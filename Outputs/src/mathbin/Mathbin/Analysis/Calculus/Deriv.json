{"zpow":
 "theorem differentiable.zpow (hf : differentiable 𝕜 f) (h : (∀ x, f x ≠ 0) ∨ 0 ≤ m) :\n    differentiable 𝕜 fun x => f x ^ m := fun x => (hf x).zpow <| h.imp_left fun h => h x\n#align differentiable.zpow differentiable.zpow\n\n",
 "unique":
 "theorem has_deriv_at.unique (h₀ : has_deriv_at f f₀' x) (h₁ : has_deriv_at f f₁' x) : f₀' = f₁' :=\n  smulRight_one_eq_iff.mp <| h₀.has_fderiv_at.unique h₁\n#align has_deriv_at.unique has_deriv_at.unique\n\n",
 "union":
 "theorem has_deriv_within_at.union (hs : has_deriv_within_at f f' s x) (ht : has_deriv_within_at f f' t x) :\n    has_deriv_within_at f f' (s ∪ t) x :=\n  hs.has_fderiv_within_at.union ht.has_fderiv_within_at\n#align has_deriv_within_at.union has_deriv_within_at.union\n\n",
 "tendsto_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem has_deriv_at.tendsto_punctured_nhds (h : has_deriv_at f f' x) (hf' : f' ≠ 0) :\n    Tendsto f (nhds_within.ne x) (nhds_within.ne (f x)) :=\n  tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ h.continuous_at.continuous_within_at (h.eventually_ne hf')\n#align has_deriv_at.tendsto_punctured_nhds has_deriv_at.tendsto_punctured_nhds\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_filter.tendsto_nhds (hL : L ≤ (nhds) x) (h : has_deriv_at_filter f f' x L) :\n    Tendsto f L ((nhds) (f x)) :=\n  h.tendsto_nhds hL\n#align has_deriv_at_filter.tendsto_nhds has_deriv_at_filter.tendsto_nhds\n\n",
 "support_deriv_subset":
 "theorem support_deriv_subset : support (deriv f) ⊆ tsupport f :=\n  by\n  intro x\n  rw [← not_imp_not]\n  intro h2x\n  rw [not_mem_tsupport_iff_eventuallyEq] at h2x\n  exact nmem_support.mpr (h2x.deriv_eq.trans (deriv_const x 0))\n#align support_deriv_subset support_deriv_subset\n\n",
 "sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem has_deriv_at.sum (h : ∀ i ∈ u, has_deriv_at (A i) (A' i) x) :\n    has_deriv_at\n      (fun y =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A' i)) x :=\n  has_deriv_at_filter.sum h\n#align has_deriv_at.sum has_deriv_at.sum\n\n",
 "sub_const":
 "theorem has_deriv_at.sub_const (hf : has_deriv_at f f' x) (c : F) : has_deriv_at (fun x => f x - c) f' x :=\n  hf.sub_const c\n#align has_deriv_at.sub_const has_deriv_at.sub_const\n\n",
 "sub":
 "theorem has_strict_deriv_at.sub (hf : has_strict_deriv_at f f' x) (hg : has_strict_deriv_at g g' x) :\n    has_strict_deriv_at (fun x => f x - g x) (f' - g') x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n#align has_strict_deriv_at.sub has_strict_deriv_at.sub\n\n",
 "smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_at.smul_const (hc : has_deriv_at c c' x) (f : F) :\n    has_deriv_at (fun y => «expr • » (c y) f) («expr • » c' f) x :=\n  by\n  rw [← has_deriv_within_at_univ] at *\n  exact hc.smul_const f\n#align has_deriv_at.smul_const has_deriv_at.smul_const\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_strict_deriv_at.smul (hc : has_strict_deriv_at c c' x) (hf : has_strict_deriv_at f f' x) :\n    has_strict_deriv_at (fun y => «expr • » (c y) (f y)) («expr • » (c x) f' + «expr • » c' (f x)) x := by\n  simpa using (hc.smul hf).has_strict_deriv_at\n#align has_strict_deriv_at.smul has_strict_deriv_at.smul\n\n",
 "scomp_has_deriv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_at.scomp_has_deriv_within_at (hg : has_deriv_at g₁ g₁' (h x)) (hh : has_deriv_within_at h h' s x) :\n    has_deriv_within_at (g₁ ∘ h) («expr • » h' g₁') s x :=\n  has_deriv_within_at.scomp x hg.has_deriv_within_at hh (mapsTo_univ _ _)\n#align has_deriv_at.scomp_has_deriv_within_at has_deriv_at.scomp_has_deriv_within_at\n\n",
 "scomp_has_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_within_at.scomp_has_deriv_at (hg : has_deriv_within_at g₁ g₁' s' (h x)) (hh : has_deriv_at h h' x)\n    (hs : ∀ x, h x ∈ s') : has_deriv_at (g₁ ∘ h) («expr • » h' g₁') x :=\n  hg.scomp x hh <| tendsto_inf.2 ⟨hh.continuous_at, tendsto_principal.2 <| eventually_of_forall hs⟩\n#align has_deriv_within_at.scomp_has_deriv_at has_deriv_within_at.scomp_has_deriv_at\n\n",
 "scomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv.scomp (hg : differentiable_at 𝕜' g₁ (h x)) (hh : differentiable_at 𝕜 h x) :\n    deriv (g₁ ∘ h) x = «expr • » (deriv h x) (deriv g₁ (h x)) :=\n  (has_deriv_at.scomp x hg.has_deriv_at hh.has_deriv_at).deriv\n#align deriv.scomp deriv.scomp\n\n",
 "prod":
 "theorem has_strict_deriv_at.prod (hf₁ : has_strict_deriv_at f₁ f₁' x) (hf₂ : has_strict_deriv_at f₂ f₂' x) :\n    has_strict_deriv_at (fun x => (f₁ x, f₂ x)) (f₁', f₂') x :=\n  hf₁.prod hf₂\n#align has_strict_deriv_at.prod has_strict_deriv_at.prod\n\n",
 "pow":
 "theorem has_deriv_at.pow (hc : has_deriv_at c c' x) :\n    has_deriv_at (fun y => c y ^ n) ((n : 𝕜) * c x ^ (n - 1) * c') x :=\n  by\n  rw [← has_deriv_within_at_univ] at *\n  exact hc.pow n\n#align has_deriv_at.pow has_deriv_at.pow\n\n",
 "of_local_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem has_deriv_at.of_local_left_inverse {f g : 𝕜 → 𝕜} {f' a : 𝕜} (hg : ContinuousAt g a)\n    (hf : has_deriv_at f f' (g a)) (hf' : f' ≠ 0)\n    (hfg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (f (g y) = y)) :\n    has_deriv_at g f'⁻¹ a :=\n  (hf.has_fderiv_at_equiv hf').of_local_left_inverse hg hfg\n#align has_deriv_at.of_local_left_inverse has_deriv_at.of_local_left_inverse\n\n",
 "not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero {f g : 𝕜 → 𝕜} {a : 𝕜} {s t : Set 𝕜}\n    (ha : a ∈ s) (hsu : unique_diff_within_at 𝕜 s a) (hf : has_deriv_within_at f 0 t (g a)) (hst : MapsTo g s t)\n    (hfg : «expr =ᶠ[ ] » (f ∘ g) (nhds_within s a) id) : ¬differentiable_within_at 𝕜 g s a :=\n  by\n  intro hg\n  have := (hf.comp a hg.has_deriv_within_at hst).congr_of_eventually_eq_of_mem hfg.symm ha\n  simpa using hsu.eq_deriv _ this (has_deriv_within_at_id _ _)\n#align not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero not_differentiable_within_at_of_local_left_inverse_has_deriv_within_at_zero\n\n",
 "not_differentiable_at_of_local_left_inverse_has_deriv_at_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem not_differentiable_at_of_local_left_inverse_has_deriv_at_zero {f g : 𝕜 → 𝕜} {a : 𝕜}\n    (hf : has_deriv_at f 0 (g a)) (hfg : «expr =ᶠ[ ] » (f ∘ g) ((nhds) a) id) : ¬differentiable_at 𝕜 g a :=\n  by\n  intro hg\n  have := (hf.comp a hg.has_deriv_at).congr_of_eventually_eq hfg.symm\n  simpa using this.unique (has_deriv_at_id a)\n#align not_differentiable_at_of_local_left_inverse_has_deriv_at_zero not_differentiable_at_of_local_left_inverse_has_deriv_at_zero\n\n",
 "nhds_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.nhds_within (h : has_deriv_within_at f f' s x) (ht : s ∈ nhds_within t x) :\n    has_deriv_within_at f f' t x :=\n  (has_deriv_within_at_inter' ht).1 (h.mono (inter_subset_right _ _))\n#align has_deriv_within_at.nhds_within has_deriv_within_at.nhds_within\n\n",
 "neg'":
 "@[simp]\ntheorem deriv.neg' : (deriv fun y => -f y) = fun x => -deriv f x :=\n  funext fun x => deriv.neg\n#align deriv.neg' deriv.neg'\n\n",
 "neg":
 "theorem deriv.neg : deriv (fun y => -f y) x = -deriv f x := by\n  simp only [deriv, fderiv_neg, ContinuousLinearMap.neg_apply]\n#align deriv.neg deriv.neg\n\n",
 "mul_const":
 "theorem has_strict_deriv_at.mul_const (hc : has_strict_deriv_at c c' x) (d : 𝔸) :\n    has_strict_deriv_at (fun y => c y * d) (c' * d) x :=\n  by\n  convert hc.mul (has_strict_deriv_at_const x d)\n  rw [MulZeroClass.mul_zero, add_zero]\n#align has_strict_deriv_at.mul_const has_strict_deriv_at.mul_const\n\n",
 "mul":
 "theorem has_strict_deriv_at.mul (hc : has_strict_deriv_at c c' x) (hd : has_strict_deriv_at d d' x) :\n    has_strict_deriv_at (fun y => c y * d y) (c' * d x + c x * d') x :=\n  by\n  have := (has_strict_fderiv_at.mul' hc hd).has_strict_deriv_at\n  rwa [ContinuousLinearMap.add_apply, ContinuousLinearMap.smul_apply, ContinuousLinearMap.smulRight_apply,\n    ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply, one_smul,\n    one_smul, add_comm] at this\n#align has_strict_deriv_at.mul has_strict_deriv_at.mul\n\n",
 "mono":
 "theorem has_deriv_within_at.mono (h : has_deriv_within_at f f' t x) (hst : s ⊆ t) : has_deriv_within_at f f' s x :=\n  has_fderiv_within_at.mono h hst\n#align has_deriv_within_at.mono has_deriv_within_at.mono\n\n",
 "limsup_slope_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > ‖f'‖` the ratio\n`(‖f z‖ - ‖f x‖) / ‖z - x‖` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `‖f'‖`.\n\nThis lemma is a weaker version of `has_deriv_within_at.limsup_norm_slope_le`\nwhere `‖f z‖ - ‖f x‖` is replaced by `‖f z - f x‖`. -/\ntheorem has_deriv_within_at.limsup_slope_norm_le (hf : has_deriv_within_at f f' s x) (hr : «expr‖ ‖» f' < r) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within s x) ((«expr‖ ‖» (z - x))⁻¹ * («expr‖ ‖» (f z) - «expr‖ ‖» (f x)) < r) :=\n  by\n  apply (hf.limsup_norm_slope_le hr).mono\n  intro z hz\n  refine' lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) _) hz\n  exact inv_nonneg.2 (norm_nonneg _)\n#align has_deriv_within_at.limsup_slope_norm_le has_deriv_within_at.limsup_slope_norm_le\n\n",
 "limsup_slope_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.limsup_slope_le' (hf : has_deriv_within_at f f' s x) (hs : x ∉ s) (hr : f' < r) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within s x) (slope f x z < r) :=\n  (has_deriv_within_at_iff_tendsto_slope' hs).1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n#align has_deriv_within_at.limsup_slope_le' has_deriv_within_at.limsup_slope_le'\n\n",
 "limsup_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.limsup_slope_le (hf : has_deriv_within_at f f' s x) (hr : f' < r) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within (s \\ {x}) x) (slope f x z < r) :=\n  has_deriv_within_at_iff_tendsto_slope.1 hf (IsOpen.mem_nhds isOpen_Iio hr)\n#align has_deriv_within_at.limsup_slope_le has_deriv_within_at.limsup_slope_le\n\n",
 "limsup_norm_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has derivative `f'` within `s` at `x`, then for any `r > ‖f'‖` the ratio\n`‖f z - f x‖ / ‖z - x‖` is less than `r` in some neighborhood of `x` within `s`.\nIn other words, the limit superior of this ratio as `z` tends to `x` along `s`\nis less than or equal to `‖f'‖`. -/\ntheorem has_deriv_within_at.limsup_norm_slope_le (hf : has_deriv_within_at f f' s x) (hr : «expr‖ ‖» f' < r) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within s x) ((«expr‖ ‖» (z - x))⁻¹ * «expr‖ ‖» (f z - f x) < r) :=\n  by\n  have hr₀ : 0 < r := lt_of_le_of_lt (norm_nonneg f') hr\n  have A :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within (s \\ {x}) x) («expr‖ ‖» («expr • » (z - x)⁻¹ (f z - f x)) ∈ Iio r) :=\n    (has_deriv_within_at_iff_tendsto_slope.1 hf).norm (IsOpen.mem_nhds isOpen_Iio hr)\n  have B :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within {x} x) («expr‖ ‖» («expr • » (z - x)⁻¹ (f z - f x)) ∈ Iio r) :=\n    mem_of_superset self_mem_nhdsWithin (singleton_subset_iff.2 <| by simp [hr₀])\n  have C := mem_sup.2 ⟨A, B⟩\n  rw [← nhdsWithin_union, diff_union_self, nhdsWithin_union, mem_sup] at C\n  filter_upwards [C.1]\n  simp only [norm_smul, mem_Iio, norm_inv]\n  exact fun _ => id\n#align has_deriv_within_at.limsup_norm_slope_le has_deriv_within_at.limsup_norm_slope_le\n\n",
 "liminf_right_slope_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has derivative `f'` within `(x, +∞)` at `x`, then for any `r > ‖f'‖` the ratio\n`(‖f z‖ - ‖f x‖) / (z - x)` is frequently less than `r` as `z → x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `‖f'‖`.\n\nSee also\n\n* `has_deriv_within_at.limsup_norm_slope_le` for a stronger version using\n  limit superior and any set `s`;\n* `has_deriv_within_at.liminf_right_norm_slope_le` for a stronger version using\n  `‖f z - f x‖` instead of `‖f z‖ - ‖f x‖`. -/\ntheorem has_deriv_within_at.liminf_right_slope_norm_le (hf : has_deriv_within_at f f' (Ici x) x)\n    (hr : «expr‖ ‖» f' < r) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      (nhds_within.gt x) ((z - x)⁻¹ * («expr‖ ‖» (f z) - «expr‖ ‖» (f x)) < r) :=\n  by\n  have := (hf.Ioi_of_Ici.limsup_slope_norm_le hr).frequently\n  refine' this.mp (eventually.mono self_mem_nhdsWithin _)\n  intro z hxz hz\n  rwa [Real.norm_eq_abs, abs_of_pos (sub_pos_of_lt hxz)] at hz\n#align has_deriv_within_at.liminf_right_slope_norm_le has_deriv_within_at.liminf_right_slope_norm_le\n\n",
 "liminf_right_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\ntheorem has_deriv_within_at.liminf_right_slope_le (hf : has_deriv_within_at f f' (Ici x) x) (hr : f' < r) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      (nhds_within.gt x) (slope f x z < r) :=\n  (hf.Ioi_of_Ici.limsup_slope_le' (lt_irrefl x) hr).frequently\n#align has_deriv_within_at.liminf_right_slope_le has_deriv_within_at.liminf_right_slope_le\n\n",
 "liminf_right_norm_slope_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- If `f` has derivative `f'` within `(x, +∞)` at `x`, then for any `r > ‖f'‖` the ratio\n`‖f z - f x‖ / ‖z - x‖` is frequently less than `r` as `z → x+0`.\nIn other words, the limit inferior of this ratio as `z` tends to `x+0`\nis less than or equal to `‖f'‖`. See also `has_deriv_within_at.limsup_norm_slope_le`\nfor a stronger version using limit superior and any set `s`. -/\ntheorem has_deriv_within_at.liminf_right_norm_slope_le (hf : has_deriv_within_at f f' (Ici x) x)\n    (hr : «expr‖ ‖» f' < r) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n      (nhds_within.gt x) ((«expr‖ ‖» (z - x))⁻¹ * «expr‖ ‖» (f z - f x) < r) :=\n  (hf.Ioi_of_Ici.limsup_norm_slope_le hr).frequently\n#align has_deriv_within_at.liminf_right_norm_slope_le has_deriv_within_at.liminf_right_norm_slope_le\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem has_strict_deriv_at.iterate {f : 𝕜 → 𝕜} {f' : 𝕜} (hf : has_strict_deriv_at f f' x) (hx : f x = x)\n    (n : ℕ) : has_strict_deriv_at («expr ^[ ]» f n) (f' ^ n) x :=\n  by\n  have := hf.iterate hx n\n  rwa [ContinuousLinearMap.smulRight_one_pow] at this\n#align has_strict_deriv_at.iterate has_strict_deriv_at.iterate\n\n",
 "iter_deriv_zpow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem iter_deriv_zpow' (m : ℤ) (k : ℕ) :\n    ((«expr ^[ ]» deriv k) fun x : 𝕜 => x ^ m) = fun x =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (m - i) *\n        x ^ (m - k) :=\n  by\n  induction' k with k ihk\n  · simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero, Function.iterate_zero]\n  ·\n    simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow', Finset.prod_range_succ,\n      Int.ofNat_succ, ← sub_sub, Int.cast_sub, Int.cast_ofNat, mul_assoc]\n#align iter_deriv_zpow' iter_deriv_zpow'\n\n",
 "iter_deriv_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem iter_deriv_zpow (m : ℤ) (x : 𝕜) (k : ℕ) :\n    («expr ^[ ]» deriv k) (fun y => y ^ m) x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (m - i) *\n        x ^ (m - k) :=\n  congr_fun (iter_deriv_zpow' m k) x\n#align iter_deriv_zpow iter_deriv_zpow\n\n",
 "iter_deriv_pow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem iter_deriv_pow' (n k : ℕ) :\n    ((«expr ^[ ]» deriv k) fun x : 𝕜 => x ^ n) = fun x =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (n - i) *\n        x ^ (n - k) :=\n  funext fun x => iter_deriv_pow n x k\n#align iter_deriv_pow' iter_deriv_pow'\n\n",
 "iter_deriv_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem iter_deriv_pow (n : ℕ) (x : 𝕜) (k : ℕ) :\n    («expr ^[ ]» deriv k) (fun x : 𝕜 => x ^ n) x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (n - i) *\n        x ^ (n - k) :=\n  by\n  simp only [← zpow_ofNat, iter_deriv_zpow, Int.cast_ofNat]\n  cases' le_or_lt k n with hkn hnk\n  · rw [Int.ofNat_sub hkn]\n  · have :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (n - i : 𝕜) =\n        0 :=\n      Finset.prod_eq_zero (Finset.mem_range.2 hnk) (sub_self _)\n    simp only [this, MulZeroClass.zero_mul]\n#align iter_deriv_pow iter_deriv_pow\n\n",
 "iter_deriv_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem iter_deriv_inv' (k : ℕ) :\n    («expr ^[ ]» deriv k) has_inv.inv = fun x : 𝕜 =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (-1 - i) *\n        x ^ (-1 - k : ℤ) :=\n  funext (iter_deriv_inv k)\n#align iter_deriv_inv' iter_deriv_inv'\n\n",
 "iter_deriv_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem iter_deriv_inv (k : ℕ) (x : 𝕜) :\n    («expr ^[ ]» deriv k) has_inv.inv x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Finset.range k)\n          (-1 - i) *\n        x ^ (-1 - k : ℤ) :=\n  by simpa only [zpow_neg_one, Int.cast_neg, Int.cast_one] using iter_deriv_zpow (-1) x k\n#align iter_deriv_inv iter_deriv_inv\n\n",
 "is_O_sub_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem has_deriv_at_filter.is_O_sub_rev (hf : has_deriv_at_filter f f' x L) (hf' : f' ≠ 0) :\n    «expr =O[ ] » (fun x' => x' - x) L fun x' => f x' - f x :=\n  suffices AntilipschitzWith («expr‖ ‖₊» f')⁻¹ (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) f') from hf.is_O_sub_rev this\n  AddMonoidHomClass.antilipschitz_of_bound (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) f') fun x => by\n    simp [norm_smul, ← div_eq_inv_mul, mul_div_cancel _ (mt norm_eq_zero.1 hf')]\n#align has_deriv_at_filter.is_O_sub_rev has_deriv_at_filter.is_O_sub_rev\n\n",
 "is_O_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem has_deriv_at_filter.is_O_sub (h : has_deriv_at_filter f f' x L) :\n    «expr =O[ ] » (fun x' => f x' - f x) L fun x' => x' - x :=\n  has_fderiv_at_filter.is_O_sub h\n#align has_deriv_at_filter.is_O_sub has_deriv_at_filter.is_O_sub\n\n",
 "inv":
 "@[simp]\ntheorem differentiable.inv (hf : differentiable 𝕜 h) (hz : ∀ x, h x ≠ 0) : differentiable 𝕜 fun x => (h x)⁻¹ := fun x =>\n  (hf x).inv (hz x)\n#align differentiable.inv differentiable.inv\n\n",
 "has_strict_fderiv_at_iff_has_strict_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_strict_fderiv_at_iff_has_strict_deriv_at {f' : «expr →L[ ] » 𝕜 𝕜 F} :\n    has_strict_fderiv_at f f' x ↔ has_strict_deriv_at f (f' 1) x := by simp [has_strict_deriv_at, has_strict_fderiv_at]\n#align has_strict_fderiv_at_iff_has_strict_deriv_at has_strict_fderiv_at_iff_has_strict_deriv_at\n\n",
 "has_strict_fderiv_at_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_strict_deriv_at.has_strict_fderiv_at_equiv {f : 𝕜 → 𝕜} {f' x : 𝕜} (hf : has_strict_deriv_at f f' x)\n    (hf' : f' ≠ 0) :\n    has_strict_fderiv_at f (ContinuousLinearEquiv.unitsEquivAut 𝕜 (Units.mk0 f' hf') : «expr →L[ ] » 𝕜 𝕜 𝕜) x :=\n  hf\n#align has_strict_deriv_at.has_strict_fderiv_at_equiv has_strict_deriv_at.has_strict_fderiv_at_equiv\n\n",
 "has_strict_deriv_at_zpow":
 "theorem has_strict_deriv_at_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) :\n    has_strict_deriv_at (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) x :=\n  by\n  have : ∀ m : ℤ, 0 < m → has_strict_deriv_at (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) x :=\n    by\n    intro m hm\n    lift m to ℕ using le_of_lt hm\n    simp only [zpow_ofNat, Int.cast_ofNat]\n    convert has_strict_deriv_at_pow _ _ using 2\n    rw [← Int.ofNat_one, ← Int.ofNat_sub, zpow_ofNat]\n    norm_cast  at hm\n    exact nat.succ_le_of_lt hm\n  rcases lt_trichotomy m 0 with (hm | hm | hm)\n  · have hx : x ≠ 0 := h.resolve_right hm.not_le\n    have := (has_strict_deriv_at_inv _).scomp _ (this (-m) (neg_pos.2 hm)) <;> [skip,\n      exact zpow_ne_zero_of_ne_zero hx _]\n    simp only [(· ∘ ·), zpow_neg, one_div, inv_inv, smul_eq_mul] at this\n    convert this using 1\n    rw [sq, mul_inv, inv_inv, Int.cast_neg, neg_mul, neg_mul_neg, ← zpow_add₀ hx, mul_assoc, ← zpow_add₀ hx]\n    congr\n    abel\n  · simp only [hm, zpow_zero, Int.cast_zero, MulZeroClass.zero_mul, has_strict_deriv_at_const]\n  · exact this m hm\n#align has_strict_deriv_at_zpow has_strict_deriv_at_zpow\n\n",
 "has_strict_deriv_at_symm":
 "/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has a\nnonzero derivative `f'` at `f.symm a` in the strict sense, then `f.symm` has the derivative `f'⁻¹`\nat `a` in the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_strict_deriv_at_symm (f : LocalHomeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.target)\n    (hf' : f' ≠ 0) (htff' : has_strict_deriv_at f f' (f.symm a)) : has_strict_deriv_at f.symm f'⁻¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) hf' (f.eventually_right_inverse ha)\n#align local_homeomorph.has_strict_deriv_at_symm local_homeomorph.has_strict_deriv_at_symm\n\n",
 "has_strict_deriv_at_pow":
 "theorem has_strict_deriv_at_pow (n : ℕ) (x : 𝕜) : has_strict_deriv_at (fun x => x ^ n) ((n : 𝕜) * x ^ (n - 1)) x :=\n  by\n  convert(Polynomial.C (1 : 𝕜) * Polynomial.X ^ n).has_strict_deriv_at x\n  · simp\n  · rw [Polynomial.derivative_C_mul_X_pow]\n    simp\n#align has_strict_deriv_at_pow has_strict_deriv_at_pow\n\n",
 "has_strict_deriv_at_pi":
 "@[simp]\ntheorem has_strict_deriv_at_pi : has_strict_deriv_at φ φ' x ↔ ∀ i, has_strict_deriv_at (fun x => φ x i) (φ' i) x :=\n  has_strict_fderiv_at_pi'\n#align has_strict_deriv_at_pi has_strict_deriv_at_pi\n\n",
 "has_strict_deriv_at_neg":
 "theorem has_strict_deriv_at_neg : has_strict_deriv_at has_neg.neg (-1) x :=\n  has_strict_deriv_at.neg <| has_strict_deriv_at_id _\n#align has_strict_deriv_at_neg has_strict_deriv_at_neg\n\n",
 "has_strict_deriv_at_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_strict_deriv_at_inv (hx : x ≠ 0) : has_strict_deriv_at has_inv.inv (-(x ^ 2)⁻¹) x :=\n  by\n  suffices\n    «expr =o[ ] » (fun p : 𝕜 × 𝕜 => (p.1 - p.2) * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) ((nhds) (x, x)) fun p => (p.1 - p.2) * 1\n    by\n    refine' this.congr' _ (eventually_of_forall fun _ => mul_one _)\n    refine' eventually.mono (IsOpen.mem_nhds (is_open_ne.prod isOpen_ne) ⟨hx, hx⟩) _\n    rintro ⟨y, z⟩ ⟨hy, hz⟩\n    simp only [mem_set_of_eq] at hy hz\n    -- hy : y ≠ 0, hz : z ≠ 0\n    field_simp [hx, hy, hz]\n    ring\n  refine' (is_O_refl (fun p : 𝕜 × 𝕜 => p.1 - p.2) _).mul_is_o ((is_o_one_iff _).2 _)\n  rw [← sub_self (x * x)⁻¹]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).inv₀ <| mul_ne_zero hx hx)\n#align has_strict_deriv_at_inv has_strict_deriv_at_inv\n\n",
 "has_strict_deriv_at_iff_has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_strict_deriv_at_iff_has_strict_fderiv_at :\n    has_strict_deriv_at f f' x ↔ has_strict_fderiv_at f (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) f') x :=\n  iff.rfl\n#align has_strict_deriv_at_iff_has_strict_fderiv_at has_strict_deriv_at_iff_has_strict_fderiv_at\n\n",
 "has_strict_deriv_at_id":
 "theorem has_strict_deriv_at_id : has_strict_deriv_at id 1 x :=\n  (has_strict_fderiv_at_id x).has_strict_deriv_at\n#align has_strict_deriv_at_id has_strict_deriv_at_id\n\n",
 "has_strict_deriv_at_const":
 "theorem has_strict_deriv_at_const : has_strict_deriv_at (fun x => c) 0 x :=\n  (has_strict_fderiv_at_const c x).has_strict_deriv_at\n#align has_strict_deriv_at_const has_strict_deriv_at_const\n\n",
 "has_strict_deriv_at":
 "/-- The derivative (in the analysis sense) of a polynomial `p` is given by `p.derivative`. -/\nprotected theorem has_strict_deriv_at (x : 𝕜) : has_strict_deriv_at (fun x => p.eval x) (p.derivative.eval x) x :=\n  by\n  apply p.induction_on\n  · simp [has_strict_deriv_at_const]\n  · intro p q hp hq\n    convert hp.add hq <;> simp\n  · intro n a h\n    convert h.mul (has_strict_deriv_at_id x)\n    · ext y\n      simp [pow_add, mul_assoc]\n    · simp only [pow_add, pow_one, derivative_mul, derivative_C, MulZeroClass.zero_mul, derivative_X_pow, derivative_X,\n        mul_one, zero_add, eval_mul, eval_C, eval_add, eval_nat_cast, eval_pow, eval_X, id.def]\n      ring\n#align has_strict_deriv_at has_strict_deriv_at\n\n",
 "has_fderiv_within_at_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_within_at_inv (x_ne_zero : x ≠ 0) :\n    has_fderiv_within_at (fun x => x⁻¹) (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (-(x ^ 2)⁻¹) : «expr →L[ ] » 𝕜 𝕜 𝕜) s x :=\n  (has_fderiv_at_inv x_ne_zero).has_fderiv_within_at\n#align has_fderiv_within_at_inv has_fderiv_within_at_inv\n\n",
 "has_fderiv_within_at_iff_has_deriv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Expressing `has_fderiv_within_at f f' s x` in terms of `has_deriv_within_at` -/\ntheorem has_fderiv_within_at_iff_has_deriv_within_at {f' : «expr →L[ ] » 𝕜 𝕜 F} :\n    has_fderiv_within_at f f' s x ↔ has_deriv_within_at f (f' 1) s x :=\n  has_fderiv_at_filter_iff_has_deriv_at_filter\n#align has_fderiv_within_at_iff_has_deriv_within_at has_fderiv_within_at_iff_has_deriv_within_at\n\n",
 "has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\nprotected theorem has_fderiv_within_at (x : 𝕜) :\n    has_fderiv_within_at (fun x => p.eval x) (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (p.derivative.eval x)) s x :=\n  (p.has_fderiv_at x).has_fderiv_within_at\n#align has_fderiv_within_at has_fderiv_within_at\n\n",
 "has_fderiv_at_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_fderiv_at_inv (x_ne_zero : x ≠ 0) :\n    has_fderiv_at (fun x => x⁻¹) (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (-(x ^ 2)⁻¹) : «expr →L[ ] » 𝕜 𝕜 𝕜) x :=\n  has_deriv_at_inv x_ne_zero\n#align has_fderiv_at_inv has_fderiv_at_inv\n\n",
 "has_fderiv_at_iff_has_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Expressing `has_fderiv_at f f' x` in terms of `has_deriv_at` -/\ntheorem has_fderiv_at_iff_has_deriv_at {f' : «expr →L[ ] » 𝕜 𝕜 F} : has_fderiv_at f f' x ↔ has_deriv_at f (f' 1) x :=\n  has_fderiv_at_filter_iff_has_deriv_at_filter\n#align has_fderiv_at_iff_has_deriv_at has_fderiv_at_iff_has_deriv_at\n\n",
 "has_fderiv_at_filter_iff_has_deriv_at_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-\nCopyright (c) 2019 Gabriel Ebner. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Gabriel Ebner, Sébastien Gouëzel\n-/\n/-- Expressing `has_fderiv_at_filter f f' x L` in terms of `has_deriv_at_filter` -/\ntheorem has_fderiv_at_filter_iff_has_deriv_at_filter {f' : «expr →L[ ] » 𝕜 𝕜 F} :\n    has_fderiv_at_filter f f' x L ↔ has_deriv_at_filter f (f' 1) x L := by simp [has_deriv_at_filter]\n#align has_fderiv_at_filter_iff_has_deriv_at_filter has_fderiv_at_filter_iff_has_deriv_at_filter\n\n",
 "has_fderiv_at_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem has_deriv_at.has_fderiv_at_equiv {f : 𝕜 → 𝕜} {f' x : 𝕜} (hf : has_deriv_at f f' x) (hf' : f' ≠ 0) :\n    has_fderiv_at f (ContinuousLinearEquiv.unitsEquivAut 𝕜 (Units.mk0 f' hf') : «expr →L[ ] » 𝕜 𝕜 𝕜) x :=\n  hf\n#align has_deriv_at.has_fderiv_at_equiv has_deriv_at.has_fderiv_at_equiv\n\n",
 "has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\nprotected theorem has_fderiv_at (x : 𝕜) :\n    has_fderiv_at (fun x => p.eval x) (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (p.derivative.eval x)) x :=\n  p.has_deriv_at x\n#align has_fderiv_at has_fderiv_at\n\n",
 "has_deriv_within_at_zpow":
 "theorem has_deriv_within_at_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) (s : Set 𝕜) :\n    has_deriv_within_at (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) s x :=\n  (has_deriv_at_zpow m x h).has_deriv_within_at\n#align has_deriv_within_at_zpow has_deriv_within_at_zpow\n\n",
 "has_deriv_within_at_univ":
 "@[simp]\ntheorem has_deriv_within_at_univ : has_deriv_within_at f f' univ x ↔ has_deriv_at f f' x :=\n  has_fderiv_within_at_univ\n#align has_deriv_within_at_univ has_deriv_within_at_univ\n\n",
 "has_deriv_within_at_pow":
 "theorem has_deriv_within_at_pow (n : ℕ) (x : 𝕜) (s : Set 𝕜) :\n    has_deriv_within_at (fun x => x ^ n) ((n : 𝕜) * x ^ (n - 1)) s x :=\n  (has_deriv_at_pow n x).has_deriv_within_at\n#align has_deriv_within_at_pow has_deriv_within_at_pow\n\n",
 "has_deriv_within_at_pi":
 "theorem has_deriv_within_at_pi : has_deriv_within_at φ φ' s x ↔ ∀ i, has_deriv_within_at (fun x => φ x i) (φ' i) s x :=\n  has_deriv_at_filter_pi\n#align has_deriv_within_at_pi has_deriv_within_at_pi\n\n",
 "has_deriv_within_at_neg":
 "theorem has_deriv_within_at_neg : has_deriv_within_at has_neg.neg (-1) s x :=\n  has_deriv_at_filter_neg _ _\n#align has_deriv_within_at_neg has_deriv_within_at_neg\n\n",
 "has_deriv_within_at_inv":
 "theorem has_deriv_within_at_inv (x_ne_zero : x ≠ 0) (s : Set 𝕜) : has_deriv_within_at (fun x => x⁻¹) (-(x ^ 2)⁻¹) s x :=\n  (has_deriv_at_inv x_ne_zero).has_deriv_within_at\n#align has_deriv_within_at_inv has_deriv_within_at_inv\n\n",
 "has_deriv_within_at_inter'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at_inter' (h : t ∈ nhds_within s x) :\n    has_deriv_within_at f f' (s ∩ t) x ↔ has_deriv_within_at f f' s x :=\n  has_fderiv_within_at_inter' h\n#align has_deriv_within_at_inter' has_deriv_within_at_inter'\n\n",
 "has_deriv_within_at_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_inter (h : t ∈ (nhds) x) :\n    has_deriv_within_at f f' (s ∩ t) x ↔ has_deriv_within_at f f' s x :=\n  has_fderiv_within_at_inter h\n#align has_deriv_within_at_inter has_deriv_within_at_inter\n\n",
 "has_deriv_within_at_iff_tendsto_slope'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_iff_tendsto_slope' (hs : x ∉ s) :\n    has_deriv_within_at f f' s x ↔ Tendsto (slope f x) (nhds_within s x) ((nhds) f') :=\n  by\n  convert← has_deriv_within_at_iff_tendsto_slope\n  exact diff_singleton_eq_self hs\n#align has_deriv_within_at_iff_tendsto_slope' has_deriv_within_at_iff_tendsto_slope'\n\n",
 "has_deriv_within_at_iff_tendsto_slope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_iff_tendsto_slope :\n    has_deriv_within_at f f' s x ↔ Tendsto (slope f x) (nhds_within (s \\ {x}) x) ((nhds) f') :=\n  by\n  simp only [has_deriv_within_at, nhdsWithin, diff_eq, inf_assoc.symm, inf_principal.symm]\n  exact has_deriv_at_filter_iff_tendsto_slope\n#align has_deriv_within_at_iff_tendsto_slope has_deriv_within_at_iff_tendsto_slope\n\n",
 "has_deriv_within_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_iff_tendsto :\n    has_deriv_within_at f f' s x ↔\n      Tendsto (fun x' => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - «expr • » (x' - x) f')) (nhds_within s x)\n        ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_deriv_within_at_iff_tendsto has_deriv_within_at_iff_tendsto\n\n",
 "has_deriv_within_at_iff_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at_iff_is_o :\n    has_deriv_within_at f f' s x ↔\n      «expr =o[ ] » (fun x' : 𝕜 => f x' - f x - «expr • » (x' - x) f') (nhds_within s x) fun x' => x' - x :=\n  iff.rfl\n#align has_deriv_within_at_iff_is_o has_deriv_within_at_iff_is_o\n\n",
 "has_deriv_within_at_iff_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Expressing `has_deriv_within_at f f' s x` in terms of `has_fderiv_within_at` -/\ntheorem has_deriv_within_at_iff_has_fderiv_within_at {f' : F} :\n    has_deriv_within_at f f' s x ↔ has_fderiv_within_at f (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) f') s x :=\n  iff.rfl\n#align has_deriv_within_at_iff_has_fderiv_within_at has_deriv_within_at_iff_has_fderiv_within_at\n\n",
 "has_deriv_within_at_id":
 "theorem has_deriv_within_at_id : has_deriv_within_at id 1 s x :=\n  has_deriv_at_filter_id _ _\n#align has_deriv_within_at_id has_deriv_within_at_id\n\n",
 "has_deriv_within_at_diff_singleton":
 "@[simp]\ntheorem has_deriv_within_at_diff_singleton : has_deriv_within_at f f' (s \\ {x}) x ↔ has_deriv_within_at f f' s x := by\n  simp only [has_deriv_within_at_iff_tendsto_slope, sdiff_idem]\n#align has_deriv_within_at_diff_singleton has_deriv_within_at_diff_singleton\n\n",
 "has_deriv_within_at_deriv_within_iff":
 "@[simp]\ntheorem has_deriv_within_at_deriv_within_iff :\n    has_deriv_within_at f (deriv_within f s x) s x ↔ differentiable_within_at 𝕜 f s x :=\n  ⟨fun h => h.differentiable_within_at, fun h => h.has_deriv_within_at⟩\n#align has_deriv_within_at_deriv_within_iff has_deriv_within_at_deriv_within_iff\n\n",
 "has_deriv_within_at_const":
 "theorem has_deriv_within_at_const : has_deriv_within_at (fun x => c) 0 s x :=\n  has_deriv_at_filter_const _ _ _\n#align has_deriv_within_at_const has_deriv_within_at_const\n\n",
 "has_deriv_within_at_congr_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_within_at_congr_set {s t u : Set 𝕜} (hu : u ∈ (nhds) x) (h : s ∩ u = t ∩ u) :\n    has_deriv_within_at f f' s x ↔ has_deriv_within_at f f' t x := by\n  simp_rw [has_deriv_within_at, nhdsWithin_eq_nhds_within' hu h]\n#align has_deriv_within_at_congr_set has_deriv_within_at_congr_set\n\n",
 "has_deriv_within_at_Ioi_iff_Ici":
 "@[simp]\ntheorem has_deriv_within_at_Ioi_iff_Ici [partial_order 𝕜] :\n    has_deriv_within_at f f' (Ioi x) x ↔ has_deriv_within_at f f' (Ici x) x := by\n  rw [← Ici_diff_left, has_deriv_within_at_diff_singleton]\n#align has_deriv_within_at_Ioi_iff_Ici has_deriv_within_at_Ioi_iff_Ici\n\n",
 "has_deriv_within_at_Iio_iff_Iic":
 "@[simp]\ntheorem has_deriv_within_at_Iio_iff_Iic [partial_order 𝕜] :\n    has_deriv_within_at f f' (Iio x) x ↔ has_deriv_within_at f f' (Iic x) x := by\n  rw [← Iic_diff_right, has_deriv_within_at_diff_singleton]\n#align has_deriv_within_at_Iio_iff_Iic has_deriv_within_at_Iio_iff_Iic\n\n",
 "has_deriv_within_at":
 "protected theorem has_deriv_within_at (x : 𝕜) (s : Set 𝕜) :\n    has_deriv_within_at (fun x => p.eval x) (p.derivative.eval x) s x :=\n  (p.has_deriv_at x).has_deriv_within_at\n#align has_deriv_within_at has_deriv_within_at\n\n",
 "has_deriv_at_zpow":
 "theorem has_deriv_at_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) :\n    has_deriv_at (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) x :=\n  (has_strict_deriv_at_zpow m x h).has_deriv_at\n#align has_deriv_at_zpow has_deriv_at_zpow\n\n",
 "has_deriv_at_symm":
 "/-- If `f` is a local homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\nnonzero derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem local_homeomorph.has_deriv_at_symm (f : LocalHomeomorph 𝕜 𝕜) {a f' : 𝕜} (ha : a ∈ f.target) (hf' : f' ≠ 0)\n    (htff' : has_deriv_at f f' (f.symm a)) : has_deriv_at f.symm f'⁻¹ a :=\n  htff'.of_local_left_inverse (f.symm.continuous_at ha) hf' (f.eventually_right_inverse ha)\n#align local_homeomorph.has_deriv_at_symm local_homeomorph.has_deriv_at_symm\n\n",
 "has_deriv_at_pow":
 "theorem has_deriv_at_pow (n : ℕ) (x : 𝕜) : has_deriv_at (fun x => x ^ n) ((n : 𝕜) * x ^ (n - 1)) x :=\n  (has_strict_deriv_at_pow n x).has_deriv_at\n#align has_deriv_at_pow has_deriv_at_pow\n\n",
 "has_deriv_at_pi":
 "theorem has_deriv_at_pi : has_deriv_at φ φ' x ↔ ∀ i, has_deriv_at (fun x => φ x i) (φ' i) x :=\n  has_deriv_at_filter_pi\n#align has_deriv_at_pi has_deriv_at_pi\n\n",
 "has_deriv_at_neg'":
 "theorem has_deriv_at_neg' : has_deriv_at (fun x => -x) (-1) x :=\n  has_deriv_at_filter_neg _ _\n#align has_deriv_at_neg' has_deriv_at_neg'\n\n",
 "has_deriv_at_neg":
 "theorem has_deriv_at_neg : has_deriv_at has_neg.neg (-1) x :=\n  has_deriv_at_filter_neg _ _\n#align has_deriv_at_neg has_deriv_at_neg\n\n",
 "has_deriv_at_mul_const":
 "theorem has_deriv_at_mul_const (c : 𝕜) : has_deriv_at (fun x => x * c) c x := by\n  simpa only [one_mul] using (has_deriv_at_id' x).mul_const c\n#align has_deriv_at_mul_const has_deriv_at_mul_const\n\n",
 "has_deriv_at_inv":
 "theorem has_deriv_at_inv (x_ne_zero : x ≠ 0) : has_deriv_at (fun y => y⁻¹) (-(x ^ 2)⁻¹) x :=\n  (has_strict_deriv_at_inv x_ne_zero).has_deriv_at\n#align has_deriv_at_inv has_deriv_at_inv\n\n",
 "has_deriv_at_iff_tendsto_slope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_tendsto_slope : has_deriv_at f f' x ↔ Tendsto (slope f x) (nhds_within.ne x) ((nhds) f') :=\n  has_deriv_at_filter_iff_tendsto_slope\n#align has_deriv_at_iff_tendsto_slope has_deriv_at_iff_tendsto_slope\n\n",
 "has_deriv_at_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_tendsto :\n    has_deriv_at f f' x ↔\n      Tendsto (fun x' => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - «expr • » (x' - x) f')) ((nhds) x)\n        ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_deriv_at_iff_tendsto has_deriv_at_iff_tendsto\n\n",
 "has_deriv_at_iff_is_o_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_is_o_nhds_zero :\n    has_deriv_at f f' x ↔ «expr =o[ ] » (fun h => f (x + h) - f x - «expr • » h f') ((nhds) 0) fun h => h :=\n  has_fderiv_at_iff_is_o_nhds_zero\n#align has_deriv_at_iff_is_o_nhds_zero has_deriv_at_iff_is_o_nhds_zero\n\n",
 "has_deriv_at_iff_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_iff_is_o :\n    has_deriv_at f f' x ↔\n      «expr =o[ ] » (fun x' : 𝕜 => f x' - f x - «expr • » (x' - x) f') ((nhds) x) fun x' => x' - x :=\n  iff.rfl\n#align has_deriv_at_iff_is_o has_deriv_at_iff_is_o\n\n",
 "has_deriv_at_iff_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Expressing `has_deriv_at f f' x` in terms of `has_fderiv_at` -/\ntheorem has_deriv_at_iff_has_fderiv_at {f' : F} :\n    has_deriv_at f f' x ↔ has_fderiv_at f (smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) f') x :=\n  iff.rfl\n#align has_deriv_at_iff_has_fderiv_at has_deriv_at_iff_has_fderiv_at\n\n",
 "has_deriv_at_id'":
 "theorem has_deriv_at_id' : has_deriv_at (fun x : 𝕜 => x) 1 x :=\n  has_deriv_at_filter_id _ _\n#align has_deriv_at_id' has_deriv_at_id'\n\n",
 "has_deriv_at_id":
 "theorem has_deriv_at_id : has_deriv_at id 1 x :=\n  has_deriv_at_filter_id _ _\n#align has_deriv_at_id has_deriv_at_id\n\n",
 "has_deriv_at_filter_pi":
 "@[simp]\ntheorem has_deriv_at_filter_pi : has_deriv_at_filter φ φ' x L ↔ ∀ i, has_deriv_at_filter (fun x => φ x i) (φ' i) x L :=\n  has_fderiv_at_filter_pi'\n#align has_deriv_at_filter_pi has_deriv_at_filter_pi\n\n",
 "has_deriv_at_filter_neg":
 "theorem has_deriv_at_filter_neg : has_deriv_at_filter has_neg.neg (-1) x L :=\n  has_deriv_at_filter.neg <| has_deriv_at_filter_id _ _\n#align has_deriv_at_filter_neg has_deriv_at_filter_neg\n\n",
 "has_deriv_at_filter_iff_tendsto_slope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.principal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the domain has dimension one, then Fréchet derivative is equivalent to the classical\ndefinition with a limit. In this version we have to take the limit along the subset `-{x}`,\nbecause for `y=x` the slope equals zero due to the convention `0⁻¹=0`. -/\ntheorem has_deriv_at_filter_iff_tendsto_slope {x : 𝕜} {L : Filter 𝕜} :\n    has_deriv_at_filter f f' x L ↔ Tendsto (slope f x) («expr ⊓ » L ((filter.principal) («expr ᶜ» {x}))) ((nhds) f') :=\n  by\n  conv_lhs =>\n    simp only [has_deriv_at_filter_iff_tendsto, (norm_inv _).symm, (norm_smul _ _).symm,\n      tendsto_zero_iff_norm_tendsto_zero.symm]\n  conv_rhs => rw [← nhds_translation_sub f', tendsto_comap_iff]\n  refine' (tendsto_inf_principal_nhds_iff_of_forall_eq <| by simp).symm.trans (tendsto_congr' _)\n  refine' (eventually_principal.2 fun z hz => _).filter_mono inf_le_right\n  simp only [(· ∘ ·)]\n  rw [smul_sub, ← mul_smul, inv_mul_cancel (sub_ne_zero.2 hz), one_smul, slope_def_module]\n#align has_deriv_at_filter_iff_tendsto_slope has_deriv_at_filter_iff_tendsto_slope\n\n",
 "has_deriv_at_filter_iff_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at_filter_iff_tendsto :\n    has_deriv_at_filter f f' x L ↔\n      Tendsto (fun x' : 𝕜 => («expr‖ ‖» (x' - x))⁻¹ * «expr‖ ‖» (f x' - f x - «expr • » (x' - x) f')) L ((nhds) 0) :=\n  has_fderiv_at_filter_iff_tendsto\n#align has_deriv_at_filter_iff_tendsto has_deriv_at_filter_iff_tendsto\n\n",
 "has_deriv_at_filter_iff_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_at_filter_iff_is_o :\n    has_deriv_at_filter f f' x L ↔\n      «expr =o[ ] » (fun x' : 𝕜 => f x' - f x - «expr • » (x' - x) f') L fun x' => x' - x :=\n  iff.rfl\n#align has_deriv_at_filter_iff_is_o has_deriv_at_filter_iff_is_o\n\n",
 "has_deriv_at_filter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\ntheorem filter.eventually_eq.has_deriv_at_filter_iff (h₀ : «expr =ᶠ[ ] » f₀ L f₁) (hx : f₀ x = f₁ x) (h₁ : f₀' = f₁') :\n    has_deriv_at_filter f₀ f₀' x L ↔ has_deriv_at_filter f₁ f₁' x L :=\n  h₀.has_fderiv_at_filter_iff hx (by simp [h₁])\n#align filter.eventually_eq.has_deriv_at_filter_iff filter.eventually_eq.has_deriv_at_filter_iff\n\n",
 "has_deriv_at_filter_id":
 "theorem has_deriv_at_filter_id : has_deriv_at_filter id 1 x L :=\n  (has_fderiv_at_filter_id x L).has_deriv_at_filter\n#align has_deriv_at_filter_id has_deriv_at_filter_id\n\n",
 "has_deriv_at_filter_const":
 "theorem has_deriv_at_filter_const : has_deriv_at_filter (fun x => c) 0 x L :=\n  (has_fderiv_at_filter_const c x L).has_deriv_at_filter\n#align has_deriv_at_filter_const has_deriv_at_filter_const\n\n",
 "has_deriv_at_filter":
 "protected theorem linear_map.has_deriv_at_filter : has_deriv_at_filter e (e 1) x L :=\n  e.to_continuous_linear_map₁.has_deriv_at_filter\n#align linear_map.has_deriv_at_filter linear_map.has_deriv_at_filter\n\n",
 "has_deriv_at_deriv_iff":
 "@[simp]\ntheorem has_deriv_at_deriv_iff : has_deriv_at f (deriv f x) x ↔ differentiable_at 𝕜 f x :=\n  ⟨fun h => h.differentiable_at, fun h => h.has_deriv_at⟩\n#align has_deriv_at_deriv_iff has_deriv_at_deriv_iff\n\n",
 "has_deriv_at_const":
 "theorem has_deriv_at_const : has_deriv_at (fun x => c) 0 x :=\n  has_deriv_at_filter_const _ _ _\n#align has_deriv_at_const has_deriv_at_const\n\n",
 "has_deriv_at":
 "/-- The derivative (in the analysis sense) of a polynomial `p` is given by `p.derivative`. -/\nprotected theorem has_deriv_at (x : 𝕜) : has_deriv_at (fun x => p.eval x) (p.derivative.eval x) x :=\n  (p.has_strict_deriv_at x).has_deriv_at\n#align has_deriv_at has_deriv_at\n\n",
 "fderiv_within_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem fderiv_within_inv (x_ne_zero : x ≠ 0) (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun x => x⁻¹) s x = smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (-(x ^ 2)⁻¹) :=\n  by\n  rw [differentiable_at.fderiv_within (differentiable_at_inv.2 x_ne_zero) hxs]\n  exact fderiv_inv\n#align fderiv_within_inv fderiv_within_inv\n\n",
 "fderiv_within_deriv_within":
 "theorem fderiv_within_deriv_within : (fderiv_within 𝕜 f s x : 𝕜 → F) 1 = deriv_within f s x :=\n  rfl\n#align fderiv_within_deriv_within fderiv_within_deriv_within\n\n",
 "fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\nprotected theorem fderiv_within (hxs : unique_diff_within_at 𝕜 s x) :\n    fderiv_within 𝕜 (fun x => p.eval x) s x = smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (p.derivative.eval x) :=\n  (p.has_fderiv_within_at x).fderiv_within hxs\n#align fderiv_within fderiv_within\n\n",
 "fderiv_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem fderiv_inv : fderiv 𝕜 (fun x => x⁻¹) x = smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (-(x ^ 2)⁻¹) := by\n  rw [← deriv_fderiv, deriv_inv]\n#align fderiv_inv fderiv_inv\n\n",
 "fderiv_deriv":
 "theorem fderiv_deriv : (fderiv 𝕜 f x : 𝕜 → F) 1 = deriv f x :=\n  rfl\n#align fderiv_deriv fderiv_deriv\n\n",
 "fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\nprotected theorem fderiv : fderiv 𝕜 (fun x => p.eval x) x = smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (p.derivative.eval x) :=\n  (p.has_fderiv_at x).fderiv\n#align fderiv fderiv\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\ntheorem has_deriv_at.eventually_ne (h : has_deriv_at f f' x) (hf' : f' ≠ 0) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      (nhds_within.ne x) (f z ≠ f x) :=\n  (has_deriv_at_iff_has_fderiv_at.1 h).eventually_ne\n    ⟨(«expr‖ ‖» f')⁻¹, fun z => by field_simp [norm_smul, mt norm_eq_zero.1 hf'] ⟩\n#align has_deriv_at.eventually_ne has_deriv_at.eventually_ne\n\n",
 "eq_deriv":
 "theorem unique_diff_within_at.eq_deriv (s : Set 𝕜) (H : unique_diff_within_at 𝕜 s x) (h : has_deriv_within_at f f' s x)\n    (h₁ : has_deriv_within_at f f₁' s x) : f' = f₁' :=\n  smulRight_one_eq_iff.mp <| unique_diff_within_at.eq H h h₁\n#align unique_diff_within_at.eq_deriv unique_diff_within_at.eq_deriv\n\n",
 "div_const":
 "@[simp]\ntheorem differentiable.div_const (hc : differentiable 𝕜 c) (d : 𝕜') : differentiable 𝕜 fun x => c x / d := fun x =>\n  (hc x).div_const d\n#align differentiable.div_const differentiable.div_const\n\n",
 "div":
 "@[simp]\ntheorem differentiable.div (hc : differentiable 𝕜 c) (hd : differentiable 𝕜 d) (hx : ∀ x, d x ≠ 0) :\n    differentiable 𝕜 fun x => c x / d x := fun x => (hc x).div (hd x) (hx x)\n#align differentiable.div differentiable.div\n\n",
 "differentiable_within_at_zpow":
 "theorem differentiable_within_at_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) :\n    differentiable_within_at 𝕜 (fun x => x ^ m) s x :=\n  (differentiable_at_zpow.mpr h).differentiable_within_at\n#align differentiable_within_at_zpow differentiable_within_at_zpow\n\n",
 "differentiable_within_at_pow":
 "theorem differentiable_within_at_pow : differentiable_within_at 𝕜 (fun x => x ^ n) s x :=\n  (differentiable_at_pow n).differentiable_within_at\n#align differentiable_within_at_pow differentiable_within_at_pow\n\n",
 "differentiable_within_at_of_deriv_within_ne_zero":
 "theorem differentiable_within_at_of_deriv_within_ne_zero (h : deriv_within f s x ≠ 0) :\n    differentiable_within_at 𝕜 f s x :=\n  not_imp_comm.1 deriv_within_zero_of_not_differentiable_within_at h\n#align differentiable_within_at_of_deriv_within_ne_zero differentiable_within_at_of_deriv_within_ne_zero\n\n",
 "differentiable_within_at_inv":
 "theorem differentiable_within_at_inv (x_ne_zero : x ≠ 0) : differentiable_within_at 𝕜 (fun x => x⁻¹) s x :=\n  (differentiable_at_inv.2 x_ne_zero).differentiable_within_at\n#align differentiable_within_at_inv differentiable_within_at_inv\n\n",
 "differentiable_within_at_Ioi_iff_Ici":
 "theorem differentiable_within_at_Ioi_iff_Ici [partial_order 𝕜] :\n    differentiable_within_at 𝕜 f (Ioi x) x ↔ differentiable_within_at 𝕜 f (Ici x) x :=\n  ⟨fun h => h.has_deriv_within_at.Ici_of_Ioi.differentiable_within_at, fun h =>\n    h.has_deriv_within_at.Ioi_of_Ici.differentiable_within_at⟩\n#align differentiable_within_at_Ioi_iff_Ici differentiable_within_at_Ioi_iff_Ici\n\n",
 "differentiable_within_at":
 "protected theorem differentiable_within_at : differentiable_within_at 𝕜 (fun x => p.eval x) s x :=\n  p.differentiable_at.differentiable_within_at\n#align differentiable_within_at differentiable_within_at\n\n",
 "differentiable_pow":
 "theorem differentiable_pow : differentiable 𝕜 fun x : 𝕜 => x ^ n := fun x => differentiable_at_pow n\n#align differentiable_pow differentiable_pow\n\n",
 "differentiable_on_zpow":
 "theorem differentiable_on_zpow (m : ℤ) (s : Set 𝕜) (h : (0 : 𝕜) ∉ s ∨ 0 ≤ m) : differentiable_on 𝕜 (fun x => x ^ m) s :=\n  fun x hxs => differentiable_within_at_zpow m x <| h.imp_left <| ne_of_mem_of_not_mem hxs\n#align differentiable_on_zpow differentiable_on_zpow\n\n",
 "differentiable_on_pow":
 "theorem differentiable_on_pow : differentiable_on 𝕜 (fun x => x ^ n) s :=\n  (differentiable_pow n).differentiable_on\n#align differentiable_on_pow differentiable_on_pow\n\n",
 "differentiable_on_neg":
 "theorem differentiable_on_neg : differentiable_on 𝕜 (has_neg.neg : 𝕜 → 𝕜) s :=\n  differentiable_on.neg differentiable_on_id\n#align differentiable_on_neg differentiable_on_neg\n\n",
 "differentiable_on_inv":
 "theorem differentiable_on_inv : differentiable_on 𝕜 (fun x : 𝕜 => x⁻¹) { x | x ≠ 0 } := fun x hx =>\n  differentiable_within_at_inv hx\n#align differentiable_on_inv differentiable_on_inv\n\n",
 "differentiable_on":
 "protected theorem differentiable_on : differentiable_on 𝕜 (fun x => p.eval x) s :=\n  p.differentiable.differentiable_on\n#align differentiable_on differentiable_on\n\n",
 "differentiable_neg":
 "theorem differentiable_neg : differentiable 𝕜 (has_neg.neg : 𝕜 → 𝕜) :=\n  differentiable.neg differentiable_id\n#align differentiable_neg differentiable_neg\n\n",
 "differentiable_at_zpow":
 "theorem differentiable_at_zpow : differentiable_at 𝕜 (fun x => x ^ m) x ↔ x ≠ 0 ∨ 0 ≤ m :=\n  ⟨fun H => NormedField.continuousAt_zpow.1 H.continuous_at, fun H => (has_deriv_at_zpow m x H).differentiable_at⟩\n#align differentiable_at_zpow differentiable_at_zpow\n\n",
 "differentiable_at_pow":
 "theorem differentiable_at_pow : differentiable_at 𝕜 (fun x => x ^ n) x :=\n  (has_deriv_at_pow n x).differentiable_at\n#align differentiable_at_pow differentiable_at_pow\n\n",
 "differentiable_at_of_deriv_ne_zero":
 "theorem differentiable_at_of_deriv_ne_zero (h : deriv f x ≠ 0) : differentiable_at 𝕜 f x :=\n  not_imp_comm.1 deriv_zero_of_not_differentiable_at h\n#align differentiable_at_of_deriv_ne_zero differentiable_at_of_deriv_ne_zero\n\n",
 "differentiable_at_inv":
 "theorem differentiable_at_inv : differentiable_at 𝕜 (fun x => x⁻¹) x ↔ x ≠ 0 :=\n  ⟨fun H => NormedField.continuousAt_inv.1 H.continuous_at, fun H => (has_deriv_at_inv H).differentiable_at⟩\n#align differentiable_at_inv differentiable_at_inv\n\n",
 "differentiable_at":
 "protected theorem differentiable_at : differentiable_at 𝕜 (fun x => p.eval x) x :=\n  (p.has_deriv_at x).differentiable_at\n#align differentiable_at differentiable_at\n\n",
 "differentiable":
 "protected theorem differentiable : differentiable 𝕜 fun x => p.eval x := fun x => p.differentiable_at\n#align differentiable differentiable\n\n",
 "deriv_zpow'":
 "@[simp]\ntheorem deriv_zpow' (m : ℤ) : (deriv fun x : 𝕜 => x ^ m) = fun x => m * x ^ (m - 1) :=\n  funext <| deriv_zpow m\n#align deriv_zpow' deriv_zpow'\n\n",
 "deriv_zpow":
 "theorem deriv_zpow (m : ℤ) (x : 𝕜) : deriv (fun x => x ^ m) x = m * x ^ (m - 1) :=\n  by\n  by_cases H : x ≠ 0 ∨ 0 ≤ m\n  · exact (has_deriv_at_zpow m x H).deriv\n  · rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_zpow.1 H)]\n    push_neg  at H\n    rcases H with ⟨rfl, hm⟩\n    rw [zero_zpow _ ((sub_one_lt _).trans hm).ne, MulZeroClass.mul_zero]\n#align deriv_zpow deriv_zpow\n\n",
 "deriv_zero_of_not_differentiable_at":
 "theorem deriv_zero_of_not_differentiable_at (h : ¬differentiable_at 𝕜 f x) : deriv f x = 0 :=\n  by\n  unfold deriv\n  rw [fderiv_zero_of_not_differentiable_at]\n  simp\n  assumption\n#align deriv_zero_of_not_differentiable_at deriv_zero_of_not_differentiable_at\n\n",
 "deriv_within_zpow":
 "theorem deriv_within_zpow (hxs : unique_diff_within_at 𝕜 s x) (h : x ≠ 0 ∨ 0 ≤ m) :\n    deriv_within (fun x => x ^ m) s x = (m : 𝕜) * x ^ (m - 1) :=\n  (has_deriv_within_at_zpow m x h s).deriv_within hxs\n#align deriv_within_zpow deriv_within_zpow\n\n",
 "deriv_within_zero_of_not_differentiable_within_at":
 "theorem deriv_within_zero_of_not_differentiable_within_at (h : ¬differentiable_within_at 𝕜 f s x) :\n    deriv_within f s x = 0 := by\n  unfold deriv_within\n  rw [fderiv_within_zero_of_not_differentiable_within_at]\n  simp\n  assumption\n#align deriv_within_zero_of_not_differentiable_within_at deriv_within_zero_of_not_differentiable_within_at\n\n",
 "deriv_within_univ":
 "@[simp]\ntheorem deriv_within_univ : deriv_within f univ = deriv f :=\n  by\n  ext\n  unfold deriv_within deriv\n  rw [fderiv_within_univ]\n#align deriv_within_univ deriv_within_univ\n\n",
 "deriv_within_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem deriv_within_sum (hxs : unique_diff_within_at 𝕜 s x) (h : ∀ i ∈ u, differentiable_within_at 𝕜 (A i) s x) :\n    deriv_within\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        s x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (deriv_within (A i) s x) :=\n  (has_deriv_within_at.sum fun i hi => (h i hi).has_deriv_within_at).deriv_within hxs\n#align deriv_within_sum deriv_within_sum\n\n",
 "deriv_within_subset":
 "theorem deriv_within_subset (st : s ⊆ t) (ht : unique_diff_within_at 𝕜 s x) (h : differentiable_within_at 𝕜 f t x) :\n    deriv_within f s x = deriv_within f t x :=\n  ((differentiable_within_at.has_deriv_within_at h).mono st).deriv_within ht\n#align deriv_within_subset deriv_within_subset\n\n",
 "deriv_within_sub_const":
 "theorem deriv_within_sub_const (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    deriv_within (fun y => f y - c) s x = deriv_within f s x := by simp only [deriv_within, fderiv_within_sub_const hxs]\n#align deriv_within_sub_const deriv_within_sub_const\n\n",
 "deriv_within_sub":
 "theorem deriv_within_sub (hxs : unique_diff_within_at 𝕜 s x) (hf : differentiable_within_at 𝕜 f s x)\n    (hg : differentiable_within_at 𝕜 g s x) :\n    deriv_within (fun y => f y - g y) s x = deriv_within f s x - deriv_within g s x :=\n  (hf.has_deriv_within_at.sub hg.has_deriv_within_at).deriv_within hxs\n#align deriv_within_sub deriv_within_sub\n\n",
 "deriv_within_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv_within_smul_const (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x) (f : F) :\n    deriv_within (fun y => «expr • » (c y) f) s x = «expr • » (deriv_within c s x) f :=\n  (hc.has_deriv_within_at.smul_const f).deriv_within hxs\n#align deriv_within_smul_const deriv_within_smul_const\n\n",
 "deriv_within_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv_within_smul (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hf : differentiable_within_at 𝕜 f s x) :\n    deriv_within (fun y => «expr • » (c y) (f y)) s x =\n      «expr • » (c x) (deriv_within f s x) + «expr • » (deriv_within c s x) (f x) :=\n  (hc.has_deriv_within_at.smul hf.has_deriv_within_at).deriv_within hxs\n#align deriv_within_smul deriv_within_smul\n\n",
 "deriv_within_pow'":
 "theorem deriv_within_pow' (hc : differentiable_within_at 𝕜 c s x) (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => c x ^ n) s x = (n : 𝕜) * c x ^ (n - 1) * deriv_within c s x :=\n  (hc.has_deriv_within_at.pow n).deriv_within hxs\n#align deriv_within_pow' deriv_within_pow'\n\n",
 "deriv_within_pow":
 "theorem deriv_within_pow (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => x ^ n) s x = (n : 𝕜) * x ^ (n - 1) :=\n  (has_deriv_within_at_pow n x s).deriv_within hxs\n#align deriv_within_pow deriv_within_pow\n\n",
 "deriv_within_pi":
 "theorem deriv_within_pi (h : ∀ i, differentiable_within_at 𝕜 (fun x => φ x i) s x) (hs : unique_diff_within_at 𝕜 s x) :\n    deriv_within φ s x = fun i => deriv_within (fun x => φ x i) s x :=\n  (has_deriv_within_at_pi.2 fun i => (h i).has_deriv_within_at).deriv_within hs\n#align deriv_within_pi deriv_within_pi\n\n",
 "deriv_within_of_open":
 "theorem deriv_within_of_open (hs : IsOpen s) (hx : x ∈ s) : deriv_within f s x = deriv f x :=\n  by\n  unfold deriv_within\n  rw [fderiv_within_of_open hs hx]\n  rfl\n#align deriv_within_of_open deriv_within_of_open\n\n",
 "deriv_within_neg":
 "theorem deriv_within_neg (hxs : unique_diff_within_at 𝕜 s x) : deriv_within has_neg.neg s x = -1 :=\n  (has_deriv_within_at_neg x s).deriv_within hxs\n#align deriv_within_neg deriv_within_neg\n\n",
 "deriv_within_mul_const":
 "theorem deriv_within_mul_const (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x) (d : 𝔸) :\n    deriv_within (fun y => c y * d) s x = deriv_within c s x * d :=\n  (hc.has_deriv_within_at.mul_const d).deriv_within hxs\n#align deriv_within_mul_const deriv_within_mul_const\n\n",
 "deriv_within_mul":
 "theorem deriv_within_mul (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hd : differentiable_within_at 𝕜 d s x) :\n    deriv_within (fun y => c y * d y) s x = deriv_within c s x * d x + c x * deriv_within d s x :=\n  (hc.has_deriv_within_at.mul hd.has_deriv_within_at).deriv_within hxs\n#align deriv_within_mul deriv_within_mul\n\n",
 "deriv_within_mem_iff":
 "theorem deriv_within_mem_iff {f : 𝕜 → F} {t : Set 𝕜} {s : Set F} {x : 𝕜} :\n    deriv_within f t x ∈ s ↔\n      differentiable_within_at 𝕜 f t x ∧ deriv_within f t x ∈ s ∨ ¬differentiable_within_at 𝕜 f t x ∧ (0 : F) ∈ s :=\n  by by_cases hx : differentiable_within_at 𝕜 f t x <;> simp [deriv_within_zero_of_not_differentiable_within_at, *]\n#align deriv_within_mem_iff deriv_within_mem_iff\n\n",
 "deriv_within_inv'":
 "theorem deriv_within_inv' (hc : differentiable_within_at 𝕜 c s x) (hx : c x ≠ 0) (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => (c x)⁻¹) s x = -deriv_within c s x / c x ^ 2 :=\n  (hc.has_deriv_within_at.inv hx).deriv_within hxs\n#align deriv_within_inv' deriv_within_inv'\n\n",
 "deriv_within_inv":
 "theorem deriv_within_inv (x_ne_zero : x ≠ 0) (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => x⁻¹) s x = -(x ^ 2)⁻¹ :=\n  by\n  rw [differentiable_at.deriv_within (differentiable_at_inv.2 x_ne_zero) hxs]\n  exact deriv_inv\n#align deriv_within_inv deriv_within_inv\n\n",
 "deriv_within_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem deriv_within_inter (ht : t ∈ (nhds) x) (hs : unique_diff_within_at 𝕜 s x) :\n    deriv_within f (s ∩ t) x = deriv_within f s x :=\n  by\n  unfold deriv_within\n  rw [fderiv_within_inter ht hs]\n#align deriv_within_inter deriv_within_inter\n\n",
 "deriv_within_id":
 "theorem deriv_within_id (hxs : unique_diff_within_at 𝕜 s x) : deriv_within id s x = 1 :=\n  (has_deriv_within_at_id x s).deriv_within hxs\n#align deriv_within_id deriv_within_id\n\n",
 "deriv_within_fderiv_within":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem deriv_within_fderiv_within : smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (deriv_within f s x) = fderiv_within 𝕜 f s x :=\n  by simp [deriv_within]\n#align deriv_within_fderiv_within deriv_within_fderiv_within\n\n",
 "deriv_within_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem filter.eventually_eq.deriv_within_eq (hs : unique_diff_within_at 𝕜 s x)\n    (hL : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : f₁ x = f x) : deriv_within f₁ s x = deriv_within f s x :=\n  by\n  unfold deriv_within\n  rw [hL.fderiv_within_eq hs hx]\n#align filter.eventually_eq.deriv_within_eq filter.eventually_eq.deriv_within_eq\n\n",
 "deriv_within_div_const":
 "theorem deriv_within_div_const (hc : differentiable_within_at 𝕜 c s x) (d : 𝕜') (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => c x / d) s x = deriv_within c s x / d := by\n  simp [div_eq_inv_mul, deriv_within_const_mul, hc, hxs]\n#align deriv_within_div_const deriv_within_div_const\n\n",
 "deriv_within_div":
 "theorem deriv_within_div (hc : differentiable_within_at 𝕜 c s x) (hd : differentiable_within_at 𝕜 d s x) (hx : d x ≠ 0)\n    (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => c x / d x) s x = (deriv_within c s x * d x - c x * deriv_within d s x) / d x ^ 2 :=\n  (hc.has_deriv_within_at.div hd.has_deriv_within_at hx).deriv_within hxs\n#align deriv_within_div deriv_within_div\n\n",
 "deriv_within_const_sub":
 "theorem deriv_within_const_sub (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    deriv_within (fun y => c - f y) s x = -deriv_within f s x := by simp [deriv_within, fderiv_within_const_sub hxs]\n#align deriv_within_const_sub deriv_within_const_sub\n\n",
 "deriv_within_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv_within_const_smul (hxs : unique_diff_within_at 𝕜 s x) (c : R) (hf : differentiable_within_at 𝕜 f s x) :\n    deriv_within (fun y => «expr • » c (f y)) s x = «expr • » c (deriv_within f s x) :=\n  (hf.has_deriv_within_at.const_smul c).deriv_within hxs\n#align deriv_within_const_smul deriv_within_const_smul\n\n",
 "deriv_within_const_mul":
 "theorem deriv_within_const_mul (hxs : unique_diff_within_at 𝕜 s x) (c : 𝔸) (hd : differentiable_within_at 𝕜 d s x) :\n    deriv_within (fun y => c * d y) s x = c * deriv_within d s x :=\n  (hd.has_deriv_within_at.const_mul c).deriv_within hxs\n#align deriv_within_const_mul deriv_within_const_mul\n\n",
 "deriv_within_const_add":
 "theorem deriv_within_const_add (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    deriv_within (fun y => c + f y) s x = deriv_within f s x := by simp only [deriv_within, fderiv_within_const_add hxs]\n#align deriv_within_const_add deriv_within_const_add\n\n",
 "deriv_within_const":
 "theorem deriv_within_const (hxs : unique_diff_within_at 𝕜 s x) : deriv_within (fun x => c) s x = 0 :=\n  (has_deriv_within_at_const _ _ _).deriv_within hxs\n#align deriv_within_const deriv_within_const\n\n",
 "deriv_within_congr":
 "theorem deriv_within_congr (hs : unique_diff_within_at 𝕜 s x) (hL : ∀ y ∈ s, f₁ y = f y) (hx : f₁ x = f x) :\n    deriv_within f₁ s x = deriv_within f s x := by\n  unfold deriv_within\n  rw [fderiv_within_congr hs hL hx]\n#align deriv_within_congr deriv_within_congr\n\n",
 "deriv_within_clm_comp":
 "theorem deriv_within_clm_comp (hc : differentiable_within_at 𝕜 c s x) (hd : differentiable_within_at 𝕜 d s x)\n    (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun y => (c y).comp (d y)) s x = (deriv_within c s x).comp (d x) + (c x).comp (deriv_within d s x) :=\n  (hc.has_deriv_within_at.clm_comp hd.has_deriv_within_at).deriv_within hxs\n#align deriv_within_clm_comp deriv_within_clm_comp\n\n",
 "deriv_within_clm_apply":
 "theorem deriv_within_clm_apply (hxs : unique_diff_within_at 𝕜 s x) (hc : differentiable_within_at 𝕜 c s x)\n    (hu : differentiable_within_at 𝕜 u s x) :\n    deriv_within (fun y => (c y) (u y)) s x = deriv_within c s x (u x) + c x (deriv_within u s x) :=\n  (hc.has_deriv_within_at.clm_apply hu.has_deriv_within_at).deriv_within hxs\n#align deriv_within_clm_apply deriv_within_clm_apply\n\n",
 "deriv_within_add_const":
 "theorem deriv_within_add_const (hxs : unique_diff_within_at 𝕜 s x) (c : F) :\n    deriv_within (fun y => f y + c) s x = deriv_within f s x := by simp only [deriv_within, fderiv_within_add_const hxs]\n#align deriv_within_add_const deriv_within_add_const\n\n",
 "deriv_within_add":
 "theorem deriv_within_add (hxs : unique_diff_within_at 𝕜 s x) (hf : differentiable_within_at 𝕜 f s x)\n    (hg : differentiable_within_at 𝕜 g s x) :\n    deriv_within (fun y => f y + g y) s x = deriv_within f s x + deriv_within g s x :=\n  (hf.has_deriv_within_at.add hg.has_deriv_within_at).deriv_within hxs\n#align deriv_within_add deriv_within_add\n\n",
 "deriv_within_Ioi_eq_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem deriv_within_Ioi_eq_Ici {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E] (f : exprℝ → E)\n    (x : exprℝ) : deriv_within f (Ioi x) x = deriv_within f (Ici x) x :=\n  by\n  by_cases H : differentiable_within_at (exprℝ) f (Ioi x) x\n  · have A := H.has_deriv_within_at.Ici_of_Ioi\n    have B := (differentiable_within_at_Ioi_iff_Ici.1 H).has_deriv_within_at\n    simpa using (unique_diff_on_Ici x).eq le_rfl A B\n  · rw [deriv_within_zero_of_not_differentiable_within_at H, deriv_within_zero_of_not_differentiable_within_at]\n    rwa [differentiable_within_at_Ioi_iff_Ici] at H\n#align deriv_within_Ioi_eq_Ici deriv_within_Ioi_eq_Ici\n\n",
 "deriv_within":
 "protected theorem deriv_within (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (fun x => p.eval x) s x = p.derivative.eval x :=\n  by\n  rw [differentiable_at.deriv_within p.differentiable_at hxs]\n  exact p.deriv\n#align deriv_within deriv_within\n\n",
 "deriv_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem deriv_sum (h : ∀ i ∈ u, differentiable_at 𝕜 (A i) x) :\n    deriv\n        (fun y =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u (A i y))\n        x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" u\n        (deriv (A i) x) :=\n  (has_deriv_at.sum fun i hi => (h i hi).has_deriv_at).deriv\n#align deriv_sum deriv_sum\n\n",
 "deriv_sub_const":
 "theorem deriv_sub_const (c : F) : deriv (fun y => f y - c) x = deriv f x := by simp only [deriv, fderiv_sub_const]\n#align deriv_sub_const deriv_sub_const\n\n",
 "deriv_sub":
 "@[simp]\ntheorem deriv_sub (hf : differentiable_at 𝕜 f x) (hg : differentiable_at 𝕜 g x) :\n    deriv (fun y => f y - g y) x = deriv f x - deriv g x :=\n  (hf.has_deriv_at.sub hg.has_deriv_at).deriv\n#align deriv_sub deriv_sub\n\n",
 "deriv_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv_smul_const (hc : differentiable_at 𝕜 c x) (f : F) :\n    deriv (fun y => «expr • » (c y) f) x = «expr • » (deriv c x) f :=\n  (hc.has_deriv_at.smul_const f).deriv\n#align deriv_smul_const deriv_smul_const\n\n",
 "deriv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv_smul (hc : differentiable_at 𝕜 c x) (hf : differentiable_at 𝕜 f x) :\n    deriv (fun y => «expr • » (c y) (f y)) x = «expr • » (c x) (deriv f x) + «expr • » (deriv c x) (f x) :=\n  (hc.has_deriv_at.smul hf.has_deriv_at).deriv\n#align deriv_smul deriv_smul\n\n",
 "deriv_pow''":
 "@[simp]\ntheorem deriv_pow'' (hc : differentiable_at 𝕜 c x) : deriv (fun x => c x ^ n) x = (n : 𝕜) * c x ^ (n - 1) * deriv c x :=\n  (hc.has_deriv_at.pow n).deriv\n#align deriv_pow'' deriv_pow''\n\n",
 "deriv_pow'":
 "@[simp]\ntheorem deriv_pow' : (deriv fun x => x ^ n) = fun x => (n : 𝕜) * x ^ (n - 1) :=\n  funext fun x => deriv_pow n\n#align deriv_pow' deriv_pow'\n\n",
 "deriv_pow":
 "theorem deriv_pow : deriv (fun x => x ^ n) x = (n : 𝕜) * x ^ (n - 1) :=\n  (has_deriv_at_pow n x).deriv\n#align deriv_pow deriv_pow\n\n",
 "deriv_pi":
 "theorem deriv_pi (h : ∀ i, differentiable_at 𝕜 (fun x => φ x i) x) : deriv φ x = fun i => deriv (fun x => φ x i) x :=\n  (has_deriv_at_pi.2 fun i => (h i).has_deriv_at).deriv\n#align deriv_pi deriv_pi\n\n",
 "deriv_neg''":
 "@[simp]\ntheorem deriv_neg'' : deriv (fun x : 𝕜 => -x) x = -1 :=\n  deriv_neg x\n#align deriv_neg'' deriv_neg''\n\n",
 "deriv_neg'":
 "@[simp]\ntheorem deriv_neg' : deriv (has_neg.neg : 𝕜 → 𝕜) = fun _ => -1 :=\n  funext deriv_neg\n#align deriv_neg' deriv_neg'\n\n",
 "deriv_neg":
 "theorem deriv_neg : deriv has_neg.neg x = -1 :=\n  has_deriv_at.deriv (has_deriv_at_neg x)\n#align deriv_neg deriv_neg\n\n",
 "deriv_mul_const_field'":
 "@[simp]\ntheorem deriv_mul_const_field' (v : 𝕜') : (deriv fun x => u x * v) = fun x => deriv u x * v :=\n  funext fun _ => deriv_mul_const_field v\n#align deriv_mul_const_field' deriv_mul_const_field'\n\n",
 "deriv_mul_const_field":
 "theorem deriv_mul_const_field (v : 𝕜') : deriv (fun y => u y * v) x = deriv u x * v :=\n  by\n  by_cases hu : differentiable_at 𝕜 u x\n  · exact deriv_mul_const hu v\n  · rw [deriv_zero_of_not_differentiable_at hu, MulZeroClass.zero_mul]\n    rcases eq_or_ne v 0 with (rfl | hd)\n    · simp only [MulZeroClass.mul_zero, deriv_const]\n    · refine' deriv_zero_of_not_differentiable_at (mt (fun H => _) hu)\n      simpa only [mul_inv_cancel_right₀ hd] using H.mul_const v⁻¹\n#align deriv_mul_const_field deriv_mul_const_field\n\n",
 "deriv_mul_const":
 "theorem deriv_mul_const (hc : differentiable_at 𝕜 c x) (d : 𝔸) : deriv (fun y => c y * d) x = deriv c x * d :=\n  (hc.has_deriv_at.mul_const d).deriv\n#align deriv_mul_const deriv_mul_const\n\n",
 "deriv_mul":
 "@[simp]\ntheorem deriv_mul (hc : differentiable_at 𝕜 c x) (hd : differentiable_at 𝕜 d x) :\n    deriv (fun y => c y * d y) x = deriv c x * d x + c x * deriv d x :=\n  (hc.has_deriv_at.mul hd.has_deriv_at).deriv\n#align deriv_mul deriv_mul\n\n",
 "deriv_mem_iff":
 "theorem deriv_mem_iff {f : 𝕜 → F} {s : Set F} {x : 𝕜} :\n    deriv f x ∈ s ↔ differentiable_at 𝕜 f x ∧ deriv f x ∈ s ∨ ¬differentiable_at 𝕜 f x ∧ (0 : F) ∈ s := by\n  by_cases hx : differentiable_at 𝕜 f x <;> simp [deriv_zero_of_not_differentiable_at, *]\n#align deriv_mem_iff deriv_mem_iff\n\n",
 "deriv_inv''":
 "@[simp]\ntheorem deriv_inv'' (hc : differentiable_at 𝕜 c x) (hx : c x ≠ 0) : deriv (fun x => (c x)⁻¹) x = -deriv c x / c x ^ 2 :=\n  (hc.has_deriv_at.inv hx).deriv\n#align deriv_inv'' deriv_inv''\n\n",
 "deriv_inv'":
 "@[simp]\ntheorem deriv_inv' : (deriv fun x : 𝕜 => x⁻¹) = fun x => -(x ^ 2)⁻¹ :=\n  funext fun x => deriv_inv\n#align deriv_inv' deriv_inv'\n\n",
 "deriv_inv":
 "theorem deriv_inv : deriv (fun x => x⁻¹) x = -(x ^ 2)⁻¹ :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  · simp [deriv_zero_of_not_differentiable_at (mt differentiable_at_inv.1 (Classical.not_not.2 rfl))]\n  · exact (has_deriv_at_inv hne).deriv\n#align deriv_inv deriv_inv\n\n",
 "deriv_id''":
 "@[simp]\ntheorem deriv_id'' : (deriv fun x : 𝕜 => x) = fun _ => 1 :=\n  deriv_id'\n#align deriv_id'' deriv_id''\n\n",
 "deriv_id'":
 "@[simp]\ntheorem deriv_id' : deriv (@id 𝕜) = fun _ => 1 :=\n  funext deriv_id\n#align deriv_id' deriv_id'\n\n",
 "deriv_id":
 "theorem deriv_id : deriv id x = 1 :=\n  has_deriv_at.deriv (has_deriv_at_id x)\n#align deriv_id deriv_id\n\n",
 "deriv_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem deriv_fderiv : smulRight (1 : «expr →L[ ] » 𝕜 𝕜 𝕜) (deriv f x) = fderiv 𝕜 f x := by simp [deriv]\n#align deriv_fderiv deriv_fderiv\n\n",
 "deriv_eq_zero":
 "theorem has_deriv_within_at.deriv_eq_zero (hd : has_deriv_within_at f 0 s x) (H : unique_diff_within_at 𝕜 s x) :\n    deriv f x = 0 :=\n  (em' (differentiable_at 𝕜 f x)).elim deriv_zero_of_not_differentiable_at fun h =>\n    H.eq_deriv _ h.has_deriv_at.has_deriv_within_at hd\n#align has_deriv_within_at.deriv_eq_zero has_deriv_within_at.deriv_eq_zero\n\n",
 "deriv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter.eventually_eq.deriv_eq (hL : «expr =ᶠ[ ] » f₁ ((nhds) x) f) : deriv f₁ x = deriv f x :=\n  by\n  unfold deriv\n  rwa [filter.eventually_eq.fderiv_eq]\n#align filter.eventually_eq.deriv_eq filter.eventually_eq.deriv_eq\n\n",
 "deriv_div_const":
 "@[simp]\ntheorem deriv_div_const (d : 𝕜') : deriv (fun x => c x / d) x = deriv c x / d := by\n  simp only [div_eq_mul_inv, deriv_mul_const_field]\n#align deriv_div_const deriv_div_const\n\n",
 "deriv_div":
 "@[simp]\ntheorem deriv_div (hc : differentiable_at 𝕜 c x) (hd : differentiable_at 𝕜 d x) (hx : d x ≠ 0) :\n    deriv (fun x => c x / d x) x = (deriv c x * d x - c x * deriv d x) / d x ^ 2 :=\n  (hc.has_deriv_at.div hd.has_deriv_at hx).deriv\n#align deriv_div deriv_div\n\n",
 "deriv_const_sub":
 "theorem deriv_const_sub (c : F) : deriv (fun y => c - f y) x = -deriv f x := by\n  simp only [← deriv_within_univ, deriv_within_const_sub (unique_diff_within_at_univ : unique_diff_within_at 𝕜 _ _)]\n#align deriv_const_sub deriv_const_sub\n\n",
 "deriv_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem deriv_const_smul (c : R) (hf : differentiable_at 𝕜 f x) :\n    deriv (fun y => «expr • » c (f y)) x = «expr • » c (deriv f x) :=\n  (hf.has_deriv_at.const_smul c).deriv\n#align deriv_const_smul deriv_const_smul\n\n",
 "deriv_const_mul_field'":
 "@[simp]\ntheorem deriv_const_mul_field' (u : 𝕜') : (deriv fun x => u * v x) = fun x => u * deriv v x :=\n  funext fun x => deriv_const_mul_field u\n#align deriv_const_mul_field' deriv_const_mul_field'\n\n",
 "deriv_const_mul_field":
 "theorem deriv_const_mul_field (u : 𝕜') : deriv (fun y => u * v y) x = u * deriv v x := by\n  simp only [mul_comm u, deriv_mul_const_field]\n#align deriv_const_mul_field deriv_const_mul_field\n\n",
 "deriv_const_mul":
 "theorem deriv_const_mul (c : 𝔸) (hd : differentiable_at 𝕜 d x) : deriv (fun y => c * d y) x = c * deriv d x :=\n  (hd.has_deriv_at.const_mul c).deriv\n#align deriv_const_mul deriv_const_mul\n\n",
 "deriv_const_add'":
 "@[simp]\ntheorem deriv_const_add' (c : F) : (deriv fun y => c + f y) = deriv f :=\n  funext fun x => deriv_const_add c\n#align deriv_const_add' deriv_const_add'\n\n",
 "deriv_const_add":
 "theorem deriv_const_add (c : F) : deriv (fun y => c + f y) x = deriv f x := by simp only [deriv, fderiv_const_add]\n#align deriv_const_add deriv_const_add\n\n",
 "deriv_const'":
 "@[simp]\ntheorem deriv_const' : (deriv fun x : 𝕜 => c) = fun x => 0 :=\n  funext fun x => deriv_const x c\n#align deriv_const' deriv_const'\n\n",
 "deriv_const":
 "theorem deriv_const : deriv (fun x => c) x = 0 :=\n  has_deriv_at.deriv (has_deriv_at_const x c)\n#align deriv_const deriv_const\n\n",
 "deriv_clm_comp":
 "theorem deriv_clm_comp (hc : differentiable_at 𝕜 c x) (hd : differentiable_at 𝕜 d x) :\n    deriv (fun y => (c y).comp (d y)) x = (deriv c x).comp (d x) + (c x).comp (deriv d x) :=\n  (hc.has_deriv_at.clm_comp hd.has_deriv_at).deriv\n#align deriv_clm_comp deriv_clm_comp\n\n",
 "deriv_clm_apply":
 "theorem deriv_clm_apply (hc : differentiable_at 𝕜 c x) (hu : differentiable_at 𝕜 u x) :\n    deriv (fun y => (c y) (u y)) x = deriv c x (u x) + c x (deriv u x) :=\n  (hc.has_deriv_at.clm_apply hu.has_deriv_at).deriv\n#align deriv_clm_apply deriv_clm_apply\n\n",
 "deriv_add_const'":
 "@[simp]\ntheorem deriv_add_const' (c : F) : (deriv fun y => f y + c) = deriv f :=\n  funext fun x => deriv_add_const c\n#align deriv_add_const' deriv_add_const'\n\n",
 "deriv_add_const":
 "theorem deriv_add_const (c : F) : deriv (fun y => f y + c) x = deriv f x := by simp only [deriv, fderiv_add_const]\n#align deriv_add_const deriv_add_const\n\n",
 "deriv_add":
 "@[simp]\ntheorem deriv_add (hf : differentiable_at 𝕜 f x) (hg : differentiable_at 𝕜 g x) :\n    deriv (fun y => f y + g y) x = deriv f x + deriv g x :=\n  (hf.has_deriv_at.add hg.has_deriv_at).deriv\n#align deriv_add deriv_add\n\n",
 "deriv":
 "theorem has_compact_support.deriv (hf : HasCompactSupport f) : HasCompactSupport (deriv f) :=\n  hf.mono' support_deriv_subset\n#align has_compact_support.deriv has_compact_support.deriv\n\n",
 "continuous_within_at":
 "theorem has_deriv_within_at.continuous_within_at (h : has_deriv_within_at f f' s x) : ContinuousWithinAt f s x :=\n  has_deriv_at_filter.tendsto_nhds inf_le_left h\n#align has_deriv_within_at.continuous_within_at has_deriv_within_at.continuous_within_at\n\n",
 "continuous_on":
 "protected theorem has_deriv_at.continuous_on {f f' : 𝕜 → F} (hderiv : ∀ x ∈ s, has_deriv_at f (f' x) x) :\n    ContinuousOn f s := fun x hx => (hderiv x hx).continuous_at.continuous_within_at\n#align has_deriv_at.continuous_on has_deriv_at.continuous_on\n\n",
 "continuous_at":
 "theorem has_deriv_at.continuous_at (h : has_deriv_at f f' x) : ContinuousAt f x :=\n  has_deriv_at_filter.tendsto_nhds le_rfl h\n#align has_deriv_at.continuous_at has_deriv_at.continuous_at\n\n",
 "const_sub":
 "theorem has_deriv_at.const_sub (c : F) (hf : has_deriv_at f f' x) : has_deriv_at (fun x => c - f x) (-f') x :=\n  hf.const_sub c\n#align has_deriv_at.const_sub has_deriv_at.const_sub\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_at.const_smul (c : R) (hf : has_deriv_at f f' x) :\n    has_deriv_at (fun y => «expr • » c (f y)) («expr • » c f') x :=\n  hf.const_smul c\n#align has_deriv_at.const_smul has_deriv_at.const_smul\n\n",
 "const_mul":
 "theorem has_strict_deriv_at.const_mul (c : 𝔸) (hd : has_strict_deriv_at d d' x) :\n    has_strict_deriv_at (fun y => c * d y) (c * d') x :=\n  by\n  convert(has_strict_deriv_at_const _ _).mul hd\n  rw [MulZeroClass.zero_mul, zero_add]\n#align has_strict_deriv_at.const_mul has_strict_deriv_at.const_mul\n\n",
 "const_add":
 "theorem has_deriv_at.const_add (c : F) (hf : has_deriv_at f f' x) : has_deriv_at (fun x => c + f x) f' x :=\n  hf.const_add c\n#align has_deriv_at.const_add has_deriv_at.const_add\n\n",
 "congr_of_mem":
 "theorem has_deriv_within_at.congr_of_mem (h : has_deriv_within_at f f' s x) (hs : ∀ x ∈ s, f₁ x = f x) (hx : x ∈ s) :\n    has_deriv_within_at f₁ f' s x :=\n  h.congr hs (hs _ hx)\n#align has_deriv_within_at.congr_of_mem has_deriv_within_at.congr_of_mem\n\n",
 "congr_of_eventually_eq_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\ntheorem has_deriv_within_at.congr_of_eventually_eq_of_mem (h : has_deriv_within_at f f' s x)\n    (h₁ : «expr =ᶠ[ ] » f₁ (nhds_within s x) f) (hx : x ∈ s) : has_deriv_within_at f₁ f' s x :=\n  h.congr_of_eventually_eq h₁ (h₁.eq_of_nhds_within hx)\n#align has_deriv_within_at.congr_of_eventually_eq_of_mem has_deriv_within_at.congr_of_eventually_eq_of_mem\n\n",
 "congr_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem has_deriv_at.congr_of_eventually_eq (h : has_deriv_at f f' x) (h₁ : «expr =ᶠ[ ] » f₁ ((nhds) x) f) :\n    has_deriv_at f₁ f' x :=\n  has_deriv_at_filter.congr_of_eventually_eq h h₁ (mem_of_mem_nhds h₁ : _)\n#align has_deriv_at.congr_of_eventually_eq has_deriv_at.congr_of_eventually_eq\n\n",
 "congr_mono":
 "theorem has_deriv_within_at.congr_mono (h : has_deriv_within_at f f' s x) (ht : ∀ x ∈ t, f₁ x = f x) (hx : f₁ x = f x)\n    (h₁ : t ⊆ s) : has_deriv_within_at f₁ f' t x :=\n  has_fderiv_within_at.congr_mono h ht hx h₁\n#align has_deriv_within_at.congr_mono has_deriv_within_at.congr_mono\n\n",
 "congr":
 "theorem has_deriv_within_at.congr (h : has_deriv_within_at f f' s x) (hs : ∀ x ∈ s, f₁ x = f x) (hx : f₁ x = f x) :\n    has_deriv_within_at f₁ f' s x :=\n  h.congr_mono hs hx (Subset.refl _)\n#align has_deriv_within_at.congr has_deriv_within_at.congr\n\n",
 "comp_has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_strict_deriv_at.comp_has_strict_fderiv_at {f : E → 𝕜'} {f' : «expr →L[ ] » E 𝕜 𝕜'} (x)\n    (hh : has_strict_deriv_at h₂ h₂' (f x)) (hf : has_strict_fderiv_at f f' x) :\n    has_strict_fderiv_at (h₂ ∘ f) («expr • » h₂' f') x :=\n  by\n  rw [has_strict_deriv_at] at hh\n  convert(hh.restrict_scalars 𝕜).comp x hf\n  ext x\n  simp [mul_comm]\n#align has_strict_deriv_at.comp_has_strict_fderiv_at has_strict_deriv_at.comp_has_strict_fderiv_at\n\n",
 "comp_has_strict_deriv_at":
 "theorem has_strict_fderiv_at.comp_has_strict_deriv_at (hl : has_strict_fderiv_at l l' (f x))\n    (hf : has_strict_deriv_at f f' x) : has_strict_deriv_at (l ∘ f) (l' f') x := by\n  simpa only [one_apply, one_smul, smul_right_apply, coe_comp', (· ∘ ·)] using\n    (hl.comp x hf.has_strict_fderiv_at).has_strict_deriv_at\n#align has_strict_fderiv_at.comp_has_strict_deriv_at has_strict_fderiv_at.comp_has_strict_deriv_at\n\n",
 "comp_has_fderiv_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_within_at.comp_has_fderiv_within_at {f : E → 𝕜'} {f' : «expr →L[ ] » E 𝕜 𝕜'} {s t} (x)\n    (hh : has_deriv_within_at h₂ h₂' t (f x)) (hf : has_fderiv_within_at f f' s x) (hst : MapsTo f s t) :\n    has_fderiv_within_at (h₂ ∘ f) («expr • » h₂' f') s x :=\n  hh.comp_has_fderiv_at_filter x hf <| hf.continuous_within_at.tendsto_nhds_within hst\n#align has_deriv_within_at.comp_has_fderiv_within_at has_deriv_within_at.comp_has_fderiv_within_at\n\n",
 "comp_has_fderiv_at_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_at_filter.comp_has_fderiv_at_filter {f : E → 𝕜'} {f' : «expr →L[ ] » E 𝕜 𝕜'} (x) {L'' : Filter E}\n    (hh₂ : has_deriv_at_filter h₂ h₂' (f x) L') (hf : has_fderiv_at_filter f f' x L'') (hL : Tendsto f L'' L') :\n    has_fderiv_at_filter (h₂ ∘ f) («expr • » h₂' f') x L'' :=\n  by\n  convert(hh₂.restrict_scalars 𝕜).comp x hf hL\n  ext x\n  simp [mul_comm]\n#align has_deriv_at_filter.comp_has_fderiv_at_filter has_deriv_at_filter.comp_has_fderiv_at_filter\n\n",
 "comp_has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_deriv_at.comp_has_fderiv_at {f : E → 𝕜'} {f' : «expr →L[ ] » E 𝕜 𝕜'} (x) (hh : has_deriv_at h₂ h₂' (f x))\n    (hf : has_fderiv_at f f' x) : has_fderiv_at (h₂ ∘ f) («expr • » h₂' f') x :=\n  hh.comp_has_fderiv_at_filter x hf hf.continuous_at\n#align has_deriv_at.comp_has_fderiv_at has_deriv_at.comp_has_fderiv_at\n\n",
 "comp_has_deriv_within_at":
 "theorem has_fderiv_at.comp_has_deriv_within_at (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_within_at f f' s x) :\n    has_deriv_within_at (l ∘ f) (l' f') s x :=\n  hl.has_fderiv_within_at.comp_has_deriv_within_at x hf (mapsTo_univ _ _)\n#align has_fderiv_at.comp_has_deriv_within_at has_fderiv_at.comp_has_deriv_within_at\n\n",
 "comp_has_deriv_at":
 "/-- The composition `l ∘ f` where `l : F → E` and `f : 𝕜 → F`, has a derivative equal to the\nFréchet derivative of `l` applied to the derivative of `f`. -/\ntheorem has_fderiv_at.comp_has_deriv_at (hl : has_fderiv_at l l' (f x)) (hf : has_deriv_at f f' x) :\n    has_deriv_at (l ∘ f) (l' f') x :=\n  has_deriv_within_at_univ.mp <| hl.comp_has_deriv_within_at x hf.has_deriv_within_at\n#align has_fderiv_at.comp_has_deriv_at has_fderiv_at.comp_has_deriv_at\n\n",
 "comp_deriv_within":
 "theorem fderiv_within.comp_deriv_within {t : Set F} (hl : differentiable_within_at 𝕜 l t (f x))\n    (hf : differentiable_within_at 𝕜 f s x) (hs : MapsTo f s t) (hxs : unique_diff_within_at 𝕜 s x) :\n    deriv_within (l ∘ f) s x = (fderiv_within 𝕜 l t (f x) : F → E) (deriv_within f s x) :=\n  (hl.has_fderiv_within_at.comp_has_deriv_within_at x hf.has_deriv_within_at hs).deriv_within hxs\n#align fderiv_within.comp_deriv_within fderiv_within.comp_deriv_within\n\n",
 "comp_deriv":
 "theorem fderiv.comp_deriv (hl : differentiable_at 𝕜 l (f x)) (hf : differentiable_at 𝕜 f x) :\n    deriv (l ∘ f) x = (fderiv 𝕜 l (f x) : F → E) (deriv f x) :=\n  (hl.has_fderiv_at.comp_has_deriv_at x hf.has_deriv_at).deriv\n#align fderiv.comp_deriv fderiv.comp_deriv\n\n",
 "comp":
 "theorem deriv.comp (hh₂ : differentiable_at 𝕜' h₂ (h x)) (hh : differentiable_at 𝕜 h x) :\n    deriv (h₂ ∘ h) x = deriv h₂ (h x) * deriv h x :=\n  (hh₂.has_deriv_at.comp x hh.has_deriv_at).deriv\n#align deriv.comp deriv.comp\n\n",
 "clm_comp":
 "theorem has_deriv_at.clm_comp (hc : has_deriv_at c c' x) (hd : has_deriv_at d d' x) :\n    has_deriv_at (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x :=\n  by\n  rw [← has_deriv_within_at_univ] at *\n  exact hc.clm_comp hd\n#align has_deriv_at.clm_comp has_deriv_at.clm_comp\n\n",
 "clm_apply":
 "theorem has_deriv_at.clm_apply (hc : has_deriv_at c c' x) (hu : has_deriv_at u u' x) :\n    has_deriv_at (fun y => (c y) (u y)) (c' (u x) + c x u') x :=\n  by\n  have := (hc.has_fderiv_at.clm_apply hu.has_fderiv_at).has_deriv_at\n  rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul,\n    add_comm] at this\n#align has_deriv_at.clm_apply has_deriv_at.clm_apply\n\n",
 "add_const":
 "theorem has_deriv_at.add_const (hf : has_deriv_at f f' x) (c : F) : has_deriv_at (fun x => f x + c) f' x :=\n  hf.add_const c\n#align has_deriv_at.add_const has_deriv_at.add_const\n\n",
 "add":
 "theorem has_deriv_at.add (hf : has_deriv_at f f' x) (hg : has_deriv_at g g' x) :\n    has_deriv_at (fun x => f x + g x) (f' + g') x :=\n  hf.add hg\n#align has_deriv_at.add has_deriv_at.add\n\n",
 "Ioi_iff_Ioo":
 "theorem has_deriv_within_at.Ioi_iff_Ioo [linear_order 𝕜] [OrderClosedTopology 𝕜] {x y : 𝕜} (h : x < y) :\n    has_deriv_within_at f f' (Ioo x y) x ↔ has_deriv_within_at f f' (Ioi x) x :=\n  has_deriv_within_at_congr_set (isOpen_Iio.mem_nhds h) <|\n    by\n    rw [Ioi_inter_Iio, inter_eq_left_iff_subset]\n    exact Ioo_subset_Iio_self\n#align has_deriv_within_at.Ioi_iff_Ioo has_deriv_within_at.Ioi_iff_Ioo\n\n"}