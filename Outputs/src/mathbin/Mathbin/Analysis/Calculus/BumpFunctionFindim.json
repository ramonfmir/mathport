{"u_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem u_support : support (u : E → exprℝ) = ball 0 1 :=\n  (Classical.choose_spec (u_exists E)).2.2.1\n#align u_support u_support\n\n",
 "u_smooth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem u_smooth : cont_diff (exprℝ) («expr⊤») (u : E → exprℝ) :=\n  (Classical.choose_spec (u_exists E)).1\n#align u_smooth u_smooth\n\n",
 "u_nonneg":
 "theorem u_nonneg (x : E) : 0 ≤ u x :=\n  ((Classical.choose_spec (u_exists E)).2.1 x).1\n#align u_nonneg u_nonneg\n\n",
 "u_neg":
 "theorem u_neg (x : E) : u (-x) = u x :=\n  (Classical.choose_spec (u_exists E)).2.2.2 x\n#align u_neg u_neg\n\n",
 "u_le_one":
 "theorem u_le_one (x : E) : u x ≤ 1 :=\n  ((Classical.choose_spec (u_exists E)).2.1 x).2\n#align u_le_one u_le_one\n\n",
 "u_int_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\ntheorem u_int_pos :\n    0 <\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (u x)\n        (exprμ) :=\n  by\n  refine' (integral_pos_iff_support_of_nonneg u_nonneg _).mpr _\n  · exact (u_continuous E).integrable_of_has_compact_support (u_compact_support E)\n  · rw [u_support]\n    exact measure_ball_pos _ _ zero_lt_one\n#align u_int_pos u_int_pos\n\n",
 "u_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem u_exists :\n    ∃ u : E → exprℝ,\n      cont_diff (exprℝ) («expr⊤») u ∧ (∀ x, u x ∈ Icc (0 : exprℝ) 1) ∧ support u = ball 0 1 ∧ ∀ x, u (-x) = u x :=\n  by\n  have A : IsOpen (ball (0 : E) 1) := is_open_ball\n  obtain ⟨f, f_support, f_smooth, f_range⟩ :\n    ∃ f : E → exprℝ, f.support = ball (0 : E) 1 ∧ cont_diff (exprℝ) («expr⊤») f ∧ Set.range f ⊆ Set.Icc 0 1\n  exact A.exists_smooth_support_eq\n  have B : ∀ x, f x ∈ Icc (0 : exprℝ) 1 := fun x => f_range (mem_range_self x)\n  refine' ⟨fun x => (f x + f (-x)) / 2, _, _, _, _⟩\n  · exact (f_smooth.add (f_smooth.comp cont_diff_neg)).div_const _\n  · intro x\n    constructor\n    · linarith [(B x).1, (B (-x)).1]\n    · linarith [(B x).2, (B (-x)).2]\n  · refine' support_eq_iff.2 ⟨fun x hx => _, fun x hx => _⟩\n    · apply ne_of_gt\n      have : 0 < f x := by\n        apply lt_of_le_of_ne (B x).1 (ne.symm _)\n        rwa [← f_support] at hx\n      linarith [(B (-x)).1]\n    · have I1 : x ∉ support f := by rwa [f_support]\n      have I2 : -x ∉ support f := by\n        rw [f_support]\n        simp only at hx\n        simpa using hx\n      simp only [mem_support, Classical.not_not] at I1 I2\n      simp only [I1, I2, add_zero, zero_div]\n  · intro x\n    simp only [add_comm, neg_neg]\n#align u_exists u_exists\n\n",
 "u_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem u_continuous : Continuous (u : E → exprℝ) :=\n  (u_smooth E).continuous\n#align u_continuous u_continuous\n\n",
 "u_compact_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem u_compact_support : HasCompactSupport (u : E → exprℝ) :=\n  by\n  rw [hasCompactSupport_def, u_support, closure_ball (0 : E) one_ne_zero]\n  exact is_compact_closed_ball _ _\n#align u_compact_support u_compact_support\n\n",
 "exists_smooth_tsupport_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/-- If a set `s` is a neighborhood of `x`, then there exists a smooth function `f` taking\nvalues in `[0, 1]`, supported in `s` and with `f x = 1`. -/\ntheorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ∈ (nhds) x) :\n    ∃ f : E → exprℝ,\n      tsupport f ⊆ s ∧ HasCompactSupport f ∧ cont_diff (exprℝ) («expr⊤») f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 :=\n  by\n  obtain ⟨d, d_pos, hd⟩ : ∃ (d : exprℝ)(hr : 0 < d), euclidean.closed_ball x d ⊆ s\n  exact euclidean.nhds_basis_closed_ball.mem_iff.1 hs\n  let c : cont_diff_bump (to_euclidean x) :=\n    { r := d / 2\n      R := d\n      r_pos := half_pos d_pos\n      r_lt_R := half_lt_self d_pos }\n  let f : E → exprℝ := c ∘ to_euclidean\n  have f_supp : f.support ⊆ euclidean.ball x d := by\n    intro y hy\n    have : to_euclidean y ∈ Function.support c := by\n      simpa only [f, Function.mem_support, Function.comp_apply, ne.def] using hy\n    rwa [c.support_eq] at this\n  have f_tsupp : tsupport f ⊆ euclidean.closed_ball x d :=\n    by\n    rw [tsupport, ← euclidean.closure_ball _ d_pos.ne']\n    exact closure_mono f_supp\n  refine' ⟨f, f_tsupp.trans hd, _, _, _, _⟩\n  · refine' is_compact_of_is_closed_bounded isClosed_closure _\n    have : bounded (euclidean.closed_ball x d) := euclidean.is_compact_closed_ball.bounded\n    apply this.mono _\n    refine' (IsClosed.closure_subset_iff euclidean.is_closed_closed_ball).2 _\n    exact f_supp.trans euclidean.ball_subset_closed_ball\n  · apply c.cont_diff.comp\n    exact continuous_linear_equiv.cont_diff _\n  · rintro t ⟨y, rfl⟩\n    exact ⟨c.nonneg, c.le_one⟩\n  · apply c.one_of_mem_closed_ball\n    apply mem_closed_ball_self\n    exact (half_pos d_pos).le\n#align exists_smooth_tsupport_subset exists_smooth_tsupport_subset\n\n",
 "exists_smooth_support_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Given an open set `s` in a finite-dimensional real normed vector space, there exists a smooth\nfunction with values in `[0, 1]` whose support is exactly `s`. -/\ntheorem is_open.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :\n    ∃ f : E → exprℝ, f.support = s ∧ cont_diff (exprℝ) («expr⊤») f ∧ Set.range f ⊆ Set.Icc 0 1 :=\n  by\n  /- For any given point `x` in `s`, one can construct a smooth function with support in `s` and\n    nonzero at `x`. By second-countability, it follows that we may cover `s` with the supports of\n    countably many such functions, say `g i`.\n    Then `∑ i, r i • g i` will be the desired function if `r i` is a sequence of positive numbers\n    tending quickly enough to zero. Indeed, this ensures that, for any `k ≤ i`, the `k`-th derivative\n    of `r i • g i` is bounded by a prescribed (summable) sequence `u i`. From this, the summability\n    of the series and of its successive derivatives follows. -/\n  rcases eq_empty_or_nonempty s with (rfl | h's)\n  ·\n    exact\n      ⟨fun x => 0, Function.support_zero, cont_diff_const, by\n        simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]⟩\n  let ι := { f : E → exprℝ // f.support ⊆ s ∧ HasCompactSupport f ∧ cont_diff (exprℝ) («expr⊤») f ∧ range f ⊆ Icc 0 1 }\n  obtain ⟨T, T_count, hT⟩ :\n    ∃ T : Set ι,\n      T.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (support (f : E → exprℝ)) =\n          s :=\n    by\n    have :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (f : E → exprℝ).support =\n        s :=\n      by\n      refine' subset.antisymm (Union_subset fun f => f.2.1) _\n      intro x hx\n      rcases exists_smooth_tsupport_subset (hs.mem_nhds hx) with ⟨f, hf⟩\n      let g : ι := ⟨f, (subset_tsupport f).trans hf.1, hf.2.1, hf.2.2.1, hf.2.2.2.1⟩\n      have : x ∈ support (g : E → exprℝ) := by\n        simp only [hf.2.2.2.2, Subtype.coe_mk, mem_support, ne.def, one_ne_zero, not_false_iff]\n      exact mem_Union_of_mem _ this\n    simp_rw [← this]\n    apply is_open_Union_countable\n    rintro ⟨f, hf⟩\n    exact hf.2.2.1.continuous.is_open_support\n  obtain ⟨g0, hg⟩ : ∃ g0 : ℕ → ι, T = range g0 :=\n    by\n    apply countable.exists_eq_range T_count\n    rcases eq_empty_or_nonempty T with (rfl | hT)\n    · simp only [Union_false, Union_empty] at hT\n      simp only [← hT, not_nonempty_empty] at h's\n      exact h's.elim\n    · exact hT\n  let g : ℕ → E → exprℝ := fun n => (g0 n).1\n  have g_s : ∀ n, support (g n) ⊆ s := fun n => (g0 n).2.1\n  have s_g : ∀ x ∈ s, ∃ n, x ∈ support (g n) := by\n    intro x hx\n    rw [← hT] at hx\n    obtain ⟨i, iT, hi⟩ : ∃ (i : ι)(hi : i ∈ T), x ∈ support (i : E → exprℝ) := by simpa only [mem_Union] using hx\n    rw [hg, mem_range] at iT\n    rcases iT with ⟨n, hn⟩\n    rw [← hn] at hi\n    exact ⟨n, hi⟩\n  have g_smooth : ∀ n, cont_diff (exprℝ) («expr⊤») (g n) := fun n => (g0 n).2.2.2.1\n  have g_comp_supp : ∀ n, HasCompactSupport (g n) := fun n => (g0 n).2.2.1\n  have g_nonneg : ∀ n x, 0 ≤ g n x := fun n x => ((g0 n).2.2.2.2 (mem_range_self x)).1\n  obtain ⟨δ, δpos, c, δc, c_lt⟩ : ∃ δ : ℕ → nnreal, (∀ i : ℕ, 0 < δ i) ∧ ∃ c : NNReal, HasSum δ c ∧ c < 1\n  exact NNReal.exists_pos_sum_of_countable one_ne_zero ℕ\n  have :\n    ∀ n : ℕ, ∃ r : exprℝ, 0 < r ∧ ∀ i ≤ n, ∀ x, «expr‖ ‖» (iterated_fderiv (exprℝ) i («expr • » r (g n)) x) ≤ δ n :=\n    by\n    intro n\n    have : ∀ i, ∃ R, ∀ x, «expr‖ ‖» (iterated_fderiv (exprℝ) i (fun x => g n x) x) ≤ R :=\n      by\n      intro i\n      have : BddAbove (range fun x => «expr‖ ‖» (iterated_fderiv (exprℝ) i (fun x : E => g n x) x)) :=\n        by\n        apply ((g_smooth n).continuous_iterated_fderiv le_top).norm.bdd_above_range_of_has_compact_support\n        apply HasCompactSupport.comp_left _ norm_zero\n        apply (g_comp_supp n).iterated_fderiv\n      rcases this with ⟨R, hR⟩\n      exact ⟨R, fun x => hR (mem_range_self _)⟩\n    choose R hR using this\n    let M := max (((Finset.range (n + 1)).image R).max' (by simp)) 1\n    have M_pos : 0 < M := zero_lt_one.trans_le (le_max_right _ _)\n    have δnpos : 0 < δ n := δpos n\n    have IR : ∀ i ≤ n, R i ≤ M := by\n      intro i hi\n      refine' le_trans _ (le_max_left _ _)\n      apply Finset.le_max'\n      apply Finset.mem_image_of_mem\n      simp only [Finset.mem_range]\n      linarith\n    refine' ⟨M⁻¹ * δ n, by positivity, fun i hi x => _⟩\n    calc\n      «expr‖ ‖» (iterated_fderiv (exprℝ) i («expr • » (M⁻¹ * δ n) (g n)) x) =\n          «expr‖ ‖» («expr • » (M⁻¹ * δ n) (iterated_fderiv (exprℝ) i (g n) x)) :=\n        by\n        rw [iterated_fderiv_const_smul_apply]\n        exact (g_smooth n).of_le le_top\n      _ = M⁻¹ * δ n * «expr‖ ‖» (iterated_fderiv (exprℝ) i (g n) x) :=\n        by\n        rw [norm_smul, Real.norm_of_nonneg]\n        positivity\n      _ ≤ M⁻¹ * δ n * M := (mul_le_mul_of_nonneg_left ((hR i x).trans (IR i hi)) (by positivity))\n      _ = δ n := by field_simp [M_pos.ne']\n      \n  choose r rpos hr using this\n  have S : ∀ x, Summable fun n => («expr • » (r n) (g n)) x :=\n    by\n    intro x\n    refine' summable_of_nnnorm_bounded _ δc.summable fun n => _\n    rw [← NNReal.coe_le_coe, coe_nnnorm]\n    simpa only [norm_iterated_fderiv_zero] using hr n 0 (zero_le n) x\n  refine'\n    ⟨fun x =>\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        ((«expr • » (r n) (g n)) x),\n      _, _, _⟩\n  · apply subset.antisymm\n    · intro x hx\n      simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, mem_support, ne.def] at hx\n      contrapose! hx\n      have : ∀ n, g n x = 0 := by\n        intro n\n        contrapose! hx\n        exact g_s n hx\n      simp only [this, MulZeroClass.mul_zero, tsum_zero]\n    · intro x hx\n      obtain ⟨n, hn⟩ : ∃ n, x ∈ support (g n)\n      exact s_g x hx\n      have I : 0 < r n * g n x := mul_pos (rpos n) (lt_of_le_of_ne (g_nonneg n x) (ne.symm hn))\n      exact ne_of_gt (tsum_pos (S x) (fun i => mul_nonneg (rpos i).le (g_nonneg i x)) n I)\n  · refine'\n      cont_diff_tsum_of_eventually (fun n => (g_smooth n).const_smul _) (fun k hk => (NNReal.hasSum_coe.2 δc).summable)\n        _\n    intro i hi\n    simp only [Nat.cofinite_eq_atTop, Pi.smul_apply, Algebra.id.smul_eq_mul, Filter.eventually_atTop, ge_iff_le]\n    exact ⟨i, fun n hn x => hr _ _ hn _⟩\n  · rintro - ⟨y, rfl⟩\n    refine' ⟨tsum_nonneg fun n => mul_nonneg (rpos n).le (g_nonneg n y), le_trans _ c_lt.le⟩\n    have A : HasSum (fun n => (δ n : exprℝ)) c := NNReal.hasSum_coe.2 δc\n    rw [← A.tsum_eq]\n    apply tsum_le_tsum _ (S y) A.summable\n    intro n\n    apply (le_abs_self _).trans\n    simpa only [norm_iterated_fderiv_zero] using hr n 0 (zero_le n) y\n#align is_open.exists_smooth_support_eq is_open.exists_smooth_support_eq\n\n",
 "Y_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_support {D : exprℝ} (Dpos : 0 < D) (D_lt_one : D < 1) : support (Y D : E → exprℝ) = ball (0 : E) (1 + D) :=\n  support_eq_iff.2 ⟨fun x hx => (Y_pos_of_mem_ball Dpos D_lt_one hx).ne', fun x hx => Y_eq_zero_of_not_mem_ball Dpos hx⟩\n#align Y_support Y_support\n\n",
 "Y_smooth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_smooth : cont_diff_on (exprℝ) («expr⊤») (uncurry Y) (lower_set.prod (Ioo (0 : exprℝ) 1) (univ : Set E)) :=\n  by\n  have hs : IsOpen (Ioo (0 : exprℝ) (1 : exprℝ)) := isOpen_Ioo\n  have hk : IsCompact (closed_ball (0 : E) 1) := proper_space.is_compact_closed_ball _ _\n  refine' cont_diff_on_convolution_left_with_param (lsmul (exprℝ) (exprℝ)) hs hk _ _ _\n  · rintro p x hp hx\n    simp only [W, mul_inv_rev, Algebra.id.smul_eq_mul, mul_eq_zero, inv_eq_zero]\n    right\n    contrapose! hx\n    have : «expr • » p⁻¹ x ∈ support u := mem_support.2 hx\n    simp only [u_support, norm_smul, mem_ball_zero_iff, Real.norm_eq_abs, abs_inv, abs_of_nonneg hp.1.le, ←\n      div_eq_inv_mul, div_lt_one hp.1] at this\n    rw [mem_closedBall_zero_iff]\n    exact this.le.trans hp.2.le\n  · exact (locally_integrable_const _).indicator measurable_set_closed_ball\n  · apply cont_diff_on.mul\n    · refine'\n        (cont_diff_on_const.mul _).inv fun x hx => ne_of_gt (mul_pos (u_int_pos E) (pow_pos (abs_pos_of_pos hx.1.1) _))\n      apply cont_diff_on.pow\n      simp_rw [← Real.norm_eq_abs]\n      apply @cont_diff_on.norm (exprℝ)\n      · exact cont_diff_on_fst\n      · intro x hx\n        exact ne_of_gt hx.1.1\n    · apply (u_smooth E).comp_cont_diff_on\n      exact cont_diff_on.smul (cont_diff_on_fst.inv fun x hx => ne_of_gt hx.1.1) cont_diff_on_snd\n#align Y_smooth Y_smooth\n\n",
 "Y_pos_of_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_pos_of_mem_ball {D : exprℝ} {x : E} (Dpos : 0 < D) (D_lt_one : D < 1) (hx : x ∈ ball (0 : E) (1 + D)) :\n    0 < Y D x := by\n  simp only [mem_ball_zero_iff] at hx\n  refine' (integral_pos_iff_support_of_nonneg (W_mul_φ_nonneg D x) _).2 _\n  · have F_comp : HasCompactSupport (W D) := W_compact_support E Dpos\n    have B : locally_integrable (φ : E → exprℝ) (exprμ) :=\n      (locally_integrable_const _).indicator measurable_set_closed_ball\n    have C : Continuous (W D : E → exprℝ) := continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))\n    exact\n      (has_compact_support.convolution_exists_left\n          (lsmul (exprℝ) (exprℝ) : «expr →L[ ] » (exprℝ) (exprℝ) («expr →L[ ] » (exprℝ) (exprℝ) (exprℝ))) F_comp C B\n          x).integrable\n  · set z := «expr • » (D / (1 + D)) x with hz\n    have B : 0 < 1 + D := by linarith\n    have C : ball z (D * (1 + D - «expr‖ ‖» x) / (1 + D)) ⊆ support fun y : E => W D y * φ (x - y) :=\n      by\n      intro y hy\n      simp only [support_mul, W_support E Dpos]\n      simp only [φ, mem_inter_iff, mem_support, ne.def, indicator_apply_eq_zero, mem_closedBall_zero_iff, one_ne_zero,\n        not_forall, not_false_iff, exists_prop, and_true_iff]\n      constructor\n      · apply ball_subset_ball' _ hy\n        simp only [z, norm_smul, abs_of_nonneg Dpos.le, abs_of_nonneg B.le, dist_zero_right, Real.norm_eq_abs, abs_div]\n        simp only [div_le_iff B, field_simps]\n        ring_nf\n      · have ID : «expr‖ ‖» (D / (1 + D) - 1) = 1 / (1 + D) :=\n          by\n          rw [Real.norm_of_nonpos]\n          · simp only [B.ne', ne.def, not_false_iff, mul_one, neg_sub, add_tsub_cancel_right, field_simps]\n          · simp only [B.ne', ne.def, not_false_iff, mul_one, field_simps]\n            apply div_nonpos_of_nonpos_of_nonneg _ B.le\n            linarith only\n        rw [← mem_closedBall_iff_norm']\n        apply closed_ball_subset_closed_ball' _ (ball_subset_closed_ball hy)\n        rw [← one_smul (exprℝ) x, dist_eq_norm, hz, ← sub_smul, one_smul, norm_smul, ID]\n        simp only [-one_div, -mul_eq_zero, B.ne', div_le_iff B, field_simps]\n        simp only [mem_ball_zero_iff] at hx\n        nlinarith only [hx, D_lt_one]\n    apply lt_of_lt_of_le _ (measure_mono C)\n    apply measure_ball_pos\n    exact div_pos (mul_pos Dpos (by linarith only [hx])) B\n#align Y_pos_of_mem_ball Y_pos_of_mem_ball\n\n",
 "Y_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_nonneg (D : exprℝ) (x : E) : 0 ≤ Y D x :=\n  integral_nonneg (W_mul_φ_nonneg D x)\n#align Y_nonneg Y_nonneg\n\n",
 "Y_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_neg (D : exprℝ) (x : E) : Y D (-x) = Y D x :=\n  by\n  apply convolution_neg_of_neg_eq\n  · apply eventually_of_forall fun x => _\n    simp only [W_def, u_neg, smul_neg, Algebra.id.smul_eq_mul, mul_eq_mul_left_iff, eq_self_iff_true, true_or_iff]\n  · apply eventually_of_forall fun x => _\n    simp only [φ, indicator, mem_closedBall_zero_iff, norm_neg]\n#align Y_neg Y_neg\n\n",
 "Y_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `convolution -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `convolution -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `convolution -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_le_one {D : exprℝ} (x : E) (Dpos : 0 < D) : Y D x ≤ 1 :=\n  by\n  have A :\n    (convolution (W D) (lsmul (exprℝ) (exprℝ)) (exprμ) φ) x ≤ (convolution (W D) (lsmul (exprℝ) (exprℝ)) (exprμ) 1) x :=\n    by\n    apply\n      convolution_mono_right_of_nonneg _ (W_nonneg D) (indicator_le_self' fun x hx => zero_le_one) fun x => zero_le_one\n    refine'\n      (has_compact_support.convolution_exists_left _ (W_compact_support E Dpos) _ (locally_integrable_const (1 : exprℝ))\n          x).integrable\n    exact continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))\n  have B : (convolution (W D) (lsmul (exprℝ) (exprℝ)) (exprμ) fun y => (1 : exprℝ)) x = 1 := by\n    simp only [convolution, ContinuousLinearMap.map_smul, mul_inv_rev, coe_smul', mul_one, lsmul_apply,\n      Algebra.id.smul_eq_mul, integral_mul_left, W_integral E Dpos, Pi.smul_apply]\n  exact A.trans (le_of_eq B)\n#align Y_le_one Y_le_one\n\n",
 "Y_eq_zero_of_not_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `convolution -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_eq_zero_of_not_mem_ball {D : exprℝ} {x : E} (Dpos : 0 < D) (hx : x ∉ ball (0 : E) (1 + D)) : Y D x = 0 :=\n  by\n  change (convolution (W D) (lsmul (exprℝ) (exprℝ)) (exprμ) φ) x = 0\n  have B : ∀ y, y ∈ ball x D → φ y = 0 := by\n    intro y hy\n    simp only [φ, indicator, mem_closedBall_zero_iff, ite_eq_right_iff, one_ne_zero]\n    intro h'y\n    have C : ball y D ⊆ ball 0 (1 + D) := by\n      apply ball_subset_ball'\n      rw [← dist_zero_right] at h'y\n      linarith only [h'y]\n    exact hx (C (mem_ball_comm.1 hy))\n  have Bx : φ x = 0 := B _ (mem_ball_self Dpos)\n  have B' : ∀ y, y ∈ ball x D → φ y = φ x := by\n    rw [Bx]\n    exact B\n  rw [convolution_eq_right' _ (le_of_eq (W_support E Dpos)) B']\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul, Bx, MulZeroClass.mul_zero, integral_const]\n#align Y_eq_zero_of_not_mem_ball Y_eq_zero_of_not_mem_ball\n\n",
 "Y_eq_one_of_mem_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `convolution -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Y_eq_one_of_mem_closed_ball {D : exprℝ} {x : E} (Dpos : 0 < D) (hx : x ∈ closedBall (0 : E) (1 - D)) :\n    Y D x = 1 := by\n  change (convolution (W D) (lsmul (exprℝ) (exprℝ)) (exprμ) φ) x = 1\n  have B : ∀ y : E, y ∈ ball x D → φ y = 1 :=\n    by\n    have C : ball x D ⊆ ball 0 1 := by\n      apply ball_subset_ball'\n      simp only [mem_closed_ball] at hx\n      linarith only [hx]\n    intro y hy\n    simp only [φ, indicator, mem_closed_ball, ite_eq_left_iff, not_le, zero_ne_one]\n    intro h'y\n    linarith only [mem_ball.1 (C hy), h'y]\n  have Bx : φ x = 1 := B _ (mem_ball_self Dpos)\n  have B' : ∀ y, y ∈ ball x D → φ y = φ x := by\n    rw [Bx]\n    exact B\n  rw [convolution_eq_right' _ (le_of_eq (W_support E Dpos)) B']\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul, integral_mul_right, W_integral E Dpos, Bx, one_mul]\n#align Y_eq_one_of_mem_closed_ball Y_eq_one_of_mem_closed_ball\n\n",
 "W_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem W_support {D : exprℝ} (Dpos : 0 < D) : support (W D : E → exprℝ) = ball 0 D :=\n  by\n  have B : «expr • » D (ball (0 : E) 1) = ball 0 D := by rw [smul_unitBall Dpos.ne', Real.norm_of_nonneg Dpos.le]\n  have C : D ^ finrank (exprℝ) E ≠ 0 := pow_ne_zero _ Dpos.ne'\n  simp only [W_def, Algebra.id.smul_eq_mul, support_mul, support_inv, univ_inter, support_comp_inv_smul₀ Dpos.ne',\n    u_support, B, support_const (u_int_pos E).ne', support_const C, abs_of_nonneg Dpos.le]\n#align W_support W_support\n\n",
 "W_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem W_nonneg (D : exprℝ) (x : E) : 0 ≤ W D x :=\n  by\n  apply mul_nonneg _ (u_nonneg _)\n  apply inv_nonneg.2\n  apply mul_nonneg (u_int_pos E).le\n  apply pow_nonneg (abs_nonneg D)\n#align W_nonneg W_nonneg\n\n",
 "W_mul_φ_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem W_mul_φ_nonneg (D : exprℝ) (x y : E) : 0 ≤ W D y * φ (x - y) :=\n  mul_nonneg (W_nonneg D y) (indicator_nonneg (by simp only [zero_le_one, imp_true_iff]) _)\n#align W_mul_φ_nonneg W_mul_φ_nonneg\n\n",
 "W_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\ntheorem W_integral {D : exprℝ} (Dpos : 0 < D) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (W D x)\n        (exprμ) =\n      1 :=\n  by\n  simp_rw [W, integral_smul]\n  rw [integral_comp_inv_smul_of_nonneg (exprμ) (u : E → exprℝ) Dpos.le, abs_of_nonneg Dpos.le, mul_comm]\n  field_simp [Dpos.ne', (u_int_pos E).ne']\n#align W_integral W_integral\n\n",
 "W_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprμ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem W_def (D : exprℝ) :\n    (W D : E → exprℝ) = fun x =>\n      «expr • »\n        («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (u x)\n              (exprμ) *\n            |D| ^ finrank (exprℝ) E)⁻¹\n        (u («expr • » D⁻¹ x)) :=\n  by\n  ext1 x\n  rfl\n#align W_def W_def\n\n",
 "W_compact_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem W_compact_support {D : exprℝ} (Dpos : 0 < D) : HasCompactSupport (W D : E → exprℝ) :=\n  by\n  rw [hasCompactSupport_def, W_support E Dpos, closure_ball (0 : E) Dpos.ne']\n  exact is_compact_closed_ball _ _\n#align W_compact_support W_compact_support\n\n"}