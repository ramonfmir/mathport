{"exists_smooth_tsupport_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n/-- If a set `s` is a neighborhood of `x`, then there exists a smooth function `f` taking\nvalues in `[0, 1]`, supported in `s` and with `f x = 1`. -/\ntheorem exists_smooth_tsupport_subset {s : set E} {x : E} (hs : s ∈ (nhds) x) :\n    ∃ f : E → exprℝ,\n      tsupport f ⊆ s ∧ has_compact_support f ∧ cont_diff (exprℝ) («expr⊤») f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 :=\n  by\n  obtain ⟨d, d_pos, hd⟩ : ∃ (d : exprℝ)(hr : 0 < d), euclidean.closed_ball x d ⊆ s\n  exact euclidean.nhds_basis_closed_ball.mem_iff.1 hs\n  let c : cont_diff_bump_of_inner (to_euclidean x) :=\n    { r := d / 2\n      R := d\n      r_pos := half_pos d_pos\n      r_lt_R := half_lt_self d_pos }\n  let f : E → exprℝ := c ∘ to_euclidean\n  have f_supp : f.support ⊆ euclidean.ball x d := by\n    intro y hy\n    have : to_euclidean y ∈ function.support c := by\n      simpa only [f, function.mem_support, Function.comp_apply, ne.def] using hy\n    rwa [c.support_eq] at this\n  have f_tsupp : tsupport f ⊆ euclidean.closed_ball x d :=\n    by\n    rw [tsupport, ← euclidean.closure_ball _ d_pos.ne']\n    exact closure_mono f_supp\n  refine' ⟨f, f_tsupp.trans hd, _, _, _, _⟩\n  · refine' is_compact_of_is_closed_bounded is_closed_closure _\n    have : bounded (euclidean.closed_ball x d) := euclidean.is_compact_closed_ball.bounded\n    apply this.mono _\n    refine' (is_closed.closure_subset_iff euclidean.is_closed_closed_ball).2 _\n    exact f_supp.trans euclidean.ball_subset_closed_ball\n  · apply c.cont_diff.comp\n    exact continuous_linear_equiv.cont_diff _\n  · rintro t ⟨y, rfl⟩\n    exact ⟨c.nonneg, c.le_one⟩\n  · apply c.one_of_mem_closed_ball\n    apply mem_closed_ball_self\n    exact (half_pos d_pos).le\n#align exists_smooth_tsupport_subset exists_smooth_tsupport_subset\n\n",
 "exists_smooth_support_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Given an open set `s` in a finite-dimensional real normed vector space, there exists a smooth\nfunction with values in `[0, 1]` whose support is exactly `s`. -/\ntheorem is_open.exists_smooth_support_eq {s : set E} (hs : is_open s) :\n    ∃ f : E → exprℝ, f.support = s ∧ cont_diff (exprℝ) («expr⊤») f ∧ Set.range f ⊆ Set.Icc 0 1 :=\n  by\n  /- For any given point `x` in `s`, one can construct a smooth function with support in `s` and\n    nonzero at `x`. By second-countability, it follows that we may cover `s` with the supports of\n    countably many such functions, say `g i`.\n    Then `∑ i, r i • g i` will be the desired function if `r i` is a sequence of positive numbers\n    tending quickly enough to zero. Indeed, this ensures that, for any `k ≤ i`, the `k`-th derivative\n    of `r i • g i` is bounded by a prescribed (summable) sequence `u i`. From this, the summability\n    of the series and of its successive derivatives follows. -/\n  rcases eq_empty_or_nonempty s with (rfl | h's)\n  ·\n    exact\n      ⟨fun x => 0, function.support_zero, cont_diff_const, by\n        simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]⟩\n  let ι :=\n    { f : E → exprℝ // f.support ⊆ s ∧ has_compact_support f ∧ cont_diff (exprℝ) («expr⊤») f ∧ range f ⊆ Icc 0 1 }\n  obtain ⟨T, T_count, hT⟩ :\n    ∃ T : set ι,\n      T.countable ∧\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (support (f : E → exprℝ)) =\n          s :=\n    by\n    have :\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (f : E → exprℝ).support =\n        s :=\n      by\n      refine' subset.antisymm (Union_subset fun f => f.2.1) _\n      intro x hx\n      rcases exists_smooth_tsupport_subset (hs.mem_nhds hx) with ⟨f, hf⟩\n      let g : ι := ⟨f, (subset_tsupport f).trans hf.1, hf.2.1, hf.2.2.1, hf.2.2.2.1⟩\n      have : x ∈ support (g : E → exprℝ) := by\n        simp only [hf.2.2.2.2, subtype.coe_mk, mem_support, ne.def, one_ne_zero, not_false_iff]\n      exact mem_Union_of_mem _ this\n    simp_rw [← this]\n    apply is_open_Union_countable\n    rintro ⟨f, hf⟩\n    exact hf.2.2.1.continuous.is_open_support\n  obtain ⟨g0, hg⟩ : ∃ g0 : ℕ → ι, T = range g0 :=\n    by\n    apply countable.exists_eq_range T_count\n    rcases eq_empty_or_nonempty T with (rfl | hT)\n    · simp only [Union_false, Union_empty] at hT\n      simp only [← hT, not_nonempty_empty] at h's\n      exact h's.elim\n    · exact hT\n  let g : ℕ → E → exprℝ := fun n => (g0 n).1\n  have g_s : ∀ n, support (g n) ⊆ s := fun n => (g0 n).2.1\n  have s_g : ∀ x ∈ s, ∃ n, x ∈ support (g n) := by\n    intro x hx\n    rw [← hT] at hx\n    obtain ⟨i, iT, hi⟩ : ∃ (i : ι)(hi : i ∈ T), x ∈ support (i : E → exprℝ) := by simpa only [mem_Union] using hx\n    rw [hg, mem_range] at iT\n    rcases iT with ⟨n, hn⟩\n    rw [← hn] at hi\n    exact ⟨n, hi⟩\n  have g_smooth : ∀ n, cont_diff (exprℝ) («expr⊤») (g n) := fun n => (g0 n).2.2.2.1\n  have g_comp_supp : ∀ n, has_compact_support (g n) := fun n => (g0 n).2.2.1\n  have g_nonneg : ∀ n x, 0 ≤ g n x := fun n x => ((g0 n).2.2.2.2 (mem_range_self x)).1\n  obtain ⟨δ, δpos, c, δc, c_lt⟩ : ∃ δ : ℕ → nnreal, (∀ i : ℕ, 0 < δ i) ∧ ∃ c : nnreal, has_sum δ c ∧ c < 1\n  exact nnreal.exists_pos_sum_of_countable one_ne_zero ℕ\n  have :\n    ∀ n : ℕ, ∃ r : exprℝ, 0 < r ∧ ∀ i ≤ n, ∀ x, «expr‖ ‖» (iterated_fderiv (exprℝ) i («expr • » r (g n)) x) ≤ δ n :=\n    by\n    intro n\n    have : ∀ i, ∃ R, ∀ x, «expr‖ ‖» (iterated_fderiv (exprℝ) i (fun x => g n x) x) ≤ R :=\n      by\n      intro i\n      have : BddAbove (range fun x => «expr‖ ‖» (iterated_fderiv (exprℝ) i (fun x : E => g n x) x)) :=\n        by\n        apply ((g_smooth n).continuous_iterated_fderiv le_top).norm.bdd_above_range_of_has_compact_support\n        apply has_compact_support.comp_left _ norm_zero\n        apply (g_comp_supp n).iterated_fderiv\n      rcases this with ⟨R, hR⟩\n      exact ⟨R, fun x => hR (mem_range_self _)⟩\n    choose R hR using this\n    let M := max (((Finset.range (n + 1)).image R).max' (by simp)) 1\n    have M_pos : 0 < M := zero_lt_one.trans_le (le_max_right _ _)\n    have δnpos : 0 < δ n := δpos n\n    have IR : ∀ i ≤ n, R i ≤ M := by\n      intro i hi\n      refine' le_trans _ (le_max_left _ _)\n      apply finset.le_max'\n      apply Finset.mem_image_of_mem\n      simp only [Finset.mem_range]\n      linarith\n    refine' ⟨M⁻¹ * δ n, by positivity, fun i hi x => _⟩\n    calc\n      «expr‖ ‖» (iterated_fderiv (exprℝ) i («expr • » (M⁻¹ * δ n) (g n)) x) =\n          «expr‖ ‖» («expr • » (M⁻¹ * δ n) (iterated_fderiv (exprℝ) i (g n) x)) :=\n        by\n        rw [iterated_fderiv_const_smul_apply]\n        exact (g_smooth n).of_le le_top\n      _ = M⁻¹ * δ n * «expr‖ ‖» (iterated_fderiv (exprℝ) i (g n) x) :=\n        by\n        rw [norm_smul, real.norm_of_nonneg]\n        positivity\n      _ ≤ M⁻¹ * δ n * M := mul_le_mul_of_nonneg_left ((hR i x).trans (IR i hi)) (by positivity)\n      _ = δ n := by field_simp [M_pos.ne']\n      \n  choose r rpos hr using this\n  have S : ∀ x, summable fun n => («expr • » (r n) (g n)) x :=\n    by\n    intro x\n    refine' summable_of_nnnorm_bounded _ δc.summable fun n => _\n    rw [← nnreal.coe_le_coe, coe_nnnorm]\n    simpa only [norm_iterated_fderiv_zero] using hr n 0 (zero_le n) x\n  refine'\n    ⟨fun x =>\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        ((«expr • » (r n) (g n)) x),\n      _, _, _⟩\n  · apply subset.antisymm\n    · intro x hx\n      simp only [pi.smul_apply, algebra.id.smul_eq_mul, mem_support, ne.def] at hx\n      contrapose! hx\n      have : ∀ n, g n x = 0 := by\n        intro n\n        contrapose! hx\n        exact g_s n hx\n      simp only [this, mul_zero, tsum_zero]\n    · intro x hx\n      obtain ⟨n, hn⟩ : ∃ n, x ∈ support (g n)\n      exact s_g x hx\n      have I : 0 < r n * g n x := mul_pos (rpos n) (lt_of_le_of_ne (g_nonneg n x) (ne.symm hn))\n      exact ne_of_gt (tsum_pos (S x) (fun i => mul_nonneg (rpos i).le (g_nonneg i x)) n I)\n  · refine'\n      cont_diff_tsum_of_eventually (fun n => (g_smooth n).const_smul _) (fun k hk => (nnreal.has_sum_coe.2 δc).summable)\n        _\n    intro i hi\n    simp only [nat.cofinite_eq_at_top, pi.smul_apply, algebra.id.smul_eq_mul, filter.eventually_at_top, ge_iff_le]\n    exact ⟨i, fun n hn x => hr _ _ hn _⟩\n  · rintro - ⟨y, rfl⟩\n    refine' ⟨tsum_nonneg fun n => mul_nonneg (rpos n).le (g_nonneg n y), le_trans _ c_lt.le⟩\n    have A : has_sum (fun n => (δ n : exprℝ)) c := nnreal.has_sum_coe.2 δc\n    rw [← A.tsum_eq]\n    apply tsum_le_tsum _ (S y) A.summable\n    intro n\n    apply (le_abs_self _).trans\n    simpa only [norm_iterated_fderiv_zero] using hr n 0 (zero_le n) y\n#align is_open.exists_smooth_support_eq is_open.exists_smooth_support_eq\n\n"}