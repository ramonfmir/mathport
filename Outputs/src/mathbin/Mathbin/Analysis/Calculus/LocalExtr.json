{"pos_tangent_cone_at_univ":
 "theorem pos_tangent_cone_at_univ : pos_tangent_cone_at univ a = univ :=\n  eq_univ_of_forall fun x => mem_pos_tangent_cone_at_of_segment_subset' (subset_univ _)\n#align pos_tangent_cone_at_univ pos_tangent_cone_at_univ\n\n",
 "pos_tangent_cone_at_mono":
 "/-\nCopyright (c) 2019 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem pos_tangent_cone_at_mono : monotone fun s => pos_tangent_cone_at s a :=\n  by\n  rintro s t hst y ⟨c, d, hd, hc, hcd⟩\n  exact ⟨c, d, mem_of_superset hd fun h hn => hst hn, hc, hcd⟩\n#align pos_tangent_cone_at_mono pos_tangent_cone_at_mono\n\n",
 "mem_pos_tangent_cone_at_of_segment_subset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_pos_tangent_cone_at_of_segment_subset' {s : set E} {x y : E} (h : segment (exprℝ) x (x + y) ⊆ s) :\n    y ∈ pos_tangent_cone_at s x := by simpa only [add_sub_cancel'] using mem_pos_tangent_cone_at_of_segment_subset h\n#align mem_pos_tangent_cone_at_of_segment_subset' mem_pos_tangent_cone_at_of_segment_subset'\n\n",
 "mem_pos_tangent_cone_at_of_segment_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mem_pos_tangent_cone_at_of_segment_subset {s : set E} {x y : E} (h : segment (exprℝ) x y ⊆ s) :\n    y - x ∈ pos_tangent_cone_at s x := by\n  let c := fun n : ℕ => (2 : exprℝ) ^ n\n  let d := fun n : ℕ => «expr • » (c n)⁻¹ (y - x)\n  refine' ⟨c, d, filter.univ_mem' fun n => h _, tendsto_pow_at_top_at_top_of_one_lt one_lt_two, _⟩\n  show x + d n ∈ segment (exprℝ) x y\n  · rw [segment_eq_image']\n    refine' ⟨(c n)⁻¹, ⟨_, _⟩, rfl⟩\n    exacts[inv_nonneg.2 (pow_nonneg zero_le_two _), inv_le_one (one_le_pow_of_one_le one_le_two _)]\n  show tendsto (fun n => «expr • » (c n) (d n)) at_top ((nhds) (y - x))\n  · convert tendsto_const_nhds\n    ext n\n    simp only [d, smul_smul]\n    rw [mul_inv_cancel, one_smul]\n    exact pow_ne_zero _ two_ne_zero\n#align mem_pos_tangent_cone_at_of_segment_subset mem_pos_tangent_cone_at_of_segment_subset\n\n",
 "has_fderiv_within_at_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `f` has a local max on `s` at `a`, `f'` is the derivative of `f` at `a` within `s`, and\n`y` belongs to the positive tangent cone of `s` at `a`, then `f' y ≤ 0`. -/\ntheorem is_local_max_on.has_fderiv_within_at_nonpos {s : set E} (h : is_local_max_on f s a)\n    (hf : has_fderiv_within_at f f' s a) {y} (hy : y ∈ pos_tangent_cone_at s a) : f' y ≤ 0 :=\n  by\n  rcases hy with ⟨c, d, hd, hc, hcd⟩\n  have hc' : tendsto (fun n => «expr‖ ‖» (c n)) at_top at_top := tendsto_at_top_mono (fun n => le_abs_self _) hc\n  refine' le_of_tendsto (hf.lim at_top hd hc' hcd) _\n  replace hd : tendsto (fun n => a + d n) at_top (nhds_within s (a + 0))\n  exact tendsto_inf.2 ⟨tendsto_const_nhds.add (tangent_cone_at.lim_zero _ hc' hcd), by rwa [tendsto_principal]⟩\n  rw [add_zero] at hd\n  replace h :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (f (a + d n) ≤ f a)\n  exact mem_map.1 (hd h)\n  replace hc :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (0 ≤ c n)\n  exact mem_map.1 (hc (mem_at_top (0 : exprℝ)))\n  filter_upwards [h, hc]\n  simp only [smul_eq_mul, mem_preimage, subset_def]\n  intro n hnf hn\n  exact mul_nonpos_of_nonneg_of_nonpos hn (sub_nonpos.2 hnf)\n#align is_local_max_on.has_fderiv_within_at_nonpos is_local_max_on.has_fderiv_within_at_nonpos\n\n",
 "has_fderiv_within_at_nonneg":
 "/-- If `f` has a local min on `s` at `a`, `f'` is the derivative of `f` at `a` within `s`, and\n`y` belongs to the positive tangent cone of `s` at `a`, then `0 ≤ f' y`. -/\ntheorem is_local_min_on.has_fderiv_within_at_nonneg {s : set E} (h : is_local_min_on f s a)\n    (hf : has_fderiv_within_at f f' s a) {y} (hy : y ∈ pos_tangent_cone_at s a) : 0 ≤ f' y := by\n  simpa using h.neg.has_fderiv_within_at_nonpos hf.neg hy\n#align is_local_min_on.has_fderiv_within_at_nonneg is_local_min_on.has_fderiv_within_at_nonneg\n\n",
 "has_fderiv_within_at_eq_zero":
 "/-- If `f` has a local max on `s` at `a`, `f'` is a derivative of `f` at `a` within `s`, and\nboth `y` and `-y` belong to the positive tangent cone of `s` at `a`, then `f' y ≤ 0`. -/\ntheorem is_local_min_on.has_fderiv_within_at_eq_zero {s : set E} (h : is_local_min_on f s a)\n    (hf : has_fderiv_within_at f f' s a) {y} (hy : y ∈ pos_tangent_cone_at s a) (hy' : -y ∈ pos_tangent_cone_at s a) :\n    f' y = 0 := by simpa using h.neg.has_fderiv_within_at_eq_zero hf.neg hy hy'\n#align is_local_min_on.has_fderiv_within_at_eq_zero is_local_min_on.has_fderiv_within_at_eq_zero\n\n",
 "has_fderiv_at_eq_zero":
 "/-- **Fermat's Theorem**: the derivative of a function at a local extremum equals zero. -/\ntheorem is_local_extr.has_fderiv_at_eq_zero (h : is_local_extr f a) : has_fderiv_at f f' a → f' = 0 :=\n  h.elim is_local_min.has_fderiv_at_eq_zero is_local_max.has_fderiv_at_eq_zero\n#align is_local_extr.has_fderiv_at_eq_zero is_local_extr.has_fderiv_at_eq_zero\n\n",
 "has_deriv_at_eq_zero":
 "/-- **Fermat's Theorem**: the derivative of a function at a local extremum equals zero. -/\ntheorem is_local_extr.has_deriv_at_eq_zero (h : is_local_extr f a) : has_deriv_at f f' a → f' = 0 :=\n  h.elim is_local_min.has_deriv_at_eq_zero is_local_max.has_deriv_at_eq_zero\n#align is_local_extr.has_deriv_at_eq_zero is_local_extr.has_deriv_at_eq_zero\n\n",
 "fderiv_within_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `f` has a local max on `s` at `a` and `y` belongs to the positive tangent cone\nof `s` at `a`, then `f' y ≤ 0`. -/\ntheorem is_local_max_on.fderiv_within_nonpos {s : set E} (h : is_local_max_on f s a) {y}\n    (hy : y ∈ pos_tangent_cone_at s a) : (fderiv_within (exprℝ) f s a : E → exprℝ) y ≤ 0 :=\n  if hf : differentiable_within_at (exprℝ) f s a then h.has_fderiv_within_at_nonpos hf.has_fderiv_within_at hy\n  else by\n    rw [fderiv_within_zero_of_not_differentiable_within_at hf]\n    rfl\n#align is_local_max_on.fderiv_within_nonpos is_local_max_on.fderiv_within_nonpos\n\n",
 "fderiv_within_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `f` has a local min on `s` at `a` and `y` belongs to the positive tangent cone\nof `s` at `a`, then `0 ≤ f' y`. -/\ntheorem is_local_min_on.fderiv_within_nonneg {s : set E} (h : is_local_min_on f s a) {y}\n    (hy : y ∈ pos_tangent_cone_at s a) : (0 : exprℝ) ≤ (fderiv_within (exprℝ) f s a : E → exprℝ) y :=\n  if hf : differentiable_within_at (exprℝ) f s a then h.has_fderiv_within_at_nonneg hf.has_fderiv_within_at hy\n  else by\n    rw [fderiv_within_zero_of_not_differentiable_within_at hf]\n    rfl\n#align is_local_min_on.fderiv_within_nonneg is_local_min_on.fderiv_within_nonneg\n\n",
 "fderiv_within_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `f` has a local min on `s` at `a` and both `y` and `-y` belong to the positive tangent cone\nof `s` at `a`, then `f' y = 0`. -/\ntheorem is_local_min_on.fderiv_within_eq_zero {s : set E} (h : is_local_min_on f s a) {y}\n    (hy : y ∈ pos_tangent_cone_at s a) (hy' : -y ∈ pos_tangent_cone_at s a) :\n    (fderiv_within (exprℝ) f s a : E → exprℝ) y = 0 :=\n  if hf : differentiable_within_at (exprℝ) f s a then h.has_fderiv_within_at_eq_zero hf.has_fderiv_within_at hy hy'\n  else by\n    rw [fderiv_within_zero_of_not_differentiable_within_at hf]\n    rfl\n#align is_local_min_on.fderiv_within_eq_zero is_local_min_on.fderiv_within_eq_zero\n\n",
 "fderiv_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Fermat's Theorem**: the derivative of a function at a local extremum equals zero. -/\ntheorem is_local_extr.fderiv_eq_zero (h : is_local_extr f a) : fderiv (exprℝ) f a = 0 :=\n  h.elim is_local_min.fderiv_eq_zero is_local_max.fderiv_eq_zero\n#align is_local_extr.fderiv_eq_zero is_local_extr.fderiv_eq_zero\n\n",
 "exists_local_extr_Ioo":
 "/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem exists_local_extr_Ioo (hab : a < b) (hfc : continuous_on f (Icc a b)) (hfI : f a = f b) :\n    ∃ c ∈ Ioo a b, is_local_extr f c :=\n  let ⟨c, cmem, hc⟩ := exists_Ioo_extr_on_Icc f hab hfc hfI\n  ⟨c, cmem, hc.is_local_extr <| Icc_mem_nhds cmem.1 cmem.2⟩\n#align exists_local_extr_Ioo exists_local_extr_Ioo\n\n",
 "exists_has_deriv_at_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- **Rolle's Theorem**, a version for a function on an open interval: if `f` has derivative `f'`\non `(a, b)` and has the same limit `l` at `𝓝[>] a` and `𝓝[<] b`, then `f' c = 0`\nfor some `c ∈ (a, b)`.  -/\ntheorem exists_has_deriv_at_eq_zero' (hab : a < b) (hfa : tendsto f (nhds_within.gt a) ((nhds) l))\n    (hfb : tendsto f (nhds_within.lt b) ((nhds) l)) (hff' : ∀ x ∈ Ioo a b, has_deriv_at f (f' x) x) :\n    ∃ c ∈ Ioo a b, f' c = 0 :=\n  by\n  have : continuous_on f (Ioo a b) := fun x hx => (hff' x hx).continuous_at.continuous_within_at\n  have hcont := continuous_on_Icc_extend_from_Ioo hab.ne this hfa hfb\n  obtain ⟨c, hc, hcextr⟩ : ∃ c ∈ Ioo a b, is_local_extr (extend_from (Ioo a b) f) c :=\n    by\n    apply exists_local_extr_Ioo _ hab hcont\n    rw [eq_lim_at_right_extend_from_Ioo hab hfb]\n    exact eq_lim_at_left_extend_from_Ioo hab hfa\n  use c, hc\n  apply (hcextr.congr _).has_deriv_at_eq_zero (hff' c hc)\n  rw [eventually_eq_iff_exists_mem]\n  exact ⟨Ioo a b, Ioo_mem_nhds hc.1 hc.2, extend_from_extends this⟩\n#align exists_has_deriv_at_eq_zero' exists_has_deriv_at_eq_zero'\n\n",
 "exists_has_deriv_at_eq_zero":
 "/-- **Rolle's Theorem** `has_deriv_at` version -/\ntheorem exists_has_deriv_at_eq_zero (hab : a < b) (hfc : continuous_on f (Icc a b)) (hfI : f a = f b)\n    (hff' : ∀ x ∈ Ioo a b, has_deriv_at f (f' x) x) : ∃ c ∈ Ioo a b, f' c = 0 :=\n  let ⟨c, cmem, hc⟩ := exists_local_extr_Ioo f hab hfc hfI\n  ⟨c, cmem, hc.has_deriv_at_eq_zero <| hff' c cmem⟩\n#align exists_has_deriv_at_eq_zero exists_has_deriv_at_eq_zero\n\n",
 "exists_deriv_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.lt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- **Rolle's Theorem**, a version for a function on an open interval: if `f` has the same limit\n`l` at `𝓝[>] a` and `𝓝[<] b`, then `deriv f c = 0` for some `c ∈ (a, b)`. This version\ndoes not require differentiability of `f` because we define `deriv f c = 0` whenever `f` is not\ndifferentiable at `c`. -/\ntheorem exists_deriv_eq_zero' (hab : a < b) (hfa : tendsto f (nhds_within.gt a) ((nhds) l))\n    (hfb : tendsto f (nhds_within.lt b) ((nhds) l)) : ∃ c ∈ Ioo a b, deriv f c = 0 :=\n  by_cases\n    (fun h : ∀ x ∈ Ioo a b, differentiable_at (exprℝ) f x =>\n      show ∃ c ∈ Ioo a b, deriv f c = 0 from exists_has_deriv_at_eq_zero' hab hfa hfb fun x hx => (h x hx).has_deriv_at)\n    fun h : ¬∀ x ∈ Ioo a b, differentiable_at (exprℝ) f x =>\n    have h : ∃ x, x ∈ Ioo a b ∧ ¬differentiable_at (exprℝ) f x :=\n      by\n      push_neg  at h\n      exact h\n    let ⟨c, hc, hcdiff⟩ := h\n    ⟨c, hc, deriv_zero_of_not_differentiable_at hcdiff⟩\n#align exists_deriv_eq_zero' exists_deriv_eq_zero'\n\n",
 "exists_deriv_eq_zero":
 "/-- **Rolle's Theorem** `deriv` version -/\ntheorem exists_deriv_eq_zero (hab : a < b) (hfc : continuous_on f (Icc a b)) (hfI : f a = f b) :\n    ∃ c ∈ Ioo a b, deriv f c = 0 :=\n  let ⟨c, cmem, hc⟩ := exists_local_extr_Ioo f hab hfc hfI\n  ⟨c, cmem, hc.deriv_eq_zero⟩\n#align exists_deriv_eq_zero exists_deriv_eq_zero\n\n",
 "exists_Ioo_extr_on_Icc":
 "/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem exists_Ioo_extr_on_Icc (hab : a < b) (hfc : continuous_on f (Icc a b)) (hfI : f a = f b) :\n    ∃ c ∈ Ioo a b, is_extr_on f (Icc a b) c :=\n  by\n  have ne : (Icc a b).nonempty := nonempty_Icc.2 (le_of_lt hab)\n  -- Consider absolute min and max points\n  obtain ⟨c, cmem, cle⟩ : ∃ c ∈ Icc a b, ∀ x ∈ Icc a b, f c ≤ f x\n  exact is_compact_Icc.exists_forall_le ne hfc\n  obtain ⟨C, Cmem, Cge⟩ : ∃ C ∈ Icc a b, ∀ x ∈ Icc a b, f x ≤ f C\n  exact is_compact_Icc.exists_forall_ge ne hfc\n  by_cases hc : f c = f a\n  · by_cases hC : f C = f a\n    · have : ∀ x ∈ Icc a b, f x = f a := fun x hx => le_antisymm (hC ▸ Cge x hx) (hc ▸ cle x hx)\n      -- `f` is a constant, so we can take any point in `Ioo a b`\n      rcases exists_between hab with ⟨c', hc'⟩\n      refine' ⟨c', hc', or.inl _⟩\n      intro x hx\n      rw [mem_set_of_eq, this x hx, ← hC]\n      exact Cge c' ⟨le_of_lt hc'.1, le_of_lt hc'.2⟩\n    · refine' ⟨C, ⟨lt_of_le_of_ne Cmem.1 <| mt _ hC, lt_of_le_of_ne Cmem.2 <| mt _ hC⟩, or.inr Cge⟩\n      exacts[fun h => by rw [h], fun h => by rw [h, hfI]]\n  · refine' ⟨c, ⟨lt_of_le_of_ne cmem.1 <| mt _ hc, lt_of_le_of_ne cmem.2 <| mt _ hc⟩, or.inl cle⟩\n    exacts[fun h => by rw [h], fun h => by rw [h, hfI]]\n#align exists_Ioo_extr_on_Icc exists_Ioo_extr_on_Icc\n\n",
 "deriv_eq_zero":
 "/-- **Fermat's Theorem**: the derivative of a function at a local extremum equals zero. -/\ntheorem is_local_extr.deriv_eq_zero (h : is_local_extr f a) : deriv f a = 0 :=\n  h.elim is_local_min.deriv_eq_zero is_local_max.deriv_eq_zero\n#align is_local_extr.deriv_eq_zero is_local_extr.deriv_eq_zero\n\n",
 "card_roots_to_finset_le_derivative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem card_roots_to_finset_le_derivative (p : polynomial (exprℝ)) :\n    p.roots.to_finset.card ≤ p.derivative.roots.to_finset.card + 1 :=\n  p.card_roots_to_finset_le_card_roots_derivative_diff_roots_succ.trans <|\n    add_le_add_right (finset.card_mono <| Finset.sdiff_subset _ _) _\n#align card_roots_to_finset_le_derivative card_roots_to_finset_le_derivative\n\n",
 "card_roots_to_finset_le_card_roots_derivative_diff_roots_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The number of roots of a real polynomial `p` is at most the number of roots of its derivative\nthat are not roots of `p` plus one. -/\ntheorem card_roots_to_finset_le_card_roots_derivative_diff_roots_succ (p : polynomial (exprℝ)) :\n    p.roots.to_finset.card ≤ (p.derivative.roots.to_finset \\ p.roots.to_finset).card + 1 :=\n  by\n  cases' eq_or_ne p.derivative 0 with hp' hp'\n  · rw [eq_C_of_derivative_eq_zero hp', roots_C, Multiset.toFinset_zero, finset.card_empty]\n    exact zero_le _\n  have hp : p ≠ 0 := ne_of_apply_ne derivative (by rwa [derivative_zero])\n  refine' finset.card_le_diff_of_interleaved fun x hx y hy hxy hxy' => _\n  rw [Multiset.mem_toFinset, mem_roots hp] at hx hy\n  obtain ⟨z, hz1, hz2⟩ := exists_deriv_eq_zero (fun x : exprℝ => eval x p) hxy p.continuous_on (hx.trans hy.symm)\n  refine' ⟨z, _, hz1⟩\n  rwa [Multiset.mem_toFinset, mem_roots hp', is_root, ← p.deriv]\n#align\n  card_roots_to_finset_le_card_roots_derivative_diff_roots_succ card_roots_to_finset_le_card_roots_derivative_diff_roots_succ\n\n",
 "card_roots_le_derivative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem card_roots_le_derivative (p : polynomial (exprℝ)) : p.roots.card ≤ p.derivative.roots.card + 1 :=\n  calc\n    p.roots.card =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          p.roots.to_finset (p.roots.count x) :=\n      (multiset.to_finset_sum_count_eq _).symm\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          p.roots.to_finset (p.roots.count x - 1 + 1) :=\n      eq.symm <|\n        finset.sum_congr rfl fun x hx =>\n          tsub_add_cancel_of_le <| Nat.succ_le_iff.2 <| Multiset.count_pos.2 <| Multiset.mem_toFinset.1 hx\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            p.roots.to_finset (p.root_multiplicity x - 1) +\n          p.roots.to_finset.card :=\n      by simp only [finset.sum_add_distrib, finset.card_eq_sum_ones, count_roots]\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            p.roots.to_finset (p.derivative.root_multiplicity x) +\n          ((p.derivative.roots.to_finset \\ p.roots.to_finset).card + 1) :=\n      add_le_add (finset.sum_le_sum fun x hx => root_multiplicity_sub_one_le_derivative_root_multiplicity _ _)\n        p.card_roots_to_finset_le_card_roots_derivative_diff_roots_succ\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            p.roots.to_finset (p.derivative.roots.count x) +\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (p.derivative.roots.to_finset \\ p.roots.to_finset) (p.derivative.roots.count x) +\n            1) :=\n      by\n      simp only [← count_roots]\n      refine' add_le_add_left (add_le_add_right ((finset.card_eq_sum_ones _).trans_le _) _) _\n      refine' finset.sum_le_sum fun x hx => Nat.succ_le_iff.2 <| _\n      rw [Multiset.count_pos, ← Multiset.mem_toFinset]\n      exact (Finset.mem_sdiff.1 hx).1\n    _ = p.derivative.roots.card + 1 :=\n      by\n      rw [← add_assoc, ← finset.sum_union Finset.disjoint_sdiff, Finset.union_sdiff_self_eq_union, ←\n        multiset.to_finset_sum_count_eq, ← finset.sum_subset (Finset.subset_union_right _ _)]\n      intro x hx₁ hx₂\n      simpa only [Multiset.mem_toFinset, Multiset.count_eq_zero] using hx₂\n    \n#align card_roots_le_derivative card_roots_le_derivative\n\n",
 "card_root_set_le_derivative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem card_root_set_le_derivative {F : Type _} [CommRing F] [algebra F (exprℝ)] (p : polynomial F) :\n    fintype.card (p.root_set (exprℝ)) ≤ fintype.card (p.derivative.root_set (exprℝ)) + 1 := by\n  simpa only [root_set_def, Finset.coe_sort_coe, fintype.card_coe, derivative_map] using\n    card_roots_to_finset_le_derivative (p.map (algebra_map F (exprℝ)))\n#align card_root_set_le_derivative card_root_set_le_derivative\n\n"}