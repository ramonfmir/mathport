{"zero_of_nonpos":
 "theorem zero_of_nonpos (h : x ≤ 0) : smooth_transition x = 0 := by rw [smooth_transition, zero_of_nonpos h, zero_div]\n#align zero_of_nonpos zero_of_nonpos\n\n",
 "zero_of_le_dist":
 "theorem zero_of_le_dist (hx : f.R ≤ euclidean.dist x c) : f x = 0 :=\n  f.to_cont_diff_bump_of_inner.zero_of_le_dist hx\n#align zero_of_le_dist zero_of_le_dist\n\n",
 "zero":
 "@[simp]\nprotected theorem zero : smooth_transition 0 = 0 :=\n  zero_of_nonpos le_rfl\n#align zero zero\n\n",
 "tsupport_normed_eq":
 "theorem tsupport_normed_eq : tsupport (f.normed μ) = metric.closed_ball c f.R := by\n  simp_rw [tsupport, f.support_normed_eq, closure_ball _ f.R_pos.ne']\n#align tsupport_normed_eq tsupport_normed_eq\n\n",
 "tsupport_eq":
 "theorem tsupport_eq : tsupport f = euclidean.closed_ball c f.R := by\n  rw [tsupport, f.support_eq, euclidean.closure_ball _ f.R_pos.ne']\n#align tsupport_eq tsupport_eq\n\n",
 "tendsto_support_normed_small_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_support_normed_small_sets {ι} {φ : ι → cont_diff_bump_of_inner c} {l : filter ι}\n    (hφ : tendsto (fun i => (φ i).R) l ((nhds) 0)) :\n    tendsto (fun i => support fun x => (φ i).normed μ x) l ((nhds) c).small_sets :=\n  by\n  simp_rw [normed_add_comm_group.tendsto_nhds_zero, real.norm_eq_abs, abs_eq_self.mpr (φ _).R_pos.le] at hφ\n  rw [tendsto_small_sets_iff]\n  intro t ht\n  rcases metric.mem_nhds_iff.mp ht with ⟨ε, hε, ht⟩\n  refine' (hφ ε hε).mono fun i hi => subset_trans _ ht\n  simp_rw [(φ i).support_normed_eq]\n  exact ball_subset_ball hi.le\n#align tendsto_support_normed_small_sets tendsto_support_normed_small_sets\n\n",
 "support_normed_eq":
 "theorem support_normed_eq : support (f.normed μ) = metric.ball c f.R := by\n  simp_rw [cont_diff_bump_of_inner.normed, support_div, f.support_eq, support_const f.integral_pos.ne', inter_univ]\n#align support_normed_eq support_normed_eq\n\n",
 "support_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem support_eq : support (f : E → exprℝ) = euclidean.ball c f.R := by\n  rw [euclidean.ball_eq_preimage, ← f.to_cont_diff_bump_of_inner.support_eq, ← support_comp_eq_preimage, coe_eq_comp]\n#align support_eq support_eq\n\n",
 "sub":
 "protected theorem sub (x : E) : f (c - x) = f (c + x) := by simp_rw [f.def, dist_self_sub_left, dist_self_add_left]\n#align sub sub\n\n",
 "pos_of_pos":
 "theorem pos_of_pos (h : 0 < x) : 0 < smooth_transition x :=\n  div_pos (exp_neg_inv_glue.pos_of_pos h) (pos_denom x)\n#align pos_of_pos pos_of_pos\n\n",
 "pos_of_mem_ball":
 "theorem pos_of_mem_ball (hx : x ∈ euclidean.ball c f.R) : 0 < f x :=\n  f.to_cont_diff_bump_of_inner.pos_of_mem_ball hx\n#align pos_of_mem_ball pos_of_mem_ball\n\n",
 "pos_denom":
 "theorem pos_denom (x) : 0 < exp_neg_inv_glue x + exp_neg_inv_glue (1 - x) :=\n  (zero_lt_one.lt_or_lt x).elim (fun hx => add_pos_of_pos_of_nonneg (pos_of_pos hx) (nonneg _)) fun hx =>\n    add_pos_of_nonneg_of_pos (nonneg _) (pos_of_pos <| sub_pos.2 hx)\n#align pos_denom pos_denom\n\n",
 "one_of_one_le":
 "theorem one_of_one_le (h : 1 ≤ x) : smooth_transition x = 1 :=\n  (div_eq_one_iff_eq <| (pos_denom x).ne').2 <| by rw [zero_of_nonpos (sub_nonpos.2 h), add_zero]\n#align one_of_one_le one_of_one_le\n\n",
 "one_of_mem_closed_ball":
 "theorem one_of_mem_closed_ball (hx : x ∈ euclidean.closed_ball c f.r) : f x = 1 :=\n  f.to_cont_diff_bump_of_inner.one_of_mem_closed_ball hx\n#align one_of_mem_closed_ball one_of_mem_closed_ball\n\n",
 "one":
 "@[simp]\nprotected theorem one : smooth_transition 1 = 1 :=\n  one_of_one_le le_rfl\n#align one one\n\n",
 "normed_sub":
 "theorem normed_sub (x : E) : f.normed μ (c - x) = f.normed μ (c + x) := by simp_rw [f.normed_def, f.sub]\n#align normed_sub normed_sub\n\n",
 "normed_neg":
 "theorem normed_neg (f : cont_diff_bump_of_inner (0 : E)) (x : E) : f.normed μ (-x) = f.normed μ x := by\n  simp_rw [f.normed_def, f.neg]\n#align normed_neg normed_neg\n\n",
 "normed_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem normed_def {μ : measure E} (x : E) :\n    f.normed μ x =\n      f x /\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ :=\n  rfl\n#align normed_def normed_def\n\n",
 "nonneg_normed":
 "theorem nonneg_normed (x : E) : 0 ≤ f.normed μ x :=\n  div_nonneg f.nonneg <| integral_nonneg f.nonneg'\n#align nonneg_normed nonneg_normed\n\n",
 "nonneg'":
 "/-- A version of `cont_diff_bump_of_inner.nonneg` with `x` explicit -/\ntheorem nonneg' (x : E) : 0 ≤ f x :=\n  f.nonneg\n#align nonneg' nonneg'\n\n",
 "nonneg":
 "theorem nonneg : 0 ≤ f x :=\n  f.to_cont_diff_bump_of_inner.nonneg\n#align nonneg nonneg\n\n",
 "neg":
 "protected theorem neg (f : cont_diff_bump_of_inner (0 : E)) (x : E) : f (-x) = f x := by\n  simp_rw [← zero_sub, f.sub, zero_add]\n#align neg neg\n\n",
 "lt_one_of_lt_one":
 "theorem lt_one_of_lt_one (h : x < 1) : smooth_transition x < 1 :=\n  (div_lt_one <| pos_denom x).2 <| lt_add_of_pos_right _ <| pos_of_pos <| sub_pos.2 h\n#align lt_one_of_lt_one lt_one_of_lt_one\n\n",
 "lt_one_of_lt_dist":
 "theorem lt_one_of_lt_dist (h : f.r < euclidean.dist x c) : f x < 1 :=\n  f.to_cont_diff_bump_of_inner.lt_one_of_lt_dist h\n#align lt_one_of_lt_dist lt_one_of_lt_dist\n\n",
 "le_one":
 "theorem le_one : f x ≤ 1 :=\n  f.to_cont_diff_bump_of_inner.le_one\n#align le_one le_one\n\n",
 "integral_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_pos :\n    0 < «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ :=\n  by\n  refine' (integral_pos_iff_support_of_nonneg f.nonneg' f.integrable).mpr _\n  rw [f.support_eq]\n  refine' is_open_ball.measure_pos _ (nonempty_ball.mpr f.R_pos)\n#align integral_pos integral_pos\n\n",
 "integral_normed_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem integral_normed_smul (z : X) [complete_space X] :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr • » (f.normed μ x) z) μ =\n      z :=\n  by simp_rw [integral_smul_const, f.integral_normed, one_smul]\n#align integral_normed_smul integral_normed_smul\n\n",
 "integral_normed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\ntheorem integral_normed :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f.normed μ x)\n        μ =\n      1 :=\n  by\n  simp_rw [cont_diff_bump_of_inner.normed, div_eq_mul_inv, mul_comm (f _), ← smul_eq_mul, integral_smul]\n  exact inv_mul_cancel f.integral_pos.ne'\n#align integral_normed integral_normed\n\n",
 "integrable_normed":
 "protected theorem integrable_normed : integrable (f.normed μ) μ :=\n  f.integrable.div_const _\n#align integrable_normed integrable_normed\n\n",
 "integrable":
 "protected theorem integrable : integrable f μ :=\n  f.continuous.integrable_of_has_compact_support f.has_compact_support\n#align integrable integrable\n\n",
 "has_compact_support_normed":
 "theorem has_compact_support_normed : has_compact_support (f.normed μ) := by\n  simp_rw [has_compact_support, f.tsupport_normed_eq, is_compact_closed_ball]\n#align has_compact_support_normed has_compact_support_normed\n\n",
 "has_compact_support":
 "protected theorem has_compact_support : has_compact_support f := by\n  simp_rw [has_compact_support, f.tsupport_eq, euclidean.is_compact_closed_ball]\n#align has_compact_support has_compact_support\n\n",
 "f_aux_zero_eq":
 "/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel, Floris van Doorn\n-/\n/-- The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition. -/\ntheorem f_aux_zero_eq : f_aux 0 = exp_neg_inv_glue := by\n  ext x\n  by_cases h : x ≤ 0\n  · simp [exp_neg_inv_glue, f_aux, h]\n  · simp [h, exp_neg_inv_glue, f_aux, ne_of_gt (not_le.1 h), P_aux]\n#align f_aux_zero_eq f_aux_zero_eq\n\n",
 "f_aux_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- To get differentiability at `0` of the auxiliary functions, we need to know that their limit\nis `0`, to be able to apply general differentiability extension theorems. This limit is checked in\nthis lemma. -/\ntheorem f_aux_limit (n : ℕ) :\n    tendsto (fun x => (P_aux n).eval x * exp (-x⁻¹) / x ^ (2 * n)) (nhds_within.gt 0) ((nhds) 0) :=\n  by\n  have A : tendsto (fun x => (P_aux n).eval x) (nhds_within.gt 0) ((nhds) ((P_aux n).eval 0)) :=\n    (P_aux n).continuous_within_at\n  have B : tendsto (fun x => exp (-x⁻¹) / x ^ (2 * n)) (nhds_within.gt 0) ((nhds) 0) :=\n    by\n    convert (tendsto_pow_mul_exp_neg_at_top_nhds_0 (2 * n)).comp tendsto_inv_zero_at_top\n    ext x\n    field_simp\n  convert A.mul B <;> simp [mul_div_assoc]\n#align f_aux_limit f_aux_limit\n\n",
 "f_aux_iterated_deriv":
 "/-- The successive derivatives of the auxiliary function `f_aux 0` are the\nfunctions `f_aux n`, by induction. -/\ntheorem f_aux_iterated_deriv (n : ℕ) : iterated_deriv n (f_aux 0) = f_aux n :=\n  by\n  induction' n with n IH\n  · simp\n  · simp [iterated_deriv_succ, IH]\n    ext x\n    exact (f_aux_has_deriv_at n x).deriv\n#align f_aux_iterated_deriv f_aux_iterated_deriv\n\n",
 "f_aux_has_deriv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- At every point, the auxiliary function `f_aux n` has a derivative which is\nequal to `f_aux (n+1)`. -/\ntheorem f_aux_has_deriv_at (n : ℕ) (x : exprℝ) : has_deriv_at (f_aux n) (f_aux (n + 1) x) x :=\n  by\n  -- check separately the result for `x < 0`, where it is trivial, for `x > 0`, where it is done\n  -- in `f_aux_deriv_pos`, and for `x = 0`, done in\n  -- `f_aux_deriv_zero`.\n  rcases lt_trichotomy x 0 with (hx | hx | hx)\n  · have : f_aux (n + 1) x = 0 := by simp [f_aux, le_of_lt hx]\n    rw [this]\n    apply (has_deriv_at_const x (0 : exprℝ)).congr_of_eventually_eq\n    filter_upwards [gt_mem_nhds hx] with _ hy\n    simp [f_aux, hy.le]\n  · have : f_aux (n + 1) 0 = 0 := by simp [f_aux, le_refl]\n    rw [hx, this]\n    exact f_aux_deriv_zero n\n  · have : f_aux (n + 1) x = (P_aux (n + 1)).eval x * exp (-x⁻¹) / x ^ (2 * (n + 1)) := by simp [f_aux, not_le_of_gt hx]\n    rw [this]\n    exact f_aux_deriv_pos n x hx\n#align f_aux_has_deriv_at f_aux_has_deriv_at\n\n",
 "f_aux_deriv_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Deduce from the limiting behavior at `0` of its derivative and general differentiability\nextension theorems that the auxiliary function `f_aux n` is differentiable at `0`,\nwith derivative `0`. -/\ntheorem f_aux_deriv_zero (n : ℕ) : has_deriv_at (f_aux n) 0 0 :=\n  by\n  -- we check separately differentiability on the left and on the right\n  have A : has_deriv_within_at (f_aux n) (0 : exprℝ) (Iic 0) 0 :=\n    by\n    apply (has_deriv_at_const (0 : exprℝ) (0 : exprℝ)).has_deriv_within_at.congr\n    · intro y hy\n      simp at hy\n      simp [f_aux, hy]\n    · simp [f_aux, le_refl]\n  have B : has_deriv_within_at (f_aux n) (0 : exprℝ) (Ici 0) 0 :=\n    by\n    have diff : differentiable_on (exprℝ) (f_aux n) (Ioi 0) := fun x hx =>\n      (f_aux_deriv_pos n x hx).differentiable_at.differentiable_within_at\n    -- next line is the nontrivial bit of this proof, appealing to differentiability\n    -- extension results.\n    apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within\n    · refine' (f_aux_limit (n + 1)).congr' _\n      apply mem_of_superset self_mem_nhds_within fun x hx => _\n      simp [(f_aux_deriv_pos n x hx).deriv]\n    · have : f_aux n 0 = 0 := by simp [f_aux, le_refl]\n      simp only [continuous_within_at, this]\n      refine' (f_aux_limit n).congr' _\n      apply mem_of_superset self_mem_nhds_within fun x hx => _\n      have : ¬x ≤ 0 := by simpa using hx\n      simp [f_aux, this]\n  simpa using A.union B\n#align f_aux_deriv_zero f_aux_deriv_zero\n\n",
 "f_aux_deriv_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`\nis the `n+1`-th auxiliary function. -/\ntheorem f_aux_deriv_pos (n : ℕ) (x : exprℝ) (hx : 0 < x) :\n    has_deriv_at (f_aux n) ((P_aux (n + 1)).eval x * exp (-x⁻¹) / x ^ (2 * (n + 1))) x :=\n  by\n  apply (f_aux_deriv n x (ne_of_gt hx)).congr_of_eventually_eq\n  filter_upwards [lt_mem_nhds hx] with _ hy\n  simp [f_aux, hy.not_le]\n#align f_aux_deriv_pos f_aux_deriv_pos\n\n",
 "f_aux_deriv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr pow_ne_zero, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`\n(given in this statement in unfolded form) is the `n+1`-th auxiliary function, since\nthe polynomial `P_aux (n+1)` was chosen precisely to ensure this. -/\ntheorem f_aux_deriv (n : ℕ) (x : exprℝ) (hx : x ≠ 0) :\n    has_deriv_at (fun x => (P_aux n).eval x * exp (-x⁻¹) / x ^ (2 * n))\n      ((P_aux (n + 1)).eval x * exp (-x⁻¹) / x ^ (2 * (n + 1))) x :=\n  by\n  simp only [P_aux, eval_add, eval_sub, eval_mul, eval_pow, eval_X, eval_C, eval_one]\n  convert\n    (((P_aux n).has_deriv_at x).mul ((has_deriv_at_exp _).comp x (has_deriv_at_inv hx).neg)).div\n      (has_deriv_at_pow (2 * n) x) (pow_ne_zero _ hx) using\n    1\n  rw [div_eq_div_iff]\n  · have := pow_ne_zero 2 hx\n    field_simp only\n    cases n\n    · simp only [mul_zero, Nat.cast_zero, mul_one]\n      ring\n    · rw [(id rfl : 2 * n.succ - 1 = 2 * n + 1)]\n      ring\n  all_goals\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\\\"[\\\", expr pow_ne_zero, \\\"]\\\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error\"\n#align f_aux_deriv f_aux_deriv\n\n",
 "exists_tsupport_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem exists_tsupport_subset {s : set E} (hs : s ∈ (nhds) c) : ∃ f : cont_diff_bump c, tsupport f ⊆ s :=\n  let ⟨R, h0, hR⟩ := euclidean.nhds_basis_closed_ball.mem_iff.1 hs\n  ⟨⟨⟨R / 2, R, half_pos h0, half_lt_self h0⟩⟩, by rwa [tsupport_eq]⟩\n#align exists_tsupport_subset exists_tsupport_subset\n\n",
 "exists_cont_diff_bump_function_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `E` is a finite dimensional normed space over `ℝ`, then for any point `x : E` and its\nneighborhood `s` there exists an infinitely smooth function with the following properties:\n\n* `f y = 1` in a neighborhood of `x`;\n* `f y = 0` outside of `s`;\n*  moreover, `tsupport f ⊆ s` and `f` has compact support;\n* `f y ∈ [0, 1]` for all `y`.\n\nThis lemma is a simple wrapper around lemmas about bundled smooth bump functions, see\n`cont_diff_bump`. -/\ntheorem exists_cont_diff_bump_function_of_mem_nhds [normed_add_comm_group E] [normed_space (exprℝ) E]\n    [finite_dimensional (exprℝ) E] {x : E} {s : set E} (hs : s ∈ (nhds) x) :\n    ∃ f : E → exprℝ,\n      «expr =ᶠ[ ] » f ((nhds) x) 1 ∧\n        (∀ y, f y ∈ Icc (0 : exprℝ) 1) ∧ cont_diff (exprℝ) («expr⊤») f ∧ has_compact_support f ∧ tsupport f ⊆ s :=\n  let ⟨f, hf⟩ := cont_diff_bump.exists_tsupport_subset hs\n  ⟨f, f.eventually_eq_one, fun y => ⟨f.nonneg, f.le_one⟩, f.cont_diff, f.has_compact_support, hf⟩\n#align exists_cont_diff_bump_function_of_mem_nhds exists_cont_diff_bump_function_of_mem_nhds\n\n",
 "exists_closure_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_closure_subset {R : exprℝ} (hR : 0 < R) {s : set E} (hs : is_closed s) (hsR : s ⊆ euclidean.ball c R) :\n    ∃ f : cont_diff_bump c, f.R = R ∧ s ⊆ euclidean.ball c f.r :=\n  by\n  rcases euclidean.exists_pos_lt_subset_ball hR hs hsR with ⟨r, hr, hsr⟩\n  exact ⟨⟨⟨r, R, hr.1, hr.2⟩⟩, rfl, hsr⟩\n#align exists_closure_subset exists_closure_subset\n\n",
 "eventually_eq_one_of_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_one_of_mem_ball (h : x ∈ euclidean.ball c f.r) : «expr =ᶠ[ ] » f ((nhds) x) 1 :=\n  to_euclidean.continuous_at (f.to_cont_diff_bump_of_inner.eventually_eq_one_of_mem_ball h)\n#align eventually_eq_one_of_mem_ball eventually_eq_one_of_mem_ball\n\n",
 "eventually_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_eq_one : «expr =ᶠ[ ] » f ((nhds) c) 1 :=\n  f.eventually_eq_one_of_mem_ball <| euclidean.mem_ball_self f.r_pos\n#align eventually_eq_one eventually_eq_one\n\n",
 "def":
 "protected theorem def (x : E) : f x = real.smooth_transition ((f.R - dist x c) / (f.R - f.r)) :=\n  rfl\n#align def def\n\n",
 "continuous_normed":
 "theorem continuous_normed : continuous (f.normed μ) :=\n  f.continuous.div_const\n#align continuous_normed continuous_normed\n\n",
 "continuous":
 "protected theorem continuous : continuous f :=\n  cont_diff_zero.mp f.cont_diff\n#align continuous continuous\n\n",
 "cont_diff_within_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem cont_diff_within_at {s n} : cont_diff_within_at (exprℝ) n f s x :=\n  f.cont_diff_at.cont_diff_within_at\n#align cont_diff_within_at cont_diff_within_at\n\n",
 "cont_diff_normed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cont_diff_normed {n : «exprℕ∞»} : cont_diff (exprℝ) n (f.normed μ) :=\n  f.cont_diff.div_const\n#align cont_diff_normed cont_diff_normed\n\n",
 "cont_diff_bump":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem _root_.cont_diff.cont_diff_bump {c g : X → E} {f : ∀ x, cont_diff_bump_of_inner (c x)}\n    (hc : cont_diff (exprℝ) n c) (hr : cont_diff (exprℝ) n fun x => (f x).r) (hR : cont_diff (exprℝ) n fun x => (f x).R)\n    (hg : cont_diff (exprℝ) n g) : cont_diff (exprℝ) n fun x => f x (g x) :=\n  by\n  rw [cont_diff_iff_cont_diff_at] at *\n  exact fun x => (hc x).cont_diff_bump (hr x) (hR x) (hg x)\n#align cont_diff.cont_diff_bump cont_diff.cont_diff_bump\n\n",
 "cont_diff_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem cont_diff_at {n} : cont_diff_at (exprℝ) n f x :=\n  f.cont_diff.cont_diff_at\n#align cont_diff_at cont_diff_at\n\n",
 "cont_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem cont_diff {n} : cont_diff (exprℝ) n f :=\n  f.to_cont_diff_bump_of_inner.cont_diff.comp (to_euclidean : «expr ≃L[ ] » E (exprℝ) _).cont_diff\n#align cont_diff cont_diff\n\n",
 "coe_eq_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_eq_comp : «expr⇑ » f = f.to_cont_diff_bump_of_inner ∘ to_euclidean :=\n  rfl\n#align coe_eq_comp coe_eq_comp\n\n",
 "R_pos":
 "theorem R_pos : 0 < f.R :=\n  f.to_cont_diff_bump_of_inner.R_pos\n#align R_pos R_pos\n\n"}