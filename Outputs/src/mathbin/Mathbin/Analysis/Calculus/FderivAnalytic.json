{"iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [× ]→L[ ] » -/\n/-- If a function is analytic on a set `s`, so are its successive Fréchet derivative. -/\ntheorem analytic_on.iterated_fderiv [complete_space F] (h : analytic_on 𝕜 f s) (n : ℕ) :\n    analytic_on 𝕜 (iterated_fderiv 𝕜 n f) s := by\n  induction' n with n IH\n  · rw [iterated_fderiv_zero_eq_comp]\n    exact\n      ((continuous_multilinear_curry_fin0 𝕜 E F).symm : «expr →L[ ] » F 𝕜 («expr [× ]→L[ ] » E 0 𝕜 F)).comp_analytic_on\n        h\n  · rw [iterated_fderiv_succ_eq_comp_left]\n    apply\n      (continuous_multilinear_curry_left_equiv 𝕜 (fun i : fin (n + 1) => E)\n              F).to_continuous_linear_equiv.to_continuous_linear_map.comp_analytic_on\n    exact IH.fderiv\n#align analytic_on.iterated_fderiv analytic_on.iterated_fderiv\n\n",
 "iterated_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If a function is analytic on a set `s`, so are its successive derivatives. -/\ntheorem analytic_on.iterated_deriv [complete_space F] (h : analytic_on 𝕜 f s) (n : ℕ) :\n    analytic_on 𝕜 ((«expr ^[ ]» deriv n) f) s :=\n  by\n  induction' n with n IH\n  · exact h\n  · simpa only [function.iterate_succ', Function.comp_apply] using IH.deriv\n#align analytic_on.iterated_deriv analytic_on.iterated_deriv\n\n",
 "has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem has_fpower_series_at.has_strict_fderiv_at (h : has_fpower_series_at f p x) :\n    has_strict_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p 1)) x :=\n  by\n  refine' h.is_O_image_sub_norm_mul_norm_sub.trans_is_o (is_o.of_norm_right _)\n  refine' is_o_iff_exists_eq_mul.2 ⟨fun y => «expr‖ ‖» (y - (x, x)), _, eventually_eq.rfl⟩\n  refine' (continuous_id.sub continuous_const).norm.tendsto' _ _ _\n  rw [_root_.id, sub_self, norm_zero]\n#align has_fpower_series_at.has_strict_fderiv_at has_fpower_series_at.has_strict_fderiv_at\n\n",
 "has_strict_deriv_at":
 "protected theorem has_fpower_series_at.has_strict_deriv_at (h : has_fpower_series_at f p x) :\n    has_strict_deriv_at f (p 1 fun _ => 1) x :=\n  h.has_strict_fderiv_at.has_strict_deriv_at\n#align has_fpower_series_at.has_strict_deriv_at has_fpower_series_at.has_strict_deriv_at\n\n",
 "has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem has_fpower_series_on_ball.has_fderiv_at [complete_space F] (h : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : («expr‖ ‖₊» y : ennreal) < r) :\n    has_fderiv_at f (continuous_multilinear_curry_fin1 𝕜 E F (p.change_origin y 1)) (x + y) :=\n  (h.change_origin hy).has_fpower_series_at.has_fderiv_at\n#align has_fpower_series_on_ball.has_fderiv_at has_fpower_series_on_ball.has_fderiv_at\n\n",
 "has_deriv_at":
 "protected theorem has_fpower_series_at.has_deriv_at (h : has_fpower_series_at f p x) :\n    has_deriv_at f (p 1 fun _ => 1) x :=\n  h.has_strict_deriv_at.has_deriv_at\n#align has_fpower_series_at.has_deriv_at has_fpower_series_at.has_deriv_at\n\n",
 "fderiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem has_fpower_series_on_ball.fderiv_eq [complete_space F] (h : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : («expr‖ ‖₊» y : ennreal) < r) :\n    fderiv 𝕜 f (x + y) = continuous_multilinear_curry_fin1 𝕜 E F (p.change_origin y 1) :=\n  (h.has_fderiv_at hy).fderiv\n#align has_fpower_series_on_ball.fderiv_eq has_fpower_series_on_ball.fderiv_eq\n\n",
 "fderiv":
 "/-- If a function is analytic on a set `s`, so is its Fréchet derivative. -/\ntheorem analytic_on.fderiv [complete_space F] (h : analytic_on 𝕜 f s) : analytic_on 𝕜 (fderiv 𝕜 f) s :=\n  by\n  intro y hy\n  rcases h y hy with ⟨p, r, hp⟩\n  exact hp.fderiv.analytic_at\n#align analytic_on.fderiv analytic_on.fderiv\n\n",
 "differentiable_within_at":
 "theorem analytic_at.differentiable_within_at (h : analytic_at 𝕜 f x) : differentiable_within_at 𝕜 f s x :=\n  h.differentiable_at.differentiable_within_at\n#align analytic_at.differentiable_within_at analytic_at.differentiable_within_at\n\n",
 "differentiable_on":
 "theorem analytic_on.differentiable_on (h : analytic_on 𝕜 f s) : differentiable_on 𝕜 f s := fun y hy =>\n  (h y hy).differentiable_within_at\n#align analytic_on.differentiable_on analytic_on.differentiable_on\n\n",
 "differentiable_at":
 "theorem analytic_at.differentiable_at : analytic_at 𝕜 f x → differentiable_at 𝕜 f x\n  | ⟨p, hp⟩ => hp.differentiable_at\n#align analytic_at.differentiable_at analytic_at.differentiable_at\n\n",
 "deriv":
 "/-- If a function is analytic on a set `s`, so is its derivative. -/\ntheorem analytic_on.deriv [complete_space F] (h : analytic_on 𝕜 f s) : analytic_on 𝕜 (deriv f) s :=\n  (continuous_linear_map.apply 𝕜 F (1 : 𝕜)).comp_analytic_on h.fderiv\n#align analytic_on.deriv analytic_on.deriv\n\n",
 "cont_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/-- An analytic function is infinitely differentiable. -/\ntheorem analytic_on.cont_diff_on [complete_space F] (h : analytic_on 𝕜 f s) {n : «exprℕ∞»} : cont_diff_on 𝕜 n f s :=\n  by\n  let t := { x | analytic_at 𝕜 f x }\n  suffices : cont_diff_on 𝕜 n f t; exact this.mono h\n  have H : analytic_on 𝕜 f t := fun x hx => hx\n  have t_open : is_open t := is_open_analytic_at 𝕜 f\n  apply cont_diff_on_of_continuous_on_differentiable_on\n  · intro m hm\n    apply (H.iterated_fderiv m).continuous_on.congr\n    intro x hx\n    exact iterated_fderiv_within_of_is_open _ t_open hx\n  · intro m hm\n    apply (H.iterated_fderiv m).differentiable_on.congr\n    intro x hx\n    exact iterated_fderiv_within_of_is_open _ t_open hx\n#align analytic_on.cont_diff_on analytic_on.cont_diff_on\n\n"}