{"iterated_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr [Ã— ]â†’L[ ] Â» -/\n/-- If a function is analytic on a set `s`, so are its successive FrÃ©chet derivative. -/\ntheorem analytic_on.iterated_fderiv [complete_space F] (h : analytic_on ğ•œ f s) (n : â„•) :\n    analytic_on ğ•œ (iterated_fderiv ğ•œ n f) s := by\n  induction' n with n IH\n  Â· rw [iterated_fderiv_zero_eq_comp]\n    exact\n      ((continuous_multilinear_curry_fin0 ğ•œ E F).symm : Â«expr â†’L[ ] Â» F ğ•œ (Â«expr [Ã— ]â†’L[ ] Â» E 0 ğ•œ F)).comp_analytic_on\n        h\n  Â· rw [iterated_fderiv_succ_eq_comp_left]\n    apply\n      (continuous_multilinear_curry_left_equiv ğ•œ (fun i : fin (n + 1) => E)\n              F).to_continuous_linear_equiv.to_continuous_linear_map.comp_analytic_on\n    exact IH.fderiv\n#align analytic_on.iterated_fderiv analytic_on.iterated_fderiv\n\n",
 "iterated_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/-- If a function is analytic on a set `s`, so are its successive derivatives. -/\ntheorem analytic_on.iterated_deriv [complete_space F] (h : analytic_on ğ•œ f s) (n : â„•) :\n    analytic_on ğ•œ ((Â«expr ^[ ]Â» deriv n) f) s :=\n  by\n  induction' n with n IH\n  Â· exact h\n  Â· simpa only [function.iterate_succ', Function.comp_apply] using IH.deriv\n#align analytic_on.iterated_deriv analytic_on.iterated_deriv\n\n",
 "has_strict_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem has_fpower_series_at.has_strict_fderiv_at (h : has_fpower_series_at f p x) :\n    has_strict_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p 1)) x :=\n  by\n  refine' h.is_O_image_sub_norm_mul_norm_sub.trans_is_o (is_o.of_norm_right _)\n  refine' is_o_iff_exists_eq_mul.2 âŸ¨fun y => Â«exprâ€– â€–Â» (y - (x, x)), _, eventually_eq.rflâŸ©\n  refine' (continuous_id.sub continuous_const).norm.tendsto' _ _ _\n  rw [_root_.id, sub_self, norm_zero]\n#align has_fpower_series_at.has_strict_fderiv_at has_fpower_series_at.has_strict_fderiv_at\n\n",
 "has_strict_deriv_at":
 "protected theorem has_fpower_series_at.has_strict_deriv_at (h : has_fpower_series_at f p x) :\n    has_strict_deriv_at f (p 1 fun _ => 1) x :=\n  h.has_strict_fderiv_at.has_strict_deriv_at\n#align has_fpower_series_at.has_strict_deriv_at has_fpower_series_at.has_strict_deriv_at\n\n",
 "has_fderiv_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem has_fpower_series_on_ball.has_fderiv_at [complete_space F] (h : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : (Â«exprâ€– â€–â‚ŠÂ» y : ennreal) < r) :\n    has_fderiv_at f (continuous_multilinear_curry_fin1 ğ•œ E F (p.change_origin y 1)) (x + y) :=\n  (h.change_origin hy).has_fpower_series_at.has_fderiv_at\n#align has_fpower_series_on_ball.has_fderiv_at has_fpower_series_on_ball.has_fderiv_at\n\n",
 "has_deriv_at":
 "protected theorem has_fpower_series_at.has_deriv_at (h : has_fpower_series_at f p x) :\n    has_deriv_at f (p 1 fun _ => 1) x :=\n  h.has_strict_deriv_at.has_deriv_at\n#align has_fpower_series_at.has_deriv_at has_fpower_series_at.has_deriv_at\n\n",
 "fderiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem has_fpower_series_on_ball.fderiv_eq [complete_space F] (h : has_fpower_series_on_ball f p x r) {y : E}\n    (hy : (Â«exprâ€– â€–â‚ŠÂ» y : ennreal) < r) :\n    fderiv ğ•œ f (x + y) = continuous_multilinear_curry_fin1 ğ•œ E F (p.change_origin y 1) :=\n  (h.has_fderiv_at hy).fderiv\n#align has_fpower_series_on_ball.fderiv_eq has_fpower_series_on_ball.fderiv_eq\n\n",
 "fderiv":
 "/-- If a function is analytic on a set `s`, so is its FrÃ©chet derivative. -/\ntheorem analytic_on.fderiv [complete_space F] (h : analytic_on ğ•œ f s) : analytic_on ğ•œ (fderiv ğ•œ f) s :=\n  by\n  intro y hy\n  rcases h y hy with âŸ¨p, r, hpâŸ©\n  exact hp.fderiv.analytic_at\n#align analytic_on.fderiv analytic_on.fderiv\n\n",
 "differentiable_within_at":
 "theorem analytic_at.differentiable_within_at (h : analytic_at ğ•œ f x) : differentiable_within_at ğ•œ f s x :=\n  h.differentiable_at.differentiable_within_at\n#align analytic_at.differentiable_within_at analytic_at.differentiable_within_at\n\n",
 "differentiable_on":
 "theorem analytic_on.differentiable_on (h : analytic_on ğ•œ f s) : differentiable_on ğ•œ f s := fun y hy =>\n  (h y hy).differentiable_within_at\n#align analytic_on.differentiable_on analytic_on.differentiable_on\n\n",
 "differentiable_at":
 "theorem analytic_at.differentiable_at : analytic_at ğ•œ f x â†’ differentiable_at ğ•œ f x\n  | âŸ¨p, hpâŸ© => hp.differentiable_at\n#align analytic_at.differentiable_at analytic_at.differentiable_at\n\n",
 "deriv":
 "/-- If a function is analytic on a set `s`, so is its derivative. -/\ntheorem analytic_on.deriv [complete_space F] (h : analytic_on ğ•œ f s) : analytic_on ğ•œ (deriv f) s :=\n  (continuous_linear_map.apply ğ•œ F (1 : ğ•œ)).comp_analytic_on h.fderiv\n#align analytic_on.deriv analytic_on.deriv\n\n",
 "cont_diff_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/-- An analytic function is infinitely differentiable. -/\ntheorem analytic_on.cont_diff_on [complete_space F] (h : analytic_on ğ•œ f s) {n : Â«exprâ„•âˆÂ»} : cont_diff_on ğ•œ n f s :=\n  by\n  let t := { x | analytic_at ğ•œ f x }\n  suffices : cont_diff_on ğ•œ n f t; exact this.mono h\n  have H : analytic_on ğ•œ f t := fun x hx => hx\n  have t_open : is_open t := is_open_analytic_at ğ•œ f\n  apply cont_diff_on_of_continuous_on_differentiable_on\n  Â· intro m hm\n    apply (H.iterated_fderiv m).continuous_on.congr\n    intro x hx\n    exact iterated_fderiv_within_of_is_open _ t_open hx\n  Â· intro m hm\n    apply (H.iterated_fderiv m).differentiable_on.congr\n    intro x hx\n    exact iterated_fderiv_within_of_is_open _ t_open hx\n#align analytic_on.cont_diff_on analytic_on.cont_diff_on\n\n"}