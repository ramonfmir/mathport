{"to_local_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem to_local_left_inverse {g : 𝕜 → 𝕜}\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (g (f x) = x)) :\n    has_strict_deriv_at g f'⁻¹ (f a) :=\n  (hf.has_strict_fderiv_at_equiv hf').to_local_left_inverse hg\n#align to_local_left_inverse to_local_left_inverse\n\n",
 "to_local_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- Given a `cont_diff` function over `𝕂` (which is `ℝ` or `ℂ`) with an invertible derivative\nat `a`, the inverse function (produced by `cont_diff.to_local_homeomorph`) is\nalso `cont_diff`. -/\ntheorem to_local_inverse {n : «exprℕ∞»} (hf : cont_diff_at 𝕂 n f a)\n    (hf' : has_fderiv_at f (f' : «expr →L[ ] » E' 𝕂 F') a) (hn : 1 ≤ n) :\n    cont_diff_at 𝕂 n (hf.local_inverse hf' hn) (f a) :=\n  by\n  have := hf.local_inverse_apply_image hf' hn\n  apply (hf.to_local_homeomorph f hf' hn).cont_diff_at_symm (image_mem_to_local_homeomorph_target hf hf' hn)\n  · convert hf'\n  · convert hf\n#align to_local_inverse to_local_inverse\n\n",
 "to_local_homeomorph_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem to_local_homeomorph_target (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) (hs : IsOpen s) :\n    (hf.to_local_homeomorph f s hc hs).target = «expr '' » f s :=\n  rfl\n#align to_local_homeomorph_target to_local_homeomorph_target\n\n",
 "to_local_homeomorph_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n@[simp]\ntheorem to_local_homeomorph_source (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) (hs : IsOpen s) : (hf.to_local_homeomorph f s hc hs).source = s :=\n  rfl\n#align to_local_homeomorph_source to_local_homeomorph_source\n\n",
 "to_local_homeomorph_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n@[simp]\ntheorem to_local_homeomorph_coe {n : «exprℕ∞»} (hf : cont_diff_at 𝕂 n f a)\n    (hf' : has_fderiv_at f (f' : «expr →L[ ] » E' 𝕂 F') a) (hn : 1 ≤ n) :\n    (hf.to_local_homeomorph f hf' hn : E' → F') = f :=\n  rfl\n#align to_local_homeomorph_coe to_local_homeomorph_coe\n\n",
 "to_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/-- The inverse function is approximated linearly on `f '' s` by `f'.symm`. -/\ntheorem to_inv (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c) (hc : subsingleton E ∨ c < (exprN)⁻¹) :\n    approximates_linear_on (hf.to_local_equiv hc).symm (f'.symm : «expr →L[ ] » F 𝕜 E) («expr '' » f s)\n      (exprN * ((exprN)⁻¹ - c)⁻¹ * c) :=\n  by\n  intro x hx y hy\n  set A := hf.to_local_equiv hc with hA\n  have Af : ∀ z, A z = f z := fun z => rfl\n  rcases(mem_image _ _ _).1 hx with ⟨x', x's, rfl⟩\n  rcases(mem_image _ _ _).1 hy with ⟨y', y's, rfl⟩\n  rw [← Af x', ← Af y', A.left_inv x's, A.left_inv y's]\n  calc\n    «expr‖ ‖» (x' - y' - f'.symm (A x' - A y')) ≤ exprN * «expr‖ ‖» (f' (x' - y' - f'.symm (A x' - A y'))) :=\n      (f' : «expr →L[ ] » E 𝕜 F).bound_of_antilipschitz f'.antilipschitz _\n    _ = exprN * «expr‖ ‖» (A y' - A x' - f' (y' - x')) := by\n      congr 2\n      simp only [ContinuousLinearEquiv.apply_symm_apply, ContinuousLinearEquiv.map_sub]\n      abel\n    _ ≤ exprN * (c * «expr‖ ‖» (y' - x')) := (mul_le_mul_of_nonneg_left (hf _ y's _ x's) (NNReal.coe_nonneg _))\n    _ ≤ exprN * (c * ((((exprN)⁻¹ - c)⁻¹ : nnreal) * «expr‖ ‖» (A y' - A x'))) :=\n      by\n      apply_rules [mul_le_mul_of_nonneg_left, NNReal.coe_nonneg]\n      rw [← dist_eq_norm, ← dist_eq_norm]\n      exact (hf.antilipschitz hc).le_mul_dist ⟨y', y's⟩ ⟨x', x's⟩\n    _ = (exprN * ((exprN)⁻¹ - c)⁻¹ * c : nnreal) * «expr‖ ‖» (A x' - A y') :=\n      by\n      simp only [norm_sub_rev, Nonneg.coe_mul]\n      ring\n    \n#align to_inv to_inv\n\n",
 "surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem surjective [CompleteSpace E] (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) univ c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) : surjective f :=\n  by\n  cases' hc with hE hc\n  · haveI : subsingleton F := (Equiv.subsingleton_congr f'.to_linear_equiv.to_equiv).1 hE\n    exact surjective_to_subsingleton _\n  · apply forall_of_forall_mem_closed_ball (fun y : F => ∃ a, f a = y) (f 0) _\n    have hc' : (0 : exprℝ) < (exprN)⁻¹ - c := by\n      rw [sub_pos]\n      exact hc\n    let p : exprℝ → Prop := fun R => closed_ball (f 0) R ⊆ Set.range f\n    have hp :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (p (((exprN)⁻¹ - c) * r)) :=\n      by\n      have hr :\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n          (0 ≤ r) :=\n        eventually_ge_at_top 0\n      refine' hr.mono fun r hr => subset.trans _ (image_subset_range f (closed_ball 0 r))\n      refine' hf.surj_on_closed_ball_of_nonlinear_right_inverse f'.to_nonlinear_right_inverse hr _\n      exact subset_univ _\n    refine' ((tendsto_id.const_mul_at_top hc').frequently hp.frequently).mono _\n    exact fun R h y hy => h hy\n#align surjective surjective\n\n",
 "surj_on_closed_ball_of_nonlinear_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a function is linearly approximated by a continuous linear map with a (possibly nonlinear)\nright inverse, then it is locally onto: a ball of an explicit radius is included in the image\nof the map. -/\ntheorem surj_on_closed_ball_of_nonlinear_right_inverse (hf : approximates_linear_on f f' s c)\n    (f'symm : f'.nonlinear_right_inverse) {ε : exprℝ} {b : E} (ε0 : 0 ≤ ε) (hε : closedBall b ε ⊆ s) :\n    SurjOn f (closedBall b ε) (closedBall (f b) (((f'symm.nnnorm : exprℝ)⁻¹ - c) * ε)) :=\n  by\n  intro y hy\n  cases' le_or_lt (f'symm.nnnorm : exprℝ)⁻¹ c with hc hc\n  · refine' ⟨b, by simp [ε0], _⟩\n    have : dist y (f b) ≤ 0 := (mem_closed_ball.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) ε0)\n    simp only [dist_le_zero] at this\n    rw [this]\n  have If' : (0 : exprℝ) < f'symm.nnnorm := by\n    rw [← inv_pos]\n    exact (NNReal.coe_nonneg _).trans_lt hc\n  have Icf' : (c : exprℝ) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff If'] at hc\n  have Jf' : (f'symm.nnnorm : exprℝ) ≠ 0 := ne_of_gt If'\n  have Jcf' : (1 : exprℝ) - c * f'symm.nnnorm ≠ 0 := by\n    apply ne_of_gt\n    linarith\n  /- We have to show that `y` can be written as `f x` for some `x ∈ closed_ball b ε`.\n    The idea of the proof is to apply the Banach contraction principle to the map\n    `g : x ↦ x + f'symm (y - f x)`, as a fixed point of this map satisfies `f x = y`.\n    When `f'symm` is a genuine linear inverse, `g` is a contracting map. In our case, since `f'symm`\n    is nonlinear, this map is not contracting (it is not even continuous), but still the proof of\n    the contraction theorem holds: `uₙ = gⁿ b` is a Cauchy sequence, converging exponentially fast\n    to the desired point `x`. Instead of appealing to general results, we check this by hand.\n  \n    The main point is that `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` stays in the ball on which one has a\n    control. Therefore, the bound can be checked at the next step, and so on inductively.\n    -/\n  set g := fun x => x + f'symm (y - f x) with hg\n  set u := fun n : ℕ => («expr ^[ ]» g n) b with hu\n  have usucc : ∀ n, u (n + 1) = g (u n) := by simp [hu, ← iterate_succ_apply' g _ b]\n  -- First bound: if `f z` is close to `y`, then `g z` is close to `z` (i.e., almost a fixed point).\n  have A : ∀ z, dist (g z) z ≤ f'symm.nnnorm * dist (f z) y :=\n    by\n    intro z\n    rw [dist_eq_norm, hg, add_sub_cancel', dist_eq_norm']\n    exact f'symm.bound _\n  -- Second bound: if `z` and `g z` are in the set with good control, then `f (g z)` becomes closer\n  -- to `y` than `f z` was (this uses the linear approximation property, and is the reason for the\n  -- choice of the formula for `g`).\n  have B : ∀ z ∈ closed_ball b ε, g z ∈ closed_ball b ε → dist (f (g z)) y ≤ c * f'symm.nnnorm * dist (f z) y :=\n    by\n    intro z hz hgz\n    set v := f'symm (y - f z) with hv\n    calc\n      dist (f (g z)) y = «expr‖ ‖» (f (z + v) - y) := by rw [dist_eq_norm]\n      _ = «expr‖ ‖» (f (z + v) - f z - f' v + f' v - (y - f z)) :=\n        by\n        congr 1\n        abel\n      _ = «expr‖ ‖» (f (z + v) - f z - f' (z + v - z)) := by\n        simp only [continuous_linear_map.nonlinear_right_inverse.right_inv, add_sub_cancel', sub_add_cancel]\n      _ ≤ c * «expr‖ ‖» (z + v - z) := (hf _ (hε hgz) _ (hε hz))\n      _ ≤ c * (f'symm.nnnorm * dist (f z) y) :=\n        by\n        apply mul_le_mul_of_nonneg_left _ (NNReal.coe_nonneg c)\n        simpa [hv, dist_eq_norm'] using f'symm.bound (y - f z)\n      _ = c * f'symm.nnnorm * dist (f z) y := by ring\n      \n  -- Third bound: a complicated bound on `dist w b` (that will show up in the induction) is enough\n  -- to check that `w` is in the ball on which one has controls. Will be used to check that `u n`\n  -- belongs to this ball for all `n`.\n  have C :\n    ∀ (n : ℕ) (w : E),\n      dist w b ≤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) * dist (f b) y →\n        w ∈ closed_ball b ε :=\n    by\n    intro n w hw\n    apply hw.trans\n    rw [div_mul_eq_mul_div, div_le_iff]\n    swap\n    · linarith\n    calc\n      (f'symm.nnnorm : exprℝ) * (1 - (c * f'symm.nnnorm) ^ n) * dist (f b) y =\n          f'symm.nnnorm * dist (f b) y * (1 - (c * f'symm.nnnorm) ^ n) :=\n        by ring\n      _ ≤ f'symm.nnnorm * dist (f b) y * 1 :=\n        by\n        apply mul_le_mul_of_nonneg_left _ (mul_nonneg (NNReal.coe_nonneg _) dist_nonneg)\n        rw [sub_le_self_iff]\n        exact pow_nonneg (mul_nonneg (NNReal.coe_nonneg _) (NNReal.coe_nonneg _)) _\n      _ ≤ f'symm.nnnorm * (((f'symm.nnnorm : exprℝ)⁻¹ - c) * ε) :=\n        by\n        rw [mul_one]\n        exact mul_le_mul_of_nonneg_left (mem_closed_ball'.1 hy) (NNReal.coe_nonneg _)\n      _ = ε * (1 - c * f'symm.nnnorm) := by\n        field_simp\n        ring\n      \n  /- Main inductive control: `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` remains in the ball on which we\n    have estimates. -/\n  have D :\n    ∀ n : ℕ,\n      dist (f (u n)) y ≤ (c * f'symm.nnnorm) ^ n * dist (f b) y ∧\n        dist (u n) b ≤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n    by\n    intro n\n    induction' n with n IH\n    · simp [hu, le_refl]\n    rw [usucc]\n    have Ign :\n      dist (g (u n)) b ≤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n.succ) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n      calc\n        dist (g (u n)) b ≤ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _\n        _ ≤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := (add_le_add (A _) le_rfl)\n        _ ≤\n            f'symm.nnnorm * ((c * f'symm.nnnorm) ^ n * dist (f b) y) +\n              f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n          (add_le_add (mul_le_mul_of_nonneg_left IH.1 (NNReal.coe_nonneg _)) IH.2)\n        _ = f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n.succ) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n          by\n          field_simp [Jcf']\n          ring\n        \n    refine' ⟨_, Ign⟩\n    calc\n      dist (f (g (u n))) y ≤ c * f'symm.nnnorm * dist (f (u n)) y := B _ (C n _ IH.2) (C n.succ _ Ign)\n      _ ≤ c * f'symm.nnnorm * ((c * f'symm.nnnorm) ^ n * dist (f b) y) :=\n        (mul_le_mul_of_nonneg_left IH.1 (mul_nonneg (NNReal.coe_nonneg _) (NNReal.coe_nonneg _)))\n      _ = (c * f'symm.nnnorm) ^ n.succ * dist (f b) y := by ring\n      \n  -- Deduce from the inductive bound that `uₙ` is a Cauchy sequence, therefore converging.\n  have : CauchySeq u :=\n    haveI : ∀ n : ℕ, dist (u n) (u (n + 1)) ≤ f'symm.nnnorm * dist (f b) y * (c * f'symm.nnnorm) ^ n :=\n      by\n      intro n\n      calc\n        dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]\n        _ ≤ f'symm.nnnorm * dist (f (u n)) y := (A _)\n        _ ≤ f'symm.nnnorm * ((c * f'symm.nnnorm) ^ n * dist (f b) y) :=\n          (mul_le_mul_of_nonneg_left (D n).1 (NNReal.coe_nonneg _))\n        _ = f'symm.nnnorm * dist (f b) y * (c * f'symm.nnnorm) ^ n := by ring\n        \n    cauchySeq_of_le_geometric _ _ Icf' this\n  obtain ⟨x, hx⟩ : ∃ x, tendsto u at_top ((nhds) x) := cauchySeq_tendsto_of_complete this\n  -- As all the `uₙ` belong to the ball `closed_ball b ε`, so does their limit `x`.\n  have xmem : x ∈ closed_ball b ε := is_closed_ball.mem_of_tendsto hx (eventually_of_forall fun n => C n _ (D n).2)\n  refine' ⟨x, xmem, _⟩\n  -- It remains to check that `f x = y`. This follows from continuity of `f` on `closed_ball b ε`\n  -- and from the fact that `f uₙ` is converging to `y` by construction.\n  have hx' : tendsto u at_top (nhds_within (closed_ball b ε) x) :=\n    by\n    simp only [nhdsWithin, tendsto_inf, hx, true_and_iff, ge_iff_le, tendsto_principal]\n    exact eventually_of_forall fun n => C n _ (D n).2\n  have T1 : tendsto (fun n => f (u n)) at_top ((nhds) (f x)) := (hf.continuous_on.mono hε x xmem).tendsto.comp hx'\n  have T2 : tendsto (fun n => f (u n)) at_top ((nhds) y) :=\n    by\n    rw [tendsto_iff_dist_tendsto_zero]\n    refine' squeeze_zero (fun n => dist_nonneg) (fun n => (D n).1) _\n    simpa using\n      (tendsto_pow_atTop_nhds_0_of_lt_1 (mul_nonneg (NNReal.coe_nonneg _) (NNReal.coe_nonneg _)) Icf').mul\n        tendsto_const_nhds\n  exact tendsto_nhds_unique T1 T2\n#align surj_on_closed_ball_of_nonlinear_right_inverse surj_on_closed_ball_of_nonlinear_right_inverse\n\n",
 "open_map_of_strict_fderiv_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem open_map_of_strict_fderiv_equiv [CompleteSpace E] {f : E → F} {f' : E → «expr ≃L[ ] » E 𝕜 F}\n    (hf : ∀ x, has_strict_fderiv_at f (f' x : «expr →L[ ] » E 𝕜 F) x) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => (hf x).map_nhds_eq_of_equiv.ge\n#align open_map_of_strict_fderiv_equiv open_map_of_strict_fderiv_equiv\n\n",
 "open_map_of_strict_deriv":
 "/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem open_map_of_strict_deriv [CompleteSpace 𝕜] {f f' : 𝕜 → 𝕜} (hf : ∀ x, has_strict_deriv_at f (f' x) x)\n    (h0 : ∀ x, f' x ≠ 0) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => ((hf x).map_nhds_eq (h0 x)).ge\n#align open_map_of_strict_deriv open_map_of_strict_deriv\n\n",
 "open_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem open_image (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) (hs : IsOpen s)\n    (hc : subsingleton F ∨ c < f'symm.nnnorm⁻¹) : IsOpen («expr '' » f s) :=\n  by\n  cases' hc with hE hc;\n  · skip\n    apply isOpen_discrete\n  simp only [isOpen_iff_mem_nhds, nhds_basis_closed_ball.mem_iff, ball_image_iff] at hs⊢\n  intro x hx\n  rcases hs x hx with ⟨ε, ε0, hε⟩\n  refine' ⟨(f'symm.nnnorm⁻¹ - c) * ε, mul_pos (sub_pos.2 hc) ε0, _⟩\n  exact (hf.surj_on_closed_ball_of_nonlinear_right_inverse f'symm (le_of_lt ε0) hε).mono hε (subset.refl _)\n#align open_image open_image\n\n",
 "mono_set":
 "theorem mono_set (hst : s ⊆ t) (hf : approximates_linear_on f f' t c) : approximates_linear_on f f' s c :=\n  fun x hx y hy => hf x (hst hx) y (hst hy)\n#align mono_set mono_set\n\n",
 "mono_num":
 "theorem mono_num (hc : c ≤ c') (hf : approximates_linear_on f f' s c) : approximates_linear_on f f' s c' :=\n  fun x hx y hy => le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc <| norm_nonneg _)\n#align mono_num mono_num\n\n",
 "mem_to_local_homeomorph_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem mem_to_local_homeomorph_source {n : «exprℕ∞»} (hf : cont_diff_at 𝕂 n f a)\n    (hf' : has_fderiv_at f (f' : «expr →L[ ] » E' 𝕂 F') a) (hn : 1 ≤ n) :\n    a ∈ (hf.to_local_homeomorph f hf' hn).source :=\n  (hf.has_strict_fderiv_at' hf' hn).mem_to_local_homeomorph_source\n#align mem_to_local_homeomorph_source mem_to_local_homeomorph_source\n\n",
 "map_nhds_eq_of_surj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq_of_surj [CompleteSpace E] [CompleteSpace F] {f : E → F} {f' : «expr →L[ ] » E 𝕜 F} {a : E}\n    (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) (h : LinearMap.range f' = «expr⊤») :\n    map f ((nhds) a) = (nhds) (f a) :=\n  by\n  let f'symm := f'.nonlinear_right_inverse_of_surjective h\n  set c : nnreal := f'symm.nnnorm⁻¹ / 2 with hc\n  have f'symm_pos : 0 < f'symm.nnnorm := f'.nonlinear_right_inverse_of_surjective_nnnorm_pos h\n  have cpos : 0 < c := by simp [hc, half_pos, inv_pos, f'symm_pos]\n  obtain ⟨s, s_nhds, hs⟩ : ∃ s ∈ (nhds) a, approximates_linear_on f f' s c :=\n    hf.approximates_deriv_on_nhds (or.inr cpos)\n  apply hs.map_nhds_eq f'symm s_nhds (or.inr (NNReal.half_lt_self _))\n  simp [ne_of_gt f'symm_pos]\n#align map_nhds_eq_of_surj map_nhds_eq_of_surj\n\n",
 "map_nhds_eq_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq_of_equiv (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    map f ((nhds) a) = (nhds) (f a) :=\n  (hf.to_local_homeomorph f).map_nhds_eq hf.mem_to_local_homeomorph_source\n#align map_nhds_eq_of_equiv map_nhds_eq_of_equiv\n\n",
 "map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq : map f ((nhds) a) = (nhds) (f a) :=\n  (hf.has_strict_fderiv_at_equiv hf').map_nhds_eq_of_equiv\n#align map_nhds_eq map_nhds_eq\n\n",
 "local_inverse_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem local_inverse_unique (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) {g : F → E}\n    (hg :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n        (g (f x) = x)) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (f a)) (g y = local_inverse f f' a hf y) :=\n  eventuallyEq_of_left_inv_of_right_inv hg hf.eventually_right_inverse <|\n    (hf.to_local_homeomorph f).tendsto_symm hf.mem_to_local_homeomorph_source\n#align local_inverse_unique local_inverse_unique\n\n",
 "local_inverse_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem local_inverse_tendsto (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    Tendsto (hf.local_inverse f f' a) (nhds <| f a) ((nhds) a) :=\n  (hf.to_local_homeomorph f).tendsto_symm hf.mem_to_local_homeomorph_source\n#align local_inverse_tendsto local_inverse_tendsto\n\n",
 "local_inverse_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem local_inverse_def (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    hf.local_inverse f _ _ = (hf.to_local_homeomorph f).symm :=\n  rfl\n#align local_inverse_def local_inverse_def\n\n",
 "local_inverse_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem local_inverse_continuous_at (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    ContinuousAt (hf.local_inverse f f' a) (f a) :=\n  (hf.to_local_homeomorph f).continuous_at_symm hf.image_mem_to_local_homeomorph_target\n#align local_inverse_continuous_at local_inverse_continuous_at\n\n",
 "local_inverse_apply_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem local_inverse_apply_image {n : «exprℕ∞»} (hf : cont_diff_at 𝕂 n f a)\n    (hf' : has_fderiv_at f (f' : «expr →L[ ] » E' 𝕂 F') a) (hn : 1 ≤ n) : hf.local_inverse hf' hn (f a) = a :=\n  (hf.has_strict_fderiv_at' hf' hn).local_inverse_apply_image\n#align local_inverse_apply_image local_inverse_apply_image\n\n",
 "lipschitz_sub":
 "theorem lipschitz_sub (hf : approximates_linear_on f f' s c) : LipschitzWith c fun x : s => f x - f' x :=\n  by\n  refine' LipschitzWith.of_dist_le_mul fun x y => _\n  rw [dist_eq_norm, Subtype.dist_eq, dist_eq_norm]\n  convert hf x x.2 y y.2 using 2\n  rw [f'.map_sub]; abel\n#align lipschitz_sub lipschitz_sub\n\n",
 "lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\nprotected theorem lipschitz (hf : approximates_linear_on f f' s c) : LipschitzWith («expr‖ ‖₊» f' + c) (s.restrict f) :=\n  by simpa only [restrict_apply, add_sub_cancel'_right] using (f'.lipschitz.restrict s).add hf.lipschitz_sub\n#align lipschitz lipschitz\n\n",
 "inverse_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The inverse function is continuous on `f '' s`. Use properties of `local_homeomorph` instead. -/\ntheorem inverse_continuous_on (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) : ContinuousOn (hf.to_local_equiv hc).symm («expr '' » f s) :=\n  by\n  apply continuousOn_iff_continuous_restrict.2\n  refine' ((hf.antilipschitz hc).to_right_inv_on' _ (hf.to_local_equiv hc).right_inv').continuous\n  exact fun x hx => (hf.to_local_equiv hc).map_target hx\n#align inverse_continuous_on inverse_continuous_on\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem injective (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) : injective (s.restrict f) :=\n  (hf.antilipschitz hc).injective\n#align injective injective\n\n",
 "inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem inj_on (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) : InjOn f s :=\n  injOn_iff_injective.2 <| hf.injective hc\n#align inj_on inj_on\n\n",
 "image_mem_to_local_homeomorph_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ∞» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem image_mem_to_local_homeomorph_target {n : «exprℕ∞»} (hf : cont_diff_at 𝕂 n f a)\n    (hf' : has_fderiv_at f (f' : «expr →L[ ] » E' 𝕂 F') a) (hn : 1 ≤ n) :\n    f a ∈ (hf.to_local_homeomorph f hf' hn).target :=\n  (hf.has_strict_fderiv_at' hf' hn).image_mem_to_local_homeomorph_target\n#align image_mem_to_local_homeomorph_target image_mem_to_local_homeomorph_target\n\n",
 "image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem image_mem_nhds (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) {x : E}\n    (hs : s ∈ (nhds) x) (hc : subsingleton F ∨ c < f'symm.nnnorm⁻¹) : «expr '' » f s ∈ (nhds) (f x) :=\n  by\n  obtain ⟨t, hts, ht, xt⟩ : ∃ (t : _)(_ : t ⊆ s), IsOpen t ∧ x ∈ t := _root_.mem_nhds_iff.1 hs\n  have := IsOpen.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)\n  exact mem_of_superset this (image_subset _ hts)\n#align image_mem_nhds image_mem_nhds\n\n",
 "exists_homeomorph_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₜ » -/\n/-- In a real vector space, a function `f` that approximates a linear equivalence on a subset `s`\ncan be extended to a homeomorphism of the whole space. -/\ntheorem exists_homeomorph_extension {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E] {F : Type _}\n    [NormedAddCommGroup F] [NormedSpace (exprℝ) F] [FiniteDimensional (exprℝ) F] {s : Set E} {f : E → F}\n    {f' : «expr ≃L[ ] » E (exprℝ) F} {c : nnreal} (hf : approximates_linear_on f (f' : «expr →L[ ] » E (exprℝ) F) s c)\n    (hc : subsingleton E ∨ lipschitz_extension_constant F * c < («expr‖ ‖₊» (f'.symm : «expr →L[ ] » F (exprℝ) E))⁻¹) :\n    ∃ g : «expr ≃ₜ » E F, EqOn f g s :=\n  by\n  -- the difference `f - f'` is Lipschitz on `s`. It can be extended to a Lipschitz function `u`\n  -- on the whole space, with a slightly worse Lipschitz constant. Then `f' + u` will be the\n  -- desired homeomorphism.\n  obtain ⟨u, hu, uf⟩ : ∃ u : E → F, LipschitzWith (lipschitz_extension_constant F * c) u ∧ eq_on (f - f') u s :=\n    hf.lipschitz_on_with.extend_finite_dimension\n  let g : E → F := fun x => f' x + u x\n  have fg : eq_on f g s := fun x hx => by simp_rw [g, ← uf hx, Pi.sub_apply, add_sub_cancel'_right]\n  have hg : approximates_linear_on g (f' : «expr →L[ ] » E (exprℝ) F) univ (lipschitz_extension_constant F * c) :=\n    by\n    apply lipschitz_on_with.approximates_linear_on\n    rw [lipschitz_on_univ]\n    convert hu\n    ext x\n    simp only [add_sub_cancel', ContinuousLinearEquiv.coe_coe, Pi.sub_apply]\n  haveI : FiniteDimensional (exprℝ) E := f'.symm.to_linear_equiv.finite_dimensional\n  exact ⟨hg.to_homeomorph g hc, fg⟩\n#align exists_homeomorph_extension exists_homeomorph_extension\n\n",
 "eventually_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_right_inverse (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\"\n      ((nhds) (f a)) (f (hf.local_inverse f f' a y) = y) :=\n  (hf.to_local_homeomorph f).eventually_right_inverse' hf.mem_to_local_homeomorph_source\n#align eventually_right_inverse eventually_right_inverse\n\n",
 "eventually_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_left_inverse (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) a)\n      (hf.local_inverse f f' a (f x) = x) :=\n  (hf.to_local_homeomorph f).eventually_left_inverse hf.mem_to_local_homeomorph_source\n#align eventually_left_inverse eventually_left_inverse\n\n",
 "closed_ball_subset_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\ntheorem closed_ball_subset_target (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) (hs : IsOpen s) {b : E} (ε0 : 0 ≤ ε) (hε : closedBall b ε ⊆ s) :\n    closedBall (f b) (((exprN)⁻¹ - c) * ε) ⊆ (hf.to_local_homeomorph f s hc hs).target :=\n  (hf.surj_on_closed_ball_of_nonlinear_right_inverse f'.to_nonlinear_right_inverse ε0 hε).mono hε (Subset.refl _)\n#align closed_ball_subset_target closed_ball_subset_target\n\n",
 "approximates_linear_on_iff_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem approximates_linear_on_iff_lipschitz_on_with {f : E → F} {f' : «expr →L[ ] » E 𝕜 F} {s : Set E} {c : nnreal} :\n    approximates_linear_on f f' s c ↔ LipschitzOnWith c (f - f') s :=\n  by\n  have : ∀ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y :=\n    by\n    intro x y\n    simp only [map_sub, Pi.sub_apply]\n    abel\n  simp only [this, lipschitzOnWith_iff_norm_sub_le, approximates_linear_on]\n#align approximates_linear_on_iff_lipschitz_on_with approximates_linear_on_iff_lipschitz_on_with\n\n",
 "approximates_linear_on_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Heather Macbeth, Sébastien Gouëzel\n-/\n@[simp]\ntheorem approximates_linear_on_empty (f : E → F) (f' : «expr →L[ ] » E 𝕜 F) (c : nnreal) :\n    approximates_linear_on f f' ∅ c := by simp [approximates_linear_on]\n#align approximates_linear_on_empty approximates_linear_on_empty\n\n",
 "approximates_deriv_on_open_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\ntheorem approximates_deriv_on_open_nhds (hf : has_strict_fderiv_at f (f' : «expr →L[ ] » E 𝕜 F) a) :\n    ∃ (s : Set E)(hs : a ∈ s ∧ IsOpen s),\n      approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s ((«expr‖ ‖₊» (f'.symm : «expr →L[ ] » F 𝕜 E))⁻¹ / 2) :=\n  by\n  refine' ((nhds_basis_opens a).exists_iff _).1 _\n  exact fun s t => approximates_linear_on.mono_set\n  exact hf.approximates_deriv_on_nhds <| f'.subsingleton_or_nnnorm_symm_pos.imp id fun hf' => half_pos <| inv_pos.2 hf'\n#align approximates_deriv_on_open_nhds approximates_deriv_on_open_nhds\n\n",
 "approximates_deriv_on_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem approximates_deriv_on_nhds {f : E → F} {f' : «expr →L[ ] » E 𝕜 F} {a : E} (hf : has_strict_fderiv_at f f' a)\n    {c : nnreal} (hc : subsingleton E ∨ 0 < c) : ∃ s ∈ (nhds) a, approximates_linear_on f f' s c :=\n  by\n  cases' hc with hE hc\n  · refine' ⟨univ, IsOpen.mem_nhds isOpen_univ trivial, fun x hx y hy => _⟩\n    simp [@subsingleton.elim E hE x y]\n  have := hf.def hc\n  rw [nhds_prod_eq, Filter.Eventually, mem_prod_same_iff] at this\n  rcases this with ⟨s, has, hs⟩\n  exact ⟨s, has, fun x hx y hy => hs (mk_mem_prod hx hy)⟩\n#align approximates_deriv_on_nhds approximates_deriv_on_nhds\n\n",
 "antilipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem antilipschitz (hf : approximates_linear_on f (f' : «expr →L[ ] » E 𝕜 F) s c)\n    (hc : subsingleton E ∨ c < (exprN)⁻¹) : AntilipschitzWith ((exprN)⁻¹ - c)⁻¹ (s.restrict f) :=\n  by\n  cases' hc with hE hc\n  · haveI : subsingleton s := ⟨fun x y => Subtype.eq <| @subsingleton.elim _ hE _ _⟩\n    exact AntilipschitzWith.of_subsingleton\n  convert(f'.antilipschitz.restrict s).add_lipschitz_with hf.lipschitz_sub hc\n  simp [restrict]\n#align antilipschitz antilipschitz\n\n",
 "ContinuousOn":
 "#print ContinuousOn /-\nprotected theorem ContinuousOn (hf : approximates_linear_on f f' s c) : ContinuousOn f s :=\n  continuousOn_iff_continuous_restrict.2 hf.continuous\n#align continuous_on ContinuousOn\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous (hf : approximates_linear_on f f' s c) : Continuous (s.restrict f) :=\n  hf.lipschitz.continuous\n#align continuous Continuous\n-/\n\n"}