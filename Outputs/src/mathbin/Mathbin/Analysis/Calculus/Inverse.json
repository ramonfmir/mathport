{"to_local_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem to_local_left_inverse {g : ğ•œ â†’ ğ•œ}\n    (hg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (g (f x) = x)) :\n    has_strict_deriv_at g f'â»Â¹ (f a) :=\n  (hf.has_strict_fderiv_at_equiv hf').to_local_left_inverse hg\n#align to_local_left_inverse to_local_left_inverse\n\n",
 "to_local_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- Given a `cont_diff` function over `ğ•‚` (which is `â„` or `â„‚`) with an invertible derivative\nat `a`, the inverse function (produced by `cont_diff.to_local_homeomorph`) is\nalso `cont_diff`. -/\ntheorem to_local_inverse {n : Â«exprâ„•âˆÂ»} (hf : cont_diff_at ğ•‚ n f a)\n    (hf' : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E' ğ•‚ F') a) (hn : 1 â‰¤ n) :\n    cont_diff_at ğ•‚ n (hf.local_inverse hf' hn) (f a) :=\n  by\n  have := hf.local_inverse_apply_image hf' hn\n  apply (hf.to_local_homeomorph f hf' hn).cont_diff_at_symm (image_mem_to_local_homeomorph_target hf hf' hn)\n  Â· convert hf'\n  Â· convert hf\n#align to_local_inverse to_local_inverse\n\n",
 "to_local_homeomorph_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem to_local_homeomorph_target (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) (hs : IsOpen s) :\n    (hf.to_local_homeomorph f s hc hs).target = Â«expr '' Â» f s :=\n  rfl\n#align to_local_homeomorph_target to_local_homeomorph_target\n\n",
 "to_local_homeomorph_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n@[simp]\ntheorem to_local_homeomorph_source (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) (hs : IsOpen s) : (hf.to_local_homeomorph f s hc hs).source = s :=\n  rfl\n#align to_local_homeomorph_source to_local_homeomorph_source\n\n",
 "to_local_homeomorph_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem to_local_homeomorph_coe {n : Â«exprâ„•âˆÂ»} (hf : cont_diff_at ğ•‚ n f a)\n    (hf' : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E' ğ•‚ F') a) (hn : 1 â‰¤ n) :\n    (hf.to_local_homeomorph f hf' hn : E' â†’ F') = f :=\n  rfl\n#align to_local_homeomorph_coe to_local_homeomorph_coe\n\n",
 "to_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/-- The inverse function is approximated linearly on `f '' s` by `f'.symm`. -/\ntheorem to_inv (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c) (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) :\n    approximates_linear_on (hf.to_local_equiv hc).symm (f'.symm : Â«expr â†’L[ ] Â» F ğ•œ E) (Â«expr '' Â» f s)\n      (exprN * ((exprN)â»Â¹ - c)â»Â¹ * c) :=\n  by\n  intro x hx y hy\n  set A := hf.to_local_equiv hc with hA\n  have Af : âˆ€ z, A z = f z := fun z => rfl\n  rcases(mem_image _ _ _).1 hx with âŸ¨x', x's, rflâŸ©\n  rcases(mem_image _ _ _).1 hy with âŸ¨y', y's, rflâŸ©\n  rw [â† Af x', â† Af y', A.left_inv x's, A.left_inv y's]\n  calc\n    Â«exprâ€– â€–Â» (x' - y' - f'.symm (A x' - A y')) â‰¤ exprN * Â«exprâ€– â€–Â» (f' (x' - y' - f'.symm (A x' - A y'))) :=\n      (f' : Â«expr â†’L[ ] Â» E ğ•œ F).bound_of_antilipschitz f'.antilipschitz _\n    _ = exprN * Â«exprâ€– â€–Â» (A y' - A x' - f' (y' - x')) := by\n      congr 2\n      simp only [ContinuousLinearEquiv.apply_symm_apply, ContinuousLinearEquiv.map_sub]\n      abel\n    _ â‰¤ exprN * (c * Â«exprâ€– â€–Â» (y' - x')) := (mul_le_mul_of_nonneg_left (hf _ y's _ x's) (NNReal.coe_nonneg _))\n    _ â‰¤ exprN * (c * ((((exprN)â»Â¹ - c)â»Â¹ : nnreal) * Â«exprâ€– â€–Â» (A y' - A x'))) :=\n      by\n      apply_rules [mul_le_mul_of_nonneg_left, NNReal.coe_nonneg]\n      rw [â† dist_eq_norm, â† dist_eq_norm]\n      exact (hf.antilipschitz hc).le_mul_dist âŸ¨y', y'sâŸ© âŸ¨x', x'sâŸ©\n    _ = (exprN * ((exprN)â»Â¹ - c)â»Â¹ * c : nnreal) * Â«exprâ€– â€–Â» (A x' - A y') :=\n      by\n      simp only [norm_sub_rev, Nonneg.coe_mul]\n      ring\n    \n#align to_inv to_inv\n\n",
 "surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem surjective [CompleteSpace E] (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) univ c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) : surjective f :=\n  by\n  cases' hc with hE hc\n  Â· haveI : subsingleton F := (Equiv.subsingleton_congr f'.to_linear_equiv.to_equiv).1 hE\n    exact surjective_to_subsingleton _\n  Â· apply forall_of_forall_mem_closed_ball (fun y : F => âˆƒ a, f a = y) (f 0) _\n    have hc' : (0 : exprâ„) < (exprN)â»Â¹ - c := by\n      rw [sub_pos]\n      exact hc\n    let p : exprâ„ â†’ Prop := fun R => closed_ball (f 0) R âŠ† Set.range f\n    have hp :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" at_top\n        (p (((exprN)â»Â¹ - c) * r)) :=\n      by\n      have hr :\n        Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" at_top\n          (0 â‰¤ r) :=\n        eventually_ge_at_top 0\n      refine' hr.mono fun r hr => subset.trans _ (image_subset_range f (closed_ball 0 r))\n      refine' hf.surj_on_closed_ball_of_nonlinear_right_inverse f'.to_nonlinear_right_inverse hr _\n      exact subset_univ _\n    refine' ((tendsto_id.const_mul_at_top hc').frequently hp.frequently).mono _\n    exact fun R h y hy => h hy\n#align surjective surjective\n\n",
 "surj_on_closed_ball_of_nonlinear_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- If a function is linearly approximated by a continuous linear map with a (possibly nonlinear)\nright inverse, then it is locally onto: a ball of an explicit radius is included in the image\nof the map. -/\ntheorem surj_on_closed_ball_of_nonlinear_right_inverse (hf : approximates_linear_on f f' s c)\n    (f'symm : f'.nonlinear_right_inverse) {Îµ : exprâ„} {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : closedBall b Îµ âŠ† s) :\n    SurjOn f (closedBall b Îµ) (closedBall (f b) (((f'symm.nnnorm : exprâ„)â»Â¹ - c) * Îµ)) :=\n  by\n  intro y hy\n  cases' le_or_lt (f'symm.nnnorm : exprâ„)â»Â¹ c with hc hc\n  Â· refine' âŸ¨b, by simp [Îµ0], _âŸ©\n    have : dist y (f b) â‰¤ 0 := (mem_closed_ball.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Îµ0)\n    simp only [dist_le_zero] at this\n    rw [this]\n  have If' : (0 : exprâ„) < f'symm.nnnorm := by\n    rw [â† inv_pos]\n    exact (NNReal.coe_nonneg _).trans_lt hc\n  have Icf' : (c : exprâ„) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff If'] at hc\n  have Jf' : (f'symm.nnnorm : exprâ„) â‰  0 := ne_of_gt If'\n  have Jcf' : (1 : exprâ„) - c * f'symm.nnnorm â‰  0 := by\n    apply ne_of_gt\n    linarith\n  /- We have to show that `y` can be written as `f x` for some `x âˆˆ closed_ball b Îµ`.\n    The idea of the proof is to apply the Banach contraction principle to the map\n    `g : x â†¦ x + f'symm (y - f x)`, as a fixed point of this map satisfies `f x = y`.\n    When `f'symm` is a genuine linear inverse, `g` is a contracting map. In our case, since `f'symm`\n    is nonlinear, this map is not contracting (it is not even continuous), but still the proof of\n    the contraction theorem holds: `uâ‚™ = gâ¿ b` is a Cauchy sequence, converging exponentially fast\n    to the desired point `x`. Instead of appealing to general results, we check this by hand.\n  \n    The main point is that `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` stays in the ball on which one has a\n    control. Therefore, the bound can be checked at the next step, and so on inductively.\n    -/\n  set g := fun x => x + f'symm (y - f x) with hg\n  set u := fun n : â„• => (Â«expr ^[ ]Â» g n) b with hu\n  have usucc : âˆ€ n, u (n + 1) = g (u n) := by simp [hu, â† iterate_succ_apply' g _ b]\n  -- First bound: if `f z` is close to `y`, then `g z` is close to `z` (i.e., almost a fixed point).\n  have A : âˆ€ z, dist (g z) z â‰¤ f'symm.nnnorm * dist (f z) y :=\n    by\n    intro z\n    rw [dist_eq_norm, hg, add_sub_cancel', dist_eq_norm']\n    exact f'symm.bound _\n  -- Second bound: if `z` and `g z` are in the set with good control, then `f (g z)` becomes closer\n  -- to `y` than `f z` was (this uses the linear approximation property, and is the reason for the\n  -- choice of the formula for `g`).\n  have B : âˆ€ z âˆˆ closed_ball b Îµ, g z âˆˆ closed_ball b Îµ â†’ dist (f (g z)) y â‰¤ c * f'symm.nnnorm * dist (f z) y :=\n    by\n    intro z hz hgz\n    set v := f'symm (y - f z) with hv\n    calc\n      dist (f (g z)) y = Â«exprâ€– â€–Â» (f (z + v) - y) := by rw [dist_eq_norm]\n      _ = Â«exprâ€– â€–Â» (f (z + v) - f z - f' v + f' v - (y - f z)) :=\n        by\n        congr 1\n        abel\n      _ = Â«exprâ€– â€–Â» (f (z + v) - f z - f' (z + v - z)) := by\n        simp only [continuous_linear_map.nonlinear_right_inverse.right_inv, add_sub_cancel', sub_add_cancel]\n      _ â‰¤ c * Â«exprâ€– â€–Â» (z + v - z) := (hf _ (hÎµ hgz) _ (hÎµ hz))\n      _ â‰¤ c * (f'symm.nnnorm * dist (f z) y) :=\n        by\n        apply mul_le_mul_of_nonneg_left _ (NNReal.coe_nonneg c)\n        simpa [hv, dist_eq_norm'] using f'symm.bound (y - f z)\n      _ = c * f'symm.nnnorm * dist (f z) y := by ring\n      \n  -- Third bound: a complicated bound on `dist w b` (that will show up in the induction) is enough\n  -- to check that `w` is in the ball on which one has controls. Will be used to check that `u n`\n  -- belongs to this ball for all `n`.\n  have C :\n    âˆ€ (n : â„•) (w : E),\n      dist w b â‰¤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) * dist (f b) y â†’\n        w âˆˆ closed_ball b Îµ :=\n    by\n    intro n w hw\n    apply hw.trans\n    rw [div_mul_eq_mul_div, div_le_iff]\n    swap\n    Â· linarith\n    calc\n      (f'symm.nnnorm : exprâ„) * (1 - (c * f'symm.nnnorm) ^ n) * dist (f b) y =\n          f'symm.nnnorm * dist (f b) y * (1 - (c * f'symm.nnnorm) ^ n) :=\n        by ring\n      _ â‰¤ f'symm.nnnorm * dist (f b) y * 1 :=\n        by\n        apply mul_le_mul_of_nonneg_left _ (mul_nonneg (NNReal.coe_nonneg _) dist_nonneg)\n        rw [sub_le_self_iff]\n        exact pow_nonneg (mul_nonneg (NNReal.coe_nonneg _) (NNReal.coe_nonneg _)) _\n      _ â‰¤ f'symm.nnnorm * (((f'symm.nnnorm : exprâ„)â»Â¹ - c) * Îµ) :=\n        by\n        rw [mul_one]\n        exact mul_le_mul_of_nonneg_left (mem_closed_ball'.1 hy) (NNReal.coe_nonneg _)\n      _ = Îµ * (1 - c * f'symm.nnnorm) := by\n        field_simp\n        ring\n      \n  /- Main inductive control: `f (u n)` becomes exponentially close to `y`, and therefore\n    `dist (u (n+1)) (u n)` becomes exponentally small, making it possible to get an inductive\n    bound on `dist (u n) b`, from which one checks that `u n` remains in the ball on which we\n    have estimates. -/\n  have D :\n    âˆ€ n : â„•,\n      dist (f (u n)) y â‰¤ (c * f'symm.nnnorm) ^ n * dist (f b) y âˆ§\n        dist (u n) b â‰¤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n    by\n    intro n\n    induction' n with n IH\n    Â· simp [hu, le_refl]\n    rw [usucc]\n    have Ign :\n      dist (g (u n)) b â‰¤ f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n.succ) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n      calc\n        dist (g (u n)) b â‰¤ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _\n        _ â‰¤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := (add_le_add (A _) le_rfl)\n        _ â‰¤\n            f'symm.nnnorm * ((c * f'symm.nnnorm) ^ n * dist (f b) y) +\n              f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n          (add_le_add (mul_le_mul_of_nonneg_left IH.1 (NNReal.coe_nonneg _)) IH.2)\n        _ = f'symm.nnnorm * (1 - (c * f'symm.nnnorm) ^ n.succ) / (1 - c * f'symm.nnnorm) * dist (f b) y :=\n          by\n          field_simp [Jcf']\n          ring\n        \n    refine' âŸ¨_, IgnâŸ©\n    calc\n      dist (f (g (u n))) y â‰¤ c * f'symm.nnnorm * dist (f (u n)) y := B _ (C n _ IH.2) (C n.succ _ Ign)\n      _ â‰¤ c * f'symm.nnnorm * ((c * f'symm.nnnorm) ^ n * dist (f b) y) :=\n        (mul_le_mul_of_nonneg_left IH.1 (mul_nonneg (NNReal.coe_nonneg _) (NNReal.coe_nonneg _)))\n      _ = (c * f'symm.nnnorm) ^ n.succ * dist (f b) y := by ring\n      \n  -- Deduce from the inductive bound that `uâ‚™` is a Cauchy sequence, therefore converging.\n  have : CauchySeq u :=\n    haveI : âˆ€ n : â„•, dist (u n) (u (n + 1)) â‰¤ f'symm.nnnorm * dist (f b) y * (c * f'symm.nnnorm) ^ n :=\n      by\n      intro n\n      calc\n        dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]\n        _ â‰¤ f'symm.nnnorm * dist (f (u n)) y := (A _)\n        _ â‰¤ f'symm.nnnorm * ((c * f'symm.nnnorm) ^ n * dist (f b) y) :=\n          (mul_le_mul_of_nonneg_left (D n).1 (NNReal.coe_nonneg _))\n        _ = f'symm.nnnorm * dist (f b) y * (c * f'symm.nnnorm) ^ n := by ring\n        \n    cauchySeq_of_le_geometric _ _ Icf' this\n  obtain âŸ¨x, hxâŸ© : âˆƒ x, tendsto u at_top ((nhds) x) := cauchySeq_tendsto_of_complete this\n  -- As all the `uâ‚™` belong to the ball `closed_ball b Îµ`, so does their limit `x`.\n  have xmem : x âˆˆ closed_ball b Îµ := is_closed_ball.mem_of_tendsto hx (eventually_of_forall fun n => C n _ (D n).2)\n  refine' âŸ¨x, xmem, _âŸ©\n  -- It remains to check that `f x = y`. This follows from continuity of `f` on `closed_ball b Îµ`\n  -- and from the fact that `f uâ‚™` is converging to `y` by construction.\n  have hx' : tendsto u at_top (nhds_within (closed_ball b Îµ) x) :=\n    by\n    simp only [nhdsWithin, tendsto_inf, hx, true_and_iff, ge_iff_le, tendsto_principal]\n    exact eventually_of_forall fun n => C n _ (D n).2\n  have T1 : tendsto (fun n => f (u n)) at_top ((nhds) (f x)) := (hf.continuous_on.mono hÎµ x xmem).tendsto.comp hx'\n  have T2 : tendsto (fun n => f (u n)) at_top ((nhds) y) :=\n    by\n    rw [tendsto_iff_dist_tendsto_zero]\n    refine' squeeze_zero (fun n => dist_nonneg) (fun n => (D n).1) _\n    simpa using\n      (tendsto_pow_atTop_nhds_0_of_lt_1 (mul_nonneg (NNReal.coe_nonneg _) (NNReal.coe_nonneg _)) Icf').mul\n        tendsto_const_nhds\n  exact tendsto_nhds_unique T1 T2\n#align surj_on_closed_ball_of_nonlinear_right_inverse surj_on_closed_ball_of_nonlinear_right_inverse\n\n",
 "open_map_of_strict_fderiv_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem open_map_of_strict_fderiv_equiv [CompleteSpace E] {f : E â†’ F} {f' : E â†’ Â«expr â‰ƒL[ ] Â» E ğ•œ F}\n    (hf : âˆ€ x, has_strict_fderiv_at f (f' x : Â«expr â†’L[ ] Â» E ğ•œ F) x) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => (hf x).map_nhds_eq_of_equiv.ge\n#align open_map_of_strict_fderiv_equiv open_map_of_strict_fderiv_equiv\n\n",
 "open_map_of_strict_deriv":
 "/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem open_map_of_strict_deriv [CompleteSpace ğ•œ] {f f' : ğ•œ â†’ ğ•œ} (hf : âˆ€ x, has_strict_deriv_at f (f' x) x)\n    (h0 : âˆ€ x, f' x â‰  0) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => ((hf x).map_nhds_eq (h0 x)).ge\n#align open_map_of_strict_deriv open_map_of_strict_deriv\n\n",
 "open_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem open_image (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) (hs : IsOpen s)\n    (hc : subsingleton F âˆ¨ c < f'symm.nnnormâ»Â¹) : IsOpen (Â«expr '' Â» f s) :=\n  by\n  cases' hc with hE hc;\n  Â· skip\n    apply isOpen_discrete\n  simp only [isOpen_iff_mem_nhds, nhds_basis_closed_ball.mem_iff, ball_image_iff] at hsâŠ¢\n  intro x hx\n  rcases hs x hx with âŸ¨Îµ, Îµ0, hÎµâŸ©\n  refine' âŸ¨(f'symm.nnnormâ»Â¹ - c) * Îµ, mul_pos (sub_pos.2 hc) Îµ0, _âŸ©\n  exact (hf.surj_on_closed_ball_of_nonlinear_right_inverse f'symm (le_of_lt Îµ0) hÎµ).mono hÎµ (subset.refl _)\n#align open_image open_image\n\n",
 "mono_set":
 "theorem mono_set (hst : s âŠ† t) (hf : approximates_linear_on f f' t c) : approximates_linear_on f f' s c :=\n  fun x hx y hy => hf x (hst hx) y (hst hy)\n#align mono_set mono_set\n\n",
 "mono_num":
 "theorem mono_num (hc : c â‰¤ c') (hf : approximates_linear_on f f' s c) : approximates_linear_on f f' s c' :=\n  fun x hx y hy => le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc <| norm_nonneg _)\n#align mono_num mono_num\n\n",
 "mem_to_local_homeomorph_source":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem mem_to_local_homeomorph_source {n : Â«exprâ„•âˆÂ»} (hf : cont_diff_at ğ•‚ n f a)\n    (hf' : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E' ğ•‚ F') a) (hn : 1 â‰¤ n) :\n    a âˆˆ (hf.to_local_homeomorph f hf' hn).source :=\n  (hf.has_strict_fderiv_at' hf' hn).mem_to_local_homeomorph_source\n#align mem_to_local_homeomorph_source mem_to_local_homeomorph_source\n\n",
 "map_nhds_eq_of_surj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq_of_surj [CompleteSpace E] [CompleteSpace F] {f : E â†’ F} {f' : Â«expr â†’L[ ] Â» E ğ•œ F} {a : E}\n    (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) (h : LinearMap.range f' = Â«exprâŠ¤Â») :\n    map f ((nhds) a) = (nhds) (f a) :=\n  by\n  let f'symm := f'.nonlinear_right_inverse_of_surjective h\n  set c : nnreal := f'symm.nnnormâ»Â¹ / 2 with hc\n  have f'symm_pos : 0 < f'symm.nnnorm := f'.nonlinear_right_inverse_of_surjective_nnnorm_pos h\n  have cpos : 0 < c := by simp [hc, half_pos, inv_pos, f'symm_pos]\n  obtain âŸ¨s, s_nhds, hsâŸ© : âˆƒ s âˆˆ (nhds) a, approximates_linear_on f f' s c :=\n    hf.approximates_deriv_on_nhds (or.inr cpos)\n  apply hs.map_nhds_eq f'symm s_nhds (or.inr (NNReal.half_lt_self _))\n  simp [ne_of_gt f'symm_pos]\n#align map_nhds_eq_of_surj map_nhds_eq_of_surj\n\n",
 "map_nhds_eq_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq_of_equiv (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    map f ((nhds) a) = (nhds) (f a) :=\n  (hf.to_local_homeomorph f).map_nhds_eq hf.mem_to_local_homeomorph_source\n#align map_nhds_eq_of_equiv map_nhds_eq_of_equiv\n\n",
 "map_nhds_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem map_nhds_eq : map f ((nhds) a) = (nhds) (f a) :=\n  (hf.has_strict_fderiv_at_equiv hf').map_nhds_eq_of_equiv\n#align map_nhds_eq map_nhds_eq\n\n",
 "local_inverse_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem local_inverse_unique (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) {g : F â†’ E}\n    (hg :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n        (g (f x) = x)) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) (f a)) (g y = local_inverse f f' a hf y) :=\n  eventuallyEq_of_left_inv_of_right_inv hg hf.eventually_right_inverse <|\n    (hf.to_local_homeomorph f).tendsto_symm hf.mem_to_local_homeomorph_source\n#align local_inverse_unique local_inverse_unique\n\n",
 "local_inverse_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem local_inverse_tendsto (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    Tendsto (hf.local_inverse f f' a) (nhds <| f a) ((nhds) a) :=\n  (hf.to_local_homeomorph f).tendsto_symm hf.mem_to_local_homeomorph_source\n#align local_inverse_tendsto local_inverse_tendsto\n\n",
 "local_inverse_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem local_inverse_def (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    hf.local_inverse f _ _ = (hf.to_local_homeomorph f).symm :=\n  rfl\n#align local_inverse_def local_inverse_def\n\n",
 "local_inverse_continuous_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem local_inverse_continuous_at (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    ContinuousAt (hf.local_inverse f f' a) (f a) :=\n  (hf.to_local_homeomorph f).continuous_at_symm hf.image_mem_to_local_homeomorph_target\n#align local_inverse_continuous_at local_inverse_continuous_at\n\n",
 "local_inverse_apply_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem local_inverse_apply_image {n : Â«exprâ„•âˆÂ»} (hf : cont_diff_at ğ•‚ n f a)\n    (hf' : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E' ğ•‚ F') a) (hn : 1 â‰¤ n) : hf.local_inverse hf' hn (f a) = a :=\n  (hf.has_strict_fderiv_at' hf' hn).local_inverse_apply_image\n#align local_inverse_apply_image local_inverse_apply_image\n\n",
 "lipschitz_sub":
 "theorem lipschitz_sub (hf : approximates_linear_on f f' s c) : LipschitzWith c fun x : s => f x - f' x :=\n  by\n  refine' LipschitzWith.of_dist_le_mul fun x y => _\n  rw [dist_eq_norm, Subtype.dist_eq, dist_eq_norm]\n  convert hf x x.2 y y.2 using 2\n  rw [f'.map_sub]; abel\n#align lipschitz_sub lipschitz_sub\n\n",
 "lipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\nprotected theorem lipschitz (hf : approximates_linear_on f f' s c) : LipschitzWith (Â«exprâ€– â€–â‚ŠÂ» f' + c) (s.restrict f) :=\n  by simpa only [restrict_apply, add_sub_cancel'_right] using (f'.lipschitz.restrict s).add hf.lipschitz_sub\n#align lipschitz lipschitz\n\n",
 "inverse_continuous_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The inverse function is continuous on `f '' s`. Use properties of `local_homeomorph` instead. -/\ntheorem inverse_continuous_on (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) : ContinuousOn (hf.to_local_equiv hc).symm (Â«expr '' Â» f s) :=\n  by\n  apply continuousOn_iff_continuous_restrict.2\n  refine' ((hf.antilipschitz hc).to_right_inv_on' _ (hf.to_local_equiv hc).right_inv').continuous\n  exact fun x hx => (hf.to_local_equiv hc).map_target hx\n#align inverse_continuous_on inverse_continuous_on\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem injective (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) : injective (s.restrict f) :=\n  (hf.antilipschitz hc).injective\n#align injective injective\n\n",
 "inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem inj_on (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) : InjOn f s :=\n  injOn_iff_injective.2 <| hf.injective hc\n#align inj_on inj_on\n\n",
 "image_mem_to_local_homeomorph_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ„•âˆÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem image_mem_to_local_homeomorph_target {n : Â«exprâ„•âˆÂ»} (hf : cont_diff_at ğ•‚ n f a)\n    (hf' : has_fderiv_at f (f' : Â«expr â†’L[ ] Â» E' ğ•‚ F') a) (hn : 1 â‰¤ n) :\n    f a âˆˆ (hf.to_local_homeomorph f hf' hn).target :=\n  (hf.has_strict_fderiv_at' hf' hn).image_mem_to_local_homeomorph_target\n#align image_mem_to_local_homeomorph_target image_mem_to_local_homeomorph_target\n\n",
 "image_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem image_mem_nhds (hf : approximates_linear_on f f' s c) (f'symm : f'.nonlinear_right_inverse) {x : E}\n    (hs : s âˆˆ (nhds) x) (hc : subsingleton F âˆ¨ c < f'symm.nnnormâ»Â¹) : Â«expr '' Â» f s âˆˆ (nhds) (f x) :=\n  by\n  obtain âŸ¨t, hts, ht, xtâŸ© : âˆƒ (t : _)(_ : t âŠ† s), IsOpen t âˆ§ x âˆˆ t := _root_.mem_nhds_iff.1 hs\n  have := IsOpen.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)\n  exact mem_of_superset this (image_subset _ hts)\n#align image_mem_nhds image_mem_nhds\n\n",
 "exists_homeomorph_extension":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚œ Â» -/\n/-- In a real vector space, a function `f` that approximates a linear equivalence on a subset `s`\ncan be extended to a homeomorphism of the whole space. -/\ntheorem exists_homeomorph_extension {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprâ„) E] {F : Type _}\n    [NormedAddCommGroup F] [NormedSpace (exprâ„) F] [FiniteDimensional (exprâ„) F] {s : Set E} {f : E â†’ F}\n    {f' : Â«expr â‰ƒL[ ] Â» E (exprâ„) F} {c : nnreal} (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E (exprâ„) F) s c)\n    (hc : subsingleton E âˆ¨ lipschitz_extension_constant F * c < (Â«exprâ€– â€–â‚ŠÂ» (f'.symm : Â«expr â†’L[ ] Â» F (exprâ„) E))â»Â¹) :\n    âˆƒ g : Â«expr â‰ƒâ‚œ Â» E F, EqOn f g s :=\n  by\n  -- the difference `f - f'` is Lipschitz on `s`. It can be extended to a Lipschitz function `u`\n  -- on the whole space, with a slightly worse Lipschitz constant. Then `f' + u` will be the\n  -- desired homeomorphism.\n  obtain âŸ¨u, hu, ufâŸ© : âˆƒ u : E â†’ F, LipschitzWith (lipschitz_extension_constant F * c) u âˆ§ eq_on (f - f') u s :=\n    hf.lipschitz_on_with.extend_finite_dimension\n  let g : E â†’ F := fun x => f' x + u x\n  have fg : eq_on f g s := fun x hx => by simp_rw [g, â† uf hx, Pi.sub_apply, add_sub_cancel'_right]\n  have hg : approximates_linear_on g (f' : Â«expr â†’L[ ] Â» E (exprâ„) F) univ (lipschitz_extension_constant F * c) :=\n    by\n    apply lipschitz_on_with.approximates_linear_on\n    rw [lipschitz_on_univ]\n    convert hu\n    ext x\n    simp only [add_sub_cancel', ContinuousLinearEquiv.coe_coe, Pi.sub_apply]\n  haveI : FiniteDimensional (exprâ„) E := f'.symm.to_linear_equiv.finite_dimensional\n  exact âŸ¨hg.to_homeomorph g hc, fgâŸ©\n#align exists_homeomorph_extension exists_homeomorph_extension\n\n",
 "eventually_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_right_inverse (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\"\n      ((nhds) (f a)) (f (hf.local_inverse f f' a y) = y) :=\n  (hf.to_local_homeomorph f).eventually_right_inverse' hf.mem_to_local_homeomorph_source\n#align eventually_right_inverse eventually_right_inverse\n\n",
 "eventually_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem eventually_left_inverse (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) a)\n      (hf.local_inverse f f' a (f x) = x) :=\n  (hf.to_local_homeomorph f).eventually_left_inverse hf.mem_to_local_homeomorph_source\n#align eventually_left_inverse eventually_left_inverse\n\n",
 "closed_ball_subset_target":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\ntheorem closed_ball_subset_target (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) (hs : IsOpen s) {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : closedBall b Îµ âŠ† s) :\n    closedBall (f b) (((exprN)â»Â¹ - c) * Îµ) âŠ† (hf.to_local_homeomorph f s hc hs).target :=\n  (hf.surj_on_closed_ball_of_nonlinear_right_inverse f'.to_nonlinear_right_inverse Îµ0 hÎµ).mono hÎµ (Subset.refl _)\n#align closed_ball_subset_target closed_ball_subset_target\n\n",
 "approximates_linear_on_iff_lipschitz_on_with":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem approximates_linear_on_iff_lipschitz_on_with {f : E â†’ F} {f' : Â«expr â†’L[ ] Â» E ğ•œ F} {s : Set E} {c : nnreal} :\n    approximates_linear_on f f' s c â†” LipschitzOnWith c (f - f') s :=\n  by\n  have : âˆ€ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y :=\n    by\n    intro x y\n    simp only [map_sub, Pi.sub_apply]\n    abel\n  simp only [this, lipschitzOnWith_iff_norm_sub_le, approximates_linear_on]\n#align approximates_linear_on_iff_lipschitz_on_with approximates_linear_on_iff_lipschitz_on_with\n\n",
 "approximates_linear_on_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Heather Macbeth, SÃ©bastien GouÃ«zel\n-/\n@[simp]\ntheorem approximates_linear_on_empty (f : E â†’ F) (f' : Â«expr â†’L[ ] Â» E ğ•œ F) (c : nnreal) :\n    approximates_linear_on f f' âˆ… c := by simp [approximates_linear_on]\n#align approximates_linear_on_empty approximates_linear_on_empty\n\n",
 "approximates_deriv_on_open_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–â‚ŠÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem approximates_deriv_on_open_nhds (hf : has_strict_fderiv_at f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) a) :\n    âˆƒ (s : Set E)(hs : a âˆˆ s âˆ§ IsOpen s),\n      approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s ((Â«exprâ€– â€–â‚ŠÂ» (f'.symm : Â«expr â†’L[ ] Â» F ğ•œ E))â»Â¹ / 2) :=\n  by\n  refine' ((nhds_basis_opens a).exists_iff _).1 _\n  exact fun s t => approximates_linear_on.mono_set\n  exact hf.approximates_deriv_on_nhds <| f'.subsingleton_or_nnnorm_symm_pos.imp id fun hf' => half_pos <| inv_pos.2 hf'\n#align approximates_deriv_on_open_nhds approximates_deriv_on_open_nhds\n\n",
 "approximates_deriv_on_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem approximates_deriv_on_nhds {f : E â†’ F} {f' : Â«expr â†’L[ ] Â» E ğ•œ F} {a : E} (hf : has_strict_fderiv_at f f' a)\n    {c : nnreal} (hc : subsingleton E âˆ¨ 0 < c) : âˆƒ s âˆˆ (nhds) a, approximates_linear_on f f' s c :=\n  by\n  cases' hc with hE hc\n  Â· refine' âŸ¨univ, IsOpen.mem_nhds isOpen_univ trivial, fun x hx y hy => _âŸ©\n    simp [@subsingleton.elim E hE x y]\n  have := hf.def hc\n  rw [nhds_prod_eq, Filter.Eventually, mem_prod_same_iff] at this\n  rcases this with âŸ¨s, has, hsâŸ©\n  exact âŸ¨s, has, fun x hx y hy => hs (mk_mem_prod hx hy)âŸ©\n#align approximates_deriv_on_nhds approximates_deriv_on_nhds\n\n",
 "antilipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprN -/\nprotected theorem antilipschitz (hf : approximates_linear_on f (f' : Â«expr â†’L[ ] Â» E ğ•œ F) s c)\n    (hc : subsingleton E âˆ¨ c < (exprN)â»Â¹) : AntilipschitzWith ((exprN)â»Â¹ - c)â»Â¹ (s.restrict f) :=\n  by\n  cases' hc with hE hc\n  Â· haveI : subsingleton s := âŸ¨fun x y => Subtype.eq <| @subsingleton.elim _ hE _ _âŸ©\n    exact AntilipschitzWith.of_subsingleton\n  convert(f'.antilipschitz.restrict s).add_lipschitz_with hf.lipschitz_sub hc\n  simp [restrict]\n#align antilipschitz antilipschitz\n\n",
 "ContinuousOn":
 "#print ContinuousOn /-\nprotected theorem ContinuousOn (hf : approximates_linear_on f f' s c) : ContinuousOn f s :=\n  continuousOn_iff_continuous_restrict.2 hf.continuous\n#align continuous_on ContinuousOn\n-/\n\n",
 "Continuous":
 "#print Continuous /-\nprotected theorem Continuous (hf : approximates_linear_on f f' s c) : Continuous (s.restrict f) :=\n  hf.lipschitz.continuous\n#align continuous Continuous\n-/\n\n"}