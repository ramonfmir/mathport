{"remove_zero_of_pos":
 "theorem remove_zero_of_pos (p : formal_multilinear_series ğ•œ E F) {n : â„•} (h : 0 < n) : p.remove_zero n = p n :=\n  by\n  rw [â† nat.succ_pred_eq_of_pos h]\n  rfl\n#align remove_zero_of_pos remove_zero_of_pos\n\n",
 "remove_zero_coeff_zero":
 "@[simp]\ntheorem remove_zero_coeff_zero (p : formal_multilinear_series ğ•œ E F) : p.remove_zero 0 = 0 :=\n  rfl\n#align remove_zero_coeff_zero remove_zero_coeff_zero\n\n",
 "remove_zero_coeff_succ":
 "@[simp]\ntheorem remove_zero_coeff_succ (p : formal_multilinear_series ğ•œ E F) (n : â„•) : p.remove_zero (n + 1) = p (n + 1) :=\n  rfl\n#align remove_zero_coeff_succ remove_zero_coeff_succ\n\n",
 "order_zero":
 "@[simp]\ntheorem order_zero : (0 : formal_multilinear_series ğ•œ E F).order = 0 := by simp [order]\n#align order_zero order_zero\n\n",
 "order_eq_zero_iff'":
 "theorem order_eq_zero_iff' : p.order = 0 â†” p = 0 âˆ¨ p 0 â‰  0 := by by_cases h : p = 0 <;> simp [h, order_eq_zero_iff]\n#align order_eq_zero_iff' order_eq_zero_iff'\n\n",
 "order_eq_zero_iff":
 "theorem order_eq_zero_iff (hp : p â‰  0) : p.order = 0 â†” p 0 â‰  0 := by\n  classical\n    have : âˆƒ n, p n â‰  0 := formal_multilinear_series.ne_iff.mp hp\n    simp [order_eq_find this, hp]\n#align order_eq_zero_iff order_eq_zero_iff\n\n",
 "order_eq_find'":
 "theorem order_eq_find' [DecidablePred fun n => p n â‰  0] (hp : p â‰  0) :\n    p.order = nat.find (formal_multilinear_series.ne_iff.mp hp) :=\n  order_eq_find _\n#align order_eq_find' order_eq_find'\n\n",
 "order_eq_find":
 "theorem order_eq_find [DecidablePred fun n => p n â‰  0] (hp : âˆƒ n, p n â‰  0) : p.order = nat.find hp := by\n  simp [order, Inf, hp]\n#align order_eq_find order_eq_find\n\n",
 "norm_apply_eq_norm_coef":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n@[simp]\ntheorem norm_apply_eq_norm_coef : Â«exprâ€– â€–Â» (p n) = Â«exprâ€– â€–Â» (coeff p n) := by\n  rw [â† mk_pi_field_coeff_eq p, continuous_multilinear_map.norm_mk_pi_field]\n#align norm_apply_eq_norm_coef norm_apply_eq_norm_coef\n\n",
 "ne_zero_of_order_ne_zero":
 "theorem ne_zero_of_order_ne_zero (hp : p.order â‰  0) : p â‰  0 := fun h => by simpa [h] using hp\n#align ne_zero_of_order_ne_zero ne_zero_of_order_ne_zero\n\n",
 "ne_iff":
 "protected theorem ne_iff {p q : formal_multilinear_series ğ•œ E F} : p â‰  q â†” âˆƒ n, p n â‰  q n :=\n  Function.ne_iff\n#align ne_iff ne_iff\n\n",
 "mk_pi_field_coeff_eq":
 "theorem mk_pi_field_coeff_eq (p : formal_multilinear_series ğ•œ ğ•œ E) (n : â„•) :\n    continuous_multilinear_map.mk_pi_field ğ•œ (Fin n) (p.coeff n) = p n :=\n  (p n).mk_pi_field_apply_one_eq_self\n#align mk_pi_field_coeff_eq mk_pi_field_coeff_eq\n\n",
 "ext_iff":
 "/-\nCopyright (c) 2019 SÃ©bastien GouÃ«zel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: SÃ©bastien GouÃ«zel\n-/\n/- `derive` is not able to find the module structure, probably because Lean is confused by the\ndependent types. We register it explicitly. -/\nprotected theorem ext_iff {p q : formal_multilinear_series ğ•œ E F} : p = q â†” âˆ€ n, p n = q n :=\n  Function.funext_iff\n#align ext_iff ext_iff\n\n",
 "const_formal_multilinear_series_apply":
 "@[simp]\ntheorem const_formal_multilinear_series_apply [NontriviallyNormedField ğ•œ] [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œ F] {c : F} {n : â„•} (hn : n â‰  0) : const_formal_multilinear_series ğ•œ E c n = 0 :=\n  nat.cases_on n (fun hn => (hn rfl).elim) (fun _ _ => rfl) hn\n#align const_formal_multilinear_series_apply const_formal_multilinear_series_apply\n\n",
 "congr":
 "#print congr /-\n/-- Convenience congruence lemma stating in a dependent setting that, if the arguments to a formal\nmultilinear series are equal, then the values are also equal. -/\ntheorem congr (p : formal_multilinear_series ğ•œ E F) {m n : â„•} {v : Fin m â†’ E} {w : Fin n â†’ E} (h1 : m = n)\n    (h2 : âˆ€ (i : â„•) (him : i < m) (hin : i < n), v âŸ¨i, himâŸ© = w âŸ¨i, hinâŸ©) : p m v = p n w :=\n  by\n  cases h1\n  congr with âŸ¨i, hiâŸ©\n  exact h2 i hi hi\n#align congr congr\n-/\n\n",
 "comp_formal_multilinear_series_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\ntheorem comp_formal_multilinear_series_apply' (f : Â«expr â†’L[ ] Â» F ğ•œ G) (p : formal_multilinear_series ğ•œ E F) (n : â„•)\n    (v : Fin n â†’ E) : (f.comp_formal_multilinear_series p) n v = f (p n v) :=\n  rfl\n#align comp_formal_multilinear_series_apply' comp_formal_multilinear_series_apply'\n\n",
 "comp_formal_multilinear_series_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem comp_formal_multilinear_series_apply (f : Â«expr â†’L[ ] Â» F ğ•œ G) (p : formal_multilinear_series ğ•œ E F) (n : â„•) :\n    (f.comp_formal_multilinear_series p) n = f.comp_continuous_multilinear_map (p n) :=\n  rfl\n#align comp_formal_multilinear_series_apply comp_formal_multilinear_series_apply\n\n",
 "comp_continuous_linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n@[simp]\ntheorem comp_continuous_linear_map_apply (p : formal_multilinear_series ğ•œ F G) (u : Â«expr â†’L[ ] Â» E ğ•œ F) (n : â„•)\n    (v : Fin n â†’ E) : (p.comp_continuous_linear_map u) n v = p n (u âˆ˜ v) :=\n  rfl\n#align comp_continuous_linear_map_apply comp_continuous_linear_map_apply\n\n",
 "coeff_iterate_fslope":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n@[simp]\ntheorem coeff_iterate_fslope (k n : â„•) : ((Â«expr ^[ ]Â» fslope k) p).coeff n = p.coeff (n + k) := by\n  induction' k with k ih generalizing p <;> first |rfl|simpa [ih]\n#align coeff_iterate_fslope coeff_iterate_fslope\n\n",
 "coeff_fslope":
 "@[simp]\ntheorem coeff_fslope : p.fslope.coeff n = p.coeff (n + 1) :=\n  by\n  have : @Fin.cons n (fun _ => ğ•œ) 1 (1 : Fin n â†’ ğ•œ) = 1 := Fin.cons_self_tail 1\n  simp only [fslope, coeff, continuous_multilinear_map.curry_left_apply, this]\n#align coeff_fslope coeff_fslope\n\n",
 "coeff_eq_zero":
 "theorem coeff_eq_zero : p.coeff n = 0 â†” p n = 0 := by\n  rw [â† mk_pi_field_coeff_eq p, continuous_multilinear_map.mk_pi_field_eq_zero_iff]\n#align coeff_eq_zero coeff_eq_zero\n\n",
 "apply_order_ne_zero'":
 "theorem apply_order_ne_zero' (hp : p.order â‰  0) : p p.order â‰  0 :=\n  apply_order_ne_zero (ne_zero_of_order_ne_zero hp)\n#align apply_order_ne_zero' apply_order_ne_zero'\n\n",
 "apply_order_ne_zero":
 "theorem apply_order_ne_zero (hp : p â‰  0) : p p.order â‰  0 := by\n  classical\n    let h := formal_multilinear_series.ne_iff.mp hp\n    exact (order_eq_find h).symm â–¸ nat.find_spec h\n#align apply_order_ne_zero apply_order_ne_zero\n\n",
 "apply_eq_zero_of_lt_order":
 "theorem apply_eq_zero_of_lt_order (hp : n < p.order) : p n = 0 :=\n  by\n  by_cases p = 0\n  Â· simp [h]\n  Â·\n    classical\n      rw [order_eq_find' h] at hp\n      simpa using nat.find_min _ hp\n#align apply_eq_zero_of_lt_order apply_eq_zero_of_lt_order\n\n",
 "apply_eq_prod_smul_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem apply_eq_prod_smul_coeff :\n    p n y =\n      Â«expr â€¢ Â»\n        (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (y i))\n        (p.coeff n) :=\n  by\n  convert(p n).to_multilinear_map.map_smul_univ y 1\n  funext <;> simp only [Pi.one_apply, Algebra.id.smul_eq_mul, mul_one]\n#align apply_eq_prod_smul_coeff apply_eq_prod_smul_coeff\n\n",
 "apply_eq_pow_smul_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n@[simp]\ntheorem apply_eq_pow_smul_coeff : (p n fun _ => z) = Â«expr â€¢ Â» (z ^ n) (p.coeff n) := by simp\n#align apply_eq_pow_smul_coeff apply_eq_pow_smul_coeff\n\n"}