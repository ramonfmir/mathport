{"differentiable_at":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem differentiable_at {f : X → Y} {x : X} (h : conformal_at f x) : differentiable_at (exprℝ) f x :=\n  let ⟨_, h₁, _⟩ := h\n  h₁.differentiable_at\n#align differentiable_at differentiable_at\n\n",
 "differentiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem differentiable {f : X → Y} (h : conformal f) : differentiable (exprℝ) f := fun x => (h x).differentiable_at\n#align differentiable differentiable\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem const_smul {f : X → Y} (hf : conformal f) {c : exprℝ} (hc : c ≠ 0) : conformal («expr • » c f) := fun x =>\n  (hf x).const_smul hc\n#align const_smul const_smul\n\n",
 "congr":
 "#print congr /-\ntheorem congr {f g : X → Y} {x : X} {u : set X} (hx : x ∈ u) (hu : is_open u) (hf : conformal_at f x)\n    (h : ∀ x : X, x ∈ u → g x = f x) : conformal_at g x :=\n  let ⟨f', hfderiv, hf'⟩ := hf\n  ⟨f', hfderiv.congr_of_eventually_eq ((hu.eventually_mem hx).mono h), hf'⟩\n#align congr congr\n-/\n\n",
 "conformal_id":
 "theorem conformal_id : conformal (id : X → X) := fun x => conformal_at_id x\n#align conformal_id conformal_id\n\n",
 "conformal_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem conformal_const_smul {c : exprℝ} (h : c ≠ 0) : conformal fun x : X => «expr • » c x := fun x =>\n  conformal_at_const_smul h x\n#align conformal_const_smul conformal_const_smul\n\n",
 "conformal_at_iff_is_conformal_map_fderiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- A function is a conformal map if and only if its differential is a conformal linear map-/\ntheorem conformal_at_iff_is_conformal_map_fderiv {f : X → Y} {x : X} :\n    conformal_at f x ↔ is_conformal_map (fderiv (exprℝ) f x) :=\n  by\n  constructor\n  · rintro ⟨f', hf, hf'⟩\n    rwa [hf.fderiv]\n  · intro H\n    by_cases h : differentiable_at (exprℝ) f x\n    · exact ⟨fderiv (exprℝ) f x, h.has_fderiv_at, H⟩\n    · nontriviality X\n      exact absurd (fderiv_zero_of_not_differentiable_at h) H.ne_zero\n#align conformal_at_iff_is_conformal_map_fderiv conformal_at_iff_is_conformal_map_fderiv\n\n",
 "conformal_at_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2021 Yourong Zang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yourong Zang\n-/\ntheorem conformal_at_id (x : X) : conformal_at id x :=\n  ⟨id (exprℝ) X, has_fderiv_at_id _, is_conformal_map_id⟩\n#align conformal_at_id conformal_at_id\n\n",
 "conformal_at_const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem conformal_at_const_smul {c : exprℝ} (h : c ≠ 0) (x : X) : conformal_at (fun x' : X => «expr • » c x') x :=\n  ⟨«expr • » c (continuous_linear_map.id (exprℝ) X), (has_fderiv_at_id x).const_smul c, is_conformal_map_const_smul h⟩\n#align conformal_at_const_smul conformal_at_const_smul\n\n",
 "conformal_at":
 "theorem conformal_at {f : X → Y} (h : conformal f) (x : X) : conformal_at f x :=\n  h x\n#align conformal_at conformal_at\n\n",
 "comp":
 "theorem comp {f : X → Y} {g : Y → Z} (hf : conformal f) (hg : conformal g) : conformal (g ∘ f) := fun x =>\n  (hg <| f x).comp x (hf x)\n#align comp comp\n\n"}