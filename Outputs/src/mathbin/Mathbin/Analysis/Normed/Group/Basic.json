{"zero_lt_one_add_norm_sq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive zero_lt_one_add_norm_sq]\ntheorem zero_lt_one_add_norm_sq' (x : E) : 0 < 1 + «expr‖ ‖» x ^ 2 := by positivity\n#align zero_lt_one_add_norm_sq' zero_lt_one_add_norm_sq'\n\n",
 "uniformity_basis_dist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem normed_comm_group.uniformity_basis_dist :\n    ((uniformity) E).has_basis (fun ε : exprℝ => 0 < ε) fun ε => { p : E × E | «expr‖ ‖» (p.fst / p.snd) < ε } :=\n  by\n  convert metric.uniformity_basis_dist\n  simp [dist_eq_norm_div]\n#align normed_comm_group.uniformity_basis_dist normed_comm_group.uniformity_basis_dist\n\n",
 "uniform_continuous_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem monoid_hom_class.uniform_continuous_of_bound [MonoidHomClass 𝓕 E F] (f : 𝓕) (C : exprℝ)\n    (h : ∀ x, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : uniform_continuous f :=\n  (monoid_hom_class.lipschitz_of_bound f C h).uniform_continuous\n#align monoid_hom_class.uniform_continuous_of_bound monoid_hom_class.uniform_continuous_of_bound\n\n",
 "uniform_continuous_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[to_additive uniform_continuous_norm]\ntheorem uniform_continuous_norm' : uniform_continuous (norm : E → exprℝ) :=\n  lipschitz_with_one_norm'.uniform_continuous\n#align uniform_continuous_norm' uniform_continuous_norm'\n\n",
 "uniform_continuous_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive uniform_continuous_nnnorm]\ntheorem uniform_continuous_nnnorm' : uniform_continuous fun a : E => «expr‖ ‖₊» a :=\n  uniform_continuous_norm'.subtype_mk _\n#align uniform_continuous_nnnorm' uniform_continuous_nnnorm'\n\n",
 "uniform_cauchy_seq_on_iff_tendsto_uniformly_on_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[to_additive]\ntheorem seminormed_group.uniform_cauchy_seq_on_iff_tendsto_uniformly_on_one {f : ι → κ → G} {s : set κ} {l : filter ι} :\n    uniform_cauchy_seq_on f l s ↔\n      tendsto_uniformly_on (fun n : ι × ι => fun z => f n.fst z / f n.snd z) 1 (filter.prod l l) s :=\n  by\n  rw [tendsto_uniformly_on_iff_tendsto_uniformly_on_filter, uniform_cauchy_seq_on_iff_uniform_cauchy_seq_on_filter,\n    seminormed_group.uniform_cauchy_seq_on_filter_iff_tendsto_uniformly_on_filter_one]\n#align\n  seminormed_group.uniform_cauchy_seq_on_iff_tendsto_uniformly_on_one seminormed_group.uniform_cauchy_seq_on_iff_tendsto_uniformly_on_one\n\n",
 "uniform_cauchy_seq_on_filter_iff_tendsto_uniformly_on_filter_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `filter.prod -/\n@[to_additive]\ntheorem seminormed_group.uniform_cauchy_seq_on_filter_iff_tendsto_uniformly_on_filter_one {f : ι → κ → G} {l : filter ι}\n    {l' : filter κ} :\n    uniform_cauchy_seq_on_filter f l l' ↔\n      tendsto_uniformly_on_filter (fun n : ι × ι => fun z => f n.fst z / f n.snd z) 1 (filter.prod l l) l' :=\n  by\n  refine' ⟨fun hf u hu => _, fun hf u hu => _⟩\n  · obtain ⟨ε, hε, H⟩ := uniformity_basis_dist.mem_uniformity_iff.mp hu\n    refine'\n      (hf { p : G × G | dist p.fst p.snd < ε } <| dist_mem_uniformity hε).mono fun x hx =>\n        H 1 (f x.fst.fst x.snd / f x.fst.snd x.snd) _\n    simpa [dist_eq_norm_div, norm_div_rev] using hx\n  · obtain ⟨ε, hε, H⟩ := uniformity_basis_dist.mem_uniformity_iff.mp hu\n    refine'\n      (hf { p : G × G | dist p.fst p.snd < ε } <| dist_mem_uniformity hε).mono fun x hx =>\n        H (f x.fst.fst x.snd) (f x.fst.snd x.snd) _\n    simpa [dist_eq_norm_div, norm_div_rev] using hx\n#align\n  seminormed_group.uniform_cauchy_seq_on_filter_iff_tendsto_uniformly_on_filter_one seminormed_group.uniform_cauchy_seq_on_filter_iff_tendsto_uniformly_on_filter_one\n\n",
 "to_nnreal_eq_nnnorm_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem to_nnreal_eq_nnnorm_of_nonneg (hr : 0 ≤ r) : r.to_nnreal = «expr‖ ‖₊» r :=\n  by\n  rw [real.to_nnreal_of_nonneg hr]\n  congr\n  rw [real.norm_eq_abs, abs_of_nonneg hr]\n#align to_nnreal_eq_nnnorm_of_nonneg to_nnreal_eq_nnnorm_of_nonneg\n\n",
 "tendsto_uniformly_on_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem seminormed_group.tendsto_uniformly_on_one {f : ι → κ → G} {s : set κ} {l : filter ι} :\n    tendsto_uniformly_on f 1 l s ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          (∀ x ∈ s, «expr‖ ‖» (f i x) < ε) :=\n  by simp_rw [tendsto_uniformly_on_iff, pi.one_apply, dist_one_left]\n#align seminormed_group.tendsto_uniformly_on_one seminormed_group.tendsto_uniformly_on_one\n\n",
 "tendsto_one_iff_norm_tendsto_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_one_iff_norm_tendsto_one {f : α → E} {a : filter α} :\n    tendsto f a ((nhds) 1) ↔ tendsto (fun e => «expr‖ ‖» (f e)) a ((nhds) 0) :=\n  by\n  rw [tendsto_iff_norm_tendsto_one]\n  simp only [div_one]\n#align tendsto_one_iff_norm_tendsto_one tendsto_one_iff_norm_tendsto_one\n\n",
 "tendsto_norm_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_norm_one : tendsto (fun a : E => «expr‖ ‖» a) ((nhds) 1) ((nhds) 0) := by\n  simpa using tendsto_norm_div_self (1 : E)\n#align tendsto_norm_one tendsto_norm_one\n\n",
 "tendsto_norm_nhds_within_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[to_additive]\ntheorem tendsto_norm_nhds_within_one : tendsto (norm : E → exprℝ) (nhds_within.ne 1) (nhds_within.gt 0) :=\n  tendsto_norm_one.inf <| tendsto_principal_principal.2 fun x => norm_pos_iff''.2\n#align tendsto_norm_nhds_within_one tendsto_norm_nhds_within_one\n\n",
 "tendsto_norm_div_self_punctured_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n@[to_additive]\ntheorem tendsto_norm_div_self_punctured_nhds (a : E) :\n    tendsto (fun x => «expr‖ ‖» (x / a)) (nhds_within.ne a) (nhds_within.gt 0) :=\n  (tendsto_norm_div_self a).inf <| tendsto_principal_principal.2 fun x hx => norm_pos_iff''.2 <| div_ne_one.2 hx\n#align tendsto_norm_div_self_punctured_nhds tendsto_norm_div_self_punctured_nhds\n\n",
 "tendsto_norm_div_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_norm_div_self (x : E) : tendsto (fun a => «expr‖ ‖» (a / x)) ((nhds) x) ((nhds) 0) := by\n  simpa [dist_eq_norm_div] using tendsto_id.dist (tendsto_const_nhds : tendsto (fun a => (x : E)) ((nhds) x) _)\n#align tendsto_norm_div_self tendsto_norm_div_self\n\n",
 "tendsto_norm_cocompact_at_top'":
 "@[to_additive tendsto_norm_cocompact_at_top]\ntheorem tendsto_norm_cocompact_at_top' [proper_space E] : tendsto norm (cocompact E) at_top := by\n  simpa only [dist_one_right] using tendsto_dist_right_cocompact_at_top (1 : E)\n#align tendsto_norm_cocompact_at_top' tendsto_norm_cocompact_at_top'\n\n",
 "tendsto_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive tendsto_norm]\ntheorem tendsto_norm' {x : E} : tendsto (fun a => «expr‖ ‖» a) ((nhds) x) ((nhds) («expr‖ ‖» x)) := by\n  simpa using tendsto_id.dist (tendsto_const_nhds : tendsto (fun a => (1 : E)) _ _)\n#align tendsto_norm' tendsto_norm'\n\n",
 "tendsto_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem normed_comm_group.tendsto_nhds_one {f : α → E} {l : filter α} :\n    tendsto f l ((nhds) 1) ↔\n      ∀ ε > 0,\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n          («expr‖ ‖» (f x) < ε) :=\n  metric.tendsto_nhds.trans <| by simp only [dist_one_right]\n#align normed_comm_group.tendsto_nhds_one normed_comm_group.tendsto_nhds_one\n\n",
 "tendsto_nhds_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem normed_comm_group.tendsto_nhds_nhds {f : E → F} {x : E} {y : F} :\n    tendsto f ((nhds) x) ((nhds) y) ↔ ∀ ε > 0, ∃ δ > 0, ∀ x', «expr‖ ‖» (x' / x) < δ → «expr‖ ‖» (f x' / y) < ε := by\n  simp_rw [metric.tendsto_nhds_nhds, dist_eq_norm_div]\n#align normed_comm_group.tendsto_nhds_nhds normed_comm_group.tendsto_nhds_nhds\n\n",
 "tendsto_inv_cobounded":
 "/-- In a (semi)normed group, inversion `x ↦ x⁻¹` tends to infinity at infinity. TODO: use\n`bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`. -/\n@[to_additive\n      \"In a (semi)normed group, negation `x ↦ -x` tends to infinity at infinity. TODO: use\\n`bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`.\"]\ntheorem filter.tendsto_inv_cobounded : tendsto (has_inv.inv : E → E) (comap norm at_top) (comap norm at_top) := by\n  simpa only [norm_inv', tendsto_comap_iff, (· ∘ ·)] using tendsto_comap\n#align filter.tendsto_inv_cobounded filter.tendsto_inv_cobounded\n\n",
 "tendsto_iff_norm_tendsto_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem tendsto_iff_norm_tendsto_one {f : α → E} {a : filter α} {b : E} :\n    tendsto f a ((nhds) b) ↔ tendsto (fun e => «expr‖ ‖» (f e / b)) a ((nhds) 0) :=\n  by\n  convert tendsto_iff_dist_tendsto_zero\n  simp [dist_eq_norm_div]\n#align tendsto_iff_norm_tendsto_one tendsto_iff_norm_tendsto_one\n\n",
 "sum_norm_apply_le_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\n@[to_additive pi.sum_norm_apply_le_norm \"The $L^1$ norm is less than the $L^\\\\infty$ norm scaled by\\nthe cardinality.\"]\ntheorem pi.sum_norm_apply_le_norm' :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr‖ ‖» (f i)) ≤\n      «expr • » (fintype.card ι) («expr‖ ‖» f) :=\n  finset.sum_le_card_nsmul _ _ _ fun i hi => norm_le_pi_norm' _ i\n#align pi.sum_norm_apply_le_norm' pi.sum_norm_apply_le_norm'\n\n",
 "sum_nnnorm_apply_le_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/-- The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. -/\n@[to_additive pi.sum_nnnorm_apply_le_nnnorm\n      \"The $L^1$ norm is less than the $L^\\\\infty$ norm scaled\\nby the cardinality.\"]\ntheorem pi.sum_nnnorm_apply_le_nnnorm' :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr‖ ‖₊» (f i)) ≤\n      «expr • » (fintype.card ι) («expr‖ ‖₊» f) :=\n  nnreal.coe_sum.trans_le <| pi.sum_norm_apply_le_norm' _\n#align pi.sum_nnnorm_apply_le_nnnorm' pi.sum_nnnorm_apply_le_nnnorm'\n\n",
 "squeeze_one_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `1`. In this pair of lemmas (`squeeze_one_norm'`\nand `squeeze_one_norm`), following a convention of similar lemmas in `topology.metric_space.basic`\nand `topology.algebra.order`, the `'` version is phrased using \"eventually\" and the non-`'` version\nis phrased absolutely. -/\n@[to_additive\n      \"Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a\\nreal function `a` which tends to `0`, then `f` tends to `1`. In this pair of lemmas\\n(`squeeze_zero_norm'` and `squeeze_zero_norm`), following a convention of similar lemmas in\\n`topology.metric_space.basic` and `topology.algebra.order`, the `'` version is phrased using\\n\\\"eventually\\\" and the non-`'` version is phrased absolutely.\"]\ntheorem squeeze_one_norm' {f : α → E} {a : α → exprℝ} {t₀ : filter α}\n    (h :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" t₀\n        («expr‖ ‖» (f n) ≤ a n))\n    (h' : tendsto a t₀ ((nhds) 0)) : tendsto f t₀ ((nhds) 1) :=\n  tendsto_one_iff_norm_tendsto_one.2 <| squeeze_zero' (eventually_of_forall fun n => norm_nonneg' _) h h'\n#align squeeze_one_norm' squeeze_one_norm'\n\n",
 "squeeze_one_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. -/\n@[to_additive\n      \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\\nfunction `a` which tends to `0`, then `f` tends to `0`.\"]\ntheorem squeeze_one_norm {f : α → E} {a : α → exprℝ} {t₀ : filter α} (h : ∀ n, «expr‖ ‖» (f n) ≤ a n) :\n    tendsto a t₀ ((nhds) 0) → tendsto f t₀ ((nhds) 1) :=\n  squeeze_one_norm' <| eventually_of_forall h\n#align squeeze_one_norm squeeze_one_norm\n\n",
 "smul_closed_ball''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_closed_ball'' : «expr • » a (closed_ball b r) = closed_ball («expr • » a b) r :=\n  by\n  ext\n  simp [mem_closed_ball, Set.mem_smul_set, dist_eq_norm_div, div_eq_inv_mul, ← eq_inv_mul_iff_mul_eq, mul_assoc]\n#align smul_closed_ball'' smul_closed_ball''\n\n",
 "smul_ball''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_ball'' : «expr • » a (ball b r) = ball («expr • » a b) r :=\n  by\n  ext\n  simp [mem_ball, Set.mem_smul_set, dist_eq_norm_div, div_eq_inv_mul, ← eq_inv_mul_iff_mul_eq, mul_assoc]\n#align smul_ball'' smul_ball''\n\n",
 "preimage_mul_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, to_additive]\ntheorem preimage_mul_sphere (a b : E) (r : exprℝ) : «expr ⁻¹' » ((· * ·) b) (sphere a r) = sphere (a / b) r :=\n  by\n  ext c\n  simp only [Set.mem_preimage, mem_sphere_iff_norm', div_div_eq_mul_div, mul_comm]\n#align preimage_mul_sphere preimage_mul_sphere\n\n",
 "preimage_mul_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, to_additive]\ntheorem preimage_mul_closed_ball (a b : E) (r : exprℝ) :\n    «expr ⁻¹' » ((· * ·) b) (closed_ball a r) = closed_ball (a / b) r :=\n  by\n  ext c\n  simp only [dist_eq_norm_div, Set.mem_preimage, mem_closed_ball, div_div_eq_mul_div, mul_comm]\n#align preimage_mul_closed_ball preimage_mul_closed_ball\n\n",
 "preimage_mul_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, to_additive]\ntheorem preimage_mul_ball (a b : E) (r : exprℝ) : «expr ⁻¹' » ((· * ·) b) (ball a r) = ball (a / b) r :=\n  by\n  ext c\n  simp only [dist_eq_norm_div, Set.mem_preimage, mem_ball, div_div_eq_mul_div, mul_comm]\n#align preimage_mul_ball preimage_mul_ball\n\n",
 "pow_mem_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem pow_mem_closed_ball {n : ℕ} (h : a ∈ closed_ball b r) : a ^ n ∈ closed_ball (b ^ n) («expr • » n r) :=\n  by\n  simp only [mem_closed_ball, dist_eq_norm_div, ← div_pow] at h⊢\n  refine' (norm_pow_le_mul_norm n (a / b)).trans _\n  simpa only [nsmul_eq_mul] using mul_le_mul_of_nonneg_left h n.cast_nonneg\n#align pow_mem_closed_ball pow_mem_closed_ball\n\n",
 "pow_mem_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem pow_mem_ball {n : ℕ} (hn : 0 < n) (h : a ∈ ball b r) : a ^ n ∈ ball (b ^ n) («expr • » n r) :=\n  by\n  simp only [mem_ball, dist_eq_norm_div, ← div_pow] at h⊢\n  refine' lt_of_le_of_lt (norm_pow_le_mul_norm n (a / b)) _\n  replace hn : 0 < (n : exprℝ);\n  · norm_cast\n    assumption\n  rw [nsmul_eq_mul]\n  nlinarith\n#align pow_mem_ball pow_mem_ball\n\n",
 "pi_norm_lt_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The seminorm of an element in a product space is `< r` if and only if the norm of each\ncomponent is. -/\n@[to_additive pi_norm_lt_iff\n      \"The seminorm of an element in a product space is `< r` if and only if\\nthe norm of each component is.\"]\ntheorem pi_norm_lt_iff' (hr : 0 < r) : «expr‖ ‖» x < r ↔ ∀ i, «expr‖ ‖» (x i) < r := by\n  simp only [← dist_one_right, dist_pi_lt_iff hr, pi.one_apply]\n#align pi_norm_lt_iff' pi_norm_lt_iff'\n\n",
 "pi_norm_le_iff_of_nonneg'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The seminorm of an element in a product space is `≤ r` if and only if the norm of each\ncomponent is. -/\n@[to_additive pi_norm_le_iff_of_nonneg\n      \"The seminorm of an element in a product space is `≤ r` if\\nand only if the norm of each component is.\"]\ntheorem pi_norm_le_iff_of_nonneg' (hr : 0 ≤ r) : «expr‖ ‖» x ≤ r ↔ ∀ i, «expr‖ ‖» (x i) ≤ r := by\n  simp only [← dist_one_right, dist_pi_le_iff hr, pi.one_apply]\n#align pi_norm_le_iff_of_nonneg' pi_norm_le_iff_of_nonneg'\n\n",
 "pi_norm_le_iff_of_nonempty'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive pi_norm_le_iff_of_nonempty]\ntheorem pi_norm_le_iff_of_nonempty' [nonempty ι] : «expr‖ ‖» f ≤ r ↔ ∀ b, «expr‖ ‖» (f b) ≤ r :=\n  by\n  by_cases hr : 0 ≤ r\n  · exact pi_norm_le_iff_of_nonneg' hr\n  ·\n    exact\n      iff_of_false (fun h => hr <| (norm_nonneg' _).trans h) fun h =>\n        hr <| (norm_nonneg' _).trans <| h <| classical.arbitrary _\n#align pi_norm_le_iff_of_nonempty' pi_norm_le_iff_of_nonempty'\n\n",
 "pi_norm_const_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive pi_norm_const_le]\ntheorem pi_norm_const_le' (a : E) : («expr‖ ‖» fun _ : ι => a) ≤ «expr‖ ‖» a :=\n  (pi_norm_le_iff_of_nonneg' <| norm_nonneg' _).2 fun _ => le_rfl\n#align pi_norm_const_le' pi_norm_const_le'\n\n",
 "pi_norm_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive pi_norm_const]\ntheorem pi_norm_const' [nonempty ι] (a : E) : («expr‖ ‖» fun i : ι => a) = «expr‖ ‖» a := by\n  simpa only [← dist_one_right] using dist_pi_const a 1\n#align pi_norm_const' pi_norm_const'\n\n",
 "pi_nnnorm_lt_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive pi_nnnorm_lt_iff]\ntheorem pi_nnnorm_lt_iff' {r : nnreal} (hr : 0 < r) : «expr‖ ‖₊» x < r ↔ ∀ i, «expr‖ ‖₊» (x i) < r :=\n  pi_norm_lt_iff' hr\n#align pi_nnnorm_lt_iff' pi_nnnorm_lt_iff'\n\n",
 "pi_nnnorm_le_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive pi_nnnorm_le_iff]\ntheorem pi_nnnorm_le_iff' {r : nnreal} : «expr‖ ‖₊» x ≤ r ↔ ∀ i, «expr‖ ‖₊» (x i) ≤ r :=\n  pi_norm_le_iff_of_nonneg' r.coe_nonneg\n#align pi_nnnorm_le_iff' pi_nnnorm_le_iff'\n\n",
 "pi_nnnorm_const_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive pi_nnnorm_const_le]\ntheorem pi_nnnorm_const_le' (a : E) : («expr‖ ‖₊» fun _ : ι => a) ≤ «expr‖ ‖₊» a :=\n  pi_norm_const_le' _\n#align pi_nnnorm_const_le' pi_nnnorm_const_le'\n\n",
 "pi_nnnorm_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp, to_additive pi_nnnorm_const]\ntheorem pi_nnnorm_const' [nonempty ι] (a : E) : («expr‖ ‖₊» fun i : ι => a) = «expr‖ ‖₊» a :=\n  nnreal.eq <| pi_norm_const' a\n#align pi_nnnorm_const' pi_nnnorm_const'\n\n",
 "op_one_is_bounded_under_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E → F → G` with an estimate `‖op x y‖ ≤ A * ‖x‖ * ‖y‖` for some constant A instead of\nmultiplication so that it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`. -/\n@[to_additive\n      \"A helper lemma used to prove that the (scalar or usual) product of a function that\\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\\noperation `op : E → F → G` with an estimate `‖op x y‖ ≤ A * ‖x‖ * ‖y‖` for some constant A instead\\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`.\"]\ntheorem filter.tendsto.op_one_is_bounded_under_le' {f : α → E} {g : α → F} {l : filter α} (hf : tendsto f l ((nhds) 1))\n    (hg : is_bounded_under (· ≤ ·) l (norm ∘ g)) (op : E → F → G)\n    (h_op : ∃ A, ∀ x y, «expr‖ ‖» (op x y) ≤ A * «expr‖ ‖» x * «expr‖ ‖» y) :\n    tendsto (fun x => op (f x) (g x)) l ((nhds) 1) :=\n  by\n  cases' h_op with A h_op\n  rcases hg with ⟨C, hC⟩; rw [eventually_map] at hC\n  rw [normed_comm_group.tendsto_nhds_one] at hf⊢\n  intro ε ε₀\n  rcases exists_pos_mul_lt ε₀ (A * C) with ⟨δ, δ₀, hδ⟩\n  filter_upwards [hf δ δ₀, hC] with i hf hg\n  refine' (h_op _ _).trans_lt _\n  cases' le_total A 0 with hA hA\n  ·\n    exact\n      (mul_nonpos_of_nonpos_of_nonneg (mul_nonpos_of_nonpos_of_nonneg hA <| norm_nonneg' _) <| norm_nonneg' _).trans_lt\n        ε₀\n  calc\n    A * «expr‖ ‖» (f i) * «expr‖ ‖» (g i) ≤ A * δ * C :=\n      mul_le_mul (mul_le_mul_of_nonneg_left hf.le hA) hg (norm_nonneg' _) (mul_nonneg hA δ₀.le)\n    _ = A * C * δ := mul_right_comm _ _ _\n    _ < ε := hδ\n    \n#align filter.tendsto.op_one_is_bounded_under_le' filter.tendsto.op_one_is_bounded_under_le'\n\n",
 "op_one_is_bounded_under_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E → F → G` with an estimate `‖op x y‖ ≤ ‖x‖ * ‖y‖` instead of multiplication so that it\ncan be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`. -/\n@[to_additive\n      \"A helper lemma used to prove that the (scalar or usual) product of a function that\\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\\noperation `op : E → F → G` with an estimate `‖op x y‖ ≤ ‖x‖ * ‖y‖` instead of multiplication so that\\nit can be applied to `(*)`, `flip (*)`, `(•)`, and `flip (•)`.\"]\ntheorem filter.tendsto.op_one_is_bounded_under_le {f : α → E} {g : α → F} {l : filter α} (hf : tendsto f l ((nhds) 1))\n    (hg : is_bounded_under (· ≤ ·) l (norm ∘ g)) (op : E → F → G)\n    (h_op : ∀ x y, «expr‖ ‖» (op x y) ≤ «expr‖ ‖» x * «expr‖ ‖» y) : tendsto (fun x => op (f x) (g x)) l ((nhds) 1) :=\n  hf.op_one_is_bounded_under_le' hg op ⟨1, fun x y => (one_mul («expr‖ ‖» x)).symm ▸ h_op x y⟩\n#align filter.tendsto.op_one_is_bounded_under_le filter.tendsto.op_one_is_bounded_under_le\n\n",
 "of_real_norm_eq_coe_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive of_real_norm_eq_coe_nnnorm]\ntheorem of_real_norm_eq_coe_nnnorm' (a : E) : ennreal.of_real («expr‖ ‖» a) = «expr‖ ‖₊» a :=\n  ennreal.of_real_eq_coe_nnreal _\n#align of_real_norm_eq_coe_nnnorm' of_real_norm_eq_coe_nnnorm'\n\n",
 "of_real_le_ennnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem of_real_le_ennnorm (r : exprℝ) : ennreal.of_real r ≤ «expr‖ ‖₊» r :=\n  by\n  obtain hr | hr := le_total 0 r\n  · exact (real.ennnorm_eq_of_real hr).ge\n  · rw [ennreal.of_real_eq_zero.2 hr]\n    exact bot_le\n#align of_real_le_ennnorm of_real_le_ennnorm\n\n",
 "norm_zpow_le_mul_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n-- Now that we've installed the norm on `ℤ`,\n-- we can state some lemmas about `zsmul`.\n@[to_additive norm_zsmul_le]\ntheorem norm_zpow_le_mul_norm (n : ℤ) (a : α) : «expr‖ ‖» (a ^ n) ≤ «expr‖ ‖» n * «expr‖ ‖» a := by\n  rcases n.eq_coe_or_neg with ⟨n, rfl | rfl⟩ <;> simpa using norm_pow_le_mul_norm n a\n#align norm_zpow_le_mul_norm norm_zpow_le_mul_norm\n\n",
 "norm_up":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_up (x : E) : «expr‖ ‖» (ulift.up x) = «expr‖ ‖» x :=\n  rfl\n#align norm_up norm_up\n\n",
 "norm_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem norm_two : «expr‖ ‖» (2 : exprℝ) = 2 :=\n  abs_of_pos zero_lt_two\n#align norm_two norm_two\n\n",
 "norm_to_nnreal'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive norm_to_nnreal]\ntheorem norm_to_nnreal' : («expr‖ ‖» a).to_nnreal = «expr‖ ‖₊» a :=\n  @real.to_nnreal_coe («expr‖ ‖₊» a)\n#align norm_to_nnreal' norm_to_nnreal'\n\n",
 "norm_to_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_to_mul (x) : «expr‖ ‖» (toMul x : E) = «expr‖ ‖» x :=\n  rfl\n#align norm_to_mul norm_to_mul\n\n",
 "norm_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_to_dual (x : E) : «expr‖ ‖» (toDual x) = «expr‖ ‖» x :=\n  rfl\n#align norm_to_dual norm_to_dual\n\n",
 "norm_to_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_to_add (x) : «expr‖ ‖» (toAdd x : E) = «expr‖ ‖» x :=\n  rfl\n#align norm_to_add norm_to_add\n\n",
 "norm_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_sum_le {E} [seminormed_add_comm_group E] (s : Finset ι) (f : ι → E) :\n    «expr‖ ‖»\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        («expr‖ ‖» (f i)) :=\n  s.le_sum_of_subadditive norm norm_zero norm_add_le f\n#align norm_sum_le norm_sum_le\n\n",
 "norm_sub_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_sub_norm_le]\ntheorem norm_sub_norm_le' (a b : E) : «expr‖ ‖» a - «expr‖ ‖» b ≤ «expr‖ ‖» (a / b) :=\n  (le_abs_self _).trans (abs_norm_sub_norm_le' a b)\n#align norm_sub_norm_le' norm_sub_norm_le'\n\n",
 "norm_snd_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_snd_le (x : E × F) : «expr‖ ‖» x.2 ≤ «expr‖ ‖» x :=\n  le_max_right _ _\n#align norm_snd_le norm_snd_le\n\n",
 "norm_prod_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[to_additive]\ntheorem norm_prod_le_of_le (s : Finset ι) {f : ι → E} {n : ι → exprℝ} (h : ∀ b ∈ s, «expr‖ ‖» (f b) ≤ n b) :\n    «expr‖ ‖»\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (n b) :=\n  (norm_prod_le s f).trans <| finset.sum_le_sum h\n#align norm_prod_le_of_le norm_prod_le_of_le\n\n",
 "norm_prod_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_prod_le_iff : «expr‖ ‖» x ≤ r ↔ «expr‖ ‖» x.1 ≤ r ∧ «expr‖ ‖» x.2 ≤ r :=\n  max_le_iff\n#align norm_prod_le_iff norm_prod_le_iff\n\n",
 "norm_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_prod_le (s : Finset ι) (f : ι → E) :\n    «expr‖ ‖»\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        («expr‖ ‖» (f i)) :=\n  by\n  rw [← Multiplicative.ofAdd_le, of_add_sum]\n  refine' finset.le_prod_of_submultiplicative (Multiplicative.ofAdd ∘ norm) _ (fun x y => _) _ _\n  · simp only [comp_app, norm_one', ofAdd_zero]\n  · exact norm_mul_le' _ _\n#align norm_prod_le norm_prod_le\n\n",
 "norm_pow_le_mul_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_nsmul_le]\ntheorem norm_pow_le_mul_norm (n : ℕ) (a : E) : «expr‖ ‖» (a ^ n) ≤ n * «expr‖ ‖» a :=\n  by\n  induction' n with n ih; · simp\n  simpa only [pow_succ', Nat.cast_succ, add_mul, one_mul] using norm_mul_le_of_le ih le_rfl\n#align norm_pow_le_mul_norm norm_pow_le_mul_norm\n\n",
 "norm_pos_iff'''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_pos_iff']\ntheorem norm_pos_iff''' [t0_space E] {a : E} : 0 < «expr‖ ‖» a ↔ a ≠ 1 := by rw [← not_le, norm_le_zero_iff''']\n#align norm_pos_iff''' norm_pos_iff'''\n\n",
 "norm_pos_iff''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_pos_iff]\ntheorem norm_pos_iff'' : 0 < «expr‖ ‖» a ↔ a ≠ 1 :=\n  norm_pos_iff'''\n#align norm_pos_iff'' norm_pos_iff''\n\n",
 "norm_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_zero]\ntheorem norm_one' : «expr‖ ‖» (1 : E) = 0 := by rw [← dist_one_right, dist_self]\n#align norm_one' norm_one'\n\n",
 "norm_of_subsingleton'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[nontriviality, to_additive norm_of_subsingleton]\ntheorem norm_of_subsingleton' [subsingleton E] (a : E) : «expr‖ ‖» a = 0 := by rw [subsingleton.elim a 1, norm_one']\n#align norm_of_subsingleton' norm_of_subsingleton'\n\n",
 "norm_of_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_of_nonpos (hr : r ≤ 0) : «expr‖ ‖» r = -r :=\n  abs_of_nonpos hr\n#align norm_of_nonpos norm_of_nonpos\n\n",
 "norm_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_of_nonneg (hr : 0 ≤ r) : «expr‖ ‖» r = r :=\n  abs_of_nonneg hr\n#align norm_of_nonneg norm_of_nonneg\n\n",
 "norm_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_of_mul (x : E) : «expr‖ ‖» (ofMul x) = «expr‖ ‖» x :=\n  rfl\n#align norm_of_mul norm_of_mul\n\n",
 "norm_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_of_dual (x : «expr ᵒᵈ» E) : «expr‖ ‖» (ofDual x) = «expr‖ ‖» x :=\n  rfl\n#align norm_of_dual norm_of_dual\n\n",
 "norm_of_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_of_add (x : E) : «expr‖ ‖» (ofAdd x) = «expr‖ ‖» x :=\n  rfl\n#align norm_of_add norm_of_add\n\n",
 "norm_nonneg'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_nonneg]\ntheorem norm_nonneg' (a : E) : 0 ≤ «expr‖ ‖» a :=\n  by\n  rw [← dist_one_right]\n  exact dist_nonneg\n#align norm_nonneg' norm_nonneg'\n\n",
 "norm_ne_zero_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_ne_zero_iff]\ntheorem norm_ne_zero_iff' : «expr‖ ‖» a ≠ 0 ↔ a ≠ 1 :=\n  norm_eq_zero''.not\n#align norm_ne_zero_iff' norm_ne_zero_iff'\n\n",
 "norm_mul₃_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_add₃_le]\ntheorem norm_mul₃_le (a b c : E) : «expr‖ ‖» (a * b * c) ≤ «expr‖ ‖» a + «expr‖ ‖» b + «expr‖ ‖» c :=\n  norm_mul_le_of_le (norm_mul_le' _ _) le_rfl\n#align norm_mul₃_le norm_mul₃_le\n\n",
 "norm_multiset_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_multiset_sum_le {E} [seminormed_add_comm_group E] (m : Multiset E) :\n    «expr‖ ‖» m.sum ≤ (m.map fun x => «expr‖ ‖» x).sum :=\n  m.le_sum_of_subadditive norm norm_zero norm_add_le\n#align norm_multiset_sum_le norm_multiset_sum_le\n\n",
 "norm_multiset_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_multiset_prod_le (m : Multiset E) : «expr‖ ‖» m.prod ≤ (m.map fun x => «expr‖ ‖» x).sum :=\n  by\n  rw [← Multiplicative.ofAdd_le, of_add_multiset_prod, Multiset.map_map]\n  refine' Multiset.le_prod_of_submultiplicative (Multiplicative.ofAdd ∘ norm) _ (fun x y => _) _\n  · simp only [comp_app, norm_one', ofAdd_zero]\n  · exact norm_mul_le' _ _\n#align norm_multiset_prod_le norm_multiset_prod_le\n\n",
 "norm_mul_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_mul_le_of_le (h₁ : «expr‖ ‖» a₁ ≤ r₁) (h₂ : «expr‖ ‖» a₂ ≤ r₂) : «expr‖ ‖» (a₁ * a₂) ≤ r₁ + r₂ :=\n  (norm_mul_le' a₁ a₂).trans <| add_le_add h₁ h₂\n#align norm_mul_le_of_le norm_mul_le_of_le\n\n",
 "norm_mul_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- **Triangle inequality** for the norm. -/\n@[to_additive norm_add_le \"**Triangle inequality** for the norm.\"]\ntheorem norm_mul_le' (a b : E) : «expr‖ ‖» (a * b) ≤ «expr‖ ‖» a + «expr‖ ‖» b := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b⁻¹\n#align norm_mul_le' norm_mul_le'\n\n",
 "norm_map_of_map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem isometry.norm_map_of_map_one {f : E → F} (hi : isometry f) (h₁ : f 1 = 1) (x : E) :\n    «expr‖ ‖» (f x) = «expr‖ ‖» x := by rw [← dist_one_right, ← h₁, hi.dist_eq, dist_one_right]\n#align isometry.norm_map_of_map_one isometry.norm_map_of_map_one\n\n",
 "norm_lt_of_mem_ball'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_lt_of_mem_ball]\ntheorem norm_lt_of_mem_ball' (h : b ∈ ball a r) : «expr‖ ‖» b < «expr‖ ‖» a + r :=\n  (norm_le_norm_add_norm_div' _ _).trans_lt <| add_lt_add_left (by rwa [← dist_eq_norm_div]) _\n#align norm_lt_of_mem_ball' norm_lt_of_mem_ball'\n\n",
 "norm_le_zero_iff'''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_le_zero_iff']\ntheorem norm_le_zero_iff''' [t0_space E] {a : E} : «expr‖ ‖» a ≤ 0 ↔ a = 1 :=\n  by\n  letI : normed_group E := { ‹seminormed_group E› with to_metric_space := metric.of_t0_pseudo_metric_space E }\n  rw [← dist_one_right, dist_le_zero]\n#align norm_le_zero_iff''' norm_le_zero_iff'''\n\n",
 "norm_le_zero_iff''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_le_zero_iff]\ntheorem norm_le_zero_iff'' : «expr‖ ‖» a ≤ 0 ↔ a = 1 :=\n  norm_le_zero_iff'''\n#align norm_le_zero_iff'' norm_le_zero_iff''\n\n",
 "norm_le_pi_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_le_pi_norm]\ntheorem norm_le_pi_norm' (i : ι) : «expr‖ ‖» (f i) ≤ «expr‖ ‖» f :=\n  (pi_norm_le_iff_of_nonneg' <| norm_nonneg' _).1 le_rfl i\n#align norm_le_pi_norm' norm_le_pi_norm'\n\n",
 "norm_le_of_mem_closed_ball'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_le_of_mem_closed_ball]\ntheorem norm_le_of_mem_closed_ball' (h : b ∈ closed_ball a r) : «expr‖ ‖» b ≤ «expr‖ ‖» a + r :=\n  (norm_le_norm_add_norm_div' _ _).trans <| add_le_add_left (by rwa [← dist_eq_norm_div]) _\n#align norm_le_of_mem_closed_ball' norm_le_of_mem_closed_ball'\n\n",
 "norm_le_norm_add_norm_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_le_norm_add_norm_div' (u v : E) : «expr‖ ‖» u ≤ «expr‖ ‖» v + «expr‖ ‖» (u / v) :=\n  by\n  rw [add_comm]\n  refine' (norm_mul_le' _ _).trans_eq' _\n  rw [div_mul_cancel']\n#align norm_le_norm_add_norm_div' norm_le_norm_add_norm_div'\n\n",
 "norm_le_norm_add_norm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_le_norm_add_norm_div (u v : E) : «expr‖ ‖» v ≤ «expr‖ ‖» u + «expr‖ ‖» (u / v) :=\n  by\n  rw [norm_div_rev]\n  exact norm_le_norm_add_norm_div' v u\n#align norm_le_norm_add_norm_div norm_le_norm_add_norm_div\n\n",
 "norm_le_norm_add_const_of_dist_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_le_norm_add_const_of_dist_le]\ntheorem norm_le_norm_add_const_of_dist_le' : dist a b ≤ r → «expr‖ ‖» a ≤ «expr‖ ‖» b + r :=\n  norm_le_of_mem_closed_ball'\n#align norm_le_norm_add_const_of_dist_le' norm_le_norm_add_const_of_dist_le'\n\n",
 "norm_le_mul_norm_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_le_mul_norm_add (u v : E) : «expr‖ ‖» u ≤ «expr‖ ‖» (u * v) + «expr‖ ‖» v :=\n  calc\n    «expr‖ ‖» u = «expr‖ ‖» (u * v / v) := by rw [mul_div_cancel'']\n    _ ≤ «expr‖ ‖» (u * v) + «expr‖ ‖» v := norm_div_le _ _\n    \n#align norm_le_mul_norm_add norm_le_mul_norm_add\n\n",
 "norm_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_neg]\ntheorem norm_inv' (a : E) : «expr‖ ‖» a⁻¹ = «expr‖ ‖» a := by simpa using norm_div_rev 1 a\n#align norm_inv' norm_inv'\n\n",
 "norm_fst_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_fst_le (x : E × F) : «expr‖ ‖» x.1 ≤ «expr‖ ‖» x :=\n  le_max_left _ _\n#align norm_fst_le norm_fst_le\n\n",
 "norm_eq_zero'''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive norm_eq_zero']\ntheorem norm_eq_zero''' [t0_space E] {a : E} : «expr‖ ‖» a = 0 ↔ a = 1 :=\n  (norm_nonneg' a).le_iff_eq.symm.trans norm_le_zero_iff'''\n#align norm_eq_zero''' norm_eq_zero'''\n\n",
 "norm_eq_zero''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_eq_zero]\ntheorem norm_eq_zero'' : «expr‖ ‖» a = 0 ↔ a = 1 :=\n  norm_eq_zero'''\n#align norm_eq_zero'' norm_eq_zero''\n\n",
 "norm_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2018 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Johannes Hölzl, Yaël Dillies\n-/\n-- See note [lower instance priority]\n-- See note [lower instance priority]\n-- See note [lower instance priority]\n-- See note [lower instance priority]\n-- See note [reducible non-instances]\n-- See note [reducible non-instances]\n@[simp]\ntheorem punit.norm_eq_zero (r : PUnit) : «expr‖ ‖» r = 0 :=\n  rfl\n#align punit.norm_eq_zero punit.norm_eq_zero\n\n",
 "norm_eq_of_mem_sphere'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive norm_eq_of_mem_sphere]\ntheorem norm_eq_of_mem_sphere' (x : sphere (1 : E) r) : «expr‖ ‖» (x : E) = r :=\n  mem_sphere_one_iff_norm.mp x.2\n#align norm_eq_of_mem_sphere' norm_eq_of_mem_sphere'\n\n",
 "norm_eq_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_eq_abs (n : ℤ) : «expr‖ ‖» n = |n| :=\n  rfl\n#align norm_eq_abs norm_eq_abs\n\n",
 "norm_down":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_down (x : ULift E) : «expr‖ ‖» x.down = «expr‖ ‖» x :=\n  rfl\n#align norm_down norm_down\n\n",
 "norm_div_sub_norm_div_le_norm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_div_sub_norm_div_le_norm_div (u v w : E) : «expr‖ ‖» (u / w) - «expr‖ ‖» (v / w) ≤ «expr‖ ‖» (u / v) := by\n  simpa only [div_div_div_cancel_right'] using norm_sub_norm_le' (u / w) (v / w)\n#align norm_div_sub_norm_div_le_norm_div norm_div_sub_norm_div_le_norm_div\n\n",
 "norm_div_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_div_rev (a b : E) : «expr‖ ‖» (a / b) = «expr‖ ‖» (b / a) := by\n  simpa only [dist_eq_norm_div] using dist_comm a b\n#align norm_div_rev norm_div_rev\n\n",
 "norm_div_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_div_pos_iff : 0 < «expr‖ ‖» (a / b) ↔ a ≠ b :=\n  by\n  rw [(norm_nonneg' _).lt_iff_ne, ne_comm]\n  exact norm_div_eq_zero_iff.not\n#align norm_div_pos_iff norm_div_pos_iff\n\n",
 "norm_div_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem lipschitz_with.norm_div_le_of_le {f : E → F} {C : nnreal} (h : lipschitz_with C f)\n    (hr : «expr‖ ‖» (a / b) ≤ r) : «expr‖ ‖» (f a / f b) ≤ C * r :=\n  (h.norm_div_le _ _).trans <| mul_le_mul_of_nonneg_left hr C.2\n#align lipschitz_with.norm_div_le_of_le lipschitz_with.norm_div_le_of_le\n\n",
 "norm_div_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_div_le (a b : E) : «expr‖ ‖» (a / b) ≤ «expr‖ ‖» a + «expr‖ ‖» b := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b\n#align norm_div_le norm_div_le\n\n",
 "norm_div_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem norm_div_eq_zero_iff : «expr‖ ‖» (a / b) = 0 ↔ a = b := by rw [norm_eq_zero'', div_eq_one]\n#align norm_div_eq_zero_iff norm_div_eq_zero_iff\n\n",
 "norm_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive pi.norm_def]\ntheorem pi.norm_def' : «expr‖ ‖» f = ↑(finset.univ.sup fun b => «expr‖ ‖₊» (f b)) :=\n  rfl\n#align pi.norm_def' pi.norm_def'\n\n",
 "norm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n-- See note [lower instance priority]\n-- See note [lower instance priority]\n-- See note [lower instance priority]\n-- See note [lower instance priority]\ntheorem prod.norm_def (x : E × F) : «expr‖ ‖» x = max («expr‖ ‖» x.1) («expr‖ ‖» x.2) :=\n  rfl\n#align prod.norm_def prod.norm_def\n\n",
 "norm_coe_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_coe_nat (n : ℕ) : «expr‖ ‖» (n : ℤ) = n := by simp [int.norm_eq_abs]\n#align norm_coe_nat norm_coe_nat\n\n",
 "norm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n-- See note [implicit instance arguments].\n/-- If `x` is an element of a submodule `s` of a normed group `E`, its norm in `E` is equal to its\nnorm in `s`.\n\nThis is a reversed version of the `simp` lemma `submodule.coe_norm` for use by `norm_cast`. -/\n@[norm_cast]\ntheorem norm_coe {_ : Ring 𝕜} [seminormed_add_comm_group E] {_ : Module 𝕜 E} {s : submodule 𝕜 E} (x : s) :\n    «expr‖ ‖» (x : E) = «expr‖ ‖» x :=\n  rfl\n#align norm_coe norm_coe\n\n",
 "norm_cast_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[norm_cast, simp]\ntheorem norm_cast_real (r : exprℚ) : «expr‖ ‖» (r : exprℝ) = «expr‖ ‖» r :=\n  rfl\n#align norm_cast_real norm_cast_real\n\n",
 "norm_cast_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[norm_cast, simp]\ntheorem _root_.int.norm_cast_rat (m : ℤ) : «expr‖ ‖» (m : exprℚ) = «expr‖ ‖» m := by\n  rw [← rat.norm_cast_real, ← int.norm_cast_real] <;> congr 1 <;> norm_cast\n#align int.norm_cast_rat int.norm_cast_rat\n\n",
 "norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive continuous_on.norm]\ntheorem continuous_on.norm' {s : set α} (h : continuous_on f s) : continuous_on (fun x => «expr‖ ‖» (f x)) s :=\n  fun x hx => (h x hx).norm'\n#align continuous_on.norm' continuous_on.norm'\n\n",
 "nnorm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive prod.nnnorm_def']\ntheorem prod.nnorm_def (x : E × F) : «expr‖ ‖₊» x = max («expr‖ ‖₊» x.1) («expr‖ ‖₊» x.2) :=\n  rfl\n#align prod.nnorm_def prod.nnorm_def\n\n",
 "nnnorm_zpow_le_mul_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive nnnorm_zsmul_le]\ntheorem nnnorm_zpow_le_mul_norm (n : ℤ) (a : α) : «expr‖ ‖₊» (a ^ n) ≤ «expr‖ ‖₊» n * «expr‖ ‖₊» a := by\n  simpa only [← nnreal.coe_le_coe, nnreal.coe_mul] using norm_zpow_le_mul_norm n a\n#align nnnorm_zpow_le_mul_norm nnnorm_zpow_le_mul_norm\n\n",
 "nnnorm_up":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_up (x : E) : «expr‖ ‖₊» (ulift.up x) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_up nnnorm_up\n\n",
 "nnnorm_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem nnnorm_two : «expr‖ ‖₊» (2 : exprℝ) = 2 :=\n  nnreal.eq <| by simp\n#align nnnorm_two nnnorm_two\n\n",
 "nnnorm_to_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_to_mul (x) : «expr‖ ‖₊» (toMul x : E) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_to_mul nnnorm_to_mul\n\n",
 "nnnorm_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_to_dual (x : E) : «expr‖ ‖₊» (toDual x) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_to_dual nnnorm_to_dual\n\n",
 "nnnorm_to_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_to_add (x) : «expr‖ ‖₊» (toAdd x : E) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_to_add nnnorm_to_add\n\n",
 "nnnorm_prod_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[to_additive]\ntheorem nnnorm_prod_le_of_le (s : Finset ι) {f : ι → E} {n : ι → nnreal} (h : ∀ b ∈ s, «expr‖ ‖₊» (f b) ≤ n b) :\n    «expr‖ ‖₊»\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (n b) :=\n  (norm_prod_le_of_le s h).trans_eq nnreal.coe_sum.symm\n#align nnnorm_prod_le_of_le nnnorm_prod_le_of_le\n\n",
 "nnnorm_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nnnorm_prod_le (s : Finset ι) (f : ι → E) :\n    «expr‖ ‖₊»\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f a)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        («expr‖ ‖₊» (f a)) :=\n  nnreal.coe_le_coe.1 <| by\n    push_cast\n    exact norm_prod_le _ _\n#align nnnorm_prod_le nnnorm_prod_le\n\n",
 "nnnorm_pow_le_mul_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive nnnorm_nsmul_le]\ntheorem nnnorm_pow_le_mul_norm (n : ℕ) (a : E) : «expr‖ ‖₊» (a ^ n) ≤ n * «expr‖ ‖₊» a := by\n  simpa only [← nnreal.coe_le_coe, nnreal.coe_mul, nnreal.coe_nat_cast] using norm_pow_le_mul_norm n a\n#align nnnorm_pow_le_mul_norm nnnorm_pow_le_mul_norm\n\n",
 "nnnorm_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp, to_additive nnnorm_zero]\ntheorem nnnorm_one' : «expr‖ ‖₊» (1 : E) = 0 :=\n  nnreal.eq norm_one'\n#align nnnorm_one' nnnorm_one'\n\n",
 "nnnorm_of_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_of_nonneg (hr : 0 ≤ r) : «expr‖ ‖₊» r = ⟨r, hr⟩ :=\n  nnreal.eq <| norm_of_nonneg hr\n#align nnnorm_of_nonneg nnnorm_of_nonneg\n\n",
 "nnnorm_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_of_mul (x : E) : «expr‖ ‖₊» (ofMul x) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_of_mul nnnorm_of_mul\n\n",
 "nnnorm_of_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_of_dual (x : «expr ᵒᵈ» E) : «expr‖ ‖₊» (ofDual x) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_of_dual nnnorm_of_dual\n\n",
 "nnnorm_of_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_of_add (x : E) : «expr‖ ‖₊» (ofAdd x) = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_of_add nnnorm_of_add\n\n",
 "nnnorm_ne_zero_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive nnnorm_ne_zero_iff]\ntheorem nnnorm_ne_zero_iff' : «expr‖ ‖₊» a ≠ 0 ↔ a ≠ 1 :=\n  nnnorm_eq_zero'.not\n#align nnnorm_ne_zero_iff' nnnorm_ne_zero_iff'\n\n",
 "nnnorm_multiset_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nnnorm_multiset_prod_le (m : Multiset E) : «expr‖ ‖₊» m.prod ≤ (m.map fun x => «expr‖ ‖₊» x).sum :=\n  nnreal.coe_le_coe.1 <| by\n    push_cast\n    rw [Multiset.map_map]\n    exact norm_multiset_prod_le _\n#align nnnorm_multiset_prod_le nnnorm_multiset_prod_le\n\n",
 "nnnorm_mul_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive nnnorm_add_le]\ntheorem nnnorm_mul_le' (a b : E) : «expr‖ ‖₊» (a * b) ≤ «expr‖ ‖₊» a + «expr‖ ‖₊» b :=\n  nnreal.coe_le_coe.1 <| norm_mul_le' a b\n#align nnnorm_mul_le' nnnorm_mul_le'\n\n",
 "nnnorm_le_pi_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive nnnorm_le_pi_nnnorm]\ntheorem nnnorm_le_pi_nnnorm' (i : ι) : «expr‖ ‖₊» (f i) ≤ «expr‖ ‖₊» f :=\n  norm_le_pi_norm' _ i\n#align nnnorm_le_pi_nnnorm' nnnorm_le_pi_nnnorm'\n\n",
 "nnnorm_le_nnnorm_add_nnnorm_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div' (a b : E) : «expr‖ ‖₊» a ≤ «expr‖ ‖₊» b + «expr‖ ‖₊» (a / b) :=\n  norm_le_norm_add_norm_div' _ _\n#align nnnorm_le_nnnorm_add_nnnorm_div' nnnorm_le_nnnorm_add_nnnorm_div'\n\n",
 "nnnorm_le_nnnorm_add_nnnorm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div (a b : E) : «expr‖ ‖₊» b ≤ «expr‖ ‖₊» a + «expr‖ ‖₊» (a / b) :=\n  norm_le_norm_add_norm_div _ _\n#align nnnorm_le_nnnorm_add_nnnorm_div nnnorm_le_nnnorm_add_nnnorm_div\n\n",
 "nnnorm_le_mul_nnnorm_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nnnorm_le_mul_nnnorm_add (a b : E) : «expr‖ ‖₊» a ≤ «expr‖ ‖₊» (a * b) + «expr‖ ‖₊» b :=\n  norm_le_mul_norm_add _ _\n#align nnnorm_le_mul_nnnorm_add nnnorm_le_mul_nnnorm_add\n\n",
 "nnnorm_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp, to_additive nnnorm_neg]\ntheorem nnnorm_inv' (a : E) : «expr‖ ‖₊» a⁻¹ = «expr‖ ‖₊» a :=\n  nnreal.eq <| norm_inv' a\n#align nnnorm_inv' nnnorm_inv'\n\n",
 "nnnorm_eq_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp, to_additive nnnorm_eq_zero]\ntheorem nnnorm_eq_zero' : «expr‖ ‖₊» a = 0 ↔ a = 1 := by rw [← nnreal.coe_eq_zero, coe_nnnorm', norm_eq_zero'']\n#align nnnorm_eq_zero' nnnorm_eq_zero'\n\n",
 "nnnorm_down":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_down (x : ULift E) : «expr‖ ‖₊» x.down = «expr‖ ‖₊» x :=\n  rfl\n#align nnnorm_down nnnorm_down\n\n",
 "nnnorm_div_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nnnorm_div_le (a b : E) : «expr‖ ‖₊» (a / b) ≤ «expr‖ ‖₊» a + «expr‖ ‖₊» b :=\n  nnreal.coe_le_coe.1 <| norm_div_le _ _\n#align nnnorm_div_le nnnorm_div_le\n\n",
 "nnnorm_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive pi.nnnorm_def]\ntheorem pi.nnnorm_def' : «expr‖ ‖₊» f = finset.univ.sup fun b => «expr‖ ‖₊» (f b) :=\n  subtype.eta _ _\n#align pi.nnnorm_def' pi.nnnorm_def'\n\n",
 "nnnorm_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem nnnorm_def (x : ULift E) : «expr‖ ‖₊» x = «expr‖ ‖₊» x.down :=\n  rfl\n#align nnnorm_def nnnorm_def\n\n",
 "nnnorm_coe_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem nnnorm_coe_nat (n : ℕ) : «expr‖ ‖₊» (n : exprℝ) = n :=\n  nnreal.eq <| norm_coe_nat _\n#align nnnorm_coe_nat nnnorm_coe_nat\n\n",
 "nnnorm_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[simp]\ntheorem nnnorm_abs (r : exprℝ) : «expr‖ ‖₊» (|r|) = «expr‖ ‖₊» r := by simp [nnnorm]\n#align nnnorm_abs nnnorm_abs\n\n",
 "nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive continuous_on.nnnorm]\ntheorem continuous_on.nnnorm' {s : set α} (h : continuous_on f s) : continuous_on (fun x => «expr‖ ‖₊» (f x)) s :=\n  fun x hx => (h x hx).nnnorm'\n#align continuous_on.nnnorm' continuous_on.nnnorm'\n\n",
 "nndist_nnnorm_nnnorm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive nndist_nnnorm_nnnorm_le]\ntheorem nndist_nnnorm_nnnorm_le' (a b : E) : nndist («expr‖ ‖₊» a) («expr‖ ‖₊» b) ≤ «expr‖ ‖₊» (a / b) :=\n  nnreal.coe_le_coe.1 <| dist_norm_norm_le' a b\n#align nndist_nnnorm_nnnorm_le' nndist_nnnorm_nnnorm_le'\n\n",
 "nndist_mul_mul_le":
 "@[to_additive]\ntheorem nndist_mul_mul_le (a₁ a₂ b₁ b₂ : E) : nndist (a₁ * a₂) (b₁ * b₂) ≤ nndist a₁ b₁ + nndist a₂ b₂ :=\n  nnreal.coe_le_coe.1 <| dist_mul_mul_le a₁ a₂ b₁ b₂\n#align nndist_mul_mul_le nndist_mul_mul_le\n\n",
 "nndist_eq_nnnorm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem nndist_eq_nnnorm_div (a b : E) : nndist a b = «expr‖ ‖₊» (a / b) :=\n  nnreal.eq <| dist_eq_norm_div _ _\n#align nndist_eq_nnnorm_div nndist_eq_nnnorm_div\n\n",
 "nhds_one_basis_norm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem normed_comm_group.nhds_one_basis_norm_lt :\n    ((nhds) (1 : E)).has_basis (fun ε : exprℝ => 0 < ε) fun ε => { y | «expr‖ ‖» y < ε } :=\n  by\n  convert normed_comm_group.nhds_basis_norm_lt (1 : E)\n  simp\n#align normed_comm_group.nhds_one_basis_norm_lt normed_comm_group.nhds_one_basis_norm_lt\n\n",
 "nhds_basis_norm_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem normed_comm_group.nhds_basis_norm_lt (x : E) :\n    ((nhds) x).has_basis (fun ε : exprℝ => 0 < ε) fun ε => { y | «expr‖ ‖» (y / x) < ε } :=\n  by\n  simp_rw [← ball_eq']\n  exact metric.nhds_basis_ball\n#align normed_comm_group.nhds_basis_norm_lt normed_comm_group.nhds_basis_norm_lt\n\n",
 "ne_one_of_norm_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem ne_one_of_norm_ne_zero : «expr‖ ‖» a ≠ 0 → a ≠ 1 :=\n  mt <| by\n    rintro rfl\n    exact norm_one'\n#align ne_one_of_norm_ne_zero ne_one_of_norm_ne_zero\n\n",
 "ne_one_of_nnnorm_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem ne_one_of_nnnorm_ne_zero {a : E} : «expr‖ ‖₊» a ≠ 0 → a ≠ 1 :=\n  mt <| by\n    rintro rfl\n    exact nnnorm_one'\n#align ne_one_of_nnnorm_ne_zero ne_one_of_nnnorm_ne_zero\n\n",
 "ne_one_of_mem_unit_sphere":
 "@[to_additive ne_zero_of_mem_unit_sphere]\ntheorem ne_one_of_mem_unit_sphere (x : sphere (1 : E) 1) : (x : E) ≠ 1 :=\n  ne_one_of_mem_sphere one_ne_zero _\n#align ne_one_of_mem_unit_sphere ne_one_of_mem_unit_sphere\n\n",
 "ne_one_of_mem_sphere":
 "@[to_additive]\ntheorem ne_one_of_mem_sphere (hr : r ≠ 0) (x : sphere (1 : E) r) : (x : E) ≠ 1 :=\n  ne_one_of_norm_ne_zero <| by rwa [norm_eq_of_mem_sphere' x]\n#align ne_one_of_mem_sphere ne_one_of_mem_sphere\n\n",
 "mul_right_to_equiv":
 "-- TODO This material is superseded by similar constructions such as\n-- `affine_isometry_equiv.const_vadd`; deduplicate\n@[simp, to_additive]\ntheorem mul_right_to_equiv (x : E) : (isometry_equiv.mul_right x).to_equiv = Equiv.mulRight x :=\n  rfl\n#align mul_right_to_equiv mul_right_to_equiv\n\n",
 "mul_right_symm":
 "@[simp, to_additive]\ntheorem mul_right_symm (x : E) : (isometry_equiv.mul_right x).symm = isometry_equiv.mul_right x⁻¹ :=\n  ext fun y => rfl\n#align mul_right_symm mul_right_symm\n\n",
 "mul_right_apply":
 "@[to_additive]\ntheorem mul_right_apply (x y : E) : (isometry_equiv.mul_right x : E → E) y = y * x :=\n  rfl\n#align mul_right_apply mul_right_apply\n\n",
 "mul_mem_closed_ball_mul_iff":
 "@[simp, to_additive]\ntheorem mul_mem_closed_ball_mul_iff {c : E} : a * c ∈ closed_ball (b * c) r ↔ a ∈ closed_ball b r := by\n  simp only [mem_closed_ball, dist_eq_norm_div, mul_div_mul_right_eq_div]\n#align mul_mem_closed_ball_mul_iff mul_mem_closed_ball_mul_iff\n\n",
 "mul_mem_closed_ball_iff_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem mul_mem_closed_ball_iff_norm : a * b ∈ closed_ball a r ↔ «expr‖ ‖» b ≤ r := by\n  rw [mem_closed_ball_iff_norm'', mul_div_cancel''']\n#align mul_mem_closed_ball_iff_norm mul_mem_closed_ball_iff_norm\n\n",
 "mul_mem_ball_mul_iff":
 "@[simp, to_additive]\ntheorem mul_mem_ball_mul_iff {c : E} : a * c ∈ ball (b * c) r ↔ a ∈ ball b r := by\n  simp only [mem_ball, dist_eq_norm_div, mul_div_mul_right_eq_div]\n#align mul_mem_ball_mul_iff mul_mem_ball_mul_iff\n\n",
 "mul_mem_ball_iff_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem mul_mem_ball_iff_norm : a * b ∈ ball a r ↔ «expr‖ ‖» b < r := by rw [mem_ball_iff_norm'', mul_div_cancel''']\n#align mul_mem_ball_iff_norm mul_mem_ball_iff_norm\n\n",
 "mul_lipschitz_with":
 "@[to_additive]\ntheorem mul_lipschitz_with (hf : antilipschitz_with Kf f) (hg : lipschitz_with Kg g) (hK : Kg < Kf⁻¹) :\n    antilipschitz_with (Kf⁻¹ - Kg)⁻¹ fun x => f x * g x :=\n  by\n  letI : pseudo_metric_space α := pseudo_emetric_space.to_pseudo_metric_space hf.edist_ne_top\n  refine' antilipschitz_with.of_le_mul_dist fun x y => _\n  rw [nnreal.coe_inv, ← div_eq_inv_mul]\n  rw [le_div_iff (nnreal.coe_pos.2 <| tsub_pos_iff_lt.2 hK)]\n  rw [mul_comm, nnreal.coe_sub hK.le, sub_mul]\n  calc\n    ↑Kf⁻¹ * dist x y - Kg * dist x y ≤ dist (f x) (f y) - dist (g x) (g y) :=\n      sub_le_sub (hf.mul_le_dist x y) (hg.dist_le_mul x y)\n    _ ≤ _ := le_trans (le_abs_self _) (abs_dist_sub_le_dist_mul_mul _ _ _ _)\n    \n#align mul_lipschitz_with mul_lipschitz_with\n\n",
 "mul_left_to_equiv":
 "@[simp, to_additive]\ntheorem mul_left_to_equiv (x : E) : (isometry_equiv.mul_left x).to_equiv = Equiv.mulLeft x :=\n  rfl\n#align mul_left_to_equiv mul_left_to_equiv\n\n",
 "mul_left_symm":
 "@[simp, to_additive]\ntheorem mul_left_symm (x : E) : (isometry_equiv.mul_left x).symm = isometry_equiv.mul_left x⁻¹ :=\n  ext fun y => rfl\n#align mul_left_symm mul_left_symm\n\n",
 "mul_div_lipschitz_with":
 "@[to_additive]\ntheorem mul_div_lipschitz_with (hf : antilipschitz_with Kf f) (hg : lipschitz_with Kg (g / f)) (hK : Kg < Kf⁻¹) :\n    antilipschitz_with (Kf⁻¹ - Kg)⁻¹ g := by\n  simpa only [pi.div_apply, mul_div_cancel'_right] using hf.mul_lipschitz_with hg hK\n#align mul_div_lipschitz_with mul_div_lipschitz_with\n\n",
 "mul'":
 "@[to_additive add]\ntheorem mul' (hf : lipschitz_with Kf f) (hg : lipschitz_with Kg g) : lipschitz_with (Kf + Kg) fun x => f x * g x :=\n  fun x y =>\n  calc\n    edist (f x * g x) (f y * g y) ≤ edist (f x) (f y) + edist (g x) (g y) := edist_mul_mul_le _ _ _ _\n    _ ≤ Kf * edist x y + Kg * edist x y := add_le_add (hf x y) (hg x y)\n    _ = (Kf + Kg) * edist x y := (add_mul _ _ _).symm\n    \n#align mul' mul'\n\n",
 "mem_sphere_one_iff_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem mem_sphere_one_iff_norm : a ∈ sphere (1 : E) r ↔ «expr‖ ‖» a = r := by simp [dist_eq_norm_div]\n#align mem_sphere_one_iff_norm mem_sphere_one_iff_norm\n\n",
 "mem_sphere_iff_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive mem_sphere_iff_norm]\ntheorem mem_sphere_iff_norm' : b ∈ sphere a r ↔ «expr‖ ‖» (b / a) = r := by simp [dist_eq_norm_div]\n#align mem_sphere_iff_norm' mem_sphere_iff_norm'\n\n",
 "mem_emetric_ball_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem mem_emetric_ball_one_iff {r : ennreal} : a ∈ emetric.ball (1 : E) r ↔ ↑(«expr‖ ‖₊» a) < r := by\n  rw [emetric.mem_ball, edist_eq_coe_nnnorm']\n#align mem_emetric_ball_one_iff mem_emetric_ball_one_iff\n\n",
 "mem_closure_one_iff_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem mem_closure_one_iff_norm {x : E} : x ∈ closure ({1} : set E) ↔ «expr‖ ‖» x = 0 := by\n  rw [← closed_ball_zero', mem_closed_ball_one_iff, (norm_nonneg' x).le_iff_eq]\n#align mem_closure_one_iff_norm mem_closure_one_iff_norm\n\n",
 "mem_closure_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem seminormed_comm_group.mem_closure_iff : a ∈ closure s ↔ ∀ ε, 0 < ε → ∃ b ∈ s, «expr‖ ‖» (a / b) < ε := by\n  simp [metric.mem_closure_iff, dist_eq_norm_div]\n#align seminormed_comm_group.mem_closure_iff seminormed_comm_group.mem_closure_iff\n\n",
 "mem_closed_ball_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem mem_closed_ball_one_iff : a ∈ closed_ball (1 : E) r ↔ «expr‖ ‖» a ≤ r := by rw [mem_closed_ball, dist_one_right]\n#align mem_closed_ball_one_iff mem_closed_ball_one_iff\n\n",
 "mem_closed_ball_iff_norm'''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive mem_closed_ball_iff_norm']\ntheorem mem_closed_ball_iff_norm''' : b ∈ closed_ball a r ↔ «expr‖ ‖» (a / b) ≤ r := by\n  rw [mem_closed_ball', dist_eq_norm_div]\n#align mem_closed_ball_iff_norm''' mem_closed_ball_iff_norm'''\n\n",
 "mem_closed_ball_iff_norm''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive mem_closed_ball_iff_norm]\ntheorem mem_closed_ball_iff_norm'' : b ∈ closed_ball a r ↔ «expr‖ ‖» (b / a) ≤ r := by\n  rw [mem_closed_ball, dist_eq_norm_div]\n#align mem_closed_ball_iff_norm'' mem_closed_ball_iff_norm''\n\n",
 "mem_ball_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem mem_ball_one_iff : a ∈ ball (1 : E) r ↔ «expr‖ ‖» a < r := by rw [mem_ball, dist_one_right]\n#align mem_ball_one_iff mem_ball_one_iff\n\n",
 "mem_ball_iff_norm'''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive mem_ball_iff_norm']\ntheorem mem_ball_iff_norm''' : b ∈ ball a r ↔ «expr‖ ‖» (a / b) < r := by rw [mem_ball', dist_eq_norm_div]\n#align mem_ball_iff_norm''' mem_ball_iff_norm'''\n\n",
 "mem_ball_iff_norm''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive mem_ball_iff_norm]\ntheorem mem_ball_iff_norm'' : b ∈ ball a r ↔ «expr‖ ‖» (b / a) < r := by rw [mem_ball, dist_eq_norm_div]\n#align mem_ball_iff_norm'' mem_ball_iff_norm''\n\n",
 "lipschitz_with_one_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[to_additive lipschitz_with_one_norm]\ntheorem lipschitz_with_one_norm' : lipschitz_with 1 (norm : E → exprℝ) := by\n  simpa only [dist_one_left] using lipschitz_with.dist_right (1 : E)\n#align lipschitz_with_one_norm' lipschitz_with_one_norm'\n\n",
 "lipschitz_with_one_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[to_additive lipschitz_with_one_nnnorm]\ntheorem lipschitz_with_one_nnnorm' : lipschitz_with 1 (has_nnnorm.nnnorm : E → nnreal) :=\n  lipschitz_with_one_norm'\n#align lipschitz_with_one_nnnorm' lipschitz_with_one_nnnorm'\n\n",
 "lipschitz_with_iff_norm_div_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem lipschitz_with_iff_norm_div_le {f : E → F} {C : nnreal} :\n    lipschitz_with C f ↔ ∀ x y, «expr‖ ‖» (f x / f y) ≤ C * «expr‖ ‖» (x / y) := by\n  simp only [lipschitz_with_iff_dist_le_mul, dist_eq_norm_div]\n#align lipschitz_with_iff_norm_div_le lipschitz_with_iff_norm_div_le\n\n",
 "lipschitz_on_with_iff_norm_div_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem lipschitz_on_with_iff_norm_div_le {f : E → F} {C : nnreal} :\n    lipschitz_on_with C f s ↔ ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → «expr‖ ‖» (f x / f y) ≤ C * «expr‖ ‖» (x / y) := by\n  simp only [lipschitz_on_with_iff_dist_le_mul, dist_eq_norm_div]\n#align lipschitz_on_with_iff_norm_div_le lipschitz_on_with_iff_norm_div_le\n\n",
 "lipschitz_of_bound_nnnorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem monoid_hom_class.lipschitz_of_bound_nnnorm [MonoidHomClass 𝓕 E F] (f : 𝓕) (C : nnreal)\n    (h : ∀ x, «expr‖ ‖₊» (f x) ≤ C * «expr‖ ‖₊» x) : lipschitz_with C f :=\n  @real.to_nnreal_coe C ▸ monoid_hom_class.lipschitz_of_bound f C h\n#align monoid_hom_class.lipschitz_of_bound_nnnorm monoid_hom_class.lipschitz_of_bound_nnnorm\n\n",
 "lipschitz_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A homomorphism `f` of seminormed groups is Lipschitz, if there exists a constant `C` such that\nfor all `x`, one has `‖f x‖ ≤ C * ‖x‖`. The analogous condition for a linear map of\n(semi)normed spaces is in `normed_space.operator_norm`. -/\n@[to_additive\n      \"A homomorphism `f` of seminormed groups is Lipschitz, if there exists a constant `C`\\nsuch that for all `x`, one has `‖f x‖ ≤ C * ‖x‖`. The analogous condition for a linear map of\\n(semi)normed spaces is in `normed_space.operator_norm`.\"]\ntheorem monoid_hom_class.lipschitz_of_bound [MonoidHomClass 𝓕 E F] (f : 𝓕) (C : exprℝ)\n    (h : ∀ x, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : lipschitz_with (real.to_nnreal C) f :=\n  lipschitz_with.of_dist_le' fun x y => by simpa only [dist_eq_norm_div, map_div] using h (x / y)\n#align monoid_hom_class.lipschitz_of_bound monoid_hom_class.lipschitz_of_bound\n\n",
 "le_norm_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_norm_self (r : exprℝ) : r ≤ «expr‖ ‖» r :=\n  le_abs_self r\n#align le_norm_self le_norm_self\n\n",
 "le_mul_norm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem le_mul_norm_div {f : E → F} (hf : antilipschitz_with K f) (x y : E) :\n    «expr‖ ‖» (x / y) ≤ K * «expr‖ ‖» (f x / f y) := by simp [← dist_eq_norm_div, hf.le_mul_dist x y]\n#align le_mul_norm_div le_mul_norm_div\n\n",
 "isometry_iff_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem monoid_hom_class.isometry_iff_norm [MonoidHomClass 𝓕 E F] (f : 𝓕) :\n    isometry f ↔ ∀ x, «expr‖ ‖» (f x) = «expr‖ ‖» x :=\n  by\n  simp only [isometry_iff_dist_eq, dist_eq_norm_div, ← map_div]\n  refine' ⟨fun h x => _, fun h x y => h _⟩\n  simpa using h x 1\n#align monoid_hom_class.isometry_iff_norm monoid_hom_class.isometry_iff_norm\n\n",
 "inv_to_equiv":
 "@[simp, to_additive]\ntheorem inv_to_equiv : (isometry_equiv.inv E).to_equiv = Equiv.inv E :=\n  rfl\n#align inv_to_equiv inv_to_equiv\n\n",
 "inv_symm":
 "@[simp, to_additive]\ntheorem inv_symm : (isometry_equiv.inv E).symm = isometry_equiv.inv E :=\n  rfl\n#align inv_symm inv_symm\n\n",
 "inv":
 "@[to_additive]\ntheorem inv (hf : lipschitz_with K f) : lipschitz_with K fun x => (f x)⁻¹ := fun x y =>\n  (edist_inv_inv _ _).trans_le <| hf x y\n#align inv inv\n\n",
 "has_compact_support_norm_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem has_compact_support_norm_iff : (has_compact_support fun x => «expr‖ ‖» (f x)) ↔ has_compact_support f :=\n  has_compact_support_comp_left fun x => norm_eq_zero\n#align has_compact_support_norm_iff has_compact_support_norm_iff\n\n",
 "exists_pos_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive metric.bounded.exists_pos_norm_le]\ntheorem metric.bounded.exists_pos_norm_le' (hs : metric.bounded s) : ∃ R > 0, ∀ x ∈ s, «expr‖ ‖» x ≤ R :=\n  let ⟨R₀, hR₀⟩ := hs.exists_norm_le'\n  ⟨max R₀ 1, by positivity, fun x hx => (hR₀ x hx).trans <| le_max_left _ _⟩\n#align metric.bounded.exists_pos_norm_le' metric.bounded.exists_pos_norm_le'\n\n",
 "exists_bound_of_continuous_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive is_compact.exists_bound_of_continuous_on]\ntheorem is_compact.exists_bound_of_continuous_on' [topological_space α] {s : set α} (hs : is_compact s) {f : α → E}\n    (hf : continuous_on f s) : ∃ C, ∀ x ∈ s, «expr‖ ‖» (f x) ≤ C :=\n  (bounded_iff_forall_norm_le'.1 (hs.image_of_continuous_on hf).bounded).imp fun C hC x hx =>\n    hC _ <| Set.mem_image_of_mem _ hx\n#align is_compact.exists_bound_of_continuous_on' is_compact.exists_bound_of_continuous_on'\n\n",
 "eventually_ne_of_tendsto_norm_at_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/-- If `‖y‖ → ∞`, then we can assume `y ≠ x` for any fixed `x`. -/\n@[to_additive eventually_ne_of_tendsto_norm_at_top \"If `‖y‖→∞`, then we can assume `y≠x` for any\\nfixed `x`\"]\ntheorem eventually_ne_of_tendsto_norm_at_top' {l : filter α} {f : α → E}\n    (h : tendsto (fun y => «expr‖ ‖» (f y)) l at_top) (x : E) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (f y ≠ x) :=\n  (h.eventually_ne_at_top _).mono fun x => ne_of_apply_ne norm\n#align eventually_ne_of_tendsto_norm_at_top' eventually_ne_of_tendsto_norm_at_top'\n\n",
 "eq_of_norm_div_le_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem eq_of_norm_div_le_zero (h : «expr‖ ‖» (a / b) ≤ 0) : a = b := by rwa [← div_eq_one, ← norm_le_zero_iff'']\n#align eq_of_norm_div_le_zero eq_of_norm_div_le_zero\n\n",
 "ennnorm_eq_of_real_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem ennnorm_eq_of_real_abs (r : exprℝ) : («expr‖ ‖₊» r : ennreal) = ennreal.of_real (|r|) := by\n  rw [← real.nnnorm_abs r, real.ennnorm_eq_of_real (abs_nonneg _)]\n#align ennnorm_eq_of_real_abs ennnorm_eq_of_real_abs\n\n",
 "ennnorm_eq_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem ennnorm_eq_of_real (hr : 0 ≤ r) : («expr‖ ‖₊» r : ennreal) = ennreal.of_real r := by\n  rw [← of_real_norm_eq_coe_nnnorm, norm_of_nonneg hr]\n#align ennnorm_eq_of_real ennnorm_eq_of_real\n\n",
 "edist_mul_right":
 "@[simp, to_additive]\ntheorem edist_mul_right (a₁ a₂ b : E) : edist (a₁ * b) (a₂ * b) = edist a₁ a₂ := by simp [edist_dist]\n#align edist_mul_right edist_mul_right\n\n",
 "edist_mul_mul_le":
 "@[to_additive]\ntheorem edist_mul_mul_le (a₁ a₂ b₁ b₂ : E) : edist (a₁ * a₂) (b₁ * b₂) ≤ edist a₁ b₁ + edist a₂ b₂ :=\n  by\n  simp only [edist_nndist]\n  norm_cast\n  apply nndist_mul_mul_le\n#align edist_mul_mul_le edist_mul_mul_le\n\n",
 "edist_mul_left":
 "@[simp, to_additive]\ntheorem edist_mul_left (a b₁ b₂ : E) : edist (a * b₁) (a * b₂) = edist b₁ b₂ := by simp [edist_dist]\n#align edist_mul_left edist_mul_left\n\n",
 "edist_inv_inv":
 "@[simp, to_additive]\ntheorem edist_inv_inv (x y : E) : edist x⁻¹ y⁻¹ = edist x y := by rw [edist_inv, inv_inv]\n#align edist_inv_inv edist_inv_inv\n\n",
 "edist_inv":
 "@[to_additive]\ntheorem edist_inv (a b : E) : edist a⁻¹ b = edist a b⁻¹ := by simp_rw [edist_dist, dist_inv]\n#align edist_inv edist_inv\n\n",
 "edist_eq_coe_nnnorm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[to_additive]\ntheorem edist_eq_coe_nnnorm_div (a b : E) : edist a b = «expr‖ ‖₊» (a / b) := by\n  rw [edist_dist, dist_eq_norm_div, of_real_norm_eq_coe_nnnorm']\n#align edist_eq_coe_nnnorm_div edist_eq_coe_nnnorm_div\n\n",
 "edist_eq_coe_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n@[to_additive edist_eq_coe_nnnorm]\ntheorem edist_eq_coe_nnnorm' (x : E) : edist x 1 = («expr‖ ‖₊» x : ennreal) := by rw [edist_eq_coe_nnnorm_div, div_one]\n#align edist_eq_coe_nnnorm' edist_eq_coe_nnnorm'\n\n",
 "edist_div_right":
 "@[simp, to_additive]\ntheorem edist_div_right (a₁ a₂ b : E) : edist (a₁ / b) (a₂ / b) = edist a₁ a₂ := by\n  simpa only [div_eq_mul_inv] using edist_mul_right _ _ _\n#align edist_div_right edist_div_right\n\n",
 "edist_div_left":
 "@[simp, to_additive]\ntheorem edist_div_left (a b₁ b₂ : E) : edist (a / b₁) (a / b₂) = edist b₁ b₂ := by\n  simp only [div_eq_mul_inv, edist_mul_left, edist_inv_inv]\n#align edist_div_left edist_div_left\n\n",
 "div":
 "@[to_additive]\ntheorem div (hf : lipschitz_with Kf f) (hg : lipschitz_with Kg g) : lipschitz_with (Kf + Kg) fun x => f x / g x := by\n  simpa only [div_eq_mul_inv] using hf.mul' hg.inv\n#align div div\n\n",
 "dist_self_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_self_mul_right (a b : E) : dist a (a * b) = «expr‖ ‖» b := by\n  rw [← dist_one_left, ← dist_mul_left a 1 b, mul_one]\n#align dist_self_mul_right dist_self_mul_right\n\n",
 "dist_self_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_self_mul_left (a b : E) : dist (a * b) a = «expr‖ ‖» b := by rw [dist_comm, dist_self_mul_right]\n#align dist_self_mul_left dist_self_mul_left\n\n",
 "dist_self_div_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_self_div_right (a b : E) : dist a (a / b) = «expr‖ ‖» b := by\n  rw [div_eq_mul_inv, dist_self_mul_right, norm_inv']\n#align dist_self_div_right dist_self_div_right\n\n",
 "dist_self_div_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_self_div_left (a b : E) : dist (a / b) a = «expr‖ ‖» b := by rw [dist_comm, dist_self_div_right]\n#align dist_self_div_left dist_self_div_left\n\n",
 "dist_prod_prod_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[to_additive]\ntheorem dist_prod_prod_le_of_le (s : Finset ι) {f a : ι → E} {d : ι → exprℝ} (h : ∀ b ∈ s, dist (f b) (a b) ≤ d b) :\n    dist (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b))\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (a b)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (d b) :=\n  by\n  simp only [dist_eq_norm_div, ← finset.prod_div_distrib] at *\n  exact norm_prod_le_of_le s h\n#align dist_prod_prod_le_of_le dist_prod_prod_le_of_le\n\n",
 "dist_prod_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[to_additive]\ntheorem dist_prod_prod_le (s : Finset ι) (f a : ι → E) :\n    dist (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f b))\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (a b)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (dist (f b) (a b)) :=\n  dist_prod_prod_le_of_le s fun _ _ => le_rfl\n#align dist_prod_prod_le dist_prod_prod_le\n\n",
 "dist_one_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_one_right (a : E) : dist a 1 = «expr‖ ‖» a := by rw [dist_eq_norm_div, div_one]\n#align dist_one_right dist_one_right\n\n",
 "dist_one_left":
 "@[simp, to_additive]\ntheorem dist_one_left : dist (1 : E) = norm :=\n  funext fun a => by rw [dist_comm, dist_one_right]\n#align dist_one_left dist_one_left\n\n",
 "dist_norm_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive dist_norm_norm_le]\ntheorem dist_norm_norm_le' (a b : E) : dist («expr‖ ‖» a) («expr‖ ‖» b) ≤ «expr‖ ‖» (a / b) :=\n  abs_norm_sub_norm_le' a b\n#align dist_norm_norm_le' dist_norm_norm_le'\n\n",
 "dist_mul_self_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_mul_self_right (a b : E) : dist b (a * b) = «expr‖ ‖» a := by\n  rw [← dist_one_left, ← dist_mul_right 1 a b, one_mul]\n#align dist_mul_self_right dist_mul_self_right\n\n",
 "dist_mul_self_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp, to_additive]\ntheorem dist_mul_self_left (a b : E) : dist (a * b) b = «expr‖ ‖» a := by rw [dist_comm, dist_mul_self_right]\n#align dist_mul_self_left dist_mul_self_left\n\n",
 "dist_mul_right":
 "@[simp, to_additive]\ntheorem dist_mul_right (a₁ a₂ b : E) : dist (a₁ * b) (a₂ * b) = dist a₁ a₂ := by simp [dist_eq_norm_div]\n#align dist_mul_right dist_mul_right\n\n",
 "dist_mul_mul_le_of_le":
 "@[to_additive]\ntheorem dist_mul_mul_le_of_le (h₁ : dist a₁ b₁ ≤ r₁) (h₂ : dist a₂ b₂ ≤ r₂) : dist (a₁ * a₂) (b₁ * b₂) ≤ r₁ + r₂ :=\n  (dist_mul_mul_le a₁ a₂ b₁ b₂).trans <| add_le_add h₁ h₂\n#align dist_mul_mul_le_of_le dist_mul_mul_le_of_le\n\n",
 "dist_mul_mul_le":
 "@[to_additive]\ntheorem dist_mul_mul_le (a₁ a₂ b₁ b₂ : E) : dist (a₁ * a₂) (b₁ * b₂) ≤ dist a₁ b₁ + dist a₂ b₂ := by\n  simpa only [dist_mul_left, dist_mul_right] using dist_triangle (a₁ * a₂) (b₁ * a₂) (b₁ * b₂)\n#align dist_mul_mul_le dist_mul_mul_le\n\n",
 "dist_mul_left":
 "-- See note [reducible non-instances]\n-- See note [reducible non-instances]\n-- See note [reducible non-instances].\n-- See note [reducible non-instances].\n@[simp, to_additive]\ntheorem dist_mul_left (a b₁ b₂ : E) : dist (a * b₁) (a * b₂) = dist b₁ b₂ := by simp [dist_eq_norm_div]\n#align dist_mul_left dist_mul_left\n\n",
 "dist_le_norm_mul_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem dist_le_norm_mul_norm (a b : E) : dist a b ≤ «expr‖ ‖» a + «expr‖ ‖» b :=\n  by\n  rw [dist_eq_norm_div]\n  apply norm_div_le\n#align dist_le_norm_mul_norm dist_le_norm_mul_norm\n\n",
 "dist_inv_inv":
 "@[simp, to_additive]\ntheorem dist_inv_inv (a b : E) : dist a⁻¹ b⁻¹ = dist a b := by rw [dist_inv, inv_inv]\n#align dist_inv_inv dist_inv_inv\n\n",
 "dist_inv":
 "@[to_additive]\ntheorem dist_inv (x y : E) : dist x⁻¹ y = dist x y⁻¹ := by\n  simp_rw [dist_eq_norm_div, ← norm_inv' (x⁻¹ / y), inv_div, div_inv_eq_mul, mul_comm]\n#align dist_inv dist_inv\n\n",
 "dist_eq_norm_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem dist_eq_norm_div' (a b : E) : dist a b = «expr‖ ‖» (b / a) := by rw [dist_comm, dist_eq_norm_div]\n#align dist_eq_norm_div' dist_eq_norm_div'\n\n",
 "dist_eq_norm_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem dist_eq_norm_div (a b : E) : dist a b = «expr‖ ‖» (a / b) :=\n  seminormed_group.dist_eq _ _\n#align dist_eq_norm_div dist_eq_norm_div\n\n",
 "dist_div_right":
 "@[to_additive]\ntheorem dist_div_right (a₁ a₂ b : E) : dist (a₁ / b) (a₂ / b) = dist a₁ a₂ := by\n  simpa only [div_eq_mul_inv] using dist_mul_right _ _ _\n#align dist_div_right dist_div_right\n\n",
 "dist_div_left":
 "@[simp, to_additive]\ntheorem dist_div_left (a b₁ b₂ : E) : dist (a / b₁) (a / b₂) = dist b₁ b₂ := by\n  simp only [div_eq_mul_inv, dist_mul_left, dist_inv_inv]\n#align dist_div_left dist_div_left\n\n",
 "dist_div_eq_dist_mul_right":
 "@[simp, to_additive]\ntheorem dist_div_eq_dist_mul_right (a b c : E) : dist a (b / c) = dist (a * c) b := by\n  rw [← dist_mul_right _ _ c, div_mul_cancel']\n#align dist_div_eq_dist_mul_right dist_div_eq_dist_mul_right\n\n",
 "dist_div_eq_dist_mul_left":
 "@[simp, to_additive]\ntheorem dist_div_eq_dist_mul_left (a b c : E) : dist (a / b) c = dist a (c * b) := by\n  rw [← dist_mul_right _ _ b, div_mul_cancel']\n#align dist_div_eq_dist_mul_left dist_div_eq_dist_mul_left\n\n",
 "dist_div_div_le_of_le":
 "@[to_additive]\ntheorem dist_div_div_le_of_le (h₁ : dist a₁ b₁ ≤ r₁) (h₂ : dist a₂ b₂ ≤ r₂) : dist (a₁ / a₂) (b₁ / b₂) ≤ r₁ + r₂ :=\n  (dist_div_div_le a₁ a₂ b₁ b₂).trans <| add_le_add h₁ h₂\n#align dist_div_div_le_of_le dist_div_div_le_of_le\n\n",
 "dist_div_div_le":
 "@[to_additive]\ntheorem dist_div_div_le (a₁ a₂ b₁ b₂ : E) : dist (a₁ / a₂) (b₁ / b₂) ≤ dist a₁ b₁ + dist a₂ b₂ := by\n  simpa only [div_eq_mul_inv, dist_inv_inv] using dist_mul_mul_le a₁ a₂⁻¹ b₁ b₂⁻¹\n#align dist_div_div_le dist_div_div_le\n\n",
 "controlled_prod_of_mem_closure_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem controlled_prod_of_mem_closure_range {j : «expr →* » E F} {b : F} (hb : b ∈ closure (j.range : set F))\n    {f : ℕ → exprℝ} (b_pos : ∀ n, 0 < f n) :\n    ∃ a : ℕ → E,\n      tendsto\n          (fun n =>\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (range (n + 1)) (j (a i)))\n          at_top ((nhds) b) ∧\n        «expr‖ ‖» (j (a 0) / b) < f 0 ∧ ∀ n, 0 < n → «expr‖ ‖» (j (a n)) < f n :=\n  by\n  obtain ⟨v, sum_v, v_in, hv₀, hv_pos⟩ := controlled_prod_of_mem_closure hb b_pos\n  choose g hg using v_in\n  refine' ⟨g, by simpa [← hg] using sum_v, by simpa [hg 0] using hv₀, fun n hn => by simpa [hg] using hv_pos n hn⟩\n#align controlled_prod_of_mem_closure_range controlled_prod_of_mem_closure_range\n\n",
 "controlled_prod_of_mem_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uniformity -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem controlled_prod_of_mem_closure {s : subgroup E} (hg : a ∈ closure (s : set E)) {b : ℕ → exprℝ}\n    (b_pos : ∀ n, 0 < b n) :\n    ∃ v : ℕ → E,\n      tendsto\n          (fun n =>\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (range (n + 1)) (v i))\n          at_top ((nhds) a) ∧\n        (∀ n, v n ∈ s) ∧ «expr‖ ‖» (v 0 / a) < b 0 ∧ ∀ n, 0 < n → «expr‖ ‖» (v n) < b n :=\n  by\n  obtain ⟨u : ℕ → E, u_in : ∀ n, u n ∈ s, lim_u : tendsto u at_top ((nhds) a)⟩ := mem_closure_iff_seq_limit.mp hg\n  obtain ⟨n₀, hn₀⟩ : ∃ n₀, ∀ n ≥ n₀, «expr‖ ‖» (u n / a) < b 0 :=\n    haveI : { x | «expr‖ ‖» (x / a) < b 0 } ∈ (nhds) a :=\n      by\n      simp_rw [← dist_eq_norm_div]\n      exact metric.ball_mem_nhds _ (b_pos _)\n    filter.tendsto_at_top'.mp lim_u _ this\n  set z : ℕ → E := fun n => u (n + n₀)\n  have lim_z : tendsto z at_top ((nhds) a) := lim_u.comp (tendsto_add_at_top_nat n₀)\n  have mem_𝓤 : ∀ n, { p : E × E | «expr‖ ‖» (p.1 / p.2) < b (n + 1) } ∈ (uniformity) E := fun n => by\n    simpa [← dist_eq_norm_div] using metric.dist_mem_uniformity (b_pos <| n + 1)\n  obtain ⟨φ : ℕ → ℕ, φ_extr : strict_mono φ, hφ : ∀ n, «expr‖ ‖» (z (φ <| n + 1) / z (φ n)) < b (n + 1)⟩ :=\n    lim_z.cauchy_seq.subseq_mem mem_𝓤\n  set w : ℕ → E := z ∘ φ\n  have hw : tendsto w at_top ((nhds) a) := lim_z.comp φ_extr.tendsto_at_top\n  set v : ℕ → E := fun i => if i = 0 then w 0 else w i / w (i - 1)\n  refine' ⟨v, tendsto.congr (finset.eq_prod_range_div' w) hw, _, hn₀ _ (n₀.le_add_left _), _⟩\n  · rintro ⟨⟩\n    · change w 0 ∈ s\n      apply u_in\n    · apply s.div_mem <;> apply u_in\n  · intro l hl\n    obtain ⟨k, rfl⟩ : ∃ k, l = k + 1\n    exact nat.exists_eq_succ_of_ne_zero hl.ne'\n    apply hφ\n#align controlled_prod_of_mem_closure controlled_prod_of_mem_closure\n\n",
 "continuous_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A homomorphism `f` of seminormed groups is continuous, if there exists a constant `C` such that\nfor all `x`, one has `‖f x‖ ≤ C * ‖x‖`. -/\n@[to_additive\n      \"A homomorphism `f` of seminormed groups is continuous, if there exists a constant `C`\\nsuch that for all `x`, one has `‖f x‖ ≤ C * ‖x‖`\"]\ntheorem monoid_hom_class.continuous_of_bound [MonoidHomClass 𝓕 E F] (f : 𝓕) (C : exprℝ)\n    (h : ∀ x, «expr‖ ‖» (f x) ≤ C * «expr‖ ‖» x) : continuous f :=\n  (monoid_hom_class.lipschitz_of_bound f C h).continuous\n#align monoid_hom_class.continuous_of_bound monoid_hom_class.continuous_of_bound\n\n",
 "continuous_norm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[continuity, to_additive continuous_norm]\ntheorem continuous_norm' : continuous fun a : E => «expr‖ ‖» a := by\n  simpa using continuous_id.dist (continuous_const : continuous fun a => (1 : E))\n#align continuous_norm' continuous_norm'\n\n",
 "continuous_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n@[continuity, to_additive continuous_nnnorm]\ntheorem continuous_nnnorm' : continuous fun a : E => «expr‖ ‖₊» a :=\n  continuous_norm'.subtype_mk _\n#align continuous_nnnorm' continuous_nnnorm'\n\n",
 "comap_norm_nhds_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n@[to_additive]\ntheorem comap_norm_nhds_one : comap norm ((nhds) 0) = (nhds) (1 : E) := by\n  simpa only [dist_one_right] using nhds_comap_dist (1 : E)\n#align comap_norm_nhds_one comap_norm_nhds_one\n\n",
 "coe_norm_group_seminorm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_norm_group_seminorm : «expr⇑ » (norm_group_seminorm E) = norm :=\n  rfl\n#align coe_norm_group_seminorm coe_norm_group_seminorm\n\n",
 "coe_norm_group_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_norm_group_norm : «expr⇑ » (norm_group_norm E) = norm :=\n  rfl\n#align coe_norm_group_norm coe_norm_group_norm\n\n",
 "coe_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n-- See note [implicit instance arguments]\n-- See note [implicit instance arguments].\n/-- If `x` is an element of a submodule `s` of a normed group `E`, its norm in `s` is equal to its\nnorm in `E`. -/\n@[simp]\ntheorem coe_norm {_ : Ring 𝕜} [seminormed_add_comm_group E] {_ : Module 𝕜 E} {s : submodule 𝕜 E} (x : s) :\n    «expr‖ ‖» x = «expr‖ ‖» (x : E) :=\n  rfl\n#align coe_norm coe_norm\n\n",
 "coe_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n-- See note [lower instance priority]\n@[simp, norm_cast, to_additive coe_nnnorm]\ntheorem coe_nnnorm' (a : E) : («expr‖ ‖₊» a : exprℝ) = «expr‖ ‖» a :=\n  rfl\n#align coe_nnnorm' coe_nnnorm'\n\n",
 "coe_nat_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem _root_.nnreal.coe_nat_abs (n : ℤ) : (n.nat_abs : nnreal) = «expr‖ ‖₊» n :=\n  nnreal.eq <|\n    calc\n      ((n.nat_abs : nnreal) : exprℝ) = (n.nat_abs : ℤ) := by simp only [Int.cast_ofNat, nnreal.coe_nat_cast]\n      _ = |n| := by simp only [Int.coe_natAbs, Int.cast_abs]\n      _ = «expr‖ ‖» n := rfl\n      \n#align nnreal.coe_nat_abs nnreal.coe_nat_abs\n\n",
 "coe_mul_right":
 "@[simp, to_additive]\ntheorem coe_mul_right (x : E) : (isometry_equiv.mul_right x : E → E) = fun y => y * x :=\n  rfl\n#align coe_mul_right coe_mul_right\n\n",
 "coe_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_mul_left (x : E) : «expr⇑ » (isometry_equiv.mul_left x) = (· * ·) x :=\n  rfl\n#align coe_mul_left coe_mul_left\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_inv : «expr⇑ » (isometry_equiv.inv E) = has_inv.inv :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_comp_nnnorm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n@[simp, to_additive coe_comp_nnnorm]\ntheorem coe_comp_nnnorm' : (coe : nnreal → exprℝ) ∘ (nnnorm : E → nnreal) = norm :=\n  rfl\n#align coe_comp_nnnorm' coe_comp_nnnorm'\n\n",
 "closure_one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem closure_one_eq : closure ({1} : set E) = { x | «expr‖ ‖» x = 0 } :=\n  Set.ext fun x => mem_closure_one_iff_norm\n#align closure_one_eq closure_one_eq\n\n",
 "cauchy_seq_prod_of_eventually_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n-- See note [lower instance priority]\n-- See note [lower instance priority]\n-- short-circuit type class inference\n-- See note [lower instance priority]\n@[to_additive]\ntheorem cauchy_seq_prod_of_eventually_eq {u v : ℕ → E} {N : ℕ} (huv : ∀ n ≥ N, u n = v n)\n    (hv :\n      cauchy_seq fun n =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (range (n + 1)) (v k)) :\n    cauchy_seq fun n =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n        (u k) :=\n  by\n  let d : ℕ → E := fun n =>\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range (n + 1))\n      (u k / v k)\n  rw [show\n      (fun n =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (range (n + 1)) (u k)) =\n        d * fun n =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            (range (n + 1)) (v k)\n      by\n      ext n\n      simp [d]]\n  suffices ∀ n ≥ N, d n = d N by exact (tendsto_at_top_of_eventually_const this).cauchy_seq.mul hv\n  intro n hn\n  dsimp [d]\n  rw [eventually_constant_prod _ hn]\n  intro m hm\n  simp [huv m hm]\n#align cauchy_seq_prod_of_eventually_eq cauchy_seq_prod_of_eventually_eq\n\n",
 "cauchy_seq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem normed_comm_group.cauchy_seq_iff [nonempty α] [SemilatticeSup α] {u : α → E} :\n    cauchy_seq u ↔ ∀ ε > 0, ∃ N, ∀ m, N ≤ m → ∀ n, N ≤ n → «expr‖ ‖» (u m / u n) < ε := by\n  simp [metric.cauchy_seq_iff, dist_eq_norm_div]\n#align normed_comm_group.cauchy_seq_iff normed_comm_group.cauchy_seq_iff\n\n",
 "bounded_iff_forall_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive bounded_iff_forall_norm_le]\ntheorem bounded_iff_forall_norm_le' : bounded s ↔ ∃ C, ∀ x ∈ s, «expr‖ ‖» x ≤ C := by\n  simpa only [Set.subset_def, mem_closed_ball_one_iff] using bounded_iff_subset_ball (1 : E)\n#align bounded_iff_forall_norm_le' bounded_iff_forall_norm_le'\n\n",
 "bounded_above_of_compact_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem continuous.bounded_above_of_compact_support (hf : continuous f) (h : has_compact_support f) :\n    ∃ C, ∀ x, «expr‖ ‖» (f x) ≤ C := by simpa [bddAbove_def] using hf.norm.bdd_above_range_of_has_compact_support h.norm\n#align continuous.bounded_above_of_compact_support continuous.bounded_above_of_compact_support\n\n",
 "bound_of_antilipschitz":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem monoid_hom_class.bound_of_antilipschitz [MonoidHomClass 𝓕 E F] (f : 𝓕) {K : nnreal} (h : antilipschitz_with K f)\n    (x) : «expr‖ ‖» x ≤ K * «expr‖ ‖» (f x) := by simpa only [dist_one_right, map_one] using h.le_mul_dist x 1\n#align monoid_hom_class.bound_of_antilipschitz monoid_hom_class.bound_of_antilipschitz\n\n",
 "ball_one_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem ball_one_eq (r : exprℝ) : ball (1 : E) r = { x | «expr‖ ‖» x < r } :=\n  Set.ext fun a => by simp\n#align ball_one_eq ball_one_eq\n\n",
 "ball_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive ball_eq]\ntheorem ball_eq' (y : E) (ε : exprℝ) : ball y ε = { x | «expr‖ ‖» (x / y) < ε } :=\n  Set.ext fun a => by simp [dist_eq_norm_div]\n#align ball_eq' ball_eq'\n\n",
 "antilipschitz_of_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive]\ntheorem monoid_hom_class.antilipschitz_of_bound [MonoidHomClass 𝓕 E F] (f : 𝓕) {K : nnreal}\n    (h : ∀ x, «expr‖ ‖» x ≤ K * «expr‖ ‖» (f x)) : antilipschitz_with K f :=\n  antilipschitz_with.of_le_mul_dist fun x y => by simpa only [dist_eq_norm_div, map_div] using h (x / y)\n#align monoid_hom_class.antilipschitz_of_bound monoid_hom_class.antilipschitz_of_bound\n\n",
 "abs_norm_sub_norm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[to_additive abs_norm_sub_norm_le]\ntheorem abs_norm_sub_norm_le' (a b : E) : |«expr‖ ‖» a - «expr‖ ‖» b| ≤ «expr‖ ‖» (a / b) := by\n  simpa [dist_eq_norm_div] using abs_dist_sub_le a b 1\n#align abs_norm_sub_norm_le' abs_norm_sub_norm_le'\n\n",
 "abs_le_floor_nnreal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\ntheorem abs_le_floor_nnreal_iff (z : ℤ) (c : nnreal) : |z| ≤ «expr⌊ ⌋₊» c ↔ «expr‖ ‖₊» z ≤ c :=\n  by\n  rw [Int.abs_eq_natAbs, Int.ofNat_le, Nat.le_floor_iff (zero_le c)]\n  congr\n  exact nnreal.coe_nat_abs z\n#align abs_le_floor_nnreal_iff abs_le_floor_nnreal_iff\n\n",
 "abs_dist_sub_le_dist_mul_mul":
 "@[to_additive]\ntheorem abs_dist_sub_le_dist_mul_mul (a₁ a₂ b₁ b₂ : E) : |dist a₁ b₁ - dist a₂ b₂| ≤ dist (a₁ * a₂) (b₁ * b₂) := by\n  simpa only [dist_mul_left, dist_mul_right, dist_comm b₂] using abs_dist_sub_le (a₁ * a₂) (b₁ * b₂) (b₁ * a₂)\n#align abs_dist_sub_le_dist_mul_mul abs_dist_sub_le_dist_mul_mul\n\n"}