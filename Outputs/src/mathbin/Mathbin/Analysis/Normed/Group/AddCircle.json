{"norm_neg_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_neg_period (x : exprℝ) : «expr‖ ‖» (x : add_circle (-p)) = «expr‖ ‖» (x : add_circle p) :=\n  by\n  suffices «expr‖ ‖» (↑(-1 * x) : add_circle (-1 * p)) = «expr‖ ‖» (x : add_circle p)\n    by\n    rw [← this, neg_one_mul]\n    simp\n  simp only [norm_coe_mul, abs_neg, abs_one, one_mul]\n#align norm_neg_period norm_neg_period\n\n",
 "norm_le_half_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_le_half_period {x : add_circle p} (hp : p ≠ 0) : «expr‖ ‖» x ≤ |p| / 2 :=\n  by\n  obtain ⟨x⟩ := x\n  change «expr‖ ‖» (x : add_circle p) ≤ |p| / 2\n  rw [norm_eq, ← mul_le_mul_left (abs_pos.mpr (inv_ne_zero hp)), ← abs_mul, mul_sub, mul_left_comm, ← mul_div_assoc, ←\n    abs_mul, inv_mul_cancel hp, mul_one, abs_one]\n  exact abs_sub_round (p⁻¹ * x)\n#align norm_le_half_period norm_le_half_period\n\n",
 "norm_half_period_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n@[simp]\ntheorem norm_half_period_eq : «expr‖ ‖» (↑(p / 2) : add_circle p) = |p| / 2 :=\n  by\n  rcases eq_or_ne p 0 with (rfl | hp); · simp\n  rw [norm_eq, ← mul_div_assoc, inv_mul_cancel hp, one_div, round_two_inv, algebraMap.coe_one, one_mul,\n    (by linarith : p / 2 - p = -(p / 2)), abs_neg, abs_div, abs_two]\n#align norm_half_period_eq norm_half_period_eq\n\n",
 "norm_eq_of_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem norm_eq_of_zero {x : exprℝ} : «expr‖ ‖» (x : add_circle (0 : exprℝ)) = |x| :=\n  by\n  suffices { y : exprℝ | (y : add_circle (0 : exprℝ)) = (x : add_circle (0 : exprℝ)) } = {x} by\n    rw [quotient_norm_eq, this, image_singleton, Real.norm_eq_abs, cinfₛ_singleton]\n  ext y\n  simp [QuotientAddGroup.eq_iff_sub_mem, mem_zmultiples_iff, sub_eq_zero]\n#align norm_eq_of_zero norm_eq_of_zero\n\n",
 "norm_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_eq' (hp : 0 < p) {x : exprℝ} : «expr‖ ‖» (x : add_circle p) = p * |p⁻¹ * x - round (p⁻¹ * x)| :=\n  by\n  conv_rhs =>\n    congr\n    rw [← abs_eq_self.mpr hp.le]\n  rw [← abs_mul, mul_sub, mul_inv_cancel_left₀ hp.ne.symm, norm_eq, mul_comm p]\n#align norm_eq' norm_eq'\n\n",
 "norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_eq {x : exprℝ} : «expr‖ ‖» (x : unit_add_circle) = |x - round x| := by simp [add_circle.norm_eq]\n#align norm_eq norm_eq\n\n",
 "norm_div_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_div_nat_cast {m n : ℕ} :\n    «expr‖ ‖» (↑(↑m / ↑n * p) : add_circle p) = p * (↑(min (m % n) (n - m % n)) / n) :=\n  by\n  have : p⁻¹ * (↑m / ↑n * p) = ↑m / ↑n := by rw [mul_comm _ p, inv_mul_cancel_left₀ hp.out.ne.symm]\n  rw [norm_eq' p hp.out, this, abs_sub_round_div_natCast_eq]\n#align norm_div_nat_cast norm_div_nat_cast\n\n",
 "norm_coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem norm_coe_mul (x : exprℝ) (t : exprℝ) :\n    «expr‖ ‖» (↑(t * x) : add_circle (t * p)) = |t| * «expr‖ ‖» (x : add_circle p) :=\n  by\n  have aux : ∀ {a b c : exprℝ}, a ∈ zmultiples b → c * a ∈ zmultiples (c * b) := fun a b c h =>\n    by\n    simp only [mem_zmultiples_iff] at h⊢\n    obtain ⟨n, rfl⟩ := h\n    exact ⟨n, (mul_smul_comm n c b).symm⟩\n  rcases eq_or_ne t 0 with (rfl | ht); · simp\n  have ht' : |t| ≠ 0 := (not_congr abs_eq_zero).mpr ht\n  simp only [quotient_norm_eq, Real.norm_eq_abs]\n  conv_rhs => rw [← smul_eq_mul, ← Real.infₛ_smul_of_nonneg (abs_nonneg t)]\n  simp only [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_iff_sub_mem]\n  congr 1\n  ext z\n  rw [mem_smul_set_iff_inv_smul_mem₀ ht']\n  show (∃ y, y - t * x ∈ zmultiples (t * p) ∧ |y| = z) ↔ ∃ w, w - x ∈ zmultiples p ∧ |w| = (|t|)⁻¹ * z\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    refine' ⟨t⁻¹ * y, _, by rw [abs_mul, abs_inv]⟩\n    rw [← inv_mul_cancel_left₀ ht x, ← inv_mul_cancel_left₀ ht p, ← mul_sub]\n    exact aux hy\n  · rintro ⟨w, hw, hw'⟩\n    refine' ⟨t * w, _, by rw [← (eq_inv_mul_iff_mul_eq₀ ht').mp hw', abs_mul]⟩\n    rw [← mul_sub]\n    exact aux hw\n#align norm_coe_mul norm_coe_mul\n\n",
 "norm_coe_eq_abs_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem norm_coe_eq_abs_iff {x : exprℝ} (hp : p ≠ 0) : «expr‖ ‖» (x : add_circle p) = |x| ↔ |x| ≤ |p| / 2 :=\n  by\n  refine' ⟨fun hx => hx ▸ norm_le_half_period p hp, fun hx => _⟩\n  suffices ∀ p : exprℝ, 0 < p → |x| ≤ p / 2 → «expr‖ ‖» (x : add_circle p) = |x|\n    by\n    rcases lt_trichotomy 0 p with (hp | rfl | hp)\n    · rw [abs_eq_self.mpr hp.le] at hx\n      exact this p hp hx\n    · contradiction\n    · rw [← norm_neg_period]\n      rw [abs_eq_neg_self.mpr hp.le] at hx\n      exact this (-p) (neg_pos.mpr hp) hx\n  clear hx\n  intro p hp hx\n  rcases eq_or_ne x (p / 2) with (rfl | hx')\n  · simp [abs_div, abs_two]\n  suffices round (p⁻¹ * x) = 0 by simp [norm_eq, this]\n  rw [round_eq_zero_iff]\n  obtain ⟨hx₁, hx₂⟩ := abs_le.mp hx\n  replace hx₂ := Ne.lt_of_le hx' hx₂\n  constructor\n  · rwa [← mul_le_mul_left hp, ← mul_assoc, mul_inv_cancel hp.ne.symm, one_mul, mul_neg, ← mul_div_assoc, mul_one]\n  · rwa [← mul_lt_mul_left hp, ← mul_assoc, mul_inv_cancel hp.ne.symm, one_mul, ← mul_div_assoc, mul_one]\n#align norm_coe_eq_abs_iff norm_coe_eq_abs_iff\n\n",
 "le_add_order_smul_norm_of_is_of_fin_add_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem le_add_order_smul_norm_of_is_of_fin_add_order {u : add_circle p} (hu : IsOfFinAddOrder u) (hu' : u ≠ 0) :\n    p ≤ «expr • » (addOrderOf u) («expr‖ ‖» u) :=\n  by\n  obtain ⟨n, hn⟩ := exists_norm_eq_of_fin_add_order hu\n  replace hu : (addOrderOf u : exprℝ) ≠ 0;\n  · norm_cast\n    exact (add_order_of_pos_iff.mpr hu).ne.symm\n  conv_lhs => rw [← mul_one p]\n  rw [hn, nsmul_eq_mul, ← mul_assoc, mul_comm _ p, mul_assoc, mul_div_cancel' _ hu, mul_le_mul_left hp.out,\n    Nat.one_le_cast, Nat.one_le_iff_ne_zero]\n  contrapose! hu'\n  simpa only [hu', algebraMap.coe_zero, zero_div, MulZeroClass.mul_zero, norm_eq_zero] using hn\n#align le_add_order_smul_norm_of_is_of_fin_add_order le_add_order_smul_norm_of_is_of_fin_add_order\n\n",
 "exists_norm_eq_of_fin_add_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem exists_norm_eq_of_fin_add_order {u : add_circle p} (hu : IsOfFinAddOrder u) :\n    ∃ k : ℕ, «expr‖ ‖» u = p * (k / addOrderOf u) :=\n  by\n  let n := addOrderOf u\n  change ∃ k : ℕ, «expr‖ ‖» u = p * (k / n)\n  obtain ⟨m, -, -, hm⟩ := exists_gcd_eq_one_of_is_of_fin_add_order hu\n  refine' ⟨min (m % n) (n - m % n), _⟩\n  rw [← hm, norm_div_nat_cast]\n#align exists_norm_eq_of_fin_add_order exists_norm_eq_of_fin_add_order\n\n",
 "coe_real_preimage_closed_ball_period_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem coe_real_preimage_closed_ball_period_zero (x ε : exprℝ) :\n    «expr ⁻¹' » coe (closedBall (x : add_circle (0 : exprℝ)) ε) = closedBall x ε := by\n  ext y <;> simp [dist_eq_norm, ← QuotientAddGroup.mk_sub]\n#align coe_real_preimage_closed_ball_period_zero coe_real_preimage_closed_ball_period_zero\n\n",
 "coe_real_preimage_closed_ball_inter_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem coe_real_preimage_closed_ball_inter_eq {x ε : exprℝ} (s : Set (exprℝ)) (hs : s ⊆ closedBall x (|p| / 2)) :\n    «expr ⁻¹' » coe (closedBall (x : add_circle p) ε) ∩ s = if ε < |p| / 2 then closedBall x ε ∩ s else s :=\n  by\n  cases' le_or_lt (|p| / 2) ε with hε hε\n  · rcases eq_or_ne p 0 with (rfl | hp)\n    · simp only [abs_zero, zero_div] at hε\n      simp only [not_lt.mpr hε, coe_real_preimage_closed_ball_period_zero, abs_zero, zero_div, if_false,\n        inter_eq_right_iff_subset]\n      exact hs.trans (closed_ball_subset_closed_ball <| by simp [hε])\n    simp [closed_ball_eq_univ_of_half_period_le p hp (↑x) hε, not_lt.mpr hε]\n  · suffices ∀ z : ℤ, closed_ball (x + «expr • » z p) ε ∩ s = if z = 0 then closed_ball x ε ∩ s else ∅ by\n      simp [-zsmul_eq_mul, ← QuotientAddGroup.mk_zero, coe_real_preimage_closed_ball_eq_Union, Union_inter, Union_ite,\n        this, hε]\n    intro z\n    simp only [Real.closedBall_eq_Icc, zero_sub, zero_add] at hs⊢\n    rcases eq_or_ne z 0 with (rfl | hz)\n    · simp\n    simp only [hz, zsmul_eq_mul, if_false, eq_empty_iff_forall_not_mem]\n    rintro y ⟨⟨hy₁, hy₂⟩, hy₀⟩\n    obtain ⟨hy₃, hy₄⟩ := hs hy₀\n    rcases lt_trichotomy 0 p with (hp | rfl | hp)\n    · cases' Int.cast_le_neg_one_or_one_le_cast_of_ne_zero (exprℝ) hz with hz' hz'\n      · have : ↑z * p ≤ -p\n        nlinarith\n        linarith [abs_eq_self.mpr hp.le]\n      · have : p ≤ ↑z * p\n        nlinarith\n        linarith [abs_eq_self.mpr hp.le]\n    · simp only [MulZeroClass.mul_zero, add_zero, abs_zero, zero_div] at hy₁ hy₂ hε\n      linarith\n    · cases' Int.cast_le_neg_one_or_one_le_cast_of_ne_zero (exprℝ) hz with hz' hz'\n      · have : -p ≤ ↑z * p\n        nlinarith\n        linarith [abs_eq_neg_self.mpr hp.le]\n      · have : ↑z * p ≤ p\n        nlinarith\n        linarith [abs_eq_neg_self.mpr hp.le]\n#align coe_real_preimage_closed_ball_inter_eq coe_real_preimage_closed_ball_inter_eq\n\n",
 "coe_real_preimage_closed_ball_eq_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem coe_real_preimage_closed_ball_eq_Union (x ε : exprℝ) :\n    «expr ⁻¹' » coe (closedBall (x : add_circle p) ε) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (closedBall (x + «expr • » z p) ε) :=\n  by\n  rcases eq_or_ne p 0 with (rfl | hp); · simp [Union_const]\n  ext y\n  simp only [dist_eq_norm, mem_preimage, mem_closed_ball, zsmul_eq_mul, mem_Union, Real.norm_eq_abs, ←\n    QuotientAddGroup.mk_sub, norm_eq, ← sub_sub]\n  refine' ⟨fun h => ⟨round (p⁻¹ * (y - x)), h⟩, _⟩\n  rintro ⟨n, hn⟩\n  rw [← mul_le_mul_left (abs_pos.mpr <| inv_ne_zero hp), ← abs_mul, mul_sub, mul_comm _ p, inv_mul_cancel_left₀ hp] at\n    hn⊢\n  exact (round_le (p⁻¹ * (y - x)) n).trans hn\n#align coe_real_preimage_closed_ball_eq_Union coe_real_preimage_closed_ball_eq_Union\n\n",
 "closed_ball_eq_univ_of_half_period_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem closed_ball_eq_univ_of_half_period_le (hp : p ≠ 0) (x : add_circle p) {ε : exprℝ} (hε : |p| / 2 ≤ ε) :\n    closedBall x ε = univ :=\n  eq_univ_iff_forall.mpr fun x => by\n    simpa only [mem_closed_ball, dist_eq_norm] using (norm_le_half_period p hp).trans hε\n#align closed_ball_eq_univ_of_half_period_le closed_ball_eq_univ_of_half_period_le\n\n"}