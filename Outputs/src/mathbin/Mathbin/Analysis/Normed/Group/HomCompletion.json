{"zero_completion":
 "#print NormedAddGroupHom.zero_completion /-\n@[simp]\ntheorem NormedAddGroupHom.zero_completion : (0 : NormedAddGroupHom G H).completion = 0 :=\n  normedAddGroupHomCompletionHom.map_zero\n#align normed_add_group_hom.zero_completion NormedAddGroupHom.zero_completion\n-/\n\n",
 "norm_toCompl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print NormedAddCommGroup.norm_toCompl /-\ntheorem NormedAddCommGroup.norm_toCompl (x : G) : «expr‖ ‖» (toCompl x) = «expr‖ ‖» x :=\n  Completion.norm_coe x\n#align normed_add_comm_group.norm_to_compl NormedAddCommGroup.norm_toCompl\n-/\n\n",
 "norm_completion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print NormedAddGroupHom.norm_completion /-\n@[simp]\ntheorem NormedAddGroupHom.norm_completion (f : NormedAddGroupHom G H) : «expr‖ ‖» f.completion = «expr‖ ‖» f :=\n  by\n  apply f.completion.op_norm_eq_of_bounds (norm_nonneg _)\n  · intro x\n    apply completion.induction_on x\n    · apply isClosed_le\n      continuity\n    · intro g\n      simp [f.le_op_norm g]\n  · intro N N_nonneg hN\n    apply f.op_norm_le_bound N_nonneg\n    intro x\n    simpa using hN x\n#align normed_add_group_hom.norm_completion NormedAddGroupHom.norm_completion\n-/\n\n",
 "ker_le_ker_completion":
 "#print NormedAddGroupHom.ker_le_ker_completion /-\ntheorem NormedAddGroupHom.ker_le_ker_completion (f : NormedAddGroupHom G H) :\n    (toCompl.comp <| incl f.ker).range ≤ f.completion.ker :=\n  by\n  intro a h\n  replace h : ∃ y : f.ker, to_compl (y : G) = a; · simpa using h\n  rcases h with ⟨⟨g, g_in : g ∈ f.ker⟩, rfl⟩\n  rw [f.mem_ker] at g_in\n  change f.completion (g : completion G) = 0\n  simp [NormedAddGroupHom.mem_ker, f.completion_coe g, g_in, completion.coe_zero]\n#align normed_add_group_hom.ker_le_ker_completion NormedAddGroupHom.ker_le_ker_completion\n-/\n\n",
 "ker_completion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print NormedAddGroupHom.ker_completion /-\ntheorem NormedAddGroupHom.ker_completion {f : NormedAddGroupHom G H} {C : exprℝ} (h : f.surjective_on_with f.range C) :\n    (f.completion.ker : Set <| Completion G) = closure (toCompl.comp <| incl f.ker).range :=\n  by\n  rcases h.exists_pos with ⟨C', C'_pos, hC'⟩\n  apply le_antisymm\n  · intro hatg hatg_in\n    rw [SeminormedAddCommGroup.mem_closure_iff]\n    intro ε ε_pos\n    have hCf : 0 ≤ C' * «expr‖ ‖» f := (zero_le_mul_left C'_pos).mpr (norm_nonneg f)\n    have ineq : 0 < 1 + C' * «expr‖ ‖» f := by linarith\n    set δ := ε / (1 + C' * «expr‖ ‖» f)\n    have δ_pos : δ > 0 := div_pos ε_pos ineq\n    obtain ⟨_, ⟨g : G, rfl⟩, hg : «expr‖ ‖» (hatg - g) < δ⟩ :=\n      seminormed_add_comm_group.mem_closure_iff.mp (completion.dense_inducing_coe.dense hatg) δ δ_pos\n    obtain ⟨g' : G, hgg' : f g' = f g, hfg : «expr‖ ‖» g' ≤ C' * «expr‖ ‖» (f g)⟩ := hC' (f g) (mem_range_self g)\n    have mem_ker : g - g' ∈ f.ker := by rw [f.mem_ker, map_sub, sub_eq_zero.mpr hgg'.symm]\n    have : «expr‖ ‖» (f g) ≤ «expr‖ ‖» f * «expr‖ ‖» (hatg - g)\n    calc\n      «expr‖ ‖» (f g) = «expr‖ ‖» (f.completion g) := by rw [f.completion_coe, completion.norm_coe]\n      _ = «expr‖ ‖» (f.completion g - 0) := by rw [sub_zero _]\n      _ = «expr‖ ‖» (f.completion g - f.completion hatg) := by rw [(f.completion.mem_ker _).mp hatg_in]\n      _ = «expr‖ ‖» (f.completion (g - hatg)) := by rw [map_sub]\n      _ ≤ «expr‖ ‖» f.completion * «expr‖ ‖» ((g : completion G) - hatg) := (f.completion.le_op_norm _)\n      _ = «expr‖ ‖» f * «expr‖ ‖» (hatg - g) := by rw [norm_sub_rev, f.norm_completion]\n      \n    have : «expr‖ ‖» (g' : completion G) ≤ C' * «expr‖ ‖» f * «expr‖ ‖» (hatg - g)\n    calc\n      «expr‖ ‖» (g' : completion G) = «expr‖ ‖» g' := completion.norm_coe _\n      _ ≤ C' * «expr‖ ‖» (f g) := hfg\n      _ ≤ C' * «expr‖ ‖» f * «expr‖ ‖» (hatg - g) := by\n        rw [mul_assoc]\n        exact (mul_le_mul_left C'_pos).mpr this\n      \n    refine' ⟨g - g', _, _⟩\n    · norm_cast\n      rw [NormedAddGroupHom.comp_range]\n      apply AddSubgroup.mem_map_of_mem\n      simp only [incl_range, mem_ker]\n    ·\n      calc\n        «expr‖ ‖» (hatg - (g - g')) = «expr‖ ‖» (hatg - g + g') := by abel\n        _ ≤ «expr‖ ‖» (hatg - g) + «expr‖ ‖» (g' : completion G) := (norm_add_le _ _)\n        _ < δ + C' * «expr‖ ‖» f * «expr‖ ‖» (hatg - g) := by linarith\n        _ ≤ δ + C' * «expr‖ ‖» f * δ := (add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) δ)\n        _ = (1 + C' * «expr‖ ‖» f) * δ := by ring\n        _ = ε := mul_div_cancel' _ ineq.ne.symm\n        \n  · rw [← f.completion.is_closed_ker.closure_eq]\n    exact closure_mono f.ker_le_ker_completion\n#align normed_add_group_hom.ker_completion NormedAddGroupHom.ker_completion\n-/\n\n",
 "extension_unique":
 "#print NormedAddGroupHom.extension_unique /-\ntheorem NormedAddGroupHom.extension_unique (f : NormedAddGroupHom G H) {g : NormedAddGroupHom (Completion G) H}\n    (hg : ∀ v, f v = g v) : f.extension = g := by\n  ext v\n  rw [NormedAddGroupHom.extension_coe_to_fun,\n    completion.extension_unique f.uniform_continuous g.uniform_continuous fun a => hg a]\n#align normed_add_group_hom.extension_unique NormedAddGroupHom.extension_unique\n-/\n\n",
 "extension_def":
 "#print NormedAddGroupHom.extension_def /-\ntheorem NormedAddGroupHom.extension_def (f : NormedAddGroupHom G H) (v : G) :\n    f.extension v = Completion.extension f v :=\n  rfl\n#align normed_add_group_hom.extension_def NormedAddGroupHom.extension_def\n-/\n\n",
 "extension_coe_to_fun":
 "#print NormedAddGroupHom.extension_coe_to_fun /-\ntheorem NormedAddGroupHom.extension_coe_to_fun (f : NormedAddGroupHom G H) :\n    (f.extension : Completion G → H) = Completion.extension f :=\n  rfl\n#align normed_add_group_hom.extension_coe_to_fun NormedAddGroupHom.extension_coe_to_fun\n-/\n\n",
 "extension_coe":
 "#print NormedAddGroupHom.extension_coe /-\n@[simp]\ntheorem NormedAddGroupHom.extension_coe (f : NormedAddGroupHom G H) (v : G) : f.extension v = f v :=\n  AddMonoidHom.extension_coe _ f.continuous _\n#align normed_add_group_hom.extension_coe NormedAddGroupHom.extension_coe\n-/\n\n",
 "denseRange_toCompl":
 "#print NormedAddCommGroup.denseRange_toCompl /-\ntheorem NormedAddCommGroup.denseRange_toCompl : DenseRange (toCompl : G → Completion G) :=\n  Completion.denseInducing_coe.dense\n#align normed_add_comm_group.dense_range_to_compl NormedAddCommGroup.denseRange_toCompl\n-/\n\n",
 "completion_toCompl":
 "#print NormedAddGroupHom.completion_toCompl /-\n@[simp]\ntheorem NormedAddGroupHom.completion_toCompl (f : NormedAddGroupHom G H) : f.completion.comp toCompl = toCompl.comp f :=\n  by\n  ext x\n  change f.completion x = _\n  simpa\n#align normed_add_group_hom.completion_to_compl NormedAddGroupHom.completion_toCompl\n-/\n\n",
 "completion_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n#print NormedAddGroupHom.completion_sub /-\ntheorem NormedAddGroupHom.completion_sub (f g : NormedAddGroupHom G H) :\n    (f - g).completion = f.completion - g.completion :=\n  map_sub (normedAddGroupHomCompletionHom : «expr →+ » (NormedAddGroupHom G H) _) f g\n#align normed_add_group_hom.completion_sub NormedAddGroupHom.completion_sub\n-/\n\n",
 "completion_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n#print NormedAddGroupHom.completion_neg /-\ntheorem NormedAddGroupHom.completion_neg (f : NormedAddGroupHom G H) : (-f).completion = -f.completion :=\n  map_neg (normedAddGroupHomCompletionHom : «expr →+ » (NormedAddGroupHom G H) _) f\n#align normed_add_group_hom.completion_neg NormedAddGroupHom.completion_neg\n-/\n\n",
 "completion_id":
 "#print NormedAddGroupHom.completion_id /-\n@[simp]\ntheorem NormedAddGroupHom.completion_id : (NormedAddGroupHom.id G).completion = NormedAddGroupHom.id (Completion G) :=\n  by\n  ext x\n  rw [NormedAddGroupHom.completion_def, NormedAddGroupHom.coe_id, completion.map_id]\n  rfl\n#align normed_add_group_hom.completion_id NormedAddGroupHom.completion_id\n-/\n\n",
 "completion_def":
 "#print NormedAddGroupHom.completion_def /-\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot\n-/\ntheorem NormedAddGroupHom.completion_def (f : NormedAddGroupHom G H) (x : Completion G) :\n    f.completion x = Completion.map f x :=\n  rfl\n#align normed_add_group_hom.completion_def NormedAddGroupHom.completion_def\n-/\n\n",
 "completion_comp":
 "#print NormedAddGroupHom.completion_comp /-\ntheorem NormedAddGroupHom.completion_comp (f : NormedAddGroupHom G H) (g : NormedAddGroupHom H K) :\n    g.completion.comp f.completion = (g.comp f).completion :=\n  by\n  ext x\n  rw [NormedAddGroupHom.coe_comp, NormedAddGroupHom.completion_def, NormedAddGroupHom.completion_coe_to_fun,\n    NormedAddGroupHom.completion_coe_to_fun,\n    completion.map_comp (NormedAddGroupHom.uniformContinuous _) (NormedAddGroupHom.uniformContinuous _)]\n  rfl\n#align normed_add_group_hom.completion_comp NormedAddGroupHom.completion_comp\n-/\n\n",
 "completion_coe_to_fun":
 "#print NormedAddGroupHom.completion_coe_to_fun /-\n@[simp]\ntheorem NormedAddGroupHom.completion_coe_to_fun (f : NormedAddGroupHom G H) :\n    (f.completion : Completion G → Completion H) = Completion.map f :=\n  by\n  ext x\n  exact NormedAddGroupHom.completion_def f x\n#align normed_add_group_hom.completion_coe_to_fun NormedAddGroupHom.completion_coe_to_fun\n-/\n\n",
 "completion_coe":
 "#print NormedAddGroupHom.completion_coe /-\n@[simp]\ntheorem NormedAddGroupHom.completion_coe (f : NormedAddGroupHom G H) (g : G) : f.completion g = f g :=\n  Completion.map_coe f.uniform_continuous _\n#align normed_add_group_hom.completion_coe NormedAddGroupHom.completion_coe\n-/\n\n",
 "completion_add":
 "#print NormedAddGroupHom.completion_add /-\ntheorem NormedAddGroupHom.completion_add (f g : NormedAddGroupHom G H) :\n    (f + g).completion = f.completion + g.completion :=\n  normedAddGroupHomCompletionHom.map_add f g\n#align normed_add_group_hom.completion_add NormedAddGroupHom.completion_add\n-/\n\n"}