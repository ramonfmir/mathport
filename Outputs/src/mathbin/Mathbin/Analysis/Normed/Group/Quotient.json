{"surjective_normed_mk":
 "/-- `S.normed_mk` is surjective. -/\ntheorem surjective_normed_mk (S : AddSubgroup M) : function.surjective (normedMk S) :=\n  surjective_quot_mk _\n#align surjective_normed_mk surjective_normed_mk\n\n",
 "quotient_norm_sub_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_sub_rev /-\ntheorem quotient_norm_sub_rev {S : AddSubgroup M} (x y : «expr ⧸ » M S) : «expr‖ ‖» (x - y) = «expr‖ ‖» (y - x) := by\n  rw [show x - y = -(y - x) by abel, quotient_norm_neg]\n#align quotient_norm_sub_rev quotient_norm_sub_rev\n-/\n\n",
 "quotient_norm_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_nonneg /-\n/-- The quotient norm is nonnegative. -/\ntheorem quotient_norm_nonneg (S : AddSubgroup M) : ∀ x : «expr ⧸ » M S, 0 ≤ «expr‖ ‖» x :=\n  by\n  rintro ⟨m⟩\n  change 0 ≤ «expr‖ ‖» (mk' S m)\n  apply le_cinfₛ (image_norm_nonempty _)\n  rintro _ ⟨n, h, rfl⟩\n  apply norm_nonneg\n#align quotient_norm_nonneg quotient_norm_nonneg\n-/\n\n",
 "quotient_norm_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_neg /-\n/-- The norm on the quotient satisfies `‖-x‖ = ‖x‖`. -/\ntheorem quotient_norm_neg {S : AddSubgroup M} (x : «expr ⧸ » M S) : «expr‖ ‖» (-x) = «expr‖ ‖» x :=\n  by\n  suffices «expr '' » norm { m | mk' S m = x } = «expr '' » norm { m | mk' S m = -x } by simp only [this, norm]\n  ext r\n  constructor\n  · rintro ⟨m, rfl : mk' S m = x, rfl⟩\n    rw [← norm_neg]\n    exact ⟨-m, by simp only [(mk' S).map_neg, Set.mem_setOf_eq], rfl⟩\n  · rintro ⟨m, hm : mk' S m = -x, rfl⟩\n    exact ⟨-m, by simpa using neg_eq_iff_eq_neg.mpr ((mk'_apply _ _).symm.trans hm)⟩\n#align quotient_norm_neg quotient_norm_neg\n-/\n\n",
 "quotient_norm_mk_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_mk_le' /-\n/-- The norm of the projection is smaller or equal to the norm of the original element. -/\ntheorem quotient_norm_mk_le' (S : AddSubgroup M) (m : M) : «expr‖ ‖» (m : «expr ⧸ » M S) ≤ «expr‖ ‖» m :=\n  quotient_norm_mk_le S m\n#align quotient_norm_mk_le' quotient_norm_mk_le'\n-/\n\n",
 "quotient_norm_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_mk_le /-\n/-- The norm of the projection is smaller or equal to the norm of the original element. -/\ntheorem quotient_norm_mk_le (S : AddSubgroup M) (m : M) : «expr‖ ‖» (mk' S m) ≤ «expr‖ ‖» m :=\n  by\n  apply cinfₛ_le\n  use 0\n  · rintro _ ⟨n, h, rfl⟩\n    apply norm_nonneg\n  · apply Set.mem_image_of_mem\n    rw [Set.mem_setOf_eq]\n#align quotient_norm_mk_le quotient_norm_mk_le\n-/\n\n",
 "quotient_norm_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_mk_eq /-\n/-- The norm of the image under the natural morphism to the quotient. -/\ntheorem quotient_norm_mk_eq (S : AddSubgroup M) (m : M) :\n    «expr‖ ‖» (mk' S m) = infₛ («expr '' » (fun x => «expr‖ ‖» (m + x)) S) :=\n  by\n  change Inf _ = _\n  congr 1\n  ext r\n  simp_rw [coe_mk', eq_iff_sub_mem]\n  constructor\n  · rintro ⟨y, h, rfl⟩\n    use y - m, h\n    simp\n  · rintro ⟨y, h, rfl⟩\n    use m + y\n    simpa using h\n#align quotient_norm_mk_eq quotient_norm_mk_eq\n-/\n\n",
 "quotient_norm_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_eq_zero_iff /-\n/-- The norm of the image of `m : M` in the quotient by `S` is zero if and only if `m` belongs\nto the closure of `S`. -/\ntheorem quotient_norm_eq_zero_iff (S : AddSubgroup M) (m : M) : «expr‖ ‖» (mk' S m) = 0 ↔ m ∈ closure (S : Set M) :=\n  by\n  have : 0 ≤ «expr‖ ‖» (mk' S m) := norm_mk_nonneg S m\n  rw [← this.le_iff_eq, quotient_norm_mk_eq, Real.infₛ_le_iff]\n  simp_rw [zero_add]\n  · calc\n      (∀ ε > (0 : exprℝ), ∃ r ∈ «expr '' » (fun x => «expr‖ ‖» (m + x)) (S : Set M), r < ε) ↔\n          ∀ ε > 0, ∃ x ∈ S, «expr‖ ‖» (m + x) < ε :=\n        by simp [Set.bex_image_iff]\n      _ ↔ ∀ ε > 0, ∃ x ∈ S, «expr‖ ‖» (m + -x) < ε := _\n      _ ↔ ∀ ε > 0, ∃ x ∈ S, x ∈ Metric.ball m ε := by simp [dist_eq_norm, ← sub_eq_add_neg, norm_sub_rev]\n      _ ↔ m ∈ closure ↑S := by simp [Metric.mem_closure_iff, dist_comm]\n      \n    refine' forall₂_congr fun ε ε_pos => _\n    rw [← S.exists_neg_mem_iff_exists_mem]\n    simp\n  · use 0\n    rintro _ ⟨x, x_in, rfl⟩\n    apply norm_nonneg\n  rw [Set.nonempty_image_iff]\n  use 0, S.zero_mem\n#align quotient_norm_eq_zero_iff quotient_norm_eq_zero_iff\n-/\n\n",
 "quotient_norm_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print AddSubgroup.quotient_norm_eq /-\n/-\nCopyright (c) 2021 Patrick Massot. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Patrick Massot, Riccardo Brasca\n-/\ntheorem AddSubgroup.quotient_norm_eq {S : AddSubgroup M} (x : «expr ⧸ » M S) :\n    «expr‖ ‖» x = infₛ («expr '' » norm { m : M | (m : «expr ⧸ » M S) = x }) :=\n  rfl\n#align add_subgroup.quotient_norm_eq AddSubgroup.quotient_norm_eq\n-/\n\n",
 "quotient_norm_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_norm_add_le /-\n/-- The quotient norm satisfies the triangle inequality. -/\ntheorem quotient_norm_add_le (S : AddSubgroup M) (x y : «expr ⧸ » M S) :\n    «expr‖ ‖» (x + y) ≤ «expr‖ ‖» x + «expr‖ ‖» y :=\n  by\n  refine' le_of_forall_pos_le_add fun ε hε => _\n  replace hε := half_pos hε\n  obtain ⟨m, rfl, hm : «expr‖ ‖» m < «expr‖ ‖» (mk' S m) + ε / 2⟩ := norm_mk_lt x hε\n  obtain ⟨n, rfl, hn : «expr‖ ‖» n < «expr‖ ‖» (mk' S n) + ε / 2⟩ := norm_mk_lt y hε\n  calc\n    «expr‖ ‖» (mk' S m + mk' S n) = «expr‖ ‖» (mk' S (m + n)) := by rw [(mk' S).map_add]\n    _ ≤ «expr‖ ‖» (m + n) := (quotient_norm_mk_le S (m + n))\n    _ ≤ «expr‖ ‖» m + «expr‖ ‖» n := (norm_add_le _ _)\n    _ ≤ «expr‖ ‖» (mk' S m) + «expr‖ ‖» (mk' S n) + ε := by linarith\n    \n#align quotient_norm_add_le quotient_norm_add_le\n-/\n\n",
 "quotient_nhd_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print quotient_nhd_basis /-\ntheorem quotient_nhd_basis (S : AddSubgroup M) :\n    ((nhds) (0 : «expr ⧸ » M S)).has_basis (fun ε : exprℝ => 0 < ε) fun ε => { x | «expr‖ ‖» x < ε } :=\n  ⟨by\n    intro U\n    constructor\n    · intro U_in\n      rw [← (mk' S).map_zero] at U_in\n      have := preimage_nhds_coinduced U_in\n      rcases metric.mem_nhds_iff.mp this with ⟨ε, ε_pos, H⟩\n      use ε / 2, half_pos ε_pos\n      intro x x_in\n      dsimp at x_in\n      rcases norm_mk_lt x (half_pos ε_pos) with ⟨y, rfl, ry⟩\n      apply H\n      rw [ball_zero_eq]\n      dsimp\n      linarith\n    · rintro ⟨ε, ε_pos, h⟩\n      have : «expr '' » (mk' S) (ball (0 : M) ε) ⊆ { x | «expr‖ ‖» x < ε } :=\n        by\n        rintro _ ⟨x, x_in, rfl⟩\n        rw [mem_ball_zero_iff] at x_in\n        exact lt_of_le_of_lt (quotient_norm_mk_le S x) x_in\n      apply Filter.mem_of_superset _ (Set.Subset.trans this h)\n      clear h U this\n      apply IsOpen.mem_nhds\n      · change IsOpen («expr ⁻¹' » (mk' S) _)\n        erw [QuotientAddGroup.preimage_image_mk]\n        apply isOpen_unionᵢ\n        rintro ⟨s, s_in⟩\n        exact (continuous_add_right s).is_open_preimage _ is_open_ball\n      · exact ⟨(0 : M), mem_ball_self ε_pos, (mk' S).map_zero⟩⟩\n#align quotient_nhd_basis quotient_nhd_basis\n-/\n\n",
 "norm_trivial_quotient_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The operator norm of the projection is `0` if the subspace is dense. -/\ntheorem norm_trivial_quotient_mk (S : AddSubgroup M) (h : (S.topological_closure : Set M) = Set.univ) :\n    «expr‖ ‖» S.normed_mk = 0 :=\n  by\n  refine' le_antisymm (op_norm_le_bound _ le_rfl fun x => _) (norm_nonneg _)\n  have hker : x ∈ S.normed_mk.ker.topological_closure :=\n    by\n    rw [S.ker_normed_mk]\n    exact Set.mem_of_eq_of_mem h trivial\n  rw [ker_normed_mk] at hker\n  simp only [(quotient_norm_eq_zero_iff S x).mpr hker, normed_mk.apply, MulZeroClass.zero_mul]\n#align norm_trivial_quotient_mk norm_trivial_quotient_mk\n\n",
 "norm_normed_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The operator norm of the projection is at most `1`. -/\ntheorem norm_normed_mk_le (S : AddSubgroup M) : «expr‖ ‖» S.normed_mk ≤ 1 :=\n  NormedAddGroupHom.opNorm_le_bound _ zero_le_one fun m => by simp [quotient_norm_mk_le']\n#align norm_normed_mk_le norm_normed_mk_le\n\n",
 "norm_normed_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The operator norm of the projection is `1` if the subspace is not dense. -/\ntheorem norm_normed_mk (S : AddSubgroup M) (h : (S.topological_closure : Set M) ≠ univ) : «expr‖ ‖» S.normed_mk = 1 :=\n  by\n  obtain ⟨x, hx⟩ := Set.nonempty_compl.2 h\n  let y := S.normed_mk x\n  have hy : «expr‖ ‖» y ≠ 0 := by\n    intro h0\n    exact Set.not_mem_of_mem_compl hx ((quotient_norm_eq_zero_iff S x).1 h0)\n  refine' le_antisymm (norm_normed_mk_le S) (le_of_forall_pos_le_add fun ε hε => _)\n  suffices 1 ≤ «expr‖ ‖» S.normed_mk + min ε ((1 : exprℝ) / 2) by\n    exact le_add_of_le_add_left this (min_le_left ε ((1 : exprℝ) / 2))\n  have hδ := sub_pos.mpr (lt_of_le_of_lt (min_le_right ε ((1 : exprℝ) / 2)) one_half_lt_one)\n  have hδpos : 0 < min ε ((1 : exprℝ) / 2) := lt_min hε one_half_pos\n  have hδnorm := mul_pos (div_pos hδpos hδ) (lt_of_le_of_ne (norm_nonneg y) hy.symm)\n  obtain ⟨m, hm, hlt⟩ := norm_mk_lt y hδnorm\n  have hrw :\n    «expr‖ ‖» y + min ε (1 / 2) / (1 - min ε (1 / 2)) * «expr‖ ‖» y =\n      «expr‖ ‖» y * (1 + min ε (1 / 2) / (1 - min ε (1 / 2))) :=\n    by ring\n  rw [hrw] at hlt\n  have hm0 : «expr‖ ‖» m ≠ 0 := by\n    intro h0\n    have hnorm := quotient_norm_mk_le S m\n    rw [h0, hm] at hnorm\n    replace hnorm := le_antisymm hnorm (norm_nonneg _)\n    simpa [hnorm] using hy\n  replace hlt := (div_lt_div_right (lt_of_le_of_ne (norm_nonneg m) hm0.symm)).2 hlt\n  simp only [hm0, div_self, ne.def, not_false_iff] at hlt\n  have hrw₁ :\n    «expr‖ ‖» y * (1 + min ε (1 / 2) / (1 - min ε (1 / 2))) / «expr‖ ‖» m =\n      «expr‖ ‖» y / «expr‖ ‖» m * (1 + min ε (1 / 2) / (1 - min ε (1 / 2))) :=\n    by ring\n  rw [hrw₁] at hlt\n  replace hlt := (inv_pos_lt_iff_one_lt_mul (lt_trans (div_pos hδpos hδ) (lt_one_add _))).2 hlt\n  suffices «expr‖ ‖» S.normed_mk ≥ 1 - min ε (1 / 2) by exact sub_le_iff_le_add.mp this\n  calc\n    «expr‖ ‖» S.normed_mk ≥ «expr‖ ‖» (S.normed_mk m) / «expr‖ ‖» m := ratio_le_op_norm S.normed_mk m\n    _ = «expr‖ ‖» y / «expr‖ ‖» m := by rw [normed_mk.apply, hm]\n    _ ≥ (1 + min ε (1 / 2) / (1 - min ε (1 / 2)))⁻¹ := (le_of_lt hlt)\n    _ = 1 - min ε (1 / 2) := by field_simp [(ne_of_lt hδ).symm]\n    \n#align norm_normed_mk norm_normed_mk\n\n",
 "norm_mk_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print norm_mk_zero /-\n/-- The quotient norm of `0` is `0`. -/\ntheorem norm_mk_zero (S : AddSubgroup M) : «expr‖ ‖» (0 : «expr ⧸ » M S) = 0 :=\n  by\n  erw [quotient_norm_eq_zero_iff]\n  exact subset_closure S.zero_mem\n#align norm_mk_zero norm_mk_zero\n-/\n\n",
 "norm_mk_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print norm_mk_nonneg /-\n/-- The quotient norm is nonnegative. -/\ntheorem norm_mk_nonneg (S : AddSubgroup M) (m : M) : 0 ≤ «expr‖ ‖» (mk' S m) :=\n  quotient_norm_nonneg S _\n#align norm_mk_nonneg norm_mk_nonneg\n-/\n\n",
 "norm_mk_lt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print norm_mk_lt' /-\n/-- For any `m : M` and any `0 < ε`, there is `s ∈ S` such that `‖m + s‖ < ‖mk' S m‖ + ε`. -/\ntheorem norm_mk_lt' (S : AddSubgroup M) (m : M) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ s ∈ S, «expr‖ ‖» (m + s) < «expr‖ ‖» (mk' S m) + ε :=\n  by\n  obtain ⟨n : M, hn : mk' S n = mk' S m, hn' : «expr‖ ‖» n < «expr‖ ‖» (mk' S m) + ε⟩ :=\n    norm_mk_lt (QuotientAddGroup.mk' S m) hε\n  erw [eq_comm, QuotientAddGroup.eq] at hn\n  use -m + n, hn\n  rwa [add_neg_cancel_left]\n#align norm_mk_lt' norm_mk_lt'\n-/\n\n",
 "norm_mk_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print Ideal.Quotient.norm_mk_lt /-\ntheorem Ideal.Quotient.norm_mk_lt {I : Ideal R} (x : «expr ⧸ » R I) {ε : exprℝ} (hε : 0 < ε) :\n    ∃ r : R, Ideal.Quotient.mk I r = x ∧ «expr‖ ‖» r < «expr‖ ‖» x + ε :=\n  norm_mk_lt x hε\n#align ideal.quotient.norm_mk_lt Ideal.Quotient.norm_mk_lt\n-/\n\n",
 "norm_mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print Ideal.Quotient.norm_mk_le /-\ntheorem Ideal.Quotient.norm_mk_le (r : R) : «expr‖ ‖» (Ideal.Quotient.mk I r) ≤ «expr‖ ‖» r :=\n  quotient_norm_mk_le I.to_add_subgroup r\n#align ideal.quotient.norm_mk_le Ideal.Quotient.norm_mk_le\n-/\n\n",
 "norm_mk_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n#print norm_mk_eq_zero /-\n/-- If `(m : M)` has norm equal to `0` in `M ⧸ S` for a closed subgroup `S` of `M`, then\n`m ∈ S`. -/\ntheorem norm_mk_eq_zero (S : AddSubgroup M) (hS : IsClosed (S : Set M)) (m : M) (h : «expr‖ ‖» (mk' S m) = 0) : m ∈ S :=\n  by rwa [quotient_norm_eq_zero_iff, hS.closure_eq] at h\n#align norm_zero_eq_zero norm_mk_eq_zero\n-/\n\n",
 "norm_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_quotient.norm_lift {f : NormedAddGroupHom M N} (hquot : IsQuotient f) {ε : exprℝ} (hε : 0 < ε) (n : N) :\n    ∃ m : M, f m = n ∧ «expr‖ ‖» m < «expr‖ ‖» n + ε :=\n  by\n  obtain ⟨m, rfl⟩ := hquot.surjective n\n  have nonemp : («expr '' » (fun m' => «expr‖ ‖» (m + m')) f.ker).nonempty :=\n    by\n    rw [Set.nonempty_image_iff]\n    exact ⟨0, f.ker.zero_mem⟩\n  rcases Real.lt_infₛ_add_pos nonemp hε with\n    ⟨_, ⟨⟨x, hx, rfl⟩, H : «expr‖ ‖» (m + x) < Inf («expr '' » (fun m' : M => «expr‖ ‖» (m + m')) f.ker) + ε⟩⟩\n  exact ⟨m + x, by rw [map_add, (NormedAddGroupHom.mem_ker f x).mp hx, add_zero], by rwa [hquot.norm]⟩\n#align is_quotient.norm_lift is_quotient.norm_lift\n\n",
 "norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_quotient.norm_le {f : NormedAddGroupHom M N} (hquot : IsQuotient f) (m : M) :\n    «expr‖ ‖» (f m) ≤ «expr‖ ‖» m := by\n  rw [hquot.norm]\n  apply cinfₛ_le\n  · use 0\n    rintro _ ⟨m', hm', rfl⟩\n    apply norm_nonneg\n  · exact ⟨0, f.ker.zero_mem, by simp⟩\n#align is_quotient.norm_le is_quotient.norm_le\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem lift_unique {N : Type _} [SeminormedAddCommGroup N] (S : AddSubgroup M) (f : NormedAddGroupHom M N)\n    (hf : ∀ s ∈ S, f s = 0) (g : NormedAddGroupHom («expr ⧸ » M S) N) : g.comp S.normed_mk = f → g = lift S f hf :=\n  by\n  intro h\n  ext\n  rcases AddSubgroup.surjective_normedMk _ x with ⟨x, rfl⟩\n  change g.comp S.normed_mk x = _\n  simpa only [h]\n#align lift_unique lift_unique\n\n",
 "lift_norm_noninc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem lift_norm_noninc {N : Type _} [SeminormedAddCommGroup N] (S : AddSubgroup M) (f : NormedAddGroupHom M N)\n    (hf : ∀ s ∈ S, f s = 0) (fb : f.norm_noninc) : (lift S f hf).norm_noninc := fun x =>\n  by\n  have fb' : «expr‖ ‖» f ≤ (1 : nnreal) := norm_noninc.norm_noninc_iff_norm_le_one.mp fb\n  simpa using le_of_op_norm_le _ (f.lift_norm_le _ _ fb') _\n#align lift_norm_noninc lift_norm_noninc\n\n",
 "lift_norm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem lift_norm_le {N : Type _} [SeminormedAddCommGroup N] (S : AddSubgroup M) (f : NormedAddGroupHom M N)\n    (hf : ∀ s ∈ S, f s = 0) {c : nnreal} (fb : «expr‖ ‖» f ≤ c) : «expr‖ ‖» (lift S f hf) ≤ c :=\n  by\n  apply op_norm_le_bound _ c.coe_nonneg\n  intro x\n  by_cases hc : c = 0\n  · simp only [hc, NNReal.coe_zero, MulZeroClass.zero_mul] at fb⊢\n    obtain ⟨x, rfl⟩ := surjective_quot_mk _ x\n    show «expr‖ ‖» (f x) ≤ 0\n    calc\n      «expr‖ ‖» (f x) ≤ 0 * «expr‖ ‖» x := f.le_of_op_norm_le fb x\n      _ = 0 := MulZeroClass.zero_mul _\n      \n  · replace hc : 0 < c := pos_iff_ne_zero.mpr hc\n    apply le_of_forall_pos_le_add\n    intro ε hε\n    have aux : 0 < ε / c := div_pos hε hc\n    obtain ⟨x, rfl, Hx⟩ : ∃ x', S.normed_mk x' = x ∧ «expr‖ ‖» x' < «expr‖ ‖» x + ε / c :=\n      (is_quotient_quotient _).norm_lift aux _\n    rw [lift_mk]\n    calc\n      «expr‖ ‖» (f x) ≤ c * «expr‖ ‖» x := f.le_of_op_norm_le fb x\n      _ ≤ c * («expr‖ ‖» (S.normed_mk x) + ε / c) := ((mul_le_mul_left _).mpr Hx.le)\n      _ = c * _ + ε := _\n      \n    · exact_mod_cast hc\n    · rw [mul_add, mul_div_cancel']\n      exact_mod_cast hc.ne'\n#align lift_norm_le lift_norm_le\n\n",
 "lift_mk":
 "theorem lift_mk {N : Type _} [SeminormedAddCommGroup N] (S : AddSubgroup M) (f : NormedAddGroupHom M N)\n    (hf : ∀ s ∈ S, f s = 0) (m : M) : lift S f hf (S.normed_mk m) = f m :=\n  rfl\n#align lift_mk lift_mk\n\n",
 "ker_normed_mk":
 "/-- The kernel of `S.normed_mk` is `S`. -/\ntheorem ker_normed_mk (S : AddSubgroup M) : S.normed_mk.ker = S :=\n  QuotientAddGroup.ker_mk' _\n#align ker_normed_mk ker_normed_mk\n\n",
 "is_quotient_quotient":
 "/-- `S.normed_mk` satisfies `is_quotient`. -/\ntheorem is_quotient_quotient (S : AddSubgroup M) : IsQuotient S.normed_mk :=\n  ⟨S.surjective_normed_mk, fun m => by simpa [S.ker_normed_mk] using quotient_norm_mk_eq _ m⟩\n#align is_quotient_quotient is_quotient_quotient\n\n",
 "image_norm_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print image_norm_nonempty /-\ntheorem image_norm_nonempty {S : AddSubgroup M} : ∀ x : «expr ⧸ » M S, («expr '' » norm { m | mk' S m = x }).nonempty :=\n  by\n  rintro ⟨m⟩\n  rw [Set.nonempty_image_iff]\n  use m\n  change mk' S m = _\n  rfl\n#align image_norm_nonempty image_norm_nonempty\n-/\n\n",
 "bddBelow_image_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print bddBelow_image_norm /-\ntheorem bddBelow_image_norm (s : Set M) : BddBelow («expr '' » norm s) :=\n  by\n  use 0\n  rintro _ ⟨x, hx, rfl⟩\n  apply norm_nonneg\n#align bdd_below_image_norm bddBelow_image_norm\n-/\n\n",
 "apply":
 "-- This is a sanity check left here on purpose to ensure that potential refactors won't destroy\n-- this important property.\n-- This is a sanity check left here on purpose to ensure that potential refactors won't destroy\n-- this important property.\n/-- `S.normed_mk` agrees with `quotient_add_group.mk' S`. -/\n@[simp]\ntheorem normed_mk.apply (S : AddSubgroup M) (m : M) : normedMk S m = QuotientAddGroup.mk' S m :=\n  rfl\n#align normed_mk.apply normed_mk.apply\n\n"}