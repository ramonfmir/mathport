{"vector_fourier_integral_eq_integral_exp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem vector_fourier_integral_eq_integral_exp_smul {V : Type _} [AddCommGroup V] [Module (exprℝ) V]\n    [MeasurableSpace V] {W : Type _} [AddCommGroup W] [Module (exprℝ) W]\n    (L : «expr →ₗ[ ] » V (exprℝ) («expr →ₗ[ ] » W (exprℝ) (exprℝ))) (μ : measure V) (f : V → E) (w : W) :\n    vector_fourier.fourier_integral fourier_char μ L f w =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr • » (Complex.exp (↑(-2 * real.pi * L v w) * Complex.I)) (f v)) μ :=\n  by simp_rw [vector_fourier.fourier_integral, real.fourier_char_apply, mul_neg, neg_mul]\n#align vector_fourier_integral_eq_integral_exp_smul vector_fourier_integral_eq_integral_exp_smul\n\n",
 "norm_fourier_integral_le_integral_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The uniform norm of the Fourier transform of `f` is bounded by the `L¹` norm of `f`. -/\ntheorem norm_fourier_integral_le_integral_norm (e : «expr →* » (Multiplicative 𝕜) (expr𝕊)) (μ : measure 𝕜) (f : 𝕜 → E)\n    (w : 𝕜) :\n    «expr‖ ‖» (fourier_integral e μ f w) ≤\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        («expr‖ ‖» (f x)) μ :=\n  vector_fourier.norm_fourier_integral_le_integral_norm _ _ _ _ _\n#align norm_fourier_integral_le_integral_norm norm_fourier_integral_le_integral_norm\n\n",
 "fourier_integral_smul_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fourier_integral_smul_const (e : «expr →* » (Multiplicative 𝕜) (expr𝕊)) (μ : measure 𝕜) (f : 𝕜 → E)\n    (r : exprℂ) : fourier_integral e μ («expr • » r f) = «expr • » r (fourier_integral e μ f) :=\n  vector_fourier.fourier_integral_smul_const _ _ _ _ _\n#align fourier_integral_smul_const fourier_integral_smul_const\n\n",
 "fourier_integral_eq_integral_exp_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem fourier_integral_eq_integral_exp_smul {E : Type _} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedSpace (exprℂ) E] (f : exprℝ → E) (w : exprℝ) :\n    (fourier_integral) f w =\n      «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n        («expr • » (Complex.exp (↑(-2 * real.pi * v * w) * Complex.I)) (f v)) :=\n  by simp_rw [fourier_integral_def, real.fourier_char_apply, mul_neg, neg_mul, mul_assoc]\n#align fourier_integral_eq_integral_exp_smul fourier_integral_eq_integral_exp_smul\n\n",
 "fourier_integral_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\ntheorem fourier_integral_def (f : exprℝ → E) (w : exprℝ) :\n    fourier_integral f w =\n      «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n        («expr • » («expr [ ]» fourier_char (-(v * w))) (f v)) :=\n  rfl\n#align fourier_integral_def fourier_integral_def\n\n",
 "fourier_integral_convergent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- In this section we assume 𝕜, V, W have topologies, and L, e are continuous (but f needn't be).\n   This is used to ensure that `e [-L v w]` is (ae strongly) measurable. We could get away with\n   imposing only a measurable-space structure on 𝕜 (it doesn't have to be the Borel sigma-algebra of\n   a topology); but it seems hard to imagine cases where this extra generality would be useful, and\n   allowing it would complicate matters in the most important use cases.\n-/\n/-- For any `w`, the Fourier integral is convergent iff `f` is integrable. -/\ntheorem fourier_integral_convergent_iff (he : Continuous e) (hL : Continuous fun p : V × W => L p.1 p.2) {f : V → E}\n    (w : W) : integrable f μ ↔ integrable (fun v : V => «expr • » («expr [ ]» e (-L v w)) (f v)) μ :=\n  by\n  -- first prove one-way implication\n  have aux :\n    ∀ {g : V → E} (hg : integrable g μ) (x : W), integrable (fun v : V => «expr • » («expr [ ]» e (-L v x)) (g v)) μ :=\n    by\n    intro g hg x\n    have c : Continuous fun v => «expr [ ]» e (-L v x) :=\n      by\n      refine' (continuous_induced_rng.mp he).comp (continuous_of_add.comp (Continuous.neg _))\n      exact hL.comp (continuous_prod_mk.mpr ⟨continuous_id, continuous_const⟩)\n    rw [← integrable_norm_iff (c.ae_strongly_measurable.smul hg.1)]\n    convert hg.norm\n    ext1 v\n    rw [norm_smul, complex.norm_eq_abs, abs_coe_circle, one_mul]\n  -- then use it for both directions\n  refine' ⟨fun hf => aux hf w, fun hf => _⟩\n  convert aux hf (-w)\n  ext1 v\n  rw [← smul_assoc, smul_eq_mul, ← Submonoid.coe_mul, ← MonoidHom.map_mul, ← ofAdd_add, LinearMap.map_neg, neg_neg, ←\n    sub_eq_add_neg, sub_self, ofAdd_zero, MonoidHom.map_one, Submonoid.coe_one, one_smul]\n#align fourier_integral_convergent_iff fourier_integral_convergent_iff\n\n",
 "fourier_integral_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- The Fourier integral of an `L^1` function is a continuous function. -/\ntheorem fourier_integral_continuous [TopologicalSpace.FirstCountableTopology W] (he : Continuous e)\n    (hL : Continuous fun p : V × W => L p.1 p.2) {f : V → E} (hf : integrable f μ) :\n    Continuous (fourier_integral e μ L f) := by\n  apply continuous_of_dominated\n  · exact fun w => ((fourier_integral_convergent_iff he hL w).mp hf).1\n  · refine' fun w => ae_of_all _ fun v => _\n    · exact fun v => «expr‖ ‖» (f v)\n    · rw [norm_smul, complex.norm_eq_abs, abs_coe_circle, one_mul]\n  · exact hf.norm\n  · rw [continuous_induced_rng] at he\n    refine' ae_of_all _ fun v => (he.comp (continuous_of_add.comp _)).smul continuous_const\n    refine' (hL.comp (continuous_prod_mk.mpr ⟨continuous_const, continuous_id⟩)).neg\n#align fourier_integral_continuous fourier_integral_continuous\n\n",
 "fourier_integral_comp_add_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕊 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/-- The Fourier transform converts right-translation into scalar multiplication by a phase factor.-/\ntheorem fourier_integral_comp_add_right [MeasurableAdd 𝕜] (e : «expr →* » (Multiplicative 𝕜) (expr𝕊)) (μ : measure 𝕜)\n    [μ.is_add_right_invariant] (f : 𝕜 → E) (v₀ : 𝕜) :\n    fourier_integral e μ (f ∘ fun v => v + v₀) = fun w =>\n      «expr • » («expr [ ]» e (v₀ * w)) (fourier_integral e μ f w) :=\n  vector_fourier.fourier_integral_comp_add_right _ _ _ _ _\n#align fourier_integral_comp_add_right fourier_integral_comp_add_right\n\n",
 "fourier_integral_add":
 "theorem fourier_integral_add (he : Continuous e) (hL : Continuous fun p : V × W => L p.1 p.2) {f g : V → E}\n    (hf : integrable f μ) (hg : integrable g μ) :\n    fourier_integral e μ L f + fourier_integral e μ L g = fourier_integral e μ L (f + g) :=\n  by\n  ext1 w\n  dsimp only [Pi.add_apply, fourier_integral]\n  simp_rw [smul_add]\n  rw [integral_add]\n  · exact (fourier_integral_convergent_iff he hL w).mp hf\n  · exact (fourier_integral_convergent_iff he hL w).mp hg\n#align fourier_integral_add fourier_integral_add\n\n",
 "fourier_char_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem fourier_char_apply (x : exprℝ) :\n    «expr [ ]» real.fourier_char x = Complex.exp (↑(2 * real.pi * x) * Complex.I) := by rfl\n#align fourier_char_apply fourier_char_apply\n\n",
 "continuous_fourier_char":
 "@[continuity]\ntheorem continuous_fourier_char : Continuous real.fourier_char :=\n  (map_continuous exp_map_circle).comp (continuous_const.mul continuous_toAdd)\n#align continuous_fourier_char continuous_fourier_char\n\n"}