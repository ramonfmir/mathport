{"tsum_eq_tsum_fourier_integral_of_rpow_decay_of_summable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/-- **Poisson's summation formula**, assuming that `f` decays as\n`|x| ^ (-b)` for some `1 < b` and its Fourier transform is summable. -/\ntheorem real.tsum_eq_tsum_fourier_integral_of_rpow_decay_of_summable {f : exprℝ → exprℂ} (hc : Continuous f) {b : exprℝ}\n    (hb : 1 < b) (hf : IsBigO (cocompact (exprℝ)) f fun x : exprℝ => |x| ^ (-b))\n    (hFf : Summable fun n : ℤ => (fourier_integral) f n) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f n) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        ((fourier_integral) f n) :=\n  real.tsum_eq_tsum_fourier_integral\n    (fun K =>\n      summable_of_isBigO (real.summable_abs_int_rpow hb)\n        ((is_O_norm_restrict_cocompact (continuous_map.mk _ hc) (zero_lt_one.trans hb) hf K).comp_tendsto\n          Int.tendsto_coe_cofinite))\n    hFf\n#align real.tsum_eq_tsum_fourier_integral_of_rpow_decay_of_summable real.tsum_eq_tsum_fourier_integral_of_rpow_decay_of_summable\n\n",
 "tsum_eq_tsum_fourier_integral_of_rpow_decay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/-- **Poisson's summation formula**, assuming that both `f` and its Fourier transform decay as\n`|x| ^ (-b)` for some `1 < b`. (This is the one-dimensional case of Corollary VII.2.6 of Stein and\nWeiss, *Introduction to Fourier analysis on Euclidean spaces*.) -/\ntheorem real.tsum_eq_tsum_fourier_integral_of_rpow_decay {f : exprℝ → exprℂ} (hc : Continuous f) {b : exprℝ}\n    (hb : 1 < b) (hf : IsBigO (cocompact (exprℝ)) f fun x : exprℝ => |x| ^ (-b))\n    (hFf : IsBigO (cocompact (exprℝ)) ((fourier_integral) f) fun x : exprℝ => |x| ^ (-b)) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f n) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        ((fourier_integral) f n) :=\n  real.tsum_eq_tsum_fourier_integral_of_rpow_decay_of_summable hc hb hf\n    (summable_of_isBigO (real.summable_abs_int_rpow hb) (hFf.comp_tendsto Int.tendsto_coe_cofinite))\n#align real.tsum_eq_tsum_fourier_integral_of_rpow_decay real.tsum_eq_tsum_fourier_integral_of_rpow_decay\n\n",
 "tsum_eq_tsum_fourier_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/-- **Poisson's summation formula** for Schwartz functions. -/\ntheorem schwartz_map.tsum_eq_tsum_fourier_integral (f g : schwartz_map (exprℝ) (exprℂ))\n    (hfg : (fourier_integral) f = g) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (f n) =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (g n) :=\n  by\n  -- We know that Schwartz functions are `O(‖x ^ (-b)‖)` for *every* `b`; for this argument we take\n  -- `b = 2` and work with that.\n  simp_rw [← hfg]\n  exact\n    real.tsum_eq_tsum_fourier_integral_of_rpow_decay f.continuous one_lt_two (f.is_O_cocompact_rpow (-2))\n      (by simpa only [hfg] using g.is_O_cocompact_rpow (-2))\n#align schwartz_map.tsum_eq_tsum_fourier_integral schwartz_map.tsum_eq_tsum_fourier_integral\n\n",
 "is_O_norm_restrict_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem is_O_norm_restrict_cocompact (f : «exprC( , )» (exprℝ) E) {b : exprℝ} (hb : 0 < b)\n    (hf : IsBigO (cocompact (exprℝ)) f fun x : exprℝ => |x| ^ (-b)) (K : Compacts (exprℝ)) :\n    IsBigO (cocompact (exprℝ)) (fun x => «expr‖ ‖» ((f.comp (ContinuousMap.addRight x)).restrict K)) fun x =>\n      |x| ^ (-b) :=\n  by\n  obtain ⟨r, hr⟩ := K.is_compact.bounded.subset_ball 0\n  rw [closed_ball_eq_Icc, zero_add, zero_sub] at hr\n  have :\n    ∀ x : exprℝ,\n      «expr‖ ‖» ((f.comp (ContinuousMap.addRight x)).restrict K) ≤ «expr‖ ‖» (f.restrict (Icc (x - r) (x + r))) :=\n    by\n    intro x\n    rw [continuous_map.norm_le _ (norm_nonneg _)]\n    rintro ⟨y, hy⟩\n    refine' (le_of_eq _).trans (continuous_map.norm_coe_le_norm _ ⟨y + x, _⟩)\n    exact ⟨by linarith [(hr hy).1], by linarith [(hr hy).2]⟩\n    simp_rw [ContinuousMap.restrict_apply, ContinuousMap.comp_apply, ContinuousMap.coe_addRight, Subtype.coe_mk]\n  simp_rw [cocompact_eq, is_O_sup] at hf⊢\n  constructor\n  · refine' (is_O_of_le at_bot _).trans (is_O_norm_Icc_restrict_at_bot hb hf.1 (-r) r)\n    simp_rw [norm_norm]\n    exact this\n  · refine' (is_O_of_le at_top _).trans (is_O_norm_Icc_restrict_at_top hb hf.2 (-r) r)\n    simp_rw [norm_norm]\n    exact this\n#align is_O_norm_restrict_cocompact is_O_norm_restrict_cocompact\n\n",
 "is_O_norm_Icc_restrict_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If `f` is `O(x ^ (-b))` at infinity, then so is the function\n`λ x, ‖f.restrict (Icc (x + R) (x + S))‖` for any fixed `R` and `S`. -/\ntheorem is_O_norm_Icc_restrict_at_top {f : «exprC( , )» (exprℝ) E} {b : exprℝ} (hb : 0 < b)\n    (hf : IsBigO atTop f fun x : exprℝ => |x| ^ (-b)) (R S : exprℝ) :\n    IsBigO atTop (fun x : exprℝ => «expr‖ ‖» (f.restrict (Icc (x + R) (x + S)))) fun x : exprℝ => |x| ^ (-b) :=\n  by\n  -- First establish an explicit estimate on decay of inverse powers.\n  -- This is logically independent of the rest of the proof, but of no mathematical interest in\n  -- itself, so it is proved using `async` rather than being formulated as a separate lemma.\n  have claim : ∀ x : exprℝ, max 0 (-2 * R) < x → ∀ y : exprℝ, x + R ≤ y → y ^ (-b) ≤ (1 / 2) ^ (-b) * x ^ (-b) :=\n    by\n    intro x hx y hy\n    rw [max_lt_iff] at hx\n    have hxR : 0 < x + R := by\n      rcases le_or_lt 0 R with (h | h)\n      · exact add_pos_of_pos_of_nonneg hx.1 h\n      · rw [← sub_lt_iff_lt_add, zero_sub]\n        refine' lt_trans _ hx.2\n        rwa [neg_mul, neg_lt_neg_iff, two_mul, add_lt_iff_neg_left]\n    have hy' : 0 < y := hxR.trans_le hy\n    have : y ^ (-b) ≤ (x + R) ^ (-b) :=\n      by\n      rw [rpow_neg hy'.le, rpow_neg hxR.le, inv_le_inv (rpow_pos_of_pos hy' _) (rpow_pos_of_pos hxR _)]\n      exact rpow_le_rpow hxR.le hy hb.le\n    refine' this.trans _\n    rw [← mul_rpow one_half_pos.le hx.1.le, rpow_neg (mul_pos one_half_pos hx.1).le, rpow_neg hxR.le]\n    refine' inv_le_inv_of_le (rpow_pos_of_pos (mul_pos one_half_pos hx.1) _) _\n    exact rpow_le_rpow (mul_pos one_half_pos hx.1).le (by linarith) hb.le\n  -- Now the main proof.\n  obtain ⟨c, hc, hc'⟩ := hf.exists_pos\n  simp only [is_O, is_O_with, eventually_at_top] at hc'⊢\n  obtain ⟨d, hd⟩ := hc'\n  refine' ⟨c * (1 / 2) ^ (-b), ⟨max (1 + max 0 (-2 * R)) (d - R), fun x hx => _⟩⟩\n  rw [ge_iff_le, max_le_iff] at hx\n  have hx' : max 0 (-2 * R) < x := by linarith\n  rw [max_lt_iff] at hx'\n  rw [norm_norm,\n    continuous_map.norm_le _ (mul_nonneg (mul_nonneg hc.le <| rpow_nonneg_of_nonneg one_half_pos.le _) (norm_nonneg _))]\n  refine' fun y => (hd y.1 (by linarith [hx.1, y.2.1])).trans _\n  have A : ∀ x : exprℝ, 0 ≤ |x| ^ (-b) := fun x => by positivity\n  rwa [mul_assoc, mul_le_mul_left hc, norm_of_nonneg (A _), norm_of_nonneg (A _)]\n  convert claim x (by linarith only [hx.1]) y.1 y.2.1\n  · apply abs_of_nonneg\n    linarith [y.2.1]\n  · exact abs_of_pos hx'.1\n#align is_O_norm_Icc_restrict_at_top is_O_norm_Icc_restrict_at_top\n\n",
 "is_O_norm_Icc_restrict_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_O_norm_Icc_restrict_at_bot {f : «exprC( , )» (exprℝ) E} {b : exprℝ} (hb : 0 < b)\n    (hf : IsBigO atBot f fun x : exprℝ => |x| ^ (-b)) (R S : exprℝ) :\n    IsBigO atBot (fun x : exprℝ => «expr‖ ‖» (f.restrict (Icc (x + R) (x + S)))) fun x : exprℝ => |x| ^ (-b) :=\n  by\n  have h1 : is_O at_top (f.comp (continuous_map.mk _ continuous_neg)) fun x : exprℝ => |x| ^ (-b) :=\n    by\n    convert hf.comp_tendsto tendsto_neg_at_top_at_bot\n    ext1 x\n    simp only [Function.comp_apply, abs_neg]\n  have h2 := (is_O_norm_Icc_restrict_at_top hb h1 (-S) (-R)).comp_tendsto tendsto_neg_at_bot_at_top\n  have : (fun x : exprℝ => |x| ^ (-b)) ∘ has_neg.neg = fun x : exprℝ => |x| ^ (-b) :=\n    by\n    ext1 x\n    simp only [Function.comp_apply, abs_neg]\n  rw [this] at h2\n  refine' (is_O_of_le _ fun x => _).trans h2\n  -- equality holds, but less work to prove `≤` alone\n  rw [norm_norm, Function.comp_apply, norm_norm, continuous_map.norm_le _ (norm_nonneg _)]\n  rintro ⟨x, hx⟩\n  rw [ContinuousMap.restrict_apply_mk]\n  refine' (le_of_eq _).trans (continuous_map.norm_coe_le_norm _ ⟨-x, _⟩)\n  · exact ⟨by linarith [hx.2], by linarith [hx.1]⟩\n  · rw [ContinuousMap.restrict_apply_mk, ContinuousMap.comp_apply, ContinuousMap.coe_mk, neg_neg]\n#align is_O_norm_Icc_restrict_at_bot is_O_norm_Icc_restrict_at_bot\n\n",
 "fourier_coeff_tsum_comp_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/-\nCopyright (c) 2023 David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Loeffler\n-/\n/-- The key lemma for Poisson summation: the `m`-th Fourier coefficient of the periodic function\n`∑' n : ℤ, f (x + n)` is the value at `m` of the Fourier transform of `f`. -/\ntheorem real.fourier_coeff_tsum_comp_add {f : «exprC( , )» (exprℝ) (exprℂ)}\n    (hf : ∀ K : Compacts (exprℝ), Summable fun n : ℤ => «expr‖ ‖» ((f.comp (ContinuousMap.addRight n)).restrict K))\n    (m : ℤ) : fourier_coeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = (fourier_integral) f m :=\n  by\n  -- NB: This proof can be shortened somewhat by telescoping together some of the steps in the calc\n  -- block, but I think it's more legible this way. We start with preliminaries about the integrand.\n  let e : «exprC( , )» (exprℝ) (exprℂ) := (fourier (-m)).comp ⟨(coe : exprℝ → unit_add_circle), continuous_quotient_mk'⟩\n  have neK :\n    ∀ (K : compacts (exprℝ)) (g : «exprC( , )» (exprℝ) (exprℂ)),\n      «expr‖ ‖» ((e * g).restrict K) = «expr‖ ‖» (g.restrict K) :=\n    by\n    have : ∀ x : exprℝ, «expr‖ ‖» (e x) = 1 := fun x => abs_coe_circle _\n    intro K g\n    simp_rw [norm_eq_supr_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]\n  have eadd : ∀ n : ℤ, e.comp (ContinuousMap.addRight n) = e :=\n    by\n    intro n\n    ext1 x\n    have : periodic e 1 := periodic.comp (fun x => add_circle.coe_add_period 1 x) _\n    simpa only [mul_one] using this.int_mul n x\n  -- Now the main argument. First unwind some definitions.\n  calc\n    fourier_coeff (periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0 1\n          (e x *\n            («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n                (f.comp (ContinuousMap.addRight n)))\n              x) :=\n      by\n      simp_rw [fourier_coeff_eq_interval_integral _ m 0, div_one, one_smul, zero_add, comp_apply, coe_mk,\n        periodic.lift_coe, zsmul_one, smul_eq_mul]\n    -- Transform sum in C(ℝ, ℂ) evaluated at x into pointwise sum of values.\n        _ =\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0 1\n          («expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            ((e * f.comp (ContinuousMap.addRight n)) x)) :=\n      by simp_rw [coe_mul, Pi.mul_apply, ← tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]\n    -- Swap sum and integral.\n        _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n            1 ((e * f.comp (ContinuousMap.addRight n)) x)) :=\n      by\n      refine' (interval_integral.tsum_interval_integral_eq_of_summable_norm _).symm\n      convert hf ⟨uIcc 0 1, isCompact_uIcc⟩\n      exact funext fun n => neK _ _\n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          («expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n            1 ((e * f).comp (ContinuousMap.addRight n) x)) :=\n      by\n      simp only [ContinuousMap.comp_apply, mul_comp] at eadd⊢\n      simp_rw [eadd]\n    -- Rearrange sum of interval integrals into an integral over `ℝ`.\n        _ =\n        «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\" (e x * f x) :=\n      by\n      suffices : integrable («expr⇑ » (e * f)); exact this.has_sum_interval_integral_comp_add_int.tsum_eq\n      apply integrable_of_summable_norm_Icc\n      convert hf ⟨Icc 0 1, is_compact_Icc⟩\n      simp_rw [ContinuousMap.comp_apply, mul_comp] at eadd⊢\n      simp_rw [eadd]\n      exact funext fun n => neK ⟨Icc 0 1, is_compact_Icc⟩ _\n    -- Minor tidying to finish\n        _ =\n        (fourier_integral) f m :=\n      by\n      rw [fourier_integral_eq_integral_exp_smul]\n      congr 1 with x : 1\n      rw [smul_eq_mul, comp_apply, coe_mk, fourier_coe_apply]\n      congr 2\n      push_cast\n      ring\n    \n#align real.fourier_coeff_tsum_comp_add real.fourier_coeff_tsum_comp_add\n\n"}