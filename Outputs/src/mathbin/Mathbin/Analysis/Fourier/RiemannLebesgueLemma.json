{"zero_at_infty_vector_fourier_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The Riemann-Lebesgue lemma, formulated in terms of `vector_fourier.fourier_integral` (with the\npairing in the definition of `fourier_integral` taken to be the canonical pairing between `V` and\nits dual space). -/\ntheorem real.zero_at_infty_vector_fourier_integral (μ : measure V) [μ.is_add_haar_measure] :\n    Tendsto (vector_fourier.fourier_integral (expre) μ (topDualPairing (exprℝ) V).flip f)\n      (cocompact («expr →L[ ] » V (exprℝ) (exprℝ))) ((nhds) 0) :=\n  tendsto_integral_exp_smul_cocompact f μ\n#align real.zero_at_infty_vector_fourier_integral real.zero_at_infty_vector_fourier_integral\n\n",
 "zero_at_infty_fourier_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fourier_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The Riemann-Lebesgue lemma for functions on `ℝ`, formulated via `real.fourier_integral`. -/\ntheorem real.zero_at_infty_fourier_integral (f : exprℝ → E) :\n    Tendsto ((fourier_integral) f) (cocompact (exprℝ)) ((nhds) 0) :=\n  tendsto_integral_exp_inner_smul_cocompact f\n#align real.zero_at_infty_fourier_integral real.zero_at_infty_fourier_integral\n\n",
 "tendsto_integral_exp_smul_cocompact_of_inner_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional inner-product space, formulated\nvia dual space. **Do not use** -- it is only a stepping stone to\n`tendsto_integral_exp_smul_cocompact` where the inner-product-space structure isn't required. -/\ntheorem tendsto_integral_exp_smul_cocompact_of_inner_product (μ : measure V) [μ.is_add_haar_measure] :\n    Tendsto\n      (fun w : «expr →L[ ] » V (exprℝ) (exprℝ) =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr • » («expr [ ]» (expre) (-w v)) (f v)) μ)\n      (cocompact («expr →L[ ] » V (exprℝ) (exprℝ))) ((nhds) 0) :=\n  by\n  obtain ⟨C, C_ne_zero, C_ne_top, hC⟩ := μ.is_add_haar_measure_eq_smul_is_add_haar_measure volume\n  rw [hC]\n  simp_rw [integral_smul_measure]\n  rw [← (smul_zero _ : «expr • » C.to_real (0 : E) = 0)]\n  apply tendsto.const_smul\n  let A := (inner_product_space.to_dual (exprℝ) V).symm\n  have :\n    (fun w : «expr →L[ ] » V (exprℝ) (exprℝ) =>\n        «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n          («expr • » («expr [ ]» (expre) (-w v)) (f v))) =\n      (fun w : V =>\n          «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n            («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v))) ∘\n        A :=\n    by\n    ext1 w\n    congr 1 with v : 1\n    rw [← inner_conj_symm, IsROrC.conj_to_real, inner_product_space.to_dual_symm_apply, real.fourier_char_apply]\n  rw [this]\n  exact (tendsto_integral_exp_inner_smul_cocompact f).comp A.to_homeomorph.to_cocompact_map.cocompact_tendsto'\n#align tendsto_integral_exp_smul_cocompact_of_inner_product tendsto_integral_exp_smul_cocompact_of_inner_product\n\n",
 "tendsto_integral_exp_smul_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem tendsto_integral_exp_smul_cocompact (μ : measure V) [μ.is_add_haar_measure] :\n    Tendsto\n      (fun w : «expr →L[ ] » V (exprℝ) (exprℝ) =>\n        «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n          («expr • » («expr [ ]» (expre) (-w v)) (f v)) μ)\n      (cocompact («expr →L[ ] » V (exprℝ) (exprℝ))) ((nhds) 0) :=\n  by\n  -- We have already proved the result for inner-product spaces, formulated in a way which doesn't\n  -- refer to the inner product. So we choose an arbitrary inner-product space isomorphic to V\n  -- and port the result over from there.\n  let V' := euclidean_space (exprℝ) (Fin (finrank (exprℝ) V))\n  have A : «expr ≃L[ ] » V (exprℝ) V' := to_euclidean\n  borelize V'\n  -- various equivs derived from A\n  let Aₘ : MeasurableEquiv V V' := A.to_homeomorph.to_measurable_equiv\n  -- isomorphism between duals derived from A -- need to do continuity as a separate step in order\n  -- to apply `linear_map.continuous_of_finite_dimensional`.\n  let Adualₗ : «expr ≃ₗ[ ] » («expr →L[ ] » V (exprℝ) (exprℝ)) (exprℝ) («expr →L[ ] » V' (exprℝ) (exprℝ)) :=\n    { to_fun := fun t => t.comp A.symm.to_continuous_linear_map\n      inv_fun := fun t => t.comp A.to_continuous_linear_map\n      map_add' := by\n        intro t s\n        ext1 v\n        simp only [ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.add_apply]\n      map_smul' := by\n        intro x f\n        ext1 v\n        simp only [RingHom.id_apply, ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.smul_apply]\n      left_inv := by\n        intro w\n        ext1 v\n        simp only [[anonymous], ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, Function.comp_apply,\n          ContinuousLinearEquiv.symm_apply_apply]\n      right_inv := by\n        intro w\n        ext1 v\n        simp only [[anonymous], ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, Function.comp_apply,\n          ContinuousLinearEquiv.apply_symm_apply] }\n  let Adual : «expr ≃L[ ] » («expr →L[ ] » V (exprℝ) (exprℝ)) (exprℝ) («expr →L[ ] » V' (exprℝ) (exprℝ)) :=\n    { Adualₗ with\n      continuous_to_fun := Adualₗ.to_linear_map.continuous_of_finite_dimensional\n      continuous_inv_fun := Adualₗ.symm.to_linear_map.continuous_of_finite_dimensional }\n  have : (μ.map Aₘ).is_add_haar_measure := measure.map_continuous_linear_equiv.is_add_haar_measure _ A\n  convert(tendsto_integral_exp_smul_cocompact_of_inner_product (f ∘ A.symm) (μ.map Aₘ)).comp\n      Adual.to_homeomorph.to_cocompact_map.cocompact_tendsto'\n  ext1 w\n  rw [Function.comp_apply, integral_map_equiv]\n  congr 1 with v : 1\n  congr <;> exact (ContinuousLinearEquiv.symm_apply_apply A v).symm\n#align tendsto_integral_exp_smul_cocompact tendsto_integral_exp_smul_cocompact\n\n",
 "tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Riemann-Lebesgue Lemma for continuous and compactly-supported functions: the integral\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 wrt `cocompact V`. Note that this is primarily\nof interest as a preparatory step for the more general result\n`tendsto_integral_exp_inner_smul_cocompact` in which `f` can be arbitrary. -/\ntheorem tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support (hf1 : Continuous f)\n    (hf2 : HasCompactSupport f) :\n    Tendsto\n      (fun w : V =>\n        «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n          («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v)))\n      (cocompact V) ((nhds) 0) :=\n  by\n  refine' normed_add_comm_group.tendsto_nhds_zero.mpr fun ε hε => _\n  suffices\n    ∃ T : exprℝ,\n      ∀ w : V,\n        T ≤ «expr‖ ‖» w →\n          «expr‖ ‖»\n              («expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n                («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v))) <\n            ε\n    by\n    simp_rw [← comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_at_top, dist_eq_norm', sub_zero]\n    exact\n      let ⟨T, hT⟩ := this\n      ⟨T, fun b hb v hv => hT v (hv.symm ▸ hb)⟩\n  obtain ⟨R, hR_pos, hR_bd⟩ : ∃ R : exprℝ, 0 < R ∧ ∀ x : V, R ≤ «expr‖ ‖» x → f x = 0\n  exact hf2.exists_pos_le_norm\n  let A := { v : V | «expr‖ ‖» v ≤ R + 1 }\n  have mA : MeasurableSet A :=\n    by\n    suffices A = Metric.closedBall (0 : V) (R + 1) by\n      rw [this]\n      exact metric.is_closed_ball.measurable_set\n    simp_rw [A, Metric.closedBall, dist_eq_norm, sub_zero]\n  obtain ⟨B, hB_pos, hB_vol⟩ : ∃ B : nnreal, 0 < B ∧ volume A ≤ B :=\n    by\n    have hc : IsCompact A := by\n      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using is_compact_closed_ball (0 : V) _\n    let B₀ := volume A\n    replace hc : B₀ < «expr⊤» := hc.measure_lt_top\n    refine' ⟨B₀.to_nnreal + 1, add_pos_of_nonneg_of_pos B₀.to_nnreal.coe_nonneg one_pos, _⟩\n    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]\n    exact le_self_add\n  --* Use uniform continuity to choose δ such that `‖x - y‖ < δ` implies `‖f x - f y‖ < ε / B`.\n  obtain ⟨δ, hδ1, hδ2⟩ :=\n    metric.uniform_continuous_iff.mp (hf2.uniform_continuous_of_continuous hf1) (ε / B) (div_pos hε hB_pos)\n  refine' ⟨1 / 2 + 1 / (2 * δ), fun w hw_bd => _⟩\n  have hw_ne : w ≠ 0 := by\n    contrapose! hw_bd\n    rw [hw_bd, norm_zero]\n    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hδ1)\n  have hw'_nm : «expr‖ ‖» ((expri) w) = 1 / (2 * «expr‖ ‖» w) := by\n    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one, sq, ← div_div, ←\n      div_div, ← div_div, div_mul_cancel _ (norm_eq_zero.not.mpr hw_ne)]\n  --* Rewrite integral in terms of `f v - f (v + w')`.\n  rw [fourier_integral_eq_half_sub_half_period_translate hw_ne (hf1.integrable_of_has_compact_support hf2), norm_smul,\n    norm_eq_abs, ← Complex.ofReal_one, ← of_real_bit0, ← of_real_div, Complex.abs_of_nonneg one_half_pos.le]\n  have : ε = 1 / 2 * (2 * ε) := by\n    field_simp\n    rw [mul_comm]\n  rw [this, mul_lt_mul_left (one_half_pos : (0 : exprℝ) < 1 / 2)]\n  refine' lt_of_le_of_lt (norm_integral_le_integral_norm _) _\n  simp_rw [norm_smul, norm_eq_abs, abs_coe_circle, one_mul]\n  --* Show integral can be taken over A only.\n  have int_A :\n    «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n        («expr‖ ‖» (f v - f (v + (expri) w))) =\n      «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" A\n        («expr‖ ‖» (f v - f (v + (expri) w))) :=\n    by\n    refine' (set_integral_eq_integral_of_forall_compl_eq_zero fun v hv => _).symm\n    dsimp only [A] at hv\n    simp only [A, mem_set_of_eq, not_le] at hv\n    rw [hR_bd v _, hR_bd (v + (expri) w) _, sub_zero, norm_zero]\n    · rw [← sub_neg_eq_add]\n      refine' le_trans _ (norm_sub_norm_le _ _)\n      rw [le_sub_iff_add_le, norm_neg]\n      refine' le_trans _ hv.le\n      rw [add_le_add_iff_left, hw'_nm, ← div_div]\n      refine' (div_le_one <| norm_pos_iff.mpr hw_ne).mpr _\n      refine' le_trans (le_add_of_nonneg_right <| one_div_nonneg.mpr <| _) hw_bd\n      exact (mul_pos (zero_lt_two' (exprℝ)) hδ1).le\n    · exact ((le_add_iff_nonneg_right _).mpr zero_le_one).trans hv.le\n  rw [int_A]\n  clear int_A\n  --* Bound integral using fact that `‖f v - f (v + w')‖` is small.\n  have bdA : ∀ v : V, v ∈ A → «expr‖ ‖» («expr‖ ‖» (f v - f (v + (expri) w))) ≤ ε / B :=\n    by\n    simp_rw [norm_norm]\n    simp_rw [dist_eq_norm] at hδ2\n    refine' fun x _ => (hδ2 _).le\n    rw [sub_add_cancel', norm_neg, hw'_nm, ← div_div, div_lt_iff (norm_pos_iff.mpr hw_ne), ← div_lt_iff' hδ1, div_div]\n    refine' (lt_add_of_pos_left _ _).trans_le hw_bd\n    exact one_half_pos\n  have bdA2 := norm_set_integral_le_of_norm_le_const (hB_vol.trans_lt ENNReal.coe_lt_top) bdA _\n  swap\n  · apply continuous.ae_strongly_measurable\n    exact continuous_norm.comp <| Continuous.sub hf1 <| Continuous.comp hf1 <| continuous_id'.add continuous_const\n  have :\n    «expr‖ ‖» _ =\n      «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" A\n        («expr‖ ‖» (f v - f (v + (expri) w))) :=\n    Real.norm_of_nonneg (set_integral_nonneg mA fun x hx => norm_nonneg _)\n  rw [this] at bdA2\n  refine' bdA2.trans_lt _\n  rw [div_mul_eq_mul_div, div_lt_iff (nnreal.coe_pos.mpr hB_pos), mul_comm (2 : exprℝ), mul_assoc, mul_lt_mul_left hε]\n  rw [← ENNReal.toReal_le_toReal] at hB_vol\n  · refine' hB_vol.trans_lt _\n    rw [(by rfl : (↑B : ENNReal).to_real = ↑B), two_mul]\n    exact lt_add_of_pos_left _ hB_pos\n  exacts[(hB_vol.trans_lt ENNReal.coe_lt_top).ne, ennreal.coe_lt_top.ne]\n#align tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support\n\n",
 "tendsto_integral_exp_inner_smul_cocompact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. -/\ntheorem tendsto_integral_exp_inner_smul_cocompact :\n    Tendsto\n      (fun w : V =>\n        «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n          («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v)))\n      (cocompact V) ((nhds) 0) :=\n  by\n  by_cases hfi : integrable f\n  swap\n  · convert tendsto_const_nhds\n    ext1 w\n    apply integral_undef\n    rwa [← fourier_integrand_integrable w]\n  refine' metric.tendsto_nhds.mpr fun ε hε => _\n  obtain ⟨g, hg_supp, hfg, hg_cont, -⟩ := hfi.exists_has_compact_support_integral_sub_le (div_pos hε two_pos)\n  refine'\n    ((metric.tendsto_nhds.mp (tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support hg_cont hg_supp))\n          _ (div_pos hε two_pos)).mp\n      (eventually_of_forall fun w hI => _)\n  rw [dist_eq_norm] at hI⊢\n  have :\n    «expr‖ ‖»\n        («expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n            («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v)) -\n          «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n            («expr • » («expr [ ]» (expre) (-inner.real v w)) (g v))) ≤\n      ε / 2 :=\n    by\n    refine' le_trans _ hfg\n    simp_rw [←\n      integral_sub ((fourier_integrand_integrable w).mp hfi)\n        ((fourier_integrand_integrable w).mp (hg_cont.integrable_of_has_compact_support hg_supp)),\n      ← smul_sub, ← Pi.sub_apply]\n    exact vector_fourier.norm_fourier_integral_le_integral_norm (expre) volume bilin_form_of_real_inner.to_lin (f - g) w\n  replace := add_lt_add_of_le_of_lt this hI\n  rw [add_halves] at this\n  refine' ((le_of_eq _).trans (norm_add_le _ _)).trans_lt this\n  simp only [sub_zero, sub_add_cancel]\n#align tendsto_integral_exp_inner_smul_cocompact tendsto_integral_exp_inner_smul_cocompact\n\n",
 "fourier_integrand_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/-\nCopyright (c) 2022 David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Loeffler\n-/\n/-- The integrand in the Riemann-Lebesgue lemma for `f` is integrable iff `f` is. -/\ntheorem fourier_integrand_integrable (w : V) :\n    integrable f ↔ integrable fun v : V => «expr • » («expr [ ]» (expre) (-inner.real v w)) (f v) :=\n  by\n  have hL : Continuous fun p : V × V => bilin_form_of_real_inner.to_lin p.1 p.2 := continuous_inner\n  rw [vector_fourier.fourier_integral_convergent_iff real.continuous_fourier_char hL w]\n  · simp only [bilin_form.to_lin_apply, bilin_form_of_real_inner_apply]\n  · infer_instance\n#align fourier_integrand_integrable fourier_integrand_integrable\n\n",
 "fourier_integral_half_period_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/-- Shifting `f` by `(1 / (2 * ‖w‖ ^ 2)) • w` negates the integral in the Riemann-Lebesgue lemma. -/\ntheorem fourier_integral_half_period_translate {w : V} (hw : w ≠ 0) :\n    «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n        («expr • » («expr [ ]» (expre) (-inner.real v w)) (f (v + (expri) w))) =\n      -«expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n          («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v)) :=\n  by\n  have hiw : inner.real ((expri) w) w = 1 / 2 :=\n    by\n    rw [inner_smul_left, inner_self_eq_norm_sq_to_K, IsROrC.ofReal_real_eq_id, id.def, IsROrC.conj_to_real, ← div_div,\n      div_mul_cancel]\n    rwa [ne.def, sq_eq_zero_iff, norm_eq_zero]\n  have :\n    (fun v : V => «expr • » («expr [ ]» (expre) (-inner.real v w)) (f (v + (expri) w))) = fun v : V =>\n      (fun x : V => «expr • » (-«expr [ ]» (expre) (-inner.real x w)) (f x)) (v + (expri) w) :=\n    by\n    ext1 v\n    simp_rw [inner_add_left, hiw, real.fourier_char_apply, neg_add, mul_add, of_real_add, add_mul, exp_add]\n    have : 2 * real.pi * -(1 / 2) = -real.pi := by\n      field_simp\n      ring\n    rw [this, of_real_neg, neg_mul, exp_neg, exp_pi_mul_I, inv_neg, inv_one, mul_neg_one, neg_neg]\n  rw [this, integral_add_right_eq_self]\n  simp only [neg_smul, integral_neg]\n#align fourier_integral_half_period_translate fourier_integral_half_period_translate\n\n",
 "fourier_integral_eq_half_sub_half_period_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expre -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `inner.real -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expri -/\n/-- Rewrite the Fourier integral in a form that allows us to use uniform continuity. -/\ntheorem fourier_integral_eq_half_sub_half_period_translate {w : V} (hw : w ≠ 0) (hf : integrable f) :\n    «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n        («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v)) =\n      «expr • » (1 / (2 : exprℂ))\n        («expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n          («expr • » («expr [ ]» (expre) (-inner.real v w)) (f v - f (v + (expri) w)))) :=\n  by\n  simp_rw [smul_sub]\n  rw [integral_sub, fourier_integral_half_period_translate hw, sub_eq_add_neg, neg_neg, ← two_smul (exprℂ) _, ←\n    @smul_assoc _ _ _ _ _ _ (IsScalarTower.left (exprℂ)), smul_eq_mul]\n  norm_num\n  exacts[(fourier_integrand_integrable w).mp hf, (fourier_integrand_integrable w).mp (hf.comp_add_right _)]\n#align fourier_integral_eq_half_sub_half_period_translate fourier_integral_eq_half_sub_half_period_translate\n\n"}