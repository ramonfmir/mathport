{"continuous_of_locally_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- If `E` is first countable, then every locally bounded linear map `E â†’â‚›â‚—[Ïƒ] F` is continuous. -/\ntheorem linear_map.continuous_of_locally_bounded [uniform_add_group F] (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒ F)\n    (hf : âˆ€ (s : set E) (hs : is_vonN_bounded ğ•œ s), is_vonN_bounded ğ•œ' (Â«expr '' Â» f s)) : continuous f :=\n  (uniform_continuous_of_continuous_at_zero f <| f.continuous_at_zero_of_locally_bounded hf).continuous\n#align linear_map.continuous_of_locally_bounded linear_map.continuous_of_locally_bounded\n\n",
 "continuous_at_zero_of_locally_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem linear_map.continuous_at_zero_of_locally_bounded (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒ F)\n    (hf : âˆ€ (s : set E) (hs : is_vonN_bounded ğ•œ s), is_vonN_bounded ğ•œ' (Â«expr '' Â» f s)) : continuous_at f 0 :=\n  by\n  -- Assume that f is not continuous at 0\n  by_contra\n  -- We use a decreasing balanced basis for 0 : E and a balanced basis for 0 : F\n  -- and reformulate non-continuity in terms of these bases\n  rcases(nhds_basis_balanced ğ•œ E).exists_antitone_subbasis with âŸ¨b, bE1, bEâŸ©\n  simp only [id.def] at bE\n  have bE' : ((nhds) (0 : E)).has_basis (fun x : â„• => x â‰  0) fun n : â„• => Â«expr â€¢ Â» (n : ğ•œ)â»Â¹ (b n) :=\n    by\n    refine' bE.1.to_has_basis _ _\n    Â· intro n _\n      use n + 1\n      simp only [ne.def, nat.succ_ne_zero, not_false_iff, Nat.cast_add, Nat.cast_one, true_and_iff]\n      -- `b (n + 1) âŠ† b n` follows from `antitone`.\n      have h : b (n + 1) âŠ† b n := bE.2 (by simp)\n      refine' subset_trans _ h\n      rintro y âŸ¨x, hx, hyâŸ©\n      -- Since `b (n + 1)` is balanced `(n+1)â»Â¹ b (n + 1) âŠ† b (n + 1)`\n      rw [â† hy]\n      refine' (bE1 (n + 1)).2.smul_mem _ hx\n      have h' : 0 < (n : exprâ„) + 1 := n.cast_add_one_pos\n      rw [norm_inv, â† Nat.cast_one, â† Nat.cast_add, is_R_or_C.norm_eq_abs, is_R_or_C.abs_cast_nat, Nat.cast_add,\n        Nat.cast_one, inv_le h' zero_lt_one]\n      norm_cast\n      simp\n    intro n hn\n    -- The converse direction follows from continuity of the scalar multiplication\n    have hcont : continuous_at (fun x : E => Â«expr â€¢ Â» (n : ğ•œ) x) 0 := (continuous_const_smul (n : ğ•œ)).continuous_at\n    simp only [continuous_at, map_zero, smul_zero] at hcont\n    rw [bE.1.tendsto_left_iff] at hcont\n    rcases hcont (b n) (bE1 n).1 with âŸ¨i, _, hiâŸ©\n    refine' âŸ¨i, trivial, fun x hx => âŸ¨Â«expr â€¢ Â» (n : ğ•œ) x, hi hx, _âŸ©âŸ©\n    simp [â† mul_smul, hn]\n  rw [continuous_at, map_zero, bE'.tendsto_iff (nhds_basis_balanced ğ•œ' F)] at h\n  push_neg  at h\n  rcases h with âŸ¨V, âŸ¨hV, hV'âŸ©, hâŸ©\n  simp only [id.def, forall_true_left] at h\n  -- There exists `u : â„• â†’ E` such that for all `n : â„•` we have `u n âˆˆ nâ»Â¹ â€¢ b n` and `f (u n) âˆ‰ V`\n  choose! u hu hu' using h\n  -- The sequence `(Î» n, n â€¢ u n)` converges to `0`\n  have h_tendsto : tendsto (fun n : â„• => Â«expr â€¢ Â» (n : ğ•œ) (u n)) at_top ((nhds) (0 : E)) :=\n    by\n    apply bE.tendsto\n    intro n\n    by_cases h : n = 0\n    Â· rw [h, Nat.cast_zero, zero_smul]\n      refine' mem_of_mem_nhds (bE.1.mem_of_mem <| by triv)\n    rcases hu n h with âŸ¨y, hy, hu1âŸ©\n    convert hy\n    rw [â† hu1, â† mul_smul]\n    simp only [h, mul_inv_cancel, ne.def, Nat.cast_eq_zero, not_false_iff, one_smul]\n  -- The image `(Î» n, n â€¢ u n)` is von Neumann bounded:\n  have h_bounded : is_vonN_bounded ğ•œ (Set.range fun n : â„• => Â«expr â€¢ Â» (n : ğ•œ) (u n)) :=\n    h_tendsto.cauchy_seq.totally_bounded_range.is_vonN_bounded ğ•œ\n  -- Since `range u` is bounded it absorbs `V`\n  rcases hf _ h_bounded hV with âŸ¨r, hr, h'âŸ©\n  cases' exists_nat_gt r with n hn\n  -- We now find a contradiction between `f (u n) âˆ‰ V` and the absorbing property\n  have h1 : r â‰¤ Â«exprâ€– â€–Â» (n : ğ•œ') :=\n    by\n    rw [is_R_or_C.norm_eq_abs, is_R_or_C.abs_cast_nat]\n    exact hn.le\n  have hn' : 0 < Â«exprâ€– â€–Â» (n : ğ•œ') := lt_of_lt_of_le hr h1\n  rw [norm_pos_iff, ne.def, Nat.cast_eq_zero] at hn'\n  have h'' : f (u n) âˆˆ V := by\n    simp only [Set.image_subset_iff] at h'\n    specialize h' (n : ğ•œ') h1 (Set.mem_range_self n)\n    simp only [Set.mem_preimage, linear_map.map_smulâ‚›â‚—, map_nat_cast] at h'\n    rcases h' with âŸ¨y, hy, h'âŸ©\n    apply_fun fun y : F => Â«expr â€¢ Â» (n : ğ•œ')â»Â¹ y  at h'\n    simp only [hn', inv_smul_smulâ‚€, ne.def, Nat.cast_eq_zero, not_false_iff] at h'\n    rwa [â† h']\n  exact hu' n hn' h''\n#align linear_map.continuous_at_zero_of_locally_bounded linear_map.continuous_at_zero_of_locally_bounded\n\n",
 "clm_of_exists_bounded_image_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-\nCopyright (c) 2022 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll\n-/\n-- It suffices to show that `f` is continuous at `0`.\n-- Continuity means that `U âˆˆ ğ“ 0` implies that `f â»Â¹' U âˆˆ ğ“ 0`.\n-- After unfolding all the definitions, we know that `f '' V âŠ† x â€¢ U`. We use this to show the\n-- inclusion `xâ»Â¹ â€¢ V âŠ† fâ»Â¹' U`.\n-- Using this inclusion, it suffices to show that `xâ»Â¹ â€¢ V` is in `ğ“ 0`, which is trivial.\ntheorem linear_map.clm_of_exists_bounded_image_coe {f : Â«expr â†’â‚—[ ] Â» E ğ•œ F}\n    {h : âˆƒ (V : set E)(hV : V âˆˆ (nhds) (0 : E)), bornology.is_vonN_bounded ğ•œ (Â«expr '' Â» f V)} :\n    (f.clm_of_exists_bounded_image h : Â«expr â†’â‚—[ ] Â» E ğ•œ F) = f :=\n  rfl\n#align linear_map.clm_of_exists_bounded_image_coe linear_map.clm_of_exists_bounded_image_coe\n\n",
 "clm_of_exists_bounded_image_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem linear_map.clm_of_exists_bounded_image_apply {f : Â«expr â†’â‚—[ ] Â» E ğ•œ F}\n    {h : âˆƒ (V : set E)(hV : V âˆˆ (nhds) (0 : E)), bornology.is_vonN_bounded ğ•œ (Â«expr '' Â» f V)} {x : E} :\n    f.clm_of_exists_bounded_image h x = f x :=\n  rfl\n#align linear_map.clm_of_exists_bounded_image_apply linear_map.clm_of_exists_bounded_image_apply\n\n"}