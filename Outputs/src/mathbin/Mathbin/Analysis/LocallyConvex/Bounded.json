{"vonN_bornology_eq":
 "/-- In a normed space, the von Neumann bornology (`bornology.vonN_bornology`) is equal to the\nmetric bornology. -/\ntheorem vonN_bornology_eq : Bornology.vonNBornology ğ•œ E = pseudo_metric_space.to_bornology :=\n  by\n  rw [Bornology.ext_iff_isBounded]\n  intro s\n  rw [Bornology.isBounded_iff_isVonNBounded]\n  exact is_vonN_bounded_iff ğ•œ E s\n#align vonN_bornology_eq vonN_bornology_eq\n\n",
 "union":
 "/-- The union of two bounded sets is bounded. -/\ntheorem is_vonN_bounded.union {sâ‚ sâ‚‚ : Set E} (hsâ‚ : IsVonNBounded ğ•œ sâ‚) (hsâ‚‚ : IsVonNBounded ğ•œ sâ‚‚) :\n    IsVonNBounded ğ•œ (sâ‚ âˆª sâ‚‚) := fun V hV => (hsâ‚ hV).union (hsâ‚‚ hV)\n#align is_vonN_bounded.union is_vonN_bounded.union\n\n",
 "subset":
 "/-- Subsets of bounded sets are bounded. -/\ntheorem is_vonN_bounded.subset {sâ‚ sâ‚‚ : Set E} (h : sâ‚ âŠ† sâ‚‚) (hsâ‚‚ : IsVonNBounded ğ•œ sâ‚‚) : IsVonNBounded ğ•œ sâ‚ :=\n  fun V hV => (hsâ‚‚ hV).mono_right h\n#align is_vonN_bounded.subset is_vonN_bounded.subset\n\n",
 "smul_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_vonN_bounded.smul_tendsto_zero {S : Set E} {Îµ : Î¹ â†’ ğ•œ} {x : Î¹ â†’ E} {l : Filter Î¹} (hS : IsVonNBounded ğ•œ S)\n    (hxS :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (x n âˆˆ S))\n    (hÎµ : Tendsto Îµ l ((nhds) 0)) : Tendsto (Â«expr â€¢ Â» Îµ x) l ((nhds) 0) :=\n  by\n  rw [tendsto_def] at *\n  intro V hV\n  rcases hS hV with âŸ¨r, r_pos, hrSâŸ©\n  filter_upwards [hxS, hÎµ _ (Metric.ball_mem_nhds 0 <| inv_pos.mpr r_pos)]with n hnS hnr\n  by_cases this : Îµ n = 0\n  Â· simp [this, mem_of_mem_nhds hV]\n  Â· rw [mem_preimage, mem_ball_zero_iff, lt_inv (norm_pos_iff.mpr this) r_pos, â† norm_inv] at hnr\n    rw [mem_preimage, Pi.smul_apply', â† Set.mem_inv_smul_set_iffâ‚€ this]\n    exact hrS _ hnr.le hnS\n#align is_vonN_bounded.smul_tendsto_zero is_vonN_bounded.smul_tendsto_zero\n\n",
 "of_topological_space_le":
 "/-- If a topology `t'` is coarser than `t`, then any set `s` that is bounded with respect to\n`t` is bounded with respect to `t'`. -/\ntheorem is_vonN_bounded.of_topological_space_le {t t' : TopologicalSpace E} (h : t â‰¤ t') {s : Set E}\n    (hs : @IsVonNBounded ğ•œ E _ _ _ t s) : @IsVonNBounded ğ•œ E _ _ _ t' s := fun V hV =>\n  hs <| (le_iff_nhds t t').mp h 0 hV\n#align is_vonN_bounded.of_topological_space_le is_vonN_bounded.of_topological_space_le\n\n",
 "is_vonN_bounded_singleton":
 "/-- Singletons are bounded. -/\ntheorem is_vonN_bounded_singleton (x : E) : IsVonNBounded ğ•œ ({x} : Set E) := fun V hV =>\n  (absorbent_nhds_zero hV).absorbs\n#align is_vonN_bounded_singleton is_vonN_bounded_singleton\n\n",
 "is_vonN_bounded_of_smul_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem is_vonN_bounded_of_smul_tendsto_zero {Îµ : Î¹ â†’ ğ•} {l : Filter Î¹} [l.ne_bot]\n    (hÎµ :\n      Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n        (Îµ n â‰  0))\n    {S : Set E} (H : âˆ€ x : Î¹ â†’ E, (âˆ€ n, x n âˆˆ S) â†’ Tendsto (Â«expr â€¢ Â» Îµ x) l ((nhds) 0)) : IsVonNBounded ğ• S :=\n  by\n  rw [(nhds_basis_balanced ğ• E).is_vonN_bounded_basis_iff]\n  by_contra' H'\n  rcases H' with âŸ¨V, âŸ¨hV, hVbâŸ©, hVSâŸ©\n  have :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" l\n      (âˆƒ x : S, Â«expr â€¢ Â» (Îµ n) (x : E) âˆ‰ V) :=\n    by\n    filter_upwards [hÎµ]with n hn\n    rw [Absorbs] at hVS\n    push_neg  at hVS\n    rcases hVS _ (norm_pos_iff.mpr <| inv_ne_zero hn) with âŸ¨a, haÎµ, haSâŸ©\n    rcases set.not_subset.mp haS with âŸ¨x, hxS, hxâŸ©\n    refine' âŸ¨âŸ¨x, hxSâŸ©, fun hnx => _âŸ©\n    rw [â† Set.mem_inv_smul_set_iffâ‚€ hn] at hnx\n    exact hx (hVb.smul_mono haÎµ hnx)\n  rcases this.choice with âŸ¨x, hxâŸ©\n  refine' Filter.frequently_false l (Filter.Eventually.frequently _)\n  filter_upwards [hx, (H (coe âˆ˜ x) fun n => (x n).2).eventually (eventually_mem_set.mpr hV)]using fun n => id\n#align is_vonN_bounded_of_smul_tendsto_zero is_vonN_bounded_of_smul_tendsto_zero\n\n",
 "is_vonN_bounded_iff_smul_tendsto_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.ne -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Given any sequence `Îµ` of scalars which tends to `ğ“[â‰ ] 0`, we have that a set `S` is bounded\n  if and only if for any sequence `x : â„• â†’ S`, `Îµ â€¢ x` tends to 0. This actually works for any\n  indexing type `Î¹`, but in the special case `Î¹ = â„•` we get the important fact that convergent\n  sequences fully characterize bounded sets. -/\ntheorem is_vonN_bounded_iff_smul_tendsto_zero {Îµ : Î¹ â†’ ğ•} {l : Filter Î¹} [l.ne_bot]\n    (hÎµ : Tendsto Îµ l (nhds_within.ne 0)) {S : Set E} :\n    IsVonNBounded ğ• S â†” âˆ€ x : Î¹ â†’ E, (âˆ€ n, x n âˆˆ S) â†’ Tendsto (Â«expr â€¢ Â» Îµ x) l ((nhds) 0) :=\n  âŸ¨fun hS x hxS => hS.smul_tendsto_zero (eventually_of_forall hxS) (le_trans hÎµ nhdsWithin_le_nhds),\n    isVonNBounded_of_smul_tendsto_zero (hÎµ self_mem_nhdsWithin)âŸ©\n#align is_vonN_bounded_iff_smul_tendsto_zero is_vonN_bounded_iff_smul_tendsto_zero\n\n",
 "is_vonN_bounded_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem is_vonN_bounded_iff' (s : Set E) :\n    Bornology.IsVonNBounded ğ•œ s â†” âˆƒ r : exprâ„, âˆ€ (x : E) (hx : x âˆˆ s), Â«exprâ€– â€–Â» x â‰¤ r := by\n  rw [NormedSpace.isVonNBounded_iff, â† Metric.bounded_iff_isBounded, bounded_iff_forall_norm_le]\n#align is_vonN_bounded_iff' is_vonN_bounded_iff'\n\n",
 "is_vonN_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem is_vonN_bounded_iff (s : Set E) : Bornology.IsVonNBounded ğ•œ s â†” Bornology.IsBounded s :=\n  by\n  rw [â† Metric.bounded_iff_isBounded, Metric.bounded_iff_subset_ball (0 : E)]\n  constructor\n  Â· intro h\n    rcases h (Metric.ball_mem_nhds 0 zero_lt_one) with âŸ¨Ï, hÏ, hÏballâŸ©\n    rcases NormedField.exists_lt_norm ğ•œ Ï with âŸ¨a, haâŸ©\n    specialize hÏball a ha.le\n    rw [â† ball_normSeminorm ğ•œ E, Seminorm.smul_ball_zero (norm_pos_iff.1 <| hÏ.trans ha), ball_normSeminorm, mul_one] at\n      hÏball\n    exact âŸ¨Â«exprâ€– â€–Â» a, hÏball.trans Metric.ball_subset_closedBallâŸ©\n  Â· exact fun âŸ¨C, hCâŸ© => (is_vonN_bounded_closed_ball ğ•œ E C).subset hC\n#align is_vonN_bounded_iff is_vonN_bounded_iff\n\n",
 "is_vonN_bounded_empty":
 "/-\nCopyright (c) 2022 Moritz Doll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll\n-/\n@[simp]\ntheorem is_vonN_bounded_empty : IsVonNBounded ğ•œ (âˆ… : Set E) := fun _ _ => absorbs_empty\n#align is_vonN_bounded_empty is_vonN_bounded_empty\n\n",
 "is_vonN_bounded_covers":
 "/-- The union of all bounded set is the whole space. -/\ntheorem is_vonN_bounded_covers : â‹ƒâ‚€ setOf (IsVonNBounded ğ•œ) = (Set.univ : Set E) :=\n  Set.eq_univ_iff_forall.mpr fun x => Set.mem_unionâ‚›.mpr âŸ¨{x}, isVonNBounded_singleton _, Set.mem_singleton _âŸ©\n#align is_vonN_bounded_covers is_vonN_bounded_covers\n\n",
 "is_vonN_bounded_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem is_vonN_bounded_closed_ball (r : exprâ„) : Bornology.IsVonNBounded ğ•œ (Metric.closedBall (0 : E) r) :=\n  (isVonNBounded_ball ğ•œ E (r + 1)).subset (Metric.closedBall_subset_ball <| by linarith)\n#align is_vonN_bounded_closed_ball is_vonN_bounded_closed_ball\n\n",
 "is_vonN_bounded_basis_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print Filter.HasBasis.isVonNBounded_basis_iff /-\ntheorem Filter.HasBasis.isVonNBounded_basis_iff {q : Î¹ â†’ Prop} {s : Î¹ â†’ Set E} {A : Set E}\n    (h : ((nhds) (0 : E)).has_basis q s) : IsVonNBounded ğ•œ A â†” âˆ€ (i) (hi : q i), Absorbs ğ•œ (s i) A :=\n  by\n  refine' âŸ¨fun hA i hi => hA (h.mem_of_mem hi), fun hA V hV => _âŸ©\n  rcases h.mem_iff.mp hV with âŸ¨i, hi, hVâŸ©\n  exact (hA i hi).mono_left hV\n#align filter.has_basis.is_vonN_bounded_basis_iff Filter.HasBasis.isVonNBounded_basis_iff\n-/\n\n",
 "is_vonN_bounded_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem is_vonN_bounded_ball (r : exprâ„) : Bornology.IsVonNBounded ğ•œ (Metric.ball (0 : E) r) :=\n  by\n  rw [metric.nhds_basis_ball.is_vonN_bounded_basis_iff, â† ball_normSeminorm ğ•œ E]\n  exact fun Îµ hÎµ => (normSeminorm ğ•œ E).ball_zero_absorbs_ball_zero hÎµ\n#align is_vonN_bounded_ball is_vonN_bounded_ball\n\n",
 "is_bounded_iff_subset_smul_closed_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem is_bounded_iff_subset_smul_closed_ball {s : Set E} :\n    Bornology.IsBounded s â†” âˆƒ a : ğ•œ, s âŠ† Â«expr â€¢ Â» a (Metric.closedBall 0 1) :=\n  by\n  constructor\n  Â· rw [is_bounded_iff_subset_smul_ball ğ•œ]\n    exact Exists.imp fun a ha => ha.trans <| Set.smul_set_mono <| Metric.ball_subset_closedBall\n  Â· rw [â† is_vonN_bounded_iff ğ•œ]\n    rintro âŸ¨a, haâŸ©\n    exact ((is_vonN_bounded_closed_ball ğ•œ E 1).image (Â«expr â€¢ Â» a 1 : Â«expr â†’L[ ] Â» E ğ•œ E)).subset ha\n#align is_bounded_iff_subset_smul_closed_ball is_bounded_iff_subset_smul_closed_ball\n\n",
 "is_bounded_iff_subset_smul_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’L[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem is_bounded_iff_subset_smul_ball {s : Set E} :\n    Bornology.IsBounded s â†” âˆƒ a : ğ•œ, s âŠ† Â«expr â€¢ Â» a (Metric.ball 0 1) :=\n  by\n  rw [â† is_vonN_bounded_iff ğ•œ]\n  constructor\n  Â· intro h\n    rcases h (Metric.ball_mem_nhds 0 zero_lt_one) with âŸ¨Ï, hÏ, hÏballâŸ©\n    rcases NormedField.exists_lt_norm ğ•œ Ï with âŸ¨a, haâŸ©\n    exact âŸ¨a, hÏball a ha.leâŸ©\n  Â· rintro âŸ¨a, haâŸ©\n    exact ((is_vonN_bounded_ball ğ•œ E 1).image (Â«expr â€¢ Â» a 1 : Â«expr â†’L[ ] Â» E ğ•œ E)).subset ha\n#align is_bounded_iff_subset_smul_ball is_bounded_iff_subset_smul_ball\n\n",
 "is_bounded_iff_is_vonN_bounded":
 "-- See note [reducible non-instances]\n@[simp]\ntheorem is_bounded_iff_is_vonN_bounded {s : Set E} : @IsBounded _ (vonNBornology ğ•œ E) s â†” IsVonNBounded ğ•œ s :=\n  isBounded_ofBounded_iff _\n#align is_bounded_iff_is_vonN_bounded is_bounded_iff_is_vonN_bounded\n\n",
 "isVonNBounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n#print TotallyBounded.isVonNBounded /-\ntheorem TotallyBounded.isVonNBounded {s : Set E} (hs : TotallyBounded s) : Bornology.IsVonNBounded ğ•œ s :=\n  by\n  rw [totallyBounded_iff_subset_finite_unionáµ¢_nhds_zero] at hs\n  intro U hU\n  have h : Filter.Tendsto (fun x : E Ã— E => x.fst + x.snd) ((nhds) (0, 0)) ((nhds) ((0 : E) + (0 : E))) := tendsto_add\n  rw [add_zero] at h\n  have h' := (nhds_basis_balanced ğ•œ E).prod (nhds_basis_balanced ğ•œ E)\n  simp_rw [â† nhds_prod_eq, id.def] at h'\n  rcases h.basis_left h' U hU with âŸ¨x, hx, h''âŸ©\n  rcases hs x.snd hx.2.1 with âŸ¨t, ht, hsâŸ©\n  refine' Absorbs.mono_right _ hs\n  rw [ht.absorbs_Union]\n  have hx_fstsnd : x.fst + x.snd âŠ† U := by\n    intro z hz\n    rcases set.mem_add.mp hz with âŸ¨z1, z2, hz1, hz2, hzâŸ©\n    have hz' : (z1, z2) âˆˆ lower_set.prod x.fst x.snd := âŸ¨hz1, hz2âŸ©\n    simpa only [hz] using h'' hz'\n  refine' fun y hy => Absorbs.mono_left _ hx_fstsnd\n  rw [â† Set.singleton_vadd, vadd_eq_add]\n  exact (absorbent_nhds_zero hx.1.1).absorbs.add hx.2.2.absorbs_self\n#align totally_bounded.is_vonN_bounded TotallyBounded.isVonNBounded\n-/\n\n",
 "image_is_vonN_bounded_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem image_is_vonN_bounded_iff (f : E' â†’ E) (s : Set E') :\n    Bornology.IsVonNBounded ğ•œ (Â«expr '' Â» f s) â†” âˆƒ r : exprâ„, âˆ€ (x : E') (hx : x âˆˆ s), Â«exprâ€– â€–Â» (f x) â‰¤ r := by\n  simp_rw [is_vonN_bounded_iff', Set.ball_image_iff]\n#align image_is_vonN_bounded_iff image_is_vonN_bounded_iff\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’SL[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- A continuous linear image of a bounded set is bounded. -/\ntheorem is_vonN_bounded.image {Ïƒ : Â«expr â†’+* Â» ğ•œâ‚ ğ•œâ‚‚} [RingHomSurjective Ïƒ] [RingHomIsometric Ïƒ] {s : Set E}\n    (hs : IsVonNBounded ğ•œâ‚ s) (f : Â«expr â†’SL[ ] Â» E Ïƒ F) : IsVonNBounded ğ•œâ‚‚ (Â«expr '' Â» f s) :=\n  by\n  let Ïƒ' := RingEquiv.ofBijective Ïƒ âŸ¨Ïƒ.injective, Ïƒ.is_surjectiveâŸ©\n  have Ïƒ_iso : Isometry Ïƒ := add_monoid_hom_class.isometry_of_norm Ïƒ fun x => ring_hom_isometric.is_iso\n  have Ïƒ'_symm_iso : Isometry Ïƒ'.symm := Ïƒ_iso.right_inv Ïƒ'.right_inv\n  have f_tendsto_zero := f.continuous.tendsto 0\n  rw [map_zero] at f_tendsto_zero\n  intro V hV\n  rcases hs (f_tendsto_zero hV) with âŸ¨r, hrpos, hrâŸ©\n  refine' âŸ¨r, hrpos, fun a ha => _âŸ©\n  rw [â† Ïƒ'.apply_symm_apply a]\n  have hanz : a â‰  0 := norm_pos_iff.mp (hrpos.trans_le ha)\n  have : Ïƒ'.symm a â‰  0 := (map_ne_zero Ïƒ'.symm.to_ring_hom).mpr hanz\n  change _ âŠ† Â«expr â€¢ Â» (Ïƒ _) _\n  rw [Set.image_subset_iff, preimage_smul_setâ‚›â‚— _ _ _ f this.is_unit]\n  refine' hr (Ïƒ'.symm a) _\n  rwa [Ïƒ'_symm_iso.norm_map_of_map_zero (map_zero _)]\n#align is_vonN_bounded.image is_vonN_bounded.image\n\n"}