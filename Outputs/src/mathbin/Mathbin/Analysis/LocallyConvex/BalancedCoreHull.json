{"subset_core_of_subset":
 "/-- The balanced core of `t` is maximal in the sense that it contains any balanced subset\n`s` of `t`.-/\ntheorem balanced.subset_core_of_subset (hs : balanced 𝕜 s) (h : s ⊆ t) : s ⊆ balanced_core 𝕜 t :=\n  subset_unionₛ_of_mem ⟨hs, h⟩\n#align balanced.subset_core_of_subset balanced.subset_core_of_subset\n\n",
 "subset_balanced_hull":
 "theorem subset_balanced_hull [norm_one_class 𝕜] {s : set E} : s ⊆ balanced_hull 𝕜 s := fun _ hx =>\n  mem_balanced_hull_iff.2 ⟨1, norm_one.le, _, hx, one_smul _ _⟩\n#align subset_balanced_hull subset_balanced_hull\n\n",
 "subset_balanced_core":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem subset_balanced_core (ht : (0 : E) ∈ t) (hst : ∀ (a : 𝕜) (ha : «expr‖ ‖» a ≤ 1), «expr • » a s ⊆ t) :\n    s ⊆ balanced_core 𝕜 t := by\n  rw [balanced_core_eq_Inter ht]\n  refine' subset_Inter₂ fun a ha => _\n  rw [← smul_inv_smul₀ (norm_pos_iff.mp <| zero_lt_one.trans_le ha) s]\n  refine' smul_set_mono (hst _ _)\n  rw [norm_inv]\n  exact inv_le_one ha\n#align subset_balanced_core subset_balanced_core\n\n",
 "smul_balanced_core_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_balanced_core_subset (s : set E) {a : 𝕜} (ha : «expr‖ ‖» a ≤ 1) :\n    «expr • » a (balanced_core 𝕜 s) ⊆ balanced_core 𝕜 s :=\n  by\n  rintro x ⟨y, hy, rfl⟩\n  rw [mem_balanced_core_iff] at hy\n  rcases hy with ⟨t, ht1, ht2, hy⟩\n  exact ⟨t, ⟨ht1, ht2⟩, ht1 a ha (smul_mem_smul_set hy)⟩\n#align smul_balanced_core_subset smul_balanced_core_subset\n\n",
 "nhds_basis_closed_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_closed_balanced [regular_space E] :\n    ((nhds) (0 : E)).has_basis (fun s : set E => s ∈ (nhds) (0 : E) ∧ is_closed s ∧ balanced 𝕜 s) id :=\n  by\n  refine' (closed_nhds_basis 0).to_has_basis (fun s hs => _) fun s hs => ⟨s, ⟨hs.1, hs.2.1⟩, rfl.subset⟩\n  refine' ⟨balanced_core 𝕜 s, ⟨balanced_core_mem_nhds_zero hs.1, _⟩, balanced_core_subset s⟩\n  exact ⟨hs.2.balanced_core, balanced_core_balanced s⟩\n#align nhds_basis_closed_balanced nhds_basis_closed_balanced\n\n",
 "nhds_basis_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem nhds_basis_balanced : ((nhds) (0 : E)).has_basis (fun s : set E => s ∈ (nhds) (0 : E) ∧ balanced 𝕜 s) id :=\n  filter.has_basis_self.mpr fun s hs =>\n    ⟨balanced_core 𝕜 s, balanced_core_mem_nhds_zero hs, balanced_core_balanced s, balanced_core_subset s⟩\n#align nhds_basis_balanced nhds_basis_balanced\n\n",
 "mem_balanced_hull_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_balanced_hull_iff : x ∈ balanced_hull 𝕜 s ↔ ∃ (r : 𝕜)(hr : «expr‖ ‖» r ≤ 1), x ∈ «expr • » r s :=\n  mem_Union₂\n#align mem_balanced_hull_iff mem_balanced_hull_iff\n\n",
 "mem_balanced_core_iff":
 "theorem mem_balanced_core_iff : x ∈ balanced_core 𝕜 s ↔ ∃ t, balanced 𝕜 t ∧ t ⊆ s ∧ x ∈ t := by\n  simp_rw [balanced_core, mem_sUnion, mem_set_of_eq, exists_prop, and_assoc']\n#align mem_balanced_core_iff mem_balanced_core_iff\n\n",
 "mem_balanced_core_aux_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_balanced_core_aux_iff : x ∈ balanced_core_aux 𝕜 s ↔ ∀ r : 𝕜, 1 ≤ «expr‖ ‖» r → x ∈ «expr • » r s :=\n  mem_Inter₂\n#align mem_balanced_core_aux_iff mem_balanced_core_aux_iff\n\n",
 "hull_subset_of_subset":
 "/-- The balanced hull of `s` is minimal in the sense that it is contained in any balanced superset\n`t` of `s`. -/\ntheorem balanced.hull_subset_of_subset (ht : balanced 𝕜 t) (h : s ⊆ t) : balanced_hull 𝕜 s ⊆ t := fun x hx =>\n  by\n  obtain ⟨r, hr, y, hy, rfl⟩ := mem_balanced_hull_iff.1 hx\n  exact ht.smul_mem hr (h hy)\n#align balanced.hull_subset_of_subset balanced.hull_subset_of_subset\n\n",
 "balanced_core_zero_mem":
 "theorem balanced_core_zero_mem (hs : (0 : E) ∈ s) : (0 : E) ∈ balanced_core 𝕜 s :=\n  mem_balanced_core_iff.2 ⟨0, balanced_zero, zero_subset.2 hs, zero_mem_zero⟩\n#align balanced_core_zero_mem balanced_core_zero_mem\n\n",
 "balanced_core_subset_balanced_core_aux":
 "theorem balanced_core_subset_balanced_core_aux : balanced_core 𝕜 s ⊆ balanced_core_aux 𝕜 s :=\n  balanced_core_aux_maximal (balanced_core_subset s) (balanced_core_balanced s)\n#align balanced_core_subset_balanced_core_aux balanced_core_subset_balanced_core_aux\n\n",
 "balanced_core_subset":
 "/-\nCopyright (c) 2022 Moritz Doll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll\n-/\ntheorem balanced_core_subset (s : set E) : balanced_core 𝕜 s ⊆ s :=\n  sUnion_subset fun t ht => ht.2\n#align balanced_core_subset balanced_core_subset\n\n",
 "balanced_core_nonempty_iff":
 "theorem balanced_core_nonempty_iff : (balanced_core 𝕜 s).nonempty ↔ (0 : E) ∈ s :=\n  ⟨fun h =>\n    zero_subset.1 <|\n      (zero_smul_set h).superset.trans <|\n        (balanced_core_balanced s (0 : 𝕜) <| norm_zero.trans_le zero_le_one).trans <| balanced_core_subset _,\n    fun h => ⟨0, balanced_core_zero_mem h⟩⟩\n#align balanced_core_nonempty_iff balanced_core_nonempty_iff\n\n",
 "balanced_core_mem_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem balanced_core_mem_nhds_zero (hU : U ∈ (nhds) (0 : E)) : balanced_core 𝕜 U ∈ (nhds) (0 : E) :=\n  by\n  -- Getting neighborhoods of the origin for `0 : 𝕜` and `0 : E`\n  obtain ⟨r, V, hr, hV, hrVU⟩ :\n    ∃ (r : exprℝ)(V : set E),\n      0 < r ∧ V ∈ (nhds) (0 : E) ∧ ∀ (c : 𝕜) (y : E), «expr‖ ‖» c < r → y ∈ V → «expr • » c y ∈ U :=\n    by\n    have h : filter.tendsto (fun x : 𝕜 × E => «expr • » x.fst x.snd) ((nhds) (0, 0)) ((nhds) 0) :=\n      continuous_smul.tendsto' (0, 0) _ (smul_zero _)\n    simpa only [← prod.exists', ← prod.forall', ← and_imp, ← and_assoc, exists_prop] using\n      h.basis_left (normed_add_comm_group.nhds_zero_basis_norm_lt.prod_nhds ((nhds) _).basis_sets) U hU\n  rcases normed_field.exists_norm_lt 𝕜 hr with ⟨y, hy₀, hyr⟩\n  rw [norm_pos_iff] at hy₀\n  have : «expr • » y V ∈ (nhds) (0 : E) := (set_smul_mem_nhds_zero_iff hy₀).mpr hV\n  -- It remains to show that `y • V ⊆ balanced_core 𝕜 U`\n  refine' filter.mem_of_superset this (subset_balanced_core (mem_of_mem_nhds hU) fun a ha => _)\n  rw [smul_smul]\n  rintro _ ⟨z, hz, rfl⟩\n  refine' hrVU _ _ _ hz\n  rw [norm_mul, ← one_mul r]\n  exact mul_lt_mul' ha hyr (norm_nonneg y) one_pos\n#align balanced_core_mem_nhds_zero balanced_core_mem_nhds_zero\n\n",
 "balanced_core_eq_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced_core_eq_Inter (hs : (0 : E) ∈ s) :\n    balanced_core 𝕜 s =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" («expr • » r s) :=\n  by\n  refine' balanced_core_subset_balanced_core_aux.antisymm _\n  refine' (balanced_core_aux_balanced _).subset_core_of_subset (balanced_core_aux_subset s)\n  exact balanced_core_subset_balanced_core_aux (balanced_core_zero_mem hs)\n#align balanced_core_eq_Inter balanced_core_eq_Inter\n\n",
 "balanced_core_empty":
 "theorem balanced_core_empty : balanced_core 𝕜 (∅ : set E) = ∅ :=\n  eq_empty_of_subset_empty (balanced_core_subset _)\n#align balanced_core_empty balanced_core_empty\n\n",
 "balanced_core_balanced":
 "theorem balanced_core_balanced (s : set E) : balanced 𝕜 (balanced_core 𝕜 s) := fun _ => smul_balanced_core_subset s\n#align balanced_core_balanced balanced_core_balanced\n\n",
 "balanced_core_aux_subset":
 "theorem balanced_core_aux_subset (s : set E) : balanced_core_aux 𝕜 s ⊆ s := fun x hx => by\n  simpa only [one_smul] using mem_balanced_core_aux_iff.1 hx 1 norm_one.ge\n#align balanced_core_aux_subset balanced_core_aux_subset\n\n",
 "balanced_core_aux_maximal":
 "theorem balanced_core_aux_maximal (h : t ⊆ s) (ht : balanced 𝕜 t) : t ⊆ balanced_core_aux 𝕜 s :=\n  by\n  refine' fun x hx => mem_balanced_core_aux_iff.2 fun r hr => _\n  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.mp <| zero_lt_one.trans_le hr)]\n  refine' h (ht.smul_mem _ hx)\n  rw [norm_inv]\n  exact inv_le_one hr\n#align balanced_core_aux_maximal balanced_core_aux_maximal\n\n",
 "balanced_core_aux_empty":
 "@[simp]\ntheorem balanced_core_aux_empty : balanced_core_aux 𝕜 (∅ : set E) = ∅ :=\n  by\n  simp_rw [balanced_core_aux, Inter₂_eq_empty_iff, smul_set_empty]\n  exact fun _ => ⟨1, norm_one.ge, not_mem_empty _⟩\n#align balanced_core_aux_empty balanced_core_aux_empty\n\n",
 "balanced_core_aux_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced_core_aux_balanced (h0 : (0 : E) ∈ balanced_core_aux 𝕜 s) : balanced 𝕜 (balanced_core_aux 𝕜 s) :=\n  by\n  rintro a ha x ⟨y, hy, rfl⟩\n  obtain rfl | h := eq_or_ne a 0\n  · rwa [zero_smul]\n  rw [mem_balanced_core_aux_iff] at hy⊢\n  intro r hr\n  have h'' : 1 ≤ «expr‖ ‖» («expr • » a⁻¹ r) := by\n    rw [norm_smul, norm_inv]\n    exact one_le_mul_of_one_le_of_one_le (one_le_inv (norm_pos_iff.mpr h) ha) hr\n  have h' := hy («expr • » a⁻¹ r) h''\n  rwa [smul_assoc, mem_inv_smul_set_iff₀ h] at h'\n#align balanced_core_aux_balanced balanced_core_aux_balanced\n\n",
 "balanced_core":
 "protected theorem is_closed.balanced_core (hU : is_closed U) : is_closed (balanced_core 𝕜 U) :=\n  by\n  by_cases h : (0 : E) ∈ U\n  · rw [balanced_core_eq_Inter h]\n    refine' is_closed_Inter fun a => _\n    refine' is_closed_Inter fun ha => _\n    have ha' := lt_of_lt_of_le zero_lt_one ha\n    rw [norm_pos_iff] at ha'\n    refine' is_closed_map_smul_of_ne_zero ha' U hU\n  convert is_closed_empty\n  contrapose! h\n  exact balanced_core_nonempty_iff.mp (Set.nonempty_iff_ne_empty.2 h)\n#align is_closed.balanced_core is_closed.balanced_core\n\n",
 "balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced_hull.balanced (s : set E) : balanced 𝕜 (balanced_hull 𝕜 s) :=\n  by\n  intro a ha\n  simp_rw [balanced_hull, smul_set_Union₂, subset_def, mem_Union₂]\n  rintro x ⟨r, hr, hx⟩\n  rw [← smul_assoc] at hx\n  exact ⟨«expr • » a r, (semi_normed_ring.norm_mul _ _).trans (mul_le_one ha (norm_nonneg r) hr), hx⟩\n#align balanced_hull.balanced balanced_hull.balanced\n\n"}