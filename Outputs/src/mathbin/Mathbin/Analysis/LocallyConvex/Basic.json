{"zero_mem":
 "theorem absorbent.zero_mem (hs : absorbent ğ•œ s) : (0 : E) âˆˆ s :=\n  absorbs_zero_iff.1 <| absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.zero_mem absorbent.zero_mem\n\n",
 "union":
 "theorem balanced.union (hA : balanced ğ•œ A) (hB : balanced ğ•œ B) : balanced ğ•œ (A âˆª B) := fun a ha =>\n  smul_set_union.subset.trans <| union_subset_union (hA _ ha) <| hB _ ha\n#align balanced.union balanced.union\n\n",
 "subset_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem balanced.subset_smul (hA : balanced ğ•œ A) (ha : 1 â‰¤ Â«exprâ€– â€–Â» a) : A âŠ† Â«expr â€¢ Â» a A :=\n  by\n  refine' (subset_set_smul_iffâ‚€ _).2 (hA aâ»Â¹ _)\n  Â· rintro rfl\n    rw [norm_zero] at ha\n    exact zero_lt_one.not_le ha\n  Â· rw [norm_inv]\n    exact inv_le_one ha\n#align balanced.subset_smul balanced.subset_smul\n\n",
 "subset":
 "theorem absorbent.subset (hA : absorbent ğ•œ A) (hAB : A âŠ† B) : absorbent ğ•œ B :=\n  by\n  refine' forall_imp (fun x => _) hA\n  exact Exists.imp fun r => and.imp_right <| forallâ‚‚_imp fun a ha hx => Set.smul_set_mono hAB hx\n#align absorbent.subset absorbent.subset\n\n",
 "sub":
 "theorem balanced.sub (hs : balanced ğ•œ s) (ht : balanced ğ•œ t) : balanced ğ•œ (s - t) :=\n  by\n  simp_rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n#align balanced.sub balanced.sub\n\n",
 "smul_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Scalar multiplication (by possibly different types) of a balanced set is monotone. -/\ntheorem balanced.smul_mono (hs : balanced ğ• s) {a : ğ•} {b : ğ•œ} (h : Â«exprâ€– â€–Â» a â‰¤ Â«exprâ€– â€–Â» b) :\n    Â«expr â€¢ Â» a s âŠ† Â«expr â€¢ Â» b s := by\n  obtain rfl | hb := eq_or_ne b 0\n  Â· rw [norm_zero] at h\n    rw [norm_eq_zero.1 (h.antisymm <| norm_nonneg _)]\n    obtain rfl | h := s.eq_empty_or_nonempty\n    Â· simp_rw [smul_set_empty]\n    Â· simp_rw [zero_smul_set h]\n  rintro _ âŸ¨x, hx, rflâŸ©\n  refine' âŸ¨Â«expr â€¢ Â» bâ»Â¹ (Â«expr â€¢ Â» a x), _, smul_inv_smulâ‚€ hb _âŸ©\n  rw [â† smul_assoc]\n  refine' hs _ _ (smul_mem_smul_set hx)\n  rw [norm_smul, norm_inv, â† div_eq_inv_mul]\n  exact div_le_one_of_le h (norm_nonneg _)\n#align balanced.smul_mono balanced.smul_mono\n\n",
 "smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem balanced.smul_eq (hA : balanced ğ•œ A) (ha : Â«exprâ€– â€–Â» a = 1) : Â«expr â€¢ Â» a A = A :=\n  (hA _ ha.le).antisymm <| hA.subset_smul ha.ge\n#align balanced.smul_eq balanced.smul_eq\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem balanced.smul (a : ğ•) (hs : balanced ğ•œ s) : balanced ğ•œ (Â«expr â€¢ Â» a s) := fun b hb =>\n  (smul_comm _ _ _).subset.trans <| smul_set_mono <| hs _ hb\n#align balanced.smul balanced.smul\n\n",
 "neg_mem_iff":
 "theorem balanced.neg_mem_iff (hs : balanced ğ•œ s) : -x âˆˆ s â†” x âˆˆ s := by\n  convert hs.mem_smul_iff (norm_neg 1) <;> simp only [neg_smul, one_smul]\n#align balanced.neg_mem_iff balanced.neg_mem_iff\n\n",
 "neg":
 "theorem balanced.neg : balanced ğ•œ s â†’ balanced ğ•œ (-s) :=\n  forallâ‚‚_imp fun _ _ h => (smul_set_neg _ _).subset.trans <| neg_subset_neg.2 h\n#align balanced.neg balanced.neg\n\n",
 "mono_right":
 "theorem absorbs.mono_right (hs : absorbs ğ•œ s u) (h : v âŠ† u) : absorbs ğ•œ s v :=\n  hs.mono Subset.rfl h\n#align absorbs.mono_right absorbs.mono_right\n\n",
 "mono_left":
 "theorem absorbs.mono_left (hs : absorbs ğ•œ s u) (h : s âŠ† t) : absorbs ğ•œ t u :=\n  hs.mono h Subset.rfl\n#align absorbs.mono_left absorbs.mono_left\n\n",
 "mono":
 "theorem absorbs.mono (hs : absorbs ğ•œ s u) (hst : s âŠ† t) (hvu : v âŠ† u) : absorbs ğ•œ t v :=\n  let âŸ¨r, hr, hâŸ© := hs\n  âŸ¨r, hr, fun a ha => hvu.trans <| (h _ ha).trans <| smul_set_mono hstâŸ©\n#align absorbs.mono absorbs.mono\n\n",
 "mem_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem balanced.mem_smul_iff (hs : balanced ğ•œ s) (h : Â«exprâ€– â€–Â» a = Â«exprâ€– â€–Â» b) :\n    Â«expr â€¢ Â» a x âˆˆ s â†” Â«expr â€¢ Â» b x âˆˆ s :=\n  by\n  obtain rfl | hb := eq_or_ne b 0\n  Â· rw [norm_zero, norm_eq_zero] at h\n    rw [h]\n  have ha : a â‰  0 := norm_ne_zero_iff.1 (ne_of_eq_of_ne h <| norm_ne_zero_iff.2 hb)\n  constructor <;> intro h' <;> [rw [â† inv_mul_cancel_rightâ‚€ ha b], rw [â† inv_mul_cancel_rightâ‚€ hb a]] <;>\n    Â· rw [â† smul_eq_mul, smul_assoc]\n      refine' hs.smul_mem _ h'\n      simp [â† h, ha]\n#align balanced.mem_smul_iff balanced.mem_smul_iff\n\n",
 "interior":
 "/-- The interior of a balanced set is balanced if it contains the origin. -/\ntheorem balanced.interior (hA : balanced ğ•œ A) (h : (0 : E) âˆˆ interior A) : balanced ğ•œ (interior A) :=\n  by\n  rw [â† union_eq_self_of_subset_left (singleton_subset_iff.2 h)]\n  exact balanced_zero_union_interior hA\n#align balanced.interior balanced.interior\n\n",
 "inter":
 "theorem absorbs.inter (hs : absorbs ğ•œ s u) (ht : absorbs ğ•œ t u) : absorbs ğ•œ (s âˆ© t) u :=\n  by\n  obtain âŸ¨a, ha, hsâŸ© := hs\n  obtain âŸ¨b, hb, htâŸ© := ht\n  have h : 0 < max a b := lt_max_of_lt_left ha\n  refine' âŸ¨max a b, lt_max_of_lt_left ha, fun c hc => _âŸ©\n  rw [smul_set_interâ‚€ (norm_pos_iff.1 <| h.trans_le hc)]\n  exact subset_inter (hs _ <| le_of_max_le_left hc) (ht _ <| le_of_max_le_right hc)\n#align absorbs.inter absorbs.inter\n\n",
 "closure":
 "theorem balanced.closure (hA : balanced ğ•œ A) : balanced ğ•œ (closure A) := fun a ha =>\n  (image_closure_subset_closure_image <| continuous_id.const_smul _).trans <| closure_mono <| hA _ ha\n#align balanced.closure balanced.closure\n\n",
 "balanced_zero_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- The union of `{0}` with the interior of a balanced set is balanced. -/\ntheorem balanced_zero_union_interior (hA : balanced ğ•œ A) : balanced ğ•œ ((0 : set E) âˆª interior A) :=\n  by\n  intro a ha\n  obtain rfl | h := eq_or_ne a 0\n  Â· rw [zero_smul_set]\n    exacts[subset_union_left _ _, âŸ¨0, or.inl rflâŸ©]\n  Â· rw [â† image_smul, image_union]\n    apply union_subset_union\n    Â· rw [image_zero, smul_zero]\n      rfl\n    Â·\n      calc\n        Â«expr â€¢ Â» a (interior A) âŠ† interior (Â«expr â€¢ Â» a A) := (is_open_map_smulâ‚€ h).image_interior_subset A\n        _ âŠ† interior A := interior_mono (hA _ ha)\n        \n#align balanced_zero_union_interior balanced_zero_union_interior\n\n",
 "balanced_zero":
 "theorem balanced_zero : balanced ğ•œ (0 : set E) := fun a ha => (smul_zero _).subset\n#align balanced_zero balanced_zero\n\n",
 "balanced_univ":
 "@[simp]\ntheorem balanced_univ : balanced ğ•œ (univ : set E) := fun a ha => subset_univ _\n#align balanced_univ balanced_univ\n\n",
 "balanced_iff_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem balanced_iff_smul_mem : balanced ğ•œ s â†” âˆ€ â¦ƒa : ğ•œâ¦„, Â«exprâ€– â€–Â» a â‰¤ 1 â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ Â«expr â€¢ Â» a x âˆˆ s :=\n  forallâ‚‚_congr fun a ha => smul_set_subset_iff\n#align balanced_iff_smul_mem balanced_iff_smul_mem\n\n",
 "balanced_iff_neg_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem balanced_iff_neg_mem (hs : convex (exprâ„) s) : balanced (exprâ„) s â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ -x âˆˆ s :=\n  by\n  refine' âŸ¨fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => _âŸ©\n  rw [real.norm_eq_abs, abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring, add_smul, neg_smul, â† smul_neg]\n  exact\n    hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two) (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two)\n      (by ring)\n#align balanced_iff_neg_mem balanced_iff_neg_mem\n\n",
 "balanced_empty":
 "@[simp]\ntheorem balanced_empty : balanced ğ•œ (âˆ… : set E) := fun _ _ => by rw [smul_set_empty]\n#align balanced_empty balanced_empty\n\n",
 "balanced_convex_hull_of_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem balanced_convex_hull_of_balanced (hs : balanced ğ•œ s) : balanced ğ•œ (convex_hull (exprâ„) s) :=\n  by\n  suffices convex (exprâ„) { x | âˆ€ a : ğ•œ, Â«exprâ€– â€–Â» a â‰¤ 1 â†’ Â«expr â€¢ Â» a x âˆˆ convex_hull (exprâ„) s }\n    by\n    rw [balanced_iff_smul_mem] at hsâŠ¢\n    refine' fun a ha x hx => convex_hull_min _ this hx a ha\n    exact fun y hy a ha => subset_convex_hull (exprâ„) s (hs ha hy)\n  intro x hx y hy u v hu hv huv a ha\n  simp only [smul_add, â† smul_comm]\n  exact convex_convex_hull (exprâ„) s (hx a ha) (hy a ha) hu hv huv\n#align balanced_convex_hull_of_balanced balanced_convex_hull_of_balanced\n\n",
 "balanced_Unionâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem balanced_Unionâ‚‚ {f : âˆ€ i, Îº i â†’ set E} (h : âˆ€ i j, balanced ğ•œ (f i j)) :\n    balanced ğ•œ\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i j)) :=\n  balanced_Union fun _ => balanced_Union <| h _\n#align balanced_Unionâ‚‚ balanced_Unionâ‚‚\n\n",
 "balanced_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem balanced_Union {f : Î¹ â†’ set E} (h : âˆ€ i, balanced ğ•œ (f i)) :\n    balanced ğ•œ\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  fun a ha => (smul_set_Union _ _).subset.trans <| Union_mono fun _ => h _ _ ha\n#align balanced_Union balanced_Union\n\n",
 "balanced_Interâ‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem balanced_Interâ‚‚ {f : âˆ€ i, Îº i â†’ set E} (h : âˆ€ i j, balanced ğ•œ (f i j)) :\n    balanced ğ•œ\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i j)) :=\n  balanced_Inter fun _ => balanced_Inter <| h _\n#align balanced_Interâ‚‚ balanced_Interâ‚‚\n\n",
 "balanced_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\ntheorem balanced_Inter {f : Î¹ â†’ set E} (h : âˆ€ i, balanced ğ•œ (f i)) :\n    balanced ğ•œ\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  fun a ha => (smul_set_interáµ¢_subset _ _).trans <| Inter_mono fun _ => h _ _ ha\n#align balanced_Inter balanced_Inter\n\n",
 "add":
 "theorem balanced.add (hs : balanced ğ•œ s) (ht : balanced ğ•œ t) : balanced ğ•œ (s + t) := fun a ha =>\n  (smul_add _ _ _).subset.trans <| add_subset_add (hs _ ha) <| ht _ ha\n#align balanced.add balanced.add\n\n",
 "absorbs_zero_iff":
 "theorem absorbs_zero_iff : absorbs ğ•œ s 0 â†” (0 : E) âˆˆ s :=\n  by\n  refine' âŸ¨_, fun h => âŸ¨1, zero_lt_one, fun a _ => zero_subset.2 <| zero_mem_smul_set hâŸ©âŸ©\n  rintro âŸ¨r, hr, hâŸ©\n  obtain âŸ¨a, haâŸ© := normed_space.exists_lt_norm ğ•œ ğ•œ r\n  have := h _ ha.le\n  rwa [zero_subset, zero_mem_smul_set_iff] at this\n  exact norm_ne_zero_iff.1 (hr.trans ha).ne'\n#align absorbs_zero_iff absorbs_zero_iff\n\n",
 "absorbs_union":
 "@[simp]\ntheorem absorbs_union : absorbs ğ•œ s (u âˆª v) â†” absorbs ğ•œ s u âˆ§ absorbs ğ•œ s v :=\n  âŸ¨fun h => âŸ¨h.mono_right <| subset_union_left _ _, h.mono_right <| subset_union_right _ _âŸ©, fun h => h.1.union h.2âŸ©\n#align absorbs_union absorbs_union\n\n",
 "absorbs_self":
 "/-- A balanced set absorbs itself. -/\ntheorem balanced.absorbs_self (hA : balanced ğ•œ A) : absorbs ğ•œ A A :=\n  by\n  refine' âŸ¨1, zero_lt_one, fun a ha x hx => _âŸ©\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  refine' hA aâ»Â¹ _ (smul_mem_smul_set hx)\n  rw [norm_inv]\n  exact inv_le_one ha\n#align balanced.absorbs_self balanced.absorbs_self\n\n",
 "absorbs_inter":
 "@[simp]\ntheorem absorbs_inter : absorbs ğ•œ (s âˆ© t) u â†” absorbs ğ•œ s u âˆ§ absorbs ğ•œ t u :=\n  âŸ¨fun h => âŸ¨h.mono_left <| inter_subset_left _ _, h.mono_left <| inter_subset_right _ _âŸ©, fun h => h.1.inter h.2âŸ©\n#align absorbs_inter absorbs_inter\n\n",
 "absorbs_finite":
 "theorem absorbent.absorbs_finite {s : set E} (hs : absorbent ğ•œ s) {v : set E} (hv : v.finite) : absorbs ğ•œ s v :=\n  by\n  rw [â† Set.bunionáµ¢_of_singleton v]\n  exact hv.absorbs_Union.mpr fun _ _ => hs.absorbs\n#align absorbent.absorbs_finite absorbent.absorbs_finite\n\n",
 "absorbs_empty":
 "/-\nCopyright (c) 2019 Jean Lo. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jean Lo, Bhavik Mehta, YaÃ«l Dillies\n-/\n@[simp]\ntheorem absorbs_empty {s : set E} : absorbs ğ•œ s (âˆ… : set E) :=\n  âŸ¨1, one_pos, fun a ha => Set.empty_subset _âŸ©\n#align absorbs_empty absorbs_empty\n\n",
 "absorbs_Union_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem absorbs_Union_finset {Î¹ : Type _} {t : Finset Î¹} {f : Î¹ â†’ set E} :\n    absorbs ğ•œ s\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) â†”\n      âˆ€ i âˆˆ t, absorbs ğ•œ s (f i) :=\n  by\n  classical\n    induction' t using Finset.induction_on with i t ht hi\n    Â·\n      simp only [Finset.not_mem_empty, Set.unionáµ¢_false, Set.unionáµ¢_empty, absorbs_empty, is_empty.forall_iff,\n        imp_true_iff]\n    rw [finset.set_bUnion_insert, absorbs_union, hi]\n    constructor <;> intro h\n    Â· refine' fun _ hi' => (finset.mem_insert.mp hi').elim _ (h.2 _)\n      exact fun hi'' => by\n        rw [hi'']\n        exact h.1\n    exact âŸ¨h i (Finset.mem_insert_self i t), fun i' hi' => h i' (Finset.mem_insert_of_mem hi')âŸ©\n#align absorbs_Union_finset absorbs_Union_finset\n\n",
 "absorbs_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem set.finite.absorbs_Union {Î¹ : Type _} {s : set E} {t : set Î¹} {f : Î¹ â†’ set E} (hi : t.finite) :\n    absorbs ğ•œ s\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) â†”\n      âˆ€ i âˆˆ t, absorbs ğ•œ s (f i) :=\n  by\n  lift t to Finset Î¹ using hi\n  simp only [Finset.mem_coe]\n  exact absorbs_Union_finset\n#align set.finite.absorbs_Union set.finite.absorbs_Union\n\n",
 "absorbs":
 "theorem absorbent.absorbs (hs : absorbent ğ•œ s) {x : E} : absorbs ğ•œ s {x} :=\n  absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.absorbs absorbent.absorbs\n\n",
 "absorbent_univ":
 "theorem absorbent_univ : absorbent ğ•œ (univ : set E) :=\n  by\n  refine' fun x => âŸ¨1, zero_lt_one, fun a ha => _âŸ©\n  rw [smul_set_univâ‚€ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  exact trivial\n#align absorbent_univ absorbent_univ\n\n",
 "absorbent_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Every neighbourhood of the origin is absorbent. -/\ntheorem absorbent_nhds_zero (hA : A âˆˆ (nhds) (0 : E)) : absorbent ğ•œ A :=\n  by\n  intro x\n  obtain âŸ¨w, hwâ‚, hwâ‚‚, hwâ‚ƒâŸ© := mem_nhds_iff.mp hA\n  have hc : continuous fun t : ğ•œ => Â«expr â€¢ Â» t x := continuous_id.smul continuous_const\n  obtain âŸ¨r, hrâ‚, hrâ‚‚âŸ© := metric.is_open_iff.mp (hwâ‚‚.preimage hc) 0 (by rwa [mem_preimage, zero_smul])\n  have hrâ‚ƒ := inv_pos.mpr (half_pos hrâ‚)\n  refine' âŸ¨(r / 2)â»Â¹, hrâ‚ƒ, fun a haâ‚ => _âŸ©\n  have haâ‚‚ : 0 < Â«exprâ€– â€–Â» a := hrâ‚ƒ.trans_le haâ‚\n  refine' (mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.mp haâ‚‚) _ _).2 (hwâ‚ <| hrâ‚‚ _)\n  rw [metric.mem_ball, dist_zero_right, norm_inv]\n  calc\n    (Â«exprâ€– â€–Â» a)â»Â¹ â‰¤ r / 2 := (inv_le (half_pos hrâ‚) haâ‚‚).mp haâ‚\n    _ < r := half_lt_self hrâ‚\n    \n#align absorbent_nhds_zero absorbent_nhds_zero\n\n",
 "absorbent_iff_nonneg_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem absorbent_iff_nonneg_lt : absorbent ğ•œ A â†” âˆ€ x, âˆƒ r, 0 â‰¤ r âˆ§ âˆ€ â¦ƒa : ğ•œâ¦„, r < Â«exprâ€– â€–Â» a â†’ x âˆˆ Â«expr â€¢ Â» a A :=\n  forall_congr' fun x =>\n    âŸ¨fun âŸ¨r, hr, hxâŸ© => âŸ¨r, hr.le, fun a ha => hx a ha.leâŸ©, fun âŸ¨r, hr, hxâŸ© =>\n      âŸ¨r + 1, add_pos_of_nonneg_of_pos hr zero_lt_one, fun a ha =>\n        hx ((lt_add_of_pos_right r zero_lt_one).trans_le ha)âŸ©âŸ©\n#align absorbent_iff_nonneg_lt absorbent_iff_nonneg_lt\n\n",
 "absorbent_iff_forall_absorbs_singleton":
 "theorem absorbent_iff_forall_absorbs_singleton : absorbent ğ•œ A â†” âˆ€ x, absorbs ğ•œ A {x} := by\n  simp_rw [absorbs, absorbent, singleton_subset_iff]\n#align absorbent_iff_forall_absorbs_singleton absorbent_iff_forall_absorbs_singleton\n\n"}