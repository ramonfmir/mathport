{"zero_mem":
 "theorem absorbent.zero_mem (hs : absorbent 𝕜 s) : (0 : E) ∈ s :=\n  absorbs_zero_iff.1 <| absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.zero_mem absorbent.zero_mem\n\n",
 "union":
 "theorem balanced.union (hA : balanced 𝕜 A) (hB : balanced 𝕜 B) : balanced 𝕜 (A ∪ B) := fun a ha =>\n  smul_set_union.subset.trans <| union_subset_union (hA _ ha) <| hB _ ha\n#align balanced.union balanced.union\n\n",
 "subset_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced.subset_smul (hA : balanced 𝕜 A) (ha : 1 ≤ «expr‖ ‖» a) : A ⊆ «expr • » a A :=\n  by\n  refine' (subset_set_smul_iff₀ _).2 (hA a⁻¹ _)\n  · rintro rfl\n    rw [norm_zero] at ha\n    exact zero_lt_one.not_le ha\n  · rw [norm_inv]\n    exact inv_le_one ha\n#align balanced.subset_smul balanced.subset_smul\n\n",
 "subset":
 "theorem absorbent.subset (hA : absorbent 𝕜 A) (hAB : A ⊆ B) : absorbent 𝕜 B :=\n  by\n  refine' forall_imp (fun x => _) hA\n  exact Exists.imp fun r => and.imp_right <| forall₂_imp fun a ha hx => Set.smul_set_mono hAB hx\n#align absorbent.subset absorbent.subset\n\n",
 "sub":
 "theorem balanced.sub (hs : balanced 𝕜 s) (ht : balanced 𝕜 t) : balanced 𝕜 (s - t) :=\n  by\n  simp_rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n#align balanced.sub balanced.sub\n\n",
 "smul_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scalar multiplication (by possibly different types) of a balanced set is monotone. -/\ntheorem balanced.smul_mono (hs : balanced 𝕝 s) {a : 𝕝} {b : 𝕜} (h : «expr‖ ‖» a ≤ «expr‖ ‖» b) :\n    «expr • » a s ⊆ «expr • » b s := by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [norm_zero] at h\n    rw [norm_eq_zero.1 (h.antisymm <| norm_nonneg _)]\n    obtain rfl | h := s.eq_empty_or_nonempty\n    · simp_rw [smul_set_empty]\n    · simp_rw [zero_smul_set h]\n  rintro _ ⟨x, hx, rfl⟩\n  refine' ⟨«expr • » b⁻¹ («expr • » a x), _, smul_inv_smul₀ hb _⟩\n  rw [← smul_assoc]\n  refine' hs _ _ (smul_mem_smul_set hx)\n  rw [norm_smul, norm_inv, ← div_eq_inv_mul]\n  exact div_le_one_of_le h (norm_nonneg _)\n#align balanced.smul_mono balanced.smul_mono\n\n",
 "smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced.smul_eq (hA : balanced 𝕜 A) (ha : «expr‖ ‖» a = 1) : «expr • » a A = A :=\n  (hA _ ha.le).antisymm <| hA.subset_smul ha.ge\n#align balanced.smul_eq balanced.smul_eq\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced.smul (a : 𝕝) (hs : balanced 𝕜 s) : balanced 𝕜 («expr • » a s) := fun b hb =>\n  (smul_comm _ _ _).subset.trans <| smul_set_mono <| hs _ hb\n#align balanced.smul balanced.smul\n\n",
 "neg_mem_iff":
 "theorem balanced.neg_mem_iff (hs : balanced 𝕜 s) : -x ∈ s ↔ x ∈ s := by\n  convert hs.mem_smul_iff (norm_neg 1) <;> simp only [neg_smul, one_smul]\n#align balanced.neg_mem_iff balanced.neg_mem_iff\n\n",
 "neg":
 "theorem balanced.neg : balanced 𝕜 s → balanced 𝕜 (-s) :=\n  forall₂_imp fun _ _ h => (smul_set_neg _ _).subset.trans <| neg_subset_neg.2 h\n#align balanced.neg balanced.neg\n\n",
 "mono_right":
 "theorem absorbs.mono_right (hs : absorbs 𝕜 s u) (h : v ⊆ u) : absorbs 𝕜 s v :=\n  hs.mono Subset.rfl h\n#align absorbs.mono_right absorbs.mono_right\n\n",
 "mono_left":
 "theorem absorbs.mono_left (hs : absorbs 𝕜 s u) (h : s ⊆ t) : absorbs 𝕜 t u :=\n  hs.mono h Subset.rfl\n#align absorbs.mono_left absorbs.mono_left\n\n",
 "mono":
 "theorem absorbs.mono (hs : absorbs 𝕜 s u) (hst : s ⊆ t) (hvu : v ⊆ u) : absorbs 𝕜 t v :=\n  let ⟨r, hr, h⟩ := hs\n  ⟨r, hr, fun a ha => hvu.trans <| (h _ ha).trans <| smul_set_mono hst⟩\n#align absorbs.mono absorbs.mono\n\n",
 "mem_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced.mem_smul_iff (hs : balanced 𝕜 s) (h : «expr‖ ‖» a = «expr‖ ‖» b) :\n    «expr • » a x ∈ s ↔ «expr • » b x ∈ s :=\n  by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [norm_zero, norm_eq_zero] at h\n    rw [h]\n  have ha : a ≠ 0 := norm_ne_zero_iff.1 (ne_of_eq_of_ne h <| norm_ne_zero_iff.2 hb)\n  constructor <;> intro h' <;> [rw [← inv_mul_cancel_right₀ ha b], rw [← inv_mul_cancel_right₀ hb a]] <;>\n    · rw [← smul_eq_mul, smul_assoc]\n      refine' hs.smul_mem _ h'\n      simp [← h, ha]\n#align balanced.mem_smul_iff balanced.mem_smul_iff\n\n",
 "interior":
 "/-- The interior of a balanced set is balanced if it contains the origin. -/\ntheorem balanced.interior (hA : balanced 𝕜 A) (h : (0 : E) ∈ interior A) : balanced 𝕜 (interior A) :=\n  by\n  rw [← union_eq_self_of_subset_left (singleton_subset_iff.2 h)]\n  exact balanced_zero_union_interior hA\n#align balanced.interior balanced.interior\n\n",
 "inter":
 "theorem absorbs.inter (hs : absorbs 𝕜 s u) (ht : absorbs 𝕜 t u) : absorbs 𝕜 (s ∩ t) u :=\n  by\n  obtain ⟨a, ha, hs⟩ := hs\n  obtain ⟨b, hb, ht⟩ := ht\n  have h : 0 < max a b := lt_max_of_lt_left ha\n  refine' ⟨max a b, lt_max_of_lt_left ha, fun c hc => _⟩\n  rw [smul_set_inter₀ (norm_pos_iff.1 <| h.trans_le hc)]\n  exact subset_inter (hs _ <| le_of_max_le_left hc) (ht _ <| le_of_max_le_right hc)\n#align absorbs.inter absorbs.inter\n\n",
 "closure":
 "theorem balanced.closure (hA : balanced 𝕜 A) : balanced 𝕜 (closure A) := fun a ha =>\n  (image_closure_subset_closure_image <| continuous_id.const_smul _).trans <| closure_mono <| hA _ ha\n#align balanced.closure balanced.closure\n\n",
 "balanced_zero_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The union of `{0}` with the interior of a balanced set is balanced. -/\ntheorem balanced_zero_union_interior (hA : balanced 𝕜 A) : balanced 𝕜 ((0 : set E) ∪ interior A) :=\n  by\n  intro a ha\n  obtain rfl | h := eq_or_ne a 0\n  · rw [zero_smul_set]\n    exacts[subset_union_left _ _, ⟨0, or.inl rfl⟩]\n  · rw [← image_smul, image_union]\n    apply union_subset_union\n    · rw [image_zero, smul_zero]\n      rfl\n    ·\n      calc\n        «expr • » a (interior A) ⊆ interior («expr • » a A) := (is_open_map_smul₀ h).image_interior_subset A\n        _ ⊆ interior A := interior_mono (hA _ ha)\n        \n#align balanced_zero_union_interior balanced_zero_union_interior\n\n",
 "balanced_zero":
 "theorem balanced_zero : balanced 𝕜 (0 : set E) := fun a ha => (smul_zero _).subset\n#align balanced_zero balanced_zero\n\n",
 "balanced_univ":
 "@[simp]\ntheorem balanced_univ : balanced 𝕜 (univ : set E) := fun a ha => subset_univ _\n#align balanced_univ balanced_univ\n\n",
 "balanced_iff_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem balanced_iff_smul_mem : balanced 𝕜 s ↔ ∀ ⦃a : 𝕜⦄, «expr‖ ‖» a ≤ 1 → ∀ ⦃x : E⦄, x ∈ s → «expr • » a x ∈ s :=\n  forall₂_congr fun a ha => smul_set_subset_iff\n#align balanced_iff_smul_mem balanced_iff_smul_mem\n\n",
 "balanced_iff_neg_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem balanced_iff_neg_mem (hs : convex (exprℝ) s) : balanced (exprℝ) s ↔ ∀ ⦃x⦄, x ∈ s → -x ∈ s :=\n  by\n  refine' ⟨fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => _⟩\n  rw [real.norm_eq_abs, abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring, add_smul, neg_smul, ← smul_neg]\n  exact\n    hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two) (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two)\n      (by ring)\n#align balanced_iff_neg_mem balanced_iff_neg_mem\n\n",
 "balanced_empty":
 "@[simp]\ntheorem balanced_empty : balanced 𝕜 (∅ : set E) := fun _ _ => by rw [smul_set_empty]\n#align balanced_empty balanced_empty\n\n",
 "balanced_convex_hull_of_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem balanced_convex_hull_of_balanced (hs : balanced 𝕜 s) : balanced 𝕜 (convex_hull (exprℝ) s) :=\n  by\n  suffices convex (exprℝ) { x | ∀ a : 𝕜, «expr‖ ‖» a ≤ 1 → «expr • » a x ∈ convex_hull (exprℝ) s }\n    by\n    rw [balanced_iff_smul_mem] at hs⊢\n    refine' fun a ha x hx => convex_hull_min _ this hx a ha\n    exact fun y hy a ha => subset_convex_hull (exprℝ) s (hs ha hy)\n  intro x hx y hy u v hu hv huv a ha\n  simp only [smul_add, ← smul_comm]\n  exact convex_convex_hull (exprℝ) s (hx a ha) (hy a ha) hu hv huv\n#align balanced_convex_hull_of_balanced balanced_convex_hull_of_balanced\n\n",
 "balanced_Union₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem balanced_Union₂ {f : ∀ i, κ i → set E} (h : ∀ i j, balanced 𝕜 (f i j)) :\n    balanced 𝕜\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i j)) :=\n  balanced_Union fun _ => balanced_Union <| h _\n#align balanced_Union₂ balanced_Union₂\n\n",
 "balanced_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem balanced_Union {f : ι → set E} (h : ∀ i, balanced 𝕜 (f i)) :\n    balanced 𝕜\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  fun a ha => (smul_set_Union _ _).subset.trans <| Union_mono fun _ => h _ _ ha\n#align balanced_Union balanced_Union\n\n",
 "balanced_Inter₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem balanced_Inter₂ {f : ∀ i, κ i → set E} (h : ∀ i j, balanced 𝕜 (f i j)) :\n    balanced 𝕜\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i j)) :=\n  balanced_Inter fun _ => balanced_Inter <| h _\n#align balanced_Inter₂ balanced_Inter₂\n\n",
 "balanced_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem balanced_Inter {f : ι → set E} (h : ∀ i, balanced 𝕜 (f i)) :\n    balanced 𝕜\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  fun a ha => (smul_set_interᵢ_subset _ _).trans <| Inter_mono fun _ => h _ _ ha\n#align balanced_Inter balanced_Inter\n\n",
 "add":
 "theorem balanced.add (hs : balanced 𝕜 s) (ht : balanced 𝕜 t) : balanced 𝕜 (s + t) := fun a ha =>\n  (smul_add _ _ _).subset.trans <| add_subset_add (hs _ ha) <| ht _ ha\n#align balanced.add balanced.add\n\n",
 "absorbs_zero_iff":
 "theorem absorbs_zero_iff : absorbs 𝕜 s 0 ↔ (0 : E) ∈ s :=\n  by\n  refine' ⟨_, fun h => ⟨1, zero_lt_one, fun a _ => zero_subset.2 <| zero_mem_smul_set h⟩⟩\n  rintro ⟨r, hr, h⟩\n  obtain ⟨a, ha⟩ := normed_space.exists_lt_norm 𝕜 𝕜 r\n  have := h _ ha.le\n  rwa [zero_subset, zero_mem_smul_set_iff] at this\n  exact norm_ne_zero_iff.1 (hr.trans ha).ne'\n#align absorbs_zero_iff absorbs_zero_iff\n\n",
 "absorbs_union":
 "@[simp]\ntheorem absorbs_union : absorbs 𝕜 s (u ∪ v) ↔ absorbs 𝕜 s u ∧ absorbs 𝕜 s v :=\n  ⟨fun h => ⟨h.mono_right <| subset_union_left _ _, h.mono_right <| subset_union_right _ _⟩, fun h => h.1.union h.2⟩\n#align absorbs_union absorbs_union\n\n",
 "absorbs_self":
 "/-- A balanced set absorbs itself. -/\ntheorem balanced.absorbs_self (hA : balanced 𝕜 A) : absorbs 𝕜 A A :=\n  by\n  refine' ⟨1, zero_lt_one, fun a ha x hx => _⟩\n  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  refine' hA a⁻¹ _ (smul_mem_smul_set hx)\n  rw [norm_inv]\n  exact inv_le_one ha\n#align balanced.absorbs_self balanced.absorbs_self\n\n",
 "absorbs_inter":
 "@[simp]\ntheorem absorbs_inter : absorbs 𝕜 (s ∩ t) u ↔ absorbs 𝕜 s u ∧ absorbs 𝕜 t u :=\n  ⟨fun h => ⟨h.mono_left <| inter_subset_left _ _, h.mono_left <| inter_subset_right _ _⟩, fun h => h.1.inter h.2⟩\n#align absorbs_inter absorbs_inter\n\n",
 "absorbs_finite":
 "theorem absorbent.absorbs_finite {s : set E} (hs : absorbent 𝕜 s) {v : set E} (hv : v.finite) : absorbs 𝕜 s v :=\n  by\n  rw [← Set.bunionᵢ_of_singleton v]\n  exact hv.absorbs_Union.mpr fun _ _ => hs.absorbs\n#align absorbent.absorbs_finite absorbent.absorbs_finite\n\n",
 "absorbs_empty":
 "/-\nCopyright (c) 2019 Jean Lo. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jean Lo, Bhavik Mehta, Yaël Dillies\n-/\n@[simp]\ntheorem absorbs_empty {s : set E} : absorbs 𝕜 s (∅ : set E) :=\n  ⟨1, one_pos, fun a ha => Set.empty_subset _⟩\n#align absorbs_empty absorbs_empty\n\n",
 "absorbs_Union_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem absorbs_Union_finset {ι : Type _} {t : Finset ι} {f : ι → set E} :\n    absorbs 𝕜 s\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ↔\n      ∀ i ∈ t, absorbs 𝕜 s (f i) :=\n  by\n  classical\n    induction' t using Finset.induction_on with i t ht hi\n    ·\n      simp only [Finset.not_mem_empty, Set.unionᵢ_false, Set.unionᵢ_empty, absorbs_empty, is_empty.forall_iff,\n        imp_true_iff]\n    rw [finset.set_bUnion_insert, absorbs_union, hi]\n    constructor <;> intro h\n    · refine' fun _ hi' => (finset.mem_insert.mp hi').elim _ (h.2 _)\n      exact fun hi'' => by\n        rw [hi'']\n        exact h.1\n    exact ⟨h i (Finset.mem_insert_self i t), fun i' hi' => h i' (Finset.mem_insert_of_mem hi')⟩\n#align absorbs_Union_finset absorbs_Union_finset\n\n",
 "absorbs_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set.finite.absorbs_Union {ι : Type _} {s : set E} {t : set ι} {f : ι → set E} (hi : t.finite) :\n    absorbs 𝕜 s\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ↔\n      ∀ i ∈ t, absorbs 𝕜 s (f i) :=\n  by\n  lift t to Finset ι using hi\n  simp only [Finset.mem_coe]\n  exact absorbs_Union_finset\n#align set.finite.absorbs_Union set.finite.absorbs_Union\n\n",
 "absorbs":
 "theorem absorbent.absorbs (hs : absorbent 𝕜 s) {x : E} : absorbs 𝕜 s {x} :=\n  absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.absorbs absorbent.absorbs\n\n",
 "absorbent_univ":
 "theorem absorbent_univ : absorbent 𝕜 (univ : set E) :=\n  by\n  refine' fun x => ⟨1, zero_lt_one, fun a ha => _⟩\n  rw [smul_set_univ₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  exact trivial\n#align absorbent_univ absorbent_univ\n\n",
 "absorbent_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Every neighbourhood of the origin is absorbent. -/\ntheorem absorbent_nhds_zero (hA : A ∈ (nhds) (0 : E)) : absorbent 𝕜 A :=\n  by\n  intro x\n  obtain ⟨w, hw₁, hw₂, hw₃⟩ := mem_nhds_iff.mp hA\n  have hc : continuous fun t : 𝕜 => «expr • » t x := continuous_id.smul continuous_const\n  obtain ⟨r, hr₁, hr₂⟩ := metric.is_open_iff.mp (hw₂.preimage hc) 0 (by rwa [mem_preimage, zero_smul])\n  have hr₃ := inv_pos.mpr (half_pos hr₁)\n  refine' ⟨(r / 2)⁻¹, hr₃, fun a ha₁ => _⟩\n  have ha₂ : 0 < «expr‖ ‖» a := hr₃.trans_le ha₁\n  refine' (mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.mp ha₂) _ _).2 (hw₁ <| hr₂ _)\n  rw [metric.mem_ball, dist_zero_right, norm_inv]\n  calc\n    («expr‖ ‖» a)⁻¹ ≤ r / 2 := (inv_le (half_pos hr₁) ha₂).mp ha₁\n    _ < r := half_lt_self hr₁\n    \n#align absorbent_nhds_zero absorbent_nhds_zero\n\n",
 "absorbent_iff_nonneg_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem absorbent_iff_nonneg_lt : absorbent 𝕜 A ↔ ∀ x, ∃ r, 0 ≤ r ∧ ∀ ⦃a : 𝕜⦄, r < «expr‖ ‖» a → x ∈ «expr • » a A :=\n  forall_congr' fun x =>\n    ⟨fun ⟨r, hr, hx⟩ => ⟨r, hr.le, fun a ha => hx a ha.le⟩, fun ⟨r, hr, hx⟩ =>\n      ⟨r + 1, add_pos_of_nonneg_of_pos hr zero_lt_one, fun a ha =>\n        hx ((lt_add_of_pos_right r zero_lt_one).trans_le ha)⟩⟩\n#align absorbent_iff_nonneg_lt absorbent_iff_nonneg_lt\n\n",
 "absorbent_iff_forall_absorbs_singleton":
 "theorem absorbent_iff_forall_absorbs_singleton : absorbent 𝕜 A ↔ ∀ x, absorbs 𝕜 A {x} := by\n  simp_rw [absorbs, absorbent, singleton_subset_iff]\n#align absorbent_iff_forall_absorbs_singleton absorbent_iff_forall_absorbs_singleton\n\n"}