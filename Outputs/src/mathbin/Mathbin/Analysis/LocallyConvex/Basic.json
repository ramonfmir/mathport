{"zero_mem":
 "#print Absorbent.zero_mem /-\ntheorem Absorbent.zero_mem (hs : Absorbent 𝕜 s) : (0 : E) ∈ s :=\n  absorbs_zero_iff.1 <| absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.zero_mem Absorbent.zero_mem\n-/\n\n",
 "union":
 "#print Balanced.union /-\ntheorem Balanced.union (hA : Balanced 𝕜 A) (hB : Balanced 𝕜 B) : Balanced 𝕜 (A ∪ B) := fun a ha =>\n  smul_set_union.subset.trans <| union_subset_union (hA _ ha) <| hB _ ha\n#align balanced.union Balanced.union\n-/\n\n",
 "subset_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Balanced.subset_smul /-\ntheorem Balanced.subset_smul (hA : Balanced 𝕜 A) (ha : 1 ≤ «expr‖ ‖» a) : A ⊆ «expr • » a A :=\n  by\n  refine' (subset_set_smul_iff₀ _).2 (hA a⁻¹ _)\n  · rintro rfl\n    rw [norm_zero] at ha\n    exact zero_lt_one.not_le ha\n  · rw [norm_inv]\n    exact inv_le_one ha\n#align balanced.subset_smul Balanced.subset_smul\n-/\n\n",
 "subset":
 "#print Absorbent.subset /-\ntheorem Absorbent.subset (hA : Absorbent 𝕜 A) (hAB : A ⊆ B) : Absorbent 𝕜 B :=\n  by\n  refine' forall_imp (fun x => _) hA\n  exact Exists.imp fun r => And.imp_right <| forall₂_imp fun a ha hx => Set.smul_set_mono hAB hx\n#align absorbent.subset Absorbent.subset\n-/\n\n",
 "sub":
 "#print Balanced.sub /-\ntheorem Balanced.sub (hs : Balanced 𝕜 s) (ht : Balanced 𝕜 t) : Balanced 𝕜 (s - t) :=\n  by\n  simp_rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n#align balanced.sub Balanced.sub\n-/\n\n",
 "smul_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Balanced.smul_mono /-\n/-- Scalar multiplication (by possibly different types) of a balanced set is monotone. -/\ntheorem Balanced.smul_mono (hs : Balanced 𝕝 s) {a : 𝕝} {b : 𝕜} (h : «expr‖ ‖» a ≤ «expr‖ ‖» b) :\n    «expr • » a s ⊆ «expr • » b s := by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [norm_zero] at h\n    rw [norm_eq_zero.1 (h.antisymm <| norm_nonneg _)]\n    obtain rfl | h := s.eq_empty_or_nonempty\n    · simp_rw [smul_set_empty]\n    · simp_rw [zero_smul_set h]\n  rintro _ ⟨x, hx, rfl⟩\n  refine' ⟨«expr • » b⁻¹ («expr • » a x), _, smul_inv_smul₀ hb _⟩\n  rw [← smul_assoc]\n  refine' hs _ _ (smul_mem_smul_set hx)\n  rw [norm_smul, norm_inv, ← div_eq_inv_mul]\n  exact div_le_one_of_le h (norm_nonneg _)\n#align balanced.smul_mono Balanced.smul_mono\n-/\n\n",
 "smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Balanced.smul_eq /-\ntheorem Balanced.smul_eq (hA : Balanced 𝕜 A) (ha : «expr‖ ‖» a = 1) : «expr • » a A = A :=\n  (hA _ ha.le).antisymm <| hA.subset_smul ha.ge\n#align balanced.smul_eq Balanced.smul_eq\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Balanced.smul /-\ntheorem Balanced.smul (a : 𝕝) (hs : Balanced 𝕜 s) : Balanced 𝕜 («expr • » a s) := fun b hb =>\n  (smul_comm _ _ _).subset.trans <| smul_set_mono <| hs _ hb\n#align balanced.smul Balanced.smul\n-/\n\n",
 "neg_mem_iff":
 "#print Balanced.neg_mem_iff /-\ntheorem Balanced.neg_mem_iff (hs : Balanced 𝕜 s) : -x ∈ s ↔ x ∈ s := by\n  convert hs.mem_smul_iff (norm_neg 1) <;> simp only [neg_smul, one_smul]\n#align balanced.neg_mem_iff Balanced.neg_mem_iff\n-/\n\n",
 "neg":
 "#print Balanced.neg /-\ntheorem Balanced.neg : Balanced 𝕜 s → Balanced 𝕜 (-s) :=\n  forall₂_imp fun _ _ h => (smul_set_neg _ _).subset.trans <| neg_subset_neg.2 h\n#align balanced.neg Balanced.neg\n-/\n\n",
 "mono_right":
 "#print Absorbs.mono_right /-\ntheorem Absorbs.mono_right (hs : Absorbs 𝕜 s u) (h : v ⊆ u) : Absorbs 𝕜 s v :=\n  hs.mono Subset.rfl h\n#align absorbs.mono_right Absorbs.mono_right\n-/\n\n",
 "mono_left":
 "#print Absorbs.mono_left /-\ntheorem Absorbs.mono_left (hs : Absorbs 𝕜 s u) (h : s ⊆ t) : Absorbs 𝕜 t u :=\n  hs.mono h Subset.rfl\n#align absorbs.mono_left Absorbs.mono_left\n-/\n\n",
 "mono":
 "#print Absorbs.mono /-\ntheorem Absorbs.mono (hs : Absorbs 𝕜 s u) (hst : s ⊆ t) (hvu : v ⊆ u) : Absorbs 𝕜 t v :=\n  let ⟨r, hr, h⟩ := hs\n  ⟨r, hr, fun a ha => hvu.trans <| (h _ ha).trans <| smul_set_mono hst⟩\n#align absorbs.mono Absorbs.mono\n-/\n\n",
 "mem_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Balanced.mem_smul_iff /-\ntheorem Balanced.mem_smul_iff (hs : Balanced 𝕜 s) (h : «expr‖ ‖» a = «expr‖ ‖» b) :\n    «expr • » a x ∈ s ↔ «expr • » b x ∈ s :=\n  by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [norm_zero, norm_eq_zero] at h\n    rw [h]\n  have ha : a ≠ 0 := norm_ne_zero_iff.1 (ne_of_eq_of_ne h <| norm_ne_zero_iff.2 hb)\n  constructor <;> intro h' <;> [rw [← inv_mul_cancel_right₀ ha b], rw [← inv_mul_cancel_right₀ hb a]] <;>\n    · rw [← smul_eq_mul, smul_assoc]\n      refine' hs.smul_mem _ h'\n      simp [← h, ha]\n#align balanced.mem_smul_iff Balanced.mem_smul_iff\n-/\n\n",
 "interior":
 "#print Balanced.interior /-\n/-- The interior of a balanced set is balanced if it contains the origin. -/\ntheorem Balanced.interior (hA : Balanced 𝕜 A) (h : (0 : E) ∈ interior A) : Balanced 𝕜 (interior A) :=\n  by\n  rw [← union_eq_self_of_subset_left (singleton_subset_iff.2 h)]\n  exact balanced_zero_union_interior hA\n#align balanced.interior Balanced.interior\n-/\n\n",
 "inter":
 "#print Absorbs.inter /-\ntheorem Absorbs.inter (hs : Absorbs 𝕜 s u) (ht : Absorbs 𝕜 t u) : Absorbs 𝕜 (s ∩ t) u :=\n  by\n  obtain ⟨a, ha, hs⟩ := hs\n  obtain ⟨b, hb, ht⟩ := ht\n  have h : 0 < max a b := lt_max_of_lt_left ha\n  refine' ⟨max a b, lt_max_of_lt_left ha, fun c hc => _⟩\n  rw [smul_set_inter₀ (norm_pos_iff.1 <| h.trans_le hc)]\n  exact subset_inter (hs _ <| le_of_max_le_left hc) (ht _ <| le_of_max_le_right hc)\n#align absorbs.inter Absorbs.inter\n-/\n\n",
 "closure":
 "#print Balanced.closure /-\ntheorem Balanced.closure (hA : Balanced 𝕜 A) : Balanced 𝕜 (closure A) := fun a ha =>\n  (image_closure_subset_closure_image <| continuous_id.const_smul _).trans <| closure_mono <| hA _ ha\n#align balanced.closure Balanced.closure\n-/\n\n",
 "balanced_zero_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print balanced_zero_union_interior /-\n/-- The union of `{0}` with the interior of a balanced set is balanced. -/\ntheorem balanced_zero_union_interior (hA : Balanced 𝕜 A) : Balanced 𝕜 ((0 : Set E) ∪ interior A) :=\n  by\n  intro a ha\n  obtain rfl | h := eq_or_ne a 0\n  · rw [zero_smul_set]\n    exacts[subset_union_left _ _, ⟨0, or.inl rfl⟩]\n  · rw [← image_smul, image_union]\n    apply union_subset_union\n    · rw [image_zero, smul_zero]\n      rfl\n    ·\n      calc\n        «expr • » a (interior A) ⊆ interior («expr • » a A) := (isOpenMap_smul₀ h).image_interior_subset A\n        _ ⊆ interior A := interior_mono (hA _ ha)\n        \n#align balanced_zero_union_interior balanced_zero_union_interior\n-/\n\n",
 "balanced_zero":
 "#print balanced_zero /-\ntheorem balanced_zero : Balanced 𝕜 (0 : Set E) := fun a ha => (smul_zero _).subset\n#align balanced_zero balanced_zero\n-/\n\n",
 "balanced_univ":
 "#print balanced_univ /-\n@[simp]\ntheorem balanced_univ : Balanced 𝕜 (univ : Set E) := fun a ha => subset_univ _\n#align balanced_univ balanced_univ\n-/\n\n",
 "balanced_unionᵢ₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print balanced_unionᵢ₂ /-\ntheorem balanced_unionᵢ₂ {f : ∀ i, κ i → Set E} (h : ∀ i j, Balanced 𝕜 (f i j)) :\n    Balanced 𝕜\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i j)) :=\n  balanced_unionᵢ fun _ => balanced_unionᵢ <| h _\n#align balanced_Union₂ balanced_unionᵢ₂\n-/\n\n",
 "balanced_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print balanced_unionᵢ /-\ntheorem balanced_unionᵢ {f : ι → Set E} (h : ∀ i, Balanced 𝕜 (f i)) :\n    Balanced 𝕜\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  fun a ha => (smul_set_Union _ _).subset.trans <| unionᵢ_mono fun _ => h _ _ ha\n#align balanced_Union balanced_unionᵢ\n-/\n\n",
 "balanced_interᵢ₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print balanced_interᵢ₂ /-\ntheorem balanced_interᵢ₂ {f : ∀ i, κ i → Set E} (h : ∀ i j, Balanced 𝕜 (f i j)) :\n    Balanced 𝕜\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i j)) :=\n  balanced_interᵢ fun _ => balanced_interᵢ <| h _\n#align balanced_Inter₂ balanced_interᵢ₂\n-/\n\n",
 "balanced_interᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n#print balanced_interᵢ /-\ntheorem balanced_interᵢ {f : ι → Set E} (h : ∀ i, Balanced 𝕜 (f i)) :\n    Balanced 𝕜\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  fun a ha => (smul_set_interᵢ_subset _ _).trans <| interᵢ_mono fun _ => h _ _ ha\n#align balanced_Inter balanced_interᵢ\n-/\n\n",
 "balanced_iff_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print balanced_iff_smul_mem /-\ntheorem balanced_iff_smul_mem : Balanced 𝕜 s ↔ ∀ ⦃a : 𝕜⦄, «expr‖ ‖» a ≤ 1 → ∀ ⦃x : E⦄, x ∈ s → «expr • » a x ∈ s :=\n  forall₂_congr fun a ha => smul_set_subset_iff\n#align balanced_iff_smul_mem balanced_iff_smul_mem\n-/\n\n",
 "balanced_iff_neg_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print balanced_iff_neg_mem /-\ntheorem balanced_iff_neg_mem (hs : Convex (exprℝ) s) : Balanced (exprℝ) s ↔ ∀ ⦃x⦄, x ∈ s → -x ∈ s :=\n  by\n  refine' ⟨fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => _⟩\n  rw [Real.norm_eq_abs, abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring, add_smul, neg_smul, ← smul_neg]\n  exact\n    hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two) (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two)\n      (by ring)\n#align balanced_iff_neg_mem balanced_iff_neg_mem\n-/\n\n",
 "balanced_empty":
 "#print balanced_empty /-\n@[simp]\ntheorem balanced_empty : Balanced 𝕜 (∅ : Set E) := fun _ _ => by rw [smul_set_empty]\n#align balanced_empty balanced_empty\n-/\n\n",
 "balanced_convexHull_of_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print balanced_convexHull_of_balanced /-\ntheorem balanced_convexHull_of_balanced (hs : Balanced 𝕜 s) : Balanced 𝕜 (convexHull (exprℝ) s) :=\n  by\n  suffices Convex (exprℝ) { x | ∀ a : 𝕜, «expr‖ ‖» a ≤ 1 → «expr • » a x ∈ convexHull (exprℝ) s }\n    by\n    rw [balanced_iff_smul_mem] at hs⊢\n    refine' fun a ha x hx => convexHull_min _ this hx a ha\n    exact fun y hy a ha => subset_convexHull (exprℝ) s (hs ha hy)\n  intro x hx y hy u v hu hv huv a ha\n  simp only [smul_add, ← smul_comm]\n  exact convex_convexHull (exprℝ) s (hx a ha) (hy a ha) hu hv huv\n#align balanced_convex_hull_of_balanced balanced_convexHull_of_balanced\n-/\n\n",
 "add":
 "#print Balanced.add /-\ntheorem Balanced.add (hs : Balanced 𝕜 s) (ht : Balanced 𝕜 t) : Balanced 𝕜 (s + t) := fun a ha =>\n  (smul_add _ _ _).subset.trans <| add_subset_add (hs _ ha) <| ht _ ha\n#align balanced.add Balanced.add\n-/\n\n",
 "absorbs_zero_iff":
 "#print absorbs_zero_iff /-\ntheorem absorbs_zero_iff : Absorbs 𝕜 s 0 ↔ (0 : E) ∈ s :=\n  by\n  refine' ⟨_, fun h => ⟨1, zero_lt_one, fun a _ => zero_subset.2 <| zero_mem_smul_set h⟩⟩\n  rintro ⟨r, hr, h⟩\n  obtain ⟨a, ha⟩ := NormedSpace.exists_lt_norm 𝕜 𝕜 r\n  have := h _ ha.le\n  rwa [zero_subset, zero_mem_smul_set_iff] at this\n  exact norm_ne_zero_iff.1 (hr.trans ha).ne'\n#align absorbs_zero_iff absorbs_zero_iff\n-/\n\n",
 "absorbs_unionᵢ_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print absorbs_unionᵢ_finset /-\ntheorem absorbs_unionᵢ_finset {ι : Type _} {t : Finset ι} {f : ι → Set E} :\n    Absorbs 𝕜 s\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ↔\n      ∀ i ∈ t, Absorbs 𝕜 s (f i) :=\n  by\n  classical\n    induction' t using Finset.induction_on with i t ht hi\n    ·\n      simp only [Finset.not_mem_empty, Set.unionᵢ_false, Set.unionᵢ_empty, absorbs_empty, IsEmpty.forall_iff,\n        imp_true_iff]\n    rw [Finset.set_bunionᵢ_insert, absorbs_union, hi]\n    constructor <;> intro h\n    · refine' fun _ hi' => (finset.mem_insert.mp hi').elim _ (h.2 _)\n      exact fun hi'' => by\n        rw [hi'']\n        exact h.1\n    exact ⟨h i (Finset.mem_insert_self i t), fun i' hi' => h i' (Finset.mem_insert_of_mem hi')⟩\n#align absorbs_Union_finset absorbs_unionᵢ_finset\n-/\n\n",
 "absorbs_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Set.Finite.absorbs_unionᵢ /-\ntheorem Set.Finite.absorbs_unionᵢ {ι : Type _} {s : Set E} {t : Set ι} {f : ι → Set E} (hi : t.finite) :\n    Absorbs 𝕜 s\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) ↔\n      ∀ i ∈ t, Absorbs 𝕜 s (f i) :=\n  by\n  lift t to Finset ι using hi\n  simp only [Finset.mem_coe]\n  exact absorbs_unionᵢ_finset\n#align set.finite.absorbs_Union Set.Finite.absorbs_unionᵢ\n-/\n\n",
 "absorbs_union":
 "#print absorbs_union /-\n@[simp]\ntheorem absorbs_union : Absorbs 𝕜 s (u ∪ v) ↔ Absorbs 𝕜 s u ∧ Absorbs 𝕜 s v :=\n  ⟨fun h => ⟨h.mono_right <| subset_union_left _ _, h.mono_right <| subset_union_right _ _⟩, fun h => h.1.union h.2⟩\n#align absorbs_union absorbs_union\n-/\n\n",
 "absorbs_self":
 "#print Balanced.absorbs_self /-\n/-- A balanced set absorbs itself. -/\ntheorem Balanced.absorbs_self (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A :=\n  by\n  refine' ⟨1, zero_lt_one, fun a ha x hx => _⟩\n  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  refine' hA a⁻¹ _ (smul_mem_smul_set hx)\n  rw [norm_inv]\n  exact inv_le_one ha\n#align balanced.absorbs_self Balanced.absorbs_self\n-/\n\n",
 "absorbs_inter":
 "#print absorbs_inter /-\n@[simp]\ntheorem absorbs_inter : Absorbs 𝕜 (s ∩ t) u ↔ Absorbs 𝕜 s u ∧ Absorbs 𝕜 t u :=\n  ⟨fun h => ⟨h.mono_left <| inter_subset_left _ _, h.mono_left <| inter_subset_right _ _⟩, fun h => h.1.inter h.2⟩\n#align absorbs_inter absorbs_inter\n-/\n\n",
 "absorbs_finite":
 "#print Absorbent.absorbs_finite /-\ntheorem Absorbent.absorbs_finite {s : Set E} (hs : Absorbent 𝕜 s) {v : Set E} (hv : v.finite) : Absorbs 𝕜 s v :=\n  by\n  rw [← Set.bunionᵢ_of_singleton v]\n  exact hv.absorbs_Union.mpr fun _ _ => hs.absorbs\n#align absorbent.absorbs_finite Absorbent.absorbs_finite\n-/\n\n",
 "absorbs_empty":
 "#print absorbs_empty /-\n/-\nCopyright (c) 2019 Jean Lo. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jean Lo, Bhavik Mehta, Yaël Dillies\n-/\n@[simp]\ntheorem absorbs_empty {s : Set E} : Absorbs 𝕜 s (∅ : Set E) :=\n  ⟨1, one_pos, fun a ha => Set.empty_subset _⟩\n#align absorbs_empty absorbs_empty\n-/\n\n",
 "absorbs":
 "#print Absorbent.absorbs /-\ntheorem Absorbent.absorbs (hs : Absorbent 𝕜 s) {x : E} : Absorbs 𝕜 s {x} :=\n  absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.absorbs Absorbent.absorbs\n-/\n\n",
 "absorbent_univ":
 "#print absorbent_univ /-\ntheorem absorbent_univ : Absorbent 𝕜 (univ : Set E) :=\n  by\n  refine' fun x => ⟨1, zero_lt_one, fun a ha => _⟩\n  rw [smul_set_univ₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  exact trivial\n#align absorbent_univ absorbent_univ\n-/\n\n",
 "absorbent_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print absorbent_nhds_zero /-\n/-- Every neighbourhood of the origin is absorbent. -/\ntheorem absorbent_nhds_zero (hA : A ∈ (nhds) (0 : E)) : Absorbent 𝕜 A :=\n  by\n  intro x\n  obtain ⟨w, hw₁, hw₂, hw₃⟩ := mem_nhds_iff.mp hA\n  have hc : Continuous fun t : 𝕜 => «expr • » t x := continuous_id.smul continuous_const\n  obtain ⟨r, hr₁, hr₂⟩ := metric.is_open_iff.mp (hw₂.preimage hc) 0 (by rwa [mem_preimage, zero_smul])\n  have hr₃ := inv_pos.mpr (half_pos hr₁)\n  refine' ⟨(r / 2)⁻¹, hr₃, fun a ha₁ => _⟩\n  have ha₂ : 0 < «expr‖ ‖» a := hr₃.trans_le ha₁\n  refine' (mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.mp ha₂) _ _).2 (hw₁ <| hr₂ _)\n  rw [Metric.mem_ball, dist_zero_right, norm_inv]\n  calc\n    («expr‖ ‖» a)⁻¹ ≤ r / 2 := (inv_le (half_pos hr₁) ha₂).mp ha₁\n    _ < r := half_lt_self hr₁\n    \n#align absorbent_nhds_zero absorbent_nhds_zero\n-/\n\n",
 "absorbent_iff_nonneg_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print absorbent_iff_nonneg_lt /-\ntheorem absorbent_iff_nonneg_lt : Absorbent 𝕜 A ↔ ∀ x, ∃ r, 0 ≤ r ∧ ∀ ⦃a : 𝕜⦄, r < «expr‖ ‖» a → x ∈ «expr • » a A :=\n  forall_congr' fun x =>\n    ⟨fun ⟨r, hr, hx⟩ => ⟨r, hr.le, fun a ha => hx a ha.le⟩, fun ⟨r, hr, hx⟩ =>\n      ⟨r + 1, add_pos_of_nonneg_of_pos hr zero_lt_one, fun a ha =>\n        hx ((lt_add_of_pos_right r zero_lt_one).trans_le ha)⟩⟩\n#align absorbent_iff_nonneg_lt absorbent_iff_nonneg_lt\n-/\n\n",
 "absorbent_iff_forall_absorbs_singleton":
 "#print absorbent_iff_forall_absorbs_singleton /-\ntheorem absorbent_iff_forall_absorbs_singleton : Absorbent 𝕜 A ↔ ∀ x, Absorbs 𝕜 A {x} := by\n  simp_rw [Absorbs, Absorbent, singleton_subset_iff]\n#align absorbent_iff_forall_absorbs_singleton absorbent_iff_forall_absorbs_singleton\n-/\n\n"}