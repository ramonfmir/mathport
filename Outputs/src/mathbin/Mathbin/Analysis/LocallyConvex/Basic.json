{"zero_mem":
 "#print Absorbent.zero_mem /-\ntheorem Absorbent.zero_mem (hs : Absorbent ğ•œ s) : (0 : E) âˆˆ s :=\n  absorbs_zero_iff.1 <| absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.zero_mem Absorbent.zero_mem\n-/\n\n",
 "union":
 "#print Balanced.union /-\ntheorem Balanced.union (hA : Balanced ğ•œ A) (hB : Balanced ğ•œ B) : Balanced ğ•œ (A âˆª B) := fun a ha =>\n  smul_set_union.subset.trans <| union_subset_union (hA _ ha) <| hB _ ha\n#align balanced.union Balanced.union\n-/\n\n",
 "subset_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Balanced.subset_smul /-\ntheorem Balanced.subset_smul (hA : Balanced ğ•œ A) (ha : 1 â‰¤ Â«exprâ€– â€–Â» a) : A âŠ† Â«expr â€¢ Â» a A :=\n  by\n  refine' (subset_set_smul_iffâ‚€ _).2 (hA aâ»Â¹ _)\n  Â· rintro rfl\n    rw [norm_zero] at ha\n    exact zero_lt_one.not_le ha\n  Â· rw [norm_inv]\n    exact inv_le_one ha\n#align balanced.subset_smul Balanced.subset_smul\n-/\n\n",
 "subset":
 "#print Absorbent.subset /-\ntheorem Absorbent.subset (hA : Absorbent ğ•œ A) (hAB : A âŠ† B) : Absorbent ğ•œ B :=\n  by\n  refine' forall_imp (fun x => _) hA\n  exact Exists.imp fun r => And.imp_right <| forallâ‚‚_imp fun a ha hx => Set.smul_set_mono hAB hx\n#align absorbent.subset Absorbent.subset\n-/\n\n",
 "sub":
 "#print Balanced.sub /-\ntheorem Balanced.sub (hs : Balanced ğ•œ s) (ht : Balanced ğ•œ t) : Balanced ğ•œ (s - t) :=\n  by\n  simp_rw [sub_eq_add_neg]\n  exact hs.add ht.neg\n#align balanced.sub Balanced.sub\n-/\n\n",
 "smul_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Balanced.smul_mono /-\n/-- Scalar multiplication (by possibly different types) of a balanced set is monotone. -/\ntheorem Balanced.smul_mono (hs : Balanced ğ• s) {a : ğ•} {b : ğ•œ} (h : Â«exprâ€– â€–Â» a â‰¤ Â«exprâ€– â€–Â» b) :\n    Â«expr â€¢ Â» a s âŠ† Â«expr â€¢ Â» b s := by\n  obtain rfl | hb := eq_or_ne b 0\n  Â· rw [norm_zero] at h\n    rw [norm_eq_zero.1 (h.antisymm <| norm_nonneg _)]\n    obtain rfl | h := s.eq_empty_or_nonempty\n    Â· simp_rw [smul_set_empty]\n    Â· simp_rw [zero_smul_set h]\n  rintro _ âŸ¨x, hx, rflâŸ©\n  refine' âŸ¨Â«expr â€¢ Â» bâ»Â¹ (Â«expr â€¢ Â» a x), _, smul_inv_smulâ‚€ hb _âŸ©\n  rw [â† smul_assoc]\n  refine' hs _ _ (smul_mem_smul_set hx)\n  rw [norm_smul, norm_inv, â† div_eq_inv_mul]\n  exact div_le_one_of_le h (norm_nonneg _)\n#align balanced.smul_mono Balanced.smul_mono\n-/\n\n",
 "smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Balanced.smul_eq /-\ntheorem Balanced.smul_eq (hA : Balanced ğ•œ A) (ha : Â«exprâ€– â€–Â» a = 1) : Â«expr â€¢ Â» a A = A :=\n  (hA _ ha.le).antisymm <| hA.subset_smul ha.ge\n#align balanced.smul_eq Balanced.smul_eq\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Balanced.smul /-\ntheorem Balanced.smul (a : ğ•) (hs : Balanced ğ•œ s) : Balanced ğ•œ (Â«expr â€¢ Â» a s) := fun b hb =>\n  (smul_comm _ _ _).subset.trans <| smul_set_mono <| hs _ hb\n#align balanced.smul Balanced.smul\n-/\n\n",
 "neg_mem_iff":
 "#print Balanced.neg_mem_iff /-\ntheorem Balanced.neg_mem_iff (hs : Balanced ğ•œ s) : -x âˆˆ s â†” x âˆˆ s := by\n  convert hs.mem_smul_iff (norm_neg 1) <;> simp only [neg_smul, one_smul]\n#align balanced.neg_mem_iff Balanced.neg_mem_iff\n-/\n\n",
 "neg":
 "#print Balanced.neg /-\ntheorem Balanced.neg : Balanced ğ•œ s â†’ Balanced ğ•œ (-s) :=\n  forallâ‚‚_imp fun _ _ h => (smul_set_neg _ _).subset.trans <| neg_subset_neg.2 h\n#align balanced.neg Balanced.neg\n-/\n\n",
 "mono_right":
 "#print Absorbs.mono_right /-\ntheorem Absorbs.mono_right (hs : Absorbs ğ•œ s u) (h : v âŠ† u) : Absorbs ğ•œ s v :=\n  hs.mono Subset.rfl h\n#align absorbs.mono_right Absorbs.mono_right\n-/\n\n",
 "mono_left":
 "#print Absorbs.mono_left /-\ntheorem Absorbs.mono_left (hs : Absorbs ğ•œ s u) (h : s âŠ† t) : Absorbs ğ•œ t u :=\n  hs.mono h Subset.rfl\n#align absorbs.mono_left Absorbs.mono_left\n-/\n\n",
 "mono":
 "#print Absorbs.mono /-\ntheorem Absorbs.mono (hs : Absorbs ğ•œ s u) (hst : s âŠ† t) (hvu : v âŠ† u) : Absorbs ğ•œ t v :=\n  let âŸ¨r, hr, hâŸ© := hs\n  âŸ¨r, hr, fun a ha => hvu.trans <| (h _ ha).trans <| smul_set_mono hstâŸ©\n#align absorbs.mono Absorbs.mono\n-/\n\n",
 "mem_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Balanced.mem_smul_iff /-\ntheorem Balanced.mem_smul_iff (hs : Balanced ğ•œ s) (h : Â«exprâ€– â€–Â» a = Â«exprâ€– â€–Â» b) :\n    Â«expr â€¢ Â» a x âˆˆ s â†” Â«expr â€¢ Â» b x âˆˆ s :=\n  by\n  obtain rfl | hb := eq_or_ne b 0\n  Â· rw [norm_zero, norm_eq_zero] at h\n    rw [h]\n  have ha : a â‰  0 := norm_ne_zero_iff.1 (ne_of_eq_of_ne h <| norm_ne_zero_iff.2 hb)\n  constructor <;> intro h' <;> [rw [â† inv_mul_cancel_rightâ‚€ ha b], rw [â† inv_mul_cancel_rightâ‚€ hb a]] <;>\n    Â· rw [â† smul_eq_mul, smul_assoc]\n      refine' hs.smul_mem _ h'\n      simp [â† h, ha]\n#align balanced.mem_smul_iff Balanced.mem_smul_iff\n-/\n\n",
 "interior":
 "#print Balanced.interior /-\n/-- The interior of a balanced set is balanced if it contains the origin. -/\ntheorem Balanced.interior (hA : Balanced ğ•œ A) (h : (0 : E) âˆˆ interior A) : Balanced ğ•œ (interior A) :=\n  by\n  rw [â† union_eq_self_of_subset_left (singleton_subset_iff.2 h)]\n  exact balanced_zero_union_interior hA\n#align balanced.interior Balanced.interior\n-/\n\n",
 "inter":
 "#print Absorbs.inter /-\ntheorem Absorbs.inter (hs : Absorbs ğ•œ s u) (ht : Absorbs ğ•œ t u) : Absorbs ğ•œ (s âˆ© t) u :=\n  by\n  obtain âŸ¨a, ha, hsâŸ© := hs\n  obtain âŸ¨b, hb, htâŸ© := ht\n  have h : 0 < max a b := lt_max_of_lt_left ha\n  refine' âŸ¨max a b, lt_max_of_lt_left ha, fun c hc => _âŸ©\n  rw [smul_set_interâ‚€ (norm_pos_iff.1 <| h.trans_le hc)]\n  exact subset_inter (hs _ <| le_of_max_le_left hc) (ht _ <| le_of_max_le_right hc)\n#align absorbs.inter Absorbs.inter\n-/\n\n",
 "closure":
 "#print Balanced.closure /-\ntheorem Balanced.closure (hA : Balanced ğ•œ A) : Balanced ğ•œ (closure A) := fun a ha =>\n  (image_closure_subset_closure_image <| continuous_id.const_smul _).trans <| closure_mono <| hA _ ha\n#align balanced.closure Balanced.closure\n-/\n\n",
 "balanced_zero_union_interior":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print balanced_zero_union_interior /-\n/-- The union of `{0}` with the interior of a balanced set is balanced. -/\ntheorem balanced_zero_union_interior (hA : Balanced ğ•œ A) : Balanced ğ•œ ((0 : Set E) âˆª interior A) :=\n  by\n  intro a ha\n  obtain rfl | h := eq_or_ne a 0\n  Â· rw [zero_smul_set]\n    exacts[subset_union_left _ _, âŸ¨0, or.inl rflâŸ©]\n  Â· rw [â† image_smul, image_union]\n    apply union_subset_union\n    Â· rw [image_zero, smul_zero]\n      rfl\n    Â·\n      calc\n        Â«expr â€¢ Â» a (interior A) âŠ† interior (Â«expr â€¢ Â» a A) := (isOpenMap_smulâ‚€ h).image_interior_subset A\n        _ âŠ† interior A := interior_mono (hA _ ha)\n        \n#align balanced_zero_union_interior balanced_zero_union_interior\n-/\n\n",
 "balanced_zero":
 "#print balanced_zero /-\ntheorem balanced_zero : Balanced ğ•œ (0 : Set E) := fun a ha => (smul_zero _).subset\n#align balanced_zero balanced_zero\n-/\n\n",
 "balanced_univ":
 "#print balanced_univ /-\n@[simp]\ntheorem balanced_univ : Balanced ğ•œ (univ : Set E) := fun a ha => subset_univ _\n#align balanced_univ balanced_univ\n-/\n\n",
 "balanced_unionáµ¢â‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print balanced_unionáµ¢â‚‚ /-\ntheorem balanced_unionáµ¢â‚‚ {f : âˆ€ i, Îº i â†’ Set E} (h : âˆ€ i j, Balanced ğ•œ (f i j)) :\n    Balanced ğ•œ\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i j)) :=\n  balanced_unionáµ¢ fun _ => balanced_unionáµ¢ <| h _\n#align balanced_Unionâ‚‚ balanced_unionáµ¢â‚‚\n-/\n\n",
 "balanced_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print balanced_unionáµ¢ /-\ntheorem balanced_unionáµ¢ {f : Î¹ â†’ Set E} (h : âˆ€ i, Balanced ğ•œ (f i)) :\n    Balanced ğ•œ\n      (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) :=\n  fun a ha => (smul_set_Union _ _).subset.trans <| unionáµ¢_mono fun _ => h _ _ ha\n#align balanced_Union balanced_unionáµ¢\n-/\n\n",
 "balanced_interáµ¢â‚‚":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print balanced_interáµ¢â‚‚ /-\ntheorem balanced_interáµ¢â‚‚ {f : âˆ€ i, Îº i â†’ Set E} (h : âˆ€ i j, Balanced ğ•œ (f i j)) :\n    Balanced ğ•œ\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i j)) :=\n  balanced_interáµ¢ fun _ => balanced_interáµ¢ <| h _\n#align balanced_Interâ‚‚ balanced_interáµ¢â‚‚\n-/\n\n",
 "balanced_interáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹‚ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â» -/\n#print balanced_interáµ¢ /-\ntheorem balanced_interáµ¢ {f : Î¹ â†’ Set E} (h : âˆ€ i, Balanced ğ•œ (f i)) :\n    Balanced ğ•œ\n      (Â«exprâ‹‚ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹‚ , Â»\" (f i)) :=\n  fun a ha => (smul_set_interáµ¢_subset _ _).trans <| interáµ¢_mono fun _ => h _ _ ha\n#align balanced_Inter balanced_interáµ¢\n-/\n\n",
 "balanced_iff_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print balanced_iff_smul_mem /-\ntheorem balanced_iff_smul_mem : Balanced ğ•œ s â†” âˆ€ â¦ƒa : ğ•œâ¦„, Â«exprâ€– â€–Â» a â‰¤ 1 â†’ âˆ€ â¦ƒx : Eâ¦„, x âˆˆ s â†’ Â«expr â€¢ Â» a x âˆˆ s :=\n  forallâ‚‚_congr fun a ha => smul_set_subset_iff\n#align balanced_iff_smul_mem balanced_iff_smul_mem\n-/\n\n",
 "balanced_iff_neg_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n#print balanced_iff_neg_mem /-\ntheorem balanced_iff_neg_mem (hs : Convex (exprâ„) s) : Balanced (exprâ„) s â†” âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ -x âˆˆ s :=\n  by\n  refine' âŸ¨fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => _âŸ©\n  rw [Real.norm_eq_abs, abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring, add_smul, neg_smul, â† smul_neg]\n  exact\n    hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two) (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two)\n      (by ring)\n#align balanced_iff_neg_mem balanced_iff_neg_mem\n-/\n\n",
 "balanced_empty":
 "#print balanced_empty /-\n@[simp]\ntheorem balanced_empty : Balanced ğ•œ (âˆ… : Set E) := fun _ _ => by rw [smul_set_empty]\n#align balanced_empty balanced_empty\n-/\n\n",
 "balanced_convexHull_of_balanced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n#print balanced_convexHull_of_balanced /-\ntheorem balanced_convexHull_of_balanced (hs : Balanced ğ•œ s) : Balanced ğ•œ (convexHull (exprâ„) s) :=\n  by\n  suffices Convex (exprâ„) { x | âˆ€ a : ğ•œ, Â«exprâ€– â€–Â» a â‰¤ 1 â†’ Â«expr â€¢ Â» a x âˆˆ convexHull (exprâ„) s }\n    by\n    rw [balanced_iff_smul_mem] at hsâŠ¢\n    refine' fun a ha x hx => convexHull_min _ this hx a ha\n    exact fun y hy a ha => subset_convexHull (exprâ„) s (hs ha hy)\n  intro x hx y hy u v hu hv huv a ha\n  simp only [smul_add, â† smul_comm]\n  exact convex_convexHull (exprâ„) s (hx a ha) (hy a ha) hu hv huv\n#align balanced_convex_hull_of_balanced balanced_convexHull_of_balanced\n-/\n\n",
 "add":
 "#print Balanced.add /-\ntheorem Balanced.add (hs : Balanced ğ•œ s) (ht : Balanced ğ•œ t) : Balanced ğ•œ (s + t) := fun a ha =>\n  (smul_add _ _ _).subset.trans <| add_subset_add (hs _ ha) <| ht _ ha\n#align balanced.add Balanced.add\n-/\n\n",
 "absorbs_zero_iff":
 "#print absorbs_zero_iff /-\ntheorem absorbs_zero_iff : Absorbs ğ•œ s 0 â†” (0 : E) âˆˆ s :=\n  by\n  refine' âŸ¨_, fun h => âŸ¨1, zero_lt_one, fun a _ => zero_subset.2 <| zero_mem_smul_set hâŸ©âŸ©\n  rintro âŸ¨r, hr, hâŸ©\n  obtain âŸ¨a, haâŸ© := NormedSpace.exists_lt_norm ğ•œ ğ•œ r\n  have := h _ ha.le\n  rwa [zero_subset, zero_mem_smul_set_iff] at this\n  exact norm_ne_zero_iff.1 (hr.trans ha).ne'\n#align absorbs_zero_iff absorbs_zero_iff\n-/\n\n",
 "absorbs_unionáµ¢_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print absorbs_unionáµ¢_finset /-\ntheorem absorbs_unionáµ¢_finset {Î¹ : Type _} {t : Finset Î¹} {f : Î¹ â†’ Set E} :\n    Absorbs ğ•œ s\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) â†”\n      âˆ€ i âˆˆ t, Absorbs ğ•œ s (f i) :=\n  by\n  classical\n    induction' t using Finset.induction_on with i t ht hi\n    Â·\n      simp only [Finset.not_mem_empty, Set.unionáµ¢_false, Set.unionáµ¢_empty, absorbs_empty, IsEmpty.forall_iff,\n        imp_true_iff]\n    rw [Finset.set_bunionáµ¢_insert, absorbs_union, hi]\n    constructor <;> intro h\n    Â· refine' fun _ hi' => (finset.mem_insert.mp hi').elim _ (h.2 _)\n      exact fun hi'' => by\n        rw [hi'']\n        exact h.1\n    exact âŸ¨h i (Finset.mem_insert_self i t), fun i' hi' => h i' (Finset.mem_insert_of_mem hi')âŸ©\n#align absorbs_Union_finset absorbs_unionáµ¢_finset\n-/\n\n",
 "absorbs_unionáµ¢":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n#print Set.Finite.absorbs_unionáµ¢ /-\ntheorem Set.Finite.absorbs_unionáµ¢ {Î¹ : Type _} {s : Set E} {t : Set Î¹} {f : Î¹ â†’ Set E} (hi : t.finite) :\n    Absorbs ğ•œ s\n        (Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" (f i)) â†”\n      âˆ€ i âˆˆ t, Absorbs ğ•œ s (f i) :=\n  by\n  lift t to Finset Î¹ using hi\n  simp only [Finset.mem_coe]\n  exact absorbs_unionáµ¢_finset\n#align set.finite.absorbs_Union Set.Finite.absorbs_unionáµ¢\n-/\n\n",
 "absorbs_union":
 "#print absorbs_union /-\n@[simp]\ntheorem absorbs_union : Absorbs ğ•œ s (u âˆª v) â†” Absorbs ğ•œ s u âˆ§ Absorbs ğ•œ s v :=\n  âŸ¨fun h => âŸ¨h.mono_right <| subset_union_left _ _, h.mono_right <| subset_union_right _ _âŸ©, fun h => h.1.union h.2âŸ©\n#align absorbs_union absorbs_union\n-/\n\n",
 "absorbs_self":
 "#print Balanced.absorbs_self /-\n/-- A balanced set absorbs itself. -/\ntheorem Balanced.absorbs_self (hA : Balanced ğ•œ A) : Absorbs ğ•œ A A :=\n  by\n  refine' âŸ¨1, zero_lt_one, fun a ha x hx => _âŸ©\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  refine' hA aâ»Â¹ _ (smul_mem_smul_set hx)\n  rw [norm_inv]\n  exact inv_le_one ha\n#align balanced.absorbs_self Balanced.absorbs_self\n-/\n\n",
 "absorbs_inter":
 "#print absorbs_inter /-\n@[simp]\ntheorem absorbs_inter : Absorbs ğ•œ (s âˆ© t) u â†” Absorbs ğ•œ s u âˆ§ Absorbs ğ•œ t u :=\n  âŸ¨fun h => âŸ¨h.mono_left <| inter_subset_left _ _, h.mono_left <| inter_subset_right _ _âŸ©, fun h => h.1.inter h.2âŸ©\n#align absorbs_inter absorbs_inter\n-/\n\n",
 "absorbs_finite":
 "#print Absorbent.absorbs_finite /-\ntheorem Absorbent.absorbs_finite {s : Set E} (hs : Absorbent ğ•œ s) {v : Set E} (hv : v.finite) : Absorbs ğ•œ s v :=\n  by\n  rw [â† Set.bunionáµ¢_of_singleton v]\n  exact hv.absorbs_Union.mpr fun _ _ => hs.absorbs\n#align absorbent.absorbs_finite Absorbent.absorbs_finite\n-/\n\n",
 "absorbs_empty":
 "#print absorbs_empty /-\n/-\nCopyright (c) 2019 Jean Lo. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jean Lo, Bhavik Mehta, YaÃ«l Dillies\n-/\n@[simp]\ntheorem absorbs_empty {s : Set E} : Absorbs ğ•œ s (âˆ… : Set E) :=\n  âŸ¨1, one_pos, fun a ha => Set.empty_subset _âŸ©\n#align absorbs_empty absorbs_empty\n-/\n\n",
 "absorbs":
 "#print Absorbent.absorbs /-\ntheorem Absorbent.absorbs (hs : Absorbent ğ•œ s) {x : E} : Absorbs ğ•œ s {x} :=\n  absorbent_iff_forall_absorbs_singleton.1 hs _\n#align absorbent.absorbs Absorbent.absorbs\n-/\n\n",
 "absorbent_univ":
 "#print absorbent_univ /-\ntheorem absorbent_univ : Absorbent ğ•œ (univ : Set E) :=\n  by\n  refine' fun x => âŸ¨1, zero_lt_one, fun a ha => _âŸ©\n  rw [smul_set_univâ‚€ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]\n  exact trivial\n#align absorbent_univ absorbent_univ\n-/\n\n",
 "absorbent_nhds_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n#print absorbent_nhds_zero /-\n/-- Every neighbourhood of the origin is absorbent. -/\ntheorem absorbent_nhds_zero (hA : A âˆˆ (nhds) (0 : E)) : Absorbent ğ•œ A :=\n  by\n  intro x\n  obtain âŸ¨w, hwâ‚, hwâ‚‚, hwâ‚ƒâŸ© := mem_nhds_iff.mp hA\n  have hc : Continuous fun t : ğ•œ => Â«expr â€¢ Â» t x := continuous_id.smul continuous_const\n  obtain âŸ¨r, hrâ‚, hrâ‚‚âŸ© := metric.is_open_iff.mp (hwâ‚‚.preimage hc) 0 (by rwa [mem_preimage, zero_smul])\n  have hrâ‚ƒ := inv_pos.mpr (half_pos hrâ‚)\n  refine' âŸ¨(r / 2)â»Â¹, hrâ‚ƒ, fun a haâ‚ => _âŸ©\n  have haâ‚‚ : 0 < Â«exprâ€– â€–Â» a := hrâ‚ƒ.trans_le haâ‚\n  refine' (mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.mp haâ‚‚) _ _).2 (hwâ‚ <| hrâ‚‚ _)\n  rw [Metric.mem_ball, dist_zero_right, norm_inv]\n  calc\n    (Â«exprâ€– â€–Â» a)â»Â¹ â‰¤ r / 2 := (inv_le (half_pos hrâ‚) haâ‚‚).mp haâ‚\n    _ < r := half_lt_self hrâ‚\n    \n#align absorbent_nhds_zero absorbent_nhds_zero\n-/\n\n",
 "absorbent_iff_nonneg_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print absorbent_iff_nonneg_lt /-\ntheorem absorbent_iff_nonneg_lt : Absorbent ğ•œ A â†” âˆ€ x, âˆƒ r, 0 â‰¤ r âˆ§ âˆ€ â¦ƒa : ğ•œâ¦„, r < Â«exprâ€– â€–Â» a â†’ x âˆˆ Â«expr â€¢ Â» a A :=\n  forall_congr' fun x =>\n    âŸ¨fun âŸ¨r, hr, hxâŸ© => âŸ¨r, hr.le, fun a ha => hx a ha.leâŸ©, fun âŸ¨r, hr, hxâŸ© =>\n      âŸ¨r + 1, add_pos_of_nonneg_of_pos hr zero_lt_one, fun a ha =>\n        hx ((lt_add_of_pos_right r zero_lt_one).trans_le ha)âŸ©âŸ©\n#align absorbent_iff_nonneg_lt absorbent_iff_nonneg_lt\n-/\n\n",
 "absorbent_iff_forall_absorbs_singleton":
 "#print absorbent_iff_forall_absorbs_singleton /-\ntheorem absorbent_iff_forall_absorbs_singleton : Absorbent ğ•œ A â†” âˆ€ x, Absorbs ğ•œ A {x} := by\n  simp_rw [Absorbs, Absorbent, singleton_subset_iff]\n#align absorbent_iff_forall_absorbs_singleton absorbent_iff_forall_absorbs_singleton\n-/\n\n"}