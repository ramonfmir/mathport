{"zero_mem_polar":
 "@[simp]\ntheorem zero_mem_polar (s : set E) : (0 : F) ∈ B.polar s := fun _ _ => by simp only [map_zero, norm_zero, zero_le_one]\n#align zero_mem_polar zero_mem_polar\n\n",
 "tripolar_eq_polar":
 "@[simp]\ntheorem tripolar_eq_polar (s : set E) : B.polar (B.flip.polar (B.polar s)) = B.polar s :=\n  by\n  refine' (B.polar_antitone (B.subset_bipolar s)).antisymm _\n  convert subset_bipolar B.flip (B.polar s)\n  exact B.flip_flip.symm\n#align tripolar_eq_polar tripolar_eq_polar\n\n",
 "subset_bipolar":
 "theorem subset_bipolar (s : set E) : s ⊆ B.flip.polar (B.polar s) := fun x hx y hy =>\n  by\n  rw [B.flip_apply]\n  exact hy x hx\n#align subset_bipolar subset_bipolar\n\n",
 "polar_zero":
 "@[simp]\ntheorem polar_zero : B.polar ({0} : set E) = Set.univ :=\n  by\n  refine' set.eq_univ_iff_forall.mpr fun y x hx => _\n  rw [set.mem_singleton_iff.mp hx, map_zero, linear_map.zero_apply, norm_zero]\n  exact zero_le_one\n#align polar_zero polar_zero\n\n",
 "polar_weak_closed":
 "/-- The polar set is closed in the weak topology induced by `B.flip`. -/\ntheorem polar_weak_closed (s : set E) : @is_closed _ (weak_bilin.topological_space B.flip) (B.polar s) :=\n  by\n  rw [polar_eq_Inter]\n  refine' is_closed_Inter fun x => is_closed_Inter fun _ => _\n  exact is_closed_le (weak_bilin.eval_continuous B.flip x).norm continuous_const\n#align polar_weak_closed polar_weak_closed\n\n",
 "polar_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem polar_univ (h : separating_right B) : B.polar Set.univ = {(0 : F)} :=\n  by\n  rw [Set.eq_singleton_iff_unique_mem]\n  refine' ⟨by simp only [zero_mem_polar], fun y hy => h _ fun x => _⟩\n  refine' norm_le_zero_iff.mp (le_of_forall_le_of_dense fun ε hε => _)\n  rcases normed_field.exists_norm_lt 𝕜 hε with ⟨c, hc, hcε⟩\n  calc\n    «expr‖ ‖» (B x y) = «expr‖ ‖» c * «expr‖ ‖» (B («expr • » c⁻¹ x) y) := by\n      rw [B.map_smul, linear_map.smul_apply, algebra.id.smul_eq_mul, norm_mul, norm_inv, mul_inv_cancel_left₀ hc.ne']\n    _ ≤ ε * 1 := mul_le_mul hcε.le (hy _ trivial) (norm_nonneg _) hε.le\n    _ = ε := mul_one _\n    \n#align polar_univ polar_univ\n\n",
 "polar_union":
 "@[simp]\ntheorem polar_union {s t : set E} : B.polar (s ∪ t) = B.polar s ∩ B.polar t :=\n  B.polar_gc.l_sup\n#align polar_union polar_union\n\n",
 "polar_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-\nCopyright (c) 2022 Moritz Doll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll, Kalle Kytölä\n-/\ntheorem polar_mem_iff (s : set E) (y : F) : y ∈ B.polar s ↔ ∀ x ∈ s, «expr‖ ‖» (B x y) ≤ 1 :=\n  iff.rfl\n#align polar_mem_iff polar_mem_iff\n\n",
 "polar_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem polar_mem (s : set E) (y : F) (hy : y ∈ B.polar s) : ∀ x ∈ s, «expr‖ ‖» (B x y) ≤ 1 :=\n  hy\n#align polar_mem polar_mem\n\n",
 "polar_gc":
 "/-- The map `B.polar : set E → set F` forms an order-reversing Galois connection with\n`B.flip.polar : set F → set E`. We use `order_dual.to_dual` and `order_dual.of_dual` to express\nthat `polar` is order-reversing. -/\ntheorem polar_gc : GaloisConnection (OrderDual.toDual ∘ B.polar) (B.flip.polar ∘ OrderDual.ofDual) := fun s t =>\n  ⟨fun h _ hx _ hy => h hy _ hx, fun h _ hx _ hy => h hy _ hx⟩\n#align polar_gc polar_gc\n\n",
 "polar_eq_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\ntheorem polar_eq_Inter {s : set E} :\n    B.polar s =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { y : F | «expr‖ ‖» (B x y) ≤ 1 } :=\n  by\n  ext\n  simp only [polar_mem_iff, Set.mem_interᵢ, Set.mem_setOf_eq]\n#align polar_eq_Inter polar_eq_Inter\n\n",
 "polar_empty":
 "@[simp]\ntheorem polar_empty : B.polar ∅ = Set.univ :=\n  B.polar_gc.l_bot\n#align polar_empty polar_empty\n\n",
 "polar_antitone":
 "theorem polar_antitone : antitone (B.polar : set E → set F) :=\n  B.polar_gc.monotone_l\n#align polar_antitone polar_antitone\n\n",
 "polar_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem polar_Union {ι} {s : ι → set E} :\n    B.polar («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (B.polar (s i)) :=\n  B.polar_gc.l_supr\n#align polar_Union polar_Union\n\n"}