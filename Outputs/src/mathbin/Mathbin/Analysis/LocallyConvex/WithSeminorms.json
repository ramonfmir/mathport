{"with_seminorms_of_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem seminorm_family.with_seminorms_of_nhds (p : seminorm_family ğ•œ E Î¹)\n    (h : (nhds) (0 : E) = p.module_filter_basis.to_filter_basis.filter) : with_seminorms p :=\n  by\n  refine' âŸ¨TopologicalAddGroup.ext inferInstance p.add_group_filter_basis.is_topological_add_group _âŸ©\n  rw [AddGroupFilterBasis.nhds_zero_eq]\n  exact h\n#align seminorm_family.with_seminorms_of_nhds seminorm_family.with_seminorms_of_nhds\n\n",
 "with_seminorms_of_has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem seminorm_family.with_seminorms_of_has_basis (p : seminorm_family ğ•œ E Î¹)\n    (h : ((nhds) (0 : E)).has_basis (fun s : Set E => s âˆˆ p.basis_sets) id) : with_seminorms p :=\n  p.with_seminorms_of_nhds <| Filter.HasBasis.eq_of_same_basis h p.add_group_filter_basis.to_filter_basis.has_basis\n#align seminorm_family.with_seminorms_of_has_basis seminorm_family.with_seminorms_of_has_basis\n\n",
 "with_seminorms_induced":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem linear_map.with_seminorms_induced [hÎ¹ : Nonempty Î¹] {q : seminorm_family ğ•œâ‚‚ F Î¹} (hq : with_seminorms q)\n    (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F) : @with_seminorms ğ•œ E Î¹ _ _ _ _ (q.comp f) (induced f inferInstance) :=\n  by\n  letI : TopologicalSpace E := induced f inferInstance\n  letI : TopologicalAddGroup E := topologicalAddGroup_induced f\n  rw [(q.comp f).with_seminorms_iff_nhds_eq_infi, nhds_induced, map_zero, q.with_seminorms_iff_nhds_eq_infi.mp hq,\n    Filter.comap_infáµ¢]\n  refine' infáµ¢_congr fun i => _\n  exact Filter.comap_comap\n#align linear_map.with_seminorms_induced linear_map.with_seminorms_induced\n\n",
 "with_seminorms_iff_uniform_space_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr = Â»(_, Â«exprâ¨… , Â»((i), _))]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/-- The uniform structure induced by a family of seminorms is exactly the infimum of the ones\ninduced by each seminorm individually. We express this as a characterization of\n`with_seminorms p`. -/\ntheorem seminorm_family.with_seminorms_iff_uniform_space_eq_infi [u : UniformSpace E] [UniformAddGroup E]\n    (p : seminorm_family ğ•œ E Î¹) :\n    with_seminorms p â†”\n      u =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          (p i).to_add_group_seminorm.to_seminormed_add_comm_group.to_uniform_space :=\n  by\n  rw [p.with_seminorms_iff_nhds_eq_infi,\n    UniformAddGroup.ext_iff inferInstance (uniformAddGroup_infáµ¢ fun i => inferInstance), toTopologicalSpace_infáµ¢,\n    nhds_infáµ¢]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr = Â»(_, Â«exprâ¨… , Â»((i), _))]]\"\n  exact @comap_norm_nhds_zero _ (p i).to_add_group_seminorm.to_seminormed_add_group\n  all_goals infer_instance\n#align seminorm_family.with_seminorms_iff_uniform_space_eq_infi seminorm_family.with_seminorms_iff_uniform_space_eq_infi\n\n",
 "with_seminorms_iff_topological_space_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr = Â»(_, Â«exprâ¨… , Â»((i), _))]] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/-- The topology induced by a family of seminorms is exactly the infimum of the ones induced by\neach seminorm individually. We express this as a characterization of `with_seminorms p`. -/\ntheorem seminorm_family.with_seminorms_iff_topological_space_eq_infi (p : seminorm_family ğ•œ E Î¹) :\n    with_seminorms p â†”\n      t =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          (p i).to_add_group_seminorm.to_seminormed_add_comm_group.to_uniform_space.to_topological_space :=\n  by\n  rw [p.with_seminorms_iff_nhds_eq_infi,\n    TopologicalAddGroup.ext_iff inferInstance (topologicalAddGroup_infáµ¢ fun i => inferInstance), nhds_infáµ¢]\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `congrm #[[expr Â«expr = Â»(_, Â«exprâ¨… , Â»((i), _))]]\"\n  exact @comap_norm_nhds_zero _ (p i).to_add_group_seminorm.to_seminormed_add_group\n  all_goals infer_instance\n#align seminorm_family.with_seminorms_iff_topological_space_eq_infi seminorm_family.with_seminorms_iff_topological_space_eq_infi\n\n",
 "with_seminorms_iff_nhds_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem seminorm_family.with_seminorms_iff_nhds_eq_infi (p : seminorm_family ğ•œ E Î¹) :\n    with_seminorms p â†”\n      ((nhds) 0 : Filter E) =\n        Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n          (((nhds) 0).comap (p i)) :=\n  by\n  rw [â† p.filter_eq_infi]\n  refine' âŸ¨fun h => _, p.with_seminorms_of_nhdsâŸ©\n  rw [h.topology_eq_with_seminorms]\n  exact AddGroupFilterBasis.nhds_zero_eq _\n#align seminorm_family.with_seminorms_iff_nhds_eq_infi seminorm_family.with_seminorms_iff_nhds_eq_infi\n\n",
 "with_seminorms_eq":
 "theorem with_seminorms.with_seminorms_eq {p : seminorm_family ğ•œ E Î¹} [t : TopologicalSpace E] (hp : with_seminorms p) :\n    t = p.module_filter_basis.topology :=\n  hp.1\n#align with_seminorms.with_seminorms_eq with_seminorms.with_seminorms_eq\n\n",
 "with_seminorms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem inducing.with_seminorms [hÎ¹ : Nonempty Î¹] {q : seminorm_family ğ•œâ‚‚ F Î¹} (hq : with_seminorms q)\n    [TopologicalSpace E] {f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F} (hf : Inducing f) : with_seminorms (q.comp f) :=\n  by\n  rw [hf.induced]\n  exact f.with_seminorms_induced hq\n#align inducing.with_seminorms inducing.with_seminorms\n\n",
 "topological_add_group":
 "theorem with_seminorms.topological_add_group (hp : with_seminorms p) : TopologicalAddGroup E :=\n  by\n  rw [hp.with_seminorms_eq]\n  exact AddGroupFilterBasis.isTopologicalAddGroup _\n#align with_seminorms.topological_add_group with_seminorms.topological_add_group\n\n",
 "to_locally_convex_space'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- Not an instance since `ğ•œ` can't be inferred. See `normed_space.to_locally_convex_space` for a\nslightly weaker instance version. -/\ntheorem normed_space.to_locally_convex_space' [NormedSpace ğ•œ E] [Module (exprâ„) E] [IsScalarTower (exprâ„) ğ•œ E] :\n    locally_convex_space (exprâ„) E :=\n  (norm_with_seminorms ğ•œ E).to_locally_convex_space\n#align normed_space.to_locally_convex_space' normed_space.to_locally_convex_space'\n\n",
 "to_locally_convex_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem with_seminorms.to_locally_convex_space {p : seminorm_family ğ•œ E Î¹} (hp : with_seminorms p) :\n    locally_convex_space (exprâ„) E :=\n  by\n  apply of_basis_zero (exprâ„) E id fun s => s âˆˆ p.basis_sets\n  Â· rw [hp.1, AddGroupFilterBasis.nhds_eq _, AddGroupFilterBasis.N_zero]\n    exact FilterBasis.hasBasis _\n  Â· intro s hs\n    change s âˆˆ Set.unionáµ¢ _ at hs\n    simp_rw [Set.mem_unionáµ¢, Set.mem_singleton_iff] at hs\n    rcases hs with âŸ¨I, r, hr, rflâŸ©\n    exact convex_ball _ _ _\n#align with_seminorms.to_locally_convex_space with_seminorms.to_locally_convex_space\n\n",
 "tendsto_nhds_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Limit `â†’ âˆ` for `with_seminorms`. -/\ntheorem with_seminorms.tendsto_nhds_at_top (hp : with_seminorms p) (u : F â†’ E) (yâ‚€ : E) :\n    Filter.Tendsto u Filter.atTop ((nhds) yâ‚€) â†” âˆ€ i Îµ, 0 < Îµ â†’ âˆƒ xâ‚€, âˆ€ x, xâ‚€ â‰¤ x â†’ p i (u x - yâ‚€) < Îµ :=\n  by\n  rw [hp.tendsto_nhds u yâ‚€]\n  exact forallâ‚ƒ_congr fun _ _ _ => Filter.eventually_atTop\n#align with_seminorms.tendsto_nhds_at_top with_seminorms.tendsto_nhds_at_top\n\n",
 "tendsto_nhds'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Convergence along filters for `with_seminorms`.\n\nVariant with `finset.sup`. -/\ntheorem with_seminorms.tendsto_nhds' (hp : with_seminorms p) (u : F â†’ E) {f : Filter F} (yâ‚€ : E) :\n    Filter.Tendsto u f ((nhds) yâ‚€) â†”\n      âˆ€ (s : Finset Î¹) (Îµ),\n        0 < Îµ â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" f\n            (s.sup p (u x - yâ‚€) < Îµ) :=\n  by simp [hp.has_basis_ball.tendsto_right_iff]\n#align with_seminorms.tendsto_nhds' with_seminorms.tendsto_nhds'\n\n",
 "tendsto_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/-- Convergence along filters for `with_seminorms`. -/\ntheorem with_seminorms.tendsto_nhds (hp : with_seminorms p) (u : F â†’ E) {f : Filter F} (yâ‚€ : E) :\n    Filter.Tendsto u f ((nhds) yâ‚€) â†”\n      âˆ€ i Îµ,\n        0 < Îµ â†’\n          Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" f\n            (p i (u x - yâ‚€) < Îµ) :=\n  by\n  rw [hp.tendsto_nhds' u yâ‚€]\n  exact\n    âŸ¨fun h i => by simpa only [Finset.sup_singleton] using h {i}, fun h s Îµ hÎµ =>\n      (s.eventually_all.2 fun i _ => h i Îµ hÎµ).mono fun _ => finset_sup_apply_lt hÎµâŸ©\n#align with_seminorms.tendsto_nhds with_seminorms.tendsto_nhds\n\n",
 "t1_of_separating":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr â‰  Â» 0) -/\n/- Note that through the following lemmas, one also immediately has that separating families\nof seminorms induce Tâ‚‚ and Tâ‚ƒ topologies by `topological_add_group.t2_space`\nand `topological_add_group.t3_space` -/\n/-- A separating family of seminorms induces a Tâ‚ topology. -/\ntheorem with_seminorms.t1_of_separating (hp : with_seminorms p) (h : âˆ€ (x) (_ : x â‰  0), âˆƒ i, p i x â‰  0) : T1Space E :=\n  by\n  haveI := hp.topological_add_group\n  refine' TopologicalAddGroup.t1Space _ _\n  rw [â† isOpen_compl_iff, hp.is_open_iff_mem_balls]\n  rintro x (hx : x â‰  0)\n  cases' h x hx with i pi_nonzero\n  refine' âŸ¨{i}, p i x, by positivity, subset_compl_singleton_iff.mpr _âŸ©\n  rw [Finset.sup_singleton, mem_ball, zero_sub, map_neg_eq_map, not_lt]\n#align with_seminorms.t1_of_separating with_seminorms.t1_of_separating\n\n",
 "separating_of_t1":
 "/-- A family of seminorms inducing a Tâ‚ topology is separating. -/\ntheorem with_seminorms.separating_of_t1 [T1Space E] (hp : with_seminorms p) (x : E) (hx : x â‰  0) : âˆƒ i, p i x â‰  0 :=\n  by\n  have := ((t1Space_TFAE E).out 0 9).mp inferInstance\n  by_contra' h\n  refine' hx (this _)\n  rw [hp.has_basis_zero_ball.specializes_iff]\n  rintro âŸ¨s, râŸ© (hr : 0 < r)\n  simp only [ball_finset_sup_eq_Inter _ _ _ hr, mem_Interâ‚‚, mem_ball_zero, h, hr, forall_true_iff]\n#align with_seminorms.separating_of_t1 with_seminorms.separating_of_t1\n\n",
 "separating_iff_t1":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x Â«expr â‰  Â» 0) -/\n/-- A family of seminorms is separating iff it induces a Tâ‚ topology. -/\ntheorem with_seminorms.separating_iff_t1 (hp : with_seminorms p) : (âˆ€ (x) (_ : x â‰  0), âˆƒ i, p i x â‰  0) â†” T1Space E :=\n  by\n  refine' âŸ¨with_seminorms.t1_of_separating hp, _âŸ©\n  intro\n  exact with_seminorms.separating_of_t1 hp\n#align with_seminorms.separating_iff_t1 with_seminorms.separating_iff_t1\n\n",
 "norm_with_seminorms":
 "/-- The topology of a `normed_space ğ•œ E` is induced by the seminorm `norm_seminorm ğ•œ E`. -/\ntheorem norm_with_seminorms (ğ•œ E) [NormedField ğ•œ] [SeminormedAddCommGroup E] [NormedSpace ğ•œ E] :\n    with_seminorms fun _ : Fin 1 => normSeminorm ğ•œ E :=\n  by\n  let p : seminorm_family ğ•œ E (Fin 1) := fun _ => normSeminorm ğ•œ E\n  refine' âŸ¨seminormed_add_comm_group.to_topological_add_group.ext p.add_group_filter_basis.is_topological_add_group _âŸ©\n  refine' Filter.HasBasis.eq_of_same_basis Metric.nhds_basis_ball _\n  rw [â† ball_normSeminorm ğ•œ E]\n  refine'\n    Filter.HasBasis.to_hasBasis p.add_group_filter_basis.nhds_zero_has_basis _ fun r hr =>\n      âŸ¨(normSeminorm ğ•œ E).ball 0 r, p.basis_sets_singleton_mem 0 hr, rfl.subsetâŸ©\n  rintro U (hU : U âˆˆ p.basis_sets)\n  rcases p.basis_sets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  use r, hr\n  rw [hU, id.def]\n  by_cases h : s.nonempty\n  Â· rw [Finset.sup_const h]\n  rw [finset.not_nonempty_iff_eq_empty.mp h, Finset.sup_empty, ball_bot _ hr]\n  exact Set.subset_univ _\n#align norm_with_seminorms norm_with_seminorms\n\n",
 "mem_nhds_iff":
 "/-- The `x`-neighbourhoods of a space whose topology is induced by a family of seminorms\nare exactly the sets which contain seminorm balls around `x`.-/\ntheorem with_seminorms.mem_nhds_iff (hp : with_seminorms p) (x : E) (U : Set E) :\n    U âˆˆ nhds x â†” âˆƒ s : Finset Î¹, âˆƒ r > 0, (s.sup p).ball x r âŠ† U := by rw [hp.has_basis_ball.mem_iff, Prod.exists]\n#align with_seminorms.mem_nhds_iff with_seminorms.mem_nhds_iff\n\n",
 "is_vonN_bounded_iff_seminorm_bounded":
 "theorem with_seminorms.is_vonN_bounded_iff_seminorm_bounded {s : Set E} (hp : with_seminorms p) :\n    Bornology.IsVonNBounded ğ•œ s â†” âˆ€ i : Î¹, âˆƒ (r : _)(hr : 0 < r), âˆ€ x âˆˆ s, p i x < r :=\n  by\n  rw [hp.is_vonN_bounded_iff_finset_seminorm_bounded]\n  constructor\n  Â· intro hI i\n    convert hI {i}\n    rw [Finset.sup_singleton]\n  intro hi I\n  by_cases hI : I.nonempty\n  Â· choose r hr h using hi\n    have h' : 0 < I.sup' hI r := by\n      rcases hI.bex with âŸ¨i, hiâŸ©\n      exact lt_of_lt_of_le (hr i) (Finset.le_sup' r hi)\n    refine' âŸ¨I.sup' hI r, h', fun x hx => finset_sup_apply_lt h' fun i hi => _âŸ©\n    refine' lt_of_lt_of_le (h i x hx) _\n    simp only [Finset.le_sup'_iff, exists_prop]\n    exact âŸ¨i, hi, (Eq.refl _).leâŸ©\n  simp only [finset.not_nonempty_iff_eq_empty.mp hI, Finset.sup_empty, coe_bot, Pi.zero_apply, exists_prop]\n  exact âŸ¨1, zero_lt_one, fun _ _ => zero_lt_oneâŸ©\n#align with_seminorms.is_vonN_bounded_iff_seminorm_bounded with_seminorms.is_vonN_bounded_iff_seminorm_bounded\n\n",
 "is_vonN_bounded_iff_finset_seminorm_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\ntheorem with_seminorms.is_vonN_bounded_iff_finset_seminorm_bounded {s : Set E} (hp : with_seminorms p) :\n    Bornology.IsVonNBounded ğ•œ s â†” âˆ€ I : Finset Î¹, âˆƒ (r : _)(hr : 0 < r), âˆ€ x âˆˆ s, I.sup p x < r :=\n  by\n  rw [hp.has_basis.is_vonN_bounded_basis_iff]\n  constructor\n  Â· intro h I\n    simp only [id.def] at h\n    specialize h ((I.sup p).ball 0 1) (p.basis_sets_mem I zero_lt_one)\n    rcases h with âŸ¨r, hr, hâŸ©\n    cases' NormedField.exists_lt_norm ğ•œ r with a ha\n    specialize h a (le_of_lt ha)\n    rw [Seminorm.smul_ball_zero (norm_pos_iff.1 <| hr.trans ha), mul_one] at h\n    refine' âŸ¨Â«exprâ€– â€–Â» a, lt_trans hr ha, _âŸ©\n    intro x hx\n    specialize h hx\n    exact (Finset.sup I p).mem_ball_zero.mp h\n  intro h s' hs'\n  rcases p.basis_sets_iff.mp hs' with âŸ¨I, r, hr, hs'âŸ©\n  rw [id.def, hs']\n  rcases h I with âŸ¨r', hr', h'âŸ©\n  simp_rw [â† (I.sup p).mem_ball_zero] at h'\n  refine' Absorbs.mono_right _ h'\n  exact (Finset.sup I p).ball_zero_absorbs_ball_zero hr\n#align with_seminorms.is_vonN_bounded_iff_finset_seminorm_bounded with_seminorms.is_vonN_bounded_iff_finset_seminorm_bounded\n\n",
 "is_open_iff_mem_balls":
 "/-- The open sets of a space whose topology is induced by a family of seminorms\nare exactly the sets which contain seminorm balls around all of their points.-/\ntheorem with_seminorms.is_open_iff_mem_balls (hp : with_seminorms p) (U : Set E) :\n    IsOpen U â†” âˆ€ x âˆˆ U, âˆƒ s : Finset Î¹, âˆƒ r > 0, (s.sup p).ball x r âŠ† U := by\n  simp_rw [â† with_seminorms.mem_nhds_iff hp _ U, isOpen_iff_mem_nhds]\n#align with_seminorms.is_open_iff_mem_balls with_seminorms.is_open_iff_mem_balls\n\n",
 "is_bounded_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem is_bounded_sup {p : Î¹ â†’ Seminorm ğ•œ E} {q : Î¹' â†’ Seminorm ğ•œâ‚‚ F} {f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F}\n    (hf : is_bounded p q f) (s' : Finset Î¹') :\n    âˆƒ (C : nnreal)(s : Finset Î¹), (s'.sup q).comp f â‰¤ Â«expr â€¢ Â» C (s.sup p) := by\n  classical\n    obtain rfl | hs' := s'.eq_empty_or_nonempty\n    Â· exact âŸ¨1, âˆ…, by simp [Seminorm.bot_eq_zero]âŸ©\n    choose fâ‚› fC hf using hf\n    use Â«expr â€¢ Â» s'.card (s'.sup fC), Finset.bunionáµ¢ s' fâ‚›\n    have hs : âˆ€ i : Î¹', i âˆˆ s' â†’ (q i).comp f â‰¤ Â«expr â€¢ Â» (s'.sup fC) ((Finset.bunionáµ¢ s' fâ‚›).sup p) :=\n      by\n      intro i hi\n      refine' (hf i).trans (smul_le_smul _ (Finset.le_sup hi))\n      exact Finset.sup_mono (Finset.subset_bunionáµ¢_of_mem fâ‚› hi)\n    refine' (comp_mono f (finset_sup_le_sum q s')).trans _\n    simp_rw [â† pullback_apply, AddMonoidHom.map_sum, pullback_apply]\n    refine' (Finset.sum_le_sum hs).trans _\n    rw [Finset.sum_const, smul_assoc]\n    exact le_rfl\n#align is_bounded_sup is_bounded_sup\n\n",
 "is_bounded_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n-- Todo: This should be phrased entirely in terms of the von Neumann bornology.\ntheorem is_bounded_const (Î¹' : Type _) [Nonempty Î¹'] {p : Î¹ â†’ Seminorm ğ•œ E} {q : Seminorm ğ•œâ‚‚ F}\n    (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F) :\n    is_bounded p (fun _ : Î¹' => q) f â†” âˆƒ (s : Finset Î¹)(C : nnreal), q.comp f â‰¤ Â«expr â€¢ Â» C (s.sup p) := by\n  simp only [is_bounded, forall_const]\n#align is_bounded_const is_bounded_const\n\n",
 "image_is_vonN_bounded_iff_seminorm_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem with_seminorms.image_is_vonN_bounded_iff_seminorm_bounded (f : G â†’ E) {s : Set G} (hp : with_seminorms p) :\n    Bornology.IsVonNBounded ğ•œ (Â«expr '' Â» f s) â†” âˆ€ i : Î¹, âˆƒ (r : _)(hr : 0 < r), âˆ€ x âˆˆ s, p i (f x) < r := by\n  simp_rw [hp.is_vonN_bounded_iff_seminorm_bounded, Set.ball_image_iff]\n#align with_seminorms.image_is_vonN_bounded_iff_seminorm_bounded with_seminorms.image_is_vonN_bounded_iff_seminorm_bounded\n\n",
 "image_is_vonN_bounded_iff_finset_seminorm_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem with_seminorms.image_is_vonN_bounded_iff_finset_seminorm_bounded (f : G â†’ E) {s : Set G}\n    (hp : with_seminorms p) :\n    Bornology.IsVonNBounded ğ•œ (Â«expr '' Â» f s) â†” âˆ€ I : Finset Î¹, âˆƒ (r : _)(hr : 0 < r), âˆ€ x âˆˆ s, I.sup p (f x) < r := by\n  simp_rw [hp.is_vonN_bounded_iff_finset_seminorm_bounded, Set.ball_image_iff]\n#align with_seminorms.image_is_vonN_bounded_iff_finset_seminorm_bounded with_seminorms.image_is_vonN_bounded_iff_finset_seminorm_bounded\n\n",
 "has_basis_zero_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem with_seminorms.has_basis_zero_ball (hp : with_seminorms p) :\n    ((nhds) (0 : E)).has_basis (fun sr : Finset Î¹ Ã— exprâ„ => 0 < sr.2) fun sr => (sr.1.sup p).ball 0 sr.2 :=\n  by\n  refine' âŸ¨fun V => _âŸ©\n  simp only [hp.has_basis.mem_iff, seminorm_family.basis_sets_iff, Prod.exists]\n  constructor\n  Â· rintro âŸ¨-, âŸ¨s, r, hr, rflâŸ©, hVâŸ©\n    exact âŸ¨s, r, hr, hVâŸ©\n  Â· rintro âŸ¨s, r, hr, hVâŸ©\n    exact âŸ¨_, âŸ¨s, r, hr, rflâŸ©, hVâŸ©\n#align with_seminorms.has_basis_zero_ball with_seminorms.has_basis_zero_ball\n\n",
 "has_basis_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr +áµ¥ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem with_seminorms.has_basis_ball (hp : with_seminorms p) {x : E} :\n    ((nhds) (x : E)).has_basis (fun sr : Finset Î¹ Ã— exprâ„ => 0 < sr.2) fun sr => (sr.1.sup p).ball x sr.2 :=\n  by\n  haveI : TopologicalAddGroup E := hp.topological_add_group\n  rw [â† map_add_left_nhds_zero]\n  convert hp.has_basis_zero_ball.map ((Â· + Â·) x)\n  ext sr : 1\n  have : (sr.fst.sup p).ball (Â«expr +áµ¥ Â» x 0) sr.snd = Â«expr +áµ¥ Â» x ((sr.fst.sup p).ball 0 sr.snd) :=\n    Eq.symm (Seminorm.vadd_ball (sr.fst.sup p))\n  rwa [vadd_eq_add, add_zero] at this\n#align with_seminorms.has_basis_ball with_seminorms.has_basis_ball\n\n",
 "has_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem with_seminorms.has_basis (hp : with_seminorms p) :\n    ((nhds) (0 : E)).has_basis (fun s : Set E => s âˆˆ p.basis_sets) id :=\n  by\n  rw [congr_fun (congr_arg (@nhds E) hp.1) 0]\n  exact AddGroupFilterBasis.nhds_zero_hasBasis _\n#align with_seminorms.has_basis with_seminorms.has_basis\n\n",
 "first_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem with_seminorms.first_countable (hp : with_seminorms p) : TopologicalSpace.FirstCountableTopology E :=\n  by\n  have : ((nhds) (0 : E)).is_countably_generated :=\n    by\n    rw [p.with_seminorms_iff_nhds_eq_infi.mp hp]\n    exact Filter.infáµ¢.isCountablyGenerated _\n  haveI : (uniformity E).is_countably_generated := UniformAddGroup.uniformity_countably_generated\n  exact UniformSpace.firstCountableTopology E\n#align with_seminorms.first_countable with_seminorms.first_countable\n\n",
 "finset_sup_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem seminorm_family.finset_sup_comp (q : seminorm_family ğ•œâ‚‚ F Î¹) (s : Finset Î¹) (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F) :\n    (s.sup q).comp f = s.sup (q.comp f) := by\n  ext x\n  rw [Seminorm.comp_apply, Seminorm.finset_sup_apply, Seminorm.finset_sup_apply]\n  rfl\n#align seminorm_family.finset_sup_comp seminorm_family.finset_sup_comp\n\n",
 "filter_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem filter_eq_infi (p : seminorm_family ğ•œ E Î¹) :\n    p.module_filter_basis.to_filter_basis.filter =\n      Â«exprâ¨… , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ¨… , Â»\"\n        (((nhds) 0).comap (p i)) :=\n  by\n  refine' le_antisymm (le_infáµ¢ fun i => _) _\n  Â· rw [p.module_filter_basis.to_filter_basis.has_basis.le_basis_iff (metric.nhds_basis_ball.comap _)]\n    intro Îµ hÎµ\n    refine' âŸ¨(p i).ball 0 Îµ, _, _âŸ©\n    Â· rw [â† (Finset.sup_singleton : _ = p i)]\n      exact p.basis_sets_mem {i} hÎµ\n    Â· rw [id, (p i).ball_zero_eq_preimage_ball]\n  Â· rw [p.module_filter_basis.to_filter_basis.has_basis.ge_iff]\n    rintro U (hU : U âˆˆ p.basis_sets)\n    rcases p.basis_sets_iff.mp hU with âŸ¨s, r, hr, rflâŸ©\n    rw [id, Seminorm.ball_finset_sup_eq_interáµ¢ _ _ _ hr, s.Inter_mem_sets]\n    exact fun i hi =>\n      Filter.mem_infáµ¢_of_mem i\n        âŸ¨Metric.ball 0 r, Metric.ball_mem_nhds 0 hr, Eq.subset (p i).ball_zero_eq_preimage_ball.symmâŸ©\n#align filter_eq_infi filter_eq_infi\n\n",
 "continuous_seminorm":
 "theorem with_seminorms.continuous_seminorm [NontriviallyNormedField ğ•] [Module ğ• E] [ContinuousConstSMul ğ• E]\n    {p : seminorm_family ğ• E Î¹} (hp : with_seminorms p) (i : Î¹) : Continuous (p i) :=\n  by\n  refine' Seminorm.continuous one_pos _\n  rw [p.with_seminorms_iff_nhds_eq_infi.mp hp, ball_zero_eq_preimage_ball]\n  exact Filter.mem_infáµ¢_of_mem i (Filter.preimage_mem_comap <| Metric.ball_mem_nhds _ one_pos)\n#align with_seminorms.continuous_seminorm with_seminorms.continuous_seminorm\n\n",
 "continuous_of_continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem continuous_of_continuous_comp {q : seminorm_family ğ•â‚‚ F Î¹'} [TopologicalSpace E] [TopologicalAddGroup E]\n    [TopologicalSpace F] [TopologicalAddGroup F] (hq : with_seminorms q) (f : Â«expr â†’â‚›â‚—[ ] Â» E Ï„â‚â‚‚ F)\n    (hf : âˆ€ i, Continuous ((q i).comp f)) : Continuous f :=\n  by\n  refine' continuous_of_continuousAt_zero f _\n  simp_rw [ContinuousAt, f.map_zero, q.with_seminorms_iff_nhds_eq_infi.mp hq, Filter.tendsto_infáµ¢,\n    Filter.tendsto_comap_iff]\n  intro i\n  convert(hf i).continuous_at\n  exact (map_zero _).symm\n#align continuous_of_continuous_comp continuous_of_continuous_comp\n\n",
 "continuous_iff_continuous_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem continuous_iff_continuous_comp {q : seminorm_family ğ•œâ‚‚ F Î¹'} [TopologicalSpace E] [TopologicalAddGroup E]\n    [TopologicalSpace F] [TopologicalAddGroup F] [ContinuousConstSMul ğ•œâ‚‚ F] (hq : with_seminorms q)\n    (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F) : Continuous f â†” âˆ€ i, Continuous ((q i).comp f) :=\n  âŸ¨fun h i => Continuous.comp (hq.continuous_seminorm i) h, continuous_of_continuous_comp hq fâŸ©\n#align continuous_iff_continuous_comp continuous_iff_continuous_comp\n\n",
 "continuous_from_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem continuous_from_bounded {p : seminorm_family ğ• E Î¹} {q : seminorm_family ğ•â‚‚ F Î¹'} [TopologicalSpace E]\n    [TopologicalAddGroup E] (hp : with_seminorms p) [TopologicalSpace F] [TopologicalAddGroup F] (hq : with_seminorms q)\n    (f : Â«expr â†’â‚›â‚—[ ] Â» E Ï„â‚â‚‚ F) (hf : seminorm.is_bounded p q f) : Continuous f :=\n  by\n  refine' continuous_of_continuous_comp hq _ fun i => Seminorm.continuous_of_continuousAt_zero _\n  rw [Metric.continuousAt_iff', map_zero]\n  intro r hr\n  rcases hf i with âŸ¨sâ‚, C, hfâŸ©\n  have hC' : 0 < C + 1 := by positivity\n  rw [hp.has_basis.eventually_iff]\n  refine' âŸ¨(sâ‚.sup p).ball 0 (r / (C + 1)), p.basis_sets_mem _ (by positivity), _âŸ©\n  simp_rw [â† Metric.mem_ball, â† mem_preimage, â† ball_zero_eq_preimage_ball]\n  refine' subset.trans _ (ball_antitone hf)\n  norm_cast\n  rw [â† ball_smul (sâ‚.sup p) hC']\n  refine' ball_antitone (smul_le_smul le_rfl _)\n  simp only [le_add_iff_nonneg_right, zero_le']\n#align continuous_from_bounded continuous_from_bounded\n\n",
 "cont_with_seminorms_normed_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem cont_with_seminorms_normed_space (F) [SeminormedAddCommGroup F] [NormedSpace ğ•â‚‚ F] [UniformSpace E]\n    [UniformAddGroup E] {p : Î¹ â†’ Seminorm ğ• E} (hp : with_seminorms p) (f : Â«expr â†’â‚›â‚—[ ] Â» E Ï„â‚â‚‚ F)\n    (hf : âˆƒ (s : Finset Î¹)(C : nnreal), (normSeminorm ğ•â‚‚ F).comp f â‰¤ Â«expr â€¢ Â» C (s.sup p)) : Continuous f :=\n  by\n  rw [â† seminorm.is_bounded_const (Fin 1)] at hf\n  exact continuous_from_bounded hp (norm_with_seminorms ğ•â‚‚ F) f hf\n#align cont_with_seminorms_normed_space cont_with_seminorms_normed_space\n\n",
 "cont_normed_space_to_with_seminorms":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem cont_normed_space_to_with_seminorms (E) [SeminormedAddCommGroup E] [NormedSpace ğ• E] [UniformSpace F]\n    [UniformAddGroup F] {q : Î¹ â†’ Seminorm ğ•â‚‚ F} (hq : with_seminorms q) (f : Â«expr â†’â‚›â‚—[ ] Â» E Ï„â‚â‚‚ F)\n    (hf : âˆ€ i : Î¹, âˆƒ C : nnreal, (q i).comp f â‰¤ Â«expr â€¢ Â» C (normSeminorm ğ• E)) : Continuous f :=\n  by\n  rw [â† seminorm.const_is_bounded (Fin 1)] at hf\n  exact continuous_from_bounded (norm_with_seminorms ğ• E) hq f hf\n#align cont_normed_space_to_with_seminorms cont_normed_space_to_with_seminorms\n\n",
 "const_is_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem const_is_bounded (Î¹ : Type _) [Nonempty Î¹] {p : Seminorm ğ•œ E} {q : Î¹' â†’ Seminorm ğ•œâ‚‚ F}\n    (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F) : is_bounded (fun _ : Î¹ => p) q f â†” âˆ€ i, âˆƒ C : nnreal, (q i).comp f â‰¤ Â«expr â€¢ Â» C p :=\n  by\n  constructor <;> intro h i\n  Â· rcases h i with âŸ¨s, C, hâŸ©\n    exact âŸ¨C, le_trans h (smul_le_smul (Finset.sup_le fun _ _ => le_rfl) le_rfl)âŸ©\n  use {Classical.arbitrary Î¹}\n  simp only [h, Finset.sup_singleton]\n#align const_is_bounded const_is_bounded\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚›â‚—[ ] Â» -/\ntheorem seminorm_family.comp_apply (q : seminorm_family ğ•œâ‚‚ F Î¹) (i : Î¹) (f : Â«expr â†’â‚›â‚—[ ] Â» E Ïƒâ‚â‚‚ F) :\n    q.comp f i = (q i).comp f :=\n  rfl\n#align seminorm_family.comp_apply seminorm_family.comp_apply\n\n",
 "basis_sets_zero":
 "theorem basis_sets_zero (U) (hU : U âˆˆ p.basis_sets) : (0 : E) âˆˆ U :=\n  by\n  rcases p.basis_sets_iff.mp hU with âŸ¨Î¹', r, hr, hUâŸ©\n  rw [hU, mem_ball_zero, map_zero]\n  exact hr\n#align basis_sets_zero basis_sets_zero\n\n",
 "basis_sets_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem basis_sets_smul_right (v : E) (U : Set E) (hU : U âˆˆ p.basis_sets) :\n    Â«exprâˆ€á¶  in , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ€á¶  in , Â»\" ((nhds) 0)\n      (Â«expr â€¢ Â» x v âˆˆ U) :=\n  by\n  rcases p.basis_sets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  rw [hU, Filter.eventually_iff]\n  simp_rw [(s.sup p).mem_ball_zero, map_smul_eq_mul]\n  by_cases h : 0 < (s.sup p) v\n  Â· simp_rw [(lt_div_iff h).symm]\n    rw [â† _root_.ball_zero_eq]\n    exact Metric.ball_mem_nhds 0 (div_pos hr h)\n  simp_rw [le_antisymm (not_lt.mp h) (map_nonneg _ v), MulZeroClass.mul_zero, hr]\n  exact IsOpen.mem_nhds isOpen_univ (mem_univ 0)\n#align basis_sets_smul_right basis_sets_smul_right\n\n",
 "basis_sets_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ€– â€–Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem basis_sets_smul_left (x : ğ•œ) (U : Set E) (hU : U âˆˆ p.basis_sets) :\n    âˆƒ (V : Set E)(H : V âˆˆ p.add_group_filter_basis.sets), V âŠ† Â«expr â»Â¹' Â» (fun y : E => Â«expr â€¢ Â» x y) U :=\n  by\n  rcases p.basis_sets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  rw [hU]\n  by_cases h : x â‰  0\n  Â· rw [(s.sup p).smul_ball_preimage 0 r x h, smul_zero]\n    use (s.sup p).ball 0 (r / Â«exprâ€– â€–Â» x)\n    exact âŸ¨p.basis_sets_mem s (div_pos hr (norm_pos_iff.mpr h)), subset.rflâŸ©\n  refine' âŸ¨(s.sup p).ball 0 r, p.basis_sets_mem s hr, _âŸ©\n  simp only [not_ne_iff.mp h, subset_def, mem_ball_zero, hr, mem_univ, map_zero, imp_true_iff, preimage_const_of_mem,\n    zero_smul]\n#align basis_sets_smul_left basis_sets_smul_left\n\n",
 "basis_sets_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\ntheorem basis_sets_smul (U) (hU : U âˆˆ p.basis_sets) :\n    âˆƒ (V : Set ğ•œ)(H : V âˆˆ (nhds) (0 : ğ•œ))(W : Set E)(H : W âˆˆ p.add_group_filter_basis.sets), Â«expr â€¢ Â» V W âŠ† U :=\n  by\n  rcases p.basis_sets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  refine' âŸ¨Metric.ball 0 r.sqrt, Metric.ball_mem_nhds 0 (real.sqrt_pos.mpr hr), _âŸ©\n  refine' âŸ¨(s.sup p).ball 0 r.sqrt, p.basis_sets_mem s (real.sqrt_pos.mpr hr), _âŸ©\n  refine' Set.Subset.trans (ball_smul_ball (s.sup p) r.sqrt r.sqrt) _\n  rw [hU, Real.mul_self_sqrt (le_of_lt hr)]\n#align basis_sets_smul basis_sets_smul\n\n",
 "basis_sets_singleton_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem basis_sets_singleton_mem (i : Î¹) {r : exprâ„} (hr : 0 < r) : (p i).ball 0 r âˆˆ p.basis_sets :=\n  (basis_sets_iff _).mpr âŸ¨{i}, _, hr, by rw [Finset.sup_singleton]âŸ©\n#align basis_sets_singleton_mem basis_sets_singleton_mem\n\n",
 "basis_sets_nonempty":
 "theorem basis_sets_nonempty [Nonempty Î¹] : p.basis_sets.nonempty :=\n  by\n  let i := Classical.arbitrary Î¹\n  refine' set.nonempty_def.mpr âŸ¨(p i).ball 0 1, _âŸ©\n  exact p.basis_sets_singleton_mem i zero_lt_one\n#align basis_sets_nonempty basis_sets_nonempty\n\n",
 "basis_sets_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem basis_sets_neg (U) (hU' : U âˆˆ p.basis_sets) :\n    âˆƒ (V : Set E)(H : V âˆˆ p.basis_sets), V âŠ† Â«expr â»Â¹' Â» (fun x : E => -x) U :=\n  by\n  rcases p.basis_sets_iff.mp hU' with âŸ¨s, r, hr, hUâŸ©\n  rw [hU, neg_preimage, neg_ball (s.sup p), neg_zero]\n  exact âŸ¨U, hU', Eq.subset hUâŸ©\n#align basis_sets_neg basis_sets_neg\n\n",
 "basis_sets_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem basis_sets_mem (i : Finset Î¹) {r : exprâ„} (hr : 0 < r) : (i.sup p).ball 0 r âˆˆ p.basis_sets :=\n  (basis_sets_iff _).mpr âŸ¨i, _, hr, rflâŸ©\n#align basis_sets_mem basis_sets_mem\n\n",
 "basis_sets_intersect":
 "theorem basis_sets_intersect (U V : Set E) (hU : U âˆˆ p.basis_sets) (hV : V âˆˆ p.basis_sets) :\n    âˆƒ (z : Set E)(H : z âˆˆ p.basis_sets), z âŠ† U âˆ© V := by\n  classical\n    rcases p.basis_sets_iff.mp hU with âŸ¨s, râ‚, hrâ‚, hUâŸ©\n    rcases p.basis_sets_iff.mp hV with âŸ¨t, râ‚‚, hrâ‚‚, hVâŸ©\n    use ((s âˆª t).sup p).ball 0 (min râ‚ râ‚‚)\n    refine' âŸ¨p.basis_sets_mem (s âˆª t) (lt_min_iff.mpr âŸ¨hrâ‚, hrâ‚‚âŸ©), _âŸ©\n    rw [hU, hV, ball_finset_sup_eq_Inter _ _ _ (lt_min_iff.mpr âŸ¨hrâ‚, hrâ‚‚âŸ©), ball_finset_sup_eq_Inter _ _ _ hrâ‚,\n      ball_finset_sup_eq_Inter _ _ _ hrâ‚‚]\n    exact\n      Set.subset_inter\n        (Set.interáµ¢â‚‚_mono' fun i hi => âŸ¨i, Finset.subset_union_left _ _ hi, ball_mono <| min_le_left _ _âŸ©)\n        (Set.interáµ¢â‚‚_mono' fun i hi => âŸ¨i, Finset.subset_union_right _ _ hi, ball_mono <| min_le_right _ _âŸ©)\n#align basis_sets_intersect basis_sets_intersect\n\n",
 "basis_sets_iff":
 "/-\nCopyright (c) 2022 Moritz Doll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Moritz Doll, Anatole Dedecker\n-/\ntheorem basis_sets_iff {U : Set E} : U âˆˆ p.basis_sets â†” âˆƒ (i : Finset Î¹)(r : _)(hr : 0 < r), U = ball (i.sup p) 0 r :=\n  by simp only [basis_sets, mem_Union, mem_singleton_iff]\n#align basis_sets_iff basis_sets_iff\n\n",
 "basis_sets_add":
 "theorem basis_sets_add (U) (hU : U âˆˆ p.basis_sets) : âˆƒ (V : Set E)(H : V âˆˆ p.basis_sets), V + V âŠ† U :=\n  by\n  rcases p.basis_sets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©\n  use (s.sup p).ball 0 (r / 2)\n  refine' âŸ¨p.basis_sets_mem s (div_pos hr zero_lt_two), _âŸ©\n  refine' Set.Subset.trans (ball_add_ball_subset (s.sup p) (r / 2) (r / 2) 0 0) _\n  rw [hU, add_zero, add_halves']\n#align basis_sets_add basis_sets_add\n\n"}