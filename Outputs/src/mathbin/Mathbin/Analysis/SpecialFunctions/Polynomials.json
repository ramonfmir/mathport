{"tendsto_nhds_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_nhds_iff {c : ùïú} : Tendsto (fun x => eval x P) atTop ((nhds) c) ‚Üî P.leading_coeff = c ‚àß P.degree ‚â§ 0 :=\n  by\n  refine' ‚ü®fun h => _, fun h => _‚ü©\n  ¬∑ have := P.is_equivalent_at_top_lead.tendsto_nhds h\n    by_cases hP : P.leading_coeff = 0\n    ¬∑ simp only [hP, MulZeroClass.zero_mul, tendsto_const_nhds_iff] at this\n      refine' ‚ü®trans hP this, by simp [leading_coeff_eq_zero.1 hP]‚ü©\n    ¬∑ rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this\n      exact this.symm\n  ¬∑ refine' P.is_equivalent_at_top_lead.symm.tendsto_nhds _\n    have : P.nat_degree = 0 := nat_degree_eq_zero_iff_degree_le_zero.2 h.2\n    simp only [h.1, this, pow_zero, mul_one]\n    exact tendsto_const_nhds\n#align tendsto_nhds_iff tendsto_nhds_iff\n\n",
 "tendsto_at_top_of_leading_coeff_nonneg":
 "theorem tendsto_at_top_of_leading_coeff_nonneg (hdeg : 0 < P.degree) (hnng : 0 ‚â§ P.leading_coeff) :\n    Tendsto (fun x => eval x P) atTop atTop :=\n  P.is_equivalent_at_top_lead.symm.tendsto_at_top <|\n    tendsto_const_mul_pow_atTop (natDegree_pos_iff_degree_pos.2 hdeg).ne' <|\n      hnng.lt_of_ne' <| leadingCoeff_ne_zero.mpr <| ne_zero_of_degree_gt hdeg\n#align tendsto_at_top_of_leading_coeff_nonneg tendsto_at_top_of_leading_coeff_nonneg\n\n",
 "tendsto_at_top_iff_leading_coeff_nonneg":
 "theorem tendsto_at_top_iff_leading_coeff_nonneg :\n    Tendsto (fun x => eval x P) atTop atTop ‚Üî 0 < P.degree ‚àß 0 ‚â§ P.leading_coeff :=\n  by\n  refine' ‚ü®fun h => _, fun h => tendsto_at_top_of_leading_coeff_nonneg P h.1 h.2‚ü©\n  have : tendsto (fun x => P.leading_coeff * x ^ P.nat_degree) at_top at_top :=\n    (is_equivalent_at_top_lead P).tendsto_at_top h\n  rw [tendsto_const_mul_pow_at_top_iff, ‚Üê pos_iff_ne_zero, nat_degree_pos_iff_degree_pos] at this\n  exact ‚ü®this.1, this.2.le‚ü©\n#align tendsto_at_top_iff_leading_coeff_nonneg tendsto_at_top_iff_leading_coeff_nonneg\n\n",
 "tendsto_at_bot_of_leading_coeff_nonpos":
 "theorem tendsto_at_bot_of_leading_coeff_nonpos (hdeg : 0 < P.degree) (hnps : P.leading_coeff ‚â§ 0) :\n    Tendsto (fun x => eval x P) atTop atBot :=\n  P.tendsto_at_bot_iff_leading_coeff_nonpos.2 ‚ü®hdeg, hnps‚ü©\n#align tendsto_at_bot_of_leading_coeff_nonpos tendsto_at_bot_of_leading_coeff_nonpos\n\n",
 "tendsto_at_bot_iff_leading_coeff_nonpos":
 "theorem tendsto_at_bot_iff_leading_coeff_nonpos :\n    Tendsto (fun x => eval x P) atTop atBot ‚Üî 0 < P.degree ‚àß P.leading_coeff ‚â§ 0 := by\n  simp only [‚Üê tendsto_neg_at_top_iff, ‚Üê eval_neg, tendsto_at_top_iff_leading_coeff_nonneg, degree_neg,\n    leading_coeff_neg, neg_nonneg]\n#align tendsto_at_bot_iff_leading_coeff_nonpos tendsto_at_bot_iff_leading_coeff_nonpos\n\n",
 "is_equivalent_at_top_lead":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem is_equivalent_at_top_lead :\n    asymptotics.is_equivalent (fun x => eval x P) atTop fun x => P.leading_coeff * x ^ P.nat_degree :=\n  by\n  by_cases h : P = 0\n  ¬∑ simp [h]\n  ¬∑ simp only [Polynomial.eval_eq_sum_range, sum_range_succ]\n    exact\n      is_o.add_is_equivalent\n        (is_o.sum fun i hi =>\n          is_o.const_mul_left\n            ((is_o.const_mul_right fun hz => h <| leading_coeff_eq_zero.mp hz) <|\n              is_o_pow_pow_at_top_of_lt (mem_range.mp hi))\n            _)\n        is_equivalent.refl\n#align is_equivalent_at_top_lead is_equivalent_at_top_lead\n\n",
 "is_equivalent_at_top_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `asymptotics.is_equivalent -/\ntheorem is_equivalent_at_top_div :\n    asymptotics.is_equivalent (fun x => eval x P / eval x Q) atTop fun x =>\n      P.leading_coeff / Q.leading_coeff * x ^ (P.nat_degree - Q.nat_degree : ‚Ñ§) :=\n  by\n  by_cases hP : P = 0\n  ¬∑ simp [hP]\n  by_cases hQ : Q = 0\n  ¬∑ simp [hQ]\n  refine'\n    (P.is_equivalent_at_top_lead.symm.div Q.is_equivalent_at_top_lead.symm).symm.trans\n      (eventually_eq.is_equivalent ((eventually_gt_at_top 0).mono fun x hx => _))\n  simp [‚Üê div_mul_div_comm, hP, hQ, zpow_sub‚ÇÄ hx.ne.symm]\n#align is_equivalent_at_top_div is_equivalent_at_top_div\n\n",
 "is_O_of_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr =O[ ] ¬ª -/\ntheorem is_O_of_degree_le (h : P.degree ‚â§ Q.degree) : ¬´expr =O[ ] ¬ª (fun x => eval x P) atTop fun x => eval x Q :=\n  by\n  by_cases hp : P = 0\n  ¬∑ simpa [hp] using is_O_zero (fun x => eval x Q) at_top\n  ¬∑ have hq : Q ‚â† 0 := ne_zero_of_degree_ge_degree h hp\n    have hPQ :\n      ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" at_top\n        (eval x Q = 0 ‚Üí eval x P = 0) :=\n      Filter.mem_of_superset (Polynomial.eventually_no_roots Q hq) fun x h h' => absurd h' h\n    cases' le_iff_lt_or_eq.mp h with h h\n    ¬∑ exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h)\n    ¬∑ exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h)\n#align is_O_of_degree_le is_O_of_degree_le\n\n",
 "eventually_no_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª -/\n/-\nCopyright (c) 2020 Anatole Dedecker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anatole Dedecker, Devon Tuma\n-/\ntheorem eventually_no_roots (hP : P ‚â† 0) :\n    ¬´expr‚àÄ·∂† in , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚àÄ·∂† in , ¬ª\" atTop\n      ¬¨P.is_root x :=\n  atTop_le_cofinite <| (finite_setOf_isRoot hP).compl_mem_cofinite\n#align eventually_no_roots eventually_no_roots\n\n",
 "div_tendsto_zero_of_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem div_tendsto_zero_of_degree_lt (hdeg : P.degree < Q.degree) :\n    Tendsto (fun x => eval x P / eval x Q) atTop ((nhds) 0) :=\n  by\n  by_cases hP : P = 0\n  ¬∑ simp [hP, tendsto_const_nhds]\n  rw [‚Üê nat_degree_lt_nat_degree_iff hP] at hdeg\n  refine' (is_equivalent_at_top_div P Q).symm.tendsto_nhds _\n  rw [‚Üê MulZeroClass.mul_zero]\n  refine' (tendsto_zpow_atTop_zero _).const_mul _\n  linarith\n#align div_tendsto_zero_of_degree_lt div_tendsto_zero_of_degree_lt\n\n",
 "div_tendsto_zero_iff_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem div_tendsto_zero_iff_degree_lt (hQ : Q ‚â† 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop ((nhds) 0) ‚Üî P.degree < Q.degree :=\n  by\n  refine' ‚ü®fun h => _, div_tendsto_zero_of_degree_lt P Q‚ü©\n  by_cases hPQ : P.leading_coeff / Q.leading_coeff = 0\n  ¬∑ simp only [div_eq_mul_inv, inv_eq_zero, mul_eq_zero] at hPQ\n    cases' hPQ with hP0 hQ0\n    ¬∑ rw [leading_coeff_eq_zero.1 hP0, degree_zero]\n      exact bot_lt_iff_ne_bot.2 fun hQ' => hQ (degree_eq_bot.1 hQ')\n    ¬∑ exact absurd (leading_coeff_eq_zero.1 hQ0) hQ\n  ¬∑ have := (is_equivalent_at_top_div P Q).tendsto_nhds h\n    rw [tendsto_const_mul_zpow_atTop_nhds_iff hPQ] at this\n    cases' this with h h\n    ¬∑ exact absurd h.2 hPQ\n    ¬∑ rw [sub_lt_iff_lt_add, zero_add, Int.ofNat_lt] at h\n      exact degree_lt_degree h.1\n#align div_tendsto_zero_iff_degree_lt div_tendsto_zero_iff_degree_lt\n\n",
 "div_tendsto_leading_coeff_div_of_degree_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem div_tendsto_leading_coeff_div_of_degree_eq (hdeg : P.degree = Q.degree) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (nhds <| P.leading_coeff / Q.leading_coeff) :=\n  by\n  refine' (is_equivalent_at_top_div P Q).symm.tendsto_nhds _\n  rw [show (P.nat_degree : ‚Ñ§) = Q.nat_degree by simp [hdeg, nat_degree]]\n  simp [tendsto_const_nhds]\n#align div_tendsto_leading_coeff_div_of_degree_eq div_tendsto_leading_coeff_div_of_degree_eq\n\n",
 "div_tendsto_at_top_of_degree_gt'":
 "theorem div_tendsto_at_top_of_degree_gt' (hdeg : Q.degree < P.degree) (hpos : 0 < P.leading_coeff / Q.leading_coeff) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atTop :=\n  by\n  have hQ : Q ‚â† 0 := fun h => by\n    simp only [h, div_zero, leading_coeff_zero] at hpos\n    linarith\n  rw [‚Üê nat_degree_lt_nat_degree_iff hQ] at hdeg\n  refine' (is_equivalent_at_top_div P Q).symm.tendsto_at_top _\n  apply tendsto.const_mul_at_top hpos\n  apply tendsto_zpow_atTop_atTop\n  linarith\n#align div_tendsto_at_top_of_degree_gt' div_tendsto_at_top_of_degree_gt'\n\n",
 "div_tendsto_at_top_of_degree_gt":
 "theorem div_tendsto_at_top_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q ‚â† 0)\n    (hnng : 0 ‚â§ P.leading_coeff / Q.leading_coeff) : Tendsto (fun x => eval x P / eval x Q) atTop atTop :=\n  have ratio_pos : 0 < P.leading_coeff / Q.leading_coeff :=\n    lt_of_le_of_ne hnng\n      (div_ne_zero (fun h => ne_zero_of_degree_gt hdeg <| leadingCoeff_eq_zero.mp h) fun h =>\n          hQ <| leadingCoeff_eq_zero.mp h).symm\n  div_tendsto_atTop_of_degree_gt' P Q hdeg ratio_pos\n#align div_tendsto_at_top_of_degree_gt div_tendsto_at_top_of_degree_gt\n\n",
 "div_tendsto_at_bot_of_degree_gt'":
 "theorem div_tendsto_at_bot_of_degree_gt' (hdeg : Q.degree < P.degree) (hneg : P.leading_coeff / Q.leading_coeff < 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atBot :=\n  by\n  have hQ : Q ‚â† 0 := fun h => by\n    simp only [h, div_zero, leading_coeff_zero] at hneg\n    linarith\n  rw [‚Üê nat_degree_lt_nat_degree_iff hQ] at hdeg\n  refine' (is_equivalent_at_top_div P Q).symm.tendsto_at_bot _\n  apply tendsto.neg_const_mul_at_top hneg\n  apply tendsto_zpow_atTop_atTop\n  linarith\n#align div_tendsto_at_bot_of_degree_gt' div_tendsto_at_bot_of_degree_gt'\n\n",
 "div_tendsto_at_bot_of_degree_gt":
 "theorem div_tendsto_at_bot_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q ‚â† 0)\n    (hnps : P.leading_coeff / Q.leading_coeff ‚â§ 0) : Tendsto (fun x => eval x P / eval x Q) atTop atBot :=\n  have ratio_neg : P.leading_coeff / Q.leading_coeff < 0 :=\n    lt_of_le_of_ne hnps\n      (div_ne_zero (fun h => ne_zero_of_degree_gt hdeg <| leadingCoeff_eq_zero.mp h) fun h =>\n        hQ <| leadingCoeff_eq_zero.mp h)\n  div_tendsto_atBot_of_degree_gt' P Q hdeg ratio_neg\n#align div_tendsto_at_bot_of_degree_gt div_tendsto_at_bot_of_degree_gt\n\n",
 "abs_tendsto_at_top_iff":
 "theorem abs_tendsto_at_top_iff : Tendsto (fun x => abs <| eval x P) atTop atTop ‚Üî 0 < P.degree :=\n  ‚ü®fun h => not_le.mp (mt (abs_isBoundedUnder_iff P).mpr (not_isBoundedUnder_of_tendsto_atTop h)), abs_tendsto_atTop P‚ü©\n#align abs_tendsto_at_top_iff abs_tendsto_at_top_iff\n\n",
 "abs_tendsto_at_top":
 "theorem abs_tendsto_at_top (hdeg : 0 < P.degree) : Tendsto (fun x => abs <| eval x P) atTop atTop :=\n  by\n  cases' le_total 0 P.leading_coeff with hP hP\n  ¬∑ exact tendsto_abs_at_top_at_top.comp (P.tendsto_at_top_of_leading_coeff_nonneg hdeg hP)\n  ¬∑ exact tendsto_abs_at_bot_at_top.comp (P.tendsto_at_bot_of_leading_coeff_nonpos hdeg hP)\n#align abs_tendsto_at_top abs_tendsto_at_top\n\n",
 "abs_is_bounded_under_iff":
 "theorem abs_is_bounded_under_iff : (IsBoundedUnder (¬∑ ‚â§ ¬∑) atTop fun x => |eval x P|) ‚Üî P.degree ‚â§ 0 :=\n  by\n  refine'\n    ‚ü®fun h => _, fun h =>\n      ‚ü®|P.coeff 0|,\n        eventually_map.mpr\n          (eventually_of_forall\n            (forall_imp (fun _ => le_of_eq) fun x =>\n              congr_arg abs <| trans (congr_arg (eval x) (eq_C_of_degree_le_zero h)) eval_C))‚ü©‚ü©\n  contrapose! h\n  exact not_is_bounded_under_of_tendsto_at_top (abs_tendsto_at_top P h)\n#align abs_is_bounded_under_iff abs_is_bounded_under_iff\n\n",
 "abs_div_tendsto_at_top_of_degree_gt":
 "theorem abs_div_tendsto_at_top_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q ‚â† 0) :\n    Tendsto (fun x => |eval x P / eval x Q|) atTop atTop :=\n  by\n  by_cases h : 0 ‚â§ P.leading_coeff / Q.leading_coeff\n  ¬∑ exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h)\n  ¬∑ push_neg  at h\n    exact tendsto_abs_at_bot_at_top.comp (P.div_tendsto_at_bot_of_degree_gt Q hdeg hQ h.le)\n#align abs_div_tendsto_at_top_of_degree_gt abs_div_tendsto_at_top_of_degree_gt\n\n"}