{"complex_of_real_eval_U":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp, norm_cast]\ntheorem complex_of_real_eval_U : ∀ x n, ((U (exprℝ) n).eval x : exprℂ) = (U (exprℂ) n).eval x :=\n  @algebra_map_eval_U (exprℝ) (exprℂ) _ _ _\n#align complex_of_real_eval_U complex_of_real_eval_U\n\n",
 "complex_of_real_eval_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp, norm_cast]\ntheorem complex_of_real_eval_T : ∀ x n, ((T (exprℝ) n).eval x : exprℂ) = (T (exprℂ) n).eval x :=\n  @algebra_map_eval_T (exprℝ) (exprℂ) _ _ _\n#align complex_of_real_eval_T complex_of_real_eval_T\n\n",
 "algebra_map_eval_U":
 "@[simp]\ntheorem algebra_map_eval_U (x : R) (n : ℕ) : algebra_map R A ((U R n).eval x) = (U A n).eval (algebra_map R A x) := by\n  rw [← aeval_algebra_map_apply_eq_algebra_map_eval, aeval_U]\n#align algebra_map_eval_U algebra_map_eval_U\n\n",
 "algebra_map_eval_T":
 "@[simp]\ntheorem algebra_map_eval_T (x : R) (n : ℕ) : algebra_map R A ((T R n).eval x) = (T A n).eval (algebra_map R A x) := by\n  rw [← aeval_algebra_map_apply_eq_algebra_map_eval, aeval_T]\n#align algebra_map_eval_T algebra_map_eval_T\n\n",
 "aeval_U":
 "@[simp]\ntheorem aeval_U (x : A) (n : ℕ) : aeval x (U R n) = (U A n).eval x := by rw [aeval_def, eval₂_eq_eval_map, map_U]\n#align aeval_U aeval_U\n\n",
 "aeval_T":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n@[simp]\ntheorem aeval_T (x : A) (n : ℕ) : aeval x (T R n) = (T A n).eval x := by rw [aeval_def, eval₂_eq_eval_map, map_T]\n#align aeval_T aeval_T\n\n",
 "U_real_cos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The `n`-th Chebyshev polynomial of the second kind evaluates on `cos θ` to the\nvalue `sin ((n + 1) * θ) / sin θ`. -/\n@[simp]\ntheorem U_real_cos : (U (exprℝ) n).eval (cos θ) * sin θ = sin ((n + 1) * θ) := by exact_mod_cast U_complex_cos θ n\n#align U_real_cos U_real_cos\n\n",
 "U_complex_cos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The `n`-th Chebyshev polynomial of the second kind evaluates on `cos θ` to the\nvalue `sin ((n + 1) * θ) / sin θ`. -/\n@[simp]\ntheorem U_complex_cos (n : ℕ) : (U (exprℂ) n).eval (cos θ) * sin θ = sin ((n + 1) * θ) :=\n  by\n  induction' n with d hd\n  · simp only [U_zero, Nat.cast_zero, eval_one, mul_one, zero_add, one_mul]\n  · rw [U_eq_X_mul_U_add_T]\n    simp only [eval_add, eval_mul, eval_X, T_complex_cos, add_mul, mul_assoc, hd, one_mul]\n    conv_rhs => rw [sin_add, mul_comm]\n    push_cast\n    simp only [add_mul, one_mul]\n#align U_complex_cos U_complex_cos\n\n",
 "T_real_cos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- ### Real versions\n/-- The `n`-th Chebyshev polynomial of the first kind evaluates on `cos θ` to the\nvalue `cos (n * θ)`. -/\n@[simp]\ntheorem T_real_cos : (T (exprℝ) n).eval (cos θ) = cos (n * θ) := by exact_mod_cast T_complex_cos θ n\n#align T_real_cos T_real_cos\n\n",
 "T_complex_cos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The `n`-th Chebyshev polynomial of the first kind evaluates on `cos θ` to the\nvalue `cos (n * θ)`. -/\n@[simp]\ntheorem T_complex_cos : ∀ n, (T (exprℂ) n).eval (cos θ) = cos (n * θ)\n  | 0 => by simp only [T_zero, eval_one, Nat.cast_zero, zero_mul, cos_zero]\n  | 1 => by simp only [eval_X, one_mul, T_one, Nat.cast_one]\n  | n + 2 => by\n    simp only [eval_X, eval_one, T_add_two, eval_sub, eval_bit0, Nat.cast_succ, eval_mul]\n    rw [T_complex_cos (n + 1), T_complex_cos n]\n    have aux : sin θ * sin θ = 1 - cos θ * cos θ :=\n      by\n      rw [← sin_sq_add_cos_sq θ]\n      ring\n    simp only [Nat.cast_add, Nat.cast_one, add_mul, cos_add, one_mul, sin_add, mul_assoc, aux]\n    ring\n#align T_complex_cos T_complex_cos\n\n"}