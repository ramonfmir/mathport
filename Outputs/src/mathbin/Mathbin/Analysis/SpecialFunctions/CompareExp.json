{"tendsto_abs_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem tendsto_abs_re (hl : is_exp_cmp_filter l) : tendsto (fun z : exprℂ => |z.re|) l at_top :=\n  tendsto_abs_at_top_at_top.comp hl.tendsto_re\n#align tendsto_abs_re tendsto_abs_re\n\n",
 "tendsto_abs":
 "theorem tendsto_abs (hl : is_exp_cmp_filter l) : tendsto abs l at_top :=\n  tendsto_at_top_mono abs_re_le_abs hl.tendsto_abs_re\n#align tendsto_abs tendsto_abs\n\n",
 "of_is_O_im_re_rpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem of_is_O_im_re_rpow (hre : tendsto re l at_top) (r : exprℝ) (hr : «expr =O[ ] » im l fun z => z.re ^ r) :\n    is_exp_cmp_filter l :=\n  ⟨hre, fun n =>\n    is_o.is_O <|\n      calc\n        «expr =O[ ] » (fun z : exprℂ => z.im ^ n) l fun z => (z.re ^ r) ^ n := hr.pow n\n        «expr =ᶠ[ ] » _ l fun z => z.re ^ (r * n) :=\n          (hre.eventually_ge_at_top 0).mono fun z hz => by simp only [real.rpow_mul hz r n, real.rpow_nat_cast]\n        «expr =o[ ] » _ l fun z => real.exp z.re := (is_o_rpow_exp_at_top _).comp_tendsto hre\n        ⟩\n#align of_is_O_im_re_rpow of_is_O_im_re_rpow\n\n",
 "of_is_O_im_re_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\ntheorem of_is_O_im_re_pow (hre : tendsto re l at_top) (n : ℕ) (hr : «expr =O[ ] » im l fun z => z.re ^ n) :\n    is_exp_cmp_filter l :=\n  of_is_O_im_re_rpow hre n <| by simpa only [real.rpow_nat_cast]\n#align of_is_O_im_re_pow of_is_O_im_re_pow\n\n",
 "of_bounded_under_im":
 "theorem of_bounded_under_im (hre : tendsto re l at_top) (him_le : is_bounded_under (· ≤ ·) l im)\n    (him_ge : is_bounded_under (· ≥ ·) l im) : is_exp_cmp_filter l :=\n  of_bounded_under_abs_im hre <| is_bounded_under_le_abs.2 ⟨him_le, him_ge⟩\n#align of_bounded_under_im of_bounded_under_im\n\n",
 "of_bounded_under_abs_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_bounded_under_abs_im (hre : tendsto re l at_top) (him : is_bounded_under (· ≤ ·) l fun z => |z.im|) :\n    is_exp_cmp_filter l :=\n  of_is_O_im_re_pow hre 0 <| by\n    simpa only [pow_zero] using @is_bounded_under.is_O_const (exprℂ) (exprℝ) (exprℝ) _ _ _ l him 1 one_ne_zero\n#align of_bounded_under_abs_im of_bounded_under_abs_im\n\n",
 "is_o_zpow_mul_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `l : filter ℂ` is an \"exponential comparison filter\", then for any complex `a₁`, `a₂` and any\ninteger `b₁ < b₂`, we have `(λ z, z ^ a₁ * exp (b₁ * z)) =o[l] (λ z, z ^ a₂ * exp (b₂ * z))`. -/\ntheorem is_o_zpow_mul_exp {b₁ b₂ : exprℝ} (hl : is_exp_cmp_filter l) (hb : b₁ < b₂) (m n : ℤ) :\n    «expr =o[ ] » (fun z => z ^ m * exp (b₁ * z)) l fun z => z ^ n * exp (b₂ * z) := by\n  simpa only [cpow_int_cast] using hl.is_o_cpow_mul_exp hb m n\n#align is_o_zpow_mul_exp is_o_zpow_mul_exp\n\n",
 "is_o_pow_mul_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `l : filter ℂ` is an \"exponential comparison filter\", then for any complex `a₁`, `a₂` and any\nnatural `b₁ < b₂`, we have `(λ z, z ^ a₁ * exp (b₁ * z)) =o[l] (λ z, z ^ a₂ * exp (b₂ * z))`. -/\ntheorem is_o_pow_mul_exp {b₁ b₂ : exprℝ} (hl : is_exp_cmp_filter l) (hb : b₁ < b₂) (m n : ℕ) :\n    «expr =o[ ] » (fun z => z ^ m * exp (b₁ * z)) l fun z => z ^ n * exp (b₂ * z) := by\n  simpa only [cpow_nat_cast] using hl.is_o_cpow_mul_exp hb m n\n#align is_o_pow_mul_exp is_o_pow_mul_exp\n\n",
 "is_o_log_re_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\ntheorem is_o_log_re_re (hl : is_exp_cmp_filter l) : «expr =o[ ] » (fun z => real.log z.re) l re :=\n  real.is_o_log_id_at_top.comp_tendsto hl.tendsto_re\n#align is_o_log_re_re is_o_log_re_re\n\n",
 "is_o_log_abs_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `l : filter ℂ` is an \"exponential comparison filter\", then $\\log |z| =o(ℜ z)$ along `l`.\nThis is the main lemma in the proof of `complex.is_exp_cmp_filter.is_o_cpow_exp` below.\n-/\ntheorem is_o_log_abs_re (hl : is_exp_cmp_filter l) : «expr =o[ ] » (fun z => real.log (abs z)) l re :=\n  calc\n    «expr =O[ ] » (fun z => real.log (abs z)) l fun z => real.log (real.sqrt 2) + real.log (max z.re (|z.im|)) :=\n      is_O.of_bound 1 <|\n        (hl.tendsto_re.eventually_ge_at_top 1).mono fun z hz =>\n          by\n          have h2 : 0 < real.sqrt 2 := by simp\n          have hz' : 1 ≤ abs z := hz.trans (re_le_abs z)\n          have hz₀ : 0 < abs z := one_pos.trans_le hz'\n          have hm₀ : 0 < max z.re (|z.im|) := lt_max_iff.2 (or.inl <| one_pos.trans_le hz)\n          rw [one_mul, real.norm_eq_abs, _root_.abs_of_nonneg (real.log_nonneg hz')]\n          refine' le_trans _ (le_abs_self _)\n          rw [← real.log_mul, real.log_le_log, ← _root_.abs_of_nonneg (le_trans zero_le_one hz)]\n          exacts[abs_le_sqrt_two_mul_max z, one_pos.trans_le hz', mul_pos h2 hm₀, h2.ne', hm₀.ne']\n    «expr =o[ ] » _ l re :=\n      is_o.add (is_o_const_left.2 <| or.inr <| hl.tendsto_abs_re) <|\n        is_o_iff_nat_mul_le.2 fun n =>\n          by\n          filter_upwards [is_o_iff_nat_mul_le.1 hl.is_o_log_re_re n, hl.abs_im_pow_eventually_le_exp_re n,\n            hl.tendsto_re.eventually_gt_at_top 1] with z hre him h₁\n          cases' le_total (|z.im|) z.re with hle hle\n          · rwa [max_eq_left hle]\n          · have H : 1 < |z.im| := h₁.trans_le hle\n            rwa [max_eq_right hle, real.norm_eq_abs, real.norm_eq_abs, abs_of_pos (real.log_pos H), ← real.log_pow,\n              real.log_le_iff_le_exp (pow_pos (one_pos.trans H) _), abs_of_pos (one_pos.trans h₁)]\n    \n#align is_o_log_abs_re is_o_log_abs_re\n\n",
 "is_o_im_pow_exp_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem is_o_im_pow_exp_re (hl : is_exp_cmp_filter l) (n : ℕ) :\n    «expr =o[ ] » (fun z : exprℂ => z.im ^ n) l fun z => real.exp z.re :=\n  flip is_o.of_pow two_ne_zero <|\n    calc\n      (fun z : exprℂ => (z.im ^ n) ^ 2) = fun z => z.im ^ (2 * n) := by simp only [pow_mul']\n      «expr =O[ ] » _ l fun z => real.exp z.re := hl.is_O_im_pow_re _\n      _ = fun z => real.exp z.re ^ 1 := by simp only [pow_one]\n      «expr =o[ ] » _ l fun z => real.exp z.re ^ 2 :=\n        (is_o_pow_pow_at_top_of_lt one_lt_two).comp_tendsto <| real.tendsto_exp_at_top.comp hl.tendsto_re\n      \n#align is_o_im_pow_exp_re is_o_im_pow_exp_re\n\n",
 "is_o_exp_cpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `l : filter ℂ` is an \"exponential comparison filter\", then for any complex `a` and any\nnegative real `b`, we have `(λ z, exp (b * z)) =o[l] (λ z, z ^ a)`. -/\ntheorem is_o_exp_cpow (hl : is_exp_cmp_filter l) (a : exprℂ) {b : exprℝ} (hb : b < 0) :\n    «expr =o[ ] » (fun z => exp (b * z)) l fun z => z ^ a := by simpa using hl.is_o_cpow_mul_exp hb 0 a\n#align is_o_exp_cpow is_o_exp_cpow\n\n",
 "is_o_cpow_mul_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `l : filter ℂ` is an \"exponential comparison filter\", then for any complex `a₁`, `a₂` and any\nreal `b₁ < b₂`, we have `(λ z, z ^ a₁ * exp (b₁ * z)) =o[l] (λ z, z ^ a₂ * exp (b₂ * z))`. -/\ntheorem is_o_cpow_mul_exp {b₁ b₂ : exprℝ} (hl : is_exp_cmp_filter l) (hb : b₁ < b₂) (a₁ a₂ : exprℂ) :\n    «expr =o[ ] » (fun z => z ^ a₁ * exp (b₁ * z)) l fun z => z ^ a₂ * exp (b₂ * z) :=\n  calc\n    «expr =ᶠ[ ] » (fun z => z ^ a₁ * exp (b₁ * z)) l fun z => z ^ a₂ * exp (b₁ * z) * z ^ (a₁ - a₂) :=\n      hl.eventually_ne.mono fun z hz => by\n        simp only\n        rw [mul_right_comm, ← cpow_add _ _ hz, add_sub_cancel'_right]\n    «expr =o[ ] » _ l fun z => z ^ a₂ * exp (b₁ * z) * exp (↑(b₂ - b₁) * z) :=\n      (is_O_refl (fun z => z ^ a₂ * exp (b₁ * z)) l).mul_is_o <| hl.is_o_cpow_exp _ (sub_pos.2 hb)\n    «expr =ᶠ[ ] » _ l fun z => z ^ a₂ * exp (b₂ * z) := by\n      simp only [of_real_sub, sub_mul, mul_assoc, ← exp_add, add_sub_cancel'_right]\n    \n#align is_o_cpow_mul_exp is_o_cpow_mul_exp\n\n",
 "is_o_cpow_exp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =Θ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/-- If `l : filter ℂ` is an \"exponential comparison filter\", then for any complex `a` and any\npositive real `b`, we have `(λ z, z ^ a) =o[l] (λ z, exp (b * z))`. -/\ntheorem is_o_cpow_exp (hl : is_exp_cmp_filter l) (a : exprℂ) {b : exprℝ} (hb : 0 < b) :\n    «expr =o[ ] » (fun z => z ^ a) l fun z => exp (b * z) :=\n  calc\n    «expr =Θ[ ] » (fun z => z ^ a) l fun z => abs z ^ re a := is_Theta_cpow_const_rpow fun _ _ => hl.eventually_ne\n    «expr =ᶠ[ ] » _ l fun z => real.exp (re a * real.log (abs z)) :=\n      hl.eventually_ne.mono fun z hz => by simp only [real.rpow_def_of_pos, abs.pos hz, mul_comm]\n    «expr =o[ ] » _ l fun z => exp (b * z) :=\n      is_o.of_norm_right <|\n        by\n        simp only [norm_eq_abs, abs_exp, of_real_mul_re, real.is_o_exp_comp_exp_comp]\n        refine' (is_equivalent.refl.sub_is_o _).symm.tendsto_at_top (hl.tendsto_re.const_mul_at_top hb)\n        exact (hl.is_o_log_abs_re.const_mul_left _).const_mul_right hb.ne'\n    \n#align is_o_cpow_exp is_o_cpow_exp\n\n",
 "eventually_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem eventually_ne (hl : is_exp_cmp_filter l) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l (w ≠ 0) :=\n  hl.tendsto_re.eventually_ne_at_top' _\n#align eventually_ne eventually_ne\n\n",
 "abs_im_pow_eventually_le_exp_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≤ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem abs_im_pow_eventually_le_exp_re (hl : is_exp_cmp_filter l) (n : ℕ) :\n    «expr ≤ᶠ[ ] » (fun z : exprℂ => |z.im| ^ n) l fun z => real.exp z.re := by\n  simpa using (hl.is_o_im_pow_exp_re n).bound zero_lt_one\n#align abs_im_pow_eventually_le_exp_re abs_im_pow_eventually_le_exp_re\n\n"}