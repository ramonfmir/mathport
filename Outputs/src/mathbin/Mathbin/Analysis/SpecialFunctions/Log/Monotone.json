{"log_mul_self_monotone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2021 Bolton Bailey. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bolton Bailey\n-/\ntheorem log_mul_self_monotone_on : monotone_on (fun x : exprℝ => log x * x) { x | 1 ≤ x } :=\n  by\n  -- TODO: can be strengthened to exp (-1) ≤ x\n  simp only [monotone_on, mem_set_of_eq]\n  intro x hex y hey hxy\n  have x_pos : 0 < x := lt_of_lt_of_le zero_lt_one hex\n  have y_pos : 0 < y := lt_of_lt_of_le zero_lt_one hey\n  refine' mul_le_mul ((log_le_log x_pos y_pos).mpr hxy) hxy (le_of_lt x_pos) _\n  rwa [le_log_iff_exp_le y_pos, real.exp_zero]\n#align log_mul_self_monotone_on log_mul_self_monotone_on\n\n",
 "log_div_sqrt_antitone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem log_div_sqrt_antitone_on : antitone_on (fun x : exprℝ => log x / sqrt x) { x | exp 2 ≤ x } :=\n  by\n  simp_rw [sqrt_eq_rpow]\n  convert @log_div_self_rpow_antitone_on (1 / 2) (by norm_num)\n  norm_num\n#align log_div_sqrt_antitone_on log_div_sqrt_antitone_on\n\n",
 "log_div_self_rpow_antitone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem log_div_self_rpow_antitone_on {a : exprℝ} (ha : 0 < a) :\n    antitone_on (fun x : exprℝ => log x / x ^ a) { x | exp (1 / a) ≤ x } :=\n  by\n  simp only [antitone_on, mem_set_of_eq]\n  intro x hex y hey hxy\n  have x_pos : 0 < x := lt_of_lt_of_le (exp_pos (1 / a)) hex\n  have y_pos : 0 < y := by linarith\n  have x_nonneg : 0 ≤ x := le_trans (le_of_lt (exp_pos (1 / a))) hex\n  have y_nonneg : 0 ≤ y := by linarith\n  nth_rw 1 [← rpow_one y]\n  nth_rw 1 [← rpow_one x]\n  rw [← div_self (ne_of_lt ha).symm, div_eq_mul_one_div a a, rpow_mul y_nonneg, rpow_mul x_nonneg,\n    log_rpow (rpow_pos_of_pos y_pos a), log_rpow (rpow_pos_of_pos x_pos a), mul_div_assoc, mul_div_assoc,\n    mul_le_mul_left (one_div_pos.mpr ha)]\n  · refine' log_div_self_antitone_on _ _ _\n    · simp only [Set.mem_setOf_eq]\n      convert rpow_le_rpow _ hex (le_of_lt ha)\n      rw [← exp_mul]\n      simp only [real.exp_eq_exp]\n      field_simp [(ne_of_lt ha).symm]\n      exact le_of_lt (exp_pos (1 / a))\n    · simp only [Set.mem_setOf_eq]\n      convert rpow_le_rpow _ (trans hex hxy) (le_of_lt ha)\n      rw [← exp_mul]\n      simp only [real.exp_eq_exp]\n      field_simp [(ne_of_lt ha).symm]\n      exact le_of_lt (exp_pos (1 / a))\n    exact rpow_le_rpow x_nonneg hxy (le_of_lt ha)\n#align log_div_self_rpow_antitone_on log_div_self_rpow_antitone_on\n\n",
 "log_div_self_antitone_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem log_div_self_antitone_on : antitone_on (fun x : exprℝ => log x / x) { x | exp 1 ≤ x } :=\n  by\n  simp only [antitone_on, mem_set_of_eq]\n  intro x hex y hey hxy\n  have x_pos : 0 < x := (exp_pos 1).trans_le hex\n  have y_pos : 0 < y := (exp_pos 1).trans_le hey\n  have hlogx : 1 ≤ log x := by rwa [le_log_iff_exp_le x_pos]\n  have hyx : 0 ≤ y / x - 1 := by rwa [le_sub_iff_add_le, le_div_iff x_pos, zero_add, one_mul]\n  rw [div_le_iff y_pos, ← sub_le_sub_iff_right (log x)]\n  calc\n    log y - log x = log (y / x) := by rw [log_div y_pos.ne' x_pos.ne']\n    _ ≤ y / x - 1 := log_le_sub_one_of_pos (div_pos y_pos x_pos)\n    _ ≤ log x * (y / x - 1) := le_mul_of_one_le_left hyx hlogx\n    _ = log x / x * y - log x := by ring\n    \n#align log_div_self_antitone_on log_div_self_antitone_on\n\n"}