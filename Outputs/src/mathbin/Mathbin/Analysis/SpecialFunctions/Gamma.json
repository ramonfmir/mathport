{"tendsto_partial_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_partial_Gamma {s : exprℂ} (hs : 0 < s.re) :\n    Tendsto (fun X : exprℝ => partial_Gamma s X) atTop (nhds <| Gamma_integral s) :=\n  interval_integral_tendsto_integral_Ioi 0 (Gamma_integral_convergent hs) tendsto_id\n#align tendsto_partial_Gamma tendsto_partial_Gamma\n\n",
 "tendsto_log_gamma_seq_of_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_log_gamma_seq_of_le_one (hf_conv : ConvexOn (exprℝ) (Ioi 0) f)\n    (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ≤ 1) :\n    Tendsto (log_gamma_seq x) atTop (nhds <| f x - f 1) :=\n  by\n  refine' tendsto_of_tendsto_of_tendsto_of_le_of_le' _ tendsto_const_nhds _ _\n  show\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (log_gamma_seq x n ≤ f x - f 1)\n  · refine' eventually.mp (eventually_ne_at_top 0) (eventually_of_forall fun n hn => _)\n    exact le_sub_iff_add_le'.mpr (ge_log_gamma_seq hf_conv (@hf_feq) hx hn)\n  show\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n      (f x - f 1 - x * (log (n + 1) - log n) ≤ log_gamma_seq x n)\n  · refine' eventually_of_forall fun n => _\n    rw [sub_le_iff_le_add', sub_le_iff_le_add']\n    convert le_log_gamma_seq hf_conv (@hf_feq) hx hx' n using 1\n    ring\n  · have : f x - f 1 = f x - f 1 - x * 0 := by ring\n    nth_rw 1 [this]\n    exact tendsto.sub tendsto_const_nhds (tendsto_log_nat_add_one_sub_log.const_mul _)\n#align tendsto_log_gamma_seq_of_le_one tendsto_log_gamma_seq_of_le_one\n\n",
 "tendsto_log_gamma_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_log_gamma_seq (hf_conv : ConvexOn (exprℝ) (Ioi 0) f)\n    (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) :\n    Tendsto (log_gamma_seq x) atTop (nhds <| f x - f 1) :=\n  by\n  suffices ∀ m : ℕ, ↑m < x → x ≤ m + 1 → tendsto (log_gamma_seq x) at_top (nhds <| f x - f 1)\n    by\n    refine' this («expr⌈ ⌉₊» (x - 1)) _ _\n    · rcases lt_or_le x 1 with ⟨⟩\n      · rwa [nat.ceil_eq_zero.mpr (by linarith : x - 1 ≤ 0), Nat.cast_zero]\n      · convert Nat.ceil_lt_add_one (by linarith : 0 ≤ x - 1)\n        abel\n    · rw [← sub_le_iff_le_add]\n      exact Nat.le_ceil _\n  intro m\n  induction' m with m hm generalizing x\n  · rw [Nat.cast_zero, zero_add]\n    exact fun _ hx' => tendsto_log_gamma_seq_of_le_one hf_conv (@hf_feq) hx hx'\n  · intro hy hy'\n    rw [Nat.cast_succ, ← sub_le_iff_le_add] at hy'\n    rw [Nat.cast_succ, ← lt_sub_iff_add_lt] at hy\n    specialize hm ((Nat.cast_nonneg _).trans_lt hy) hy hy'\n    -- now massage gauss_product n (x - 1) into gauss_product (n - 1) x\n    have :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (log_gamma_seq (x - 1) n = log_gamma_seq x (n - 1) + x * (log (↑(n - 1) + 1) - log ↑(n - 1)) - log (x - 1)) :=\n      by\n      refine' eventually.mp (eventually_ge_at_top 1) (eventually_of_forall fun n hn => _)\n      have := log_gamma_seq_add_one (x - 1) (n - 1)\n      rw [sub_add_cancel, nat.sub_add_cancel hn] at this\n      rw [this]\n      ring\n    replace hm :=\n      ((tendsto.congr' this hm).add (tendsto_const_nhds : tendsto (fun _ => log (x - 1)) _ _)).comp\n        (tendsto_add_at_top_nat 1)\n    have :\n      ((fun x_1 : ℕ =>\n            (fun n : ℕ => log_gamma_seq x (n - 1) + x * (log (↑(n - 1) + 1) - log ↑(n - 1)) - log (x - 1)) x_1 +\n              (fun b : ℕ => log (x - 1)) x_1) ∘\n          fun a : ℕ => a + 1) =\n        fun n => log_gamma_seq x n + x * (log (↑n + 1) - log ↑n) :=\n      by\n      ext1 n\n      dsimp only [Function.comp_apply]\n      rw [sub_add_cancel, nat.add_sub_cancel]\n    rw [this] at hm\n    convert hm.sub (tendsto_log_nat_add_one_sub_log.const_mul x) using 2\n    · ext1 n\n      ring\n    · have := hf_feq ((Nat.cast_nonneg m).trans_lt hy)\n      rw [sub_add_cancel] at this\n      rw [this]\n      ring\n#align tendsto_log_gamma_seq tendsto_log_gamma_seq\n\n",
 "tendsto_log_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem tendsto_log_Gamma {x : exprℝ} (hx : 0 < x) : Tendsto (log_gamma_seq x) atTop (nhds <| log (Gamma x)) :=\n  by\n  have : log (Gamma x) = (log ∘ Gamma) x - (log ∘ Gamma) 1 := by\n    simp_rw [Function.comp_apply, Gamma_one, log_one, sub_zero]\n  rw [this]\n  refine' bohr_mollerup.tendsto_log_gamma_seq convex_on_log_Gamma (fun y hy => _) hx\n  rw [Function.comp_apply, Gamma_add_one hy.ne', log_mul hy.ne' (Gamma_pos_of_pos hy).ne', add_comm]\n#align tendsto_log_Gamma tendsto_log_Gamma\n\n",
 "partial_Gamma_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The recurrence relation for the indefinite version of the `Γ` function. -/\ntheorem partial_Gamma_add_one {s : exprℂ} (hs : 0 < s.re) {X : exprℝ} (hX : 0 ≤ X) :\n    partial_Gamma (s + 1) X = s * partial_Gamma s X - (-X).exp * X ^ s :=\n  by\n  rw [partial_Gamma, partial_Gamma, add_sub_cancel]\n  have F_der_I :\n    ∀ x : exprℝ,\n      x ∈ Ioo 0 X →\n        has_deriv_at (fun x => (-x).exp * x ^ s : exprℝ → exprℂ) (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1)))\n          x :=\n    by\n    intro x hx\n    have d1 : has_deriv_at (fun y : exprℝ => (-y).exp) (-(-x).exp) x := by simpa using (has_deriv_at_neg x).exp\n    have d2 : has_deriv_at (fun y : exprℝ => ↑y ^ s) (s * x ^ (s - 1)) x :=\n      by\n      have t := @has_deriv_at.cpow_const _ _ _ s (has_deriv_at_id ↑x) _\n      simpa only [mul_one] using t.comp_of_real\n      simpa only [id.def, of_real_re, of_real_im, ne.def, eq_self_iff_true, not_true, or_false_iff, mul_one] using hx.1\n    simpa only [of_real_neg, neg_mul] using d1.of_real_comp.mul d2\n  have cont := (continuous_of_real.comp continuous_neg.exp).mul (continuous_of_real_cpow_const hs)\n  have der_ible := (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)\n  have int_eval := integral_eq_sub_of_has_deriv_at_of_le hX cont.continuous_on F_der_I der_ible\n  -- We are basically done here but manipulating the output into the right form is fiddly.\n  apply_fun fun x : exprℂ => -x  at int_eval\n  rw [interval_integral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)\n      (Gamma_integrand_deriv_integrable_B hs hX),\n    interval_integral.integral_neg, neg_add, neg_neg] at int_eval\n  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]\n  simp only [sub_left_inj, add_left_inj]\n  have :\n    (fun x => (-x).exp * (s * x ^ (s - 1)) : exprℝ → exprℂ) = (fun x => s * (-x).exp * x ^ (s - 1) : exprℝ → exprℂ) :=\n    by\n    ext1\n    ring\n  rw [this]\n  have t := @integral_const_mul 0 X volume _ _ s fun x : exprℝ => (-x).exp * x ^ (s - 1)\n  dsimp at t\n  rw [← t, of_real_zero, zero_cpow]\n  · rw [MulZeroClass.mul_zero, add_zero]\n    congr\n    ext1\n    ring\n  · contrapose! hs\n    rw [hs, zero_re]\n#align partial_Gamma_add_one partial_Gamma_add_one\n\n",
 "log_gamma_seq_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem log_gamma_seq_add_one (x : exprℝ) (n : ℕ) :\n    log_gamma_seq (x + 1) n = log_gamma_seq x (n + 1) + log x - (x + 1) * (log (n + 1) - log n) :=\n  by\n  dsimp only [Nat.factorial_succ, log_gamma_seq]\n  conv_rhs => rw [Finset.sum_range_succ', Nat.cast_zero, add_zero]\n  rw [Nat.cast_mul, log_mul]\n  rotate_left\n  · rw [Nat.cast_ne_zero]\n    exact nat.succ_ne_zero n\n  · rw [Nat.cast_ne_zero]\n    exact Nat.factorial_ne_zero n\n  have :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) (log (x + 1 + ↑m)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) (log (x + ↑(k + 1))) :=\n    by\n    refine' Finset.sum_congr (by rfl) fun m hm => _\n    congr 1\n    push_cast\n    abel\n  rw [← this, Nat.cast_add_one n]\n  ring\n#align log_gamma_seq_add_one log_gamma_seq_add_one\n\n",
 "loc_unif_bound_dGamma_integrand":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- A uniform bound for the `s`-derivative of the `Γ` integrand for `s` in vertical strips. -/\ntheorem loc_unif_bound_dGamma_integrand {t : exprℂ} {s1 s2 x : exprℝ} (ht1 : s1 ≤ t.re) (ht2 : t.re ≤ s2) (hx : 0 < x) :\n    «expr‖ ‖» (dGamma_integrand t x) ≤ dGamma_integrand_real s1 x + dGamma_integrand_real s2 x :=\n  by\n  rcases le_or_lt 1 x with (h | h)\n  · -- case 1 ≤ x\n    refine' le_add_of_nonneg_of_le (abs_nonneg _) _\n    rw [dGamma_integrand, dGamma_integrand_real, complex.norm_eq_abs, map_mul, abs_mul, ← Complex.ofReal_mul,\n      Complex.abs_ofReal]\n    refine' mul_le_mul_of_nonneg_left _ (abs_nonneg _)\n    rw [complex.abs_cpow_eq_rpow_re_of_pos hx]\n    refine' le_trans _ (le_abs_self _)\n    apply rpow_le_rpow_of_exponent_le h\n    rw [Complex.sub_re, Complex.one_re]\n    linarith\n  · refine' le_add_of_le_of_nonneg _ (abs_nonneg _)\n    rw [dGamma_integrand, dGamma_integrand_real, complex.norm_eq_abs, map_mul, abs_mul, ← Complex.ofReal_mul,\n      Complex.abs_ofReal]\n    refine' mul_le_mul_of_nonneg_left _ (abs_nonneg _)\n    rw [complex.abs_cpow_eq_rpow_re_of_pos hx]\n    refine' le_trans _ (le_abs_self _)\n    apply rpow_le_rpow_of_exponent_ge hx h.le\n    rw [Complex.sub_re, Complex.one_re]\n    linarith\n#align loc_unif_bound_dGamma_integrand loc_unif_bound_dGamma_integrand\n\n",
 "le_log_gamma_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem le_log_gamma_seq (hf_conv : ConvexOn (exprℝ) (Ioi 0) f)\n    (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ≤ 1) (n : ℕ) :\n    f x ≤ f 1 + x * log (n + 1) - x * log n + log_gamma_seq x n :=\n  by\n  rw [log_gamma_seq, ← add_sub_assoc, le_sub_iff_add_le, ← f_add_nat_eq (@hf_feq) hx, add_comm x]\n  refine' (f_add_nat_le hf_conv (@hf_feq) (nat.add_one_ne_zero n) hx hx').trans (le_of_eq _)\n  rw [f_nat_eq @hf_feq (by linarith : n + 1 ≠ 0), nat.add_sub_cancel, Nat.cast_add_one]\n  ring\n#align le_log_gamma_seq le_log_gamma_seq\n\n",
 "has_deriv_at_Gamma_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/-- The derivative of the `Γ` integral, at any `s ∈ ℂ` with `1 < re s`, is given by the integral\nof `exp (-x) * log x * x ^ (s - 1)` over `[0, ∞)`. -/\ntheorem has_deriv_at_Gamma_integral {s : exprℂ} (hs : 1 < s.re) :\n    integrable_on (fun x => Real.exp (-x) * real.log x * x ^ (s - 1) : exprℝ → exprℂ) (Ioi 0) volume ∧\n      has_deriv_at Gamma_integral\n        («expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" (Ioi 0)\n          (Real.exp (-x) * real.log x * x ^ (s - 1)))\n        s :=\n  by\n  let ε := (s.re - 1) / 2\n  let μ := volume.restrict (Ioi (0 : exprℝ))\n  let bound := fun x : exprℝ => dGamma_integrand_real (s.re - ε) x + dGamma_integrand_real (s.re + ε) x\n  have cont : ∀ t : exprℂ, ContinuousOn (fun x => Real.exp (-x) * x ^ (t - 1) : exprℝ → exprℂ) (Ioi 0) :=\n    by\n    intro t\n    apply (continuous_of_real.comp continuous_neg.exp).continuous_on.mul\n    apply ContinuousAt.continuousOn\n    intro x hx\n    refine' (continuous_at_cpow_const _).comp continuous_of_real.continuous_at\n    exact or.inl hx\n  have eps_pos : 0 < ε := div_pos (sub_pos.mpr hs) zero_lt_two\n  have hF_meas :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" ((nhds) s)\n      (ae_strongly_measurable (fun x => Real.exp (-x) * x ^ (t - 1) : exprℝ → exprℂ) μ) :=\n    by\n    apply eventually_of_forall\n    intro t\n    exact (cont t).ae_strongly_measurable measurable_set_Ioi\n  have hF'_meas : ae_strongly_measurable (dGamma_integrand s) μ :=\n    by\n    refine' continuous_on.ae_strongly_measurable _ measurable_set_Ioi\n    have : dGamma_integrand s = (fun x => Real.exp (-x) * x ^ (s - 1) * real.log x : exprℝ → exprℂ) :=\n      by\n      ext1\n      simp only [dGamma_integrand]\n      ring\n    rw [this]\n    refine' ContinuousOn.mul (cont s) (ContinuousAt.continuousOn _)\n    exact fun x hx => continuous_of_real.continuous_at.comp (continuous_at_log (mem_Ioi.mp hx).ne')\n  have h_bound :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ t : exprℂ, t ∈ Metric.ball s ε → «expr‖ ‖» (dGamma_integrand t x) ≤ bound x) :=\n    by\n    refine' (ae_restrict_iff' measurable_set_Ioi).mpr (ae_of_all _ fun x hx => _)\n    intro t ht\n    rw [Metric.mem_ball, complex.dist_eq] at ht\n    replace ht := lt_of_le_of_lt (Complex.abs_re_le_abs <| t - s) ht\n    rw [Complex.sub_re, @abs_sub_lt_iff (exprℝ) _ t.re s.re ((s.re - 1) / 2)] at ht\n    refine' loc_unif_bound_dGamma_integrand _ _ hx\n    all_goals simp only [ε]; linarith\n  have bound_integrable : integrable bound μ := by\n    apply integrable.add\n    · refine' dGamma_integral_abs_convergent (s.re - ε) _\n      field_simp\n      rw [one_lt_div]\n      · linarith\n      · exact zero_lt_two\n    · refine' dGamma_integral_abs_convergent (s.re + ε) _\n      linarith\n  have h_diff :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ t : exprℂ,\n        t ∈ Metric.ball s ε →\n          has_deriv_at (fun u => Real.exp (-x) * x ^ (u - 1) : exprℂ → exprℂ) (dGamma_integrand t x) t) :=\n    by\n    refine' (ae_restrict_iff' measurable_set_Ioi).mpr (ae_of_all _ fun x hx => _)\n    intro t ht\n    rw [mem_Ioi] at hx\n    simp only [dGamma_integrand]\n    rw [mul_assoc]\n    apply has_deriv_at.const_mul\n    rw [of_real_log hx.le, mul_comm]\n    have := ((has_deriv_at_id t).sub_const 1).const_cpow (or.inl (of_real_ne_zero.mpr hx.ne'))\n    rwa [mul_one] at this\n  exact\n    has_deriv_at_integral_of_dominated_loc_of_deriv_le eps_pos hF_meas\n      (Gamma_integral_convergent (zero_lt_one.trans hs)) hF'_meas h_bound bound_integrable h_diff\n#align has_deriv_at_Gamma_integral has_deriv_at_Gamma_integral\n\n",
 "ge_log_gamma_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ge_log_gamma_seq (hf_conv : ConvexOn (exprℝ) (Ioi 0) f)\n    (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hn : n ≠ 0) :\n    f 1 + log_gamma_seq x n ≤ f x := by\n  dsimp [log_gamma_seq]\n  rw [← add_sub_assoc, sub_le_iff_le_add, ← f_add_nat_eq (@hf_feq) hx, add_comm x _]\n  refine' le_trans (le_of_eq _) (f_add_nat_ge hf_conv @hf_feq _ hx)\n  · rw [f_nat_eq @hf_feq, nat.add_sub_cancel, Nat.cast_add_one, add_sub_cancel]\n    · ring\n    · exact nat.succ_ne_zero _\n  · apply nat.succ_le_succ\n    linarith [nat.pos_of_ne_zero hn]\n#align ge_log_gamma_seq ge_log_gamma_seq\n\n",
 "f_nat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem f_nat_eq (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y) (hn : n ≠ 0) :\n    f n = f 1 + log (nat.factorial (n - 1)) :=\n  by\n  refine' Nat.le_induction (by simp) (fun m hm IH => _) n (Nat.one_le_iff_ne_zero.2 hn)\n  have A : 0 < (m : exprℝ) := Nat.cast_pos.2 hm\n  simp only [hf_feq A, Nat.cast_add, algebraMap.coe_one, Nat.add_succ_sub_one, add_zero]\n  rw [IH, add_assoc, ← log_mul (nat.cast_ne_zero.mpr (Nat.factorial_ne_zero _)) A.ne', ← Nat.cast_mul]\n  conv_rhs => rw [← nat.succ_pred_eq_of_pos hm, Nat.factorial_succ, mul_comm]\n  congr\n  exact (nat.succ_pred_eq_of_pos hm).symm\n#align f_nat_eq f_nat_eq\n\n",
 "f_add_nat_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Linear upper bound for `f (x + n)` on unit interval -/\ntheorem f_add_nat_le (hf_conv : ConvexOn (exprℝ) (Ioi 0) f) (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y)\n    (hn : n ≠ 0) (hx : 0 < x) (hx' : x ≤ 1) : f (n + x) ≤ f n + x * log n :=\n  by\n  have hn' : 0 < (n : exprℝ) := nat.cast_pos.mpr (nat.pos_of_ne_zero hn)\n  have : f n + x * log n = (1 - x) * f n + x * f (n + 1) :=\n    by\n    rw [hf_feq hn']\n    ring\n  rw [this, (by ring : (n : exprℝ) + x = (1 - x) * n + x * (n + 1))]\n  simpa only [smul_eq_mul] using\n    hf_conv.2 hn' (by linarith : 0 < (n + 1 : exprℝ)) (by linarith : 0 ≤ 1 - x) hx.le (by linarith)\n#align f_add_nat_le f_add_nat_le\n\n",
 "f_add_nat_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem f_add_nat_ge (hf_conv : ConvexOn (exprℝ) (Ioi 0) f) (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y)\n    (hn : 2 ≤ n) (hx : 0 < x) : f n + x * log (n - 1) ≤ f (n + x) :=\n  by\n  have npos : 0 < (n : exprℝ) - 1 := by\n    rw [← Nat.cast_one, sub_pos, Nat.cast_lt]\n    linarith\n  have c :=\n    (convex_on_iff_slope_mono_adjacent.mp <| hf_conv).2 npos (by linarith : 0 < (n : exprℝ) + x)\n      (by linarith : (n : exprℝ) - 1 < (n : exprℝ)) (by linarith)\n  rw [add_sub_cancel', sub_sub_cancel, div_one] at c\n  have : f (↑n - 1) = f n - log (↑n - 1) :=\n    by\n    nth_rw_rhs 1 [(by ring : (n : exprℝ) = ↑n - 1 + 1)]\n    rw [hf_feq npos, add_sub_cancel]\n  rwa [this, le_div_iff hx, sub_sub_cancel, le_sub_iff_add_le, mul_comm _ x, add_comm] at c\n#align f_add_nat_ge f_add_nat_ge\n\n",
 "f_add_nat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem f_add_nat_eq (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (n : ℕ) :\n    f (x + n) =\n      f x +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (log (x + m)) :=\n  by\n  induction' n with n hn\n  · simp\n  · have : x + n.succ = x + n + 1 := by\n      push_cast\n      ring\n    rw [this, hf_feq, hn]\n    rw [Finset.range_succ, Finset.sum_insert Finset.not_mem_range_self]\n    abel\n    linarith [(Nat.cast_nonneg n : 0 ≤ (n : exprℝ))]\n#align f_add_nat_eq f_add_nat_eq\n\n",
 "eq_Gamma_of_log_convex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- (namespace)\n/-- The **Bohr-Mollerup theorem**: the Gamma function is the *unique* log-convex, positive-valued\nfunction on the positive reals which satisfies `f 1 = 1` and `f (x + 1) = x * f x` for all `x`. -/\ntheorem eq_Gamma_of_log_convex {f : exprℝ → exprℝ} (hf_conv : ConvexOn (exprℝ) (Ioi 0) (log ∘ f))\n    (hf_feq : ∀ {y : exprℝ}, 0 < y → f (y + 1) = y * f y) (hf_pos : ∀ {y : exprℝ}, 0 < y → 0 < f y) (hf_one : f 1 = 1) :\n    EqOn f Gamma (Ioi (0 : exprℝ)) :=\n  by\n  suffices : eq_on (log ∘ f) (log ∘ Gamma) (Ioi (0 : exprℝ))\n  exact fun x hx => log_inj_on_pos (hf_pos hx) (Gamma_pos_of_pos hx) (this hx)\n  intro x hx\n  have e1 := bohr_mollerup.tendsto_log_gamma_seq hf_conv _ hx\n  · rw [Function.comp_apply log f 1, hf_one, log_one, sub_zero] at e1\n    exact tendsto_nhds_unique e1 (bohr_mollerup.tendsto_log_Gamma hx)\n  · intro y hy\n    rw [Function.comp_apply, hf_feq hy, log_mul hy.ne' (hf_pos hy).ne']\n    ring\n#align eq_Gamma_of_log_convex eq_Gamma_of_log_convex\n\n",
 "differentiable_at_Gamma_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem differentiable_at_Gamma_aux (s : exprℂ) (n : ℕ) (h1 : 1 - s.re < n) (h2 : ∀ m : ℕ, s ≠ -m) :\n    differentiable_at (exprℂ) (Gamma_aux n) s :=\n  by\n  induction' n with n hn generalizing s\n  · refine' (has_deriv_at_Gamma_integral _).2.differentiable_at\n    rw [Nat.cast_zero] at h1\n    linarith\n  · dsimp only [Gamma_aux]\n    specialize hn (s + 1)\n    have a : 1 - (s + 1).re < ↑n := by\n      rw [Nat.cast_succ] at h1\n      rw [Complex.add_re, Complex.one_re]\n      linarith\n    have b : ∀ m : ℕ, s + 1 ≠ -m := by\n      intro m\n      have := h2 (1 + m)\n      contrapose! this\n      rw [← eq_sub_iff_add_eq] at this\n      simpa using this\n    refine' differentiable_at.div (differentiable_at.comp _ (hn a b) _) _ _\n    simp\n    simp\n    simpa using h2 0\n#align differentiable_at_Gamma_aux differentiable_at_Gamma_aux\n\n",
 "differentiable_at_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem differentiable_at_Gamma {s : exprℝ} (hs : ∀ m : ℕ, s ≠ -m) : differentiable_at (exprℝ) Gamma s :=\n  by\n  refine' (complex.differentiable_at_Gamma _ _).has_deriv_at.real_of_complex.differentiable_at\n  simp_rw [← Complex.ofReal_nat_cast, ← Complex.ofReal_neg, ne.def, Complex.ofReal_inj]\n  exact hs\n#align differentiable_at_Gamma differentiable_at_Gamma\n\n",
 "dGamma_integrand_is_o_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem dGamma_integrand_is_o_at_top (s : exprℝ) :\n    «expr =o[ ] » (fun x : exprℝ => exp (-x) * log x * x ^ (s - 1)) atTop fun x => exp (-(1 / 2) * x) :=\n  by\n  refine' is_o_of_tendsto (fun x hx => _) _\n  · exfalso\n    exact (-(1 / 2) * x).exp_pos.ne' hx\n  have :\n    eventually_eq at_top (fun x : exprℝ => exp (-x) * log x * x ^ (s - 1) / exp (-(1 / 2) * x))\n      (fun x : exprℝ => (fun z : exprℝ => exp (1 / 2 * z) / z ^ s) x * (fun z : exprℝ => z / log z) x)⁻¹ :=\n    by\n    refine' eventually_of_mem (Ioi_mem_at_top 1) _\n    intro x hx\n    dsimp\n    replace hx := lt_trans zero_lt_one (mem_Ioi.mp hx)\n    rw [Real.exp_neg, neg_mul, Real.exp_neg, rpow_sub hx]\n    have : exp x = exp (x / 2) * exp (x / 2) := by rw [← Real.exp_add, add_halves]\n    rw [this]\n    field_simp [hx.ne', exp_ne_zero (x / 2)]\n    ring\n  refine' tendsto.congr' this.symm (tendsto.inv_tendsto_at_top _)\n  apply tendsto.at_top_mul_at_top (tendsto_exp_mul_div_rpow_at_top s (1 / 2) one_half_pos)\n  refine' tendsto.congr' _ ((tendsto_exp_div_pow_at_top 1).comp tendsto_log_at_top)\n  apply eventually_eq_of_mem (Ioi_mem_at_top (0 : exprℝ))\n  intro x hx\n  simp [exp_log hx]\n#align dGamma_integrand_is_o_at_top dGamma_integrand_is_o_at_top\n\n",
 "dGamma_integral_abs_convergent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/-- Absolute convergence of the integral which will give the derivative of the `Γ` function on\n`1 < re s`. -/\ntheorem dGamma_integral_abs_convergent (s : exprℝ) (hs : 1 < s) :\n    integrable_on (fun x : exprℝ => «expr‖ ‖» (exp (-x) * log x * x ^ (s - 1))) (Ioi 0) :=\n  by\n  rw [← Ioc_union_Ioi_eq_Ioi (@zero_le_one (exprℝ) _ _ _ _), integrable_on_union]\n  refine' ⟨⟨_, _⟩, _⟩\n  · refine' continuous_on.ae_strongly_measurable (ContinuousOn.mul _ _).norm measurable_set_Ioc\n    · refine' (continuous_exp.comp continuous_neg).continuous_on.mul (continuous_on_log.mono _)\n      simp\n    · apply continuous_on_id.rpow_const\n      intro x hx\n      right\n      linarith\n  · apply has_finite_integral_of_bounded\n    swap\n    · exact 1 / (s - 1)\n    refine' (ae_restrict_iff' measurable_set_Ioc).mpr (ae_of_all _ fun x hx => _)\n    rw [norm_norm, norm_eq_abs, mul_assoc, abs_mul, ← one_mul (1 / (s - 1))]\n    refine' mul_le_mul _ _ (abs_nonneg _) zero_le_one\n    · rw [abs_of_pos (exp_pos (-x)), exp_le_one_iff, neg_le, neg_zero]\n      exact hx.1.le\n    · exact (abs_log_mul_self_rpow_lt x (s - 1) hx.1 hx.2 (sub_pos.mpr hs)).le\n  · have := (dGamma_integrand_is_o_at_top s).is_O.norm_left\n    refine' integrable_of_is_O_exp_neg one_half_pos (ContinuousOn.mul _ _).norm this\n    · refine' (continuous_exp.comp continuous_neg).continuous_on.mul (continuous_on_log.mono _)\n      simp\n    · apply ContinuousAt.continuousOn fun x hx => _\n      apply continuous_at_id.rpow continuousAt_const\n      dsimp\n      right\n      linarith\n#align dGamma_integral_abs_convergent dGamma_integral_abs_convergent\n\n",
 "convex_on_log_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem convex_on_log_Gamma : ConvexOn (exprℝ) (Ioi 0) (log ∘ Gamma) :=\n  by\n  refine' convex_on_iff_forall_pos.mpr ⟨convex_Ioi _, fun x hx y hy a b ha hb hab => _⟩\n  have : b = 1 - a := by linarith; subst this\n  simp_rw [Function.comp_apply, smul_eq_mul]\n  rw [← log_rpow (Gamma_pos_of_pos hy), ← log_rpow (Gamma_pos_of_pos hx), ←\n    log_mul (rpow_pos_of_pos (Gamma_pos_of_pos hx) _).ne' (rpow_pos_of_pos (Gamma_pos_of_pos hy) _).ne',\n    log_le_log (Gamma_pos_of_pos (add_pos (mul_pos ha hx) (mul_pos hb hy)))\n      (mul_pos (rpow_pos_of_pos (Gamma_pos_of_pos hx) _) (rpow_pos_of_pos (Gamma_pos_of_pos hy) _))]\n  exact Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma hx hy ha hb hab\n#align convex_on_log_Gamma convex_on_log_Gamma\n\n",
 "convex_on_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem convex_on_Gamma : ConvexOn (exprℝ) (Ioi 0) Gamma :=\n  by\n  refine' ⟨convex_Ioi 0, fun x hx y hy a b ha hb hab => _⟩\n  have :=\n    ConvexOn.comp (convex_on_exp.subset (subset_univ _) _) convex_on_log_Gamma fun u hu v hv huv => exp_le_exp.mpr huv\n  convert this.2 hx hy ha hb hab\n  · rw [Function.comp_apply, exp_log (Gamma_pos_of_pos <| this.1 hx hy ha hb hab)]\n  · rw [Function.comp_apply, exp_log (Gamma_pos_of_pos hx)]\n  · rw [Function.comp_apply, exp_log (Gamma_pos_of_pos hy)]\n  · rw [convex_iff_is_preconnected]\n    refine' is_preconnected_Ioi.image _ fun x hx => ContinuousAt.continuousWithinAt _\n    refine' (differentiable_at_Gamma fun m => _).continuous_at.log (Gamma_pos_of_pos hx).ne'\n    exact (neg_lt_iff_pos_add.mpr (add_pos_of_pos_of_nonneg hx (Nat.cast_nonneg m))).ne'\n#align convex_on_Gamma convex_on_Gamma\n\n",
 "beta_integral_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem beta_integral_symm (u v : exprℂ) : beta_integral v u = beta_integral u v :=\n  by\n  rw [beta_integral, beta_integral]\n  have :=\n    interval_integral.integral_comp_mul_add (fun x : exprℝ => (x : exprℂ) ^ (u - 1) * (1 - ↑x) ^ (v - 1))\n      neg_one_lt_zero.ne 1\n  rw [inv_neg, inv_one, neg_one_smul, ← interval_integral.integral_symm] at this\n  convert this\n  · ext1 x\n    rw [mul_comm]\n    congr <;>\n      · push_cast\n        ring\n  · ring; · ring\n#align beta_integral_symm beta_integral_symm\n\n",
 "beta_integral_scaled":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem beta_integral_scaled (s t : exprℂ) {a : exprℝ} (ha : 0 < a) :\n    «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0 a\n        ((x : exprℂ) ^ (s - 1) * (a - x) ^ (t - 1)) =\n      a ^ (s + t - 1) * beta_integral s t :=\n  by\n  have ha' : (a : exprℂ) ≠ 0 := of_real_ne_zero.mpr ha.ne'\n  rw [beta_integral]\n  have A : (a : exprℂ) ^ (s + t - 1) = a * (a ^ (s - 1) * a ^ (t - 1)) := by\n    rw [(by abel : s + t - 1 = 1 + (s - 1) + (t - 1)), cpow_add _ _ ha', cpow_add 1 _ ha', cpow_one, mul_assoc]\n  rw [A, mul_assoc, ← interval_integral.integral_const_mul (↑a ^ _ * _), ← real_smul, ← zero_div a, ← div_self ha.ne', ←\n    interval_integral.integral_comp_div _ ha.ne', zero_div]\n  simp_rw [interval_integral.integral_of_le ha.le]\n  refine' set_integral_congr measurable_set_Ioc fun x hx => _\n  dsimp only\n  rw [mul_mul_mul_comm]\n  congr 1\n  · rw [← mul_cpow_of_real_nonneg ha.le (div_pos hx.1 ha).le, of_real_div, mul_div_cancel' _ ha']\n  · rw [(by push_cast : (1 : exprℂ) - ↑(x / a) = ↑(1 - x / a)), ←\n      mul_cpow_of_real_nonneg ha.le (sub_nonneg.mpr <| (div_le_one ha).mpr hx.2)]\n    push_cast\n    rw [mul_sub, mul_one, mul_div_cancel' _ ha']\n#align beta_integral_scaled beta_integral_scaled\n\n",
 "beta_integral_recurrence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- Recurrence formula for the Beta function. -/\ntheorem beta_integral_recurrence {u v : exprℂ} (hu : 0 < re u) (hv : 0 < re v) :\n    u * beta_integral u (v + 1) = v * beta_integral (u + 1) v :=\n  by\n  -- NB: If we knew `Gamma (u + v + 1) ≠ 0` this would be an easy consequence of\n  -- `Gamma_mul_Gamma_eq_beta_integral`; but we don't know that yet. We will prove it later, but\n  -- this lemma is needed in the proof. So we give a (somewhat laborious) direct argument.\n  let F : exprℝ → exprℂ := fun x => x ^ u * (1 - x) ^ v\n  have hu' : 0 < re (u + 1) := by\n    rw [add_re, one_re]\n    positivity\n  have hv' : 0 < re (v + 1) := by\n    rw [add_re, one_re]\n    positivity\n  have hc : ContinuousOn F (Icc 0 1) :=\n    by\n    refine' (ContinuousAt.continuousOn fun x hx => _).mul (ContinuousAt.continuousOn fun x hx => _)\n    · refine' (continuous_at_cpow_const_of_re_pos (or.inl _) hu).comp continuous_of_real.continuous_at\n      rw [of_real_re]\n      exact hx.1\n    · refine'\n        (continuous_at_cpow_const_of_re_pos (or.inl _) hv).comp (continuous_const.sub continuous_of_real).continuous_at\n      rw [sub_re, one_re, of_real_re, sub_nonneg]\n      exact hx.2\n  have hder :\n    ∀ x : exprℝ,\n      x ∈ Ioo (0 : exprℝ) 1 →\n        has_deriv_at F (u * (↑x ^ (u - 1) * (1 - ↑x) ^ v) - v * (↑x ^ u * (1 - ↑x) ^ (v - 1))) x :=\n    by\n    intro x hx\n    have U : has_deriv_at (fun y : exprℂ => y ^ u) (u * ↑x ^ (u - 1)) ↑x :=\n      by\n      have := has_deriv_at.cpow_const (has_deriv_at_id ↑x) (or.inl _)\n      · rw [mul_one] at this\n        exact this\n      · rw [id.def, of_real_re]\n        exact hx.1\n    have V : has_deriv_at (fun y : exprℂ => (1 - y) ^ v) (-v * (1 - ↑x) ^ (v - 1)) ↑x :=\n      by\n      have A := has_deriv_at.cpow_const (has_deriv_at_id (1 - ↑x)) (or.inl _)\n      rotate_left\n      · exact v\n      · rw [id.def, sub_re, one_re, of_real_re, sub_pos]\n        exact hx.2\n      simp_rw [id.def] at A\n      have B : has_deriv_at (fun y : exprℂ => 1 - y) (-1) ↑x :=\n        by\n        apply has_deriv_at.const_sub\n        apply has_deriv_at_id\n      convert has_deriv_at.comp (↑x) A B using 1\n      ring\n    convert(U.mul V).comp_of_real\n    ring\n  have h_int := ((beta_integral_convergent hu hv').const_mul u).sub ((beta_integral_convergent hu' hv).const_mul v)\n  dsimp only at h_int\n  rw [add_sub_cancel, add_sub_cancel] at h_int\n  have int_ev := interval_integral.integral_eq_sub_of_has_deriv_at_of_le zero_le_one hc hder h_int\n  have hF0 : F 0 = 0 :=\n    by\n    simp only [mul_eq_zero, of_real_zero, cpow_eq_zero_iff, eq_self_iff_true, ne.def, true_and_iff, sub_zero, one_cpow,\n      one_ne_zero, or_false_iff]\n    contrapose! hu\n    rw [hu, zero_re]\n  have hF1 : F 1 = 0 :=\n    by\n    simp only [mul_eq_zero, of_real_one, one_cpow, one_ne_zero, sub_self, cpow_eq_zero_iff, eq_self_iff_true, ne.def,\n      true_and_iff, false_or_iff]\n    contrapose! hv\n    rw [hv, zero_re]\n  rw [hF0, hF1, sub_zero, interval_integral.integral_sub, interval_integral.integral_const_mul,\n    interval_integral.integral_const_mul] at int_ev\n  · rw [beta_integral, beta_integral, ← sub_eq_zero]\n    convert int_ev <;>\n      · ext1 x\n        congr\n        abel\n  · apply interval_integrable.const_mul\n    convert beta_integral_convergent hu hv'\n    ext1 x\n    rw [add_sub_cancel]\n  · apply interval_integrable.const_mul\n    convert beta_integral_convergent hu' hv\n    ext1 x\n    rw [add_sub_cancel]\n#align beta_integral_recurrence beta_integral_recurrence\n\n",
 "beta_integral_eval_one_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem beta_integral_eval_one_right {u : exprℂ} (hu : 0 < re u) : beta_integral u 1 = 1 / u :=\n  by\n  simp_rw [beta_integral, sub_self, cpow_zero, mul_one]\n  rw [integral_cpow (or.inl _)]\n  · rw [of_real_zero, of_real_one, one_cpow, zero_cpow, sub_zero, sub_add_cancel]\n    rw [sub_add_cancel]\n    contrapose! hu\n    rw [hu, zero_re]\n  · rwa [sub_re, one_re, ← sub_pos, sub_neg_eq_add, sub_add_cancel]\n#align beta_integral_eval_one_right beta_integral_eval_one_right\n\n",
 "beta_integral_eval_nat_add_one_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Explicit formula for the Beta function when second argument is a positive integer. -/\ntheorem beta_integral_eval_nat_add_one_right {u : exprℂ} (hu : 0 < re u) (n : ℕ) :\n    beta_integral u (n + 1) =\n      nat.factorial n /\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (Finset.range (n + 1)) (u + j) :=\n  by\n  induction' n with n IH generalizing u\n  ·\n    rw [Nat.cast_zero, zero_add, beta_integral_eval_one_right hu, Nat.factorial_zero, Nat.cast_one, zero_add,\n      Finset.prod_range_one, Nat.cast_zero, add_zero]\n  · have := beta_integral_recurrence hu (_ : 0 < re n.succ)\n    swap\n    · rw [← of_real_nat_cast, of_real_re]\n      positivity\n    rw [mul_comm u _, ← eq_div_iff] at this\n    swap\n    · contrapose! hu\n      rw [hu, zero_re]\n    rw [this, Finset.prod_range_succ', Nat.cast_succ, IH]\n    swap\n    · rw [add_re, one_re]\n      positivity\n    rw [Nat.factorial_succ, Nat.cast_mul, Nat.cast_add, Nat.cast_one, Nat.cast_zero, add_zero, ← mul_div_assoc, ←\n      div_div]\n    congr 3 with j : 1\n    push_cast\n    abel\n#align beta_integral_eval_nat_add_one_right beta_integral_eval_nat_add_one_right\n\n",
 "beta_integral_convergent_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- Auxiliary lemma for `beta_integral_convergent`, showing convergence at the left endpoint. -/\ntheorem beta_integral_convergent_left {u : exprℂ} (hu : 0 < re u) (v : exprℂ) :\n    interval_integrable (fun x => x ^ (u - 1) * (1 - x) ^ (v - 1) : exprℝ → exprℂ) volume 0 (1 / 2) :=\n  by\n  apply interval_integrable.mul_continuous_on\n  · refine' interval_integral.interval_integrable_cpow' _\n    rwa [sub_re, one_re, ← zero_sub, sub_lt_sub_iff_right]\n  · apply ContinuousAt.continuousOn\n    intro x hx\n    rw [uIcc_of_le (by positivity : (0 : exprℝ) ≤ 1 / 2)] at hx\n    apply continuous_at.cpow\n    · exact (continuous_const.sub continuous_of_real).continuous_at\n    · exact continuousAt_const\n    · rw [sub_re, one_re, of_real_re, sub_pos]\n      exact or.inl (hx.2.trans_lt (by norm_num : (1 / 2 : exprℝ) < 1))\n#align beta_integral_convergent_left beta_integral_convergent_left\n\n",
 "beta_integral_convergent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The Beta integral is convergent for all `u, v` of positive real part. -/\ntheorem beta_integral_convergent {u v : exprℂ} (hu : 0 < re u) (hv : 0 < re v) :\n    interval_integrable (fun x => x ^ (u - 1) * (1 - x) ^ (v - 1) : exprℝ → exprℂ) volume 0 1 :=\n  by\n  refine' (beta_integral_convergent_left hu v).trans _\n  rw [interval_integrable.iff_comp_neg]\n  convert((beta_integral_convergent_left hv u).comp_add_right 1).symm\n  · ext1 x\n    conv_lhs => rw [mul_comm]\n    congr 2 <;>\n      · push_cast\n        ring\n  · norm_num\n  · norm_num\n#align beta_integral_convergent beta_integral_convergent\n\n",
 "approx_Gamma_integral_tendsto_Gamma_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- The main techical lemma for `Gamma_seq_tendsto_Gamma`, expressing the integral defining the\nGamma function for `0 < re s` as the limit of a sequence of integrals over finite intervals. -/\ntheorem approx_Gamma_integral_tendsto_Gamma_integral {s : exprℂ} (hs : 0 < re s) :\n    Tendsto\n      (fun n : ℕ =>\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0 n\n          (↑((1 - x / n) ^ n) * (x : exprℂ) ^ (s - 1)))\n      atTop (nhds <| Gamma s) :=\n  by\n  rw [Gamma_eq_integral hs]\n  -- We apply dominated convergence to the following function, which we will show is uniformly\n  -- bounded above by the Gamma integrand `exp (-x) * x ^ (re s - 1)`.\n  let f : ℕ → exprℝ → exprℂ := fun n =>\n    indicator (Ioc 0 (n : exprℝ)) fun x : exprℝ => ↑((1 - x / n) ^ n) * (x : exprℂ) ^ (s - 1)\n  -- integrability of f\n  have f_ible : ∀ n : ℕ, integrable (f n) (volume.restrict (Ioi 0)) :=\n    by\n    intro n\n    rw [integrable_indicator_iff (measurable_set_Ioc : MeasurableSet (Ioc (_ : exprℝ) _)), integrable_on,\n      measure.restrict_restrict_of_subset Ioc_subset_Ioi_self, ← integrable_on, ←\n      interval_integrable_iff_integrable_Ioc_of_le (by positivity : (0 : exprℝ) ≤ n)]\n    apply interval_integrable.continuous_on_mul\n    · refine' interval_integral.interval_integrable_cpow' _\n      rwa [sub_re, one_re, ← zero_sub, sub_lt_sub_iff_right]\n    · apply Continuous.continuousOn\n      continuity\n  -- pointwise limit of f\n  have f_tends :\n    ∀ x : exprℝ,\n      x ∈ Ioi (0 : exprℝ) → tendsto (fun n : ℕ => f n x) at_top (nhds <| ↑(Real.exp (-x)) * (x : exprℂ) ^ (s - 1)) :=\n    by\n    intro x hx\n    apply tendsto.congr'\n    show\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" at_top\n        (↑((1 - x / n) ^ n) * (x : exprℂ) ^ (s - 1) = f n x)\n    · refine' eventually.mp (eventually_ge_at_top («expr⌈ ⌉₊» x)) (eventually_of_forall fun n hn => _)\n      rw [Nat.ceil_le] at hn\n      dsimp only [f]\n      rw [indicator_of_mem]\n      exact ⟨hx, hn⟩\n    · simp_rw [mul_comm _ (↑x ^ _)]\n      refine' (tendsto.comp (continuous_of_real.tendsto _) _).const_mul _\n      convert tendsto_one_plus_div_pow_exp (-x)\n      ext1 n\n      rw [neg_div, ← sub_eq_add_neg]\n  -- let `convert` identify the remaining goals\n  convert tendsto_integral_of_dominated_convergence _ (fun n => (f_ible n).1) (real.Gamma_integral_convergent hs) _\n      ((ae_restrict_iff' measurable_set_Ioi).mpr (ae_of_all _ f_tends))\n  -- limit of f is the integrand we want\n  · ext1 n\n    rw [integral_indicator (measurable_set_Ioc : MeasurableSet (Ioc (_ : exprℝ) _)),\n      interval_integral.integral_of_le (by positivity : 0 ≤ (n : exprℝ)),\n      measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]\n  -- f is uniformly bounded by the Gamma integrand\n  · intro n\n    refine' (ae_restrict_iff' measurable_set_Ioi).mpr (ae_of_all _ fun x hx => _)\n    dsimp only [f]\n    rcases lt_or_le (n : exprℝ) x with (hxn | hxn)\n    · rw [indicator_of_not_mem (not_mem_Ioc_of_gt hxn), norm_zero, mul_nonneg_iff_right_nonneg_of_pos (exp_pos _)]\n      exact rpow_nonneg_of_nonneg (le_of_lt hx) _\n    · rw [indicator_of_mem (mem_Ioc.mpr ⟨hx, hxn⟩), norm_mul, complex.norm_eq_abs,\n        Complex.abs_of_nonneg (pow_nonneg (sub_nonneg.mpr <| div_le_one_of_le hxn <| by positivity) _),\n        complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hx, sub_re, one_re, mul_le_mul_right (rpow_pos_of_pos hx _)]\n      exact one_sub_div_pow_le_exp_neg hxn\n#align approx_Gamma_integral_tendsto_Gamma_integral approx_Gamma_integral_tendsto_Gamma_integral\n\n",
 "Gamma_zero":
 "/-- At `0` the Gamma function is undefined; by convention we assign it the value `0`. -/\ntheorem Gamma_zero : Gamma 0 = 0 := by\n  simpa only [← Complex.ofReal_zero, complex.Gamma_of_real, Complex.ofReal_inj] using complex.Gamma_zero\n#align Gamma_zero Gamma_zero\n\n",
 "Gamma_two":
 "-- (section)\ntheorem Gamma_two : Gamma 2 = 1 := by simpa using Gamma_nat_eq_factorial 1\n#align Gamma_two Gamma_two\n\n",
 "Gamma_three_div_two_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Gamma_three_div_two_lt_one : Gamma (3 / 2) < 1 :=\n  by\n  -- This can also be proved using the closed-form evaluation of `Gamma (1 / 2)` in\n  -- `analysis.special_functions.gaussian`, but we give a self-contained proof using log-convexity\n  -- to avoid unnecessary imports.\n  have A : (0 : exprℝ) < 3 / 2 := by norm_num\n  have :=\n    bohr_mollerup.f_add_nat_le convex_on_log_Gamma (fun y hy => _) two_ne_zero one_half_pos\n      (by norm_num : 1 / 2 ≤ (1 : exprℝ))\n  swap\n  · rw [Function.comp_apply, Gamma_add_one hy.ne', log_mul hy.ne' (Gamma_pos_of_pos hy).ne', add_comm]\n  rw [Function.comp_apply, Function.comp_apply, Nat.cast_two, Gamma_two, log_one, zero_add,\n    (by norm_num : (2 : exprℝ) + 1 / 2 = 3 / 2 + 1), Gamma_add_one A.ne', log_mul A.ne' (Gamma_pos_of_pos A).ne', ←\n    le_sub_iff_add_le', log_le_iff_le_exp (Gamma_pos_of_pos A)] at this\n  refine' this.trans_lt (exp_lt_one_iff.mpr _)\n  rw [mul_comm, ← mul_div_assoc, div_sub' _ _ (2 : exprℝ) two_ne_zero]\n  refine' div_neg_of_neg_of_pos _ two_pos\n  rw [sub_neg, mul_one, ← Nat.cast_two, ← log_pow, ← exp_lt_exp, Nat.cast_two, exp_log two_pos, exp_log] <;> norm_num\n#align Gamma_three_div_two_lt_one Gamma_three_div_two_lt_one\n\n",
 "Gamma_strict_mono_on_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Gamma_strict_mono_on_Ici : StrictMonoOn Gamma (Ici 2) :=\n  by\n  convert convex_on_Gamma.strict_mono_of_lt (by norm_num : (0 : exprℝ) < 3 / 2) (by norm_num : (3 / 2 : exprℝ) < 2)\n      (Gamma_two.symm ▸ Gamma_three_div_two_lt_one)\n  symm\n  rw [inter_eq_right_iff_subset]\n  exact fun x hx => two_pos.trans_le hx\n#align Gamma_strict_mono_on_Ici Gamma_strict_mono_on_Ici\n\n",
 "Gamma_seq_tendsto_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- Euler's limit formula for the real Gamma function. -/\ntheorem Gamma_seq_tendsto_Gamma (s : exprℝ) : Tendsto (Gamma_seq s) atTop (nhds <| Gamma s) :=\n  by\n  suffices : tendsto (coe ∘ Gamma_seq s : ℕ → exprℂ) at_top (nhds <| complex.Gamma s)\n  exact (complex.continuous_re.tendsto (complex.Gamma ↑s)).comp this\n  convert complex.Gamma_seq_tendsto_Gamma s\n  ext1 n\n  dsimp only [Gamma_seq, Function.comp_apply, complex.Gamma_seq]\n  push_cast\n  rw [complex.of_real_cpow n.cast_nonneg, Complex.ofReal_nat_cast]\n#align Gamma_seq_tendsto_Gamma Gamma_seq_tendsto_Gamma\n\n",
 "Gamma_seq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem Gamma_seq_mul (z : exprℂ) {n : ℕ} (hn : n ≠ 0) :\n    Gamma_seq z n * Gamma_seq (1 - z) n =\n      n / (n + 1 - z) *\n        (1 /\n          (z *\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n              (Finset.range n) (1 - z ^ 2 / (j + 1) ^ 2))) :=\n  by\n  -- also true for n = 0 but we don't need it\n  have aux : ∀ a b c d : exprℂ, a * b * (c * d) = a * c * (b * d) :=\n    by\n    intros\n    ring\n  rw [Gamma_seq, Gamma_seq, div_mul_div_comm, aux, ← pow_two]\n  have : (n : exprℂ) ^ z * n ^ (1 - z) = n := by\n    rw [← cpow_add _ _ (nat.cast_ne_zero.mpr hn), add_sub_cancel'_right, cpow_one]\n  rw [this, Finset.prod_range_succ', Finset.prod_range_succ, aux, ← Finset.prod_mul_distrib, Nat.cast_zero, add_zero,\n    add_comm (1 - z) n, ← add_sub_assoc]\n  have : ∀ j : ℕ, (z + ↑(j + 1)) * (1 - z + ↑j) = ↑((j + 1) ^ 2) * (1 - z ^ 2 / (↑j + 1) ^ 2) :=\n    by\n    intro j\n    push_cast\n    have : (j : exprℂ) + 1 ≠ 0 := by\n      rw [← Nat.cast_succ, Nat.cast_ne_zero]\n      exact nat.succ_ne_zero j\n    field_simp\n    ring\n  simp_rw [this]\n  rw [Finset.prod_mul_distrib, ← Nat.cast_prod, Finset.prod_pow, Finset.prod_range_add_one_eq_factorial, Nat.cast_pow,\n    (by\n      intros\n      ring : ∀ a b c d : exprℂ, a * b * (c * d) = a * (d * (b * c))),\n    ← div_div, mul_div_cancel, ← div_div, mul_comm z _, mul_one_div]\n  exact pow_ne_zero 2 (nat.cast_ne_zero.mpr <| Nat.factorial_ne_zero n)\n#align Gamma_seq_mul Gamma_seq_mul\n\n",
 "Gamma_seq_eq_beta_integral_of_re_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_seq_eq_beta_integral_of_re_pos {s : exprℂ} (hs : 0 < re s) (n : ℕ) :\n    Gamma_seq s n = n ^ s * beta_integral s (n + 1) := by\n  rw [Gamma_seq, beta_integral_eval_nat_add_one_right hs n, ← mul_div_assoc]\n#align Gamma_seq_eq_beta_integral_of_re_pos Gamma_seq_eq_beta_integral_of_re_pos\n\n",
 "Gamma_seq_eq_approx_Gamma_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_seq_eq_approx_Gamma_integral {s : exprℂ} (hs : 0 < re s) {n : ℕ} (hn : n ≠ 0) :\n    Gamma_seq s n =\n      «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0 n\n        (↑((1 - x / n) ^ n) * (x : exprℂ) ^ (s - 1)) :=\n  by\n  have : ∀ x : exprℝ, x = x / n * n := by\n    intro x\n    rw [div_mul_cancel]\n    exact nat.cast_ne_zero.mpr hn\n  conv in ↑_ ^ _ =>\n    congr\n    rw [this x]\n  rw [Gamma_seq_eq_beta_integral_of_re_pos hs]\n  rw [beta_integral,\n    @interval_integral.integral_comp_div _ _ _ _ 0 n _ (fun x => ↑((1 - x) ^ n) * ↑(x * ↑n) ^ (s - 1) : exprℝ → exprℂ)\n      (nat.cast_ne_zero.mpr hn),\n    real_smul, zero_div, div_self, add_sub_cancel, ← interval_integral.integral_const_mul, ←\n    interval_integral.integral_const_mul]\n  swap\n  · exact nat.cast_ne_zero.mpr hn\n  simp_rw [interval_integral.integral_of_le zero_le_one]\n  refine' set_integral_congr measurable_set_Ioc fun x hx => _\n  push_cast\n  have hn' : (n : exprℂ) ≠ 0 := nat.cast_ne_zero.mpr hn\n  have A : (n : exprℂ) ^ s = (n : exprℂ) ^ (s - 1) * n :=\n    by\n    conv_lhs => rw [(by ring : s = s - 1 + 1), cpow_add _ _ hn']\n    simp\n  have B : ((x : exprℂ) * ↑n) ^ (s - 1) = (x : exprℂ) ^ (s - 1) * ↑n ^ (s - 1) := by\n    rw [← of_real_nat_cast, mul_cpow_of_real_nonneg hx.1.le (nat.cast_pos.mpr (nat.pos_of_ne_zero hn)).le]\n  rw [A, B, cpow_nat_cast]\n  ring\n#align Gamma_seq_eq_approx_Gamma_integral Gamma_seq_eq_approx_Gamma_integral\n\n",
 "Gamma_seq_add_one_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_seq_add_one_left (s : exprℂ) {n : ℕ} (hn : n ≠ 0) :\n    Gamma_seq (s + 1) n / s = n / (n + 1 + s) * Gamma_seq s n :=\n  by\n  conv_lhs => rw [Gamma_seq, Finset.prod_range_succ, div_div]\n  conv_rhs =>\n    rw [Gamma_seq, Finset.prod_range_succ', Nat.cast_zero, add_zero, div_mul_div_comm, ← mul_assoc, ← mul_assoc,\n      mul_comm _ (Finset.prod _ _)]\n  congr 3\n  · rw [cpow_add _ _ (nat.cast_ne_zero.mpr hn), cpow_one, mul_comm]\n  · refine' Finset.prod_congr (by rfl) fun x hx => _\n    push_cast\n    ring\n  · abel\n#align Gamma_seq_add_one_left Gamma_seq_add_one_left\n\n",
 "Gamma_pos_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Gamma_pos_of_pos {s : exprℝ} (hs : 0 < s) : 0 < Gamma s :=\n  by\n  rw [Gamma_eq_integral hs]\n  have : (Function.support fun x : exprℝ => exp (-x) * x ^ (s - 1)) ∩ Ioi 0 = Ioi 0 :=\n    by\n    rw [inter_eq_right_iff_subset]\n    intro x hx\n    rw [Function.mem_support]\n    exact mul_ne_zero (exp_pos _).ne' (rpow_pos_of_pos hx _).ne'\n  rw [set_integral_pos_iff_support_of_nonneg_ae]\n  · rw [this, volume_Ioi, ← ENNReal.ofReal_zero]\n    exact ENNReal.ofReal_lt_top\n  · refine' eventually_of_mem (self_mem_ae_restrict measurable_set_Ioi) _\n    exact fun x hx => (mul_pos (exp_pos _) (rpow_pos_of_pos hx _)).le\n  · exact Gamma_integral_convergent hs\n#align Gamma_pos_of_pos Gamma_pos_of_pos\n\n",
 "Gamma_one":
 "theorem Gamma_one : Gamma 1 = 1 := by rw [Gamma, Complex.ofReal_one, complex.Gamma_one, Complex.one_re]\n#align Gamma_one Gamma_one\n\n",
 "Gamma_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem _root_.complex.Gamma_of_real (s : exprℝ) : complex.Gamma (s : exprℂ) = Gamma s := by\n  rw [Gamma, eq_comm, ← Complex.conj_eq_iff_re, ← complex.Gamma_conj, Complex.conj_ofReal]\n#align complex.Gamma_of_real complex.Gamma_of_real\n\n",
 "Gamma_neg_nat_eq_zero":
 "/-- At `-n` for `n ∈ ℕ`, the Gamma function is undefined; by convention we assign it the value `0`.\n-/\ntheorem Gamma_neg_nat_eq_zero (n : ℕ) : Gamma (-n) = 0 := by\n  simpa only [← Complex.ofReal_nat_cast, ← Complex.ofReal_neg, complex.Gamma_of_real, Complex.ofReal_eq_zero] using\n    complex.Gamma_neg_nat_eq_zero n\n#align Gamma_neg_nat_eq_zero Gamma_neg_nat_eq_zero\n\n",
 "Gamma_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The Gamma function does not vanish on `ℂ` (except at non-positive integers, where the function\nis mathematically undefined and we set it to `0` by convention). -/\ntheorem Gamma_ne_zero {s : exprℂ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 :=\n  by\n  by_cases h_im : s.im = 0\n  · have : s = ↑s.re := by\n      conv_lhs => rw [← Complex.re_add_im s]\n      rw [h_im, of_real_zero, MulZeroClass.zero_mul, add_zero]\n    rw [this, Gamma_of_real, of_real_ne_zero]\n    refine' real.Gamma_ne_zero fun n => _\n    specialize hs n\n    contrapose! hs\n    rwa [this, ← of_real_nat_cast, ← of_real_neg, of_real_inj]\n  · have : sin (↑(real.pi) * s) ≠ 0 := by\n      rw [complex.sin_ne_zero_iff]\n      intro k\n      apply_fun im\n      rw [of_real_mul_im, ← of_real_int_cast, ← of_real_mul, of_real_im]\n      exact mul_ne_zero real.pi_pos.ne' h_im\n    have A := div_ne_zero (of_real_ne_zero.mpr real.pi_pos.ne') this\n    rw [← complex.Gamma_mul_Gamma_one_sub s, mul_ne_zero_iff] at A\n    exact A.1\n#align Gamma_ne_zero Gamma_ne_zero\n\n",
 "Gamma_nat_eq_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem Gamma_nat_eq_factorial (n : ℕ) : Gamma (n + 1) = nat.factorial n := by\n  rw [Gamma, Complex.ofReal_add, Complex.ofReal_nat_cast, Complex.ofReal_one, complex.Gamma_nat_eq_factorial, ←\n    Complex.ofReal_nat_cast, Complex.ofReal_re]\n#align Gamma_nat_eq_factorial Gamma_nat_eq_factorial\n\n",
 "Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Log-convexity of the Gamma function on the positive reals (stated in multiplicative form),\nproved using the Hölder inequality applied to Euler's integral. -/\ntheorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : exprℝ} (hs : 0 < s) (ht : 0 < t) (ha : 0 < a)\n    (hb : 0 < b) (hab : a + b = 1) : Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b :=\n  by\n  -- We will apply Hölder's inequality, for the conjugate exponents `p = 1 / a`\n  -- and `q = 1 / b`, to the functions `f a s` and `f b t`, where `f` is as follows:\n  let f : exprℝ → exprℝ → exprℝ → exprℝ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))\n  have e : is_conjugate_exponent (1 / a) (1 / b) := Real.isConjugateExponent_one_div ha hb hab\n  have hab' : b = 1 - a := by linarith\n  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)\n  -- some properties of f:\n  have posf : ∀ c u x : exprℝ, x ∈ Ioi (0 : exprℝ) → 0 ≤ f c u x := fun c u x hx =>\n    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le\n  have posf' :\n    ∀ c u : exprℝ,\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\"\n        (volume.restrict (Ioi 0)) (0 ≤ f c u x) :=\n    fun c u => (ae_restrict_iff' measurable_set_Ioi).mpr (ae_of_all _ (posf c u))\n  have fpow : ∀ {c x : exprℝ} (hc : 0 < c) (u : exprℝ) (hx : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) :=\n    by\n    intro c x hc u hx\n    dsimp only [f]\n    rw [mul_rpow (exp_pos _).le ((rpow_nonneg_of_nonneg hx.le) _), ← exp_mul, ← rpow_mul hx.le]\n    congr 2 <;>\n      · field_simp [hc.ne']\n        ring\n  -- show `f c u` is in `ℒp` for `p = 1/c`:\n  have f_mem_Lp :\n    ∀ {c u : exprℝ} (hc : 0 < c) (hu : 0 < u), mem_ℒp (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) :=\n    by\n    intro c u hc hu\n    have A : ENNReal.ofReal (1 / c) ≠ 0 := by rwa [ne.def, ENNReal.ofReal_eq_zero, not_le, one_div_pos]\n    have B : ENNReal.ofReal (1 / c) ≠ ennreal.top := ENNReal.ofReal_ne_top\n    rw [← mem_ℒp_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le), ENNReal.div_self A B,\n      mem_ℒp_one_iff_integrable]\n    · apply integrable.congr (Gamma_integral_convergent hu)\n      refine' eventually_eq_of_mem (self_mem_ae_restrict measurable_set_Ioi) fun x hx => _\n      dsimp only\n      rw [fpow hc u hx]\n      congr 1\n      exact (norm_of_nonneg (posf _ _ x hx)).symm\n    · refine' continuous_on.ae_strongly_measurable _ measurable_set_Ioi\n      refine' (Continuous.continuousOn _).mul (ContinuousAt.continuousOn fun x hx => _)\n      · exact continuous_exp.comp (continuous_const.mul continuous_id')\n      · exact continuous_at_rpow_const _ _ (or.inl (ne_of_lt hx).symm)\n  -- now apply Hölder:\n  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]\n  convert measure_theory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)\n      (f_mem_Lp hb ht) using\n    1\n  · refine' set_integral_congr measurable_set_Ioi fun x hx => _\n    dsimp only [f]\n    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by rw [← exp_add, ← add_mul, ← neg_add, hab, neg_one_mul]\n    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) :=\n      by\n      rw [← rpow_add hx, hab']\n      congr 1\n      ring\n    rw [A, B]\n    ring\n  · rw [one_div_one_div, one_div_one_div]\n    congr 2 <;> exact set_integral_congr measurable_set_Ioi fun x hx => fpow (by assumption) _ hx\n#align Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma\n\n",
 "Gamma_mul_Gamma_one_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/-- Euler's reflection formula for the real Gamma function. -/\ntheorem Gamma_mul_Gamma_one_sub (s : exprℝ) : Gamma s * Gamma (1 - s) = real.pi / sin (real.pi * s) :=\n  by\n  simp_rw [← Complex.ofReal_inj, Complex.ofReal_div, Complex.ofReal_sin, Complex.ofReal_mul, ← complex.Gamma_of_real,\n    Complex.ofReal_sub, Complex.ofReal_one]\n  exact complex.Gamma_mul_Gamma_one_sub s\n#align Gamma_mul_Gamma_one_sub Gamma_mul_Gamma_one_sub\n\n",
 "Gamma_mul_Gamma_eq_beta_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprcexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprcexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprcexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- Relation between Beta integral and Gamma function.  -/\ntheorem Gamma_mul_Gamma_eq_beta_integral {s t : exprℂ} (hs : 0 < re s) (ht : 0 < re t) :\n    Gamma s * Gamma t = Gamma (s + t) * beta_integral s t :=\n  by\n  -- Note that we haven't proved (yet) that the Gamma function has no zeroes, so we can't formulate\n  -- this as a formula for the Beta function.\n  have conv_int :=\n    integral_pos_convolution (Gamma_integral_convergent hs) (Gamma_integral_convergent ht)\n      (continuous_linear_map.mul (exprℝ) (exprℂ))\n  simp_rw [continuous_linear_map.mul_apply'] at conv_int\n  have hst : 0 < re (s + t) := by\n    rw [add_re]\n    exact add_pos hs ht\n  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst, Gamma_integral, Gamma_integral, Gamma_integral,\n    ← conv_int, ← integral_mul_right (beta_integral _ _)]\n  refine' set_integral_congr measurable_set_Ioi fun x hx => _\n  dsimp only\n  rw [mul_assoc, ← beta_integral_scaled s t hx, ← interval_integral.integral_const_mul]\n  congr 1 with y : 1\n  push_cast\n  suffices (exprcexp) (-x) = (exprcexp) (-y) * (exprcexp) (-(x - y))\n    by\n    rw [this]\n    ring\n  · rw [← Complex.exp_add]\n    congr 1\n    abel\n#align Gamma_mul_Gamma_eq_beta_integral Gamma_mul_Gamma_eq_beta_integral\n\n",
 "Gamma_integrand_is_o":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =o[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2022 David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Loeffler\n-/\n/-- Asymptotic bound for the `Γ` function integrand. -/\ntheorem Gamma_integrand_is_o (s : exprℝ) :\n    «expr =o[ ] » (fun x : exprℝ => exp (-x) * x ^ s) atTop fun x : exprℝ => exp (-(1 / 2) * x) :=\n  by\n  refine' is_o_of_tendsto (fun x hx => _) _\n  · exfalso\n    exact (exp_pos (-(1 / 2) * x)).ne' hx\n  have : (fun x : exprℝ => exp (-x) * x ^ s / exp (-(1 / 2) * x)) = (fun x : exprℝ => exp (1 / 2 * x) / x ^ s)⁻¹ :=\n    by\n    ext1 x\n    field_simp [exp_ne_zero, exp_neg, ← Real.exp_add]\n    left\n    ring\n  rw [this]\n  exact (tendsto_exp_mul_div_rpow_at_top s (1 / 2) one_half_pos).inv_tendsto_at_top\n#align Gamma_integrand_is_o Gamma_integrand_is_o\n\n",
 "Gamma_integrand_interval_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\nprivate theorem Gamma_integrand_interval_integrable (s : exprℂ) {X : exprℝ} (hs : 0 < s.re) (hX : 0 ≤ X) :\n    interval_integrable (fun x => (-x).exp * x ^ (s - 1) : exprℝ → exprℂ) volume 0 X :=\n  by\n  rw [interval_integrable_iff_integrable_Ioc_of_le hX]\n  exact integrable_on.mono_set (Gamma_integral_convergent hs) Ioc_subset_Ioi_self\n#align Gamma_integrand_interval_integrable Gamma_integrand_interval_integrable\n\n",
 "Gamma_integrand_deriv_integrable_B":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\nprivate theorem Gamma_integrand_deriv_integrable_B {s : exprℂ} (hs : 0 < s.re) {Y : exprℝ} (hY : 0 ≤ Y) :\n    interval_integrable (fun x : exprℝ => (-x).exp * (s * x ^ (s - 1)) : exprℝ → exprℂ) volume 0 Y :=\n  by\n  have :\n    (fun x => (-x).exp * (s * x ^ (s - 1)) : exprℝ → exprℂ) = (fun x => s * ((-x).exp * x ^ (s - 1)) : exprℝ → exprℂ) :=\n    by\n    ext1\n    ring\n  rw [this, interval_integrable_iff_integrable_Ioc_of_le hY]\n  constructor\n  · refine' (continuous_on_const.mul _).ae_strongly_measurable measurable_set_Ioc\n    apply (continuous_of_real.comp continuous_neg.exp).continuous_on.mul\n    apply ContinuousAt.continuousOn\n    intro x hx\n    refine' (_ : ContinuousAt (fun x : exprℂ => x ^ (s - 1)) _).comp continuous_of_real.continuous_at\n    apply continuous_at_cpow_const\n    rw [of_real_re]\n    exact or.inl hx.1\n  rw [← has_finite_integral_norm_iff]\n  simp_rw [norm_eq_abs, map_mul]\n  refine' (((real.Gamma_integral_convergent hs).mono_set Ioc_subset_Ioi_self).has_finite_integral.congr _).const_mul _\n  rw [eventually_eq, ae_restrict_iff']\n  · apply ae_of_all\n    intro x hx\n    rw [abs_of_nonneg (exp_pos _).le, abs_cpow_eq_rpow_re_of_pos hx.1]\n    simp\n  · exact measurable_set_Ioc\n#align Gamma_integrand_deriv_integrable_B Gamma_integrand_deriv_integrable_B\n\n",
 "Gamma_integrand_deriv_integrable_A":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\nprivate theorem Gamma_integrand_deriv_integrable_A {s : exprℂ} (hs : 0 < s.re) {X : exprℝ} (hX : 0 ≤ X) :\n    interval_integrable (fun x => -((-x).exp * x ^ s) : exprℝ → exprℂ) volume 0 X :=\n  by\n  convert(Gamma_integrand_interval_integrable (s + 1) _ hX).neg\n  · ext1\n    simp only [add_sub_cancel, Pi.neg_apply]\n  · simp only [add_re, one_re]\n    linarith\n#align Gamma_integrand_deriv_integrable_A Gamma_integrand_deriv_integrable_A\n\n",
 "Gamma_integral_one":
 "theorem Gamma_integral_one : Gamma_integral 1 = 1 := by\n  simpa only [← of_real_one, Gamma_integral_of_real, of_real_inj, sub_self, rpow_zero, mul_one] using\n    integral_exp_neg_Ioi_zero\n#align Gamma_integral_one Gamma_integral_one\n\n",
 "Gamma_integral_of_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\ntheorem Gamma_integral_of_real (s : exprℝ) :\n    Gamma_integral ↑s =\n      ↑(«expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" (Ioi 0)\n          (Real.exp (-x) * x ^ (s - 1))) :=\n  by\n  rw [Gamma_integral, ← _root_.integral_of_real]\n  refine' set_integral_congr measurable_set_Ioi _\n  intro x hx; dsimp only\n  rw [of_real_mul, of_real_cpow (mem_Ioi.mp hx).le]\n  simp\n#align Gamma_integral_of_real Gamma_integral_of_real\n\n",
 "Gamma_integral_convergent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- Technical note: In defining the Gamma integrand exp (-x) * x ^ (s - 1) for s complex, we have to\nmake a choice between ↑(real.exp (-x)), complex.exp (↑(-x)), and complex.exp (-↑x), all of which are\nequal but not definitionally so. We use the first of these throughout. -/\n/-- The integral defining the `Γ` function converges for complex `s` with `0 < re s`.\n\nThis is proved by reduction to the real case. -/\ntheorem Gamma_integral_convergent {s : exprℂ} (hs : 0 < s.re) :\n    integrable_on (fun x => (-x).exp * x ^ (s - 1) : exprℝ → exprℂ) (Ioi 0) :=\n  by\n  constructor\n  · refine' continuous_on.ae_strongly_measurable _ measurable_set_Ioi\n    apply (continuous_of_real.comp continuous_neg.exp).continuous_on.mul\n    apply ContinuousAt.continuousOn\n    intro x hx\n    have : ContinuousAt (fun x : exprℂ => x ^ (s - 1)) ↑x :=\n      by\n      apply continuous_at_cpow_const\n      rw [of_real_re]\n      exact or.inl hx\n    exact ContinuousAt.comp this continuous_of_real.continuous_at\n  · rw [← has_finite_integral_norm_iff]\n    refine' has_finite_integral.congr (real.Gamma_integral_convergent hs).2 _\n    refine' (ae_restrict_iff' measurable_set_Ioi).mpr (ae_of_all _ fun x hx => _)\n    dsimp only\n    rw [norm_eq_abs, map_mul, abs_of_nonneg <| le_of_lt <| exp_pos <| -x, abs_cpow_eq_rpow_re_of_pos hx _]\n    simp\n#align Gamma_integral_convergent Gamma_integral_convergent\n\n",
 "Gamma_integral_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\ntheorem Gamma_integral_conj (s : exprℂ) : Gamma_integral ((star_ring_end) s) = (star_ring_end) (Gamma_integral s) :=\n  by\n  rw [Gamma_integral, Gamma_integral, ← integral_conj]\n  refine' set_integral_congr measurable_set_Ioi fun x hx => _\n  dsimp only\n  rw [RingHom.map_mul, conj_of_real, cpow_def_of_ne_zero (of_real_ne_zero.mpr (ne_of_gt hx)),\n    cpow_def_of_ne_zero (of_real_ne_zero.mpr (ne_of_gt hx)), ← exp_conj, RingHom.map_mul, ← of_real_log (le_of_lt hx),\n    conj_of_real, RingHom.map_sub, RingHom.map_one]\n#align Gamma_integral_conj Gamma_integral_conj\n\n",
 "Gamma_integral_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᶠ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The recurrence relation for the `Γ` integral. -/\ntheorem Gamma_integral_add_one {s : exprℂ} (hs : 0 < s.re) : Gamma_integral (s + 1) = s * Gamma_integral s :=\n  by\n  suffices tendsto (s + 1).partial_Gamma at_top (nhds <| s * Gamma_integral s)\n    by\n    refine' tendsto_nhds_unique _ this\n    apply tendsto_partial_Gamma\n    rw [add_re, one_re]\n    linarith\n  have : «expr =ᶠ[ ] » (fun X : exprℝ => s * partial_Gamma s X - X ^ s * (-X).exp) at_top (s + 1).partial_Gamma :=\n    by\n    apply eventually_eq_of_mem (Ici_mem_at_top (0 : exprℝ))\n    intro X hX\n    rw [partial_Gamma_add_one hs (mem_Ici.mp hX)]\n    ring_nf\n  refine' tendsto.congr' this _\n  suffices tendsto (fun X => -X ^ s * (-X).exp : exprℝ → exprℂ) at_top ((nhds) 0) by\n    simpa using tendsto.add (tendsto.const_mul s (tendsto_partial_Gamma hs)) this\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  have :\n    «expr =ᶠ[ ] » (fun e : exprℝ => «expr‖ ‖» (-(e : exprℂ) ^ s * (-e).exp)) at_top fun e : exprℝ =>\n      e ^ s.re * (-1 * e).exp :=\n    by\n    refine' eventually_eq_of_mem (Ioi_mem_at_top 0) _\n    intro x hx\n    dsimp only\n    rw [norm_eq_abs, map_mul, abs.map_neg, abs_cpow_eq_rpow_re_of_pos hx, abs_of_nonneg (exp_pos (-x)).le, neg_mul,\n      one_mul]\n  exact (tendsto_congr' this).mpr (tendsto_rpow_mul_exp_neg_mul_at_top_nhds_0 _ _ zero_lt_one)\n#align Gamma_integral_add_one Gamma_integral_add_one\n\n",
 "Gamma_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_eq_zero_iff (s : exprℂ) : Gamma s = 0 ↔ ∃ m : ℕ, s = -m :=\n  by\n  constructor\n  · contrapose!\n    exact Gamma_ne_zero\n  · rintro ⟨m, rfl⟩\n    exact Gamma_neg_nat_eq_zero m\n#align Gamma_eq_zero_iff Gamma_eq_zero_iff\n\n",
 "Gamma_eq_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\ntheorem Gamma_eq_integral {s : exprℝ} (hs : 0 < s) :\n    Gamma s =\n      «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" (Ioi 0)\n        (exp (-x) * x ^ (s - 1)) :=\n  by\n  rw [Gamma, complex.Gamma_eq_integral (by rwa [Complex.ofReal_re] : 0 < complex.re s)]\n  dsimp only [complex.Gamma_integral]\n  simp_rw [← Complex.ofReal_one, ← Complex.ofReal_sub]\n  suffices\n    «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" (Ioi 0)\n        (↑(exp (-x)) * (x : exprℂ) ^ ((s - 1 : exprℝ) : exprℂ)) =\n      «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" (Ioi 0)\n        ((exp (-x) * x ^ (s - 1) : exprℝ) : exprℂ)\n    by rw [this, _root_.integral_of_real, Complex.ofReal_re]\n  refine' set_integral_congr measurable_set_Ioi fun x hx => _\n  push_cast\n  rw [complex.of_real_cpow (le_of_lt hx)]\n  push_cast\n#align Gamma_eq_integral Gamma_eq_integral\n\n",
 "Gamma_eq_Gamma_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_eq_Gamma_aux (s : exprℂ) (n : ℕ) (h1 : -s.re < ↑n) : Gamma s = Gamma_aux n s :=\n  by\n  have u : ∀ k : ℕ, Gamma_aux («expr⌊ ⌋₊» (1 - s.re) + k) s = Gamma s :=\n    by\n    intro k\n    induction' k with k hk\n    · simp [Gamma]\n    · rw [← hk, nat.succ_eq_add_one, ← add_assoc]\n      refine' (Gamma_aux_recurrence2 s («expr⌊ ⌋₊» (1 - s.re) + k) _).symm\n      rw [Nat.cast_add]\n      have i0 := Nat.sub_one_lt_floor (1 - s.re)\n      simp only [sub_sub_cancel_left] at i0\n      refine' lt_add_of_lt_of_nonneg i0 _\n      rw [← Nat.cast_zero, Nat.cast_le]\n      exact nat.zero_le k\n  convert(u <| n - «expr⌊ ⌋₊» (1 - s.re)).symm\n  rw [nat.add_sub_of_le]\n  by_cases 0 ≤ 1 - s.re\n  · apply nat.le_of_lt_succ\n    exact_mod_cast lt_of_le_of_lt (Nat.floor_le h) (by linarith : 1 - s.re < n + 1)\n  · rw [Nat.floor_of_nonpos]\n    linarith\n    linarith\n#align Gamma_eq_Gamma_aux Gamma_eq_Gamma_aux\n\n",
 "Gamma_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\ntheorem Gamma_conj (s : exprℂ) : Gamma ((star_ring_end) s) = (star_ring_end) (Gamma s) :=\n  by\n  suffices : ∀ (n : ℕ) (s : exprℂ), Gamma_aux n ((star_ring_end) s) = (star_ring_end) (Gamma_aux n s); exact this _ _\n  intro n\n  induction' n with n IH\n  · rw [Gamma_aux]\n    exact Gamma_integral_conj\n  · intro s\n    rw [Gamma_aux]\n    dsimp only\n    rw [div_eq_mul_inv _ s, RingHom.map_mul, conj_inv, ← div_eq_mul_inv]\n    suffices (star_ring_end) s + 1 = (star_ring_end) (s + 1) by rw [this, IH]\n    rw [RingHom.map_add, RingHom.map_one]\n#align Gamma_conj Gamma_conj\n\n",
 "Gamma_aux_recurrence2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_aux_recurrence2 (s : exprℂ) (n : ℕ) (h1 : -s.re < ↑n) : Gamma_aux n s = Gamma_aux (n + 1) s :=\n  by\n  cases n\n  · simp only [Nat.cast_zero, neg_lt_zero] at h1\n    dsimp only [Gamma_aux]\n    rw [Gamma_integral_add_one h1, mul_div_cancel_left]\n    rintro rfl\n    rw [zero_re] at h1\n    exact h1.false\n  · dsimp only [Gamma_aux]\n    have : Gamma_aux n (s + 1 + 1) / (s + 1) = Gamma_aux n (s + 1) :=\n      by\n      have hh1 : -(s + 1).re < n :=\n        by\n        rw [nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one] at h1\n        rw [add_re, one_re]\n        linarith\n      rw [Gamma_aux_recurrence1 (s + 1) n hh1]\n    rw [this]\n#align Gamma_aux_recurrence2 Gamma_aux_recurrence2\n\n",
 "Gamma_aux_recurrence1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem Gamma_aux_recurrence1 (s : exprℂ) (n : ℕ) (h1 : -s.re < ↑n) : Gamma_aux n s = Gamma_aux n (s + 1) / s :=\n  by\n  induction' n with n hn generalizing s\n  · simp only [Nat.cast_zero, neg_lt_zero] at h1\n    dsimp only [Gamma_aux]\n    rw [Gamma_integral_add_one h1]\n    rw [mul_comm, mul_div_cancel]\n    contrapose! h1\n    rw [h1]\n    simp\n  · dsimp only [Gamma_aux]\n    have hh1 : -(s + 1).re < n :=\n      by\n      rw [nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one] at h1\n      rw [add_re, one_re]\n      linarith\n    rw [← hn (s + 1) hh1]\n#align Gamma_aux_recurrence1 Gamma_aux_recurrence1\n\n",
 "Gamma_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Gamma_add_one {s : exprℝ} (hs : s ≠ 0) : Gamma (s + 1) = s * Gamma s :=\n  by\n  simp_rw [Gamma]\n  rw [Complex.ofReal_add, Complex.ofReal_one, complex.Gamma_add_one, Complex.ofReal_mul_re]\n  rwa [Complex.ofReal_ne_zero]\n#align Gamma_add_one Gamma_add_one\n\n"}