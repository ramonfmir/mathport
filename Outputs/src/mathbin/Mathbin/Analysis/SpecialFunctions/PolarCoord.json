{"polar_coord_source_ae_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem polar_coord_source_ae_eq_univ : «expr =ᵐ[ ] » polar_coord.source volume univ :=\n  by\n  have A : «expr ᶜ» polar_coord.source ⊆ (LinearMap.snd (exprℝ) (exprℝ) (exprℝ)).ker :=\n    by\n    intro x hx\n    simp only [polar_coord_source, compl_union, mem_inter_iff, mem_compl_iff, mem_set_of_eq, not_lt,\n      Classical.not_not] at hx\n    exact hx.2\n  have B : volume ((LinearMap.snd (exprℝ) (exprℝ) (exprℝ)).ker : Set (exprℝ × exprℝ)) = 0 :=\n    by\n    apply measure.add_haar_submodule\n    rw [ne.def, LinearMap.ker_eq_top]\n    intro h\n    have :\n      (LinearMap.snd (exprℝ) (exprℝ) (exprℝ)) (0, 1) = (0 : «expr →ₗ[ ] » (exprℝ × exprℝ) (exprℝ) (exprℝ)) (0, 1) := by\n      rw [h]\n    simpa using this\n  simp only [ae_eq_univ]\n  exact le_antisymm ((measure_mono A).trans (le_of_eq B)) bot_le\n#align polar_coord_source_ae_eq_univ polar_coord_source_ae_eq_univ\n\n",
 "integral_comp_polar_coord_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →L[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\ntheorem integral_comp_polar_coord_symm {E : Type _} [NormedAddCommGroup E] [NormedSpace (exprℝ) E] [CompleteSpace E]\n    (f : exprℝ × exprℝ → E) :\n    «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n        polar_coord.target («expr • » p.1 (f (polar_coord.symm p))) =\n      «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\" (f p) :=\n  by\n  set B : exprℝ × exprℝ → «expr →L[ ] » (exprℝ × exprℝ) (exprℝ) (exprℝ × exprℝ) := fun p =>\n    (Matrix.toLin (Basis.finTwoProd (exprℝ)) (Basis.finTwoProd (exprℝ))\n        !![cos p.2, -p.1 * sin p.2; sin p.2, p.1 * cos p.2]).to_continuous_linear_map with\n    hB\n  have A : ∀ p ∈ polar_coord.symm.source, has_fderiv_at polar_coord.symm (B p) p := fun p hp =>\n    has_fderiv_at_polar_coord_symm p\n  have B_det : ∀ p, (B p).det = p.1 := by\n    intro p\n    conv_rhs => rw [← one_mul p.1, ← cos_sq_add_sin_sq p.2]\n    simp only [neg_mul, linear_map.det_to_continuous_linear_map, LinearMap.det_toLin, Matrix.det_fin_two_of,\n      sub_neg_eq_add]\n    ring\n  symm\n  calc\n    «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\" (f p) =\n        «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n          polar_coord.source (f p) :=\n      by\n      rw [← integral_univ]\n      apply set_integral_congr_set_ae\n      exact polar_coord_source_ae_eq_univ.symm\n    _ =\n        «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n          polar_coord.target («expr • » (abs (B p).det) (f (polar_coord.symm p))) :=\n      by apply integral_target_eq_integral_abs_det_fderiv_smul volume A\n    _ =\n        «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\"\n          polar_coord.target («expr • » p.1 (f (polar_coord.symm p))) :=\n      by\n      apply set_integral_congr polar_coord.open_target.measurable_set fun x hx => _\n      rw [B_det, abs_of_pos]\n      exact hx.1\n    \n#align integral_comp_polar_coord_symm integral_comp_polar_coord_symm\n\n",
 "has_fderiv_at_polar_coord_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2022 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\ntheorem has_fderiv_at_polar_coord_symm (p : exprℝ × exprℝ) :\n    has_fderiv_at polar_coord.symm\n      (Matrix.toLin (Basis.finTwoProd (exprℝ)) (Basis.finTwoProd (exprℝ))\n          !![cos p.2, -p.1 * sin p.2; sin p.2, p.1 * cos p.2]).to_continuous_linear_map\n      p :=\n  by\n  rw [matrix.to_lin_fin_two_prod_to_continuous_linear_map]\n  convert has_fderiv_at.prod (has_fderiv_at_fst.mul ((has_deriv_at_cos p.2).comp_has_fderiv_at p has_fderiv_at_snd))\n        (has_fderiv_at_fst.mul ((has_deriv_at_sin p.2).comp_has_fderiv_at p has_fderiv_at_snd)) using\n      2 <;>\n    simp only [smul_smul, add_comm, neg_mul, neg_smul, smul_neg]\n#align has_fderiv_at_polar_coord_symm has_fderiv_at_polar_coord_symm\n\n"}