{"transfer_sylow_restrict_eq_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem transfer_sylow_restrict_eq_pow :\n    «expr⇑ » ((transfer_sylow P hP).restrict (P : Subgroup G)) = (· ^ (P : Subgroup G).index) :=\n  funext fun g => transfer_sylow_eq_pow P hP g g.2\n#align transfer_sylow_restrict_eq_pow transfer_sylow_restrict_eq_pow\n\n",
 "transfer_sylow_eq_pow_aux":
 "/-- Auxillary lemma in order to state `transfer_sylow_eq_pow`. -/\ntheorem transfer_sylow_eq_pow_aux (g : G) (hg : g ∈ P) (k : ℕ) (g₀ : G) (h : g₀⁻¹ * g ^ k * g₀ ∈ P) :\n    g₀⁻¹ * g ^ k * g₀ = g ^ k :=\n  by\n  haveI : (P : Subgroup G).is_commutative := ⟨⟨fun a b => Subtype.ext (hP (le_normalizer b.2) a a.2)⟩⟩\n  replace hg := (P : Subgroup G).pow_mem hg k\n  obtain ⟨n, hn, h⟩ := P.conj_eq_normalizer_conj_of_mem (g ^ k) g₀ hg h\n  exact h.trans (Commute.inv_mul_cancel (hP hn (g ^ k) hg).symm)\n#align transfer_sylow_eq_pow_aux transfer_sylow_eq_pow_aux\n\n",
 "transfer_sylow_eq_pow":
 "theorem transfer_sylow_eq_pow (g : G) (hg : g ∈ P) :\n    transfer_sylow P hP g = ⟨g ^ (P : Subgroup G).index, transfer_eq_pow_aux g (transfer_sylow_eq_pow_aux P hP g hg)⟩ :=\n  by apply transfer_eq_pow\n#align transfer_sylow_eq_pow transfer_sylow_eq_pow\n\n",
 "transfer_eq_prod_quotient_orbit_rel_zpowers_quot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-- Explicit computation of the transfer homomorphism. -/\ntheorem transfer_eq_prod_quotient_orbit_rel_zpowers_quot [FiniteIndex H] (g : G)\n    [Fintype (quotient (orbitRel (zpowers g) («expr ⧸ » G H)))] :\n    transfer ϕ g =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (ϕ\n          ⟨q.out'.out'⁻¹ * g ^ Function.minimalPeriod ((«expr • » · ·) g) q.out' * q.out'.out',\n            QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q.out'⟩) :=\n  by\n  classical\n    letI := H.fintype_quotient_of_finite_index\n    calc\n      transfer ϕ g =\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            _ :=\n        transfer_def ϕ (transfer_transversal H g) g\n      _ = _ := ((quotient_equiv_sigma_zmod H g).symm.prod_comp _).symm\n      _ = _ := (Finset.prod_sigma _ _ _)\n      _ = _ := Fintype.prod_congr _ _ fun q => _\n      \n    simp only [quotient_equiv_sigma_zmod_symm_apply, transfer_transversal_apply', transfer_transversal_apply'']\n    rw [Fintype.prod_eq_single (0 : ZMod (Function.minimalPeriod ((«expr • » · ·) g) q.out')) fun k hk => _]\n    · simp only [if_pos, ZMod.cast_zero, zpow_zero, one_mul, mul_assoc]\n    · simp only [if_neg hk, inv_mul_self]\n      exact map_one ϕ\n#align transfer_eq_prod_quotient_orbit_rel_zpowers_quot transfer_eq_prod_quotient_orbit_rel_zpowers_quot\n\n",
 "transfer_eq_pow_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Auxillary lemma in order to state `transfer_eq_pow`. -/\ntheorem transfer_eq_pow_aux (g : G) (key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g₀⁻¹ * g ^ k * g₀ = g ^ k) :\n    g ^ H.index ∈ H := by\n  by_cases hH : H.index = 0\n  · rw [hH, pow_zero]\n    exact H.one_mem\n  letI := fintype_of_index_ne_zero hH\n  classical\n    replace key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g ^ k ∈ H := fun k g₀ hk =>\n      (_root_.congr_arg (· ∈ H) (key k g₀ hk)).mp hk\n    replace key : ∀ q : «expr ⧸ » G H, g ^ Function.minimalPeriod ((«expr • » · ·) g) q ∈ H := fun q =>\n      key (Function.minimalPeriod ((«expr • » · ·) g) q) q.out' (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)\n    let f : quotient (orbit_rel (zpowers g) («expr ⧸ » G H)) → zpowers g := fun q =>\n      (⟨g, mem_zpowers g⟩ : zpowers g) ^ Function.minimalPeriod ((«expr • » · ·) g) q.out'\n    have hf : ∀ q, f q ∈ H.subgroup_of (zpowers g) := fun q => key q.out'\n    replace key := Subgroup.prod_mem (H.subgroup_of (zpowers g)) fun q (hq : q ∈ Finset.univ) => hf q\n    simpa only [minimal_period_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,\n      Fintype.card_congr (self_equiv_sigma_orbits (zpowers g) («expr ⧸ » G H)), index_eq_card] using key\n#align transfer_eq_pow_aux transfer_eq_pow_aux\n\n",
 "transfer_eq_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem transfer_eq_pow [FiniteIndex H] (g : G)\n    (key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g₀⁻¹ * g ^ k * g₀ = g ^ k) :\n    transfer ϕ g = ϕ ⟨g ^ H.index, transfer_eq_pow_aux g key⟩ := by\n  classical\n    letI := H.fintype_quotient_of_finite_index\n    change ∀ (k g₀) (hk : g₀⁻¹ * g ^ k * g₀ ∈ H), ↑(⟨g₀⁻¹ * g ^ k * g₀, hk⟩ : H) = g ^ k at key\n    rw [transfer_eq_prod_quotient_orbit_rel_zpowers_quot, ← Finset.prod_to_list, List.prod_map_hom]\n    refine' congr_arg ϕ (Subtype.coe_injective _)\n    rw [H.coe_mk, ← (zpowers g).coe_mk g (mem_zpowers g), ← (zpowers g).coe_pow, (zpowers g).coe_mk, index_eq_card,\n      Fintype.card_congr (self_equiv_sigma_orbits (zpowers g) («expr ⧸ » G H)), Fintype.card_sigma, ←\n      Finset.prod_pow_eq_pow_sum, ← Finset.prod_to_list]\n    simp only [coe_list_prod, list.map_map, ← minimal_period_eq_card]\n    congr 2\n    funext\n    apply key\n#align transfer_eq_pow transfer_eq_pow\n\n",
 "transfer_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem transfer_def [FiniteIndex H] (g : G) : transfer ϕ g = diff ϕ T («expr • » g T) := by\n  rw [transfer, ← diff_mul_diff, ← smul_diff_smul, mul_comm, diff_mul_diff] <;> rfl\n#align transfer_def transfer_def\n\n",
 "transfer_center_pow_apply":
 "@[simp]\ntheorem transfer_center_pow_apply [FiniteIndex (center G)] (g : G) :\n    ↑(transfer_center_pow G g) = g ^ (center G).index :=\n  rfl\n#align transfer_center_pow_apply transfer_center_pow_apply\n\n",
 "transfer_center_eq_pow":
 "theorem transfer_center_eq_pow [FiniteIndex (center G)] (g : G) :\n    transfer (MonoidHom.id (center G)) g = ⟨g ^ (center G).index, (center G).pow_index_mem g⟩ :=\n  transfer_eq_pow (id (center G)) g fun k _ hk => by rw [← mul_right_inj, hk, mul_inv_cancel_right]\n#align transfer_center_eq_pow transfer_center_eq_pow\n\n",
 "smul_diff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_diff_smul (g : G) : diff ϕ («expr • » g S) («expr • » g T) = diff ϕ S T :=\n  let h := H.fintype_quotient_of_finite_index\n  prod_bij' (fun q _ => «expr • » g⁻¹ q) (fun _ _ => mem_univ _)\n    (fun _ _ =>\n      congr_arg ϕ\n        (by\n          simp_rw [coe_mk, smul_apply_eq_smul_apply_inv_smul, smul_eq_mul, mul_inv_rev, mul_assoc,\n            inv_mul_cancel_left]))\n    (fun q _ => «expr • » g q) (fun _ _ => mem_univ _) (fun q _ => smul_inv_smul g q) fun q _ => inv_smul_smul g q\n#align smul_diff_smul smul_diff_smul\n\n",
 "not_dvd_card_ker_transfer_sylow":
 "theorem not_dvd_card_ker_transfer_sylow : ¬p ∣ Nat.card (transfer_sylow P hP).ker :=\n  (ker_transfer_sylow_is_complement' P hP).index_eq_card ▸ not_dvd_index_sylow P <|\n    mt index_eq_zero_of_relindex_eq_zero index_ne_zero_of_finite\n#align not_dvd_card_ker_transfer_sylow not_dvd_card_ker_transfer_sylow\n\n",
 "ker_transfer_sylow_is_complement'":
 "/-- Burnside's normal p-complement theorem: If `N(P) ≤ C(P)`, then `P` has a normal complement. -/\ntheorem ker_transfer_sylow_is_complement' : is_complement' (transfer_sylow P hP).ker P :=\n  by\n  have hf : function.bijective ((transfer_sylow P hP).restrict (P : Subgroup G)) :=\n    (transfer_sylow_restrict_eq_pow P hP).symm ▸\n      (P.2.pow_equiv' (not_dvd_index_sylow P (mt index_eq_zero_of_relindex_eq_zero index_ne_zero_of_finite))).bijective\n  rw [function.bijective, ← range_top_iff_surjective, restrict_range] at hf\n  have := range_top_iff_surjective.mp (top_le_iff.mp (hf.2.ge.trans (map_le_range _ P)))\n  rw [← (comap_injective this).eq_iff, comap_top, comap_map_eq, sup_comm, SetLike.ext'_iff, normal_mul, ←\n    ker_eq_bot_iff, ← (map_injective (P : Subgroup G).subtype_injective).eq_iff, ker_restrict, subgroup_of_map_subtype,\n    Subgroup.map_bot, coe_top] at hf\n  exact is_complement'_of_disjoint_and_mul_eq_univ (disjoint_iff.2 hf.1) hf.2\n#align ker_transfer_sylow_is_complement' ker_transfer_sylow_is_complement'\n\n",
 "ker_transfer_sylow_disjoint":
 "theorem ker_transfer_sylow_disjoint (Q : Subgroup G) (hQ : is_p_group p Q) : Disjoint (transfer_sylow P hP).ker Q :=\n  disjoint_iff.mpr <|\n    card_eq_one.mp <|\n      (hQ.to_le inf_le_right).card_eq_or_dvd.resolve_right fun h =>\n        not_dvd_card_ker_transfer_sylow P hP <| h.trans <| nat_card_dvd_of_le _ _ inf_le_left\n#align ker_transfer_sylow_disjoint ker_transfer_sylow_disjoint\n\n",
 "diff_self":
 "@[to_additive]\ntheorem diff_self : diff ϕ T T = 1 :=\n  mul_right_eq_self.mp (diff_mul_diff ϕ T T T)\n#align diff_self diff_self\n\n",
 "diff_mul_diff":
 "/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\n@[to_additive]\ntheorem diff_mul_diff : diff ϕ R S * diff ϕ S T = diff ϕ R T :=\n  prod_mul_distrib.symm.trans\n    (prod_congr rfl fun q hq =>\n      (ϕ.map_mul _ _).symm.trans\n        (congr_arg ϕ (by simp_rw [Subtype.ext_iff, coe_mul, coe_mk, mul_assoc, mul_inv_cancel_left])))\n#align diff_mul_diff diff_mul_diff\n\n",
 "diff_inv":
 "@[to_additive]\ntheorem diff_inv : (diff ϕ S T)⁻¹ = diff ϕ T S :=\n  inv_eq_of_mul_eq_one_right <| (diff_mul_diff ϕ S T S).trans <| diff_self ϕ S\n#align diff_inv diff_inv\n\n"}