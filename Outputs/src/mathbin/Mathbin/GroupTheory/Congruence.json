{"zpow":
 "/-- Multiplicative congruence relations preserve integer powers. -/\n@[to_additive AddCon.zsmul \"Additive congruence relations preserve integer scaling.\"]\nprotected theorem zpow : ∀ (n : ℤ) {w x}, c w x → c (w ^ n) (x ^ n)\n  | int.of_nat n, w, x, h => by simpa only [zpow_ofNat] using c.pow _ h\n  | -[n+1], w, x, h => by simpa only [zpow_negSucc] using c.inv (c.pow _ h)\n#align zpow zpow\n\n",
 "trans":
 "#print trans /-\n/-- Congruence relations are transitive. -/\n@[to_additive \"Additive congruence relations are transitive.\"]\nprotected theorem trans : ∀ {x y z}, c x y → c y z → c x z := fun _ _ _ h => c.to_setoid.trans' h\n#align trans trans\n-/\n\n",
 "to_submonoid_inj":
 "@[to_additive]\ntheorem to_submonoid_inj (c d : Con M) (H : (c : Submonoid (M × M)) = d) : c = d :=\n  ext fun x y => show (x, y) ∈ (c : Submonoid (M × M)) ↔ (x, y) ∈ ↑d by rw [H]\n#align to_submonoid_inj to_submonoid_inj\n\n",
 "to_setoid_inj":
 "/-- The map sending a congruence relation to its underlying equivalence relation is injective. -/\n@[to_additive \"The map sending an additive congruence relation to its underlying equivalence\\nrelation is injective.\"]\ntheorem to_setoid_inj {c d : Con M} (H : c.to_setoid = d.to_setoid) : c = d :=\n  ext <| ext_iff.1 H\n#align to_setoid_inj to_setoid_inj\n\n",
 "symm":
 "#print symm /-\n/-- Congruence relations are symmetric. -/\n@[to_additive \"Additive congruence relations are symmetric.\"]\nprotected theorem symm : ∀ {x y}, c x y → c y x := fun _ _ h => c.to_setoid.symm' h\n#align symm symm\n-/\n\n",
 "sup_eq_con_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The supremum of congruence relations `c, d` equals the smallest congruence relation containing\n    the binary relation '`x` is related to `y` by `c` or `d`'. -/\n@[to_additive sup_eq_add_con_gen\n      \"The supremum of additive congruence relations `c, d` equals the\\nsmallest additive congruence relation containing the binary relation '`x` is related to `y`\\nby `c` or `d`'.\"]\ntheorem sup_eq_con_gen (c d : Con M) : «expr ⊔ » c d = conGen fun x y => c x y ∨ d x y :=\n  by\n  rw [con_gen_eq]\n  apply congr_arg Inf\n  simp only [le_def, or_imp, ← forall_and]\n#align sup_eq_con_gen sup_eq_con_gen\n\n",
 "sup_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The supremum of two congruence relations equals the smallest congruence relation containing\n    the supremum of the underlying binary operations. -/\n@[to_additive\n      \"The supremum of two additive congruence relations equals the smallest additive\\ncongruence relation containing the supremum of the underlying binary operations.\"]\ntheorem sup_def {c d : Con M} : «expr ⊔ » c d = conGen («expr ⊔ » c.r d.r) := by rw [sup_eq_con_gen] <;> rfl\n#align sup_def sup_def\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul {α M : Type _} [MulOneClass M] [SMul α M] [IsScalarTower α M M] (c : Con M) (a : α) {w x : M} (h : c w x) :\n    c («expr • » a w) («expr • » a x) := by simpa only [smul_one_mul] using c.mul (c.refl' («expr • » a 1 : M)) h\n#align smul smul\n\n",
 "rel_mk":
 "@[simp, to_additive]\ntheorem rel_mk {s : setoid M} {h a b} : con.mk s h a b ↔ r a b :=\n  iff.rfl\n#align rel_mk rel_mk\n\n",
 "rel_eq_coe":
 "/-\nCopyright (c) 2019 Amelia Livingston. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Amelia Livingston\n-/\n@[simp, to_additive]\ntheorem rel_eq_coe (c : Con M) : c.r = c :=\n  rfl\n#align rel_eq_coe rel_eq_coe\n\n",
 "refl":
 "#print refl /-\n/-- Congruence relations are reflexive. -/\n@[to_additive \"Additive congruence relations are reflexive.\"]\nprotected theorem refl (x) : c x x :=\n  c.to_setoid.refl' x\n#align refl refl\n-/\n\n",
 "quot_mk_eq_coe":
 "-- Quotients\n-- Lower the priority since it unifies with any quotient type.\n@[simp, to_additive]\ntheorem quot_mk_eq_coe {M : Type _} [Mul M] (c : Con M) (x : M) : Quot.mk c x = (x : c.quotient) :=\n  rfl\n#align quot_mk_eq_coe quot_mk_eq_coe\n\n",
 "pow":
 "/-- Multiplicative congruence relations preserve natural powers. -/\n@[to_additive AddCon.nsmul \"Additive congruence relations preserve natural scaling.\"]\nprotected theorem pow {M : Type _} [Monoid M] (c : Con M) : ∀ (n : ℕ) {w x}, c w x → c (w ^ n) (x ^ n)\n  | 0, w, x, h => by simpa using c.refl _\n  | nat.succ n, w, x, h => by simpa [pow_succ] using c.mul h (pow n h)\n#align pow pow\n\n",
 "mul_ker_mk_eq":
 "/-- The kernel of the quotient map induced by a congruence relation `c` equals `c`. -/\n@[simp, to_additive \"The kernel of the quotient map induced by an additive congruence relation\\n`c` equals `c`.\"]\ntheorem mul_ker_mk_eq : (mulKer (coe : M → c.quotient) fun x y => rfl) = c :=\n  ext fun x y => Quotient.eq''\n#align mul_ker_mk_eq mul_ker_mk_eq\n\n",
 "mul":
 "/-- Multiplicative congruence relations preserve multiplication. -/\n@[to_additive \"Additive congruence relations preserve addition.\"]\nprotected theorem mul : ∀ {w x y z}, c w x → c y z → c (w * y) (x * z) := fun _ _ _ _ h1 h2 => c.mul' h1 h2\n#align mul mul\n\n",
 "mrange_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mrange_mk' : c.mk'.mrange = «expr⊤» :=\n  MonoidHom.mrange_top_iff_surjective.2 mk'_surjective\n#align mrange_mk' mrange_mk'\n\n",
 "mk'_surjective":
 "/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\n    surjective. -/\n@[to_additive \"The natural homomorphism from an `add_monoid` to its quotient by a congruence\\nrelation is surjective.\"]\ntheorem mk'_surjective : surjective c.mk' :=\n  Quotient.surjective_Quotient_mk''\n#align mk'_surjective mk'_surjective\n\n",
 "mk'_ker":
 "/-- The kernel of the natural homomorphism from a monoid to its quotient by a congruence\n    relation `c` equals `c`. -/\n@[simp,\n  to_additive\n      \"The kernel of the natural homomorphism from an `add_monoid` to its quotient by\\nan additive congruence relation `c` equals `c`.\"]\ntheorem mk'_ker : ker c.mk' = c :=\n  ext fun _ _ => c.eq\n#align mk'_ker mk'_ker\n\n",
 "mem_coe":
 "@[to_additive]\ntheorem mem_coe {c : Con M} {x y} : (x, y) ∈ (↑c : Submonoid (M × M)) ↔ (x, y) ∈ c :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "map_of_surjective_eq_map_gen":
 "/-- A specialization of 'the smallest congruence relation containing a congruence relation `c`\n    equals `c`'. -/\n@[to_additive\n      \"A specialization of 'the smallest additive congruence relation containing\\nan additive congruence relation `c` equals `c`'.\"]\ntheorem map_of_surjective_eq_map_gen {c : Con M} {f : M → N} (H : ∀ x y, f (x * y) = f x * f y) (h : mulKer f H ≤ c)\n    (hf : surjective f) : c.map_gen f = c.map_of_surjective f H h hf := by\n  rw [← con_gen_of_con (c.map_of_surjective f H h hf)] <;> rfl\n#align map_of_surjective_eq_map_gen map_of_surjective_eq_map_gen\n\n",
 "map_apply":
 "/-- Given congruence relations `c, d` on a monoid such that `d` contains `c`, the definition of\n    the homomorphism from the quotient by `c` to the quotient by `d` induced by `d`'s quotient\n    map. -/\n@[to_additive\n      \"Given additive congruence relations `c, d` on an `add_monoid` such that `d`\\ncontains `c`, the definition of the homomorphism from the quotient by `c` to the quotient by `d`\\ninduced by `d`'s quotient map.\"]\ntheorem map_apply {c d : Con M} (h : c ≤ d) (x) : c.map d h x = c.lift d.mk' (fun x y hc => d.eq.2 <| h hc) x :=\n  rfl\n#align map_apply map_apply\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The uniqueness part of the universal property for quotients of monoids. -/\n@[to_additive \"The uniqueness part of the universal property for quotients of `add_monoid`s.\"]\ntheorem lift_unique (H : c ≤ ker f) (g : «expr →* » c.quotient P) (Hg : g.comp c.mk' = f) : g = c.lift f H :=\n  lift_funext g (c.lift f H) fun x => by\n    subst f\n    rfl\n#align lift_unique lift_unique\n\n",
 "lift_surjective_of_surjective":
 "/-- Surjective monoid homomorphisms constant on a congruence relation `c`'s equivalence classes\n    induce a surjective homomorphism on `c`'s quotient. -/\n@[to_additive\n      \"Surjective `add_monoid` homomorphisms constant on an additive congruence\\nrelation `c`'s equivalence classes induce a surjective homomorphism on `c`'s quotient.\"]\ntheorem lift_surjective_of_surjective (h : c ≤ ker f) (hf : surjective f) : surjective (c.lift f h) := fun y =>\n  exists.elim (hf y) fun w hw => ⟨w, (lift_mk' h w).symm ▸ hw⟩\n#align lift_surjective_of_surjective lift_surjective_of_surjective\n\n",
 "lift_range":
 "/-- Given a congruence relation `c` on a monoid and a homomorphism `f` constant on `c`'s\n    equivalence classes, `f` has the same image as the homomorphism that `f` induces on the\n    quotient. -/\n@[to_additive\n      \"Given an additive congruence relation `c` on an `add_monoid` and a homomorphism `f`\\nconstant on `c`'s equivalence classes, `f` has the same image as the homomorphism that `f` induces\\non the quotient.\"]\ntheorem lift_range (H : c ≤ ker f) : (c.lift f H).mrange = f.mrange :=\n  Submonoid.ext fun x => ⟨by rintro ⟨⟨y⟩, hy⟩ <;> exact ⟨y, hy⟩, fun ⟨y, hy⟩ => ⟨↑y, hy⟩⟩\n#align lift_range lift_range\n\n",
 "lift_on_units_mk":
 "@[simp, to_additive]\ntheorem lift_on_units_mk (f : ∀ x y : M, c (x * y) 1 → c (y * x) 1 → α)\n    (Hf : ∀ x y hxy hyx x' y' hxy' hyx', c x x' → c y y' → f x y hxy hyx = f x' y' hxy' hyx') (x y : M) (hxy hyx) :\n    liftOnUnits ⟨(x : c.quotient), y, hxy, hyx⟩ f Hf = f x y (c.eq.1 hxy) (c.eq.1 hyx) :=\n  rfl\n#align lift_on_units_mk lift_on_units_mk\n\n",
 "lift_on_coe":
 "/-- Definition of the function on the quotient by a congruence relation `c` induced by a function\n    that is constant on `c`'s equivalence classes. -/\n@[simp,\n  to_additive\n      \"Definition of the function on the quotient by an additive congruence\\nrelation `c` induced by a function that is constant on `c`'s equivalence classes.\"]\nprotected theorem lift_on_coe {β} (c : Con M) (f : M → β) (h : ∀ a b, c a b → f a = f b) (x : M) :\n    Con.liftOn (x : c.quotient) f h = f x :=\n  rfl\n#align lift_on_coe lift_on_coe\n\n",
 "lift_mk'":
 "/-- The diagram describing the universal property for quotients of monoids commutes. -/\n@[to_additive \"The diagram describing the universal property for quotients of `add_monoid`s\\ncommutes.\"]\ntheorem lift_mk' (H : c ≤ ker f) (x) : c.lift f H (c.mk' x) = f x :=\n  rfl\n#align lift_mk' lift_mk'\n\n",
 "lift_funext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\n    are equal on elements that are coercions from the monoid. -/\n@[to_additive\n      \"Homomorphisms on the quotient of an `add_monoid` by an additive congruence relation\\nare equal if they are equal on elements that are coercions from the `add_monoid`.\"]\ntheorem lift_funext (f g : «expr →* » c.quotient P) (h : ∀ a : M, f a = g a) : f = g :=\n  by\n  rw [← lift_apply_mk' f, ← lift_apply_mk' g]\n  congr 1\n  exact MonoidHom.ext_iff.2 h\n#align lift_funext lift_funext\n\n",
 "lift_comp_mk'":
 "/-- The diagram describing the universal property for quotients of monoids commutes. -/\n@[simp, to_additive \"The diagram describing the universal property for quotients of `add_monoid`s\\ncommutes.\"]\ntheorem lift_comp_mk' (H : c ≤ ker f) : (c.lift f H).comp c.mk' = f := by ext <;> rfl\n#align lift_comp_mk' lift_comp_mk'\n\n",
 "lift_coe":
 "/-- The diagram describing the universal property for quotients of monoids commutes. -/\n@[simp, to_additive \"The diagram describing the universal property for quotients of `add_monoid`s\\ncommutes.\"]\ntheorem lift_coe (H : c ≤ ker f) (x : M) : c.lift f H x = f x :=\n  rfl\n#align lift_coe lift_coe\n\n",
 "lift_apply_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Given a homomorphism `f` from the quotient of a monoid by a congruence relation, `f` equals the\n    homomorphism on the quotient induced by `f` composed with the natural map from the monoid to\n    the quotient. -/\n@[simp,\n  to_additive\n      \"Given a homomorphism `f` from the quotient of an `add_monoid` by an additive\\ncongruence relation, `f` equals the homomorphism on the quotient induced by `f` composed with the\\nnatural map from the `add_monoid` to the quotient.\"]\ntheorem lift_apply_mk' (f : «expr →* » c.quotient P) :\n    (c.lift (f.comp c.mk') fun x y h => show f ↑x = f ↑y by rw [c.eq.2 h]) = f := by ext <;> rcases x with ⟨⟩ <;> rfl\n#align lift_apply_mk' lift_apply_mk'\n\n",
 "le_iff":
 "@[to_additive]\ntheorem le_iff {c d : Con M} : c ≤ d ↔ (c : Submonoid (M × M)) ≤ d :=\n  ⟨fun h x H => h H, fun h x y hc => h <| show (x, y) ∈ c from hc⟩\n#align le_iff le_iff\n\n",
 "le_def":
 "-- The complete lattice of congruence relations on a type\n/-- Definition of `≤` for congruence relations. -/\n@[to_additive \"Definition of `≤` for additive congruence relations.\"]\ntheorem le_def {c d : Con M} : c ≤ d ↔ ∀ {x y}, c x y → d x y :=\n  iff.rfl\n#align le_def le_def\n\n",
 "ker_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The definition of the congruence relation defined by a monoid homomorphism's kernel. -/\n@[simp,\n  to_additive \"The definition of the additive congruence relation defined by an `add_monoid`\\nhomomorphism's kernel.\"]\ntheorem ker_rel (f : «expr →* » M P) {x y} : ker f x y ↔ f x = f y :=\n  iff.rfl\n#align ker_rel ker_rel\n\n",
 "ker_lift_range_eq":
 "/-- Given a monoid homomorphism `f`, the induced homomorphism on the quotient by `f`'s kernel has\n    the same image as `f`. -/\n@[simp,\n  to_additive\n      \"Given an `add_monoid` homomorphism `f`, the induced homomorphism\\non the quotient by `f`'s kernel has the same image as `f`.\"]\ntheorem ker_lift_range_eq : (kerLift f).mrange = f.mrange :=\n  lift_range fun _ _ => id\n#align ker_lift_range_eq ker_lift_range_eq\n\n",
 "ker_lift_mk":
 "/-- The diagram described by the universal property for quotients of monoids, when the congruence\n    relation is the kernel of the homomorphism, commutes. -/\n@[simp,\n  to_additive\n      \"The diagram described by the universal property for quotients\\nof `add_monoid`s, when the additive congruence relation is the kernel of the homomorphism,\\ncommutes.\"]\ntheorem ker_lift_mk (x : M) : kerLift f x = f x :=\n  rfl\n#align ker_lift_mk ker_lift_mk\n\n",
 "ker_lift_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\n@[to_additive \"An `add_monoid` homomorphism `f` induces an injective homomorphism on the quotient\\nby `f`'s kernel.\"]\ntheorem ker_lift_injective (f : «expr →* » M P) : injective (kerLift f) := fun x y =>\n  Quotient.inductionOn₂' x y fun _ _ => (ker f).eq.2\n#align ker_lift_injective ker_lift_injective\n\n",
 "ker_eq_lift_of_injective":
 "/-- Given a monoid homomorphism `f` from `M` to `P`, the kernel of `f` is the unique congruence\n    relation on `M` whose induced map from the quotient of `M` to `P` is injective. -/\n@[to_additive\n      \"Given an `add_monoid` homomorphism `f` from `M` to `P`, the kernel of `f`\\nis the unique additive congruence relation on `M` whose induced map from the quotient of `M`\\nto `P` is injective.\"]\ntheorem ker_eq_lift_of_injective (H : c ≤ ker f) (h : injective (c.lift f H)) : ker f = c :=\n  toSetoid_inj <| ker_eq_lift_of_injective f H h\n#align ker_eq_lift_of_injective ker_eq_lift_of_injective\n\n",
 "ker_apply_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- The elements related to `x ∈ M`, `M` a monoid, by the kernel of a monoid homomorphism are\n    those in the preimage of `f(x)` under `f`. -/\n@[to_additive\n      \"The elements related to `x ∈ M`, `M` an `add_monoid`, by the kernel of\\nan `add_monoid` homomorphism are those in the preimage of `f(x)` under `f`. \"]\ntheorem ker_apply_eq_preimage {f : «expr →* » M P} (x) : (ker f) x = «expr ⁻¹' » f {f x} :=\n  Set.ext fun x =>\n    ⟨fun h => Set.mem_preimage.2 <| Set.mem_singleton_iff.2 h.symm, fun h =>\n      (Set.mem_singleton_iff.1 <| Set.mem_preimage.1 h).symm⟩\n#align ker_apply_eq_preimage ker_apply_eq_preimage\n\n",
 "inv":
 "/-- Multiplicative congruence relations preserve inversion. -/\n@[to_additive \"Additive congruence relations preserve negation.\"]\nprotected theorem inv : ∀ {w x}, c w x → c w⁻¹ x⁻¹ := fun x y h => by\n  simpa using c.symm (c.mul (c.mul (c.refl x⁻¹) h) (c.refl y⁻¹))\n#align inv inv\n\n",
 "inf_iff_and":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- Definition of the infimum of two congruence relations. -/\n@[to_additive \"Definition of the infimum of two additive congruence relations.\"]\ntheorem inf_iff_and {c d : Con M} {x y} : («expr ⊓ » c d) x y ↔ c x y ∧ d x y :=\n  iff.rfl\n#align inf_iff_and inf_iff_and\n\n",
 "inf_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- The infimum of two congruence relations equals the infimum of the underlying binary\n    operations. -/\n@[to_additive\n      \"The infimum of two additive congruence relations equals the infimum of the\\nunderlying binary operations.\"]\ntheorem inf_def {c d : Con M} : («expr ⊓ » c d).r = «expr ⊓ » c.r d.r :=\n  rfl\n#align inf_def inf_def\n\n",
 "induction_on₂":
 "/-- A version of `con.induction_on` for predicates which take two arguments. -/\n@[elab_as_elim, to_additive \"A version of `add_con.induction_on` for predicates which take\\ntwo arguments.\"]\nprotected theorem induction_on₂ {d : Con N} {C : c.quotient → d.quotient → Prop} (p : c.quotient) (q : d.quotient)\n    (H : ∀ (x : M) (y : N), C x y) : C p q :=\n  Quotient.inductionOn₂' p q H\n#align induction_on₂ induction_on₂\n\n",
 "induction_on_units":
 "@[elab_as_elim, to_additive]\ntheorem induction_on_units {p : Units c.quotient → Prop} (u : Units c.quotient)\n    (H : ∀ (x y : M) (hxy : c (x * y) 1) (hyx : c (y * x) 1), p ⟨x, y, c.eq.2 hxy, c.eq.2 hyx⟩) : p u :=\n  by\n  rcases u with ⟨⟨x⟩, ⟨y⟩, h₁, h₂⟩\n  exact H x y (c.eq.1 h₁) (c.eq.1 h₂)\n#align induction_on_units induction_on_units\n\n",
 "induction_on":
 "/-- The inductive principle used to prove propositions about the elements of a quotient by a\n    congruence relation. -/\n@[elab_as_elim,\n  to_additive\n      \"The inductive principle used to prove propositions about\\nthe elements of a quotient by an additive congruence relation.\"]\nprotected theorem induction_on {C : c.quotient → Prop} (q : c.quotient) (H : ∀ x : M, C x) : C q :=\n  Quotient.inductionOn' q H\n#align induction_on induction_on\n\n",
 "hrec_on₂_coe":
 "@[simp, to_additive]\ntheorem hrec_on₂_coe {cM : Con M} {cN : Con N} {φ : cM.quotient → cN.quotient → Sort _} (a : M) (b : N)\n    (f : ∀ (x : M) (y : N), φ x y) (h : ∀ x y x' y', cM x x' → cN y y' → HEq (f x y) (f x' y')) :\n    Con.hrecOn₂ (↑a) (↑b) f h = f a b :=\n  rfl\n#align hrec_on₂_coe hrec_on₂_coe\n\n",
 "ext_iff":
 "/-- Iff version of extensionality rule for congruence relations. -/\n@[to_additive \"Iff version of extensionality rule for additive congruence relations.\"]\ntheorem ext_iff {c d : Con M} : (∀ x y, c x y ↔ d x y) ↔ c = d :=\n  ⟨ext, fun h _ _ => h ▸ iff.rfl⟩\n#align ext_iff ext_iff\n\n",
 "ext'_iff":
 "/-- Two congruence relations are equal iff their underlying binary relations are equal. -/\n@[to_additive \"Two additive congruence relations are equal iff their underlying binary relations\\nare equal.\"]\ntheorem ext'_iff {c d : Con M} : c.r = d.r ↔ c = d :=\n  ⟨ext', fun h => h ▸ rfl⟩\n#align ext'_iff ext'_iff\n\n",
 "ext'":
 "/-- The map sending a congruence relation to its underlying binary relation is injective. -/\n@[to_additive \"The map sending an additive congruence relation to its underlying binary relation\\nis injective.\"]\ntheorem ext' {c d : Con M} (H : c.r = d.r) : c = d :=\n  by\n  rcases c with ⟨⟨⟩⟩\n  rcases d with ⟨⟨⟩⟩\n  cases H\n  congr\n#align ext' ext'\n\n",
 "ext":
 "/-- Extensionality rule for congruence relations. -/\n@[ext, to_additive \"Extensionality rule for additive congruence relations.\"]\ntheorem ext {c d : Con M} (H : ∀ x y, c x y ↔ d x y) : c = d :=\n  ext' <| by ext <;> apply H\n#align ext ext\n\n",
 "div":
 "/-- Multiplicative congruence relations preserve division. -/\n@[to_additive \"Additive congruence relations preserve subtraction.\"]\nprotected theorem div : ∀ {w x y z}, c w x → c y z → c (w / y) (x / z) := fun w x y z h1 h2 => by\n  simpa only [div_eq_mul_inv] using c.mul h1 (c.inv h2)\n#align div div\n\n",
 "con_gen_of_con":
 "/-- Congruence relations equal the smallest congruence relation in which they are contained. -/\n@[simp,\n  to_additive add_con_gen_of_add_con\n      \"Additive congruence relations equal the smallest\\nadditive congruence relation in which they are contained.\"]\ntheorem con_gen_of_con (c : Con M) : conGen c = c :=\n  le_antisymm (by rw [con_gen_eq] <;> exact infₛ_le fun _ _ => id) con_gen.rel.of\n#align con_gen_of_con con_gen_of_con\n\n",
 "con_gen_mono":
 "/-- Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation\n    containing `s` contains the smallest congruence relation containing `r`. -/\n@[to_additive add_con_gen_mono\n      \"Given binary relations `r, s` with `r` contained in `s`, the\\nsmallest additive congruence relation containing `s` contains the smallest additive congruence\\nrelation containing `r`.\"]\ntheorem con_gen_mono {r s : M → M → Prop} (h : ∀ x y, r x y → s x y) : conGen r ≤ conGen s :=\n  conGen_le fun x y hr => con_gen.rel.of _ _ <| h x y hr\n#align con_gen_mono con_gen_mono\n\n",
 "con_gen_le":
 "/-- The smallest congruence relation containing a binary relation `r` is contained in any\n    congruence relation containing `r`. -/\n@[to_additive add_con_gen_le\n      \"The smallest additive congruence relation containing a binary\\nrelation `r` is contained in any additive congruence relation containing `r`.\"]\ntheorem con_gen_le {r : M → M → Prop} {c : Con M} (h : ∀ x y, r x y → @Setoid.r _ c.to_setoid x y) : conGen r ≤ c := by\n  rw [con_gen_eq] <;> exact infₛ_le h\n#align con_gen_le con_gen_le\n\n",
 "con_gen_idem":
 "/-- The map sending a binary relation to the smallest congruence relation in which it is\n    contained is idempotent. -/\n@[simp,\n  to_additive add_con_gen_idem\n      \"The map sending a binary relation to the smallest additive\\ncongruence relation in which it is contained is idempotent.\"]\ntheorem con_gen_idem (r : M → M → Prop) : conGen (conGen r) = conGen r :=\n  conGen_of_con _\n#align con_gen_idem con_gen_idem\n\n",
 "con_gen_eq":
 "/-- The inductively defined smallest congruence relation containing a binary relation `r` equals\n    the infimum of the set of congruence relations containing `r`. -/\n@[to_additive add_con_gen_eq\n      \"The inductively defined smallest additive congruence relation\\ncontaining a binary relation `r` equals the infimum of the set of additive congruence relations\\ncontaining `r`.\"]\ntheorem con_gen_eq (r : M → M → Prop) : conGen r = infₛ { s : Con M | ∀ x y, r x y → s x y } :=\n  le_antisymm\n    (fun x y H =>\n      con_gen.rel.rec_on H (fun _ _ h _ hs => hs _ _ h) (Con.refl _) (fun _ _ _ => Con.symm _)\n        (fun _ _ _ _ _ => Con.trans _) fun w x y z _ _ h1 h2 c hc => c.mul (h1 c hc) <| h2 c hc)\n    (infₛ_le fun _ _ => con_gen.rel.of _ _)\n#align con_gen_eq con_gen_eq\n\n",
 "comap_rel":
 "@[simp, to_additive]\ntheorem comap_rel {f : M → N} (H : ∀ x y, f (x * y) = f x * f y) {c : Con N} {x y : M} :\n    comap f H c x y ↔ c (f x) (f y) :=\n  iff.rfl\n#align comap_rel comap_rel\n\n",
 "comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Given a monoid homomorphism `f : N → M` and a congruence relation `c` on `M`, the congruence\n    relation induced on `N` by `f` equals the kernel of `c`'s quotient homomorphism composed with\n    `f`. -/\n@[to_additive\n      \"Given an `add_monoid` homomorphism `f : N → M` and an additive congruence relation\\n`c` on `M`, the additive congruence relation induced on `N` by `f` equals the kernel of `c`'s\\nquotient homomorphism composed with `f`.\"]\ntheorem comap_eq {f : «expr →* » N M} : comap f f.map_mul c = ker (c.mk'.comp f) :=\n  ext fun x y => show c _ _ ↔ c.mk' _ = c.mk' _ by rw [← c.eq] <;> rfl\n#align comap_eq comap_eq\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem coe_smul {α M : Type _} [MulOneClass M] [SMul α M] [IsScalarTower α M M] (c : Con M) (a : α) (x : M) :\n    (↑(«expr • » a x) : c.quotient) = «expr • » a ↑x :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_one":
 "/-- The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the\n    monoid's 1. -/\n@[simp,\n  to_additive\n      \"The 0 of the quotient of an `add_monoid` by an additive congruence relation\\nis the equivalence class of the `add_monoid`'s 0.\"]\ntheorem coe_one : ((1 : M) : c.quotient) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_mul":
 "/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\n    definition). -/\n@[simp,\n  to_additive\n      \"The coercion to the quotient of an additive congruence relation commutes with\\naddition (by definition).\"]\ntheorem coe_mul (x y : M) : (↑(x * y) : c.quotient) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk'":
 "@[simp, to_additive]\ntheorem coe_mk' : (c.mk' : M → c.quotient) = coe :=\n  rfl\n#align coe_mk' coe_mk'\n\n",
 "Sup_eq_con_gen":
 "/-- The supremum of a set of congruence relations `S` equals the smallest congruence relation\n    containing the binary relation 'there exists `c ∈ S` such that `x` is related to `y` by\n    `c`'. -/\n@[to_additive Sup_eq_add_con_gen\n      \"The supremum of a set of additive congruence relations `S` equals\\nthe smallest additive congruence relation containing the binary relation 'there exists `c ∈ S`\\nsuch that `x` is related to `y` by `c`'.\"]\ntheorem Sup_eq_con_gen (S : Set (Con M)) : supₛ S = conGen fun x y => ∃ c : Con M, c ∈ S ∧ c x y :=\n  by\n  rw [con_gen_eq]\n  apply congr_arg Inf\n  ext\n  exact ⟨fun h _ _ ⟨r, hr⟩ => h hr.1 hr.2, fun h r hS _ _ hr => h _ _ ⟨r, hS, hr⟩⟩\n#align Sup_eq_con_gen Sup_eq_con_gen\n\n",
 "Sup_def":
 "/-- The supremum of a set of congruence relations is the same as the smallest congruence relation\n    containing the supremum of the set's image under the map to the underlying binary relation. -/\n@[to_additive\n      \"The supremum of a set of additive congruence relations is the same as the smallest\\nadditive congruence relation containing the supremum of the set's image under the map to the\\nunderlying binary relation.\"]\ntheorem Sup_def {S : Set (Con M)} : supₛ S = conGen (supₛ (@Set.image (Con M) (M → M → Prop) coe_fn S)) :=\n  by\n  rw [Sup_eq_con_gen, supₛ_image]\n  congr with (x y)\n  simp only [supₛ_image, supᵢ_apply, supᵢ_Prop_eq, exists_prop, rel_eq_coe]\n#align Sup_def Sup_def\n\n",
 "Inf_to_setoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The infimum of a set of congruence relations is the same as the infimum of the set's image\n    under the map to the underlying equivalence relation. -/\n@[to_additive\n      \"The infimum of a set of additive congruence relations is the same as the infimum of\\nthe set's image under the map to the underlying equivalence relation.\"]\ntheorem Inf_to_setoid (S : Set (Con M)) : (infₛ S).to_setoid = infₛ («expr '' » to_setoid S) :=\n  Setoid.ext' fun x y =>\n    ⟨fun h r ⟨c, hS, hr⟩ => by rw [← hr] <;> exact h c hS, fun h c hS => h c.to_setoid ⟨c, hS, rfl⟩⟩\n#align Inf_to_setoid Inf_to_setoid\n\n",
 "Inf_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-- The infimum of a set of congruence relations is the same as the infimum of the set's image\n    under the map to the underlying binary relation. -/\n@[to_additive\n      \"The infimum of a set of additive congruence relations is the same as the infimum\\nof the set's image under the map to the underlying binary relation.\"]\ntheorem Inf_def (S : Set (Con M)) : «expr⇑ » (infₛ S) = infₛ (@Set.image (Con M) (M → M → Prop) coe_fn S) :=\n  by\n  ext\n  simp only [infₛ_image, infᵢ_apply, infᵢ_Prop_eq]\n  rfl\n#align Inf_def Inf_def\n\n",
 "Eq":
 "#print Eq /-\n/-- Two elements are related by a congruence relation `c` iff they are represented by the same\n    element of the quotient by `c`. -/\n@[simp,\n  to_additive\n      \"Two elements are related by an additive congruence relation `c` iff they\\nare represented by the same element of the quotient by `c`.\"]\nprotected theorem Eq {a b : M} : (a : c.quotient) = b ↔ c a b :=\n  Quotient.eq''\n#align eq Eq\n-/\n\n"}