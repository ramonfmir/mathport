{"univ_perm_fin_succ":
 "/-- The set of all permutations of `fin (n + 1)` can be constructed by augmenting the set of\npermutations of `fin n` by each element of `fin (n + 1)` in turn. -/\ntheorem finset.univ_perm_fin_succ {n : ℕ} :\n    @finset.univ (perm <| fin n.succ) _ =\n      (finset.univ : Finset <| fin n.succ × perm (fin n)).map equiv.perm.decompose_fin.symm.to_embedding :=\n  (finset.univ_map_equiv_to_embedding _).symm\n#align finset.univ_perm_fin_succ finset.univ_perm_fin_succ\n\n",
 "symm_sign":
 "@[simp]\ntheorem equiv.perm.decompose_fin.symm_sign {n : ℕ} (p : fin (n + 1)) (e : perm (fin n)) :\n    perm.sign (equiv.perm.decompose_fin.symm (p, e)) = ite (p = 0) 1 (-1) * perm.sign e := by\n  refine' Fin.cases _ _ p <;> simp [equiv.perm.decompose_fin, Fin.succ_ne_zero]\n#align equiv.perm.decompose_fin.symm_sign equiv.perm.decompose_fin.symm_sign\n\n",
 "support_fin_rotate_of_le":
 "theorem support_fin_rotate_of_le {n : ℕ} (h : 2 ≤ n) : support (fin_rotate n) = finset.univ :=\n  by\n  obtain ⟨m, rfl⟩ := exists_add_of_le h\n  rw [add_comm, support_fin_rotate]\n#align support_fin_rotate_of_le support_fin_rotate_of_le\n\n",
 "support_fin_rotate":
 "@[simp]\ntheorem support_fin_rotate {n : ℕ} : support (fin_rotate (n + 2)) = finset.univ :=\n  by\n  ext\n  simp\n#align support_fin_rotate support_fin_rotate\n\n",
 "succ_above_cycle_range":
 "@[simp]\ntheorem succ_above_cycle_range {n : ℕ} (i j : fin n) : i.succ.succ_above (i.cycle_range j) = swap 0 i.succ j.succ :=\n  by\n  cases n\n  · rcases j with ⟨_, ⟨⟩⟩\n  rcases lt_trichotomy j i with (hlt | heq | hgt)\n  · have : (j + 1).cast_succ = j.succ := by\n      ext\n      rw [coe_cast_succ, coe_succ, Fin.val_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)]\n    rw [fin.cycle_range_of_lt hlt, Fin.succAbove_below, this, swap_apply_of_ne_of_ne]\n    · apply Fin.succ_ne_zero\n    · exact (Fin.succ_injective _).ne hlt.ne\n    · rw [Fin.lt_iff_val_lt_val]\n      simpa [this] using hlt\n  · rw [HEq, fin.cycle_range_self, Fin.succAbove_below, swap_apply_right, Fin.castSucc_zero]\n    · rw [Fin.castSucc_zero]\n      apply Fin.succ_pos\n  · rw [fin.cycle_range_of_gt hgt, Fin.succAbove_above, swap_apply_of_ne_of_ne]\n    · apply Fin.succ_ne_zero\n    · apply (Fin.succ_injective _).ne hgt.ne.symm\n    · simpa [Fin.le_iff_val_le_val] using hgt\n#align succ_above_cycle_range succ_above_cycle_range\n\n",
 "sign_fin_rotate":
 "@[simp]\ntheorem sign_fin_rotate (n : ℕ) : perm.sign (fin_rotate (n + 1)) = (-1) ^ n :=\n  by\n  induction' n with n ih\n  · simp\n  · rw [fin_rotate_succ]\n    simp [ih, pow_succ]\n#align sign_fin_rotate sign_fin_rotate\n\n",
 "sign_cycle_range":
 "@[simp]\ntheorem sign_cycle_range {n : ℕ} (i : fin n) : perm.sign (cycle_range i) = (-1) ^ (i : ℕ) := by simp [cycle_range]\n#align sign_cycle_range sign_cycle_range\n\n",
 "is_three_cycle_cycle_range_two":
 "theorem is_three_cycle_cycle_range_two {n : ℕ} : is_three_cycle (cycle_range 2 : perm (fin (n + 3))) := by\n  rw [is_three_cycle, cycle_type_cycle_range] <;> decide\n#align is_three_cycle_cycle_range_two is_three_cycle_cycle_range_two\n\n",
 "is_cycle_fin_rotate_of_le":
 "theorem is_cycle_fin_rotate_of_le {n : ℕ} (h : 2 ≤ n) : is_cycle (fin_rotate n) :=\n  by\n  obtain ⟨m, rfl⟩ := exists_add_of_le h\n  rw [add_comm]\n  exact is_cycle_fin_rotate\n#align is_cycle_fin_rotate_of_le is_cycle_fin_rotate_of_le\n\n",
 "is_cycle_fin_rotate":
 "theorem is_cycle_fin_rotate {n : ℕ} : is_cycle (fin_rotate (n + 2)) :=\n  by\n  refine' ⟨0, by decide, fun x hx' => ⟨x, _⟩⟩\n  clear hx'\n  cases' x with x hx\n  rw [coe_coe, zpow_ofNat, Fin.ext_iff, Fin.val_mk]\n  induction' x with x ih; · rfl\n  rw [pow_succ, perm.mul_apply, coe_fin_rotate_of_ne_last, ih (lt_trans x.lt_succ_self hx)]\n  rw [ne.def, Fin.ext_iff, ih (lt_trans x.lt_succ_self hx), Fin.val_last]\n  exact ne_of_lt (nat.lt_of_succ_lt_succ hx)\n#align is_cycle_fin_rotate is_cycle_fin_rotate\n\n",
 "is_cycle_cycle_range":
 "theorem is_cycle_cycle_range {n : ℕ} {i : fin (n + 1)} (h0 : i ≠ 0) : is_cycle (cycle_range i) :=\n  by\n  cases' i with i hi\n  cases i\n  · exact (h0 rfl).elim\n  exact is_cycle_fin_rotate.extend_domain _\n#align is_cycle_cycle_range is_cycle_cycle_range\n\n",
 "fin_rotate_succ":
 "theorem fin_rotate_succ {n : ℕ} : fin_rotate n.succ = decompose_fin.symm (1, fin_rotate n) :=\n  by\n  ext i\n  cases n; · simp\n  refine' Fin.cases _ (fun i => _) i\n  · simp\n  rw [coe_fin_rotate, decompose_fin_symm_apply_succ, if_congr i.succ_eq_last_succ rfl rfl]\n  split_ifs with h\n  · simp [h]\n  ·\n    rw [Fin.val_succ, Function.Injective.map_swap Fin.val_injective, Fin.val_succ, coe_fin_rotate, if_neg h,\n      Fin.val_zero, Fin.val_one, swap_apply_of_ne_of_ne (nat.succ_ne_zero _) (Nat.succ_succ_ne_one _)]\n#align fin_rotate_succ fin_rotate_succ\n\n",
 "decompose_fin_symm_of_refl":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp]\ntheorem equiv.perm.decompose_fin_symm_of_refl {n : ℕ} (p : fin (n + 1)) :\n    equiv.perm.decompose_fin.symm (p, equiv.refl _) = swap 0 p := by\n  simp [equiv.perm.decompose_fin, Equiv.permCongr_def]\n#align equiv.perm.decompose_fin_symm_of_refl equiv.perm.decompose_fin_symm_of_refl\n\n",
 "decompose_fin_symm_of_one":
 "@[simp]\ntheorem equiv.perm.decompose_fin_symm_of_one {n : ℕ} (p : fin (n + 1)) :\n    equiv.perm.decompose_fin.symm (p, 1) = swap 0 p :=\n  equiv.perm.decompose_fin_symm_of_refl p\n#align equiv.perm.decompose_fin_symm_of_one equiv.perm.decompose_fin_symm_of_one\n\n",
 "decompose_fin_symm_apply_zero":
 "@[simp]\ntheorem equiv.perm.decompose_fin_symm_apply_zero {n : ℕ} (p : fin (n + 1)) (e : perm (fin n)) :\n    equiv.perm.decompose_fin.symm (p, e) 0 = p := by simp [equiv.perm.decompose_fin]\n#align equiv.perm.decompose_fin_symm_apply_zero equiv.perm.decompose_fin_symm_apply_zero\n\n",
 "decompose_fin_symm_apply_succ":
 "@[simp]\ntheorem equiv.perm.decompose_fin_symm_apply_succ {n : ℕ} (e : perm (fin n)) (p : fin (n + 1)) (x : fin n) :\n    equiv.perm.decompose_fin.symm (p, e) x.succ = swap 0 p (e x).succ :=\n  by\n  refine' Fin.cases _ _ p\n  · simp [equiv.perm.decompose_fin, equiv_functor.map]\n  · intro i\n    by_cases h : i = e x\n    · simp [h, equiv.perm.decompose_fin, equiv_functor.map]\n    · have h' : some (e x) ≠ some i := fun H => h (option.some_injective _ H).symm\n      have h'' : (e x).succ ≠ i.succ := fun H => h (Fin.succ_injective _ H).symm\n      simp [h, h'', Fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne,\n        swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h']\n#align equiv.perm.decompose_fin_symm_apply_succ equiv.perm.decompose_fin_symm_apply_succ\n\n",
 "decompose_fin_symm_apply_one":
 "@[simp]\ntheorem equiv.perm.decompose_fin_symm_apply_one {n : ℕ} (e : perm (fin (n + 1))) (p : fin (n + 2)) :\n    equiv.perm.decompose_fin.symm (p, e) 1 = swap 0 p (e 0).succ := by\n  rw [← Fin.succ_zero_eq_one, equiv.perm.decompose_fin_symm_apply_succ e p 0]\n#align equiv.perm.decompose_fin_symm_apply_one equiv.perm.decompose_fin_symm_apply_one\n\n",
 "cycle_type_fin_rotate_of_le":
 "theorem cycle_type_fin_rotate_of_le {n : ℕ} (h : 2 ≤ n) : cycle_type (fin_rotate n) = {n} :=\n  by\n  obtain ⟨m, rfl⟩ := exists_add_of_le h\n  rw [add_comm, cycle_type_fin_rotate]\n#align cycle_type_fin_rotate_of_le cycle_type_fin_rotate_of_le\n\n",
 "cycle_type_fin_rotate":
 "@[simp]\ntheorem cycle_type_fin_rotate {n : ℕ} : cycle_type (fin_rotate (n + 2)) = {n + 2} :=\n  by\n  rw [is_cycle_fin_rotate.cycle_type, support_fin_rotate, ← fintype.card, fintype.card_fin]\n  rfl\n#align cycle_type_fin_rotate cycle_type_fin_rotate\n\n",
 "cycle_type_cycle_range":
 "@[simp]\ntheorem cycle_type_cycle_range {n : ℕ} {i : fin (n + 1)} (h0 : i ≠ 0) : cycle_type (cycle_range i) = {i + 1} :=\n  by\n  cases' i with i hi\n  cases i\n  · exact (h0 rfl).elim\n  rw [cycle_range, cycle_type_extend_domain]\n  exact cycle_type_fin_rotate\n#align cycle_type_cycle_range cycle_type_cycle_range\n\n",
 "cycle_range_zero'":
 "@[simp]\ntheorem cycle_range_zero' {n : ℕ} (h : 0 < n) : cycle_range ⟨0, h⟩ = 1 :=\n  by\n  cases' n with n\n  · cases h\n  exact cycle_range_zero n\n#align cycle_range_zero' cycle_range_zero'\n\n",
 "cycle_range_zero":
 "@[simp]\ntheorem cycle_range_zero (n : ℕ) : cycle_range (0 : fin n.succ) = 1 :=\n  by\n  ext j\n  refine' Fin.cases _ (fun j => _) j\n  · simp\n  · rw [cycle_range_of_gt (Fin.succ_pos j), one_apply]\n#align cycle_range_zero cycle_range_zero\n\n",
 "cycle_range_symm_zero":
 "@[simp]\ntheorem cycle_range_symm_zero {n : ℕ} (i : fin (n + 1)) : i.cycle_range.symm 0 = i :=\n  i.cycle_range.injective (by simp)\n#align cycle_range_symm_zero cycle_range_symm_zero\n\n",
 "cycle_range_symm_succ":
 "@[simp]\ntheorem cycle_range_symm_succ {n : ℕ} (i : fin (n + 1)) (j : fin n) : i.cycle_range.symm j.succ = i.succ_above j :=\n  i.cycle_range.injective (by simp)\n#align cycle_range_symm_succ cycle_range_symm_succ\n\n",
 "cycle_range_succ_above":
 "@[simp]\ntheorem cycle_range_succ_above {n : ℕ} (i : fin (n + 1)) (j : fin n) : i.cycle_range (i.succ_above j) = j.succ :=\n  by\n  cases' lt_or_ge j.cast_succ i with h h\n  · rw [Fin.succAbove_below _ _ h, fin.cycle_range_of_lt h, Fin.coeSucc_eq_succ]\n  · rw [Fin.succAbove_above _ _ h, fin.cycle_range_of_gt (fin.le_cast_succ_iff.mp h)]\n#align cycle_range_succ_above cycle_range_succ_above\n\n",
 "cycle_range_self":
 "@[simp]\ntheorem cycle_range_self {n : ℕ} (i : fin n.succ) : cycle_range i i = 0 :=\n  cycle_range_of_eq rfl\n#align cycle_range_self cycle_range_self\n\n",
 "cycle_range_of_lt":
 "theorem cycle_range_of_lt {n : ℕ} {i j : fin n.succ} (h : j < i) : cycle_range i j = j + 1 := by\n  rw [cycle_range_of_le h.le, if_neg h.ne]\n#align cycle_range_of_lt cycle_range_of_lt\n\n",
 "cycle_range_of_le":
 "theorem cycle_range_of_le {n : ℕ} {i j : fin n.succ} (h : j ≤ i) : cycle_range i j = if j = i then 0 else j + 1 :=\n  by\n  cases n\n  · simp\n  have : j = (Fin.castLe (nat.succ_le_of_lt i.is_lt)).to_embedding ⟨j, lt_of_le_of_lt h (nat.lt_succ_self i)⟩ := by simp\n  ext\n  rw [this, cycle_range, of_left_inverse'_eq_of_injective, ← function.embedding.to_equiv_range_eq_of_injective, ←\n    via_fintype_embedding, via_fintype_embedding_apply_image, rel_embedding.coe_fn_to_embedding, coe_cast_le,\n    coe_fin_rotate]\n  simp only [Fin.ext_iff, coe_last, coe_mk, coe_zero, Fin.eta, apply_ite coe, cast_le_mk]\n  split_ifs with heq\n  · rfl\n  · rw [Fin.val_add_one_of_lt]\n    exact lt_of_lt_of_le (lt_of_le_of_ne h (mt (congr_arg coe) HEq)) (le_last i)\n#align cycle_range_of_le cycle_range_of_le\n\n",
 "cycle_range_of_gt":
 "theorem cycle_range_of_gt {n : ℕ} {i j : fin n.succ} (h : i < j) : cycle_range i j = j :=\n  by\n  rw [cycle_range, of_left_inverse'_eq_of_injective, ← function.embedding.to_equiv_range_eq_of_injective, ←\n    via_fintype_embedding, via_fintype_embedding_apply_not_mem_range]\n  simpa\n#align cycle_range_of_gt cycle_range_of_gt\n\n",
 "cycle_range_of_eq":
 "theorem cycle_range_of_eq {n : ℕ} {i j : fin n.succ} (h : j = i) : cycle_range i j = 0 := by\n  rw [cycle_range_of_le h.le, if_pos h]\n#align cycle_range_of_eq cycle_range_of_eq\n\n",
 "cycle_range_last":
 "@[simp]\ntheorem cycle_range_last (n : ℕ) : cycle_range (last n) = fin_rotate (n + 1) :=\n  by\n  ext i\n  rw [coe_cycle_range_of_le (le_last _), coe_fin_rotate]\n#align cycle_range_last cycle_range_last\n\n",
 "cycle_range_apply":
 "theorem cycle_range_apply {n : ℕ} (i j : fin n.succ) :\n    cycle_range i j = if j < i then j + 1 else if j = i then 0 else j :=\n  by\n  split_ifs with h₁ h₂\n  · exact cycle_range_of_lt h₁\n  · exact cycle_range_of_eq h₂\n  · exact cycle_range_of_gt (lt_of_le_of_ne (le_of_not_gt h₁) (ne.symm h₂))\n#align cycle_range_apply cycle_range_apply\n\n",
 "coe_cycle_range_of_lt":
 "theorem coe_cycle_range_of_lt {n : ℕ} {i j : fin n.succ} (h : j < i) : (cycle_range i j : ℕ) = j + 1 := by\n  rw [coe_cycle_range_of_le h.le, if_neg h.ne]\n#align coe_cycle_range_of_lt coe_cycle_range_of_lt\n\n",
 "coe_cycle_range_of_le":
 "theorem coe_cycle_range_of_le {n : ℕ} {i j : fin n.succ} (h : j ≤ i) :\n    (cycle_range i j : ℕ) = if j = i then 0 else j + 1 :=\n  by\n  rw [cycle_range_of_le h]\n  split_ifs with h'\n  · rfl\n  exact\n    coe_add_one_of_lt\n      (calc\n        (j : ℕ) < i := fin.lt_iff_coe_lt_coe.mp (lt_of_le_of_ne h h')\n        _ ≤ n := nat.lt_succ_iff.mp i.2\n        )\n#align coe_cycle_range_of_le coe_cycle_range_of_le\n\n"}