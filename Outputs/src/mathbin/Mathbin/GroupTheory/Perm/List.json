{"zip_with_swap_prod_support'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem zip_with_swap_prod_support' (l l' : list α) :\n    { x | (zip_with swap l l').prod x ≠ x } ≤ «expr ⊔ » l.to_finset l'.to_finset :=\n  by\n  simp only [Set.sup_eq_union, Set.le_eq_subset]\n  induction' l with y l hl generalizing l'\n  · simp\n  · cases' l' with z l'\n    · simp\n    · intro x\n      simp only [Set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply]\n      intro hx\n      by_cases h : x ∈ { x | (zip_with swap l l').prod x ≠ x }\n      · specialize hl l' h\n        refine' Set.MemUnion.elim hl (fun hm => _) fun hm => _ <;>\n          · simp only [Finset.coe_insert, Set.mem_insert_iff, Finset.mem_coe, to_finset_cons, mem_to_finset] at hm⊢\n            simp [hm]\n      · simp only [not_not, Set.mem_setOf_eq] at h\n        simp only [h, Set.mem_setOf_eq] at hx\n        rw [swap_apply_ne_self_iff] at hx\n        rcases hx with ⟨hyz, rfl | rfl⟩ <;> simp\n#align zip_with_swap_prod_support' zip_with_swap_prod_support'\n\n",
 "zip_with_swap_prod_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem zip_with_swap_prod_support [fintype α] (l l' : list α) :\n    (zip_with swap l l').prod.support ≤ «expr ⊔ » l.to_finset l'.to_finset :=\n  by\n  intro x hx\n  have hx' : x ∈ { x | (zip_with swap l l').prod x ≠ x } := by simpa using hx\n  simpa using zip_with_swap_prod_support' _ _ hx'\n#align zip_with_swap_prod_support zip_with_swap_prod_support\n\n",
 "support_form_perm_of_nodup'":
 "theorem support_form_perm_of_nodup' (l : list α) (h : Nodup l) (h' : ∀ x : α, l ≠ [x]) :\n    { x | form_perm l x ≠ x } = l.to_finset := by\n  apply le_antisymm\n  · exact support_form_perm_le' l\n  · intro x hx\n    simp only [Finset.mem_coe, mem_to_finset] at hx\n    obtain ⟨n, hn, rfl⟩ := nth_le_of_mem hx\n    rw [Set.mem_setOf_eq, form_perm_apply_nth_le _ h]\n    intro H\n    rw [nodup_iff_nth_le_inj] at h\n    specialize h _ _ _ _ H\n    cases' (nat.succ_le_of_lt hn).eq_or_lt with hn' hn'\n    · simp only [← hn', nat.mod_self] at h\n      refine' not_exists.mpr h' _\n      simpa [← h, eq_comm, length_eq_one] using hn'\n    · simpa [nat.mod_eq_of_lt hn'] using h\n#align support_form_perm_of_nodup' support_form_perm_of_nodup'\n\n",
 "support_form_perm_of_nodup":
 "theorem support_form_perm_of_nodup [fintype α] (l : list α) (h : Nodup l) (h' : ∀ x : α, l ≠ [x]) :\n    support (form_perm l) = l.to_finset := by\n  rw [← Finset.coe_inj]\n  convert support_form_perm_of_nodup' _ h h'\n  simp [Set.ext_iff]\n#align support_form_perm_of_nodup support_form_perm_of_nodup\n\n",
 "support_form_perm_le'":
 "theorem support_form_perm_le' : { x | form_perm l x ≠ x } ≤ l.to_finset :=\n  by\n  refine' (zip_with_swap_prod_support' l l.tail).trans _\n  simpa [Finset.subset_iff] using tail_subset l\n#align support_form_perm_le' support_form_perm_le'\n\n",
 "support_form_perm_le":
 "theorem support_form_perm_le [fintype α] : support (form_perm l) ≤ l.to_finset :=\n  by\n  intro x hx\n  have hx' : x ∈ { x | form_perm l x ≠ x } := by simpa using hx\n  simpa using support_form_perm_le' _ hx'\n#align support_form_perm_le support_form_perm_le\n\n",
 "mem_of_form_perm_ne_self":
 "theorem mem_of_form_perm_ne_self (l : list α) (x : α) (h : form_perm l x ≠ x) : x ∈ l :=\n  by\n  suffices x ∈ { y | form_perm l y ≠ y } by\n    rw [← mem_to_finset]\n    exact support_form_perm_le' _ this\n  simpa using h\n#align mem_of_form_perm_ne_self mem_of_form_perm_ne_self\n\n",
 "mem_of_form_perm_apply_ne":
 "theorem mem_of_form_perm_apply_ne (x : α) (l : list α) : l.form_perm x ≠ x → x ∈ l :=\n  not_imp_comm.2 <| list.form_perm_apply_of_not_mem _ _\n#align mem_of_form_perm_apply_ne mem_of_form_perm_apply_ne\n\n",
 "mem_of_form_perm_apply_mem":
 "theorem mem_of_form_perm_apply_mem (x : α) (l : list α) (h : l.form_perm x ∈ l) : x ∈ l :=\n  by\n  cases' l with y l\n  · simpa\n  induction' l with z l IH generalizing x y\n  · simpa using h\n  · by_cases hx : (z :: l).form_perm x ∈ z :: l\n    · rw [list.form_perm_cons_cons, mul_apply, swap_apply_def] at h\n      split_ifs  at h <;> simp [IH _ _ hx]\n    · replace hx := (function.injective.eq_iff (Equiv.injective _)).mp (list.form_perm_apply_of_not_mem _ _ hx)\n      simp only [list.form_perm_cons_cons, hx, Equiv.Perm.coe_mul, Function.comp_apply, List.mem_cons, swap_apply_def,\n        ite_eq_left_iff] at h\n      simp only [List.mem_cons]\n      obtain h | h | h := h <;> · split_ifs  at h <;> cc\n#align mem_of_form_perm_apply_mem mem_of_form_perm_apply_mem\n\n",
 "form_perm_zpow_apply_mem_imp_mem":
 "theorem form_perm_zpow_apply_mem_imp_mem (l : list α) (x : α) (hx : x ∈ l) (n : ℤ) : (form_perm l ^ n) x ∈ l :=\n  by\n  by_cases h : (l.form_perm ^ n) x = x\n  · simpa [h] using hx\n  · have : x ∈ { x | (l.form_perm ^ n) x ≠ x } := h\n    rw [← set_support_apply_mem] at this\n    replace this := set_support_zpow_subset _ _ this\n    simpa using support_form_perm_le' _ this\n#align form_perm_zpow_apply_mem_imp_mem form_perm_zpow_apply_mem_imp_mem\n\n",
 "form_perm_singleton":
 "@[simp]\ntheorem form_perm_singleton (x : α) : form_perm [x] = 1 :=\n  rfl\n#align form_perm_singleton form_perm_singleton\n\n",
 "form_perm_rotate_one":
 "theorem form_perm_rotate_one (l : list α) (h : Nodup l) : form_perm (l.rotate 1) = form_perm l :=\n  by\n  have h' : nodup (l.rotate 1) := by simpa using h\n  ext x\n  by_cases hx : x ∈ l.rotate 1\n  · obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx\n    rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h]\n    simp\n  · rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem]\n    simpa using hx\n#align form_perm_rotate_one form_perm_rotate_one\n\n",
 "form_perm_rotate":
 "theorem form_perm_rotate (l : list α) (h : Nodup l) (n : ℕ) : form_perm (l.rotate n) = form_perm l :=\n  by\n  induction' n with n hn\n  · simp\n  · rw [nat.succ_eq_add_one, ← rotate_rotate, form_perm_rotate_one, hn]\n    rwa [is_rotated.nodup_iff]\n    exact is_rotated.forall l n\n#align form_perm_rotate form_perm_rotate\n\n",
 "form_perm_reverse":
 "theorem form_perm_reverse (l : list α) (h : Nodup l) : form_perm l.reverse = (form_perm l)⁻¹ :=\n  by\n  -- Let's show `form_perm l` is an inverse to `form_perm l.reverse`.\n  rw [eq_comm, inv_eq_iff_mul_eq_one]\n  ext x\n  -- We only have to check for `x ∈ l` that `form_perm l (form_perm l.reverse x)`\n  rw [mul_apply, one_apply]\n  by_cases hx : x ∈ l\n  swap\n  · rw [form_perm_apply_of_not_mem x l.reverse, form_perm_apply_of_not_mem _ _ hx]\n    simpa using hx\n  · obtain ⟨k, hk, rfl⟩ := nth_le_of_mem (mem_reverse.mpr hx)\n    rw [form_perm_apply_nth_le l.reverse (nodup_reverse.mpr h), nth_le_reverse', form_perm_apply_nth_le _ h,\n      nth_le_reverse']\n    · congr\n      rw [length_reverse, ← Nat.succ_le_iff, nat.succ_eq_add_one] at hk\n      cases' hk.eq_or_lt with hk' hk'\n      · simp [← hk']\n      · rw [length_reverse, nat.mod_eq_of_lt hk', tsub_add_eq_add_tsub (Nat.le_pred_of_lt hk'), nat.mod_eq_of_lt]\n        · simp\n        · rw [tsub_add_cancel_of_le]\n          refine' tsub_lt_self _ (nat.zero_lt_succ _)\n          all_goals simpa using (nat.zero_le _).trans_lt hk'\n    all_goals\n      rw [← tsub_add_eq_tsub_tsub, ← length_reverse]\n      refine' tsub_lt_self _ (zero_lt_one.trans_le (le_add_right le_rfl))\n      exact k.zero_le.trans_lt hk\n#align form_perm_reverse form_perm_reverse\n\n",
 "form_perm_pow_length_eq_one_of_nodup":
 "theorem form_perm_pow_length_eq_one_of_nodup (hl : Nodup l) : form_perm l ^ length l = 1 :=\n  by\n  ext x\n  by_cases hx : x ∈ l\n  · obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx\n    simp [form_perm_pow_apply_nth_le _ hl, nat.mod_eq_of_lt hk]\n  · have : x ∉ { x | (l.form_perm ^ l.length) x ≠ x } := by\n      intro H\n      refine' hx _\n      replace H := set_support_zpow_subset l.form_perm l.length H\n      simpa using support_form_perm_le' _ H\n    simpa\n#align form_perm_pow_length_eq_one_of_nodup form_perm_pow_length_eq_one_of_nodup\n\n",
 "form_perm_pow_apply_nth_le":
 "theorem form_perm_pow_apply_nth_le (l : list α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :\n    (form_perm l ^ n) (l.nth_le k hk) = l.nth_le ((k + n) % l.length) (nat.mod_lt _ (k.zero_le.trans_lt hk)) :=\n  by\n  induction' n with n hn\n  · simp [nat.mod_eq_of_lt hk]\n  · simp [pow_succ, mul_apply, hn, form_perm_apply_nth_le _ h, nat.succ_eq_add_one, ← nat.add_assoc]\n#align form_perm_pow_apply_nth_le form_perm_pow_apply_nth_le\n\n",
 "form_perm_pow_apply_head":
 "theorem form_perm_pow_apply_head (x : α) (l : list α) (h : Nodup (x :: l)) (n : ℕ) :\n    (form_perm (x :: l) ^ n) x = (x :: l).nth_le (n % (x :: l).length) (nat.mod_lt _ (nat.zero_lt_succ _)) := by\n  convert form_perm_pow_apply_nth_le _ h n 0 _ <;> simp\n#align form_perm_pow_apply_head form_perm_pow_apply_head\n\n",
 "form_perm_pair":
 "theorem form_perm_pair (x y : α) : form_perm [x, y] = swap x y :=\n  rfl\n#align form_perm_pair form_perm_pair\n\n",
 "form_perm_nil":
 "/-\nCopyright (c) 2021 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\n@[simp]\ntheorem form_perm_nil : form_perm ([] : list α) = 1 :=\n  rfl\n#align form_perm_nil form_perm_nil\n\n",
 "form_perm_mem_iff_mem":
 "theorem form_perm_mem_iff_mem : l.form_perm x ∈ l ↔ x ∈ l :=\n  ⟨l.mem_of_form_perm_apply_mem x, l.form_perm_apply_mem_of_mem x⟩\n#align form_perm_mem_iff_mem form_perm_mem_iff_mem\n\n",
 "form_perm_ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\ntheorem form_perm_ext_iff {x y x' y' : α} {l l' : list α} (hd : Nodup (x :: y :: l)) (hd' : Nodup (x' :: y' :: l')) :\n    form_perm (x :: y :: l) = form_perm (x' :: y' :: l') ↔ «expr ~r » (x :: y :: l) (x' :: y' :: l') :=\n  by\n  refine' ⟨fun h => _, fun hr => form_perm_eq_of_is_rotated hd hr⟩\n  rw [equiv.perm.ext_iff] at h\n  have hx : x' ∈ x :: y :: l :=\n    by\n    have : x' ∈ { z | form_perm (x :: y :: l) z ≠ z } :=\n      by\n      rw [Set.mem_setOf_eq, h x', form_perm_apply_head _ _ _ hd']\n      simp only [mem_cons_iff, nodup_cons] at hd'\n      push_neg  at hd'\n      exact hd'.left.left.symm\n    simpa using support_form_perm_le' _ this\n  obtain ⟨n, hn, hx'⟩ := nth_le_of_mem hx\n  have hl : (x :: y :: l).length = (x' :: y' :: l').length :=\n    by\n    rw [← dedup_eq_self.mpr hd, ← dedup_eq_self.mpr hd', ← card_to_finset, ← card_to_finset]\n    refine' congr_arg finset.card _\n    rw [← Finset.coe_inj, ← support_form_perm_of_nodup' _ hd (by simp), ← support_form_perm_of_nodup' _ hd' (by simp)]\n    simp only [h]\n  use n\n  apply List.ext_nthLe\n  · rw [length_rotate, hl]\n  · intro k hk hk'\n    rw [nth_le_rotate]\n    induction' k with k IH\n    · simp_rw [nat.zero_add, nat.mod_eq_of_lt hn]\n      simpa\n    · have : k.succ = (k + 1) % (x' :: y' :: l').length := by rw [← nat.succ_eq_add_one, nat.mod_eq_of_lt hk']\n      simp_rw [this]\n      rw [← form_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ← IH (k.lt_succ_self.trans hk), ← h,\n        form_perm_apply_nth_le _ hd]\n      congr 1\n      have h1 : 1 = 1 % (x' :: y' :: l').length := by simp\n      rw [hl, nat.mod_eq_of_lt hk', h1, ← Nat.add_mod, nat.succ_add]\n#align form_perm_ext_iff form_perm_ext_iff\n\n",
 "form_perm_eq_self_of_not_mem":
 "theorem form_perm_eq_self_of_not_mem (l : list α) (x : α) (h : x ∉ l) : form_perm l x = x :=\n  by_contra fun H => h <| mem_of_form_perm_ne_self _ _ H\n#align form_perm_eq_self_of_not_mem form_perm_eq_self_of_not_mem\n\n",
 "form_perm_eq_one_iff":
 "theorem form_perm_eq_one_iff (hl : Nodup l) : form_perm l = 1 ↔ l.length ≤ 1 :=\n  by\n  cases' l with hd tl\n  · simp\n  · rw [← form_perm_apply_mem_eq_self_iff _ hl hd (mem_cons_self _ _)]\n    constructor\n    · simp (config := { contextual := true })\n    · intro h\n      simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length,\n        nonpos_iff_eq_zero, length_eq_zero] at h\n      simp [h]\n#align form_perm_eq_one_iff form_perm_eq_one_iff\n\n",
 "form_perm_eq_of_is_rotated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\ntheorem form_perm_eq_of_is_rotated {l l' : list α} (hd : Nodup l) (h : «expr ~r » l l') : form_perm l = form_perm l' :=\n  by\n  obtain ⟨n, rfl⟩ := h\n  exact (form_perm_rotate l hd n).symm\n#align form_perm_eq_of_is_rotated form_perm_eq_of_is_rotated\n\n",
 "form_perm_eq_head_iff_eq_last":
 "theorem form_perm_eq_head_iff_eq_last (x y : α) : form_perm (y :: l) x = y ↔ x = getLast (y :: l) (cons_ne_nil _ _) :=\n  iff.trans (by rw [form_perm_apply_last]) (form_perm (y :: l)).injective.eq_iff\n#align form_perm_eq_head_iff_eq_last form_perm_eq_head_iff_eq_last\n\n",
 "form_perm_eq_form_perm_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\ntheorem form_perm_eq_form_perm_iff {l l' : list α} (hl : l.nodup) (hl' : l'.nodup) :\n    l.form_perm = l'.form_perm ↔ «expr ~r » l l' ∨ l.length ≤ 1 ∧ l'.length ≤ 1 :=\n  by\n  rcases l with (_ | ⟨x, _ | ⟨y, l⟩⟩)\n  · suffices l'.length ≤ 1 ↔ l' = nil ∨ l'.length ≤ 1 by simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero]\n    refine' ⟨fun h => or.inr h, _⟩\n    rintro (rfl | h)\n    · simp\n    · exact h\n  · suffices l'.length ≤ 1 ↔ «expr ~r » [x] l' ∨ l'.length ≤ 1 by\n      simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl]\n    refine' ⟨fun h => or.inr h, _⟩\n    rintro (h | h)\n    · simp [← h.perm.length_eq]\n    · exact h\n  · rcases l' with (_ | ⟨x', _ | ⟨y', l'⟩⟩)\n    · simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]\n    · suffices ¬«expr ~r » (x :: y :: l) [x'] by simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]\n      intro h\n      simpa using h.perm.length_eq\n    · simp [-form_perm_cons_cons, form_perm_ext_iff hl hl']\n#align form_perm_eq_form_perm_iff form_perm_eq_form_perm_iff\n\n",
 "form_perm_cons_cons":
 "@[simp]\ntheorem form_perm_cons_cons (x y : α) (l : list α) : form_perm (x :: y :: l) = swap x y * form_perm (y :: l) :=\n  prod_cons\n#align form_perm_cons_cons form_perm_cons_cons\n\n",
 "form_perm_cons_concat_apply_last":
 "@[simp]\ntheorem form_perm_cons_concat_apply_last (x y : α) (xs : list α) : form_perm (x :: (xs ++ [y])) y = x :=\n  by\n  induction' xs with z xs IH generalizing x y\n  · simp\n  · simp [IH]\n#align form_perm_cons_concat_apply_last form_perm_cons_concat_apply_last\n\n",
 "form_perm_apply_of_not_mem":
 "theorem form_perm_apply_of_not_mem (x : α) (l : list α) (h : x ∉ l) : form_perm l x = x :=\n  by\n  cases' l with y l\n  · simp\n  induction' l with z l IH generalizing x y\n  · simp\n  · specialize IH x z (mt (mem_cons_of_mem y) h)\n    simp only [not_or, mem_cons_iff] at h\n    simp [IH, swap_apply_of_ne_of_ne, h]\n#align form_perm_apply_of_not_mem form_perm_apply_of_not_mem\n\n",
 "form_perm_apply_nth_le_zero":
 "theorem form_perm_apply_nth_le_zero (l : list α) (h : Nodup l) (hl : 1 < l.length) :\n    form_perm l (l.nth_le 0 (zero_lt_one.trans hl)) = l.nth_le 1 hl :=\n  by\n  rcases l with (_ | ⟨x, _ | ⟨y, tl⟩⟩)\n  · simp\n  · simp\n  · simpa using form_perm_apply_head _ _ _ h\n#align form_perm_apply_nth_le_zero form_perm_apply_nth_le_zero\n\n",
 "form_perm_apply_nth_le_length":
 "@[simp]\ntheorem form_perm_apply_nth_le_length (x : α) (xs : list α) :\n    form_perm (x :: xs) ((x :: xs).nth_le xs.length (by simp)) = x := by\n  rw [nth_le_cons_length, form_perm_apply_last] <;> rfl\n#align form_perm_apply_nth_le_length form_perm_apply_nth_le_length\n\n",
 "form_perm_apply_nth_le":
 "theorem form_perm_apply_nth_le (xs : list α) (h : Nodup xs) (n : ℕ) (hn : n < xs.length) :\n    form_perm xs (xs.nth_le n hn) = xs.nth_le ((n + 1) % xs.length) (nat.mod_lt _ (n.zero_le.trans_lt hn)) :=\n  by\n  cases' xs with x xs\n  · simp\n  · have : n ≤ xs.length := by\n      refine' nat.le_of_lt_succ _\n      simpa using hn\n    rcases this.eq_or_lt with (rfl | hn')\n    · simp\n    · simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn']\n#align form_perm_apply_nth_le form_perm_apply_nth_le\n\n",
 "form_perm_apply_mem_of_mem":
 "theorem form_perm_apply_mem_of_mem (x : α) (l : list α) (h : x ∈ l) : form_perm l x ∈ l :=\n  by\n  cases' l with y l\n  · simpa\n  induction' l with z l IH generalizing x y\n  · simpa using h\n  · by_cases hx : x ∈ z :: l\n    · rw [form_perm_cons_cons, mul_apply, swap_apply_def]\n      split_ifs <;> simp [IH _ _ hx]\n    · replace h : x = y := or.resolve_right h hx\n      simp [form_perm_apply_of_not_mem _ _ hx, ← h]\n#align form_perm_apply_mem_of_mem form_perm_apply_mem_of_mem\n\n",
 "form_perm_apply_mem_ne_self_iff":
 "theorem form_perm_apply_mem_ne_self_iff (hl : Nodup l) (x : α) (hx : x ∈ l) : form_perm l x ≠ x ↔ 2 ≤ l.length :=\n  by\n  rw [ne.def, form_perm_apply_mem_eq_self_iff _ hl x hx, not_le]\n  exact ⟨nat.succ_le_of_lt, nat.lt_of_succ_le⟩\n#align form_perm_apply_mem_ne_self_iff form_perm_apply_mem_ne_self_iff\n\n",
 "form_perm_apply_mem_eq_self_iff":
 "theorem form_perm_apply_mem_eq_self_iff (hl : Nodup l) (x : α) (hx : x ∈ l) : form_perm l x = x ↔ length l ≤ 1 :=\n  by\n  obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx\n  rw [form_perm_apply_nth_le _ hl, hl.nth_le_inj_iff]\n  cases hn : l.length\n  · exact absurd k.zero_le (hk.trans_le hn.le).not_le\n  · rw [hn] at hk\n    cases' (nat.le_of_lt_succ hk).eq_or_lt with hk' hk'\n    · simp [← hk', nat.succ_le_succ_iff, eq_comm]\n    · simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), Nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk'\n#align form_perm_apply_mem_eq_self_iff form_perm_apply_mem_eq_self_iff\n\n",
 "form_perm_apply_lt":
 "theorem form_perm_apply_lt (xs : list α) (h : Nodup xs) (n : ℕ) (hn : n + 1 < xs.length) :\n    form_perm xs (xs.nth_le n ((nat.lt_succ_self n).trans hn)) = xs.nth_le (n + 1) hn :=\n  by\n  induction' n with n IH generalizing xs\n  · simpa using form_perm_apply_nth_le_zero _ h _\n  · rcases xs with (_ | ⟨x, _ | ⟨y, l⟩⟩)\n    · simp\n    · simp\n    · specialize IH (y :: l) h.of_cons _\n      · simpa [Nat.succ_lt_succ_iff] using hn\n      simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le]\n      generalize_proofs  at IH\n      rw [IH, swap_apply_of_ne_of_ne, nth_le] <;>\n        · rintro rfl\n          simpa [nth_le_mem _ _ _] using h\n#align form_perm_apply_lt form_perm_apply_lt\n\n",
 "form_perm_apply_last":
 "@[simp]\ntheorem form_perm_apply_last (x : α) (xs : list α) : form_perm (x :: xs) ((x :: xs).last (cons_ne_nil x xs)) = x := by\n  induction' xs using List.reverseRecOn with xs y IH generalizing x <;> simp\n#align form_perm_apply_last form_perm_apply_last\n\n",
 "form_perm_apply_head":
 "theorem form_perm_apply_head (x y : α) (xs : list α) (h : Nodup (x :: y :: xs)) : form_perm (x :: y :: xs) x = y := by\n  simp [form_perm_apply_of_not_mem _ _ h.not_mem]\n#align form_perm_apply_head form_perm_apply_head\n\n"}