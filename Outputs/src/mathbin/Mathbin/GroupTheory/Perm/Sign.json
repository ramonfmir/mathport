{"swap_induction_on'":
 "/-- Like `swap_induction_on`, but with the composition on the right of `f`.\n\nAn induction principle for permutations. If `P` holds for the identity permutation, and\nis preserved under composition with a non-trivial swap, then `P` holds for all permutations. -/\n@[elab_as_elim]\ntheorem swap_induction_on' [Finite α] {P : Perm α → Prop} (f : Perm α) :\n    P 1 → (∀ f x y, x ≠ y → P f → P (f * swap x y)) → P f := fun h1 IH =>\n  inv_inv f ▸ swap_induction_on f⁻¹ h1 fun f => IH f⁻¹\n#align swap_induction_on' swap_induction_on'\n\n",
 "swap_induction_on":
 "/-- An induction principle for permutations. If `P` holds for the identity permutation, and\nis preserved under composition with a non-trivial swap, then `P` holds for all permutations. -/\n@[elab_as_elim]\ntheorem swap_induction_on [Finite α] {P : Perm α → Prop} (f : Perm α) :\n    P 1 → (∀ f x y, x ≠ y → P f → P (swap x y * f)) → P f :=\n  by\n  cases nonempty_fintype α\n  cases' (trunc_swap_factors f).out with l hl\n  induction' l with g l ih generalizing f\n  · simp (config := { contextual := true }) only [hl.left.symm, List.prod_nil, forall_true_iff]\n  · intro h1 hmul_swap\n    rcases hl.2 g (by simp) with ⟨x, y, hxy⟩\n    rw [← hl.1, List.prod_cons, hxy.2]\n    exact hmul_swap _ _ _ hxy.1 (ih _ ⟨rfl, fun v hv => hl.2 _ (list.mem_cons_of_mem _ hv)⟩ h1 hmul_swap)\n#align swap_induction_on swap_induction_on\n\n",
 "support_pow_coprime":
 "theorem support_pow_coprime {σ : Perm α} {n : ℕ} (h : Nat.coprime n (orderOf σ)) : (σ ^ n).support = σ.support :=\n  by\n  obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h\n  exact le_antisymm (support_pow_le σ n) (le_trans (ge_of_eq (congr_arg support hm)) (support_pow_le (σ ^ n) m))\n#align support_pow_coprime support_pow_coprime\n\n",
 "subtype_perm_of_fintype_one":
 "@[simp]\ntheorem subtype_perm_of_fintype_one (p : α → Prop) [Fintype { x // p x }] (h : ∀ x, p x → p ((1 : Perm α) x)) :\n    @subtypePermOfFintype α 1 p _ h = 1 :=\n  Equiv.ext fun ⟨_, _⟩ => rfl\n#align subtype_perm_of_fintype_one subtype_perm_of_fintype_one\n\n",
 "subtype_perm_of_fintype_apply":
 "@[simp]\ntheorem subtype_perm_of_fintype_apply (f : Perm α) {p : α → Prop} [Fintype { x // p x }] (h : ∀ x, p x → p (f x))\n    (x : { x // p x }) : subtypePermOfFintype f h x = ⟨f x, h x x.2⟩ :=\n  rfl\n#align subtype_perm_of_fintype_apply subtype_perm_of_fintype_apply\n\n",
 "sign_trans_trans_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem sign_trans_trans_symm [DecidableEq β] [Fintype β] (f : Perm β) (e : «expr ≃ » α β) :\n    sign ((e.trans f).trans e.symm) = sign f :=\n  sign_symm_trans_trans f e.symm\n#align sign_trans_trans_symm sign_trans_trans_symm\n\n",
 "sign_trans":
 "@[simp]\ntheorem sign_trans (f g : Perm α) : sign (f.trans g) = sign g * sign f := by rw [← mul_def, sign_mul]\n#align sign_trans sign_trans\n\n",
 "sign_symm_trans_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem sign_symm_trans_trans [DecidableEq β] [Fintype β] (f : Perm α) (e : «expr ≃ » α β) :\n    sign ((e.symm.trans f).trans e) = sign f :=\n  signAux3_symm_trans_trans f e mem_univ mem_univ\n#align sign_symm_trans_trans sign_symm_trans_trans\n\n",
 "sign_symm":
 "@[simp]\ntheorem sign_symm (e : Perm α) : sign e.symm = sign e :=\n  sign_inv e\n#align sign_symm sign_symm\n\n",
 "sign_swap'":
 "@[simp]\ntheorem sign_swap' {x y : α} : (swap x y).sign = if x = y then 1 else -1 :=\n  if H : x = y then by simp [H, swap_self] else by simp [sign_swap H, H]\n#align sign_swap' sign_swap'\n\n",
 "sign_swap":
 "theorem sign_swap {x y : α} (h : x ≠ y) : sign (swap x y) = -1 :=\n  (signAux3_mul_and_swap 1 1 _ mem_univ).2 x y h\n#align sign_swap sign_swap\n\n",
 "sign_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem sign_surjective [Nontrivial α] : function.surjective (sign : Perm α → «expr ˣ» ℤ) := fun a =>\n  (Int.units_eq_one_or a).elim (fun h => ⟨1, by simp [h]⟩) fun h =>\n    let ⟨x, y, hxy⟩ := exists_pair_ne α\n    ⟨swap x y, by rw [sign_swap hxy, h]⟩\n#align sign_surjective sign_surjective\n\n",
 "sign_sum_congr":
 "@[simp]\ntheorem sign_sum_congr (σa : Perm α) (σb : Perm β) : (sumCongr σa σb).sign = σa.sign * σb.sign :=\n  by\n  suffices (sum_congr σa (1 : perm β)).sign = σa.sign ∧ (sum_congr (1 : perm α) σb).sign = σb.sign by\n    rw [← this.1, ← this.2, ← sign_mul, sum_congr_mul, one_mul, mul_one]\n  constructor\n  · apply σa.swap_induction_on _ fun σa' a₁ a₂ ha ih => _\n    · simp\n    ·\n      rw [← one_mul (1 : perm β), ← sum_congr_mul, sign_mul, sign_mul, ih, sum_congr_swap_one, sign_swap ha,\n        sign_swap (sum.inl_injective.ne_iff.mpr ha)]\n  · apply σb.swap_induction_on _ fun σb' b₁ b₂ hb ih => _\n    · simp\n    ·\n      rw [← one_mul (1 : perm α), ← sum_congr_mul, sign_mul, sign_mul, ih, sum_congr_one_swap, sign_swap hb,\n        sign_swap (sum.inr_injective.ne_iff.mpr hb)]\n#align sign_sum_congr sign_sum_congr\n\n",
 "sign_subtype_perm":
 "theorem sign_subtype_perm (f : Perm α) {p : α → Prop} [DecidablePred p] (h₁ : ∀ x, p x ↔ p (f x))\n    (h₂ : ∀ x, f x ≠ x → p x) : sign (subtypePerm f h₁) = sign f :=\n  by\n  let l := (truncSwapFactors (subtypePerm f h₁)).out\n  have hl' : ∀ g' ∈ l.1.map ofSubtype, IsSwap g' := fun g' hg' =>\n    let ⟨g, hg⟩ := List.mem_map.1 hg'\n    hg.2 ▸ (l.2.2 _ hg.1).of_subtype_is_swap\n  have hl'₂ : (l.1.map ofSubtype).prod = f := by rw [l.1.prod_hom of_subtype, l.2.1, of_subtype_subtype_perm _ h₂]\n  conv =>\n    congr\n    rw [← l.2.1]\n    skip\n    rw [← hl'₂]\n  rw [sign_prod_list_swap l.2.2, sign_prod_list_swap hl', list.length_map]\n#align sign_subtype_perm sign_subtype_perm\n\n",
 "sign_subtype_congr":
 "@[simp]\ntheorem sign_subtype_congr {p : α → Prop} [DecidablePred p] (ep : Perm { a // p a }) (en : Perm { a // ¬p a }) :\n    (ep.subtype_congr en).sign = ep.sign * en.sign := by simp [subtype_congr]\n#align sign_subtype_congr sign_subtype_congr\n\n",
 "sign_refl":
 "@[simp]\ntheorem sign_refl : sign (Equiv.refl α) = 1 :=\n  MonoidHom.map_one sign\n#align sign_refl sign_refl\n\n",
 "sign_prod_list_swap":
 "theorem sign_prod_list_swap {l : List (Perm α)} (hl : ∀ g ∈ l, IsSwap g) : sign l.prod = (-1) ^ l.length :=\n  by\n  have h₁ : l.map sign = List.replicate l.length (-1) :=\n    List.eq_replicate.2\n      ⟨by simp, fun u hu =>\n        let ⟨g, hg⟩ := List.mem_map.1 hu\n        hg.2 ▸ (hl _ hg.1).sign_eq⟩\n  rw [← List.prod_replicate, ← h₁, List.prod_hom _ (@SignType.sign α _ _)]\n#align sign_prod_list_swap sign_prod_list_swap\n\n",
 "sign_prod_extend_right":
 "@[simp]\ntheorem sign_prod_extend_right (a : α) (σ : Perm β) : (prodExtendRight a σ).sign = σ.sign :=\n  sign_bij (fun (ab : α × β) _ => ab.snd) (fun ⟨a', b⟩ hab hab' => by simp [eq_of_prod_extend_right_ne hab])\n    (fun ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ hab₁ hab₂ h => by\n      simpa [eq_of_prod_extend_right_ne hab₁, eq_of_prod_extend_right_ne hab₂] using h)\n    fun y hy => ⟨(a, y), by simpa, by simp⟩\n#align sign_prod_extend_right sign_prod_extend_right\n\n",
 "sign_prod_congr_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem sign_prod_congr_right (σ : α → Perm β) :\n    sign (prodCongrRight σ) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ k).sign :=\n  by\n  obtain ⟨l, hl, mem_l⟩ := Finite.exists_univ_list α\n  have l_to_finset : l.to_finset = Finset.univ := by\n    apply eq_top_iff.mpr\n    intro b _\n    exact list.mem_to_finset.mpr (mem_l b)\n  rw [← prod_prod_extend_right σ hl mem_l, sign.map_list_prod, list.map_map, ← l_to_finset, List.prod_toFinset _ hl]\n  simp_rw [← fun a => sign_prod_extend_right a (σ a)]\n#align sign_prod_congr_right sign_prod_congr_right\n\n",
 "sign_prod_congr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem sign_prod_congr_left (σ : α → Perm β) :\n    sign (prodCongrLeft σ) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (σ k).sign :=\n  by\n  refine' (sign_eq_sign_of_equiv _ _ (prod_comm β α) _).trans (sign_prod_congr_right σ)\n  rintro ⟨b, α⟩\n  rfl\n#align sign_prod_congr_left sign_prod_congr_left\n\n",
 "sign_perm_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem sign_perm_congr (e : «expr ≃ » α β) (p : Perm α) : (e.perm_congr p).sign = p.sign :=\n  sign_eq_sign_of_equiv _ _ e.symm (by simp)\n#align sign_perm_congr sign_perm_congr\n\n",
 "sign_one":
 "#print sign_one /-\n@[simp]\ntheorem sign_one : sign (1 : Perm α) = 1 :=\n  MonoidHom.map_one sign\n#align sign_one sign_one\n-/\n\n",
 "sign_of_subtype":
 "@[simp]\ntheorem sign_of_subtype {p : α → Prop} [DecidablePred p] (f : Equiv.Perm (Subtype p)) :\n    Equiv.Perm.sign f.of_subtype = Equiv.Perm.sign f :=\n  sign_extendDomain f (Equiv.refl (Subtype p))\n#align sign_of_subtype sign_of_subtype\n\n",
 "sign_mul":
 "#print sign_mul /-\n@[simp]\ntheorem sign_mul (f g : Perm α) : sign (f * g) = sign f * sign g :=\n  MonoidHom.map_mul sign f g\n#align sign_mul sign_mul\n-/\n\n",
 "sign_inv":
 "@[simp]\ntheorem sign_inv (f : Perm α) : sign f⁻¹ = sign f := by rw [MonoidHom.map_inv SignType.sign f, Int.units_inv_eq_self]\n#align sign_inv sign_inv\n\n",
 "sign_extend_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem sign_extend_domain (e : Perm α) {p : β → Prop} [DecidablePred p] (f : «expr ≃ » α (Subtype p)) :\n    Equiv.Perm.sign (e.extend_domain f) = Equiv.Perm.sign e := by\n  simp only [Equiv.Perm.extendDomain, sign_subtype_congr, sign_perm_congr, sign_refl, mul_one]\n#align sign_extend_domain sign_extend_domain\n\n",
 "sign_eq_sign_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem sign_eq_sign_of_equiv [DecidableEq β] [Fintype β] (f : Perm α) (g : Perm β) (e : «expr ≃ » α β)\n    (h : ∀ x, e (f x) = g (e x)) : sign f = sign g :=\n  by\n  have hg : g = (e.symm.trans f).trans e := Equiv.ext <| by simp [h]\n  rw [hg, sign_symm_trans_trans]\n#align sign_eq_sign_of_equiv sign_eq_sign_of_equiv\n\n",
 "sign_eq":
 "theorem is_swap.sign_eq {f : Perm α} (h : f.is_swap) : sign f = -1 :=\n  let ⟨x, y, hxy⟩ := h\n  hxy.2.symm ▸ sign_swap hxy.1\n#align is_swap.sign_eq is_swap.sign_eq\n\n",
 "sign_bij_aux_surj":
 "theorem sign_bij_aux_surj {n : ℕ} {f : Perm (Fin n)} : ∀ a ∈ finPairsLT n, ∃ b ∈ finPairsLT n, a = signBijAux f b :=\n  fun ⟨a₁, a₂⟩ ha =>\n  if hxa : f⁻¹ a₂ < f⁻¹ a₁ then\n    ⟨⟨f⁻¹ a₁, f⁻¹ a₂⟩, mem_finPairsLT.2 hxa, by\n      dsimp [sign_bij_aux]\n      rw [apply_inv_self, apply_inv_self, if_pos (mem_fin_pairs_lt.1 ha)]⟩\n  else\n    ⟨⟨f⁻¹ a₂, f⁻¹ a₁⟩,\n      mem_finPairsLT.2 <|\n        (le_of_not_gt hxa).lt_of_ne fun h => by simpa [mem_fin_pairs_lt, f⁻¹.injective h, lt_irrefl] using ha,\n      by\n      dsimp [sign_bij_aux]\n      rw [apply_inv_self, apply_inv_self, if_neg (mem_fin_pairs_lt.1 ha).le.not_lt]⟩\n#align sign_bij_aux_surj sign_bij_aux_surj\n\n",
 "sign_bij_aux_mem":
 "theorem sign_bij_aux_mem {n : ℕ} {f : Perm (Fin n)} :\n    ∀ a : Σa : Fin n, Fin n, a ∈ finPairsLT n → signBijAux f a ∈ finPairsLT n := fun ⟨a₁, a₂⟩ ha =>\n  by\n  unfold sign_bij_aux\n  split_ifs with h\n  · exact mem_fin_pairs_lt.2 h\n  · exact mem_fin_pairs_lt.2 ((le_of_not_gt h).lt_of_ne fun h => (mem_fin_pairs_lt.1 ha).ne (f.injective h.symm))\n#align sign_bij_aux_mem sign_bij_aux_mem\n\n",
 "sign_bij_aux_inj":
 "theorem sign_bij_aux_inj {n : ℕ} {f : Perm (Fin n)} :\n    ∀ a b : Σa : Fin n, Fin n, a ∈ finPairsLT n → b ∈ finPairsLT n → signBijAux f a = signBijAux f b → a = b :=\n  fun ⟨a₁, a₂⟩ ⟨b₁, b₂⟩ ha hb h => by\n  unfold sign_bij_aux at h\n  rw [mem_fin_pairs_lt] at *\n  have : ¬b₁ < b₂ := hb.le.not_lt\n  split_ifs  at h <;> simp_all only [(Equiv.injective f).eq_iff, eq_self_iff_true, and_self_iff, heq_iff_eq]\n#align sign_bij_aux_inj sign_bij_aux_inj\n\n",
 "sign_bij":
 "theorem sign_bij [DecidableEq β] [Fintype β] {f : Perm α} {g : Perm β} (i : ∀ x : α, f x ≠ x → β)\n    (h : ∀ x hx hx', i (f x) hx' = g (i x hx)) (hi : ∀ x₁ x₂ hx₁ hx₂, i x₁ hx₁ = i x₂ hx₂ → x₁ = x₂)\n    (hg : ∀ y, g y ≠ y → ∃ x hx, i x hx = y) : sign f = sign g :=\n  calc\n    sign f = sign (subtypePerm f <| by simp : Perm { x // f x ≠ x }) := (sign_subtypePerm _ _ fun _ => id).symm\n    _ = sign (subtypePerm g <| by simp : Perm { x // g x ≠ x }) :=\n      (sign_eq_sign_of_equiv _ _\n        (Equiv.ofBijective\n          (fun x : { x // f x ≠ x } =>\n            (⟨i x.1 x.2, by\n                have : f (f x) ≠ f x := mt (fun h => f.injective h) x.2\n                rw [← h _ x.2 this]\n                exact mt (hi _ _ this x.2) x.2⟩ :\n              { y // g y ≠ y }))\n          ⟨fun ⟨x, hx⟩ ⟨y, hy⟩ h => Subtype.eq (hi _ _ _ _ (subtype.mk.inj h)), fun ⟨y, hy⟩ =>\n            let ⟨x, hfx, hx⟩ := hg y hy\n            ⟨⟨x, hfx⟩, Subtype.eq hx⟩⟩)\n        fun ⟨x, _⟩ => Subtype.eq (h x _ _))\n    _ = sign g := sign_subtypePerm _ _ fun _ => id\n    \n#align sign_bij sign_bij\n\n",
 "sign_aux_swap_zero_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\nprivate theorem sign_aux_swap_zero_one' (n : ℕ) : signAux (swap (0 : Fin (n + 2)) 1) = -1 :=\n  show\n    _ =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        {(⟨1, 0⟩ : Σa : Fin (n + 2), Fin (n + 2))}\n        (if (Equiv.swap 0 1) x.1 ≤ swap 0 1 x.2 then (-1 : «expr ˣ» ℤ) else 1)\n    by\n    refine'\n      Eq.symm\n        (prod_subset (fun ⟨x₁, x₂⟩ => by simp (config := { contextual := true }) [mem_fin_pairs_lt, Fin.one_pos])\n          fun a ha₁ ha₂ => _)\n    rcases a with ⟨a₁, a₂⟩\n    replace ha₁ : a₂ < a₁ := mem_fin_pairs_lt.1 ha₁\n    dsimp only\n    rcases a₁.zero_le.eq_or_lt with (rfl | H)\n    · exact absurd a₂.zero_le ha₁.not_le\n    rcases a₂.zero_le.eq_or_lt with (rfl | H')\n    · simp only [and_true_iff, eq_self_iff_true, heq_iff_eq, mem_singleton] at ha₂\n      have : 1 < a₁ := lt_of_le_of_ne (nat.succ_le_of_lt ha₁) (ne.symm ha₂)\n      have h01 : Equiv.swap (0 : Fin (n + 2)) 1 0 = 1 := by simp\n      -- TODO : fix properly\n      norm_num [swap_apply_of_ne_of_ne (ne_of_gt H) ha₂, this.not_le, h01]\n    · have le : 1 ≤ a₂ := nat.succ_le_of_lt H'\n      have lt : 1 < a₁ := le.trans_lt ha₁\n      have h01 : Equiv.swap (0 : Fin (n + 2)) 1 1 = 0 := by simp\n      -- TODO\n      rcases le.eq_or_lt with (rfl | lt')\n      · norm_num [swap_apply_of_ne_of_ne H.ne' lt.ne', H.not_le, h01]\n      ·\n        norm_num [swap_apply_of_ne_of_ne (ne_of_gt H) (ne_of_gt lt),\n          swap_apply_of_ne_of_ne (ne_of_gt H') (ne_of_gt lt'), ha₁.not_le]\n#align sign_aux_swap_zero_one' sign_aux_swap_zero_one'\n\n",
 "sign_aux_swap_zero_one":
 "private theorem sign_aux_swap_zero_one {n : ℕ} (hn : 2 ≤ n) :\n    signAux (swap (⟨0, lt_of_lt_of_le (by decide) hn⟩ : Fin n) ⟨1, lt_of_lt_of_le (by decide) hn⟩) = -1 :=\n  by\n  rcases n with (_ | _ | n)\n  · norm_num at hn\n  · norm_num at hn\n  · exact sign_aux_swap_zero_one' n\n#align sign_aux_swap_zero_one sign_aux_swap_zero_one\n\n",
 "sign_aux_swap":
 "theorem sign_aux_swap : ∀ {n : ℕ} {x y : Fin n} (hxy : x ≠ y), signAux (swap x y) = -1\n  | 0 => by decide\n  | 1 => by decide\n  | n + 2 => fun x y hxy => by\n    have h2n : 2 ≤ n + 2 := by decide\n    rw [← isConj_iff_eq, ← sign_aux_swap_zero_one h2n]\n    exact (MonoidHom.mk' sign_aux sign_aux_mul).map_is_conj (is_conj_swap hxy (by decide))\n#align sign_aux_swap sign_aux_swap\n\n",
 "sign_aux_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem sign_aux_one (n : ℕ) : signAux (1 : Perm (Fin n)) = 1 :=\n  by\n  unfold sign_aux\n  conv =>\n    rhs\n    rw [← @Finset.prod_const_one («expr ˣ» ℤ) _ (fin_pairs_lt n)]\n  exact Finset.prod_congr rfl fun a ha => if_neg (mem_fin_pairs_lt.1 ha).not_le\n#align sign_aux_one sign_aux_one\n\n",
 "sign_aux_mul":
 "theorem sign_aux_mul {n : ℕ} (f g : Perm (Fin n)) : signAux (f * g) = signAux f * signAux g :=\n  by\n  rw [← sign_aux_inv g]\n  unfold sign_aux\n  rw [← prod_mul_distrib]\n  refine' prod_bij (fun a ha => sign_bij_aux g a) sign_bij_aux_mem _ sign_bij_aux_inj sign_bij_aux_surj\n  rintro ⟨a, b⟩ hab\n  rw [sign_bij_aux, mul_apply, mul_apply]\n  rw [mem_fin_pairs_lt] at hab\n  by_cases h : g b < g a\n  · rw [dif_pos h]\n    simp only [not_le_of_gt hab, mul_one, perm.inv_apply_self, if_false]\n  · rw [dif_neg h, inv_apply_self, inv_apply_self, if_pos hab.le]\n    by_cases h₁ : f (g b) ≤ f (g a)\n    · have : f (g b) ≠ f (g a) := by\n        rw [ne.def, f.injective.eq_iff, g.injective.eq_iff]\n        exact ne_of_lt hab\n      rw [if_pos h₁, if_neg (h₁.lt_of_ne this).not_le]\n      rfl\n    · rw [if_neg h₁, if_pos (lt_of_not_ge h₁).le]\n      rfl\n#align sign_aux_mul sign_aux_mul\n\n",
 "sign_aux_inv":
 "@[simp]\ntheorem sign_aux_inv {n : ℕ} (f : Perm (Fin n)) : signAux f⁻¹ = signAux f :=\n  prod_bij (fun a ha => signBijAux f⁻¹ a) signBijAux_mem\n    (fun ⟨a, b⟩ hab =>\n      if h : f⁻¹ b < f⁻¹ a then by\n        rw [sign_bij_aux, dif_pos h, if_neg h.not_le, apply_inv_self, apply_inv_self,\n          if_neg (mem_fin_pairs_lt.1 hab).not_le]\n      else by\n        rw [sign_bij_aux, if_pos (le_of_not_gt h), dif_neg h, apply_inv_self, apply_inv_self,\n          if_pos (mem_fin_pairs_lt.1 hab).le])\n    signBijAux_inj signBijAux_surj\n#align sign_aux_inv sign_aux_inv\n\n",
 "sign_aux_eq_sign_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem sign_aux_eq_sign_aux2 {n : ℕ} :\n    ∀ (l : List α) (f : Perm α) (e : «expr ≃ » α (Fin n)) (h : ∀ x, f x ≠ x → x ∈ l),\n      signAux ((e.symm.trans f).trans e) = signAux2 l f\n  | [], f, e, h =>\n    by\n    have : f = 1 := Equiv.ext fun y => Classical.not_not.1 (mt (h y) (list.not_mem_nil _))\n    rw [this, one_def, Equiv.trans_refl, Equiv.symm_trans_self, ← one_def, sign_aux_one, sign_aux2]\n  | sym.cons' x l, f, e, h => by\n    rw [sign_aux2]\n    by_cases hfx : x = f x\n    · rw [if_pos hfx]\n      exact\n        sign_aux_eq_sign_aux2 l f _ fun y (hy : f y ≠ y) =>\n          List.mem_of_ne_of_mem (fun h : y = x => by simpa [h, hfx.symm] using hy) (h y hy)\n    · have hy : ∀ y : α, (swap x (f x) * f) y ≠ y → y ∈ l := fun y hy =>\n        have : f y ≠ y ∧ y ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hy\n        List.mem_of_ne_of_mem this.2 (h _ this.1)\n      have : (e.symm.trans (swap x (f x) * f)).trans e = swap (e x) (e (f x)) * (e.symm.trans f).trans e := by\n        ext <;> simp [← Equiv.symm_trans_swap_trans, mul_def]\n      have hefx : e x ≠ e (f x) := mt e.injective.eq_iff.1 hfx\n      rw [if_neg hfx, ← sign_aux_eq_sign_aux2 _ _ e hy, this, sign_aux_mul, sign_aux_swap hefx]\n      simp only [neg_neg, one_mul, neg_mul]\n#align sign_aux_eq_sign_aux2 sign_aux_eq_sign_aux2\n\n",
 "sign_aux3_symm_trans_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem sign_aux3_symm_trans_trans [DecidableEq β] [Fintype β] (f : Perm α) (e : «expr ≃ » α β) {s : Multiset α}\n    {t : Multiset β} (hs : ∀ x, x ∈ s) (ht : ∀ x, x ∈ t) : signAux3 ((e.symm.trans f).trans e) ht = signAux3 f hs :=\n  quotient.induction_on₂ t s\n    (fun l₁ l₂ h₁ h₂ =>\n      show signAux2 _ _ = signAux2 _ _ by\n        let n := equivFin β\n        rw [← sign_aux_eq_sign_aux2 _ _ n fun _ _ => h₁ _, ← sign_aux_eq_sign_aux2 _ _ (e.trans n) fun _ _ => h₂ _]\n        exact congr_arg sign_aux (Equiv.ext fun x => by simp only [Equiv.coe_trans, apply_eq_iff_eq, symm_trans_apply]))\n    ht hs\n#align sign_aux3_symm_trans_trans sign_aux3_symm_trans_trans\n\n",
 "sign_aux3_mul_and_swap":
 "theorem sign_aux3_mul_and_swap [Fintype α] (f g : Perm α) (s : Multiset α) (hs : ∀ x, x ∈ s) :\n    signAux3 (f * g) hs = signAux3 f hs * signAux3 g hs ∧ ∀ x y, x ≠ y → signAux3 (swap x y) hs = -1 :=\n  by\n  let ⟨l, hl⟩ := quotient.exists_rep s\n  let e := equivFin α\n  clear _let_match\n  subst hl\n  show sign_aux2 l (f * g) = sign_aux2 l f * sign_aux2 l g ∧ ∀ x y, x ≠ y → sign_aux2 l (swap x y) = -1\n  have hfg : (e.symm.trans (f * g)).trans e = (e.symm.trans f).trans e * (e.symm.trans g).trans e :=\n    Equiv.ext fun h => by simp [mul_apply]\n  constructor\n  ·\n    rw [← sign_aux_eq_sign_aux2 _ _ e fun _ _ => hs _, ← sign_aux_eq_sign_aux2 _ _ e fun _ _ => hs _, ←\n      sign_aux_eq_sign_aux2 _ _ e fun _ _ => hs _, hfg, sign_aux_mul]\n  · intro x y hxy\n    have hexy : e x ≠ e y := mt e.injective.eq_iff.1 hxy\n    rw [← sign_aux_eq_sign_aux2 _ _ e fun _ _ => hs _, symm_trans_swap_trans, sign_aux_swap hexy]\n#align sign_aux3_mul_and_swap sign_aux3_mul_and_swap\n\n",
 "prod_prod_extend_right":
 "/-- If we apply `prod_extend_right a (σ a)` for all `a : α` in turn,\nwe get `prod_congr_right σ`. -/\ntheorem prod_prod_extend_right {α : Type _} [DecidableEq α] (σ : α → Perm β) {l : List α} (hl : l.nodup)\n    (mem_l : ∀ a, a ∈ l) : (l.map fun a => prodExtendRight a (σ a)).prod = prodCongrRight σ :=\n  by\n  ext ⟨a, b⟩ : 1\n  -- We'll use induction on the list of elements,\n  -- but we have to keep track of whether we already passed `a` in the list.\n  suffices\n    a ∈ l ∧ (l.map fun a => prod_extend_right a (σ a)).prod (a, b) = (a, σ a b) ∨\n      a ∉ l ∧ (l.map fun a => prod_extend_right a (σ a)).prod (a, b) = (a, b)\n    by\n    obtain ⟨_, prod_eq⟩ := or.resolve_right this (not_and.mpr fun h _ => h (mem_l a))\n    rw [prod_eq, prod_congr_right_apply]\n  clear mem_l\n  induction' l with a' l ih\n  · refine' or.inr ⟨list.not_mem_nil _, _⟩\n    rw [List.map_nil, List.prod_nil, one_apply]\n  rw [list.map_cons, List.prod_cons, mul_apply]\n  rcases ih (list.nodup_cons.mp hl).2 with (⟨mem_l, prod_eq⟩ | ⟨not_mem_l, prod_eq⟩) <;> rw [prod_eq]\n  · refine' or.inl ⟨list.mem_cons_of_mem _ mem_l, _⟩\n    rw [prod_extend_right_apply_ne _ fun h : a = a' => (list.nodup_cons.mp hl).1 (h ▸ mem_l)]\n  by_cases ha' : a = a'\n  · rw [← ha'] at *\n    refine' or.inl ⟨l.mem_cons_self a, _⟩\n    rw [prod_extend_right_apply_eq]\n  · refine' or.inr ⟨fun h => not_or_of_not ha' not_mem_l ((List.mem_cons _ _ _).mp h), _⟩\n    rw [prod_extend_right_apply_ne _ ha']\n#align prod_prod_extend_right prod_prod_extend_right\n\n",
 "perm_maps_to_inl_iff_maps_to_inr":
 "theorem perm_maps_to_inl_iff_maps_to_inr {m n : Type _} [Finite m] [Finite n] (σ : Perm (Sum m n)) :\n    Set.MapsTo σ (Set.range Sum.inl) (Set.range Sum.inl) ↔ Set.MapsTo σ (Set.range Sum.inr) (Set.range Sum.inr) :=\n  by\n  cases nonempty_fintype m\n  cases nonempty_fintype n\n  constructor <;>\n    ( intro h\n      classical\n        rw [← perm_inv_maps_to_iff_maps_to] at h\n        intro x\n        cases' hx : σ x with l r)\n  · rintro ⟨a, rfl⟩\n    obtain ⟨y, hy⟩ := h ⟨l, rfl⟩\n    rw [← hx, σ.inv_apply_self] at hy\n    exact absurd hy Sum.inl_ne_inr\n  · rintro ⟨a, ha⟩\n    exact ⟨r, rfl⟩\n  · rintro ⟨a, ha⟩\n    exact ⟨l, rfl⟩\n  · rintro ⟨a, rfl⟩\n    obtain ⟨y, hy⟩ := h ⟨r, rfl⟩\n    rw [← hx, σ.inv_apply_self] at hy\n    exact absurd hy Sum.inr_ne_inl\n#align perm_maps_to_inl_iff_maps_to_inr perm_maps_to_inl_iff_maps_to_inr\n\n",
 "perm_inv_on_of_perm_on_finset":
 "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n-- An example on how to determine the order of an element of a finite group.\ntheorem perm_inv_on_of_perm_on_finset {s : Finset α} {f : Perm α} (h : ∀ x ∈ s, f x ∈ s) {y : α} (hy : y ∈ s) :\n    f⁻¹ y ∈ s :=\n  by\n  have h0 : ∀ y ∈ s, ∃ (x : _)(hx : x ∈ s), y = (fun i (hi : i ∈ s) => f i) x hx :=\n    Finset.surj_on_of_inj_on_of_card_le (fun x hx => (fun i hi => f i) x hx) (fun a ha => h a ha)\n      (fun a₁ a₂ ha₁ ha₂ heq => (Equiv.apply_eq_iff_eq f).mp HEq) rfl.ge\n  obtain ⟨y2, hy2, heq⟩ := h0 y hy\n  convert hy2\n  rw [HEq]\n  simp only [inv_apply_self]\n#align perm_inv_on_of_perm_on_finset perm_inv_on_of_perm_on_finset\n\n",
 "perm_inv_on_of_perm_on_finite":
 "theorem perm_inv_on_of_perm_on_finite {f : Perm α} {p : α → Prop} [Finite { x // p x }] (h : ∀ x, p x → p (f x)) {x : α}\n    (hx : p x) : p (f⁻¹ x) :=\n  perm_inv_mapsTo_of_mapsTo f h hx\n#align perm_inv_on_of_perm_on_finite perm_inv_on_of_perm_on_finite\n\n",
 "perm_inv_maps_to_of_maps_to":
 "theorem perm_inv_maps_to_of_maps_to (f : Perm α) {s : Set α} [Finite s] (h : Set.MapsTo f s s) :\n    Set.MapsTo (f⁻¹ : _) s s := by\n  cases nonempty_fintype s <;>\n    exact fun x hx =>\n      set.mem_to_finset.mp <|\n        perm_inv_on_of_perm_on_finset (fun a ha => set.mem_to_finset.mpr (h (set.mem_to_finset.mp ha)))\n          (set.mem_to_finset.mpr hx)\n#align perm_inv_maps_to_of_maps_to perm_inv_maps_to_of_maps_to\n\n",
 "perm_inv_maps_to_iff_maps_to":
 "@[simp]\ntheorem perm_inv_maps_to_iff_maps_to {f : Perm α} {s : Set α} [Finite s] :\n    Set.MapsTo (f⁻¹ : _) s s ↔ Set.MapsTo f s s :=\n  ⟨perm_inv_mapsTo_of_mapsTo f⁻¹, perm_inv_mapsTo_of_mapsTo f⟩\n#align perm_inv_maps_to_iff_maps_to perm_inv_maps_to_iff_maps_to\n\n",
 "order_of":
 "theorem disjoint.order_of {σ τ : Perm α} (hστ : Disjoint σ τ) : orderOf (σ * τ) = Nat.lcm (orderOf σ) (orderOf τ) :=\n  haveI h : ∀ n : ℕ, (σ * τ) ^ n = 1 ↔ σ ^ n = 1 ∧ τ ^ n = 1 := fun n => by\n    rw [hστ.commute.mul_pow, disjoint.mul_eq_one_iff (hστ.pow_disjoint_pow n n)]\n  nat.dvd_antisymm hστ.commute.order_of_mul_dvd_lcm\n    (Nat.lcm_dvd (orderOf_dvd_of_pow_eq_one ((h (orderOf (σ * τ))).mp (pow_orderOf_eq_one (σ * τ))).1)\n      (orderOf_dvd_of_pow_eq_one ((h (orderOf (σ * τ))).mp (pow_orderOf_eq_one (σ * τ))).2))\n#align disjoint.order_of disjoint.order_of\n\n",
 "mem_sum_congr_hom_range_of_perm_maps_to_inl":
 "theorem mem_sum_congr_hom_range_of_perm_maps_to_inl {m n : Type _} [Finite m] [Finite n] {σ : Perm (Sum m n)}\n    (h : Set.MapsTo σ (Set.range Sum.inl) (Set.range Sum.inl)) : σ ∈ (sumCongrHom m n).range :=\n  by\n  cases nonempty_fintype m\n  cases nonempty_fintype n\n  classical\n    have h1 : ∀ x : Sum m n, (∃ a : m, Sum.inl a = x) → ∃ a : m, Sum.inl a = σ x :=\n      by\n      rintro x ⟨a, ha⟩\n      apply h\n      rw [← ha]\n      exact ⟨a, rfl⟩\n    have h3 : ∀ x : Sum m n, (∃ b : n, Sum.inr b = x) → ∃ b : n, Sum.inr b = σ x :=\n      by\n      rintro x ⟨b, hb⟩\n      apply (perm_maps_to_inl_iff_maps_to_inr σ).mp h\n      rw [← hb]\n      exact ⟨b, rfl⟩\n    let σ₁' := subtype_perm_of_fintype σ h1\n    let σ₂' := subtype_perm_of_fintype σ h3\n    let σ₁ := perm_congr (Equiv.ofInjective _ Sum.inl_injective).symm σ₁'\n    let σ₂ := perm_congr (Equiv.ofInjective _ Sum.inr_injective).symm σ₂'\n    rw [MonoidHom.mem_range, Prod.exists]\n    use σ₁, σ₂\n    rw [perm.sum_congr_hom_apply]\n    ext\n    cases' x with a b\n    · rw [Equiv.sumCongr_apply, Sum.map_inl, perm_congr_apply, Equiv.symm_symm,\n        apply_of_injective_symm Sum.inl_injective]\n      erw [subtype_perm_apply]\n      rw [of_injective_apply, Subtype.coe_mk, Subtype.coe_mk]\n    · rw [Equiv.sumCongr_apply, Sum.map_inr, perm_congr_apply, Equiv.symm_symm,\n        apply_of_injective_symm Sum.inr_injective]\n      erw [subtype_perm_apply]\n      rw [of_injective_apply, Subtype.coe_mk, Subtype.coe_mk]\n#align mem_sum_congr_hom_range_of_perm_maps_to_inl mem_sum_congr_hom_range_of_perm_maps_to_inl\n\n",
 "mem_fin_pairs_lt":
 "theorem mem_fin_pairs_lt {n : ℕ} {a : Σa : Fin n, Fin n} : a ∈ finPairsLT n ↔ a.2 < a.1 := by\n  simp only [fin_pairs_lt, Fin.lt_iff_val_lt_val, true_and_iff, mem_attach_fin, mem_range, mem_univ, mem_sigma]\n#align mem_fin_pairs_lt mem_fin_pairs_lt\n\n",
 "is_conj_swap":
 "theorem is_conj_swap {w x y z : α} (hwx : w ≠ x) (hyz : y ≠ z) : IsConj (swap w x) (swap y z) :=\n  isConj_iff.2\n    (have h : ∀ {y z : α}, y ≠ z → w ≠ z → swap w y * swap x z * swap w x * (swap w y * swap x z)⁻¹ = swap y z :=\n      fun y z hyz hwz => by\n      rw [mul_inv_rev, swap_inv, swap_inv, mul_assoc (swap w y), mul_assoc (swap w y), ← mul_assoc _ (swap x z),\n        swap_mul_swap_mul_swap hwx hwz, ← mul_assoc, swap_mul_swap_mul_swap hwz.symm hyz.symm]\n    if hwz : w = z then\n      have hwy : w ≠ y := by cc\n      ⟨swap w z * swap x y, by rw [swap_comm y z, h hyz.symm hwy]⟩\n    else ⟨swap w y * swap x z, h hyz hwz⟩)\n#align is_conj_swap is_conj_swap\n\n",
 "extend_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem disjoint.extend_domain {α : Type _} {p : β → Prop} [DecidablePred p] (f : «expr ≃ » α (Subtype p))\n    {σ τ : Perm α} (h : Disjoint σ τ) : Disjoint (σ.extend_domain f) (τ.extend_domain f) :=\n  by\n  intro b\n  by_cases pb : p b\n  ·\n    refine' (h (f.symm ⟨b, pb⟩)).imp _ _ <;>\n      · intro h\n        rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, Subtype.coe_mk]\n  · left\n    rw [extend_domain_apply_not_subtype _ _ pb]\n#align disjoint.extend_domain disjoint.extend_domain\n\n",
 "eq_sign_of_surjective_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem eq_sign_of_surjective_hom {s : «expr →* » (Perm α) («expr ˣ» ℤ)} (hs : surjective s) : s = sign :=\n  have : ∀ {f}, IsSwap f → s f = -1 := fun f ⟨x, y, hxy, hxy'⟩ =>\n    hxy'.symm ▸\n      by_contradiction fun h =>\n        by\n        have : ∀ f, IsSwap f → s f = 1 := fun f ⟨a, b, hab, hab'⟩ =>\n          by\n          rw [← isConj_iff_eq, ← or.resolve_right (Int.units_eq_one_or _) h, hab']\n          exact s.map_is_conj (is_conj_swap hab hxy)\n        let ⟨g, hg⟩ := hs (-1)\n        let ⟨l, hl⟩ := (truncSwapFactors g).out\n        have : ∀ a ∈ l.map s, a = (1 : «expr ˣ» ℤ) := fun a ha =>\n          let ⟨g, hg⟩ := List.mem_map.1 ha\n          hg.2 ▸ this _ (hl.2 _ hg.1)\n        have : s l.prod = 1 := by rw [← l.prod_hom s, List.eq_replicate_length.2 this, List.prod_replicate, one_pow]\n        rw [hl.1, hg] at this\n        exact absurd this (by decide)\n  MonoidHom.ext fun f => by\n    let ⟨l, hl₁, hl₂⟩ := (truncSwapFactors f).out\n    have hsl : ∀ a ∈ l.map s, a = (-1 : «expr ˣ» ℤ) := fun a ha =>\n      let ⟨g, hg⟩ := List.mem_map.1 ha\n      hg.2 ▸ this (hl₂ _ hg.1)\n    rw [← hl₁, ← l.prod_hom s, List.eq_replicate_length.2 hsl, list.length_map, List.prod_replicate,\n      sign_prod_list_swap hl₂]\n#align eq_sign_of_surjective_hom eq_sign_of_surjective_hom\n\n",
 "closure_is_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem closure_is_swap [Finite α] : Subgroup.closure { σ : Perm α | IsSwap σ } = «expr⊤» :=\n  by\n  cases nonempty_fintype α\n  refine' eq_top_iff.mpr fun x hx => _\n  obtain ⟨h1, h2⟩ := Subtype.mem (trunc_swap_factors x).out\n  rw [← h1]\n  exact Subgroup.list_prod_mem _ fun y hy => Subgroup.subset_closure (h2 y hy)\n#align closure_is_swap closure_is_swap\n\n"}