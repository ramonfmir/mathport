{"two_le_length_to_list_iff_mem_support":
 "theorem two_le_length_to_list_iff_mem_support {p : Perm α} {x : α} : 2 ≤ length (to_list p x) ↔ x ∈ p.support := by simp\n#align two_le_length_to_list_iff_mem_support two_le_length_to_list_iff_mem_support\n\n",
 "to_list_pow_apply_eq_rotate":
 "theorem to_list_pow_apply_eq_rotate (p : Perm α) (x : α) (k : ℕ) : p.to_list ((p ^ k) x) = (p.to_list x).rotate k :=\n  by\n  apply ext_le\n  · simp only [length_to_list, cycle_of_self_apply_pow, length_rotate]\n  · intro n hn hn'\n    rw [nth_le_to_list, nth_le_rotate, nth_le_to_list, length_to_list, pow_mod_card_support_cycle_of_self_apply,\n      pow_add, mul_apply]\n#align to_list_pow_apply_eq_rotate to_list_pow_apply_eq_rotate\n\n",
 "to_list_one":
 "@[simp]\ntheorem to_list_one : to_list (1 : Perm α) x = [] := by simp [to_list, cycle_of_one]\n#align to_list_one to_list_one\n\n",
 "to_list_nth_le_zero":
 "theorem to_list_nth_le_zero (h : x ∈ p.support) :\n    (to_list p x).nth_le 0 (length_to_list_pos_of_mem_support _ _ h) = x := by simp [to_list]\n#align to_list_nth_le_zero to_list_nth_le_zero\n\n",
 "to_list_ne_singleton":
 "theorem to_list_ne_singleton (y : α) : to_list p x ≠ [y] :=\n  by\n  intro H\n  simpa [card_support_ne_one] using congr_arg length H\n#align to_list_ne_singleton to_list_ne_singleton\n\n",
 "to_list_is_rotated":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\ntheorem same_cycle.to_list_is_rotated {f : Perm α} {x y : α} (h : SameCycle f x y) :\n    «expr ~r » (to_list f x) (to_list f y) := by\n  by_cases hx : x ∈ f.support\n  · obtain ⟨_ | k, hk, hy⟩ := h.exists_pow_eq_of_mem_support hx\n    · simp only [coe_one, id.def, pow_zero] at hy\n      simp [hy]\n    use k.succ\n    rw [← to_list_pow_apply_eq_rotate, hy]\n  · rw [to_list_eq_nil_iff.mpr hx, is_rotated_nil_iff', eq_comm, to_list_eq_nil_iff]\n    rwa [← h.mem_support_iff]\n#align same_cycle.to_list_is_rotated same_cycle.to_list_is_rotated\n\n",
 "to_list_form_perm_singleton":
 "theorem to_list_form_perm_singleton (x y : α) : to_list (formPerm [x]) y = [] := by simp\n#align to_list_form_perm_singleton to_list_form_perm_singleton\n\n",
 "to_list_form_perm_nontrivial":
 "theorem to_list_form_perm_nontrivial (l : List α) (hl : 2 ≤ l.length) (hn : Nodup l) :\n    to_list (formPerm l) (l.nth_le 0 (zero_lt_two.trans_le hl)) = l :=\n  by\n  have hc : l.form_perm.is_cycle := list.is_cycle_form_perm hn hl\n  have hs : l.form_perm.support = l.to_finset :=\n    by\n    refine' support_form_perm_of_nodup _ hn _\n    rintro _ rfl\n    simpa [Nat.succ_le_succ_iff] using hl\n  rw [to_list, hc.cycle_of_eq (mem_support.mp _), hs, card_to_finset, dedup_eq_self.mpr hn]\n  · refine' List.ext_nthLe (by simp) fun k hk hk' => _\n    simp [form_perm_pow_apply_nth_le _ hn, nat.mod_eq_of_lt hk']\n  · simpa [hs] using nth_le_mem _ _ _\n#align to_list_form_perm_nontrivial to_list_form_perm_nontrivial\n\n",
 "to_list_form_perm_nil":
 "theorem to_list_form_perm_nil (x : α) : to_list (formPerm ([] : List α)) x = [] := by simp\n#align to_list_form_perm_nil to_list_form_perm_nil\n\n",
 "to_list_form_perm_is_rotated_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~r » -/\ntheorem to_list_form_perm_is_rotated_self (l : List α) (hl : 2 ≤ l.length) (hn : Nodup l) (x : α) (hx : x ∈ l) :\n    «expr ~r » (to_list (formPerm l) x) l :=\n  by\n  obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx\n  have hr : «expr ~r » l (l.rotate k) := ⟨k, rfl⟩\n  rw [form_perm_eq_of_is_rotated hn hr]\n  rw [← nth_le_rotate' l k k]\n  simp only [nat.mod_eq_of_lt hk, tsub_add_cancel_of_le hk.le, nat.mod_self]\n  rw [to_list_form_perm_nontrivial]\n  · simp\n  · simpa using hl\n  · simpa using hn\n#align to_list_form_perm_is_rotated_self to_list_form_perm_is_rotated_self\n\n",
 "to_list_eq_nil_iff":
 "@[simp]\ntheorem to_list_eq_nil_iff {p : Perm α} {x} : to_list p x = [] ↔ x ∉ p.support := by simp [to_list]\n#align to_list_eq_nil_iff to_list_eq_nil_iff\n\n",
 "to_cycle_eq_to_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem to_cycle_eq_to_list (f : Perm α) (hf : IsCycle f) (x : α) (hx : f x ≠ x) : to_cycle f hf = to_list f x :=\n  by\n  have key : (Finset.univ : Finset α).val = «expr ::ₘ » x (finset.univ.val.erase x) := by simp\n  rw [to_cycle, key]\n  simp [hx]\n#align to_cycle_eq_to_list to_cycle_eq_to_list\n\n",
 "support_form_perm":
 "theorem support_form_perm [Fintype α] (s : Cycle α) (h : Nodup s) (hn : Nontrivial s) :\n    support (form_perm s h) = s.to_finset :=\n  by\n  induction s using Quot.inductionOn\n  refine' support_form_perm_of_nodup s h _\n  rintro _ rfl\n  simpa [Nat.succ_le_succ_iff] using length_nontrivial hn\n#align support_form_perm support_form_perm\n\n",
 "pow_apply_mem_to_list_iff_mem_support":
 "theorem pow_apply_mem_to_list_iff_mem_support {n : ℕ} : (p ^ n) x ∈ p.to_list x ↔ x ∈ p.support :=\n  by\n  rw [mem_to_list_iff, and_iff_right_iff_imp]\n  refine' fun _ => same_cycle.symm _\n  rw [same_cycle_pow_left]\n#align pow_apply_mem_to_list_iff_mem_support pow_apply_mem_to_list_iff_mem_support\n\n",
 "pairwise_same_cycle_form_perm":
 "theorem pairwise_same_cycle_form_perm (hl : Nodup l) (hn : 2 ≤ l.length) : Pairwise l.form_perm.same_cycle l :=\n  Pairwise.imp_mem.mpr\n    (pairwise_of_forall fun x y hx hy =>\n      (is_cycle_form_perm hl hn).same_cycle ((formPerm_apply_mem_ne_self_iff _ hl _ hx).mpr hn)\n        ((formPerm_apply_mem_ne_self_iff _ hl _ hy).mpr hn))\n#align pairwise_same_cycle_form_perm pairwise_same_cycle_form_perm\n\n",
 "nth_le_to_list":
 "theorem nth_le_to_list (n : ℕ) (hn : n < length (to_list p x)) : nthLe (to_list p x) n hn = (p ^ n) x := by\n  simp [to_list]\n#align nth_le_to_list nth_le_to_list\n\n",
 "nontrivial_to_cycle":
 "theorem nontrivial_to_cycle (f : Perm α) (hf : IsCycle f) : (to_cycle f hf).nontrivial :=\n  by\n  obtain ⟨x, hx, -⟩ := id hf\n  simp [to_cycle_eq_to_list f hf x hx, hx, Cycle.nontrivial_coe_nodup_iff (nodup_to_list _ _)]\n#align nontrivial_to_cycle nontrivial_to_cycle\n\n",
 "nodup_to_list":
 "theorem nodup_to_list (p : Perm α) (x : α) : Nodup (to_list p x) :=\n  by\n  by_cases hx : p x = x\n  · rw [← not_mem_support, ← to_list_eq_nil_iff] at hx\n    simp [hx]\n  have hc : is_cycle (cycle_of p x) := is_cycle_cycle_of p hx\n  rw [nodup_iff_nth_le_inj]\n  rintro n m hn hm\n  rw [length_to_list, ← hc.order_of] at hm hn\n  rw [← cycle_of_apply_self, ← ne.def, ← mem_support] at hx\n  rw [nth_le_to_list, nth_le_to_list, ← cycle_of_pow_apply_self p x n, ← cycle_of_pow_apply_self p x m]\n  cases n <;> cases m\n  · simp\n  · rw [← hc.support_pow_of_pos_of_lt_order_of m.zero_lt_succ hm, mem_support, cycle_of_pow_apply_self] at hx\n    simp [hx.symm]\n  · rw [← hc.support_pow_of_pos_of_lt_order_of n.zero_lt_succ hn, mem_support, cycle_of_pow_apply_self] at hx\n    simp [hx]\n  intro h\n  have hn' : ¬orderOf (p.cycle_of x) ∣ n.succ := Nat.not_dvd_of_pos_of_lt n.zero_lt_succ hn\n  have hm' : ¬orderOf (p.cycle_of x) ∣ m.succ := Nat.not_dvd_of_pos_of_lt m.zero_lt_succ hm\n  rw [← hc.support_pow_eq_iff] at hn' hm'\n  rw [← nat.mod_eq_of_lt hn, ← nat.mod_eq_of_lt hm, ← pow_inj_mod]\n  refine' support_congr _ _\n  · rw [hm', hn']\n    exact Finset.Subset.refl _\n  · rw [hm']\n    intro y hy\n    obtain ⟨k, rfl⟩ := hc.exists_pow_eq (mem_support.mp hx) (mem_support.mp hy)\n    rw [← mul_apply, (Commute.pow_pow_self _ _ _).eq, mul_apply, h, ← mul_apply, ← mul_apply,\n      (Commute.pow_pow_self _ _ _).eq]\n#align nodup_to_list nodup_to_list\n\n",
 "nodup_to_cycle":
 "theorem nodup_to_cycle (f : Perm α) (hf : IsCycle f) : (to_cycle f hf).nodup :=\n  by\n  obtain ⟨x, hx, -⟩ := id hf\n  simpa [to_cycle_eq_to_list f hf x hx] using nodup_to_list _ _\n#align nodup_to_cycle nodup_to_cycle\n\n",
 "next_to_list_eq_apply":
 "theorem next_to_list_eq_apply (p : Perm α) (x y : α) (hy : y ∈ to_list p x) : next (to_list p x) y hy = p y :=\n  by\n  rw [mem_to_list_iff] at hy\n  obtain ⟨k, hk, hk'⟩ := hy.left.exists_pow_eq_of_mem_support hy.right\n  rw [← nth_le_to_list p x k (by simpa using hk)] at hk'\n  simp_rw [← hk']\n  rw [next_nth_le _ (nodup_to_list _ _), nth_le_to_list, nth_le_to_list, ← mul_apply, ← pow_succ, length_to_list,\n    pow_apply_eq_pow_mod_order_of_cycle_of_apply p (k + 1), is_cycle.order_of]\n  exact is_cycle_cycle_of _ (mem_support.mp hy.right)\n#align next_to_list_eq_apply next_to_list_eq_apply\n\n",
 "mem_to_list_iff":
 "theorem mem_to_list_iff {y : α} : y ∈ to_list p x ↔ SameCycle p x y ∧ x ∈ p.support :=\n  by\n  simp only [to_list, mem_range, mem_map]\n  constructor\n  · rintro ⟨n, hx, rfl⟩\n    refine' ⟨⟨n, rfl⟩, _⟩\n    contrapose! hx\n    rw [← support_cycle_of_eq_nil_iff] at hx\n    simp [hx]\n  · rintro ⟨h, hx⟩\n    simpa using h.exists_pow_eq_of_mem_support hx\n#align mem_to_list_iff mem_to_list_iff\n\n",
 "length_to_list_pos_of_mem_support":
 "theorem length_to_list_pos_of_mem_support (h : x ∈ p.support) : 0 < length (to_list p x) :=\n  zero_lt_two.trans_le (two_le_length_to_list_iff_mem_support.mpr h)\n#align length_to_list_pos_of_mem_support length_to_list_pos_of_mem_support\n\n",
 "length_to_list":
 "@[simp]\ntheorem length_to_list : length (to_list p x) = (cycleOf p x).support.card := by simp [to_list]\n#align length_to_list length_to_list\n\n",
 "is_cycle_form_perm":
 "theorem is_cycle_form_perm (s : Cycle α) (h : Nodup s) (hn : Nontrivial s) : IsCycle (form_perm s h) :=\n  by\n  induction s using Quot.inductionOn\n  exact list.is_cycle_form_perm h (length_nontrivial hn)\n#align is_cycle_form_perm is_cycle_form_perm\n\n",
 "form_perm_to_list":
 "theorem form_perm_to_list (f : Perm α) (x : α) : formPerm (to_list f x) = f.cycle_of x :=\n  by\n  by_cases hx : f x = x\n  · rw [(cycle_of_eq_one_iff f).mpr hx, to_list_eq_nil_iff.mpr (not_mem_support.mpr hx), form_perm_nil]\n  ext y\n  by_cases hy : same_cycle f x y\n  · obtain ⟨k, hk, rfl⟩ := hy.exists_pow_eq_of_mem_support (mem_support.mpr hx)\n    rw [cycle_of_apply_apply_pow_self, list.form_perm_apply_mem_eq_next (nodup_to_list f x), next_to_list_eq_apply,\n      pow_succ, mul_apply]\n    rw [mem_to_list_iff]\n    exact ⟨⟨k, rfl⟩, mem_support.mpr hx⟩\n  · rw [cycle_of_apply_of_not_same_cycle hy, form_perm_apply_of_not_mem]\n    simp [mem_to_list_iff, hy]\n#align form_perm_to_list form_perm_to_list\n\n",
 "form_perm_subsingleton":
 "theorem form_perm_subsingleton (s : Cycle α) (h : Subsingleton s) : form_perm s h.nodup = 1 :=\n  by\n  induction s using Quot.inductionOn\n  simp only [form_perm_coe, mk_eq_coe]\n  simp only [length_subsingleton_iff, length_coe, mk_eq_coe] at h\n  cases' s with hd tl\n  · simp\n  · simp only [length_eq_zero, add_le_iff_nonpos_left, list.length, nonpos_iff_eq_zero] at h\n    simp [h]\n#align form_perm_subsingleton form_perm_subsingleton\n\n",
 "form_perm_reverse":
 "theorem form_perm_reverse (s : Cycle α) (h : Nodup s) :\n    form_perm s.reverse (nodup_reverse_iff.mpr h) = (form_perm s h)⁻¹ :=\n  by\n  induction s using Quot.inductionOn\n  simpa using form_perm_reverse _ h\n#align form_perm_reverse form_perm_reverse\n\n",
 "form_perm_eq_self_of_not_mem":
 "theorem form_perm_eq_self_of_not_mem (s : Cycle α) (h : Nodup s) (x : α) (hx : x ∉ s) : form_perm s h x = x :=\n  by\n  induction s using Quot.inductionOn\n  simpa using List.formPerm_eq_self_of_not_mem _ _ hx\n#align form_perm_eq_self_of_not_mem form_perm_eq_self_of_not_mem\n\n",
 "form_perm_eq_form_perm_iff":
 "theorem form_perm_eq_form_perm_iff {α : Type _} [DecidableEq α] {s s' : Cycle α} {hs : s.nodup} {hs' : s'.nodup} :\n    s.form_perm hs = s'.form_perm hs' ↔ s = s' ∨ s.subsingleton ∧ s'.subsingleton :=\n  by\n  rw [Cycle.length_subsingleton_iff, Cycle.length_subsingleton_iff]\n  revert s s'\n  intro s s'\n  apply Quotient.inductionOn₂' s s'\n  intro l l'\n  simpa using form_perm_eq_form_perm_iff\n#align form_perm_eq_form_perm_iff form_perm_eq_form_perm_iff\n\n",
 "form_perm_disjoint_iff":
 "/-\nCopyright (c) 2021 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\ntheorem form_perm_disjoint_iff (hl : Nodup l) (hl' : Nodup l') (hn : 2 ≤ l.length) (hn' : 2 ≤ l'.length) :\n    Perm.Disjoint (formPerm l) (formPerm l') ↔ l.disjoint l' :=\n  by\n  rw [disjoint_iff_eq_or_eq, List.Disjoint]\n  constructor\n  · rintro h x hx hx'\n    specialize h x\n    rw [form_perm_apply_mem_eq_self_iff _ hl _ hx, form_perm_apply_mem_eq_self_iff _ hl' _ hx'] at h\n    rcases h with (hl | hl') <;> linarith\n  · intro h x\n    by_cases hx : x ∈ l\n    by_cases hx' : x ∈ l'\n    · exact (h hx hx').elim\n    all_goals have := form_perm_eq_self_of_not_mem _ _ ‹_›; tauto\n#align form_perm_disjoint_iff form_perm_disjoint_iff\n\n",
 "form_perm_coe":
 "@[simp]\ntheorem form_perm_coe (l : List α) (hl : l.nodup) : form_perm (l : Cycle α) hl = l.form_perm :=\n  rfl\n#align form_perm_coe form_perm_coe\n\n",
 "form_perm_apply_mem_eq_next":
 "theorem form_perm_apply_mem_eq_next (s : Cycle α) (h : Nodup s) (x : α) (hx : x ∈ s) :\n    form_perm s h x = next s h x hx := by\n  induction s using Quot.inductionOn\n  simpa using list.form_perm_apply_mem_eq_next h _ _\n#align form_perm_apply_mem_eq_next form_perm_apply_mem_eq_next\n\n",
 "exists_unique_cycle_subtype":
 "theorem is_cycle.exists_unique_cycle_subtype {f : Perm α} (hf : IsCycle f) :\n    ∃! s : { s : Cycle α // s.nodup }, (s : Cycle α).form_perm s.prop = f :=\n  by\n  obtain ⟨s, ⟨hs, rfl⟩, hs'⟩ := hf.exists_unique_cycle\n  refine' ⟨⟨s, hs⟩, rfl, _⟩\n  rintro ⟨t, ht⟩ ht'\n  simpa using hs' _ ⟨ht, ht'⟩\n#align is_cycle.exists_unique_cycle_subtype is_cycle.exists_unique_cycle_subtype\n\n",
 "exists_unique_cycle_nontrivial_subtype":
 "theorem is_cycle.exists_unique_cycle_nontrivial_subtype {f : Perm α} (hf : IsCycle f) :\n    ∃! s : { s : Cycle α // s.nodup ∧ s.nontrivial }, (s : Cycle α).form_perm s.prop.left = f :=\n  by\n  obtain ⟨⟨s, hn⟩, hs, hs'⟩ := hf.exists_unique_cycle_subtype\n  refine' ⟨⟨s, hn, _⟩, _, _⟩\n  · rw [hn.nontrivial_iff]\n    subst f\n    intro H\n    refine' hf.ne_one _\n    simpa using cycle.form_perm_subsingleton _ H\n  · simpa using hs\n  · rintro ⟨t, ht, ht'⟩ ht''\n    simpa using hs' ⟨t, ht⟩ ht''\n#align is_cycle.exists_unique_cycle_nontrivial_subtype is_cycle.exists_unique_cycle_nontrivial_subtype\n\n",
 "exists_unique_cycle":
 "theorem is_cycle.exists_unique_cycle {f : Perm α} (hf : IsCycle f) : ∃! s : Cycle α, ∃ h : s.nodup, s.form_perm h = f :=\n  by\n  cases nonempty_fintype α\n  obtain ⟨x, hx, hy⟩ := id hf\n  refine' ⟨f.to_list x, ⟨nodup_to_list f x, _⟩, _⟩\n  · simp [form_perm_to_list, hf.cycle_of_eq hx]\n  · rintro ⟨l⟩ ⟨hn, rfl⟩\n    simp only [Cycle.mk_eq_coe, Cycle.coe_eq_coe, Subtype.coe_mk, cycle.form_perm_coe]\n    refine' (to_list_form_perm_is_rotated_self _ _ hn _ _).symm\n    · contrapose! hx\n      suffices form_perm l = 1 by simp [this]\n      rw [form_perm_eq_one_iff _ hn]\n      exact nat.le_of_lt_succ hx\n    · rw [← mem_to_finset]\n      refine' support_form_perm_le l _\n      simpa using hx\n#align is_cycle.exists_unique_cycle is_cycle.exists_unique_cycle\n\n",
 "cycle_type_form_perm":
 "theorem cycle_type_form_perm (hl : Nodup l) (hn : 2 ≤ l.length) : cycleType l.attach.form_perm = {l.length} :=\n  by\n  rw [← length_attach] at hn\n  rw [← nodup_attach] at hl\n  rw [cycle_type_eq [l.attach.form_perm]]\n  · simp only [map, Function.comp_apply]\n    rw [support_form_perm_of_nodup _ hl, card_to_finset, dedup_eq_self.mpr hl]\n    · simp\n    · intro x h\n      simpa [h, Nat.succ_le_succ_iff] using hn\n  · simp\n  · simpa using is_cycle_form_perm hl hn\n  · simp\n#align cycle_type_form_perm cycle_type_form_perm\n\n",
 "cycle_of_form_perm":
 "theorem cycle_of_form_perm (hl : Nodup l) (hn : 2 ≤ l.length) (x) : cycleOf l.attach.form_perm x = l.attach.form_perm :=\n  have hn : 2 ≤ l.attach.length := by rwa [← length_attach] at hn\n  have hl : l.attach.nodup := by rwa [← nodup_attach] at hl\n  (is_cycle_form_perm hl hn).cycle_of_eq ((formPerm_apply_mem_ne_self_iff _ hl _ (mem_attach _ _)).mpr hn)\n#align cycle_of_form_perm cycle_of_form_perm\n\n"}