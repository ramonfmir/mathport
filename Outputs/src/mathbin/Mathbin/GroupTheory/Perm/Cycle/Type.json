{"zero_eq":
 "theorem zero_eq : vectorsProdEqOne G 0 = {Vector.nil} :=\n  Set.eq_singleton_iff_unique_mem.mpr ⟨Eq.refl (1 : G), fun v hv => v.eq_nil⟩\n#align zero_eq zero_eq\n\n",
 "two_le_of_mem_cycle_type":
 "theorem two_le_of_mem_cycle_type {σ : Perm α} {n : ℕ} (h : n ∈ σ.cycle_type) : 2 ≤ n :=\n  by\n  simp only [cycle_type_def, ← Finset.mem_def, Function.comp_apply, Multiset.mem_map, mem_cycle_factors_finset_iff] at h\n  obtain ⟨_, ⟨hc, -⟩, rfl⟩ := h\n  exact hc.two_le_card_support\n#align two_le_of_mem_cycle_type two_le_of_mem_cycle_type\n\n",
 "two_dvd_card_support":
 "theorem two_dvd_card_support {σ : Perm α} (hσ : σ ^ 2 = 1) : 2 ∣ σ.support.card :=\n  (congr_arg (has_dvd.dvd 2) σ.sum_cycle_type).mp\n    (Multiset.dvd_sum fun n hn => by\n      rw [le_antisymm (nat.le_of_dvd zero_lt_two <| (dvd_of_mem_cycle_type hn).trans <| orderOf_dvd_of_pow_eq_one hσ)\n          (two_le_of_mem_cycle_type hn)])\n#align two_dvd_card_support two_dvd_card_support\n\n",
 "swap_mul_swap_same_mem_closure_three_cycles":
 "theorem swap_mul_swap_same_mem_closure_three_cycles {a b c : α} (ab : a ≠ b) (ac : a ≠ c) :\n    swap a b * swap a c ∈ closure { σ : Perm α | IsThreeCycle σ } :=\n  by\n  by_cases bc : b = c\n  · subst bc\n    simp [one_mem]\n  exact subset_closure (is_three_cycle_swap_mul_swap_same ab ac bc)\n#align swap_mul_swap_same_mem_closure_three_cycles swap_mul_swap_same_mem_closure_three_cycles\n\n",
 "sum_cycle_type":
 "theorem sum_cycle_type (σ : Perm α) : σ.cycle_type.sum = σ.support.card :=\n  cycle_induction_on (fun τ : Perm α => τ.cycle_type.sum = τ.support.card) σ\n    (by rw [cycle_type_one, sum_zero, support_one, Finset.card_empty])\n    (fun σ hσ => by rw [hσ.cycle_type, coe_sum, List.sum_singleton]) fun σ τ hστ hc hσ hτ => by\n    rw [hστ.cycle_type, sum_add, hσ, hτ, hστ.card_support_mul]\n#align sum_cycle_type sum_cycle_type\n\n",
 "subgroup_eq_top_of_swap_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subgroup_eq_top_of_swap_mem [DecidableEq α] {H : Subgroup (Perm α)} [d : DecidablePred (· ∈ H)] {τ : Perm α}\n    (h0 : (Fintype.card α).prime) (h1 : Fintype.card α ∣ Fintype.card H) (h2 : τ ∈ H) (h3 : IsSwap τ) : H = «expr⊤» :=\n  by\n  haveI : Fact (Fintype.card α).prime := ⟨h0⟩\n  obtain ⟨σ, hσ⟩ := exists_prime_orderOf_dvd_card (Fintype.card α) h1\n  have hσ1 : orderOf (σ : perm α) = Fintype.card α := (orderOf_subgroup σ).trans hσ\n  have hσ2 : is_cycle ↑σ := is_cycle_of_prime_order'' h0 hσ1\n  have hσ3 : (σ : perm α).support = «expr⊤» := Finset.eq_univ_of_card (σ : perm α).support (hσ2.order_of.symm.trans hσ1)\n  have hσ4 : Subgroup.closure {↑σ, τ} = «expr⊤» := closure_prime_cycle_swap h0 hσ2 hσ3 h3\n  rw [eq_top_iff, ← hσ4, Subgroup.closure_le, Set.insert_subset, Set.singleton_subset_iff]\n  exact ⟨Subtype.mem σ, h2⟩\n#align subgroup_eq_top_of_swap_mem subgroup_eq_top_of_swap_mem\n\n",
 "sign_of_cycle_type'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem sign_of_cycle_type' (σ : Perm α) : sign σ = (σ.cycle_type.map fun n => -(-1 : «expr ˣ» ℤ) ^ n).prod :=\n  cycle_induction_on (fun τ : Perm α => sign τ = (τ.cycle_type.map fun n => -(-1 : «expr ˣ» ℤ) ^ n).prod) σ\n    (by rw [sign_one, cycle_type_one, Multiset.map_zero, prod_zero])\n    (fun σ hσ => by rw [hσ.sign, hσ.cycle_type, coe_map, coe_prod, list.map_singleton, List.prod_singleton])\n    fun σ τ hστ hc hσ hτ => by rw [sign_mul, hσ, hτ, hστ.cycle_type, Multiset.map_add, prod_add]\n#align sign_of_cycle_type' sign_of_cycle_type'\n\n",
 "sign_of_cycle_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem sign_of_cycle_type (f : Perm α) : sign f = (-1 : «expr ˣ» ℤ) ^ (f.cycle_type.sum + f.cycle_type.card) :=\n  cycle_induction_on (fun f : Perm α => sign f = (-1 : «expr ˣ» ℤ) ^ (f.cycle_type.sum + f.cycle_type.card)) f\n    (-- base_one\n    by rw [Equiv.Perm.cycleType_one, sign_one, Multiset.sum_zero, Multiset.card_zero, pow_zero])\n    (-- base_cycles\n    fun f hf => by\n      rw [Equiv.Perm.IsCycle.cycleType hf, hf.sign, coe_sum, List.sum_cons, sum_nil, add_zero, coe_card,\n        length_singleton, pow_add, pow_one, mul_comm, neg_mul, one_mul])-- induction_disjoint\n  fun f g hfg hf Pf Pg => by\n    rw [Equiv.Perm.Disjoint.cycleType hfg, Multiset.sum_add, Multiset.card_add, ← add_assoc,\n      add_comm f.cycle_type.sum g.cycle_type.sum, add_assoc g.cycle_type.sum _ _, add_comm g.cycle_type.sum _,\n      add_assoc, pow_add, ← Pf, ← Pg, Equiv.Perm.sign_mul]\n#align sign_of_cycle_type sign_of_cycle_type\n\n",
 "sign":
 "#print SignType.sign /-\ntheorem SignType.sign (h : IsThreeCycle σ) : sign σ = 1 :=\n  by\n  rw [Equiv.Perm.sign_of_cycleType, h.cycle_type]\n  rfl\n#align sign SignType.sign\n-/\n\n",
 "rotate_zero":
 "theorem rotate_zero : rotate v 0 = v :=\n  Subtype.ext (Subtype.ext v.1.1.rotate_zero)\n#align rotate_zero rotate_zero\n\n",
 "rotate_rotate":
 "theorem rotate_rotate : rotate (rotate v j) k = rotate v (j + k) :=\n  Subtype.ext (Subtype.ext (v.1.1.rotate_rotate j k))\n#align rotate_rotate rotate_rotate\n\n",
 "rotate_length":
 "theorem rotate_length : rotate v n = v :=\n  Subtype.ext (Subtype.ext ((congr_arg _ v.1.2.symm).trans v.1.1.rotate_length))\n#align rotate_length rotate_length\n\n",
 "parts_partition":
 "theorem parts_partition {σ : Perm α} :\n    σ.partition.parts = σ.cycle_type + replicate (Fintype.card α - σ.support.card) 1 :=\n  rfl\n#align parts_partition parts_partition\n\n",
 "partition_eq_of_is_conj":
 "theorem partition_eq_of_is_conj {σ τ : Perm α} : IsConj σ τ ↔ σ.partition = τ.partition :=\n  by\n  rw [is_conj_iff_cycle_type_eq]\n  refine' ⟨fun h => _, fun h => _⟩\n  · rw [nat.partition.ext_iff, parts_partition, parts_partition, ← sum_cycle_type, ← sum_cycle_type, h]\n  · rw [← filter_parts_partition_eq_cycle_type, ← filter_parts_partition_eq_cycle_type, h]\n#align partition_eq_of_is_conj partition_eq_of_is_conj\n\n",
 "order_of_cycle_of_dvd_order_of":
 "theorem order_of_cycle_of_dvd_order_of (f : Perm α) (x : α) : orderOf (cycleOf f x) ∣ orderOf f :=\n  by\n  by_cases hx : f x = x\n  · rw [← cycle_of_eq_one_iff] at hx\n    simp [hx]\n  · refine' dvd_of_mem_cycle_type _\n    rw [cycle_type, Multiset.mem_map]\n    refine' ⟨f.cycle_of x, _, _⟩\n    · rwa [← Finset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support]\n    · simp [(is_cycle_cycle_of _ hx).order_of]\n#align order_of_cycle_of_dvd_order_of order_of_cycle_of_dvd_order_of\n\n",
 "orderOf":
 "#print orderOf /-\ntheorem orderOf {g : Perm α} (ht : IsThreeCycle g) : orderOf g = 3 := by\n  rw [← lcm_cycle_type, ht.cycle_type, Multiset.lcm_singleton, normalize_eq]\n#align order_of orderOf\n-/\n\n",
 "one_lt_of_mem_cycle_type":
 "theorem one_lt_of_mem_cycle_type {σ : Perm α} {n : ℕ} (h : n ∈ σ.cycle_type) : 1 < n :=\n  two_le_of_mem_cycleType h\n#align one_lt_of_mem_cycle_type one_lt_of_mem_cycle_type\n\n",
 "one_eq":
 "theorem one_eq : vectorsProdEqOne G 1 = {Vector.nil.cons 1} :=\n  by\n  simp_rw [Set.eq_singleton_iff_unique_mem, mem_iff, Vector.toList_singleton, List.prod_singleton, Vector.head_cons]\n  exact ⟨rfl, fun v hv => v.cons_head_tail.symm.trans (congr_arg₂ Vector.cons hv v.tail.eq_nil)⟩\n#align one_eq one_eq\n\n",
 "mul_mem_closure_three_cycles":
 "theorem is_swap.mul_mem_closure_three_cycles {σ τ : Perm α} (hσ : IsSwap σ) (hτ : IsSwap τ) :\n    σ * τ ∈ closure { σ : Perm α | IsThreeCycle σ } :=\n  by\n  obtain ⟨a, b, ab, rfl⟩ := hσ\n  obtain ⟨c, d, cd, rfl⟩ := hτ\n  by_cases ac : a = c\n  · subst ac\n    exact swap_mul_swap_same_mem_closure_three_cycles ab cd\n  have h' : swap a b * swap c d = swap a b * swap a c * (swap c a * swap c d) := by simp [swap_comm c a, mul_assoc]\n  rw [h']\n  exact\n    mul_mem (swap_mul_swap_same_mem_closure_three_cycles ab ac)\n      (swap_mul_swap_same_mem_closure_three_cycles (ne.symm ac) cd)\n#align is_swap.mul_mem_closure_three_cycles is_swap.mul_mem_closure_three_cycles\n\n",
 "mem_iff":
 "theorem mem_iff {n : ℕ} (v : Vector G n) : v ∈ vectorsProdEqOne G n ↔ v.to_list.prod = 1 :=\n  iff.rfl\n#align mem_iff mem_iff\n\n",
 "mem_cycle_type_iff":
 "theorem mem_cycle_type_iff {n : ℕ} {σ : Perm α} :\n    n ∈ cycleType σ ↔ ∃ c τ : Perm α, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n :=\n  by\n  constructor\n  · intro h\n    obtain ⟨l, rfl, hlc, hld⟩ := trunc_cycle_factors σ\n    rw [cycle_type_eq _ rfl hlc hld] at h\n    obtain ⟨c, cl, rfl⟩ := List.exists_of_mem_map h\n    rw [(List.perm_cons_erase cl).pairwise_iff fun _ _ hd => _] at hld\n    swap\n    · exact hd.symm\n    refine' ⟨c, (l.erase c).prod, _, _, hlc _ cl, rfl⟩\n    · rw [← List.prod_cons, (List.perm_cons_erase cl).symm.prod_eq' (hld.imp fun _ _ => disjoint.commute)]\n    · exact disjoint_prod_right _ fun g => List.rel_of_pairwise_cons hld\n  · rintro ⟨c, t, rfl, hd, hc, rfl⟩\n    simp [hd.cycle_type, hc.cycle_type]\n#align mem_cycle_type_iff mem_cycle_type_iff\n\n",
 "le_card_support_of_mem_cycle_type":
 "theorem le_card_support_of_mem_cycle_type {n : ℕ} {σ : Perm α} (h : n ∈ cycleType σ) : n ≤ σ.support.card :=\n  (le_sum_of_mem h).trans (le_of_eq σ.sum_cycle_type)\n#align le_card_support_of_mem_cycle_type le_card_support_of_mem_cycle_type\n\n",
 "lcm_cycle_type":
 "theorem lcm_cycle_type (σ : Perm α) : σ.cycle_type.lcm = orderOf σ :=\n  cycle_induction_on (fun τ : Perm α => τ.cycle_type.lcm = orderOf τ) σ (by rw [cycle_type_one, lcm_zero, orderOf_one])\n    (fun σ hσ => by rw [hσ.cycle_type, coe_singleton, lcm_singleton, hσ.order_of, normalize_eq]) fun σ τ hστ hc hσ hτ =>\n    by rw [hστ.cycle_type, lcm_add, lcm_eq_nat_lcm, hστ.order_of, hσ, hτ]\n#align lcm_cycle_type lcm_cycle_type\n\n",
 "is_three_cycle_swap_mul_swap_same":
 "theorem is_three_cycle_swap_mul_swap_same {a b c : α} (ab : a ≠ b) (ac : a ≠ c) (bc : b ≠ c) :\n    IsThreeCycle (swap a b * swap a c) :=\n  by\n  suffices h : support (swap a b * swap a c) = {a, b, c}\n  · rw [← card_support_eq_three_iff, h]\n    simp [ab, ac, bc]\n  apply le_antisymm ((support_mul_le _ _).trans fun x => _) fun x hx => _\n  · simp [ab, ac, bc]\n  · simp only [Finset.mem_insert, Finset.mem_singleton] at hx\n    rw [mem_support]\n    simp only [perm.coe_mul, Function.comp_apply, ne.def]\n    obtain rfl | rfl | rfl := hx\n    · rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm]\n      exact ac.symm\n    · rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right]\n      exact ab\n    · rw [swap_apply_right, swap_apply_left]\n      exact bc\n#align is_three_cycle_swap_mul_swap_same is_three_cycle_swap_mul_swap_same\n\n",
 "is_three_cycle_sq":
 "theorem is_three_cycle_sq {g : Perm α} (ht : IsThreeCycle g) : IsThreeCycle (g * g) :=\n  by\n  rw [← pow_two, ← card_support_eq_three_iff, support_pow_coprime, ht.card_support]\n  rw [ht.order_of, Nat.coprime_iff_gcd_eq_one]\n  norm_num\n#align is_three_cycle_sq is_three_cycle_sq\n\n",
 "is_cycle_of_prime_order''":
 "theorem is_cycle_of_prime_order'' {σ : Perm α} (h1 : (Fintype.card α).prime) (h2 : orderOf σ = Fintype.card α) :\n    σ.is_cycle :=\n  isCycle_of_prime_order' ((congr_arg Nat.Prime h2).mpr h1)\n    (by\n      classical\n        rw [← one_mul (Fintype.card α), ← h2, mul_lt_mul_right (orderOf_pos σ)]\n        exact one_lt_two)\n#align is_cycle_of_prime_order'' is_cycle_of_prime_order''\n\n",
 "is_cycle_of_prime_order'":
 "theorem is_cycle_of_prime_order' {σ : Perm α} (h1 : (orderOf σ).prime) (h2 : Fintype.card α < 2 * orderOf σ) :\n    σ.is_cycle := by classical exact is_cycle_of_prime_order h1 (lt_of_le_of_lt σ.support.card_le_univ h2)\n#align is_cycle_of_prime_order' is_cycle_of_prime_order'\n\n",
 "is_cycle_of_prime_order":
 "theorem is_cycle_of_prime_order {σ : Perm α} (h1 : (orderOf σ).prime) (h2 : σ.support.card < 2 * orderOf σ) :\n    σ.is_cycle := by\n  obtain ⟨n, hn⟩ := cycle_type_prime_order h1\n  rw [← σ.sum_cycle_type, hn, Multiset.sum_replicate, nsmul_eq_mul, Nat.cast_id, mul_lt_mul_right (orderOf_pos σ),\n    Nat.succ_lt_succ_iff, Nat.lt_succ_iff, le_zero_iff] at h2\n  rw [← card_cycle_type_eq_one, hn, card_replicate, h2]\n#align is_cycle_of_prime_order is_cycle_of_prime_order\n\n",
 "is_cycle":
 "theorem is_cycle (h : IsThreeCycle σ) : IsCycle σ := by rw [← card_cycle_type_eq_one, h.cycle_type, card_singleton]\n#align is_cycle is_cycle\n\n",
 "is_conj_of_cycle_type_eq":
 "theorem is_conj_of_cycle_type_eq {σ τ : Perm α} (h : cycleType σ = cycleType τ) : IsConj σ τ :=\n  by\n  revert τ\n  apply cycle_induction_on _ σ\n  · intro τ h\n    rw [cycle_type_one, eq_comm, cycle_type_eq_zero] at h\n    rw [h]\n  · intro σ hσ τ hστ\n    have hτ := card_cycle_type_eq_one.2 hσ\n    rw [hστ, card_cycle_type_eq_one] at hτ\n    apply hσ.is_conj hτ\n    rw [hσ.cycle_type, hτ.cycle_type, coe_eq_coe, singleton_perm] at hστ\n    simp only [and_true_iff, eq_self_iff_true] at hστ\n    exact hστ\n  · intro σ τ hστ hσ h1 h2 π hπ\n    rw [hστ.cycle_type] at hπ\n    · have h : σ.support.card ∈ map (Finset.card ∘ perm.support) π.cycle_factors_finset.val := by\n        simp [← cycle_type_def, ← hπ, hσ.cycle_type]\n      obtain ⟨σ', hσ'l, hσ'⟩ := multiset.mem_map.mp h\n      have key : IsConj (σ' * (π * σ'⁻¹)) π := by\n        rw [isConj_iff]\n        use σ'⁻¹\n        simp [mul_assoc]\n      refine' IsConj.trans _ key\n      have hs : σ.cycle_type = σ'.cycle_type :=\n        by\n        rw [← Finset.mem_def, mem_cycle_factors_finset_iff] at hσ'l\n        rw [hσ.cycle_type, ← hσ', hσ'l.left.cycle_type]\n      refine' hστ.is_conj_mul (h1 hs) (h2 _) _\n      · rw [cycle_type_mul_mem_cycle_factors_finset_eq_sub, ← hπ, add_comm, hs, add_tsub_cancel_right]\n        rwa [Finset.mem_def]\n      · exact (disjoint_mul_inv_of_mem_cycle_factors_finset hσ'l).symm\n#align is_conj_of_cycle_type_eq is_conj_of_cycle_type_eq\n\n",
 "is_conj_iff_cycle_type_eq":
 "theorem is_conj_iff_cycle_type_eq {σ τ : Perm α} : IsConj σ τ ↔ σ.cycle_type = τ.cycle_type :=\n  ⟨fun h => by\n    obtain ⟨π, rfl⟩ := isConj_iff.1 h\n    rw [cycle_type_conj], isConj_of_cycleType_eq⟩\n#align is_conj_iff_cycle_type_eq is_conj_iff_cycle_type_eq\n\n",
 "inv_iff":
 "@[simp]\ntheorem inv_iff {f : Perm α} : IsThreeCycle f⁻¹ ↔ IsThreeCycle f :=\n  ⟨by\n    rw [← inv_inv f]\n    apply inv, inv⟩\n#align inv_iff inv_iff\n\n",
 "inv":
 "theorem inv {f : Perm α} (h : IsThreeCycle f) : IsThreeCycle f⁻¹ := by rwa [is_three_cycle, cycle_type_inv]\n#align inv inv\n\n",
 "filter_parts_partition_eq_cycle_type":
 "theorem filter_parts_partition_eq_cycle_type {σ : Perm α} :\n    ((partition σ).parts.filter fun n => 2 ≤ n) = σ.cycle_type :=\n  by\n  rw [parts_partition, filter_add, Multiset.filter_eq_self.2 fun _ => two_le_of_mem_cycle_type,\n    Multiset.filter_eq_nil.2 fun a h => _, add_zero]\n  rw [Multiset.eq_of_mem_replicate h]\n  decide\n#align filter_parts_partition_eq_cycle_type filter_parts_partition_eq_cycle_type\n\n",
 "exists_prime_order_of_dvd_card":
 "#print exists_prime_orderOf_dvd_card /-\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem exists_prime_orderOf_dvd_card {G : Type _} [Group G] [Fintype G] (p : ℕ) [hp : Fact p.prime]\n    (hdvd : p ∣ Fintype.card G) : ∃ x : G, orderOf x = p :=\n  by\n  have hp' : p - 1 ≠ 0 := mt tsub_eq_zero_iff_le.mp (not_le_of_lt hp.out.one_lt)\n  have Scard :=\n    calc\n      p ∣ Fintype.card G ^ (p - 1) := hdvd.trans (dvd_pow (dvd_refl _) hp')\n      _ = Fintype.card (vectors_prod_eq_one G p) := (vectors_prod_eq_one.card G p).symm\n      \n  let f : ℕ → vectors_prod_eq_one G p → vectors_prod_eq_one G p := fun k v => vectors_prod_eq_one.rotate v k\n  have hf1 : ∀ v, f 0 v = v := vectors_prod_eq_one.rotate_zero\n  have hf2 : ∀ j k v, f k (f j v) = f (j + k) v := fun j k v => vectors_prod_eq_one.rotate_rotate v j k\n  have hf3 : ∀ v, f p v = v := vectors_prod_eq_one.rotate_length\n  let σ :=\n    equiv.mk (f 1) (f (p - 1)) (fun s => by rw [hf2, add_tsub_cancel_of_le hp.out.one_lt.le, hf3]) fun s => by\n      rw [hf2, tsub_add_cancel_of_le hp.out.one_lt.le, hf3]\n  have hσ : ∀ k v, (σ ^ k) v = f k v := fun k v =>\n    nat.rec (hf1 v).symm (fun k hk => Eq.trans (congr_arg σ hk) (hf2 k 1 v)) k\n  replace hσ : σ ^ p ^ 1 = 1 := perm.ext fun v => by rw [pow_one, hσ, hf3, one_apply]\n  let v₀ : vectors_prod_eq_one G p := ⟨Vector.replicate p 1, (List.prod_replicate p 1).trans (one_pow p)⟩\n  have hv₀ : σ v₀ = v₀ := Subtype.ext (Subtype.ext (List.rotate_replicate (1 : G) p 1))\n  obtain ⟨v, hv1, hv2⟩ := exists_fixed_point_of_prime' Scard hσ hv₀\n  refine'\n    Exists.imp (fun g hg => orderOf_eq_prime _ fun hg' => hv2 _)\n      (list.rotate_one_eq_self_iff_eq_replicate.mp (subtype.ext_iff.mp (subtype.ext_iff.mp hv1)))\n  · rw [← List.prod_replicate, ← v.1.2, ← hg, show v.val.val.prod = 1 from v.2]\n  · rw [Subtype.ext_iff_val, Subtype.ext_iff_val, hg, hg', v.1.2]\n    rfl\n#align exists_prime_order_of_dvd_card exists_prime_orderOf_dvd_card\n-/\n\n",
 "exists_prime_add_order_of_dvd_card":
 "#print exists_prime_addOrderOf_dvd_card /-\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem exists_prime_addOrderOf_dvd_card {G : Type _} [AddGroup G] [Fintype G] (p : ℕ) [hp : Fact p.prime]\n    (hdvd : p ∣ Fintype.card G) : ∃ x : G, addOrderOf x = p :=\n  @exists_prime_orderOf_dvd_card (Multiplicative G) _ _ _ _ hdvd\n#align exists_prime_add_order_of_dvd_card exists_prime_addOrderOf_dvd_card\n-/\n\n",
 "exists_fixed_point_of_prime'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem exists_fixed_point_of_prime' {p n : ℕ} [hp : Fact p.prime] (hα : p ∣ Fintype.card α) {σ : Perm α}\n    (hσ : σ ^ p ^ n = 1) {a : α} (ha : σ a = a) : ∃ b : α, σ b = b ∧ b ≠ a := by\n  classical\n    have h : ∀ b : α, b ∈ «expr ᶜ» σ.support ↔ σ b = b := fun b => by\n      rw [Finset.mem_compl, mem_support, Classical.not_not]\n    obtain ⟨b, hb1, hb2⟩ :=\n      Finset.exists_ne_of_one_lt_card\n        (lt_of_lt_of_le hp.out.one_lt\n          (nat.le_of_dvd (finset.card_pos.mpr ⟨a, (h a).mpr ha⟩)\n            (nat.modeq_zero_iff_dvd.mp ((card_compl_support_modeq hσ).trans (nat.modeq_zero_iff_dvd.mpr hα)))))\n        a\n    exact ⟨b, (h b).mp hb1, hb2⟩\n#align exists_fixed_point_of_prime' exists_fixed_point_of_prime'\n\n",
 "exists_fixed_point_of_prime":
 "theorem exists_fixed_point_of_prime {p n : ℕ} [hp : Fact p.prime] (hα : ¬p ∣ Fintype.card α) {σ : Perm α}\n    (hσ : σ ^ p ^ n = 1) : ∃ a : α, σ a = a := by\n  classical\n    contrapose! hα\n    simp_rw [← mem_support] at hα\n    exact\n      nat.modeq_zero_iff_dvd.mp\n        ((congr_arg _ (finset.card_eq_zero.mpr (compl_eq_bot.mpr (finset.eq_univ_iff_forall.mpr hα)))).mp\n          (card_compl_support_modeq hσ).symm)\n#align exists_fixed_point_of_prime exists_fixed_point_of_prime\n\n",
 "dvd_of_mem_cycle_type":
 "theorem dvd_of_mem_cycle_type {σ : Perm α} {n : ℕ} (h : n ∈ σ.cycle_type) : n ∣ orderOf σ :=\n  by\n  rw [← lcm_cycle_type]\n  exact dvd_lcm h\n#align dvd_of_mem_cycle_type dvd_of_mem_cycle_type\n\n",
 "cycle_type_prime_order":
 "theorem cycle_type_prime_order {σ : Perm α} (hσ : (orderOf σ).prime) :\n    ∃ n : ℕ, σ.cycle_type = replicate (n + 1) (orderOf σ) :=\n  by\n  rw [eq_replicate_of_mem fun n hn =>\n      or_iff_not_imp_left.mp (hσ.eq_one_or_self_of_dvd n (dvd_of_mem_cycle_type hn)) (one_lt_of_mem_cycle_type hn).ne']\n  use σ.cycle_type.card - 1\n  rw [tsub_add_cancel_of_le]\n  rw [Nat.succ_le_iff, pos_iff_ne_zero, ne, card_cycle_type_eq_zero]\n  intro H\n  rw [H, orderOf_one] at hσ\n  exact hσ.ne_one rfl\n#align cycle_type_prime_order cycle_type_prime_order\n\n",
 "cycle_type_one":
 "theorem cycle_type_one : (1 : Perm α).cycle_type = 0 :=\n  cycleType_eq [] rfl (fun _ => false.elim) Pairwise.nil\n#align cycle_type_one cycle_type_one\n\n",
 "cycle_type_of_subtype":
 "theorem cycle_type_of_subtype {p : α → Prop} [DecidablePred p] {g : Perm (Subtype p)} :\n    cycleType g.of_subtype = cycleType g :=\n  cycleType_extendDomain (Equiv.refl (Subtype p))\n#align cycle_type_of_subtype cycle_type_of_subtype\n\n",
 "cycle_type_of_card_le_mem_cycle_type_add_two":
 "theorem cycle_type_of_card_le_mem_cycle_type_add_two {n : ℕ} {g : Perm α} (hn2 : Fintype.card α < n + 2)\n    (hng : n ∈ g.cycle_type) : g.cycle_type = {n} :=\n  by\n  obtain ⟨c, g', rfl, hd, hc, rfl⟩ := mem_cycle_type_iff.1 hng\n  by_cases g'1 : g' = 1\n  · rw [hd.cycle_type, hc.cycle_type, coe_singleton, g'1, cycle_type_one, add_zero]\n  contrapose! hn2\n  apply le_trans _ (c * g').support.card_le_univ\n  rw [hd.card_support_mul]\n  exact add_le_add_left (two_le_card_support_of_ne_one g'1) _\n#align cycle_type_of_card_le_mem_cycle_type_add_two cycle_type_of_card_le_mem_cycle_type_add_two\n\n",
 "cycle_type_mul_mem_cycle_factors_finset_eq_sub":
 "theorem cycle_type_mul_mem_cycle_factors_finset_eq_sub {f g : Perm α} (hf : f ∈ g.cycle_factors_finset) :\n    (g * f⁻¹).cycle_type = g.cycle_type - f.cycle_type :=\n  by\n  suffices (g * f⁻¹).cycle_type + f.cycle_type = g.cycle_type - f.cycle_type + f.cycle_type\n    by\n    rw [tsub_add_cancel_of_le (cycle_type_le_of_mem_cycle_factors_finset hf)] at this\n    simp [← this]\n  simp [← (disjoint_mul_inv_of_mem_cycle_factors_finset hf).cycle_type,\n    tsub_add_cancel_of_le (cycle_type_le_of_mem_cycle_factors_finset hf)]\n#align cycle_type_mul_mem_cycle_factors_finset_eq_sub cycle_type_mul_mem_cycle_factors_finset_eq_sub\n\n",
 "cycle_type_le_of_mem_cycle_factors_finset":
 "theorem cycle_type_le_of_mem_cycle_factors_finset {f g : Perm α} (hf : f ∈ g.cycle_factors_finset) :\n    f.cycle_type ≤ g.cycle_type := by\n  rw [mem_cycle_factors_finset_iff] at hf\n  rw [cycle_type_def, cycle_type_def, hf.left.cycle_factors_finset_eq_singleton]\n  refine' map_le_map _\n  simpa [← Finset.mem_def, mem_cycle_factors_finset_iff] using hf\n#align cycle_type_le_of_mem_cycle_factors_finset cycle_type_le_of_mem_cycle_factors_finset\n\n",
 "cycle_type_inv":
 "theorem cycle_type_inv (σ : Perm α) : σ⁻¹.cycle_type = σ.cycle_type :=\n  cycle_induction_on (fun τ : Perm α => τ⁻¹.cycle_type = τ.cycle_type) σ rfl\n    (fun σ hσ => by rw [hσ.cycle_type, hσ.inv.cycle_type, support_inv]) fun σ τ hστ hc hσ hτ => by\n    rw [mul_inv_rev, hστ.cycle_type, ← hσ, ← hτ, add_comm,\n      disjoint.cycle_type fun x =>\n        Or.imp (fun h : τ x = x => inv_eq_iff_eq.mpr h.symm) (fun h : σ x = x => inv_eq_iff_eq.mpr h.symm) (hστ x).symm]\n#align cycle_type_inv cycle_type_inv\n\n",
 "cycle_type_extend_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem cycle_type_extend_domain {β : Type _} [Fintype β] [DecidableEq β] {p : β → Prop} [DecidablePred p]\n    (f : «expr ≃ » α (Subtype p)) {g : Perm α} : cycleType (g.extend_domain f) = cycleType g :=\n  by\n  apply cycle_induction_on _ g\n  · rw [extend_domain_one, cycle_type_one, cycle_type_one]\n  · intro σ hσ\n    rw [(hσ.extend_domain f).cycle_type, hσ.cycle_type, card_support_extend_domain]\n  · intro σ τ hd hc hσ hτ\n    rw [hd.cycle_type, ← extend_domain_mul, (hd.extend_domain f).cycle_type, hσ, hτ]\n#align cycle_type_extend_domain cycle_type_extend_domain\n\n",
 "cycle_type_eq_zero":
 "theorem cycle_type_eq_zero {σ : Perm α} : σ.cycle_type = 0 ↔ σ = 1 := by\n  simp [cycle_type_def, cycle_factors_finset_eq_empty_iff]\n#align cycle_type_eq_zero cycle_type_eq_zero\n\n",
 "cycle_type_eq'":
 "theorem cycle_type_eq' {σ : Perm α} (s : Finset (Perm α)) (h1 : ∀ f : Perm α, f ∈ s → f.is_cycle)\n    (h2 : (s : Set (Perm α)).pairwise Disjoint) (h0 : s.noncomm_prod id (h2.imp fun _ _ => Disjoint.commute) = σ) :\n    σ.cycle_type = s.1.map (Finset.card ∘ support) :=\n  by\n  rw [cycle_type_def]\n  congr\n  rw [cycle_factors_finset_eq_finset]\n  exact ⟨h1, h2, h0⟩\n#align cycle_type_eq' cycle_type_eq'\n\n",
 "cycle_type_eq":
 "theorem cycle_type_eq {σ : Perm α} (l : List (Perm α)) (h0 : l.prod = σ) (h1 : ∀ σ : Perm α, σ ∈ l → σ.is_cycle)\n    (h2 : l.pairwise Disjoint) : σ.cycle_type = l.map (Finset.card ∘ support) :=\n  by\n  have hl : l.nodup := nodup_of_pairwise_disjoint_cycles h1 h2\n  rw [cycle_type_eq' l.to_finset]\n  · simp [list.dedup_eq_self.mpr hl]\n  · simpa using h1\n  · simpa [hl] using h0\n  · simpa [list.dedup_eq_self.mpr hl] using h2.forall disjoint.symmetric\n#align cycle_type_eq cycle_type_eq\n\n",
 "cycle_type_def":
 "/-\nCopyright (c) 2020 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem cycle_type_def (σ : Perm α) : σ.cycle_type = σ.cycle_factors_finset.1.map (Finset.card ∘ support) :=\n  rfl\n#align cycle_type_def cycle_type_def\n\n",
 "cycle_type_conj":
 "theorem cycle_type_conj {σ τ : Perm α} : (τ * σ * τ⁻¹).cycle_type = σ.cycle_type :=\n  by\n  revert τ\n  apply cycle_induction_on _ σ\n  · intro\n    simp\n  · intro σ hσ τ\n    rw [hσ.cycle_type, hσ.conj.cycle_type, card_support_conj]\n  · intro σ τ hd hc hσ hτ π\n    rw [← conj_mul, hd.cycle_type, disjoint.cycle_type, hσ, hτ]\n    intro a\n    apply (hd (π⁻¹ a)).imp _ _ <;>\n      · intro h\n        rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self]\n#align cycle_type_conj cycle_type_conj\n\n",
 "cycle_type":
 "theorem cycle_type (h : IsThreeCycle σ) : σ.cycle_type = {3} :=\n  h\n#align cycle_type cycle_type\n\n",
 "card_support_eq_three_iff":
 "#print card_support_eq_three_iff /-\ntheorem card_support_eq_three_iff : σ.support.card = 3 ↔ σ.is_three_cycle :=\n  by\n  refine' ⟨fun h => _, is_three_cycle.card_support⟩\n  by_cases h0 : σ.cycle_type = 0\n  · rw [← sum_cycle_type, h0, sum_zero] at h\n    exact (ne_of_lt zero_lt_three h).elim\n  obtain ⟨n, hn⟩ := exists_mem_of_ne_zero h0\n  by_cases h1 : σ.cycle_type.erase n = 0\n  · rw [← sum_cycle_type, ← cons_erase hn, h1, cons_zero, Multiset.sum_singleton] at h\n    rw [is_three_cycle, ← cons_erase hn, h1, h, ← cons_zero]\n  obtain ⟨m, hm⟩ := exists_mem_of_ne_zero h1\n  rw [← sum_cycle_type, ← cons_erase hn, ← cons_erase hm, Multiset.sum_cons, Multiset.sum_cons] at h\n  -- TODO: linarith [...] should solve this directly\n  have : ∀ {k}, 2 ≤ m → 2 ≤ n → n + (m + k) = 3 → False :=\n    by\n    intros\n    linarith\n  cases this (two_le_of_mem_cycle_type (mem_of_mem_erase hm)) (two_le_of_mem_cycle_type hn) h\n#align card_support_eq_three_iff card_support_eq_three_iff\n-/\n\n",
 "card_support":
 "theorem card_support (h : IsThreeCycle σ) : σ.support.card = 3 := by\n  rw [← sum_cycle_type, h.cycle_type, Multiset.sum_singleton]\n#align card_support card_support\n\n",
 "card_cycle_type_eq_zero":
 "theorem card_cycle_type_eq_zero {σ : Perm α} : σ.cycle_type.card = 0 ↔ σ = 1 := by rw [card_eq_zero, cycle_type_eq_zero]\n#align card_cycle_type_eq_zero card_cycle_type_eq_zero\n\n",
 "card_cycle_type_eq_one":
 "theorem card_cycle_type_eq_one {σ : Perm α} : σ.cycle_type.card = 1 ↔ σ.is_cycle :=\n  by\n  rw [card_eq_one]\n  simp_rw [cycle_type_def, Multiset.map_eq_singleton, ← Finset.singleton_val, Finset.val_inj,\n    cycle_factors_finset_eq_singleton_iff]\n  constructor\n  · rintro ⟨_, _, ⟨h, -⟩, -⟩\n    exact h\n  · intro h\n    use σ.support.card, σ\n    simp [h]\n#align card_cycle_type_eq_one card_cycle_type_eq_one\n\n",
 "card_compl_support_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem card_compl_support_modeq [DecidableEq α] {p n : ℕ} [hp : Fact p.prime] {σ : Perm α} (hσ : σ ^ p ^ n = 1) :\n    «expr ≡ [MOD ]» («expr ᶜ» σ.support).card (Fintype.card α) p :=\n  by\n  rw [Nat.modEq_iff_dvd' («expr ᶜ» σ.support).card_le_univ, ← Finset.card_compl, compl_compl]\n  refine' (congr_arg _ σ.sum_cycle_type).mp (Multiset.dvd_sum fun k hk => _)\n  obtain ⟨m, -, hm⟩ := (Nat.dvd_prime_pow hp.out).mp (orderOf_dvd_of_pow_eq_one hσ)\n  obtain ⟨l, -, rfl⟩ := (Nat.dvd_prime_pow hp.out).mp ((congr_arg _ hm).mp (dvd_of_mem_cycle_type hk))\n  exact dvd_pow_self _ fun h => (one_lt_of_mem_cycle_type hk).ne <| by rw [h, pow_zero]\n#align card_compl_support_modeq card_compl_support_modeq\n\n",
 "card":
 "theorem card [Fintype G] : Fintype.card (vectorsProdEqOne G n) = Fintype.card G ^ (n - 1) :=\n  (Fintype.card_congr (equivVector G n)).trans (card_vector (n - 1))\n#align card card\n\n"}