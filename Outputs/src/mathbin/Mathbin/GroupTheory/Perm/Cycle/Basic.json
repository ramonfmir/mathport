{"zpowers_equiv_support_symm_apply":
 "@[simp]\ntheorem is_cycle.zpowers_equiv_support_symm_apply {σ : perm α} (hσ : is_cycle σ) (n : ℕ) :\n    hσ.zpowers_equiv_support.symm\n        ⟨(σ ^ n) (Classical.choose hσ), pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec hσ).1)⟩ =\n      ⟨σ ^ n, n, rfl⟩ :=\n  (equiv.symm_apply_eq _).2 hσ.zpowers_equiv_support_apply\n#align is_cycle.zpowers_equiv_support_symm_apply is_cycle.zpowers_equiv_support_symm_apply\n\n",
 "zpowers_equiv_support_apply":
 "@[simp]\ntheorem is_cycle.zpowers_equiv_support_apply {σ : perm α} (hσ : is_cycle σ) {n : ℕ} :\n    hσ.zpowers_equiv_support ⟨σ ^ n, n, rfl⟩ =\n      ⟨(σ ^ n) (Classical.choose hσ), pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec hσ).1)⟩ :=\n  rfl\n#align is_cycle.zpowers_equiv_support_apply is_cycle.zpowers_equiv_support_apply\n\n",
 "zpow_apply_eq_zpow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem is_cycle_on.zpow_apply_eq_zpow_apply {s : Finset α} (hf : f.is_cycle_on s) (ha : a ∈ s) {m n : ℤ} :\n    (f ^ m) a = (f ^ n) a ↔ «expr ≡ [ZMOD ]» m n s.card :=\n  by\n  rw [Int.modEq_iff_dvd, ← hf.zpow_apply_eq ha]\n  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]\n#align is_cycle_on.zpow_apply_eq_zpow_apply is_cycle_on.zpow_apply_eq_zpow_apply\n\n",
 "zpow_apply_eq":
 "theorem is_cycle_on.zpow_apply_eq {s : Finset α} (hf : f.is_cycle_on s) (ha : a ∈ s) :\n    ∀ {n : ℤ}, (f ^ n) a = a ↔ (s.card : ℤ) ∣ n\n  | int.of_nat n => (hf.pow_apply_eq ha).trans Int.coe_nat_dvd.symm\n  | Int.negSucc n => by\n    rw [zpow_negSucc, ← inv_pow]\n    exact (hf.inv.pow_apply_eq ha).trans ((dvd_neg _ _).trans Int.coe_nat_dvd).symm\n#align is_cycle_on.zpow_apply_eq is_cycle_on.zpow_apply_eq\n\n",
 "two_le_card_support_cycle_of_iff":
 "@[simp]\ntheorem two_le_card_support_cycle_of_iff : 2 ≤ card (cycle_of f x).support ↔ f x ≠ x :=\n  by\n  refine' ⟨fun h => _, fun h => by simpa using (is_cycle_cycle_of _ h).two_le_card_support⟩\n  contrapose! h\n  rw [← cycle_of_eq_one_iff] at h\n  simp [h]\n#align two_le_card_support_cycle_of_iff two_le_card_support_cycle_of_iff\n\n",
 "two_le_card_support":
 "theorem is_cycle.two_le_card_support (h : is_cycle f) : 2 ≤ f.support.card :=\n  two_le_card_support_of_ne_one h.ne_one\n#align is_cycle.two_le_card_support is_cycle.two_le_card_support\n\n",
 "trans":
 "@[trans]\ntheorem same_cycle.trans : same_cycle f x y → same_cycle f y z → same_cycle f x z := fun ⟨i, hi⟩ ⟨j, hj⟩ =>\n  ⟨j + i, by rw [zpow_add, mul_apply, hi, hj]⟩\n#align same_cycle.trans same_cycle.trans\n\n",
 "symm":
 "@[symm]\ntheorem same_cycle.symm : same_cycle f x y → same_cycle f y x := fun ⟨i, hi⟩ =>\n  ⟨-i, by rw [zpow_neg, ← hi, inv_apply_self]⟩\n#align same_cycle.symm same_cycle.symm\n\n",
 "swap_mul":
 "theorem is_cycle.swap_mul {α : Type _} [decidable_eq α] {f : perm α} (hf : is_cycle f) {x : α} (hx : f x ≠ x)\n    (hffx : f (f x) ≠ x) : is_cycle (swap x (f x) * f) :=\n  ⟨f x, by simp [swap_apply_def, mul_apply, if_neg hffx, f.injective.eq_iff, if_neg hx, hx], fun y hy =>\n    let ⟨i, hi⟩ := hf.exists_zpow_eq hx (ne_and_ne_of_swap_mul_apply_ne_self hy).1\n    have hi : (f ^ (i - 1)) (f x) = y :=\n      calc\n        (f ^ (i - 1)) (f x) = (f ^ (i - 1) * f ^ (1 : ℤ)) x := by rw [zpow_one, mul_apply]\n        _ = y := by rwa [← zpow_add, sub_add_cancel]\n        \n    is_cycle_swap_mul_aux₂ (i - 1) hy hi⟩\n#align is_cycle.swap_mul is_cycle.swap_mul\n\n",
 "support_pow_of_pos_of_lt_order_of":
 "theorem is_cycle.support_pow_of_pos_of_lt_order_of (hf : is_cycle f) {n : ℕ} (npos : 0 < n) (hn : n < order_of f) :\n    (f ^ n).support = f.support :=\n  hf.support_pow_eq_iff.2 <| Nat.not_dvd_of_pos_of_lt npos hn\n#align is_cycle.support_pow_of_pos_of_lt_order_of is_cycle.support_pow_of_pos_of_lt_order_of\n\n",
 "support_pow_eq_iff":
 "theorem is_cycle.support_pow_eq_iff (hf : is_cycle f) {n : ℕ} : support (f ^ n) = support f ↔ ¬order_of f ∣ n :=\n  by\n  rw [order_of_dvd_iff_pow_eq_one]\n  constructor\n  · intro h H\n    refine' hf.ne_one _\n    rw [← support_eq_empty_iff, ← h, H, support_one]\n  · intro H\n    apply le_antisymm (support_pow_le _ n) _\n    intro x hx\n    contrapose! H\n    ext z\n    by_cases hz : f z = z\n    · rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply]\n    · obtain ⟨k, rfl⟩ := hf.exists_pow_eq hz (mem_support.mp hx)\n      apply (f ^ k).injective\n      rw [← mul_apply, (Commute.pow_pow_self _ _ _).eq, mul_apply]\n      simpa using H\n#align is_cycle.support_pow_eq_iff is_cycle.support_pow_eq_iff\n\n",
 "support_cycle_of_le":
 "theorem support_cycle_of_le (f : perm α) (x : α) : support (f.cycle_of x) ≤ support f :=\n  by\n  intro y hy\n  rw [mem_support, cycle_of_apply] at hy\n  split_ifs  at hy\n  · exact mem_support.mpr hy\n  · exact absurd rfl hy\n#align support_cycle_of_le support_cycle_of_le\n\n",
 "support_cycle_of_eq_nil_iff":
 "theorem support_cycle_of_eq_nil_iff : (f.cycle_of x).support = ∅ ↔ x ∉ f.support := by simp\n#align support_cycle_of_eq_nil_iff support_cycle_of_eq_nil_iff\n\n",
 "support_conj":
 "@[simp]\ntheorem support_conj : (σ * τ * σ⁻¹).support = τ.support.map σ.to_embedding :=\n  by\n  ext\n  simp only [mem_map_equiv, perm.coe_mul, comp_app, ne.def, perm.mem_support, equiv.eq_symm_apply]\n  rfl\n#align support_conj support_conj\n\n",
 "support_congr":
 "/-- Unlike `support_congr`, which assumes that `∀ (x ∈ g.support), f x = g x)`, here\nwe have the weaker assumption that `∀ (x ∈ f.support), f x = g x`. -/\ntheorem is_cycle.support_congr (hf : is_cycle f) (hg : is_cycle g) (h : f.support ⊆ g.support)\n    (h' : ∀ x ∈ f.support, f x = g x) : f = g :=\n  by\n  have : f.support = g.support := by\n    refine' le_antisymm h _\n    intro z hz\n    obtain ⟨x, hx, hf'⟩ := id hf\n    have hx' : g x ≠ x := by rwa [← h' x (mem_support.mpr hx)]\n    obtain ⟨m, hm⟩ := hg.exists_pow_eq hx' (mem_support.mp hz)\n    have h'' : ∀ x ∈ f.support ∩ g.support, f x = g x :=\n      by\n      intro x hx\n      exact h' x (mem_of_mem_inter_left hx)\n    rwa [← hm, ← pow_eq_on_of_mem_support h'' _ x (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')),\n      pow_apply_mem_support, mem_support]\n  refine' support_congr h _\n  simpa [← this] using h'\n#align is_cycle.support_congr is_cycle.support_congr\n\n",
 "sum_smul_sum_eq_sum_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sum_smul_sum_eq_sum_perm (hσ : σ.is_cycle_on s) (f : ι → α) (g : ι → β) :\n    «expr • » (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i))\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range s.card)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          («expr • » (f i) (g ((σ ^ k) i)))) :=\n  by\n  simp_rw [sum_smul_sum, product_self_eq_disj_Union_perm hσ, sum_disj_Union, sum_map]\n  rfl\n#align sum_smul_sum_eq_sum_perm sum_smul_sum_eq_sum_perm\n\n",
 "sum_mul_sum_eq_sum_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_mul_sum_eq_sum_perm (hσ : σ.is_cycle_on s) (f g : ι → α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i) *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range s.card)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (f i * g ((σ ^ k) i))) :=\n  sum_smul_sum_eq_sum_perm hσ f g\n#align sum_mul_sum_eq_sum_perm sum_mul_sum_eq_sum_perm\n\n",
 "subtype_perm":
 "/-- Note that the identity is a cycle on any subsingleton set, but not a cycle. -/\nprotected theorem is_cycle_on.subtype_perm (hf : f.is_cycle_on s) :\n    (f.subtype_perm fun _ => hf.apply_mem_iff.symm : perm s).is_cycle_on Set.univ :=\n  by\n  obtain hs | hs := s.subsingleton_or_nontrivial\n  · haveI := hs.coe_sort\n    exact is_cycle_on_of_subsingleton _ _\n  convert (hf.is_cycle_subtype_perm hs).is_cycle_on\n  rw [eq_comm, Set.eq_univ_iff_forall]\n  exact fun x => ne_of_apply_ne (coe : s → α) (hf.apply_ne hs x.prop)\n#align is_cycle_on.subtype_perm is_cycle_on.subtype_perm\n\n",
 "sign":
 "theorem is_cycle.sign : ∀ {f : perm α} (hf : is_cycle f), sign f = -(-1) ^ f.support.card\n  | f => fun hf =>\n    let ⟨x, hx⟩ := hf\n    calc\n      sign f = sign (swap x (f x) * (swap x (f x) * f)) := by rw [← mul_assoc, mul_def, mul_def, swap_swap, trans_refl]\n      _ = -(-1) ^ f.support.card :=\n        if h1 : f (f x) = x then\n          by\n          have h : swap x (f x) * f = 1 :=\n            by\n            rw [hf.eq_swap_of_apply_apply_eq_self hx.1 h1]\n            simp only [perm.mul_def, perm.one_def, swap_apply_left, swap_swap]\n          rw [sign_mul, sign_swap hx.1.symm, h, sign_one, hf.eq_swap_of_apply_apply_eq_self hx.1 h1,\n            card_support_swap hx.1.symm]\n          rfl\n        else\n          by\n          have h : card (support (swap x (f x) * f)) + 1 = card (support f) := by\n            rw [← insert_erase (mem_support.2 hx.1), support_swap_mul_eq _ _ h1,\n              card_insert_of_not_mem (not_mem_erase _ _), sdiff_singleton_eq_erase]\n          have wf : card (support (swap x (f x) * f)) < card (support f) := card_support_swap_mul hx.1\n          rw [sign_mul, sign_swap hx.1.symm, (hf.swap_mul hx.1 h1).sign, ← h]\n          simp only [pow_add, mul_one, neg_neg, one_mul, mul_neg, eq_self_iff_true, pow_one, neg_mul_neg]\n      termination_by'\n  ⟨_, measure_wf fun f => f.support.card⟩\n#align is_cycle.sign is_cycle.sign\n\n",
 "same_cycle_zpow_right":
 "@[simp]\ntheorem same_cycle_zpow_right {n : ℤ} : same_cycle f x ((f ^ n) y) ↔ same_cycle f x y := by\n  rw [same_cycle_comm, same_cycle_zpow_left, same_cycle_comm]\n#align same_cycle_zpow_right same_cycle_zpow_right\n\n",
 "same_cycle_zpow_left":
 "@[simp]\ntheorem same_cycle_zpow_left {n : ℤ} : same_cycle f ((f ^ n) x) y ↔ same_cycle f x y :=\n  (Equiv.addRight (n : ℤ)).exists_congr_left.trans <| by simp [same_cycle, zpow_add]\n#align same_cycle_zpow_left same_cycle_zpow_left\n\n",
 "same_cycle_subtype_perm":
 "@[simp]\ntheorem same_cycle_subtype_perm {h} {x y : { x // p x }} : (f.subtype_perm h).same_cycle x y ↔ f.same_cycle x y :=\n  exists_congr fun n => by simp [subtype.ext_iff]\n#align same_cycle_subtype_perm same_cycle_subtype_perm\n\n",
 "same_cycle_pow_right":
 "@[simp]\ntheorem same_cycle_pow_right {n : ℕ} : same_cycle f x ((f ^ n) y) ↔ same_cycle f x y := by\n  rw [← zpow_ofNat, same_cycle_zpow_right]\n#align same_cycle_pow_right same_cycle_pow_right\n\n",
 "same_cycle_pow_left":
 "@[simp]\ntheorem same_cycle_pow_left {n : ℕ} : same_cycle f ((f ^ n) x) y ↔ same_cycle f x y := by\n  rw [← zpow_ofNat, same_cycle_zpow_left]\n#align same_cycle_pow_left same_cycle_pow_left\n\n",
 "same_cycle_one":
 "@[simp]\ntheorem same_cycle_one : same_cycle 1 x y ↔ x = y := by simp [same_cycle]\n#align same_cycle_one same_cycle_one\n\n",
 "same_cycle_inv_apply_right":
 "@[simp]\ntheorem same_cycle_inv_apply_right : same_cycle f x (f⁻¹ y) ↔ same_cycle f x y := by\n  rw [← same_cycle_apply_right, apply_inv_self]\n#align same_cycle_inv_apply_right same_cycle_inv_apply_right\n\n",
 "same_cycle_inv_apply_left":
 "@[simp]\ntheorem same_cycle_inv_apply_left : same_cycle f (f⁻¹ x) y ↔ same_cycle f x y := by\n  rw [← same_cycle_apply_left, apply_inv_self]\n#align same_cycle_inv_apply_left same_cycle_inv_apply_left\n\n",
 "same_cycle_inv":
 "@[simp]\ntheorem same_cycle_inv : same_cycle f⁻¹ x y ↔ same_cycle f x y :=\n  (Equiv.neg _).exists_congr_left.trans <| by simp [same_cycle]\n#align same_cycle_inv same_cycle_inv\n\n",
 "same_cycle_extend_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem same_cycle_extend_domain {p : β → Prop} [decidable_pred p] {f : «expr ≃ » α (subtype p)} :\n    same_cycle (g.extend_domain f) (f x) (f y) ↔ g.same_cycle x y :=\n  exists_congr fun n => by rw [← extend_domain_zpow, extend_domain_apply_image, subtype.coe_inj, f.injective.eq_iff]\n#align same_cycle_extend_domain same_cycle_extend_domain\n\n",
 "same_cycle_conj":
 "@[simp]\ntheorem same_cycle_conj : same_cycle (g * f * g⁻¹) x y ↔ same_cycle f (g⁻¹ x) (g⁻¹ y) :=\n  exists_congr fun i => by simp [conj_zpow, eq_inv_iff_eq]\n#align same_cycle_conj same_cycle_conj\n\n",
 "same_cycle_comm":
 "theorem same_cycle_comm : same_cycle f x y ↔ same_cycle f y x :=\n  ⟨same_cycle.symm, same_cycle.symm⟩\n#align same_cycle_comm same_cycle_comm\n\n",
 "same_cycle_apply_right":
 "@[simp]\ntheorem same_cycle_apply_right : same_cycle f x (f y) ↔ same_cycle f x y := by\n  rw [same_cycle_comm, same_cycle_apply_left, same_cycle_comm]\n#align same_cycle_apply_right same_cycle_apply_right\n\n",
 "same_cycle_apply_left":
 "@[simp]\ntheorem same_cycle_apply_left : same_cycle f (f x) y ↔ same_cycle f x y :=\n  (Equiv.addRight 1).exists_congr_left.trans <| by simp [zpow_sub, same_cycle]\n#align same_cycle_apply_left same_cycle_apply_left\n\n",
 "same_cycle":
 "protected theorem is_cycle.same_cycle (hf : is_cycle f) (hx : f x ≠ x) (hy : f y ≠ y) : same_cycle f x y :=\n  let ⟨g, hg⟩ := hf\n  let ⟨a, ha⟩ := hg.2 hx\n  let ⟨b, hb⟩ := hg.2 hy\n  ⟨b - a, by rw [← ha, ← mul_apply, ← zpow_add, sub_add_cancel, hb]⟩\n#align is_cycle.same_cycle is_cycle.same_cycle\n\n",
 "rfl":
 "theorem same_cycle.rfl : same_cycle f x x :=\n  same_cycle.refl _ _\n#align same_cycle.rfl same_cycle.rfl\n\n",
 "refl":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Yaël Dillies\n-/\n@[refl]\ntheorem same_cycle.refl (f : perm α) (x : α) : same_cycle f x x :=\n  ⟨0, rfl⟩\n#align same_cycle.refl same_cycle.refl\n\n",
 "range_zpow":
 "theorem is_cycle_on.range_zpow (h : f.is_cycle_on s) (ha : a ∈ s) : Set.range (fun n => (f ^ n) a : ℤ → α) = s :=\n  Set.Subset.antisymm (Set.range_subset_iff.2 fun n => (h.1.perm_zpow _).maps_to ha) <| h.2 ha\n#align is_cycle_on.range_zpow is_cycle_on.range_zpow\n\n",
 "range_pow":
 "theorem is_cycle_on.range_pow (hs : s.finite) (h : f.is_cycle_on s) (ha : a ∈ s) :\n    Set.range (fun n => (f ^ n) a : ℕ → α) = s :=\n  Set.Subset.antisymm (Set.range_subset_iff.2 fun n => h.1.maps_to.perm_pow _ ha) fun x => h.exists_pow_eq' hs ha\n#align is_cycle_on.range_pow is_cycle_on.range_pow\n\n",
 "product_self_eq_disj_Union_perm_aux":
 "theorem product_self_eq_disj_Union_perm_aux (hf : f.is_cycle_on s) :\n    (range s.card : set ℕ).pairwise_disjoint fun k => s.map ⟨fun i => (i, (f ^ k) i), fun i j => congr_arg prod.fst⟩ :=\n  by\n  obtain hs | hs := (s : set α).subsingleton_or_nontrivial\n  · refine' Set.Subsingleton.pairwise _ _\n    simp_rw [Set.Subsingleton, mem_coe, ← card_le_one] at hs⊢\n    rwa [card_range]\n  classical\n    rintro m hm n hn hmn\n    simp only [disjoint_left, function.on_fun, mem_map, Function.Embedding.coeFn_mk, exists_prop, not_exists, not_and,\n      forall_exists_index, and_imp, prod.forall, prod.mk.inj_iff]\n    rintro _ _ _ - rfl rfl a ha rfl h\n    rw [hf.pow_apply_eq_pow_apply ha] at h\n    rw [mem_coe, mem_range] at hm hn\n    exact hmn.symm (h.eq_of_lt_of_lt hn hm)\n#align product_self_eq_disj_Union_perm_aux product_self_eq_disj_Union_perm_aux\n\n",
 "product_self_eq_disj_Union_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- We can partition the square `s ×ˢ s` into shifted diagonals as such:\n```\n01234\n40123\n34012\n23401\n12340\n```\n\nThe diagonals are given by the cycle `f`.\n-/\ntheorem product_self_eq_disj_Union_perm (hf : f.is_cycle_on s) :\n    finset.product s s =\n      (range s.card).disj_Union (fun k => s.map ⟨fun i => (i, (f ^ k) i), fun i j => congr_arg prod.fst⟩)\n        (product_self_eq_disj_Union_perm_aux hf) :=\n  by\n  ext ⟨a, b⟩\n  simp only [mem_product, Equiv.Perm.coe_pow, mem_disj_Union, mem_range, mem_map, Function.Embedding.coeFn_mk,\n    prod.mk.inj_iff, exists_prop]\n  refine' ⟨fun hx => _, _⟩\n  · obtain ⟨n, hn, rfl⟩ := hf.exists_pow_eq hx.1 hx.2\n    exact ⟨n, hn, a, hx.1, rfl, by rw [f.iterate_eq_pow]⟩\n  · rintro ⟨n, -, a, ha, rfl, rfl⟩\n    exact ⟨ha, (hf.1.iterate _).maps_to ha⟩\n#align product_self_eq_disj_Union_perm product_self_eq_disj_Union_perm\n\n",
 "prod_self_eq_Union_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem prod_self_eq_Union_perm (hf : f.is_cycle_on s) :\n    finset.product s s =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (fun a => (a, (f ^ n) a)) s) :=\n  by\n  ext ⟨a, b⟩\n  simp only [mem_prod, mem_Union, mem_image]\n  refine' ⟨fun hx => _, _⟩\n  · obtain ⟨n, rfl⟩ := hf.2 hx.1 hx.2\n    exact ⟨_, _, hx.1, rfl⟩\n  · rintro ⟨n, a, ha, ⟨⟩⟩\n    exact ⟨ha, (hf.1.perm_zpow _).maps_to ha⟩\n#align prod_self_eq_Union_perm prod_self_eq_Union_perm\n\n",
 "pow_mod_card_support_cycle_of_self_apply":
 "theorem pow_mod_card_support_cycle_of_self_apply (f : perm α) (n : ℕ) (x : α) :\n    (f ^ (n % (f.cycle_of x).support.card)) x = (f ^ n) x :=\n  by\n  by_cases hx : f x = x\n  · rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]\n  ·\n    rw [← cycle_of_pow_apply_self, ← cycle_of_pow_apply_self f, ← (is_cycle_cycle_of f hx).order_of, ←\n      pow_eq_mod_order_of]\n#align pow_mod_card_support_cycle_of_self_apply pow_mod_card_support_cycle_of_self_apply\n\n",
 "pow_iff":
 "theorem is_cycle.pow_iff [Finite β] {f : perm β} (hf : is_cycle f) {n : ℕ} :\n    is_cycle (f ^ n) ↔ n.coprime (order_of f) := by\n  classical\n    cases nonempty_fintype β\n    constructor\n    · intro h\n      have hr : support (f ^ n) = support f := by\n        rw [hf.support_pow_eq_iff]\n        rintro ⟨k, rfl⟩\n        refine' h.ne_one _\n        simp [pow_mul, pow_order_of_eq_one]\n      have : order_of (f ^ n) = order_of f := by rw [h.order_of, hr, hf.order_of]\n      rw [order_of_pow, Nat.div_eq_self] at this\n      cases this\n      · exact absurd this (order_of_pos _).ne'\n      · rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm]\n    · intro h\n      obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h\n      have hf' : is_cycle ((f ^ n) ^ m) := by rwa [hm]\n      refine' hf'.of_pow fun x hx => _\n      rw [hm]\n      exact support_pow_le _ n hx\n#align is_cycle.pow_iff is_cycle.pow_iff\n\n",
 "pow_eq_pow_iff":
 "-- TODO: Define a `set`-valued support to get rid of the `finite β` assumption\ntheorem is_cycle.pow_eq_pow_iff [Finite β] {f : perm β} (hf : is_cycle f) {a b : ℕ} :\n    f ^ a = f ^ b ↔ ∃ x, f x ≠ x ∧ (f ^ a) x = (f ^ b) x := by\n  classical\n    cases nonempty_fintype β\n    constructor\n    · intro h\n      obtain ⟨x, hx, -⟩ := id hf\n      exact ⟨x, hx, by simp [h]⟩\n    · rintro ⟨x, hx, hx'⟩\n      wlog hab : a ≤ b\n      suffices f ^ (b - a) = 1 by\n        rw [pow_sub _ hab, mul_inv_eq_one] at this\n        rw [this]\n      rw [hf.pow_eq_one_iff]\n      by_cases hfa : (f ^ a) x ∈ f.support\n      · refine' ⟨(f ^ a) x, mem_support.mp hfa, _⟩\n        simp only [pow_sub _ hab, Equiv.Perm.coe_mul, Function.comp_apply, inv_apply_self, ← hx']\n      · have h := @Equiv.Perm.zpow_apply_comm _ f 1 a x\n        simp only [zpow_one, zpow_ofNat] at h\n        rw [not_mem_support, h, function.injective.eq_iff (f ^ a).injective] at hfa\n        contradiction\n#align is_cycle.pow_eq_pow_iff is_cycle.pow_eq_pow_iff\n\n",
 "pow_eq_one_iff''":
 "-- TODO: Define a `set`-valued support to get rid of the `finite β` assumption\ntheorem is_cycle.pow_eq_one_iff'' [Finite β] {f : perm β} (hf : is_cycle f) {n : ℕ} :\n    f ^ n = 1 ↔ ∀ x, f x ≠ x → (f ^ n) x = x :=\n  ⟨fun h x hx => (hf.pow_eq_one_iff' hx).1 h, fun h =>\n    let ⟨x, hx, _⟩ := id hf\n    (hf.pow_eq_one_iff' hx).2 (h _ hx)⟩\n#align is_cycle.pow_eq_one_iff'' is_cycle.pow_eq_one_iff''\n\n",
 "pow_eq_one_iff'":
 "-- TODO: Define a `set`-valued support to get rid of the `finite β` assumption\ntheorem is_cycle.pow_eq_one_iff' [Finite β] {f : perm β} (hf : is_cycle f) {n : ℕ} {x : β} (hx : f x ≠ x) :\n    f ^ n = 1 ↔ (f ^ n) x = x :=\n  ⟨fun h => fun_like.congr_fun h x, fun h => hf.pow_eq_one_iff.2 ⟨x, hx, h⟩⟩\n#align is_cycle.pow_eq_one_iff' is_cycle.pow_eq_one_iff'\n\n",
 "pow_eq_one_iff":
 "-- TODO: Define a `set`-valued support to get rid of the `finite β` assumption\ntheorem is_cycle.pow_eq_one_iff [Finite β] {f : perm β} (hf : is_cycle f) {n : ℕ} :\n    f ^ n = 1 ↔ ∃ x, f x ≠ x ∧ (f ^ n) x = x := by\n  classical\n    cases nonempty_fintype β\n    constructor\n    · intro h\n      obtain ⟨x, hx, -⟩ := id hf\n      exact ⟨x, hx, by simp [h]⟩\n    · rintro ⟨x, hx, hx'⟩\n      by_cases h : support (f ^ n) = support f\n      · rw [← mem_support, ← h, mem_support] at hx\n        contradiction\n      · rw [hf.support_pow_eq_iff, not_not] at h\n        obtain ⟨k, rfl⟩ := h\n        rw [pow_mul, pow_order_of_eq_one, one_pow]\n#align is_cycle.pow_eq_one_iff is_cycle.pow_eq_one_iff\n\n",
 "pow_card_apply":
 "theorem is_cycle_on.pow_card_apply {s : Finset α} (hf : f.is_cycle_on s) (ha : a ∈ s) : (f ^ s.card) a = a :=\n  (hf.pow_apply_eq ha).2 dvd_rfl\n#align is_cycle_on.pow_card_apply is_cycle_on.pow_card_apply\n\n",
 "pow_apply_eq_pow_mod_order_of_cycle_of_apply":
 "theorem pow_apply_eq_pow_mod_order_of_cycle_of_apply (f : perm α) (n : ℕ) (x : α) :\n    (f ^ n) x = (f ^ (n % order_of (cycle_of f x))) x := by\n  rw [← cycle_of_pow_apply_self f, ← cycle_of_pow_apply_self f, pow_eq_mod_order_of]\n#align pow_apply_eq_pow_mod_order_of_cycle_of_apply pow_apply_eq_pow_mod_order_of_cycle_of_apply\n\n",
 "pow_apply_eq_pow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem is_cycle_on.pow_apply_eq_pow_apply {s : Finset α} (hf : f.is_cycle_on s) (ha : a ∈ s) {m n : ℕ} :\n    (f ^ m) a = (f ^ n) a ↔ «expr ≡ [MOD ]» m n s.card :=\n  by\n  rw [Nat.modEq_iff_dvd, ← hf.zpow_apply_eq ha]\n  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]\n#align is_cycle_on.pow_apply_eq_pow_apply is_cycle_on.pow_apply_eq_pow_apply\n\n",
 "pow_apply_eq":
 "-- TODO: Theory of order of an element under an action\ntheorem is_cycle_on.pow_apply_eq {s : Finset α} (hf : f.is_cycle_on s) (ha : a ∈ s) {n : ℕ} :\n    (f ^ n) a = a ↔ s.card ∣ n :=\n  by\n  obtain rfl | hs := Finset.eq_singleton_or_nontrivial ha\n  · rw [coe_singleton, is_cycle_on_singleton] at hf\n    simpa using is_fixed_pt.iterate hf n\n  classical\n    have h : ∀ x ∈ s.attach, ¬f ↑x = ↑x := fun x hx => hf.apply_ne hs x.prop\n    have := (hf.is_cycle_subtype_perm hs).order_of\n    simp only [filter_true_of_mem h, support_subtype_perm, card_attach] at this\n    rw [← this, order_of_dvd_iff_pow_eq_one,\n      (hf.is_cycle_subtype_perm hs).pow_eq_one_iff' (ne_of_apply_ne (coe : s → α) <| hf.apply_ne hs (⟨a, ha⟩ : s).prop)]\n    simp only [subtype.coe_mk, subtype_perm_pow, subtype_perm_apply]\n#align is_cycle_on.pow_apply_eq is_cycle_on.pow_apply_eq\n\n",
 "order_of":
 "protected theorem is_cycle.order_of (hf : is_cycle f) : order_of f = f.support.card :=\n  by\n  rw [order_eq_card_zpowers, ← fintype.card_coe]\n  convert fintype.card_congr (is_cycle.zpowers_equiv_support hf)\n#align is_cycle.order_of is_cycle.order_of\n\n",
 "of_zpow":
 "theorem is_cycle_on.of_zpow {n : ℤ} (hf : (f ^ n).is_cycle_on s) (h : Set.BijOn f s s) : f.is_cycle_on s :=\n  ⟨h, fun x hx y hy => (hf.2 hx hy).of_zpow⟩\n#align is_cycle_on.of_zpow is_cycle_on.of_zpow\n\n",
 "of_pow":
 "theorem is_cycle_on.of_pow {n : ℕ} (hf : (f ^ n).is_cycle_on s) (h : Set.BijOn f s s) : f.is_cycle_on s :=\n  ⟨h, fun x hx y hy => (hf.2 hx hy).of_pow⟩\n#align is_cycle_on.of_pow is_cycle_on.of_pow\n\n",
 "not_is_cycle_one":
 "@[simp]\ntheorem not_is_cycle_one : ¬(1 : perm α).is_cycle := fun H => H.ne_one rfl\n#align not_is_cycle_one not_is_cycle_one\n\n",
 "nodup_of_pairwise_disjoint_cycles":
 "theorem nodup_of_pairwise_disjoint_cycles {l : list (perm β)} (h1 : ∀ f ∈ l, is_cycle f) (h2 : l.pairwise disjoint) :\n    l.nodup :=\n  nodup_of_pairwise_disjoint (fun h => (h1 1 h).ne_one rfl) h2\n#align nodup_of_pairwise_disjoint_cycles nodup_of_pairwise_disjoint_cycles\n\n",
 "ne_one":
 "theorem is_cycle.ne_one (h : is_cycle f) : f ≠ 1 := fun hf => by simpa [hf, is_cycle] using h\n#align is_cycle.ne_one is_cycle.ne_one\n\n",
 "mem_support_iff":
 "theorem same_cycle.mem_support_iff (h : same_cycle f x y) : x ∈ support f ↔ y ∈ support f :=\n  ⟨fun hx => support_cycle_of_le f x (mem_support_cycle_of_iff.mpr ⟨h, hx⟩), fun hy =>\n    support_cycle_of_le f y (mem_support_cycle_of_iff.mpr ⟨h.symm, hy⟩)⟩\n#align same_cycle.mem_support_iff same_cycle.mem_support_iff\n\n",
 "mem_support_cycle_of_iff'":
 "theorem mem_support_cycle_of_iff' (hx : f x ≠ x) : y ∈ support (f.cycle_of x) ↔ same_cycle f x y := by\n  rw [mem_support_cycle_of_iff, and_iff_left (mem_support.2 hx)]\n#align mem_support_cycle_of_iff' mem_support_cycle_of_iff'\n\n",
 "mem_support_cycle_of_iff":
 "theorem mem_support_cycle_of_iff : y ∈ support (f.cycle_of x) ↔ same_cycle f x y ∧ x ∈ support f :=\n  by\n  by_cases hx : f x = x\n  · rw [(cycle_of_eq_one_iff _).mpr hx]\n    simp [hx]\n  · rw [mem_support, cycle_of_apply]\n    split_ifs with hy\n    · simp only [hx, hy, iff_true_iff, ne.def, not_false_iff, and_self_iff, mem_support]\n      rcases hy with ⟨k, rfl⟩\n      rw [← not_mem_support]\n      simpa using hx\n    · simpa [hx] using hy\n#align mem_support_cycle_of_iff mem_support_cycle_of_iff\n\n",
 "mem_list_cycles_iff":
 "theorem mem_list_cycles_iff {α : Type _} [Finite α] {l : list (perm α)} (h1 : ∀ σ : perm α, σ ∈ l → σ.is_cycle)\n    (h2 : l.pairwise disjoint) {σ : perm α} : σ ∈ l ↔ σ.is_cycle ∧ ∀ (a : α) (h4 : σ a ≠ a), σ a = l.prod a :=\n  by\n  suffices σ.is_cycle → (σ ∈ l ↔ ∀ (a : α) (h4 : σ a ≠ a), σ a = l.prod a) by\n    exact ⟨fun hσ => ⟨h1 σ hσ, (this (h1 σ hσ)).mp hσ⟩, fun hσ => (this hσ.1).mpr hσ.2⟩\n  intro h3\n  classical\n    cases nonempty_fintype α\n    constructor\n    · intro h a ha\n      exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)\n    · intro h\n      have hσl : σ.support ⊆ l.prod.support := by\n        intro x hx\n        rw [mem_support] at hx\n        rwa [mem_support, ← h _ hx]\n      obtain ⟨a, ha, -⟩ := id h3\n      rw [← mem_support] at ha\n      obtain ⟨τ, hτ, hτa⟩ := exists_mem_support_of_mem_support_prod (hσl ha)\n      have hτl : ∀ x ∈ τ.support, τ x = l.prod x := eq_on_support_mem_disjoint hτ h2\n      have key : ∀ x ∈ σ.support ∩ τ.support, σ x = τ x :=\n        by\n        intro x hx\n        rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hτl x (mem_of_mem_inter_right hx)]\n      convert hτ\n      refine' h3.eq_on_support_inter_nonempty_congr (h1 _ hτ) key _ ha\n      exact key a (mem_inter_of_mem ha hτa)\n#align mem_list_cycles_iff mem_list_cycles_iff\n\n",
 "mem_cycle_factors_finset_support_le":
 "theorem mem_cycle_factors_finset_support_le {p f : perm α} (h : p ∈ cycle_factors_finset f) : p.support ≤ f.support :=\n  by\n  rw [mem_cycle_factors_finset_iff] at h\n  intro x hx\n  rwa [mem_support, ← h.right x hx, ← mem_support]\n#align mem_cycle_factors_finset_support_le mem_cycle_factors_finset_support_le\n\n",
 "mem_cycle_factors_finset_iff":
 "theorem mem_cycle_factors_finset_iff {f p : perm α} :\n    p ∈ cycle_factors_finset f ↔ p.is_cycle ∧ ∀ a ∈ p.support, p a = f a :=\n  by\n  obtain ⟨l, hl, hl'⟩ := f.cycle_factors_finset.exists_list_nodup_eq\n  rw [← hl']\n  rw [eq_comm, cycle_factors_finset_eq_list_to_finset hl] at hl'\n  simpa [List.mem_toFinset, ne.def, ← hl'.right.right] using mem_list_cycles_iff hl'.left hl'.right.left\n#align mem_cycle_factors_finset_iff mem_cycle_factors_finset_iff\n\n",
 "list_cycles_perm_list_cycles":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem list_cycles_perm_list_cycles {α : Type _} [Finite α] {l₁ l₂ : list (perm α)} (h₀ : l₁.prod = l₂.prod)\n    (h₁l₁ : ∀ σ : perm α, σ ∈ l₁ → σ.is_cycle) (h₁l₂ : ∀ σ : perm α, σ ∈ l₂ → σ.is_cycle) (h₂l₁ : l₁.pairwise disjoint)\n    (h₂l₂ : l₂.pairwise disjoint) : list.perm l₁ l₂ := by\n  classical\n    refine'\n      (List.perm_ext (nodup_of_pairwise_disjoint_cycles h₁l₁ h₂l₁) (nodup_of_pairwise_disjoint_cycles h₁l₂ h₂l₂)).mpr\n        fun σ => _\n    by_cases hσ : σ.is_cycle\n    · obtain ⟨a, ha⟩ := not_forall.mp (mt ext hσ.ne_one)\n      rw [mem_list_cycles_iff h₁l₁ h₂l₁, mem_list_cycles_iff h₁l₂ h₂l₂, h₀]\n    · exact iff_of_false (mt (h₁l₁ σ) hσ) (mt (h₁l₂ σ) hσ)\n#align list_cycles_perm_list_cycles list_cycles_perm_list_cycles\n\n",
 "is_cycle_swap_mul_aux₂":
 "theorem is_cycle_swap_mul_aux₂ {α : Type _} [decidable_eq α] :\n    ∀ (n : ℤ) {b x : α} {f : perm α} (hb : (swap x (f x) * f) b ≠ b) (h : (f ^ n) (f x) = b),\n      ∃ i : ℤ, ((swap x (f x) * f) ^ i) (f x) = b\n  | (n : ℕ) => fun b x f => is_cycle_swap_mul_aux₁ n\n  | -[n+1] => fun b x f hb h =>\n    if hfbx' : f x = b then ⟨0, hfbx'⟩\n    else\n      have : f b ≠ b ∧ b ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hb\n      have hb : (swap x (f⁻¹ x) * f⁻¹) (f⁻¹ b) ≠ f⁻¹ b :=\n        by\n        rw [mul_apply, swap_apply_def]\n        split_ifs <;> simp only [inv_eq_iff_eq, perm.mul_apply, zpow_negSucc, ne.def, perm.apply_inv_self] at * <;> cc\n      let ⟨i, hi⟩ :=\n        is_cycle_swap_mul_aux₁ n hb\n          (show (f⁻¹ ^ n) (f⁻¹ x) = f⁻¹ b by\n            rw [← zpow_ofNat, ← h, ← mul_apply, ← mul_apply, ← mul_apply, zpow_negSucc, ← inv_pow, pow_succ', mul_assoc,\n              mul_assoc, inv_mul_self, mul_one, zpow_ofNat, ← pow_succ', ← pow_succ])\n      have h : (swap x (f⁻¹ x) * f⁻¹) (f x) = f⁻¹ x := by rw [mul_apply, inv_apply_self, swap_apply_left]\n      ⟨-i, by\n        rw [← add_sub_cancel i 1, neg_sub, sub_eq_add_neg, zpow_add, zpow_one, zpow_neg, ← inv_zpow, mul_inv_rev,\n          swap_inv, mul_swap_eq_swap_mul, inv_apply_self, swap_comm _ x, zpow_add, zpow_one, mul_apply,\n          mul_apply (_ ^ i), h, hi, mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (ne.symm hfbx')]⟩\n#align is_cycle_swap_mul_aux₂ is_cycle_swap_mul_aux₂\n\n",
 "is_cycle_swap_mul_aux₁":
 "theorem is_cycle_swap_mul_aux₁ {α : Type _} [decidable_eq α] :\n    ∀ (n : ℕ) {b x : α} {f : perm α} (hb : (swap x (f x) * f) b ≠ b) (h : (f ^ n) (f x) = b),\n      ∃ i : ℤ, ((swap x (f x) * f) ^ i) (f x) = b\n  | 0 => fun b x f hb h => ⟨0, h⟩\n  | (n + 1 : ℕ) => fun b x f hb h =>\n    if hfbx : f x = b then ⟨0, hfbx⟩\n    else\n      have : f b ≠ b ∧ b ≠ x := ne_and_ne_of_swap_mul_apply_ne_self hb\n      have hb' : (swap x (f x) * f) (f⁻¹ b) ≠ f⁻¹ b :=\n        by\n        rw [mul_apply, apply_inv_self, swap_apply_of_ne_of_ne this.2 (ne.symm hfbx), ne.def, ← f.injective.eq_iff,\n          apply_inv_self]\n        exact this.1\n      let ⟨i, hi⟩ :=\n        is_cycle_swap_mul_aux₁ n hb'\n          (f.injective <| by\n            rw [apply_inv_self]\n            rwa [pow_succ, mul_apply] at h)\n      ⟨i + 1, by\n        rw [add_comm, zpow_add, mul_apply, hi, zpow_one, mul_apply, apply_inv_self,\n          swap_apply_of_ne_of_ne (ne_and_ne_of_swap_mul_apply_ne_self hb).2 (ne.symm hfbx)]⟩\n#align is_cycle_swap_mul_aux₁ is_cycle_swap_mul_aux₁\n\n",
 "is_cycle_swap":
 "theorem is_cycle_swap (hxy : x ≠ y) : is_cycle (swap x y) :=\n  ⟨y, by rwa [swap_apply_right], fun a (ha : ite (a = x) y (ite (a = y) x a) ≠ a) =>\n    if hya : y = a then ⟨0, hya⟩\n    else\n      ⟨1, by\n        rw [zpow_one, swap_apply_def]\n        split_ifs  at * <;> cc⟩⟩\n#align is_cycle_swap is_cycle_swap\n\n",
 "is_cycle_subtype_perm":
 "/-- Note that the identity satisfies `is_cycle_on` for any subsingleton set, but not `is_cycle`. -/\ntheorem is_cycle_on.is_cycle_subtype_perm (hf : f.is_cycle_on s) (hs : s.nontrivial) :\n    (f.subtype_perm fun _ => hf.apply_mem_iff.symm : perm s).is_cycle :=\n  by\n  obtain ⟨a, ha⟩ := hs.nonempty\n  exact\n    ⟨⟨a, ha⟩, ne_of_apply_ne (coe : s → α) (hf.apply_ne hs ha), fun b hb =>\n      (hf.2 (⟨a, ha⟩ : s).prop b.prop).subtype_perm⟩\n#align is_cycle_on.is_cycle_subtype_perm is_cycle_on.is_cycle_subtype_perm\n\n",
 "is_cycle_pow_pos_of_lt_prime_order":
 "theorem is_cycle.is_cycle_pow_pos_of_lt_prime_order [Finite β] {f : perm β} (hf : is_cycle f) (hf' : (order_of f).prime)\n    (n : ℕ) (hn : 0 < n) (hn' : n < order_of f) : is_cycle (f ^ n) := by\n  classical\n    cases nonempty_fintype β\n    have : n.coprime (order_of f) := by\n      refine' nat.coprime.symm _\n      rw [Nat.Prime.coprime_iff_not_dvd hf']\n      exact Nat.not_dvd_of_pos_of_lt hn hn'\n    obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime this\n    have hf'' := hf\n    rw [← hm] at hf''\n    refine' hf''.of_pow _\n    rw [hm]\n    exact support_pow_le f n\n#align is_cycle.is_cycle_pow_pos_of_lt_prime_order is_cycle.is_cycle_pow_pos_of_lt_prime_order\n\n",
 "is_cycle_on_swap":
 "theorem is_cycle_on_swap [decidable_eq α] (hab : a ≠ b) : (swap a b).is_cycle_on {a, b} :=\n  ⟨bijOn_swap (by simp) (by simp), fun x hx y hy =>\n    by\n    rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hx hy\n    obtain rfl | rfl := hx <;> obtain rfl | rfl := hy\n    · exact ⟨0, by rw [zpow_zero, coe_one, id.def]⟩\n    · exact ⟨1, by rw [zpow_one, swap_apply_left]⟩\n    · exact ⟨1, by rw [zpow_one, swap_apply_right]⟩\n    · exact ⟨0, by rw [zpow_zero, coe_one, id.def]⟩⟩\n#align is_cycle_on_swap is_cycle_on_swap\n\n",
 "is_cycle_on_support_cycle_of":
 "theorem is_cycle_on_support_cycle_of (f : perm α) (x : α) : f.is_cycle_on (f.cycle_of x).support :=\n  ⟨f.bij_on <| by simp [mem_support_cycle_of_iff], fun a ha b hb =>\n    by\n    rw [mem_coe, mem_support_cycle_of_iff] at ha hb\n    exact ha.1.symm.trans hb.1⟩\n#align is_cycle_on_support_cycle_of is_cycle_on_support_cycle_of\n\n",
 "is_cycle_on_singleton":
 "@[simp]\ntheorem is_cycle_on_singleton : f.is_cycle_on {a} ↔ f a = a := by simp [is_cycle_on, same_cycle.rfl]\n#align is_cycle_on_singleton is_cycle_on_singleton\n\n",
 "is_cycle_on_one":
 "@[simp]\ntheorem is_cycle_on_one : (1 : perm α).is_cycle_on s ↔ s.subsingleton := by\n  simp [is_cycle_on, Set.bijOn_id, Set.Subsingleton]\n#align is_cycle_on_one is_cycle_on_one\n\n",
 "is_cycle_on_of_subsingleton":
 "theorem is_cycle_on_of_subsingleton [subsingleton α] (f : perm α) (s : set α) : f.is_cycle_on s :=\n  ⟨s.bij_on_of_subsingleton _, fun x _ y _ => (subsingleton.elim x y).same_cycle _⟩\n#align is_cycle_on_of_subsingleton is_cycle_on_of_subsingleton\n\n",
 "is_cycle_on_inv":
 "@[simp]\ntheorem is_cycle_on_inv : f⁻¹.is_cycle_on s ↔ f.is_cycle_on s := by simp [is_cycle_on, set.bij_on_perm_inv]\n#align is_cycle_on_inv is_cycle_on_inv\n\n",
 "is_cycle_on_form_perm":
 "theorem nodup.is_cycle_on_form_perm (h : l.nodup) : l.form_perm.is_cycle_on { a | a ∈ l } :=\n  by\n  refine' ⟨l.form_perm.bij_on fun _ => form_perm_mem_iff_mem, fun a ha b hb => _⟩\n  rw [Set.mem_setOf, ← index_of_lt_length] at ha hb\n  rw [← index_of_nth_le ha, ← index_of_nth_le hb]\n  refine' ⟨l.index_of b - l.index_of a, _⟩\n  simp only [sub_eq_neg_add, zpow_add, zpow_neg, Equiv.Perm.inv_eq_iff_eq, zpow_ofNat, Equiv.Perm.coe_mul,\n    form_perm_pow_apply_nth_le _ h]\n  rw [add_comm]\n#align nodup.is_cycle_on_form_perm nodup.is_cycle_on_form_perm\n\n",
 "is_cycle_on_empty":
 "@[simp]\ntheorem is_cycle_on_empty : f.is_cycle_on ∅ := by simp [is_cycle_on]\n#align is_cycle_on_empty is_cycle_on_empty\n\n",
 "is_cycle_on":
 "protected theorem is_cycle.is_cycle_on (hf : f.is_cycle) : f.is_cycle_on { x | f x ≠ x } :=\n  ⟨f.bij_on fun x => f.apply_eq_iff_eq.not, fun a ha b => hf.same_cycle ha⟩\n#align is_cycle.is_cycle_on is_cycle.is_cycle_on\n\n",
 "is_cycle_inv":
 "@[simp]\ntheorem is_cycle_inv : is_cycle f⁻¹ ↔ is_cycle f :=\n  ⟨fun h => by\n    convert h.inv\n    rw [inv_inv], is_cycle.inv⟩\n#align is_cycle_inv is_cycle_inv\n\n",
 "is_cycle_iff_same_cycle":
 "theorem is_cycle_iff_same_cycle (hx : f x ≠ x) : is_cycle f ↔ ∀ {y}, same_cycle f x y ↔ f y ≠ y :=\n  ⟨fun hf y =>\n    ⟨fun ⟨i, hi⟩ hy =>\n      hx <| by\n        rw [← zpow_apply_eq_self_of_apply_eq_self hy i, (f ^ i).injective.eq_iff] at hi\n        rw [hi, hy],\n      hf.exists_zpow_eq hx⟩,\n    fun h => ⟨x, hx, fun y hy => h.2 hy⟩⟩\n#align is_cycle_iff_same_cycle is_cycle_iff_same_cycle\n\n",
 "is_cycle_iff_exists_is_cycle_on":
 "/-- This lemma demonstrates the relation between `equiv.perm.is_cycle` and `equiv.perm.is_cycle_on`\nin non-degenerate cases. -/\ntheorem is_cycle_iff_exists_is_cycle_on :\n    f.is_cycle ↔ ∃ s : set α, s.nontrivial ∧ f.is_cycle_on s ∧ ∀ ⦃x⦄, ¬IsFixedPt f x → x ∈ s :=\n  by\n  refine' ⟨fun hf => ⟨{ x | f x ≠ x }, _, hf.is_cycle_on, fun _ => id⟩, _⟩\n  · obtain ⟨a, ha⟩ := hf\n    exact ⟨f a, f.injective.ne ha.1, a, ha.1, ha.1⟩\n  · rintro ⟨s, hs, hf, hsf⟩\n    obtain ⟨a, ha⟩ := hs.nonempty\n    exact ⟨a, hf.apply_ne hs ha, fun b hb => hf.2 ha <| hsf hb⟩\n#align is_cycle_iff_exists_is_cycle_on is_cycle_iff_exists_is_cycle_on\n\n",
 "is_cycle_cycle_of_iff":
 "/-- `x` is in the support of `f` iff `equiv.perm.cycle_of f x` is a cycle. -/\ntheorem is_cycle_cycle_of_iff (f : perm α) : is_cycle (cycle_of f x) ↔ f x ≠ x :=\n  by\n  refine' ⟨fun hx => _, f.is_cycle_cycle_of⟩\n  rw [ne.def, ← cycle_of_eq_one_iff f]\n  exact hx.ne_one\n#align is_cycle_cycle_of_iff is_cycle_cycle_of_iff\n\n",
 "is_cycle_cycle_of":
 "theorem is_cycle_cycle_of (f : perm α) (hx : f x ≠ x) : is_cycle (cycle_of f x) :=\n  have : cycle_of f x x ≠ x := by rwa [same_cycle.rfl.cycle_of_apply]\n  (is_cycle_iff_same_cycle this).2 fun y =>\n    ⟨fun h => mt h.apply_eq_self_iff.2 this, fun h =>\n      if hxy : same_cycle f x y then\n        let ⟨i, hi⟩ := hxy\n        ⟨i, by rw [cycle_of_zpow_apply_self, hi]⟩\n      else by\n        rw [cycle_of_apply_of_not_same_cycle hxy] at h\n        exact (h rfl).elim⟩\n#align is_cycle_cycle_of is_cycle_cycle_of\n\n",
 "is_cycle":
 "protected theorem is_swap.is_cycle : is_swap f → is_cycle f :=\n  by\n  rintro ⟨x, y, hxy, rfl⟩\n  exact is_cycle_swap hxy\n#align is_swap.is_cycle is_swap.is_cycle\n\n",
 "is_conj_of_support_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem is_conj_of_support_equiv (f : «expr ≃ » { x // x ∈ (σ.support : set α) } { x // x ∈ (τ.support : set α) })\n    (hf : ∀ (x : α) (hx : x ∈ (σ.support : set α)), (f ⟨σ x, apply_mem_support.2 hx⟩ : α) = τ ↑(f ⟨x, hx⟩)) :\n    IsConj σ τ := by\n  refine' isConj_iff.2 ⟨equiv.extend_subtype f, _⟩\n  rw [mul_inv_eq_iff_eq_mul]\n  ext\n  simp only [perm.mul_apply]\n  by_cases hx : x ∈ σ.support\n  · rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem]\n    · exact hf x (Finset.mem_coe.2 hx)\n  ·\n    rwa [not_not.1 ((not_congr mem_support).1 (equiv.extend_subtype_not_mem f _ _)),\n      not_not.1 ((not_congr mem_support).mp hx)]\n#align is_conj_of_support_equiv is_conj_of_support_equiv\n\n",
 "is_conj_mul":
 "theorem disjoint.is_conj_mul {α : Type _} [Finite α] {σ τ π ρ : perm α} (hc1 : IsConj σ π) (hc2 : IsConj τ ρ)\n    (hd1 : disjoint σ τ) (hd2 : disjoint π ρ) : IsConj (σ * τ) (π * ρ) := by\n  classical\n    cases nonempty_fintype α\n    obtain ⟨f, rfl⟩ := isConj_iff.1 hc1\n    obtain ⟨g, rfl⟩ := isConj_iff.1 hc2\n    have hd1' := coe_inj.2 hd1.support_mul\n    have hd2' := coe_inj.2 hd2.support_mul\n    rw [coe_union] at *\n    have hd1'' := disjoint_coe.2 (disjoint_iff_disjoint_support.1 hd1)\n    have hd2'' := disjoint_coe.2 (disjoint_iff_disjoint_support.1 hd2)\n    refine' is_conj_of_support_equiv _ _\n    ·\n      refine'\n          ((Equiv.Set.ofEq hd1').trans (Equiv.Set.union hd1''.le_bot)).trans\n            ((Equiv.sumCongr (subtype_equiv f fun a => _) (subtype_equiv g fun a => _)).trans\n              ((Equiv.Set.ofEq hd2').trans (Equiv.Set.union hd2''.le_bot)).symm) <;>\n        · simp only [Set.mem_image, to_embedding_apply, exists_eq_right, support_conj, coe_map, apply_eq_iff_eq]\n    · intro x hx\n      simp only [trans_apply, symm_trans_apply, set.of_eq_apply, set.of_eq_symm_apply, equiv.sum_congr_apply]\n      rw [hd1', Set.mem_union] at hx\n      cases' hx with hxσ hxτ\n      · rw [mem_coe, mem_support] at hxσ\n        rw [set.union_apply_left hd1''.le_bot _, set.union_apply_left hd1''.le_bot _]\n        simp only [subtype_equiv_apply, perm.coe_mul, sum.map_inl, comp_app, set.union_symm_apply_left, subtype.coe_mk,\n          apply_eq_iff_eq]\n        · have h := (hd2 (f x)).resolve_left _\n          · rw [mul_apply, mul_apply] at h\n            rw [h, inv_apply_self, (hd1 x).resolve_left hxσ]\n          · rwa [mul_apply, mul_apply, inv_apply_self, apply_eq_iff_eq]\n        · rwa [subtype.coe_mk, subtype.coe_mk, mem_coe, mem_support]\n        ·\n          rwa [subtype.coe_mk, subtype.coe_mk, perm.mul_apply, (hd1 x).resolve_left hxσ, mem_coe, apply_mem_support,\n            mem_support]\n      · rw [mem_coe, ← apply_mem_support, mem_support] at hxτ\n        rw [set.union_apply_right hd1''.le_bot _, set.union_apply_right hd1''.le_bot _]\n        simp only [subtype_equiv_apply, perm.coe_mul, sum.map_inr, comp_app, set.union_symm_apply_right, subtype.coe_mk,\n          apply_eq_iff_eq]\n        · have h := (hd2 (g (τ x))).resolve_right _\n          · rw [mul_apply, mul_apply] at h\n            rw [inv_apply_self, h, (hd1 (τ x)).resolve_right hxτ]\n          · rwa [mul_apply, mul_apply, inv_apply_self, apply_eq_iff_eq]\n        · rwa [subtype.coe_mk, subtype.coe_mk, mem_coe, ← apply_mem_support, mem_support]\n        · rwa [subtype.coe_mk, subtype.coe_mk, perm.mul_apply, (hd1 (τ x)).resolve_right hxτ, mem_coe, mem_support]\n#align disjoint.is_conj_mul disjoint.is_conj_mul\n\n",
 "is_conj_iff":
 "theorem is_cycle.is_conj_iff (hσ : is_cycle σ) (hτ : is_cycle τ) : IsConj σ τ ↔ σ.support.card = τ.support.card :=\n  ⟨by\n    intro h\n    obtain ⟨π, rfl⟩ := isConj_iff.1 h\n    apply finset.card_congr (fun a ha => π a) (fun _ ha => _) (fun _ _ _ _ ab => π.injective ab) fun b hb => _\n    · simp [mem_support.1 ha]\n    · refine' ⟨π⁻¹ b, ⟨_, π.apply_inv_self b⟩⟩\n      contrapose! hb\n      rw [mem_support, not_not] at hb\n      rw [mem_support, not_not, perm.mul_apply, perm.mul_apply, hb, perm.apply_inv_self], hσ.is_conj hτ⟩\n#align is_cycle.is_conj_iff is_cycle.is_conj_iff\n\n",
 "is_conj":
 "theorem is_cycle.is_conj (hσ : is_cycle σ) (hτ : is_cycle τ) (h : σ.support.card = τ.support.card) : IsConj σ τ :=\n  by\n  refine'\n    is_conj_of_support_equiv\n      (hσ.zpowers_equiv_support.symm.trans <|\n        (zpowers_equiv_zpowers <| by rw [hσ.order_of, h, hτ.order_of]).trans hτ.zpowers_equiv_support)\n      _\n  intro x hx\n  simp only [perm.mul_apply, equiv.trans_apply, equiv.sum_congr_apply]\n  obtain ⟨n, rfl⟩ := hσ.exists_pow_eq (Classical.choose_spec hσ).1 (mem_support.1 hx)\n  apply eq.trans _ (congr rfl (congr rfl (congr rfl (congr rfl (hσ.zpowers_equiv_support_symm_apply n).symm))))\n  apply (congr rfl (congr rfl (congr rfl (hσ.zpowers_equiv_support_symm_apply (n + 1))))).trans _\n  simp only [ne.def, is_cycle.zpowers_equiv_support_apply, subtype.coe_mk, zpowers_equiv_zpowers_apply]\n  rw [pow_succ, perm.mul_apply]\n#align is_cycle.is_conj is_cycle.is_conj\n\n",
 "inv":
 "theorem is_cycle.inv (hf : is_cycle f) : is_cycle f⁻¹ :=\n  hf.imp fun x ⟨hx, h⟩ => ⟨inv_eq_iff_eq.not.2 hx.symm, fun y hy => (h <| inv_eq_iff_eq.not.2 hy.symm).inv⟩\n#align is_cycle.inv is_cycle.inv\n\n",
 "fixed_point_card_lt_of_ne_one":
 "theorem fixed_point_card_lt_of_ne_one [fintype α] {σ : perm α} (h : σ ≠ 1) :\n    (filter (fun x => σ x = x) univ).card < fintype.card α - 1 :=\n  by\n  rw [lt_tsub_iff_left, ← lt_tsub_iff_right, ← finset.card_compl, finset.compl_filter]\n  exact one_lt_card_support_of_ne_one h\n#align fixed_point_card_lt_of_ne_one fixed_point_card_lt_of_ne_one\n\n",
 "extend_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_cycle_on.extend_domain {p : β → Prop} [decidable_pred p] (f : «expr ≃ » α (subtype p))\n    (h : g.is_cycle_on s) : (g.extend_domain f).is_cycle_on («expr '' » (coe ∘ f) s) :=\n  ⟨h.1.extend_domain, by\n    rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩\n    exact (h.2 ha hb).extend_domain⟩\n#align is_cycle_on.extend_domain is_cycle_on.extend_domain\n\n",
 "exists_zpow_eq":
 "theorem is_cycle.exists_zpow_eq : is_cycle f → f x ≠ x → f y ≠ y → ∃ i : ℤ, (f ^ i) x = y :=\n  is_cycle.same_cycle\n#align is_cycle.exists_zpow_eq is_cycle.exists_zpow_eq\n\n",
 "exists_pow_eq_one":
 "theorem is_cycle.exists_pow_eq_one [Finite β] {f : perm β} (hf : is_cycle f) : ∃ (k : ℕ)(hk : 1 < k), f ^ k = 1 := by\n  classical\n    have : is_of_fin_order f := exists_pow_eq_one f\n    rw [is_of_fin_order_iff_pow_eq_one] at this\n    obtain ⟨x, hx, hx'⟩ := hf\n    obtain ⟨_ | _ | k, hk, hk'⟩ := this\n    · exact absurd hk (lt_asymm hk)\n    · rw [pow_one] at hk'\n      simpa [hk'] using hx\n    · exact ⟨k + 2, by simp, hk'⟩\n#align is_cycle.exists_pow_eq_one is_cycle.exists_pow_eq_one\n\n",
 "exists_pow_eq_of_mem_support":
 "theorem same_cycle.exists_pow_eq_of_mem_support (h : same_cycle f x y) (hx : x ∈ f.support) :\n    ∃ (i : ℕ)(hi' : i < (f.cycle_of x).support.card), (f ^ i) x = y :=\n  by\n  rw [mem_support] at hx\n  refine' (f.is_cycle_on_support_cycle_of _).exists_pow_eq _ _ <;> rwa [mem_support_cycle_of_iff' hx]\n#align same_cycle.exists_pow_eq_of_mem_support same_cycle.exists_pow_eq_of_mem_support\n\n",
 "exists_pow_eq''":
 "theorem same_cycle.exists_pow_eq'' [Finite α] (h : same_cycle f x y) :\n    ∃ (i : ℕ)(hpos : 0 < i)(h : i ≤ order_of f), (f ^ i) x = y := by\n  classical\n    obtain ⟨_ | i, hi, rfl⟩ := h.exists_pow_eq'\n    · refine' ⟨order_of f, order_of_pos f, le_rfl, _⟩\n      rw [pow_order_of_eq_one, pow_zero]\n    · exact ⟨i.succ, i.zero_lt_succ, hi.le, rfl⟩\n#align same_cycle.exists_pow_eq'' same_cycle.exists_pow_eq''\n\n",
 "exists_pow_eq'":
 "theorem is_cycle_on.exists_pow_eq' (hs : s.finite) (hf : f.is_cycle_on s) (ha : a ∈ s) (hb : b ∈ s) :\n    ∃ n : ℕ, (f ^ n) a = b := by\n  lift s to Finset α using id hs\n  obtain ⟨n, -, hn⟩ := hf.exists_pow_eq ha hb\n  exact ⟨n, hn⟩\n#align is_cycle_on.exists_pow_eq' is_cycle_on.exists_pow_eq'\n\n",
 "exists_pow_eq":
 "theorem same_cycle.exists_pow_eq (f : perm α) (h : same_cycle f x y) :\n    ∃ (i : ℕ)(hi : 0 < i)(hi' : i ≤ (f.cycle_of x).support.card + 1), (f ^ i) x = y :=\n  by\n  by_cases hx : x ∈ f.support\n  · obtain ⟨k, hk, hk'⟩ := h.exists_pow_eq_of_mem_support hx\n    cases k\n    · refine' ⟨(f.cycle_of x).support.card, _, self_le_add_right _ _, _⟩\n      · refine' zero_lt_one.trans (one_lt_card_support_of_ne_one _)\n        simpa using hx\n      · simp only [perm.coe_one, id.def, pow_zero] at hk'\n        subst hk'\n        rw [← (is_cycle_cycle_of _ <| mem_support.1 hx).order_of, ← cycle_of_pow_apply_self, pow_order_of_eq_one,\n          one_apply]\n    · exact ⟨k + 1, by simp, nat.le_succ_of_le hk.le, hk'⟩\n  · refine' ⟨1, zero_lt_one, by simp, _⟩\n    obtain ⟨k, rfl⟩ := h\n    rw [not_mem_support] at hx\n    rw [pow_apply_eq_self_of_apply_eq_self hx, zpow_apply_eq_self_of_apply_eq_self hx]\n#align same_cycle.exists_pow_eq same_cycle.exists_pow_eq\n\n",
 "exists_cycle_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem countable.exists_cycle_on (hs : s.countable) : ∃ f : perm α, f.is_cycle_on s ∧ { x | f x ≠ x } ⊆ s := by\n  classical\n    obtain hs' | hs' := s.finite_or_infinite\n    · refine' ⟨hs'.to_finset.to_list.form_perm, _, fun x hx => by simpa using list.mem_of_form_perm_apply_ne _ _ hx⟩\n      convert hs'.to_finset.nodup_to_list.is_cycle_on_form_perm\n      simp\n    haveI := hs.to_subtype\n    haveI := hs'.to_subtype\n    obtain ⟨f⟩ : nonempty («expr ≃ » ℤ s) := infer_instance\n    refine'\n      ⟨(Equiv.addRight 1).extend_domain f, _, fun x hx =>\n        of_not_not fun h => hx <| perm.extend_domain_apply_not_subtype _ _ h⟩\n    convert int.add_right_one_is_cycle.is_cycle_on.extend_domain _\n    rw [image_comp, Equiv.image_eq_preimage]\n    ext\n    simp\n#align countable.exists_cycle_on countable.exists_cycle_on\n\n",
 "eq_swap_of_apply_apply_eq_self":
 "theorem is_cycle.eq_swap_of_apply_apply_eq_self {α : Type _} [decidable_eq α] {f : perm α} (hf : is_cycle f) {x : α}\n    (hfx : f x ≠ x) (hffx : f (f x) = x) : f = swap x (f x) :=\n  equiv.ext fun y =>\n    let ⟨z, hz⟩ := hf\n    let ⟨i, hi⟩ := hz.2 hfx\n    if hyx : y = x then by simp [hyx]\n    else\n      if hfyx : y = f x then by simp [hfyx, hffx]\n      else by\n        rw [swap_apply_of_ne_of_ne hyx hfyx]\n        refine' by_contradiction fun hy => _\n        cases' hz.2 hy with j hj\n        rw [← sub_add_cancel j i, zpow_add, mul_apply, hi] at hj\n        cases' zpow_apply_eq_of_apply_apply_eq_self hffx (j - i) with hji hji\n        · rw [← hj, hji] at hyx\n          cc\n        · rw [← hj, hji] at hfyx\n          cc\n#align is_cycle.eq_swap_of_apply_apply_eq_self is_cycle.eq_swap_of_apply_apply_eq_self\n\n",
 "eq_on_support_inter_nonempty_congr":
 "/-- If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. -/\ntheorem is_cycle.eq_on_support_inter_nonempty_congr (hf : is_cycle f) (hg : is_cycle g)\n    (h : ∀ x ∈ f.support ∩ g.support, f x = g x) (hx : f x = g x) (hx' : x ∈ f.support) : f = g :=\n  by\n  have hx'' : x ∈ g.support := by rwa [mem_support, ← hx, ← mem_support]\n  have : f.support ⊆ g.support := by\n    intro y hy\n    obtain ⟨k, rfl⟩ := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)\n    rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]\n  rw [(inter_eq_left_iff_subset _ _).mpr this] at h\n  exact hf.support_congr hg this h\n#align is_cycle.eq_on_support_inter_nonempty_congr is_cycle.eq_on_support_inter_nonempty_congr\n\n",
 "eq_of_right":
 "theorem same_cycle.eq_of_right (h : same_cycle f x y) (hy : IsFixedPt f y) : x = y :=\n  h.eq_of_left <| h.apply_eq_self_iff.2 hy\n#align same_cycle.eq_of_right same_cycle.eq_of_right\n\n",
 "eq_of_left":
 "theorem same_cycle.eq_of_left (h : same_cycle f x y) (hx : IsFixedPt f x) : x = y :=\n  let ⟨n, hn⟩ := h\n  (hx.perm_zpow _).eq.symm.trans hn\n#align same_cycle.eq_of_left same_cycle.eq_of_left\n\n",
 "disjoint_mul_inv_of_mem_cycle_factors_finset":
 "theorem disjoint_mul_inv_of_mem_cycle_factors_finset {f g : perm α} (h : f ∈ cycle_factors_finset g) :\n    disjoint (g * f⁻¹) f := by\n  rw [mem_cycle_factors_finset_iff] at h\n  intro x\n  by_cases hx : f x = x\n  · exact or.inr hx\n  · refine' or.inl _\n    rw [mul_apply, ← h.right, apply_inv_self]\n    rwa [← support_inv, apply_mem_support, support_inv, mem_support]\n#align disjoint_mul_inv_of_mem_cycle_factors_finset disjoint_mul_inv_of_mem_cycle_factors_finset\n\n",
 "disjoint_cycle_factors_finset":
 "theorem disjoint.disjoint_cycle_factors_finset {f g : perm α} (h : disjoint f g) :\n    Disjoint (cycle_factors_finset f) (cycle_factors_finset g) :=\n  by\n  rw [disjoint_iff_disjoint_support] at h\n  rw [Finset.disjoint_left]\n  intro x hx hy\n  simp only [mem_cycle_factors_finset_iff, mem_support] at hx hy\n  obtain ⟨⟨⟨a, ha, -⟩, hf⟩, -, hg⟩ := hx, hy\n  refine' h.le_bot (_ : a ∈ f.support ∩ g.support)\n  simp [ha, ← hf a ha, ← hg a ha]\n#align disjoint.disjoint_cycle_factors_finset disjoint.disjoint_cycle_factors_finset\n\n",
 "cycle_of_zpow_apply_self":
 "@[simp]\ntheorem cycle_of_zpow_apply_self (f : perm α) (x : α) : ∀ n : ℤ, (cycle_of f x ^ n) x = (f ^ n) x\n  | (n : ℕ) => cycle_of_pow_apply_self f x n\n  | -[n+1] => by rw [zpow_negSucc, ← inv_pow, cycle_of_inv, zpow_negSucc, ← inv_pow, cycle_of_pow_apply_self]\n#align cycle_of_zpow_apply_self cycle_of_zpow_apply_self\n\n",
 "cycle_of_self_apply_zpow":
 "@[simp]\ntheorem cycle_of_self_apply_zpow (f : perm α) (n : ℤ) (x : α) : cycle_of f ((f ^ n) x) = cycle_of f x :=\n  same_cycle.rfl.zpow_left.cycle_of_eq\n#align cycle_of_self_apply_zpow cycle_of_self_apply_zpow\n\n",
 "cycle_of_self_apply_pow":
 "@[simp]\ntheorem cycle_of_self_apply_pow (f : perm α) (n : ℕ) (x : α) : cycle_of f ((f ^ n) x) = cycle_of f x :=\n  same_cycle.rfl.pow_left.cycle_of_eq\n#align cycle_of_self_apply_pow cycle_of_self_apply_pow\n\n",
 "cycle_of_self_apply":
 "@[simp]\ntheorem cycle_of_self_apply (f : perm α) (x : α) : cycle_of f (f x) = cycle_of f x :=\n  (same_cycle_apply_right.2 same_cycle.rfl).symm.cycle_of_eq\n#align cycle_of_self_apply cycle_of_self_apply\n\n",
 "cycle_of_pow_apply_self":
 "@[simp]\ntheorem cycle_of_pow_apply_self (f : perm α) (x : α) : ∀ n : ℕ, (cycle_of f x ^ n) x = (f ^ n) x\n  | 0 => rfl\n  | n + 1 => by\n    rw [pow_succ, mul_apply, cycle_of_apply, cycle_of_pow_apply_self, if_pos, pow_succ, mul_apply]\n    exact ⟨n, rfl⟩\n#align cycle_of_pow_apply_self cycle_of_pow_apply_self\n\n",
 "cycle_of_one":
 "theorem cycle_of_one (x : α) : cycle_of 1 x = 1 :=\n  (cycle_of_eq_one_iff 1).mpr rfl\n#align cycle_of_one cycle_of_one\n\n",
 "cycle_of_mul_of_apply_right_eq_self":
 "theorem cycle_of_mul_of_apply_right_eq_self (h : Commute f g) (x : α) (hx : g x = x) :\n    (f * g).cycle_of x = f.cycle_of x := by\n  ext y\n  by_cases hxy : (f * g).same_cycle x y\n  · obtain ⟨z, rfl⟩ := hxy\n    rw [cycle_of_apply_apply_zpow_self]\n    simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]\n  · rw [cycle_of_apply_of_not_same_cycle hxy, cycle_of_apply_of_not_same_cycle]\n    contrapose! hxy\n    obtain ⟨z, rfl⟩ := hxy\n    refine' ⟨z, _⟩\n    simp [h.mul_zpow, zpow_apply_eq_self_of_apply_eq_self hx]\n#align cycle_of_mul_of_apply_right_eq_self cycle_of_mul_of_apply_right_eq_self\n\n",
 "cycle_of_mul_distrib":
 "theorem disjoint.cycle_of_mul_distrib (h : f.disjoint g) (x : α) : (f * g).cycle_of x = f.cycle_of x * g.cycle_of x :=\n  by\n  cases' (disjoint_iff_eq_or_eq.mp h) x with hfx hgx\n  · simp [h.commute.eq, cycle_of_mul_of_apply_right_eq_self h.symm.commute, hfx]\n  · simp [cycle_of_mul_of_apply_right_eq_self h.commute, hgx]\n#align disjoint.cycle_of_mul_distrib disjoint.cycle_of_mul_distrib\n\n",
 "cycle_of_mem_cycle_factors_finset_iff":
 "theorem cycle_of_mem_cycle_factors_finset_iff {f : perm α} {x : α} :\n    cycle_of f x ∈ cycle_factors_finset f ↔ x ∈ f.support :=\n  by\n  rw [mem_cycle_factors_finset_iff]\n  constructor\n  · rintro ⟨hc, h⟩\n    contrapose! hc\n    rw [not_mem_support, ← cycle_of_eq_one_iff] at hc\n    simp [hc]\n  · intro hx\n    refine' ⟨is_cycle_cycle_of _ (mem_support.mp hx), _⟩\n    intro y hy\n    rw [mem_support] at hy\n    rw [cycle_of_apply]\n    split_ifs with H\n    · rfl\n    · rw [cycle_of_apply_of_not_same_cycle H] at hy\n      contradiction\n#align cycle_of_mem_cycle_factors_finset_iff cycle_of_mem_cycle_factors_finset_iff\n\n",
 "cycle_of_inv":
 "theorem cycle_of_inv (f : perm α) (x : α) : (cycle_of f x)⁻¹ = cycle_of f⁻¹ x :=\n  equiv.ext fun y => by\n    rw [inv_eq_iff_eq, cycle_of_apply, cycle_of_apply]\n    split_ifs <;> simp_all [same_cycle_inv, same_cycle_inv_apply_right]\n#align cycle_of_inv cycle_of_inv\n\n",
 "cycle_of_eq_one_iff":
 "@[simp]\ntheorem cycle_of_eq_one_iff (f : perm α) : cycle_of f x = 1 ↔ f x = x :=\n  by\n  simp_rw [ext_iff, cycle_of_apply, one_apply]\n  refine' ⟨fun h => (if_pos (same_cycle.refl f x)).symm.trans (h x), fun h y => _⟩\n  by_cases hy : f y = y\n  · rw [hy, if_t_t]\n  · exact if_neg (mt same_cycle.apply_eq_self_iff (by tauto))\n#align cycle_of_eq_one_iff cycle_of_eq_one_iff\n\n",
 "cycle_of_eq":
 "theorem is_cycle.cycle_of_eq (hf : is_cycle f) (hx : f x ≠ x) : cycle_of f x = f :=\n  equiv.ext fun y =>\n    if h : same_cycle f x y then by rw [h.cycle_of_apply]\n    else by rw [cycle_of_apply_of_not_same_cycle h, not_not.1 (mt ((is_cycle_iff_same_cycle hx).1 hf).2 h)]\n#align is_cycle.cycle_of_eq is_cycle.cycle_of_eq\n\n",
 "cycle_of_apply_self":
 "@[simp]\ntheorem cycle_of_apply_self (f : perm α) (x : α) : cycle_of f x x = f x :=\n  same_cycle.rfl.cycle_of_apply\n#align cycle_of_apply_self cycle_of_apply_self\n\n",
 "cycle_of_apply_of_not_same_cycle":
 "theorem cycle_of_apply_of_not_same_cycle : ¬same_cycle f x y → cycle_of f x y = y :=\n  ofSubtype_apply_of_not_mem _\n#align cycle_of_apply_of_not_same_cycle cycle_of_apply_of_not_same_cycle\n\n",
 "cycle_of_apply_apply_zpow_self":
 "@[simp]\ntheorem cycle_of_apply_apply_zpow_self (f : perm α) (x : α) (k : ℤ) : cycle_of f x ((f ^ k) x) = (f ^ (k + 1)) x :=\n  by\n  rw [same_cycle.cycle_of_apply]\n  · rw [add_comm, zpow_add, zpow_one, mul_apply]\n  · exact ⟨k, rfl⟩\n#align cycle_of_apply_apply_zpow_self cycle_of_apply_apply_zpow_self\n\n",
 "cycle_of_apply_apply_self":
 "@[simp]\ntheorem cycle_of_apply_apply_self (f : perm α) (x : α) : cycle_of f x (f x) = f (f x) := by\n  convert cycle_of_apply_apply_pow_self f x 1 using 1\n#align cycle_of_apply_apply_self cycle_of_apply_apply_self\n\n",
 "cycle_of_apply_apply_pow_self":
 "@[simp]\ntheorem cycle_of_apply_apply_pow_self (f : perm α) (x : α) (k : ℕ) : cycle_of f x ((f ^ k) x) = (f ^ (k + 1)) x := by\n  convert cycle_of_apply_apply_zpow_self f x k using 1\n#align cycle_of_apply_apply_pow_self cycle_of_apply_apply_pow_self\n\n",
 "cycle_of_apply":
 "theorem same_cycle.cycle_of_apply : same_cycle f x y → cycle_of f x y = f y :=\n  ofSubtype_apply_of_mem _\n#align same_cycle.cycle_of_apply same_cycle.cycle_of_apply\n\n",
 "cycle_of":
 "protected theorem is_cycle.cycle_of (hf : is_cycle f) : cycle_of f x = if f x = x then 1 else f :=\n  by\n  by_cases hx : f x = x\n  · rwa [if_pos hx, cycle_of_eq_one_iff]\n  · rwa [if_neg hx, hf.cycle_of_eq]\n#align is_cycle.cycle_of is_cycle.cycle_of\n\n",
 "cycle_is_cycle_of":
 "/-- If c is a cycle, a ∈ c.support and c is a cycle of f, then `c = f.cycle_of a` -/\ntheorem cycle_is_cycle_of {f c : equiv.perm α} {a : α} (ha : a ∈ c.support) (hc : c ∈ f.cycle_factors_finset) :\n    c = f.cycle_of a :=\n  by\n  suffices f.cycle_of a = c.cycle_of a by\n    rw [this]\n    apply symm\n    exact\n      equiv.perm.is_cycle.cycle_of_eq (equiv.perm.mem_cycle_factors_finset_iff.mp hc).left\n        (equiv.perm.mem_support.mp ha)\n  let hfc := (equiv.perm.disjoint_mul_inv_of_mem_cycle_factors_finset hc).symm\n  let hfc2 := perm.disjoint.commute hfc\n  rw [← equiv.perm.cycle_of_mul_of_apply_right_eq_self hfc2]\n  simp only [hfc2.eq, inv_mul_cancel_right]\n  -- a est dans le support de c, donc pas dans celui de g c⁻¹\n  exact equiv.perm.not_mem_support.mp (finset.disjoint_left.mp (equiv.perm.disjoint.disjoint_support hfc) ha)\n#align cycle_is_cycle_of cycle_is_cycle_of\n\n",
 "cycle_induction_on":
 "@[elab_as_elim]\ntheorem cycle_induction_on [Finite β] (P : perm β → Prop) (σ : perm β) (base_one : P 1)\n    (base_cycles : ∀ σ : perm β, σ.is_cycle → P σ)\n    (induction_disjoint : ∀ σ τ : perm β, disjoint σ τ → is_cycle σ → P σ → P τ → P (σ * τ)) : P σ :=\n  by\n  cases nonempty_fintype β\n  suffices ∀ l : list (perm β), (∀ τ : perm β, τ ∈ l → τ.is_cycle) → l.pairwise Disjoint → P l.prod by\n    classical\n      let x := σ.trunc_cycle_factors.out\n      exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2)\n  intro l\n  induction' l with σ l ih\n  · exact fun _ _ => base_one\n  · intro h1 h2\n    rw [List.prod_cons]\n    exact\n      induction_disjoint σ l.prod (disjoint_prod_right _ (list.pairwise_cons.mp h2).1) (h1 _ (list.mem_cons_self _ _))\n        (base_cycles σ (h1 σ (l.mem_cons_self σ))) (ih (fun τ hτ => h1 τ (list.mem_cons_of_mem σ hτ)) h2.of_cons)\n#align cycle_induction_on cycle_induction_on\n\n",
 "cycle_factors_finset_pairwise_disjoint":
 "theorem cycle_factors_finset_pairwise_disjoint : (cycle_factors_finset f : set (perm α)).pairwise disjoint :=\n  (cycle_factors_finset_eq_finset.mp rfl).2.some\n#align cycle_factors_finset_pairwise_disjoint cycle_factors_finset_pairwise_disjoint\n\n",
 "cycle_factors_finset_one":
 "@[simp]\ntheorem cycle_factors_finset_one : cycle_factors_finset (1 : perm α) = ∅ := by simp [cycle_factors_finset_eq_empty_iff]\n#align cycle_factors_finset_one cycle_factors_finset_one\n\n",
 "cycle_factors_finset_noncomm_prod":
 "/-- The product of cycle factors is equal to the original `f : perm α`. -/\ntheorem cycle_factors_finset_noncomm_prod\n    (comm : (cycle_factors_finset f : set (perm α)).pairwise Commute := cycle_factors_finset_mem_commute f) :\n    f.cycle_factors_finset.noncomm_prod id comm = f :=\n  (cycle_factors_finset_eq_finset.mp rfl).2.some_spec\n#align cycle_factors_finset_noncomm_prod cycle_factors_finset_noncomm_prod\n\n",
 "cycle_factors_finset_mul_inv_mem_eq_sdiff":
 "theorem cycle_factors_finset_mul_inv_mem_eq_sdiff [fintype α] {f g : perm α} (h : f ∈ cycle_factors_finset g) :\n    cycle_factors_finset (g * f⁻¹) = cycle_factors_finset g \\ {f} :=\n  by\n  revert f\n  apply cycle_induction_on _ g\n  · simp\n  · intro σ hσ f hf\n    simp only [cycle_factors_finset_eq_singleton_self_iff.mpr hσ, mem_singleton] at hf⊢\n    simp [hf]\n  · intro σ τ hd hc hσ hτ f\n    simp_rw [hd.cycle_factors_finset_mul_eq_union, mem_union]\n    -- if only `wlog` could work here...\n    rintro (hf | hf)\n    · rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc,\n        disjoint.cycle_factors_finset_mul_eq_union, hσ hf]\n      · rw [mem_cycle_factors_finset_iff] at hf\n        intro x\n        cases' hd.symm x with hx hx\n        · exact or.inl hx\n        · refine' or.inr _\n          by_cases hfx : f x = x\n          · rw [← hfx]\n            simpa [hx] using hfx.symm\n          · rw [mul_apply]\n            rw [← hf.right _ (mem_support.mpr hfx)] at hx\n            contradiction\n      · exact fun H => hd.disjoint_cycle_factors_finset.le_bot (mem_inter_of_mem hf H)\n    · rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc,\n        disjoint.cycle_factors_finset_mul_eq_union, hτ hf]\n      · rw [mem_cycle_factors_finset_iff] at hf\n        intro x\n        cases' hd x with hx hx\n        · exact or.inl hx\n        · refine' or.inr _\n          by_cases hfx : f x = x\n          · rw [← hfx]\n            simpa [hx] using hfx.symm\n          · rw [mul_apply]\n            rw [← hf.right _ (mem_support.mpr hfx)] at hx\n            contradiction\n      · exact fun H => hd.disjoint_cycle_factors_finset.le_bot (mem_inter_of_mem H hf)\n#align cycle_factors_finset_mul_inv_mem_eq_sdiff cycle_factors_finset_mul_inv_mem_eq_sdiff\n\n",
 "cycle_factors_finset_mul_eq_union":
 "theorem disjoint.cycle_factors_finset_mul_eq_union {f g : perm α} (h : disjoint f g) :\n    cycle_factors_finset (f * g) = cycle_factors_finset f ∪ cycle_factors_finset g :=\n  by\n  rw [cycle_factors_finset_eq_finset]\n  refine' ⟨_, _, _⟩\n  · simp [or_imp, mem_cycle_factors_finset_iff, forall_swap]\n  · rw [coe_union, Set.pairwise_union_of_symmetric disjoint.symmetric]\n    exact\n      ⟨cycle_factors_finset_pairwise_disjoint _, cycle_factors_finset_pairwise_disjoint _, fun x hx y hy hxy =>\n        h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)⟩\n  · rw [noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset]\n    rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod]\n#align disjoint.cycle_factors_finset_mul_eq_union disjoint.cycle_factors_finset_mul_eq_union\n\n",
 "cycle_factors_finset_mem_commute":
 "theorem cycle_factors_finset_mem_commute : (cycle_factors_finset f : set (perm α)).pairwise Commute :=\n  (cycle_factors_finset_pairwise_disjoint _).mono' fun _ _ => disjoint.commute\n#align cycle_factors_finset_mem_commute cycle_factors_finset_mem_commute\n\n",
 "cycle_factors_finset_injective":
 "/-- Two permutations `f g : perm α` have the same cycle factors iff they are the same. -/\ntheorem cycle_factors_finset_injective : function.injective (@cycle_factors_finset α _ _) :=\n  by\n  intro f g h\n  rw [← cycle_factors_finset_noncomm_prod f]\n  simpa [h] using cycle_factors_finset_noncomm_prod g\n#align cycle_factors_finset_injective cycle_factors_finset_injective\n\n",
 "cycle_factors_finset_eq_singleton_self_iff":
 "@[simp]\ntheorem cycle_factors_finset_eq_singleton_self_iff {f : perm α} : f.cycle_factors_finset = {f} ↔ f.is_cycle := by\n  simp [cycle_factors_finset_eq_finset]\n#align cycle_factors_finset_eq_singleton_self_iff cycle_factors_finset_eq_singleton_self_iff\n\n",
 "cycle_factors_finset_eq_singleton_iff":
 "theorem cycle_factors_finset_eq_singleton_iff {f g : perm α} : f.cycle_factors_finset = {g} ↔ f.is_cycle ∧ f = g :=\n  by\n  suffices f = g → (g.is_cycle ↔ f.is_cycle) by simpa [cycle_factors_finset_eq_finset, eq_comm]\n  rintro rfl\n  exact iff.rfl\n#align cycle_factors_finset_eq_singleton_iff cycle_factors_finset_eq_singleton_iff\n\n",
 "cycle_factors_finset_eq_singleton":
 "theorem is_cycle.cycle_factors_finset_eq_singleton {f : perm α} (hf : is_cycle f) : f.cycle_factors_finset = {f} :=\n  cycle_factors_finset_eq_singleton_self_iff.mpr hf\n#align is_cycle.cycle_factors_finset_eq_singleton is_cycle.cycle_factors_finset_eq_singleton\n\n",
 "cycle_factors_finset_eq_list_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem cycle_factors_finset_eq_list_to_finset {σ : perm α} {l : list (perm α)} (hn : l.nodup) :\n    σ.cycle_factors_finset = l.to_finset ↔ (∀ f : perm α, f ∈ l → f.is_cycle) ∧ l.pairwise disjoint ∧ l.prod = σ :=\n  by\n  obtain ⟨⟨l', hp', hc', hd'⟩, hl⟩ := trunc.exists_rep σ.trunc_cycle_factors\n  have ht : cycle_factors_finset σ = l'.to_finset := by rw [cycle_factors_finset, ← hl, trunc.lift_mk]\n  rw [ht]\n  constructor\n  · intro h\n    have hn' : l'.nodup := nodup_of_pairwise_disjoint_cycles hc' hd'\n    have hperm : list.perm l l' := List.perm_of_nodup_nodup_toFinset_eq hn hn' h.symm\n    refine' ⟨_, _, _⟩\n    · exact fun _ h => hc' _ (hperm.subset h)\n    · rwa [List.Perm.pairwise_iff disjoint.symmetric hperm]\n    · rw [← hp', hperm.symm.prod_eq']\n      refine' hd'.imp _\n      exact fun _ _ => disjoint.commute\n  · rintro ⟨hc, hd, hp⟩\n    refine' List.toFinset_eq_of_perm _ _ _\n    refine' list_cycles_perm_list_cycles _ hc' hc hd' hd\n    rw [hp, hp']\n#align cycle_factors_finset_eq_list_to_finset cycle_factors_finset_eq_list_to_finset\n\n",
 "cycle_factors_finset_eq_finset":
 "theorem cycle_factors_finset_eq_finset {σ : perm α} {s : Finset (perm α)} :\n    σ.cycle_factors_finset = s ↔\n      (∀ f : perm α, f ∈ s → f.is_cycle) ∧\n        ∃ h : (s : set (perm α)).pairwise disjoint, s.noncomm_prod id (h.mono' fun _ _ => disjoint.commute) = σ :=\n  by\n  obtain ⟨l, hl, rfl⟩ := s.exists_list_nodup_eq\n  simp [cycle_factors_finset_eq_list_to_finset, hl]\n#align cycle_factors_finset_eq_finset cycle_factors_finset_eq_finset\n\n",
 "cycle_factors_finset_eq_empty_iff":
 "theorem cycle_factors_finset_eq_empty_iff {f : perm α} : cycle_factors_finset f = ∅ ↔ f = 1 := by\n  simpa [cycle_factors_finset_eq_finset] using eq_comm\n#align cycle_factors_finset_eq_empty_iff cycle_factors_finset_eq_empty_iff\n\n",
 "countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\nprotected theorem is_cycle_on.countable (hs : f.is_cycle_on s) : s.countable :=\n  by\n  obtain rfl | ⟨a, ha⟩ := s.eq_empty_or_nonempty\n  · exact set.countable_empty\n  · exact (set.countable_range fun n : ℤ => («expr⇑ » (f ^ n) : α → α) a).mono (hs.2 ha)\n#align is_cycle_on.countable is_cycle_on.countable\n\n",
 "conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem is_cycle_on.conj (h : f.is_cycle_on s) : (g * f * g⁻¹).is_cycle_on («expr '' » (g : perm α) s) :=\n  ⟨(g.bij_on_image.comp h.1).comp g.bij_on_symm_image, fun x hx y hy =>\n    by\n    rw [← preimage_inv] at hx hy\n    convert (h.2 hx hy).conj <;> rw [apply_inv_self]⟩\n#align is_cycle_on.conj is_cycle_on.conj\n\n",
 "closure_prime_cycle_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem closure_prime_cycle_swap {σ τ : perm α} (h0 : (fintype.card α).prime) (h1 : is_cycle σ)\n    (h2 : σ.support = finset.univ) (h3 : is_swap τ) : closure ({σ, τ} : set (perm α)) = «expr⊤» :=\n  by\n  obtain ⟨x, y, h4, h5⟩ := h3\n  obtain ⟨i, hi⟩ :=\n    h1.exists_pow_eq (mem_support.mp ((finset.ext_iff.mp h2 x).mpr (finset.mem_univ x)))\n      (mem_support.mp ((finset.ext_iff.mp h2 y).mpr (finset.mem_univ y)))\n  rw [h5, ← hi]\n  refine' closure_cycle_coprime_swap (nat.coprime.symm (h0.coprime_iff_not_dvd.mpr fun h => h4 _)) h1 h2 x\n  cases' h with m hm\n  rwa [hm, pow_mul, ← finset.card_univ, ← h2, ← h1.order_of, pow_order_of_eq_one, one_pow, one_apply] at hi\n#align closure_prime_cycle_swap closure_prime_cycle_swap\n\n",
 "closure_is_cycle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem closure_is_cycle : closure { σ : perm β | is_cycle σ } = «expr⊤» := by\n  classical\n    cases nonempty_fintype β\n    exact top_le_iff.mp (le_trans (ge_of_eq closure_is_swap) (closure_mono fun _ => is_swap.is_cycle))\n#align closure_is_cycle closure_is_cycle\n\n",
 "closure_cycle_coprime_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem closure_cycle_coprime_swap {n : ℕ} {σ : perm α} (h0 : nat.coprime n (fintype.card α)) (h1 : is_cycle σ)\n    (h2 : σ.support = finset.univ) (x : α) : closure ({σ, swap x ((σ ^ n) x)} : set (perm α)) = «expr⊤» :=\n  by\n  rw [← finset.card_univ, ← h2, ← h1.order_of] at h0\n  cases' exists_pow_eq_self_of_coprime h0 with m hm\n  have h2' : (σ ^ n).support = «expr⊤» := eq.trans (support_pow_coprime h0) h2\n  have h1' : is_cycle ((σ ^ n) ^ (m : ℤ)) := by rwa [← hm] at h1\n  replace h1' : is_cycle (σ ^ n) := h1'.of_pow (le_trans (support_pow_le σ n) (ge_of_eq (congr_arg support hm)))\n  rw [eq_top_iff, ← closure_cycle_adjacent_swap h1' h2' x, closure_le, Set.insert_subset]\n  exact\n    ⟨subgroup.pow_mem (closure _) (subset_closure (Set.mem_insert σ _)) n,\n      set.singleton_subset_iff.mpr (subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _)))⟩\n#align closure_cycle_coprime_swap closure_cycle_coprime_swap\n\n",
 "closure_cycle_adjacent_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem closure_cycle_adjacent_swap {σ : perm α} (h1 : is_cycle σ) (h2 : σ.support = «expr⊤») (x : α) :\n    closure ({σ, swap x (σ x)} : set (perm α)) = «expr⊤» :=\n  by\n  let H := closure ({σ, swap x (σ x)} : set (perm α))\n  have h3 : σ ∈ H := subset_closure (Set.mem_insert σ _)\n  have h4 : swap x (σ x) ∈ H := subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n  have step1 : ∀ n : ℕ, swap ((σ ^ n) x) ((σ ^ (n + 1)) x) ∈ H :=\n    by\n    intro n\n    induction' n with n ih\n    · exact subset_closure (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n    · convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3)\n      simp_rw [mul_swap_eq_swap_mul, mul_inv_cancel_right, pow_succ]\n      rfl\n  have step2 : ∀ n : ℕ, swap x ((σ ^ n) x) ∈ H := by\n    intro n\n    induction' n with n ih\n    · convert H.one_mem\n      exact swap_self x\n    · by_cases h5 : x = (σ ^ n) x\n      · rw [pow_succ, mul_apply, ← h5]\n        exact h4\n      by_cases h6 : x = (σ ^ (n + 1)) x\n      · rw [← h6, swap_self]\n        exact H.one_mem\n      rw [swap_comm, ← swap_mul_swap_mul_swap h5 h6]\n      exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n)\n  have step3 : ∀ y : α, swap x y ∈ H := by\n    intro y\n    have hx : x ∈ («expr⊤» : Finset α) := finset.mem_univ x\n    rw [← h2, mem_support] at hx\n    have hy : y ∈ («expr⊤» : Finset α) := finset.mem_univ y\n    rw [← h2, mem_support] at hy\n    cases' is_cycle.exists_pow_eq h1 hx hy with n hn\n    rw [← hn]\n    exact step2 n\n  have step4 : ∀ y z : α, swap y z ∈ H := by\n    intro y z\n    by_cases h5 : z = x\n    · rw [h5, swap_comm]\n      exact step3 y\n    by_cases h6 : z = y\n    · rw [h6, swap_self]\n      exact H.one_mem\n    rw [← swap_mul_swap_mul_swap h5 h6, swap_comm z x]\n    exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y)\n  rw [eq_top_iff, ← closure_is_swap, closure_le]\n  rintro τ ⟨y, z, h5, h6⟩\n  rw [h6]\n  exact step4 y z\n#align closure_cycle_adjacent_swap closure_cycle_adjacent_swap\n\n",
 "card_support_cycle_of_pos_iff":
 "@[simp]\ntheorem card_support_cycle_of_pos_iff : 0 < card (cycle_of f x).support ↔ f x ≠ x :=\n  by\n  rw [← two_le_card_support_cycle_of_iff, ← Nat.succ_le_iff]\n  exact ⟨fun h => or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_le⟩\n#align card_support_cycle_of_pos_iff card_support_cycle_of_pos_iff\n\n",
 "card_support_conj":
 "theorem card_support_conj : (σ * τ * σ⁻¹).support.card = τ.support.card := by simp\n#align card_support_conj card_support_conj\n\n",
 "apply_ne":
 "protected theorem is_cycle_on.apply_ne (hf : f.is_cycle_on s) (hs : s.nontrivial) (ha : a ∈ s) : f a ≠ a :=\n  by\n  obtain ⟨b, hb, hba⟩ := hs.exists_ne a\n  obtain ⟨n, rfl⟩ := hf.2 ha hb\n  exact fun h => hba (is_fixed_pt.perm_zpow h n)\n#align is_cycle_on.apply_ne is_cycle_on.apply_ne\n\n",
 "apply_mem_iff":
 "theorem is_cycle_on.apply_mem_iff (hf : f.is_cycle_on s) : f x ∈ s ↔ x ∈ s :=\n  ⟨fun hx => by\n    convert hf.1.perm_inv.1 hx\n    rw [inv_apply_self], fun hx => hf.1.maps_to hx⟩\n#align is_cycle_on.apply_mem_iff is_cycle_on.apply_mem_iff\n\n",
 "apply_eq_self_iff":
 "theorem same_cycle.apply_eq_self_iff : same_cycle f x y → (f x = x ↔ f y = y) := fun ⟨i, hi⟩ => by\n  rw [← hi, ← mul_apply, ← zpow_one_add, add_comm, zpow_add_one, mul_apply, (f ^ i).injective.eq_iff]\n#align same_cycle.apply_eq_self_iff same_cycle.apply_eq_self_iff\n\n",
 "add_right_one_is_cycle":
 "theorem add_right_one_is_cycle : (Equiv.addRight 1 : perm ℤ).is_cycle :=\n  ⟨0, one_ne_zero, fun n _ => ⟨n, by simp⟩⟩\n#align add_right_one_is_cycle add_right_one_is_cycle\n\n",
 "add_left_one_is_cycle":
 "theorem add_left_one_is_cycle : (Equiv.addLeft 1 : perm ℤ).is_cycle :=\n  ⟨0, one_ne_zero, fun n _ => ⟨n, by simp⟩⟩\n#align add_left_one_is_cycle add_left_one_is_cycle\n\n"}