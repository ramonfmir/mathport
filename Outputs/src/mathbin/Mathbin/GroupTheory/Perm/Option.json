{"univ_perm_option":
 "/-- The set of all permutations of `option α` can be constructed by augmenting the set of\npermutations of `α` by each element of `option α` in turn. -/\ntheorem finset.univ_perm_option {α : Type _} [decidable_eq α] [fintype α] :\n    @finset.univ (perm <| option α) _ =\n      (finset.univ : Finset <| option α × perm α).map equiv.perm.decompose_option.symm.to_embedding :=\n  (finset.univ_map_equiv_to_embedding _).symm\n#align finset.univ_perm_option finset.univ_perm_option\n\n",
 "option_congr_swap":
 "@[simp]\ntheorem equiv.option_congr_swap {α : Type _} [decidable_eq α] (x y : α) :\n    optionCongr (swap x y) = swap (some x) (some y) :=\n  by\n  ext (_ | i)\n  · simp [swap_apply_of_ne_of_ne]\n  · by_cases hx : i = x\n    simp [hx, swap_apply_of_ne_of_ne]\n    by_cases hy : i = y <;> simp [hx, hy, swap_apply_of_ne_of_ne]\n#align equiv.option_congr_swap equiv.option_congr_swap\n\n",
 "option_congr_sign":
 "@[simp]\ntheorem equiv.option_congr_sign {α : Type _} [decidable_eq α] [fintype α] (e : perm α) :\n    perm.sign e.option_congr = perm.sign e :=\n  by\n  apply perm.swap_induction_on e\n  · simp [perm.one_def]\n  · intro f x y hne h\n    simp [h, hne, perm.mul_def, ← Equiv.optionCongr_trans]\n#align equiv.option_congr_sign equiv.option_congr_sign\n\n",
 "option_congr_one":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp]\ntheorem equiv.option_congr_one {α : Type _} : (1 : perm α).option_congr = 1 :=\n  Equiv.optionCongr_refl\n#align equiv.option_congr_one equiv.option_congr_one\n\n",
 "map_equiv_remove_none":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem map_equiv_remove_none {α : Type _} [decidable_eq α] (σ : perm (option α)) :\n    (removeNone σ).option_congr = swap none (σ none) * σ :=\n  by\n  ext1 x\n  have : option.map («expr⇑ » (remove_none σ)) x = (swap none (σ none)) (σ x) :=\n    by\n    cases x\n    · simp\n    · cases h : σ (some x)\n      · simp [remove_none_none _ h]\n      · have hn : σ (some x) ≠ none := by simp [h]\n        have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp)\n        simp [remove_none_some _ ⟨_, h⟩, ← h, swap_apply_of_ne_of_ne hn hσn]\n  simpa using this\n#align map_equiv_remove_none map_equiv_remove_none\n\n",
 "decompose_option_symm_sign":
 "theorem equiv.perm.decompose_option_symm_sign {α : Type _} [decidable_eq α] [fintype α] (e : perm α) :\n    perm.sign (equiv.perm.decompose_option.symm (none, e)) = perm.sign e := by simp\n#align equiv.perm.decompose_option_symm_sign equiv.perm.decompose_option_symm_sign\n\n",
 "decompose_option_symm_of_none_apply":
 "theorem equiv.perm.decompose_option_symm_of_none_apply {α : Type _} [decidable_eq α] (e : perm α) (i : option α) :\n    equiv.perm.decompose_option.symm (none, e) i = i.map e := by simp\n#align equiv.perm.decompose_option_symm_of_none_apply equiv.perm.decompose_option_symm_of_none_apply\n\n"}