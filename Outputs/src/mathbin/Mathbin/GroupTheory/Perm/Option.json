{"univ_perm_option":
 "#print Finset.univ_perm_option /-\n/-- The set of all permutations of `option α` can be constructed by augmenting the set of\npermutations of `α` by each element of `option α` in turn. -/\ntheorem Finset.univ_perm_option {α : Type _} [DecidableEq α] [Fintype α] :\n    @Finset.univ (Perm <| Option α) _ =\n      (Finset.univ : Finset <| Option α × Perm α).map Equiv.Perm.decomposeOption.symm.to_embedding :=\n  (Finset.univ_map_equiv_to_embedding _).symm\n#align finset.univ_perm_option Finset.univ_perm_option\n-/\n\n",
 "optionCongr_swap":
 "#print Equiv.optionCongr_swap /-\n@[simp]\ntheorem Equiv.optionCongr_swap {α : Type _} [DecidableEq α] (x y : α) :\n    optionCongr (swap x y) = swap (some x) (some y) :=\n  by\n  ext (_ | i)\n  · simp [swap_apply_of_ne_of_ne]\n  · by_cases hx : i = x\n    simp [hx, swap_apply_of_ne_of_ne]\n    by_cases hy : i = y <;> simp [hx, hy, swap_apply_of_ne_of_ne]\n#align equiv.option_congr_swap Equiv.optionCongr_swap\n-/\n\n",
 "optionCongr_sign":
 "#print Equiv.optionCongr_sign /-\n@[simp]\ntheorem Equiv.optionCongr_sign {α : Type _} [DecidableEq α] [Fintype α] (e : Perm α) :\n    Perm.sign e.option_congr = Perm.sign e :=\n  by\n  apply perm.swap_induction_on e\n  · simp [perm.one_def]\n  · intro f x y hne h\n    simp [h, hne, perm.mul_def, ← Equiv.optionCongr_trans]\n#align equiv.option_congr_sign Equiv.optionCongr_sign\n-/\n\n",
 "optionCongr_one":
 "#print Equiv.optionCongr_one /-\n/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp]\ntheorem Equiv.optionCongr_one {α : Type _} : (1 : Perm α).option_congr = 1 :=\n  Equiv.optionCongr_refl\n#align equiv.option_congr_one Equiv.optionCongr_one\n-/\n\n",
 "map_equiv_removeNone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print map_equiv_removeNone /-\n@[simp]\ntheorem map_equiv_removeNone {α : Type _} [DecidableEq α] (σ : Perm (Option α)) :\n    (removeNone σ).option_congr = swap none (σ none) * σ :=\n  by\n  ext1 x\n  have : option.map («expr⇑ » (remove_none σ)) x = (swap none (σ none)) (σ x) :=\n    by\n    cases x\n    · simp\n    · cases h : σ (some x)\n      · simp [remove_none_none _ h]\n      · have hn : σ (some x) ≠ none := by simp [h]\n        have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp)\n        simp [remove_none_some _ ⟨_, h⟩, ← h, swap_apply_of_ne_of_ne hn hσn]\n  simpa using this\n#align map_equiv_remove_none map_equiv_removeNone\n-/\n\n",
 "decomposeOption_symm_sign":
 "#print Equiv.Perm.decomposeOption_symm_sign /-\ntheorem Equiv.Perm.decomposeOption_symm_sign {α : Type _} [DecidableEq α] [Fintype α] (e : Perm α) :\n    Perm.sign (Equiv.Perm.decomposeOption.symm (none, e)) = Perm.sign e := by simp\n#align equiv.perm.decompose_option_symm_sign Equiv.Perm.decomposeOption_symm_sign\n-/\n\n",
 "decomposeOption_symm_of_none_apply":
 "#print Equiv.Perm.decomposeOption_symm_of_none_apply /-\ntheorem Equiv.Perm.decomposeOption_symm_of_none_apply {α : Type _} [DecidableEq α] (e : Perm α) (i : Option α) :\n    Equiv.Perm.decomposeOption.symm (none, e) i = i.map e := by simp\n#align equiv.perm.decompose_option_symm_of_none_apply Equiv.Perm.decomposeOption_symm_of_none_apply\n-/\n\n"}