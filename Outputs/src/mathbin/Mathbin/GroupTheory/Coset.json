{"right_rel_r_eq_right_coset_equivalence":
 "theorem right_rel_r_eq_right_coset_equivalence : @Setoid.r _ (quotient_group.right_rel s) = right_coset_equivalence s :=\n  by\n  ext\n  rw [right_rel_eq]\n  exact (right_coset_eq_iff s).symm\n#align right_rel_r_eq_right_coset_equivalence right_rel_r_eq_right_coset_equivalence\n\n",
 "right_rel_eq":
 "@[to_additive]\ntheorem right_rel_eq : @Setoid.r _ (right_rel s) = fun x y => y * x⁻¹ ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply right_rel_apply\n#align right_rel_eq right_rel_eq\n\n",
 "right_rel_apply":
 "@[to_additive]\ntheorem right_rel_apply {x y : α} : @Setoid.r _ (right_rel s) x y ↔ y * x⁻¹ ∈ s :=\n  calc\n    (∃ a : s, (a : α) * y = x) ↔ ∃ a : s, y * x⁻¹ = a⁻¹ := by simp only [mul_inv_eq_iff_eq_mul, eq_inv_mul_iff_mul_eq]\n    _ ↔ y * x⁻¹ ∈ s := by simp [SetLike.exists]\n    \n#align right_rel_apply right_rel_apply\n\n",
 "right_coset_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[simp, to_additive right_add_coset_zero]\ntheorem right_coset_one : right_coset s 1 = s :=\n  Set.ext <| by simp [right_coset]\n#align right_coset_one right_coset_one\n\n",
 "right_coset_mem_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive right_add_coset_mem_right_add_coset]\ntheorem right_coset_mem_right_coset {a : α} (ha : a ∈ s) : right_coset (s : set α) a = s :=\n  Set.ext fun b => by simp [mem_right_coset_iff, mul_mem_cancel_right (s.inv_mem ha)]\n#align right_coset_mem_right_coset right_coset_mem_right_coset\n\n",
 "right_coset_equivalence_rel":
 "@[to_additive right_add_coset_equivalence_rel]\ntheorem right_coset_equivalence_rel (s : set α) : equivalence (right_coset_equivalence s) :=\n  Equivalence.mk (right_coset_equivalence s) (fun a => rfl) (fun a b => eq.symm) fun a b c => eq.trans\n#align right_coset_equivalence_rel right_coset_equivalence_rel\n\n",
 "right_coset_eq_iff":
 "@[to_additive right_add_coset_eq_iff]\ntheorem right_coset_eq_iff {x y : α} : right_coset (↑s) x = right_coset s y ↔ y * x⁻¹ ∈ s :=\n  by\n  rw [Set.ext_iff]\n  simp_rw [mem_right_coset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [mul_right_inv]\n    exact s.one_mem\n  · intro h z\n    rw [← inv_mul_cancel_left y x⁻¹]\n    rw [← mul_assoc]\n    exact s.mul_mem_cancel_right h\n#align right_coset_eq_iff right_coset_eq_iff\n\n",
 "right_coset_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[simp, to_additive right_add_coset_assoc]\ntheorem right_coset_assoc (s : set α) (a b : α) : right_coset (right_coset s a) b = right_coset s (a * b) := by\n  simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]\n#align right_coset_assoc right_coset_assoc\n\n",
 "quotient_subgroup_of_map_of_le_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_subgroup_of_map_of_le_apply_mk (H : subgroup α) (h : s ≤ t) (g : H) :\n    quotient_subgroup_of_map_of_le H h (quotient_group.mk g) = quotient_group.mk g :=\n  rfl\n#align quotient_subgroup_of_map_of_le_apply_mk quotient_subgroup_of_map_of_le_apply_mk\n\n",
 "quotient_subgroup_of_embedding_of_le_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_subgroup_of_embedding_of_le_apply_mk (H : subgroup α) (h : s ≤ t) (g : s) :\n    quotient_subgroup_of_embedding_of_le H h (quotient_group.mk g) = quotient_group.mk (inclusion h g) :=\n  rfl\n#align quotient_subgroup_of_embedding_of_le_apply_mk quotient_subgroup_of_embedding_of_le_apply_mk\n\n",
 "quotient_map_of_le_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_map_of_le_apply_mk (h : s ≤ t) (g : α) :\n    quotient_map_of_le h (quotient_group.mk g) = quotient_group.mk g :=\n  rfl\n#align quotient_map_of_le_apply_mk quotient_map_of_le_apply_mk\n\n",
 "quotient_lift_on_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp, to_additive]\ntheorem quotient_lift_on_coe {β} (f : α → β) (h) (x : α) : quotient.lift_on' (x : «expr ⧸ » α s) f h = f x :=\n  rfl\n#align quotient_lift_on_coe quotient_lift_on_coe\n\n",
 "quotient_infi_subgroup_of_embedding_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_infi_subgroup_of_embedding_apply_mk {ι : Type _} (f : ι → subgroup α) (H : subgroup α) (g : H)\n    (i : ι) : quotient_infi_subgroup_of_embedding f H (quotient_group.mk g) i = quotient_group.mk g :=\n  rfl\n#align quotient_infi_subgroup_of_embedding_apply_mk quotient_infi_subgroup_of_embedding_apply_mk\n\n",
 "quotient_infi_embedding_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_infi_embedding_apply_mk {ι : Type _} (f : ι → subgroup α) (g : α) (i : ι) :\n    quotient_infi_embedding f (quotient_group.mk g) i = quotient_group.mk g :=\n  rfl\n#align quotient_infi_embedding_apply_mk quotient_infi_embedding_apply_mk\n\n",
 "quotient_equiv_of_eq_mk":
 "theorem quotient_equiv_of_eq_mk (h : s = t) (a : α) :\n    quotient_equiv_of_eq h (quotient_group.mk a) = quotient_group.mk a :=\n  rfl\n#align quotient_equiv_of_eq_mk quotient_equiv_of_eq_mk\n\n",
 "preimage_image_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem preimage_image_coe (N : subgroup α) (s : set α) :\n    «expr ⁻¹' » coe («expr '' » (coe : α → «expr ⧸ » α N) s) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr ⁻¹' » (fun y : α => y * x) s) :=\n  by\n  ext x\n  simp only [quotient_group.eq, SetLike.exists, exists_prop, Set.mem_preimage, Set.mem_unionᵢ, Set.mem_image,\n    [anonymous], ← eq_inv_mul_iff_mul_eq]\n  exact ⟨fun ⟨y, hs, hN⟩ => ⟨_, N.inv_mem hN, by simpa using hs⟩, fun ⟨z, hz, hxz⟩ => ⟨x * z, hxz, by simpa using hz⟩⟩\n#align preimage_image_coe preimage_image_coe\n\n",
 "out_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp, to_additive quotient_add_group.out_eq']\ntheorem out_eq' (a : «expr ⧸ » α s) : mk a.out' = a :=\n  quotient.out_eq' a\n#align out_eq' out_eq'\n\n",
 "orbit_subgroup_one_eq_self":
 "@[to_additive]\ntheorem orbit_subgroup_one_eq_self : mul_action.orbit s (1 : α) = s :=\n  orbit_subgroup_eq_self_of_mem s s.one_mem\n#align orbit_subgroup_one_eq_self orbit_subgroup_one_eq_self\n\n",
 "orbit_subgroup_eq_self_of_mem":
 "@[to_additive]\ntheorem orbit_subgroup_eq_self_of_mem {a : α} (ha : a ∈ s) : mul_action.orbit s a = s :=\n  (orbit_subgroup_eq_right_coset s a).trans (right_coset_mem_right_coset s ha)\n#align orbit_subgroup_eq_self_of_mem orbit_subgroup_eq_self_of_mem\n\n",
 "orbit_subgroup_eq_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive]\ntheorem orbit_subgroup_eq_right_coset (a : α) : mul_action.orbit s a = right_coset s a :=\n  Set.ext fun b => ⟨fun ⟨c, d⟩ => ⟨c, c.2, d⟩, fun ⟨c, d, e⟩ => ⟨⟨c, d⟩, e⟩⟩\n#align orbit_subgroup_eq_right_coset orbit_subgroup_eq_right_coset\n\n",
 "one_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n@[simp, to_additive zero_left_add_coset]\ntheorem one_left_coset : left_coset 1 s = s :=\n  Set.ext <| by simp [left_coset]\n#align one_left_coset one_left_coset\n\n",
 "normal_of_eq_cosets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive normal_of_eq_add_cosets]\ntheorem normal_of_eq_cosets (h : ∀ g : α, left_coset g s = right_coset s g) : s.normal :=\n  ⟨fun a ha g => show g * a * g⁻¹ ∈ (s : set α) by rw [← mem_right_coset_iff, ← h] <;> exact mem_left_coset g ha⟩\n#align normal_of_eq_cosets normal_of_eq_cosets\n\n",
 "normal_iff_eq_cosets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive normal_iff_eq_add_cosets]\ntheorem normal_iff_eq_cosets : s.normal ↔ ∀ g : α, left_coset g s = right_coset s g :=\n  ⟨@eq_cosets_of_normal _ _ s, normal_of_eq_cosets s⟩\n#align normal_iff_eq_cosets normal_iff_eq_cosets\n\n",
 "mk_surjective":
 "@[to_additive]\ntheorem mk_surjective : function.surjective <| @mk _ _ s :=\n  Quotient.surjective_Quotient_mk''\n#align mk_surjective mk_surjective\n\n",
 "mk_out'_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- It can be useful to write `obtain ⟨h, H⟩ := mk_out'_eq_mul ...`, and then `rw [H]` or\n  `simp_rw [H]` or `simp only [H]`. In order for `simp_rw` and `simp only` to work, this lemma is\n  stated in terms of an arbitrary `h : s`, rathern that the specific `h = g⁻¹ * (mk g).out'`. -/\n@[to_additive quotient_add_group.mk_out'_eq_mul]\ntheorem mk_out'_eq_mul (g : α) : ∃ h : s, (mk g : «expr ⧸ » α s).out' = g * h :=\n  ⟨⟨g⁻¹ * (mk g).out', eq'.mp (mk g).out_eq'.symm⟩, by rw [[anonymous], mul_inv_cancel_left]⟩\n#align mk_out'_eq_mul mk_out'_eq_mul\n\n",
 "mk_mul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp, to_additive quotient_add_group.mk_add_of_mem]\ntheorem mk_mul_of_mem (a : α) (hb : b ∈ s) : (mk (a * b) : «expr ⧸ » α s) = mk a := by\n  rwa [eq', mul_inv_rev, inv_mul_cancel_right, s.inv_mem_iff]\n#align mk_mul_of_mem mk_mul_of_mem\n\n",
 "mem_right_coset_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive mem_right_add_coset_right_add_coset]\ntheorem mem_right_coset_right_coset {a : α} (ha : right_coset (s : set α) a = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha] <;> exact mem_own_right_coset s a\n#align mem_right_coset_right_coset mem_right_coset_right_coset\n\n",
 "mem_right_coset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive mem_right_add_coset_iff]\ntheorem mem_right_coset_iff (a : α) : x ∈ right_coset s a ↔ x * a⁻¹ ∈ s :=\n  iff.intro (fun ⟨b, hb, eq⟩ => by simp [eq.symm, hb]) fun h => ⟨x * a⁻¹, h, by simp⟩\n#align mem_right_coset_iff mem_right_coset_iff\n\n",
 "mem_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive mem_right_add_coset]\ntheorem mem_right_coset {s : set α} {x : α} (a : α) (hxS : x ∈ s) : x * a ∈ right_coset s a :=\n  mem_image_of_mem (fun b : α => b * a) hxS\n#align mem_right_coset mem_right_coset\n\n",
 "mem_own_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive mem_own_right_add_coset]\ntheorem mem_own_right_coset (a : α) : a ∈ right_coset (s : set α) a :=\n  suffices 1 * a ∈ right_coset (s : set α) a by simpa\n  mem_right_coset a (one_mem s : 1 ∈ s)\n#align mem_own_right_coset mem_own_right_coset\n\n",
 "mem_own_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n@[to_additive mem_own_left_add_coset]\ntheorem mem_own_left_coset (a : α) : a ∈ left_coset a s :=\n  suffices a * 1 ∈ left_coset a s by simpa\n  mem_left_coset a (one_mem s : 1 ∈ s)\n#align mem_own_left_coset mem_own_left_coset\n\n",
 "mem_left_coset_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n@[to_additive mem_left_add_coset_left_add_coset]\ntheorem mem_left_coset_left_coset {a : α} (ha : left_coset a s = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha] <;> exact mem_own_left_coset s a\n#align mem_left_coset_left_coset mem_left_coset_left_coset\n\n",
 "mem_left_coset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n@[to_additive mem_left_add_coset_iff]\ntheorem mem_left_coset_iff (a : α) : x ∈ left_coset a s ↔ a⁻¹ * x ∈ s :=\n  iff.intro (fun ⟨b, hb, eq⟩ => by simp [eq.symm, hb]) fun h => ⟨a⁻¹ * x, h, by simp⟩\n#align mem_left_coset_iff mem_left_coset_iff\n\n",
 "mem_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/-\nCopyright (c) 2018 Mitchell Rowett. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mitchell Rowett, Scott Morrison\n-/\n@[to_additive mem_left_add_coset]\ntheorem mem_left_coset {s : set α} {x : α} (a : α) (hxS : x ∈ s) : a * x ∈ left_coset a s :=\n  mem_image_of_mem (fun b : α => a * b) hxS\n#align mem_left_coset mem_left_coset\n\n",
 "left_rel_r_eq_left_coset_equivalence":
 "theorem left_rel_r_eq_left_coset_equivalence : @Setoid.r _ (quotient_group.left_rel s) = left_coset_equivalence s :=\n  by\n  ext\n  rw [left_rel_eq]\n  exact (left_coset_eq_iff s).symm\n#align left_rel_r_eq_left_coset_equivalence left_rel_r_eq_left_coset_equivalence\n\n",
 "left_rel_eq":
 "@[to_additive]\ntheorem left_rel_eq : @Setoid.r _ (left_rel s) = fun x y => x⁻¹ * y ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply left_rel_apply\n#align left_rel_eq left_rel_eq\n\n",
 "left_rel_apply":
 "@[to_additive]\ntheorem left_rel_apply {x y : α} : @Setoid.r _ (left_rel s) x y ↔ x⁻¹ * y ∈ s :=\n  calc\n    (∃ a : s.opposite, y * mul_opposite.unop a = x) ↔ ∃ a : s, y * a = x := s.opposite_equiv.symm.exists_congr_left\n    _ ↔ ∃ a : s, x⁻¹ * y = a⁻¹ := by simp only [inv_mul_eq_iff_eq_mul, eq_mul_inv_iff_mul_eq]\n    _ ↔ x⁻¹ * y ∈ s := by simp [SetLike.exists]\n    \n#align left_rel_apply left_rel_apply\n\n",
 "left_coset_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive left_add_coset_right_add_coset]\ntheorem left_coset_right_coset (s : set α) (a b : α) :\n    right_coset (left_coset a s) b = left_coset a (right_coset s b) := by\n  simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]\n#align left_coset_right_coset left_coset_right_coset\n\n",
 "left_coset_mem_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n@[to_additive left_add_coset_mem_left_add_coset]\ntheorem left_coset_mem_left_coset {a : α} (ha : a ∈ s) : left_coset a s = s :=\n  Set.ext <| by simp [mem_left_coset_iff, mul_mem_cancel_left (s.inv_mem ha)]\n#align left_coset_mem_left_coset left_coset_mem_left_coset\n\n",
 "left_coset_equivalence_rel":
 "@[to_additive left_add_coset_equivalence_rel]\ntheorem left_coset_equivalence_rel (s : set α) : equivalence (left_coset_equivalence s) :=\n  Equivalence.mk (left_coset_equivalence s) (fun a => rfl) (fun a b => eq.symm) fun a b c => eq.trans\n#align left_coset_equivalence_rel left_coset_equivalence_rel\n\n",
 "left_coset_eq_iff":
 "@[to_additive left_add_coset_eq_iff]\ntheorem left_coset_eq_iff {x y : α} : left_coset x s = left_coset y s ↔ x⁻¹ * y ∈ s :=\n  by\n  rw [Set.ext_iff]\n  simp_rw [mem_left_coset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [mul_left_inv]\n    exact s.one_mem\n  · intro h z\n    rw [← mul_inv_cancel_right x⁻¹ y]\n    rw [mul_assoc]\n    exact s.mul_mem_cancel_left h\n#align left_coset_eq_iff left_coset_eq_iff\n\n",
 "left_coset_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n@[simp, to_additive left_add_coset_assoc]\ntheorem left_coset_assoc (s : set α) (a b : α) : left_coset a (left_coset b s) = left_coset (a * b) s := by\n  simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]\n#align left_coset_assoc left_coset_assoc\n\n",
 "induction_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- note [use has_coe_t]\n@[elab_as_elim, to_additive]\ntheorem induction_on' {C : «expr ⧸ » α s → Prop} (x : «expr ⧸ » α s) (H : ∀ z : α, C z) : C x :=\n  Quotient.inductionOn' x H\n#align induction_on' induction_on'\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[elab_as_elim, to_additive]\ntheorem induction_on {C : «expr ⧸ » α s → Prop} (x : «expr ⧸ » α s) (H : ∀ z, C (quotient_group.mk z)) : C x :=\n  Quotient.inductionOn' x H\n#align induction_on induction_on\n\n",
 "forall_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem forall_coe {C : «expr ⧸ » α s → Prop} : (∀ x : «expr ⧸ » α s, C x) ↔ ∀ x : α, C x :=\n  mk_surjective.forall\n#align forall_coe forall_coe\n\n",
 "exists_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem exists_coe {C : «expr ⧸ » α s → Prop} : (∃ x : «expr ⧸ » α s, C x) ↔ ∃ x : α, C x :=\n  mk_surjective.exists\n#align exists_coe exists_coe\n\n",
 "eq_cosets_of_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n@[to_additive eq_add_cosets_of_normal]\ntheorem eq_cosets_of_normal (N : s.normal) (g : α) : left_coset g s = right_coset s g :=\n  Set.ext fun a => by simp [mem_left_coset_iff, mem_right_coset_iff] <;> rw [N.mem_comm_iff]\n#align eq_cosets_of_normal eq_cosets_of_normal\n\n",
 "eq_class_eq_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem eq_class_eq_left_coset (s : subgroup α) (g : α) : { x : α | (x : «expr ⧸ » α s) = g } = left_coset g s :=\n  Set.ext fun z => by rw [mem_left_coset_iff, Set.mem_setOf_eq, eq_comm, quotient_group.eq, SetLike.mem_coe]\n#align eq_class_eq_left_coset eq_class_eq_left_coset\n\n",
 "eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive quotient_add_group.eq']\ntheorem eq' {a b : α} : (mk a : «expr ⧸ » α s) = mk b ↔ a⁻¹ * b ∈ s :=\n  quotient_group.eq\n#align eq' eq'\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive quotient_add_group.eq]\nprotected theorem eq {a b : α} : (a : «expr ⧸ » α s) = b ↔ a⁻¹ * b ∈ s :=\n  calc\n    _ ↔ @Setoid.r _ (left_rel s) a b := quotient.eq'\n    _ ↔ _ := by rw [left_rel_apply]\n    \n#align eq eq\n\n",
 "card_subgroup_dvd_card":
 "/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\n@[to_additive \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\\nambient group.\"]\ntheorem card_subgroup_dvd_card [fintype α] (s : subgroup α) [fintype s] : fintype.card s ∣ fintype.card α := by\n  classical simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_left ℕ]\n#align card_subgroup_dvd_card card_subgroup_dvd_card\n\n",
 "card_quotient_right_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem card_quotient_right_rel [fintype («expr ⧸ » α s)] :\n    fintype.card (quotient (quotient_group.right_rel s)) = fintype.card («expr ⧸ » α s) :=\n  fintype.of_equiv_card (quotient_group.quotient_right_rel_equiv_quotient_left_rel s).symm\n#align card_quotient_right_rel card_quotient_right_rel\n\n",
 "card_quotient_dvd_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem card_quotient_dvd_card [fintype α] (s : subgroup α) [decidable_pred (· ∈ s)] :\n    fintype.card («expr ⧸ » α s) ∣ fintype.card α := by\n  simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_right ℕ]\n#align card_quotient_dvd_card card_quotient_dvd_card\n\n",
 "card_eq_card_quotient_mul_card_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem card_eq_card_quotient_mul_card_subgroup [fintype α] (s : subgroup α) [fintype s]\n    [decidable_pred fun a => a ∈ s] : fintype.card α = fintype.card («expr ⧸ » α s) * fintype.card s := by\n  rw [← fintype.card_prod] <;> exact fintype.card_congr subgroup.group_equiv_quotient_times_subgroup\n#align card_eq_card_quotient_mul_card_subgroup card_eq_card_quotient_mul_card_subgroup\n\n",
 "card_dvd_of_le":
 "@[to_additive]\ntheorem card_dvd_of_le {H K : subgroup α} [fintype H] [fintype K] (hHK : H ≤ K) : card H ∣ card K :=\n  card_dvd_of_injective (inclusion hHK) (inclusion_injective hHK)\n#align card_dvd_of_le card_dvd_of_le\n\n",
 "card_dvd_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem card_dvd_of_injective [fintype α] [fintype H] (f : «expr →* » α H) (hf : function.injective f) :\n    card α ∣ card H := by\n  classical calc\n      card α = card (f.range : subgroup H) := card_congr (Equiv.ofInjective f hf)\n      _ ∣ card H := card_subgroup_dvd_card _\n      \n#align card_dvd_of_injective card_dvd_of_injective\n\n",
 "card_comap_dvd_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem card_comap_dvd_of_injective (K : subgroup H) [fintype K] (f : «expr →* » α H) [fintype (K.comap f)]\n    (hf : function.injective f) : fintype.card (K.comap f) ∣ fintype.card K := by\n  haveI : fintype ((K.comap f).map f) := fintype.of_equiv _ (equiv_map_of_injective _ _ hf).to_equiv <;>\n    calc\n      fintype.card (K.comap f) = fintype.card ((K.comap f).map f) :=\n        fintype.card_congr (equiv_map_of_injective _ _ hf).to_equiv\n      _ ∣ fintype.card K := card_dvd_of_le (map_comap_le _ _)\n      \n#align card_comap_dvd_of_injective card_comap_dvd_of_injective\n\n"}