{"right_rel_r_eq_right_coset_equivalence":
 "theorem right_rel_r_eq_right_coset_equivalence : @Setoid.r _ (QuotientGroup.rightRel s) = RightCosetEquivalence s :=\n  by\n  ext\n  rw [right_rel_eq]\n  exact (rightCoset_eq_iff s).symm\n#align right_rel_r_eq_right_coset_equivalence right_rel_r_eq_right_coset_equivalence\n\n",
 "right_rel_eq":
 "@[to_additive]\ntheorem right_rel_eq : @Setoid.r _ (rightRel s) = fun x y => y * x⁻¹ ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply right_rel_apply\n#align right_rel_eq right_rel_eq\n\n",
 "right_rel_apply":
 "@[to_additive]\ntheorem right_rel_apply {x y : α} : @Setoid.r _ (rightRel s) x y ↔ y * x⁻¹ ∈ s :=\n  calc\n    (∃ a : s, (a : α) * y = x) ↔ ∃ a : s, y * x⁻¹ = a⁻¹ := by simp only [mul_inv_eq_iff_eq_mul, eq_inv_mul_iff_mul_eq]\n    _ ↔ y * x⁻¹ ∈ s := by simp [SetLike.exists]\n    \n#align right_rel_apply right_rel_apply\n\n",
 "rightCoset_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print rightCoset_one /-\n@[simp, to_additive rightAddCoset_zero]\ntheorem rightCoset_one : right_coset s 1 = s :=\n  Set.ext <| by simp [rightCoset]\n#align right_coset_one rightCoset_one\n#align right_add_coset_zero rightAddCoset_zero\n-/\n\n",
 "rightCoset_mem_rightCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print rightCoset_mem_rightCoset /-\n@[to_additive rightAddCoset_mem_rightAddCoset]\ntheorem rightCoset_mem_rightCoset {a : α} (ha : a ∈ s) : right_coset (s : Set α) a = s :=\n  Set.ext fun b => by simp [mem_rightCoset_iff, mul_mem_cancel_right (s.inv_mem ha)]\n#align right_coset_mem_right_coset rightCoset_mem_rightCoset\n#align right_add_coset_mem_right_add_coset rightAddCoset_mem_rightAddCoset\n-/\n\n",
 "rightCoset_eq_iff":
 "#print rightCoset_eq_iff /-\n@[to_additive rightAddCoset_eq_iff]\ntheorem rightCoset_eq_iff {x y : α} : rightCoset (↑s) x = rightCoset s y ↔ y * x⁻¹ ∈ s :=\n  by\n  rw [Set.ext_iff]\n  simp_rw [mem_rightCoset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [mul_right_inv]\n    exact s.one_mem\n  · intro h z\n    rw [← inv_mul_cancel_left y x⁻¹]\n    rw [← mul_assoc]\n    exact s.mul_mem_cancel_right h\n#align right_coset_eq_iff rightCoset_eq_iff\n#align right_add_coset_eq_iff rightAddCoset_eq_iff\n-/\n\n",
 "rightCoset_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print rightCoset_assoc /-\n@[simp, to_additive rightAddCoset_assoc]\ntheorem rightCoset_assoc (s : Set α) (a b : α) : right_coset (right_coset s a) b = right_coset s (a * b) := by\n  simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n#align right_coset_assoc rightCoset_assoc\n#align right_add_coset_assoc rightAddCoset_assoc\n-/\n\n",
 "rightCosetEquivalence_rel":
 "#print rightCosetEquivalence_rel /-\n@[to_additive rightAddCosetEquivalence_rel]\ntheorem rightCosetEquivalence_rel (s : Set α) : equivalence (RightCosetEquivalence s) :=\n  Equivalence.mk (RightCosetEquivalence s) (fun a => rfl) (fun a b => Eq.symm) fun a b c => Eq.trans\n#align right_coset_equivalence_rel rightCosetEquivalence_rel\n#align right_add_coset_equivalence_rel rightAddCosetEquivalence_rel\n-/\n\n",
 "quotient_subgroup_of_map_of_le_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_subgroup_of_map_of_le_apply_mk (H : Subgroup α) (h : s ≤ t) (g : H) :\n    quotientSubgroupOfMapOfLe H h (QuotientGroup.mk g) = QuotientGroup.mk g :=\n  rfl\n#align quotient_subgroup_of_map_of_le_apply_mk quotient_subgroup_of_map_of_le_apply_mk\n\n",
 "quotient_subgroup_of_embedding_of_le_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_subgroup_of_embedding_of_le_apply_mk (H : Subgroup α) (h : s ≤ t) (g : s) :\n    quotientSubgroupOfEmbeddingOfLe H h (QuotientGroup.mk g) = QuotientGroup.mk (inclusion h g) :=\n  rfl\n#align quotient_subgroup_of_embedding_of_le_apply_mk quotient_subgroup_of_embedding_of_le_apply_mk\n\n",
 "quotient_map_of_le_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_map_of_le_apply_mk (h : s ≤ t) (g : α) : quotientMapOfLe h (QuotientGroup.mk g) = QuotientGroup.mk g :=\n  rfl\n#align quotient_map_of_le_apply_mk quotient_map_of_le_apply_mk\n\n",
 "quotient_lift_on_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp, to_additive]\ntheorem quotient_lift_on_coe {β} (f : α → β) (h) (x : α) : Quotient.liftOn' (x : «expr ⧸ » α s) f h = f x :=\n  rfl\n#align quotient_lift_on_coe quotient_lift_on_coe\n\n",
 "quotient_infi_subgroup_of_embedding_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_infi_subgroup_of_embedding_apply_mk {ι : Type _} (f : ι → Subgroup α) (H : Subgroup α) (g : H)\n    (i : ι) : quotientInfᵢSubgroupOfEmbedding f H (QuotientGroup.mk g) i = QuotientGroup.mk g :=\n  rfl\n#align quotient_infi_subgroup_of_embedding_apply_mk quotient_infi_subgroup_of_embedding_apply_mk\n\n",
 "quotient_infi_embedding_apply_mk":
 "@[simp, to_additive]\ntheorem quotient_infi_embedding_apply_mk {ι : Type _} (f : ι → Subgroup α) (g : α) (i : ι) :\n    quotientInfᵢEmbedding f (QuotientGroup.mk g) i = QuotientGroup.mk g :=\n  rfl\n#align quotient_infi_embedding_apply_mk quotient_infi_embedding_apply_mk\n\n",
 "quotient_equiv_of_eq_mk":
 "theorem quotient_equiv_of_eq_mk (h : s = t) (a : α) : quotientEquivOfEq h (QuotientGroup.mk a) = QuotientGroup.mk a :=\n  rfl\n#align quotient_equiv_of_eq_mk quotient_equiv_of_eq_mk\n\n",
 "preimage_image_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem preimage_image_coe (N : Subgroup α) (s : Set α) :\n    «expr ⁻¹' » coe («expr '' » (coe : α → «expr ⧸ » α N) s) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr ⁻¹' » (fun y : α => y * x) s) :=\n  by\n  ext x\n  simp only [QuotientGroup.eq, SetLike.exists, exists_prop, Set.mem_preimage, Set.mem_unionᵢ, Set.mem_image,\n    [anonymous], ← eq_inv_mul_iff_mul_eq]\n  exact ⟨fun ⟨y, hs, hN⟩ => ⟨_, N.inv_mem hN, by simpa using hs⟩, fun ⟨z, hz, hxz⟩ => ⟨x * z, hxz, by simpa using hz⟩⟩\n#align preimage_image_coe preimage_image_coe\n\n",
 "out_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp, to_additive QuotientAddGroup.out_eq']\ntheorem out_eq' (a : «expr ⧸ » α s) : mk a.out' = a :=\n  Quotient.out_eq' a\n#align out_eq' out_eq'\n\n",
 "orbit_subgroup_one_eq_self":
 "#print orbit_subgroup_one_eq_self /-\n@[to_additive]\ntheorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : α) = s :=\n  orbit_subgroup_eq_self_of_mem s s.one_mem\n#align orbit_subgroup_one_eq_self orbit_subgroup_one_eq_self\n#align orbit_add_subgroup_zero_eq_self orbit_addSubgroup_zero_eq_self\n-/\n\n",
 "orbit_subgroup_eq_self_of_mem":
 "#print orbit_subgroup_eq_self_of_mem /-\n@[to_additive]\ntheorem orbit_subgroup_eq_self_of_mem {a : α} (ha : a ∈ s) : MulAction.orbit s a = s :=\n  (orbit_subgroup_eq_rightCoset s a).trans (rightCoset_mem_rightCoset s ha)\n#align orbit_subgroup_eq_self_of_mem orbit_subgroup_eq_self_of_mem\n#align orbit_add_subgroup_eq_self_of_mem orbit_addSubgroup_eq_self_of_mem\n-/\n\n",
 "orbit_subgroup_eq_rightCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print orbit_subgroup_eq_rightCoset /-\n@[to_additive]\ntheorem orbit_subgroup_eq_rightCoset (a : α) : MulAction.orbit s a = right_coset s a :=\n  Set.ext fun b => ⟨fun ⟨c, d⟩ => ⟨c, c.2, d⟩, fun ⟨c, d, e⟩ => ⟨⟨c, d⟩, e⟩⟩\n#align orbit_subgroup_eq_right_coset orbit_subgroup_eq_rightCoset\n#align orbit_add_subgroup_eq_right_coset orbit_addSubgroup_eq_rightCoset\n-/\n\n",
 "one_leftCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print one_leftCoset /-\n@[simp, to_additive zero_leftAddCoset]\ntheorem one_leftCoset : left_coset 1 s = s :=\n  Set.ext <| by simp [leftCoset]\n#align one_left_coset one_leftCoset\n#align zero_left_add_coset zero_leftAddCoset\n-/\n\n",
 "normal_of_eq_cosets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print normal_of_eq_cosets /-\n@[to_additive normal_of_eq_addCosets]\ntheorem normal_of_eq_cosets (h : ∀ g : α, left_coset g s = right_coset s g) : s.normal :=\n  ⟨fun a ha g => show g * a * g⁻¹ ∈ (s : Set α) by rw [← mem_rightCoset_iff, ← h] <;> exact mem_leftCoset g ha⟩\n#align normal_of_eq_cosets normal_of_eq_cosets\n#align normal_of_eq_add_cosets normal_of_eq_addCosets\n-/\n\n",
 "normal_iff_eq_cosets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print normal_iff_eq_cosets /-\n@[to_additive normal_iff_eq_addCosets]\ntheorem normal_iff_eq_cosets : s.normal ↔ ∀ g : α, left_coset g s = right_coset s g :=\n  ⟨@eq_cosets_of_normal _ _ s, normal_of_eq_cosets s⟩\n#align normal_iff_eq_cosets normal_iff_eq_cosets\n#align normal_iff_eq_add_cosets normal_iff_eq_addCosets\n-/\n\n",
 "mk_surjective":
 "@[to_additive]\ntheorem mk_surjective : function.surjective <| @mk _ _ s :=\n  Quotient.surjective_Quotient_mk''\n#align mk_surjective mk_surjective\n\n",
 "mk_out'_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- It can be useful to write `obtain ⟨h, H⟩ := mk_out'_eq_mul ...`, and then `rw [H]` or\n  `simp_rw [H]` or `simp only [H]`. In order for `simp_rw` and `simp only` to work, this lemma is\n  stated in terms of an arbitrary `h : s`, rathern that the specific `h = g⁻¹ * (mk g).out'`. -/\n@[to_additive QuotientAddGroup.mk_out'_eq_mul]\ntheorem mk_out'_eq_mul (g : α) : ∃ h : s, (mk g : «expr ⧸ » α s).out' = g * h :=\n  ⟨⟨g⁻¹ * (mk g).out', eq'.mp (mk g).out_eq'.symm⟩, by rw [[anonymous], mul_inv_cancel_left]⟩\n#align mk_out'_eq_mul mk_out'_eq_mul\n\n",
 "mk_mul_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp, to_additive QuotientAddGroup.mk_add_of_mem]\ntheorem mk_mul_of_mem (a : α) (hb : b ∈ s) : (mk (a * b) : «expr ⧸ » α s) = mk a := by\n  rwa [eq', mul_inv_rev, inv_mul_cancel_right, s.inv_mem_iff]\n#align mk_mul_of_mem mk_mul_of_mem\n\n",
 "mem_rightCoset_rightCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print mem_rightCoset_rightCoset /-\n@[to_additive mem_rightAddCoset_rightAddCoset]\ntheorem mem_rightCoset_rightCoset {a : α} (ha : right_coset (s : Set α) a = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha] <;> exact mem_own_rightCoset s a\n#align mem_right_coset_right_coset mem_rightCoset_rightCoset\n#align mem_right_add_coset_right_add_coset mem_rightAddCoset_rightAddCoset\n-/\n\n",
 "mem_rightCoset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print mem_rightCoset_iff /-\n@[to_additive mem_rightAddCoset_iff]\ntheorem mem_rightCoset_iff (a : α) : x ∈ right_coset s a ↔ x * a⁻¹ ∈ s :=\n  iff.intro (fun ⟨b, hb, Eq⟩ => by simp [Eq.symm, hb]) fun h => ⟨x * a⁻¹, h, by simp⟩\n#align mem_right_coset_iff mem_rightCoset_iff\n#align mem_right_add_coset_iff mem_rightAddCoset_iff\n-/\n\n",
 "mem_rightCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print mem_rightCoset /-\n@[to_additive mem_rightAddCoset]\ntheorem mem_rightCoset {s : Set α} {x : α} (a : α) (hxS : x ∈ s) : x * a ∈ right_coset s a :=\n  mem_image_of_mem (fun b : α => b * a) hxS\n#align mem_right_coset mem_rightCoset\n#align mem_right_add_coset mem_rightAddCoset\n-/\n\n",
 "mem_own_rightCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print mem_own_rightCoset /-\n@[to_additive mem_own_rightAddCoset]\ntheorem mem_own_rightCoset (a : α) : a ∈ right_coset (s : Set α) a :=\n  suffices 1 * a ∈ right_coset (s : Set α) a by simpa\n  mem_rightCoset a (one_mem s : 1 ∈ s)\n#align mem_own_right_coset mem_own_rightCoset\n#align mem_own_right_add_coset mem_own_rightAddCoset\n-/\n\n",
 "mem_own_leftCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print mem_own_leftCoset /-\n@[to_additive mem_own_leftAddCoset]\ntheorem mem_own_leftCoset (a : α) : a ∈ left_coset a s :=\n  suffices a * 1 ∈ left_coset a s by simpa\n  mem_leftCoset a (one_mem s : 1 ∈ s)\n#align mem_own_left_coset mem_own_leftCoset\n#align mem_own_left_add_coset mem_own_leftAddCoset\n-/\n\n",
 "mem_leftCoset_leftCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print mem_leftCoset_leftCoset /-\n@[to_additive mem_leftAddCoset_leftAddCoset]\ntheorem mem_leftCoset_leftCoset {a : α} (ha : left_coset a s = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha] <;> exact mem_own_leftCoset s a\n#align mem_left_coset_left_coset mem_leftCoset_leftCoset\n#align mem_left_add_coset_left_add_coset mem_leftAddCoset_leftAddCoset\n-/\n\n",
 "mem_leftCoset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print mem_leftCoset_iff /-\n@[to_additive mem_leftAddCoset_iff]\ntheorem mem_leftCoset_iff (a : α) : x ∈ left_coset a s ↔ a⁻¹ * x ∈ s :=\n  iff.intro (fun ⟨b, hb, Eq⟩ => by simp [Eq.symm, hb]) fun h => ⟨a⁻¹ * x, h, by simp⟩\n#align mem_left_coset_iff mem_leftCoset_iff\n#align mem_left_add_coset_iff mem_leftAddCoset_iff\n-/\n\n",
 "mem_leftCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print mem_leftCoset /-\n/-\nCopyright (c) 2018 Mitchell Rowett. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mitchell Rowett, Scott Morrison\n-/\n@[to_additive mem_leftAddCoset]\ntheorem mem_leftCoset {s : Set α} {x : α} (a : α) (hxS : x ∈ s) : a * x ∈ left_coset a s :=\n  mem_image_of_mem (fun b : α => a * b) hxS\n#align mem_left_coset mem_leftCoset\n#align mem_left_add_coset mem_leftAddCoset\n-/\n\n",
 "left_rel_r_eq_left_coset_equivalence":
 "theorem left_rel_r_eq_left_coset_equivalence : @Setoid.r _ (QuotientGroup.leftRel s) = LeftCosetEquivalence s :=\n  by\n  ext\n  rw [left_rel_eq]\n  exact (leftCoset_eq_iff s).symm\n#align left_rel_r_eq_left_coset_equivalence left_rel_r_eq_left_coset_equivalence\n\n",
 "left_rel_eq":
 "@[to_additive]\ntheorem left_rel_eq : @Setoid.r _ (leftRel s) = fun x y => x⁻¹ * y ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply left_rel_apply\n#align left_rel_eq left_rel_eq\n\n",
 "left_rel_apply":
 "@[to_additive]\ntheorem left_rel_apply {x y : α} : @Setoid.r _ (leftRel s) x y ↔ x⁻¹ * y ∈ s :=\n  calc\n    (∃ a : s.opposite, y * MulOpposite.unop a = x) ↔ ∃ a : s, y * a = x := s.opposite_equiv.symm.exists_congr_left\n    _ ↔ ∃ a : s, x⁻¹ * y = a⁻¹ := by simp only [inv_mul_eq_iff_eq_mul, eq_mul_inv_iff_mul_eq]\n    _ ↔ x⁻¹ * y ∈ s := by simp [SetLike.exists]\n    \n#align left_rel_apply left_rel_apply\n\n",
 "leftCoset_rightCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print leftCoset_rightCoset /-\n@[to_additive leftAddCoset_rightAddCoset]\ntheorem leftCoset_rightCoset (s : Set α) (a b : α) : right_coset (left_coset a s) b = left_coset a (right_coset s b) :=\n  by simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n#align left_coset_right_coset leftCoset_rightCoset\n#align left_add_coset_right_add_coset leftAddCoset_rightAddCoset\n-/\n\n",
 "leftCoset_mem_leftCoset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print leftCoset_mem_leftCoset /-\n@[to_additive leftAddCoset_mem_leftAddCoset]\ntheorem leftCoset_mem_leftCoset {a : α} (ha : a ∈ s) : left_coset a s = s :=\n  Set.ext <| by simp [mem_leftCoset_iff, mul_mem_cancel_left (s.inv_mem ha)]\n#align left_coset_mem_left_coset leftCoset_mem_leftCoset\n#align left_add_coset_mem_left_add_coset leftAddCoset_mem_leftAddCoset\n-/\n\n",
 "leftCoset_eq_iff":
 "#print leftCoset_eq_iff /-\n@[to_additive leftAddCoset_eq_iff]\ntheorem leftCoset_eq_iff {x y : α} : leftCoset x s = leftCoset y s ↔ x⁻¹ * y ∈ s :=\n  by\n  rw [Set.ext_iff]\n  simp_rw [mem_leftCoset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [mul_left_inv]\n    exact s.one_mem\n  · intro h z\n    rw [← mul_inv_cancel_right x⁻¹ y]\n    rw [mul_assoc]\n    exact s.mul_mem_cancel_left h\n#align left_coset_eq_iff leftCoset_eq_iff\n#align left_add_coset_eq_iff leftAddCoset_eq_iff\n-/\n\n",
 "leftCoset_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n#print leftCoset_assoc /-\n@[simp, to_additive leftAddCoset_assoc]\ntheorem leftCoset_assoc (s : Set α) (a b : α) : left_coset a (left_coset b s) = left_coset (a * b) s := by\n  simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n#align left_coset_assoc leftCoset_assoc\n#align left_add_coset_assoc leftAddCoset_assoc\n-/\n\n",
 "leftCosetEquivalence_rel":
 "#print leftCosetEquivalence_rel /-\n@[to_additive leftAddCosetEquivalence_rel]\ntheorem leftCosetEquivalence_rel (s : Set α) : equivalence (LeftCosetEquivalence s) :=\n  Equivalence.mk (LeftCosetEquivalence s) (fun a => rfl) (fun a b => Eq.symm) fun a b c => Eq.trans\n#align left_coset_equivalence_rel leftCosetEquivalence_rel\n#align left_add_coset_equivalence_rel leftAddCosetEquivalence_rel\n-/\n\n",
 "induction_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- note [use has_coe_t]\n@[elab_as_elim, to_additive]\ntheorem induction_on' {C : «expr ⧸ » α s → Prop} (x : «expr ⧸ » α s) (H : ∀ z : α, C z) : C x :=\n  Quotient.inductionOn' x H\n#align induction_on' induction_on'\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[elab_as_elim, to_additive]\ntheorem induction_on {C : «expr ⧸ » α s → Prop} (x : «expr ⧸ » α s) (H : ∀ z, C (QuotientGroup.mk z)) : C x :=\n  Quotient.inductionOn' x H\n#align induction_on induction_on\n\n",
 "forall_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem forall_coe {C : «expr ⧸ » α s → Prop} : (∀ x : «expr ⧸ » α s, C x) ↔ ∀ x : α, C x :=\n  mk_surjective.forall\n#align forall_coe forall_coe\n\n",
 "exists_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem exists_coe {C : «expr ⧸ » α s → Prop} : (∃ x : «expr ⧸ » α s, C x) ↔ ∃ x : α, C x :=\n  mk_surjective.exists\n#align exists_coe exists_coe\n\n",
 "eq_cosets_of_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `left_coset -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `right_coset -/\n#print eq_cosets_of_normal /-\n@[to_additive eq_addCosets_of_normal]\ntheorem eq_cosets_of_normal (N : s.normal) (g : α) : left_coset g s = right_coset s g :=\n  Set.ext fun a => by simp [mem_leftCoset_iff, mem_rightCoset_iff] <;> rw [N.mem_comm_iff]\n#align eq_cosets_of_normal eq_cosets_of_normal\n#align eq_add_cosets_of_normal eq_addCosets_of_normal\n-/\n\n",
 "eq_class_eq_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem eq_class_eq_left_coset (s : Subgroup α) (g : α) : { x : α | (x : «expr ⧸ » α s) = g } = leftCoset g s :=\n  Set.ext fun z => by rw [mem_leftCoset_iff, Set.mem_setOf_eq, eq_comm, QuotientGroup.eq, SetLike.mem_coe]\n#align eq_class_eq_left_coset eq_class_eq_left_coset\n\n",
 "eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive QuotientAddGroup.eq']\ntheorem eq' {a b : α} : (mk a : «expr ⧸ » α s) = mk b ↔ a⁻¹ * b ∈ s :=\n  QuotientGroup.eq\n#align eq' eq'\n\n",
 "card_subgroup_dvd_card":
 "/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\n@[to_additive \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\\nambient group.\"]\ntheorem card_subgroup_dvd_card [Fintype α] (s : Subgroup α) [Fintype s] : Fintype.card s ∣ Fintype.card α := by\n  classical simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_left ℕ]\n#align card_subgroup_dvd_card card_subgroup_dvd_card\n\n",
 "card_quotient_right_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem card_quotient_right_rel [Fintype («expr ⧸ » α s)] :\n    Fintype.card (quotient (QuotientGroup.rightRel s)) = Fintype.card («expr ⧸ » α s) :=\n  Fintype.ofEquiv_card (QuotientGroup.quotientRightRelEquivQuotientLeftRel s).symm\n#align card_quotient_right_rel card_quotient_right_rel\n\n",
 "card_quotient_dvd_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem card_quotient_dvd_card [Fintype α] (s : Subgroup α) [DecidablePred (· ∈ s)] :\n    Fintype.card («expr ⧸ » α s) ∣ Fintype.card α := by\n  simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_right ℕ]\n#align card_quotient_dvd_card card_quotient_dvd_card\n\n",
 "card_eq_card_quotient_mul_card_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem card_eq_card_quotient_mul_card_subgroup [Fintype α] (s : Subgroup α) [Fintype s]\n    [DecidablePred fun a => a ∈ s] : Fintype.card α = Fintype.card («expr ⧸ » α s) * Fintype.card s := by\n  rw [← Fintype.card_prod] <;> exact Fintype.card_congr Subgroup.groupEquivQuotientProdSubgroup\n#align card_eq_card_quotient_mul_card_subgroup card_eq_card_quotient_mul_card_subgroup\n\n",
 "card_dvd_of_le":
 "@[to_additive]\ntheorem card_dvd_of_le {H K : Subgroup α} [Fintype H] [Fintype K] (hHK : H ≤ K) : card H ∣ card K :=\n  card_dvd_of_injective (inclusion hHK) (inclusion_injective hHK)\n#align card_dvd_of_le card_dvd_of_le\n\n",
 "card_dvd_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem card_dvd_of_injective [Fintype α] [Fintype H] (f : «expr →* » α H) (hf : function.injective f) :\n    card α ∣ card H := by\n  classical calc\n      card α = card (f.range : Subgroup H) := card_congr (Equiv.ofInjective f hf)\n      _ ∣ card H := card_subgroup_dvd_card _\n      \n#align card_dvd_of_injective card_dvd_of_injective\n\n",
 "card_comap_dvd_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem card_comap_dvd_of_injective (K : Subgroup H) [Fintype K] (f : «expr →* » α H) [Fintype (K.comap f)]\n    (hf : function.injective f) : Fintype.card (K.comap f) ∣ Fintype.card K := by\n  haveI : Fintype ((K.comap f).map f) := Fintype.ofEquiv _ (equiv_map_of_injective _ _ hf).to_equiv <;>\n    calc\n      Fintype.card (K.comap f) = Fintype.card ((K.comap f).map f) :=\n        Fintype.card_congr (equiv_map_of_injective _ _ hf).to_equiv\n      _ ∣ Fintype.card K := card_dvd_of_le (map_comap_le _ _)\n      \n#align card_comap_dvd_of_injective card_comap_dvd_of_injective\n\n",
 "Eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print Eq /-\n@[to_additive QuotientAddGroup.eq]\nprotected theorem Eq {a b : α} : (a : «expr ⧸ » α s) = b ↔ a⁻¹ * b ∈ s :=\n  calc\n    _ ↔ @Setoid.r _ (leftRel s) a b := Quotient.eq''\n    _ ↔ _ := by rw [left_rel_apply]\n    \n#align eq Eq\n-/\n\n"}