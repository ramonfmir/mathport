{"stabilizer_vadd_eq_stabilizer_map_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- If the stabilizer of `x` is `S`, then the stabilizer of `g +ᵥ x` is `g + S + (-g)`. -/\ntheorem stabilizer_vadd_eq_stabilizer_map_conj (g : α) (x : β) :\n    stabilizer α («expr +ᵥ » g x) = (stabilizer α x).map (AddAut.conj g).to_add_monoid_hom :=\n  by\n  ext h\n  rw [mem_stabilizer_iff, ← vadd_left_cancel_iff (-g), vadd_vadd, vadd_vadd, vadd_vadd, add_left_neg, zero_vadd, ←\n    mem_stabilizer_iff, add_subgroup.mem_map_equiv, AddAut.conj_symm_apply]\n#align stabilizer_vadd_eq_stabilizer_map_conj stabilizer_vadd_eq_stabilizer_map_conj\n\n",
 "stabilizer_smul_eq_stabilizer_map_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If the stabilizer of `x` is `S`, then the stabilizer of `g • x` is `gSg⁻¹`. -/\ntheorem stabilizer_smul_eq_stabilizer_map_conj (g : α) (x : β) :\n    stabilizer α («expr • » g x) = (stabilizer α x).map (MulAut.conj g).to_monoid_hom :=\n  by\n  ext h\n  rw [mem_stabilizer_iff, ← smul_left_cancel_iff g⁻¹, smul_smul, smul_smul, smul_smul, mul_left_inv, one_smul, ←\n    mem_stabilizer_iff, subgroup.mem_map_equiv, MulAut.conj_symm_apply]\n#align stabilizer_smul_eq_stabilizer_map_conj stabilizer_smul_eq_stabilizer_map_conj\n\n",
 "smul_orbit_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_orbit_subset (a : α) (b : β) : «expr • » a (orbit α b) ⊆ orbit α b :=\n  (maps_to_smul_orbit a b).image_subset\n#align smul_orbit_subset smul_orbit_subset\n\n",
 "smul_orbit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem smul_orbit (a : α) (b : β) : «expr • » a (orbit α b) = orbit α b :=\n  (smul_orbit_subset a b).antisymm <|\n    calc\n      orbit α b = «expr • » a («expr • » a⁻¹ (orbit α b)) := (smul_inv_smul _ _).symm\n      _ ⊆ «expr • » a (orbit α b) := Set.image_subset _ (smul_orbit_subset _ _)\n      \n#align smul_orbit smul_orbit\n\n",
 "smul_mem_orbit_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_mem_orbit_smul (g h : α) (a : β) : «expr • » g a ∈ orbit α («expr • » h a) := by\n  simp only [orbit_smul, mem_orbit]\n#align smul_mem_orbit_smul smul_mem_orbit_smul\n\n",
 "smul_cancel_of_non_zero_divisor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `smul` by a `k : M` over a ring is injective, if `k` is not a zero divisor.\nThe general theory of such `k` is elaborated by `is_smul_regular`.\nThe typeclass that restricts all terms of `M` to have this property is `no_zero_smul_divisors`. -/\ntheorem smul_cancel_of_non_zero_divisor {M R : Type _} [monoid M] [NonUnitalNonAssocRing R] [DistribMulAction M R]\n    (k : M) (h : ∀ x : R, «expr • » k x = 0 → x = 0) {a b : R} (h' : «expr • » k a = «expr • » k b) : a = b :=\n  by\n  rw [← sub_eq_zero]\n  refine' h _ _\n  rw [smul_sub, h', sub_self]\n#align smul_cancel_of_non_zero_divisor smul_cancel_of_non_zero_divisor\n\n",
 "quotient_preimage_image_eq_union_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/-- When you take a set `U` in `β`, push it down to the quotient, and pull back, you get the union\nof the orbit of `U` under `α`. -/\n@[to_additive\n      \"When you take a set `U` in `β`, push it down to the quotient, and pull back, you get\\nthe union of the orbit of `U` under `α`.\"]\ntheorem quotient_preimage_image_eq_union_mul (U : set β) :\n    «expr ⁻¹' » Quotient.mk'' («expr '' » Quotient.mk'' U) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » ((«expr • » · ·) a) U) :=\n  by\n  set f : β → quotient (mul_action.orbit_rel α β) := Quotient.mk''\n  ext\n  constructor\n  · rintro ⟨y, hy, hxy⟩\n    obtain ⟨a, rfl⟩ := quotient.exact hxy\n    rw [Set.mem_unionᵢ]\n    exact ⟨a⁻¹, «expr • » a x, hy, inv_smul_smul a x⟩\n  · intro hx\n    rw [Set.mem_unionᵢ] at hx\n    obtain ⟨a, u, hu₁, hu₂⟩ := hx\n    rw [Set.mem_preimage, Set.mem_image_iff_bex]\n    refine' ⟨«expr • » a⁻¹ x, _, by simp only [quotient.eq] <;> use a⁻¹⟩\n    rw [← hu₂]\n    convert hu₁\n    simp only [inv_smul_smul]\n#align quotient_preimage_image_eq_union_mul quotient_preimage_image_eq_union_mul\n\n",
 "orbit_smul_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem orbit_smul_subset (a : α) (b : β) : orbit α («expr • » a b) ⊆ orbit α b :=\n  Set.range_subset_iff.2 fun a' => mul_smul a' a b ▸ mem_orbit _ _\n#align orbit_smul_subset orbit_smul_subset\n\n",
 "orbit_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem orbit_smul (a : α) (b : β) : orbit α («expr • » a b) = orbit α b :=\n  (orbit_smul_subset a b).antisymm <|\n    calc\n      orbit α b = orbit α («expr • » a⁻¹ («expr • » a b)) := by rw [inv_smul_smul]\n      _ ⊆ orbit α («expr • » a b) := orbit_smul_subset _ _\n      \n#align orbit_smul orbit_smul\n\n",
 "orbit_nonempty":
 "@[to_additive]\ntheorem orbit_nonempty (b : β) : Set.Nonempty (orbit α b) :=\n  Set.range_nonempty _\n#align orbit_nonempty orbit_nonempty\n\n",
 "orbit_mk":
 "@[simp, to_additive]\ntheorem orbit_rel.quotient.orbit_mk (b : β) :\n    orbit_rel.quotient.orbit (quotient.mk' b : orbit_rel.quotient α β) = orbit α b :=\n  rfl\n#align orbit_rel.quotient.orbit_mk orbit_rel.quotient.orbit_mk\n\n",
 "orbit_eq_univ":
 "@[to_additive]\ntheorem orbit_eq_univ [IsPretransitive α β] (x : β) : orbit α x = Set.univ :=\n  (surjective_smul α x).range_eq\n#align orbit_eq_univ orbit_eq_univ\n\n",
 "orbit_eq_orbit_out":
 "/-- Note that `hφ = quotient.out_eq'` is a useful choice here. -/\n@[to_additive \"Note that `hφ = quotient.out_eq'` is a useful choice here.\"]\ntheorem orbit_rel.quotient.orbit_eq_orbit_out (x : orbit_rel.quotient α β) {φ : orbit_rel.quotient α β → β}\n    (hφ : right_inverse φ quotient.mk') : orbit_rel.quotient.orbit x = orbit α (φ x) :=\n  by\n  conv_lhs => rw [← hφ x]\n  induction x using Quotient.inductionOn'\n  rfl\n#align orbit_rel.quotient.orbit_eq_orbit_out orbit_rel.quotient.orbit_eq_orbit_out\n\n",
 "orbit_eq_iff":
 "@[to_additive]\ntheorem orbit_eq_iff {a b : β} : orbit α a = orbit α b ↔ a ∈ orbit α b :=\n  ⟨fun h => h ▸ mem_orbit_self _, fun ⟨c, hc⟩ => hc ▸ orbit_smul _ _⟩\n#align orbit_eq_iff orbit_eq_iff\n\n",
 "mem_stabilizer_submonoid_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem mem_stabilizer_submonoid_iff {b : β} {a : α} : a ∈ stabilizer.submonoid α b ↔ «expr • » a b = b :=\n  iff.rfl\n#align mem_stabilizer_submonoid_iff mem_stabilizer_submonoid_iff\n\n",
 "mem_stabilizer_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem mem_stabilizer_iff {b : β} {a : α} : a ∈ stabilizer α b ↔ «expr • » a b = b :=\n  iff.rfl\n#align mem_stabilizer_iff mem_stabilizer_iff\n\n",
 "mem_orbit_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem mem_orbit_smul (g : α) (a : β) : a ∈ orbit α («expr • » g a) := by simp only [orbit_smul, mem_orbit_self]\n#align mem_orbit_smul mem_orbit_smul\n\n",
 "mem_orbit_self":
 "@[simp, to_additive]\ntheorem mem_orbit_self (b : β) : b ∈ orbit α b :=\n  ⟨1, by simp [mul_action.one_smul]⟩\n#align mem_orbit_self mem_orbit_self\n\n",
 "mem_orbit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n@[to_additive]\ntheorem mem_orbit_iff {b₁ b₂ : β} : b₂ ∈ orbit α b₁ ↔ ∃ x : α, «expr • » x b₁ = b₂ :=\n  iff.rfl\n#align mem_orbit_iff mem_orbit_iff\n\n",
 "mem_orbit":
 "@[to_additive]\ntheorem orbit_rel.quotient.mem_orbit {b : β} {x : orbit_rel.quotient α β} : b ∈ x.orbit ↔ quotient.mk' b = x :=\n  by\n  induction x using Quotient.inductionOn'\n  rw [quotient.eq']\n  rfl\n#align orbit_rel.quotient.mem_orbit orbit_rel.quotient.mem_orbit\n\n",
 "mem_fixed_points_iff_card_orbit_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem mem_fixed_points_iff_card_orbit_eq_one {a : β} [fintype (orbit α a)] :\n    a ∈ fixed_points α β ↔ fintype.card (orbit α a) = 1 :=\n  by\n  rw [fintype.card_eq_one_iff, mem_fixed_points]\n  constructor\n  · exact fun h => ⟨⟨a, mem_orbit_self _⟩, fun ⟨b, ⟨x, hx⟩⟩ => subtype.eq <| by simp [h x, hx.symm]⟩\n  · intro h x\n    rcases h with ⟨⟨z, hz⟩, hz₁⟩\n    calc\n      «expr • » x a = z := subtype.mk.inj (hz₁ ⟨«expr • » x a, mem_orbit _ _⟩)\n      _ = a := (subtype.mk.inj (hz₁ ⟨a, mem_orbit_self _⟩)).symm\n      \n#align mem_fixed_points_iff_card_orbit_eq_one mem_fixed_points_iff_card_orbit_eq_one\n\n",
 "mem_fixed_points'":
 "@[to_additive]\ntheorem mem_fixed_points' {b : β} : b ∈ fixed_points α β ↔ ∀ b', b' ∈ orbit α b → b' = b :=\n  ⟨fun h b h₁ =>\n    let ⟨x, hx⟩ := mem_orbit_iff.1 h₁\n    hx ▸ h x,\n    fun h b => h _ (mem_orbit _ _)⟩\n#align mem_fixed_points' mem_fixed_points'\n\n",
 "mem_fixed_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem mem_fixed_points {b : β} : b ∈ fixed_points α β ↔ ∀ x : α, «expr • » x b = b :=\n  iff.rfl\n#align mem_fixed_points mem_fixed_points\n\n",
 "mem_fixed_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem mem_fixed_by {g : α} {b : β} : b ∈ fixed_by α β g ↔ «expr • » g b = b :=\n  iff.rfl\n#align mem_fixed_by mem_fixed_by\n\n",
 "maps_to_smul_orbit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[to_additive]\ntheorem maps_to_smul_orbit (a : α) (b : β) : Set.MapsTo ((«expr • » · ·) a) (orbit α b) (orbit α b) :=\n  Set.range_subset_iff.2 fun a' => ⟨a * a', mul_smul _ _ _⟩\n#align maps_to_smul_orbit maps_to_smul_orbit\n\n",
 "image_inter_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem image_inter_image_iff (U V : set β) :\n    «expr '' » Quotient.mk'' U ∩ «expr '' » Quotient.mk'' V = ∅ ↔ ∀ x ∈ U, ∀ a : α, «expr • » a x ∉ V :=\n  Set.disjoint_iff_inter_eq_empty.symm.trans disjoint_image_image_iff\n#align image_inter_image_iff image_inter_image_iff\n\n",
 "fixed_eq_Inter_fixed_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[to_additive]\ntheorem fixed_eq_Inter_fixed_by :\n    fixed_points α β =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (fixed_by α β g) :=\n  Set.ext fun x => ⟨fun hx => Set.mem_interᵢ.2 fun g => hx g, fun hx g => (Set.mem_interᵢ.1 hx g : _)⟩\n#align fixed_eq_Inter_fixed_by fixed_eq_Inter_fixed_by\n\n",
 "disjoint_image_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem disjoint_image_image_iff {U V : set β} :\n    Disjoint («expr '' » Quotient.mk'' U) («expr '' » Quotient.mk'' V) ↔ ∀ x ∈ U, ∀ a : α, «expr • » a x ∉ V :=\n  by\n  set f : β → quotient (mul_action.orbit_rel α β) := Quotient.mk''\n  refine' ⟨fun h x x_in_U a a_in_V => h.le_bot ⟨⟨x, x_in_U, quotient.sound ⟨a⁻¹, _⟩⟩, ⟨«expr • » a x, a_in_V, rfl⟩⟩, _⟩\n  · simp\n  · intro h\n    rw [Set.disjoint_left]\n    rintro x ⟨y, hy₁, hy₂⟩ ⟨z, hz₁, hz₂⟩\n    obtain ⟨a, rfl⟩ := quotient.exact (hz₂.trans hy₂.symm)\n    exact h y hy₁ a hz₁\n#align disjoint_image_image_iff disjoint_image_image_iff\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem orbit.coe_smul {b : β} {a : α} {b' : orbit α b} : ↑(«expr • » a b') = «expr • » a (b' : β) :=\n  rfl\n#align orbit.coe_smul orbit.coe_smul\n\n"}