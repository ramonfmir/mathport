{"update_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem update_smul {α : Type _} [∀ i, SMul α (f i)] [decidable_eq I] (c : α) (f₁ : ∀ i, f i) (i : I) (x₁ : f i) :\n    update («expr • » c f₁) i («expr • » c x₁) = «expr • » c (update f₁ i x₁) :=\n  funext fun j => (apply_update (fun i => («expr • » · ·) c) f₁ i x₁ j).symm\n#align update_smul update_smul\n\n",
 "smul_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2018 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon, Patrick Massot\n-/\n-- The indexing type\n-- The family of types already equipped with instances\n@[simp, to_additive]\ntheorem smul_apply' {g : I → Type _} [∀ i, SMul (f i) (g i)] (s : ∀ i, f i) (x : ∀ i, g i) :\n    («expr • » s x) i = «expr • » (s i) (x i) :=\n  rfl\n#align smul_apply' smul_apply'\n\n",
 "single_smul₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem single_smul₀ {g : I → Type _} [∀ i, monoid_with_zero (f i)] [∀ i, add_monoid (g i)]\n    [∀ i, DistribMulAction (f i) (g i)] [decidable_eq I] (i : I) (r : f i) (x : g i) :\n    single i («expr • » r x) = «expr • » (single i r) (single i x) :=\n  single_op₂ (fun i : I => ((«expr • » · ·) : f i → g i → g i)) (fun j => smul_zero _) _ _ _\n#align single_smul₀ single_smul₀\n\n",
 "single_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A version of `pi.single_smul` for non-dependent functions. It is useful in cases Lean fails\nto apply `pi.single_smul`. -/\ntheorem single_smul' {α β} [monoid α] [add_monoid β] [DistribMulAction α β] [decidable_eq I] (i : I) (r : α) (x : β) :\n    single i («expr • » r x) = «expr • » r (single i x) :=\n  single_smul i r x\n#align single_smul' single_smul'\n\n",
 "single_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem single_smul {α} [monoid α] [∀ i, add_monoid <| f i] [∀ i, DistribMulAction α <| f i] [decidable_eq I] (i : I)\n    (r : α) (x : f i) : single i («expr • » r x) = «expr • » r (single i x) :=\n  single_op (fun i : I => ((«expr • » · ·) r : f i → f i)) (fun j => smul_zero _) _ _\n#align single_smul single_smul\n\n",
 "piecewise_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem piecewise_smul {α : Type _} [∀ i, SMul α (f i)] (s : set I) [∀ i, decidable (i ∈ s)] (c : α)\n    (f₁ g₁ : ∀ i, f i) : s.piecewise («expr • » c f₁) («expr • » c g₁) = «expr • » c (s.piecewise f₁ g₁) :=\n  s.piecewise_op _ _ fun _ => («expr • » · ·) c\n#align piecewise_smul piecewise_smul\n\n",
 "has_faithful_smul_at":
 "/-- If `f i` has a faithful scalar action for a given `i`, then so does `Π i, f i`. This is\nnot an instance as `i` cannot be inferred. -/\n@[to_additive Pi.faithfulVAdd_at\n      \"If `f i` has a faithful additive action for a given `i`, then\\nso does `Π i, f i`. This is not an instance as `i` cannot be inferred\"]\ntheorem has_faithful_smul_at {α : Type _} [∀ i, SMul α <| f i] [∀ i, nonempty (f i)] (i : I) [FaithfulSMul α (f i)] :\n    FaithfulSMul α (∀ i, f i) :=\n  ⟨fun x y h =>\n    eq_of_smul_eq_smul fun a : f i => by\n      classical\n        have := congr_fun (h <| function.update (fun j => classical.choice (‹∀ i, nonempty (f i)› j)) i a) i\n        simpa using this⟩\n#align has_faithful_smul_at has_faithful_smul_at\n\n",
 "extend_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Function.extend_smul /-\n@[to_additive]\ntheorem Function.extend_smul {R α β γ : Type _} [SMul R γ] (r : R) (f : α → β) (g : α → γ) (e : β → γ) :\n    function.extend f («expr • » r g) («expr • » r e) = «expr • » r (function.extend f g e) :=\n  funext fun _ => by convert (apply_dite ((«expr • » · ·) r) _ _ _).symm\n#align function.extend_smul Function.extend_smul\n-/\n\n"}