{"unop_smul_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsCentralScalar.unop_smul_eq_smul /-\n@[to_additive]\ntheorem IsCentralScalar.unop_smul_eq_smul {M α : Type _} [SMul M α] [SMul («expr ᵐᵒᵖ» M) α] [IsCentralScalar M α]\n    (m : «expr ᵐᵒᵖ» M) (a : α) : «expr • » (mul_opposite.unop m) a = «expr • » m a :=\n  MulOpposite.rec' (fun m => (is_central_scalar.op_smul_eq_smul _ _).symm) m\n#align is_central_scalar.unop_smul_eq_smul IsCentralScalar.unop_smul_eq_smul\n-/\n\n",
 "to_fun_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem to_fun_apply (x : M) (y : α) : MulAction.toFun M α y x = «expr • » x y :=\n  rfl\n#align to_fun_apply to_fun_apply\n\n",
 "toMul_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n#print toMul_smul /-\n@[simp]\ntheorem toMul_smul [SMul α β] (a) (b : β) : «expr • » (toMul a : α) b = «expr +ᵥ » a b :=\n  rfl\n#align to_mul_smul toMul_smul\n-/\n\n",
 "toMonoidHom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print MulDistribMulAction.toMonoidHom_apply /-\n@[simp]\ntheorem MulDistribMulAction.toMonoidHom_apply (r : M) (x : A) : MulDistribMulAction.toMonoidHom A r x = «expr • » r x :=\n  rfl\n#align mul_distrib_mul_action.to_monoid_hom_apply MulDistribMulAction.toMonoidHom_apply\n-/\n\n",
 "toAdd_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print toAdd_vadd /-\n@[simp]\ntheorem toAdd_vadd [VAdd α β] (a) (b : β) : «expr +ᵥ » (toAdd a : α) b = «expr • » a b :=\n  rfl\n#align to_add_vadd toAdd_vadd\n-/\n\n",
 "symm":
 "#print SMulCommClass.symm /-\n/-- Commutativity of actions is a symmetric relation. This lemma can't be an instance because this\nwould cause a loop in the instance search graph. -/\n@[to_additive]\ntheorem SMulCommClass.symm (M N α : Type _) [SMul M α] [SMul N α] [SMulCommClass M N α] : SMulCommClass N M α :=\n  ⟨fun a' a b => (smul_comm a a' b).symm⟩\n#align smul_comm_class.symm SMulCommClass.symm\n-/\n\n",
 "surjective_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem surjective_smul (x : α) : surjective fun c : M => «expr • » c x :=\n  exists_smul_eq M x\n#align surjective_smul surjective_smul\n\n",
 "smul_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_zero /-\n@[simp]\ntheorem smul_zero (a : M) : «expr • » a (0 : A) = 0 :=\n  smul_zero_class.smul_zero _\n#align smul_zero smul_zero\n-/\n\n",
 "smul_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_sub /-\ntheorem smul_sub (r : M) (x y : A) : «expr • » r (x - y) = «expr • » r x - «expr • » r y := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, smul_add, smul_neg]\n#align smul_sub smul_sub\n-/\n\n",
 "smul_smul_smul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_smul_smul_comm /-\n@[to_additive]\ntheorem smul_smul_smul_comm [SMul α β] [SMul α γ] [SMul β δ] [SMul α δ] [SMul γ δ] [IsScalarTower α β δ]\n    [IsScalarTower α γ δ] [SMulCommClass β γ δ] (a : α) (b : β) (c : γ) (d : δ) :\n    «expr • » («expr • » a b) («expr • » c d) = «expr • » («expr • » a c) («expr • » b d) :=\n  by\n  rw [smul_assoc, smul_assoc, smul_comm b]\n  infer_instance\n#align smul_smul_smul_comm smul_smul_smul_comm\n-/\n\n",
 "smul_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_smul /-\n@[to_additive]\ntheorem smul_smul (a₁ a₂ : M) (b : α) : «expr • » a₁ («expr • » a₂ b) = «expr • » (a₁ * a₂) b :=\n  (mul_smul _ _ _).symm\n#align smul_smul smul_smul\n-/\n\n",
 "smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Commute.smul_right /-\n@[to_additive]\ntheorem Commute.smul_right [Mul α] [SMulCommClass M α α] [IsScalarTower M α α] {a b : α} (h : Commute a b) (r : M) :\n    Commute a («expr • » r b) :=\n  (mul_smul_comm _ _ _).trans ((congr_arg _ h).trans <| (smul_mul_assoc _ _ _).symm)\n#align commute.smul_right Commute.smul_right\n-/\n\n",
 "smul_one_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_one_smul /-\n@[simp, to_additive]\ntheorem smul_one_smul {M} (N) [monoid N] [SMul M N] [MulAction N α] [SMul M α] [IsScalarTower M N α] (x : M) (y : α) :\n    «expr • » («expr • » x (1 : N)) y = «expr • » x y := by rw [smul_assoc, one_smul]\n#align smul_one_smul smul_one_smul\n-/\n\n",
 "smul_one_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_one_mul /-\n@[simp, to_additive]\ntheorem smul_one_mul {M N} [mul_one_class N] [SMul M N] [IsScalarTower M N N] (x : M) (y : N) :\n    «expr • » x 1 * y = «expr • » x y := by rw [smul_mul_assoc, one_mul]\n#align smul_one_mul smul_one_mul\n-/\n\n",
 "smul_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_neg /-\n-- See note [lower instance priority]\n-- `smul_comm_class.symm` is not registered as an instance, as it would cause a loop\n-- `smul_comm_class.symm` is not registered as an instance, as it would cause a loop\n@[simp]\ntheorem smul_neg (r : M) (x : A) : «expr • » r (-x) = -«expr • » r x :=\n  eq_neg_of_add_eq_zero_left <| by rw [← smul_add, neg_add_self, smul_zero]\n#align smul_neg smul_neg\n-/\n\n",
 "smul_mul_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mul_smul /-\n-- see Note [lower instance priority]\n/-- Note that the `is_scalar_tower M α α` and `smul_comm_class M α α` typeclass arguments are\nusually satisfied by `algebra M α`. -/\n@[to_additive, nolint to_additive_doc]\ntheorem smul_mul_smul [Mul α] (r s : M) (x y : α) [IsScalarTower M α α] [SMulCommClass M α α] :\n    «expr • » r x * «expr • » s y = «expr • » (r * s) (x * y) := by\n  rw [smul_mul_assoc, mul_smul_comm, ← smul_assoc, smul_eq_mul]\n#align smul_mul_smul smul_mul_smul\n-/\n\n",
 "smul_mul_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mul_assoc /-\n/-- Note that the `is_scalar_tower α β β` typeclass argument is usually satisfied by `algebra α β`.\n-/\n@[to_additive, nolint to_additive_doc]\ntheorem smul_mul_assoc [Mul β] [SMul α β] [IsScalarTower α β β] (r : α) (x y : β) :\n    «expr • » r x * y = «expr • » r (x * y) :=\n  smul_assoc r x y\n#align smul_mul_assoc smul_mul_assoc\n-/\n\n",
 "smul_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_mul' /-\ntheorem smul_mul' (a : M) (b₁ b₂ : A) : «expr • » a (b₁ * b₂) = «expr • » a b₁ * «expr • » a b₂ :=\n  mul_distrib_mul_action.smul_mul _ _ _\n#align smul_mul' smul_mul'\n-/\n\n",
 "smul_left_injective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n#print smul_left_injective' /-\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Yury Kudryashov\n-/\n@[to_additive]\ntheorem smul_left_injective' [SMul M α] [FaithfulSMul M α] : function.injective ((«expr • » · ·) : M → α → α) :=\n  fun m₁ m₂ h => has_faithful_smul.eq_of_smul_eq_smul (congr_fun h)\n#align smul_left_injective' smul_left_injective'\n-/\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Commute.smul_left /-\n@[to_additive]\ntheorem Commute.smul_left [Mul α] [SMulCommClass M α α] [IsScalarTower M α α] {a b : α} (h : Commute a b) (r : M) :\n    Commute («expr • » r a) b :=\n  (h.symm.smul_right r).symm\n#align commute.smul_left Commute.smul_left\n-/\n\n",
 "smul_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_ite /-\n@[to_additive]\ntheorem smul_ite (a : M) (b₁ b₂ : α) : «expr • » a (ite p b₁ b₂) = ite p («expr • » a b₁) («expr • » a b₂) := by\n  split_ifs <;> rfl\n#align smul_ite smul_ite\n-/\n\n",
 "smul_inv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_inv' /-\n@[simp]\ntheorem smul_inv' (r : M) (x : A) : «expr • » r x⁻¹ = («expr • » r x)⁻¹ :=\n  (MulDistribMulAction.toMonoidHom A r).map_inv x\n#align smul_inv' smul_inv'\n-/\n\n",
 "smul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_mul /-\n-- see Note [lower instance priority]\n@[simp, to_additive]\ntheorem smul_eq_mul (α : Type _) [Mul α] {a a' : α} : «expr • » a a' = a * a' :=\n  rfl\n#align smul_eq_mul smul_eq_mul\n-/\n\n",
 "smul_div'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_div' /-\ntheorem smul_div' (r : M) (x y : A) : «expr • » r (x / y) = «expr • » r x / «expr • » r y :=\n  map_div (MulDistribMulAction.toMonoidHom A r) x y\n#align smul_div' smul_div'\n-/\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AddMonoid.End.smul_def /-\n@[simp]\ntheorem AddMonoid.End.smul_def [add_monoid α] (f : AddMonoid.End α) (a : α) : «expr • » f a = f a :=\n  rfl\n#align add_monoid.End.smul_def AddMonoid.End.smul_def\n-/\n\n",
 "smul_comm_class'":
 "/-- This cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\nare still metavariables.\n-/\n@[to_additive\n      \"This cannot be an instance because it can cause infinite loops whenever\\nthe `has_vadd` arguments are still metavariables.\"]\ntheorem comp.smul_comm_class' [SMul β α] [SMulCommClass β M α] (g : N → M) :\n    haveI := comp α g\n    SMulCommClass β N α :=\n  { smul_comm := fun _ n => @smul_comm _ _ _ _ _ _ _ (g n) }\n#align comp.smul_comm_class' comp.smul_comm_class'\n\n",
 "smul_comm_class":
 "/-- This cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\nare still metavariables.\n-/\n@[to_additive\n      \"This cannot be an instance because it can cause infinite loops whenever\\nthe `has_vadd` arguments are still metavariables.\"]\ntheorem comp.smul_comm_class [SMul β α] [SMulCommClass M β α] (g : N → M) :\n    haveI := comp α g\n    SMulCommClass N β α :=\n  { smul_comm := fun n => @smul_comm _ _ _ _ _ _ (g n) }\n#align comp.smul_comm_class comp.smul_comm_class\n\n",
 "smul_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_assoc /-\n@[simp, to_additive]\ntheorem smul_assoc {M N} [SMul M N] [SMul N α] [SMul M α] [IsScalarTower M N α] (x : M) (y : N) (z : α) :\n    «expr • » («expr • » x y) z = «expr • » x («expr • » y z) :=\n  is_scalar_tower.smul_assoc x y z\n#align smul_assoc smul_assoc\n-/\n\n",
 "smul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_add /-\ntheorem smul_add (a : M) (b₁ b₂ : A) : «expr • » a (b₁ + b₂) = «expr • » a b₁ + «expr • » a b₂ :=\n  distrib_smul.smul_add _ _ _\n#align smul_add smul_add\n-/\n\n",
 "one_smul_eq_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n#print one_smul_eq_id /-\n/-- `has_smul` version of `one_mul_eq_id` -/\n@[to_additive \"`has_vadd` version of `zero_add_eq_id`\"]\ntheorem one_smul_eq_id : ((«expr • » · ·) (1 : M) : α → α) = id :=\n  funext <| one_smul _\n#align one_smul_eq_id one_smul_eq_id\n-/\n\n",
 "one_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print one_smul /-\n@[simp, to_additive]\ntheorem one_smul (b : α) : «expr • » (1 : M) b = b :=\n  mul_action.one_smul _\n#align one_smul one_smul\n-/\n\n",
 "of_smul_one_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print IsScalarTower.of_smul_one_mul /-\n@[to_additive]\ntheorem IsScalarTower.of_smul_one_mul {M N} [monoid N] [SMul M N]\n    (h : ∀ (x : M) (y : N), «expr • » x (1 : N) * y = «expr • » x y) : IsScalarTower M N N :=\n  ⟨fun x y z => by rw [← h, smul_eq_mul, mul_assoc, h, smul_eq_mul]⟩\n#align is_scalar_tower.of_smul_one_mul IsScalarTower.of_smul_one_mul\n-/\n\n",
 "of_mul_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print SMulCommClass.of_mul_smul_one /-\n@[to_additive]\ntheorem SMulCommClass.of_mul_smul_one {M N} [monoid N] [SMul M N]\n    (H : ∀ (x : M) (y : N), y * «expr • » x (1 : N) = «expr • » x y) : SMulCommClass M N N :=\n  ⟨fun x y z => by rw [← H x z, smul_eq_mul, ← H, smul_eq_mul, mul_assoc]⟩\n#align smul_comm_class.of_mul_smul_one SMulCommClass.of_mul_smul_one\n-/\n\n",
 "ofMul_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print ofMul_vadd /-\n@[simp]\ntheorem ofMul_vadd [SMul α β] (a : α) (b : β) : «expr +ᵥ » (ofMul a) b = «expr • » a b :=\n  rfl\n#align of_mul_vadd ofMul_vadd\n-/\n\n",
 "ofAdd_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n#print ofAdd_smul /-\n@[simp]\ntheorem ofAdd_smul [VAdd α β] (a : α) (b : β) : «expr • » (ofAdd a) b = «expr +ᵥ » a b :=\n  rfl\n#align of_add_smul ofAdd_smul\n-/\n\n",
 "mul_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mul_smul_one /-\n@[simp, to_additive]\ntheorem mul_smul_one {M N} [mul_one_class N] [SMul M N] [SMulCommClass M N N] (x : M) (y : N) :\n    y * «expr • » x 1 = «expr • » x y := by rw [← smul_eq_mul, ← smul_comm, smul_eq_mul, mul_one]\n#align mul_smul_one mul_smul_one\n-/\n\n",
 "mul_smul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mul_smul_comm /-\n/-- Note that the `smul_comm_class α β β` typeclass argument is usually satisfied by `algebra α β`.\n-/\n@[to_additive, nolint to_additive_doc]\ntheorem mul_smul_comm [Mul β] [SMul α β] [SMulCommClass α β β] (s : α) (x y : β) :\n    x * «expr • » s y = «expr • » s (x * y) :=\n  (smul_comm s x y).symm\n#align mul_smul_comm mul_smul_comm\n-/\n\n",
 "ite_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print ite_smul /-\n@[to_additive]\ntheorem ite_smul (a₁ a₂ : M) (b : α) : «expr • » (ite p a₁ a₂) b = ite p («expr • » a₁ b) («expr • » a₂ b) := by\n  split_ifs <;> rfl\n#align ite_smul ite_smul\n-/\n\n",
 "is_scalar_tower":
 "-- these instances are very low priority, as there is usually a faster way to find these instances\n/-- Given a tower of scalar actions `M → α → β`, if we use `has_smul.comp`\nto pull back both of `M`'s actions by a map `g : N → M`, then we obtain a new\ntower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\nare still metavariables.\n-/\n@[to_additive\n      \"Given a tower of additive actions `M → α → β`, if we use\\n`has_smul.comp` to pull back both of `M`'s actions by a map `g : N → M`, then we obtain a new tower\\nof scalar actions `N → α → β`.\\n\\nThis cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\\nare still metavariables.\"]\ntheorem comp.is_scalar_tower [SMul M β] [SMul α β] [IsScalarTower M α β] (g : N → M) : by\n    haveI := comp α g <;> haveI := comp β g <;> exact IsScalarTower N α β :=\n  { smul_assoc := fun n => @smul_assoc _ _ _ _ _ _ _ (g n) }\n#align comp.is_scalar_tower comp.is_scalar_tower\n\n",
 "exists_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem exists_smul_eq (x y : α) : ∃ m : M, «expr • » m x = y :=\n  is_pretransitive.exists_smul_eq x y\n#align exists_smul_eq exists_smul_eq\n\n",
 "comp_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n#print comp_smul_left /-\n/-- `has_smul` version of `comp_mul_left` -/\n@[to_additive \"`has_vadd` version of `comp_add_left`\"]\ntheorem comp_smul_left (a₁ a₂ : M) : («expr • » · ·) a₁ ∘ («expr • » · ·) a₂ = ((«expr • » · ·) (a₁ * a₂) : α → α) :=\n  funext fun _ => (mul_smul _ _ _).symm\n#align comp_smul_left comp_smul_left\n-/\n\n"}