{"zpow_mem":
 "#print zpow_mem /-\n@[to_additive]\nprotected theorem zpow_mem {x : G} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K :=\n  zpow_mem hx\n#align zpow_mem zpow_mem\n#align zsmul_mem zsmul_mem\n-/\n\n",
 "top_to_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem top_to_submonoid : («expr⊤» : Subgroup G).to_submonoid = «expr⊤» :=\n  rfl\n#align top_to_submonoid top_to_submonoid\n\n",
 "top_subgroup_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem top_subgroup_of : («expr⊤» : Subgroup G).subgroup_of H = «expr⊤» :=\n  rfl\n#align top_subgroup_of top_subgroup_of\n\n",
 "top_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive top_prod_top]\ntheorem top_prod_top : («expr⊤» : Subgroup G).prod («expr⊤» : Subgroup N) = «expr⊤» :=\n  (top_prod _).trans <| comap_top _\n#align top_prod_top top_prod_top\n\n",
 "top_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive top_prod]\ntheorem top_prod (H : Subgroup N) : («expr⊤» : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n#align top_prod top_prod\n\n",
 "to_submonoid_strict_mono":
 "@[to_additive, mono]\ntheorem to_submonoid_strict_mono : StrictMono (toSubmonoid : Subgroup G → Submonoid G) := fun _ _ => id\n#align to_submonoid_strict_mono to_submonoid_strict_mono\n\n",
 "to_submonoid_mono":
 "@[to_additive, mono]\ntheorem to_submonoid_mono : Monotone (toSubmonoid : Subgroup G → Submonoid G) :=\n  toSubmonoid_strictMono.monotone\n#align to_submonoid_mono to_submonoid_mono\n\n",
 "to_submonoid_le":
 "@[simp, to_additive]\ntheorem to_submonoid_le {p q : Subgroup G} : p.to_submonoid ≤ q.to_submonoid ↔ p ≤ q :=\n  iff.rfl\n#align to_submonoid_le to_submonoid_le\n\n",
 "to_submonoid_injective":
 "@[to_additive]\ntheorem to_submonoid_injective : function.injective (toSubmonoid : Subgroup G → Submonoid G) := fun p q h =>\n  SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)\n#align to_submonoid_injective to_submonoid_injective\n\n",
 "to_submonoid_eq":
 "@[simp, to_additive]\ntheorem to_submonoid_eq {p q : Subgroup G} : p.to_submonoid = q.to_submonoid ↔ p = q :=\n  toSubmonoid_injective.eq_iff\n#align to_submonoid_eq to_submonoid_eq\n\n",
 "supr_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem supr_eq_closure {ι : Sort _} (p : ι → Subgroup G) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) =\n      closure\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (p i : Set G)) :=\n  by simp_rw [closure_unionᵢ, closure_eq]\n#align supr_eq_closure supr_eq_closure\n\n",
 "supr_comap_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem supr_comap_le {ι : Sort _} (f : «expr →* » G N) (s : ι → Subgroup N) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).comap f) ≤\n      (supᵢ s).comap f :=\n  Monotone.le_map_supᵢ fun _ _ => comap_mono\n#align supr_comap_le supr_comap_le\n\n",
 "sup_subgroup_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem sup_subgroup_of_eq {H K L : Subgroup G} (hH : H ≤ L) (hK : K ≤ L) :\n    «expr ⊔ » (H.subgroup_of L) (K.subgroup_of L) = («expr ⊔ » H K).subgroup_of L :=\n  comap_sup_eq_of_le_range L.subtype (hH.trans L.subtype_range.ge) (hK.trans L.subtype_range.ge)\n#align sup_subgroup_of_eq sup_subgroup_of_eq\n\n",
 "subtype_range":
 "#print Subgroup.subtype_range /-\n@[simp, to_additive]\ntheorem Subgroup.subtype_range (H : Subgroup G) : H.subtype.range = H :=\n  by\n  rw [range_eq_map, ← SetLike.coe_set_eq, coe_map, Subgroup.coeSubtype]\n  ext\n  simp\n#align subgroup.subtype_range Subgroup.subtype_range\n#align add_subgroup.subtype_range AddSubgroup.subtype_range\n-/\n\n",
 "subtype_injective":
 "@[to_additive]\ntheorem subtype_injective : injective (Subgroup.subtype H) :=\n  Subtype.coe_injective\n#align subtype_injective subtype_injective\n\n",
 "subtype_comp_range_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem subtype_comp_range_restrict (f : «expr →* » G N) : f.range.subtype.comp f.range_restrict = f :=\n  ext <| f.coe_range_restrict\n#align subtype_comp_range_restrict subtype_comp_range_restrict\n\n",
 "subtype_comp_inclusion":
 "@[simp, to_additive]\ntheorem subtype_comp_inclusion {H K : Subgroup G} (hH : H ≤ K) : K.subtype.comp (inclusion hH) = H.subtype :=\n  rfl\n#align subtype_comp_inclusion subtype_comp_inclusion\n\n",
 "subsingleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print subsingleton_iff /-\n@[simp, to_additive]\ntheorem subsingleton_iff : subsingleton (Subgroup G) ↔ subsingleton G :=\n  ⟨fun h =>\n    ⟨fun x y =>\n      have : ∀ i : G, i = 1 := fun i => mem_bot.mp <| subsingleton.elim («expr⊤» : Subgroup G) («expr⊥») ▸ mem_top i\n      (this x).trans (this y).symm⟩,\n    fun h => ⟨fun x y => Subgroup.ext fun i => subsingleton.elim 1 i ▸ by simp [Subgroup.one_mem]⟩⟩\n#align subsingleton_iff subsingleton_iff\n-/\n\n",
 "subset_normal_closure":
 "theorem subset_normal_closure : s ⊆ normalClosure s :=\n  Set.Subset.trans subset_conjugatesOfSet conjugatesOfSet_subset_normalClosure\n#align subset_normal_closure subset_normal_closure\n\n",
 "subset_conjugates_of_set":
 "theorem subset_conjugates_of_set : s ⊆ conjugatesOfSet s := fun (x : G) (h : x ∈ s) =>\n  mem_conjugatesOfSet_iff.2 ⟨x, h, IsConj.refl _⟩\n#align subset_conjugates_of_set subset_conjugates_of_set\n\n",
 "subset_closure":
 "#print subset_closure /-\n/-- The subgroup generated by a set includes the set. -/\n@[simp, to_additive \"The `add_subgroup` generated by a set includes the set.\"]\ntheorem subset_closure : k ⊆ closure k := fun x hx => mem_closure.2 fun K hK => hK hx\n#align subset_closure subset_closure\n-/\n\n",
 "subgroup_of_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem subgroup_of_sup (A A' B : Subgroup G) (hA : A ≤ B) (hA' : A' ≤ B) :\n    («expr ⊔ » A A').subgroup_of B = «expr ⊔ » (A.subgroup_of B) (A'.subgroup_of B) :=\n  by\n  refine' map_injective_of_ker_le B.subtype (ker_le_comap _ _) (le_trans (ker_le_comap B.subtype _) le_sup_left) _\n  · simp only [subgroup_of, map_comap_eq, map_sup, subtype_range]\n    rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]\n#align subgroup_of_sup subgroup_of_sup\n\n",
 "subgroup_of_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem subgroup_of_self : H.subgroup_of H = «expr⊤» :=\n  top_unique fun g hg => g.2\n#align subgroup_of_self subgroup_of_self\n\n",
 "subgroup_of_range_eq_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem subgroup_of_range_eq_of_le {G₁ G₂ : Type _} [Group G₁] [Group G₂] {K : Subgroup G₂} (f : «expr →* » G₁ G₂)\n    (h : f.range ≤ K) : f.range.subgroup_of K = (f.cod_restrict K fun x => h ⟨x, rfl⟩).range :=\n  by\n  ext k\n  refine' exists_congr _\n  simp [Subtype.ext_iff]\n#align subgroup_of_range_eq_of_le subgroup_of_range_eq_of_le\n\n",
 "subgroup_of_normalizer_eq":
 "@[to_additive]\ntheorem subgroup_of_normalizer_eq {H N : Subgroup G} (h : H.normalizer ≤ N) :\n    H.normalizer.subgroup_of N = (H.subgroup_of N).normalizer :=\n  by\n  apply comap_normalizer_eq_of_injective_of_le_range\n  exact Subtype.coe_injective\n  simpa\n#align subgroup_of_normalizer_eq subgroup_of_normalizer_eq\n\n",
 "subgroup_of_map_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem subgroup_of_map_subtype (H K : Subgroup G) : (H.subgroup_of K).map K.subtype = «expr ⊓ » H K :=\n  SetLike.ext' <| Subtype.image_preimage_coe _ _\n#align subgroup_of_map_subtype subgroup_of_map_subtype\n\n",
 "subgroup_of_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem subgroup_of_inj {H₁ H₂ K : Subgroup G} :\n    H₁.subgroup_of K = H₂.subgroup_of K ↔ «expr ⊓ » H₁ K = «expr ⊓ » H₂ K := by\n  simpa only [SetLike.ext_iff, mem_inf, mem_subgroup_of, and_congr_left_iff] using Subtype.forall\n#align subgroup_of_inj subgroup_of_inj\n\n",
 "subgroup_of_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem subgroup_of_eq_top {H K : Subgroup G} : H.subgroup_of K = «expr⊤» ↔ K ≤ H := by\n  rw [← top_subgroup_of, subgroup_of_inj, top_inf_eq, inf_eq_right]\n#align subgroup_of_eq_top subgroup_of_eq_top\n\n",
 "subgroup_of_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem subgroup_of_eq_bot {H K : Subgroup G} : H.subgroup_of K = «expr⊥» ↔ Disjoint H K := by\n  rw [disjoint_iff, ← bot_subgroup_of, subgroup_of_inj, bot_inf_eq]\n#align subgroup_of_eq_bot subgroup_of_eq_bot\n\n",
 "subgroup_of_bot_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem subgroup_of_bot_eq_top : H.subgroup_of («expr⊥») = «expr⊤» :=\n  subsingleton.elim _ _\n#align subgroup_of_bot_eq_top subgroup_of_bot_eq_top\n\n",
 "subgroup_of_bot_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem subgroup_of_bot_eq_bot : H.subgroup_of («expr⊥») = «expr⊥» :=\n  subsingleton.elim _ _\n#align subgroup_of_bot_eq_bot subgroup_of_bot_eq_bot\n\n",
 "subgroup_map_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem subgroup_map_symm_apply (e : «expr ≃* » G G') (H : Subgroup G) (g : H.map (e : «expr →* » G G')) :\n    (e.subgroup_map H).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=\n  rfl\n#align subgroup_map_symm_apply subgroup_map_symm_apply\n\n",
 "subgroup_map_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem subgroup_map_surjective (f : «expr →* » G G') (H : Subgroup G) : function.surjective (f.subgroup_map H) :=\n  f.submonoid_map_surjective H.to_submonoid\n#align subgroup_map_surjective subgroup_map_surjective\n\n",
 "subgroupOf":
 "#print Subgroup.Normal.subgroupOf /-\n-- Here `H.normal` is an explicit argument so we can use dot notation with `subgroup_of`.\n@[to_additive]\ntheorem Subgroup.Normal.subgroupOf {H : Subgroup G} (hH : H.normal) (K : Subgroup G) : (H.subgroup_of K).normal :=\n  hH.comap _\n#align subgroup.normal.subgroup_of Subgroup.Normal.subgroupOf\n#align add_subgroup.normal.add_subgroup_of AddSubgroup.Normal.addSubgroupOf\n-/\n\n",
 "restrict_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem restrict_range (f : «expr →* » G N) : (f.restrict K).range = K.map f := by\n  simp_rw [SetLike.ext_iff, mem_range, mem_map, restrict_apply, SetLike.exists, Subtype.coe_mk, iff_self_iff,\n    forall_const]\n#align restrict_range restrict_range\n\n",
 "range_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/\n@[to_additive \"The range of a surjective `add_monoid` homomorphism is the whole of the codomain.\"]\ntheorem range_top_of_surjective {N} [Group N] (f : «expr →* » G N) (hf : function.surjective f) :\n    f.range = («expr⊤» : Subgroup N) :=\n  range_top_iff_surjective.2 hf\n#align range_top_of_surjective range_top_of_surjective\n\n",
 "range_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem range_top_iff_surjective {N} [Group N] {f : «expr →* » G N} :\n    f.range = («expr⊤» : Subgroup N) ↔ function.surjective f :=\n  SetLike.ext'_iff.trans <| iff.trans (by rw [coe_range, coe_top]) Set.range_iff_surjective\n#align range_top_iff_surjective range_top_iff_surjective\n\n",
 "range_restrict_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem range_restrict_surjective (f : «expr →* » G N) : function.surjective f.range_restrict := fun ⟨_, g, rfl⟩ =>\n  ⟨g, rfl⟩\n#align range_restrict_surjective range_restrict_surjective\n\n",
 "range_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem range_one : (1 : «expr →* » G N).range = «expr⊥» :=\n  SetLike.ext fun x => by simpa using @comm _ (· = ·) _ 1 x\n#align range_one range_one\n\n",
 "range_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem range_eq_map (f : «expr →* » G N) : f.range = («expr⊤» : Subgroup G).map f := by ext <;> simp\n#align range_eq_map range_eq_map\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive prod_top]\ntheorem prod_top (K : Subgroup G) : K.prod («expr⊤» : Subgroup N) = K.comap (MonoidHom.fst G N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n#align prod_top prod_top\n\n",
 "prod_mono_right":
 "@[to_additive prod_mono_right]\ntheorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.prod t :=\n  prod_mono (le_refl K)\n#align prod_mono_right prod_mono_right\n\n",
 "prod_mono_left":
 "@[to_additive prod_mono_left]\ntheorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.prod H := fun s₁ s₂ hs =>\n  prod_mono hs (le_refl H)\n#align prod_mono_left prod_mono_left\n\n",
 "prod_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n@[to_additive prod_mono]\ntheorem prod_mono : («expr ⇒ » (· ≤ ·) («expr ⇒ » (· ≤ ·) (· ≤ ·))) (@prod G _ N _) (@prod G _ N _) :=\n  fun s s' hs t t' ht => Set.prod_mono hs ht\n#align prod_mono prod_mono\n\n",
 "prod_map_comap_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem prod_map_comap_prod {G' : Type _} {N' : Type _} [Group G'] [Group N'] (f : «expr →* » G N)\n    (g : «expr →* » G' N') (S : Subgroup N) (S' : Subgroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n#align prod_map_comap_prod prod_map_comap_prod\n\n",
 "prod_le_iff":
 "@[to_additive prod_le_iff]\ntheorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :\n    H.prod K ≤ J ↔ map (MonoidHom.inl G N) H ≤ J ∧ map (MonoidHom.inr G N) K ≤ J := by\n  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.prod_le_iff\n#align prod_le_iff prod_le_iff\n\n",
 "prod_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.prod K = «expr⊥» ↔ H = «expr⊥» ∧ K = «expr⊥» := by\n  simpa only [← Subgroup.toSubmonoid_eq] using Submonoid.prod_eq_bot_iff\n#align prod_eq_bot_iff prod_eq_bot_iff\n\n",
 "pow_mem":
 "#print pow_mem /-\n@[to_additive AddSubgroup.nsmul_mem]\nprotected theorem pow_mem {x : G} (hx : x ∈ K) : ∀ n : ℕ, x ^ n ∈ K :=\n  pow_mem hx\n#align pow_mem pow_mem\n#align nsmul_mem nsmul_mem\n-/\n\n",
 "pi_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem pi_top (I : Set η) : (pi I fun i => («expr⊤» : Subgroup (f i))) = «expr⊤» :=\n  ext fun x => by simp [mem_pi]\n#align pi_top pi_top\n\n",
 "pi_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem pi_eq_bot_iff (H : ∀ i, Subgroup (f i)) : pi Set.univ H = «expr⊥» ↔ ∀ i, H i = «expr⊥» := by\n  classical\n    simp only [eq_bot_iff_forall]\n    constructor\n    · intro h i x hx\n      have : MonoidHom.single f i x = 1 := h (MonoidHom.single f i x) ((mul_single_mem_pi i x).mpr fun _ => hx)\n      simpa using congr_fun this i\n    · exact fun h x hx => funext fun i => h _ _ (hx i trivial)\n#align pi_eq_bot_iff pi_eq_bot_iff\n\n",
 "pi_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem pi_empty (H : ∀ i, Subgroup (f i)) : pi ∅ H = «expr⊤» :=\n  ext fun x => by simp [mem_pi]\n#align pi_empty pi_empty\n\n",
 "pi_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem pi_bot : (pi Set.univ fun i => («expr⊥» : Subgroup (f i))) = «expr⊥» :=\n  (eq_bot_iff_forall _).mpr fun p hp => by\n    simp only [mem_pi, mem_bot] at *\n    ext j\n    exact hp j trivial\n#align pi_bot pi_bot\n\n",
 "one_mem":
 "/-- A subgroup contains the group's 1. -/\n@[to_additive \"An `add_subgroup` contains the group's 0.\"]\nprotected theorem one_mem : (1 : G) ∈ H :=\n  one_mem _\n#align one_mem one_mem\n\n",
 "of_left_inverse_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem of_left_inverse_symm_apply {f : «expr →* » G N} {g : «expr →* » N G} (h : function.left_inverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x :=\n  rfl\n#align of_left_inverse_symm_apply of_left_inverse_symm_apply\n\n",
 "of_left_inverse_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem of_left_inverse_apply {f : «expr →* » G N} {g : «expr →* » N G} (h : function.left_inverse g f) (x : G) :\n    ↑(ofLeftInverse h x) = f x :=\n  rfl\n#align of_left_inverse_apply of_left_inverse_apply\n\n",
 "of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem of_injective_apply {f : «expr →* » G N} (hf : function.injective f) {x : G} : ↑(ofInjective hf x) = f x :=\n  rfl\n#align of_injective_apply of_injective_apply\n\n",
 "not_mem_of_not_mem_closure":
 "#print not_mem_of_not_mem_closure /-\n@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : G} (hP : P ∉ closure k) : P ∉ k := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n-/\n\n",
 "normalizer_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem normalizer_eq_top : H.normalizer = «expr⊤» ↔ H.normal :=\n  eq_top_iff.trans\n    ⟨fun h => ⟨fun a ha b => (h (mem_top b) a).mp ha⟩, fun h a ha b =>\n      ⟨fun hb => h.conj_mem b hb a, fun hb => by rwa [h.mem_comm_iff, inv_mul_cancel_left] at hb⟩⟩\n#align normalizer_eq_top normalizer_eq_top\n\n",
 "normalizer_condition_iff_only_full_group_self_normalizing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print normalizerCondition_iff_only_full_group_self_normalizing /-\n/-- Alternative phrasing of the normalizer condition: Only the full group is self-normalizing.\nThis may be easier to work with, as it avoids inequalities and negations.  -/\ntheorem normalizerCondition_iff_only_full_group_self_normalizing :\n    NormalizerCondition G ↔ ∀ H : Subgroup G, H.normalizer = H → H = «expr⊤» :=\n  by\n  apply forall_congr'; intro H\n  simp only [lt_iff_le_and_ne, le_normalizer, true_and_iff, le_top, ne.def]\n  tauto\n#align normalizer_condition_iff_only_full_group_self_normalizing normalizerCondition_iff_only_full_group_self_normalizing\n-/\n\n",
 "normal_subgroup_of_iff":
 "@[to_additive]\ntheorem normal_subgroup_of_iff {H K : Subgroup G} (hHK : H ≤ K) :\n    (H.subgroup_of K).normal ↔ ∀ h k, h ∈ H → k ∈ K → k * h * k⁻¹ ∈ H :=\n  ⟨fun hN h k hH hK => hN.conj_mem ⟨h, hHK hH⟩ hH ⟨k, hK⟩, fun hN => { conj_mem := fun h hm k => hN h.1 k.1 hm k.2 }⟩\n#align normal_subgroup_of_iff normal_subgroup_of_iff\n\n",
 "normal_of_coatom":
 "/-- In a group that satisifes the normalizer condition, every maximal subgroup is normal -/\ntheorem normalizer_condition.normal_of_coatom (hnc : NormalizerCondition G) (hmax : IsCoatom H) : H.normal :=\n  normalizer_eq_top.mp (hmax.2 _ (hnc H (lt_top_iff_ne_top.mpr hmax.1)))\n#align normalizer_condition.normal_of_coatom normalizer_condition.normal_of_coatom\n\n",
 "normal_le_normal_core":
 "theorem normal_le_normal_core {H : Subgroup G} {N : Subgroup G} [hN : N.normal] : N ≤ H.normal_core ↔ N ≤ H :=\n  ⟨ge_trans H.normal_core_le, fun h_le n hn g => h_le (hN.conj_mem n hn g)⟩\n#align normal_le_normal_core normal_le_normal_core\n\n",
 "normal_core_mono":
 "theorem normal_core_mono {H K : Subgroup G} (h : H ≤ K) : H.normal_core ≤ K.normal_core :=\n  normal_le_normalCore.mpr (H.normal_core_le.trans h)\n#align normal_core_mono normal_core_mono\n\n",
 "normal_core_le":
 "theorem normal_core_le (H : Subgroup G) : H.normal_core ≤ H := fun a h =>\n  by\n  rw [← mul_one a, ← inv_one, ← one_mul a]\n  exact h 1\n#align normal_core_le normal_core_le\n\n",
 "normal_core_idempotent":
 "@[simp]\ntheorem normal_core_idempotent (H : Subgroup G) : H.normal_core.normal_core = H.normal_core :=\n  H.normal_core.normal_core_eq_self\n#align normal_core_idempotent normal_core_idempotent\n\n",
 "normal_core_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem normal_core_eq_supr (H : Subgroup G) :\n    H.normal_core = «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" N :=\n  le_antisymm (le_supᵢ_of_le H.normal_core (le_supᵢ_of_le H.normal_core_normal (le_supᵢ_of_le H.normal_core_le le_rfl)))\n    (supᵢ_le fun N => supᵢ_le fun hN => supᵢ_le normal_le_normal_core.mpr)\n#align normal_core_eq_supr normal_core_eq_supr\n\n",
 "normal_core_eq_self":
 "@[simp]\ntheorem normal_core_eq_self (H : Subgroup G) [H.normal] : H.normal_core = H :=\n  le_antisymm H.normal_core_le (normal_le_normalCore.mpr le_rfl)\n#align normal_core_eq_self normal_core_eq_self\n\n",
 "normal_closure_subset_iff":
 "theorem normal_closure_subset_iff {N : Subgroup G} [N.normal] : s ⊆ N ↔ normalClosure s ≤ N :=\n  ⟨normalClosure_le_normal, Set.Subset.trans subset_normalClosure⟩\n#align normal_closure_subset_iff normal_closure_subset_iff\n\n",
 "normal_closure_mono":
 "theorem normal_closure_mono {s t : Set G} (h : s ⊆ t) : normalClosure s ≤ normalClosure t :=\n  normalClosure_le_normal (Set.Subset.trans h subset_normalClosure)\n#align normal_closure_mono normal_closure_mono\n\n",
 "normal_closure_le_normal":
 "/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/\ntheorem normal_closure_le_normal {N : Subgroup G} [N.normal] (h : s ⊆ N) : normalClosure s ≤ N :=\n  by\n  intro a w\n  refine' closure_induction w (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _\n  · exact conjugates_of_set_subset h hx\n  · exact one_mem _\n  · exact mul_mem ihx ihy\n  · exact inv_mem ihx\n#align normal_closure_le_normal normal_closure_le_normal\n\n",
 "normal_closure_idempotent":
 "@[simp]\ntheorem normal_closure_idempotent : normalClosure ↑(normalClosure s) = normalClosure s :=\n  normalClosure_eq_self _\n#align normal_closure_idempotent normal_closure_idempotent\n\n",
 "normal_closure_eq_top_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem normal_closure_eq_top_of {N : Subgroup G} [hn : N.normal] {g g' : G} {hg : g ∈ N} {hg' : g' ∈ N}\n    (hc : IsConj g g') (ht : normalClosure ({⟨g, hg⟩} : Set N) = «expr⊤») :\n    normalClosure ({⟨g', hg'⟩} : Set N) = «expr⊤» :=\n  by\n  obtain ⟨c, rfl⟩ := isConj_iff.1 hc\n  have h : ∀ x : N, (MulAut.conj c) x ∈ N := by\n    rintro ⟨x, hx⟩\n    exact hn.conj_mem _ hx c\n  have hs : function.surjective (((MulAut.conj c).to_monoid_hom.restrict N).cod_restrict _ h) :=\n    by\n    rintro ⟨x, hx⟩\n    refine' ⟨⟨c⁻¹ * x * c, _⟩, _⟩\n    · have h := hn.conj_mem _ hx c⁻¹\n      rwa [inv_inv] at h\n    simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,\n      MonoidHom.restrict_apply, Subtype.mk_eq_mk, ← mul_assoc, mul_inv_self, one_mul]\n    rw [mul_assoc, mul_inv_self, mul_one]\n  have ht' := map_mono (eq_top_iff.1 ht)\n  rw [← MonoidHom.range_eq_map, MonoidHom.range_top_of_surjective _ hs] at ht'\n  refine' eq_top_iff.2 (le_trans ht' (map_le_iff_le_comap.2 (normal_closure_le_normal _)))\n  rw [Set.singleton_subset_iff, SetLike.mem_coe]\n  simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk, MonoidHom.restrict_apply,\n    mem_comap]\n  exact subset_normal_closure (Set.mem_singleton _)\n#align normal_closure_eq_top_of normal_closure_eq_top_of\n\n",
 "normal_closure_eq_self":
 "@[simp]\ntheorem normal_closure_eq_self (H : Subgroup G) [H.normal] : normalClosure ↑H = H :=\n  le_antisymm (normalClosure_le_normal rfl.subset) le_normalClosure\n#align normal_closure_eq_self normal_closure_eq_self\n\n",
 "normal_closure_eq_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem normal_closure_eq_infi :\n    normalClosure s =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" N :=\n  le_antisymm (le_infᵢ fun N => le_infᵢ fun hN => le_infᵢ normal_closure_le_normal)\n    (infᵢ_le_of_le (normalClosure s) (infᵢ_le_of_le (by infer_instance) (infᵢ_le_of_le subset_normalClosure le_rfl)))\n#align normal_closure_eq_infi normal_closure_eq_infi\n\n",
 "normal_closure_closure_eq_normal_closure":
 "@[simp]\ntheorem normal_closure_closure_eq_normal_closure {s : Set G} : normalClosure ↑(closure s) = normalClosure s :=\n  le_antisymm (normalClosure_le_normal closure_le_normalClosure) (normalClosure_mono subset_closure)\n#align normal_closure_closure_eq_normal_closure normal_closure_closure_eq_normal_closure\n\n",
 "nontrivial_iff_exists_ne_one":
 "@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H ↔ ∃ x ∈ H, x ≠ (1 : G) :=\n  Subtype.nontrivial_iff_exists_ne (fun x => x ∈ H) (1 : H)\n#align nontrivial_iff_exists_ne_one nontrivial_iff_exists_ne_one\n\n",
 "nontrivial_iff":
 "#print nontrivial_iff /-\n@[simp, to_additive]\ntheorem nontrivial_iff : Nontrivial (Subgroup G) ↔ Nontrivial G :=\n  not_iff_not.mp ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans not_nontrivial_iff_subsingleton.symm)\n#align nontrivial_iff nontrivial_iff\n-/\n\n",
 "mul_single_mem_pi":
 "@[simp, to_additive]\ntheorem mul_single_mem_pi [DecidableEq η] {I : Set η} {H : ∀ i, Subgroup (f i)} (i : η) (x : f i) :\n    Pi.mulSingle i x ∈ pi I H ↔ i ∈ I → x ∈ H i := by\n  constructor\n  · intro h hi\n    simpa using h i hi\n  · intro h j hj\n    by_cases heq : j = i\n    · subst HEq\n      simpa using h hj\n    · simp [HEq, one_mem]\n#align mul_single_mem_pi mul_single_mem_pi\n\n",
 "mul_mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ «expr ⊔ » S T :=\n  («expr ⊔ » S T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n#align mul_mem_sup mul_mem_sup\n\n",
 "mul_mem_cancel_right":
 "#print mul_mem_cancel_right /-\n@[to_additive]\nprotected theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=\n  mul_mem_cancel_right h\n#align mul_mem_cancel_right mul_mem_cancel_right\n#align add_mem_cancel_right add_mem_cancel_right\n-/\n\n",
 "mul_mem_cancel_left":
 "#print mul_mem_cancel_left /-\n@[to_additive]\nprotected theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=\n  mul_mem_cancel_left h\n#align mul_mem_cancel_left mul_mem_cancel_left\n#align add_mem_cancel_left add_mem_cancel_left\n-/\n\n",
 "mul_mem":
 "/-- A subgroup is closed under multiplication. -/\n@[to_additive \"An `add_subgroup` is closed under addition.\"]\nprotected theorem mul_mem {x y : G} : x ∈ H → y ∈ H → x * y ∈ H :=\n  mul_mem\n#align mul_mem mul_mem\n\n",
 "mul_injective_of_disjoint":
 "@[to_additive]\ntheorem mul_injective_of_disjoint {H₁ H₂ : Subgroup G} (h : Disjoint H₁ H₂) :\n    function.injective (fun g => g.1 * g.2 : H₁ × H₂ → G) :=\n  by\n  intro x y hxy\n  rw [← inv_mul_eq_iff_eq_mul, ← mul_assoc, ← mul_inv_eq_one, mul_assoc] at hxy\n  replace hxy := disjoint_iff_mul_eq_one.mp h (y.1⁻¹ * x.1).prop (x.2 * y.2⁻¹).prop hxy\n  rwa [coe_mul, coe_mul, coe_inv, coe_inv, inv_mul_eq_one, mul_inv_eq_one, ← Subtype.ext_iff, ← Subtype.ext_iff,\n    eq_comm, ← Prod.ext_iff] at hxy\n#align mul_injective_of_disjoint mul_injective_of_disjoint\n\n",
 "mk_le_mk":
 "@[simp, to_additive]\ntheorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :\n    mk s h_one h_mul h_inv ≤ mk t h_one' h_mul' h_inv' ↔ s ⊆ t :=\n  iff.rfl\n#align mk_le_mk mk_le_mk\n\n",
 "mk_eq_one_iff":
 "@[simp, to_additive]\ntheorem mk_eq_one_iff {g : G} {h} : (⟨g, h⟩ : H) = 1 ↔ g = 1 :=\n  show (⟨g, h⟩ : H) = (⟨1, H.one_mem⟩ : H) ↔ g = 1 by simp\n#align mk_eq_one_iff mk_eq_one_iff\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mem_top (x : G) : x ∈ («expr⊤» : Subgroup G) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_submonoid":
 "@[simp, to_additive]\ntheorem mem_to_submonoid (K : Subgroup G) (x : G) : x ∈ K.to_submonoid ↔ x ∈ K :=\n  iff.rfl\n#align mem_to_submonoid mem_to_submonoid\n\n",
 "mem_supr_of_mem":
 "@[to_additive]\ntheorem mem_supr_of_mem {ι : Sort _} {S : ι → Subgroup G} (i : ι) : ∀ {x : G}, x ∈ S i → x ∈ supᵢ S :=\n  show S i ≤ supᵢ S from le_supᵢ _ _\n#align mem_supr_of_mem mem_supr_of_mem\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem mem_supr_of_directed {ι} [hι : Nonempty ι] {K : ι → Subgroup G} (hK : Directed (· ≤ ·) K) {x : G} :\n    x ∈ (supᵢ K : Subgroup G) ↔ ∃ i, x ∈ K i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ K i) hi⟩\n  suffices\n    x ∈\n        closure\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (K i : Set G)) →\n      ∃ i, x ∈ K i\n    by simpa only [closure_unionᵢ, closure_eq (K _)] using this\n  refine' fun hx => closure_induction hx (fun _ => mem_Union.1) _ _ _\n  · exact hι.elim fun i => ⟨i, (K i).one_mem⟩\n  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hK i j with ⟨k, hki, hkj⟩\n    exact ⟨k, mul_mem (hki hi) (hkj hj)⟩\n  rintro _ ⟨i, hi⟩\n  exact ⟨i, inv_mem hi⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup_right {S T : Subgroup G} : ∀ {x : G}, x ∈ T → x ∈ «expr ⊔ » S T :=\n  show T ≤ «expr ⊔ » S T from le_sup_right\n#align mem_sup_right mem_sup_right\n\n",
 "mem_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup_left {S T : Subgroup G} : ∀ {x : G}, x ∈ S → x ∈ «expr ⊔ » S T :=\n  show S ≤ «expr ⊔ » S T from le_sup_left\n#align mem_sup_left mem_sup_left\n\n",
 "mem_sup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup' : x ∈ «expr ⊔ » s t ↔ ∃ (y : s)(z : t), (y : C) * z = x :=\n  mem_sup.trans <| by simp only [SetLike.exists, coe_mk]\n#align mem_sup' mem_sup'\n\n",
 "mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup : x ∈ «expr ⊔ » s t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x :=\n  ⟨fun h => by\n    rw [← closure_eq s, ← closure_eq t, ← closure_union] at h\n    apply closure_induction h\n    · rintro y (h | h)\n      · exact ⟨y, h, 1, t.one_mem, by simp⟩\n      · exact ⟨1, s.one_mem, y, h, by simp⟩\n    · exact ⟨1, s.one_mem, 1, ⟨t.one_mem, mul_one 1⟩⟩\n    · rintro _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩\n      exact ⟨_, mul_mem hy₁ hy₂, _, mul_mem hz₁ hz₂, by simp [mul_assoc] <;> cc⟩\n    · rintro _ ⟨y, hy, z, hz, rfl⟩\n      exact ⟨_, inv_mem hy, _, inv_mem hz, mul_comm z y ▸ (mul_inv_rev z y).symm⟩, by\n    rintro ⟨y, hy, z, hz, rfl⟩ <;> exact mul_mem_sup hy hz⟩\n#align mem_sup mem_sup\n\n",
 "mem_subgroup_of":
 "@[to_additive]\ntheorem mem_subgroup_of {H K : Subgroup G} {h : K} : h ∈ H.subgroup_of K ↔ (h : G) ∈ H :=\n  iff.rfl\n#align mem_subgroup_of mem_subgroup_of\n\n",
 "mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem mem_range {f : «expr →* » G N} {y : N} : y ∈ f.range ↔ ∃ x, f x = y :=\n  iff.rfl\n#align mem_range mem_range\n\n",
 "mem_prod":
 "@[to_additive mem_prod]\ntheorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G × N} : p ∈ H.prod K ↔ p.1 ∈ H ∧ p.2 ∈ K :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "mem_pi":
 "@[to_additive]\ntheorem mem_pi (I : Set η) {H : ∀ i, Subgroup (f i)} {p : ∀ i, f i} : p ∈ pi I H ↔ ∀ i : η, i ∈ I → p i ∈ H i :=\n  iff.rfl\n#align mem_pi mem_pi\n\n",
 "mem_normalizer_iff''":
 "@[to_additive]\ntheorem mem_normalizer_iff'' {g : G} : g ∈ H.normalizer ↔ ∀ h : G, h ∈ H ↔ g⁻¹ * h * g ∈ H := by\n  rw [← inv_mem_iff, mem_normalizer_iff, inv_inv]\n#align mem_normalizer_iff'' mem_normalizer_iff''\n\n",
 "mem_normalizer_iff'":
 "@[to_additive]\ntheorem mem_normalizer_iff' {g : G} : g ∈ H.normalizer ↔ ∀ n, n * g ∈ H ↔ g * n ∈ H :=\n  ⟨fun h n => by rw [h, mul_assoc, mul_inv_cancel_right], fun h n => by rw [mul_assoc, ← h, inv_mul_cancel_right]⟩\n#align mem_normalizer_iff' mem_normalizer_iff'\n\n",
 "mem_normalizer_iff":
 "-- variant for sets.\n-- TODO should this replace `normalizer`?\n@[to_additive]\ntheorem mem_normalizer_iff {g : G} : g ∈ H.normalizer ↔ ∀ h, h ∈ H ↔ g * h * g⁻¹ ∈ H :=\n  iff.rfl\n#align mem_normalizer_iff mem_normalizer_iff\n\n",
 "mem_mk":
 "@[simp, to_additive]\ntheorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) : x ∈ mk s h_one h_mul h_inv ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_map_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem mem_map_of_mem (f : «expr →* » G N) {K : Subgroup G} {x : G} (hx : x ∈ K) : f x ∈ K.map f :=\n  mem_image_of_mem f hx\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem mem_map_iff_mem {f : «expr →* » G N} (hf : function.injective f) {K : Subgroup G} {x : G} :\n    f x ∈ K.map f ↔ x ∈ K :=\n  hf.mem_set_image\n#align mem_map_iff_mem mem_map_iff_mem\n\n",
 "mem_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem mem_map_equiv {f : «expr ≃* » G N} {K : Subgroup G} {x : N} : x ∈ K.map f.to_monoid_hom ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (↑K) f.to_equiv x\n#align mem_map_equiv mem_map_equiv\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem mem_map {f : «expr →* » G N} {K : Subgroup G} {y : N} : y ∈ K.map f ↔ ∃ x ∈ K, f x = y :=\n  mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem mem_ker (f : «expr →* » G M) {x : G} : x ∈ f.ker ↔ f x = 1 :=\n  iff.rfl\n#align mem_ker mem_ker\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem mem_infi {ι : Sort _} {S : ι → Subgroup G} {x : G} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem mem_inf {p p' : Subgroup G} {x : G} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_conjugates_of_set_iff":
 "theorem mem_conjugates_of_set_iff {x : G} : x ∈ conjugatesOfSet s ↔ ∃ a ∈ s, IsConj a x :=\n  Set.mem_unionᵢ₂\n#align mem_conjugates_of_set_iff mem_conjugates_of_set_iff\n\n",
 "mem_comm_iff":
 "@[to_additive]\ntheorem mem_comm_iff {a b : G} : a * b ∈ H ↔ b * a ∈ H :=\n  ⟨nH.mem_comm, nH.mem_comm⟩\n#align mem_comm_iff mem_comm_iff\n\n",
 "mem_comm":
 "@[to_additive]\ntheorem subgroup_normal.mem_comm {H K : Subgroup G} (hK : H ≤ K) [hN : (H.subgroup_of K).normal] {a b : G} (hb : b ∈ K)\n    (h : a * b ∈ H) : b * a ∈ H :=\n  by\n  have := (normal_subgroup_of_iff hK).mp hN (a * b) b h hb\n  rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at this\n#align subgroup_normal.mem_comm subgroup_normal.mem_comm\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem mem_comap {K : Subgroup N} {f : «expr →* » G N} {x : G} : x ∈ K.comap f ↔ f x ∈ K :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_closure_singleton":
 "/-- The subgroup generated by an element of a group equals the set of integer number powers of\n    the element. -/\n@[to_additive\n      \"The `add_subgroup` generated by an element of an `add_group` equals the set of\\nnatural number multiples of the element.\"]\ntheorem mem_closure_singleton {x y : G} : y ∈ closure ({x} : Set G) ↔ ∃ n : ℤ, x ^ n = y :=\n  by\n  refine' ⟨fun hy => closure_induction hy _ _ _ _, fun ⟨n, hn⟩ => hn ▸ zpow_mem (subset_closure <| mem_singleton x) n⟩\n  · intro y hy\n    rw [eq_of_mem_singleton hy]\n    exact ⟨1, zpow_one x⟩\n  · exact ⟨0, zpow_zero x⟩\n  · rintro _ _ ⟨n, rfl⟩ ⟨m, rfl⟩\n    exact ⟨n + m, zpow_add x n m⟩\n  rintro _ ⟨n, rfl⟩\n  exact ⟨-n, zpow_neg x n⟩\n#align mem_closure_singleton mem_closure_singleton\n\n",
 "mem_closure_pair":
 "@[to_additive]\ntheorem mem_closure_pair {x y z : C} : z ∈ closure ({x, y} : Set C) ↔ ∃ m n : ℤ, x ^ m * y ^ n = z :=\n  by\n  rw [← Set.singleton_union, Subgroup.closure_union, mem_sup]\n  simp_rw [exists_prop, mem_closure_singleton, exists_exists_eq_and]\n#align mem_closure_pair mem_closure_pair\n\n",
 "mem_closure":
 "@[to_additive]\ntheorem mem_closure {x : G} : x ∈ closure k ↔ ∀ K : Subgroup G, k ⊆ K → x ∈ K :=\n  mem_infₛ\n#align mem_closure mem_closure\n\n",
 "mem_centralizer_iff_commutator_eq_one":
 "@[to_additive]\ntheorem mem_centralizer_iff_commutator_eq_one {g : G} : g ∈ H.centralizer ↔ ∀ h ∈ H, h * g * h⁻¹ * g⁻¹ = 1 := by\n  simp only [mem_centralizer_iff, mul_inv_eq_iff_eq_mul, one_mul]\n#align mem_centralizer_iff_commutator_eq_one mem_centralizer_iff_commutator_eq_one\n\n",
 "mem_centralizer_iff":
 "@[to_additive]\ntheorem mem_centralizer_iff {g : G} : g ∈ H.centralizer ↔ ∀ h ∈ H, h * g = g * h :=\n  iff.rfl\n#align mem_centralizer_iff mem_centralizer_iff\n\n",
 "mem_center_iff":
 "@[to_additive]\ntheorem mem_center_iff {z : G} : z ∈ center G ↔ ∀ g, g * z = z * g :=\n  iff.rfl\n#align mem_center_iff mem_center_iff\n\n",
 "mem_carrier":
 "@[simp, to_additive]\ntheorem mem_carrier {s : Subgroup G} {x : G} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem mem_bot {x : G} : x ∈ («expr⊥» : Subgroup G) ↔ x = 1 :=\n  iff.rfl\n#align mem_bot mem_bot\n\n",
 "mem_Sup_of_mem":
 "@[to_additive]\ntheorem mem_Sup_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s ∈ S) : ∀ {x : G}, x ∈ s → x ∈ supₛ S :=\n  show s ≤ supₛ S from le_supₛ hs\n#align mem_Sup_of_mem mem_Sup_of_mem\n\n",
 "mem_Sup_of_directed_on":
 "@[to_additive]\ntheorem mem_Sup_of_directed_on {K : Set (Subgroup G)} (Kne : K.nonempty) (hK : DirectedOn (· ≤ ·) K) {x : G} :\n    x ∈ supₛ K ↔ ∃ s ∈ K, x ∈ s := by\n  haveI : Nonempty K := Kne.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hK.directed_coe, SetCoe.exists, Subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "mem_Inf":
 "@[simp, to_additive]\ntheorem mem_Inf {S : Set (Subgroup G)} {x : G} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "map_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem map_top_of_surjective (f : «expr →* » G N) (h : function.surjective f) : Subgroup.map f («expr⊤») = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro x hx\n  obtain ⟨y, hy⟩ := h x\n  exact ⟨y, trivial, hy⟩\n#align map_top_of_surjective map_top_of_surjective\n\n",
 "map_symm_eq_iff_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : «expr ≃* » G N} : H.map ↑e.symm = K ↔ K.map ↑e = H :=\n  by\n  constructor <;> rintro rfl\n  · rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self, MulEquiv.coe_monoidHom_refl, map_id]\n  · rw [map_map, ← MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm, MulEquiv.coe_monoidHom_refl, map_id]\n#align map_symm_eq_iff_map_eq map_symm_eq_iff_map_eq\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\n@[to_additive]\ntheorem map_supᵢ {ι : Sort _} (f : «expr →* » G N) (s : ι → Subgroup G) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem map_sup (H K : Subgroup G) (f : «expr →* » G N) : («expr ⊔ » H K).map f = «expr ⊔ » (H.map f) (K.map f) :=\n  (gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_subtype_le_map_subtype":
 "@[simp, to_additive]\ntheorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :\n    H.map G'.subtype ≤ K.map G'.subtype ↔ H ≤ K :=\n  map_le_map_iff_of_injective Subtype.coe_injective\n#align map_subtype_le_map_subtype map_subtype_le_map_subtype\n\n",
 "map_subtype_le":
 "@[to_additive]\ntheorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.subtype ≤ H :=\n  (K.map_le_range H.subtype).trans (le_of_eq H.subtype_range)\n#align map_subtype_le map_subtype_le\n\n",
 "map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_range (g : «expr →* » N P) (f : «expr →* » G N) : f.range.map g = (g.comp f).range := by\n  rw [range_eq_map, range_eq_map] <;> exact («expr⊤» : Subgroup G).map_map g f\n#align map_range map_range\n\n",
 "map_one_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem map_one_eq_bot : K.map (1 : «expr →* » G N) = «expr⊥» :=\n  eq_bot_iff.mpr <| by\n    rintro x ⟨y, _, rfl⟩\n    simp\n#align map_one_eq_bot map_one_eq_bot\n\n",
 "map_normalizer_eq_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The image of the normalizer is equal to the normalizer of the image of a bijective\n  function. -/\n@[to_additive \"The image of the normalizer is equal to the normalizer of the image of a bijective\\n  function.\"]\ntheorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : «expr →* » G N} (hf : function.bijective f) :\n    H.normalizer.map f = (H.map f).normalizer :=\n  map_equiv_normalizer_eq H (MulEquiv.ofBijective f hf)\n#align map_normalizer_eq_of_bijective map_normalizer_eq_of_bijective\n\n",
 "map_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_mono {f : «expr →* » G N} {K K' : Subgroup G} : K ≤ K' → map f K ≤ map f K' :=\n  image_subset _\n#align map_mono map_mono\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_map (g : «expr →* » N P) (f : «expr →* » G N) : (K.map f).map g = K.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_range":
 "@[to_additive]\ntheorem map_le_range (H : Subgroup G) : map f H ≤ f.range :=\n  (range_eq_map f).symm ▸ map_mono le_top\n#align map_le_range map_le_range\n\n",
 "map_le_map_iff_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_le_map_iff_of_injective {f : «expr →* » G N} (hf : function.injective f) {H K : Subgroup G} :\n    H.map f ≤ K.map f ↔ H ≤ K := by rw [map_le_iff_le_comap, comap_map_eq_self_of_injective hf]\n#align map_le_map_iff_of_injective map_le_map_iff_of_injective\n\n",
 "map_le_map_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem map_le_map_iff' {f : «expr →* » G N} {H K : Subgroup G} :\n    H.map f ≤ K.map f ↔ «expr ⊔ » H f.ker ≤ «expr ⊔ » K f.ker := by\n  simp only [map_le_map_iff, sup_le_iff, le_sup_right, and_true_iff]\n#align map_le_map_iff' map_le_map_iff'\n\n",
 "map_le_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem map_le_map_iff {f : «expr →* » G N} {H K : Subgroup G} : H.map f ≤ K.map f ↔ H ≤ «expr ⊔ » K f.ker := by\n  rw [map_le_iff_le_comap, comap_map_eq]\n#align map_le_map_iff map_le_map_iff\n\n",
 "map_le_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_le_iff_le_comap {f : «expr →* » G N} {K : Subgroup G} {H : Subgroup N} : K.map f ≤ H ↔ K ≤ H.comap f :=\n  image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_injective_of_ker_le":
 "/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\n@[to_additive \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"]\ntheorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K) (hf : map f H = map f K) : H = K :=\n  by\n  apply_fun comap f  at hf\n  rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf\n#align map_injective_of_ker_le map_injective_of_ker_le\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_injective {f : «expr →* » G N} (h : function.injective f) : function.injective (map f) :=\n  function.left_inverse.injective <| comap_map_eq_self_of_injective h\n#align map_injective map_injective\n\n",
 "map_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem map_inf_le (H K : Subgroup G) (f : «expr →* » G N) : map f («expr ⊓ » H K) ≤ «expr ⊓ » (map f H) (map f K) :=\n  le_inf (map_mono inf_le_left) (map_mono inf_le_right)\n#align map_inf_le map_inf_le\n\n",
 "map_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem map_inf_eq (H K : Subgroup G) (f : «expr →* » G N) (hf : function.injective f) :\n    map f («expr ⊓ » H K) = «expr ⊓ » (map f H) (map f K) :=\n  by\n  rw [← SetLike.coe_set_eq]\n  simp [Set.image_inter hf]\n#align map_inf_eq map_inf_eq\n\n",
 "map_id":
 "@[simp, to_additive]\ntheorem map_id : K.map (MonoidHom.id G) = K :=\n  SetLike.coe_injective <| image_id _\n#align map_id map_id\n\n",
 "map_equiv_normalizer_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/\n@[to_additive \"The image of the normalizer is equal to the normalizer of the image of an\\nisomorphism.\"]\ntheorem map_equiv_normalizer_eq (H : Subgroup G) (f : «expr ≃* » G N) :\n    H.normalizer.map f.to_monoid_hom = (H.map f.to_monoid_hom).normalizer :=\n  by\n  ext x\n  simp only [mem_normalizer_iff, mem_map_equiv]\n  rw [f.to_equiv.forall_congr]\n  simp\n#align map_equiv_normalizer_eq map_equiv_normalizer_eq\n\n",
 "map_equiv_eq_comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : «expr ≃* » G N) (K : Subgroup G) :\n    K.map f.to_monoid_hom = K.comap f.symm.to_monoid_hom :=\n  SetLike.coe_injective (f.to_equiv.image_eq_preimage K)\n#align map_equiv_eq_comap_symm map_equiv_eq_comap_symm\n\n",
 "map_eq_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_eq_range_iff {f : «expr →* » G N} {H : Subgroup G} : H.map f = f.range ↔ Codisjoint H f.ker := by\n  rw [f.range_eq_map, map_eq_map_iff, codisjoint_iff, top_sup_eq]\n#align map_eq_range_iff map_eq_range_iff\n\n",
 "map_eq_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem map_eq_map_iff {f : «expr →* » G N} {H K : Subgroup G} :\n    H.map f = K.map f ↔ «expr ⊔ » H f.ker = «expr ⊔ » K f.ker := by simp only [le_antisymm_iff, map_le_map_iff']\n#align map_eq_map_iff map_eq_map_iff\n\n",
 "map_eq_comap_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_eq_comap_of_inverse {f : «expr →* » G N} {g : «expr →* » N G} (hl : function.left_inverse g f)\n    (hr : function.right_inverse g f) (H : Subgroup G) : map f H = comap g H :=\n  SetLike.ext' <| by rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]\n#align map_eq_comap_of_inverse map_eq_comap_of_inverse\n\n",
 "map_eq_bot_iff_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem map_eq_bot_iff_of_injective {f : «expr →* » G N} (hf : function.injective f) :\n    H.map f = «expr⊥» ↔ H = «expr⊥» := by rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]\n#align map_eq_bot_iff_of_injective map_eq_bot_iff_of_injective\n\n",
 "map_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print map_eq_bot_iff /-\n@[to_additive]\ntheorem map_eq_bot_iff {f : «expr →* » G N} : H.map f = «expr⊥» ↔ H ≤ f.ker :=\n  (gc_map_comap f).l_eq_bot\n#align map_eq_bot_iff map_eq_bot_iff\n-/\n\n",
 "map_comap_le":
 "@[to_additive]\ntheorem map_comap_le (H : Subgroup N) : map f (comap f H) ≤ H :=\n  (gc_map_comap f).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_comap_eq_self_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_comap_eq_self_of_surjective {f : «expr →* » G N} (h : function.surjective f) (H : Subgroup N) :\n    map f (comap f H) = H :=\n  map_comap_eq_self ((range_top_of_surjective _ h).symm ▸ le_top)\n#align map_comap_eq_self_of_surjective map_comap_eq_self_of_surjective\n\n",
 "map_comap_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_comap_eq_self {f : «expr →* » G N} {H : Subgroup N} (h : H ≤ f.range) : map f (comap f H) = H := by\n  rwa [map_comap_eq, inf_eq_right]\n#align map_comap_eq_self map_comap_eq_self\n\n",
 "map_comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem map_comap_eq (H : Subgroup N) : map f (comap f H) = «expr ⊓ » f.range H :=\n  SetLike.ext' <| by rw [coe_map, coe_comap, Set.image_preimage_eq_inter_range, coe_inf, coe_range, Set.inter_comm]\n#align map_comap_eq map_comap_eq\n\n",
 "map_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup\ngenerated by the image of the set. -/\n@[to_additive\n      \"The image under an `add_monoid` hom of the `add_subgroup` generated by a set equals\\nthe `add_subgroup` generated by the image of the set.\"]\ntheorem map_closure (f : «expr →* » G N) (s : Set G) : (closure s).map f = closure («expr '' » f s) :=\n  Set.image_preimage.l_comm_of_u_comm (Subgroup.gc_map_comap f) (Subgroup.gi N).gc (Subgroup.gi G).gc fun t => rfl\n#align map_closure map_closure\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem map_bot (f : «expr →* » G N) : («expr⊥» : Subgroup G).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem normal.map {H : Subgroup G} (h : H.normal) (f : «expr →* » G N) (hf : function.surjective f) :\n    (H.map f).normal :=\n  by\n  rw [← normalizer_eq_top, ← top_le_iff, ← f.range_top_of_surjective hf, f.range_eq_map, ← normalizer_eq_top.2 h]\n  exact le_normalizer_map _\n#align normal.map normal.map\n\n",
 "lift_of_right_inverse_comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem lift_of_right_inverse_comp_apply (hf : function.right_inverse f_inv f)\n    (g : { g : «expr →* » G₁ G₃ // f.ker ≤ g.ker }) (x : G₁) : (f.lift_of_right_inverse f_inv hf g) (f x) = g x :=\n  f.lift_of_right_inverse_aux_comp_apply f_inv hf g.1 g.2 x\n#align lift_of_right_inverse_comp_apply lift_of_right_inverse_comp_apply\n\n",
 "lift_of_right_inverse_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem lift_of_right_inverse_comp (hf : function.right_inverse f_inv f)\n    (g : { g : «expr →* » G₁ G₃ // f.ker ≤ g.ker }) : (f.lift_of_right_inverse f_inv hf g).comp f = g :=\n  MonoidHom.ext <| f.lift_of_right_inverse_comp_apply f_inv hf g\n#align lift_of_right_inverse_comp lift_of_right_inverse_comp\n\n",
 "lift_of_right_inverse_aux_comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem lift_of_right_inverse_aux_comp_apply (hf : function.right_inverse f_inv f) (g : «expr →* » G₁ G₃)\n    (hg : f.ker ≤ g.ker) (x : G₁) : (f.lift_of_right_inverse_aux f_inv hf g hg) (f x) = g x :=\n  by\n  dsimp [lift_of_right_inverse_aux]\n  rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]\n  apply hg\n  rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]\n  simp only [hf _]\n#align lift_of_right_inverse_aux_comp_apply lift_of_right_inverse_aux_comp_apply\n\n",
 "le_prod_iff":
 "@[to_additive le_prod_iff]\ntheorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :\n    J ≤ H.prod K ↔ map (MonoidHom.fst G N) J ≤ H ∧ map (MonoidHom.snd G N) J ≤ K := by\n  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.le_prod_iff\n#align le_prod_iff le_prod_iff\n\n",
 "le_pi_iff":
 "@[to_additive]\ntheorem le_pi_iff {I : Set η} {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :\n    J ≤ pi I H ↔ ∀ i : η, i ∈ I → map (Pi.evalMonoidHom f i) J ≤ H i :=\n  by\n  constructor\n  · intro h i hi\n    rintro _ ⟨x, hx, rfl⟩\n    exact (h hx) _ hi\n  · intro h x hx i hi\n    refine' h i hi ⟨_, hx, rfl⟩\n#align le_pi_iff le_pi_iff\n\n",
 "le_normalizer_of_normal":
 "@[to_additive]\ntheorem le_normalizer_of_normal [hK : (H.subgroup_of K).normal] (HK : H ≤ K) : K ≤ H.normalizer := fun x hx y =>\n  ⟨fun yH => hK.conj_mem ⟨y, HK yH⟩ yH ⟨x, hx⟩, fun yH => by\n    simpa [mem_subgroup_of, mul_assoc] using hK.conj_mem ⟨x * y * x⁻¹, HK yH⟩ yH ⟨x⁻¹, K.inv_mem hx⟩⟩\n#align le_normalizer_of_normal le_normalizer_of_normal\n\n",
 "le_normalizer_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The image of the normalizer is contained in the normalizer of the image. -/\n@[to_additive \"The image of the normalizer is contained in the normalizer of the image.\"]\ntheorem le_normalizer_map (f : «expr →* » G N) : H.normalizer.map f ≤ (H.map f).normalizer := fun _ =>\n  by\n  simp only [and_imp, exists_prop, mem_map, exists_imp, mem_normalizer_iff]\n  rintro x hx rfl n\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    use x * y * x⁻¹, (hx y).1 hy\n    simp\n  · rintro ⟨y, hyH, hy⟩\n    use x⁻¹ * y * x\n    rw [hx]\n    simp [hy, hyH, mul_assoc]\n#align le_normalizer_map le_normalizer_map\n\n",
 "le_normalizer_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The preimage of the normalizer is contained in the normalizer of the preimage. -/\n@[to_additive \"The preimage of the normalizer is contained in the normalizer of the preimage.\"]\ntheorem le_normalizer_comap (f : «expr →* » N G) : H.normalizer.comap f ≤ (H.comap f).normalizer := fun x =>\n  by\n  simp only [mem_normalizer_iff, mem_comap]\n  intro h n\n  simp [h (f n)]\n#align le_normalizer_comap le_normalizer_comap\n\n",
 "le_normalizer":
 "@[to_additive]\ntheorem le_normalizer : H ≤ normalizer H := fun x xH n => by\n  rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]\n#align le_normalizer le_normalizer\n\n",
 "le_normal_closure":
 "theorem le_normal_closure {H : Subgroup G} : H ≤ normalClosure ↑H := fun _ h => subset_normalClosure h\n#align le_normal_closure le_normal_closure\n\n",
 "le_comap_map":
 "@[to_additive]\ntheorem le_comap_map (H : Subgroup G) : H ≤ comap f (map f H) :=\n  (gc_map_comap f).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "le_closure_to_submonoid":
 "@[to_additive]\ntheorem le_closure_to_submonoid (S : Set G) : Submonoid.closure S ≤ (closure S).to_submonoid :=\n  Submonoid.closure_le.2 subset_closure\n#align le_closure_to_submonoid le_closure_to_submonoid\n\n",
 "le_centralizer_iff_is_commutative":
 "@[to_additive]\ntheorem le_centralizer_iff_is_commutative : K ≤ K.centralizer ↔ K.is_commutative :=\n  ⟨fun h => ⟨⟨fun x y => Subtype.ext (h y.2 x x.2)⟩⟩, fun h x hx y hy => congr_arg coe (h.1.1 ⟨y, hy⟩ ⟨x, hx⟩)⟩\n#align le_centralizer_iff_is_commutative le_centralizer_iff_is_commutative\n\n",
 "le_centralizer_iff":
 "@[to_additive]\ntheorem le_centralizer_iff : H ≤ K.centralizer ↔ K ≤ H.centralizer :=\n  ⟨fun h x hx y hy => (h hy x hx).symm, fun h x hx y hy => (h hy x hx).symm⟩\n#align le_centralizer_iff le_centralizer_iff\n\n",
 "le_centralizer":
 "@[to_additive]\ntheorem le_centralizer [h : H.is_commutative] : H ≤ H.centralizer :=\n  le_centralizer_iff_isCommutative.mpr h\n#align le_centralizer le_centralizer\n\n",
 "ker_to_hom_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem ker_to_hom_units {M} [Monoid M] (f : «expr →* » G M) : f.to_hom_units.ker = f.ker :=\n  by\n  ext x\n  simp [mem_ker, Units.ext_iff]\n#align ker_to_hom_units ker_to_hom_units\n\n",
 "ker_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subgroup.ker_subtype /-\n@[simp, to_additive]\ntheorem Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = «expr⊥» :=\n  H.subtype.ker_eq_bot_iff.mpr Subtype.coe_injective\n#align subgroup.ker_subtype Subgroup.ker_subtype\n#align add_subgroup.ker_subtype AddSubgroup.ker_subtype\n-/\n\n",
 "ker_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem ker_restrict (f : «expr →* » G N) : (f.restrict K).ker = f.ker.subgroup_of K :=\n  rfl\n#align ker_restrict ker_restrict\n\n",
 "ker_range_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem ker_range_restrict (f : «expr →* » G N) : ker (rangeRestrict f) = ker f :=\n  ker_codRestrict _ _ _\n#align ker_range_restrict ker_range_restrict\n\n",
 "ker_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem ker_prod_map {G' : Type _} {N' : Type _} [Group G'] [Group N'] (f : «expr →* » G N) (g : «expr →* » G' N') :\n    (prodMap f g).ker = f.ker.prod g.ker := by\n  rw [← comap_bot, ← comap_bot, ← comap_bot, ← prod_map_comap_prod, bot_prod_bot]\n#align ker_prod_map ker_prod_map\n\n",
 "ker_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem ker_one : (1 : «expr →* » G M).ker = «expr⊤» :=\n  SetLike.ext fun x => eq_self_iff_true _\n#align ker_one ker_one\n\n",
 "ker_le_comap":
 "@[to_additive]\ntheorem ker_le_comap (H : Subgroup N) : f.ker ≤ comap f H :=\n  comap_bot f ▸ comap_mono bot_le\n#align ker_le_comap ker_le_comap\n\n",
 "ker_inclusion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subgroup.ker_inclusion /-\n@[simp, to_additive]\ntheorem Subgroup.ker_inclusion {H K : Subgroup G} (h : H ≤ K) : (inclusion h).ker = «expr⊥» :=\n  (inclusion h).ker_eq_bot_iff.mpr (Set.inclusion_injective h)\n#align subgroup.ker_inclusion Subgroup.ker_inclusion\n#align add_subgroup.ker_inclusion AddSubgroup.ker_inclusion\n-/\n\n",
 "ker_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem ker_id : (MonoidHom.id G).ker = «expr⊥» :=\n  rfl\n#align ker_id ker_id\n\n",
 "ker_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem ker_eq_bot_iff (f : «expr →* » G M) : f.ker = «expr⊥» ↔ function.injective f :=\n  ⟨fun h x y hxy => by rwa [eq_iff, h, mem_bot, inv_mul_eq_one, eq_comm] at hxy, fun h =>\n    bot_unique fun x hx => h (hx.trans f.map_one.symm)⟩\n#align ker_eq_bot_iff ker_eq_bot_iff\n\n",
 "ker_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem ker_cod_restrict {S} [SetLike S N] [SubmonoidClass S N] (f : «expr →* » G N) (s : S) (h : ∀ x, f x ∈ s) :\n    (f.cod_restrict s h).ker = f.ker :=\n  SetLike.ext fun x => Subtype.ext_iff\n#align ker_cod_restrict ker_cod_restrict\n\n",
 "inv_mem_iff":
 "#print inv_mem_iff /-\n@[to_additive]\nprotected theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=\n  inv_mem_iff\n#align inv_mem_iff inv_mem_iff\n#align neg_mem_iff neg_mem_iff\n-/\n\n",
 "inv_mem":
 "/-- A subgroup is closed under inverse. -/\n@[to_additive \"An `add_subgroup` is closed under inverse.\"]\nprotected theorem inv_mem {x : G} : x ∈ H → x⁻¹ ∈ H :=\n  inv_mem\n#align inv_mem inv_mem\n\n",
 "inf_subgroup_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem inf_subgroup_of_right (H K : Subgroup G) : («expr ⊓ » H K).subgroup_of K = H.subgroup_of K :=\n  subgroupOf_inj.2 inf_right_idem\n#align inf_subgroup_of_right inf_subgroup_of_right\n\n",
 "inf_subgroup_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem inf_subgroup_of_left (H K : Subgroup G) : («expr ⊓ » K H).subgroup_of K = H.subgroup_of K := by\n  rw [inf_comm, inf_subgroup_of_right]\n#align inf_subgroup_of_left inf_subgroup_of_left\n\n",
 "inf_subgroup_of_inf_normal_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem inf_subgroup_of_inf_normal_of_right (A B' B : Subgroup G) (hB : B' ≤ B) [hN : (B'.subgroup_of B).normal] :\n    ((«expr ⊓ » A B').subgroup_of («expr ⊓ » A B)).normal :=\n  {\n    conj_mem := fun n hn g =>\n      ⟨mul_mem (mul_mem (mem_inf.1 g.2).1 (mem_inf.1 n.2).1) (inv_mem (mem_inf.1 g.2).1),\n        (normal_subgroupOf_iff hB).mp hN n g hn.2 (mem_inf.mp g.2).2⟩ }\n#align inf_subgroup_of_inf_normal_of_right inf_subgroup_of_inf_normal_of_right\n\n",
 "inf_subgroup_of_inf_normal_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem inf_subgroup_of_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' ≤ A)\n    [hN : (A'.subgroup_of A).normal] : ((«expr ⊓ » A' B).subgroup_of («expr ⊓ » A B)).normal :=\n  {\n    conj_mem := fun n hn g =>\n      ⟨(normal_subgroupOf_iff hA).mp hN n g hn.1 (mem_inf.mp g.2).1,\n        mul_mem (mul_mem (mem_inf.1 g.2).2 (mem_inf.1 n.2).2) (inv_mem (mem_inf.1 g.2).2)⟩ }\n#align inf_subgroup_of_inf_normal_of_left inf_subgroup_of_inf_normal_of_left\n\n",
 "inclusion_self":
 "@[simp, to_additive]\ntheorem inclusion_self (x : H) : inclusion le_rfl x = x :=\n  by\n  cases x\n  rfl\n#align inclusion_self inclusion_self\n\n",
 "inclusion_right":
 "@[to_additive]\ntheorem inclusion_right (h : H ≤ K) (x : K) (hx : (x : G) ∈ H) : inclusion h ⟨x, hx⟩ = x :=\n  by\n  cases x\n  rfl\n#align inclusion_right inclusion_right\n\n",
 "inclusion_range":
 "#print Subgroup.inclusion_range /-\n@[simp, to_additive]\ntheorem Subgroup.inclusion_range {H K : Subgroup G} (h_le : H ≤ K) : (inclusion h_le).range = H.subgroup_of K :=\n  Subgroup.ext fun g => Set.ext_iff.mp (Set.range_inclusion h_le) g\n#align subgroup.inclusion_range Subgroup.inclusion_range\n#align add_subgroup.inclusion_range AddSubgroup.inclusion_range\n-/\n\n",
 "inclusion_mk":
 "@[simp, to_additive]\ntheorem inclusion_mk {h : H ≤ K} (x : G) (hx : x ∈ H) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=\n  rfl\n#align inclusion_mk inclusion_mk\n\n",
 "inclusion_injective":
 "@[to_additive]\ntheorem inclusion_injective {H K : Subgroup G} (h : H ≤ K) : function.injective <| inclusion h :=\n  Set.inclusion_injective h\n#align inclusion_injective inclusion_injective\n\n",
 "inclusion_inclusion":
 "@[simp]\ntheorem inclusion_inclusion {L : S} (hHK : H ≤ K) (hKL : K ≤ L) (x : H) :\n    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x :=\n  by\n  cases x\n  rfl\n#align inclusion_inclusion inclusion_inclusion\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem gc_map_comap (f : «expr →* » G N) : GaloisConnection (map f) (comap f) := fun _ _ => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "ext":
 "/-- Two subgroups are equal if they have the same elements. -/\n@[ext, to_additive \"Two `add_subgroup`s are equal if they have the same elements.\"]\ntheorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=\n  SetLike.ext h\n#align ext ext\n\n",
 "exists_inv_mem_iff_exists_mem":
 "#print exists_inv_mem_iff_exists_mem /-\n@[to_additive]\nprotected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G → Prop} :\n    (∃ x : G, x ∈ K ∧ P x⁻¹) ↔ ∃ x ∈ K, P x :=\n  exists_inv_mem_iff_exists_mem\n#align exists_inv_mem_iff_exists_mem exists_inv_mem_iff_exists_mem\n#align exists_neg_mem_iff_exists_mem exists_neg_mem_iff_exists_mem\n-/\n\n",
 "equiv_map_of_injective_coe_mul_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem equiv_map_of_injective_coe_mul_equiv (H : Subgroup G) (e : «expr ≃* » G G') :\n    H.equiv_map_of_injective (e : «expr →* » G G') (EquivLike.injective e) = e.subgroup_map H :=\n  by\n  ext\n  rfl\n#align equiv_map_of_injective_coe_mul_equiv equiv_map_of_injective_coe_mul_equiv\n\n",
 "eq_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_top_iff' : H = «expr⊤» ↔ ∀ x : G, x ∈ H :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n#align eq_top_iff' eq_top_iff'\n\n",
 "eq_on_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\n@[to_additive \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\\nclosure.\"]\ntheorem eq_on_closure {f g : «expr →* » G M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eq_locus g from (closure_le _).2 h\n#align eq_on_closure eq_on_closure\n\n",
 "eq_of_eq_on_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_of_eq_on_top {f g : «expr →* » G M} (h : Set.EqOn f g («expr⊤» : Subgroup G)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_top eq_of_eq_on_top\n\n",
 "eq_of_eq_on_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem eq_of_eq_on_dense {s : Set G} (hs : closure s = «expr⊤») {f g : «expr →* » G M} (h : s.eq_on f g) : f = g :=\n  eq_of_eqOn_top <| hs ▸ eqOn_closure h\n#align eq_of_eq_on_dense eq_of_eq_on_dense\n\n",
 "eq_locus_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem eq_locus_same (f : «expr →* » G N) : f.eq_locus f = «expr⊤» :=\n  SetLike.ext fun _ => eq_self_iff_true _\n#align eq_locus_same eq_locus_same\n\n",
 "eq_lift_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem eq_lift_of_right_inverse (hf : function.right_inverse f_inv f) (g : «expr →* » G₁ G₃) (hg : f.ker ≤ g.ker)\n    (h : «expr →* » G₂ G₃) (hh : h.comp f = g) : h = f.lift_of_right_inverse f_inv hf ⟨g, hg⟩ :=\n  by\n  simp_rw [← hh]\n  exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm\n#align eq_lift_of_right_inverse eq_lift_of_right_inverse\n\n",
 "eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem eq_iff (f : «expr →* » G M) {x y : G} : f x = f y ↔ y⁻¹ * x ∈ f.ker :=\n  by\n  constructor <;> intro h\n  · rw [mem_ker, map_mul, h, ← map_mul, inv_mul_self, map_one]\n  · rw [← one_mul x, ← mul_inv_self y, mul_assoc, map_mul, f.mem_ker.1 h, mul_one]\n#align eq_iff eq_iff\n\n",
 "eq_bot_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem eq_bot_of_subsingleton [subsingleton H] : H = «expr⊥» :=\n  by\n  rw [Subgroup.eq_bot_iff_forall]\n  intro y hy\n  rw [← Subgroup.coe_mk H y hy, subsingleton.elim (⟨y, hy⟩ : H) 1, Subgroup.coe_one]\n#align eq_bot_of_subsingleton eq_bot_of_subsingleton\n\n",
 "eq_bot_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem eq_bot_iff_forall : H = «expr⊥» ↔ ∀ x ∈ H, x = (1 : G) :=\n  toSubmonoid_injective.eq_iff.symm.trans <| Submonoid.eq_bot_iff_forall _\n#align eq_bot_iff_forall eq_bot_iff_forall\n\n",
 "div_mem_comm_iff":
 "#print div_mem_comm_iff /-\n@[to_additive]\nprotected theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=\n  div_mem_comm_iff\n#align div_mem_comm_iff div_mem_comm_iff\n#align sub_mem_comm_iff sub_mem_comm_iff\n-/\n\n",
 "div_mem":
 "#print div_mem /-\n/-- A subgroup is closed under division. -/\n@[to_additive \"An `add_subgroup` is closed under subtraction.\"]\nprotected theorem div_mem {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H :=\n  div_mem hx hy\n#align div_mem div_mem\n#align sub_mem sub_mem\n-/\n\n",
 "disjoint_iff_mul_eq_one":
 "@[to_additive]\ntheorem disjoint_iff_mul_eq_one {H₁ H₂ : Subgroup G} :\n    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x * y = 1 → x = 1 ∧ y = 1 :=\n  disjoint_def'.trans\n    ⟨fun h x y hx hy hxy =>\n      let hx1 : x = 1 := h hx (H₂.inv_mem hy) (eq_inv_iff_mul_eq_one.mpr hxy)\n      ⟨hx1, by simpa [hx1] using hxy⟩,\n      fun h x y hx hy hxy => (h hx (H₂.inv_mem hy) (mul_inv_eq_one.mpr hxy)).1⟩\n#align disjoint_iff_mul_eq_one disjoint_iff_mul_eq_one\n\n",
 "disjoint_def'":
 "@[to_additive]\ntheorem disjoint_def' {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x = y → x = 1 :=\n  disjoint_def.trans ⟨fun h x y hx hy hxy => h hx <| hxy.symm ▸ hy, fun h x hx hx' => h hx hx' rfl⟩\n#align disjoint_def' disjoint_def'\n\n",
 "disjoint_def":
 "@[to_additive]\ntheorem disjoint_def {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x : G}, x ∈ H₁ → x ∈ H₂ → x = 1 :=\n  disjoint_iff_inf_le.trans <| by simp only [Disjoint, SetLike.le_def, mem_inf, mem_bot, and_imp]\n#align disjoint_def disjoint_def\n\n",
 "copy_eq":
 "@[to_additive]\ntheorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = ↑K) : K.copy s hs = K :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "conjugates_subset_normal":
 "theorem conjugates_subset_normal {N : Subgroup G} [tn : N.normal] {a : G} (h : a ∈ N) : conjugatesOf a ⊆ N :=\n  by\n  rintro a hc\n  obtain ⟨c, rfl⟩ := isConj_iff.1 hc\n  exact tn.conj_mem a h c\n#align conjugates_subset_normal conjugates_subset_normal\n\n",
 "conjugates_of_set_subset_normal_closure":
 "theorem conjugates_of_set_subset_normal_closure : conjugatesOfSet s ⊆ normalClosure s :=\n  subset_closure\n#align conjugates_of_set_subset_normal_closure conjugates_of_set_subset_normal_closure\n\n",
 "conjugates_of_set_subset":
 "theorem conjugates_of_set_subset {s : Set G} {N : Subgroup G} [N.normal] (h : s ⊆ N) : conjugatesOfSet s ⊆ N :=\n  Set.unionᵢ₂_subset fun x H => conjugates_subset_normal (h H)\n#align conjugates_of_set_subset conjugates_of_set_subset\n\n",
 "conjugates_of_set_mono":
 "theorem conjugates_of_set_mono {s t : Set G} (h : s ⊆ t) : conjugatesOfSet s ⊆ conjugatesOfSet t :=\n  Set.bunionᵢ_subset_bunionᵢ_left h\n#align conjugates_of_set_mono conjugates_of_set_mono\n\n",
 "conj_mem_conjugates_of_set":
 "/-- The set of conjugates of `s` is closed under conjugation. -/\ntheorem conj_mem_conjugates_of_set {x c : G} : x ∈ conjugatesOfSet s → c * x * c⁻¹ ∈ conjugatesOfSet s := fun H =>\n  by\n  rcases mem_conjugates_of_set_iff.1 H with ⟨a, h₁, h₂⟩\n  exact mem_conjugates_of_set_iff.2 ⟨a, h₁, h₂.trans (isConj_iff.2 ⟨c, rfl⟩)⟩\n#align conj_mem_conjugates_of_set conj_mem_conjugates_of_set\n\n",
 "commute_of_normal_of_disjoint":
 "/-- Elements of disjoint, normal subgroups commute. -/\n@[to_additive \"Elements of disjoint, normal subgroups commute.\"]\ntheorem commute_of_normal_of_disjoint (H₁ H₂ : Subgroup G) (hH₁ : H₁.normal) (hH₂ : H₂.normal) (hdis : Disjoint H₁ H₂)\n    (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : Commute x y :=\n  by\n  suffices x * y * x⁻¹ * y⁻¹ = 1 by\n    show x * y = y * x\n    · rw [mul_assoc, mul_eq_one_iff_eq_inv] at this\n      simpa\n  apply hdis.le_bot\n  constructor\n  · suffices x * (y * x⁻¹ * y⁻¹) ∈ H₁ by simpa [mul_assoc]\n    exact H₁.mul_mem hx (hH₁.conj_mem _ (H₁.inv_mem hx) _)\n  · show x * y * x⁻¹ * y⁻¹ ∈ H₂\n    apply H₂.mul_mem _ (H₂.inv_mem hy)\n    apply hH₂.conj_mem _ hy\n#align commute_of_normal_of_disjoint commute_of_normal_of_disjoint\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem comap_top (f : «expr →* » G N) : («expr⊤» : Subgroup N).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_sup_eq_of_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H ≤ f.range) (hK : K ≤ f.range) :\n    «expr ⊔ » (comap f H) (comap f K) = comap f («expr ⊔ » H K) :=\n  map_injective_of_ker_le f ((ker_le_comap f H).trans le_sup_left) (ker_le_comap f («expr ⊔ » H K))\n    (by\n      rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH, inf_eq_right.mpr hK,\n        inf_eq_right.mpr (sup_le hH hK)])\n#align comap_sup_eq_of_le_range comap_sup_eq_of_le_range\n\n",
 "comap_sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem comap_sup_eq (H K : Subgroup N) (hf : function.surjective f) :\n    «expr ⊔ » (comap f H) (comap f K) = comap f («expr ⊔ » H K) :=\n  comap_sup_eq_of_le_range f (le_top.trans (ge_of_eq (f.range_top_of_surjective hf)))\n    (le_top.trans (ge_of_eq (f.range_top_of_surjective hf)))\n#align comap_sup_eq comap_sup_eq\n\n",
 "comap_sup_comap_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem comap_sup_comap_le (H K : Subgroup N) (f : «expr →* » G N) :\n    «expr ⊔ » (comap f H) (comap f K) ≤ comap f («expr ⊔ » H K) :=\n  Monotone.le_map_sup (fun _ _ => comap_mono) H K\n#align comap_sup_comap_le comap_sup_comap_le\n\n",
 "comap_subtype":
 "@[simp, to_additive]\ntheorem comap_subtype (H K : Subgroup G) : H.comap K.subtype = H.subgroup_of K :=\n  rfl\n#align comap_subtype comap_subtype\n\n",
 "comap_normalizer_eq_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The preimage of the normalizer is equal to the normalizer of the preimage of a surjective\n  function. -/\n@[to_additive \"The preimage of the normalizer is equal to the normalizer of the preimage of\\na surjective function.\"]\ntheorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : «expr →* » N G} (hf : function.surjective f) :\n    H.normalizer.comap f = (H.comap f).normalizer :=\n  le_antisymm (le_normalizer_comap f)\n    (by\n      intro x hx\n      simp only [mem_comap, mem_normalizer_iff] at *\n      intro n\n      rcases hf n with ⟨y, rfl⟩\n      simp [hx y])\n#align comap_normalizer_eq_of_surjective comap_normalizer_eq_of_surjective\n\n",
 "comap_normalizer_eq_of_injective_of_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_normalizer_eq_of_injective_of_le_range {N : Type _} [Group N] (H : Subgroup G) {f : «expr →* » N G}\n    (hf : function.injective f) (h : H.normalizer ≤ f.range) : comap f H.normalizer = (comap f H).normalizer :=\n  by\n  apply Subgroup.map_injective hf\n  rw [map_comap_eq_self h]\n  apply le_antisymm\n  · refine' le_trans (le_of_eq _) (map_mono (le_normalizer_comap _))\n    rw [map_comap_eq_self h]\n  · refine' le_trans (le_normalizer_map f) (le_of_eq _)\n    rw [map_comap_eq_self (le_trans le_normalizer h)]\n#align comap_normalizer_eq_of_injective_of_le_range comap_normalizer_eq_of_injective_of_le_range\n\n",
 "comap_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_mono {f : «expr →* » G N} {K K' : Subgroup N} : K ≤ K' → comap f K ≤ comap f K' :=\n  preimage_mono\n#align comap_mono comap_mono\n\n",
 "comap_map_eq_self_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_map_eq_self_of_injective {f : «expr →* » G N} (h : function.injective f) (H : Subgroup G) :\n    comap f (map f H) = H :=\n  comap_map_eq_self (((ker_eq_bot_iff _).mpr h).symm ▸ bot_le)\n#align comap_map_eq_self_of_injective comap_map_eq_self_of_injective\n\n",
 "comap_map_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_map_eq_self {f : «expr →* » G N} {H : Subgroup G} (h : f.ker ≤ H) : comap f (map f H) = H := by\n  rwa [comap_map_eq, sup_eq_left]\n#align comap_map_eq_self comap_map_eq_self\n\n",
 "comap_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem comap_map_eq (H : Subgroup G) : comap f (map f H) = «expr ⊔ » H f.ker :=\n  by\n  refine' le_antisymm _ (sup_le (le_comap_map _ _) (ker_le_comap _ _))\n  intro x hx; simp only [exists_prop, mem_map, mem_comap] at hx\n  rcases hx with ⟨y, hy, hy'⟩\n  rw [← mul_inv_cancel_left y x]\n  exact mul_mem_sup hy (by simp [mem_ker, hy'])\n#align comap_map_eq comap_map_eq\n\n",
 "comap_lt_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_lt_comap_of_surjective {f : «expr →* » G N} {K L : Subgroup N} (hf : function.surjective f) :\n    K.comap f < L.comap f ↔ K < L := by simp_rw [lt_iff_le_not_le, comap_le_comap_of_surjective hf]\n#align comap_lt_comap_of_surjective comap_lt_comap_of_surjective\n\n",
 "comap_le_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_le_comap_of_surjective {f : «expr →* » G N} {K L : Subgroup N} (hf : function.surjective f) :\n    K.comap f ≤ L.comap f ↔ K ≤ L :=\n  comap_le_comap_of_le_range (le_top.trans (f.range_top_of_surjective hf).ge)\n#align comap_le_comap_of_surjective comap_le_comap_of_surjective\n\n",
 "comap_le_comap_of_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_le_comap_of_le_range {f : «expr →* » G N} {K L : Subgroup N} (hf : K ≤ f.range) :\n    K.comap f ≤ L.comap f ↔ K ≤ L :=\n  ⟨(map_comap_eq_self hf).ge.trans ∘ map_le_iff_le_comap.mpr, comap_mono⟩\n#align comap_le_comap_of_le_range comap_le_comap_of_le_range\n\n",
 "comap_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_ker (g : «expr →* » N P) (f : «expr →* » G N) : g.ker.comap f = (g.comp f).ker :=\n  rfl\n#align comap_ker comap_ker\n\n",
 "comap_injective_is_commutative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_injective_is_commutative {f : «expr →* » G' G} (hf : injective f) [H.is_commutative] :\n    (H.comap f).is_commutative :=\n  ⟨⟨fun a b =>\n      Subtype.ext\n        (by\n          have := mul_comm (⟨f a, a.2⟩ : H) (⟨f b, b.2⟩ : H)\n          rwa [Subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ← map_mul, ← map_mul, hf.eq_iff] at this)⟩⟩\n#align comap_injective_is_commutative comap_injective_is_commutative\n\n",
 "comap_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_injective {f : «expr →* » G N} (h : function.surjective f) : function.injective (comap f) := fun K L => by\n  simp only [le_antisymm_iff, comap_le_comap_of_surjective h, imp_self]\n#align comap_injective comap_injective\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem comap_infi {ι : Sort _} (f : «expr →* » G N) (s : ι → Subgroup N) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem comap_inf (H K : Subgroup N) (f : «expr →* » G N) :\n    («expr ⊓ » H K).comap f = «expr ⊓ » (H.comap f) (K.comap f) :=\n  (gc_map_comap f).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_inclusion_subgroup_of":
 "@[simp, to_additive]\ntheorem comap_inclusion_subgroup_of {K₁ K₂ : Subgroup G} (h : K₁ ≤ K₂) (H : Subgroup G) :\n    (H.subgroup_of K₂).comap (inclusion h) = H.subgroup_of K₁ :=\n  rfl\n#align comap_inclusion_subgroup_of comap_inclusion_subgroup_of\n\n",
 "comap_id":
 "@[simp, to_additive]\ntheorem comap_id (K : Subgroup N) : K.comap (MonoidHom.id _) = K :=\n  by\n  ext\n  rfl\n#align comap_id comap_id\n\n",
 "comap_equiv_eq_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : «expr ≃* » N G) (K : Subgroup G) :\n    K.comap f.to_monoid_hom = K.map f.symm.to_monoid_hom :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n#align comap_equiv_eq_map_symm comap_equiv_eq_map_symm\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_comap (K : Subgroup P) (g : «expr →* » N P) (f : «expr →* » G N) :\n    (K.comap g).comap f = K.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem comap_bot (f : «expr →* » G N) : («expr⊥» : Subgroup N).comap f = f.ker :=\n  rfl\n#align comap_bot comap_bot\n\n",
 "comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Subgroup.Normal.comap /-\n-- Here `H.normal` is an explicit argument so we can use dot notation with `comap`.\n@[to_additive]\ntheorem Subgroup.Normal.comap {H : Subgroup N} (hH : H.normal) (f : «expr →* » G N) : (H.comap f).normal :=\n  ⟨fun _ => by simp (config := { contextual := true }) [Subgroup.mem_comap, hH.conj_mem]⟩\n#align subgroup.normal.comap Subgroup.Normal.comap\n#align add_subgroup.normal.comap AddSubgroup.Normal.comap\n-/\n\n",
 "coe_zpow":
 "@[simp, norm_cast, to_additive]\ntheorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = x ^ n :=\n  rfl\n#align coe_zpow coe_zpow\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem coe_top : ((«expr⊤» : Subgroup G) : Set G) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_submonoid":
 "@[simp, to_additive]\ntheorem coe_to_submonoid (K : Subgroup G) : (K.to_submonoid : Set G) = K :=\n  rfl\n#align coe_to_submonoid coe_to_submonoid\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem coe_supr_of_directed {ι} [Nonempty ι] {S : ι → Subgroup G} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          Subgroup G) :\n        Set G) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_subtype : «expr⇑ » H.subtype = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_subgroup_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem coe_subgroup_of (H K : Subgroup G) : (H.subgroup_of K : Set K) = «expr ⁻¹' » K.subtype H :=\n  rfl\n#align coe_subgroup_of coe_subgroup_of\n\n",
 "coe_subgroup_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem coe_subgroup_map_apply (e : «expr ≃* » G G') (H : Subgroup G) (g : H) :\n    ((subgroupMap e H g : H.map (e : «expr →* » G G')) : G') = e g :=\n  rfl\n#align coe_subgroup_map_apply coe_subgroup_map_apply\n\n",
 "coe_set_mk":
 "@[simp, to_additive]\ntheorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) : (mk s h_one h_mul h_inv : Set G) = s :=\n  rfl\n#align coe_set_mk coe_set_mk\n\n",
 "coe_range_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem coe_range_restrict (f : «expr →* » G N) (g : G) : (f.range_restrict g : N) = f g :=\n  rfl\n#align coe_range_restrict coe_range_restrict\n\n",
 "coe_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem coe_range (f : «expr →* » G N) : (f.range : Set N) = Set.range f :=\n  rfl\n#align coe_range coe_range\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[to_additive coe_prod]\ntheorem coe_prod (H : Subgroup G) (K : Subgroup N) : (H.prod K : Set (G × N)) = set.prod H K :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "@[simp, norm_cast, to_additive]\ntheorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = x ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_pi":
 "-- defined here and not in group_theory.submonoid.operations to have access to algebra.group.pi\n@[to_additive]\ntheorem coe_pi (I : Set η) (H : ∀ i, Subgroup (f i)) :\n    (pi I H : Set (∀ i, f i)) = Set.pi I fun i => (H i : Set (f i)) :=\n  rfl\n#align coe_pi coe_pi\n\n",
 "coe_one":
 "@[simp, norm_cast, to_additive]\ntheorem coe_one : ((1 : H) : G) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_mul":
 "@[simp, norm_cast, to_additive]\ntheorem coe_mul (x y : H) : (↑(x * y) : G) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk":
 "@[simp, norm_cast, to_additive]\ntheorem coe_mk (x : G) (hx : x ∈ H) : ((⟨x, hx⟩ : H) : G) = x :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp, to_additive]\ntheorem coe_map (f : «expr →* » G N) (K : Subgroup G) : (K.map f : Set N) = «expr '' » f K :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem coe_ker (f : «expr →* » G M) : (f.ker : Set G) = «expr ⁻¹' » (f : G → M) {1} :=\n  rfl\n#align coe_ker coe_ker\n\n",
 "coe_inv":
 "@[simp, norm_cast, to_additive]\ntheorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : G) :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_infi {ι : Sort _} {S : ι → Subgroup G} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : Set G) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp only [infᵢ, coe_Inf, Set.binterᵢ_range]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem coe_inf (p p' : Subgroup G) : ((«expr ⊓ » p p' : Subgroup G) : Set G) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_inclusion":
 "@[simp, to_additive]\ntheorem coe_inclusion {H K : Subgroup G} {h : H ≤ K} (a : H) : (inclusion h a : G) = a :=\n  by\n  cases a\n  simp only [inclusion, coe_mk, MonoidHom.mk'_apply]\n#align coe_inclusion coe_inclusion\n\n",
 "coe_equiv_map_of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem coe_equiv_map_of_injective_apply (H : Subgroup G) (f : «expr →* » G N) (hf : function.injective f) (h : H) :\n    (equivMapOfInjective H f hf h : N) = f h :=\n  rfl\n#align coe_equiv_map_of_injective_apply coe_equiv_map_of_injective_apply\n\n",
 "coe_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.univ ↔ H = «expr⊤» :=\n  (SetLike.ext'_iff.trans (by rfl)).symm\n#align coe_eq_univ coe_eq_univ\n\n",
 "coe_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem coe_eq_singleton {H : Subgroup G} : (∃ g : G, (H : Set G) = {g}) ↔ H = «expr⊥» :=\n  ⟨fun ⟨g, hg⟩ =>\n    haveI : subsingleton (H : Set G) := by\n      rw [hg]\n      infer_instance\n    H.eq_bot_of_subsingleton,\n    fun h => ⟨1, SetLike.ext'_iff.mp h⟩⟩\n#align coe_eq_singleton coe_eq_singleton\n\n",
 "coe_div":
 "@[simp, norm_cast, to_additive]\ntheorem coe_div (x y : H) : (↑(x / y) : G) = ↑x / ↑y :=\n  rfl\n#align coe_div coe_div\n\n",
 "coe_copy":
 "@[simp, to_additive]\ntheorem coe_copy (K : Subgroup G) (s : Set G) (hs : s = ↑K) : (K.copy s hs : Set G) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comp_range_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[to_additive]\ntheorem coe_comp_range_restrict (f : «expr →* » G N) :\n    (coe : f.range → N) ∘ («expr⇑ » f.range_restrict : G → f.range) = f :=\n  rfl\n#align coe_comp_range_restrict coe_comp_range_restrict\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, to_additive]\ntheorem coe_comap (K : Subgroup N) (f : «expr →* » G N) : (K.comap f : Set G) = «expr ⁻¹' » f K :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_center":
 "@[to_additive]\ntheorem coe_center : ↑(center G) = Set.center G :=\n  rfl\n#align coe_center coe_center\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem coe_bot : ((«expr⊥» : Subgroup G) : Set G) = {1} :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_Inf (H : Set (Subgroup G)) :\n    ((infₛ H : Subgroup G) : Set G) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "codisjoint_subgroup_of_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem codisjoint_subgroup_of_sup (H K : Subgroup G) :\n    Codisjoint (H.subgroup_of («expr ⊔ » H K)) (K.subgroup_of («expr ⊔ » H K)) :=\n  by\n  rw [codisjoint_iff, sup_subgroup_of_eq, subgroup_of_self]\n  exacts[le_sup_left, le_sup_right]\n#align codisjoint_subgroup_of_sup codisjoint_subgroup_of_sup\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print closure_univ /-\n@[simp, to_additive]\ntheorem closure_univ : closure (univ : Set G) = «expr⊤» :=\n  @coe_top G _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n-/\n\n",
 "closure_unionᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print closure_unionᵢ /-\n@[to_additive]\ntheorem closure_unionᵢ {ι} (s : ι → Set G) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (Subgroup.gi G).gc.l_supr\n#align closure_Union closure_unionᵢ\n-/\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print closure_union /-\n@[to_additive]\ntheorem closure_union (s t : Set G) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (Subgroup.gi G).gc.l_sup\n#align closure_union closure_union\n-/\n\n",
 "closure_singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem closure_singleton_one : closure ({1} : Set G) = «expr⊥» := by simp [eq_bot_iff_forall, mem_closure_singleton]\n#align closure_singleton_one closure_singleton_one\n\n",
 "closure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem closure_preimage_le (f : «expr →* » G N) (s : Set N) : closure («expr ⁻¹' » f s) ≤ (closure s).comap f :=\n  (closure_le _).2 fun x hx => by rw [SetLike.mem_coe, mem_comap] <;> exact subset_closure hx\n#align closure_preimage_le closure_preimage_le\n\n",
 "closure_preimage_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem closure_preimage_eq_top (s : Set G) : closure («expr ⁻¹' » (closure s).subtype s) = «expr⊤» :=\n  by\n  apply map_injective (closure s).subtype_injective\n  rwa [MonoidHom.map_closure, ← MonoidHom.range_eq_map, subtype_range, Set.image_preimage_eq_of_subset]\n  rw [coe_subtype, Subtype.range_coe_subtype]\n  exact subset_closure\n#align closure_preimage_eq_top closure_preimage_eq_top\n\n",
 "closure_mono":
 "#print closure_mono /-\n/-- Subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\nthen `closure h ≤ closure k`. -/\n@[to_additive\n      \"Additive subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\\nthen `closure h ≤ closure k`\"]\ntheorem closure_mono ⦃h k : Set G⦄ (h' : h ⊆ k) : closure h ≤ closure k :=\n  (Subgroup.gi G).gc.monotone_l h'\n#align closure_mono closure_mono\n-/\n\n",
 "closure_le_normal_closure":
 "theorem closure_le_normal_closure {s : Set G} : closure s ≤ normalClosure s := by\n  simp only [subset_normal_closure, closure_le]\n#align closure_le_normal_closure closure_le_normal_closure\n\n",
 "closure_le":
 "/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/\n@[simp, to_additive \"An additive subgroup `K` includes `closure k` if and only if it includes `k`\"]\ntheorem closure_le : closure k ≤ K ↔ k ⊆ K :=\n  ⟨Subset.trans subset_closure, fun h => infₛ_le h⟩\n#align closure_le closure_le\n\n",
 "closure_induction₂":
 "/-- An induction principle for closure membership for predicates with two arguments. -/\n@[elab_as_elim,\n  to_additive \"An induction principle for additive closure membership, for\\npredicates with two arguments.\"]\ntheorem closure_induction₂ {p : G → G → Prop} {x} {y : G} (hx : x ∈ closure k) (hy : y ∈ closure k)\n    (Hk : ∀ x ∈ k, ∀ y ∈ k, p x y) (H1_left : ∀ x, p 1 x) (H1_right : ∀ x, p x 1)\n    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂))\n    (Hinv_left : ∀ x y, p x y → p x⁻¹ y) (Hinv_right : ∀ x y, p x y → p x y⁻¹) : p x y :=\n  closure_induction hx (fun x xk => closure_induction hy (Hk x xk) (H1_right x) (Hmul_right x) (Hinv_right x))\n    (H1_left y) (fun z z' => Hmul_left z z' y) fun z => Hinv_left z y\n#align closure_induction₂ closure_induction₂\n\n",
 "closure_induction'":
 "/-- A dependent version of `subgroup.closure_induction`.  -/\n@[elab_as_elim, to_additive \"A dependent version of `add_subgroup.closure_induction`. \"]\ntheorem closure_induction' {p : ∀ x, x ∈ closure k → Prop} (Hs : ∀ (x) (h : x ∈ k), p x (subset_closure h))\n    (H1 : p 1 (one_mem _)) (Hmul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    (Hinv : ∀ x hx, p x hx → p x⁻¹ (inv_mem hx)) {x} (hx : x ∈ closure k) : p x hx :=\n  by\n  refine' exists.elim _ fun (hx : x ∈ closure k) (hc : p x hx) => hc\n  exact\n    closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) ⟨_, H1⟩ (fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ => ⟨_, Hmul _ _ _ _ hx hy⟩)\n      fun x ⟨hx', hx⟩ => ⟨_, Hinv _ _ hx⟩\n#align closure_induction' closure_induction'\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and\nis preserved under multiplication and inverse, then `p` holds for all elements of the closure\nof `k`. -/\n@[elab_as_elim,\n  to_additive\n      \"An induction principle for additive closure membership. If `p`\\nholds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p` holds\\nfor all elements of the additive closure of `k`.\"]\ntheorem closure_induction {p : G → Prop} {x} (h : x ∈ closure k) (Hk : ∀ x ∈ k, p x) (H1 : p 1)\n    (Hmul : ∀ x y, p x → p y → p (x * y)) (Hinv : ∀ x, p x → p x⁻¹) : p x :=\n  (@closure_le _ _ ⟨p, Hmul, H1, Hinv⟩ _).2 Hk h\n#align closure_induction closure_induction\n\n",
 "closure_eq_top_of_mclosure_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem closure_eq_top_of_mclosure_eq_top {S : Set G} (h : Submonoid.closure S = «expr⊤») : closure S = «expr⊤» :=\n  (eq_top_iff' _).2 fun x => le_closure_toSubmonoid _ <| h.symm ▸ trivial\n#align closure_eq_top_of_mclosure_eq_top closure_eq_top_of_mclosure_eq_top\n\n",
 "closure_eq_of_le":
 "@[to_additive]\ntheorem closure_eq_of_le (h₁ : k ⊆ K) (h₂ : K ≤ closure k) : closure k = K :=\n  le_antisymm ((closure_le <| K).2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem closure_eq_bot_iff (G : Type _) [Group G] (S : Set G) : closure S = «expr⊥» ↔ S ⊆ {1} :=\n  by\n  rw [← le_bot_iff]\n  exact closure_le _\n#align closure_eq_bot_iff closure_eq_bot_iff\n\n",
 "closure_eq":
 "/-- Closure of a subgroup `K` equals `K`. -/\n@[simp, to_additive \"Additive closure of an additive subgroup `K` equals `K`\"]\ntheorem closure_eq : closure (K : Set G) = K :=\n  (Subgroup.gi G).l_u_eq K\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print closure_empty /-\n@[simp, to_additive]\ntheorem closure_empty : closure (∅ : Set G) = «expr⊥» :=\n  (Subgroup.gi G).gc.l_bot\n#align closure_empty closure_empty\n-/\n\n",
 "closure_closure_coe_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem closure_closure_coe_preimage {k : Set G} : closure («expr ⁻¹' » (coe : closure k → G) k) = «expr⊤» :=\n  eq_top_iff.2 fun x =>\n    subtype.rec_on x fun x hx _ =>\n      by\n      refine' closure_induction' (fun g hg => _) _ (fun g₁ g₂ hg₁ hg₂ => _) (fun g hg => _) hx\n      · exact subset_closure hg\n      · exact one_mem _\n      · exact mul_mem\n      · exact inv_mem\n#align closure_closure_coe_preimage closure_closure_coe_preimage\n\n",
 "characteristic_iff_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem characteristic_iff_map_le : H.characteristic ↔ ∀ ϕ : «expr ≃* » G G, H.map ϕ.to_monoid_hom ≤ H :=\n  by\n  simp_rw [map_equiv_eq_comap_symm]\n  exact characteristic_iff_comap_le.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n#align characteristic_iff_map_le characteristic_iff_map_le\n\n",
 "characteristic_iff_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem characteristic_iff_map_eq : H.characteristic ↔ ∀ ϕ : «expr ≃* » G G, H.map ϕ.to_monoid_hom = H :=\n  by\n  simp_rw [map_equiv_eq_comap_symm]\n  exact characteristic_iff_comap_eq.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n#align characteristic_iff_map_eq characteristic_iff_map_eq\n\n",
 "characteristic_iff_le_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem characteristic_iff_le_map : H.characteristic ↔ ∀ ϕ : «expr ≃* » G G, H ≤ H.map ϕ.to_monoid_hom :=\n  by\n  simp_rw [map_equiv_eq_comap_symm]\n  exact characteristic_iff_le_comap.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n#align characteristic_iff_le_map characteristic_iff_le_map\n\n",
 "characteristic_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem characteristic_iff_le_comap : H.characteristic ↔ ∀ ϕ : «expr ≃* » G G, H ≤ H.comap ϕ.to_monoid_hom :=\n  characteristic_iff_comap_eq.trans\n    ⟨fun h ϕ => ge_of_eq (h ϕ), fun h ϕ =>\n      le_antisymm (fun g hg => (congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mp (h ϕ.symm hg)) (h ϕ)⟩\n#align characteristic_iff_le_comap characteristic_iff_le_comap\n\n",
 "characteristic_iff_comap_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem characteristic_iff_comap_le : H.characteristic ↔ ∀ ϕ : «expr ≃* » G G, H.comap ϕ.to_monoid_hom ≤ H :=\n  characteristic_iff_comap_eq.trans\n    ⟨fun h ϕ => le_of_eq (h ϕ), fun h ϕ =>\n      le_antisymm (h ϕ) fun g hg => h ϕ.symm ((congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mpr hg)⟩\n#align characteristic_iff_comap_le characteristic_iff_comap_le\n\n",
 "characteristic_iff_comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem characteristic_iff_comap_eq : H.characteristic ↔ ∀ ϕ : «expr ≃* » G G, H.comap ϕ.to_monoid_hom = H :=\n  ⟨characteristic.fixed, characteristic.mk⟩\n#align characteristic_iff_comap_eq characteristic_iff_comap_eq\n\n",
 "centralizer_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem centralizer_top : centralizer («expr⊤») = center G :=\n  SetLike.ext' (Set.centralizer_univ G)\n#align centralizer_top centralizer_top\n\n",
 "centralizer_le":
 "@[to_additive]\ntheorem centralizer_le (h : H ≤ K) : centralizer K ≤ centralizer H :=\n  Submonoid.centralizer_le h\n#align centralizer_le centralizer_le\n\n",
 "center_to_submonoid":
 "@[simp, to_additive]\ntheorem center_to_submonoid : (center G).to_submonoid = Submonoid.center G :=\n  rfl\n#align center_to_submonoid center_to_submonoid\n\n",
 "center_le_normalizer":
 "@[to_additive]\ntheorem center_le_normalizer : center G ≤ H.normalizer := fun x hx y => by simp [← mem_center_iff.mp hx y, mul_assoc]\n#align center_le_normalizer center_le_normalizer\n\n",
 "center_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print CommGroup.center_eq_top /-\ntheorem CommGroup.center_eq_top {G : Type _} [CommGroup G] : center G = «expr⊤» :=\n  by\n  rw [eq_top_iff']\n  intro x y\n  exact mul_comm y x\n#align comm_group.center_eq_top CommGroup.center_eq_top\n-/\n\n",
 "bot_to_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem bot_to_submonoid : («expr⊥» : Subgroup G).to_submonoid = «expr⊥» :=\n  rfl\n#align bot_to_submonoid bot_to_submonoid\n\n",
 "bot_subgroup_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem bot_subgroup_of : («expr⊥» : Subgroup G).subgroup_of H = «expr⊥» :=\n  Eq.symm (Subgroup.ext fun g => Subtype.ext_iff)\n#align bot_subgroup_of bot_subgroup_of\n\n",
 "bot_prod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem bot_prod_bot : («expr⊥» : Subgroup G).prod («expr⊥» : Subgroup N) = «expr⊥» :=\n  SetLike.coe_injective <| by simp [coe_prod, Prod.one_eq_mk]\n#align bot_prod_bot bot_prod_bot\n\n",
 "bot_or_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\n@[to_additive \"A subgroup is either the trivial subgroup or nontrivial.\"]\ntheorem bot_or_nontrivial (H : Subgroup G) : H = «expr⊥» ∨ Nontrivial H := by\n  classical\n    by_cases h : ∀ x ∈ H, x = (1 : G)\n    · left\n      exact H.eq_bot_iff_forall.mpr h\n    · right\n      simp only [not_forall] at h\n      simpa only [nontrivial_iff_exists_ne_one]\n#align bot_or_nontrivial bot_or_nontrivial\n\n",
 "bot_or_exists_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\n@[to_additive \"A subgroup is either the trivial subgroup or contains a nonzero element.\"]\ntheorem bot_or_exists_ne_one (H : Subgroup G) : H = «expr⊥» ∨ ∃ x ∈ H, x ≠ (1 : G) :=\n  by\n  convert H.bot_or_nontrivial\n  rw [nontrivial_iff_exists_ne_one]\n#align bot_or_exists_ne_one bot_or_exists_ne_one\n\n",
 "apply_coe_mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem apply_coe_mem_map (f : «expr →* » G N) (K : Subgroup G) (x : K) : f x ∈ K.map f :=\n  mem_map_of_mem f x.prop\n#align apply_coe_mem_map apply_coe_mem_map\n\n"}