{"prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print prod_mem /-\n/-- Product of elements of a subgroup of a `comm_group` indexed by a `finset` is in the\n    subgroup. -/\n@[to_additive\n      \"Sum of elements in an `add_subgroup` of an `add_comm_group` indexed by a `finset`\\nis in the `add_subgroup`.\"]\nprotected theorem prod_mem {G : Type _} [CommGroup G] (K : Subgroup G) {ι : Type _} {t : Finset ι} {f : ι → G}\n    (h : ∀ c ∈ t, f c ∈ K) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f c) ∈ K :=\n  prod_mem h\n#align prod_mem prod_mem\n#align sum_mem sum_mem\n-/\n\n",
 "pi_mem_of_mul_single_mem_aux":
 "@[to_additive]\ntheorem pi_mem_of_mul_single_mem_aux [DecidableEq η] (I : Finset η) {H : Subgroup (∀ i, f i)} (x : ∀ i, f i)\n    (h1 : ∀ i, i ∉ I → x i = 1) (h2 : ∀ i, i ∈ I → Pi.mulSingle i (x i) ∈ H) : x ∈ H :=\n  by\n  induction' I using Finset.induction_on with i I hnmem ih generalizing x\n  · convert one_mem H\n    ext i\n    exact h1 i (not_mem_empty i)\n  · have : x = Function.update x i 1 * Pi.mulSingle i (x i) :=\n      by\n      ext j\n      by_cases heq : j = i\n      · subst HEq\n        simp\n      · simp [HEq]\n    rw [this]\n    clear this\n    apply mul_mem\n    · apply ih <;> clear ih\n      · intro j hj\n        by_cases heq : j = i\n        · subst HEq\n          simp\n        · simp [HEq]\n          apply h1 j\n          simpa [HEq] using hj\n      · intro j hj\n        have : j ≠ i := by\n          rintro rfl\n          contradiction\n        simp [this]\n        exact h2 _ (Finset.mem_insert_of_mem hj)\n    · apply h2\n      simp\n#align pi_mem_of_mul_single_mem_aux pi_mem_of_mul_single_mem_aux\n\n",
 "pi_mem_of_mul_single_mem":
 "@[to_additive]\ntheorem pi_mem_of_mul_single_mem [Finite η] [DecidableEq η] {H : Subgroup (∀ i, f i)} (x : ∀ i, f i)\n    (h : ∀ i, Pi.mulSingle i (x i) ∈ H) : x ∈ H :=\n  by\n  cases nonempty_fintype η\n  exact pi_mem_of_mul_single_mem_aux Finset.univ x (by simp) fun i _ => h i\n#align pi_mem_of_mul_single_mem pi_mem_of_mul_single_mem\n\n",
 "pi_le_iff":
 "/-- For finite index types, the `subgroup.pi` is generated by the embeddings of the groups.  -/\n@[to_additive \"For finite index types, the `subgroup.pi` is generated by the embeddings of the\\nadditive groups.\"]\ntheorem pi_le_iff [DecidableEq η] [Finite η] {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :\n    pi univ H ≤ J ↔ ∀ i : η, map (MonoidHom.single f i) (H i) ≤ J :=\n  by\n  constructor\n  · rintro h i _ ⟨x, hx, rfl⟩\n    apply h\n    simpa using hx\n  · exact fun h x hx => pi_mem_of_mul_single_mem x fun i => h i (mem_map_of_mem _ (hx i trivial))\n#align pi_le_iff pi_le_iff\n\n",
 "one_lt_card_iff_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem one_lt_card_iff_ne_bot [Fintype H] : 1 < Fintype.card H ↔ H ≠ «expr⊥» :=\n  lt_iff_not_le.trans H.card_le_one_iff_eq_bot.not\n#align one_lt_card_iff_ne_bot one_lt_card_iff_ne_bot\n\n",
 "noncomm_prod_mem":
 "@[to_additive]\ntheorem noncomm_prod_mem (K : Subgroup G) {ι : Type _} {t : Finset ι} {f : ι → G} (comm) :\n    (∀ c ∈ t, f c ∈ K) → t.noncomm_prod f comm ∈ K :=\n  K.to_submonoid.noncomm_prod_mem t f comm\n#align noncomm_prod_mem noncomm_prod_mem\n\n",
 "multiset_prod_mem":
 "#print multiset_prod_mem /-\n/-- Product of a multiset of elements in a subgroup of a `comm_group` is in the subgroup. -/\n@[to_additive \"Sum of a multiset of elements in an `add_subgroup` of an `add_comm_group`\\nis in the `add_subgroup`.\"]\nprotected theorem multiset_prod_mem {G} [CommGroup G] (K : Subgroup G) (g : Multiset G) :\n    (∀ a ∈ g, a ∈ K) → g.prod ∈ K :=\n  multiset_prod_mem g\n#align multiset_prod_mem multiset_prod_mem\n#align multiset_sum_mem multiset_sum_mem\n-/\n\n",
 "multiset_noncomm_prod_mem":
 "@[to_additive]\ntheorem multiset_noncomm_prod_mem (K : Subgroup G) (g : Multiset G) (comm) :\n    (∀ a ∈ g, a ∈ K) → g.noncomm_prod comm ∈ K :=\n  K.to_submonoid.multiset_noncomm_prod_mem g comm\n#align multiset_noncomm_prod_mem multiset_noncomm_prod_mem\n\n",
 "mem_normalizer_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_normalizer_fintype {S : Set G} [Finite S] {x : G} (h : ∀ n, n ∈ S → x * n * x⁻¹ ∈ S) :\n    x ∈ Subgroup.setNormalizer S := by\n  haveI := classical.prop_decidable <;> cases nonempty_fintype S <;>\n      haveI := Set.fintypeImage S fun n => x * n * x⁻¹ <;>\n    exact fun n =>\n      ⟨h n, fun h₁ =>\n        have heq : «expr '' » (fun n => x * n * x⁻¹) S = S :=\n          Set.eq_of_subset_of_card_le (fun n ⟨y, hy⟩ => hy.2 ▸ h y hy.1)\n            (by rw [Set.card_image_of_injective S conj_injective])\n        have : x * n * x⁻¹ ∈ «expr '' » (fun n => x * n * x⁻¹) S := HEq.symm ▸ h₁\n        let ⟨y, hy⟩ := this\n        conj_injective hy.2 ▸ hy.1⟩\n#align mem_normalizer_fintype mem_normalizer_fintype\n\n",
 "list_prod_mem":
 "#print list_prod_mem /-\n/-\nCopyright (c) 2020 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\n@[to_additive \"Sum of a list of elements in an `add_subgroup` is in the `add_subgroup`.\"]\nprotected theorem list_prod_mem {l : List G} : (∀ x ∈ l, x ∈ K) → l.prod ∈ K :=\n  list_prod_mem\n#align list_prod_mem list_prod_mem\n#align list_sum_mem list_sum_mem\n-/\n\n",
 "eq_top_of_le_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_top_of_le_card [Fintype H] [Fintype G] (h : Fintype.card G ≤ Fintype.card H) : H = «expr⊤» :=\n  eq_top_of_card_eq H (le_antisymm (Fintype.card_le_of_injective coe Subtype.coe_injective) h)\n#align eq_top_of_le_card eq_top_of_le_card\n\n",
 "eq_top_of_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_top_of_card_eq [Fintype H] [Fintype G] (h : Fintype.card H = Fintype.card G) : H = «expr⊤» :=\n  by\n  haveI : Fintype (H : Set G) := ‹Fintype H›\n  rw [SetLike.ext'_iff, coe_top, ← Finset.coe_univ, ← (H : Set G).coe_to_finset, Finset.coe_inj, ←\n    Finset.card_eq_iff_eq_univ, ← h, Set.toFinset_card]\n  congr\n#align eq_top_of_card_eq eq_top_of_card_eq\n\n",
 "eq_bot_of_card_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem eq_bot_of_card_le [Fintype H] (h : Fintype.card H ≤ 1) : H = «expr⊥» :=\n  let _ := Fintype.card_le_one_iff_subsingleton.mp h\n  eq_bot_of_subsingleton H\n#align eq_bot_of_card_le eq_bot_of_card_le\n\n",
 "eq_bot_of_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem eq_bot_of_card_eq [Fintype H] (h : Fintype.card H = 1) : H = «expr⊥» :=\n  H.eq_bot_of_card_le (le_of_eq h)\n#align eq_bot_of_card_eq eq_bot_of_card_eq\n\n",
 "coe_multiset_prod":
 "@[simp, norm_cast, to_additive]\ntheorem coe_multiset_prod {G} [CommGroup G] (H : Subgroup G) (m : Multiset H) : (m.prod : G) = (m.map coe).prod :=\n  SubmonoidClass.coe_multiset_prod m\n#align coe_multiset_prod coe_multiset_prod\n\n",
 "coe_list_prod":
 "@[simp, norm_cast, to_additive]\ntheorem coe_list_prod (l : List H) : (l.prod : G) = (l.map coe).prod :=\n  SubmonoidClass.coe_list_prod l\n#align coe_list_prod coe_list_prod\n\n",
 "coe_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, norm_cast, to_additive]\ntheorem coe_finset_prod {ι G} [CommGroup G] (H : Subgroup G) (f : ι → H) (s : Finset ι) :\n    ↑(finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) : G) :=\n  SubmonoidClass.coe_finset_prod f s\n#align coe_finset_prod coe_finset_prod\n\n",
 "card_le_one_iff_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem card_le_one_iff_eq_bot [Fintype H] : Fintype.card H ≤ 1 ↔ H = «expr⊥» :=\n  ⟨fun h => (eq_bot_iff_forall _).2 fun x hx => by simpa [Subtype.ext_iff] using Fintype.card_le_one_iff.1 h ⟨x, hx⟩ 1,\n    fun h => by simp [h]⟩\n#align card_le_one_iff_eq_bot card_le_one_iff_eq_bot\n\n",
 "card_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- curly brackets `{}` are used here instead of instance brackets `[]` because\n  the instance in a goal is often not the same as the one inferred by type class inference.  -/\n@[simp, to_additive]\ntheorem card_bot {_ : Fintype («expr↥ » («expr⊥» : Subgroup G))} : Fintype.card («expr⊥» : Subgroup G) = 1 :=\n  Fintype.card_eq_one_iff.2 ⟨⟨(1 : G), Set.mem_singleton 1⟩, fun ⟨y, hy⟩ => Subtype.eq <| Subgroup.mem_bot.1 hy⟩\n#align card_bot card_bot\n\n"}