{"supr_induction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A dependent version of `subgroup.supr_induction`. -/\n@[elab_as_elim, to_additive \"A dependent version of `add_subgroup.supr_induction`. \"]\ntheorem supr_induction' {ι : Sort _} (S : ι → subgroup G)\n    {C :\n      ∀ x,\n        x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) →\n          Prop}\n    (hp : ∀ (i), ∀ x ∈ S i, C x (mem_supr_of_mem i ‹_›)) (h1 : C 1 (one_mem _))\n    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i)) :\n    C x hx :=\n  by\n  refine'\n    exists.elim _\n      fun\n        (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i))\n        (hc : C x hx) =>\n      hc\n  refine' supr_induction S hx (fun i x hx => _) _ fun x y => _\n  · exact ⟨_, hp _ _ hx⟩\n  · exact ⟨_, h1⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    refine' ⟨_, hmul _ _ _ _ Cx Cy⟩\n#align supr_induction' supr_induction'\n\n",
 "supr_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[elab_as_elim,\n  to_additive\n      \" An induction principle for elements of `⨆ i, S i`.\\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\\nthen it holds for all elements of the supremum of `S`. \"]\ntheorem supr_induction {ι : Sort _} (S : ι → subgroup G) {C : G → Prop} {x : G}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i))\n    (hp : ∀ (i), ∀ x ∈ S i, C x) (h1 : C 1) (hmul : ∀ x y, C x → C y → C (x * y)) : C x :=\n  by\n  rw [supr_eq_closure] at hx\n  refine' closure_induction'' hx (fun x hx => _) (fun x hx => _) h1 hmul\n  · obtain ⟨i, hi⟩ := set.mem_Union.mp hx\n    exact hp _ _ hi\n  · obtain ⟨i, hi⟩ := set.mem_Union.mp hx\n    exact hp _ _ (inv_mem hi)\n#align supr_induction supr_induction\n\n",
 "sup_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem sup_eq_closure (H K : subgroup G) : «expr ⊔ » H K = closure (H * K) :=\n  le_antisymm\n    (sup_le (fun h hh => subset_closure ⟨h, 1, hh, K.one_mem, mul_one h⟩) fun k hk =>\n      subset_closure ⟨1, k, H.one_mem, hk, one_mul k⟩)\n    (by conv_rhs => rw [← closure_eq H, ← closure_eq K] <;> apply closure_mul_le)\n#align sup_eq_closure sup_eq_closure\n\n",
 "subset_pointwise_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem subset_pointwise_smul_iff {a : α} {S T : subgroup G} : S ≤ «expr • » a T ↔ «expr • » a⁻¹ S ≤ T :=\n  subset_set_smul_iff\n#align subset_pointwise_smul_iff subset_pointwise_smul_iff\n\n",
 "subgroup_mul_singleton":
 "theorem subgroup_mul_singleton {H : subgroup G} {h : G} (hh : h ∈ H) : (H : set G) * {h} = H :=\n  by\n  refine' le_antisymm _ fun h' hh' => ⟨h' * h⁻¹, h, H.mul_mem hh' (H.inv_mem hh), rfl, inv_mul_cancel_right h' h⟩\n  rintro _ ⟨h', h, hh', rfl : _ = _, rfl⟩\n  exact H.mul_mem hh' hh\n#align subgroup_mul_singleton subgroup_mul_singleton\n\n",
 "smul_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_sup (a : α) (S T : subgroup G) : «expr • » a («expr ⊔ » S T) = «expr ⊔ » («expr • » a S) («expr • » a T) :=\n  map_sup _ _ _\n#align smul_sup smul_sup\n\n",
 "smul_opposite_image_mul_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_opposite_image_mul_preimage {H : subgroup G} (g : G) (h : H.opposite) (s : set G) :\n    «expr '' » (fun y => «expr • » h y) («expr ⁻¹' » (has_mul.mul g) s) =\n      «expr ⁻¹' » (has_mul.mul g) («expr '' » (fun y => «expr • » h y) s) :=\n  by\n  ext x\n  cases h\n  simp [(«expr • » · ·), mul_assoc]\n#align smul_opposite_image_mul_preimage smul_opposite_image_mul_preimage\n\n",
 "smul_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_normal (g : G) (H : subgroup G) [h : normal H] : «expr • » (MulAut.conj g) H = H :=\n  h.conj_act g\n#align smul_normal smul_normal\n\n",
 "smul_mem_pointwise_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_mem_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : add_subgroup A) (x : A) :\n    «expr • » a x ∈ «expr • » a S ↔ x ∈ S :=\n  smul_mem_smul_set_iff₀ ha (S : set A) x\n#align smul_mem_pointwise_smul_iff₀ smul_mem_pointwise_smul_iff₀\n\n",
 "smul_mem_pointwise_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : α} {S : add_subgroup A} {x : A} : «expr • » a x ∈ «expr • » a S ↔ x ∈ S :=\n  smul_mem_smul_set_iff\n#align smul_mem_pointwise_smul_iff smul_mem_pointwise_smul_iff\n\n",
 "smul_mem_pointwise_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_mem_pointwise_smul (m : A) (a : α) (S : add_subgroup A) : m ∈ S → «expr • » a m ∈ «expr • » a S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ «expr • » a (S : set A))\n#align smul_mem_pointwise_smul smul_mem_pointwise_smul\n\n",
 "smul_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_inf (a : α) (S T : subgroup G) : «expr • » a («expr ⊓ » S T) = «expr ⊓ » («expr • » a S) («expr • » a T) :=\n  by simp [SetLike.ext_iff, mem_pointwise_smul_iff_inv_smul_mem]\n#align smul_inf smul_inf\n\n",
 "smul_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_closure (a : α) (s : set G) : «expr • » a (closure s) = closure («expr • » a s) :=\n  monoid_hom.map_closure _ _\n#align smul_closure smul_closure\n\n",
 "smul_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem smul_bot (a : α) : «expr • » a («expr⊥» : subgroup G) = «expr⊥» :=\n  map_bot _\n#align smul_bot smul_bot\n\n",
 "singleton_mul_subgroup":
 "theorem singleton_mul_subgroup {H : subgroup G} {h : G} (hh : h ∈ H) : {h} * (H : set G) = H :=\n  by\n  refine' le_antisymm _ fun h' hh' => ⟨h, h⁻¹ * h', rfl, H.mul_mem (H.inv_mem hh) hh', mul_inv_cancel_left h h'⟩\n  rintro _ ⟨h, h', rfl : _ = _, hh', rfl⟩\n  exact H.mul_mem hh hh'\n#align singleton_mul_subgroup singleton_mul_subgroup\n\n",
 "pointwise_smul_to_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem pointwise_smul_to_submonoid (a : α) (S : subgroup G) :\n    («expr • » a S).to_submonoid = «expr • » a S.to_submonoid :=\n  rfl\n#align pointwise_smul_to_submonoid pointwise_smul_to_submonoid\n\n",
 "pointwise_smul_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem pointwise_smul_to_add_submonoid (a : α) (S : add_subgroup A) :\n    («expr • » a S).to_add_submonoid = «expr • » a S.to_add_submonoid :=\n  rfl\n#align pointwise_smul_to_add_submonoid pointwise_smul_to_add_submonoid\n\n",
 "pointwise_smul_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pointwise_smul_subset_iff {a : α} {S T : subgroup G} : «expr • » a S ≤ T ↔ S ≤ «expr • » a⁻¹ T :=\n  set_smul_subset_iff\n#align pointwise_smul_subset_iff pointwise_smul_subset_iff\n\n",
 "pointwise_smul_le_pointwise_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : add_subgroup A} :\n    «expr • » a S ≤ «expr • » a T ↔ S ≤ T :=\n  set_smul_subset_set_smul_iff₀ ha\n#align pointwise_smul_le_pointwise_smul_iff₀ pointwise_smul_le_pointwise_smul_iff₀\n\n",
 "pointwise_smul_le_pointwise_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : α} {S T : add_subgroup A} : «expr • » a S ≤ «expr • » a T ↔ S ≤ T :=\n  set_smul_subset_set_smul_iff\n#align pointwise_smul_le_pointwise_smul_iff pointwise_smul_le_pointwise_smul_iff\n\n",
 "pointwise_smul_le_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pointwise_smul_le_iff₀ {a : α} (ha : a ≠ 0) {S T : add_subgroup A} : «expr • » a S ≤ T ↔ S ≤ «expr • » a⁻¹ T :=\n  set_smul_subset_iff₀ ha\n#align pointwise_smul_le_iff₀ pointwise_smul_le_iff₀\n\n",
 "pointwise_smul_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pointwise_smul_le_iff {a : α} {S T : add_subgroup A} : «expr • » a S ≤ T ↔ S ≤ «expr • » a⁻¹ T :=\n  set_smul_subset_iff\n#align pointwise_smul_le_iff pointwise_smul_le_iff\n\n",
 "pointwise_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pointwise_smul_def {a : α} (S : subgroup G) : «expr • » a S = S.map (MulDistribMulAction.toMonoidEnd _ _ a) :=\n  rfl\n#align pointwise_smul_def pointwise_smul_def\n\n",
 "normal_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The carrier of `N ⊔ H` is just `↑N * ↑H` (pointwise set product) when `N` is normal. -/\n@[to_additive \"The carrier of `N ⊔ H` is just `↑N + ↑H` (pointwise set addition)\\nwhen `N` is normal.\"]\ntheorem normal_mul (N H : subgroup G) [N.normal] : (↑(«expr ⊔ » N H) : set G) = N * H :=\n  Set.Subset.antisymm\n    (show «expr ⊔ » N H ≤ normal_mul_aux N H by\n      rw [sup_eq_closure]\n      apply infₛ_le _\n      dsimp\n      rfl)\n    ((sup_eq_closure N H).symm ▸ subset_closure)\n#align normal_mul normal_mul\n\n",
 "mul_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The carrier of `H ⊔ N` is just `↑H * ↑N` (pointwise set product) when `N` is normal. -/\n@[to_additive \"The carrier of `H ⊔ N` is just `↑H + ↑N` (pointwise set addition)\\nwhen `N` is normal.\"]\ntheorem mul_normal (H N : subgroup G) [N.normal] : (↑(«expr ⊔ » H N) : set G) = H * N :=\n  Set.Subset.antisymm\n    (show «expr ⊔ » H N ≤ mul_normal_aux H N by\n      rw [sup_eq_closure]\n      apply infₛ_le _\n      dsimp\n      rfl)\n    ((sup_eq_closure H N).symm ▸ subset_closure)\n#align mul_normal mul_normal\n\n",
 "mul_inf_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem mul_inf_assoc (A B C : subgroup G) (h : A ≤ C) : (A : set G) * ↑(«expr ⊓ » B C) = «expr ⊓ » (A * B) C :=\n  by\n  ext\n  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]\n  constructor\n  · rintro ⟨y, z, hy, ⟨hzB, hzC⟩, rfl⟩\n    refine' ⟨_, mul_mem (h hy) hzC⟩\n    exact ⟨y, z, hy, hzB, rfl⟩\n  rintro ⟨⟨y, z, hy, hz, rfl⟩, hyz⟩\n  refine' ⟨y, z, hy, ⟨hz, _⟩, rfl⟩\n  suffices y⁻¹ * (y * z) ∈ C by simpa\n  exact mul_mem (inv_mem (h hy)) hyz\n#align mul_inf_assoc mul_inf_assoc\n\n",
 "mem_smul_pointwise_iff_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_smul_pointwise_iff_exists (m : A) (a : α) (S : add_subgroup A) :\n    m ∈ «expr • » a S ↔ ∃ s : A, s ∈ S ∧ «expr • » a s = m :=\n  (Set.mem_smul_set : m ∈ «expr • » a (S : set A) ↔ _)\n#align mem_smul_pointwise_iff_exists mem_smul_pointwise_iff_exists\n\n",
 "mem_pointwise_smul_iff_inv_smul_mem₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_pointwise_smul_iff_inv_smul_mem₀ {a : α} (ha : a ≠ 0) (S : add_subgroup A) (x : A) :\n    x ∈ «expr • » a S ↔ «expr • » a⁻¹ x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem₀ ha (S : set A) x\n#align mem_pointwise_smul_iff_inv_smul_mem₀ mem_pointwise_smul_iff_inv_smul_mem₀\n\n",
 "mem_pointwise_smul_iff_inv_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_pointwise_smul_iff_inv_smul_mem {a : α} {S : add_subgroup A} {x : A} :\n    x ∈ «expr • » a S ↔ «expr • » a⁻¹ x ∈ S :=\n  mem_smul_set_iff_inv_smul_mem\n#align mem_pointwise_smul_iff_inv_smul_mem mem_pointwise_smul_iff_inv_smul_mem\n\n",
 "mem_inv_pointwise_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_inv_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) (S : add_subgroup A) (x : A) :\n    x ∈ «expr • » a⁻¹ S ↔ «expr • » a x ∈ S :=\n  mem_inv_smul_set_iff₀ ha (S : set A) x\n#align mem_inv_pointwise_smul_iff₀ mem_inv_pointwise_smul_iff₀\n\n",
 "mem_inv_pointwise_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_inv_pointwise_smul_iff {a : α} {S : add_subgroup A} {x : A} : x ∈ «expr • » a⁻¹ S ↔ «expr • » a x ∈ S :=\n  mem_inv_smul_set_iff\n#align mem_inv_pointwise_smul_iff mem_inv_pointwise_smul_iff\n\n",
 "le_pointwise_smul_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_pointwise_smul_iff₀ {a : α} (ha : a ≠ 0) {S T : add_subgroup A} : S ≤ «expr • » a T ↔ «expr • » a⁻¹ S ≤ T :=\n  subset_set_smul_iff₀ ha\n#align le_pointwise_smul_iff₀ le_pointwise_smul_iff₀\n\n",
 "le_pointwise_smul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_pointwise_smul_iff {a : α} {S T : add_subgroup A} : S ≤ «expr • » a T ↔ «expr • » a⁻¹ S ≤ T :=\n  subset_set_smul_iff\n#align le_pointwise_smul_iff le_pointwise_smul_iff\n\n",
 "inv_subset_closure":
 "@[simp, to_additive]\ntheorem inv_subset_closure (S : set G) : S⁻¹ ⊆ closure S := fun s hs =>\n  by\n  rw [SetLike.mem_coe, ← subgroup.inv_mem_iff]\n  exact subset_closure (mem_inv.mp hs)\n#align inv_subset_closure inv_subset_closure\n\n",
 "inv_coe_set":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp, to_additive]\ntheorem inv_coe_set [SetLike S G] [subgroup_class S G] {H : S} : (H : set G)⁻¹ = H :=\n  by\n  ext\n  simp\n#align inv_coe_set inv_coe_set\n\n",
 "inf_mul_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem inf_mul_assoc (A B C : subgroup G) (h : C ≤ A) :\n    ((«expr ⊓ » A B : subgroup G) : set G) * C = «expr ⊓ » A (B * C) :=\n  by\n  ext\n  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]\n  constructor\n  · rintro ⟨y, z, ⟨hyA, hyB⟩, hz, rfl⟩\n    refine' ⟨A.mul_mem hyA (h hz), _⟩\n    exact ⟨y, z, hyB, hz, rfl⟩\n  rintro ⟨hyz, y, z, hy, hz, rfl⟩\n  refine' ⟨y, z, ⟨_, hy⟩, hz, rfl⟩\n  suffices y * z * z⁻¹ ∈ A by simpa\n  exact mul_mem hyz (inv_mem (h hz))\n#align inf_mul_assoc inf_mul_assoc\n\n",
 "conj_smul_subgroup_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem conj_smul_subgroup_of {P H : subgroup G} (hP : P ≤ H) (h : H) :\n    «expr • » (MulAut.conj h) (P.subgroup_of H) = («expr • » (MulAut.conj (h : G)) P).subgroup_of H :=\n  by\n  refine' le_antisymm _ _\n  · rintro - ⟨g, hg, rfl⟩\n    exact ⟨g, hg, rfl⟩\n  · rintro p ⟨g, hg, hp⟩\n    exact ⟨⟨g, hP hg⟩, hg, subtype.ext hp⟩\n#align conj_smul_subgroup_of conj_smul_subgroup_of\n\n",
 "conj_smul_le_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem conj_smul_le_of_le {P H : subgroup G} (hP : P ≤ H) (h : H) : «expr • » (MulAut.conj (h : G)) P ≤ H :=\n  by\n  rintro - ⟨g, hg, rfl⟩\n  exact H.mul_mem (H.mul_mem h.2 (hP hg)) (H.inv_mem h.2)\n#align conj_smul_le_of_le conj_smul_le_of_le\n\n",
 "conj_act":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem normal.conj_act {G : Type _} [group G] {H : subgroup G} (hH : H.normal) (g : conj_act G) : «expr • » g H = H :=\n  by\n  ext\n  constructor\n  · intro h\n    have := hH.conj_mem («expr • » g⁻¹ x) _ (conj_act.of_conj_act g)\n    rw [subgroup.mem_pointwise_smul_iff_inv_smul_mem] at h\n    dsimp at *\n    rw [conj_act.smul_def] at *\n    simp only [conj_act.of_conj_act_inv, conj_act.of_conj_act_to_conj_act, inv_inv] at *\n    convert this\n    simp only [← mul_assoc, mul_right_inv, one_mul, mul_inv_cancel_right]\n    rw [subgroup.mem_pointwise_smul_iff_inv_smul_mem] at h\n    exact h\n  · intro h\n    rw [subgroup.mem_pointwise_smul_iff_inv_smul_mem, conj_act.smul_def]\n    apply hH.conj_mem\n    exact h\n#align normal.conj_act normal.conj_act\n\n",
 "coe_pointwise_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_pointwise_smul (a : α) (S : add_subgroup A) : ↑(«expr • » a S) = «expr • » a (S : set A) :=\n  rfl\n#align coe_pointwise_smul coe_pointwise_smul\n\n",
 "closure_to_submonoid":
 "@[to_additive]\ntheorem closure_to_submonoid (S : set G) : (closure S).to_submonoid = Submonoid.closure (S ∪ S⁻¹) :=\n  by\n  refine' le_antisymm (fun x hx => _) (Submonoid.closure_le.2 _)\n  · refine'\n      closure_induction hx (fun x hx => Submonoid.closure_mono (subset_union_left S S⁻¹) (Submonoid.subset_closure hx))\n        (Submonoid.one_mem _) (fun x y hx hy => Submonoid.mul_mem _ hx hy) fun x hx => _\n    rwa [← submonoid.mem_closure_inv, Set.union_inv, inv_inv, Set.union_comm]\n  · simp only [true_and_iff, coe_to_submonoid, union_subset_iff, subset_closure, inv_subset_closure]\n#align closure_to_submonoid closure_to_submonoid\n\n",
 "closure_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem closure_mul_le (S T : set G) : closure (S * T) ≤ «expr ⊔ » (closure S) (closure T) :=\n  infₛ_le fun x ⟨s, t, hs, ht, hx⟩ =>\n    hx ▸\n      («expr ⊔ » (closure S) (closure T)).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)\n        (SetLike.le_def.mp le_sup_right <| subset_closure ht)\n#align closure_mul_le closure_mul_le\n\n",
 "closure_inv":
 "@[simp, to_additive]\ntheorem closure_inv (s : set G) : closure s⁻¹ = closure s := by\n  simp only [← to_submonoid_eq, closure_to_submonoid, inv_inv, union_comm]\n#align closure_inv closure_inv\n\n",
 "closure_induction_right":
 "@[to_additive]\ntheorem closure_induction_right {p : G → Prop} {x : G} (h : x ∈ closure s) (H1 : p 1)\n    (Hmul : ∀ (x), ∀ y ∈ s, p x → p (x * y)) (Hinv : ∀ (x), ∀ y ∈ s, p x → p (x * y⁻¹)) : p x :=\n  let key := (closure_to_submonoid s).le\n  submonoid.closure_induction_right (key h) H1 fun x y hy =>\n    hy.elim (Hmul x y) fun hy hx => (congr_arg _ <| inv_inv y).mp <| Hinv x y⁻¹ hy hx\n#align closure_induction_right closure_induction_right\n\n",
 "closure_induction_left":
 "@[to_additive]\ntheorem closure_induction_left {p : G → Prop} {x : G} (h : x ∈ closure s) (H1 : p 1)\n    (Hmul : ∀ x ∈ s, ∀ (y), p y → p (x * y)) (Hinv : ∀ x ∈ s, ∀ (y), p y → p (x⁻¹ * y)) : p x :=\n  let key := (closure_to_submonoid s).le\n  submonoid.closure_induction_left (key h) H1 fun x hx =>\n    hx.elim (Hmul x) fun hx y hy => (congr_arg _ <| inv_inv x).mp <| Hinv x⁻¹ hx y hy\n#align closure_induction_left closure_induction_left\n\n",
 "closure_induction''":
 "/-- An induction principle for closure membership. If `p` holds for `1` and all elements of\n`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of\nthe closure of `k`. -/\n@[to_additive\n      \"An induction principle for additive closure membership. If `p` holds for `0` and all\\nelements of `k` and their negation, and is preserved under addition, then `p` holds for all\\nelements of the additive closure of `k`.\"]\ntheorem closure_induction'' {p : G → Prop} {x} (h : x ∈ closure s) (Hk : ∀ x ∈ s, p x) (Hk_inv : ∀ x ∈ s, p x⁻¹)\n    (H1 : p 1) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  closure_induction_left h H1 (fun x hx y hy => Hmul x y (Hk x hx) hy) fun x hx y => Hmul x⁻¹ y <| Hk_inv x hx\n#align closure_induction'' closure_induction''\n\n"}