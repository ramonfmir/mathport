{"inv_card_commutator_le_comm_prob":
 "theorem inv_card_commutator_le_comm_prob : (↑(nat.card (commutator G)))⁻¹ ≤ comm_prob G :=\n  (inv_pos_le_iff_one_le_mul (nat.cast_pos.mpr finite.card_pos)).mpr\n    (le_trans (ge_of_eq (comm_prob_eq_one_iff.mpr (abelianization.comm_group G).mul_comm))\n      (commutator G).comm_prob_quotient_le)\n#align inv_card_commutator_le_comm_prob inv_card_commutator_le_comm_prob\n\n",
 "comm_prob_subgroup_le":
 "theorem subgroup.comm_prob_subgroup_le : comm_prob H ≤ comm_prob G * H.index ^ 2 :=\n  by\n  /- After rewriting with `comm_prob_def`, we reduce to showing that `G` has at least as many\n      commuting pairs as `H`. -/\n  rw [comm_prob_def, comm_prob_def, div_le_iff, mul_assoc, ← mul_pow, ← nat.cast_mul, mul_comm H.index,\n    H.card_mul_index, div_mul_cancel, nat.cast_le]\n  · refine' finite.card_le_of_injective (fun p => ⟨⟨p.1.1, p.1.2⟩, subtype.ext_iff.mp p.2⟩) _\n    exact fun p q h => by simpa only [subtype.ext_iff, prod.ext_iff] using h\n  · exact pow_ne_zero 2 (nat.cast_ne_zero.mpr finite.card_pos.ne')\n  · exact pow_pos (nat.cast_pos.mpr finite.card_pos) 2\n#align subgroup.comm_prob_subgroup_le subgroup.comm_prob_subgroup_le\n\n",
 "comm_prob_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem subgroup.comm_prob_quotient_le [H.normal] : comm_prob («expr ⧸ » G H) ≤ comm_prob G * nat.card H :=\n  by\n  /- After rewriting with `comm_prob_def'`, we reduce to showing that `G` has at least as many\n      conjugacy classes as `G ⧸ H`. -/\n  rw [comm_prob_def', comm_prob_def', div_le_iff, mul_assoc, ← nat.cast_mul, ← subgroup.index, H.card_mul_index,\n    div_mul_cancel, nat.cast_le]\n  · apply finite.card_le_of_surjective\n    show function.surjective (ConjClasses.map (quotient_group.mk' H))\n    exact ConjClasses.map_surjective Quotient.surjective_Quotient_mk''\n  · exact nat.cast_ne_zero.mpr finite.card_pos.ne'\n  · exact nat.cast_pos.mpr finite.card_pos\n#align subgroup.comm_prob_quotient_le subgroup.comm_prob_quotient_le\n\n",
 "comm_prob_pos":
 "theorem comm_prob_pos [h : nonempty M] : 0 < comm_prob M :=\n  h.elim fun x =>\n    div_pos (nat.cast_pos.mpr (finite.card_pos_iff.mpr ⟨⟨(x, x), rfl⟩⟩)) (pow_pos (nat.cast_pos.mpr finite.card_pos) 2)\n#align comm_prob_pos comm_prob_pos\n\n",
 "comm_prob_le_one":
 "theorem comm_prob_le_one : comm_prob M ≤ 1 :=\n  by\n  refine' div_le_one_of_le _ (sq_nonneg (nat.card M))\n  rw [← Nat.cast_pow, nat.cast_le, sq, ← nat.card_prod]\n  apply finite.card_subtype_le\n#align comm_prob_le_one comm_prob_le_one\n\n",
 "comm_prob_eq_one_iff":
 "theorem comm_prob_eq_one_iff [h : nonempty M] : comm_prob M = 1 ↔ commutative ((· * ·) : M → M → M) :=\n  by\n  haveI := fintype.of_finite M\n  rw [comm_prob, ← Set.coe_setOf, nat.card_eq_fintype_card, nat.card_eq_fintype_card]\n  rw [div_eq_one_iff_eq, ← Nat.cast_pow, Nat.cast_inj, sq, ← card_prod, set_fintype_card_eq_univ_iff,\n    Set.eq_univ_iff_forall]\n  · exact ⟨fun h x y => h (x, y), fun h x => h x.1 x.2⟩\n  · exact pow_ne_zero 2 (nat.cast_ne_zero.mpr card_ne_zero)\n#align comm_prob_eq_one_iff comm_prob_eq_one_iff\n\n",
 "comm_prob_def'":
 "theorem comm_prob_def' : comm_prob G = nat.card (ConjClasses G) / nat.card G :=\n  by\n  rw [comm_prob, card_comm_eq_card_conj_classes_mul_card, nat.cast_mul, sq]\n  exact mul_div_mul_right _ _ (nat.cast_ne_zero.mpr finite.card_pos.ne')\n#align comm_prob_def' comm_prob_def'\n\n",
 "comm_prob_def":
 "/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem comm_prob_def : comm_prob M = nat.card { p : M × M // p.1 * p.2 = p.2 * p.1 } / nat.card M ^ 2 :=\n  rfl\n#align comm_prob_def comm_prob_def\n\n",
 "card_comm_eq_card_conj_classes_mul_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem card_comm_eq_card_conj_classes_mul_card :\n    nat.card { p : G × G // p.1 * p.2 = p.2 * p.1 } = nat.card (ConjClasses G) * nat.card G :=\n  by\n  haveI := fintype.of_finite G\n  simp only [nat.card_eq_fintype_card]\n  convert\n    calc\n      card { p : G × G // p.1 * p.2 = p.2 * p.1 } = card (Σg, { h // g * h = h * g }) :=\n        card_congr (Equiv.subtypeProdEquivSigmaSubtype fun g h : G => g * h = h * g)\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (card { h // g * h = h * g }) :=\n        card_sigma _\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (card (mul_action.fixed_by (conj_act G) G g)) :=\n        sum_equiv conj_act.to_conj_act.to_equiv _ _ fun g =>\n          card_congr' <| congr_arg _ <| funext fun h => mul_inv_eq_iff_eq_mul.symm.to_eq\n      _ = card (quotient (mul_action.orbit_rel (conj_act G) G)) * card G :=\n        mul_action.sum_card_fixed_by_eq_card_orbits_mul_card_group (conj_act G) G\n      _ = card (quotient (IsConj.setoid G)) * card G :=\n        by\n        have this : mul_action.orbit_rel (conj_act G) G = IsConj.setoid G :=\n          setoid.ext fun g h => (Setoid.comm' _).trans is_conj_iff.symm\n        cc\n      \n#align card_comm_eq_card_conj_classes_mul_card card_comm_eq_card_conj_classes_mul_card\n\n"}