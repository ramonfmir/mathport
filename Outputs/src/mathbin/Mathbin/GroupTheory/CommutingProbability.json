{"inv_card_commutator_le_commProb":
 "#print inv_card_commutator_le_commProb /-\ntheorem inv_card_commutator_le_commProb : (↑(Nat.card (commutator G)))⁻¹ ≤ commProb G :=\n  (inv_pos_le_iff_one_le_mul (nat.cast_pos.mpr Finite.card_pos)).mpr\n    (le_trans (ge_of_eq (commProb_eq_one_iff.mpr (abelianization.comm_group G).mul_comm))\n      (commutator G).comm_prob_quotient_le)\n#align inv_card_commutator_le_comm_prob inv_card_commutator_le_commProb\n-/\n\n",
 "commProb_subgroup_le":
 "#print Subgroup.commProb_subgroup_le /-\ntheorem Subgroup.commProb_subgroup_le : commProb H ≤ commProb G * H.index ^ 2 :=\n  by\n  /- After rewriting with `comm_prob_def`, we reduce to showing that `G` has at least as many\n      commuting pairs as `H`. -/\n  rw [commProb_def, commProb_def, div_le_iff, mul_assoc, ← mul_pow, ← Nat.cast_mul, mul_comm H.index, H.card_mul_index,\n    div_mul_cancel, Nat.cast_le]\n  · refine' Finite.card_le_of_injective (fun p => ⟨⟨p.1.1, p.1.2⟩, subtype.ext_iff.mp p.2⟩) _\n    exact fun p q h => by simpa only [Subtype.ext_iff, Prod.ext_iff] using h\n  · exact pow_ne_zero 2 (nat.cast_ne_zero.mpr finite.card_pos.ne')\n  · exact pow_pos (nat.cast_pos.mpr Finite.card_pos) 2\n#align subgroup.comm_prob_subgroup_le Subgroup.commProb_subgroup_le\n-/\n\n",
 "commProb_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print Subgroup.commProb_quotient_le /-\ntheorem Subgroup.commProb_quotient_le [H.normal] : commProb («expr ⧸ » G H) ≤ commProb G * Nat.card H :=\n  by\n  /- After rewriting with `comm_prob_def'`, we reduce to showing that `G` has at least as many\n      conjugacy classes as `G ⧸ H`. -/\n  rw [commProb_def', commProb_def', div_le_iff, mul_assoc, ← Nat.cast_mul, ← Subgroup.index, H.card_mul_index,\n    div_mul_cancel, Nat.cast_le]\n  · apply Finite.card_le_of_surjective\n    show function.surjective (ConjClasses.map (QuotientGroup.mk' H))\n    exact ConjClasses.map_surjective Quotient.surjective_Quotient_mk''\n  · exact nat.cast_ne_zero.mpr finite.card_pos.ne'\n  · exact nat.cast_pos.mpr Finite.card_pos\n#align subgroup.comm_prob_quotient_le Subgroup.commProb_quotient_le\n-/\n\n",
 "commProb_pos":
 "#print commProb_pos /-\ntheorem commProb_pos [h : Nonempty M] : 0 < commProb M :=\n  h.elim fun x =>\n    div_pos (Nat.cast_pos.mpr (Finite.card_pos_iff.mpr ⟨⟨(x, x), rfl⟩⟩)) (pow_pos (Nat.cast_pos.mpr Finite.card_pos) 2)\n#align comm_prob_pos commProb_pos\n-/\n\n",
 "commProb_le_one":
 "#print commProb_le_one /-\ntheorem commProb_le_one : commProb M ≤ 1 :=\n  by\n  refine' div_le_one_of_le _ (sq_nonneg (Nat.card M))\n  rw [← Nat.cast_pow, Nat.cast_le, sq, ← Nat.card_prod]\n  apply Finite.card_subtype_le\n#align comm_prob_le_one commProb_le_one\n-/\n\n",
 "commProb_eq_one_iff":
 "#print commProb_eq_one_iff /-\ntheorem commProb_eq_one_iff [h : Nonempty M] : commProb M = 1 ↔ commutative ((· * ·) : M → M → M) :=\n  by\n  haveI := Fintype.ofFinite M\n  rw [commProb, ← Set.coe_setOf, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]\n  rw [div_eq_one_iff_eq, ← Nat.cast_pow, Nat.cast_inj, sq, ← card_prod, set_fintype_card_eq_univ_iff,\n    Set.eq_univ_iff_forall]\n  · exact ⟨fun h x y => h (x, y), fun h x => h x.1 x.2⟩\n  · exact pow_ne_zero 2 (nat.cast_ne_zero.mpr card_ne_zero)\n#align comm_prob_eq_one_iff commProb_eq_one_iff\n-/\n\n",
 "commProb_def'":
 "#print commProb_def' /-\ntheorem commProb_def' : commProb G = Nat.card (ConjClasses G) / Nat.card G :=\n  by\n  rw [commProb, card_comm_eq_card_conjClasses_mul_card, Nat.cast_mul, sq]\n  exact mul_div_mul_right _ _ (nat.cast_ne_zero.mpr finite.card_pos.ne')\n#align comm_prob_def' commProb_def'\n-/\n\n",
 "commProb_def":
 "#print commProb_def /-\n/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem commProb_def : commProb M = Nat.card { p : M × M // p.1 * p.2 = p.2 * p.1 } / Nat.card M ^ 2 :=\n  rfl\n#align comm_prob_def commProb_def\n-/\n\n",
 "card_comm_eq_card_conjClasses_mul_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n#print card_comm_eq_card_conjClasses_mul_card /-\ntheorem card_comm_eq_card_conjClasses_mul_card :\n    Nat.card { p : G × G // p.1 * p.2 = p.2 * p.1 } = Nat.card (ConjClasses G) * Nat.card G :=\n  by\n  haveI := Fintype.ofFinite G\n  simp only [Nat.card_eq_fintype_card]\n  convert calc\n      card { p : G × G // p.1 * p.2 = p.2 * p.1 } = card (Σg, { h // g * h = h * g }) :=\n        card_congr (Equiv.subtypeProdEquivSigmaSubtype fun g h : G => g * h = h * g)\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (card { h // g * h = h * g }) :=\n        (card_sigma _)\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (card (MulAction.fixedBy (ConjAct G) G g)) :=\n        (sum_equiv conj_act.to_conj_act.to_equiv _ _ fun g =>\n          card_congr' <| congr_arg _ <| funext fun h => mul_inv_eq_iff_eq_mul.symm.to_eq)\n      _ = card (quotient (MulAction.orbitRel (ConjAct G) G)) * card G :=\n        (MulAction.sum_card_fixedBy_eq_card_orbits_mul_card_group (ConjAct G) G)\n      _ = card (quotient (IsConj.setoid G)) * card G :=\n        by\n        have this : MulAction.orbitRel (ConjAct G) G = IsConj.setoid G :=\n          Setoid.ext fun g h => (Setoid.comm' _).trans is_conj_iff.symm\n        cc\n      \n#align card_comm_eq_card_conj_classes_mul_card card_comm_eq_card_conjClasses_mul_card\n-/\n\n"}