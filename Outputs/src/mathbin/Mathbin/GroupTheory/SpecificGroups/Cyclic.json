{"prime_card":
 "@[to_additive]\ntheorem prime_card [fintype α] : (fintype.card α).prime :=\n  by\n  have h0 : 0 < fintype.card α := fintype.card_pos_iff.2 (by infer_instance)\n  obtain ⟨g, hg⟩ := is_cyclic.exists_generator α\n  rw [Nat.prime_def_lt'']\n  refine' ⟨fintype.one_lt_card_iff_nontrivial.2 infer_instance, fun n hn => _⟩\n  refine' (is_simple_order.eq_bot_or_eq_top (subgroup.zpowers (g ^ n))).symm.imp _ _\n  · intro h\n    have hgo := order_of_pow g\n    rw [order_of_eq_card_of_forall_mem_zpowers hg, nat.gcd_eq_right_iff_dvd.1 hn,\n      order_of_eq_card_of_forall_mem_zpowers, eq_comm, Nat.div_eq_iff_eq_mul_left (nat.pos_of_dvd_of_pos hn h0) hn] at\n      hgo\n    · exact (mul_left_cancel₀ (ne_of_gt h0) ((mul_one (fintype.card α)).trans hgo)).symm\n    · intro x\n      rw [h]\n      exact subgroup.mem_top _\n  · intro h\n    apply le_antisymm (nat.le_of_dvd h0 hn)\n    rw [← order_of_eq_card_of_forall_mem_zpowers hg]\n    apply order_of_le_of_pow_eq_one (nat.pos_of_dvd_of_pos hn h0)\n    rw [← subgroup.mem_bot, ← h]\n    exact subgroup.mem_zpowers _\n#align prime_card prime_card\n\n",
 "order_of_eq_zero_of_forall_mem_zpowers":
 "@[to_additive infinite.add_order_of_eq_zero_of_forall_mem_zmultiples]\ntheorem infinite.order_of_eq_zero_of_forall_mem_zpowers [Infinite α] {g : α} (h : ∀ x, x ∈ zpowers g) :\n    order_of g = 0 := by\n  classical\n    rw [order_of_eq_zero_iff']\n    refine' fun n hn hgn => _\n    have ho := order_of_pos' ((is_of_fin_order_iff_pow_eq_one g).mpr ⟨n, hn, hgn⟩)\n    obtain ⟨x, hx⟩ := infinite.exists_not_mem_finset (Finset.image (pow g) <| Finset.range <| order_of g)\n    apply hx\n    rw [← mem_powers_iff_mem_range_order_of' g x ho, submonoid.mem_powers_iff]\n    obtain ⟨k, hk⟩ := h x\n    obtain ⟨k, rfl | rfl⟩ := k.eq_coe_or_neg\n    · exact ⟨k, by exact_mod_cast hk⟩\n    let t : ℤ := -k % order_of g\n    rw [zpow_eq_mod_order_of] at hk\n    have : 0 ≤ t := Int.emod_nonneg (-k) (by exact_mod_cast ho.ne')\n    refine' ⟨t.to_nat, _⟩\n    rwa [← zpow_ofNat, Int.toNat_of_nonneg this]\n#align infinite.order_of_eq_zero_of_forall_mem_zpowers infinite.order_of_eq_zero_of_forall_mem_zpowers\n\n",
 "order_of_eq_card_of_forall_mem_zpowers":
 "@[to_additive add_order_of_eq_card_of_forall_mem_zmultiples]\ntheorem order_of_eq_card_of_forall_mem_zpowers [fintype α] {g : α} (hx : ∀ x, x ∈ zpowers g) :\n    order_of g = fintype.card α := by\n  classical\n    rw [order_eq_card_zpowers]\n    apply fintype.card_of_finset'\n    simpa using hx\n#align order_of_eq_card_of_forall_mem_zpowers order_of_eq_card_of_forall_mem_zpowers\n\n",
 "of_exponent_eq_card":
 "@[to_additive]\ntheorem is_cyclic.of_exponent_eq_card [comm_group α] [fintype α] (h : exponent α = fintype.card α) : is_cyclic α :=\n  let ⟨g, _, hg⟩ := Finset.mem_image.mp (finset.max'_mem _ _)\n  is_cyclic_of_order_of_eq_card g <| hg.trans <| exponent_eq_max'_order_of.symm.trans h\n#align is_cyclic.of_exponent_eq_card is_cyclic.of_exponent_eq_card\n\n",
 "map_cyclic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n@[to_additive monoid_add_hom.map_add_cyclic]\ntheorem monoid_hom.map_cyclic {G : Type _} [group G] [h : is_cyclic G] (σ : «expr →* » G G) :\n    ∃ m : ℤ, ∀ g : G, σ g = g ^ m :=\n  by\n  obtain ⟨h, hG⟩ := is_cyclic.exists_generator G\n  obtain ⟨m, hm⟩ := hG (σ h)\n  refine' ⟨m, fun g => _⟩\n  obtain ⟨n, rfl⟩ := hG g\n  rw [MonoidHom.map_zpow, ← hm, ← zpow_mul, ← zpow_mul']\n#align monoid_hom.map_cyclic monoid_hom.map_cyclic\n\n",
 "is_simple_iff_is_cyclic_and_prime_card":
 "@[to_additive add_comm_group.is_simple_iff_is_add_cyclic_and_prime_card]\ntheorem comm_group.is_simple_iff_is_cyclic_and_prime_card [fintype α] [comm_group α] :\n    is_simple_group α ↔ is_cyclic α ∧ (fintype.card α).prime :=\n  by\n  constructor\n  · intro h\n    exact ⟨is_simple_group.is_cyclic, is_simple_group.prime_card⟩\n  · rintro ⟨hc, hp⟩\n    haveI : fact (fintype.card α).prime := ⟨hp⟩\n    exact is_simple_group_of_prime_card rfl\n#align comm_group.is_simple_iff_is_cyclic_and_prime_card comm_group.is_simple_iff_is_cyclic_and_prime_card\n\n",
 "is_simple_group_of_prime_card":
 "/-- A finite group of prime order is simple. -/\n@[to_additive \"A finite group of prime order is simple.\"]\ntheorem is_simple_group_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact p.prime]\n    (h : fintype.card α = p) : is_simple_group α :=\n  ⟨by\n    have h' := Nat.Prime.one_lt (fact.out p.prime)\n    rw [← h] at h'\n    haveI := fintype.one_lt_card_iff_nontrivial.1 h'\n    apply exists_pair_ne α, fun H Hn => by\n    classical\n      have hcard := card_subgroup_dvd_card H\n      rw [h, dvd_prime (fact.out p.prime)] at hcard\n      refine' hcard.imp (fun h1 => _) fun hp => _\n      · haveI := fintype.card_le_one_iff_subsingleton.1 (le_of_eq h1)\n        apply eq_bot_of_subsingleton\n      · exact eq_top_of_card_eq _ (hp.trans h.symm)⟩\n#align is_simple_group_of_prime_card is_simple_group_of_prime_card\n\n",
 "is_cyclic_of_prime_card":
 "/-- A finite group of prime order is cyclic. -/\n@[to_additive is_add_cyclic_of_prime_card \"A finite group of prime order is cyclic.\"]\ntheorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact p.prime]\n    (h : fintype.card α = p) : is_cyclic α :=\n  ⟨by\n    obtain ⟨g, hg⟩ : ∃ g : α, g ≠ 1 := fintype.exists_ne_of_one_lt_card (h.symm ▸ hp.1.one_lt) 1\n    classical\n      -- for fintype (subgroup.zpowers g)\n      have : fintype.card (subgroup.zpowers g) ∣ p := by\n        rw [← h]\n        apply card_subgroup_dvd_card\n      rw [Nat.dvd_prime hp.1] at this\n      cases this\n      · rw [fintype.card_eq_one_iff] at this\n        cases' this with t ht\n        suffices g = 1 by contradiction\n        have hgt :=\n          ht\n            ⟨g, by\n              change g ∈ subgroup.zpowers g\n              exact subgroup.mem_zpowers g⟩\n        rw [← ht 1] at hgt\n        change (⟨_, _⟩ : subgroup.zpowers g) = ⟨_, _⟩ at hgt\n        simpa using hgt\n      · use g\n        intro x\n        rw [← h] at this\n        rw [subgroup.eq_top_of_card_eq _ this]\n        exact subgroup.mem_top _⟩\n#align is_cyclic_of_prime_card is_cyclic_of_prime_card\n\n",
 "is_cyclic_of_order_of_eq_card":
 "@[to_additive is_add_cyclic_of_order_of_eq_card]\ntheorem is_cyclic_of_order_of_eq_card [fintype α] (x : α) (hx : order_of x = fintype.card α) : is_cyclic α := by\n  classical\n    use x\n    simp_rw [← SetLike.mem_coe, ← Set.eq_univ_iff_forall]\n    rw [← fintype.card_congr (Equiv.Set.univ α), order_eq_card_zpowers] at hx\n    exact set.eq_of_subset_of_card_le (Set.subset_univ _) (ge_of_eq hx)\n#align is_cyclic_of_order_of_eq_card is_cyclic_of_order_of_eq_card\n\n",
 "is_cyclic_of_card_pow_eq_one_le":
 "theorem is_cyclic_of_card_pow_eq_one_le : is_cyclic α :=\n  have : (univ.filter fun a : α => order_of a = fintype.card α).nonempty :=\n    card_pos.1 <| by rw [card_order_of_eq_totient_aux₂ hn dvd_rfl] <;> exact totient_pos (fintype.card_pos_iff.2 ⟨1⟩)\n  let ⟨x, hx⟩ := this\n  is_cyclic_of_order_of_eq_card x (Finset.mem_filter.1 hx).2\n#align is_cyclic_of_card_pow_eq_one_le is_cyclic_of_card_pow_eq_one_le\n\n",
 "is_add_cyclic_of_card_pow_eq_one_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_add_cyclic_of_card_pow_eq_one_le {α} [add_group α] [decidable_eq α] [fintype α]\n    (hn : ∀ n : ℕ, 0 < n → (univ.filter fun a : α => «expr • » n a = 0).card ≤ n) : is_add_cyclic α :=\n  by\n  obtain ⟨g, hg⟩ := @is_cyclic_of_card_pow_eq_one_le (Multiplicative α) _ _ _ hn\n  exact ⟨⟨g, hg⟩⟩\n#align is_add_cyclic_of_card_pow_eq_one_le is_add_cyclic_of_card_pow_eq_one_le\n\n",
 "image_range_order_of":
 "@[to_additive]\ntheorem is_cyclic.image_range_order_of (ha : ∀ x : α, x ∈ zpowers a) :\n    Finset.image (fun i => a ^ i) (range (order_of a)) = univ :=\n  by\n  simp_rw [← SetLike.mem_coe] at ha\n  simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha, set.to_finset_univ]\n#align is_cyclic.image_range_order_of is_cyclic.image_range_order_of\n\n",
 "image_range_card":
 "@[to_additive]\ntheorem is_cyclic.image_range_card (ha : ∀ x : α, x ∈ zpowers a) :\n    Finset.image (fun i => a ^ i) (range (fintype.card α)) = univ := by\n  rw [← order_of_eq_card_of_forall_mem_zpowers ha, is_cyclic.image_range_order_of ha]\n#align is_cyclic.image_range_card is_cyclic.image_range_card\n\n",
 "iff_exponent_eq_card":
 "@[to_additive]\ntheorem is_cyclic.iff_exponent_eq_card [comm_group α] [fintype α] : is_cyclic α ↔ exponent α = fintype.card α :=\n  ⟨fun h => is_cyclic.exponent_eq_card, is_cyclic.of_exponent_eq_card⟩\n#align is_cyclic.iff_exponent_eq_card is_cyclic.iff_exponent_eq_card\n\n",
 "exponent_eq_zero_of_infinite":
 "@[to_additive]\ntheorem is_cyclic.exponent_eq_zero_of_infinite [group α] [is_cyclic α] [Infinite α] : exponent α = 0 :=\n  let ⟨g, hg⟩ := is_cyclic.exists_generator α\n  exponent_eq_zero_of_order_zero <| infinite.order_of_eq_zero_of_forall_mem_zpowers hg\n#align is_cyclic.exponent_eq_zero_of_infinite is_cyclic.exponent_eq_zero_of_infinite\n\n",
 "exponent_eq_card":
 "@[to_additive]\ntheorem is_cyclic.exponent_eq_card [group α] [is_cyclic α] [fintype α] : exponent α = fintype.card α :=\n  by\n  obtain ⟨g, hg⟩ := is_cyclic.exists_generator α\n  apply nat.dvd_antisymm\n  · rw [← lcm_order_eq_exponent, finset.lcm_dvd_iff]\n    exact fun b _ => order_of_dvd_card_univ\n  rw [← order_of_eq_card_of_forall_mem_zpowers hg]\n  exact order_dvd_exponent _\n#align is_cyclic.exponent_eq_card is_cyclic.exponent_eq_card\n\n",
 "exists_monoid_generator":
 "@[to_additive]\ntheorem is_cyclic.exists_monoid_generator [Finite α] [is_cyclic α] : ∃ x : α, ∀ y : α, y ∈ submonoid.powers x :=\n  by\n  simp_rw [mem_powers_iff_mem_zpowers]\n  exact is_cyclic.exists_generator α\n#align is_cyclic.exists_monoid_generator is_cyclic.exists_monoid_generator\n\n",
 "commutative_of_cyclic_center_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- A group is commutative if the quotient by the center is cyclic.\n  Also see `comm_group_of_cycle_center_quotient` for the `comm_group` instance. -/\n@[to_additive commutative_of_add_cyclic_center_quotient\n      \"A group is commutative if the quotient by\\n  the center is cyclic. Also see `add_comm_group_of_cycle_center_quotient`\\n  for the `add_comm_group` instance.\"]\ntheorem commutative_of_cyclic_center_quotient [is_cyclic H] (f : «expr →* » G H) (hf : f.ker ≤ center G) (a b : G) :\n    a * b = b * a :=\n  let ⟨⟨x, y, (hxy : f y = x)⟩, (hx : ∀ a : f, a ∈ zpowers _)⟩ := is_cyclic.exists_generator f.range\n  let ⟨m, hm⟩ := hx ⟨f a, a, rfl⟩\n  let ⟨n, hn⟩ := hx ⟨f b, b, rfl⟩\n  have hm : x ^ m = f a := by simpa [subtype.ext_iff] using hm\n  have hn : x ^ n = f b := by simpa [subtype.ext_iff] using hn\n  have ha : y ^ (-m) * a ∈ center G := hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hm, inv_mul_self])\n  have hb : y ^ (-n) * b ∈ center G := hf (by rw [f.mem_ker, f.map_mul, f.map_zpow, hxy, zpow_neg, hn, inv_mul_self])\n  calc\n    a * b = y ^ m * (y ^ (-m) * a * y ^ n) * (y ^ (-n) * b) := by simp [mul_assoc]\n    _ = y ^ m * (y ^ n * (y ^ (-m) * a)) * (y ^ (-n) * b) := by rw [mem_center_iff.1 ha]\n    _ = y ^ m * y ^ n * y ^ (-m) * (a * (y ^ (-n) * b)) := by simp [mul_assoc]\n    _ = y ^ m * y ^ n * y ^ (-m) * (y ^ (-n) * b * a) := by rw [mem_center_iff.1 hb]\n    _ = b * a := by group\n    \n#align commutative_of_cyclic_center_quotient commutative_of_cyclic_center_quotient\n\n",
 "card_pow_eq_one_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([2, 3]) } -/\n@[to_additive is_add_cyclic.card_pow_eq_one_le]\ntheorem is_cyclic.card_pow_eq_one_le [decidable_eq α] [fintype α] [is_cyclic α] {n : ℕ} (hn0 : 0 < n) :\n    (univ.filter fun a : α => a ^ n = 1).card ≤ n :=\n  let ⟨g, hg⟩ := is_cyclic.exists_generator α\n  calc\n    (univ.filter fun a : α => a ^ n = 1).card ≤\n        (zpowers (g ^ (fintype.card α / nat.gcd n (fintype.card α))) : set α).to_finset.card :=\n      card_le_of_subset fun x hx =>\n        let ⟨m, hm⟩ := show x ∈ submonoid.powers g from mem_powers_iff_mem_zpowers.2 <| hg x\n        set.mem_to_finset.2\n          ⟨(m / (fintype.card α / nat.gcd n (fintype.card α)) : ℕ),\n            by\n            have hgmn : g ^ (m * nat.gcd n (fintype.card α)) = 1 := by\n              rw [pow_mul, hm, ← pow_gcd_card_eq_one_iff] <;> exact (mem_filter.1 hx).2\n            rw [zpow_ofNat, ← pow_mul, Nat.mul_div_cancel_left', hm]\n            refine' dvd_of_mul_dvd_mul_right (gcd_pos_of_pos_left (fintype.card α) hn0) _\n            conv_lhs => rw [Nat.div_mul_cancel (nat.gcd_dvd_right _ _), ← order_of_eq_card_of_forall_mem_zpowers hg]\n            exact order_of_dvd_of_pow_eq_one hgmn⟩\n    _ ≤ n := by\n      let ⟨m, hm⟩ := nat.gcd_dvd_right n (fintype.card α)\n      have hm0 : 0 < m :=\n        nat.pos_of_ne_zero fun hm0 => by\n          rw [hm0, mul_zero, fintype.card_eq_zero_iff] at hm\n          exact hm.elim' 1\n      simp only [set.to_finset_card, SetLike.coe_sort_coe]\n      rw [← order_eq_card_zpowers, order_of_pow g, order_of_eq_card_of_forall_mem_zpowers hg]\n      rw [hm]\n      rw [nat.mul_div_cancel_left _ (gcd_pos_of_pos_left _ hn0), gcd_mul_left_left, hm, nat.mul_div_cancel _ hm0]\n      exact le_of_dvd hn0 (nat.gcd_dvd_left _ _)\n    \n#align is_cyclic.card_pow_eq_one_le is_cyclic.card_pow_eq_one_le\n\n",
 "card_pow_eq_one_eq_order_of_aux":
 "private theorem card_pow_eq_one_eq_order_of_aux (a : α) :\n    (finset.univ.filter fun b : α => b ^ order_of a = 1).card = order_of a :=\n  le_antisymm (hn _ (order_of_pos a))\n    (calc\n      order_of a = @fintype.card (zpowers a) (id _) := order_eq_card_zpowers\n      _ ≤\n          @fintype.card (↑(univ.filter fun b : α => b ^ order_of a = 1) : set α)\n            (fintype.of_finset _ fun _ => iff.rfl) :=\n        @fintype.card_le_of_injective (zpowers a) (↑(univ.filter fun b : α => b ^ order_of a = 1) : set α) (id _) (id _)\n          (fun b =>\n            ⟨b.1,\n              mem_filter.2\n                ⟨mem_univ _, by\n                  let ⟨i, hi⟩ := b.2\n                  rw [← hi, ← zpow_ofNat, ← zpow_mul, mul_comm, zpow_mul, zpow_ofNat, pow_order_of_eq_one, one_zpow]⟩⟩)\n          fun _ _ h => subtype.eq (subtype.mk.inj h)\n      _ = (univ.filter fun b : α => b ^ order_of a = 1).card := fintype.card_of_finset _ _\n      )\n#align card_pow_eq_one_eq_order_of_aux card_pow_eq_one_eq_order_of_aux\n\n",
 "card_order_of_eq_totient_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem card_order_of_eq_totient_aux₂ {d : ℕ} (hd : d ∣ fintype.card α) :\n    (univ.filter fun a : α => order_of a = d).card = (nat.totient) d :=\n  by\n  let c := fintype.card α\n  have hc0 : 0 < c := fintype.card_pos_iff.2 ⟨1⟩\n  apply card_order_of_eq_totient_aux₁ hn hd\n  by_contra h0\n  simp only [not_lt, _root_.le_zero_iff, card_eq_zero] at h0\n  apply lt_irrefl c\n  calc\n    c =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" c.divisors\n          (univ.filter fun a : α => order_of a = m).card :=\n      by\n      simp only [← filter_dvd_eq_divisors hc0.ne', sum_card_order_of_eq_card_pow_eq_one hc0.ne']\n      apply congr_arg card\n      simp\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (c.divisors.erase d) (univ.filter fun a : α => order_of a = m).card :=\n      by\n      rw [eq_comm]\n      refine' sum_subset (erase_subset _ _) fun m hm₁ hm₂ => _\n      have : m = d := by\n        contrapose! hm₂\n        exact mem_erase_of_ne_of_mem hm₂ hm₁\n      simp [this, h0]\n    _ ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (c.divisors.erase d) ((nat.totient) m) :=\n      by\n      refine' sum_le_sum fun m hm => _\n      have hmc : m ∣ c := by\n        simp only [mem_erase, mem_divisors] at hm\n        tauto\n      rcases(filter (fun a : α => order_of a = m) univ).card.eq_zero_or_pos with (h1 | h1)\n      · simp [h1]\n      · simp [card_order_of_eq_totient_aux₁ hn hmc h1]\n    _ <\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" c.divisors\n          ((nat.totient) m) :=\n      sum_erase_lt_of_pos (mem_divisors.2 ⟨hd, hc0.ne'⟩) (totient_pos (pos_of_dvd_of_pos hd hc0))\n    _ = c := sum_totient _\n    \n#align card_order_of_eq_totient_aux₂ card_order_of_eq_totient_aux₂\n\n",
 "card_order_of_eq_totient_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n-- use φ for nat.totient\nprivate theorem card_order_of_eq_totient_aux₁ :\n    ∀ {d : ℕ},\n      d ∣ fintype.card α →\n        0 < (univ.filter fun a : α => order_of a = d).card →\n          (univ.filter fun a : α => order_of a = d).card = (nat.totient) d :=\n  by\n  intro d hd hpos\n  induction' d using Nat.strongRec' with d IH\n  rcases decidable.eq_or_ne d 0 with (rfl | hd0)\n  · cases fintype.card_ne_zero (eq_zero_of_zero_dvd hd)\n  rcases card_pos.1 hpos with ⟨a, ha'⟩\n  have ha : order_of a = d := (mem_filter.1 ha').2\n  have h1 :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.proper_divisors\n        (univ.filter fun a : α => order_of a = m).card =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.proper_divisors\n        ((nat.totient) m) :=\n    by\n    refine' finset.sum_congr rfl fun m hm => _\n    simp only [mem_filter, mem_range, mem_proper_divisors] at hm\n    refine' IH m hm.2 (hm.1.trans hd) (finset.card_pos.2 ⟨a ^ (d / m), _⟩)\n    simp only [mem_filter, mem_univ, order_of_pow a, ha, true_and_iff, nat.gcd_eq_right (div_dvd_of_dvd hm.1),\n      Nat.div_div_self hm.1 hd0]\n  have h2 :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.divisors\n        (univ.filter fun a : α => order_of a = m).card =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.divisors\n        ((nat.totient) m) :=\n    by\n    rw [← filter_dvd_eq_divisors hd0, sum_card_order_of_eq_card_pow_eq_one hd0, filter_dvd_eq_divisors hd0, sum_totient,\n      ← ha, card_pow_eq_one_eq_order_of_aux hn a]\n  simpa [← cons_self_proper_divisors hd0, ← h1] using h2\n#align card_order_of_eq_totient_aux₁ card_order_of_eq_totient_aux₁\n\n",
 "card_order_of_eq_totient":
 "theorem is_add_cyclic.card_order_of_eq_totient {α} [add_group α] [is_add_cyclic α] [fintype α] {d : ℕ}\n    (hd : d ∣ fintype.card α) : (univ.filter fun a : α => add_order_of a = d).card = totient d :=\n  by\n  obtain ⟨g, hg⟩ := id ‹is_add_cyclic α›\n  exact @is_cyclic.card_order_of_eq_totient (Multiplicative α) _ ⟨⟨g, hg⟩⟩ _ _ hd\n#align is_add_cyclic.card_order_of_eq_totient is_add_cyclic.card_order_of_eq_totient\n\n"}