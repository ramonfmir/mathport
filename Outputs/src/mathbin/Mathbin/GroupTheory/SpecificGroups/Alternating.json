{"two_mul_card_alternatingGroup":
 "#print two_mul_card_alternatingGroup /-\ntheorem two_mul_card_alternatingGroup [Nontrivial α] : 2 * card (alternatingGroup α) = card (Perm α) :=\n  by\n  let this := (QuotientGroup.quotientKerEquivOfSurjective _ (sign_surjective α)).to_equiv\n  rw [← Fintype.card_units_int, ← Fintype.card_congr this]\n  exact (Subgroup.card_eq_card_quotient_mul_card_subgroup _).symm\n#align two_mul_card_alternating_group two_mul_card_alternatingGroup\n-/\n\n",
 "prod_list_swap_mem_alternating_group_iff_even_length":
 "theorem prod_list_swap_mem_alternating_group_iff_even_length {l : List (Perm α)} (hl : ∀ g ∈ l, IsSwap g) :\n    l.prod ∈ alternatingGroup α ↔ Even l.length :=\n  by\n  rw [mem_alternating_group, sign_prod_list_swap hl, ← Units.val_eq_one, Units.val_pow_eq_pow_val, Units.coe_neg_one,\n    neg_one_pow_eq_one_iff_even]\n  decide\n#align prod_list_swap_mem_alternating_group_iff_even_length prod_list_swap_mem_alternating_group_iff_even_length\n\n",
 "normal_closure_swap_mul_swap_five":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\n  used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\n  -/\ntheorem normal_closure_swap_mul_swap_five :\n    normalClosure ({⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩} : Set (alternatingGroup (Fin 5))) =\n      «expr⊤» :=\n  by\n  let g1 := (⟨swap 0 2 * swap 0 1, mem_alternating_group.2 (by decide)⟩ : alternatingGroup (Fin 5))\n  let g2 := (⟨swap 0 4 * swap 1 3, mem_alternating_group.2 (by decide)⟩ : alternatingGroup (Fin 5))\n  have h5 : g1 * g2 * g1⁻¹ * g2⁻¹ = ⟨finRotate 5, fin_rotate_bit1_mem_alternating_group⟩ :=\n    by\n    rw [Subtype.ext_iff]\n    simp only [Fin.val_mk, Subgroup.coe_mul, Subgroup.coe_inv, Fin.val_mk]\n    decide\n  rw [eq_top_iff, ← normal_closure_fin_rotate_five]\n  refine' normal_closure_le_normal _\n  rw [Set.singleton_subset_iff, SetLike.mem_coe, ← h5]\n  have h : g2 ∈ normal_closure {g2} := SetLike.mem_coe.1 (subset_normal_closure (Set.mem_singleton _))\n  exact mul_mem (subgroup.normal_closure_normal.conj_mem _ h g1) (inv_mem h)\n#align normal_closure_swap_mul_swap_five normal_closure_swap_mul_swap_five\n\n",
 "normal_closure_fin_rotate_five":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The normal closure of the 5-cycle `fin_rotate 5` within $A_5$ is the whole group. This will be\n  used to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/\ntheorem normal_closure_fin_rotate_five :\n    normalClosure ({⟨finRotate 5, finRotate_bit1_mem_alternatingGroup⟩} : Set (alternatingGroup (Fin 5))) = «expr⊤» :=\n  eq_top_iff.2\n    (by\n      have h3 : is_three_cycle (Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)⁻¹ * (finRotate 5)⁻¹) :=\n        card_support_eq_three_iff.1 (by decide)\n      rw [← h3.alternating_normal_closure (by rw [card_fin])]\n      refine' normal_closure_le_normal _\n      rw [Set.singleton_subset_iff, SetLike.mem_coe]\n      have h : (⟨finRotate 5, fin_rotate_bit1_mem_alternating_group⟩ : alternatingGroup (Fin 5)) ∈ normal_closure _ :=\n        SetLike.mem_coe.1 (subset_normal_closure (Set.mem_singleton _))\n      exact\n        mul_mem\n          (subgroup.normal_closure_normal.conj_mem _ h\n            ⟨Fin.cycleRange 2, fin.is_three_cycle_cycle_range_two.mem_alternating_group⟩)\n          (inv_mem h))\n#align normal_closure_fin_rotate_five normal_closure_fin_rotate_five\n\n",
 "nontrivial_of_three_le_card":
 "theorem nontrivial_of_three_le_card (h3 : 3 ≤ card α) : Nontrivial (alternatingGroup α) :=\n  by\n  haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)\n  rw [← Fintype.one_lt_card_iff_nontrivial]\n  refine' lt_of_mul_lt_mul_left _ (le_of_lt nat.prime_two.pos)\n  rw [two_mul_card_alternatingGroup, card_perm, ← Nat.succ_le_iff]\n  exact le_trans h3 (card α).self_le_factorial\n#align nontrivial_of_three_le_card nontrivial_of_three_le_card\n\n",
 "mem_alternating_group":
 "theorem is_three_cycle.mem_alternating_group {f : Perm α} (h : IsThreeCycle f) : f ∈ alternatingGroup α :=\n  mem_alternatingGroup.2 h.sign\n#align is_three_cycle.mem_alternating_group is_three_cycle.mem_alternating_group\n\n",
 "is_three_cycle_sq_of_three_mem_cycle_type_five":
 "/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\n  its cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n  $A_5$. -/\ntheorem is_three_cycle_sq_of_three_mem_cycle_type_five {g : Perm (Fin 5)} (h : 3 ∈ cycleType g) :\n    IsThreeCycle (g * g) := by\n  obtain ⟨c, g', rfl, hd, hc, h3⟩ := mem_cycle_type_iff.1 h\n  simp only [mul_assoc]\n  rw [hd.commute.eq, ← mul_assoc g']\n  suffices hg' : orderOf g' ∣ 2\n  · rw [← pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]\n    exact (card_support_eq_three_iff.1 h3).is_three_cycle_sq\n  rw [← lcm_cycle_type, Multiset.lcm_dvd]\n  intro n hn\n  rw [le_antisymm (two_le_of_mem_cycle_type hn) (le_trans (le_card_support_of_mem_cycle_type hn) _)]\n  apply le_of_add_le_add_left\n  rw [← hd.card_support_mul, h3]\n  exact (c * g').support.card_le_univ\n#align is_three_cycle_sq_of_three_mem_cycle_type_five is_three_cycle_sq_of_three_mem_cycle_type_five\n\n",
 "is_three_cycle_is_conj":
 "theorem is_three_cycle_is_conj (h5 : 5 ≤ Fintype.card α) {σ τ : alternatingGroup α} (hσ : IsThreeCycle (σ : Perm α))\n    (hτ : IsThreeCycle (τ : Perm α)) : IsConj σ τ :=\n  alternatingGroup.isConj_of (isConj_iff_cycleType_eq.2 (hσ.trans hτ.symm)) (by rwa [hσ.card_support])\n#align is_three_cycle_is_conj is_three_cycle_is_conj\n\n",
 "is_conj_swap_mul_swap_of_cycle_type_two":
 "/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\n  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\n  in $A_5$ is $A_5$. -/\ntheorem is_conj_swap_mul_swap_of_cycle_type_two {g : Perm (Fin 5)} (ha : g ∈ alternatingGroup (Fin 5)) (h1 : g ≠ 1)\n    (h2 : ∀ n, n ∈ cycleType (g : Perm (Fin 5)) → n = 2) : IsConj (swap 0 4 * swap 1 3) g :=\n  by\n  have h := g.support.card_le_univ\n  rw [← Multiset.eq_replicate_card] at h2\n  rw [← sum_cycle_type, h2, Multiset.sum_replicate, smul_eq_mul] at h\n  have h : g.cycle_type.card ≤ 3 := le_of_mul_le_mul_right (le_trans h (by decide)) (by decide)\n  rw [mem_alternating_group, sign_of_cycle_type, h2] at ha\n  norm_num at ha\n  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, Units.ext_iff, Units.val_one, Units.val_pow_eq_pow_val,\n    Units.coe_neg_one, neg_one_pow_eq_one_iff_even _] at ha\n  swap; · decide\n  rw [is_conj_iff_cycle_type_eq, h2]\n  interval_cases\n  · exact (h1 (card_cycle_type_eq_zero.1 h_1)).elim\n  · contrapose! ha\n    simp [h_1]\n  · have h04 : (0 : Fin 5) ≠ 4 := by decide\n    have h13 : (1 : Fin 5) ≠ 3 := by decide\n    rw [h_1, disjoint.cycle_type, (is_cycle_swap h04).cycle_type, (is_cycle_swap h13).cycle_type, card_support_swap h04,\n      card_support_swap h13]\n    · rfl\n    · rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]\n      decide\n  · contrapose! ha\n    simp [h_1]\n#align is_conj_swap_mul_swap_of_cycle_type_two is_conj_swap_mul_swap_of_cycle_type_two\n\n",
 "is_conj_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_conj_of {σ τ : alternatingGroup α} (hc : IsConj (σ : Perm α) (τ : Perm α))\n    (hσ : (σ : Perm α).support.card + 2 ≤ Fintype.card α) : IsConj σ τ :=\n  by\n  obtain ⟨σ, hσ⟩ := σ\n  obtain ⟨τ, hτ⟩ := τ\n  obtain ⟨π, hπ⟩ := isConj_iff.1 hc\n  rw [Subtype.coe_mk, Subtype.coe_mk] at hπ\n  cases' Int.units_eq_one_or (SignType.sign π) with h h\n  · rw [isConj_iff]\n    refine' ⟨⟨π, mem_alternating_group.mp h⟩, Subtype.val_injective _⟩\n    simpa only [subtype.val_eq_coe, Subgroup.coe_mul, coe_inv, coe_mk] using hπ\n  · have h2 : 2 ≤ («expr ᶜ» σ.support).card :=\n      by\n      rw [Finset.card_compl, le_tsub_iff_left σ.support.card_le_univ]\n      exact hσ\n    obtain ⟨a, ha, b, hb, ab⟩ := Finset.one_lt_card.1 h2\n    refine' isConj_iff.2 ⟨⟨π * swap a b, _⟩, Subtype.val_injective _⟩\n    · rw [mem_alternating_group, MonoidHom.map_mul, h, sign_swap ab, Int.units_mul_self]\n    · simp only [← hπ, coe_mk, Subgroup.coe_mul, subtype.val_eq_coe]\n      have hd : Disjoint (swap a b) σ :=\n        by\n        rw [disjoint_iff_disjoint_support, support_swap ab, Finset.disjoint_insert_left, Finset.disjoint_singleton_left]\n        exact ⟨Finset.mem_compl.1 ha, Finset.mem_compl.1 hb⟩\n      rw [mul_assoc π _ σ, hd.commute.eq, coe_inv, coe_mk]\n      simp [mul_assoc]\n#align is_conj_of is_conj_of\n\n",
 "fin_rotate_bit1_mem_alternating_group":
 "theorem fin_rotate_bit1_mem_alternating_group {n : ℕ} : finRotate (bit1 n) ∈ alternatingGroup (Fin (bit1 n)) := by\n  rw [mem_alternating_group, bit1, sign_finRotate, pow_bit0', Int.units_mul_self, one_pow]\n#align fin_rotate_bit1_mem_alternating_group fin_rotate_bit1_mem_alternating_group\n\n",
 "closure_three_cycles_eq_alternating":
 "@[simp]\ntheorem closure_three_cycles_eq_alternating : closure { σ : Perm α | IsThreeCycle σ } = alternatingGroup α :=\n  closure_eq_of_le _ (fun σ hσ => mem_alternatingGroup.2 hσ.sign) fun σ hσ =>\n    by\n    suffices hind :\n      ∀ (n : ℕ) (l : List (perm α)) (hl : ∀ g, g ∈ l → is_swap g) (hn : l.length = 2 * n),\n        l.prod ∈ closure { σ : perm α | is_three_cycle σ }\n    · obtain ⟨l, rfl, hl⟩ := trunc_swap_factors σ\n      obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternating_group_iff_even_length hl).1 hσ\n      rw [← two_mul] at hn\n      exact hind n l hl hn\n    intro n\n    induction' n with n ih <;> intro l hl hn\n    · simp [List.length_eq_zero.1 hn, one_mem]\n    rw [nat.mul_succ] at hn\n    obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn\n    rw [list.length_cons, Nat.succ_inj'] at hn\n    obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn\n    rw [List.prod_cons, List.prod_cons, ← mul_assoc]\n    rw [list.length_cons, Nat.succ_inj'] at hn\n    exact\n      mul_mem\n        (is_swap.mul_mem_closure_three_cycles (hl a (list.mem_cons_self a _))\n          (hl b (list.mem_cons_of_mem a (l.mem_cons_self b))))\n        (ih _ (fun g hg => hl g (list.mem_cons_of_mem _ (list.mem_cons_of_mem _ hg))) hn)\n#align closure_three_cycles_eq_alternating closure_three_cycles_eq_alternating\n\n",
 "alternating_normal_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\n  at least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem is_three_cycle.alternating_normal_closure (h5 : 5 ≤ Fintype.card α) {f : Perm α} (hf : IsThreeCycle f) :\n    normalClosure ({⟨f, hf.mem_alternating_group⟩} : Set (alternatingGroup α)) = «expr⊤» :=\n  eq_top_iff.2\n    (by\n      have hi : function.injective (alternatingGroup α).subtype := Subtype.coe_injective\n      refine' eq_top_iff.1 (map_injective hi (le_antisymm (map_mono le_top) _))\n      rw [← MonoidHom.range_eq_map, subtype_range, normal_closure, MonoidHom.map_closure]\n      refine' (le_of_eq closure_three_cycles_eq_alternating.symm).trans (closure_mono _)\n      intro g h\n      obtain ⟨c, rfl⟩ := isConj_iff.1 (is_conj_iff_cycle_type_eq.2 (hf.trans h.symm))\n      refine' ⟨⟨c * f * c⁻¹, h.mem_alternating_group⟩, _, rfl⟩\n      rw [Group.mem_conjugatesOfSet_iff]\n      exact ⟨⟨f, hf.mem_alternating_group⟩, Set.mem_singleton _, is_three_cycle_is_conj h5 hf h⟩)\n#align is_three_cycle.alternating_normal_closure is_three_cycle.alternating_normal_closure\n\n",
 "alternatingGroup_eq_sign_ker":
 "#print alternatingGroup_eq_sign_ker /-\n/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem alternatingGroup_eq_sign_ker : alternatingGroup α = sign.ker :=\n  rfl\n#align alternating_group_eq_sign_ker alternatingGroup_eq_sign_ker\n-/\n\n"}