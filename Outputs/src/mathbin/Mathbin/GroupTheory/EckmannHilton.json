{"one":
 "/-- If a type carries two unital binary operations that distribute over each other,\nthen they have the same unit elements.\n\nIn fact, the two operations are the same, and give a commutative monoid structure,\nsee `eckmann_hilton.comm_monoid`. -/\ntheorem one : e₁ = e₂ := by simpa only [h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id] using Distrib e₂ e₁ e₁ e₂\n#align one one\n\n",
 "mul_comm":
 "#print mul_comm /-\n/-- If a type carries two unital binary operations that distribute over each other,\nthen these operations are commutative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.comm_monoid`. -/\ntheorem mul_comm : is_commutative _ m₂ :=\n  ⟨fun a b => by simpa [mul h₁ h₂ Distrib, h₂.left_id, h₂.right_id] using Distrib e₂ a b e₂⟩\n#align mul_comm mul_comm\n-/\n\n",
 "mul_assoc":
 "#print mul_assoc /-\n/-- If a type carries two unital binary operations that distribute over each other,\nthen these operations are associative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.comm_monoid`. -/\ntheorem mul_assoc : is_associative _ m₂ :=\n  ⟨fun a b c => by simpa [mul h₁ h₂ Distrib, h₂.left_id, h₂.right_id] using Distrib a b e₂ c⟩\n#align mul_assoc mul_assoc\n-/\n\n",
 "mul":
 "/-- If a type carries two unital binary operations that distribute over each other,\nthen these operations are equal.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.comm_monoid`. -/\ntheorem mul : m₁ = m₂ := by\n  funext a b\n  calc\n    m₁ a b = m₁ (m₂ a e₁) (m₂ e₁ b) := by\n      simp only [one h₁ h₂ Distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]\n    _ = m₂ a b := by simp only [Distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]\n    \n#align mul mul\n\n",
 "is_unital":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau, Robert Y. Lewis\n-/\n@[to_additive EckmannHilton.AddZeroClass.IsUnital]\ntheorem mul_one_class.is_unital [G : MulOneClass X] : IsUnital (· * ·) (1 : X) :=\n  is_unital.mk (by infer_instance) (by infer_instance)\n#align mul_one_class.is_unital mul_one_class.is_unital\n\n"}