{"transfer_transversal_apply''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\ntheorem transfer_transversal_apply'' (q : orbit_rel.quotient (zpowers g) («expr ⧸ » G H))\n    (k : zmod (minimal_period ((«expr • » · ·) g) q.out')) :\n    ↑(to_equiv («expr • » g (transfer_transversal H g)).2 («expr • » (g ^ (k : ℤ)) q.out')) =\n      if k = 0 then g ^ minimal_period ((«expr • » · ·) g) q.out' * q.out'.out' else g ^ (k : ℤ) * q.out'.out' :=\n  by\n  rw [smul_apply_eq_smul_apply_inv_smul, transfer_transversal_apply, transfer_function_apply, ← mul_smul, ←\n    zpow_neg_one, ← zpow_add, quotient_equiv_sigma_zmod_apply, smul_eq_mul, ← mul_assoc, ← zpow_one_add, Int.cast_add,\n    Int.cast_neg, Int.cast_one, int_cast_cast, cast_id', id.def, ← sub_eq_neg_add, cast_sub_one, add_sub_cancel'_right]\n  by_cases hk : k = 0\n  · rw [if_pos hk, if_pos hk, zpow_ofNat]\n  · rw [if_neg hk, if_neg hk]\n#align transfer_transversal_apply'' transfer_transversal_apply''\n\n",
 "transfer_transversal_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem transfer_transversal_apply' (q : orbit_rel.quotient (zpowers g) («expr ⧸ » G H))\n    (k : zmod (minimal_period ((«expr • » · ·) g) q.out')) :\n    ↑(to_equiv (transfer_transversal H g).2 («expr • » (g ^ (k : ℤ)) q.out')) = g ^ (k : ℤ) * q.out'.out' := by\n  rw [transfer_transversal_apply, transfer_function_apply, ← quotient_equiv_sigma_zmod_symm_apply, apply_symm_apply]\n#align transfer_transversal_apply' transfer_transversal_apply'\n\n",
 "transfer_transversal_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem transfer_transversal_apply (q : «expr ⧸ » G H) :\n    ↑(to_equiv (transfer_transversal H g).2 q) = transfer_function H g q :=\n  to_equiv_apply (coe_transfer_function H g) q\n#align transfer_transversal_apply transfer_transversal_apply\n\n",
 "transfer_function_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem transfer_function_apply (q : «expr ⧸ » G H) :\n    transfer_function H g q =\n      g ^ ((quotient_equiv_sigma_zmod H g q).2 : ℤ) * (quotient_equiv_sigma_zmod H g q).1.out'.out' :=\n  rfl\n#align transfer_function_apply transfer_function_apply\n\n",
 "to_fun_mul_inv_mem":
 "@[to_additive]\ntheorem to_fun_mul_inv_mem (hS : S ∈ subgroup.right_transversals (H : set G)) (g : G) : (to_fun hS g : G) * g⁻¹ ∈ H :=\n  (congr_arg (· ∈ H) (by rw [mul_inv_rev, inv_inv])).mp (H.inv_mem (mul_inv_to_fun_mem hS g))\n#align to_fun_mul_inv_mem to_fun_mul_inv_mem\n\n",
 "to_equiv_apply":
 "@[to_additive]\ntheorem to_equiv_apply {f : quotient (quotient_group.right_rel H) → G} (hf : ∀ q, quotient.mk' (f q) = q)\n    (q : quotient (quotient_group.right_rel H)) : (to_equiv (range_mem_right_transversals hf) q : G) = f q :=\n  by\n  refine' (subtype.ext_iff.mp _).trans (subtype.coe_mk (f q) ⟨q, rfl⟩)\n  exact (to_equiv (range_mem_right_transversals hf)).apply_eq_iff_eq_symm_apply.mpr (hf q).symm\n#align to_equiv_apply to_equiv_apply\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[to_additive]\ntheorem is_complement'.symm (h : is_complement' H K) : is_complement' K H :=\n  by\n  let ϕ : «expr ≃ » (H × K) (K × H) :=\n    equiv.mk (fun x => ⟨x.2⁻¹, x.1⁻¹⟩) (fun x => ⟨x.2⁻¹, x.1⁻¹⟩) (fun x => Prod.ext (inv_inv _) (inv_inv _)) fun x =>\n      Prod.ext (inv_inv _) (inv_inv _)\n  let ψ : «expr ≃ » G G := equiv.mk (fun g : G => g⁻¹) (fun g : G => g⁻¹) inv_inv inv_inv\n  suffices (ψ ∘ fun x : H × K => x.1.1 * x.2.1) = (fun x : K × H => x.1.1 * x.2.1) ∘ ϕ by\n    rwa [is_complement'_def, is_complement, ← equiv.bijective_comp, ← this, equiv.comp_bijective]\n  exact funext fun x => mul_inv_rev _ _\n#align is_complement'.symm is_complement'.symm\n\n",
 "sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_complement'.sup_eq_top (h : is_complement' H K) : «expr ⊔ » H K = «expr⊤» :=\n  h.is_compl.sup_eq_top\n#align is_complement'.sup_eq_top is_complement'.sup_eq_top\n\n",
 "smul_to_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_to_fun (f : F) (T : left_transversals (H : set G)) (g : G) :\n    («expr • » f (to_fun T.2 g) : G) = to_fun («expr • » f T).2 («expr • » f g) :=\n  subtype.ext_iff.mp <|\n    @ExistsUnique.unique («expr↥ » («expr • » f T)) (fun s => (↑s)⁻¹ * «expr • » f g ∈ H)\n      (mem_left_transversals_iff_exists_unique_inv_mul_mem.mp («expr • » f T).2 («expr • » f g))\n      ⟨«expr • » f (to_fun T.2 g), Set.smul_mem_smul_set (subtype.coe_prop _)⟩\n      (to_fun («expr • » f T).2 («expr • » f g)) (quotient_action.inv_mul_mem f (inv_to_fun_mul_mem T.2 g))\n      (inv_to_fun_mul_mem («expr • » f T).2 («expr • » f g))\n#align smul_to_fun smul_to_fun\n\n",
 "smul_to_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_to_equiv (f : F) (T : left_transversals (H : set G)) (q : «expr ⧸ » G H) :\n    «expr • » f (to_equiv T.2 q : G) = to_equiv («expr • » f T).2 («expr • » f q) :=\n  Quotient.inductionOn' q fun g => smul_to_fun f T g\n#align smul_to_equiv smul_to_equiv\n\n",
 "smul_apply_eq_smul_apply_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_apply_eq_smul_apply_inv_smul (f : F) (T : left_transversals (H : set G)) (q : «expr ⧸ » G H) :\n    (to_equiv («expr • » f T).2 q : G) = «expr • » f (to_equiv T.2 («expr • » f⁻¹ q) : G) := by\n  rw [smul_to_equiv, smul_inv_smul]\n#align smul_apply_eq_smul_apply_inv_smul smul_apply_eq_smul_apply_inv_smul\n\n",
 "range_mem_right_transversals":
 "@[to_additive]\ntheorem range_mem_right_transversals {f : quotient (quotient_group.right_rel H) → G}\n    (hf : ∀ q, quotient.mk' (f q) = q) : Set.range f ∈ right_transversals (H : set G) :=\n  mem_right_transversals_iff_bijective.mpr\n    ⟨by rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h <;> exact congr_arg _ (((hf q₁).symm.trans h).trans (hf q₂)), fun q =>\n      ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n#align range_mem_right_transversals range_mem_right_transversals\n\n",
 "range_mem_left_transversals":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem range_mem_left_transversals {f : «expr ⧸ » G H → G} (hf : ∀ q, ↑(f q) = q) :\n    Set.range f ∈ left_transversals (H : set G) :=\n  mem_left_transversals_iff_bijective.mpr\n    ⟨by rintro ⟨-, q₁, rfl⟩ ⟨-, q₂, rfl⟩ h <;> exact congr_arg _ (((hf q₁).symm.trans h).trans (hf q₂)), fun q =>\n      ⟨⟨f q, q, rfl⟩, hf q⟩⟩\n#align range_mem_left_transversals range_mem_left_transversals\n\n",
 "quotient_equiv_sigma_zmod_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem quotient_equiv_sigma_zmod_symm_apply (q : orbit_rel.quotient (zpowers g) («expr ⧸ » G H))\n    (k : zmod (minimal_period ((«expr • » · ·) g) q.out')) :\n    (quotient_equiv_sigma_zmod H g).symm ⟨q, k⟩ = «expr • » (g ^ (k : ℤ)) q.out' :=\n  rfl\n#align quotient_equiv_sigma_zmod_symm_apply quotient_equiv_sigma_zmod_symm_apply\n\n",
 "quotient_equiv_sigma_zmod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem quotient_equiv_sigma_zmod_apply (q : orbit_rel.quotient (zpowers g) («expr ⧸ » G H)) (k : ℤ) :\n    quotient_equiv_sigma_zmod H g («expr • » (g ^ k) q.out') = ⟨q, k⟩ := by\n  rw [apply_eq_iff_eq_symm_apply, quotient_equiv_sigma_zmod_symm_apply, zmod.coe_int_cast, zpow_smul_mod_minimal_period]\n#align quotient_equiv_sigma_zmod_apply quotient_equiv_sigma_zmod_apply\n\n",
 "mul_inv_to_fun_mem":
 "@[to_additive]\ntheorem mul_inv_to_fun_mem (hS : S ∈ subgroup.right_transversals (H : set G)) (g : G) : g * (to_fun hS g : G)⁻¹ ∈ H :=\n  quotient_group.right_rel_apply.mp <| quotient.exact' <| mk'_to_equiv _ _\n#align mul_inv_to_fun_mem mul_inv_to_fun_mem\n\n",
 "mk'_to_equiv":
 "@[to_additive]\ntheorem mk'_to_equiv (hS : S ∈ subgroup.right_transversals (H : set G)) (q : quotient (quotient_group.right_rel H)) :\n    quotient.mk' (to_equiv hS q : G) = q :=\n  (to_equiv hS).symm_apply_apply q\n#align mk'_to_equiv mk'_to_equiv\n\n",
 "mem_transfer_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem mem_transfer_set (q : «expr ⧸ » G H) : transfer_function H g q ∈ transfer_set H g :=\n  ⟨q, rfl⟩\n#align mem_transfer_set mem_transfer_set\n\n",
 "mem_right_transversals_iff_exists_unique_quotient_mk'_eq":
 "@[to_additive]\ntheorem mem_right_transversals_iff_exists_unique_quotient_mk'_eq :\n    S ∈ right_transversals (H : set G) ↔ ∀ q : quotient (quotient_group.right_rel H), ∃! s : S, quotient.mk' s.1 = q :=\n  by\n  simp_rw [mem_right_transversals_iff_exists_unique_mul_inv_mem, SetLike.mem_coe, ← quotient_group.right_rel_apply, ←\n    quotient.eq']\n  exact ⟨fun h q => Quotient.inductionOn' q h, fun h g => h (quotient.mk' g)⟩\n#align mem_right_transversals_iff_exists_unique_quotient_mk'_eq mem_right_transversals_iff_exists_unique_quotient_mk'_eq\n\n",
 "mem_right_transversals_iff_exists_unique_mul_inv_mem":
 "@[to_additive]\ntheorem mem_right_transversals_iff_exists_unique_mul_inv_mem :\n    S ∈ right_transversals T ↔ ∀ g : G, ∃! s : S, g * (s : G)⁻¹ ∈ T :=\n  by\n  rw [right_transversals, Set.mem_setOf_eq, is_complement_iff_exists_unique]\n  refine' ⟨fun h g => _, fun h g => _⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    exact\n      ⟨x.2, (congr_arg (· ∈ T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, fun y hy =>\n        (prod.ext_iff.mp (h2 ⟨⟨g * y⁻¹, hy⟩, y⟩ (inv_mul_cancel_right g y))).2⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    refine' ⟨⟨⟨g * x⁻¹, h1⟩, x⟩, inv_mul_cancel_right g x, fun y hy => _⟩\n    have := h2 y.2 ((congr_arg (· ∈ T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2)\n    exact Prod.ext (subtype.ext (eq_mul_inv_of_mul_eq ((congr_arg _ this).mp hy))) this\n#align mem_right_transversals_iff_exists_unique_mul_inv_mem mem_right_transversals_iff_exists_unique_mul_inv_mem\n\n",
 "mem_right_transversals_iff_bijective":
 "@[to_additive]\ntheorem mem_right_transversals_iff_bijective :\n    S ∈ right_transversals (H : set G) ↔\n      function.bijective (S.restrict (quotient.mk' : G → quotient (quotient_group.right_rel H))) :=\n  mem_right_transversals_iff_exists_unique_quotient_mk'_eq.trans\n    (Function.bijective_iff_existsUnique (S.restrict quotient.mk')).symm\n#align mem_right_transversals_iff_bijective mem_right_transversals_iff_bijective\n\n",
 "mem_left_transversals_iff_exists_unique_quotient_mk'_eq":
 "@[to_additive]\ntheorem mem_left_transversals_iff_exists_unique_quotient_mk'_eq :\n    S ∈ left_transversals (H : set G) ↔ ∀ q : quotient (quotient_group.left_rel H), ∃! s : S, quotient.mk' s.1 = q :=\n  by\n  simp_rw [mem_left_transversals_iff_exists_unique_inv_mul_mem, SetLike.mem_coe, ← quotient_group.eq']\n  exact ⟨fun h q => Quotient.inductionOn' q h, fun h g => h (quotient.mk' g)⟩\n#align mem_left_transversals_iff_exists_unique_quotient_mk'_eq mem_left_transversals_iff_exists_unique_quotient_mk'_eq\n\n",
 "mem_left_transversals_iff_exists_unique_inv_mul_mem":
 "@[to_additive]\ntheorem mem_left_transversals_iff_exists_unique_inv_mul_mem :\n    S ∈ left_transversals T ↔ ∀ g : G, ∃! s : S, (s : G)⁻¹ * g ∈ T :=\n  by\n  rw [left_transversals, Set.mem_setOf_eq, is_complement_iff_exists_unique]\n  refine' ⟨fun h g => _, fun h g => _⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    exact\n      ⟨x.1, (congr_arg (· ∈ T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, fun y hy =>\n        (prod.ext_iff.mp (h2 ⟨y, y⁻¹ * g, hy⟩ (mul_inv_cancel_left y g))).1⟩\n  · obtain ⟨x, h1, h2⟩ := h g\n    refine' ⟨⟨x, x⁻¹ * g, h1⟩, mul_inv_cancel_left x g, fun y hy => _⟩\n    have := h2 y.1 ((congr_arg (· ∈ T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)\n    exact Prod.ext this (subtype.ext (eq_inv_mul_of_mul_eq ((congr_arg _ this).mp hy)))\n#align mem_left_transversals_iff_exists_unique_inv_mul_mem mem_left_transversals_iff_exists_unique_inv_mul_mem\n\n",
 "mem_left_transversals_iff_bijective":
 "@[to_additive]\ntheorem mem_left_transversals_iff_bijective :\n    S ∈ left_transversals (H : set G) ↔\n      function.bijective (S.restrict (quotient.mk' : G → quotient (quotient_group.left_rel H))) :=\n  mem_left_transversals_iff_exists_unique_quotient_mk'_eq.trans\n    (Function.bijective_iff_existsUnique (S.restrict quotient.mk')).symm\n#align mem_left_transversals_iff_bijective mem_left_transversals_iff_bijective\n\n",
 "is_complement_top_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement_top_singleton {g : G} : is_complement («expr⊤» : set G) {g} :=\n  ⟨fun ⟨x, _, rfl⟩ ⟨y, _, rfl⟩ h => Prod.ext (subtype.ext (mul_right_cancel h)) rfl, fun x =>\n    ⟨⟨⟨x * g⁻¹, ⟨⟩⟩, g, rfl⟩, inv_mul_cancel_right x g⟩⟩\n#align is_complement_top_singleton is_complement_top_singleton\n\n",
 "is_complement_top_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement_top_right : is_complement S («expr⊤») ↔ ∃ g : G, S = {g} :=\n  by\n  refine' ⟨fun h => set.exists_eq_singleton_iff_nonempty_subsingleton.mpr ⟨_, fun a ha b hb => _⟩, _⟩\n  · obtain ⟨a, ha⟩ := h.2 1\n    exact ⟨a.1.1, a.1.2⟩\n  · have : (⟨⟨a, ha⟩, ⟨_, mem_top a⁻¹⟩⟩ : S × («expr⊤» : set G)) = ⟨⟨b, hb⟩, ⟨_, mem_top b⁻¹⟩⟩ :=\n      h.1 ((mul_inv_self a).trans (mul_inv_self b).symm)\n    exact subtype.ext_iff.mp (prod.ext_iff.mp this).1\n  · rintro ⟨g, rfl⟩\n    exact is_complement_singleton_top\n#align is_complement_top_right is_complement_top_right\n\n",
 "is_complement_top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement_top_left : is_complement («expr⊤») S ↔ ∃ g : G, S = {g} :=\n  by\n  refine' ⟨fun h => set.exists_eq_singleton_iff_nonempty_subsingleton.mpr ⟨_, fun a ha b hb => _⟩, _⟩\n  · obtain ⟨a, ha⟩ := h.2 1\n    exact ⟨a.2.1, a.2.2⟩\n  · have : (⟨⟨_, mem_top a⁻¹⟩, ⟨a, ha⟩⟩ : («expr⊤» : set G) × S) = ⟨⟨_, mem_top b⁻¹⟩, ⟨b, hb⟩⟩ :=\n      h.1 ((inv_mul_self a).trans (inv_mul_self b).symm)\n    exact subtype.ext_iff.mp (prod.ext_iff.mp this).2\n  · rintro ⟨g, rfl⟩\n    exact is_complement_top_singleton\n#align is_complement_top_left is_complement_top_left\n\n",
 "is_complement_singleton_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement_singleton_top {g : G} : is_complement ({g} : set G) («expr⊤») :=\n  ⟨fun ⟨⟨_, rfl⟩, x⟩ ⟨⟨_, rfl⟩, y⟩ h => Prod.ext rfl (subtype.ext (mul_left_cancel h)), fun x =>\n    ⟨⟨⟨g, rfl⟩, g⁻¹ * x, ⟨⟩⟩, mul_inv_cancel_left g x⟩⟩\n#align is_complement_singleton_top is_complement_singleton_top\n\n",
 "is_complement_singleton_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement_singleton_right {g : G} : is_complement S {g} ↔ S = «expr⊤» :=\n  by\n  refine' ⟨fun h => top_le_iff.mp fun x hx => _, fun h => (congr_arg _ h).mpr is_complement_top_singleton⟩\n  obtain ⟨y, hy⟩ := h.2 (x * g)\n  conv_rhs at hy => rw [← show y.2.1 = g from y.2.2]\n  rw [← mul_right_cancel hy]\n  exact y.1.2\n#align is_complement_singleton_right is_complement_singleton_right\n\n",
 "is_complement_singleton_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement_singleton_left {g : G} : is_complement {g} S ↔ S = «expr⊤» :=\n  by\n  refine' ⟨fun h => top_le_iff.mp fun x hx => _, fun h => (congr_arg _ h).mpr is_complement_singleton_top⟩\n  obtain ⟨⟨⟨z, rfl : z = g⟩, y, _⟩, hy⟩ := h.2 (g * x)\n  rwa [← mul_left_cancel hy]\n#align is_complement_singleton_left is_complement_singleton_left\n\n",
 "is_complement_iff_exists_unique":
 "@[to_additive]\ntheorem is_complement_iff_exists_unique : is_complement S T ↔ ∀ g : G, ∃! x : S × T, x.1.1 * x.2.1 = g :=\n  Function.bijective_iff_existsUnique _\n#align is_complement_iff_exists_unique is_complement_iff_exists_unique\n\n",
 "is_complement'_top_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem is_complement'_top_right : is_complement' H («expr⊤») ↔ H = «expr⊥» :=\n  is_complement_top_right.trans coe_eq_singleton\n#align is_complement'_top_right is_complement'_top_right\n\n",
 "is_complement'_top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem is_complement'_top_left : is_complement' («expr⊤») H ↔ H = «expr⊥» :=\n  is_complement_top_left.trans coe_eq_singleton\n#align is_complement'_top_left is_complement'_top_left\n\n",
 "is_complement'_top_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem is_complement'_top_bot : is_complement' («expr⊤» : subgroup G) («expr⊥») :=\n  is_complement_top_singleton\n#align is_complement'_top_bot is_complement'_top_bot\n\n",
 "is_complement'_stabilizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_complement'_stabilizer {α : Type _} [MulAction G α] (a : α) (h1 : ∀ h : H, «expr • » h a = a → h = 1)\n    (h2 : ∀ g : G, ∃ h : H, «expr • » h («expr • » g a) = a) : is_complement' H (mul_action.stabilizer G a) :=\n  by\n  refine' is_complement_iff_exists_unique.mpr fun g => _\n  obtain ⟨h, hh⟩ := h2 g\n  have hh' : «expr • » (↑h * g) a = a := by rwa [mul_smul]\n  refine' ⟨⟨h⁻¹, h * g, hh'⟩, inv_mul_cancel_left h g, _⟩\n  rintro ⟨h', g, hg : «expr • » g a = a⟩ rfl\n  specialize h1 (h * h') (by rwa [mul_smul, smul_def h', ← hg, ← mul_smul, hg])\n  refine' Prod.ext (eq_inv_of_mul_eq_one_right h1) (subtype.ext _)\n  rwa [subtype.ext_iff, coe_one, coe_mul, ← self_eq_mul_left, mul_assoc (↑h) (↑h') g] at h1\n#align is_complement'_stabilizer is_complement'_stabilizer\n\n",
 "is_complement'_of_disjoint_and_mul_eq_univ":
 "theorem is_complement'_of_disjoint_and_mul_eq_univ (h1 : Disjoint H K) (h2 : ↑H * ↑K = (Set.univ : set G)) :\n    is_complement' H K := by\n  refine' ⟨mul_injective_of_disjoint h1, fun g => _⟩\n  obtain ⟨h, k, hh, hk, hg⟩ := set.eq_univ_iff_forall.mp h2 g\n  exact ⟨(⟨h, hh⟩, ⟨k, hk⟩), hg⟩\n#align is_complement'_of_disjoint_and_mul_eq_univ is_complement'_of_disjoint_and_mul_eq_univ\n\n",
 "is_complement'_of_coprime":
 "theorem is_complement'_of_coprime [fintype G] [fintype H] [fintype K]\n    (h1 : fintype.card H * fintype.card K = fintype.card G) (h2 : nat.coprime (fintype.card H) (fintype.card K)) :\n    is_complement' H K :=\n  is_complement'_of_card_mul_and_disjoint h1 (disjoint_iff.mpr (inf_eq_bot_of_coprime h2))\n#align is_complement'_of_coprime is_complement'_of_coprime\n\n",
 "is_complement'_of_card_mul_and_disjoint":
 "theorem is_complement'_of_card_mul_and_disjoint [fintype G] [fintype H] [fintype K]\n    (h1 : fintype.card H * fintype.card K = fintype.card G) (h2 : Disjoint H K) : is_complement' H K :=\n  (fintype.bijective_iff_injective_and_card _).mpr ⟨mul_injective_of_disjoint h2, (fintype.card_prod H K).trans h1⟩\n#align is_complement'_of_card_mul_and_disjoint is_complement'_of_card_mul_and_disjoint\n\n",
 "is_complement'_iff_card_mul_and_disjoint":
 "theorem is_complement'_iff_card_mul_and_disjoint [fintype G] [fintype H] [fintype K] :\n    is_complement' H K ↔ fintype.card H * fintype.card K = fintype.card G ∧ Disjoint H K :=\n  ⟨fun h => ⟨h.card_mul, h.disjoint⟩, fun h => is_complement'_of_card_mul_and_disjoint h.1 h.2⟩\n#align is_complement'_iff_card_mul_and_disjoint is_complement'_iff_card_mul_and_disjoint\n\n",
 "is_complement'_def":
 "/-\nCopyright (c) 2021 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\n@[to_additive]\ntheorem is_complement'_def : is_complement' H K ↔ is_complement (H : set G) (K : set G) :=\n  iff.rfl\n#align is_complement'_def is_complement'_def\n\n",
 "is_complement'_comm":
 "@[to_additive]\ntheorem is_complement'_comm : is_complement' H K ↔ is_complement' K H :=\n  ⟨is_complement'.symm, is_complement'.symm⟩\n#align is_complement'_comm is_complement'_comm\n\n",
 "is_complement'_bot_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem is_complement'_bot_top : is_complement' («expr⊥» : subgroup G) («expr⊤») :=\n  is_complement_singleton_top\n#align is_complement'_bot_top is_complement'_bot_top\n\n",
 "is_complement'_bot_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem is_complement'_bot_right : is_complement' H («expr⊥») ↔ H = «expr⊤» :=\n  is_complement_singleton_right.trans coe_eq_univ\n#align is_complement'_bot_right is_complement'_bot_right\n\n",
 "is_complement'_bot_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem is_complement'_bot_left : is_complement' («expr⊥») H ↔ H = «expr⊤» :=\n  is_complement_singleton_left.trans coe_eq_univ\n#align is_complement'_bot_left is_complement'_bot_left\n\n",
 "is_compl":
 "theorem is_complement'.is_compl (h : is_complement' H K) : IsCompl H K :=\n  by\n  refine'\n    ⟨disjoint_iff_inf_le.mpr fun g ⟨p, q⟩ =>\n        let x : H × K := ⟨⟨g, p⟩, 1⟩\n        let y : H × K := ⟨1, g, q⟩\n        subtype.ext_iff.mp (prod.ext_iff.mp (show x = y from h.1 ((mul_one g).trans (one_mul g).symm))).1,\n      codisjoint_iff_le_sup.mpr fun g _ => _⟩\n  obtain ⟨⟨h, k⟩, rfl⟩ := h.2 g\n  exact subgroup.mul_mem_sup h.2 k.2\n#align is_complement'.is_compl is_complement'.is_compl\n\n",
 "inv_to_fun_mul_mem":
 "@[to_additive]\ntheorem inv_to_fun_mul_mem (hS : S ∈ subgroup.left_transversals (H : set G)) (g : G) : (to_fun hS g : G)⁻¹ * g ∈ H :=\n  quotient_group.left_rel_apply.mp <| quotient.exact' <| mk'_to_equiv _ _\n#align inv_to_fun_mul_mem inv_to_fun_mul_mem\n\n",
 "inv_mul_to_fun_mem":
 "@[to_additive]\ntheorem inv_mul_to_fun_mem (hS : S ∈ subgroup.left_transversals (H : set G)) (g : G) : g⁻¹ * to_fun hS g ∈ H :=\n  (congr_arg (· ∈ H) (by rw [mul_inv_rev, inv_inv])).mp (H.inv_mem (inv_to_fun_mul_mem hS g))\n#align inv_mul_to_fun_mem inv_mul_to_fun_mem\n\n",
 "index_eq_card":
 "theorem is_complement'.index_eq_card (h : is_complement' H K) : K.index = nat.card H :=\n  (card_left_transversal h).symm\n#align is_complement'.index_eq_card is_complement'.index_eq_card\n\n",
 "exists_unique":
 "@[to_additive]\ntheorem is_complement.exists_unique (h : is_complement S T) (g : G) : ∃! x : S × T, x.1.1 * x.2.1 = g :=\n  is_complement_iff_exists_unique.mp h g\n#align is_complement.exists_unique is_complement.exists_unique\n\n",
 "exists_right_transversal":
 "@[to_additive]\ntheorem exists_right_transversal (g : G) : ∃ S ∈ right_transversals (H : set G), g ∈ S := by\n  classical\n    refine'\n      ⟨Set.range (function.update quotient.out' _ g), range_mem_right_transversals fun q => _, quotient.mk' g,\n        function.update_same (quotient.mk' g) g quotient.out'⟩\n    by_cases hq : q = quotient.mk' g\n    · exact hq.symm ▸ congr_arg _ (function.update_same (quotient.mk' g) g quotient.out')\n    · exact eq.trans (congr_arg _ (function.update_noteq hq g quotient.out')) q.out_eq'\n#align exists_right_transversal exists_right_transversal\n\n",
 "exists_left_transversal":
 "@[to_additive]\ntheorem exists_left_transversal (g : G) : ∃ S ∈ left_transversals (H : set G), g ∈ S := by\n  classical\n    refine'\n      ⟨Set.range (function.update quotient.out' (↑g) g), range_mem_left_transversals fun q => _, g,\n        function.update_same g g quotient.out'⟩\n    by_cases hq : q = g\n    · exact hq.symm ▸ congr_arg _ (function.update_same g g quotient.out')\n    · exact eq.trans (congr_arg _ (function.update_noteq hq g quotient.out')) q.out_eq'\n#align exists_left_transversal exists_left_transversal\n\n",
 "disjoint":
 "theorem is_complement'.disjoint (h : is_complement' H K) : Disjoint H K :=\n  h.is_compl.disjoint\n#align is_complement'.disjoint is_complement'.disjoint\n\n",
 "coe_transfer_function":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem coe_transfer_function (q : «expr ⧸ » G H) : ↑(transfer_function H g q) = q := by\n  rw [transfer_function_apply, ← smul_eq_mul, coe_smul_out', ← quotient_equiv_sigma_zmod_symm_apply, sigma.eta,\n    symm_apply_apply]\n#align coe_transfer_function coe_transfer_function\n\n",
 "card_right_transversal":
 "@[to_additive]\ntheorem card_right_transversal (h : S ∈ right_transversals (H : set G)) : nat.card S = H.index :=\n  nat.card_congr <|\n    (Equiv.ofBijective _ <| mem_right_transversals_iff_bijective.mp h).trans <|\n      quotient_group.quotient_right_rel_equiv_quotient_left_rel H\n#align card_right_transversal card_right_transversal\n\n",
 "card_mul":
 "theorem is_complement'.card_mul [fintype G] [fintype H] [fintype K] (h : is_complement' H K) :\n    fintype.card H * fintype.card K = fintype.card G :=\n  h.card_mul\n#align is_complement'.card_mul is_complement'.card_mul\n\n",
 "card_left_transversal":
 "@[to_additive]\ntheorem card_left_transversal (h : S ∈ left_transversals (H : set G)) : nat.card S = H.index :=\n  nat.card_congr <| Equiv.ofBijective _ <| mem_left_transversals_iff_bijective.mp h\n#align card_left_transversal card_left_transversal\n\n"}