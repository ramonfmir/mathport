{"supr_induction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A dependent version of `submonoid.supr_induction`. -/\n@[elab_as_elim, to_additive \"A dependent version of `add_submonoid.supr_induction`. \"]\ntheorem supr_induction' {ι : Sort _} (S : ι → Submonoid M)\n    {C :\n      ∀ x,\n        x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) →\n          Prop}\n    (hp : ∀ (i), ∀ x ∈ S i, C x (mem_supr_of_mem i ‹_›)) (h1 : C 1 (one_mem _))\n    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i)) :\n    C x hx :=\n  by\n  refine'\n    exists.elim _\n      fun\n        (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i))\n        (hc : C x hx) =>\n      hc\n  refine' supr_induction S hx (fun i x hx => _) _ fun x y => _\n  · exact ⟨_, hp _ _ hx⟩\n  · exact ⟨_, h1⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    refine' ⟨_, hmul _ _ _ _ Cx Cy⟩\n#align supr_induction' supr_induction'\n\n",
 "supr_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[elab_as_elim,\n  to_additive\n      \" An induction principle for elements of `⨆ i, S i`.\\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\\nthen it holds for all elements of the supremum of `S`. \"]\ntheorem supr_induction {ι : Sort _} (S : ι → Submonoid M) {C : M → Prop} {x : M}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i))\n    (hp : ∀ (i), ∀ x ∈ S i, C x) (h1 : C 1) (hmul : ∀ x y, C x → C y → C (x * y)) : C x :=\n  by\n  rw [supr_eq_closure] at hx\n  refine' closure_induction hx (fun x hx => _) h1 hmul\n  obtain ⟨i, hi⟩ := set.mem_Union.mp hx\n  exact hp _ _ hi\n#align supr_induction supr_induction\n\n",
 "sup_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem sup_eq_range (s t : Submonoid N) : «expr ⊔ » s t = (s.subtype.coprod t.subtype).mrange := by\n  rw [mrange_eq_map, ← mrange_inl_sup_mrange_inr, map_sup, map_mrange, coprod_comp_inl, map_mrange, coprod_comp_inr,\n    range_subtype, range_subtype]\n#align sup_eq_range sup_eq_range\n\n",
 "prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Product of elements of a submonoid of a `comm_monoid` indexed by a `finset` is in the\n    submonoid. -/\n@[to_additive\n      \"Sum of elements in an `add_submonoid` of an `add_comm_monoid` indexed by a `finset`\\nis in the `add_submonoid`.\"]\ntheorem prod_mem {M : Type _} [comm_monoid M] (S : Submonoid M) {ι : Type _} {t : Finset ι} {f : ι → M}\n    (h : ∀ c ∈ t, f c ∈ S) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f c) ∈ S :=\n  S.multiset_prod_mem (t.1.map f) fun x hx =>\n    let ⟨i, hi, hix⟩ := Multiset.mem_map.1 hx\n    hix ▸ h i hi\n#align prod_mem prod_mem\n\n",
 "powers_subset":
 "theorem powers_subset {n : M} {P : Submonoid M} (h : n ∈ P) : powers n ≤ P := fun x hx =>\n  match x, hx with\n  | _, ⟨i, rfl⟩ => pow_mem h i\n#align powers_subset powers_subset\n\n",
 "powers_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem powers_one : powers (1 : M) = «expr⊥» :=\n  bot_unique <| powers_subset (one_mem _)\n#align powers_one powers_one\n\n",
 "powers_eq_closure":
 "theorem powers_eq_closure (n : M) : powers n = closure {n} :=\n  by\n  ext\n  exact mem_closure_singleton.symm\n#align powers_eq_closure powers_eq_closure\n\n",
 "pow_right_injective_iff_pow_injective":
 "theorem pow_right_injective_iff_pow_injective {n : M} :\n    (function.injective fun m : ℕ => n ^ m) ↔ function.injective (pow n) :=\n  subtype.coe_injective.of_comp_iff (pow n)\n#align pow_right_injective_iff_pow_injective pow_right_injective_iff_pow_injective\n\n",
 "pow_log_eq_self":
 "@[simp]\ntheorem pow_log_eq_self [decidable_eq M] {n : M} (p : powers n) : pow n (log p) = p :=\n  subtype.ext <| nat.find_spec p.prop\n#align pow_log_eq_self pow_log_eq_self\n\n",
 "pow_apply":
 "theorem pow_apply (n : M) (m : ℕ) : submonoid.pow n m = ⟨n ^ m, m, rfl⟩ :=\n  rfl\n#align pow_apply pow_apply\n\n",
 "of_mul_image_powers_eq_multiples_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_mul_image_powers_eq_multiples_of_mul [monoid M] {x : M} :\n    «expr '' » Additive.ofMul (submonoid.powers x : set M) = add_submonoid.multiples (Additive.ofMul x) :=\n  by\n  ext\n  constructor\n  · rintro ⟨y, ⟨n, hy1⟩, hy2⟩\n    use n\n    simpa [← ofMul_pow, hy1]\n  · rintro ⟨n, hn⟩\n    refine' ⟨x ^ n, ⟨n, rfl⟩, _⟩\n    rwa [ofMul_pow]\n#align of_mul_image_powers_eq_multiples_of_mul of_mul_image_powers_eq_multiples_of_mul\n\n",
 "of_mclosure_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_comm_class.of_mclosure_eq_top {N α} [monoid M] [SMul N α] [MulAction M α] {s : set M}\n    (htop : Submonoid.closure s = «expr⊤»)\n    (hs : ∀ x ∈ s, ∀ (y : N) (z : α), «expr • » x («expr • » y z) = «expr • » y («expr • » x z)) :\n    SMulCommClass M N α :=\n  by\n  refine' ⟨fun x => submonoid.induction_of_closure_eq_top_left htop x _ _⟩\n  · intro y z\n    rw [one_smul, one_smul]\n  · clear x\n    intro x hx x' hx' y z\n    rw [mul_smul, mul_smul, hx', hs x hx]\n#align smul_comm_class.of_mclosure_eq_top smul_comm_class.of_mclosure_eq_top\n\n",
 "of_add_image_multiples_eq_powers_of_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem of_add_image_multiples_eq_powers_of_add [add_monoid A] {x : A} :\n    «expr '' » Multiplicative.ofAdd (add_submonoid.multiples x : set A) = submonoid.powers (Multiplicative.ofAdd x) :=\n  by\n  symm\n  rw [Equiv.eq_image_iff_symm_image_eq]\n  exact of_mul_image_powers_eq_multiples_of_mul\n#align of_add_image_multiples_eq_powers_of_add of_add_image_multiples_eq_powers_of_add\n\n",
 "noncomm_prod_mem":
 "@[to_additive]\ntheorem noncomm_prod_mem (S : Submonoid M) {ι : Type _} (t : Finset ι) (f : ι → M) (comm) (h : ∀ c ∈ t, f c ∈ S) :\n    t.noncomm_prod f comm ∈ S := by\n  apply multiset_noncomm_prod_mem\n  intro y\n  rw [Multiset.mem_map]\n  rintro ⟨x, ⟨hx, rfl⟩⟩\n  exact h x hx\n#align noncomm_prod_mem noncomm_prod_mem\n\n",
 "multiset_prod_mem":
 "/-- Product of a multiset of elements in a submonoid of a `comm_monoid` is in the submonoid. -/\n@[to_additive \"Sum of a multiset of elements in an `add_submonoid` of an `add_comm_monoid` is\\nin the `add_submonoid`.\"]\ntheorem multiset_prod_mem {M} [comm_monoid M] (S : Submonoid M) (m : Multiset M) (hm : ∀ a ∈ m, a ∈ S) : m.prod ∈ S :=\n  by\n  lift m to Multiset S using hm\n  rw [← coe_multiset_prod]\n  exact m.prod.coe_prop\n#align multiset_prod_mem multiset_prod_mem\n\n",
 "multiset_noncomm_prod_mem":
 "@[to_additive]\ntheorem multiset_noncomm_prod_mem (S : Submonoid M) (m : Multiset M) (comm) (h : ∀ x ∈ m, x ∈ S) :\n    m.noncomm_prod comm ∈ S := by\n  induction' m using Quotient.inductionOn with l\n  simp only [Multiset.quot_mk_to_coe, multiset.noncomm_prod_coe]\n  exact submonoid.list_prod_mem _ h\n#align multiset_noncomm_prod_mem multiset_noncomm_prod_mem\n\n",
 "mul_right_mem_add_closure":
 "/-- The product of an element of the additive closure of a multiplicative subsemigroup `M`\nand an element of `M` is contained in the additive closure of `M`. -/\ntheorem mul_right_mem_add_closure (ha : a ∈ add_submonoid.closure (S : set R)) (hb : b ∈ S) :\n    a * b ∈ add_submonoid.closure (S : set R) := by\n  revert b\n  refine' add_submonoid.closure_induction ha _ _ _ <;> clear ha a\n  · exact fun r hr b hb => add_submonoid.mem_closure.mpr fun y hy => hy (mul_mem hr hb)\n  · exact fun b hb => by simp only [zero_mul, (add_submonoid.closure (S : set R)).zero_mem]\n  · simp_rw [add_mul]\n    exact fun r s hr hs b hb => (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)\n#align mul_right_mem_add_closure mul_right_mem_add_closure\n\n",
 "mul_mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mul_mem_sup {S T : Submonoid M} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ «expr ⊔ » S T :=\n  («expr ⊔ » S T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n#align mul_mem_sup mul_mem_sup\n\n",
 "mul_mem_add_closure":
 "/-- The product of two elements of the additive closure of a submonoid `M` is an element of the\nadditive closure of `M`. -/\ntheorem mul_mem_add_closure (ha : a ∈ add_submonoid.closure (S : set R)) (hb : b ∈ add_submonoid.closure (S : set R)) :\n    a * b ∈ add_submonoid.closure (S : set R) := by\n  revert a\n  refine' add_submonoid.closure_induction hb _ _ _ <;> clear hb b\n  · exact fun r hr b hb => mul_mem_class.mul_right_mem_add_closure hb hr\n  · exact fun b hb => by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]\n  · simp_rw [mul_add]\n    exact fun r s hr hs b hb => (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)\n#align mul_mem_add_closure mul_mem_add_closure\n\n",
 "mul_left_mem_add_closure":
 "/-- The product of an element of `S` and an element of the additive closure of a multiplicative\nsubmonoid `S` is contained in the additive closure of `S`. -/\ntheorem mul_left_mem_add_closure (ha : a ∈ S) (hb : b ∈ add_submonoid.closure (S : set R)) :\n    a * b ∈ add_submonoid.closure (S : set R) :=\n  mul_mem_add_closure (add_submonoid.mem_closure.mpr fun sT hT => hT ha) hb\n#align mul_left_mem_add_closure mul_left_mem_add_closure\n\n",
 "mrange_lift":
 "@[to_additive]\ntheorem _root_.free_monoid.mrange_lift {α} (f : α → M) : (FreeMonoid.lift f).mrange = closure (Set.range f) := by\n  rw [mrange_eq_map, ← free_monoid.closure_range_of, map_mclosure, ← Set.range_comp, FreeMonoid.lift_comp_of]\n#align free_monoid.mrange_lift free_monoid.mrange_lift\n\n",
 "mem_supr_of_mem":
 "@[to_additive]\ntheorem mem_supr_of_mem {ι : Sort _} {S : ι → Submonoid M} (i : ι) : ∀ {x : M}, x ∈ S i → x ∈ supᵢ S :=\n  show S i ≤ supᵢ S from le_supᵢ _ _\n#align mem_supr_of_mem mem_supr_of_mem\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n-- TODO: this section can be generalized to `[submonoid_class B M] [complete_lattice B]`\n-- such that `complete_lattice.le` coincides with `set_like.le`\n@[to_additive]\ntheorem mem_supr_of_directed {ι} [hι : nonempty ι] {S : ι → Submonoid M} (hS : Directed (· ≤ ·) S) {x : M} :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ i, x ∈ S i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ S i) hi⟩\n  suffices\n    x ∈\n        closure\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (S i : set M)) →\n      ∃ i, x ∈ S i\n    by simpa only [closure_Union, closure_eq (S _)] using this\n  refine' fun hx => closure_induction hx (fun _ => mem_Union.1) _ _\n  · exact hι.elim fun i => ⟨i, (S i).one_mem⟩\n  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hS i j with ⟨k, hki, hkj⟩\n    exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup_right {S T : Submonoid M} : ∀ {x : M}, x ∈ T → x ∈ «expr ⊔ » S T :=\n  show T ≤ «expr ⊔ » S T from le_sup_right\n#align mem_sup_right mem_sup_right\n\n",
 "mem_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup_left {S T : Submonoid M} : ∀ {x : M}, x ∈ S → x ∈ «expr ⊔ » S T :=\n  show S ≤ «expr ⊔ » S T from le_sup_left\n#align mem_sup_left mem_sup_left\n\n",
 "mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup {s t : Submonoid N} {x : N} : x ∈ «expr ⊔ » s t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x := by\n  simp only [sup_eq_range, mem_mrange, coprod_apply, prod.exists, SetLike.exists, coe_subtype, subtype.coe_mk]\n#align mem_sup mem_sup\n\n",
 "mem_powers_iff":
 "theorem mem_powers_iff (x z : M) : x ∈ powers z ↔ ∃ n : ℕ, z ^ n = x :=\n  iff.rfl\n#align mem_powers_iff mem_powers_iff\n\n",
 "mem_powers":
 "@[simp]\ntheorem mem_powers (n : M) : n ∈ powers n :=\n  ⟨1, pow_one _⟩\n#align mem_powers mem_powers\n\n",
 "mem_closure_singleton_self":
 "theorem mem_closure_singleton_self {y : M} : y ∈ closure ({y} : set M) :=\n  mem_closure_singleton.2 ⟨1, pow_one y⟩\n#align mem_closure_singleton_self mem_closure_singleton_self\n\n",
 "mem_closure_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The `add_submonoid` generated by an element of an `add_monoid` equals the set of\nnatural number multiples of the element. -/\ntheorem mem_closure_singleton {x y : A} : y ∈ closure ({x} : set A) ↔ ∃ n : ℕ, «expr • » n x = y := by\n  rw [closure_singleton_eq, AddMonoidHom.mem_mrange] <;> rfl\n#align mem_closure_singleton mem_closure_singleton\n\n",
 "mem_closure_pair":
 "/-- An element is in the closure of a two-element set if it is a linear combination of those two\nelements. -/\n@[to_additive \"An element is in the closure of a two-element set if it is a linear combination of\\nthose two elements.\"]\ntheorem mem_closure_pair {A : Type _} [comm_monoid A] (a b c : A) :\n    c ∈ Submonoid.closure ({a, b} : set A) ↔ ∃ m n : ℕ, a ^ m * b ^ n = c :=\n  by\n  rw [← Set.singleton_union, Submonoid.closure_union, mem_sup]\n  simp_rw [exists_prop, mem_closure_singleton, exists_exists_eq_and]\n#align mem_closure_pair mem_closure_pair\n\n",
 "mem_Sup_of_mem":
 "@[to_additive]\ntheorem mem_Sup_of_mem {S : set (Submonoid M)} {s : Submonoid M} (hs : s ∈ S) : ∀ {x : M}, x ∈ s → x ∈ supₛ S :=\n  show s ≤ supₛ S from le_supₛ hs\n#align mem_Sup_of_mem mem_Sup_of_mem\n\n",
 "mem_Sup_of_directed_on":
 "@[to_additive]\ntheorem mem_Sup_of_directed_on {S : set (Submonoid M)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) {x : M} :\n    x ∈ supₛ S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : nonempty S := Sne.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hS.directed_coe, SetCoe.exists, subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "map_powers":
 "@[simp]\ntheorem map_powers {N : Type _} {F : Type _} [monoid N] [MonoidHomClass F M N] (f : F) (m : M) :\n    (powers m).map f = powers (f m) := by simp only [powers_eq_closure, map_mclosure f, Set.image_singleton]\n#align map_powers map_powers\n\n",
 "log_pow_int_eq_self":
 "theorem log_pow_int_eq_self {x : ℤ} (h : 1 < x.nat_abs) (m : ℕ) : log (pow x m) = m :=\n  (pow_log_equiv (Int.pow_right_injective h)).symm_apply_apply _\n#align log_pow_int_eq_self log_pow_int_eq_self\n\n",
 "log_pow_eq_self":
 "@[simp]\ntheorem log_pow_eq_self [decidable_eq M] {n : M} (h : function.injective fun m : ℕ => n ^ m) (m : ℕ) :\n    log (pow n m) = m :=\n  pow_right_injective_iff_pow_injective.mp h <| pow_log_eq_self _\n#align log_pow_eq_self log_pow_eq_self\n\n",
 "log_mul":
 "theorem log_mul [decidable_eq M] {n : M} (h : function.injective fun m : ℕ => n ^ m) (x y : powers (n : M)) :\n    log (x * y) = log x + log y :=\n  (pow_log_equiv h).symm.map_mul x y\n#align log_mul log_mul\n\n",
 "list_prod_mem":
 "/-- Product of a list of elements in a submonoid is in the submonoid. -/\n@[to_additive \"Sum of a list of elements in an `add_submonoid` is in the `add_submonoid`.\"]\ntheorem list_prod_mem {l : list M} (hl : ∀ x ∈ l, x ∈ s) : l.prod ∈ s :=\n  by\n  lift l to list s using hl\n  rw [← coe_list_prod]\n  exact l.prod.coe_prop\n#align list_prod_mem list_prod_mem\n\n",
 "induction_of_closure_eq_top_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[elab_as_elim, to_additive]\ntheorem induction_of_closure_eq_top_right {s : set M} {p : M → Prop} (hs : closure s = «expr⊤») (x : M) (H1 : p 1)\n    (Hmul : ∀ (x), ∀ y ∈ s, p x → p (x * y)) : p x :=\n  closure_induction_right\n    (by\n      rw [hs]\n      exact mem_top _)\n    H1 Hmul\n#align induction_of_closure_eq_top_right induction_of_closure_eq_top_right\n\n",
 "induction_of_closure_eq_top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[elab_as_elim, to_additive]\ntheorem induction_of_closure_eq_top_left {s : set M} {p : M → Prop} (hs : closure s = «expr⊤») (x : M) (H1 : p 1)\n    (Hmul : ∀ x ∈ s, ∀ (y), p y → p (x * y)) : p x :=\n  closure_induction_left\n    (by\n      rw [hs]\n      exact mem_top _)\n    H1 Hmul\n#align induction_of_closure_eq_top_left induction_of_closure_eq_top_left\n\n",
 "exists_multiset_of_mem_closure":
 "@[to_additive]\ntheorem exists_multiset_of_mem_closure {M : Type _} [comm_monoid M] {s : set M} {x : M} (hx : x ∈ closure s) :\n    ∃ (l : Multiset M)(hl : ∀ y ∈ l, y ∈ s), l.prod = x :=\n  by\n  obtain ⟨l, h1, h2⟩ := exists_list_of_mem_closure hx\n  exact ⟨l, h1, (Multiset.coe_prod l).trans h2⟩\n#align exists_multiset_of_mem_closure exists_multiset_of_mem_closure\n\n",
 "exists_list_of_mem_closure":
 "@[to_additive]\ntheorem exists_list_of_mem_closure {s : set M} {x : M} (hx : x ∈ closure s) :\n    ∃ (l : list M)(hl : ∀ y ∈ l, y ∈ s), l.prod = x := by\n  rwa [← SetLike.mem_coe, closure_eq_image_prod, Set.mem_image_iff_bex] at hx\n#align exists_list_of_mem_closure exists_list_of_mem_closure\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem coe_supr_of_directed {ι} [nonempty ι] {S : ι → Submonoid M} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          Submonoid M) :\n        set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_multiset_prod":
 "@[simp, norm_cast, to_additive]\ntheorem coe_multiset_prod {M} [comm_monoid M] (S : Submonoid M) (m : Multiset S) : (m.prod : M) = (m.map coe).prod :=\n  S.subtype.map_multiset_prod m\n#align coe_multiset_prod coe_multiset_prod\n\n",
 "coe_list_prod":
 "@[simp, norm_cast, to_additive]\ntheorem coe_list_prod (l : list s) : (l.prod : M) = (l.map coe).prod :=\n  s.subtype.map_list_prod l\n#align coe_list_prod coe_list_prod\n\n",
 "coe_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp, norm_cast, to_additive]\ntheorem coe_finset_prod {ι M} [comm_monoid M] (S : Submonoid M) (f : ι → S) (s : Finset ι) :\n    ↑(finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i) : M) :=\n  S.subtype.map_prod f s\n#align coe_finset_prod coe_finset_prod\n\n",
 "coe_Sup_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem coe_Sup_of_directed_on {S : set (Submonoid M)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) :\n    (↑(supₛ S) : set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑s :=\n  Set.ext fun x => by simp [mem_Sup_of_directed_on Sne hS]\n#align coe_Sup_of_directed_on coe_Sup_of_directed_on\n\n",
 "closure_singleton_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem closure_singleton_zero : closure ({0} : set A) = «expr⊥» := by\n  simp [eq_bot_iff_forall, mem_closure_singleton, nsmul_zero]\n#align closure_singleton_zero closure_singleton_zero\n\n",
 "closure_singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem closure_singleton_one : closure ({1} : set M) = «expr⊥» := by simp [eq_bot_iff_forall, mem_closure_singleton]\n#align closure_singleton_one closure_singleton_one\n\n",
 "closure_singleton_eq":
 "theorem closure_singleton_eq (x : A) : closure ({x} : set A) = (multiplesHom A x).mrange :=\n  closure_eq_of_le (Set.singleton_subset_iff.2 ⟨1, one_nsmul x⟩) fun x ⟨n, hn⟩ =>\n    hn ▸ nsmul_mem (subset_closure <| Set.mem_singleton _) _\n#align closure_singleton_eq closure_singleton_eq\n\n",
 "closure_range_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem closure_range_of : closure (Set.range <| @of α) = «expr⊤» :=\n  eq_top_iff.2 fun x hx =>\n    FreeMonoid.recOn x (one_mem _) fun x xs hxs => mul_mem (subset_closure <| Set.mem_range_self _) hxs\n#align closure_range_of closure_range_of\n\n",
 "closure_induction_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem closure_induction_right {s : set M} {p : M → Prop} {x : M} (h : x ∈ closure s) (H1 : p 1)\n    (Hmul : ∀ (x), ∀ y ∈ s, p x → p (x * y)) : p x :=\n  @closure_induction_left _ _ («expr ⁻¹' » mul_opposite.unop s) (p ∘ mul_opposite.unop) (MulOpposite.op x)\n    (closure_induction h (fun x hx => subset_closure hx) (one_mem _) fun x y hx hy => mul_mem hy hx) H1 fun x hx y =>\n    Hmul _ _ hx\n#align closure_induction_right closure_induction_right\n\n",
 "closure_induction_left":
 "@[to_additive]\ntheorem closure_induction_left {s : set M} {p : M → Prop} {x : M} (h : x ∈ closure s) (H1 : p 1)\n    (Hmul : ∀ x ∈ s, ∀ (y), p y → p (x * y)) : p x :=\n  by\n  rw [closure_eq_mrange] at h\n  obtain ⟨l, rfl⟩ := h\n  induction' l using FreeMonoid.recOn with x y ih\n  · exact H1\n  · simpa only [map_mul, FreeMonoid.lift_eval_of] using Hmul _ x.prop _ ih\n#align closure_induction_left closure_induction_left\n\n",
 "closure_eq_mrange":
 "@[to_additive]\ntheorem closure_eq_mrange (s : set M) : closure s = (FreeMonoid.lift (coe : s → M)).mrange := by\n  rw [free_monoid.mrange_lift, Subtype.range_coe]\n#align closure_eq_mrange closure_eq_mrange\n\n",
 "closure_eq_image_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem closure_eq_image_prod (s : set M) :\n    (closure s : set M) = «expr '' » List.prod { l : list M | ∀ x ∈ l, x ∈ s } :=\n  by\n  rw [closure_eq_mrange, coe_mrange, ← List.range_map_coe, ← Set.range_comp, function.comp]\n  exact congr_arg _ (funext <| FreeMonoid.lift_apply _)\n#align closure_eq_image_prod closure_eq_image_prod\n\n"}