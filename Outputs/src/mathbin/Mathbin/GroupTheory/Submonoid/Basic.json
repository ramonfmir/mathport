{"supr_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem supr_eq_closure {ι : Sort _} (p : ι → Submonoid M) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) =\n      Submonoid.closure\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (p i : set M)) :=\n  by simp_rw [Submonoid.closure_unionᵢ, Submonoid.closure_eq]\n#align supr_eq_closure supr_eq_closure\n\n",
 "subsingleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print subsingleton_iff /-\n@[simp, to_additive]\ntheorem subsingleton_iff : subsingleton (Submonoid M) ↔ subsingleton M :=\n  ⟨fun h =>\n    ⟨fun x y =>\n      have : ∀ i : M, i = 1 := fun i => mem_bot.mp <| subsingleton.elim («expr⊤» : Submonoid M) («expr⊥») ▸ mem_top i\n      (this x).trans (this y).symm⟩,\n    fun h => ⟨fun x y => Submonoid.ext fun i => subsingleton.elim 1 i ▸ by simp [Submonoid.one_mem]⟩⟩\n#align subsingleton_iff subsingleton_iff\n-/\n\n",
 "subset_closure":
 "/-- The submonoid generated by a set includes the set. -/\n@[simp, to_additive \"The `add_submonoid` generated by a set includes the set.\"]\ntheorem subset_closure : s ⊆ closure s := fun x hx => mem_closure.2 fun S hS => hS hx\n#align subset_closure subset_closure\n\n",
 "pow_mem":
 "#print pow_mem /-\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Kenny Lau, Johan Commelin, Mario Carneiro, Kevin Buzzard,\nAmelia Livingston, Yury Kudryashov\n-/\n-- Only needed for notation\n-- Only needed for notation\n@[to_additive]\ntheorem pow_mem {M} [monoid M] {A : Type _} [SetLike A M] [SubmonoidClass A M] {S : A} {x : M} (hx : x ∈ S) :\n    ∀ n : ℕ, x ^ n ∈ S\n  | 0 => by\n    rw [pow_zero]\n    exact one_mem_class.one_mem S\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_mem_class.mul_mem hx (pow_mem n)\n#align pow_mem pow_mem\n-/\n\n",
 "one_mem":
 "/-- A submonoid contains the monoid's 1. -/\n@[to_additive \"An `add_submonoid` contains the monoid's 0.\"]\nprotected theorem one_mem : (1 : M) ∈ S :=\n  one_mem S\n#align one_mem one_mem\n\n",
 "not_mem_of_not_mem_closure":
 "@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n\n",
 "nontrivial_iff":
 "#print nontrivial_iff /-\n@[simp, to_additive]\ntheorem nontrivial_iff : nontrivial (Submonoid M) ↔ nontrivial M :=\n  not_iff_not.mp ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans not_nontrivial_iff_subsingleton.symm)\n#align nontrivial_iff nontrivial_iff\n-/\n\n",
 "mul_mem":
 "/-- A submonoid is closed under multiplication. -/\n@[to_additive \"An `add_submonoid` is closed under addition.\"]\nprotected theorem mul_mem {x y : M} : x ∈ S → y ∈ S → x * y ∈ S :=\n  mul_mem\n#align mul_mem mul_mem\n\n",
 "mk_le_mk":
 "@[simp, to_additive]\ntheorem mk_le_mk {s t : set M} (h_one) (h_mul) (h_one') (h_mul') : mk s h_one h_mul ≤ mk t h_one' h_mul' ↔ s ⊆ t :=\n  iff.rfl\n#align mk_le_mk mk_le_mk\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mem_top (x : M) : x ∈ («expr⊤» : Submonoid M) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem mem_supr {ι : Sort _} (p : ι → Submonoid M) {m : M} :\n    m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) ↔\n      ∀ N, (∀ i, p i ≤ N) → m ∈ N :=\n  by\n  rw [← closure_singleton_le_iff_mem, le_supᵢ_iff]\n  simp only [closure_singleton_le_iff_mem]\n#align mem_supr mem_supr\n\n",
 "mem_submonoid_iff":
 "#print IsUnit.mem_submonoid_iff /-\n@[to_additive]\ntheorem IsUnit.mem_submonoid_iff {M : Type _} [monoid M] (a : M) : a ∈ IsUnit.submonoid M ↔ is_unit a :=\n  by\n  change a ∈ set_of is_unit ↔ is_unit a\n  rw [Set.mem_setOf_eq]\n#align is_unit.mem_submonoid_iff IsUnit.mem_submonoid_iff\n-/\n\n",
 "mem_mk":
 "@[simp, to_additive]\ntheorem mem_mk {s : set M} {x : M} (h_one) (h_mul) : x ∈ mk s h_one h_mul ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem mem_infi {ι : Sort _} {S : ι → Submonoid M} {x : M} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem mem_inf {p p' : Submonoid M} {x : M} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_closure":
 "@[to_additive]\ntheorem mem_closure {x : M} : x ∈ closure s ↔ ∀ S : Submonoid M, s ⊆ S → x ∈ S :=\n  mem_Inf\n#align mem_closure mem_closure\n\n",
 "mem_carrier":
 "@[simp, to_additive]\ntheorem mem_carrier {s : Submonoid M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem mem_bot {x : M} : x ∈ («expr⊥» : Submonoid M) ↔ x = 1 :=\n  Set.mem_singleton_iff\n#align mem_bot mem_bot\n\n",
 "mem_Inf":
 "@[to_additive]\ntheorem mem_Inf {S : set (Submonoid M)} {x : M} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "ext":
 "/-- Two submonoids are equal if they have the same elements. -/\n@[ext, to_additive \"Two `add_submonoid`s are equal if they have the same elements.\"]\ntheorem ext {S T : Submonoid M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "eq_on_mclosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. -/\n@[to_additive \"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid\\nclosure.\"]\ntheorem eq_on_mclosure {f g : «expr →* » M N} {s : set M} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eq_mlocus g from closure_le.2 h\n#align eq_on_mclosure eq_on_mclosure\n\n",
 "eq_of_eq_on_mtop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_of_eq_on_mtop {f g : «expr →* » M N} (h : Set.EqOn f g («expr⊤» : Submonoid M)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_mtop eq_of_eq_on_mtop\n\n",
 "eq_of_eq_on_mdense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem eq_of_eq_on_mdense {s : set M} (hs : closure s = «expr⊤») {f g : «expr →* » M N} (h : s.eq_on f g) : f = g :=\n  eq_of_eq_on_mtop <| hs ▸ eqOn_closureM h\n#align eq_of_eq_on_mdense eq_of_eq_on_mdense\n\n",
 "eq_mlocus_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem eq_mlocus_same (f : «expr →* » M N) : f.eq_mlocus f = «expr⊤» :=\n  SetLike.ext fun _ => eq_self_iff_true _\n#align eq_mlocus_same eq_mlocus_same\n\n",
 "disjoint_def'":
 "@[to_additive]\ntheorem disjoint_def' {p₁ p₂ : Submonoid M} : Disjoint p₁ p₂ ↔ ∀ {x y : M}, x ∈ p₁ → y ∈ p₂ → x = y → x = 1 :=\n  disjoint_def.trans ⟨fun h x y hx hy hxy => h hx <| hxy.symm ▸ hy, fun h x hx hx' => h hx hx' rfl⟩\n#align disjoint_def' disjoint_def'\n\n",
 "disjoint_def":
 "@[to_additive]\ntheorem disjoint_def {p₁ p₂ : Submonoid M} : Disjoint p₁ p₂ ↔ ∀ {x : M}, x ∈ p₁ → x ∈ p₂ → x = 1 := by\n  simp_rw [disjoint_iff_inf_le, SetLike.le_def, mem_inf, and_imp, mem_bot]\n#align disjoint_def disjoint_def\n\n",
 "dense_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `s` is a dense set in a monoid `M`, `submonoid.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, verify `p 1`,\nand verify that `p x` and `p y` imply `p (x * y)`. -/\n@[elab_as_elim,\n  to_additive\n      \"If `s` is a dense set in an additive monoid `M`,\\n`add_submonoid.closure s = ⊤`, then in order to prove that some predicate `p` holds for all `x : M`\\nit suffices to verify `p x` for `x ∈ s`, verify `p 0`, and verify that `p x` and `p y` imply\\n`p (x + y)`.\"]\ntheorem dense_induction {p : M → Prop} (x : M) {s : set M} (hs : closure s = «expr⊤») (Hs : ∀ x ∈ s, p x) (H1 : p 1)\n    (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  by\n  have : ∀ x ∈ closure s, p x := fun x hx => closure_induction hx Hs H1 Hmul\n  simpa [hs] using this x\n#align dense_induction dense_induction\n\n",
 "copy_eq":
 "@[to_additive]\ntheorem copy_eq {s : set M} (hs : s = S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem coe_top : ((«expr⊤» : Submonoid M) : set M) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_set_mk":
 "@[simp, to_additive]\ntheorem coe_set_mk {s : set M} (h_one) (h_mul) : (mk s h_one h_mul : set M) = s :=\n  rfl\n#align coe_set_mk coe_set_mk\n\n",
 "coe_of_mclosure_eq_top_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_of_mclosure_eq_top_right (f : M → N) (hs : closure s = «expr⊤») (h1 hmul) :\n    «expr⇑ » (ofClosureMEqTopRight f hs h1 hmul) = f :=\n  rfl\n#align coe_of_mclosure_eq_top_right coe_of_mclosure_eq_top_right\n\n",
 "coe_of_mclosure_eq_top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_of_mclosure_eq_top_left (f : M → N) (hs : closure s = «expr⊤») (h1 hmul) :\n    «expr⇑ » (ofClosureMEqTopLeft f hs h1 hmul) = f :=\n  rfl\n#align coe_of_mclosure_eq_top_left coe_of_mclosure_eq_top_left\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_infi {ι : Sort _} {S : ι → Submonoid M} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : set M) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp only [infᵢ, coe_Inf, Set.binterᵢ_range]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem coe_inf (p p' : Submonoid M) : ((«expr ⊓ » p p' : Submonoid M) : set M) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_copy":
 "@[simp, to_additive]\ntheorem coe_copy {s : set M} (hs : s = S) : (S.copy s hs : set M) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem coe_bot : ((«expr⊥» : Submonoid M) : set M) = {1} :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_Inf (S : set (Submonoid M)) :\n    ((infₛ S : Submonoid M) : set M) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem closure_univ : closure (univ : set M) = «expr⊤» :=\n  @coe_top M _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem closure_union (s t : set M) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (Submonoid.gi M).gc.l_sup\n#align closure_union closure_union\n\n",
 "closure_singleton_le_iff_mem":
 "@[simp, to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Submonoid M) : closure {m} ≤ p ↔ m ∈ p := by\n  rw [closure_le, singleton_subset_iff, SetLike.mem_coe]\n#align closure_singleton_le_iff_mem closure_singleton_le_iff_mem\n\n",
 "closure_mono":
 "/-- Submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[to_additive\n      \"Additive submonoid closure of a set is monotone in its argument: if `s ⊆ t`,\\nthen `closure s ≤ closure t`\"]\ntheorem closure_mono ⦃s t : set M⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Subset.trans h subset_closure\n#align closure_mono closure_mono\n\n",
 "closure_le":
 "/-- A submonoid `S` includes `closure s` if and only if it includes `s`. -/\n@[simp, to_additive \"An additive submonoid `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s ≤ S ↔ s ⊆ S :=\n  ⟨Subset.trans subset_closure, fun h => infₛ_le h⟩\n#align closure_le closure_le\n\n",
 "closure_induction₂":
 "/-- An induction principle for closure membership for predicates with two arguments.  -/\n@[elab_as_elim,\n  to_additive \"An induction principle for additive closure membership for\\npredicates with two arguments.\"]\ntheorem closure_induction₂ {p : M → M → Prop} {x} {y : M} (hx : x ∈ closure s) (hy : y ∈ closure s)\n    (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (H1_left : ∀ x, p 1 x) (H1_right : ∀ x, p x 1)\n    (Hmul_left : ∀ x y z, p x z → p y z → p (x * y) z) (Hmul_right : ∀ x y z, p z x → p z y → p z (x * y)) : p x y :=\n  closure_induction hx (fun x xs => closure_induction hy (Hs x xs) (H1_right x) fun z y h₁ h₂ => Hmul_right z _ _ h₁ h₂)\n    (H1_left y) fun x z h₁ h₂ => Hmul_left _ _ _ h₁ h₂\n#align closure_induction₂ closure_induction₂\n\n",
 "closure_induction'":
 "/-- A dependent version of `submonoid.closure_induction`.  -/\n@[elab_as_elim, to_additive \"A dependent version of `add_submonoid.closure_induction`. \"]\ntheorem closure_induction' (s : set M) {p : ∀ x, x ∈ closure s → Prop} (Hs : ∀ (x) (h : x ∈ s), p x (subset_closure h))\n    (H1 : p 1 (one_mem _)) (Hmul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) {x} (hx : x ∈ closure s) :\n    p x hx := by\n  refine' exists.elim _ fun (hx : x ∈ closure s) (hc : p x hx) => hc\n  exact closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) ⟨_, H1⟩ fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ => ⟨_, Hmul _ _ _ _ hx hy⟩\n#align closure_induction' closure_induction'\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. -/\n@[elab_as_elim,\n  to_additive\n      \"An induction principle for additive closure membership. If `p`\\nholds for `0` and all elements of `s`, and is preserved under addition, then `p` holds for all\\nelements of the additive closure of `s`.\"]\ntheorem closure_induction {p : M → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x) (H1 : p 1)\n    (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  (@closure_le _ _ _ ⟨p, Hmul, H1⟩).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_eq_of_le":
 "@[to_additive]\ntheorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure s) : closure s = S :=\n  le_antisymm (closure_le.2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a submonoid `S` equals `S`. -/\n@[simp, to_additive \"Additive closure of an additive submonoid `S` equals `S`\"]\ntheorem closure_eq : closure (S : set M) = S :=\n  (Submonoid.gi M).l_u_eq S\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem closure_empty : closure (∅ : set M) = «expr⊥» :=\n  (Submonoid.gi M).gc.l_bot\n#align closure_empty closure_empty\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem closure_Union {ι} (s : ι → set M) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (Submonoid.gi M).gc.l_supr\n#align closure_Union closure_Union\n\n"}