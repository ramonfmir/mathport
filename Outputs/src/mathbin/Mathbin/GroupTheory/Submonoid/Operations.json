{"top_prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive top_prod_top]\ntheorem top_prod_top : («expr⊤» : Submonoid M).prod («expr⊤» : Submonoid N) = «expr⊤» :=\n  (top_prod _).trans <| comap_top _\n#align top_prod_top top_prod_top\n\n",
 "top_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive top_prod]\ntheorem top_prod (s : Submonoid N) : («expr⊤» : Submonoid M).prod s = s.comap (MonoidHom.snd M N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n#align top_prod top_prod\n\n",
 "top_equiv_to_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem top_equiv_to_monoid_hom : (topEquiv : «expr ≃* » _ M).to_monoid_hom = («expr⊤» : Submonoid M).subtype :=\n  rfl\n#align top_equiv_to_monoid_hom top_equiv_to_monoid_hom\n\n",
 "toSubmonoid_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print AddSubmonoid.toSubmonoid_closure /-\ntheorem AddSubmonoid.toSubmonoid_closure (S : set A) :\n    (add_submonoid.closure S).to_submonoid = Submonoid.closure («expr ⁻¹' » Multiplicative.toAdd S) :=\n  le_antisymm\n    (AddSubmonoid.toSubmonoid.to_galois_connection.l_le <| add_submonoid.closure_le.2 Submonoid.subset_closure)\n    (Submonoid.closure_le.2 add_submonoid.subset_closure)\n#align add_submonoid.to_submonoid_closure AddSubmonoid.toSubmonoid_closure\n-/\n\n",
 "toSubmonoid'_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print AddSubmonoid.toSubmonoid'_closure /-\ntheorem AddSubmonoid.toSubmonoid'_closure (S : set (Additive M)) :\n    (add_submonoid.closure S).to_submonoid' = Submonoid.closure («expr ⁻¹' » Multiplicative.ofAdd S) :=\n  le_antisymm (AddSubmonoid.toSubmonoid'.le_symm_apply.1 <| add_submonoid.closure_le.2 Submonoid.subset_closure)\n    (Submonoid.closure_le.2 add_submonoid.subset_closure)\n#align add_submonoid.to_submonoid'_closure AddSubmonoid.toSubmonoid'_closure\n-/\n\n",
 "toAddSubmonoid_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Submonoid.toAddSubmonoid_closure /-\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Kenny Lau, Johan Commelin, Mario Carneiro, Kevin Buzzard,\nAmelia Livingston, Yury Kudryashov\n-/\ntheorem Submonoid.toAddSubmonoid_closure (S : set M) :\n    (Submonoid.closure S).to_add_submonoid = add_submonoid.closure («expr ⁻¹' » Additive.toMul S) :=\n  le_antisymm (Submonoid.toAddSubmonoid.le_symm_apply.1 <| Submonoid.closure_le.2 add_submonoid.subset_closure)\n    (add_submonoid.closure_le.2 Submonoid.subset_closure)\n#align submonoid.to_add_submonoid_closure Submonoid.toAddSubmonoid_closure\n-/\n\n",
 "toAddSubmonoid'_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Submonoid.toAddSubmonoid'_closure /-\ntheorem Submonoid.toAddSubmonoid'_closure (S : set (Multiplicative A)) :\n    (Submonoid.closure S).to_add_submonoid' = add_submonoid.closure («expr ⁻¹' » Additive.ofMul S) :=\n  le_antisymm\n    (Submonoid.toAddSubmonoid'.to_galois_connection.l_le <| Submonoid.closure_le.2 add_submonoid.subset_closure)\n    (add_submonoid.closure_le.2 Submonoid.subset_closure)\n#align submonoid.to_add_submonoid'_closure Submonoid.toAddSubmonoid'_closure\n-/\n\n",
 "submonoid_map_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive add_equiv.add_submonoid_map_symm_apply]\ntheorem submonoid_map_symm_apply (e : «expr ≃* » M N) (S : Submonoid M) (g : S.map (e : «expr →* » M N)) :\n    (e.submonoid_map S).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=\n  rfl\n#align submonoid_map_symm_apply submonoid_map_symm_apply\n\n",
 "submonoid_map_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem submonoid_map_surjective (f : «expr →* » M N) (M' : Submonoid M) : function.surjective (f.submonoid_map M') :=\n  by\n  rintro ⟨_, x, hx, rfl⟩\n  exact ⟨⟨x, hx⟩, rfl⟩\n#align submonoid_map_surjective submonoid_map_surjective\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem smul_def [SMul M' α] {S : Submonoid M'} (g : S) (m : α) : «expr • » g m = «expr • » (g : M') m :=\n  rfl\n#align smul_def smul_def\n\n",
 "restrict_mrange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem restrict_mrange (f : «expr →* » M N) : (f.restrict S).mrange = S.map f := by\n  simp_rw [SetLike.ext_iff, mem_mrange, mem_map, restrict_apply, SetLike.exists, subtype.coe_mk, iff_self_iff,\n    forall_const]\n#align restrict_mrange restrict_mrange\n\n",
 "restrict_mker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem restrict_mker (f : «expr →* » M N) : (f.restrict S).mker = f.mker.comap S.subtype :=\n  rfl\n#align restrict_mker restrict_mker\n\n",
 "restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem restrict_apply {N S : Type _} [mul_one_class N] [SetLike S M] [SubmonoidClass S M] (f : «expr →* » M N) (s : S)\n    (x : s) : f.restrict s x = f x :=\n  rfl\n#align restrict_apply restrict_apply\n\n",
 "range_subtype":
 "@[simp, to_additive]\ntheorem range_subtype (s : Submonoid M) : s.subtype.mrange = s :=\n  SetLike.coe_injective <| (coe_mrange _).trans <| Subtype.range_coe\n#align range_subtype range_subtype\n\n",
 "range_restrict_mker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem range_restrict_mker (f : «expr →* » M N) : mker (mrangeRestrict f) = mker f :=\n  by\n  ext\n  change (⟨f x, _⟩ : mrange f) = ⟨1, _⟩ ↔ f x = 1\n  simp only\n#align range_restrict_mker range_restrict_mker\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive prod_top]\ntheorem prod_top (s : Submonoid M) : s.prod («expr⊤» : Submonoid N) = s.comap (MonoidHom.fst M N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n#align prod_top prod_top\n\n",
 "prod_mono":
 "@[to_additive prod_mono]\ntheorem prod_mono {s₁ s₂ : Submonoid M} {t₁ t₂ : Submonoid N} (hs : s₁ ≤ s₂) (ht : t₁ ≤ t₂) : s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n#align prod_mono prod_mono\n\n",
 "prod_map_comap_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem prod_map_comap_prod' {M' : Type _} {N' : Type _} [mul_one_class M'] [mul_one_class N'] (f : «expr →* » M N)\n    (g : «expr →* » M' N') (S : Submonoid N) (S' : Submonoid N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n#align prod_map_comap_prod' prod_map_comap_prod'\n\n",
 "prod_le_iff":
 "@[to_additive prod_le_iff]\ntheorem prod_le_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M × N)} :\n    s.prod t ≤ u ↔ s.map (inl M N) ≤ u ∧ t.map (inr M N) ≤ u :=\n  by\n  constructor\n  · intro h\n    constructor\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨hx, Submonoid.one_mem _⟩\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨Submonoid.one_mem _, hx⟩\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ ⟨h1, h2⟩\n    have h1' : inl M N x1 ∈ u := by\n      apply hH\n      simpa using h1\n    have h2' : inr M N x2 ∈ u := by\n      apply hK\n      simpa using h2\n    simpa using Submonoid.mul_mem _ h1' h2'\n#align prod_le_iff prod_le_iff\n\n",
 "prod_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem prod_eq_top_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = «expr⊤» ↔ s = «expr⊤» ∧ t = «expr⊤» := by\n  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← mrange_eq_map, mrange_fst, mrange_snd]\n#align prod_eq_top_iff prod_eq_top_iff\n\n",
 "prod_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem prod_eq_bot_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = «expr⊥» ↔ s = «expr⊥» ∧ t = «expr⊥» := by\n  simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot', mker_inl, mker_inr]\n#align prod_eq_bot_iff prod_eq_bot_iff\n\n",
 "prod_bot_sup_bot_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive prod_bot_sup_bot_prod]\ntheorem prod_bot_sup_bot_prod (s : Submonoid M) (t : Submonoid N) :\n    «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t) = s.prod t :=\n  le_antisymm (sup_le (prod_mono (le_refl s) bot_le) (prod_mono bot_le (le_refl t))) fun p hp =>\n    Prod.fst_mul_snd p ▸\n      mul_mem\n        ((le_sup_left : s.prod («expr⊥») ≤ «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t)) ⟨hp.1, Set.mem_singleton 1⟩)\n        ((le_sup_right : prod («expr⊥») t ≤ «expr ⊔ » (s.prod («expr⊥»)) (prod («expr⊥») t))\n          ⟨Set.mem_singleton 1, hp.2⟩)\n#align prod_bot_sup_bot_prod prod_bot_sup_bot_prod\n\n",
 "pow_mem":
 "#print pow_mem /-\n@[to_additive]\nprotected theorem pow_mem {M : Type _} [monoid M] (S : Submonoid M) {x : M} (hx : x ∈ S) (n : ℕ) : x ^ n ∈ S :=\n  pow_mem hx n\n#align pow_mem pow_mem\n-/\n\n",
 "one_def":
 "@[to_additive]\ntheorem one_def : (1 : S) = ⟨1, S.one_mem⟩ :=\n  rfl\n#align one_def one_def\n\n",
 "nontrivial_iff_exists_ne_one":
 "@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (S : Submonoid M) : nontrivial S ↔ ∃ x ∈ S, x ≠ (1 : M) :=\n  calc\n    nontrivial S ↔ ∃ x : S, x ≠ 1 := nontrivial_iff_exists_ne 1\n    _ ↔ ∃ (x : _)(hx : x ∈ S), (⟨x, hx⟩ : S) ≠ ⟨1, S.one_mem⟩ := subtype.exists\n    _ ↔ ∃ x ∈ S, x ≠ (1 : M) := by simp only [ne.def]\n    \n#align nontrivial_iff_exists_ne_one nontrivial_iff_exists_ne_one\n\n",
 "mul_def":
 "@[to_additive]\ntheorem mul_def (x y : S) : x * y = ⟨x * y, S.mul_mem x.2 y.2⟩ :=\n  rfl\n#align mul_def mul_def\n\n",
 "mrange_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The range of a surjective monoid hom is the whole of the codomain. -/\n@[to_additive \"The range of a surjective `add_monoid` hom is the whole of the codomain.\"]\ntheorem mrange_top_of_surjective (f : F) (hf : function.surjective f) : mrange f = («expr⊤» : Submonoid N) :=\n  mrange_top_iff_surjective.2 hf\n#align mrange_top_of_surjective mrange_top_of_surjective\n\n",
 "mrange_top_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem mrange_top_iff_surjective {f : F} : mrange f = («expr⊤» : Submonoid N) ↔ function.surjective f :=\n  SetLike.ext'_iff.trans <| iff.trans (by rw [coe_mrange, coe_top]) Set.range_iff_surjective\n#align mrange_top_iff_surjective mrange_top_iff_surjective\n\n",
 "mrange_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mrange_snd : (snd M N).mrange = «expr⊤» :=\n  mrange_top_of_surjective (snd M N) <| @prod.snd_surjective _ _ ⟨1⟩\n#align mrange_snd mrange_snd\n\n",
 "mrange_restrict_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem mrange_restrict_surjective (f : «expr →* » M N) : function.surjective f.mrange_restrict := fun ⟨_, ⟨x, rfl⟩⟩ =>\n  ⟨x, rfl⟩\n#align mrange_restrict_surjective mrange_restrict_surjective\n\n",
 "mrange_inr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem mrange_inr' : (inr M N).mrange = comap (fst M N) («expr⊥») :=\n  mrange_inr.trans (prod_top _)\n#align mrange_inr' mrange_inr'\n\n",
 "mrange_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem mrange_inr : (inr M N).mrange = prod («expr⊥») («expr⊤») := by\n  simpa only [mrange_eq_map] using map_inr («expr⊤»)\n#align mrange_inr mrange_inr\n\n",
 "mrange_inl_sup_mrange_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mrange_inl_sup_mrange_inr : «expr ⊔ » (inl M N).mrange (inr M N).mrange = «expr⊤» := by\n  simp only [mrange_inl, mrange_inr, prod_bot_sup_bot_prod, top_prod_top]\n#align mrange_inl_sup_mrange_inr mrange_inl_sup_mrange_inr\n\n",
 "mrange_inl'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem mrange_inl' : (inl M N).mrange = comap (snd M N) («expr⊥») :=\n  mrange_inl.trans (top_prod _)\n#align mrange_inl' mrange_inl'\n\n",
 "mrange_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem mrange_inl : (inl M N).mrange = prod («expr⊤») («expr⊥») := by\n  simpa only [mrange_eq_map] using map_inl («expr⊤»)\n#align mrange_inl mrange_inl\n\n",
 "mrange_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mrange_fst : (fst M N).mrange = «expr⊤» :=\n  mrange_top_of_surjective (fst M N) <| @prod.fst_surjective _ _ ⟨1⟩\n#align mrange_fst mrange_fst\n\n",
 "mrange_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem mrange_eq_map (f : F) : mrange f = («expr⊤» : Submonoid M).map f :=\n  Submonoid.copy_eq _\n#align mrange_eq_map mrange_eq_map\n\n",
 "monotone_map":
 "@[to_additive]\ntheorem monotone_map {f : F} : monotone (map f) :=\n  (gc_map_comap f).monotone_l\n#align monotone_map monotone_map\n\n",
 "monotone_comap":
 "@[to_additive]\ntheorem monotone_comap {f : F} : monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n#align monotone_comap monotone_comap\n\n",
 "mker_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem mker_prod_map {M' : Type _} {N' : Type _} [mul_one_class M'] [mul_one_class N'] (f : «expr →* » M N)\n    (g : «expr →* » M' N') : (prodMap f g).mker = f.mker.prod g.mker := by\n  rw [← comap_bot', ← comap_bot', ← comap_bot', ← prod_map_comap_prod', bot_prod_bot]\n#align mker_prod_map mker_prod_map\n\n",
 "mker_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mker_one : (1 : «expr →* » M N).mker = «expr⊤» := by\n  ext\n  simp [mem_mker]\n#align mker_one mker_one\n\n",
 "mker_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem mker_inr : (inr M N).mker = «expr⊥» := by\n  ext x\n  simp [mem_mker]\n#align mker_inr mker_inr\n\n",
 "mker_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem mker_inl : (inl M N).mker = «expr⊥» := by\n  ext x\n  simp [mem_mker]\n#align mker_inl mker_inl\n\n",
 "mk_pow":
 "@[simp, to_additive]\ntheorem mk_pow {M} [monoid M] {A : Type _} [SetLike A M] [SubmonoidClass A M] {S : A} (x : M) (hx : x ∈ S) (n : ℕ) :\n    (⟨x, hx⟩ : S) ^ n = ⟨x ^ n, pow_mem hx n⟩ :=\n  rfl\n#align mk_pow mk_pow\n\n",
 "mk_mul_mk":
 "@[simp, to_additive]\ntheorem mk_mul_mk (x y : M) (hx : x ∈ S) (hy : y ∈ S) : (⟨x, hx⟩ : S) * ⟨y, hy⟩ = ⟨x * y, S.mul_mem hx hy⟩ :=\n  rfl\n#align mk_mul_mk mk_mul_mk\n\n",
 "mem_prod":
 "@[to_additive mem_prod]\ntheorem mem_prod {s : Submonoid M} {t : Submonoid N} {p : M × N} : p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "mem_mrange":
 "@[simp, to_additive]\ntheorem mem_mrange {f : F} {y : N} : y ∈ mrange f ↔ ∃ x, f x = y :=\n  iff.rfl\n#align mem_mrange mem_mrange\n\n",
 "mem_mker":
 "@[to_additive]\ntheorem mem_mker (f : F) {x : M} : x ∈ mker f ↔ f x = 1 :=\n  iff.rfl\n#align mem_mker mem_mker\n\n",
 "mem_map_of_mem":
 "@[to_additive]\ntheorem mem_map_of_mem (f : F) {S : Submonoid M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_iff_mem":
 "@[to_additive]\ntheorem mem_map_iff_mem {f : F} (hf : function.injective f) {S : Submonoid M} {x : M} : f x ∈ S.map f ↔ x ∈ S :=\n  hf.mem_set_image\n#align mem_map_iff_mem mem_map_iff_mem\n\n",
 "mem_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem mem_map_equiv {f : «expr ≃* » M N} {K : Submonoid M} {x : N} : x ∈ K.map f.to_monoid_hom ↔ f.symm x ∈ K :=\n  @Set.mem_image_equiv _ _ (↑K) f.to_equiv x\n#align mem_map_equiv mem_map_equiv\n\n",
 "mem_map":
 "@[simp, to_additive]\ntheorem mem_map {f : F} {S : Submonoid M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_comap":
 "@[simp, to_additive]\ntheorem mem_comap {S : Submonoid N} {f : F} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mclosure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem mclosure_preimage_le (f : F) (s : set N) : closure («expr ⁻¹' » f s) ≤ (closure s).comap f :=\n  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n#align mclosure_preimage_le mclosure_preimage_le\n\n",
 "map_surjective_of_surjective":
 "@[to_additive]\ntheorem map_surjective_of_surjective : function.surjective (map f) :=\n  (giMapComap hf).l_surjective\n#align map_surjective_of_surjective map_surjective_of_surjective\n\n",
 "map_supr_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem map_supr_comap_of_surjective (S : ι → Submonoid N) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((S i).comap f)).map\n        f =\n      supᵢ S :=\n  (giMapComap hf).l_supr_u _\n#align map_supr_comap_of_surjective map_supr_comap_of_surjective\n\n",
 "map_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem map_supr {ι : Sort _} (f : F) (s : ι → Submonoid M) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_supr\n#align map_supr map_supr\n\n",
 "map_sup_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Submonoid N) : («expr ⊔ » (S.comap f) (T.comap f)).map f = «expr ⊔ » S T :=\n  (giMapComap hf).l_sup_u _ _\n#align map_sup_comap_of_surjective map_sup_comap_of_surjective\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem map_sup (S T : Submonoid M) (f : F) : («expr ⊔ » S T).map f = «expr ⊔ » (S.map f) (T.map f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n#align map_sup map_sup\n\n",
 "map_strict_mono_of_injective":
 "@[to_additive]\ntheorem map_strict_mono_of_injective : strict_mono (map f) :=\n  (gciMapComap hf).strict_mono_l\n#align map_strict_mono_of_injective map_strict_mono_of_injective\n\n",
 "map_mrange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_mrange (g : «expr →* » N P) (f : «expr →* » M N) : f.mrange.map g = (g.comp f).mrange := by\n  simpa only [mrange_eq_map] using («expr⊤» : Submonoid M).map_map g f\n#align map_mrange map_mrange\n\n",
 "map_mclosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\n    by the image of the set. -/\n@[to_additive\n      \"The image under an `add_monoid` hom of the `add_submonoid` generated by a set equals\\nthe `add_submonoid` generated by the image of the set.\"]\ntheorem map_mclosure (f : F) (s : set M) : (closure s).map f = closure («expr '' » f s) :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <| le_trans (closure_mono <| Set.subset_preimage_image _ _) (mclosure_preimage_le _ _))\n    (closure_le.2 <| Set.image_subset _ subset_closure)\n#align map_mclosure map_mclosure\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem map_map (g : «expr →* » N P) (f : «expr →* » M N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_of_le_comap":
 "@[to_additive]\ntheorem map_le_of_le_comap {T : Submonoid N} {f : F} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n#align map_le_of_le_comap map_le_of_le_comap\n\n",
 "map_le_map_iff_of_injective":
 "@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Submonoid M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gciMapComap hf).l_le_l_iff\n#align map_le_map_iff_of_injective map_le_map_iff_of_injective\n\n",
 "map_le_iff_le_comap":
 "@[to_additive]\ntheorem map_le_iff_le_comap {f : F} {S : Submonoid M} {T : Submonoid N} : S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem map_inr (s : Submonoid N) : s.map (inr M N) = prod («expr⊥») s :=\n  ext fun p =>\n    ⟨fun ⟨x, hx, hp⟩ => hp ▸ ⟨Set.mem_singleton 1, hx⟩, fun ⟨hp1, hps⟩ =>\n      ⟨p.2, hps, Prod.ext (Set.eq_of_mem_singleton hp1).symm rfl⟩⟩\n#align map_inr map_inr\n\n",
 "map_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem map_inl (s : Submonoid M) : s.map (inl M N) = s.prod («expr⊥») :=\n  ext fun p =>\n    ⟨fun ⟨x, hx, hp⟩ => hp ▸ ⟨hx, Set.mem_singleton 1⟩, fun ⟨hps, hp1⟩ =>\n      ⟨p.1, hps, Prod.ext rfl <| (Set.eq_of_mem_singleton hp1).symm⟩⟩\n#align map_inl map_inl\n\n",
 "map_injective_of_injective":
 "@[to_additive]\ntheorem map_injective_of_injective : function.injective (map f) :=\n  (gciMapComap hf).l_injective\n#align map_injective_of_injective map_injective_of_injective\n\n",
 "map_infi_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem map_infi_comap_of_surjective (S : ι → Submonoid N) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((S i).comap f)).map\n        f =\n      infᵢ S :=\n  (giMapComap hf).l_infi_u _\n#align map_infi_comap_of_surjective map_infi_comap_of_surjective\n\n",
 "map_inf_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Submonoid N) : («expr ⊓ » (S.comap f) (T.comap f)).map f = «expr ⊓ » S T :=\n  (giMapComap hf).l_inf_u _ _\n#align map_inf_comap_of_surjective map_inf_comap_of_surjective\n\n",
 "map_id":
 "@[simp, to_additive]\ntheorem map_id (S : Submonoid M) : S.map (MonoidHom.id M) = S :=\n  ext fun x => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩\n#align map_id map_id\n\n",
 "map_equiv_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem map_equiv_top (f : «expr ≃* » M N) : («expr⊤» : Submonoid M).map f.to_monoid_hom = «expr⊤» :=\n  SetLike.coe_injective <| Set.image_univ.trans f.surjective.range_eq\n#align map_equiv_top map_equiv_top\n\n",
 "map_equiv_eq_comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : «expr ≃* » M N) (K : Submonoid M) :\n    K.map f.to_monoid_hom = K.comap f.symm.to_monoid_hom :=\n  SetLike.coe_injective (f.to_equiv.image_eq_preimage K)\n#align map_equiv_eq_comap_symm map_equiv_eq_comap_symm\n\n",
 "map_comap_map":
 "@[simp, to_additive]\ntheorem map_comap_map {f : F} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n#align map_comap_map map_comap_map\n\n",
 "map_comap_le":
 "@[to_additive]\ntheorem map_comap_le {S : Submonoid N} {f : F} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_comap_eq_of_surjective":
 "@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Submonoid N) : (S.comap f).map f = S :=\n  (giMapComap hf).l_u_eq _\n#align map_comap_eq_of_surjective map_comap_eq_of_surjective\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem map_bot (f : F) : («expr⊥» : Submonoid M).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "le_prod_iff":
 "@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M × N)} :\n    u ≤ s.prod t ↔ u.map (fst M N) ≤ s ∧ u.map (snd M N) ≤ t :=\n  by\n  constructor\n  · intro h\n    constructor\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).1\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).2\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h\n    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩\n#align le_prod_iff le_prod_iff\n\n",
 "le_comap_of_map_le":
 "@[to_additive]\ntheorem le_comap_of_map_le {T : Submonoid N} {f : F} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n#align le_comap_of_map_le le_comap_of_map_le\n\n",
 "le_comap_map":
 "@[to_additive]\ntheorem le_comap_map {f : F} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "gc_map_comap":
 "@[to_additive]\ntheorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f) := fun S T => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "equiv_map_of_injective_coe_mul_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem submonoid.equiv_map_of_injective_coe_mul_equiv (e : «expr ≃* » M N) :\n    S.equiv_map_of_injective (e : «expr →* » M N) (equiv_like.injective e) = e.submonoid_map S :=\n  by\n  ext\n  rfl\n#align submonoid.equiv_map_of_injective_coe_mul_equiv submonoid.equiv_map_of_injective_coe_mul_equiv\n\n",
 "eq_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_top_iff' : S = «expr⊤» ↔ ∀ x : M, x ∈ S :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n#align eq_top_iff' eq_top_iff'\n\n",
 "eq_bot_iff_forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem eq_bot_iff_forall : S = «expr⊥» ↔ ∀ x ∈ S, x = (1 : M) :=\n  SetLike.ext_iff.trans <| by simp (config := { contextual := true }) [iff_def, S.one_mem]\n#align eq_bot_iff_forall eq_bot_iff_forall\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem comap_top (f : F) : («expr⊤» : Submonoid N).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_surjective_of_injective":
 "@[to_additive]\ntheorem comap_surjective_of_injective : function.surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n#align comap_surjective_of_injective comap_surjective_of_injective\n\n",
 "comap_supr_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem comap_supr_map_of_injective (S : ι → Submonoid M) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((S i).map f)).comap\n        f =\n      supᵢ S :=\n  (gciMapComap hf).u_supr_l _\n#align comap_supr_map_of_injective comap_supr_map_of_injective\n\n",
 "comap_sup_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Submonoid M) : («expr ⊔ » (S.map f) (T.map f)).comap f = «expr ⊔ » S T :=\n  (gciMapComap hf).u_sup_l _ _\n#align comap_sup_map_of_injective comap_sup_map_of_injective\n\n",
 "comap_strict_mono_of_surjective":
 "@[to_additive]\ntheorem comap_strict_mono_of_surjective : strict_mono (comap f) :=\n  (giMapComap hf).strict_mono_u\n#align comap_strict_mono_of_surjective comap_strict_mono_of_surjective\n\n",
 "comap_mker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_mker (g : «expr →* » N P) (f : «expr →* » M N) : g.mker.comap f = (g.comp f).mker :=\n  rfl\n#align comap_mker comap_mker\n\n",
 "comap_map_eq_of_injective":
 "@[to_additive]\ntheorem comap_map_eq_of_injective (S : Submonoid M) : (S.map f).comap f = S :=\n  (gciMapComap hf).u_l_eq _\n#align comap_map_eq_of_injective comap_map_eq_of_injective\n\n",
 "comap_map_comap":
 "@[simp, to_additive]\ntheorem comap_map_comap {S : Submonoid N} {f : F} : ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n#align comap_map_comap comap_map_comap\n\n",
 "comap_le_comap_iff_of_surjective":
 "@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Submonoid N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (giMapComap hf).u_le_u_iff\n#align comap_le_comap_iff_of_surjective comap_le_comap_iff_of_surjective\n\n",
 "comap_injective_of_surjective":
 "@[to_additive]\ntheorem comap_injective_of_surjective : function.injective (comap f) :=\n  (giMapComap hf).u_injective\n#align comap_injective_of_surjective comap_injective_of_surjective\n\n",
 "comap_infi_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem comap_infi_map_of_injective (S : ι → Submonoid M) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((S i).map f)).comap\n        f =\n      infᵢ S :=\n  (gciMapComap hf).u_infi_l _\n#align comap_infi_map_of_injective comap_infi_map_of_injective\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem comap_infi {ι : Sort _} (f : F) (s : ι → Submonoid N) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Submonoid M) : («expr ⊓ » (S.map f) (T.map f)).comap f = «expr ⊓ » S T :=\n  (gciMapComap hf).u_inf_l _ _\n#align comap_inf_map_of_injective comap_inf_map_of_injective\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem comap_inf (S T : Submonoid N) (f : F) : («expr ⊓ » S T).comap f = «expr ⊓ » (S.comap f) (T.comap f) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_id":
 "@[simp, to_additive]\ntheorem comap_id (S : Submonoid P) : S.comap (MonoidHom.id P) = S :=\n  ext (by simp)\n#align comap_id comap_id\n\n",
 "comap_equiv_eq_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : «expr ≃* » N M) (K : Submonoid M) :\n    K.comap f.to_monoid_hom = K.map f.symm.to_monoid_hom :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n#align comap_equiv_eq_map_symm comap_equiv_eq_map_symm\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem comap_comap (S : Submonoid P) (g : «expr →* » N P) (f : «expr →* » M N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "comap_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem comap_bot' (f : F) : («expr⊥» : Submonoid N).comap f = mker f :=\n  rfl\n#align comap_bot' comap_bot'\n\n",
 "coe_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, to_additive]\ntheorem coe_subtype : «expr⇑ » S.subtype = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_submonoid_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n-- this name is primed so that the version to `f.range` instead of `f.mrange` can be unprimed.\n@[simp, to_additive]\ntheorem coe_submonoid_map_apply (e : «expr ≃* » M N) (S : Submonoid M) (g : S) :\n    ((submonoidMap e S g : S.map (e : «expr →* » M N)) : N) = e g :=\n  rfl\n#align coe_submonoid_map_apply coe_submonoid_map_apply\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[to_additive coe_prod]\ntheorem coe_prod (s : Submonoid M) (t : Submonoid N) : (s.prod t : set (M × N)) = set.prod s t :=\n  rfl\n#align coe_prod coe_prod\n\n",
 "coe_pow":
 "@[simp, norm_cast, to_additive]\ntheorem coe_pow {M : Type _} [monoid M] {S : Submonoid M} (x : S) (n : ℕ) : ↑(x ^ n) = (x ^ n : M) :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "@[simp, norm_cast, to_additive]\ntheorem coe_one : ((1 : S) : M) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_mul":
 "@[simp, norm_cast, to_additive]\ntheorem coe_mul (x y : S) : (↑(x * y) : M) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mrange_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem coe_mrange_restrict {N} [mul_one_class N] (f : «expr →* » M N) (x : M) : (f.mrange_restrict x : N) = f x :=\n  rfl\n#align coe_mrange_restrict coe_mrange_restrict\n\n",
 "coe_mrange":
 "@[simp, to_additive]\ntheorem coe_mrange (f : F) : (mrange f : set N) = Set.range f :=\n  rfl\n#align coe_mrange coe_mrange\n\n",
 "coe_mker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[to_additive]\ntheorem coe_mker (f : F) : (mker f : set M) = «expr ⁻¹' » (f : M → N) {1} :=\n  rfl\n#align coe_mker coe_mker\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp, to_additive]\ntheorem coe_map (f : F) (S : Submonoid M) : (S.map f : set N) = «expr '' » f S :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_equiv_map_of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem coe_equiv_map_of_injective_apply (f : «expr →* » M N) (hf : function.injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x :=\n  rfl\n#align coe_equiv_map_of_injective_apply coe_equiv_map_of_injective_apply\n\n",
 "coe_eq_one":
 "@[simp, norm_cast, to_additive]\ntheorem coe_eq_one {x : S'} : (↑x : M₁) = 1 ↔ x = 1 :=\n  (subtype.ext_iff.symm : (x : M₁) = (1 : S') ↔ x = 1)\n#align coe_eq_one coe_eq_one\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp, to_additive]\ntheorem coe_comap (S : Submonoid N) (f : F) : (S.comap f : set M) = «expr ⁻¹' » f S :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "closure_closure_coe_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem closure_closure_coe_preimage {s : set M} : closure («expr ⁻¹' » (coe : closure s → M) s) = «expr⊤» :=\n  eq_top_iff.2 fun x =>\n    subtype.rec_on x fun x hx _ =>\n      by\n      refine' closure_induction' _ (fun g hg => _) _ (fun g₁ g₂ hg₁ hg₂ => _) hx\n      · exact subset_closure hg\n      · exact Submonoid.one_mem _\n      · exact Submonoid.mul_mem _\n#align closure_closure_coe_preimage closure_closure_coe_preimage\n\n",
 "bot_prod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem bot_prod_bot : («expr⊥» : Submonoid M).prod («expr⊥» : Submonoid N) = «expr⊥» :=\n  SetLike.coe_injective <| by simp [coe_prod, Prod.one_eq_mk]\n#align bot_prod_bot bot_prod_bot\n\n",
 "bot_or_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A submonoid is either the trivial submonoid or nontrivial. -/\n@[to_additive \"An additive submonoid is either the trivial additive submonoid or nontrivial.\"]\ntheorem bot_or_nontrivial (S : Submonoid M) : S = «expr⊥» ∨ nontrivial S := by\n  simp only [eq_bot_iff_forall, nontrivial_iff_exists_ne_one, ← not_forall, classical.em]\n#align bot_or_nontrivial bot_or_nontrivial\n\n",
 "bot_or_exists_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A submonoid is either the trivial submonoid or contains a nonzero element. -/\n@[to_additive \"An additive submonoid is either the trivial additive submonoid or contains a nonzero\\nelement.\"]\ntheorem bot_or_exists_ne_one (S : Submonoid M) : S = «expr⊥» ∨ ∃ x ∈ S, x ≠ (1 : M) :=\n  S.bot_or_nontrivial.imp_right S.nontrivial_iff_exists_ne_one.mp\n#align bot_or_exists_ne_one bot_or_exists_ne_one\n\n",
 "apply_coe_mem_map":
 "@[to_additive]\ntheorem apply_coe_mem_map (f : F) (S : Submonoid M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.prop\n#align apply_coe_mem_map apply_coe_mem_map\n\n"}