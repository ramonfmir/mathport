{"to_map_injective":
 "@[to_additive]\ntheorem to_map_injective : function.injective (@LocalizationMap.toMap _ _ S N _) := fun _ _ h =>\n  ext <| MonoidHom.ext_iff.1 h\n#align to_map_injective to_map_injective\n\n",
 "symm_comp_of_mul_equiv_of_localizations_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem symm_comp_of_mul_equiv_of_localizations_apply' {k : «expr ≃* » P N} (x) :\n    k ((f.of_mul_equiv_of_localizations k.symm).to_map x) = f.to_map x :=\n  k.apply_symm_apply (f.to_map x)\n#align symm_comp_of_mul_equiv_of_localizations_apply' symm_comp_of_mul_equiv_of_localizations_apply'\n\n",
 "symm_comp_of_mul_equiv_of_localizations_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem symm_comp_of_mul_equiv_of_localizations_apply {k : «expr ≃* » N P} (x) :\n    k.symm ((f.of_mul_equiv_of_localizations k).to_map x) = f.to_map x :=\n  k.symm_apply_apply (f.to_map x)\n#align symm_comp_of_mul_equiv_of_localizations_apply symm_comp_of_mul_equiv_of_localizations_apply\n\n",
 "surj":
 "@[to_additive]\ntheorem surj (f : LocalizationMap S N) (z : N) : ∃ x : M × S, z * f.to_map x.2 = f.to_map x.1 :=\n  f.3 z\n#align surj surj\n\n",
 "smul_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- TODO: this definition should take `smul_comm_class R M M` instead of `is_scalar_tower R M M` if\n-- we ever want to generalize to the non-commutative case.\ntheorem smul_mk [SMul R M] [IsScalarTower R M M] (c : R) (a b) :\n    «expr • » c (mk a b : Localization S) = mk («expr • » c a) b :=\n  by\n  unfold has_smul.smul Localization.smul\n  apply lift_on_mk\n#align smul_mk smul_mk\n\n",
 "sec_zero_fst":
 "@[simp]\ntheorem localization_map.sec_zero_fst {f : LocalizationMap S N} : f.to_map (f.sec 0).fst = 0 := by\n  rw [localization_map.sec_spec', MulZeroClass.mul_zero]\n#align localization_map.sec_zero_fst localization_map.sec_zero_fst\n\n",
 "sec_spec'":
 "@[to_additive]\ntheorem sec_spec' {f : LocalizationMap S N} (z : N) : f.to_map (f.sec z).1 = f.to_map (f.sec z).2 * z := by\n  rw [mul_comm, sec_spec]\n#align sec_spec' sec_spec'\n\n",
 "sec_spec":
 "@[to_additive]\ntheorem sec_spec {f : LocalizationMap S N} (z : N) : z * f.to_map (f.sec z).2 = f.to_map (f.sec z).1 :=\n  Classical.choose_spec <| f.surj z\n#align sec_spec sec_spec\n\n",
 "rec_mk":
 "@[simp, to_additive]\ntheorem rec_mk {p : Localization S → Sort u} (f : ∀ (a : M) (b : S), p (mk a b)) (H) (a : M) (b : S) :\n    (rec f H (mk a b) : p (mk a b)) = f a b :=\n  rfl\n#align rec_mk rec_mk\n\n",
 "r_of_eq":
 "@[to_additive]\ntheorem r_of_eq {x y : M × S} (h : ↑y.2 * x.1 = ↑x.2 * y.1) : r S x y :=\n  r_iff_exists.2 ⟨1, by rw [h]⟩\n#align r_of_eq r_of_eq\n\n",
 "r_iff_exists":
 "@[to_additive]\ntheorem r_iff_exists {x y : M × S} : r S x y ↔ ∃ c : S, ↑c * (↑y.2 * x.1) = c * (x.2 * y.1) := by rw [r_eq_r' S] <;> rfl\n#align r_iff_exists r_iff_exists\n\n",
 "r_eq_r'":
 "/-\nCopyright (c) 2019 Amelia Livingston. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Amelia Livingston\n-/\n-- note we multiply by `c` on the left so that we can later generalize to `•`\n/-- The congruence relation used to localize a `comm_monoid` at a submonoid can be expressed\nequivalently as an infimum (see `localization.r`) or explicitly\n(see `localization.r'`). -/\n@[to_additive\n      \"The additive congruence relation used to localize an `add_comm_monoid` at a\\nsubmonoid can be expressed equivalently as an infimum (see `add_localization.r`) or\\nexplicitly (see `add_localization.r'`).\"]\ntheorem r_eq_r' : r S = r' S :=\n  le_antisymm (infₛ_le fun _ => ⟨1, by simp⟩) <|\n    le_infₛ fun b H ⟨p, q⟩ ⟨x, y⟩ ⟨t, ht⟩ =>\n      by\n      rw [← one_mul (p, q), ← one_mul (x, y)]\n      refine' b.trans (b.mul (H (t * y)) (b.refl _)) _\n      convert b.symm (b.mul (H (t * q)) (b.refl (x, y))) using 1\n      dsimp only [Prod.mk_mul_mk, Submonoid.coe_mul] at ht⊢\n      simp_rw [mul_assoc, ht, mul_comm y q]\n#align r_eq_r' r_eq_r'\n\n",
 "one_rel":
 "@[to_additive]\ntheorem one_rel (y : S) : r S 1 (y, y) := fun b hb => hb y\n#align one_rel one_rel\n\n",
 "of_mul_equiv_of_mul_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem of_mul_equiv_of_mul_equiv_apply {k : LocalizationMap T Q} {j : «expr ≃* » M P} (H : S.map j.to_monoid_hom = T)\n    (x) : (f.of_mul_equiv_of_localizations (f.mul_equiv_of_mul_equiv k H)).to_map x = k.to_map (j x) :=\n  ext_iff.1 (f.mul_equiv_of_localizations_right_inv (k.of_mul_equiv_of_dom H)) x\n#align of_mul_equiv_of_mul_equiv_apply of_mul_equiv_of_mul_equiv_apply\n\n",
 "of_mul_equiv_of_mul_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_mul_equiv {k : LocalizationMap T Q} {j : «expr ≃* » M P} (H : S.map j.to_monoid_hom = T) :\n    (f.of_mul_equiv_of_localizations (f.mul_equiv_of_mul_equiv k H)).to_map = k.to_map.comp j.to_monoid_hom :=\n  MonoidHom.ext <| f.of_mul_equiv_of_mul_equiv_apply H\n#align of_mul_equiv_of_mul_equiv of_mul_equiv_of_mul_equiv\n\n",
 "of_mul_equiv_of_localizations_id":
 "@[simp, to_additive]\ntheorem of_mul_equiv_of_localizations_id : f.of_mul_equiv_of_localizations (MulEquiv.refl N) = f := by ext <;> rfl\n#align of_mul_equiv_of_localizations_id of_mul_equiv_of_localizations_id\n\n",
 "of_mul_equiv_of_localizations_eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_localizations_eq_iff_eq {k : «expr ≃* » N P} {x y} :\n    (f.of_mul_equiv_of_localizations k).to_map x = y ↔ f.to_map x = k.symm y :=\n  k.to_equiv.eq_symm_apply.symm\n#align of_mul_equiv_of_localizations_eq_iff_eq of_mul_equiv_of_localizations_eq_iff_eq\n\n",
 "of_mul_equiv_of_localizations_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_localizations_eq {k : «expr ≃* » N P} :\n    (f.of_mul_equiv_of_localizations k).to_map = k.to_monoid_hom.comp f.to_map :=\n  rfl\n#align of_mul_equiv_of_localizations_eq of_mul_equiv_of_localizations_eq\n\n",
 "of_mul_equiv_of_localizations_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_localizations_comp {k : «expr ≃* » N P} {j : «expr ≃* » P Q} :\n    (f.of_mul_equiv_of_localizations (k.trans j)).to_map =\n      j.to_monoid_hom.comp (f.of_mul_equiv_of_localizations k).to_map :=\n  by ext <;> rfl\n#align of_mul_equiv_of_localizations_comp of_mul_equiv_of_localizations_comp\n\n",
 "of_mul_equiv_of_localizations_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem of_mul_equiv_of_localizations_apply {k : «expr ≃* » N P} (x) :\n    (f.of_mul_equiv_of_localizations k).to_map x = k (f.to_map x) :=\n  rfl\n#align of_mul_equiv_of_localizations_apply of_mul_equiv_of_localizations_apply\n\n",
 "of_mul_equiv_of_dom_id":
 "/-- A special case of `f ∘ id = f`, `f` a localization map. -/\n@[simp, to_additive \"A special case of `f ∘ id = f`, `f` a localization map.\"]\ntheorem of_mul_equiv_of_dom_id :\n    f.of_mul_equiv_of_dom\n        (show S.map (MulEquiv.refl M).to_monoid_hom = S from\n          Submonoid.ext fun x => ⟨fun ⟨y, hy, h⟩ => h ▸ hy, fun h => ⟨x, h, rfl⟩⟩) =\n      f :=\n  by ext <;> rfl\n#align of_mul_equiv_of_dom_id of_mul_equiv_of_dom_id\n\n",
 "of_mul_equiv_of_dom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_dom_eq {k : «expr ≃* » P M} (H : T.map k.to_monoid_hom = S) :\n    (f.of_mul_equiv_of_dom H).to_map = f.to_map.comp k.to_monoid_hom :=\n  rfl\n#align of_mul_equiv_of_dom_eq of_mul_equiv_of_dom_eq\n\n",
 "of_mul_equiv_of_dom_comp_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_dom_comp_symm {k : «expr ≃* » P M} (H : T.map k.to_monoid_hom = S) (x) :\n    (f.of_mul_equiv_of_dom H).to_map (k.symm x) = f.to_map x :=\n  congr_arg f.to_map <| k.apply_symm_apply x\n#align of_mul_equiv_of_dom_comp_symm of_mul_equiv_of_dom_comp_symm\n\n",
 "of_mul_equiv_of_dom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem of_mul_equiv_of_dom_comp {k : «expr ≃* » M P} (H : T.map k.symm.to_monoid_hom = S) (x) :\n    (f.of_mul_equiv_of_dom H).to_map (k x) = f.to_map x :=\n  congr_arg f.to_map <| k.symm_apply_apply x\n#align of_mul_equiv_of_dom_comp of_mul_equiv_of_dom_comp\n\n",
 "of_mul_equiv_of_dom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem of_mul_equiv_of_dom_apply {k : «expr ≃* » P M} (H : T.map k.to_monoid_hom = S) (x) :\n    (f.of_mul_equiv_of_dom H).to_map x = f.to_map (k x) :=\n  rfl\n#align of_mul_equiv_of_dom_apply of_mul_equiv_of_dom_apply\n\n",
 "mul_mk'_one_eq_mk'":
 "@[to_additive]\ntheorem mul_mk'_one_eq_mk' (x) (y : S) : f.to_map x * f.mk' 1 y = f.mk' x y := by rw [mul_mk'_eq_mk'_of_mul, mul_one]\n#align mul_mk'_one_eq_mk' mul_mk'_one_eq_mk'\n\n",
 "mul_mk'_eq_mk'_of_mul":
 "@[to_additive]\ntheorem mul_mk'_eq_mk'_of_mul (x₁ x₂) (y : S) : f.to_map x₁ * f.mk' x₂ y = f.mk' (x₁ * x₂) y := by\n  rw [← mk'_one, ← mk'_mul, one_mul]\n#align mul_mk'_eq_mk'_of_mul mul_mk'_eq_mk'_of_mul\n\n",
 "mul_inv_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Given a monoid hom `f : M →* N` and submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`w : M, z : N` and `y ∈ S`, we have `z = w * (f y)⁻¹ ↔ z * f y = w`. -/\n@[to_additive\n      \"Given an add_monoid hom `f : M →+ N` and submonoid `S ⊆ M` such that\\n`f(S) ⊆ add_units N`, for all `w : M, z : N` and `y ∈ S`, we have `z = w - f y ↔ z + f y = w`.\"]\ntheorem mul_inv_right {f : «expr →* » M N} (h : ∀ y : S, IsUnit (f y)) (y : S) (w z) :\n    z = w * ↑(IsUnit.liftRight (f.restrict S) h y)⁻¹ ↔ z * f y = w := by rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]\n#align mul_inv_right mul_inv_right\n\n",
 "mul_inv_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Given a monoid hom `f : M →* N` and submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`w : M, z : N` and `y ∈ S`, we have `w * (f y)⁻¹ = z ↔ w = f y * z`. -/\n@[to_additive\n      \"Given an add_monoid hom `f : M →+ N` and submonoid `S ⊆ M` such that\\n`f(S) ⊆ add_units N`, for all `w : M, z : N` and `y ∈ S`, we have `w - f y = z ↔ w = f y + z`.\"]\ntheorem mul_inv_left {f : «expr →* » M N} (h : ∀ y : S, IsUnit (f y)) (y : S) (w z) :\n    w * ↑(IsUnit.liftRight (f.restrict S) h y)⁻¹ = z ↔ w = f y * z := by\n  rw [mul_comm] <;> convert Units.inv_mul_eq_iff_eq_mul _ <;> exact (IsUnit.coe_liftRight (f.restrict S) h _).symm\n#align mul_inv_left mul_inv_left\n\n",
 "mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print mul_inv /-\n/-- Given a monoid hom `f : M →* N` and submonoid `S ⊆ M` such that\n`f(S) ⊆ Nˣ`, for all `x₁ x₂ : M` and `y₁, y₂ ∈ S`, we have\n`f x₁ * (f y₁)⁻¹ = f x₂ * (f y₂)⁻¹ ↔ f (x₁ * y₂) = f (x₂ * y₁)`. -/\n@[simp,\n  to_additive\n      \"Given an add_monoid hom `f : M →+ N` and submonoid `S ⊆ M` such that\\n`f(S) ⊆ add_units N`, for all `x₁ x₂ : M` and `y₁, y₂ ∈ S`, we have\\n`f x₁ - f y₁ = f x₂ - f y₂ ↔ f (x₁ + y₂) = f (x₂ + y₁)`.\"]\ntheorem mul_inv {f : «expr →* » M N} (h : ∀ y : S, IsUnit (f y)) {x₁ x₂} {y₁ y₂ : S} :\n    f x₁ * ↑(IsUnit.liftRight (f.restrict S) h y₁)⁻¹ = f x₂ * ↑(IsUnit.liftRight (f.restrict S) h y₂)⁻¹ ↔\n      f (x₁ * y₂) = f (x₂ * y₁) :=\n  by rw [mul_inv_right h, mul_assoc, mul_comm _ (f y₂), ← mul_assoc, mul_inv_left h, mul_comm x₂, f.map_mul, f.map_mul]\n#align mul_inv mul_inv\n#align neg_add neg_add\n-/\n\n",
 "mul_equiv_of_quotient_symm_monoid_of":
 "@[simp, to_additive]\ntheorem mul_equiv_of_quotient_symm_monoid_of (x) : (mulEquivOfQuotient f).symm (f.to_map x) = (monoidOf S).to_map x :=\n  f.lift_eq _ _\n#align mul_equiv_of_quotient_symm_monoid_of mul_equiv_of_quotient_symm_monoid_of\n\n",
 "mul_equiv_of_quotient_symm_mk'":
 "@[simp, to_additive]\ntheorem mul_equiv_of_quotient_symm_mk' (x y) : (mulEquivOfQuotient f).symm (f.mk' x y) = (monoidOf S).mk' x y :=\n  f.lift_mk' _ _ _\n#align mul_equiv_of_quotient_symm_mk' mul_equiv_of_quotient_symm_mk'\n\n",
 "mul_equiv_of_quotient_symm_mk":
 "@[to_additive]\ntheorem mul_equiv_of_quotient_symm_mk (x y) : (mulEquivOfQuotient f).symm (f.mk' x y) = mk x y := by\n  rw [mk_eq_monoid_of_mk'_apply] <;> exact mul_equiv_of_quotient_symm_mk' _ _\n#align mul_equiv_of_quotient_symm_mk mul_equiv_of_quotient_symm_mk\n\n",
 "mul_equiv_of_quotient_monoid_of":
 "@[simp, to_additive]\ntheorem mul_equiv_of_quotient_monoid_of (x) : mulEquivOfQuotient f ((monoidOf S).to_map x) = f.to_map x :=\n  (monoidOf S).lift_eq _ _\n#align mul_equiv_of_quotient_monoid_of mul_equiv_of_quotient_monoid_of\n\n",
 "mul_equiv_of_quotient_mk'":
 "@[simp, to_additive]\ntheorem mul_equiv_of_quotient_mk' (x y) : mulEquivOfQuotient f ((monoidOf S).mk' x y) = f.mk' x y :=\n  (monoidOf S).lift_mk' _ _ _\n#align mul_equiv_of_quotient_mk' mul_equiv_of_quotient_mk'\n\n",
 "mul_equiv_of_quotient_mk":
 "@[to_additive]\ntheorem mul_equiv_of_quotient_mk (x y) : mulEquivOfQuotient f (mk x y) = f.mk' x y := by\n  rw [mk_eq_monoid_of_mk'_apply] <;> exact mul_equiv_of_quotient_mk' _ _\n#align mul_equiv_of_quotient_mk mul_equiv_of_quotient_mk\n\n",
 "mul_equiv_of_quotient_apply":
 "@[simp, to_additive]\ntheorem mul_equiv_of_quotient_apply (x) : mulEquivOfQuotient f x = (monoidOf S).lift f.map_units x :=\n  rfl\n#align mul_equiv_of_quotient_apply mul_equiv_of_quotient_apply\n\n",
 "mul_equiv_of_mul_equiv_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem mul_equiv_of_mul_equiv_mk' {k : LocalizationMap T Q} {j : «expr ≃* » M P} (H : S.map j.to_monoid_hom = T)\n    (x y) : f.mul_equiv_of_mul_equiv k H (f.mk' x y) = k.mk' (j x) ⟨j y, H ▸ Set.mem_image_of_mem j y.2⟩ :=\n  f.map_mk' (fun y : S => H ▸ Set.mem_image_of_mem j y.2) _ _\n#align mul_equiv_of_mul_equiv_mk' mul_equiv_of_mul_equiv_mk'\n\n",
 "mul_equiv_of_mul_equiv_eq_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem mul_equiv_of_mul_equiv_eq_map_apply {k : LocalizationMap T Q} {j : «expr ≃* » M P}\n    (H : S.map j.to_monoid_hom = T) (x) :\n    f.mul_equiv_of_mul_equiv k H x =\n      f.map (fun y : S => show j.to_monoid_hom y ∈ T from H ▸ Set.mem_image_of_mem j y.2) k x :=\n  rfl\n#align mul_equiv_of_mul_equiv_eq_map_apply mul_equiv_of_mul_equiv_eq_map_apply\n\n",
 "mul_equiv_of_mul_equiv_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem mul_equiv_of_mul_equiv_eq_map {k : LocalizationMap T Q} {j : «expr ≃* » M P} (H : S.map j.to_monoid_hom = T) :\n    (f.mul_equiv_of_mul_equiv k H).to_monoid_hom =\n      f.map (fun y : S => show j.to_monoid_hom y ∈ T from H ▸ Set.mem_image_of_mem j y.2) k :=\n  rfl\n#align mul_equiv_of_mul_equiv_eq_map mul_equiv_of_mul_equiv_eq_map\n\n",
 "mul_equiv_of_mul_equiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem mul_equiv_of_mul_equiv_eq {k : LocalizationMap T Q} {j : «expr ≃* » M P} (H : S.map j.to_monoid_hom = T) (x) :\n    f.mul_equiv_of_mul_equiv k H (f.to_map x) = k.to_map (j x) :=\n  f.map_eq (fun y : S => H ▸ Set.mem_image_of_mem j y.2) _\n#align mul_equiv_of_mul_equiv_eq mul_equiv_of_mul_equiv_eq\n\n",
 "mul_equiv_of_localizations_symm_eq_mul_equiv_of_localizations":
 "@[to_additive]\ntheorem mul_equiv_of_localizations_symm_eq_mul_equiv_of_localizations {k : LocalizationMap S P} :\n    (k.mul_equiv_of_localizations f).symm = f.mul_equiv_of_localizations k :=\n  rfl\n#align mul_equiv_of_localizations_symm_eq_mul_equiv_of_localizations mul_equiv_of_localizations_symm_eq_mul_equiv_of_localizations\n\n",
 "mul_equiv_of_localizations_symm_apply":
 "@[simp, to_additive]\ntheorem mul_equiv_of_localizations_symm_apply {k : LocalizationMap S P} {x} :\n    (f.mul_equiv_of_localizations k).symm x = k.lift f.map_units x :=\n  rfl\n#align mul_equiv_of_localizations_symm_apply mul_equiv_of_localizations_symm_apply\n\n",
 "mul_equiv_of_localizations_right_inv_apply":
 "@[simp, to_additive add_equiv_of_localizations_right_inv_apply]\ntheorem mul_equiv_of_localizations_right_inv_apply {k : LocalizationMap S P} {x} :\n    (f.of_mul_equiv_of_localizations (f.mul_equiv_of_localizations k)).to_map x = k.to_map x :=\n  ext_iff.1 (f.mul_equiv_of_localizations_right_inv k) x\n#align mul_equiv_of_localizations_right_inv_apply mul_equiv_of_localizations_right_inv_apply\n\n",
 "mul_equiv_of_localizations_right_inv":
 "@[to_additive add_equiv_of_localizations_right_inv]\ntheorem mul_equiv_of_localizations_right_inv (k : LocalizationMap S P) :\n    f.of_mul_equiv_of_localizations (f.mul_equiv_of_localizations k) = k :=\n  toMap_injective <| f.lift_comp k.map_units\n#align mul_equiv_of_localizations_right_inv mul_equiv_of_localizations_right_inv\n\n",
 "mul_equiv_of_localizations_left_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp, to_additive]\ntheorem mul_equiv_of_localizations_left_inv_apply {k : «expr ≃* » N P} (x) :\n    f.mul_equiv_of_localizations (f.of_mul_equiv_of_localizations k) x = k x := by\n  rw [mul_equiv_of_localizations_left_inv]\n#align mul_equiv_of_localizations_left_inv_apply mul_equiv_of_localizations_left_inv_apply\n\n",
 "mul_equiv_of_localizations_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[to_additive]\ntheorem mul_equiv_of_localizations_left_inv (k : «expr ≃* » N P) :\n    f.mul_equiv_of_localizations (f.of_mul_equiv_of_localizations k) = k :=\n  MulEquiv.ext <| MonoidHom.ext_iff.1 <| f.lift_of_comp k.to_monoid_hom\n#align mul_equiv_of_localizations_left_inv mul_equiv_of_localizations_left_inv\n\n",
 "mul_equiv_of_localizations_apply":
 "@[simp, to_additive]\ntheorem mul_equiv_of_localizations_apply {k : LocalizationMap S P} {x} :\n    f.mul_equiv_of_localizations k x = f.lift k.map_units x :=\n  rfl\n#align mul_equiv_of_localizations_apply mul_equiv_of_localizations_apply\n\n",
 "mk_zero":
 "theorem mk_zero (x : S) : mk 0 (x : S) = 0 :=\n  calc\n    mk 0 x = mk 0 1 := mk_eq_mk_iff.mpr (r_of_eq (by simp))\n    _ = 0 := rfl\n    \n#align mk_zero mk_zero\n\n",
 "mk_self":
 "@[to_additive]\ntheorem mk_self (a : S) : mk (a : M) a = 1 := by\n  symm\n  rw [← mk_one, mk_eq_mk_iff]\n  exact one_rel a\n#align mk_self mk_self\n\n",
 "mk_pow":
 "@[to_additive]\ntheorem mk_pow (n : ℕ) (a : M) (b : S) : mk a b ^ n = mk (a ^ n) (b ^ n) :=\n  rfl\n#align mk_pow mk_pow\n\n",
 "mk_one_eq_monoid_of_mk":
 "@[to_additive]\ntheorem mk_one_eq_monoid_of_mk (x) : mk x 1 = (monoidOf S).to_map x :=\n  rfl\n#align mk_one_eq_monoid_of_mk mk_one_eq_monoid_of_mk\n\n",
 "mk_one":
 "@[to_additive]\ntheorem mk_one : mk 1 (1 : S) = 1 :=\n  rfl\n#align mk_one mk_one\n\n",
 "mk_mul":
 "@[to_additive]\ntheorem mk_mul (a c : M) (b d : S) : mk a b * mk c d = mk (a * c) (b * d) :=\n  rfl\n#align mk_mul mk_mul\n\n",
 "mk_lt_mk":
 "@[to_additive]\ntheorem mk_lt_mk : mk a₁ a₂ < mk b₁ b₂ ↔ ↑b₂ * a₁ < a₂ * b₁ :=\n  iff.rfl\n#align mk_lt_mk mk_lt_mk\n\n",
 "mk_left_injective":
 "@[to_additive]\ntheorem mk_left_injective (b : s) : injective fun a => mk a b := fun c d h => by\n  simpa [-mk_eq_monoid_of_mk', mk_eq_mk_iff, r_iff_exists] using h\n#align mk_left_injective mk_left_injective\n\n",
 "mk_le_mk":
 "@[to_additive]\ntheorem mk_le_mk : mk a₁ a₂ ≤ mk b₁ b₂ ↔ ↑b₂ * a₁ ≤ a₂ * b₁ :=\n  iff.rfl\n#align mk_le_mk mk_le_mk\n\n",
 "mk_eq_monoid_of_mk'_apply":
 "@[to_additive]\ntheorem mk_eq_monoid_of_mk'_apply (x y) : mk x y = (monoidOf S).mk' x y :=\n  show _ = _ * _ from\n    (Submonoid.LocalizationMap.mul_inv_right (monoidOf S).map_units _ _ _).2 <|\n      by\n      rw [← mk_one_eq_monoid_of_mk, ← mk_one_eq_monoid_of_mk,\n        show mk x y * mk y 1 = mk (x * y) (1 * y) by rw [mul_comm 1 y, mk_mul],\n        show mk x 1 = mk (x * 1) ((1 : S) * 1) by rw [mul_one, mul_one]]\n      exact mk_eq_mk_iff.2 (Con.symm _ <| (Localization.r S).mul (Con.refl _ (x, 1)) <| one_rel _)\n#align mk_eq_monoid_of_mk'_apply mk_eq_monoid_of_mk'_apply\n\n",
 "mk_eq_monoid_of_mk'":
 "@[simp, to_additive]\ntheorem away.mk_eq_monoid_of_mk' : mk = (Away.monoidOf x).mk' :=\n  mk_eq_monoidOf_mk'\n#align away.mk_eq_monoid_of_mk' away.mk_eq_monoid_of_mk'\n\n",
 "mk_eq_mk_iff'":
 "@[to_additive]\ntheorem mk_eq_mk_iff' : mk a₁ a₂ = mk b₁ b₂ ↔ ↑b₂ * a₁ = a₂ * b₁ := by\n  simp_rw [mk_eq_mk_iff, r_iff_exists, mul_left_cancel_iff, exists_const]\n#align mk_eq_mk_iff' mk_eq_mk_iff'\n\n",
 "mk_eq_mk_iff":
 "@[to_additive]\ntheorem mk_eq_mk_iff {a c : M} {b d : S} : mk a b = mk c d ↔ r S ⟨a, b⟩ ⟨c, d⟩ :=\n  (r S).eq\n#align mk_eq_mk_iff mk_eq_mk_iff\n\n",
 "mk'_surjective":
 "@[to_additive]\ntheorem mk'_surjective (z : N) : ∃ (x : _)(y : S), f.mk' x y = z :=\n  ⟨(f.sec z).1, (f.sec z).2, f.mk'_sec z⟩\n#align mk'_surjective mk'_surjective\n\n",
 "mk'_spec'":
 "@[to_additive]\ntheorem mk'_spec' (x) (y : S) : f.to_map y * f.mk' x y = f.to_map x := by rw [mul_comm, mk'_spec]\n#align mk'_spec' mk'_spec'\n\n",
 "mk'_spec":
 "@[to_additive]\ntheorem mk'_spec (x) (y : S) : f.mk' x y * f.to_map y = f.to_map x :=\n  show _ * _ * _ = _ by rw [mul_assoc, mul_comm _ (f.to_map y), ← mul_assoc, mul_inv_left, mul_comm]\n#align mk'_spec mk'_spec\n\n",
 "mk'_self'":
 "@[simp, to_additive]\ntheorem mk'_self' (y : S) : f.mk' (y : M) y = 1 :=\n  show _ * _ = _ by rw [mul_inv_left, mul_one]\n#align mk'_self' mk'_self'\n\n",
 "mk'_self":
 "@[simp, to_additive]\ntheorem mk'_self (x) (H : x ∈ S) : f.mk' x ⟨x, H⟩ = 1 := by convert mk'_self' _ _ <;> rfl\n#align mk'_self mk'_self\n\n",
 "mk'_sec":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, for all `z : N` we have that if\n`x : M, y ∈ S` are such that `z * f y = f x`, then `f x * (f y)⁻¹ = z`. -/\n@[simp,\n  to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, for all `z : N`\\nwe have that if `x : M, y ∈ S` are such that `z + f y = f x`, then `f x - f y = z`.\"]\ntheorem mk'_sec (z : N) : f.mk' (f.sec z).1 (f.sec z).2 = z :=\n  show _ * _ = _ by rw [← sec_spec, mul_inv_left, mul_comm]\n#align mk'_sec mk'_sec\n\n",
 "mk'_one":
 "@[to_additive]\ntheorem mk'_one (x) : f.mk' x (1 : S) = f.to_map x := by rw [mk', MonoidHom.map_one] <;> exact mul_one _\n#align mk'_one mk'_one\n\n",
 "mk'_mul_eq_mk'_of_mul":
 "@[to_additive]\ntheorem mk'_mul_eq_mk'_of_mul (x₁ x₂) (y : S) : f.mk' x₂ y * f.to_map x₁ = f.mk' (x₁ * x₂) y := by\n  rw [mul_comm, mul_mk'_eq_mk'_of_mul]\n#align mk'_mul_eq_mk'_of_mul mk'_mul_eq_mk'_of_mul\n\n",
 "mk'_mul_cancel_right":
 "@[simp, to_additive]\ntheorem mk'_mul_cancel_right (x : M) (y : S) : f.mk' (x * y) y = f.to_map x := by\n  rw [← mul_mk'_one_eq_mk', f.to_map.map_mul, mul_assoc, mul_mk'_one_eq_mk', mk'_self', mul_one]\n#align mk'_mul_cancel_right mk'_mul_cancel_right\n\n",
 "mk'_mul_cancel_left":
 "@[to_additive]\ntheorem mk'_mul_cancel_left (x) (y : S) : f.mk' ((y : M) * x) y = f.to_map x := by rw [mul_comm, mk'_mul_cancel_right]\n#align mk'_mul_cancel_left mk'_mul_cancel_left\n\n",
 "mk'_mul":
 "@[to_additive]\ntheorem mk'_mul (x₁ x₂ : M) (y₁ y₂ : S) : f.mk' (x₁ * x₂) (y₁ * y₂) = f.mk' x₁ y₁ * f.mk' x₂ y₂ :=\n  (mul_inv_left f.map_units _ _ _).2 <|\n    show _ = _ * (_ * _ * (_ * _)) by\n      rw [← mul_assoc, ← mul_assoc, mul_inv_right f.map_units, mul_assoc, mul_assoc, mul_comm _ (f.to_map x₂), ←\n          mul_assoc, ← mul_assoc, mul_inv_right f.map_units, Submonoid.coe_mul, f.to_map.map_mul, f.to_map.map_mul] <;>\n        ac_rfl\n#align mk'_mul mk'_mul\n\n",
 "mk'_eq_of_eq'":
 "@[to_additive]\ntheorem mk'_eq_of_eq' {a₁ b₁ : M} {a₂ b₂ : S} (H : b₁ * ↑a₂ = a₁ * ↑b₂) : f.mk' a₁ a₂ = f.mk' b₁ b₂ :=\n  f.mk'_eq_of_eq <| by simpa only [mul_comm] using H\n#align mk'_eq_of_eq' mk'_eq_of_eq'\n\n",
 "mk'_eq_of_eq":
 "@[to_additive]\ntheorem mk'_eq_of_eq {a₁ b₁ : M} {a₂ b₂ : S} (H : ↑a₂ * b₁ = ↑b₂ * a₁) : f.mk' a₁ a₂ = f.mk' b₁ b₂ :=\n  f.mk'_eq_iff_eq.2 <| H ▸ rfl\n#align mk'_eq_of_eq mk'_eq_of_eq\n\n",
 "mk'_eq_iff_mk'_eq":
 "@[to_additive]\ntheorem mk'_eq_iff_mk'_eq (g : LocalizationMap S P) {x₁ x₂} {y₁ y₂ : S} :\n    f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ g.mk' x₁ y₁ = g.mk' x₂ y₂ :=\n  f.eq'.trans g.eq'.symm\n#align mk'_eq_iff_mk'_eq mk'_eq_iff_mk'_eq\n\n",
 "mk'_eq_iff_eq_mul":
 "@[to_additive]\ntheorem mk'_eq_iff_eq_mul {x} {y : S} {z} : f.mk' x y = z ↔ f.to_map x = z * f.to_map y := by\n  rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]\n#align mk'_eq_iff_eq_mul mk'_eq_iff_eq_mul\n\n",
 "mk'_eq_iff_eq'":
 "@[to_additive]\ntheorem mk'_eq_iff_eq' {x₁ x₂} {y₁ y₂ : S} : f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ f.to_map (x₁ * y₂) = f.to_map (x₂ * y₁) := by\n  simp only [f.mk'_eq_iff_eq, mul_comm]\n#align mk'_eq_iff_eq' mk'_eq_iff_eq'\n\n",
 "mk'_eq_iff_eq":
 "@[to_additive]\ntheorem mk'_eq_iff_eq {x₁ x₂} {y₁ y₂ : S} : f.mk' x₁ y₁ = f.mk' x₂ y₂ ↔ f.to_map (y₂ * x₁) = f.to_map (y₁ * x₂) :=\n  ⟨fun H => by rw [f.to_map.map_mul, f.to_map.map_mul, f.mk'_eq_iff_eq_mul.1 H, ← mul_assoc, mk'_spec', mul_comm],\n    fun H => by\n    rw [mk'_eq_iff_eq_mul, mk', mul_assoc, mul_comm _ (f.to_map y₁), ← mul_assoc, ← f.to_map.map_mul, mul_comm x₂, ← H,\n      ← mul_comm x₁, f.to_map.map_mul, mul_inv_right f.map_units]⟩\n#align mk'_eq_iff_eq mk'_eq_iff_eq\n\n",
 "map_units":
 "@[to_additive]\ntheorem map_units (f : LocalizationMap S N) (y : S) : IsUnit (f.to_map y) :=\n  f.2 y\n#align map_units map_units\n\n",
 "map_spec":
 "/-- Given localization maps `f : M →* N, k : P →* Q` for submonoids `S, T` respectively, if a\n`comm_monoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ↔ k (g x) = k (g y) * u` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n      \"Given localization maps `f : M →+ N, k : P →+ Q` for submonoids `S, T` respectively,\\nif an `add_comm_monoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all\\n`z : N`, `u : Q`, we have `f.map hy k z = u ↔ k (g x) = k (g y) + u` where `x : M, y ∈ S` are such\\nthat `z + f y = f x`.\"]\ntheorem map_spec (z u) : f.map hy k z = u ↔ k.to_map (g (f.sec z).1) = k.to_map (g (f.sec z).2) * u :=\n  f.lift_spec (fun y => k.map_units ⟨g y, hy y⟩) _ _\n#align map_spec map_spec\n\n",
 "map_right_cancel":
 "@[to_additive]\ntheorem map_right_cancel {x y} {c : S} (h : f.to_map (c * x) = f.to_map (c * y)) : f.to_map x = f.to_map y :=\n  by\n  rw [f.to_map.map_mul, f.to_map.map_mul] at h\n  cases' f.map_units c with u hu\n  rw [← hu] at h\n  exact (Units.mul_right_inj u).1 h\n#align map_right_cancel map_right_cancel\n\n",
 "map_mul_right":
 "/-- Given localization maps `f : M →* N, k : P →* Q` for submonoids `S, T` respectively, if a\n`comm_monoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\nwe have `f.map hy k z * k (g y) = k (g x)` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n      \"Given localization maps `f : M →+ N, k : P →+ Q` for submonoids `S, T` respectively,\\nif an `add_comm_monoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then\\nfor all `z : N`, we have `f.map hy k z + k (g y) = k (g x)` where `x : M, y ∈ S` are such that\\n`z + f y = f x`.\"]\ntheorem map_mul_right (z) : f.map hy k z * k.to_map (g (f.sec z).2) = k.to_map (g (f.sec z).1) :=\n  f.lift_mul_right (fun y => k.map_units ⟨g y, hy y⟩) _\n#align map_mul_right map_mul_right\n\n",
 "map_mul_left":
 "/-- Given localization maps `f : M →* N, k : P →* Q` for submonoids `S, T` respectively, if a\n`comm_monoid` homomorphism `g : M →* P` induces a `f.map hy k : N →* Q`, then for all `z : N`,\nwe have `k (g y) * f.map hy k z = k (g x)` where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n      \"Given localization maps `f : M →+ N, k : P →+ Q` for submonoids `S, T` respectively,\\nif an `add_comm_monoid` homomorphism `g : M →+ P` induces a `f.map hy k : N →+ Q`, then for all\\n`z : N`, we have `k (g y) + f.map hy k z = k (g x)` where `x : M, y ∈ S` are such that\\n`z + f y = f x`.\"]\ntheorem map_mul_left (z) : k.to_map (g (f.sec z).2) * f.map hy k z = k.to_map (g (f.sec z).1) := by\n  rw [mul_comm, f.map_mul_right]\n#align map_mul_left map_mul_left\n\n",
 "map_mk'":
 "@[to_additive]\ntheorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) ⟨g y, hy y⟩ :=\n  by\n  rw [map, lift_mk', mul_inv_left]\n  · show k.to_map (g x) = k.to_map (g y) * _\n    rw [mul_mk'_eq_mk'_of_mul]\n    exact (k.mk'_mul_cancel_left (g x) ⟨g y, hy y⟩).symm\n#align map_mk' map_mk'\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- If `comm_monoid` homs `g : M →* P, l : P →* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\n@[to_additive\n      \"If `add_comm_monoid` homs `g : M →+ P, l : P →+ A` induce maps of localizations,\\nthe composition of the induced maps equals the map of localizations induced by `l ∘ g`.\"]\ntheorem map_map {A : Type _} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R] (j : LocalizationMap U R)\n    {l : «expr →* » P A} (hl : ∀ w : T, l w ∈ U) (x) :\n    k.map hl j (f.map hy k x) = f.map (fun x => show l.comp g x ∈ U from hl ⟨g x, hy x⟩) j x := by\n  rw [← f.map_comp_map hy j hl] <;> rfl\n#align map_map map_map\n\n",
 "map_left_cancel":
 "@[to_additive]\ntheorem map_left_cancel {x y} {c : S} (h : f.to_map (x * c) = f.to_map (y * c)) : f.to_map x = f.to_map y :=\n  f.map_right_cancel <| by rw [mul_comm _ x, mul_comm _ y, h]\n#align map_left_cancel map_left_cancel\n\n",
 "map_id":
 "@[simp, to_additive]\ntheorem map_id (z : N) : f.map (fun y => show MonoidHom.id M y ∈ S from y.2) f z = z :=\n  f.lift_id z\n#align map_id map_id\n\n",
 "map_eq":
 "@[to_additive]\ntheorem map_eq (x) : f.map hy k (f.to_map x) = k.to_map (g x) :=\n  f.lift_eq (fun y => k.map_units ⟨g y, hy y⟩) x\n#align map_eq map_eq\n\n",
 "map_comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- If `comm_monoid` homs `g : M →* P, l : P →* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\n@[to_additive\n      \"If `add_comm_monoid` homs `g : M →+ P, l : P →+ A` induce maps of localizations,\\nthe composition of the induced maps equals the map of localizations induced by `l ∘ g`.\"]\ntheorem map_comp_map {A : Type _} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R] (j : LocalizationMap U R)\n    {l : «expr →* » P A} (hl : ∀ w : T, l w ∈ U) :\n    (k.map hl j).comp (f.map hy k) = f.map (fun x => show l.comp g x ∈ U from hl ⟨g x, hy x⟩) j :=\n  by\n  ext z\n  show j.to_map _ * _ = j.to_map (l _) * _\n  · rw [mul_inv_left, ← mul_assoc, mul_inv_right]\n    show j.to_map _ * j.to_map (l (g _)) = j.to_map (l _) * _\n    rw [← j.to_map.map_mul, ← j.to_map.map_mul, ← l.map_mul, ← l.map_mul]\n    exact k.comp_eq_of_eq hl j (by rw [k.to_map.map_mul, k.to_map.map_mul, sec_spec', mul_assoc, map_mul_right])\n#align map_comp_map map_comp_map\n\n",
 "map_comp":
 "@[simp, to_additive]\ntheorem map_comp : (f.map hy k).comp f.to_map = k.to_map.comp g :=\n  f.lift_comp fun y => k.map_units ⟨g y, hy y⟩\n#align map_comp map_comp\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem lift_unique {j : «expr →* » N P} (hj : ∀ x, j (f.to_map x) = g x) : f.lift hg = j :=\n  by\n  ext\n  rw [lift_spec, ← hj, ← hj, ← j.map_mul]\n  apply congr_arg\n  rw [← sec_spec']\n#align lift_unique lift_unique\n\n",
 "lift_surjective_iff":
 "@[to_additive]\ntheorem lift_surjective_iff : function.surjective (f.lift hg) ↔ ∀ v : P, ∃ x : M × S, v * g x.2 = g x.1 :=\n  by\n  constructor\n  · intro H v\n    obtain ⟨z, hz⟩ := H v\n    obtain ⟨x, hx⟩ := f.surj z\n    use x\n    rw [← hz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ↑x.2)]\n    erw [IsUnit.mul_liftRight_inv (g.restrict S) hg, mul_one]\n  · intro H v\n    obtain ⟨x, hx⟩ := H v\n    use f.mk' x.1 x.2\n    rw [lift_mk', mul_inv_left hg, mul_comm, ← hx]\n#align lift_surjective_iff lift_surjective_iff\n\n",
 "lift_spec_mul":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v w : P`, we have\n`f.lift hg z * w = v ↔ g x * w = g y * v`, where `x : M, y ∈ S` are such that\n`z * f y = f x`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, if\\nan `add_comm_monoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all\\n`z : N, v w : P`, we have `f.lift hg z + w = v ↔ g x + w = g y + v`, where `x : M, y ∈ S` are such\\nthat `z + f y = f x`.\"]\ntheorem lift_spec_mul (z w v) : f.lift hg z * w = v ↔ g (f.sec z).1 * w = g (f.sec z).2 * v :=\n  by\n  rw [mul_comm]\n  show _ * (_ * _) = _ ↔ _\n  rw [← mul_assoc, mul_inv_left hg, mul_comm]\n#align lift_spec_mul lift_spec_mul\n\n",
 "lift_spec":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v : P`, we have\n`f.lift hg z = v ↔ g x = g y * v`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, if\\nan `add_comm_monoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all\\n`z : N, v : P`, we have `f.lift hg z = v ↔ g x = g y + v`, where `x : M, y ∈ S` are such that\\n`z + f y = f x`.\"]\ntheorem lift_spec (z v) : f.lift hg z = v ↔ g (f.sec z).1 = g (f.sec z).2 * v :=\n  mul_inv_left hg _ _ v\n#align lift_spec lift_spec\n\n",
 "lift_on₂_mk'":
 "@[simp, to_additive]\ntheorem lift_on₂_mk' {p : Sort _} (f : M → S → M → S → p) (H) (a c : M) (b d : S) :\n    liftOn₂ ((monoidOf S).mk' a b) ((monoidOf S).mk' c d) f H = f a b c d := by rw [← mk_eq_monoid_of_mk', lift_on₂_mk]\n#align lift_on₂_mk' lift_on₂_mk'\n\n",
 "lift_on₂_mk":
 "@[to_additive]\ntheorem lift_on₂_mk {p : Sort _} (f : M → S → M → S → p) (H) (a c : M) (b d : S) :\n    liftOn₂ (mk a b) (mk c d) f H = f a b c d :=\n  rfl\n#align lift_on₂_mk lift_on₂_mk\n\n",
 "lift_on_zero":
 "theorem lift_on_zero {p : Type _} (f : ∀ (x : M) (y : S), p) (H) : liftOn 0 f H = f 0 1 := by\n  rw [← mk_zero 1, lift_on_mk]\n#align lift_on_zero lift_on_zero\n\n",
 "lift_on_mk'":
 "@[simp, to_additive]\ntheorem lift_on_mk' {p : Sort u} (f : ∀ (a : M) (b : S), p) (H) (a : M) (b : S) :\n    liftOn ((monoidOf S).mk' a b) f H = f a b := by rw [← mk_eq_monoid_of_mk', lift_on_mk]\n#align lift_on_mk' lift_on_mk'\n\n",
 "lift_on_mk":
 "@[to_additive]\ntheorem lift_on_mk {p : Sort u} (f : ∀ (a : M) (b : S), p) (H) (a : M) (b : S) : liftOn (mk a b) f H = f a b :=\n  rfl\n#align lift_on_mk lift_on_mk\n\n",
 "lift_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp, to_additive]\ntheorem lift_of_comp (j : «expr →* » N P) : f.lift (f.is_unit_comp j) = j :=\n  by\n  ext\n  rw [lift_spec]\n  show j _ = j _ * _\n  erw [← j.map_mul, sec_spec']\n#align lift_of_comp lift_of_comp\n\n",
 "lift_mul_right":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have\n`f.lift hg z * g y = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, if\\nan `add_comm_monoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N`, we\\nhave `f.lift hg z + g y = g x`, where `x : M, y ∈ S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_right (z) : f.lift hg z * g (f.sec z).2 = g (f.sec z).1 :=\n  show _ * _ * _ = _ by erw [mul_assoc, IsUnit.liftRight_inv_mul, mul_one]\n#align lift_mul_right lift_mul_right\n\n",
 "lift_mul_left":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map\n`g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have\n`g y * f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, if\\nan `add_comm_monoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N`, we\\nhave `g y + f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_left (z) : g (f.sec z).2 * f.lift hg z = g (f.sec z).1 := by rw [mul_comm, lift_mul_right]\n#align lift_mul_left lift_mul_left\n\n",
 "lift_mk'_spec":
 "@[to_additive]\ntheorem lift_mk'_spec (x v) (y : S) : f.lift hg (f.mk' x y) = v ↔ g x = g y * v := by\n  rw [f.lift_mk' hg] <;> exact mul_inv_left hg _ _ _\n#align lift_mk'_spec lift_mk'_spec\n\n",
 "lift_mk'":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M` and a map of `comm_monoid`s\n`g : M →* P` such that `g y` is invertible for all `y : S`, the homomorphism induced from\n`N` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : M, y ∈ S`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M` and a map\\nof `add_comm_monoid`s `g : M →+ P` such that `g y` is invertible for all `y : S`, the homomorphism\\ninduced from `N` to `P` maps `f x - f y` to `g x - g y` for all `x : M, y ∈ S`.\"]\ntheorem lift_mk' (x y) : f.lift hg (f.mk' x y) = g x * ↑(IsUnit.liftRight (g.restrict S) hg y)⁻¹ :=\n  (mul_inv hg).2 <|\n    f.eq_of_eq hg <| by rw [f.to_map.map_mul, f.to_map.map_mul, sec_spec', mul_assoc, f.mk'_spec, mul_comm]\n#align lift_mk' lift_mk'\n\n",
 "lift_left_inverse":
 "/-- Given two localization maps `f : M →* N, k : M →* P` for a submonoid `S ⊆ M`,\nthe hom from `P` to `N` induced by `f` is left inverse to the hom from `N` to `P`\ninduced by `k`. -/\n@[simp,\n  to_additive\n      \"Given two localization maps `f : M →+ N, k : M →+ P` for a submonoid `S ⊆ M`,\\nthe hom from `P` to `N` induced by `f` is left inverse to the hom from `N` to `P`\\ninduced by `k`.\"]\ntheorem lift_left_inverse {k : LocalizationMap S P} (z : N) : k.lift f.map_units (f.lift k.map_units z) = z :=\n  by\n  rw [lift_spec]\n  cases' f.surj z with x hx\n  conv_rhs =>\n    congr\n    skip\n    rw [f.eq_mk'_iff_mul_eq.2 hx]\n  rw [mk', ← mul_assoc, mul_inv_right f.map_units, ← f.to_map.map_mul, ← f.to_map.map_mul]\n  apply k.eq_of_eq f.map_units\n  rw [k.to_map.map_mul, k.to_map.map_mul, ← sec_spec, mul_assoc, lift_spec_mul]\n  repeat' rw [← k.to_map.map_mul]\n  apply f.eq_of_eq k.map_units\n  repeat' rw [f.to_map.map_mul]\n  rw [sec_spec', ← hx]\n  ac_rfl\n#align lift_left_inverse lift_left_inverse\n\n",
 "lift_injective_iff":
 "@[to_additive]\ntheorem lift_injective_iff : function.injective (f.lift hg) ↔ ∀ x y, f.to_map x = f.to_map y ↔ g x = g y :=\n  by\n  constructor\n  · intro H x y\n    constructor\n    · exact f.eq_of_eq hg\n    · intro h\n      rw [← f.lift_eq hg, ← f.lift_eq hg] at h\n      exact H h\n  · intro H z w h\n    obtain ⟨x, hx⟩ := f.surj z\n    obtain ⟨y, hy⟩ := f.surj w\n    rw [← f.mk'_sec z, ← f.mk'_sec w]\n    exact (mul_inv f.map_units).2 ((H _ _).2 <| (mul_inv hg).1 h)\n#align lift_injective_iff lift_injective_iff\n\n",
 "lift_id":
 "@[simp, to_additive]\ntheorem lift_id (x) : f.lift f.map_units x = x :=\n  MonoidHom.ext_iff.1 (f.lift_of_comp <| MonoidHom.id N) x\n#align lift_id lift_id\n\n",
 "lift_eq_iff":
 "@[to_additive]\ntheorem lift_eq_iff {x y : M × S} :\n    f.lift hg (f.mk' x.1 x.2) = f.lift hg (f.mk' y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) := by\n  rw [lift_mk', lift_mk', mul_inv hg]\n#align lift_eq_iff lift_eq_iff\n\n",
 "lift_eq":
 "@[simp]\ntheorem away_map.lift_eq (hg : IsAddUnit (g x)) (a : A) : F.lift x hg (F.to_map a) = g a :=\n  lift_eq _ _ _\n#align away_map.lift_eq away_map.lift_eq\n\n",
 "lift_comp":
 "@[simp]\ntheorem away_map.lift_comp (hg : IsAddUnit (g x)) : (F.lift x hg).comp F.to_map = g :=\n  lift_comp _ _\n#align away_map.lift_comp away_map.lift_comp\n\n",
 "is_unit_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem is_unit_comp (j : «expr →* » N P) (y : S) : IsUnit (j.comp f.to_map y) :=\n  ⟨Units.map j <| IsUnit.liftRight (f.to_map.restrict S) f.map_units y,\n    show j _ = j _ from congr_arg j <| IsUnit.coe_liftRight (f.to_map.restrict S) f.map_units _⟩\n#align is_unit_comp is_unit_comp\n\n",
 "inv_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print inv_unique /-\n/-- Given a monoid hom `f : M →* N` and submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y ∈ S`, `(f y)⁻¹` is unique. -/\n@[to_additive\n      \"Given an add_monoid hom `f : M →+ N` and submonoid `S ⊆ M` such that\\n`f(S) ⊆ add_units N`, for all `y ∈ S`, `- (f y)` is unique.\"]\ntheorem inv_unique {f : «expr →* » M N} (h : ∀ y : S, IsUnit (f y)) {y : S} {z} (H : f y * z = 1) :\n    ↑(IsUnit.liftRight (f.restrict S) h y)⁻¹ = z := by rw [← one_mul ↑_⁻¹, mul_inv_left, ← H]\n#align inv_unique inv_unique\n#align neg_unique neg_unique\n-/\n\n",
 "inv_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print inv_inj /-\n/-- Given a monoid hom `f : M →* N` and submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y, z ∈ S`, we have `(f y)⁻¹ = (f z)⁻¹ → f y = f z`. -/\n@[to_additive\n      \"Given an add_monoid hom `f : M →+ N` and submonoid `S ⊆ M` such that\\n`f(S) ⊆ add_units N`, for all `y, z ∈ S`, we have `- (f y) = - (f z) → f y = f z`.\"]\ntheorem inv_inj {f : «expr →* » M N} (hf : ∀ y : S, IsUnit (f y)) {y z}\n    (h : (IsUnit.liftRight (f.restrict S) hf y)⁻¹ = (IsUnit.liftRight (f.restrict S) hf z)⁻¹) : f y = f z := by\n  rw [← mul_one (f y), eq_comm, ← mul_inv_left hf y (f z) 1, h] <;> convert Units.inv_mul _ <;>\n    exact (IsUnit.coe_liftRight (f.restrict S) hf _).symm\n#align inv_inj inv_inj\n#align neg_inj neg_inj\n-/\n\n",
 "induction_on₃":
 "@[elab_as_elim, to_additive]\ntheorem induction_on₃ {p : Localization S → Localization S → Localization S → Prop} (x y z)\n    (H : ∀ x y z : M × S, p (mk x.1 x.2) (mk y.1 y.2) (mk z.1 z.2)) : p x y z :=\n  induction_on₂ x y fun x y => induction_on z <| H x y\n#align induction_on₃ induction_on₃\n\n",
 "induction_on₂":
 "@[elab_as_elim, to_additive]\ntheorem induction_on₂ {p : Localization S → Localization S → Prop} (x y)\n    (H : ∀ x y : M × S, p (mk x.1 x.2) (mk y.1 y.2)) : p x y :=\n  induction_on x fun x => induction_on y <| H x\n#align induction_on₂ induction_on₂\n\n",
 "induction_on":
 "@[elab_as_elim, to_additive]\ntheorem induction_on {p : Localization S → Prop} (x) (H : ∀ y : M × S, p (mk y.1 y.2)) : p x :=\n  ind H x\n#align induction_on induction_on\n\n",
 "ind":
 "@[elab_as_elim, to_additive]\ntheorem ind {p : Localization S → Prop} (H : ∀ y : M × S, p (mk y.1 y.2)) (x) : p x :=\n  rec (fun a b => H (a, b)) (fun _ _ _ _ _ => rfl) x\n#align ind ind\n\n",
 "ext_iff":
 "@[to_additive]\ntheorem ext_iff {f g : LocalizationMap S N} : f = g ↔ ∀ x, f.to_map x = g.to_map x :=\n  ⟨fun h x => h ▸ rfl, ext⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext, to_additive]\ntheorem ext {f g : LocalizationMap S N} (h : ∀ x, f.to_map x = g.to_map x) : f = g :=\n  by\n  rcases f with ⟨⟨⟩⟩\n  rcases g with ⟨⟨⟩⟩\n  simp only\n  exact funext h\n#align ext ext\n\n",
 "exists_of_sec_mk'":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, for all `x₁ : M` and `y₁ ∈ S`,\nif `x₂ : M, y₂ ∈ S` are such that `f x₁ * (f y₁)⁻¹ * f y₂ = f x₂`, then there exists `c ∈ S`\nsuch that `x₁ * y₂ * c = x₂ * y₁ * c`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, for all `x₁ : M`\\nand `y₁ ∈ S`, if `x₂ : M, y₂ ∈ S` are such that `(f x₁ - f y₁) + f y₂ = f x₂`, then there exists\\n`c ∈ S` such that `x₁ + y₂ + c = x₂ + y₁ + c`.\"]\ntheorem exists_of_sec_mk' (x) (y : S) :\n    ∃ c : S, ↑c * (↑(f.sec <| f.mk' x y).2 * x) = c * (y * (f.sec <| f.mk' x y).1) :=\n  f.eq_iff_exists.1 <| f.mk'_eq_iff_eq.1 <| (mk'_sec _ _).symm\n#align exists_of_sec_mk' exists_of_sec_mk'\n\n",
 "eq_of_eq":
 "/-- Given a localization map `f : M →* N` for a submonoid `S ⊆ M` and a map of `comm_monoid`s\n`g : M →* P` such that `g(S) ⊆ units P`, `f x = f y → g x = g y` for all `x y : M`. -/\n@[to_additive\n      \"Given a localization map `f : M →+ N` for a submonoid `S ⊆ M` and a map\\nof `add_comm_monoid`s `g : M →+ P` such that `g(S) ⊆ add_units P`, `f x = f y → g x = g y`\\nfor all `x y : M`.\"]\ntheorem eq_of_eq (hg : ∀ y : S, IsUnit (g y)) {x y} (h : f.to_map x = f.to_map y) : g x = g y :=\n  by\n  obtain ⟨c, hc⟩ := f.eq_iff_exists.1 h\n  rw [← one_mul (g x), ← IsUnit.liftRight_inv_mul (g.restrict S) hg c]\n  show _ * g c * _ = _\n  rw [mul_assoc, ← g.map_mul, hc, mul_comm, mul_inv_left hg, g.map_mul]\n#align eq_of_eq eq_of_eq\n\n",
 "eq_mk'_iff_mul_eq":
 "@[to_additive]\ntheorem eq_mk'_iff_mul_eq {x} {y : S} {z} : z = f.mk' x y ↔ z * f.to_map y = f.to_map x :=\n  ⟨fun H => by rw [H, mk'_spec], fun H => by erw [mul_inv_right, H] <;> rfl⟩\n#align eq_mk'_iff_mul_eq eq_mk'_iff_mul_eq\n\n",
 "eq_iff_exists":
 "@[to_additive]\ntheorem eq_iff_exists (f : LocalizationMap S N) {x y} : f.to_map x = f.to_map y ↔ ∃ c : S, ↑c * x = c * y :=\n  f.4 x y\n#align eq_iff_exists eq_iff_exists\n\n",
 "eq_iff_eq":
 "@[to_additive]\ntheorem eq_iff_eq (g : LocalizationMap S P) {x y} : f.to_map x = f.to_map y ↔ g.to_map x = g.to_map y :=\n  f.eq_iff_exists.trans g.eq_iff_exists.symm\n#align eq_iff_eq eq_iff_eq\n\n",
 "eq'":
 "@[to_additive]\nprotected theorem eq' {a₁ b₁} {a₂ b₂ : S} : f.mk' a₁ a₂ = f.mk' b₁ b₂ ↔ Localization.r S (a₁, a₂) (b₁, b₂) := by\n  rw [f.eq, Localization.r_iff_exists]\n#align eq' eq'\n\n",
 "epic_of_localization_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem epic_of_localization_map {j k : «expr →* » N P} (h : ∀ a, j.comp f.to_map a = k.comp f.to_map a) : j = k :=\n  by\n  rw [← f.lift_of_comp j, ← f.lift_of_comp k]\n  congr 1 with x; exact h x\n#align epic_of_localization_map epic_of_localization_map\n\n",
 "comp_eq_of_eq":
 "/-- Given `comm_monoid`s `M, P`, localization maps `f : M →* N, k : P →* Q` for submonoids\n`S, T` respectively, and `g : M →* P` such that `g(S) ⊆ T`, `f x = f y` implies\n`k (g x) = k (g y)`. -/\n@[to_additive\n      \"Given `add_comm_monoid`s `M, P`, localization maps `f : M →+ N, k : P →+ Q` for\\nsubmonoids `S, T` respectively, and `g : M →+ P` such that `g(S) ⊆ T`, `f x = f y`\\nimplies `k (g x) = k (g y)`.\"]\ntheorem comp_eq_of_eq {T : Submonoid P} {Q : Type _} [CommMonoid Q] (hg : ∀ y : S, g y ∈ T) (k : LocalizationMap T Q)\n    {x y} (h : f.to_map x = f.to_map y) : k.to_map (g x) = k.to_map (g y) :=\n  f.eq_of_eq (fun y : S => show IsUnit (k.to_map.comp g y) from k.map_units ⟨g y, hg y⟩) h\n#align comp_eq_of_eq comp_eq_of_eq\n\n",
 "Eq":
 "#print Eq /-\n@[to_additive]\nprotected theorem Eq {a₁ b₁} {a₂ b₂ : S} : f.mk' a₁ a₂ = f.mk' b₁ b₂ ↔ ∃ c : S, ↑c * (↑b₂ * a₁) = c * (a₂ * b₁) :=\n  f.mk'_eq_iff_eq.trans <| f.eq_iff_exists\n#align eq Eq\n-/\n\n"}