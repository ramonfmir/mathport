{"to_subgroup_eq_coe":
 "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Thomas Browning\n-/\n@[simp]\ntheorem to_subgroup_eq_coe {P : sylow p G} : P.to_subgroup = ↑P :=\n  rfl\n#align to_subgroup_eq_coe to_subgroup_eq_coe\n\n",
 "sylow_mem_fixed_points_iff":
 "theorem is_p_group.sylow_mem_fixed_points_iff {P : subgroup G} (hP : is_p_group p P) {Q : sylow p G} :\n    Q ∈ fixed_points P (sylow p G) ↔ P ≤ Q := by\n  rw [P.sylow_mem_fixed_points_iff, ← inf_eq_left, hP.inf_normalizer_sylow, inf_eq_left]\n#align is_p_group.sylow_mem_fixed_points_iff is_p_group.sylow_mem_fixed_points_iff\n\n",
 "subtype_injective":
 "theorem subtype_injective {P Q : sylow p G} {hP : ↑P ≤ N} {hQ : ↑Q ≤ N} (h : P.subtype hP = Q.subtype hQ) : P = Q :=\n  by\n  rw [SetLike.ext_iff] at h⊢\n  exact fun g => ⟨fun hg => (h ⟨g, hP hg⟩).mp hg, fun hg => (h ⟨g, hQ hg⟩).mpr hg⟩\n#align subtype_injective subtype_injective\n\n",
 "subsingleton_of_normal":
 "theorem subsingleton_of_normal {p : ℕ} [fact p.prime] [Finite (sylow p G)] (P : sylow p G)\n    (h : (P : subgroup G).normal) : subsingleton (sylow p G) :=\n  by\n  apply subsingleton.intro\n  intro Q R\n  obtain ⟨x, h1⟩ := exists_smul_eq G P Q\n  obtain ⟨x, h2⟩ := exists_smul_eq G P R\n  rw [sylow.smul_eq_of_normal] at h1 h2\n  rw [← h1, ← h2]\n#align subsingleton_of_normal subsingleton_of_normal\n\n",
 "stabilizer_eq_normalizer":
 "theorem sylow.stabilizer_eq_normalizer (P : sylow p G) : stabilizer G P = (P : subgroup G).normalizer :=\n  ext fun g => sylow.smul_eq_iff_mem_normalizer\n#align sylow.stabilizer_eq_normalizer sylow.stabilizer_eq_normalizer\n\n",
 "smul_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.smul_subtype {P : sylow p G} {H : subgroup G} (hP : ↑P ≤ H) (h : H) :\n    «expr • » h (P.subtype hP) = («expr • » h P).subtype (sylow.smul_le hP h) :=\n  sylow.ext (subgroup.conj_smul_subgroup_of hP h)\n#align sylow.smul_subtype sylow.smul_subtype\n\n",
 "smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.smul_le {P : sylow p G} {H : subgroup G} (hP : ↑P ≤ H) (h : H) : ↑(«expr • » h P) ≤ H :=\n  subgroup.conj_smul_le_of_le hP h\n#align sylow.smul_le sylow.smul_le\n\n",
 "smul_eq_of_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.smul_eq_of_normal {g : G} {P : sylow p G} [h : (P : subgroup G).normal] : «expr • » g P = P := by\n  simp only [sylow.smul_eq_iff_mem_normalizer, normalizer_eq_top.mpr h, mem_top]\n#align sylow.smul_eq_of_normal sylow.smul_eq_of_normal\n\n",
 "smul_eq_iff_mem_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.smul_eq_iff_mem_normalizer {g : G} {P : sylow p G} :\n    «expr • » g P = P ↔ g ∈ (P : subgroup G).normalizer :=\n  by\n  rw [eq_comm, SetLike.ext_iff, ← inv_mem_iff, mem_normalizer_iff, inv_inv]\n  exact\n    forall_congr' fun h =>\n      iff_congr iff.rfl\n        ⟨fun ⟨a, b, c⟩ => (congr_arg _ c).mp ((congr_arg (· ∈ P.1) (MulAut.inv_apply_self G (MulAut.conj g) a)).mpr b),\n          fun hh => ⟨(MulAut.conj g)⁻¹ h, hh, MulAut.apply_inv_self G (MulAut.conj g) h⟩⟩\n#align sylow.smul_eq_iff_mem_normalizer sylow.smul_eq_iff_mem_normalizer\n\n",
 "smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.smul_def {g : G} {P : sylow p G} : «expr • » g P = «expr • » (MulAut.conj g) P :=\n  rfl\n#align sylow.smul_def sylow.smul_def\n\n",
 "prime_pow_dvd_card_normalizer":
 "/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\n  then `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem prime_pow_dvd_card_normalizer [fintype G] {p : ℕ} {n : ℕ} [hp : fact p.prime] (hdvd : p ^ (n + 1) ∣ card G)\n    {H : subgroup G} (hH : fintype.card H = p ^ n) : p ^ (n + 1) ∣ card (normalizer H) :=\n  Nat.modEq_zero_iff_dvd.1 ((card_normalizer_modeq_card hH).trans hdvd.modeq_zero_nat)\n#align prime_pow_dvd_card_normalizer prime_pow_dvd_card_normalizer\n\n",
 "prime_dvd_card_quotient_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\n  index of `H` inside its normalizer. -/\ntheorem prime_dvd_card_quotient_normalizer [fintype G] {p : ℕ} {n : ℕ} [hp : fact p.prime] (hdvd : p ^ (n + 1) ∣ card G)\n    {H : subgroup G} (hH : fintype.card H = p ^ n) :\n    p ∣ card («expr ⧸ » (normalizer H) (subgroup.comap ((normalizer H).subtype : «expr →* » (normalizer H) G) H)) :=\n  let ⟨s, hs⟩ := exists_eq_mul_left_of_dvd hdvd\n  have hcard : card («expr ⧸ » G H) = s * p :=\n    (mul_left_inj' (show card H ≠ 0 from fintype.card_ne_zero)).1\n      (by rwa [← card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])\n  have hm :\n    s * p % p =\n      card («expr ⧸ » (normalizer H) (subgroup.comap ((normalizer H).subtype : «expr →* » (normalizer H) G) H)) % p :=\n    hcard ▸ (card_quotient_normalizer_modeq_card_quotient hH).symm\n  nat.dvd_of_mod_eq_zero (by rwa [nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)\n#align prime_dvd_card_quotient_normalizer prime_dvd_card_quotient_normalizer\n\n",
 "pow_dvd_card_of_pow_dvd_card":
 "theorem pow_dvd_card_of_pow_dvd_card [fintype G] {p n : ℕ} [hp : fact p.prime] (P : sylow p G) (hdvd : p ^ n ∣ card G) :\n    p ^ n ∣ card P :=\n  (hp.1.coprime_pow_of_not_dvd (not_dvd_index_sylow P index_ne_zero_of_finite)).symm.dvd_of_dvd_mul_left\n    ((index_mul_card P.1).symm ▸ hdvd)\n#align pow_dvd_card_of_pow_dvd_card pow_dvd_card_of_pow_dvd_card\n\n",
 "pointwise_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.pointwise_smul_def {α : Type _} [group α] [MulDistribMulAction α G] {g : α} {P : sylow p G} :\n    ↑(«expr • » g P) = «expr • » g (P : subgroup G) :=\n  rfl\n#align sylow.pointwise_smul_def sylow.pointwise_smul_def\n\n",
 "orbit_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem sylow.orbit_eq_top [fact p.prime] [Finite (sylow p G)] (P : sylow p G) : orbit G P = «expr⊤» :=\n  top_le_iff.mp fun Q hQ => exists_smul_eq G P Q\n#align sylow.orbit_eq_top sylow.orbit_eq_top\n\n",
 "not_dvd_index_sylow'":
 "theorem not_dvd_index_sylow' [hp : fact p.prime] (P : sylow p G) [(P : subgroup G).normal]\n    [finite_index (P : subgroup G)] : ¬p ∣ (P : subgroup G).index :=\n  by\n  intro h\n  haveI := (P : subgroup G).fintype_quotient_of_finite_index\n  rw [index_eq_card] at h\n  obtain ⟨x, hx⟩ := exists_prime_order_of_dvd_card p h\n  have h := is_p_group.of_card ((order_eq_card_zpowers.symm.trans hx).trans (pow_one p).symm)\n  let Q := (zpowers x).comap (quotient_group.mk' (P : subgroup G))\n  have hQ : is_p_group p Q := by\n    apply h.comap_of_ker_is_p_group\n    rw [quotient_group.ker_mk]\n    exact P.2\n  replace hp := mt order_of_eq_one_iff.mpr (ne_of_eq_of_ne hx hp.1.ne_one)\n  rw [← zpowers_eq_bot, ← ne, ← bot_lt_iff_ne_bot, ← comap_lt_comap_of_surjective (quotient_group.mk'_surjective _),\n    monoid_hom.comap_bot, quotient_group.ker_mk] at hp\n  exact hp.ne' (P.3 hQ hp.le)\n#align not_dvd_index_sylow' not_dvd_index_sylow'\n\n",
 "not_dvd_index_sylow":
 "theorem not_dvd_index_sylow [hp : fact p.prime] [Finite (sylow p G)] (P : sylow p G)\n    (hP : relindex ↑P (P : subgroup G).normalizer ≠ 0) : ¬p ∣ (P : subgroup G).index :=\n  by\n  cases nonempty_fintype (sylow p G)\n  rw [← relindex_mul_index le_normalizer, ← card_sylow_eq_index_normalizer]\n  haveI : (P.subtype le_normalizer : subgroup (P : subgroup G).normalizer).normal := subgroup.normal_in_normalizer\n  haveI : finite_index ↑(P.subtype le_normalizer) := ⟨hP⟩\n  replace hP := not_dvd_index_sylow' (P.subtype le_normalizer)\n  exact hp.1.not_dvd_mul hP (not_dvd_card_sylow p G)\n#align not_dvd_index_sylow not_dvd_index_sylow\n\n",
 "not_dvd_card_sylow":
 "theorem not_dvd_card_sylow [hp : fact p.prime] [fintype (sylow p G)] : ¬p ∣ card (sylow p G) := fun h =>\n  hp.1.ne_one\n    (Nat.dvd_one.mp\n      ((Nat.modEq_iff_dvd' zero_le_one).mp ((Nat.modEq_zero_iff_dvd.mpr h).symm.trans (card_sylow_modeq_one p G))))\n#align not_dvd_card_sylow not_dvd_card_sylow\n\n",
 "normalizer_sup_eq_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\n  of `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem sylow.normalizer_sup_eq_top' {p : ℕ} [fact p.prime] {N : subgroup G} [N.normal] [Finite (sylow p N)]\n    (P : sylow p G) (hP : ↑P ≤ N) : «expr ⊔ » (P : subgroup G).normalizer N = «expr⊤» := by\n  rw [← sylow.normalizer_sup_eq_top (P.subtype hP), P.coe_subtype, subgroup_of_map_subtype, inf_of_le_left hP]\n#align sylow.normalizer_sup_eq_top' sylow.normalizer_sup_eq_top'\n\n",
 "normalizer_sup_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\n  of `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem sylow.normalizer_sup_eq_top {p : ℕ} [fact p.prime] {N : subgroup G} [N.normal] [Finite (sylow p N)]\n    (P : sylow p N) : «expr ⊔ » ((↑P : subgroup N).map N.subtype).normalizer N = «expr⊤» :=\n  by\n  refine' top_le_iff.mp fun g hg => _\n  obtain ⟨n, hn⟩ := exists_smul_eq N («expr • » (mul_aut.conj_normal g : MulAut N) P) P\n  rw [← inv_mul_cancel_left (↑n) g, sup_comm]\n  apply mul_mem_sup (N.inv_mem n.2)\n  rw [sylow.smul_def, ← mul_smul, ← mul_aut.conj_normal_coe, ← mul_aut.conj_normal.map_mul, sylow.ext_iff,\n    sylow.pointwise_smul_def, pointwise_smul_def] at hn\n  refine' fun x =>\n    (mem_map_iff_mem\n            (show function.injective (MulAut.conj (↑n * g)).to_monoid_hom from\n              (MulAut.conj (↑n * g)).injective)).symm.trans\n      _\n  rw [map_map, ← congr_arg (map N.subtype) hn, map_map]\n  rfl\n#align sylow.normalizer_sup_eq_top sylow.normalizer_sup_eq_top\n\n",
 "normalizer_normalizer":
 "@[simp]\ntheorem normalizer_normalizer {p : ℕ} [fact p.prime] [Finite (sylow p G)] (P : sylow p G) :\n    (↑P : subgroup G).normalizer.normalizer = (↑P : subgroup G).normalizer :=\n  by\n  have := normal_of_normalizer_normal (P.subtype (le_normalizer.trans le_normalizer))\n  simp_rw [← normalizer_eq_top, coe_subtype, ← subgroup_of_normalizer_eq le_normalizer, ←\n    subgroup_of_normalizer_eq le_rfl, subgroup_of_self] at this\n  rw [← subtype_range (P : subgroup G).normalizer.normalizer, monoid_hom.range_eq_map, ← this rfl]\n  exact map_comap_eq_self (le_normalizer.trans (ge_of_eq (subtype_range _)))\n#align normalizer_normalizer normalizer_normalizer\n\n",
 "normal_of_normalizer_normal":
 "theorem normal_of_normalizer_normal {p : ℕ} [fact p.prime] [Finite (sylow p G)] (P : sylow p G)\n    (hn : (↑P : subgroup G).normalizer.normal) : (↑P : subgroup G).normal := by\n  rw [← normalizer_eq_top, ← normalizer_sup_eq_top' P le_normalizer, sup_idem]\n#align normal_of_normalizer_normal normal_of_normalizer_normal\n\n",
 "normal_of_normalizer_condition":
 "theorem normal_of_normalizer_condition (hnc : normalizer_condition G) {p : ℕ} [fact p.prime] [Finite (sylow p G)]\n    (P : sylow p G) : (↑P : subgroup G).normal :=\n  normalizer_eq_top.mp <| normalizer_condition_iff_only_full_group_self_normalizing.mp hnc _ <| normalizer_normalizer _\n#align normal_of_normalizer_condition normal_of_normalizer_condition\n\n",
 "normal_of_all_max_subgroups_normal":
 "theorem normal_of_all_max_subgroups_normal [Finite G] (hnc : ∀ H : subgroup G, IsCoatom H → H.normal) {p : ℕ}\n    [fact p.prime] [Finite (sylow p G)] (P : sylow p G) : (↑P : subgroup G).normal :=\n  normalizer_eq_top.mp\n    (by\n      rcases eq_top_or_exists_le_coatom (↑P : subgroup G).normalizer with (heq | ⟨K, hK, hNK⟩)\n      · exact HEq\n      · haveI := hnc _ hK\n        have hPK : ↑P ≤ K := le_trans le_normalizer hNK\n        refine' (hK.1 _).elim\n        rw [← sup_of_le_right hNK, P.normalizer_sup_eq_top' hPK])\n#align normal_of_all_max_subgroups_normal normal_of_all_max_subgroups_normal\n\n",
 "ne_bot_of_dvd_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ne_bot_of_dvd_card [fintype G] {p : ℕ} [hp : fact p.prime] (P : sylow p G) (hdvd : p ∣ card G) :\n    (P : subgroup G) ≠ «expr⊥» := by\n  refine' fun h => hp.out.not_dvd_one _\n  have key : p ∣ card (P : subgroup G) := P.dvd_card_of_dvd_card hdvd\n  rwa [h, card_bot] at key\n#align ne_bot_of_dvd_card ne_bot_of_dvd_card\n\n",
 "mem_fixed_points_mul_left_cosets_iff_mem_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem mem_fixed_points_mul_left_cosets_iff_mem_normalizer {H : subgroup G} [Finite («expr↥ » (H : set G))] {x : G} :\n    (x : «expr ⧸ » G H) ∈ fixedPoints H («expr ⧸ » G H) ↔ x ∈ normalizer H :=\n  ⟨fun hx =>\n    have ha : ∀ {y : «expr ⧸ » G H}, y ∈ orbit H (x : «expr ⧸ » G H) → y = x := fun _ => (mem_fixed_points' _).1 hx _\n    inv_mem_iff.1\n      (mem_normalizer_fintype fun n (hn : n ∈ H) =>\n        have : (n⁻¹ * x)⁻¹ * x ∈ H := quotient_group.eq.1 (ha (mem_orbit _ ⟨n⁻¹, H.inv_mem hn⟩))\n        show _ ∈ H by\n          rw [mul_inv_rev, inv_inv] at this\n          convert this\n          rw [inv_inv]),\n    fun hx : ∀ n : G, n ∈ H ↔ x * n * x⁻¹ ∈ H =>\n    (mem_fixed_points' _).2 fun y =>\n      Quotient.inductionOn' y fun y hy =>\n        quotient_group.eq.2\n          (let ⟨⟨b, hb₁⟩, hb₂⟩ := hy\n          have hb₂ : (b * x)⁻¹ * y ∈ H := quotient_group.eq.1 hb₂\n          inv_mem_iff.1 <|\n            (hx _).2 <|\n              (mul_mem_cancel_left (inv_mem hb₁)).1 <| by rw [hx] at hb₂ <;> simpa [mul_inv_rev, mul_assoc] using hb₂)⟩\n#align mem_fixed_points_mul_left_cosets_iff_mem_normalizer mem_fixed_points_mul_left_cosets_iff_mem_normalizer\n\n",
 "inf_normalizer_sylow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_p_group.inf_normalizer_sylow {P : subgroup G} (hP : is_p_group p P) (Q : sylow p G) :\n    «expr ⊓ » P (Q : subgroup G).normalizer = «expr ⊓ » P Q :=\n  le_antisymm\n    (le_inf inf_le_left (sup_eq_right.mp (Q.3 (hP.to_inf_left.to_sup_of_normal_right' Q.2 inf_le_right) le_sup_right)))\n    (inf_le_inf_left P le_normalizer)\n#align is_p_group.inf_normalizer_sylow is_p_group.inf_normalizer_sylow\n\n",
 "ext_iff":
 "theorem ext_iff {P Q : sylow p G} : P = Q ↔ (P : subgroup G) = Q :=\n  ⟨congr_arg coe, ext⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext {P Q : sylow p G} (h : (P : subgroup G) = Q) : P = Q := by cases P <;> cases Q <;> congr\n#align ext ext\n\n",
 "exists_subgroup_card_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\n  then `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\n  if `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem exists_subgroup_card_pow_succ [fintype G] {p : ℕ} {n : ℕ} [hp : fact p.prime] (hdvd : p ^ (n + 1) ∣ card G)\n    {H : subgroup G} (hH : fintype.card H = p ^ n) : ∃ K : subgroup G, fintype.card K = p ^ (n + 1) ∧ H ≤ K :=\n  let ⟨s, hs⟩ := exists_eq_mul_left_of_dvd hdvd\n  have hcard : card («expr ⧸ » G H) = s * p :=\n    (mul_left_inj' (show card H ≠ 0 from fintype.card_ne_zero)).1\n      (by rwa [← card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])\n  have hm : s * p % p = card («expr ⧸ » (normalizer H) (H.subgroup_of H.normalizer)) % p :=\n    card_congr (fixed_points_mul_left_cosets_equiv_quotient H) ▸\n      hcard ▸ (is_p_group.of_card hH).card_modeq_card_fixed_points _\n  have hm' : p ∣ card («expr ⧸ » (normalizer H) (H.subgroup_of H.normalizer)) :=\n    nat.dvd_of_mod_eq_zero (by rwa [nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)\n  let ⟨x, hx⟩ := @exists_prime_order_of_dvd_card _ (quotient_group.quotient.group _) _ _ hp hm'\n  have hequiv : «expr ≃ » H (H.subgroup_of H.normalizer) := (subgroup_of_equiv_of_le le_normalizer).symm.to_equiv\n  ⟨subgroup.map (normalizer H).subtype (subgroup.comap (mk' (H.subgroup_of H.normalizer)) (zpowers x)),\n    by\n    show\n      card («expr↥ » (map H.normalizer.subtype (comap (mk' (H.subgroup_of H.normalizer)) (subgroup.zpowers x)))) =\n        p ^ (n + 1)\n    suffices\n      card\n          («expr↥ »\n            («expr '' » subtype.val\n              (subgroup.comap (mk' (H.subgroup_of H.normalizer)) (zpowers x) : set («expr↥ » H.normalizer)))) =\n        p ^ (n + 1)\n      by convert this using 2\n    rw [set.card_image_of_injective (subgroup.comap (mk' (H.subgroup_of H.normalizer)) (zpowers x) : set H.normalizer)\n        subtype.val_injective,\n      pow_succ', ← hH, fintype.card_congr hequiv, ← hx, order_eq_card_zpowers, ← fintype.card_prod]\n    exact @fintype.card_congr _ _ (id _) (id _) (preimage_mk_equiv_subgroup_times_set _ _),\n    by\n    intro y hy\n    simp only [exists_prop, subgroup.coe_subtype, mk'_apply, subgroup.mem_map, subgroup.mem_comap]\n    refine' ⟨⟨y, le_normalizer hy⟩, ⟨0, _⟩, rfl⟩\n    rw [zpow_zero, eq_comm, quotient_group.eq_one_iff]\n    simpa using hy⟩\n#align exists_subgroup_card_pow_succ exists_subgroup_card_pow_succ\n\n",
 "exists_subgroup_card_pow_prime_le":
 "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\n  then `H` is contained in a subgroup of cardinality `p ^ m`\n  if `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem exists_subgroup_card_pow_prime_le [fintype G] (p : ℕ) :\n    ∀ {n m : ℕ} [hp : fact p.prime] (hdvd : p ^ m ∣ card G) (H : subgroup G) (hH : card H = p ^ n) (hnm : n ≤ m),\n      ∃ K : subgroup G, card K = p ^ m ∧ H ≤ K\n  | n, m => fun hp hdvd H hH hnm =>\n    (lt_or_eq_of_le hnm).elim\n      (fun hnm : n < m =>\n        have h0m : 0 < m := lt_of_le_of_lt n.zero_le hnm\n        have wf : m - 1 < m := nat.sub_lt h0m zero_lt_one\n        have hnm1 : n ≤ m - 1 := le_tsub_of_add_le_right hnm\n        let ⟨K, hK⟩ :=\n          @exists_subgroup_card_pow_prime_le n (m - 1) hp (Nat.pow_dvd_of_le_of_pow_dvd tsub_le_self hdvd) H hH hnm1\n        have hdvd' : p ^ (m - 1 + 1) ∣ card G := by rwa [tsub_add_cancel_of_le h0m.nat_succ_le]\n        let ⟨K', hK'⟩ := @exists_subgroup_card_pow_succ _ _ _ _ _ hp hdvd' K hK.1\n        ⟨K', by rw [hK'.1, tsub_add_cancel_of_le h0m.nat_succ_le], le_trans hK.2 hK'.2⟩)\n      fun hnm : n = m => ⟨H, by simp [hH, hnm]⟩\n#align exists_subgroup_card_pow_prime_le exists_subgroup_card_pow_prime_le\n\n",
 "exists_subgroup_card_pow_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\n  the cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem exists_subgroup_card_pow_prime [fintype G] (p : ℕ) {n : ℕ} [fact p.prime] (hdvd : p ^ n ∣ card G) :\n    ∃ K : subgroup G, fintype.card K = p ^ n :=\n  let ⟨K, hK⟩ := exists_subgroup_card_pow_prime_le p hdvd («expr⊥») (by simp) n.zero_le\n  ⟨K, hK.1⟩\n#align exists_subgroup_card_pow_prime exists_subgroup_card_pow_prime\n\n",
 "exists_le_sylow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A generalization of **Sylow's first theorem**.\n  Every `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem is_p_group.exists_le_sylow {P : subgroup G} (hP : is_p_group p P) : ∃ Q : sylow p G, P ≤ Q :=\n  exists.elim\n    (zorn_nonempty_partialOrder₀ { Q : subgroup G | is_p_group p Q }\n      (fun c hc1 hc2 Q hQ =>\n        ⟨{  carrier := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" R\n            one_mem' := ⟨Q, ⟨⟨Q, hQ⟩, rfl⟩, Q.one_mem⟩\n            inv_mem' := fun g ⟨_, ⟨R, rfl⟩, hg⟩ => ⟨R, ⟨R, rfl⟩, R.1.inv_mem hg⟩\n            mul_mem' := fun g h ⟨_, ⟨R, rfl⟩, hg⟩ ⟨_, ⟨S, rfl⟩, hh⟩ =>\n              (hc2.total R.2 S.2).elim (fun T => ⟨S, ⟨S, rfl⟩, S.1.mul_mem (T hg) hh⟩) fun T =>\n                ⟨R, ⟨R, rfl⟩, R.1.mul_mem hg (T hh)⟩ },\n          fun ⟨g, _, ⟨S, rfl⟩, hg⟩ =>\n          by\n          refine' Exists.imp (fun k hk => _) (hc1 S.2 ⟨g, hg⟩)\n          rwa [subtype.ext_iff, coe_pow] at hk⊢, fun M hM g hg => ⟨M, ⟨⟨M, hM⟩, rfl⟩, hg⟩⟩)\n      P hP)\n    fun Q ⟨hQ1, hQ2, hQ3⟩ => ⟨⟨Q, hQ1, hQ3⟩, hQ2⟩\n#align is_p_group.exists_le_sylow is_p_group.exists_le_sylow\n\n",
 "exists_comap_subtype_eq":
 "theorem sylow.exists_comap_subtype_eq {H : subgroup G} (P : sylow p H) :\n    ∃ Q : sylow p G, (Q : subgroup G).comap H.subtype = P :=\n  P.exists_comap_eq_of_injective subtype.coe_injective\n#align sylow.exists_comap_subtype_eq sylow.exists_comap_subtype_eq\n\n",
 "exists_comap_eq_of_ker_is_p_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {H : Type _} [group H] (P : sylow p H) {f : «expr →* » H G}\n    (hf : is_p_group p f.ker) : ∃ Q : sylow p G, (Q : subgroup G).comap f = P :=\n  Exists.imp (fun Q hQ => P.3 (Q.2.comap_of_ker_is_p_group f hf) (map_le_iff_le_comap.mp hQ))\n    (P.2.map f).exists_le_sylow\n#align sylow.exists_comap_eq_of_ker_is_p_group sylow.exists_comap_eq_of_ker_is_p_group\n\n",
 "exists_comap_eq_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem sylow.exists_comap_eq_of_injective {H : Type _} [group H] (P : sylow p H) {f : «expr →* » H G}\n    (hf : function.injective f) : ∃ Q : sylow p G, (Q : subgroup G).comap f = P :=\n  P.exists_comap_eq_of_ker_is_p_group (is_p_group.ker_is_p_group_of_injective hf)\n#align sylow.exists_comap_eq_of_injective sylow.exists_comap_eq_of_injective\n\n",
 "dvd_card_of_dvd_card":
 "theorem dvd_card_of_dvd_card [fintype G] {p : ℕ} [fact p.prime] (P : sylow p G) (hdvd : p ∣ card G) : p ∣ card P :=\n  by\n  rw [← pow_one p] at hdvd\n  have key := P.pow_dvd_card_of_pow_dvd_card hdvd\n  rwa [pow_one] at key\n#align dvd_card_of_dvd_card dvd_card_of_dvd_card\n\n",
 "conj_eq_normalizer_conj_of_mem_centralizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.conj_eq_normalizer_conj_of_mem_centralizer [fact p.prime] [Finite (sylow p G)] (P : sylow p G) (x g : G)\n    (hx : x ∈ (P : subgroup G).centralizer) (hy : g⁻¹ * x * g ∈ (P : subgroup G).centralizer) :\n    ∃ n ∈ (P : subgroup G).normalizer, g⁻¹ * x * g = n⁻¹ * x * n :=\n  by\n  have h1 : ↑P ≤ (zpowers x).centralizer := by rwa [le_centralizer_iff, zpowers_le]\n  have h2 : ↑(«expr • » g P) ≤ (zpowers x).centralizer :=\n    by\n    rw [le_centralizer_iff, zpowers_le]\n    rintro - ⟨z, hz, rfl⟩\n    specialize hy z hz\n    rwa [← mul_assoc, ← eq_mul_inv_iff_mul_eq, mul_assoc, mul_assoc, mul_assoc, ← mul_assoc, eq_inv_mul_iff_mul_eq, ←\n      mul_assoc, ← mul_assoc] at hy\n  obtain ⟨h, hh⟩ := exists_smul_eq (zpowers x).centralizer ((«expr • » g P).subtype h2) (P.subtype h1)\n  simp_rw [sylow.smul_subtype, smul_def, smul_smul] at hh\n  refine' ⟨h * g, sylow.smul_eq_iff_mem_normalizer.mp (sylow.subtype_injective hh), _⟩\n  rw [← mul_assoc, Commute.right_comm (h.prop x (mem_zpowers x)), mul_inv_rev, inv_mul_cancel_right]\n#align sylow.conj_eq_normalizer_conj_of_mem_centralizer sylow.conj_eq_normalizer_conj_of_mem_centralizer\n\n",
 "conj_eq_normalizer_conj_of_mem":
 "theorem sylow.conj_eq_normalizer_conj_of_mem [fact p.prime] [Finite (sylow p G)] (P : sylow p G)\n    [hP : (P : subgroup G).is_commutative] (x g : G) (hx : x ∈ P) (hy : g⁻¹ * x * g ∈ P) :\n    ∃ n ∈ (P : subgroup G).normalizer, g⁻¹ * x * g = n⁻¹ * x * n :=\n  P.conj_eq_normalizer_conj_of_mem_centralizer x g (le_centralizer P hx) (le_centralizer P hy)\n#align sylow.conj_eq_normalizer_conj_of_mem sylow.conj_eq_normalizer_conj_of_mem\n\n",
 "coe_subtype":
 "@[simp]\ntheorem coe_subtype (h : ↑P ≤ N) : ↑(P.subtype h) = subgroup_of (↑P) N :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_subgroup_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.coe_subgroup_smul {g : G} {P : sylow p G} :\n    ↑(«expr • » g P) = «expr • » (MulAut.conj g) (P : subgroup G) :=\n  rfl\n#align sylow.coe_subgroup_smul sylow.coe_subgroup_smul\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sylow.coe_smul {g : G} {P : sylow p G} : ↑(«expr • » g P) = «expr • » (MulAut.conj g) (P : set G) :=\n  rfl\n#align sylow.coe_smul sylow.coe_smul\n\n",
 "coe_comap_of_ker_is_p_group":
 "@[simp]\ntheorem coe_comap_of_ker_is_p_group (hϕ : is_p_group p ϕ.ker) (h : ↑P ≤ ϕ.range) :\n    ↑(P.comap_of_ker_is_p_group ϕ hϕ h) = subgroup.comap ϕ ↑P :=\n  rfl\n#align coe_comap_of_ker_is_p_group coe_comap_of_ker_is_p_group\n\n",
 "coe_comap_of_injective":
 "@[simp]\ntheorem coe_comap_of_injective (hϕ : function.injective ϕ) (h : ↑P ≤ ϕ.range) :\n    ↑(P.comap_of_injective ϕ hϕ h) = subgroup.comap ϕ ↑P :=\n  rfl\n#align coe_comap_of_injective coe_comap_of_injective\n\n",
 "characteristic_of_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem characteristic_of_normal {p : ℕ} [fact p.prime] [Finite (sylow p G)] (P : sylow p G)\n    (h : (P : subgroup G).normal) : (P : subgroup G).characteristic :=\n  by\n  haveI := sylow.subsingleton_of_normal P h\n  rw [characteristic_iff_map_eq]\n  intro Φ\n  show («expr • » Φ P).to_subgroup = P.to_subgroup\n  congr\n#align characteristic_of_normal characteristic_of_normal\n\n",
 "card_sylow_modeq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- A generalization of **Sylow's third theorem**.\n  If the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem card_sylow_modeq_one [fact p.prime] [fintype (sylow p G)] : «expr ≡ [MOD ]» (card (sylow p G)) 1 p :=\n  by\n  refine' sylow.nonempty.elim fun P : sylow p G => _\n  have : fixed_points P.1 (sylow p G) = {P} :=\n    Set.ext fun Q : sylow p G =>\n      calc\n        Q ∈ fixed_points P (sylow p G) ↔ P.1 ≤ Q := P.2.sylow_mem_fixed_points_iff\n        _ ↔ Q.1 = P.1 := ⟨P.3 Q.2, ge_of_eq⟩\n        _ ↔ Q ∈ {P} := sylow.ext_iff.symm.trans set.mem_singleton_iff.symm\n        \n  have : fintype (fixed_points P.1 (sylow p G)) := by\n    rw [this]\n    infer_instance\n  have : card (fixed_points P.1 (sylow p G)) = 1 := by simp [this]\n  exact (P.2.card_modeq_card_fixed_points (sylow p G)).trans (by rw [this])\n#align card_sylow_modeq_one card_sylow_modeq_one\n\n",
 "card_sylow_eq_index_normalizer":
 "theorem card_sylow_eq_index_normalizer [fact p.prime] [fintype (sylow p G)] (P : sylow p G) :\n    card (sylow p G) = (P : subgroup G).normalizer.index :=\n  (card_sylow_eq_card_quotient_normalizer P).trans (P : subgroup G).normalizer.index_eq_card.symm\n#align card_sylow_eq_index_normalizer card_sylow_eq_index_normalizer\n\n",
 "card_sylow_eq_card_quotient_normalizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem card_sylow_eq_card_quotient_normalizer [fact p.prime] [fintype (sylow p G)] (P : sylow p G) :\n    card (sylow p G) = card («expr ⧸ » G (P : subgroup G).normalizer) :=\n  card_congr P.equiv_quotient_normalizer\n#align card_sylow_eq_card_quotient_normalizer card_sylow_eq_card_quotient_normalizer\n\n",
 "card_sylow_dvd_index":
 "theorem card_sylow_dvd_index [fact p.prime] [fintype (sylow p G)] (P : sylow p G) :\n    card (sylow p G) ∣ (P : subgroup G).index :=\n  ((congr_arg _ (card_sylow_eq_index_normalizer P)).mp dvd_rfl).trans (index_dvd_of_le le_normalizer)\n#align card_sylow_dvd_index card_sylow_dvd_index\n\n",
 "card_quotient_normalizer_modeq_card_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\n  mod `p` to the index of `H`.  -/\ntheorem card_quotient_normalizer_modeq_card_quotient [fintype G] {p : ℕ} {n : ℕ} [hp : fact p.prime] {H : subgroup G}\n    (hH : fintype.card H = p ^ n) :\n    «expr ≡ [MOD ]»\n      (card («expr ⧸ » (normalizer H) (subgroup.comap ((normalizer H).subtype : «expr →* » (normalizer H) G) H)))\n      (card («expr ⧸ » G H)) p :=\n  by\n  rw [← fintype.card_congr (fixed_points_mul_left_cosets_equiv_quotient H)]\n  exact ((is_p_group.of_card hH).card_modeq_card_fixed_points _).symm\n#align card_quotient_normalizer_modeq_card_quotient card_quotient_normalizer_modeq_card_quotient\n\n",
 "card_preimage_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem quotient_group.card_preimage_mk [fintype G] (s : subgroup G) (t : set («expr ⧸ » G s)) :\n    fintype.card («expr ⁻¹' » quotient_group.mk t) = fintype.card s * fintype.card t := by\n  rw [← fintype.card_prod, fintype.card_congr (preimage_mk_equiv_subgroup_times_set _ _)]\n#align quotient_group.card_preimage_mk quotient_group.card_preimage_mk\n\n",
 "card_normalizer_modeq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\n  normalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  -/\ntheorem card_normalizer_modeq_card [fintype G] {p : ℕ} {n : ℕ} [hp : fact p.prime] {H : subgroup G}\n    (hH : fintype.card H = p ^ n) : «expr ≡ [MOD ]» (card (normalizer H)) (card G) (p ^ (n + 1)) :=\n  by\n  have : «expr ≃ » (H.subgroup_of (normalizer H)) H := (subgroup_of_equiv_of_le le_normalizer).to_equiv\n  rw [card_eq_card_quotient_mul_card_subgroup H, card_eq_card_quotient_mul_card_subgroup (H.subgroup_of (normalizer H)),\n    fintype.card_congr this, hH, pow_succ]\n  exact (card_quotient_normalizer_modeq_card_quotient hH).mul_right' _\n#align card_normalizer_modeq_card card_normalizer_modeq_card\n\n",
 "card_eq_multiplicity":
 "/-- The cardinality of a Sylow group is `p ^ n`\n where `n` is the multiplicity of `p` in the group order. -/\ntheorem card_eq_multiplicity [fintype G] {p : ℕ} [hp : fact p.prime] (P : sylow p G) :\n    card P = p ^ nat.factorization (card G) p :=\n  by\n  obtain ⟨n, heq : card P = _⟩ := is_p_group.iff_card.mp P.is_p_group'\n  refine' nat.dvd_antisymm _ (P.pow_dvd_card_of_pow_dvd_card (nat.ord_proj_dvd _ p))\n  rw [HEq, ← hp.out.pow_dvd_iff_dvd_ord_proj (show card G ≠ 0 from card_ne_zero), ← HEq]\n  exact P.1.card_subgroup_dvd_card\n#align card_eq_multiplicity card_eq_multiplicity\n\n",
 "card_coprime_index":
 "/-- Sylow subgroups are Hall subgroups. -/\ntheorem card_coprime_index [fintype G] {p : ℕ} [hp : fact p.prime] (P : sylow p G) :\n    (card P).coprime (index (P : subgroup G)) :=\n  let ⟨n, hn⟩ := is_p_group.iff_card.mp P.2\n  hn.symm ▸ (hp.1.coprime_pow_of_not_dvd (not_dvd_index_sylow P index_ne_zero_of_finite)).symm\n#align card_coprime_index card_coprime_index\n\n"}