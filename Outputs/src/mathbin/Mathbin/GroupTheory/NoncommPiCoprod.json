{"noncomm_pi_coprod_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem noncomm_pi_coprod_range :\n    (noncommPiCoprod hcomm).range =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (H i) :=\n  by simp [noncomm_pi_coprod, MonoidHom.noncommPiCoprod_range]\n#align noncomm_pi_coprod_range noncomm_pi_coprod_range\n\n",
 "noncomm_pi_coprod_mul_single":
 "@[simp, to_additive]\ntheorem noncomm_pi_coprod_mul_single (i : ι) (y : H i) : noncommPiCoprod hcomm (Pi.mulSingle i y) = y := by\n  apply MonoidHom.noncommPiCoprod_mulSingle\n#align noncomm_pi_coprod_mul_single noncomm_pi_coprod_mul_single\n\n",
 "noncomm_pi_coprod_mrange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem noncomm_pi_coprod_mrange :\n    (noncommPiCoprod ϕ hcomm).mrange =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (ϕ i).mrange :=\n  by\n  classical\n    apply le_antisymm\n    · rintro x ⟨f, rfl⟩\n      refine' Submonoid.noncommProd_mem _ _ _ _ _\n      intro i hi\n      apply Submonoid.mem_supₛ_of_mem\n      · use i\n      simp\n    · refine' supᵢ_le _\n      rintro i x ⟨y, rfl⟩\n      refine' ⟨Pi.mulSingle i y, noncomm_pi_coprod_mul_single _ _ _⟩\n#align noncomm_pi_coprod_mrange noncomm_pi_coprod_mrange\n\n",
 "injective_noncomm_pi_coprod_of_independent":
 "@[to_additive]\ntheorem injective_noncomm_pi_coprod_of_independent (hind : CompleteLattice.Independent H) :\n    function.injective (noncommPiCoprod hcomm) :=\n  by\n  apply MonoidHom.injective_noncommPiCoprod_of_independent\n  · simpa using hind\n  · intro i\n    exact Subtype.coe_injective\n#align injective_noncomm_pi_coprod_of_independent injective_noncomm_pi_coprod_of_independent\n\n",
 "independent_range_of_coprime_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem independent_range_of_coprime_order [Finite ι] [∀ i, Fintype (H i)]\n    (hcoprime : ∀ i j, i ≠ j → Nat.coprime (Fintype.card (H i)) (Fintype.card (H j))) :\n    CompleteLattice.Independent fun i => (ϕ i).range :=\n  by\n  cases nonempty_fintype ι\n  classical\n    rintro i\n    rw [disjoint_iff_inf_le]\n    rintro f ⟨hxi, hxp⟩\n    dsimp at hxi hxp\n    rw [supᵢ_subtype', ← noncomm_pi_coprod_range] at hxp\n    rotate_left\n    · intro _ _ hj\n      apply hcomm\n      exact hj ∘ Subtype.ext\n    cases' hxp with g hgf\n    cases' hxi with g' hg'f\n    have hxi : orderOf f ∣ Fintype.card (H i) := by\n      rw [← hg'f]\n      exact (orderOf_map_dvd _ _).trans orderOf_dvd_card_univ\n    have hxp :\n      orderOf f ∣\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (Fintype.card (H j)) :=\n      by\n      rw [← hgf, ← Fintype.card_pi]\n      exact (orderOf_map_dvd _ _).trans orderOf_dvd_card_univ\n    change f = 1\n    rw [← pow_one f, ← orderOf_dvd_iff_pow_eq_one]\n    convert← Nat.dvd_gcd hxp hxi\n    rw [← Nat.coprime_iff_gcd_eq_one]\n    apply Nat.coprime_prod_left\n    intro j _\n    apply hcoprime\n    exact j.2\n#align independent_range_of_coprime_order independent_range_of_coprime_order\n\n",
 "independent_of_coprime_order":
 "@[to_additive]\ntheorem independent_of_coprime_order [Finite ι] [∀ i, Fintype (H i)]\n    (hcoprime : ∀ i j, i ≠ j → Nat.coprime (Fintype.card (H i)) (Fintype.card (H j))) : CompleteLattice.Independent H :=\n  by\n  simpa using\n    MonoidHom.independent_range_of_coprime_order (fun i => (H i).subtype) (commute_subtype_of_commute hcomm) hcoprime\n#align independent_of_coprime_order independent_of_coprime_order\n\n",
 "eq_one_of_noncomm_prod_eq_one_of_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-\nCopyright (c) 2022 Joachim Breitner. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joachim Breitner\n-/\n/-- `finset.noncomm_prod` is “injective” in `f` if `f` maps into independent subgroups.  This\ngeneralizes (one direction of) `subgroup.disjoint_iff_mul_eq_one`. -/\n@[to_additive\n      \"`finset.noncomm_sum` is “injective” in `f` if `f` maps into independent subgroups.\\nThis generalizes (one direction of) `add_subgroup.disjoint_iff_add_eq_zero`. \"]\ntheorem eq_one_of_noncomm_prod_eq_one_of_independent {ι : Type _} (s : Finset ι) (f : ι → G) (comm) (K : ι → Subgroup G)\n    (hind : CompleteLattice.Independent K) (hmem : ∀ x ∈ s, f x ∈ K x) (heq1 : s.noncomm_prod f comm = 1) :\n    ∀ i ∈ s, f i = 1 := by\n  classical\n    revert heq1\n    induction' s using Finset.induction_on with i s hnmem ih\n    · simp\n    · have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)\n      simp only [Finset.forall_mem_insert] at hmem\n      have hmem_bsupr :\n        s.noncomm_prod f hcomm ∈\n          «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (K i) :=\n        by\n        refine' Subgroup.noncommProd_mem _ _ _\n        intro x hx\n        have :\n          K x ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (K i) :=\n          le_supᵢ₂ x hx\n        exact this (hmem.2 x hx)\n      intro heq1\n      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1\n      have hnmem' : i ∉ (s : Set ι) := by simpa\n      obtain ⟨heq1i : f i = 1, heq1S : s.noncomm_prod f _ = 1⟩ :=\n        subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_bsupr hnmem') hmem.1 hmem_bsupr heq1\n      intro i h\n      simp only [Finset.mem_insert] at h\n      rcases h with ⟨rfl | _⟩\n      · exact heq1i\n      · exact ih hcomm hmem.2 heq1S _ h\n#align eq_one_of_noncomm_prod_eq_one_of_independent eq_one_of_noncomm_prod_eq_one_of_independent\n\n",
 "commute_subtype_of_commute":
 "-- We have an family of subgroups\n-- Elements of `Π (i : ι), H i` are called `f` and `g` here\n-- We assume that the elements of different subgroups commute\n@[to_additive]\ntheorem commute_subtype_of_commute (i j : ι) (hne : i ≠ j) :\n    ∀ (x : H i) (y : H j), Commute ((H i).subtype x) ((H j).subtype y) :=\n  by\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  exact hcomm i j hne x y hx hy\n#align commute_subtype_of_commute commute_subtype_of_commute\n\n"}