{"noncomm_pi_coprod_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem noncomm_pi_coprod_range :\n    (noncomm_pi_coprod hcomm).range =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (H i) :=\n  by simp [noncomm_pi_coprod, monoid_hom.noncomm_pi_coprod_range]\n#align noncomm_pi_coprod_range noncomm_pi_coprod_range\n\n",
 "noncomm_pi_coprod_mul_single":
 "@[simp, to_additive]\ntheorem noncomm_pi_coprod_mul_single (i : ι) (y : H i) : noncomm_pi_coprod hcomm (Pi.mulSingle i y) = y := by\n  apply monoid_hom.noncomm_pi_coprod_mul_single\n#align noncomm_pi_coprod_mul_single noncomm_pi_coprod_mul_single\n\n",
 "noncomm_pi_coprod_mrange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem noncomm_pi_coprod_mrange :\n    (noncomm_pi_coprod ϕ hcomm).mrange =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (ϕ i).mrange :=\n  by\n  classical\n    apply le_antisymm\n    · rintro x ⟨f, rfl⟩\n      refine' submonoid.noncomm_prod_mem _ _ _ _ _\n      intro i hi\n      apply submonoid.mem_Sup_of_mem\n      · use i\n      simp\n    · refine' supᵢ_le _\n      rintro i x ⟨y, rfl⟩\n      refine' ⟨Pi.mulSingle i y, noncomm_pi_coprod_mul_single _ _ _⟩\n#align noncomm_pi_coprod_mrange noncomm_pi_coprod_mrange\n\n",
 "injective_noncomm_pi_coprod_of_independent":
 "@[to_additive]\ntheorem injective_noncomm_pi_coprod_of_independent (hind : complete_lattice.independent H) :\n    function.injective (noncomm_pi_coprod hcomm) :=\n  by\n  apply monoid_hom.injective_noncomm_pi_coprod_of_independent\n  · simpa using hind\n  · intro i\n    exact subtype.coe_injective\n#align injective_noncomm_pi_coprod_of_independent injective_noncomm_pi_coprod_of_independent\n\n",
 "independent_range_of_coprime_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem independent_range_of_coprime_order [Finite ι] [∀ i, fintype (H i)]\n    (hcoprime : ∀ i j, i ≠ j → nat.coprime (fintype.card (H i)) (fintype.card (H j))) :\n    complete_lattice.independent fun i => (ϕ i).range :=\n  by\n  cases nonempty_fintype ι\n  classical\n    rintro i\n    rw [disjoint_iff_inf_le]\n    rintro f ⟨hxi, hxp⟩\n    dsimp at hxi hxp\n    rw [supᵢ_subtype', ← noncomm_pi_coprod_range] at hxp\n    rotate_left\n    · intro _ _ hj\n      apply hcomm\n      exact hj ∘ subtype.ext\n    cases' hxp with g hgf\n    cases' hxi with g' hg'f\n    have hxi : order_of f ∣ fintype.card (H i) := by\n      rw [← hg'f]\n      exact (order_of_map_dvd _ _).trans order_of_dvd_card_univ\n    have hxp :\n      order_of f ∣\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (fintype.card (H j)) :=\n      by\n      rw [← hgf, ← fintype.card_pi]\n      exact (order_of_map_dvd _ _).trans order_of_dvd_card_univ\n    change f = 1\n    rw [← pow_one f, ← order_of_dvd_iff_pow_eq_one]\n    convert ← nat.dvd_gcd hxp hxi\n    rw [← nat.coprime_iff_gcd_eq_one]\n    apply nat.coprime_prod_left\n    intro j _\n    apply hcoprime\n    exact j.2\n#align independent_range_of_coprime_order independent_range_of_coprime_order\n\n",
 "independent_of_coprime_order":
 "@[to_additive]\ntheorem independent_of_coprime_order [Finite ι] [∀ i, fintype (H i)]\n    (hcoprime : ∀ i j, i ≠ j → nat.coprime (fintype.card (H i)) (fintype.card (H j))) :\n    complete_lattice.independent H := by\n  simpa using\n    monoid_hom.independent_range_of_coprime_order (fun i => (H i).subtype) (commute_subtype_of_commute hcomm) hcoprime\n#align independent_of_coprime_order independent_of_coprime_order\n\n",
 "commute_subtype_of_commute":
 "-- We have an family of subgroups\n-- Elements of `Π (i : ι), H i` are called `f` and `g` here\n-- We assume that the elements of different subgroups commute\n@[to_additive]\ntheorem commute_subtype_of_commute (i j : ι) (hne : i ≠ j) :\n    ∀ (x : H i) (y : H j), Commute ((H i).subtype x) ((H j).subtype y) :=\n  by\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  exact hcomm i j hne x y hx hy\n#align commute_subtype_of_commute commute_subtype_of_commute\n\n"}