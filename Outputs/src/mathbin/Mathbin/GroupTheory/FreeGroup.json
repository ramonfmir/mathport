{"unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem prod.unique (g : «expr →* » (free_group α) α) (hg : ∀ x, g (of x) = x) {x} : g x = prod x :=\n  lift.unique g hg\n#align prod.unique prod.unique\n\n",
 "trans":
 "@[trans, to_additive]\ntheorem red.trans : red L₁ L₂ → red L₂ L₃ → red L₁ L₃ :=\n  refl_trans_gen.trans\n#align red.trans red.trans\n\n",
 "to_word_one":
 "@[simp, to_additive]\ntheorem to_word_one : (1 : free_group α).to_word = [] :=\n  rfl\n#align to_word_one to_word_one\n\n",
 "to_word_mk":
 "@[simp, to_additive]\ntheorem to_word_mk : (mk L₁).to_word = reduce L₁ :=\n  rfl\n#align to_word_mk to_word_mk\n\n",
 "to_word_inv":
 "@[to_additive]\ntheorem to_word_inv {x : free_group α} : x⁻¹.to_word = inv_rev x.to_word :=\n  by\n  rcases x with ⟨L⟩\n  rw [quot_mk_eq_mk, inv_mk, to_word_mk, to_word_mk, reduce_inv_rev]\n#align to_word_inv to_word_inv\n\n",
 "to_word_injective":
 "@[to_additive]\ntheorem to_word_injective : function.injective (to_word : free_group α → list (α × bool)) := by\n  rintro ⟨L₁⟩ ⟨L₂⟩ <;> exact reduce.exact\n#align to_word_injective to_word_injective\n\n",
 "to_word_inj":
 "@[simp, to_additive]\ntheorem to_word_inj {x y : free_group α} : to_word x = to_word y ↔ x = y :=\n  to_word_injective.eq_iff\n#align to_word_inj to_word_inj\n\n",
 "to_word_eq_nil_iff":
 "@[simp, to_additive]\ntheorem to_word_eq_nil_iff {x : free_group α} : x.to_word = [] ↔ x = 1 :=\n  to_word_injective.eq_iff' to_word_one\n#align to_word_eq_nil_iff to_word_eq_nil_iff\n\n",
 "to_red":
 "@[to_additive]\ntheorem step.to_red : step L₁ L₂ → red L₁ L₂ :=\n  refl_trans_gen.single\n#align step.to_red step.to_red\n\n",
 "to_append_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem to_append_iff : red L (L₁ ++ L₂) ↔ ∃ L₃ L₄, L = L₃ ++ L₄ ∧ red L₃ L₁ ∧ red L₄ L₂ :=\n  iff.intro\n    (by\n      generalize eq : L₁ ++ L₂ = L₁₂\n      intro h\n      induction' h with L' L₁₂ hLL' h ih generalizing L₁ L₂\n      · exact ⟨_, _, eq.symm, by rfl, by rfl⟩\n      · cases' h with s e a b\n        rcases List.append_eq_append_iff.1 eq with (⟨s', rfl, rfl⟩ | ⟨e', rfl, rfl⟩)\n        · have :\n            L₁ ++ (s' ++ sym.cons' (a, b) (sym.cons' (a, not b) e)) =\n              L₁ ++ s' ++ sym.cons' (a, b) (sym.cons' (a, not b) e) :=\n            by simp\n          rcases ih this with ⟨w₁, w₂, rfl, h₁, h₂⟩\n          exact ⟨w₁, w₂, rfl, h₁, h₂.tail step.bnot⟩\n        · have :\n            s ++ sym.cons' (a, b) (sym.cons' (a, not b) e') ++ L₂ =\n              s ++ sym.cons' (a, b) (sym.cons' (a, not b) (e' ++ L₂)) :=\n            by simp\n          rcases ih this with ⟨w₁, w₂, rfl, h₁, h₂⟩\n          exact ⟨w₁, w₂, rfl, h₁.tail step.bnot, h₂⟩)\n    fun ⟨L₃, L₄, eq, h₃, h₄⟩ => eq.symm ▸ append_append h₃ h₄\n#align to_append_iff to_append_iff\n\n",
 "sum_mk":
 "@[simp]\ntheorem sum_mk : sum (mk L) = List.sum (L.map fun x => cond x.2 x.1 (-x.1)) :=\n  rfl\n#align sum_mk sum_mk\n\n",
 "sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/-- If `w₁ w₂` are words such that `w₁` reduces to `w₂`, then `w₂` is a sublist of `w₁`. -/\n@[to_additive \"If `w₁ w₂` are words such that `w₁` reduces to `w₂`,\\nthen `w₂` is a sublist of `w₁`.\"]\nprotected theorem sublist : red L₁ L₂ → «expr <+ » L₂ L₁ :=\n  reflTransGen_of_transitive_reflexive (fun l => List.Sublist.refl l) (fun a b c hab hbc => List.Sublist.trans hbc hab)\n    fun a b => red.step.sublist\n#align sublist sublist\n\n",
 "step_inv_rev_iff":
 "@[simp, to_additive]\ntheorem red.step_inv_rev_iff : red.step (inv_rev L₁) (inv_rev L₂) ↔ red.step L₁ L₂ :=\n  ⟨fun h => by simpa only [inv_rev_inv_rev] using h.inv_rev, fun h => h.inv_rev⟩\n#align red.step_inv_rev_iff red.step_inv_rev_iff\n\n",
 "sound":
 "-- TODO @[to_additive] doesn't succeed, possibly due to a bug\ntheorem red.enum.sound (H : L₂ ∈ red.enum L₁) : red L₁ L₂ :=\n  List.of_mem_filter H\n#align red.enum.sound red.enum.sound\n\n",
 "sizeof_of_step":
 "@[to_additive]\ntheorem sizeof_of_step : ∀ {L₁ L₂ : list (α × bool)}, step L₁ L₂ → L₂.sizeof < L₁.sizeof\n  | _, _, @step.bnot _ L1 L2 x b => by\n    induction' L1 with hd tl ih\n    case nil =>\n      dsimp [list.sizeof]\n      have H :\n        1 + SizeOf.sizeOf (x, b) + (1 + SizeOf.sizeOf (x, not b) + list.sizeof L2) =\n          list.sizeof L2 + 1 + (SizeOf.sizeOf (x, b) + SizeOf.sizeOf (x, not b) + 1) :=\n        by ac_rfl\n      rw [H]\n      exact nat.le_add_right _ _\n    case cons =>\n      dsimp [list.sizeof]\n      exact nat.add_lt_add_left ih _\n#align sizeof_of_step sizeof_of_step\n\n",
 "singleton_iff":
 "/-- A letter only reduces to itself. -/\n@[to_additive \"A letter only reduces to itself.\"]\ntheorem singleton_iff {x} : red [x] L₁ ↔ L₁ = [x] :=\n  reflTransGen_iff_eq fun l => not_step_singleton\n#align singleton_iff singleton_iff\n\n",
 "self":
 "/-- A word and its maximal reduction correspond to\nthe same element of the free group. -/\n@[to_additive \"A word and its maximal reduction correspond to\\nthe same element of the additive free group.\"]\ntheorem reduce.self : mk (reduce L) = mk L :=\n  reduce.exact reduce.idem\n#align reduce.self reduce.self\n\n",
 "rev":
 "/-- If words `w₁ w₂` are such that `w₁` reduces to `w₂`,\nthen `w₂` reduces to the maximal reduction of `w₁`. -/\n@[to_additive\n      \"If words `w₁ w₂` are such that `w₁` reduces to `w₂`,\\nthen `w₂` reduces to the maximal reduction of `w₁`.\"]\ntheorem reduce.rev (H : red L₁ L₂) : red L₂ (reduce L₁) :=\n  (reduce.eq_of_red H).symm ▸ reduce.red\n#align reduce.rev reduce.rev\n\n",
 "refl":
 "/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n@[refl, to_additive]\ntheorem red.refl : red L L :=\n  refl_trans_gen.refl\n#align red.refl red.refl\n\n",
 "reduce_to_word":
 "@[simp, to_additive]\ntheorem reduce_to_word : ∀ x : free_group α, reduce (to_word x) = to_word x :=\n  by\n  rintro ⟨L⟩\n  exact reduce.idem\n#align reduce_to_word reduce_to_word\n\n",
 "reduce_right":
 "@[to_additive]\ntheorem red.reduce_right (h : red L₁ L₂) : red L₁ (reduce L₂) :=\n  reduce.eq_of_red h ▸ reduce.red\n#align red.reduce_right red.reduce_right\n\n",
 "reduce_left":
 "@[to_additive]\ntheorem red.reduce_left (h : red L₁ L₂) : red L₂ (reduce L₁) :=\n  (reduce.eq_of_red h).symm ▸ reduce.red\n#align red.reduce_left red.reduce_left\n\n",
 "reduce_inv_rev":
 "@[to_additive]\ntheorem reduce_inv_rev {w : list (α × bool)} : reduce (inv_rev w) = inv_rev (reduce w) :=\n  by\n  apply reduce.min\n  rw [← red_inv_rev_iff, inv_rev_inv_rev]\n  apply red.reduce_left\n  have : red (inv_rev (inv_rev w)) (inv_rev (reduce (inv_rev w))) := reduce.red.inv_rev\n  rwa [inv_rev_inv_rev] at this\n#align reduce_inv_rev reduce_inv_rev\n\n",
 "red_inv_rev_iff":
 "@[simp, to_additive]\ntheorem red_inv_rev_iff : red (inv_rev L₁) (inv_rev L₂) ↔ red L₁ L₂ :=\n  ⟨fun h => by simpa only [inv_rev_inv_rev] using h.inv_rev, fun h => h.inv_rev⟩\n#align red_inv_rev_iff red_inv_rev_iff\n\n",
 "red_iff_irreducible":
 "@[to_additive]\ntheorem red_iff_irreducible {x1 b1 x2 b2} (h : (x1, b1) ≠ (x2, b2)) :\n    red [(x1, not b1), (x2, b2)] L ↔ L = [(x1, not b1), (x2, b2)] :=\n  by\n  apply refl_trans_gen_iff_eq\n  generalize eq : [(x1, not b1), (x2, b2)] = L'\n  intro L h'\n  cases h'\n  simp [List.cons_eq_append_iff, List.nil_eq_append] at eq\n  rcases eq with ⟨rfl, ⟨rfl, rfl⟩, ⟨rfl, rfl⟩, rfl⟩; subst_vars\n  simp at h\n  contradiction\n#align red_iff_irreducible red_iff_irreducible\n\n",
 "red":
 "/-- The first theorem that characterises the function\n`reduce`: a word reduces to its maximal reduction. -/\n@[to_additive \"The first theorem that characterises the function\\n`reduce`: a word reduces to its maximal reduction.\"]\ntheorem reduce.red : red L (reduce L) := by\n  induction' L with hd1 tl1 ih\n  case nil => constructor\n  case cons =>\n    dsimp\n    revert ih\n    generalize htl : reduce tl1 = TL\n    intro ih\n    cases' TL with hd2 tl2\n    case nil => exact red.cons_cons ih\n    case cons =>\n      dsimp only\n      split_ifs with h\n      · trans\n        · exact red.cons_cons ih\n        · cases hd1\n          cases hd2\n          cases h\n          dsimp at *\n          subst_vars\n          exact red.step.cons_bnot_rev.to_red\n      · exact red.cons_cons ih\n#align reduce.red reduce.red\n\n",
 "range_le":
 "@[to_additive]\ntheorem lift.range_le {s : subgroup β} (H : Set.range f ⊆ s) : (lift f).range ≤ s := by\n  rintro _ ⟨⟨L⟩, rfl⟩ <;>\n    exact\n      list.rec_on L s.one_mem fun ⟨x, b⟩ tl ih =>\n        bool.rec_on b (by simp at ih⊢ <;> exact s.mul_mem (s.inv_mem <| H ⟨x, rfl⟩) ih)\n          (by simp at ih⊢ <;> exact s.mul_mem (H ⟨x, rfl⟩) ih)\n#align lift.range_le lift.range_le\n\n",
 "range_eq_closure":
 "@[to_additive]\ntheorem lift.range_eq_closure : (lift f).range = subgroup.closure (Set.range f) :=\n  by\n  apply le_antisymm (lift.range_le subgroup.subset_closure)\n  rw [subgroup.closure_le]\n  rintro _ ⟨a, rfl⟩\n  exact ⟨of a, by simp only [lift.of]⟩\n#align lift.range_eq_closure lift.range_eq_closure\n\n",
 "quot_mk_eq_mk":
 "@[simp, to_additive]\ntheorem quot_mk_eq_mk : Quot.mk red.step L = mk L :=\n  rfl\n#align quot_mk_eq_mk quot_mk_eq_mk\n\n",
 "quot_map_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n@[simp, to_additive]\ntheorem quot_map_mk (β : Type v) (f : list (α × bool) → list (β × bool)) (H : («expr ⇒ » red.step red.step) f f) :\n    quot.map f H (mk L) = mk (f L) :=\n  rfl\n#align quot_map_mk quot_map_mk\n\n",
 "quot_lift_on_mk":
 "@[simp, to_additive]\ntheorem quot_lift_on_mk (β : Type v) (f : list (α × bool) → β) (H : ∀ L₁ L₂, red.step L₁ L₂ → f L₁ = f L₂) :\n    quot.lift_on (mk L) f H = f L :=\n  rfl\n#align quot_lift_on_mk quot_lift_on_mk\n\n",
 "quot_lift_mk":
 "@[simp, to_additive]\ntheorem quot_lift_mk (β : Type v) (f : list (α × bool) → β) (H : ∀ L₁ L₂, red.step L₁ L₂ → f L₁ = f L₂) :\n    Quot.lift f H (mk L) = f L :=\n  rfl\n#align quot_lift_mk quot_lift_mk\n\n",
 "pure_bind":
 "@[simp, to_additive]\ntheorem pure_bind (f : α → free_group β) (x) : pure x >>= f = f x :=\n  lift.of\n#align pure_bind pure_bind\n\n",
 "prod_mk":
 "@[simp, to_additive]\ntheorem prod_mk : prod (mk L) = List.prod (L.map fun x => cond x.2 x.1 x.1⁻¹) :=\n  rfl\n#align prod_mk prod_mk\n\n",
 "one_eq_mk":
 "@[to_additive]\ntheorem one_eq_mk : (1 : free_group α) = mk [] :=\n  rfl\n#align one_eq_mk one_eq_mk\n\n",
 "one_bind":
 "@[simp, to_additive]\ntheorem one_bind (f : α → free_group β) : 1 >>= f = 1 :=\n  (lift f).map_one\n#align one_bind one_bind\n\n",
 "of_injective":
 "/-- The canonical map from the type to the free group is an injection. -/\n@[to_additive \"The canonical map from the type to the additive free group is an injection.\"]\ntheorem of_injective : function.injective (@of α) := fun _ _ H =>\n  by\n  let ⟨L₁, hx, hy⟩ := red.exact.1 H\n  simp [red.singleton_iff] at hx hy <;> cc\n#align of_injective of_injective\n\n",
 "of_eq":
 "@[to_additive]\ntheorem lift.of_eq (x : free_group α) : lift of x = x :=\n  MonoidHom.congr_fun (lift.apply_symm_apply (MonoidHom.id _)) x\n#align lift.of_eq lift.of_eq\n\n",
 "of":
 "@[simp]\ntheorem sum.of {x : α} : sum (of x) = x :=\n  prod.of\n#align sum.of sum.of\n\n",
 "not_step_singleton":
 "@[to_additive]\ntheorem not_step_singleton : ∀ {p : α × bool}, ¬step [p] L\n  | (a, b) => by simp [step.cons_left_iff, not_step_nil]\n#align not_step_singleton not_step_singleton\n\n",
 "not_step_nil":
 "@[to_additive]\ntheorem not_step_nil : ¬step [] L := by\n  generalize h' : [] = L'\n  intro h\n  cases' h with L₁ L₂\n  simp [List.nil_eq_append] at h'\n  contradiction\n#align not_step_nil not_step_nil\n\n",
 "not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      []\n      [(Term.attributes\n        \"@[\"\n        [(Term.attrInstance (Term.attrKind []) (to_additive \"to_additive\" [] [] (to_additiveRest [] [] [] [])))]\n        \"]\")]\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `reduce.not [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`p] [\":\" (Term.prop \"Prop\")] \"}\")]\n       (Term.typeSpec\n        \":\"\n        (Term.forall\n         \"∀\"\n         [(Term.implicitBinder \"{\" [`L₁ `L₂ `L₃] [\":\" (Term.app `list [(«term_×_» `α \"×\" `bool)])] \"}\")\n          (Term.implicitBinder \"{\" [`x `b] [] \"}\")]\n         []\n         \",\"\n         (Term.arrow\n          («term_=_»\n           (Term.app `reduce [`L₁])\n           \"=\"\n           («term_++_»\n            `L₂\n            \"++\"\n            (Term.app\n             `sym.cons'\n             [(Term.tuple \"(\" [`x \",\" [`b]] \")\")\n              (Term.app `sym.cons' [(Term.tuple \"(\" [`x \",\" [(Term.app `not [`b])]] \")\") `L₃])])))\n          \"→\"\n          `p))))\n      (Command.declValEqns\n       (Term.matchAltsWhereDecls\n        (Term.matchAlts\n         [(Term.matchAlt\n           \"|\"\n           [[(«term[_]» \"[\" [] \"]\") \",\" `L2 \",\" `L3 \",\" (Term.hole \"_\") \",\" (Term.hole \"_\")]]\n           \"=>\"\n           (Term.fun\n            \"fun\"\n            (Term.basicFun\n             [`h]\n             []\n             \"=>\"\n             (Term.byTactic\n              \"by\"\n              (Tactic.tacticSeq\n               (Tactic.tacticSeq1Indented\n                [(Tactic.«tactic_<;>_»\n                  (Tactic.cases \"cases\" [(Tactic.casesTarget [] `L2)] [] [])\n                  \"<;>\"\n                  (Tactic.injections \"injections\" []))]))))))\n          (Term.matchAlt\n           \"|\"\n           [[(Term.app `sym.cons' [(Term.tuple \"(\" [`x \",\" [`b]] \")\") `L1]) \",\" `L2 \",\" `L3 \",\" `x' \",\" `b']]\n           \"=>\"\n           (Term.byTactic\n            \"by\"\n            (Tactic.tacticSeq\n             (Tactic.tacticSeq1Indented\n              [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n               []\n               (Tactic.cases \"cases\" [(Tactic.casesTarget [`r \":\"] (Term.app `reduce [`L1]))] [] [])\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n                 []\n                 (Tactic.intro \"intro\" [`h])\n                 []\n                 (Tactic.tacticHave_\n                  \"have\"\n                  (Term.haveDecl (Term.haveIdDecl [] [] \":=\" (Term.app `congr_arg [`list.length `h]))))\n                 []\n                 (Tactic.simp\n                  \"simp\"\n                  []\n                  []\n                  []\n                  [\"[\" [(Tactic.simpErase \"-\" `add_comm)] \"]\"]\n                  [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.app\n                   `absurd\n                   [`this\n                    (Term.byTactic \"by\" (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.decide \"decide\")])))]))])\n               []\n               (Tactic.cases'\n                \"cases'\"\n                [(Tactic.casesTarget [] `hd)]\n                []\n                [\"with\" [(Lean.binderIdent `y) (Lean.binderIdent `c)]])\n               []\n               (Tactic.dsimp \"dsimp\" [] [] [\"only\"] [] [])\n               []\n               (Tactic.«tactic_<;>_»\n                (Mathlib.Tactic.splitIfs \"split_ifs\" [] [\"with\" [(Lean.binderIdent `h)]])\n                \"<;>\"\n                (Tactic.intro \"intro\" [`H]))\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.rwSeq\n                  \"rw\"\n                  []\n                  (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `H)] \"]\")\n                  [(Tactic.location \"at\" (Tactic.locationHyp [`r] []))])\n                 []\n                 (Tactic.exact\n                  \"exact\"\n                  (Term.app\n                   (Term.explicit \"@\" `reduce.not)\n                   [`L1 (Term.app `sym.cons' [(Term.tuple \"(\" [`y \",\" [`c]] \")\") `L2]) `L3 `x' `b' `r]))])\n               []\n               (Std.Tactic.rcases\n                \"rcases\"\n                [(Tactic.casesTarget [] `L2)]\n                [\"with\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed\n                   [(Std.Tactic.RCases.rcasesPat.paren\n                     \"(\"\n                     (Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed\n                       [(Std.Tactic.RCases.rcasesPat.ignore \"_\")\n                        \"|\"\n                        (Std.Tactic.RCases.rcasesPat.tuple\n                         \"⟨\"\n                         [(Std.Tactic.RCases.rcasesPatLo\n                           (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                           [])\n                          \",\"\n                          (Std.Tactic.RCases.rcasesPatLo\n                           (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `L2)])\n                           [])]\n                         \"⟩\")])\n                      [])\n                     \")\")])\n                  [])])\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.injections \"injections\" [])\n                 []\n                 (Tactic.substVars \"subst_vars\")\n                 []\n                 (Tactic.simp \"simp\" [] [] [] [] [(Tactic.location \"at\" (Tactic.locationHyp [`h] []))])\n                 []\n                 (Tactic.cc \"cc\")])\n               []\n               (tactic__\n                (cdotTk (patternIgnore (token.«· » \"·\")))\n                [(Tactic.refine'\n                  \"refine'\"\n                  (Term.app (Term.explicit \"@\" `reduce.not) [`L1 `L2 `L3 `x' `b' (Term.hole \"_\")]))\n                 []\n                 (Tactic.injection \"injection\" `H [\"with\" [\"_\" `H]])\n                 []\n                 (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `r) \",\" (Tactic.rwRule [] `H)] \"]\") [])\n                 []\n                 (Tactic.tacticRfl \"rfl\")])]))))])\n        []))\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.declValSimple'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n          []\n          (Tactic.cases \"cases\" [(Tactic.casesTarget [`r \":\"] (Term.app `reduce [`L1]))] [] [])\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.dsimp \"dsimp\" [] [] [] [] [])\n            []\n            (Tactic.intro \"intro\" [`h])\n            []\n            (Tactic.tacticHave_\n             \"have\"\n             (Term.haveDecl (Term.haveIdDecl [] [] \":=\" (Term.app `congr_arg [`list.length `h]))))\n            []\n            (Tactic.simp\n             \"simp\"\n             []\n             []\n             []\n             [\"[\" [(Tactic.simpErase \"-\" `add_comm)] \"]\"]\n             [(Tactic.location \"at\" (Tactic.locationHyp [`this] []))])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.app\n              `absurd\n              [`this (Term.byTactic \"by\" (Tactic.tacticSeq (Tactic.tacticSeq1Indented [(Tactic.decide \"decide\")])))]))])\n          []\n          (Tactic.cases'\n           \"cases'\"\n           [(Tactic.casesTarget [] `hd)]\n           []\n           [\"with\" [(Lean.binderIdent `y) (Lean.binderIdent `c)]])\n          []\n          (Tactic.dsimp \"dsimp\" [] [] [\"only\"] [] [])\n          []\n          (Tactic.«tactic_<;>_»\n           (Mathlib.Tactic.splitIfs \"split_ifs\" [] [\"with\" [(Lean.binderIdent `h)]])\n           \"<;>\"\n           (Tactic.intro \"intro\" [`H]))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `H)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`r] []))])\n            []\n            (Tactic.exact\n             \"exact\"\n             (Term.app\n              (Term.explicit \"@\" `reduce.not)\n              [`L1 (Term.app `sym.cons' [(Term.tuple \"(\" [`y \",\" [`c]] \")\") `L2]) `L3 `x' `b' `r]))])\n          []\n          (Std.Tactic.rcases\n           \"rcases\"\n           [(Tactic.casesTarget [] `L2)]\n           [\"with\"\n            (Std.Tactic.RCases.rcasesPatLo\n             (Std.Tactic.RCases.rcasesPatMed\n              [(Std.Tactic.RCases.rcasesPat.paren\n                \"(\"\n                (Std.Tactic.RCases.rcasesPatLo\n                 (Std.Tactic.RCases.rcasesPatMed\n                  [(Std.Tactic.RCases.rcasesPat.ignore \"_\")\n                   \"|\"\n                   (Std.Tactic.RCases.rcasesPat.tuple\n                    \"⟨\"\n                    [(Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `a)])\n                      [])\n                     \",\"\n                     (Std.Tactic.RCases.rcasesPatLo\n                      (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `L2)])\n                      [])]\n                    \"⟩\")])\n                 [])\n                \")\")])\n             [])])\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.injections \"injections\" [])\n            []\n            (Tactic.substVars \"subst_vars\")\n            []\n            (Tactic.simp \"simp\" [] [] [] [] [(Tactic.location \"at\" (Tactic.locationHyp [`h] []))])\n            []\n            (Tactic.cc \"cc\")])\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.refine' \"refine'\" (Term.app (Term.explicit \"@\" `reduce.not) [`L1 `L2 `L3 `x' `b' (Term.hole \"_\")]))\n            []\n            (Tactic.injection \"injection\" `H [\"with\" [\"_\" `H]])\n            []\n            (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `r) \",\" (Tactic.rwRule [] `H)] \"]\") [])\n            []\n            (Tactic.tacticRfl \"rfl\")])])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.refine' \"refine'\" (Term.app (Term.explicit \"@\" `reduce.not) [`L1 `L2 `L3 `x' `b' (Term.hole \"_\")]))\n        []\n        (Tactic.injection \"injection\" `H [\"with\" [\"_\" `H]])\n        []\n        (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `r) \",\" (Tactic.rwRule [] `H)] \"]\") [])\n        []\n        (Tactic.tacticRfl \"rfl\")])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tacticRfl \"rfl\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `r) \",\" (Tactic.rwRule [] `H)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `H\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `r\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.injection \"injection\" `H [\"with\" [\"_\" `H]])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'ident'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'Lean.Parser.Term.hole'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValEqns', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n@[ to_additive ]\n  theorem\n    reduce.not\n    { p : Prop }\n      : ∀ { L₁ L₂ L₃ : list α × bool } { x b } , reduce L₁ = L₂ ++ sym.cons' ( x , b ) sym.cons' ( x , not b ) L₃ → p\n    | [ ] , L2 , L3 , _ , _ => fun h => by cases L2 <;> injections\n      |\n        sym.cons' ( x , b ) L1 , L2 , L3 , x' , b'\n        =>\n        by\n          dsimp\n            cases r : reduce L1\n            · dsimp intro h have := congr_arg list.length h simp [ - add_comm ] at this exact absurd this by decide\n            cases' hd with y c\n            dsimp only\n            split_ifs with h <;> intro H\n            · rw [ H ] at r exact @ reduce.not L1 sym.cons' ( y , c ) L2 L3 x' b' r\n            rcases L2 with ( _ | ⟨ a , L2 ⟩ )\n            · injections subst_vars simp at h cc\n            · refine' @ reduce.not L1 L2 L3 x' b' _ injection H with _ H rw [ r , H ] rfl\n#align reduce.not reduce.not\n\n",
 "norm_one":
 "@[simp, to_additive]\ntheorem norm_one : norm (1 : free_group α) = 0 :=\n  rfl\n#align norm_one norm_one\n\n",
 "norm_mul_le":
 "@[to_additive]\ntheorem norm_mul_le (x y : free_group α) : norm (x * y) ≤ norm x + norm y :=\n  calc\n    norm (x * y) = norm (mk (x.to_word ++ y.to_word)) := by rw [← mul_mk, mk_to_word, mk_to_word]\n    _ ≤ (x.to_word ++ y.to_word).length := norm_mk_le\n    _ = norm x + norm y := list.length_append _ _\n    \n#align norm_mul_le norm_mul_le\n\n",
 "norm_mk_le":
 "@[to_additive]\ntheorem norm_mk_le : norm (mk L₁) ≤ L₁.length :=\n  reduce.red.length_le\n#align norm_mk_le norm_mk_le\n\n",
 "norm_inv_eq":
 "@[simp, to_additive]\ntheorem norm_inv_eq {x : free_group α} : norm x⁻¹ = norm x := by simp only [norm, to_word_inv, inv_rev_length]\n#align norm_inv_eq norm_inv_eq\n\n",
 "norm_eq_zero":
 "@[simp, to_additive]\ntheorem norm_eq_zero {x : free_group α} : norm x = 0 ↔ x = 1 := by\n  simp only [norm, List.length_eq_zero, to_word_eq_nil_iff]\n#align norm_eq_zero norm_eq_zero\n\n",
 "nil_iff":
 "/-- The empty word `[]` only reduces to itself. -/\n@[to_additive \"The empty word `[]` only reduces to itself.\"]\ntheorem nil_iff : red [] L ↔ L = [] :=\n  reflTransGen_iff_eq fun l => red.not_step_nil\n#align nil_iff nil_iff\n\n",
 "mul_mk":
 "@[simp, to_additive]\ntheorem mul_mk : mk L₁ * mk L₂ = mk (L₁ ++ L₂) :=\n  rfl\n#align mul_mk mul_mk\n\n",
 "mul_bind":
 "@[simp, to_additive]\ntheorem mul_bind (f : α → free_group β) (x y : free_group α) : x * y >>= f = (x >>= f) * (y >>= f) :=\n  (lift f).map_mul _ _\n#align mul_bind mul_bind\n\n",
 "mk_to_word":
 "@[to_additive]\ntheorem mk_to_word : ∀ {x : free_group α}, mk (to_word x) = x := by rintro ⟨L⟩ <;> exact reduce.self\n#align mk_to_word mk_to_word\n\n",
 "mk":
 "@[simp, to_additive]\ntheorem map.mk : map f (mk L) = mk (L.map fun x => (f x.1, x.2)) :=\n  rfl\n#align map.mk map.mk\n\n",
 "min":
 "/-- The second theorem that characterises the\nfunction `reduce`: the maximal reduction of a word\nonly reduces to itself. -/\n@[to_additive\n      \"The second theorem that characterises the\\nfunction `reduce`: the maximal reduction of a word\\nonly reduces to itself.\"]\ntheorem reduce.min (H : red (reduce L₁) L₂) : reduce L₁ = L₂ :=\n  by\n  induction' H with L1 L' L2 H1 H2 ih\n  · rfl\n  · cases' H1 with L4 L5 x b\n    exact reduce.not H2\n#align reduce.min reduce.min\n\n",
 "map_pure":
 "@[simp, to_additive]\ntheorem map_pure (f : α → β) (x : α) : f <$> (pure x : free_group α) = pure (f x) :=\n  map.of\n#align map_pure map_pure\n\n",
 "map_one":
 "#print map_one /-\n@[simp, to_additive]\ntheorem map_one (f : α → β) : f <$> (1 : free_group α) = 1 :=\n  (map f).map_one\n#align map_one map_one\n-/\n\n",
 "map_mul":
 "#print map_mul /-\n@[simp, to_additive]\ntheorem map_mul (f : α → β) (x y : free_group α) : f <$> (x * y) = f <$> x * f <$> y :=\n  (map f).map_mul x y\n#align map_mul map_mul\n-/\n\n",
 "map_inv":
 "#print map_inv /-\n@[simp, to_additive]\ntheorem map_inv (f : α → β) (x : free_group α) : f <$> x⁻¹ = (f <$> x)⁻¹ :=\n  (map f).map_inv x\n#align map_inv map_inv\n-/\n\n",
 "map_eq_lift":
 "@[to_additive]\ntheorem map_eq_lift : map f x = lift (of ∘ f) x :=\n  eq.symm <| map.unique _ fun x => by simp\n#align map_eq_lift map_eq_lift\n\n",
 "lift_eq_prod_map":
 "@[to_additive]\ntheorem lift_eq_prod_map {β : Type v} [group β] {f : α → β} {x} : lift f x = prod (map f x) :=\n  by\n  rw [← lift.unique (prod.comp (map f))]\n  · rfl\n  · simp\n#align lift_eq_prod_map lift_eq_prod_map\n\n",
 "lift":
 "@[to_additive]\ntheorem red.step.lift {f : α → β} (H : red.step L₁ L₂) : lift.aux f L₁ = lift.aux f L₂ := by\n  cases' H with _ _ _ b <;> cases b <;> simp [lift.aux]\n#align red.step.lift red.step.lift\n\n",
 "length_le":
 "@[to_additive]\ntheorem length_le (h : red L₁ L₂) : L₂.length ≤ L₁.length :=\n  h.sublist.length_le\n#align length_le length_le\n\n",
 "length":
 "@[to_additive]\ntheorem length (h : red L₁ L₂) : ∃ n, L₁.length = L₂.length + 2 * n :=\n  by\n  induction' h with L₂ L₃ h₁₂ h₂₃ ih\n  · exact ⟨0, rfl⟩\n  · rcases ih with ⟨n, eq⟩\n    exists 1 + n\n    simp [mul_add, eq, (step.length h₂₃).symm, add_assoc]\n#align length length\n\n",
 "join_red_of_step":
 "@[to_additive]\ntheorem join_red_of_step (h : red.step L₁ L₂) : join red L₁ L₂ :=\n  join_of_single reflexive_reflTransGen h.to_red\n#align join_red_of_step join_red_of_step\n\n",
 "inv_rev_surjective":
 "@[to_additive]\ntheorem inv_rev_surjective : function.surjective (@inv_rev α) :=\n  inv_rev_involutive.surjective\n#align inv_rev_surjective inv_rev_surjective\n\n",
 "inv_rev_length":
 "@[simp, to_additive]\ntheorem inv_rev_length : (inv_rev L₁).length = L₁.length := by simp [inv_rev]\n#align inv_rev_length inv_rev_length\n\n",
 "inv_rev_involutive":
 "@[to_additive]\ntheorem inv_rev_involutive : function.involutive (@inv_rev α) := fun _ => inv_rev_inv_rev\n#align inv_rev_involutive inv_rev_involutive\n\n",
 "inv_rev_inv_rev":
 "@[simp, to_additive]\ntheorem inv_rev_inv_rev : inv_rev (inv_rev L₁) = L₁ := by simp [inv_rev, (· ∘ ·)]\n#align inv_rev_inv_rev inv_rev_inv_rev\n\n",
 "inv_rev_injective":
 "@[to_additive]\ntheorem inv_rev_injective : function.injective (@inv_rev α) :=\n  inv_rev_involutive.injective\n#align inv_rev_injective inv_rev_injective\n\n",
 "inv_rev_empty":
 "@[simp, to_additive]\ntheorem inv_rev_empty : inv_rev ([] : list (α × bool)) = [] :=\n  rfl\n#align inv_rev_empty inv_rev_empty\n\n",
 "inv_rev_bijective":
 "@[to_additive]\ntheorem inv_rev_bijective : function.bijective (@inv_rev α) :=\n  inv_rev_involutive.bijective\n#align inv_rev_bijective inv_rev_bijective\n\n",
 "inv_rev":
 "@[to_additive]\ntheorem red.inv_rev {L₁ L₂ : list (α × bool)} (h : red L₁ L₂) : red (inv_rev L₁) (inv_rev L₂) :=\n  relation.refl_trans_gen.lift _ (fun a b => red.step.inv_rev) h\n#align red.inv_rev red.inv_rev\n\n",
 "inv_of_red_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/-- If `x` and `y` are distinct letters and `w₁ w₂` are words such that `xw₁` reduces to `yw₂`, then\n`w₁` reduces to `x⁻¹yw₂`. -/\n@[to_additive\n      \"If `x` and `y` are distinct letters and `w₁ w₂` are words such that `x + w₁` reduces to `y + w₂`,\\nthen `w₁` reduces to `-x + y + w₂`.\"]\ntheorem inv_of_red_of_ne {x1 b1 x2 b2} (H1 : (x1, b1) ≠ (x2, b2))\n    (H2 : red (sym.cons' (x1, b1) L₁) (sym.cons' (x2, b2) L₂)) :\n    red L₁ (sym.cons' (x1, not b1) (sym.cons' (x2, b2) L₂)) :=\n  by\n  have : red (sym.cons' (x1, b1) L₁) ([(x2, b2)] ++ L₂) := H2\n  rcases to_append_iff.1 this with ⟨_ | ⟨p, L₃⟩, L₄, eq, h₁, h₂⟩\n  · simp [nil_iff] at h₁\n    contradiction\n  · cases eq\n    show red (L₃ ++ L₄) ([(x1, not b1), (x2, b2)] ++ L₂)\n    apply append_append _ h₂\n    have h₁ : red (sym.cons' (x1, not b1) (sym.cons' (x1, b1) L₃)) [(x1, not b1), (x2, b2)] := cons_cons h₁\n    have h₂ : red (sym.cons' (x1, not b1) (sym.cons' (x1, b1) L₃)) L₃ := step.cons_bnot_rev.to_red\n    rcases church_rosser h₁ h₂ with ⟨L', h₁, h₂⟩\n    rw [red_iff_irreducible H1] at h₁\n    rwa [h₁] at h₂\n#align inv_of_red_of_ne inv_of_red_of_ne\n\n",
 "inv_mk":
 "@[simp, to_additive]\ntheorem inv_mk : (mk L)⁻¹ = mk (inv_rev L) :=\n  rfl\n#align inv_mk inv_mk\n\n",
 "inv_bind":
 "@[simp, to_additive]\ntheorem inv_bind (f : α → free_group β) (x : free_group α) : x⁻¹ >>= f = (x >>= f)⁻¹ :=\n  (lift f).map_inv _\n#align inv_bind inv_bind\n\n",
 "induction_on":
 "@[elab_as_elim, to_additive]\nprotected theorem induction_on {C : free_group α → Prop} (z : free_group α) (C1 : C 1) (Cp : ∀ x, C <| pure x)\n    (Ci : ∀ x, C (pure x) → C (pure x)⁻¹) (Cm : ∀ x y, C x → C y → C (x * y)) : C z :=\n  Quot.inductionOn z fun L =>\n    list.rec_on L C1 fun ⟨x, b⟩ tl ih => bool.rec_on b (Cm _ _ (Ci _ <| Cp x) ih) (Cm _ _ (Cp x) ih)\n#align induction_on induction_on\n\n",
 "idem":
 "/-- `reduce` is idempotent, i.e. the maximal reduction\nof the maximal reduction of a word is the maximal\nreduction of the word. -/\n@[simp,\n  to_additive\n      \"`reduce` is idempotent, i.e. the maximal reduction\\nof the maximal reduction of a word is the maximal\\nreduction of the word.\"]\ntheorem reduce.idem : reduce (reduce L) = reduce L :=\n  eq.symm <| reduce.min reduce.red\n#align reduce.idem reduce.idem\n\n",
 "id'":
 "@[simp, to_additive]\ntheorem map.id' (x : free_group α) : map (fun z => z) x = x :=\n  map.id x\n#align map.id' map.id'\n\n",
 "id":
 "@[simp, to_additive]\ntheorem map.id (x : free_group α) : map id x = x := by rcases x with ⟨L⟩ <;> simp [List.map_id']\n#align map.id map.id\n\n",
 "free_group_congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[to_additive]\ntheorem free_group_congr_trans {α β γ} (e : «expr ≃ » α β) (f : «expr ≃ » β γ) :\n    (free_group_congr e).trans (free_group_congr f) = free_group_congr (e.trans f) :=\n  MulEquiv.ext <| map.comp _ _\n#align free_group_congr_trans free_group_congr_trans\n\n",
 "free_group_congr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp, to_additive]\ntheorem free_group_congr_symm {α β} (e : «expr ≃ » α β) : (free_group_congr e).symm = free_group_congr e.symm :=\n  rfl\n#align free_group_congr_symm free_group_congr_symm\n\n",
 "free_group_congr_refl":
 "@[simp, to_additive]\ntheorem free_group_congr_refl : free_group_congr (equiv.refl α) = MulEquiv.refl _ :=\n  MulEquiv.ext map.id\n#align free_group_congr_refl free_group_congr_refl\n\n",
 "ext_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext,\n  to_additive\n      \"Two homomorphisms out of a free additive group are equal if they are equal on generators.\\n\\nSee note [partially-applied ext lemmas].\"]\ntheorem ext_hom {G : Type _} [group G] (f g : «expr →* » (free_group α) G) (h : ∀ a, f (of a) = g (of a)) : f = g :=\n  lift.symm.injective <| funext h\n#align ext_hom ext_hom\n\n",
 "exact":
 "/-- If two words have a common maximal reduction,\nthen they correspond to the same element in the free group. -/\n@[to_additive\n      \"If two words have a common maximal reduction,\\nthen they correspond to the same element in the additive free group.\"]\ntheorem reduce.exact (H : reduce L₁ = reduce L₂) : mk L₁ = mk L₂ :=\n  red.exact.2 ⟨reduce L₂, H ▸ reduce.red, reduce.red⟩\n#align reduce.exact reduce.exact\n\n",
 "eqv_gen_step_iff_join_red":
 "@[to_additive]\ntheorem eqv_gen_step_iff_join_red : EqvGen red.step L₁ L₂ ↔ join red L₁ L₂ :=\n  iff.intro\n    (fun h =>\n      have : EqvGen (join red) L₁ L₂ := h.mono fun a b => join_red_of_step\n      equivalence_join_red.eqv_gen_iff.1 this)\n    (join_of_equivalence (eqv_gen.is_equivalence _) fun a b =>\n      reflTransGen_of_equivalence (eqv_gen.is_equivalence _) eqv_gen.rel)\n#align eqv_gen_step_iff_join_red eqv_gen_step_iff_join_red\n\n",
 "equivalence_join_red":
 "@[to_additive]\ntheorem equivalence_join_red : equivalence (join (@red α)) :=\n  equivalence_join_refl_trans_gen fun a b c hab hac =>\n    match b, c, red.step.diamond hab hac rfl with\n    | b, _, or.inl rfl => ⟨b, by rfl, by rfl⟩\n    | b, c, or.inr ⟨d, hbd, hcd⟩ => ⟨d, refl_gen.single hbd, refl_trans_gen.single hcd⟩\n#align equivalence_join_red equivalence_join_red\n\n",
 "eq_of_red":
 "/-- If a word reduces to another word, then they have\na common maximal reduction. -/\n@[to_additive \"If a word reduces to another word, then they have\\na common maximal reduction.\"]\ntheorem reduce.eq_of_red (H : red L₁ L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨L₃, HR13, HR23⟩ := red.church_rosser reduce.red (red.trans H reduce.red)\n  (reduce.min HR13).trans (reduce.min HR23).symm\n#align reduce.eq_of_red reduce.eq_of_red\n\n",
 "eq":
 "@[to_additive]\ntheorem reduce.step.eq (H : red.step L₁ L₂) : reduce L₁ = reduce L₂ :=\n  let ⟨L₃, HR13, HR23⟩ := red.church_rosser reduce.red (reduce.red.head H)\n  (reduce.min HR13).trans (reduce.min HR23).symm\n#align reduce.step.eq reduce.step.eq\n\n",
 "diamond_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem step.diamond_aux :\n    ∀ {L₁ L₂ L₃ L₄ : list (α × bool)} {x1 b1 x2 b2},\n      L₁ ++ sym.cons' (x1, b1) (sym.cons' (x1, not b1) L₂) = L₃ ++ sym.cons' (x2, b2) (sym.cons' (x2, not b2) L₄) →\n        L₁ ++ L₂ = L₃ ++ L₄ ∨ ∃ L₅, red.step (L₁ ++ L₂) L₅ ∧ red.step (L₃ ++ L₄) L₅\n  | [], _, [], _, _, _, _, _, H => by injections <;> subst_vars <;> simp\n  | [], _, [(x3, b3)], _, _, _, _, _, H => by injections <;> subst_vars <;> simp\n  | [(x3, b3)], _, [], _, _, _, _, _, H => by injections <;> subst_vars <;> simp\n  | [], _, sym.cons' (x3, b3) (sym.cons' (x4, b4) tl), _, _, _, _, _, H => by\n    injections <;> subst_vars <;> simp <;> right <;> exact ⟨_, red.step.bnot, red.step.cons_bnot⟩\n  | sym.cons' (x3, b3) (sym.cons' (x4, b4) tl), _, [], _, _, _, _, _, H => by\n    injections <;> subst_vars <;> simp <;> right <;> exact ⟨_, red.step.cons_bnot, red.step.bnot⟩\n  | sym.cons' (x3, b3) tl, _, sym.cons' (x4, b4) tl2, _, _, _, _, _, H =>\n    let ⟨H1, H2⟩ := list.cons.inj H\n    match step.diamond_aux H2 with\n    | or.inl H3 => or.inl <| by simp [H1, H3]\n    | or.inr ⟨L₅, H3, H4⟩ => or.inr ⟨_, step.cons H3, by simpa [H1] using step.cons H4⟩\n#align step.diamond_aux step.diamond_aux\n\n",
 "diamond":
 "@[to_additive]\ntheorem step.diamond :\n    ∀ {L₁ L₂ L₃ L₄ : list (α × bool)},\n      red.step L₁ L₃ → red.step L₂ L₄ → L₁ = L₂ → L₃ = L₄ ∨ ∃ L₅, red.step L₃ L₅ ∧ red.step L₄ L₅\n  | _, _, _, _, red.step.bnot, red.step.bnot, H => step.diamond_aux H\n#align step.diamond step.diamond\n\n",
 "cons_nil_iff_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/-- If `x` is a letter and `w` is a word such that `xw` reduces to the empty word, then `w` reduces\nto `x⁻¹` -/\n@[to_additive\n      \"If `x` is a letter and `w` is a word such that `x + w` reduces to the empty word,\\nthen `w` reduces to `-x`.\"]\ntheorem cons_nil_iff_singleton {x b} : red (sym.cons' (x, b) L) [] ↔ red L [(x, not b)] :=\n  iff.intro\n    (fun h => by\n      have h₁ : red (sym.cons' (x, not b) (sym.cons' (x, b) L)) [(x, not b)] := cons_cons h\n      have h₂ : red (sym.cons' (x, not b) (sym.cons' (x, b) L)) L := refl_trans_gen.single step.cons_bnot_rev\n      let ⟨L', h₁, h₂⟩ := church_rosser h₁ h₂\n      rw [singleton_iff] at h₁ <;> subst L' <;> assumption)\n    fun h => (cons_cons h).tail step.cons_bnot\n#align cons_nil_iff_singleton cons_nil_iff_singleton\n\n",
 "cons_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem step.cons_left_iff {a : α} {b : bool} :\n    step (sym.cons' (a, b) L₁) L₂ ↔ (∃ L, step L₁ L ∧ L₂ = sym.cons' (a, b) L) ∨ L₁ = sym.cons' (a, not b) L₂ :=\n  by\n  constructor\n  · generalize hL : (sym.cons' (a, b) L₁ : list _) = L\n    rintro @⟨_ | ⟨p, s'⟩, e, a', b'⟩\n    · simp at hL\n      simp [*]\n    · simp at hL\n      rcases hL with ⟨rfl, rfl⟩\n      refine' or.inl ⟨s' ++ e, step.bnot, _⟩\n      simp\n  · rintro (⟨L, h, rfl⟩ | rfl)\n    · exact step.cons h\n    · exact step.cons_bnot\n#align step.cons_left_iff step.cons_left_iff\n\n",
 "cons_cons_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem cons_cons_iff (p) : red (sym.cons' p L₁) (sym.cons' p L₂) ↔ red L₁ L₂ :=\n  iff.intro\n    (by\n      generalize eq₁ : (sym.cons' p L₁ : list _) = LL₁\n      generalize eq₂ : (sym.cons' p L₂ : list _) = LL₂\n      intro h\n      induction' h using relation.refl_trans_gen.head_induction_on with L₁ L₂ h₁₂ h ih generalizing L₁ L₂\n      · subst_vars\n        cases eq₂\n        constructor\n      · subst_vars\n        cases' p with a b\n        rw [step.cons_left_iff] at h₁₂\n        rcases h₁₂ with (⟨L, h₁₂, rfl⟩ | rfl)\n        · exact (ih rfl rfl).head h₁₂\n        · exact (cons_cons h).tail step.cons_bnot_rev)\n    cons_cons\n#align cons_cons_iff cons_cons_iff\n\n",
 "cons_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem cons_cons {p} : red L₁ L₂ → red (sym.cons' p L₁) (sym.cons' p L₂) :=\n  refl_trans_gen.lift (list.cons p) fun a b => step.cons\n#align cons_cons cons_cons\n\n",
 "cons_bnot_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp, to_additive]\ntheorem step.cons_bnot_rev {x b} : red.step (sym.cons' (x, not b) (sym.cons' (x, b) L)) L :=\n  @red.step.bnot_rev _ [] _ _ _\n#align step.cons_bnot_rev step.cons_bnot_rev\n\n",
 "cons_bnot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp, to_additive]\ntheorem step.cons_bnot {x b} : red.step (sym.cons' (x, b) (sym.cons' (x, not b) L)) L :=\n  @step.bnot _ [] _ _ _\n#align step.cons_bnot step.cons_bnot\n\n",
 "cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp, to_additive]\ntheorem reduce.cons (x) :\n    reduce (sym.cons' x L) =\n      list.cases_on (reduce L) [x] fun hd tl =>\n        if x.1 = hd.1 ∧ x.2 = not hd.2 then tl else sym.cons' x (sym.cons' hd tl) :=\n  rfl\n#align reduce.cons reduce.cons\n\n",
 "complete":
 "theorem red.enum.complete (H : red L₁ L₂) : L₂ ∈ red.enum L₁ :=\n  List.mem_filter_of_mem (List.mem_sublists.2 <| red.sublist H) H\n#align red.enum.complete red.enum.complete\n\n",
 "comp":
 "@[to_additive]\ntheorem map.comp {γ : Type w} (f : α → β) (g : β → γ) (x) : map g (map f x) = map (g ∘ f) x := by\n  rcases x with ⟨L⟩ <;> simp\n#align map.comp map.comp\n\n",
 "church_rosser":
 "/-- **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\nrespectively. This is also known as Newman's diamond lemma. -/\n@[to_additive\n      \"**Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\\nrespectively. This is also known as Newman's diamond lemma.\"]\ntheorem church_rosser : red L₁ L₂ → red L₁ L₃ → join red L₂ L₃ :=\n  relation.church_rosser fun a b c hab hac =>\n    match b, c, red.step.diamond hab hac rfl with\n    | b, _, or.inl rfl => ⟨b, by rfl, by rfl⟩\n    | b, c, or.inr ⟨d, hbd, hcd⟩ => ⟨d, refl_gen.single hbd, hcd.to_red⟩\n#align church_rosser church_rosser\n\n",
 "bnot_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp, to_additive]\ntheorem step.bnot_rev {x b} : step (L₁ ++ sym.cons' (x, not b) (sym.cons' (x, b) L₂)) (L₁ ++ L₂) := by\n  cases b <;> exact step.bnot\n#align step.bnot_rev step.bnot_rev\n\n",
 "append_right":
 "@[to_additive]\ntheorem step.append_right : ∀ {L₁ L₂ L₃ : list (α × bool)}, step L₁ L₂ → step (L₁ ++ L₃) (L₂ ++ L₃)\n  | _, _, _, red.step.bnot => by simp\n#align step.append_right step.append_right\n\n",
 "append_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem step.append_left_iff : ∀ L, step (L ++ L₁) (L ++ L₂) ↔ step L₁ L₂\n  | [] => by simp\n  | sym.cons' p l => by simp [step.append_left_iff l, step.cons_cons_iff]\n#align step.append_left_iff step.append_left_iff\n\n",
 "append_left":
 "@[to_additive]\ntheorem step.append_left : ∀ {L₁ L₂ L₃ : list (α × bool)}, step L₂ L₃ → step (L₁ ++ L₂) (L₁ ++ L₃)\n  | _, _, _, red.step.bnot => by rw [← list.append_assoc, ← list.append_assoc] <;> constructor\n#align step.append_left step.append_left\n\n",
 "append_append_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[to_additive]\ntheorem append_append_left_iff : ∀ L, red (L ++ L₁) (L ++ L₂) ↔ red L₁ L₂\n  | [] => iff.rfl\n  | sym.cons' p L => by simp [append_append_left_iff L, cons_cons_iff]\n#align append_append_left_iff append_append_left_iff\n\n",
 "append_append":
 "@[to_additive]\ntheorem append_append (h₁ : red L₁ L₃) (h₂ : red L₂ L₄) : red (L₁ ++ L₂) (L₃ ++ L₄) :=\n  (h₁.lift (fun L => L ++ L₂) fun a b => step.append_right).trans ((append_append_left_iff _).2 h₂)\n#align append_append append_append\n\n",
 "antisymm":
 "#print antisymm /-\n@[to_additive]\ntheorem antisymm (h₁₂ : red L₁ L₂) (h₂₁ : red L₂ L₁) : L₁ = L₂ :=\n  h₂₁.sublist.antisymm h₁₂.sublist\n#align antisymm antisymm\n-/\n\n"}