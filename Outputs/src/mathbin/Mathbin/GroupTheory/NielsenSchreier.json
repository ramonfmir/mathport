{"tree_hom_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem tree_hom_root : tree_hom T (root' T) = («expr𝟙») _ :=\n  -- this should just be `tree_hom_eq T path.nil`, but Lean treats `hom_of_path` with suspicion.\n    trans\n    (tree_hom_eq T path.nil) rfl\n#align tree_hom_root tree_hom_root\n\n",
 "tree_hom_eq":
 "/- In this section, we suppose we have a free groupoid with a spanning tree for its generating\nquiver. The goal is to prove that the vertex group at the root is free. A picture to have in mind\nis that we are 'pulling' the endpoints of all the edges of the quiver along the spanning tree to\nthe root. -/\n-- this has to be marked noncomputable, see issue #451.\n-- It might be nicer to define this in terms of `compose_path`\n/-- Any path to `a` gives `tree_hom T a`, since paths in the tree are unique. -/\ntheorem tree_hom_eq {a : G} (p : Path (root T) a) : tree_hom T a = hom_of_path T p := by\n  rw [tree_hom, Unique.default_eq]\n#align tree_hom_eq tree_hom_eq\n\n",
 "path_nonempty_of_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- If there exists a morphism `a → b` in a free groupoid, then there also exists a zigzag\nfrom `a` to `b` in the generating quiver. -/\ntheorem path_nonempty_of_hom {G} [Groupoid.{u, u} G] [is_free_groupoid G] {a b : G} :\n    Nonempty («expr ⟶ » a b) → Nonempty (Path (symgen a) (symgen b)) :=\n  by\n  rintro ⟨p⟩\n  rw [← @weakly_connected_component.eq (generators G), eq_comm, ← free_group.of_injective.eq_iff, ← mul_inv_eq_one]\n  let X := FreeGroup (weakly_connected_component <| generators G)\n  let f : G → X := fun g => FreeGroup.of (weakly_connected_component.mk g)\n  let F : «expr ⥤ » G (CategoryTheory.SingleObj X) := single_obj.difference_functor f\n  change F.map p = ((CategoryTheory.Functor.const G).obj ()).map p\n  congr ; ext\n  rw [functor.const_obj_map, id_as_one, difference_functor_map, mul_inv_eq_one]\n  apply congr_arg FreeGroup.of\n  apply (weakly_connected_component.eq _ _).mpr\n  exact ⟨hom.to_path (Sum.inr e)⟩\n#align path_nonempty_of_hom path_nonempty_of_hom\n\n",
 "loop_of_hom_eq_id":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (e «expr ∈ » wide_subquiver_symmetrify[quiver.wide_subquiver_symmetrify] T a b) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Turning an edge in the spanning tree into a loop gives the indentity loop. -/\ntheorem loop_of_hom_eq_id {a b : generators G} (e) (_ : e ∈ wideSubquiverSymmetrify T a b) :\n    loop_of_hom T (of e) = («expr𝟙») (root' T) :=\n  by\n  rw [loop_of_hom, ← category.assoc, is_iso.comp_inv_eq, category.id_comp]\n  cases H\n  · rw [tree_hom_eq T (path.cons default ⟨Sum.inl e, H⟩), hom_of_path]\n    rfl\n  · rw [tree_hom_eq T (path.cons default ⟨Sum.inr e, H⟩), hom_of_path]\n    simp only [is_iso.inv_hom_id, category.comp_id, category.assoc, tree_hom]\n#align loop_of_hom_eq_id loop_of_hom_eq_id\n\n",
 "ext_functor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-\nCopyright (c) 2021 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn\n-/\n/-- Two functors from a free groupoid to a group are equal when they agree on the generating\nquiver. -/\n@[ext]\ntheorem ext_functor {G} [Groupoid.{v} G] [is_free_groupoid G] {X : Type v} [Group X]\n    (f g : «expr ⥤ » G (CategoryTheory.SingleObj X)) (h : ∀ (a b) (e : «expr ⟶ » a b), f.map (of e) = g.map (of e)) :\n    f = g :=\n  let ⟨_, _, u⟩ := @unique_lift G _ _ X _ fun (a b : generators G) (e : «expr ⟶ » a b) => g.map (of e)\n  trans (u _ h) (u _ fun _ _ _ => rfl).symm\n#align ext_functor ext_functor\n\n"}