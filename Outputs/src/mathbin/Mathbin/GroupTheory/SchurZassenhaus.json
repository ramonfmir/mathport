{"step7":
 "/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\ntheorem step7 : is_commutative N :=\n  by\n  haveI := N.bot_or_nontrivial.resolve_left (step0 h1 h2 h3)\n  haveI : fact (fintype.card N).min_fac.prime := ⟨step4 h1 h2 h3⟩\n  exact\n    ⟨⟨fun g h =>\n        eq_top_iff.mp ((step3 h1 h2 h3 N.center).resolve_left (step6 h1 h2 h3).bot_lt_center.ne') (mem_top h) g⟩⟩\n#align step7 step7\n\n",
 "step6":
 "/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem step6 : is_p_group (fintype.card N).min_fac N :=\n  by\n  haveI : fact (fintype.card N).min_fac.prime := ⟨step4 h1 h2 h3⟩\n  refine' sylow.nonempty.elim fun P => P.2.of_surjective P.1.subtype _\n  rw [← monoid_hom.range_top_iff_surjective, subtype_range]\n  haveI : (P.1.map N.subtype).normal :=\n    normalizer_eq_top.mp (step1 h1 h2 h3 (P.1.map N.subtype).normalizer P.normalizer_sup_eq_top)\n  exact (step3 h1 h2 h3 P.1).resolve_left (step5 h1 h2 h3)\n#align step6 step6\n\n",
 "step5":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem step5 {P : sylow (fintype.card N).min_fac N} : P.1 ≠ «expr⊥» :=\n  haveI : fact (fintype.card N).min_fac.prime := ⟨step4 h1 h2 h3⟩\n  P.ne_bot_of_dvd_card (fintype.card N).min_fac_dvd\n#align step5 step5\n\n",
 "step4":
 "/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem step4 : (fintype.card N).min_fac.prime :=\n  Nat.minFac_prime (N.one_lt_card_iff_ne_bot.mpr (step0 h1 h2 h3)).ne'\n#align step4 step4\n\n",
 "step3":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem step3 (K : subgroup N) [(K.map N.subtype).normal] : K = «expr⊥» ∨ K = «expr⊤» :=\n  by\n  have key := step2 h1 h2 h3 (K.map N.subtype) K.map_subtype_le\n  rw [← map_bot N.subtype] at key\n  conv at key =>\n    congr\n    skip\n    rhs\n    rw [← N.subtype_range, N.subtype.range_eq_map]\n  have inj := map_injective N.subtype_injective\n  rwa [inj.eq_iff, inj.eq_iff] at key\n#align step3 step3\n\n",
 "step2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem step2 (K : subgroup G) [K.normal] (hK : K ≤ N) : K = «expr⊥» ∨ K = N :=\n  by\n  have : function.surjective (quotient_group.mk' K) := Quotient.surjective_Quotient_mk''\n  have h4 := step1 h1 h2 h3\n  contrapose! h4\n  have h5 : fintype.card («expr ⧸ » G K) < fintype.card G :=\n    by\n    rw [← index_eq_card, ← K.index_mul_card]\n    refine' lt_mul_of_one_lt_right (nat.pos_of_ne_zero index_ne_zero_of_finite) (K.one_lt_card_iff_ne_bot.mpr h4.1)\n  have h6 : nat.coprime (fintype.card (N.map (quotient_group.mk' K))) (N.map (quotient_group.mk' K)).index :=\n    by\n    have index_map := N.index_map_eq this (by rwa [quotient_group.ker_mk])\n    have index_pos : 0 < N.index := nat.pos_of_ne_zero index_ne_zero_of_finite\n    rw [index_map]\n    refine' h1.coprime_dvd_left _\n    rw [← Nat.mul_dvd_mul_iff_left index_pos, index_mul_card, ← index_map, index_mul_card]\n    exact K.card_quotient_dvd_card\n  obtain ⟨H, hH⟩ := h2 («expr ⧸ » G K) h5 h6\n  refine' ⟨H.comap (quotient_group.mk' K), _, _⟩\n  · have key : (N.map (quotient_group.mk' K)).comap (quotient_group.mk' K) = N :=\n      by\n      refine' comap_map_eq_self _\n      rwa [quotient_group.ker_mk]\n    rwa [← key, comap_sup_eq, hH.symm.sup_eq_top, comap_top]\n  · rw [← comap_top (quotient_group.mk' K)]\n    intro hH'\n    rw [comap_injective this hH', is_complement'_top_right, map_eq_bot_iff, quotient_group.ker_mk] at hH\n    · exact h4.2 (le_antisymm hK hH)\n#align step2 step2\n\n",
 "step1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem step1 (K : subgroup G) (hK : «expr ⊔ » K N = «expr⊤») : K = «expr⊤» :=\n  by\n  contrapose! h3\n  have h4 : (N.comap K.subtype).index = N.index :=\n    by\n    rw [← N.relindex_top_right, ← hK]\n    exact (relindex_sup_right K N).symm\n  have h5 : fintype.card K < fintype.card G := by\n    rw [← K.index_mul_card]\n    exact lt_mul_of_one_lt_left fintype.card_pos (one_lt_index_of_ne_top h3)\n  have h6 : nat.coprime (fintype.card (N.comap K.subtype)) (N.comap K.subtype).index :=\n    by\n    rw [h4]\n    exact h1.coprime_dvd_left (card_comap_dvd_of_injective N K.subtype subtype.coe_injective)\n  obtain ⟨H, hH⟩ := h2 K h5 h6\n  replace hH : fintype.card (H.map K.subtype) = N.index :=\n    ((set.card_image_of_injective _ subtype.coe_injective).trans\n          (mul_left_injective₀ fintype.card_ne_zero\n            (hH.symm.card_mul.trans (N.comap K.subtype).index_mul_card.symm))).trans\n      h4\n  have h7 : fintype.card N * fintype.card (H.map K.subtype) = fintype.card G := by rw [hH, ← N.index_mul_card, mul_comm]\n  have h8 : (fintype.card N).coprime (fintype.card (H.map K.subtype)) := by rwa [hH]\n  exact ⟨H.map K.subtype, is_complement'_of_coprime h7 h8⟩\n#align step1 step1\n\n",
 "step0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\n@[nolint unused_arguments]\nprivate theorem step0 : N ≠ «expr⊥» := by\n  rintro rfl\n  exact h3 («expr⊤») is_complement'_bot_top\n#align step0 step0\n\n",
 "smul_diff_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem smul_diff_smul' [hH : normal H] (g : «expr ᵐᵒᵖ» G) :\n    diff (MonoidHom.id H) («expr • » g α) («expr • » g β) =\n      ⟨g.unop⁻¹ * (diff (MonoidHom.id H) α β : H) * g.unop,\n        hH.mem_comm ((congr_arg (· ∈ H) (mul_inv_cancel_left _ _)).mpr (SetLike.coe_mem _))⟩ :=\n  by\n  letI := H.fintype_quotient_of_finite_index\n  let ϕ : «expr →* » H H :=\n    { to_fun := fun h =>\n        ⟨g.unop⁻¹ * h * g.unop, hH.mem_comm ((congr_arg (· ∈ H) (mul_inv_cancel_left _ _)).mpr (SetLike.coe_mem _))⟩\n      map_one' := by rw [subtype.ext_iff, coe_mk, coe_one, mul_one, inv_mul_self]\n      map_mul' := fun h₁ h₂ => by\n        rw [subtype.ext_iff, coe_mk, coe_mul, coe_mul, coe_mk, coe_mk, mul_assoc, mul_assoc, mul_assoc, mul_assoc,\n          mul_assoc, mul_inv_cancel_left] }\n  refine'\n    eq.trans\n      (finset.prod_bij' (fun q _ => «expr • » g⁻¹ q) (fun q _ => finset.mem_univ _) (fun q _ => subtype.ext _)\n        (fun q _ => «expr • » g q) (fun q _ => finset.mem_univ _) (fun q _ => smul_inv_smul g q) fun q _ =>\n        inv_smul_smul g q)\n      (map_prod ϕ _ _).symm\n  simp_rw [monoid_hom.id_apply, MonoidHom.coe_mk, coe_mk, smul_apply_eq_smul_apply_inv_smul, smul_eq_mul_unop,\n    mul_inv_rev, mul_assoc]\n#align smul_diff_smul' smul_diff_smul'\n\n",
 "smul_diff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_diff' (h : H) :\n    diff (MonoidHom.id H) α («expr • » (op (h : G)) β) = diff (MonoidHom.id H) α β * h ^ H.index :=\n  by\n  letI := H.fintype_quotient_of_finite_index\n  rw [diff, diff, index_eq_card, ← finset.card_univ, ← finset.prod_const, ← finset.prod_mul_distrib]\n  refine' finset.prod_congr rfl fun q _ => _\n  simp_rw [subtype.ext_iff, monoid_hom.id_apply, coe_mul, coe_mk, mul_assoc, mul_right_inj]\n  rw [smul_apply_eq_smul_apply_inv_smul, smul_eq_mul_unop, unop_op, mul_left_inj, ← subtype.ext_iff,\n    equiv.apply_eq_iff_eq, inv_smul_eq_iff]\n  exact self_eq_mul_right.mpr ((quotient_group.eq_one_iff _).mpr h.2)\n#align smul_diff' smul_diff'\n\n",
 "is_complement'_stabilizer_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_complement'_stabilizer_of_coprime {α : H.quotient_diff} (hH : nat.coprime (nat.card H) H.index) :\n    is_complement' H (stabilizer G α) :=\n  is_complement'_stabilizer α (eq_one_of_smul_eq_one hH α) fun g => exists_smul_eq hH («expr • » g α) α\n#align is_complement'_stabilizer_of_coprime is_complement'_stabilizer_of_coprime\n\n",
 "exists_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_smul_eq (hH : nat.coprime (nat.card H) H.index) (α β : H.quotient_diff) : ∃ h : H, «expr • » h α = β :=\n  Quotient.inductionOn' α\n    (Quotient.inductionOn' β fun β α =>\n      Exists.imp (fun n => quotient.sound')\n        ⟨(pow_coprime hH).symm (diff (MonoidHom.id H) β α),\n          (diff_inv _ _ _).symm.trans\n            (inv_eq_one.mpr\n              ((smul_diff' β α ((pow_coprime hH).symm (diff (MonoidHom.id H) β α))⁻¹).trans\n                (by rw [inv_pow, ← pow_coprime_apply hH, equiv.apply_symm_apply, mul_inv_self])))⟩)\n#align exists_smul_eq exists_smul_eq\n\n",
 "exists_right_complement'_of_coprime_of_fintype":
 "/-- **Schur-Zassenhaus** for normal subgroups:\n  If `H : subgroup G` is normal, and has order coprime to its index, then there exists a\n  subgroup `K` which is a (right) complement of `H`. -/\ntheorem exists_right_complement'_of_coprime_of_fintype [fintype G] {N : subgroup G} [N.normal]\n    (hN : nat.coprime (fintype.card N) N.index) : ∃ H : subgroup G, is_complement' N H :=\n  exists_right_complement'_of_coprime_aux' rfl hN\n#align exists_right_complement'_of_coprime_of_fintype exists_right_complement'_of_coprime_of_fintype\n\n",
 "exists_right_complement'_of_coprime_aux'":
 "/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem exists_right_complement'_of_coprime_aux' [fintype G] (hG : fintype.card G = n) {N : subgroup G}\n    [N.normal] (hN : nat.coprime (fintype.card N) N.index) : ∃ H : subgroup G, is_complement' N H :=\n  by\n  revert G\n  apply nat.strong_induction_on n\n  rintro n ih G _ _ rfl N _ hN\n  refine' not_forall_not.mp fun h3 => _\n  haveI :=\n    schur_zassenhaus_induction.step7 hN\n      (fun G' _ _ hG' => by\n        apply ih _ hG'\n        rfl)\n      h3\n  rw [← nat.card_eq_fintype_card] at hN\n  exact not_exists_of_forall_not h3 (exists_right_complement'_of_coprime_aux hN)\n#align exists_right_complement'_of_coprime_aux' exists_right_complement'_of_coprime_aux'\n\n",
 "exists_right_complement'_of_coprime_aux":
 "/-- Do not use this lemma: It is made obsolete by `exists_right_complement'_of_coprime` -/\nprivate theorem exists_right_complement'_of_coprime_aux (hH : nat.coprime (nat.card H) H.index) :\n    ∃ K : subgroup G, is_complement' H K :=\n  instNonempty.elim fun α => ⟨stabilizer G α, is_complement'_stabilizer_of_coprime hH⟩\n#align exists_right_complement'_of_coprime_aux exists_right_complement'_of_coprime_aux\n\n",
 "exists_right_complement'_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Schur-Zassenhaus** for normal subgroups:\n  If `H : subgroup G` is normal, and has order coprime to its index, then there exists a\n  subgroup `K` which is a (right) complement of `H`. -/\ntheorem exists_right_complement'_of_coprime {N : subgroup G} [N.normal] (hN : nat.coprime (nat.card N) N.index) :\n    ∃ H : subgroup G, is_complement' N H := by\n  by_cases hN1 : nat.card N = 0\n  · rw [hN1, nat.coprime_zero_left, index_eq_one] at hN\n    rw [hN]\n    exact ⟨«expr⊥», is_complement'_top_bot⟩\n  by_cases hN2 : N.index = 0\n  · rw [hN2, nat.coprime_zero_right] at hN\n    haveI := (cardinal.to_nat_eq_one_iff_unique.mp hN).1\n    rw [N.eq_bot_of_subsingleton]\n    exact ⟨«expr⊤», is_complement'_bot_top⟩\n  have hN3 : nat.card G ≠ 0 := by\n    rw [← N.card_mul_index]\n    exact mul_ne_zero hN1 hN2\n  haveI := (cardinal.lt_aleph_0_iff_fintype.mp (lt_of_not_ge (mt cardinal.to_nat_apply_of_aleph_0_le hN3))).some\n  rw [nat.card_eq_fintype_card] at hN\n  exact exists_right_complement'_of_coprime_of_fintype hN\n#align exists_right_complement'_of_coprime exists_right_complement'_of_coprime\n\n",
 "exists_left_complement'_of_coprime_of_fintype":
 "/-- **Schur-Zassenhaus** for normal subgroups:\n  If `H : subgroup G` is normal, and has order coprime to its index, then there exists a\n  subgroup `K` which is a (left) complement of `H`. -/\ntheorem exists_left_complement'_of_coprime_of_fintype [fintype G] {N : subgroup G} [N.normal]\n    (hN : nat.coprime (fintype.card N) N.index) : ∃ H : subgroup G, is_complement' H N :=\n  Exists.imp (fun _ => is_complement'.symm) (exists_right_complement'_of_coprime_of_fintype hN)\n#align exists_left_complement'_of_coprime_of_fintype exists_left_complement'_of_coprime_of_fintype\n\n",
 "exists_left_complement'_of_coprime":
 "/-- **Schur-Zassenhaus** for normal subgroups:\n  If `H : subgroup G` is normal, and has order coprime to its index, then there exists a\n  subgroup `K` which is a (left) complement of `H`. -/\ntheorem exists_left_complement'_of_coprime {N : subgroup G} [N.normal] (hN : nat.coprime (nat.card N) N.index) :\n    ∃ H : subgroup G, is_complement' H N :=\n  Exists.imp (fun _ => is_complement'.symm) (exists_right_complement'_of_coprime hN)\n#align exists_left_complement'_of_coprime exists_left_complement'_of_coprime\n\n",
 "eq_one_of_smul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem eq_one_of_smul_eq_one (hH : nat.coprime (nat.card H) H.index) (α : H.quotient_diff) (h : H) :\n    «expr • » h α = α → h = 1 :=\n  Quotient.inductionOn' α fun α hα =>\n    (pow_coprime hH).injective <|\n      calc\n        h ^ H.index = diff (MonoidHom.id H) («expr • » (op ((h⁻¹ : H) : G)) α) α := by\n          rw [← diff_inv, smul_diff', diff_self, one_mul, inv_pow, inv_inv]\n        _ = 1 ^ H.index := (quotient.exact' hα).trans (one_pow H.index).symm\n        \n#align eq_one_of_smul_eq_one eq_one_of_smul_eq_one\n\n"}