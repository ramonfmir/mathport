{"rank_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Group.rank_spec /-\n@[to_additive]\ntheorem Group.rank_spec [h : Group.Fg G] :\n    ∃ S : Finset G, S.card = Group.rank G ∧ Subgroup.closure (S : Set G) = «expr⊤» :=\n  @nat.find_spec _ (Classical.decPred _) (Group.fg_iff'.mp h)\n#align group.rank_spec Group.rank_spec\n#align add_group.rank_spec AddGroup.rank_spec\n-/\n\n",
 "rank_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Group.rank_range_le /-\n@[to_additive]\ntheorem Group.rank_range_le [Group.Fg G] {f : «expr →* » G G'} : Group.rank f.range ≤ Group.rank G :=\n  Group.rank_le_of_surjective f.range_restrict f.range_restrict_surjective\n#align group.rank_range_le Group.rank_range_le\n#align add_group.rank_range_le AddGroup.rank_range_le\n-/\n\n",
 "rank_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Group.rank_le_of_surjective /-\n@[to_additive]\ntheorem Group.rank_le_of_surjective [Group.Fg G] [Group.Fg G'] (f : «expr →* » G G') (hf : function.surjective f) :\n    Group.rank G' ≤ Group.rank G := by\n  classical\n    obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n    trans (S.image f).card\n    · apply Group.rank_le\n      rw [Finset.coe_image, ← MonoidHom.map_closure, hS2, Subgroup.map_top_of_surjective f hf]\n    · exact finset.card_image_le.trans_eq hS1\n#align group.rank_le_of_surjective Group.rank_le_of_surjective\n#align add_group.rank_le_of_surjective AddGroup.rank_le_of_surjective\n-/\n\n",
 "rank_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Group.rank_le /-\n@[to_additive]\ntheorem Group.rank_le [h : Group.Fg G] {S : Finset G} (hS : Subgroup.closure (S : Set G) = «expr⊤») :\n    Group.rank G ≤ S.card :=\n  @Nat.find_le _ _ (Classical.decPred _) (Group.fg_iff'.mp h) ⟨S, rfl, hS⟩\n#align group.rank_le Group.rank_le\n#align add_group.rank_le AddGroup.rank_le\n-/\n\n",
 "rank_congr":
 "@[to_additive]\ntheorem rank_congr {H K : Subgroup G} [Group.Fg H] [Group.Fg K] (h : H = K) : Group.rank H = Group.rank K := by subst h\n#align rank_congr rank_congr\n\n",
 "rank_closure_finset_le_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem rank_closure_finset_le_card (s : Finset G) : Group.rank (closure (s : Set G)) ≤ s.card := by\n  classical\n    let t : Finset (closure (s : Set G)) := s.preimage coe (subtype.coe_injective.inj_on _)\n    have ht : closure (t : Set (closure (s : Set G))) = «expr⊤» :=\n      by\n      rw [Finset.coe_preimage]\n      exact closure_preimage_eq_top s\n    apply (Group.rank_le (closure (s : Set G)) ht).trans\n    rw [← Finset.card_image_of_injOn, Finset.image_preimage]\n    · apply Finset.card_filter_le\n    · apply subtype.coe_injective.inj_on\n#align rank_closure_finset_le_card rank_closure_finset_le_card\n\n",
 "rank_closure_finite_le_nat_card":
 "@[to_additive]\ntheorem rank_closure_finite_le_nat_card (s : Set G) [Finite s] : Group.rank (closure s) ≤ Nat.card s :=\n  by\n  haveI := Fintype.ofFinite s\n  rw [Nat.card_eq_fintype_card, ← s.to_finset_card, ← rank_congr (congr_arg _ s.coe_to_finset)]\n  exact rank_closure_finset_le_card s.to_finset\n#align rank_closure_finite_le_nat_card rank_closure_finite_le_nat_card\n\n",
 "powers_fg":
 "#print Submonoid.powers_fg /-\n@[to_additive AddSubmonoid.multiples_fg]\ntheorem Submonoid.powers_fg (r : M) : (Submonoid.powers r).fg :=\n  ⟨{r}, (Finset.coe_singleton r).symm ▸ (Submonoid.powers_eq_closure r).symm⟩\n#align submonoid.powers_fg Submonoid.powers_fg\n#align add_submonoid.multiples_fg AddSubmonoid.multiples_fg\n-/\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Submonoid.Fg.map_injective /-\n@[to_additive]\ntheorem Submonoid.Fg.map_injective {M' : Type _} [Monoid M'] {P : Submonoid M} (e : «expr →* » M M')\n    (he : function.injective e) (h : (P.map e).fg) : P.fg :=\n  by\n  obtain ⟨s, hs⟩ := h\n  use s.preimage e (he.inj_on _)\n  apply Submonoid.map_injective_of_injective he\n  rw [← hs, e.map_mclosure, Finset.coe_preimage]\n  congr\n  rw [Set.image_preimage_eq_iff, ← e.coe_mrange, ← Submonoid.closure_le, hs, e.mrange_eq_map]\n  exact Submonoid.monotone_map le_top\n#align submonoid.fg.map_injective Submonoid.Fg.map_injective\n#align add_submonoid.fg.map_injective AddSubmonoid.Fg.map_injective\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Submonoid.Fg.map /-\n@[to_additive]\ntheorem Submonoid.Fg.map {M' : Type _} [Monoid M'] {P : Submonoid M} (h : P.fg) (e : «expr →* » M M') : (P.map e).fg :=\n  by\n  classical\n    obtain ⟨s, rfl⟩ := h\n    exact ⟨s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]⟩\n#align submonoid.fg.map Submonoid.Fg.map\n#align add_submonoid.fg.map AddSubmonoid.Fg.map\n-/\n\n",
 "iff_add_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print GroupFg.iff_add_fg /-\ntheorem GroupFg.iff_add_fg : Group.Fg G ↔ AddGroup.Fg (Additive G) :=\n  ⟨fun h => ⟨(Subgroup.fg_iff_add_fg («expr⊤»)).1 h.out⟩, fun h => ⟨(Subgroup.fg_iff_add_fg («expr⊤»)).2 h.out⟩⟩\n#align group_fg.iff_add_fg GroupFg.iff_add_fg\n-/\n\n",
 "fg_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print Group.fg_of_surjective /-\n@[to_additive]\ntheorem Group.fg_of_surjective {G' : Type _} [Group G'] [hG : Group.Fg G] {f : «expr →* » G G'}\n    (hf : function.surjective f) : Group.Fg G' :=\n  Group.fg_iff_monoid_fg.mpr <| @Monoid.fg_of_surjective G _ G' _ (Group.fg_iff_monoid_fg.mp hG) f hf\n#align group.fg_of_surjective Group.fg_of_surjective\n#align add_group.fg_of_surjective AddGroup.fg_of_surjective\n-/\n\n",
 "fg_iff_submonoid_fg":
 "#print Subgroup.fg_iff_submonoid_fg /-\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\n@[to_additive AddSubgroup.fg_iff_addSubmonoid_fg\n      \"An additive subgroup is finitely generated if\\nand only if it is finitely generated as an additive submonoid.\"]\ntheorem Subgroup.fg_iff_submonoid_fg (P : Subgroup G) : P.fg ↔ P.to_submonoid.fg :=\n  by\n  constructor\n  · rintro ⟨S, rfl⟩\n    rw [Submonoid.fg_iff]\n    refine' ⟨S ∪ S⁻¹, _, S.finite_to_set.union S.finite_to_set.inv⟩\n    exact (Subgroup.closure_toSubmonoid _).symm\n  · rintro ⟨S, hS⟩\n    refine' ⟨S, le_antisymm _ _⟩\n    · rw [Subgroup.closure_le, ← Subgroup.coe_toSubmonoid, ← hS]\n      exact Submonoid.subset_closure\n    · rw [← Subgroup.toSubmonoid_le, ← hS, Submonoid.closure_le]\n      exact Subgroup.subset_closure\n#align subgroup.fg_iff_submonoid_fg Subgroup.fg_iff_submonoid_fg\n#align add_subgroup.fg_iff_add_submonoid.fg AddSubgroup.fg_iff_addSubmonoid_fg\n-/\n\n",
 "fg_iff_mul_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AddGroup.fg_iff_mul_fg /-\ntheorem AddGroup.fg_iff_mul_fg : AddGroup.Fg H ↔ Group.Fg (Multiplicative H) :=\n  ⟨fun h => ⟨(AddSubgroup.fg_iff_mul_fg («expr⊤»)).1 h.out⟩, fun h => ⟨(AddSubgroup.fg_iff_mul_fg («expr⊤»)).2 h.out⟩⟩\n#align add_group.fg_iff_mul_fg AddGroup.fg_iff_mul_fg\n-/\n\n",
 "fg_iff_monoid_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Group.fg_iff_monoid_fg /-\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\n@[to_additive AddGroup.fg_iff_addMonoid_fg\n      \"An additive group is finitely generated if and only\\nif it is finitely generated as an additive monoid.\"]\ntheorem Group.fg_iff_monoid_fg : Group.Fg G ↔ Monoid.Fg G :=\n  ⟨fun h => Monoid.fg_def.2 <| (Subgroup.fg_iff_submonoid_fg («expr⊤»)).1 (Group.fg_def.1 h), fun h =>\n    Group.fg_def.2 <| (Subgroup.fg_iff_submonoid_fg («expr⊤»)).2 (Monoid.fg_def.1 h)⟩\n#align group.fg_iff_monoid.fg Group.fg_iff_monoid_fg\n#align add_group.fg_iff_add_monoid.fg AddGroup.fg_iff_addMonoid_fg\n-/\n\n",
 "fg_iff_add_fg":
 "#print Subgroup.fg_iff_add_fg /-\ntheorem Subgroup.fg_iff_add_fg (P : Subgroup G) : P.fg ↔ P.to_add_subgroup.fg :=\n  by\n  rw [Subgroup.fg_iff_submonoid_fg, AddSubgroup.fg_iff_addSubmonoid_fg]\n  exact (Subgroup.toSubmonoid P).fg_iff_add_fg\n#align subgroup.fg_iff_add_fg Subgroup.fg_iff_add_fg\n-/\n\n",
 "fg_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Group.fg_iff' /-\n@[to_additive]\ntheorem Group.fg_iff' : Group.Fg G ↔ ∃ (n : _)(S : Finset G), S.card = n ∧ Subgroup.closure (S : Set G) = «expr⊤» :=\n  Group.fg_def.trans ⟨fun ⟨S, hS⟩ => ⟨S.card, S, rfl, hS⟩, fun ⟨n, S, hn, hS⟩ => ⟨S, hS⟩⟩\n#align group.fg_iff' Group.fg_iff'\n#align add_group.fg_iff' AddGroup.fg_iff'\n-/\n\n",
 "fg_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Group.fg_iff /-\n/-- An equivalent expression of `group.fg` in terms of `set.finite` instead of `finset`. -/\n@[to_additive \"An equivalent expression of `add_group.fg` in terms of `set.finite` instead of\\n`finset`.\"]\ntheorem Group.fg_iff : Group.Fg G ↔ ∃ S : Set G, Subgroup.closure S = («expr⊤» : Subgroup G) ∧ S.finite :=\n  ⟨fun h => (Subgroup.fg_iff («expr⊤»)).1 h.out, fun h => ⟨(Subgroup.fg_iff («expr⊤»)).2 h⟩⟩\n#align group.fg_iff Group.fg_iff\n#align add_group.fg_iff AddGroup.fg_iff\n-/\n\n",
 "fg_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AddGroup.fg_def /-\ntheorem AddGroup.fg_def : AddGroup.Fg H ↔ («expr⊤» : AddSubgroup H).fg :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align add_group.fg_def AddGroup.fg_def\n-/\n\n"}