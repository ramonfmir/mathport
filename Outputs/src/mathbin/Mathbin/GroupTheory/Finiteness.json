{"rank_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem group.rank_spec [h : group.fg G] :\n    ∃ S : Finset G, S.card = group.rank G ∧ subgroup.closure (S : set G) = «expr⊤» :=\n  @nat.find_spec _ (classical.dec_pred _) (group.fg_iff'.mp h)\n#align group.rank_spec group.rank_spec\n\n",
 "rank_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem group.rank_range_le [group.fg G] {f : «expr →* » G G'} : group.rank f.range ≤ group.rank G :=\n  group.rank_le_of_surjective f.range_restrict f.range_restrict_surjective\n#align group.rank_range_le group.rank_range_le\n\n",
 "rank_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem group.rank_le_of_surjective [group.fg G] [group.fg G'] (f : «expr →* » G G') (hf : function.surjective f) :\n    group.rank G' ≤ group.rank G := by\n  classical\n    obtain ⟨S, hS1, hS2⟩ := group.rank_spec G\n    trans (S.image f).card\n    · apply group.rank_le\n      rw [Finset.coe_image, ← monoid_hom.map_closure, hS2, subgroup.map_top_of_surjective f hf]\n    · exact finset.card_image_le.trans_eq hS1\n#align group.rank_le_of_surjective group.rank_le_of_surjective\n\n",
 "rank_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem group.rank_le [h : group.fg G] {S : Finset G} (hS : subgroup.closure (S : set G) = «expr⊤») :\n    group.rank G ≤ S.card :=\n  @Nat.find_le _ _ (classical.dec_pred _) (group.fg_iff'.mp h) ⟨S, rfl, hS⟩\n#align group.rank_le group.rank_le\n\n",
 "rank_congr":
 "@[to_additive]\ntheorem rank_congr {H K : subgroup G} [group.fg H] [group.fg K] (h : H = K) : group.rank H = group.rank K := by subst h\n#align rank_congr rank_congr\n\n",
 "rank_closure_finset_le_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem rank_closure_finset_le_card (s : Finset G) : group.rank (closure (s : set G)) ≤ s.card := by\n  classical\n    let t : Finset (closure (s : set G)) := s.preimage coe (subtype.coe_injective.inj_on _)\n    have ht : closure (t : set (closure (s : set G))) = «expr⊤» :=\n      by\n      rw [finset.coe_preimage]\n      exact closure_preimage_eq_top s\n    apply (group.rank_le (closure (s : set G)) ht).trans\n    rw [← finset.card_image_of_inj_on, finset.image_preimage]\n    · apply finset.card_filter_le\n    · apply subtype.coe_injective.inj_on\n#align rank_closure_finset_le_card rank_closure_finset_le_card\n\n",
 "rank_closure_finite_le_nat_card":
 "@[to_additive]\ntheorem rank_closure_finite_le_nat_card (s : set G) [Finite s] : group.rank (closure s) ≤ nat.card s :=\n  by\n  haveI := fintype.of_finite s\n  rw [nat.card_eq_fintype_card, ← s.to_finset_card, ← rank_congr (congr_arg _ s.coe_to_finset)]\n  exact rank_closure_finset_le_card s.to_finset\n#align rank_closure_finite_le_nat_card rank_closure_finite_le_nat_card\n\n",
 "powers_fg":
 "@[to_additive add_submonoid.multiples_fg]\ntheorem submonoid.powers_fg (r : M) : (submonoid.powers r).fg :=\n  ⟨{r}, (Finset.coe_singleton r).symm ▸ (submonoid.powers_eq_closure r).symm⟩\n#align submonoid.powers_fg submonoid.powers_fg\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem submonoid.fg.map_injective {M' : Type _} [monoid M'] {P : Submonoid M} (e : «expr →* » M M')\n    (he : function.injective e) (h : (P.map e).fg) : P.fg :=\n  by\n  obtain ⟨s, hs⟩ := h\n  use s.preimage e (he.inj_on _)\n  apply Submonoid.map_injective_of_injective he\n  rw [← hs, e.map_mclosure, finset.coe_preimage]\n  congr\n  rw [Set.image_preimage_eq_iff, ← e.coe_mrange, ← Submonoid.closure_le, hs, e.mrange_eq_map]\n  exact Submonoid.monotone_map le_top\n#align submonoid.fg.map_injective submonoid.fg.map_injective\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem submonoid.fg.map {M' : Type _} [monoid M'] {P : Submonoid M} (h : P.fg) (e : «expr →* » M M') : (P.map e).fg :=\n  by\n  classical\n    obtain ⟨s, rfl⟩ := h\n    exact ⟨s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]⟩\n#align submonoid.fg.map submonoid.fg.map\n\n",
 "iff_add_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem group_fg.iff_add_fg : group.fg G ↔ add_group.fg (Additive G) :=\n  ⟨fun h => ⟨(subgroup.fg_iff_add_fg («expr⊤»)).1 h.out⟩, fun h => ⟨(subgroup.fg_iff_add_fg («expr⊤»)).2 h.out⟩⟩\n#align group_fg.iff_add_fg group_fg.iff_add_fg\n\n",
 "fg_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem group.fg_of_surjective {G' : Type _} [group G'] [hG : group.fg G] {f : «expr →* » G G'}\n    (hf : function.surjective f) : group.fg G' :=\n  group.fg_iff_monoid.fg.mpr <| @monoid.fg_of_surjective G _ G' _ (group.fg_iff_monoid.fg.mp hG) f hf\n#align group.fg_of_surjective group.fg_of_surjective\n\n",
 "fg_iff_submonoid_fg":
 "/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\n@[to_additive add_subgroup.fg_iff_add_submonoid.fg\n      \"An additive subgroup is finitely generated if\\nand only if it is finitely generated as an additive submonoid.\"]\ntheorem subgroup.fg_iff_submonoid_fg (P : subgroup G) : P.fg ↔ P.to_submonoid.fg :=\n  by\n  constructor\n  · rintro ⟨S, rfl⟩\n    rw [submonoid.fg_iff]\n    refine' ⟨S ∪ S⁻¹, _, S.finite_to_set.union S.finite_to_set.inv⟩\n    exact (subgroup.closure_to_submonoid _).symm\n  · rintro ⟨S, hS⟩\n    refine' ⟨S, le_antisymm _ _⟩\n    · rw [subgroup.closure_le, ← subgroup.coe_to_submonoid, ← hS]\n      exact Submonoid.subset_closure\n    · rw [← subgroup.to_submonoid_le, ← hS, Submonoid.closure_le]\n      exact subgroup.subset_closure\n#align subgroup.fg_iff_submonoid_fg subgroup.fg_iff_submonoid_fg\n\n",
 "fg_iff_mul_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem add_group.fg_iff_mul_fg : add_group.fg H ↔ group.fg (Multiplicative H) :=\n  ⟨fun h => ⟨(add_subgroup.fg_iff_mul_fg («expr⊤»)).1 h.out⟩, fun h => ⟨(add_subgroup.fg_iff_mul_fg («expr⊤»)).2 h.out⟩⟩\n#align add_group.fg_iff_mul_fg add_group.fg_iff_mul_fg\n\n",
 "fg_iff_add_fg":
 "theorem subgroup.fg_iff_add_fg (P : subgroup G) : P.fg ↔ P.to_add_subgroup.fg :=\n  by\n  rw [subgroup.fg_iff_submonoid_fg, add_subgroup.fg_iff_add_submonoid.fg]\n  exact (subgroup.to_submonoid P).fg_iff_add_fg\n#align subgroup.fg_iff_add_fg subgroup.fg_iff_add_fg\n\n",
 "fg_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem group.fg_iff' : group.fg G ↔ ∃ (n : _)(S : Finset G), S.card = n ∧ subgroup.closure (S : set G) = «expr⊤» :=\n  group.fg_def.trans ⟨fun ⟨S, hS⟩ => ⟨S.card, S, rfl, hS⟩, fun ⟨n, S, hn, hS⟩ => ⟨S, hS⟩⟩\n#align group.fg_iff' group.fg_iff'\n\n",
 "fg_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- An equivalent expression of `group.fg` in terms of `set.finite` instead of `finset`. -/\n@[to_additive \"An equivalent expression of `add_group.fg` in terms of `set.finite` instead of\\n`finset`.\"]\ntheorem group.fg_iff : group.fg G ↔ ∃ S : set G, subgroup.closure S = («expr⊤» : subgroup G) ∧ S.finite :=\n  ⟨fun h => (subgroup.fg_iff («expr⊤»)).1 h.out, fun h => ⟨(subgroup.fg_iff («expr⊤»)).2 h⟩⟩\n#align group.fg_iff group.fg_iff\n\n",
 "fg_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem add_group.fg_def : add_group.fg H ↔ («expr⊤» : add_subgroup H).fg :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align add_group.fg_def add_group.fg_def\n\n",
 "fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\n@[to_additive add_group.fg_iff_add_monoid.fg\n      \"An additive group is finitely generated if and only\\nif it is finitely generated as an additive monoid.\"]\ntheorem group.fg_iff_monoid.fg : group.fg G ↔ monoid.fg G :=\n  ⟨fun h => monoid.fg_def.2 <| (subgroup.fg_iff_submonoid_fg («expr⊤»)).1 (group.fg_def.1 h), fun h =>\n    group.fg_def.2 <| (subgroup.fg_iff_submonoid_fg («expr⊤»)).2 (monoid.fg_def.1 h)⟩\n#align group.fg_iff_monoid.fg group.fg_iff_monoid.fg\n\n"}