{"one_mem_commutator_set":
 "theorem one_mem_commutator_set : (1 : G) ∈ commutator_set G :=\n  ⟨1, 1, commutator_element_self 1⟩\n#align one_mem_commutator_set one_mem_commutator_set\n\n",
 "mem_commutator_set_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem mem_commutator_set_iff : g ∈ commutator_set G ↔ ∃ g₁ g₂ : G, «expr⁅ , ⁆» g₁ g₂ = g :=\n  iff.rfl\n#align mem_commutator_set_iff mem_commutator_set_iff\n\n",
 "map_commutator_element":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem map_commutator_element : (f («expr⁅ , ⁆» g₁ g₂) : G') = «expr⁅ , ⁆» (f g₁) (f g₂) := by\n  simp_rw [commutatorElement_def, map_mul f, map_inv f]\n#align map_commutator_element map_commutator_element\n\n",
 "map_commutator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem map_commutator (f : «expr →* » G G') : map f («expr⁅ , ⁆» H₁ H₂) = «expr⁅ , ⁆» (map f H₁) (map f H₂) :=\n  by\n  simp_rw [le_antisymm_iff, map_le_iff_le_comap, commutator_le, mem_comap, map_commutator_element]\n  constructor\n  · intro p hp q hq\n    exact commutator_mem_commutator (mem_map_of_mem _ hp) (mem_map_of_mem _ hq)\n  · rintro _ ⟨p, hp, rfl⟩ _ ⟨q, hq, rfl⟩\n    rw [← map_commutator_element]\n    exact mem_map_of_mem _ (commutator_mem_commutator hp hq)\n#align map_commutator map_commutator\n\n",
 "conjugate_commutator_element":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem conjugate_commutator_element : g₃ * «expr⁅ , ⁆» g₁ g₂ * g₃⁻¹ = «expr⁅ , ⁆» (g₃ * g₁ * g₃⁻¹) (g₃ * g₂ * g₃⁻¹) :=\n  map_commutator_element (MulAut.conj g₃).to_monoid_hom g₁ g₂\n#align conjugate_commutator_element conjugate_commutator_element\n\n",
 "commutator_set_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_set_def : commutator_set G = { g | ∃ g₁ g₂ : G, «expr⁅ , ⁆» g₁ g₂ = g } :=\n  rfl\n#align commutator_set_def commutator_set_def\n\n",
 "commutator_prod_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_prod_prod (K₁ K₂ : subgroup G') :\n    «expr⁅ , ⁆» (H₁.prod K₁) (H₂.prod K₂) = («expr⁅ , ⁆» H₁ H₂).prod («expr⁅ , ⁆» K₁ K₂) :=\n  by\n  apply le_antisymm\n  · rw [commutator_le]\n    rintro ⟨p₁, p₂⟩ ⟨hp₁, hp₂⟩ ⟨q₁, q₂⟩ ⟨hq₁, hq₂⟩\n    exact ⟨commutator_mem_commutator hp₁ hq₁, commutator_mem_commutator hp₂ hq₂⟩\n  · rw [prod_le_iff]\n    constructor <;>\n      · rw [map_commutator]\n        apply commutator_mono <;>\n          simp [le_prod_iff, map_map, MonoidHom.fst_comp_inl, MonoidHom.snd_comp_inl, MonoidHom.fst_comp_inr,\n            MonoidHom.snd_comp_inr]\n#align commutator_prod_prod commutator_prod_prod\n\n",
 "commutator_pi_pi_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- The commutator of a finite direct product is contained in the direct product of the commutators.\n-/\ntheorem commutator_pi_pi_of_finite {η : Type _} [Finite η] {Gs : η → Type _} [∀ i, group (Gs i)]\n    (H K : ∀ i, subgroup (Gs i)) :\n    «expr⁅ , ⁆» (subgroup.pi Set.univ H) (subgroup.pi Set.univ K) =\n      subgroup.pi Set.univ fun i => «expr⁅ , ⁆» (H i) (K i) :=\n  by\n  classical\n    apply le_antisymm (commutator_pi_pi_le H K)\n    · rw [pi_le_iff]\n      intro i hi\n      rw [map_commutator]\n      apply commutator_mono <;>\n        · rw [le_pi_iff]\n          intro j hj\n          rintro _ ⟨_, ⟨x, hx, rfl⟩, rfl⟩\n          by_cases h : j = i\n          · subst h\n            simpa using hx\n          · simp [h, one_mem]\n#align commutator_pi_pi_of_finite commutator_pi_pi_of_finite\n\n",
 "commutator_pi_pi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-- The commutator of direct product is contained in the direct product of the commutators.\n\nSee `commutator_pi_pi_of_finite` for equality given `fintype η`.\n-/\ntheorem commutator_pi_pi_le {η : Type _} {Gs : η → Type _} [∀ i, group (Gs i)] (H K : ∀ i, subgroup (Gs i)) :\n    «expr⁅ , ⁆» (subgroup.pi Set.univ H) (subgroup.pi Set.univ K) ≤\n      subgroup.pi Set.univ fun i => «expr⁅ , ⁆» (H i) (K i) :=\n  commutator_le.mpr fun p hp q hq i hi => commutator_mem_commutator (hp i hi) (hq i hi)\n#align commutator_pi_pi_le commutator_pi_pi_le\n\n",
 "commutator_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_mono (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) : «expr⁅ , ⁆» H₁ H₂ ≤ «expr⁅ , ⁆» K₁ K₂ :=\n  commutator_le.mpr fun g₁ hg₁ g₂ hg₂ => commutator_mem_commutator (h₁ hg₁) (h₂ hg₂)\n#align commutator_mono commutator_mono\n\n",
 "commutator_mem_commutator_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_mem_commutator_set : «expr⁅ , ⁆» g₁ g₂ ∈ commutator_set G :=\n  ⟨g₁, g₂, rfl⟩\n#align commutator_mem_commutator_set commutator_mem_commutator_set\n\n",
 "commutator_mem_commutator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_mem_commutator (h₁ : g₁ ∈ H₁) (h₂ : g₂ ∈ H₂) : «expr⁅ , ⁆» g₁ g₂ ∈ «expr⁅ , ⁆» H₁ H₂ :=\n  subset_closure ⟨g₁, h₁, g₂, h₂, rfl⟩\n#align commutator_mem_commutator commutator_mem_commutator\n\n",
 "commutator_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_le_right [h : H₂.normal] : «expr⁅ , ⁆» H₁ H₂ ≤ H₂ :=\n  commutator_le.mpr fun g₁ h₁ g₂ h₂ => H₂.mul_mem (h.conj_mem g₂ h₂ g₁) (H₂.inv_mem h₂)\n#align commutator_le_right commutator_le_right\n\n",
 "commutator_le_map_commutator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_le_map_commutator {f : «expr →* » G G'} {K₁ K₂ : subgroup G'} (h₁ : K₁ ≤ H₁.map f)\n    (h₂ : K₂ ≤ H₂.map f) : «expr⁅ , ⁆» K₁ K₂ ≤ («expr⁅ , ⁆» H₁ H₂).map f :=\n  (commutator_mono h₁ h₂).trans (ge_of_eq (map_commutator H₁ H₂ f))\n#align commutator_le_map_commutator commutator_le_map_commutator\n\n",
 "commutator_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_le_left [H₁.normal] : «expr⁅ , ⁆» H₁ H₂ ≤ H₁ :=\n  commutator_comm H₂ H₁ ▸ commutator_le_right H₂ H₁\n#align commutator_le_left commutator_le_left\n\n",
 "commutator_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem commutator_le_inf [normal H₁] [normal H₂] : «expr⁅ , ⁆» H₁ H₂ ≤ «expr ⊓ » H₁ H₂ :=\n  le_inf (commutator_le_left H₁ H₂) (commutator_le_right H₁ H₂)\n#align commutator_le_inf commutator_le_inf\n\n",
 "commutator_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_le : «expr⁅ , ⁆» H₁ H₂ ≤ H₃ ↔ ∀ g₁ ∈ H₁, ∀ g₂ ∈ H₂, «expr⁅ , ⁆» g₁ g₂ ∈ H₃ :=\n  H₃.closure_le.trans ⟨fun h a b c d => h ⟨a, b, c, d, rfl⟩, fun h g ⟨a, b, c, d, h_eq⟩ => h_eq ▸ h a b c d⟩\n#align commutator_le commutator_le\n\n",
 "commutator_eq_bot_iff_le_centralizer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem commutator_eq_bot_iff_le_centralizer : «expr⁅ , ⁆» H₁ H₂ = «expr⊥» ↔ H₁ ≤ H₂.centralizer :=\n  by\n  rw [eq_bot_iff, commutator_le]\n  refine' forall_congr' fun p => forall_congr' fun hp => forall_congr' fun q => forall_congr' fun hq => _\n  rw [mem_bot, commutator_element_eq_one_iff_mul_comm, eq_comm]\n#align commutator_eq_bot_iff_le_centralizer commutator_eq_bot_iff_le_centralizer\n\n",
 "commutator_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commute.commutator_eq (h : Commute g₁ g₂) : «expr⁅ , ⁆» g₁ g₂ = 1 :=\n  commutator_element_eq_one_iff_commute.mpr h\n#align commute.commutator_eq commute.commutator_eq\n\n",
 "commutator_element_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem commutator_element_self : «expr⁅ , ⁆» g g = 1 :=\n  (Commute.refl g).commutator_eq\n#align commutator_element_self commutator_element_self\n\n",
 "commutator_element_one_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem commutator_element_one_right : «expr⁅ , ⁆» g (1 : G) = 1 :=\n  (Commute.one_right g).commutator_eq\n#align commutator_element_one_right commutator_element_one_right\n\n",
 "commutator_element_one_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem commutator_element_one_left : «expr⁅ , ⁆» (1 : G) g = 1 :=\n  (Commute.one_left g).commutator_eq\n#align commutator_element_one_left commutator_element_one_left\n\n",
 "commutator_element_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n@[simp]\ntheorem commutator_element_inv : («expr⁅ , ⁆» g₁ g₂)⁻¹ = «expr⁅ , ⁆» g₂ g₁ := by\n  simp_rw [commutatorElement_def, mul_inv_rev, inv_inv, mul_assoc]\n#align commutator_element_inv commutator_element_inv\n\n",
 "commutator_element_eq_one_iff_mul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/-\nCopyright (c) 2021 Jordan Brown, Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jordan Brown, Thomas Browning, Patrick Lutz\n-/\ntheorem commutator_element_eq_one_iff_mul_comm : «expr⁅ , ⁆» g₁ g₂ = 1 ↔ g₁ * g₂ = g₂ * g₁ := by\n  rw [commutatorElement_def, mul_inv_eq_one, mul_inv_eq_iff_eq_mul]\n#align commutator_element_eq_one_iff_mul_comm commutator_element_eq_one_iff_mul_comm\n\n",
 "commutator_element_eq_one_iff_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_element_eq_one_iff_commute : «expr⁅ , ⁆» g₁ g₂ = 1 ↔ Commute g₁ g₂ :=\n  commutator_element_eq_one_iff_mul_comm\n#align commutator_element_eq_one_iff_commute commutator_element_eq_one_iff_commute\n\n",
 "commutator_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_def' [H₁.normal] [H₂.normal] :\n    «expr⁅ , ⁆» H₁ H₂ = normal_closure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, «expr⁅ , ⁆» g₁ g₂ = g } :=\n  le_antisymm closure_le_normal_closure (normal_closure_le_normal subset_closure)\n#align commutator_def' commutator_def'\n\n",
 "commutator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_def (H₁ H₂ : subgroup G) :\n    «expr⁅ , ⁆» H₁ H₂ = closure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, «expr⁅ , ⁆» g₁ g₂ = g } :=\n  rfl\n#align commutator_def commutator_def\n\n",
 "commutator_commutator_eq_bot_of_rotate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem commutator_commutator_eq_bot_of_rotate (h1 : «expr⁅ , ⁆» («expr⁅ , ⁆» H₂ H₃) H₁ = «expr⊥»)\n    (h2 : «expr⁅ , ⁆» («expr⁅ , ⁆» H₃ H₁) H₂ = «expr⊥») : «expr⁅ , ⁆» («expr⁅ , ⁆» H₁ H₂) H₃ = «expr⊥» :=\n  by\n  simp_rw [commutator_eq_bot_iff_le_centralizer, commutator_le, mem_centralizer_iff_commutator_eq_one, ←\n    commutatorElement_def] at h1 h2⊢\n  intro x hx y hy z hz\n  trans x * z * («expr⁅ , ⁆» y («expr⁅ , ⁆» z⁻¹ x⁻¹))⁻¹ * z⁻¹ * y * («expr⁅ , ⁆» x⁻¹ («expr⁅ , ⁆» y⁻¹ z))⁻¹ * y⁻¹ * x⁻¹\n  · group\n  · rw [h1 _ (H₂.inv_mem hy) _ hz _ (H₁.inv_mem hx), h2 _ (H₃.inv_mem hz) _ (H₁.inv_mem hx) _ hy]\n    group\n#align commutator_commutator_eq_bot_of_rotate commutator_commutator_eq_bot_of_rotate\n\n",
 "commutator_comm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_comm_le : «expr⁅ , ⁆» H₁ H₂ ≤ «expr⁅ , ⁆» H₂ H₁ :=\n  commutator_le.mpr fun g₁ h₁ g₂ h₂ =>\n    commutator_element_inv g₂ g₁ ▸ («expr⁅ , ⁆» H₂ H₁).inv_mem_iff.mpr (commutator_mem_commutator h₂ h₁)\n#align commutator_comm_le commutator_comm_le\n\n",
 "commutator_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_comm : «expr⁅ , ⁆» H₁ H₂ = «expr⁅ , ⁆» H₂ H₁ :=\n  le_antisymm (commutator_comm_le H₁ H₂) (commutator_comm_le H₂ H₁)\n#align commutator_comm commutator_comm\n\n",
 "commutator_bot_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem commutator_bot_right : «expr⁅ , ⁆» H₁ («expr⊥») = («expr⊥» : subgroup G) :=\n  le_bot_iff.mp (commutator_le_right H₁ («expr⊥»))\n#align commutator_bot_right commutator_bot_right\n\n",
 "commutator_bot_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem commutator_bot_left : «expr⁅ , ⁆» («expr⊥» : subgroup G) H₁ = «expr⊥» :=\n  le_bot_iff.mp (commutator_le_left («expr⊥») H₁)\n#align commutator_bot_left commutator_bot_left\n\n"}