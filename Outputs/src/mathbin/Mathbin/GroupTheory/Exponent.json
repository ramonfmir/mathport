{"pow_exponent_eq_one":
 "@[to_additive exponent_nsmul_eq_zero]\ntheorem pow_exponent_eq_one (g : G) : g ^ exponent G = 1 :=\n  by\n  by_cases exponent_exists G\n  · simp_rw [exponent, dif_pos h]\n    exact (nat.find_spec h).2 g\n  · simp_rw [exponent, dif_neg h, pow_zero]\n#align pow_exponent_eq_one pow_exponent_eq_one\n\n",
 "pow_eq_mod_exponent":
 "@[to_additive]\ntheorem pow_eq_mod_exponent {n : ℕ} (g : G) : g ^ n = g ^ (n % exponent G) :=\n  calc\n    g ^ n = g ^ (n % exponent G + exponent G * (n / exponent G)) := by rw [nat.mod_add_div]\n    _ = g ^ (n % exponent G) := by simp [pow_add, pow_mul, pow_exponent_eq_one]\n    \n#align pow_eq_mod_exponent pow_eq_mod_exponent\n\n",
 "order_dvd_exponent":
 "@[to_additive add_order_dvd_exponent]\ntheorem order_dvd_exponent (g : G) : order_of g ∣ exponent G :=\n  order_of_dvd_of_pow_eq_one <| pow_exponent_eq_one g\n#align order_dvd_exponent order_dvd_exponent\n\n",
 "lcm_order_of_dvd_exponent":
 "@[to_additive lcm_add_order_of_dvd_exponent]\ntheorem lcm_order_of_dvd_exponent [fintype G] : (finset.univ : Finset G).lcm order_of ∣ exponent G :=\n  by\n  apply finset.lcm_dvd\n  intro g hg\n  exact order_dvd_exponent g\n#align lcm_order_of_dvd_exponent lcm_order_of_dvd_exponent\n\n",
 "lcm_order_eq_exponent":
 "@[to_additive lcm_add_order_eq_exponent]\ntheorem lcm_order_eq_exponent [fintype G] : (finset.univ : Finset G).lcm order_of = exponent G :=\n  by\n  apply nat.dvd_antisymm (lcm_order_of_dvd_exponent G)\n  refine' exponent_dvd_of_forall_pow_eq_one G _ fun g => _\n  obtain ⟨m, hm⟩ : order_of g ∣ finset.univ.lcm order_of := finset.dvd_lcm (finset.mem_univ g)\n  rw [hm, pow_mul, pow_order_of_eq_one, one_pow]\n#align lcm_order_eq_exponent lcm_order_eq_exponent\n\n",
 "exponent_pos_of_exists":
 "@[to_additive]\ntheorem exponent_pos_of_exists (n : ℕ) (hpos : 0 < n) (hG : ∀ g : G, g ^ n = 1) : 0 < exponent G :=\n  by\n  have h : ∃ n, 0 < n ∧ ∀ g : G, g ^ n = 1 := ⟨n, hpos, hG⟩\n  rw [exponent, dif_pos]\n  exact (nat.find_spec h).1\n#align exponent_pos_of_exists exponent_pos_of_exists\n\n",
 "exponent_ne_zero_of_finite":
 "@[to_additive]\ntheorem exponent_ne_zero_of_finite [Finite G] : exponent G ≠ 0 :=\n  by\n  cases nonempty_fintype G\n  simpa [← lcm_order_eq_exponent, finset.lcm_eq_zero_iff] using fun x => (order_of_pos x).ne'\n#align exponent_ne_zero_of_finite exponent_ne_zero_of_finite\n\n",
 "exponent_ne_zero_iff_range_order_of_finite":
 "@[to_additive]\ntheorem exponent_ne_zero_iff_range_order_of_finite (h : ∀ g : G, 0 < order_of g) :\n    exponent G ≠ 0 ↔ (Set.range (order_of : G → ℕ)).finite :=\n  by\n  refine' ⟨fun he => _, fun he => _⟩\n  · by_contra h\n    obtain ⟨m, ⟨t, rfl⟩, het⟩ := set.infinite.exists_nat_lt h (exponent G)\n    exact pow_ne_one_of_lt_order_of' he het (pow_exponent_eq_one t)\n  · lift Set.range order_of to Finset ℕ using he with t ht\n    have htpos : 0 < t.prod id := by\n      refine' finset.prod_pos fun a ha => _\n      rw [← Finset.mem_coe, ht] at ha\n      obtain ⟨k, rfl⟩ := ha\n      exact h k\n    suffices exponent G ∣ t.prod id by\n      intro h\n      rw [h, zero_dvd_iff] at this\n      exact htpos.ne' this\n    refine' exponent_dvd_of_forall_pow_eq_one _ _ fun g => _\n    rw [pow_eq_mod_order_of, nat.mod_eq_zero_of_dvd, pow_zero g]\n    apply finset.dvd_prod_of_mem\n    rw [← Finset.mem_coe, ht]\n    exact Set.mem_range_self g\n#align exponent_ne_zero_iff_range_order_of_finite exponent_ne_zero_iff_range_order_of_finite\n\n",
 "exponent_min'":
 "@[to_additive]\ntheorem exponent_min' (n : ℕ) (hpos : 0 < n) (hG : ∀ g : G, g ^ n = 1) : exponent G ≤ n :=\n  by\n  rw [exponent, dif_pos]\n  · apply nat.find_min'\n    exact ⟨hpos, hG⟩\n  · exact ⟨n, hpos, hG⟩\n#align exponent_min' exponent_min'\n\n",
 "exponent_min":
 "@[to_additive]\ntheorem exponent_min (m : ℕ) (hpos : 0 < m) (hm : m < exponent G) : ∃ g : G, g ^ m ≠ 1 :=\n  by\n  by_contra' h\n  have hcon : exponent G ≤ m := exponent_min' m hpos h\n  linarith\n#align exponent_min exponent_min\n\n",
 "exponent_exists_iff_ne_zero":
 "/-\nCopyright (c) 2021 Julian Kuelshammer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Julian Kuelshammer\n-/\n@[to_additive]\ntheorem exponent_exists_iff_ne_zero : exponent_exists G ↔ exponent G ≠ 0 :=\n  by\n  rw [exponent]\n  split_ifs\n  · simp [h, @not_lt_zero' ℕ]\n  --if this isn't done this way, `to_additive` freaks\n  · tauto\n#align exponent_exists_iff_ne_zero exponent_exists_iff_ne_zero\n\n",
 "exponent_eq_zero_of_order_zero":
 "@[to_additive]\ntheorem exponent_eq_zero_of_order_zero {g : G} (hg : order_of g = 0) : exponent G = 0 :=\n  exponent_eq_zero_iff.mpr fun ⟨n, hn, hgn⟩ => order_of_eq_zero_iff'.mp hg n hn <| hgn g\n#align exponent_eq_zero_of_order_zero exponent_eq_zero_of_order_zero\n\n",
 "exponent_eq_zero_iff_range_order_of_infinite":
 "@[to_additive]\ntheorem exponent_eq_zero_iff_range_order_of_infinite (h : ∀ g : G, 0 < order_of g) :\n    exponent G = 0 ↔ (Set.range (order_of : G → ℕ)).infinite :=\n  by\n  have := exponent_ne_zero_iff_range_order_of_finite h\n  rwa [ne.def, not_iff_comm, iff.comm] at this\n#align exponent_eq_zero_iff_range_order_of_infinite exponent_eq_zero_iff_range_order_of_infinite\n\n",
 "exponent_eq_zero_iff":
 "@[to_additive]\ntheorem exponent_eq_zero_iff : exponent G = 0 ↔ ¬exponent_exists G := by\n  simp only [exponent_exists_iff_ne_zero, not_not]\n#align exponent_eq_zero_iff exponent_eq_zero_iff\n\n",
 "exponent_eq_supr_order_of'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem exponent_eq_supr_order_of' :\n    exponent G =\n      if ∃ g : G, order_of g = 0 then 0\n      else\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (order_of g) :=\n  by\n  split_ifs\n  · obtain ⟨g, hg⟩ := h\n    exact exponent_eq_zero_of_order_zero hg\n  · have := not_exists.mp h\n    exact exponent_eq_supr_order_of fun g => Ne.bot_lt <| this g\n#align exponent_eq_supr_order_of' exponent_eq_supr_order_of'\n\n",
 "exponent_eq_supr_order_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem exponent_eq_supr_order_of (h : ∀ g : G, 0 < order_of g) :\n    exponent G =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (order_of g) :=\n  by\n  rw [supᵢ]\n  rcases eq_or_ne (exponent G) 0 with (he | he)\n  · rw [he, set.infinite.nat.Sup_eq_zero <| (exponent_eq_zero_iff_range_order_of_infinite h).1 he]\n  have hne : (Set.range (order_of : G → ℕ)).nonempty := ⟨1, 1, order_of_one⟩\n  have hfin : (Set.range (order_of : G → ℕ)).finite := by rwa [← exponent_ne_zero_iff_range_order_of_finite h]\n  obtain ⟨t, ht⟩ := hne.cSup_mem hfin\n  apply nat.dvd_antisymm _\n  · rw [← ht]\n    apply order_dvd_exponent\n  refine' nat.dvd_of_factors_subperm he _\n  rw [List.subperm_ext_iff]\n  by_contra' h\n  obtain ⟨p, hp, hpe⟩ := h\n  replace hp := nat.prime_of_mem_factors hp\n  simp only [nat.factors_count_eq] at hpe\n  set k := (order_of t).factorization p with hk\n  obtain ⟨g, hg⟩ := hp.exists_order_of_eq_pow_factorization_exponent G\n  suffices order_of t < order_of (t ^ p ^ k * g) by\n    rw [ht] at this\n    exact this.not_le (le_csupₛ hfin.bdd_above <| Set.mem_range_self _)\n  have hpk : p ^ k ∣ order_of t := nat.ord_proj_dvd _ _\n  have hpk' : order_of (t ^ p ^ k) = order_of t / p ^ k := by\n    rw [order_of_pow' t (pow_ne_zero k hp.ne_zero), nat.gcd_eq_right hpk]\n  obtain ⟨a, ha⟩ := Nat.exists_eq_add_of_lt hpe\n  have hcoprime : (order_of (t ^ p ^ k)).coprime (order_of g) :=\n    by\n    rw [hg, Nat.coprime_pow_right_iff (pos_of_gt hpe), nat.coprime_comm]\n    apply or.resolve_right (Nat.coprime_or_dvd_of_prime hp _)\n    nth_rw 1 [← pow_one p]\n    convert nat.pow_succ_factorization_not_dvd (h <| t ^ p ^ k).ne' hp\n    rw [hpk', nat.factorization_div hpk]\n    simp [hp]\n  rw [(Commute.all _ g).order_of_mul_eq_mul_order_of_of_coprime hcoprime, hpk', hg, ha, ← ht, ← hk, pow_add, pow_add,\n    pow_one, ← mul_assoc, ← mul_assoc, Nat.div_mul_cancel, mul_assoc, lt_mul_iff_one_lt_right <| h t, ← pow_succ']\n  exact one_lt_pow hp.one_lt a.succ_ne_zero\n  exact hpk\n#align exponent_eq_supr_order_of exponent_eq_supr_order_of\n\n",
 "exponent_eq_max'_order_of":
 "@[to_additive]\ntheorem exponent_eq_max'_order_of [fintype G] : exponent G = ((@finset.univ G _).image order_of).max' ⟨1, by simp⟩ :=\n  by\n  rw [← finset.nonempty.cSup_eq_max', Finset.coe_image, finset.coe_univ, Set.image_univ, ← supᵢ]\n  exact exponent_eq_supr_order_of order_of_pos\n#align exponent_eq_max'_order_of exponent_eq_max'_order_of\n\n",
 "exponent_dvd_of_forall_pow_eq_one":
 "@[to_additive]\ntheorem exponent_dvd_of_forall_pow_eq_one (G) [monoid G] (n : ℕ) (hG : ∀ g : G, g ^ n = 1) : exponent G ∣ n :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · exact dvd_zero _\n  apply nat.dvd_of_mod_eq_zero\n  by_contra h\n  have h₁ := nat.pos_of_ne_zero h\n  have h₂ : n % exponent G < exponent G := nat.mod_lt _ (exponent_pos_of_exists n hpos hG)\n  have h₃ : exponent G ≤ n % exponent G := by\n    apply exponent_min' _ h₁\n    simp_rw [← pow_eq_mod_exponent]\n    exact hG\n  linarith\n#align exponent_dvd_of_forall_pow_eq_one exponent_dvd_of_forall_pow_eq_one\n\n",
 "exp_eq_one_of_subsingleton":
 "@[simp, to_additive]\ntheorem exp_eq_one_of_subsingleton [subsingleton G] : exponent G = 1 :=\n  by\n  apply le_antisymm\n  · apply exponent_min' _ nat.one_pos\n    simp\n  · apply nat.succ_le_of_lt\n    apply exponent_pos_of_exists 1 nat.one_pos\n    simp\n#align exp_eq_one_of_subsingleton exp_eq_one_of_subsingleton\n\n",
 "exists_order_of_eq_pow_factorization_exponent":
 "@[to_additive exists_order_of_eq_pow_padic_val_nat_add_exponent]\ntheorem _root_.nat.prime.exists_order_of_eq_pow_factorization_exponent {p : ℕ} (hp : p.prime) :\n    ∃ g : G, order_of g = p ^ (exponent G).factorization p :=\n  by\n  haveI := fact.mk hp\n  rcases eq_or_ne ((exponent G).factorization p) 0 with (h | h)\n  · refine' ⟨1, by rw [h, pow_zero, order_of_one]⟩\n  have he : 0 < exponent G :=\n    Ne.bot_lt fun ht => by\n      rw [ht] at h\n      apply h\n      rw [bot_eq_zero, nat.factorization_zero, finsupp.zero_apply]\n  rw [← finsupp.mem_support_iff] at h\n  obtain ⟨g, hg⟩ : ∃ g : G, g ^ (exponent G / p) ≠ 1 :=\n    by\n    suffices key : ¬exponent G ∣ exponent G / p\n    · simpa using mt (exponent_dvd_of_forall_pow_eq_one G (exponent G / p)) key\n    exact fun hd =>\n      hp.one_lt.not_le\n        ((mul_le_iff_le_one_left he).mp <|\n          nat.le_of_dvd he <| Nat.mul_dvd_of_dvd_div (nat.dvd_of_mem_factorization h) hd)\n  obtain ⟨k, hk : exponent G = p ^ _ * k⟩ := nat.ord_proj_dvd _ _\n  obtain ⟨t, ht⟩ := nat.exists_eq_succ_of_ne_zero (finsupp.mem_support_iff.mp h)\n  refine' ⟨g ^ k, _⟩\n  rw [ht]\n  apply order_of_eq_prime_pow\n  · rwa [hk, mul_comm, ht, pow_succ', ← mul_assoc, nat.mul_div_cancel _ hp.pos, pow_mul] at hg\n  · rw [← nat.succ_eq_add_one, ← ht, ← pow_mul, mul_comm, ← hk]\n    exact pow_exponent_eq_one g\n#align nat.prime.exists_order_of_eq_pow_factorization_exponent nat.prime.exists_order_of_eq_pow_factorization_exponent\n\n",
 "card_dvd_exponent_pow_rank'":
 "@[to_additive]\ntheorem card_dvd_exponent_pow_rank' {n : ℕ} (hG : ∀ g : G, g ^ n = 1) : nat.card G ∣ n ^ group.rank G :=\n  (card_dvd_exponent_pow_rank G).trans\n    (pow_dvd_pow_of_dvd (monoid.exponent_dvd_of_forall_pow_eq_one G n hG) (group.rank G))\n#align card_dvd_exponent_pow_rank' card_dvd_exponent_pow_rank'\n\n",
 "card_dvd_exponent_pow_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem card_dvd_exponent_pow_rank : nat.card G ∣ monoid.exponent G ^ group.rank G :=\n  by\n  obtain ⟨S, hS1, hS2⟩ := group.rank_spec G\n  rw [← hS1, ← fintype.card_coe, ← finset.card_univ, ← finset.prod_const]\n  let f : «expr →* » (∀ g : S, zpowers (g : G)) G := noncomm_pi_coprod fun s t h x y hx hy => mul_comm x y\n  have hf : function.surjective f :=\n    by\n    rw [← monoid_hom.range_top_iff_surjective, eq_top_iff, ← hS2, closure_le]\n    exact fun g hg => ⟨Pi.mulSingle ⟨g, hg⟩ ⟨g, mem_zpowers g⟩, noncomm_pi_coprod_mul_single _ _⟩\n  replace hf := nat_card_dvd_of_surjective f hf\n  rw [nat.card_pi] at hf\n  refine' hf.trans (finset.prod_dvd_prod_of_dvd _ _ fun g hg => _)\n  rw [← order_eq_card_zpowers']\n  exact monoid.order_dvd_exponent (g : G)\n#align card_dvd_exponent_pow_rank card_dvd_exponent_pow_rank\n\n"}