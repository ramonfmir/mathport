{"unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift.unique (φ : «expr →* » (abelianization G) A)\n    -- hφ : φ agrees with f on the image of G in Gᵃᵇ\n    (hφ : ∀ x : G, φ (of x) = f x)\n    {x : abelianization G} : φ x = lift f x :=\n  quotient_group.induction_on x hφ\n#align lift.unique lift.unique\n\n",
 "rank_commutator_le_card":
 "theorem rank_commutator_le_card [Finite (commutator_set G)] : group.rank (commutator G) ≤ nat.card (commutator_set G) :=\n  by\n  rw [subgroup.rank_congr (commutator_eq_closure G)]\n  apply subgroup.rank_closure_finite_le_nat_card\n#align rank_commutator_le_card rank_commutator_le_card\n\n",
 "rank_closure_commutator_representations_le":
 "theorem rank_closure_commutator_representations_le [Finite (commutator_set G)] :\n    group.rank (closure_commutator_representatives G) ≤ 2 * nat.card (commutator_set G) :=\n  by\n  rw [two_mul]\n  exact\n    (subgroup.rank_closure_finite_le_nat_card _).trans\n      ((set.card_union_le _ _).trans\n        (add_le_add ((finite.card_image_le _).trans (finite.card_range_le _))\n          ((finite.card_image_le _).trans (finite.card_range_le _))))\n#align rank_closure_commutator_representations_le rank_closure_commutator_representations_le\n\n",
 "of":
 "@[simp]\ntheorem lift.of (x : G) : lift f (of x) = f x :=\n  rfl\n#align lift.of lift.of\n\n",
 "mk_eq_of":
 "@[simp]\ntheorem mk_eq_of (a : G) : Quot.mk _ a = of a :=\n  rfl\n#align mk_eq_of mk_eq_of\n\n",
 "map_of":
 "@[simp]\ntheorem map_of (x : G) : map f (of x) = of (f x) :=\n  rfl\n#align map_of map_of\n\n",
 "map_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem map_map_apply {I : Type w} [group I] {g : «expr →* » H I} {x : abelianization G} :\n    map g (map f x) = map (g.comp f) x :=\n  MonoidHom.congr_fun (map_comp _ _) x\n#align map_map_apply map_map_apply\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : map (MonoidHom.id G) = MonoidHom.id (abelianization G) :=\n  hom_ext _ _ rfl\n#align map_id map_id\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem map_comp {I : Type w} [group I] (g : «expr →* » H I) : (map g).comp (map f) = map (g.comp f) :=\n  hom_ext _ _ rfl\n#align map_comp map_comp\n\n",
 "lift_of":
 "@[simp]\ntheorem lift_of : lift of = MonoidHom.id (abelianization G) :=\n  lift.apply_symm_apply <| MonoidHom.id _\n#align lift_of lift_of\n\n",
 "image_commutator_set_closure_commutator_representatives":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_commutator_set_closure_commutator_representatives :\n    «expr '' » (closure_commutator_representatives G).subtype (commutator_set (closure_commutator_representatives G)) =\n      commutator_set G :=\n  by\n  apply Set.Subset.antisymm\n  · rintro - ⟨-, ⟨g₁, g₂, rfl⟩, rfl⟩\n    exact ⟨g₁, g₂, rfl⟩\n  ·\n    exact fun g hg =>\n      ⟨_,\n        ⟨⟨_, subset_closure (or.inl ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩, ⟨_, subset_closure (or.inr ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩,\n          rfl⟩,\n        hg.some_spec.some_spec⟩\n#align image_commutator_set_closure_commutator_representatives image_commutator_set_closure_commutator_representatives\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext (φ ψ : «expr →* » (abelianization G) A) (h : φ.comp of = ψ.comp of) : φ = ψ :=\n  MonoidHom.ext fun x => quotient_group.induction_on x <| MonoidHom.congr_fun h\n#align hom_ext hom_ext\n\n",
 "commutator_subset_ker":
 "-- So far we have built Gᵃᵇ and proved it's an abelian group.\n-- Furthremore we defined the canonical projection `of : G → Gᵃᵇ`\n-- Let `A` be an abelian group and let `f` be a group homomorphism from `G` to `A`.\ntheorem commutator_subset_ker : commutator G ≤ f.ker :=\n  by\n  rw [commutator_eq_closure, subgroup.closure_le]\n  rintro x ⟨p, q, rfl⟩\n  simp [monoid_hom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]\n#align commutator_subset_ker commutator_subset_ker\n\n",
 "commutator_eq_normal_closure":
 "theorem commutator_eq_normal_closure : commutator G = subgroup.normal_closure (commutator_set G) := by\n  simp [commutator, subgroup.commutator_def', commutator_set]\n#align commutator_eq_normal_closure commutator_eq_normal_closure\n\n",
 "commutator_eq_closure":
 "theorem commutator_eq_closure : commutator G = subgroup.closure (commutator_set G) := by\n  simp [commutator, subgroup.commutator_def, commutator_set]\n#align commutator_eq_closure commutator_eq_closure\n\n",
 "commutator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Michael Howes\n-/\n-- Let G be a group.\ntheorem commutator_def : commutator G = «expr⁅ , ⁆» («expr⊤» : subgroup G) («expr⊤») :=\n  rfl\n#align commutator_def commutator_def\n\n",
 "commutator_centralizer_commutator_le_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem commutator_centralizer_commutator_le_center :\n    «expr⁅ , ⁆» (commutator G).centralizer (commutator G).centralizer ≤ subgroup.center G :=\n  by\n  rw [← subgroup.centralizer_top, ← subgroup.commutator_eq_bot_iff_le_centralizer]\n  suffices «expr⁅ , ⁆» («expr⁅ , ⁆» («expr⊤») (commutator G).centralizer) (commutator G).centralizer = «expr⊥»\n    by\n    refine' subgroup.commutator_commutator_eq_bot_of_rotate _ this\n    rwa [subgroup.commutator_comm (commutator G).centralizer]\n  rw [subgroup.commutator_comm, subgroup.commutator_eq_bot_iff_le_centralizer]\n  exact Set.centralizer_subset (subgroup.commutator_mono le_top le_top)\n#align commutator_centralizer_commutator_le_center commutator_centralizer_commutator_le_center\n\n",
 "card_commutator_set_closure_commutator_representatives":
 "theorem card_commutator_set_closure_commutator_representatives :\n    nat.card (commutator_set (closure_commutator_representatives G)) = nat.card (commutator_set G) :=\n  by\n  rw [← image_commutator_set_closure_commutator_representatives G]\n  exact nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))\n#align card_commutator_set_closure_commutator_representatives card_commutator_set_closure_commutator_representatives\n\n",
 "card_commutator_closure_commutator_representatives":
 "theorem card_commutator_closure_commutator_representatives :\n    nat.card (commutator (closure_commutator_representatives G)) = nat.card (commutator G) :=\n  by\n  rw [commutator_eq_closure G, ← image_commutator_set_closure_commutator_representatives, ← monoid_hom.map_closure, ←\n    commutator_eq_closure]\n  exact nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))\n#align card_commutator_closure_commutator_representatives card_commutator_closure_commutator_representatives\n\n",
 "abelianization_congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n@[simp]\ntheorem abelianization_congr_trans {I : Type v} [group I] (e₂ : «expr ≃* » H I) :\n    e.abelianization_congr.trans e₂.abelianization_congr = (e.trans e₂).abelianization_congr :=\n  MulEquiv.toMonoidHom_injective (abelianization.hom_ext _ _ rfl)\n#align abelianization_congr_trans abelianization_congr_trans\n\n",
 "abelianization_congr_symm":
 "@[simp]\ntheorem abelianization_congr_symm : e.abelianization_congr.symm = e.symm.abelianization_congr :=\n  rfl\n#align abelianization_congr_symm abelianization_congr_symm\n\n",
 "abelianization_congr_refl":
 "@[simp]\ntheorem abelianization_congr_refl : (MulEquiv.refl G).abelianization_congr = MulEquiv.refl (abelianization G) :=\n  MulEquiv.toMonoidHom_injective abelianization.lift_of\n#align abelianization_congr_refl abelianization_congr_refl\n\n",
 "abelianization_congr_of":
 "@[simp]\ntheorem abelianization_congr_of (x : G) : e.abelianization_congr (abelianization.of x) = abelianization.of (e x) :=\n  rfl\n#align abelianization_congr_of abelianization_congr_of\n\n"}