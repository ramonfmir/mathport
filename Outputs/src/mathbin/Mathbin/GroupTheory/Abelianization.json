{"unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift.unique (φ : «expr →* » (Abelianization G) A)\n    -- hφ : φ agrees with f on the image of G in Gᵃᵇ\n    (hφ : ∀ x : G, φ (of x) = f x)\n    {x : Abelianization G} : φ x = lift f x :=\n  QuotientGroup.induction_on x hφ\n#align lift.unique lift.unique\n\n",
 "rank_commutator_le_card":
 "#print rank_commutator_le_card /-\ntheorem rank_commutator_le_card [Finite (commutatorSet G)] : Group.rank (commutator G) ≤ Nat.card (commutatorSet G) :=\n  by\n  rw [Subgroup.rank_congr (commutator_eq_closure G)]\n  apply Subgroup.rank_closure_finite_le_nat_card\n#align rank_commutator_le_card rank_commutator_le_card\n-/\n\n",
 "rank_closureCommutatorRepresentatives_le":
 "#print rank_closureCommutatorRepresentatives_le /-\ntheorem rank_closureCommutatorRepresentatives_le [Finite (commutatorSet G)] :\n    Group.rank (closureCommutatorRepresentatives G) ≤ 2 * Nat.card (commutatorSet G) :=\n  by\n  rw [two_mul]\n  exact\n    (Subgroup.rank_closure_finite_le_nat_card _).trans\n      ((Set.card_union_le _ _).trans\n        (add_le_add ((Finite.card_image_le _).trans (Finite.card_range_le _))\n          ((Finite.card_image_le _).trans (Finite.card_range_le _))))\n#align rank_closure_commutator_representations_le rank_closureCommutatorRepresentatives_le\n-/\n\n",
 "of":
 "@[simp]\ntheorem lift.of (x : G) : lift f (of x) = f x :=\n  rfl\n#align lift.of lift.of\n\n",
 "mk_eq_of":
 "@[simp]\ntheorem mk_eq_of (a : G) : Quot.mk _ a = of a :=\n  rfl\n#align mk_eq_of mk_eq_of\n\n",
 "map_of":
 "@[simp]\ntheorem map_of (x : G) : map f (of x) = of (f x) :=\n  rfl\n#align map_of map_of\n\n",
 "map_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem map_map_apply {I : Type w} [Group I] {g : «expr →* » H I} {x : Abelianization G} :\n    map g (map f x) = map (g.comp f) x :=\n  MonoidHom.congr_fun (map_comp _ _) x\n#align map_map_apply map_map_apply\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : map (MonoidHom.id G) = MonoidHom.id (Abelianization G) :=\n  hom_ext _ _ rfl\n#align map_id map_id\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem map_comp {I : Type w} [Group I] (g : «expr →* » H I) : (map g).comp (map f) = map (g.comp f) :=\n  hom_ext _ _ rfl\n#align map_comp map_comp\n\n",
 "lift_of":
 "@[simp]\ntheorem lift_of : lift of = MonoidHom.id (Abelianization G) :=\n  lift.apply_symm_apply <| MonoidHom.id _\n#align lift_of lift_of\n\n",
 "image_commutatorSet_closureCommutatorRepresentatives":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print image_commutatorSet_closureCommutatorRepresentatives /-\ntheorem image_commutatorSet_closureCommutatorRepresentatives :\n    «expr '' » (closureCommutatorRepresentatives G).subtype (commutatorSet (closureCommutatorRepresentatives G)) =\n      commutatorSet G :=\n  by\n  apply Set.Subset.antisymm\n  · rintro - ⟨-, ⟨g₁, g₂, rfl⟩, rfl⟩\n    exact ⟨g₁, g₂, rfl⟩\n  ·\n    exact fun g hg =>\n      ⟨_,\n        ⟨⟨_, subset_closure (or.inl ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩, ⟨_, subset_closure (or.inr ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩,\n          rfl⟩,\n        hg.some_spec.some_spec⟩\n#align image_commutator_set_closure_commutator_representatives image_commutatorSet_closureCommutatorRepresentatives\n-/\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext (φ ψ : «expr →* » (Abelianization G) A) (h : φ.comp of = ψ.comp of) : φ = ψ :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| MonoidHom.congr_fun h\n#align hom_ext hom_ext\n\n",
 "commutator_subset_ker":
 "-- So far we have built Gᵃᵇ and proved it's an abelian group.\n-- Furthremore we defined the canonical projection `of : G → Gᵃᵇ`\n-- Let `A` be an abelian group and let `f` be a group homomorphism from `G` to `A`.\ntheorem commutator_subset_ker : commutator G ≤ f.ker :=\n  by\n  rw [commutator_eq_closure, Subgroup.closure_le]\n  rintro x ⟨p, q, rfl⟩\n  simp [MonoidHom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]\n#align commutator_subset_ker commutator_subset_ker\n\n",
 "commutator_eq_normalClosure":
 "#print commutator_eq_normalClosure /-\ntheorem commutator_eq_normalClosure : commutator G = Subgroup.normalClosure (commutatorSet G) := by\n  simp [commutator, Subgroup.commutator_def', commutatorSet]\n#align commutator_eq_normal_closure commutator_eq_normalClosure\n-/\n\n",
 "commutator_eq_closure":
 "#print commutator_eq_closure /-\ntheorem commutator_eq_closure : commutator G = Subgroup.closure (commutatorSet G) := by\n  simp [commutator, Subgroup.commutator_def, commutatorSet]\n#align commutator_eq_closure commutator_eq_closure\n-/\n\n",
 "commutator_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print commutator_def /-\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Michael Howes\n-/\n-- Let G be a group.\ntheorem commutator_def : commutator G = «expr⁅ , ⁆» («expr⊤» : Subgroup G) («expr⊤») :=\n  rfl\n#align commutator_def commutator_def\n-/\n\n",
 "commutator_centralizer_commutator_le_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n#print commutator_centralizer_commutator_le_center /-\ntheorem commutator_centralizer_commutator_le_center :\n    «expr⁅ , ⁆» (commutator G).centralizer (commutator G).centralizer ≤ Subgroup.center G :=\n  by\n  rw [← Subgroup.centralizer_top, ← Subgroup.commutator_eq_bot_iff_le_centralizer]\n  suffices «expr⁅ , ⁆» («expr⁅ , ⁆» («expr⊤») (commutator G).centralizer) (commutator G).centralizer = «expr⊥»\n    by\n    refine' Subgroup.commutator_commutator_eq_bot_of_rotate _ this\n    rwa [Subgroup.commutator_comm (commutator G).centralizer]\n  rw [Subgroup.commutator_comm, Subgroup.commutator_eq_bot_iff_le_centralizer]\n  exact Set.centralizer_subset (Subgroup.commutator_mono le_top le_top)\n#align commutator_centralizer_commutator_le_center commutator_centralizer_commutator_le_center\n-/\n\n",
 "card_commutator_closureCommutatorRepresentatives":
 "#print card_commutator_closureCommutatorRepresentatives /-\ntheorem card_commutator_closureCommutatorRepresentatives :\n    Nat.card (commutator (closureCommutatorRepresentatives G)) = Nat.card (commutator G) :=\n  by\n  rw [commutator_eq_closure G, ← image_commutatorSet_closureCommutatorRepresentatives, ← MonoidHom.map_closure, ←\n    commutator_eq_closure]\n  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))\n#align card_commutator_closure_commutator_representatives card_commutator_closureCommutatorRepresentatives\n-/\n\n",
 "card_commutatorSet_closureCommutatorRepresentatives":
 "#print card_commutatorSet_closureCommutatorRepresentatives /-\ntheorem card_commutatorSet_closureCommutatorRepresentatives :\n    Nat.card (commutatorSet (closureCommutatorRepresentatives G)) = Nat.card (commutatorSet G) :=\n  by\n  rw [← image_commutatorSet_closureCommutatorRepresentatives G]\n  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))\n#align card_commutator_set_closure_commutator_representatives card_commutatorSet_closureCommutatorRepresentatives\n-/\n\n",
 "abelianizationCongr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n#print abelianizationCongr_trans /-\n@[simp]\ntheorem abelianizationCongr_trans {I : Type v} [Group I] (e₂ : «expr ≃* » H I) :\n    e.abelianization_congr.trans e₂.abelianization_congr = (e.trans e₂).abelianization_congr :=\n  MulEquiv.toMonoidHom_injective (Abelianization.hom_ext _ _ rfl)\n#align abelianization_congr_trans abelianizationCongr_trans\n-/\n\n",
 "abelianizationCongr_symm":
 "#print abelianizationCongr_symm /-\n@[simp]\ntheorem abelianizationCongr_symm : e.abelianization_congr.symm = e.symm.abelianization_congr :=\n  rfl\n#align abelianization_congr_symm abelianizationCongr_symm\n-/\n\n",
 "abelianizationCongr_refl":
 "#print abelianizationCongr_refl /-\n@[simp]\ntheorem abelianizationCongr_refl : (MulEquiv.refl G).abelianization_congr = MulEquiv.refl (Abelianization G) :=\n  MulEquiv.toMonoidHom_injective Abelianization.lift_of\n#align abelianization_congr_refl abelianizationCongr_refl\n-/\n\n",
 "abelianizationCongr_of":
 "#print abelianizationCongr_of /-\n@[simp]\ntheorem abelianizationCongr_of (x : G) : e.abelianization_congr (Abelianization.of x) = Abelianization.of (e x) :=\n  rfl\n#align abelianization_congr_of abelianizationCongr_of\n-/\n\n"}