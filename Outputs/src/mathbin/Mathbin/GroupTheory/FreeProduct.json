{"to_list_ne_nil":
 "theorem to_list_ne_nil {i j} (w : neword M i j) : w.to_list ≠ list.nil :=\n  by\n  induction w\n  · rintro ⟨rfl⟩\n  · apply List.append_ne_nil_of_ne_nil_left\n    assumption\n#align to_list_ne_nil to_list_ne_nil\n\n",
 "to_list_last'":
 "@[simp]\ntheorem to_list_last' {i j} (w : neword M i j) : w.to_list.last' = option.some ⟨j, w.last⟩ :=\n  by\n  rw [← option.mem_def]\n  induction w\n  · rw [option.mem_def]\n    rfl\n  · exact List.getLast?_append w_ih_w₂\n#align to_list_last' to_list_last'\n\n",
 "to_list_head'":
 "@[simp]\ntheorem to_list_head' {i j} (w : neword M i j) : w.to_list.head' = option.some ⟨i, w.head⟩ :=\n  by\n  rw [← option.mem_def]\n  induction w\n  · rw [option.mem_def]\n    rfl\n  · exact List.head?_append w_ih_w₁\n#align to_list_head' to_list_head'\n\n",
 "smul_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_induction {C : word M → Prop} (h_empty : C empty)\n    (h_smul : ∀ (i) (m : M i) (w), C w → C («expr • » (of m) w)) (w : word M) : C w :=\n  by\n  cases' w with ls h1 h2\n  induction' ls with l ls ih\n  · exact h_empty\n  cases' l with i m\n  rw [cons_eq_smul]\n  exact h_smul _ _ _ (ih _ _)\n#align smul_induction smul_induction\n\n",
 "singleton_last":
 "@[simp]\ntheorem singleton_last {i} (x : M i) (hne_one : x ≠ 1) : (singleton x hne_one).last = x :=\n  rfl\n#align singleton_last singleton_last\n\n",
 "singleton_head":
 "@[simp]\ntheorem singleton_head {i} (x : M i) (hne_one : x ≠ 1) : (singleton x hne_one).head = x :=\n  rfl\n#align singleton_head singleton_head\n\n",
 "replace_head_head":
 "@[simp]\ntheorem replace_head_head {i j : ι} (x : M i) (hnotone : x ≠ 1) (w : neword M i j) :\n    (replace_head x hnotone w).head = x := by\n  induction w\n  rfl\n  exact w_ih_w₁ _ _\n#align replace_head_head replace_head_head\n\n",
 "rcons_inj":
 "theorem rcons_inj {i} : function.injective (rcons : pair M i → word M) :=\n  by\n  rintro ⟨m, w, h⟩ ⟨m', w', h'⟩ he\n  by_cases hm : m = 1 <;> by_cases hm' : m' = 1\n  · simp only [rcons, dif_pos hm, dif_pos hm'] at he\n    cc\n  · exfalso\n    simp only [rcons, dif_pos hm, dif_neg hm'] at he\n    rw [he] at h\n    exact h rfl\n  · exfalso\n    simp only [rcons, dif_pos hm', dif_neg hm] at he\n    rw [← he] at h'\n    exact h' rfl\n  · have : m = m' ∧ w.to_list = w'.to_list := by\n      simpa only [rcons, dif_neg hm, dif_neg hm', true_and_iff, eq_self_iff_true, subtype.mk_eq_mk, heq_iff_eq, ←\n        subtype.ext_iff_val] using he\n    rcases this with ⟨rfl, h⟩\n    congr\n    exact word.ext _ _ h\n#align rcons_inj rcons_inj\n\n",
 "range_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem range_eq_supr {N} [group N] (f : ∀ i, «expr →* » (G i) N) :\n    (lift f).range =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i).range :=\n  by\n  apply le_antisymm (lift_range_le _ f fun i => le_supᵢ _ i)\n  apply supᵢ_le _\n  rintro i _ ⟨x, rfl⟩\n  exact ⟨of x, by simp only [lift_of]⟩\n#align range_eq_supr range_eq_supr\n\n",
 "prod_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem prod_smul (m) : ∀ w : word M, prod («expr • » m w) = m * prod w :=\n  by\n  apply m.induction_on\n  · intro\n    rw [one_smul, one_mul]\n  · intros\n    rw [of_smul_def, prod_rcons, of.map_mul, mul_assoc, ← prod_rcons, ← equiv_pair_symm, equiv.symm_apply_apply]\n  · intro x y hx hy w\n    rw [mul_smul, hx, hy, mul_assoc]\n#align prod_smul prod_smul\n\n",
 "prod_singleton":
 "@[simp]\ntheorem prod_singleton {i} (x : M i) (hne_one : x ≠ 1) : (singleton x hne_one).prod = of x := by\n  simp [to_word, Prod, word.prod]\n#align prod_singleton prod_singleton\n\n",
 "prod_rcons":
 "@[simp]\ntheorem prod_rcons {i} (p : pair M i) : prod (rcons p) = of p.head * prod p.tail :=\n  if hm : p.head = 1 then by rw [rcons, dif_pos hm, hm, MonoidHom.map_one, one_mul]\n  else by rw [rcons, dif_neg hm, Prod, list.map_cons, List.prod_cons, Prod]\n#align prod_rcons prod_rcons\n\n",
 "prod_empty":
 "@[simp]\ntheorem prod_empty : prod (empty : word M) = 1 :=\n  rfl\n#align prod_empty prod_empty\n\n",
 "of_word":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/-- Every nonempty `word M` can be constructed as a `neword M i j` -/\ntheorem of_word (w : word M) (h : w ≠ empty) : ∃ (i j : _)(w' : neword M i j), w'.to_word = w :=\n  by\n  rsuffices ⟨i, j, w, h⟩ : ∃ (i j : _)(w' : neword M i j), w'.to_word.to_list = w.to_list\n  · refine' ⟨i, j, w, _⟩\n    ext\n    rw [h]\n  cases' w with l hnot1 hchain\n  induction' l with x l hi\n  · contradiction\n  · rw [List.forall_mem_cons] at hnot1\n    cases' l with y l\n    · refine' ⟨x.1, x.1, singleton x.2 hnot1.1, _⟩\n      simp [to_word]\n    · rw [List.chain'_cons] at hchain\n      specialize hi hnot1.2 hchain.2 (by rintro ⟨rfl⟩)\n      obtain ⟨i, j, w', hw' : w'.to_list = sym.cons' y l⟩ := hi\n      obtain rfl : y = ⟨i, w'.head⟩ := by simpa [hw'] using w'.to_list_head'\n      refine' ⟨x.1, j, append (singleton x.2 hnot1.1) hchain.1 w', _⟩\n      · simpa [to_word] using hw'\n#align of_word of_word\n\n",
 "of_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem of_smul_def (i) (w : word M) (m : M i) :\n    «expr • » (of m) w = rcons { equiv_pair i w with head := m * (equiv_pair i w).head } :=\n  rfl\n#align of_smul_def of_smul_def\n\n",
 "of_left_inverse":
 "theorem of_left_inverse [decidable_eq ι] (i : ι) :\n    function.left_inverse (lift <| Pi.mulSingle i (MonoidHom.id (M i))) of := fun x => by\n  simp only [lift_of, Pi.mulSingle_eq_same, monoid_hom.id_apply]\n#align of_left_inverse of_left_inverse\n\n",
 "of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem of_injective (i : ι) : function.injective («expr⇑ » (of : «expr →* » (M i) _)) := by\n  classical exact (of_left_inverse i).injective\n#align of_injective of_injective\n\n",
 "of_apply":
 "/-\nCopyright (c) 2021 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn, Joachim Breitner\n-/\ntheorem of_apply {i} (m : M i) : of m = con.mk' _ (FreeMonoid.of <| sigma.mk i m) :=\n  rfl\n#align of_apply of_apply\n\n",
 "mul_head_prod":
 "@[simp]\ntheorem mul_head_prod {i j : ι} (w : neword M i j) (x : M i) (hnotone : x * w.head ≠ 1) :\n    (mul_head w x hnotone).prod = of x * w.prod := by\n  unfold mul_head\n  induction w\n  · simp [mul_head, replace_head]\n  · specialize w_ih_w₁ _ hnotone\n    clear w_ih_w₂\n    simp [replace_head, ← mul_assoc] at *\n    congr 1\n#align mul_head_prod mul_head_prod\n\n",
 "mul_head_head":
 "@[simp]\ntheorem mul_head_head {i j : ι} (w : neword M i j) (x : M i) (hnotone : x * w.head ≠ 1) :\n    (mul_head w x hnotone).head = x * w.head := by\n  induction w\n  rfl\n  exact w_ih_w₁ _ _\n#align mul_head_head mul_head_head\n\n",
 "mrange_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem mrange_eq_supr {N} [monoid N] (f : ∀ i, «expr →* » (M i) N) :\n    (lift f).mrange =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i).mrange :=\n  by\n  apply le_antisymm (lift_mrange_le f fun i => le_supᵢ _ i)\n  apply supᵢ_le _\n  rintro i _ ⟨x, rfl⟩\n  exact ⟨of x, by simp only [lift_of]⟩\n#align mrange_eq_supr mrange_eq_supr\n\n",
 "lift_word_prod_nontrivial_of_other_i":
 "theorem lift_word_prod_nontrivial_of_other_i {i j k} (w : neword H i j) (hhead : k ≠ i) (hlast : k ≠ j) :\n    lift f w.prod ≠ 1 := by\n  intro heq1\n  have : X k ⊆ X i := by simpa [heq1] using lift_word_ping_pong f X hpp w hlast.symm\n  obtain ⟨x, hx⟩ := hXnonempty k\n  exact (hXdisj hhead).le_bot ⟨hx, this hx⟩\n#align lift_word_prod_nontrivial_of_other_i lift_word_prod_nontrivial_of_other_i\n\n",
 "lift_word_prod_nontrivial_of_not_empty":
 "theorem lift_word_prod_nontrivial_of_not_empty {i j} (w : neword H i j) : lift f w.prod ≠ 1 := by\n  classical\n    cases hcard\n    · obtain ⟨i, h1, h2⟩ := cardinal.three_le hcard i j\n      exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w h1 h2\n    · cases' hcard with k hcard\n      by_cases hh : i = k <;> by_cases hl : j = k\n      · subst hh\n        subst hl\n        exact lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w\n      · subst hh\n        change j ≠ i at hl\n        exact lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w hcard hl.symm\n      · subst hl\n        change i ≠ j at hh\n        have : lift f w.inv.prod ≠ 1 :=\n          lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w.inv hcard hh.symm\n        intro heq\n        apply this\n        simpa using HEq\n      · change i ≠ k at hh\n        change j ≠ k at hl\n        obtain ⟨h, hn1, -⟩ := cardinal.three_le hcard 1 1\n        let w' : neword H k k :=\n          neword.append (neword.append (neword.singleton h hn1) hh.symm w) hl\n            (neword.singleton h⁻¹ (inv_ne_one.mpr hn1))\n        have hw' : lift f w'.prod ≠ 1 := lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w'\n        intro heq1\n        apply hw'\n        simp [w', heq1]\n#align lift_word_prod_nontrivial_of_not_empty lift_word_prod_nontrivial_of_not_empty\n\n",
 "lift_word_prod_nontrivial_of_head_eq_last":
 "theorem lift_word_prod_nontrivial_of_head_eq_last {i} (w : neword H i i) : lift f w.prod ≠ 1 :=\n  by\n  obtain ⟨k, hk⟩ := exists_ne i\n  exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hk hk\n#align lift_word_prod_nontrivial_of_head_eq_last lift_word_prod_nontrivial_of_head_eq_last\n\n",
 "lift_word_prod_nontrivial_of_head_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lift_word_prod_nontrivial_of_head_card {i j} (w : neword H i j) (hcard : 3 ≤ cardinal.mk (H i))\n    (hheadtail : i ≠ j) : lift f w.prod ≠ 1 :=\n  by\n  obtain ⟨h, hn1, hnh⟩ := cardinal.three_le hcard 1 w.head⁻¹\n  have hnot1 : h * w.head ≠ 1 := by\n    rw [← div_inv_eq_mul]\n    exact div_ne_one_of_ne hnh\n  let w' : neword H i i :=\n    neword.append (neword.mul_head w h hnot1) hheadtail.symm (neword.singleton h⁻¹ (inv_ne_one.mpr hn1))\n  have hw' : lift f w'.prod ≠ 1 := lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w'\n  intro heq1\n  apply hw'\n  simp [w', heq1]\n#align lift_word_prod_nontrivial_of_head_card lift_word_prod_nontrivial_of_head_card\n\n",
 "lift_word_ping_pong":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- We need many groups or one group with many elements\n-- A group action on α, and the ping-pong sets\ntheorem lift_word_ping_pong {i j k} (w : neword H i j) (hk : j ≠ k) : «expr • » (lift f w.prod) (X k) ⊆ X i :=\n  by\n  rename' i => i', j => j', k => m, hk => hm\n  induction' w with i x hne_one i j k l w₁ hne w₂ hIw₁ hIw₂ generalizing m <;> clear i' j'\n  · simpa using hpp hm _ hne_one\n  ·\n    calc\n      «expr • » (lift f (neword.append w₁ hne w₂).prod) (X m) =\n          «expr • » (lift f w₁.prod) («expr • » (lift f w₂.prod) (X m)) :=\n        by simp [mul_action.mul_smul]\n      _ ⊆ «expr • » (lift f w₁.prod) (X k) := set_smul_subset_set_smul_iff.mpr (hIw₂ hm)\n      _ ⊆ X i := hIw₁ hne\n      \n#align lift_word_ping_pong lift_word_ping_pong\n\n",
 "lift_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift_range_le {N} [group N] (f : ∀ i, «expr →* » (G i) N) {s : subgroup N} (h : ∀ i, (f i).range ≤ s) :\n    (lift f).range ≤ s := by\n  rintro _ ⟨x, rfl⟩\n  induction' x using free_product.induction_on with i x x y hx hy\n  · exact s.one_mem\n  · simp only [lift_of, SetLike.mem_coe]\n    exact h i (Set.mem_range_self x)\n  · simp only [map_mul, SetLike.mem_coe]\n    exact s.mul_mem hx hy\n#align lift_range_le lift_range_le\n\n",
 "lift_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem lift_of {N} [monoid N] (fi : ∀ i, «expr →* » (M i) N) {i} (m : M i) : lift fi (of m) = fi i m := by\n  conv_rhs => rw [← lift.symm_apply_apply fi, lift_symm_apply, MonoidHom.comp_apply]\n#align lift_of lift_of\n\n",
 "lift_mrange_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lift_mrange_le {N} [monoid N] (f : ∀ i, «expr →* » (M i) N) {s : Submonoid N} (h : ∀ i, (f i).mrange ≤ s) :\n    (lift f).mrange ≤ s := by\n  rintro _ ⟨x, rfl⟩\n  induction' x using free_product.induction_on with i x x y hx hy\n  · exact s.one_mem\n  · simp only [lift_of, SetLike.mem_coe]\n    exact h i (Set.mem_range_self x)\n  · simp only [map_mul, SetLike.mem_coe]\n    exact s.mul_mem hx hy\n#align lift_mrange_le lift_mrange_le\n\n",
 "lift_injective_of_ping_pong":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- The Ping-Pong-Lemma.\n\nGiven a group action of `G` on `X` so that the `H i` acts in a specific way on disjoint subsets\n`X i` we can prove that `lift f` is injective, and thus the image of `lift f` is isomorphic to the\nfree product of the `H i`.\n\nOften the Ping-Pong-Lemma is stated with regard to subgroups `H i` that generate the whole group;\nwe generalize to arbitrary group homomorphisms `f i : H i →* G` and do not require the group to be\ngenerated by the images.\n\nUsually the Ping-Pong-Lemma requires that one group `H i` has at least three elements. This\ncondition is only needed if `# ι = 2`, and we accept `3 ≤ # ι` as an alternative.\n-/\ntheorem lift_injective_of_ping_pong : function.injective (lift f) := by\n  classical\n    apply (injective_iff_map_eq_one (lift f)).mpr\n    rw [(free_product.word.equiv : «expr ≃ » _ (word H)).forall_congr_left']\n    · intro w Heq\n      dsimp [word.equiv] at *\n      · rw [empty_of_word_prod_eq_one f hcard X hXnonempty hXdisj hpp Heq]\n        rfl\n#align lift_injective_of_ping_pong lift_injective_of_ping_pong\n\n",
 "inv_prod":
 "@[simp]\ntheorem inv_prod {i j} (w : neword G i j) : w.inv.prod = w.prod⁻¹ := by induction w <;> simp [inv, *]\n#align inv_prod inv_prod\n\n",
 "inv_last":
 "@[simp]\ntheorem inv_last {i j} (w : neword G i j) : w.inv.last = w.head⁻¹ := by induction w <;> simp [inv, *]\n#align inv_last inv_last\n\n",
 "inv_head":
 "@[simp]\ntheorem inv_head {i j} (w : neword G i j) : w.inv.head = w.last⁻¹ := by induction w <;> simp [inv, *]\n#align inv_head inv_head\n\n",
 "inv_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem inv_def (x : free_product G) :\n    x⁻¹ = mul_opposite.unop (lift (fun i => (of : «expr →* » (G i) _).op.comp (MulEquiv.inv' (G i)).to_monoid_hom) x) :=\n  rfl\n#align inv_def inv_def\n\n",
 "injective_lift_of_ping_pong":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n-- NB: One might expect this theorem to be phrased with ℤ, but ℤ is an additive group,\n-- and using `multiplicative ℤ` runs into diamond issues.\n-- A group action on α, and the ping-pong sets\n/-- The Ping-Pong-Lemma.\n\nGiven a group action of `G` on `X` so that the generators of the free groups act in specific\nways on disjoint subsets `X i` and `Y i` we can prove that `lift f` is injective, and thus the image\nof `lift f` is isomorphic to the free group.\n\nOften the Ping-Pong-Lemma is stated with regard to group elements that generate the whole group;\nwe generalize to arbitrary group homomorphisms from the free group to `G`  and do not require the\ngroup to be generated by the elements.\n-/\ntheorem _root_.free_group.injective_lift_of_ping_pong : function.injective (free_group.lift a) :=\n  by\n  -- Step one: express the free group lift via the free product lift\n  have :\n    free_group.lift a =\n      (free_product.lift fun i => free_group.lift fun _ => a i).comp (@free_group_equiv_free_product ι).to_monoid_hom :=\n    by\n    ext i\n    simp\n  rw [this]\n  clear this\n  refine' function.injective.comp _ (MulEquiv.injective _)\n  -- Step two: Invoke the ping-pong lemma for free products\n  show function.injective (lift fun i : ι => free_group.lift fun _ => a i)\n  -- Prepare to instantiate lift_injective_of_ping_pong\n  let H : ι → Type _ := fun i => free_group unit\n  let f : ∀ i, «expr →* » (H i) G := fun i => free_group.lift fun _ => a i\n  let X' : ι → set α := fun i => X i ∪ Y i\n  apply lift_injective_of_ping_pong f _ X'\n  show _ ∨ ∃ i, 3 ≤ cardinal.mk (H i)\n  · inhabit ι\n    right\n    use Inhabited.default ι\n    simp only [H]\n    rw [free_group.free_group_unit_equiv_int.cardinal_eq, cardinal.mk_denumerable]\n    apply le_of_lt\n    simp\n  show ∀ i, (X' i).nonempty\n  · exact fun i => Set.Nonempty.inl (hXnonempty i)\n  show Pairwise fun i j => Disjoint (X' i) (X' j)\n  · intro i j hij\n    simp only [X']\n    apply Disjoint.union_left <;> apply Disjoint.union_right\n    · exact hXdisj hij\n    · exact hXYdisj i j\n    · exact (hXYdisj j i).symm\n    · exact hYdisj hij\n  show Pairwise fun i j => ∀ h : H i, h ≠ 1 → «expr • » (f i h) (X' j) ⊆ X' i\n  · rintro i j hij\n    -- use free_group unit ≃ ℤ\n    refine' free_group.free_group_unit_equiv_int.forall_congr_left'.mpr _\n    intro n hne1\n    change «expr • » (free_group.lift (fun _ => a i) (free_group.of () ^ n)) (X' j) ⊆ X' i\n    simp only [map_zpow, free_group.lift.of]\n    change «expr • » (a i ^ n) (X' j) ⊆ X' i\n    have hnne0 : n ≠ 0 := by\n      rintro rfl\n      apply hne1\n      simpa\n    clear hne1\n    simp only [X']\n    -- Positive and negative powers separately\n    cases' (lt_or_gt_of_ne hnne0).swap with hlt hgt\n    · have h1n : 1 ≤ n := hlt\n      calc\n        «expr • » (a i ^ n) (X' j) ⊆ «expr • » (a i ^ n) («expr ᶜ» (Y i)) :=\n          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right\n        _ ⊆ X i := by\n          refine' Int.le_induction _ _ _ h1n\n          · rw [zpow_one]\n            exact hX i\n          · intro n hle hi\n            calc\n              «expr • » (a i ^ (n + 1)) («expr ᶜ» (Y i)) = «expr • » (a i ^ n * a i) («expr ᶜ» (Y i)) := by\n                rw [zpow_add, zpow_one]\n              _ = «expr • » (a i ^ n) («expr • » (a i) («expr ᶜ» (Y i))) := mul_action.mul_smul _ _ _\n              _ ⊆ «expr • » (a i ^ n) (X i) := smul_set_mono <| hX i\n              _ ⊆ «expr • » (a i ^ n) («expr ᶜ» (Y i)) := smul_set_mono (hXYdisj i i).subset_compl_right\n              _ ⊆ X i := hi\n              \n        _ ⊆ X' i := Set.subset_union_left _ _\n        \n    · have h1n : n ≤ -1 := by\n        apply int.le_of_lt_add_one\n        simpa using hgt\n      calc\n        «expr • » (a i ^ n) (X' j) ⊆ «expr • » (a i ^ n) («expr ᶜ» (X i)) :=\n          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right\n        _ ⊆ Y i := by\n          refine' Int.le_induction_down _ _ _ h1n\n          · rw [zpow_neg, zpow_one]\n            exact hY i\n          · intro n hle hi\n            calc\n              «expr • » (a i ^ (n - 1)) («expr ᶜ» (X i)) = «expr • » (a i ^ n * (a i)⁻¹) («expr ᶜ» (X i)) := by\n                rw [zpow_sub, zpow_one]\n              _ = «expr • » (a i ^ n) («expr • » (a i)⁻¹ («expr ᶜ» (X i))) := mul_action.mul_smul _ _ _\n              _ ⊆ «expr • » (a i ^ n) (Y i) := smul_set_mono <| hY i\n              _ ⊆ «expr • » (a i ^ n) («expr ᶜ» (X i)) := smul_set_mono (hXYdisj i i).symm.subset_compl_right\n              _ ⊆ Y i := hi\n              \n        _ ⊆ X' i := Set.subset_union_right _ _\n        \n#align free_group.injective_lift_of_ping_pong free_group.injective_lift_of_ping_pong\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem induction_on {C : free_product M → Prop} (m : free_product M) (h_one : C 1) (h_of : ∀ (i) (m : M i), C (of m))\n    (h_mul : ∀ x y, C x → C y → C (x * y)) : C m :=\n  by\n  let S : Submonoid (free_product M) := submonoid.mk (set_of C) h_mul h_one\n  convert subtype.prop (lift (fun i => of.cod_restrict S (h_of i)) m)\n  change MonoidHom.id _ m = S.subtype.comp _ m\n  congr\n  ext\n  simp [MonoidHom.codRestrict]\n#align induction_on induction_on\n\n",
 "fst_idx_ne_iff":
 "theorem fst_idx_ne_iff {w : word M} {i} : fst_idx w ≠ some i ↔ ∀ l ∈ w.to_list.head', i ≠ sigma.fst l :=\n  not_iff_not.mp <| by simp [fst_idx]\n#align fst_idx_ne_iff fst_idx_ne_iff\n\n",
 "ext_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem ext_hom (f g : «expr →* » (free_product M) N) (h : ∀ i, f.comp (of : «expr →* » (M i) _) = g.comp of) : f = g :=\n  (MonoidHom.cancel_right con.mk'_surjective).mp <|\n    FreeMonoid.hom_eq fun ⟨i, x⟩ => by\n      rw [MonoidHom.comp_apply, MonoidHom.comp_apply, ← of_apply, ← MonoidHom.comp_apply, ← MonoidHom.comp_apply, h]\n#align ext_hom ext_hom\n\n",
 "equiv_pair_symm":
 "-- This definition is computable but not very nice to look at. Thankfully we don't have to inspect\n-- it, since `rcons` is known to be injective.\ntheorem equiv_pair_symm (i) (p : pair M i) : (equiv_pair i).symm p = rcons p :=\n  rfl\n#align equiv_pair_symm equiv_pair_symm\n\n",
 "equiv_pair_eq_of_fst_idx_ne":
 "theorem equiv_pair_eq_of_fst_idx_ne {i} {w : word M} (h : fst_idx w ≠ some i) : equiv_pair i w = ⟨1, w, h⟩ :=\n  (equiv_pair i).apply_eq_iff_eq_symm_apply.mpr <| eq.symm (dif_pos rfl)\n#align equiv_pair_eq_of_fst_idx_ne equiv_pair_eq_of_fst_idx_ne\n\n",
 "empty_of_word_prod_eq_one":
 "theorem empty_of_word_prod_eq_one {w : word H} (h : lift f w.prod = 1) : w = word.empty :=\n  by\n  by_contra hnotempty\n  obtain ⟨i, j, w, rfl⟩ := neword.of_word w hnotempty\n  exact lift_word_prod_nontrivial_of_not_empty f hcard X hXnonempty hXdisj hpp w h\n#align empty_of_word_prod_eq_one empty_of_word_prod_eq_one\n\n",
 "cons_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem cons_eq_smul {i} {m : M i} {ls h1 h2} :\n    word.mk (sym.cons' ⟨i, m⟩ ls) h1 h2 = «expr • » (of m) (mk_aux ls h1 h2) := by\n  rw [cons_eq_rcons, of_smul_def, equiv_pair_eq_of_fst_idx_ne _] <;> simp only [mul_one]\n#align cons_eq_smul cons_eq_smul\n\n",
 "cons_eq_rcons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem cons_eq_rcons {i} {m : M i} {ls h1 h2} :\n    word.mk (sym.cons' ⟨i, m⟩ ls) h1 h2 = rcons ⟨m, mk_aux ls h1 h2, fst_idx_ne_iff.mpr h2.rel_head'⟩ :=\n  by\n  rw [rcons, dif_neg]\n  rfl\n  exact h1 ⟨i, m⟩ (ls.mem_cons_self _)\n#align cons_eq_rcons cons_eq_rcons\n\n",
 "append_prod":
 "@[simp]\ntheorem append_prod {i j k l} {w₁ : neword M i j} {hne : j ≠ k} {w₂ : neword M k l} :\n    (append w₁ hne w₂).prod = w₁.prod * w₂.prod := by simp [to_word, Prod, word.prod]\n#align append_prod append_prod\n\n",
 "append_last":
 "@[simp]\ntheorem append_last {i j k l} {w₁ : neword M i j} {hne : j ≠ k} {w₂ : neword M k l} :\n    (append w₁ hne w₂).last = w₂.last :=\n  rfl\n#align append_last append_last\n\n",
 "append_head":
 "@[simp]\ntheorem append_head {i j k l} {w₁ : neword M i j} {hne : j ≠ k} {w₂ : neword M k l} :\n    (append w₁ hne w₂).head = w₁.head :=\n  rfl\n#align append_head append_head\n\n"}