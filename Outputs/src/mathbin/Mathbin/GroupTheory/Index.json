{"sq_mem_of_index_two":
 "@[to_additive two_smul_mem_of_index_two]\ntheorem sq_mem_of_index_two (h : H.index = 2) (a : G) : a ^ 2 ∈ H :=\n  (pow_two a).symm ▸ mul_self_mem_of_index_two h a\n#align sq_mem_of_index_two sq_mem_of_index_two\n\n",
 "relindex_top_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem relindex_top_right : H.relindex («expr⊤») = H.index := by\n  rw [← relindex_mul_index (show H ≤ «expr⊤» from le_top), index_top, mul_one]\n#align relindex_top_right relindex_top_right\n\n",
 "relindex_top_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem relindex_top_left : («expr⊤» : Subgroup G).relindex H = 1 :=\n  index_top\n#align relindex_top_left relindex_top_left\n\n",
 "relindex_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp, to_additive]\ntheorem relindex_sup_right [K.normal] : K.relindex («expr ⊔ » H K) = K.relindex H :=\n  Nat.card_congr (QuotientGroup.quotientInfEquivProdNormalQuotient H K).to_equiv.symm\n#align relindex_sup_right relindex_sup_right\n\n",
 "relindex_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp, to_additive]\ntheorem relindex_sup_left [K.normal] : K.relindex («expr ⊔ » K H) = K.relindex H := by rw [sup_comm, relindex_sup_right]\n#align relindex_sup_left relindex_sup_left\n\n",
 "relindex_subgroup_of":
 "@[to_additive]\ntheorem relindex_subgroup_of (hKL : K ≤ L) : (H.subgroup_of L).relindex (K.subgroup_of L) = H.relindex K :=\n  ((index_comap (H.subgroup_of L) (inclusion hKL)).trans (congr_arg _ (inclusion_range hKL))).symm\n#align relindex_subgroup_of relindex_subgroup_of\n\n",
 "relindex_self":
 "@[simp, to_additive]\ntheorem relindex_self : H.relindex H = 1 := by rw [relindex, subgroup_of_self, index_top]\n#align relindex_self relindex_self\n\n",
 "relindex_ne_zero_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem relindex_ne_zero_trans (hHK : H.relindex K ≠ 0) (hKL : K.relindex L ≠ 0) : H.relindex L ≠ 0 := fun h =>\n  mul_ne_zero (mt (relindex_eq_zero_of_le_right (show «expr ⊓ » K L ≤ K from inf_le_left)) hHK) hKL\n    ((relindex_inf_mul_relindex H K L).trans (relindex_eq_zero_of_le_left inf_le_left h))\n#align relindex_ne_zero_trans relindex_ne_zero_trans\n\n",
 "relindex_mul_relindex":
 "@[to_additive relindex_mul_relindex]\ntheorem relindex_mul_relindex (hHK : H ≤ K) (hKL : K ≤ L) : H.relindex K * K.relindex L = H.relindex L :=\n  by\n  rw [← relindex_subgroup_of hKL]\n  exact relindex_mul_index fun x hx => hHK hx\n#align relindex_mul_relindex relindex_mul_relindex\n\n",
 "relindex_mul_index":
 "@[to_additive relindex_mul_index]\ntheorem relindex_mul_index (h : H ≤ K) : H.relindex K * K.index = H.index :=\n  ((mul_comm _ _).trans (Cardinal.toNat_mul _ _).symm).trans\n    (congr_arg Cardinal.toNat (Equiv.cardinal_eq (quotientEquivProdOfLe h))).symm\n#align relindex_mul_index relindex_mul_index\n\n",
 "relindex_le_of_le_right":
 "@[to_additive]\ntheorem relindex_le_of_le_right (hKL : K ≤ L) (hHL : H.relindex L ≠ 0) : H.relindex K ≤ H.relindex L :=\n  Finite.card_le_of_embedding' (quotientSubgroupOfEmbeddingOfLe H hKL) fun h => (hHL h).elim\n#align relindex_le_of_le_right relindex_le_of_le_right\n\n",
 "relindex_le_of_le_left":
 "@[to_additive]\ntheorem relindex_le_of_le_left (hHK : H ≤ K) (hHL : H.relindex L ≠ 0) : K.relindex L ≤ H.relindex L :=\n  nat.le_of_dvd (nat.pos_of_ne_zero hHL) (relindex_dvd_of_le_left L hHK)\n#align relindex_le_of_le_left relindex_le_of_le_left\n\n",
 "relindex_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem relindex_ker {H} [Group H] (f : «expr →* » G H) (K : Subgroup G) :\n    f.ker.relindex K = Nat.card («expr '' » f K) :=\n  by\n  rw [← MonoidHom.comap_bot, relindex_comap, relindex_bot_left]\n  rfl\n#align relindex_ker relindex_ker\n\n",
 "relindex_infi_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem relindex_infi_ne_zero {ι : Type _} [hι : Finite ι] {f : ι → Subgroup G} (hf : ∀ i, (f i).relindex L ≠ 0) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).relindex L ≠\n      0 :=\n  haveI := Fintype.ofFinite ι\n  (finset.prod_ne_zero_iff.mpr fun i hi => hf i) ∘\n    nat.card_pi.symm.trans ∘ Finite.card_eq_zero_of_embedding (quotient_infi_subgroup_of_embedding f L)\n#align relindex_infi_ne_zero relindex_infi_ne_zero\n\n",
 "relindex_infi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem relindex_infi_le {ι : Type _} [Fintype ι] (f : ι → Subgroup G) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).relindex L ≤\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        ((f i).relindex L) :=\n  le_of_le_of_eq\n    (Finite.card_le_of_embedding' (quotientInfᵢSubgroupOfEmbedding f L) fun h =>\n      let ⟨i, hi, h⟩ := Finset.prod_eq_zero_iff.mp (Nat.card_pi.symm.trans h)\n      relindex_eq_zero_of_le_left (infᵢ_le f i) h)\n    Nat.card_pi\n#align relindex_infi_le relindex_infi_le\n\n",
 "relindex_inf_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem relindex_inf_ne_zero (hH : H.relindex L ≠ 0) (hK : K.relindex L ≠ 0) : («expr ⊓ » H K).relindex L ≠ 0 :=\n  by\n  replace hH : H.relindex («expr ⊓ » K L) ≠ 0 := mt (relindex_eq_zero_of_le_right inf_le_right) hH\n  rw [← inf_relindex_right] at hH hK⊢\n  rw [inf_assoc]\n  exact relindex_ne_zero_trans hH hK\n#align relindex_inf_ne_zero relindex_inf_ne_zero\n\n",
 "relindex_inf_mul_relindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive relindex_inf_mul_relindex]\ntheorem relindex_inf_mul_relindex : H.relindex («expr ⊓ » K L) * K.relindex L = («expr ⊓ » H K).relindex L := by\n  rw [← inf_relindex_right H («expr ⊓ » K L), ← inf_relindex_right K L, ← inf_relindex_right («expr ⊓ » H K) L,\n    inf_assoc, relindex_mul_relindex («expr ⊓ » H («expr ⊓ » K L)) («expr ⊓ » K L) L inf_le_right inf_le_right]\n#align relindex_inf_mul_relindex relindex_inf_mul_relindex\n\n",
 "relindex_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem relindex_inf_le : («expr ⊓ » H K).relindex L ≤ H.relindex L * K.relindex L :=\n  by\n  by_cases h : H.relindex L = 0\n  · exact (le_of_eq (relindex_eq_zero_of_le_left inf_le_left h)).trans (zero_le _)\n  rw [← inf_relindex_right, inf_assoc, ← relindex_mul_relindex _ _ L inf_le_right inf_le_right, inf_relindex_right,\n    inf_relindex_right]\n  exact mul_le_mul_right' (relindex_le_of_le_right inf_le_right h) (K.relindex L)\n#align relindex_inf_le relindex_inf_le\n\n",
 "relindex_eq_zero_of_le_right":
 "@[to_additive]\ntheorem relindex_eq_zero_of_le_right (hKL : K ≤ L) (hHK : H.relindex K = 0) : H.relindex L = 0 :=\n  Finite.card_eq_zero_of_embedding (quotientSubgroupOfEmbeddingOfLe H hKL) hHK\n#align relindex_eq_zero_of_le_right relindex_eq_zero_of_le_right\n\n",
 "relindex_eq_zero_of_le_left":
 "@[to_additive]\ntheorem relindex_eq_zero_of_le_left (hHK : H ≤ K) (hKL : K.relindex L = 0) : H.relindex L = 0 :=\n  eq_zero_of_zero_dvd (hKL ▸ relindex_dvd_of_le_left L hHK)\n#align relindex_eq_zero_of_le_left relindex_eq_zero_of_le_left\n\n",
 "relindex_eq_one":
 "@[simp, to_additive relindex_eq_one]\ntheorem relindex_eq_one : H.relindex K = 1 ↔ K ≤ H :=\n  index_eq_one.trans subgroupOf_eq_top\n#align relindex_eq_one relindex_eq_one\n\n",
 "relindex_dvd_of_le_left":
 "@[to_additive]\ntheorem relindex_dvd_of_le_left (hHK : H ≤ K) : K.relindex L ∣ H.relindex L :=\n  inf_of_le_left hHK ▸ dvd_of_mul_left_eq _ (relindex_inf_mul_relindex _ _ _)\n#align relindex_dvd_of_le_left relindex_dvd_of_le_left\n\n",
 "relindex_dvd_index_of_normal":
 "@[to_additive]\ntheorem relindex_dvd_index_of_normal [H.normal] : H.relindex K ∣ H.index :=\n  relindex_sup_right K H ▸ relindex_dvd_index_of_le le_sup_right\n#align relindex_dvd_index_of_normal relindex_dvd_index_of_normal\n\n",
 "relindex_dvd_index_of_le":
 "@[to_additive]\ntheorem relindex_dvd_index_of_le (h : H ≤ K) : H.relindex K ∣ H.index :=\n  dvd_of_mul_right_eq K.index (relindex_mul_index h)\n#align relindex_dvd_index_of_le relindex_dvd_index_of_le\n\n",
 "relindex_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem relindex_comap {G' : Type _} [Group G'] (f : «expr →* » G' G) (K : Subgroup G') :\n    relindex (comap f H) K = relindex H (map f K) := by\n  rw [relindex, subgroup_of, comap_comap, index_comap, ← f.map_range, K.subtype_range]\n#align relindex_comap relindex_comap\n\n",
 "relindex_bot_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem relindex_bot_right : H.relindex («expr⊥») = 1 := by rw [relindex, subgroup_of_bot_eq_top, index_top]\n#align relindex_bot_right relindex_bot_right\n\n",
 "relindex_bot_left_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem relindex_bot_left_eq_card [Fintype H] : («expr⊥» : Subgroup G).relindex H = Fintype.card H :=\n  H.relindex_bot_left.trans Nat.card_eq_fintype_card\n#align relindex_bot_left_eq_card relindex_bot_left_eq_card\n\n",
 "relindex_bot_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem relindex_bot_left : («expr⊥» : Subgroup G).relindex H = Nat.card H := by\n  rw [relindex, bot_subgroup_of, index_bot]\n#align relindex_bot_left relindex_bot_left\n\n",
 "one_lt_index_of_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive one_lt_index_of_ne_top]\ntheorem one_lt_index_of_ne_top [Finite («expr ⧸ » G H)] (hH : H ≠ «expr⊤») : 1 < H.index :=\n  Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨index_ne_zero_of_finite, mt index_eq_one.mp hH⟩\n#align one_lt_index_of_ne_top one_lt_index_of_ne_top\n\n",
 "nat_card_dvd_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem nat_card_dvd_of_surjective {G H : Type _} [Group G] [Group H] (f : «expr →* » G H)\n    (hf : function.surjective f) : Nat.card H ∣ Nat.card G :=\n  by\n  rw [← Nat.card_congr (QuotientGroup.quotientKerEquivOfSurjective f hf).to_equiv]\n  exact Dvd.intro_left (Nat.card f.ker) f.ker.card_mul_index\n#align nat_card_dvd_of_surjective nat_card_dvd_of_surjective\n\n",
 "nat_card_dvd_of_le":
 "@[to_additive]\ntheorem nat_card_dvd_of_le (hHK : H ≤ K) : Nat.card H ∣ Nat.card K :=\n  nat_card_dvd_of_injective (inclusion hHK) (inclusion_injective hHK)\n#align nat_card_dvd_of_le nat_card_dvd_of_le\n\n",
 "nat_card_dvd_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem nat_card_dvd_of_injective {G H : Type _} [Group G] [Group H] (f : «expr →* » G H) (hf : function.injective f) :\n    Nat.card G ∣ Nat.card H := by\n  rw [Nat.card_congr (MonoidHom.ofInjective hf).to_equiv]\n  exact Dvd.intro f.range.index f.range.card_mul_index\n#align nat_card_dvd_of_injective nat_card_dvd_of_injective\n\n",
 "mul_self_mem_of_index_two":
 "@[to_additive]\ntheorem mul_self_mem_of_index_two (h : H.index = 2) (a : G) : a * a ∈ H := by rw [mul_mem_iff_of_index_two h]\n#align mul_self_mem_of_index_two mul_self_mem_of_index_two\n\n",
 "mul_mem_iff_of_index_two":
 "@[to_additive]\ntheorem mul_mem_iff_of_index_two (h : H.index = 2) {a b : G} : a * b ∈ H ↔ (a ∈ H ↔ b ∈ H) :=\n  by\n  by_cases ha : a ∈ H; · simp only [ha, true_iff_iff, mul_mem_cancel_left ha]\n  by_cases hb : b ∈ H; · simp only [hb, iff_true_iff, mul_mem_cancel_right hb]\n  simp only [ha, hb, iff_self_iff, iff_true_iff]\n  rcases index_eq_two_iff.1 h with ⟨c, hc⟩\n  refine' (hc _).or.resolve_left _\n  rwa [mul_assoc, mul_mem_cancel_right ((hc _).or.resolve_right hb)]\n#align mul_mem_iff_of_index_two mul_mem_iff_of_index_two\n\n",
 "inf_relindex_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem inf_relindex_right : («expr ⊓ » H K).relindex K = H.relindex K := by\n  rw [relindex, relindex, inf_subgroup_of_right]\n#align inf_relindex_right inf_relindex_right\n\n",
 "inf_relindex_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem inf_relindex_left : («expr ⊓ » H K).relindex H = K.relindex H := by rw [inf_comm, inf_relindex_right]\n#align inf_relindex_left inf_relindex_left\n\n",
 "index_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem index_top : («expr⊤» : Subgroup G).index = 1 :=\n  Cardinal.toNat_eq_one_iff_unique.mpr ⟨QuotientGroup.subsingleton_quotient_top, ⟨1⟩⟩\n#align index_top index_top\n\n",
 "index_ne_zero_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem index_ne_zero_of_finite [hH : Finite («expr ⧸ » G H)] : H.index ≠ 0 :=\n  by\n  cases nonempty_fintype («expr ⧸ » G H)\n  rw [index_eq_card]\n  exact Fintype.card_ne_zero\n#align index_ne_zero_of_finite index_ne_zero_of_finite\n\n",
 "index_mul_card":
 "@[to_additive index_mul_card]\ntheorem index_mul_card [Fintype G] [hH : Fintype H] : H.index * Fintype.card H = Fintype.card G := by\n  rw [← relindex_bot_left_eq_card, ← index_bot_eq_card, mul_comm] <;> exact relindex_mul_index bot_le\n#align index_mul_card index_mul_card\n\n",
 "index_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem index_map_eq {G' : Type _} [Group G'] {f : «expr →* » G G'} (hf1 : function.surjective f) (hf2 : f.ker ≤ H) :\n    (H.map f).index = H.index :=\n  nat.dvd_antisymm (H.index_map_dvd hf1) (H.dvd_index_map hf2)\n#align index_map_eq index_map_eq\n\n",
 "index_map_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem index_map_dvd {G' : Type _} [Group G'] {f : «expr →* » G G'} (hf : function.surjective f) :\n    (H.map f).index ∣ H.index :=\n  by\n  rw [index_map, f.range_top_of_surjective hf, index_top, mul_one]\n  exact index_dvd_of_le le_sup_left\n#align index_map_dvd index_map_dvd\n\n",
 "index_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem index_map {G' : Type _} [Group G'] (f : «expr →* » G G') :\n    (H.map f).index = («expr ⊔ » H f.ker).index * f.range.index := by\n  rw [← comap_map_eq, index_comap, relindex_mul_index (H.map_le_range f)]\n#align index_map index_map\n\n",
 "index_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem index_ker {H} [Group H] (f : «expr →* » G H) : f.ker.index = Nat.card (Set.range f) :=\n  by\n  rw [← MonoidHom.comap_bot, index_comap, relindex_bot_left]\n  rfl\n#align index_ker index_ker\n\n",
 "index_infi_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem index_infi_ne_zero {ι : Type _} [Finite ι] {f : ι → Subgroup G} (hf : ∀ i, (f i).index ≠ 0) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).index ≠ 0 :=\n  by\n  simp_rw [← relindex_top_right] at hf⊢\n  exact relindex_infi_ne_zero hf\n#align index_infi_ne_zero index_infi_ne_zero\n\n",
 "index_infi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem index_infi_le {ι : Type _} [Fintype ι] (f : ι → Subgroup G) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)).index ≤\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f i).index :=\n  by simp_rw [← relindex_top_right, relindex_infi_le]\n#align index_infi_le index_infi_le\n\n",
 "index_inf_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem index_inf_ne_zero (hH : H.index ≠ 0) (hK : K.index ≠ 0) : («expr ⊓ » H K).index ≠ 0 :=\n  by\n  rw [← relindex_top_right] at hH hK⊢\n  exact relindex_inf_ne_zero hH hK\n#align index_inf_ne_zero index_inf_ne_zero\n\n",
 "index_inf_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[to_additive]\ntheorem index_inf_le : («expr ⊓ » H K).index ≤ H.index * K.index := by simp_rw [← relindex_top_right, relindex_inf_le]\n#align index_inf_le index_inf_le\n\n",
 "index_eq_zero_of_relindex_eq_zero":
 "@[to_additive]\ntheorem index_eq_zero_of_relindex_eq_zero (h : H.relindex K = 0) : H.index = 0 :=\n  H.relindex_top_right.symm.trans (relindex_eq_zero_of_le_right le_top h)\n#align index_eq_zero_of_relindex_eq_zero index_eq_zero_of_relindex_eq_zero\n\n",
 "index_eq_two_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\n@[to_additive\n      \"/-- An additive subgroup has index two if and only if there exists `a` such that for\\nall `b`, exactly one of `b + a` and `b` belong to `H`. -/\"]\ntheorem index_eq_two_iff : H.index = 2 ↔ ∃ a, ∀ b, Xor' (b * a ∈ H) (b ∈ H) :=\n  by\n  simp only [index, Nat.card_eq_two_iff' ((1 : G) : «expr ⧸ » G H), exists_unique, inv_mem_iff, QuotientGroup.exists_mk,\n    QuotientGroup.forall_mk, ne.def, QuotientGroup.eq, mul_one, xor_iff_iff_not]\n  refine' exists_congr fun a => ⟨fun ha b => ⟨fun hba hb => _, fun hb => _⟩, fun ha => ⟨_, fun b hb => _⟩⟩\n  · exact ha.1 ((mul_mem_cancel_left hb).1 hba)\n  · exact inv_inv b ▸ ha.2 _ (mt inv_mem_iff.1 hb)\n  · rw [← inv_mem_iff, ← ha, inv_mul_self]\n    exact one_mem _\n  · rwa [ha, inv_mem_iff]\n#align index_eq_two_iff index_eq_two_iff\n\n",
 "index_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive index_eq_one]\ntheorem index_eq_one : H.index = 1 ↔ H = «expr⊤» :=\n  ⟨fun h => QuotientGroup.subgroup_eq_top_of_subsingleton H (Cardinal.toNat_eq_one_iff_unique.mp h).1, fun h =>\n    (congr_arg index h).trans index_top⟩\n#align index_eq_one index_eq_one\n\n",
 "index_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem index_eq_card [Fintype («expr ⧸ » G H)] : H.index = Fintype.card («expr ⧸ » G H) :=\n  Nat.card_eq_fintype_card\n#align index_eq_card index_eq_card\n\n",
 "index_dvd_of_le":
 "@[to_additive]\ntheorem index_dvd_of_le (h : H ≤ K) : K.index ∣ H.index :=\n  dvd_of_mul_left_eq (H.relindex K) (relindex_mul_index h)\n#align index_dvd_of_le index_dvd_of_le\n\n",
 "index_dvd_card":
 "@[to_additive]\ntheorem index_dvd_card [Fintype G] : H.index ∣ Fintype.card G := by\n  classical exact ⟨Fintype.card H, H.index_mul_card.symm⟩\n#align index_dvd_card index_dvd_card\n\n",
 "index_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-\nCopyright (c) 2021 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\n@[to_additive]\ntheorem index_comap_of_surjective {G' : Type _} [Group G'] {f : «expr →* » G' G} (hf : function.surjective f) :\n    (H.comap f).index = H.index := by\n  letI := QuotientGroup.leftRel H\n  letI := QuotientGroup.leftRel (H.comap f)\n  have key : ∀ x y : G', Setoid.r x y ↔ Setoid.r (f x) (f y) :=\n    by\n    simp only [QuotientGroup.leftRel_apply]\n    exact fun x y => iff_of_eq (congr_arg (· ∈ H) (by rw [f.map_mul, f.map_inv]))\n  refine' Cardinal.toNat_congr (Equiv.ofBijective (Quotient.map' f fun x y => (key x y).mp) ⟨_, _⟩)\n  · simp_rw [← Quotient.eq''] at key\n    refine' Quotient.ind' fun x => _\n    refine' Quotient.ind' fun y => _\n    exact (key x y).mpr\n  · refine' Quotient.ind' fun x => _\n    obtain ⟨y, hy⟩ := hf x\n    exact ⟨y, (quotient.map'_mk' f _ y).trans (congr_arg Quotient.mk'' hy)⟩\n#align index_comap_of_surjective index_comap_of_surjective\n\n",
 "index_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem index_comap {G' : Type _} [Group G'] (f : «expr →* » G' G) : (H.comap f).index = H.relindex f.range :=\n  Eq.trans (congr_arg index (by rfl)) ((H.subgroup_of f.range).index_comap_of_surjective f.range_restrict_surjective)\n#align index_comap index_comap\n\n",
 "index_center_le_pow":
 "theorem index_center_le_pow [Finite (commutatorSet G)] [Group.Fg G] :\n    (center G).index ≤ Nat.card (commutatorSet G) ^ Group.rank G :=\n  by\n  obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n  rw [← hS1, ← Fintype.card_coe, ← Nat.card_eq_fintype_card, ← Finset.coe_sort_coe, ← Nat.card_fun]\n  exact Finite.card_le_of_embedding (quotient_center_embedding hS2)\n#align index_center_le_pow index_center_le_pow\n\n",
 "index_bot_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem index_bot_eq_card [Fintype G] : («expr⊥» : Subgroup G).index = Fintype.card G :=\n  index_bot.trans Nat.card_eq_fintype_card\n#align index_bot_eq_card index_bot_eq_card\n\n",
 "index_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem index_bot : («expr⊥» : Subgroup G).index = Nat.card G :=\n  Cardinal.toNat_congr QuotientGroup.quotientBot.to_equiv\n#align index_bot index_bot\n\n",
 "finite_index_of_le":
 "@[to_additive]\ntheorem finite_index_of_le [FiniteIndex H] (h : H ≤ K) : FiniteIndex K :=\n  ⟨ne_zero_of_dvd_ne_zero finite_index.finite_index (index_dvd_of_le h)⟩\n#align finite_index_of_le finite_index_of_le\n\n",
 "finite_index_of_finite_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive]\ntheorem finite_index_of_finite_quotient [Finite («expr ⧸ » G H)] : FiniteIndex H :=\n  ⟨index_ne_zero_of_finite⟩\n#align finite_index_of_finite_quotient finite_index_of_finite_quotient\n\n",
 "dvd_index_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem dvd_index_map {G' : Type _} [Group G'] {f : «expr →* » G G'} (hf : f.ker ≤ H) : H.index ∣ (H.map f).index :=\n  by\n  rw [index_map, sup_of_le_left hf]\n  apply dvd_mul_right\n#align dvd_index_map dvd_index_map\n\n",
 "card_mul_index":
 "@[simp, to_additive card_mul_index]\ntheorem card_mul_index : Nat.card H * H.index = Nat.card G :=\n  by\n  rw [← relindex_bot_left, ← index_bot]\n  exact relindex_mul_index bot_le\n#align card_mul_index card_mul_index\n\n",
 "card_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive card_eq_one]\ntheorem card_eq_one : Nat.card H = 1 ↔ H = «expr⊥» :=\n  H.relindex_bot_left ▸ relindex_eq_one.trans le_bot_iff\n#align card_eq_one card_eq_one\n\n",
 "card_dvd_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem card_dvd_of_surjective {G H : Type _} [Group G] [Group H] [Fintype G] [Fintype H] (f : «expr →* » G H)\n    (hf : function.surjective f) : Fintype.card H ∣ Fintype.card G := by\n  simp only [← Nat.card_eq_fintype_card, nat_card_dvd_of_surjective f hf]\n#align card_dvd_of_surjective card_dvd_of_surjective\n\n"}