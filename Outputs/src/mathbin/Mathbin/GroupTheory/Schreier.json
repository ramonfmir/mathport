{"rank_le_index_mul_rank":
 "theorem rank_le_index_mul_rank [hG : group.fg G] [finite_index H] : group.rank H ≤ H.index * group.rank G :=\n  by\n  haveI := H.fg_of_index_ne_zero\n  obtain ⟨S, hS₀, hS⟩ := group.rank_spec G\n  obtain ⟨T, hT₀, hT⟩ := exists_finset_card_le_mul H hS\n  calc\n    group.rank H ≤ T.card := group.rank_le H hT\n    _ ≤ H.index * S.card := hT₀\n    _ = H.index * group.rank G := congr_arg ((· * ·) H.index) hS₀\n    \n#align rank_le_index_mul_rank rank_le_index_mul_rank\n\n",
 "exists_finset_card_le_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem exists_finset_card_le_mul [finite_index H] {S : Finset G} (hS : closure (S : set G) = «expr⊤») :\n    ∃ T : Finset H, T.card ≤ H.index * S.card ∧ closure (T : set H) = «expr⊤» :=\n  by\n  letI := H.fintype_quotient_of_finite_index\n  haveI : decidable_eq G := classical.dec_eq G\n  obtain ⟨R₀, hR : R₀ ∈ right_transversals (H : set G), hR1⟩ := exists_right_transversal (1 : G)\n  haveI : fintype R₀ := fintype.of_equiv _ (mem_right_transversals.to_equiv hR)\n  let R : Finset G := set.to_finset R₀\n  replace hR : (R : set G) ∈ right_transversals (H : set G) := by rwa [set.coe_to_finset]\n  replace hR1 : (1 : G) ∈ R := by rwa [set.mem_to_finset]\n  refine' ⟨_, _, closure_mul_image_eq_top' hR hR1 hS⟩\n  calc\n    _ ≤ (R * S).card := finset.card_image_le\n    _ ≤ (finset.product R S).card := finset.card_image_le\n    _ = R.card * S.card := R.card_product S\n    _ = H.index * S.card := congr_arg (· * S.card) _\n    \n  calc\n    R.card = fintype.card R := (fintype.card_coe R).symm\n    _ = _ := (fintype.card_congr (mem_right_transversals.to_equiv hR)).symm\n    _ = fintype.card («expr ⧸ » G H) := quotient_group.card_quotient_right_rel H\n    _ = H.index := H.index_eq_card.symm\n    \n#align exists_finset_card_le_mul exists_finset_card_le_mul\n\n",
 "closure_mul_image_mul_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem closure_mul_image_mul_eq_top (hR : R ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R)\n    (hS : closure S = «expr⊤») : (closure ((R * S).image fun g => g * (to_fun hR g)⁻¹) : set G) * R = «expr⊤» :=\n  by\n  let f : G → R := fun g => to_fun hR g\n  let U : set G := (R * S).image fun g => g * (f g)⁻¹\n  change (closure U : set G) * R = «expr⊤»\n  refine' top_le_iff.mp fun g hg => _\n  apply closure_induction_right (eq_top_iff.mp hS (mem_top g))\n  · exact ⟨1, 1, (closure U).one_mem, hR1, one_mul 1⟩\n  · rintro - s hs ⟨u, r, hu, hr, rfl⟩\n    rw [show u * r * s = u * (r * s * (f (r * s))⁻¹) * f (r * s) by group]\n    refine' Set.mul_mem_mul ((closure U).mul_mem hu _) (f (r * s)).coe_prop\n    exact subset_closure ⟨r * s, Set.mul_mem_mul hr hs, rfl⟩\n  · rintro - s hs ⟨u, r, hu, hr, rfl⟩\n    rw [show u * r * s⁻¹ = u * (f (r * s⁻¹) * s * r⁻¹)⁻¹ * f (r * s⁻¹) by group]\n    refine' Set.mul_mem_mul ((closure U).mul_mem hu ((closure U).inv_mem _)) (f (r * s⁻¹)).2\n    refine' subset_closure ⟨f (r * s⁻¹) * s, Set.mul_mem_mul (f (r * s⁻¹)).2 hs, _⟩\n    rw [mul_right_inj, inv_inj, ← subtype.coe_mk r hr, ← subtype.ext_iff, subtype.coe_mk]\n    apply\n      (mem_right_transversals_iff_exists_unique_mul_inv_mem.mp hR (f (r * s⁻¹) * s)).unique\n        (mul_inv_to_fun_mem hR (f (r * s⁻¹) * s))\n    rw [mul_assoc, ← inv_inv s, ← mul_inv_rev, inv_inv]\n    exact to_fun_mul_inv_mem hR (r * s⁻¹)\n#align closure_mul_image_mul_eq_top closure_mul_image_mul_eq_top\n\n",
 "closure_mul_image_eq_top'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Schreier's Lemma**: If `R : finset G` is a right_transversal of `H : subgroup G`\n  with `1 ∈ R`, and if `G` is generated by `S : finset G`, then `H` is generated by the `finset`\n  `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`. -/\ntheorem closure_mul_image_eq_top' [decidable_eq G] {R S : Finset G} (hR : (R : set G) ∈ right_transversals (H : set G))\n    (hR1 : (1 : G) ∈ R) (hS : closure (S : set G) = «expr⊤») :\n    closure (((R * S).image fun g => ⟨_, mul_inv_to_fun_mem hR g⟩ : Finset H) : set H) = «expr⊤» :=\n  by\n  rw [Finset.coe_image, finset.coe_mul]\n  exact closure_mul_image_eq_top hR hR1 hS\n#align closure_mul_image_eq_top' closure_mul_image_eq_top'\n\n",
 "closure_mul_image_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Schreier's Lemma**: If `R : set G` is a right_transversal of `H : subgroup G`\n  with `1 ∈ R`, and if `G` is generated by `S : set G`, then `H` is generated by the `set`\n  `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`. -/\ntheorem closure_mul_image_eq_top (hR : R ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R)\n    (hS : closure S = «expr⊤») :\n    closure ((R * S).image fun g => ⟨g * (to_fun hR g)⁻¹, mul_inv_to_fun_mem hR g⟩ : set H) = «expr⊤» :=\n  by\n  rw [eq_top_iff, ← map_subtype_le_map_subtype, monoid_hom.map_closure, Set.image_image]\n  exact (map_subtype_le («expr⊤»)).trans (ge_of_eq (closure_mul_image_eq hR hR1 hS))\n#align closure_mul_image_eq_top closure_mul_image_eq_top\n\n",
 "closure_mul_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Schreier's Lemma**: If `R : set G` is a right_transversal of `H : subgroup G`\n  with `1 ∈ R`, and if `G` is generated by `S : set G`, then `H` is generated by the `set`\n  `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`. -/\ntheorem closure_mul_image_eq (hR : R ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R) (hS : closure S = «expr⊤») :\n    closure ((R * S).image fun g => g * (to_fun hR g)⁻¹) = H :=\n  by\n  have hU : closure ((R * S).image fun g => g * (to_fun hR g)⁻¹) ≤ H :=\n    by\n    rw [closure_le]\n    rintro - ⟨g, -, rfl⟩\n    exact mul_inv_to_fun_mem hR g\n  refine' le_antisymm hU fun h hh => _\n  obtain ⟨g, r, hg, hr, rfl⟩ := show h ∈ _ from eq_top_iff.mp (closure_mul_image_mul_eq_top hR hR1 hS) (mem_top h)\n  suffices (⟨r, hr⟩ : R) = (⟨1, hR1⟩ : R) by rwa [show r = 1 from subtype.ext_iff.mp this, mul_one]\n  apply (mem_right_transversals_iff_exists_unique_mul_inv_mem.mp hR r).unique\n  · rw [subtype.coe_mk, mul_inv_self]\n    exact H.one_mem\n  · rw [subtype.coe_mk, inv_one, mul_one]\n    exact (H.mul_mem_cancel_left (hU hg)).mp hh\n#align closure_mul_image_eq closure_mul_image_eq\n\n",
 "card_commutator_le_of_finite_commutator_set":
 "/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\n  commutators. -/\ntheorem card_commutator_le_of_finite_commutator_set [Finite (commutator_set G)] :\n    nat.card (commutator G) ≤ card_commutator_bound (nat.card (commutator_set G)) :=\n  by\n  have h1 := index_center_le_pow (closure_commutator_representatives G)\n  have h2 := card_commutator_dvd_index_center_pow (closure_commutator_representatives G)\n  rw [card_commutator_set_closure_commutator_representatives] at h1 h2\n  rw [card_commutator_closure_commutator_representatives] at h2\n  replace h1 := h1.trans (Nat.pow_le_pow_of_le_right finite.card_pos (rank_closure_commutator_representations_le G))\n  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))\n  rw [← pow_succ'] at h2\n  refine' (nat.le_of_dvd _ h2).trans (Nat.pow_le_pow_of_le_left h1 _)\n  exact pow_pos (nat.pos_of_ne_zero finite_index.finite_index) _\n#align card_commutator_le_of_finite_commutator_set card_commutator_le_of_finite_commutator_set\n\n",
 "card_commutator_dvd_index_center_pow":
 "/-- If `G` has `n` commutators `[g₁, g₂]`, then `|G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\nwhere `G'` denotes the commutator of `G`. -/\ntheorem card_commutator_dvd_index_center_pow [Finite (commutator_set G)] :\n    nat.card (commutator G) ∣ (center G).index ^ ((center G).index * nat.card (commutator_set G) + 1) :=\n  by\n  -- First handle the case when `Z(G)` has infinite index and `[G : Z(G)]` is defined to be `0`\n  by_cases hG : (center G).index = 0\n  · simp_rw [hG, zero_mul, zero_add, pow_one, dvd_zero]\n  haveI : finite_index (center G) := ⟨hG⟩\n  -- Rewrite as `|Z(G) ∩ G'| * [G' : Z(G) ∩ G'] ∣ [G : Z(G)] ^ ([G : Z(G)] * n) * [G : Z(G)]`\n  rw [← ((center G).subgroup_of (commutator G)).card_mul_index, pow_succ']\n  -- We have `h1 : [G' : Z(G) ∩ G'] ∣ [G : Z(G)]`\n  have h1 := relindex_dvd_index_of_normal (center G) (commutator G)\n  -- So we can reduce to proving `|Z(G) ∩ G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n)`\n  refine' mul_dvd_mul _ h1\n  -- We know that `[G' : Z(G) ∩ G'] < ∞` by `h1` and `hG`\n  haveI : finite_index ((center G).subgroup_of (commutator G)) := ⟨ne_zero_of_dvd_ne_zero hG h1⟩\n  -- We have `h2 : rank (Z(G) ∩ G') ≤ [G' : Z(G) ∩ G'] * rank G'` by Schreier's lemma\n  have h2 := rank_le_index_mul_rank ((center G).subgroup_of (commutator G))\n  -- We have `h3 : [G' : Z(G) ∩ G'] * rank G' ≤ [G : Z(G)] * n` by `h1` and `rank G' ≤ n`\n  have h3 := nat.mul_le_mul (nat.le_of_dvd (nat.pos_of_ne_zero hG) h1) (rank_commutator_le_card G)\n  -- So we can reduce to proving `|Z(G) ∩ G'| ∣ [G : Z(G)] ^ rank (Z(G) ∩ G')`\n  refine' dvd_trans _ (pow_dvd_pow (center G).index (h2.trans h3))\n  -- `Z(G) ∩ G'` is abelian, so it enough to prove that `g ^ [G : Z(G)] = 1` for `g ∈ Z(G) ∩ G'`\n  apply card_dvd_exponent_pow_rank' _ fun g => _\n  -- `Z(G)` is abelian, so `g ∈ Z(G) ∩ G' ≤ G' ≤ ker (transfer : G → Z(G))`\n  have := abelianization.commutator_subset_ker (monoid_hom.transfer_center_pow G) g.1.2\n  -- `transfer g` is defeq to `g ^ [G : Z(G)]`, so we are done\n  simpa only [monoid_hom.mem_ker, subtype.ext_iff] using this\n#align card_commutator_dvd_index_center_pow card_commutator_dvd_index_center_pow\n\n"}