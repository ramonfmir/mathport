{"union_quot_to_doset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem union_quot_to_doset (H K : subgroup G) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (quot_to_doset H K q) =\n      Set.univ :=\n  by\n  ext x\n  simp only [Set.mem_unionᵢ, quot_to_doset, mem_doset, SetLike.mem_coe, exists_prop, Set.mem_univ, iff_true_iff]\n  use mk H K x\n  obtain ⟨h, k, h3, h4, h5⟩ := mk_out'_eq_mul H K x\n  refine' ⟨h⁻¹, H.inv_mem h3, k⁻¹, K.inv_mem h4, _⟩\n  simp only [h5, subgroup.coe_mk, ← mul_assoc, one_mul, mul_left_inv, mul_inv_cancel_right]\n#align union_quot_to_doset union_quot_to_doset\n\n",
 "right_bot_eq_right_quot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem right_bot_eq_right_quot (H : subgroup G) :\n    quotient H.1 («expr⊥» : subgroup G) = _root_.quotient (quotient_group.right_rel H) :=\n  by\n  unfold quotient\n  congr\n  ext\n  simp_rw [← rel_bot_eq_right_group_rel H]\n  rfl\n#align right_bot_eq_right_quot right_bot_eq_right_quot\n\n",
 "rel_iff":
 "theorem rel_iff {H K : subgroup G} {x y : G} : (setoid ↑H ↑K).rel x y ↔ ∃ a ∈ H, ∃ b ∈ K, y = a * x * b :=\n  iff.trans ⟨fun hxy => (congr_arg _ hxy).mpr (mem_doset_self H K y), fun hxy => (doset_eq_of_mem hxy).symm⟩ mem_doset\n#align rel_iff rel_iff\n\n",
 "rel_bot_eq_right_group_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem rel_bot_eq_right_group_rel (H : subgroup G) :\n    (setoid ↑H ↑(«expr⊥» : subgroup G)).rel = (quotient_group.right_rel H).rel :=\n  by\n  ext (a b)\n  rw [rel_iff, Setoid.Rel, quotient_group.right_rel_apply]\n  constructor\n  · rintro ⟨b, hb, a, rfl : a = 1, rfl⟩\n    change b * a * 1 * a⁻¹ ∈ H\n    rwa [mul_one, mul_inv_cancel_right]\n  · rintro (h : b * a⁻¹ ∈ H)\n    exact ⟨b * a⁻¹, h, 1, rfl, by rw [mul_one, inv_mul_cancel_right]⟩\n#align rel_bot_eq_right_group_rel rel_bot_eq_right_group_rel\n\n",
 "out_eq'":
 "theorem out_eq' (H K : subgroup G) (q : quotient ↑H ↑K) : mk H K q.out' = q :=\n  quotient.out_eq' q\n#align out_eq' out_eq'\n\n",
 "mk_out'_eq_mul":
 "theorem mk_out'_eq_mul (H K : subgroup G) (g : G) :\n    ∃ h k : G, h ∈ H ∧ k ∈ K ∧ (mk H K g : quotient ↑H ↑K).out' = h * g * k :=\n  by\n  have := eq H K (mk H K g : quotient ↑H ↑K).out' g\n  rw [out_eq'] at this\n  obtain ⟨h, h_h, k, hk, T⟩ := this.1 rfl\n  refine' ⟨h⁻¹, k⁻¹, H.inv_mem h_h, K.inv_mem hk, eq_mul_inv_of_mul_eq (eq_inv_mul_of_mul_eq _)⟩\n  rw [← mul_assoc, ← T]\n#align mk_out'_eq_mul mk_out'_eq_mul\n\n",
 "mk_eq_of_doset_eq":
 "theorem mk_eq_of_doset_eq {H K : subgroup G} {a b : G} (h : doset a H K = doset b H K) : mk H K a = mk H K b :=\n  by\n  rw [eq]\n  exact mem_doset.mp (h.symm ▸ mem_doset_self H K b)\n#align mk_eq_of_doset_eq mk_eq_of_doset_eq\n\n",
 "mem_doset_self":
 "theorem mem_doset_self (H K : subgroup G) (a : G) : a ∈ doset a H K :=\n  mem_doset.mpr ⟨1, H.one_mem, 1, K.one_mem, (one_mul a).symm.trans (mul_one (1 * a)).symm⟩\n#align mem_doset_self mem_doset_self\n\n",
 "mem_doset_of_not_disjoint":
 "theorem mem_doset_of_not_disjoint {H K : subgroup G} {a b : G} (h : ¬Disjoint (doset a H K) (doset b H K)) :\n    b ∈ doset a H K := by\n  rw [Set.not_disjoint_iff] at h\n  simp only [mem_doset] at *\n  obtain ⟨x, ⟨l, hl, r, hr, hrx⟩, y, hy, ⟨r', hr', rfl⟩⟩ := h\n  refine' ⟨y⁻¹ * l, H.mul_mem (H.inv_mem hy) hl, r * r'⁻¹, K.mul_mem hr (K.inv_mem hr'), _⟩\n  rwa [mul_assoc, mul_assoc, eq_inv_mul_iff_mul_eq, ← mul_assoc, ← mul_assoc, eq_mul_inv_iff_mul_eq]\n#align mem_doset_of_not_disjoint mem_doset_of_not_disjoint\n\n",
 "mem_doset":
 "/-\nCopyright (c) 2021 Chris Birkbeck. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Birkbeck\n-/\ntheorem mem_doset {s t : set α} {a b : α} : b ∈ doset a s t ↔ ∃ x ∈ s, ∃ y ∈ t, b = x * a * y :=\n  ⟨fun ⟨_, y, ⟨x, _, hx, rfl, rfl⟩, hy, h⟩ => ⟨x, hx, y, hy, h.symm⟩, fun ⟨x, hx, y, hy, h⟩ =>\n    ⟨x * a, y, ⟨x, a, hx, rfl, rfl⟩, hy, h.symm⟩⟩\n#align mem_doset mem_doset\n\n",
 "left_bot_eq_left_quot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem left_bot_eq_left_quot (H : subgroup G) : quotient («expr⊥» : subgroup G).1 H = «expr ⧸ » G H :=\n  by\n  unfold quotient\n  congr\n  ext\n  simp_rw [← bot_rel_eq_left_rel H]\n  rfl\n#align left_bot_eq_left_quot left_bot_eq_left_quot\n\n",
 "eq_of_not_disjoint":
 "theorem eq_of_not_disjoint {H K : subgroup G} {a b : G} (h : ¬Disjoint (doset a H K) (doset b H K)) :\n    doset a H K = doset b H K := by\n  rw [disjoint_comm] at h\n  have ha : a ∈ doset b H K := mem_doset_of_not_disjoint h\n  apply doset_eq_of_mem ha\n#align eq_of_not_disjoint eq_of_not_disjoint\n\n",
 "eq":
 "theorem eq (H K : subgroup G) (a b : G) : mk H K a = mk H K b ↔ ∃ h ∈ H, ∃ k ∈ K, b = h * a * k :=\n  by\n  rw [quotient.eq']\n  apply rel_iff\n#align eq eq\n\n",
 "doset_union_right_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem doset_union_right_coset (H K : subgroup G) (a : G) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (right_coset (↑H) (a * k)) =\n      doset a H K :=\n  by\n  ext x\n  simp only [mem_right_coset_iff, exists_prop, mul_inv_rev, Set.mem_unionᵢ, mem_doset, subgroup.mem_carrier,\n    SetLike.mem_coe]\n  constructor\n  · rintro ⟨y, h_h⟩\n    refine' ⟨x * (y⁻¹ * a⁻¹), h_h, y, y.2, _⟩\n    simp only [← mul_assoc, subgroup.coe_mk, inv_mul_cancel_right]\n  · rintro ⟨x, hx, y, hy, hxy⟩\n    refine' ⟨⟨y, hy⟩, _⟩\n    simp only [hxy, ← mul_assoc, hx, mul_inv_cancel_right, subgroup.coe_mk]\n#align doset_union_right_coset doset_union_right_coset\n\n",
 "doset_union_left_coset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem doset_union_left_coset (H K : subgroup G) (a : G) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (left_coset (h * a : G) K) =\n      doset a H K :=\n  by\n  ext x\n  simp only [mem_left_coset_iff, mul_inv_rev, Set.mem_unionᵢ, mem_doset]\n  constructor\n  · rintro ⟨y, h_h⟩\n    refine' ⟨y, y.2, a⁻¹ * y⁻¹ * x, h_h, _⟩\n    simp only [← mul_assoc, one_mul, mul_right_inv, mul_inv_cancel_right]\n  · rintro ⟨x, hx, y, hy, hxy⟩\n    refine' ⟨⟨x, hx⟩, _⟩\n    simp only [hxy, ← mul_assoc, hy, one_mul, mul_left_inv, subgroup.coe_mk, inv_mul_cancel_right]\n#align doset_union_left_coset doset_union_left_coset\n\n",
 "doset_eq_of_mem":
 "theorem doset_eq_of_mem {H K : subgroup G} {a b : G} (hb : b ∈ doset a H K) : doset b H K = doset a H K :=\n  by\n  obtain ⟨_, k, ⟨h, a, hh, rfl : _ = _, rfl⟩, hk, rfl⟩ := hb\n  rw [doset, doset, ← Set.singleton_mul_singleton, ← Set.singleton_mul_singleton, mul_assoc, mul_assoc,\n    subgroup.singleton_mul_subgroup hk, ← mul_assoc, ← mul_assoc, subgroup.subgroup_mul_singleton hh]\n#align doset_eq_of_mem doset_eq_of_mem\n\n",
 "disjoint_out'":
 "theorem disjoint_out' {H K : subgroup G} {a b : quotient H.1 K} :\n    a ≠ b → Disjoint (doset a.out' H K) (doset b.out' H K) :=\n  by\n  contrapose!\n  intro h\n  simpa [out_eq'] using mk_eq_of_doset_eq (eq_of_not_disjoint h)\n#align disjoint_out' disjoint_out'\n\n",
 "bot_rel_eq_left_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bot_rel_eq_left_rel (H : subgroup G) :\n    (setoid ↑(«expr⊥» : subgroup G) ↑H).rel = (quotient_group.left_rel H).rel :=\n  by\n  ext (a b)\n  rw [rel_iff, Setoid.Rel, quotient_group.left_rel_apply]\n  constructor\n  · rintro ⟨a, rfl : a = 1, b, hb, rfl⟩\n    change a⁻¹ * (1 * a * b) ∈ H\n    rwa [one_mul, inv_mul_cancel_left]\n  · rintro (h : a⁻¹ * b ∈ H)\n    exact ⟨1, rfl, a⁻¹ * b, h, by rw [one_mul, mul_inv_cancel_left]⟩\n#align bot_rel_eq_left_rel bot_rel_eq_left_rel\n\n"}