{"upper_central_series_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem upper_central_series_zero : upper_central_series G 0 = «expr⊥» :=\n  rfl\n#align upper_central_series_zero upper_central_series_zero\n\n",
 "upper_central_series_step_eq_comap_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The proof that `upper_central_series_step H` is the preimage of the centre of `G/H` under\nthe canonical surjection. -/\ntheorem upper_central_series_step_eq_comap_center :\n    upper_central_series_step H = subgroup.comap (mk' H) (center («expr ⧸ » G H)) :=\n  by\n  ext\n  rw [mem_comap, mem_center_iff, forall_coe]\n  apply forall_congr'\n  intro y\n  rw [coe_mk', ← quotient_group.coe_mul, ← quotient_group.coe_mul, eq_comm, eq_iff_div_mem, div_eq_mul_inv, mul_inv_rev,\n    mul_assoc]\n#align upper_central_series_step_eq_comap_center upper_central_series_step_eq_comap_center\n\n",
 "upper_central_series_one":
 "@[simp]\ntheorem upper_central_series_one : upper_central_series G 1 = center G :=\n  by\n  ext\n  simp only [upper_central_series, upper_central_series_aux, upper_central_series_step, center, Set.center, mem_mk,\n    mem_bot, Set.mem_setOf_eq]\n  exact forall_congr' fun y => by rw [mul_inv_eq_one, mul_inv_eq_iff_eq_mul, eq_comm]\n#align upper_central_series_one upper_central_series_one\n\n",
 "upper_central_series_nilpotency_class":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem upper_central_series_nilpotency_class : upper_central_series G (group.nilpotency_class G) = «expr⊤» :=\n  nat.find_spec (is_nilpotent.nilpotent G)\n#align upper_central_series_nilpotency_class upper_central_series_nilpotency_class\n\n",
 "upper_central_series_mono":
 "theorem upper_central_series_mono : monotone (upper_central_series G) :=\n  by\n  refine' monotone_nat_of_le_succ _\n  intro n x hx y\n  rw [mul_assoc, mul_assoc, ← mul_assoc y x⁻¹ y⁻¹]\n  exact mul_mem hx (normal.conj_mem (upper_central_series.subgroup.normal G n) x⁻¹ (inv_mem hx) y)\n#align upper_central_series_mono upper_central_series_mono\n\n",
 "upper_central_series_is_ascending_central_series":
 "/-- The upper central series of a group is an ascending central series. -/\ntheorem upper_central_series_is_ascending_central_series : is_ascending_central_series (upper_central_series G) :=\n  ⟨rfl, fun x n h => h⟩\n#align upper_central_series_is_ascending_central_series upper_central_series_is_ascending_central_series\n\n",
 "upper_central_series_eq_top_iff_nilpotency_class_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem upper_central_series_eq_top_iff_nilpotency_class_le {n : ℕ} :\n    upper_central_series G n = «expr⊤» ↔ group.nilpotency_class G ≤ n :=\n  by\n  constructor\n  · intro h\n    exact Nat.find_le h\n  · intro h\n    apply eq_top_iff.mpr\n    rw [← upper_central_series_nilpotency_class]\n    exact upper_central_series_mono _ h\n#align upper_central_series_eq_top_iff_nilpotency_class_le upper_central_series_eq_top_iff_nilpotency_class_le\n\n",
 "of_quotient_center_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem of_quotient_center_nilpotent (h : is_nilpotent («expr ⧸ » G (center G))) : is_nilpotent G :=\n  by\n  obtain ⟨n, hn⟩ := h.nilpotent\n  use n.succ\n  simp [← comap_upper_central_series_quotient_center, hn]\n#align of_quotient_center_nilpotent of_quotient_center_nilpotent\n\n",
 "normalizer_condition_of_is_nilpotent":
 "theorem normalizer_condition_of_is_nilpotent [h : is_nilpotent G] : normalizer_condition G :=\n  by\n  -- roughly based on https://groupprops.subwiki.org/wiki/Nilpotent_implies_normalizer_condition\n  rw [normalizer_condition_iff_only_full_group_self_normalizing]\n  apply nilpotent_center_quotient_ind G <;> clear! G\n  · intro G _ _ H _\n    apply subsingleton.elim\n  · intro G _ _ ih H hH\n    have hch : center G ≤ H := subgroup.center_le_normalizer.trans (le_of_eq hH)\n    have hkh : (mk' (center G)).ker ≤ H := by simpa using hch\n    have hsur : function.surjective (mk' (center G)) := surjective_quot_mk _\n    let H' := H.map (mk' (center G))\n    have hH' : H'.normalizer = H' := by\n      apply comap_injective hsur\n      rw [comap_normalizer_eq_of_surjective _ hsur, comap_map_eq_self hkh]\n      exact hH\n    apply map_injective_of_ker_le (mk' (center G)) hkh le_top\n    exact (ih H' hH').trans (symm (map_top_of_surjective _ hsur))\n#align normalizer_condition_of_is_nilpotent normalizer_condition_of_is_nilpotent\n\n",
 "nilpotent_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The range of a surjective homomorphism from a nilpotent group is nilpotent -/\ntheorem nilpotent_of_surjective {G' : Type _} [group G'] [h : is_nilpotent G] (f : «expr →* » G G')\n    (hf : function.surjective f) : is_nilpotent G' :=\n  by\n  rcases h with ⟨n, hn⟩\n  use n\n  apply eq_top_iff.mpr\n  calc\n    «expr⊤» = f.range := symm (f.range_top_of_surjective hf)\n    _ = subgroup.map f («expr⊤») := monoid_hom.range_eq_map _\n    _ = subgroup.map f (upper_central_series G n) := by rw [hn]\n    _ ≤ upper_central_series G' n := upper_central_series.map hf n\n    \n#align nilpotent_of_surjective nilpotent_of_surjective\n\n",
 "nilpotent_of_mul_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/-- Nilpotency respects isomorphisms -/\ntheorem nilpotent_of_mul_equiv {G' : Type _} [group G'] [h : is_nilpotent G] (f : «expr ≃* » G G') : is_nilpotent G' :=\n  nilpotent_of_surjective f.to_monoid_hom (MulEquiv.surjective f)\n#align nilpotent_of_mul_equiv nilpotent_of_mul_equiv\n\n",
 "nilpotent_iff_lower_central_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A group is nilpotent if and only if its lower central series eventually reaches\n  the trivial subgroup. -/\ntheorem nilpotent_iff_lower_central_series : is_nilpotent G ↔ ∃ n, lower_central_series G n = «expr⊥» :=\n  by\n  rw [nilpotent_iff_finite_descending_central_series]\n  constructor\n  · rintro ⟨n, H, ⟨h0, hs⟩, hn⟩\n    use n\n    rw [eq_bot_iff, ← hn]\n    exact descending_central_series_ge_lower H ⟨h0, hs⟩ n\n  · rintro ⟨n, hn⟩\n    exact ⟨n, lower_central_series G, lower_central_series_is_descending_central_series, hn⟩\n#align nilpotent_iff_lower_central_series nilpotent_iff_lower_central_series\n\n",
 "nilpotent_iff_finite_descending_central_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A group `G` is nilpotent iff there exists a descending central series which reaches the\n  trivial group in a finite time. -/\ntheorem nilpotent_iff_finite_descending_central_series :\n    is_nilpotent G ↔ ∃ n : ℕ, ∃ H : ℕ → subgroup G, is_descending_central_series H ∧ H n = «expr⊥» :=\n  by\n  rw [nilpotent_iff_finite_ascending_central_series]\n  constructor\n  · rintro ⟨n, H, hH, hn⟩\n    refine' ⟨n, fun m => H (n - m), is_decending_rev_series_of_is_ascending G hn hH, _⟩\n    rw [tsub_self]\n    exact hH.1\n  · rintro ⟨n, H, hH, hn⟩\n    refine' ⟨n, fun m => H (n - m), is_ascending_rev_series_of_is_descending G hn hH, _⟩\n    rw [tsub_self]\n    exact hH.1\n#align nilpotent_iff_finite_descending_central_series nilpotent_iff_finite_descending_central_series\n\n",
 "nilpotent_iff_finite_ascending_central_series":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A group `G` is nilpotent iff there exists an ascending central series which reaches `G` in\n  finitely many steps. -/\ntheorem nilpotent_iff_finite_ascending_central_series :\n    is_nilpotent G ↔ ∃ n : ℕ, ∃ H : ℕ → subgroup G, is_ascending_central_series H ∧ H n = «expr⊤» :=\n  by\n  constructor\n  · rintro ⟨n, nH⟩\n    refine' ⟨_, _, upper_central_series_is_ascending_central_series G, nH⟩\n  · rintro ⟨n, H, hH, hn⟩\n    use n\n    rw [eq_top_iff, ← hn]\n    exact ascending_central_series_le_upper H hH n\n#align nilpotent_iff_finite_ascending_central_series nilpotent_iff_finite_ascending_central_series\n\n",
 "nilpotent_center_quotient_ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- A custom induction principle for nilpotent groups. The base case is a trivial group\n(`subsingleton G`), and in the induction step, one can assume the hypothesis for\nthe group quotiented by its center. -/\n@[elab_as_elim]\ntheorem nilpotent_center_quotient_ind {P : ∀ (G) [group G], ∀ [is_nilpotent G], Prop} (G : Type _) [group G]\n    [is_nilpotent G] (hbase : ∀ (G) [group G] [subsingleton G], P G)\n    (hstep : ∀ (G) [group G], ∀ [is_nilpotent G], ∀ ih : P («expr ⧸ » G (center G)), P G) : P G :=\n  by\n  obtain ⟨n, h⟩ : ∃ n, group.nilpotency_class G = n := ⟨_, rfl⟩\n  induction' n with n ih generalizing G\n  · haveI := nilpotency_class_zero_iff_subsingleton.mp h\n    exact hbase _\n  · have hn : group.nilpotency_class («expr ⧸ » G (center G)) = n := by simp [nilpotency_class_quotient_center, h]\n    exact hstep _ (ih _ hn)\n#align nilpotent_center_quotient_ind nilpotent_center_quotient_ind\n\n",
 "nilpotency_class_zero_iff_subsingleton":
 "theorem nilpotency_class_zero_iff_subsingleton [is_nilpotent G] : group.nilpotency_class G = 0 ↔ subsingleton G := by\n  simp [group.nilpotency_class, Nat.find_eq_zero, subsingleton_iff_bot_eq_top]\n#align nilpotency_class_zero_iff_subsingleton nilpotency_class_zero_iff_subsingleton\n\n",
 "nilpotency_class_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The nilpotency class of a quotient of `G` is less or equal the nilpotency class of `G` -/\ntheorem nilpotency_class_quotient_le (H : subgroup G) [H.normal] [h : is_nilpotent G] :\n    group.nilpotency_class («expr ⧸ » G H) ≤ group.nilpotency_class G :=\n  nilpotency_class_le_of_surjective _ _\n#align nilpotency_class_quotient_le nilpotency_class_quotient_le\n\n",
 "nilpotency_class_quotient_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Quotienting the `center G` reduces the nilpotency class by 1 -/\ntheorem nilpotency_class_quotient_center [hH : is_nilpotent G] :\n    group.nilpotency_class («expr ⧸ » G (center G)) = group.nilpotency_class G - 1 :=\n  by\n  generalize hn : group.nilpotency_class G = n\n  rcases n with (rfl | n)\n  · simp [nilpotency_class_zero_iff_subsingleton] at *\n    haveI := hn\n    infer_instance\n  · suffices group.nilpotency_class («expr ⧸ » G (center G)) = n by simpa\n    apply le_antisymm\n    · apply upper_central_series_eq_top_iff_nilpotency_class_le.mp\n      apply @comap_injective G _ _ _ (mk' (center G)) (surjective_quot_mk _)\n      rw [comap_upper_central_series_quotient_center, comap_top, ← hn]\n      exact upper_central_series_nilpotency_class\n    · apply le_of_add_le_add_right\n      calc\n        n + 1 = n.succ := rfl\n        _ = group.nilpotency_class G := symm hn\n        _ ≤ group.nilpotency_class («expr ⧸ » G (center G)) + 1 :=\n          nilpotency_class_le_of_ker_le_center _ (le_of_eq (ker_mk _)) _\n        \n#align nilpotency_class_quotient_center nilpotency_class_quotient_center\n\n",
 "nilpotency_class_prod":
 "/-- The nilpotency class of a product is the max of the nilpotency classes of the factors -/\ntheorem nilpotency_class_prod [is_nilpotent G₁] [is_nilpotent G₂] :\n    group.nilpotency_class (G₁ × G₂) = max (group.nilpotency_class G₁) (group.nilpotency_class G₂) :=\n  by\n  refine' eq_of_forall_ge_iff fun k => _\n  simp only [max_le_iff, ← lower_central_series_eq_bot_iff_nilpotency_class_le, lower_central_series_prod,\n    prod_eq_bot_iff]\n#align nilpotency_class_prod nilpotency_class_prod\n\n",
 "nilpotency_class_pi":
 "/-- The nilpotency class of an n-ary product is the sup of the nilpotency classes of the factors -/\ntheorem nilpotency_class_pi [fintype η] [∀ i, is_nilpotent (Gs i)] :\n    group.nilpotency_class (∀ i, Gs i) = finset.univ.sup fun i => group.nilpotency_class (Gs i) :=\n  by\n  apply eq_of_forall_ge_iff\n  intro k\n  simp only [finset.sup_le_iff, ← lower_central_series_eq_bot_iff_nilpotency_class_le,\n    lower_central_series_pi_of_finite, pi_eq_bot_iff, finset.mem_univ, true_imp_iff]\n#align nilpotency_class_pi nilpotency_class_pi\n\n",
 "nilpotency_class_le_one":
 "/-- Abelian groups have nilpotency class at most one -/\ntheorem comm_group.nilpotency_class_le_one {G : Type _} [comm_group G] : group.nilpotency_class G ≤ 1 :=\n  by\n  apply upper_central_series_eq_top_iff_nilpotency_class_le.mp\n  rw [upper_central_series_one]\n  apply comm_group.center_eq_top\n#align comm_group.nilpotency_class_le_one comm_group.nilpotency_class_le_one\n\n",
 "nilpotency_class_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The nilpotency class of the range of a surejctive homomorphism from a\nnilpotent group is less or equal the nilpotency class of the domain -/\ntheorem nilpotency_class_le_of_surjective {G' : Type _} [group G'] (f : «expr →* » G G') (hf : function.surjective f)\n    [h : is_nilpotent G] : @group.nilpotency_class G' _ (nilpotent_of_surjective _ hf) ≤ group.nilpotency_class G :=\n  by\n  apply Nat.find_mono\n  intro n hn\n  apply eq_top_iff.mpr\n  calc\n    «expr⊤» = f.range := symm (f.range_top_of_surjective hf)\n    _ = subgroup.map f («expr⊤») := monoid_hom.range_eq_map _\n    _ = subgroup.map f (upper_central_series G n) := by rw [hn]\n    _ ≤ upper_central_series G' n := upper_central_series.map hf n\n    \n#align nilpotency_class_le_of_surjective nilpotency_class_le_of_surjective\n\n",
 "nilpotency_class_le_of_ker_le_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem nilpotency_class_le_of_ker_le_center {H : Type _} [group H] (f : «expr →* » G H) (hf1 : f.ker ≤ center G)\n    (hH : is_nilpotent H) :\n    @group.nilpotency_class G _ (is_nilpotent_of_ker_le_center f hf1 hH) ≤ group.nilpotency_class H + 1 :=\n  by\n  rw [← lower_central_series_length_eq_nilpotency_class]\n  apply nat.find_min'\n  refine' lower_central_series_succ_eq_bot (le_trans ((map_eq_bot_iff _).mp _) hf1)\n  apply eq_bot_iff.mpr\n  apply le_trans (lower_central_series.map f _)\n  simp only [lower_central_series_nilpotency_class, le_bot_iff]\n#align nilpotency_class_le_of_ker_le_center nilpotency_class_le_of_ker_le_center\n\n",
 "nilpotency_class_le":
 "/-- A the nilpotency class of a subgroup is less or equal the the nilpotency class of the group -/\ntheorem subgroup.nilpotency_class_le (H : subgroup G) [hG : is_nilpotent G] :\n    group.nilpotency_class H ≤ group.nilpotency_class G :=\n  by\n  repeat' rw [← lower_central_series_length_eq_nilpotency_class]\n  apply Nat.find_mono\n  intro n hG\n  have := lower_central_series_map_subtype_le H n\n  simp only [hG, SetLike.le_def, mem_map, forall_apply_eq_imp_iff₂, exists_imp] at this\n  exact eq_bot_iff.mpr fun x hx => subtype.ext (this x hx)\n#align subgroup.nilpotency_class_le subgroup.nilpotency_class_le\n\n",
 "nilpotency_class_eq_quotient_center_plus_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem nilpotency_class_eq_quotient_center_plus_one [hH : is_nilpotent G] [nontrivial G] :\n    group.nilpotency_class G = group.nilpotency_class («expr ⧸ » G (center G)) + 1 :=\n  by\n  rw [nilpotency_class_quotient_center]\n  rcases h : group.nilpotency_class G with ⟨⟩\n  · exfalso\n    rw [nilpotency_class_zero_iff_subsingleton] at h\n    skip\n    apply false_of_nontrivial_of_subsingleton G\n  · simp\n#align nilpotency_class_eq_quotient_center_plus_one nilpotency_class_eq_quotient_center_plus_one\n\n",
 "mem_upper_central_series_succ_iff":
 "/-- The `n+1`st term of the upper central series `H i` has underlying set equal to the `x` such\nthat `⁅x,G⁆ ⊆ H n`-/\ntheorem mem_upper_central_series_succ_iff (n : ℕ) (x : G) :\n    x ∈ upper_central_series G (n + 1) ↔ ∀ y : G, x * y * x⁻¹ * y⁻¹ ∈ upper_central_series G n :=\n  iff.rfl\n#align mem_upper_central_series_succ_iff mem_upper_central_series_succ_iff\n\n",
 "mem_upper_central_series_step":
 "/-\nCopyright (c) 2021 Kevin Buzzard. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Ines Wright, Joachim Breitner\n-/\ntheorem mem_upper_central_series_step (x : G) : x ∈ upper_central_series_step H ↔ ∀ y, x * y * x⁻¹ * y⁻¹ ∈ H :=\n  iff.rfl\n#align mem_upper_central_series_step mem_upper_central_series_step\n\n",
 "mem_lower_central_series_succ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem mem_lower_central_series_succ_iff (n : ℕ) (q : G) :\n    q ∈ lower_central_series G (n + 1) ↔\n      q ∈ closure { x | ∃ p ∈ lower_central_series G n, ∃ q ∈ («expr⊤» : subgroup G), p * q * p⁻¹ * q⁻¹ = x } :=\n  iff.rfl\n#align mem_lower_central_series_succ_iff mem_lower_central_series_succ_iff\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem lower_central_series.map {H : Type _} [group H] (f : «expr →* » G H) (n : ℕ) :\n    subgroup.map f (lower_central_series G n) ≤ lower_central_series H n :=\n  by\n  induction' n with d hd\n  · simp [Nat.zero_eq]\n  · rintro a ⟨x, hx : x ∈ lower_central_series G d.succ, rfl⟩\n    refine'\n      closure_induction hx _ (by simp [f.map_one, subgroup.one_mem _])\n        (fun y z hy hz => by simp [MonoidHom.map_mul, subgroup.mul_mem _ hy hz]) fun y hy => by\n        simp [f.map_inv, subgroup.inv_mem _ hy]\n    rintro a ⟨y, hy, z, ⟨-, rfl⟩⟩\n    apply mem_closure.mpr\n    exact fun K hK => hK ⟨f y, hd (mem_map_of_mem f hy), by simp [commutatorElement_def]⟩\n#align lower_central_series.map lower_central_series.map\n\n",
 "lower_central_series_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem lower_central_series_zero : lower_central_series G 0 = «expr⊤» :=\n  rfl\n#align lower_central_series_zero lower_central_series_zero\n\n",
 "lower_central_series_succ_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lower_central_series_succ_eq_bot {n : ℕ} (h : lower_central_series G n ≤ center G) :\n    lower_central_series G (n + 1) = «expr⊥» :=\n  by\n  rw [lower_central_series_succ, closure_eq_bot_iff, Set.subset_singleton_iff]\n  rintro x ⟨y, hy1, z, ⟨⟩, rfl⟩\n  rw [mul_assoc, ← mul_inv_rev, mul_inv_eq_one, eq_comm]\n  exact mem_center_iff.mp (h hy1) z\n#align lower_central_series_succ_eq_bot lower_central_series_succ_eq_bot\n\n",
 "lower_central_series_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lower_central_series_succ (n : ℕ) :\n    lower_central_series G (n + 1) =\n      closure { x | ∃ p ∈ lower_central_series G n, ∃ q ∈ («expr⊤» : subgroup G), p * q * p⁻¹ * q⁻¹ = x } :=\n  rfl\n#align lower_central_series_succ lower_central_series_succ\n\n",
 "lower_central_series_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lower_central_series_prod (n : ℕ) :\n    lower_central_series (G₁ × G₂) n = (lower_central_series G₁ n).prod (lower_central_series G₂ n) :=\n  by\n  induction' n with n ih\n  · simp\n  ·\n    calc\n      lower_central_series (G₁ × G₂) n.succ = «expr⁅ , ⁆» (lower_central_series (G₁ × G₂) n) («expr⊤») := rfl\n      _ = «expr⁅ , ⁆» ((lower_central_series G₁ n).prod (lower_central_series G₂ n)) («expr⊤») := by rw [ih]\n      _ =\n          «expr⁅ , ⁆» ((lower_central_series G₁ n).prod (lower_central_series G₂ n))\n            ((«expr⊤» : subgroup G₁).prod («expr⊤»)) :=\n        by simp\n      _ =\n          («expr⁅ , ⁆» (lower_central_series G₁ n) («expr⊤» : subgroup G₁)).prod\n            («expr⁅ , ⁆» (lower_central_series G₂ n) («expr⊤»)) :=\n        commutator_prod_prod _ _ _ _\n      _ = (lower_central_series G₁ n.succ).prod (lower_central_series G₂ n.succ) := rfl\n      \n#align lower_central_series_prod lower_central_series_prod\n\n",
 "lower_central_series_pi_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- Now for finite products\ntheorem lower_central_series_pi_of_finite [Finite η] (n : ℕ) :\n    lower_central_series (∀ i, Gs i) n = subgroup.pi Set.univ fun i => lower_central_series (Gs i) n :=\n  by\n  let pi := fun f : ∀ i, subgroup (Gs i) => subgroup.pi Set.univ f\n  induction' n with n ih\n  · simp [pi_top]\n  ·\n    calc\n      lower_central_series (∀ i, Gs i) n.succ = «expr⁅ , ⁆» (lower_central_series (∀ i, Gs i) n) («expr⊤») := rfl\n      _ = «expr⁅ , ⁆» (pi fun i => lower_central_series (Gs i) n) («expr⊤») := by rw [ih]\n      _ = «expr⁅ , ⁆» (pi fun i => lower_central_series (Gs i) n) (pi fun i => «expr⊤») := by simp [pi, pi_top]\n      _ = pi fun i => «expr⁅ , ⁆» (lower_central_series (Gs i) n) («expr⊤») := commutator_pi_pi_of_finite _ _\n      _ = pi fun i => lower_central_series (Gs i) n.succ := rfl\n      \n#align lower_central_series_pi_of_finite lower_central_series_pi_of_finite\n\n",
 "lower_central_series_pi_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- First the case of infinite products with bounded nilpotency class\ntheorem lower_central_series_pi_le (n : ℕ) :\n    lower_central_series (∀ i, Gs i) n ≤ subgroup.pi Set.univ fun i => lower_central_series (Gs i) n :=\n  by\n  let pi := fun f : ∀ i, subgroup (Gs i) => subgroup.pi Set.univ f\n  induction' n with n ih\n  · simp [pi_top]\n  ·\n    calc\n      lower_central_series (∀ i, Gs i) n.succ = «expr⁅ , ⁆» (lower_central_series (∀ i, Gs i) n) («expr⊤») := rfl\n      _ ≤ «expr⁅ , ⁆» (pi fun i => lower_central_series (Gs i) n) («expr⊤») := commutator_mono ih (le_refl _)\n      _ = «expr⁅ , ⁆» (pi fun i => lower_central_series (Gs i) n) (pi fun i => «expr⊤») := by simp [pi, pi_top]\n      _ ≤ pi fun i => «expr⁅ , ⁆» (lower_central_series (Gs i) n) («expr⊤») := commutator_pi_pi_le _ _\n      _ = pi fun i => lower_central_series (Gs i) n.succ := rfl\n      \n#align lower_central_series_pi_le lower_central_series_pi_le\n\n",
 "lower_central_series_one":
 "@[simp]\ntheorem lower_central_series_one : lower_central_series G 1 = commutator G :=\n  rfl\n#align lower_central_series_one lower_central_series_one\n\n",
 "lower_central_series_nilpotency_class":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem lower_central_series_nilpotency_class : lower_central_series G (group.nilpotency_class G) = «expr⊥» :=\n  by\n  rw [← lower_central_series_length_eq_nilpotency_class]\n  exact nat.find_spec (nilpotent_iff_lower_central_series.mp _)\n#align lower_central_series_nilpotency_class lower_central_series_nilpotency_class\n\n",
 "lower_central_series_map_subtype_le":
 "theorem lower_central_series_map_subtype_le (H : subgroup G) (n : ℕ) :\n    (lower_central_series H n).map H.subtype ≤ lower_central_series G n :=\n  by\n  induction' n with d hd\n  · simp\n  · rw [lower_central_series_succ, lower_central_series_succ, monoid_hom.map_closure]\n    apply subgroup.closure_mono\n    rintro x1 ⟨x2, ⟨x3, hx3, x4, hx4, rfl⟩, rfl⟩\n    exact ⟨x3, hd (mem_map.mpr ⟨x3, hx3, rfl⟩), x4, by simp⟩\n#align lower_central_series_map_subtype_le lower_central_series_map_subtype_le\n\n",
 "lower_central_series_length_eq_nilpotency_class":
 "/-- The nilpotency class of a nilpotent `G` is equal to the length of the lower central series. -/\ntheorem lower_central_series_length_eq_nilpotency_class :\n    nat.find (nilpotent_iff_lower_central_series.mp hG) = @group.nilpotency_class G _ _ :=\n  by\n  rw [← least_descending_central_series_length_eq_nilpotency_class]\n  refine' le_antisymm (Nat.find_mono _) (Nat.find_mono _)\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    rw [← le_bot_iff, ← hn]\n    exact descending_central_series_ge_lower H hH n\n  · rintro n h\n    exact ⟨lower_central_series G, ⟨lower_central_series_is_descending_central_series, h⟩⟩\n#align lower_central_series_length_eq_nilpotency_class lower_central_series_length_eq_nilpotency_class\n\n",
 "lower_central_series_is_descending_central_series":
 "/-- The lower central series of a group is a descending central series. -/\ntheorem lower_central_series_is_descending_central_series : is_descending_central_series (lower_central_series G) :=\n  by\n  constructor; rfl\n  intro x n hxn g\n  exact commutator_mem_commutator hxn (mem_top g)\n#align lower_central_series_is_descending_central_series lower_central_series_is_descending_central_series\n\n",
 "lower_central_series_eq_bot_iff_nilpotency_class_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lower_central_series_eq_bot_iff_nilpotency_class_le {n : ℕ} :\n    lower_central_series G n = «expr⊥» ↔ group.nilpotency_class G ≤ n :=\n  by\n  constructor\n  · intro h\n    rw [← lower_central_series_length_eq_nilpotency_class]\n    exact Nat.find_le h\n  · intro h\n    apply eq_bot_iff.mpr\n    rw [← lower_central_series_nilpotency_class]\n    exact lower_central_series_antitone h\n#align lower_central_series_eq_bot_iff_nilpotency_class_le lower_central_series_eq_bot_iff_nilpotency_class_le\n\n",
 "lower_central_series_antitone":
 "theorem lower_central_series_antitone : antitone (lower_central_series G) :=\n  by\n  refine' antitone_nat_of_succ_le fun n x hx => _\n  simp only [mem_lower_central_series_succ_iff, exists_prop, mem_top, exists_true_left, true_and_iff] at hx\n  refine' closure_induction hx _ (subgroup.one_mem _) (@subgroup.mul_mem _ _ _) (@subgroup.inv_mem _ _ _)\n  rintro y ⟨z, hz, a, ha⟩\n  rw [← ha, mul_assoc, mul_assoc, ← mul_assoc a z⁻¹ a⁻¹]\n  exact mul_mem hz (normal.conj_mem (lower_central_series.subgroup.normal n) z⁻¹ (inv_mem hz) a)\n#align lower_central_series_antitone lower_central_series_antitone\n\n",
 "least_descending_central_series_length_eq_nilpotency_class":
 "/-- The nilpotency class of a nilpotent `G` is equal to the smallest `n` for which the descending\ncentral series reaches `⊥` in its `n`'th term. -/\ntheorem least_descending_central_series_length_eq_nilpotency_class :\n    nat.find ((nilpotent_iff_finite_descending_central_series G).mp hG) = group.nilpotency_class G :=\n  by\n  rw [← least_ascending_central_series_length_eq_nilpotency_class]\n  refine' le_antisymm (Nat.find_mono _) (Nat.find_mono _)\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    refine' ⟨fun m => H (n - m), is_decending_rev_series_of_is_ascending G hn hH, _⟩\n    rw [tsub_self]\n    exact hH.1\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    refine' ⟨fun m => H (n - m), is_ascending_rev_series_of_is_descending G hn hH, _⟩\n    rw [tsub_self]\n    exact hH.1\n#align\n  least_descending_central_series_length_eq_nilpotency_class least_descending_central_series_length_eq_nilpotency_class\n\n",
 "least_ascending_central_series_length_eq_nilpotency_class":
 "/-- The nilpotency class of a nilpotent `G` is equal to the smallest `n` for which an ascending\ncentral series reaches `G` in its `n`'th term. -/\ntheorem least_ascending_central_series_length_eq_nilpotency_class :\n    nat.find ((nilpotent_iff_finite_ascending_central_series G).mp hG) = group.nilpotency_class G :=\n  by\n  refine' le_antisymm (Nat.find_mono _) (Nat.find_mono _)\n  · intro n hn\n    exact ⟨upper_central_series G, upper_central_series_is_ascending_central_series G, hn⟩\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    rw [← top_le_iff, ← hn]\n    exact ascending_central_series_le_upper H hH n\n#align\n  least_ascending_central_series_length_eq_nilpotency_class least_ascending_central_series_length_eq_nilpotency_class\n\n",
 "is_nilpotent_pi_of_bounded_class":
 "/-- products of nilpotent groups are nilpotent if their nipotency class is bounded -/\ntheorem is_nilpotent_pi_of_bounded_class [∀ i, is_nilpotent (Gs i)] (n : ℕ)\n    (h : ∀ i, group.nilpotency_class (Gs i) ≤ n) : is_nilpotent (∀ i, Gs i) :=\n  by\n  rw [nilpotent_iff_lower_central_series]\n  refine' ⟨n, _⟩\n  rw [eq_bot_iff]\n  apply le_trans (lower_central_series_pi_le _)\n  rw [← eq_bot_iff, pi_eq_bot_iff]\n  intro i\n  apply lower_central_series_eq_bot_iff_nilpotency_class_le.mpr (h i)\n#align is_nilpotent_pi_of_bounded_class is_nilpotent_pi_of_bounded_class\n\n",
 "is_nilpotent_of_product_of_sylow_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem is_nilpotent_of_product_of_sylow_group\n    (e : «expr ≃* » (∀ p : (fintype.card G).factorization.support, ∀ P : sylow p G, (↑P : subgroup G)) G) :\n    is_nilpotent G := by\n  classical\n    let ps := (fintype.card G).factorization.support\n    have : ∀ (p : ps) (P : sylow p G), is_nilpotent (↑P : subgroup G) :=\n      by\n      intro p P\n      haveI : fact (Nat.Prime ↑p) := fact.mk (nat.prime_of_mem_factorization (Finset.coe_mem p))\n      exact P.is_p_group'.is_nilpotent\n    exact nilpotent_of_mul_equiv e\n#align is_nilpotent_of_product_of_sylow_group is_nilpotent_of_product_of_sylow_group\n\n",
 "is_nilpotent_of_ker_le_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The preimage of a nilpotent group is nilpotent if the kernel of the homomorphism is contained\nin the center -/\ntheorem is_nilpotent_of_ker_le_center {H : Type _} [group H] (f : «expr →* » G H) (hf1 : f.ker ≤ center G)\n    (hH : is_nilpotent H) : is_nilpotent G :=\n  by\n  rw [nilpotent_iff_lower_central_series] at *\n  rcases hH with ⟨n, hn⟩\n  use n + 1\n  refine' lower_central_series_succ_eq_bot (le_trans ((map_eq_bot_iff _).mp _) hf1)\n  exact eq_bot_iff.mpr (hn ▸ lower_central_series.map f n)\n#align is_nilpotent_of_ker_le_center is_nilpotent_of_ker_le_center\n\n",
 "is_nilpotent_of_finite_tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment\n        \"/--\"\n        \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. -/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `is_nilpotent_of_finite_tfae [])\n      (Command.declSig\n       []\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `is_nilpotent [`G])\n            \",\"\n            (Term.app `normalizer_condition [`G])\n            \",\"\n            (Term.forall\n             \"∀\"\n             [`H]\n             [(Term.typeSpec \":\" (Term.app `subgroup [`G]))]\n             \",\"\n             (Term.arrow (Term.app `IsCoatom [`H]) \"→\" (Term.proj `H \".\" `normal)))\n            \",\"\n            (Term.forall\n             \"∀\"\n             [(Term.explicitBinder \"(\" [`p] [\":\" (termℕ \"ℕ\")] [] \")\")\n              (Term.explicitBinder \"(\" [`hp] [\":\" (Term.app `fact [(Term.proj `p \".\" `prime)])] [] \")\")\n              (Term.explicitBinder \"(\" [`P] [\":\" (Term.app `sylow [`p `G])] [] \")\")]\n             []\n             \",\"\n             (Term.proj (Term.typeAscription \"(\" (coeNotation \"↑\" `P) \":\" [(Term.app `subgroup [`G])] \")\") \".\" `normal))\n            \",\"\n            (Term.app\n             `nonempty\n             [(Term.app\n               `«expr ≃* »\n               [(Term.forall\n                 \"∀\"\n                 [`p]\n                 [(Term.typeSpec \":\" (Term.proj (Term.proj (Term.app `card [`G]) \".\" `factorization) \".\" `support))]\n                 \",\"\n                 (Term.forall\n                  \"∀\"\n                  [`P]\n                  [(Term.typeSpec \":\" (Term.app `sylow [`p `G]))]\n                  \",\"\n                  (Term.typeAscription \"(\" (coeNotation \"↑\" `P) \":\" [(Term.app `subgroup [`G])] \")\")))\n                `G])])]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.app (Term.explicit \"@\" `normalizer_condition_of_is_nilpotent) [(Term.hole \"_\") (Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun [`h `H] [] \"=>\" (Term.app `normalizer_condition.normal_of_coatom [`H `h]))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" [`h `p (Term.hole \"_\") `P])\n             []\n             (Tactic.exact \"exact\" (Term.app `sylow.normal_of_all_max_subgroups_normal [`h (Term.hole \"_\")]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.app `nonempty.intro [(Term.app `sylow.direct_product_of_normal [`h])]))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n           \";\"\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `e)])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `is_nilpotent_of_product_of_sylow_group [`e]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.app (Term.explicit \"@\" `normalizer_condition_of_is_nilpotent) [(Term.hole \"_\") (Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"3\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun [`h `H] [] \"=>\" (Term.app `normalizer_condition.normal_of_coatom [`H `h]))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"4\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" [`h `p (Term.hole \"_\") `P])\n            []\n            (Tactic.exact \"exact\" (Term.app `sylow.normal_of_all_max_subgroups_normal [`h (Term.hole \"_\")]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"5\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.app `nonempty.intro [(Term.app `sylow.direct_product_of_normal [`h])]))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n          \";\"\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `e)])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `is_nilpotent_of_product_of_sylow_group [`e]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `e)]) [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.exact \"exact\" (Term.app `is_nilpotent_of_product_of_sylow_group [`e]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `is_nilpotent_of_product_of_sylow_group [`e]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `is_nilpotent_of_product_of_sylow_group [`e])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `e\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `is_nilpotent_of_product_of_sylow_group\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `e)]) [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"5\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/--\n    A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\n    normal and iff all sylow groups are normal and iff the group is the direct product of its sylow\n    groups. -/\n  theorem\n    is_nilpotent_of_finite_tfae\n    :\n      TFAE\n        [\n          is_nilpotent G\n            ,\n            normalizer_condition G\n            ,\n            ∀ H : subgroup G , IsCoatom H → H . normal\n            ,\n            ∀ ( p : ℕ ) ( hp : fact p . prime ) ( P : sylow p G ) , ( ↑ P : subgroup G ) . normal\n            ,\n            nonempty «expr ≃* » ∀ p : card G . factorization . support , ∀ P : sylow p G , ( ↑ P : subgroup G ) G\n          ]\n    :=\n      by\n        tfae_have 1 → 2\n          ;\n          · exact @ normalizer_condition_of_is_nilpotent _ _\n          tfae_have 2 → 3\n          ;\n          · exact fun h H => normalizer_condition.normal_of_coatom H h\n          tfae_have 3 → 4\n          ;\n          · intro h p _ P exact sylow.normal_of_all_max_subgroups_normal h _\n          tfae_have 4 → 5\n          ;\n          · exact fun h => nonempty.intro sylow.direct_product_of_normal h\n          tfae_have 5 → 1\n          ;\n          · rintro ⟨ e ⟩ exact is_nilpotent_of_product_of_sylow_group e\n          tfae_finish\n#align is_nilpotent_of_finite_tfae is_nilpotent_of_finite_tfae\n\n",
 "is_nilpotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- A p-group is nilpotent -/\ntheorem is_p_group.is_nilpotent [Finite G] {p : ℕ} [hp : fact (Nat.Prime p)] (h : is_p_group p G) : is_nilpotent G :=\n  by\n  cases nonempty_fintype G\n  classical\n    revert hG\n    induction' val using fintype.induction_subsingleton_or_nontrivial with G hG hS G hG hN ih\n    · infer_instance\n    · intro\n      intro h\n      have hcq : fintype.card («expr ⧸ » G (center G)) < fintype.card G :=\n        by\n        rw [card_eq_card_quotient_mul_card_subgroup (center G)]\n        apply lt_mul_of_one_lt_right\n        exact fintype.card_pos_iff.mpr has_one.nonempty\n        exact (subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)\n      have hnq : is_nilpotent («expr ⧸ » G (center G)) := ih _ hcq (h.to_quotient (center G))\n      exact of_quotient_center_nilpotent hnq\n#align is_p_group.is_nilpotent is_p_group.is_nilpotent\n\n",
 "is_decending_rev_series_of_is_ascending":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_decending_rev_series_of_is_ascending {H : ℕ → subgroup G} {n : ℕ} (hn : H n = «expr⊤»)\n    (hasc : is_ascending_central_series H) : is_descending_central_series fun m : ℕ => H (n - m) :=\n  by\n  cases' hasc with h0 hH\n  refine' ⟨hn, fun x m hx g => _⟩\n  dsimp at hx\n  by_cases hm : n ≤ m\n  · rw [tsub_eq_zero_of_le hm, h0, subgroup.mem_bot] at hx\n    subst hx\n    convert subgroup.one_mem _\n    group\n  · push_neg  at hm\n    apply hH\n    convert hx\n    rw [tsub_add_eq_add_tsub (nat.succ_le_of_lt hm), nat.succ_sub_succ]\n#align is_decending_rev_series_of_is_ascending is_decending_rev_series_of_is_ascending\n\n",
 "is_ascending_rev_series_of_is_descending":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_ascending_rev_series_of_is_descending {H : ℕ → subgroup G} {n : ℕ} (hn : H n = «expr⊥»)\n    (hdesc : is_descending_central_series H) : is_ascending_central_series fun m : ℕ => H (n - m) :=\n  by\n  cases' hdesc with h0 hH\n  refine' ⟨hn, fun x m hx g => _⟩\n  dsimp only at hx⊢\n  by_cases hm : n ≤ m\n  · have hnm : n - m = 0 := tsub_eq_zero_iff_le.mpr hm\n    rw [hnm, h0]\n    exact mem_top _\n  · push_neg  at hm\n    convert hH x _ hx g\n    rw [tsub_add_eq_add_tsub (nat.succ_le_of_lt hm), nat.succ_sub_succ]\n#align is_ascending_rev_series_of_is_descending is_ascending_rev_series_of_is_descending\n\n",
 "descending_central_series_ge_lower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem descending_central_series_ge_lower (H : ℕ → subgroup G) (hH : is_descending_central_series H) :\n    ∀ n : ℕ, lower_central_series G n ≤ H n\n  | 0 => hH.1.symm ▸ le_refl («expr⊤»)\n  | n + 1 => commutator_le.mpr fun x hx q _ => hH.2 x n (descending_central_series_ge_lower n hx) q\n#align descending_central_series_ge_lower descending_central_series_ge_lower\n\n",
 "derived_le_lower_central":
 "theorem derived_le_lower_central (n : ℕ) : derived_series G n ≤ lower_central_series G n :=\n  by\n  induction' n with i ih\n  · simp\n  · apply commutator_mono ih\n    simp\n#align derived_le_lower_central derived_le_lower_central\n\n",
 "comap_upper_central_series_quotient_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem comap_upper_central_series_quotient_center (n : ℕ) :\n    comap (mk' (center G)) (upper_central_series («expr ⧸ » G (center G)) n) = upper_central_series G n.succ :=\n  by\n  induction' n with n ih\n  · simp\n  · let Hn := upper_central_series («expr ⧸ » G (center G)) n\n    calc\n      comap (mk' (center G)) (upper_central_series_step Hn) =\n          comap (mk' (center G)) (comap (mk' Hn) (center («expr ⧸ » («expr ⧸ » G (center G)) Hn))) :=\n        by rw [upper_central_series_step_eq_comap_center]\n      _ = comap (mk' (comap (mk' (center G)) Hn)) (center («expr ⧸ » G (comap (mk' (center G)) Hn))) :=\n        quotient_group.comap_comap_center\n      _ = comap (mk' (upper_central_series G n.succ)) (center («expr ⧸ » G (upper_central_series G n.succ))) :=\n        comap_center_subst ih\n      _ = upper_central_series_step (upper_central_series G n.succ) :=\n        symm (upper_central_series_step_eq_comap_center _)\n      \n#align comap_upper_central_series_quotient_center comap_upper_central_series_quotient_center\n\n",
 "comap_center_subst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n-- This technical lemma helps with rewriting the subgroup, which occurs in indices\nprivate theorem comap_center_subst {H₁ H₂ : subgroup G} [normal H₁] [normal H₂] (h : H₁ = H₂) :\n    comap (mk' H₁) (center («expr ⧸ » G H₁)) = comap (mk' H₂) (center («expr ⧸ » G H₂)) := by subst h\n#align comap_center_subst comap_center_subst\n\n",
 "ascending_central_series_le_upper":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- is_nilpotent is already defined in the root namespace (for elements of rings).\n/-- Any ascending central series for a group is bounded above by the upper central series. -/\ntheorem ascending_central_series_le_upper (H : ℕ → subgroup G) (hH : is_ascending_central_series H) :\n    ∀ n : ℕ, H n ≤ upper_central_series G n\n  | 0 => hH.1.symm ▸ le_refl («expr⊥»)\n  | n + 1 => by\n    intro x hx\n    rw [mem_upper_central_series_succ_iff]\n    exact fun y => ascending_central_series_le_upper n (hH.2 x n hx y)\n#align ascending_central_series_le_upper ascending_central_series_le_upper\n\n"}