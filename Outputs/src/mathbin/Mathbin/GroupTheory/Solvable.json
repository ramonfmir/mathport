{"solvable_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print solvable_of_surjective /-\ntheorem solvable_of_surjective (hf : function.surjective f) [h : IsSolvable G] : IsSolvable G' :=\n  solvable_of_ker_le_range f (1 : «expr →* » G' G) ((f.range_top_of_surjective hf).symm ▸ le_top)\n#align solvable_of_surjective solvable_of_surjective\n-/\n\n",
 "solvable_of_solvable_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print solvable_of_solvable_injective /-\ntheorem solvable_of_solvable_injective (hf : function.injective f) [h : IsSolvable G'] : IsSolvable G :=\n  solvable_of_ker_le_range (1 : «expr →* » G' G) f ((f.ker_eq_bot_iff.mpr hf).symm ▸ bot_le)\n#align solvable_of_solvable_injective solvable_of_solvable_injective\n-/\n\n",
 "solvable_of_ker_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print solvable_of_ker_le_range /-\ntheorem solvable_of_ker_le_range {G' G'' : Type _} [Group G'] [Group G''] (f : «expr →* » G' G) (g : «expr →* » G G'')\n    (hfg : g.ker ≤ f.range) [hG' : IsSolvable G'] [hG'' : IsSolvable G''] : IsSolvable G :=\n  by\n  obtain ⟨n, hn⟩ := id hG''\n  obtain ⟨m, hm⟩ := id hG'\n  refine' ⟨⟨n + m, le_bot_iff.mp (map_bot f ▸ hm ▸ _)⟩⟩\n  clear hm\n  induction' m with m hm\n  ·\n    exact\n      f.range_eq_map ▸\n        ((derivedSeries G n).map_eq_bot_iff.mp\n              (le_bot_iff.mp ((map_derivedSeries_le_derivedSeries g n).trans hn.le))).trans\n          hfg\n  · exact commutator_le_map_commutator hm hm\n#align solvable_of_ker_le_range solvable_of_ker_le_range\n-/\n\n",
 "not_solvable_of_mem_derivedSeries":
 "#print not_solvable_of_mem_derivedSeries /-\ntheorem not_solvable_of_mem_derivedSeries {g : G} (h1 : g ≠ 1) (h2 : ∀ n : ℕ, g ∈ derivedSeries G n) : ¬IsSolvable G :=\n  mt (isSolvable_def _).mp\n    (not_exists_of_forall_not fun n h => h1 (Subgroup.mem_bot.mp ((congr_arg (has_mem.mem g) h).mp (h2 n))))\n#align not_solvable_of_mem_derived_series not_solvable_of_mem_derivedSeries\n-/\n\n",
 "not_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n#print Equiv.Perm.not_solvable /-\ntheorem Equiv.Perm.not_solvable (X : Type _) (hX : 5 ≤ Cardinal.mk X) : ¬IsSolvable (Equiv.Perm X) :=\n  by\n  intro h\n  have key : Nonempty («expr ↪ » (Fin 5) X) := by\n    rwa [← Cardinal.lift_mk_le, Cardinal.mk_fin, Cardinal.lift_natCast, Nat.cast_bit1, Nat.cast_bit0, Nat.cast_one,\n      Cardinal.lift_id]\n  exact\n    Equiv.Perm.fin_5_not_solvable\n      (solvable_of_solvable_injective (Equiv.Perm.viaEmbeddingHom_injective (Nonempty.some key)))\n#align equiv.perm.not_solvable Equiv.Perm.not_solvable\n-/\n\n",
 "map_derivedSeries_le_derivedSeries":
 "#print map_derivedSeries_le_derivedSeries /-\ntheorem map_derivedSeries_le_derivedSeries (n : ℕ) : (derivedSeries G n).map f ≤ derivedSeries G' n :=\n  by\n  induction' n with n ih\n  · exact le_top\n  · simp only [derivedSeries_succ, map_commutator, commutator_mono, ih]\n#align map_derived_series_le_derived_series map_derivedSeries_le_derivedSeries\n-/\n\n",
 "map_derivedSeries_eq":
 "#print map_derivedSeries_eq /-\ntheorem map_derivedSeries_eq (hf : function.surjective f) (n : ℕ) : (derivedSeries G n).map f = derivedSeries G' n :=\n  le_antisymm (map_derivedSeries_le_derivedSeries f n) (derivedSeries_le_map_derivedSeries hf n)\n#align map_derived_series_eq map_derivedSeries_eq\n-/\n\n",
 "isSolvable_of_top_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isSolvable_of_top_eq_bot /-\ntheorem isSolvable_of_top_eq_bot (h : («expr⊤» : Subgroup G) = «expr⊥») : IsSolvable G :=\n  ⟨⟨0, h⟩⟩\n#align is_solvable_of_top_eq_bot isSolvable_of_top_eq_bot\n-/\n\n",
 "isSolvable_of_comm":
 "#print isSolvable_of_comm /-\ntheorem isSolvable_of_comm {G : Type _} [hG : Group G] (h : ∀ a b : G, a * b = b * a) : IsSolvable G :=\n  by\n  letI hG' : CommGroup G := { hG with mul_comm := h }\n  cases hG\n  exact CommGroup.isSolvable\n#align is_solvable_of_comm isSolvable_of_comm\n-/\n\n",
 "isSolvable_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print isSolvable_def /-\ntheorem isSolvable_def : IsSolvable G ↔ ∃ n : ℕ, derivedSeries G n = «expr⊥» :=\n  ⟨fun h => h.solvable, fun h => ⟨h⟩⟩\n#align is_solvable_def isSolvable_def\n-/\n\n",
 "fin_5_not_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\n#print Equiv.Perm.fin_5_not_solvable /-\ntheorem Equiv.Perm.fin_5_not_solvable : ¬IsSolvable (Equiv.Perm (Fin 5)) :=\n  by\n  let x : Equiv.Perm (Fin 5) :=\n    ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\",\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", by decide, by\n      decide⟩\n  let y : Equiv.Perm (Fin 5) :=\n    ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\",\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", by decide, by\n      decide⟩\n  let z : Equiv.Perm (Fin 5) :=\n    ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\",\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", by decide, by\n      decide⟩\n  have key : x = z * «expr⁅ , ⁆» x (y * x * y⁻¹) * z⁻¹ := by decide\n  refine' not_solvable_of_mem_derivedSeries (show x ≠ 1 by decide) fun n => _\n  induction' n with n ih\n  · exact mem_top x\n  · rw [key, (derivedSeries_normal _ _).mem_comm_iff, inv_mul_cancel_left]\n    exact commutator_mem_commutator ih ((derivedSeries_normal _ _).conj_mem _ ih _)\n#align equiv.perm.fin_5_not_solvable Equiv.Perm.fin_5_not_solvable\n-/\n\n",
 "derivedSeries_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print derivedSeries_zero /-\n/-\nCopyright (c) 2021 Jordan Brown, Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jordan Brown, Thomas Browning, Patrick Lutz\n-/\n@[simp]\ntheorem derivedSeries_zero : derivedSeries G 0 = «expr⊤» :=\n  rfl\n#align derived_series_zero derivedSeries_zero\n-/\n\n",
 "derivedSeries_succ":
 "#print IsSimpleGroup.derivedSeries_succ /-\ntheorem IsSimpleGroup.derivedSeries_succ {n : ℕ} : derivedSeries G n.succ = commutator G :=\n  by\n  induction' n with n ih\n  · exact derivedSeries_one G\n  rw [derivedSeries_succ, ih]\n  cases' (commutator.normal G).eq_bot_or_eq_top with h h\n  · rw [h, commutator_bot_left]\n  · rwa [h]\n#align is_simple_group.derived_series_succ IsSimpleGroup.derivedSeries_succ\n-/\n\n",
 "derivedSeries_one":
 "#print derivedSeries_one /-\n@[simp]\ntheorem derivedSeries_one : derivedSeries G 1 = commutator G :=\n  rfl\n#align derived_series_one derivedSeries_one\n-/\n\n",
 "derivedSeries_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print derivedSeries_normal /-\ntheorem derivedSeries_normal (n : ℕ) : (derivedSeries G n).normal :=\n  by\n  induction' n with n ih\n  · exact («expr⊤» : Subgroup G).normal_of_characteristic\n  · exact Subgroup.commutator_normal (derivedSeries G n) (derivedSeries G n)\n#align derived_series_normal derivedSeries_normal\n-/\n\n",
 "derivedSeries_le_map_derivedSeries":
 "#print derivedSeries_le_map_derivedSeries /-\ntheorem derivedSeries_le_map_derivedSeries (hf : function.surjective f) (n : ℕ) :\n    derivedSeries G' n ≤ (derivedSeries G n).map f :=\n  by\n  induction' n with n ih\n  · exact (map_top_of_surjective f hf).ge\n  · exact commutator_le_map_commutator ih ih\n#align derived_series_le_map_derived_series derivedSeries_le_map_derivedSeries\n-/\n\n",
 "comm_iff_isSolvable":
 "#print IsSimpleGroup.comm_iff_isSolvable /-\ntheorem IsSimpleGroup.comm_iff_isSolvable : (∀ a b : G, a * b = b * a) ↔ IsSolvable G :=\n  ⟨isSolvable_of_comm, fun ⟨⟨n, hn⟩⟩ => by\n    cases n\n    · intro a b\n      refine' (mem_bot.1 _).trans (mem_bot.1 _).symm <;>\n        · rw [← hn]\n          exact mem_top _\n    · rw [IsSimpleGroup.derivedSeries_succ] at hn\n      intro a b\n      rw [← mul_inv_eq_one, mul_inv_rev, ← mul_assoc, ← mem_bot, ← hn, commutator_eq_closure]\n      exact subset_closure ⟨a, b, rfl⟩⟩\n#align is_simple_group.comm_iff_is_solvable IsSimpleGroup.comm_iff_isSolvable\n-/\n\n"}