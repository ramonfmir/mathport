{"solvable_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem solvable_of_surjective (hf : function.surjective f) [h : is_solvable G] : is_solvable G' :=\n  solvable_of_ker_le_range f (1 : «expr →* » G' G) ((f.range_top_of_surjective hf).symm ▸ le_top)\n#align solvable_of_surjective solvable_of_surjective\n\n",
 "solvable_of_solvable_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem solvable_of_solvable_injective (hf : function.injective f) [h : is_solvable G'] : is_solvable G :=\n  solvable_of_ker_le_range (1 : «expr →* » G' G) f ((f.ker_eq_bot_iff.mpr hf).symm ▸ bot_le)\n#align solvable_of_solvable_injective solvable_of_solvable_injective\n\n",
 "solvable_of_ker_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem solvable_of_ker_le_range {G' G'' : Type _} [group G'] [group G''] (f : «expr →* » G' G) (g : «expr →* » G G'')\n    (hfg : g.ker ≤ f.range) [hG' : is_solvable G'] [hG'' : is_solvable G''] : is_solvable G :=\n  by\n  obtain ⟨n, hn⟩ := id hG''\n  obtain ⟨m, hm⟩ := id hG'\n  refine' ⟨⟨n + m, le_bot_iff.mp (map_bot f ▸ hm ▸ _)⟩⟩\n  clear hm\n  induction' m with m hm\n  ·\n    exact\n      f.range_eq_map ▸\n        ((derived_series G n).map_eq_bot_iff.mp\n              (le_bot_iff.mp ((map_derived_series_le_derived_series g n).trans hn.le))).trans\n          hfg\n  · exact commutator_le_map_commutator hm hm\n#align solvable_of_ker_le_range solvable_of_ker_le_range\n\n",
 "not_solvable_of_mem_derived_series":
 "theorem not_solvable_of_mem_derived_series {g : G} (h1 : g ≠ 1) (h2 : ∀ n : ℕ, g ∈ derived_series G n) :\n    ¬is_solvable G :=\n  mt (is_solvable_def _).mp\n    (not_exists_of_forall_not fun n h => h1 (subgroup.mem_bot.mp ((congr_arg (has_mem.mem g) h).mp (h2 n))))\n#align not_solvable_of_mem_derived_series not_solvable_of_mem_derived_series\n\n",
 "not_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem equiv.perm.not_solvable (X : Type _) (hX : 5 ≤ cardinal.mk X) : ¬is_solvable (equiv.perm X) :=\n  by\n  intro h\n  have key : nonempty («expr ↪ » (fin 5) X) := by\n    rwa [← cardinal.lift_mk_le, cardinal.mk_fin, cardinal.lift_nat_cast, Nat.cast_bit1, Nat.cast_bit0, Nat.cast_one,\n      cardinal.lift_id]\n  exact\n    equiv.perm.fin_5_not_solvable\n      (solvable_of_solvable_injective (Equiv.Perm.viaEmbeddingHom_injective (nonempty.some key)))\n#align equiv.perm.not_solvable equiv.perm.not_solvable\n\n",
 "map_derived_series_le_derived_series":
 "theorem map_derived_series_le_derived_series (n : ℕ) : (derived_series G n).map f ≤ derived_series G' n :=\n  by\n  induction' n with n ih\n  · exact le_top\n  · simp only [derived_series_succ, map_commutator, commutator_mono, ih]\n#align map_derived_series_le_derived_series map_derived_series_le_derived_series\n\n",
 "map_derived_series_eq":
 "theorem map_derived_series_eq (hf : function.surjective f) (n : ℕ) : (derived_series G n).map f = derived_series G' n :=\n  le_antisymm (map_derived_series_le_derived_series f n) (derived_series_le_map_derived_series hf n)\n#align map_derived_series_eq map_derived_series_eq\n\n",
 "is_solvable_of_top_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_solvable_of_top_eq_bot (h : («expr⊤» : subgroup G) = «expr⊥») : is_solvable G :=\n  ⟨⟨0, h⟩⟩\n#align is_solvable_of_top_eq_bot is_solvable_of_top_eq_bot\n\n",
 "is_solvable_of_comm":
 "theorem is_solvable_of_comm {G : Type _} [hG : group G] (h : ∀ a b : G, a * b = b * a) : is_solvable G :=\n  by\n  letI hG' : comm_group G := { hG with mul_comm := h }\n  cases hG\n  exact comm_group.is_solvable\n#align is_solvable_of_comm is_solvable_of_comm\n\n",
 "is_solvable_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_solvable_def : is_solvable G ↔ ∃ n : ℕ, derived_series G n = «expr⊥» :=\n  ⟨fun h => h.solvable, fun h => ⟨h⟩⟩\n#align is_solvable_def is_solvable_def\n\n",
 "fin_5_not_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⁅ , ⁆» -/\ntheorem equiv.perm.fin_5_not_solvable : ¬is_solvable (equiv.perm (fin 5)) :=\n  by\n  let x : equiv.perm (fin 5) :=\n    ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\",\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", by decide, by\n      decide⟩\n  let y : equiv.perm (fin 5) :=\n    ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\",\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", by decide, by\n      decide⟩\n  let z : equiv.perm (fin 5) :=\n    ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\",\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", by decide, by\n      decide⟩\n  have key : x = z * «expr⁅ , ⁆» x (y * x * y⁻¹) * z⁻¹ := by decide\n  refine' not_solvable_of_mem_derived_series (show x ≠ 1 by decide) fun n => _\n  induction' n with n ih\n  · exact mem_top x\n  · rw [key, (derived_series_normal _ _).mem_comm_iff, inv_mul_cancel_left]\n    exact commutator_mem_commutator ih ((derived_series_normal _ _).conj_mem _ ih _)\n#align equiv.perm.fin_5_not_solvable equiv.perm.fin_5_not_solvable\n\n",
 "derived_series_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2021 Jordan Brown, Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jordan Brown, Thomas Browning, Patrick Lutz\n-/\n@[simp]\ntheorem derived_series_zero : derived_series G 0 = «expr⊤» :=\n  rfl\n#align derived_series_zero derived_series_zero\n\n",
 "derived_series_succ":
 "theorem is_simple_group.derived_series_succ {n : ℕ} : derived_series G n.succ = commutator G :=\n  by\n  induction' n with n ih\n  · exact derived_series_one G\n  rw [derived_series_succ, ih]\n  cases' (commutator.normal G).eq_bot_or_eq_top with h h\n  · rw [h, commutator_bot_left]\n  · rwa [h]\n#align is_simple_group.derived_series_succ is_simple_group.derived_series_succ\n\n",
 "derived_series_one":
 "@[simp]\ntheorem derived_series_one : derived_series G 1 = commutator G :=\n  rfl\n#align derived_series_one derived_series_one\n\n",
 "derived_series_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem derived_series_normal (n : ℕ) : (derived_series G n).normal :=\n  by\n  induction' n with n ih\n  · exact («expr⊤» : subgroup G).normal_of_characteristic\n  · exact subgroup.commutator_normal (derived_series G n) (derived_series G n)\n#align derived_series_normal derived_series_normal\n\n",
 "derived_series_le_map_derived_series":
 "theorem derived_series_le_map_derived_series (hf : function.surjective f) (n : ℕ) :\n    derived_series G' n ≤ (derived_series G n).map f :=\n  by\n  induction' n with n ih\n  · exact (map_top_of_surjective f hf).ge\n  · exact commutator_le_map_commutator ih ih\n#align derived_series_le_map_derived_series derived_series_le_map_derived_series\n\n",
 "comm_iff_is_solvable":
 "theorem is_simple_group.comm_iff_is_solvable : (∀ a b : G, a * b = b * a) ↔ is_solvable G :=\n  ⟨is_solvable_of_comm, fun ⟨⟨n, hn⟩⟩ => by\n    cases n\n    · intro a b\n      refine' (mem_bot.1 _).trans (mem_bot.1 _).symm <;>\n        · rw [← hn]\n          exact mem_top _\n    · rw [is_simple_group.derived_series_succ] at hn\n      intro a b\n      rw [← mul_inv_eq_one, mul_inv_rev, ← mul_assoc, ← mem_bot, ← hn, commutator_eq_closure]\n      exact subset_closure ⟨a, b, rfl⟩⟩\n#align is_simple_group.comm_iff_is_solvable is_simple_group.comm_iff_is_solvable\n\n"}