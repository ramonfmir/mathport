{"torsion_mul_equiv_symm_apply_coe":
 "@[to_additive]\ntheorem torsion_mul_equiv_symm_apply_coe (tG : is_torsion G) (a : G) :\n    tG.torsion_mul_equiv.symm a = ⟨Submonoid.topEquiv.symm a, tG _⟩ :=\n  rfl\n#align torsion_mul_equiv_symm_apply_coe torsion_mul_equiv_symm_apply_coe\n\n",
 "torsion_mul_equiv_apply":
 "@[to_additive]\ntheorem torsion_mul_equiv_apply (tG : is_torsion G) (a : torsion G) :\n    tG.torsion_mul_equiv a = MulEquiv.submonoidCongr tG.torsion_eq_top a :=\n  rfl\n#align torsion_mul_equiv_apply torsion_mul_equiv_apply\n\n",
 "torsion_eq_torsion_submonoid":
 "/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\n@[to_additive add_torsion_eq_add_torsion_submonoid\n      \"The additive torsion submonoid of an abelian group equals the torsion subgroup as a submonoid.\"]\ntheorem torsion_eq_torsion_submonoid : comm_monoid.torsion G = (torsion G).to_submonoid :=\n  rfl\n#align torsion_eq_torsion_submonoid torsion_eq_torsion_submonoid\n\n",
 "torsion_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The torsion submonoid of a torsion monoid is `⊤`. -/\n@[simp, to_additive \"The additive torsion submonoid of an additive torsion monoid is `⊤`.\"]\ntheorem torsion_eq_top (tG : is_torsion G) : torsion G = «expr⊤» := by ext <;> tauto\n#align torsion_eq_top torsion_eq_top\n\n",
 "subgroup":
 "/-- Subgroups of torsion-free groups are torsion-free. -/\n@[to_additive \"Subgroups of additive torsion-free groups are additively torsion-free.\"]\ntheorem is_torsion_free.subgroup (tG : is_torsion_free G) (H : Subgroup G) : is_torsion_free H := fun h hne =>\n  (isOfFinOrder_iff_coe H.to_submonoid h).not.mpr <| tG h <| by norm_cast <;> simp [hne, not_false_iff]\n#align is_torsion_free.subgroup is_torsion_free.subgroup\n\n",
 "quotient_torsion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\n@[to_additive add_is_torsion_free.quotient_torsion\n      \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"]\ntheorem is_torsion_free.quotient_torsion : is_torsion_free <| «expr ⧸ » G (torsion G) := fun g hne hfin =>\n  hne <| by\n    induction g using QuotientGroup.induction_on'\n    obtain ⟨m, mpos, hm⟩ := (isOfFinOrder_iff_pow_eq_one _).mp hfin\n    obtain ⟨n, npos, hn⟩ := (isOfFinOrder_iff_pow_eq_one _).mp ((QuotientGroup.eq_one_iff _).mp hm)\n    exact\n      (QuotientGroup.eq_one_iff g).mpr\n        ((isOfFinOrder_iff_pow_eq_one _).mpr ⟨m * n, mul_pos mpos npos, (pow_mul g m n).symm ▸ hn⟩)\n#align is_torsion_free.quotient_torsion is_torsion_free.quotient_torsion\n\n",
 "quotient_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The image of a quotient is torsion iff the group is torsion. -/\n@[to_additive add_is_torsion.quotient_iff \"The image of a quotient is additively torsion iff the group is torsion.\"]\ntheorem is_torsion.quotient_iff {f : «expr →* » G H} (hf : function.surjective f) (hN : N = f.ker) (tN : is_torsion N) :\n    is_torsion H ↔ is_torsion G :=\n  ⟨fun tH => is_torsion.extension_closed hN tH tN, fun tG => is_torsion.of_surjective hf tG⟩\n#align is_torsion.quotient_iff is_torsion.quotient_iff\n\n",
 "prod":
 "/-- Direct products of torsion free groups are torsion free. -/\n@[to_additive add_monoid.is_torsion_free.prod \"Direct products of additive torsion free groups are torsion free.\"]\ntheorem is_torsion_free.prod {η : Type _} {Gs : η → Type _} [∀ i, Group (Gs i)] (tfGs : ∀ i, is_torsion_free (Gs i)) :\n    is_torsion_free <| ∀ i, Gs i := fun w hne h =>\n  hne <| funext fun i => Classical.not_not.mp <| mt (tfGs i (w i)) <| Classical.not_not.mpr <| h.apply i\n#align is_torsion_free.prod is_torsion_free.prod\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The image of a surjective torsion group homomorphism is torsion. -/\n@[to_additive add_is_torsion.of_surjective \"The image of a surjective additive torsion group homomorphism is torsion.\"]\ntheorem is_torsion.of_surjective {f : «expr →* » G H} (hf : function.surjective f) (tG : is_torsion G) : is_torsion H :=\n  fun h => by\n  obtain ⟨g, hg⟩ := hf h\n  rw [← hg]\n  exact f.is_of_fin_order (tG g)\n#align is_torsion.of_surjective is_torsion.of_surjective\n\n",
 "not_torsion_free":
 "/-- A nontrivial torsion group is not torsion-free. -/\n@[to_additive add_monoid.is_torsion.not_torsion_free \"A nontrivial additive torsion group is not torsion-free.\"]\ntheorem is_torsion.not_torsion_free [hN : Nontrivial G] : is_torsion G → ¬is_torsion_free G := fun tG =>\n  (not_is_torsion_free_iff _).mpr <|\n    by\n    obtain ⟨x, hx⟩ := (nontrivial_iff_exists_ne (1 : G)).mp hN\n    exact ⟨x, hx, tG x⟩\n#align is_torsion.not_torsion_free is_torsion.not_torsion_free\n\n",
 "not_torsion":
 "/-- A nontrivial torsion-free group is not torsion. -/\n@[to_additive add_monoid.is_torsion_free.not_torsion \"A nontrivial torsion-free additive group is not torsion.\"]\ntheorem is_torsion_free.not_torsion [hN : Nontrivial G] : is_torsion_free G → ¬is_torsion G := fun tfG =>\n  (not_is_torsion_iff _).mpr <|\n    by\n    obtain ⟨x, hx⟩ := (nontrivial_iff_exists_ne (1 : G)).mp hN\n    exact ⟨x, (tfG x) hx⟩\n#align is_torsion_free.not_torsion is_torsion_free.not_torsion\n\n",
 "not_is_torsion_iff":
 "/-\nCopyright (c) 2022 Julian Berman. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Julian Berman\n-/\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\n@[simp, to_additive \"An additive monoid is not a torsion monoid if it has an element of infinite order.\"]\ntheorem not_is_torsion_iff : ¬is_torsion G ↔ ∃ g : G, ¬IsOfFinOrder g := by rw [is_torsion, not_forall]\n#align not_is_torsion_iff not_is_torsion_iff\n\n",
 "not_is_torsion_free_iff":
 "/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\n@[simp, to_additive \"An additive monoid is not torsion free if any nontrivial element has finite order.\"]\ntheorem not_is_torsion_free_iff : ¬is_torsion_free G ↔ ∃ g : G, g ≠ 1 ∧ IsOfFinOrder g := by\n  simp_rw [is_torsion_free, ne.def, not_forall, Classical.not_not, exists_prop]\n#align not_is_torsion_free_iff not_is_torsion_free_iff\n\n",
 "module_of_torsion":
 "-- A (semi/)ring of scalars and a commutative monoid of elements\n/-- A module whose scalars are additively torsion is additively torsion. -/\ntheorem is_torsion.module_of_torsion [Semiring R] [Module R M] (tR : is_torsion R) : is_torsion M := fun f =>\n  (isOfFinAddOrder_iff_nsmul_eq_zero _).mpr <|\n    by\n    obtain ⟨n, npos, hn⟩ := (isOfFinAddOrder_iff_nsmul_eq_zero _).mp (tR 1)\n    exact ⟨n, npos, by simp only [nsmul_eq_smul_cast R _ f, ← nsmul_one, hn, zero_smul]⟩\n#align is_torsion.module_of_torsion is_torsion.module_of_torsion\n\n",
 "module_of_finite":
 "/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem is_torsion.module_of_finite [Ring R] [Finite R] [Module R M] : is_torsion M :=\n  (is_add_torsion_of_finite : is_torsion R).module_of_torsion _ _\n#align is_torsion.module_of_finite is_torsion.module_of_finite\n\n",
 "is_torsion_of_finite":
 "/-- Finite groups are torsion groups. -/\n@[to_additive is_add_torsion_of_finite \"Finite additive groups are additive torsion groups.\"]\ntheorem is_torsion_of_finite [Finite G] : is_torsion G :=\n  exponent_exists.is_torsion <| exponent_exists_iff_ne_zero.mpr exponent_ne_zero_of_finite\n#align is_torsion_of_finite is_torsion_of_finite\n\n",
 "is_torsion":
 "/-- Torsion submonoids are torsion. -/\n@[to_additive \"Additive torsion submonoids are additively torsion.\"]\ntheorem torsion.is_torsion : is_torsion <| torsion G := fun ⟨_, n, npos, hn⟩ =>\n  ⟨n, npos,\n    Subtype.ext <| by\n      rw [mul_left_iterate, _root_.mul_one, [anonymous], Subtype.coe_mk, Submonoid.coe_one,\n        (isPeriodicPt_mul_iff_pow_eq_one _).mp hn]⟩\n#align torsion.is_torsion torsion.is_torsion\n\n",
 "is_p_group":
 "/-- The `p`-primary component is a `p` group. -/\ntheorem primary_component.is_p_group : is_p_group p <| primary_component G p := fun g =>\n  (propext exists_orderOf_eq_prime_pow_iff.symm).mpr (comm_monoid.primary_component.exists_order_of_eq_prime_pow g)\n#align primary_component.is_p_group primary_component.is_p_group\n\n",
 "extension_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- Torsion groups are closed under extensions. -/\n@[to_additive add_is_torsion.extension_closed \"Additive torsion groups are closed under extensions.\"]\ntheorem is_torsion.extension_closed {f : «expr →* » G H} (hN : N = f.ker) (tH : is_torsion H) (tN : is_torsion N) :\n    is_torsion G := fun g =>\n  (isOfFinOrder_iff_pow_eq_one _).mpr <|\n    by\n    obtain ⟨ngn, ngnpos, hngn⟩ := (isOfFinOrder_iff_pow_eq_one _).mp (tH <| f g)\n    have hmem := f.mem_ker.mpr ((f.map_pow g ngn).trans hngn)\n    lift g ^ ngn to N using hN.symm ▸ hmem with gn\n    obtain ⟨nn, nnpos, hnn⟩ := (isOfFinOrder_iff_pow_eq_one _).mp (tN gn)\n    exact ⟨ngn * nn, mul_pos ngnpos nnpos, by rw [pow_mul, ← h, ← Subgroup.coe_pow, hnn, Subgroup.coe_one]⟩\n#align is_torsion.extension_closed is_torsion.extension_closed\n\n",
 "exponent_exists":
 "/-- The group exponent exists for any bounded torsion group. -/\n@[to_additive is_add_torsion.exponent_exists \"The group exponent exists for any bounded additive torsion group.\"]\ntheorem is_torsion.exponent_exists (tG : is_torsion G) (bounded : (Set.range fun g : G => orderOf g).finite) :\n    exponent_exists G :=\n  exponent_exists_iff_ne_zero.mpr <|\n    (exponent_ne_zero_iff_range_order_of_finite fun g => orderOf_pos' (tG g)).mpr bounded\n#align is_torsion.exponent_exists is_torsion.exponent_exists\n\n",
 "exists_order_of_eq_prime_pow":
 "/-- Elements of the `p`-primary component have order `p^n` for some `n`. -/\n@[to_additive \"Elements of the `p`-primary component have additive order `p^n` for some `n`\"]\ntheorem primary_component.exists_order_of_eq_prime_pow (g : comm_monoid.primary_component G p) :\n    ∃ n : ℕ, orderOf g = p ^ n := by simpa [primary_component] using g.property\n#align primary_component.exists_order_of_eq_prime_pow primary_component.exists_order_of_eq_prime_pow\n\n",
 "disjoint":
 "/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\n@[to_additive \"The `p`- and `q`-primary components are disjoint for `p ≠ q`.\"]\ntheorem primary_component.disjoint {p' : ℕ} [hp' : Fact p'.prime] (hne : p ≠ p') :\n    Disjoint (comm_monoid.primary_component G p) (comm_monoid.primary_component G p') :=\n  Submonoid.disjoint_def.mpr <| by\n    rintro g ⟨_ | n, hn⟩ ⟨n', hn'⟩\n    · rwa [pow_zero, orderOf_eq_one_iff] at hn\n    · exact absurd (eq_of_prime_pow_eq hp.out.prime hp'.out.prime n.succ_pos (hn.symm.trans hn')) hne\n#align primary_component.disjoint primary_component.disjoint\n\n"}