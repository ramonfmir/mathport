{"supr_eq_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem supr_eq_closure {ι : Sort _} (p : ι → Subsemigroup M) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) =\n      Subsemigroup.closure\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (p i : set M)) :=\n  by simp_rw [Subsemigroup.closure_unionᵢ, Subsemigroup.closure_eq]\n#align supr_eq_closure supr_eq_closure\n\n",
 "subsingleton_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem subsingleton_of_subsingleton [subsingleton (Subsemigroup M)] : subsingleton M :=\n  by\n  constructor <;> intro x y\n  have : ∀ a : M, a ∈ («expr⊥» : Subsemigroup M) := by simp [subsingleton.elim («expr⊥» : Subsemigroup M) («expr⊤»)]\n  exact absurd (this x) not_mem_bot\n#align subsingleton_of_subsingleton subsingleton_of_subsingleton\n\n",
 "subset_closure":
 "/-- The subsemigroup generated by a set includes the set. -/\n@[simp, to_additive \"The `add_subsemigroup` generated by a set includes the set.\"]\ntheorem subset_closure : s ⊆ closure s := fun x hx => mem_closure.2 fun S hS => hS hx\n#align subset_closure subset_closure\n\n",
 "not_mem_of_not_mem_closure":
 "@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n\n",
 "not_mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive]\ntheorem not_mem_bot {x : M} : x ∉ («expr⊥» : Subsemigroup M) :=\n  Set.not_mem_empty x\n#align not_mem_bot not_mem_bot\n\n",
 "mul_mem":
 "/-- A subsemigroup is closed under multiplication. -/\n@[to_additive \"An `add_subsemigroup` is closed under addition.\"]\nprotected theorem mul_mem {x y : M} : x ∈ S → y ∈ S → x * y ∈ S :=\n  subsemigroup.mul_mem' S\n#align mul_mem mul_mem\n\n",
 "mk_le_mk":
 "@[simp, to_additive]\ntheorem mk_le_mk {s t : set M} (h_mul) (h_mul') : mk s h_mul ≤ mk t h_mul' ↔ s ⊆ t :=\n  iff.rfl\n#align mk_le_mk mk_le_mk\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem mem_top (x : M) : x ∈ («expr⊤» : Subsemigroup M) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem mem_supr {ι : Sort _} (p : ι → Subsemigroup M) {m : M} :\n    m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) ↔\n      ∀ N, (∀ i, p i ≤ N) → m ∈ N :=\n  by\n  rw [← closure_singleton_le_iff_mem, le_supᵢ_iff]\n  simp only [closure_singleton_le_iff_mem]\n#align mem_supr mem_supr\n\n",
 "mem_mk":
 "@[simp, to_additive]\ntheorem mem_mk {s : set M} {x : M} (h_mul) : x ∈ mk s h_mul ↔ x ∈ s :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[to_additive]\ntheorem mem_infi {ι : Sort _} {S : ι → Subsemigroup M} {x : M} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem mem_inf {p p' : Subsemigroup M} {x : M} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_closure":
 "@[to_additive]\ntheorem mem_closure {x : M} : x ∈ closure s ↔ ∀ S : Subsemigroup M, s ⊆ S → x ∈ S :=\n  mem_Inf\n#align mem_closure mem_closure\n\n",
 "mem_carrier":
 "/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Kenny Lau, Johan Commelin, Mario Carneiro, Kevin Buzzard,\nAmelia Livingston, Yury Kudryashov, Yakov Pechersky\n-/\n-- Only needed for notation\n-- Only needed for notation\n@[simp, to_additive]\ntheorem mem_carrier {s : Subsemigroup M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_Inf":
 "@[to_additive]\ntheorem mem_Inf {S : set (Subsemigroup M)} {x : M} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "ext":
 "/-- Two subsemigroups are equal if they have the same elements. -/\n@[ext, to_additive \"Two `add_subsemigroup`s are equal if they have the same elements.\"]\ntheorem ext {S T : Subsemigroup M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "eq_on_mclosure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n/-- If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. -/\n@[to_additive \"If two add homomorphisms are equal on a set,\\nthen they are equal on its additive subsemigroup closure.\"]\ntheorem eq_on_mclosure {f g : «expr →ₙ* » M N} {s : set M} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eq_mlocus g from closure_le.2 h\n#align eq_on_mclosure eq_on_mclosure\n\n",
 "eq_of_eq_on_mtop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[to_additive]\ntheorem eq_of_eq_on_mtop {f g : «expr →ₙ* » M N} (h : Set.EqOn f g («expr⊤» : Subsemigroup M)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_mtop eq_of_eq_on_mtop\n\n",
 "eq_of_eq_on_mdense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₙ* » -/\n@[to_additive]\ntheorem eq_of_eq_on_mdense {s : set M} (hs : closure s = «expr⊤») {f g : «expr →ₙ* » M N} (h : s.eq_on f g) : f = g :=\n  eq_of_eq_on_mtop <| hs ▸ eqOn_closure h\n#align eq_of_eq_on_mdense eq_of_eq_on_mdense\n\n",
 "dense_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `s` is a dense set in a magma `M`, `subsemigroup.closure s = ⊤`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`,\nand verify that `p x` and `p y` imply `p (x * y)`. -/\n@[elab_as_elim,\n  to_additive\n      \"If `s` is a dense set in an additive monoid `M`,\\n`add_subsemigroup.closure s = ⊤`, then in order to prove that some predicate `p` holds\\nfor all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify that `p x` and `p y` imply\\n`p (x + y)`.\"]\ntheorem dense_induction {p : M → Prop} (x : M) {s : set M} (hs : closure s = «expr⊤») (Hs : ∀ x ∈ s, p x)\n    (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  by\n  have : ∀ x ∈ closure s, p x := fun x hx => closure_induction hx Hs Hmul\n  simpa [hs] using this x\n#align dense_induction dense_induction\n\n",
 "copy_eq":
 "@[to_additive]\ntheorem copy_eq {s : set M} (hs : s = S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem coe_top : ((«expr⊤» : Subsemigroup M) : set M) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_set_mk":
 "@[simp, to_additive]\ntheorem coe_set_mk {s : set M} (h_mul) : (mk s h_mul : set M) = s :=\n  rfl\n#align coe_set_mk coe_set_mk\n\n",
 "coe_of_mdense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, norm_cast, to_additive]\ntheorem coe_of_mdense [semigroup M] [semigroup N] {s : set M} (f : M → N) (hs : closure s = «expr⊤») (hmul) :\n    (ofDense f hs hmul : M → N) = f :=\n  rfl\n#align coe_of_mdense coe_of_mdense\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_infi {ι : Sort _} {S : ι → Subsemigroup M} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : set M) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp only [infᵢ, coe_Inf, Set.binterᵢ_range]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, to_additive]\ntheorem coe_inf (p p' : Subsemigroup M) : ((«expr ⊓ » p p' : Subsemigroup M) : set M) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_copy":
 "@[simp, to_additive]\ntheorem coe_copy {s : set M} (hs : s = S) : (S.copy s hs : set M) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem coe_bot : ((«expr⊥» : Subsemigroup M) : set M) = ∅ :=\n  rfl\n#align coe_bot coe_bot\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast, to_additive]\ntheorem coe_Inf (S : set (Subsemigroup M)) :\n    ((infₛ S : Subsemigroup M) : set M) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, to_additive]\ntheorem closure_univ : closure (univ : set M) = «expr⊤» :=\n  @coe_top M _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem closure_union (s t : set M) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (Subsemigroup.gi M).gc.l_sup\n#align closure_union closure_union\n\n",
 "closure_singleton_le_iff_mem":
 "@[simp, to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Subsemigroup M) : closure {m} ≤ p ↔ m ∈ p := by\n  rw [closure_le, singleton_subset_iff, SetLike.mem_coe]\n#align closure_singleton_le_iff_mem closure_singleton_le_iff_mem\n\n",
 "closure_mono":
 "/-- subsemigroup closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[to_additive\n      \"Additive subsemigroup closure of a set is monotone in its argument: if `s ⊆ t`,\\nthen `closure s ≤ closure t`\"]\ntheorem closure_mono ⦃s t : set M⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Subset.trans h subset_closure\n#align closure_mono closure_mono\n\n",
 "closure_le":
 "/-- A subsemigroup `S` includes `closure s` if and only if it includes `s`. -/\n@[simp, to_additive \"An additive subsemigroup `S` includes `closure s`\\nif and only if it includes `s`\"]\ntheorem closure_le : closure s ≤ S ↔ s ⊆ S :=\n  ⟨Subset.trans subset_closure, fun h => infₛ_le h⟩\n#align closure_le closure_le\n\n",
 "closure_induction₂":
 "/-- An induction principle for closure membership for predicates with two arguments.  -/\n@[elab_as_elim,\n  to_additive \"An induction principle for additive closure membership for\\npredicates with two arguments.\"]\ntheorem closure_induction₂ {p : M → M → Prop} {x} {y : M} (hx : x ∈ closure s) (hy : y ∈ closure s)\n    (Hs : ∀ x ∈ s, ∀ y ∈ s, p x y) (Hmul_left : ∀ x y z, p x z → p y z → p (x * y) z)\n    (Hmul_right : ∀ x y z, p z x → p z y → p z (x * y)) : p x y :=\n  closure_induction hx (fun x xs => closure_induction hy (Hs x xs) fun z y h₁ h₂ => Hmul_right z _ _ h₁ h₂)\n    fun x z h₁ h₂ => Hmul_left _ _ _ h₁ h₂\n#align closure_induction₂ closure_induction₂\n\n",
 "closure_induction'":
 "/-- A dependent version of `subsemigroup.closure_induction`.  -/\n@[elab_as_elim, to_additive \"A dependent version of `add_subsemigroup.closure_induction`. \"]\ntheorem closure_induction' (s : set M) {p : ∀ x, x ∈ closure s → Prop} (Hs : ∀ (x) (h : x ∈ s), p x (subset_closure h))\n    (Hmul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) {x} (hx : x ∈ closure s) : p x hx :=\n  by\n  refine' exists.elim _ fun (hx : x ∈ closure s) (hc : p x hx) => hc\n  exact closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ => ⟨_, Hmul _ _ _ _ hx hy⟩\n#align closure_induction' closure_induction'\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. -/\n@[elab_as_elim,\n  to_additive\n      \"An induction principle for additive closure membership. If `p`\\nholds for all elements of `s`, and is preserved under addition, then `p` holds for all\\nelements of the additive closure of `s`.\"]\ntheorem closure_induction {p : M → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x)\n    (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  (@closure_le _ _ _ ⟨p, Hmul⟩).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_eq_of_le":
 "@[to_additive]\ntheorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure s) : closure s = S :=\n  le_antisymm (closure_le.2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a subsemigroup `S` equals `S`. -/\n@[simp, to_additive \"Additive closure of an additive subsemigroup `S` equals `S`\"]\ntheorem closure_eq : closure (S : set M) = S :=\n  (Subsemigroup.gi M).l_u_eq S\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, to_additive]\ntheorem closure_empty : closure (∅ : set M) = «expr⊥» :=\n  (Subsemigroup.gi M).gc.l_bot\n#align closure_empty closure_empty\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[to_additive]\ntheorem closure_Union {ι} (s : ι → set M) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (Subsemigroup.gi M).gc.l_supr\n#align closure_Union closure_Union\n\n"}