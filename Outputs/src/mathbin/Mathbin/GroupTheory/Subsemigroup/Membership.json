{"supr_induction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A dependent version of `subsemigroup.supr_induction`. -/\n@[elab_as_elim, to_additive \"A dependent version of `add_subsemigroup.supr_induction`. \"]\ntheorem supr_induction' (S : ι → Subsemigroup M)\n    {C :\n      ∀ x,\n        x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) →\n          Prop}\n    (hp : ∀ (i), ∀ x ∈ S i, C x (mem_supᵢ_of_mem i ‹_›))\n    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i)) :\n    C x hx :=\n  by\n  refine'\n    exists.elim _\n      fun\n        (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i))\n        (hc : C x hx) =>\n      hc\n  refine' supr_induction S hx (fun i x hx => _) fun x y => _\n  · exact ⟨_, hp _ _ hx⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, hmul _ _ _ _ Cx Cy⟩\n#align supr_induction' supr_induction'\n\n",
 "supr_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[elab_as_elim,\n  to_additive\n      \" An induction principle for elements of `⨆ i, S i`.\\nIf `C` holds all elements of `S i` for all `i`, and is preserved under addition,\\nthen it holds for all elements of the supremum of `S`. \"]\ntheorem supr_induction (S : ι → Subsemigroup M) {C : M → Prop} {x : M}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i))\n    (hp : ∀ (i), ∀ x ∈ S i, C x) (hmul : ∀ x y, C x → C y → C (x * y)) : C x :=\n  by\n  rw [supr_eq_closure] at hx\n  refine' closure_induction hx (fun x hx => _) hmul\n  obtain ⟨i, hi⟩ := set.mem_Union.mp hx\n  exact hp _ _ hi\n#align supr_induction supr_induction\n\n",
 "mul_mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ «expr ⊔ » S T :=\n  mul_mem (mem_sup_left hx) (mem_sup_right hy)\n#align mul_mem_sup mul_mem_sup\n\n",
 "mem_supr_of_mem":
 "@[to_additive]\ntheorem mem_supr_of_mem {S : ι → Subsemigroup M} (i : ι) : ∀ {x : M}, x ∈ S i → x ∈ supᵢ S :=\n  show S i ≤ supᵢ S from le_supᵢ _ _\n#align mem_supr_of_mem mem_supr_of_mem\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\n-- TODO: this section can be generalized to `[mul_mem_class B M] [complete_lattice B]`\n-- such that `complete_lattice.le` coincides with `set_like.le`\n@[to_additive]\ntheorem mem_supr_of_directed {S : ι → Subsemigroup M} (hS : Directed (· ≤ ·) S) {x : M} :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ i, x ∈ S i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ S i) hi⟩\n  suffices\n    x ∈\n        closure\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (S i : set M)) →\n      ∃ i, x ∈ S i\n    by simpa only [closure_Union, closure_eq (S _)] using this\n  refine' fun hx => closure_induction hx (fun y hy => mem_Union.mp hy) _\n  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hS i j with ⟨k, hki, hkj⟩\n    exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup_right {S T : Subsemigroup M} : ∀ {x : M}, x ∈ T → x ∈ «expr ⊔ » S T :=\n  show T ≤ «expr ⊔ » S T from le_sup_right\n#align mem_sup_right mem_sup_right\n\n",
 "mem_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[to_additive]\ntheorem mem_sup_left {S T : Subsemigroup M} : ∀ {x : M}, x ∈ S → x ∈ «expr ⊔ » S T :=\n  show S ≤ «expr ⊔ » S T from le_sup_left\n#align mem_sup_left mem_sup_left\n\n",
 "mem_Sup_of_mem":
 "@[to_additive]\ntheorem mem_Sup_of_mem {S : set (Subsemigroup M)} {s : Subsemigroup M} (hs : s ∈ S) : ∀ {x : M}, x ∈ s → x ∈ supₛ S :=\n  show s ≤ supₛ S from le_supₛ hs\n#align mem_Sup_of_mem mem_Sup_of_mem\n\n",
 "mem_Sup_of_directed_on":
 "@[to_additive]\ntheorem mem_Sup_of_directed_on {S : set (Subsemigroup M)} (hS : DirectedOn (· ≤ ·) S) {x : M} :\n    x ∈ supₛ S ↔ ∃ s ∈ S, x ∈ s := by\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hS.directed_coe, SetCoe.exists, subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem coe_supr_of_directed {S : ι → Subsemigroup M} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          Subsemigroup M) :\n        set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_Sup_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[to_additive]\ntheorem coe_Sup_of_directed_on {S : set (Subsemigroup M)} (hS : DirectedOn (· ≤ ·) S) :\n    (↑(supₛ S) : set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑s :=\n  Set.ext fun x => by simp [mem_Sup_of_directed_on hS]\n#align coe_Sup_of_directed_on coe_Sup_of_directed_on\n\n"}