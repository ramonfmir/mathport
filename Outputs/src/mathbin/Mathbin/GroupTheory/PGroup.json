{"to_sup_of_normal_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem to_sup_of_normal_right' {H K : subgroup G} (hH : is_p_group p H) (hK : is_p_group p K)\n    (hHK : H ≤ K.normalizer) : is_p_group p («expr ⊔ » H K : subgroup G) :=\n  let hHK' :=\n    to_sup_of_normal_right (hH.of_equiv (subgroup.subgroup_of_equiv_of_le hHK).symm)\n      (hK.of_equiv (subgroup.subgroup_of_equiv_of_le subgroup.le_normalizer).symm)\n  ((congr_arg (fun H : subgroup K.normalizer => is_p_group p H)\n            (subgroup.sup_subgroup_of_eq hHK subgroup.le_normalizer)).mp\n        hHK').of_equiv\n    (subgroup.subgroup_of_equiv_of_le (sup_le hHK subgroup.le_normalizer))\n#align to_sup_of_normal_right' to_sup_of_normal_right'\n\n",
 "to_sup_of_normal_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem to_sup_of_normal_right {H K : subgroup G} (hH : is_p_group p H) (hK : is_p_group p K) [K.normal] :\n    is_p_group p («expr ⊔ » H K : subgroup G) :=\n  by\n  rw [← quotient_group.ker_mk K, ← subgroup.comap_map_eq]\n  apply (hH.map (quotient_group.mk' K)).comap_of_ker_is_p_group\n  rwa [quotient_group.ker_mk]\n#align to_sup_of_normal_right to_sup_of_normal_right\n\n",
 "to_sup_of_normal_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem to_sup_of_normal_left' {H K : subgroup G} (hH : is_p_group p H) (hK : is_p_group p K) (hHK : K ≤ H.normalizer) :\n    is_p_group p («expr ⊔ » H K : subgroup G) :=\n  (congr_arg (fun H : subgroup G => is_p_group p H) sup_comm).mp (to_sup_of_normal_right' hK hH hHK)\n#align to_sup_of_normal_left' to_sup_of_normal_left'\n\n",
 "to_sup_of_normal_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem to_sup_of_normal_left {H K : subgroup G} (hH : is_p_group p H) (hK : is_p_group p K) [H.normal] :\n    is_p_group p («expr ⊔ » H K : subgroup G) :=\n  (congr_arg (fun H : subgroup G => is_p_group p H) sup_comm).mp (to_sup_of_normal_right hK hH)\n#align to_sup_of_normal_left to_sup_of_normal_left\n\n",
 "to_subgroup":
 "theorem to_subgroup (H : subgroup G) : is_p_group p H :=\n  hG.of_injective H.subtype subtype.coe_injective\n#align to_subgroup to_subgroup\n\n",
 "to_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem to_quotient (H : subgroup G) [H.normal] : is_p_group p («expr ⧸ » G H) :=\n  hG.of_surjective (quotient_group.mk' H) Quotient.surjective_Quotient_mk''\n#align to_quotient to_quotient\n\n",
 "to_le":
 "theorem to_le {H K : subgroup G} (hK : is_p_group p K) (hHK : H ≤ K) : is_p_group p H :=\n  hK.of_injective (subgroup.inclusion hHK) fun a b h => subtype.ext (show _ from subtype.ext_iff.mp h)\n#align to_le to_le\n\n",
 "to_inf_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem to_inf_right {H K : subgroup G} (hK : is_p_group p K) : is_p_group p («expr ⊓ » H K : subgroup G) :=\n  hK.to_le inf_le_right\n#align to_inf_right to_inf_right\n\n",
 "to_inf_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem to_inf_left {H K : subgroup G} (hH : is_p_group p H) : is_p_group p («expr ⊓ » H K : subgroup G) :=\n  hH.to_le inf_le_left\n#align to_inf_left to_inf_left\n\n",
 "pow_equiv_symm_apply":
 "@[simp]\ntheorem pow_equiv_symm_apply {n : ℕ} (hn : p.coprime n) (g : G) : (hG.pow_equiv hn).symm g = g ^ (order_of g).gcd_b n :=\n  by rw [order_eq_card_zpowers'] <;> rfl\n#align pow_equiv_symm_apply pow_equiv_symm_apply\n\n",
 "pow_equiv_apply":
 "@[simp]\ntheorem pow_equiv_apply {n : ℕ} (hn : p.coprime n) (g : G) : hG.pow_equiv hn g = g ^ n :=\n  rfl\n#align pow_equiv_apply pow_equiv_apply\n\n",
 "order_of_coprime":
 "theorem order_of_coprime {n : ℕ} (hn : p.coprime n) (g : G) : (order_of g).coprime n :=\n  let ⟨k, hk⟩ := hG g\n  (hn.pow_left k).coprime_dvd_left (order_of_dvd_of_pow_eq_one hk)\n#align order_of_coprime order_of_coprime\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem of_surjective {H : Type _} [group H] (ϕ : «expr →* » G H) (hϕ : function.surjective ϕ) : is_p_group p H :=\n  by\n  refine' fun h => exists.elim (hϕ h) fun g hg => Exists.imp (fun k hk => _) (hG g)\n  rw [← hg, ← ϕ.map_pow, hk, ϕ.map_one]\n#align of_surjective of_surjective\n\n",
 "of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem of_injective {H : Type _} [group H] (ϕ : «expr →* » H G) (hϕ : function.injective ϕ) : is_p_group p H :=\n  by\n  simp_rw [is_p_group, ← hϕ.eq_iff, ϕ.map_pow, ϕ.map_one]\n  exact fun h => hG (ϕ h)\n#align of_injective of_injective\n\n",
 "of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\ntheorem of_equiv {H : Type _} [group H] (ϕ : «expr ≃* » G H) : is_p_group p H :=\n  hG.of_surjective ϕ.to_monoid_hom ϕ.surjective\n#align of_equiv of_equiv\n\n",
 "of_card":
 "theorem of_card [fintype G] {n : ℕ} (hG : card G = p ^ n) : is_p_group p G := fun g =>\n  ⟨n, by rw [← hG, pow_card_eq_one]⟩\n#align of_card of_card\n\n",
 "of_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem of_bot : is_p_group p («expr⊥» : subgroup G) :=\n  of_card (subgroup.card_bot.trans (pow_zero p).symm)\n#align of_bot of_bot\n\n",
 "nontrivial_iff_card":
 "theorem nontrivial_iff_card [fintype G] : nontrivial G ↔ ∃ n > 0, card G = p ^ n :=\n  ⟨fun hGnt =>\n    let ⟨k, hk⟩ := iff_card.1 hG\n    ⟨k, nat.pos_of_ne_zero fun hk0 => by rw [hk0, pow_zero] at hk <;> exact fintype.one_lt_card.ne' hk, hk⟩,\n    fun ⟨k, hk0, hk⟩ => one_lt_card_iff_nontrivial.1 <| hk.symm ▸ one_lt_pow (fact.out p.prime).one_lt (ne_of_gt hk0)⟩\n#align nontrivial_iff_card nontrivial_iff_card\n\n",
 "nonempty_fixed_point_of_prime_not_dvd_card":
 "/-- If a p-group acts on `α` and the cardinality of `α` is not a multiple\n  of `p` then the action has a fixed point. -/\ntheorem nonempty_fixed_point_of_prime_not_dvd_card (hpα : ¬p ∣ card α) [Finite (fixed_points G α)] :\n    (fixed_points G α).nonempty :=\n  @Set.nonempty_of_nonempty_subtype _ _\n    (by\n      cases nonempty_fintype (fixed_points G α)\n      rw [← card_pos_iff, pos_iff_ne_zero]\n      contrapose! hpα\n      rw [← Nat.modEq_zero_iff_dvd, ← hpα]\n      exact hG.card_modeq_card_fixed_points α)\n#align nonempty_fixed_point_of_prime_not_dvd_card nonempty_fixed_point_of_prime_not_dvd_card\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem map {H : subgroup G} (hH : is_p_group p H) {K : Type _} [group K] (ϕ : «expr →* » G K) :\n    is_p_group p (H.map ϕ) := by\n  rw [← H.subtype_range, monoid_hom.map_range]\n  exact hH.of_surjective (ϕ.restrict H).range_restrict (ϕ.restrict H).range_restrict_surjective\n#align map map\n\n",
 "ker_is_p_group_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem ker_is_p_group_of_injective {K : Type _} [group K] {ϕ : «expr →* » K G} (hϕ : function.injective ϕ) :\n    is_p_group p ϕ.ker :=\n  (congr_arg (fun Q : subgroup K => is_p_group p Q) (ϕ.ker_eq_bot_iff.mpr hϕ)).mpr is_p_group.of_bot\n#align ker_is_p_group_of_injective ker_is_p_group_of_injective\n\n",
 "index":
 "theorem index (H : subgroup G) [H.finite_index] : ∃ n : ℕ, H.index = p ^ n :=\n  by\n  haveI := H.normal_core.fintype_quotient_of_finite_index\n  obtain ⟨n, hn⟩ := iff_card.mp (hG.to_quotient H.normal_core)\n  obtain ⟨k, hk1, hk2⟩ :=\n    (Nat.dvd_prime_pow hp.out).mp\n      ((congr_arg _ (H.normal_core.index_eq_card.trans hn)).mp (subgroup.index_dvd_of_le H.normal_core_le))\n  exact ⟨k, hk2⟩\n#align index index\n\n",
 "iff_order_of":
 "/-\nCopyright (c) 2018 . All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Thomas Browning\n-/\ntheorem iff_order_of [hp : fact p.prime] : is_p_group p G ↔ ∀ g : G, ∃ k : ℕ, order_of g = p ^ k :=\n  forall_congr' fun g =>\n    ⟨fun ⟨k, hk⟩ => Exists.imp (fun j => Exists.snd) ((Nat.dvd_prime_pow hp.out).mp (order_of_dvd_of_pow_eq_one hk)),\n      Exists.imp fun k hk => by rw [← hk, pow_order_of_eq_one]⟩\n#align iff_order_of iff_order_of\n\n",
 "iff_card":
 "theorem iff_card [fact p.prime] [fintype G] : is_p_group p G ↔ ∃ n : ℕ, card G = p ^ n :=\n  by\n  have hG : card G ≠ 0 := card_ne_zero\n  refine' ⟨fun h => _, fun ⟨n, hn⟩ => of_card hn⟩\n  suffices ∀ q ∈ nat.factors (card G), q = p by\n    use (card G).factors.length\n    rw [← List.prod_replicate, ← List.eq_replicate_of_mem this, nat.prod_factors hG]\n  intro q hq\n  obtain ⟨hq1, hq2⟩ := (nat.mem_factors hG).mp hq\n  haveI : fact q.prime := ⟨hq1⟩\n  obtain ⟨g, hg⟩ := exists_prime_order_of_dvd_card q hq2\n  obtain ⟨k, hk⟩ := (iff_order_of.mp h) g\n  exact (hq1.pow_eq_iff.mp (hg.symm.trans hk).symm).1.symm\n#align iff_card iff_card\n\n",
 "exists_fixed_point_of_prime_dvd_card_of_fixed_point":
 "/-- If a p-group acts on `α` and the cardinality of `α` is a multiple\n  of `p`, and the action has one fixed point, then it has another fixed point. -/\ntheorem exists_fixed_point_of_prime_dvd_card_of_fixed_point (hpα : p ∣ card α) {a : α} (ha : a ∈ fixed_points G α) :\n    ∃ b, b ∈ fixed_points G α ∧ a ≠ b :=\n  by\n  cases nonempty_fintype (fixed_points G α)\n  have hpf : p ∣ card (fixed_points G α) :=\n    nat.modeq_zero_iff_dvd.mp ((hG.card_modeq_card_fixed_points α).symm.trans hpα.modeq_zero_nat)\n  have hα : 1 < card (fixed_points G α) :=\n    (fact.out p.prime).one_lt.trans_le (nat.le_of_dvd (card_pos_iff.2 ⟨⟨a, ha⟩⟩) hpf)\n  exact\n    let ⟨⟨b, hb⟩, hba⟩ := exists_ne_of_one_lt_card hα ⟨a, ha⟩\n    ⟨b, hb, fun hab => hba (by simp_rw [hab])⟩\n#align exists_fixed_point_of_prime_dvd_card_of_fixed_point exists_fixed_point_of_prime_dvd_card_of_fixed_point\n\n",
 "disjoint_of_ne":
 "/-- p-groups with different p are disjoint -/\ntheorem disjoint_of_ne (p₁ p₂ : ℕ) [hp₁ : fact p₁.prime] [hp₂ : fact p₂.prime] (hne : p₁ ≠ p₂) (H₁ H₂ : subgroup G)\n    (hH₁ : is_p_group p₁ H₁) (hH₂ : is_p_group p₂ H₂) : Disjoint H₁ H₂ :=\n  by\n  rw [subgroup.disjoint_def]\n  intro x hx₁ hx₂\n  obtain ⟨n₁, hn₁⟩ := iff_order_of.mp hH₁ ⟨x, hx₁⟩\n  obtain ⟨n₂, hn₂⟩ := iff_order_of.mp hH₂ ⟨x, hx₂⟩\n  rw [← order_of_subgroup, subgroup.coe_mk] at hn₁ hn₂\n  have : p₁ ^ n₁ = p₂ ^ n₂ := by rw [← hn₁, ← hn₂]\n  rcases n₁.eq_zero_or_pos with (rfl | hn₁)\n  · simpa using hn₁\n  · exact absurd (eq_of_prime_pow_eq hp₁.out.prime hp₂.out.prime hn₁ this) hne\n#align disjoint_of_ne disjoint_of_ne\n\n",
 "cyclic_center_quotient_of_card_eq_prime_sq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem cyclic_center_quotient_of_card_eq_prime_sq (hG : card G = p ^ 2) : is_cyclic («expr ⧸ » G (center G)) := by\n  classical\n    rcases card_center_eq_prime_pow hG zero_lt_two with ⟨k, hk0, hk⟩\n    rw [card_eq_card_quotient_mul_card_subgroup (center G), mul_comm, hk] at hG\n    have hk2 := (Nat.pow_dvd_pow_iff_le_right (fact.out p.prime).one_lt).1 ⟨_, hG.symm⟩\n    interval_cases k\n    · rw [sq, pow_one, mul_right_inj' (fact.out p.prime).ne_zero] at hG\n      exact is_cyclic_of_prime_card hG\n    ·\n      exact\n        @is_cyclic_of_subsingleton _ _\n          ⟨fintype.card_le_one_iff.1\n              (mul_right_injective₀ (pow_ne_zero 2 (ne_zero.ne p)) (hG.trans (mul_one (p ^ 2)).symm)).le⟩\n#align cyclic_center_quotient_of_card_eq_prime_sq cyclic_center_quotient_of_card_eq_prime_sq\n\n",
 "coprime_card_of_ne":
 "/-- finite p-groups with different p have coprime orders -/\ntheorem coprime_card_of_ne {G₂ : Type _} [group G₂] (p₁ p₂ : ℕ) [hp₁ : fact p₁.prime] [hp₂ : fact p₂.prime]\n    (hne : p₁ ≠ p₂) (H₁ : subgroup G) (H₂ : subgroup G₂) [fintype H₁] [fintype H₂] (hH₁ : is_p_group p₁ H₁)\n    (hH₂ : is_p_group p₂ H₂) : nat.coprime (fintype.card H₁) (fintype.card H₂) :=\n  by\n  obtain ⟨n₁, heq₁⟩ := iff_card.mp hH₁; rw [heq₁]; clear heq₁\n  obtain ⟨n₂, heq₂⟩ := iff_card.mp hH₂; rw [heq₂]; clear heq₂\n  exact Nat.coprime_pow_primes _ _ hp₁.elim hp₂.elim hne\n#align coprime_card_of_ne coprime_card_of_ne\n\n",
 "commutative_of_card_eq_prime_sq":
 "/-- A group of order `p ^ 2` is commutative. See also `is_p_group.comm_group_of_card_eq_prime_sq`\nfor the `comm_group` instance. -/\ntheorem commutative_of_card_eq_prime_sq (hG : card G = p ^ 2) : ∀ a b : G, a * b = b * a :=\n  (comm_group_of_card_eq_prime_sq hG).mul_comm\n#align commutative_of_card_eq_prime_sq commutative_of_card_eq_prime_sq\n\n",
 "comap_subtype":
 "theorem comap_subtype {H : subgroup G} (hH : is_p_group p H) {K : subgroup G} : is_p_group p (H.comap K.subtype) :=\n  hH.comap_of_injective K.subtype subtype.coe_injective\n#align comap_subtype comap_subtype\n\n",
 "comap_of_ker_is_p_group":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem comap_of_ker_is_p_group {H : subgroup G} (hH : is_p_group p H) {K : Type _} [group K] (ϕ : «expr →* » K G)\n    (hϕ : is_p_group p ϕ.ker) : is_p_group p (H.comap ϕ) :=\n  by\n  intro g\n  obtain ⟨j, hj⟩ := hH ⟨ϕ g.1, g.2⟩\n  rw [subtype.ext_iff, H.coe_pow, subtype.coe_mk, ← ϕ.map_pow] at hj\n  obtain ⟨k, hk⟩ := hϕ ⟨g.1 ^ p ^ j, hj⟩\n  rwa [subtype.ext_iff, ϕ.ker.coe_pow, subtype.coe_mk, ← pow_mul, ← pow_add] at hk\n  exact ⟨j + k, by rwa [subtype.ext_iff, (H.comap ϕ).coe_pow]⟩\n#align comap_of_ker_is_p_group comap_of_ker_is_p_group\n\n",
 "comap_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\ntheorem comap_of_injective {H : subgroup G} (hH : is_p_group p H) {K : Type _} [group K] (ϕ : «expr →* » K G)\n    (hϕ : function.injective ϕ) : is_p_group p (H.comap ϕ) :=\n  hH.comap_of_ker_is_p_group ϕ (ker_is_p_group_of_injective hϕ)\n#align comap_of_injective comap_of_injective\n\n",
 "center_nontrivial":
 "theorem center_nontrivial [nontrivial G] [Finite G] : nontrivial (subgroup.center G) := by\n  classical\n    cases nonempty_fintype G\n    have := (hG.of_equiv conj_act.to_conj_act).exists_fixed_point_of_prime_dvd_card_of_fixed_point G\n    rw [conj_act.fixed_points_eq_center] at this\n    obtain ⟨g, hg⟩ := this _ (subgroup.center G).one_mem\n    · exact ⟨⟨1, ⟨g, hg.1⟩, mt subtype.ext_iff.mp hg.2⟩⟩\n    · obtain ⟨n, hn0, hn⟩ := hG.nontrivial_iff_card.mp infer_instance\n      exact hn.symm ▸ dvd_pow_self _ (ne_of_gt hn0)\n#align center_nontrivial center_nontrivial\n\n",
 "card_orbit":
 "theorem card_orbit (a : α) [fintype (orbit G a)] : ∃ n : ℕ, card (orbit G a) = p ^ n :=\n  by\n  let ϕ := orbit_equiv_quotient_stabilizer G a\n  haveI := fintype.of_equiv (orbit G a) ϕ\n  haveI := (stabilizer G a).finite_index_of_finite_quotient\n  rw [card_congr ϕ, ← subgroup.index_eq_card]\n  exact hG.index (stabilizer G a)\n#align card_orbit card_orbit\n\n",
 "card_modeq_card_fixed_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- If `G` is a `p`-group acting on a finite set `α`, then the number of fixed points\n  of the action is congruent mod `p` to the cardinality of `α` -/\ntheorem card_modeq_card_fixed_points [fintype (fixed_points G α)] :\n    «expr ≡ [MOD ]» (card α) (card (fixed_points G α)) p := by\n  classical\n    calc\n      card α = card (Σy : quotient (orbit_rel G α), { x // quotient.mk' x = y }) :=\n        card_congr (Equiv.sigmaFiberEquiv (@quotient.mk' _ (orbit_rel G α))).symm\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (card { x // quotient.mk' x = a }) :=\n        card_sigma _\n      «expr ≡ [MOD ]» _\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" 1)\n          p :=\n        _\n      _ = _ := by simp <;> rfl\n      \n    rw [← zmod.eq_iff_modeq_nat p, nat.cast_sum, nat.cast_sum]\n    have key : ∀ x, card { y // (quotient.mk' y : quotient (orbit_rel G α)) = quotient.mk' x } = card (orbit G x) :=\n      fun x => by simp only [quotient.eq'] <;> congr\n    refine'\n      eq.symm\n        (finset.sum_bij_ne_zero (fun a _ _ => quotient.mk' a.1) (fun _ _ _ => finset.mem_univ _)\n          (fun a₁ a₂ _ _ _ _ h => subtype.eq ((mem_fixed_points' α).mp a₂.2 a₁.1 (quotient.exact' h)))\n          (fun b => Quotient.inductionOn' b fun b _ hb => _) fun a ha _ => by\n          rw [key, mem_fixed_points_iff_card_orbit_eq_one.mp a.2])\n    obtain ⟨k, hk⟩ := hG.card_orbit b\n    have : k = 0 :=\n      le_zero_iff.1\n        (nat.le_of_lt_succ\n          (lt_of_not_ge\n            (mt (pow_dvd_pow p)\n              (by rwa [pow_one, ← hk, ← Nat.modEq_zero_iff_dvd, ← zmod.eq_iff_modeq_nat, ← key, Nat.cast_zero]))))\n    exact\n      ⟨⟨b, mem_fixed_points_iff_card_orbit_eq_one.2 <| by rw [hk, this, pow_zero]⟩, finset.mem_univ _,\n        ne_of_eq_of_ne Nat.cast_one one_ne_zero, rfl⟩\n#align card_modeq_card_fixed_points card_modeq_card_fixed_points\n\n",
 "card_eq_or_dvd":
 "theorem card_eq_or_dvd : nat.card G = 1 ∨ p ∣ nat.card G :=\n  by\n  cases fintype_or_infinite G\n  · obtain ⟨n, hn⟩ := iff_card.mp hG\n    rw [nat.card_eq_fintype_card, hn]\n    cases n\n    · exact or.inl rfl\n    · exact or.inr ⟨p ^ n, rfl⟩\n  · rw [nat.card_eq_zero_of_infinite]\n    exact or.inr ⟨0, rfl⟩\n#align card_eq_or_dvd card_eq_or_dvd\n\n",
 "card_center_eq_prime_pow":
 "/-- The cardinality of the `center` of a `p`-group is `p ^ k` where `k` is positive. -/\ntheorem card_center_eq_prime_pow (hn : 0 < n) [fintype (center G)] : ∃ k > 0, card (center G) = p ^ k :=\n  by\n  have hcG := to_subgroup (of_card hGpn) (center G)\n  rcases iff_card.1 hcG with ⟨k, hk⟩\n  haveI : nontrivial G := (nontrivial_iff_card <| of_card hGpn).2 ⟨n, hn, hGpn⟩\n  exact (nontrivial_iff_card hcG).mp (center_nontrivial (of_card hGpn))\n#align card_center_eq_prime_pow card_center_eq_prime_pow\n\n",
 "bot_lt_center":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bot_lt_center [nontrivial G] [Finite G] : «expr⊥» < subgroup.center G :=\n  by\n  haveI := center_nontrivial hG\n  cases nonempty_fintype G\n  classical exact bot_lt_iff_ne_bot.mpr ((subgroup.center G).one_lt_card_iff_ne_bot.mp fintype.one_lt_card)\n#align bot_lt_center bot_lt_center\n\n"}