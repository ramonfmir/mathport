{"zpowers_equiv_zpowers_apply":
 "@[simp, to_additive zmultiples_equiv_zmultiples_apply]\ntheorem zpowers_equiv_zpowers_apply [Finite G] (h : order_of x = order_of y) (n : ℕ) :\n    zpowers_equiv_zpowers h ⟨x ^ n, n, zpow_ofNat x n⟩ = ⟨y ^ n, n, zpow_ofNat y n⟩ :=\n  by\n  rw [zpowers_equiv_zpowers, equiv.trans_apply, equiv.trans_apply, fin_equiv_zpowers_symm_apply, ← equiv.eq_symm_apply,\n    fin_equiv_zpowers_symm_apply]\n  simp [h]\n#align zpowers_equiv_zpowers_apply zpowers_equiv_zpowers_apply\n\n",
 "zpow_pow_order_of":
 "@[simp, to_additive zsmul_smul_order_of]\ntheorem zpow_pow_order_of : (x ^ i) ^ order_of x = 1 :=\n  by\n  by_cases h : is_of_fin_order x\n  · rw [← zpow_ofNat, ← zpow_mul, mul_comm, zpow_mul, zpow_ofNat, pow_order_of_eq_one, one_zpow]\n  · rw [order_of_eq_zero h, pow_zero]\n#align zpow_pow_order_of zpow_pow_order_of\n\n",
 "zpow_eq_mod_order_of":
 "@[to_additive zsmul_eq_mod_add_order_of]\ntheorem zpow_eq_mod_order_of : x ^ i = x ^ (i % order_of x) :=\n  calc\n    x ^ i = x ^ (i % order_of x + order_of x * (i / order_of x)) := by rw [Int.mod_add_div]\n    _ = x ^ (i % order_of x) := by simp [zpow_add, zpow_mul, pow_order_of_eq_one]\n    \n#align zpow_eq_mod_order_of zpow_eq_mod_order_of\n\n",
 "zpow_eq_mod_card":
 "@[to_additive]\ntheorem zpow_eq_mod_card (n : ℤ) : x ^ n = x ^ (n % fintype.card G) := by\n  rw [zpow_eq_mod_order_of, ← Int.emod_emod_of_dvd n (Int.coe_nat_dvd.2 order_of_dvd_card_univ), ← zpow_eq_mod_order_of]\n#align zpow_eq_mod_card zpow_eq_mod_card\n\n",
 "zpow":
 "@[to_additive is_of_fin_add_order.zsmul]\ntheorem is_of_fin_order.zpow (h : is_of_fin_order x) {i : ℤ} : is_of_fin_order (x ^ i) :=\n  (is_of_fin_order_iff_pow_eq_one _).mpr ⟨order_of x, order_of_pos' h, zpow_pow_order_of⟩\n#align is_of_fin_order.zpow is_of_fin_order.zpow\n\n",
 "vadd_eq_self_of_mem_zmultiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem vadd_eq_self_of_mem_zmultiples {α G : Type _} [add_group G] [AddAction G α] {x y : G}\n    (hx : x ∈ add_subgroup.zmultiples y) {a : α} (hs : «expr +ᵥ » y a = a) : «expr +ᵥ » x a = a :=\n  @smul_eq_self_of_mem_zpowers (Multiplicative G) _ _ _ α _ hx a hs\n#align vadd_eq_self_of_mem_zmultiples vadd_eq_self_of_mem_zmultiples\n\n",
 "sum_card_order_of_eq_card_pow_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[to_additive sum_card_add_order_of_eq_card_nsmul_eq_zero]\ntheorem sum_card_order_of_eq_card_pow_eq_one [fintype G] [decidable_eq G] (hn : n ≠ 0) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((Finset.range n.succ).filter (· ∣ n)) (finset.univ.filter fun x : G => order_of x = m).card =\n      (finset.univ.filter fun x : G => x ^ n = 1).card :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((Finset.range n.succ).filter (· ∣ n)) (finset.univ.filter fun x : G => order_of x = m).card =\n        _ :=\n      (finset.card_bUnion\n          (by\n            intros\n            apply Finset.disjoint_filter.2\n            cc)).symm\n    _ = _ :=\n      congr_arg finset.card\n        (Finset.ext\n          (by\n            intro x\n            suffices order_of x ≤ n ∧ order_of x ∣ n ↔ x ^ n = 1 by simpa [Nat.lt_succ_iff]\n            exact\n              ⟨fun h => by\n                let ⟨m, hm⟩ := h.2\n                rw [hm, pow_mul, pow_order_of_eq_one, one_pow], fun h =>\n                ⟨order_of_le_of_pow_eq_one hn.bot_lt h, order_of_dvd_of_pow_eq_one h⟩⟩))\n    \n#align sum_card_order_of_eq_card_pow_eq_one sum_card_order_of_eq_card_pow_eq_one\n\n",
 "smul_eq_self_of_mem_zpowers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_eq_self_of_mem_zpowers {α : Type _} [MulAction G α] (hx : x ∈ subgroup.zpowers y) {a : α}\n    (hs : «expr • » y a = a) : «expr • » x a = a :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp hx\n  rw [← mul_action.to_perm_apply, ← mul_action.to_perm_hom_apply, MonoidHom.map_zpow _ y k,\n    mul_action.to_perm_hom_apply]\n  exact Function.IsFixedPt.perm_zpow hs k\n#align smul_eq_self_of_mem_zpowers smul_eq_self_of_mem_zpowers\n\n",
 "powers_equiv_powers_apply":
 "@[simp, to_additive multiples_equiv_multiples_apply]\ntheorem powers_equiv_powers_apply [Finite G] (h : order_of x = order_of y) (n : ℕ) :\n    powers_equiv_powers h ⟨x ^ n, n, rfl⟩ = ⟨y ^ n, n, rfl⟩ :=\n  by\n  rw [powers_equiv_powers, equiv.trans_apply, equiv.trans_apply, fin_equiv_powers_symm_apply, ← equiv.eq_symm_apply,\n    fin_equiv_powers_symm_apply]\n  simp [h]\n#align powers_equiv_powers_apply powers_equiv_powers_apply\n\n",
 "powers_eq_zpowers":
 "@[to_additive multiples_eq_zmultiples]\ntheorem powers_eq_zpowers [Finite G] (x : G) : (submonoid.powers x : set G) = zpowers x :=\n  Set.ext fun x => mem_powers_iff_mem_zpowers\n#align powers_eq_zpowers powers_eq_zpowers\n\n",
 "pow_order_of_eq_one":
 "@[to_additive add_order_of_nsmul_eq_zero]\ntheorem pow_order_of_eq_one (x : G) : x ^ order_of x = 1 :=\n  by\n  convert is_periodic_pt_minimal_period ((· * ·) x) _\n  rw [order_of, mul_left_iterate, mul_one]\n#align pow_order_of_eq_one pow_order_of_eq_one\n\n",
 "pow_ne_one_of_lt_order_of'":
 "@[to_additive nsmul_ne_zero_of_lt_add_order_of']\ntheorem pow_ne_one_of_lt_order_of' (n0 : n ≠ 0) (h : n < order_of x) : x ^ n ≠ 1 := fun j =>\n  not_is_periodic_pt_of_pos_of_lt_minimal_period n0 h ((is_periodic_pt_mul_iff_pow_eq_one x).mpr j)\n#align pow_ne_one_of_lt_order_of' pow_ne_one_of_lt_order_of'\n\n",
 "pow_injective_of_lt_order_of":
 "@[to_additive nsmul_injective_of_lt_add_order_of]\ntheorem pow_injective_of_lt_order_of (hn : n < order_of x) (hm : m < order_of x) (eq : x ^ n = x ^ m) : n = m :=\n  eq_of_lt_minimal_period_of_iterate_eq hn hm (by simpa only [mul_left_iterate, mul_one] )\n#align pow_injective_of_lt_order_of pow_injective_of_lt_order_of\n\n",
 "pow_inj_mod":
 "@[to_additive]\ntheorem pow_inj_mod {n m : ℕ} : x ^ n = x ^ m ↔ n % order_of x = m % order_of x :=\n  by\n  cases' (order_of x).zero_le.eq_or_lt with hx hx\n  · simp [pow_inj_iff_of_order_of_eq_zero, hx.symm]\n  rw [pow_eq_mod_order_of, @pow_eq_mod_order_of _ _ _ m]\n  exact ⟨pow_injective_of_lt_order_of _ (nat.mod_lt _ hx) (nat.mod_lt _ hx), fun h => congr_arg _ h⟩\n#align pow_inj_mod pow_inj_mod\n\n",
 "pow_inj_iff_of_order_of_eq_zero":
 "@[to_additive nsmul_inj_iff_of_add_order_of_eq_zero]\ntheorem pow_inj_iff_of_order_of_eq_zero (h : order_of x = 0) {n m : ℕ} : x ^ n = x ^ m ↔ n = m :=\n  by\n  rw [order_of_eq_zero_iff, is_of_fin_order_iff_pow_eq_one] at h\n  push_neg  at h\n  induction' n with n IH generalizing m\n  · cases m\n    · simp\n    · simpa [eq_comm] using h m.succ m.zero_lt_succ\n  · cases m\n    · simpa using h n.succ n.zero_lt_succ\n    · simp [pow_succ, IH]\n#align pow_inj_iff_of_order_of_eq_zero pow_inj_iff_of_order_of_eq_zero\n\n",
 "pow_index_mem":
 "@[to_additive]\ntheorem subgroup.pow_index_mem {G : Type _} [group G] (H : subgroup G) [normal H] (g : G) : g ^ index H ∈ H := by\n  rw [← eq_one_iff, quotient_group.coe_pow H, index, pow_card_eq_one']\n#align subgroup.pow_index_mem subgroup.pow_index_mem\n\n",
 "pow_gcd_card_eq_one_iff":
 "/-- TODO: Generalise to `finite` + `cancel_monoid`. -/\n@[to_additive gcd_nsmul_card_eq_zero_iff \"TODO: Generalise to `finite` + `cancel_add_monoid`\"]\ntheorem pow_gcd_card_eq_one_iff : x ^ n = 1 ↔ x ^ gcd n (fintype.card G) = 1 :=\n  ⟨fun h => pow_gcd_eq_one _ h <| pow_card_eq_one, fun h =>\n    by\n    let ⟨m, hm⟩ := gcd_dvd_left n (fintype.card G)\n    rw [hm, pow_mul, h, one_pow]⟩\n#align pow_gcd_card_eq_one_iff pow_gcd_card_eq_one_iff\n\n",
 "pow_eq_pow_iff_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n@[to_additive]\ntheorem pow_eq_pow_iff_modeq : x ^ n = x ^ m ↔ «expr ≡ [MOD ]» n m (order_of x) :=\n  by\n  wlog hmn : m ≤ n\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n  rw [← mul_one (x ^ m), pow_add, mul_left_cancel_iff, pow_eq_one_iff_modeq]\n  exact ⟨fun h => Nat.ModEq.add_left _ h, fun h => Nat.ModEq.add_left_cancel' _ h⟩\n#align pow_eq_pow_iff_modeq pow_eq_pow_iff_modeq\n\n",
 "pow_eq_one_iff_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n@[to_additive]\ntheorem pow_eq_one_iff_modeq : x ^ n = 1 ↔ «expr ≡ [MOD ]» n 0 (order_of x) := by\n  rw [modeq_zero_iff_dvd, order_of_dvd_iff_pow_eq_one]\n#align pow_eq_one_iff_modeq pow_eq_one_iff_modeq\n\n",
 "pow_eq_mod_order_of":
 "@[to_additive nsmul_eq_mod_add_order_of]\ntheorem pow_eq_mod_order_of {n : ℕ} : x ^ n = x ^ (n % order_of x) :=\n  calc\n    x ^ n = x ^ (n % order_of x + order_of x * (n / order_of x)) := by rw [nat.mod_add_div]\n    _ = x ^ (n % order_of x) := by simp [pow_add, pow_mul, pow_order_of_eq_one]\n    \n#align pow_eq_mod_order_of pow_eq_mod_order_of\n\n",
 "pow_eq_mod_card":
 "@[to_additive]\ntheorem pow_eq_mod_card (n : ℕ) : x ^ n = x ^ (n % fintype.card G) := by\n  rw [pow_eq_mod_order_of, ← Nat.mod_mod_of_dvd n order_of_dvd_card_univ, ← pow_eq_mod_order_of]\n#align pow_eq_mod_card pow_eq_mod_card\n\n",
 "pow_coprime_one":
 "@[simp, to_additive]\ntheorem pow_coprime_one {G : Type _} [group G] (h : (nat.card G).coprime n) : pow_coprime h 1 = 1 :=\n  one_pow n\n#align pow_coprime_one pow_coprime_one\n\n",
 "pow_coprime_inv":
 "@[simp, to_additive]\ntheorem pow_coprime_inv {G : Type _} [group G] (h : (nat.card G).coprime n) {g : G} :\n    pow_coprime h g⁻¹ = (pow_coprime h g)⁻¹ :=\n  inv_pow g n\n#align pow_coprime_inv pow_coprime_inv\n\n",
 "pow_card_eq_one'":
 "@[simp, to_additive card_nsmul_eq_zero']\ntheorem pow_card_eq_one' {G : Type _} [group G] {x : G} : x ^ nat.card G = 1 :=\n  order_of_dvd_iff_pow_eq_one.mp order_of_dvd_nat_card\n#align pow_card_eq_one' pow_card_eq_one'\n\n",
 "pow_card_eq_one":
 "@[simp, to_additive card_nsmul_eq_zero]\ntheorem pow_card_eq_one : x ^ fintype.card G = 1 := by rw [← nat.card_eq_fintype_card, pow_card_eq_one']\n#align pow_card_eq_one pow_card_eq_one\n\n",
 "order_of_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[to_additive]\ntheorem order_of_units {y : «expr ˣ» G} : order_of (y : G) = order_of y :=\n  order_of_injective (Units.coeHom G) Units.ext y\n#align order_of_units order_of_units\n\n",
 "order_of_submonoid":
 "@[simp, norm_cast, to_additive]\ntheorem order_of_submonoid {H : Submonoid G} (y : H) : order_of (y : G) = order_of y :=\n  order_of_injective H.subtype subtype.coe_injective y\n#align order_of_submonoid order_of_submonoid\n\n",
 "order_of_subgroup":
 "@[simp, norm_cast, to_additive]\ntheorem order_of_subgroup {H : subgroup G} (y : H) : order_of (y : G) = order_of y :=\n  order_of_injective H.subtype subtype.coe_injective y\n#align order_of_subgroup order_of_subgroup\n\n",
 "order_of_pow_dvd":
 "@[to_additive add_order_of_smul_dvd]\ntheorem order_of_pow_dvd (n : ℕ) : order_of (x ^ n) ∣ order_of x := by\n  rw [order_of_dvd_iff_pow_eq_one, pow_right_comm, pow_order_of_eq_one, one_pow]\n#align order_of_pow_dvd order_of_pow_dvd\n\n",
 "order_of_pow_coprime":
 "@[to_additive add_order_of_nsmul_coprime]\ntheorem order_of_pow_coprime (h : (order_of y).coprime m) : order_of (y ^ m) = order_of y :=\n  by\n  by_cases hg : order_of y = 0\n  · rw [m.coprime_zero_left.mp (hg ▸ h), pow_one]\n  · rw [order_of_pow'' y m (hg.imp_symm order_of_eq_zero), h.gcd_eq_one, nat.div_one]\n#align order_of_pow_coprime order_of_pow_coprime\n\n",
 "order_of_pow''":
 "@[to_additive add_order_of_nsmul'']\ntheorem order_of_pow'' (h : is_of_fin_order x) : order_of (x ^ n) = order_of x / gcd (order_of x) n :=\n  by\n  convert minimal_period_iterate_eq_div_gcd' h\n  simp only [order_of, mul_left_iterate]\n#align order_of_pow'' order_of_pow''\n\n",
 "order_of_pow'":
 "@[to_additive add_order_of_nsmul']\ntheorem order_of_pow' (h : n ≠ 0) : order_of (x ^ n) = order_of x / gcd (order_of x) n :=\n  by\n  convert minimal_period_iterate_eq_div_gcd h\n  simp only [order_of, mul_left_iterate]\n#align order_of_pow' order_of_pow'\n\n",
 "order_of_pow":
 "/-- This is the same as `order_of_pow'` and `order_of_pow''` but with one assumption less which is\nautomatic in the case of a finite cancellative monoid.-/\n@[to_additive add_order_of_nsmul\n      \"This is the same as `add_order_of_nsmul'` and `add_order_of_nsmul` but with one assumption less\\nwhich is automatic in the case of a finite cancellative additive monoid.\"]\ntheorem order_of_pow [Finite G] (x : G) : order_of (x ^ n) = order_of x / gcd (order_of x) n :=\n  order_of_pow'' _ _ (exists_pow_eq_one _)\n#align order_of_pow order_of_pow\n\n",
 "order_of_pos_iff":
 "/-- A group element has finite order iff its order is positive. -/\n@[to_additive add_order_of_pos_iff \"A group element has finite additive order iff its order is positive.\"]\ntheorem order_of_pos_iff : 0 < order_of x ↔ is_of_fin_order x := by\n  rwa [iff_not_comm.mp order_of_eq_zero_iff, pos_iff_ne_zero]\n#align order_of_pos_iff order_of_pos_iff\n\n",
 "order_of_pos'":
 "@[to_additive add_order_of_pos']\ntheorem order_of_pos' (h : is_of_fin_order x) : 0 < order_of x :=\n  minimal_period_pos_of_mem_periodic_pts h\n#align order_of_pos' order_of_pos'\n\n",
 "order_of_pos":
 "/-- This is the same as `order_of_pos' but with one fewer explicit assumption since this is\n  automatic in case of a finite cancellative monoid.-/\n@[to_additive add_order_of_pos\n      \"This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is\\n  automatic in case of a finite cancellative additive monoid.\"]\ntheorem order_of_pos [Finite G] (x : G) : 0 < order_of x :=\n  order_of_pos' (exists_pow_eq_one x)\n#align order_of_pos order_of_pos\n\n",
 "order_of_one":
 "@[simp, to_additive]\ntheorem order_of_one : order_of (1 : G) = 1 := by rw [order_of, one_mul_eq_id, minimal_period_id]\n#align order_of_one order_of_one\n\n",
 "order_of_of_add_eq_add_order_of":
 "@[simp]\ntheorem order_of_of_add_eq_add_order_of (a : A) : order_of (Multiplicative.ofAdd a) = add_order_of a :=\n  rfl\n#align order_of_of_add_eq_add_order_of order_of_of_add_eq_add_order_of\n\n",
 "order_of_mul_eq_right_of_forall_prime_mul_dvd":
 "/-- If each prime factor of `order_of x` has higher multiplicity in `order_of y`, and `x` commutes\n  with `y`, then `x * y` has the same order as `y`. -/\n@[to_additive add_order_of_add_eq_right_of_forall_prime_mul_dvd\n      \"If each prime factor of\\n  `add_order_of x` has higher multiplicity in `add_order_of y`, and `x` commutes with `y`,\\n  then `x + y` has the same order as `y`.\"]\ntheorem order_of_mul_eq_right_of_forall_prime_mul_dvd (hy : is_of_fin_order y)\n    (hdvd : ∀ p : ℕ, p.prime → p ∣ order_of x → p * order_of x ∣ order_of y) : order_of (x * y) = order_of y :=\n  by\n  have hoy := order_of_pos' hy\n  have hxy := dvd_of_forall_prime_mul_dvd hdvd\n  apply order_of_eq_of_pow_and_pow_div_prime hoy <;> simp only [ne, ← order_of_dvd_iff_pow_eq_one]\n  · exact trans h.order_of_mul_dvd_lcm (lcm_dvd hxy dvd_rfl)\n  refine' fun p hp hpy hd => hp.ne_one _\n  rw [← Nat.dvd_one, ← mul_dvd_mul_iff_right hoy.ne', one_mul, ← dvd_div_iff hpy]\n  refine' trans (order_of_dvd_lcm_mul h) (lcm_dvd ((dvd_div_iff hpy).2 _) hd)\n  by_cases p ∣ order_of x\n  exacts[hdvd p hp h, (hp.coprime_iff_not_dvd.2 h).mul_dvd_of_dvd_of_dvd hpy hxy]\n#align order_of_mul_eq_right_of_forall_prime_mul_dvd order_of_mul_eq_right_of_forall_prime_mul_dvd\n\n",
 "order_of_mul_eq_mul_order_of_of_coprime":
 "@[to_additive add_order_of_add_eq_mul_add_order_of_of_coprime]\ntheorem order_of_mul_eq_mul_order_of_of_coprime (hco : (order_of x).coprime (order_of y)) :\n    order_of (x * y) = order_of x * order_of y :=\n  by\n  convert h.function_commute_mul_left.minimal_period_of_comp_eq_mul_of_coprime hco\n  simp only [order_of, comp_mul_left]\n#align order_of_mul_eq_mul_order_of_of_coprime order_of_mul_eq_mul_order_of_of_coprime\n\n",
 "order_of_mul_dvd_mul_order_of":
 "@[to_additive add_order_of_add_dvd_mul_add_order_of]\ntheorem order_of_mul_dvd_mul_order_of : order_of (x * y) ∣ order_of x * order_of y :=\n  dvd_trans h.order_of_mul_dvd_lcm (lcm_dvd_mul _ _)\n#align order_of_mul_dvd_mul_order_of order_of_mul_dvd_mul_order_of\n\n",
 "order_of_mul_dvd_lcm":
 "@[to_additive]\ntheorem order_of_mul_dvd_lcm : order_of (x * y) ∣ nat.lcm (order_of x) (order_of y) :=\n  by\n  convert function.commute.minimal_period_of_comp_dvd_lcm h.function_commute_mul_left\n  rw [order_of, comp_mul_left]\n#align order_of_mul_dvd_lcm order_of_mul_dvd_lcm\n\n",
 "order_of_map_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive add_order_of_map_dvd]\ntheorem order_of_map_dvd {H : Type _} [monoid H] (ψ : «expr →* » G H) (x : G) : order_of (ψ x) ∣ order_of x :=\n  by\n  apply order_of_dvd_of_pow_eq_one\n  rw [← map_pow, pow_order_of_eq_one]\n  apply map_one\n#align order_of_map_dvd order_of_map_dvd\n\n",
 "order_of_le_two":
 "theorem linear_ordered_ring.order_of_le_two : order_of x ≤ 2 :=\n  by\n  cases' ne_or_eq (|x|) 1 with h h\n  · simp [order_of_abs_ne_one h]\n  rcases eq_or_eq_neg_of_abs_eq h with (rfl | rfl)\n  · simp\n  apply order_of_le_of_pow_eq_one <;> norm_num\n#align linear_ordered_ring.order_of_le_two linear_ordered_ring.order_of_le_two\n\n",
 "order_of_le_of_pow_eq_one":
 "@[to_additive add_order_of_le_of_nsmul_eq_zero]\ntheorem order_of_le_of_pow_eq_one (hn : 0 < n) (h : x ^ n = 1) : order_of x ≤ n :=\n  is_periodic_pt.minimal_period_le hn (by rwa [is_periodic_pt_mul_iff_pow_eq_one])\n#align order_of_le_of_pow_eq_one order_of_le_of_pow_eq_one\n\n",
 "order_of_le_card_univ":
 "@[to_additive add_order_of_le_card_univ]\ntheorem order_of_le_card_univ [fintype G] : order_of x ≤ fintype.card G :=\n  finset.le_card_of_inj_on_range ((· ^ ·) x) (fun n _ => finset.mem_univ _) fun i hi j hj =>\n    pow_injective_of_lt_order_of x hi hj\n#align order_of_le_card_univ order_of_le_card_univ\n\n",
 "order_of_inv":
 "@[simp, to_additive]\ntheorem order_of_inv (x : G) : order_of x⁻¹ = order_of x := by simp [order_of_eq_order_of_iff]\n#align order_of_inv order_of_inv\n\n",
 "order_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive add_order_of_injective]\ntheorem order_of_injective {H : Type _} [monoid H] (f : «expr →* » G H) (hf : function.injective f) (x : G) :\n    order_of (f x) = order_of x := by\n  simp_rw [order_of_eq_order_of_iff, ← f.map_pow, ← f.map_one, hf.eq_iff, iff_self_iff, forall_const]\n#align order_of_injective order_of_injective\n\n",
 "order_of_eq_zero_iff'":
 "@[to_additive add_order_of_eq_zero_iff']\ntheorem order_of_eq_zero_iff' : order_of x = 0 ↔ ∀ n : ℕ, 0 < n → x ^ n ≠ 1 := by\n  simp_rw [order_of_eq_zero_iff, is_of_fin_order_iff_pow_eq_one, not_exists, not_and]\n#align order_of_eq_zero_iff' order_of_eq_zero_iff'\n\n",
 "order_of_eq_zero_iff":
 "@[to_additive add_order_of_eq_zero_iff]\ntheorem order_of_eq_zero_iff : order_of x = 0 ↔ ¬is_of_fin_order x :=\n  ⟨fun h H => (order_of_pos' H).ne' h, order_of_eq_zero⟩\n#align order_of_eq_zero_iff order_of_eq_zero_iff\n\n",
 "order_of_eq_zero":
 "@[to_additive add_order_of_eq_zero]\ntheorem order_of_eq_zero (h : ¬is_of_fin_order x) : order_of x = 0 := by rwa [order_of, minimal_period, dif_neg]\n#align order_of_eq_zero order_of_eq_zero\n\n",
 "order_of_eq_prime_pow":
 "@[to_additive add_order_of_eq_prime_pow]\ntheorem order_of_eq_prime_pow (hnot : ¬x ^ p ^ n = 1) (hfin : x ^ p ^ (n + 1) = 1) : order_of x = p ^ (n + 1) := by\n  apply minimal_period_eq_prime_pow <;> rwa [is_periodic_pt_mul_iff_pow_eq_one]\n#align order_of_eq_prime_pow order_of_eq_prime_pow\n\n",
 "order_of_eq_prime":
 "@[to_additive add_order_of_eq_prime]\ntheorem order_of_eq_prime (hg : x ^ p = 1) (hg1 : x ≠ 1) : order_of x = p :=\n  minimal_period_eq_prime ((is_periodic_pt_mul_iff_pow_eq_one _).mpr hg) (by rwa [is_fixed_pt, mul_one])\n#align order_of_eq_prime order_of_eq_prime\n\n",
 "order_of_eq_order_of_iff":
 "@[to_additive add_order_of_eq_add_order_of_iff]\ntheorem order_of_eq_order_of_iff {H : Type _} [monoid H] {y : H} :\n    order_of x = order_of y ↔ ∀ n : ℕ, x ^ n = 1 ↔ y ^ n = 1 := by\n  simp_rw [← is_periodic_pt_mul_iff_pow_eq_one, ← minimal_period_eq_minimal_period_iff, order_of]\n#align order_of_eq_order_of_iff order_of_eq_order_of_iff\n\n",
 "order_of_eq_one_iff":
 "@[simp, to_additive add_monoid.order_of_eq_one_iff]\ntheorem order_of_eq_one_iff : order_of x = 1 ↔ x = 1 := by\n  rw [order_of, is_fixed_point_iff_minimal_period_eq_one, is_fixed_pt, mul_one]\n#align order_of_eq_one_iff order_of_eq_one_iff\n\n",
 "order_of_eq_of_pow_and_pow_div_prime":
 "/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`, then `x` has order `n` in `G`.\n-/\n@[to_additive add_order_of_eq_of_nsmul_and_div_prime_nsmul\n      \"If `n * x = 0`, but `n/p * x ≠ 0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"]\ntheorem order_of_eq_of_pow_and_pow_div_prime (hn : 0 < n) (hx : x ^ n = 1)\n    (hd : ∀ p : ℕ, p.prime → p ∣ n → x ^ (n / p) ≠ 1) : order_of x = n :=\n  by\n  -- Let `a` be `n/(order_of x)`, and show `a = 1`\n  cases' exists_eq_mul_right_of_dvd (order_of_dvd_of_pow_eq_one hx) with a ha\n  suffices a = 1 by simp [this, ha]\n  -- Assume `a` is not one...\n  by_contra\n  have a_min_fac_dvd_p_sub_one : a.min_fac ∣ n :=\n    by\n    obtain ⟨b, hb⟩ : ∃ b : ℕ, a = b * a.min_fac := exists_eq_mul_left_of_dvd a.min_fac_dvd\n    rw [hb, ← mul_assoc] at ha\n    exact Dvd.intro_left (order_of x * b) ha.symm\n  -- Use the minimum prime factor of `a` as `p`.\n  refine' hd a.min_fac (Nat.minFac_prime h) a_min_fac_dvd_p_sub_one _\n  rw [← order_of_dvd_iff_pow_eq_one, Nat.dvd_div_iff a_min_fac_dvd_p_sub_one, ha, mul_comm,\n    Nat.mul_dvd_mul_iff_left (order_of_pos' _)]\n  · exact Nat.minFac_dvd a\n  · rw [is_of_fin_order_iff_pow_eq_one]\n    exact Exists.intro n (id ⟨hn, hx⟩)\n#align order_of_eq_of_pow_and_pow_div_prime order_of_eq_of_pow_and_pow_div_prime\n\n",
 "order_of_eq_iff":
 "@[to_additive add_order_of_eq_iff]\ntheorem order_of_eq_iff {n} (h : 0 < n) : order_of x = n ↔ x ^ n = 1 ∧ ∀ m, m < n → 0 < m → x ^ m ≠ 1 :=\n  by\n  simp_rw [ne, ← is_periodic_pt_mul_iff_pow_eq_one, order_of, minimal_period]\n  split_ifs with h1\n  · rw [find_eq_iff, exists_prop_of_true h]\n    push_neg\n    rfl\n  · rw [iff_false_left h.ne]\n    rintro ⟨h', -⟩\n    exact h1 ⟨n, h, h'⟩\n#align order_of_eq_iff order_of_eq_iff\n\n",
 "order_of_dvd_of_pow_eq_one":
 "@[to_additive add_order_of_dvd_of_nsmul_eq_zero]\ntheorem order_of_dvd_of_pow_eq_one (h : x ^ n = 1) : order_of x ∣ n :=\n  is_periodic_pt.minimal_period_dvd ((is_periodic_pt_mul_iff_pow_eq_one _).mpr h)\n#align order_of_dvd_of_pow_eq_one order_of_dvd_of_pow_eq_one\n\n",
 "order_of_dvd_of_mem_zpowers":
 "@[to_additive add_order_of_dvd_of_mem_zmultiples]\ntheorem order_of_dvd_of_mem_zpowers (h : y ∈ subgroup.zpowers x) : order_of y ∣ order_of x :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp h\n  rw [order_of_dvd_iff_pow_eq_one]\n  exact zpow_pow_order_of\n#align order_of_dvd_of_mem_zpowers order_of_dvd_of_mem_zpowers\n\n",
 "order_of_dvd_nat_card":
 "@[to_additive add_order_of_dvd_nat_card]\ntheorem order_of_dvd_nat_card {G : Type _} [group G] {x : G} : order_of x ∣ nat.card G :=\n  by\n  cases' fintype_or_infinite G with h h\n  · simp only [nat.card_eq_fintype_card, order_of_dvd_card_univ]\n  · simp only [card_eq_zero_of_infinite, dvd_zero]\n#align order_of_dvd_nat_card order_of_dvd_nat_card\n\n",
 "order_of_dvd_lcm_mul":
 "@[to_additive]\ntheorem order_of_dvd_lcm_mul : order_of y ∣ nat.lcm (order_of x) (order_of (x * y)) :=\n  by\n  by_cases h0 : order_of x = 0\n  · rw [h0, lcm_zero_left]\n    apply dvd_zero\n  conv_lhs =>\n    rw [← one_mul y, ← pow_order_of_eq_one x, ← succ_pred_eq_of_pos (nat.pos_of_ne_zero h0), pow_succ', mul_assoc]\n  exact\n    (((Commute.refl x).mul_right h).pow_left _).order_of_mul_dvd_lcm.trans\n      (lcm_dvd_iff.2 ⟨trans (order_of_pow_dvd _) (dvd_lcm_left _ _), dvd_lcm_right _ _⟩)\n#align order_of_dvd_lcm_mul order_of_dvd_lcm_mul\n\n",
 "order_of_dvd_iff_zpow_eq_one":
 "@[to_additive add_order_of_dvd_iff_zsmul_eq_zero]\ntheorem order_of_dvd_iff_zpow_eq_one : (order_of x : ℤ) ∣ i ↔ x ^ i = 1 :=\n  by\n  rcases Int.eq_nat_or_neg i with ⟨i, rfl | rfl⟩\n  · rw [Int.coe_nat_dvd, order_of_dvd_iff_pow_eq_one, zpow_ofNat]\n  · rw [dvd_neg, Int.coe_nat_dvd, zpow_neg, inv_eq_one, zpow_ofNat, order_of_dvd_iff_pow_eq_one]\n#align order_of_dvd_iff_zpow_eq_one order_of_dvd_iff_zpow_eq_one\n\n",
 "order_of_dvd_iff_pow_eq_one":
 "@[to_additive add_order_of_dvd_iff_nsmul_eq_zero]\ntheorem order_of_dvd_iff_pow_eq_one {n : ℕ} : order_of x ∣ n ↔ x ^ n = 1 :=\n  ⟨fun h => by rw [pow_eq_mod_order_of, nat.mod_eq_zero_of_dvd h, pow_zero], order_of_dvd_of_pow_eq_one⟩\n#align order_of_dvd_iff_pow_eq_one order_of_dvd_iff_pow_eq_one\n\n",
 "order_of_dvd_card_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[to_additive add_order_of_dvd_card_univ]\ntheorem order_of_dvd_card_univ : order_of x ∣ fintype.card G := by\n  classical\n    have ft_prod : fintype («expr ⧸ » G (zpowers x) × zpowers x) :=\n      fintype.of_equiv G group_equiv_quotient_times_subgroup\n    have ft_s : fintype (zpowers x) := @fintype.prod_right _ _ _ ft_prod _\n    have ft_cosets : fintype («expr ⧸ » G (zpowers x)) := @fintype.prod_left _ _ _ ft_prod ⟨⟨1, (zpowers x).one_mem⟩⟩\n    have eq₁ : fintype.card G = @fintype.card _ ft_cosets * @fintype.card _ ft_s :=\n      calc\n        fintype.card G = @fintype.card _ ft_prod :=\n          @fintype.card_congr _ _ _ ft_prod group_equiv_quotient_times_subgroup\n        _ = @fintype.card _ (@prod.fintype _ _ ft_cosets ft_s) := congr_arg (@fintype.card _) <| subsingleton.elim _ _\n        _ = @fintype.card _ ft_cosets * @fintype.card _ ft_s := @fintype.card_prod _ _ ft_cosets ft_s\n        \n    have eq₂ : order_of x = @fintype.card _ ft_s :=\n      calc\n        order_of x = _ := order_eq_card_zpowers\n        _ = _ := congr_arg (@fintype.card _) <| subsingleton.elim _ _\n        \n    exact Dvd.intro (@fintype.card («expr ⧸ » G (subgroup.zpowers x)) ft_cosets) (by rw [eq₁, eq₂, mul_comm])\n#align order_of_dvd_card_univ order_of_dvd_card_univ\n\n",
 "order_of_abs_ne_one":
 "theorem order_of_abs_ne_one (h : |x| ≠ 1) : order_of x = 0 :=\n  by\n  rw [order_of_eq_zero_iff']\n  intro n hn hx\n  replace hx : |x| ^ n = 1 := by simpa only [abs_one, abs_pow] using congr_arg abs hx\n  cases' h.lt_or_lt with h h\n  · exact ((pow_lt_one (abs_nonneg x) h hn.ne').ne hx).elim\n  · exact ((one_lt_pow h hn.ne').ne' hx).elim\n#align order_of_abs_ne_one order_of_abs_ne_one\n\n",
 "order_eq_card_zpowers":
 "/-- See also `order_eq_card_zpowers'`. -/\n@[to_additive add_order_eq_card_zmultiples \"See also `add_order_eq_card_zmultiples'`.\"]\ntheorem order_eq_card_zpowers : order_of x = fintype.card (zpowers x) :=\n  (fintype.card_fin (order_of x)).symm.trans (fintype.card_eq.2 ⟨fin_equiv_zpowers x⟩)\n#align order_eq_card_zpowers order_eq_card_zpowers\n\n",
 "order_eq_card_powers":
 "@[to_additive add_order_of_eq_card_multiples]\ntheorem order_eq_card_powers [fintype G] : order_of x = fintype.card (submonoid.powers x : set G) :=\n  (fintype.card_fin (order_of x)).symm.trans (fintype.card_eq.2 ⟨fin_equiv_powers x⟩)\n#align order_eq_card_powers order_eq_card_powers\n\n",
 "of_mem_zpowers":
 "@[to_additive is_of_fin_add_order.of_mem_zmultiples]\ntheorem is_of_fin_order.of_mem_zpowers (h : is_of_fin_order x) (h' : y ∈ subgroup.zpowers x) : is_of_fin_order y :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp h'\n  exact h.zpow\n#align is_of_fin_order.of_mem_zpowers is_of_fin_order.of_mem_zpowers\n\n",
 "not_is_of_fin_order_of_injective_pow":
 "/-- See also `injective_pow_iff_not_is_of_fin_order`. -/\n@[to_additive not_is_of_fin_add_order_of_injective_nsmul \"See also\\n`injective_nsmul_iff_not_is_of_fin_add_order`.\"]\ntheorem not_is_of_fin_order_of_injective_pow {x : G} (h : injective fun n : ℕ => x ^ n) : ¬is_of_fin_order x :=\n  by\n  simp_rw [is_of_fin_order_iff_pow_eq_one, not_exists, not_and]\n  intro n hn_pos hnx\n  rw [← pow_zero x] at hnx\n  rw [h hnx] at hn_pos\n  exact irrefl 0 hn_pos\n#align not_is_of_fin_order_of_injective_pow not_is_of_fin_order_of_injective_pow\n\n",
 "mul":
 "/-- Elements of finite order are closed under multiplication. -/\n@[to_additive \"Elements of finite additive order are closed under addition.\"]\ntheorem is_of_fin_order.mul (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n  (Commute.all x y).is_of_fin_order_mul hx hy\n#align is_of_fin_order.mul is_of_fin_order.mul\n\n",
 "mem_zpowers_iff_mem_range_order_of":
 "@[to_additive mem_zmultiples_iff_mem_range_add_order_of]\ntheorem mem_zpowers_iff_mem_range_order_of [Finite G] [decidable_eq G] :\n    y ∈ subgroup.zpowers x ↔ y ∈ (Finset.range (order_of x)).image ((· ^ ·) x : ℕ → G) := by\n  rw [← mem_powers_iff_mem_zpowers, mem_powers_iff_mem_range_order_of]\n#align mem_zpowers_iff_mem_range_order_of mem_zpowers_iff_mem_range_order_of\n\n",
 "mem_powers_iff_mem_zpowers":
 "@[to_additive mem_multiples_iff_mem_zmultiples]\ntheorem mem_powers_iff_mem_zpowers [Finite G] : y ∈ submonoid.powers x ↔ y ∈ zpowers x :=\n  ⟨fun ⟨n, hn⟩ => ⟨n, by simp_all⟩, fun ⟨i, hi⟩ =>\n    ⟨(i % order_of x).nat_abs, by\n      rwa [← zpow_ofNat, Int.natAbs_of_nonneg (Int.emod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (order_of_pos x))), ←\n        zpow_eq_mod_order_of]⟩⟩\n#align mem_powers_iff_mem_zpowers mem_powers_iff_mem_zpowers\n\n",
 "mem_powers_iff_mem_range_order_of'":
 "@[to_additive mem_multiples_iff_mem_range_add_order_of']\ntheorem mem_powers_iff_mem_range_order_of' [decidable_eq G] (hx : 0 < order_of x) :\n    y ∈ submonoid.powers x ↔ y ∈ (Finset.range (order_of x)).image ((· ^ ·) x : ℕ → G) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' hx fun i => pow_eq_mod_order_of.symm\n#align mem_powers_iff_mem_range_order_of' mem_powers_iff_mem_range_order_of'\n\n",
 "mem_powers_iff_mem_range_order_of":
 "@[to_additive mem_multiples_iff_mem_range_add_order_of]\ntheorem mem_powers_iff_mem_range_order_of [Finite G] [decidable_eq G] :\n    y ∈ submonoid.powers x ↔ y ∈ (Finset.range (order_of x)).image ((· ^ ·) x : ℕ → G) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' (order_of_pos x) fun i => pow_eq_mod_order_of.symm\n#align mem_powers_iff_mem_range_order_of mem_powers_iff_mem_range_order_of\n\n",
 "is_periodic_pt_mul_iff_pow_eq_one":
 "/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Julian Kuelshammer\n-/\n@[to_additive]\ntheorem is_periodic_pt_mul_iff_pow_eq_one (x : G) : is_periodic_pt ((· * ·) x) n 1 ↔ x ^ n = 1 := by\n  rw [is_periodic_pt, is_fixed_pt, mul_left_iterate, mul_one]\n#align is_periodic_pt_mul_iff_pow_eq_one is_periodic_pt_mul_iff_pow_eq_one\n\n",
 "is_of_fin_order_one":
 "/-- 1 is of finite order in any monoid. -/\n@[to_additive \"0 is of finite order in any additive monoid.\"]\ntheorem is_of_fin_order_one : is_of_fin_order (1 : G) :=\n  (is_of_fin_order_iff_pow_eq_one 1).mpr ⟨1, _root_.one_pos, one_pow 1⟩\n#align is_of_fin_order_one is_of_fin_order_one\n\n",
 "is_of_fin_order_of_add_iff":
 "theorem is_of_fin_order_of_add_iff : is_of_fin_order (Multiplicative.ofAdd a) ↔ is_of_fin_add_order a :=\n  iff.rfl\n#align is_of_fin_order_of_add_iff is_of_fin_order_of_add_iff\n\n",
 "is_of_fin_order_mul":
 "/-- Commuting elements of finite order are closed under multiplication. -/\n@[to_additive \"Commuting elements of finite additive order are closed under addition.\"]\ntheorem is_of_fin_order_mul (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n  order_of_pos_iff.mp <|\n    pos_of_dvd_of_pos h.order_of_mul_dvd_mul_order_of <| mul_pos (order_of_pos' hx) (order_of_pos' hy)\n#align is_of_fin_order_mul is_of_fin_order_mul\n\n",
 "is_of_fin_order_inv_iff":
 "/-- Inverses of elements of finite order have finite order. -/\n@[simp, to_additive \"Inverses of elements of finite additive order have finite additive order.\"]\ntheorem is_of_fin_order_inv_iff {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x :=\n  ⟨fun h => inv_inv x ▸ h.inv, is_of_fin_order.inv⟩\n#align is_of_fin_order_inv_iff is_of_fin_order_inv_iff\n\n",
 "is_of_fin_order_iff_pow_eq_one":
 "@[to_additive is_of_fin_add_order_iff_nsmul_eq_zero]\ntheorem is_of_fin_order_iff_pow_eq_one (x : G) : is_of_fin_order x ↔ ∃ n, 0 < n ∧ x ^ n = 1 :=\n  by\n  convert iff.rfl\n  simp [is_periodic_pt_mul_iff_pow_eq_one]\n#align is_of_fin_order_iff_pow_eq_one is_of_fin_order_iff_pow_eq_one\n\n",
 "is_of_fin_order_iff_coe":
 "/-- Elements of finite order are of finite order in submonoids.-/\n@[to_additive is_of_fin_add_order_iff_coe \"Elements of finite order are of finite order in\\nsubmonoids.\"]\ntheorem is_of_fin_order_iff_coe (H : Submonoid G) (x : H) : is_of_fin_order x ↔ is_of_fin_order (x : G) :=\n  by\n  rw [is_of_fin_order_iff_pow_eq_one, is_of_fin_order_iff_pow_eq_one]\n  norm_cast\n#align is_of_fin_order_iff_coe is_of_fin_order_iff_coe\n\n",
 "is_of_fin_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/-- The image of an element of finite order has finite order. -/\n@[to_additive add_monoid_hom.is_of_fin_order\n      \"The image of an element of finite additive order has finite additive order.\"]\ntheorem monoid_hom.is_of_fin_order {H : Type v} [monoid H] (f : «expr →* » G H) {x : G} (h : is_of_fin_order x) :\n    is_of_fin_order <| f x :=\n  (is_of_fin_order_iff_pow_eq_one _).mpr <|\n    by\n    rcases(is_of_fin_order_iff_pow_eq_one _).mp h with ⟨n, npos, hn⟩\n    exact ⟨n, npos, by rw [← f.map_pow, hn, f.map_one]⟩\n#align monoid_hom.is_of_fin_order monoid_hom.is_of_fin_order\n\n",
 "is_of_fin_add_order_of_mul_iff":
 "theorem is_of_fin_add_order_of_mul_iff : is_of_fin_add_order (Additive.ofMul x) ↔ is_of_fin_order x :=\n  iff.rfl\n#align is_of_fin_add_order_of_mul_iff is_of_fin_add_order_of_mul_iff\n\n",
 "inv":
 "/-- Inverses of elements of finite order have finite order. -/\n@[to_additive \"Inverses of elements of finite additive order have finite additive order.\"]\ntheorem is_of_fin_order.inv {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹ :=\n  (is_of_fin_order_iff_pow_eq_one _).mpr <|\n    by\n    rcases(is_of_fin_order_iff_pow_eq_one x).mp hx with ⟨n, npos, hn⟩\n    refine' ⟨n, npos, by simp_rw [inv_pow, hn, inv_one]⟩\n#align is_of_fin_order.inv is_of_fin_order.inv\n\n",
 "injective_pow_iff_not_is_of_fin_order":
 "@[simp, to_additive injective_nsmul_iff_not_is_of_fin_add_order]\ntheorem injective_pow_iff_not_is_of_fin_order {x : G} : (injective fun n : ℕ => x ^ n) ↔ ¬is_of_fin_order x :=\n  by\n  refine' ⟨fun h => not_is_of_fin_order_of_injective_pow h, fun h n m hnm => _⟩\n  rwa [pow_eq_pow_iff_modeq, order_of_eq_zero_iff.mpr h, modeq_zero_iff] at hnm\n#align injective_pow_iff_not_is_of_fin_order injective_pow_iff_not_is_of_fin_order\n\n",
 "infinite_not_is_of_fin_order":
 "@[to_additive infinite_not_is_of_fin_add_order]\ntheorem infinite_not_is_of_fin_order {x : G} (h : ¬is_of_fin_order x) : { y : G | ¬is_of_fin_order y }.infinite :=\n  by\n  let s := { n | 0 < n }.image fun n : ℕ => x ^ n\n  have hs : s ⊆ { y : G | ¬is_of_fin_order y } :=\n    by\n    rintro - ⟨n, hn : 0 < n, rfl⟩ (contra : is_of_fin_order (x ^ n))\n    apply h\n    rw [is_of_fin_order_iff_pow_eq_one] at contra⊢\n    obtain ⟨m, hm, hm'⟩ := contra\n    exact ⟨n * m, mul_pos hn hm, by rwa [pow_mul]⟩\n  suffices s.infinite by exact this.mono hs\n  contrapose! h\n  have : ¬injective fun n : ℕ => x ^ n :=\n    by\n    have := set.not_inj_on_infinite_finite_image (set.Ioi_infinite 0) (set.not_infinite.mp h)\n    contrapose! this\n    exact Set.injOn_of_injective this _\n  rwa [injective_pow_iff_not_is_of_fin_order, not_not] at this\n#align infinite_not_is_of_fin_order infinite_not_is_of_fin_order\n\n",
 "inf_eq_bot_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[to_additive add_inf_eq_bot_of_coprime]\ntheorem inf_eq_bot_of_coprime {G : Type _} [group G] {H K : subgroup G} [fintype H] [fintype K]\n    (h : nat.coprime (fintype.card H) (fintype.card K)) : «expr ⊓ » H K = «expr⊥» :=\n  by\n  refine' («expr ⊓ » H K).eq_bot_iff_forall.mpr fun x hx => _\n  rw [← order_of_eq_one_iff, ← Nat.dvd_one, ← h.gcd_eq_one, nat.dvd_gcd_iff]\n  exact\n    ⟨(congr_arg (· ∣ fintype.card H) (order_of_subgroup ⟨x, hx.1⟩)).mpr order_of_dvd_card_univ,\n      (congr_arg (· ∣ fintype.card K) (order_of_subgroup ⟨x, hx.2⟩)).mpr order_of_dvd_card_univ⟩\n#align inf_eq_bot_of_coprime inf_eq_bot_of_coprime\n\n",
 "image_range_order_of":
 "/-- TODO: Generalise to `submonoid.powers`.-/\n@[to_additive image_range_add_order_of, nolint to_additive_doc]\ntheorem image_range_order_of [decidable_eq G] :\n    Finset.image (fun i => x ^ i) (Finset.range (order_of x)) = (zpowers x : set G).to_finset :=\n  by\n  ext x\n  rw [set.mem_to_finset, SetLike.mem_coe, mem_zpowers_iff_mem_range_order_of]\n#align image_range_order_of image_range_order_of\n\n",
 "fin_equiv_zpowers_symm_apply":
 "@[simp, to_additive fin_equiv_zmultiples_symm_apply]\ntheorem fin_equiv_zpowers_symm_apply [Finite G] (x : G) (n : ℕ) {hn : ∃ m : ℤ, x ^ m = x ^ n} :\n    (fin_equiv_zpowers x).symm ⟨x ^ n, hn⟩ = ⟨n % order_of x, nat.mod_lt _ (order_of_pos x)⟩ :=\n  by\n  rw [fin_equiv_zpowers, equiv.symm_trans_apply, equiv.set.of_eq_symm_apply]\n  exact fin_equiv_powers_symm_apply x n\n#align fin_equiv_zpowers_symm_apply fin_equiv_zpowers_symm_apply\n\n",
 "fin_equiv_zpowers_apply":
 "@[simp, to_additive fin_equiv_zmultiples_apply]\ntheorem fin_equiv_zpowers_apply [Finite G] {n : fin (order_of x)} :\n    fin_equiv_zpowers x n = ⟨x ^ (n : ℕ), n, zpow_ofNat x n⟩ :=\n  rfl\n#align fin_equiv_zpowers_apply fin_equiv_zpowers_apply\n\n",
 "fin_equiv_powers_symm_apply":
 "@[simp, to_additive fin_equiv_multiples_symm_apply]\ntheorem fin_equiv_powers_symm_apply [Finite G] (x : G) (n : ℕ) {hn : ∃ m : ℕ, x ^ m = x ^ n} :\n    (fin_equiv_powers x).symm ⟨x ^ n, hn⟩ = ⟨n % order_of x, nat.mod_lt _ (order_of_pos x)⟩ := by\n  rw [equiv.symm_apply_eq, fin_equiv_powers_apply, subtype.mk_eq_mk, pow_eq_mod_order_of, Fin.val_mk]\n#align fin_equiv_powers_symm_apply fin_equiv_powers_symm_apply\n\n",
 "fin_equiv_powers_apply":
 "@[simp, to_additive fin_equiv_multiples_apply]\ntheorem fin_equiv_powers_apply [Finite G] {x : G} {n : fin (order_of x)} : fin_equiv_powers x n = ⟨x ^ ↑n, n, rfl⟩ :=\n  rfl\n#align fin_equiv_powers_apply fin_equiv_powers_apply\n\n",
 "exists_zpow_eq_one":
 "@[to_additive]\ntheorem exists_zpow_eq_one [Finite G] (x : G) : ∃ (i : ℤ)(H : i ≠ 0), x ^ (i : ℤ) = 1 :=\n  by\n  rcases exists_pow_eq_one x with ⟨w, hw1, hw2⟩\n  refine' ⟨w, int.coe_nat_ne_zero.mpr (ne_of_gt hw1), _⟩\n  rw [zpow_ofNat]\n  exact (is_periodic_pt_mul_iff_pow_eq_one _).mp hw2\n#align exists_zpow_eq_one exists_zpow_eq_one\n\n",
 "exists_pow_eq_self_of_coprime":
 "@[to_additive]\ntheorem exists_pow_eq_self_of_coprime (h : n.coprime (order_of x)) : ∃ m : ℕ, (x ^ n) ^ m = x :=\n  by\n  by_cases h0 : order_of x = 0\n  · rw [h0, coprime_zero_right] at h\n    exact ⟨1, by rw [h, pow_one, pow_one]⟩\n  by_cases h1 : order_of x = 1\n  · exact ⟨0, by rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]⟩\n  obtain ⟨m, hm⟩ := exists_mul_mod_eq_one_of_coprime h (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, h1⟩)\n  exact ⟨m, by rw [← pow_mul, pow_eq_mod_order_of, hm, pow_one]⟩\n#align exists_pow_eq_self_of_coprime exists_pow_eq_self_of_coprime\n\n",
 "exists_pow_eq_one":
 "-- TODO: Of course everything also works for right_cancel_monoids.\n-- TODO: Use this to show that a finite left cancellative monoid is a group.\n@[to_additive]\ntheorem exists_pow_eq_one [Finite G] (x : G) : is_of_fin_order x :=\n  by\n  have : (Set.univ : set G).finite := set.univ.to_finite\n  contrapose! this\n  exact set.infinite.mono (Set.subset_univ _) (infinite_not_is_of_fin_order this)\n#align exists_pow_eq_one exists_pow_eq_one\n\n",
 "exists_order_of_eq_prime_pow_iff":
 "@[to_additive exists_add_order_of_eq_prime_pow_iff]\ntheorem exists_order_of_eq_prime_pow_iff : (∃ k : ℕ, order_of x = p ^ k) ↔ ∃ m : ℕ, x ^ (p : ℕ) ^ m = 1 :=\n  ⟨fun ⟨k, hk⟩ => ⟨k, by rw [← hk, pow_order_of_eq_one]⟩, fun ⟨_, hm⟩ =>\n    by\n    obtain ⟨k, _, hk⟩ := (Nat.dvd_prime_pow hp.elim).mp (order_of_dvd_of_pow_eq_one hm)\n    exact ⟨k, hk⟩⟩\n#align exists_order_of_eq_prime_pow_iff exists_order_of_eq_prime_pow_iff\n\n",
 "apply":
 "/-- If a direct product has finite order then so does each component. -/\n@[to_additive \"If a direct product has finite additive order then so does each component.\"]\ntheorem is_of_fin_order.apply {η : Type _} {Gs : η → Type _} [∀ i, monoid (Gs i)] {x : ∀ i, Gs i}\n    (h : is_of_fin_order x) : ∀ i, is_of_fin_order (x i) :=\n  by\n  rcases(is_of_fin_order_iff_pow_eq_one _).mp h with ⟨n, npos, hn⟩\n  exact fun _ => (is_of_fin_order_iff_pow_eq_one _).mpr ⟨n, npos, (congr_fun hn.symm _).symm⟩\n#align is_of_fin_order.apply is_of_fin_order.apply\n\n",
 "add_order_of_of_mul_eq_order_of":
 "@[simp]\ntheorem add_order_of_of_mul_eq_order_of (x : G) : add_order_of (Additive.ofMul x) = order_of x :=\n  rfl\n#align add_order_of_of_mul_eq_order_of add_order_of_of_mul_eq_order_of\n\n"}