{"zpowersEquivZpowers_apply":
 "#print zpowersEquivZpowers_apply /-\n@[simp, to_additive zmultiples_equiv_zmultiples_apply]\ntheorem zpowersEquivZpowers_apply [Finite G] (h : orderOf x = orderOf y) (n : ℕ) :\n    zpowersEquivZpowers h ⟨x ^ n, n, zpow_ofNat x n⟩ = ⟨y ^ n, n, zpow_ofNat y n⟩ :=\n  by\n  rw [zpowersEquivZpowers, Equiv.trans_apply, Equiv.trans_apply, finEquivZpowers_symm_apply, ← Equiv.eq_symm_apply,\n    finEquivZpowers_symm_apply]\n  simp [h]\n#align zpowers_equiv_zpowers_apply zpowersEquivZpowers_apply\n#align zmultiples_equiv_zmultiples_apply zmultiples_equiv_zmultiples_apply\n-/\n\n",
 "zpow_pow_orderOf":
 "#print zpow_pow_orderOf /-\n@[simp, to_additive zsmul_smul_addOrderOf]\ntheorem zpow_pow_orderOf : (x ^ i) ^ orderOf x = 1 :=\n  by\n  by_cases h : IsOfFinOrder x\n  · rw [← zpow_ofNat, ← zpow_mul, mul_comm, zpow_mul, zpow_ofNat, pow_orderOf_eq_one, one_zpow]\n  · rw [orderOf_eq_zero h, pow_zero]\n#align zpow_pow_order_of zpow_pow_orderOf\n#align zsmul_smul_order_of zsmul_smul_addOrderOf\n-/\n\n",
 "zpow_eq_mod_orderOf":
 "#print zpow_eq_mod_orderOf /-\n@[to_additive zsmul_eq_mod_addOrderOf]\ntheorem zpow_eq_mod_orderOf : x ^ i = x ^ (i % orderOf x) :=\n  calc\n    x ^ i = x ^ (i % orderOf x + orderOf x * (i / orderOf x)) := by rw [Int.emod_add_ediv]\n    _ = x ^ (i % orderOf x) := by simp [zpow_add, zpow_mul, pow_orderOf_eq_one]\n    \n#align zpow_eq_mod_order_of zpow_eq_mod_orderOf\n#align zsmul_eq_mod_add_order_of zsmul_eq_mod_addOrderOf\n-/\n\n",
 "zpow_eq_mod_card":
 "#print zpow_eq_mod_card /-\n@[to_additive]\ntheorem zpow_eq_mod_card (n : ℤ) : x ^ n = x ^ (n % Fintype.card G) := by\n  rw [zpow_eq_mod_orderOf, ← Int.emod_emod_of_dvd n (Int.coe_nat_dvd.2 orderOf_dvd_card_univ), ← zpow_eq_mod_orderOf]\n#align zpow_eq_mod_card zpow_eq_mod_card\n#align zsmul_eq_mod_card zsmul_eq_mod_card\n-/\n\n",
 "zpow":
 "#print IsOfFinOrder.zpow /-\n@[to_additive IsOfFinAddOrder.zsmul]\ntheorem IsOfFinOrder.zpow (h : IsOfFinOrder x) {i : ℤ} : IsOfFinOrder (x ^ i) :=\n  (isOfFinOrder_iff_pow_eq_one _).mpr ⟨orderOf x, orderOf_pos' h, zpow_pow_orderOf⟩\n#align is_of_fin_order.zpow IsOfFinOrder.zpow\n#align is_of_fin_add_order.zsmul IsOfFinAddOrder.zsmul\n-/\n\n",
 "vadd_eq_self_of_mem_zmultiples":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n#print vadd_eq_self_of_mem_zmultiples /-\ntheorem vadd_eq_self_of_mem_zmultiples {α G : Type _} [AddGroup G] [AddAction G α] {x y : G}\n    (hx : x ∈ AddSubgroup.zmultiples y) {a : α} (hs : «expr +ᵥ » y a = a) : «expr +ᵥ » x a = a :=\n  @smul_eq_self_of_mem_zpowers (Multiplicative G) _ _ _ α _ hx a hs\n#align vadd_eq_self_of_mem_zmultiples vadd_eq_self_of_mem_zmultiples\n-/\n\n",
 "sum_card_orderOf_eq_card_pow_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print sum_card_orderOf_eq_card_pow_eq_one /-\n@[to_additive sum_card_addOrderOf_eq_card_nsmul_eq_zero]\ntheorem sum_card_orderOf_eq_card_pow_eq_one [Fintype G] [DecidableEq G] (hn : n ≠ 0) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((Finset.range n.succ).filter (· ∣ n)) (Finset.univ.filter fun x : G => orderOf x = m).card =\n      (Finset.univ.filter fun x : G => x ^ n = 1).card :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((Finset.range n.succ).filter (· ∣ n)) (Finset.univ.filter fun x : G => orderOf x = m).card =\n        _ :=\n      (Finset.card_bunionᵢ\n          (by\n            intros\n            apply Finset.disjoint_filter.2\n            cc)).symm\n    _ = _ :=\n      congr_arg Finset.card\n        (Finset.ext\n          (by\n            intro x\n            suffices orderOf x ≤ n ∧ orderOf x ∣ n ↔ x ^ n = 1 by simpa [Nat.lt_succ_iff]\n            exact\n              ⟨fun h => by\n                let ⟨m, hm⟩ := h.2\n                rw [hm, pow_mul, pow_orderOf_eq_one, one_pow], fun h =>\n                ⟨orderOf_le_of_pow_eq_one hn.bot_lt h, orderOf_dvd_of_pow_eq_one h⟩⟩))\n    \n#align sum_card_order_of_eq_card_pow_eq_one sum_card_orderOf_eq_card_pow_eq_one\n#align sum_card_add_order_of_eq_card_nsmul_eq_zero sum_card_addOrderOf_eq_card_nsmul_eq_zero\n-/\n\n",
 "smul_eq_self_of_mem_zpowers":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_self_of_mem_zpowers /-\ntheorem smul_eq_self_of_mem_zpowers {α : Type _} [MulAction G α] (hx : x ∈ Subgroup.zpowers y) {a : α}\n    (hs : «expr • » y a = a) : «expr • » x a = a :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp hx\n  rw [← MulAction.toPerm_apply, ← MulAction.toPermHom_apply, MonoidHom.map_zpow _ y k, MulAction.toPermHom_apply]\n  exact Function.IsFixedPt.perm_zpow hs k\n#align smul_eq_self_of_mem_zpowers smul_eq_self_of_mem_zpowers\n-/\n\n",
 "powers_eq_zpowers":
 "#print powers_eq_zpowers /-\n@[to_additive multiples_eq_zmultiples]\ntheorem powers_eq_zpowers [Finite G] (x : G) : (Submonoid.powers x : Set G) = zpowers x :=\n  Set.ext fun x => mem_powers_iff_mem_zpowers\n#align powers_eq_zpowers powers_eq_zpowers\n#align multiples_eq_zmultiples multiples_eq_zmultiples\n-/\n\n",
 "powersEquivPowers_apply":
 "#print powersEquivPowers_apply /-\n@[simp, to_additive multiplesEquivMultiples_apply]\ntheorem powersEquivPowers_apply [Finite G] (h : orderOf x = orderOf y) (n : ℕ) :\n    powersEquivPowers h ⟨x ^ n, n, rfl⟩ = ⟨y ^ n, n, rfl⟩ :=\n  by\n  rw [powersEquivPowers, Equiv.trans_apply, Equiv.trans_apply, finEquivPowers_symm_apply, ← Equiv.eq_symm_apply,\n    finEquivPowers_symm_apply]\n  simp [h]\n#align powers_equiv_powers_apply powersEquivPowers_apply\n#align multiples_equiv_multiples_apply multiplesEquivMultiples_apply\n-/\n\n",
 "pow_orderOf_eq_one":
 "#print pow_orderOf_eq_one /-\n@[to_additive addOrderOf_nsmul_eq_zero]\ntheorem pow_orderOf_eq_one (x : G) : x ^ orderOf x = 1 :=\n  by\n  convert is_periodic_pt_minimal_period ((· * ·) x) _\n  rw [orderOf, mul_left_iterate, mul_one]\n#align pow_order_of_eq_one pow_orderOf_eq_one\n#align add_order_of_nsmul_eq_zero addOrderOf_nsmul_eq_zero\n-/\n\n",
 "pow_ne_one_of_lt_orderOf'":
 "#print pow_ne_one_of_lt_orderOf' /-\n@[to_additive nsmul_ne_zero_of_lt_addOrderOf']\ntheorem pow_ne_one_of_lt_orderOf' (n0 : n ≠ 0) (h : n < orderOf x) : x ^ n ≠ 1 := fun j =>\n  not_isPeriodicPt_of_pos_of_lt_minimalPeriod n0 h ((isPeriodicPt_mul_iff_pow_eq_one x).mpr j)\n#align pow_ne_one_of_lt_order_of' pow_ne_one_of_lt_orderOf'\n#align nsmul_ne_zero_of_lt_add_order_of' nsmul_ne_zero_of_lt_addOrderOf'\n-/\n\n",
 "pow_injective_of_lt_orderOf":
 "#print pow_injective_of_lt_orderOf /-\n@[to_additive nsmul_injective_of_lt_addOrderOf]\ntheorem pow_injective_of_lt_orderOf (hn : n < orderOf x) (hm : m < orderOf x) (eq : x ^ n = x ^ m) : n = m :=\n  eq_of_lt_minimalPeriod_of_iterate_eq hn hm (by simpa only [mul_left_iterate, mul_one] )\n#align pow_injective_of_lt_order_of pow_injective_of_lt_orderOf\n#align nsmul_injective_of_lt_add_order_of nsmul_injective_of_lt_addOrderOf\n-/\n\n",
 "pow_inj_mod":
 "#print pow_inj_mod /-\n@[to_additive]\ntheorem pow_inj_mod {n m : ℕ} : x ^ n = x ^ m ↔ n % orderOf x = m % orderOf x :=\n  by\n  cases' (orderOf x).zero_le.eq_or_lt with hx hx\n  · simp [pow_inj_iff_of_orderOf_eq_zero, hx.symm]\n  rw [pow_eq_mod_orderOf, @pow_eq_mod_orderOf _ _ _ m]\n  exact ⟨pow_injective_of_lt_orderOf _ (nat.mod_lt _ hx) (nat.mod_lt _ hx), fun h => congr_arg _ h⟩\n#align pow_inj_mod pow_inj_mod\n#align nsmul_inj_mod nsmul_inj_mod\n-/\n\n",
 "pow_inj_iff_of_orderOf_eq_zero":
 "#print pow_inj_iff_of_orderOf_eq_zero /-\n@[to_additive nsmul_inj_iff_of_addOrderOf_eq_zero]\ntheorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : ℕ} : x ^ n = x ^ m ↔ n = m :=\n  by\n  rw [orderOf_eq_zero_iff, isOfFinOrder_iff_pow_eq_one] at h\n  push_neg  at h\n  induction' n with n IH generalizing m\n  · cases m\n    · simp\n    · simpa [eq_comm] using h m.succ m.zero_lt_succ\n  · cases m\n    · simpa using h n.succ n.zero_lt_succ\n    · simp [pow_succ, IH]\n#align pow_inj_iff_of_order_of_eq_zero pow_inj_iff_of_orderOf_eq_zero\n#align nsmul_inj_iff_of_add_order_of_eq_zero nsmul_inj_iff_of_addOrderOf_eq_zero\n-/\n\n",
 "pow_index_mem":
 "#print Subgroup.pow_index_mem /-\n@[to_additive]\ntheorem Subgroup.pow_index_mem {G : Type _} [Group G] (H : Subgroup G) [Normal H] (g : G) : g ^ index H ∈ H := by\n  rw [← eq_one_iff, QuotientGroup.mk_pow H, index, pow_card_eq_one']\n#align subgroup.pow_index_mem Subgroup.pow_index_mem\n#align add_subgroup.nsmul_index_mem AddSubgroup.nsmul_index_mem\n-/\n\n",
 "pow_gcd_card_eq_one_iff":
 "#print pow_gcd_card_eq_one_iff /-\n/-- TODO: Generalise to `finite` + `cancel_monoid`. -/\n@[to_additive gcd_nsmul_card_eq_zero_iff \"TODO: Generalise to `finite` + `cancel_add_monoid`\"]\ntheorem pow_gcd_card_eq_one_iff : x ^ n = 1 ↔ x ^ gcd n (Fintype.card G) = 1 :=\n  ⟨fun h => pow_gcd_eq_one _ h <| pow_card_eq_one, fun h =>\n    by\n    let ⟨m, hm⟩ := gcd_dvd_left n (Fintype.card G)\n    rw [hm, pow_mul, h, one_pow]⟩\n#align pow_gcd_card_eq_one_iff pow_gcd_card_eq_one_iff\n#align gcd_nsmul_card_eq_zero_iff gcd_nsmul_card_eq_zero_iff\n-/\n\n",
 "pow_eq_pow_iff_modEq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print pow_eq_pow_iff_modEq /-\n@[to_additive]\ntheorem pow_eq_pow_iff_modEq : x ^ n = x ^ m ↔ «expr ≡ [MOD ]» n m (orderOf x) :=\n  by\n  wlog hmn : m ≤ n generalizing m n\n  · rw [eq_comm, modeq.comm, this (le_of_not_le hmn)]\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hmn\n  rw [← mul_one (x ^ m), pow_add, mul_left_cancel_iff, pow_eq_one_iff_modEq]\n  exact ⟨fun h => Nat.ModEq.add_left _ h, fun h => Nat.ModEq.add_left_cancel' _ h⟩\n#align pow_eq_pow_iff_modeq pow_eq_pow_iff_modEq\n#align nsmul_eq_nsmul_iff_modeq nsmul_eq_nsmul_iff_modEq\n-/\n\n",
 "pow_eq_one_iff_modEq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print pow_eq_one_iff_modEq /-\n@[to_additive]\ntheorem pow_eq_one_iff_modEq : x ^ n = 1 ↔ «expr ≡ [MOD ]» n 0 (orderOf x) := by\n  rw [modeq_zero_iff_dvd, orderOf_dvd_iff_pow_eq_one]\n#align pow_eq_one_iff_modeq pow_eq_one_iff_modEq\n#align nsmul_eq_zero_iff_modeq nsmul_eq_zero_iff_modEq\n-/\n\n",
 "pow_eq_mod_orderOf":
 "#print pow_eq_mod_orderOf /-\n@[to_additive nsmul_eq_mod_addOrderOf]\ntheorem pow_eq_mod_orderOf {n : ℕ} : x ^ n = x ^ (n % orderOf x) :=\n  calc\n    x ^ n = x ^ (n % orderOf x + orderOf x * (n / orderOf x)) := by rw [nat.mod_add_div]\n    _ = x ^ (n % orderOf x) := by simp [pow_add, pow_mul, pow_orderOf_eq_one]\n    \n#align pow_eq_mod_order_of pow_eq_mod_orderOf\n#align nsmul_eq_mod_add_order_of nsmul_eq_mod_addOrderOf\n-/\n\n",
 "pow_eq_mod_card":
 "#print pow_eq_mod_card /-\n@[to_additive]\ntheorem pow_eq_mod_card (n : ℕ) : x ^ n = x ^ (n % Fintype.card G) := by\n  rw [pow_eq_mod_orderOf, ← Nat.mod_mod_of_dvd n orderOf_dvd_card_univ, ← pow_eq_mod_orderOf]\n#align pow_eq_mod_card pow_eq_mod_card\n#align nsmul_eq_mod_card nsmul_eq_mod_card\n-/\n\n",
 "pow_card_eq_one'":
 "#print pow_card_eq_one' /-\n@[simp, to_additive card_nsmul_eq_zero']\ntheorem pow_card_eq_one' {G : Type _} [Group G] {x : G} : x ^ Nat.card G = 1 :=\n  orderOf_dvd_iff_pow_eq_one.mp orderOf_dvd_nat_card\n#align pow_card_eq_one' pow_card_eq_one'\n#align card_nsmul_eq_zero' card_nsmul_eq_zero'\n-/\n\n",
 "pow_card_eq_one":
 "#print pow_card_eq_one /-\n@[simp, to_additive card_nsmul_eq_zero]\ntheorem pow_card_eq_one : x ^ Fintype.card G = 1 := by rw [← Nat.card_eq_fintype_card, pow_card_eq_one']\n#align pow_card_eq_one pow_card_eq_one\n#align card_nsmul_eq_zero card_nsmul_eq_zero\n-/\n\n",
 "powCoprime_one":
 "#print powCoprime_one /-\n@[simp, to_additive]\ntheorem powCoprime_one {G : Type _} [Group G] (h : (Nat.card G).coprime n) : powCoprime h 1 = 1 :=\n  one_pow n\n#align pow_coprime_one powCoprime_one\n#align nsmul_coprime_zero nsmulCoprime_zero\n-/\n\n",
 "powCoprime_inv":
 "#print powCoprime_inv /-\n@[simp, to_additive]\ntheorem powCoprime_inv {G : Type _} [Group G] (h : (Nat.card G).coprime n) {g : G} :\n    powCoprime h g⁻¹ = (powCoprime h g)⁻¹ :=\n  inv_pow g n\n#align pow_coprime_inv powCoprime_inv\n#align nsmul_coprime_neg nsmulCoprime_neg\n-/\n\n",
 "order_of_mul_eq_right_of_forall_prime_mul_dvd":
 "/-- If each prime factor of `order_of x` has higher multiplicity in `order_of y`, and `x` commutes\n  with `y`, then `x * y` has the same order as `y`. -/\n@[to_additive add_order_of_add_eq_right_of_forall_prime_mul_dvd\n      \"If each prime factor of\\n  `add_order_of x` has higher multiplicity in `add_order_of y`, and `x` commutes with `y`,\\n  then `x + y` has the same order as `y`.\"]\ntheorem order_of_mul_eq_right_of_forall_prime_mul_dvd (hy : IsOfFinOrder y)\n    (hdvd : ∀ p : ℕ, p.prime → p ∣ orderOf x → p * orderOf x ∣ orderOf y) : orderOf (x * y) = orderOf y :=\n  by\n  have hoy := orderOf_pos' hy\n  have hxy := dvd_of_forall_prime_mul_dvd hdvd\n  apply orderOf_eq_of_pow_and_pow_div_prime hoy <;> simp only [ne, ← orderOf_dvd_iff_pow_eq_one]\n  · exact trans h.order_of_mul_dvd_lcm (lcm_dvd hxy dvd_rfl)\n  refine' fun p hp hpy hd => hp.ne_one _\n  rw [← Nat.dvd_one, ← mul_dvd_mul_iff_right hoy.ne', one_mul, ← dvd_div_iff hpy]\n  refine' trans (order_of_dvd_lcm_mul h) (lcm_dvd ((dvd_div_iff hpy).2 _) hd)\n  by_cases p ∣ orderOf x\n  exacts[hdvd p hp h, (hp.coprime_iff_not_dvd.2 h).mul_dvd_of_dvd_of_dvd hpy hxy]\n#align order_of_mul_eq_right_of_forall_prime_mul_dvd order_of_mul_eq_right_of_forall_prime_mul_dvd\n\n",
 "order_of_mul_eq_mul_order_of_of_coprime":
 "@[to_additive add_order_of_add_eq_mul_add_order_of_of_coprime]\ntheorem order_of_mul_eq_mul_order_of_of_coprime (hco : (orderOf x).coprime (orderOf y)) :\n    orderOf (x * y) = orderOf x * orderOf y :=\n  by\n  convert h.function_commute_mul_left.minimal_period_of_comp_eq_mul_of_coprime hco\n  simp only [orderOf, comp_mul_left]\n#align order_of_mul_eq_mul_order_of_of_coprime order_of_mul_eq_mul_order_of_of_coprime\n\n",
 "order_of_mul_dvd_mul_order_of":
 "@[to_additive add_order_of_add_dvd_mul_add_order_of]\ntheorem order_of_mul_dvd_mul_order_of : orderOf (x * y) ∣ orderOf x * orderOf y :=\n  dvd_trans h.order_of_mul_dvd_lcm (lcm_dvd_mul _ _)\n#align order_of_mul_dvd_mul_order_of order_of_mul_dvd_mul_order_of\n\n",
 "order_of_mul_dvd_lcm":
 "@[to_additive]\ntheorem order_of_mul_dvd_lcm : orderOf (x * y) ∣ Nat.lcm (orderOf x) (orderOf y) :=\n  by\n  convert Function.Commute.minimalPeriod_of_comp_dvd_lcm h.function_commute_mul_left\n  rw [orderOf, comp_mul_left]\n#align order_of_mul_dvd_lcm order_of_mul_dvd_lcm\n\n",
 "order_of_dvd_lcm_mul":
 "@[to_additive]\ntheorem order_of_dvd_lcm_mul : orderOf y ∣ Nat.lcm (orderOf x) (orderOf (x * y)) :=\n  by\n  by_cases h0 : orderOf x = 0\n  · rw [h0, lcm_zero_left]\n    apply dvd_zero\n  conv_lhs =>\n    rw [← one_mul y, ← pow_orderOf_eq_one x, ← succ_pred_eq_of_pos (nat.pos_of_ne_zero h0), pow_succ', mul_assoc]\n  exact\n    (((Commute.refl x).mul_right h).pow_left _).order_of_mul_dvd_lcm.trans\n      (lcm_dvd_iff.2 ⟨trans (orderOf_pow_dvd _) (dvd_lcm_left _ _), dvd_lcm_right _ _⟩)\n#align order_of_dvd_lcm_mul order_of_dvd_lcm_mul\n\n",
 "orderOf_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n#print orderOf_units /-\n@[to_additive]\ntheorem orderOf_units {y : «expr ˣ» G} : orderOf (y : G) = orderOf y :=\n  orderOf_injective (Units.coeHom G) Units.ext y\n#align order_of_units orderOf_units\n#align order_of_add_units addOrderOf_addUnits\n-/\n\n",
 "orderOf_submonoid":
 "#print orderOf_submonoid /-\n@[simp, norm_cast, to_additive]\ntheorem orderOf_submonoid {H : Submonoid G} (y : H) : orderOf (y : G) = orderOf y :=\n  orderOf_injective H.subtype Subtype.coe_injective y\n#align order_of_submonoid orderOf_submonoid\n#align order_of_add_submonoid addOrderOf_addSubmonoid\n-/\n\n",
 "orderOf_subgroup":
 "#print orderOf_subgroup /-\n@[simp, norm_cast, to_additive]\ntheorem orderOf_subgroup {H : Subgroup G} (y : H) : orderOf (y : G) = orderOf y :=\n  orderOf_injective H.subtype Subtype.coe_injective y\n#align order_of_subgroup orderOf_subgroup\n#align order_of_add_subgroup addOrderOf_addSubgroup\n-/\n\n",
 "orderOf_pow_dvd":
 "#print orderOf_pow_dvd /-\n@[to_additive addOrderOf_smul_dvd]\ntheorem orderOf_pow_dvd (n : ℕ) : orderOf (x ^ n) ∣ orderOf x := by\n  rw [orderOf_dvd_iff_pow_eq_one, pow_right_comm, pow_orderOf_eq_one, one_pow]\n#align order_of_pow_dvd orderOf_pow_dvd\n#align add_order_of_smul_dvd addOrderOf_smul_dvd\n-/\n\n",
 "orderOf_pow_coprime":
 "#print orderOf_pow_coprime /-\n@[to_additive addOrderOf_nsmul_coprime]\ntheorem orderOf_pow_coprime (h : (orderOf y).coprime m) : orderOf (y ^ m) = orderOf y :=\n  by\n  by_cases hg : orderOf y = 0\n  · rw [m.coprime_zero_left.mp (hg ▸ h), pow_one]\n  · rw [orderOf_pow'' y m (hg.imp_symm orderOf_eq_zero), h.gcd_eq_one, nat.div_one]\n#align order_of_pow_coprime orderOf_pow_coprime\n#align add_order_of_nsmul_coprime addOrderOf_nsmul_coprime\n-/\n\n",
 "orderOf_pow''":
 "#print orderOf_pow'' /-\n@[to_additive addOrderOf_nsmul'']\ntheorem orderOf_pow'' (h : IsOfFinOrder x) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n :=\n  by\n  convert minimal_period_iterate_eq_div_gcd' h\n  simp only [orderOf, mul_left_iterate]\n#align order_of_pow'' orderOf_pow''\n#align add_order_of_nsmul'' addOrderOf_nsmul''\n-/\n\n",
 "orderOf_pow'":
 "#print orderOf_pow' /-\n@[to_additive addOrderOf_nsmul']\ntheorem orderOf_pow' (h : n ≠ 0) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n :=\n  by\n  convert minimal_period_iterate_eq_div_gcd h\n  simp only [orderOf, mul_left_iterate]\n#align order_of_pow' orderOf_pow'\n#align add_order_of_nsmul' addOrderOf_nsmul'\n-/\n\n",
 "orderOf_pow":
 "#print orderOf_pow /-\n/-- This is the same as `order_of_pow'` and `order_of_pow''` but with one assumption less which is\nautomatic in the case of a finite cancellative monoid.-/\n@[to_additive addOrderOf_nsmul\n      \"This is the same as `add_order_of_nsmul'` and `add_order_of_nsmul` but with one assumption less\\nwhich is automatic in the case of a finite cancellative additive monoid.\"]\ntheorem orderOf_pow [Finite G] (x : G) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n :=\n  orderOf_pow'' _ _ (exists_pow_eq_one _)\n#align order_of_pow orderOf_pow\n#align add_order_of_nsmul addOrderOf_nsmul\n-/\n\n",
 "orderOf_pos_iff":
 "#print orderOf_pos_iff /-\n/-- A group element has finite order iff its order is positive. -/\n@[to_additive addOrderOf_pos_iff \"A group element has finite additive order iff its order is positive.\"]\ntheorem orderOf_pos_iff : 0 < orderOf x ↔ IsOfFinOrder x := by\n  rwa [iff_not_comm.mp orderOf_eq_zero_iff, pos_iff_ne_zero]\n#align order_of_pos_iff orderOf_pos_iff\n#align add_order_of_pos_iff addOrderOf_pos_iff\n-/\n\n",
 "orderOf_pos'":
 "#print orderOf_pos' /-\n@[to_additive addOrderOf_pos']\ntheorem orderOf_pos' (h : IsOfFinOrder x) : 0 < orderOf x :=\n  minimalPeriod_pos_of_mem_periodicPts h\n#align order_of_pos' orderOf_pos'\n#align add_order_of_pos' addOrderOf_pos'\n-/\n\n",
 "orderOf_pos":
 "#print orderOf_pos /-\n/-- This is the same as `order_of_pos' but with one fewer explicit assumption since this is\n  automatic in case of a finite cancellative monoid.-/\n@[to_additive addOrderOf_pos\n      \"This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is\\n  automatic in case of a finite cancellative additive monoid.\"]\ntheorem orderOf_pos [Finite G] (x : G) : 0 < orderOf x :=\n  orderOf_pos' (exists_pow_eq_one x)\n#align order_of_pos orderOf_pos\n#align add_order_of_pos addOrderOf_pos\n-/\n\n",
 "orderOf_one":
 "#print orderOf_one /-\n@[simp, to_additive]\ntheorem orderOf_one : orderOf (1 : G) = 1 := by rw [orderOf, one_mul_eq_id, minimal_period_id]\n#align order_of_one orderOf_one\n#align order_of_zero addOrderOf_zero\n-/\n\n",
 "orderOf_ofAdd_eq_addOrderOf":
 "#print orderOf_ofAdd_eq_addOrderOf /-\n@[simp]\ntheorem orderOf_ofAdd_eq_addOrderOf (a : A) : orderOf (Multiplicative.ofAdd a) = addOrderOf a :=\n  rfl\n#align order_of_of_add_eq_add_order_of orderOf_ofAdd_eq_addOrderOf\n-/\n\n",
 "orderOf_map_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print orderOf_map_dvd /-\n@[to_additive addOrderOf_map_dvd]\ntheorem orderOf_map_dvd {H : Type _} [Monoid H] (ψ : «expr →* » G H) (x : G) : orderOf (ψ x) ∣ orderOf x :=\n  by\n  apply orderOf_dvd_of_pow_eq_one\n  rw [← map_pow, pow_orderOf_eq_one]\n  apply map_one\n#align order_of_map_dvd orderOf_map_dvd\n#align add_order_of_map_dvd addOrderOf_map_dvd\n-/\n\n",
 "orderOf_le_two":
 "#print LinearOrderedRing.orderOf_le_two /-\ntheorem LinearOrderedRing.orderOf_le_two : orderOf x ≤ 2 :=\n  by\n  cases' ne_or_eq (|x|) 1 with h h\n  · simp [orderOf_abs_ne_one h]\n  rcases eq_or_eq_neg_of_abs_eq h with (rfl | rfl)\n  · simp\n  apply orderOf_le_of_pow_eq_one <;> norm_num\n#align linear_ordered_ring.order_of_le_two LinearOrderedRing.orderOf_le_two\n-/\n\n",
 "orderOf_le_of_pow_eq_one":
 "#print orderOf_le_of_pow_eq_one /-\n@[to_additive addOrderOf_le_of_nsmul_eq_zero]\ntheorem orderOf_le_of_pow_eq_one (hn : 0 < n) (h : x ^ n = 1) : orderOf x ≤ n :=\n  IsPeriodicPt.minimalPeriod_le hn (by rwa [isPeriodicPt_mul_iff_pow_eq_one])\n#align order_of_le_of_pow_eq_one orderOf_le_of_pow_eq_one\n#align add_order_of_le_of_nsmul_eq_zero addOrderOf_le_of_nsmul_eq_zero\n-/\n\n",
 "orderOf_le_card_univ":
 "#print orderOf_le_card_univ /-\n@[to_additive addOrderOf_le_card_univ]\ntheorem orderOf_le_card_univ [Fintype G] : orderOf x ≤ Fintype.card G :=\n  Finset.le_card_of_inj_on_range ((· ^ ·) x) (fun n _ => Finset.mem_univ _) fun i hi j hj =>\n    pow_injective_of_lt_orderOf x hi hj\n#align order_of_le_card_univ orderOf_le_card_univ\n#align add_order_of_le_card_univ addOrderOf_le_card_univ\n-/\n\n",
 "orderOf_inv":
 "#print orderOf_inv /-\n@[simp, to_additive]\ntheorem orderOf_inv (x : G) : orderOf x⁻¹ = orderOf x := by simp [orderOf_eq_orderOf_iff]\n#align order_of_inv orderOf_inv\n#align order_of_neg addOrderOf_neg\n-/\n\n",
 "orderOf_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print orderOf_injective /-\n@[to_additive addOrderOf_injective]\ntheorem orderOf_injective {H : Type _} [Monoid H] (f : «expr →* » G H) (hf : function.injective f) (x : G) :\n    orderOf (f x) = orderOf x := by\n  simp_rw [orderOf_eq_orderOf_iff, ← f.map_pow, ← f.map_one, hf.eq_iff, iff_self_iff, forall_const]\n#align order_of_injective orderOf_injective\n#align add_order_of_injective addOrderOf_injective\n-/\n\n",
 "orderOf_eq_zero_iff'":
 "#print orderOf_eq_zero_iff' /-\n@[to_additive addOrderOf_eq_zero_iff']\ntheorem orderOf_eq_zero_iff' : orderOf x = 0 ↔ ∀ n : ℕ, 0 < n → x ^ n ≠ 1 := by\n  simp_rw [orderOf_eq_zero_iff, isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n#align order_of_eq_zero_iff' orderOf_eq_zero_iff'\n#align add_order_of_eq_zero_iff' addOrderOf_eq_zero_iff'\n-/\n\n",
 "orderOf_eq_zero_iff":
 "#print orderOf_eq_zero_iff /-\n@[to_additive addOrderOf_eq_zero_iff]\ntheorem orderOf_eq_zero_iff : orderOf x = 0 ↔ ¬IsOfFinOrder x :=\n  ⟨fun h H => (orderOf_pos' H).ne' h, orderOf_eq_zero⟩\n#align order_of_eq_zero_iff orderOf_eq_zero_iff\n#align add_order_of_eq_zero_iff addOrderOf_eq_zero_iff\n-/\n\n",
 "orderOf_eq_zero":
 "#print orderOf_eq_zero /-\n@[to_additive addOrderOf_eq_zero]\ntheorem orderOf_eq_zero (h : ¬IsOfFinOrder x) : orderOf x = 0 := by rwa [orderOf, minimal_period, dif_neg]\n#align order_of_eq_zero orderOf_eq_zero\n#align add_order_of_eq_zero addOrderOf_eq_zero\n-/\n\n",
 "orderOf_eq_prime_pow":
 "#print orderOf_eq_prime_pow /-\n@[to_additive addOrderOf_eq_prime_pow]\ntheorem orderOf_eq_prime_pow (hnot : ¬x ^ p ^ n = 1) (hfin : x ^ p ^ (n + 1) = 1) : orderOf x = p ^ (n + 1) := by\n  apply minimal_period_eq_prime_pow <;> rwa [isPeriodicPt_mul_iff_pow_eq_one]\n#align order_of_eq_prime_pow orderOf_eq_prime_pow\n#align add_order_of_eq_prime_pow addOrderOf_eq_prime_pow\n-/\n\n",
 "orderOf_eq_prime":
 "#print orderOf_eq_prime /-\n@[to_additive addOrderOf_eq_prime]\ntheorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x ≠ 1) : orderOf x = p :=\n  minimalPeriod_eq_prime ((isPeriodicPt_mul_iff_pow_eq_one _).mpr hg) (by rwa [is_fixed_pt, mul_one])\n#align order_of_eq_prime orderOf_eq_prime\n#align add_order_of_eq_prime addOrderOf_eq_prime\n-/\n\n",
 "orderOf_eq_orderOf_iff":
 "#print orderOf_eq_orderOf_iff /-\n@[to_additive addOrderOf_eq_addOrderOf_iff]\ntheorem orderOf_eq_orderOf_iff {H : Type _} [Monoid H] {y : H} :\n    orderOf x = orderOf y ↔ ∀ n : ℕ, x ^ n = 1 ↔ y ^ n = 1 := by\n  simp_rw [← isPeriodicPt_mul_iff_pow_eq_one, ← minimal_period_eq_minimal_period_iff, orderOf]\n#align order_of_eq_order_of_iff orderOf_eq_orderOf_iff\n#align add_order_of_eq_add_order_of_iff addOrderOf_eq_addOrderOf_iff\n-/\n\n",
 "orderOf_eq_one_iff":
 "#print orderOf_eq_one_iff /-\n@[simp, to_additive AddMonoid.addOrderOf_eq_one_iff]\ntheorem orderOf_eq_one_iff : orderOf x = 1 ↔ x = 1 := by\n  rw [orderOf, is_fixed_point_iff_minimal_period_eq_one, is_fixed_pt, mul_one]\n#align order_of_eq_one_iff orderOf_eq_one_iff\n#align add_monoid.order_of_eq_one_iff AddMonoid.addOrderOf_eq_one_iff\n-/\n\n",
 "orderOf_eq_of_pow_and_pow_div_prime":
 "#print orderOf_eq_of_pow_and_pow_div_prime /-\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`, then `x` has order `n` in `G`.\n-/\n@[to_additive addOrderOf_eq_of_nsmul_and_div_prime_nsmul\n      \"If `n * x = 0`, but `n/p * x ≠ 0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"]\ntheorem orderOf_eq_of_pow_and_pow_div_prime (hn : 0 < n) (hx : x ^ n = 1)\n    (hd : ∀ p : ℕ, p.prime → p ∣ n → x ^ (n / p) ≠ 1) : orderOf x = n :=\n  by\n  -- Let `a` be `n/(order_of x)`, and show `a = 1`\n  cases' exists_eq_mul_right_of_dvd (orderOf_dvd_of_pow_eq_one hx) with a ha\n  suffices a = 1 by simp [this, ha]\n  -- Assume `a` is not one...\n  by_contra\n  have a_min_fac_dvd_p_sub_one : a.min_fac ∣ n :=\n    by\n    obtain ⟨b, hb⟩ : ∃ b : ℕ, a = b * a.min_fac := exists_eq_mul_left_of_dvd a.min_fac_dvd\n    rw [hb, ← mul_assoc] at ha\n    exact Dvd.intro_left (orderOf x * b) ha.symm\n  -- Use the minimum prime factor of `a` as `p`.\n  refine' hd a.min_fac (Nat.minFac_prime h) a_min_fac_dvd_p_sub_one _\n  rw [← orderOf_dvd_iff_pow_eq_one, Nat.dvd_div_iff a_min_fac_dvd_p_sub_one, ha, mul_comm,\n    Nat.mul_dvd_mul_iff_left (orderOf_pos' _)]\n  · exact Nat.minFac_dvd a\n  · rw [isOfFinOrder_iff_pow_eq_one]\n    exact Exists.intro n (id ⟨hn, hx⟩)\n#align order_of_eq_of_pow_and_pow_div_prime orderOf_eq_of_pow_and_pow_div_prime\n#align add_order_of_eq_of_nsmul_and_div_prime_nsmul addOrderOf_eq_of_nsmul_and_div_prime_nsmul\n-/\n\n",
 "orderOf_eq_iff":
 "#print orderOf_eq_iff /-\n@[to_additive addOrderOf_eq_iff]\ntheorem orderOf_eq_iff {n} (h : 0 < n) : orderOf x = n ↔ x ^ n = 1 ∧ ∀ m, m < n → 0 < m → x ^ m ≠ 1 :=\n  by\n  simp_rw [ne, ← isPeriodicPt_mul_iff_pow_eq_one, orderOf, minimal_period]\n  split_ifs with h1\n  · rw [find_eq_iff, exists_prop_of_true h]\n    push_neg\n    rfl\n  · rw [iff_false_left h.ne]\n    rintro ⟨h', -⟩\n    exact h1 ⟨n, h, h'⟩\n#align order_of_eq_iff orderOf_eq_iff\n#align add_order_of_eq_iff addOrderOf_eq_iff\n-/\n\n",
 "orderOf_eq_card_zpowers":
 "#print orderOf_eq_card_zpowers /-\n/-- See also `order_eq_card_zpowers'`. -/\n@[to_additive addOrderOf_eq_card_zmultiples \"See also `add_order_eq_card_zmultiples'`.\"]\ntheorem orderOf_eq_card_zpowers : orderOf x = Fintype.card (zpowers x) :=\n  (Fintype.card_fin (orderOf x)).symm.trans (Fintype.card_eq.2 ⟨finEquivZpowers x⟩)\n#align order_eq_card_zpowers orderOf_eq_card_zpowers\n#align add_order_eq_card_zmultiples addOrderOf_eq_card_zmultiples\n-/\n\n",
 "orderOf_eq_card_powers":
 "#print orderOf_eq_card_powers /-\n@[to_additive addOrderOf_eq_card_multiples]\ntheorem orderOf_eq_card_powers [Fintype G] : orderOf x = Fintype.card (Submonoid.powers x : Set G) :=\n  (Fintype.card_fin (orderOf x)).symm.trans (Fintype.card_eq.2 ⟨finEquivPowers x⟩)\n#align order_eq_card_powers orderOf_eq_card_powers\n#align add_order_of_eq_card_multiples addOrderOf_eq_card_multiples\n-/\n\n",
 "orderOf_dvd_of_pow_eq_one":
 "#print orderOf_dvd_of_pow_eq_one /-\n@[to_additive addOrderOf_dvd_of_nsmul_eq_zero]\ntheorem orderOf_dvd_of_pow_eq_one (h : x ^ n = 1) : orderOf x ∣ n :=\n  IsPeriodicPt.minimalPeriod_dvd ((isPeriodicPt_mul_iff_pow_eq_one _).mpr h)\n#align order_of_dvd_of_pow_eq_one orderOf_dvd_of_pow_eq_one\n#align add_order_of_dvd_of_nsmul_eq_zero addOrderOf_dvd_of_nsmul_eq_zero\n-/\n\n",
 "orderOf_dvd_of_mem_zpowers":
 "#print orderOf_dvd_of_mem_zpowers /-\n@[to_additive addOrderOf_dvd_of_mem_zmultiples]\ntheorem orderOf_dvd_of_mem_zpowers (h : y ∈ Subgroup.zpowers x) : orderOf y ∣ orderOf x :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp h\n  rw [orderOf_dvd_iff_pow_eq_one]\n  exact zpow_pow_orderOf\n#align order_of_dvd_of_mem_zpowers orderOf_dvd_of_mem_zpowers\n#align add_order_of_dvd_of_mem_zmultiples addOrderOf_dvd_of_mem_zmultiples\n-/\n\n",
 "orderOf_dvd_nat_card":
 "#print orderOf_dvd_nat_card /-\n@[to_additive addOrderOf_dvd_nat_card]\ntheorem orderOf_dvd_nat_card {G : Type _} [Group G] {x : G} : orderOf x ∣ Nat.card G :=\n  by\n  cases' fintypeOrInfinite G with h h\n  · simp only [Nat.card_eq_fintype_card, orderOf_dvd_card_univ]\n  · simp only [card_eq_zero_of_infinite, dvd_zero]\n#align order_of_dvd_nat_card orderOf_dvd_nat_card\n#align add_order_of_dvd_nat_card addOrderOf_dvd_nat_card\n-/\n\n",
 "orderOf_dvd_iff_zpow_eq_one":
 "#print orderOf_dvd_iff_zpow_eq_one /-\n@[to_additive addOrderOf_dvd_iff_zsmul_eq_zero]\ntheorem orderOf_dvd_iff_zpow_eq_one : (orderOf x : ℤ) ∣ i ↔ x ^ i = 1 :=\n  by\n  rcases Int.eq_nat_or_neg i with ⟨i, rfl | rfl⟩\n  · rw [Int.coe_nat_dvd, orderOf_dvd_iff_pow_eq_one, zpow_ofNat]\n  · rw [dvd_neg, Int.coe_nat_dvd, zpow_neg, inv_eq_one, zpow_ofNat, orderOf_dvd_iff_pow_eq_one]\n#align order_of_dvd_iff_zpow_eq_one orderOf_dvd_iff_zpow_eq_one\n#align add_order_of_dvd_iff_zsmul_eq_zero addOrderOf_dvd_iff_zsmul_eq_zero\n-/\n\n",
 "orderOf_dvd_iff_pow_eq_one":
 "#print orderOf_dvd_iff_pow_eq_one /-\n@[to_additive addOrderOf_dvd_iff_nsmul_eq_zero]\ntheorem orderOf_dvd_iff_pow_eq_one {n : ℕ} : orderOf x ∣ n ↔ x ^ n = 1 :=\n  ⟨fun h => by rw [pow_eq_mod_orderOf, nat.mod_eq_zero_of_dvd h, pow_zero], orderOf_dvd_of_pow_eq_one⟩\n#align order_of_dvd_iff_pow_eq_one orderOf_dvd_iff_pow_eq_one\n#align add_order_of_dvd_iff_nsmul_eq_zero addOrderOf_dvd_iff_nsmul_eq_zero\n-/\n\n",
 "orderOf_dvd_card_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print orderOf_dvd_card_univ /-\n@[to_additive addOrderOf_dvd_card_univ]\ntheorem orderOf_dvd_card_univ : orderOf x ∣ Fintype.card G := by\n  classical\n    have ft_prod : Fintype («expr ⧸ » G (zpowers x) × zpowers x) :=\n      Fintype.ofEquiv G group_equiv_quotient_times_subgroup\n    have ft_s : Fintype (zpowers x) := @Fintype.prodRight _ _ _ ft_prod _\n    have ft_cosets : Fintype («expr ⧸ » G (zpowers x)) := @Fintype.prodLeft _ _ _ ft_prod ⟨⟨1, (zpowers x).one_mem⟩⟩\n    have eq₁ : Fintype.card G = @Fintype.card _ ft_cosets * @Fintype.card _ ft_s :=\n      calc\n        Fintype.card G = @Fintype.card _ ft_prod :=\n          @Fintype.card_congr _ _ _ ft_prod group_equiv_quotient_times_subgroup\n        _ = @Fintype.card _ (@prod.fintype _ _ ft_cosets ft_s) := (congr_arg (@Fintype.card _) <| subsingleton.elim _ _)\n        _ = @Fintype.card _ ft_cosets * @Fintype.card _ ft_s := @Fintype.card_prod _ _ ft_cosets ft_s\n        \n    have eq₂ : orderOf x = @Fintype.card _ ft_s :=\n      calc\n        orderOf x = _ := orderOf_eq_card_zpowers\n        _ = _ := congr_arg (@Fintype.card _) <| subsingleton.elim _ _\n        \n    exact Dvd.intro (@Fintype.card («expr ⧸ » G (Subgroup.zpowers x)) ft_cosets) (by rw [eq₁, eq₂, mul_comm])\n#align order_of_dvd_card_univ orderOf_dvd_card_univ\n#align add_order_of_dvd_card_univ addOrderOf_dvd_card_univ\n-/\n\n",
 "orderOf_abs_ne_one":
 "#print orderOf_abs_ne_one /-\ntheorem orderOf_abs_ne_one (h : |x| ≠ 1) : orderOf x = 0 :=\n  by\n  rw [orderOf_eq_zero_iff']\n  intro n hn hx\n  replace hx : |x| ^ n = 1 := by simpa only [abs_one, abs_pow] using congr_arg abs hx\n  cases' h.lt_or_lt with h h\n  · exact ((pow_lt_one (abs_nonneg x) h hn.ne').ne hx).elim\n  · exact ((one_lt_pow h hn.ne').ne' hx).elim\n#align order_of_abs_ne_one orderOf_abs_ne_one\n-/\n\n",
 "of_mem_zpowers":
 "#print IsOfFinOrder.of_mem_zpowers /-\n@[to_additive IsOfFinAddOrder.of_mem_zmultiples]\ntheorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y ∈ Subgroup.zpowers x) : IsOfFinOrder y :=\n  by\n  obtain ⟨k, rfl⟩ := subgroup.mem_zpowers_iff.mp h'\n  exact h.zpow\n#align is_of_fin_order.of_mem_zpowers IsOfFinOrder.of_mem_zpowers\n#align is_of_fin_add_order.of_mem_zmultiples IsOfFinAddOrder.of_mem_zmultiples\n-/\n\n",
 "not_isOfFinOrder_of_injective_pow":
 "#print not_isOfFinOrder_of_injective_pow /-\n/-- See also `injective_pow_iff_not_is_of_fin_order`. -/\n@[to_additive not_isOfFinAddOrder_of_injective_nsmul \"See also\\n`injective_nsmul_iff_not_is_of_fin_add_order`.\"]\ntheorem not_isOfFinOrder_of_injective_pow {x : G} (h : injective fun n : ℕ => x ^ n) : ¬IsOfFinOrder x :=\n  by\n  simp_rw [isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n  intro n hn_pos hnx\n  rw [← pow_zero x] at hnx\n  rw [h hnx] at hn_pos\n  exact irrefl 0 hn_pos\n#align not_is_of_fin_order_of_injective_pow not_isOfFinOrder_of_injective_pow\n#align not_is_of_fin_add_order_of_injective_nsmul not_isOfFinAddOrder_of_injective_nsmul\n-/\n\n",
 "mul":
 "#print IsOfFinOrder.mul /-\n/-- Elements of finite order are closed under multiplication. -/\n@[to_additive \"Elements of finite additive order are closed under addition.\"]\ntheorem IsOfFinOrder.mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) :=\n  (Commute.all x y).is_of_fin_order_mul hx hy\n#align is_of_fin_order.mul IsOfFinOrder.mul\n#align is_of_fin_add_order.add IsOfFinAddOrder.add\n-/\n\n",
 "mem_zpowers_iff_mem_range_orderOf":
 "#print mem_zpowers_iff_mem_range_orderOf /-\n@[to_additive mem_zmultiples_iff_mem_range_addOrderOf]\ntheorem mem_zpowers_iff_mem_range_orderOf [Finite G] [DecidableEq G] :\n    y ∈ Subgroup.zpowers x ↔ y ∈ (Finset.range (orderOf x)).image ((· ^ ·) x : ℕ → G) := by\n  rw [← mem_powers_iff_mem_zpowers, mem_powers_iff_mem_range_orderOf]\n#align mem_zpowers_iff_mem_range_order_of mem_zpowers_iff_mem_range_orderOf\n#align mem_zmultiples_iff_mem_range_add_order_of mem_zmultiples_iff_mem_range_addOrderOf\n-/\n\n",
 "mem_powers_iff_mem_zpowers":
 "#print mem_powers_iff_mem_zpowers /-\n@[to_additive mem_multiples_iff_mem_zmultiples]\ntheorem mem_powers_iff_mem_zpowers [Finite G] : y ∈ Submonoid.powers x ↔ y ∈ zpowers x :=\n  ⟨fun ⟨n, hn⟩ => ⟨n, by simp_all⟩, fun ⟨i, hi⟩ =>\n    ⟨(i % orderOf x).nat_abs, by\n      rwa [← zpow_ofNat, Int.natAbs_of_nonneg (Int.emod_nonneg _ (Int.coe_nat_ne_zero_iff_pos.2 (orderOf_pos x))), ←\n        zpow_eq_mod_orderOf]⟩⟩\n#align mem_powers_iff_mem_zpowers mem_powers_iff_mem_zpowers\n#align mem_multiples_iff_mem_zmultiples mem_multiples_iff_mem_zmultiples\n-/\n\n",
 "mem_powers_iff_mem_range_order_of'":
 "#print mem_powers_iff_mem_range_order_of' /-\n@[to_additive mem_multiples_iff_mem_range_addOrderOf']\ntheorem mem_powers_iff_mem_range_order_of' [DecidableEq G] (hx : 0 < orderOf x) :\n    y ∈ Submonoid.powers x ↔ y ∈ (Finset.range (orderOf x)).image ((· ^ ·) x : ℕ → G) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' hx fun i => pow_eq_mod_orderOf.symm\n#align mem_powers_iff_mem_range_order_of' mem_powers_iff_mem_range_order_of'\n#align mem_multiples_iff_mem_range_add_order_of' mem_multiples_iff_mem_range_addOrderOf'\n-/\n\n",
 "mem_powers_iff_mem_range_orderOf":
 "#print mem_powers_iff_mem_range_orderOf /-\n@[to_additive mem_multiples_iff_mem_range_addOrderOf]\ntheorem mem_powers_iff_mem_range_orderOf [Finite G] [DecidableEq G] :\n    y ∈ Submonoid.powers x ↔ y ∈ (Finset.range (orderOf x)).image ((· ^ ·) x : ℕ → G) :=\n  Finset.mem_range_iff_mem_finset_range_of_mod_eq' (orderOf_pos x) fun i => pow_eq_mod_orderOf.symm\n#align mem_powers_iff_mem_range_order_of mem_powers_iff_mem_range_orderOf\n#align mem_multiples_iff_mem_range_add_order_of mem_multiples_iff_mem_range_addOrderOf\n-/\n\n",
 "is_of_fin_order_mul":
 "/-- Commuting elements of finite order are closed under multiplication. -/\n@[to_additive \"Commuting elements of finite additive order are closed under addition.\"]\ntheorem is_of_fin_order_mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) :=\n  orderOf_pos_iff.mp <| pos_of_dvd_of_pos h.order_of_mul_dvd_mul_order_of <| mul_pos (orderOf_pos' hx) (orderOf_pos' hy)\n#align is_of_fin_order_mul is_of_fin_order_mul\n\n",
 "isPeriodicPt_mul_iff_pow_eq_one":
 "#print isPeriodicPt_mul_iff_pow_eq_one /-\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Julian Kuelshammer\n-/\n@[to_additive]\ntheorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt ((· * ·) x) n 1 ↔ x ^ n = 1 := by\n  rw [is_periodic_pt, is_fixed_pt, mul_left_iterate, mul_one]\n#align is_periodic_pt_mul_iff_pow_eq_one isPeriodicPt_mul_iff_pow_eq_one\n#align is_periodic_pt_add_iff_nsmul_eq_zero isPeriodicPt_add_iff_nsmul_eq_zero\n-/\n\n",
 "isOfFinOrder_one":
 "#print isOfFinOrder_one /-\n/-- 1 is of finite order in any monoid. -/\n@[to_additive \"0 is of finite order in any additive monoid.\"]\ntheorem isOfFinOrder_one : IsOfFinOrder (1 : G) :=\n  (isOfFinOrder_iff_pow_eq_one 1).mpr ⟨1, one_pos, one_pow 1⟩\n#align is_of_fin_order_one isOfFinOrder_one\n#align is_of_fin_order_zero isOfFinAddOrder_zero\n-/\n\n",
 "isOfFinOrder_ofAdd_iff":
 "#print isOfFinOrder_ofAdd_iff /-\ntheorem isOfFinOrder_ofAdd_iff : IsOfFinOrder (Multiplicative.ofAdd a) ↔ IsOfFinAddOrder a :=\n  iff.rfl\n#align is_of_fin_order_of_add_iff isOfFinOrder_ofAdd_iff\n-/\n\n",
 "isOfFinOrder_inv_iff":
 "#print isOfFinOrder_inv_iff /-\n/-- Inverses of elements of finite order have finite order. -/\n@[simp, to_additive \"Inverses of elements of finite additive order have finite additive order.\"]\ntheorem isOfFinOrder_inv_iff {x : G} : IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n  ⟨fun h => inv_inv x ▸ h.inv, IsOfFinOrder.inv⟩\n#align is_of_fin_order_inv_iff isOfFinOrder_inv_iff\n#align is_of_fin_order_neg_iff isOfFinAddOrder_neg_iff\n-/\n\n",
 "isOfFinOrder_iff_pow_eq_one":
 "#print isOfFinOrder_iff_pow_eq_one /-\n@[to_additive isOfFinAddOrder_iff_nsmul_eq_zero]\ntheorem isOfFinOrder_iff_pow_eq_one (x : G) : IsOfFinOrder x ↔ ∃ n, 0 < n ∧ x ^ n = 1 :=\n  by\n  convert iff.rfl\n  simp [isPeriodicPt_mul_iff_pow_eq_one]\n#align is_of_fin_order_iff_pow_eq_one isOfFinOrder_iff_pow_eq_one\n#align is_of_fin_add_order_iff_nsmul_eq_zero isOfFinAddOrder_iff_nsmul_eq_zero\n-/\n\n",
 "isOfFinOrder_iff_coe":
 "#print isOfFinOrder_iff_coe /-\n/-- Elements of finite order are of finite order in submonoids.-/\n@[to_additive isOfFinAddOrder_iff_coe \"Elements of finite order are of finite order in\\nsubmonoids.\"]\ntheorem isOfFinOrder_iff_coe (H : Submonoid G) (x : H) : IsOfFinOrder x ↔ IsOfFinOrder (x : G) :=\n  by\n  rw [isOfFinOrder_iff_pow_eq_one, isOfFinOrder_iff_pow_eq_one]\n  norm_cast\n#align is_of_fin_order_iff_coe isOfFinOrder_iff_coe\n#align is_of_fin_add_order_iff_coe isOfFinAddOrder_iff_coe\n-/\n\n",
 "isOfFinOrder":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print MonoidHom.isOfFinOrder /-\n/-- The image of an element of finite order has finite order. -/\n@[to_additive AddMonoidHom.isOfFinAddOrder\n      \"The image of an element of finite additive order has finite additive order.\"]\ntheorem MonoidHom.isOfFinOrder {H : Type v} [Monoid H] (f : «expr →* » G H) {x : G} (h : IsOfFinOrder x) :\n    IsOfFinOrder <| f x :=\n  (isOfFinOrder_iff_pow_eq_one _).mpr <|\n    by\n    rcases(isOfFinOrder_iff_pow_eq_one _).mp h with ⟨n, npos, hn⟩\n    exact ⟨n, npos, by rw [← f.map_pow, hn, f.map_one]⟩\n#align monoid_hom.is_of_fin_order MonoidHom.isOfFinOrder\n#align add_monoid_hom.is_of_fin_order AddMonoidHom.isOfFinAddOrder\n-/\n\n",
 "isOfFinAddOrder_ofMul_iff":
 "#print isOfFinAddOrder_ofMul_iff /-\ntheorem isOfFinAddOrder_ofMul_iff : IsOfFinAddOrder (Additive.ofMul x) ↔ IsOfFinOrder x :=\n  iff.rfl\n#align is_of_fin_add_order_of_mul_iff isOfFinAddOrder_ofMul_iff\n-/\n\n",
 "inv":
 "#print IsOfFinOrder.inv /-\n/-- Inverses of elements of finite order have finite order. -/\n@[to_additive \"Inverses of elements of finite additive order have finite additive order.\"]\ntheorem IsOfFinOrder.inv {x : G} (hx : IsOfFinOrder x) : IsOfFinOrder x⁻¹ :=\n  (isOfFinOrder_iff_pow_eq_one _).mpr <|\n    by\n    rcases(isOfFinOrder_iff_pow_eq_one x).mp hx with ⟨n, npos, hn⟩\n    refine' ⟨n, npos, by simp_rw [inv_pow, hn, inv_one]⟩\n#align is_of_fin_order.inv IsOfFinOrder.inv\n#align is_of_fin_add_order.neg IsOfFinAddOrder.neg\n-/\n\n",
 "injective_pow_iff_not_isOfFinOrder":
 "#print injective_pow_iff_not_isOfFinOrder /-\n@[simp, to_additive injective_nsmul_iff_not_isOfFinAddOrder]\ntheorem injective_pow_iff_not_isOfFinOrder {x : G} : (injective fun n : ℕ => x ^ n) ↔ ¬IsOfFinOrder x :=\n  by\n  refine' ⟨fun h => not_isOfFinOrder_of_injective_pow h, fun h n m hnm => _⟩\n  rwa [pow_eq_pow_iff_modEq, order_of_eq_zero_iff.mpr h, modeq_zero_iff] at hnm\n#align injective_pow_iff_not_is_of_fin_order injective_pow_iff_not_isOfFinOrder\n#align injective_nsmul_iff_not_is_of_fin_add_order injective_nsmul_iff_not_isOfFinAddOrder\n-/\n\n",
 "infinite_not_isOfFinOrder":
 "#print infinite_not_isOfFinOrder /-\n@[to_additive infinite_not_isOfFinAddOrder]\ntheorem infinite_not_isOfFinOrder {x : G} (h : ¬IsOfFinOrder x) : { y : G | ¬IsOfFinOrder y }.infinite :=\n  by\n  let s := { n | 0 < n }.image fun n : ℕ => x ^ n\n  have hs : s ⊆ { y : G | ¬IsOfFinOrder y } :=\n    by\n    rintro - ⟨n, hn : 0 < n, rfl⟩ (contra : IsOfFinOrder (x ^ n))\n    apply h\n    rw [isOfFinOrder_iff_pow_eq_one] at contra⊢\n    obtain ⟨m, hm, hm'⟩ := contra\n    exact ⟨n * m, mul_pos hn hm, by rwa [pow_mul]⟩\n  suffices s.infinite by exact this.mono hs\n  contrapose! h\n  have : ¬injective fun n : ℕ => x ^ n :=\n    by\n    have := Set.not_injOn_infinite_finite_image (Set.Ioi_infinite 0) (set.not_infinite.mp h)\n    contrapose! this\n    exact Set.injOn_of_injective this _\n  rwa [injective_pow_iff_not_isOfFinOrder, Classical.not_not] at this\n#align infinite_not_is_of_fin_order infinite_not_isOfFinOrder\n#align infinite_not_is_of_fin_add_order infinite_not_isOfFinAddOrder\n-/\n\n",
 "inf_eq_bot_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print inf_eq_bot_of_coprime /-\n@[to_additive add_inf_eq_bot_of_coprime]\ntheorem inf_eq_bot_of_coprime {G : Type _} [Group G] {H K : Subgroup G} [Fintype H] [Fintype K]\n    (h : Nat.coprime (Fintype.card H) (Fintype.card K)) : «expr ⊓ » H K = «expr⊥» :=\n  by\n  refine' («expr ⊓ » H K).eq_bot_iff_forall.mpr fun x hx => _\n  rw [← orderOf_eq_one_iff, ← Nat.dvd_one, ← h.gcd_eq_one, Nat.dvd_gcd_iff]\n  exact\n    ⟨(congr_arg (· ∣ Fintype.card H) (orderOf_subgroup ⟨x, hx.1⟩)).mpr orderOf_dvd_card_univ,\n      (congr_arg (· ∣ Fintype.card K) (orderOf_subgroup ⟨x, hx.2⟩)).mpr orderOf_dvd_card_univ⟩\n#align inf_eq_bot_of_coprime inf_eq_bot_of_coprime\n#align add_inf_eq_bot_of_coprime add_inf_eq_bot_of_coprime\n-/\n\n",
 "image_range_orderOf":
 "#print image_range_orderOf /-\n/-- TODO: Generalise to `submonoid.powers`.-/\n@[to_additive image_range_addOrderOf, nolint to_additive_doc]\ntheorem image_range_orderOf [DecidableEq G] :\n    Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (zpowers x : Set G).to_finset :=\n  by\n  ext x\n  rw [Set.mem_toFinset, SetLike.mem_coe, mem_zpowers_iff_mem_range_orderOf]\n#align image_range_order_of image_range_orderOf\n#align image_range_add_order_of image_range_addOrderOf\n-/\n\n",
 "finEquivZpowers_symm_apply":
 "#print finEquivZpowers_symm_apply /-\n@[simp, to_additive finEquivZmultiples_symm_apply]\ntheorem finEquivZpowers_symm_apply [Finite G] (x : G) (n : ℕ) {hn : ∃ m : ℤ, x ^ m = x ^ n} :\n    (finEquivZpowers x).symm ⟨x ^ n, hn⟩ = ⟨n % orderOf x, nat.mod_lt _ (orderOf_pos x)⟩ :=\n  by\n  rw [finEquivZpowers, Equiv.symm_trans_apply, equiv.set.of_eq_symm_apply]\n  exact finEquivPowers_symm_apply x n\n#align fin_equiv_zpowers_symm_apply finEquivZpowers_symm_apply\n#align fin_equiv_zmultiples_symm_apply finEquivZmultiples_symm_apply\n-/\n\n",
 "finEquivZpowers_apply":
 "#print finEquivZpowers_apply /-\n@[simp, to_additive finEquivZmultiples_apply]\ntheorem finEquivZpowers_apply [Finite G] {n : Fin (orderOf x)} :\n    finEquivZpowers x n = ⟨x ^ (n : ℕ), n, zpow_ofNat x n⟩ :=\n  rfl\n#align fin_equiv_zpowers_apply finEquivZpowers_apply\n#align fin_equiv_zmultiples_apply finEquivZmultiples_apply\n-/\n\n",
 "finEquivPowers_symm_apply":
 "#print finEquivPowers_symm_apply /-\n@[simp, to_additive finEquivMultiples_symm_apply]\ntheorem finEquivPowers_symm_apply [Finite G] (x : G) (n : ℕ) {hn : ∃ m : ℕ, x ^ m = x ^ n} :\n    (finEquivPowers x).symm ⟨x ^ n, hn⟩ = ⟨n % orderOf x, nat.mod_lt _ (orderOf_pos x)⟩ := by\n  rw [Equiv.symm_apply_eq, finEquivPowers_apply, Subtype.mk_eq_mk, pow_eq_mod_orderOf, Fin.val_mk]\n#align fin_equiv_powers_symm_apply finEquivPowers_symm_apply\n#align fin_equiv_multiples_symm_apply finEquivMultiples_symm_apply\n-/\n\n",
 "finEquivPowers_apply":
 "#print finEquivPowers_apply /-\n@[simp, to_additive finEquivMultiples_apply]\ntheorem finEquivPowers_apply [Finite G] {x : G} {n : Fin (orderOf x)} : finEquivPowers x n = ⟨x ^ ↑n, n, rfl⟩ :=\n  rfl\n#align fin_equiv_powers_apply finEquivPowers_apply\n#align fin_equiv_multiples_apply finEquivMultiples_apply\n-/\n\n",
 "exists_zpow_eq_one":
 "#print exists_zpow_eq_one /-\n@[to_additive]\ntheorem exists_zpow_eq_one [Finite G] (x : G) : ∃ (i : ℤ)(H : i ≠ 0), x ^ (i : ℤ) = 1 :=\n  by\n  rcases exists_pow_eq_one x with ⟨w, hw1, hw2⟩\n  refine' ⟨w, int.coe_nat_ne_zero.mpr (ne_of_gt hw1), _⟩\n  rw [zpow_ofNat]\n  exact (isPeriodicPt_mul_iff_pow_eq_one _).mp hw2\n#align exists_zpow_eq_one exists_zpow_eq_one\n#align exists_zsmul_eq_zero exists_zsmul_eq_zero\n-/\n\n",
 "exists_pow_eq_self_of_coprime":
 "#print exists_pow_eq_self_of_coprime /-\n@[to_additive]\ntheorem exists_pow_eq_self_of_coprime (h : n.coprime (orderOf x)) : ∃ m : ℕ, (x ^ n) ^ m = x :=\n  by\n  by_cases h0 : orderOf x = 0\n  · rw [h0, coprime_zero_right] at h\n    exact ⟨1, by rw [h, pow_one, pow_one]⟩\n  by_cases h1 : orderOf x = 1\n  · exact ⟨0, by rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]⟩\n  obtain ⟨m, hm⟩ := exists_mul_mod_eq_one_of_coprime h (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, h1⟩)\n  exact ⟨m, by rw [← pow_mul, pow_eq_mod_orderOf, hm, pow_one]⟩\n#align exists_pow_eq_self_of_coprime exists_pow_eq_self_of_coprime\n#align exists_nsmul_eq_self_of_coprime exists_nsmul_eq_self_of_coprime\n-/\n\n",
 "exists_pow_eq_one":
 "#print exists_pow_eq_one /-\n-- TODO: Of course everything also works for right_cancel_monoids.\n-- TODO: Use this to show that a finite left cancellative monoid is a group.\n@[to_additive]\ntheorem exists_pow_eq_one [Finite G] (x : G) : IsOfFinOrder x :=\n  by\n  have : (Set.univ : Set G).finite := set.univ.to_finite\n  contrapose! this\n  exact Set.Infinite.mono (Set.subset_univ _) (infinite_not_isOfFinOrder this)\n#align exists_pow_eq_one exists_pow_eq_one\n#align exists_nsmul_eq_zero exists_nsmul_eq_zero\n-/\n\n",
 "exists_orderOf_eq_prime_pow_iff":
 "#print exists_orderOf_eq_prime_pow_iff /-\n@[to_additive exists_addOrderOf_eq_prime_pow_iff]\ntheorem exists_orderOf_eq_prime_pow_iff : (∃ k : ℕ, orderOf x = p ^ k) ↔ ∃ m : ℕ, x ^ (p : ℕ) ^ m = 1 :=\n  ⟨fun ⟨k, hk⟩ => ⟨k, by rw [← hk, pow_orderOf_eq_one]⟩, fun ⟨_, hm⟩ =>\n    by\n    obtain ⟨k, _, hk⟩ := (Nat.dvd_prime_pow hp.elim).mp (orderOf_dvd_of_pow_eq_one hm)\n    exact ⟨k, hk⟩⟩\n#align exists_order_of_eq_prime_pow_iff exists_orderOf_eq_prime_pow_iff\n#align exists_add_order_of_eq_prime_pow_iff exists_addOrderOf_eq_prime_pow_iff\n-/\n\n",
 "apply":
 "#print IsOfFinOrder.apply /-\n/-- If a direct product has finite order then so does each component. -/\n@[to_additive \"If a direct product has finite additive order then so does each component.\"]\ntheorem IsOfFinOrder.apply {η : Type _} {Gs : η → Type _} [∀ i, Monoid (Gs i)] {x : ∀ i, Gs i} (h : IsOfFinOrder x) :\n    ∀ i, IsOfFinOrder (x i) :=\n  by\n  rcases(isOfFinOrder_iff_pow_eq_one _).mp h with ⟨n, npos, hn⟩\n  exact fun _ => (isOfFinOrder_iff_pow_eq_one _).mpr ⟨n, npos, (congr_fun hn.symm _).symm⟩\n#align is_of_fin_order.apply IsOfFinOrder.apply\n#align is_of_fin_add_order.apply IsOfFinAddOrder.apply\n-/\n\n",
 "addOrderOf_ofMul_eq_orderOf":
 "#print addOrderOf_ofMul_eq_orderOf /-\n@[simp]\ntheorem addOrderOf_ofMul_eq_orderOf (x : G) : addOrderOf (Additive.ofMul x) = orderOf x :=\n  rfl\n#align add_order_of_of_mul_eq_order_of addOrderOf_ofMul_eq_orderOf\n-/\n\n"}