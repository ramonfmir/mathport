{"of_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\ntheorem of_succ {Y : C} {n q : â„•} {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))}\n    (v : higher_faces_vanish (q + 1) Ï†) : higher_faces_vanish q Ï† := fun j hj =>\n  v j (by simpa only [â† add_assoc] using le_add_right hj)\n#align of_succ of_succ\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem of_comp {Y Z : C} {q n : â„•} {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q Ï†)\n    (f : Â«expr âŸ¶ Â» Z Y) : higher_faces_vanish q (Â«expr â‰« Â» f Ï†) := fun j hj => by rw [assoc, v j hj, comp_zero]\n#align of_comp of_comp\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem induction {Y : C} {n q : â„•} {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q Ï†) :\n    higher_faces_vanish (q + 1) (Â«expr â‰« Â» Ï† (((Â«exprğŸ™Â») _ + HÏƒ q).f (n + 1))) :=\n  by\n  intro j hjâ‚\n  dsimp\n  simp only [comp_add, add_comp, comp_id]\n  -- when n < q, the result follows immediately from the assumption\n  by_cases hqn : n < q\n  Â· rw [v.comp_HÏƒ_eq_zero hqn, zero_comp, add_zero, v j (by linarith)]\n  -- we now assume that nâ‰¥q, and write n=a+q\n  cases' nat.le.dest (not_lt.mp hqn) with a ha\n  rw [v.comp_HÏƒ_eq (show n = a + q by linarith), neg_comp, add_neg_eq_zero, assoc, assoc]\n  cases' n with m hm\n  -- the boundary case n=0\n  Â· simpa only [nat.eq_zero_of_add_eq_zero_left ha, fin.eq_zero j, Fin.mk_zero, Fin.mk_one, Î´_comp_Ïƒ_succ, comp_id]\n  -- in the other case, we need to write n as m+1\n  -- then, we first consider the particular case j = a\n  by_cases hjâ‚‚ : a = (j : â„•)\n  Â· simp only [hjâ‚‚, Fin.eta, Î´_comp_Ïƒ_succ, comp_id]\n    congr\n    ext\n    simp only [Fin.val_succ, Fin.val_mk]\n  -- now, we assume j â‰  a (i.e. a < j)\n  have haj : a < j := (Ne.le_iff_lt hjâ‚‚).mp (by linarith)\n  have hjâ‚ƒ := j.is_lt\n  have ham : a â‰¤ m := by\n    by_contra\n    rw [not_le, â† Nat.succ_le_iff] at h\n    linarith\n  rw [X.Î´_comp_Ïƒ_of_gt', j.pred_succ]\n  swap\n  Â· rw [Fin.lt_iff_val_lt_val]\n    simpa only [Fin.val_mk, Fin.val_succ, add_lt_add_iff_right] using haj\n  obtain ham' | ham'' := ham.lt_or_eq\n  Â· -- case where `a<m`\n    rw [â† X.Î´_comp_Î´''_assoc]\n    swap\n    Â· rw [Fin.le_iff_val_le_val]\n      dsimp\n      linarith\n    simp only [â† assoc, v j (by linarith), zero_comp]\n  Â· -- in the last case, a=m, q=1 and j=a+1\n    rw [X.Î´_comp_Î´_self'_assoc]\n    swap\n    Â· ext\n      dsimp\n      have hq : q = 1 := by rw [â† add_left_inj a, ha, ham'', add_comm]\n      linarith\n    simp only [â† assoc, v j (by linarith), zero_comp]\n#align induction induction\n\n",
 "comp_Î´_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2022 JoÃ«l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: JoÃ«l Riou\n-/\n@[reassoc.1]\ntheorem comp_Î´_eq_zero {Y : C} {n : â„•} {q : â„•} {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))}\n    (v : higher_faces_vanish q Ï†) (j : fin (n + 2)) (hjâ‚ : j â‰  0) (hjâ‚‚ : n + 2 â‰¤ (j : â„•) + q) :\n    Â«expr â‰« Â» Ï† (X.Î´ j) = 0 := by\n  obtain âŸ¨i, hiâŸ© := Fin.eq_succ_of_ne_zero hjâ‚\n  subst hi\n  apply v i\n  rw [â† @nat.add_le_add_iff_right 1, add_assoc]\n  simpa only [Fin.val_succ, add_assoc, add_comm 1] using hjâ‚‚\n#align comp_Î´_eq_zero comp_Î´_eq_zero\n\n",
 "comp_HÏƒ_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem comp_HÏƒ_eq_zero {Y : C} {n q : â„•} {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))}\n    (v : higher_faces_vanish q Ï†) (hqn : n < q) : Â«expr â‰« Â» Ï† ((HÏƒ q).f (n + 1)) = 0 :=\n  by\n  simp only [HÏƒ, homotopy.null_homotopic_map'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]\n  rw [hÏƒ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]\n  by_cases hqn' : n + 1 < q\n  Â· rw [hÏƒ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]\n  Â· simp only [hÏƒ'_eq (show n + 1 = 0 + q by linarith) (c_mk (n + 2) (n + 1) rfl), pow_zero, Fin.mk_zero, one_zsmul,\n      eq_to_hom_refl, comp_id, comp_sum, alternating_face_map_complex.obj_d_eq]\n    rw [â† fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by linarith), fin.sum_trunc]\n    Â· simp only [fin.sum_univ_cast_succ, fin.sum_univ_zero, zero_add, Fin.last, Fin.castLe_mk, Fin.cast_mk,\n        Fin.castSucc_mk]\n      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one, neg_smul, comp_neg]\n      erw [Î´_comp_Ïƒ_self, Î´_comp_Ïƒ_succ, add_right_neg]\n    Â· intro j\n      rw [comp_zsmul, comp_zsmul, Î´_comp_Ïƒ_of_gt', v.comp_Î´_eq_zero_assoc, zero_comp, zsmul_zero]\n      Â· intro h\n        rw [Fin.pred_eq_iff_eq_succ, Fin.ext_iff] at h\n        dsimp at h\n        linarith\n      Â· dsimp\n        simp only [Fin.cast_natAdd, Fin.coe_pred, Fin.coe_addNat, add_succ_sub_one]\n        linarith\n      Â· rw [Fin.lt_iff_val_lt_val]\n        dsimp\n        linarith\n#align comp_HÏƒ_eq_zero comp_HÏƒ_eq_zero\n\n",
 "comp_HÏƒ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem comp_HÏƒ_eq {Y : C} {n a q : â„•} {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q Ï†)\n    (hnaq : n = a + q) :\n    Â«expr â‰« Â» Ï† ((HÏƒ q).f (n + 1)) =\n      -Â«expr â‰« Â» Ï†\n          (Â«expr â‰« Â» (X.Î´ âŸ¨a + 1, nat.succ_lt_succ (Nat.lt_succ_iff.mpr (nat.le.intro hnaq.symm))âŸ©)\n            (X.Ïƒ âŸ¨a, Nat.lt_succ_iff.mpr (nat.le.intro hnaq.symm)âŸ©)) :=\n  by\n  have hnaq_shift : âˆ€ d : â„•, n + d = a + d + q := by\n    intro d\n    rw [add_assoc, add_comm d, â† add_assoc, hnaq]\n  rw [HÏƒ, homotopy.null_homotopic_map'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl),\n    hÏƒ'_eq hnaq (c_mk (n + 1) n rfl), hÏƒ'_eq (hnaq_shift 1) (c_mk (n + 2) (n + 1) rfl)]\n  simp only [alternating_face_map_complex.obj_d_eq, eq_to_hom_refl, comp_id, comp_sum, sum_comp, comp_add]\n  simp only [comp_zsmul, zsmul_comp, â† assoc, â† mul_zsmul]\n  -- cleaning up the first sum\n  rw [â† fin.sum_congr' _ (hnaq_shift 2).symm, fin.sum_trunc]\n  swap\n  Â· rintro âŸ¨k, hkâŸ©\n    suffices Â«expr â‰« Â» Ï† (X.Î´ (âŸ¨a + 2 + k, by linarithâŸ© : fin (n + 2))) = 0 by\n      simp only [this, Fin.natAdd_mk, Fin.cast_mk, zero_comp, smul_zero]\n    convert\n      v âŸ¨a + k + 1, by linarithâŸ©\n        (by\n          rw [Fin.val_mk]\n          linarith)\n    rw [nat.succ_eq_add_one]\n    linarith\n  -- cleaning up the second sum\n  rw [â† fin.sum_congr' _ (hnaq_shift 3).symm, @fin.sum_trunc _ _ (a + 3)]\n  swap\n  Â· rintro âŸ¨k, hkâŸ©\n    rw [assoc, X.Î´_comp_Ïƒ_of_gt', v.comp_Î´_eq_zero_assoc, zero_comp, zsmul_zero]\n    Â· intro h\n      rw [Fin.pred_eq_iff_eq_succ, Fin.ext_iff] at h\n      dsimp at h\n      linarith\n    Â· dsimp\n      simp only [Fin.coe_pred, Fin.val_mk, succ_add_sub_one]\n      linarith\n    Â· dsimp\n      linarith\n  -- leaving out three specific terms\n  conv_lhs =>\n    congr\n    skip\n    rw [fin.sum_univ_cast_succ, fin.sum_univ_cast_succ]\n  rw [fin.sum_univ_cast_succ]\n  simp only [Fin.last, Fin.castLe_mk, Fin.coe_cast, Fin.cast_mk, Fin.coe_castLe, Fin.val_mk, Fin.castSucc_mk,\n    Fin.coe_castSucc]\n  /- the purpose of the following `simplif` is to create three subgoals in order\n      to finish the proof -/\n  have simplif :\n    âˆ€ a b c d e f : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1)),\n      b = f â†’ d + e = 0 â†’ c + a = 0 â†’ a + b + (c + d + e) = f :=\n    by\n    intro a b c d e f h1 h2 h3\n    rw [add_assoc c d e, h2, add_zero, add_comm a b, add_assoc, add_comm a c, h3, add_zero, h1]\n  apply simplif\n  Â· -- b=f\n    rw [â† pow_add, Odd.neg_one_pow, neg_smul, one_zsmul]\n    use a\n    linarith\n  Â· -- d+e = 0\n    rw [assoc, assoc, X.Î´_comp_Ïƒ_self' (Fin.castSucc_mk _ _ _).symm, X.Î´_comp_Ïƒ_succ' (Fin.succ_mk _ _ _).symm]\n    simp only [comp_id, pow_add _ (a + 1) 1, pow_one, mul_neg, mul_one, neg_smul, add_right_neg]\n  Â· -- c+a = 0\n    rw [â† finset.sum_add_distrib]\n    apply finset.sum_eq_zero\n    rintro âŸ¨i, hiâŸ© hâ‚€\n    have hia : (âŸ¨i, by linarithâŸ© : fin (n + 2)) â‰¤ Fin.castSucc (âŸ¨a, by linarithâŸ© : fin (n + 1)) := by\n      simpa only [Fin.le_iff_val_le_val, Fin.val_mk, Fin.castSucc_mk, â† lt_succ_iff] using hi\n    simp only [Fin.val_mk, Fin.castLe_mk, Fin.castSucc_mk, Fin.succ_mk, assoc, Fin.cast_mk, â† Î´_comp_Ïƒ_of_le X hia,\n      add_eq_zero_iff_eq_neg, â† neg_zsmul]\n    congr\n    ring\n#align comp_HÏƒ_eq comp_HÏƒ_eq\n\n"}