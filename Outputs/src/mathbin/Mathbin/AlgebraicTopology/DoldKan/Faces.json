{"of_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\ntheorem of_succ {Y : C} {n q : ℕ} {φ : «expr ⟶ » Y (simplicial_object.at X (n + 1))}\n    (v : higher_faces_vanish (q + 1) φ) : higher_faces_vanish q φ := fun j hj =>\n  v j (by simpa only [← add_assoc] using le_add_right hj)\n#align of_succ of_succ\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem of_comp {Y Z : C} {q n : ℕ} {φ : «expr ⟶ » Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q φ)\n    (f : «expr ⟶ » Z Y) : higher_faces_vanish q («expr ≫ » f φ) := fun j hj => by rw [assoc, v j hj, comp_zero]\n#align of_comp of_comp\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem induction {Y : C} {n q : ℕ} {φ : «expr ⟶ » Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q φ) :\n    higher_faces_vanish (q + 1) («expr ≫ » φ (((«expr𝟙») _ + Hσ q).f (n + 1))) :=\n  by\n  intro j hj₁\n  dsimp\n  simp only [comp_add, add_comp, comp_id]\n  -- when n < q, the result follows immediately from the assumption\n  by_cases hqn : n < q\n  · rw [v.comp_Hσ_eq_zero hqn, zero_comp, add_zero, v j (by linarith)]\n  -- we now assume that n≥q, and write n=a+q\n  cases' nat.le.dest (not_lt.mp hqn) with a ha\n  rw [v.comp_Hσ_eq (show n = a + q by linarith), neg_comp, add_neg_eq_zero, assoc, assoc]\n  cases' n with m hm\n  -- the boundary case n=0\n  · simpa only [nat.eq_zero_of_add_eq_zero_left ha, fin.eq_zero j, Fin.mk_zero, Fin.mk_one, δ_comp_σ_succ, comp_id]\n  -- in the other case, we need to write n as m+1\n  -- then, we first consider the particular case j = a\n  by_cases hj₂ : a = (j : ℕ)\n  · simp only [hj₂, Fin.eta, δ_comp_σ_succ, comp_id]\n    congr\n    ext\n    simp only [Fin.val_succ, Fin.val_mk]\n  -- now, we assume j ≠ a (i.e. a < j)\n  have haj : a < j := (Ne.le_iff_lt hj₂).mp (by linarith)\n  have hj₃ := j.is_lt\n  have ham : a ≤ m := by\n    by_contra\n    rw [not_le, ← Nat.succ_le_iff] at h\n    linarith\n  rw [X.δ_comp_σ_of_gt', j.pred_succ]\n  swap\n  · rw [Fin.lt_iff_val_lt_val]\n    simpa only [Fin.val_mk, Fin.val_succ, add_lt_add_iff_right] using haj\n  obtain ham' | ham'' := ham.lt_or_eq\n  · -- case where `a<m`\n    rw [← X.δ_comp_δ''_assoc]\n    swap\n    · rw [Fin.le_iff_val_le_val]\n      dsimp\n      linarith\n    simp only [← assoc, v j (by linarith), zero_comp]\n  · -- in the last case, a=m, q=1 and j=a+1\n    rw [X.δ_comp_δ_self'_assoc]\n    swap\n    · ext\n      dsimp\n      have hq : q = 1 := by rw [← add_left_inj a, ha, ham'', add_comm]\n      linarith\n    simp only [← assoc, v j (by linarith), zero_comp]\n#align induction induction\n\n",
 "comp_δ_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\n@[reassoc.1]\ntheorem comp_δ_eq_zero {Y : C} {n : ℕ} {q : ℕ} {φ : «expr ⟶ » Y (simplicial_object.at X (n + 1))}\n    (v : higher_faces_vanish q φ) (j : fin (n + 2)) (hj₁ : j ≠ 0) (hj₂ : n + 2 ≤ (j : ℕ) + q) :\n    «expr ≫ » φ (X.δ j) = 0 := by\n  obtain ⟨i, hi⟩ := Fin.eq_succ_of_ne_zero hj₁\n  subst hi\n  apply v i\n  rw [← @nat.add_le_add_iff_right 1, add_assoc]\n  simpa only [Fin.val_succ, add_assoc, add_comm 1] using hj₂\n#align comp_δ_eq_zero comp_δ_eq_zero\n\n",
 "comp_Hσ_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_Hσ_eq_zero {Y : C} {n q : ℕ} {φ : «expr ⟶ » Y (simplicial_object.at X (n + 1))}\n    (v : higher_faces_vanish q φ) (hqn : n < q) : «expr ≫ » φ ((Hσ q).f (n + 1)) = 0 :=\n  by\n  simp only [Hσ, homotopy.null_homotopic_map'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]\n  rw [hσ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]\n  by_cases hqn' : n + 1 < q\n  · rw [hσ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]\n  · simp only [hσ'_eq (show n + 1 = 0 + q by linarith) (c_mk (n + 2) (n + 1) rfl), pow_zero, Fin.mk_zero, one_zsmul,\n      eq_to_hom_refl, comp_id, comp_sum, alternating_face_map_complex.obj_d_eq]\n    rw [← fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by linarith), fin.sum_trunc]\n    · simp only [fin.sum_univ_cast_succ, fin.sum_univ_zero, zero_add, Fin.last, Fin.castLe_mk, Fin.cast_mk,\n        Fin.castSucc_mk]\n      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one, neg_smul, comp_neg]\n      erw [δ_comp_σ_self, δ_comp_σ_succ, add_right_neg]\n    · intro j\n      rw [comp_zsmul, comp_zsmul, δ_comp_σ_of_gt', v.comp_δ_eq_zero_assoc, zero_comp, zsmul_zero]\n      · intro h\n        rw [Fin.pred_eq_iff_eq_succ, Fin.ext_iff] at h\n        dsimp at h\n        linarith\n      · dsimp\n        simp only [Fin.cast_natAdd, Fin.coe_pred, Fin.coe_addNat, add_succ_sub_one]\n        linarith\n      · rw [Fin.lt_iff_val_lt_val]\n        dsimp\n        linarith\n#align comp_Hσ_eq_zero comp_Hσ_eq_zero\n\n",
 "comp_Hσ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_Hσ_eq {Y : C} {n a q : ℕ} {φ : «expr ⟶ » Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q φ)\n    (hnaq : n = a + q) :\n    «expr ≫ » φ ((Hσ q).f (n + 1)) =\n      -«expr ≫ » φ\n          («expr ≫ » (X.δ ⟨a + 1, nat.succ_lt_succ (Nat.lt_succ_iff.mpr (nat.le.intro hnaq.symm))⟩)\n            (X.σ ⟨a, Nat.lt_succ_iff.mpr (nat.le.intro hnaq.symm)⟩)) :=\n  by\n  have hnaq_shift : ∀ d : ℕ, n + d = a + d + q := by\n    intro d\n    rw [add_assoc, add_comm d, ← add_assoc, hnaq]\n  rw [Hσ, homotopy.null_homotopic_map'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl),\n    hσ'_eq hnaq (c_mk (n + 1) n rfl), hσ'_eq (hnaq_shift 1) (c_mk (n + 2) (n + 1) rfl)]\n  simp only [alternating_face_map_complex.obj_d_eq, eq_to_hom_refl, comp_id, comp_sum, sum_comp, comp_add]\n  simp only [comp_zsmul, zsmul_comp, ← assoc, ← mul_zsmul]\n  -- cleaning up the first sum\n  rw [← fin.sum_congr' _ (hnaq_shift 2).symm, fin.sum_trunc]\n  swap\n  · rintro ⟨k, hk⟩\n    suffices «expr ≫ » φ (X.δ (⟨a + 2 + k, by linarith⟩ : fin (n + 2))) = 0 by\n      simp only [this, Fin.natAdd_mk, Fin.cast_mk, zero_comp, smul_zero]\n    convert\n      v ⟨a + k + 1, by linarith⟩\n        (by\n          rw [Fin.val_mk]\n          linarith)\n    rw [nat.succ_eq_add_one]\n    linarith\n  -- cleaning up the second sum\n  rw [← fin.sum_congr' _ (hnaq_shift 3).symm, @fin.sum_trunc _ _ (a + 3)]\n  swap\n  · rintro ⟨k, hk⟩\n    rw [assoc, X.δ_comp_σ_of_gt', v.comp_δ_eq_zero_assoc, zero_comp, zsmul_zero]\n    · intro h\n      rw [Fin.pred_eq_iff_eq_succ, Fin.ext_iff] at h\n      dsimp at h\n      linarith\n    · dsimp\n      simp only [Fin.coe_pred, Fin.val_mk, succ_add_sub_one]\n      linarith\n    · dsimp\n      linarith\n  -- leaving out three specific terms\n  conv_lhs =>\n    congr\n    skip\n    rw [fin.sum_univ_cast_succ, fin.sum_univ_cast_succ]\n  rw [fin.sum_univ_cast_succ]\n  simp only [Fin.last, Fin.castLe_mk, Fin.coe_cast, Fin.cast_mk, Fin.coe_castLe, Fin.val_mk, Fin.castSucc_mk,\n    Fin.coe_castSucc]\n  /- the purpose of the following `simplif` is to create three subgoals in order\n      to finish the proof -/\n  have simplif :\n    ∀ a b c d e f : «expr ⟶ » Y (simplicial_object.at X (n + 1)),\n      b = f → d + e = 0 → c + a = 0 → a + b + (c + d + e) = f :=\n    by\n    intro a b c d e f h1 h2 h3\n    rw [add_assoc c d e, h2, add_zero, add_comm a b, add_assoc, add_comm a c, h3, add_zero, h1]\n  apply simplif\n  · -- b=f\n    rw [← pow_add, Odd.neg_one_pow, neg_smul, one_zsmul]\n    use a\n    linarith\n  · -- d+e = 0\n    rw [assoc, assoc, X.δ_comp_σ_self' (Fin.castSucc_mk _ _ _).symm, X.δ_comp_σ_succ' (Fin.succ_mk _ _ _).symm]\n    simp only [comp_id, pow_add _ (a + 1) 1, pow_one, mul_neg, mul_one, neg_smul, add_right_neg]\n  · -- c+a = 0\n    rw [← finset.sum_add_distrib]\n    apply finset.sum_eq_zero\n    rintro ⟨i, hi⟩ h₀\n    have hia : (⟨i, by linarith⟩ : fin (n + 2)) ≤ Fin.castSucc (⟨a, by linarith⟩ : fin (n + 1)) := by\n      simpa only [Fin.le_iff_val_le_val, Fin.val_mk, Fin.castSucc_mk, ← lt_succ_iff] using hi\n    simp only [Fin.val_mk, Fin.castLe_mk, Fin.castSucc_mk, Fin.succ_mk, assoc, Fin.cast_mk, ← δ_comp_σ_of_le X hia,\n      add_eq_zero_iff_eq_neg, ← neg_zsmul]\n    congr\n    ring\n#align comp_Hσ_eq comp_Hσ_eq\n\n"}