{"splitting_map_eq_id":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem splitting_map_eq_id (Δ : «expr ᵒᵖ» simplex_category) :\n    simplicial_object.splitting.map (Γ₀.obj K)\n        (fun n : ℕ =>\n          sigma.ι (Γ₀.obj.summand K (op (simplex_category.mk n))) (splitting.index_set.id (op (simplex_category.mk n))))\n        Δ =\n      («expr𝟙») _ :=\n  by\n  ext A\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `discrete_cases #[]\"\n  induction Δ using opposite.rec\n  induction' Δ with n\n  dsimp\n  simp only [colimit.ι_desc, cofan.mk_ι_app, comp_id, Γ₀.obj_map]\n  rw [Γ₀.obj.map_on_summand₀ K (simplicial_object.splitting.index_set.id A.1)\n      (show «expr ≫ » A.e ((«expr𝟙») _) = «expr ≫ » A.e.op.unop ((«expr𝟙») _) by rfl),\n    Γ₀.obj.termwise.map_mono_id, A.ext']\n  apply id_comp\n#align splitting_map_eq_id splitting_map_eq_id\n\n",
 "splitting_iso_hom_eq_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem splitting_iso_hom_eq_id (Δ : «expr ᵒᵖ» simplex_category) : ((splitting K).iso Δ).hom = («expr𝟙») _ :=\n  splitting_map_eq_id K Δ\n#align splitting_iso_hom_eq_id splitting_iso_hom_eq_id\n\n",
 "on_Γ₀_summand_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem higher_faces_vanish.on_Γ₀_summand_id (K : chain_complex C ℕ) (n : ℕ) :\n    higher_faces_vanish (n + 1)\n      ((Γ₀.splitting K).ι_summand (splitting.index_set.id (op (simplex_category.mk (n + 1))))) :=\n  by\n  intro j hj\n  have eq := Γ₀.obj.map_mono_on_summand_id K (simplex_category.δ j.succ)\n  rw [Γ₀.obj.termwise.map_mono_eq_zero K, zero_comp] at eq; rotate_left\n  · intro h\n    exact (nat.succ_ne_self n) (congr_arg simplex_category.len h)\n  · exact fun h => Fin.succ_ne_zero j (by simpa only [is_δ₀.iff] using h)\n  exact eq\n#align higher_faces_vanish.on_Γ₀_summand_id higher_faces_vanish.on_Γ₀_summand_id\n\n",
 "map_on_summand₀'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem map_on_summand₀' {Δ Δ' : «expr ᵒᵖ» simplex_category} (A : splitting.index_set Δ) (θ : «expr ⟶ » Δ Δ') :\n    «expr ≫ » (sigma.ι (summand K Δ) A) (map K θ) =\n      «expr ≫ » (termwise.map_mono K (image.ι («expr ≫ » θ.unop A.e))) (sigma.ι (summand K _) (A.pull θ)) :=\n  map_on_summand₀ K A (A.fac_pull θ)\n#align map_on_summand₀' map_on_summand₀'\n\n",
 "map_on_summand₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem map_on_summand₀ {Δ Δ' : «expr ᵒᵖ» simplex_category} (A : splitting.index_set Δ) {θ : «expr ⟶ » Δ Δ'}\n    {Δ'' : simplex_category} {e : «expr ⟶ » Δ'.unop Δ''} {i : «expr ⟶ » Δ'' A.1.unop} [Epi e] [Mono i]\n    (fac : «expr ≫ » e i = «expr ≫ » θ.unop A.e) :\n    «expr ≫ » (sigma.ι (summand K Δ) A) (map K θ) =\n      «expr ≫ » (termwise.map_mono K i) (sigma.ι (summand K Δ') (splitting.index_set.mk e)) :=\n  by\n  simp only [map, colimit.ι_desc, cofan.mk_ι_app]\n  have h := simplex_category.image_eq fac\n  subst h\n  congr\n  · exact simplex_category.image_ι_eq fac\n  · dsimp only [simplicial_object.splitting.index_set.pull]\n    congr\n    exact simplex_category.factor_thru_image_eq fac\n#align map_on_summand₀ map_on_summand₀\n\n",
 "map_on_summand'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem obj.map_on_summand' {Δ Δ' : «expr ᵒᵖ» simplex_category} (A : splitting.index_set Δ) (θ : «expr ⟶ » Δ Δ') :\n    «expr ≫ » ((splitting K).ι_summand A) ((obj K).map θ) =\n      «expr ≫ » (obj.termwise.map_mono K (image.ι («expr ≫ » θ.unop A.e))) ((splitting K).ι_summand (A.pull θ)) :=\n  by\n  apply obj.map_on_summand\n  apply image.fac\n#align obj.map_on_summand' obj.map_on_summand'\n\n",
 "map_on_summand":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem obj.map_on_summand {Δ Δ' : «expr ᵒᵖ» simplex_category} (A : splitting.index_set Δ) (θ : «expr ⟶ » Δ Δ')\n    {Δ'' : simplex_category} {e : «expr ⟶ » Δ'.unop Δ''} {i : «expr ⟶ » Δ'' A.1.unop} [Epi e] [Mono i]\n    (fac : «expr ≫ » e i = «expr ≫ » θ.unop A.e) :\n    «expr ≫ » ((Γ₀.splitting K).ι_summand A) ((Γ₀.obj K).map θ) =\n      «expr ≫ » (Γ₀.obj.termwise.map_mono K i) ((Γ₀.splitting K).ι_summand (splitting.index_set.mk e)) :=\n  by\n  dsimp only [simplicial_object.splitting.ι_summand, simplicial_object.splitting.ι_coprod]\n  simp only [assoc, Γ₀.splitting_iso_hom_eq_id, id_comp, comp_id]\n  exact Γ₀.obj.map_on_summand₀ K A fac\n#align obj.map_on_summand obj.map_on_summand\n\n",
 "map_mono_δ₀'":
 "theorem map_mono_δ₀' (hi : is_δ₀ i) : map_mono K i = K.d Δ.len Δ'.len :=\n  by\n  unfold map_mono\n  classical\n    rw [dif_neg, dif_pos hi]\n    rintro rfl\n    simpa only [self_eq_add_right, nat.one_ne_zero] using hi.1\n#align map_mono_δ₀' map_mono_δ₀'\n\n",
 "map_mono_δ₀":
 "@[simp]\ntheorem map_mono_δ₀ {n : ℕ} : map_mono K (δ (0 : fin (n + 2))) = K.d (n + 1) n :=\n  map_mono_δ₀' K _ (by rw [is_δ₀.iff])\n#align map_mono_δ₀ map_mono_δ₀\n\n",
 "map_mono_on_summand_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem obj.map_mono_on_summand_id {Δ Δ' : simplex_category} (i : «expr ⟶ » Δ' Δ) [Mono i] :\n    «expr ≫ » ((splitting K).ι_summand (splitting.index_set.id (op Δ))) ((obj K).map i.op) =\n      «expr ≫ » (obj.termwise.map_mono K i) ((splitting K).ι_summand (splitting.index_set.id (op Δ'))) :=\n  obj.map_on_summand K (splitting.index_set.id (op Δ)) i.op\n    (rfl : «expr ≫ » ((«expr𝟙») _) i = «expr ≫ » i ((«expr𝟙») _))\n#align obj.map_mono_on_summand_id obj.map_mono_on_summand_id\n\n",
 "map_mono_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem map_mono_naturality : «expr ≫ » (map_mono K i) (f.f Δ'.len) = «expr ≫ » (f.f Δ.len) (map_mono K' i) :=\n  by\n  unfold map_mono\n  split_ifs\n  · subst h\n    simp only [id_comp, eq_to_hom_refl, comp_id]\n  · rw [homological_complex.hom.comm]\n  · rw [zero_comp, comp_zero]\n#align map_mono_naturality map_mono_naturality\n\n",
 "map_mono_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem map_mono_id : map_mono K ((«expr𝟙») Δ) = («expr𝟙») _ :=\n  by\n  unfold map_mono\n  simp only [eq_self_iff_true, eq_to_hom_refl, dite_eq_ite, if_true]\n#align map_mono_id map_mono_id\n\n",
 "map_mono_eq_zero":
 "theorem map_mono_eq_zero (h₁ : Δ ≠ Δ') (h₂ : ¬is_δ₀ i) : map_mono K i = 0 :=\n  by\n  unfold map_mono\n  rw [ne.def] at h₁\n  split_ifs\n  rfl\n#align map_mono_eq_zero map_mono_eq_zero\n\n",
 "map_mono_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem map_mono_comp : «expr ≫ » (map_mono K i) (map_mono K i') = map_mono K («expr ≫ » i' i) :=\n  by\n  -- case where i : Δ' ⟶ Δ is the identity\n  by_cases h₁ : Δ = Δ'\n  · subst h₁\n    simp only [simplex_category.eq_id_of_mono i, comp_id, id_comp, map_mono_id K, eq_to_hom_refl]\n  -- case where i' : Δ'' ⟶ Δ' is the identity\n  by_cases h₂ : Δ' = Δ''\n  · subst h₂\n    simp only [simplex_category.eq_id_of_mono i', comp_id, id_comp, map_mono_id K, eq_to_hom_refl]\n  -- then the RHS is always zero\n  obtain ⟨k, hk⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i h₁)\n  obtain ⟨k', hk'⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i' h₂)\n  have eq : Δ.len = Δ''.len + (k + k' + 2) := by linarith\n  rw [map_mono_eq_zero K («expr ≫ » i' i) _ _]; rotate_left\n  · by_contra\n    simpa only [self_eq_add_right, h] using eq\n  · by_contra\n    simp only [h.1, add_right_inj] at eq\n    linarith\n  -- in all cases, the LHS is also zero, either by definition, or because d ≫ d = 0\n  by_cases h₃ : is_δ₀ i\n  · by_cases h₄ : is_δ₀ i'\n    · rw [map_mono_δ₀' K i h₃, map_mono_δ₀' K i' h₄, homological_complex.d_comp_d]\n    · simp only [map_mono_eq_zero K i' h₂ h₄, comp_zero]\n  · simp only [map_mono_eq_zero K i h₁ h₃, zero_comp]\n#align map_mono_comp map_mono_comp\n\n",
 "map_epi_on_summand_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem obj.map_epi_on_summand_id {Δ Δ' : simplex_category} (e : «expr ⟶ » Δ' Δ) [Epi e] :\n    «expr ≫ » ((Γ₀.splitting K).ι_summand (splitting.index_set.id (op Δ))) ((Γ₀.obj K).map e.op) =\n      (Γ₀.splitting K).ι_summand (splitting.index_set.mk e) :=\n  by\n  simpa only [Γ₀.obj.map_on_summand K (splitting.index_set.id (op Δ)) e.op\n      (rfl : «expr ≫ » e ((«expr𝟙») Δ) = «expr ≫ » e ((«expr𝟙») Δ)),\n    Γ₀.obj.termwise.map_mono_id] using id_comp _\n#align obj.map_epi_on_summand_id obj.map_epi_on_summand_id\n\n",
 "iff":
 "/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\ntheorem iff {j : ℕ} {i : fin (j + 2)} : is_δ₀ (simplex_category.δ i) ↔ i = 0 :=\n  by\n  constructor\n  · rintro ⟨h₁, h₂⟩\n    by_contra\n    exact h₂ (Fin.succAbove_ne_zero_zero h)\n  · rintro rfl\n    exact ⟨rfl, Fin.succ_ne_zero _⟩\n#align iff iff\n\n",
 "eq_δ₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem eq_δ₀ {n : ℕ} {i : «expr ⟶ » (simplex_category.mk n) (simplex_category.mk (n + 1))} [Mono i] (hi : is_δ₀ i) :\n    i = simplex_category.δ 0 := by\n  obtain ⟨j, rfl⟩ := simplex_category.eq_δ_of_mono i\n  rw [iff] at hi\n  rw [hi]\n#align eq_δ₀ eq_δ₀\n\n",
 "P_infty_on_Γ₀_splitting_summand_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `alternating_face_map_complex -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp, reassoc.1]\ntheorem P_infty_on_Γ₀_splitting_summand_eq_self (K : chain_complex C ℕ) {n : ℕ} :\n    «expr ≫ » ((Γ₀.splitting K).ι_summand (splitting.index_set.id (op (simplex_category.mk n))))\n        ((P_infty : «expr ⟶ » (alternating_face_map_complex (Γ₀.obj K)) _).f n) =\n      (Γ₀.splitting K).ι_summand (splitting.index_set.id (op (simplex_category.mk n))) :=\n  by\n  rw [P_infty_f]\n  cases n\n  · simpa only [P_f_0_eq] using comp_id _\n  · exact (higher_faces_vanish.on_Γ₀_summand_id K n).comp_P_eq_self\n#align P_infty_on_Γ₀_splitting_summand_eq_self P_infty_on_Γ₀_splitting_summand_eq_self\n\n"}