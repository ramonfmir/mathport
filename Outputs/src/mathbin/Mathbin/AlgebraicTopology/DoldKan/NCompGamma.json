{"Œì‚ÇÄ_obj_termwise_map_mono_comp_P_infty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n@[reassoc.1]\ntheorem Œì‚ÇÄ_obj_termwise_map_mono_comp_P_infty (X : SimplicialObject C) {Œî Œî' : SimplexCategory} (i : ¬´expr ‚ü∂ ¬ª Œî Œî')\n    [Mono i] :\n    ¬´expr ‚â´ ¬ª (Œì‚ÇÄ.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i) (PInfty.f Œî.len) =\n      ¬´expr ‚â´ ¬ª (PInfty.f Œî'.len) (X.map i.op) :=\n  by\n  induction' Œî using SimplexCategory.rec with n\n  induction' Œî' using SimplexCategory.rec with n'\n  dsimp\n  -- We start with the case `i` is an identity\n  by_cases n = n'\n  ¬∑ subst h\n    simp only [SimplexCategory.eq_id_of_mono i, Œì‚ÇÄ.obj.termwise.map_mono_id, op_id, X.map_id]\n    dsimp\n    simp only [id_comp, comp_id]\n  by_cases hi : is_Œ¥‚ÇÄ i\n  -- The case `i = Œ¥ 0`\n  ¬∑ have h' : n' = n + 1 := hi.left\n    subst h'\n    simp only [Œì‚ÇÄ.obj.termwise.map_mono_Œ¥‚ÇÄ' _ i hi]\n    dsimp\n    rw [‚Üê P_infty.comm' _ n rfl, alternating_face_map_complex.obj_d_eq]\n    simp only [eq_self_iff_true, id_comp, if_true, preadditive.comp_sum]\n    rw [Finset.sum_eq_single (0 : Fin (n + 2))]\n    rotate_left\n    ¬∑ intro b hb hb'\n      rw [preadditive.comp_zsmul]\n      erw [P_infty_comp_map_mono_eq_zero X (SimplexCategory.Œ¥ b) h\n          (by\n            rw [is_Œ¥‚ÇÄ.iff]\n            exact hb'),\n        zsmul_zero]\n    ¬∑ simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]\n    ¬∑ simpa only [hi.eq_Œ¥‚ÇÄ, Fin.val_zero, pow_zero, one_zsmul]\n  -- The case `i ‚â† Œ¥ 0`\n  ¬∑ rw [Œì‚ÇÄ.obj.termwise.map_mono_eq_zero _ i _ hi, zero_comp]\n    swap\n    ¬∑ by_contra h'\n      exact h (congr_arg SimplexCategory.len h'.symm)\n    rw [P_infty_comp_map_mono_eq_zero]\n    ¬∑ exact h\n    ¬∑ by_contra h'\n      exact hi h'\n#align Œì‚ÇÄ_obj_termwise_map_mono_comp_P_infty Œì‚ÇÄ_obj_termwise_map_mono_comp_P_infty\n\n",
 "nat_trans_app_f_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\ntheorem nat_trans_app_f_app (P : Karoubi (SimplicialObject C)) :\n    Œì‚ÇÇN‚ÇÇ.natTrans.app P =\n      ¬´expr ‚â´ ¬ª ((¬´expr ‚ãô ¬ª N‚ÇÇ Œì‚ÇÇ).map P.decomp_id_i)\n        (¬´expr ‚â´ ¬ª ((¬´expr ‚â´ ¬ª compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ.hom Œì‚ÇÇN‚ÇÅ.natTrans).app P.X) P.decomp_id_p) :=\n  whiskeringLeft_obj_preimage_app (¬´expr ‚â´ ¬ª compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ.hom Œì‚ÇÇN‚ÇÅ.natTrans) P\n#align nat_trans_app_f_app nat_trans_app_f_app\n\n",
 "identity_N‚ÇÇ_objectwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\ntheorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :\n    ¬´expr ‚â´ ¬ª (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P)) (N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P)) = (¬´exprùüô¬ª) (N‚ÇÇ.obj P) :=\n  by\n  ext n\n  have eq‚ÇÅ :\n    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P)).f.f n =\n      ¬´expr ‚â´ ¬ª (P_infty.f n)\n        (¬´expr ‚â´ ¬ª (P.p.app (op (simplex_category.mk n)))\n          ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).Œπ_summand (splitting.index_set.id (op (simplex_category.mk n))))) :=\n    by simp only [N‚ÇÇŒì‚ÇÇ_inv_app_f_f, N‚ÇÇ_obj_p_f, assoc]\n  have eq‚ÇÇ :\n    ¬´expr ‚â´ ¬ª ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).Œπ_summand (splitting.index_set.id (op (simplex_category.mk n))))\n        ((N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.nat_trans.app P)).f.f n) =\n      ¬´expr ‚â´ ¬ª (P_infty.f n) (P.p.app (op (simplex_category.mk n))) :=\n    by\n    dsimp [N‚ÇÇ]\n    simp only [Œì‚ÇÇN‚ÇÇ.nat_trans_app_f_app, P_infty_on_Œì‚ÇÄ_splitting_summand_eq_self_assoc, functor.comp_map,\n      compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_hom, nat_trans.comp_app, eq_to_hom_app, assoc, karoubi.comp_f, karoubi.eq_to_hom_f,\n      eq_to_hom_refl, comp_id, karoubi.decomp_id_p_f, karoubi.comp_p_assoc, Œì‚ÇÇ_map_f_app, N‚ÇÇ_map_f_f,\n      karoubi.decomp_id_i_f, Œì‚ÇÇN‚ÇÅ.nat_trans_app_f_app]\n    erw [splitting.Œπ_desc_assoc, assoc, assoc, splitting.Œπ_desc_assoc]\n    dsimp [splitting.index_set.id, splitting.index_set.e]\n    simp only [assoc, nat_trans.naturality, P_infty_f_naturality_assoc, app_idem_assoc, P_infty_f_idem_assoc]\n    erw [P.X.map_id, comp_id]\n  simp only [karoubi.comp_f, HomologicalComplex.comp_f, karoubi.id_eq, N‚ÇÇ_obj_p_f, assoc, eq‚ÇÅ, eq‚ÇÇ,\n    P_infty_f_naturality_assoc, app_idem, P_infty_f_idem_assoc]\n#align identity_N‚ÇÇ_objectwise identity_N‚ÇÇ_objectwise\n\n",
 "identity_N‚ÇÇ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ó´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚•§ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ó´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùüô¬ª -/\ntheorem identity_N‚ÇÇ :\n    (¬´expr ‚â´ ¬ª (¬´expr ‚ó´ ¬ª ((¬´exprùüô¬ª) (N‚ÇÇ : ¬´expr ‚•§ ¬ª (Karoubi (SimplicialObject C)) _)) N‚ÇÇŒì‚ÇÇ.inv)\n          (¬´expr ‚ó´ ¬ª Œì‚ÇÇN‚ÇÇ.natTrans ((¬´exprùüô¬ª) N‚ÇÇ)) :\n        ¬´expr ‚ü∂ ¬ª N‚ÇÇ N‚ÇÇ) =\n      (¬´exprùüô¬ª) N‚ÇÇ :=\n  by\n  ext P : 2\n  dsimp\n  rw [Œì‚ÇÇ.map_id, N‚ÇÇ.map_id, comp_id, id_comp, identity_N‚ÇÇ_objectwise P]\n#align identity_N‚ÇÇ identity_N‚ÇÇ\n\n",
 "compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_nat_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ãô ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´exprùü≠¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\ntheorem compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_nat_trans (X : SimplicialObject C) :\n    Œì‚ÇÇN‚ÇÅ.natTrans.app X = ¬´expr ‚â´ ¬ª (compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ.app X).inv (Œì‚ÇÇN‚ÇÇ.natTrans.app ((toKaroubi _).obj X)) :=\n  by\n  rw [‚Üê cancel_epi (compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ.app X).hom, iso.hom_inv_id_assoc]\n  exact\n    congr_app\n      (((whiskering_left _ _ _).obj _).image_preimage\n          (¬´expr ‚â´ ¬ª compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ.hom Œì‚ÇÇN‚ÇÅ.nat_trans :\n            ¬´expr ‚ü∂ ¬ª _ (¬´expr ‚ãô ¬ª (to_karoubi _) ((¬´exprùü≠¬ª) _)))).symm\n      X\n#align compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_nat_trans compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_nat_trans\n\n",
 "P_infty_comp_map_mono_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚ü∂ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚â´ ¬ª -/\n/-\nCopyright (c) 2022 Jo√´l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo√´l Riou\n-/\ntheorem P_infty_comp_map_mono_eq_zero (X : SimplicialObject C) {n : ‚Ñï} {Œî' : SimplexCategory}\n    (i : ¬´expr ‚ü∂ ¬ª Œî' (simplex_category.mk n)) [hi : Mono i] (h‚ÇÅ : Œî'.len ‚â† n) (h‚ÇÇ : ¬¨IsŒ¥‚ÇÄ i) :\n    ¬´expr ‚â´ ¬ª (PInfty.f n) (X.map i.op) = 0 :=\n  by\n  induction' Œî' using SimplexCategory.rec with m\n  obtain ‚ü®k, hk‚ü© :=\n    Nat.exists_eq_add_of_lt\n      (len_lt_of_mono i fun h => by\n        rw [‚Üê h] at h‚ÇÅ\n        exact h‚ÇÅ rfl)\n  simp only [len_mk] at hk\n  cases k\n  ¬∑ change n = m + 1 at hk\n    subst hk\n    obtain ‚ü®j, rfl‚ü© := eq_Œ¥_of_mono i\n    rw [is_Œ¥‚ÇÄ.iff] at h‚ÇÇ\n    have h‚ÇÉ : 1 ‚â§ (j : ‚Ñï) := by\n      by_contra\n      exact h‚ÇÇ (by simpa only [Fin.ext_iff, not_le, Nat.lt_one_iff] using h)\n    exact (higher_faces_vanish.of_P (m + 1) m).comp_Œ¥_eq_zero j h‚ÇÇ (by linarith)\n  ¬∑ simp only [nat.succ_eq_add_one, ‚Üê add_assoc] at hk\n    clear h‚ÇÇ hi\n    subst hk\n    obtain ‚ü®j‚ÇÅ, i, rfl‚ü© :=\n      eq_comp_Œ¥_of_not_surjective i fun h =>\n        by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        linarith\n    obtain ‚ü®j‚ÇÇ, i, rfl‚ü© :=\n      eq_comp_Œ¥_of_not_surjective i fun h =>\n        by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        linarith\n    by_cases hj‚ÇÅ : j‚ÇÅ = 0\n    ¬∑ subst hj‚ÇÅ\n      rw [assoc, ‚Üê SimplexCategory.Œ¥_comp_Œ¥'' (Fin.zero_le _)]\n      simp only [op_comp, X.map_comp, assoc, P_infty_f]\n      erw [(higher_faces_vanish.of_P _ _).comp_Œ¥_eq_zero_assoc _ j‚ÇÇ.succ_ne_zero, zero_comp]\n      rw [Fin.val_succ]\n      linarith\n    ¬∑ simp only [op_comp, X.map_comp, assoc, P_infty_f]\n      erw [(higher_faces_vanish.of_P _ _).comp_Œ¥_eq_zero_assoc _ hj‚ÇÅ, zero_comp]\n      by_contra\n      exact\n        hj‚ÇÅ\n          (by\n            simp only [Fin.ext_iff, Fin.val_zero]\n            linarith)\n#align P_infty_comp_map_mono_eq_zero P_infty_comp_map_mono_eq_zero\n\n"}