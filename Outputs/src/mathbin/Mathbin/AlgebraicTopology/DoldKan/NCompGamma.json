{"Γ₀_obj_termwise_map_mono_comp_P_infty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem Γ₀_obj_termwise_map_mono_comp_P_infty (X : SimplicialObject C) {Δ Δ' : SimplexCategory} (i : «expr ⟶ » Δ Δ')\n    [Mono i] :\n    «expr ≫ » (Γ₀.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i) (PInfty.f Δ.len) =\n      «expr ≫ » (PInfty.f Δ'.len) (X.map i.op) :=\n  by\n  induction' Δ using SimplexCategory.rec with n\n  induction' Δ' using SimplexCategory.rec with n'\n  dsimp\n  -- We start with the case `i` is an identity\n  by_cases n = n'\n  · subst h\n    simp only [SimplexCategory.eq_id_of_mono i, Γ₀.obj.termwise.map_mono_id, op_id, X.map_id]\n    dsimp\n    simp only [id_comp, comp_id]\n  by_cases hi : is_δ₀ i\n  -- The case `i = δ 0`\n  · have h' : n' = n + 1 := hi.left\n    subst h'\n    simp only [Γ₀.obj.termwise.map_mono_δ₀' _ i hi]\n    dsimp\n    rw [← P_infty.comm' _ n rfl, alternating_face_map_complex.obj_d_eq]\n    simp only [eq_self_iff_true, id_comp, if_true, preadditive.comp_sum]\n    rw [Finset.sum_eq_single (0 : Fin (n + 2))]\n    rotate_left\n    · intro b hb hb'\n      rw [preadditive.comp_zsmul]\n      erw [P_infty_comp_map_mono_eq_zero X (SimplexCategory.δ b) h\n          (by\n            rw [is_δ₀.iff]\n            exact hb'),\n        zsmul_zero]\n    · simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff]\n    · simpa only [hi.eq_δ₀, Fin.val_zero, pow_zero, one_zsmul]\n  -- The case `i ≠ δ 0`\n  · rw [Γ₀.obj.termwise.map_mono_eq_zero _ i _ hi, zero_comp]\n    swap\n    · by_contra h'\n      exact h (congr_arg SimplexCategory.len h'.symm)\n    rw [P_infty_comp_map_mono_eq_zero]\n    · exact h\n    · by_contra h'\n      exact hi h'\n#align Γ₀_obj_termwise_map_mono_comp_P_infty Γ₀_obj_termwise_map_mono_comp_P_infty\n\n",
 "nat_trans_app_f_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem nat_trans_app_f_app (P : Karoubi (SimplicialObject C)) :\n    Γ₂N₂.natTrans.app P =\n      «expr ≫ » ((«expr ⋙ » N₂ Γ₂).map P.decomp_id_i)\n        («expr ≫ » ((«expr ≫ » compatibility_Γ₂N₁_Γ₂N₂.hom Γ₂N₁.natTrans).app P.X) P.decomp_id_p) :=\n  whiskeringLeft_obj_preimage_app («expr ≫ » compatibility_Γ₂N₁_Γ₂N₂.hom Γ₂N₁.natTrans) P\n#align nat_trans_app_f_app nat_trans_app_f_app\n\n",
 "identity_N₂_objectwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem identity_N₂_objectwise (P : Karoubi (SimplicialObject C)) :\n    «expr ≫ » (N₂Γ₂.inv.app (N₂.obj P)) (N₂.map (Γ₂N₂.natTrans.app P)) = («expr𝟙») (N₂.obj P) :=\n  by\n  ext n\n  have eq₁ :\n    (N₂Γ₂.inv.app (N₂.obj P)).f.f n =\n      «expr ≫ » (P_infty.f n)\n        («expr ≫ » (P.p.app (op (simplex_category.mk n)))\n          ((Γ₀.splitting (N₂.obj P).X).ι_summand (splitting.index_set.id (op (simplex_category.mk n))))) :=\n    by simp only [N₂Γ₂_inv_app_f_f, N₂_obj_p_f, assoc]\n  have eq₂ :\n    «expr ≫ » ((Γ₀.splitting (N₂.obj P).X).ι_summand (splitting.index_set.id (op (simplex_category.mk n))))\n        ((N₂.map (Γ₂N₂.nat_trans.app P)).f.f n) =\n      «expr ≫ » (P_infty.f n) (P.p.app (op (simplex_category.mk n))) :=\n    by\n    dsimp [N₂]\n    simp only [Γ₂N₂.nat_trans_app_f_app, P_infty_on_Γ₀_splitting_summand_eq_self_assoc, functor.comp_map,\n      compatibility_Γ₂N₁_Γ₂N₂_hom, nat_trans.comp_app, eq_to_hom_app, assoc, karoubi.comp_f, karoubi.eq_to_hom_f,\n      eq_to_hom_refl, comp_id, karoubi.decomp_id_p_f, karoubi.comp_p_assoc, Γ₂_map_f_app, N₂_map_f_f,\n      karoubi.decomp_id_i_f, Γ₂N₁.nat_trans_app_f_app]\n    erw [splitting.ι_desc_assoc, assoc, assoc, splitting.ι_desc_assoc]\n    dsimp [splitting.index_set.id, splitting.index_set.e]\n    simp only [assoc, nat_trans.naturality, P_infty_f_naturality_assoc, app_idem_assoc, P_infty_f_idem_assoc]\n    erw [P.X.map_id, comp_id]\n  simp only [karoubi.comp_f, HomologicalComplex.comp_f, karoubi.id_eq, N₂_obj_p_f, assoc, eq₁, eq₂,\n    P_infty_f_naturality_assoc, app_idem, P_infty_f_idem_assoc]\n#align identity_N₂_objectwise identity_N₂_objectwise\n\n",
 "identity_N₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ◫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ◫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem identity_N₂ :\n    («expr ≫ » («expr ◫ » ((«expr𝟙») (N₂ : «expr ⥤ » (Karoubi (SimplicialObject C)) _)) N₂Γ₂.inv)\n          («expr ◫ » Γ₂N₂.natTrans ((«expr𝟙») N₂)) :\n        «expr ⟶ » N₂ N₂) =\n      («expr𝟙») N₂ :=\n  by\n  ext P : 2\n  dsimp\n  rw [Γ₂.map_id, N₂.map_id, comp_id, id_comp, identity_N₂_objectwise P]\n#align identity_N₂ identity_N₂\n\n",
 "compatibility_Γ₂N₁_Γ₂N₂_nat_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem compatibility_Γ₂N₁_Γ₂N₂_nat_trans (X : SimplicialObject C) :\n    Γ₂N₁.natTrans.app X = «expr ≫ » (compatibility_Γ₂N₁_Γ₂N₂.app X).inv (Γ₂N₂.natTrans.app ((toKaroubi _).obj X)) :=\n  by\n  rw [← cancel_epi (compatibility_Γ₂N₁_Γ₂N₂.app X).hom, iso.hom_inv_id_assoc]\n  exact\n    congr_app\n      (((whiskering_left _ _ _).obj _).image_preimage\n          («expr ≫ » compatibility_Γ₂N₁_Γ₂N₂.hom Γ₂N₁.nat_trans :\n            «expr ⟶ » _ («expr ⋙ » (to_karoubi _) ((«expr𝟭») _)))).symm\n      X\n#align compatibility_Γ₂N₁_Γ₂N₂_nat_trans compatibility_Γ₂N₁_Γ₂N₂_nat_trans\n\n",
 "P_infty_comp_map_mono_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\ntheorem P_infty_comp_map_mono_eq_zero (X : SimplicialObject C) {n : ℕ} {Δ' : SimplexCategory}\n    (i : «expr ⟶ » Δ' (simplex_category.mk n)) [hi : Mono i] (h₁ : Δ'.len ≠ n) (h₂ : ¬Isδ₀ i) :\n    «expr ≫ » (PInfty.f n) (X.map i.op) = 0 :=\n  by\n  induction' Δ' using SimplexCategory.rec with m\n  obtain ⟨k, hk⟩ :=\n    Nat.exists_eq_add_of_lt\n      (len_lt_of_mono i fun h => by\n        rw [← h] at h₁\n        exact h₁ rfl)\n  simp only [len_mk] at hk\n  cases k\n  · change n = m + 1 at hk\n    subst hk\n    obtain ⟨j, rfl⟩ := eq_δ_of_mono i\n    rw [is_δ₀.iff] at h₂\n    have h₃ : 1 ≤ (j : ℕ) := by\n      by_contra\n      exact h₂ (by simpa only [Fin.ext_iff, not_le, Nat.lt_one_iff] using h)\n    exact (higher_faces_vanish.of_P (m + 1) m).comp_δ_eq_zero j h₂ (by linarith)\n  · simp only [nat.succ_eq_add_one, ← add_assoc] at hk\n    clear h₂ hi\n    subst hk\n    obtain ⟨j₁, i, rfl⟩ :=\n      eq_comp_δ_of_not_surjective i fun h =>\n        by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        linarith\n    obtain ⟨j₂, i, rfl⟩ :=\n      eq_comp_δ_of_not_surjective i fun h =>\n        by\n        have h' := len_le_of_epi (SimplexCategory.epi_iff_surjective.2 h)\n        dsimp at h'\n        linarith\n    by_cases hj₁ : j₁ = 0\n    · subst hj₁\n      rw [assoc, ← SimplexCategory.δ_comp_δ'' (Fin.zero_le _)]\n      simp only [op_comp, X.map_comp, assoc, P_infty_f]\n      erw [(higher_faces_vanish.of_P _ _).comp_δ_eq_zero_assoc _ j₂.succ_ne_zero, zero_comp]\n      rw [Fin.val_succ]\n      linarith\n    · simp only [op_comp, X.map_comp, assoc, P_infty_f]\n      erw [(higher_faces_vanish.of_P _ _).comp_δ_eq_zero_assoc _ hj₁, zero_comp]\n      by_contra\n      exact\n        hj₁\n          (by\n            simp only [Fin.ext_iff, Fin.val_zero]\n            linarith)\n#align P_infty_comp_map_mono_eq_zero P_infty_comp_map_mono_eq_zero\n\n"}