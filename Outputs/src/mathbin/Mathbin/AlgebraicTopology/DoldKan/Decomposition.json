{"pre_comp_φ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp]\ntheorem pre_comp_φ : (f.pre_comp g).φ = «expr ≫ » (g.app (op (simplex_category.mk (n + 1)))) f.φ :=\n  by\n  unfold φ pre_comp\n  simp only [P_infty_f, comp_add]\n  congr 1\n  · simp only [P_f_naturality_assoc]\n  · simp only [comp_sum, P_f_naturality_assoc, simplicial_object.δ_naturality_assoc]\n#align pre_comp_φ pre_comp_φ\n\n",
 "post_comp_φ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem post_comp_φ : (f.post_comp h).φ = «expr ≫ » f.φ h :=\n  by\n  unfold φ post_comp\n  simp only [add_comp, sum_comp, assoc]\n#align post_comp_φ post_comp_φ\n\n",
 "id_φ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_φ : (id X n).φ = («expr𝟙») _ :=\n  by\n  simp only [← P_add_Q_f (n + 1) (n + 1), φ]\n  congr 1\n  · simp only [id, P_infty_f, P_f_idem]\n  · convert (decomposition_Q n (n + 1)).symm\n    ext i\n    simpa only [finset.mem_univ, Finset.mem_filter, true_and_iff, true_iff_iff] using Fin.is_lt i\n#align id_φ id_φ\n\n",
 "decomposition_Q":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\n/-- In each positive degree, this lemma decomposes the idempotent endomorphism\n`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.\nAs `Q q` is the complement projection to `P q`, this implies that in the case of\nsimplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as\n$x = x' + \\sum (i=0}^{q-1} σ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and\nthe $y_i$ are in degree $n$. -/\ntheorem decomposition_Q (n q : ℕ) :\n    ((Q q).f (n + 1) : «expr ⟶ » (simplicial_object.at X (n + 1)) (simplicial_object.at X (n + 1))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.filter (fun i : fin (n + 1) => (i : ℕ) < q) finset.univ)\n        («expr ≫ » ((P i).f (n + 1)) («expr ≫ » (X.δ i.rev.succ) (X.σ i.rev))) :=\n  by\n  induction' q with q hq\n  · simp only [Q_eq_zero, homological_complex.zero_f_apply, nat.not_lt_zero, Finset.filter_false, finset.sum_empty]\n  · by_cases hqn : q + 1 ≤ n + 1\n    swap\n    · rw [Q_is_eventually_constant (show n + 1 ≤ q by linarith), hq]\n      congr\n      ext\n      have hx := x.is_lt\n      simp only [nat.succ_eq_add_one]\n      constructor <;> intro h <;> linarith\n    · cases' nat.le.dest (nat.succ_le_succ_iff.mp hqn) with a ha\n      rw [Q_eq, homological_complex.sub_f_apply, homological_complex.comp_f, hq]\n      symm\n      conv_rhs => rw [sub_eq_add_neg, add_comm]\n      let q' : fin (n + 1) := ⟨q, nat.succ_le_iff.mp hqn⟩\n      convert finset.sum_insert (_ : q' ∉ _)\n      · ext i\n        simp only [Finset.mem_insert, Finset.mem_filter, finset.mem_univ, true_and_iff, Nat.lt_succ_iff_lt_or_eq,\n          Fin.ext_iff]\n        tauto\n      · have hnaq' : n = a + q := by linarith\n        simpa only [Fin.val_mk, (higher_faces_vanish.of_P q n).comp_Hσ_eq hnaq', q'.rev_eq hnaq', neg_neg]\n      · simp only [Finset.mem_filter, Fin.val_mk, lt_self_iff_false, and_false_iff, not_false_iff]\n#align decomposition_Q decomposition_Q\n\n"}