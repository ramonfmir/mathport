{"pre_comp_Ï†":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp]\ntheorem pre_comp_Ï† : (f.pre_comp g).Ï† = Â«expr â‰« Â» (g.app (op (simplex_category.mk (n + 1)))) f.Ï† :=\n  by\n  unfold Ï† pre_comp\n  simp only [P_infty_f, comp_add]\n  congr 1\n  Â· simp only [P_f_naturality_assoc]\n  Â· simp only [comp_sum, P_f_naturality_assoc, simplicial_object.Î´_naturality_assoc]\n#align pre_comp_Ï† pre_comp_Ï†\n\n",
 "post_comp_Ï†":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem post_comp_Ï† : (f.post_comp h).Ï† = Â«expr â‰« Â» f.Ï† h :=\n  by\n  unfold Ï† post_comp\n  simp only [add_comp, sum_comp, assoc]\n#align post_comp_Ï† post_comp_Ï†\n\n",
 "id_Ï†":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n@[simp]\ntheorem id_Ï† : (id X n).Ï† = (Â«exprðŸ™Â») _ :=\n  by\n  simp only [â† P_add_Q_f (n + 1) (n + 1), Ï†]\n  congr 1\n  Â· simp only [id, P_infty_f, P_f_idem]\n  Â· convert (decomposition_Q n (n + 1)).symm\n    ext i\n    simpa only [finset.mem_univ, Finset.mem_filter, true_and_iff, true_iff_iff] using Fin.is_lt i\n#align id_Ï† id_Ï†\n\n",
 "decomposition_Q":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2022 JoÃ«l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: JoÃ«l Riou\n-/\n/-- In each positive degree, this lemma decomposes the idempotent endomorphism\n`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.\nAs `Q q` is the complement projection to `P q`, this implies that in the case of\nsimplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as\n$x = x' + \\sum (i=0}^{q-1} Ïƒ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and\nthe $y_i$ are in degree $n$. -/\ntheorem decomposition_Q (n q : â„•) :\n    ((Q q).f (n + 1) : Â«expr âŸ¶ Â» (simplicial_object.at X (n + 1)) (simplicial_object.at X (n + 1))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.filter (fun i : fin (n + 1) => (i : â„•) < q) finset.univ)\n        (Â«expr â‰« Â» ((P i).f (n + 1)) (Â«expr â‰« Â» (X.Î´ i.rev.succ) (X.Ïƒ i.rev))) :=\n  by\n  induction' q with q hq\n  Â· simp only [Q_eq_zero, homological_complex.zero_f_apply, nat.not_lt_zero, Finset.filter_false, finset.sum_empty]\n  Â· by_cases hqn : q + 1 â‰¤ n + 1\n    swap\n    Â· rw [Q_is_eventually_constant (show n + 1 â‰¤ q by linarith), hq]\n      congr\n      ext\n      have hx := x.is_lt\n      simp only [nat.succ_eq_add_one]\n      constructor <;> intro h <;> linarith\n    Â· cases' nat.le.dest (nat.succ_le_succ_iff.mp hqn) with a ha\n      rw [Q_eq, homological_complex.sub_f_apply, homological_complex.comp_f, hq]\n      symm\n      conv_rhs => rw [sub_eq_add_neg, add_comm]\n      let q' : fin (n + 1) := âŸ¨q, nat.succ_le_iff.mp hqnâŸ©\n      convert finset.sum_insert (_ : q' âˆ‰ _)\n      Â· ext i\n        simp only [Finset.mem_insert, Finset.mem_filter, finset.mem_univ, true_and_iff, Nat.lt_succ_iff_lt_or_eq,\n          Fin.ext_iff]\n        tauto\n      Â· have hnaq' : n = a + q := by linarith\n        simpa only [Fin.val_mk, (higher_faces_vanish.of_P q n).comp_HÏƒ_eq hnaq', q'.rev_eq hnaq', neg_neg]\n      Â· simp only [Finset.mem_filter, Fin.val_mk, lt_self_iff_false, and_false_iff, not_false_iff]\n#align decomposition_Q decomposition_Q\n\n"}