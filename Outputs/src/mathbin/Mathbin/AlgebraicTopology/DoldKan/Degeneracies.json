{"Ïƒ_comp_P_infty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp, reassoc.1]\ntheorem Ïƒ_comp_P_infty (X : simplicial_object C) {n : â„•} (i : fin (n + 1)) :\n    Â«expr â‰« Â» (X.Ïƒ i) (P_infty.f (n + 1)) = 0 :=\n  by\n  rw [P_infty_f, Ïƒ_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\n#align Ïƒ_comp_P_infty Ïƒ_comp_P_infty\n\n",
 "Ïƒ_comp_P_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprðŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem Ïƒ_comp_P_eq_zero (X : simplicial_object C) {n q : â„•} (i : fin (n + 1)) (hi : n + 1 â‰¤ i + q) :\n    Â«expr â‰« Â» (X.Ïƒ i) ((P q).f (n + 1)) = 0 :=\n  by\n  induction' q with q hq generalizing i hi\n  Â· exfalso\n    have h := Fin.is_lt i\n    linarith\n  Â· by_cases n + 1 â‰¤ (i : â„•) + q\n    Â· unfold P\n      simp only [homological_complex.comp_f, â† assoc]\n      rw [hq i h, zero_comp]\n    Â· have hi' : n = (i : â„•) + q := by\n        cases' le_iff_exists_add.mp hi with j hj\n        rw [â† Nat.lt_succ_iff, nat.succ_eq_add_one, add_assoc, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [â† add_left_inj 1, add_assoc, hj, self_eq_add_right, h]\n      cases n\n      Â· fin_cases i\n        rw [show q = 0 by linarith]\n        unfold P\n        simp only [id_comp, homological_complex.add_f_apply, comp_add, homological_complex.id_f, HÏƒ,\n          homotopy.null_homotopic_map'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl), alternating_face_map_complex.obj_d_eq]\n        erw [hÏƒ'_eq' (zero_add 0).symm, hÏƒ'_eq' (add_zero 1).symm, comp_id, fin.sum_univ_two, fin.sum_univ_succ,\n          fin.sum_univ_two]\n        simp only [pow_zero, pow_one, pow_two, Fin.val_zero, Fin.val_one, Fin.val_two, one_zsmul, neg_zsmul,\n          Fin.mk_zero, Fin.mk_one, Fin.val_succ, pow_add, one_mul, neg_mul, neg_neg, Fin.succ_zero_eq_one,\n          Fin.succ_one_eq_two, comp_neg, neg_comp, add_comp, comp_add]\n        erw [simplicial_object.Î´_comp_Ïƒ_self, simplicial_object.Î´_comp_Ïƒ_self_assoc, simplicial_object.Î´_comp_Ïƒ_succ,\n          comp_id, simplicial_object.Î´_comp_Ïƒ_of_le X (show (0 : fin 2) â‰¤ Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          simplicial_object.Î´_comp_Ïƒ_self_assoc, simplicial_object.Î´_comp_Ïƒ_succ_assoc]\n        abel\n      Â· rw [â† id_comp (X.Ïƒ i), â† (P_add_Q_f q n.succ : _ = (Â«exprðŸ™Â») (X.obj _)), add_comp, add_comp]\n        have v : higher_faces_vanish q (Â«expr â‰« Â» ((P q).f n.succ) (X.Ïƒ i)) := (higher_faces_vanish.of_P q n).comp_Ïƒ hi'\n        unfold P\n        erw [â† assoc, v.comp_P_eq_self, homological_complex.add_f_apply, preadditive.comp_add, comp_id,\n          v.comp_HÏƒ_eq hi', assoc, simplicial_object.Î´_comp_Ïƒ_succ'_assoc, Fin.eta, decomposition_Q n q, sum_comp,\n          sum_comp, finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        swap\n        Â· ext\n          simp only [Fin.val_mk, Fin.val_succ]\n        Â· intro j hj\n          simp only [true_and_iff, finset.mem_univ, Finset.mem_filter] at hj\n          simp only [nat.succ_eq_add_one] at hi'\n          obtain âŸ¨k, hkâŸ© := nat.le.dest (nat.lt_succ_iff.mp (Fin.is_lt j))\n          rw [add_comm] at hk\n          have hi'' : i = Fin.castSucc âŸ¨i, by linarithâŸ© := by\n            ext\n            simp only [Fin.castSucc_mk, Fin.eta]\n          have eq :=\n            hq j.rev.succ\n              (by\n                simp only [â† hk, Fin.rev_eq j hk.symm, nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n                linarith)\n          rw [homological_complex.comp_f, assoc, assoc, assoc, hi'', simplicial_object.Ïƒ_comp_Ïƒ_assoc, reassoc_of eq,\n            zero_comp, comp_zero, comp_zero, comp_zero]\n          simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n          linarith\n#align Ïƒ_comp_P_eq_zero Ïƒ_comp_P_eq_zero\n\n",
 "degeneracy_comp_P_infty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem degeneracy_comp_P_infty (X : simplicial_object C) (n : â„•) {Î”' : simplex_category}\n    (Î¸ : Â«expr âŸ¶ Â» (simplex_category.mk n) Î”') (hÎ¸ : Â¬Mono Î¸) : Â«expr â‰« Â» (X.map Î¸.op) (P_infty.f n) = 0 :=\n  by\n  rw [simplex_category.mono_iff_injective] at hÎ¸\n  cases n\n  Â· exfalso\n    apply hÎ¸\n    intro x y h\n    fin_cases x\n    fin_cases y\n  Â· obtain âŸ¨i, Î±, hâŸ© := simplex_category.eq_Ïƒ_comp_of_not_injective Î¸ hÎ¸\n    rw [h, op_comp, X.map_comp, assoc, show X.map (simplex_category.Ïƒ i).op = X.Ïƒ i by rfl, Ïƒ_comp_P_infty, comp_zero]\n#align degeneracy_comp_P_infty degeneracy_comp_P_infty\n\n",
 "comp_Ïƒ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplicial_object.at -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-\nCopyright (c) 2022 JoÃ«l Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: JoÃ«l Riou\n-/\ntheorem higher_faces_vanish.comp_Ïƒ {Y : C} {X : simplicial_object C} {n b q : â„•}\n    {Ï† : Â«expr âŸ¶ Â» Y (simplicial_object.at X (n + 1))} (v : higher_faces_vanish q Ï†) (hnbq : n + 1 = b + q) :\n    higher_faces_vanish q\n      (Â«expr â‰« Â» Ï† (X.Ïƒ âŸ¨b, by simpa only [hnbq, Nat.lt_succ_iff, le_add_iff_nonneg_right] using zero_le qâŸ©)) :=\n  fun j hj =>\n  by\n  rw [assoc, simplicial_object.Î´_comp_Ïƒ_of_gt', Fin.pred_succ, v.comp_Î´_eq_zero_assoc _ _ hj, zero_comp]\n  Â· intro hj'\n    simpa only [hj', hnbq, Fin.val_zero, zero_add, add_comm b, add_assoc, false_and_iff, add_le_iff_nonpos_right,\n      le_zero_iff, add_eq_zero_iff, nat.one_ne_zero] using hj\n  Â· simp only [Fin.lt_iff_val_lt_val, Nat.lt_iff_add_one_le, Fin.succ_mk, Fin.val_mk, Fin.val_succ,\n      add_le_add_iff_right]\n    linarith\n#align higher_faces_vanish.comp_Ïƒ higher_faces_vanish.comp_Ïƒ\n\n"}