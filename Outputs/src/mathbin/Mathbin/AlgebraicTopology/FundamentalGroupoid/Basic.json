{"trans_refl_reparam_aux_zero":
 "theorem trans_refl_reparam_aux_zero : trans_refl_reparam_aux 0 = 0 := by norm_num [trans_refl_reparam_aux]\n#align trans_refl_reparam_aux_zero trans_refl_reparam_aux_zero\n\n",
 "trans_refl_reparam_aux_one":
 "theorem trans_refl_reparam_aux_one : trans_refl_reparam_aux 1 = 1 := by norm_num [trans_refl_reparam_aux]\n#align trans_refl_reparam_aux_one trans_refl_reparam_aux_one\n\n",
 "trans_refl_reparam_aux_mem_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem trans_refl_reparam_aux_mem_I (t : unit_interval) : trans_refl_reparam_aux t âˆˆ unit_interval :=\n  by\n  unfold trans_refl_reparam_aux\n  split_ifs <;> constructor <;> linarith [unitInterval.le_one t, unitInterval.nonneg t]\n#align trans_refl_reparam_aux_mem_I trans_refl_reparam_aux_mem_I\n\n",
 "trans_refl_reparam":
 "theorem trans_refl_reparam (p : Path xâ‚€ xâ‚) :\n    p.trans (Path.refl xâ‚) =\n      p.reparam (fun t => âŸ¨trans_refl_reparam_aux t, trans_refl_reparam_aux_mem_I tâŸ©) (by continuity)\n        (Subtype.ext trans_refl_reparam_aux_zero) (Subtype.ext trans_refl_reparam_aux_one) :=\n  by\n  ext\n  unfold trans_refl_reparam_aux\n  simp only [Path.trans_apply, not_le, coe_to_fun, Function.comp_apply]\n  split_ifs\n  Â· rfl\n  Â· simp\n#align trans_refl_reparam trans_refl_reparam\n\n",
 "trans_assoc_reparam_aux_zero":
 "theorem trans_assoc_reparam_aux_zero : trans_assoc_reparam_aux 0 = 0 := by norm_num [trans_assoc_reparam_aux]\n#align trans_assoc_reparam_aux_zero trans_assoc_reparam_aux_zero\n\n",
 "trans_assoc_reparam_aux_one":
 "theorem trans_assoc_reparam_aux_one : trans_assoc_reparam_aux 1 = 1 := by norm_num [trans_assoc_reparam_aux]\n#align trans_assoc_reparam_aux_one trans_assoc_reparam_aux_one\n\n",
 "trans_assoc_reparam_aux_mem_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem trans_assoc_reparam_aux_mem_I (t : unit_interval) : trans_assoc_reparam_aux t âˆˆ unit_interval :=\n  by\n  unfold trans_assoc_reparam_aux\n  split_ifs <;> constructor <;> linarith [unitInterval.le_one t, unitInterval.nonneg t]\n#align trans_assoc_reparam_aux_mem_I trans_assoc_reparam_aux_mem_I\n\n",
 "trans_assoc_reparam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem trans_assoc_reparam {xâ‚€ xâ‚ xâ‚‚ xâ‚ƒ : X} (p : Path xâ‚€ xâ‚) (q : Path xâ‚ xâ‚‚) (r : Path xâ‚‚ xâ‚ƒ) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam (fun t => âŸ¨trans_assoc_reparam_aux t, trans_assoc_reparam_aux_mem_I tâŸ©)\n        (by continuity) (Subtype.ext trans_assoc_reparam_aux_zero) (Subtype.ext trans_assoc_reparam_aux_one) :=\n  by\n  ext\n  simp only [trans_assoc_reparam_aux, Path.trans_apply, mul_inv_cancel_leftâ‚€, not_le, Function.comp_apply, ne.def,\n    not_false_iff, bit0_eq_zero, one_ne_zero, mul_ite, Subtype.coe_mk, Path.coe_reparam]\n  -- TODO: why does split_ifs not reduce the ifs??????\n  split_ifs with hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ hâ‚…\n  Â· simp [hâ‚‚, hâ‚ƒ, -one_div]\n  Â· exfalso\n    linarith\n  Â· exfalso\n    linarith\n  Â· have h : Â¬(x : exprâ„) + 1 / 4 â‰¤ 1 / 2 := by linarith\n    have h' : 2 * ((x : exprâ„) + 1 / 4) - 1 â‰¤ 1 / 2 := by linarith\n    have h'' : 2 * (2 * (x : exprâ„)) - 1 = 2 * (2 * (â†‘x + 1 / 4) - 1) := by linarith\n    simp only [hâ‚„, hâ‚, h, h', h'', dif_neg (show Â¬False from id), dif_pos true.intro, if_false, if_true]\n  Â· exfalso\n    linarith\n  Â· have h : Â¬(1 / 2 : exprâ„) * (x + 1) â‰¤ 1 / 2 := by linarith\n    have h' : Â¬2 * ((1 / 2 : exprâ„) * (x + 1)) - 1 â‰¤ 1 / 2 := by linarith\n    simp only [hâ‚, hâ‚…, h, h', if_false, dif_neg (show Â¬False from id)]\n    congr\n    ring\n#align trans_assoc_reparam trans_assoc_reparam\n\n",
 "refl_trans_symm_aux_mem_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem refl_trans_symm_aux_mem_I (x : unit_interval Ã— unit_interval) : refl_trans_symm_aux x âˆˆ unit_interval :=\n  by\n  dsimp only [refl_trans_symm_aux]\n  split_ifs\n  Â· constructor\n    Â· apply mul_nonneg\n      Â· apply mul_nonneg\n        Â· unit_interval\n        Â· norm_num\n      Â· unit_interval\n    Â· rw [mul_assoc]\n      apply mul_le_one\n      Â· unit_interval\n      Â· apply mul_nonneg\n        Â· norm_num\n        Â· unit_interval\n      Â· linarith\n  Â· constructor\n    Â· apply mul_nonneg\n      Â· unit_interval\n      linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n    Â· apply mul_le_one\n      Â· unit_interval\n      Â· linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n      Â· linarith [unitInterval.nonneg x.2, unitInterval.le_one x.2]\n#align refl_trans_symm_aux_mem_I refl_trans_symm_aux_mem_I\n\n",
 "map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprC( , )Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\ntheorem map_eq {X Y : TopCat} {xâ‚€ xâ‚ : X} (f : Â«exprC( , )Â» X Y) (p : path.homotopic.quotient xâ‚€ xâ‚) :\n    ((fundamental_groupoid_functor.map) f).map p = p.map_fn f :=\n  rfl\n#align map_eq map_eq\n\n",
 "id_eq_path_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\ntheorem id_eq_path_refl (x : fundamental_groupoid X) : (Â«exprğŸ™Â») x = Â«exprâŸ¦ âŸ§Â» (Path.refl x) :=\n  rfl\n#align id_eq_path_refl id_eq_path_refl\n\n",
 "continuous_trans_refl_reparam_aux":
 "@[continuity]\ntheorem continuous_trans_refl_reparam_aux : Continuous trans_refl_reparam_aux :=\n  by\n  refine' continuous_if_le _ _ (Continuous.continuousOn _) (Continuous.continuousOn _) _ <;> [continuity, continuity,\n    continuity, continuity, skip]\n  intro x hx\n  norm_num [hx]\n#align continuous_trans_refl_reparam_aux continuous_trans_refl_reparam_aux\n\n",
 "continuous_trans_assoc_reparam_aux":
 "@[continuity]\ntheorem continuous_trans_assoc_reparam_aux : Continuous trans_assoc_reparam_aux := by\n  refine'\n        continuous_if_le _ _ (Continuous.continuousOn _)\n          (continuous_if_le _ _ (Continuous.continuousOn _) (Continuous.continuousOn _) _).continuous_on _ <;>\n      [continuity, continuity, continuity, continuity, continuity, continuity, continuity, skip, skip] <;>\n    Â· intro x hx\n      norm_num [hx]\n#align continuous_trans_assoc_reparam_aux continuous_trans_assoc_reparam_aux\n\n",
 "continuous_refl_trans_symm_aux":
 "/-\nCopyright (c) 2021 Shing Tak Lam. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Shing Tak Lam\n-/\n@[continuity]\ntheorem continuous_refl_trans_symm_aux : Continuous refl_trans_symm_aux :=\n  by\n  refine' continuous_if_le _ _ (Continuous.continuousOn _) (Continuous.continuousOn _) _\n  Â· continuity\n  Â· continuity\n  Â· continuity\n  Â· continuity\n  intro x hx\n  norm_num [hx, mul_assoc]\n#align continuous_refl_trans_symm_aux continuous_refl_trans_symm_aux\n\n",
 "comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem comp_eq (x y z : fundamental_groupoid X) (p : Â«expr âŸ¶ Â» x y) (q : Â«expr âŸ¶ Â» y z) : Â«expr â‰« Â» p q = p.comp q :=\n  rfl\n#align comp_eq comp_eq\n\n"}