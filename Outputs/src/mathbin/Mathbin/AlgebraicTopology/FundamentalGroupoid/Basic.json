{"trans_refl_reparam_aux_zero":
 "theorem trans_refl_reparam_aux_zero : trans_refl_reparam_aux 0 = 0 := by norm_num [trans_refl_reparam_aux]\n#align trans_refl_reparam_aux_zero trans_refl_reparam_aux_zero\n\n",
 "trans_refl_reparam_aux_one":
 "theorem trans_refl_reparam_aux_one : trans_refl_reparam_aux 1 = 1 := by norm_num [trans_refl_reparam_aux]\n#align trans_refl_reparam_aux_one trans_refl_reparam_aux_one\n\n",
 "trans_refl_reparam_aux_mem_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem trans_refl_reparam_aux_mem_I (t : unit_interval) : trans_refl_reparam_aux t ∈ unit_interval :=\n  by\n  unfold trans_refl_reparam_aux\n  split_ifs <;> constructor <;> linarith [unit_interval.le_one t, unit_interval.nonneg t]\n#align trans_refl_reparam_aux_mem_I trans_refl_reparam_aux_mem_I\n\n",
 "trans_refl_reparam":
 "theorem trans_refl_reparam (p : path x₀ x₁) :\n    p.trans (path.refl x₁) =\n      p.reparam (fun t => ⟨trans_refl_reparam_aux t, trans_refl_reparam_aux_mem_I t⟩) (by continuity)\n        (subtype.ext trans_refl_reparam_aux_zero) (subtype.ext trans_refl_reparam_aux_one) :=\n  by\n  ext\n  unfold trans_refl_reparam_aux\n  simp only [path.trans_apply, not_le, coe_to_fun, Function.comp_apply]\n  split_ifs\n  · rfl\n  · simp\n#align trans_refl_reparam trans_refl_reparam\n\n",
 "trans_assoc_reparam_aux_zero":
 "theorem trans_assoc_reparam_aux_zero : trans_assoc_reparam_aux 0 = 0 := by norm_num [trans_assoc_reparam_aux]\n#align trans_assoc_reparam_aux_zero trans_assoc_reparam_aux_zero\n\n",
 "trans_assoc_reparam_aux_one":
 "theorem trans_assoc_reparam_aux_one : trans_assoc_reparam_aux 1 = 1 := by norm_num [trans_assoc_reparam_aux]\n#align trans_assoc_reparam_aux_one trans_assoc_reparam_aux_one\n\n",
 "trans_assoc_reparam_aux_mem_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem trans_assoc_reparam_aux_mem_I (t : unit_interval) : trans_assoc_reparam_aux t ∈ unit_interval :=\n  by\n  unfold trans_assoc_reparam_aux\n  split_ifs <;> constructor <;> linarith [unit_interval.le_one t, unit_interval.nonneg t]\n#align trans_assoc_reparam_aux_mem_I trans_assoc_reparam_aux_mem_I\n\n",
 "trans_assoc_reparam":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem trans_assoc_reparam {x₀ x₁ x₂ x₃ : X} (p : path x₀ x₁) (q : path x₁ x₂) (r : path x₂ x₃) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam (fun t => ⟨trans_assoc_reparam_aux t, trans_assoc_reparam_aux_mem_I t⟩)\n        (by continuity) (subtype.ext trans_assoc_reparam_aux_zero) (subtype.ext trans_assoc_reparam_aux_one) :=\n  by\n  ext\n  simp only [trans_assoc_reparam_aux, path.trans_apply, mul_inv_cancel_left₀, not_le, Function.comp_apply, ne.def,\n    not_false_iff, bit0_eq_zero, one_ne_zero, mul_ite, subtype.coe_mk, path.coe_to_fun]\n  -- TODO: why does split_ifs not reduce the ifs??????\n  split_ifs with h₁ h₂ h₃ h₄ h₅\n  · simp [h₂, h₃, -one_div]\n  · exfalso\n    linarith\n  · exfalso\n    linarith\n  · have h : ¬(x : exprℝ) + 1 / 4 ≤ 1 / 2 := by linarith\n    have h' : 2 * ((x : exprℝ) + 1 / 4) - 1 ≤ 1 / 2 := by linarith\n    have h'' : 2 * (2 * (x : exprℝ)) - 1 = 2 * (2 * (↑x + 1 / 4) - 1) := by linarith\n    simp only [h₄, h₁, h, h', h'', dif_neg (show ¬false from id), dif_pos true.intro, if_false, if_true]\n  · exfalso\n    linarith\n  · have h : ¬(1 / 2 : exprℝ) * (x + 1) ≤ 1 / 2 := by linarith\n    have h' : ¬2 * ((1 / 2 : exprℝ) * (x + 1)) - 1 ≤ 1 / 2 := by linarith\n    simp only [h₁, h₅, h, h', if_false, dif_neg (show ¬false from id)]\n    congr\n    ring\n#align trans_assoc_reparam trans_assoc_reparam\n\n",
 "refl_trans_symm_aux_mem_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\ntheorem refl_trans_symm_aux_mem_I (x : unit_interval × unit_interval) : refl_trans_symm_aux x ∈ unit_interval :=\n  by\n  dsimp only [refl_trans_symm_aux]\n  split_ifs\n  · constructor\n    · apply mul_nonneg\n      · apply mul_nonneg\n        · unit_interval\n        · norm_num\n      · unit_interval\n    · rw [mul_assoc]\n      apply mul_le_one\n      · unit_interval\n      · apply mul_nonneg\n        · norm_num\n        · unit_interval\n      · linarith\n  · constructor\n    · apply mul_nonneg\n      · unit_interval\n      linarith [unit_interval.nonneg x.2, unit_interval.le_one x.2]\n    · apply mul_le_one\n      · unit_interval\n      · linarith [unit_interval.nonneg x.2, unit_interval.le_one x.2]\n      · linarith [unit_interval.nonneg x.2, unit_interval.le_one x.2]\n#align refl_trans_symm_aux_mem_I refl_trans_symm_aux_mem_I\n\n",
 "map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprC( , )» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\ntheorem map_eq {X Y : Top} {x₀ x₁ : X} (f : «exprC( , )» X Y) (p : path.homotopic.quotient x₀ x₁) :\n    ((fundamental_groupoid_functor.map) f).map p = p.map_fn f :=\n  rfl\n#align map_eq map_eq\n\n",
 "id_eq_path_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem id_eq_path_refl (x : fundamental_groupoid X) : («expr𝟙») x = «expr⟦ ⟧» (path.refl x) :=\n  rfl\n#align id_eq_path_refl id_eq_path_refl\n\n",
 "continuous_trans_refl_reparam_aux":
 "@[continuity]\ntheorem continuous_trans_refl_reparam_aux : continuous trans_refl_reparam_aux :=\n  by\n  refine' continuous_if_le _ _ (continuous.continuous_on _) (continuous.continuous_on _) _ <;> [continuity, continuity,\n    continuity, continuity, skip]\n  intro x hx\n  norm_num [hx]\n#align continuous_trans_refl_reparam_aux continuous_trans_refl_reparam_aux\n\n",
 "continuous_trans_assoc_reparam_aux":
 "@[continuity]\ntheorem continuous_trans_assoc_reparam_aux : continuous trans_assoc_reparam_aux := by\n  refine'\n        continuous_if_le _ _ (continuous.continuous_on _)\n          (continuous_if_le _ _ (continuous.continuous_on _) (continuous.continuous_on _) _).continuous_on _ <;>\n      [continuity, continuity, continuity, continuity, continuity, continuity, continuity, skip, skip] <;>\n    · intro x hx\n      norm_num [hx]\n#align continuous_trans_assoc_reparam_aux continuous_trans_assoc_reparam_aux\n\n",
 "continuous_refl_trans_symm_aux":
 "/-\nCopyright (c) 2021 Shing Tak Lam. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Shing Tak Lam\n-/\n@[continuity]\ntheorem continuous_refl_trans_symm_aux : continuous refl_trans_symm_aux :=\n  by\n  refine' continuous_if_le _ _ (continuous.continuous_on _) (continuous.continuous_on _) _\n  · continuity\n  · continuity\n  · continuity\n  · continuity\n  intro x hx\n  norm_num [hx, mul_assoc]\n#align continuous_refl_trans_symm_aux continuous_refl_trans_symm_aux\n\n",
 "comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem comp_eq (x y z : fundamental_groupoid X) (p : «expr ⟶ » x y) (q : «expr ⟶ » y z) : «expr ≫ » p q = p.comp q :=\n  rfl\n#align comp_eq comp_eq\n\n"}