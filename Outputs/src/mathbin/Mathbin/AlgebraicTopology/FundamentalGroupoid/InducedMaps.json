{"ulift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n-- We let `X` and `Y` be spaces, and `f` and `g` be homotopic maps between them\n@[simp]\ntheorem ulift_apply (i : ULift.{u} (unit_interval)) (x : X) : H.ulift_map (i, x) = H (i.down, x) :=\n  rfl\n#align ulift_apply ulift_apply\n\n",
 "start_path":
 "private theorem start_path : f xâ‚€ = g xâ‚‚ := by convert hfg 0 <;> simp only [Path.source]\n#align start_path start_path\n\n",
 "heq_path_of_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/-- If `f(p(t) = g(q(t))` for two paths `p` and `q`, then the induced path homotopy classes\n`f(p)` and `g(p)` are the same as well, despite having a priori different types -/\ntheorem heq_path_of_eq_image :\n    HEq (((fundamental_groupoid_functor.map) f).map (Â«exprâŸ¦ âŸ§Â» p))\n      (((fundamental_groupoid_functor.map) g).map (Â«exprâŸ¦ âŸ§Â» q)) :=\n  by\n  simp only [map_eq, â† path.homotopic.map_lift]\n  apply path.homotopic.hpath_hext\n  exact hfg\n#align heq_path_of_eq_image heq_path_of_eq_image\n\n",
 "hcast_def":
 "/-\nCopyright (c) 2022 Praneeth Kolichala. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Praneeth Kolichala\n-/\n@[simp]\ntheorem hcast_def {X : TopCat} {xâ‚€ xâ‚ : X} (hxâ‚€ : xâ‚€ = xâ‚) : hcast hxâ‚€ = eqToHom hxâ‚€ :=\n  rfl\n#align hcast_def hcast_def\n\n",
 "eval_at_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.obj -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- Proof that `H.eval_at x = H(0 âŸ¶ 1, x âŸ¶ x)`, with the appropriate casts -/\ntheorem eval_at_eq (x : X) :\n    Â«exprâŸ¦ âŸ§Â» (H.eval_at x) =\n      Â«expr â‰« Â» (hcast (H.apply_zero x).symm)\n        (Â«expr â‰« Â» (((fundamental_groupoid_functor.map) H.ulift_map).map (prod_to_prod_Top_I uhpath01 ((Â«exprğŸ™Â») x)))\n          (hcast (H.apply_one x).symm.symm)) :=\n  by\n  dsimp only [prod_to_prod_Top_I, uhpath01, hcast]\n  refine' (@functor.conj_eq_to_hom_iff_heq ((fundamental_groupoid_functor.obj) Y) _ _ _ _ _ _ _ _ _).mpr _\n  simp only [id_eq_path_refl, prod_to_prod_Top_map, path.homotopic.prod_lift, map_eq, â† path.homotopic.map_lift]\n  apply path.homotopic.hpath_hext; intro ; rfl\n#align eval_at_eq eval_at_eq\n\n",
 "eq_path_of_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\ntheorem eq_path_of_eq_image :\n    ((fundamental_groupoid_functor.map) f).map (Â«exprâŸ¦ âŸ§Â» p) =\n      Â«expr â‰« Â» (hcast (start_path hfg))\n        (Â«expr â‰« Â» (((fundamental_groupoid_functor.map) g).map (Â«exprâŸ¦ âŸ§Â» q)) (hcast (end_path hfg).symm)) :=\n  by\n  rw [functor.conj_eq_to_hom_iff_heq]\n  exact heq_path_of_eq_image hfg\n#align eq_path_of_eq_image eq_path_of_eq_image\n\n",
 "eq_diag_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n-- Finally, we show `d = f(p) â‰« Hâ‚ = Hâ‚€ â‰« g(p)`\ntheorem eq_diag_path :\n    Â«expr â‰« Â» (((fundamental_groupoid_functor.map) f).map p) (Â«exprâŸ¦ âŸ§Â» (H.eval_at xâ‚)) = H.diagonal_path' p âˆ§\n      (Â«expr â‰« Â» (Â«exprâŸ¦ âŸ§Â» (H.eval_at xâ‚€)) (((fundamental_groupoid_functor.map) g).map p) :\n          Â«expr âŸ¶ Â» (from_top (f xâ‚€)) (from_top (g xâ‚))) =\n        H.diagonal_path' p :=\n  by\n  rw [H.apply_zero_path, H.apply_one_path, H.eval_at_eq, H.eval_at_eq]\n  dsimp only [prod_to_prod_Top_I]\n  constructor <;>\n    Â· slice_lhs 2 5 => simp [â† CategoryTheory.Functor.map_comp]\n      rfl\n#align eq_diag_path eq_diag_path\n\n",
 "end_path":
 "private theorem end_path : f xâ‚ = g xâ‚ƒ := by convert hfg 1 <;> simp only [Path.target]\n#align end_path end_path\n\n",
 "apply_zero_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- Proof that `f(p) = H(0 âŸ¶ 0, p)`, with the appropriate casts -/\ntheorem apply_zero_path :\n    ((fundamental_groupoid_functor.map) f).map p =\n      Â«expr â‰« Â» (hcast (H.apply_zero xâ‚€).symm)\n        (Â«expr â‰« Â»\n          (((fundamental_groupoid_functor.map) H.ulift_map).map (prod_to_prod_Top_I ((Â«exprğŸ™Â») (ULift.up 0)) p))\n          (hcast (H.apply_zero xâ‚))) :=\n  by\n  apply Quotient.inductionOn p\n  intro p'\n  apply @eq_path_of_eq_image _ _ _ _ H.ulift_map _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')\n  simp\n#align apply_zero_path apply_zero_path\n\n",
 "apply_one_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/-- Proof that `g(p) = H(1 âŸ¶ 1, p)`, with the appropriate casts -/\ntheorem apply_one_path :\n    ((fundamental_groupoid_functor.map) g).map p =\n      Â«expr â‰« Â» (hcast (H.apply_one xâ‚€).symm)\n        (Â«expr â‰« Â»\n          (((fundamental_groupoid_functor.map) H.ulift_map).map (prod_to_prod_Top_I ((Â«exprğŸ™Â») (ULift.up 1)) p))\n          (hcast (H.apply_one xâ‚))) :=\n  by\n  apply Quotient.inductionOn p\n  intro p'\n  apply @eq_path_of_eq_image _ _ _ _ H.ulift_map _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')\n  simp\n#align apply_one_path apply_one_path\n\n"}