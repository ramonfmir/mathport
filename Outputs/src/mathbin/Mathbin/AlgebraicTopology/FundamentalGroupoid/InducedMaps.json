{"ulift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `unit_interval -/\n-- We let `X` and `Y` be spaces, and `f` and `g` be homotopic maps between them\n@[simp]\ntheorem ulift_apply (i : ULift.{u} (unit_interval)) (x : X) : H.ulift_map (i, x) = H (i.down, x) :=\n  rfl\n#align ulift_apply ulift_apply\n\n",
 "start_path":
 "private theorem start_path : f x₀ = g x₂ := by convert hfg 0 <;> simp only [Path.source]\n#align start_path start_path\n\n",
 "heq_path_of_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-- If `f(p(t) = g(q(t))` for two paths `p` and `q`, then the induced path homotopy classes\n`f(p)` and `g(p)` are the same as well, despite having a priori different types -/\ntheorem heq_path_of_eq_image :\n    HEq (((fundamental_groupoid_functor.map) f).map («expr⟦ ⟧» p))\n      (((fundamental_groupoid_functor.map) g).map («expr⟦ ⟧» q)) :=\n  by\n  simp only [map_eq, ← path.homotopic.map_lift]\n  apply path.homotopic.hpath_hext\n  exact hfg\n#align heq_path_of_eq_image heq_path_of_eq_image\n\n",
 "hcast_def":
 "/-\nCopyright (c) 2022 Praneeth Kolichala. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Praneeth Kolichala\n-/\n@[simp]\ntheorem hcast_def {X : TopCat} {x₀ x₁ : X} (hx₀ : x₀ = x₁) : hcast hx₀ = eqToHom hx₀ :=\n  rfl\n#align hcast_def hcast_def\n\n",
 "eval_at_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.obj -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Proof that `H.eval_at x = H(0 ⟶ 1, x ⟶ x)`, with the appropriate casts -/\ntheorem eval_at_eq (x : X) :\n    «expr⟦ ⟧» (H.eval_at x) =\n      «expr ≫ » (hcast (H.apply_zero x).symm)\n        («expr ≫ » (((fundamental_groupoid_functor.map) H.ulift_map).map (prod_to_prod_Top_I uhpath01 ((«expr𝟙») x)))\n          (hcast (H.apply_one x).symm.symm)) :=\n  by\n  dsimp only [prod_to_prod_Top_I, uhpath01, hcast]\n  refine' (@functor.conj_eq_to_hom_iff_heq ((fundamental_groupoid_functor.obj) Y) _ _ _ _ _ _ _ _ _).mpr _\n  simp only [id_eq_path_refl, prod_to_prod_Top_map, path.homotopic.prod_lift, map_eq, ← path.homotopic.map_lift]\n  apply path.homotopic.hpath_hext; intro ; rfl\n#align eval_at_eq eval_at_eq\n\n",
 "eq_path_of_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem eq_path_of_eq_image :\n    ((fundamental_groupoid_functor.map) f).map («expr⟦ ⟧» p) =\n      «expr ≫ » (hcast (start_path hfg))\n        («expr ≫ » (((fundamental_groupoid_functor.map) g).map («expr⟦ ⟧» q)) (hcast (end_path hfg).symm)) :=\n  by\n  rw [functor.conj_eq_to_hom_iff_heq]\n  exact heq_path_of_eq_image hfg\n#align eq_path_of_eq_image eq_path_of_eq_image\n\n",
 "eq_diag_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n-- Finally, we show `d = f(p) ≫ H₁ = H₀ ≫ g(p)`\ntheorem eq_diag_path :\n    «expr ≫ » (((fundamental_groupoid_functor.map) f).map p) («expr⟦ ⟧» (H.eval_at x₁)) = H.diagonal_path' p ∧\n      («expr ≫ » («expr⟦ ⟧» (H.eval_at x₀)) (((fundamental_groupoid_functor.map) g).map p) :\n          «expr ⟶ » (from_top (f x₀)) (from_top (g x₁))) =\n        H.diagonal_path' p :=\n  by\n  rw [H.apply_zero_path, H.apply_one_path, H.eval_at_eq, H.eval_at_eq]\n  dsimp only [prod_to_prod_Top_I]\n  constructor <;>\n    · slice_lhs 2 5 => simp [← CategoryTheory.Functor.map_comp]\n      rfl\n#align eq_diag_path eq_diag_path\n\n",
 "end_path":
 "private theorem end_path : f x₁ = g x₃ := by convert hfg 1 <;> simp only [Path.target]\n#align end_path end_path\n\n",
 "apply_zero_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Proof that `f(p) = H(0 ⟶ 0, p)`, with the appropriate casts -/\ntheorem apply_zero_path :\n    ((fundamental_groupoid_functor.map) f).map p =\n      «expr ≫ » (hcast (H.apply_zero x₀).symm)\n        («expr ≫ »\n          (((fundamental_groupoid_functor.map) H.ulift_map).map (prod_to_prod_Top_I ((«expr𝟙») (ULift.up 0)) p))\n          (hcast (H.apply_zero x₁))) :=\n  by\n  apply Quotient.inductionOn p\n  intro p'\n  apply @eq_path_of_eq_image _ _ _ _ H.ulift_map _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')\n  simp\n#align apply_zero_path apply_zero_path\n\n",
 "apply_one_path":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `fundamental_groupoid_functor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/-- Proof that `g(p) = H(1 ⟶ 1, p)`, with the appropriate casts -/\ntheorem apply_one_path :\n    ((fundamental_groupoid_functor.map) g).map p =\n      «expr ≫ » (hcast (H.apply_one x₀).symm)\n        («expr ≫ »\n          (((fundamental_groupoid_functor.map) H.ulift_map).map (prod_to_prod_Top_I ((«expr𝟙») (ULift.up 1)) p))\n          (hcast (H.apply_one x₁))) :=\n  by\n  apply Quotient.inductionOn p\n  intro p'\n  apply @eq_path_of_eq_image _ _ _ _ H.ulift_map _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')\n  simp\n#align apply_one_path apply_one_path\n\n"}