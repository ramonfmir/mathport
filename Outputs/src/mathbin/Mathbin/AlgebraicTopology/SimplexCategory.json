{"σ_comp_σ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The fifth simplicial identity -/\n@[reassoc.1]\ntheorem σ_comp_σ {n} {i j : fin (n + 1)} (H : i ≤ j) : «expr ≫ » (σ i.cast_succ) (σ j) = «expr ≫ » (σ j.succ) (σ i) :=\n  by\n  ext k\n  dsimp [σ, Fin.predAbove]\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  rcases k with ⟨k, _⟩\n  simp only [Fin.mk_le_mk] at H\n  -- At this point `simp with push_cast` makes good progress, but neither `simp?` nor `squeeze_simp`\n  -- return usable sets of lemmas.\n  -- To avoid using a non-terminal simp, we make a `suffices` statement indicating the shape\n  -- of the goal we're looking for, and then use `simpa with push_cast`.\n  -- I'm not sure this is actually much more robust that a non-terminal simp.\n  suffices ite (_ < dite (i < k) _ _) _ _ = ite (_ < dite (j + 1 < k) _ _) _ _ by simpa [Fin.predAbove, push_cast]\n  split_ifs\n  -- `split_ifs` created 12 goals.\n  -- Most of them are dealt with `by simp at *; linarith`,\n  -- but we pull out two harder ones to do by hand.\n  pick_goal 3\n  · simp only [not_lt] at h_2\n    exact\n      false.elim\n        (lt_irrefl (k - 1)\n          (lt_of_lt_of_le (nat.pred_lt (id (ne_of_lt (lt_of_le_of_lt (zero_le i) h)).symm))\n            (le_trans h_2 (nat.succ_le_of_lt h_1))))\n  pick_goal 3\n  · simp only [Subtype.mk_lt_mk, not_lt] at h_1\n    exact false.elim (lt_irrefl j (lt_of_lt_of_le (nat.pred_lt_pred (nat.succ_ne_zero j) h_2) h_1))\n  -- Deal with the rest automatically.\n  all_goals simp at * <;> linarith\n#align σ_comp_σ σ_comp_σ\n\n",
 "δ_comp_σ_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[reassoc.1]\ntheorem δ_comp_σ_succ' {n} (j : fin (n + 2)) (i : fin (n + 1)) (H : j = i.succ) :\n    «expr ≫ » (δ j) (σ i) = («expr𝟙») (simplex_category.mk n) :=\n  by\n  subst H\n  rw [δ_comp_σ_succ]\n#align δ_comp_σ_succ' δ_comp_σ_succ'\n\n",
 "δ_comp_σ_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/-- The second part of the third simplicial identity -/\n@[reassoc.1]\ntheorem δ_comp_σ_succ {n} {i : fin (n + 1)} : «expr ≫ » (δ i.succ) (σ i) = («expr𝟙») (simplex_category.mk n) :=\n  by\n  ext j\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  dsimp [δ, σ, Fin.succAbove, Fin.predAbove]\n  simp [Fin.predAbove, push_cast]\n  split_ifs <;> · simp at * <;> linarith\n#align δ_comp_σ_succ δ_comp_σ_succ\n\n",
 "δ_comp_σ_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[reassoc.1]\ntheorem δ_comp_σ_self' {n} {j : fin (n + 2)} {i : fin (n + 1)} (H : j = i.cast_succ) :\n    «expr ≫ » (δ j) (σ i) = («expr𝟙») (simplex_category.mk n) :=\n  by\n  subst H\n  rw [δ_comp_σ_self]\n#align δ_comp_σ_self' δ_comp_σ_self'\n\n",
 "δ_comp_σ_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/-- The first part of the third simplicial identity -/\n@[reassoc.1]\ntheorem δ_comp_σ_self {n} {i : fin (n + 1)} : «expr ≫ » (δ i.cast_succ) (σ i) = («expr𝟙») (simplex_category.mk n) :=\n  by\n  ext j\n  suffices\n    ite (Fin.castSucc i < ite (j < i) (Fin.castSucc j) j.succ) (ite (j < i) (j : ℕ) (j + 1) - 1)\n        (ite (j < i) j (j + 1)) =\n      j\n    by\n    dsimp [δ, σ, Fin.succAbove, Fin.predAbove]\n    simpa [Fin.predAbove, push_cast]\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  dsimp\n  split_ifs <;> · simp at * <;> linarith\n#align δ_comp_σ_self δ_comp_σ_self\n\n",
 "δ_comp_σ_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The second simplicial identity -/\n@[reassoc.1]\ntheorem δ_comp_σ_of_le {n} {i : fin (n + 2)} {j : fin (n + 1)} (H : i ≤ j.cast_succ) :\n    «expr ≫ » (δ i.cast_succ) (σ j.succ) = «expr ≫ » (σ j) (δ i) :=\n  by\n  ext k\n  suffices\n    ite (j.succ.cast_succ < ite (k < i) k.cast_succ k.succ) (ite (k < i) (k : ℕ) (k + 1) - 1) (ite (k < i) k (k + 1)) =\n      ite\n        ((if h : (j : ℕ) < k then\n              k.pred\n                (by\n                  rintro rfl\n                  exact nat.not_lt_zero _ h)\n            else\n              k.cast_lt\n                (by\n                  cases j\n                  cases k\n                  simp only [len_mk]\n                  linarith)).cast_succ <\n          i)\n        (ite (j.cast_succ < k) (k - 1) k) (ite (j.cast_succ < k) (k - 1) k + 1)\n    by\n    dsimp [δ, σ, Fin.succAbove, Fin.predAbove]\n    simp [Fin.predAbove, push_cast]\n    convert rfl\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  rcases k with ⟨k, _⟩\n  simp only [Fin.mk_le_mk, Fin.castSucc_mk] at H\n  dsimp\n  split_ifs\n  -- Most of the goals can now be handled by `linarith`,\n  -- but we have to deal with two of them by hand.\n  pick_goal 8\n  · exact (nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) ‹_›)).symm\n  pick_goal 7\n  · have : k ≤ i := Nat.le_of_pred_lt ‹_›\n    linarith\n  -- Hope for the best from `linarith`:\n  all_goals try first |rfl|simp at * <;> linarith\n#align δ_comp_σ_of_le δ_comp_σ_of_le\n\n",
 "δ_comp_σ_of_gt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem δ_comp_σ_of_gt' {n} {i : fin (n + 3)} {j : fin (n + 2)} (H : j.succ < i) :\n    «expr ≫ » (δ i) (σ j) =\n      «expr ≫ »\n        (σ\n          (j.cast_lt\n            ((add_lt_add_iff_right 1).mp\n              (lt_of_lt_of_le (by simpa only [[anonymous], ← Fin.val_succ] using fin.lt_iff_coe_lt_coe.mp H) i.is_le))))\n        (δ (i.pred fun hi => by simpa only [Fin.not_lt_zero, hi] using H)) :=\n  by\n  rw [← δ_comp_σ_of_gt]\n  · simpa only [Fin.succ_pred]\n  · rw [Fin.castSucc_cast_lt, ← Fin.succ_lt_succ_iff, Fin.succ_pred]\n    exact H\n#align δ_comp_σ_of_gt' δ_comp_σ_of_gt'\n\n",
 "δ_comp_σ_of_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The fourth simplicial identity -/\n@[reassoc.1]\ntheorem δ_comp_σ_of_gt {n} {i : fin (n + 2)} {j : fin (n + 1)} (H : j.cast_succ < i) :\n    «expr ≫ » (δ i.succ) (σ j.cast_succ) = «expr ≫ » (σ j) (δ i) :=\n  by\n  ext k\n  dsimp [δ, σ, Fin.succAbove, Fin.predAbove]\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  rcases k with ⟨k, _⟩\n  simp only [Fin.mk_lt_mk, Fin.castSucc_mk] at H\n  suffices ite (_ < ite (k < i + 1) _ _) _ _ = ite _ (ite (j < k) (k - 1) k) (ite (j < k) (k - 1) k + 1) by\n    simpa [apply_dite Fin.castSucc, Fin.predAbove, push_cast]\n  split_ifs\n  -- Most of the goals can now be handled by `linarith`,\n  -- but we have to deal with three of them by hand.\n  swap\n  · simp only [Fin.mk_lt_mk] at h_1\n    simp only [not_lt] at h_2\n    simp only [self_eq_add_right, one_ne_zero]\n    exact\n      lt_irrefl (k - 1)\n        (lt_of_lt_of_le (nat.pred_lt (ne_of_lt (lt_of_le_of_lt (zero_le _) h_1)).symm)\n          (le_trans (nat.le_of_lt_succ h) h_2))\n  pick_goal 4\n  · simp only [Fin.mk_lt_mk] at h_1\n    simp only [not_lt] at h\n    simp only [Nat.add_succ_sub_one, add_zero]\n    exfalso\n    exact lt_irrefl _ (lt_of_le_of_lt (Nat.le_pred_of_lt (nat.lt_of_succ_le h)) h_3)\n  pick_goal 4\n  · simp only [Fin.mk_lt_mk] at h_1\n    simp only [not_lt] at h_3\n    simp only [Nat.add_succ_sub_one, add_zero]\n    exact (nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) h_2)).symm\n  -- Hope for the best from `linarith`:\n  all_goals simp at h_1 h_2⊢ <;> linarith\n#align δ_comp_σ_of_gt δ_comp_σ_of_gt\n\n",
 "δ_comp_δ_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem δ_comp_δ_self' {n} {i : fin (n + 2)} {j : fin (n + 3)} (H : j = i.cast_succ) :\n    «expr ≫ » (δ i) (δ j) = «expr ≫ » (δ i) (δ i.succ) :=\n  by\n  subst H\n  rw [δ_comp_δ_self]\n#align δ_comp_δ_self' δ_comp_δ_self'\n\n",
 "δ_comp_δ_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The special case of the first simplicial identity -/\n@[reassoc.1]\ntheorem δ_comp_δ_self {n} {i : fin (n + 2)} : «expr ≫ » (δ i) (δ i.cast_succ) = «expr ≫ » (δ i) (δ i.succ) :=\n  (δ_comp_δ (le_refl i)).symm\n#align δ_comp_δ_self δ_comp_δ_self\n\n",
 "δ_comp_δ''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem δ_comp_δ'' {n} {i : fin (n + 3)} {j : fin (n + 2)} (H : i ≤ j.cast_succ) :\n    «expr ≫ » (δ (i.cast_lt (nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt))) (δ j.succ) =\n      «expr ≫ » (δ j) (δ i) :=\n  by\n  rw [δ_comp_δ]\n  · rfl\n  · exact H\n#align δ_comp_δ'' δ_comp_δ''\n\n",
 "δ_comp_δ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem δ_comp_δ' {n} {i : fin (n + 2)} {j : fin (n + 3)} (H : i.cast_succ < j) :\n    «expr ≫ » (δ i) (δ j) =\n      «expr ≫ » (δ (j.pred fun hj => by simpa only [hj, Fin.not_lt_zero] using H)) (δ i.cast_succ) :=\n  by\n  rw [← δ_comp_δ]\n  · rw [Fin.succ_pred]\n  ·\n    simpa only [Fin.le_iff_val_le_val, ← Nat.lt_succ_iff, nat.succ_eq_add_one, ← Fin.val_succ, j.succ_pred,\n      Fin.lt_iff_val_lt_val] using H\n#align δ_comp_δ' δ_comp_δ'\n\n",
 "δ_comp_δ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The generic case of the first simplicial identity -/\ntheorem δ_comp_δ {n} {i j : fin (n + 2)} (H : i ≤ j) : «expr ≫ » (δ i) (δ j.succ) = «expr ≫ » (δ j) (δ i.cast_succ) :=\n  by\n  ext k\n  dsimp [δ, Fin.succAbove]\n  simp only [order_embedding.to_order_hom_coe, OrderEmbedding.coe_ofStrictMono, Function.comp_apply,\n    simplex_category.hom.to_order_hom_mk, order_hom.comp_coe]\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  rcases k with ⟨k, _⟩\n  split_ifs <;> · simp at * <;> linarith\n#align δ_comp_δ δ_comp_δ\n\n",
 "to_order_hom_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n@[simp]\ntheorem to_order_hom_mk {a b : simplex_category} (f : «expr →o » (fin (a.len + 1)) (fin (b.len + 1))) :\n    (mk f).to_order_hom = f :=\n  rfl\n#align to_order_hom_mk to_order_hom_mk\n\n",
 "skeletal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙ » -/\ntheorem skeletal : skeletal simplex_category := fun X Y ⟨I⟩ =>\n  by\n  suffices fintype.card (fin (X.len + 1)) = fintype.card (fin (Y.len + 1))\n    by\n    ext\n    simpa\n  · apply fintype.card_congr\n    refine' equiv.ulift.symm.trans (((«expr ⋙ » skeletal_functor (forget _)).map_iso I).to_equiv.trans _)\n    apply equiv.ulift\n#align skeletal skeletal\n\n",
 "mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A morphism in `simplex_category` is a monomorphism precisely when it is an injective function\n-/\ntheorem mono_iff_injective {n m : simplex_category} {f : «expr ⟶ » n m} : Mono f ↔ function.injective f.to_order_hom :=\n  by\n  rw [← functor.mono_map_iff_mono skeletal_equivalence.functor]\n  dsimp only [skeletal_equivalence, functor.as_equivalence_functor]\n  rw [NonemptyFinLinOrd.mono_iff_injective, skeletal_functor.coe_map, function.injective.of_comp_iff ULift.up_injective,\n    function.injective.of_comp_iff' _ ULift.down_bijective]\n#align mono_iff_injective mono_iff_injective\n\n",
 "mk_to_order_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\ntheorem mk_to_order_hom_apply {a b : simplex_category} (f : «expr →o » (fin (a.len + 1)) (fin (b.len + 1)))\n    (i : fin (a.len + 1)) : (mk f).to_order_hom i = f i :=\n  rfl\n#align mk_to_order_hom_apply mk_to_order_hom_apply\n\n",
 "mk_to_order_hom":
 "@[simp]\ntheorem mk_to_order_hom {a b : simplex_category} (f : simplex_category.hom a b) : mk f.to_order_hom = f :=\n  rfl\n#align mk_to_order_hom mk_to_order_hom\n\n",
 "mk_len":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp]\ntheorem mk_len (n : simplex_category) : simplex_category.mk n.len = n :=\n  rfl\n#align mk_len mk_len\n\n",
 "len_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp]\ntheorem len_mk (n : ℕ) : (simplex_category.mk n).len = n :=\n  rfl\n#align len_mk len_mk\n\n",
 "len_lt_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem len_lt_of_mono {Δ' Δ : simplex_category} (i : «expr ⟶ » Δ' Δ) [hi : Mono i] (hi' : Δ ≠ Δ') : Δ'.len < Δ.len :=\n  by\n  cases lt_or_eq_of_le (len_le_of_mono hi)\n  · exact h\n  · exfalso\n    exact\n      hi'\n        (by\n          ext\n          exact h.symm)\n#align len_lt_of_mono len_lt_of_mono\n\n",
 "len_le_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A monomorphism in `simplex_category` must increase lengths-/\ntheorem len_le_of_mono {x y : simplex_category} {f : «expr ⟶ » x y} : Mono f → x.len ≤ y.len :=\n  by\n  intro hyp_f_mono\n  have f_inj : function.injective f.to_order_hom.to_fun := mono_iff_injective.elim_left hyp_f_mono\n  simpa using fintype.card_le_of_injective f.to_order_hom.to_fun f_inj\n#align len_le_of_mono len_le_of_mono\n\n",
 "len_le_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- An epimorphism in `simplex_category` must decrease lengths-/\ntheorem len_le_of_epi {x y : simplex_category} {f : «expr ⟶ » x y} : Epi f → y.len ≤ x.len :=\n  by\n  intro hyp_f_epi\n  have f_surj : function.surjective f.to_order_hom.to_fun := epi_iff_surjective.elim_left hyp_f_epi\n  simpa using fintype.card_le_of_surjective f.to_order_hom.to_fun f_surj\n#align len_le_of_epi len_le_of_epi\n\n",
 "le_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem le_of_mono {n m : ℕ} {f : «expr ⟶ » (simplex_category.mk n) (simplex_category.mk m)} :\n    CategoryTheory.Mono f → n ≤ m :=\n  len_le_of_mono\n#align le_of_mono le_of_mono\n\n",
 "le_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem le_of_epi {n m : ℕ} {f : «expr ⟶ » (simplex_category.mk n) (simplex_category.mk m)} : Epi f → m ≤ n :=\n  len_le_of_epi\n#align le_of_epi le_of_epi\n\n",
 "iso_eq_iso_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\ntheorem iso_eq_iso_refl {x : simplex_category} (e : «expr ≅ » x x) : e = Iso.refl x :=\n  by\n  have h : (finset.univ : Finset (fin (x.len + 1))).card = x.len + 1 := finset.card_fin (x.len + 1)\n  have eq₁ := finset.order_emb_of_fin_unique' h fun i => finset.mem_univ ((order_iso_of_iso e) i)\n  have eq₂ := finset.order_emb_of_fin_unique' h fun i => finset.mem_univ ((order_iso_of_iso (iso.refl x)) i)\n  ext1; ext1\n  convert congr_arg (fun φ => OrderEmbedding.toOrderHom φ) (eq₁.trans eq₂.symm)\n  ext1; ext1 i\n  rfl\n#align iso_eq_iso_refl iso_eq_iso_refl\n\n",
 "is_iso_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem is_iso_of_bijective {x y : simplex_category} {f : «expr ⟶ » x y}\n    (hf : function.bijective f.to_order_hom.to_fun) : IsIso f :=\n  haveI : is_iso ((forget simplex_category).map f) := (is_iso_iff_bijective _).mpr hf\n  is_iso_of_reflects_iso f (forget simplex_category)\n#align is_iso_of_bijective is_iso_of_bijective\n\n",
 "image_ι_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem image_ι_eq {Δ Δ'' : simplex_category} {φ : «expr ⟶ » Δ Δ''} {e : «expr ⟶ » Δ (image φ)} [Epi e]\n    {i : «expr ⟶ » (image φ) Δ''} [Mono i] (fac : «expr ≫ » e i = φ) : image.ι φ = i :=\n  by\n  haveI := strong_epi_of_epi e\n  rw [← image.iso_strong_epi_mono_hom_comp_ι e i fac,\n    simplex_category.eq_id_of_is_iso (image.iso_strong_epi_mono e i fac).hom, category.id_comp]\n#align image_ι_eq image_ι_eq\n\n",
 "image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem image_eq {Δ Δ' Δ'' : simplex_category} {φ : «expr ⟶ » Δ Δ''} {e : «expr ⟶ » Δ Δ'} [Epi e] {i : «expr ⟶ » Δ' Δ''}\n    [Mono i] (fac : «expr ≫ » e i = φ) : image φ = Δ' :=\n  by\n  haveI := strong_epi_of_epi e\n  let e := image.iso_strong_epi_mono e i fac\n  ext\n  exact le_antisymm (len_le_of_epi (infer_instance : epi e.hom)) (len_le_of_mono (infer_instance : mono e.hom))\n#align image_eq image_eq\n\n",
 "hom_zero_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem hom_zero_zero (f : «expr ⟶ » (simplex_category.mk 0) (simplex_category.mk 0)) : f = («expr𝟙») _ :=\n  by\n  ext : 2\n  dsimp\n  apply subsingleton.elim\n#align hom_zero_zero hom_zero_zero\n\n",
 "factor_thru_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem factor_thru_image_eq {Δ Δ'' : simplex_category} {φ : «expr ⟶ » Δ Δ''} {e : «expr ⟶ » Δ (image φ)} [Epi e]\n    {i : «expr ⟶ » (image φ) Δ''} [Mono i] (fac : «expr ≫ » e i = φ) : factor_thru_image φ = e := by\n  rw [← cancel_mono i, fac, ← image_ι_eq fac, image.fac]\n#align factor_thru_image_eq factor_thru_image_eq\n\n",
 "ext":
 "@[ext]\ntheorem ext {a b : simplex_category} (f g : simplex_category.hom a b) : f.to_order_hom = g.to_order_hom → f = g :=\n  id\n#align ext ext\n\n",
 "eq_σ_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_σ_of_epi {n : ℕ} (θ : «expr ⟶ » (mk (n + 1)) (mk n)) [Epi θ] : ∃ i : fin (n + 1), θ = σ i :=\n  by\n  rcases eq_σ_comp_of_not_injective θ _ with ⟨i, θ', h⟩; swap\n  · by_contra\n    simpa only [nat.one_ne_zero, add_le_iff_nonpos_right, nonpos_iff_eq_zero] using\n      le_of_mono (mono_iff_injective.mpr h)\n  use i\n  haveI : epi («expr ≫ » (σ i) θ') := by\n    rw [← h]\n    infer_instance\n  haveI := CategoryTheory.epi_of_epi (σ i) θ'\n  rw [h, eq_id_of_epi θ', category.comp_id]\n#align eq_σ_of_epi eq_σ_of_epi\n\n",
 "eq_σ_comp_of_not_injective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eq_σ_comp_of_not_injective' {n : ℕ} {Δ' : simplex_category} (θ : «expr ⟶ » (mk (n + 1)) Δ') (i : fin (n + 1))\n    (hi : θ.to_order_hom i.cast_succ = θ.to_order_hom i.succ) : ∃ θ' : «expr ⟶ » (mk n) Δ', θ = «expr ≫ » (σ i) θ' :=\n  by\n  use «expr ≫ » (δ i.succ) θ\n  ext1; ext1; ext1 x\n  simp only [hom.to_order_hom_mk, Function.comp_apply, order_hom.comp_coe, hom.comp, small_category_comp, σ, mk_hom,\n    OrderHom.coe_fun_mk]\n  by_cases h' : x ≤ i.cast_succ\n  · rw [Fin.predAbove_below i x h']\n    have eq := Fin.castSucc_castPred (gt_of_gt_of_ge (Fin.castSucc_lt_last i) h')\n    erw [Fin.succAbove_below i.succ x.cast_pred _]\n    swap\n    · rwa [eq, ← Fin.le_castSucc_iff]\n    rw [eq]\n  · simp only [not_le] at h'\n    let y :=\n      x.pred\n        (by\n          intro h\n          rw [h] at h'\n          simpa only [Fin.lt_iff_val_lt_val, nat.not_lt_zero, Fin.val_zero] using h')\n    simp only [show x = y.succ by rw [Fin.succ_pred]] at h'⊢\n    rw [Fin.predAbove_above i y.succ h', Fin.pred_succ]\n    by_cases h'' : y = i\n    · rw [h'']\n      convert hi.symm\n      erw [Fin.succAbove_below i.succ _]\n      exact Fin.lt_succ\n    · erw [Fin.succAbove_above i.succ _]\n      simp only [Fin.lt_iff_val_lt_val, Fin.le_iff_val_le_val, Fin.val_succ, Fin.coe_castSucc, Nat.lt_succ_iff,\n        Fin.ext_iff] at h' h''⊢\n      cases' nat.le.dest h' with c hc\n      cases c\n      · exfalso\n        rw [add_zero] at hc\n        rw [hc] at h''\n        exact h'' rfl\n      · rw [← hc]\n        simp only [add_le_add_iff_left, nat.succ_eq_add_one, le_add_iff_nonneg_left, zero_le]\n#align eq_σ_comp_of_not_injective' eq_σ_comp_of_not_injective'\n\n",
 "eq_σ_comp_of_not_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eq_σ_comp_of_not_injective {n : ℕ} {Δ' : simplex_category} (θ : «expr ⟶ » (mk (n + 1)) Δ')\n    (hθ : ¬function.injective θ.to_order_hom) : ∃ (i : fin (n + 1))(θ' : «expr ⟶ » (mk n) Δ'), θ = «expr ≫ » (σ i) θ' :=\n  by\n  simp only [function.injective, exists_prop, not_forall] at hθ\n  -- as θ is not injective, there exists `x<y` such that `θ x = θ y`\n  -- and then, `θ x = θ (x+1)`\n  have hθ₂ : ∃ x y : fin (n + 2), (hom.to_order_hom θ) x = (hom.to_order_hom θ) y ∧ x < y :=\n    by\n    rcases hθ with ⟨x, y, ⟨h₁, h₂⟩⟩\n    by_cases x < y\n    · exact ⟨x, y, ⟨h₁, h⟩⟩\n    · refine' ⟨y, x, ⟨h₁.symm, _⟩⟩\n      cases' lt_or_eq_of_le (not_lt.mp h) with h' h'\n      · exact h'\n      · exfalso\n        exact h₂ h'.symm\n  rcases hθ₂ with ⟨x, y, ⟨h₁, h₂⟩⟩\n  let z := x.cast_pred\n  use z\n  simp only [← show z.cast_succ = x from Fin.castSucc_castPred (lt_of_lt_of_le h₂ (Fin.le_last y))] at h₁ h₂\n  apply eq_σ_comp_of_not_injective'\n  rw [Fin.castSucc_lt_iff_succ_le] at h₂\n  apply le_antisymm\n  · exact θ.to_order_hom.monotone (le_of_lt (Fin.castSucc_lt_succ z))\n  · rw [h₁]\n    exact θ.to_order_hom.monotone h₂\n#align eq_σ_comp_of_not_injective eq_σ_comp_of_not_injective\n\n",
 "eq_δ_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem eq_δ_of_mono {n : ℕ} (θ : «expr ⟶ » (mk n) (mk (n + 1))) [Mono θ] : ∃ i : fin (n + 2), θ = δ i :=\n  by\n  rcases eq_comp_δ_of_not_surjective θ _ with ⟨i, θ', h⟩; swap\n  · by_contra\n    simpa only [add_le_iff_nonpos_right, nonpos_iff_eq_zero] using le_of_epi (epi_iff_surjective.mpr h)\n  use i\n  haveI : mono («expr ≫ » θ' (δ i)) := by\n    rw [← h]\n    infer_instance\n  haveI := CategoryTheory.mono_of_mono θ' (δ i)\n  rw [h, eq_id_of_mono θ', category.id_comp]\n#align eq_δ_of_mono eq_δ_of_mono\n\n",
 "eq_id_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem eq_id_of_mono {x : simplex_category} (i : «expr ⟶ » x x) [Mono i] : i = («expr𝟙») _ :=\n  by\n  suffices is_iso i by\n    haveI := this\n    apply eq_id_of_is_iso\n  apply is_iso_of_bijective\n  dsimp\n  rw [fintype.bijective_iff_injective_and_card i.to_order_hom, ← mono_iff_injective, eq_self_iff_true, and_true_iff]\n  infer_instance\n#align eq_id_of_mono eq_id_of_mono\n\n",
 "eq_id_of_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem eq_id_of_is_iso {x : simplex_category} (f : «expr ⟶ » x x) [hf : IsIso f] : f = («expr𝟙») _ :=\n  congr_arg (fun φ : «expr ≅ » _ _ => φ.hom) (iso_eq_iso_refl (asIso f))\n#align eq_id_of_is_iso eq_id_of_is_iso\n\n",
 "eq_id_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\ntheorem eq_id_of_epi {x : simplex_category} (i : «expr ⟶ » x x) [Epi i] : i = («expr𝟙») _ :=\n  by\n  suffices is_iso i by\n    haveI := this\n    apply eq_id_of_is_iso\n  apply is_iso_of_bijective\n  dsimp\n  rw [fintype.bijective_iff_surjective_and_card i.to_order_hom, ← epi_iff_surjective, eq_self_iff_true, and_true_iff]\n  infer_instance\n#align eq_id_of_epi eq_id_of_epi\n\n",
 "eq_comp_δ_of_not_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eq_comp_δ_of_not_surjective' {n : ℕ} {Δ : simplex_category} (θ : «expr ⟶ » Δ (mk (n + 1))) (i : fin (n + 2))\n    (hi : ∀ x, θ.to_order_hom x ≠ i) : ∃ θ' : «expr ⟶ » Δ (mk n), θ = «expr ≫ » θ' (δ i) :=\n  by\n  by_cases i < Fin.last (n + 1)\n  · use «expr ≫ » θ (σ (Fin.castPred i))\n    ext1\n    ext1\n    ext1 x\n    simp only [hom.to_order_hom_mk, Function.comp_apply, order_hom.comp_coe, hom.comp, small_category_comp]\n    by_cases h' : θ.to_order_hom x ≤ i\n    · simp only [σ, mk_hom, hom.to_order_hom_mk, OrderHom.coe_fun_mk]\n      rw [Fin.predAbove_below (Fin.castPred i) (θ.to_order_hom x) (by simpa [Fin.castSucc_castPred h] using h')]\n      erw [Fin.succAbove_below i]\n      swap\n      · simp only [Fin.lt_iff_val_lt_val, Fin.coe_castSucc]\n        exact lt_of_le_of_lt (Fin.coe_castPred_le_self _) (fin.lt_iff_coe_lt_coe.mp ((Ne.le_iff_lt (hi x)).mp h'))\n      rw [Fin.castSucc_castPred]\n      apply lt_of_le_of_lt h' h\n    · simp only [not_le] at h'\n      simp only [σ, mk_hom, hom.to_order_hom_mk, OrderHom.coe_fun_mk,\n        Fin.predAbove_above (Fin.castPred i) (θ.to_order_hom x) (by simpa only [Fin.castSucc_castPred h] using h')]\n      erw [Fin.succAbove_above i _, Fin.succ_pred]\n      simpa only [Fin.le_iff_val_le_val, Fin.coe_castSucc, Fin.coe_pred] using\n        Nat.le_pred_of_lt (fin.lt_iff_coe_lt_coe.mp h')\n  · obtain rfl := le_antisymm (Fin.le_last i) (not_lt.mp h)\n    use «expr ≫ » θ (σ (Fin.last _))\n    ext1\n    ext1\n    ext1 x\n    simp only [hom.to_order_hom_mk, Function.comp_apply, order_hom.comp_coe, hom.comp, small_category_comp, σ, δ,\n      mk_hom, OrderHom.coe_fun_mk, order_embedding.to_order_hom_coe, Fin.predAbove_last, Fin.succAbove_last,\n      Fin.castSucc_castPred ((Ne.le_iff_lt (hi x)).mp (Fin.le_last _))]\n#align eq_comp_δ_of_not_surjective' eq_comp_δ_of_not_surjective'\n\n",
 "eq_comp_δ_of_not_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem eq_comp_δ_of_not_surjective {n : ℕ} {Δ : simplex_category} (θ : «expr ⟶ » Δ (mk (n + 1)))\n    (hθ : ¬function.surjective θ.to_order_hom) : ∃ (i : fin (n + 2))(θ' : «expr ⟶ » Δ (mk n)), θ = «expr ≫ » θ' (δ i) :=\n  by\n  cases' not_forall.mp hθ with i hi\n  use i\n  exact eq_comp_δ_of_not_surjective' θ i (not_exists.mp hi)\n#align eq_comp_δ_of_not_surjective eq_comp_δ_of_not_surjective\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- A morphism in `simplex_category` is an epimorphism if and only if it is a surjective function\n-/\ntheorem epi_iff_surjective {n m : simplex_category} {f : «expr ⟶ » n m} : Epi f ↔ function.surjective f.to_order_hom :=\n  by\n  rw [← functor.epi_map_iff_epi skeletal_equivalence.functor]\n  dsimp only [skeletal_equivalence, functor.as_equivalence_functor]\n  rw [NonemptyFinLinOrd.epi_iff_surjective, skeletal_functor.coe_map,\n    function.surjective.of_comp_iff' ULift.up_bijective, function.surjective.of_comp_iff _ ULift.down_surjective]\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "const_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem const_comp (x y : simplex_category) (i : fin (x.len + 1)) (f : «expr ⟶ » x y) :\n    «expr ≫ » (const x i) f = const y (f.to_order_hom i) :=\n  rfl\n#align const_comp const_comp\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem skeletal_functor.coe_map {Δ₁ Δ₂ : simplex_category} (f : «expr ⟶ » Δ₁ Δ₂) :\n    coe_fn (skeletal_functor.{v}.map f) = ulift.up ∘ f.to_order_hom ∘ ulift.down :=\n  rfl\n#align skeletal_functor.coe_map skeletal_functor.coe_map\n\n"}