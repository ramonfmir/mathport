{"Ïƒ_comp_Ïƒ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The fifth simplicial identity -/\n@[reassoc.1]\ntheorem Ïƒ_comp_Ïƒ {n} {i j : fin (n + 1)} (H : i â‰¤ j) : Â«expr â‰« Â» (Ïƒ i.cast_succ) (Ïƒ j) = Â«expr â‰« Â» (Ïƒ j.succ) (Ïƒ i) :=\n  by\n  ext k\n  dsimp [Ïƒ, Fin.predAbove]\n  rcases i with âŸ¨i, _âŸ©\n  rcases j with âŸ¨j, _âŸ©\n  rcases k with âŸ¨k, _âŸ©\n  simp only [Fin.mk_le_mk] at H\n  -- At this point `simp with push_cast` makes good progress, but neither `simp?` nor `squeeze_simp`\n  -- return usable sets of lemmas.\n  -- To avoid using a non-terminal simp, we make a `suffices` statement indicating the shape\n  -- of the goal we're looking for, and then use `simpa with push_cast`.\n  -- I'm not sure this is actually much more robust that a non-terminal simp.\n  suffices ite (_ < dite (i < k) _ _) _ _ = ite (_ < dite (j + 1 < k) _ _) _ _ by simpa [Fin.predAbove, push_cast]\n  split_ifs\n  -- `split_ifs` created 12 goals.\n  -- Most of them are dealt with `by simp at *; linarith`,\n  -- but we pull out two harder ones to do by hand.\n  pick_goal 3\n  Â· simp only [not_lt] at h_2\n    exact\n      false.elim\n        (lt_irrefl (k - 1)\n          (lt_of_lt_of_le (nat.pred_lt (id (ne_of_lt (lt_of_le_of_lt (zero_le i) h)).symm))\n            (le_trans h_2 (nat.succ_le_of_lt h_1))))\n  pick_goal 3\n  Â· simp only [Subtype.mk_lt_mk, not_lt] at h_1\n    exact false.elim (lt_irrefl j (lt_of_lt_of_le (nat.pred_lt_pred (nat.succ_ne_zero j) h_2) h_1))\n  -- Deal with the rest automatically.\n  all_goals simp at * <;> linarith\n#align Ïƒ_comp_Ïƒ Ïƒ_comp_Ïƒ\n\n",
 "Î´_comp_Ïƒ_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_succ' {n} (j : fin (n + 2)) (i : fin (n + 1)) (H : j = i.succ) :\n    Â«expr â‰« Â» (Î´ j) (Ïƒ i) = (Â«exprğŸ™Â») (simplex_category.mk n) :=\n  by\n  subst H\n  rw [Î´_comp_Ïƒ_succ]\n#align Î´_comp_Ïƒ_succ' Î´_comp_Ïƒ_succ'\n\n",
 "Î´_comp_Ïƒ_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/-- The second part of the third simplicial identity -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_succ {n} {i : fin (n + 1)} : Â«expr â‰« Â» (Î´ i.succ) (Ïƒ i) = (Â«exprğŸ™Â») (simplex_category.mk n) :=\n  by\n  ext j\n  rcases i with âŸ¨i, _âŸ©\n  rcases j with âŸ¨j, _âŸ©\n  dsimp [Î´, Ïƒ, Fin.succAbove, Fin.predAbove]\n  simp [Fin.predAbove, push_cast]\n  split_ifs <;> Â· simp at * <;> linarith\n#align Î´_comp_Ïƒ_succ Î´_comp_Ïƒ_succ\n\n",
 "Î´_comp_Ïƒ_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_self' {n} {j : fin (n + 2)} {i : fin (n + 1)} (H : j = i.cast_succ) :\n    Â«expr â‰« Â» (Î´ j) (Ïƒ i) = (Â«exprğŸ™Â») (simplex_category.mk n) :=\n  by\n  subst H\n  rw [Î´_comp_Ïƒ_self]\n#align Î´_comp_Ïƒ_self' Î´_comp_Ïƒ_self'\n\n",
 "Î´_comp_Ïƒ_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/-- The first part of the third simplicial identity -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_self {n} {i : fin (n + 1)} : Â«expr â‰« Â» (Î´ i.cast_succ) (Ïƒ i) = (Â«exprğŸ™Â») (simplex_category.mk n) :=\n  by\n  ext j\n  suffices\n    ite (Fin.castSucc i < ite (j < i) (Fin.castSucc j) j.succ) (ite (j < i) (j : â„•) (j + 1) - 1)\n        (ite (j < i) j (j + 1)) =\n      j\n    by\n    dsimp [Î´, Ïƒ, Fin.succAbove, Fin.predAbove]\n    simpa [Fin.predAbove, push_cast]\n  rcases i with âŸ¨i, _âŸ©\n  rcases j with âŸ¨j, _âŸ©\n  dsimp\n  split_ifs <;> Â· simp at * <;> linarith\n#align Î´_comp_Ïƒ_self Î´_comp_Ïƒ_self\n\n",
 "Î´_comp_Ïƒ_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The second simplicial identity -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_of_le {n} {i : fin (n + 2)} {j : fin (n + 1)} (H : i â‰¤ j.cast_succ) :\n    Â«expr â‰« Â» (Î´ i.cast_succ) (Ïƒ j.succ) = Â«expr â‰« Â» (Ïƒ j) (Î´ i) :=\n  by\n  ext k\n  suffices\n    ite (j.succ.cast_succ < ite (k < i) k.cast_succ k.succ) (ite (k < i) (k : â„•) (k + 1) - 1) (ite (k < i) k (k + 1)) =\n      ite\n        ((if h : (j : â„•) < k then\n              k.pred\n                (by\n                  rintro rfl\n                  exact nat.not_lt_zero _ h)\n            else\n              k.cast_lt\n                (by\n                  cases j\n                  cases k\n                  simp only [len_mk]\n                  linarith)).cast_succ <\n          i)\n        (ite (j.cast_succ < k) (k - 1) k) (ite (j.cast_succ < k) (k - 1) k + 1)\n    by\n    dsimp [Î´, Ïƒ, Fin.succAbove, Fin.predAbove]\n    simp [Fin.predAbove, push_cast]\n    convert rfl\n  rcases i with âŸ¨i, _âŸ©\n  rcases j with âŸ¨j, _âŸ©\n  rcases k with âŸ¨k, _âŸ©\n  simp only [Fin.mk_le_mk, Fin.castSucc_mk] at H\n  dsimp\n  split_ifs\n  -- Most of the goals can now be handled by `linarith`,\n  -- but we have to deal with two of them by hand.\n  pick_goal 8\n  Â· exact (nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) â€¹_â€º)).symm\n  pick_goal 7\n  Â· have : k â‰¤ i := Nat.le_of_pred_lt â€¹_â€º\n    linarith\n  -- Hope for the best from `linarith`:\n  all_goals try first |rfl|simp at * <;> linarith\n#align Î´_comp_Ïƒ_of_le Î´_comp_Ïƒ_of_le\n\n",
 "Î´_comp_Ïƒ_of_gt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_of_gt' {n} {i : fin (n + 3)} {j : fin (n + 2)} (H : j.succ < i) :\n    Â«expr â‰« Â» (Î´ i) (Ïƒ j) =\n      Â«expr â‰« Â»\n        (Ïƒ\n          (j.cast_lt\n            ((add_lt_add_iff_right 1).mp\n              (lt_of_lt_of_le (by simpa only [[anonymous], â† Fin.val_succ] using fin.lt_iff_coe_lt_coe.mp H) i.is_le))))\n        (Î´ (i.pred fun hi => by simpa only [Fin.not_lt_zero, hi] using H)) :=\n  by\n  rw [â† Î´_comp_Ïƒ_of_gt]\n  Â· simpa only [Fin.succ_pred]\n  Â· rw [Fin.castSucc_cast_lt, â† Fin.succ_lt_succ_iff, Fin.succ_pred]\n    exact H\n#align Î´_comp_Ïƒ_of_gt' Î´_comp_Ïƒ_of_gt'\n\n",
 "Î´_comp_Ïƒ_of_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The fourth simplicial identity -/\n@[reassoc.1]\ntheorem Î´_comp_Ïƒ_of_gt {n} {i : fin (n + 2)} {j : fin (n + 1)} (H : j.cast_succ < i) :\n    Â«expr â‰« Â» (Î´ i.succ) (Ïƒ j.cast_succ) = Â«expr â‰« Â» (Ïƒ j) (Î´ i) :=\n  by\n  ext k\n  dsimp [Î´, Ïƒ, Fin.succAbove, Fin.predAbove]\n  rcases i with âŸ¨i, _âŸ©\n  rcases j with âŸ¨j, _âŸ©\n  rcases k with âŸ¨k, _âŸ©\n  simp only [Fin.mk_lt_mk, Fin.castSucc_mk] at H\n  suffices ite (_ < ite (k < i + 1) _ _) _ _ = ite _ (ite (j < k) (k - 1) k) (ite (j < k) (k - 1) k + 1) by\n    simpa [apply_dite Fin.castSucc, Fin.predAbove, push_cast]\n  split_ifs\n  -- Most of the goals can now be handled by `linarith`,\n  -- but we have to deal with three of them by hand.\n  swap\n  Â· simp only [Fin.mk_lt_mk] at h_1\n    simp only [not_lt] at h_2\n    simp only [self_eq_add_right, one_ne_zero]\n    exact\n      lt_irrefl (k - 1)\n        (lt_of_lt_of_le (nat.pred_lt (ne_of_lt (lt_of_le_of_lt (zero_le _) h_1)).symm)\n          (le_trans (nat.le_of_lt_succ h) h_2))\n  pick_goal 4\n  Â· simp only [Fin.mk_lt_mk] at h_1\n    simp only [not_lt] at h\n    simp only [Nat.add_succ_sub_one, add_zero]\n    exfalso\n    exact lt_irrefl _ (lt_of_le_of_lt (Nat.le_pred_of_lt (nat.lt_of_succ_le h)) h_3)\n  pick_goal 4\n  Â· simp only [Fin.mk_lt_mk] at h_1\n    simp only [not_lt] at h_3\n    simp only [Nat.add_succ_sub_one, add_zero]\n    exact (nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) h_2)).symm\n  -- Hope for the best from `linarith`:\n  all_goals simp at h_1 h_2âŠ¢ <;> linarith\n#align Î´_comp_Ïƒ_of_gt Î´_comp_Ïƒ_of_gt\n\n",
 "Î´_comp_Î´_self'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[reassoc.1]\ntheorem Î´_comp_Î´_self' {n} {i : fin (n + 2)} {j : fin (n + 3)} (H : j = i.cast_succ) :\n    Â«expr â‰« Â» (Î´ i) (Î´ j) = Â«expr â‰« Â» (Î´ i) (Î´ i.succ) :=\n  by\n  subst H\n  rw [Î´_comp_Î´_self]\n#align Î´_comp_Î´_self' Î´_comp_Î´_self'\n\n",
 "Î´_comp_Î´_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The special case of the first simplicial identity -/\n@[reassoc.1]\ntheorem Î´_comp_Î´_self {n} {i : fin (n + 2)} : Â«expr â‰« Â» (Î´ i) (Î´ i.cast_succ) = Â«expr â‰« Â» (Î´ i) (Î´ i.succ) :=\n  (Î´_comp_Î´ (le_refl i)).symm\n#align Î´_comp_Î´_self Î´_comp_Î´_self\n\n",
 "Î´_comp_Î´''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem Î´_comp_Î´'' {n} {i : fin (n + 3)} {j : fin (n + 2)} (H : i â‰¤ j.cast_succ) :\n    Â«expr â‰« Â» (Î´ (i.cast_lt (nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt))) (Î´ j.succ) =\n      Â«expr â‰« Â» (Î´ j) (Î´ i) :=\n  by\n  rw [Î´_comp_Î´]\n  Â· rfl\n  Â· exact H\n#align Î´_comp_Î´'' Î´_comp_Î´''\n\n",
 "Î´_comp_Î´'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem Î´_comp_Î´' {n} {i : fin (n + 2)} {j : fin (n + 3)} (H : i.cast_succ < j) :\n    Â«expr â‰« Â» (Î´ i) (Î´ j) =\n      Â«expr â‰« Â» (Î´ (j.pred fun hj => by simpa only [hj, Fin.not_lt_zero] using H)) (Î´ i.cast_succ) :=\n  by\n  rw [â† Î´_comp_Î´]\n  Â· rw [Fin.succ_pred]\n  Â·\n    simpa only [Fin.le_iff_val_le_val, â† Nat.lt_succ_iff, nat.succ_eq_add_one, â† Fin.val_succ, j.succ_pred,\n      Fin.lt_iff_val_lt_val] using H\n#align Î´_comp_Î´' Î´_comp_Î´'\n\n",
 "Î´_comp_Î´":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/-- The generic case of the first simplicial identity -/\ntheorem Î´_comp_Î´ {n} {i j : fin (n + 2)} (H : i â‰¤ j) : Â«expr â‰« Â» (Î´ i) (Î´ j.succ) = Â«expr â‰« Â» (Î´ j) (Î´ i.cast_succ) :=\n  by\n  ext k\n  dsimp [Î´, Fin.succAbove]\n  simp only [order_embedding.to_order_hom_coe, OrderEmbedding.coe_ofStrictMono, Function.comp_apply,\n    simplex_category.hom.to_order_hom_mk, order_hom.comp_coe]\n  rcases i with âŸ¨i, _âŸ©\n  rcases j with âŸ¨j, _âŸ©\n  rcases k with âŸ¨k, _âŸ©\n  split_ifs <;> Â· simp at * <;> linarith\n#align Î´_comp_Î´ Î´_comp_Î´\n\n",
 "to_order_hom_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\n@[simp]\ntheorem to_order_hom_mk {a b : simplex_category} (f : Â«expr â†’o Â» (fin (a.len + 1)) (fin (b.len + 1))) :\n    (mk f).to_order_hom = f :=\n  rfl\n#align to_order_hom_mk to_order_hom_mk\n\n",
 "skeletal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™ Â» -/\ntheorem skeletal : skeletal simplex_category := fun X Y âŸ¨IâŸ© =>\n  by\n  suffices fintype.card (fin (X.len + 1)) = fintype.card (fin (Y.len + 1))\n    by\n    ext\n    simpa\n  Â· apply fintype.card_congr\n    refine' equiv.ulift.symm.trans (((Â«expr â‹™ Â» skeletal_functor (forget _)).map_iso I).to_equiv.trans _)\n    apply equiv.ulift\n#align skeletal skeletal\n\n",
 "mono_iff_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A morphism in `simplex_category` is a monomorphism precisely when it is an injective function\n-/\ntheorem mono_iff_injective {n m : simplex_category} {f : Â«expr âŸ¶ Â» n m} : Mono f â†” function.injective f.to_order_hom :=\n  by\n  rw [â† functor.mono_map_iff_mono skeletal_equivalence.functor]\n  dsimp only [skeletal_equivalence, functor.as_equivalence_functor]\n  rw [NonemptyFinLinOrd.mono_iff_injective, skeletal_functor.coe_map, function.injective.of_comp_iff ULift.up_injective,\n    function.injective.of_comp_iff' _ ULift.down_bijective]\n#align mono_iff_injective mono_iff_injective\n\n",
 "mk_to_order_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’o Â» -/\ntheorem mk_to_order_hom_apply {a b : simplex_category} (f : Â«expr â†’o Â» (fin (a.len + 1)) (fin (b.len + 1)))\n    (i : fin (a.len + 1)) : (mk f).to_order_hom i = f i :=\n  rfl\n#align mk_to_order_hom_apply mk_to_order_hom_apply\n\n",
 "mk_to_order_hom":
 "@[simp]\ntheorem mk_to_order_hom {a b : simplex_category} (f : simplex_category.hom a b) : mk f.to_order_hom = f :=\n  rfl\n#align mk_to_order_hom mk_to_order_hom\n\n",
 "mk_len":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp]\ntheorem mk_len (n : simplex_category) : simplex_category.mk n.len = n :=\n  rfl\n#align mk_len mk_len\n\n",
 "len_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n@[simp]\ntheorem len_mk (n : â„•) : (simplex_category.mk n).len = n :=\n  rfl\n#align len_mk len_mk\n\n",
 "len_lt_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem len_lt_of_mono {Î”' Î” : simplex_category} (i : Â«expr âŸ¶ Â» Î”' Î”) [hi : Mono i] (hi' : Î” â‰  Î”') : Î”'.len < Î”.len :=\n  by\n  cases lt_or_eq_of_le (len_le_of_mono hi)\n  Â· exact h\n  Â· exfalso\n    exact\n      hi'\n        (by\n          ext\n          exact h.symm)\n#align len_lt_of_mono len_lt_of_mono\n\n",
 "len_le_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A monomorphism in `simplex_category` must increase lengths-/\ntheorem len_le_of_mono {x y : simplex_category} {f : Â«expr âŸ¶ Â» x y} : Mono f â†’ x.len â‰¤ y.len :=\n  by\n  intro hyp_f_mono\n  have f_inj : function.injective f.to_order_hom.to_fun := mono_iff_injective.elim_left hyp_f_mono\n  simpa using fintype.card_le_of_injective f.to_order_hom.to_fun f_inj\n#align len_le_of_mono len_le_of_mono\n\n",
 "len_le_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- An epimorphism in `simplex_category` must decrease lengths-/\ntheorem len_le_of_epi {x y : simplex_category} {f : Â«expr âŸ¶ Â» x y} : Epi f â†’ y.len â‰¤ x.len :=\n  by\n  intro hyp_f_epi\n  have f_surj : function.surjective f.to_order_hom.to_fun := epi_iff_surjective.elim_left hyp_f_epi\n  simpa using fintype.card_le_of_surjective f.to_order_hom.to_fun f_surj\n#align len_le_of_epi len_le_of_epi\n\n",
 "le_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem le_of_mono {n m : â„•} {f : Â«expr âŸ¶ Â» (simplex_category.mk n) (simplex_category.mk m)} :\n    CategoryTheory.Mono f â†’ n â‰¤ m :=\n  len_le_of_mono\n#align le_of_mono le_of_mono\n\n",
 "le_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem le_of_epi {n m : â„•} {f : Â«expr âŸ¶ Â» (simplex_category.mk n) (simplex_category.mk m)} : Epi f â†’ m â‰¤ n :=\n  len_le_of_epi\n#align le_of_epi le_of_epi\n\n",
 "iso_eq_iso_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\ntheorem iso_eq_iso_refl {x : simplex_category} (e : Â«expr â‰… Â» x x) : e = Iso.refl x :=\n  by\n  have h : (finset.univ : Finset (fin (x.len + 1))).card = x.len + 1 := finset.card_fin (x.len + 1)\n  have eqâ‚ := finset.order_emb_of_fin_unique' h fun i => finset.mem_univ ((order_iso_of_iso e) i)\n  have eqâ‚‚ := finset.order_emb_of_fin_unique' h fun i => finset.mem_univ ((order_iso_of_iso (iso.refl x)) i)\n  ext1; ext1\n  convert congr_arg (fun Ï† => OrderEmbedding.toOrderHom Ï†) (eqâ‚.trans eqâ‚‚.symm)\n  ext1; ext1 i\n  rfl\n#align iso_eq_iso_refl iso_eq_iso_refl\n\n",
 "is_iso_of_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem is_iso_of_bijective {x y : simplex_category} {f : Â«expr âŸ¶ Â» x y}\n    (hf : function.bijective f.to_order_hom.to_fun) : IsIso f :=\n  haveI : is_iso ((forget simplex_category).map f) := (is_iso_iff_bijective _).mpr hf\n  is_iso_of_reflects_iso f (forget simplex_category)\n#align is_iso_of_bijective is_iso_of_bijective\n\n",
 "image_Î¹_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem image_Î¹_eq {Î” Î”'' : simplex_category} {Ï† : Â«expr âŸ¶ Â» Î” Î”''} {e : Â«expr âŸ¶ Â» Î” (image Ï†)} [Epi e]\n    {i : Â«expr âŸ¶ Â» (image Ï†) Î”''} [Mono i] (fac : Â«expr â‰« Â» e i = Ï†) : image.Î¹ Ï† = i :=\n  by\n  haveI := strong_epi_of_epi e\n  rw [â† image.iso_strong_epi_mono_hom_comp_Î¹ e i fac,\n    simplex_category.eq_id_of_is_iso (image.iso_strong_epi_mono e i fac).hom, category.id_comp]\n#align image_Î¹_eq image_Î¹_eq\n\n",
 "image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem image_eq {Î” Î”' Î”'' : simplex_category} {Ï† : Â«expr âŸ¶ Â» Î” Î”''} {e : Â«expr âŸ¶ Â» Î” Î”'} [Epi e] {i : Â«expr âŸ¶ Â» Î”' Î”''}\n    [Mono i] (fac : Â«expr â‰« Â» e i = Ï†) : image Ï† = Î”' :=\n  by\n  haveI := strong_epi_of_epi e\n  let e := image.iso_strong_epi_mono e i fac\n  ext\n  exact le_antisymm (len_le_of_epi (infer_instance : epi e.hom)) (len_le_of_mono (infer_instance : mono e.hom))\n#align image_eq image_eq\n\n",
 "hom_zero_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem hom_zero_zero (f : Â«expr âŸ¶ Â» (simplex_category.mk 0) (simplex_category.mk 0)) : f = (Â«exprğŸ™Â») _ :=\n  by\n  ext : 2\n  dsimp\n  apply subsingleton.elim\n#align hom_zero_zero hom_zero_zero\n\n",
 "factor_thru_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem factor_thru_image_eq {Î” Î”'' : simplex_category} {Ï† : Â«expr âŸ¶ Â» Î” Î”''} {e : Â«expr âŸ¶ Â» Î” (image Ï†)} [Epi e]\n    {i : Â«expr âŸ¶ Â» (image Ï†) Î”''} [Mono i] (fac : Â«expr â‰« Â» e i = Ï†) : factor_thru_image Ï† = e := by\n  rw [â† cancel_mono i, fac, â† image_Î¹_eq fac, image.fac]\n#align factor_thru_image_eq factor_thru_image_eq\n\n",
 "ext":
 "@[ext]\ntheorem ext {a b : simplex_category} (f g : simplex_category.hom a b) : f.to_order_hom = g.to_order_hom â†’ f = g :=\n  id\n#align ext ext\n\n",
 "eq_Ïƒ_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eq_Ïƒ_of_epi {n : â„•} (Î¸ : Â«expr âŸ¶ Â» (mk (n + 1)) (mk n)) [Epi Î¸] : âˆƒ i : fin (n + 1), Î¸ = Ïƒ i :=\n  by\n  rcases eq_Ïƒ_comp_of_not_injective Î¸ _ with âŸ¨i, Î¸', hâŸ©; swap\n  Â· by_contra\n    simpa only [nat.one_ne_zero, add_le_iff_nonpos_right, nonpos_iff_eq_zero] using\n      le_of_mono (mono_iff_injective.mpr h)\n  use i\n  haveI : epi (Â«expr â‰« Â» (Ïƒ i) Î¸') := by\n    rw [â† h]\n    infer_instance\n  haveI := CategoryTheory.epi_of_epi (Ïƒ i) Î¸'\n  rw [h, eq_id_of_epi Î¸', category.comp_id]\n#align eq_Ïƒ_of_epi eq_Ïƒ_of_epi\n\n",
 "eq_Ïƒ_comp_of_not_injective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eq_Ïƒ_comp_of_not_injective' {n : â„•} {Î”' : simplex_category} (Î¸ : Â«expr âŸ¶ Â» (mk (n + 1)) Î”') (i : fin (n + 1))\n    (hi : Î¸.to_order_hom i.cast_succ = Î¸.to_order_hom i.succ) : âˆƒ Î¸' : Â«expr âŸ¶ Â» (mk n) Î”', Î¸ = Â«expr â‰« Â» (Ïƒ i) Î¸' :=\n  by\n  use Â«expr â‰« Â» (Î´ i.succ) Î¸\n  ext1; ext1; ext1 x\n  simp only [hom.to_order_hom_mk, Function.comp_apply, order_hom.comp_coe, hom.comp, small_category_comp, Ïƒ, mk_hom,\n    OrderHom.coe_fun_mk]\n  by_cases h' : x â‰¤ i.cast_succ\n  Â· rw [Fin.predAbove_below i x h']\n    have eq := Fin.castSucc_castPred (gt_of_gt_of_ge (Fin.castSucc_lt_last i) h')\n    erw [Fin.succAbove_below i.succ x.cast_pred _]\n    swap\n    Â· rwa [eq, â† Fin.le_castSucc_iff]\n    rw [eq]\n  Â· simp only [not_le] at h'\n    let y :=\n      x.pred\n        (by\n          intro h\n          rw [h] at h'\n          simpa only [Fin.lt_iff_val_lt_val, nat.not_lt_zero, Fin.val_zero] using h')\n    simp only [show x = y.succ by rw [Fin.succ_pred]] at h'âŠ¢\n    rw [Fin.predAbove_above i y.succ h', Fin.pred_succ]\n    by_cases h'' : y = i\n    Â· rw [h'']\n      convert hi.symm\n      erw [Fin.succAbove_below i.succ _]\n      exact Fin.lt_succ\n    Â· erw [Fin.succAbove_above i.succ _]\n      simp only [Fin.lt_iff_val_lt_val, Fin.le_iff_val_le_val, Fin.val_succ, Fin.coe_castSucc, Nat.lt_succ_iff,\n        Fin.ext_iff] at h' h''âŠ¢\n      cases' nat.le.dest h' with c hc\n      cases c\n      Â· exfalso\n        rw [add_zero] at hc\n        rw [hc] at h''\n        exact h'' rfl\n      Â· rw [â† hc]\n        simp only [add_le_add_iff_left, nat.succ_eq_add_one, le_add_iff_nonneg_left, zero_le]\n#align eq_Ïƒ_comp_of_not_injective' eq_Ïƒ_comp_of_not_injective'\n\n",
 "eq_Ïƒ_comp_of_not_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eq_Ïƒ_comp_of_not_injective {n : â„•} {Î”' : simplex_category} (Î¸ : Â«expr âŸ¶ Â» (mk (n + 1)) Î”')\n    (hÎ¸ : Â¬function.injective Î¸.to_order_hom) : âˆƒ (i : fin (n + 1))(Î¸' : Â«expr âŸ¶ Â» (mk n) Î”'), Î¸ = Â«expr â‰« Â» (Ïƒ i) Î¸' :=\n  by\n  simp only [function.injective, exists_prop, not_forall] at hÎ¸\n  -- as Î¸ is not injective, there exists `x<y` such that `Î¸ x = Î¸ y`\n  -- and then, `Î¸ x = Î¸ (x+1)`\n  have hÎ¸â‚‚ : âˆƒ x y : fin (n + 2), (hom.to_order_hom Î¸) x = (hom.to_order_hom Î¸) y âˆ§ x < y :=\n    by\n    rcases hÎ¸ with âŸ¨x, y, âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n    by_cases x < y\n    Â· exact âŸ¨x, y, âŸ¨hâ‚, hâŸ©âŸ©\n    Â· refine' âŸ¨y, x, âŸ¨hâ‚.symm, _âŸ©âŸ©\n      cases' lt_or_eq_of_le (not_lt.mp h) with h' h'\n      Â· exact h'\n      Â· exfalso\n        exact hâ‚‚ h'.symm\n  rcases hÎ¸â‚‚ with âŸ¨x, y, âŸ¨hâ‚, hâ‚‚âŸ©âŸ©\n  let z := x.cast_pred\n  use z\n  simp only [â† show z.cast_succ = x from Fin.castSucc_castPred (lt_of_lt_of_le hâ‚‚ (Fin.le_last y))] at hâ‚ hâ‚‚\n  apply eq_Ïƒ_comp_of_not_injective'\n  rw [Fin.castSucc_lt_iff_succ_le] at hâ‚‚\n  apply le_antisymm\n  Â· exact Î¸.to_order_hom.monotone (le_of_lt (Fin.castSucc_lt_succ z))\n  Â· rw [hâ‚]\n    exact Î¸.to_order_hom.monotone hâ‚‚\n#align eq_Ïƒ_comp_of_not_injective eq_Ïƒ_comp_of_not_injective\n\n",
 "eq_Î´_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem eq_Î´_of_mono {n : â„•} (Î¸ : Â«expr âŸ¶ Â» (mk n) (mk (n + 1))) [Mono Î¸] : âˆƒ i : fin (n + 2), Î¸ = Î´ i :=\n  by\n  rcases eq_comp_Î´_of_not_surjective Î¸ _ with âŸ¨i, Î¸', hâŸ©; swap\n  Â· by_contra\n    simpa only [add_le_iff_nonpos_right, nonpos_iff_eq_zero] using le_of_epi (epi_iff_surjective.mpr h)\n  use i\n  haveI : mono (Â«expr â‰« Â» Î¸' (Î´ i)) := by\n    rw [â† h]\n    infer_instance\n  haveI := CategoryTheory.mono_of_mono Î¸' (Î´ i)\n  rw [h, eq_id_of_mono Î¸', category.id_comp]\n#align eq_Î´_of_mono eq_Î´_of_mono\n\n",
 "eq_id_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem eq_id_of_mono {x : simplex_category} (i : Â«expr âŸ¶ Â» x x) [Mono i] : i = (Â«exprğŸ™Â») _ :=\n  by\n  suffices is_iso i by\n    haveI := this\n    apply eq_id_of_is_iso\n  apply is_iso_of_bijective\n  dsimp\n  rw [fintype.bijective_iff_injective_and_card i.to_order_hom, â† mono_iff_injective, eq_self_iff_true, and_true_iff]\n  infer_instance\n#align eq_id_of_mono eq_id_of_mono\n\n",
 "eq_id_of_is_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰… Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem eq_id_of_is_iso {x : simplex_category} (f : Â«expr âŸ¶ Â» x x) [hf : IsIso f] : f = (Â«exprğŸ™Â») _ :=\n  congr_arg (fun Ï† : Â«expr â‰… Â» _ _ => Ï†.hom) (iso_eq_iso_refl (asIso f))\n#align eq_id_of_is_iso eq_id_of_is_iso\n\n",
 "eq_id_of_epi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ™Â» -/\ntheorem eq_id_of_epi {x : simplex_category} (i : Â«expr âŸ¶ Â» x x) [Epi i] : i = (Â«exprğŸ™Â») _ :=\n  by\n  suffices is_iso i by\n    haveI := this\n    apply eq_id_of_is_iso\n  apply is_iso_of_bijective\n  dsimp\n  rw [fintype.bijective_iff_surjective_and_card i.to_order_hom, â† epi_iff_surjective, eq_self_iff_true, and_true_iff]\n  infer_instance\n#align eq_id_of_epi eq_id_of_epi\n\n",
 "eq_comp_Î´_of_not_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eq_comp_Î´_of_not_surjective' {n : â„•} {Î” : simplex_category} (Î¸ : Â«expr âŸ¶ Â» Î” (mk (n + 1))) (i : fin (n + 2))\n    (hi : âˆ€ x, Î¸.to_order_hom x â‰  i) : âˆƒ Î¸' : Â«expr âŸ¶ Â» Î” (mk n), Î¸ = Â«expr â‰« Â» Î¸' (Î´ i) :=\n  by\n  by_cases i < Fin.last (n + 1)\n  Â· use Â«expr â‰« Â» Î¸ (Ïƒ (Fin.castPred i))\n    ext1\n    ext1\n    ext1 x\n    simp only [hom.to_order_hom_mk, Function.comp_apply, order_hom.comp_coe, hom.comp, small_category_comp]\n    by_cases h' : Î¸.to_order_hom x â‰¤ i\n    Â· simp only [Ïƒ, mk_hom, hom.to_order_hom_mk, OrderHom.coe_fun_mk]\n      rw [Fin.predAbove_below (Fin.castPred i) (Î¸.to_order_hom x) (by simpa [Fin.castSucc_castPred h] using h')]\n      erw [Fin.succAbove_below i]\n      swap\n      Â· simp only [Fin.lt_iff_val_lt_val, Fin.coe_castSucc]\n        exact lt_of_le_of_lt (Fin.coe_castPred_le_self _) (fin.lt_iff_coe_lt_coe.mp ((Ne.le_iff_lt (hi x)).mp h'))\n      rw [Fin.castSucc_castPred]\n      apply lt_of_le_of_lt h' h\n    Â· simp only [not_le] at h'\n      simp only [Ïƒ, mk_hom, hom.to_order_hom_mk, OrderHom.coe_fun_mk,\n        Fin.predAbove_above (Fin.castPred i) (Î¸.to_order_hom x) (by simpa only [Fin.castSucc_castPred h] using h')]\n      erw [Fin.succAbove_above i _, Fin.succ_pred]\n      simpa only [Fin.le_iff_val_le_val, Fin.coe_castSucc, Fin.coe_pred] using\n        Nat.le_pred_of_lt (fin.lt_iff_coe_lt_coe.mp h')\n  Â· obtain rfl := le_antisymm (Fin.le_last i) (not_lt.mp h)\n    use Â«expr â‰« Â» Î¸ (Ïƒ (Fin.last _))\n    ext1\n    ext1\n    ext1 x\n    simp only [hom.to_order_hom_mk, Function.comp_apply, order_hom.comp_coe, hom.comp, small_category_comp, Ïƒ, Î´,\n      mk_hom, OrderHom.coe_fun_mk, order_embedding.to_order_hom_coe, Fin.predAbove_last, Fin.succAbove_last,\n      Fin.castSucc_castPred ((Ne.le_iff_lt (hi x)).mp (Fin.le_last _))]\n#align eq_comp_Î´_of_not_surjective' eq_comp_Î´_of_not_surjective'\n\n",
 "eq_comp_Î´_of_not_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\ntheorem eq_comp_Î´_of_not_surjective {n : â„•} {Î” : simplex_category} (Î¸ : Â«expr âŸ¶ Â» Î” (mk (n + 1)))\n    (hÎ¸ : Â¬function.surjective Î¸.to_order_hom) : âˆƒ (i : fin (n + 2))(Î¸' : Â«expr âŸ¶ Â» Î” (mk n)), Î¸ = Â«expr â‰« Â» Î¸' (Î´ i) :=\n  by\n  cases' not_forall.mp hÎ¸ with i hi\n  use i\n  exact eq_comp_Î´_of_not_surjective' Î¸ i (not_exists.mp hi)\n#align eq_comp_Î´_of_not_surjective eq_comp_Î´_of_not_surjective\n\n",
 "epi_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/-- A morphism in `simplex_category` is an epimorphism if and only if it is a surjective function\n-/\ntheorem epi_iff_surjective {n m : simplex_category} {f : Â«expr âŸ¶ Â» n m} : Epi f â†” function.surjective f.to_order_hom :=\n  by\n  rw [â† functor.epi_map_iff_epi skeletal_equivalence.functor]\n  dsimp only [skeletal_equivalence, functor.as_equivalence_functor]\n  rw [NonemptyFinLinOrd.epi_iff_surjective, skeletal_functor.coe_map,\n    function.surjective.of_comp_iff' ULift.up_bijective, function.surjective.of_comp_iff _ ULift.down_surjective]\n#align epi_iff_surjective epi_iff_surjective\n\n",
 "const_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰« Â» -/\n@[simp]\ntheorem const_comp (x y : simplex_category) (i : fin (x.len + 1)) (f : Â«expr âŸ¶ Â» x y) :\n    Â«expr â‰« Â» (const x i) f = const y (f.to_order_hom i) :=\n  rfl\n#align const_comp const_comp\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\ntheorem skeletal_functor.coe_map {Î”â‚ Î”â‚‚ : simplex_category} (f : Â«expr âŸ¶ Â» Î”â‚ Î”â‚‚) :\n    coe_fn (skeletal_functor.{v}.map f) = ulift.up âˆ˜ f.to_order_hom âˆ˜ ulift.down :=\n  rfl\n#align skeletal_functor.coe_map skeletal_functor.coe_map\n\n"}