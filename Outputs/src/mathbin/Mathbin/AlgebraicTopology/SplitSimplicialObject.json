{"ι_summand_naturality_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_summand_naturality_symm {S₁ S₂ : Split C} (Φ : «expr ⟶ » S₁ S₂) {Δ : «expr ᵒᵖ» SimplexCategory}\n    (A : Splitting.IndexSet Δ) :\n    «expr ≫ » (S₁.s.ι_summand A) (Φ.F.app Δ) = «expr ≫ » (Φ.f A.1.unop.len) (S₂.s.ι_summand A) := by\n  rw [S₁.s.ι_summand_eq, S₂.s.ι_summand_eq, assoc, Φ.F.naturality, ← Φ.comm_assoc]\n#align ι_summand_naturality_symm ι_summand_naturality_symm\n\n",
 "ι_summand_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `simplex_category.mk -/\ntheorem ι_summand_id (n : ℕ) : s.ι_summand (IndexSet.id (op (simplex_category.mk n))) = s.ι n :=\n  by\n  erw [ι_summand_eq, X.map_id, comp_id]\n  rfl\n#align ι_summand_id ι_summand_id\n\n",
 "ι_summand_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem ι_summand_eq {Δ : «expr ᵒᵖ» SimplexCategory} (A : IndexSet Δ) :\n    s.ι_summand A = «expr ≫ » (s.ι A.1.unop.len) (X.map A.e.op) :=\n  by\n  dsimp only [ι_summand, iso.hom]\n  erw [colimit.ι_desc, cofan.mk_ι_app]\n#align ι_summand_eq ι_summand_eq\n\n",
 "ι_summand_epi_naturality":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem ι_summand_epi_naturality {Δ₁ Δ₂ : «expr ᵒᵖ» SimplexCategory} (A : IndexSet Δ₁) (p : «expr ⟶ » Δ₁ Δ₂)\n    [Epi p.unop] : «expr ≫ » (s.ι_summand A) (X.map p) = s.ι_summand (A.epi_comp p) :=\n  by\n  dsimp [ι_summand]\n  erw [colimit.ι_desc, colimit.ι_desc, cofan.mk_ι_app, cofan.mk_ι_app]\n  dsimp only [index_set.epi_comp, index_set.e]\n  rw [op_comp, X.map_comp, assoc, Quiver.Hom.op_unop]\n#align ι_summand_epi_naturality ι_summand_epi_naturality\n\n",
 "ι_summand_comp_app":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_summand_comp_app (f : «expr ⟶ » X Y) {Δ : «expr ᵒᵖ» SimplexCategory} (A : IndexSet Δ) :\n    «expr ≫ » (s.ι_summand A) (f.app Δ) = «expr ≫ » (s.φ f A.1.unop.len) (Y.map A.e.op) := by\n  simp only [ι_summand_eq_assoc, φ, nat_trans.naturality, assoc]\n#align ι_summand_comp_app ι_summand_comp_app\n\n",
 "ι_desc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp, reassoc.1]\ntheorem ι_desc {Z : C} (Δ : «expr ᵒᵖ» SimplexCategory) (F : ∀ A : IndexSet Δ, «expr ⟶ » (s.N A.1.unop.len) Z)\n    (A : IndexSet Δ) : «expr ≫ » (s.ι_summand A) (s.desc Δ F) = F A :=\n  by\n  dsimp only [ι_summand, desc]\n  simp only [assoc, iso.hom_inv_id_assoc, ι_coprod]\n  erw [colimit.ι_desc, cofan.mk_ι_app]\n#align ι_desc ι_desc\n\n",
 "id_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_f (S : Split C) (n : ℕ) : ((«expr𝟙») S : «expr ⟶ » S S).f n = («expr𝟙») (S.s.N n) :=\n  rfl\n#align id_f id_f\n\n",
 "id_F":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟙» -/\n@[simp]\ntheorem id_F (S : Split C) : ((«expr𝟙») S : «expr ⟶ » S S).F = («expr𝟙») S.X :=\n  rfl\n#align id_F id_F\n\n",
 "hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem hom_ext' {Z : C} {Δ : «expr ᵒᵖ» SimplexCategory} (f g : «expr ⟶ » (X.obj Δ) Z)\n    (h : ∀ A : IndexSet Δ, «expr ≫ » (s.ι_summand A) f = «expr ≫ » (s.ι_summand A) g) : f = g :=\n  by\n  rw [← cancel_epi (s.iso Δ).hom]\n  ext A\n  trace \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:73:14: unsupported tactic `discrete_cases #[]\"\n  simpa only [ι_summand_eq, iso_hom, colimit.ι_desc_assoc, cofan.mk_ι_app, assoc] using h A\n#align hom_ext' hom_ext'\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem hom_ext (f g : «expr ⟶ » X Y) (h : ∀ n : ℕ, s.φ f n = s.φ g n) : f = g :=\n  by\n  ext Δ\n  apply s.hom_ext'\n  intro A\n  induction Δ using Opposite.rec'\n  induction' Δ using SimplexCategory.rec with n\n  dsimp\n  simp only [s.ι_summand_comp_app, h]\n#align hom_ext hom_ext\n\n",
 "fac_pull":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[reassoc.1]\ntheorem fac_pull : «expr ≫ » (A.pull θ).e (image.ι («expr ≫ » θ.unop A.e)) = «expr ≫ » θ.unop A.e :=\n  image.fac _\n#align fac_pull fac_pull\n\n",
 "ext'":
 "/-\nCopyright (c) 2022 Joël Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joël Riou\n-/\ntheorem ext' : A = ⟨A.1, ⟨A.e, A.2.2⟩⟩ := by tidy\n#align ext' ext'\n\n",
 "ext":
 "@[ext]\ntheorem hom.ext {S₁ S₂ : Split C} (Φ₁ Φ₂ : Hom S₁ S₂) (h : ∀ n : ℕ, Φ₁.f n = Φ₂.f n) : Φ₁ = Φ₂ :=\n  by\n  rcases Φ₁ with ⟨F₁, f₁, c₁⟩\n  rcases Φ₂ with ⟨F₂, f₂, c₂⟩\n  have h' : f₁ = f₂ := by\n    ext\n    apply h\n  subst h'\n  simp only [eq_self_iff_true, and_true_iff]\n  apply S₁.s.hom_ext\n  intro n\n  dsimp\n  rw [c₁, c₂]\n#align hom.ext hom.ext\n\n",
 "eq_id_iff_mono":
 "theorem eq_id_iff_mono : A.eq_id ↔ Mono A.e := by\n  constructor\n  · intro h\n    dsimp at h\n    subst h\n    dsimp only [id, e]\n    infer_instance\n  · intro h\n    rw [eq_id_iff_len_le]\n    exact len_le_of_mono h\n#align eq_id_iff_mono eq_id_iff_mono\n\n",
 "eq_id_iff_len_le":
 "theorem eq_id_iff_len_le : A.eq_id ↔ Δ.unop.len ≤ A.1.unop.len :=\n  by\n  rw [eq_id_iff_len_eq]\n  constructor\n  · intro h\n    rw [h]\n  · exact le_antisymm (len_le_of_epi (inferInstance : epi A.e))\n#align eq_id_iff_len_le eq_id_iff_len_le\n\n",
 "eq_id_iff_len_eq":
 "theorem eq_id_iff_len_eq : A.eq_id ↔ A.1.unop.len = Δ.unop.len :=\n  by\n  rw [eq_id_iff_eq]\n  constructor\n  · intro h\n    rw [h]\n  · intro h\n    rw [← unop_inj_iff]\n    ext\n    exact h\n#align eq_id_iff_len_eq eq_id_iff_len_eq\n\n",
 "eq_id_iff_eq":
 "theorem eq_id_iff_eq : A.eq_id ↔ A.1 = Δ := by\n  constructor\n  · intro h\n    dsimp at h\n    rw [h]\n    rfl\n  · intro h\n    rcases A with ⟨Δ', ⟨f, hf⟩⟩\n    simp only at h\n    subst h\n    refine' ext _ _ rfl _\n    · haveI := hf\n      simp only [eq_to_hom_refl, comp_id]\n      exact eq_id_of_epi f\n#align eq_id_iff_eq eq_id_iff_eq\n\n",
 "congr_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem congr_f {S₁ S₂ : Split C} {Φ₁ Φ₂ : «expr ⟶ » S₁ S₂} (h : Φ₁ = Φ₂) (n : ℕ) : Φ₁.f n = Φ₂.f n := by rw [h]\n#align congr_f congr_f\n\n",
 "congr_F":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\ntheorem congr_F {S₁ S₂ : Split C} {Φ₁ Φ₂ : «expr ⟶ » S₁ S₂} (h : Φ₁ = Φ₂) : Φ₁.F = Φ₂.F := by rw [h]\n#align congr_F congr_F\n\n",
 "comp_f":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_f {S₁ S₂ S₃ : Split C} (Φ₁₂ : «expr ⟶ » S₁ S₂) (Φ₂₃ : «expr ⟶ » S₂ S₃) (n : ℕ) :\n    («expr ≫ » Φ₁₂ Φ₂₃).f n = «expr ≫ » (Φ₁₂.f n) (Φ₂₃.f n) :=\n  rfl\n#align comp_f comp_f\n\n",
 "comp_F":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n@[simp]\ntheorem comp_F {S₁ S₂ S₃ : Split C} (Φ₁₂ : «expr ⟶ » S₁ S₂) (Φ₂₃ : «expr ⟶ » S₂ S₃) :\n    («expr ≫ » Φ₁₂ Φ₂₃).F = «expr ≫ » Φ₁₂.F Φ₂₃.F :=\n  rfl\n#align comp_F comp_F\n\n"}