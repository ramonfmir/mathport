{"pumping_lemma":
 "theorem pumping_lemma [fintype σ] {x : list α} (hx : x ∈ M.accepts) (hlen : fintype.card σ ≤ list.length x) :\n    ∃ a b c,\n      x = a ++ b ++ c ∧ a.length + b.length ≤ fintype.card σ ∧ b ≠ [] ∧ {a} * language.star {b} * {c} ≤ M.accepts :=\n  by\n  obtain ⟨_, a, b, c, hx, hlen, hnil, rfl, hb, hc⟩ := M.eval_from_split hlen rfl\n  use a, b, c, hx, hlen, hnil\n  intro y hy\n  rw [language.mem_mul] at hy\n  rcases hy with ⟨ab, c', hab, hc', rfl⟩\n  rw [language.mem_mul] at hab\n  rcases hab with ⟨a', b', ha', hb', rfl⟩\n  rw [Set.mem_singleton_iff] at ha' hc'\n  substs ha' hc'\n  have h := M.eval_from_of_pow hb hb'\n  rwa [mem_accepts, eval_from_of_append, eval_from_of_append, h, hc]\n#align pumping_lemma pumping_lemma\n\n",
 "mem_accepts":
 "theorem mem_accepts (x : list α) : x ∈ M.accepts ↔ M.eval_from M.start x ∈ M.accept := by rfl\n#align mem_accepts mem_accepts\n\n",
 "eval_singleton":
 "@[simp]\ntheorem eval_singleton (a : α) : M.eval [a] = M.step M.start a :=\n  rfl\n#align eval_singleton eval_singleton\n\n",
 "eval_nil":
 "@[simp]\ntheorem eval_nil : M.eval [] = M.start :=\n  rfl\n#align eval_nil eval_nil\n\n",
 "eval_from_split":
 "theorem eval_from_split [fintype σ] {x : list α} {s t : σ} (hlen : fintype.card σ ≤ x.length)\n    (hx : M.eval_from s x = t) :\n    ∃ q a b c,\n      x = a ++ b ++ c ∧\n        a.length + b.length ≤ fintype.card σ ∧\n          b ≠ [] ∧ M.eval_from s a = q ∧ M.eval_from q b = q ∧ M.eval_from q c = t :=\n  by\n  obtain ⟨n, m, hneq, heq⟩ :=\n    fintype.exists_ne_map_eq_of_card_lt (fun n : fin (fintype.card σ + 1) => M.eval_from s (x.take n)) (by norm_num)\n  wlog hle : (n : ℕ) ≤ m using n m\n  have hlt : (n : ℕ) < m := (Ne.le_iff_lt hneq).mp hle\n  have hm : (m : ℕ) ≤ fintype.card σ := Fin.is_le m\n  dsimp at heq\n  refine' ⟨M.eval_from s ((x.take m).take n), (x.take m).take n, (x.take m).drop n, x.drop m, _, _, _, by rfl, _⟩\n  · rw [List.take_append_drop, List.take_append_drop]\n  · simp only [list.length_drop, list.length_take]\n    rw [min_eq_left (hm.trans hlen), min_eq_left hle, add_tsub_cancel_of_le hle]\n    exact hm\n  · intro h\n    have hlen' := congr_arg list.length h\n    simp only [list.length_drop, list.length, list.length_take] at hlen'\n    rw [min_eq_left, tsub_eq_zero_iff_le] at hlen'\n    · apply hneq\n      apply le_antisymm\n      assumption'\n    exact hm.trans hlen\n  have hq : M.eval_from (M.eval_from s ((x.take m).take n)) ((x.take m).drop n) = M.eval_from s ((x.take m).take n) :=\n    by\n    rw [List.take_take, min_eq_left hle, ← eval_from_of_append, HEq, ← min_eq_left hle, ← List.take_take,\n      min_eq_left hle, List.take_append_drop]\n  use hq\n  rwa [← hq, ← eval_from_of_append, ← eval_from_of_append, ← list.append_assoc, List.take_append_drop,\n    List.take_append_drop]\n#align eval_from_split eval_from_split\n\n",
 "eval_from_singleton":
 "@[simp]\ntheorem eval_from_singleton (s : σ) (a : α) : M.eval_from s [a] = M.step s a :=\n  rfl\n#align eval_from_singleton eval_from_singleton\n\n",
 "eval_from_of_pow":
 "theorem eval_from_of_pow {x y : list α} {s : σ} (hx : M.eval_from s x = s) (hy : y ∈ @language.star α {x}) :\n    M.eval_from s y = s := by\n  rw [language.mem_star] at hy\n  rcases hy with ⟨S, rfl, hS⟩\n  induction' S with a S ih\n  · rfl\n  · have ha := hS a (list.mem_cons_self _ _)\n    rw [Set.mem_singleton_iff] at ha\n    rw [list.join, eval_from_of_append, ha, hx]\n    apply ih\n    intro z hz\n    exact hS z (list.mem_cons_of_mem a hz)\n#align eval_from_of_pow eval_from_of_pow\n\n",
 "eval_from_of_append":
 "theorem eval_from_of_append (start : σ) (x y : list α) :\n    M.eval_from start (x ++ y) = M.eval_from (M.eval_from start x) y :=\n  x.foldl_append _ _ y\n#align eval_from_of_append eval_from_of_append\n\n",
 "eval_from_nil":
 "/-\nCopyright (c) 2020 Fox Thomson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fox Thomson\n-/\n@[simp]\ntheorem eval_from_nil (s : σ) : M.eval_from s [] = s :=\n  rfl\n#align eval_from_nil eval_from_nil\n\n",
 "eval_from_append_singleton":
 "@[simp]\ntheorem eval_from_append_singleton (s : σ) (x : list α) (a : α) :\n    M.eval_from s (x ++ [a]) = M.step (M.eval_from s x) a := by\n  simp only [eval_from, List.foldl_append, List.foldl_cons, List.foldl_nil]\n#align eval_from_append_singleton eval_from_append_singleton\n\n",
 "eval_append_singleton":
 "@[simp]\ntheorem eval_append_singleton (x : list α) (a : α) : M.eval (x ++ [a]) = M.step (M.eval x) a :=\n  eval_from_append_singleton _ _ _ _\n#align eval_append_singleton eval_append_singleton\n\n"}