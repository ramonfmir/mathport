{"zero_eval":
 "@[simp]\ntheorem zero_eval (v) : zero.eval v = pure [0] := by simp [zero]\n#align zero_eval zero_eval\n\n",
 "zero":
 "theorem code.ok.zero {c} (h : code.ok c) {v} : eval step (step_normal c cont.halt v) = cfg.halt <$> code.eval c v :=\n  by\n  rw [h, ← bind_pure_comp_eq_map]; congr ; funext v\n  exact Part.eq_some_iff.2 (mem_eval.2 ⟨refl_trans_gen.single rfl, rfl⟩)\n#align code.ok.zero code.ok.zero\n\n",
 "unrev_ok":
 "theorem unrev_ok {q s} {S : K' → list Γ'} :\n    reaches₁ (TM2.step tr) ⟨some (unrev q), s, S⟩\n      ⟨some q, none, update (update S rev []) main (List.reverseAux (S rev) (S main))⟩ :=\n  move_ok (by decide) <| split_at_pred_ff _\n#align unrev_ok unrev_ok\n\n",
 "tr_supports":
 "/-- The set `code_supp c k` is a finite set that witnesses the effective finiteness of the `tr`\nTuring machine. Starting from the initial state `tr_normal c k`, forward simulation uses only\nstates in `code_supp c k`, so this is a finite state machine. Even though the underlying type of\nstate labels `Λ'` is infinite, for a given partial recursive function `c` and continuation `k`,\nonly finitely many states are accessed, corresponding roughly to subterms of `c`. -/\ntheorem tr_supports (c k) : @TM2.supports _ _ _ _ _ ⟨tr_normal c k⟩ tr (code_supp c k) :=\n  ⟨code_supp_self _ _ (tr_stmts₁_self _), fun l' => code_supp_supports (Finset.Subset.refl _) _⟩\n#align tr_supports tr_supports\n\n",
 "tr_stmts₁_trans":
 "theorem tr_stmts₁_trans {q q'} : q' ∈ tr_stmts₁ q → tr_stmts₁ q' ⊆ tr_stmts₁ q :=\n  by\n  induction q <;>\n    simp (config := { contextual := true }) only [tr_stmts₁, Finset.mem_insert, Finset.mem_union, or_imp,\n      Finset.mem_singleton, Finset.Subset.refl, imp_true_iff, true_and_iff]\n  iterate 4 exact fun h => Finset.Subset.trans (q_ih h) (Finset.subset_insert _ _)\n  · simp\n    intro s h x h'\n    simp\n    exact or.inr ⟨_, q_ih s h h'⟩\n  · constructor\n    · rintro rfl\n      apply Finset.subset_insert\n    · intro h x h'\n      simp\n      exact or.inr (or.inr <| q_ih h h')\n  · refine' ⟨fun h x h' => _, fun h x h' => _, fun h x h' => _⟩ <;> simp\n    · exact or.inr (or.inr <| or.inl <| q_ih_q₁ h h')\n    · cases' Finset.mem_insert.1 h' with h' h' <;> simp [h', unrev]\n    · exact or.inr (or.inr <| or.inr <| q_ih_q₂ h h')\n#align tr_stmts₁_trans tr_stmts₁_trans\n\n",
 "tr_stmts₁_supports'":
 "theorem tr_stmts₁_supports' {S q K} (H₁ : (q : Λ').supports S) (H₂ : tr_stmts₁ q ∪ K ⊆ S) (H₃ : K ⊆ S → supports K S) :\n    supports (tr_stmts₁ q ∪ K) S := by\n  simp [Finset.union_subset_iff] at H₂\n  exact supports_union.2 ⟨tr_stmts₁_supports H₁ H₂.1, H₃ H₂.2⟩\n#align tr_stmts₁_supports' tr_stmts₁_supports'\n\n",
 "tr_stmts₁_supports":
 "theorem tr_stmts₁_supports {S q} (H₁ : (q : Λ').supports S) (HS₁ : tr_stmts₁ q ⊆ S) : supports (tr_stmts₁ q) S :=\n  by\n  have W := fun {q} => tr_stmts₁_self q\n  induction q <;> simp [tr_stmts₁] at HS₁⊢\n  any_goals\n    cases' Finset.insert_subset.1 HS₁ with h₁ h₂\n    first |have h₃ := h₂ W|try simp [Finset.subset_iff] at h₂\n  · exact supports_insert.2 ⟨⟨fun _ => h₃, fun _ => h₁⟩, q_ih H₁ h₂⟩\n  -- move\n  · exact supports_insert.2 ⟨⟨fun _ => h₃, fun _ => h₁⟩, q_ih H₁ h₂⟩\n  -- clear\n  · exact supports_insert.2 ⟨⟨fun _ => h₁, fun _ => h₃⟩, q_ih H₁ h₂⟩\n  -- copy\n  · exact supports_insert.2 ⟨⟨fun _ => h₃, fun _ => h₃⟩, q_ih H₁ h₂⟩\n  -- push\n  -- read\n  · refine' supports_insert.2 ⟨fun _ => h₂ _ W, _⟩\n    exact supports_bUnion.2 fun _ => q_ih _ (H₁ _) fun _ h => h₂ _ h\n  -- succ\n  · refine' supports_insert.2 ⟨⟨fun _ => h₁, fun _ => h₂.1, fun _ => h₂.1⟩, _⟩\n    exact supports_insert.2 ⟨⟨fun _ => h₂.2 _ W, fun _ => h₂.1⟩, q_ih H₁ h₂.2⟩\n  -- pred\n  · refine' supports_insert.2 ⟨⟨fun _ => h₁, fun _ => h₂.2 _ (or.inl W), fun _ => h₂.1, fun _ => h₂.1⟩, _⟩\n    refine' supports_insert.2 ⟨⟨fun _ => h₂.2 _ (or.inr W), fun _ => h₂.1⟩, _⟩\n    refine' supports_union.2 ⟨_, _⟩\n    · exact q_ih_q₁ H₁.1 fun _ h => h₂.2 _ (or.inl h)\n    · exact q_ih_q₂ H₁.2 fun _ h => h₂.2 _ (or.inr h)\n  -- ret\n  · exact supports_singleton.2 (ret_supports H₁)\n#align tr_stmts₁_supports tr_stmts₁_supports\n\n",
 "tr_stmts₁_self":
 "theorem tr_stmts₁_self (q) : q ∈ tr_stmts₁ q := by\n  induction q <;> · first |apply Finset.mem_singleton_self|apply Finset.mem_insert_self\n#align tr_stmts₁_self tr_stmts₁_self\n\n",
 "tr_ret_respects":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem tr_ret_respects (k v s) :\n    ∃ b₂,\n      tr_cfg (step_ret k v) b₂ ∧\n        reaches₁ (TM2.step tr) ⟨some (Λ'.ret (tr_cont k)), s, K'.elim (tr_list v) [] [] (tr_cont_stack k)⟩ b₂ :=\n  by\n  induction k generalizing v s\n  case halt => exact ⟨_, rfl, trans_gen.single rfl⟩\n  case cons₁ fs as k IH =>\n    obtain ⟨s', h₁, h₂⟩ := tr_normal_respects fs (cont.cons₂ v k) as none\n    refine' ⟨s', h₁, trans_gen.head rfl _⟩; simp\n    refine' (move₂_ok (by decide) _ (split_at_pred_ff _)).trans _; · rfl; simp\n    refine' (move₂_ok (by decide) _ _).trans _; pick_goal 4; · rfl\n    pick_goal 4;\n    · exact split_at_pred_eq _ _ _ (some Γ'.Cons) _ (fun x h => Bool.decide_false (tr_list_ne_Cons _ _ h)) ⟨rfl, rfl⟩\n    refine' (move₂_ok (by decide) _ (split_at_pred_ff _)).trans _; · rfl; simp\n    exact h₂\n  case cons₂ ns k IH =>\n    obtain ⟨c, h₁, h₂⟩ := IH (snum.bit ns.head v) none\n    exact ⟨c, h₁, trans_gen.head rfl <| head_stack_ok.trans h₂⟩\n  case comp f k IH =>\n    obtain ⟨s', h₁, h₂⟩ := tr_normal_respects f k v s\n    exact ⟨_, h₁, trans_gen.head rfl h₂⟩\n  case fix f k IH =>\n    rw [step_ret]\n    have :\n      if v.head = 0 then nat_end (tr_list v).head'.iget = tt ∧ (tr_list v).tail = tr_list v.tail\n      else\n        nat_end (tr_list v).head'.iget = ff ∧\n          (tr_list v).tail = (tr_nat v.head).tail ++ snum.bit Γ'.cons (tr_list v.tail) :=\n      by\n      cases' v with n\n      · exact ⟨rfl, rfl⟩\n      cases n\n      · simp\n      rw [tr_list, List.headI, tr_nat, Nat.cast_succ, num.add_one, Num.succ, list.tail]\n      cases (n : Num).succ' <;> exact ⟨rfl, rfl⟩\n    by_cases v.head = 0 <;> simp [h] at this⊢\n    · obtain ⟨c, h₁, h₂⟩ := IH v.tail (tr_list v).head'\n      refine' ⟨c, h₁, trans_gen.head rfl _⟩\n      simp [tr_cont, tr_cont_stack, this]\n      exact h₂\n    · obtain ⟨s', h₁, h₂⟩ := tr_normal_respects f (cont.fix f k) v.tail (some Γ'.cons)\n      refine' ⟨_, h₁, trans_gen.head rfl <| trans_gen.trans _ h₂⟩\n      pick_goal 3\n      simp [tr_cont, this.1]\n      convert clear_ok (split_at_pred_eq _ _ (tr_nat v.head).tail (some Γ'.cons) _ _ _) using 2\n      · simp\n      · exact fun x h => tr_nat_nat_end _ _ (List.tail_subset _ h)\n      · exact ⟨rfl, this.2⟩\n#align tr_ret_respects tr_ret_respects\n\n",
 "tr_respects":
 "theorem tr_respects : respects step (TM2.step tr) tr_cfg\n  | cfg.ret k v, _, ⟨s, rfl⟩ => tr_ret_respects _ _ _\n  | cfg.halt v, _, rfl => rfl\n#align tr_respects tr_respects\n\n",
 "tr_pos_num_nat_end":
 "theorem tr_pos_num_nat_end : ∀ (n), ∀ x ∈ tr_pos_num n, nat_end x = ff\n  | pos_num.one, _, or.inl rfl => rfl\n  | pos_num.bit0 n, _, or.inl rfl => rfl\n  | pos_num.bit0 n, _, or.inr h => tr_pos_num_nat_end n _ h\n  | pos_num.bit1 n, _, or.inl rfl => rfl\n  | pos_num.bit1 n, _, or.inr h => tr_pos_num_nat_end n _ h\n#align tr_pos_num_nat_end tr_pos_num_nat_end\n\n",
 "tr_num_nat_end":
 "theorem tr_num_nat_end : ∀ (n), ∀ x ∈ tr_num n, nat_end x = ff\n  | Num.pos n, x, h => tr_pos_num_nat_end n x h\n#align tr_num_nat_end tr_num_nat_end\n\n",
 "tr_normal_supports":
 "theorem tr_normal_supports {S c k} (Hk : code_supp c k ⊆ S) : (tr_normal c k).supports S :=\n  by\n  induction c generalizing k <;> simp [Λ'.supports, head]\n  case zero' => exact Finset.union_subset_right Hk\n  case succ => intro ; split_ifs <;> exact Finset.union_subset_right Hk\n  case tail => exact Finset.union_subset_right Hk\n  case cons f fs IHf IHfs => apply IHf; rw [code_supp_cons] at Hk; exact Finset.union_subset_right Hk\n  case comp f g IHf IHg => apply IHg; rw [code_supp_comp] at Hk; exact Finset.union_subset_right Hk\n  case case f g IHf IHg =>\n    simp only [code_supp_case, Finset.union_subset_iff] at Hk\n    exact ⟨IHf Hk.2.1, IHg Hk.2.2⟩\n  case fix f IHf => apply IHf; rw [code_supp_fix] at Hk; exact Finset.union_subset_right Hk\n#align tr_normal_supports tr_normal_supports\n\n",
 "tr_normal_respects":
 "theorem tr_normal_respects (c k v s) :\n    ∃ b₂,\n      tr_cfg (step_normal c k v) b₂ ∧\n        reaches₁ (TM2.step tr) ⟨some (tr_normal c (tr_cont k)), s, K'.elim (tr_list v) [] [] (tr_cont_stack k)⟩ b₂ :=\n  by\n  induction c generalizing k v s\n  case zero' => refine' ⟨_, ⟨s, rfl⟩, trans_gen.single _⟩; simp\n  case succ => refine' ⟨_, ⟨none, rfl⟩, head_main_ok.trans succ_ok⟩\n  case tail =>\n    let o : option Γ' := list.cases_on v none fun _ _ => some Γ'.cons\n    refine' ⟨_, ⟨o, rfl⟩, _⟩; convert clear_ok _; simp; swap\n    refine' split_at_pred_eq _ _ (tr_nat v.head) _ _ (tr_nat_nat_end _) _\n    cases v <;> simp\n  case cons f fs IHf IHfs =>\n    obtain ⟨c, h₁, h₂⟩ := IHf (cont.cons₁ fs v k) v none\n    refine' ⟨c, h₁, trans_gen.head rfl <| (move_ok (by decide) (split_at_pred_ff _)).trans _⟩\n    simp [step_normal]\n    refine' (copy_ok _ none [] (tr_list v).reverse _ _).trans _\n    convert h₂ using 2\n    simp [List.reverseAux_eq, tr_cont_stack]\n  case comp f g IHf IHg => exact IHg (cont.comp f k) v s\n  case case f g IHf IHg =>\n    rw [step_normal]\n    obtain ⟨s', h⟩ := pred_ok _ _ s v _ _\n    cases' v.head with n\n    · obtain ⟨c, h₁, h₂⟩ := IHf k _ s'\n      exact ⟨_, h₁, h.trans h₂⟩\n    · obtain ⟨c, h₁, h₂⟩ := IHg k _ s'\n      exact ⟨_, h₁, h.trans h₂⟩\n  case fix f IH => apply IH\n#align tr_normal_respects tr_normal_respects\n\n",
 "tr_nat_zero":
 "@[simp]\ntheorem tr_nat_zero : tr_nat 0 = [] := by rw [tr_nat, Nat.cast_zero] <;> rfl\n#align tr_nat_zero tr_nat_zero\n\n",
 "tr_nat_nat_end":
 "theorem tr_nat_nat_end (n) : ∀ x ∈ tr_nat n, nat_end x = ff :=\n  tr_num_nat_end _\n#align tr_nat_nat_end tr_nat_nat_end\n\n",
 "tr_nat_default":
 "@[simp]\ntheorem tr_nat_default : tr_nat default = [] :=\n  tr_nat_zero\n#align tr_nat_default tr_nat_default\n\n",
 "tr_list_ne_Cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem tr_list_ne_Cons : ∀ (l), ∀ x ∈ tr_list l, x ≠ Γ'.Cons\n  | snum.bit a l, x, h => by\n    simp [tr_list] at h\n    obtain h | rfl | h := h\n    · rintro rfl\n      cases tr_nat_nat_end _ _ h\n    · rintro ⟨⟩\n    · exact tr_list_ne_Cons l _ h\n#align tr_list_ne_Cons tr_list_ne_Cons\n\n",
 "tr_init":
 "theorem tr_init (c v) : ∃ b, tr_cfg (step_normal c cont.halt v) b ∧ reaches₁ (TM2.step tr) (init c v) b :=\n  tr_normal_respects _ _ _ _\n#align tr_init tr_init\n\n",
 "tr_eval":
 "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> code.eval c v :=\n  by\n  obtain ⟨i, h₁, h₂⟩ := tr_init c v\n  refine' Part.ext fun x => _\n  rw [reaches_eval h₂.to_refl]; simp\n  refine' ⟨fun h => _, _⟩\n  · obtain ⟨c, hc₁, hc₂⟩ := tr_eval_rev tr_respects h₁ h\n    simp [step_normal_eval] at hc₂\n    obtain ⟨v', hv, rfl⟩ := hc₂\n    exact ⟨_, hv, hc₁.symm⟩\n  · rintro ⟨v', hv, rfl⟩\n    have := tr_eval tr_respects h₁\n    simp [step_normal_eval] at this\n    obtain ⟨_, ⟨⟩, h⟩ := this _ hv rfl\n    exact h\n#align tr_eval tr_eval\n\n",
 "then_eval":
 "theorem cont.then_eval {k k' : cont} {v} : (k.then k').eval v = k.eval v >>= k'.eval :=\n  by\n  induction k generalizing v <;> simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]\n  · simp only [← k_ih]\n  · split_ifs <;> [rfl, simp only [← k_ih, bind_assoc]]\n#align cont.then_eval cont.then_eval\n\n",
 "supports_union":
 "theorem supports_union {K₁ K₂ S} : supports (K₁ ∪ K₂) S ↔ supports K₁ S ∧ supports K₂ S := by\n  simp [supports, or_imp, forall_and]\n#align supports_union supports_union\n\n",
 "supports_singleton":
 "theorem supports_singleton {S q} : supports {q} S ↔ TM2.supports_stmt S (tr q) := by simp [supports]\n#align supports_singleton supports_singleton\n\n",
 "supports_insert":
 "theorem supports_insert {K S q} : supports (insert q K) S ↔ TM2.supports_stmt S (tr q) ∧ supports K S := by\n  simp [supports]\n#align supports_insert supports_insert\n\n",
 "supports_bUnion":
 "theorem supports_bUnion {K : option Γ' → Finset Λ'} {S} : supports (finset.univ.bUnion K) S ↔ ∀ a, supports (K a) S :=\n  by simp [supports] <;> apply forall_swap\n#align supports_bUnion supports_bUnion\n\n",
 "succ_ok":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem succ_ok {q s n} {c d : list Γ'} :\n    reaches₁ (TM2.step tr) ⟨some (Λ'.succ q), s, K'.elim (tr_list [n]) [] c d⟩\n      ⟨some q, none, K'.elim (tr_list [n.succ]) [] c d⟩ :=\n  by\n  simp [tr_nat, num.add_one]\n  cases' (n : Num) with a\n  · refine' trans_gen.head rfl _\n    simp\n    rw [if_neg]\n    swap\n    rintro ⟨⟩\n    rw [if_pos]\n    swap\n    rfl\n    convert unrev_ok\n    simp\n    rfl\n  simp [Num.succ, tr_num, Num.succ']\n  suffices\n    ∀ l₁,\n      ∃ l₁' l₂' s',\n        List.reverseAux l₁ (tr_pos_num a.succ) = List.reverseAux l₁' l₂' ∧\n          reaches₁ (TM2.step tr) ⟨some q.succ, s, K'.elim (tr_pos_num a ++ [Γ'.cons]) l₁ c d⟩\n            ⟨some (unrev q), s', K'.elim (l₂' ++ [Γ'.cons]) l₁' c d⟩\n    by\n    obtain ⟨l₁', l₂', s', e, h⟩ := this []\n    simp [List.reverseAux] at e\n    refine' h.trans _\n    convert unrev_ok using 2\n    simp [e, List.reverseAux_eq]\n  induction' a with m IH m IH generalizing s <;> intro l₁\n  · refine' ⟨snum.bit Γ'.bit0 l₁, [Γ'.bit1], some Γ'.cons, rfl, trans_gen.head rfl (trans_gen.single _)⟩\n    simp [tr_pos_num]\n  · obtain ⟨l₁', l₂', s', e, h⟩ := IH (snum.bit Γ'.bit0 l₁)\n    refine' ⟨l₁', l₂', s', e, trans_gen.head _ h⟩\n    swap\n    simp [PosNum.succ, tr_pos_num]\n  · refine' ⟨l₁, _, some Γ'.bit0, rfl, trans_gen.single _⟩\n    simp\n    rfl\n#align succ_ok succ_ok\n\n",
 "step_ret_then":
 "/-- The `step_ret` function respects the `then k'` homomorphism. Note that this is an exact\nequality, not a simulation; the original and embedded machines move in lock-step until the\nembedded machine reaches the halt state. -/\ntheorem step_ret_then {k k' : cont} {v} : step_ret (k.then k') v = (step_ret k v).then k' :=\n  by\n  induction k generalizing v <;> simp only [cont.then, step_ret, cfg.then, *]\n  · rw [← step_normal_then]\n    rfl\n  · rw [← step_normal_then]\n  · split_ifs\n    · rw [← k_ih]\n    · rw [← step_normal_then]\n      rfl\n#align step_ret_then step_ret_then\n\n",
 "step_ret_eval":
 "theorem step_ret_eval {k v} : eval step (step_ret k v) = cfg.halt <$> k.eval v :=\n  by\n  induction k generalizing v\n  case halt =>\n    simp only [mem_eval, cont.eval, map_pure]\n    exact Part.eq_some_iff.2 (mem_eval.2 ⟨refl_trans_gen.refl, rfl⟩)\n  case cons₁ fs as k IH =>\n    rw [cont.eval, step_ret, code_is_ok]\n    simp only [← bind_pure_comp_eq_map, bind_assoc]; congr ; funext v'\n    rw [reaches_eval]; swap; exact refl_trans_gen.single rfl\n    rw [step_ret, IH, bind_pure_comp_eq_map]\n  case cons₂ ns k IH => rw [cont.eval, step_ret]; exact IH\n  case comp f k IH =>\n    rw [cont.eval, step_ret, code_is_ok]\n    simp only [← bind_pure_comp_eq_map, bind_assoc]; congr ; funext v'\n    rw [reaches_eval]; swap; exact refl_trans_gen.single rfl\n    rw [IH, bind_pure_comp_eq_map]\n  case fix f k IH =>\n    rw [cont.eval, step_ret]; simp only [bind_pure_comp_eq_map]\n    split_ifs; · exact IH\n    simp only [← bind_pure_comp_eq_map, bind_assoc, cont_eval_fix (code_is_ok _)]\n    congr ; funext ; rw [bind_pure_comp_eq_map, ← IH]\n    exact reaches_eval (refl_trans_gen.single rfl)\n#align step_ret_eval step_ret_eval\n\n",
 "step_normal_then":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:337:16: warning: unsupported simp config option: constructor_eq -/\n/-- The `step_normal` function respects the `then k'` homomorphism. Note that this is an exact\nequality, not a simulation; the original and embedded machines move in lock-step until the\nembedded machine reaches the halt state. -/\ntheorem step_normal_then (c) (k k' : cont) (v) : step_normal c (k.then k') v = (step_normal c k v).then k' :=\n  by\n  induction c generalizing k v <;> simp only [cont.then, step_normal, cfg.then, *]\n  case cons c c' ih ih' => rw [← ih, cont.then]\n  case comp c c' ih ih' => rw [← ih', cont.then]\n  · cases v.head <;> simp only [nat.elim]\n  case fix c ih => rw [← ih, cont.then]\n#align step_normal_then step_normal_then\n\n",
 "step_normal_eval":
 "theorem step_normal_eval (c v) : eval step (step_normal c cont.halt v) = cfg.halt <$> c.eval v :=\n  (code_is_ok c).zero\n#align step_normal_eval step_normal_eval\n\n",
 "split_at_pred_ff":
 "theorem split_at_pred_ff {α} (L : list α) : split_at_pred (fun _ => false) L = (L, none, []) :=\n  split_at_pred_eq _ _ _ _ _ (fun _ _ => rfl) ⟨rfl, rfl⟩\n#align split_at_pred_ff split_at_pred_ff\n\n",
 "split_at_pred_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem split_at_pred_eq {α} (p : α → bool) :\n    ∀ L l₁ o l₂,\n      (∀ x ∈ l₁, p x = ff) →\n        Option.elim' (L = l₁ ∧ l₂ = []) (fun a => p a = tt ∧ L = l₁ ++ snum.bit a l₂) o →\n          split_at_pred p L = (l₁, o, l₂)\n  | [], _, none, _, _, ⟨rfl, rfl⟩ => rfl\n  | [], l₁, some o, l₂, h₁, ⟨h₂, h₃⟩ => by simp at h₃ <;> contradiction\n  | snum.bit a L, l₁, o, l₂, h₁, h₂ => by\n    rw [split_at_pred]\n    have IH := split_at_pred_eq L\n    cases o\n    · cases' l₁ with a' l₁ <;> rcases h₂ with ⟨⟨⟩, rfl⟩\n      rw [h₁ a (or.inl rfl), cond, IH L none [] _ ⟨rfl, rfl⟩]\n      rfl\n      exact fun x h => h₁ x (or.inr h)\n    · cases' l₁ with a' l₁ <;> rcases h₂ with ⟨h₂, ⟨⟩⟩\n      · rw [h₂, cond]\n      rw [h₁ a (or.inl rfl), cond, IH l₁ (some o) l₂ _ ⟨h₂, _⟩] <;> try rfl\n      exact fun x h => h₁ x (or.inr h)\n#align split_at_pred_eq split_at_pred_eq\n\n",
 "ret_supports":
 "theorem ret_supports {S k} (H₁ : cont_supp k ⊆ S) : TM2.supports_stmt S (tr (Λ'.ret k)) :=\n  by\n  have W := fun {q} => tr_stmts₁_self q\n  cases k\n  case halt => trivial\n  case cons₁ => rw [cont_supp_cons₁, Finset.union_subset_iff] at H₁; exact fun _ => H₁.1 W\n  case cons₂ => rw [cont_supp_cons₂, Finset.union_subset_iff] at H₁; exact fun _ => H₁.1 W\n  case comp => rw [cont_supp_comp] at H₁; exact fun _ => H₁ (code_supp_self _ _ W)\n  case fix =>\n    rw [cont_supp_fix] at H₁\n    have L := @Finset.mem_union_left; have R := @Finset.mem_union_right\n    intro s; dsimp only; cases nat_end s.iget\n    · refine' H₁ (R _ <| L _ <| R _ <| R _ <| L _ W)\n    · exact H₁ (R _ <| L _ <| R _ <| R _ <| R _ <| Finset.mem_singleton_self _)\n#align ret_supports ret_supports\n\n",
 "pred_ok":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem pred_ok (q₁ q₂ s v) (c d : list Γ') :\n    ∃ s',\n      reaches₁ (TM2.step tr) ⟨some (Λ'.pred q₁ q₂), s, K'.elim (tr_list v) [] c d⟩\n        (v.head.elim ⟨some q₁, s', K'.elim (tr_list v.tail) [] c d⟩ fun n _ =>\n          ⟨some q₂, s', K'.elim (tr_list (snum.bit n v.tail)) [] c d⟩) :=\n  by\n  rcases v with (_ | ⟨_ | n, v⟩)\n  · refine' ⟨none, trans_gen.single _⟩\n    simp\n    rfl\n  · refine' ⟨some Γ'.cons, trans_gen.single _⟩\n    simp\n  refine' ⟨none, _⟩\n  simp [tr_nat, num.add_one, Num.succ, tr_num]\n  cases' (n : Num) with a\n  · simp [tr_pos_num, tr_num, show num.zero.succ' = pos_num.one from rfl]\n    refine' trans_gen.head rfl _\n    convert unrev_ok\n    simp\n    rfl\n  simp [tr_num, Num.succ']\n  suffices\n    ∀ l₁,\n      ∃ l₁' l₂' s',\n        List.reverseAux l₁ (tr_pos_num a) = List.reverseAux l₁' l₂' ∧\n          reaches₁ (TM2.step tr)\n            ⟨some (q₁.pred q₂), s, K'.elim (tr_pos_num a.succ ++ snum.bit Γ'.cons (tr_list v)) l₁ c d⟩\n            ⟨some (unrev q₂), s', K'.elim (l₂' ++ snum.bit Γ'.cons (tr_list v)) l₁' c d⟩\n    by\n    obtain ⟨l₁', l₂', s', e, h⟩ := this []\n    simp [List.reverseAux] at e\n    refine' h.trans _\n    convert unrev_ok using 2\n    simp [e, List.reverseAux_eq]\n  induction' a with m IH m IH generalizing s <;> intro l₁\n  · refine' ⟨snum.bit Γ'.bit1 l₁, [], some Γ'.cons, rfl, trans_gen.head rfl (trans_gen.single _)⟩\n    simp [tr_pos_num, show pos_num.one.succ = pos_num.one.bit0 from rfl]\n  · obtain ⟨l₁', l₂', s', e, h⟩ := IH (some Γ'.bit0) (snum.bit Γ'.bit1 l₁)\n    refine' ⟨l₁', l₂', s', e, trans_gen.head _ h⟩\n    simp\n    rfl\n  · obtain ⟨a, l, e, h⟩ : ∃ a l, tr_pos_num m = snum.bit a l ∧ nat_end a = ff := by cases m <;> refine' ⟨_, _, rfl, rfl⟩\n    refine' ⟨snum.bit Γ'.bit0 l₁, _, some a, rfl, trans_gen.single _⟩\n    simp [tr_pos_num, PosNum.succ, e, h, nat_end, show some Γ'.bit1 ≠ some Γ'.bit0 by decide]\n#align pred_ok pred_ok\n\n",
 "pred_eval":
 "@[simp]\ntheorem pred_eval (v) : pred.eval v = pure [v.head.pred] := by simp [pred] <;> cases v.head <;> simp\n#align pred_eval pred_eval\n\n",
 "nil_eval":
 "/-\nCopyright (c) 2020 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n@[simp]\ntheorem nil_eval (v) : nil.eval v = pure [] := by simp [nil]\n#align nil_eval nil_eval\n\n",
 "move₂_ok":
 "theorem move₂_ok {p k₁ k₂ q s L₁ o L₂} {S : K' → list Γ'} (h₁ : k₁ ≠ rev ∧ k₂ ≠ rev ∧ k₁ ≠ k₂) (h₂ : S rev = [])\n    (e : split_at_pred p (S k₁) = (L₁, o, L₂)) :\n    reaches₁ (TM2.step tr) ⟨some (move₂ p k₁ k₂ q), s, S⟩\n      ⟨some q, none, update (update S k₁ (o.elim id list.cons L₂)) k₂ (L₁ ++ S k₂)⟩ :=\n  by\n  refine' (move_ok h₁.1 e).trans (trans_gen.head rfl _)\n  cases o <;> simp only [Option.elim', tr, id.def]\n  · convert move_ok h₁.2.1.symm (split_at_pred_ff _) using 2\n    simp only [function.update_comm h₁.1, function.update_idem]\n    rw [show update S rev [] = S by rw [← h₂, function.update_eq_self]]\n    simp only [function.update_noteq h₁.2.2.symm, function.update_noteq h₁.2.1, function.update_noteq h₁.1.symm,\n      List.reverseAux_eq, h₂, function.update_same, list.append_nil, List.reverse_reverse]\n  · convert move_ok h₁.2.1.symm (split_at_pred_ff _) using 2\n    simp only [h₂, function.update_comm h₁.1, List.reverseAux_eq, function.update_same, list.append_nil,\n      function.update_idem]\n    rw [show update S rev [] = S by rw [← h₂, function.update_eq_self]]\n    simp only [function.update_noteq h₁.1.symm, function.update_noteq h₁.2.2.symm, function.update_noteq h₁.2.1,\n      function.update_same, List.reverse_reverse]\n#align move₂_ok move₂_ok\n\n",
 "move_ok":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem move_ok {p k₁ k₂ q s L₁ o L₂} {S : K' → list Γ'} (h₁ : k₁ ≠ k₂) (e : split_at_pred p (S k₁) = (L₁, o, L₂)) :\n    reaches₁ (TM2.step tr) ⟨some (Λ'.move p k₁ k₂ q), s, S⟩\n      ⟨some q, o, update (update S k₁ L₂) k₂ (L₁.reverse_core (S k₂))⟩ :=\n  by\n  induction' L₁ with a L₁ IH generalizing S s\n  · rw [(_ : [].reverse_core _ = _), function.update_eq_self]\n    swap\n    · rw [function.update_noteq h₁.symm]\n      rfl\n    refine' trans_gen.head' rfl _\n    simp\n    cases' S k₁ with a Sk\n    · cases e\n      rfl\n    simp [split_at_pred] at e⊢\n    cases p a <;> simp at e⊢\n    · revert e\n      rcases split_at_pred p Sk with ⟨_, _, _⟩\n      rintro ⟨⟩\n    · simp only [e]\n  · refine' trans_gen.head rfl _\n    simp\n    cases' e₁ : S k₁ with a' Sk <;> rw [e₁, split_at_pred] at e\n    · cases e\n    cases e₂ : p a' <;> simp only [e₂, cond] at e\n    swap\n    · cases e\n    rcases e₃ : split_at_pred p Sk with ⟨_, _, _⟩\n    rw [e₃, split_at_pred] at e\n    cases e\n    simp [e₂]\n    convert @IH (update (update S k₁ Sk) k₂ (snum.bit a (S k₂))) _ _ using 2 <;>\n      simp [function.update_noteq, h₁, h₁.symm, e₃, List.reverseAux]\n    simp [function.update_comm h₁.symm]\n#align move_ok move_ok\n\n",
 "is_ret":
 "theorem step_normal.is_ret (c k v) : ∃ k' v', step_normal c k v = cfg.ret k' v' :=\n  by\n  induction c generalizing k v\n  iterate 3 exact ⟨_, _, rfl⟩\n  case cons f fs IHf IHfs => apply IHf\n  case comp f g IHf IHg => apply IHg\n  case case f g IHf IHg => rw [step_normal]; cases v.head <;> simp only [nat.elim] <;> [apply IHf, apply IHg]\n  case fix f IHf => apply IHf\n#align step_normal.is_ret step_normal.is_ret\n\n",
 "id_eval":
 "@[simp]\ntheorem id_eval (v) : id.eval v = pure v := by simp [id]\n#align id_eval id_eval\n\n",
 "head_supports":
 "theorem head_supports {S k q} (H : (q : Λ').supports S) : (head k q).supports S := fun _ => by\n  dsimp only <;> split_ifs <;> exact H\n#align head_supports head_supports\n\n",
 "head_stack_ok":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\ntheorem head_stack_ok {q s L₁ L₂ L₃} :\n    reaches₁ (TM2.step tr) ⟨some (head stack q), s, K'.elim (tr_list L₁) [] [] (tr_list L₂ ++ snum.bit Γ'.Cons L₃)⟩\n      ⟨some q, none, K'.elim (tr_list (snum.bit L₂.head L₁)) [] [] L₃⟩ :=\n  by\n  cases' L₂ with a L₂\n  · refine'\n      trans_gen.trans (move_ok (by decide) (split_at_pred_eq _ _ [] (some Γ'.Cons) L₃ (by rintro _ ⟨⟩) ⟨rfl, rfl⟩))\n        (trans_gen.head rfl (trans_gen.head rfl _))\n    convert unrev_ok\n    simp\n    rfl\n  · refine'\n      trans_gen.trans\n        (move_ok (by decide)\n          (split_at_pred_eq _ _ (tr_nat a) (some Γ'.cons) (tr_list L₂ ++ snum.bit Γ'.Cons L₃) (tr_nat_nat_end _)\n            ⟨rfl, by simp⟩))\n        (trans_gen.head rfl (trans_gen.head rfl _))\n    simp\n    refine'\n      trans_gen.trans\n        (clear_ok\n          (split_at_pred_eq _ _ (tr_list L₂) (some Γ'.Cons) L₃ (fun x h => Bool.decide_false (tr_list_ne_Cons _ _ h))\n            ⟨rfl, by simp⟩))\n        _\n    convert unrev_ok\n    simp [List.reverseAux_eq]\n#align head_stack_ok head_stack_ok\n\n",
 "head_main_ok":
 "theorem head_main_ok {q s L} {c d : list Γ'} :\n    reaches₁ (TM2.step tr) ⟨some (head main q), s, K'.elim (tr_list L) [] c d⟩\n      ⟨some q, none, K'.elim (tr_list [L.head]) [] c d⟩ :=\n  by\n  let o : option Γ' := list.cases_on L none fun _ _ => some Γ'.cons\n  refine'\n    (move_ok (by decide) (split_at_pred_eq _ _ (tr_nat L.head) o (tr_list L.tail) (tr_nat_nat_end _) _)).trans\n      (trans_gen.head rfl (trans_gen.head rfl _))\n  · cases L <;> simp\n  simp\n  rw [if_neg (show o ≠ some Γ'.Cons by cases L <;> rintro ⟨⟩)]\n  refine' (clear_ok (split_at_pred_eq _ _ _ none [] _ ⟨rfl, rfl⟩)).trans _\n  · exact fun x h => Bool.decide_false (tr_list_ne_Cons _ _ h)\n  convert unrev_ok; simp [List.reverseAux_eq]\n#align head_main_ok head_main_ok\n\n",
 "head_eval":
 "@[simp]\ntheorem head_eval (v) : head.eval v = pure [v.head] := by simp [head]\n#align head_eval head_eval\n\n",
 "exists_code":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `snum.bit -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem exists_code {n} {f : «expr →. » (Vector ℕ n) ℕ} (hf : nat.partrec' f) :\n    ∃ c : code, ∀ v : Vector ℕ n, c.eval v.1 = pure <$> f v :=\n  by\n  induction' hf with n f hf\n  induction hf\n  case prim.zero => exact ⟨zero', fun ⟨[], _⟩ => rfl⟩\n  case prim.succ => exact ⟨succ, fun ⟨[v], _⟩ => rfl⟩\n  case prim.nth n i =>\n    refine' Fin.succRec (fun n => _) (fun n i IH => _) i\n    · exact ⟨head, fun ⟨list.cons a as, _⟩ => by simp <;> rfl⟩\n    · obtain ⟨c, h⟩ := IH\n      exact ⟨c.comp tail, fun v => by simpa [← vector.nth_tail] using h v.tail⟩\n  case prim.comp m n f g hf hg IHf IHg => simpa [Part.bind_eq_bind] using exists_code.comp IHf IHg\n  case prim.prec n f g hf hg IHf IHg =>\n    obtain ⟨cf, hf⟩ := IHf\n    obtain ⟨cg, hg⟩ := IHg\n    simp only [Part.map_eq_map, Part.map_some, pfun.coe_val] at hf hg\n    refine' ⟨prec cf cg, fun v => _⟩\n    rw [← v.cons_head_tail]\n    specialize hf v.tail\n    replace hg := fun a b => hg («expr ::ᵥ » a («expr ::ᵥ » b v.tail))\n    simp only [vector.cons_val, vector.tail_val] at hf hg\n    simp only [Part.map_eq_map, Part.map_some, vector.cons_val, vector.cons_tail, vector.cons_head, pfun.coe_val,\n      vector.tail_val]\n    simp only [← Part.pure_eq_some] at hf hg⊢\n    induction' v.head with n IH <;>\n      simp [prec, hf, bind_assoc, ← Part.map_eq_map, ← bind_pure_comp_eq_map, show ∀ x, pure x = [x] from fun _ => rfl,\n        -subtype.val_eq_coe]\n    suffices\n      ∀ a b,\n        a + b = n →\n          (snum.bit n.succ\n                (snum.bit 0\n                  (snum.bit\n                    (g\n                      («expr ::ᵥ » n\n                        («expr ::ᵥ » (nat.elim (f v.tail) (fun y IH => g («expr ::ᵥ » y («expr ::ᵥ » IH v.tail))) n)\n                          v.tail)))\n                    v.val.tail)) :\n              list ℕ) ∈\n            pfun.fix\n              (fun v : list ℕ => do\n                let x ← cg.eval (snum.bit v.head v.tail.tail)\n                pure <|\n                    if v = 0 then sum.inl (snum.bit v (snum.bit v (snum.bit x.head v)) : list ℕ)\n                    else sum.inr (snum.bit v (snum.bit v (snum.bit x.head v))))\n              (snum.bit a\n                (snum.bit b\n                  (snum.bit (nat.elim (f v.tail) (fun y IH => g («expr ::ᵥ » y («expr ::ᵥ » IH v.tail))) a)\n                    v.val.tail)))\n      by\n      rw [(_ : pfun.fix _ _ = pure _)]\n      swap\n      exact Part.eq_some_iff.2 (this 0 n (zero_add n))\n      simp only [List.headI, pure_bind, List.tail_cons]\n    intro a b e\n    induction' b with b IH generalizing a e\n    · refine' pfun.mem_fix_iff.2 (or.inl <| Part.eq_some_iff.1 _)\n      simp only [hg, ← e, pure_bind, List.tail_cons]\n      rfl\n    · refine' pfun.mem_fix_iff.2 (or.inr ⟨_, _, IH (a + 1) (by rwa [add_right_comm])⟩)\n      simp only [hg, eval, pure_bind, nat.elim_succ, list.tail]\n      exact Part.mem_some_iff.2 rfl\n  case comp m n f g hf hg IHf IHg => exact exists_code.comp IHf IHg\n  case rfind n f hf IHf =>\n    obtain ⟨cf, hf⟩ := IHf; refine' ⟨rfind cf, fun v => _⟩\n    replace hf := fun a => hf («expr ::ᵥ » a v)\n    simp only [Part.map_eq_map, Part.map_some, vector.cons_val, pfun.coe_val,\n      show ∀ x, pure x = [x] from fun _ => rfl] at hf⊢\n    refine' Part.ext fun x => _\n    simp only [rfind, Part.bind_eq_bind, Part.pure_eq_some, Part.map_eq_map, Part.bind_some, exists_prop, eval,\n      List.headI, pred_eval, Part.map_some, Bool.false_eq_decide_iff, Part.mem_bind_iff, list.length, Part.mem_map_iff,\n      nat.mem_rfind, list.tail, Bool.true_eq_decide_iff, Part.mem_some_iff, Part.map_bind]\n    constructor\n    · rintro ⟨v', h1, rfl⟩\n      suffices\n        ∀ v₁ : list ℕ,\n          v' ∈\n              pfun.fix\n                (fun v =>\n                  (cf.eval v).bind fun y =>\n                    Part.some <|\n                      if y.head = 0 then sum.inl (snum.bit v.head.succ v.tail)\n                      else sum.inr (snum.bit v.head.succ v.tail))\n                v₁ →\n            ∀ n,\n              v₁ = snum.bit n v.val →\n                (∀ m < n, ¬f («expr ::ᵥ » m v) = 0) →\n                  ∃ a : ℕ,\n                    (f («expr ::ᵥ » a v) = 0 ∧ ∀ {m : ℕ}, m < a → ¬f («expr ::ᵥ » m v) = 0) ∧ [a] = [v'.head.pred]\n        by exact this _ h1 0 rfl (by rintro _ ⟨⟩)\n      clear h1\n      intro v₀ h1\n      refine' pfun.fix_induction h1 fun v₁ h2 IH => _\n      clear h1\n      rintro n rfl hm\n      have := pfun.mem_fix_iff.1 h2\n      simp only [hf, Part.bind_some] at this\n      split_ifs  at this\n      · simp only [List.headI, exists_false, or_false_iff, Part.mem_some_iff, List.tail_cons, false_and_iff] at this\n        subst this\n        exact ⟨_, ⟨h, hm⟩, rfl⟩\n      · refine' IH (snum.bit n.succ v.val) (by simp_all) _ rfl fun m h' => _\n        obtain h | rfl := Nat.lt_succ_iff_lt_or_eq.1 h'\n        exacts[hm _ h, h]\n    · rintro ⟨n, ⟨hn, hm⟩, rfl⟩\n      refine' ⟨snum.bit n.succ v.1, _, rfl⟩\n      have :\n        (snum.bit n.succ v.1 : list ℕ) ∈\n          pfun.fix\n            (fun v =>\n              (cf.eval v).bind fun y =>\n                Part.some <|\n                  if y.head = 0 then sum.inl (snum.bit v.head.succ v.tail) else sum.inr (snum.bit v.head.succ v.tail))\n            (snum.bit n v.val) :=\n        pfun.mem_fix_iff.2 (or.inl (by simp [hf, hn, -subtype.val_eq_coe]))\n      generalize (snum.bit n.succ v.1 : list ℕ) = w at this⊢\n      clear hn\n      induction' n with n IH\n      · exact this\n      refine' IH (fun m h' => hm (nat.lt_succ_of_lt h')) (pfun.mem_fix_iff.2 (or.inr ⟨_, _, this⟩))\n      simp only [hf, hm n.lt_succ_self, Part.bind_some, List.headI, eq_self_iff_true, if_false, Part.mem_some_iff,\n        and_self_iff, List.tail_cons]\n#align exists_code exists_code\n\n",
 "elim_update_stack":
 "@[simp]\ntheorem K'.elim_update_stack {a b c d d'} : update (K'.elim a b c d) stack d' = K'.elim a b c d' := by\n  funext x <;> cases x <;> rfl\n#align K'.elim_update_stack K'.elim_update_stack\n\n",
 "elim_update_rev":
 "@[simp]\ntheorem K'.elim_update_rev {a b c d b'} : update (K'.elim a b c d) rev b' = K'.elim a b' c d := by\n  funext x <;> cases x <;> rfl\n#align K'.elim_update_rev K'.elim_update_rev\n\n",
 "elim_update_main":
 "@[simp]\ntheorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d := by\n  funext x <;> cases x <;> rfl\n#align K'.elim_update_main K'.elim_update_main\n\n",
 "elim_update_aux":
 "@[simp]\ntheorem K'.elim_update_aux {a b c d c'} : update (K'.elim a b c d) aux c' = K'.elim a b c' d := by\n  funext x <;> cases x <;> rfl\n#align K'.elim_update_aux K'.elim_update_aux\n\n",
 "copy_ok":
 "theorem copy_ok (q s a b c d) :\n    reaches₁ (TM2.step tr) ⟨some (Λ'.copy q), s, K'.elim a b c d⟩\n      ⟨some q, none, K'.elim (List.reverseAux b a) [] c (List.reverseAux b d)⟩ :=\n  by\n  induction' b with x b IH generalizing a d s\n  · refine' trans_gen.single _\n    simp\n    rfl\n  refine' trans_gen.head rfl _; simp; exact IH _ _ _\n#align copy_ok copy_ok\n\n",
 "cont_supp_supports":
 "theorem cont_supp_supports {S k} (H : cont_supp k ⊆ S) : supports (cont_supp k) S :=\n  by\n  induction k\n  · simp [cont_supp_halt, supports]\n  case cons₁ f k IH =>\n    have H₁ := H; rw [cont_supp_cons₁] at H₁; have H₂ := Finset.union_subset_right H₁\n    refine' tr_stmts₁_supports' (tr_normal_supports H₂) H₁ fun h => _\n    refine' supports_union.2 ⟨code_supp'_supports H₂, _⟩\n    simp only [code_supp, cont_supp_cons₂, Finset.union_subset_iff] at H₂\n    exact tr_stmts₁_supports' (head_supports H₂.2.2) (Finset.union_subset_right h) IH\n  case cons₂ k IH =>\n    have H' := H; rw [cont_supp_cons₂] at H'\n    exact tr_stmts₁_supports' (head_supports <| Finset.union_subset_right H') H' IH\n  case comp f k IH =>\n    have H' := H; rw [cont_supp_comp] at H'; have H₂ := Finset.union_subset_right H'\n    exact supports_union.2 ⟨code_supp'_supports H', IH H₂⟩\n  case fix f k IH =>\n    rw [cont_supp] at H\n    exact supports_union.2 ⟨code_supp'_supports H, IH (Finset.union_subset_right H)⟩\n#align cont_supp_supports cont_supp_supports\n\n",
 "cont_supp_halt":
 "@[simp]\ntheorem cont_supp_halt : cont_supp cont'.halt = ∅ :=\n  rfl\n#align cont_supp_halt cont_supp_halt\n\n",
 "cont_supp_fix":
 "theorem cont_supp_fix (f k) : cont_supp (cont'.fix f k) = code_supp f (cont'.fix f k) := by\n  simp (config := { contextual := true }) [code_supp, code_supp', cont_supp, Finset.union_assoc, Finset.subset_iff]\n#align cont_supp_fix cont_supp_fix\n\n",
 "cont_supp_cons₂":
 "@[simp]\ntheorem cont_supp_cons₂ (k) : cont_supp (cont'.cons₂ k) = tr_stmts₁ (head stack <| Λ'.ret k) ∪ cont_supp k :=\n  rfl\n#align cont_supp_cons₂ cont_supp_cons₂\n\n",
 "cont_supp_cons₁":
 "@[simp]\ntheorem cont_supp_cons₁ (fs k) :\n    cont_supp (cont'.cons₁ fs k) =\n      tr_stmts₁\n          (move₂ (fun _ => false) main aux <|\n            move₂ (fun s => s = Γ'.Cons) stack main <|\n              move₂ (fun _ => false) aux stack <| tr_normal fs (cont'.cons₂ k)) ∪\n        code_supp fs (cont'.cons₂ k) :=\n  by simp [code_supp, code_supp', cont_supp, Finset.union_assoc]\n#align cont_supp_cons₁ cont_supp_cons₁\n\n",
 "cont_supp_comp":
 "@[simp]\ntheorem cont_supp_comp (f k) : cont_supp (cont'.comp f k) = code_supp f k :=\n  rfl\n#align cont_supp_comp cont_supp_comp\n\n",
 "cont_eval_fix":
 "theorem cont_eval_fix {f k v} (fok : code.ok f) :\n    eval step (step_normal f (cont.fix f k) v) = f.fix.eval v >>= fun v => eval step (cfg.ret k v) :=\n  by\n  refine' Part.ext fun x => _\n  simp only [Part.bind_eq_bind, Part.mem_bind_iff]\n  constructor\n  · suffices\n      ∀ c,\n        x ∈ eval step c →\n          ∀ v c',\n            c = cfg.then c' (cont.fix f k) →\n              reaches step (step_normal f cont.halt v) c' →\n                ∃ v₁ ∈ f.eval v,\n                  ∃ v₂ ∈ if List.headI v₁ = 0 then pure v₁.tail else f.fix.eval v₁.tail, x ∈ eval step (cfg.ret k v₂)\n      by\n      intro h\n      obtain ⟨v₁, hv₁, v₂, hv₂, h₃⟩ := this _ h _ _ (step_normal_then _ cont.halt _ _) refl_trans_gen.refl\n      refine' ⟨v₂, pfun.mem_fix_iff.2 _, h₃⟩\n      simp only [Part.eq_some_iff.2 hv₁, Part.map_some]\n      split_ifs  at hv₂⊢\n      · rw [Part.mem_some_iff.1 hv₂]\n        exact or.inl (Part.mem_some _)\n      · exact or.inr ⟨_, Part.mem_some _, hv₂⟩\n    refine' fun c he => eval_induction he fun y h IH => _\n    rintro v (⟨v'⟩ | ⟨k', v'⟩) rfl hr <;> rw [cfg.then] at h IH\n    · have := mem_eval.2 ⟨hr, rfl⟩\n      rw [fok, Part.bind_eq_bind, Part.mem_bind_iff] at this\n      obtain ⟨v'', h₁, h₂⟩ := this\n      rw [reaches_eval] at h₂\n      swap\n      exact refl_trans_gen.single rfl\n      cases Part.mem_unique h₂ (mem_eval.2 ⟨refl_trans_gen.refl, rfl⟩)\n      refine' ⟨v', h₁, _⟩\n      rw [step_ret] at h\n      revert h\n      by_cases he : v'.head = 0 <;> simp only [exists_prop, if_pos, if_false, he] <;> intro h\n      · refine' ⟨_, Part.mem_some _, _⟩\n        rw [reaches_eval]\n        exact h\n        exact refl_trans_gen.single rfl\n      · obtain ⟨k₀, v₀, e₀⟩ := step_normal.is_ret f cont.halt v'.tail\n        have e₁ := step_normal_then f cont.halt (cont.fix f k) v'.tail\n        rw [e₀, cont.then, cfg.then] at e₁\n        obtain ⟨v₁, hv₁, v₂, hv₂, h₃⟩ := IH (step_ret (k₀.then (cont.fix f k)) v₀) _ v'.tail _ step_ret_then _\n        · refine' ⟨_, pfun.mem_fix_iff.2 _, h₃⟩\n          simp only [Part.eq_some_iff.2 hv₁, Part.map_some, Part.mem_some_iff]\n          split_ifs  at hv₂⊢ <;> [exact or.inl (Part.mem_some_iff.1 hv₂), exact or.inr ⟨_, rfl, hv₂⟩]\n        · rw [step_ret, if_neg he, e₁]\n          rfl\n        · apply refl_trans_gen.single\n          rw [e₀]\n          exact rfl\n    · exact IH _ rfl _ _ step_ret_then (refl_trans_gen.tail hr rfl)\n  · rintro ⟨v', he, hr⟩\n    rw [reaches_eval] at hr\n    swap\n    exact refl_trans_gen.single rfl\n    refine' pfun.fix_induction he fun v (he : v' ∈ f.fix.eval v) IH => _\n    rw [fok, Part.bind_eq_bind, Part.mem_bind_iff]\n    obtain he | ⟨v'', he₁', _⟩ := pfun.mem_fix_iff.1 he\n    · obtain ⟨v', he₁, he₂⟩ := (Part.mem_map_iff _).1 he\n      split_ifs  at he₂ <;> cases he₂\n      refine' ⟨_, he₁, _⟩\n      rw [reaches_eval]\n      swap\n      exact refl_trans_gen.single rfl\n      rwa [step_ret, if_pos h]\n    · obtain ⟨v₁, he₁, he₂⟩ := (Part.mem_map_iff _).1 he₁'\n      split_ifs  at he₂ <;> cases he₂\n      clear he₂ he₁'\n      refine' ⟨_, he₁, _⟩\n      rw [reaches_eval]\n      swap\n      exact refl_trans_gen.single rfl\n      rwa [step_ret, if_neg h]\n      exact IH v₁.tail ((Part.mem_map_iff _).2 ⟨_, he₁, if_neg h⟩)\n#align cont_eval_fix cont_eval_fix\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem exists_code.comp {m n} {f : «expr →. » (Vector ℕ n) ℕ} {g : fin n → «expr →. » (Vector ℕ m) ℕ}\n    (hf : ∃ c : code, ∀ v : Vector ℕ n, c.eval v.1 = pure <$> f v)\n    (hg : ∀ i, ∃ c : code, ∀ v : Vector ℕ m, c.eval v.1 = pure <$> g i v) :\n    ∃ c : code, ∀ v : Vector ℕ m, c.eval v.1 = pure <$> ((vector.m_of_fn fun i => g i v) >>= f) :=\n  by\n  rsuffices ⟨cg, hg⟩ : ∃ c : code, ∀ v : Vector ℕ m, c.eval v.1 = subtype.val <$> vector.m_of_fn fun i => g i v\n  · obtain ⟨cf, hf⟩ := hf\n    exact\n      ⟨cf.comp cg, fun v => by\n        simp [hg, hf, map_bind, seq_bind_eq, (· ∘ ·), -subtype.val_eq_coe]\n        rfl⟩\n  clear hf f; induction' n with n IH\n  · exact ⟨nil, fun v => by simp [vector.m_of_fn] <;> rfl⟩\n  · obtain ⟨cg, hg₁⟩ := hg 0\n    obtain ⟨cl, hl⟩ := IH fun i => hg i.succ\n    exact\n      ⟨cons cg cl, fun v =>\n        by\n        simp [vector.m_of_fn, hg₁, map_bind, seq_bind_eq, bind_assoc, (· ∘ ·), hl, -subtype.val_eq_coe]\n        rfl⟩\n#align exists_code.comp exists_code.comp\n\n",
 "code_supp_zero":
 "@[simp]\ntheorem code_supp_zero (k) : code_supp code.zero' k = tr_stmts₁ (tr_normal code.zero' k) ∪ cont_supp k :=\n  rfl\n#align code_supp_zero code_supp_zero\n\n",
 "code_supp_tail":
 "@[simp]\ntheorem code_supp_tail (k) : code_supp code.tail k = tr_stmts₁ (tr_normal code.tail k) ∪ cont_supp k :=\n  rfl\n#align code_supp_tail code_supp_tail\n\n",
 "code_supp_supports":
 "theorem code_supp_supports {S c k} (H : code_supp c k ⊆ S) : supports (code_supp c k) S :=\n  supports_union.2 ⟨code_supp'_supports H, cont_supp_supports (Finset.union_subset_right H)⟩\n#align code_supp_supports code_supp_supports\n\n",
 "code_supp_succ":
 "@[simp]\ntheorem code_supp_succ (k) : code_supp code.succ k = tr_stmts₁ (tr_normal code.succ k) ∪ cont_supp k :=\n  rfl\n#align code_supp_succ code_supp_succ\n\n",
 "code_supp_self":
 "@[simp]\ntheorem code_supp_self (c k) : tr_stmts₁ (tr_normal c k) ⊆ code_supp c k :=\n  Finset.Subset.trans (code_supp'_self _ _) (Finset.subset_union_left _ _)\n#align code_supp_self code_supp_self\n\n",
 "code_supp_fix":
 "@[simp]\ntheorem code_supp_fix (f k) :\n    code_supp (code.fix f) k = tr_stmts₁ (tr_normal (code.fix f) k) ∪ code_supp f (cont'.fix f k) := by\n  simp [code_supp, code_supp', cont_supp, Finset.union_assoc, Finset.union_left_comm, Finset.union_left_idem]\n#align code_supp_fix code_supp_fix\n\n",
 "code_supp_cons":
 "@[simp]\ntheorem code_supp_cons (f fs k) :\n    code_supp (code.cons f fs) k = tr_stmts₁ (tr_normal (code.cons f fs) k) ∪ code_supp f (cont'.cons₁ fs k) := by\n  simp [code_supp, code_supp', cont_supp, Finset.union_assoc]\n#align code_supp_cons code_supp_cons\n\n",
 "code_supp_comp":
 "@[simp]\ntheorem code_supp_comp (f g k) :\n    code_supp (code.comp f g) k = tr_stmts₁ (tr_normal (code.comp f g) k) ∪ code_supp g (cont'.comp f k) :=\n  by\n  simp [code_supp, code_supp', cont_supp, Finset.union_assoc]\n  rw [← Finset.union_assoc _ _ (cont_supp k), Finset.union_eq_right_iff_subset.2 (code_supp'_self _ _)]\n#align code_supp_comp code_supp_comp\n\n",
 "code_supp_case":
 "@[simp]\ntheorem code_supp_case (f g k) :\n    code_supp (code.case f g) k = tr_stmts₁ (tr_normal (code.case f g) k) ∪ (code_supp f k ∪ code_supp g k) := by\n  simp [code_supp, code_supp', cont_supp, Finset.union_assoc, Finset.union_left_comm]\n#align code_supp_case code_supp_case\n\n",
 "code_supp'_supports":
 "theorem code_supp'_supports {S c k} (H : code_supp c k ⊆ S) : supports (code_supp' c k) S :=\n  by\n  induction c generalizing k\n  iterate 3 exact tr_stmts₁_supports (tr_normal_supports H) (Finset.Subset.trans (code_supp_self _ _) H)\n  case cons f fs IHf IHfs =>\n    have H' := H; simp only [code_supp_cons, Finset.union_subset_iff] at H'\n    refine' tr_stmts₁_supports' (tr_normal_supports H) (Finset.union_subset_left H) fun h => _\n    refine' supports_union.2 ⟨IHf H'.2, _⟩\n    refine' tr_stmts₁_supports' (tr_normal_supports _) (Finset.union_subset_right h) fun h => _\n    · simp only [code_supp, Finset.union_subset_iff, cont_supp] at h H⊢\n      exact ⟨h.2.2.1, h.2.2.2, H.2⟩\n    refine' supports_union.2 ⟨IHfs _, _⟩\n    · rw [code_supp, cont_supp_cons₁] at H'\n      exact Finset.union_subset_right (Finset.union_subset_right H'.2)\n    exact tr_stmts₁_supports (head_supports <| Finset.union_subset_right H) (Finset.union_subset_right h)\n  case comp f g IHf IHg =>\n    have H' := H; rw [code_supp_comp] at H'; have H' := Finset.union_subset_right H'\n    refine' tr_stmts₁_supports' (tr_normal_supports H) (Finset.union_subset_left H) fun h => _\n    refine' supports_union.2 ⟨IHg H', _⟩\n    refine' tr_stmts₁_supports' (tr_normal_supports _) (Finset.union_subset_right h) fun h => _\n    · simp only [code_supp', code_supp, Finset.union_subset_iff, cont_supp] at h H⊢\n      exact ⟨h.2.2, H.2⟩\n    exact IHf (Finset.union_subset_right H')\n  case case f g IHf IHg =>\n    have H' := H; simp only [code_supp_case, Finset.union_subset_iff] at H'\n    refine' tr_stmts₁_supports' (tr_normal_supports H) (Finset.union_subset_left H) fun h => _\n    exact supports_union.2 ⟨IHf H'.2.1, IHg H'.2.2⟩\n  case fix f IHf =>\n    have H' := H; simp only [code_supp_fix, Finset.union_subset_iff] at H'\n    refine' tr_stmts₁_supports' (tr_normal_supports H) (Finset.union_subset_left H) fun h => _\n    refine' supports_union.2 ⟨IHf H'.2, _⟩\n    refine' tr_stmts₁_supports' (tr_normal_supports _) (Finset.union_subset_right h) fun h => _\n    · simp only [code_supp', code_supp, Finset.union_subset_iff, cont_supp, tr_stmts₁, Finset.insert_subset] at h H⊢\n      exact ⟨h.1, ⟨H.1.1, h⟩, H.2⟩\n    exact supports_singleton.2 (ret_supports <| Finset.union_subset_right H)\n#align code_supp'_supports code_supp'_supports\n\n",
 "code_supp'_self":
 "@[simp]\ntheorem code_supp'_self (c k) : tr_stmts₁ (tr_normal c k) ⊆ code_supp' c k := by\n  cases c <;> first |rfl|exact Finset.subset_union_left _ _\n#align code_supp'_self code_supp'_self\n\n",
 "code_is_ok":
 "theorem code_is_ok (c) : code.ok c :=\n  by\n  induction c <;> intro k v <;> rw [step_normal]\n  iterate 3 simp only [code.eval, pure_bind]\n  case cons f fs IHf IHfs =>\n    rw [code.eval, IHf]\n    simp only [bind_assoc, cont.eval, pure_bind]; congr ; funext v\n    rw [reaches_eval]; swap; exact refl_trans_gen.single rfl\n    rw [step_ret, IHfs]; congr ; funext v'\n    refine' eq.trans _ (eq.symm _) <;> try exact reaches_eval (refl_trans_gen.single rfl)\n  case comp f g IHf IHg =>\n    rw [code.eval, IHg]\n    simp only [bind_assoc, cont.eval, pure_bind]; congr ; funext v\n    rw [reaches_eval]; swap; exact refl_trans_gen.single rfl\n    rw [step_ret, IHf]\n  case case f g IHf IHg => simp only [code.eval];\n    cases v.head <;> simp only [nat.elim, code.eval] <;> [apply IHf, apply IHg]\n  case fix f IHf => rw [cont_eval_fix IHf]\n#align code_is_ok code_is_ok\n\n",
 "clear_ok":
 "theorem clear_ok {p k q s L₁ o L₂} {S : K' → list Γ'} (e : split_at_pred p (S k) = (L₁, o, L₂)) :\n    reaches₁ (TM2.step tr) ⟨some (Λ'.clear p k q), s, S⟩ ⟨some q, o, update S k L₂⟩ :=\n  by\n  induction' L₁ with a L₁ IH generalizing S s\n  · refine' trans_gen.head' rfl _\n    simp\n    cases' S k with a Sk\n    · cases e\n      rfl\n    simp [split_at_pred] at e⊢\n    cases p a <;> simp at e⊢\n    · revert e\n      rcases split_at_pred p Sk with ⟨_, _, _⟩\n      rintro ⟨⟩\n    · simp only [e]\n  · refine' trans_gen.head rfl _\n    simp\n    cases' e₁ : S k with a' Sk <;> rw [e₁, split_at_pred] at e\n    · cases e\n    cases e₂ : p a' <;> simp only [e₂, cond] at e\n    swap\n    · cases e\n    rcases e₃ : split_at_pred p Sk with ⟨_, _, _⟩\n    rw [e₃, split_at_pred] at e\n    cases e\n    simp [e₂]\n    convert @IH (update S k Sk) _ _ using 2 <;> simp [e₃]\n#align clear_ok clear_ok\n\n"}