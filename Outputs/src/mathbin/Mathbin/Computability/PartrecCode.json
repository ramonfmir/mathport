{"smn":
 "/-- The $S_n^m$ theorem: There is a computable function, namely `nat.partrec.code.curry`, that takes a\nprogram and a ℕ `n`, and returns a new program using `n` as the first argument.\n-/\ntheorem smn : ∃ f : Code → ℕ → Code, Computable₂ f ∧ ∀ c n x, eval (f c n) x = eval c (pair n x) :=\n  ⟨curry, Primrec₂.to_comp curry_prim, eval_curry⟩\n#align smn smn\n\n",
 "rfind_prim":
 "theorem rfind_prim : Primrec rfind' :=\n  ofNat_iff.2 <|\n    encode_iff.1 <|\n      nat_add.comp (nat_double_succ.comp <| nat_double_succ.comp <| encode_iff.2 <| Primrec.ofNat Code) (const 4)\n#align rfind_prim rfind_prim\n\n",
 "rfind'":
 "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem rfind' {f} (hf : Nat.Partrec f) :\n    Nat.Partrec (Nat.unpaired fun a m => (Nat.rfind fun n => (fun m => m = 0) <$> f (pair a (n + m))).map (· + m)) :=\n  Partrec₂.unpaired'.2 <|\n    by\n    refine'\n      Partrec.map\n        ((@Partrec₂.unpaired' fun a b : ℕ => Nat.rfind fun n => (fun m => m = 0) <$> f (mkpair a (n + b))).1 _)\n        (primrec.nat_add.comp Primrec.snd <| primrec.snd.comp Primrec.fst).to_comp.to₂\n    have :=\n      rfind\n        (Partrec₂.unpaired'.2\n          ((Partrec.nat_iff.2 hf).comp\n              (primrec₂.mkpair.comp (primrec.fst.comp <| primrec.unpair.comp Primrec.fst)\n                  (primrec.nat_add.comp Primrec.snd\n                    (primrec.snd.comp <| primrec.unpair.comp Primrec.fst))).to_comp).to₂)\n    simp at this; exact this\n#align rfind' rfind'\n\n",
 "rec_prim'":
 "theorem rec_prim' {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Primrec c) {z : α → σ} (hz : Primrec z)\n    {s : α → σ} (hs : Primrec s) {l : α → σ} (hl : Primrec l) {r : α → σ} (hr : Primrec r)\n    {pr : α → Code × Code × σ × σ → σ} (hpr : Primrec₂ pr) {co : α → Code × Code × σ × σ → σ} (hco : Primrec₂ co)\n    {pc : α → Code × Code × σ × σ → σ} (hpc : Primrec₂ pc) {rf : α → Code × σ → σ} (hrf : Primrec₂ rf) :\n    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)\n    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)\n    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)\n    let RF (a) cf hf := rf a (cf, hf)\n    let F (a : α) (c : Code) : σ := nat.partrec.code.rec_on c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)\n    Primrec (fun a => F a (c a) : α → σ) :=\n  by\n  intros\n  let G₁ : (α × List σ) × ℕ × ℕ → Option σ := fun p =>\n    let a := p.1.1\n    let IH := p.1.2\n    let n := p.2.1\n    let m := p.2.2\n    (IH.nth m).bind fun s =>\n      (IH.nth m.unpair.1).bind fun s₁ =>\n        (IH.nth m.unpair.2).map fun s₂ =>\n          cond n.bodd\n            (cond n.div2.bodd (rf a (of_nat code m, s)) (pc a (of_nat code m.unpair.1, of_nat code m.unpair.2, s₁, s₂)))\n            (cond n.div2.bodd (co a (of_nat code m.unpair.1, of_nat code m.unpair.2, s₁, s₂))\n              (pr a (of_nat code m.unpair.1, of_nat code m.unpair.2, s₁, s₂)))\n  have : Primrec G₁ := by\n    refine' option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _\n    refine' option_bind ((list_nth.comp (snd.comp fst) (fst.comp <| primrec.unpair.comp (snd.comp snd))).comp fst) _\n    refine'\n      option_map ((list_nth.comp (snd.comp fst) (snd.comp <| primrec.unpair.comp (snd.comp snd))).comp <| fst.comp fst)\n        _\n    have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)\n    have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m₁ := fst.comp (primrec.unpair.comp m)\n    have m₂ := snd.comp (primrec.unpair.comp m)\n    have s := snd.comp (fst.comp fst)\n    have s₁ := snd.comp fst\n    have s₂ := snd\n    exact\n      (nat_bodd.comp n).cond\n        ((nat_bodd.comp <| nat_div2.comp n).cond (hrf.comp a (((Primrec.ofNat code).comp m).pair s))\n          (hpc.comp a (((Primrec.ofNat code).comp m₁).pair <| ((Primrec.ofNat code).comp m₂).pair <| s₁.pair s₂)))\n        (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)\n          (hco.comp a (((Primrec.ofNat code).comp m₁).pair <| ((Primrec.ofNat code).comp m₂).pair <| s₁.pair s₂))\n          (hpr.comp a (((Primrec.ofNat code).comp m₁).pair <| ((Primrec.ofNat code).comp m₂).pair <| s₁.pair s₂)))\n  let G : α → List σ → Option σ := fun a IH =>\n    IH.length.cases (some (z a)) fun n =>\n      n.cases (some (s a)) fun n =>\n        n.cases (some (l a)) fun n => n.cases (some (r a)) fun n => G₁ ((a, IH), n, n.div2.div2)\n  have : Primrec₂ G :=\n    nat_cases (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <|\n      nat_cases snd (option_some_iff.2 (hs.comp (fst.comp fst))) <|\n        nat_cases snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <|\n          nat_cases snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst)))\n            (this.comp <|\n              ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|\n                snd.pair <| nat_div2.comp <| nat_div2.comp snd)\n  refine'\n    ((nat_strong_rec (fun a n => F a (of_nat code n)) this.to₂ fun a n => _).comp Primrec.id <| encode_iff.2 hc).of_eq\n      fun a => by simp\n  simp\n  iterate 4 cases' n with n; · simp [of_nat_code_eq, of_nat_code] <;> rfl\n  simp [G]\n  rw [list.length_map, List.length_range]\n  let m := n.div2.div2\n  show G₁ ((a, (list.range (n + 4)).map fun n => F a (of_nat code n)), n, m) = some (F a (of_nat code (n + 4)))\n  have hm : m < n + 4 := by\n    simp [Nat.div2_val, m] <;>\n      exact\n        lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))\n  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n  simp [G₁]\n  simp [List.get?_map, List.get?_range, hm, m1, m2]\n  change of_nat code (n + 4) with of_nat_code (n + 4)\n  simp [of_nat_code]\n  cases n.bodd <;> cases n.div2.bodd <;> rfl\n#align rec_prim' rec_prim'\n\n",
 "rec_prim":
 "/-- Recursion on `nat.partrec.code` is primitive recursive. -/\ntheorem rec_prim {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Primrec c) {z : α → σ} (hz : Primrec z)\n    {s : α → σ} (hs : Primrec s) {l : α → σ} (hl : Primrec l) {r : α → σ} (hr : Primrec r)\n    {pr : α → Code → Code → σ → σ → σ}\n    (hpr : Primrec fun a : α × Code × Code × σ × σ => pr a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {co : α → Code → Code → σ → σ → σ}\n    (hco : Primrec fun a : α × Code × Code × σ × σ => co a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {pc : α → Code → Code → σ → σ → σ}\n    (hpc : Primrec fun a : α × Code × Code × σ × σ => pc a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2) {rf : α → Code → σ → σ}\n    (hrf : Primrec fun a : α × Code × σ => rf a.1 a.2.1 a.2.2) :\n    let F (a : α) (c : Code) : σ := nat.partrec.code.rec_on c (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a)\n    Primrec fun a => F a (c a) :=\n  by\n  intros\n  let G₁ : (α × List σ) × ℕ × ℕ → Option σ := fun p =>\n    let a := p.1.1\n    let IH := p.1.2\n    let n := p.2.1\n    let m := p.2.2\n    (IH.nth m).bind fun s =>\n      (IH.nth m.unpair.1).bind fun s₁ =>\n        (IH.nth m.unpair.2).map fun s₂ =>\n          cond n.bodd\n            (cond n.div2.bodd (rf a (of_nat code m) s) (pc a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s₁ s₂))\n            (cond n.div2.bodd (co a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s₁ s₂)\n              (pr a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s₁ s₂))\n  have : Primrec G₁ := by\n    refine' option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _\n    refine' option_bind ((list_nth.comp (snd.comp fst) (fst.comp <| primrec.unpair.comp (snd.comp snd))).comp fst) _\n    refine'\n      option_map ((list_nth.comp (snd.comp fst) (snd.comp <| primrec.unpair.comp (snd.comp snd))).comp <| fst.comp fst)\n        _\n    have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)\n    have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m₁ := fst.comp (primrec.unpair.comp m)\n    have m₂ := snd.comp (primrec.unpair.comp m)\n    have s := snd.comp (fst.comp fst)\n    have s₁ := snd.comp fst\n    have s₂ := snd\n    exact\n      (nat_bodd.comp n).cond\n        ((nat_bodd.comp <| nat_div2.comp n).cond (hrf.comp <| a.pair (((Primrec.ofNat code).comp m).pair s))\n          (hpc.comp <|\n            a.pair (((Primrec.ofNat code).comp m₁).pair <| ((Primrec.ofNat code).comp m₂).pair <| s₁.pair s₂)))\n        (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)\n          (hco.comp <|\n            a.pair (((Primrec.ofNat code).comp m₁).pair <| ((Primrec.ofNat code).comp m₂).pair <| s₁.pair s₂))\n          (hpr.comp <|\n            a.pair (((Primrec.ofNat code).comp m₁).pair <| ((Primrec.ofNat code).comp m₂).pair <| s₁.pair s₂)))\n  let G : α → List σ → Option σ := fun a IH =>\n    IH.length.cases (some (z a)) fun n =>\n      n.cases (some (s a)) fun n =>\n        n.cases (some (l a)) fun n => n.cases (some (r a)) fun n => G₁ ((a, IH), n, n.div2.div2)\n  have : Primrec₂ G :=\n    nat_cases (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <|\n      nat_cases snd (option_some_iff.2 (hs.comp (fst.comp fst))) <|\n        nat_cases snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <|\n          nat_cases snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst)))\n            (this.comp <|\n              ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|\n                snd.pair <| nat_div2.comp <| nat_div2.comp snd)\n  refine'\n    ((nat_strong_rec (fun a n => F a (of_nat code n)) this.to₂ fun a n => _).comp Primrec.id <| encode_iff.2 hc).of_eq\n      fun a => by simp\n  simp\n  iterate 4 cases' n with n; · simp [of_nat_code_eq, of_nat_code] <;> rfl\n  simp [G]\n  rw [list.length_map, List.length_range]\n  let m := n.div2.div2\n  show G₁ ((a, (list.range (n + 4)).map fun n => F a (of_nat code n)), n, m) = some (F a (of_nat code (n + 4)))\n  have hm : m < n + 4 := by\n    simp [Nat.div2_val, m] <;>\n      exact\n        lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))\n  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n  simp [G₁]\n  simp [List.get?_map, List.get?_range, hm, m1, m2]\n  change of_nat code (n + 4) with of_nat_code (n + 4)\n  simp [of_nat_code]\n  cases n.bodd <;> cases n.div2.bodd <;> rfl\n#align rec_prim rec_prim\n\n",
 "rec_computable":
 "/-- Recursion on `nat.partrec.code` is computable. -/\ntheorem rec_computable {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Computable c) {z : α → σ}\n    (hz : Computable z) {s : α → σ} (hs : Computable s) {l : α → σ} (hl : Computable l) {r : α → σ} (hr : Computable r)\n    {pr : α → Code × Code × σ × σ → σ} (hpr : Computable₂ pr) {co : α → Code × Code × σ × σ → σ} (hco : Computable₂ co)\n    {pc : α → Code × Code × σ × σ → σ} (hpc : Computable₂ pc) {rf : α → Code × σ → σ} (hrf : Computable₂ rf) :\n    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)\n    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)\n    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)\n    let RF (a) cf hf := rf a (cf, hf)\n    let F (a : α) (c : Code) : σ := nat.partrec.code.rec_on c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)\n    Computable fun a => F a (c a) :=\n  by\n  -- TODO(Mario): less copy-paste from previous proof\n  intros\n  let G₁ : (α × List σ) × ℕ × ℕ → Option σ := fun p =>\n    let a := p.1.1\n    let IH := p.1.2\n    let n := p.2.1\n    let m := p.2.2\n    (IH.nth m).bind fun s =>\n      (IH.nth m.unpair.1).bind fun s₁ =>\n        (IH.nth m.unpair.2).map fun s₂ =>\n          cond n.bodd\n            (cond n.div2.bodd (rf a (of_nat code m, s)) (pc a (of_nat code m.unpair.1, of_nat code m.unpair.2, s₁, s₂)))\n            (cond n.div2.bodd (co a (of_nat code m.unpair.1, of_nat code m.unpair.2, s₁, s₂))\n              (pr a (of_nat code m.unpair.1, of_nat code m.unpair.2, s₁, s₂)))\n  have : Computable G₁ := by\n    refine' option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _\n    refine' option_bind ((list_nth.comp (snd.comp fst) (fst.comp <| computable.unpair.comp (snd.comp snd))).comp fst) _\n    refine'\n      option_map\n        ((list_nth.comp (snd.comp fst) (snd.comp <| computable.unpair.comp (snd.comp snd))).comp <| fst.comp fst) _\n    have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)\n    have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)\n    have m₁ := fst.comp (computable.unpair.comp m)\n    have m₂ := snd.comp (computable.unpair.comp m)\n    have s := snd.comp (fst.comp fst)\n    have s₁ := snd.comp fst\n    have s₂ := snd\n    exact\n      (nat_bodd.comp n).cond\n        ((nat_bodd.comp <| nat_div2.comp n).cond (hrf.comp a (((Computable.ofNat code).comp m).pair s))\n          (hpc.comp a (((Computable.ofNat code).comp m₁).pair <| ((Computable.ofNat code).comp m₂).pair <| s₁.pair s₂)))\n        (Computable.cond (nat_bodd.comp <| nat_div2.comp n)\n          (hco.comp a (((Computable.ofNat code).comp m₁).pair <| ((Computable.ofNat code).comp m₂).pair <| s₁.pair s₂))\n          (hpr.comp a (((Computable.ofNat code).comp m₁).pair <| ((Computable.ofNat code).comp m₂).pair <| s₁.pair s₂)))\n  let G : α → List σ → Option σ := fun a IH =>\n    IH.length.cases (some (z a)) fun n =>\n      n.cases (some (s a)) fun n =>\n        n.cases (some (l a)) fun n => n.cases (some (r a)) fun n => G₁ ((a, IH), n, n.div2.div2)\n  have : Computable₂ G :=\n    nat_cases (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <|\n      nat_cases snd (option_some_iff.2 (hs.comp (fst.comp fst))) <|\n        nat_cases snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <|\n          nat_cases snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst)))\n            (this.comp <|\n              ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|\n                snd.pair <| nat_div2.comp <| nat_div2.comp snd)\n  refine'\n    ((nat_strong_rec (fun a n => F a (of_nat code n)) this.to₂ fun a n => _).comp Computable.id <|\n          encode_iff.2 hc).of_eq\n      fun a => by simp\n  simp\n  iterate 4 cases' n with n; · simp [of_nat_code_eq, of_nat_code] <;> rfl\n  simp [G]\n  rw [list.length_map, List.length_range]\n  let m := n.div2.div2\n  show G₁ ((a, (list.range (n + 4)).map fun n => F a (of_nat code n)), n, m) = some (F a (of_nat code (n + 4)))\n  have hm : m < n + 4 := by\n    simp [Nat.div2_val, m] <;>\n      exact\n        lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))\n  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n  simp [G₁]\n  simp [List.get?_map, List.get?_range, hm, m1, m2]\n  change of_nat code (n + 4) with of_nat_code (n + 4)\n  simp [of_nat_code]\n  cases n.bodd <;> cases n.div2.bodd <;> rfl\n#align rec_computable rec_computable\n\n",
 "prec_prim":
 "theorem prec_prim : Primrec₂ prec :=\n  Primrec₂.ofNat_iff.2 <|\n    Primrec₂.encode_iff.1 <|\n      nat_add.comp\n        (nat_double_succ.comp <|\n          nat_double.comp <|\n            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)\n              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))\n        (Primrec₂.const 4)\n#align prec_prim prec_prim\n\n",
 "pair_prim":
 "theorem pair_prim : Primrec₂ pair :=\n  Primrec₂.ofNat_iff.2 <|\n    Primrec₂.encode_iff.1 <|\n      nat_add.comp\n        (nat_double.comp <|\n          nat_double.comp <|\n            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)\n              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))\n        (Primrec₂.const 4)\n#align pair_prim pair_prim\n\n",
 "of_nat_code_eq":
 "theorem of_nat_code_eq : ofNat Code = ofNatCode :=\n  rfl\n#align of_nat_code_eq of_nat_code_eq\n\n",
 "hlup":
 "private theorem hlup : Primrec fun p : _ × (_ × _) × _ => lup p.1 p.2.1 p.2.2 :=\n  option_bind (list_get?.comp fst (Primrec.encode.comp <| fst.comp snd))\n    (option_bind (list_get?.comp snd <| snd.comp <| snd.comp fst) snd)\n#align hlup hlup\n\n",
 "hG":
 "-- zero\nprivate theorem hG : Primrec G :=\n  by\n  have a := (Primrec.ofNat (ℕ × code)).comp list_length\n  have k := fst.comp a\n  refine' option_some.comp (list_map (list_range.comp k) (_ : Primrec _))\n  replace k := k.comp fst; have n := snd\n  refine' nat_cases k (const none) (_ : Primrec _)\n  have k := k.comp fst; have n := n.comp fst; have k' := snd\n  have c := snd.comp (a.comp <| fst.comp fst)\n  apply\n    rec_prim c (const (some 0)) (option_some.comp (primrec.succ.comp n))\n      (option_some.comp (fst.comp <| primrec.unpair.comp n)) (option_some.comp (snd.comp <| primrec.unpair.comp n))\n  · have L := (fst.comp fst).comp fst\n    have k := k.comp fst\n    have n := n.comp fst\n    have cf := fst.comp snd\n    have cg := (fst.comp snd).comp snd\n    exact\n      option_bind (hlup.comp <| L.pair <| (k.pair cf).pair n)\n        (option_map ((hlup.comp <| L.pair <| (k.pair cg).pair n).comp fst) (primrec₂.mkpair.comp (snd.comp fst) snd))\n  · have L := (fst.comp fst).comp fst\n    have k := k.comp fst\n    have n := n.comp fst\n    have cf := fst.comp snd\n    have cg := (fst.comp snd).comp snd\n    exact\n      option_bind (hlup.comp <| L.pair <| (k.pair cg).pair n)\n        (hlup.comp ((L.comp fst).pair <| ((k.pair cf).comp fst).pair snd))\n  · have L := (fst.comp fst).comp fst\n    have k := k.comp fst\n    have n := n.comp fst\n    have cf := fst.comp snd\n    have cg := (fst.comp snd).comp snd\n    have z := fst.comp (primrec.unpair.comp n)\n    refine' nat_cases (snd.comp (primrec.unpair.comp n)) (hlup.comp <| L.pair <| (k.pair cf).pair z) (_ : Primrec _)\n    have L := L.comp fst\n    have z := z.comp fst\n    have y := snd\n    refine'\n      option_bind (hlup.comp <| L.pair <| (((k'.pair c).comp fst).comp fst).pair (primrec₂.mkpair.comp z y))\n        (_ : Primrec _)\n    have z := z.comp fst\n    have y := y.comp fst\n    have i := snd\n    exact\n      hlup.comp\n        ((L.comp fst).pair <|\n          ((k.pair cg).comp <| fst.comp fst).pair <| primrec₂.mkpair.comp z <| primrec₂.mkpair.comp y i)\n  · have L := (fst.comp fst).comp fst\n    have k := k.comp fst\n    have n := n.comp fst\n    have cf := fst.comp snd\n    have z := fst.comp (primrec.unpair.comp n)\n    have m := snd.comp (primrec.unpair.comp n)\n    refine' option_bind (hlup.comp <| L.pair <| (k.pair cf).pair (primrec₂.mkpair.comp z m)) (_ : Primrec _)\n    have m := m.comp fst\n    exact\n      nat_cases snd (option_some.comp m)\n        ((hlup.comp\n              ((L.comp fst).pair <|\n                ((k'.pair c).comp <| fst.comp fst).pair (primrec₂.mkpair.comp (z.comp fst) (primrec.succ.comp m)))).comp\n          fst)\n#align hG hG\n\n",
 "fixed_point₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem fixed_point₂ {f : Code → «expr →. » ℕ ℕ} (hf : Partrec₂ f) : ∃ c : Code, eval c = f c :=\n  let ⟨cf, ef⟩ := exists_code.1 hf\n  (fixed_point (curry_prim.comp (Primrec.const cf) Primrec.encode).to_comp).imp fun c e =>\n    funext fun n => by simp [e.symm, ef, Part.map_id']\n#align fixed_point₂ fixed_point₂\n\n",
 "fixed_point":
 "/-- Roger's fixed-point theorem: Any total, computable `f` has a fixed point: That is, under the\ninterpretation given by `nat.partrec.code.eval`, there is a code `c` such that `c` and `f c` have\nthe same evaluation.\n-/\ntheorem fixed_point {f : Code → Code} (hf : Computable f) : ∃ c : Code, eval (f c) = eval c :=\n  let g (x y : ℕ) : Part ℕ := eval (ofNat Code x) x >>= fun b => eval (ofNat Code b) y\n  have : Partrec₂ g :=\n    (eval_part.comp ((Computable.ofNat _).comp fst) fst).bind\n      (eval_part.comp ((Computable.ofNat _).comp snd) (snd.comp fst)).to₂\n  let ⟨cg, eg⟩ := exists_code.1 this\n  have eg' : ∀ a n, eval cg (pair a n) = Part.map encode (g a n) := by simp [eg]\n  let F (x : ℕ) : Code := f (curry cg x)\n  have : Computable F := hf.comp (curry_prim.comp (Primrec.const cg) Primrec.id).to_comp\n  let ⟨cF, eF⟩ := exists_code.1 this\n  have eF' : eval cF (encode cF) = Part.some (encode (F (encode cF))) := by simp [eF]\n  ⟨curry cg (encode cF),\n    funext fun n =>\n      show eval (f (curry cg (encode cF))) n = eval (curry cg (encode cF)) n by simp [eg', eF', Part.map_id', g]⟩\n#align fixed_point fixed_point\n\n",
 "exists_code":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/-- A function is partial recursive if and only if there is a code implementing it. -/\ntheorem exists_code {f : «expr →. » ℕ ℕ} : Nat.Partrec f ↔ ∃ c : Code, eval c = f :=\n  ⟨fun h => by\n    induction h\n    case zero => exact ⟨zero, rfl⟩\n    case succ => exact ⟨succ, rfl⟩\n    case left => exact ⟨left, rfl⟩\n    case right => exact ⟨right, rfl⟩\n    case pair f g pf pg hf hg =>\n      rcases hf with ⟨cf, rfl⟩; rcases hg with ⟨cg, rfl⟩\n      exact ⟨pair cf cg, rfl⟩\n    case comp f g pf pg hf hg =>\n      rcases hf with ⟨cf, rfl⟩; rcases hg with ⟨cg, rfl⟩\n      exact ⟨comp cf cg, rfl⟩\n    case prec f g pf pg hf hg =>\n      rcases hf with ⟨cf, rfl⟩; rcases hg with ⟨cg, rfl⟩\n      exact ⟨prec cf cg, rfl⟩\n    case rfind f pf hf =>\n      rcases hf with ⟨cf, rfl⟩\n      refine' ⟨comp (rfind' cf) (pair code.id zero), _⟩\n      simp [eval, (· <*> ·), pure, PFun.pure, Part.map_id'],\n    fun h => by\n    rcases h with ⟨c, rfl⟩; induction c\n    case zero => exact nat.partrec.zero\n    case succ => exact nat.partrec.succ\n    case left => exact nat.partrec.left\n    case right => exact nat.partrec.right\n    case pair cf cg pf pg => exact pf.pair pg\n    case comp cf cg pf pg => exact pf.comp pg\n    case prec cf cg pf pg => exact pf.prec pg\n    case rfind' cf pf => exact pf.rfind'⟩\n#align exists_code exists_code\n\n",
 "evaln_sound":
 "theorem evaln_sound : ∀ {k c n x}, x ∈ evaln k c n → x ∈ eval c n\n  | 0, _, n, x, h => by simp [evaln] at h <;> cases h\n  | k + 1, c, n, x, h =>\n    by\n    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;>\n        simp [eval, evaln, (· >> ·), (· <*> ·)] at h⊢ <;>\n      cases' h with _ h\n    iterate 4 simpa [pure, PFun.pure, eq_comm] using h\n    · -- pair cf cg\n      rcases h with ⟨y, ef, z, eg, rfl⟩\n      exact ⟨_, hf _ _ ef, _, hg _ _ eg, rfl⟩\n    · --comp hf hg\n      rcases h with ⟨y, eg, ef⟩\n      exact ⟨_, hg _ _ eg, hf _ _ ef⟩\n    · -- prec cf cg\n      revert h\n      induction' n.unpair.2 with m IH generalizing x <;> simp\n      · apply hf\n      · refine' fun y h₁ h₂ => ⟨y, IH _ _, _⟩\n        · have := evaln_mono k.le_succ h₁\n          simp [evaln, (· >> ·)] at this\n          exact this.2\n        · exact hg _ _ h₂\n    · -- rfind' cf\n      rcases h with ⟨m, h₁, h₂⟩\n      by_cases m0 : m = 0 <;> simp [m0] at h₂\n      ·\n        exact\n          ⟨0, ⟨by simpa [m0] using hf _ _ h₁, fun m => (nat.not_lt_zero _).elim⟩, by injection h₂ with h₂ <;> simp [h₂]⟩\n      · have := evaln_sound h₂\n        simp [eval] at this\n        rcases this with ⟨y, ⟨hy₁, hy₂⟩, rfl⟩\n        refine'\n          ⟨y + 1, ⟨by simpa [add_comm, add_left_comm] using hy₁, fun i im => _⟩, by simp [add_comm, add_left_comm]⟩\n        cases' i with i\n        · exact ⟨m, by simpa using hf _ _ h₁, m0⟩\n        · rcases hy₂ (nat.lt_of_succ_lt_succ im) with ⟨z, hz, z0⟩\n          exact ⟨z, by simpa [nat.succ_eq_add_one, add_comm, add_left_comm] using hz, z0⟩\n#align evaln_sound evaln_sound\n\n",
 "evaln_prim":
 "/-- The `nat.partrec.code.evaln` function is primitive recursive. -/\ntheorem evaln_prim : Primrec fun a : (ℕ × Code) × ℕ => evaln a.1.1 a.1.2 a.2 :=\n  have :\n    Primrec₂ fun (_ : Unit) (n : ℕ) =>\n      let a := ofNat (ℕ × Code) n\n      (list.range a.1).map (evaln a.1 a.2) :=\n    Primrec.nat_strong_rec _ (hG.comp snd).to₂ fun _ p =>\n      by\n      simp [G]\n      rw [(_ : (of_nat (ℕ × code) _).snd = of_nat code p.unpair.2)]\n      swap\n      · simp\n      apply List.map_congr fun n => _\n      rw [(by simp : list.range p = list.range (mkpair p.unpair.1 (encode (of_nat code p.unpair.2))))]\n      generalize p.unpair.1 = k\n      generalize of_nat code p.unpair.2 = c\n      intro nk\n      cases' k with k'\n      · simp [evaln]\n      let k := k' + 1\n      change k'.succ with k\n      simp [Nat.lt_succ_iff] at nk\n      have hg :\n        ∀ {k' c' n},\n          mkpair k' (encode c') < mkpair k (encode c) →\n            lup\n                ((list.range (mkpair k (encode c))).map fun n =>\n                  (list.range n.unpair.1).map (evaln n.unpair.1 (of_nat code n.unpair.2)))\n                (k', c') n =\n              evaln k' c' n :=\n        by\n        intro k₁ c₁ n₁ hl\n        simp [lup, List.get?_range hl, evaln_map, (· >>= ·)]\n      cases' c with cf cg cf cg cf cg cf <;> simp [evaln, nk, (· >> ·), (· >>= ·), (· <$> ·), (· <*> ·), pure]\n      · cases' encode_lt_pair cf cg with lf lg\n        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]\n        cases evaln k cf n\n        · rfl\n        cases evaln k cg n <;> rfl\n      · cases' encode_lt_comp cf cg with lf lg\n        rw [hg (Nat.pair_lt_pair_right _ lg)]\n        cases evaln k cg n\n        · rfl\n        simp [hg (Nat.pair_lt_pair_right _ lf)]\n      · cases' encode_lt_prec cf cg with lf lg\n        rw [hg (Nat.pair_lt_pair_right _ lf)]\n        cases n.unpair.2\n        · rfl\n        simp\n        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]\n        cases evaln k' _ _\n        · rfl\n        simp [hg (Nat.pair_lt_pair_right _ lg)]\n      · have lf := encode_lt_rfind' cf\n        rw [hg (Nat.pair_lt_pair_right _ lf)]\n        cases' evaln k cf n with x\n        · rfl\n        simp\n        cases x <;> simp [nat.succ_ne_zero]\n        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]\n  (option_bind (list_get?.comp (this.comp (const ()) (encode_iff.2 fst)) snd) snd.to₂).of_eq fun ⟨⟨k, c⟩, n⟩ => by\n    simp [evaln_map]\n#align evaln_prim evaln_prim\n\n",
 "evaln_mono":
 "theorem evaln_mono : ∀ {k₁ k₂ c n x}, k₁ ≤ k₂ → x ∈ evaln k₁ c n → x ∈ evaln k₂ c n\n  | 0, k₂, c, n, x, hl, h => by simp [evaln] at h <;> cases h\n  | k + 1, k₂ + 1, c, n, x, hl, h => by\n    have hl' := nat.le_of_succ_le_succ hl\n    have :\n      ∀ {k k₂ n x : ℕ} {o₁ o₂ : Option ℕ},\n        k ≤ k₂ → (x ∈ o₁ → x ∈ o₂) → x ∈ guard (n ≤ k) >> o₁ → x ∈ guard (n ≤ k₂) >> o₂ :=\n      by\n      simp [(· >> ·)]\n      introv h h₁ h₂ h₃\n      exact ⟨le_trans h₂ h, h₁ h₃⟩\n    simp at h⊢\n    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;> rw [evaln] at h⊢ <;>\n      refine' this hl' (fun h => _) h\n    iterate 4 exact h\n    · -- pair cf cg\n      simp [(· <*> ·)] at h⊢\n      exact h.imp fun a => and.imp (hf _ _) <| Exists.imp fun b => And.imp_left (hg _ _)\n    · -- comp cf cg\n      simp at h⊢\n      exact h.imp fun a => and.imp (hg _ _) (hf _ _)\n    · -- prec cf cg\n      revert h\n      simp\n      induction n.unpair.2 <;> simp\n      · apply hf\n      · exact fun y h₁ h₂ => ⟨y, evaln_mono hl' h₁, hg _ _ h₂⟩\n    · -- rfind' cf\n      simp at h⊢\n      refine' h.imp fun x => and.imp (hf _ _) _\n      by_cases x0 : x = 0 <;> simp [x0]\n      exact evaln_mono hl'\n#align evaln_mono evaln_mono\n\n",
 "evaln_map":
 "private theorem evaln_map (k c n) : ((((list.range k).nth n).map (evaln k c)).bind fun b => b) = evaln k c n :=\n  by\n  by_cases kn : n < k\n  · simp [List.get?_range kn]\n  · rw [List.get?_len_le]\n    · cases e : evaln k c n\n      · rfl\n      exact kn.elim (evaln_bound e)\n    simpa using kn\n#align evaln_map evaln_map\n\n",
 "evaln_complete":
 "theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n :=\n  ⟨fun h => by\n    rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n\n    · exact ⟨k + 1, h⟩\n    induction c generalizing n x <;> simp [eval, evaln, pure, PFun.pure, (· <*> ·), (· >> ·)] at h⊢\n    iterate 4 exact ⟨⟨_, le_rfl⟩, h.symm⟩\n    case pair cf cg hf hg =>\n      rcases h with ⟨x, hx, y, hy, rfl⟩\n      rcases hf hx with ⟨k₁, hk₁⟩; rcases hg hy with ⟨k₂, hk₂⟩\n      refine' ⟨max k₁ k₂, _⟩\n      refine'\n        ⟨le_max_of_le_left <| nat.le_of_lt_succ <| evaln_bound hk₁, _,\n          evaln_mono (nat.succ_le_succ <| le_max_left _ _) hk₁, _,\n          evaln_mono (nat.succ_le_succ <| le_max_right _ _) hk₂, rfl⟩\n    case comp cf cg hf hg =>\n      rcases h with ⟨y, hy, hx⟩\n      rcases hg hy with ⟨k₁, hk₁⟩; rcases hf hx with ⟨k₂, hk₂⟩\n      refine' ⟨max k₁ k₂, _⟩\n      exact\n        ⟨le_max_of_le_left <| nat.le_of_lt_succ <| evaln_bound hk₁, _,\n          evaln_mono (nat.succ_le_succ <| le_max_left _ _) hk₁, evaln_mono (nat.succ_le_succ <| le_max_right _ _) hk₂⟩\n    case prec cf cg hf hg =>\n      revert h\n      generalize n.unpair.1 = n₁; generalize n.unpair.2 = n₂\n      induction' n₂ with m IH generalizing x n <;> simp\n      · intro\n        rcases hf h with ⟨k, hk⟩\n        exact ⟨_, le_max_left _ _, evaln_mono (nat.succ_le_succ <| le_max_right _ _) hk⟩\n      · intro y hy hx\n        rcases IH hy with ⟨k₁, nk₁, hk₁⟩\n        rcases hg hx with ⟨k₂, hk₂⟩\n        refine'\n          ⟨(max k₁ k₂).succ, nat.le_succ_of_le <| le_max_of_le_left <| le_trans (le_max_left _ (mkpair n₁ m)) nk₁, y,\n            evaln_mono (nat.succ_le_succ <| le_max_left _ _) _,\n            evaln_mono (nat.succ_le_succ <| nat.le_succ_of_le <| le_max_right _ _) hk₂⟩\n        simp [evaln, (· >> ·)]\n        exact ⟨le_trans (le_max_right _ _) nk₁, hk₁⟩\n    case rfind' cf hf =>\n      rcases h with ⟨y, ⟨hy₁, hy₂⟩, rfl⟩\n      suffices ∃ k, y + n.unpair.2 ∈ evaln (k + 1) (rfind' cf) (mkpair n.unpair.1 n.unpair.2) by simpa [evaln, (· >> ·)]\n      revert hy₁ hy₂\n      generalize n.unpair.2 = m\n      intros\n      induction' y with y IH generalizing m <;> simp [evaln, (· >> ·)]\n      · simp at hy₁\n        rcases hf hy₁ with ⟨k, hk⟩\n        exact ⟨_, nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simp <;> rfl⟩\n      · rcases hy₂ (nat.succ_pos _) with ⟨a, ha, a0⟩\n        rcases hf ha with ⟨k₁, hk₁⟩\n        rcases IH m.succ (by simpa [nat.succ_eq_add_one, add_comm, add_left_comm] using hy₁) fun i hi => by\n            simpa [nat.succ_eq_add_one, add_comm, add_left_comm] using hy₂ (nat.succ_lt_succ hi) with\n          ⟨k₂, hk₂⟩\n        use (max k₁ k₂).succ\n        rw [zero_add] at hk₁\n        use nat.le_succ_of_le <| le_max_of_le_left <| nat.le_of_lt_succ <| evaln_bound hk₁\n        use a\n        use evaln_mono (nat.succ_le_succ <| nat.le_succ_of_le <| le_max_left _ _) hk₁\n        simpa [nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using\n          evaln_mono (nat.succ_le_succ <| le_max_right _ _) hk₂,\n    fun ⟨k, h⟩ => evaln_sound h⟩\n#align evaln_complete evaln_complete\n\n",
 "evaln_bound":
 "theorem evaln_bound : ∀ {k c n x}, x ∈ evaln k c n → n < k\n  | 0, c, n, x, h => by simp [evaln] at h <;> cases h\n  | k + 1, c, n, x, h =>\n    by\n    suffices ∀ {o : Option ℕ}, x ∈ guard (n ≤ k) >> o → n < k + 1 by cases c <;> rw [evaln] at h <;> exact this h\n    simpa [(· >> ·)] using nat.lt_succ_of_le\n#align evaln_bound evaln_bound\n\n",
 "eval_prec_zero":
 "/-- Helper lemma for the evaluation of `prec` in the base case. -/\n@[simp]\ntheorem eval_prec_zero (cf cg : Code) (a : ℕ) : eval (prec cf cg) (pair a 0) = eval cf a := by\n  rw [eval, Nat.unpaired, Nat.unpair_pair, Nat.rec_zero]\n#align eval_prec_zero eval_prec_zero\n\n",
 "eval_prec_succ":
 "/-- Helper lemma for the evaluation of `prec` in the recursive case. -/\ntheorem eval_prec_succ (cf cg : Code) (a k : ℕ) :\n    eval (prec cf cg) (pair a (nat.succ k)) = do\n      let ih ← eval (prec cf cg) (pair a k)\n      eval cg (mkpair a (mkpair k ih)) :=\n  by\n  rw [eval, Nat.unpaired, Part.bind_eq_bind, Nat.unpair_pair, Nat.rec_add_one]\n  simp\n#align eval_prec_succ eval_prec_succ\n\n",
 "eval_part":
 "theorem eval_part : Partrec₂ eval :=\n  (rfindOpt (evaln_prim.to_comp.comp ((snd.pair (fst.comp fst)).pair (snd.comp fst))).to₂).of_eq fun a => by\n    simp [eval_eq_rfind_opt]\n#align eval_part eval_part\n\n",
 "eval_id":
 "@[simp]\ntheorem eval_id (n) : eval Code.id n = Part.some n := by simp! [(· <*> ·)]\n#align eval_id eval_id\n\n",
 "eval_eq_rfind_opt":
 "theorem eval_eq_rfind_opt (c n) : eval c n = Nat.rfindOpt fun k => evaln k c n :=\n  Part.ext fun x => by\n    refine' evaln_complete.trans (Nat.rfindOpt_mono _).symm\n    intro a m n hl; apply evaln_mono hl\n#align eval_eq_rfind_opt eval_eq_rfind_opt\n\n",
 "eval_curry":
 "@[simp]\ntheorem eval_curry (c n x) : eval (curry c n) x = eval c (pair n x) := by simp! [(· <*> ·)]\n#align eval_curry eval_curry\n\n",
 "eval_const":
 "@[simp]\ntheorem eval_const : ∀ n m, eval (Code.const n) m = Part.some n\n  | 0, m => rfl\n  | n + 1, m => by simp! [*]\n#align eval_const eval_const\n\n",
 "encode_of_nat_code":
 "/-- Proof that `nat.partrec.code.of_nat_code` is the inverse of `nat.partrec.code.encode_code`-/\nprivate theorem encode_of_nat_code : ∀ n, encodeCode (ofNatCode n) = n\n  | 0 => by simp [of_nat_code, encode_code]\n  | 1 => by simp [of_nat_code, encode_code]\n  | 2 => by simp [of_nat_code, encode_code]\n  | 3 => by simp [of_nat_code, encode_code]\n  | n + 4 => by\n    let m := n.div2.div2\n    have hm : m < n + 4 := by\n      simp [m, Nat.div2_val] <;>\n        exact\n          lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _))\n            (nat.succ_le_succ (nat.le_add_right _ _))\n    have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n    have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n    have IH := encode_of_nat_code m\n    have IH1 := encode_of_nat_code m.unpair.1\n    have IH2 := encode_of_nat_code m.unpair.2\n    trans\n    swap\n    rw [← Nat.bit_decomp n, ← Nat.bit_decomp n.div2]\n    simp [encode_code, of_nat_code, -add_comm]\n    cases n.bodd <;> cases n.div2.bodd <;> simp [encode_code, of_nat_code, -add_comm, IH, IH1, IH2, m, Nat.bit]\n#align encode_of_nat_code encode_of_nat_code\n\n",
 "encode_lt_rfind'":
 "theorem encode_lt_rfind' (cf) : encode cf < encode (rfind' cf) :=\n  by\n  simp [encode_code_eq, encode_code, -add_comm]\n  have := nat.mul_le_mul_right _ (by decide : 1 ≤ 2 * 2)\n  rw [one_mul, mul_assoc, ← bit0_eq_two_mul, ← bit0_eq_two_mul] at this\n  refine' lt_of_le_of_lt (le_trans this _) (lt_add_of_pos_right _ (by decide : 0 < 4))\n  exact le_of_lt (Nat.bit0_lt_bit1 <| le_of_lt <| Nat.bit0_lt_bit1 <| le_rfl)\n#align encode_lt_rfind' encode_lt_rfind'\n\n",
 "encode_lt_prec":
 "theorem encode_lt_prec (cf cg) : encode cf < encode (prec cf cg) ∧ encode cg < encode (prec cf cg) :=\n  by\n  suffices; exact (encode_lt_pair cf cg).imp (fun h => lt_trans h this) fun h => lt_trans h this\n  change _; simp [encode_code_eq, encode_code]\n#align encode_lt_prec encode_lt_prec\n\n",
 "encode_lt_pair":
 "theorem encode_lt_pair (cf cg) : encode cf < encode (pair cf cg) ∧ encode cg < encode (pair cf cg) :=\n  by\n  simp [encode_code_eq, encode_code, -add_comm]\n  have := nat.mul_le_mul_right _ (by decide : 1 ≤ 2 * 2)\n  rw [one_mul, mul_assoc, ← bit0_eq_two_mul, ← bit0_eq_two_mul] at this\n  have := lt_of_le_of_lt this (lt_add_of_pos_right _ (by decide : 0 < 4))\n  exact ⟨lt_of_le_of_lt (Nat.left_le_pair _ _) this, lt_of_le_of_lt (Nat.right_le_pair _ _) this⟩\n#align encode_lt_pair encode_lt_pair\n\n",
 "encode_lt_comp":
 "theorem encode_lt_comp (cf cg) : encode cf < encode (comp cf cg) ∧ encode cg < encode (comp cf cg) :=\n  by\n  suffices; exact (encode_lt_pair cf cg).imp (fun h => lt_trans h this) fun h => lt_trans h this\n  change _; simp [encode_code_eq, encode_code]\n#align encode_lt_comp encode_lt_comp\n\n",
 "encode_code_eq":
 "theorem encode_code_eq : encode = encodeCode :=\n  rfl\n#align encode_code_eq encode_code_eq\n\n",
 "curry_prim":
 "theorem curry_prim : Primrec₂ curry :=\n  comp_prim.comp Primrec.fst <| pair_prim.comp (const_prim.comp Primrec.snd) (Primrec.const Code.id)\n#align curry_prim curry_prim\n\n",
 "curry_inj":
 "theorem curry_inj {c₁ c₂ n₁ n₂} (h : curry c₁ n₁ = curry c₂ n₂) : c₁ = c₂ ∧ n₁ = n₂ :=\n  ⟨by injection h, by\n    injection h\n    injection h with h₁ h₂\n    injection h₂ with h₃ h₄\n    exact const_inj h₃⟩\n#align curry_inj curry_inj\n\n",
 "const_prim":
 "theorem const_prim : Primrec Code.const :=\n  (Primrec.id.nat_iterate (Primrec.const zero) (comp_prim.comp (Primrec.const succ) Primrec.snd).to₂).of_eq fun n => by\n    simp <;> induction n <;> simp [*, code.const, Function.iterate_succ']\n#align const_prim const_prim\n\n",
 "const_inj":
 "theorem const_inj : ∀ {n₁ n₂}, Nat.Partrec.Code.const n₁ = Nat.Partrec.Code.const n₂ → n₁ = n₂\n  | 0, 0, h => by simp\n  | n₁ + 1, n₂ + 1, h => by\n    dsimp [Nat.Partrec.Code.const] at h\n    injection h with h₁ h₂\n    simp only [const_inj h₂]\n#align const_inj const_inj\n\n",
 "comp_prim":
 "theorem comp_prim : Primrec₂ comp :=\n  Primrec₂.ofNat_iff.2 <|\n    Primrec₂.encode_iff.1 <|\n      nat_add.comp\n        (nat_double.comp <|\n          nat_double_succ.comp <|\n            Primrec₂.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)\n              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))\n        (Primrec₂.const 4)\n#align comp_prim comp_prim\n\n"}