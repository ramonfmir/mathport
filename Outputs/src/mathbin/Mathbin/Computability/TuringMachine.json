{"write_self":
 "@[simp]\ntheorem tape.write_self {Γ} [Inhabited Γ] : ∀ T : Tape Γ, T.write T.1 = T := by rintro ⟨⟩ <;> rfl\n#align tape.write_self tape.write_self\n\n",
 "write_nth":
 "@[simp]\ntheorem tape.write_nth {Γ} [Inhabited Γ] (b : Γ) :\n    ∀ (T : Tape Γ) {i : ℤ}, (T.write b).nth i = if i = 0 then b else T.nth i\n  | ⟨a, L, R⟩, 0 => rfl\n  | ⟨a, L, R⟩, (n + 1 : ℕ) => rfl\n  | ⟨a, L, R⟩, -[n+1] => rfl\n#align tape.write_nth tape.write_nth\n\n",
 "write_move_right_n":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem tape.write_move_right_n {Γ} [Inhabited Γ] (f : Γ → Γ) (L R : ListBlank Γ) (n : ℕ) :\n    ((«expr ^[ ]» (Tape.move dir.right) n) (Tape.mk' L R)).write (f (R.nth n)) =\n      («expr ^[ ]» (Tape.move dir.right) n) (Tape.mk' L (R.modify_nth f n)) :=\n  by\n  induction' n with n IH generalizing L R\n  · simp only [list_blank.nth_zero, list_blank.modify_nth, iterate_zero_apply]\n    rw [← tape.write_mk', list_blank.cons_head_tail]\n  simp only [list_blank.head_cons, list_blank.nth_succ, list_blank.modify_nth, tape.move_right_mk',\n    list_blank.tail_cons, iterate_succ_apply, IH]\n#align tape.write_move_right_n tape.write_move_right_n\n\n",
 "write_mk'":
 "@[simp]\ntheorem tape.write_mk' {Γ} [Inhabited Γ] (a b : Γ) (L R : ListBlank Γ) :\n    (Tape.mk' L (R.cons a)).write b = Tape.mk' L (R.cons b) := by\n  simp only [tape.write, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self_iff]\n#align tape.write_mk' tape.write_mk'\n\n",
 "univ_supports":
 "theorem univ_supports (M : machine) : supports M Set.univ :=\n  ⟨trivial, fun q a q' s h₁ h₂ => trivial⟩\n#align univ_supports univ_supports\n\n",
 "trans":
 "theorem reaches₀.trans {σ} {f : σ → Option σ} {a b c : σ} (h₁ : Reaches₀ f a b) (h₂ : Reaches₀ f b c) : Reaches₀ f a c\n  | d, h₃ => h₁ _ (h₂ _ h₃)\n#align reaches₀.trans reaches₀.trans\n\n",
 "tr_tape_mk'":
 "theorem tr_tape_mk' (L R : ListBlank Γ) : tr_tape (Tape.mk' L R) = tr_tape' L R := by\n  simp only [tr_tape, tape.mk'_left, tape.mk'_right₀]\n#align tr_tape_mk' tr_tape_mk'\n\n",
 "tr_tape'_move_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem tr_tape'_move_right (L R) :\n    («expr ^[ ]» (Tape.move dir.right) n) (tr_tape' L R) = tr_tape' (L.cons R.head) R.tail :=\n  by\n  suffices ∀ i L, («expr ^[ ]» (tape.move dir.right) i) ((«expr ^[ ]» (tape.move dir.left) i) L) = L\n    by\n    refine' (Eq.symm _).trans (this n _)\n    simp only [tr_tape'_move_left, list_blank.cons_head_tail, list_blank.head_cons, list_blank.tail_cons]\n  intros\n  induction' i with i IH\n  · rfl\n  rw [iterate_succ_apply, iterate_succ_apply', tape.move_left_right, IH]\n#align tr_tape'_move_right tr_tape'_move_right\n\n",
 "tr_tape'_move_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem tr_tape'_move_left (L R) :\n    («expr ^[ ]» (Tape.move dir.left) n) (tr_tape' L R) = tr_tape' L.tail (R.cons L.head) :=\n  by\n  obtain ⟨a, L, rfl⟩ := L.exists_cons\n  simp only [tr_tape', list_blank.cons_bind, list_blank.head_cons, list_blank.tail_cons]\n  suffices\n    ∀ {L' R' l₁ l₂} (e : Vector.toList (enc a) = List.reverseAux l₁ l₂),\n      («expr ^[ ]» (tape.move dir.left) l₁.length) (tape.mk' (list_blank.append l₁ L') (list_blank.append l₂ R')) =\n        tape.mk' L' (list_blank.append (Vector.toList (enc a)) R')\n    by simpa only [List.length_reverse, Vector.toList_length] using this (List.reverse_reverse _).symm\n  intros\n  induction' l₁ with b l₁ IH generalizing l₂\n  · cases e\n    rfl\n  simp only [list.length, list.cons_append, iterate_succ_apply]\n  convert IH e\n  simp only [list_blank.tail_cons, list_blank.append, tape.move_left_mk', list_blank.head_cons]\n#align tr_tape'_move_left tr_tape'_move_left\n\n",
 "tr_supports":
 "theorem tr_supports {S} (ss : TM2.Supports M S) : TM1.Supports tr (tr_supp S) :=\n  ⟨Finset.mem_bunionᵢ.2 ⟨_, ss.1, Finset.mem_insert.2 <| or.inl rfl⟩, fun l' h =>\n    by\n    suffices\n      ∀ (q) (ss' : TM2.supports_stmt S q) (sub : ∀ x ∈ tr_stmts₁ q, x ∈ tr_supp M S),\n        TM1.supports_stmt (tr_supp M S) (tr_normal q) ∧ ∀ l' ∈ tr_stmts₁ q, TM1.supports_stmt (tr_supp M S) (tr M l')\n      by\n      rcases Finset.mem_bunionᵢ.1 h with ⟨l, lS, h⟩\n      have := this _ (ss.2 l lS) fun x hx => Finset.mem_bunionᵢ.2 ⟨_, lS, Finset.mem_insert_of_mem hx⟩\n      rcases Finset.mem_insert.1 h with (rfl | h) <;> [exact this.1, exact this.2 _ h]\n    clear h l'\n    refine' stmt_st_rec _ _ _ _ _ <;> intros\n    · -- stack op\n      rw [TM2to1.supports_run] at ss'\n      simp only [TM2to1.tr_stmts₁_run, Finset.mem_union, Finset.mem_insert, Finset.mem_singleton] at sub\n      have hgo := sub _ (or.inl <| or.inl rfl)\n      have hret := sub _ (or.inl <| or.inr rfl)\n      cases' IH ss' fun x hx => sub x <| or.inr hx with IH₁ IH₂\n      refine' ⟨by simp only [tr_normal_run, TM1.supports_stmt] <;> intros <;> exact hgo, fun l h => _⟩\n      rw [tr_stmts₁_run] at h\n      simp only [TM2to1.tr_stmts₁_run, Finset.mem_union, Finset.mem_insert, Finset.mem_singleton] at h\n      rcases h with (⟨rfl | rfl⟩ | h)\n      · unfold TM1.supports_stmt TM2to1.tr\n        rcases s with (_ | _ | _)\n        · exact ⟨fun _ _ => hret, fun _ _ => hgo⟩\n        · exact ⟨fun _ _ => hret, fun _ _ => hgo⟩\n        · exact ⟨⟨fun _ _ => hret, fun _ _ => hret⟩, fun _ _ => hgo⟩\n      · unfold TM1.supports_stmt TM2to1.tr\n        exact ⟨IH₁, fun _ _ => hret⟩\n      · exact IH₂ _ h\n    · -- load\n      unfold TM2to1.tr_stmts₁ at ss' sub⊢\n      exact IH ss' sub\n    · -- branch\n      unfold TM2to1.tr_stmts₁ at sub\n      cases' IH₁ ss'.1 fun x hx => sub x <| Finset.mem_union_left _ hx with IH₁₁ IH₁₂\n      cases' IH₂ ss'.2 fun x hx => sub x <| Finset.mem_union_right _ hx with IH₂₁ IH₂₂\n      refine' ⟨⟨IH₁₁, IH₂₁⟩, fun l h => _⟩\n      rw [tr_stmts₁] at h\n      rcases Finset.mem_union.1 h with (h | h) <;> [exact IH₁₂ _ h, exact IH₂₂ _ h]\n    · -- goto\n      rw [tr_stmts₁]\n      unfold TM2to1.tr_normal TM1.supports_stmt\n      unfold TM2.supports_stmt at ss'\n      exact ⟨fun _ v => Finset.mem_bunionᵢ.2 ⟨_, ss' v, Finset.mem_insert_self _ _⟩, fun _ => false.elim⟩\n    · exact ⟨trivial, fun _ => false.elim⟩⟩\n#align tr_supports tr_supports\n\n",
 "tr_stmts₁_run":
 "theorem tr_stmts₁_run {k s q} : tr_stmts₁ (st_run s q) = {go k s q, ret q} ∪ tr_stmts₁ q := by\n  rcases s with (_ | _ | _) <;> unfold tr_stmts₁ st_run\n#align tr_stmts₁_run tr_stmts₁_run\n\n",
 "tr_respects_aux₃":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem tr_respects_aux₃ {q v} {L : ListBlank (∀ k, Option (Γ k))} (n) :\n    Reaches₀ (TM1.step tr) ⟨some (ret q), v, («expr ^[ ]» (Tape.move dir.right) n) (Tape.mk' ∅ (add_bottom L))⟩\n      ⟨some (ret q), v, Tape.mk' ∅ (add_bottom L)⟩ :=\n  by\n  induction' n with n IH; · rfl\n  refine' reaches₀.head _ IH\n  rw [Option.mem_def, TM1.step, tr, TM1.step_aux, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_succ_fst,\n    TM1.step_aux, iterate_succ', tape.move_right_left]\n  rfl\n#align tr_respects_aux₃ tr_respects_aux₃\n\n",
 "tr_respects_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem tr_respects_aux₂ {k q v} {S : ∀ k, List (Γ k)} {L : ListBlank (∀ k, Option (Γ k))}\n    (hL : ∀ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o) :\n    let v' := st_var v (S k) o\n    let Sk' := st_write v (S k) o\n    let S' := update S k Sk'\n    ∃ L' : ListBlank (∀ k, Option (Γ k)),\n      (∀ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) ∧\n        TM1.stepAux (tr_st_act q o) v ((«expr ^[ ]» (Tape.move dir.right) (S k).length) (Tape.mk' ∅ (add_bottom L))) =\n          TM1.stepAux q v' ((«expr ^[ ]» (Tape.move dir.right) (S' k).length) (Tape.mk' ∅ (add_bottom L'))) :=\n  by\n  dsimp only; simp; cases o <;> simp only [st_write, st_var, tr_st_act, TM1.step_aux]\n  case push f =>\n    have := tape.write_move_right_n fun a : Γ' => (a.1, update a.2 k (some (f v)))\n    dsimp only at this\n    refine'\n      ⟨_, fun k' => _, by\n        rw [tape.move_right_n_head, list.length, tape.mk'_nth_nat, this,\n          add_bottom_modify_nth fun a => update a k (some (f v)), nat.add_one, iterate_succ']⟩\n    refine' list_blank.ext fun i => _\n    rw [list_blank.nth_map, list_blank.nth_modify_nth, proj, pointed_map.mk_val]\n    by_cases h' : k' = k\n    · subst k'\n      split_ifs <;> simp only [List.reverse_cons, Function.update_same, list_blank.nth_mk, list.map]\n      ·\n        rw [List.getI_eq_nthLe, List.nthLe_append_right] <;>\n          simp only [h, List.nthLe_singleton, list.length_map, List.length_reverse, Nat.succ_pos', list.length_append,\n            lt_add_iff_pos_right, list.length]\n      rw [← proj_map_nth, hL, list_blank.nth_mk]\n      cases' lt_or_gt_of_ne h with h h\n      · rw [List.getI_append]\n        simpa only [list.length_map, List.length_reverse] using h\n      · rw [gt_iff_lt] at h\n        rw [List.getI_eq_default, List.getI_eq_default] <;>\n          simp only [Nat.add_one_le_iff, h, list.length, le_of_lt, List.length_reverse, list.length_append,\n            list.length_map]\n    · split_ifs <;> rw [Function.update_noteq h', ← proj_map_nth, hL]\n      rw [Function.update_noteq h']\n  case peek f =>\n    rw [Function.update_eq_self]\n    use L, hL; rw [tape.move_left_right]; congr\n    cases e : S k; · rfl\n    rw [list.length_cons, iterate_succ', tape.move_right_left, tape.move_right_n_head, tape.mk'_nth_nat,\n      add_bottom_nth_snd, stk_nth_val _ (hL k), e, List.reverse_cons, ← List.length_reverse, List.get?_concat_length]\n    rfl\n  case pop f =>\n    cases e : S k\n    · simp only [tape.mk'_head, list_blank.head_cons, tape.move_left_mk', list.length, tape.write_mk', List.head?,\n        iterate_zero_apply, List.tail_nil]\n      rw [← e, Function.update_eq_self]\n      exact ⟨L, hL, by rw [add_bottom_head_fst, cond]⟩\n    · refine'\n        ⟨_, fun k' => _, by\n          rw [list.length_cons, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_succ_fst, cond, iterate_succ',\n            tape.move_right_left, tape.move_right_n_head, tape.mk'_nth_nat,\n            tape.write_move_right_n fun a : Γ' => (a.1, update a.2 k none),\n            add_bottom_modify_nth fun a => update a k none, add_bottom_nth_snd, stk_nth_val _ (hL k), e,\n            show (List.cons hd tl).reverse.nth tl.length = some hd by\n              rw [List.reverse_cons, ← List.length_reverse, List.get?_concat_length] <;> rfl,\n            List.head?, list.tail]⟩\n      refine' list_blank.ext fun i => _\n      rw [list_blank.nth_map, list_blank.nth_modify_nth, proj, pointed_map.mk_val]\n      by_cases h' : k' = k\n      · subst k'\n        split_ifs <;> simp only [Function.update_same, list_blank.nth_mk, list.tail]\n        · rw [List.getI_eq_default]\n          · rfl\n          rw [h, List.length_reverse, list.length_map]\n        rw [← proj_map_nth, hL, list_blank.nth_mk, e, list.map, List.reverse_cons]\n        cases' lt_or_gt_of_ne h with h h\n        · rw [List.getI_append]\n          simpa only [list.length_map, List.length_reverse] using h\n        · rw [gt_iff_lt] at h\n          rw [List.getI_eq_default, List.getI_eq_default] <;>\n            simp only [Nat.add_one_le_iff, h, list.length, le_of_lt, List.length_reverse, list.length_append,\n              list.length_map]\n      · split_ifs <;> rw [Function.update_noteq h', ← proj_map_nth, hL]\n        rw [Function.update_noteq h']\n#align tr_respects_aux₂ tr_respects_aux₂\n\n",
 "tr_respects_aux₁":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (n «expr ≤ » S.length) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem tr_respects_aux₁ {k} (o q v) {S : List (Γ k)} {L : ListBlank (∀ k, Option (Γ k))}\n    (hL : L.map (proj k) = ListBlank.mk (S.map some).reverse) (n) (_ : n ≤ S.length) :\n    Reaches₀ (TM1.step tr) ⟨some (go k o q), v, Tape.mk' ∅ (add_bottom L)⟩\n      ⟨some (go k o q), v, («expr ^[ ]» (Tape.move dir.right) n) (Tape.mk' ∅ (add_bottom L))⟩ :=\n  by\n  induction' n with n IH; · rfl\n  apply (IH (le_of_lt H)).tail\n  rw [iterate_succ_apply'];\n  simp only [TM1.step, TM1.step_aux, tr, tape.mk'_nth_nat, tape.move_right_n_head, add_bottom_nth_snd, Option.mem_def]\n  rw [stk_nth_val _ hL, List.nthLe_get?]; rfl; rwa [List.length_reverse]\n#align tr_respects_aux₁ tr_respects_aux₁\n\n",
 "tr_respects_aux":
 "theorem tr_respects_aux {q v T k} {S : ∀ k, List (Γ k)}\n    (hT : ∀ k, ListBlank.map (proj k) T = ListBlank.mk ((S k).map some).reverse) (o : st_act k)\n    (IH :\n      ∀ {v : σ} {S : ∀ k : K, List (Γ k)} {T : ListBlank (∀ k, Option (Γ k))},\n        (∀ k, ListBlank.map (proj k) T = ListBlank.mk ((S k).map some).reverse) →\n          ∃ b,\n            tr_cfg (TM2.stepAux q v S) b ∧\n              Reaches (TM1.step tr) (TM1.stepAux (tr_normal q) v (Tape.mk' ∅ (add_bottom T))) b) :\n    ∃ b,\n      tr_cfg (TM2.stepAux (st_run o q) v S) b ∧\n        Reaches (TM1.step tr) (TM1.stepAux (tr_normal (st_run o q)) v (Tape.mk' ∅ (add_bottom T))) b :=\n  by\n  simp only [tr_normal_run, step_run]\n  have hgo := tr_respects_aux₁ M o q v (hT k) _ le_rfl\n  obtain ⟨T', hT', hrun⟩ := tr_respects_aux₂ hT o\n  have hret := tr_respects_aux₃ M _\n  have := hgo.tail' rfl\n  rw [tr, TM1.step_aux, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_snd, stk_nth_val _ (hT k),\n    List.get?_len_le (le_of_eq (List.length_reverse _)), option.is_none, cond, hrun, TM1.step_aux] at this\n  obtain ⟨c, gc, rc⟩ := IH hT'\n  refine' ⟨c, gc, (this.to₀.trans hret c (trans_gen.head' rfl _)).to_refl⟩\n  rw [tr, TM1.step_aux, tape.mk'_head, add_bottom_head_fst]\n  exact rc\n#align tr_respects_aux tr_respects_aux\n\n",
 "tr_respects":
 "theorem tr_respects : Respects (TM2.step M) (TM1.step tr) tr_cfg := fun c₁ c₂ h =>\n  by\n  cases' h with l v S L hT; clear h\n  cases l; · constructor\n  simp only [TM2.step, respects, Option.map_some']\n  rsuffices ⟨b, c, r⟩ : ∃ b, _ ∧ reaches (TM1.step (tr M)) _ _\n  · exact ⟨b, c, trans_gen.head' rfl r⟩\n  rw [tr]\n  revert v S L hT; refine' stmt_st_rec _ _ _ _ _ (M l) <;> intros\n  · exact tr_respects_aux M hT s @IH\n  · exact IH _ hT\n  · unfold TM2.step_aux tr_normal TM1.step_aux\n    cases p v <;> [exact IH₂ _ hT, exact IH₁ _ hT]\n  · exact ⟨_, ⟨_, hT⟩, refl_trans_gen.refl⟩\n  · exact ⟨_, ⟨_, hT⟩, refl_trans_gen.refl⟩\n#align tr_respects tr_respects\n\n",
 "tr_reaches₁":
 "theorem tr_reaches₁ {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂} (aa : tr a₁ a₂) {b₁}\n    (ab : Reaches₁ f₁ a₁ b₁) : ∃ b₂, tr b₁ b₂ ∧ Reaches₁ f₂ a₂ b₂ :=\n  by\n  induction' ab with c₁ ac c₁ d₁ ac cd IH\n  · have := H aa\n    rwa [show f₁ a₁ = _ from ac] at this\n  · rcases IH with ⟨c₂, cc, ac₂⟩\n    have := H cc\n    rw [show f₁ c₁ = _ from cd] at this\n    rcases this with ⟨d₂, dd, cd₂⟩\n    exact ⟨_, dd, ac₂.trans cd₂⟩\n#align tr_reaches₁ tr_reaches₁\n\n",
 "tr_reaches_rev":
 "theorem tr_reaches_rev {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂} (aa : tr a₁ a₂) {b₂}\n    (ab : Reaches f₂ a₂ b₂) : ∃ c₁ c₂, Reaches f₂ b₂ c₂ ∧ tr c₁ c₂ ∧ Reaches f₁ a₁ c₁ :=\n  by\n  induction' ab with c₂ d₂ ac cd IH\n  · exact ⟨_, _, refl_trans_gen.refl, aa, refl_trans_gen.refl⟩\n  · rcases IH with ⟨e₁, e₂, ce, ee, ae⟩\n    rcases refl_trans_gen.cases_head ce with (rfl | ⟨d', cd', de⟩)\n    · have := H ee\n      revert this\n      cases' eg : f₁ e₁ with g₁ <;> simp only [respects, and_imp, exists_imp]\n      · intro c0\n        cases cd.symm.trans c0\n      · intro g₂ gg cg\n        rcases trans_gen.head'_iff.1 cg with ⟨d', cd', dg⟩\n        cases Option.mem_unique cd cd'\n        exact ⟨_, _, dg, gg, ae.tail eg⟩\n    · cases Option.mem_unique cd cd'\n      exact ⟨_, _, de, ee, ae⟩\n#align tr_reaches_rev tr_reaches_rev\n\n",
 "tr_reaches":
 "theorem tr_reaches {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂} (aa : tr a₁ a₂) {b₁}\n    (ab : Reaches f₁ a₁ b₁) : ∃ b₂, tr b₁ b₂ ∧ Reaches f₂ a₂ b₂ :=\n  by\n  rcases refl_trans_gen_iff_eq_or_trans_gen.1 ab with (rfl | ab)\n  · exact ⟨_, aa, refl_trans_gen.refl⟩\n  ·\n    exact\n      let ⟨b₂, bb, h⟩ := tr_reaches₁ H aa ab\n      ⟨b₂, bb, h.to_refl⟩\n#align tr_reaches tr_reaches\n\n",
 "tr_normal_run":
 "theorem tr_normal_run {k} (s q) : tr_normal (st_run s q) = goto fun _ _ => go k s q := by\n  rcases s with (_ | _ | _) <;> rfl\n#align tr_normal_run tr_normal_run\n\n",
 "tr_eval_rev":
 "theorem tr_eval_rev {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ b₂ a₂} (aa : tr a₁ a₂)\n    (ab : b₂ ∈ eval f₂ a₂) : ∃ b₁, tr b₁ b₂ ∧ b₁ ∈ eval f₁ a₁ :=\n  by\n  cases' mem_eval.1 ab with ab b0\n  rcases tr_reaches_rev H aa ab with ⟨c₁, c₂, bc, cc, ac⟩\n  cases (refl_trans_gen_iff_eq (Option.eq_none_iff_forall_not_mem.1 b0)).1 bc\n  refine' ⟨_, cc, mem_eval.2 ⟨ac, _⟩⟩\n  have := H cc; cases' f₁ c₁ with d₁; · rfl\n  rcases this with ⟨d₂, dd, bd⟩\n  rcases trans_gen.head'_iff.1 bd with ⟨e, h, _⟩\n  cases b0.symm.trans h\n#align tr_eval_rev tr_eval_rev\n\n",
 "tr_eval_dom":
 "theorem tr_eval_dom (k) (L : List (Γ k)) : (TM1.eval tr (tr_init k L)).dom ↔ (TM2.eval M k L).dom :=\n  tr_eval_dom tr_respects (tr_cfg_init _ _)\n#align tr_eval_dom tr_eval_dom\n\n",
 "tr_eval'":
 "theorem tr_eval' {σ₁ σ₂} (f₁ : σ₁ → Option σ₁) (f₂ : σ₂ → Option σ₂) (tr : σ₁ → σ₂)\n    (H : Respects f₁ f₂ fun a b => tr a = b) (a₁) : eval f₂ (tr a₁) = tr <$> eval f₁ a₁ :=\n  Part.ext fun b₂ =>\n    ⟨fun h =>\n      let ⟨b₁, bb, hb⟩ := tr_eval_rev H rfl h\n      (Part.mem_map_iff _).2 ⟨b₁, hb, bb⟩,\n      fun h => by\n      rcases(Part.mem_map_iff _).1 h with ⟨b₁, ab, bb⟩\n      rcases tr_eval H rfl ab with ⟨_, rfl, h⟩\n      rwa [bb] at h⟩\n#align tr_eval' tr_eval'\n\n",
 "tr_eval":
 "theorem tr_eval (k) (L : List (Γ k)) {L₁ L₂} (H₁ : L₁ ∈ TM1.eval tr (tr_init k L)) (H₂ : L₂ ∈ TM2.eval M k L) :\n    ∃ (S : ∀ k, List (Γ k))(L' : ListBlank (∀ k, Option (Γ k))),\n      add_bottom L' = L₁ ∧ (∀ k, L'.map (proj k) = ListBlank.mk ((S k).map some).reverse) ∧ S k = L₂ :=\n  by\n  obtain ⟨c₁, h₁, rfl⟩ := (Part.mem_map_iff _).1 H₁\n  obtain ⟨c₂, h₂, rfl⟩ := (Part.mem_map_iff _).1 H₂\n  obtain ⟨_, ⟨L', hT⟩, h₃⟩ := tr_eval (tr_respects M) (tr_cfg_init M k L) h₂\n  cases Part.mem_unique h₁ h₃\n  exact ⟨_, L', by simp only [tape.mk'_right₀], hT, rfl⟩\n#align tr_eval tr_eval\n\n",
 "tr_cfg_init":
 "theorem tr_cfg_init (k) (L : List (Γ k)) : tr_cfg (TM2.init k L) (TM1.init (tr_init k L)) :=\n  by\n  rw [(_ : TM1.init _ = _)]\n  · refine' ⟨list_blank.mk (L.reverse.map fun a => update default k (some a)), fun k' => _⟩\n    refine' list_blank.ext fun i => _\n    rw [list_blank.map_mk, list_blank.nth_mk, List.getI_eq_iget_get?, list.map_map, (· ∘ ·), List.get?_map, proj,\n      pointed_map.mk_val]\n    by_cases k' = k\n    · subst k'\n      simp only [Function.update_same]\n      rw [list_blank.nth_mk, List.getI_eq_iget_get?, ← List.map_reverse, List.get?_map]\n    · simp only [Function.update_noteq h]\n      rw [list_blank.nth_mk, List.getI_eq_iget_get?, list.map, List.reverse_nil, List.get?]\n      cases L.reverse.nth i <;> rfl\n  · rw [tr_init, TM1.init]\n    dsimp only\n    congr <;> cases L.reverse <;> try rfl\n    simp only [list.map_map, List.tail_cons, list.map]\n    rfl\n#align tr_cfg_init tr_cfg_init\n\n",
 "to₀":
 "theorem reaches.to₀ {σ} {f : σ → Option σ} {a b : σ} (h : Reaches f a b) : Reaches₀ f a b\n  | c, h₂ => h₂.trans_right h\n#align reaches.to₀ reaches.to₀\n\n",
 "tail_mk":
 "@[simp]\ntheorem list_blank.tail_mk {Γ} [Inhabited Γ] (l : List Γ) : ListBlank.tail (ListBlank.mk l) = ListBlank.mk l.tail :=\n  rfl\n#align list_blank.tail_mk list_blank.tail_mk\n\n",
 "tail_map":
 "@[simp]\ntheorem list_blank.tail_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : ListBlank Γ) :\n    (l.map f).tail = l.tail.map f :=\n  by\n  conv =>\n    lhs\n    rw [← list_blank.cons_head_tail l]\n  exact Quotient.inductionOn' l fun a => rfl\n#align list_blank.tail_map list_blank.tail_map\n\n",
 "tail_cons":
 "@[simp]\ntheorem list_blank.tail_cons {Γ} [Inhabited Γ] (a : Γ) : ∀ l : ListBlank Γ, (l.cons a).tail = l :=\n  Quotient.ind' fun l => rfl\n#align list_blank.tail_cons list_blank.tail_cons\n\n",
 "tail'":
 "theorem reaches₀.tail' {σ} {f : σ → Option σ} {a b c : σ} (h : Reaches₀ f a b) (h₂ : c ∈ f b) : Reaches₁ f a c :=\n  h _ (trans_gen.single h₂)\n#align reaches₀.tail' reaches₀.tail'\n\n",
 "tail":
 "theorem reaches₀.tail {σ} {f : σ → Option σ} {a b c : σ} (h₁ : Reaches₀ f a b) (h : c ∈ f b) : Reaches₀ f a c :=\n  h₁.trans (Reaches₀.single h)\n#align reaches₀.tail reaches₀.tail\n\n",
 "symm":
 "@[symm]\ntheorem blank_rel.symm {Γ} [Inhabited Γ] {l₁ l₂ : List Γ} : BlankRel l₁ l₂ → BlankRel l₂ l₁ :=\n  Or.symm\n#align blank_rel.symm blank_rel.symm\n\n",
 "supports_stmt_write":
 "theorem supports_stmt_write {S l q} : SupportsStmt S (write l q) = SupportsStmt S q := by\n  induction' l with a l IH <;> simp only [write, supports_stmt, *]\n#align supports_stmt_write supports_stmt_write\n\n",
 "supports_stmt_read":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprstmt' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprstmt' -/\ntheorem supports_stmt_read {S} : ∀ {f : Γ → exprstmt'}, (∀ a, SupportsStmt S (f a)) → SupportsStmt S (read f) :=\n  suffices ∀ (i) (f : Vector Bool i → exprstmt'), (∀ v, SupportsStmt S (f v)) → SupportsStmt S (read_aux i f) from\n    fun f hf => this n _ (by intro <;> simp only [supports_stmt_move, hf])\n  fun i f hf => by\n  induction' i with i IH; · exact hf _\n  constructor <;> apply IH <;> intro <;> apply hf\n#align supports_stmt_read supports_stmt_read\n\n",
 "supports_stmt_move":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem supports_stmt_move {S d q} : SupportsStmt S (move d q) = SupportsStmt S q :=\n  by\n  suffices ∀ {i}, SupportsStmt S ((«expr ^[ ]» (stmt.move d) i) q) = _ from this\n  intro <;> induction i generalizing q <;> simp only [*, iterate] <;> rfl\n#align supports_stmt_move supports_stmt_move\n\n",
 "supports_run":
 "-- [inhabited Λ]: as this is a local definition it is more trouble than\n-- it is worth to omit the typeclass assumption without breaking the parameters\ntheorem supports_run (S : Finset Λ) {k} (s : st_act k) (q) : TM2.SupportsStmt S (st_run s q) ↔ TM2.SupportsStmt S q :=\n  by rcases s with (_ | _ | _) <;> rfl\n#align supports_run supports_run\n\n",
 "stmts₁_trans":
 "theorem stmts₁_trans {q₁ q₂} : q₁ ∈ stmts₁ q₂ → stmts₁ q₁ ⊆ stmts₁ q₂ :=\n  by\n  intro h₁₂ q₀ h₀₁\n  induction' q₂ with _ _ q IH _ _ q IH _ _ q IH _ q IH <;> simp only [stmts₁] at h₁₂⊢ <;>\n    simp only [Finset.mem_insert, Finset.mem_singleton, Finset.mem_union] at h₁₂\n  iterate 4 \n    rcases h₁₂ with (rfl | h₁₂)\n    · unfold stmts₁ at h₀₁\n      exact h₀₁\n    · exact Finset.mem_insert_of_mem (IH h₁₂)\n  case branch f q₁ q₂ IH₁ IH₂ =>\n    rcases h₁₂ with (rfl | h₁₂ | h₁₂)\n    · unfold stmts₁ at h₀₁\n      exact h₀₁\n    · exact Finset.mem_insert_of_mem (Finset.mem_union_left _ (IH₁ h₁₂))\n    · exact Finset.mem_insert_of_mem (Finset.mem_union_right _ (IH₂ h₁₂))\n  case goto l => subst h₁₂; exact h₀₁\n  case halt => subst h₁₂; exact h₀₁\n#align stmts₁_trans stmts₁_trans\n\n",
 "stmts₁_supports_stmt_mono":
 "theorem stmts₁_supports_stmt_mono {S q₁ q₂} (h : q₁ ∈ stmts₁ q₂) (hs : supports_stmt S q₂) : supports_stmt S q₁ :=\n  by\n  induction' q₂ with _ _ q IH _ _ q IH _ _ q IH _ q IH <;>\n    simp only [stmts₁, supports_stmt, Finset.mem_insert, Finset.mem_union, Finset.mem_singleton] at h hs\n  iterate 4 rcases h with (rfl | h) <;> [exact hs, exact IH h hs]\n  case branch f q₁ q₂ IH₁ IH₂ => rcases h with (rfl | h | h); exacts[hs, IH₁ h hs.1, IH₂ h hs.2]\n  case goto l => subst h; exact hs\n  case halt => subst h; trivial\n#align stmts₁_supports_stmt_mono stmts₁_supports_stmt_mono\n\n",
 "stmts₁_self":
 "-- Index type of stacks\n-- Type of stack elements\n-- Type of function labels\n-- Type of variable settings\ntheorem stmts₁_self {q} : q ∈ stmts₁ q := by cases q <;> apply_rules [Finset.mem_insert_self, Finset.mem_singleton_self]\n#align stmts₁_self stmts₁_self\n\n",
 "stmts_trans":
 "theorem stmts_trans {M : Λ → stmt} {S q₁ q₂} (h₁ : q₁ ∈ stmts₁ q₂) : some q₂ ∈ stmts M S → some q₁ ∈ stmts M S := by\n  simp only [stmts, Finset.mem_insertNone, Finset.mem_bunionᵢ, Option.mem_def, forall_eq', exists_imp] <;>\n    exact fun l ls h₂ => ⟨_, ls, stmts₁_trans h₂ h₁⟩\n#align stmts_trans stmts_trans\n\n",
 "stmts_supports_stmt":
 "theorem stmts_supports_stmt {M : Λ → stmt} {S q} (ss : supports M S) : some q ∈ stmts M S → supports_stmt S q := by\n  simp only [stmts, Finset.mem_insertNone, Finset.mem_bunionᵢ, Option.mem_def, forall_eq', exists_imp] <;>\n    exact fun l ls h => stmts₁_supports_stmt_mono h (ss.2 _ ls)\n#align stmts_supports_stmt stmts_supports_stmt\n\n",
 "stk_nth_val":
 "-- A displaced lemma proved in unnecessary generality\ntheorem stk_nth_val {K : Type _} {Γ : K → Type _} {L : ListBlank (∀ k, Option (Γ k))} {k S} (n)\n    (hL : ListBlank.map (proj k) L = ListBlank.mk (list.map some S).reverse) : L.nth n k = S.reverse.nth n :=\n  by\n  rw [← proj_map_nth, hL, ← List.map_reverse, list_blank.nth_mk, List.getI_eq_iget_get?, List.get?_map]\n  cases S.reverse.nth n <;> rfl\n#align stk_nth_val stk_nth_val\n\n",
 "step_supports":
 "theorem step_supports (M : Λ → stmt) {S} (ss : supports M S) :\n    ∀ {c c' : cfg}, c' ∈ step M c → c.l ∈ S.insert_none → c'.l ∈ S.insert_none\n  | ⟨some l₁, v, T⟩, c', h₁, h₂ =>\n    by\n    replace h₂ := ss.2 _ (Finset.some_mem_insertNone.1 h₂)\n    simp only [step, Option.mem_def] at h₁; subst c'\n    revert h₂; induction' M l₁ with _ _ q IH _ _ q IH _ _ q IH _ q IH generalizing v T <;> intro hs\n    iterate 4 exact IH _ _ hs\n    case branch p q₁' q₂' IH₁ IH₂ =>\n      unfold step_aux; cases p v\n      · exact IH₂ _ _ hs.2\n      · exact IH₁ _ _ hs.1\n    case goto => exact Finset.some_mem_insertNone.2 (hs _)\n    case halt => apply Multiset.mem_cons_self\n#align step_supports step_supports\n\n",
 "step_run":
 "theorem step_run {k : K} (q v S) :\n    ∀ s : st_act k, TM2.stepAux (st_run s q) v S = TM2.stepAux q (st_var v (S k) s) (update S k (st_write v (S k) s))\n  | st_act.push f => rfl\n  | st_act.peek f => by unfold st_write <;> rw [Function.update_eq_self] <;> rfl\n  | st_act.pop f => rfl\n#align step_run step_run\n\n",
 "step_aux_write":
 "theorem step_aux_write (q v a b L R) :\n    stepAux (write (enc a).to_list q) v (tr_tape' L (ListBlank.cons b R)) =\n      stepAux q v (tr_tape' (ListBlank.cons a L) R) :=\n  by\n  simp only [tr_tape', list.cons_bind, list.append_assoc]\n  suffices\n    ∀ {L' R'} (l₁ l₂ l₂' : List Bool) (e : l₂'.length = l₂.length),\n      step_aux (write l₂ q) v (tape.mk' (list_blank.append l₁ L') (list_blank.append l₂' R')) =\n        step_aux q v (tape.mk' (L'.append (List.reverseAux l₂ l₁)) R')\n    by convert this [] _ _ ((enc b).2.trans (enc a).2.symm) <;> rw [list_blank.cons_bind] <;> rfl\n  clear a b L R\n  intros\n  induction' l₂ with a l₂ IH generalizing l₁ l₂'\n  · cases List.length_eq_zero.1 e\n    rfl\n  cases' l₂' with b l₂' <;> injection e with e\n  dsimp only [write, step_aux]\n  convert IH _ _ e using 1\n  simp only [list_blank.head_cons, list_blank.tail_cons, list_blank.append, tape.move_right_mk', tape.write_mk']\n#align step_aux_write step_aux_write\n\n",
 "step_aux_read":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem step_aux_read (f v L R) : stepAux (read f) v (tr_tape' L R) = stepAux (f R.head) v (tr_tape' L R) :=\n  by\n  suffices\n    ∀ f,\n      step_aux (read_aux n f) v (tr_tape' enc0 L R) = step_aux (f (enc R.head)) v (tr_tape' enc0 (L.cons R.head) R.tail)\n    by\n    rw [read, this, step_aux_move, encdec, tr_tape'_move_left enc0]\n    simp only [list_blank.head_cons, list_blank.cons_head_tail, list_blank.tail_cons]\n  obtain ⟨a, R, rfl⟩ := R.exists_cons\n  simp only [list_blank.head_cons, list_blank.tail_cons, tr_tape', list_blank.cons_bind, list_blank.append_assoc]\n  suffices\n    ∀ i f L' R' l₁ l₂ h,\n      step_aux (read_aux i f) v (tape.mk' (list_blank.append l₁ L') (list_blank.append l₂ R')) =\n        step_aux (f ⟨l₂, h⟩) v (tape.mk' (list_blank.append (l₂.reverse_core l₁) L') R')\n    by\n    intro f\n    convert this n f _ _ _ _ (enc a).2 <;> simp\n  clear f L a R\n  intros\n  subst i\n  induction' l₂ with a l₂ IH generalizing l₁\n  · rfl\n  trans step_aux (read_aux l₂.length fun v => f («expr ::ᵥ » a v)) v (tape.mk' ((L'.append l₁).cons a) (R'.append l₂))\n  · dsimp [read_aux, step_aux]\n    simp\n    cases a <;> rfl\n  rw [← list_blank.append, IH]\n  rfl\n#align step_aux_read step_aux_read\n\n",
 "step_aux_move":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem step_aux_move (d q v T) : stepAux (move d q) v T = stepAux q v ((«expr ^[ ]» (Tape.move d) n) T) :=\n  by\n  suffices : ∀ i, step_aux ((«expr ^[ ]» (stmt.move d) i) q) v T = step_aux q v ((«expr ^[ ]» (tape.move d) i) T)\n  exact this n\n  intro ; induction' i with i IH generalizing T; · rfl\n  rw [iterate_succ', step_aux, IH, iterate_succ]\n#align step_aux_move step_aux_move\n\n",
 "single":
 "theorem reaches₀.single {σ} {f : σ → Option σ} {a b : σ} (h : b ∈ f a) : Reaches₀ f a b\n  | c, h₂ => h₂.head h\n#align reaches₀.single reaches₀.single\n\n",
 "right₀_nth":
 "theorem tape.right₀_nth {Γ} [Inhabited Γ] (T : Tape Γ) (n : ℕ) : T.right₀.nth n = T.nth n := by\n  cases n <;>\n    simp only [tape.nth, tape.right₀, Int.ofNat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons,\n      list_blank.tail_cons]\n#align tape.right₀_nth tape.right₀_nth\n\n",
 "refl":
 "@[refl]\ntheorem reaches₀.refl {σ} {f : σ → Option σ} (a : σ) : Reaches₀ f a a\n  | b, h => h\n#align reaches₀.refl reaches₀.refl\n\n",
 "reaches₁_fwd":
 "theorem reaches₁_fwd {σ} {f : σ → Option σ} {a b c} (h₁ : Reaches₁ f a c) (h₂ : b ∈ f a) : Reaches f b c :=\n  by\n  rcases trans_gen.head'_iff.1 h₁ with ⟨b', hab, hbc⟩\n  cases Option.mem_unique hab h₂; exact hbc\n#align reaches₁_fwd reaches₁_fwd\n\n",
 "reaches₁_eq":
 "theorem reaches₁_eq {σ} {f : σ → Option σ} {a b c} (h : f a = f b) : Reaches₁ f a c ↔ Reaches₁ f b c :=\n  TransGen.head'_iff.trans (TransGen.head'_iff.trans <| by rw [h]).symm\n#align reaches₁_eq reaches₁_eq\n\n",
 "reaches₀_eq":
 "theorem reaches₀_eq {σ} {f : σ → Option σ} {a b} (e : f a = f b) : Reaches₀ f a b\n  | d, h => (reaches₁_eq e).2 h\n#align reaches₀_eq reaches₀_eq\n\n",
 "reaches_total":
 "theorem reaches_total {σ} {f : σ → Option σ} {a b c} (hab : Reaches f a b) (hac : Reaches f a c) :\n    Reaches f b c ∨ Reaches f c b :=\n  ReflTransGen.total_of_right_unique (fun _ _ _ => Option.mem_unique) hab hac\n#align reaches_total reaches_total\n\n",
 "reaches_eval":
 "theorem reaches_eval {σ} {f : σ → Option σ} {a b} (ab : Reaches f a b) : eval f a = eval f b :=\n  Part.ext fun c =>\n    ⟨fun h =>\n      let ⟨ac, c0⟩ := mem_eval.1 h\n      mem_eval.2\n        ⟨(or_iff_left_of_imp fun cb => (eval_maximal h).1 cb ▸ refl_trans_gen.refl).1 (reaches_total ab ac), c0⟩,\n      fun h =>\n      let ⟨bc, c0⟩ := mem_eval.1 h\n      mem_eval.2 ⟨ab.trans bc, c0⟩⟩\n#align reaches_eval reaches_eval\n\n",
 "proj_map_nth":
 "theorem proj_map_nth {ι : Type _} {Γ : ι → Type _} [∀ i, Inhabited (Γ i)] (i : ι) (L n) :\n    (ListBlank.map (@proj ι Γ _ i) L).nth n = L.nth n i := by rw [list_blank.nth_map] <;> rfl\n#align proj_map_nth proj_map_nth\n\n",
 "nth_zero":
 "@[simp]\ntheorem tape.nth_zero {Γ} [Inhabited Γ] (T : Tape Γ) : T.nth 0 = T.1 :=\n  rfl\n#align tape.nth_zero tape.nth_zero\n\n",
 "nth_succ":
 "@[simp]\ntheorem list_blank.nth_succ {Γ} [Inhabited Γ] (l : ListBlank Γ) (n : ℕ) : l.nth (n + 1) = l.tail.nth n :=\n  by\n  conv =>\n    lhs\n    rw [← list_blank.cons_head_tail l]\n  exact Quotient.inductionOn' l.tail fun l => rfl\n#align list_blank.nth_succ list_blank.nth_succ\n\n",
 "nth_modify_nth":
 "theorem list_blank.nth_modify_nth {Γ} [Inhabited Γ] (f : Γ → Γ) (n i) (L : ListBlank Γ) :\n    (L.modify_nth f n).nth i = if i = n then f (L.nth i) else L.nth i :=\n  by\n  induction' n with n IH generalizing i L\n  ·\n    cases i <;>\n      simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true,\n        list_blank.nth_succ, if_false, list_blank.tail_cons]\n  · cases i\n    · rw [if_neg (nat.succ_ne_zero _).symm]\n      simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth]\n    · simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons]\n#align list_blank.nth_modify_nth list_blank.nth_modify_nth\n\n",
 "nth_mk":
 "@[simp]\ntheorem list_blank.nth_mk {Γ} [Inhabited Γ] (l : List Γ) (n : ℕ) : (ListBlank.mk l).nth n = l.inth n :=\n  rfl\n#align list_blank.nth_mk list_blank.nth_mk\n\n",
 "nth_map":
 "@[simp]\ntheorem list_blank.nth_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : ListBlank Γ) (n : ℕ) :\n    (l.map f).nth n = f (l.nth n) :=\n  l.induction_on\n    (by\n      intro l; simp only [List.get?_map, list_blank.map_mk, list_blank.nth_mk, List.getI_eq_iget_get?]\n      cases l.nth n; · exact f.2.symm; · rfl)\n#align list_blank.nth_map list_blank.nth_map\n\n",
 "move_right_nth":
 "@[simp]\ntheorem tape.move_right_nth {Γ} [Inhabited Γ] (T : Tape Γ) (i : ℤ) : (T.move dir.right).nth i = T.nth (i + 1) := by\n  conv =>\n      rhs\n      rw [← T.move_right_left] <;>\n    rw [tape.move_left_nth, add_sub_cancel]\n#align tape.move_right_nth tape.move_right_nth\n\n",
 "move_right_n_head":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem tape.move_right_n_head {Γ} [Inhabited Γ] (T : Tape Γ) (i : ℕ) :\n    ((«expr ^[ ]» (Tape.move dir.right) i) T).head = T.nth i := by\n  induction i generalizing T <;> [rfl, simp only [*, tape.move_right_nth, Int.ofNat_succ, iterate_succ]]\n#align tape.move_right_n_head tape.move_right_n_head\n\n",
 "move_right_mk'":
 "@[simp]\ntheorem tape.move_right_mk' {Γ} [Inhabited Γ] (L R : ListBlank Γ) :\n    (Tape.mk' L R).move dir.right = Tape.mk' (L.cons R.head) R.tail := by\n  simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail, and_self_iff,\n    list_blank.tail_cons]\n#align tape.move_right_mk' tape.move_right_mk'\n\n",
 "move_right_left":
 "@[simp]\ntheorem tape.move_right_left {Γ} [Inhabited Γ] (T : Tape Γ) : (T.move dir.right).move dir.left = T := by\n  cases T <;> simp [tape.move]\n#align tape.move_right_left tape.move_right_left\n\n",
 "move_left_right":
 "@[simp]\ntheorem tape.move_left_right {Γ} [Inhabited Γ] (T : Tape Γ) : (T.move dir.left).move dir.right = T := by\n  cases T <;> simp [tape.move]\n#align tape.move_left_right tape.move_left_right\n\n",
 "move_left_nth":
 "@[simp]\ntheorem tape.move_left_nth {Γ} [Inhabited Γ] : ∀ (T : Tape Γ) (i : ℤ), (T.move dir.left).nth i = T.nth (i - 1)\n  | ⟨a, L, R⟩, -[n+1] => (ListBlank.nth_succ _ _).symm\n  | ⟨a, L, R⟩, 0 => (ListBlank.nth_zero _).symm\n  | ⟨a, L, R⟩, 1 => (ListBlank.nth_zero _).trans (ListBlank.head_cons _ _)\n  | ⟨a, L, R⟩, (n + 1 : ℕ) + 1 => by\n    rw [add_sub_cancel]\n    change (R.cons a).nth (n + 1) = R.nth n\n    rw [list_blank.nth_succ, list_blank.tail_cons]\n#align tape.move_left_nth tape.move_left_nth\n\n",
 "move_left_mk'":
 "@[simp]\ntheorem tape.move_left_mk' {Γ} [Inhabited Γ] (L R : ListBlank Γ) :\n    (Tape.mk' L R).move dir.left = Tape.mk' L.tail (R.cons L.head) := by\n  simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail, and_self_iff,\n    list_blank.tail_cons]\n#align tape.move_left_mk' tape.move_left_mk'\n\n",
 "mk_val":
 "@[simp]\ntheorem pointed_map.mk_val {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : Γ → Γ') (pt) : (pointed_map.mk f pt : Γ → Γ') = f :=\n  rfl\n#align pointed_map.mk_val pointed_map.mk_val\n\n",
 "mk'_right₀":
 "@[simp]\ntheorem tape.mk'_right₀ {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).right₀ = R :=\n  ListBlank.cons_head_tail _\n#align tape.mk'_right₀ tape.mk'_right₀\n\n",
 "mk'_right":
 "@[simp]\ntheorem tape.mk'_right {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).right = R.tail :=\n  rfl\n#align tape.mk'_right tape.mk'_right\n\n",
 "mk'_nth_nat":
 "@[simp]\ntheorem tape.mk'_nth_nat {Γ} [Inhabited Γ] (L R : ListBlank Γ) (n : ℕ) : (Tape.mk' L R).nth n = R.nth n := by\n  rw [← tape.right₀_nth, tape.mk'_right₀]\n#align tape.mk'_nth_nat tape.mk'_nth_nat\n\n",
 "mk'_left_right₀":
 "@[simp]\ntheorem tape.mk'_left_right₀ {Γ} [Inhabited Γ] (T : Tape Γ) : Tape.mk' T.left T.right₀ = T := by\n  cases T <;>\n    simp only [tape.right₀, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self_iff]\n#align tape.mk'_left_right₀ tape.mk'_left_right₀\n\n",
 "mk'_left":
 "@[simp]\ntheorem tape.mk'_left {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).left = L :=\n  rfl\n#align tape.mk'_left tape.mk'_left\n\n",
 "mk'_head":
 "@[simp]\ntheorem tape.mk'_head {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).head = R.head :=\n  rfl\n#align tape.mk'_head tape.mk'_head\n\n",
 "mem_eval":
 "theorem mem_eval {σ} {f : σ → Option σ} {a b} : b ∈ eval f a ↔ Reaches f a b ∧ f b = none :=\n  ⟨fun h => by\n    refine' eval_induction h fun a h IH => _\n    cases' e : f a with a'\n    · rw [Part.mem_unique h (PFun.mem_fix_iff.2 <| or.inl <| Part.mem_some_iff.2 <| by rw [e] <;> rfl)]\n      exact ⟨refl_trans_gen.refl, e⟩\n    · rcases PFun.mem_fix_iff.1 h with (h | ⟨_, h, _⟩) <;> rw [e] at h <;> cases Part.mem_some_iff.1 h\n      cases' IH a' (by rwa [e]) with h₁ h₂\n      exact ⟨refl_trans_gen.head e h₁, h₂⟩, fun ⟨h₁, h₂⟩ =>\n    by\n    refine' refl_trans_gen.head_induction_on h₁ _ fun a a' h _ IH => _\n    · refine' PFun.mem_fix_iff.2 (or.inl _)\n      rw [h₂]\n      apply Part.mem_some\n    · refine' PFun.mem_fix_iff.2 (or.inr ⟨_, _, IH⟩)\n      rw [show f a = _ from h]\n      apply Part.mem_some⟩\n#align mem_eval mem_eval\n\n",
 "map_write":
 "@[simp]\ntheorem tape.map_write {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (b : Γ) :\n    ∀ T : Tape Γ, (T.write b).map f = (T.map f).write (f b) := by rintro ⟨⟩ <;> rfl\n#align tape.map_write tape.map_write\n\n",
 "map_step":
 "theorem machine.map_step {S : Set Λ} (f₂₁ : function.right_inverse f₁ f₂) (g₂₁ : ∀ q ∈ S, g₂ (g₁ q) = q) :\n    ∀ c : Cfg Γ Λ, c.q ∈ S → (step M c).map (Cfg.map f₁ g₁) = step (M.map f₁ f₂ g₁ g₂) (Cfg.map f₁ g₁ c)\n  | ⟨q, T⟩, h => by\n    unfold step machine.map cfg.map\n    simp only [Turing.Tape.map_fst, g₂₁ q h, f₂₁ _]\n    rcases M q T.1 with (_ | ⟨q', d | a⟩); · rfl\n    · simp only [step, cfg.map, Option.map_some', tape.map_move f₁]\n      rfl\n    · simp only [step, cfg.map, Option.map_some', tape.map_write]\n      rfl\n#align machine.map_step machine.map_step\n\n",
 "map_respects":
 "theorem machine.map_respects (g₁ : PointedMap Λ Λ') (g₂ : Λ' → Λ) {S} (ss : Supports M S)\n    (f₂₁ : function.right_inverse f₁ f₂) (g₂₁ : ∀ q ∈ S, g₂ (g₁ q) = q) :\n    Respects (step M) (step (M.map f₁ f₂ g₁ g₂)) fun a b => a.q ∈ S ∧ Cfg.map f₁ g₁ a = b\n  | c, _, ⟨cs, rfl⟩ => by\n    cases' e : step M c with c' <;> unfold respects\n    · rw [← M.map_step f₁ f₂ g₁ g₂ f₂₁ g₂₁ _ cs, e]\n      rfl\n    · refine' ⟨_, ⟨step_supports M ss e cs, rfl⟩, trans_gen.single _⟩\n      rw [← M.map_step f₁ f₂ g₁ g₂ f₂₁ g₂₁ _ cs, e]\n      exact rfl\n#align machine.map_respects machine.map_respects\n\n",
 "map_pt":
 "@[simp]\ntheorem pointed_map.map_pt {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') : f default = default :=\n  pointed_map.map_pt' _\n#align pointed_map.map_pt pointed_map.map_pt\n\n",
 "map_move":
 "theorem tape.map_move {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (T : Tape Γ) (d) :\n    (T.move d).map f = (T.map f).move d := by\n  cases T <;> cases d <;>\n    simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self_iff,\n      list_blank.tail_map]\n#align tape.map_move tape.map_move\n\n",
 "map_modify_nth":
 "theorem list_blank.map_modify_nth {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (F : PointedMap Γ Γ') (f : Γ → Γ) (f' : Γ' → Γ')\n    (H : ∀ x, F (f x) = f' (F x)) (n) (L : ListBlank Γ) : (L.modify_nth f n).map F = (L.map F).modify_nth f' n := by\n  induction' n with n IH generalizing L <;>\n    simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]\n#align list_blank.map_modify_nth list_blank.map_modify_nth\n\n",
 "map_mk₂":
 "theorem tape.map_mk₂ {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (L R : List Γ) :\n    (Tape.mk₂ L R).map f = Tape.mk₂ (L.map f) (R.map f) := by simp only [tape.mk₂, tape.map_mk', list_blank.map_mk]\n#align tape.map_mk₂ tape.map_mk₂\n\n",
 "map_mk₁":
 "theorem tape.map_mk₁ {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : List Γ) :\n    (Tape.mk₁ l).map f = Tape.mk₁ (l.map f) :=\n  Tape.map_mk₂ _ _ _\n#align tape.map_mk₁ tape.map_mk₁\n\n",
 "map_mk'":
 "theorem tape.map_mk' {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (L R : ListBlank Γ) :\n    (Tape.mk' L R).map f = Tape.mk' (L.map f) (R.map f) := by\n  simp only [tape.mk', tape.map, list_blank.head_map, eq_self_iff_true, and_self_iff, list_blank.tail_map]\n#align tape.map_mk' tape.map_mk'\n\n",
 "map_mk":
 "@[simp]\ntheorem list_blank.map_mk {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : List Γ) :\n    (ListBlank.mk l).map f = ListBlank.mk (l.map f) :=\n  rfl\n#align list_blank.map_mk list_blank.map_mk\n\n",
 "map_init":
 "theorem map_init (g₁ : PointedMap Λ Λ') (l : List Γ) : (init l).map f₁ g₁ = init (l.map f₁) :=\n  congr (congr_arg cfg.mk g₁.map_pt) (Tape.map_mk₁ _ _)\n#align map_init map_init\n\n",
 "map_fst":
 "@[simp]\ntheorem tape.map_fst {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') : ∀ T : Tape Γ, (T.map f).1 = f T.1 := by\n  rintro ⟨⟩ <;> rfl\n#align tape.map_fst tape.map_fst\n\n",
 "map_cons":
 "@[simp]\ntheorem list_blank.map_cons {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : ListBlank Γ) (a : Γ) :\n    (l.cons a).map f = (l.map f).cons (f a) :=\n  by\n  refine' (list_blank.cons_head_tail _).symm.trans _\n  simp only [list_blank.head_map, list_blank.head_cons, list_blank.tail_map, list_blank.tail_cons]\n#align list_blank.map_cons list_blank.map_cons\n\n",
 "induction_on":
 "@[elab_as_elim]\nprotected theorem list_blank.induction_on {Γ} [Inhabited Γ] {p : ListBlank Γ → Prop} (q : ListBlank Γ)\n    (h : ∀ a, p (ListBlank.mk a)) : p q :=\n  Quotient.inductionOn' q h\n#align list_blank.induction_on list_blank.induction_on\n\n",
 "head_mk":
 "@[simp]\ntheorem list_blank.head_mk {Γ} [Inhabited Γ] (l : List Γ) : ListBlank.head (ListBlank.mk l) = l.head :=\n  rfl\n#align list_blank.head_mk list_blank.head_mk\n\n",
 "head_map":
 "@[simp]\ntheorem list_blank.head_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : ListBlank Γ) :\n    (l.map f).head = f l.head :=\n  by\n  conv =>\n    lhs\n    rw [← list_blank.cons_head_tail l]\n  exact Quotient.inductionOn' l fun a => rfl\n#align list_blank.head_map list_blank.head_map\n\n",
 "head_cons":
 "@[simp]\ntheorem list_blank.head_cons {Γ} [Inhabited Γ] (a : Γ) : ∀ l : ListBlank Γ, (l.cons a).head = a :=\n  Quotient.ind' fun l => rfl\n#align list_blank.head_cons list_blank.head_cons\n\n",
 "head":
 "theorem reaches₀.head {σ} {f : σ → Option σ} {a b c : σ} (h : b ∈ f a) (h₂ : Reaches₀ f b c) : Reaches₀ f a c :=\n  (Reaches₀.single h).trans h₂\n#align reaches₀.head reaches₀.head\n\n",
 "fun_respects":
 "theorem fun_respects {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂} :\n    (Respects f₁ f₂ fun a b => tr a = b) ↔ ∀ ⦃a₁⦄, FRespects f₂ tr (tr a₁) (f₁ a₁) :=\n  forall_congr' fun a₁ => by cases f₁ a₁ <;> simp only [frespects, respects, exists_eq_left', forall_eq']\n#align fun_respects fun_respects\n\n",
 "frespects_eq":
 "theorem frespects_eq {σ₁ σ₂} {f₂ : σ₂ → Option σ₂} {tr : σ₁ → σ₂} {a₂ b₂} (h : f₂ a₂ = f₂ b₂) :\n    ∀ {b₁}, FRespects f₂ tr a₂ b₁ ↔ FRespects f₂ tr b₂ b₁\n  | some b₁ => reaches₁_eq h\n  | none => by unfold frespects <;> rw [h]\n#align frespects_eq frespects_eq\n\n",
 "ext":
 "@[ext]\ntheorem list_blank.ext {Γ} [Inhabited Γ] {L₁ L₂ : ListBlank Γ} : (∀ i, L₁.nth i = L₂.nth i) → L₁ = L₂ :=\n  ListBlank.induction_on L₁ fun l₁ =>\n    ListBlank.induction_on L₂ fun l₂ H => by\n      wlog h : l₁.length ≤ l₂.length\n      · cases le_total l₁.length l₂.length <;> [skip, symm] <;> apply_assumption <;> try assumption\n        intro\n        rw [H]\n      refine' Quotient.sound' (or.inl ⟨l₂.length - l₁.length, _⟩)\n      refine' List.ext_nthLe _ fun i h h₂ => Eq.symm _\n      · simp only [add_tsub_cancel_of_le h, list.length_append, List.length_replicate]\n      simp only [list_blank.nth_mk] at H\n      cases' lt_or_le i l₁.length with h' h'\n      ·\n        simp only [List.nthLe_append _ h', List.nthLe_get? h, List.nthLe_get? h', ← List.getI_eq_nthLe _ h, ←\n          List.getI_eq_nthLe _ h', H]\n      ·\n        simp only [List.nthLe_append_right h', List.nthLe_replicate, List.nthLe_get? h, List.get?_len_le h', ←\n          List.getI_eq_default _ h', H, List.getI_eq_nthLe _ h]\n#align list_blank.ext list_blank.ext\n\n",
 "exists_mk'":
 "theorem tape.exists_mk' {Γ} [Inhabited Γ] (T : Tape Γ) : ∃ L R, T = Tape.mk' L R :=\n  ⟨_, _, (Tape.mk'_left_right₀ _).symm⟩\n#align tape.exists_mk' tape.exists_mk'\n\n",
 "exists_enc_dec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem exists_enc_dec [Fintype Γ] :\n    ∃ (n : _)(enc : Γ → Vector Bool n)(dec : Vector Bool n → Γ),\n      enc default = Vector.replicate n false ∧ ∀ a, dec (enc a) = a :=\n  by\n  letI := Classical.decEq Γ\n  let n := Fintype.card Γ\n  obtain ⟨F⟩ := Fintype.truncEquivFin Γ\n  let G : «expr ↪ » (Fin n) (Fin n → Bool) :=\n    ⟨fun a b => a = b, fun a b h => Bool.of_decide_true <| (congr_fun h b).trans <| Bool.decide_true rfl⟩\n  let H := (F.to_embedding.trans G).trans (Equiv.vectorEquivFin _ _).symm.to_embedding\n  classical\n    let enc := H.set_value default (Vector.replicate n ff)\n    exact ⟨_, enc, Function.invFun enc, H.set_value_eq _ _, Function.leftInverse_invFun enc.2⟩\n#align exists_enc_dec exists_enc_dec\n\n",
 "exists_cons":
 "/-- The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where\nthis only holds for nonempty lists. -/\ntheorem list_blank.exists_cons {Γ} [Inhabited Γ] (l : ListBlank Γ) : ∃ a l', l = ListBlank.cons a l' :=\n  ⟨_, _, (ListBlank.cons_head_tail _).symm⟩\n#align list_blank.exists_cons list_blank.exists_cons\n\n",
 "eval_maximal₁":
 "theorem eval_maximal₁ {σ} {f : σ → Option σ} {a b} (h : b ∈ eval f a) (c) : ¬Reaches₁ f b c\n  | bc => by\n    let ⟨ab, b0⟩ := mem_eval.1 h\n    let ⟨b', h', _⟩ := TransGen.head'_iff.1 bc\n    cases b0.symm.trans h'\n#align eval_maximal₁ eval_maximal₁\n\n",
 "eval_maximal":
 "theorem eval_maximal {σ} {f : σ → Option σ} {a b} (h : b ∈ eval f a) {c} : Reaches f b c ↔ c = b :=\n  let ⟨ab, b0⟩ := mem_eval.1 h\n  reflTransGen_iff_eq fun b' h' => by cases b0.symm.trans h'\n#align eval_maximal eval_maximal\n\n",
 "equivalence":
 "theorem blank_rel.equivalence (Γ) [Inhabited Γ] : equivalence (@BlankRel Γ _) :=\n  ⟨BlankRel.refl, @BlankRel.symm _ _, @BlankRel.trans _ _⟩\n#align blank_rel.equivalence blank_rel.equivalence\n\n",
 "cons_mk":
 "@[simp]\ntheorem list_blank.cons_mk {Γ} [Inhabited Γ] (a : Γ) (l : List Γ) :\n    ListBlank.cons a (ListBlank.mk l) = ListBlank.mk (a :: l) :=\n  rfl\n#align list_blank.cons_mk list_blank.cons_mk\n\n",
 "cons_head_tail":
 "/-- The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where\nthis only holds for nonempty lists. -/\n@[simp]\ntheorem list_blank.cons_head_tail {Γ} [Inhabited Γ] : ∀ l : ListBlank Γ, l.tail.cons l.head = l :=\n  Quotient.ind'\n    (by\n      refine' fun l => Quotient.sound' (or.inr _)\n      cases l; · exact ⟨1, rfl⟩; · rfl)\n#align list_blank.cons_head_tail list_blank.cons_head_tail\n\n",
 "cons_bind":
 "@[simp]\ntheorem list_blank.cons_bind {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (a : Γ) (l : ListBlank Γ) (f : Γ → List Γ') (hf) :\n    (l.cons a).bind f hf = (l.bind f hf).append (f a) :=\n  l.induction_on <| by\n    intro <;> simp only [list_blank.append_mk, list_blank.bind_mk, list_blank.cons_mk, list.cons_bind]\n#align list_blank.cons_bind list_blank.cons_bind\n\n",
 "bind_mk":
 "@[simp]\ntheorem list_blank.bind_mk {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (l : List Γ) (f : Γ → List Γ') (hf) :\n    (ListBlank.mk l).bind f hf = ListBlank.mk (l.bind f) :=\n  rfl\n#align list_blank.bind_mk list_blank.bind_mk\n\n",
 "below_of_le":
 "theorem blank_extends.below_of_le {Γ} [Inhabited Γ] {l l₁ l₂ : List Γ} :\n    BlankExtends l l₁ → BlankExtends l l₂ → l₁.length ≤ l₂.length → BlankExtends l₁ l₂ :=\n  by\n  rintro ⟨i, rfl⟩ ⟨j, rfl⟩ h; use j - i\n  simp only [list.length_append, add_le_add_iff_left, List.length_replicate] at h\n  simp only [← List.replicate_add, add_tsub_cancel_of_le h, list.append_assoc]\n#align blank_extends.below_of_le blank_extends.below_of_le\n\n",
 "append_mk":
 "@[simp]\ntheorem list_blank.append_mk {Γ} [Inhabited Γ] (l₁ l₂ : List Γ) :\n    ListBlank.append l₁ (ListBlank.mk l₂) = ListBlank.mk (l₁ ++ l₂) := by\n  induction l₁ <;> simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]\n#align list_blank.append_mk list_blank.append_mk\n\n",
 "append_assoc":
 "theorem list_blank.append_assoc {Γ} [Inhabited Γ] (l₁ l₂ : List Γ) (l₃ : ListBlank Γ) :\n    ListBlank.append (l₁ ++ l₂) l₃ = ListBlank.append l₁ (ListBlank.append l₂ l₃) :=\n  l₃.induction_on <| by intro <;> simp only [list_blank.append_mk, list.append_assoc]\n#align list_blank.append_assoc list_blank.append_assoc\n\n",
 "add_bottom_nth_succ_fst":
 "theorem add_bottom_nth_succ_fst (L n) : ((add_bottom L).nth (n + 1)).1 = false := by\n  rw [list_blank.nth_succ, add_bottom, list_blank.tail_cons, list_blank.nth_map] <;> rfl\n#align add_bottom_nth_succ_fst add_bottom_nth_succ_fst\n\n",
 "add_bottom_nth_snd":
 "theorem add_bottom_nth_snd (L n) : ((add_bottom L).nth n).2 = L.nth n := by\n  conv =>\n      rhs\n      rw [← add_bottom_map L, list_blank.nth_map] <;>\n    rfl\n#align add_bottom_nth_snd add_bottom_nth_snd\n\n",
 "add_bottom_modify_nth":
 "theorem add_bottom_modify_nth (f : (∀ k, Option (Γ k)) → ∀ k, Option (Γ k)) (L n) :\n    (add_bottom L).modify_nth (fun a => (a.1, f a.2)) n = add_bottom (L.modify_nth f n) :=\n  by\n  cases n <;> simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]\n  congr ; symm; apply list_blank.map_modify_nth; intro ; rfl\n#align add_bottom_modify_nth add_bottom_modify_nth\n\n",
 "add_bottom_map":
 "-- [decidable_eq K]: Because K is a parameter, we cannot easily skip\n-- the decidable_eq assumption, and this is a local definition anyway so it's not important.\ntheorem add_bottom_map (L) : (add_bottom L).map ⟨Prod.snd, rfl⟩ = L :=\n  by\n  simp only [add_bottom, list_blank.map_cons] <;> convert list_blank.cons_head_tail _\n  generalize list_blank.tail L = L'\n  refine' L'.induction_on fun l => _; simp\n#align add_bottom_map add_bottom_map\n\n",
 "add_bottom_head_fst":
 "theorem add_bottom_head_fst (L) : (add_bottom L).head.1 = true := by rw [add_bottom, list_blank.head_cons] <;> rfl\n#align add_bottom_head_fst add_bottom_head_fst\n\n",
 "above_of_le":
 "theorem blank_extends.above_of_le {Γ} [Inhabited Γ] {l l₁ l₂ : List Γ} :\n    BlankExtends l₁ l → BlankExtends l₂ l → l₁.length ≤ l₂.length → BlankExtends l₁ l₂ :=\n  by\n  rintro ⟨i, rfl⟩ ⟨j, e⟩ h; use i - j\n  refine' List.append_right_cancel (e.symm.trans _)\n  rw [list.append_assoc, ← List.replicate_add, tsub_add_cancel_of_le]\n  apply_fun list.length  at e\n  simp only [list.length_append, List.length_replicate] at e\n  rwa [← add_le_add_iff_left, e, add_le_add_iff_right]\n#align blank_extends.above_of_le blank_extends.above_of_le\n\n"}