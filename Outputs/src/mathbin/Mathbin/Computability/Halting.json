{"vec_iff":
 "theorem vec_iff {m n f} : @Vec m n f ↔ Computable f :=\n  ⟨fun h => by simpa only [of_fn_nth] using vector_of_fn fun i => to_part (h i), fun h i =>\n    of_part <| vector_get.comp h (const i)⟩\n#align vec_iff vec_iff\n\n",
 "to_re":
 "theorem to_re {p : α → Prop} (hp : ComputablePred p) : RePred p :=\n  by\n  obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp\n  unfold RePred\n  refine' (Partrec.cond hf (Decidable.Partrec.const' (Part.some ())) Partrec.none).of_eq fun n => Part.ext fun a => _\n  cases a; cases f n <;> simp\n#align to_re to_re\n\n",
 "to_part":
 "theorem to_part {n f} (pf : @Partrec' n f) : Partrec f :=\n  by\n  induction pf\n  case prim n f hf => exact hf.to_prim.to_comp\n  case comp m n f g _ _ hf hg => exact (vector_m_of_fn fun i => hg i).bind (hf.comp snd)\n  case\n    rfind n f _ hf =>\n    have :=\n      ((primrec.eq.comp Primrec.id (Primrec.const 0)).to_comp.comp (hf.comp (vector_cons.comp snd fst))).to₂.partrec₂\n    exact this.rfind\n#align to_part to_part\n\n",
 "tail":
 "theorem tail {n f} (hf : @Partrec' n f) : @Partrec' n.succ fun v => f v.tail :=\n  (hf.comp _ fun i => @prim _ _ <| nat.primrec'.nth i.succ).of_eq fun v => by\n    simp <;> rw [← of_fn_nth v.tail] <;> congr <;> funext i <;> simp\n#align tail tail\n\n",
 "sum_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem sum_cases {f : α → Sum β γ} {g : α → «expr →. » β σ} {h : α → «expr →. » γ σ} (hf : Computable f)\n    (hg : Partrec₂ g) (hh : Partrec₂ h) : @Partrec _ σ _ _ fun a => sum.cases_on (f a) (g a) (h a) :=\n  option_some_iff.1 <|\n    (cond (sum_casesOn hf (const true).to₂ (const false).to₂)\n          (sum_casesOn_left hf (option_some_iff.2 hg).to₂ (const option.none).to₂)\n          (sum_casesOn_right hf (const option.none).to₂ (option_some_iff.2 hh).to₂)).of_eq\n      fun a => by cases f a <;> simp only [Bool.cond_true, Bool.cond_false]\n#align sum_cases sum_cases\n\n",
 "rice₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem rice₂ (C : Set Code) (H : ∀ cf cg, eval cf = eval cg → (cf ∈ C ↔ cg ∈ C)) :\n    (ComputablePred fun c => c ∈ C) ↔ C = ∅ ∨ C = Set.univ := by\n  classical exact\n      have hC : ∀ f, f ∈ C ↔ eval f ∈ «expr '' » eval C := fun f =>\n        ⟨Set.mem_image_of_mem _, fun ⟨g, hg, e⟩ => (H _ _ e).1 hg⟩\n      ⟨fun h =>\n        or_iff_not_imp_left.2 fun C0 =>\n          Set.eq_univ_of_forall fun cg =>\n            let ⟨cf, fC⟩ := Set.nonempty_iff_ne_empty.2 C0\n            (hC _).2 <|\n              rice («expr '' » eval C) (h.of_eq hC) (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),\n        fun h => by\n        obtain rfl | rfl := h <;> simp [ComputablePred, Set.mem_empty_iff_false] <;>\n          exact ⟨by infer_instance, Computable.const _⟩⟩\n#align rice₂ rice₂\n\n",
 "rice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem rice (C : Set («expr →. » ℕ ℕ)) (h : ComputablePred fun c => eval c ∈ C) {f g} (hf : Nat.Partrec f)\n    (hg : Nat.Partrec g) (fC : f ∈ C) : g ∈ C := by\n  cases' h with _ h; skip\n  obtain ⟨c, e⟩ :=\n    fixed_point₂\n      (Partrec.cond (h.comp fst) ((Partrec.nat_iff.2 hg).comp snd).to₂ ((Partrec.nat_iff.2 hf).comp snd).to₂).to₂\n  simp at e\n  by_cases H : eval c ∈ C\n  · simp only [H, if_true] at e\n    rwa [← e]\n  · simp only [H, if_false] at e\n    rw [e] at H\n    contradiction\n#align rice rice\n\n",
 "rfind_opt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem rfind_opt {n} {f : Vector ℕ (n + 1) → ℕ} (hf : @Partrec' (n + 1) f) :\n    @Partrec' n fun v => Nat.rfindOpt fun a => ofNat (Option ℕ) (f («expr ::ᵥ » a v)) :=\n  ((rfind <|\n            (of_prim (Primrec.nat_sub.comp (Primrec.const 1) Primrec.vector_head)).comp₁ (fun n => Part.some (1 - n))\n              hf).bind\n        ((prim Nat.Primrec'.pred).comp₁ nat.pred hf)).of_eq\n    fun v =>\n    Part.ext fun b =>\n      by\n      simp only [Nat.rfindOpt, exists_prop, tsub_eq_zero_iff_le, PFun.coe_val, Part.mem_bind_iff, Part.mem_some_iff,\n        Option.mem_def, Part.mem_coe]\n      refine' exists_congr fun a => (and_congr (iff_of_eq _) iff.rfl).trans (and_congr_right fun h => _)\n      · congr\n        funext n\n        simp only [Part.some_inj, PFun.coe_val]\n        cases f («expr ::ᵥ » n v) <;> simp [nat.succ_le_succ] <;> rfl\n      · have := Nat.rfind_spec h\n        simp only [PFun.coe_val, Part.mem_some_iff] at this\n        cases' f («expr ::ᵥ » a v) with c\n        · cases this\n        rw [← Option.some_inj, eq_comm]\n        rfl\n#align rfind_opt rfind_opt\n\n",
 "prim":
 "theorem vec.prim {n m f} (hf : @Nat.Primrec'.Vec n m f) : Vec f := fun i => prim <| hf i\n#align vec.prim vec.prim\n\n",
 "part_iff₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem part_iff₂ {f : ℕ → «expr →. » ℕ ℕ} : (@Partrec' 2 fun v => f v.head v.tail.head) ↔ Partrec₂ f :=\n  part_iff.trans\n    ⟨fun h =>\n      (h.comp <| vector_cons.comp fst <| vector_cons.comp snd (const nil)).of_eq fun v => by\n        simp only [cons_head, cons_tail],\n      fun h => h.comp vector_head (vector_head.comp vector_tail)⟩\n#align part_iff₂ part_iff₂\n\n",
 "part_iff₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem part_iff₁ {f : «expr →. » ℕ ℕ} : (@Partrec' 1 fun v => f v.head) ↔ Partrec f :=\n  part_iff.trans\n    ⟨fun h =>\n      (h.comp <| (Primrec.vector_ofFn fun i => Primrec.id).to_comp).of_eq fun v => by simp only [id.def, head_of_fn],\n      fun h => h.comp vector_head⟩\n#align part_iff₁ part_iff₁\n\n",
 "part_iff":
 "theorem part_iff {n f} : @Partrec' n f ↔ Partrec f :=\n  ⟨to_part, of_part⟩\n#align part_iff part_iff\n\n",
 "of_prim":
 "theorem of_prim {n} {f : Vector ℕ n → ℕ} (hf : Primrec f) : @Partrec' n f :=\n  prim (Nat.Primrec'.of_prim hf)\n#align of_prim of_prim\n\n",
 "of_part":
 "theorem of_part : ∀ {n f}, Partrec f → @Partrec' n f :=\n  suffices ∀ f, Nat.Partrec f → @Partrec' 1 fun v => f v.head from fun n f hf =>\n    by\n    let g; swap\n    exact\n      (comp₁ g (this g hf) (prim Nat.Primrec'.encode)).of_eq fun i => by dsimp only [g] <;> simp [encodek, Part.map_id']\n  fun f hf => by\n  obtain ⟨c, rfl⟩ := exists_code.1 hf\n  simpa [eval_eq_rfind_opt] using\n    rfind_opt <|\n      of_prim <|\n        Primrec.encode_iff.2 <|\n          evaln_prim.comp <|\n            (primrec.vector_head.pair (Primrec.const c)).pair <| primrec.vector_head.comp Primrec.vector_tail\n#align of_part of_part\n\n",
 "of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n#print of_eq /-\ntheorem of_eq {n} {f g : «expr →. » (Vector ℕ n) ℕ} (hf : Partrec' f) (H : ∀ i, f i = g i) : Partrec' g :=\n  (funext H : f = g) ▸ hf\n#align of_eq of_eq\n-/\n\n",
 "not":
 "/- warning: not clashes with bnot -> not\nCase conversion may be inaccurate. Consider using '#align not notₓ'. -/\n#print not /-\nprotected theorem not {p : α → Prop} (hp : ComputablePred p) : ComputablePred fun a => ¬p a := by\n  obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp <;>\n    exact\n      ⟨by infer_instance,\n        (cond hf (const ff) (const tt)).of_eq fun n => by\n          dsimp\n          cases f n <;> rfl⟩\n#align not not\n-/\n\n",
 "nil":
 "protected theorem nil {n} : @Vec n 0 fun _ => nil := fun i => i.elim0\n#align nil nil\n\n",
 "merge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem merge' {f g : «expr →. » α σ} (hf : Partrec f) (hg : Partrec g) :\n    ∃ k : «expr →. » α σ, Partrec k ∧ ∀ a, (∀ x ∈ k a, x ∈ f a ∨ x ∈ g a) ∧ ((k a).dom ↔ (f a).dom ∨ (g a).dom) :=\n  by\n  let ⟨k, hk, H⟩ := Nat.Partrec.merge' (bind_decode₂_iff.1 hf) (bind_decode₂_iff.1 hg)\n  let k' a := (k (encode a)).bind fun n => decode σ n\n  refine' ⟨k', ((nat_iff.2 hk).comp Computable.encode).bind (computable.decode.of_option.comp snd).to₂, fun a => _⟩\n  suffices; refine' ⟨this, ⟨fun h => (this _ ⟨h, rfl⟩).imp Exists.fst Exists.fst, _⟩⟩\n  · intro h\n    rw [bind_dom]\n    have hk : (k (encode a)).dom := (H _).2.2 (by simpa only [encodek₂, bind_some, coe_some] using h)\n    exists hk\n    simp only [exists_prop, mem_map_iff, mem_coe, mem_bind_iff, Option.mem_def] at H\n    obtain ⟨a', ha', y, hy, e⟩ | ⟨a', ha', y, hy, e⟩ := (H _).1 _ ⟨hk, rfl⟩ <;> · simp only [e.symm, encodek]\n  intro x h'; simp only [k', exists_prop, mem_coe, mem_bind_iff, Option.mem_def] at h'\n  obtain ⟨n, hn, hx⟩ := h'\n  have := (H _).1 _ hn\n  simp [mem_decode₂, encode_injective.eq_iff] at this\n  obtain ⟨a', ha, rfl⟩ | ⟨a', ha, rfl⟩ := this <;> simp only [encodek] at hx <;> rw [hx] at ha\n  · exact or.inl ha\n  exact or.inr ha\n#align merge' merge'\n\n",
 "merge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem merge {f g : «expr →. » α σ} (hf : Partrec f) (hg : Partrec g) (H : ∀ (a), ∀ x ∈ f a, ∀ y ∈ g a, x = y) :\n    ∃ k : «expr →. » α σ, Partrec k ∧ ∀ a x, x ∈ k a ↔ x ∈ f a ∨ x ∈ g a :=\n  let ⟨k, hk, K⟩ := merge' hf hg\n  ⟨k, hk, fun a x =>\n    ⟨(K _).1 _, fun h => by\n      have : (k a).dom := (K _).2.2 (h.imp Exists.fst Exists.fst)\n      refine' ⟨this, _⟩\n      cases' h with h h <;> cases' (K _).1 _ ⟨this, rfl⟩ with h' h'\n      · exact mem_unique h' h\n      · exact (H _ _ h _ h').symm\n      · exact H _ _ h' _ h\n      · exact mem_unique h' h⟩⟩\n#align merge merge\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprotected theorem map {n f} {g : Vector ℕ (n + 1) → ℕ} (hf : @Partrec' n f) (hg : @Partrec' (n + 1) g) :\n    @Partrec' n fun v => (f v).map fun a => g («expr ::ᵥ » a v) := by\n  simp [(Part.bind_some_eq_map _ _).symm] <;> exact hf.bind hg\n#align map map\n\n",
 "idv":
 "theorem idv {n} : @Vec n n id :=\n  Vec.prim Nat.Primrec'.idv\n#align idv idv\n\n",
 "head":
 "theorem head {n : ℕ} : @Partrec' n.succ (@head ℕ n) :=\n  prim Nat.Primrec'.head\n#align head head\n\n",
 "halting_problem_re":
 "theorem halting_problem_re (n) : RePred fun c => (eval c n).dom :=\n  (eval_part.comp Computable.id (Computable.const _)).dom_re\n#align halting_problem_re halting_problem_re\n\n",
 "halting_problem_not_re":
 "theorem halting_problem_not_re (n) : ¬RePred fun c => ¬(eval c n).dom\n  | h => halting_problem _ <| computable_iff_re_compl_re'.2 ⟨halting_problem_re _, h⟩\n#align halting_problem_not_re halting_problem_not_re\n\n",
 "halting_problem":
 "theorem halting_problem (n) : ¬ComputablePred fun c => (eval c n).dom\n  | h => rice { f | (f n).dom } h nat.partrec.zero Nat.Partrec.none trivial\n#align halting_problem halting_problem\n\n",
 "dom_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n#print Partrec.dom_re /-\ntheorem Partrec.dom_re {α β} [Primcodable α] [Primcodable β] {f : «expr →. » α β} (h : Partrec f) :\n    RePred fun a => (f a).dom :=\n  (h.map (Computable.const ()).to₂).of_eq fun n => Part.ext fun _ => by simp [Part.dom_iff_mem]\n#align partrec.dom_re Partrec.dom_re\n-/\n\n",
 "cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprotected theorem cons {n m} {f : Vector ℕ n → ℕ} {g} (hf : @Partrec' n f) (hg : @Vec n m g) :\n    Vec fun v => «expr ::ᵥ » (f v) (g v) := fun i =>\n  Fin.cases (by simp [*]) (fun i => by simp only [hg i, nth_cons_succ]) i\n#align cons cons\n\n",
 "cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n#print cond /-\ntheorem cond {c : α → Bool} {f : «expr →. » α σ} {g : «expr →. » α σ} (hc : Computable c) (hf : Partrec f)\n    (hg : Partrec g) : Partrec fun a => cond (c a) (f a) (g a) :=\n  let ⟨cf, ef⟩ := exists_code.1 hf\n  let ⟨cg, eg⟩ := exists_code.1 hg\n  ((eval_part.comp (Computable.cond hc (const cf) (const cg)) Computable.id).bind\n        ((@Computable.decode σ _).comp snd).of_option.to₂).of_eq\n    fun a => by cases c a <;> simp [ef, eg, encodek]\n#align cond cond\n-/\n\n",
 "comp₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem comp₁ {n} (f : «expr →. » ℕ ℕ) {g : Vector ℕ n → ℕ} (hf : @Partrec' 1 fun v => f v.head) (hg : @Partrec' n g) :\n    @Partrec' n fun v => f (g v) := by simpa using hf.comp' (partrec'.cons hg partrec'.nil)\n#align comp₁ comp₁\n\n",
 "computable_iff_re_compl_re'":
 "theorem computable_iff_re_compl_re' {p : α → Prop} : ComputablePred p ↔ RePred p ∧ RePred fun a => ¬p a := by\n  classical exact computable_iff_re_compl_re\n#align computable_iff_re_compl_re' computable_iff_re_compl_re'\n\n",
 "computable_iff_re_compl_re":
 "-- Post's theorem on the equivalence of r.e., co-r.e. sets and\n-- computable sets. The assumption that p is decidable is required\n-- unless we assume Markov's principle or LEM.\n@[nolint decidable_classical]\ntheorem computable_iff_re_compl_re {p : α → Prop} [DecidablePred p] :\n    ComputablePred p ↔ RePred p ∧ RePred fun a => ¬p a :=\n  ⟨fun h => ⟨h.to_re, h.not.to_re⟩, fun ⟨h₁, h₂⟩ =>\n    ⟨‹_›,\n      by\n      obtain ⟨k, pk, hk⟩ := Partrec.merge (h₁.map (Computable.const tt).to₂) (h₂.map (Computable.const ff).to₂) _\n      · refine' Partrec.of_eq pk fun n => Part.eq_some_iff.2 _\n        rw [hk]\n        simp\n        apply decidable.em\n      · intro a x hx y hy\n        simp at hx hy\n        cases hy.1 hx.1⟩⟩\n#align computable_iff_re_compl_re computable_iff_re_compl_re\n\n",
 "computable_iff":
 "theorem computable_iff {p : α → Prop} : ComputablePred p ↔ ∃ f : α → Bool, Computable f ∧ p = fun a => f a :=\n  ⟨fun ⟨D, h⟩ => ⟨_, h, funext fun a => propext (Bool.decide_iff _).symm⟩, by\n    rintro ⟨f, h, rfl⟩ <;> exact ⟨by infer_instance, by simpa using h⟩⟩\n#align computable_iff computable_iff\n\n",
 "comp'":
 "theorem comp' {n m f g} (hf : @Partrec' m f) (hg : @Vec n m g) : Partrec' fun v => f (g v) :=\n  (hf.comp _ hg).of_eq fun v => by simp\n#align comp' comp'\n\n",
 "bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprotected theorem bind {n f g} (hf : @Partrec' n f) (hg : @Partrec' (n + 1) g) :\n    @Partrec' n fun v => (f v).bind fun a => g («expr ::ᵥ » a v) :=\n  (@comp n (n + 1) g (fun i => Fin.cases f (fun i v => some (v.nth i)) i) hg fun i =>\n        by\n        refine' Fin.cases _ (fun i => _) i <;> simp [*]\n        exact prim (nat.primrec'.nth _)).of_eq\n    fun v => by simp [m_of_fn, Part.bind_assoc, pure]\n#align bind bind\n\n"}