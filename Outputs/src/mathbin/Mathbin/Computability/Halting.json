{"vec_iff":
 "theorem vec_iff {m n f} : @vec m n f ↔ computable f :=\n  ⟨fun h => by simpa only [of_fn_nth] using vector_of_fn fun i => to_part (h i), fun h i =>\n    of_part <| vector_nth.comp h (const i)⟩\n#align vec_iff vec_iff\n\n",
 "to_re":
 "theorem to_re {p : α → Prop} (hp : computable_pred p) : re_pred p :=\n  by\n  obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp\n  unfold re_pred\n  refine' (partrec.cond hf (decidable.partrec.const' (Part.some ())) partrec.none).of_eq fun n => Part.ext fun a => _\n  cases a; cases f n <;> simp\n#align to_re to_re\n\n",
 "to_part":
 "theorem to_part {n f} (pf : @partrec' n f) : partrec f :=\n  by\n  induction pf\n  case prim n f hf => exact hf.to_prim.to_comp\n  case comp m n f g _ _ hf hg => exact (vector_m_of_fn fun i => hg i).bind (hf.comp snd)\n  case\n    rfind n f _ hf =>\n    have :=\n      ((primrec.eq.comp primrec.id (primrec.const 0)).to_comp.comp (hf.comp (vector_cons.comp snd fst))).to₂.partrec₂\n    exact this.rfind\n#align to_part to_part\n\n",
 "tail":
 "theorem tail {n f} (hf : @partrec' n f) : @partrec' n.succ fun v => f v.tail :=\n  (hf.comp _ fun i => @prim _ _ <| nat.primrec'.nth i.succ).of_eq fun v => by\n    simp <;> rw [← of_fn_nth v.tail] <;> congr <;> funext i <;> simp\n#align tail tail\n\n",
 "sum_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem sum_cases {f : α → Sum β γ} {g : α → «expr →. » β σ} {h : α → «expr →. » γ σ} (hf : computable f)\n    (hg : partrec₂ g) (hh : partrec₂ h) : @partrec _ σ _ _ fun a => sum.cases_on (f a) (g a) (h a) :=\n  option_some_iff.1 <|\n    (cond (sum_cases hf (const true).to₂ (const false).to₂)\n          (sum_cases_left hf (option_some_iff.2 hg).to₂ (const option.none).to₂)\n          (sum_cases_right hf (const option.none).to₂ (option_some_iff.2 hh).to₂)).of_eq\n      fun a => by cases f a <;> simp only [Bool.cond_true, Bool.cond_false]\n#align sum_cases sum_cases\n\n",
 "rice₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem rice₂ (C : set code) (H : ∀ cf cg, eval cf = eval cg → (cf ∈ C ↔ cg ∈ C)) :\n    (computable_pred fun c => c ∈ C) ↔ C = ∅ ∨ C = Set.univ := by\n  classical exact\n      have hC : ∀ f, f ∈ C ↔ eval f ∈ «expr '' » eval C := fun f =>\n        ⟨Set.mem_image_of_mem _, fun ⟨g, hg, e⟩ => (H _ _ e).1 hg⟩\n      ⟨fun h =>\n        or_iff_not_imp_left.2 fun C0 =>\n          Set.eq_univ_of_forall fun cg =>\n            let ⟨cf, fC⟩ := Set.nonempty_iff_ne_empty.2 C0\n            (hC _).2 <|\n              rice («expr '' » eval C) (h.of_eq hC) (partrec.nat_iff.1 <| eval_part.comp (const cf) computable.id)\n                (partrec.nat_iff.1 <| eval_part.comp (const cg) computable.id) ((hC _).1 fC),\n        fun h => by\n        obtain rfl | rfl := h <;> simp [computable_pred, Set.mem_empty_iff_false] <;>\n          exact ⟨by infer_instance, computable.const _⟩⟩\n#align rice₂ rice₂\n\n",
 "rice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem rice (C : set («expr →. » ℕ ℕ)) (h : computable_pred fun c => eval c ∈ C) {f g} (hf : nat.partrec f)\n    (hg : nat.partrec g) (fC : f ∈ C) : g ∈ C := by\n  cases' h with _ h; skip\n  obtain ⟨c, e⟩ :=\n    fixed_point₂\n      (partrec.cond (h.comp fst) ((partrec.nat_iff.2 hg).comp snd).to₂ ((partrec.nat_iff.2 hf).comp snd).to₂).to₂\n  simp at e\n  by_cases H : eval c ∈ C\n  · simp only [H, if_true] at e\n    rwa [← e]\n  · simp only [H, if_false] at e\n    rw [e] at H\n    contradiction\n#align rice rice\n\n",
 "rfind_opt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem rfind_opt {n} {f : Vector ℕ (n + 1) → ℕ} (hf : @partrec' (n + 1) f) :\n    @partrec' n fun v => nat.rfind_opt fun a => of_nat (option ℕ) (f («expr ::ᵥ » a v)) :=\n  ((rfind <|\n            (of_prim (primrec.nat_sub.comp (primrec.const 1) primrec.vector_head)).comp₁ (fun n => Part.some (1 - n))\n              hf).bind\n        ((prim nat.primrec'.pred).comp₁ nat.pred hf)).of_eq\n    fun v =>\n    Part.ext fun b =>\n      by\n      simp only [nat.rfind_opt, exists_prop, tsub_eq_zero_iff_le, pfun.coe_val, Part.mem_bind_iff, Part.mem_some_iff,\n        option.mem_def, Part.mem_coe]\n      refine' exists_congr fun a => (and_congr (iff_of_eq _) iff.rfl).trans (and_congr_right fun h => _)\n      · congr\n        funext n\n        simp only [Part.some_inj, pfun.coe_val]\n        cases f («expr ::ᵥ » n v) <;> simp [nat.succ_le_succ] <;> rfl\n      · have := nat.rfind_spec h\n        simp only [pfun.coe_val, Part.mem_some_iff] at this\n        cases' f («expr ::ᵥ » a v) with c\n        · cases this\n        rw [← option.some_inj, eq_comm]\n        rfl\n#align rfind_opt rfind_opt\n\n",
 "prim":
 "theorem vec.prim {n m f} (hf : @nat.primrec'.vec n m f) : vec f := fun i => prim <| hf i\n#align vec.prim vec.prim\n\n",
 "part_iff₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem part_iff₂ {f : ℕ → «expr →. » ℕ ℕ} : (@partrec' 2 fun v => f v.head v.tail.head) ↔ partrec₂ f :=\n  part_iff.trans\n    ⟨fun h =>\n      (h.comp <| vector_cons.comp fst <| vector_cons.comp snd (const nil)).of_eq fun v => by\n        simp only [cons_head, cons_tail],\n      fun h => h.comp vector_head (vector_head.comp vector_tail)⟩\n#align part_iff₂ part_iff₂\n\n",
 "part_iff₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem part_iff₁ {f : «expr →. » ℕ ℕ} : (@partrec' 1 fun v => f v.head) ↔ partrec f :=\n  part_iff.trans\n    ⟨fun h =>\n      (h.comp <| (primrec.vector_of_fn fun i => primrec.id).to_comp).of_eq fun v => by simp only [id.def, head_of_fn],\n      fun h => h.comp vector_head⟩\n#align part_iff₁ part_iff₁\n\n",
 "part_iff":
 "theorem part_iff {n f} : @partrec' n f ↔ partrec f :=\n  ⟨to_part, of_part⟩\n#align part_iff part_iff\n\n",
 "of_prim":
 "theorem of_prim {n} {f : Vector ℕ n → ℕ} (hf : primrec f) : @partrec' n f :=\n  prim (nat.primrec'.of_prim hf)\n#align of_prim of_prim\n\n",
 "of_part":
 "theorem of_part : ∀ {n f}, partrec f → @partrec' n f :=\n  suffices ∀ f, nat.partrec f → @partrec' 1 fun v => f v.head from fun n f hf =>\n    by\n    let g; swap\n    exact\n      (comp₁ g (this g hf) (prim nat.primrec'.encode)).of_eq fun i => by dsimp only [g] <;> simp [encodek, Part.map_id']\n  fun f hf => by\n  obtain ⟨c, rfl⟩ := exists_code.1 hf\n  simpa [eval_eq_rfind_opt] using\n    rfind_opt <|\n      of_prim <|\n        primrec.encode_iff.2 <|\n          evaln_prim.comp <|\n            (primrec.vector_head.pair (primrec.const c)).pair <| primrec.vector_head.comp primrec.vector_tail\n#align of_part of_part\n\n",
 "of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n#print of_eq /-\ntheorem of_eq {n} {f g : «expr →. » (Vector ℕ n) ℕ} (hf : partrec' f) (H : ∀ i, f i = g i) : partrec' g :=\n  (funext H : f = g) ▸ hf\n#align of_eq of_eq\n-/\n\n",
 "not":
 "/- warning: not clashes with bnot -> not\nCase conversion may be inaccurate. Consider using '#align not notₓ'. -/\n#print not /-\nprotected theorem not {p : α → Prop} (hp : computable_pred p) : computable_pred fun a => ¬p a := by\n  obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp <;>\n    exact\n      ⟨by infer_instance,\n        (cond hf (const ff) (const tt)).of_eq fun n => by\n          dsimp\n          cases f n <;> rfl⟩\n#align not not\n-/\n\n",
 "nil":
 "protected theorem nil {n} : @vec n 0 fun _ => nil := fun i => i.elim0\n#align nil nil\n\n",
 "merge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem merge' {f g : «expr →. » α σ} (hf : partrec f) (hg : partrec g) :\n    ∃ k : «expr →. » α σ, partrec k ∧ ∀ a, (∀ x ∈ k a, x ∈ f a ∨ x ∈ g a) ∧ ((k a).dom ↔ (f a).dom ∨ (g a).dom) :=\n  by\n  let ⟨k, hk, H⟩ := nat.partrec.merge' (bind_decode₂_iff.1 hf) (bind_decode₂_iff.1 hg)\n  let k' a := (k (encode a)).bind fun n => decode σ n\n  refine' ⟨k', ((nat_iff.2 hk).comp computable.encode).bind (computable.decode.of_option.comp snd).to₂, fun a => _⟩\n  suffices; refine' ⟨this, ⟨fun h => (this _ ⟨h, rfl⟩).imp Exists.fst Exists.fst, _⟩⟩\n  · intro h\n    rw [bind_dom]\n    have hk : (k (encode a)).dom := (H _).2.2 (by simpa only [encodek₂, bind_some, coe_some] using h)\n    exists hk\n    simp only [exists_prop, mem_map_iff, mem_coe, mem_bind_iff, option.mem_def] at H\n    obtain ⟨a', ha', y, hy, e⟩ | ⟨a', ha', y, hy, e⟩ := (H _).1 _ ⟨hk, rfl⟩ <;> · simp only [e.symm, encodek]\n  intro x h'; simp only [k', exists_prop, mem_coe, mem_bind_iff, option.mem_def] at h'\n  obtain ⟨n, hn, hx⟩ := h'\n  have := (H _).1 _ hn\n  simp [mem_decode₂, encode_injective.eq_iff] at this\n  obtain ⟨a', ha, rfl⟩ | ⟨a', ha, rfl⟩ := this <;> simp only [encodek] at hx <;> rw [hx] at ha\n  · exact or.inl ha\n  exact or.inr ha\n#align merge' merge'\n\n",
 "merge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem merge {f g : «expr →. » α σ} (hf : partrec f) (hg : partrec g) (H : ∀ (a), ∀ x ∈ f a, ∀ y ∈ g a, x = y) :\n    ∃ k : «expr →. » α σ, partrec k ∧ ∀ a x, x ∈ k a ↔ x ∈ f a ∨ x ∈ g a :=\n  let ⟨k, hk, K⟩ := merge' hf hg\n  ⟨k, hk, fun a x =>\n    ⟨(K _).1 _, fun h => by\n      have : (k a).dom := (K _).2.2 (h.imp Exists.fst Exists.fst)\n      refine' ⟨this, _⟩\n      cases' h with h h <;> cases' (K _).1 _ ⟨this, rfl⟩ with h' h'\n      · exact mem_unique h' h\n      · exact (H _ _ h _ h').symm\n      · exact H _ _ h' _ h\n      · exact mem_unique h' h⟩⟩\n#align merge merge\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprotected theorem map {n f} {g : Vector ℕ (n + 1) → ℕ} (hf : @partrec' n f) (hg : @partrec' (n + 1) g) :\n    @partrec' n fun v => (f v).map fun a => g («expr ::ᵥ » a v) := by\n  simp [(Part.bind_some_eq_map _ _).symm] <;> exact hf.bind hg\n#align map map\n\n",
 "idv":
 "theorem idv {n} : @vec n n id :=\n  vec.prim nat.primrec'.idv\n#align idv idv\n\n",
 "head":
 "theorem head {n : ℕ} : @partrec' n.succ (@head ℕ n) :=\n  prim nat.primrec'.head\n#align head head\n\n",
 "halting_problem_re":
 "theorem halting_problem_re (n) : re_pred fun c => (eval c n).dom :=\n  (eval_part.comp computable.id (computable.const _)).dom_re\n#align halting_problem_re halting_problem_re\n\n",
 "halting_problem_not_re":
 "theorem halting_problem_not_re (n) : ¬re_pred fun c => ¬(eval c n).dom\n  | h => halting_problem _ <| computable_iff_re_compl_re'.2 ⟨halting_problem_re _, h⟩\n#align halting_problem_not_re halting_problem_not_re\n\n",
 "halting_problem":
 "theorem halting_problem (n) : ¬computable_pred fun c => (eval c n).dom\n  | h => rice { f | (f n).dom } h nat.partrec.zero nat.partrec.none trivial\n#align halting_problem halting_problem\n\n",
 "dom_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem partrec.dom_re {α β} [primcodable α] [primcodable β] {f : «expr →. » α β} (h : partrec f) :\n    re_pred fun a => (f a).dom :=\n  (h.map (computable.const ()).to₂).of_eq fun n => Part.ext fun _ => by simp [Part.dom_iff_mem]\n#align partrec.dom_re partrec.dom_re\n\n",
 "cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprotected theorem cons {n m} {f : Vector ℕ n → ℕ} {g} (hf : @partrec' n f) (hg : @vec n m g) :\n    vec fun v => «expr ::ᵥ » (f v) (g v) := fun i =>\n  Fin.cases (by simp [*]) (fun i => by simp only [hg i, nth_cons_succ]) i\n#align cons cons\n\n",
 "cond":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\n#print cond /-\ntheorem cond {c : α → bool} {f : «expr →. » α σ} {g : «expr →. » α σ} (hc : computable c) (hf : partrec f)\n    (hg : partrec g) : partrec fun a => cond (c a) (f a) (g a) :=\n  let ⟨cf, ef⟩ := exists_code.1 hf\n  let ⟨cg, eg⟩ := exists_code.1 hg\n  ((eval_part.comp (computable.cond hc (const cf) (const cg)) computable.id).bind\n        ((@computable.decode σ _).comp snd).of_option.to₂).of_eq\n    fun a => by cases c a <;> simp [ef, eg, encodek]\n#align cond cond\n-/\n\n",
 "comp₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →. » -/\ntheorem comp₁ {n} (f : «expr →. » ℕ ℕ) {g : Vector ℕ n → ℕ} (hf : @partrec' 1 fun v => f v.head) (hg : @partrec' n g) :\n    @partrec' n fun v => f (g v) := by simpa using hf.comp' (partrec'.cons hg partrec'.nil)\n#align comp₁ comp₁\n\n",
 "computable_iff_re_compl_re'":
 "theorem computable_iff_re_compl_re' {p : α → Prop} : computable_pred p ↔ re_pred p ∧ re_pred fun a => ¬p a := by\n  classical exact computable_iff_re_compl_re\n#align computable_iff_re_compl_re' computable_iff_re_compl_re'\n\n",
 "computable_iff_re_compl_re":
 "-- Post's theorem on the equivalence of r.e., co-r.e. sets and\n-- computable sets. The assumption that p is decidable is required\n-- unless we assume Markov's principle or LEM.\n@[nolint decidable_classical]\ntheorem computable_iff_re_compl_re {p : α → Prop} [decidable_pred p] :\n    computable_pred p ↔ re_pred p ∧ re_pred fun a => ¬p a :=\n  ⟨fun h => ⟨h.to_re, h.not.to_re⟩, fun ⟨h₁, h₂⟩ =>\n    ⟨‹_›,\n      by\n      obtain ⟨k, pk, hk⟩ := partrec.merge (h₁.map (computable.const tt).to₂) (h₂.map (computable.const ff).to₂) _\n      · refine' partrec.of_eq pk fun n => Part.eq_some_iff.2 _\n        rw [hk]\n        simp\n        apply decidable.em\n      · intro a x hx y hy\n        simp at hx hy\n        cases hy.1 hx.1⟩⟩\n#align computable_iff_re_compl_re computable_iff_re_compl_re\n\n",
 "computable_iff":
 "theorem computable_iff {p : α → Prop} : computable_pred p ↔ ∃ f : α → bool, computable f ∧ p = fun a => f a :=\n  ⟨fun ⟨D, h⟩ => ⟨_, h, funext fun a => propext (Bool.decide_iff _).symm⟩, by\n    rintro ⟨f, h, rfl⟩ <;> exact ⟨by infer_instance, by simpa using h⟩⟩\n#align computable_iff computable_iff\n\n",
 "comp'":
 "theorem comp' {n m f g} (hf : @partrec' m f) (hg : @vec n m g) : partrec' fun v => f (g v) :=\n  (hf.comp _ hg).of_eq fun v => by simp\n#align comp' comp'\n\n",
 "bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\nprotected theorem bind {n f g} (hf : @partrec' n f) (hg : @partrec' (n + 1) g) :\n    @partrec' n fun v => (f v).bind fun a => g («expr ::ᵥ » a v) :=\n  (@comp n (n + 1) g (fun i => Fin.cases f (fun i v => some (v.nth i)) i) hg fun i =>\n        by\n        refine' Fin.cases _ (fun i => _) i <;> simp [*]\n        exact prim (nat.primrec'.nth _)).of_eq\n    fun v => by simp [m_of_fn, Part.bind_assoc, pure]\n#align bind bind\n\n"}