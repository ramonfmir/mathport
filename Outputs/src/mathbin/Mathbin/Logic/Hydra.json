{"not_cut_expand_zero":
 "theorem not_cut_expand_zero [is_irrefl α r] (s) : ¬CutExpand r s 0 := by\n  classical\n    rw [cut_expand_iff]\n    rintro ⟨_, _, _, ⟨⟩, _⟩\n#align not_cut_expand_zero not_cut_expand_zero\n\n",
 "cut_expand_singleton_singleton":
 "theorem cut_expand_singleton_singleton {x' x} (h : r x' x) : CutExpand r {x'} {x} :=\n  cutExpand_singleton fun a h => by rwa [mem_singleton.1 h]\n#align cut_expand_singleton_singleton cut_expand_singleton_singleton\n\n",
 "cut_expand_singleton":
 "theorem cut_expand_singleton {s x} (h : ∀ x' ∈ s, r x' x) : CutExpand r s {x} :=\n  ⟨s, x, h, add_comm s _⟩\n#align cut_expand_singleton cut_expand_singleton\n\n",
 "cut_expand_le_inv_image_lex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-\nCopyright (c) 2022 Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Junyan Xu\n-/\ntheorem cut_expand_le_inv_image_lex [hi : is_irrefl α r] :\n    CutExpand r ≤ inv_image (Finsupp.Lex («expr ⊓ » («expr ᶜ» r) (· ≠ ·)) (· < ·)) toFinsupp :=\n  fun s t ⟨u, a, hr, he⟩ => by\n  classical\n    refine' ⟨a, fun b h => _, _⟩ <;> simp_rw [to_finsupp_apply]\n    · apply_fun count b  at he\n      simp_rw [count_add] at he\n      convert he <;> convert(add_zero _).symm <;> rw [count_eq_zero] <;> intro hb\n      exacts[h.2 (mem_singleton.1 hb), h.1 (hr b hb)]\n    · apply_fun count a  at he\n      simp_rw [count_add, count_singleton_self] at he\n      apply nat.lt_of_succ_le\n      convert he.le\n      convert(add_zero _).symm\n      exact count_eq_zero.2 fun ha => hi.irrefl a <| hr a ha\n#align cut_expand_le_inv_image_lex cut_expand_le_inv_image_lex\n\n",
 "cut_expand_iff":
 "theorem cut_expand_iff [DecidableEq α] [is_irrefl α r] {s' s : Multiset α} :\n    CutExpand r s' s ↔ ∃ (t : Multiset α)(a : _), (∀ a' ∈ t, r a' a) ∧ a ∈ s ∧ s' = s.erase a + t :=\n  by\n  simp_rw [cut_expand, add_singleton_eq_iff]\n  refine' exists₂_congr fun t a => ⟨_, _⟩\n  · rintro ⟨ht, ha, rfl⟩\n    obtain h | h := mem_add.1 ha\n    exacts[⟨ht, h, t.erase_add_left_pos h⟩, (@irrefl α r _ a (ht a h)).elim]\n  · rintro ⟨ht, h, rfl⟩\n    exact ⟨ht, mem_add.2 (or.inl h), (t.erase_add_left_pos h).symm⟩\n#align cut_expand_iff cut_expand_iff\n\n",
 "cut_expand_fibration":
 "/-- For any relation `r` on `α`, multiset addition `multiset α × multiset α → multiset α` is a\n  fibration between the game sum of `cut_expand r` with itself and `cut_expand r` itself. -/\ntheorem cut_expand_fibration (r : α → α → Prop) :\n    Fibration (GameAdd (CutExpand r) (CutExpand r)) (CutExpand r) fun s => s.1 + s.2 :=\n  by\n  rintro ⟨s₁, s₂⟩ s ⟨t, a, hr, he⟩; dsimp at he⊢\n  classical\n    obtain ⟨ha, rfl⟩ := add_singleton_eq_iff.1 he\n    rw [add_assoc, mem_add] at ha\n    obtain h | h := ha\n    · refine' ⟨(s₁.erase a + t, s₂), game_add.fst ⟨t, a, hr, _⟩, _⟩\n      · rw [add_comm, ← add_assoc, singleton_add, cons_erase h]\n      · rw [add_assoc s₁, erase_add_left_pos _ h, add_right_comm, add_assoc]\n    · refine' ⟨(s₁, (s₂ + t).erase a), game_add.snd ⟨t, a, hr, _⟩, _⟩\n      · rw [add_comm, singleton_add, cons_erase h]\n      · rw [add_assoc, erase_add_right_pos _ h]\n#align cut_expand_fibration cut_expand_fibration\n\n",
 "cut_expand_add_left":
 "theorem cut_expand_add_left {t u} (s) : CutExpand r (s + t) (s + u) ↔ CutExpand r t u :=\n  exists₂_congr fun _ _ => and_congr iff.rfl <| by rw [add_assoc, add_assoc, add_left_cancel_iff]\n#align cut_expand_add_left cut_expand_add_left\n\n",
 "cut_expand":
 "#print WellFounded.cutExpand /-\n/-- `cut_expand r` is well-founded when `r` is. -/\ntheorem WellFounded.cutExpand (hr : well_founded r) : well_founded (CutExpand r) :=\n  ⟨letI h := hr.is_irrefl\n    fun s => acc_of_singleton fun a _ => (hr.apply a).cut_expand⟩\n#align well_founded.cut_expand WellFounded.cutExpand\n-/\n\n",
 "acc_of_singleton":
 "/-- A multiset is accessible under `cut_expand` if all its singleton subsets are,\n  assuming `r` is irreflexive. -/\ntheorem acc_of_singleton [is_irrefl α r] {s : Multiset α} : (∀ a ∈ s, acc (CutExpand r) {a}) → acc (CutExpand r) s :=\n  by\n  refine' Multiset.induction _ _ s\n  · exact fun _ => acc.intro 0 fun s h => (not_cut_expand_zero s h).elim\n  · intro a s ih hacc\n    rw [← s.singleton_add a]\n    exact\n      ((hacc a <| s.mem_cons_self a).prod_game_add <| ih fun a ha => hacc a <| mem_cons_of_mem ha).of_fibration _\n        (cut_expand_fibration r)\n#align acc_of_singleton acc_of_singleton\n\n"}