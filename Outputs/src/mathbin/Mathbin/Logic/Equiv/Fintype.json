{"viaFintypeEmbedding_sign":
 "#print Equiv.Perm.viaFintypeEmbedding_sign /-\n@[simp]\ntheorem Equiv.Perm.viaFintypeEmbedding_sign [DecidableEq α] [Fintype β] :\n    Equiv.Perm.sign (e.via_fintype_embedding f) = Equiv.Perm.sign e := by simp [Equiv.Perm.viaFintypeEmbedding]\n#align equiv.perm.via_fintype_embedding_sign Equiv.Perm.viaFintypeEmbedding_sign\n-/\n\n",
 "viaFintypeEmbedding_apply_not_mem_range":
 "#print Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range /-\ntheorem Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range {b : β} (h : b ∉ Set.range f) :\n    e.via_fintype_embedding f b = b := by\n  rwa [Equiv.Perm.viaFintypeEmbedding, Equiv.Perm.extendDomain_apply_not_subtype]\n#align equiv.perm.via_fintype_embedding_apply_not_mem_range Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range\n-/\n\n",
 "viaFintypeEmbedding_apply_mem_range":
 "#print Equiv.Perm.viaFintypeEmbedding_apply_mem_range /-\ntheorem Equiv.Perm.viaFintypeEmbedding_apply_mem_range {b : β} (h : b ∈ Set.range f) :\n    e.via_fintype_embedding f b = f (e (f.inv_of_mem_range ⟨b, h⟩)) := by\n  simpa [Equiv.Perm.viaFintypeEmbedding, Equiv.Perm.extendDomain_apply_subtype, h]\n#align equiv.perm.via_fintype_embedding_apply_mem_range Equiv.Perm.viaFintypeEmbedding_apply_mem_range\n-/\n\n",
 "viaFintypeEmbedding_apply_image":
 "#print Equiv.Perm.viaFintypeEmbedding_apply_image /-\n@[simp]\ntheorem Equiv.Perm.viaFintypeEmbedding_apply_image (a : α) : e.via_fintype_embedding f (f a) = f (e a) :=\n  by\n  rw [Equiv.Perm.viaFintypeEmbedding]\n  convert Equiv.Perm.extendDomain_apply_image e _ _\n#align equiv.perm.via_fintype_embedding_apply_image Equiv.Perm.viaFintypeEmbedding_apply_image\n-/\n\n",
 "toEquivRange_symm_apply_self":
 "#print Function.Embedding.toEquivRange_symm_apply_self /-\n@[simp]\ntheorem Function.Embedding.toEquivRange_symm_apply_self (a : α) :\n    f.to_equiv_range.symm ⟨f a, Set.mem_range_self a⟩ = a := by simp [Equiv.symm_apply_eq]\n#align function.embedding.to_equiv_range_symm_apply_self Function.Embedding.toEquivRange_symm_apply_self\n-/\n\n",
 "toEquivRange_eq_ofInjective":
 "#print Function.Embedding.toEquivRange_eq_ofInjective /-\ntheorem Function.Embedding.toEquivRange_eq_ofInjective : f.to_equiv_range = Equiv.ofInjective f f.injective :=\n  by\n  ext\n  simp\n#align function.embedding.to_equiv_range_eq_of_injective Function.Embedding.toEquivRange_eq_ofInjective\n-/\n\n",
 "toEquivRange_apply":
 "#print Function.Embedding.toEquivRange_apply /-\n/-\nCopyright (c) 2021 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\n@[simp]\ntheorem Function.Embedding.toEquivRange_apply (a : α) : f.to_equiv_range a = ⟨f a, Set.mem_range_self a⟩ :=\n  rfl\n#align function.embedding.to_equiv_range_apply Function.Embedding.toEquivRange_apply\n-/\n\n",
 "extend_subtype_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_not_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : ¬p x) : ¬q (e.extend_subtype x) :=\n  by\n  convert(e.to_compl ⟨x, hx⟩).2\n  rw [e.extend_subtype_apply_of_not_mem _ hx, subtype.val_eq_coe]\n#align extend_subtype_not_mem extend_subtype_not_mem\n\n",
 "extend_subtype_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : p x) : q (e.extend_subtype x) :=\n  by\n  convert(e ⟨x, hx⟩).2\n  rw [e.extend_subtype_apply_of_mem _ hx, subtype.val_eq_coe]\n#align extend_subtype_mem extend_subtype_mem\n\n",
 "extend_subtype_apply_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_apply_of_not_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : ¬p x) :\n    e.extend_subtype x = e.to_compl ⟨x, hx⟩ :=\n  by\n  dsimp only [extend_subtype]\n  simp only [subtype_congr, Equiv.trans_apply, Equiv.sumCongr_apply]\n  rw [sum_compl_apply_symm_of_neg _ _ hx, Sum.map_inr, sum_compl_apply_inr]\n#align extend_subtype_apply_of_not_mem extend_subtype_apply_of_not_mem\n\n",
 "extend_subtype_apply_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_apply_of_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : p x) :\n    e.extend_subtype x = e ⟨x, hx⟩ := by\n  dsimp only [extend_subtype]\n  simp only [subtype_congr, Equiv.trans_apply, Equiv.sumCongr_apply]\n  rw [sum_compl_apply_symm_of_pos _ _ hx, Sum.map_inl, sum_compl_apply_inl]\n#align extend_subtype_apply_of_mem extend_subtype_apply_of_mem\n\n"}