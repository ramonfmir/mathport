{"via_fintype_embedding_sign":
 "@[simp]\ntheorem equiv.perm.via_fintype_embedding_sign [decidable_eq α] [fintype β] :\n    equiv.perm.sign (e.via_fintype_embedding f) = equiv.perm.sign e := by simp [equiv.perm.via_fintype_embedding]\n#align equiv.perm.via_fintype_embedding_sign equiv.perm.via_fintype_embedding_sign\n\n",
 "via_fintype_embedding_apply_not_mem_range":
 "theorem equiv.perm.via_fintype_embedding_apply_not_mem_range {b : β} (h : b ∉ Set.range f) :\n    e.via_fintype_embedding f b = b := by\n  rwa [equiv.perm.via_fintype_embedding, Equiv.Perm.extendDomain_apply_not_subtype]\n#align equiv.perm.via_fintype_embedding_apply_not_mem_range equiv.perm.via_fintype_embedding_apply_not_mem_range\n\n",
 "via_fintype_embedding_apply_mem_range":
 "theorem equiv.perm.via_fintype_embedding_apply_mem_range {b : β} (h : b ∈ Set.range f) :\n    e.via_fintype_embedding f b = f (e (f.inv_of_mem_range ⟨b, h⟩)) := by\n  simpa [equiv.perm.via_fintype_embedding, Equiv.Perm.extendDomain_apply_subtype, h]\n#align equiv.perm.via_fintype_embedding_apply_mem_range equiv.perm.via_fintype_embedding_apply_mem_range\n\n",
 "via_fintype_embedding_apply_image":
 "@[simp]\ntheorem equiv.perm.via_fintype_embedding_apply_image (a : α) : e.via_fintype_embedding f (f a) = f (e a) :=\n  by\n  rw [equiv.perm.via_fintype_embedding]\n  convert Equiv.Perm.extendDomain_apply_image e _ _\n#align equiv.perm.via_fintype_embedding_apply_image equiv.perm.via_fintype_embedding_apply_image\n\n",
 "to_equiv_range_symm_apply_self":
 "@[simp]\ntheorem function.embedding.to_equiv_range_symm_apply_self (a : α) :\n    f.to_equiv_range.symm ⟨f a, Set.mem_range_self a⟩ = a := by simp [equiv.symm_apply_eq]\n#align function.embedding.to_equiv_range_symm_apply_self function.embedding.to_equiv_range_symm_apply_self\n\n",
 "to_equiv_range_eq_of_injective":
 "theorem function.embedding.to_equiv_range_eq_of_injective : f.to_equiv_range = Equiv.ofInjective f f.injective :=\n  by\n  ext\n  simp\n#align function.embedding.to_equiv_range_eq_of_injective function.embedding.to_equiv_range_eq_of_injective\n\n",
 "to_equiv_range_apply":
 "/-\nCopyright (c) 2021 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\n@[simp]\ntheorem function.embedding.to_equiv_range_apply (a : α) : f.to_equiv_range a = ⟨f a, Set.mem_range_self a⟩ :=\n  rfl\n#align function.embedding.to_equiv_range_apply function.embedding.to_equiv_range_apply\n\n",
 "extend_subtype_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_not_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : ¬p x) : ¬q (e.extend_subtype x) :=\n  by\n  convert (e.to_compl ⟨x, hx⟩).2\n  rw [e.extend_subtype_apply_of_not_mem _ hx, subtype.val_eq_coe]\n#align extend_subtype_not_mem extend_subtype_not_mem\n\n",
 "extend_subtype_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : p x) : q (e.extend_subtype x) :=\n  by\n  convert (e ⟨x, hx⟩).2\n  rw [e.extend_subtype_apply_of_mem _ hx, subtype.val_eq_coe]\n#align extend_subtype_mem extend_subtype_mem\n\n",
 "extend_subtype_apply_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_apply_of_not_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : ¬p x) :\n    e.extend_subtype x = e.to_compl ⟨x, hx⟩ :=\n  by\n  dsimp only [extend_subtype]\n  simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply]\n  rw [sum_compl_apply_symm_of_neg _ _ hx, sum.map_inr, sum_compl_apply_inr]\n#align extend_subtype_apply_of_not_mem extend_subtype_apply_of_not_mem\n\n",
 "extend_subtype_apply_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem extend_subtype_apply_of_mem (e : «expr ≃ » { x // p x } { x // q x }) (x) (hx : p x) :\n    e.extend_subtype x = e ⟨x, hx⟩ := by\n  dsimp only [extend_subtype]\n  simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply]\n  rw [sum_compl_apply_symm_of_pos _ _ hx, sum.map_inl, sum_compl_apply_inl]\n#align extend_subtype_apply_of_mem extend_subtype_apply_of_mem\n\n"}