{"union_symm_apply_right":
 "@[simp]\ntheorem union_symm_apply_right {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : s ∩ t ⊆ ∅) (a : t) :\n    (Equiv.Set.union H).symm (Sum.inr a) = ⟨a, subset_union_right _ _ a.2⟩ :=\n  rfl\n#align union_symm_apply_right union_symm_apply_right\n\n",
 "union_symm_apply_left":
 "@[simp]\ntheorem union_symm_apply_left {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : s ∩ t ⊆ ∅) (a : s) :\n    (Equiv.Set.union H).symm (Sum.inl a) = ⟨a, subset_union_left _ _ a.2⟩ :=\n  rfl\n#align union_symm_apply_left union_symm_apply_left\n\n",
 "union_apply_right":
 "theorem union_apply_right {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : s ∩ t ⊆ ∅) {a : (s ∪ t : Set α)}\n    (ha : ↑a ∈ t) : Equiv.Set.union H a = Sum.inr ⟨a, ha⟩ :=\n  dif_neg fun h => H ⟨h, ha⟩\n#align union_apply_right union_apply_right\n\n",
 "union_apply_left":
 "-- We could construct this using `equiv.set.image e s e.injective`,\n-- but this definition provides an explicit inverse.\ntheorem union_apply_left {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : s ∩ t ⊆ ∅) {a : (s ∪ t : Set α)}\n    (ha : ↑a ∈ s) : Equiv.Set.union H a = Sum.inl ⟨a, ha⟩ :=\n  dif_pos ha\n#align union_apply_left union_apply_left\n\n",
 "symm_preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem symm_preimage_preimage {α β} (e : «expr ≃ » α β) (s : Set β) : «expr ⁻¹' » e.symm («expr ⁻¹' » e s) = s :=\n  e.right_inverse_symm.preimage_preimage s\n#align symm_preimage_preimage symm_preimage_preimage\n\n",
 "symm_image_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem symm_image_image {α β} (e : «expr ≃ » α β) (s : Set α) : «expr '' » e.symm («expr '' » e s) = s :=\n  e.left_inverse_symm.image_image s\n#align symm_image_image symm_image_image\n\n",
 "sum_diff_subset_symm_apply_of_not_mem":
 "theorem sum_diff_subset_symm_apply_of_not_mem {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)] {x : t}\n    (hx : x.1 ∉ s) : (Equiv.Set.sumDiffSubset h).symm x = Sum.inr ⟨x, ⟨x.2, hx⟩⟩ :=\n  by\n  apply (Equiv.Set.sumDiffSubset h).injective\n  simp only [apply_symm_apply, sum_diff_subset_apply_inr]\n  exact Subtype.eq rfl\n#align sum_diff_subset_symm_apply_of_not_mem sum_diff_subset_symm_apply_of_not_mem\n\n",
 "sum_diff_subset_symm_apply_of_mem":
 "theorem sum_diff_subset_symm_apply_of_mem {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)] {x : t} (hx : x.1 ∈ s) :\n    (Equiv.Set.sumDiffSubset h).symm x = Sum.inl ⟨x, hx⟩ :=\n  by\n  apply (Equiv.Set.sumDiffSubset h).injective\n  simp only [apply_symm_apply, sum_diff_subset_apply_inl]\n  exact Subtype.eq rfl\n#align sum_diff_subset_symm_apply_of_mem sum_diff_subset_symm_apply_of_mem\n\n",
 "sum_diff_subset_apply_inr":
 "@[simp]\ntheorem sum_diff_subset_apply_inr {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)] (x : t \\ s) :\n    Equiv.Set.sumDiffSubset h (Sum.inr x) = inclusion (diff_subset t s) x :=\n  rfl\n#align sum_diff_subset_apply_inr sum_diff_subset_apply_inr\n\n",
 "sum_diff_subset_apply_inl":
 "@[simp]\ntheorem sum_diff_subset_apply_inl {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)] (x : s) :\n    Equiv.Set.sumDiffSubset h (Sum.inl x) = inclusion h x :=\n  rfl\n#align sum_diff_subset_apply_inl sum_diff_subset_apply_inl\n\n",
 "sum_compl_symm_apply_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem sum_compl_symm_apply_of_not_mem {α : Type u} {s : Set α} [DecidablePred (· ∈ s)] {x : α} (hx : x ∉ s) :\n    (Equiv.Set.sumCompl s).symm x = Sum.inr ⟨x, hx⟩ :=\n  by\n  have : ↑(⟨x, or.inr hx⟩ : (s ∪ «expr ᶜ» s : Set α)) ∈ «expr ᶜ» s := hx\n  rw [Equiv.Set.sumCompl]\n  simpa using set.union_apply_right _ this\n#align sum_compl_symm_apply_of_not_mem sum_compl_symm_apply_of_not_mem\n\n",
 "sum_compl_symm_apply_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem sum_compl_symm_apply_of_mem {α : Type u} {s : Set α} [DecidablePred (· ∈ s)] {x : α} (hx : x ∈ s) :\n    (Equiv.Set.sumCompl s).symm x = Sum.inl ⟨x, hx⟩ :=\n  by\n  have : ↑(⟨x, or.inl hx⟩ : (s ∪ «expr ᶜ» s : Set α)) ∈ s := hx\n  rw [Equiv.Set.sumCompl]\n  simpa using set.union_apply_left _ this\n#align sum_compl_symm_apply_of_mem sum_compl_symm_apply_of_mem\n\n",
 "sum_compl_symm_apply_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem sum_compl_symm_apply_compl {α : Type _} {s : Set α} [DecidablePred (· ∈ s)] {x : «expr ᶜ» s} :\n    (Equiv.Set.sumCompl s).symm x = Sum.inr x := by cases' x with x hx <;> exact set.sum_compl_symm_apply_of_not_mem hx\n#align sum_compl_symm_apply_compl sum_compl_symm_apply_compl\n\n",
 "sum_compl_symm_apply":
 "@[simp]\ntheorem sum_compl_symm_apply {α : Type _} {s : Set α} [DecidablePred (· ∈ s)] {x : s} :\n    (Equiv.Set.sumCompl s).symm x = Sum.inl x := by cases' x with x hx <;> exact set.sum_compl_symm_apply_of_mem hx\n#align sum_compl_symm_apply sum_compl_symm_apply\n\n",
 "sum_compl_apply_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem sum_compl_apply_inr {α : Type u} (s : Set α) [DecidablePred (· ∈ s)] (x : «expr ᶜ» s) :\n    Equiv.Set.sumCompl s (Sum.inr x) = x :=\n  rfl\n#align sum_compl_apply_inr sum_compl_apply_inr\n\n",
 "sum_compl_apply_inl":
 "@[simp]\ntheorem sum_compl_apply_inl {α : Type u} (s : Set α) [DecidablePred (· ∈ s)] (x : s) :\n    Equiv.Set.sumCompl s (Sum.inl x) = x :=\n  rfl\n#align sum_compl_apply_inl sum_compl_apply_inl\n\n",
 "subset_image'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\nprotected theorem subset_image' {α β} (e : «expr ≃ » α β) (s : Set α) (t : Set β) :\n    s ⊆ «expr '' » e.symm t ↔ «expr '' » e s ⊆ t :=\n  calc\n    s ⊆ «expr '' » e.symm t ↔ «expr '' » e.symm.symm s ⊆ t := by rw [e.symm.subset_image]\n    _ ↔ «expr '' » e s ⊆ t := by rw [e.symm_symm]\n    \n#align subset_image' subset_image'\n\n",
 "subset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\nprotected theorem subset_image {α β} (e : «expr ≃ » α β) (s : Set α) (t : Set β) :\n    «expr '' » e.symm t ⊆ s ↔ t ⊆ «expr '' » e s := by rw [image_subset_iff, e.image_eq_preimage]\n#align subset_image subset_image\n\n",
 "set_forall_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem set_forall_iff {α β} (e : «expr ≃ » α β) {p : Set α → Prop} : (∀ a, p a) ↔ ∀ a, p («expr ⁻¹' » e a) :=\n  e.injective.preimage_surjective.forall\n#align set_forall_iff set_forall_iff\n\n",
 "self_comp_of_injective_symm":
 "@[simp]\ntheorem self_comp_of_injective_symm {α β} {f : α → β} (hf : injective f) : f ∘ (ofInjective f hf).symm = coe :=\n  funext fun x => apply_ofInjective_symm hf x\n#align self_comp_of_injective_symm self_comp_of_injective_symm\n\n",
 "range_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura, Mario Carneiro\n-/\n@[simp]\ntheorem range_eq_univ {α : Type _} {β : Type _} (e : «expr ≃ » α β) : range e = univ :=\n  eq_univ_of_forall e.surjective\n#align range_eq_univ range_eq_univ\n\n",
 "prod_assoc_symm_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_assoc_symm_preimage {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    «expr ⁻¹' » (Equiv.prodAssoc α β γ).symm (set.prod (set.prod s t) u) = set.prod s (set.prod t u) :=\n  by\n  ext\n  simp [and_assoc']\n#align prod_assoc_symm_preimage prod_assoc_symm_preimage\n\n",
 "prod_assoc_symm_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_assoc_symm_image {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    «expr '' » (Equiv.prodAssoc α β γ).symm (set.prod s (set.prod t u)) = set.prod (set.prod s t) u := by\n  simpa only [Equiv.image_eq_preimage] using prod_assoc_preimage\n#align prod_assoc_symm_image prod_assoc_symm_image\n\n",
 "prod_assoc_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_assoc_preimage {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    «expr ⁻¹' » (Equiv.prodAssoc α β γ) (set.prod s (set.prod t u)) = set.prod (set.prod s t) u :=\n  by\n  ext\n  simp [and_assoc']\n#align prod_assoc_preimage prod_assoc_preimage\n\n",
 "prod_assoc_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n-- `@[simp]` doesn't like these lemmas, as it uses `set.image_congr'` to turn `equiv.prod_assoc`\n-- into a lambda expression and then unfold it.\ntheorem prod_assoc_image {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    «expr '' » (Equiv.prodAssoc α β γ) (set.prod (set.prod s t) u) = set.prod s (set.prod t u) := by\n  simpa only [Equiv.image_eq_preimage] using prod_assoc_symm_preimage\n#align prod_assoc_image prod_assoc_image\n\n",
 "preimage_symm_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_symm_preimage {α β} (e : «expr ≃ » α β) (s : Set α) : «expr ⁻¹' » e («expr ⁻¹' » e.symm s) = s :=\n  e.left_inverse_symm.preimage_preimage s\n#align preimage_symm_preimage preimage_symm_preimage\n\n",
 "preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_subset {α β} (e : «expr ≃ » α β) (s t : Set β) : «expr ⁻¹' » e s ⊆ «expr ⁻¹' » e t ↔ s ⊆ t :=\n  e.surjective.preimage_subset_preimage_iff\n#align preimage_subset preimage_subset\n\n",
 "preimage_pi_equiv_pi_subtype_prod_symm_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem preimage_pi_equiv_pi_subtype_prod_symm_pi {α : Type _} {β : α → Type _} (p : α → Prop) [DecidablePred p]\n    (s : ∀ i, Set (β i)) :\n    «expr ⁻¹' » (piEquivPiSubtypeProd p β).symm (pi univ s) =\n      set.prod (pi univ fun i : { i // p i } => s i) (pi univ fun i : { i // ¬p i } => s i) :=\n  by\n  ext ⟨f, g⟩\n  simp only [mem_preimage, mem_univ_pi, prod_mk_mem_set_prod_eq, Subtype.forall, ← forall_and]\n  refine' forall_congr' fun i => _\n  dsimp only [Subtype.coe_mk]\n  by_cases hi : p i <;> simp [hi]\n#align preimage_pi_equiv_pi_subtype_prod_symm_pi preimage_pi_equiv_pi_subtype_prod_symm_pi\n\n",
 "preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem preimage_image {α β} (e : «expr ≃ » α β) (s : Set α) : «expr ⁻¹' » e («expr '' » e s) = s :=\n  e.injective.preimage_image s\n#align preimage_image preimage_image\n\n",
 "preimage_equiv_eq_image_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Set.preimage_equiv_eq_image_symm /-\n/-- Alias for `equiv.image_eq_preimage` -/\ntheorem Set.preimage_equiv_eq_image_symm {α β} (S : Set α) (f : «expr ≃ » β α) :\n    «expr ⁻¹' » f S = «expr '' » f.symm S :=\n  (f.symm.image_eq_preimage S).symm\n#align set.preimage_equiv_eq_image_symm Set.preimage_equiv_eq_image_symm\n-/\n\n",
 "preimage_eq_iff_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_eq_iff_eq_image {α β} (e : «expr ≃ » α β) (s t) : «expr ⁻¹' » e s = t ↔ s = «expr '' » e t :=\n  preimage_eq_iff_eq_image e.bijective\n#align preimage_eq_iff_eq_image preimage_eq_iff_eq_image\n\n",
 "of_preimage_equiv_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- See also `equiv.sigma_fiber_equiv`.\n-- See also `equiv.of_fiber_equiv`.\ntheorem of_preimage_equiv_map {α β γ} {f : α → γ} {g : β → γ}\n    (e : ∀ c, «expr ≃ » («expr ⁻¹' » f {c}) («expr ⁻¹' » g {c})) (a : α) : g (ofPreimageEquiv e a) = f a :=\n  Equiv.ofFiberEquiv_map e a\n#align of_preimage_equiv_map of_preimage_equiv_map\n\n",
 "of_left_inverse_eq_of_injective":
 "theorem of_left_inverse_eq_of_injective {α β : Type _} (f : α → β) (f_inv : Nonempty α → β → α)\n    (hf : ∀ h : Nonempty α, left_inverse (f_inv h) f) :\n    ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty α)).elim (fun h => (hf h).injective) fun h _ _ _ =>\n          by\n          haveI : subsingleton α := subsingleton_of_not_nonempty h\n          simp) :=\n  by\n  ext\n  simp\n#align of_left_inverse_eq_of_injective of_left_inverse_eq_of_injective\n\n",
 "of_left_inverse'_eq_of_injective":
 "theorem of_left_inverse'_eq_of_injective {α β : Type _} (f : α → β) (f_inv : β → α) (hf : left_inverse f_inv f) :\n    ofLeftInverse' f f_inv hf = ofInjective f hf.injective :=\n  by\n  ext\n  simp\n#align of_left_inverse'_eq_of_injective of_left_inverse'_eq_of_injective\n\n",
 "of_injective_symm_apply":
 "@[simp]\ntheorem of_injective_symm_apply {α β} {f : α → β} (hf : injective f) (a : α) :\n    (ofInjective f hf).symm ⟨f a, ⟨a, rfl⟩⟩ = a :=\n  by\n  apply (of_injective f hf).injective\n  simp [apply_of_injective_symm hf]\n#align of_injective_symm_apply of_injective_symm_apply\n\n",
 "mem_image_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Set.mem_image_equiv /-\ntheorem Set.mem_image_equiv {α β} {S : Set α} {f : «expr ≃ » α β} {x : β} : x ∈ «expr '' » f S ↔ f.symm x ∈ S :=\n  Set.ext_iff.mp (f.image_eq_preimage S) x\n#align set.mem_image_equiv Set.mem_image_equiv\n-/\n\n",
 "insert_symm_apply_inr":
 "@[simp]\ntheorem insert_symm_apply_inr {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s) (b : PUnit.{u + 1}) :\n    (Equiv.Set.insert H).symm (Sum.inr b) = ⟨a, or.inl rfl⟩ :=\n  rfl\n#align insert_symm_apply_inr insert_symm_apply_inr\n\n",
 "insert_symm_apply_inl":
 "@[simp]\ntheorem insert_symm_apply_inl {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s) (b : s) :\n    (Equiv.Set.insert H).symm (Sum.inl b) = ⟨b, or.inr b.2⟩ :=\n  rfl\n#align insert_symm_apply_inl insert_symm_apply_inl\n\n",
 "insert_apply_right":
 "@[simp]\ntheorem insert_apply_right {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s) (b : s) :\n    Equiv.Set.insert H ⟨b, or.inr b.2⟩ = Sum.inl b :=\n  (Equiv.Set.insert H).apply_eq_iff_eq_symm_apply.2 rfl\n#align insert_apply_right insert_apply_right\n\n",
 "insert_apply_left":
 "@[simp]\ntheorem insert_apply_left {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s) :\n    Equiv.Set.insert H ⟨a, or.inl rfl⟩ = Sum.inr PUnit.unit :=\n  (Equiv.Set.insert H).apply_eq_iff_eq_symm_apply.2 rfl\n#align insert_apply_left insert_apply_left\n\n",
 "image_symm_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_symm_preimage {α β} {f : α → β} (hf : injective f) (u s : Set α) :\n    «expr ⁻¹' » (fun x => (Set.image f s hf).symm x : «expr '' » f s → α) u = «expr ⁻¹' » coe («expr '' » f u) :=\n  by\n  ext ⟨b, a, has, rfl⟩\n  have : ∀ h : ∃ a', a' ∈ s ∧ a' = a, Classical.choose h = a := fun h => (Classical.choose_spec h).2\n  simp [Equiv.Set.image, Equiv.Set.imageOfInjOn, hf.eq_iff, this]\n#align image_symm_preimage image_symm_preimage\n\n",
 "image_symm_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_symm_image {α β} (e : «expr ≃ » α β) (s : Set β) : «expr '' » e («expr '' » e.symm s) = s :=\n  e.symm.symm_image_image s\n#align image_symm_image image_symm_image\n\n",
 "image_symm_apply":
 "@[simp]\nprotected theorem image_symm_apply {α β} (f : α → β) (s : Set α) (H : injective f) (x : α) (h : x ∈ s) :\n    (Set.image f s H).symm ⟨f x, ⟨x, ⟨h, rfl⟩⟩⟩ = ⟨x, h⟩ :=\n  by\n  apply (Set.image f s H).injective\n  simp [(Set.image f s H).apply_symm_apply]\n#align image_symm_apply image_symm_apply\n\n",
 "image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_subset {α β} (e : «expr ≃ » α β) (s t : Set α) : «expr '' » e s ⊆ «expr '' » e t ↔ s ⊆ t :=\n  image_subset_image_iff e.injective\n#align image_subset image_subset\n\n",
 "image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem image_preimage {α β} (e : «expr ≃ » α β) (s : Set β) : «expr '' » e («expr ⁻¹' » e s) = s :=\n  e.surjective.image_preimage s\n#align image_preimage image_preimage\n\n",
 "image_equiv_eq_preimage_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Set.image_equiv_eq_preimage_symm /-\n/-- Alias for `equiv.image_eq_preimage` -/\ntheorem Set.image_equiv_eq_preimage_symm {α β} (S : Set α) (f : «expr ≃ » α β) :\n    «expr '' » f S = «expr ⁻¹' » f.symm S :=\n  f.image_eq_preimage S\n#align set.image_equiv_eq_preimage_symm Set.image_equiv_eq_preimage_symm\n-/\n\n",
 "image_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\nprotected theorem image_eq_preimage {α β} (e : «expr ≃ » α β) (s : Set α) : «expr '' » e s = «expr ⁻¹' » e.symm s :=\n  Set.ext fun x => mem_image_iff_of_inverse e.left_inv e.right_inv\n#align image_eq_preimage image_eq_preimage\n\n",
 "image_eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_eq_iff_eq {α β} (e : «expr ≃ » α β) (s t : Set α) : «expr '' » e s = «expr '' » e t ↔ s = t :=\n  image_eq_image e.injective\n#align image_eq_iff_eq image_eq_iff_eq\n\n",
 "image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprotected theorem image_compl {α β} (f : Equiv α β) (s : Set α) :\n    «expr '' » f («expr ᶜ» s) = «expr ᶜ» («expr '' » f s) :=\n  image_compl_eq f.bijective\n#align image_compl image_compl\n\n",
 "eq_preimage_iff_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem eq_preimage_iff_image_eq {α β} (e : «expr ≃ » α β) (s t) : s = «expr ⁻¹' » e t ↔ «expr '' » e s = t :=\n  eq_preimage_iff_image_eq e.bijective\n#align eq_preimage_iff_image_eq eq_preimage_iff_image_eq\n\n",
 "eq_image_iff_symm_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem eq_image_iff_symm_image_eq {α β} (e : «expr ≃ » α β) (s : Set α) (t : Set β) :\n    t = «expr '' » e s ↔ «expr '' » e.symm t = s :=\n  (e.symm.injective.image_injective.eq_iff' (e.symm_image_image s)).symm\n#align eq_image_iff_symm_image_eq eq_image_iff_symm_image_eq\n\n",
 "dite_comp_equiv_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- The composition of an updated function with an equiv on a subset can be expressed as an\nupdated function. -/\ntheorem dite_comp_equiv_update {α : Type _} {β : Sort _} {γ : Sort _} {s : Set α} (e : «expr ≃ » β s) (v : β → γ)\n    (w : α → γ) (j : β) (x : γ) [DecidableEq β] [DecidableEq α] [∀ j, Decidable (j ∈ s)] :\n    (fun i : α => if h : i ∈ s then (Function.update v j x) (e.symm ⟨i, h⟩) else w i) =\n      Function.update (fun i : α => if h : i ∈ s then v (e.symm ⟨i, h⟩) else w i) (e j) x :=\n  by\n  ext i\n  by_cases h : i ∈ s\n  · rw [dif_pos h, Function.update_apply_equiv_apply, Equiv.symm_symm, Function.comp, Function.update_apply,\n      Function.update_apply, dif_pos h]\n    have h_coe : (⟨i, h⟩ : s) = e j ↔ i = e j := subtype.ext_iff.trans (by rw [Subtype.coe_mk])\n    simp_rw [h_coe]\n  · have : i ≠ e j := by\n      contrapose! h\n      have : (e j : α) ∈ s := (e j).2\n      rwa [← h] at this\n    simp [h, this]\n#align dite_comp_equiv_update dite_comp_equiv_updateₓ\n\n",
 "coe_of_injective_symm":
 "theorem coe_of_injective_symm {α β} {f : α → β} (hf : injective f) :\n    ((ofInjective f hf).symm : range f → α) = rangeSplitting f :=\n  by\n  ext ⟨y, x, rfl⟩\n  apply hf\n  simp [apply_range_splitting f]\n#align coe_of_injective_symm coe_of_injective_symm\n\n",
 "apply_of_injective_symm":
 "theorem apply_of_injective_symm {α β} {f : α → β} (hf : injective f) (b : range f) :\n    f ((ofInjective f hf).symm b) = b :=\n  Subtype.ext_iff.1 <| (ofInjective f hf).apply_symm_apply b\n#align apply_of_injective_symm apply_of_injective_symm\n\n"}