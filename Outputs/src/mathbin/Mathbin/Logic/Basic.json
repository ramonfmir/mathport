{"xor_true":
 "#print xor_true /-\n@[simp]\ntheorem xor_true : Xor' true = not :=\n  funext fun a => by simp [Xor']\n#align xor_true xor_true\n-/\n\n",
 "xor_self":
 "#print xor_self /-\n@[simp]\ntheorem xor_self (a : Prop) : Xor' a a = false := by simp [Xor']\n#align xor_self xor_self\n-/\n\n",
 "xor_not_right":
 "#print xor_not_right /-\n@[simp]\ntheorem xor_not_right : Xor' a ¬b ↔ (a ↔ b) := by by_cases a <;> simp [*]\n#align xor_not_right xor_not_right\n-/\n\n",
 "xor_not_not":
 "#print xor_not_not /-\ntheorem xor_not_not : Xor' (¬a) ¬b ↔ Xor' a b := by simp [Xor', or_comm', and_comm']\n#align xor_not_not xor_not_not\n-/\n\n",
 "xor_not_left":
 "#print xor_not_left /-\n@[simp]\ntheorem xor_not_left : Xor' (¬a) b ↔ (a ↔ b) := by by_cases a <;> simp [*]\n#align xor_not_left xor_not_left\n-/\n\n",
 "xor_iff_not_iff'":
 "#print xor_iff_not_iff' /-\ntheorem xor_iff_not_iff' : Xor' a b ↔ (¬a ↔ b) := by simp only [← @xor_not_left _ b, not_not]\n#align xor_iff_not_iff' xor_iff_not_iff'\n-/\n\n",
 "xor_iff_not_iff":
 "#print xor_iff_not_iff /-\ntheorem xor_iff_not_iff (P Q : Prop) : Xor' P Q ↔ ¬(P ↔ Q) :=\n  (not_xor P Q).not_right\n#align xor_iff_not_iff xor_iff_not_iff\n-/\n\n",
 "xor_iff_iff_not":
 "#print xor_iff_iff_not /-\ntheorem xor_iff_iff_not : Xor' a b ↔ (a ↔ ¬b) := by simp only [← @xor_not_right a, not_not]\n#align xor_iff_iff_not xor_iff_iff_not\n-/\n\n",
 "xor_false":
 "#print xor_false /-\n@[simp]\ntheorem xor_false : Xor' false = id :=\n  funext fun a => by simp [Xor']\n#align xor_false xor_false\n-/\n\n",
 "xor_comm":
 "#print xor_comm /-\ntheorem xor_comm (a b) : Xor' a b ↔ Xor' b a :=\n  or_comm' _ _\n#align xor_comm xor_comm\n-/\n\n",
 "unique₂":
 "#print ExistsUnique.unique₂ /-\ntheorem ExistsUnique.unique₂ {α : Sort _} {p : α → Sort _} [∀ x, subsingleton (p x)] {q : ∀ (x : α) (hx : p x), Prop}\n    (h : ∃! (x : _)(hx : p x), q x hx) {y₁ y₂ : α} (hpy₁ : p y₁) (hqy₁ : q y₁ hpy₁) (hpy₂ : p y₂) (hqy₂ : q y₂ hpy₂) :\n    y₁ = y₂ := by\n  simp only [exists_unique_iff_exists] at h\n  exact h.unique ⟨hpy₁, hqy₁⟩ ⟨hpy₂, hqy₂⟩\n#align exists_unique.unique2 ExistsUnique.unique₂\n-/\n\n",
 "unique":
 "theorem exists_unique.unique {α : Sort _} {p : α → Prop} (h : ∃! x, p x) {y₁ y₂ : α} (py₁ : p y₁) (py₂ : p y₂) :\n    y₁ = y₂ :=\n  ExistsUnique.unique h py₁ py₂\n#align exists_unique.unique exists_unique.unique\n\n",
 "swap":
 "#print imp.swap /-\ntheorem imp.swap : a → b → c ↔ b → a → c :=\n  ⟨swap, swap⟩\n#align imp.swap imp.swap\n-/\n\n",
 "subsingleton_of_forall_eq":
 "#print subsingleton_of_forall_eq /-\n/-- If all points are equal to a given point `x`, then `α` is a subsingleton. -/\ntheorem subsingleton_of_forall_eq {α : Sort _} (x : α) (h : ∀ y, y = x) : subsingleton α :=\n  ⟨fun a b => (h a).symm ▸ (h b).symm ▸ rfl⟩\n#align subsingleton_of_forall_eq subsingleton_of_forall_eq\n-/\n\n",
 "subsingleton_iff_forall_eq":
 "#print subsingleton_iff_forall_eq /-\ntheorem subsingleton_iff_forall_eq {α : Sort _} (x : α) : subsingleton α ↔ ∀ y, y = x :=\n  ⟨fun h y => @subsingleton.elim _ h y x, subsingleton_of_forall_eq x⟩\n#align subsingleton_iff_forall_eq subsingleton_iff_forall_eq\n-/\n\n",
 "some_spec2":
 "-- use shortened names to avoid conflict when classical namespace is open.\ntheorem some_spec2 {α : Sort _} {p : α → Prop} {h : ∃ a, p a} (q : α → Prop) (hpq : ∀ a, p a → q a) : q (choose h) :=\n  hpq _ <| choose_spec _\n#align some_spec2 some_spec2\n\n",
 "snd":
 "#print Exists.snd /-\ntheorem Exists.snd {p : b → Prop} : ∀ h : Exists p, p h.fst\n  | ⟨_, h⟩ => h\n#align Exists.snd Exists.snd\n-/\n\n",
 "rotate":
 "theorem or.rotate : a ∨ b ∨ c → b ∨ c ∨ a :=\n  or_rotate.1\n#align or.rotate or.rotate\n\n",
 "rec_heq_of_heq":
 "#print rec_heq_of_heq /-\ntheorem rec_heq_of_heq {β} {C : α → Sort _} {x : C a} {y : β} (eq : a = b) (h : HEq x y) :\n    HEq (@eq.rec α a C x b eq) y := by subst eq <;> exact h\n#align rec_heq_of_heq rec_heq_of_heq\n-/\n\n",
 "proof_irrel_heq":
 "#print proof_irrel_heq /-\ntheorem proof_irrel_heq {p q : Prop} (hp : p) (hq : q) : HEq hp hq :=\n  by\n  have : p = q := propext ⟨fun _ => hq, fun _ => hp⟩\n  subst q <;> rfl\n#align proof_irrel_heq proof_irrel_heq\n-/\n\n",
 "pi_congr":
 "#print pi_congr /-\ntheorem pi_congr {β' : α → Sort _} (h : ∀ a, β a = β' a) : (∀ a, β a) = ∀ a, β' a :=\n  (funext h : β = β') ▸ rfl\n#align pi_congr pi_congr\n-/\n\n",
 "peirce'":
 "#print peirce' /-\ntheorem peirce' {a : Prop} (H : ∀ b : Prop, (a → b) → a) : a :=\n  H _ id\n#align peirce' peirce'\n-/\n\n",
 "peirce":
 "#print peirce /-\ntheorem peirce (a b : Prop) : ((a → b) → a) → a :=\n  decidable.peirce _ _\n#align peirce peirce\n-/\n\n",
 "or_self_right":
 "#print or_self_right /-\n@[simp]\ntheorem or_self_right : (a ∨ b) ∨ b ↔ a ∨ b :=\n  ⟨fun h => h.elim id or.inr, fun h => h.elim (or.inl ∘ or.inl) or.inr⟩\n#align or_self_right or_self_right\n-/\n\n",
 "or_self_left":
 "#print or_self_left /-\n@[simp]\ntheorem or_self_left : a ∨ a ∨ b ↔ a ∨ b :=\n  ⟨fun h => h.elim or.inl id, fun h => h.elim or.inl (or.inr ∘ or.inr)⟩\n#align or_self_left or_self_left\n-/\n\n",
 "or_rotate":
 "#print or_rotate /-\ntheorem or_rotate : a ∨ b ∨ c ↔ b ∨ c ∨ a := by simp only [or_left_comm, or_comm]\n#align or_rotate or_rotate\n-/\n\n",
 "or_right_comm":
 "#print or_right_comm /-\ntheorem or_right_comm : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b := by rw [or_assoc', or_assoc', or_comm' b]\n#align or.right_comm or_right_comm\n-/\n\n",
 "or_or_or_comm":
 "#print or_or_or_comm /-\ntheorem or_or_or_comm (a b c d : Prop) : (a ∨ b) ∨ c ∨ d ↔ (a ∨ c) ∨ b ∨ d := by\n  rw [← or_assoc', @or_right_comm a, or_assoc']\n#align or_or_or_comm or_or_or_comm\n-/\n\n",
 "or_or_distrib_right":
 "#print or_or_distrib_right /-\ntheorem or_or_distrib_right (a b c : Prop) : (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b ∨ c := by rw [or_or_or_comm, or_self_iff]\n#align or_or_distrib_right or_or_distrib_right\n-/\n\n",
 "or_or_distrib_left":
 "#print or_or_distrib_left /-\ntheorem or_or_distrib_left (a b c : Prop) : a ∨ b ∨ c ↔ (a ∨ b) ∨ a ∨ c := by rw [or_or_or_comm, or_self_iff]\n#align or_or_distrib_left or_or_distrib_left\n-/\n\n",
 "or_of_or_of_imp_right":
 "#print or_of_or_of_imp_right /-\ntheorem or_of_or_of_imp_right (h₁ : c ∨ a) (h : a → b) : c ∨ b :=\n  or.imp_right h h₁\n#align or_of_or_of_imp_right or_of_or_of_imp_right\n-/\n\n",
 "or_of_or_of_imp_of_imp":
 "#print or_of_or_of_imp_of_imp /-\ntheorem or_of_or_of_imp_of_imp (h₁ : a ∨ b) (h₂ : a → c) (h₃ : b → d) : c ∨ d :=\n  Or.imp h₂ h₃ h₁\n#align or_of_or_of_imp_of_imp or_of_or_of_imp_of_imp\n-/\n\n",
 "or_of_or_of_imp_left":
 "#print or_of_or_of_imp_left /-\ntheorem or_of_or_of_imp_left (h₁ : a ∨ c) (h : a → b) : b ∨ c :=\n  or.imp_left h h₁\n#align or_of_or_of_imp_left or_of_or_of_imp_left\n-/\n\n",
 "or_not_of_imp":
 "#print or_not_of_imp /-\ntheorem or_not_of_imp : (a → b) → b ∨ ¬a :=\n  decidable.or_not_of_imp\n#align or_not_of_imp or_not_of_imp\n-/\n\n",
 "or_not":
 "#print or_not /-\ntheorem or_not {p : Prop} : p ∨ ¬p :=\n  em _\n#align or_not or_not\n-/\n\n",
 "or_imp":
 "#print or_imp /-\ntheorem or_imp : a ∨ b → c ↔ (a → c) ∧ (b → c) :=\n  ⟨fun h => ⟨fun ha => h (or.inl ha), fun hb => h (or.inr hb)⟩, fun ⟨ha, hb⟩ => or.rec ha hb⟩\n#align or_imp_distrib or_imp\n-/\n\n",
 "or_iff_right_iff_imp":
 "#print or_iff_right_iff_imp /-\n@[simp]\ntheorem or_iff_right_iff_imp : (a ∨ b ↔ b) ↔ a → b := by rw [or_comm', or_iff_left_iff_imp]\n#align or_iff_right_iff_imp or_iff_right_iff_imp\n-/\n\n",
 "or_iff_right":
 "#print or_iff_right /-\ntheorem or_iff_right (ha : ¬a) : a ∨ b ↔ b :=\n  ⟨fun h => h.resolve_left ha, or.inr⟩\n#align or_iff_right or_iff_right\n-/\n\n",
 "or_iff_not_imp_right":
 "#print or_iff_not_imp_right /-\ntheorem or_iff_not_imp_right : a ∨ b ↔ ¬b → a :=\n  Decidable.or_iff_not_imp_right\n#align or_iff_not_imp_right or_iff_not_imp_right\n-/\n\n",
 "or_iff_not_imp_left":
 "#print or_iff_not_imp_left /-\ntheorem or_iff_not_imp_left : a ∨ b ↔ ¬a → b :=\n  decidable.or_iff_not_imp_left\n#align or_iff_not_imp_left or_iff_not_imp_left\n-/\n\n",
 "or_iff_not_and_not":
 "#print or_iff_not_and_not /-\ntheorem or_iff_not_and_not : a ∨ b ↔ ¬(¬a ∧ ¬b) :=\n  decidable.or_iff_not_and_not\n#align or_iff_not_and_not or_iff_not_and_not\n-/\n\n",
 "or_iff_left_iff_imp":
 "#print or_iff_left_iff_imp /-\n@[simp]\ntheorem or_iff_left_iff_imp : (a ∨ b ↔ a) ↔ b → a :=\n  ⟨fun h hb => h.1 (or.inr hb), or_iff_left_of_imp⟩\n#align or_iff_left_iff_imp or_iff_left_iff_imp\n-/\n\n",
 "or_iff_left":
 "theorem or_iff_left (hb : ¬b) : a ∨ b ↔ a :=\n  ⟨fun h => h.resolve_right hb, or.inl⟩\n#align or_iff_left or_iff_leftₓ\n\n",
 "or_congr_right'":
 "theorem or_congr_right' (h : ¬a → (b ↔ c)) : a ∨ b ↔ a ∨ c :=\n  Decidable.or_congr_right' h\n#align or_congr_right or_congr_right'ₓ\n\n",
 "or_congr_right":
 "theorem or_congr_right (h : b ↔ c) : a ∨ b ↔ a ∨ c :=\n  iff.rfl.or h\n#align or_congr_right' or_congr_rightₓ\n\n",
 "or_congr_left'":
 "#print or_congr_left' /-\ntheorem or_congr_left' (h : ¬c → (a ↔ b)) : a ∨ c ↔ b ∨ c :=\n  Decidable.or_congr_left' h\n#align or_congr_left or_congr_left'\n-/\n\n",
 "or_congr_left":
 "#print or_congr_left /-\ntheorem or_congr_left (h : a ↔ b) : a ∨ c ↔ b ∨ c :=\n  h.or iff.rfl\n#align or_congr_left' or_congr_left\n-/\n\n",
 "or_and_right":
 "#print or_and_right /-\n/-- `∧` distributes over `∨` (on the right). -/\ntheorem or_and_right : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c :=\n  (and_comm.trans and_or_left).trans (and_comm.or and_comm)\n#align or_and_distrib_right or_and_right\n-/\n\n",
 "or_and_left":
 "#print or_and_left /-\n/-- `∨` distributes over `∧` (on the left). -/\ntheorem or_and_left : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c) :=\n  ⟨or.rec (fun ha => and.intro (or.inl ha) (or.inl ha)) (and.imp or.inr or.inr),\n    and.rec <| or.rec (imp_intro ∘ or.inl) (or.imp_right ∘ and.intro)⟩\n#align or_and_distrib_left or_and_left\n-/\n\n",
 "or":
 "theorem iff.or (h₁ : a ↔ b) (h₂ : c ↔ d) : a ∨ c ↔ b ∨ d :=\n  or_congr h₁ h₂\n#align iff.or iff.or\n\n",
 "of_not_not":
 "#print of_not_not /-\ntheorem of_not_not : ¬¬a → a :=\n  by_contra\n#align of_not_not of_not_not\n-/\n\n",
 "of_not_imp":
 "#print of_not_imp /-\ntheorem of_not_imp : ¬(a → b) → a :=\n  decidable.of_not_imp\n#align of_not_imp of_not_imp\n-/\n\n",
 "not_xor":
 "#print not_xor /-\n@[simp]\ntheorem not_xor (P Q : Prop) : ¬Xor' P Q ↔ (P ↔ Q) := by\n  simp only [not_and, Xor', not_or, not_not, ← iff_iff_implies_and_implies]\n#align not_xor not_xor\n-/\n\n",
 "not_right":
 "theorem iff.not_right (h : ¬a ↔ b) : a ↔ ¬b :=\n  not_not.symm.trans h.not\n#align iff.not_right iff.not_right\n\n",
 "not_or_of_imp":
 "#print not_or_of_imp /-\ntheorem not_or_of_imp : (a → b) → ¬a ∨ b :=\n  decidable.not_or_of_imp\n#align not_or_of_imp not_or_of_imp\n-/\n\n",
 "not_or":
 "#print not_or /-\n/-- One of de Morgan's laws: the negation of a disjunction is logically equivalent to the\nconjunction of the negations. -/\ntheorem not_or : ¬(a ∨ b) ↔ ¬a ∧ ¬b :=\n  or_imp\n#align not_or_distrib not_or\n-/\n\n",
 "not_of_not_imp":
 "#print not_of_not_imp /-\ntheorem not_of_not_imp {a : Prop} : ¬(a → b) → ¬b :=\n  mt imp_intro\n#align not_of_not_imp not_of_not_imp\n-/\n\n",
 "not_not_of_not_imp":
 "#print not_not_of_not_imp /-\ntheorem not_not_of_not_imp : ¬(a → b) → ¬¬a :=\n  mt not.elim\n#align not_not_of_not_imp not_not_of_not_imp\n-/\n\n",
 "not_not":
 "#print not_not /-\n/-- The Double Negation Theorem: `¬ ¬ P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. -/\n@[simp]\ntheorem not_not : ¬¬a ↔ a :=\n  decidable.not_not\n#align not_not not_not\n-/\n\n",
 "not_nonempty_pempty":
 "#print not_nonempty_pempty /-\n@[simp]\ntheorem not_nonempty_pempty : ¬nonempty PEmpty := fun ⟨h⟩ => h.elim\n#align not_nonempty_pempty not_nonempty_pempty\n-/\n\n",
 "not_ne_iff":
 "#print not_ne_iff /-\ntheorem not_ne_iff {α : Sort _} {a b : α} : ¬a ≠ b ↔ a = b :=\n  not_not\n#align not_ne_iff not_ne_iff\n-/\n\n",
 "not_left":
 "theorem iff.not_left (h : a ↔ ¬b) : ¬a ↔ b :=\n  h.not.trans not_not\n#align iff.not_left iff.not_left\n\n",
 "not_imp_symm":
 "-- See Note [decidable namespace]\nprotected theorem decidable.not_imp_symm [decidable a] (h : ¬a → b) (hb : ¬b) : a :=\n  decidable.by_contradiction <| hb ∘ h\n#align decidable.not_imp_symm decidable.not_imp_symm\n\n",
 "not_imp_self":
 "#print not_imp_self /-\n@[simp]\ntheorem not_imp_self : ¬a → a ↔ a :=\n  decidable.not_imp_self\n#align not_imp_self not_imp_self\n-/\n\n",
 "not_imp_of_and_not":
 "#print not_imp_of_and_not /-\ntheorem not_imp_of_and_not : a ∧ ¬b → ¬(a → b)\n  | ⟨ha, hb⟩, h => hb <| h ha\n#align not_imp_of_and_not not_imp_of_and_not\n-/\n\n",
 "not_imp_not":
 "#print not_imp_not /-\ntheorem not_imp_not : ¬a → ¬b ↔ b → a :=\n  decidable.not_imp_not\n#align not_imp_not not_imp_not\n-/\n\n",
 "not_imp_comm":
 "#print not_imp_comm /-\ntheorem not_imp_comm : ¬a → b ↔ ¬b → a :=\n  decidable.not_imp_comm\n#align not_imp_comm not_imp_comm\n-/\n\n",
 "not_imp":
 "#print not_imp /-\ntheorem not_imp : ¬(a → b) ↔ a ∧ ¬b :=\n  decidable.not_imp\n#align not_imp not_imp\n-/\n\n",
 "not_iff_not":
 "#print not_iff_not /-\ntheorem not_iff_not : (¬a ↔ ¬b) ↔ (a ↔ b) :=\n  decidable.not_iff_not\n#align not_iff_not not_iff_not\n-/\n\n",
 "not_iff_comm":
 "#print not_iff_comm /-\ntheorem not_iff_comm : (¬a ↔ b) ↔ (¬b ↔ a) :=\n  decidable.not_iff_comm\n#align not_iff_comm not_iff_comm\n-/\n\n",
 "not_iff":
 "#print not_iff /-\ntheorem not_iff : ¬(a ↔ b) ↔ (¬a ↔ b) :=\n  decidable.not_iff\n#align not_iff not_iff\n-/\n\n",
 "not_forall_of_exists_not":
 "#print not_forall_of_exists_not /-\ntheorem not_forall_of_exists_not : (∃ x, ¬p x) → ¬∀ x, p x\n  | ⟨x, hn⟩, h => hn (h x)\n#align not_forall_of_exists_not not_forall_of_exists_not\n-/\n\n",
 "not_forall_not":
 "#print not_forall_not /-\ntheorem not_forall_not : (¬∀ x, ¬p x) ↔ ∃ x, p x :=\n  decidable.not_forall_not\n#align not_forall_not not_forall_not\n-/\n\n",
 "not_forall":
 "#print not_forall /-\n@[simp]\ntheorem not_forall {p : α → Prop} : (¬∀ x, p x) ↔ ∃ x, ¬p x :=\n  decidable.not_forall\n#align not_forall not_forall\n-/\n\n",
 "not_exists_of_forall_not":
 "#print not_exists_of_forall_not /-\n--theorem forall_not_of_not_exists (h : ¬ ∃ x, p x) : ∀ x, ¬ p x :=\n--forall_imp_of_exists_imp h\ntheorem not_exists_of_forall_not (h : ∀ x, ¬p x) : ¬∃ x, p x :=\n  exists_imp.2 h\n#align not_exists_of_forall_not not_exists_of_forall_not\n-/\n\n",
 "not_exists_not":
 "#print not_exists_not /-\n@[simp]\ntheorem not_exists_not : (¬∃ x, ¬p x) ↔ ∀ x, p x :=\n  decidable.not_exists_not\n#align not_exists_not not_exists_not\n-/\n\n",
 "not_exists":
 "#print not_exists /-\n@[simp]\ntheorem not_exists : (¬∃ x, p x) ↔ ∀ x, ¬p x :=\n  exists_imp\n#align not_exists not_exists\n-/\n\n",
 "not_bex":
 "#print not_bex /-\ntheorem not_bex : (¬∃ x h, P x h) ↔ ∀ x h, ¬P x h :=\n  bex_imp\n#align not_bex not_bex\n-/\n\n",
 "not_ball_of_bex_not":
 "#print not_ball_of_bex_not /-\ntheorem not_ball_of_bex_not : (∃ x h, ¬P x h) → ¬∀ x h, P x h\n  | ⟨x, h, hp⟩, al => hp <| al x h\n#align not_ball_of_bex_not not_ball_of_bex_not\n-/\n\n",
 "not_ball":
 "/- warning: not_ball clashes with classical.not_ball -> not_ball\nCase conversion may be inaccurate. Consider using '#align not_ball not_ballₓ'. -/\n#print not_ball /-\ntheorem not_ball {α : Sort _} {p : α → Prop} {P : ∀ x : α, p x → Prop} : (¬∀ x h, P x h) ↔ ∃ x h, ¬P x h :=\n  _root_.not_ball\n#align not_ball not_ball\n-/\n\n",
 "not_and_self_iff":
 "/- warning: not_and_self_iff clashes with not_and_self -> not_and_self_iff\nCase conversion may be inaccurate. Consider using '#align not_and_self_iff not_and_self_iffₓ'. -/\n#print not_and_self_iff /-\ntheorem not_and_self_iff (a : Prop) : ¬a ∧ a ↔ false :=\n  iff.intro (fun ⟨hna, ha⟩ => hna ha) false.elim\n#align not_and_self_iff not_and_self_iff\n-/\n\n",
 "not_and_or":
 "#print not_and_or /-\n/-- One of de Morgan's laws: the negation of a conjunction is logically equivalent to the\ndisjunction of the negations. -/\ntheorem not_and_or : ¬(a ∧ b) ↔ ¬a ∨ ¬b :=\n  decidable.not_and_distrib\n#align not_and_distrib not_and_or\n-/\n\n",
 "not_and_of_not_right":
 "#print not_and_of_not_right /-\ntheorem not_and_of_not_right (a : Prop) {b : Prop} : ¬b → ¬(a ∧ b) :=\n  mt And.right\n#align not_and_of_not_right not_and_of_not_right\n-/\n\n",
 "not_and_of_not_or_not":
 "#print not_and_of_not_or_not /-\ntheorem not_and_of_not_or_not (h : ¬a ∨ ¬b) : ¬(a ∧ b)\n  | ⟨ha, hb⟩ => or.elim h (absurd ha) (absurd hb)\n#align not_and_of_not_or_not not_and_of_not_or_not\n-/\n\n",
 "not_and_of_not_left":
 "#print not_and_of_not_left /-\ntheorem not_and_of_not_left (b : Prop) : ¬a → ¬(a ∧ b) :=\n  mt And.left\n#align not_and_of_not_left not_and_of_not_left\n-/\n\n",
 "not_and_not_right":
 "#print not_and_not_right /-\ntheorem not_and_not_right : ¬(a ∧ ¬b) ↔ a → b :=\n  decidable.not_and_not_right\n#align not_and_not_right not_and_not_right\n-/\n\n",
 "not_and_distrib'":
 "-- See Note [decidable namespace]\nprotected theorem decidable.not_and_distrib' [decidable b] : ¬(a ∧ b) ↔ ¬a ∨ ¬b :=\n  ⟨fun h => if hb : b then or.inl fun ha => h ⟨ha, hb⟩ else or.inr hb, not_and_of_not_or_not⟩\n#align decidable.not_and_distrib' decidable.not_and_distrib'\n\n",
 "not_and_distrib":
 "-- See Note [decidable namespace]\nprotected theorem decidable.not_and_distrib [decidable a] : ¬(a ∧ b) ↔ ¬a ∨ ¬b :=\n  ⟨fun h => if ha : a then or.inr fun hb => h ⟨ha, hb⟩ else or.inl ha, not_and_of_not_or_not⟩\n#align decidable.not_and_distrib decidable.not_and_distrib\n\n",
 "not_and'":
 "#print not_and' /-\ntheorem not_and' : ¬(a ∧ b) ↔ b → ¬a :=\n  not_and.trans imp_not_comm\n#align not_and' not_and'\n-/\n\n",
 "not_and":
 "#print not_and /-\n@[simp]\ntheorem not_and : ¬(a ∧ b) ↔ a → ¬b :=\n  and_imp\n#align not_and not_and\n-/\n\n",
 "not":
 "theorem iff.not (h : a ↔ b) : ¬a ↔ ¬b :=\n  not_congr h\n#align iff.not iff.not\n\n",
 "ne_or_ne":
 "theorem ne.ne_or_ne {x y : α} (z : α) (h : x ≠ y) : x ≠ z ∨ y ≠ z :=\n  not_and_or.1 <| mt (and_imp.2 eq.substr) h.symm\n#align ne.ne_or_ne ne.ne_or_ne\n\n",
 "ne_or_eq":
 "#print ne_or_eq /-\ntheorem ne_or_eq : x ≠ y ∨ x = y :=\n  em' <| x = y\n#align ne_or_eq ne_or_eq\n-/\n\n",
 "ne_of_not_mem'":
 "/-- **Alias** of `ne_of_mem_of_not_mem'`. -/\ntheorem has_mem.mem.ne_of_not_mem' : a ∈ s → a ∉ t → s ≠ t :=\n  ne_of_mem_of_not_mem'\n#align has_mem.mem.ne_of_not_mem' has_mem.mem.ne_of_not_mem'\n\n",
 "ne_of_not_mem":
 "/-- **Alias** of `ne_of_mem_of_not_mem`. -/\ntheorem has_mem.mem.ne_of_not_mem : a ∈ s → b ∉ s → a ≠ b :=\n  ne_of_mem_of_not_mem\n#align has_mem.mem.ne_of_not_mem has_mem.mem.ne_of_not_mem\n\n",
 "ne_of_mem_of_not_mem'":
 "#print ne_of_mem_of_not_mem' /-\ntheorem ne_of_mem_of_not_mem' (h : a ∈ s) : a ∉ t → s ≠ t :=\n  mt fun e => e ▸ h\n#align ne_of_mem_of_not_mem' ne_of_mem_of_not_mem'\n-/\n\n",
 "ne_of_mem_of_not_mem":
 "#print ne_of_mem_of_not_mem /-\ntheorem ne_of_mem_of_not_mem (h : a ∈ s) : b ∉ s → a ≠ b :=\n  mt fun e => e ▸ h\n#align ne_of_mem_of_not_mem ne_of_mem_of_not_mem\n-/\n\n",
 "ne_of_apply_ne":
 "#print ne_of_apply_ne /-\ntheorem ne_of_apply_ne {α β : Sort _} (f : α → β) {x y : α} (h : f x ≠ f y) : x ≠ y := fun w : x = y =>\n  h (congr_arg f w)\n#align ne_of_apply_ne ne_of_apply_ne\n-/\n\n",
 "ne_comm":
 "#print ne_comm /-\n-- missing [symm] attribute for ne in core.\ntheorem ne_comm {α} {a b : α} : a ≠ b ↔ b ≠ a :=\n  ⟨ne.symm, ne.symm⟩\n#align ne_comm ne_comm\n-/\n\n",
 "ne_and_eq_iff_right":
 "#print ne_and_eq_iff_right /-\ntheorem ne_and_eq_iff_right {α : Sort _} {a b c : α} (h : b ≠ c) : a ≠ b ∧ a = c ↔ a = c :=\n  and_iff_right_of_imp fun h2 => h2.symm ▸ h.symm\n#align ne_and_eq_iff_right ne_and_eq_iff_right\n-/\n\n",
 "mtr":
 "/-- Provide the reverse of modus tollens (`mt`) as dot notation for implications. -/\nprotected theorem function.mtr : (¬a → ¬b) → b → a :=\n  not_imp_not.mp\n#align function.mtr function.mtr\n\n",
 "mt":
 "/-- Provide modus tollens (`mt`) as dot notation for implications. -/\nprotected theorem function.mt : (a → b) → ¬b → ¬a :=\n  mt\n#align function.mt function.mt\n\n",
 "ite_not":
 "#print ite_not /-\n/-- Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. -/\n@[simp]\ntheorem ite_not : ite (¬P) a b = ite P b a :=\n  dite_not P (fun _ => a) fun _ => b\n#align ite_not ite_not\n-/\n\n",
 "ite_ne_right_iff":
 "protected theorem ne.ite_ne_right_iff (h : a ≠ b) : ite P a b ≠ b ↔ P :=\n  ne.dite_ne_right_iff fun _ => h\n#align ne.ite_ne_right_iff ne.ite_ne_right_iff\n\n",
 "ite_ne_left_iff":
 "protected theorem ne.ite_ne_left_iff (h : a ≠ b) : ite P a b ≠ a ↔ ¬P :=\n  ne.dite_ne_left_iff fun _ => h\n#align ne.ite_ne_left_iff ne.ite_ne_left_iff\n\n",
 "ite_ite_comm":
 "#print ite_ite_comm /-\ntheorem ite_ite_comm (h : P → ¬Q) : (if P then a else if Q then b else c) = if Q then b else if P then a else c :=\n  dite_dite_comm P Q h\n#align ite_ite_comm ite_ite_comm\n-/\n\n",
 "ite_eq_right_iff":
 "protected theorem ne.ite_eq_right_iff (h : a ≠ b) : ite P a b = b ↔ ¬P :=\n  ne.dite_eq_right_iff fun _ => h\n#align ne.ite_eq_right_iff ne.ite_eq_right_iff\n\n",
 "ite_eq_or_eq":
 "#print ite_eq_or_eq /-\ntheorem ite_eq_or_eq : ite P a b = a ∨ ite P a b = b :=\n  decidable.by_cases (fun h => or.inl (if_pos h)) fun h => or.inr (if_neg h)\n#align ite_eq_or_eq ite_eq_or_eq\n-/\n\n",
 "ite_eq_left_iff":
 "protected theorem ne.ite_eq_left_iff (h : a ≠ b) : ite P a b = a ↔ P :=\n  ne.dite_eq_left_iff fun _ => h\n#align ne.ite_eq_left_iff ne.ite_eq_left_iff\n\n",
 "ite_eq_iff'":
 "#print ite_eq_iff' /-\ntheorem ite_eq_iff' : ite P a b = c ↔ (P → a = c) ∧ (¬P → b = c) :=\n  dite_eq_iff'\n#align ite_eq_iff' ite_eq_iff'\n-/\n\n",
 "ite_eq_iff":
 "#print ite_eq_iff /-\ntheorem ite_eq_iff : ite P a b = c ↔ P ∧ a = c ∨ ¬P ∧ b = c :=\n  dite_eq_iff.trans <| by rw [exists_prop, exists_prop]\n#align ite_eq_iff ite_eq_iff\n-/\n\n",
 "ite_apply":
 "#print ite_apply /-\n/-- A 'ite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `ite` that applies\neither branch to `a`. -/\ntheorem ite_apply (f g : ∀ a, σ a) (a : α) : (ite P f g) a = ite P (f a) (g a) :=\n  dite_apply P (fun _ => f) (fun _ => g) a\n#align ite_apply ite_apply\n-/\n\n",
 "ite_and":
 "#print ite_and /-\ntheorem ite_and : ite (P ∧ Q) a b = ite P (ite Q a b) b := by by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]\n#align ite_and ite_and\n-/\n\n",
 "intro₂":
 "#print ExistsUnique.intro₂ /-\ntheorem ExistsUnique.intro₂ {α : Sort _} {p : α → Sort _} [∀ x, subsingleton (p x)] {q : ∀ (x : α) (h : p x), Prop}\n    (w : α) (hp : p w) (hq : q w hp) (H : ∀ (y) (hy : p y), q y hy → y = w) : ∃! (x : _)(hx : p x), q x hx :=\n  by\n  simp only [exists_unique_iff_exists]\n  exact exists_unique.intro w ⟨hp, hq⟩ fun y ⟨hyp, hyq⟩ => H y hyp hyq\n#align exists_unique.intro2 ExistsUnique.intro₂\n-/\n\n",
 "intro":
 "#print BEx.intro /-\ntheorem BEx.intro (a : α) (h₁ : p a) (h₂ : P a h₁) : ∃ (x : _)(h : p x), P x h :=\n  ⟨a, h₁, h₂⟩\n#align bex.intro BEx.intro\n-/\n\n",
 "imp_true_iff":
 "/- warning: imp_true_iff clashes with implies_true_iff -> imp_true_iff\nCase conversion may be inaccurate. Consider using '#align imp_true_iff imp_true_iffₓ'. -/\n#print imp_true_iff /-\ntheorem imp_true_iff {α : Sort _} : α → true ↔ true :=\n  iff_true_intro fun _ => trivial\n#align imp_true_iff imp_true_iff\n-/\n\n",
 "imp_symm":
 "theorem not.imp_symm : (¬a → b) → ¬b → a :=\n  not.decidable_imp_symm\n#align not.imp_symm not.imp_symm\n\n",
 "imp_self":
 "#print imp_self /-\n@[simp]\ntheorem imp_self : a → a ↔ true :=\n  iff_true_intro id\n#align imp_self imp_self\n-/\n\n",
 "imp_right":
 "#print BEx.imp_right /-\ntheorem BEx.imp_right (H : ∀ x h, P x h → Q x h) : (∃ x h, P x h) → ∃ x h, Q x h\n  | ⟨x, h, h'⟩ => ⟨_, _, H _ _ h'⟩\n#align bex.imp_right BEx.imp_right\n-/\n\n",
 "imp_or'":
 "theorem imp_or' : a → b ∨ c ↔ (a → b) ∨ (a → c) :=\n  Decidable.imp_or'\n#align imp_or_distrib' imp_or'ₓ\n\n",
 "imp_or":
 "#print imp_or /-\ntheorem imp_or : a → b ∨ c ↔ (a → b) ∨ (a → c) :=\n  Decidable.imp_or\n#align imp_or_distrib imp_or\n-/\n\n",
 "imp_not_self":
 "#print imp_not_self /-\n@[simp]\ntheorem imp_not_self : a → ¬a ↔ ¬a :=\n  ⟨fun h ha => h ha ha, fun h _ => h⟩\n#align imp_not_self imp_not_self\n-/\n\n",
 "imp_not_comm":
 "#print imp_not_comm /-\ntheorem imp_not_comm : a → ¬b ↔ b → ¬a :=\n  imp.swap\n#align imp_not_comm imp_not_comm\n-/\n\n",
 "imp_left":
 "#print BEx.imp_left /-\ntheorem BEx.imp_left (H : ∀ x, p x → q x) : (∃ (x : _)(_ : p x), r x) → ∃ (x : _)(_ : q x), r x\n  | ⟨x, hp, hr⟩ => ⟨x, H _ hp, hr⟩\n#align bex.imp_left BEx.imp_left\n-/\n\n",
 "imp_intro":
 "#print imp_intro /-\ntheorem imp_intro {α β : Prop} (h : α) : β → α := fun _ => h\n#align imp_intro imp_intro\n-/\n\n",
 "imp_imp_imp":
 "#print imp_imp_imp /-\n-- for monotonicity\ntheorem imp_imp_imp (h₀ : c → a) (h₁ : b → d) : (a → b) → c → d := fun h₂ : a → b => h₁ ∘ h₂ ∘ h₀\n#align imp_imp_imp imp_imp_imp\n-/\n\n",
 "imp_iff_right_iff":
 "#print imp_iff_right_iff /-\n@[simp]\ntheorem imp_iff_right_iff : (a → b ↔ b) ↔ a ∨ b :=\n  decidable.imp_iff_right_iff\n#align imp_iff_right_iff imp_iff_right_iff\n-/\n\n",
 "imp_iff_right":
 "theorem imp_iff_right (ha : a) : a → b ↔ b :=\n  ⟨fun f => f ha, imp_intro⟩\n#align imp_iff_right imp_iff_rightₓ\n\n",
 "imp_iff_or_not":
 "#print imp_iff_or_not /-\ntheorem imp_iff_or_not : b → a ↔ a ∨ ¬b :=\n  Decidable.imp_iff_or_not\n#align imp_iff_or_not imp_iff_or_not\n-/\n\n",
 "imp_iff_not_or":
 "#print imp_iff_not_or /-\ntheorem imp_iff_not_or : a → b ↔ ¬a ∨ b :=\n  decidable.imp_iff_not_or\n#align imp_iff_not_or imp_iff_not_or\n-/\n\n",
 "imp_iff_not":
 "theorem imp_iff_not (hb : ¬b) : a → b ↔ ¬a :=\n  imp_congr_right fun _ => iff_false_intro hb\n#align imp_iff_not imp_iff_notₓ\n\n",
 "imp_forall_iff":
 "#print imp_forall_iff /-\n/-- We intentionally restrict the type of `α` in this lemma so that this is a safer to use in simp\nthan `forall_swap`. -/\ntheorem imp_forall_iff {α : Type _} {p : Prop} {q : α → Prop} : (p → ∀ x, q x) ↔ ∀ x, p → q x :=\n  forall_swap\n#align imp_forall_iff imp_forall_iff\n-/\n\n",
 "imp_false":
 "#print imp_false /-\ntheorem imp_false : a → false ↔ ¬a :=\n  iff.rfl\n#align imp_false imp_false\n-/\n\n",
 "imp_and":
 "#print imp_and /-\ntheorem imp_and {α} : α → b ∧ c ↔ (α → b) ∧ (α → c) :=\n  ⟨fun h => ⟨fun ha => (h ha).left, fun ha => (h ha).right⟩, fun h ha => ⟨h.left ha, h.right ha⟩⟩\n#align imp_and_distrib imp_and\n-/\n\n",
 "imp3":
 "theorem or.imp3 (had : a → d) (hbe : b → e) (hcf : c → f) : a ∨ b ∨ c → d ∨ e ∨ f :=\n  Or.imp had <| Or.imp hbe hcf\n#align or.imp3 or.imp3\n\n",
 "imp'":
 "#print Exists.imp' /-\ntheorem Exists.imp' {p : α → Prop} {q : β → Prop} (f : α → β) (hpq : ∀ a, p a → q (f a)) (hp : ∃ a, p a) : ∃ b, q b :=\n  exists.elim hp fun a hp' => ⟨_, hpq _ hp'⟩\n#align exists_imp_exists' Exists.imp'\n-/\n\n",
 "imp":
 "#print Exists₃.imp /-\ntheorem Exists₃.imp {p q : ∀ a b, γ a b → Prop} (h : ∀ a b c, p a b c → q a b c) :\n    (∃ a b c, p a b c) → ∃ a b c, q a b c :=\n  Exists.imp fun a => Exists₂.imp <| h a\n#align Exists₃.imp Exists₃.imp\n-/\n\n",
 "iff_true_right":
 "#print iff_true_right /-\ntheorem iff_true_right (ha : a) : (b ↔ a) ↔ b :=\n  iff.comm.trans (iff_true_left ha)\n#align iff_true_right iff_true_right\n-/\n\n",
 "iff_true_left":
 "#print iff_true_left /-\ntheorem iff_true_left (ha : a) : (a ↔ b) ↔ b :=\n  ⟨fun h => h.1 ha, iff_of_true ha⟩\n#align iff_true_left iff_true_left\n-/\n\n",
 "iff_self_and":
 "#print iff_self_and /-\n@[simp]\ntheorem iff_self_and {p q : Prop} : (p ↔ p ∧ q) ↔ p → q := by rw [@iff.comm p, and_iff_left_iff_imp]\n#align iff_self_and iff_self_and\n-/\n\n",
 "iff_of_true":
 "#print iff_of_true /-\ntheorem iff_of_true (ha : a) (hb : b) : a ↔ b :=\n  ⟨fun _ => hb, fun _ => ha⟩\n#align iff_of_true iff_of_true\n-/\n\n",
 "iff_of_false":
 "#print iff_of_false /-\ntheorem iff_of_false (ha : ¬a) (hb : ¬b) : a ↔ b :=\n  ⟨ha.elim, hb.elim⟩\n#align iff_of_false iff_of_false\n-/\n\n",
 "iff_of_eq":
 "#print iff_of_eq /-\ntheorem iff_of_eq (e : a = b) : a ↔ b :=\n  e ▸ iff.rfl\n#align iff_of_eq iff_of_eq\n-/\n\n",
 "iff_not_comm":
 "#print iff_not_comm /-\ntheorem iff_not_comm : (a ↔ ¬b) ↔ (b ↔ ¬a) :=\n  decidable.iff_not_comm\n#align iff_not_comm iff_not_comm\n-/\n\n",
 "iff_mpr_iff_true_intro":
 "#print iff_mpr_iff_true_intro /-\n@[simp]\ntheorem iff_mpr_iff_true_intro {P : Prop} (h : P) : Iff.mpr (iff_true_intro h) true.intro = h :=\n  rfl\n#align iff_mpr_iff_true_intro iff_mpr_iff_true_intro\n-/\n\n",
 "iff_iff_not_or_and_or_not":
 "#print iff_iff_not_or_and_or_not /-\ntheorem iff_iff_not_or_and_or_not : (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b) :=\n  decidable.iff_iff_not_or_and_or_not\n#align iff_iff_not_or_and_or_not iff_iff_not_or_and_or_not\n-/\n\n",
 "iff_iff_eq":
 "#print iff_iff_eq /-\ntheorem iff_iff_eq : (a ↔ b) ↔ a = b :=\n  ⟨propext, iff_of_eq⟩\n#align iff_iff_eq iff_iff_eq\n-/\n\n",
 "iff_iff_and_or_not_and_not":
 "#print iff_iff_and_or_not_and_not /-\ntheorem iff_iff_and_or_not_and_not : (a ↔ b) ↔ a ∧ b ∨ ¬a ∧ ¬b :=\n  decidable.iff_iff_and_or_not_and_not\n#align iff_iff_and_or_not_and_not iff_iff_and_or_not_and_not\n-/\n\n",
 "iff_false_right":
 "#print iff_false_right /-\ntheorem iff_false_right (ha : ¬a) : (b ↔ a) ↔ ¬b :=\n  iff.comm.trans (iff_false_left ha)\n#align iff_false_right iff_false_right\n-/\n\n",
 "iff_false_left":
 "#print iff_false_left /-\ntheorem iff_false_left (ha : ¬a) : (a ↔ b) ↔ ¬b :=\n  ⟨fun h => mt h.2 ha, iff_of_false ha⟩\n#align iff_false_left iff_false_left\n-/\n\n",
 "iff_def'":
 "#print iff_def' /-\ntheorem iff_def' : (a ↔ b) ↔ (b → a) ∧ (a → b) :=\n  iff_def.trans and_comm\n#align iff_def' iff_def'\n-/\n\n",
 "iff_def":
 "#print iff_def /-\ntheorem iff_def : (a ↔ b) ↔ (a → b) ∧ (b → a) :=\n  iff_iff_implies_and_implies _ _\n#align iff_def iff_def\n-/\n\n",
 "iff_and_self":
 "#print iff_and_self /-\n@[simp]\ntheorem iff_and_self {p q : Prop} : (p ↔ q ∧ p) ↔ p → q := by rw [and_comm', iff_self_and]\n#align iff_and_self iff_and_self\n-/\n\n",
 "iff":
 "theorem iff.iff (h₁ : a ↔ b) (h₂ : c ↔ d) : (a ↔ c) ↔ (b ↔ d) :=\n  iff_congr h₁ h₂\n#align iff.iff iff.iff\n\n",
 "heq_of_cast_eq":
 "#print heq_of_cast_eq /-\ntheorem heq_of_cast_eq : ∀ {α β : Sort _} {a : α} {a' : β} (e : α = β) (h₂ : cast e a = a'), HEq a a'\n  | α, _, a, a', rfl, h => eq.rec_on h (heq.refl _)\n#align heq_of_cast_eq heq_of_cast_eq\n-/\n\n",
 "heq_iff_eq":
 "#print heq_iff_eq /-\n@[simp]\ntheorem heq_iff_eq : HEq a b ↔ a = b :=\n  ⟨eq_of_heq, heq_of_eq⟩\n#align heq_iff_eq heq_iff_eq\n-/\n\n",
 "funext₃":
 "#print funext₃ /-\ntheorem funext₃ {f g : ∀ a b c, δ a b c} (h : ∀ a b c, f a b c = g a b c) : f = g :=\n  funext fun _ => funext₂ <| h _\n#align funext₃ funext₃\n-/\n\n",
 "funext₂":
 "#print funext₂ /-\ntheorem funext₂ {f g : ∀ a b, γ a b} (h : ∀ a b, f a b = g a b) : f = g :=\n  funext fun _ => funext <| h _\n#align funext₂ funext₂\n-/\n\n",
 "fst":
 "#print Exists.fst /-\ntheorem Exists.fst {p : b → Prop} : Exists p → b\n  | ⟨h, _⟩ => h\n#align Exists.fst Exists.fst\n-/\n\n",
 "forall₅_congr":
 "#print forall₅_congr /-\ntheorem forall₅_congr {p q : ∀ a b c d, ε a b c d → Prop} (h : ∀ a b c d e, p a b c d e ↔ q a b c d e) :\n    (∀ a b c d e, p a b c d e) ↔ ∀ a b c d e, q a b c d e :=\n  forall_congr' fun a => forall₄_congr <| h a\n#align forall₅_congr forall₅_congr\n-/\n\n",
 "forall₄_congr":
 "#print forall₄_congr /-\ntheorem forall₄_congr {p q : ∀ a b c, δ a b c → Prop} (h : ∀ a b c d, p a b c d ↔ q a b c d) :\n    (∀ a b c d, p a b c d) ↔ ∀ a b c d, q a b c d :=\n  forall_congr' fun a => forall₃_congr <| h a\n#align forall₄_congr forall₄_congr\n-/\n\n",
 "forall₃_true_iff":
 "#print forall₃_true_iff /-\n@[simp]\ntheorem forall₃_true_iff {β : α → Sort _} {γ : ∀ a, β a → Sort _} : (∀ (a) (b : β a), γ a b → true) ↔ true :=\n  forall_true_iff' fun _ => forall₂_true_iff\n#align forall_3_true_iff forall₃_true_iff\n-/\n\n",
 "forall₃_imp":
 "#print forall₃_imp /-\ntheorem forall₃_imp {p q : ∀ a b, γ a b → Prop} (h : ∀ a b c, p a b c → q a b c) :\n    (∀ a b c, p a b c) → ∀ a b c, q a b c :=\n  forall_imp fun a => forall₂_imp <| h a\n#align forall₃_imp forall₃_imp\n-/\n\n",
 "forall₃_congr":
 "#print forall₃_congr /-\ntheorem forall₃_congr {p q : ∀ a b, γ a b → Prop} (h : ∀ a b c, p a b c ↔ q a b c) :\n    (∀ a b c, p a b c) ↔ ∀ a b c, q a b c :=\n  forall_congr' fun a => forall₂_congr <| h a\n#align forall₃_congr forall₃_congr\n-/\n\n",
 "forall₂_true_iff":
 "#print forall₂_true_iff /-\n@[simp]\ntheorem forall₂_true_iff {β : α → Sort _} : (∀ a, β a → true) ↔ true :=\n  forall_true_iff' fun _ => forall_true_iff\n#align forall_2_true_iff forall₂_true_iff\n-/\n\n",
 "forall₂_swap":
 "#print forall₂_swap /-\ntheorem forall₂_swap {ι₁ ι₂ : Sort _} {κ₁ : ι₁ → Sort _} {κ₂ : ι₂ → Sort _} {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} :\n    (∀ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∀ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂ :=\n  ⟨swap₂, swap₂⟩\n#align forall₂_swap forall₂_swap\n-/\n\n",
 "forall₂_imp":
 "#print forall₂_imp /-\ntheorem forall₂_imp {p q : ∀ a, β a → Prop} (h : ∀ a b, p a b → q a b) : (∀ a b, p a b) → ∀ a b, q a b :=\n  forall_imp fun i => forall_imp <| h i\n#align forall₂_imp forall₂_imp\n-/\n\n",
 "forall₂_congr":
 "#print forall₂_congr /-\ntheorem forall₂_congr {p q : ∀ a, β a → Prop} (h : ∀ a b, p a b ↔ q a b) : (∀ a b, p a b) ↔ ∀ a b, q a b :=\n  forall_congr' fun a => forall_congr' <| h a\n#align forall₂_congr forall₂_congr\n-/\n\n",
 "forall_true_left":
 "#print forall_true_left /-\n/-- See `is_empty.forall_iff` for the `false` version. -/\n@[simp]\ntheorem forall_true_left (p : true → Prop) : (∀ x, p x) ↔ p true.intro :=\n  forall_prop_of_true _\n#align forall_true_left forall_true_left\n-/\n\n",
 "forall_true_iff'":
 "#print forall_true_iff' /-\n-- Unfortunately this causes simp to loop sometimes, so we\n-- add the 2 and 3 cases as simp lemmas instead\ntheorem forall_true_iff' (h : ∀ a, p a ↔ true) : (∀ a, p a) ↔ true :=\n  iff_true_intro fun _ => of_iff_true (h _)\n#align forall_true_iff' forall_true_iff'\n-/\n\n",
 "forall_true_iff":
 "#print forall_true_iff /-\n-- TODO: duplicate of a lemma in core\ntheorem forall_true_iff : α → true ↔ true :=\n  imp_true_iff α\n#align forall_true_iff forall_true_iff\n-/\n\n",
 "forall_swap":
 "#print forall_swap /-\ntheorem forall_swap {p : α → β → Prop} : (∀ x y, p x y) ↔ ∀ y x, p x y :=\n  ⟨swap, swap⟩\n#align forall_swap forall_swap\n-/\n\n",
 "forall_prop_of_true":
 "#print forall_prop_of_true /-\ntheorem forall_prop_of_true {p : Prop} {q : p → Prop} (h : p) : (∀ h' : p, q h') ↔ q h :=\n  @forall_const (q h) p ⟨h⟩\n#align forall_prop_of_true forall_prop_of_true\n-/\n\n",
 "forall_prop_of_false":
 "#print forall_prop_of_false /-\ntheorem forall_prop_of_false {p : Prop} {q : p → Prop} (hn : ¬p) : (∀ h' : p, q h') ↔ true :=\n  iff_true_intro fun h => hn.elim h\n#align forall_prop_of_false forall_prop_of_false\n-/\n\n",
 "forall_prop_congr'":
 "#print forall_prop_congr' /-\n@[congr]\ntheorem forall_prop_congr' {p p' : Prop} {q q' : p → Prop} (hq : ∀ h, q h ↔ q' h) (hp : p ↔ p') :\n    (∀ h, q h) = ∀ h : p', q' (hp.2 h) :=\n  propext (forall_prop_congr hq _)\n#align forall_prop_congr' forall_prop_congr'\n-/\n\n",
 "forall_prop_congr":
 "#print forall_prop_congr /-\n@[congr]\ntheorem forall_prop_congr {p p' : Prop} {q q' : p → Prop} (hq : ∀ h, q h ↔ q' h) (hp : p ↔ p') :\n    (∀ h, q h) ↔ ∀ h : p', q' (hp.2 h) :=\n  ⟨fun h1 h2 => (hq _).1 (h1 (hp.2 _)), fun h1 h2 => (hq _).2 (h1 (hp.1 h2))⟩\n#align forall_prop_congr forall_prop_congr\n-/\n\n",
 "forall_or_right":
 "#print forall_or_right /-\ntheorem forall_or_right {q : Prop} {p : α → Prop} : (∀ x, p x ∨ q) ↔ (∀ x, p x) ∨ q :=\n  Decidable.forall_or_right\n#align forall_or_distrib_right forall_or_right\n-/\n\n",
 "forall_or_of_or_forall":
 "#print forall_or_of_or_forall /-\ntheorem forall_or_of_or_forall (h : b ∨ ∀ x, p x) (x) : b ∨ p x :=\n  h.imp_right fun h₂ => h₂ x\n#align forall_or_of_or_forall forall_or_of_or_forall\n-/\n\n",
 "forall_or_left":
 "#print forall_or_left /-\ntheorem forall_or_left {q : Prop} {p : α → Prop} : (∀ x, q ∨ p x) ↔ q ∨ ∀ x, p x :=\n  Decidable.forall_or_left\n#align forall_or_distrib_left forall_or_left\n-/\n\n",
 "forall_of_ball":
 "#print forall_of_ball /-\ntheorem forall_of_ball (H : ∀ x, p x) (h : ∀ x, p x → q x) (x) : q x :=\n  h x <| H x\n#align forall_of_ball forall_of_ball\n-/\n\n",
 "forall_imp_iff_exists_imp":
 "#print forall_imp_iff_exists_imp /-\ntheorem forall_imp_iff_exists_imp [ha : nonempty α] : (∀ x, p x) → b ↔ ∃ x, p x → b :=\n  let ⟨a⟩ := ha\n  ⟨fun h =>\n    not_forall_not.1 fun h' =>\n      by_cases (fun hb : b => h' a fun _ => hb) fun hb => hb <| h fun x => (not_imp.1 (h' x)).1,\n    fun ⟨x, hx⟩ h => hx (h x)⟩\n#align forall_imp_iff_exists_imp forall_imp_iff_exists_imp\n-/\n\n",
 "forall_imp":
 "#print forall_imp /-\ntheorem forall_imp {p q : α → Prop} (h : ∀ a, p a → q a) : (∀ a, p a) → ∀ a, q a := fun h' a => h a (h' a)\n#align forall_imp forall_imp\n-/\n\n",
 "forall_forall_const":
 "/-- For some reason simp doesn't use `forall_const` to simplify in this case. -/\n@[simp]\ntheorem forall_forall_const {α β : Type _} (p : β → Prop) [nonempty α] : (∀ x, α → p x) ↔ ∀ x, p x :=\n  forall_congr' fun x => forall_const α\n#align forall_forall_const forall_forall_const\n\n",
 "forall_exists_index":
 "#print forall_exists_index /-\n@[simp]\ntheorem forall_exists_index {q : (∃ x, p x) → Prop} : (∀ h, q h) ↔ ∀ (x) (h : p x), q ⟨x, h⟩ :=\n  ⟨fun h x hpx => h ⟨x, hpx⟩, fun h ⟨x, hpx⟩ => h x hpx⟩\n#align forall_exists_index forall_exists_index\n-/\n\n",
 "forall_eq_or_imp":
 "#print forall_eq_or_imp /-\n-- this lemma is needed to simplify the output of `list.mem_cons_iff`\n@[simp]\ntheorem forall_eq_or_imp {a' : α} : (∀ a, a = a' ∨ q a → p a) ↔ p a' ∧ ∀ a, q a → p a := by\n  simp only [or_imp, forall_and, forall_eq]\n#align forall_eq_or_imp forall_eq_or_imp\n-/\n\n",
 "forall_eq_apply_imp_iff'":
 "#print forall_eq_apply_imp_iff' /-\n@[simp]\ntheorem forall_eq_apply_imp_iff' {f : α → β} {p : β → Prop} : (∀ b, ∀ a, b = f a → p b) ↔ ∀ a, p (f a) :=\n  by\n  rw [forall_swap]\n  simp\n#align forall_eq_apply_imp_iff' forall_eq_apply_imp_iff'\n-/\n\n",
 "forall_eq_apply_imp_iff":
 "#print forall_eq_apply_imp_iff /-\n@[simp]\ntheorem forall_eq_apply_imp_iff {f : α → β} {p : β → Prop} : (∀ a, ∀ b, b = f a → p b) ↔ ∀ a, p (f a) := by\n  simp [@eq_comm _ _ (f _)]\n#align forall_eq_apply_imp_iff forall_eq_apply_imp_iff\n-/\n\n",
 "forall_eq'":
 "#print forall_eq' /-\n@[simp]\ntheorem forall_eq' {a' : α} : (∀ a, a' = a → p a) ↔ p a' := by simp [@eq_comm _ a']\n#align forall_eq' forall_eq'\n-/\n\n",
 "forall_eq":
 "#print forall_eq /-\n@[simp]\ntheorem forall_eq {a' : α} : (∀ a, a = a' → p a) ↔ p a' :=\n  ⟨fun h => h a' rfl, fun h a e => e.symm ▸ h⟩\n#align forall_eq forall_eq\n-/\n\n",
 "forall_const":
 "#print forall_const /-\n@[simp]\ntheorem forall_const (α : Sort _) [i : nonempty α] : α → b ↔ b :=\n  ⟨i.elim, fun hb x => hb⟩\n#align forall_const forall_const\n-/\n\n",
 "forall_apply_eq_imp_iff₂":
 "#print forall_apply_eq_imp_iff₂ /-\n@[simp]\ntheorem forall_apply_eq_imp_iff₂ {f : α → β} {p : α → Prop} {q : β → Prop} :\n    (∀ b, ∀ a, p a → f a = b → q b) ↔ ∀ a, p a → q (f a) :=\n  ⟨fun h a ha => h (f a) a ha rfl, fun h b a ha hb => hb ▸ h a ha⟩\n#align forall_apply_eq_imp_iff₂ forall_apply_eq_imp_iff₂\n-/\n\n",
 "forall_apply_eq_imp_iff'":
 "#print forall_apply_eq_imp_iff' /-\n@[simp]\ntheorem forall_apply_eq_imp_iff' {f : α → β} {p : β → Prop} : (∀ b, ∀ a, f a = b → p b) ↔ ∀ a, p (f a) :=\n  by\n  rw [forall_swap]\n  simp\n#align forall_apply_eq_imp_iff' forall_apply_eq_imp_iff'\n-/\n\n",
 "forall_apply_eq_imp_iff":
 "#print forall_apply_eq_imp_iff /-\n@[simp]\ntheorem forall_apply_eq_imp_iff {f : α → β} {p : β → Prop} : (∀ a, ∀ b, f a = b → p b) ↔ ∀ a, p (f a) :=\n  ⟨fun h a => h a (f a) rfl, fun h a b hab => hab ▸ h a⟩\n#align forall_apply_eq_imp_iff forall_apply_eq_imp_iff\n-/\n\n",
 "forall_and":
 "#print forall_and /-\ntheorem forall_and : (∀ x, p x ∧ q x) ↔ (∀ x, p x) ∧ ∀ x, q x :=\n  ⟨fun h => ⟨fun x => (h x).left, fun x => (h x).right⟩, fun ⟨h₁, h₂⟩ x => ⟨h₁ x, h₂ x⟩⟩\n#align forall_and_distrib forall_and\n-/\n\n",
 "false_ne_true":
 "#print false_ne_true /-\ntheorem false_ne_true : false ≠ true\n  | h => h.symm ▸ trivial\n#align false_ne_true false_ne_true\n-/\n\n",
 "fact_iff":
 "#print fact_iff /-\ntheorem fact_iff {p : Prop} : fact p ↔ p :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align fact_iff fact_iff\n-/\n\n",
 "exists₅_congr":
 "#print exists₅_congr /-\ntheorem exists₅_congr {p q : ∀ a b c d, ε a b c d → Prop} (h : ∀ a b c d e, p a b c d e ↔ q a b c d e) :\n    (∃ a b c d e, p a b c d e) ↔ ∃ a b c d e, q a b c d e :=\n  exists_congr fun a => exists₄_congr <| h a\n#align exists₅_congr exists₅_congr\n-/\n\n",
 "exists₄_congr":
 "#print exists₄_congr /-\ntheorem exists₄_congr {p q : ∀ a b c, δ a b c → Prop} (h : ∀ a b c d, p a b c d ↔ q a b c d) :\n    (∃ a b c d, p a b c d) ↔ ∃ a b c d, q a b c d :=\n  exists_congr fun a => exists₃_congr <| h a\n#align exists₄_congr exists₄_congr\n-/\n\n",
 "exists₃_congr":
 "#print exists₃_congr /-\ntheorem exists₃_congr {p q : ∀ a b, γ a b → Prop} (h : ∀ a b c, p a b c ↔ q a b c) :\n    (∃ a b c, p a b c) ↔ ∃ a b c, q a b c :=\n  exists_congr fun a => exists₂_congr <| h a\n#align exists₃_congr exists₃_congr\n-/\n\n",
 "exists₂_congr":
 "#print exists₂_congr /-\ntheorem exists₂_congr {p q : ∀ a, β a → Prop} (h : ∀ a b, p a b ↔ q a b) : (∃ a b, p a b) ↔ ∃ a b, q a b :=\n  exists_congr fun a => exists_congr <| h a\n#align exists₂_congr exists₂_congr\n-/\n\n",
 "exists₂_comm":
 "#print exists₂_comm /-\ntheorem exists₂_comm {ι₁ ι₂ : Sort _} {κ₁ : ι₁ → Sort _} {κ₂ : ι₂ → Sort _} {p : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Prop} :\n    (∃ i₁ j₁ i₂ j₂, p i₁ j₁ i₂ j₂) ↔ ∃ i₂ j₂ i₁ j₁, p i₁ j₁ i₂ j₂ := by simp only [@exists_comm (κ₁ _), @exists_comm ι₁]\n#align exists₂_comm exists₂_comm\n-/\n\n",
 "exists₂":
 "#print ExistsUnique.exists₂ /-\ntheorem ExistsUnique.exists₂ {α : Sort _} {p : α → Sort _} {q : ∀ (x : α) (h : p x), Prop}\n    (h : ∃! (x : _)(hx : p x), q x hx) : ∃ (x : _)(hx : p x), q x hx :=\n  h.exists.imp fun x hx => hx.exists\n#align exists_unique.exists2 ExistsUnique.exists₂\n-/\n\n",
 "exists_unique_prop_of_true":
 "#print exists_unique_prop_of_true /-\ntheorem exists_unique_prop_of_true {p : Prop} {q : p → Prop} (h : p) : (∃! h' : p, q h') ↔ q h :=\n  @exists_unique_const (q h) p ⟨h⟩ _\n#align exists_unique_prop_of_true exists_unique_prop_of_true\n-/\n\n",
 "exists_unique_prop":
 "#print exists_unique_prop /-\ntheorem exists_unique_prop {p q : Prop} : (∃! h : p, q) ↔ p ∧ q := by simp\n#align exists_unique_prop exists_unique_prop\n-/\n\n",
 "exists_unique_iff_exists":
 "#print exists_unique_iff_exists /-\n@[simp]\ntheorem exists_unique_iff_exists {α : Sort _} [subsingleton α] {p : α → Prop} : (∃! x, p x) ↔ ∃ x, p x :=\n  ⟨fun h => h.exists, Exists.imp fun x hx => ⟨hx, fun y _ => subsingleton.elim y x⟩⟩\n#align exists_unique_iff_exists exists_unique_iff_exists\n-/\n\n",
 "exists_unique_false":
 "#print exists_unique_false /-\n@[simp]\ntheorem exists_unique_false : ¬∃! a : α, false := fun ⟨a, h, h'⟩ => h\n#align exists_unique_false exists_unique_false\n-/\n\n",
 "exists_unique_eq'":
 "#print exists_unique_eq' /-\n@[simp]\ntheorem exists_unique_eq' {a' : α} : ∃! a, a' = a := by simp only [exists_unique, and_self_iff, forall_eq', exists_eq']\n#align exists_unique_eq' exists_unique_eq'\n-/\n\n",
 "exists_unique_eq":
 "#print exists_unique_eq /-\n@[simp]\ntheorem exists_unique_eq {a' : α} : ∃! a, a = a' := by\n  simp only [eq_comm, exists_unique, and_self_iff, forall_eq', exists_eq']\n#align exists_unique_eq exists_unique_eq\n-/\n\n",
 "exists_unique_const":
 "#print exists_unique_const /-\ntheorem exists_unique_const (α : Sort _) [i : nonempty α] [subsingleton α] : (∃! x : α, b) ↔ b := by simp\n#align exists_unique_const exists_unique_const\n-/\n\n",
 "exists_true_left":
 "#print exists_true_left /-\n/-- See `is_empty.exists_iff` for the `false` version. -/\n@[simp]\ntheorem exists_true_left (p : true → Prop) : (∃ x, p x) ↔ p true.intro :=\n  exists_prop_of_true _\n#align exists_true_left exists_true_left\n-/\n\n",
 "exists_swap":
 "#print exists_swap /-\ntheorem exists_swap {p : α → β → Prop} : (∃ x y, p x y) ↔ ∃ y x, p x y :=\n  ⟨fun ⟨x, y, h⟩ => ⟨y, x, h⟩, fun ⟨y, x, h⟩ => ⟨x, y, h⟩⟩\n#align exists_swap exists_swap\n-/\n\n",
 "exists_prop_of_true":
 "#print exists_prop_of_true /-\ntheorem exists_prop_of_true {p : Prop} {q : p → Prop} (h : p) : (∃ h' : p, q h') ↔ q h :=\n  @exists_const (q h) p ⟨h⟩\n#align exists_prop_of_true exists_prop_of_true\n-/\n\n",
 "exists_prop_of_false":
 "#print exists_prop_of_false /-\ntheorem exists_prop_of_false {p : Prop} {q : p → Prop} : ¬p → ¬∃ h' : p, q h' :=\n  mt Exists.fst\n#align exists_prop_of_false exists_prop_of_false\n-/\n\n",
 "exists_prop_congr'":
 "#print exists_prop_congr' /-\n@[congr]\ntheorem exists_prop_congr' {p p' : Prop} {q q' : p → Prop} (hq : ∀ h, q h ↔ q' h) (hp : p ↔ p') :\n    Exists q = ∃ h : p', q' (hp.2 h) :=\n  propext (exists_prop_congr hq _)\n#align exists_prop_congr' exists_prop_congr'\n-/\n\n",
 "exists_prop_congr":
 "#print exists_prop_congr /-\n@[congr]\ntheorem exists_prop_congr {p p' : Prop} {q q' : p → Prop} (hq : ∀ h, q h ↔ q' h) (hp : p ↔ p') :\n    Exists q ↔ ∃ h : p', q' (hp.2 h) :=\n  ⟨fun ⟨_, _⟩ => ⟨hp.1 ‹_›, (hq _).1 ‹_›⟩, fun ⟨_, _⟩ => ⟨_, (hq _).2 ‹_›⟩⟩\n#align exists_prop_congr exists_prop_congr\n-/\n\n",
 "exists_prop":
 "#print exists_prop /-\n@[simp]\ntheorem exists_prop {p q : Prop} : (∃ h : p, q) ↔ p ∧ q :=\n  ⟨fun ⟨h₁, h₂⟩ => ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨h₁, h₂⟩⟩\n#align exists_prop exists_prop\n-/\n\n",
 "exists_or_eq_right'":
 "#print exists_or_eq_right' /-\n@[simp]\ntheorem exists_or_eq_right' (y : α) (p : α → Prop) : ∃ x : α, p x ∨ y = x :=\n  ⟨y, or.inr rfl⟩\n#align exists_or_eq_right' exists_or_eq_right'\n-/\n\n",
 "exists_or_eq_right":
 "#print exists_or_eq_right /-\n@[simp]\ntheorem exists_or_eq_right (y : α) (p : α → Prop) : ∃ x : α, p x ∨ x = y :=\n  ⟨y, or.inr rfl⟩\n#align exists_or_eq_right exists_or_eq_right\n-/\n\n",
 "exists_or_eq_left'":
 "#print exists_or_eq_left' /-\n@[simp]\ntheorem exists_or_eq_left' (y : α) (p : α → Prop) : ∃ x : α, y = x ∨ p x :=\n  ⟨y, or.inl rfl⟩\n#align exists_or_eq_left' exists_or_eq_left'\n-/\n\n",
 "exists_or_eq_left":
 "#print exists_or_eq_left /-\n@[simp]\ntheorem exists_or_eq_left (y : α) (p : α → Prop) : ∃ x : α, x = y ∨ p x :=\n  ⟨y, or.inl rfl⟩\n#align exists_or_eq_left exists_or_eq_left\n-/\n\n",
 "exists_or":
 "#print exists_or /-\ntheorem exists_or : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ ∃ x, q x :=\n  ⟨fun ⟨x, hpq⟩ => hpq.elim (fun hpx => or.inl ⟨x, hpx⟩) fun hqx => or.inr ⟨x, hqx⟩, fun hepq =>\n    hepq.elim (fun ⟨x, hpx⟩ => ⟨x, or.inl hpx⟩) fun ⟨x, hqx⟩ => ⟨x, or.inr hqx⟩⟩\n#align exists_or_distrib exists_or\n-/\n\n",
 "exists_of_bex":
 "#print exists_of_bex /-\ntheorem exists_of_bex : (∃ (x : _)(_ : p x), q x) → ∃ x, q x\n  | ⟨x, _, hq⟩ => ⟨x, hq⟩\n#align exists_of_bex exists_of_bex\n-/\n\n",
 "exists_imp":
 "#print exists_imp /-\ntheorem exists_imp : (∃ x, p x) → b ↔ ∀ x, p x → b :=\n  forall_exists_index\n#align exists_imp_distrib exists_imp\n-/\n\n",
 "exists_iff_of_forall":
 "#print exists_iff_of_forall /-\ntheorem exists_iff_of_forall {p : Prop} {q : p → Prop} (h : ∀ h, q h) : (∃ h, q h) ↔ p :=\n  ⟨Exists.fst, fun H => ⟨H, h H⟩⟩\n#align exists_iff_of_forall exists_iff_of_forall\n-/\n\n",
 "exists_false":
 "#print exists_false /-\n@[simp]\ntheorem exists_false : ¬∃ a : α, false := fun ⟨a, h⟩ => h\n#align exists_false exists_false\n-/\n\n",
 "exists_exists_eq_and":
 "#print exists_exists_eq_and /-\n@[simp]\ntheorem exists_exists_eq_and {f : α → β} {p : β → Prop} : (∃ b, (∃ a, f a = b) ∧ p b) ↔ ∃ a, p (f a) :=\n  ⟨fun ⟨b, ⟨a, ha⟩, hb⟩ => ⟨a, ha.symm ▸ hb⟩, fun ⟨a, ha⟩ => ⟨f a, ⟨a, rfl⟩, ha⟩⟩\n#align exists_exists_eq_and exists_exists_eq_and\n-/\n\n",
 "exists_exists_and_eq_and":
 "#print exists_exists_and_eq_and /-\n@[simp]\ntheorem exists_exists_and_eq_and {f : α → β} {p : α → Prop} {q : β → Prop} :\n    (∃ b, (∃ a, p a ∧ f a = b) ∧ q b) ↔ ∃ a, p a ∧ q (f a) :=\n  ⟨fun ⟨b, ⟨a, ha, hab⟩, hb⟩ => ⟨a, ha, hab.symm ▸ hb⟩, fun ⟨a, hp, hq⟩ => ⟨f a, ⟨a, hp, rfl⟩, hq⟩⟩\n#align exists_exists_and_eq_and exists_exists_and_eq_and\n-/\n\n",
 "exists_eq_right_right'":
 "#print exists_eq_right_right' /-\n@[simp]\ntheorem exists_eq_right_right' {a' : α} : (∃ a : α, p a ∧ q a ∧ a' = a) ↔ p a' ∧ q a' :=\n  ⟨fun ⟨_, hp, hq, rfl⟩ => ⟨hp, hq⟩, fun ⟨hp, hq⟩ => ⟨a', hp, hq, rfl⟩⟩\n#align exists_eq_right_right' exists_eq_right_right'\n-/\n\n",
 "exists_eq_right_right":
 "#print exists_eq_right_right /-\n@[simp]\ntheorem exists_eq_right_right {a' : α} : (∃ a : α, p a ∧ q a ∧ a = a') ↔ p a' ∧ q a' :=\n  ⟨fun ⟨_, hp, hq, rfl⟩ => ⟨hp, hq⟩, fun ⟨hp, hq⟩ => ⟨a', hp, hq, rfl⟩⟩\n#align exists_eq_right_right exists_eq_right_right\n-/\n\n",
 "exists_eq_right'":
 "#print exists_eq_right' /-\n@[simp]\ntheorem exists_eq_right' {a' : α} : (∃ a, p a ∧ a' = a) ↔ p a' := by simp [@eq_comm _ a']\n#align exists_eq_right' exists_eq_right'\n-/\n\n",
 "exists_eq_right":
 "#print exists_eq_right /-\n@[simp]\ntheorem exists_eq_right {a' : α} : (∃ a, p a ∧ a = a') ↔ p a' :=\n  (exists_congr fun a => and_comm).trans exists_eq_left\n#align exists_eq_right exists_eq_right\n-/\n\n",
 "exists_eq_left'":
 "#print exists_eq_left' /-\n@[simp]\ntheorem exists_eq_left' {a' : α} : (∃ a, a' = a ∧ p a) ↔ p a' := by simp [@eq_comm _ a']\n#align exists_eq_left' exists_eq_left'\n-/\n\n",
 "exists_eq_left":
 "#print exists_eq_left /-\n@[simp]\ntheorem exists_eq_left {a' : α} : (∃ a, a = a' ∧ p a) ↔ p a' :=\n  ⟨fun ⟨a, e, h⟩ => e ▸ h, fun h => ⟨_, rfl, h⟩⟩\n#align exists_eq_left exists_eq_left\n-/\n\n",
 "exists_eq'":
 "#print exists_eq' /-\n@[simp]\ntheorem exists_eq' {a' : α} : ∃ a, a' = a :=\n  ⟨_, rfl⟩\n#align exists_eq' exists_eq'\n-/\n\n",
 "exists_eq":
 "#print exists_eq /-\ntheorem exists_eq {a' : α} : ∃ a, a = a' :=\n  ⟨_, rfl⟩\n#align exists_eq exists_eq\n-/\n\n",
 "exists_const":
 "#print exists_const /-\n@[simp]\ntheorem exists_const (α : Sort _) [i : nonempty α] : (∃ x : α, b) ↔ b :=\n  ⟨fun ⟨x, h⟩ => h, i.elim exists.intro⟩\n#align exists_const exists_const\n-/\n\n",
 "exists_comm":
 "#print exists_comm /-\ntheorem exists_comm {p : α → β → Prop} : (∃ a b, p a b) ↔ ∃ b a, p a b :=\n  ⟨fun ⟨a, b, h⟩ => ⟨b, a, h⟩, fun ⟨b, a, h⟩ => ⟨a, b, h⟩⟩\n#align exists_comm exists_comm\n-/\n\n",
 "exists_apply_eq_apply'":
 "#print exists_apply_eq_apply' /-\n@[simp]\ntheorem exists_apply_eq_apply' (f : α → β) (a' : α) : ∃ a, f a' = f a :=\n  ⟨a', rfl⟩\n#align exists_apply_eq_apply' exists_apply_eq_apply'\n-/\n\n",
 "exists_apply_eq_apply":
 "#print exists_apply_eq_apply /-\n@[simp]\ntheorem exists_apply_eq_apply (f : α → β) (a' : α) : ∃ a, f a = f a' :=\n  ⟨a', rfl⟩\n#align exists_apply_eq_apply exists_apply_eq_apply\n-/\n\n",
 "exists_and_right":
 "#print exists_and_right /-\n@[simp]\ntheorem exists_and_right {q : Prop} {p : α → Prop} : (∃ x, p x ∧ q) ↔ (∃ x, p x) ∧ q := by simp [and_comm']\n#align exists_and_distrib_right exists_and_right\n-/\n\n",
 "exists_and_left":
 "#print exists_and_left /-\n@[simp]\ntheorem exists_and_left {q : Prop} {p : α → Prop} : (∃ x, q ∧ p x) ↔ q ∧ ∃ x, p x :=\n  ⟨fun ⟨x, hq, hp⟩ => ⟨hq, x, hp⟩, fun ⟨hq, x, hp⟩ => ⟨x, hq, hp⟩⟩\n#align exists_and_distrib_left exists_and_left\n-/\n\n",
 "exists":
 "theorem and.exists {p q : Prop} {f : p ∧ q → Prop} : (∃ h, f h) ↔ ∃ hp hq, f ⟨hp, hq⟩ :=\n  ⟨fun ⟨h, H⟩ => ⟨h.1, h.2, H⟩, fun ⟨hp, hq, H⟩ => ⟨⟨hp, hq⟩, H⟩⟩\n#align and.exists and.exists\n\n",
 "eq_true_iff":
 "theorem eq_true_iff {a : Prop} : (a = true) = a :=\n  have : (a ↔ true) = a := propext (iff_true_iff a)\n  eq.subst (@iff_eq_eq a true) this\n#align eq_true_iff eq_true_iff\n\n",
 "eq_true_eq_id":
 "#print eq_true_eq_id /-\n@[simp]\ntheorem eq_true_eq_id : eq true = id := by\n  funext\n  simp only [true_iff_iff, id.def, iff_self_iff, eq_iff_iff]\n#align eq_true_eq_id eq_true_eq_id\n-/\n\n",
 "eq_rec_constant":
 "#print eq_rec_constant /-\n/-- Transport through trivial families is the identity. -/\n@[simp]\ntheorem eq_rec_constant {α : Sort _} {a a' : α} {β : Sort _} (y : β) (h : a = a') :\n    @eq.rec α a (fun a => β) y a' h = y := by\n  cases h\n  rfl\n#align eq_rec_constant eq_rec_constant\n-/\n\n",
 "eq_or_ne":
 "#print eq_or_ne /-\ntheorem eq_or_ne : x = y ∨ x ≠ y :=\n  em <| x = y\n#align eq_or_ne eq_or_ne\n-/\n\n",
 "eq_mpr_eq_cast":
 "#print eq_mpr_eq_cast /-\n@[simp]\ntheorem eq_mpr_eq_cast {α β : Sort _} (h : α = β) : eq.mpr h = cast h.symm :=\n  rfl\n#align eq_mpr_eq_cast eq_mpr_eq_cast\n-/\n\n",
 "eq_mp_eq_cast":
 "#print eq_mp_eq_cast /-\n@[simp]\ntheorem eq_mp_eq_cast {α β : Sort _} (h : α = β) : eq.mp h = cast h :=\n  rfl\n#align eq_mp_eq_cast eq_mp_eq_cast\n-/\n\n",
 "eq_iff_true_of_subsingleton":
 "#print eq_iff_true_of_subsingleton /-\n/-\nCopyright (c) 2016 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\n/- We add the `inline` attribute to optimize VM computation using these declarations. For example,\n  `if p ∧ q then ... else ...` will not evaluate the decidability of `q` if `p` is false. -/\n@[simp]\ntheorem eq_iff_true_of_subsingleton {α : Sort _} [subsingleton α] (x y : α) : x = y ↔ true := by cc\n#align eq_iff_true_of_subsingleton eq_iff_true_of_subsingleton\n-/\n\n",
 "eq_iff_iff":
 "#print eq_iff_iff /-\n@[simp]\ntheorem eq_iff_iff {p q : Prop} : p = q ↔ (p ↔ q) :=\n  iff_iff_eq.symm\n#align eq_iff_iff eq_iff_iff\n-/\n\n",
 "eq_iff_eq_cancel_right":
 "#print eq_iff_eq_cancel_right /-\n@[simp]\ntheorem eq_iff_eq_cancel_right {a b : α} : (∀ {c}, a = c ↔ b = c) ↔ a = b :=\n  ⟨fun h => by rw [h], fun h a => by rw [h]⟩\n#align eq_iff_eq_cancel_right eq_iff_eq_cancel_right\n-/\n\n",
 "eq_iff_eq_cancel_left":
 "#print eq_iff_eq_cancel_left /-\n@[simp]\ntheorem eq_iff_eq_cancel_left {b c : α} : (∀ {a}, a = b ↔ a = c) ↔ b = c :=\n  ⟨fun h => by rw [← h], fun h a => by rw [h]⟩\n#align eq_iff_eq_cancel_left eq_iff_eq_cancel_left\n-/\n\n",
 "eq_equivalence":
 "#print eq_equivalence /-\ntheorem eq_equivalence : equivalence (@eq α) :=\n  ⟨eq.refl, @eq.symm _, @eq.trans _⟩\n#align eq_equivalence eq_equivalence\n-/\n\n",
 "em'":
 "#print em' /-\ntheorem em' (p : Prop) : ¬p ∨ p :=\n  (em p).swap\n#align em' em'\n-/\n\n",
 "em":
 "#print em /-\ntheorem em (p : Prop) : p ∨ ¬p :=\n  classical.em _\n#align em em\n-/\n\n",
 "elim₂":
 "#print ExistsUnique.elim₂ /-\ntheorem ExistsUnique.elim₂ {α : Sort _} {p : α → Sort _} [∀ x, subsingleton (p x)] {q : ∀ (x) (h : p x), Prop}\n    {b : Prop} (h₂ : ∃! (x : _)(h : p x), q x h)\n    (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b) : b :=\n  by\n  simp only [exists_unique_iff_exists] at h₂\n  apply h₂.elim\n  exact fun x ⟨hxp, hxq⟩ H => h₁ x hxp hxq fun y hyp hyq => H y ⟨hyp, hyq⟩\n#align exists_unique.elim2 ExistsUnique.elim₂\n-/\n\n",
 "elim3":
 "theorem or.elim3 (h : a ∨ b ∨ c) (ha : a → d) (hb : b → d) (hc : c → d) : d :=\n  or.elim h ha fun h₂ => or.elim h₂ hb hc\n#align or.elim3 or.elim3\n\n",
 "elim":
 "#print BEx.elim /-\ntheorem BEx.elim {b : Prop} : (∃ x h, P x h) → (∀ a h, P a h → b) → b\n  | ⟨a, h₁, h₂⟩, h' => h' a h₁ h₂\n#align bex.elim BEx.elim\n-/\n\n",
 "down_injective":
 "theorem plift.down_injective {α : Sort _} : function.injective (@plift.down α)\n  | ⟨a⟩, ⟨b⟩, rfl => rfl\n#align plift.down_injective plift.down_injective\n\n",
 "down_inj":
 "@[simp]\ntheorem plift.down_inj {α : Sort _} {a b : PLift α} : a.down = b.down ↔ a = b :=\n  ⟨fun h => plift.down_injective h, fun h => by rw [h]⟩\n#align plift.down_inj plift.down_inj\n\n",
 "dite_not":
 "#print dite_not /-\n/-- Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches. -/\n@[simp]\ntheorem dite_not (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (fun h => y (not_not_intro h)) x := by\n  by_cases h : P <;> simp [h]\n#align dite_not dite_not\n-/\n\n",
 "dite_ne_right_iff":
 "protected theorem ne.dite_ne_right_iff (h : ∀ h, A h ≠ b) : (dite P A fun _ => b) ≠ b ↔ P :=\n  dite_ne_right_iff.trans <| exists_iff_of_forall h\n#align ne.dite_ne_right_iff ne.dite_ne_right_iff\n\n",
 "dite_ne_left_iff":
 "protected theorem ne.dite_ne_left_iff (h : ∀ h, a ≠ B h) : dite P (fun _ => a) B ≠ a ↔ ¬P :=\n  dite_ne_left_iff.trans <| exists_iff_of_forall h\n#align ne.dite_ne_left_iff ne.dite_ne_left_iff\n\n",
 "dite_eq_right_iff":
 "protected theorem ne.dite_eq_right_iff (h : ∀ h, A h ≠ b) : (dite P A fun _ => b) = b ↔ ¬P :=\n  dite_eq_right_iff.trans <| ⟨fun H h' => h h' (H h'), fun h' H => (h' H).elim⟩\n#align ne.dite_eq_right_iff ne.dite_eq_right_iff\n\n",
 "dite_eq_or_eq":
 "#print dite_eq_or_eq /-\ntheorem dite_eq_or_eq : (∃ h, dite P A B = A h) ∨ ∃ h, dite P A B = B h :=\n  decidable.by_cases (fun h => or.inl ⟨h, dif_pos h⟩) fun h => or.inr ⟨h, dif_neg h⟩\n#align dite_eq_or_eq dite_eq_or_eq\n-/\n\n",
 "dite_eq_left_iff":
 "protected theorem ne.dite_eq_left_iff (h : ∀ h, a ≠ B h) : dite P (fun _ => a) B = a ↔ P :=\n  dite_eq_left_iff.trans <| ⟨fun H => of_not_not fun h' => h h' (H h').symm, fun h H => (H h).elim⟩\n#align ne.dite_eq_left_iff ne.dite_eq_left_iff\n\n",
 "dite_eq_ite":
 "#print dite_eq_ite /-\n/-- A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. -/\n@[simp]\ntheorem dite_eq_ite : (dite P (fun h => a) fun h => b) = ite P a b :=\n  rfl\n#align dite_eq_ite dite_eq_ite\n-/\n\n",
 "dite_eq_iff'":
 "#print dite_eq_iff' /-\ntheorem dite_eq_iff' : dite P A B = c ↔ (∀ h, A h = c) ∧ ∀ h, B h = c :=\n  ⟨fun he => ⟨fun h => (dif_pos h).symm.trans he, fun h => (dif_neg h).symm.trans he⟩, fun he =>\n    (em P).elim (fun h => (dif_pos h).trans <| he.1 h) fun h => (dif_neg h).trans <| he.2 h⟩\n#align dite_eq_iff' dite_eq_iff'\n-/\n\n",
 "dite_eq_iff":
 "#print dite_eq_iff /-\ntheorem dite_eq_iff : dite P A B = c ↔ (∃ h, A h = c) ∨ ∃ h, B h = c := by\n  by_cases P <;> simp [*, exists_prop_of_false not_false]\n#align dite_eq_iff dite_eq_iff\n-/\n\n",
 "dite_dite_comm":
 "#print dite_dite_comm /-\ntheorem dite_dite_comm {B : Q → α} {C : ¬P → ¬Q → α} (h : P → ¬Q) :\n    (if p : P then A p else if q : Q then B q else C p q) = if q : Q then B q else if p : P then A p else C p q :=\n  dite_eq_iff'.2\n    ⟨fun p => by rw [dif_neg (h p), dif_pos p], fun np => by\n      congr\n      funext\n      rw [dif_neg np]⟩\n#align dite_dite_comm dite_dite_comm\n-/\n\n",
 "dite_apply":
 "#print dite_apply /-\n/-- A 'dite' producing a `Pi` type `Π a, σ a`, applied to a value `a : α` is a `dite` that applies\neither branch to `a`. -/\ntheorem dite_apply (f : P → ∀ a, σ a) (g : ¬P → ∀ a, σ a) (a : α) :\n    (dite P f g) a = dite P (fun h => f h a) fun h => g h a := by by_cases h : P <;> simp [h]\n#align dite_apply dite_apply\n-/\n\n",
 "decidable_imp_symm":
 "theorem not.decidable_imp_symm [decidable a] : (¬a → b) → ¬b → a :=\n  decidable.not_imp_symm\n#align not.decidable_imp_symm not.decidable_imp_symm\n\n",
 "dec_em'":
 "#print dec_em' /-\ntheorem dec_em' (p : Prop) [decidable p] : ¬p ∨ p :=\n  (dec_em p).swap\n#align dec_em' dec_em'\n-/\n\n",
 "dec_em":
 "#print dec_em /-\ntheorem dec_em (p : Prop) [decidable p] : p ∨ ¬p :=\n  decidable.em p\n#align dec_em dec_em\n-/\n\n",
 "congr_right":
 "theorem eq.congr_right {x y z : α} (h : x = y) : z = x ↔ z = y := by rw [h]\n#align eq.congr_right eq.congr_right\n\n",
 "congr_refl_right":
 "#print congr_refl_right /-\n@[simp]\ntheorem congr_refl_right {α β : Sort _} {f g : α → β} (h : f = g) (a : α) : congr h (eq.refl a) = congr_fun h a :=\n  rfl\n#align congr_refl_right congr_refl_right\n-/\n\n",
 "congr_refl_left":
 "#print congr_refl_left /-\n@[simp]\ntheorem congr_refl_left {α β : Sort _} (f : α → β) {a b : α} (h : a = b) : congr (eq.refl f) h = congr_arg f h :=\n  rfl\n#align congr_refl_left congr_refl_left\n-/\n\n",
 "congr_left":
 "theorem eq.congr_left {x y z : α} (h : x = y) : x = z ↔ y = z := by rw [h]\n#align eq.congr_left eq.congr_left\n\n",
 "congr_heq":
 "#print congr_heq /-\ntheorem congr_heq {α β γ : Sort _} {f : α → γ} {g : β → γ} {x : α} {y : β} (h₁ : HEq f g) (h₂ : HEq x y) : f x = g y :=\n  by\n  cases h₂\n  cases h₁\n  rfl\n#align congr_heq congr_heq\n-/\n\n",
 "congr_fun₃":
 "#print congr_fun₃ /-\ntheorem congr_fun₃ {f g : ∀ a b c, δ a b c} (h : f = g) (a : α) (b : β a) (c : γ a b) : f a b c = g a b c :=\n  congr_fun₂ (congr_fun h _) _ _\n#align congr_fun₃ congr_fun₃\n-/\n\n",
 "congr_fun₂":
 "#print congr_fun₂ /-\ntheorem congr_fun₂ {f g : ∀ a b, γ a b} (h : f = g) (a : α) (b : β a) : f a b = g a b :=\n  congr_fun (congr_fun h _) _\n#align congr_fun₂ congr_fun₂\n-/\n\n",
 "congr_fun_rfl":
 "#print congr_fun_rfl /-\n@[simp]\ntheorem congr_fun_rfl {α β : Sort _} (f : α → β) (a : α) : congr_fun (eq.refl f) a = eq.refl (f a) :=\n  rfl\n#align congr_fun_rfl congr_fun_rfl\n-/\n\n",
 "congr_fun_congr_arg":
 "#print congr_fun_congr_arg /-\n@[simp]\ntheorem congr_fun_congr_arg {α β γ : Sort _} (f : α → β → γ) {a a' : α} (p : a = a') (b : β) :\n    congr_fun (congr_arg f p) b = congr_arg (fun a => f a b) p :=\n  rfl\n#align congr_fun_congr_arg congr_fun_congr_arg\n-/\n\n",
 "congr_arg₂":
 "#print congr_arg₂ /-\ntheorem congr_arg₂ {α β γ : Sort _} (f : α → β → γ) {x x' : α} {y y' : β} (hx : x = x') (hy : y = y') :\n    f x y = f x' y' := by\n  subst hx\n  subst hy\n#align congr_arg2 congr_arg₂\n-/\n\n",
 "congr_arg_refl":
 "#print congr_arg_refl /-\n@[simp]\ntheorem congr_arg_refl {α β : Sort _} (f : α → β) (a : α) : congr_arg f (eq.refl a) = eq.refl (f a) :=\n  rfl\n#align congr_arg_refl congr_arg_refl\n-/\n\n",
 "congr_arg_heq":
 "#print congr_arg_heq /-\ntheorem congr_arg_heq {α} {β : α → Sort _} (f : ∀ a, β a) : ∀ {a₁ a₂ : α}, a₁ = a₂ → HEq (f a₁) (f a₂)\n  | a, _, rfl => heq.rfl\n#align congr_arg_heq congr_arg_heq\n-/\n\n",
 "congr":
 "protected theorem eq.congr {x₁ x₂ y₁ y₂ : α} (h₁ : x₁ = y₁) (h₂ : x₂ = y₂) : x₁ = x₂ ↔ y₁ = y₂ :=\n  by\n  subst h₁\n  subst h₂\n#align eq.congr eq.congr\n\n",
 "coe_sort_coe_trans":
 "-- This instance should have low priority, to ensure we follow the chain\n-- `set_like → has_coe_to_sort`\ntheorem coe_sort_coe_trans {α β γ δ} [Coe α β] [has_coe_t_aux β γ] [CoeSort γ δ] (x : α) :\n    @coe_sort α _ _ x = @coe_sort β _ _ x :=\n  rfl\n#align coe_sort_coe_trans coe_sort_coe_trans\n\n",
 "coe_sort_coe_base":
 "@[simp]\ntheorem coe_sort_coe_base {α β γ} [Coe α β] [CoeSort β γ] (x : α) : @coe_sort α _ _ x = @coe_sort β _ _ x :=\n  rfl\n#align coe_sort_coe_base coe_sort_coe_base\n\n",
 "coe_fn_coe_trans'":
 "/-- Non-dependent version of `coe_fn_coe_trans`, helps `rw` figure out the argument. -/\ntheorem coe_fn_coe_trans' {α β γ} {δ : outParam <| _} [Coe α β] [has_coe_t_aux β γ] [CoeFun γ fun _ => δ] (x : α) :\n    @coe_fn α _ _ x = @coe_fn β _ _ x :=\n  rfl\n#align coe_fn_coe_trans' coe_fn_coe_trans'\n\n",
 "coe_fn_coe_trans":
 "theorem coe_fn_coe_trans {α β γ δ} [Coe α β] [has_coe_t_aux β γ] [CoeFun γ δ] (x : α) :\n    @coe_fn α _ _ x = @coe_fn β _ _ x :=\n  rfl\n#align coe_fn_coe_trans coe_fn_coe_trans\n\n",
 "coe_fn_coe_base'":
 "/-- Non-dependent version of `coe_fn_coe_base`, helps `rw` figure out the argument. -/\ntheorem coe_fn_coe_base' {α β} {γ : outParam <| _} [Coe α β] [CoeFun β fun _ => γ] (x : α) :\n    @coe_fn α _ _ x = @coe_fn β _ _ x :=\n  rfl\n#align coe_fn_coe_base' coe_fn_coe_base'\n\n",
 "coe_fn_coe_base":
 "@[simp]\ntheorem coe_fn_coe_base {α β γ} [Coe α β] [CoeFun β γ] (x : α) : @coe_fn α _ _ x = @coe_fn β _ _ x :=\n  rfl\n#align coe_fn_coe_base coe_fn_coe_base\n\n",
 "coe_coe":
 "/-- Add an instance to \"undo\" coercion transitivity into a chain of coercions, because\n   most simp lemmas are stated with respect to simple coercions and will not match when\n   part of a chain. -/\n@[simp]\ntheorem coe_coe {α β γ} [Coe α β] [CoeTC β γ] (a : α) : (a : γ) = (a : β) :=\n  rfl\n#align coe_coe coe_coe\n\n",
 "choose_spec":
 "#print Exists.choose_spec /-\n-- This enables projection notation.\n/-- Show that an element extracted from `P : ∃ a, p a` using `P.some` satisfies `p`.\n-/\ntheorem Exists.choose_spec {p : α → Prop} (P : ∃ a, p a) : p P.some :=\n  Classical.choose_spec P\n#align Exists.some_spec Exists.choose_spec\n-/\n\n",
 "cast_eq_iff_heq":
 "#print cast_eq_iff_heq /-\ntheorem cast_eq_iff_heq {α β : Sort _} {a : α} {a' : β} {e : α = β} : cast e a = a' ↔ HEq a a' :=\n  ⟨heq_of_cast_eq _, fun h => by cases h <;> rfl⟩\n#align cast_eq_iff_heq cast_eq_iff_heq\n-/\n\n",
 "cast_cast":
 "#print cast_cast /-\n@[simp]\ntheorem cast_cast : ∀ {α β γ : Sort _} (ha : α = β) (hb : β = γ) (a : α), cast hb (cast ha a) = cast (ha.trans hb) a\n  | _, _, _, rfl, rfl, a => rfl\n#align cast_cast cast_cast\n-/\n\n",
 "cases":
 "theorem cases {p : Prop → Prop} (h1 : p true) (h2 : p false) : ∀ a, p a := fun a => cases_on a h1 h2\n#align cases cases\n\n",
 "by_contradiction":
 "/- warning: by_contradiction clashes with classical.by_contradiction -> by_contradiction\nCase conversion may be inaccurate. Consider using '#align by_contradiction by_contradictionₓ'. -/\n#print by_contradiction /-\ntheorem by_contradiction {p} : (¬p → false) → p :=\n  decidable.by_contradiction\n#align by_contradiction by_contradiction\n-/\n\n",
 "by_contra":
 "#print by_contra /-\n-- alias by_contradiction ← by_contra\ntheorem by_contra {p} : (¬p → false) → p :=\n  decidable.by_contradiction\n#align by_contra by_contra\n-/\n\n",
 "bex_or_left":
 "#print bex_or_left /-\ntheorem bex_or_left : (∃ (x : _)(_ : p x ∨ q x), r x) ↔ (∃ (x : _)(_ : p x), r x) ∨ ∃ (x : _)(_ : q x), r x := by\n  simp only [exists_prop] <;> exact iff.trans (exists_congr fun x => or_and_right) exists_or\n#align bex_or_left_distrib bex_or_left\n-/\n\n",
 "bex_or":
 "#print bex_or /-\ntheorem bex_or : (∃ x h, P x h ∨ Q x h) ↔ (∃ x h, P x h) ∨ ∃ x h, Q x h :=\n  iff.trans (exists_congr fun x => exists_or) exists_or\n#align bex_or_distrib bex_or\n-/\n\n",
 "bex_of_exists":
 "#print bex_of_exists /-\ntheorem bex_of_exists (H : ∀ x, p x) : (∃ x, q x) → ∃ (x : _)(_ : p x), q x\n  | ⟨x, hq⟩ => ⟨x, H x, hq⟩\n#align bex_of_exists bex_of_exists\n-/\n\n",
 "bex_imp":
 "#print bex_imp /-\n@[simp]\ntheorem bex_imp : (∃ x h, P x h) → b ↔ ∀ x h, P x h → b := by simp\n#align bex_imp_distrib bex_imp\n-/\n\n",
 "bex_eq_left":
 "#print bex_eq_left /-\ntheorem bex_eq_left {a : α} : (∃ (x : _)(_ : x = a), p x) ↔ p a := by simp only [exists_prop, exists_eq_left]\n#align bex_eq_left bex_eq_left\n-/\n\n",
 "bex_def":
 "#print bex_def /-\ntheorem bex_def : (∃ (x : _)(h : p x), q x) ↔ ∃ x, p x ∧ q x :=\n  ⟨fun ⟨x, px, qx⟩ => ⟨x, px, qx⟩, fun ⟨x, px, qx⟩ => ⟨x, px, qx⟩⟩\n#align bex_def bex_def\n-/\n\n",
 "bex_congr":
 "#print bex_congr /-\ntheorem bex_congr (H : ∀ x h, P x h ↔ Q x h) : (∃ x h, P x h) ↔ ∃ x h, Q x h :=\n  exists_congr fun x => exists_congr (H x)\n#align bex_congr bex_congr\n-/\n\n",
 "ball_true_iff":
 "#print ball_true_iff /-\ntheorem ball_true_iff (p : α → Prop) : (∀ x, p x → true) ↔ true :=\n  iff_true_intro fun h hrx => trivial\n#align ball_true_iff ball_true_iff\n-/\n\n",
 "ball_or_left":
 "#print ball_or_left /-\ntheorem ball_or_left : (∀ x, p x ∨ q x → r x) ↔ (∀ x, p x → r x) ∧ ∀ x, q x → r x :=\n  iff.trans (forall_congr' fun x => or_imp) forall_and\n#align ball_or_left_distrib ball_or_left\n-/\n\n",
 "ball_of_forall":
 "#print ball_of_forall /-\ntheorem ball_of_forall (h : ∀ x, p x) (x) : p x :=\n  h x\n#align ball_of_forall ball_of_forall\n-/\n\n",
 "ball_mem_comm":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a b «expr ∈ » s) -/\n#print ball_mem_comm /-\ntheorem ball_mem_comm {α β} [Membership α β] {s : β} {p : α → α → Prop} :\n    (∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), p a b) ↔ ∀ a b, a ∈ s → b ∈ s → p a b :=\n  ball_cond_comm\n#align ball_mem_comm ball_mem_comm\n-/\n\n",
 "ball_congr":
 "#print ball_congr /-\ntheorem ball_congr (H : ∀ x h, P x h ↔ Q x h) : (∀ x h, P x h) ↔ ∀ x h, Q x h :=\n  forall_congr' fun x => forall_congr' (H x)\n#align ball_congr ball_congr\n-/\n\n",
 "ball_cond_comm":
 "#print ball_cond_comm /-\n-- todo: change name\ntheorem ball_cond_comm {α} {s : α → Prop} {p : α → α → Prop} :\n    (∀ a, s a → ∀ b, s b → p a b) ↔ ∀ a b, s a → s b → p a b :=\n  ⟨fun h a b ha hb => h a ha b hb, fun h a ha b hb => h a b ha hb⟩\n#align ball_cond_comm ball_cond_comm\n-/\n\n",
 "ball_and":
 "#print ball_and /-\ntheorem ball_and : (∀ x h, P x h ∧ Q x h) ↔ (∀ x h, P x h) ∧ ∀ x h, Q x h :=\n  iff.trans (forall_congr' fun x => forall_and) forall_and\n#align ball_and_distrib ball_and\n-/\n\n",
 "apply_ite₂":
 "#print apply_ite₂ /-\n/-- A two-argument function applied to two `ite`s is a `ite` of that two-argument function\napplied to each of the branches. -/\ntheorem apply_ite₂ (f : α → β → γ) (P : Prop) [decidable P] (a b : α) (c d : β) :\n    f (ite P a b) (ite P c d) = ite P (f a c) (f b d) :=\n  apply_dite₂ f P (fun _ => a) (fun _ => b) (fun _ => c) fun _ => d\n#align apply_ite2 apply_ite₂\n-/\n\n",
 "apply_ite":
 "#print apply_ite /-\n/-- A function applied to a `ite` is a `ite` of that function applied to each of the branches. -/\ntheorem apply_ite : f (ite P a b) = ite P (f a) (f b) :=\n  apply_dite f P (fun _ => a) fun _ => b\n#align apply_ite apply_ite\n-/\n\n",
 "apply_dite₂":
 "#print apply_dite₂ /-\n/-- A two-argument function applied to two `dite`s is a `dite` of that two-argument function\napplied to each of the branches. -/\ntheorem apply_dite₂ (f : α → β → γ) (P : Prop) [decidable P] (a : P → α) (b : ¬P → α) (c : P → β) (d : ¬P → β) :\n    f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h) := by\n  by_cases h : P <;> simp [h]\n#align apply_dite2 apply_dite₂\n-/\n\n",
 "apply_dite":
 "#print apply_dite /-\n/-- A function applied to a `dite` is a `dite` of that function applied to each of the branches. -/\ntheorem apply_dite (x : P → α) (y : ¬P → α) : f (dite P x y) = dite P (fun h => f (x h)) fun h => f (y h) := by\n  by_cases h : P <;> simp [h]\n#align apply_dite apply_dite\n-/\n\n",
 "and_self_right":
 "#print and_self_right /-\n@[simp]\ntheorem and_self_right : (a ∧ b) ∧ b ↔ a ∧ b :=\n  ⟨fun h => ⟨h.1.1, h.2⟩, fun h => ⟨⟨h.1, h.2⟩, h.2⟩⟩\n#align and_self_right and_self_right\n-/\n\n",
 "and_self_left":
 "#print and_self_left /-\n@[simp]\ntheorem and_self_left : a ∧ a ∧ b ↔ a ∧ b :=\n  ⟨fun h => ⟨h.1, h.2.2⟩, fun h => ⟨h.1, h.1, h.2⟩⟩\n#align and_self_left and_self_left\n-/\n\n",
 "and_rotate":
 "#print and_rotate /-\ntheorem and_rotate : a ∧ b ∧ c ↔ b ∧ c ∧ a := by simp only [and_left_comm, and_comm]\n#align and_rotate and_rotate\n-/\n\n",
 "and_right_comm":
 "#print and_right_comm /-\ntheorem and_right_comm : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b := by simp only [and_left_comm, and_comm]\n#align and.right_comm and_right_comm\n-/\n\n",
 "and_or_right":
 "#print and_or_right /-\n/-- `∨` distributes over `∧` (on the right). -/\ntheorem and_or_right : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c) :=\n  (or_comm.trans or_and_left).trans (or_comm.and or_comm)\n#align and_or_distrib_right and_or_right\n-/\n\n",
 "and_or_left":
 "#print and_or_left /-\n/-- `∧` distributes over `∨` (on the left). -/\ntheorem and_or_left : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c :=\n  ⟨fun ⟨ha, hbc⟩ => hbc.imp (and.intro ha) (and.intro ha), or.rec (and.imp_right or.inl) (and.imp_right or.inr)⟩\n#align and_or_distrib_left and_or_left\n-/\n\n",
 "and_or_imp":
 "#print and_or_imp /-\n@[simp]\ntheorem and_or_imp : a ∧ b ∨ (a → c) ↔ a → b ∨ c :=\n  decidable.and_or_imp\n#align and_or_imp and_or_imp\n-/\n\n",
 "and_not_self_iff":
 "/- warning: and_not_self_iff clashes with and_not_self -> and_not_self_iff\nCase conversion may be inaccurate. Consider using '#align and_not_self_iff and_not_self_iffₓ'. -/\n#print and_not_self_iff /-\ntheorem and_not_self_iff (a : Prop) : a ∧ ¬a ↔ false :=\n  iff.intro (fun h => h.right h.left) fun h => h.elim\n#align and_not_self_iff and_not_self_iff\n-/\n\n",
 "and_imp":
 "#print and_imp /-\n@[simp]\ntheorem and_imp : a ∧ b → c ↔ a → b → c :=\n  iff.intro (fun h ha hb => h ⟨ha, hb⟩) fun h ⟨ha, hb⟩ => h ha hb\n#align and_imp and_imp\n-/\n\n",
 "and_iff_right_of_imp":
 "#print and_iff_right_of_imp /-\ntheorem and_iff_right_of_imp {a b : Prop} (h : b → a) : a ∧ b ↔ b :=\n  iff.intro And.right fun hb => ⟨h hb, hb⟩\n#align and_iff_right_of_imp and_iff_right_of_imp\n-/\n\n",
 "and_iff_right_iff_imp":
 "#print and_iff_right_iff_imp /-\n@[simp]\ntheorem and_iff_right_iff_imp {a b : Prop} : (a ∧ b ↔ b) ↔ b → a :=\n  ⟨fun h ha => (h.2 ha).1, and_iff_right_of_imp⟩\n#align and_iff_right_iff_imp and_iff_right_iff_imp\n-/\n\n",
 "and_iff_not_or_not":
 "#print and_iff_not_or_not /-\ntheorem and_iff_not_or_not : a ∧ b ↔ ¬(¬a ∨ ¬b) :=\n  decidable.and_iff_not_or_not\n#align and_iff_not_or_not and_iff_not_or_not\n-/\n\n",
 "and_iff_left_of_imp":
 "#print and_iff_left_of_imp /-\ntheorem and_iff_left_of_imp {a b : Prop} (h : a → b) : a ∧ b ↔ a :=\n  iff.intro And.left fun ha => ⟨ha, h ha⟩\n#align and_iff_left_of_imp and_iff_left_of_imp\n-/\n\n",
 "and_iff_left_iff_imp":
 "#print and_iff_left_iff_imp /-\n@[simp]\ntheorem and_iff_left_iff_imp {a b : Prop} : (a ∧ b ↔ a) ↔ a → b :=\n  ⟨fun h ha => (h.2 ha).2, and_iff_left_of_imp⟩\n#align and_iff_left_iff_imp and_iff_left_iff_imp\n-/\n\n",
 "and_forall_ne":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (b «expr ≠ » a) -/\n#print and_forall_ne /-\ntheorem and_forall_ne (a : α) : (p a ∧ ∀ (b) (_ : b ≠ a), p b) ↔ ∀ b, p b :=\n  decidable.and_forall_ne a\n#align and_forall_ne and_forall_ne\n-/\n\n",
 "and_congr_right_iff":
 "#print and_congr_right_iff /-\n@[simp]\ntheorem and_congr_right_iff : (a ∧ b ↔ a ∧ c) ↔ a → (b ↔ c) :=\n  ⟨fun h ha => by simp [ha] at h <;> exact h, and_congr_right⟩\n#align and.congr_right_iff and_congr_right_iff\n-/\n\n",
 "and_congr_right'":
 "theorem and_congr_right' (h : b ↔ c) : a ∧ b ↔ a ∧ c :=\n  iff.rfl.and h\n#align and_congr_right' and_congr_right'ₓ\n\n",
 "and_congr_left_iff":
 "@[simp]\ntheorem and_congr_left_iff : (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b) := by simp only [and_comm, ← and_congr_right_iff]\n#align and.congr_left_iff and_congr_left_iffₓ\n\n",
 "and_congr_left'":
 "#print and_congr_left' /-\ntheorem and_congr_left' (h : a ↔ b) : a ∧ c ↔ b ∧ c :=\n  h.and iff.rfl\n#align and_congr_left' and_congr_left'\n-/\n\n",
 "and_congr_left":
 "theorem and_congr_left (h : c → (a ↔ b)) : a ∧ c ↔ b ∧ c :=\n  and_comm.trans <| (and_congr_right h).trans and_comm\n#align and_congr_left and_congr_leftₓ\n\n",
 "and_and_right":
 "#print and_and_right /-\ntheorem and_and_right (a b c : Prop) : (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b ∧ c := by rw [and_and_and_comm, and_self_iff]\n#align and_and_distrib_right and_and_right\n-/\n\n",
 "and_and_left":
 "#print and_and_left /-\ntheorem and_and_left (a b c : Prop) : a ∧ b ∧ c ↔ (a ∧ b) ∧ a ∧ c := by rw [and_and_and_comm, and_self_iff]\n#align and_and_distrib_left and_and_left\n-/\n\n",
 "and_and_and_comm":
 "#print and_and_and_comm /-\ntheorem and_and_and_comm (a b c d : Prop) : (a ∧ b) ∧ c ∧ d ↔ (a ∧ c) ∧ b ∧ d := by\n  rw [← and_assoc', @and_right_comm a, and_assoc']\n#align and_and_and_comm and_and_and_comm\n-/\n\n",
 "and":
 "theorem iff.and (h₁ : a ↔ b) (h₂ : c ↔ d) : a ∧ c ↔ b ∧ d :=\n  and_congr h₁ h₂\n#align iff.and iff.and\n\n"}