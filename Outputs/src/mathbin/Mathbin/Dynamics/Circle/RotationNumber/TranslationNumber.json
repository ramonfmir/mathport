{"units_semiconj_of_translation_number_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `circle_deg1_lift`. This version uses arguments `f₁ f₂ : circle_deg1_liftˣ`\nto assume that `f₁` and `f₂` are homeomorphisms. -/\ntheorem units_semiconj_of_translation_number_eq {f₁ f₂ : «expr ˣ» CircleDeg1Lift} (h : (exprτ) f₁ = (exprτ) f₂) :\n    ∃ F : CircleDeg1Lift, Semiconj F f₁ f₂ :=\n  haveI :\n    ∀ n : Multiplicative ℤ,\n      (exprτ) ((Units.coeHom _).comp (zpowersHom _ f₁) n) = (exprτ) ((Units.coeHom _).comp (zpowersHom _ f₂) n) :=\n    by\n    intro n\n    simp [h]\n  (semiconj_of_group_action_of_forall_translation_number_eq _ _ this).imp fun F hF => hF (Multiplicative.ofAdd 1)\n#align units_semiconj_of_translation_number_eq units_semiconj_of_translation_number_eq\n\n",
 "units_inv_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem units_inv_apply_apply (f : «expr ˣ» CircleDeg1Lift) (x : exprℝ) : (f⁻¹ : «expr ˣ» CircleDeg1Lift) (f x) = x :=\n  by simp only [← units_coe, ← mul_apply, f.inv_mul, coe_one, id]\n#align units_inv_apply_apply units_inv_apply_apply\n\n",
 "units_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem units_coe (f : «expr ˣ» CircleDeg1Lift) : «expr⇑ » (f : CircleDeg1Lift) = f :=\n  rfl\n#align units_coe units_coe\n\n",
 "units_apply_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem units_apply_inv_apply (f : «expr ˣ» CircleDeg1Lift) (x : exprℝ) : f ((f⁻¹ : «expr ˣ» CircleDeg1Lift) x) = x :=\n  by simp only [← units_coe, ← mul_apply, f.mul_inv, coe_one, id]\n#align units_apply_inv_apply units_apply_inv_apply\n\n",
 "transnum_aux_seq_zero":
 "theorem transnum_aux_seq_zero : f.transnum_aux_seq 0 = f 0 := by simp [transnum_aux_seq]\n#align transnum_aux_seq_zero transnum_aux_seq_zero\n\n",
 "transnum_aux_seq_dist_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem transnum_aux_seq_dist_lt (n : ℕ) : dist (f.transnum_aux_seq n) (f.transnum_aux_seq (n + 1)) < 1 / 2 / 2 ^ n :=\n  by\n  have : 0 < (2 ^ (n + 1) : exprℝ) := pow_pos zero_lt_two _\n  rw [div_div, ← pow_succ, ← abs_of_pos this]\n  replace := abs_pos.2 (ne_of_gt this)\n  convert(div_lt_div_right this).2 ((f ^ 2 ^ n).dist_map_map_zero_lt (f ^ 2 ^ n))\n  simp_rw [transnum_aux_seq, Real.dist_eq]\n  rw [← abs_div, sub_div, pow_succ', pow_succ, ← two_mul, mul_div_mul_left _ _ (two_ne_zero' (exprℝ)), pow_mul, sq,\n    mul_apply]\n#align transnum_aux_seq_dist_lt transnum_aux_seq_dist_lt\n\n",
 "transnum_aux_seq_def":
 "-- TODO: choose two different symbols for `circle_deg1_lift.translation_number` and the future\n-- `circle_mono_homeo.rotation_number`, then make them `localized notation`s\ntheorem transnum_aux_seq_def : f.transnum_aux_seq = fun n : ℕ => (f ^ 2 ^ n) 0 / 2 ^ n :=\n  rfl\n#align transnum_aux_seq_def transnum_aux_seq_def\n\n",
 "translation_number_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n@[simp]\ntheorem translation_number_zpow (f : «expr ˣ» CircleDeg1Lift) : ∀ n : ℤ, (exprτ) (f ^ n : Units _) = n * (exprτ) f\n  | (n : ℕ) => by simp [translation_number_pow f n]\n  | -[n+1] => by\n    simp\n    ring\n#align translation_number_zpow translation_number_zpow\n\n",
 "translation_number_units_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n@[simp]\ntheorem translation_number_units_inv (f : «expr ˣ» CircleDeg1Lift) : (exprτ) ↑f⁻¹ = -(exprτ) f :=\n  eq_neg_iff_add_eq_zero.2 <| by simp [← translation_number_mul_of_commute (Commute.refl _).units_inv_left]\n#align translation_number_units_inv translation_number_units_inv\n\n",
 "translation_number_translate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_translate (x : exprℝ) : (exprτ) (translate <| Multiplicative.ofAdd x) = x :=\n  translationNumber_eq_of_tendsto₀' _ <| by simp [Nat.cast_add_one_ne_zero, mul_div_cancel_left, tendsto_const_nhds]\n#align translation_number_translate translation_number_translate\n\n",
 "translation_number_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n@[simp]\ntheorem translation_number_pow : ∀ n : ℕ, (exprτ) (f ^ n) = n * (exprτ) f\n  | 0 => by simp\n  | n + 1 => by\n    rw [pow_succ', translation_number_mul_of_commute (Commute.pow_self f n), translation_number_pow n, Nat.cast_add_one,\n      add_mul, one_mul]\n#align translation_number_pow translation_number_pow\n\n",
 "translation_number_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n@[simp]\ntheorem translation_number_one : (exprτ) 1 = 0 :=\n  translationNumber_eq_of_tendsto₀ _ <| by simp [tendsto_const_nhds]\n#align translation_number_one translation_number_one\n\n",
 "translation_number_of_map_pow_eq_add_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- If `f^n x - x`, `n > 0`, is an integer number `m` for some point `x`, then\n`τ f = m / n`. On the circle this means that a map with a periodic orbit has\na rational rotation number. -/\ntheorem translation_number_of_map_pow_eq_add_int {x : exprℝ} {n : ℕ} {m : ℤ} (h : (f ^ n) x = x + m) (hn : 0 < n) :\n    (exprτ) f = m / n := by\n  have := (f ^ n).translation_number_of_eq_add_int h\n  rwa [translation_number_pow, mul_comm, ← eq_div_iff] at this\n  exact Nat.cast_ne_zero.2 (ne_of_gt hn)\n#align translation_number_of_map_pow_eq_add_int translation_number_of_map_pow_eq_add_int\n\n",
 "translation_number_of_eq_add_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- If `f x - x` is an integer number `m` for some point `x`, then `τ f = m`.\nOn the circle this means that a map with a fixed point has rotation number zero. -/\ntheorem translation_number_of_eq_add_int {x : exprℝ} {m : ℤ} (h : f x = x + m) : (exprτ) f = m :=\n  le_antisymm (translationNumber_le_of_le_add_int f <| le_of_eq h)\n    (le_translationNumber_of_add_int_le f <| le_of_eq h.symm)\n#align translation_number_of_eq_add_int translation_number_of_eq_add_int\n\n",
 "translation_number_mul_of_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_mul_of_commute {f g : CircleDeg1Lift} (h : Commute f g) :\n    (exprτ) (f * g) = (exprτ) f + (exprτ) g :=\n  by\n  have :\n    tendsto (fun n : ℕ => (fun k => (f ^ k) 0 + (g ^ k) 0) (2 ^ n) / 2 ^ n) at_top (nhds <| (exprτ) f + (exprτ) g) :=\n    (f.tendsto_translation_number_aux.add g.tendsto_translation_number_aux).congr fun n =>\n      (add_div ((f ^ 2 ^ n) 0) ((g ^ 2 ^ n) 0) ((2 : exprℝ) ^ n)).symm\n  refine' tendsto_nhds_unique ((f * g).tendsto_translation_number_of_dist_bounded_aux _ 1 fun n => _) this\n  rw [h.mul_pow, dist_comm]\n  exact le_of_lt ((f ^ n).dist_map_map_zero_lt (g ^ n))\n#align translation_number_mul_of_commute translation_number_mul_of_commute\n\n",
 "translation_number_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_mono : Monotone (exprτ) := fun f g h =>\n  le_of_tendsto_of_tendsto' f.tendsto_translation_number₀ g.tendsto_translation_number₀ fun n =>\n    div_le_div_of_le_of_nonneg (pow_mono h n 0) n.cast_nonneg\n#align translation_number_mono translation_number_mono\n\n",
 "translation_number_lt_of_forall_lt_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_lt_of_forall_lt_add (hf : Continuous f) {z : exprℝ} (hz : ∀ x, f x < x + z) :\n    (exprτ) f < z :=\n  by\n  obtain ⟨x, xmem, hx⟩ : ∃ x ∈ Icc (0 : exprℝ) 1, ∀ y ∈ Icc (0 : exprℝ) 1, f y - y ≤ f x - x\n  exact is_compact_Icc.exists_forall_ge (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuous_on\n  refine' lt_of_le_of_lt _ (sub_lt_iff_lt_add'.2 <| hz x)\n  apply translation_number_le_of_le_add\n  simp only [← sub_le_iff_le_add']\n  exact f.forall_map_sub_of_Icc (fun a => a ≤ f x - x) hx\n#align translation_number_lt_of_forall_lt_add translation_number_lt_of_forall_lt_add\n\n",
 "translation_number_le_of_le_add_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_le_of_le_add_nat {x : exprℝ} {m : ℕ} (h : f x ≤ x + m) : (exprτ) f ≤ m :=\n  @translationNumber_le_of_le_add_int f x m h\n#align translation_number_le_of_le_add_nat translation_number_le_of_le_add_nat\n\n",
 "translation_number_le_of_le_add_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_le_of_le_add_int {x : exprℝ} {m : ℤ} (h : f x ≤ x + m) : (exprτ) f ≤ m :=\n  le_of_tendsto' (f.tendsto_translation_number' x) fun n =>\n    (div_le_iff' (n.cast_add_one_pos : (0 : exprℝ) < _)).mpr <|\n      sub_le_iff_le_add'.2 <|\n        (coe_pow f (n + 1)).symm ▸ @Nat.cast_add_one (exprℝ) _ n ▸ f.iterate_le_of_map_le_add_int h (n + 1)\n#align translation_number_le_of_le_add_int translation_number_le_of_le_add_int\n\n",
 "translation_number_le_of_le_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_le_of_le_add {z : exprℝ} (hz : ∀ x, f x ≤ x + z) : (exprτ) f ≤ z :=\n  translationNumber_translate z ▸ translationNumber_mono fun x => trans_rel_left _ (hz x) (add_comm _ _)\n#align translation_number_le_of_le_add translation_number_le_of_le_add\n\n",
 "translation_number_le_ceil_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem translation_number_le_ceil_sub (x : exprℝ) : (exprτ) f ≤ «expr⌈ ⌉» (f x - x) :=\n  translationNumber_le_of_le_add_int f <| sub_le_iff_le_add'.1 (le_ceil <| f x - x)\n#align translation_number_le_ceil_sub translation_number_le_ceil_sub\n\n",
 "translation_number_eq_rat_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_rat_iff (hf : Continuous f) {m : ℤ} {n : ℕ} (hn : 0 < n) :\n    (exprτ) f = m / n ↔ ∃ x, (f ^ n) x = x + m :=\n  by\n  rw [eq_div_iff, mul_comm, ← translation_number_pow] <;> [skip, exact ne_of_gt (Nat.cast_pos.2 hn)]\n  exact (f ^ n).translation_number_eq_int_iff (f.continuous_pow hf n)\n#align translation_number_eq_rat_iff translation_number_eq_rat_iff\n\n",
 "translation_number_eq_of_tendsto₀'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_of_tendsto₀' {τ' : exprℝ}\n    (h : Tendsto (fun n : ℕ => («expr ^[ ]» f (n + 1)) 0 / (n + 1)) atTop ((nhds) τ')) : (exprτ) f = τ' :=\n  f.translation_number_eq_of_tendsto₀ <| (tendsto_add_atTop_iff_nat 1).1 (by exact_mod_cast h)\n#align translation_number_eq_of_tendsto₀' translation_number_eq_of_tendsto₀'\n\n",
 "translation_number_eq_of_tendsto₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_of_tendsto₀ {τ' : exprℝ}\n    (h : Tendsto (fun n : ℕ => («expr ^[ ]» f n) 0 / n) atTop ((nhds) τ')) : (exprτ) f = τ' :=\n  f.translation_number_eq_of_tendsto_aux <| by\n    simpa [(· ∘ ·), transnum_aux_seq_def, coe_pow] using h.comp (Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two)\n#align translation_number_eq_of_tendsto₀ translation_number_eq_of_tendsto₀\n\n",
 "translation_number_eq_of_tendsto_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_of_tendsto_aux {τ' : exprℝ} (h : Tendsto f.transnum_aux_seq atTop ((nhds) τ')) :\n    (exprτ) f = τ' :=\n  h.lim_eq\n#align translation_number_eq_of_tendsto_aux translation_number_eq_of_tendsto_aux\n\n",
 "translation_number_eq_of_semiconj_by":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_of_semiconj_by {f g₁ g₂ : CircleDeg1Lift} (H : SemiconjBy f g₁ g₂) :\n    (exprτ) g₁ = (exprτ) g₂ :=\n  translationNumber_eq_of_dist_bounded 2 fun n => le_of_lt <| dist_map_zero_lt_of_semiconjBy <| H.pow_right n\n#align translation_number_eq_of_semiconj_by translation_number_eq_of_semiconj_by\n\n",
 "translation_number_eq_of_semiconj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_of_semiconj {f g₁ g₂ : CircleDeg1Lift} (H : Function.Semiconj f g₁ g₂) :\n    (exprτ) g₁ = (exprτ) g₂ :=\n  translationNumber_eq_of_semiconjBy <| semiconjBy_iff_semiconj.2 H\n#align translation_number_eq_of_semiconj translation_number_eq_of_semiconj\n\n",
 "translation_number_eq_of_dist_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_of_dist_bounded {f g : CircleDeg1Lift} (C : exprℝ)\n    (H : ∀ n : ℕ, dist ((f ^ n) 0) ((g ^ n) 0) ≤ C) : (exprτ) f = (exprτ) g :=\n  Eq.symm <| g.translation_number_eq_of_tendsto_aux <| f.tendsto_translation_number_of_dist_bounded_aux _ C H\n#align translation_number_eq_of_dist_bounded translation_number_eq_of_dist_bounded\n\n",
 "translation_number_eq_int_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem translation_number_eq_int_iff (hf : Continuous f) {m : ℤ} : (exprτ) f = m ↔ ∃ x, f x = x + m :=\n  by\n  refine' ⟨fun h => h ▸ f.exists_eq_add_translation_number hf, _⟩\n  rintro ⟨x, hx⟩\n  exact f.translation_number_of_eq_add_int hx\n#align translation_number_eq_int_iff translation_number_eq_int_iff\n\n",
 "translation_number_conj_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n@[simp]\ntheorem translation_number_conj_eq' (f : «expr ˣ» CircleDeg1Lift) (g : CircleDeg1Lift) :\n    (exprτ) (↑f⁻¹ * g * f) = (exprτ) g :=\n  translationNumber_conj_eq f⁻¹ g\n#align translation_number_conj_eq' translation_number_conj_eq'\n\n",
 "translation_number_conj_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n@[simp]\ntheorem translation_number_conj_eq (f : «expr ˣ» CircleDeg1Lift) (g : CircleDeg1Lift) :\n    (exprτ) (↑f * g * ↑f⁻¹) = (exprτ) g :=\n  (translationNumber_eq_of_semiconjBy (f.mk_semiconj_by g)).symm\n#align translation_number_conj_eq translation_number_conj_eq\n\n",
 "translate_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem translate_zpow (x : exprℝ) (n : ℤ) :\n    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| ↑n * x) := by\n  simp only [← zsmul_eq_mul, ofAdd_zsmul, MonoidHom.map_zpow]\n#align translate_zpow translate_zpow\n\n",
 "translate_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem translate_pow (x : exprℝ) (n : ℕ) :\n    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| ↑n * x) :=\n  translate_zpow x n\n#align translate_pow translate_pow\n\n",
 "translate_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem translate_iterate (x : exprℝ) (n : ℕ) :\n    «expr ^[ ]» (translate (Multiplicative.ofAdd x)) n = translate (Multiplicative.ofAdd <| ↑n * x) := by\n  rw [← units_coe, ← coe_pow, ← Units.val_pow_eq_pow_val, translate_pow, units_coe]\n#align translate_iterate translate_iterate\n\n",
 "translate_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem translate_inv_apply (x y : exprℝ) : (translate <| Multiplicative.ofAdd x)⁻¹ y = -x + y :=\n  rfl\n#align translate_inv_apply translate_inv_apply\n\n",
 "translate_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem translate_apply (x y : exprℝ) : translate (Multiplicative.ofAdd x) y = x + y :=\n  rfl\n#align translate_apply translate_apply\n\n",
 "tendsto_translation_number₀'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem tendsto_translation_number₀' : Tendsto (fun n : ℕ => (f ^ (n + 1)) 0 / (n + 1)) atTop (nhds <| (exprτ) f) :=\n  by\n  refine'\n    tendsto_iff_dist_tendsto_zero.2 <|\n      squeeze_zero (fun _ => dist_nonneg) (fun n => _)\n        ((tendsto_const_div_atTop_nhds_0_nat 1).comp (tendsto_add_at_top_nat 1))\n  dsimp\n  have : (0 : exprℝ) < n + 1 := n.cast_add_one_pos\n  rw [Real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ← Real.dist_eq, abs_of_pos this, Nat.cast_add_one,\n    div_le_div_right this, ← Nat.cast_add_one]\n  apply dist_pow_map_zero_mul_translation_number_le\n#align tendsto_translation_number₀' tendsto_translation_number₀'\n\n",
 "tendsto_translation_number₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem tendsto_translation_number₀ : Tendsto (fun n : ℕ => (f ^ n) 0 / n) atTop (nhds <| (exprτ) f) :=\n  (tendsto_add_atTop_iff_nat 1).1 (by exact_mod_cast f.tendsto_translation_number₀')\n#align tendsto_translation_number₀ tendsto_translation_number₀\n\n",
 "tendsto_translation_number_of_dist_bounded_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem tendsto_translation_number_of_dist_bounded_aux (x : ℕ → exprℝ) (C : exprℝ)\n    (H : ∀ n : ℕ, dist ((f ^ n) 0) (x n) ≤ C) : Tendsto (fun n : ℕ => x (2 ^ n) / 2 ^ n) atTop (nhds <| (exprτ) f) :=\n  by\n  refine' f.tendsto_translation_number_aux.congr_dist (squeeze_zero (fun _ => dist_nonneg) _ _)\n  · exact fun n => C / 2 ^ n\n  · intro n\n    have : 0 < (2 ^ n : exprℝ) := pow_pos zero_lt_two _\n    convert(div_le_div_right this).2 (H (2 ^ n))\n    rw [transnum_aux_seq, Real.dist_eq, ← sub_div, abs_div, abs_of_pos this, Real.dist_eq]\n  ·\n    exact\n      MulZeroClass.mul_zero C ▸\n        tendsto_const_nhds.mul (tendsto_inv_at_top_zero.comp <| tendsto_pow_atTop_atTop_of_one_lt one_lt_two)\n#align tendsto_translation_number_of_dist_bounded_aux tendsto_translation_number_of_dist_bounded_aux\n\n",
 "tendsto_translation_number_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem tendsto_translation_number_aux : Tendsto f.transnum_aux_seq atTop (nhds <| (exprτ) f) :=\n  (cauchySeq_of_le_geometric_two 1 fun n => le_of_lt <| f.transnum_aux_seq_dist_lt n).tendsto_lim\n#align tendsto_translation_number_aux tendsto_translation_number_aux\n\n",
 "tendsto_translation_number'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem tendsto_translation_number' (x : exprℝ) :\n    Tendsto (fun n : ℕ => ((f ^ (n + 1)) x - x) / (n + 1)) atTop (nhds <| (exprτ) f) := by\n  exact_mod_cast (tendsto_add_at_top_iff_nat 1).2 (f.tendsto_translation_number x)\n#align tendsto_translation_number' tendsto_translation_number'\n\n",
 "tendsto_translation_number":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- For any `x : ℝ` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem tendsto_translation_number (x : exprℝ) : Tendsto (fun n : ℕ => ((f ^ n) x - x) / n) atTop (nhds <| (exprτ) f) :=\n  by\n  rw [← translation_number_conj_eq' (translate <| Multiplicative.ofAdd x)]\n  convert tendsto_translation_number₀ _\n  ext n\n  simp [sub_eq_neg_add, Units.conj_pow']\n#align tendsto_translation_number tendsto_translation_number\n\n",
 "tendsto_at_top":
 "protected theorem tendsto_at_top : Tendsto f atTop atTop :=\n  tendsto_atTop_mono f.le_map_of_map_zero <|\n    tendsto_atTop_add_const_left _ _ <|\n      (tendsto_atTop_mono fun x => (sub_one_lt_floor x).le) <| by\n        simpa [sub_eq_add_neg] using tendsto_at_top_add_const_right _ _ tendsto_id\n#align tendsto_at_top tendsto_at_top\n\n",
 "tendsto_at_bot":
 "protected theorem tendsto_at_bot : Tendsto f atBot atBot :=\n  tendsto_atBot_mono f.map_le_of_map_zero <|\n    tendsto_atBot_add_const_left _ _ <|\n      (tendsto_atBot_mono fun x => (ceil_lt_add_one x).le) <| tendsto_atBot_add_const_right _ _ tendsto_id\n#align tendsto_at_bot tendsto_at_bot\n\n",
 "sup_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n-- TODO: generalize to `monotone.max`\n@[simp]\ntheorem sup_apply (x : exprℝ) : («expr ⊔ » f g) x = max (f x) (g x) :=\n  rfl\n#align sup_apply sup_apply\n\n",
 "strict_mono_iff_injective":
 "theorem strict_mono_iff_injective : StrictMono f ↔ injective f :=\n  f.monotone.strict_mono_iff_injective\n#align strict_mono_iff_injective strict_mono_iff_injective\n\n",
 "semiconj_of_is_unit_of_translation_number_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `circle_deg1_lift`. This version uses assumptions `is_unit f₁` and `is_unit f₂`\nto assume that `f₁` and `f₂` are homeomorphisms. -/\ntheorem semiconj_of_is_unit_of_translation_number_eq {f₁ f₂ : CircleDeg1Lift} (h₁ : IsUnit f₁) (h₂ : IsUnit f₂)\n    (h : (exprτ) f₁ = (exprτ) f₂) : ∃ F : CircleDeg1Lift, Semiconj F f₁ f₂ :=\n  by\n  rcases h₁, h₂ with ⟨⟨f₁, rfl⟩, ⟨f₂, rfl⟩⟩\n  exact units_semiconj_of_translation_number_eq h\n#align semiconj_of_is_unit_of_translation_number_eq semiconj_of_is_unit_of_translation_number_eq\n\n",
 "semiconj_of_group_action_of_forall_translation_number_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- Consider two actions `f₁ f₂ : G →* circle_deg1_lift` of a group on the real line by lifts of\norientation preserving circle homeomorphisms. Suppose that for each `g : G` the homeomorphisms\n`f₁ g` and `f₂ g` have equal rotation numbers. Then there exists `F : circle_deg1_lift`  such that\n`F * f₁ g = f₂ g * F` for all `g : G`.\n\nThis is a version of Proposition 5.4 from [Étienne Ghys, Groupes d'homeomorphismes du cercle et\ncohomologie bornee][ghys87:groupes]. -/\ntheorem semiconj_of_group_action_of_forall_translation_number_eq {G : Type _} [Group G]\n    (f₁ f₂ : «expr →* » G CircleDeg1Lift) (h : ∀ g, (exprτ) (f₁ g) = (exprτ) (f₂ g)) :\n    ∃ F : CircleDeg1Lift, ∀ g, Semiconj F (f₁ g) (f₂ g) :=\n  by\n  -- Equality of translation number guarantees that for each `x`\n  -- the set `{f₂ g⁻¹ (f₁ g x) | g : G}` is bounded above.\n  have : ∀ x, BddAbove (range fun g => f₂ g⁻¹ (f₁ g x)) :=\n    by\n    refine' fun x => ⟨x + 2, _⟩\n    rintro _ ⟨g, rfl⟩\n    have : (exprτ) (f₂ g⁻¹) = -(exprτ) (f₂ g) := by\n      rw [← MonoidHom.coe_toHomUnits, MonoidHom.map_inv, translation_number_units_inv, MonoidHom.coe_toHomUnits]\n    calc\n      f₂ g⁻¹ (f₁ g x) ≤ f₂ g⁻¹ (x + (exprτ) (f₁ g) + 1) := mono _ (map_lt_add_translation_number_add_one _ _).le\n      _ = f₂ g⁻¹ (x + (exprτ) (f₂ g)) + 1 := by rw [h, map_add_one]\n      _ ≤ x + (exprτ) (f₂ g) + (exprτ) (f₂ g⁻¹) + 1 + 1 := by\n        mono\n        exact (map_lt_add_translation_number_add_one _ _).le\n      _ = x + 2 := by simp [this, bit0, add_assoc]\n      \n  -- We have a theorem about actions by `order_iso`, so we introduce auxiliary maps\n  -- to `ℝ ≃o ℝ`.\n  set F₁ := to_order_iso.comp f₁.to_hom_units\n  set F₂ := to_order_iso.comp f₂.to_hom_units\n  have hF₁ : ∀ g, «expr⇑ » (F₁ g) = f₁ g := fun _ => rfl\n  have hF₂ : ∀ g, «expr⇑ » (F₂ g) = f₂ g := fun _ => rfl\n  simp only [← hF₁, ← hF₂]\n  -- Now we apply `cSup_div_semiconj` and go back to `f₁` and `f₂`.\n    refine' ⟨⟨_, fun x y hxy => _, fun x => _⟩, cSup_div_semiconj F₂ F₁ fun x => _⟩ <;>\n    simp only [hF₁, hF₂, ← MonoidHom.map_inv, coe_mk]\n  · refine' csupᵢ_mono (this y) fun g => _\n    exact mono _ (mono _ hxy)\n  · simp only [map_add_one]\n    exact\n      (Monotone.map_csupᵢ_of_continuousAt (continuous_at_id.add continuousAt_const) (monotone_id.add_const (1 : exprℝ))\n          (this x)).symm\n  · exact this x\n#align semiconj_of_group_action_of_forall_translation_number_eq semiconj_of_group_action_of_forall_translation_number_eq\n\n",
 "semiconj_of_bijective_of_translation_number_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `circle_deg1_lift`. This version uses assumptions `bijective f₁` and\n`bijective f₂` to assume that `f₁` and `f₂` are homeomorphisms. -/\ntheorem semiconj_of_bijective_of_translation_number_eq {f₁ f₂ : CircleDeg1Lift} (h₁ : bijective f₁) (h₂ : bijective f₂)\n    (h : (exprτ) f₁ = (exprτ) f₂) : ∃ F : CircleDeg1Lift, Semiconj F f₁ f₂ :=\n  semiconj_of_isUnit_of_translationNumber_eq (isUnit_iff_bijective.2 h₁) (isUnit_iff_bijective.2 h₂) h\n#align semiconj_of_bijective_of_translation_number_eq semiconj_of_bijective_of_translation_number_eq\n\n",
 "semiconj_by_iff_semiconj":
 "theorem semiconj_by_iff_semiconj {f g₁ g₂ : CircleDeg1Lift} : SemiconjBy f g₁ g₂ ↔ Semiconj f g₁ g₂ :=\n  ext_iff\n#align semiconj_by_iff_semiconj semiconj_by_iff_semiconj\n\n",
 "pow_monotone":
 "theorem pow_monotone (n : ℕ) : Monotone fun f : CircleDeg1Lift => f ^ n := fun f g h => pow_mono h n\n#align pow_monotone pow_monotone\n\n",
 "pow_mono":
 "#print pow_mono /-\ntheorem pow_mono {f g : CircleDeg1Lift} (h : f ≤ g) (n : ℕ) : f ^ n ≤ g ^ n := fun x => by\n  simp only [coe_pow, iterate_mono h n x]\n#align pow_mono pow_mono\n-/\n\n",
 "mul_floor_map_zero_le_floor_iterate_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem mul_floor_map_zero_le_floor_iterate_zero (n : ℕ) : ↑n * «expr⌊ ⌋» (f 0) ≤ «expr⌊ ⌋» ((«expr ^[ ]» f n) 0) :=\n  by\n  rw [le_floor, Int.cast_mul, Int.cast_ofNat, ← zero_add ((n : exprℝ) * _)]\n  apply le_iterate_of_add_int_le_map\n  simp [floor_le]\n#align mul_floor_map_zero_le_floor_iterate_zero mul_floor_map_zero_le_floor_iterate_zero\n\n",
 "mul_apply":
 "theorem mul_apply (x) : (f * g) x = f (g x) :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mono":
 "@[mono]\ntheorem mono {x y} (h : x ≤ y) : f x ≤ f y :=\n  f.monotone h\n#align mono mono\n\n",
 "map_sub_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_sub_nat (x : exprℝ) (n : ℕ) : f (x - n) = f x - n :=\n  f.map_sub_int x n\n#align map_sub_nat map_sub_nat\n\n",
 "map_sub_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_sub_int (x : exprℝ) (n : ℤ) : f (x - n) = f x - n :=\n  f.commute_sub_int n x\n#align map_sub_int map_sub_int\n\n",
 "map_one_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_one_add (x : exprℝ) : f (1 + x) = 1 + f x := by rw [add_comm, map_add_one, add_comm]\n#align map_one_add map_one_add\n\n",
 "map_nat_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_nat_add (n : ℕ) (x : exprℝ) : f (n + x) = n + f x :=\n  f.map_int_add n x\n#align map_nat_add map_nat_add\n\n",
 "map_map_zero_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem map_map_zero_lt : f (g 0) < f 0 + g 0 + 1 :=\n  calc\n    f (g 0) ≤ f 0 + «expr⌈ ⌉» (g 0) := f.map_map_zero_le g\n    _ < f 0 + (g 0 + 1) := (add_lt_add_left (ceil_lt_add_one _) _)\n    _ = f 0 + g 0 + 1 := (add_assoc _ _ _).symm\n    \n#align map_map_zero_lt map_map_zero_lt\n\n",
 "map_map_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem map_map_zero_le : f (g 0) ≤ f 0 + «expr⌈ ⌉» (g 0) :=\n  f.map_le_of_map_zero (g 0)\n#align map_map_zero_le map_map_zero_le\n\n",
 "map_lt_of_translation_number_lt_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem map_lt_of_translation_number_lt_nat {n : ℕ} (h : (exprτ) f < n) (x : exprℝ) : f x < x + n :=\n  @map_lt_of_translationNumber_lt_int f n h x\n#align map_lt_of_translation_number_lt_nat map_lt_of_translation_number_lt_nat\n\n",
 "map_lt_of_translation_number_lt_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem map_lt_of_translation_number_lt_int {n : ℤ} (h : (exprτ) f < n) (x : exprℝ) : f x < x + n :=\n  not_le.1 <| mt f.le_translation_number_of_add_int_le <| not_le.2 h\n#align map_lt_of_translation_number_lt_int map_lt_of_translation_number_lt_int\n\n",
 "map_lt_add_translation_number_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem map_lt_add_translation_number_add_one (x : exprℝ) : f x < x + (exprτ) f + 1 :=\n  calc\n    f x < x + «expr⌊ ⌋» ((exprτ) f) + 1 := f.map_lt_add_floor_translation_number_add_one x\n    _ ≤ x + (exprτ) f + 1 := by\n      mono*\n      exact floor_le ((exprτ) f)\n    \n#align map_lt_add_translation_number_add_one map_lt_add_translation_number_add_one\n\n",
 "map_lt_add_floor_translation_number_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem map_lt_add_floor_translation_number_add_one (x : exprℝ) : f x < x + «expr⌊ ⌋» ((exprτ) f) + 1 :=\n  by\n  rw [add_assoc]\n  norm_cast\n  refine' map_lt_of_translation_number_lt_int _ _ _\n  push_cast\n  exact lt_floor_add_one _\n#align map_lt_add_floor_translation_number_add_one map_lt_add_floor_translation_number_add_one\n\n",
 "map_le_of_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem map_le_of_map_zero (x : exprℝ) : f x ≤ f 0 + «expr⌈ ⌉» x :=\n  calc\n    f x ≤ f («expr⌈ ⌉» x) := f.monotone <| le_ceil _\n    _ = f 0 + «expr⌈ ⌉» x := f.map_int_of_map_zero _\n    \n#align map_le_of_map_zero map_le_of_map_zero\n\n",
 "map_int_of_map_zero":
 "theorem map_int_of_map_zero (n : ℤ) : f n = f 0 + n := by rw [← f.map_add_int, zero_add]\n#align map_int_of_map_zero map_int_of_map_zero\n\n",
 "map_int_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_int_add (m : ℤ) (x : exprℝ) : f (m + x) = m + f x :=\n  f.commute_int_add m x\n#align map_int_add map_int_add\n\n",
 "map_fract_sub_fract_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_fract_sub_fract_eq (x : exprℝ) : f (fract x) - fract x = f x - x := by\n  rw [Int.fract, f.map_sub_int, sub_sub_sub_cancel_right]\n#align map_fract_sub_fract_eq map_fract_sub_fract_eq\n\n",
 "map_add_one":
 "@[simp]\ntheorem map_add_one : ∀ x, f (x + 1) = f x + 1 :=\n  f.map_add_one'\n#align map_add_one map_add_one\n\n",
 "map_add_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_add_nat (x : exprℝ) (n : ℕ) : f (x + n) = f x + n :=\n  f.map_add_int x n\n#align map_add_nat map_add_nat\n\n",
 "map_add_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem map_add_int (x : exprℝ) (m : ℤ) : f (x + m) = f x + m :=\n  f.commute_add_int m x\n#align map_add_int map_add_int\n\n",
 "lt_translation_number_of_forall_add_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem lt_translation_number_of_forall_add_lt (hf : Continuous f) {z : exprℝ} (hz : ∀ x, x + z < f x) :\n    z < (exprτ) f :=\n  by\n  obtain ⟨x, xmem, hx⟩ : ∃ x ∈ Icc (0 : exprℝ) 1, ∀ y ∈ Icc (0 : exprℝ) 1, f x - x ≤ f y - y\n  exact is_compact_Icc.exists_forall_le (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuous_on\n  refine' lt_of_lt_of_le (lt_sub_iff_add_lt'.2 <| hz x) _\n  apply le_translation_number_of_add_le\n  simp only [← le_sub_iff_add_le']\n  exact f.forall_map_sub_of_Icc _ hx\n#align lt_translation_number_of_forall_add_lt lt_translation_number_of_forall_add_lt\n\n",
 "lt_map_of_nat_lt_translation_number":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lt_map_of_nat_lt_translation_number {n : ℕ} (h : ↑n < (exprτ) f) (x : exprℝ) : x + n < f x :=\n  @lt_map_of_int_lt_translationNumber f n h x\n#align lt_map_of_nat_lt_translation_number lt_map_of_nat_lt_translation_number\n\n",
 "lt_map_of_int_lt_translation_number":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lt_map_of_int_lt_translation_number {n : ℤ} (h : ↑n < (exprτ) f) (x : exprℝ) : x + n < f x :=\n  not_le.1 <| mt f.translation_number_le_of_le_add_int <| not_le.2 h\n#align lt_map_of_int_lt_translation_number lt_map_of_int_lt_translation_number\n\n",
 "lt_map_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem lt_map_map_zero : f 0 + g 0 - 1 < f (g 0) :=\n  calc\n    f 0 + g 0 - 1 = f 0 + (g 0 - 1) := add_sub_assoc _ _ _\n    _ < f 0 + «expr⌊ ⌋» (g 0) := (add_lt_add_left (sub_one_lt_floor _) _)\n    _ ≤ f (g 0) := f.le_map_map_zero g\n    \n#align lt_map_map_zero lt_map_map_zero\n\n",
 "lt_iterate_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem lt_iterate_pos_iff {x : exprℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) : x + n * m < («expr ^[ ]» f n) x ↔ x + m < f x :=\n  by simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)\n#align lt_iterate_pos_iff lt_iterate_pos_iff\n\n",
 "le_translation_number_of_add_nat_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem le_translation_number_of_add_nat_le {x : exprℝ} {m : ℕ} (h : x + m ≤ f x) : ↑m ≤ (exprτ) f :=\n  @le_translationNumber_of_add_int_le f x m h\n#align le_translation_number_of_add_nat_le le_translation_number_of_add_nat_le\n\n",
 "le_translation_number_of_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem le_translation_number_of_add_le {z : exprℝ} (hz : ∀ x, x + z ≤ f x) : z ≤ (exprτ) f :=\n  translationNumber_translate z ▸ translationNumber_mono fun x => trans_rel_right _ (add_comm _ _) (hz x)\n#align le_translation_number_of_add_le le_translation_number_of_add_le\n\n",
 "le_translation_number_of_add_int_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem le_translation_number_of_add_int_le {x : exprℝ} {m : ℤ} (h : x + m ≤ f x) : ↑m ≤ (exprτ) f :=\n  ge_of_tendsto' (f.tendsto_translation_number' x) fun n =>\n    (le_div_iff (n.cast_add_one_pos : (0 : exprℝ) < _)).mpr <|\n      le_sub_iff_add_le'.2 <| by\n        simp only [coe_pow, mul_comm (m : exprℝ), ← Nat.cast_add_one, f.le_iterate_of_add_int_le_map h]\n#align le_translation_number_of_add_int_le le_translation_number_of_add_int_le\n\n",
 "le_map_of_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem le_map_of_map_zero (x : exprℝ) : f 0 + «expr⌊ ⌋» x ≤ f x :=\n  calc\n    f 0 + «expr⌊ ⌋» x = f («expr⌊ ⌋» x) := (f.map_int_of_map_zero _).symm\n    _ ≤ f x := f.monotone <| floor_le _\n    \n#align le_map_of_map_zero le_map_of_map_zero\n\n",
 "le_map_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem le_map_map_zero : f 0 + «expr⌊ ⌋» (g 0) ≤ f (g 0) :=\n  f.le_map_of_map_zero (g 0)\n#align le_map_map_zero le_map_map_zero\n\n",
 "le_iterate_pos_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem le_iterate_pos_iff {x : exprℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) : x + n * m ≤ («expr ^[ ]» f n) x ↔ x + m ≤ f x :=\n  by simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)\n#align le_iterate_pos_iff le_iterate_pos_iff\n\n",
 "le_iterate_of_add_int_le_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem le_iterate_of_add_int_le_map {x : exprℝ} {m : ℤ} (h : x + m ≤ f x) (n : ℕ) : x + n * m ≤ («expr ^[ ]» f n) x :=\n  by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const m) f.monotone h n\n#align le_iterate_of_add_int_le_map le_iterate_of_add_int_le_map\n\n",
 "le_floor_map_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem le_floor_map_map_zero : «expr⌊ ⌋» (f 0) + «expr⌊ ⌋» (g 0) ≤ «expr⌊ ⌋» (f (g 0)) :=\n  calc\n    «expr⌊ ⌋» (f 0) + «expr⌊ ⌋» (g 0) = «expr⌊ ⌋» (f 0 + «expr⌊ ⌋» (g 0)) := (floor_add_int _ _).symm\n    _ ≤ «expr⌊ ⌋» (f (g 0)) := floor_mono <| f.le_map_map_zero g\n    \n#align le_floor_map_map_zero le_floor_map_map_zero\n\n",
 "le_ceil_map_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem le_ceil_map_map_zero : «expr⌈ ⌉» (f 0) + «expr⌊ ⌋» (g 0) ≤ «expr⌈ ⌉» ((f * g) 0) :=\n  calc\n    «expr⌈ ⌉» (f 0) + «expr⌊ ⌋» (g 0) = «expr⌈ ⌉» (f 0 + «expr⌊ ⌋» (g 0)) := (ceil_add_int _ _).symm\n    _ ≤ «expr⌈ ⌉» (f (g 0)) := ceil_mono <| f.le_map_map_zero g\n    \n#align le_ceil_map_map_zero le_ceil_map_map_zero\n\n",
 "iterate_pos_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_pos_lt_iff {x : exprℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) : («expr ^[ ]» f n) x < x + n * m ↔ f x < x + m :=\n  by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strict_mono_id.add_const m) hn\n#align iterate_pos_lt_iff iterate_pos_lt_iff\n\n",
 "iterate_pos_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_pos_le_iff {x : exprℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) : («expr ^[ ]» f n) x ≤ x + n * m ↔ f x ≤ x + m :=\n  by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strict_mono_id.add_const m) hn\n#align iterate_pos_le_iff iterate_pos_le_iff\n\n",
 "iterate_pos_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_pos_eq_iff {x : exprℝ} {m : ℤ} {n : ℕ} (hn : 0 < n) : («expr ^[ ]» f n) x = x + n * m ↔ f x = x + m :=\n  by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn\n#align iterate_pos_eq_iff iterate_pos_eq_iff\n\n",
 "iterate_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_monotone (n : ℕ) : Monotone fun f : CircleDeg1Lift => «expr ^[ ]» f n := fun f g h =>\n  f.monotone.iterate_le_of_le h _\n#align iterate_monotone iterate_monotone\n\n",
 "iterate_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_mono {f g : CircleDeg1Lift} (h : f ≤ g) (n : ℕ) : «expr ^[ ]» f n ≤ «expr ^[ ]» g n :=\n  iterate_monotone n h\n#align iterate_mono iterate_mono\n\n",
 "iterate_le_of_map_le_add_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_le_of_map_le_add_int {x : exprℝ} {m : ℤ} (h : f x ≤ x + m) (n : ℕ) : («expr ^[ ]» f n) x ≤ x + n * m :=\n  by\n  simpa only [nsmul_eq_mul, add_right_iterate] using\n    (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const m) h n\n#align iterate_le_of_map_le_add_int iterate_le_of_map_le_add_int\n\n",
 "iterate_eq_of_map_eq_add_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_eq_of_map_eq_add_int {x : exprℝ} {m : ℤ} (h : f x = x + m) (n : ℕ) : («expr ^[ ]» f n) x = x + n * m :=\n  by simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h\n#align iterate_eq_of_map_eq_add_int iterate_eq_of_map_eq_add_int\n\n",
 "is_unit_iff_bijective":
 "theorem is_unit_iff_bijective {f : CircleDeg1Lift} : IsUnit f ↔ bijective f :=\n  ⟨fun ⟨u, h⟩ => h ▸ (toOrderIso u).bijective, fun h =>\n    Units.isUnit\n      { val := f\n        inv :=\n          { to_fun := (Equiv.ofBijective f h).symm\n            monotone' := fun x y hxy =>\n              (f.strict_mono_iff_injective.2 h.1).le_iff_le.1\n                (by simp only [Equiv.ofBijective_apply_symm_apply f h, hxy])\n            map_add_one' := fun x => h.1 <| by simp only [Equiv.ofBijective_apply_symm_apply f, f.map_add_one] }\n        val_inv := ext <| Equiv.ofBijective_apply_symm_apply f h\n        inv_val := ext <| Equiv.ofBijective_symm_apply_apply f h }⟩\n#align is_unit_iff_bijective is_unit_iff_bijective\n\n",
 "inf_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_apply (x : exprℝ) : («expr ⊓ » f g) x = min (f x) (g x) :=\n  rfl\n#align inf_apply inf_apply\n\n",
 "forall_map_sub_of_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- If a predicate depends only on `f x - x` and holds for all `0 ≤ x ≤ 1`,\nthen it holds for all `x`. -/\ntheorem forall_map_sub_of_Icc (P : exprℝ → Prop) (h : ∀ x ∈ Icc (0 : exprℝ) 1, P (f x - x)) (x : exprℝ) : P (f x - x) :=\n  f.map_fract_sub_fract_eq x ▸ h _ ⟨fract_nonneg _, le_of_lt (fract_lt_one _)⟩\n#align forall_map_sub_of_Icc forall_map_sub_of_Icc\n\n",
 "floor_sub_le_translation_number":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem floor_sub_le_translation_number (x : exprℝ) : ↑(«expr⌊ ⌋» (f x - x)) ≤ (exprτ) f :=\n  le_translationNumber_of_add_int_le f <| le_sub_iff_add_le'.1 (floor_le <| f x - x)\n#align floor_sub_le_translation_number floor_sub_le_translation_number\n\n",
 "floor_map_map_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem floor_map_map_zero_le : «expr⌊ ⌋» (f (g 0)) ≤ «expr⌊ ⌋» (f 0) + «expr⌈ ⌉» (g 0) :=\n  calc\n    «expr⌊ ⌋» (f (g 0)) ≤ «expr⌊ ⌋» (f 0 + «expr⌈ ⌉» (g 0)) := floor_mono <| f.map_map_zero_le g\n    _ = «expr⌊ ⌋» (f 0) + «expr⌈ ⌉» (g 0) := floor_add_int _ _\n    \n#align floor_map_map_zero_le floor_map_map_zero_le\n\n",
 "ext_iff":
 "theorem ext_iff {f g : CircleDeg1Lift} : f = g ↔ ∀ x, f x = g x :=\n  ⟨fun h x => h ▸ rfl, fun h => ext h⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext ⦃f g : CircleDeg1Lift⦄ (h : ∀ x, f x = g x) : f = g :=\n  [anonymous] <| funext h\n#align ext ext\n\n",
 "exists_eq_add_translation_number":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem exists_eq_add_translation_number (hf : Continuous f) : ∃ x, f x = x + (exprτ) f :=\n  by\n  obtain ⟨a, ha⟩ : ∃ x, f x ≤ x + f.translation_number :=\n    by\n    by_contra' H\n    exact lt_irrefl _ (f.lt_translation_number_of_forall_add_lt hf H)\n  obtain ⟨b, hb⟩ : ∃ x, x + (exprτ) f ≤ f x := by\n    by_contra' H\n    exact lt_irrefl _ (f.translation_number_lt_of_forall_lt_add hf H)\n  exact intermediate_value_univ₂ hf (continuous_id.add continuous_const) ha hb\n#align exists_eq_add_translation_number exists_eq_add_translation_number\n\n",
 "dist_pow_map_zero_mul_translation_number_le":
 "theorem dist_pow_map_zero_mul_translation_number_le (n : ℕ) : dist ((f ^ n) 0) (n * f.translation_number) ≤ 1 :=\n  f.translation_number_pow n ▸ (f ^ n).dist_map_zero_translation_number_le\n#align dist_pow_map_zero_mul_translation_number_le dist_pow_map_zero_mul_translation_number_le\n\n",
 "dist_map_zero_translation_number_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprτ -/\ntheorem dist_map_zero_translation_number_le : dist (f 0) ((exprτ) f) ≤ 1 :=\n  f.transnum_aux_seq_zero ▸\n    dist_le_of_le_geometric_two_of_tendsto₀ 1 (fun n => le_of_lt <| f.transnum_aux_seq_dist_lt n)\n      f.tendsto_translation_number_aux\n#align dist_map_zero_translation_number_le dist_map_zero_translation_number_le\n\n",
 "dist_map_zero_lt_of_semiconj_by":
 "theorem dist_map_zero_lt_of_semiconj_by {f g₁ g₂ : CircleDeg1Lift} (h : SemiconjBy f g₁ g₂) : dist (g₁ 0) (g₂ 0) < 2 :=\n  dist_map_zero_lt_of_semiconj <| semiconjBy_iff_semiconj.1 h\n#align dist_map_zero_lt_of_semiconj_by dist_map_zero_lt_of_semiconj_by\n\n",
 "dist_map_zero_lt_of_semiconj":
 "theorem dist_map_zero_lt_of_semiconj {f g₁ g₂ : CircleDeg1Lift} (h : Function.Semiconj f g₁ g₂) :\n    dist (g₁ 0) (g₂ 0) < 2 :=\n  calc\n    dist (g₁ 0) (g₂ 0) ≤ dist (g₁ 0) (f (g₁ 0) - f 0) + dist _ (g₂ 0) := dist_triangle _ _ _\n    _ = dist (f 0 + g₁ 0) (f (g₁ 0)) + dist (g₂ 0 + f 0) (g₂ (f 0)) := by\n      simp only [h.eq, Real.dist_eq, sub_sub, add_comm (f 0), sub_sub_eq_add_sub, abs_sub_comm (g₂ (f 0))]\n    _ < 2 := add_lt_add (f.dist_map_map_zero_lt g₁) (g₂.dist_map_map_zero_lt f)\n    \n#align dist_map_zero_lt_of_semiconj dist_map_zero_lt_of_semiconj\n\n",
 "dist_map_map_zero_lt":
 "theorem dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1 :=\n  by\n  rw [dist_comm, Real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ← sub_eq_add_neg]\n  exact ⟨f.lt_map_map_zero g, f.map_map_zero_lt g⟩\n#align dist_map_map_zero_lt dist_map_map_zero_lt\n\n",
 "continuous_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print continuous_pow /-\ntheorem continuous_pow (hf : Continuous f) (n : ℕ) : Continuous («expr⇑ » (f ^ n : CircleDeg1Lift)) :=\n  by\n  rw [coe_pow]\n  exact hf.iterate n\n#align continuous_pow continuous_pow\n-/\n\n",
 "continuous_iff_surjective":
 "theorem continuous_iff_surjective : Continuous f ↔ function.surjective f :=\n  ⟨fun h => h.surjective f.tendsto_at_top f.tendsto_at_bot, f.monotone.continuous_of_surjective⟩\n#align continuous_iff_surjective continuous_iff_surjective\n\n",
 "commute_sub_nat":
 "theorem commute_sub_nat (n : ℕ) : Function.Commute f fun x => x - n := by\n  simpa only [sub_eq_add_neg] using\n    (f.commute_add_nat n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv\n#align commute_sub_nat commute_sub_nat\n\n",
 "commute_sub_int":
 "theorem commute_sub_int (n : ℤ) : Function.Commute f fun x => x - n := by\n  simpa only [sub_eq_add_neg] using\n    (f.commute_add_int n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv\n#align commute_sub_int commute_sub_int\n\n",
 "commute_nat_add":
 "theorem commute_nat_add (n : ℕ) : Function.Commute f ((· + ·) n) := by\n  simpa only [nsmul_one, add_left_iterate] using Function.Commute.iterate_right f.map_one_add n\n#align commute_nat_add commute_nat_add\n\n",
 "commute_int_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem commute_int_add (n : ℤ) : Function.Commute f ((· + ·) n) := by\n  simpa only [add_comm _ (n : exprℝ)] using f.commute_add_int n\n#align commute_int_add commute_int_add\n\n",
 "commute_iff_commute":
 "theorem commute_iff_commute {f g : CircleDeg1Lift} : Commute f g ↔ Function.Commute f g :=\n  ext_iff\n#align commute_iff_commute commute_iff_commute\n\n",
 "commute_add_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem commute_add_nat (n : ℕ) : Function.Commute f fun x => x + n := by\n  simp only [add_comm _ (n : exprℝ), f.commute_nat_add n]\n#align commute_add_nat commute_add_nat\n\n",
 "commute_add_int":
 "theorem commute_add_int : ∀ n : ℤ, Function.Commute f fun x => x + n\n  | (n : ℕ) => f.commute_add_nat n\n  | -[n+1] => by simpa [sub_eq_add_neg] using f.commute_sub_nat (n + 1)\n#align commute_add_int commute_add_int\n\n",
 "coe_to_order_iso_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem coe_to_order_iso_symm (f : «expr ˣ» CircleDeg1Lift) :\n    «expr⇑ » (toOrderIso f).symm = (f⁻¹ : «expr ˣ» CircleDeg1Lift) :=\n  rfl\n#align coe_to_order_iso_symm coe_to_order_iso_symm\n\n",
 "coe_to_order_iso_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem coe_to_order_iso_inv (f : «expr ˣ» CircleDeg1Lift) :\n    «expr⇑ » (toOrderIso f)⁻¹ = (f⁻¹ : «expr ˣ» CircleDeg1Lift) :=\n  rfl\n#align coe_to_order_iso_inv coe_to_order_iso_inv\n\n",
 "coe_to_order_iso":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_to_order_iso (f : «expr ˣ» CircleDeg1Lift) : «expr⇑ » (toOrderIso f) = f :=\n  rfl\n#align coe_to_order_iso coe_to_order_iso\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem coe_pow : ∀ n : ℕ, «expr⇑ » (f ^ n) = «expr ^[ ]» f n\n  | 0 => rfl\n  | n + 1 => by\n    ext x\n    simp [coe_pow n, pow_succ']\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_one : «expr⇑ » (1 : CircleDeg1Lift) = id :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mul : «expr⇑ » (f * g) = f ∘ g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2020 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n@[simp]\ntheorem coe_mk (f h₁ h₂) : «expr⇑ » (mk f h₁ h₂) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem coe_inj : ∀ ⦃f g : CircleDeg1Lift⦄, (f : exprℝ → exprℝ) = g → f = g := fun ⟨f, fm, fd⟩ ⟨g, gm, gd⟩ h => by\n  congr <;> exact h\n#align coe_inj coe_inj\n\n",
 "ceil_map_map_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\ntheorem ceil_map_map_zero_le : «expr⌈ ⌉» (f (g 0)) ≤ «expr⌈ ⌉» (f 0) + «expr⌈ ⌉» (g 0) :=\n  calc\n    «expr⌈ ⌉» (f (g 0)) ≤ «expr⌈ ⌉» (f 0 + «expr⌈ ⌉» (g 0)) := ceil_mono <| f.map_map_zero_le g\n    _ = «expr⌈ ⌉» (f 0) + «expr⌈ ⌉» (g 0) := ceil_add_int _ _\n    \n#align ceil_map_map_zero_le ceil_map_map_zero_le\n\n",
 "Monotone":
 "#print Monotone /-\nprotected theorem Monotone : Monotone f :=\n  f.monotone'\n#align monotone Monotone\n-/\n\n"}