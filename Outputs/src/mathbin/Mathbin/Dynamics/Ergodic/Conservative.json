{"measure_mem_forall_ge_image_not_mem_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`, the set\nof points `x ∈ s` such that `x` does not return to `s` after `≥ n` iterations has measure zero. -/\ntheorem measure_mem_forall_ge_image_not_mem_eq_zero (hf : conservative f μ) (hs : MeasurableSet s) (n : ℕ) :\n    μ ({ x ∈ s | ∀ m ≥ n, («expr ^[ ]» f m) x ∉ s }) = 0 :=\n  by\n  by_contra H\n  have : MeasurableSet (s ∩ { x | ∀ m ≥ n, («expr ^[ ]» f m) x ∉ s }) :=\n    by\n    simp only [set_of_forall, ← compl_set_of]\n    exact hs.inter (MeasurableSet.binterᵢ (to_countable _) fun m _ => hf.measurable.iterate m hs.compl)\n  rcases(hf.exists_gt_measure_inter_ne_zero this H) n with ⟨m, hmn, hm⟩\n  rcases nonempty_of_measure_ne_zero hm with ⟨x, ⟨hxs, hxn⟩, hxm, -⟩\n  exact hxn m hmn.lt.le hxm\n#align measure_mem_forall_ge_image_not_mem_eq_zero measure_mem_forall_ge_image_not_mem_eq_zero\n\n",
 "measure_inter_frequently_image_mem_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem measure_inter_frequently_image_mem_eq (hf : conservative f μ) (hs : MeasurableSet s) :\n    μ\n        (s ∩\n          { x |\n            «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n              atTop ((«expr ^[ ]» f n) x ∈ s) }) =\n      μ s :=\n  measure_congr (hf.inter_frequently_image_mem_ae_eq hs)\n#align measure_inter_frequently_image_mem_eq measure_inter_frequently_image_mem_eq\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- Iteration of a conservative system is a conservative system. -/\nprotected theorem iterate (hf : conservative f μ) (n : ℕ) : conservative («expr ^[ ]» f n) μ :=\n  by\n  cases n\n  · exact conservative.id μ\n  -- Discharge the trivial case `n = 0`\n  refine' ⟨hf.1.iterate _, fun s hs hs0 => _⟩\n  rcases(hf.frequently_ae_mem_and_frequently_image_mem hs hs0).exists with ⟨x, hxs, hx⟩\n  /- We take a point `x ∈ s` such that `f^[k] x ∈ s` for infinitely many values of `k`,\n    then we choose two of these values `k < l` such that `k ≡ l [MOD (n + 1)]`.\n    Then `f^[k] x ∈ s` and `(f^[n + 1])^[(l - k) / (n + 1)] (f^[k] x) = f^[l] x ∈ s`. -/\n  rw [Nat.frequently_atTop_iff_infinite] at hx\n  rcases Nat.exists_lt_modEq_of_infinite hx n.succ_pos with ⟨k, hk, l, hl, hkl, hn⟩\n  set m := (l - k) / (n + 1)\n  have : (n + 1) * m = l - k := by\n    apply Nat.mul_div_cancel'\n    exact (Nat.modEq_iff_dvd' hkl.le).1 hn\n  refine' ⟨(«expr ^[ ]» f k) x, hk, m, _, _⟩\n  · intro hm\n    rw [hm, MulZeroClass.mul_zero, eq_comm, tsub_eq_zero_iff_le] at this\n    exact this.not_lt hkl\n  · rwa [← iterate_mul, this, ← iterate_add_apply, tsub_add_cancel_of_le]\n    exact hkl.le\n#align iterate iterate\n\n",
 "inter_frequently_image_mem_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem inter_frequently_image_mem_ae_eq (hf : conservative f μ) (hs : MeasurableSet s) :\n    «expr =ᵐ[ ] »\n      (s ∩\n          { x |\n            «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\"\n              atTop ((«expr ^[ ]» f n) x ∈ s) } :\n        Set α)\n      μ s :=\n  inter_eventuallyEq_left.2 <| hf.ae_mem_imp_frequently_image_mem hs\n#align inter_frequently_image_mem_ae_eq inter_frequently_image_mem_ae_eq\n\n",
 "id":
 "#print id /-\n/-- The identity map is conservative w.r.t. any measure. -/\nprotected theorem id (μ : Measure α) : conservative id μ :=\n  { to_quasi_measure_preserving := QuasiMeasurePreserving.id μ\n    exists_mem_image_mem := fun s hs h0 =>\n      let ⟨x, hx⟩ := nonempty_of_measure_ne_zero h0\n      ⟨x, hx, 1, one_ne_zero, hx⟩ }\n#align id id\n-/\n\n",
 "frequently_measure_inter_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `f` is a conservative map and `s` is a measurable set of nonzero measure, then\nfor infinitely many values of `m` a positive measure of points `x ∈ s` returns back to `s`\nafter `m` iterations of `f`. -/\ntheorem frequently_measure_inter_ne_zero (hf : conservative f μ) (hs : MeasurableSet s) (h0 : μ s ≠ 0) :\n    «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n      (μ (s ∩ «expr ⁻¹' » («expr ^[ ]» f m) s) ≠ 0) :=\n  by\n  by_contra H\n  simp only [not_frequently, eventually_at_top, ne.def, Classical.not_not] at H\n  rcases H with ⟨N, hN⟩\n  induction' N with N ihN\n  · apply h0\n    simpa using hN 0 le_rfl\n  rw [imp_false] at ihN\n  push_neg  at ihN\n  rcases ihN with ⟨n, hn, hμn⟩\n  set T :=\n    s ∩\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr ⁻¹' » («expr ^[ ]» f n) s)\n  have hT : MeasurableSet T := hs.inter (MeasurableSet.bunionᵢ (to_countable _) fun _ _ => hf.measurable.iterate _ hs)\n  have hμT : μ T = 0 := by\n    convert(measure_bUnion_null_iff <| to_countable _).2 hN\n    rw [← inter_Union₂]\n    rfl\n  have : μ ((s ∩ «expr ⁻¹' » («expr ^[ ]» f n) s) \\ T) ≠ 0 := by rwa [measure_diff_null hμT]\n  rcases hf.exists_mem_image_mem ((hs.inter (hf.measurable.iterate n hs)).diff hT) this with\n    ⟨x, ⟨⟨hxs, hxn⟩, hxT⟩, m, hm0, ⟨hxms, hxm⟩, hxx⟩\n  refine' hxT ⟨hxs, mem_Union₂.2 ⟨n + m, _, _⟩⟩\n  · exact add_le_add hn (Nat.one_le_of_lt <| pos_iff_ne_zero.2 hm0)\n  · rwa [Set.mem_preimage, ← iterate_add_apply] at hxm\n#align frequently_measure_inter_ne_zero frequently_measure_inter_ne_zero\n\n",
 "frequently_ae_mem_and_frequently_image_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `f` is a conservative self-map and `s` is a measurable set of positive measure, then\n`μ.ae`-frequently we have `x ∈ s` and `s` returns to `s` under infinitely many iterations of `f`. -/\ntheorem frequently_ae_mem_and_frequently_image_mem (hf : conservative f μ) (hs : MeasurableSet s) (h0 : μ s ≠ 0) :\n    «expr∃ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᵐ ∂ , »\" μ\n      (x ∈ s ∧\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n          ((«expr ^[ ]» f n) x ∈ s)) :=\n  ((frequently_ae_mem_iff.2 h0).and_eventually (hf.ae_mem_imp_frequently_image_mem hs)).mono fun x hx =>\n    ⟨hx.1, hx.2 hx.1⟩\n#align frequently_ae_mem_and_frequently_image_mem frequently_ae_mem_and_frequently_image_mem\n\n",
 "exists_gt_measure_inter_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `f` is a conservative map and `s` is a measurable set of nonzero measure, then\nfor an arbitrarily large `m` a positive measure of points `x ∈ s` returns back to `s`\nafter `m` iterations of `f`. -/\ntheorem exists_gt_measure_inter_ne_zero (hf : conservative f μ) (hs : MeasurableSet s) (h0 : μ s ≠ 0) (N : ℕ) :\n    ∃ m > N, μ (s ∩ «expr ⁻¹' » («expr ^[ ]» f m) s) ≠ 0 :=\n  let ⟨m, hm, hmN⟩ := ((hf.frequently_measure_inter_ne_zero hs h0).and_eventually (eventually_gt_atTop N)).exists\n  ⟨m, hmN, hm⟩\n#align exists_gt_measure_inter_ne_zero exists_gt_measure_inter_ne_zero\n\n",
 "conservative":
 "/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- A self-map preserving a finite measure is conservative. -/\nprotected theorem measure_preserving.conservative [FiniteMeasure μ] (h : MeasurePreserving f μ μ) : conservative f μ :=\n  ⟨h.quasi_measure_preserving, fun s hsm h0 => h.exists_mem_image_mem hsm h0⟩\n#align measure_preserving.conservative measure_preserving.conservative\n\n",
 "ae_mem_imp_frequently_image_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`,\nalmost every point `x ∈ s` returns back to `s` infinitely many times. -/\ntheorem ae_mem_imp_frequently_image_mem (hf : conservative f μ) (hs : MeasurableSet s) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (x ∈ s →\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n          ((«expr ^[ ]» f n) x ∈ s)) :=\n  by\n  simp only [frequently_at_top, @forall_swap (_ ∈ s), ae_all_iff]\n  intro n\n  filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]\n  simp\n#align ae_mem_imp_frequently_image_mem ae_mem_imp_frequently_image_mem\n\n",
 "ae_frequently_mem_of_mem_nhds":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- Poincaré recurrence theorem. Let `f : α → α` be a conservative dynamical system on a topological\nspace with second countable topology and measurable open sets. Then almost every point `x : α`\nis recurrent: it visits every neighborhood `s ∈ 𝓝 x` infinitely many times. -/\ntheorem ae_frequently_mem_of_mem_nhds [TopologicalSpace α] [SecondCountableTopology α] [opens_measurable_space α]\n    {f : α → α} {μ : Measure α} (h : conservative f μ) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ s ∈ (nhds) x,\n        «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n          ((«expr ^[ ]» f n) x ∈ s)) :=\n  by\n  have :\n    ∀ s ∈ countable_basis α,\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (x ∈ s →\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" at_top\n            ((«expr ^[ ]» f n) x ∈ s)) :=\n    fun s hs => h.ae_mem_imp_frequently_image_mem (is_open_of_mem_countable_basis hs).measurable_set\n  refine' ((ae_ball_iff <| countable_countable_basis α).2 this).mono fun x hx s hs => _\n  rcases(is_basis_countable_basis α).mem_nhds_iff.1 hs with ⟨o, hoS, hxo, hos⟩\n  exact (hx o hoS hxo).mono fun n hn => hos hn\n#align ae_frequently_mem_of_mem_nhds ae_frequently_mem_of_mem_nhds\n\n",
 "ae_forall_image_mem_imp_frequently_image_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- Poincaré recurrence theorem: if `f` is a conservative dynamical system and `s` is a measurable\nset, then for `μ`-a.e. `x`, if the orbit of `x` visits `s` at least once, then it visits `s`\ninfinitely many times.  -/\ntheorem ae_forall_image_mem_imp_frequently_image_mem (hf : conservative f μ) (hs : MeasurableSet s) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ k,\n        («expr ^[ ]» f k) x ∈ s →\n          «expr∃ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∃ᶠ in , »\" atTop\n            ((«expr ^[ ]» f n) x ∈ s)) :=\n  by\n  refine' ae_all_iff.2 fun k => _\n  refine' (hf.ae_mem_imp_frequently_image_mem (hf.measurable.iterate k hs)).mono fun x hx hk => _\n  rw [← map_add_at_top_eq_nat k, frequently_map]\n  refine' (hx hk).mono fun n hn => _\n  rwa [add_comm, iterate_add_apply]\n#align ae_forall_image_mem_imp_frequently_image_mem ae_forall_image_mem_imp_frequently_image_mem\n\n"}