{"ergodic_zsmul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ergodic_zsmul_add (x : add_circle T) {n : ℤ} (h : 1 < |n|) : ergodic fun y => «expr • » n y + x :=\n  by\n  set f : add_circle T → add_circle T := fun y => «expr • » n y + x\n  let e : «expr ≃ᵐ » (add_circle T) (add_circle T) := measurable_equiv.add_left (divisible_by.div x <| n - 1)\n  have he : measure_preserving e volume volume := measure_preserving_add_left volume _\n  suffices e ∘ f ∘ e.symm = fun y => «expr • » n y\n    by\n    rw [← he.ergodic_conjugate_iff, this]\n    exact ergodic_zsmul h\n  replace h : n - 1 ≠ 0\n  · rw [← abs_one] at h\n    rw [sub_ne_zero]\n    exact ne_of_apply_ne _ (ne_of_gt h)\n  have hnx : «expr • » n (divisible_by.div x (n - 1)) = x + divisible_by.div x (n - 1) :=\n    by\n    conv_rhs =>\n      congr\n      rw [← divisible_by.div_cancel x h]\n    rw [sub_smul, one_smul, sub_add_cancel]\n  ext y\n  simp only [f, hnx, measurable_equiv.coe_add_left, measurable_equiv.symm_add_left, comp_app, smul_add, zsmul_neg',\n    neg_smul, neg_add_rev]\n  abel\n#align ergodic_zsmul_add ergodic_zsmul_add\n\n",
 "ergodic_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ergodic_zsmul {n : ℤ} (hn : 1 < |n|) : ergodic fun y : add_circle T => «expr • » n y :=\n  { measure_preserving_zsmul volume (abs_pos.mp <| lt_trans zero_lt_one hn) with\n    ae_empty_or_univ := fun s hs hs' =>\n      by\n      let u : ℕ → add_circle T := fun j => ↑((↑1 : exprℝ) / ↑(n.nat_abs ^ j) * T)\n      replace hn : 1 < n.nat_abs\n      · rwa [Int.abs_eq_natAbs, nat.one_lt_cast] at hn\n      have hu₀ : ∀ j, add_order_of (u j) = n.nat_abs ^ j := fun j =>\n        add_order_of_div_of_gcd_eq_one (pow_pos (pos_of_gt hn) j) (gcd_one_left _)\n      have hnu : ∀ j, «expr • » (n ^ j) (u j) = 0 := fun j => by\n        rw [← add_order_of_dvd_iff_zsmul_eq_zero, hu₀, Int.coe_nat_pow, Int.coe_natAbs, ← abs_pow, abs_dvd]\n      have hu₁ : ∀ j, «expr =ᵐ[ ] » («expr +ᵥ » (u j) s : set _) volume s := fun j => by\n        rw [vadd_eq_self_of_preimage_zsmul_eq_self hs' (hnu j)]\n      have hu₂ : tendsto (fun j => add_order_of <| u j) at_top at_top :=\n        by\n        simp_rw [hu₀]\n        exact nat.tendsto_pow_at_top_at_top_of_one_lt hn\n      exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hs.null_measurable_set hu₁ hu₂ }\n#align ergodic_zsmul ergodic_zsmul\n\n",
 "ergodic_nsmul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ergodic_nsmul_add (x : add_circle T) {n : ℕ} (h : 1 < n) : ergodic fun y => «expr • » n y + x :=\n  ergodic_zsmul_add x (by simp [h] : 1 < |(n : ℤ)|)\n#align ergodic_nsmul_add ergodic_nsmul_add\n\n",
 "ergodic_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ergodic_nsmul {n : ℕ} (hn : 1 < n) : ergodic fun y : add_circle T => «expr • » n y :=\n  ergodic_zsmul (by simp [hn] : 1 < |(n : ℤ)|)\n#align ergodic_nsmul ergodic_nsmul\n\n",
 "ae_empty_or_univ_of_forall_vadd_ae_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds_within.gt -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n/-- If a null-measurable subset of the circle is almost invariant under rotation by a family of\nrational angles with denominators tending to infinity, then it must be almost empty or almost full.\n-/\ntheorem ae_empty_or_univ_of_forall_vadd_ae_eq_self {s : set <| add_circle T} (hs : null_measurable_set s volume)\n    {ι : Type _} {l : filter ι} [l.ne_bot] {u : ι → add_circle T}\n    (hu₁ : ∀ i, «expr =ᵐ[ ] » («expr +ᵥ » (u i) s : set _) volume s) (hu₂ : tendsto (add_order_of ∘ u) l at_top) :\n    «expr =ᵐ[ ] » s volume (∅ : set <| add_circle T) ∨ «expr =ᵐ[ ] » s volume univ :=\n  by\n  /- Sketch of proof:\n    Assume `T = 1` for simplicity and let `μ` be the Haar measure. We may assume `s` has positive\n    measure since otherwise there is nothing to prove. In this case, by Lebesgue's density theorem,\n    there exists a point `d` of positive density. Let `Iⱼ` be the sequence of closed balls about `d`\n    of diameter `1 / nⱼ` where `nⱼ` is the additive order of `uⱼ`. Since `d` has positive density we\n    must have `μ (s ∩ Iⱼ) / μ Iⱼ → 1` along `l`. However since `s` is invariant under the action of\n    `uⱼ` and since `Iⱼ` is a fundamental domain for this action, we must have\n    `μ (s ∩ Iⱼ) = nⱼ * μ s = (μ Iⱼ) * μ s`. We thus have `μ s → 1` and thus `μ s = 1`. -/\n  set μ := (volume : measure <| add_circle T)\n  set n : ι → ℕ := add_order_of ∘ u\n  have hT₀ : 0 < T := hT.out\n  have hT₁ : ennreal.of_real T ≠ 0 := by simpa\n  rw [ae_eq_empty, ae_eq_univ_iff_measure_eq hs, add_circle.measure_univ]\n  cases' eq_or_ne (μ s) 0 with h h\n  · exact or.inl h\n  right\n  obtain ⟨d, -, hd⟩ :\n    ∃ d,\n      d ∈ s ∧\n        ∀ {ι'} {l : filter ι'} (w : ι' → add_circle T) (δ : ι' → exprℝ),\n          tendsto δ l (nhds_within.gt 0) →\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n                (d ∈ closed_ball (w j) (1 * δ j)) →\n              tendsto (fun j => μ (s ∩ closed_ball (w j) (δ j)) / μ (closed_ball (w j) (δ j))) l ((nhds) 1) :=\n    exists_mem_of_measure_ne_zero_of_ae h (is_doubling_measure.ae_tendsto_measure_inter_div μ s 1)\n  let I : ι → set (add_circle T) := fun j => closed_ball d (T / (2 * ↑(n j)))\n  replace hd : tendsto (fun j => μ (s ∩ I j) / μ (I j)) l ((nhds) 1)\n  · let δ : ι → exprℝ := fun j => T / (2 * ↑(n j))\n    have hδ₀ :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (0 < δ j) :=\n      (hu₂.eventually_gt_at_top 0).mono fun j hj => div_pos hT₀ <| by positivity\n    have hδ₁ : tendsto δ l (nhds_within.gt 0) :=\n      by\n      refine' tendsto_nhds_within_iff.mpr ⟨_, hδ₀⟩\n      replace hu₂ : tendsto (fun j => T⁻¹ * 2 * n j) l at_top :=\n        (tendsto_coe_nat_at_top_iff.mpr hu₂).const_mul_at_top (by positivity : 0 < T⁻¹ * 2)\n      convert hu₂.inv_tendsto_at_top\n      ext j\n      simp only [δ, pi.inv_apply, mul_inv_rev, inv_inv, div_eq_inv_mul, ← mul_assoc]\n    have hw :\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n        (d ∈ closed_ball d (1 * δ j)) :=\n      hδ₀.mono fun j hj => by simp [hj.le]\n    exact hd _ δ hδ₁ hw\n  suffices\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" l\n      (μ (s ∩ I j) / μ (I j) = μ s / ennreal.of_real T)\n    by\n    replace hd := hd.congr' this\n    rwa [tendsto_const_nhds_iff, ennreal.div_eq_one_iff hT₁ ennreal.of_real_ne_top] at hd\n  refine' (hu₂.eventually_gt_at_top 0).mono fun j hj => _\n  have huj : is_of_fin_add_order (u j) := add_order_of_pos_iff.mp hj\n  have huj' : 1 ≤ (↑(n j) : exprℝ) := by\n    norm_cast\n    exact nat.succ_le_iff.mpr hj\n  have hI₀ : μ (I j) ≠ 0 := (measure_closed_ball_pos _ d <| by positivity).ne.symm\n  have hI₁ : μ (I j) ≠ «expr⊤» := measure_ne_top _ _\n  have hI₂ : μ (I j) * ↑(n j) = ennreal.of_real T :=\n    by\n    rw [volume_closed_ball, mul_div, mul_div_mul_left T _ two_ne_zero, min_eq_right (div_le_self hT₀.le huj'), mul_comm,\n      ← nsmul_eq_mul, ← ennreal.of_real_nsmul, nsmul_eq_mul, mul_div_cancel']\n    exact nat.cast_ne_zero.mpr hj.ne'\n  rw [ennreal.div_eq_div_iff hT₁ ennreal.of_real_ne_top hI₀ hI₁,\n    volume_of_add_preimage_eq s _ (u j) d huj (hu₁ j) closed_ball_ae_eq_ball, nsmul_eq_mul, ← mul_assoc, hI₂]\n#align ae_empty_or_univ_of_forall_vadd_ae_eq_self ae_empty_or_univ_of_forall_vadd_ae_eq_self\n\n"}