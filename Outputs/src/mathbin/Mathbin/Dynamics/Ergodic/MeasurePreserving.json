{"symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n#print symm /-\ntheorem symm (e : «expr ≃ᵐ » α β) {μa : measure α} {μb : measure β} (h : measure_preserving e μa μb) :\n    measure_preserving e.symm μb μa :=\n  ⟨e.symm.measurable, by rw [← h.map_eq, map_map e.symm.measurable e.measurable, e.symm_comp_self, map_id]⟩\n#align symm symm\n-/\n\n",
 "sigma_finite":
 "protected theorem sigma_finite {f : α → β} (hf : measure_preserving f μa μb) [sigma_finite μb] : sigma_finite μa :=\n  sigma_finite.of_map μa hf.ae_measurable (by rwa [hf.map_eq])\n#align sigma_finite sigma_finite\n\n",
 "restrict_preimage_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_preimage_emb {f : α → β} (hf : measure_preserving f μa μb) (h₂ : measurable_embedding f) (s : set β) :\n    measure_preserving f (μa.restrict («expr ⁻¹' » f s)) (μb.restrict s) :=\n  ⟨hf.measurable, by rw [← hf.map_eq, h₂.restrict_map]⟩\n#align restrict_preimage_emb restrict_preimage_emb\n\n",
 "restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_preimage {f : α → β} (hf : measure_preserving f μa μb) {s : set β} (hs : measurable_set s) :\n    measure_preserving f (μa.restrict («expr ⁻¹' » f s)) (μb.restrict s) :=\n  ⟨hf.measurable, by rw [← hf.map_eq, restrict_map hf.measurable hs]⟩\n#align restrict_preimage restrict_preimage\n\n",
 "restrict_image_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem restrict_image_emb {f : α → β} (hf : measure_preserving f μa μb) (h₂ : measurable_embedding f) (s : set α) :\n    measure_preserving f (μa.restrict s) (μb.restrict («expr '' » f s)) := by\n  simpa only [preimage_image_eq _ h₂.injective] using hf.restrict_preimage_emb h₂ («expr '' » f s)\n#align restrict_image_emb restrict_image_emb\n\n",
 "quasi_measure_preserving":
 "protected theorem quasi_measure_preserving {f : α → β} (hf : measure_preserving f μa μb) :\n    quasi_measure_preserving f μa μb :=\n  ⟨hf.1, hf.2.absolutely_continuous⟩\n#align quasi_measure_preserving quasi_measure_preserving\n\n",
 "measure_preserving_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem measure_preserving_symm (μ : measure α) (e : «expr ≃ᵐ » α β) : measure_preserving e.symm (map e μ) μ :=\n  (e.measurable.measure_preserving μ).symm _\n#align measure_preserving_symm measure_preserving_symm\n\n",
 "measure_preserving":
 "/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nprotected theorem _root_.measurable.measure_preserving {f : α → β} (h : measurable f) (μa : measure α) :\n    measure_preserving f μa (map f μa) :=\n  ⟨h, rfl⟩\n#align measurable.measure_preserving measurable.measure_preserving\n\n",
 "measure_preimage_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measure_preimage_emb {f : α → β} (hf : measure_preserving f μa μb) (hfe : measurable_embedding f) (s : set β) :\n    μa («expr ⁻¹' » f s) = μb s := by rw [← hf.map_eq, hfe.map_apply]\n#align measure_preimage_emb measure_preimage_emb\n\n",
 "measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measure_preimage {f : α → β} (hf : measure_preserving f μa μb) {s : set β} (hs : measurable_set s) :\n    μa («expr ⁻¹' » f s) = μb s := by rw [← hf.map_eq, map_apply hf.1 hs]\n#align measure_preimage measure_preimage\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem iterate {f : α → α} (hf : measure_preserving f μa μa) :\n    ∀ n, measure_preserving («expr ^[ ]» f n) μa μa\n  | 0 => measure_preserving.id μa\n  | n + 1 => (iterate n).comp hf\n#align iterate iterate\n\n",
 "id":
 "#print id /-\nprotected theorem id (μ : measure α) : measure_preserving id μ μ :=\n  ⟨measurable_id, map_id⟩\n#align id id\n-/\n\n",
 "exists_mem_image_mem_of_volume_lt_mul_volume":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `μ univ < n * μ s` and `f` is a map preserving measure `μ`,\nthen for some `x ∈ s` and `0 < m < n`, `f^[m] x ∈ s`. -/\ntheorem exists_mem_image_mem_of_volume_lt_mul_volume (hf : measure_preserving f μ μ) (hs : measurable_set s) {n : ℕ}\n    (hvol : μ (univ : set α) < n * μ s) : ∃ x ∈ s, ∃ m ∈ Ioo 0 n, («expr ^[ ]» f m) x ∈ s :=\n  by\n  have A : ∀ m, measurable_set («expr ⁻¹' » («expr ^[ ]» f m) s) := fun m => (hf.iterate m).measurable hs\n  have B : ∀ m, μ («expr ⁻¹' » («expr ^[ ]» f m) s) = μ s := fun m => (hf.iterate m).measure_preimage hs\n  have : μ (univ : set α) < (Finset.range n).sum fun m => μ («expr ⁻¹' » («expr ^[ ]» f m) s) := by\n    simpa only [B, nsmul_eq_mul, finset.sum_const, finset.card_range]\n  rcases exists_nonempty_inter_of_measure_univ_lt_sum_measure μ (fun m hm => A m) this with\n    ⟨i, hi, j, hj, hij, x, hxi, hxj⟩\n  -- without `tactic.skip` Lean closes the extra goal but it takes a long time; not sure why\n  wlog (discharger := tactic.skip) hlt : i < j := hij.lt_or_lt using i j, j i\n  · simp only [Set.mem_preimage, Finset.mem_range] at hi hj hxi hxj\n    refine' ⟨(«expr ^[ ]» f i) x, hxi, j - i, ⟨tsub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj⟩, _⟩\n    rwa [← iterate_add_apply, tsub_add_cancel_of_le hlt.le]\n  · exact fun hi hj hij hxi hxj => this hj hi hij.symm hxj hxi\n#align exists_mem_image_mem_of_volume_lt_mul_volume exists_mem_image_mem_of_volume_lt_mul_volume\n\n",
 "exists_mem_image_mem":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (m «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- A self-map preserving a finite measure is conservative: if `μ s ≠ 0`, then at least one point\n`x ∈ s` comes back to `s` under iterations of `f`. Actually, a.e. point of `s` comes back to `s`\ninfinitely many times, see `measure_theory.measure_preserving.conservative` and theorems about\n`measure_theory.conservative`. -/\ntheorem exists_mem_image_mem [is_finite_measure μ] (hf : measure_preserving f μ μ) (hs : measurable_set s)\n    (hs' : μ s ≠ 0) : ∃ x ∈ s, ∃ (m : _)(_ : m ≠ 0), («expr ^[ ]» f m) x ∈ s :=\n  by\n  rcases ennreal.exists_nat_mul_gt hs' (measure_ne_top μ (univ : set α)) with ⟨N, hN⟩\n  rcases hf.exists_mem_image_mem_of_volume_lt_mul_volume hs hN with ⟨x, hx, m, hm, hmx⟩\n  exact ⟨x, hx, m, hm.1.ne', hmx⟩\n#align exists_mem_image_mem exists_mem_image_mem\n\n",
 "comp_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem comp_right_iff {g : α → β} {e : «expr ≃ᵐ » γ α} (h : measure_preserving e μc μa) :\n    measure_preserving (g ∘ e) μc μb ↔ measure_preserving g μa μb :=\n  by\n  refine' ⟨fun hg => _, fun hg => hg.comp h⟩\n  convert hg.comp (measure_preserving.symm e h)\n  simp [function.comp.assoc g e e.symm]\n#align comp_right_iff comp_right_iff\n\n",
 "comp_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem comp_left_iff {g : α → β} {e : «expr ≃ᵐ » β γ} (h : measure_preserving e μb μc) :\n    measure_preserving (e ∘ g) μa μc ↔ measure_preserving g μa μb :=\n  by\n  refine' ⟨fun hg => _, fun hg => h.comp hg⟩\n  convert (measure_preserving.symm e h).comp hg\n  simp [← function.comp.assoc e.symm e g]\n#align comp_left_iff comp_left_iff\n\n",
 "comp":
 "protected theorem comp {g : β → γ} {f : α → β} (hg : measure_preserving g μb μc) (hf : measure_preserving f μa μb) :\n    measure_preserving (g ∘ f) μa μc :=\n  ⟨hg.1.comp hf.1, by rw [← map_map hg.1 hf.1, hf.2, hg.2]⟩\n#align comp comp\n\n",
 "ae_measurable_comp_iff":
 "theorem ae_measurable_comp_iff {f : α → β} (hf : measure_preserving f μa μb) (h₂ : measurable_embedding f) {g : β → γ} :\n    ae_measurable (g ∘ f) μa ↔ ae_measurable g μb := by rw [← hf.map_eq, h₂.ae_measurable_map_iff]\n#align ae_measurable_comp_iff ae_measurable_comp_iff\n\n",
 "ae_measurable":
 "protected theorem ae_measurable {f : α → β} (hf : measure_preserving f μa μb) : ae_measurable f μa :=\n  hf.1.ae_measurable\n#align ae_measurable ae_measurable\n\n"}