{"symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\n#print symm /-\ntheorem symm (e : «expr ≃ᵐ » α β) {μa : Measure α} {μb : Measure β} (h : MeasurePreserving e μa μb) :\n    MeasurePreserving e.symm μb μa :=\n  ⟨e.symm.measurable, by rw [← h.map_eq, map_map e.symm.measurable e.measurable, e.symm_comp_self, map_id]⟩\n#align symm symm\n-/\n\n",
 "sigma_finite":
 "protected theorem sigma_finite {f : α → β} (hf : MeasurePreserving f μa μb) [SigmaFinite μb] : SigmaFinite μa :=\n  SigmaFinite.of_map μa hf.ae_measurable (by rwa [hf.map_eq])\n#align sigma_finite sigma_finite\n\n",
 "restrict_preimage_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_preimage_emb {f : α → β} (hf : MeasurePreserving f μa μb) (h₂ : MeasurableEmbedding f) (s : Set β) :\n    MeasurePreserving f (μa.restrict («expr ⁻¹' » f s)) (μb.restrict s) :=\n  ⟨hf.measurable, by rw [← hf.map_eq, h₂.restrict_map]⟩\n#align restrict_preimage_emb restrict_preimage_emb\n\n",
 "restrict_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem restrict_preimage {f : α → β} (hf : MeasurePreserving f μa μb) {s : Set β} (hs : MeasurableSet s) :\n    MeasurePreserving f (μa.restrict («expr ⁻¹' » f s)) (μb.restrict s) :=\n  ⟨hf.measurable, by rw [← hf.map_eq, restrict_map hf.measurable hs]⟩\n#align restrict_preimage restrict_preimage\n\n",
 "restrict_image_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem restrict_image_emb {f : α → β} (hf : MeasurePreserving f μa μb) (h₂ : MeasurableEmbedding f) (s : Set α) :\n    MeasurePreserving f (μa.restrict s) (μb.restrict («expr '' » f s)) := by\n  simpa only [preimage_image_eq _ h₂.injective] using hf.restrict_preimage_emb h₂ («expr '' » f s)\n#align restrict_image_emb restrict_image_emb\n\n",
 "quasi_measure_preserving":
 "protected theorem quasi_measure_preserving {f : α → β} (hf : MeasurePreserving f μa μb) :\n    QuasiMeasurePreserving f μa μb :=\n  ⟨hf.1, hf.2.absolutely_continuous⟩\n#align quasi_measure_preserving quasi_measure_preserving\n\n",
 "measure_preserving_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\ntheorem measure_preserving_symm (μ : Measure α) (e : «expr ≃ᵐ » α β) : MeasurePreserving e.symm (map e μ) μ :=\n  (e.measurable.measure_preserving μ).symm _\n#align measure_preserving_symm measure_preserving_symm\n\n",
 "measure_preserving":
 "#print Measurable.measurePreserving /-\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nprotected theorem Measurable.measurePreserving {f : α → β} (h : Measurable f) (μa : Measure α) :\n    MeasurePreserving f μa (map f μa) :=\n  ⟨h, rfl⟩\n#align measurable.measure_preserving Measurable.measurePreserving\n-/\n\n",
 "measure_preimage_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measure_preimage_emb {f : α → β} (hf : MeasurePreserving f μa μb) (hfe : MeasurableEmbedding f) (s : Set β) :\n    μa («expr ⁻¹' » f s) = μb s := by rw [← hf.map_eq, hfe.map_apply]\n#align measure_preimage_emb measure_preimage_emb\n\n",
 "measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measure_preimage {f : α → β} (hf : MeasurePreserving f μa μb) {s : Set β} (hs : MeasurableSet s) :\n    μa («expr ⁻¹' » f s) = μb s := by rw [← hf.map_eq, map_apply hf.1 hs]\n#align measure_preimage measure_preimage\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem iterate {f : α → α} (hf : MeasurePreserving f μa μa) : ∀ n, MeasurePreserving («expr ^[ ]» f n) μa μa\n  | 0 => MeasurePreserving.id μa\n  | n + 1 => (iterate n).comp hf\n#align iterate iterate\n\n",
 "id":
 "#print id /-\nprotected theorem id (μ : Measure α) : MeasurePreserving id μ μ :=\n  ⟨measurable_id, map_id⟩\n#align id id\n-/\n\n",
 "exists_mem_image_mem_of_volume_lt_mul_volume":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- If `μ univ < n * μ s` and `f` is a map preserving measure `μ`,\nthen for some `x ∈ s` and `0 < m < n`, `f^[m] x ∈ s`. -/\ntheorem exists_mem_image_mem_of_volume_lt_mul_volume (hf : MeasurePreserving f μ μ) (hs : MeasurableSet s) {n : ℕ}\n    (hvol : μ (univ : Set α) < n * μ s) : ∃ x ∈ s, ∃ m ∈ Ioo 0 n, («expr ^[ ]» f m) x ∈ s :=\n  by\n  have A : ∀ m, MeasurableSet («expr ⁻¹' » («expr ^[ ]» f m) s) := fun m => (hf.iterate m).measurable hs\n  have B : ∀ m, μ («expr ⁻¹' » («expr ^[ ]» f m) s) = μ s := fun m => (hf.iterate m).measure_preimage hs\n  have : μ (univ : Set α) < (Finset.range n).sum fun m => μ («expr ⁻¹' » («expr ^[ ]» f m) s) := by\n    simpa only [B, nsmul_eq_mul, Finset.sum_const, Finset.card_range]\n  rcases exists_nonempty_inter_of_measure_univ_lt_sum_measure μ (fun m hm => A m) this with\n    ⟨i, hi, j, hj, hij, x, hxi, hxj⟩\n  wlog hlt : i < j generalizing i j\n  · exact this j hj i hi hij.symm hxj hxi (hij.lt_or_lt.resolve_left hlt)\n  simp only [Set.mem_preimage, Finset.mem_range] at hi hj hxi hxj\n  refine' ⟨(«expr ^[ ]» f i) x, hxi, j - i, ⟨tsub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj⟩, _⟩\n  rwa [← iterate_add_apply, tsub_add_cancel_of_le hlt.le]\n#align exists_mem_image_mem_of_volume_lt_mul_volume exists_mem_image_mem_of_volume_lt_mul_volume\n\n",
 "exists_mem_image_mem":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (m «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- A self-map preserving a finite measure is conservative: if `μ s ≠ 0`, then at least one point\n`x ∈ s` comes back to `s` under iterations of `f`. Actually, a.e. point of `s` comes back to `s`\ninfinitely many times, see `measure_theory.measure_preserving.conservative` and theorems about\n`measure_theory.conservative`. -/\ntheorem exists_mem_image_mem [FiniteMeasure μ] (hf : MeasurePreserving f μ μ) (hs : MeasurableSet s) (hs' : μ s ≠ 0) :\n    ∃ x ∈ s, ∃ (m : _)(_ : m ≠ 0), («expr ^[ ]» f m) x ∈ s :=\n  by\n  rcases ENNReal.exists_nat_mul_gt hs' (measure_ne_top μ (univ : Set α)) with ⟨N, hN⟩\n  rcases hf.exists_mem_image_mem_of_volume_lt_mul_volume hs hN with ⟨x, hx, m, hm, hmx⟩\n  exact ⟨x, hx, m, hm.1.ne', hmx⟩\n#align exists_mem_image_mem exists_mem_image_mem\n\n",
 "comp_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem comp_right_iff {g : α → β} {e : «expr ≃ᵐ » γ α} (h : MeasurePreserving e μc μa) :\n    MeasurePreserving (g ∘ e) μc μb ↔ MeasurePreserving g μa μb :=\n  by\n  refine' ⟨fun hg => _, fun hg => hg.comp h⟩\n  convert hg.comp (measure_preserving.symm e h)\n  simp [function.comp.assoc g e e.symm]\n#align comp_right_iff comp_right_iff\n\n",
 "comp_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵐ » -/\nprotected theorem comp_left_iff {g : α → β} {e : «expr ≃ᵐ » β γ} (h : MeasurePreserving e μb μc) :\n    MeasurePreserving (e ∘ g) μa μc ↔ MeasurePreserving g μa μb :=\n  by\n  refine' ⟨fun hg => _, fun hg => h.comp hg⟩\n  convert(measure_preserving.symm e h).comp hg\n  simp [← function.comp.assoc e.symm e g]\n#align comp_left_iff comp_left_iff\n\n",
 "comp":
 "protected theorem comp {g : β → γ} {f : α → β} (hg : MeasurePreserving g μb μc) (hf : MeasurePreserving f μa μb) :\n    MeasurePreserving (g ∘ f) μa μc :=\n  ⟨hg.1.comp hf.1, by rw [← map_map hg.1 hf.1, hf.2, hg.2]⟩\n#align comp comp\n\n",
 "ae_measurable_comp_iff":
 "theorem ae_measurable_comp_iff {f : α → β} (hf : MeasurePreserving f μa μb) (h₂ : MeasurableEmbedding f) {g : β → γ} :\n    AEMeasurable (g ∘ f) μa ↔ AEMeasurable g μb := by rw [← hf.map_eq, h₂.ae_measurable_map_iff]\n#align ae_measurable_comp_iff ae_measurable_comp_iff\n\n",
 "AEMeasurable":
 "#print AEMeasurable /-\nprotected theorem AEMeasurable {f : α → β} (hf : MeasurePreserving f μa μb) : AEMeasurable f μa :=\n  hf.1.ae_measurable\n#align ae_measurable AEMeasurable\n-/\n\n"}