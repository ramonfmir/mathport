{"zpow_smul_mod_minimal_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem zpow_smul_mod_minimal_period (n : ℤ) :\n    «expr • » (a ^ (n % (Function.minimalPeriod ((«expr • » · ·) a) b : ℤ))) b = «expr • » (a ^ n) b := by\n  conv_rhs =>\n    rw [← Int.emod_add_ediv n (minimal_period ((«expr • » · ·) a) b), zpow_add, mul_smul,\n      zpow_smul_eq_iff_minimal_period_dvd.mpr (dvd_mul_right _ _)]\n#align zpow_smul_mod_minimal_period zpow_smul_mod_minimal_period\n\n",
 "zpow_smul_eq_iff_minimal_period_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[to_additive]\ntheorem zpow_smul_eq_iff_minimal_period_dvd {n : ℤ} :\n    «expr • » (a ^ n) b = b ↔ (Function.minimalPeriod ((«expr • » · ·) a) b : ℤ) ∣ n :=\n  by\n  cases n\n  · rw [Int.ofNat_eq_coe, zpow_ofNat, Int.coe_nat_dvd, pow_smul_eq_iff_minimal_period_dvd]\n  ·\n    rw [Int.negSucc_coe, zpow_neg, zpow_ofNat, inv_smul_eq_iff, eq_comm, dvd_neg, Int.coe_nat_dvd,\n      pow_smul_eq_iff_minimal_period_dvd]\n#align zpow_smul_eq_iff_minimal_period_dvd zpow_smul_eq_iff_minimal_period_dvd\n\n",
 "trans_dvd":
 "theorem trans_dvd (hm : IsPeriodicPt f m x) {n : ℕ} (hn : m ∣ n) : IsPeriodicPt f n x :=\n  let ⟨k, hk⟩ := hn\n  hk.symm ▸ hm.mul_const k\n#align trans_dvd trans_dvd\n\n",
 "sub":
 "protected theorem sub (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) : IsPeriodicPt f (m - n) x :=\n  by\n  cases' le_total n m with h h\n  · refine' left_of_add _ hn\n    rwa [tsub_add_cancel_of_le h]\n  · rw [tsub_eq_zero_iff_le.mpr h]\n    apply is_periodic_pt_zero\n#align sub sub\n\n",
 "self_mem_periodic_orbit":
 "@[simp]\ntheorem self_mem_periodic_orbit (hx : x ∈ periodicPts f) : x ∈ periodicOrbit f x :=\n  iterate_mem_periodicOrbit hx 0\n#align self_mem_periodic_orbit self_mem_periodic_orbit\n\n",
 "right_of_add":
 "theorem right_of_add (hn : IsPeriodicPt f (n + m) x) (hm : IsPeriodicPt f n x) : IsPeriodicPt f m x :=\n  by\n  rw [add_comm] at hn\n  exact hn.left_of_add hm\n#align right_of_add right_of_add\n\n",
 "pow_smul_mod_minimal_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem pow_smul_mod_minimal_period (n : ℕ) :\n    «expr • » (a ^ (n % Function.minimalPeriod ((«expr • » · ·) a) b)) b = «expr • » (a ^ n) b := by\n  conv_rhs =>\n    rw [← nat.mod_add_div n (minimal_period ((«expr • » · ·) a) b), pow_add, mul_smul,\n      pow_smul_eq_iff_minimal_period_dvd.mpr (dvd_mul_right _ _)]\n#align pow_smul_mod_minimal_period pow_smul_mod_minimal_period\n\n",
 "pow_smul_eq_iff_minimal_period_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n@[to_additive]\ntheorem pow_smul_eq_iff_minimal_period_dvd {n : ℕ} :\n    «expr • » (a ^ n) b = b ↔ Function.minimalPeriod ((«expr • » · ·) a) b ∣ n := by\n  rw [← is_periodic_pt_iff_minimal_period_dvd, is_periodic_pt, is_fixed_pt, smul_iterate]\n#align pow_smul_eq_iff_minimal_period_dvd pow_smul_eq_iff_minimal_period_dvd\n\n",
 "periodic_orbit_length":
 "@[simp]\ntheorem periodic_orbit_length : (periodicOrbit f x).length = minimalPeriod f x := by\n  rw [periodic_orbit, Cycle.length_coe, list.length_map, List.length_range]\n#align periodic_orbit_length periodic_orbit_length\n\n",
 "periodic_orbit_eq_nil_of_not_periodic_pt":
 "theorem periodic_orbit_eq_nil_of_not_periodic_pt (h : x ∉ periodicPts f) : periodicOrbit f x = Cycle.nil :=\n  periodicOrbit_eq_nil_iff_not_periodic_pt.2 h\n#align periodic_orbit_eq_nil_of_not_periodic_pt periodic_orbit_eq_nil_of_not_periodic_pt\n\n",
 "periodic_orbit_eq_nil_iff_not_periodic_pt":
 "@[simp]\ntheorem periodic_orbit_eq_nil_iff_not_periodic_pt : periodicOrbit f x = Cycle.nil ↔ x ∉ periodicPts f :=\n  by\n  simp [periodic_orbit]\n  exact minimal_period_eq_zero_iff_nmem_periodic_pts\n#align periodic_orbit_eq_nil_iff_not_periodic_pt periodic_orbit_eq_nil_iff_not_periodic_pt\n\n",
 "periodic_orbit_eq_cycle_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- The definition of a periodic orbit, in terms of `cycle.map`. -/\ntheorem periodic_orbit_eq_cycle_map (f : α → α) (x : α) :\n    periodicOrbit f x = (list.range (minimalPeriod f x) : Cycle ℕ).map fun n => («expr ^[ ]» f n) x :=\n  rfl\n#align periodic_orbit_eq_cycle_map periodic_orbit_eq_cycle_map\n\n",
 "periodic_orbit_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/-- The definition of a periodic orbit, in terms of `list.map`. -/\ntheorem periodic_orbit_def (f : α → α) (x : α) :\n    periodicOrbit f x = (list.range (minimalPeriod f x)).map fun n => («expr ^[ ]» f n) x :=\n  rfl\n#align periodic_orbit_def periodic_orbit_def\n\n",
 "periodic_orbit_chain'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem periodic_orbit_chain' (r : α → α → Prop) {f : α → α} {x : α} (hx : x ∈ periodicPts f) :\n    (periodicOrbit f x).chain r ↔ ∀ n, r ((«expr ^[ ]» f n) x) ((«expr ^[ ]» f (n + 1)) x) :=\n  by\n  rw [periodic_orbit_chain r]\n  refine' ⟨fun H n => _, fun H n _ => H n⟩\n  rw [iterate_succ_apply, ← iterate_mod_minimal_period_eq]\n  nth_rw 2 [← iterate_mod_minimal_period_eq]\n  rw [← iterate_succ_apply, minimal_period_apply hx]\n  exact H _ (mod_lt _ (minimal_period_pos_of_mem_periodic_pts hx))\n#align periodic_orbit_chain' periodic_orbit_chain'\n\n",
 "periodic_orbit_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem periodic_orbit_chain (r : α → α → Prop) {f : α → α} {x : α} :\n    (periodicOrbit f x).chain r ↔ ∀ n < minimalPeriod f x, r ((«expr ^[ ]» f n) x) ((«expr ^[ ]» f (n + 1)) x) :=\n  by\n  by_cases hx : x ∈ periodic_pts f\n  · have hx' := minimal_period_pos_of_mem_periodic_pts hx\n    have hM := nat.sub_add_cancel (succ_le_iff.2 hx')\n    rw [periodic_orbit, ← Cycle.map_coe, Cycle.chain_map, ← hM, Cycle.chain_range_succ]\n    refine' ⟨_, fun H => ⟨_, fun m hm => H _ (hm.trans (nat.lt_succ_self _))⟩⟩\n    · rintro ⟨hr, H⟩ n hn\n      cases' eq_or_lt_of_le (lt_succ_iff.1 hn) with hM' hM'\n      · rwa [hM', hM, iterate_minimal_period]\n      · exact H _ hM'\n    · rw [iterate_zero_apply]\n      nth_rw 3 [← @iterate_minimal_period α f x]\n      nth_rw 2 [← hM]\n      exact H _ (nat.lt_succ_self _)\n  · rw [periodic_orbit_eq_nil_of_not_periodic_pt hx, minimal_period_eq_zero_of_nmem_periodic_pts hx]\n    simp\n#align periodic_orbit_chain periodic_orbit_chain\n\n",
 "periodic_orbit_apply_iterate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem periodic_orbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :\n    periodicOrbit f ((«expr ^[ ]» f n) x) = periodicOrbit f x :=\n  Eq.symm <|\n    Cycle.coe_eq_coe.2 <|\n      ⟨n, by\n        apply List.ext_nthLe _ fun m _ _ => _\n        · simp [minimal_period_apply_iterate hx]\n        · rw [List.nthLe_rotate _ n m]\n          simp [iterate_add_apply]⟩\n#align periodic_orbit_apply_iterate_eq periodic_orbit_apply_iterate_eq\n\n",
 "periodic_orbit_apply_eq":
 "theorem periodic_orbit_apply_eq (hx : x ∈ periodicPts f) : periodicOrbit f (f x) = periodicOrbit f x :=\n  periodicOrbit_apply_iterate_eq hx 1\n#align periodic_orbit_apply_eq periodic_orbit_apply_eq\n\n",
 "not_is_periodic_pt_of_pos_of_lt_minimal_period":
 "theorem not_is_periodic_pt_of_pos_of_lt_minimal_period :\n    ∀ {n : ℕ} (n0 : n ≠ 0) (hn : n < minimalPeriod f x), ¬IsPeriodicPt f n x\n  | 0, n0, _ => (n0 rfl).elim\n  | n + 1, _, hn => fun hp => nat.succ_ne_zero _ (hp.eq_zero_of_lt_minimal_period hn)\n#align not_is_periodic_pt_of_pos_of_lt_minimal_period not_is_periodic_pt_of_pos_of_lt_minimal_period\n\n",
 "nodup_periodic_orbit":
 "theorem nodup_periodic_orbit : (periodicOrbit f x).nodup :=\n  by\n  rw [periodic_orbit, Cycle.nodup_coe_iff, List.nodup_map_iff_inj_on (List.nodup_range _)]\n  intro m hm n hn hmn\n  rw [List.mem_range] at hm hn\n  rwa [eq_iff_lt_minimal_period_of_iterate_eq hm hn] at hmn\n#align nodup_periodic_orbit nodup_periodic_orbit\n\n",
 "mul_const":
 "protected theorem mul_const (hm : IsPeriodicPt f m x) (n : ℕ) : IsPeriodicPt f (m * n) x := by\n  simp only [is_periodic_pt, iterate_mul, hm.is_fixed_pt.iterate n]\n#align mul_const mul_const\n\n",
 "mod":
 "protected theorem mod (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) : IsPeriodicPt f (m % n) x :=\n  (hn.iterate_mod_apply m).trans hm\n#align mod mod\n\n",
 "mk_mem_periodic_pts":
 "theorem mk_mem_periodic_pts (hn : 0 < n) (hx : IsPeriodicPt f n x) : x ∈ periodicPts f :=\n  ⟨n, hn, hx⟩\n#align mk_mem_periodic_pts mk_mem_periodic_pts\n\n",
 "minimal_period_pos_of_mem_periodic_pts":
 "theorem minimal_period_pos_of_mem_periodic_pts (hx : x ∈ periodicPts f) : 0 < minimalPeriod f x := by\n  simp only [minimal_period, dif_pos hx, (nat.find_spec hx).fst.lt]\n#align minimal_period_pos_of_mem_periodic_pts minimal_period_pos_of_mem_periodic_pts\n\n",
 "minimal_period_pos_iff_mem_periodic_pts":
 "theorem minimal_period_pos_iff_mem_periodic_pts : 0 < minimalPeriod f x ↔ x ∈ periodicPts f :=\n  ⟨not_imp_not.1 fun h => by simp only [minimal_period, dif_neg h, lt_irrefl 0, not_false_iff],\n    minimalPeriod_pos_of_mem_periodicPts⟩\n#align minimal_period_pos_iff_mem_periodic_pts minimal_period_pos_iff_mem_periodic_pts\n\n",
 "minimal_period_pos":
 "theorem is_periodic_pt.minimal_period_pos (hn : 0 < n) (hx : IsPeriodicPt f n x) : 0 < minimalPeriod f x :=\n  minimalPeriod_pos_of_mem_periodicPts <| mk_mem_periodicPts hn hx\n#align is_periodic_pt.minimal_period_pos is_periodic_pt.minimal_period_pos\n\n",
 "minimal_period_of_comp_eq_mul_of_coprime":
 "theorem commute.minimal_period_of_comp_eq_mul_of_coprime {g : α → α} (h : Function.Commute f g)\n    (hco : coprime (minimalPeriod f x) (minimalPeriod g x)) :\n    minimalPeriod (f ∘ g) x = minimalPeriod f x * minimalPeriod g x :=\n  by\n  apply dvd_antisymm h.minimal_period_of_comp_dvd_mul\n  suffices :\n    ∀ {f g : α → α},\n      Commute f g → coprime (minimal_period f x) (minimal_period g x) → minimal_period f x ∣ minimal_period (f ∘ g) x\n  exact hco.mul_dvd_of_dvd_of_dvd (this h hco) (h.comp_eq.symm ▸ this h.symm hco.symm)\n  clear hco h f g\n  intro f g h hco\n  refine' hco.dvd_of_dvd_mul_left (is_periodic_pt.left_of_comp h _ _).minimal_period_dvd\n  · exact (is_periodic_pt_minimal_period _ _).const_mul _\n  · exact (is_periodic_pt_minimal_period _ _).mul_const _\n#align commute.minimal_period_of_comp_eq_mul_of_coprime commute.minimal_period_of_comp_eq_mul_of_coprime\n\n",
 "minimal_period_of_comp_dvd_mul":
 "theorem commute.minimal_period_of_comp_dvd_mul {g : α → α} (h : Function.Commute f g) :\n    minimalPeriod (f ∘ g) x ∣ minimalPeriod f x * minimalPeriod g x :=\n  dvd_trans h.minimal_period_of_comp_dvd_lcm (lcm_dvd_mul _ _)\n#align commute.minimal_period_of_comp_dvd_mul commute.minimal_period_of_comp_dvd_mul\n\n",
 "minimal_period_of_comp_dvd_lcm":
 "theorem commute.minimal_period_of_comp_dvd_lcm {g : α → α} (h : Function.Commute f g) :\n    minimalPeriod (f ∘ g) x ∣ Nat.lcm (minimalPeriod f x) (minimalPeriod g x) :=\n  by\n  rw [← is_periodic_pt_iff_minimal_period_dvd]\n  exact (is_periodic_pt_minimal_period f x).comp_lcm h (is_periodic_pt_minimal_period g x)\n#align commute.minimal_period_of_comp_dvd_lcm commute.minimal_period_of_comp_dvd_lcm\n\n",
 "minimal_period_le":
 "theorem is_periodic_pt.minimal_period_le (hn : 0 < n) (hx : IsPeriodicPt f n x) : minimalPeriod f x ≤ n :=\n  by\n  rw [minimal_period, dif_pos (mk_mem_periodic_pts hn hx)]\n  exact nat.find_min' (mk_mem_periodic_pts hn hx) ⟨hn, hx⟩\n#align is_periodic_pt.minimal_period_le is_periodic_pt.minimal_period_le\n\n",
 "minimal_period_iterate_eq_div_gcd_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprivate theorem minimal_period_iterate_eq_div_gcd_aux (h : 0 < gcd (minimalPeriod f x) n) :\n    minimalPeriod («expr ^[ ]» f n) x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n :=\n  by\n  apply nat.dvd_antisymm\n  · apply is_periodic_pt.minimal_period_dvd\n    rw [is_periodic_pt, is_fixed_pt, ← iterate_mul, ← Nat.mul_div_assoc _ (gcd_dvd_left _ _), mul_comm,\n      Nat.mul_div_assoc _ (gcd_dvd_right _ _), mul_comm, iterate_mul]\n    exact (is_periodic_pt_minimal_period f x).iterate _\n  · apply coprime.dvd_of_dvd_mul_right (coprime_div_gcd_div_gcd h)\n    apply dvd_of_mul_dvd_mul_right h\n    rw [Nat.div_mul_cancel (gcd_dvd_left _ _), mul_assoc, Nat.div_mul_cancel (gcd_dvd_right _ _), mul_comm]\n    apply is_periodic_pt.minimal_period_dvd\n    rw [is_periodic_pt, is_fixed_pt, iterate_mul]\n    exact is_periodic_pt_minimal_period _ _\n#align minimal_period_iterate_eq_div_gcd_aux minimal_period_iterate_eq_div_gcd_aux\n\n",
 "minimal_period_iterate_eq_div_gcd'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem minimal_period_iterate_eq_div_gcd' (h : x ∈ periodicPts f) :\n    minimalPeriod («expr ^[ ]» f n) x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n :=\n  minimal_period_iterate_eq_div_gcd_aux <| gcd_pos_of_pos_left n (minimalPeriod_pos_iff_mem_periodicPts.mpr h)\n#align minimal_period_iterate_eq_div_gcd' minimal_period_iterate_eq_div_gcd'\n\n",
 "minimal_period_iterate_eq_div_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem minimal_period_iterate_eq_div_gcd (h : n ≠ 0) :\n    minimalPeriod («expr ^[ ]» f n) x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n :=\n  minimal_period_iterate_eq_div_gcd_aux <| gcd_pos_of_pos_right _ (nat.pos_of_ne_zero h)\n#align minimal_period_iterate_eq_div_gcd minimal_period_iterate_eq_div_gcd\n\n",
 "minimal_period_id":
 "theorem minimal_period_id : minimalPeriod id x = 1 :=\n  ((is_periodic_id _ _).minimal_period_le nat.one_pos).antisymm\n    (nat.succ_le_of_lt ((is_periodic_id _ _).minimal_period_pos nat.one_pos))\n#align minimal_period_id minimal_period_id\n\n",
 "minimal_period_eq_zero_of_nmem_periodic_pts":
 "theorem minimal_period_eq_zero_of_nmem_periodic_pts (hx : x ∉ periodicPts f) : minimalPeriod f x = 0 := by\n  simp only [minimal_period, dif_neg hx]\n#align minimal_period_eq_zero_of_nmem_periodic_pts minimal_period_eq_zero_of_nmem_periodic_pts\n\n",
 "minimal_period_eq_zero_iff_nmem_periodic_pts":
 "theorem minimal_period_eq_zero_iff_nmem_periodic_pts : minimalPeriod f x = 0 ↔ x ∉ periodicPts f := by\n  rw [← minimal_period_pos_iff_mem_periodic_pts, not_lt, nonpos_iff_eq_zero]\n#align minimal_period_eq_zero_iff_nmem_periodic_pts minimal_period_eq_zero_iff_nmem_periodic_pts\n\n",
 "minimal_period_eq_prime_pow":
 "theorem minimal_period_eq_prime_pow {p k : ℕ} [hp : Fact p.prime] (hk : ¬IsPeriodicPt f (p ^ k) x)\n    (hk1 : IsPeriodicPt f (p ^ (k + 1)) x) : minimalPeriod f x = p ^ (k + 1) := by\n  apply Nat.eq_prime_pow_of_dvd_least_prime_pow hp.out <;> rwa [← is_periodic_pt_iff_minimal_period_dvd]\n#align minimal_period_eq_prime_pow minimal_period_eq_prime_pow\n\n",
 "minimal_period_eq_prime":
 "theorem minimal_period_eq_prime {p : ℕ} [hp : Fact p.prime] (hper : IsPeriodicPt f p x) (hfix : ¬IsFixedPt f x) :\n    minimalPeriod f x = p :=\n  (hp.out.eq_one_or_self_of_dvd _ hper.minimal_period_dvd).resolve_left (mt minimalPeriod_eq_one_iff_isFixedPt.1 hfix)\n#align minimal_period_eq_prime minimal_period_eq_prime\n\n",
 "minimal_period_eq_minimal_period_iff":
 "theorem minimal_period_eq_minimal_period_iff {g : β → β} {y : β} :\n    minimalPeriod f x = minimalPeriod g y ↔ ∀ n, IsPeriodicPt f n x ↔ IsPeriodicPt g n y := by\n  simp_rw [is_periodic_pt_iff_minimal_period_dvd, dvd_right_iff_eq]\n#align minimal_period_eq_minimal_period_iff minimal_period_eq_minimal_period_iff\n\n",
 "minimal_period_dvd":
 "theorem is_periodic_pt.minimal_period_dvd (hx : IsPeriodicPt f n x) : minimalPeriod f x ∣ n :=\n  (eq_or_lt_of_le <| n.zero_le).elim (fun hn0 => hn0 ▸ dvd_zero _) fun hn0 =>\n    nat.dvd_iff_mod_eq_zero.2 <|\n      (hx.mod <| isPeriodicPt_minimalPeriod f x).eq_zero_of_lt_minimal_period <|\n        nat.mod_lt _ <| hx.minimal_period_pos hn0\n#align is_periodic_pt.minimal_period_dvd is_periodic_pt.minimal_period_dvd\n\n",
 "minimal_period_apply_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem minimal_period_apply_iterate (hx : x ∈ periodicPts f) (n : ℕ) :\n    minimalPeriod f ((«expr ^[ ]» f n) x) = minimalPeriod f x :=\n  by\n  apply\n    (is_periodic_pt.minimal_period_le (minimal_period_pos_of_mem_periodic_pts hx) _).antisymm\n      ((is_periodic_pt_of_mem_periodic_pts_of_is_periodic_pt_iterate hx\n            (is_periodic_pt_minimal_period f _)).minimal_period_le\n        (minimal_period_pos_of_mem_periodic_pts _))\n  · exact (is_periodic_pt_minimal_period f x).apply_iterate n\n  · rcases hx with ⟨m, hm, hx⟩\n    exact ⟨m, hm, hx.apply_iterate n⟩\n#align minimal_period_apply_iterate minimal_period_apply_iterate\n\n",
 "minimal_period_apply":
 "theorem minimal_period_apply (hx : x ∈ periodicPts f) : minimalPeriod f (f x) = minimalPeriod f x :=\n  minimalPeriod_apply_iterate hx 1\n#align minimal_period_apply minimal_period_apply\n\n",
 "mem_pts_of_period":
 "@[simp]\ntheorem mem_pts_of_period : x ∈ ptsOfPeriod f n ↔ IsPeriodicPt f n x :=\n  iff.rfl\n#align mem_pts_of_period mem_pts_of_period\n\n",
 "mem_periodic_pts":
 "theorem mem_periodic_pts : x ∈ periodicPts f ↔ ∃ n > 0, IsPeriodicPt f n x :=\n  iff.rfl\n#align mem_periodic_pts mem_periodic_pts\n\n",
 "mem_periodic_orbit_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem mem_periodic_orbit_iff (hx : x ∈ periodicPts f) : y ∈ periodicOrbit f x ↔ ∃ n, («expr ^[ ]» f n) x = y :=\n  by\n  simp only [periodic_orbit, Cycle.mem_coe_iff, List.mem_map, List.mem_range]\n  use fun ⟨a, ha, ha'⟩ => ⟨a, ha'⟩\n  rintro ⟨n, rfl⟩\n  use n % minimal_period f x, mod_lt _ (minimal_period_pos_of_mem_periodic_pts hx)\n  rw [iterate_mod_minimal_period_eq]\n#align mem_periodic_orbit_iff mem_periodic_orbit_iff\n\n",
 "maps_to_pts_of_period":
 "theorem semiconj.maps_to_pts_of_period {g : α → β} (h : Semiconj g fa fb) (n : ℕ) :\n    MapsTo g (ptsOfPeriod fa n) (ptsOfPeriod fb n) :=\n  (h.iterate_right n).maps_to_fixed_pts\n#align semiconj.maps_to_pts_of_period semiconj.maps_to_pts_of_period\n\n",
 "maps_to_periodic_pts":
 "theorem semiconj.maps_to_periodic_pts {g : α → β} (h : Semiconj g fa fb) : MapsTo g (periodicPts fa) (periodicPts fb) :=\n  fun x ⟨n, hn, hx⟩ => ⟨n, hn, hx.map h⟩\n#align semiconj.maps_to_periodic_pts semiconj.maps_to_periodic_pts\n\n",
 "map":
 "protected theorem map (hx : IsPeriodicPt fa n x) {g : α → β} (hg : Semiconj g fa fb) : IsPeriodicPt fb n (g x) :=\n  hx.map (hg.iterate_right n)\n#align map map\n\n",
 "left_of_comp":
 "theorem left_of_comp {g : α → α} (hco : Commute f g) (hfg : IsPeriodicPt (f ∘ g) n x) (hg : IsPeriodicPt g n x) :\n    IsPeriodicPt f n x := by\n  rw [is_periodic_pt, hco.comp_iterate] at hfg\n  exact hfg.left_of_comp hg\n#align left_of_comp left_of_comp\n\n",
 "left_of_add":
 "theorem left_of_add (hn : IsPeriodicPt f (n + m) x) (hm : IsPeriodicPt f m x) : IsPeriodicPt f n x :=\n  by\n  rw [is_periodic_pt, iterate_add] at hn\n  exact hn.left_of_comp hm\n#align left_of_add left_of_add\n\n",
 "le_of_lt_minimal_period_of_iterate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem le_of_lt_minimal_period_of_iterate_eq {m n : ℕ} (hm : m < minimalPeriod f x)\n    (hmn : («expr ^[ ]» f m) x = («expr ^[ ]» f n) x) : m ≤ n :=\n  by\n  by_contra' hmn'\n  rw [← nat.add_sub_of_le hmn'.le, add_comm, iterate_add_apply] at hmn\n  exact\n    ((is_periodic_pt.minimal_period_le (tsub_pos_of_lt hmn')\n              (is_periodic_pt_of_mem_periodic_pts_of_is_periodic_pt_iterate\n                (minimal_period_pos_iff_mem_periodic_pts.1 ((zero_le m).trans_lt hm)) hmn)).trans\n          (nat.sub_le m n)).not_lt\n      hm\n#align le_of_lt_minimal_period_of_iterate_eq le_of_lt_minimal_period_of_iterate_eq\n\n",
 "iterate_mod_minimal_period_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_mod_minimal_period_eq : («expr ^[ ]» f (n % minimalPeriod f x)) x = («expr ^[ ]» f n) x :=\n  (isPeriodicPt_minimalPeriod f x).iterate_mod_apply n\n#align iterate_mod_minimal_period_eq iterate_mod_minimal_period_eq\n\n",
 "iterate_mod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem iterate_mod_apply (h : IsPeriodicPt f n x) (m : ℕ) : («expr ^[ ]» f (m % n)) x = («expr ^[ ]» f m) x := by\n  conv_rhs => rw [← nat.mod_add_div m n, iterate_add_apply, (h.mul_const _).eq]\n#align iterate_mod_apply iterate_mod_apply\n\n",
 "iterate_minimal_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_minimal_period : («expr ^[ ]» f (minimalPeriod f x)) x = x :=\n  isPeriodicPt_minimalPeriod f x\n#align iterate_minimal_period iterate_minimal_period\n\n",
 "iterate_mem_periodic_orbit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_mem_periodic_orbit (hx : x ∈ periodicPts f) (n : ℕ) : («expr ^[ ]» f n) x ∈ periodicOrbit f x :=\n  (mem_periodicOrbit_iff hx).2 ⟨n, rfl⟩\n#align iterate_mem_periodic_orbit iterate_mem_periodic_orbit\n\n",
 "iterate_add_minimal_period_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem iterate_add_minimal_period_eq : («expr ^[ ]» f (n + minimalPeriod f x)) x = («expr ^[ ]» f n) x :=\n  by\n  rw [iterate_add_apply]\n  congr\n  exact is_periodic_pt_minimal_period f x\n#align iterate_add_minimal_period_eq iterate_add_minimal_period_eq\n\n",
 "iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem iterate (hf : IsPeriodicPt f n x) (m : ℕ) : IsPeriodicPt («expr ^[ ]» f m) n x :=\n  by\n  rw [is_periodic_pt, ← iterate_mul, mul_comm, iterate_mul]\n  exact hf.is_fixed_pt.iterate m\n#align iterate iterate\n\n",
 "is_periodic_pt_zero":
 "/-- Any point is a periodic point of period `0`. -/\ntheorem is_periodic_pt_zero (f : α → α) (x : α) : IsPeriodicPt f 0 x :=\n  isFixedPt_id x\n#align is_periodic_pt_zero is_periodic_pt_zero\n\n",
 "is_periodic_pt_of_mem_periodic_pts_of_is_periodic_pt_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem is_periodic_pt_of_mem_periodic_pts_of_is_periodic_pt_iterate (hx : x ∈ periodicPts f)\n    (hm : IsPeriodicPt f m ((«expr ^[ ]» f n) x)) : IsPeriodicPt f m x :=\n  by\n  rcases hx with ⟨r, hr, hr'⟩\n  convert(hm.apply_iterate ((n / r + 1) * r - n)).eq\n  suffices n ≤ (n / r + 1) * r by rw [← iterate_add_apply, nat.sub_add_cancel this, iterate_mul, (hr'.iterate _).eq]\n  rw [add_mul, one_mul]\n  exact (Nat.lt_div_mul_add hr).le\n#align is_periodic_pt_of_mem_periodic_pts_of_is_periodic_pt_iterate is_periodic_pt_of_mem_periodic_pts_of_is_periodic_pt_iterate\n\n",
 "is_periodic_pt_minimal_period":
 "theorem is_periodic_pt_minimal_period (f : α → α) (x : α) : IsPeriodicPt f (minimalPeriod f x) x :=\n  by\n  delta minimal_period\n  split_ifs with hx\n  · exact (nat.find_spec hx).snd\n  · exact is_periodic_pt_zero f x\n#align is_periodic_pt_minimal_period is_periodic_pt_minimal_period\n\n",
 "is_periodic_pt_iff_minimal_period_dvd":
 "theorem is_periodic_pt_iff_minimal_period_dvd : IsPeriodicPt f n x ↔ minimalPeriod f x ∣ n :=\n  ⟨IsPeriodicPt.minimalPeriod_dvd, fun h => (isPeriodicPt_minimalPeriod f x).trans_dvd h⟩\n#align is_periodic_pt_iff_minimal_period_dvd is_periodic_pt_iff_minimal_period_dvd\n\n",
 "is_periodic_pt":
 "/-\nCopyright (c) 2020 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem is_fixed_pt.is_periodic_pt (hf : IsFixedPt f x) (n : ℕ) : IsPeriodicPt f n x :=\n  hf.iterate n\n#align is_fixed_pt.is_periodic_pt is_fixed_pt.is_periodic_pt\n\n",
 "is_periodic_id":
 "/-- For the identity map, all points are periodic. -/\ntheorem is_periodic_id (n : ℕ) (x : α) : IsPeriodicPt id n x :=\n  (isFixedPt_id x).is_periodic_pt n\n#align is_periodic_id is_periodic_id\n\n",
 "is_fixed_pt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\nprotected theorem is_fixed_pt (hf : IsPeriodicPt f n x) : IsFixedPt («expr ^[ ]» f n) x :=\n  hf\n#align is_fixed_pt is_fixed_pt\n\n",
 "is_fixed_point_iff_minimal_period_eq_one":
 "theorem is_fixed_point_iff_minimal_period_eq_one : minimalPeriod f x = 1 ↔ IsFixedPt f x :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rw [← iterate_one f]\n    refine' Function.IsPeriodicPt.isFixedPt _\n    rw [← h]\n    exact is_periodic_pt_minimal_period f x\n  ·\n    exact\n      ((h.is_periodic_pt 1).minimal_period_le nat.one_pos).antisymm\n        (nat.succ_le_of_lt ((h.is_periodic_pt 1).minimal_period_pos nat.one_pos))\n#align is_fixed_point_iff_minimal_period_eq_one is_fixed_point_iff_minimal_period_eq_one\n\n",
 "gcd":
 "protected theorem gcd (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) : IsPeriodicPt f (m.gcd n) x :=\n  by\n  revert hm hn\n  refine' Nat.gcd.induction m n (fun n h0 hn => _) fun m n hm ih hm hn => _\n  · rwa [Nat.gcd_zero_left]\n  · rw [Nat.gcd_rec]\n    exact ih (hn.mod hm) hm\n#align gcd gcd\n\n",
 "eq_zero_of_lt_minimal_period":
 "theorem is_periodic_pt.eq_zero_of_lt_minimal_period (hx : IsPeriodicPt f n x) (hn : n < minimalPeriod f x) : n = 0 :=\n  Eq.symm <| (eq_or_lt_of_le <| n.zero_le).resolve_right fun hn0 => not_lt.2 (hx.minimal_period_le hn0) hn\n#align is_periodic_pt.eq_zero_of_lt_minimal_period is_periodic_pt.eq_zero_of_lt_minimal_period\n\n",
 "eq_of_lt_minimal_period_of_iterate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem eq_of_lt_minimal_period_of_iterate_eq {m n : ℕ} (hm : m < minimalPeriod f x) (hn : n < minimalPeriod f x)\n    (hmn : («expr ^[ ]» f m) x = («expr ^[ ]» f n) x) : m = n :=\n  (le_of_lt_minimalPeriod_of_iterate_eq hm hmn).antisymm (le_of_lt_minimalPeriod_of_iterate_eq hn hmn.symm)\n#align eq_of_lt_minimal_period_of_iterate_eq eq_of_lt_minimal_period_of_iterate_eq\n\n",
 "eq_of_apply_eq_same":
 "/-- If `f` sends two periodic points `x` and `y` of the same positive period to the same point,\nthen `x = y`. For a similar statement about points of different periods see `eq_of_apply_eq`. -/\ntheorem eq_of_apply_eq_same (hx : IsPeriodicPt f n x) (hy : IsPeriodicPt f n y) (hn : 0 < n) (h : f x = f y) : x = y :=\n  by rw [← hx.eq, ← hy.eq, ← iterate_pred_comp_of_pos f hn, comp_app, h]\n#align eq_of_apply_eq_same eq_of_apply_eq_same\n\n",
 "eq_of_apply_eq":
 "/-- If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. -/\ntheorem eq_of_apply_eq (hx : IsPeriodicPt f m x) (hy : IsPeriodicPt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) :\n    x = y :=\n  (hx.mul_const n).eq_of_apply_eq_same (hy.const_mul m) (mul_pos hm hn) h\n#align eq_of_apply_eq eq_of_apply_eq\n\n",
 "eq_iff_lt_minimal_period_of_iterate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem eq_iff_lt_minimal_period_of_iterate_eq {m n : ℕ} (hm : m < minimalPeriod f x) (hn : n < minimalPeriod f x) :\n    («expr ^[ ]» f m) x = («expr ^[ ]» f n) x ↔ m = n :=\n  ⟨eq_of_lt_minimalPeriod_of_iterate_eq hm hn, congr_arg _⟩\n#align eq_iff_lt_minimal_period_of_iterate_eq eq_iff_lt_minimal_period_of_iterate_eq\n\n",
 "directed_pts_of_period_pnat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem directed_pts_of_period_pnat (f : α → α) : Directed (· ⊆ ·) fun n : «exprℕ+» => ptsOfPeriod f n := fun m n =>\n  ⟨m * n, fun x hx => hx.mul_const n, fun x hx => hx.const_mul m⟩\n#align directed_pts_of_period_pnat directed_pts_of_period_pnat\n\n",
 "const_mul":
 "protected theorem const_mul (hm : IsPeriodicPt f m x) (n : ℕ) : IsPeriodicPt f (n * m) x := by\n  simp only [mul_comm n, hm.mul_const n]\n#align const_mul const_mul\n\n",
 "comp_lcm":
 "theorem comp_lcm {g : α → α} (hco : Commute f g) (hf : IsPeriodicPt f m x) (hg : IsPeriodicPt g n x) :\n    IsPeriodicPt (f ∘ g) (Nat.lcm m n) x :=\n  (hf.trans_dvd <| Nat.dvd_lcm_left _ _).comp hco (hg.trans_dvd <| Nat.dvd_lcm_right _ _)\n#align comp_lcm comp_lcm\n\n",
 "comp":
 "theorem comp {g : α → α} (hco : Commute f g) (hf : IsPeriodicPt f n x) (hg : IsPeriodicPt g n x) :\n    IsPeriodicPt (f ∘ g) n x := by\n  rw [is_periodic_pt, hco.comp_iterate]\n  exact hf.comp hg\n#align comp comp\n\n",
 "bij_on_pts_of_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem bij_on_pts_of_period (f : α → α) {n : ℕ} (hn : 0 < n) : BijOn f (ptsOfPeriod f n) (ptsOfPeriod f n) :=\n  ⟨(Commute.refl f).maps_to_pts_of_period n, fun x hx y hy hxy => hx.eq_of_apply_eq_same hy hn hxy, fun x hx =>\n    ⟨(«expr ^[ ]» f n.pred) x, hx.apply_iterate _, by rw [← comp_app f, comp_iterate_pred_of_pos f hn, hx.eq]⟩⟩\n#align bij_on_pts_of_period bij_on_pts_of_period\n\n",
 "bij_on_periodic_pts":
 "theorem bij_on_periodic_pts : BijOn f (periodicPts f) (periodicPts f) :=\n  unionᵢ_pNat_ptsOfPeriod f ▸ bijOn_unionᵢ_of_directed (directed_ptsOfPeriod_pNat f) fun i => bijOn_ptsOfPeriod f i.pos\n#align bij_on_periodic_pts bij_on_periodic_pts\n\n",
 "bUnion_pts_of_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem bUnion_pts_of_period :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ptsOfPeriod f n) =\n      periodicPts f :=\n  Set.ext fun x => by simp [mem_periodic_pts]\n#align bUnion_pts_of_period bUnion_pts_of_period\n\n",
 "apply_iterate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem apply_iterate (hx : IsPeriodicPt f n x) (m : ℕ) : IsPeriodicPt f n ((«expr ^[ ]» f m) x) :=\n  hx.map <| Commute.iterate_self f m\n#align apply_iterate apply_iterate\n\n",
 "apply":
 "protected theorem apply (hx : IsPeriodicPt f n x) : IsPeriodicPt f n (f x) :=\n  hx.apply_iterate 1\n#align apply apply\n\n",
 "add":
 "protected theorem add (hn : IsPeriodicPt f n x) (hm : IsPeriodicPt f m x) : IsPeriodicPt f (n + m) x :=\n  by\n  rw [is_periodic_pt, iterate_add]\n  exact hn.comp hm\n#align add add\n\n",
 "Union_pnat_pts_of_period":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_pnat_pts_of_period :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (ptsOfPeriod f n) =\n      periodicPts f :=\n  supᵢ_subtype.trans <| bUnion_ptsOfPeriod f\n#align Union_pnat_pts_of_period Union_pnat_pts_of_period\n\n"}