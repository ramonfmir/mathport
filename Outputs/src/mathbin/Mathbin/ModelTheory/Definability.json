{"union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem definable.union {f g : Set (α → M)} (hf : A.definable L f) (hg : A.definable L g) : A.definable L (f ∪ g) :=\n  by\n  rcases hf with ⟨φ, hφ⟩\n  rcases hg with ⟨θ, hθ⟩\n  refine' ⟨«expr ⊔ » φ θ, _⟩\n  ext\n  rw [hφ, hθ, mem_set_of_eq, formula.realize_sup, mem_union, mem_set_of_eq, mem_set_of_eq]\n#align definable.union definable.union\n\n",
 "sdiff":
 "@[simp]\ntheorem definable.sdiff {s t : Set (α → M)} (hs : A.definable L s) (ht : A.definable L t) : A.definable L (s \\ t) :=\n  hs.inter ht.compl\n#align definable.sdiff definable.sdiff\n\n",
 "preimage_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem definable.preimage_comp (f : α → β) {s : Set (α → M)} (h : A.definable L s) :\n    A.definable L («expr ⁻¹' » (fun g : β → M => g ∘ f) s) :=\n  by\n  obtain ⟨φ, rfl⟩ := h\n  refine' ⟨φ.relabel f, _⟩\n  ext\n  simp only [Set.preimage_setOf_eq, mem_set_of_eq, formula.realize_relabel]\n#align definable.preimage_comp definable.preimage_comp\n\n",
 "not_mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem not_mem_bot {x : α → M} : ¬x ∈ («expr⊥» : L.definable_set A α) :=\n  not_mem_empty x\n#align not_mem_bot not_mem_bot\n\n",
 "mono":
 "theorem definable.mono (hAs : A.definable L s) (hAB : A ⊆ B) : B.definable L s :=\n  by\n  rw [definable_iff_empty_definable_with_params] at *\n  exact hAs.map_expansion (L.Lhom_with_constants_map (Set.inclusion hAB))\n#align definable.mono definable.mono\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top : x ∈ («expr⊤» : L.definable_set A α) :=\n  mem_univ x\n#align mem_top mem_top\n\n",
 "mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem mem_sup : x ∈ «expr ⊔ » s t ↔ x ∈ s ∨ x ∈ t :=\n  iff.rfl\n#align mem_sup mem_sup\n\n",
 "mem_sdiff":
 "@[simp]\ntheorem mem_sdiff : x ∈ s \\ t ↔ x ∈ s ∧ ¬x ∈ t :=\n  iff.rfl\n#align mem_sdiff mem_sdiff\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf : x ∈ «expr ⊓ » s t ↔ x ∈ s ∧ x ∈ t :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem mem_compl : x ∈ «expr ᶜ» s ↔ ¬x ∈ s :=\n  iff.rfl\n#align mem_compl mem_compl\n\n",
 "map_expansion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem definable.map_expansion {L' : FirstOrder.Language} [L'.Structure M] (h : A.definable L s) (φ : «expr →ᴸ » L L')\n    [φ.is_expansion_on M] : A.definable L' s := by\n  obtain ⟨ψ, rfl⟩ := h\n  refine' ⟨(φ.add_constants A).on_formula ψ, _⟩\n  ext x\n  simp only [mem_set_of_eq, Lhom.realize_on_formula]\n#align definable.map_expansion definable.map_expansion\n\n",
 "le_iff":
 "theorem le_iff : s ≤ t ↔ (s : Set (α → M)) ≤ (t : Set (α → M)) :=\n  iff.rfl\n#align le_iff le_iff\n\n",
 "inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem definable.inter {f g : Set (α → M)} (hf : A.definable L f) (hg : A.definable L g) : A.definable L (f ∩ g) :=\n  by\n  rcases hf with ⟨φ, rfl⟩\n  rcases hg with ⟨θ, rfl⟩\n  refine' ⟨«expr ⊓ » φ θ, _⟩\n  ext\n  simp\n#align definable.inter definable.inter\n\n",
 "image_comp_sum_inl_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- This lemma is only intended as a helper for `definable.image_comp. -/\ntheorem definable.image_comp_sum_inl_fin (m : ℕ) {s : Set (Sum α (Fin m) → M)} (h : A.definable L s) :\n    A.definable L («expr '' » (fun g : Sum α (Fin m) → M => g ∘ Sum.inl) s) :=\n  by\n  obtain ⟨φ, rfl⟩ := h\n  refine' ⟨(bounded_formula.relabel id φ).exs, _⟩\n  ext x\n  simp only [Set.mem_image, mem_set_of_eq, bounded_formula.realize_exs, bounded_formula.realize_relabel,\n    function.comp.right_id, Fin.castAdd_zero, Fin.cast_refl]\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    exact ⟨y ∘ Sum.inr, (congr (congr rfl (Sum.elim_comp_inl_inr y).symm) (funext finZeroElim)).mp hy⟩\n  · rintro ⟨y, hy⟩\n    exact ⟨Sum.elim x y, (congr rfl (funext finZeroElim)).mp hy, Sum.elim_comp_inl _ _⟩\n#align definable.image_comp_sum_inl_fin definable.image_comp_sum_inl_fin\n\n",
 "image_comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem definable.image_comp_equiv {s : Set (β → M)} (h : A.definable L s) (f : «expr ≃ » α β) :\n    A.definable L («expr '' » (fun g : β → M => g ∘ f) s) :=\n  by\n  refine' (congr rfl _).mp (h.preimage_comp f.symm)\n  rw [image_eq_preimage_of_inverse]\n  · intro i\n    ext b\n    simp only [Function.comp_apply, Equiv.apply_symm_apply]\n  · intro i\n    ext a\n    simp\n#align definable.image_comp_equiv definable.image_comp_equiv\n\n",
 "image_comp_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Shows that definability is closed under finite projections. -/\ntheorem definable.image_comp_embedding {s : Set (β → M)} (h : A.definable L s) (f : «expr ↪ » α β) [Finite β] :\n    A.definable L («expr '' » (fun g : β → M => g ∘ f) s) := by\n  classical\n    cases nonempty_fintype β\n    refine'\n      (congr rfl (ext fun x => _)).mp\n        (((h.image_comp_equiv (Equiv.Set.sumCompl (range f))).image_comp_equiv\n              (Equiv.sumCongr (Equiv.ofInjective f f.injective) (Fintype.equivFin _).symm)).image_comp_sum_inl_fin\n          _)\n    simp only [mem_preimage, mem_image, exists_exists_and_eq_and]\n    refine' exists_congr fun y => and_congr_right fun ys => Eq.congr_left (funext fun a => _)\n    simp\n#align definable.image_comp_embedding definable.image_comp_embedding\n\n",
 "image_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Shows that definability is closed under finite projections. -/\ntheorem definable.image_comp {s : Set (β → M)} (h : A.definable L s) (f : α → β) [Finite α] [Finite β] :\n    A.definable L («expr '' » (fun g : β → M => g ∘ f) s) := by\n  classical\n    cases nonempty_fintype α\n    cases nonempty_fintype β\n    have h :=\n      (((h.image_comp_equiv (Equiv.Set.sumCompl (range f))).image_comp_equiv\n                (Equiv.sumCongr (_root_.equiv.refl _) (Fintype.equivFin _).symm)).image_comp_sum_inl_fin\n            _).preimage_comp\n        (range_splitting f)\n    have h' : A.definable L { x : α → M | ∀ a, x a = x (range_splitting f (range_factorization f a)) } :=\n      by\n      have h' : ∀ a, A.definable L { x : α → M | x a = x (range_splitting f (range_factorization f a)) } :=\n        by\n        refine' fun a => ⟨(var a).equal (var (range_splitting f (range_factorization f a))), ext _⟩\n        simp\n      refine' (congr rfl (ext _)).mp (definable_finset_bInter h' Finset.univ)\n      simp\n    refine' (congr rfl (ext fun x => _)).mp (h.inter h')\n    simp only [Equiv.coe_trans, mem_inter_iff, mem_preimage, mem_image, exists_exists_and_eq_and, mem_set_of_eq]\n    constructor\n    · rintro ⟨⟨y, ys, hy⟩, hx⟩\n      refine' ⟨y, ys, _⟩\n      ext a\n      rw [hx a, ← Function.comp_apply x, ← hy]\n      simp\n    · rintro ⟨y, ys, rfl⟩\n      refine' ⟨⟨y, ys, _⟩, fun a => _⟩\n      · ext\n        simp [Set.apply_rangeSplitting f]\n      · rw [Function.comp_apply, Function.comp_apply, apply_range_splitting f, range_factorization_coe]\n#align definable.image_comp definable.image_comp\n\n",
 "empty_definable_iff":
 "theorem empty_definable_iff : (∅ : Set M).definable L s ↔ ∃ φ : L.formula α, s = setOf φ.realize :=\n  by\n  rw [definable, Equiv.exists_congr_left (Lequiv.add_empty_constants L (∅ : Set M)).on_formula]\n  simp\n#align empty_definable_iff empty_definable_iff\n\n",
 "definable_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem definable_univ : A.definable L (univ : Set (α → M)) :=\n  ⟨«expr⊤», by\n    ext\n    simp⟩\n#align definable_univ definable_univ\n\n",
 "definable_iff_empty_definable_with_params":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem definable_iff_empty_definable_with_params :\n    A.definable L s ↔ (∅ : Set M).definable (language.with_constants L A) s :=\n  empty_definable_iff.symm\n#align definable_iff_empty_definable_with_params definable_iff_empty_definable_with_params\n\n",
 "definable_finset_sup":
 "theorem definable_finset_sup {ι : Type _} {f : ∀ i : ι, Set (α → M)} (hf : ∀ i, A.definable L (f i)) (s : Finset ι) :\n    A.definable L (s.sup f) := by\n  classical\n    refine' Finset.induction definable_empty (fun i s is h => _) s\n    rw [Finset.sup_insert]\n    exact (hf i).union h\n#align definable_finset_sup definable_finset_sup\n\n",
 "definable_finset_inf":
 "theorem definable_finset_inf {ι : Type _} {f : ∀ i : ι, Set (α → M)} (hf : ∀ i, A.definable L (f i)) (s : Finset ι) :\n    A.definable L (s.inf f) := by\n  classical\n    refine' Finset.induction definable_univ (fun i s is h => _) s\n    rw [Finset.inf_insert]\n    exact (hf i).inter h\n#align definable_finset_inf definable_finset_inf\n\n",
 "definable_finset_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem definable_finset_bUnion {ι : Type _} {f : ∀ i : ι, Set (α → M)} (hf : ∀ i, A.definable L (f i)) (s : Finset ι) :\n    A.definable L\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :=\n  by\n  rw [← Finset.sup_set_eq_bunionᵢ]\n  exact definable_finset_sup hf s\n#align definable_finset_bUnion definable_finset_bUnion\n\n",
 "definable_finset_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem definable_finset_bInter {ι : Type _} {f : ∀ i : ι, Set (α → M)} (hf : ∀ i, A.definable L (f i)) (s : Finset ι) :\n    A.definable L\n      («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i)) :=\n  by\n  rw [← Finset.inf_set_eq_interᵢ]\n  exact definable_finset_inf hf s\n#align definable_finset_bInter definable_finset_bInter\n\n",
 "definable_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem definable_empty : A.definable L (∅ : Set (α → M)) :=\n  ⟨«expr⊥», by\n    ext\n    simp⟩\n#align definable_empty definable_empty\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem definable.compl {s : Set (α → M)} (hf : A.definable L s) : A.definable L («expr ᶜ» s) :=\n  by\n  rcases hf with ⟨φ, hφ⟩\n  refine' ⟨φ.not, _⟩\n  rw [hφ]\n  rfl\n#align definable.compl definable.compl\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp, norm_cast]\ntheorem coe_top : ((«expr⊤» : L.definable_set A α) : Set (α → M)) = univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp, norm_cast]\ntheorem coe_sup (s t : L.definable_set A α) : (↑(«expr ⊔ » s t) : Set (α → M)) = s ∪ t :=\n  rfl\n#align coe_sup coe_sup\n\n",
 "coe_sdiff":
 "@[simp, norm_cast]\ntheorem coe_sdiff (s t : L.definable_set A α) : (↑(s \\ t) : Set (α → M)) = s \\ t :=\n  rfl\n#align coe_sdiff coe_sdiff\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf (s t : L.definable_set A α) : (↑(«expr ⊓ » s t) : Set (α → M)) = s ∩ t :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp, norm_cast]\ntheorem coe_compl (s : L.definable_set A α) : (↑(«expr ᶜ» s) : Set (α → M)) = «expr ᶜ» s :=\n  rfl\n#align coe_compl coe_compl\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp, norm_cast]\ntheorem coe_bot : ((«expr⊥» : L.definable_set A α) : Set (α → M)) = ∅ :=\n  rfl\n#align coe_bot coe_bot\n\n"}