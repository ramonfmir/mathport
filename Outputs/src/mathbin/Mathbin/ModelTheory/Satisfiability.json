{"trans":
 "@[trans]\ntheorem semantically_equivalent.trans {φ ψ θ : L.bounded_formula α n} (h1 : T.semantically_equivalent φ ψ)\n    (h2 : T.semantically_equivalent ψ θ) : T.semantically_equivalent φ θ := fun M v xs =>\n  by\n  have h1' := h1 M v xs\n  have h2' := h2 M v xs\n  rw [bounded_formula.realize_iff] at *\n  exact ⟨h2'.1 ∘ h1'.1, h1'.2 ∘ h2'.2⟩\n#align semantically_equivalent.trans semantically_equivalent.trans\n\n",
 "symm":
 "@[symm]\ntheorem semantically_equivalent.symm {φ ψ : L.bounded_formula α n} (h : T.semantically_equivalent φ ψ) :\n    T.semantically_equivalent ψ φ := fun M v xs =>\n  by\n  rw [bounded_formula.realize_iff, iff.comm, ← bounded_formula.realize_iff]\n  exact h M v xs\n#align semantically_equivalent.symm semantically_equivalent.symm\n\n",
 "sup_semantically_equivalent_not_inf_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem sup_semantically_equivalent_not_inf_not :\n    T.semantically_equivalent («expr ⊔ » φ ψ) («expr ⊓ » φ.not ψ.not).not :=\n  φ.sup_semantically_equivalent_not_inf_not ψ\n#align sup_semantically_equivalent_not_inf_not sup_semantically_equivalent_not_inf_not\n\n",
 "semantically_equivalent_to_prenex":
 "theorem semantically_equivalent_to_prenex (φ : L.bounded_formula α n) :\n    (∅ : L.Theory).semantically_equivalent φ φ.to_prenex := fun M v xs => by rw [realize_iff, realize_to_prenex]\n#align semantically_equivalent_to_prenex semantically_equivalent_to_prenex\n\n",
 "semantically_equivalent_not_not":
 "theorem semantically_equivalent_not_not : T.semantically_equivalent φ φ.not.not :=\n  φ.semantically_equivalent_not_not\n#align semantically_equivalent_not_not semantically_equivalent_not_not\n\n",
 "semantically_equivalent_all_lift_at":
 "theorem semantically_equivalent_all_lift_at : T.semantically_equivalent φ (φ.lift_at 1 n).all := fun M v xs =>\n  by\n  skip\n  rw [realize_iff, realize_all_lift_at_one_self]\n#align semantically_equivalent_all_lift_at semantically_equivalent_all_lift_at\n\n",
 "refl":
 "@[refl]\ntheorem semantically_equivalent.refl (φ : L.bounded_formula α n) : T.semantically_equivalent φ φ := fun M v xs => by\n  rw [bounded_formula.realize_iff]\n#align semantically_equivalent.refl semantically_equivalent.refl\n\n",
 "realize_sentence_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem realize_sentence_iff (h : T.is_complete) (φ : L.sentence) (M : Type _) [L.Structure M]\n    [models_bounded_formula M T] [nonempty M] : models_bounded_formula M φ ↔ models_bounded_formula T φ :=\n  by\n  cases' h.2 φ with hφ hφn\n  · exact iff_of_true (hφ.realize_sentence M) hφ\n  · exact iff_of_false ((sentence.realize_not M).1 (hφn.realize_sentence M)) ((h.models_not_iff φ).1 hφn)\n#align realize_sentence_iff realize_sentence_iff\n\n",
 "realize_sentence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem models_bounded_formula.realize_sentence {φ : L.sentence} (h : models_bounded_formula T φ) (M : Type _)\n    [L.Structure M] [models_bounded_formula M T] [nonempty M] : models_bounded_formula M φ :=\n  by\n  rw [models_iff_not_satisfiable] at h\n  contrapose! h\n  have : models_bounded_formula M (T ∪ {formula.not φ}) :=\n    by\n    simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp, sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, infer_instance⟩\n  exact model.is_satisfiable M\n#align models_bounded_formula.realize_sentence models_bounded_formula.realize_sentence\n\n",
 "realize_iff":
 "theorem semantically_equivalent.realize_iff {φ ψ : L.formula α} {M : Type max u v} [ne : nonempty M]\n    [str : L.Structure M] (hM : T.model M) (h : T.semantically_equivalent φ ψ) {v : α → M} :\n    φ.realize v ↔ ψ.realize v :=\n  h.realize_bd_iff\n#align semantically_equivalent.realize_iff semantically_equivalent.realize_iff\n\n",
 "realize_bd_iff":
 "theorem semantically_equivalent.realize_bd_iff {φ ψ : L.bounded_formula α n} {M : Type max u v} [ne : nonempty M]\n    [str : L.Structure M] [hM : T.model M] (h : T.semantically_equivalent φ ψ) {v : α → M} {xs : fin n → M} :\n    φ.realize v xs ↔ ψ.realize v xs :=\n  bounded_formula.realize_iff.1 (h (Model.of T M) v xs)\n#align semantically_equivalent.realize_bd_iff semantically_equivalent.realize_bd_iff\n\n",
 "not":
 "protected theorem semantically_equivalent.not {φ ψ : L.bounded_formula α n} (h : T.semantically_equivalent φ ψ) :\n    T.semantically_equivalent φ.not ψ.not :=\n  by\n  simp_rw [semantically_equivalent, models_bounded_formula, bounded_formula.realize_iff, bounded_formula.realize_not]\n  exact fun M v xs => not_congr h.realize_bd_iff\n#align semantically_equivalent.not semantically_equivalent.not\n\n",
 "mono":
 "theorem is_satisfiable.mono (h : T'.is_satisfiable) (hs : T ⊆ T') : T.is_satisfiable :=\n  ⟨(Theory.model.mono (Model.is_model h.some) hs).bundled⟩\n#align is_satisfiable.mono is_satisfiable.mono\n\n",
 "models_sentence_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem models_sentence_of_mem {φ : L.sentence} (h : φ ∈ T) : models_bounded_formula T φ :=\n  models_sentence_iff.2 fun _ => realize_sentence_of_mem T h\n#align models_sentence_of_mem models_sentence_of_mem\n\n",
 "models_sentence_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem models_sentence_iff {φ : L.sentence} :\n    models_bounded_formula T φ ↔ ∀ M : Model.{u, v, max u v} T, models_bounded_formula M φ :=\n  models_formula_iff.trans (forall_congr' fun M => unique.forall_iff)\n#align models_sentence_iff models_sentence_iff\n\n",
 "models_not_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem models_not_iff (h : T.is_complete) (φ : L.sentence) :\n    models_bounded_formula T φ.not ↔ ¬models_bounded_formula T φ :=\n  by\n  cases' h.2 φ with hφ hφn\n  · simp only [hφ, not_true, iff_false_iff]\n    rw [models_sentence_iff, not_forall]\n    refine' ⟨h.1.some, _⟩\n    simp only [sentence.realize_not, not_not]\n    exact models_sentence_iff.1 hφ _\n  · simp only [hφn, true_iff_iff]\n    intro hφ\n    rw [models_sentence_iff] at *\n    exact hφn h.1.some (hφ _)\n#align models_not_iff models_not_iff\n\n",
 "models_iff_not_satisfiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem models_iff_not_satisfiable (φ : L.sentence) : models_bounded_formula T φ ↔ ¬is_satisfiable (T ∪ {φ.not}) :=\n  by\n  rw [models_sentence_iff, is_satisfiable]\n  refine'\n    ⟨fun h1 h2 =>\n      (sentence.realize_not _).1\n        (realize_sentence_of_mem (T ∪ {formula.not φ}) (Set.subset_union_right _ _ (Set.mem_singleton _)))\n        (h1 (h2.some.subtheory_Model (Set.subset_union_left _ _))),\n      fun h M => _⟩\n  contrapose! h\n  rw [← sentence.realize_not] at h\n  refine'\n    ⟨{  carrier := M\n        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => _⟩ }⟩\n  rw [Set.mem_singleton_iff.1 h']\n  exact h\n#align models_iff_not_satisfiable models_iff_not_satisfiable\n\n",
 "models_formula_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\n-- input using \\|= or \\vDash, but not using \\models\ntheorem models_formula_iff {φ : L.formula α} :\n    models_bounded_formula T φ ↔ ∀ (M : Model.{u, v, max u v} T) (v : α → M), φ.realize v :=\n  forall_congr' fun M => forall_congr' fun v => unique.forall_iff\n#align models_formula_iff models_formula_iff\n\n",
 "mem_or_not_mem":
 "theorem mem_or_not_mem (φ : L.sentence) : φ ∈ L.complete_theory M ∨ φ.not ∈ L.complete_theory M := by\n  simp_rw [complete_theory, Set.mem_setOf_eq, sentence.realize, formula.realize_not, or_not]\n#align mem_or_not_mem mem_or_not_mem\n\n",
 "mem_of_models":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem is_maximal.mem_of_models (h : T.is_maximal) {φ : L.sentence} (hφ : models_bounded_formula T φ) : φ ∈ T :=\n  by\n  refine' (h.mem_or_not_mem φ).resolve_right fun con => _\n  rw [models_iff_not_satisfiable, Set.union_singleton, Set.insert_eq_of_mem con] at hφ\n  exact hφ h.1\n#align is_maximal.mem_of_models is_maximal.mem_of_models\n\n",
 "mem_iff_models":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem is_maximal.mem_iff_models (h : T.is_maximal) (φ : L.sentence) : φ ∈ T ↔ models_bounded_formula T φ :=\n  ⟨models_sentence_of_mem, h.mem_of_models⟩\n#align is_maximal.mem_iff_models is_maximal.mem_iff_models\n\n",
 "is_satisfiable_union_distinct_constants_theory_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem is_satisfiable_union_distinct_constants_theory_of_infinite (T : L.Theory) (s : set α) (M : Type w')\n    [L.Structure M] [Theory.model M T] [Infinite M] :\n    ((L.Lhom_with_constants α).on_Theory T ∪ L.distinct_constants_theory s).is_satisfiable := by\n  classical\n    rw [distinct_constants_theory_eq_Union, Set.union_unionᵢ, is_satisfiable_directed_union_iff]\n    ·\n      exact fun t =>\n        is_satisfiable_union_distinct_constants_theory_of_card_le T _ M\n          ((lift_le_aleph_0.2 (finset_card_lt_aleph_0 _).le).trans (aleph_0_le_lift.2 (aleph_0_le_mk M)))\n    · refine' (monotone_const.union (monotone_distinct_constants_theory.comp _)).directed_le\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact set.monotone_image.comp fun _ _ => Finset.coe_subset.2\n#align\n  is_satisfiable_union_distinct_constants_theory_of_infinite is_satisfiable_union_distinct_constants_theory_of_infinite\n\n",
 "is_satisfiable_union_distinct_constants_theory_of_card_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem is_satisfiable_union_distinct_constants_theory_of_card_le (T : L.Theory) (s : set α) (M : Type w') [nonempty M]\n    [L.Structure M] [Theory.model M T] (h : cardinal.lift.{w'} (cardinal.mk s) ≤ cardinal.lift.{w} (cardinal.mk M)) :\n    ((L.Lhom_with_constants α).on_Theory T ∪ L.distinct_constants_theory s).is_satisfiable :=\n  by\n  haveI : inhabited M := Classical.inhabited_of_nonempty infer_instance\n  rw [cardinal.lift_mk_le'] at h\n  letI : (constants_on α).Structure M := constants_on.Structure (function.extend coe h.some default)\n  have : Theory.model M ((L.Lhom_with_constants α).on_Theory T ∪ L.distinct_constants_theory s) :=\n    by\n    refine' ((Lhom.on_Theory_model _ _).2 infer_instance).union _\n    rw [model_distinct_constants_theory]\n    refine' fun a as b bs ab => _\n    rw [← subtype.coe_mk a as, ← subtype.coe_mk b bs, ← subtype.ext_iff]\n    exact\n      h.some.injective\n        ((subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))\n  exact model.is_satisfiable M\n#align\n  is_satisfiable_union_distinct_constants_theory_of_card_le is_satisfiable_union_distinct_constants_theory_of_card_le\n\n",
 "is_satisfiable_on_Theory_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\ntheorem is_satisfiable_on_Theory_iff {L' : language.{w, w'}} {φ : «expr →ᴸ » L L'} (h : φ.injective) :\n    (φ.on_Theory T).is_satisfiable ↔ T.is_satisfiable := by\n  classical\n    refine' ⟨is_satisfiable_of_is_satisfiable_on_Theory φ, fun h' => _⟩\n    haveI : inhabited h'.some := classical.inhabited_of_nonempty'\n    exact model.is_satisfiable (h'.some.default_expansion h)\n#align is_satisfiable_on_Theory_iff is_satisfiable_on_Theory_iff\n\n",
 "is_satisfiable_of_is_satisfiable_on_Theory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\ntheorem is_satisfiable_of_is_satisfiable_on_Theory {L' : language.{w, w'}} (φ : «expr →ᴸ » L L')\n    (h : (φ.on_Theory T).is_satisfiable) : T.is_satisfiable :=\n  model.is_satisfiable (h.some.reduct φ)\n#align is_satisfiable_of_is_satisfiable_on_Theory is_satisfiable_of_is_satisfiable_on_Theory\n\n",
 "is_satisfiable_iff_is_finitely_satisfiable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/-- The Compactness Theorem of first-order logic: A theory is satisfiable if and only if it is\nfinitely satisfiable. -/\ntheorem is_satisfiable_iff_is_finitely_satisfiable {T : L.Theory} : T.is_satisfiable ↔ T.is_finitely_satisfiable :=\n  ⟨Theory.is_satisfiable.is_finitely_satisfiable, fun h => by\n    classical\n      set M : ∀ T0 : Finset T, Type max u v := fun T0 =>\n        (h (T0.map (Function.Embedding.subtype fun x => x ∈ T)) T0.map_subtype_subset).some with hM\n      let M' := filter.product (↑(ultrafilter.of (filter.at_top : filter (Finset T)))) M\n      have h' : Theory.model M' T := by\n        refine' ⟨fun φ hφ => _⟩\n        rw [ultraproduct.sentence_realize]\n        refine'\n          filter.eventually.filter_mono (ultrafilter.of_le _)\n            (filter.eventually_at_top.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T)) _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe, subtype.exists,\n          subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩\n      exact ⟨Model.of T M'⟩⟩\n#align is_satisfiable_iff_is_finitely_satisfiable is_satisfiable_iff_is_finitely_satisfiable\n\n",
 "is_satisfiable_empty":
 "theorem is_satisfiable_empty (L : language.{u, v}) : is_satisfiable (∅ : L.Theory) :=\n  ⟨default⟩\n#align is_satisfiable_empty is_satisfiable_empty\n\n",
 "is_satisfiable_directed_union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_satisfiable_directed_union_iff {ι : Type _} [nonempty ι] {T : ι → L.Theory} (h : Directed (· ⊆ ·) T) :\n    Theory.is_satisfiable\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)) ↔\n      ∀ i, (T i).is_satisfiable :=\n  by\n  refine' ⟨fun h' i => h'.mono (Set.subset_unionᵢ _ _), fun h' => _⟩\n  rw [is_satisfiable_iff_is_finitely_satisfiable, is_finitely_satisfiable]\n  intro T0 hT0\n  obtain ⟨i, hi⟩ := h.exists_mem_subset_of_finset_subset_bUnion hT0\n  exact (h' i).mono hi\n#align is_satisfiable_directed_union_iff is_satisfiable_directed_union_iff\n\n",
 "is_satisfiable_Union_iff_is_satisfiable_Union_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem is_satisfiable_Union_iff_is_satisfiable_Union_finset {ι : Type _} (T : ι → L.Theory) :\n    is_satisfiable\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)) ↔\n      ∀ s : Finset ι,\n        is_satisfiable\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (T i)) :=\n  by\n  classical\n    refine' ⟨fun h s => h.mono (Set.unionᵢ_mono fun _ => Set.unionᵢ_subset_iff.2 fun _ => refl _), fun h => _⟩\n    rw [is_satisfiable_iff_is_finitely_satisfiable]\n    intro s hs\n    rw [set.Union_eq_Union_finset] at hs\n    obtain ⟨t, ht⟩ := Directed.exists_mem_subset_of_finset_subset_bunionᵢ _ hs\n    · exact (h t).mono ht\n    · exact Monotone.directed_le fun t1 t2 h => Set.unionᵢ_mono fun _ => Set.unionᵢ_mono' fun h1 => ⟨h h1, refl _⟩\n#align is_satisfiable_Union_iff_is_satisfiable_Union_finset is_satisfiable_Union_iff_is_satisfiable_Union_finset\n\n",
 "is_satisfiable":
 "theorem is_satisfiable [nonempty M] : (L.complete_theory M).is_satisfiable :=\n  Theory.model.is_satisfiable M\n#align is_satisfiable is_satisfiable\n\n",
 "is_maximal":
 "theorem is_maximal [nonempty M] : (L.complete_theory M).is_maximal :=\n  ⟨is_satisfiable L M, mem_or_not_mem L M⟩\n#align is_maximal is_maximal\n\n",
 "is_finitely_satisfiable":
 "theorem is_satisfiable.is_finitely_satisfiable (h : T.is_satisfiable) : T.is_finitely_satisfiable := fun _ => h.mono\n#align is_satisfiable.is_finitely_satisfiable is_satisfiable.is_finitely_satisfiable\n\n",
 "is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- The Łoś–Vaught Test : a criterion for categorical theories to be complete. -/\ntheorem categorical.is_complete (h : κ.categorical T) (h1 : cardinal.aleph_0 ≤ κ)\n    (h2 : cardinal.lift.{w} L.card ≤ cardinal.lift.{max u v} κ) (hS : T.is_satisfiable)\n    (hT : ∀ M : Theory.Model.{u, v, max u v} T, Infinite M) : T.is_complete :=\n  ⟨hS, fun φ => by\n    obtain ⟨N, hN⟩ := Theory.exists_model_card_eq ⟨hS.some, hT hS.some⟩ κ h1 h2\n    rw [Theory.models_sentence_iff, Theory.models_sentence_iff]\n    by_contra con\n    push_neg  at con\n    obtain ⟨⟨MF, hMF⟩, MT, hMT⟩ := con\n    rw [sentence.realize_not, not_not] at hMT\n    refine' hMF _\n    haveI := hT MT\n    haveI := hT MF\n    obtain ⟨NT, MNT, hNT⟩ := exists_elementarily_equivalent_card_eq L MT κ h1 h2\n    obtain ⟨NF, MNF, hNF⟩ := exists_elementarily_equivalent_card_eq L MF κ h1 h2\n    obtain ⟨TF⟩ := h (MNT.to_Model T) (MNF.to_Model T) hNT hNF\n    exact ((MNT.realize_sentence φ).trans ((TF.realize_sentence φ).trans (MNF.realize_sentence φ).symm)).1 hMT⟩\n#align categorical.is_complete categorical.is_complete\n\n",
 "inf_semantically_equivalent_not_sup_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem inf_semantically_equivalent_not_sup_not :\n    T.semantically_equivalent («expr ⊓ » φ ψ) («expr ⊔ » φ.not ψ.not).not :=\n  φ.inf_semantically_equivalent_not_sup_not ψ\n#align inf_semantically_equivalent_not_sup_not inf_semantically_equivalent_not_sup_not\n\n",
 "induction_on_sup_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_qf.induction_on_sup_not {P : L.bounded_formula α n → Prop} {φ : L.bounded_formula α n} (h : is_qf φ)\n    (hf : P («expr⊥» : L.bounded_formula α n)) (ha : ∀ ψ : L.bounded_formula α n, is_atomic ψ → P ψ)\n    (hsup : ∀ {φ₁ φ₂} (h₁ : P φ₁) (h₂ : P φ₂), P («expr ⊔ » φ₁ φ₂)) (hnot : ∀ {φ} (h : P φ), P φ.not)\n    (hse : ∀ {φ₁ φ₂ : L.bounded_formula α n} (h : Theory.semantically_equivalent ∅ φ₁ φ₂), P φ₁ ↔ P φ₂) : P φ :=\n  is_qf.rec_on h hf ha fun φ₁ φ₂ _ _ h1 h2 => (hse (φ₁.imp_semantically_equivalent_not_sup φ₂)).2 (hsup (hnot h1) h2)\n#align is_qf.induction_on_sup_not is_qf.induction_on_sup_not\n\n",
 "induction_on_inf_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem is_qf.induction_on_inf_not {P : L.bounded_formula α n → Prop} {φ : L.bounded_formula α n} (h : is_qf φ)\n    (hf : P («expr⊥» : L.bounded_formula α n)) (ha : ∀ ψ : L.bounded_formula α n, is_atomic ψ → P ψ)\n    (hinf : ∀ {φ₁ φ₂} (h₁ : P φ₁) (h₂ : P φ₂), P («expr ⊓ » φ₁ φ₂)) (hnot : ∀ {φ} (h : P φ), P φ.not)\n    (hse : ∀ {φ₁ φ₂ : L.bounded_formula α n} (h : Theory.semantically_equivalent ∅ φ₁ φ₂), P φ₁ ↔ P φ₂) : P φ :=\n  h.induction_on_sup_not hf ha\n    (fun φ₁ φ₂ h1 h2 => (hse (φ₁.sup_semantically_equivalent_not_inf_not φ₂)).2 (hnot (hinf (hnot h1) (hnot h2))))\n    (fun _ => hnot) fun _ _ => hse\n#align is_qf.induction_on_inf_not is_qf.induction_on_inf_not\n\n",
 "induction_on_exists_not":
 "theorem induction_on_exists_not {P : ∀ {m}, L.bounded_formula α m → Prop} (φ : L.bounded_formula α n)\n    (hqf : ∀ {m} {ψ : L.bounded_formula α m}, is_qf ψ → P ψ)\n    (hnot : ∀ {m} {φ : L.bounded_formula α m} (h : P φ), P φ.not)\n    (hex : ∀ {m} {φ : L.bounded_formula α (m + 1)} (h : P φ), P φ.ex)\n    (hse : ∀ {m} {φ₁ φ₂ : L.bounded_formula α m} (h : Theory.semantically_equivalent ∅ φ₁ φ₂), P φ₁ ↔ P φ₂) : P φ :=\n  φ.induction_on_all_ex (fun _ _ => hqf)\n    (fun _ φ hφ => (hse φ.all_semantically_equivalent_not_ex_not).2 (hnot (hex (hnot hφ)))) (fun _ _ => hex)\n    fun _ _ _ => hse\n#align induction_on_exists_not induction_on_exists_not\n\n",
 "induction_on_all_ex":
 "theorem induction_on_all_ex {P : ∀ {m}, L.bounded_formula α m → Prop} (φ : L.bounded_formula α n)\n    (hqf : ∀ {m} {ψ : L.bounded_formula α m}, is_qf ψ → P ψ)\n    (hall : ∀ {m} {ψ : L.bounded_formula α (m + 1)} (h : P ψ), P ψ.all)\n    (hex : ∀ {m} {φ : L.bounded_formula α (m + 1)} (h : P φ), P φ.ex)\n    (hse : ∀ {m} {φ₁ φ₂ : L.bounded_formula α m} (h : Theory.semantically_equivalent ∅ φ₁ φ₂), P φ₁ ↔ P φ₂) : P φ :=\n  by\n  suffices h' : ∀ {m} {φ : L.bounded_formula α m}, φ.is_prenex → P φ\n  · exact (hse φ.semantically_equivalent_to_prenex).2 (h' φ.to_prenex_is_prenex)\n  intro m φ hφ\n  induction' hφ with _ _ hφ _ _ _ hφ _ _ _ hφ\n  · exact hqf hφ\n  · exact hall hφ\n  · exact hex hφ\n#align induction_on_all_ex induction_on_all_ex\n\n",
 "imp_semantically_equivalent_not_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem imp_semantically_equivalent_not_sup : T.semantically_equivalent (φ.imp ψ) («expr ⊔ » φ.not ψ) :=\n  φ.imp_semantically_equivalent_not_sup ψ\n#align imp_semantically_equivalent_not_sup imp_semantically_equivalent_not_sup\n\n",
 "imp":
 "protected theorem semantically_equivalent.imp {φ ψ φ' ψ' : L.bounded_formula α n} (h : T.semantically_equivalent φ ψ)\n    (h' : T.semantically_equivalent φ' ψ') : T.semantically_equivalent (φ.imp φ') (ψ.imp ψ') :=\n  by\n  simp_rw [semantically_equivalent, models_bounded_formula, bounded_formula.realize_iff, bounded_formula.realize_imp]\n  exact fun M v xs => imp_congr h.realize_bd_iff h'.realize_bd_iff\n#align semantically_equivalent.imp semantically_equivalent.imp\n\n",
 "exists_model_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem exists_model_card_eq (h : ∃ M : Model.{u, v, max u v} T, Infinite M) (κ : cardinal.{w})\n    (h1 : cardinal.aleph_0 ≤ κ) (h2 : cardinal.lift.{w} L.card ≤ cardinal.lift.{max u v} κ) :\n    ∃ N : Model.{u, v, w} T, cardinal.mk N = κ := by\n  cases' h with M MI\n  obtain ⟨N, hN, rfl⟩ := exists_elementarily_equivalent_card_eq L M κ h1 h2\n  haveI : nonempty N := hN.nonempty\n  exact ⟨hN.Theory_model.bundled, rfl⟩\n#align exists_model_card_eq exists_model_card_eq\n\n",
 "exists_large_model_of_infinite_model":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- Any theory with an infinite model has arbitrarily large models. -/\ntheorem exists_large_model_of_infinite_model (T : L.Theory) (κ : cardinal.{w}) (M : Type w') [L.Structure M]\n    [Theory.model M T] [Infinite M] : ∃ N : Model.{_, _, max u v w} T, cardinal.lift.{max u v w} κ ≤ cardinal.mk N :=\n  by\n  obtain ⟨N⟩ := is_satisfiable_union_distinct_constants_theory_of_infinite T (Set.univ : set κ.out) M\n  refine' ⟨(N.is_model.mono (Set.subset_union_left _ _)).bundled.reduct _, _⟩\n  haveI : Theory.model N (distinct_constants_theory _ _) := N.is_model.mono (Set.subset_union_right _ _)\n  simp only [Model.reduct_carrier, coe_of, Model.carrier_eq_coe]\n  refine' trans (lift_le.2 (le_of_eq (cardinal.mk_out κ).symm)) _\n  rw [← mk_univ]\n  refine' (card_le_of_model_distinct_constants_theory L Set.univ N).trans (lift_le.1 _)\n  rw [lift_lift]\n#align exists_large_model_of_infinite_model exists_large_model_of_infinite_model\n\n",
 "exists_elementary_embedding_card_eq_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementary_embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- A version of The Downward Löwenheim–Skolem theorem where the structure `N` elementarily embeds\ninto `M`, but is not by type a substructure of `M`, and thus can be chosen to belong to the universe\nof the cardinal `κ`.\n -/\ntheorem exists_elementary_embedding_card_eq_of_le (M : Type w') [L.Structure M] [nonempty M] (κ : cardinal.{w})\n    (h1 : cardinal.aleph_0 ≤ κ) (h2 : lift.{w} L.card ≤ cardinal.lift.{max u v} κ)\n    (h3 : lift.{w'} κ ≤ cardinal.lift.{w} (cardinal.mk M)) :\n    ∃ N : bundled L.Structure, nonempty (elementary_embedding N L M) ∧ cardinal.mk N = κ :=\n  by\n  obtain ⟨S, _, hS⟩ := exists_elementary_substructure_card_eq L ∅ κ h1 (by simp) h2 h3\n  have : Small.{w} S := by\n    rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')\n  refine'\n    ⟨(equivShrink S).bundled_induced L, ⟨S.subtype.comp (equiv.bundled_induced_equiv L _).symm.to_elementary_embedding⟩,\n      lift_inj.1 (trans _ hS)⟩\n  simp only [equiv.bundled_induced_α, lift_mk_shrink']\n#align exists_elementary_embedding_card_eq_of_le exists_elementary_embedding_card_eq_of_le\n\n",
 "exists_elementary_embedding_card_eq_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementary_embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The Upward Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the cardinalities of `L`\nand an infinite `L`-structure `M`, then `M` has an elementary extension of cardinality `κ`. -/\ntheorem exists_elementary_embedding_card_eq_of_ge (M : Type w') [L.Structure M] [iM : Infinite M] (κ : cardinal.{w})\n    (h1 : cardinal.lift.{w} L.card ≤ cardinal.lift.{max u v} κ)\n    (h2 : cardinal.lift.{w} (cardinal.mk M) ≤ cardinal.lift.{w'} κ) :\n    ∃ N : bundled L.Structure, nonempty (elementary_embedding M L N) ∧ cardinal.mk N = κ :=\n  by\n  obtain ⟨N0, hN0⟩ := (L.elementary_diagram M).exists_large_model_of_infinite_model κ M\n  let f0 := elementary_embedding.of_models_elementary_diagram L M N0\n  rw [← lift_le.{max w w', max u v}, lift_lift, lift_lift] at h2\n  obtain ⟨N, ⟨NN0⟩, hN⟩ :=\n    exists_elementary_embedding_card_eq_of_le (language.with_constants L M) N0 κ\n      (aleph_0_le_lift.1 ((aleph_0_le_lift.2 (aleph_0_le_mk M)).trans h2)) _ (hN0.trans _)\n  · letI := (Lhom_with_constants L M).reduct N\n    haveI h : Theory.model N (L.elementary_diagram M) :=\n      (NN0.Theory_model_iff (L.elementary_diagram M)).2 infer_instance\n    refine' ⟨bundled.of N, ⟨_⟩, hN⟩\n    apply elementary_embedding.of_models_elementary_diagram L M N\n  · simp only [card_with_constants, lift_add, lift_lift]\n    rw [add_comm, add_eq_max (aleph_0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n    rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1\n    exact ⟨h2, h1⟩\n  · rw [← lift_umax', lift_id]\n#align exists_elementary_embedding_card_eq_of_ge exists_elementary_embedding_card_eq_of_ge\n\n",
 "exists_elementary_embedding_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementary_embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementary_embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the cardinalities of `L`\nand an infinite `L`-structure `M`, then there is an elementary embedding in the appropriate\ndirection between then `M` and a structure of cardinality `κ`. -/\ntheorem exists_elementary_embedding_card_eq (M : Type w') [L.Structure M] [iM : Infinite M] (κ : cardinal.{w})\n    (h1 : cardinal.aleph_0 ≤ κ) (h2 : lift.{w} L.card ≤ cardinal.lift.{max u v} κ) :\n    ∃ N : bundled L.Structure,\n      (nonempty (elementary_embedding N L M) ∨ nonempty (elementary_embedding M L N)) ∧ cardinal.mk N = κ :=\n  by\n  cases le_or_gt (lift.{w'} κ) (cardinal.lift.{w} (cardinal.mk M))\n  · obtain ⟨N, hN1, hN2⟩ := exists_elementary_embedding_card_eq_of_le L M κ h1 h2 h\n    exact ⟨N, or.inl hN1, hN2⟩\n  · obtain ⟨N, hN1, hN2⟩ := exists_elementary_embedding_card_eq_of_ge L M κ h2 (le_of_lt h)\n    exact ⟨N, or.inr hN1, hN2⟩\n#align exists_elementary_embedding_card_eq exists_elementary_embedding_card_eq\n\n",
 "exists_elementarily_equivalent_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- A consequence of the Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the\ncardinalities of `L` and an infinite `L`-structure `M`, then there is a structure of cardinality `κ`\nelementarily equivalent to `M`. -/\ntheorem exists_elementarily_equivalent_card_eq (M : Type w') [L.Structure M] [Infinite M] (κ : cardinal.{w})\n    (h1 : cardinal.aleph_0 ≤ κ) (h2 : lift.{w} L.card ≤ cardinal.lift.{max u v} κ) :\n    ∃ N : category_theory.bundled L.Structure, elementarily_equivalent M L N ∧ cardinal.mk N = κ :=\n  by\n  obtain ⟨N, NM | MN, hNκ⟩ := exists_elementary_embedding_card_eq L M κ h1 h2\n  · exact ⟨N, NM.some.elementarily_equivalent.symm, hNκ⟩\n  · exact ⟨N, MN.some.elementarily_equivalent, hNκ⟩\n#align exists_elementarily_equivalent_card_eq exists_elementarily_equivalent_card_eq\n\n",
 "ex_semantically_equivalent_not_all_not":
 "theorem ex_semantically_equivalent_not_all_not (φ : L.bounded_formula α (n + 1)) :\n    T.semantically_equivalent φ.ex φ.not.all.not := fun M v xs => by simp\n#align ex_semantically_equivalent_not_all_not ex_semantically_equivalent_not_all_not\n\n",
 "ex":
 "protected theorem semantically_equivalent.ex {φ ψ : L.bounded_formula α (n + 1)} (h : T.semantically_equivalent φ ψ) :\n    T.semantically_equivalent φ.ex ψ.ex :=\n  by\n  simp_rw [semantically_equivalent, models_bounded_formula, bounded_formula.realize_iff, bounded_formula.realize_ex]\n  exact fun M v xs => exists_congr fun a => h.realize_bd_iff\n#align semantically_equivalent.ex semantically_equivalent.ex\n\n",
 "empty_infinite_Theory_is_complete":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem empty_infinite_Theory_is_complete : language.empty.infinite_theory.is_complete :=\n  (empty_Theory_categorical (cardinal.aleph_0) _).is_complete (cardinal.aleph_0) _ le_rfl (by simp)\n    ⟨Theory.model.bundled ((model_infinite_theory_iff language.empty).2 nat.infinite)⟩ fun M =>\n    (model_infinite_theory_iff language.empty).1 M.is_model\n#align empty_infinite_Theory_is_complete empty_infinite_Theory_is_complete\n\n",
 "empty_Theory_categorical":
 "theorem empty_Theory_categorical (T : language.empty.Theory) : κ.categorical T := fun M N hM hN => by\n  rw [empty.nonempty_equiv_iff, hM, hN]\n#align empty_Theory_categorical empty_Theory_categorical\n\n",
 "all_semantically_equivalent_not_ex_not":
 "theorem all_semantically_equivalent_not_ex_not (φ : L.bounded_formula α (n + 1)) :\n    T.semantically_equivalent φ.all φ.not.ex.not := fun M v xs => by simp\n#align all_semantically_equivalent_not_ex_not all_semantically_equivalent_not_ex_not\n\n",
 "all":
 "protected theorem semantically_equivalent.all {φ ψ : L.bounded_formula α (n + 1)} (h : T.semantically_equivalent φ ψ) :\n    T.semantically_equivalent φ.all ψ.all :=\n  by\n  simp_rw [semantically_equivalent, models_bounded_formula, bounded_formula.realize_iff, bounded_formula.realize_all]\n  exact fun M v xs => forall_congr' fun a => h.realize_bd_iff\n#align semantically_equivalent.all semantically_equivalent.all\n\n"}