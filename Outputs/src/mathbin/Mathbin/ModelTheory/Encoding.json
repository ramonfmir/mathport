{"list_encode_sigma_injective":
 "theorem list_encode_sigma_injective : function.injective fun φ : Σn, L.bounded_formula α n => φ.2.list_encode :=\n  BoundedFormula.encoding.encode_injective\n#align list_encode_sigma_injective list_encode_sigma_injective\n\n",
 "list_encode_injective":
 "theorem list_encode_injective : function.injective (listEncode : L.term α → List (Sum α (Σi, L.functions i))) :=\n  Term.encoding.encode_injective\n#align list_encode_injective list_encode_injective\n\n",
 "list_decode_encode_list":
 "@[simp]\ntheorem list_decode_encode_list (l : List (Σn, L.bounded_formula α n)) :\n    (listDecode (l.bind fun φ => φ.2.list_encode)).1 = l.head :=\n  by\n  suffices h :\n    ∀ (φ : Σn, L.bounded_formula α n) (l),\n      (list_decode (list_encode φ.2 ++ l)).1 = φ ∧ (list_decode (list_encode φ.2 ++ l)).2.1 = l\n  · induction' l with φ l lih\n    · rw [list.nil_bind]\n      simp [list_decode]\n    · rw [cons_bind, (h φ _).1, head_cons]\n  · rintro ⟨n, φ⟩\n    induction' φ with _ _ _ _ _ _ _ ts _ _ _ ih1 ih2 _ _ ih <;> intro l\n    · rw [list_encode, singleton_append, list_decode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [list_encode, cons_append, cons_append, list_decode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [list_encode, cons_append, cons_append, singleton_append, cons_append, list_decode]\n      · have h :\n          ∀ i : Fin φ_l,\n            ((list.map Sum.getLeft\n                      (list.map\n                          (fun i : Fin φ_l =>\n                            Sum.inl\n                              (⟨(⟨φ_n, Rel φ_R ts⟩ : Σn, L.bounded_formula α n).fst, ts i⟩ :\n                                Σn, L.term (Sum α (Fin n))))\n                          (fin_range φ_l) ++\n                        l)).nth\n                  ↑i).join =\n              some ⟨_, ts i⟩ :=\n          by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right, nth_eq_some,\n            length_append, length_map, length_fin_range]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [nth_le_append, nth_le_map]\n          ·\n            simp only [Sum.getLeft, nth_le_fin_range, Fin.eta, Function.comp_apply, eq_self_iff_true, heq_iff_eq,\n              and_self_iff]\n          · exact lt_of_lt_of_le i.is_lt (ge_of_eq (length_fin_range _))\n          · rw [length_map, length_fin_range]\n            exact i.2\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [eq_self_iff_true, heq_iff_eq, true_and_iff]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (option.get h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_fin_range, nat.sub_self, drop, drop_eq_nil_of_le,\n          nil_append]\n        rw [length_map, length_fin_range]\n    · rw [list_encode, list.append_assoc, cons_append, list_decode]\n      simp only [subtype.val_eq_coe] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigma_imp, dif_pos rfl]\n      exact ⟨rfl, rfl⟩\n    · rw [list_encode, cons_append, list_decode]\n      simp only\n      simp only [subtype.val_eq_coe] at *\n      rw [(ih _).1, (ih _).2, sigma_all]\n      exact ⟨rfl, rfl⟩\n#align list_decode_encode_list list_decode_encode_list\n\n",
 "card_sigma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem card_sigma :\n    cardinal.mk (Σn, L.term (Sum α (Fin n))) = max (cardinal.aleph_0) (cardinal.mk (Sum α (Σi, L.functions i))) :=\n  by\n  refine' le_antisymm _ _\n  · rw [mk_sigma]\n    refine' (sum_le_supr_lift _).trans _\n    rw [mk_nat, lift_aleph_0, mul_eq_max_of_aleph_0_le_left le_rfl, max_le_iff, csupᵢ_le_iff' (bdd_above_range _)]\n    · refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (cardinal.mk α)), lift_add, add_assoc,\n        lift_lift, lift_lift, mk_fin, lift_nat_cast]\n      exact add_le_add_right (nat_lt_aleph_0 _).le _\n    · rw [← one_le_iff_ne_zero]\n      refine' trans _ (le_csupᵢ (bdd_above_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩\n  · rw [max_le_iff, ← infinite_iff]\n    refine' ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => _, _⟩\n    · cases ij\n      rfl\n    · rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩) fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, eq_self_iff_true, heq_iff_eq, true_and_iff] at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, nat.zero_ne_one, false_and_iff] at h\n          exact h.elim\n        · simp only [Sum.elim_inr, Sum.elim_inl, nat.one_ne_zero, false_and_iff] at h\n          exact h.elim\n        · simp only [Sum.elim_inr, eq_self_iff_true, heq_iff_eq, true_and_iff] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]\n#align card_sigma card_sigma\n\n",
 "card_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem card_le :\n    cardinal.mk (Σn, L.bounded_formula α n) ≤\n      max (cardinal.aleph_0) (Cardinal.lift.{max u v} (cardinal.mk α) + Cardinal.lift.{u'} L.card) :=\n  by\n  refine' lift_le.1 (bounded_formula.encoding.card_le_card_list.trans _)\n  rw [encoding_Γ, mk_list_eq_max_mk_aleph_0, lift_max, lift_aleph_0, lift_max, lift_aleph_0, max_le_iff]\n  refine' ⟨_, le_max_left _ _⟩\n  rw [mk_sum, term.card_sigma, mk_sum, ← add_eq_max le_rfl, mk_sum, mk_nat]\n  simp only [lift_add, lift_lift, lift_aleph_0]\n  rw [← add_assoc, add_comm, ← add_assoc, ← add_assoc, aleph_0_add_aleph_0, add_assoc, add_eq_max le_rfl, add_assoc,\n    card, symbols, mk_sum, lift_add, lift_lift, lift_lift]\n#align card_le card_le\n\n"}