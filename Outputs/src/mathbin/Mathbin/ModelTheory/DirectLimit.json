{"unify_sigma_mk_self":
 "@[simp]\ntheorem unify_sigma_mk_self {α : Type _} {i : ι} {x : α → G i} :\n    (unify f (sigma.mk i ∘ x) i fun j ⟨a, hj⟩ => trans (le_of_eq hj.symm) (refl _)) = x :=\n  by\n  ext a\n  simp only [unify, directed_system.map_self]\n#align unify_sigma_mk_self unify_sigma_mk_self\n\n",
 "rel_map_unify_equiv":
 "theorem rel_map_unify_equiv {n : ℕ} (R : L.relations n) (x : fin n → Σi, G i) (i j : ι)\n    (hi : i ∈ upperBounds (range (sigma.fst ∘ x))) (hj : j ∈ upperBounds (range (sigma.fst ∘ x))) :\n    rel_map R (unify f x i hi) = rel_map R (unify f x j hj) :=\n  by\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  rw [← (f i k ik).map_rel, comp_unify, ← (f j k jk).map_rel, comp_unify]\n#align rel_map_unify_equiv rel_map_unify_equiv\n\n",
 "rel_map_quotient_mk_sigma_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n@[simp]\ntheorem rel_map_quotient_mk_sigma_mk {n : ℕ} {R : L.relations n} {i : ι} {x : fin n → G i} :\n    (rel_map R fun a => («expr⟦ ⟧» ⟨i, x a⟩ : direct_limit G f)) = rel_map R x :=\n  by\n  rw [rel_map_quotient_mk]\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i (Classical.choose (fintype.bdd_above_range fun a : fin n => i))\n  rw [rel_map_equiv_unify G f R (fun a => ⟨i, x a⟩) i, unify_sigma_mk_self]\n#align rel_map_quotient_mk_sigma_mk rel_map_quotient_mk_sigma_mk\n\n",
 "rel_map_equiv_unify":
 "theorem rel_map_equiv_unify {n : ℕ} (R : L.relations n) (x : fin n → Σi, G i) (i : ι)\n    (hi : i ∈ upperBounds (range (sigma.fst ∘ x))) :\n    @rel_map _ _ (sigma_structure G f) _ R x = rel_map R (unify f x i hi) :=\n  rel_map_unify_equiv G f R x (Classical.choose (fintype.bdd_above_range fun a => (x a).1)) i _ hi\n#align rel_map_equiv_unify rel_map_equiv_unify\n\n",
 "of_f":
 "@[simp]\ntheorem of_f {i j : ι} {hij : i ≤ j} {x : G i} : of L ι G f j (f i j hij x) = of L ι G f i x :=\n  by\n  simp only [of_apply, quotient.eq]\n  refine' setoid.symm ⟨j, hij, refl j, _⟩\n  simp only [directed_system.map_self]\n#align of_f of_f\n\n",
 "of_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n@[simp]\ntheorem of_apply {i : ι} {x : G i} : of L ι G f i x = «expr⟦ ⟧» ⟨i, x⟩ :=\n  rfl\n#align of_apply of_apply\n\n",
 "map_self":
 "/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n/-- A copy of `directed_system.map_self` specialized to `L`-embeddings, as otherwise the\n`λ i j h, f i j h` can confuse the simplifier. -/\ntheorem map_self [directed_system G fun i j h => f i j h] (i x h) : f i i h x = x :=\n  directed_system.map_self (fun i j h => f i j h) i x h\n#align map_self map_self\n\n",
 "map_map":
 "/-- A copy of `directed_system.map_map` specialized to `L`-embeddings, as otherwise the\n`λ i j h, f i j h` can confuse the simplifier. -/\ntheorem map_map [directed_system G fun i j h => f i j h] {i j k} (hij hjk x) :\n    f j k hjk (f i j hij x) = f i k (le_trans hij hjk) x :=\n  directed_system.map_map (fun i j h => f i j h) hij hjk x\n#align map_map map_map\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\ntheorem lift_unique (F : language.embedding (direct_limit G f) L P) (x) :\n    F x =\n      lift L ι G f (fun i => F.comp <| of L ι G f i) (fun i j hij x => by rw [F.comp_apply, F.comp_apply, of_f]) x :=\n  direct_limit.induction_on x fun i x => by rw [lift_of] <;> rfl\n#align lift_unique lift_unique\n\n",
 "lift_quotient_mk_sigma_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n@[simp]\ntheorem lift_quotient_mk_sigma_mk {i} (x : G i) : lift L ι G f g Hg («expr⟦ ⟧» ⟨i, x⟩) = (g i) x :=\n  by\n  change (lift L ι G f g Hg).to_fun («expr⟦ ⟧» ⟨i, x⟩) = _\n  simp only [lift, quotient.lift_mk]\n#align lift_quotient_mk_sigma_mk lift_quotient_mk_sigma_mk\n\n",
 "lift_of":
 "theorem lift_of {i} (x : G i) : lift L ι G f g Hg (of L ι G f i x) = g i x := by simp\n#align lift_of lift_of\n\n",
 "induction_on":
 "@[elab_as_elim]\nprotected theorem induction_on {C : direct_limit G f → Prop} (z : direct_limit G f) (ih : ∀ i x, C (of L ι G f i x)) :\n    C z :=\n  let ⟨i, x, h⟩ := exists_of z\n  h ▸ ih i x\n#align induction_on induction_on\n\n",
 "fun_map_unify_equiv":
 "theorem fun_map_unify_equiv {n : ℕ} (F : L.functions n) (x : fin n → Σi, G i) (i j : ι)\n    (hi : i ∈ upperBounds (range (sigma.fst ∘ x))) (hj : j ∈ upperBounds (range (sigma.fst ∘ x))) :\n    (⟨i, fun_map F (unify f x i hi)⟩ : Σi, G i) ≈ ⟨j, fun_map F (unify f x j hj)⟩ :=\n  by\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  refine' ⟨k, ik, jk, _⟩\n  rw [(f i k ik).map_fun, (f j k jk).map_fun, comp_unify, comp_unify]\n#align fun_map_unify_equiv fun_map_unify_equiv\n\n",
 "fun_map_quotient_mk_sigma_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n@[simp]\ntheorem fun_map_quotient_mk_sigma_mk {n : ℕ} {F : L.functions n} {i : ι} {x : fin n → G i} :\n    (fun_map F fun a => («expr⟦ ⟧» ⟨i, x a⟩ : direct_limit G f)) = «expr⟦ ⟧» ⟨i, fun_map F x⟩ :=\n  by\n  simp only [Function.comp_apply, fun_map_quotient_mk, quotient.eq]\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i (Classical.choose (fintype.bdd_above_range fun a : fin n => i))\n  refine' ⟨k, jk, ik, _⟩\n  simp only [embedding.map_fun, comp_unify]\n  rfl\n#align fun_map_quotient_mk_sigma_mk fun_map_quotient_mk_sigma_mk\n\n",
 "fun_map_equiv_unify":
 "theorem fun_map_equiv_unify {n : ℕ} (F : L.functions n) (x : fin n → Σi, G i) (i : ι)\n    (hi : i ∈ upperBounds (range (sigma.fst ∘ x))) :\n    @fun_map _ _ (sigma_structure G f) _ F x ≈ ⟨_, fun_map F (unify f x i hi)⟩ :=\n  fun_map_unify_equiv G f F x (Classical.choose (fintype.bdd_above_range fun a => (x a).1)) i _ hi\n#align fun_map_equiv_unify fun_map_equiv_unify\n\n",
 "exists_unify_eq":
 "theorem exists_unify_eq {α : Type _} [fintype α] {x y : α → Σi, G i} (xy : x ≈ y) :\n    ∃ (i : ι)(hx : i ∈ upperBounds (range (sigma.fst ∘ x)))(hy : i ∈ upperBounds (range (sigma.fst ∘ y))),\n      unify f x i hx = unify f y i hy :=\n  by\n  obtain ⟨i, hi⟩ := fintype.bdd_above_range (sum.elim (fun a => (x a).1) fun a => (y a).1)\n  rw [sum.elim_range, upperBounds_union] at hi\n  simp_rw [← function.comp_apply sigma.fst _] at hi\n  exact ⟨i, hi.1, hi.2, funext fun a => (equiv_iff G f _ _).1 (xy a)⟩\n#align exists_unify_eq exists_unify_eq\n\n",
 "exists_quotient_mk_sigma_mk_eq":
 "theorem exists_quotient_mk_sigma_mk_eq {α : Type _} [fintype α] (x : α → direct_limit G f) :\n    ∃ (i : ι)(y : α → G i), x = Quotient.mk'' ∘ sigma.mk i ∘ y :=\n  by\n  obtain ⟨i, hi⟩ := fintype.bdd_above_range fun a => (x a).out.1\n  refine' ⟨i, unify f (quotient.out ∘ x) i hi, _⟩\n  ext a\n  rw [quotient.eq_mk_iff_out, Function.comp_apply, unify, equiv_iff G f _]\n  · simp only [directed_system.map_self]\n  · rfl\n#align exists_quotient_mk_sigma_mk_eq exists_quotient_mk_sigma_mk_eq\n\n",
 "exists_of":
 "/-- Every element of the direct limit corresponds to some element in\nsome component of the directed system. -/\ntheorem exists_of (z : direct_limit G f) : ∃ i x, of L ι G f i x = z :=\n  ⟨z.out.1, z.out.2, by simp⟩\n#align exists_of exists_of\n\n",
 "equiv_iff":
 "theorem equiv_iff {x y : Σi, G i} {i : ι} (hx : x.1 ≤ i) (hy : y.1 ≤ i) : x ≈ y ↔ (f x.1 i hx) x.2 = (f y.1 i hy) y.2 :=\n  by\n  cases x\n  cases y\n  refine' ⟨fun xy => _, fun xy => ⟨i, hx, hy, xy⟩⟩\n  obtain ⟨j, _, _, h⟩ := xy\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  have h := congr_arg (f j k jk) h\n  apply (f i k ik).injective\n  rw [directed_system.map_map, directed_system.map_map] at *\n  exact h\n#align equiv_iff equiv_iff\n\n",
 "comp_unify":
 "theorem comp_unify {α : Type _} {x : α → Σi, G i} {i j : ι} (ij : i ≤ j) (h : i ∈ upperBounds (range (sigma.fst ∘ x))) :\n    f i j ij ∘ unify f x i h = unify f x j fun k hk => trans (mem_upperBounds.1 h k hk) ij :=\n  by\n  ext a\n  simp [unify, directed_system.map_map]\n#align comp_unify comp_unify\n\n",
 "coe_nat_le_rec":
 "@[simp]\ntheorem coe_nat_le_rec (m n : ℕ) (h : m ≤ n) : (nat_le_rec f' m n h : G' m → G' n) = Nat.leRecOn h fun n => f' n :=\n  by\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h\n  ext x\n  induction' k with k ih\n  · rw [nat_le_rec, Nat.leRecOn_self, embedding.refl_apply, Nat.leRecOn_self]\n  · rw [Nat.leRecOn_succ le_self_add, nat_le_rec, Nat.leRecOn_succ le_self_add, ← nat_le_rec, embedding.comp_apply, ih]\n#align coe_nat_le_rec coe_nat_le_rec\n\n",
 "cg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n/-- The direct limit of countably many countably generated structures is countably generated. -/\ntheorem cg {ι : Type _} [Encodable ι] [preorder ι] [IsDirected ι (· ≤ ·)] [nonempty ι] {G : ι → Type w}\n    [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → language.embedding (G i) L (G j)) (h : ∀ i, Structure.cg L (G i))\n    [directed_system G fun i j h => f i j h] : Structure.cg L (direct_limit G f) :=\n  by\n  refine'\n    ⟨⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (direct_limit.of L ι G f i) (Classical.choose (h i).out)),\n        _, _⟩⟩\n  · exact set.countable_Union fun i => set.countable.image (Classical.choose_spec (h i).out).1 _\n  · rw [eq_top_iff, substructure.closure_Union]\n    simp_rw [← embedding.coe_to_hom, substructure.closure_image]\n    rw [le_supᵢ_iff]\n    intro S hS x hx\n    let out := @quotient.out _ (direct_limit.setoid G f)\n    refine' hS (out x).1 ⟨(out x).2, _, _⟩\n    · rw [(Classical.choose_spec (h (out x).1).out).2]\n      simp only [substructure.coe_top]\n    · simp only [embedding.coe_to_hom, direct_limit.of_apply, sigma.eta, quotient.out_eq]\n#align cg cg\n\n"}