{"to_hom_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_hom_range (f : language.equiv M L N) : f.to_hom.range = «expr⊤» :=\n  by\n  ext n\n  simp only [hom.mem_range, coe_to_hom, substructure.mem_top, iff_true_iff]\n  exact ⟨f.symm n, apply_symm_apply _ _⟩\n#align to_hom_range to_hom_range\n\n",
 "subtype_comp_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n@[simp]\ntheorem subtype_comp_cod_restrict (f : language.embedding M L N) (p : L.substructure N) (h : ∀ b, f b ∈ p) :\n    p.subtype.comp (cod_restrict p f h) = f :=\n  ext fun b => rfl\n#align subtype_comp_cod_restrict subtype_comp_cod_restrict\n\n",
 "substructure_equiv_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n@[simp]\ntheorem substructure_equiv_map_apply (f : language.embedding M L N) (p : L.substructure M) (x : p) :\n    (f.substructure_equiv_map p x : N) = f x :=\n  rfl\n#align substructure_equiv_map_apply substructure_equiv_map_apply\n\n",
 "substructure_closure":
 "theorem _root_.set.countable.substructure_closure [countable (Σl, L.functions l)] (h : s.countable) :\n    countable.{w + 1} (closure L s) := by\n  haveI : countable s := h.to_subtype\n  rw [← mk_le_aleph_0_iff, ← lift_le_aleph_0]\n  exact lift_card_closure_le_card_term.trans mk_le_aleph_0\n#align set.countable.substructure_closure set.countable.substructure_closure\n\n",
 "subset_closure_with_constants":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem subset_closure_with_constants : A ⊆ closure (language.with_constants L A) s :=\n  by\n  intro a ha\n  simp only [SetLike.mem_coe]\n  let a' : (language.with_constants L A).constants := sum.inr ⟨a, ha⟩\n  exact constants_mem a'\n#align subset_closure_with_constants subset_closure_with_constants\n\n",
 "subset_closure":
 "/-- The substructure generated by a set includes the set. -/\n@[simp]\ntheorem subset_closure : s ⊆ closure L s :=\n  (closure L).le_closure s\n#align subset_closure subset_closure\n\n",
 "reduct_with_constants":
 "@[simp]\ntheorem reduct_with_constants : (L.Lhom_with_constants A).substructure_reduct (S.with_constants h) = S :=\n  by\n  ext\n  simp\n#align reduct_with_constants reduct_with_constants\n\n",
 "realize_mem":
 "theorem term.realize_mem {α : Type _} (t : L.term α) (xs : α → M) (h : ∀ a, xs a ∈ S) : t.realize xs ∈ S :=\n  by\n  induction' t with a n f ts ih\n  · exact h a\n  · exact substructure.fun_mem _ _ _ ih\n#align term.realize_mem term.realize_mem\n\n",
 "range_subtype":
 "theorem range_subtype (S : L.substructure M) : S.subtype.to_hom.range = S :=\n  by\n  ext x\n  simp only [hom.mem_range, embedding.coe_to_hom, coe_subtype]\n  refine' ⟨_, fun h => ⟨⟨x, h⟩, rfl⟩⟩\n  rintro ⟨⟨y, hy⟩, rfl⟩\n  exact hy\n#align range_subtype range_subtype\n\n",
 "range_le_iff_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_le_iff_comap {f : language.hom M L N} {p : L.substructure N} : range f ≤ p ↔ comap f p = «expr⊤» := by\n  rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]\n#align range_le_iff_comap range_le_iff_comap\n\n",
 "range_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_id : range (id L M) = «expr⊤» :=\n  SetLike.coe_injective Set.range_id\n#align range_id range_id\n\n",
 "range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_top {f : language.hom M L N} : range f = «expr⊤» ↔ function.surjective f := by\n  rw [SetLike.ext'_iff, range_coe, coe_top, Set.range_iff_surjective]\n#align range_eq_top range_eq_top\n\n",
 "range_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_map (f : language.hom M L N) : f.range = map f («expr⊤») :=\n  by\n  ext\n  simp\n#align range_eq_map range_eq_map\n\n",
 "range_comp_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem range_comp_le_range (f : language.hom M L N) (g : language.hom N L P) :\n    range (g.comp f : language.hom M L P) ≤ range g :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n#align range_comp_le_range range_comp_le_range\n\n",
 "range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem range_comp (f : language.hom M L N) (g : language.hom N L P) :\n    range (g.comp f : language.hom M L P) = map g (range f) :=\n  SetLike.coe_injective (Set.range_comp g f)\n#align range_comp range_comp\n\n",
 "range_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem range_coe (f : language.hom M L N) : (range f : set N) = Set.range f :=\n  rfl\n#align range_coe range_coe\n\n",
 "not_mem_of_not_mem_closure":
 "theorem not_mem_of_not_mem_closure {P : M} (hP : P ∉ closure L s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n\n",
 "monotone_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem monotone_map {f : language.hom M L N} : monotone (map f) :=\n  (gc_map_comap f).monotone_l\n#align monotone_map monotone_map\n\n",
 "monotone_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem monotone_comap {f : language.hom M L N} : monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n#align monotone_comap monotone_comap\n\n",
 "mem_with_constants":
 "@[simp]\ntheorem mem_with_constants {x : M} : x ∈ S.with_constants h ↔ x ∈ S :=\n  iff.rfl\n#align mem_with_constants mem_with_constants\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top (x : M) : x ∈ («expr⊤» : L.substructure M) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_substructure_reduct":
 "@[simp]\ntheorem mem_substructure_reduct {x : M} {S : L'.substructure M} : x ∈ φ.substructure_reduct S ↔ x ∈ S :=\n  iff.rfl\n#align mem_substructure_reduct mem_substructure_reduct\n\n",
 "mem_range_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem mem_range_self (f : language.hom M L N) (x : M) : f x ∈ f.range :=\n  ⟨x, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n@[simp]\ntheorem mem_range {f : language.hom M L N} {x} : x ∈ range f ↔ ∃ y, f y = x :=\n  iff.rfl\n#align mem_range mem_range\n\n",
 "mem_map_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem mem_map_of_mem (f : language.hom M L N) {S : L.substructure M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n@[simp]\ntheorem mem_map {f : language.hom M L N} {S : L.substructure M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y :=\n  mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem mem_infi {ι : Sort _} {S : ι → L.substructure M} {x : M} :\n    x ∈ «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i) ↔\n      ∀ i, x ∈ S i :=\n  by simp only [infᵢ, mem_Inf, Set.forall_range_iff]\n#align mem_infi mem_infi\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {p p' : L.substructure M} {x : M} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n@[simp]\ntheorem mem_comap {S : L.substructure N} {f : language.hom M L N} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_closure_iff_exists_term":
 "theorem mem_closure_iff_exists_term {x : M} : x ∈ closure L s ↔ ∃ t : L.term s, t.realize (coe : s → M) = x := by\n  rw [← SetLike.mem_coe, coe_closure_eq_range_term_realize, mem_range]\n#align mem_closure_iff_exists_term mem_closure_iff_exists_term\n\n",
 "mem_closure":
 "theorem mem_closure {x : M} : x ∈ closure L s ↔ ∀ S : L.substructure M, s ⊆ S → x ∈ S :=\n  mem_Inf\n#align mem_closure mem_closure\n\n",
 "mem_carrier":
 "@[simp]\ntheorem mem_carrier {s : L.substructure M} {x : M} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : set (L.substructure M)} {x : M} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_interᵢ₂\n#align mem_Inf mem_Inf\n\n",
 "map_surjective_of_surjective":
 "theorem map_surjective_of_surjective : function.surjective (map f) :=\n  (gi_map_comap hf).l_surjective\n#align map_surjective_of_surjective map_surjective_of_surjective\n\n",
 "map_supr_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_supr_comap_of_surjective (S : ι → L.substructure N) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((S i).comap f)).map\n        f =\n      supᵢ S :=\n  (gi_map_comap hf).l_supr_u _\n#align map_supr_comap_of_surjective map_supr_comap_of_surjective\n\n",
 "map_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_supr {ι : Sort _} (f : language.hom M L N) (s : ι → L.substructure M) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f).l_supr\n#align map_supr map_supr\n\n",
 "map_sup_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup_comap_of_surjective (S T : L.substructure N) :\n    («expr ⊔ » (S.comap f) (T.comap f)).map f = «expr ⊔ » S T :=\n  (gi_map_comap hf).l_sup_u _ _\n#align map_sup_comap_of_surjective map_sup_comap_of_surjective\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (S T : L.substructure M) (f : language.hom M L N) :\n    («expr ⊔ » S T).map f = «expr ⊔ » (S.map f) (T.map f) :=\n  (gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_strict_mono_of_injective":
 "theorem map_strict_mono_of_injective : strict_mono (map f) :=\n  (gci_map_comap hf).strict_mono_l\n#align map_strict_mono_of_injective map_strict_mono_of_injective\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem map_map (g : language.hom N L P) (f : language.hom M L N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem map_le_range {f : language.hom M L N} {p : L.substructure M} : map f p ≤ range f :=\n  SetLike.coe_mono (Set.image_subset_range f p)\n#align map_le_range map_le_range\n\n",
 "map_le_of_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem map_le_of_le_comap {T : L.substructure N} {f : language.hom M L N} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n#align map_le_of_le_comap map_le_of_le_comap\n\n",
 "map_le_map_iff_of_injective":
 "theorem map_le_map_iff_of_injective {S T : L.substructure M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gci_map_comap hf).l_le_l_iff\n#align map_le_map_iff_of_injective map_le_map_iff_of_injective\n\n",
 "map_le_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem map_le_iff_le_comap {f : language.hom M L N} {S : L.substructure M} {T : L.substructure N} :\n    S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_injective_of_injective":
 "theorem map_injective_of_injective : function.injective (map f) :=\n  (gci_map_comap hf).l_injective\n#align map_injective_of_injective map_injective_of_injective\n\n",
 "map_infi_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi_comap_of_surjective (S : ι → L.substructure N) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((S i).comap f)).map\n        f =\n      infᵢ S :=\n  (gi_map_comap hf).l_infi_u _\n#align map_infi_comap_of_surjective map_infi_comap_of_surjective\n\n",
 "map_inf_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf_comap_of_surjective (S T : L.substructure N) :\n    («expr ⊓ » (S.comap f) (T.comap f)).map f = «expr ⊓ » S T :=\n  (gi_map_comap hf).l_inf_u _ _\n#align map_inf_comap_of_surjective map_inf_comap_of_surjective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (S : L.substructure M) : S.map (hom.id L M) = S :=\n  ext fun x => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩\n#align map_id map_id\n\n",
 "map_comap_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n@[simp]\ntheorem map_comap_map {f : language.hom M L N} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n#align map_comap_map map_comap_map\n\n",
 "map_comap_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem map_comap_le {S : L.substructure N} {f : language.hom M L N} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_comap_eq_of_surjective":
 "theorem map_comap_eq_of_surjective (S : L.substructure N) : (S.comap f).map f = S :=\n  (gi_map_comap hf).l_u_eq _\n#align map_comap_eq_of_surjective map_comap_eq_of_surjective\n\n",
 "map_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_closure (f : language.hom M L N) (s : set M) : (closure L s).map f = closure L («expr '' » f s) :=\n  eq.symm <|\n    closure_eq_of_le (Set.image_subset f subset_closure) <|\n      map_le_iff_le_comap.2 <| closure_le.2 fun x hx => subset_closure ⟨x, hx, rfl⟩\n#align map_closure map_closure\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : language.hom M L N) : («expr⊥» : L.substructure M).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "lift_card_closure_le_card_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lift_card_closure_le_card_term : cardinal.lift.{max u w} (cardinal.mk (closure L s)) ≤ cardinal.mk (L.term s) :=\n  by\n  rw [← SetLike.coe_sort_coe, coe_closure_eq_range_term_realize]\n  rw [← cardinal.lift_id'.{w, max u w} (cardinal.mk (L.term s))]\n  exact cardinal.mk_range_le_lift\n#align lift_card_closure_le_card_term lift_card_closure_le_card_term\n\n",
 "lift_card_closure_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem lift_card_closure_le :\n    cardinal.lift.{u, w} (cardinal.mk (closure L s)) ≤\n      max (cardinal.aleph_0)\n        (cardinal.lift.{u, w} (cardinal.mk s) + cardinal.lift.{w, u} (cardinal.mk (Σi, L.functions i))) :=\n  by\n  rw [← lift_umax]\n  refine' lift_card_closure_le_card_term.trans (term.card_le.trans _)\n  rw [mk_sum, lift_umax]\n#align lift_card_closure_le lift_card_closure_le\n\n",
 "le_comap_of_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem le_comap_of_map_le {T : L.substructure N} {f : language.hom M L N} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n#align le_comap_of_map_le le_comap_of_map_le\n\n",
 "le_comap_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem le_comap_map {f : language.hom M L N} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "inter":
 "theorem inter (hs : closed_under f s) (ht : closed_under f t) : closed_under f (s ∩ t) := fun x h =>\n  mem_inter (hs x fun i => mem_of_mem_inter_left (h i)) (ht x fun i => mem_of_mem_inter_right (h i))\n#align inter inter\n\n",
 "inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf (hs : closed_under f s) (ht : closed_under f t) : closed_under f («expr ⊓ » s t) :=\n  hs.inter ht\n#align inf inf\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem gc_map_comap (f : language.hom M L N) : GaloisConnection (map f) (comap f) := fun S T => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "ext":
 "/-- Two substructures are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : L.substructure M} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "equiv_range_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n@[simp]\ntheorem equiv_range_apply (f : language.embedding M L N) (x : M) : (f.equiv_range x : N) = f x :=\n  rfl\n#align equiv_range_apply equiv_range_apply\n\n",
 "eq_on_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/-- If two `L.hom`s are equal on a set, then they are equal on its substructure closure. -/\ntheorem eq_on_closure {f g : language.hom M L N} {s : set M} (h : Set.EqOn f g s) : Set.EqOn f g (closure L s) :=\n  show closure L s ≤ f.eq_locus g from closure_le.2 h\n#align eq_on_closure eq_on_closure\n\n",
 "eq_of_eq_on_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_of_eq_on_top {f g : language.hom M L N} (h : Set.EqOn f g («expr⊤» : substructure L M)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_top eq_of_eq_on_top\n\n",
 "eq_of_eq_on_dense":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem eq_of_eq_on_dense (hs : closure L s = «expr⊤») {f g : language.hom M L N} (h : s.eq_on f g) : f = g :=\n  eq_of_eq_on_top <| hs ▸ eq_on_closure h\n#align eq_of_eq_on_dense eq_of_eq_on_dense\n\n",
 "dom_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n@[simp]\ntheorem dom_restrict_apply (f : language.embedding M L N) (p : L.substructure M) (x : p) : f.dom_restrict p x = f x :=\n  rfl\n#align dom_restrict_apply dom_restrict_apply\n\n",
 "dense_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `s` is a dense set in a structure `M`, `substructure.closure L s = ⊤`, then in order to prove\nthat some predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ∈ s`, and verify\nthat `p` is preserved under function symbols. -/\n@[elab_as_elim]\ntheorem dense_induction {p : M → Prop} (x : M) {s : set M} (hs : closure L s = «expr⊤») (Hs : ∀ x ∈ s, p x)\n    (Hfun : ∀ {n : ℕ} (f : L.functions n), closed_under f (set_of p)) : p x :=\n  by\n  have : ∀ x ∈ closure L s, p x := fun x hx => closure_induction hx Hs fun n => Hfun\n  simpa [hs] using this x\n#align dense_induction dense_induction\n\n",
 "copy_eq":
 "theorem copy_eq {s : set M} (hs : s = S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "constants_mem":
 "theorem constants_mem (c : L.constants) : ↑c ∈ S :=\n  mem_carrier.2 (S.fun_mem c _ Fin.elim0)\n#align constants_mem constants_mem\n\n",
 "comp_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n@[simp]\ntheorem comp_cod_restrict (f : language.embedding M L N) (g : language.embedding N L P) (p : L.substructure P)\n    (h : ∀ b, g b ∈ p) :\n    ((cod_restrict p g h).comp f : language.embedding M L p) = cod_restrict p (g.comp f) fun b => h _ :=\n  ext fun b => rfl\n#align comp_cod_restrict comp_cod_restrict\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : language.hom M L N) : («expr⊤» : L.substructure N).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_surjective_of_injective":
 "theorem comap_surjective_of_injective : function.surjective (comap f) :=\n  (gci_map_comap hf).u_surjective\n#align comap_surjective_of_injective comap_surjective_of_injective\n\n",
 "comap_supr_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem comap_supr_map_of_injective (S : ι → L.substructure M) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((S i).map f)).comap\n        f =\n      supᵢ S :=\n  (gci_map_comap hf).u_supr_l _\n#align comap_supr_map_of_injective comap_supr_map_of_injective\n\n",
 "comap_sup_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem comap_sup_map_of_injective (S T : L.substructure M) : («expr ⊔ » (S.map f) (T.map f)).comap f = «expr ⊔ » S T :=\n  (gci_map_comap hf).u_sup_l _ _\n#align comap_sup_map_of_injective comap_sup_map_of_injective\n\n",
 "comap_strict_mono_of_surjective":
 "theorem comap_strict_mono_of_surjective : strict_mono (comap f) :=\n  (gi_map_comap hf).strict_mono_u\n#align comap_strict_mono_of_surjective comap_strict_mono_of_surjective\n\n",
 "comap_map_eq_of_injective":
 "theorem comap_map_eq_of_injective (S : L.substructure M) : (S.map f).comap f = S :=\n  (gci_map_comap hf).u_l_eq _\n#align comap_map_eq_of_injective comap_map_eq_of_injective\n\n",
 "comap_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n@[simp]\ntheorem comap_map_comap {S : L.substructure N} {f : language.hom M L N} : ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n#align comap_map_comap comap_map_comap\n\n",
 "comap_le_comap_iff_of_surjective":
 "theorem comap_le_comap_iff_of_surjective {S T : L.substructure N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (gi_map_comap hf).u_le_u_iff\n#align comap_le_comap_iff_of_surjective comap_le_comap_iff_of_surjective\n\n",
 "comap_injective_of_surjective":
 "theorem comap_injective_of_surjective : function.injective (comap f) :=\n  (gi_map_comap hf).u_injective\n#align comap_injective_of_surjective comap_injective_of_surjective\n\n",
 "comap_infi_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi_map_of_injective (S : ι → L.substructure M) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((S i).map f)).comap\n        f =\n      infᵢ S :=\n  (gci_map_comap hf).u_infi_l _\n#align comap_infi_map_of_injective comap_infi_map_of_injective\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi {ι : Sort _} (f : language.hom M L N) (s : ι → L.substructure N) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf_map_of_injective (S T : L.substructure M) : («expr ⊓ » (S.map f) (T.map f)).comap f = «expr ⊓ » S T :=\n  (gci_map_comap hf).u_inf_l _ _\n#align comap_inf_map_of_injective comap_inf_map_of_injective\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf (S T : L.substructure N) (f : language.hom M L N) :\n    («expr ⊓ » S T).comap f = «expr ⊓ » (S.comap f) (T.comap f) :=\n  (gc_map_comap f).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id (S : L.substructure P) : S.comap (hom.id _ _) = S :=\n  ext (by simp)\n#align comap_id comap_id\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem comap_comap (S : L.substructure P) (g : language.hom N L P) (f : language.hom M L N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "coe_with_constants":
 "@[simp]\ntheorem coe_with_constants : (S.with_constants h : set M) = ↑S :=\n  rfl\n#align coe_with_constants coe_with_constants\n\n",
 "coe_top_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top_equiv : «expr⇑ » (top_equiv : language.equiv («expr⊤» : L.substructure M) L M) = coe :=\n  rfl\n#align coe_top_equiv coe_top_equiv\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ((«expr⊤» : L.substructure M) : set M) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_subtype : «expr⇑ » S.subtype = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_substructure_reduct":
 "@[simp]\ntheorem coe_substructure_reduct {S : L'.substructure M} : (φ.substructure_reduct S : set M) = ↑S :=\n  rfl\n#align coe_substructure_reduct coe_substructure_reduct\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_infi {ι : Sort _} {S : ι → L.substructure M} :\n    (↑(«expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (S i)) : set M) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp only [infᵢ, coe_Inf, Set.binterᵢ_range]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf (p p' : L.substructure M) : ((«expr ⊓ » p p' : L.substructure M) : set M) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_inclusion":
 "@[simp]\ntheorem coe_inclusion {S T : L.substructure M} (h : S ≤ T) : (inclusion h : S → T) = Set.inclusion h :=\n  rfl\n#align coe_inclusion coe_inclusion\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy {s : set M} (hs : s = S) : (S.copy s hs : set M) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_closure_eq_range_term_realize":
 "theorem coe_closure_eq_range_term_realize : (closure L s : set M) = range (@term.realize L _ _ _ (coe : s → M)) :=\n  by\n  let S : L.substructure M := ⟨range (term.realize coe), fun n f x hx => _⟩\n  · change _ = (S : set M)\n    rw [← SetLike.ext'_iff]\n    refine' closure_eq_of_le (fun x hx => ⟨var ⟨x, hx⟩, rfl⟩) (le_infₛ fun S' hS' => _)\n    · rintro _ ⟨t, rfl⟩\n      exact t.realize_mem _ fun i => hS' i.2\n  · simp only [mem_range] at *\n    refine' ⟨func f fun i => Classical.choose (hx i), _⟩\n    simp only [term.realize, fun i => Classical.choose_spec (hx i)]\n#align coe_closure_eq_range_term_realize coe_closure_eq_range_term_realize\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : set (L.substructure M)) :\n    ((infₛ S : L.substructure M) : set M) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "cod_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n@[simp]\ntheorem cod_restrict_apply (p : L.substructure N) (f : language.embedding M L N) {h} (x : M) :\n    (cod_restrict p f h x : N) = f x :=\n  rfl\n#align cod_restrict_apply cod_restrict_apply\n\n",
 "closure_with_constants_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem closure_with_constants_eq :\n    closure (language.with_constants L A) s =\n      (closure L (A ∪ s)).with_constants ((A.subset_union_left s).trans subset_closure) :=\n  by\n  refine' closure_eq_of_le ((A.subset_union_right s).trans subset_closure) _\n  rw [← (L.Lhom_with_constants A).substructure_reduct.le_iff_le]\n  simp only [subset_closure, reduct_with_constants, closure_le, Lhom.coe_substructure_reduct, Set.union_subset_iff,\n    and_true_iff]\n  · exact subset_closure_with_constants\n  · infer_instance\n  · infer_instance\n#align closure_with_constants_eq closure_with_constants_eq\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem closure_univ : closure L (univ : set M) = «expr⊤» :=\n  @coe_top L M _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem closure_union (s t : set M) : closure L (s ∪ t) = «expr ⊔ » (closure L s) (closure L t) :=\n  (substructure.gi L M).gc.l_sup\n#align closure_union closure_union\n\n",
 "closure_mono":
 "/-- Substructure closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure L s ≤ closure L t`. -/\ntheorem closure_mono ⦃s t : set M⦄ (h : s ⊆ t) : closure L s ≤ closure L t :=\n  (closure L).monotone h\n#align closure_mono closure_mono\n\n",
 "closure_le":
 "/-- A substructure `S` includes `closure L s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le : closure L s ≤ S ↔ s ⊆ S :=\n  (closure L).closure_le_closed_iff_le s S.closed\n#align closure_le closure_le\n\n",
 "closure_induction'":
 "/-- A dependent version of `substructure.closure_induction`. -/\n@[elab_as_elim]\ntheorem closure_induction' (s : set M) {p : ∀ x, x ∈ closure L s → Prop}\n    (Hs : ∀ (x) (h : x ∈ s), p x (subset_closure h))\n    (Hfun : ∀ {n : ℕ} (f : L.functions n), closed_under f { x | ∃ hx, p x hx }) {x} (hx : x ∈ closure L s) : p x hx :=\n  by\n  refine' exists.elim _ fun (hx : x ∈ closure L s) (hc : p x hx) => hc\n  exact closure_induction hx (fun x hx => ⟨subset_closure hx, Hs x hx⟩) @Hfun\n#align closure_induction' closure_induction'\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under function symbols, then `p` holds for all elements of the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {p : M → Prop} {x} (h : x ∈ closure L s) (Hs : ∀ x ∈ s, p x)\n    (Hfun : ∀ {n : ℕ} (f : L.functions n), closed_under f (set_of p)) : p x :=\n  (@closure_le L M _ ⟨set_of p, fun n => Hfun⟩ _).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem closure_image (f : language.hom M L N) : closure L («expr '' » f s) = map f (closure L s) :=\n  (map_closure f s).symm\n#align closure_image closure_image\n\n",
 "closure_eq_of_le":
 "theorem closure_eq_of_le (h₁ : s ⊆ S) (h₂ : S ≤ closure L s) : closure L s = S :=\n  (closure L).eq_of_le h₁ h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a substructure `S` equals `S`. -/\n@[simp]\ntheorem closure_eq : closure L (S : set M) = S :=\n  (substructure.gi L M).l_u_eq S\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem closure_empty : closure L (∅ : set M) = «expr⊥» :=\n  (substructure.gi L M).gc.l_bot\n#align closure_empty closure_empty\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem closure_Union {ι} (s : ι → set M) :\n    closure L («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (closure L (s i)) :=\n  (substructure.gi L M).gc.l_supr\n#align closure_Union closure_Union\n\n",
 "closed_under_univ":
 "/-\nCopyright (c) 2021 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem closed_under_univ : closed_under f (univ : set M) := fun _ _ => mem_univ _\n#align closed_under_univ closed_under_univ\n\n",
 "closed":
 "@[simp]\ntheorem closed (S : L.substructure M) : (closure L).closed (S : set M) :=\n  congr rfl ((closure L).eq_of_le Set.Subset.rfl fun x xS => mem_closure.2 fun T hT => hT xS)\n#align closed closed\n\n",
 "apply_coe_mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.hom -/\ntheorem apply_coe_mem_map (f : language.hom M L N) (S : L.substructure M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.prop\n#align apply_coe_mem_map apply_coe_mem_map\n\n",
 "Inf":
 "theorem Inf (hS : ∀ s, s ∈ S → closed_under f s) : closed_under f (infₛ S) := fun x h s hs =>\n  hS s hs x fun i => h i s hs\n#align Inf Inf\n\n"}