{"to_list_foldr_inf_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem to_list_foldr_inf_mem {p : T.complete_type α} {t : Finset (language.with_constants L α).sentence} :\n    t.to_list.foldr («expr ⊓ » · ·) («expr⊤») ∈ p ↔ (t : (language.with_constants L α).Theory) ⊆ ↑p :=\n  by\n  simp_rw [subset_def, ← SetLike.mem_coe, p.is_maximal.mem_iff_models, models_sentence_iff, sentence.realize,\n    formula.realize, bounded_formula.realize_foldr_inf, Finset.mem_toList]\n  exact ⟨fun h φ hφ M => h _ _ hφ, fun h M φ hφ => h _ hφ _⟩\n#align to_list_foldr_inf_mem to_list_foldr_inf_mem\n\n",
 "subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem subset (p : T.complete_type α) :\n    (L.Lhom_with_constants α).on_Theory T ⊆ (p : (language.with_constants L α).Theory) :=\n  p.subset'\n#align subset subset\n\n",
 "set_of_subset_eq_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem set_of_subset_eq_univ_iff (S : (language.with_constants L α).Theory) :\n    { p : T.complete_type α | S ⊆ ↑p } = univ ↔\n      ∀ φ, φ ∈ S → models_bounded_formula ((L.Lhom_with_constants α).on_Theory T) φ :=\n  by\n  have h : { p : T.complete_type α | S ⊆ ↑p } = «expr⋂₀ » («expr '' » (fun φ => { p | φ ∈ p }) S) :=\n    by\n    ext\n    simp [subset_def]\n  simp_rw [h, sInter_eq_univ, ← set_of_mem_eq_univ_iff]\n  refine' ⟨fun h φ φS => h _ ⟨_, φS, rfl⟩, _⟩\n  rintro h _ ⟨φ, h1, rfl⟩\n  exact h _ h1\n#align set_of_subset_eq_univ_iff set_of_subset_eq_univ_iff\n\n",
 "set_of_subset_eq_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem set_of_subset_eq_empty_iff (S : (language.with_constants L α).Theory) :\n    { p : T.complete_type α | S ⊆ ↑p } = ∅ ↔ ¬((L.Lhom_with_constants α).on_Theory T ∪ S).is_satisfiable :=\n  by\n  rw [iff_not_comm, ← not_nonempty_iff_eq_empty, not_not, Set.Nonempty]\n  refine'\n    ⟨fun h =>\n      ⟨⟨(language.with_constants L α).complete_theory h.some, (subset_union_left _ S).trans complete_theory.subset,\n          complete_theory.is_maximal _ _⟩,\n        (subset_union_right ((L.Lhom_with_constants α).on_Theory T) _).trans complete_theory.subset⟩,\n      _⟩\n  rintro ⟨p, hp⟩\n  exact p.is_maximal.1.mono (union_subset p.subset hp)\n#align set_of_subset_eq_empty_iff set_of_subset_eq_empty_iff\n\n",
 "set_of_mem_eq_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem set_of_mem_eq_univ_iff (φ : (language.with_constants L α).sentence) :\n    { p : T.complete_type α | φ ∈ p } = univ ↔ models_bounded_formula ((L.Lhom_with_constants α).on_Theory T) φ :=\n  by\n  rw [models_iff_not_satisfiable, ← compl_empty_iff, compl_set_of_mem, ← set_of_subset_eq_empty_iff]\n  simp\n#align set_of_mem_eq_univ_iff set_of_mem_eq_univ_iff\n\n",
 "not_mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem not_mem_iff (p : T.complete_type α) (φ : (language.with_constants L α).sentence) : φ.not ∈ p ↔ ¬φ ∈ p :=\n  ⟨fun hf ht =>\n    by\n    have h : ¬is_satisfiable ({φ, φ.not} : (language.with_constants L α).Theory) :=\n      by\n      rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1\n    refine' h (p.is_maximal.1.mono _)\n    rw [insert_subset, singleton_subset_iff]\n    exact ⟨ht, hf⟩, (p.mem_or_not_mem φ).resolve_left⟩\n#align not_mem_iff not_mem_iff\n\n",
 "nonempty_iff":
 "theorem nonempty_iff : nonempty (T.complete_type α) ↔ T.is_satisfiable :=\n  by\n  rw [← is_satisfiable_on_Theory_iff (Lhom_with_constants_injective L α)]\n  rw [nonempty_iff_univ_nonempty, nonempty_iff_ne_empty, ne.def, not_iff_comm, ←\n    union_empty ((L.Lhom_with_constants α).on_Theory T), ← set_of_subset_eq_empty_iff]\n  simp\n#align nonempty_iff nonempty_iff\n\n",
 "mem_or_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem mem_or_not_mem (p : T.complete_type α) (φ : (language.with_constants L α).sentence) : φ ∈ p ∨ φ.not ∈ p :=\n  p.is_maximal.mem_or_not_mem φ\n#align mem_or_not_mem mem_or_not_mem\n\n",
 "mem_of_models":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `models_bounded_formula -/\ntheorem mem_of_models (p : T.complete_type α) {φ : (language.with_constants L α).sentence}\n    (h : models_bounded_formula ((L.Lhom_with_constants α).on_Theory T) φ) : φ ∈ p :=\n  (p.mem_or_not_mem φ).resolve_right fun con =>\n    ((models_iff_not_satisfiable _).1 h) (p.is_maximal.1.mono (union_subset p.subset (singleton_subset_iff.2 con)))\n#align mem_of_models mem_of_models\n\n",
 "is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem is_maximal (p : T.complete_type α) : is_maximal (p : (language.with_constants L α).Theory) :=\n  p.is_maximal'\n#align is_maximal is_maximal\n\n",
 "compl_set_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_set_of_mem {φ : (language.with_constants L α).sentence} :\n    «expr ᶜ» { p : T.complete_type α | φ ∈ p } = { p : T.complete_type α | φ.not ∈ p } :=\n  ext fun _ => (not_mem_iff _ _).symm\n#align compl_set_of_mem compl_set_of_mem\n\n",
 "Inter_set_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Inter_set_of_subset {ι : Type _} (S : ι → (language.with_constants L α).Theory) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        { p : T.complete_type α | S i ⊆ p } =\n      { p |\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i) ⊆ p } :=\n  by\n  ext\n  simp only [mem_Inter, mem_set_of_eq, Union_subset_iff]\n#align Inter_set_of_subset Inter_set_of_subset\n\n"}