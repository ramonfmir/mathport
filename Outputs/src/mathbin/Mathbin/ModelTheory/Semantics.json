{"union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem model.union {T' : L.Theory} (h : Theory.model M T) (h' : Theory.model M T') : Theory.model M (T ∪ T') :=\n  by\n  simp only [model_iff, Set.mem_union] at *\n  exact fun φ hφ => hφ.elim (h _) (h' _)\n#align model.union model.union\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n#print trans /-\n@[trans]\ntheorem trans (MN : elementarily_equivalent M L N) (NP : elementarily_equivalent N L P) :\n    elementarily_equivalent M L P :=\n  MN.trans NP\n#align trans trans\n-/\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n#print symm /-\n@[symm]\ntheorem symm (h : elementarily_equivalent M L N) : elementarily_equivalent N L M :=\n  h.symm\n#align symm symm\n-/\n\n",
 "subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem complete_theory.subset [MT : Theory.model M T] : T ⊆ L.complete_theory M :=\n  model_iff_subset_complete_theory.1 MT\n#align complete_theory.subset complete_theory.subset\n\n",
 "set_of_realize_on_formula":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n@[simp]\ntheorem Lhom.set_of_realize_on_formula [L'.Structure M] (φ : «expr →ᴸ » L L') [φ.is_expansion_on M] (ψ : L.formula α) :\n    (set_of (φ.on_formula ψ).realize : set (α → M)) = set_of ψ.realize :=\n  by\n  ext\n  simp\n#align Lhom.set_of_realize_on_formula Lhom.set_of_realize_on_formula\n\n",
 "realize_vars_to_constants":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem realize_vars_to_constants [(language.with_constants L α).Structure M]\n    [(Lhom_with_constants L α).is_expansion_on M] {t : L.term (Sum α β)} {v : β → M} :\n    t.vars_to_constants.realize v = t.realize (sum.elim (fun a => ↑(L.con a)) v) :=\n  by\n  induction' t with ab n f ts ih\n  · cases ab <;> simp [language.con]\n  · simp [ih]\n#align realize_vars_to_constants realize_vars_to_constants\n\n",
 "realize_transitive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_transitive :\n    Theory.model M r.transitive ↔\n      transitive fun x y : M =>\n        rel_map r («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  forall_congr' fun _ =>\n    forall_congr' fun _ => forall_congr' fun _ => imp_congr realize_rel₂ (imp_congr realize_rel₂ realize_rel₂)\n#align realize_transitive realize_transitive\n\n",
 "realize_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_total :\n    Theory.model M r.total ↔\n      total fun x y : M =>\n        rel_map r («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  forall_congr' fun _ => forall_congr' fun _ => realize_sup.trans (or_congr realize_rel₂ realize_rel₂)\n#align realize_total realize_total\n\n",
 "realize_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem realize_top : («expr⊤» : L.formula α).realize v ↔ true :=\n  bounded_formula.realize_top\n#align realize_top realize_top\n\n",
 "realize_to_prenex_imp_right":
 "theorem realize_to_prenex_imp_right {φ ψ : L.bounded_formula α n} (hφ : is_qf φ) (hψ : is_prenex ψ) {v : α → M}\n    {xs : fin n → M} : (φ.to_prenex_imp_right ψ).realize v xs ↔ (φ.imp ψ).realize v xs :=\n  by\n  revert φ\n  induction' hψ with _ _ hψ _ _ hψ ih _ _ hψ ih <;> intro φ hφ\n  · rw [hψ.to_prenex_imp_right]\n  · refine' trans (forall_congr' fun _ => ih hφ.lift_at) _\n    simp only [realize_imp, realize_lift_at_one_self, snoc_comp_cast_succ, realize_all]\n    exact ⟨fun h1 a h2 => h1 h2 a, fun h1 h2 a => h1 a h2⟩\n  · rw [to_prenex_imp_right, realize_ex]\n    refine' trans (exists_congr fun _ => ih hφ.lift_at) _\n    simp only [realize_imp, realize_lift_at_one_self, snoc_comp_cast_succ, realize_ex]\n    refine' ⟨_, fun h' => _⟩\n    · rintro ⟨a, ha⟩ h\n      exact ⟨a, ha h⟩\n    · by_cases φ.realize v xs\n      · obtain ⟨a, ha⟩ := h' h\n        exact ⟨a, fun _ => ha⟩\n      · inhabit M\n        exact ⟨default, fun h'' => (h h'').elim⟩\n#align realize_to_prenex_imp_right realize_to_prenex_imp_right\n\n",
 "realize_to_prenex_imp":
 "theorem realize_to_prenex_imp {φ ψ : L.bounded_formula α n} (hφ : is_prenex φ) (hψ : is_prenex ψ) {v : α → M}\n    {xs : fin n → M} : (φ.to_prenex_imp ψ).realize v xs ↔ (φ.imp ψ).realize v xs :=\n  by\n  revert ψ\n  induction' hφ with _ _ hφ _ _ hφ ih _ _ hφ ih <;> intro ψ hψ\n  · rw [hφ.to_prenex_imp]\n    exact realize_to_prenex_imp_right hφ hψ\n  · rw [to_prenex_imp, realize_ex]\n    refine' trans (exists_congr fun _ => ih hψ.lift_at) _\n    simp only [realize_imp, realize_lift_at_one_self, snoc_comp_cast_succ, realize_all]\n    refine' ⟨_, fun h' => _⟩\n    · rintro ⟨a, ha⟩ h\n      exact ha (h a)\n    · by_cases ψ.realize v xs\n      · inhabit M\n        exact ⟨default, fun h'' => h⟩\n      · obtain ⟨a, ha⟩ := not_forall.1 (h ∘ h')\n        exact ⟨a, fun h => (ha h).elim⟩\n  · refine' trans (forall_congr' fun _ => ih hψ.lift_at) _\n    simp\n#align realize_to_prenex_imp realize_to_prenex_imp\n\n",
 "realize_to_prenex":
 "@[simp]\ntheorem realize_to_prenex (φ : L.bounded_formula α n) {v : α → M} :\n    ∀ {xs : fin n → M}, φ.to_prenex.realize v xs ↔ φ.realize v xs :=\n  by\n  refine'\n    bounded_formula.rec_on φ (fun _ _ => iff.rfl) (fun _ _ _ _ => iff.rfl) (fun _ _ _ _ _ => iff.rfl)\n      (fun _ f1 f2 h1 h2 _ => _) fun _ f h xs => _\n  · rw [to_prenex, realize_to_prenex_imp f1.to_prenex_is_prenex f2.to_prenex_is_prenex, realize_imp, realize_imp, h1,\n      h2]\n    infer_instance\n  · rw [realize_all, to_prenex, realize_all]\n    exact forall_congr' fun a => h\n#align realize_to_prenex realize_to_prenex\n\n",
 "realize_to_formula":
 "@[simp]\ntheorem realize_to_formula (φ : L.bounded_formula α n) (v : Sum α (fin n) → M) :\n    φ.to_formula.realize v ↔ φ.realize (v ∘ sum.inl) (v ∘ sum.inr) :=\n  by\n  induction' φ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 _ _ ih3 a8 a9 a0\n  · rfl\n  · simp [bounded_formula.realize]\n  · simp [bounded_formula.realize]\n  · rw [to_formula, formula.realize, realize_imp, ← formula.realize, ih1, ← formula.realize, ih2, realize_imp]\n  · rw [to_formula, formula.realize, realize_all, realize_all]\n    refine' forall_congr' fun a => _\n    have h := ih3 (sum.elim (v ∘ sum.inl) (snoc (v ∘ sum.inr) a))\n    simp only [sum.elim_comp_inl, sum.elim_comp_inr] at h\n    rw [← h, realize_relabel, formula.realize]\n    rcongr\n    · cases x\n      · simp\n      · refine' Fin.lastCases _ (fun i => _) x\n        · rw [sum.elim_inr, snoc_last, Function.comp_apply, sum.elim_inr, Function.comp_apply,\n            fin_sum_fin_equiv_symm_last, sum.map_inr, sum.elim_inr, Function.comp_apply]\n          exact (congr rfl (subsingleton.elim _ _)).trans (snoc_last _ _)\n        · simp only [cast_succ, Function.comp_apply, sum.elim_inr, fin_sum_fin_equiv_symm_apply_cast_add, sum.map_inl,\n            sum.elim_inl]\n          rw [← cast_succ, snoc_cast_succ]\n    · exact subsingleton.elim _ _\n#align realize_to_formula realize_to_formula\n\n",
 "realize_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n@[simp]\ntheorem equiv.realize_term {v : α → M} (t : L.term α) (g : language.equiv M L N) :\n    t.realize (g ∘ v) = g (t.realize v) :=\n  g.to_hom.realize_term\n#align equiv.realize_term equiv.realize_term\n\n",
 "realize_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_symmetric :\n    Theory.model M r.symmetric ↔\n      symmetric fun x y : M =>\n        rel_map r («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  forall_congr' fun _ => forall_congr' fun _ => imp_congr realize_rel₂ realize_rel₂\n#align realize_symmetric realize_symmetric\n\n",
 "realize_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem realize_sup : («expr ⊔ » φ ψ).realize v ↔ φ.realize v ∨ ψ.realize v :=\n  bounded_formula.realize_sup\n#align realize_sup realize_sup\n\n",
 "realize_subst":
 "theorem realize_subst {φ : L.bounded_formula α n} {tf : α → L.term β} {v : β → M} {xs : fin n → M} :\n    (φ.subst tf).realize v xs ↔ φ.realize (fun a => (tf a).realize v) xs :=\n  realize_map_term_rel_id\n    (fun n t x => by\n      rw [term.realize_subst]\n      rcongr a\n      · cases a\n        · simp only [sum.elim_inl, term.realize_relabel, sum.elim_comp_inl]\n        · rfl)\n    (by simp)\n#align realize_subst realize_subst\n\n",
 "realize_sentence_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem Theory.realize_sentence_of_mem [Theory.model M T] {φ : L.sentence} (h : φ ∈ T) : Theory.model M φ :=\n  Theory.model.realize_of_mem φ h\n#align Theory.realize_sentence_of_mem Theory.realize_sentence_of_mem\n\n",
 "realize_sentence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_sentence (h : elementarily_equivalent M L N) (φ : L.sentence) : Theory.model M φ ↔ Theory.model N φ :=\n  (elementarily_equivalent_iff.1 h) φ\n#align realize_sentence realize_sentence\n\n",
 "realize_restrict_var_left":
 "@[simp]\ntheorem realize_restrict_var_left [decidable_eq α] {γ : Type _} {t : L.term (Sum α γ)} {s : set α}\n    (h : ↑t.var_finset_left ⊆ s) {v : α → M} {xs : γ → M} :\n    (t.restrict_var_left (Set.inclusion h)).realize (sum.elim (v ∘ coe) xs) = t.realize (sum.elim v xs) :=\n  by\n  induction' t with a _ _ _ ih\n  · cases a <;> rfl\n  · simp_rw [var_finset_left, Finset.coe_bunionᵢ, Set.unionᵢ_subset_iff] at h\n    exact congr rfl (funext fun i => ih i (h i (finset.mem_univ i)))\n#align realize_restrict_var_left realize_restrict_var_left\n\n",
 "realize_restrict_var":
 "@[simp]\ntheorem realize_restrict_var [decidable_eq α] {t : L.term α} {s : set α} (h : ↑t.var_finset ⊆ s) {v : α → M} :\n    (t.restrict_var (Set.inclusion h)).realize (v ∘ coe) = t.realize v :=\n  by\n  induction' t with _ _ _ _ ih\n  · rfl\n  · simp_rw [var_finset, Finset.coe_bunionᵢ, Set.unionᵢ_subset_iff] at h\n    exact congr rfl (funext fun i => ih i (h i (finset.mem_univ i)))\n#align realize_restrict_var realize_restrict_var\n\n",
 "realize_restrict_free_var":
 "@[simp]\ntheorem realize_restrict_free_var [decidable_eq α] {n : ℕ} {φ : L.bounded_formula α n} {s : set α}\n    (h : ↑φ.free_var_finset ⊆ s) {v : α → M} {xs : fin n → M} :\n    (φ.restrict_free_var (Set.inclusion h)).realize (v ∘ coe) xs ↔ φ.realize v xs :=\n  by\n  induction' φ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 _ _ ih3\n  · rfl\n  · simp [restrict_free_var, realize]\n  · simp [restrict_free_var, realize]\n  · simp [restrict_free_var, realize, ih1, ih2]\n  · simp [restrict_free_var, realize, ih3]\n#align realize_restrict_free_var realize_restrict_free_var\n\n",
 "realize_rel₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_rel₂ {R : L.relations 2} {t₁ t₂ : L.term _} :\n    (R.formula₂ t₁ t₂).realize v ↔\n      rel_map R («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  rw [relations.formula₂, realize_rel, iff_eq_eq]\n  refine' congr rfl (funext (Fin.cases _ _))\n  · simp only [matrix.cons_val_zero]\n  · simp only [matrix.cons_val_succ, matrix.cons_val_fin_one, forall_const]\n#align realize_rel₂ realize_rel₂\n\n",
 "realize_rel₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_rel₁ {R : L.relations 1} {t : L.term _} :\n    (R.formula₁ t).realize v ↔\n      rel_map R («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  rw [relations.formula₁, realize_rel, iff_eq_eq]\n  refine' congr rfl (funext fun _ => _)\n  simp only [matrix.cons_val_fin_one]\n#align realize_rel₁ realize_rel₁\n\n",
 "realize_relabel_sum_inr":
 "theorem realize_relabel_sum_inr (φ : L.formula (fin n)) {v : empty → M} {x : fin n → M} :\n    (bounded_formula.relabel sum.inr φ).realize v x ↔ φ.realize x := by\n  rw [bounded_formula.realize_relabel, formula.realize, sum.elim_comp_inr, Fin.castAdd_zero, cast_refl,\n    OrderIso.coe_refl, function.comp.right_id, subsingleton.elim (x ∘ (nat_add n : fin 0 → fin n)) default]\n#align realize_relabel_sum_inr realize_relabel_sum_inr\n\n",
 "realize_relabel_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem realize_relabel_equiv {g : «expr ≃ » α β} {k} {φ : L.bounded_formula α k} {v : β → M} {xs : fin k → M} :\n    (relabel_equiv g φ).realize v xs ↔ φ.realize (v ∘ g) xs :=\n  by\n  simp only [relabel_equiv, map_term_rel_equiv_apply, equiv.coe_refl]\n  refine' realize_map_term_rel_id (fun n t xs => _) fun _ _ _ => rfl\n  simp only [relabel_equiv_apply, term.realize_relabel]\n  refine' congr (congr rfl _) rfl\n  ext (i | i) <;> rfl\n#align realize_relabel_equiv realize_relabel_equiv\n\n",
 "realize_relabel":
 "@[simp]\ntheorem realize_relabel {φ : L.formula α} {g : α → β} {v : β → M} : (φ.relabel g).realize v ↔ φ.realize (v ∘ g) :=\n  by\n  rw [realize, realize, relabel, bounded_formula.realize_relabel, iff_eq_eq, Fin.castAdd_zero]\n  exact congr rfl (funext finZeroElim)\n#align realize_relabel realize_relabel\n\n",
 "realize_rel":
 "@[simp]\ntheorem realize_rel {k : ℕ} {R : L.relations k} {ts : fin k → L.term α} :\n    (R.formula ts).realize v ↔ rel_map R fun i => (ts i).realize v :=\n  bounded_formula.realize_rel.trans (by simp)\n#align realize_rel realize_rel\n\n",
 "realize_reflexive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_reflexive :\n    Theory.model M r.reflexive ↔\n      reflexive fun x y : M =>\n        rel_map r («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  forall_congr' fun _ => realize_rel₂\n#align realize_reflexive realize_reflexive\n\n",
 "realize_on_term":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n@[simp]\ntheorem realize_on_term [L'.Structure M] (φ : «expr →ᴸ » L L') [φ.is_expansion_on M] (t : L.term α) (v : α → M) :\n    (φ.on_term t).realize v = t.realize v := by\n  induction' t with _ n f ts ih\n  · rfl\n  · simp only [term.realize, Lhom.on_term, Lhom.map_on_function, ih]\n#align realize_on_term realize_on_term\n\n",
 "realize_on_sentence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\n@[simp]\ntheorem Lhom.realize_on_sentence [L'.Structure M] (φ : «expr →ᴸ » L L') [φ.is_expansion_on M] (ψ : L.sentence) :\n    sentence.realize M (φ.on_sentence ψ) ↔ sentence.realize M ψ :=\n  φ.realize_on_formula ψ\n#align Lhom.realize_on_sentence Lhom.realize_on_sentence\n\n",
 "realize_on_formula":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n@[simp]\ntheorem Lhom.realize_on_formula [L'.Structure M] (φ : «expr →ᴸ » L L') [φ.is_expansion_on M] (ψ : L.formula α)\n    {v : α → M} : (φ.on_formula ψ).realize v ↔ ψ.realize v :=\n  φ.realize_on_bounded_formula ψ\n#align Lhom.realize_on_formula Lhom.realize_on_formula\n\n",
 "realize_on_bounded_formula":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n@[simp]\ntheorem realize_on_bounded_formula [L'.Structure M] (φ : «expr →ᴸ » L L') [φ.is_expansion_on M] {n : ℕ}\n    (ψ : L.bounded_formula α n) {v : α → M} {xs : fin n → M} : (φ.on_bounded_formula ψ).realize v xs ↔ ψ.realize v xs :=\n  by\n  induction' ψ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 _ _ ih3\n  · rfl\n  · simp only [on_bounded_formula, realize_bd_equal, realize_on_term]\n    rfl\n  · simp only [on_bounded_formula, realize_rel, realize_on_term, Lhom.map_on_relation]\n    rfl\n  · simp only [on_bounded_formula, ih1, ih2, realize_imp]\n  · simp only [on_bounded_formula, ih3, realize_all]\n#align realize_on_bounded_formula realize_on_bounded_formula\n\n",
 "realize_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\n-- input using \\|= or \\vDash, but not using \\models\n@[simp]\ntheorem sentence.realize_not {φ : L.sentence} : sentence.realize M φ.not ↔ ¬sentence.realize M φ :=\n  iff.rfl\n#align sentence.realize_not sentence.realize_not\n\n",
 "realize_map_term_rel_id":
 "theorem realize_map_term_rel_id [L'.Structure M] {ft : ∀ n, L.term (Sum α (fin n)) → L'.term (Sum β (fin n))}\n    {fr : ∀ n, L.relations n → L'.relations n} {n} {φ : L.bounded_formula α n} {v : α → M} {v' : β → M} {xs : fin n → M}\n    (h1 :\n      ∀ (n) (t : L.term (Sum α (fin n))) (xs : fin n → M),\n        (ft n t).realize (sum.elim v' xs) = t.realize (sum.elim v xs))\n    (h2 : ∀ (n) (R : L.relations n) (x : fin n → M), rel_map (fr n R) x = rel_map R x) :\n    (φ.map_term_rel ft fr fun _ => id).realize v' xs ↔ φ.realize v xs :=\n  by\n  induction' φ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 _ _ ih\n  · rfl\n  · simp [map_term_rel, realize, h1]\n  · simp [map_term_rel, realize, h1, h2]\n  · simp [map_term_rel, realize, ih1, ih2]\n  · simp only [map_term_rel, realize, ih, id.def]\n#align realize_map_term_rel_id realize_map_term_rel_id\n\n",
 "realize_map_term_rel_add_cast_le":
 "theorem realize_map_term_rel_add_cast_le [L'.Structure M] {k : ℕ}\n    {ft : ∀ n, L.term (Sum α (fin n)) → L'.term (Sum β (fin (k + n)))} {fr : ∀ n, L.relations n → L'.relations n} {n}\n    {φ : L.bounded_formula α n} (v : ∀ {n}, (fin (k + n) → M) → α → M) {v' : β → M} (xs : fin (k + n) → M)\n    (h1 :\n      ∀ (n) (t : L.term (Sum α (fin n))) (xs' : fin (k + n) → M),\n        (ft n t).realize (sum.elim v' xs') = t.realize (sum.elim (v xs') (xs' ∘ Fin.natAdd _)))\n    (h2 : ∀ (n) (R : L.relations n) (x : fin n → M), rel_map (fr n R) x = rel_map R x)\n    (hv : ∀ (n) (xs : fin (k + n) → M) (x : M), @v (n + 1) (snoc xs x : fin _ → M) = v xs) :\n    (φ.map_term_rel ft fr fun n => cast_le (add_assoc _ _ _).symm.le).realize v' xs ↔\n      φ.realize (v xs) (xs ∘ Fin.natAdd _) :=\n  by\n  induction' φ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 _ _ ih\n  · rfl\n  · simp [map_term_rel, realize, h1]\n  · simp [map_term_rel, realize, h1, h2]\n  · simp [map_term_rel, realize, ih1, ih2]\n  · simp [map_term_rel, realize, ih, hv]\n#align realize_map_term_rel_add_cast_le realize_map_term_rel_add_cast_le\n\n",
 "realize_lift_at_one_self":
 "@[simp]\ntheorem realize_lift_at_one_self {n : ℕ} {φ : L.bounded_formula α n} {v : α → M} {xs : fin (n + 1) → M} :\n    (φ.lift_at 1 n).realize v xs ↔ φ.realize v (xs ∘ cast_succ) :=\n  by\n  rw [realize_lift_at_one (refl n), iff_eq_eq]\n  refine' congr rfl (congr rfl (funext fun i => _))\n  rw [if_pos i.is_lt]\n#align realize_lift_at_one_self realize_lift_at_one_self\n\n",
 "realize_lift_at_one":
 "theorem realize_lift_at_one {n m : ℕ} {φ : L.bounded_formula α n} {v : α → M} {xs : fin (n + 1) → M} (hmn : m ≤ n) :\n    (φ.lift_at 1 m).realize v xs ↔ φ.realize v (xs ∘ fun i => if ↑i < m then castSucc i else i.succ) := by\n  simp_rw [realize_lift_at (add_le_add_right hmn 1), cast_succ, add_nat_one]\n#align realize_lift_at_one realize_lift_at_one\n\n",
 "realize_lift_at":
 "theorem realize_lift_at {n n' m : ℕ} {φ : L.bounded_formula α n} {v : α → M} {xs : fin (n + n') → M}\n    (hmn : m + n' ≤ n + 1) :\n    (φ.lift_at n' m).realize v xs ↔ φ.realize v (xs ∘ fun i => if ↑i < m then Fin.castAdd n' i else Fin.addNat n' i) :=\n  by\n  rw [lift_at]\n  induction' φ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 k _ ih3\n  · simp [realize, map_term_rel]\n  · simp [realize, map_term_rel, realize_rel, realize_lift_at, sum.elim_comp_map]\n  · simp [realize, map_term_rel, realize_rel, realize_lift_at, sum.elim_comp_map]\n  · simp only [map_term_rel, realize, ih1 hmn, ih2 hmn]\n  · have h : k + 1 + n' = k + n' + 1 := by rw [add_assoc, add_comm 1 n', ← add_assoc]\n    simp only [map_term_rel, realize, realize_cast_le_of_eq h, ih3 (hmn.trans k.succ.le_succ)]\n    refine' forall_congr' fun x => iff_eq_eq.mpr (congr rfl (funext (Fin.lastCases _ fun i => _)))\n    · simp only [Function.comp_apply, coe_last, snoc_last]\n      by_cases k < m\n      · rw [if_pos h]\n        refine' (congr rfl (ext _)).trans (snoc_last _ _)\n        simp only [coe_cast, coe_cast_add, coe_last, self_eq_add_right]\n        refine' le_antisymm (le_of_add_le_add_left ((hmn.trans (nat.succ_le_of_lt h)).trans _)) n'.zero_le\n        rw [add_zero]\n      · rw [if_neg h]\n        refine' (congr rfl (ext _)).trans (snoc_last _ _)\n        simp\n    · simp only [Function.comp_apply, fin.snoc_cast_succ]\n      refine' (congr rfl (ext _)).trans (snoc_cast_succ _ _ _)\n      simp only [cast_refl, coe_cast_succ, OrderIso.coe_refl, id.def]\n      split_ifs <;> simp\n#align realize_lift_at realize_lift_at\n\n",
 "realize_irreflexive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_irreflexive :\n    Theory.model M r.irreflexive ↔\n      irreflexive fun x y : M =>\n        rel_map r («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  forall_congr' fun _ => not_congr realize_rel₂\n#align realize_irreflexive realize_irreflexive\n\n",
 "realize_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem realize_inf : («expr ⊓ » φ ψ).realize v ↔ φ.realize v ∧ ψ.realize v :=\n  bounded_formula.realize_inf\n#align realize_inf realize_inf\n\n",
 "realize_imp":
 "@[simp]\ntheorem realize_imp : (φ.imp ψ).realize v ↔ φ.realize v → ψ.realize v :=\n  bounded_formula.realize_imp\n#align realize_imp realize_imp\n\n",
 "realize_iff_of_model_complete_theory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_iff_of_model_complete_theory [Theory.model N (L.complete_theory M)] (φ : L.sentence) :\n    Theory.model N φ ↔ Theory.model M φ :=\n  by\n  refine' ⟨fun h => _, (L.complete_theory M).realize_sentence_of_mem⟩\n  contrapose! h\n  rw [← sentence.realize_not] at *\n  exact (L.complete_theory M).realize_sentence_of_mem (mem_complete_theory.2 h)\n#align realize_iff_of_model_complete_theory realize_iff_of_model_complete_theory\n\n",
 "realize_iff":
 "@[simp]\ntheorem realize_iff : (φ.iff ψ).realize v ↔ (φ.realize v ↔ ψ.realize v) :=\n  bounded_formula.realize_iff\n#align realize_iff realize_iff\n\n",
 "realize_graph":
 "@[simp]\ntheorem realize_graph {f : L.functions n} {x : fin n → M} {y : M} :\n    (formula.graph f).realize (fin.cons y x : _ → M) ↔ fun_map f x = y :=\n  by\n  simp only [formula.graph, term.realize, realize_equal, fin.cons_zero, fin.cons_succ]\n  rw [eq_comm]\n#align realize_graph realize_graph\n\n",
 "realize_functions_apply₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_functions_apply₂ {f : L.functions 2} {t₁ t₂ : L.term α} {v : α → M} :\n    (f.apply₂ t₁ t₂).realize v =\n      fun_map f («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  rw [functions.apply₂, term.realize]\n  refine' congr rfl (funext (Fin.cases _ _))\n  · simp only [matrix.cons_val_zero]\n  · simp only [matrix.cons_val_succ, matrix.cons_val_fin_one, forall_const]\n#align realize_functions_apply₂ realize_functions_apply₂\n\n",
 "realize_functions_apply₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_functions_apply₁ {f : L.functions 1} {t : L.term α} {v : α → M} :\n    (f.apply₁ t).realize v =\n      fun_map f («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  rw [functions.apply₁, term.realize]\n  refine' congr rfl (funext fun i => _)\n  simp only [matrix.cons_val_fin_one]\n#align realize_functions_apply₁ realize_functions_apply₁\n\n",
 "realize_formula":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n@[simp]\ntheorem realize_formula (g : language.equiv M L N) (φ : L.formula α) {v : α → M} : φ.realize (g ∘ v) ↔ φ.realize v := by\n  rw [formula.realize, formula.realize, ← g.realize_bounded_formula φ, iff_eq_eq, unique.eq_default (g ∘ default)]\n#align realize_formula realize_formula\n\n",
 "realize_foldr_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem realize_foldr_sup (l : list (L.bounded_formula α n)) (v : α → M) (xs : fin n → M) :\n    (l.foldr («expr ⊔ » · ·) («expr⊥»)).realize v xs ↔ ∃ φ ∈ l, bounded_formula.realize φ v xs :=\n  by\n  induction' l with φ l ih\n  · simp\n  · simp_rw [List.foldr_cons, realize_sup, ih, exists_prop, List.mem_cons, or_and_right, exists_or, exists_eq_left]\n#align realize_foldr_sup realize_foldr_sup\n\n",
 "realize_foldr_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem realize_foldr_inf (l : list (L.bounded_formula α n)) (v : α → M) (xs : fin n → M) :\n    (l.foldr («expr ⊓ » · ·) («expr⊤»)).realize v xs ↔ ∀ φ ∈ l, bounded_formula.realize φ v xs :=\n  by\n  induction' l with φ l ih\n  · simp\n  · simp [ih]\n#align realize_foldr_inf realize_foldr_inf\n\n",
 "realize_exs":
 "@[simp]\ntheorem realize_exs {φ : L.bounded_formula α n} {v : α → M} : φ.exs.realize v ↔ ∃ xs : fin n → M, φ.realize v xs :=\n  by\n  induction' n with n ih\n  · exact unique.exists_iff.symm\n  · simp only [bounded_formula.exs, ih, realize_ex]\n    constructor\n    · rintro ⟨xs, x, h⟩\n      exact ⟨_, h⟩\n    · rintro ⟨xs, h⟩\n      rw [← fin.snoc_init_self xs] at h\n      exact ⟨_, _, h⟩\n#align realize_exs realize_exs\n\n",
 "realize_ex":
 "@[simp]\ntheorem realize_ex : θ.ex.realize v xs ↔ ∃ a : M, θ.realize v (fin.snoc xs a) :=\n  by\n  rw [bounded_formula.ex, realize_not, realize_all, not_forall]\n  simp_rw [realize_not, not_not]\n#align realize_ex realize_ex\n\n",
 "realize_equiv_sentence_symm_con":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem realize_equiv_sentence_symm_con [(language.with_constants L α).Structure M]\n    [(L.Lhom_with_constants α).is_expansion_on M] (φ : (language.with_constants L α).sentence) :\n    ((equiv_sentence.symm φ).realize fun a => (L.con a : M)) ↔ φ.realize M :=\n  by\n  simp only [equiv_sentence, equiv.symm_symm, equiv.coe_trans, realize, bounded_formula.realize_relabel_equiv]\n  refine' trans _ bounded_formula.realize_constants_vars_equiv\n  congr with (i | i)\n  · rfl\n  · exact i.elim\n#align realize_equiv_sentence_symm_con realize_equiv_sentence_symm_con\n\n",
 "realize_equiv_sentence_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem realize_equiv_sentence_symm (φ : (language.with_constants L α).sentence) (v : α → M) :\n    (equiv_sentence.symm φ).realize v ↔\n      @sentence.realize _ M (@language.with_constants_Structure L M _ α (constants_on.Structure v)) φ :=\n  letI := constants_on.Structure v\n  realize_equiv_sentence_symm_con M φ\n#align realize_equiv_sentence_symm realize_equiv_sentence_symm\n\n",
 "realize_equiv_sentence":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem realize_equiv_sentence [(language.with_constants L α).Structure M] [(L.Lhom_with_constants α).is_expansion_on M]\n    (φ : L.formula α) : (equiv_sentence φ).realize M ↔ φ.realize fun a => (L.con a : M) := by\n  rw [← realize_equiv_sentence_symm_con M (equiv_sentence φ), _root_.equiv.symm_apply_apply]\n#align realize_equiv_sentence realize_equiv_sentence\n\n",
 "realize_equal":
 "@[simp]\ntheorem realize_equal {t₁ t₂ : L.term α} {x : α → M} : (t₁.equal t₂).realize x ↔ t₁.realize x = t₂.realize x := by\n  simp [term.equal, realize]\n#align realize_equal realize_equal\n\n",
 "realize_constants_vars_equiv_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem realize_constants_vars_equiv_left [(language.with_constants L α).Structure M]\n    [(Lhom_with_constants L α).is_expansion_on M] {n} {t : (language.with_constants L α).term (Sum β (fin n))}\n    {v : β → M} {xs : fin n → M} :\n    (constants_vars_equiv_left t).realize (sum.elim (sum.elim (fun a => ↑(L.con a)) v) xs) =\n      t.realize (sum.elim v xs) :=\n  by\n  simp only [constants_vars_equiv_left, realize_relabel, equiv.coe_trans, Function.comp_apply,\n    constants_vars_equiv_apply, relabel_equiv_symm_apply]\n  refine' trans _ realize_constants_to_vars\n  rcongr\n  rcases x with (a | (b | i)) <;> simp\n#align realize_constants_vars_equiv_left realize_constants_vars_equiv_left\n\n",
 "realize_constants_vars_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\ntheorem realize_constants_vars_equiv [(language.with_constants L α).Structure M]\n    [(Lhom_with_constants L α).is_expansion_on M] {n} {φ : (language.with_constants L α).bounded_formula β n}\n    {v : β → M} {xs : fin n → M} :\n    (constants_vars_equiv φ).realize (sum.elim (fun a => ↑(L.con a)) v) xs ↔ φ.realize v xs :=\n  by\n  refine' realize_map_term_rel_id (fun n t xs => realize_constants_vars_equiv_left) fun n R xs => _\n  rw [← (Lhom_with_constants L α).map_on_relation (Equiv.sumEmpty (L.relations n) ((constants_on α).relations n) R) xs]\n  rcongr\n  cases R\n  · simp\n  · exact is_empty_elim R\n#align realize_constants_vars_equiv realize_constants_vars_equiv\n\n",
 "realize_constants_to_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem realize_constants_to_vars [(language.with_constants L α).Structure M]\n    [(Lhom_with_constants L α).is_expansion_on M] {t : (language.with_constants L α).term β} {v : β → M} :\n    t.constants_to_vars.realize (sum.elim (fun a => ↑(L.con a)) v) = t.realize v :=\n  by\n  induction' t with _ n f _ ih\n  · simp\n  · cases n\n    · cases f\n      · simp [ih]\n      · simp only [realize, constants_to_vars, sum.elim_inl, fun_map_eq_coe_constants]\n        rfl\n    · cases f\n      · simp [ih]\n      · exact is_empty_elim f\n#align realize_constants_to_vars realize_constants_to_vars\n\n",
 "realize_constants":
 "@[simp]\ntheorem realize_constants {c : L.constants} {v : α → M} : c.term.realize v = c :=\n  fun_map_eq_coe_constants\n#align realize_constants realize_constants\n\n",
 "realize_con":
 "theorem realize_con {A : set M} {a : A} {v : α → M} : (L.con a).term.realize v = a :=\n  rfl\n#align realize_con realize_con\n\n",
 "realize_cast_le_of_eq":
 "theorem realize_cast_le_of_eq {m n : ℕ} (h : m = n) {h' : m ≤ n} {φ : L.bounded_formula α m} {v : α → M}\n    {xs : fin n → M} : (φ.cast_le h').realize v xs ↔ φ.realize v (xs ∘ Fin.cast h) :=\n  by\n  subst h\n  simp only [cast_le_rfl, cast_refl, OrderIso.coe_refl, function.comp.right_id]\n#align realize_cast_le_of_eq realize_cast_le_of_eq\n\n",
 "realize_card_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem sentence.realize_card_ge (n) : Theory.model M (sentence.card_ge L n) ↔ ↑n ≤ cardinal.mk M :=\n  by\n  rw [← lift_mk_fin, ← lift_le, lift_lift, lift_mk_le, sentence.card_ge, sentence.realize, bounded_formula.realize_exs]\n  simp_rw [bounded_formula.realize_foldr_inf]\n  simp only [Function.comp_apply, List.mem_map', prod.exists, ne.def, List.mem_product, List.mem_finRange,\n    forall_exists_index, and_imp, List.mem_filter, true_and_iff]\n  refine' ⟨_, fun xs => ⟨xs.some, _⟩⟩\n  · rintro ⟨xs, h⟩\n    refine' ⟨⟨xs, fun i j ij => _⟩⟩\n    contrapose! ij\n    have hij := h _ i j ij rfl\n    simp only [bounded_formula.realize_not, term.realize, bounded_formula.realize_bd_equal, sum.elim_inr] at hij\n    exact hij\n  · rintro _ i j ij rfl\n    simp [ij]\n#align sentence.realize_card_ge sentence.realize_card_ge\n\n",
 "realize_bounded_formula":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n@[simp]\ntheorem realize_bounded_formula (g : language.equiv M L N) (φ : L.bounded_formula α n) {v : α → M} {xs : fin n → M} :\n    φ.realize (g ∘ v) (g ∘ xs) ↔ φ.realize v xs :=\n  by\n  induction' φ with _ _ _ _ _ _ _ _ _ _ _ ih1 ih2 _ _ ih3\n  · rfl\n  · simp only [bounded_formula.realize, ← sum.comp_elim, equiv.realize_term, g.injective.eq_iff]\n  · simp only [bounded_formula.realize, ← sum.comp_elim, equiv.realize_term, g.map_rel]\n  · rw [bounded_formula.realize, ih1, ih2, bounded_formula.realize]\n  · rw [bounded_formula.realize, bounded_formula.realize]\n    constructor\n    · intro h a\n      have h' := h (g a)\n      rw [← fin.comp_snoc, ih3] at h'\n      exact h'\n    · intro h a\n      have h' := h (g.symm a)\n      rw [← ih3, fin.comp_snoc, g.apply_symm_apply] at h'\n      exact h'\n#align realize_bounded_formula realize_bounded_formula\n\n",
 "realize_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem realize_bot : («expr⊥» : L.formula α).realize v ↔ false :=\n  iff.rfl\n#align realize_bot realize_bot\n\n",
 "realize_bd_equal":
 "@[simp]\ntheorem realize_bd_equal (t₁ t₂ : L.term (Sum α (fin l))) :\n    (t₁.bd_equal t₂).realize v xs ↔ t₁.realize (sum.elim v xs) = t₂.realize (sum.elim v xs) :=\n  iff.rfl\n#align realize_bd_equal realize_bd_equal\n\n",
 "realize_antisymmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem realize_antisymmetric :\n    Theory.model M r.antisymmetric ↔\n      anti_symmetric fun x y : M =>\n        rel_map r («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  forall_congr' fun _ => forall_congr' fun _ => imp_congr realize_rel₂ (imp_congr realize_rel₂ iff.rfl)\n#align realize_antisymmetric realize_antisymmetric\n\n",
 "realize_alls":
 "@[simp]\ntheorem realize_alls {φ : L.bounded_formula α n} {v : α → M} : φ.alls.realize v ↔ ∀ xs : fin n → M, φ.realize v xs :=\n  by\n  induction' n with n ih\n  · exact unique.forall_iff.symm\n  · simp only [alls, ih, realize]\n    exact ⟨fun h xs => fin.snoc_init_self xs ▸ h _ _, fun h xs x => h (fin.snoc xs x)⟩\n#align realize_alls realize_alls\n\n",
 "realize_all_lift_at_one_self":
 "theorem realize_all_lift_at_one_self {n : ℕ} {φ : L.bounded_formula α n} {v : α → M} {xs : fin n → M} :\n    (φ.lift_at 1 n).all.realize v xs ↔ φ.realize v xs :=\n  by\n  inhabit M\n  simp only [realize_all, realize_lift_at_one_self]\n  refine' ⟨fun h => _, fun h a => _⟩\n  · refine' (congr rfl (funext fun i => _)).mp (h default)\n    simp\n  · refine' (congr rfl (funext fun i => _)).mp h\n    simp\n#align realize_all_lift_at_one_self realize_all_lift_at_one_self\n\n",
 "realize_all":
 "@[simp]\ntheorem realize_all : (all θ).realize v xs ↔ ∀ a : M, θ.realize v (fin.snoc xs a) :=\n  iff.rfl\n#align realize_all realize_all\n\n",
 "on_Theory_model":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem Lhom.on_Theory_model [L'.Structure M] (φ : «expr →ᴸ » L L') [φ.is_expansion_on M] (T : L.Theory) :\n    Theory.model M (φ.on_Theory T) ↔ Theory.model M T := by simp [Theory.model_iff, Lhom.on_Theory]\n#align Lhom.on_Theory_model Lhom.on_Theory_model\n\n",
 "nonempty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\ntheorem nonempty_iff (h : elementarily_equivalent M L N) : nonempty M ↔ nonempty N :=\n  (model_nonempty_theory_iff L).symm.trans (h.Theory_model_iff.trans (model_nonempty_theory_iff L))\n#align nonempty_iff nonempty_iff\n\n",
 "nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\ntheorem nonempty [Mn : nonempty M] (h : elementarily_equivalent M L N) : nonempty N :=\n  h.nonempty_iff.1 Mn\n#align nonempty nonempty\n\n",
 "mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem model.mono {T' : L.Theory} (h : Theory.model M T') (hs : T ⊆ T') : Theory.model M T :=\n  ⟨fun φ hφ => T'.realize_sentence_of_mem (hs hφ)⟩\n#align model.mono model.mono\n\n",
 "model_union_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem model_union_iff {T' : L.Theory} : Theory.model M (T ∪ T') ↔ Theory.model M T ∧ Theory.model M T' :=\n  ⟨fun h => ⟨h.mono (T.subset_union_left T'), h.mono (T.subset_union_right T')⟩, fun h => h.1.union h.2⟩\n#align model_union_iff model_union_iff\n\n",
 "model_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem model_singleton_iff {φ : L.sentence} : Theory.model M ({φ} : L.Theory) ↔ Theory.model M φ := by simp\n#align model_singleton_iff model_singleton_iff\n\n",
 "model_nonempty_theory_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem model_nonempty_theory_iff : Theory.model M L.nonempty_theory ↔ nonempty M := by\n  simp only [nonempty_theory, Theory.model_iff, Set.mem_singleton_iff, forall_eq, sentence.realize_card_ge,\n    Nat.cast_one, one_le_iff_ne_zero, mk_ne_zero_iff]\n#align model_nonempty_theory_iff model_nonempty_theory_iff\n\n",
 "model_infinite_theory_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem model_infinite_theory_iff : Theory.model M L.infinite_theory ↔ Infinite M := by\n  simp [infinite_theory, infinite_iff, aleph_0_le]\n#align model_infinite_theory_iff model_infinite_theory_iff\n\n",
 "model_iff_subset_complete_theory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem model_iff_subset_complete_theory : Theory.model M T ↔ T ⊆ L.complete_theory M :=\n  T.model_iff\n#align model_iff_subset_complete_theory model_iff_subset_complete_theory\n\n",
 "model_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n-- input using \\|= or \\vDash, but not using \\models\n@[simp]\ntheorem Theory.model_iff : Theory.model M T ↔ ∀ φ ∈ T, Theory.model M φ :=\n  ⟨fun h => h.realize_of_mem, fun h => ⟨h⟩⟩\n#align Theory.model_iff Theory.model_iff\n\n",
 "model_distinct_constants_theory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem model_distinct_constants_theory {M : Type w} [(language.with_constants L α).Structure M] (s : set α) :\n    Theory.model M (L.distinct_constants_theory s) ↔ Set.InjOn (fun i : α => (L.con i : M)) s :=\n  by\n  simp only [distinct_constants_theory, Theory.model_iff, Set.mem_image, Set.mem_inter, Set.mem_prod, Set.mem_compl,\n    prod.exists, forall_exists_index, and_imp]\n  refine' ⟨fun h a as b bs ab => _, _⟩\n  · contrapose! ab\n    have h' := h _ a b ⟨⟨as, bs⟩, ab⟩ rfl\n    simp only [sentence.realize, formula.realize_not, formula.realize_equal, term.realize_constants] at h'\n    exact h'\n  · rintro h φ a b ⟨⟨as, bs⟩, ab⟩ rfl\n    simp only [sentence.realize, formula.realize_not, formula.realize_equal, term.realize_constants]\n    exact fun contra => ab (h as bs contra)\n#align model_distinct_constants_theory model_distinct_constants_theory\n\n",
 "mem_complete_theory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\n@[simp]\ntheorem mem_complete_theory {φ : sentence L} : φ ∈ L.complete_theory M ↔ sentence.realize M φ :=\n  iff.rfl\n#align mem_complete_theory mem_complete_theory\n\n",
 "infinite_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\ntheorem infinite_iff (h : elementarily_equivalent M L N) : Infinite M ↔ Infinite N :=\n  (model_infinite_theory_iff L).symm.trans (h.Theory_model_iff.trans (model_infinite_theory_iff L))\n#align infinite_iff infinite_iff\n\n",
 "elementarily_equivalent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sentence.realize -/\ntheorem elementarily_equivalent_iff :\n    elementarily_equivalent M L N ↔ ∀ φ : L.sentence, sentence.realize M φ ↔ sentence.realize N φ := by\n  simp only [elementarily_equivalent, Set.ext_iff, complete_theory, Set.mem_setOf_eq]\n#align elementarily_equivalent_iff elementarily_equivalent_iff\n\n",
 "elementarily_equivalent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\ntheorem elementarily_equivalent (g : language.equiv M L N) : elementarily_equivalent M L N :=\n  elementarily_equivalent_iff.2 g.realize_sentence\n#align elementarily_equivalent elementarily_equivalent\n\n",
 "complete_theory_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\ntheorem complete_theory_eq (h : elementarily_equivalent M L N) : L.complete_theory M = L.complete_theory N :=\n  h\n#align complete_theory_eq complete_theory_eq\n\n",
 "card_le_of_model_distinct_constants_theory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem card_le_of_model_distinct_constants_theory (s : set α) (M : Type w) [(language.with_constants L α).Structure M]\n    [h : Theory.model M (L.distinct_constants_theory s)] :\n    cardinal.lift.{w} (cardinal.mk s) ≤ cardinal.lift.{u'} (cardinal.mk M) :=\n  lift_mk_le'.2 ⟨⟨_, Set.injOn_iff_injective.1 ((L.model_distinct_constants_theory s).1 h)⟩⟩\n#align card_le_of_model_distinct_constants_theory card_le_of_model_distinct_constants_theory\n\n",
 "Theory_model_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem Theory_model_iff (h : elementarily_equivalent M L N) : Theory.model M T ↔ Theory.model N T := by\n  rw [Theory.model_iff_subset_complete_theory, Theory.model_iff_subset_complete_theory, h.complete_theory_eq]\n#align Theory_model_iff Theory_model_iff\n\n",
 "Theory_model":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem Theory_model [MT : Theory.model M T] (h : elementarily_equivalent M L N) : Theory.model N T :=\n  h.Theory_model_iff.1 MT\n#align Theory_model Theory_model\n\n",
 "Infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `elementarily_equivalent -/\n#print Infinite /-\ntheorem Infinite [Mi : Infinite M] (h : elementarily_equivalent M L N) : Infinite N :=\n  h.infinite_iff.1 Mi\n#align infinite Infinite\n-/\n\n"}