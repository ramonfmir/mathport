{"nonempty":
 "theorem age.nonempty : (L.age M).nonempty :=\n  ⟨bundled.of (substructure.closure L (∅ : set M)), (fg_iff_Structure_fg _).1 (fg_closure set.finite_empty),\n    ⟨substructure.subtype _⟩⟩\n#align age.nonempty age.nonempty\n\n",
 "mem_age_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\ntheorem Structure.fg.mem_age_of_equiv {M N : bundled L.Structure} (h : Structure.fg L M)\n    (MN : nonempty (language.equiv M L N)) : N ∈ L.age M :=\n  ⟨MN.some.fg_iff.1 h, ⟨MN.some.symm.to_embedding⟩⟩\n#align Structure.fg.mem_age_of_equiv Structure.fg.mem_age_of_equiv\n\n",
 "joint_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem age.joint_embedding : joint_embedding (L.age M) := fun N hN P hP =>\n  ⟨bundled.of («expr↥ » («expr ⊔ » hN.2.some.to_hom.range hP.2.some.to_hom.range)),\n    ⟨(fg_iff_Structure_fg _).1 ((hN.1.range hN.2.some.to_hom).sup (hP.1.range hP.2.some.to_hom)), ⟨subtype _⟩⟩,\n    ⟨embedding.comp (inclusion le_sup_left) hN.2.some.equiv_range.to_embedding⟩,\n    ⟨embedding.comp (inclusion le_sup_right) hP.2.some.equiv_range.to_embedding⟩⟩\n#align age.joint_embedding age.joint_embedding\n\n",
 "is_fraisse":
 "/-- If a class has a Fraïssé limit, it must be Fraïssé. -/\ntheorem is_fraisse [countable (Σl, L.functions l)] [countable M] (h : is_fraisse_limit K M) : is_fraisse K :=\n  (congr rfl h.age).mp h.ultrahomogeneous.age_is_fraisse\n#align is_fraisse is_fraisse\n\n",
 "is_equiv_invariant_of_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\ntheorem hereditary.is_equiv_invariant_of_fg (h : hereditary K)\n    (fg : ∀ M : bundled.{w} L.Structure, M ∈ K → Structure.fg L M) (M N : bundled.{w} L.Structure)\n    (hn : nonempty (language.equiv M L N)) : M ∈ K ↔ N ∈ K :=\n  ⟨fun MK => h M MK ((fg M MK).mem_age_of_equiv hn), fun NK => h N NK ((fg N NK).mem_age_of_equiv ⟨hn.some.symm⟩)⟩\n#align hereditary.is_equiv_invariant_of_fg hereditary.is_equiv_invariant_of_fg\n\n",
 "is_equiv_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem age.is_equiv_invariant (N P : bundled.{w} L.Structure) (h : nonempty (language.equiv N L P)) :\n    N ∈ L.age M ↔ P ∈ L.age M :=\n  and_congr h.some.fg_iff\n    ⟨nonempty.map fun x => embedding.comp x h.some.symm.to_embedding,\n      nonempty.map fun x => embedding.comp x h.some.to_embedding⟩\n#align age.is_equiv_invariant age.is_equiv_invariant\n\n",
 "hereditary":
 "theorem age.hereditary : hereditary (L.age M) := fun N hN P hP => hN.2.some.age_subset_age hP\n#align age.hereditary age.hereditary\n\n",
 "exists_countable_is_age_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem exists_countable_is_age_of_iff [countable (Σl, L.functions l)] :\n    (∃ M : bundled.{w} L.Structure, countable M ∧ L.age M = K) ↔\n      K.nonempty ∧\n        (∀ M N : bundled.{w} L.Structure, nonempty (language.equiv M L N) → (M ∈ K ↔ N ∈ K)) ∧\n          («expr '' » Quotient.mk'' K).countable ∧\n            (∀ M : bundled.{w} L.Structure, M ∈ K → Structure.fg L M) ∧ hereditary K ∧ joint_embedding K :=\n  by\n  constructor\n  · rintro ⟨M, h1, h2, rfl⟩\n    skip\n    refine'\n      ⟨age.nonempty M, age.is_equiv_invariant L M, age.countable_quotient M, fun N hN => hN.1, age.hereditary M,\n        age.joint_embedding M⟩\n  · rintro ⟨Kn, eqinv, cq, hfg, hp, jep⟩\n    obtain ⟨M, hM, rfl⟩ := exists_cg_is_age_of Kn eqinv cq hfg hp jep\n    exact ⟨M, Structure.cg_iff_countable.1 hM, rfl⟩\n#align exists_countable_is_age_of_iff exists_countable_is_age_of_iff\n\n",
 "exists_cg_is_age_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Sufficient conditions for a class to be the age of a countably-generated structure. -/\ntheorem exists_cg_is_age_of (hn : K.nonempty)\n    (h : ∀ M N : bundled.{w} L.Structure, nonempty (language.equiv M L N) → (M ∈ K ↔ N ∈ K))\n    (hc : («expr '' » Quotient.mk'' K).countable) (fg : ∀ M : bundled.{w} L.Structure, M ∈ K → Structure.fg L M)\n    (hp : hereditary K) (jep : joint_embedding K) : ∃ M : bundled.{w} L.Structure, Structure.cg L M ∧ L.age M = K :=\n  by\n  obtain ⟨F, hF⟩ := hc.exists_eq_range (hn.image _)\n  simp only [Set.ext_iff, forall_quotient_iff, mem_image, mem_range, quotient.eq] at hF\n  simp_rw [quotient.eq_mk_iff_out] at hF\n  have hF' : ∀ n : ℕ, (F n).out ∈ K := by\n    intro n\n    obtain ⟨P, hP1, hP2⟩ := (hF (F n).out).2 ⟨n, setoid.refl _⟩\n    exact (h _ _ hP2).1 hP1\n  choose P hPK hP hFP using fun (N : K) (n : ℕ) => jep N N.2 (F (n + 1)).out (hF' _)\n  let G : ℕ → K := @nat.rec (fun _ => K) ⟨(F 0).out, hF' 0⟩ fun n N => ⟨P N n, hPK N n⟩\n  let f : ∀ i j, i ≤ j → language.embedding (G i) L (G j) := directed_system.nat_le_rec fun n => (hP _ n).some\n  refine'\n    ⟨bundled.of (direct_limit (fun n => G n) f), direct_limit.cg _ fun n => (fg _ (G n).2).cg,\n      (age_direct_limit _ _).trans (subset_antisymm (Union_subset fun n N hN => hp (G n) (G n).2 hN) fun N KN => _)⟩\n  obtain ⟨n, ⟨e⟩⟩ := (hF N).1 ⟨N, KN, setoid.refl _⟩\n  refine' mem_Union_of_mem n ⟨fg _ KN, ⟨embedding.comp _ e.symm.to_embedding⟩⟩\n  cases n\n  · exact embedding.refl _ _\n  · exact (hFP _ n).some\n#align exists_cg_is_age_of exists_cg_is_age_of\n\n",
 "countable_quotient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The age of a countable structure is essentially countable (has countably many isomorphism\nclasses). -/\ntheorem age.countable_quotient [h : countable M] : («expr '' » Quotient.mk'' (L.age M)).countable := by\n  classical\n    refine'\n      (congr_arg _ (Set.ext <| forall_quotient_iff.2 fun N => _)).mp\n        (countable_range fun s : Finset M => «expr⟦ ⟧» ⟨closure L (s : set M), infer_instance⟩)\n    simp only [mem_image, mem_range, mem_set_of_eq, quotient.eq]\n    constructor\n    · rintro ⟨s, hs⟩\n      use bundled.of («expr↥ » (closure L (s : set M)))\n      exact ⟨⟨(fg_iff_Structure_fg _).1 (fg_closure s.finite_to_set), ⟨subtype _⟩⟩, hs⟩\n    · rintro ⟨P, ⟨⟨s, hs⟩, ⟨PM⟩⟩, hP2⟩\n      refine' ⟨s.image PM, setoid.trans _ hP2⟩\n      rw [← embedding.coe_to_hom, Finset.coe_image, closure_image PM.to_hom, hs, ← hom.range_eq_map]\n      exact ⟨PM.equiv_range.symm⟩\n#align age.countable_quotient age.countable_quotient\n\n",
 "amalgamation_age":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem is_ultrahomogeneous.amalgamation_age (h : L.is_ultrahomogeneous M) : amalgamation (L.age M) :=\n  by\n  rintro N P Q NP NQ ⟨Nfg, ⟨NM⟩⟩ ⟨Pfg, ⟨PM⟩⟩ ⟨Qfg, ⟨QM⟩⟩\n  obtain ⟨g, hg⟩ :=\n    h (PM.comp NP).to_hom.range (Nfg.range _) ((QM.comp NQ).comp (PM.comp NP).equiv_range.symm.to_embedding)\n  let s := «expr ⊔ » (g.to_hom.comp PM.to_hom).range QM.to_hom.range\n  refine'\n    ⟨bundled.of s,\n      embedding.comp (substructure.inclusion le_sup_left) (g.to_embedding.comp PM).equiv_range.to_embedding,\n      embedding.comp (substructure.inclusion le_sup_right) QM.equiv_range.to_embedding,\n      ⟨(fg_iff_Structure_fg _).1 (fg.sup (Pfg.range _) (Qfg.range _)), ⟨substructure.subtype _⟩⟩, _⟩\n  ext n\n  have hgn := (embedding.ext_iff.1 hg) ((PM.comp NP).equiv_range n)\n  simp only [embedding.comp_apply, Equiv.coe_toEmbedding, equiv.symm_apply_apply, substructure.coe_subtype,\n    embedding.equiv_range_apply] at hgn\n  simp only [embedding.comp_apply, Equiv.coe_toEmbedding, substructure.coe_inclusion, Set.coe_inclusion,\n    embedding.equiv_range_apply, hgn]\n#align is_ultrahomogeneous.amalgamation_age is_ultrahomogeneous.amalgamation_age\n\n",
 "age_subset_age":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\ntheorem embedding.age_subset_age (MN : language.embedding M L N) : L.age M ⊆ L.age N := fun _ =>\n  and.imp_right (nonempty.map MN.comp)\n#align embedding.age_subset_age embedding.age_subset_age\n\n",
 "age_is_fraisse":
 "theorem is_ultrahomogeneous.age_is_fraisse [countable M] (h : L.is_ultrahomogeneous M) : is_fraisse (L.age M) :=\n  ⟨age.nonempty M, fun _ hN => hN.1, age.is_equiv_invariant L M, age.countable_quotient M, age.hereditary M,\n    age.joint_embedding M, h.amalgamation_age⟩\n#align is_ultrahomogeneous.age_is_fraisse is_ultrahomogeneous.age_is_fraisse\n\n",
 "age_eq_age":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.equiv -/\ntheorem equiv.age_eq_age (MN : language.equiv M L N) : L.age M = L.age N :=\n  le_antisymm MN.to_embedding.age_subset_age MN.symm.to_embedding.age_subset_age\n#align equiv.age_eq_age equiv.age_eq_age\n\n",
 "age_direct_limit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.embedding -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The age of a direct limit of structures is the union of the ages of the structures. -/\n@[simp]\ntheorem age_direct_limit {ι : Type w} [preorder ι] [IsDirected ι (· ≤ ·)] [nonempty ι] (G : ι → Type max w w')\n    [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → language.embedding (G i) L (G j))\n    [directed_system G fun i j h => f i j h] :\n    L.age (direct_limit G f) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (L.age (G i)) :=\n  by\n  classical\n    ext M\n    simp only [mem_Union]\n    constructor\n    · rintro ⟨Mfg, ⟨e⟩⟩\n      obtain ⟨s, hs⟩ := Mfg.range e.to_hom\n      let out := @quotient.out _ (direct_limit.setoid G f)\n      obtain ⟨i, hi⟩ := Finset.exists_le (s.image (sigma.fst ∘ out))\n      have e' := (direct_limit.of L ι G f i).equiv_range.symm.to_embedding\n      refine' ⟨i, Mfg, ⟨e'.comp ((substructure.inclusion _).comp e.equiv_range.to_embedding)⟩⟩\n      rw [← hs, closure_le]\n      intro x hx\n      refine' ⟨f (out x).1 i (hi (out x).1 (Finset.mem_image_of_mem _ hx)) (out x).2, _⟩\n      rw [embedding.coe_to_hom, direct_limit.of_apply, quotient.mk_eq_iff_out,\n        direct_limit.equiv_iff G f _ (hi (out x).1 (Finset.mem_image_of_mem _ hx)), directed_system.map_self]\n      rfl\n    · rintro ⟨i, Mfg, ⟨e⟩⟩\n      exact ⟨Mfg, ⟨embedding.comp (direct_limit.of L ι G f i) e⟩⟩\n#align age_direct_limit age_direct_limit\n\n"}