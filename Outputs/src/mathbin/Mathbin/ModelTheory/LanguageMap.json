{"with_constants_rel_map_sum_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem with_constants_rel_map_sum_inl [(language.with_constants L α).Structure M]\n    [(Lhom_with_constants L α).is_expansion_on M] {n} {R : L.relations n} {x : fin n → M} :\n    @rel_map (language.with_constants L α) M _ n (sum.inl R) x = rel_map R x :=\n  (Lhom_with_constants L α).map_on_relation R x\n#align with_constants_rel_map_sum_inl with_constants_rel_map_sum_inl\n\n",
 "with_constants_fun_map_sum_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem with_constants_fun_map_sum_inr {a : α} {x : fin 0 → M} :\n    @fun_map (language.with_constants L α) M _ 0 (sum.inr a : (language.with_constants L α).functions 0) x = L.con a :=\n  by\n  rw [unique.eq_default x]\n  exact (Lhom.sum_inr : «expr →ᴸ » (constants_on α) (L.sum _)).map_on_function _ _\n#align with_constants_fun_map_sum_inr with_constants_fun_map_sum_inr\n\n",
 "with_constants_fun_map_sum_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n@[simp]\ntheorem with_constants_fun_map_sum_inl [(language.with_constants L α).Structure M]\n    [(Lhom_with_constants L α).is_expansion_on M] {n} {f : L.functions n} {x : fin n → M} :\n    @fun_map (language.with_constants L α) M _ n (sum.inl f) x = fun_map f x :=\n  (Lhom_with_constants L α).map_on_function f x\n#align with_constants_fun_map_sum_inl with_constants_fun_map_sum_inl\n\n",
 "sum_map_comp_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n@[simp]\ntheorem sum_map_comp_inr : Lhom.comp (ϕ.sum_map ψ) Lhom.sum_inr = Lhom.comp Lhom.sum_inr ψ :=\n  Lhom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n#align sum_map_comp_inr sum_map_comp_inr\n\n",
 "sum_map_comp_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n@[simp]\ntheorem sum_map_comp_inl : Lhom.comp (ϕ.sum_map ψ) Lhom.sum_inl = Lhom.comp Lhom.sum_inl ϕ :=\n  Lhom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n#align sum_map_comp_inl sum_map_comp_inl\n\n",
 "sum_inr_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\ntheorem sum_inr_injective : (Lhom.sum_inr : «expr →ᴸ » L' (L.sum L')).injective :=\n  ⟨fun n => sum.inr_injective, fun n => sum.inr_injective⟩\n#align sum_inr_injective sum_inr_injective\n\n",
 "sum_inl_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\ntheorem sum_inl_injective : (Lhom.sum_inl : «expr →ᴸ » L (L.sum L')).injective :=\n  ⟨fun n => sum.inl_injective, fun n => sum.inl_injective⟩\n#align sum_inl_injective sum_inl_injective\n\n",
 "sum_elim_inl_inr":
 "theorem sum_elim_inl_inr : Lhom.sum_inl.sum_elim Lhom.sum_inr = Lhom.id (L.sum L') :=\n  Lhom.funext (funext fun _ => sum.elim_inl_inr) (funext fun _ => sum.elim_inl_inr)\n#align sum_elim_inl_inr sum_elim_inl_inr\n\n",
 "sum_elim_comp_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\ntheorem sum_elim_comp_inr (ψ : «expr →ᴸ » L'' L') : Lhom.comp (ϕ.sum_elim ψ) Lhom.sum_inr = ψ :=\n  Lhom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n#align sum_elim_comp_inr sum_elim_comp_inr\n\n",
 "sum_elim_comp_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\ntheorem sum_elim_comp_inl (ψ : «expr →ᴸ » L'' L') : Lhom.comp (ϕ.sum_elim ψ) Lhom.sum_inl = ϕ :=\n  Lhom.funext (funext fun _ => rfl) (funext fun _ => rfl)\n#align sum_elim_comp_inl sum_elim_comp_inl\n\n",
 "mk₂_funext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\ntheorem mk₂_funext {c f₁ f₂ : Type u} {r₁ r₂ : Type v} {F G : «expr →ᴸ » (language.mk₂ c f₁ f₂ r₁ r₂) L'}\n    (h0 : ∀ c : (language.mk₂ c f₁ f₂ r₁ r₂).constants, F.on_function c = G.on_function c)\n    (h1 : ∀ f : (language.mk₂ c f₁ f₂ r₁ r₂).functions 1, F.on_function f = G.on_function f)\n    (h2 : ∀ f : (language.mk₂ c f₁ f₂ r₁ r₂).functions 2, F.on_function f = G.on_function f)\n    (h1' : ∀ r : (language.mk₂ c f₁ f₂ r₁ r₂).relations 1, F.on_relation r = G.on_relation r)\n    (h2' : ∀ r : (language.mk₂ c f₁ f₂ r₁ r₂).relations 2, F.on_relation r = G.on_relation r) : F = G :=\n  Lhom.funext\n    (funext fun n =>\n      nat.cases_on n (funext h0) fun n =>\n        nat.cases_on n (funext h1) fun n => nat.cases_on n (funext h2) fun n => funext fun f => pempty.elim f)\n    (funext fun n =>\n      nat.cases_on n (funext fun r => pempty.elim r) fun n =>\n        nat.cases_on n (funext h1') fun n => nat.cases_on n (funext h2') fun n => funext fun r => pempty.elim r)\n#align mk₂_funext mk₂_funext\n\n",
 "map_on_relation":
 "@[simp]\ntheorem map_on_relation {M : Type _} [L.Structure M] [L'.Structure M] [ϕ.is_expansion_on M] {n} (R : L.relations n)\n    (x : fin n → M) : rel_map (ϕ.on_relation R) x = rel_map R x :=\n  is_expansion_on.map_on_relation R x\n#align map_on_relation map_on_relation\n\n",
 "map_on_function":
 "@[simp]\ntheorem map_on_function {M : Type _} [L.Structure M] [L'.Structure M] [ϕ.is_expansion_on M] {n} (f : L.functions n)\n    (x : fin n → M) : fun_map (ϕ.on_function f) x = fun_map f x :=\n  is_expansion_on.map_on_function f x\n#align map_on_function map_on_function\n\n",
 "map_constants_comp_sum_inl":
 "@[simp]\ntheorem Lhom.map_constants_comp_sum_inl {f : α → β} :\n    (L.Lhom_with_constants_map f).comp Lhom.sum_inl = L.Lhom_with_constants β := by ext (n f R) <;> rfl\n#align Lhom.map_constants_comp_sum_inl Lhom.map_constants_comp_sum_inl\n\n",
 "is_expansion_on_default":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\ntheorem injective.is_expansion_on_default {ϕ : «expr →ᴸ » L L'}\n    [∀ (n) (f : L'.functions n), decidable (f ∈ Set.range fun f : L.functions n => on_function ϕ f)]\n    [∀ (n) (r : L'.relations n), decidable (r ∈ Set.range fun r : L.relations n => on_relation ϕ r)] (h : ϕ.injective)\n    (M : Type _) [inhabited M] [L.Structure M] : @is_expansion_on L L' ϕ M _ (ϕ.default_expansion M) :=\n  by\n  letI := ϕ.default_expansion M\n  refine' ⟨fun n f xs => _, fun n r xs => _⟩\n  · have hf : ϕ.on_function f ∈ Set.range fun f : L.functions n => ϕ.on_function f := ⟨f, rfl⟩\n    refine' (dif_pos hf).trans _\n    rw [h.on_function hf.some_spec]\n  · have hr : ϕ.on_relation r ∈ Set.range fun r : L.relations n => ϕ.on_relation r := ⟨r, rfl⟩\n    refine' (dif_pos hr).trans _\n    rw [h.on_relation hr.some_spec]\n#align injective.is_expansion_on_default injective.is_expansion_on_default\n\n",
 "id_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n@[simp]\ntheorem id_comp (F : «expr →ᴸ » L L') : Lhom.comp (Lhom.id L') F = F :=\n  by\n  cases F\n  rfl\n#align id_comp id_comp\n\n",
 "funext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n#print funext /-\n/-\nCopyright (c) 2021 Aaron Anderson, Jesse Michael Han, Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson, Jesse Michael Han, Floris van Doorn\n-/\n-- \\^L\n@[ext]\nprotected theorem funext {F G : «expr →ᴸ » L L'} (h_fun : F.on_function = G.on_function)\n    (h_rel : F.on_relation = G.on_relation) : F = G :=\n  by\n  cases' F with Ff Fr\n  cases' G with Gf Gr\n  simp only [*]\n  exact and.intro h_fun h_rel\n#align funext funext\n-/\n\n",
 "fun_map_sum_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n@[simp]\ntheorem fun_map_sum_inr [(L'.sum L).Structure M] [(Lhom.sum_inr : «expr →ᴸ » L (L'.sum L)).is_expansion_on M] {n}\n    {f : L.functions n} {x : fin n → M} : @fun_map (L'.sum L) M _ n (sum.inr f) x = fun_map f x :=\n  (Lhom.sum_inr : «expr →ᴸ » L (L'.sum L)).map_on_function f x\n#align fun_map_sum_inr fun_map_sum_inr\n\n",
 "fun_map_sum_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n@[simp]\ntheorem fun_map_sum_inl [(L.sum L').Structure M] [(Lhom.sum_inl : «expr →ᴸ » L (L.sum L')).is_expansion_on M] {n}\n    {f : L.functions n} {x : fin n → M} : @fun_map (L.sum L') M _ n (sum.inl f) x = fun_map f x :=\n  (Lhom.sum_inl : «expr →ᴸ » L (L.sum L')).map_on_function f x\n#align fun_map_sum_inl fun_map_sum_inl\n\n",
 "constants_on_map_is_expansion_on":
 "theorem constants_on_map_is_expansion_on {f : α → β} {fα : α → M} {fβ : β → M} (h : fβ ∘ f = fα) :\n    @Lhom.is_expansion_on _ _ (Lhom.constants_on_map f) M (constants_on.Structure fα) (constants_on.Structure fβ) :=\n  by\n  letI := constants_on.Structure fα\n  letI := constants_on.Structure fβ\n  exact\n    ⟨fun n => nat.cases_on n (fun F x => (congr_fun h F : _)) fun n F => is_empty_elim F, fun _ R => is_empty_elim R⟩\n#align constants_on_map_is_expansion_on constants_on_map_is_expansion_on\n\n",
 "constants_on_constants":
 "-- \\^L\ntheorem constants_on_constants : (constants_on α).constants = α :=\n  rfl\n#align constants_on_constants constants_on_constants\n\n",
 "comp_sum_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\ntheorem comp_sum_elim {L3 : language} (θ : «expr →ᴸ » L' L3) :\n    Lhom.comp θ (ϕ.sum_elim ψ) = (Lhom.comp θ ϕ).sum_elim (Lhom.comp θ ψ) :=\n  Lhom.funext (funext fun n => sum.comp_elim _ _ _) (funext fun n => sum.comp_elim _ _ _)\n#align comp_sum_elim comp_sum_elim\n\n",
 "comp_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n@[simp]\ntheorem comp_id (F : «expr →ᴸ » L L') : Lhom.comp F (Lhom.id L) = F :=\n  by\n  cases F\n  rfl\n#align comp_id comp_id\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᴸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Lhom.comp -/\ntheorem comp_assoc {L3 : language} (F : «expr →ᴸ » L'' L3) (G : «expr →ᴸ » L' L'') (H : «expr →ᴸ » L L') :\n    Lhom.comp (Lhom.comp F G) H = Lhom.comp F (Lhom.comp G H) :=\n  rfl\n#align comp_assoc comp_assoc\n\n",
 "coe_con":
 "@[simp]\ntheorem coe_con {a : A} : (L.con a : M) = a :=\n  rfl\n#align coe_con coe_con\n\n",
 "card_with_constants":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `language.with_constants -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n@[simp]\ntheorem card_with_constants :\n    (language.with_constants L α).card = cardinal.lift.{w'} L.card + cardinal.lift.{max u v} (cardinal.mk α) := by\n  rw [with_constants, card_sum, card_constants_on]\n#align card_with_constants card_with_constants\n\n",
 "card_constants_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem card_constants_on : (constants_on α).card = cardinal.mk α := by simp\n#align card_constants_on card_constants_on\n\n",
 "Lhom_with_constants_injective":
 "theorem Lhom_with_constants_injective : (L.Lhom_with_constants α).injective :=\n  Lhom.sum_inl_injective\n#align Lhom_with_constants_injective Lhom_with_constants_injective\n\n"}