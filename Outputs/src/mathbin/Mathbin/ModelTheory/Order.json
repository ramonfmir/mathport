{"rel_map_le_symb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem rel_map_le_symb [LE M] [L.ordered_structure M] {a b : M} :\n    RelMap (le_symb : L.relations 2)\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") ↔\n      a ≤ b :=\n  by\n  rw [← order_Lhom_le_symb, Lhom.map_on_relation]\n  rfl\n#align rel_map_le_symb rel_map_le_symb\n\n",
 "realize_no_top_order_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_no_top_order_iff : Theory.model M Language.order.no_top_order_sentence ↔ NoTopOrder M :=\n  by\n  simp only [no_top_order_sentence, sentence.realize, formula.realize, bounded_formula.realize_all,\n    bounded_formula.realize_ex, bounded_formula.realize_not, realize, term.realize_le, Sum.elim_inr]\n  refine' ⟨fun h => ⟨fun a => h a⟩, _⟩\n  intro h a\n  exact exists_not_le a\n#align realize_no_top_order_iff realize_no_top_order_iff\n\n",
 "realize_no_top_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem realize_no_top_order [h : NoTopOrder M] : Theory.model M Language.order.no_top_order_sentence :=\n  realize_noTopOrder_iff.2 h\n#align realize_no_top_order realize_no_top_order\n\n",
 "realize_no_bot_order_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_no_bot_order_iff : Theory.model M Language.order.no_bot_order_sentence ↔ NoBotOrder M :=\n  by\n  simp only [no_bot_order_sentence, sentence.realize, formula.realize, bounded_formula.realize_all,\n    bounded_formula.realize_ex, bounded_formula.realize_not, realize, term.realize_le, Sum.elim_inr]\n  refine' ⟨fun h => ⟨fun a => h a⟩, _⟩\n  intro h a\n  exact exists_not_ge a\n#align realize_no_bot_order_iff realize_no_bot_order_iff\n\n",
 "realize_no_bot_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem realize_no_bot_order [h : NoBotOrder M] : Theory.model M Language.order.no_bot_order_sentence :=\n  realize_noBotOrder_iff.2 h\n#align realize_no_bot_order realize_no_bot_order\n\n",
 "realize_lt":
 "@[simp]\ntheorem term.realize_lt [preorder M] [L.ordered_structure M] {t₁ t₂ : L.term (Sum α (Fin n))} {v : α → M}\n    {xs : Fin n → M} : (t₁.lt t₂).realize v xs ↔ t₁.realize (Sum.elim v xs) < t₂.realize (Sum.elim v xs) := by\n  simp [term.lt, lt_iff_le_not_le]\n#align term.realize_lt term.realize_lt\n\n",
 "realize_le":
 "@[simp]\ntheorem term.realize_le [LE M] [L.ordered_structure M] {t₁ t₂ : L.term (Sum α (Fin n))} {v : α → M} {xs : Fin n → M} :\n    (t₁.le t₂).realize v xs ↔ t₁.realize (Sum.elim v xs) ≤ t₂.realize (Sum.elim v xs) := by simp [term.le]\n#align term.realize_le term.realize_le\n\n",
 "realize_densely_ordered_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_densely_ordered_iff [preorder M] :\n    Theory.model M Language.order.densely_ordered_sentence ↔ DenselyOrdered M :=\n  by\n  simp only [densely_ordered_sentence, sentence.realize, formula.realize, bounded_formula.realize_imp,\n    bounded_formula.realize_all, realize, term.realize_lt, Sum.elim_inr, bounded_formula.realize_ex,\n    bounded_formula.realize_inf]\n  refine' ⟨fun h => ⟨fun a b ab => h a b ab⟩, _⟩\n  intro h a b ab\n  exact exists_between ab\n#align realize_densely_ordered_iff realize_densely_ordered_iff\n\n",
 "realize_densely_ordered":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem realize_densely_ordered [preorder M] [h : DenselyOrdered M] :\n    Theory.model M Language.order.densely_ordered_sentence :=\n  realize_denselyOrdered_iff.2 h\n#align realize_densely_ordered realize_densely_ordered\n\n",
 "ordered_structure_iff":
 "@[simp]\ntheorem ordered_structure_iff [IsOrdered L] [LE M] [L.Structure M] :\n    L.ordered_structure M ↔ LHom.IsExpansionOn (orderLHom L) M :=\n  iff.rfl\n#align ordered_structure_iff ordered_structure_iff\n\n",
 "order_Lhom_order":
 "@[simp]\ntheorem order_Lhom_order : orderLHom Language.order = LHom.id Language.order :=\n  LHom.funext (subsingleton.elim _ _) (subsingleton.elim _ _)\n#align order_Lhom_order order_Lhom_order\n\n",
 "order_Lhom_le_symb":
 "/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem order_Lhom_le_symb [L.is_ordered] : (orderLHom L).on_relation le_symb = (le_symb : L.relations 2) :=\n  rfl\n#align order_Lhom_le_symb order_Lhom_le_symb\n\n"}