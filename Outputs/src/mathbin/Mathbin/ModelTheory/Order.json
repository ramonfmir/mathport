{"rel_map_le_symb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem rel_map_le_symb [LE M] [L.is_ordered_structure M] {a b : M} :\n    rel_map (le_symb : L.relations 2)\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") ↔\n      a ≤ b :=\n  by\n  rw [← order_Lhom_le_symb, Lhom.map_on_relation]\n  rfl\n#align rel_map_le_symb rel_map_le_symb\n\n",
 "realize_no_top_order_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_no_top_order_iff : Theory.model M sentence.no_top_order ↔ NoTopOrder M :=\n  by\n  simp only [sentence.no_top_order, sentence.realize, formula.realize, bounded_formula.realize_all,\n    bounded_formula.realize_ex, bounded_formula.realize_not, realize, term.realize_le, sum.elim_inr]\n  refine' ⟨fun h => ⟨fun a => h a⟩, _⟩\n  intro h a\n  exact exists_not_le a\n#align realize_no_top_order_iff realize_no_top_order_iff\n\n",
 "realize_no_top_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem realize_no_top_order [h : NoTopOrder M] : Theory.model M sentence.no_top_order :=\n  realize_no_top_order_iff.2 h\n#align realize_no_top_order realize_no_top_order\n\n",
 "realize_no_bot_order_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_no_bot_order_iff : Theory.model M sentence.no_bot_order ↔ NoBotOrder M :=\n  by\n  simp only [sentence.no_bot_order, sentence.realize, formula.realize, bounded_formula.realize_all,\n    bounded_formula.realize_ex, bounded_formula.realize_not, realize, term.realize_le, sum.elim_inr]\n  refine' ⟨fun h => ⟨fun a => h a⟩, _⟩\n  intro h a\n  exact exists_not_ge a\n#align realize_no_bot_order_iff realize_no_bot_order_iff\n\n",
 "realize_no_bot_order":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem realize_no_bot_order [h : NoBotOrder M] : Theory.model M sentence.no_bot_order :=\n  realize_no_bot_order_iff.2 h\n#align realize_no_bot_order realize_no_bot_order\n\n",
 "realize_lt":
 "@[simp]\ntheorem term.realize_lt [preorder M] [L.is_ordered_structure M] {t₁ t₂ : L.term (Sum α (fin n))} {v : α → M}\n    {xs : fin n → M} : (t₁.lt t₂).realize v xs ↔ t₁.realize (sum.elim v xs) < t₂.realize (sum.elim v xs) := by\n  simp [term.lt, lt_iff_le_not_le]\n#align term.realize_lt term.realize_lt\n\n",
 "realize_le":
 "@[simp]\ntheorem term.realize_le [LE M] [L.is_ordered_structure M] {t₁ t₂ : L.term (Sum α (fin n))} {v : α → M}\n    {xs : fin n → M} : (t₁.le t₂).realize v xs ↔ t₁.realize (sum.elim v xs) ≤ t₂.realize (sum.elim v xs) := by\n  simp [term.le]\n#align term.realize_le term.realize_le\n\n",
 "realize_densely_ordered_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\ntheorem realize_densely_ordered_iff [preorder M] : Theory.model M sentence.densely_ordered ↔ DenselyOrdered M :=\n  by\n  simp only [sentence.densely_ordered, sentence.realize, formula.realize, bounded_formula.realize_imp,\n    bounded_formula.realize_all, realize, term.realize_lt, sum.elim_inr, bounded_formula.realize_ex,\n    bounded_formula.realize_inf]\n  refine' ⟨fun h => ⟨fun a b ab => h a b ab⟩, _⟩\n  intro h a b ab\n  exact exists_between ab\n#align realize_densely_ordered_iff realize_densely_ordered_iff\n\n",
 "realize_densely_ordered":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n@[simp]\ntheorem realize_densely_ordered [preorder M] [h : DenselyOrdered M] : Theory.model M sentence.densely_ordered :=\n  realize_densely_ordered_iff.2 h\n#align realize_densely_ordered realize_densely_ordered\n\n",
 "order_Lhom_order":
 "@[simp]\ntheorem order_Lhom_order : order_Lhom language.order = Lhom.id language.order :=\n  Lhom.funext (subsingleton.elim _ _) (subsingleton.elim _ _)\n#align order_Lhom_order order_Lhom_order\n\n",
 "order_Lhom_le_symb":
 "/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n@[simp]\ntheorem order_Lhom_le_symb [L.is_ordered] : (order_Lhom L).on_relation le_symb = (le_symb : L.relations 2) :=\n  rfl\n#align order_Lhom_le_symb order_Lhom_le_symb\n\n",
 "is_ordered_structure_iff":
 "@[simp]\ntheorem is_ordered_structure_iff [is_ordered L] [LE M] [L.Structure M] :\n    L.is_ordered_structure M ↔ Lhom.is_expansion_on (order_Lhom L) M :=\n  iff.rfl\n#align is_ordered_structure_iff is_ordered_structure_iff\n\n"}