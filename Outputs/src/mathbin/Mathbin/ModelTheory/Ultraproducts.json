{"term_realize_cast":
 "theorem term_realize_cast {β : Type _} (x : β → ∀ a, M a) (t : L.term β) :\n    (t.realize fun i => (x i : (u : filter α).product M)) = fun a => t.realize fun i => x i a :=\n  by\n  convert @term.realize_quotient_mk L _ ((u : filter α).product_setoid M) (ultraproduct.setoid_prestructure M u) _ t x\n  ext a\n  induction t\n  · rfl\n  · simp only [term.realize, t_ih]\n    rfl\n#align term_realize_cast term_realize_cast\n\n",
 "sentence_realize":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Theory.model -/\n/-- Łoś's Theorem : A sentence is true in an ultraproduct if and only if the set of structures it is\n  true in is in the ultrafilter. -/\ntheorem sentence_realize (φ : L.sentence) :\n    Theory.model ((u : filter α).product M) φ ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" u\n        (Theory.model (M a) φ) :=\n  by\n  simp_rw [sentence.realize, ← realize_formula_cast φ, iff_eq_eq]\n  exact congr rfl (subsingleton.elim _ _)\n#align sentence_realize sentence_realize\n\n",
 "realize_formula_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem realize_formula_cast {β : Type _} (φ : L.formula β) (x : β → ∀ a, M a) :\n    (φ.realize fun i => (x i : (u : filter α).product M)) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" u\n        (φ.realize fun i => x i a) :=\n  by\n  simp_rw [formula.realize, ← bounded_formula_realize_cast φ x, iff_eq_eq]\n  exact congr rfl (subsingleton.elim _ _)\n#align realize_formula_cast realize_formula_cast\n\n",
 "fun_map_cast":
 "/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem fun_map_cast {n : ℕ} (f : L.functions n) (x : fin n → ∀ a, M a) :\n    (fun_map f fun i => (x i : (u : filter α).product M)) = fun a => fun_map f fun i => x i a := by\n  apply fun_map_quotient_mk\n#align fun_map_cast fun_map_cast\n\n",
 "bounded_formula_realize_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\ntheorem bounded_formula_realize_cast {β : Type _} {n : ℕ} (φ : L.bounded_formula β n) (x : β → ∀ a, M a)\n    (v : fin n → ∀ a, M a) :\n    (φ.realize (fun i : β => (x i : (u : filter α).product M)) fun i => v i) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" u\n        (φ.realize (fun i : β => x i a) fun i => v i a) :=\n  by\n  letI := (u : filter α).product_setoid M\n  induction' φ with _ _ _ _ _ _ _ _ m _ _ ih ih' k φ ih\n  · simp only [bounded_formula.realize, eventually_const]\n  · have h2 : ∀ a : α, (sum.elim (fun i : β => x i a) fun i => v i a) = fun i => sum.elim x v i a := fun a =>\n      funext fun i => sum.cases_on i (fun i => rfl) fun i => rfl\n    simp only [bounded_formula.realize, (sum.comp_elim coe x v).symm, h2, term_realize_cast]\n    exact quotient.eq'\n  · have h2 : ∀ a : α, (sum.elim (fun i : β => x i a) fun i => v i a) = fun i => sum.elim x v i a := fun a =>\n      funext fun i => sum.cases_on i (fun i => rfl) fun i => rfl\n    simp only [bounded_formula.realize, (sum.comp_elim coe x v).symm, term_realize_cast, h2]\n    exact rel_map_quotient_mk _ _\n  · simp only [bounded_formula.realize, ih v, ih' v]\n    rw [ultrafilter.eventually_imp]\n  · simp only [bounded_formula.realize]\n    trans\n      ∀ m : ∀ a : α, M a,\n        φ.realize (fun i : β => (x i : (u : filter α).product M)) (fin.snoc (coe ∘ v) (↑m : (u : filter α).product M))\n    · exact forall_quotient_iff\n    have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : fin (k + 1) => (fin.snoc v m : _ → ∀ a, M a) i a) = fin.snoc (fun i : fin k => v i a) (m a) :=\n      by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i hi => _)\n      · simp only [fin.snoc_last]\n      · simp only [fin.snoc_cast_succ]\n    simp only [← fin.comp_snoc, ih, h']\n    refine' ⟨fun h => _, fun h m => _⟩\n    · contrapose! h\n      simp_rw [← ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α => classical.epsilon fun m : M a => ¬φ.realize (fun i => x i a) (fin.snoc (fun i => v i a) m), _⟩\n      rw [← ultrafilter.eventually_not]\n      exact filter.mem_of_superset h fun a ha => classical.epsilon_spec ha\n    · rw [filter.eventually_iff] at *\n      exact filter.mem_of_superset h fun a ha => ha (m a)\n#align bounded_formula_realize_cast bounded_formula_realize_cast\n\n"}