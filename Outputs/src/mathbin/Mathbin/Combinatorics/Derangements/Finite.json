{"num_derangements_zero":
 "@[simp]\ntheorem num_derangements_zero : num_derangements 0 = 1 :=\n  rfl\n#align num_derangements_zero num_derangements_zero\n\n",
 "num_derangements_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem num_derangements_sum (n : ℕ) :\n    (num_derangements n : ℤ) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (n + 1)) ((-1 : ℤ) ^ k * nat.asc_factorial k (n - k)) :=\n  by\n  induction' n with n hn; · rfl\n  rw [finset.sum_range_succ, num_derangements_succ, hn, finset.mul_sum, tsub_self, nat.asc_factorial_zero,\n    Int.ofNat_one, mul_one, pow_succ, neg_one_mul, sub_eq_add_neg, add_left_inj, finset.sum_congr rfl]\n  -- show that (n + 1) * (-1)^x * asc_fac x (n - x) = (-1)^x * asc_fac x (n.succ - x)\n  intro x hx\n  have h_le : x ≤ n := finset.mem_range_succ_iff.mp hx\n  rw [nat.succ_sub h_le, nat.asc_factorial_succ, add_tsub_cancel_of_le h_le, Int.ofNat_mul, Int.ofNat_succ,\n    mul_left_comm]\n#align num_derangements_sum num_derangements_sum\n\n",
 "num_derangements_succ":
 "theorem num_derangements_succ (n : ℕ) :\n    (num_derangements (n + 1) : ℤ) = (n + 1) * (num_derangements n : ℤ) - (-1) ^ n :=\n  by\n  induction' n with n hn\n  · rfl\n  · simp only [num_derangements_add_two, hn, pow_succ, Int.ofNat_mul, Int.ofNat_add, Int.ofNat_succ]\n    ring\n#align num_derangements_succ num_derangements_succ\n\n",
 "num_derangements_one":
 "@[simp]\ntheorem num_derangements_one : num_derangements 1 = 0 :=\n  rfl\n#align num_derangements_one num_derangements_one\n\n",
 "num_derangements_add_two":
 "theorem num_derangements_add_two (n : ℕ) :\n    num_derangements (n + 2) = (n + 1) * (num_derangements n + num_derangements (n + 1)) :=\n  rfl\n#align num_derangements_add_two num_derangements_add_two\n\n",
 "card_derangements_invariant":
 "/-\nCopyright (c) 2021 Henry Swanson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Henry Swanson\n-/\ntheorem card_derangements_invariant {α β : Type _} [fintype α] [decidable_eq α] [fintype β] [decidable_eq β]\n    (h : card α = card β) : card (derangements α) = card (derangements β) :=\n  fintype.card_congr (equiv.derangements_congr <| equiv_of_card_eq h)\n#align card_derangements_invariant card_derangements_invariant\n\n",
 "card_derangements_fin_eq_num_derangements":
 "theorem card_derangements_fin_eq_num_derangements {n : ℕ} : card (derangements (fin n)) = num_derangements n :=\n  by\n  induction' n using nat.strong_induction_on with n hyp\n  obtain _ | _ | n := n; · rfl; · rfl\n  -- knock out cases 0 and 1\n  -- now we have n ≥ 2. rewrite everything in terms of card_derangements, so that we can use\n  -- `card_derangements_fin_add_two`\n  rw [num_derangements_add_two, card_derangements_fin_add_two, mul_add, hyp _ (nat.lt_add_of_pos_right zero_lt_two),\n    hyp _ (lt_add_one _)]\n#align card_derangements_fin_eq_num_derangements card_derangements_fin_eq_num_derangements\n\n",
 "card_derangements_fin_add_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem card_derangements_fin_add_two (n : ℕ) :\n    card (derangements (fin (n + 2))) =\n      (n + 1) * card (derangements (fin n)) + (n + 1) * card (derangements (fin (n + 1))) :=\n  by\n  -- get some basic results about the size of fin (n+1) plus or minus an element\n  have h1 : ∀ a : fin (n + 1), card («expr ᶜ» {a} : set (fin (n + 1))) = card (fin n) :=\n    by\n    intro a\n    simp only [fintype.card_fin, finset.card_fin, fintype.card_of_finset, Finset.filter_ne' _ a,\n      Set.mem_compl_singleton_iff, finset.card_erase_of_mem (finset.mem_univ a), add_tsub_cancel_right]\n  have h2 : card (fin (n + 2)) = card (option (fin (n + 1))) := by simp only [card_fin, card_option]\n  -- rewrite the LHS and substitute in our fintype-level equivalence\n  simp only [card_derangements_invariant h2,\n    card_congr\n      (@derangements_recursion_equiv (fin (n + 1))\n        _),-- push the cardinality through the Σ and ⊕ so that we can use `card_n`\n    card_sigma,\n    card_sum, card_derangements_invariant (h1 _), finset.sum_const, nsmul_eq_mul, finset.card_fin, mul_add, nat.cast_id]\n#align card_derangements_fin_add_two card_derangements_fin_add_two\n\n",
 "card_derangements_eq_num_derangements":
 "theorem card_derangements_eq_num_derangements (α : Type _) [fintype α] [decidable_eq α] :\n    card (derangements α) = num_derangements (card α) :=\n  by\n  rw [← card_derangements_invariant (card_fin _)]\n  exact card_derangements_fin_eq_num_derangements\n#align card_derangements_eq_num_derangements card_derangements_eq_num_derangements\n\n"}