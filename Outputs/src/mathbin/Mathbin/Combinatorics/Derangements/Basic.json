{"mem_fiber":
 "theorem remove_none.mem_fiber (a : Option α) (f : Perm α) :\n    f ∈ RemoveNone.fiber a ↔ ∃ F : Perm (Option α), F ∈ derangements (Option α) ∧ F none = a ∧ removeNone F = f := by\n  simp [remove_none.fiber, derangements]\n#align remove_none.mem_fiber remove_none.mem_fiber\n\n",
 "mem_derangements_iff_fixedPoints_eq_empty":
 "#print mem_derangements_iff_fixedPoints_eq_empty /-\n/-\nCopyright (c) 2021 Henry Swanson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Henry Swanson\n-/\ntheorem mem_derangements_iff_fixedPoints_eq_empty {f : Perm α} : f ∈ derangements α ↔ fixedPoints f = ∅ :=\n  Set.eq_empty_iff_forall_not_mem.symm\n#align mem_derangements_iff_fixed_points_eq_empty mem_derangements_iff_fixedPoints_eq_empty\n-/\n\n",
 "fiber_some":
 "/-- For any `a : α`, the fiber over `some a` is the set of permutations\n    where `a` is the only possible fixed point. -/\ntheorem remove_none.fiber_some (a : α) : RemoveNone.fiber (some a) = { f : Perm α | fixedPoints f ⊆ {a} } :=\n  by\n  ext f\n  constructor\n  · rw [remove_none.mem_fiber]\n    rintro ⟨F, F_derangement, F_none, rfl⟩ x x_fixed\n    rw [mem_fixed_points_iff] at x_fixed\n    apply_fun some  at x_fixed\n    cases' Fx : F (some x) with y\n    · rwa [remove_none_none F Fx, F_none, Option.some_inj, eq_comm] at x_fixed\n    · exfalso\n      rw [remove_none_some F ⟨y, Fx⟩] at x_fixed\n      exact F_derangement _ x_fixed\n  · intro h_opfp\n    use equiv.perm.decompose_option.symm (some a, f)\n    constructor\n    · intro x\n      apply_fun swap none (some a)\n      simp only [perm.decompose_option_symm_apply, swap_apply_self, perm.coe_mul]\n      cases x\n      · simp\n      simp only [Equiv.optionCongr_apply, Option.map_some']\n      by_cases x_vs_a : x = a\n      · rw [x_vs_a, swap_apply_right]\n        apply Option.some_ne_none\n      have ne_1 : some x ≠ none := Option.some_ne_none _\n      have ne_2 : some x ≠ some a := (Option.some_injective α).ne_iff.mpr x_vs_a\n      rw [swap_apply_of_ne_of_ne ne_1 ne_2, (Option.some_injective α).ne_iff]\n      intro contra\n      exact x_vs_a (h_opfp contra)\n    · rw [apply_symm_apply]\n#align remove_none.fiber_some remove_none.fiber_some\n\n",
 "fiber_none":
 "theorem remove_none.fiber_none : RemoveNone.fiber (@none α) = ∅ :=\n  by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro f hyp\n  rw [remove_none.mem_fiber] at hyp\n  rcases hyp with ⟨F, F_derangement, F_none, _⟩\n  exact F_derangement none F_none\n#align remove_none.fiber_none remove_none.fiber_none\n\n"}