{"singleton":
 "@[to_additive]\ntheorem FP.singleton {M} [Semigroup M] (a : Stream' M) (i : ℕ) : a.nth i ∈ FP a :=\n  by\n  induction' i with i ih generalizing a\n  · apply FP.head\n  · apply FP.tail\n    apply ih\n#align FP.singleton FP.singleton\n\n",
 "mul_two":
 "@[to_additive]\ntheorem FP.mul_two {M} [Semigroup M] (a : Stream' M) (i j : ℕ) (ij : i < j) : a.nth i * a.nth j ∈ FP a :=\n  by\n  refine' FP_drop_subset_FP _ i _\n  rw [← Stream'.head_drop]\n  apply FP.cons\n  rcases le_iff_exists_add.mp (nat.succ_le_of_lt ij) with ⟨d, hd⟩\n  have := FP.singleton (a.drop i).tail d\n  rw [Stream'.tail_eq_drop, Stream'.nth_drop, Stream'.nth_drop] at this\n  convert this\n  rw [hd, add_comm, nat.succ_add, nat.add_succ]\n#align FP.mul_two FP.mul_two\n\n",
 "mul":
 "/-- If `m` and `m'` are finite products in `M`, then so is `m * m'`, provided that `m'` is obtained\nfrom a subsequence of `M` starting sufficiently late. -/\n@[to_additive\n      \"If `m` and `m'` are finite sums in `M`, then so is `m + m'`, provided that `m'`\\nis obtained from a subsequence of `M` starting sufficiently late.\"]\ntheorem FP.mul {M} [Semigroup M] {a : Stream' M} {m : M} (hm : m ∈ FP a) : ∃ n, ∀ m' ∈ FP (a.drop n), m * m' ∈ FP a :=\n  by\n  induction' hm with a a m hm ih a m hm ih\n  · exact ⟨1, fun m hm => FP.cons a m hm⟩\n  · cases' ih with n hn\n    use n + 1\n    intro m' hm'\n    exact FP.tail _ _ (hn _ hm')\n  · cases' ih with n hn\n    use n + 1\n    intro m' hm'\n    rw [mul_assoc]\n    exact FP.cons _ _ (hn _ hm')\n#align FP.mul FP.mul\n\n",
 "finset_prod":
 "@[to_additive]\ntheorem FP.finset_prod {M} [CommMonoid M] (a : Stream' M) (s : Finset ℕ) (hs : s.nonempty) :\n    (s.prod fun i => a.nth i) ∈ FP a :=\n  by\n  refine' FP_drop_subset_FP _ (s.min' hs) _\n  induction' s using Finset.strongInduction with s ih\n  rw [← Finset.mul_prod_erase _ _ (s.min'_mem hs), ← Stream'.head_drop]\n  cases' (s.erase (s.min' hs)).eq_empty_or_nonempty with h h\n  · rw [h, Finset.prod_empty, mul_one]\n    exact FP.head _\n  · apply FP.cons\n    rw [Stream'.tail_eq_drop, Stream'.drop_drop, add_comm]\n    refine' Set.mem_of_subset_of_mem _ (ih _ (Finset.erase_ssubset <| s.min'_mem hs) h)\n    have : s.min' hs + 1 ≤ (s.erase (s.min' hs)).min' h :=\n      nat.succ_le_of_lt (Finset.min'_lt_of_mem_erase_min' _ _ <| Finset.min'_mem _ _)\n    cases' le_iff_exists_add.mp this with d hd\n    rw [hd, add_comm, ← Stream'.drop_drop]\n    apply FP_drop_subset_FP\n#align FP.finset_prod FP.finset_prod\n\n",
 "exists_idempotent_ultrafilter_le_FP":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[to_additive exists_idempotent_ultrafilter_le_FS]\ntheorem exists_idempotent_ultrafilter_le_FP {M} [Semigroup M] (a : Stream' M) :\n    ∃ U : Ultrafilter M,\n      U * U = U ∧\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" U\n          (m ∈ FP a) :=\n  by\n  let S : Set (Ultrafilter M) :=\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n      { U |\n        «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" U\n          (m ∈ FP (a.drop n)) }\n  obtain ⟨U, hU, U_idem⟩ := exists_idempotent_in_compact_subsemigroup _ S _ _ _\n  · refine' ⟨U, U_idem, _⟩\n    convert set.mem_Inter.mp hU 0\n  · exact Ultrafilter.continuous_mul_left\n  · apply IsCompact.nonempty_interᵢ_of_sequence_nonempty_compact_closed\n    · intro n U hU\n      apply eventually.mono hU\n      rw [add_comm, ← Stream'.drop_drop, ← Stream'.tail_eq_drop]\n      exact FP.tail _\n    · intro n\n      exact ⟨pure _, mem_pure.mpr <| FP.head _⟩\n    · exact (ultrafilter_isClosed_basic _).is_compact\n    · intro n\n      apply ultrafilter_isClosed_basic\n  · exact IsClosed.isCompact (isClosed_interᵢ fun i => ultrafilter_isClosed_basic _)\n  · intro U hU V hV\n    rw [Set.mem_interᵢ] at *\n    intro n\n    rw [Set.mem_setOf_eq, Ultrafilter.eventually_mul]\n    apply eventually.mono (hU n)\n    intro m hm\n    obtain ⟨n', hn⟩ := FP.mul hm\n    apply eventually.mono (hV (n' + n))\n    intro m' hm'\n    apply hn\n    simpa only [Stream'.drop_drop] using hm'\n#align exists_idempotent_ultrafilter_le_FP exists_idempotent_ultrafilter_le_FP\n\n",
 "exists_FP_of_large":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n@[to_additive exists_FS_of_large]\ntheorem exists_FP_of_large {M} [Semigroup M] (U : Ultrafilter M) (U_idem : U * U = U) (s₀ : Set M) (sU : s₀ ∈ U) :\n    ∃ a, FP a ⊆ s₀ :=\n  by\n  /- Informally: given a `U`-large set `s₀`, the set `s₀ ∩ { m | ∀ᶠ m' in U, m * m' ∈ s₀ }` is also\n  `U`-large (since `U` is idempotent). Thus in particular there is an `a₀` in this intersection. Now\n  let `s₁` be the intersection `s₀ ∩ { m | a₀ * m ∈ s₀ }`. By choice of `a₀`, this is again `U`-large,\n  so we can repeat the argument starting from `s₁`, obtaining `a₁`, `s₂`, etc. This gives the desired\n  infinite sequence. -/\n  have exists_elem :\n    ∀ {s : Set M} (hs : s ∈ U),\n      (s ∩\n          { m |\n            «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" U\n              (m * m' ∈ s) }).nonempty :=\n    fun s hs =>\n    Ultrafilter.nonempty_of_mem\n      (inter_mem hs <| by\n        rw [← U_idem] at hs\n        exact hs)\n  let elem : { s // s ∈ U } → M := fun p => (exists_elem p.property).some\n  let succ : { s // s ∈ U } → { s // s ∈ U } := fun p =>\n    ⟨p.val ∩ { m | elem p * m ∈ p.val },\n      inter_mem p.2 <| show _ from Set.inter_subset_right _ _ (exists_elem p.2).some_mem⟩\n  use Stream'.corec elem succ (subtype.mk s₀ sU)\n  suffices ∀ (a : Stream' M), ∀ m ∈ FP a, ∀ p, a = Stream'.corec elem succ p → m ∈ p.val\n    by\n    intro m hm\n    exact this _ m hm ⟨s₀, sU⟩ rfl\n  clear sU s₀\n  intro a m h\n  induction' h with b b n h ih b n h ih\n  · rintro p rfl\n    rw [Stream'.corec_eq, Stream'.head_cons]\n    exact Set.inter_subset_left _ _ (Set.Nonempty.some_mem _)\n  · rintro p rfl\n    refine' Set.inter_subset_left _ _ (ih (succ p) _)\n    rw [Stream'.corec_eq, Stream'.tail_cons]\n  · rintro p rfl\n    have := Set.inter_subset_right _ _ (ih (succ p) _)\n    · simpa only using this\n    rw [Stream'.corec_eq, Stream'.tail_cons]\n#align exists_FP_of_large exists_FP_of_large\n\n",
 "exists_FP_of_finite_cover":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The weak form of **Hindman's theorem**: in any finite cover of a nonempty semigroup, one of the\nparts contains an FP-set. -/\n@[to_additive exists_FS_of_finite_cover\n      \"The weak form of **Hindman's theorem**: in any finite cover\\nof a nonempty additive semigroup, one of the parts contains an FS-set.\"]\ntheorem exists_FP_of_finite_cover {M} [Semigroup M] [Nonempty M] (s : Set (Set M)) (sfin : s.finite)\n    (scov : «expr⊤» ⊆ ⋃₀ s) : ∃ c ∈ s, ∃ a : Stream' M, FP a ⊆ c :=\n  let ⟨U, hU⟩ := exists_idempotent_of_compact_t2_of_continuous_mul_left (@Ultrafilter.continuous_mul_left M _)\n  let ⟨c, c_s, hc⟩ := (Ultrafilter.finite_unionₛ_mem_iff sfin).mp (mem_of_superset univ_mem scov)\n  ⟨c, c_s, exists_FP_of_large U hU c hc⟩\n#align exists_FP_of_finite_cover exists_FP_of_finite_cover\n\n",
 "eventually_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print Ultrafilter.eventually_mul /-\n/-\nCopyright (c) 2021 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn\n-/\n/- We could have taken this as the definition of `U * V`, but then we would have to prove that it\ndefines an ultrafilter. -/\n@[to_additive]\ntheorem Ultrafilter.eventually_mul {M} [Mul M] (U V : Ultrafilter M) (p : M → Prop) :\n    «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" (↑(U * V))\n        (p m) ↔\n      «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" U\n        («expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" V\n          (p (m * m'))) :=\n  iff.rfl\n#align ultrafilter.eventually_mul Ultrafilter.eventually_mul\n#align ultrafilter.eventually_add Ultrafilter.eventually_add\n-/\n\n",
 "continuous_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᶠ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , » -/\n#print Ultrafilter.continuous_mul_left /-\n-- We don't prove `continuous_mul_right`, because in general it is false!\n@[to_additive]\ntheorem Ultrafilter.continuous_mul_left {M} [Semigroup M] (V : Ultrafilter M) : Continuous (· * V) :=\n  TopologicalSpace.IsTopologicalBasis.continuous ultrafilterBasis_is_basis _ <|\n    Set.forall_range_iff.mpr fun s =>\n      ultrafilter_isOpen_basic\n        { m : M |\n          «expr∀ᶠ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᶠ in , »\" V\n            (m * m' ∈ s) }\n#align ultrafilter.continuous_mul_left Ultrafilter.continuous_mul_left\n#align ultrafilter.continuous_add_left Ultrafilter.continuous_add_left\n-/\n\n",
 "FP_partition_regular":
 "/-- The strong form of **Hindman's theorem**: in any finite cover of an FP-set, one the parts\ncontains an FP-set. -/\n@[to_additive FS_partition_regular\n      \"The strong form of **Hindman's theorem**: in any finite cover of\\nan FS-set, one the parts contains an FS-set.\"]\ntheorem FP_partition_regular {M} [Semigroup M] (a : Stream' M) (s : Set (Set M)) (sfin : s.finite)\n    (scov : FP a ⊆ ⋃₀ s) : ∃ c ∈ s, ∃ b : Stream' M, FP b ⊆ c :=\n  let ⟨U, idem, aU⟩ := exists_idempotent_ultrafilter_le_FP a\n  let ⟨c, cs, hc⟩ := (Ultrafilter.finite_unionₛ_mem_iff sfin).mp (mem_of_superset aU scov)\n  ⟨c, cs, exists_FP_of_large U idem c hc⟩\n#align FP_partition_regular FP_partition_regular\n\n",
 "FP_drop_subset_FP":
 "@[to_additive FS_iter_tail_sub_FS]\ntheorem FP_drop_subset_FP {M} [Semigroup M] (a : Stream' M) (n : ℕ) : FP (a.drop n) ⊆ FP a :=\n  by\n  induction' n with n ih; · rfl\n  rw [Nat.succ_eq_one_add, ← Stream'.drop_drop]\n  exact trans (FP.tail _) ih\n#align FP_drop_subset_FP FP_drop_subset_FP\n\n"}