{"up_shadow_monotone":
 "/-- The upper shadow is monotone. -/\n@[mono]\ntheorem up_shadow_monotone : Monotone (upShadow : Finset (Finset Î±) â†’ Finset (Finset Î±)) := fun ğ’œ â„¬ => sup_mono\n#align up_shadow_monotone up_shadow_monotone\n\n",
 "up_shadow_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n@[simp]\ntheorem up_shadow_image_compl : ((finset.up_shadow) ğ’œ).image compl = (finset.shadow) (ğ’œ.image compl) :=\n  by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_up_shadow_iff]\n  constructor\n  Â· rintro âŸ¨_, âŸ¨s, hs, a, ha, rflâŸ©, rflâŸ©\n    exact âŸ¨Â«expr á¶œÂ» s, âŸ¨s, hs, rflâŸ©, a, mem_compl.2 ha, compl_insert.symmâŸ©\n  Â· rintro âŸ¨_, âŸ¨s, hs, rflâŸ©, a, ha, rflâŸ©\n    exact âŸ¨insert a s, âŸ¨s, hs, a, mem_compl.1 ha, rflâŸ©, compl_insertâŸ©\n#align up_shadow_image_compl up_shadow_image_compl\n\n",
 "up_shadow_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- The upper shadow of the empty set is empty. -/\n@[simp]\ntheorem up_shadow_empty : (finset.up_shadow) (âˆ… : Finset (Finset Î±)) = âˆ… :=\n  rfl\n#align up_shadow_empty up_shadow_empty\n\n",
 "up_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- The upper shadow of a family of `r`-sets is a family of `r + 1`-sets. -/\nprotected theorem _root_.set.sized.up_shadow (hğ’œ : (ğ’œ : Set (Finset Î±)).sized r) :\n    ((finset.up_shadow) ğ’œ : Set (Finset Î±)).sized (r + 1) :=\n  by\n  intro A h\n  obtain âŸ¨A, hA, i, hi, rflâŸ© := mem_up_shadow_iff.1 h\n  rw [card_insert_of_not_mem hi, hğ’œ hA]\n#align set.sized.up_shadow set.sized.up_shadow\n\n",
 "sized_shadow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\ntheorem sized_shadow_iff (h : âˆ… âˆ‰ ğ’œ) :\n    ((finset.shadow) ğ’œ : Set (Finset Î±)).sized r â†” (ğ’œ : Set (Finset Î±)).sized (r + 1) :=\n  by\n  refine' âŸ¨fun hğ’œ s hs => _, set.sized.shadowâŸ©\n  obtain âŸ¨a, haâŸ© := nonempty_iff_ne_empty.2 (ne_of_mem_of_not_mem hs h)\n  rw [â† hğ’œ (erase_mem_shadow hs ha), card_erase_add_one ha]\n#align sized_shadow_iff sized_shadow_iff\n\n",
 "shadow_singleton_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n@[simp]\ntheorem shadow_singleton_empty : (finset.shadow) ({âˆ…} : Finset (Finset Î±)) = âˆ… :=\n  rfl\n#align shadow_singleton_empty shadow_singleton_empty\n\n",
 "shadow_monotone":
 "--TODO: Prove `âˆ‚ {{a}} = {âˆ…}` quickly using `covers` and `grade_order`\n/-- The shadow is monotone. -/\n@[mono]\ntheorem shadow_monotone : Monotone (shadow : Finset (Finset Î±) â†’ Finset (Finset Î±)) := fun ğ’œ â„¬ => sup_mono\n#align shadow_monotone shadow_monotone\n\n",
 "shadow_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n@[simp]\ntheorem shadow_image_compl : ((finset.shadow) ğ’œ).image compl = (finset.up_shadow) (ğ’œ.image compl) :=\n  by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_up_shadow_iff]\n  constructor\n  Â· rintro âŸ¨_, âŸ¨s, hs, a, ha, rflâŸ©, rflâŸ©\n    exact âŸ¨Â«expr á¶œÂ» s, âŸ¨s, hs, rflâŸ©, a, not_mem_compl.2 ha, compl_erase.symmâŸ©\n  Â· rintro âŸ¨_, âŸ¨s, hs, rflâŸ©, a, ha, rflâŸ©\n    exact âŸ¨s.erase a, âŸ¨s, hs, a, not_mem_compl.1 ha, rflâŸ©, compl_eraseâŸ©\n#align shadow_image_compl shadow_image_compl\n\n",
 "shadow_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-\nCopyright (c) 2021 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Alena Gusakov, YaÃ«l Dillies\n-/\n/-- The shadow of the empty set is empty. -/\n@[simp]\ntheorem shadow_empty : (finset.shadow) (âˆ… : Finset (Finset Î±)) = âˆ… :=\n  rfl\n#align shadow_empty shadow_empty\n\n",
 "shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- The shadow of a family of `r`-sets is a family of `r - 1`-sets. -/\nprotected theorem _root_.set.sized.shadow (hğ’œ : (ğ’œ : Set (Finset Î±)).sized r) :\n    ((finset.shadow) ğ’œ : Set (Finset Î±)).sized (r - 1) :=\n  by\n  intro A h\n  obtain âŸ¨A, hA, i, hi, rflâŸ© := mem_shadow_iff.1 h\n  rw [card_erase_of_mem hi, hğ’œ hA]\n#align set.sized.shadow set.sized.shadow\n\n",
 "mem_up_shadow_iff_exists_mem_card_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- `s âˆˆ âˆ‚âº ğ’œ` iff `s` is exactly one element less than something from `ğ’œ`. -/\ntheorem mem_up_shadow_iff_exists_mem_card_add_one : s âˆˆ (finset.up_shadow) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, t âŠ† s âˆ§ t.card + 1 = s.card :=\n  by\n  refine' mem_up_shadow_iff_erase_mem.trans âŸ¨_, _âŸ©\n  Â· rintro âŸ¨a, ha, hsâŸ©\n    exact âŸ¨s.erase a, hs, erase_subset _ _, card_erase_add_one haâŸ©\n  Â· rintro âŸ¨t, ht, hts, hâŸ©\n    obtain âŸ¨a, haâŸ© : âˆƒ a, s \\ t = {a} := card_eq_one.1 (by rw [card_sdiff hts, â† h, add_tsub_cancel_left])\n    refine' âŸ¨a, sdiff_subset _ _ ((ha.ge : _ âŠ† _) <| mem_singleton_self a), _âŸ©\n    rwa [â† sdiff_singleton_eq_erase, â† ha, sdiff_sdiff_eq_self hts]\n#align mem_up_shadow_iff_exists_mem_card_add_one mem_up_shadow_iff_exists_mem_card_add_one\n\n",
 "mem_up_shadow_iff_exists_mem_card_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements more than something in `ğ’œ`. -/\ntheorem mem_up_shadow_iff_exists_mem_card_add :\n    s âˆˆ (Â«expr ^[ ]Â» (finset.up_shadow) k) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, t âŠ† s âˆ§ t.card + k = s.card :=\n  by\n  induction' k with k ih generalizing ğ’œ s\n  Â· refine' âŸ¨fun hs => âŸ¨s, hs, subset.refl _, rflâŸ©, _âŸ©\n    rintro âŸ¨t, ht, hst, hcardâŸ©\n    rwa [â† eq_of_subset_of_card_le hst hcard.ge]\n  simp only [exists_prop, Function.comp_apply, Function.iterate_succ]\n  refine' ih.trans _\n  clear ih\n  constructor\n  Â· rintro âŸ¨t, ht, hts, hcardstâŸ©\n    obtain âŸ¨u, hu, hut, hcardtuâŸ© := mem_up_shadow_iff_exists_mem_card_add_one.1 ht\n    refine' âŸ¨u, hu, hut.trans hts, _âŸ©\n    rw [â† hcardst, â† hcardtu, add_right_comm]\n    rfl\n  Â· rintro âŸ¨t, ht, hts, hcardâŸ©\n    obtain âŸ¨u, htu, hus, huâŸ© :=\n      Finset.exists_intermediate_set 1\n        (by\n          rw [add_comm, â† hcard]\n          exact add_le_add_left (zero_lt_succ _) _)\n        hts\n    rw [add_comm] at hu\n    refine' âŸ¨u, mem_up_shadow_iff_exists_mem_card_add_one.2 âŸ¨t, ht, htu, hu.symmâŸ©, hus, _âŸ©\n    rw [hu, â† hcard, add_right_comm]\n    rfl\n#align mem_up_shadow_iff_exists_mem_card_add mem_up_shadow_iff_exists_mem_card_add\n\n",
 "mem_up_shadow_iff_erase_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- `t` is in the upper shadow of `ğ’œ` iff we can remove an element from it so that the resulting\nfinset is in `ğ’œ`. -/\ntheorem mem_up_shadow_iff_erase_mem : s âˆˆ (finset.up_shadow) ğ’œ â†” âˆƒ a âˆˆ s, s.erase a âˆˆ ğ’œ :=\n  by\n  refine' mem_up_shadow_iff.trans âŸ¨_, _âŸ©\n  Â· rintro âŸ¨s, hs, a, ha, rflâŸ©\n    refine' âŸ¨a, mem_insert_self a s, _âŸ©\n    rwa [erase_insert ha]\n  Â· rintro âŸ¨a, ha, hsâŸ©\n    exact âŸ¨s.erase a, hs, a, not_mem_erase _ _, insert_erase haâŸ©\n#align mem_up_shadow_iff_erase_mem mem_up_shadow_iff_erase_mem\n\n",
 "mem_up_shadow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a Â«expr âˆ‰ Â» t) -/\n/-- `s` is in the upper shadow of `ğ’œ` iff there is an `t âˆˆ ğ’œ` from which we can remove one element\nto get `s`. -/\ntheorem mem_up_shadow_iff : s âˆˆ (finset.up_shadow) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, âˆƒ (a : _)(_ : a âˆ‰ t), insert a t = s := by\n  simp_rw [up_shadow, mem_sup, mem_image, exists_prop, mem_compl]\n#align mem_up_shadow_iff mem_up_shadow_iff\n\n",
 "mem_shadow_iff_insert_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a Â«expr âˆ‰ Â» s) -/\n/-- `t` is in the shadow of `ğ’œ` iff we can add an element to it so that the resulting finset is in\n`ğ’œ`. -/\ntheorem mem_shadow_iff_insert_mem : s âˆˆ (finset.shadow) ğ’œ â†” âˆƒ (a : _)(_ : a âˆ‰ s), insert a s âˆˆ ğ’œ :=\n  by\n  refine' mem_shadow_iff.trans âŸ¨_, _âŸ©\n  Â· rintro âŸ¨s, hs, a, ha, rflâŸ©\n    refine' âŸ¨a, not_mem_erase a s, _âŸ©\n    rwa [insert_erase ha]\n  Â· rintro âŸ¨a, ha, hsâŸ©\n    exact âŸ¨insert a s, hs, a, mem_insert_self _ _, erase_insert haâŸ©\n#align mem_shadow_iff_insert_mem mem_shadow_iff_insert_mem\n\n",
 "mem_shadow_iff_exists_mem_card_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- `s âˆˆ âˆ‚ ğ’œ` iff `s` is exactly one element less than something from `ğ’œ` -/\ntheorem mem_shadow_iff_exists_mem_card_add_one : s âˆˆ (finset.shadow) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, s âŠ† t âˆ§ t.card = s.card + 1 :=\n  by\n  refine' mem_shadow_iff_insert_mem.trans âŸ¨_, _âŸ©\n  Â· rintro âŸ¨a, ha, hsâŸ©\n    exact âŸ¨insert a s, hs, subset_insert _ _, card_insert_of_not_mem haâŸ©\n  Â· rintro âŸ¨t, ht, hst, hâŸ©\n    obtain âŸ¨a, haâŸ© : âˆƒ a, t \\ s = {a} := card_eq_one.1 (by rw [card_sdiff hst, h, add_tsub_cancel_left])\n    exact\n      âŸ¨a, fun hat => not_mem_sdiff_of_mem_right hat ((ha.ge : _ âŠ† _) <| mem_singleton_self a), by\n        rwa [insert_eq a s, â† ha, sdiff_union_of_subset hst]âŸ©\n#align mem_shadow_iff_exists_mem_card_add_one mem_shadow_iff_exists_mem_card_add_one\n\n",
 "mem_shadow_iff_exists_mem_card_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements less than something in `ğ’œ`. -/\ntheorem mem_shadow_iff_exists_mem_card_add :\n    s âˆˆ (Â«expr ^[ ]Â» (finset.shadow) k) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, s âŠ† t âˆ§ t.card = s.card + k :=\n  by\n  induction' k with k ih generalizing ğ’œ s\n  Â· refine' âŸ¨fun hs => âŸ¨s, hs, subset.refl _, rflâŸ©, _âŸ©\n    rintro âŸ¨t, ht, hst, hcardâŸ©\n    rwa [eq_of_subset_of_card_le hst hcard.le]\n  simp only [exists_prop, Function.comp_apply, Function.iterate_succ]\n  refine' ih.trans _\n  clear ih\n  constructor\n  Â· rintro âŸ¨t, ht, hst, hcardstâŸ©\n    obtain âŸ¨u, hu, htu, hcardtuâŸ© := mem_shadow_iff_exists_mem_card_add_one.1 ht\n    refine' âŸ¨u, hu, hst.trans htu, _âŸ©\n    rw [hcardtu, hcardst]\n    rfl\n  Â· rintro âŸ¨t, ht, hst, hcardâŸ©\n    obtain âŸ¨u, hsu, hut, huâŸ© :=\n      Finset.exists_intermediate_set k\n        (by\n          rw [add_comm, hcard]\n          exact le_succ _)\n        hst\n    rw [add_comm] at hu\n    refine' âŸ¨u, mem_shadow_iff_exists_mem_card_add_one.2 âŸ¨t, ht, hut, _âŸ©, hsu, huâŸ©\n    rw [hcard, hu]\n    rfl\n#align mem_shadow_iff_exists_mem_card_add mem_shadow_iff_exists_mem_card_add\n\n",
 "mem_shadow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- `s` is in the shadow of `ğ’œ` iff there is an `t âˆˆ ğ’œ` from which we can remove one element to\nget `s`. -/\ntheorem mem_shadow_iff : s âˆˆ (finset.shadow) ğ’œ â†” âˆƒ t âˆˆ ğ’œ, âˆƒ a âˆˆ t, erase t a = s := by\n  simp only [shadow, mem_sup, mem_image]\n#align mem_shadow_iff mem_shadow_iff\n\n",
 "insert_mem_up_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\ntheorem insert_mem_up_shadow (hs : s âˆˆ ğ’œ) (ha : a âˆ‰ s) : insert a s âˆˆ (finset.up_shadow) ğ’œ :=\n  mem_upShadow_iff.2 âŸ¨s, hs, a, ha, rflâŸ©\n#align insert_mem_up_shadow insert_mem_up_shadow\n\n",
 "exists_subset_of_mem_up_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- Being in the upper shadow of `ğ’œ` means we have a superset in `ğ’œ`. -/\ntheorem exists_subset_of_mem_up_shadow (hs : s âˆˆ (finset.up_shadow) ğ’œ) : âˆƒ t âˆˆ ğ’œ, t âŠ† s :=\n  let âŸ¨t, ht, hts, _âŸ© := mem_upShadow_iff_exists_mem_card_add_one.1 hs\n  âŸ¨t, ht, htsâŸ©\n#align exists_subset_of_mem_up_shadow exists_subset_of_mem_up_shadow\n\n",
 "exists_subset_of_mem_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- Being in the shadow of `ğ’œ` means we have a superset in `ğ’œ`. -/\ntheorem exists_subset_of_mem_shadow (hs : s âˆˆ (finset.shadow) ğ’œ) : âˆƒ t âˆˆ ğ’œ, s âŠ† t :=\n  let âŸ¨t, ht, hstâŸ© := mem_shadow_iff_exists_mem_card_add_one.1 hs\n  âŸ¨t, ht, hst.1âŸ©\n#align exists_subset_of_mem_shadow exists_subset_of_mem_shadow\n\n",
 "erase_mem_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\ntheorem erase_mem_shadow (hs : s âˆˆ ğ’œ) (ha : a âˆˆ s) : erase s a âˆˆ (finset.shadow) ğ’œ :=\n  mem_shadow_iff.2 âŸ¨s, hs, a, ha, rflâŸ©\n#align erase_mem_shadow erase_mem_shadow\n\n"}