{"up_shadow_monotone":
 "/-- The upper shadow is monotone. -/\n@[mono]\ntheorem up_shadow_monotone : Monotone (upShadow : Finset (Finset α) → Finset (Finset α)) := fun 𝒜 ℬ => sup_mono\n#align up_shadow_monotone up_shadow_monotone\n\n",
 "up_shadow_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n@[simp]\ntheorem up_shadow_image_compl : ((finset.up_shadow) 𝒜).image compl = (finset.shadow) (𝒜.image compl) :=\n  by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_up_shadow_iff]\n  constructor\n  · rintro ⟨_, ⟨s, hs, a, ha, rfl⟩, rfl⟩\n    exact ⟨«expr ᶜ» s, ⟨s, hs, rfl⟩, a, mem_compl.2 ha, compl_insert.symm⟩\n  · rintro ⟨_, ⟨s, hs, rfl⟩, a, ha, rfl⟩\n    exact ⟨insert a s, ⟨s, hs, a, mem_compl.1 ha, rfl⟩, compl_insert⟩\n#align up_shadow_image_compl up_shadow_image_compl\n\n",
 "up_shadow_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- The upper shadow of the empty set is empty. -/\n@[simp]\ntheorem up_shadow_empty : (finset.up_shadow) (∅ : Finset (Finset α)) = ∅ :=\n  rfl\n#align up_shadow_empty up_shadow_empty\n\n",
 "up_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- The upper shadow of a family of `r`-sets is a family of `r + 1`-sets. -/\nprotected theorem _root_.set.sized.up_shadow (h𝒜 : (𝒜 : Set (Finset α)).sized r) :\n    ((finset.up_shadow) 𝒜 : Set (Finset α)).sized (r + 1) :=\n  by\n  intro A h\n  obtain ⟨A, hA, i, hi, rfl⟩ := mem_up_shadow_iff.1 h\n  rw [card_insert_of_not_mem hi, h𝒜 hA]\n#align set.sized.up_shadow set.sized.up_shadow\n\n",
 "sized_shadow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\ntheorem sized_shadow_iff (h : ∅ ∉ 𝒜) :\n    ((finset.shadow) 𝒜 : Set (Finset α)).sized r ↔ (𝒜 : Set (Finset α)).sized (r + 1) :=\n  by\n  refine' ⟨fun h𝒜 s hs => _, set.sized.shadow⟩\n  obtain ⟨a, ha⟩ := nonempty_iff_ne_empty.2 (ne_of_mem_of_not_mem hs h)\n  rw [← h𝒜 (erase_mem_shadow hs ha), card_erase_add_one ha]\n#align sized_shadow_iff sized_shadow_iff\n\n",
 "shadow_singleton_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n@[simp]\ntheorem shadow_singleton_empty : (finset.shadow) ({∅} : Finset (Finset α)) = ∅ :=\n  rfl\n#align shadow_singleton_empty shadow_singleton_empty\n\n",
 "shadow_monotone":
 "--TODO: Prove `∂ {{a}} = {∅}` quickly using `covers` and `grade_order`\n/-- The shadow is monotone. -/\n@[mono]\ntheorem shadow_monotone : Monotone (shadow : Finset (Finset α) → Finset (Finset α)) := fun 𝒜 ℬ => sup_mono\n#align shadow_monotone shadow_monotone\n\n",
 "shadow_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n@[simp]\ntheorem shadow_image_compl : ((finset.shadow) 𝒜).image compl = (finset.up_shadow) (𝒜.image compl) :=\n  by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_up_shadow_iff]\n  constructor\n  · rintro ⟨_, ⟨s, hs, a, ha, rfl⟩, rfl⟩\n    exact ⟨«expr ᶜ» s, ⟨s, hs, rfl⟩, a, not_mem_compl.2 ha, compl_erase.symm⟩\n  · rintro ⟨_, ⟨s, hs, rfl⟩, a, ha, rfl⟩\n    exact ⟨s.erase a, ⟨s, hs, a, not_mem_compl.1 ha, rfl⟩, compl_erase⟩\n#align shadow_image_compl shadow_image_compl\n\n",
 "shadow_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-\nCopyright (c) 2021 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Alena Gusakov, Yaël Dillies\n-/\n/-- The shadow of the empty set is empty. -/\n@[simp]\ntheorem shadow_empty : (finset.shadow) (∅ : Finset (Finset α)) = ∅ :=\n  rfl\n#align shadow_empty shadow_empty\n\n",
 "shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- The shadow of a family of `r`-sets is a family of `r - 1`-sets. -/\nprotected theorem _root_.set.sized.shadow (h𝒜 : (𝒜 : Set (Finset α)).sized r) :\n    ((finset.shadow) 𝒜 : Set (Finset α)).sized (r - 1) :=\n  by\n  intro A h\n  obtain ⟨A, hA, i, hi, rfl⟩ := mem_shadow_iff.1 h\n  rw [card_erase_of_mem hi, h𝒜 hA]\n#align set.sized.shadow set.sized.shadow\n\n",
 "mem_up_shadow_iff_exists_mem_card_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- `s ∈ ∂⁺ 𝒜` iff `s` is exactly one element less than something from `𝒜`. -/\ntheorem mem_up_shadow_iff_exists_mem_card_add_one : s ∈ (finset.up_shadow) 𝒜 ↔ ∃ t ∈ 𝒜, t ⊆ s ∧ t.card + 1 = s.card :=\n  by\n  refine' mem_up_shadow_iff_erase_mem.trans ⟨_, _⟩\n  · rintro ⟨a, ha, hs⟩\n    exact ⟨s.erase a, hs, erase_subset _ _, card_erase_add_one ha⟩\n  · rintro ⟨t, ht, hts, h⟩\n    obtain ⟨a, ha⟩ : ∃ a, s \\ t = {a} := card_eq_one.1 (by rw [card_sdiff hts, ← h, add_tsub_cancel_left])\n    refine' ⟨a, sdiff_subset _ _ ((ha.ge : _ ⊆ _) <| mem_singleton_self a), _⟩\n    rwa [← sdiff_singleton_eq_erase, ← ha, sdiff_sdiff_eq_self hts]\n#align mem_up_shadow_iff_exists_mem_card_add_one mem_up_shadow_iff_exists_mem_card_add_one\n\n",
 "mem_up_shadow_iff_exists_mem_card_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- `t ∈ ∂^k 𝒜` iff `t` is exactly `k` elements more than something in `𝒜`. -/\ntheorem mem_up_shadow_iff_exists_mem_card_add :\n    s ∈ («expr ^[ ]» (finset.up_shadow) k) 𝒜 ↔ ∃ t ∈ 𝒜, t ⊆ s ∧ t.card + k = s.card :=\n  by\n  induction' k with k ih generalizing 𝒜 s\n  · refine' ⟨fun hs => ⟨s, hs, subset.refl _, rfl⟩, _⟩\n    rintro ⟨t, ht, hst, hcard⟩\n    rwa [← eq_of_subset_of_card_le hst hcard.ge]\n  simp only [exists_prop, Function.comp_apply, Function.iterate_succ]\n  refine' ih.trans _\n  clear ih\n  constructor\n  · rintro ⟨t, ht, hts, hcardst⟩\n    obtain ⟨u, hu, hut, hcardtu⟩ := mem_up_shadow_iff_exists_mem_card_add_one.1 ht\n    refine' ⟨u, hu, hut.trans hts, _⟩\n    rw [← hcardst, ← hcardtu, add_right_comm]\n    rfl\n  · rintro ⟨t, ht, hts, hcard⟩\n    obtain ⟨u, htu, hus, hu⟩ :=\n      Finset.exists_intermediate_set 1\n        (by\n          rw [add_comm, ← hcard]\n          exact add_le_add_left (zero_lt_succ _) _)\n        hts\n    rw [add_comm] at hu\n    refine' ⟨u, mem_up_shadow_iff_exists_mem_card_add_one.2 ⟨t, ht, htu, hu.symm⟩, hus, _⟩\n    rw [hu, ← hcard, add_right_comm]\n    rfl\n#align mem_up_shadow_iff_exists_mem_card_add mem_up_shadow_iff_exists_mem_card_add\n\n",
 "mem_up_shadow_iff_erase_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- `t` is in the upper shadow of `𝒜` iff we can remove an element from it so that the resulting\nfinset is in `𝒜`. -/\ntheorem mem_up_shadow_iff_erase_mem : s ∈ (finset.up_shadow) 𝒜 ↔ ∃ a ∈ s, s.erase a ∈ 𝒜 :=\n  by\n  refine' mem_up_shadow_iff.trans ⟨_, _⟩\n  · rintro ⟨s, hs, a, ha, rfl⟩\n    refine' ⟨a, mem_insert_self a s, _⟩\n    rwa [erase_insert ha]\n  · rintro ⟨a, ha, hs⟩\n    exact ⟨s.erase a, hs, a, not_mem_erase _ _, insert_erase ha⟩\n#align mem_up_shadow_iff_erase_mem mem_up_shadow_iff_erase_mem\n\n",
 "mem_up_shadow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a «expr ∉ » t) -/\n/-- `s` is in the upper shadow of `𝒜` iff there is an `t ∈ 𝒜` from which we can remove one element\nto get `s`. -/\ntheorem mem_up_shadow_iff : s ∈ (finset.up_shadow) 𝒜 ↔ ∃ t ∈ 𝒜, ∃ (a : _)(_ : a ∉ t), insert a t = s := by\n  simp_rw [up_shadow, mem_sup, mem_image, exists_prop, mem_compl]\n#align mem_up_shadow_iff mem_up_shadow_iff\n\n",
 "mem_shadow_iff_insert_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a «expr ∉ » s) -/\n/-- `t` is in the shadow of `𝒜` iff we can add an element to it so that the resulting finset is in\n`𝒜`. -/\ntheorem mem_shadow_iff_insert_mem : s ∈ (finset.shadow) 𝒜 ↔ ∃ (a : _)(_ : a ∉ s), insert a s ∈ 𝒜 :=\n  by\n  refine' mem_shadow_iff.trans ⟨_, _⟩\n  · rintro ⟨s, hs, a, ha, rfl⟩\n    refine' ⟨a, not_mem_erase a s, _⟩\n    rwa [insert_erase ha]\n  · rintro ⟨a, ha, hs⟩\n    exact ⟨insert a s, hs, a, mem_insert_self _ _, erase_insert ha⟩\n#align mem_shadow_iff_insert_mem mem_shadow_iff_insert_mem\n\n",
 "mem_shadow_iff_exists_mem_card_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- `s ∈ ∂ 𝒜` iff `s` is exactly one element less than something from `𝒜` -/\ntheorem mem_shadow_iff_exists_mem_card_add_one : s ∈ (finset.shadow) 𝒜 ↔ ∃ t ∈ 𝒜, s ⊆ t ∧ t.card = s.card + 1 :=\n  by\n  refine' mem_shadow_iff_insert_mem.trans ⟨_, _⟩\n  · rintro ⟨a, ha, hs⟩\n    exact ⟨insert a s, hs, subset_insert _ _, card_insert_of_not_mem ha⟩\n  · rintro ⟨t, ht, hst, h⟩\n    obtain ⟨a, ha⟩ : ∃ a, t \\ s = {a} := card_eq_one.1 (by rw [card_sdiff hst, h, add_tsub_cancel_left])\n    exact\n      ⟨a, fun hat => not_mem_sdiff_of_mem_right hat ((ha.ge : _ ⊆ _) <| mem_singleton_self a), by\n        rwa [insert_eq a s, ← ha, sdiff_union_of_subset hst]⟩\n#align mem_shadow_iff_exists_mem_card_add_one mem_shadow_iff_exists_mem_card_add_one\n\n",
 "mem_shadow_iff_exists_mem_card_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- `t ∈ ∂^k 𝒜` iff `t` is exactly `k` elements less than something in `𝒜`. -/\ntheorem mem_shadow_iff_exists_mem_card_add :\n    s ∈ («expr ^[ ]» (finset.shadow) k) 𝒜 ↔ ∃ t ∈ 𝒜, s ⊆ t ∧ t.card = s.card + k :=\n  by\n  induction' k with k ih generalizing 𝒜 s\n  · refine' ⟨fun hs => ⟨s, hs, subset.refl _, rfl⟩, _⟩\n    rintro ⟨t, ht, hst, hcard⟩\n    rwa [eq_of_subset_of_card_le hst hcard.le]\n  simp only [exists_prop, Function.comp_apply, Function.iterate_succ]\n  refine' ih.trans _\n  clear ih\n  constructor\n  · rintro ⟨t, ht, hst, hcardst⟩\n    obtain ⟨u, hu, htu, hcardtu⟩ := mem_shadow_iff_exists_mem_card_add_one.1 ht\n    refine' ⟨u, hu, hst.trans htu, _⟩\n    rw [hcardtu, hcardst]\n    rfl\n  · rintro ⟨t, ht, hst, hcard⟩\n    obtain ⟨u, hsu, hut, hu⟩ :=\n      Finset.exists_intermediate_set k\n        (by\n          rw [add_comm, hcard]\n          exact le_succ _)\n        hst\n    rw [add_comm] at hu\n    refine' ⟨u, mem_shadow_iff_exists_mem_card_add_one.2 ⟨t, ht, hut, _⟩, hsu, hu⟩\n    rw [hcard, hu]\n    rfl\n#align mem_shadow_iff_exists_mem_card_add mem_shadow_iff_exists_mem_card_add\n\n",
 "mem_shadow_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- `s` is in the shadow of `𝒜` iff there is an `t ∈ 𝒜` from which we can remove one element to\nget `s`. -/\ntheorem mem_shadow_iff : s ∈ (finset.shadow) 𝒜 ↔ ∃ t ∈ 𝒜, ∃ a ∈ t, erase t a = s := by\n  simp only [shadow, mem_sup, mem_image]\n#align mem_shadow_iff mem_shadow_iff\n\n",
 "insert_mem_up_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\ntheorem insert_mem_up_shadow (hs : s ∈ 𝒜) (ha : a ∉ s) : insert a s ∈ (finset.up_shadow) 𝒜 :=\n  mem_upShadow_iff.2 ⟨s, hs, a, ha, rfl⟩\n#align insert_mem_up_shadow insert_mem_up_shadow\n\n",
 "exists_subset_of_mem_up_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.up_shadow -/\n/-- Being in the upper shadow of `𝒜` means we have a superset in `𝒜`. -/\ntheorem exists_subset_of_mem_up_shadow (hs : s ∈ (finset.up_shadow) 𝒜) : ∃ t ∈ 𝒜, t ⊆ s :=\n  let ⟨t, ht, hts, _⟩ := mem_upShadow_iff_exists_mem_card_add_one.1 hs\n  ⟨t, ht, hts⟩\n#align exists_subset_of_mem_up_shadow exists_subset_of_mem_up_shadow\n\n",
 "exists_subset_of_mem_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- Being in the shadow of `𝒜` means we have a superset in `𝒜`. -/\ntheorem exists_subset_of_mem_shadow (hs : s ∈ (finset.shadow) 𝒜) : ∃ t ∈ 𝒜, s ⊆ t :=\n  let ⟨t, ht, hst⟩ := mem_shadow_iff_exists_mem_card_add_one.1 hs\n  ⟨t, ht, hst.1⟩\n#align exists_subset_of_mem_shadow exists_subset_of_mem_shadow\n\n",
 "erase_mem_shadow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\ntheorem erase_mem_shadow (hs : s ∈ 𝒜) (ha : a ∈ s) : erase s a ∈ (finset.shadow) 𝒜 :=\n  mem_shadow_iff.2 ⟨s, hs, a, ha, rfl⟩\n#align erase_mem_shadow erase_mem_shadow\n\n"}