{"sum_card_slice_div_choose_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- The **Lubell-Yamamoto-Meshalkin inequality**. If `ğ’œ` is an antichain, then the sum of the\nproportion of elements it takes from each layer is less than `1`. -/\ntheorem sum_card_slice_div_choose_le_one [Fintype Î±] (hğ’œ : IsAntichain (Â· âŠ† Â·) (ğ’œ : Set (Finset Î±))) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (range (Fintype.card Î± + 1)) (((finset.slice ğ’œ r).card : ğ•œ) / (Fintype.card Î±).choose r) â‰¤\n      1 :=\n  by\n  classical\n    rw [â† sum_flip]\n    refine' (le_card_falling_div_choose le_rfl hğ’œ).trans _\n    rw [div_le_iff] <;> norm_cast\n    Â· simpa only [nat.sub_self, one_mul, Nat.choose_zero_right, falling] using (sized_falling 0 ğ’œ).card_le\n    Â· rw [tsub_self, choose_zero_right]\n      exact zero_lt_one\n#align sum_card_slice_div_choose_le_one sum_card_slice_div_choose_le_one\n\n",
 "sperner":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/-- **Sperner's theorem**. The size of an antichain in `finset Î±` is bounded by the size of the\nmaximal layer in `finset Î±`. This precisely means that `finset Î±` is a Sperner order. -/\ntheorem _root_.is_antichain.sperner [Fintype Î±] {ğ’œ : Finset (Finset Î±)}\n    (hğ’œ : IsAntichain (Â· âŠ† Â·) (ğ’œ : Set (Finset Î±))) : ğ’œ.card â‰¤ (Fintype.card Î±).choose (Fintype.card Î± / 2) := by\n  classical\n    suffices\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Iic (Fintype.card Î±)) (((finset.slice ğ’œ r).card : exprâ„š) / (Fintype.card Î±).choose (Fintype.card Î± / 2)) â‰¤\n        1\n      by\n      rwa [â† sum_div, â† Nat.cast_sum, div_le_one, cast_le, sum_card_slice] at this\n      norm_cast\n      exact choose_pos (nat.div_le_self _ _)\n    rw [Iic_eq_Icc, â† Ico_succ_right, bot_eq_zero, Ico_zero_eq_range]\n    refine' (sum_le_sum fun r hr => _).trans (sum_card_slice_div_choose_le_one hğ’œ)\n    rw [mem_range] at hr\n    refine' div_le_div_of_le_left _ _ _ <;> norm_cast\n    Â· exact nat.zero_le _\n    Â· exact choose_pos (lt_succ_iff.1 hr)\n    Â· exact choose_le_middle _ _\n#align is_antichain.sperner is_antichain.sperner\n\n",
 "slice_union_shadow_falling_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\ntheorem slice_union_shadow_falling_succ : finset.slice ğ’œ k âˆª (finset.shadow) (falling (k + 1) ğ’œ) = falling k ğ’œ :=\n  by\n  ext s\n  simp_rw [mem_union, mem_slice, mem_shadow_iff, exists_prop, mem_falling]\n  constructor\n  Â· rintro (h | âŸ¨s, âŸ¨âŸ¨t, ht, hstâŸ©, hsâŸ©, a, ha, rflâŸ©)\n    Â· exact âŸ¨âŸ¨s, h.1, subset.refl _âŸ©, h.2âŸ©\n    refine' âŸ¨âŸ¨t, ht, (erase_subset _ _).trans hstâŸ©, _âŸ©\n    rw [card_erase_of_mem ha, hs]\n    rfl\n  Â· rintro âŸ¨âŸ¨t, ht, hstâŸ©, hsâŸ©\n    by_cases s âˆˆ ğ’œ\n    Â· exact or.inl âŸ¨h, hsâŸ©\n    obtain âŸ¨a, ha, hstâŸ© := ssubset_iff.1 (ssubset_of_subset_of_ne hst (ht.ne_of_not_mem h).symm)\n    refine' or.inr âŸ¨insert a s, âŸ¨âŸ¨t, ht, hstâŸ©, _âŸ©, a, mem_insert_self _ _, erase_insert haâŸ©\n    rw [card_insert_of_not_mem ha, hs]\n#align slice_union_shadow_falling_succ slice_union_shadow_falling_succ\n\n",
 "slice_subset_falling":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\ntheorem slice_subset_falling : finset.slice ğ’œ k âŠ† falling k ğ’œ := fun s hs =>\n  mem_falling.2 <| (mem_slice.1 hs).imp_left fun h => âŸ¨s, h, Subset.refl _âŸ©\n#align slice_subset_falling slice_subset_falling\n\n",
 "sized_falling":
 "theorem sized_falling : (falling k ğ’œ : Set (Finset Î±)).sized k := fun s hs => (mem_falling.1 hs).2\n#align sized_falling sized_falling\n\n",
 "mem_falling":
 "theorem mem_falling : s âˆˆ falling k ğ’œ â†” (âˆƒ t âˆˆ ğ’œ, s âŠ† t) âˆ§ s.card = k := by\n  simp_rw [falling, mem_sup, mem_powerset_len, exists_and_right]\n#align mem_falling mem_falling\n\n",
 "le_card_falling_div_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- A bound on any top part of the sum in LYM in terms of the size of `falling k ğ’œ`. -/\ntheorem le_card_falling_div_choose [Fintype Î±] (hk : k â‰¤ Fintype.card Î±)\n    (hğ’œ : IsAntichain (Â· âŠ† Â·) (ğ’œ : Set (Finset Î±))) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (k + 1))\n        (((finset.slice ğ’œ (Fintype.card Î± - r)).card : ğ•œ) / (Fintype.card Î±).choose (Fintype.card Î± - r)) â‰¤\n      (falling (Fintype.card Î± - k) ğ’œ).card / (Fintype.card Î±).choose (Fintype.card Î± - k) :=\n  by\n  induction' k with k ih\n  Â· simp only [tsub_zero, cast_one, cast_le, sum_singleton, div_one, choose_self, range_one]\n    exact card_le_of_subset (slice_subset_falling _ _)\n  rw [succ_eq_add_one] at *\n  rw [sum_range_succ, â† slice_union_shadow_falling_succ, card_disjoint_union hğ’œ.disjoint_slice_shadow_falling, cast_add,\n    _root_.add_div, add_comm]\n  rw [â† tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left hk)]\n  exact\n    add_le_add_left\n      ((ih <| le_of_succ_le hk).trans <|\n        card_div_choose_le_card_shadow_div_choose (tsub_pos_iff_lt.2 <| Nat.succ_le_iff.1 hk).ne' <| sized_falling _ _)\n      _\n#align le_card_falling_div_choose le_card_falling_div_choose\n\n",
 "falling_zero_subset":
 "theorem falling_zero_subset : falling 0 ğ’œ âŠ† {âˆ…} :=\n  subset_singleton_iff'.2 fun t ht => card_eq_zero.1 <| sized_falling _ _ ht\n#align falling_zero_subset falling_zero_subset\n\n",
 "disjoint_slice_shadow_falling":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- The shadow of `falling m ğ’œ` is disjoint from the `n`-sized elements of `ğ’œ`, thanks to the\nantichain property. -/\ntheorem _root_.is_antichain.disjoint_slice_shadow_falling {m n : â„•} (hğ’œ : IsAntichain (Â· âŠ† Â·) (ğ’œ : Set (Finset Î±))) :\n    Disjoint (finset.slice ğ’œ m) ((finset.shadow) (falling n ğ’œ)) :=\n  disjoint_right.2 fun s hâ‚ hâ‚‚ =>\n    by\n    simp_rw [mem_shadow_iff, exists_prop, mem_falling] at hâ‚\n    obtain âŸ¨s, âŸ¨âŸ¨t, ht, hstâŸ©, hsâŸ©, a, ha, rflâŸ© := hâ‚\n    refine' hğ’œ (slice_subset hâ‚‚) ht _ ((erase_subset _ _).trans hst)\n    rintro rfl\n    exact not_mem_erase _ _ (hst ha)\n#align is_antichain.disjoint_slice_shadow_falling is_antichain.disjoint_slice_shadow_falling\n\n",
 "card_mul_le_card_shadow_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-\nCopyright (c) 2022 Bhavik Mehta, YaÃ«l Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Alena Gusakov, YaÃ«l Dillies\n-/\n/-- The downward **local LYM inequality**, with cancelled denominators. `ğ’œ` takes up less of `Î±^(r)`\n(the finsets of card `r`) than `âˆ‚ğ’œ` takes up of `Î±^(r - 1)`. -/\ntheorem card_mul_le_card_shadow_mul (hğ’œ : (ğ’œ : Set (Finset Î±)).sized r) :\n    ğ’œ.card * r â‰¤ ((finset.shadow) ğ’œ).card * (Fintype.card Î± - r + 1) :=\n  by\n  refine' card_mul_le_card_mul' (Â· âŠ† Â·) (fun s hs => _) fun s hs => _\n  Â· rw [â† hğ’œ hs, â† card_image_of_inj_on s.erase_inj_on]\n    refine' card_le_of_subset _\n    simp_rw [image_subset_iff, mem_bipartite_below]\n    exact fun a ha => âŸ¨erase_mem_shadow hs ha, erase_subset _ _âŸ©\n  refine' le_trans _ tsub_tsub_le_tsub_add\n  rw [â† hğ’œ.shadow hs, â† card_compl, â† card_image_of_inj_on (insert_inj_on' _)]\n  refine' card_le_of_subset fun t ht => _\n  infer_instance\n  rw [mem_bipartite_above] at ht\n  have : âˆ… âˆ‰ ğ’œ := by\n    rw [â† mem_coe, hğ’œ.empty_mem_iff, coe_eq_singleton]\n    rintro rfl\n    rwa [shadow_singleton_empty] at hs\n  obtain âŸ¨a, ha, rflâŸ© := exists_eq_insert_iff.2 âŸ¨ht.2, by rw [(sized_shadow_iff this).1 hğ’œ.shadow ht.1, hğ’œ.shadow hs]âŸ©\n  exact mem_image_of_mem _ (mem_compl.2 ha)\n#align card_mul_le_card_shadow_mul card_mul_le_card_shadow_mul\n\n",
 "card_div_choose_le_card_shadow_div_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- The downward **local LYM inequality**. `ğ’œ` takes up less of `Î±^(r)` (the finsets of card `r`)\nthan `âˆ‚ğ’œ` takes up of `Î±^(r - 1)`. -/\ntheorem card_div_choose_le_card_shadow_div_choose (hr : r â‰  0) (hğ’œ : (ğ’œ : Set (Finset Î±)).sized r) :\n    (ğ’œ.card : ğ•œ) / (Fintype.card Î±).choose r â‰¤ ((finset.shadow) ğ’œ).card / (Fintype.card Î±).choose (r - 1) :=\n  by\n  obtain hr' | hr' := lt_or_le (Fintype.card Î±) r\n  Â· rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]\n    exact div_nonneg (cast_nonneg _) (cast_nonneg _)\n  replace hğ’œ := card_mul_le_card_shadow_mul hğ’œ\n  rw [div_le_div_iff] <;> norm_cast\n  Â· cases r\n    Â· exact (hr rfl).elim\n    rw [nat.succ_eq_add_one] at *\n    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at hğ’œ\n    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)\n    convert nat.mul_le_mul_right ((Fintype.card Î±).choose r) hğ’œ using 1\n    Â· simp [mul_assoc, Nat.choose_succ_right_eq]\n      exact or.inl (mul_comm _ _)\n    Â· simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]\n      exact or.inl (mul_comm _ _)\n  Â· exact Nat.choose_pos hr'\n  Â· exact Nat.choose_pos (r.pred_le.trans hr')\n#align card_div_choose_le_card_shadow_div_choose card_div_choose_le_card_shadow_div_choose\n\n"}