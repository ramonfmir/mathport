{"sum_card_slice_div_choose_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- The **Lubell-Yamamoto-Meshalkin inequality**. If `𝒜` is an antichain, then the sum of the\nproportion of elements it takes from each layer is less than `1`. -/\ntheorem sum_card_slice_div_choose_le_one [Fintype α] (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (range (Fintype.card α + 1)) (((finset.slice 𝒜 r).card : 𝕜) / (Fintype.card α).choose r) ≤\n      1 :=\n  by\n  classical\n    rw [← sum_flip]\n    refine' (le_card_falling_div_choose le_rfl h𝒜).trans _\n    rw [div_le_iff] <;> norm_cast\n    · simpa only [nat.sub_self, one_mul, Nat.choose_zero_right, falling] using (sized_falling 0 𝒜).card_le\n    · rw [tsub_self, choose_zero_right]\n      exact zero_lt_one\n#align sum_card_slice_div_choose_le_one sum_card_slice_div_choose_le_one\n\n",
 "sperner":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- **Sperner's theorem**. The size of an antichain in `finset α` is bounded by the size of the\nmaximal layer in `finset α`. This precisely means that `finset α` is a Sperner order. -/\ntheorem _root_.is_antichain.sperner [Fintype α] {𝒜 : Finset (Finset α)}\n    (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) : 𝒜.card ≤ (Fintype.card α).choose (Fintype.card α / 2) := by\n  classical\n    suffices\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Iic (Fintype.card α)) (((finset.slice 𝒜 r).card : exprℚ) / (Fintype.card α).choose (Fintype.card α / 2)) ≤\n        1\n      by\n      rwa [← sum_div, ← Nat.cast_sum, div_le_one, cast_le, sum_card_slice] at this\n      norm_cast\n      exact choose_pos (nat.div_le_self _ _)\n    rw [Iic_eq_Icc, ← Ico_succ_right, bot_eq_zero, Ico_zero_eq_range]\n    refine' (sum_le_sum fun r hr => _).trans (sum_card_slice_div_choose_le_one h𝒜)\n    rw [mem_range] at hr\n    refine' div_le_div_of_le_left _ _ _ <;> norm_cast\n    · exact nat.zero_le _\n    · exact choose_pos (lt_succ_iff.1 hr)\n    · exact choose_le_middle _ _\n#align is_antichain.sperner is_antichain.sperner\n\n",
 "slice_union_shadow_falling_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\ntheorem slice_union_shadow_falling_succ : finset.slice 𝒜 k ∪ (finset.shadow) (falling (k + 1) 𝒜) = falling k 𝒜 :=\n  by\n  ext s\n  simp_rw [mem_union, mem_slice, mem_shadow_iff, exists_prop, mem_falling]\n  constructor\n  · rintro (h | ⟨s, ⟨⟨t, ht, hst⟩, hs⟩, a, ha, rfl⟩)\n    · exact ⟨⟨s, h.1, subset.refl _⟩, h.2⟩\n    refine' ⟨⟨t, ht, (erase_subset _ _).trans hst⟩, _⟩\n    rw [card_erase_of_mem ha, hs]\n    rfl\n  · rintro ⟨⟨t, ht, hst⟩, hs⟩\n    by_cases s ∈ 𝒜\n    · exact or.inl ⟨h, hs⟩\n    obtain ⟨a, ha, hst⟩ := ssubset_iff.1 (ssubset_of_subset_of_ne hst (ht.ne_of_not_mem h).symm)\n    refine' or.inr ⟨insert a s, ⟨⟨t, ht, hst⟩, _⟩, a, mem_insert_self _ _, erase_insert ha⟩\n    rw [card_insert_of_not_mem ha, hs]\n#align slice_union_shadow_falling_succ slice_union_shadow_falling_succ\n\n",
 "slice_subset_falling":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\ntheorem slice_subset_falling : finset.slice 𝒜 k ⊆ falling k 𝒜 := fun s hs =>\n  mem_falling.2 <| (mem_slice.1 hs).imp_left fun h => ⟨s, h, Subset.refl _⟩\n#align slice_subset_falling slice_subset_falling\n\n",
 "sized_falling":
 "theorem sized_falling : (falling k 𝒜 : Set (Finset α)).sized k := fun s hs => (mem_falling.1 hs).2\n#align sized_falling sized_falling\n\n",
 "mem_falling":
 "theorem mem_falling : s ∈ falling k 𝒜 ↔ (∃ t ∈ 𝒜, s ⊆ t) ∧ s.card = k := by\n  simp_rw [falling, mem_sup, mem_powerset_len, exists_and_right]\n#align mem_falling mem_falling\n\n",
 "le_card_falling_div_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- A bound on any top part of the sum in LYM in terms of the size of `falling k 𝒜`. -/\ntheorem le_card_falling_div_choose [Fintype α] (hk : k ≤ Fintype.card α)\n    (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (k + 1))\n        (((finset.slice 𝒜 (Fintype.card α - r)).card : 𝕜) / (Fintype.card α).choose (Fintype.card α - r)) ≤\n      (falling (Fintype.card α - k) 𝒜).card / (Fintype.card α).choose (Fintype.card α - k) :=\n  by\n  induction' k with k ih\n  · simp only [tsub_zero, cast_one, cast_le, sum_singleton, div_one, choose_self, range_one]\n    exact card_le_of_subset (slice_subset_falling _ _)\n  rw [succ_eq_add_one] at *\n  rw [sum_range_succ, ← slice_union_shadow_falling_succ, card_disjoint_union h𝒜.disjoint_slice_shadow_falling, cast_add,\n    _root_.add_div, add_comm]\n  rw [← tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left hk)]\n  exact\n    add_le_add_left\n      ((ih <| le_of_succ_le hk).trans <|\n        card_div_choose_le_card_shadow_div_choose (tsub_pos_iff_lt.2 <| Nat.succ_le_iff.1 hk).ne' <| sized_falling _ _)\n      _\n#align le_card_falling_div_choose le_card_falling_div_choose\n\n",
 "falling_zero_subset":
 "theorem falling_zero_subset : falling 0 𝒜 ⊆ {∅} :=\n  subset_singleton_iff'.2 fun t ht => card_eq_zero.1 <| sized_falling _ _ ht\n#align falling_zero_subset falling_zero_subset\n\n",
 "disjoint_slice_shadow_falling":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- The shadow of `falling m 𝒜` is disjoint from the `n`-sized elements of `𝒜`, thanks to the\nantichain property. -/\ntheorem _root_.is_antichain.disjoint_slice_shadow_falling {m n : ℕ} (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) :\n    Disjoint (finset.slice 𝒜 m) ((finset.shadow) (falling n 𝒜)) :=\n  disjoint_right.2 fun s h₁ h₂ =>\n    by\n    simp_rw [mem_shadow_iff, exists_prop, mem_falling] at h₁\n    obtain ⟨s, ⟨⟨t, ht, hst⟩, hs⟩, a, ha, rfl⟩ := h₁\n    refine' h𝒜 (slice_subset h₂) ht _ ((erase_subset _ _).trans hst)\n    rintro rfl\n    exact not_mem_erase _ _ (hst ha)\n#align is_antichain.disjoint_slice_shadow_falling is_antichain.disjoint_slice_shadow_falling\n\n",
 "card_mul_le_card_shadow_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-\nCopyright (c) 2022 Bhavik Mehta, Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Alena Gusakov, Yaël Dillies\n-/\n/-- The downward **local LYM inequality**, with cancelled denominators. `𝒜` takes up less of `α^(r)`\n(the finsets of card `r`) than `∂𝒜` takes up of `α^(r - 1)`. -/\ntheorem card_mul_le_card_shadow_mul (h𝒜 : (𝒜 : Set (Finset α)).sized r) :\n    𝒜.card * r ≤ ((finset.shadow) 𝒜).card * (Fintype.card α - r + 1) :=\n  by\n  refine' card_mul_le_card_mul' (· ⊆ ·) (fun s hs => _) fun s hs => _\n  · rw [← h𝒜 hs, ← card_image_of_inj_on s.erase_inj_on]\n    refine' card_le_of_subset _\n    simp_rw [image_subset_iff, mem_bipartite_below]\n    exact fun a ha => ⟨erase_mem_shadow hs ha, erase_subset _ _⟩\n  refine' le_trans _ tsub_tsub_le_tsub_add\n  rw [← h𝒜.shadow hs, ← card_compl, ← card_image_of_inj_on (insert_inj_on' _)]\n  refine' card_le_of_subset fun t ht => _\n  infer_instance\n  rw [mem_bipartite_above] at ht\n  have : ∅ ∉ 𝒜 := by\n    rw [← mem_coe, h𝒜.empty_mem_iff, coe_eq_singleton]\n    rintro rfl\n    rwa [shadow_singleton_empty] at hs\n  obtain ⟨a, ha, rfl⟩ := exists_eq_insert_iff.2 ⟨ht.2, by rw [(sized_shadow_iff this).1 h𝒜.shadow ht.1, h𝒜.shadow hs]⟩\n  exact mem_image_of_mem _ (mem_compl.2 ha)\n#align card_mul_le_card_shadow_mul card_mul_le_card_shadow_mul\n\n",
 "card_div_choose_le_card_shadow_div_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.shadow -/\n/-- The downward **local LYM inequality**. `𝒜` takes up less of `α^(r)` (the finsets of card `r`)\nthan `∂𝒜` takes up of `α^(r - 1)`. -/\ntheorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0) (h𝒜 : (𝒜 : Set (Finset α)).sized r) :\n    (𝒜.card : 𝕜) / (Fintype.card α).choose r ≤ ((finset.shadow) 𝒜).card / (Fintype.card α).choose (r - 1) :=\n  by\n  obtain hr' | hr' := lt_or_le (Fintype.card α) r\n  · rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]\n    exact div_nonneg (cast_nonneg _) (cast_nonneg _)\n  replace h𝒜 := card_mul_le_card_shadow_mul h𝒜\n  rw [div_le_div_iff] <;> norm_cast\n  · cases r\n    · exact (hr rfl).elim\n    rw [nat.succ_eq_add_one] at *\n    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at h𝒜\n    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)\n    convert nat.mul_le_mul_right ((Fintype.card α).choose r) h𝒜 using 1\n    · simp [mul_assoc, Nat.choose_succ_right_eq]\n      exact or.inl (mul_comm _ _)\n    · simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]\n      exact or.inl (mul_comm _ _)\n  · exact Nat.choose_pos hr'\n  · exact Nat.choose_pos (r.pred_le.trans hr')\n#align card_div_choose_le_card_shadow_div_choose card_div_choose_le_card_shadow_div_choose\n\n"}