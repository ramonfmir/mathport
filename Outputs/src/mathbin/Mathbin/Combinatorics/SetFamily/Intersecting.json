{"not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem intersecting.not_mem {s : set α} (hs : s.intersecting) {a : α} (ha : «expr ᶜ» a ∈ s) : a ∉ s := fun h =>\n  hs ha h disjoint_compl_left\n#align intersecting.not_mem intersecting.not_mem\n\n",
 "not_compl_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem intersecting.not_compl_mem {s : set α} (hs : s.intersecting) {a : α} (ha : a ∈ s) : «expr ᶜ» a ∉ s := fun h =>\n  hs ha h disjoint_compl_right\n#align intersecting.not_compl_mem intersecting.not_compl_mem\n\n",
 "not_bot_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem intersecting.not_bot_mem (hs : s.intersecting) : «expr⊥» ∉ s := fun h => hs h h disjoint_bot_left\n#align intersecting.not_bot_mem intersecting.not_bot_mem\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem intersecting.ne_bot (hs : s.intersecting) (ha : a ∈ s) : a ≠ «expr⊥» :=\n  ne_of_mem_of_not_mem ha hs.not_bot_mem\n#align intersecting.ne_bot intersecting.ne_bot\n\n",
 "mono":
 "/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\n@[mono]\ntheorem intersecting.mono (h : t ⊆ s) (hs : s.intersecting) : t.intersecting := fun a ha b hb => hs (h ha) (h hb)\n#align intersecting.mono intersecting.mono\n\n",
 "is_upper_set'":
 "/-- Maximal intersecting families are upper sets. Finset version. -/\ntheorem intersecting.is_upper_set' {s : Finset α} (hs : (s : set α).intersecting)\n    (h : ∀ t : Finset α, (t : set α).intersecting → s ⊆ t → s = t) : is_upper_set (s : set α) := by\n  classical\n    rintro a b hab ha\n    rw [h (insert b s) _ (Finset.subset_insert _ _)]\n    · exact mem_insert_self _ _\n    rw [coe_insert]\n    exact hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n#align intersecting.is_upper_set' intersecting.is_upper_set'\n\n",
 "is_upper_set":
 "/-- Maximal intersecting families are upper sets. -/\nprotected theorem intersecting.is_upper_set (hs : s.intersecting) (h : ∀ t : set α, t.intersecting → s ⊆ t → s = t) :\n    is_upper_set s := by\n  classical\n    rintro a b hab ha\n    rw [h (insert b s) _ (subset_insert _ _)]\n    · exact mem_insert _ _\n    exact hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n#align intersecting.is_upper_set intersecting.is_upper_set\n\n",
 "is_max_iff_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- Note, this lemma is false when `α` has exactly one element and boring when `α` is empty.\ntheorem intersecting.is_max_iff_card_eq (hs : (s : set α).intersecting) :\n    (∀ t : Finset α, (t : set α).intersecting → s ⊆ t → s = t) ↔ 2 * s.card = fintype.card α := by\n  classical\n    refine'\n      ⟨fun h => _, fun h t ht hst =>\n        finset.eq_of_subset_of_card_le hst <| le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) two_pos⟩\n    suffices s.disj_union (s.map ⟨compl, compl_injective⟩) hs.disjoint_map_compl = finset.univ by\n      rw [fintype.card, ← this, two_mul, card_disj_union, card_map]\n    rw [← coe_eq_univ, disj_union_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,\n      image_eq_preimage_of_inverse compl_compl compl_compl]\n    refine' eq_univ_of_forall fun a => _\n    simp_rw [mem_union, mem_preimage]\n    by_contra' ha\n    refine' s.ne_insert_of_not_mem _ ha.1 (h _ _ <| s.subset_insert _)\n    rw [coe_insert]\n    refine' hs.insert _ fun b hb hab => ha.2 <| (hs.is_upper_set' h) hab.le_compl_left hb\n    rintro rfl\n    have :=\n      h {«expr⊤»}\n        (by\n          rw [coe_singleton]\n          exact intersecting_singleton.2 top_ne_bot)\n    rw [compl_bot] at ha\n    rw [coe_eq_empty.1 ((hs.is_upper_set' h).not_top_mem.1 ha.2)] at this\n    exact Finset.singleton_ne_empty _ (this <| empty_subset _).symm\n#align intersecting.is_max_iff_card_eq intersecting.is_max_iff_card_eq\n\n",
 "intersecting_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem intersecting_singleton : ({a} : set α).intersecting ↔ a ≠ «expr⊥» := by simp [intersecting]\n#align intersecting_singleton intersecting_singleton\n\n",
 "intersecting_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem intersecting_insert : (insert a s).intersecting ↔ s.intersecting ∧ a ≠ «expr⊥» ∧ ∀ b ∈ s, ¬Disjoint a b :=\n  ⟨fun h =>\n    ⟨h.mono <| subset_insert _ _, h.ne_bot <| mem_insert _ _, fun b hb => h (mem_insert _ _) <| mem_insert_of_mem _ hb⟩,\n    fun h => h.1.insert h.2.1 h.2.2⟩\n#align intersecting_insert intersecting_insert\n\n",
 "intersecting_iff_pairwise_not_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem intersecting_iff_pairwise_not_disjoint :\n    s.intersecting ↔ (s.pairwise fun a b => ¬Disjoint a b) ∧ s ≠ {«expr⊥»} :=\n  by\n  refine' ⟨fun h => ⟨fun a ha b hb _ => h ha hb, _⟩, fun h a ha b hb hab => _⟩\n  · rintro rfl\n    exact intersecting_singleton.1 h rfl\n  · have := h.1.eq ha hb (not_not.2 hab)\n    rw [this, disjoint_self] at hab\n    rw [hab] at hb\n    exact h.2 (eq_singleton_iff_unique_mem.2 ⟨hb, fun c hc => not_ne_iff.1 fun H => h.1 hb hc H.symm disjoint_bot_left⟩)\n#align intersecting_iff_pairwise_not_disjoint intersecting_iff_pairwise_not_disjoint\n\n",
 "intersecting_iff_eq_empty_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem intersecting_iff_eq_empty_of_subsingleton [subsingleton α] (s : set α) : s.intersecting ↔ s = ∅ :=\n  by\n  refine'\n    subsingleton_of_subsingleton.intersecting.trans\n      ⟨not_imp_comm.2 fun h => subsingleton_of_subsingleton.eq_singleton_of_mem _, _⟩\n  · obtain ⟨a, ha⟩ := nonempty_iff_ne_empty.2 h\n    rwa [subsingleton.elim («expr⊥») a]\n  · rintro rfl\n    exact (Set.singleton_nonempty _).ne_empty.symm\n#align intersecting_iff_eq_empty_of_subsingleton intersecting_iff_eq_empty_of_subsingleton\n\n",
 "intersecting_empty":
 "theorem intersecting_empty : (∅ : set α).intersecting := fun _ => false.elim\n#align intersecting_empty intersecting_empty\n\n",
 "intersecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\nprotected theorem subsingleton.intersecting (hs : s.subsingleton) : s.intersecting ↔ s ≠ {«expr⊥»} :=\n  intersecting_iff_pairwise_not_disjoint.trans <| and_iff_right <| hs.pairwise _\n#align subsingleton.intersecting subsingleton.intersecting\n\n",
 "insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem intersecting.insert (hs : s.intersecting) (ha : a ≠ «expr⊥») (h : ∀ b ∈ s, ¬Disjoint a b) :\n    (insert a s).intersecting := by\n  rintro b (rfl | hb) c (rfl | hc)\n  · rwa [disjoint_self]\n  · exact h _ hc\n  · exact fun H => h _ hb H.symm\n  · exact hs hb hc\n#align intersecting.insert intersecting.insert\n\n",
 "exists_mem_set":
 "theorem intersecting.exists_mem_set {𝒜 : set (set α)} (h𝒜 : 𝒜.intersecting) {s t : set α} (hs : s ∈ 𝒜) (ht : t ∈ 𝒜) :\n    ∃ a, a ∈ s ∧ a ∈ t :=\n  not_disjoint_iff.1 <| h𝒜 hs ht\n#align intersecting.exists_mem_set intersecting.exists_mem_set\n\n",
 "exists_mem_finset":
 "theorem intersecting.exists_mem_finset [decidable_eq α] {𝒜 : set (Finset α)} (h𝒜 : 𝒜.intersecting) {s t : Finset α}\n    (hs : s ∈ 𝒜) (ht : t ∈ 𝒜) : ∃ a, a ∈ s ∧ a ∈ t :=\n  not_disjoint_iff.1 <| disjoint_coe.not.2 <| h𝒜 hs ht\n#align intersecting.exists_mem_finset intersecting.exists_mem_finset\n\n",
 "exists_card_eq":
 "theorem intersecting.exists_card_eq (hs : (s : set α).intersecting) :\n    ∃ t, s ⊆ t ∧ 2 * t.card = fintype.card α ∧ (t : set α).intersecting :=\n  by\n  have := hs.card_le\n  rw [mul_comm, ← Nat.le_div_iff_mul_le' two_pos] at this\n  revert hs\n  refine' s.strong_downward_induction_on _ this\n  rintro s ih hcard hs\n  by_cases ∀ t : Finset α, (t : set α).intersecting → s ⊆ t → s = t\n  · exact ⟨s, subset.rfl, hs.is_max_iff_card_eq.1 h, hs⟩\n  push_neg  at h\n  obtain ⟨t, ht, hst⟩ := h\n  refine' (ih _ (_root_.ssubset_iff_subset_ne.2 hst) ht).imp fun u => and.imp_left hst.1.trans\n  rw [Nat.le_div_iff_mul_le' two_pos, mul_comm]\n  exact ht.card_le\n#align intersecting.exists_card_eq intersecting.exists_card_eq\n\n",
 "disjoint_map_compl":
 "theorem intersecting.disjoint_map_compl {s : Finset α} (hs : (s : set α).intersecting) :\n    Disjoint s (s.map ⟨compl, compl_injective⟩) :=\n  by\n  rw [Finset.disjoint_left]\n  rintro x hx hxc\n  obtain ⟨x, hx', rfl⟩ := mem_map.mp hxc\n  exact hs.not_compl_mem hx' hx\n#align intersecting.disjoint_map_compl intersecting.disjoint_map_compl\n\n",
 "card_le":
 "theorem intersecting.card_le [fintype α] {s : Finset α} (hs : (s : set α).intersecting) : 2 * s.card ≤ fintype.card α :=\n  by\n  classical\n    refine' (s.disj_union _ hs.disjoint_map_compl).card_le_univ.trans_eq' _\n    rw [two_mul, card_disj_union, card_map]\n#align intersecting.card_le intersecting.card_le\n\n"}