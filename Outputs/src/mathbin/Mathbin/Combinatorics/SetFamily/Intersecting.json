{"not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem intersecting.not_mem {s : set Î±} (hs : s.intersecting) {a : Î±} (ha : Â«expr á¶œÂ» a âˆˆ s) : a âˆ‰ s := fun h =>\n  hs ha h disjoint_compl_left\n#align intersecting.not_mem intersecting.not_mem\n\n",
 "not_compl_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem intersecting.not_compl_mem {s : set Î±} (hs : s.intersecting) {a : Î±} (ha : a âˆˆ s) : Â«expr á¶œÂ» a âˆ‰ s := fun h =>\n  hs ha h disjoint_compl_right\n#align intersecting.not_compl_mem intersecting.not_compl_mem\n\n",
 "not_bot_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem intersecting.not_bot_mem (hs : s.intersecting) : Â«exprâŠ¥Â» âˆ‰ s := fun h => hs h h disjoint_bot_left\n#align intersecting.not_bot_mem intersecting.not_bot_mem\n\n",
 "ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem intersecting.ne_bot (hs : s.intersecting) (ha : a âˆˆ s) : a â‰  Â«exprâŠ¥Â» :=\n  ne_of_mem_of_not_mem ha hs.not_bot_mem\n#align intersecting.ne_bot intersecting.ne_bot\n\n",
 "mono":
 "/-\nCopyright (c) 2022 YaÃ«l Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies\n-/\n@[mono]\ntheorem intersecting.mono (h : t âŠ† s) (hs : s.intersecting) : t.intersecting := fun a ha b hb => hs (h ha) (h hb)\n#align intersecting.mono intersecting.mono\n\n",
 "is_upper_set'":
 "/-- Maximal intersecting families are upper sets. Finset version. -/\ntheorem intersecting.is_upper_set' {s : Finset Î±} (hs : (s : set Î±).intersecting)\n    (h : âˆ€ t : Finset Î±, (t : set Î±).intersecting â†’ s âŠ† t â†’ s = t) : is_upper_set (s : set Î±) := by\n  classical\n    rintro a b hab ha\n    rw [h (insert b s) _ (Finset.subset_insert _ _)]\n    Â· exact mem_insert_self _ _\n    rw [coe_insert]\n    exact hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n#align intersecting.is_upper_set' intersecting.is_upper_set'\n\n",
 "is_upper_set":
 "/-- Maximal intersecting families are upper sets. -/\nprotected theorem intersecting.is_upper_set (hs : s.intersecting) (h : âˆ€ t : set Î±, t.intersecting â†’ s âŠ† t â†’ s = t) :\n    is_upper_set s := by\n  classical\n    rintro a b hab ha\n    rw [h (insert b s) _ (subset_insert _ _)]\n    Â· exact mem_insert _ _\n    exact hs.insert (mt (eq_bot_mono hab) <| hs.ne_bot ha) fun c hc hbc => hs ha hc <| hbc.mono_left hab\n#align intersecting.is_upper_set intersecting.is_upper_set\n\n",
 "is_max_iff_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n-- Note, this lemma is false when `Î±` has exactly one element and boring when `Î±` is empty.\ntheorem intersecting.is_max_iff_card_eq (hs : (s : set Î±).intersecting) :\n    (âˆ€ t : Finset Î±, (t : set Î±).intersecting â†’ s âŠ† t â†’ s = t) â†” 2 * s.card = fintype.card Î± := by\n  classical\n    refine'\n      âŸ¨fun h => _, fun h t ht hst =>\n        finset.eq_of_subset_of_card_le hst <| le_of_mul_le_mul_left (ht.card_le.trans_eq h.symm) two_posâŸ©\n    suffices s.disj_union (s.map âŸ¨compl, compl_injectiveâŸ©) hs.disjoint_map_compl = finset.univ by\n      rw [fintype.card, â† this, two_mul, card_disj_union, card_map]\n    rw [â† coe_eq_univ, disj_union_eq_union, coe_union, coe_map, Function.Embedding.coeFn_mk,\n      image_eq_preimage_of_inverse compl_compl compl_compl]\n    refine' eq_univ_of_forall fun a => _\n    simp_rw [mem_union, mem_preimage]\n    by_contra' ha\n    refine' s.ne_insert_of_not_mem _ ha.1 (h _ _ <| s.subset_insert _)\n    rw [coe_insert]\n    refine' hs.insert _ fun b hb hab => ha.2 <| (hs.is_upper_set' h) hab.le_compl_left hb\n    rintro rfl\n    have :=\n      h {Â«exprâŠ¤Â»}\n        (by\n          rw [coe_singleton]\n          exact intersecting_singleton.2 top_ne_bot)\n    rw [compl_bot] at ha\n    rw [coe_eq_empty.1 ((hs.is_upper_set' h).not_top_mem.1 ha.2)] at this\n    exact Finset.singleton_ne_empty _ (this <| empty_subset _).symm\n#align intersecting.is_max_iff_card_eq intersecting.is_max_iff_card_eq\n\n",
 "intersecting_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n@[simp]\ntheorem intersecting_singleton : ({a} : set Î±).intersecting â†” a â‰  Â«exprâŠ¥Â» := by simp [intersecting]\n#align intersecting_singleton intersecting_singleton\n\n",
 "intersecting_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem intersecting_insert : (insert a s).intersecting â†” s.intersecting âˆ§ a â‰  Â«exprâŠ¥Â» âˆ§ âˆ€ b âˆˆ s, Â¬Disjoint a b :=\n  âŸ¨fun h =>\n    âŸ¨h.mono <| subset_insert _ _, h.ne_bot <| mem_insert _ _, fun b hb => h (mem_insert _ _) <| mem_insert_of_mem _ hbâŸ©,\n    fun h => h.1.insert h.2.1 h.2.2âŸ©\n#align intersecting_insert intersecting_insert\n\n",
 "intersecting_iff_pairwise_not_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem intersecting_iff_pairwise_not_disjoint :\n    s.intersecting â†” (s.pairwise fun a b => Â¬Disjoint a b) âˆ§ s â‰  {Â«exprâŠ¥Â»} :=\n  by\n  refine' âŸ¨fun h => âŸ¨fun a ha b hb _ => h ha hb, _âŸ©, fun h a ha b hb hab => _âŸ©\n  Â· rintro rfl\n    exact intersecting_singleton.1 h rfl\n  Â· have := h.1.eq ha hb (not_not.2 hab)\n    rw [this, disjoint_self] at hab\n    rw [hab] at hb\n    exact h.2 (eq_singleton_iff_unique_mem.2 âŸ¨hb, fun c hc => not_ne_iff.1 fun H => h.1 hb hc H.symm disjoint_bot_leftâŸ©)\n#align intersecting_iff_pairwise_not_disjoint intersecting_iff_pairwise_not_disjoint\n\n",
 "intersecting_iff_eq_empty_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem intersecting_iff_eq_empty_of_subsingleton [subsingleton Î±] (s : set Î±) : s.intersecting â†” s = âˆ… :=\n  by\n  refine'\n    subsingleton_of_subsingleton.intersecting.trans\n      âŸ¨not_imp_comm.2 fun h => subsingleton_of_subsingleton.eq_singleton_of_mem _, _âŸ©\n  Â· obtain âŸ¨a, haâŸ© := nonempty_iff_ne_empty.2 h\n    rwa [subsingleton.elim (Â«exprâŠ¥Â») a]\n  Â· rintro rfl\n    exact (Set.singleton_nonempty _).ne_empty.symm\n#align intersecting_iff_eq_empty_of_subsingleton intersecting_iff_eq_empty_of_subsingleton\n\n",
 "intersecting_empty":
 "theorem intersecting_empty : (âˆ… : set Î±).intersecting := fun _ => false.elim\n#align intersecting_empty intersecting_empty\n\n",
 "intersecting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\nprotected theorem subsingleton.intersecting (hs : s.subsingleton) : s.intersecting â†” s â‰  {Â«exprâŠ¥Â»} :=\n  intersecting_iff_pairwise_not_disjoint.trans <| and_iff_right <| hs.pairwise _\n#align subsingleton.intersecting subsingleton.intersecting\n\n",
 "insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem intersecting.insert (hs : s.intersecting) (ha : a â‰  Â«exprâŠ¥Â») (h : âˆ€ b âˆˆ s, Â¬Disjoint a b) :\n    (insert a s).intersecting := by\n  rintro b (rfl | hb) c (rfl | hc)\n  Â· rwa [disjoint_self]\n  Â· exact h _ hc\n  Â· exact fun H => h _ hb H.symm\n  Â· exact hs hb hc\n#align intersecting.insert intersecting.insert\n\n",
 "exists_mem_set":
 "theorem intersecting.exists_mem_set {ğ’œ : set (set Î±)} (hğ’œ : ğ’œ.intersecting) {s t : set Î±} (hs : s âˆˆ ğ’œ) (ht : t âˆˆ ğ’œ) :\n    âˆƒ a, a âˆˆ s âˆ§ a âˆˆ t :=\n  not_disjoint_iff.1 <| hğ’œ hs ht\n#align intersecting.exists_mem_set intersecting.exists_mem_set\n\n",
 "exists_mem_finset":
 "theorem intersecting.exists_mem_finset [decidable_eq Î±] {ğ’œ : set (Finset Î±)} (hğ’œ : ğ’œ.intersecting) {s t : Finset Î±}\n    (hs : s âˆˆ ğ’œ) (ht : t âˆˆ ğ’œ) : âˆƒ a, a âˆˆ s âˆ§ a âˆˆ t :=\n  not_disjoint_iff.1 <| disjoint_coe.not.2 <| hğ’œ hs ht\n#align intersecting.exists_mem_finset intersecting.exists_mem_finset\n\n",
 "exists_card_eq":
 "theorem intersecting.exists_card_eq (hs : (s : set Î±).intersecting) :\n    âˆƒ t, s âŠ† t âˆ§ 2 * t.card = fintype.card Î± âˆ§ (t : set Î±).intersecting :=\n  by\n  have := hs.card_le\n  rw [mul_comm, â† Nat.le_div_iff_mul_le' two_pos] at this\n  revert hs\n  refine' s.strong_downward_induction_on _ this\n  rintro s ih hcard hs\n  by_cases âˆ€ t : Finset Î±, (t : set Î±).intersecting â†’ s âŠ† t â†’ s = t\n  Â· exact âŸ¨s, subset.rfl, hs.is_max_iff_card_eq.1 h, hsâŸ©\n  push_neg  at h\n  obtain âŸ¨t, ht, hstâŸ© := h\n  refine' (ih _ (_root_.ssubset_iff_subset_ne.2 hst) ht).imp fun u => and.imp_left hst.1.trans\n  rw [Nat.le_div_iff_mul_le' two_pos, mul_comm]\n  exact ht.card_le\n#align intersecting.exists_card_eq intersecting.exists_card_eq\n\n",
 "disjoint_map_compl":
 "theorem intersecting.disjoint_map_compl {s : Finset Î±} (hs : (s : set Î±).intersecting) :\n    Disjoint s (s.map âŸ¨compl, compl_injectiveâŸ©) :=\n  by\n  rw [Finset.disjoint_left]\n  rintro x hx hxc\n  obtain âŸ¨x, hx', rflâŸ© := mem_map.mp hxc\n  exact hs.not_compl_mem hx' hx\n#align intersecting.disjoint_map_compl intersecting.disjoint_map_compl\n\n",
 "card_le":
 "theorem intersecting.card_le [fintype Î±] {s : Finset Î±} (hs : (s : set Î±).intersecting) : 2 * s.card â‰¤ fintype.card Î± :=\n  by\n  classical\n    refine' (s.disj_union _ hs.disjoint_map_compl).card_le_univ.trans_eq' _\n    rw [two_mul, card_disj_union, card_map]\n#align intersecting.card_le intersecting.card_le\n\n"}