{"sup_sdiff_mem_of_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- If `a` is in the family compression and can be compressed, then its compression is in the\noriginal family. -/\ntheorem sup_sdiff_mem_of_mem_compression (ha : a ∈ (uv.compression) u v s) (hva : v ≤ a) (hua : Disjoint u a) :\n    «expr ⊔ » a u \\ v ∈ s :=\n  by\n  rw [mem_compression, compress_of_disjoint_of_le hua hva] at ha\n  obtain ⟨_, ha⟩ | ⟨_, b, hb, rfl⟩ := ha\n  · exact ha\n  have hu : u = «expr⊥» :=\n    by\n    suffices Disjoint u (u \\ v) by rwa [(hua.mono_right hva).sdiff_eq_left, disjoint_self] at this\n    refine' hua.mono_right _\n    rw [← compress_idem, compress_of_disjoint_of_le hua hva]\n    exact sdiff_le_sdiff_right le_sup_right\n  have hv : v = «expr⊥» := by\n    rw [← disjoint_self]\n    apply Disjoint.mono_right hva\n    rw [← compress_idem, compress_of_disjoint_of_le hua hva]\n    exact disjoint_sdiff_self_right\n  rwa [hu, hv, compress_self, sup_bot_eq, sdiff_bot]\n#align sup_sdiff_mem_of_mem_compression sup_sdiff_mem_of_mem_compression\n\n",
 "sup_sdiff_injOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_sdiff_injOn /-\n/-\nCopyright (c) 2021 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\n/-- UV-compression is injective on the elements it moves. See `uv.compress`. -/\ntheorem sup_sdiff_injOn [GeneralizedBooleanAlgebra α] (u v : α) :\n    { x | Disjoint u x ∧ v ≤ x }.inj_on fun x => «expr ⊔ » x u \\ v :=\n  by\n  rintro a ha b hb hab\n  have h : «expr ⊔ » ((«expr ⊔ » a u \\ v) \\ u) v = «expr ⊔ » ((«expr ⊔ » b u \\ v) \\ u) v :=\n    by\n    dsimp at hab\n    rw [hab]\n  rwa [sdiff_sdiff_comm, ha.1.symm.sup_sdiff_cancel_right, sdiff_sdiff_comm, hb.1.symm.sup_sdiff_cancel_right,\n    sdiff_sup_cancel ha.2, sdiff_sup_cancel hb.2] at h\n#align sup_sdiff_inj_on sup_sdiff_injOn\n-/\n\n",
 "mem_of_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `a` is in the `u, v`-compression but `v ≤ a`, then `a` must have been in the original\nfamily. -/\ntheorem mem_of_mem_compression (ha : a ∈ (uv.compression) u v s) (hva : v ≤ a) (hvu : v = «expr⊥» → u = «expr⊥») :\n    a ∈ s := by\n  rw [mem_compression] at ha\n  obtain ha | ⟨_, b, hb, h⟩ := ha\n  · exact ha.1\n  unfold compress at h\n  split_ifs  at h\n  · rw [← h, le_sdiff_iff] at hva\n    rw [hvu hva, hva, sup_bot_eq, sdiff_bot] at h\n    rwa [← h]\n  · rwa [← h]\n#align mem_of_mem_compression mem_of_mem_compression\n\n",
 "mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/-- `a` is in the UV-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression :\n    a ∈ (uv.compression) u v s ↔ a ∈ s ∧ compress u v a ∈ s ∨ a ∉ s ∧ ∃ b ∈ s, compress u v b = a := by\n  simp_rw [compression, mem_union, mem_filter, mem_image, and_comm' (a ∉ s)]\n#align mem_compression mem_compression\n\n",
 "is_compressed_self":
 "/-- Any family is compressed along two identical elements. -/\ntheorem is_compressed_self (u : α) (s : Finset α) : IsCompressed u u s :=\n  compression_self u s\n#align is_compressed_self is_compressed_self\n\n",
 "compression_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n@[simp]\ntheorem compression_self (u : α) (s : Finset α) : (uv.compression) u u s = s :=\n  by\n  unfold compression\n  convert union_empty s\n  · ext a\n    rw [mem_filter, compress_self, and_self_iff]\n  · refine' eq_empty_of_forall_not_mem fun a ha => _\n    simp_rw [mem_filter, mem_image, compress_self] at ha\n    obtain ⟨⟨b, hb, rfl⟩, hb'⟩ := ha\n    exact hb' hb\n#align compression_self compression_self\n\n",
 "compression_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/-- Compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (u v : α) (s : Finset α) :\n    (uv.compression) u v ((uv.compression) u v s) = (uv.compression) u v s :=\n  by\n  have h : Filter (fun a => compress u v a ∉ (uv.compression) u v s) ((uv.compression) u v s) = ∅ :=\n    filter_false_of_mem fun a ha h => h <| compress_mem_compression_of_mem_compression ha\n  rw [compression, image_filter, h, image_empty, ← h]\n  exact filter_union_filter_neg_eq _ (compression u v s)\n#align compression_idem compression_idem\n\n",
 "compress_self":
 "@[simp]\ntheorem compress_self (u a : α) : compress u u a = a :=\n  by\n  unfold compress\n  split_ifs\n  · exact h.1.symm.sup_sdiff_cancel_right\n  · rfl\n#align compress_self compress_self\n\n",
 "compress_of_disjoint_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n-- The namespace is here to distinguish from other compressions.\ntheorem compress_of_disjoint_of_le (hua : Disjoint u a) (hva : v ≤ a) : compress u v a = «expr ⊔ » a u \\ v :=\n  if_pos ⟨hua, hva⟩\n#align compress_of_disjoint_of_le compress_of_disjoint_of_le\n\n",
 "compress_mem_compression_of_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n-- This is a special case of `compress_mem_compression` once we have `compression_idem`.\ntheorem compress_mem_compression_of_mem_compression (ha : a ∈ (uv.compression) u v s) :\n    compress u v a ∈ (uv.compression) u v s :=\n  by\n  rw [mem_compression] at ha⊢\n  simp only [compress_idem, exists_prop]\n  obtain ⟨_, ha⟩ | ⟨_, b, hb, rfl⟩ := ha\n  · exact or.inl ⟨ha, ha⟩\n  · exact or.inr ⟨by rwa [compress_idem], b, hb, (compress_idem _ _ _).symm⟩\n#align compress_mem_compression_of_mem_compression compress_mem_compression_of_mem_compression\n\n",
 "compress_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\ntheorem compress_mem_compression (ha : a ∈ s) : compress u v a ∈ (uv.compression) u v s :=\n  by\n  rw [mem_compression]\n  by_cases compress u v a ∈ s\n  · rw [compress_idem]\n    exact or.inl ⟨h, h⟩\n  · exact or.inr ⟨h, a, ha, rfl⟩\n#align compress_mem_compression compress_mem_compression\n\n",
 "compress_idem":
 "/-- Compressing an element is idempotent. -/\n@[simp]\ntheorem compress_idem (u v a : α) : compress u v (compress u v a) = compress u v a :=\n  by\n  unfold compress\n  split_ifs with h h'\n  · rw [le_sdiff_iff.1 h'.2, sdiff_bot, sdiff_bot, sup_assoc, sup_idem]\n  · rfl\n  · rfl\n#align compress_idem compress_idem\n\n",
 "compress_disjoint":
 "theorem compress_disjoint (u v : α) :\n    Disjoint (s.filter fun a => compress u v a ∈ s) ((s.image <| compress u v).filter fun a => a ∉ s) :=\n  disjoint_left.2 fun a ha₁ ha₂ => (mem_filter.1 ha₂).2 (mem_filter.1 ha₁).1\n#align compress_disjoint compress_disjoint\n\n",
 "card_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `uv.compression -/\n/-- Compressing a family doesn't change its size. -/\ntheorem card_compression (u v : α) (s : Finset α) : ((uv.compression) u v s).card = s.card :=\n  by\n  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_inj_on, ←\n    card_disjoint_union, filter_union_filter_neg_eq]\n  · rw [disjoint_iff_inter_eq_empty]\n    exact filter_inter_filter_neg_eq _ _ _\n  intro a ha b hb hab\n  dsimp at hab\n  rw [mem_coe, mem_filter, Function.comp_apply] at ha hb\n  rw [compress] at ha hab\n  split_ifs  at ha hab with has\n  · rw [compress] at hb hab\n    split_ifs  at hb hab with hbs\n    · exact sup_sdiff_injOn u v has hbs hab\n    · exact (hb.2 hb.1).elim\n  · exact (ha.2 ha.1).elim\n#align card_compression card_compression\n\n",
 "card_compress":
 "/-- Compressing a finset doesn't change its size. -/\ntheorem card_compress (hUV : U.card = V.card) (A : Finset α) : (compress U V A).card = A.card :=\n  by\n  unfold compress\n  split_ifs\n  · rw [card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_disjoint_union h.1.symm, hUV, add_tsub_cancel_right]\n  · rfl\n#align card_compress card_compress\n\n"}