{"non_member_subfamily_union":
 "theorem non_member_subfamily_union (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∪ ℬ).non_member_subfamily a = 𝒜.non_member_subfamily a ∪ ℬ.non_member_subfamily a :=\n  filter_union _ _ _\n#align non_member_subfamily_union non_member_subfamily_union\n\n",
 "non_member_subfamily_non_member_subfamily":
 "@[simp]\ntheorem non_member_subfamily_non_member_subfamily :\n    (𝒜.non_member_subfamily a).non_member_subfamily a = 𝒜.non_member_subfamily a :=\n  by\n  ext\n  simp\n#align non_member_subfamily_non_member_subfamily non_member_subfamily_non_member_subfamily\n\n",
 "non_member_subfamily_member_subfamily":
 "@[simp]\ntheorem non_member_subfamily_member_subfamily : (𝒜.member_subfamily a).non_member_subfamily a = 𝒜.member_subfamily a :=\n  by\n  ext\n  simp\n#align non_member_subfamily_member_subfamily non_member_subfamily_member_subfamily\n\n",
 "non_member_subfamily_inter":
 "theorem non_member_subfamily_inter (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∩ ℬ).non_member_subfamily a = 𝒜.non_member_subfamily a ∩ ℬ.non_member_subfamily a :=\n  filter_inter_distrib _ _ _\n#align non_member_subfamily_inter non_member_subfamily_inter\n\n",
 "member_subfamily_union_non_member_subfamily":
 "theorem member_subfamily_union_non_member_subfamily (a : α) (𝒜 : Finset (Finset α)) :\n    𝒜.member_subfamily a ∪ 𝒜.non_member_subfamily a = 𝒜.image fun s => s.erase a :=\n  by\n  ext s\n  simp only [mem_union, mem_member_subfamily, mem_non_member_subfamily, mem_image, exists_prop]\n  constructor\n  · rintro (h | h)\n    · exact ⟨_, h.1, erase_insert h.2⟩\n    · exact ⟨_, h.1, erase_eq_of_not_mem h.2⟩\n  · rintro ⟨s, hs, rfl⟩\n    by_cases ha : a ∈ s\n    · exact or.inl ⟨by rwa [insert_erase ha], not_mem_erase _ _⟩\n    · exact or.inr ⟨by rwa [erase_eq_of_not_mem ha], not_mem_erase _ _⟩\n#align member_subfamily_union_non_member_subfamily member_subfamily_union_non_member_subfamily\n\n",
 "member_subfamily_union":
 "theorem member_subfamily_union (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∪ ℬ).member_subfamily a = 𝒜.member_subfamily a ∪ ℬ.member_subfamily a := by\n  simp_rw [member_subfamily, filter_union, image_union]\n#align member_subfamily_union member_subfamily_union\n\n",
 "member_subfamily_non_member_subfamily":
 "@[simp]\ntheorem member_subfamily_non_member_subfamily : (𝒜.non_member_subfamily a).member_subfamily a = ∅ :=\n  by\n  ext\n  simp\n#align member_subfamily_non_member_subfamily member_subfamily_non_member_subfamily\n\n",
 "member_subfamily_member_subfamily":
 "@[simp]\ntheorem member_subfamily_member_subfamily : (𝒜.member_subfamily a).member_subfamily a = ∅ :=\n  by\n  ext\n  simp\n#align member_subfamily_member_subfamily member_subfamily_member_subfamily\n\n",
 "member_subfamily_inter":
 "theorem member_subfamily_inter (a : α) (𝒜 ℬ : Finset (Finset α)) :\n    (𝒜 ∩ ℬ).member_subfamily a = 𝒜.member_subfamily a ∩ ℬ.member_subfamily a :=\n  by\n  unfold member_subfamily\n  rw [filter_inter_distrib, image_inter_of_inj_on _ _ ((erase_inj_on' _).mono _)]\n  rw [← coe_union, ← filter_union, coe_filter]\n  exact Set.inter_subset_right _ _\n#align member_subfamily_inter member_subfamily_inter\n\n",
 "mem_non_member_subfamily":
 "/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\n@[simp]\ntheorem mem_non_member_subfamily : s ∈ 𝒜.non_member_subfamily a ↔ s ∈ 𝒜 ∧ a ∉ s :=\n  mem_filter\n#align mem_non_member_subfamily mem_non_member_subfamily\n\n",
 "mem_member_subfamily":
 "@[simp]\ntheorem mem_member_subfamily : s ∈ 𝒜.member_subfamily a ↔ insert a s ∈ 𝒜 ∧ a ∉ s :=\n  by\n  simp_rw [member_subfamily, mem_image, mem_filter]\n  refine' ⟨_, fun h => ⟨insert a s, ⟨h.1, mem_insert_self _ _⟩, erase_insert h.2⟩⟩\n  rintro ⟨s, hs, rfl⟩\n  rw [insert_erase hs.2]\n  exact ⟨hs.1, not_mem_erase _ _⟩\n#align mem_member_subfamily mem_member_subfamily\n\n",
 "mem_compression_of_insert_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\ntheorem mem_compression_of_insert_mem_compression (h : insert a s ∈ (down.compression) a 𝒜) :\n    s ∈ (down.compression) a 𝒜 := by\n  by_cases ha : a ∈ s\n  · rwa [insert_eq_of_mem ha] at h\n  · rw [← erase_insert ha]\n    exact erase_mem_compression_of_mem_compression h\n#align mem_compression_of_insert_mem_compression mem_compression_of_insert_mem_compression\n\n",
 "mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n-- The namespace is here to distinguish from other compressions.\n/-- `a` is in the down-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression : s ∈ (down.compression) a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 :=\n  by\n  simp_rw [compression, mem_disj_union, mem_filter, mem_image, and_comm' (s ∉ 𝒜)]\n  refine'\n    or_congr_right\n      (and_congr_left fun hs => ⟨_, fun h => ⟨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hs⟩⟩)\n  rintro ⟨t, ht, rfl⟩\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]\n#align mem_compression mem_compression\n\n",
 "erase_mem_compression_of_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n-- This is a special case of `erase_mem_compression` once we have `compression_idem`.\ntheorem erase_mem_compression_of_mem_compression : s ∈ (down.compression) a 𝒜 → s.erase a ∈ (down.compression) a 𝒜 :=\n  by\n  simp_rw [mem_compression, erase_idem]\n  refine' Or.imp (fun h => ⟨h.2, h.2⟩) fun h => _\n  rwa [erase_eq_of_not_mem (insert_ne_self.1 <| ne_of_mem_of_not_mem h.2 h.1)]\n#align erase_mem_compression_of_mem_compression erase_mem_compression_of_mem_compression\n\n",
 "erase_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\ntheorem erase_mem_compression (hs : s ∈ 𝒜) : s.erase a ∈ (down.compression) a 𝒜 :=\n  by\n  simp_rw [mem_compression, erase_idem, and_self_iff]\n  refine' (em _).imp_right fun h => ⟨h, _⟩\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem hs h).symm)]\n#align erase_mem_compression erase_mem_compression\n\n",
 "compression_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/-- Down-compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (a : α) (𝒜 : Finset (Finset α)) :\n    (down.compression) a ((down.compression) a 𝒜) = (down.compression) a 𝒜 :=\n  by\n  ext s\n  refine' mem_compression.trans ⟨_, fun h => or.inl ⟨h, erase_mem_compression_of_mem_compression h⟩⟩\n  rintro (h | h)\n  · exact h.1\n  · cases h.1 (mem_compression_of_insert_mem_compression h.2)\n#align compression_idem compression_idem\n\n",
 "card_member_subfamily_add_card_non_member_subfamily":
 "theorem card_member_subfamily_add_card_non_member_subfamily (a : α) (𝒜 : Finset (Finset α)) :\n    (𝒜.member_subfamily a).card + (𝒜.non_member_subfamily a).card = 𝒜.card :=\n  by\n  rw [member_subfamily, non_member_subfamily, card_image_of_inj_on, filter_card_add_filter_neg_card_eq_card]\n  exact (erase_inj_on' _).mono fun s hs => (mem_filter.1 hs).2\n#align card_member_subfamily_add_card_non_member_subfamily card_member_subfamily_add_card_non_member_subfamily\n\n",
 "card_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/-- Down-compressing a family doesn't change its size. -/\n@[simp]\ntheorem card_compression (a : α) (𝒜 : Finset (Finset α)) : ((down.compression) a 𝒜).card = 𝒜.card :=\n  by\n  rw [compression, card_disj_union, image_filter, card_image_of_inj_on ((erase_inj_on' _).mono fun s hs => _), ←\n    card_disjoint_union, filter_union_filter_neg_eq]\n  · exact disjoint_filter_filter_neg _ _ _\n  rw [mem_coe, mem_filter] at hs\n  exact not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm\n#align card_compression card_compression\n\n"}