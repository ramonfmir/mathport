{"non_member_subfamily_union":
 "theorem non_member_subfamily_union (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆª â„¬).non_member_subfamily a = ğ’œ.non_member_subfamily a âˆª â„¬.non_member_subfamily a :=\n  filter_union _ _ _\n#align non_member_subfamily_union non_member_subfamily_union\n\n",
 "non_member_subfamily_non_member_subfamily":
 "@[simp]\ntheorem non_member_subfamily_non_member_subfamily :\n    (ğ’œ.non_member_subfamily a).non_member_subfamily a = ğ’œ.non_member_subfamily a :=\n  by\n  ext\n  simp\n#align non_member_subfamily_non_member_subfamily non_member_subfamily_non_member_subfamily\n\n",
 "non_member_subfamily_member_subfamily":
 "@[simp]\ntheorem non_member_subfamily_member_subfamily : (ğ’œ.member_subfamily a).non_member_subfamily a = ğ’œ.member_subfamily a :=\n  by\n  ext\n  simp\n#align non_member_subfamily_member_subfamily non_member_subfamily_member_subfamily\n\n",
 "non_member_subfamily_inter":
 "theorem non_member_subfamily_inter (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆ© â„¬).non_member_subfamily a = ğ’œ.non_member_subfamily a âˆ© â„¬.non_member_subfamily a :=\n  filter_inter_distrib _ _ _\n#align non_member_subfamily_inter non_member_subfamily_inter\n\n",
 "member_subfamily_union_non_member_subfamily":
 "theorem member_subfamily_union_non_member_subfamily (a : Î±) (ğ’œ : Finset (Finset Î±)) :\n    ğ’œ.member_subfamily a âˆª ğ’œ.non_member_subfamily a = ğ’œ.image fun s => s.erase a :=\n  by\n  ext s\n  simp only [mem_union, mem_member_subfamily, mem_non_member_subfamily, mem_image, exists_prop]\n  constructor\n  Â· rintro (h | h)\n    Â· exact âŸ¨_, h.1, erase_insert h.2âŸ©\n    Â· exact âŸ¨_, h.1, erase_eq_of_not_mem h.2âŸ©\n  Â· rintro âŸ¨s, hs, rflâŸ©\n    by_cases ha : a âˆˆ s\n    Â· exact or.inl âŸ¨by rwa [insert_erase ha], not_mem_erase _ _âŸ©\n    Â· exact or.inr âŸ¨by rwa [erase_eq_of_not_mem ha], not_mem_erase _ _âŸ©\n#align member_subfamily_union_non_member_subfamily member_subfamily_union_non_member_subfamily\n\n",
 "member_subfamily_union":
 "theorem member_subfamily_union (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆª â„¬).member_subfamily a = ğ’œ.member_subfamily a âˆª â„¬.member_subfamily a := by\n  simp_rw [member_subfamily, filter_union, image_union]\n#align member_subfamily_union member_subfamily_union\n\n",
 "member_subfamily_non_member_subfamily":
 "@[simp]\ntheorem member_subfamily_non_member_subfamily : (ğ’œ.non_member_subfamily a).member_subfamily a = âˆ… :=\n  by\n  ext\n  simp\n#align member_subfamily_non_member_subfamily member_subfamily_non_member_subfamily\n\n",
 "member_subfamily_member_subfamily":
 "@[simp]\ntheorem member_subfamily_member_subfamily : (ğ’œ.member_subfamily a).member_subfamily a = âˆ… :=\n  by\n  ext\n  simp\n#align member_subfamily_member_subfamily member_subfamily_member_subfamily\n\n",
 "member_subfamily_inter":
 "theorem member_subfamily_inter (a : Î±) (ğ’œ â„¬ : Finset (Finset Î±)) :\n    (ğ’œ âˆ© â„¬).member_subfamily a = ğ’œ.member_subfamily a âˆ© â„¬.member_subfamily a :=\n  by\n  unfold member_subfamily\n  rw [filter_inter_distrib, image_inter_of_inj_on _ _ ((erase_inj_on' _).mono _)]\n  rw [â† coe_union, â† filter_union, coe_filter]\n  exact Set.inter_subset_right _ _\n#align member_subfamily_inter member_subfamily_inter\n\n",
 "mem_non_member_subfamily":
 "/-\nCopyright (c) 2022 YaÃ«l Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies\n-/\n@[simp]\ntheorem mem_non_member_subfamily : s âˆˆ ğ’œ.non_member_subfamily a â†” s âˆˆ ğ’œ âˆ§ a âˆ‰ s :=\n  mem_filter\n#align mem_non_member_subfamily mem_non_member_subfamily\n\n",
 "mem_member_subfamily":
 "@[simp]\ntheorem mem_member_subfamily : s âˆˆ ğ’œ.member_subfamily a â†” insert a s âˆˆ ğ’œ âˆ§ a âˆ‰ s :=\n  by\n  simp_rw [member_subfamily, mem_image, mem_filter]\n  refine' âŸ¨_, fun h => âŸ¨insert a s, âŸ¨h.1, mem_insert_self _ _âŸ©, erase_insert h.2âŸ©âŸ©\n  rintro âŸ¨s, hs, rflâŸ©\n  rw [insert_erase hs.2]\n  exact âŸ¨hs.1, not_mem_erase _ _âŸ©\n#align mem_member_subfamily mem_member_subfamily\n\n",
 "mem_compression_of_insert_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\ntheorem mem_compression_of_insert_mem_compression (h : insert a s âˆˆ (down.compression) a ğ’œ) :\n    s âˆˆ (down.compression) a ğ’œ := by\n  by_cases ha : a âˆˆ s\n  Â· rwa [insert_eq_of_mem ha] at h\n  Â· rw [â† erase_insert ha]\n    exact erase_mem_compression_of_mem_compression h\n#align mem_compression_of_insert_mem_compression mem_compression_of_insert_mem_compression\n\n",
 "mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n-- The namespace is here to distinguish from other compressions.\n/-- `a` is in the down-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression : s âˆˆ (down.compression) a ğ’œ â†” s âˆˆ ğ’œ âˆ§ s.erase a âˆˆ ğ’œ âˆ¨ s âˆ‰ ğ’œ âˆ§ insert a s âˆˆ ğ’œ :=\n  by\n  simp_rw [compression, mem_disj_union, mem_filter, mem_image, and_comm' (s âˆ‰ ğ’œ)]\n  refine'\n    or_congr_right\n      (and_congr_left fun hs => âŸ¨_, fun h => âŸ¨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hsâŸ©âŸ©)\n  rintro âŸ¨t, ht, rflâŸ©\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]\n#align mem_compression mem_compression\n\n",
 "erase_mem_compression_of_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n-- This is a special case of `erase_mem_compression` once we have `compression_idem`.\ntheorem erase_mem_compression_of_mem_compression : s âˆˆ (down.compression) a ğ’œ â†’ s.erase a âˆˆ (down.compression) a ğ’œ :=\n  by\n  simp_rw [mem_compression, erase_idem]\n  refine' Or.imp (fun h => âŸ¨h.2, h.2âŸ©) fun h => _\n  rwa [erase_eq_of_not_mem (insert_ne_self.1 <| ne_of_mem_of_not_mem h.2 h.1)]\n#align erase_mem_compression_of_mem_compression erase_mem_compression_of_mem_compression\n\n",
 "erase_mem_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\ntheorem erase_mem_compression (hs : s âˆˆ ğ’œ) : s.erase a âˆˆ (down.compression) a ğ’œ :=\n  by\n  simp_rw [mem_compression, erase_idem, and_self_iff]\n  refine' (em _).imp_right fun h => âŸ¨h, _âŸ©\n  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem hs h).symm)]\n#align erase_mem_compression erase_mem_compression\n\n",
 "compression_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/-- Down-compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (a : Î±) (ğ’œ : Finset (Finset Î±)) :\n    (down.compression) a ((down.compression) a ğ’œ) = (down.compression) a ğ’œ :=\n  by\n  ext s\n  refine' mem_compression.trans âŸ¨_, fun h => or.inl âŸ¨h, erase_mem_compression_of_mem_compression hâŸ©âŸ©\n  rintro (h | h)\n  Â· exact h.1\n  Â· cases h.1 (mem_compression_of_insert_mem_compression h.2)\n#align compression_idem compression_idem\n\n",
 "card_member_subfamily_add_card_non_member_subfamily":
 "theorem card_member_subfamily_add_card_non_member_subfamily (a : Î±) (ğ’œ : Finset (Finset Î±)) :\n    (ğ’œ.member_subfamily a).card + (ğ’œ.non_member_subfamily a).card = ğ’œ.card :=\n  by\n  rw [member_subfamily, non_member_subfamily, card_image_of_inj_on, filter_card_add_filter_neg_card_eq_card]\n  exact (erase_inj_on' _).mono fun s hs => (mem_filter.1 hs).2\n#align card_member_subfamily_add_card_non_member_subfamily card_member_subfamily_add_card_non_member_subfamily\n\n",
 "card_compression":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `down.compression -/\n/-- Down-compressing a family doesn't change its size. -/\n@[simp]\ntheorem card_compression (a : Î±) (ğ’œ : Finset (Finset Î±)) : ((down.compression) a ğ’œ).card = ğ’œ.card :=\n  by\n  rw [compression, card_disj_union, image_filter, card_image_of_inj_on ((erase_inj_on' _).mono fun s hs => _), â†\n    card_disjoint_union, filter_union_filter_neg_eq]\n  Â· exact disjoint_filter_filter_neg _ _ _\n  rw [mem_coe, mem_filter] at hs\n  exact not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm\n#align card_compression card_compression\n\n"}