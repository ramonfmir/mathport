{"two_lt_point_count":
 "theorem two_lt_point_count [Finite P] [Finite L] (l : L) : 2 < point_count P l := by\n  simpa only [point_count_eq P l, Nat.succ_lt_succ_iff] using one_lt_order P L\n#align two_lt_point_count two_lt_point_count\n\n",
 "two_lt_line_count":
 "theorem two_lt_line_count [Finite P] [Finite L] (p : P) : 2 < line_count L p := by\n  simpa only [line_count_eq L p, Nat.succ_lt_succ_iff] using one_lt_order P L\n#align two_lt_line_count two_lt_line_count\n\n",
 "sum_line_count_eq_sum_point_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n-- If `s < univ`, then consequence of `hs₂`\ntheorem sum_line_count_eq_sum_point_count [fintype P] [fintype L] :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (line_count L p) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (point_count P l) :=\n  by\n  classical\n    simp only [line_count, point_count, nat.card_eq_fintype_card, ← fintype.card_sigma]\n    apply fintype.card_congr\n    calc\n      «expr ≃ » (Σp, { l : L // p ∈ l }) { x : P × L // x.1 ∈ x.2 } := (Equiv.subtypeProdEquivSigmaSubtype (· ∈ ·)).symm\n      «expr ≃ » _ { x : L × P // x.2 ∈ x.1 } := (Equiv.prodComm P L).subtype_equiv fun x => iff.rfl\n      «expr ≃ » _ (Σl, { p // p ∈ l }) := Equiv.subtypeProdEquivSigmaSubtype fun (l : L) (p : P) => p ∈ l\n      \n#align sum_line_count_eq_sum_point_count sum_line_count_eq_sum_point_count\n\n",
 "point_count_le_line_count":
 "theorem has_lines.point_count_le_line_count [has_lines P L] {p : P} {l : L} (h : p ∉ l) [Finite { l : L // p ∈ l }] :\n    point_count P l ≤ line_count L p :=\n  by\n  by_cases hf : Infinite { p : P // p ∈ l }\n  · exact (le_of_eq nat.card_eq_zero_of_infinite).trans (zero_le (line_count L p))\n  haveI := fintype_of_not_infinite hf\n  cases nonempty_fintype { l : L // p ∈ l }\n  rw [line_count, point_count, nat.card_eq_fintype_card, nat.card_eq_fintype_card]\n  have : ∀ p' : { p // p ∈ l }, p ≠ p' := fun p' hp' => h ((congr_arg (· ∈ l) hp').mpr p'.2)\n  exact\n    fintype.card_le_of_injective (fun p' => ⟨mk_line (this p'), (mk_line_ax (this p')).1⟩) fun p₁ p₂ hp =>\n      subtype.ext\n        ((eq_or_eq p₁.2 p₂.2 (mk_line_ax (this p₁)).2\n              ((congr_arg _ (subtype.ext_iff.mp hp)).mpr (mk_line_ax (this p₂)).2)).resolve_right\n          fun h' => (congr_arg _ h').mp h (mk_line_ax (this p₁)).1)\n#align has_lines.point_count_le_line_count has_lines.point_count_le_line_count\n\n",
 "point_count_eq_point_count":
 "theorem point_count_eq_point_count [Finite P] [Finite L] (l m : L) : point_count P l = point_count P m :=\n  line_count_eq_line_count (dual P) l m\n#align point_count_eq_point_count point_count_eq_point_count\n\n",
 "point_count_eq":
 "theorem point_count_eq [Finite P] [Finite L] (l : L) : point_count P l = order P L + 1 :=\n  (line_count_eq (dual P) l).trans (congr_arg (fun n => n + 1) (dual.order P L))\n#align point_count_eq point_count_eq\n\n",
 "order":
 "theorem dual.order [Finite P] [Finite L] : order (dual L) (dual P) = order P L :=\n  congr_arg (fun n => n - 1) (line_count_eq_point_count _ _)\n#align dual.order dual.order\n\n",
 "one_lt_order":
 "theorem one_lt_order [Finite P] [Finite L] : 1 < order P L :=\n  by\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, -, -, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  classical\n    cases nonempty_fintype { p : P // p ∈ l₂ }\n    rw [← add_lt_add_iff_right, ← point_count_eq _ l₂, point_count, nat.card_eq_fintype_card]\n    simp_rw [fintype.two_lt_card_iff, ne, subtype.ext_iff]\n    have h := mk_point_ax fun h => h₂₁ ((congr_arg _ h).mpr h₂₂)\n    exact\n      ⟨⟨mk_point _, h.2⟩, ⟨p₂, h₂₂⟩, ⟨p₃, h₃₂⟩, ne_of_mem_of_not_mem h.1 h₂₁, ne_of_mem_of_not_mem h.1 h₃₁,\n        ne_of_mem_of_not_mem h₂₃ h₃₃⟩\n#align one_lt_order one_lt_order\n\n",
 "line_count_le_point_count":
 "theorem has_points.line_count_le_point_count [has_points P L] {p : P} {l : L} (h : p ∉ l)\n    [hf : Finite { p : P // p ∈ l }] : line_count L p ≤ point_count P l :=\n  @has_lines.point_count_le_line_count (dual L) (dual P) _ _ l p h hf\n#align has_points.line_count_le_point_count has_points.line_count_le_point_count\n\n",
 "line_count_eq_point_count":
 "theorem line_count_eq_point_count [Finite P] [Finite L] (p : P) (l : L) : line_count L p = point_count P l :=\n  exists.elim (exists_point l) fun q hq =>\n    (line_count_eq_line_count L p q).trans <| by\n      cases nonempty_fintype P\n      cases nonempty_fintype L\n      exact has_lines.line_count_eq_point_count (card_points_eq_card_lines P L) hq\n#align line_count_eq_point_count line_count_eq_point_count\n\n",
 "line_count_eq_line_count":
 "theorem line_count_eq_line_count [Finite P] [Finite L] (p q : P) : line_count L p = line_count L q :=\n  by\n  cases nonempty_fintype P\n  cases nonempty_fintype L\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, h₁₂, h₁₃, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := exists_config\n  have h := card_points_eq_card_lines P L\n  let n := line_count L p₂\n  have hp₂ : line_count L p₂ = n := rfl\n  have hl₁ : point_count P l₁ = n := (has_lines.line_count_eq_point_count h h₂₁).symm.trans hp₂\n  have hp₃ : line_count L p₃ = n := (has_lines.line_count_eq_point_count h h₃₁).trans hl₁\n  have hl₃ : point_count P l₃ = n := (has_lines.line_count_eq_point_count h h₃₃).symm.trans hp₃\n  have hp₁ : line_count L p₁ = n := (has_lines.line_count_eq_point_count h h₁₃).trans hl₃\n  have hl₂ : point_count P l₂ = n := (has_lines.line_count_eq_point_count h h₁₂).symm.trans hp₁\n  suffices ∀ p : P, line_count L p = n by exact (this p).trans (this q).symm\n  refine' fun p => or_not.elim (fun h₂ => _) fun h₂ => (has_lines.line_count_eq_point_count h h₂).trans hl₂\n  refine' or_not.elim (fun h₃ => _) fun h₃ => (has_lines.line_count_eq_point_count h h₃).trans hl₃\n  rwa [(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h => h₃₃ ((congr_arg (has_mem.mem p₃) h).mp h₃₂)]\n#align line_count_eq_line_count line_count_eq_line_count\n\n",
 "line_count_eq":
 "theorem line_count_eq [Finite P] [Finite L] (p : P) : line_count L p = order P L + 1 := by\n  classical\n    obtain ⟨q, -, -, l, -, -, -, -, h, -⟩ := Classical.choose_spec (@exists_config P L _ _)\n    cases nonempty_fintype { l : L // q ∈ l }\n    rw [order, line_count_eq_line_count L p q, line_count_eq_line_count L (Classical.choose _) q, line_count,\n      nat.card_eq_fintype_card, nat.sub_add_cancel]\n    exact fintype.card_pos_iff.mpr ⟨⟨l, h⟩⟩\n#align line_count_eq line_count_eq\n\n",
 "exists_unique_point":
 "/-\nCopyright (c) 2021 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem has_points.exists_unique_point [has_points P L] (l₁ l₂ : L) (hl : l₁ ≠ l₂) : ∃! p, p ∈ l₁ ∧ p ∈ l₂ :=\n  ⟨mk_point hl, mk_point_ax hl, fun p hp => (eq_or_eq hp.1 (mk_point_ax hl).1 hp.2 (mk_point_ax hl).2).resolve_right hl⟩\n#align has_points.exists_unique_point has_points.exists_unique_point\n\n",
 "exists_unique_line":
 "theorem has_lines.exists_unique_line [has_lines P L] (p₁ p₂ : P) (hp : p₁ ≠ p₂) : ∃! l : L, p₁ ∈ l ∧ p₂ ∈ l :=\n  has_points.exists_unique_point (dual L) (dual P) p₁ p₂ hp\n#align has_lines.exists_unique_line has_lines.exists_unique_line\n\n",
 "exists_injective_of_card_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- If a nondegenerate configuration has at least as many points as lines, then there exists\n  an injective function `f` from lines to points, such that `f l` does not lie on `l`. -/\ntheorem nondegenerate.exists_injective_of_card_le [nondegenerate P L] [fintype P] [fintype L]\n    (h : fintype.card L ≤ fintype.card P) : ∃ f : L → P, function.injective f ∧ ∀ l, f l ∉ l := by\n  classical\n    let t : L → Finset P := fun l => set.to_finset { p | p ∉ l }\n    suffices ∀ s : Finset L, s.card ≤ (s.bUnion t).card\n      by\n      -- Hall's marriage theorem\n      obtain ⟨f, hf1, hf2⟩ := (finset.all_card_le_bUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => set.mem_to_finset.mp (hf2 l)⟩\n    intro s\n    by_cases hs₀ : s.card = 0\n    -- If `s = ∅`, then `s.card = 0 ≤ (s.bUnion t).card`\n    · simp_rw [hs₀, zero_le]\n    by_cases hs₁ : s.card = 1\n    -- If `s = {l}`, then pick a point `p ∉ l`\n    · obtain ⟨l, rfl⟩ := finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point l\n      rw [finset.card_singleton, Finset.singleton_bunionᵢ, Nat.one_le_iff_ne_zero]\n      exact finset.card_ne_zero_of_mem (set.mem_to_finset.mpr hl)\n    suffices («expr ᶜ» (s.bUnion t)).card ≤ («expr ᶜ» s).card\n      by\n      -- Rephrase in terms of complements (uses `h`)\n      rw [finset.card_compl, finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this\n    have hs₂ : («expr ᶜ» (s.bUnion t)).card ≤ 1 :=\n      by\n      -- At most one line through two points of `s`\n      refine' finset.card_le_one_iff.mpr fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [finset.mem_compl, Finset.mem_bunionᵢ, exists_prop, not_exists, not_and, set.mem_to_finset,\n        Set.mem_setOf_eq, not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ := finset.one_lt_card_iff.mp (nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃\n    by_cases hs₃ : («expr ᶜ» s).card = 0\n    · rw [hs₃, le_zero_iff]\n      rw [finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (finset.card_le_univ _), eq_comm,\n        finset.card_eq_iff_eq_univ] at hs₃⊢\n      rw [hs₃]\n      rw [finset.eq_univ_iff_forall] at hs₃⊢\n      exact fun p =>\n        exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => finset.mem_bUnion.mpr ⟨l, finset.mem_univ l, set.mem_to_finset.mpr hl⟩\n    · exact hs₂.trans (nat.one_le_iff_ne_zero.mpr hs₃)\n#align nondegenerate.exists_injective_of_card_le nondegenerate.exists_injective_of_card_le\n\n",
 "exists_bijective_of_card_eq":
 "theorem has_lines.exists_bijective_of_card_eq [has_lines P L] [fintype P] [fintype L]\n    (h : fintype.card P = fintype.card L) :\n    ∃ f : L → P, function.bijective f ∧ ∀ l, point_count P l = line_count L (f l) := by\n  classical\n    obtain ⟨f, hf1, hf2⟩ := nondegenerate.exists_injective_of_card_le (ge_of_eq h)\n    have hf3 := (fintype.bijective_iff_injective_and_card f).mpr ⟨hf1, h.symm⟩\n    refine'\n      ⟨f, hf3, fun l =>\n        (finset.sum_eq_sum_iff_of_le fun l hl => has_lines.point_count_le_line_count (hf2 l)).mp\n          ((sum_line_count_eq_sum_point_count P L).symm.trans\n            (finset.sum_bij (fun l hl => f l) (fun l hl => finset.mem_univ (f l))\n                (fun l hl => refl (line_count L (f l))) (fun l₁ l₂ hl₁ hl₂ hl => hf1 hl) fun p hp => _).symm)\n          l (finset.mem_univ l)⟩\n    obtain ⟨l, rfl⟩ := hf3.2 p\n    exact ⟨l, finset.mem_univ l, rfl⟩\n#align has_lines.exists_bijective_of_card_eq has_lines.exists_bijective_of_card_eq\n\n",
 "card_points_eq_card_lines":
 "-- see Note [lower instance priority]\n-- see Note [lower instance priority]\ntheorem card_points_eq_card_lines [fintype P] [fintype L] : fintype.card P = fintype.card L :=\n  le_antisymm (has_lines.card_le P L) (has_points.card_le P L)\n#align card_points_eq_card_lines card_points_eq_card_lines\n\n",
 "card_points":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem card_points [fintype P] [Finite L] : fintype.card P = order P L ^ 2 + order P L + 1 :=\n  by\n  cases nonempty_fintype L\n  obtain ⟨p, -⟩ := @exists_config P L _ _\n  let ϕ : «expr ≃ » { q // q ≠ p } (Σl : { l : L // p ∈ l }, { q // q ∈ l.1 ∧ q ≠ p }) :=\n    { to_fun := fun q => ⟨⟨mk_line q.2, (mk_line_ax q.2).2⟩, q, (mk_line_ax q.2).1, q.2⟩\n      inv_fun := fun lq => ⟨lq.2, lq.2.2.2⟩\n      left_inv := fun q => subtype.ext rfl\n      right_inv := fun lq =>\n        sigma.subtype_ext\n          (subtype.ext\n            ((eq_or_eq (mk_line_ax lq.2.2.2).1 (mk_line_ax lq.2.2.2).2 lq.2.2.1 lq.1.2).resolve_left lq.2.2.2))\n          rfl }\n  classical\n    have h1 : fintype.card { q // q ≠ p } + 1 = fintype.card P :=\n      by\n      apply (eq_tsub_iff_add_eq_of_le (nat.succ_le_of_lt (fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert (fintype.card_subtype_compl _).trans (congr_arg _ (fintype.card_subtype_eq p))\n    have h2 : ∀ l : { l : L // p ∈ l }, fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L :=\n      by\n      intro l\n      rw [← fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter _ _),\n        fintype.card_subtype_compl fun x : subtype (· ∈ l.val) => x.val = p, ← nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((point_count_eq P l.1).trans _)\n      rw [← fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [subtype.ext_iff_val]\n    simp_rw [← h1, fintype.card_congr ϕ, fintype.card_sigma, h2, finset.sum_const, finset.card_univ]\n    rw [← nat.card_eq_fintype_card, ← line_count, line_count_eq, smul_eq_mul, nat.succ_mul, sq]\n#align card_points card_points\n\n",
 "card_lines":
 "theorem card_lines [Finite P] [fintype L] : fintype.card L = order P L ^ 2 + order P L + 1 :=\n  (card_points (dual L) (dual P)).trans (congr_arg (fun n => n ^ 2 + n + 1) (dual.order P L))\n#align card_lines card_lines\n\n",
 "card_le":
 "/-- If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`. -/\ntheorem has_points.card_le [has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P :=\n  @has_lines.card_le (dual L) (dual P) _ _ _ _\n#align has_points.card_le has_points.card_le\n\n"}