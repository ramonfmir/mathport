{"sum_two_pow_lt_iff_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- For subsets of ℕ, we can show that colex is equivalent to binary. -/\ntheorem sum_two_pow_lt_iff_lt (A B : Finset ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" A (2 ^ i) <\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" B (2 ^ i) ↔\n      A.to_colex < B.to_colex :=\n  by\n  have z :\n    ∀ A B : Finset ℕ,\n      A.to_colex < B.to_colex →\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" A (2 ^ i) <\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" B (2 ^ i) :=\n    by\n    intro A B\n    rw [← sdiff_lt_sdiff_iff_lt, Colex.lt_def]\n    rintro ⟨k, z, kA, kB⟩\n    rw [← sdiff_union_inter A B]\n    conv_rhs => rw [← sdiff_union_inter B A]\n    rw [sum_union (disjoint_sdiff_inter _ _), sum_union (disjoint_sdiff_inter _ _), inter_comm, add_lt_add_iff_right]\n    apply lt_of_lt_of_le (@Nat.sum_two_pow_lt k (A \\ B) _)\n    · apply single_le_sum (fun _ _ => nat.zero_le _) kB\n    intro x hx\n    apply lt_of_le_of_ne (le_of_not_lt fun kx => _)\n    · apply ne_of_mem_of_not_mem hx kA\n    have := (z kx).1 hx\n    rw [mem_sdiff] at this hx\n    exact hx.2 this.1\n  refine' ⟨fun h => (lt_trichotomy A B).resolve_right fun h₁ => h₁.elim _ (not_lt_of_gt h ∘ z _ _), z A B⟩\n  rintro rfl\n  apply irrefl _ h\n#align sum_two_pow_lt_iff_lt sum_two_pow_lt_iff_lt\n\n",
 "sum_two_pow_lt":
 "#print Nat.sum_two_pow_lt /-\n/-- If everything in `A` is less than `k`, we can bound the sum of powers. -/\ntheorem Nat.sum_two_pow_lt {k : ℕ} {A : Finset ℕ} (h₁ : ∀ {x}, x ∈ A → x < k) : A.sum (pow 2) < 2 ^ k :=\n  by\n  apply lt_of_le_of_lt (sum_le_sum_of_subset fun t => mem_range.2 ∘ h₁)\n  have z := geom_sum_mul_add 1 k\n  rw [mul_one, one_add_one_eq_two] at z\n  rw [← z]\n  apply nat.lt_succ_self\n#align nat.sum_two_pow_lt Nat.sum_two_pow_lt\n-/\n\n",
 "sum_two_pow_le_iff_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- For subsets of ℕ, we can show that colex is equivalent to binary. -/\ntheorem sum_two_pow_le_iff_lt (A B : Finset ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" A (2 ^ i) ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" B (2 ^ i) ↔\n      A.to_colex ≤ B.to_colex :=\n  by rw [le_iff_le_iff_lt_iff_lt, sum_two_pow_lt_iff_lt]\n#align sum_two_pow_le_iff_lt sum_two_pow_le_iff_lt\n\n",
 "singleton_lt_iff_lt":
 "/-- Colex is an extension of the base ordering on α. -/\ntheorem singleton_lt_iff_lt [linear_order α] {r s : α} :\n    ({r} : Finset α).to_colex < ({s} : Finset α).to_colex ↔ r < s := by simp [lt_singleton_iff_mem_lt]\n#align singleton_lt_iff_lt singleton_lt_iff_lt\n\n",
 "singleton_le_iff_le":
 "/-- Colex is an extension of the base ordering on α. -/\ntheorem singleton_le_iff_le [linear_order α] {r s : α} :\n    ({r} : Finset α).to_colex ≤ ({s} : Finset α).to_colex ↔ r ≤ s := by\n  rw [le_iff_le_iff_lt_iff_lt, singleton_lt_iff_lt]\n#align singleton_le_iff_le singleton_le_iff_le\n\n",
 "sdiff_lt_sdiff_iff_lt":
 "/-- Colex doesn't care if you remove the other set -/\n@[simp]\ntheorem sdiff_lt_sdiff_iff_lt [LT α] [DecidableEq α] (A B : Finset α) :\n    (A \\ B).to_colex < (B \\ A).to_colex ↔ A.to_colex < B.to_colex :=\n  by\n  rw [Colex.lt_def, Colex.lt_def]\n  apply exists_congr\n  intro k\n  simp only [mem_sdiff, not_and, Classical.not_not]\n  constructor\n  · rintro ⟨z, kAB, kB, kA⟩\n    refine' ⟨_, kA, kB⟩\n    · intro x hx\n      specialize z hx\n      tauto\n  · rintro ⟨z, kA, kB⟩\n    refine' ⟨_, fun _ => kB, kB, kA⟩\n    intro x hx\n    rw [z hx]\n#align sdiff_lt_sdiff_iff_lt sdiff_lt_sdiff_iff_lt\n\n",
 "sdiff_le_sdiff_iff_le":
 "/-- Colex doesn't care if you remove the other set -/\n@[simp]\ntheorem sdiff_le_sdiff_iff_le [linear_order α] (A B : Finset α) :\n    (A \\ B).to_colex ≤ (B \\ A).to_colex ↔ A.to_colex ≤ B.to_colex := by\n  rw [le_iff_le_iff_lt_iff_lt, sdiff_lt_sdiff_iff_lt]\n#align sdiff_le_sdiff_iff_le sdiff_le_sdiff_iff_le\n\n",
 "mem_le_of_singleton_le":
 "/-- If {r} is less than or equal to s in the colexicographical sense,\n  then s contains an element greater than or equal to r. -/\ntheorem mem_le_of_singleton_le [linear_order α] {r : α} {s : Finset α} :\n    ({r} : Finset α).to_colex ≤ s.to_colex ↔ ∃ x ∈ s, r ≤ x :=\n  by\n  rw [← not_lt]\n  simp [lt_singleton_iff_mem_lt]\n#align mem_le_of_singleton_le mem_le_of_singleton_le\n\n",
 "lt_trichotomy":
 "#print lt_trichotomy /-\ntheorem lt_trichotomy [linear_order α] (A B : Finset.Colex α) : A < B ∨ A = B ∨ B < A :=\n  by\n  by_cases h₁ : A = B\n  · tauto\n  rcases exists_max_image (A \\ B ∪ B \\ A) id _ with ⟨k, hk, z⟩\n  · simp only [mem_union, mem_sdiff] at hk\n    cases hk\n    · right\n      right\n      refine' ⟨k, fun t th => _, hk.2, hk.1⟩\n      specialize z t\n      by_contra h₂\n      simp only [mem_union, mem_sdiff, id.def] at z\n      rw [not_iff, iff_iff_and_or_not_and_not, Classical.not_not, and_comm'] at h₂\n      apply not_le_of_lt th (z h₂)\n    · left\n      refine' ⟨k, fun t th => _, hk.2, hk.1⟩\n      specialize z t\n      by_contra h₃\n      simp only [mem_union, mem_sdiff, id.def] at z\n      rw [not_iff, iff_iff_and_or_not_and_not, Classical.not_not, and_comm', or_comm'] at h₃\n      apply not_le_of_lt th (z h₃)\n  rw [nonempty_iff_ne_empty]\n  intro a\n  simp only [union_eq_empty_iff, sdiff_eq_empty_iff_subset] at a\n  apply h₁ (subset.antisymm a.1 a.2)\n#align lt_trichotomy lt_trichotomy\n-/\n\n",
 "lt_trans":
 "#print lt_trans /-\n@[trans]\ntheorem lt_trans [linear_order α] {a b c : Finset.Colex α} : a < b → b < c → a < c :=\n  by\n  rintro ⟨k₁, k₁z, notinA, inB⟩ ⟨k₂, k₂z, notinB, inC⟩\n  cases lt_or_gt_of_ne (ne_of_mem_of_not_mem inB notinB)\n  · refine' ⟨k₂, fun x hx => _, by rwa [k₁z h], inC⟩\n    rw [← k₂z hx]\n    apply k₁z (trans h hx)\n  · refine' ⟨k₁, fun x hx => _, notinA, by rwa [← k₂z h]⟩\n    rw [k₁z hx]\n    apply k₂z (trans h hx)\n#align lt_trans lt_trans\n-/\n\n",
 "lt_singleton_iff_mem_lt":
 "/-- `s.to_colex < {r}.to_colex` iff all elements of `s` are less than `r`. -/\ntheorem lt_singleton_iff_mem_lt [linear_order α] {r : α} {s : Finset α} :\n    s.to_colex < ({r} : Finset α).to_colex ↔ ∀ x ∈ s, x < r :=\n  by\n  simp only [lt_def, mem_singleton, ← and_assoc', exists_eq_right]\n  constructor\n  · intro t x hx\n    rw [← not_le]\n    intro h\n    rcases lt_or_eq_of_le h with (h₁ | rfl)\n    · exact ne_of_irrefl h₁ ((t.1 h₁).1 hx).symm\n    · exact t.2 hx\n  · exact fun h => ⟨fun z hz => ⟨fun i => (asymm hz (h _ i)).elim, fun i => (hz.ne' i).elim⟩, by simpa using h r⟩\n#align lt_singleton_iff_mem_lt lt_singleton_iff_mem_lt\n\n",
 "lt_def":
 "#print Colex.lt_def /-\ntheorem Colex.lt_def [LT α] (A B : Finset α) :\n    A.to_colex < B.to_colex ↔ ∃ k, (∀ {x}, k < x → (x ∈ A ↔ x ∈ B)) ∧ k ∉ A ∧ k ∈ B :=\n  iff.rfl\n#align colex.lt_def Colex.lt_def\n-/\n\n",
 "le_trans":
 "#print le_trans /-\n@[trans]\ntheorem le_trans [linear_order α] (a b c : Finset.Colex α) : a ≤ b → b ≤ c → a ≤ c := fun AB BC =>\n  AB.elim (fun k => BC.elim (fun t => or.inl (lt_trans k t)) fun t => t ▸ AB) fun k => k.symm ▸ BC\n#align le_trans le_trans\n-/\n\n",
 "le_def":
 "#print Colex.le_def /-\ntheorem Colex.le_def [LT α] (A B : Finset α) : A.to_colex ≤ B.to_colex ↔ A.to_colex < B.to_colex ∨ A = B :=\n  iff.rfl\n#align colex.le_def Colex.le_def\n-/\n\n",
 "hom_lt_iff":
 "/-- Strictly monotone functions preserve the colex ordering. -/\ntheorem hom_lt_iff {β : Type _} [linear_order α] [DecidableEq β] [preorder β] {f : α → β} (h₁ : StrictMono f)\n    (A B : Finset α) : (A.image f).to_colex < (B.image f).to_colex ↔ A.to_colex < B.to_colex :=\n  by\n  simp only [Colex.lt_def, not_exists, mem_image, exists_prop, not_and]\n  constructor\n  · rintro ⟨k, z, q, k', _, rfl⟩\n    exact ⟨k', fun x hx => by simpa [h₁.injective.eq_iff] using z (h₁ hx), fun t => q _ t rfl, ‹k' ∈ B›⟩\n  rintro ⟨k, z, ka, _⟩\n  refine' ⟨f k, fun x hx => _, _, k, ‹k ∈ B›, rfl⟩\n  · constructor\n    any_goals\n      rintro ⟨x', hx', rfl⟩\n      refine' ⟨x', _, rfl⟩\n      first |rwa [← z _]|rwa [z _]\n      rwa [StrictMono.lt_iff_lt h₁] at hx\n  · simp only [h₁.injective, Function.Injective.eq_iff]\n    exact fun x hx => ne_of_mem_of_not_mem hx ka\n#align hom_lt_iff hom_lt_iff\n\n",
 "hom_le_iff":
 "/-- Strictly monotone functions preserve the colex ordering. -/\ntheorem hom_le_iff {β : Type _} [linear_order α] [linear_order β] {f : α → β} (h₁ : StrictMono f) (A B : Finset α) :\n    (A.image f).to_colex ≤ (B.image f).to_colex ↔ A.to_colex ≤ B.to_colex := by\n  rw [le_iff_le_iff_lt_iff_lt, hom_lt_iff h₁]\n#align hom_le_iff hom_le_iff\n\n",
 "hom_fin_lt_iff":
 "/-- A special case of `colex.hom_lt_iff` which is sometimes useful. -/\n@[simp]\ntheorem hom_fin_lt_iff {n : ℕ} (A B : Finset (Fin n)) :\n    (A.image fun i : Fin n => (i : ℕ)).to_colex < (B.image fun i : Fin n => (i : ℕ)).to_colex ↔\n      A.to_colex < B.to_colex :=\n  Colex.hom_lt_iff (fun x y k => k) _ _\n#align hom_fin_lt_iff hom_fin_lt_iff\n\n",
 "hom_fin_le_iff":
 "/-- A special case of `colex_hom` which is sometimes useful. -/\n@[simp]\ntheorem hom_fin_le_iff {n : ℕ} (A B : Finset (Fin n)) :\n    (A.image fun i : Fin n => (i : ℕ)).to_colex ≤ (B.image fun i : Fin n => (i : ℕ)).to_colex ↔\n      A.to_colex ≤ B.to_colex :=\n  Colex.hom_le_iff (fun x y k => k) _ _\n#align hom_fin_le_iff hom_fin_le_iff\n\n",
 "forall_lt_of_colex_lt_of_forall_lt":
 "/-- If `A` is before `B` in colex, and everything in `B` is small, then everything in `A` is small.\n-/\ntheorem forall_lt_of_colex_lt_of_forall_lt [linear_order α] {A B : Finset α} (t : α) (h₁ : A.to_colex < B.to_colex)\n    (h₂ : ∀ x ∈ B, x < t) : ∀ x ∈ A, x < t := by\n  rw [Colex.lt_def] at h₁\n  rcases h₁ with ⟨k, z, _, _⟩\n  intro x hx\n  apply lt_of_not_ge\n  intro a\n  refine' not_lt_of_ge a (h₂ x _)\n  rwa [← z]\n  apply lt_of_lt_of_le (h₂ k ‹_›) a\n#align forall_lt_of_colex_lt_of_forall_lt forall_lt_of_colex_lt_of_forall_lt\n\n",
 "eq_iff":
 "#print Colex.eq_iff /-\n/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Alena Gusakov\n-/\n@[simp]\ntheorem Colex.eq_iff (A B : Finset α) : A.to_colex = B.to_colex ↔ A = B :=\n  iff.rfl\n#align colex.eq_iff Colex.eq_iff\n-/\n\n",
 "empty_to_colex_lt":
 "theorem empty_to_colex_lt [linear_order α] {A : Finset α} (hA : A.nonempty) : (∅ : Finset α).to_colex < A.to_colex :=\n  by\n  rw [Colex.lt_def]\n  refine' ⟨max' _ hA, _, by simp, max'_mem _ _⟩\n  simp only [false_iff_iff, not_mem_empty]\n  intro x hx t\n  apply not_le_of_lt hx (le_max' _ _ t)\n#align empty_to_colex_lt empty_to_colex_lt\n\n",
 "empty_to_colex_le":
 "@[simp]\ntheorem empty_to_colex_le [linear_order α] {A : Finset α} : (∅ : Finset α).to_colex ≤ A.to_colex :=\n  by\n  rcases A.eq_empty_or_nonempty with (rfl | hA)\n  · simp\n  · apply (empty_to_colex_lt hA).le\n#align empty_to_colex_le empty_to_colex_le\n\n",
 "colex_lt_of_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/-- If `A ⊂ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`⊆` is not a linear order. -/\ntheorem colex_lt_of_ssubset [linear_order α] {A B : Finset α} (h : «expr ⊂ » A B) : A.to_colex < B.to_colex :=\n  by\n  rw [← sdiff_lt_sdiff_iff_lt, sdiff_eq_empty_iff_subset.2 h.1]\n  exact empty_to_colex_lt (by simpa [Finset.Nonempty] using exists_of_ssubset h)\n#align colex_lt_of_ssubset colex_lt_of_ssubset\n\n",
 "colex_le_of_subset":
 "/-- If `A ⊆ B`, then `A ≤ B` in the colex order. Note the converse does not hold, as `⊆` is not a\nlinear order. -/\ntheorem colex_le_of_subset [linear_order α] {A B : Finset α} (h : A ⊆ B) : A.to_colex ≤ B.to_colex :=\n  by\n  rw [← sdiff_le_sdiff_iff_le, sdiff_eq_empty_iff_subset.2 h]\n  apply empty_to_colex_le\n#align colex_le_of_subset colex_le_of_subset\n\n"}