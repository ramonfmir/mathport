{"hall_hard_inductive_step_B":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- Second case of the inductive step: assuming that\n`∃ (s : finset ι), s ≠ univ → s.card = (s.bUnion t).card`\nand that the statement of **Hall's Marriage Theorem** is true for all\n`ι'` of cardinality ≤ `n`, then it is true for `ι` of cardinality `n + 1`.\n-/\ntheorem hall_hard_inductive_step_B {n : ℕ} (hn : Fintype.card ι = n + 1)\n    (ht : ∀ s : Finset ι, s.card ≤ (s.bUnion t).card)\n    (ih :\n      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),\n        Fintype.card ι' ≤ n →\n          (∀ s' : Finset ι', s'.card ≤ (s'.bUnion t').card) → ∃ f : ι' → α, function.injective f ∧ ∀ x, f x ∈ t' x)\n    (s : Finset ι) (hs : s.nonempty) (hns : s ≠ univ) (hus : s.card = (s.bUnion t).card) :\n    ∃ f : ι → α, function.injective f ∧ ∀ x, f x ∈ t x :=\n  by\n  haveI := Classical.decEq ι\n  -- Restrict to `s`\n  let t' : s → Finset α := fun x' => t x'\n  rw [nat.add_one] at hn\n  have card_ι'_le : Fintype.card s ≤ n := by\n    apply nat.le_of_lt_succ\n    calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := ((card_lt_iff_ne_univ _).mpr hns)\n      _ = n.succ := hn\n      \n  rcases ih t' card_ι'_le (hall_cond_of_restrict ht) with ⟨f', hf', hsf'⟩\n  -- Restrict to `sᶜ` in the domain and `(s.bUnion t)ᶜ` in the codomain.\n  set ι'' := «expr ᶜ» (s : Set ι) with ι''_def\n  let t'' : ι'' → Finset α := fun a'' => t a'' \\ s.bUnion t\n  have card_ι''_le : Fintype.card ι'' ≤ n :=\n    by\n    simp_rw [← Nat.lt_succ_iff, ← hn, ι'', ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]\n  rcases ih t'' card_ι''_le (hall_cond_of_compl hus ht) with ⟨f'', hf'', hsf''⟩\n  -- Put them together\n  have f'_mem_bUnion : ∀ {x'} (hx' : x' ∈ s), f' ⟨x', hx'⟩ ∈ s.bUnion t :=\n    by\n    intro x' hx'\n    rw [mem_bUnion]\n    exact ⟨x', hx', hsf' _⟩\n  have f''_not_mem_bUnion : ∀ {x''} (hx'' : ¬x'' ∈ s), ¬f'' ⟨x'', hx''⟩ ∈ s.bUnion t :=\n    by\n    intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2\n  have im_disj : ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s), f' ⟨x', hx'⟩ ≠ f'' ⟨x'', hx''⟩ :=\n    by\n    intro _ _ hx' hx'' h\n    apply f''_not_mem_bUnion hx''\n    rw [← h]\n    apply f'_mem_bUnion\n  refine' ⟨fun x => if h : x ∈ s then f' ⟨x, h⟩ else f'' ⟨x, h⟩, _, _⟩\n  · exact hf'.dite _ hf'' im_disj\n  · intro x\n    split_ifs with h\n    · exact hsf' ⟨x, h⟩\n    · exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)\n#align hall_hard_inductive_step_B hall_hard_inductive_step_B\n\n",
 "hall_hard_inductive_step_A":
 "/-- First case of the inductive step: assuming that\n`∀ (s : finset ι), s.nonempty → s ≠ univ → s.card < (s.bUnion t).card`\nand that the statement of **Hall's Marriage Theorem** is true for all\n`ι'` of cardinality ≤ `n`, then it is true for `ι` of cardinality `n + 1`.\n-/\ntheorem hall_hard_inductive_step_A {n : ℕ} (hn : Fintype.card ι = n + 1)\n    (ht : ∀ s : Finset ι, s.card ≤ (s.bUnion t).card)\n    (ih :\n      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),\n        Fintype.card ι' ≤ n →\n          (∀ s' : Finset ι', s'.card ≤ (s'.bUnion t').card) → ∃ f : ι' → α, function.injective f ∧ ∀ x, f x ∈ t' x)\n    (ha : ∀ s : Finset ι, s.nonempty → s ≠ univ → s.card < (s.bUnion t).card) :\n    ∃ f : ι → α, function.injective f ∧ ∀ x, f x ∈ t x :=\n  by\n  haveI : Nonempty ι := fintype.card_pos_iff.mp (hn.symm ▸ nat.succ_pos _)\n  haveI := Classical.decEq ι\n  -- Choose an arbitrary element `x : ι` and `y : t x`.\n  let x := Classical.arbitrary ι\n  have tx_ne : (t x).nonempty := by\n    rw [← Finset.card_pos]\n    calc\n      0 < 1 := nat.one_pos\n      _ ≤ (Finset.bunionᵢ {x} t).card := (ht {x})\n      _ = (t x).card := by rw [Finset.singleton_bunionᵢ]\n      \n  choose y hy using tx_ne\n  -- Restrict to everything except `x` and `y`.\n  let ι' := { x' : ι | x' ≠ x }\n  let t' : ι' → Finset α := fun x' => (t x').erase y\n  have card_ι' : Fintype.card ι' = n :=\n    calc\n      Fintype.card ι' = Fintype.card ι - 1 := Set.card_ne_eq _\n      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]\n      \n  rcases ih t' card_ι'.le (hall_cond_of_erase y ha) with ⟨f', hfinj, hfr⟩\n  -- Extend the resulting function.\n  refine' ⟨fun z => if h : z = x then y else f' ⟨z, h⟩, _, _⟩\n  · rintro z₁ z₂\n    have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [← h] using hfr x\n    by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;> simp [h₁, h₂, hfinj.eq_iff, key, key.symm]\n  · intro z\n    split_ifs with hz\n    · rwa [hz]\n    · specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2\n#align hall_hard_inductive_step_A hall_hard_inductive_step_A\n\n",
 "hall_hard_inductive":
 "/-- Here we combine the two inductive steps into a full strong induction proof,\ncompleting the proof the harder direction of **Hall's Marriage Theorem**.\n-/\ntheorem hall_hard_inductive (ht : ∀ s : Finset ι, s.card ≤ (s.bUnion t).card) :\n    ∃ f : ι → α, function.injective f ∧ ∀ x, f x ∈ t x :=\n  by\n  cases nonempty_fintype ι\n  induction' hn : Fintype.card ι using nat.strong_induction_on with n ih generalizing ι\n  rcases n with (_ | _)\n  · rw [Fintype.card_eq_zero_iff] at hn\n    exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩\n  · have ih' :\n      ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α),\n        Fintype.card ι' ≤ n →\n          (∀ s' : Finset ι', s'.card ≤ (s'.bUnion t').card) → ∃ f : ι' → α, function.injective f ∧ ∀ x, f x ∈ t' x :=\n      by\n      intro ι' _ _ hι' ht'\n      exact ih _ (nat.lt_succ_of_le hι') ht' _ rfl\n    by_cases h : ∀ s : Finset ι, s.nonempty → s ≠ univ → s.card < (s.bUnion t).card\n    · exact hall_hard_inductive_step_A hn ht ih' h\n    · push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht ih' s sne snu (nat.le_antisymm (ht _) sle)\n#align hall_hard_inductive hall_hard_inductive\n\n",
 "hall_cond_of_restrict":
 "theorem hall_cond_of_restrict {ι : Type u} {t : ι → Finset α} {s : Finset ι}\n    (ht : ∀ s : Finset ι, s.card ≤ (s.bUnion t).card) (s' : Finset (s : Set ι)) :\n    s'.card ≤ (s'.bUnion fun a' => t a').card := by\n  classical\n    rw [← card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image coe) using 1\n    apply congr_arg\n    ext y\n    simp\n#align hall_cond_of_restrict hall_cond_of_restrict\n\n",
 "hall_cond_of_erase":
 "/-\nCopyright (c) 2021 Alena Gusakov, Bhavik Mehta, Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alena Gusakov, Bhavik Mehta, Kyle Miller\n-/\ntheorem hall_cond_of_erase {x : ι} (a : α) (ha : ∀ s : Finset ι, s.nonempty → s ≠ univ → s.card < (s.bUnion t).card)\n    (s' : Finset { x' : ι | x' ≠ x }) : s'.card ≤ (s'.bUnion fun x' => (t x').erase a).card :=\n  by\n  haveI := Classical.decEq ι\n  specialize ha (s'.image coe)\n  rw [nonempty.image_iff, Finset.card_image_of_injective s' Subtype.coe_injective] at ha\n  by_cases he : s'.nonempty\n  · have ha' : s'.card < (s'.bUnion fun x => t x).card :=\n      by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_bUnion, exists_prop, SetCoe.exists, exists_and_right, exists_eq_right, Subtype.coe_mk]\n    rw [← erase_bUnion]\n    by_cases hb : a ∈ s'.bUnion fun x => t x\n    · rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'\n    · rw [erase_eq_of_not_mem hb]\n      exact nat.le_of_lt ha'\n  · rw [nonempty_iff_ne_empty, Classical.not_not] at he\n    subst s'\n    simp\n#align hall_cond_of_erase hall_cond_of_erase\n\n",
 "hall_cond_of_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem hall_cond_of_compl {ι : Type u} {t : ι → Finset α} {s : Finset ι} (hus : s.card = (s.bUnion t).card)\n    (ht : ∀ s : Finset ι, s.card ≤ (s.bUnion t).card) (s' : Finset («expr ᶜ» s : Set ι)) :\n    s'.card ≤ (s'.bUnion fun x' => t x' \\ s.bUnion t).card :=\n  by\n  haveI := Classical.decEq ι\n  have disj : Disjoint s (s'.image coe) :=\n    by\n    simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right, exists_eq_right,\n      Subtype.coe_mk]\n    intro x hx hc h\n    exact absurd hx hc\n  have : s'.card = (s ∪ s'.image coe).card - s.card := by simp [disj, card_image_of_injective _ Subtype.coe_injective]\n  rw [this, hus]\n  refine' (tsub_le_tsub_right (ht _) _).trans _\n  rw [← card_sdiff]\n  · refine' (card_le_of_subset _).trans le_rfl\n    intro t\n    simp only [mem_bUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right, exists_imp]\n    rintro x (hx | ⟨x', hx', rfl⟩) rat hs\n    · exact (hs x hx Rat).elim\n    · exact ⟨⟨x', hx', Rat⟩, hs⟩\n  · apply bUnion_subset_bUnion_of_subset_left\n    apply subset_union_left\n#align hall_cond_of_compl hall_cond_of_compl\n\n",
 "all_card_le_bunionᵢ_card_iff_existsInjective'":
 "#print Finset.all_card_le_bunionᵢ_card_iff_existsInjective' /-\n/-- This is the version of **Hall's Marriage Theorem** in terms of indexed\nfamilies of finite sets `t : ι → finset α` with `ι` finite.\nIt states that there is a set of distinct representatives if and only\nif every union of `k` of the sets has at least `k` elements.\n\nSee `finset.all_card_le_bUnion_card_iff_exists_injective` for a version\nwhere the `finite ι` constraint is removed.\n-/\ntheorem Finset.all_card_le_bunionᵢ_card_iff_existsInjective' {ι α : Type _} [Finite ι] [DecidableEq α]\n    (t : ι → Finset α) :\n    (∀ s : Finset ι, s.card ≤ (s.bUnion t).card) ↔ ∃ f : ι → α, function.injective f ∧ ∀ x, f x ∈ t x :=\n  by\n  constructor\n  · exact HallMarriageTheorem.hall_hard_inductive\n  · rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← card_image_of_injective s hf₁]\n    apply card_le_of_subset\n    intro\n    rw [mem_image, mem_bUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩\n#align finset.all_card_le_bUnion_card_iff_exists_injective' Finset.all_card_le_bunionᵢ_card_iff_existsInjective'\n-/\n\n"}