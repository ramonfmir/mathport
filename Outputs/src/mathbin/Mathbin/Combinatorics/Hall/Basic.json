{"nonempty":
 "/-\nCopyright (c) 2021 Alena Gusakov, Bhavik Mehta, Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alena Gusakov, Bhavik Mehta, Kyle Miller\n-/\n/-- When the Hall condition is satisfied, the set of matchings on a finite set is nonempty.\nThis is where `finset.all_card_le_bUnion_card_iff_exists_injective'` comes into the argument. -/\ntheorem hall_matchings_on.nonempty {ι : Type u} {α : Type v} [decidable_eq α] (t : ι → Finset α)\n    (h : ∀ s : Finset ι, s.card ≤ (s.bUnion t).card) (ι' : Finset ι) : nonempty (hall_matchings_on t ι') := by\n  classical\n    refine' ⟨classical.indefinite_description _ _⟩\n    apply (all_card_le_bUnion_card_iff_exists_injective' fun i : ι' => t i).mp\n    intro s'\n    convert h (s'.image coe) using 1\n    simp only [card_image_of_injective s' subtype.coe_injective]\n    rw [image_bUnion]\n#align hall_matchings_on.nonempty hall_matchings_on.nonempty\n\n",
 "all_card_le_rel_image_card_iff_exists_injective":
 "/-- This is a version of **Hall's Marriage Theorem** in terms of a relation\nbetween types `α` and `β` such that `α` is finite and the image of\neach `x : α` is finite (it suffices for `β` to be finite; see\n`fintype.all_card_le_filter_rel_iff_exists_injective`).  There is\na transversal of the relation (an injective function `α → β` whose graph is\na subrelation of the relation) iff every subset of\n`k` terms of `α` is related to at least `k` terms of `β`.\n\nNote: if `[fintype β]`, then there exist instances for `[∀ (a : α), fintype (rel.image r {a})]`.\n-/\ntheorem fintype.all_card_le_rel_image_card_iff_exists_injective {α : Type u} {β : Type v} [decidable_eq β]\n    (r : α → β → Prop) [∀ a : α, fintype (Rel.image r {a})] :\n    (∀ A : Finset α, A.card ≤ fintype.card (Rel.image r A)) ↔ ∃ f : α → β, function.injective f ∧ ∀ x, r x (f x) :=\n  by\n  let r' a := (Rel.image r {a}).to_finset\n  have h : ∀ A : Finset α, fintype.card (Rel.image r A) = (A.bUnion r').card :=\n    by\n    intro A\n    rw [← set.to_finset_card]\n    apply congr_arg\n    ext b\n    simp [Rel.image]\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp [Rel.image]\n  simp only [h, h']\n  apply finset.all_card_le_bUnion_card_iff_exists_injective\n#align fintype.all_card_le_rel_image_card_iff_exists_injective fintype.all_card_le_rel_image_card_iff_exists_injective\n\n",
 "all_card_le_filter_rel_iff_exists_injective":
 "-- TODO: decidable_pred makes Yael sad. When an appropriate decidable_rel-like exists, fix it.\n/-- This is a version of **Hall's Marriage Theorem** in terms of a relation to a finite type.\nThere is a transversal of the relation (an injective function `α → β` whose graph is a subrelation\nof the relation) iff every subset of `k` terms of `α` is related to at least `k` terms of `β`.\n\nIt is like `fintype.all_card_le_rel_image_card_iff_exists_injective` but uses `finset.filter`\nrather than `rel.image`.\n-/\ntheorem fintype.all_card_le_filter_rel_iff_exists_injective {α : Type u} {β : Type v} [fintype β] (r : α → β → Prop)\n    [∀ a, decidable_pred (r a)] :\n    (∀ A : Finset α, A.card ≤ (univ.filter fun b : β => ∃ a ∈ A, r a b).card) ↔\n      ∃ f : α → β, function.injective f ∧ ∀ x, r x (f x) :=\n  by\n  haveI := classical.dec_eq β\n  let r' a := univ.filter fun b => r a b\n  have h : ∀ A : Finset α, (univ.filter fun b : β => ∃ a ∈ A, r a b) = A.bUnion r' :=\n    by\n    intro A\n    ext b\n    simp\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp\n  simp_rw [h, h']\n  apply finset.all_card_le_bUnion_card_iff_exists_injective\n#align fintype.all_card_le_filter_rel_iff_exists_injective fintype.all_card_le_filter_rel_iff_exists_injective\n\n",
 "all_card_le_bUnion_card_iff_exists_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵖ» -/\n-- TODO: This takes a long time to elaborate for an unknown reason.\n/-- This is the version of **Hall's Marriage Theorem** in terms of indexed\nfamilies of finite sets `t : ι → finset α`.  It states that there is a\nset of distinct representatives if and only if every union of `k` of the\nsets has at least `k` elements.\n\nRecall that `s.bUnion t` is the union of all the sets `t i` for `i ∈ s`.\n\nThis theorem is bootstrapped from `finset.all_card_le_bUnion_card_iff_exists_injective'`,\nwhich has the additional constraint that `ι` is a `fintype`.\n-/\ntheorem finset.all_card_le_bUnion_card_iff_exists_injective {ι : Type u} {α : Type v} [decidable_eq α]\n    (t : ι → Finset α) :\n    (∀ s : Finset ι, s.card ≤ (s.bUnion t).card) ↔ ∃ f : ι → α, function.injective f ∧ ∀ x, f x ∈ t x :=\n  by\n  constructor\n  · intro h\n    -- Set up the functor\n    haveI : ∀ ι' : «expr ᵒᵖ» (Finset ι), nonempty ((hall_matchings_functor t).obj ι') := fun ι' =>\n      hall_matchings_on.nonempty t h ι'.unop\n    classical\n      haveI : ∀ ι' : «expr ᵒᵖ» (Finset ι), fintype ((hall_matchings_functor t).obj ι') :=\n        by\n        intro ι'\n        rw [hall_matchings_functor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_fintype_inverse_system (hall_matchings_functor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i => (u (opposite.op ({i} : Finset ι))).val ⟨i, by simp only [opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        have le : ∀ {s t : Finset ι}, s ⊆ t → s ≤ t := fun _ _ h => h\n        rw [← hu (category_theory.hom_of_le (le subi)).op, ← hu (category_theory.hom_of_le (le subi')).op]\n        let uii' := u (opposite.op ({i, i'} : Finset ι))\n        exact fun h => subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (opposite.op ({i} : Finset ι))).property.2\n  · -- The reverse direction is a straightforward cardinality argument\n    rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← finset.card_image_of_injective s hf₁]\n    apply finset.card_le_of_subset\n    intro\n    rw [Finset.mem_image, Finset.mem_bunionᵢ]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩\n#align finset.all_card_le_bUnion_card_iff_exists_injective finset.all_card_le_bUnion_card_iff_exists_injective\n\n"}