{"to_prefunctor_symm_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭q» -/\n@[simp]\ntheorem to_prefunctor_symm_id : to_prefunctor.symm ((«expr𝟭q») (single_obj α)) = id :=\n  rfl\n#align to_prefunctor_symm_id to_prefunctor_symm_id\n\n",
 "to_prefunctor_symm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⥤q » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\n@[simp]\ntheorem to_prefunctor_symm_comp (f : «expr ⥤q » (single_obj α) (single_obj β))\n    (g : «expr ⥤q » (single_obj β) (single_obj γ)) :\n    to_prefunctor.symm («expr ⋙q » f g) = to_prefunctor.symm g ∘ to_prefunctor.symm f := by\n  simp only [equiv.symm_apply_eq, to_prefunctor_comp, equiv.apply_symm_apply]\n#align to_prefunctor_symm_comp to_prefunctor_symm_comp\n\n",
 "to_prefunctor_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr𝟭q» -/\n/-\nCopyright (c) 2023 Antoine Labelle. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Antoine Labelle\n-/\n-- See note [reducible non-instances]\n-- See note [reducible non-instances]\ntheorem to_prefunctor_id : to_prefunctor id = («expr𝟭q») (single_obj α) :=\n  rfl\n#align to_prefunctor_id to_prefunctor_id\n\n",
 "to_prefunctor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⋙q » -/\ntheorem to_prefunctor_comp (f : α → β) (g : β → γ) :\n    to_prefunctor (g ∘ f) = «expr ⋙q » (to_prefunctor f) (to_prefunctor g) :=\n  rfl\n#align to_prefunctor_comp to_prefunctor_comp\n\n",
 "path_to_list_to_path":
 "theorem path_to_list_to_path {x : single_obj α} (p : path (star α) x) :\n    list_to_path (path_to_list p) = p.cast rfl unit.ext :=\n  by\n  induction' p with y z p a ih\n  rfl\n  tidy\n#align path_to_list_to_path path_to_list_to_path\n\n",
 "path_equiv_list_symm_nil":
 "@[simp]\ntheorem path_equiv_list_symm_nil : path_equiv_list.symm ([] : list α) = path.nil :=\n  rfl\n#align path_equiv_list_symm_nil path_equiv_list_symm_nil\n\n",
 "path_equiv_list_symm_cons":
 "@[simp]\ntheorem path_equiv_list_symm_cons (l : list α) (a : α) :\n    path_equiv_list.symm (a :: l) = path.cons (path_equiv_list.symm l) a :=\n  rfl\n#align path_equiv_list_symm_cons path_equiv_list_symm_cons\n\n",
 "path_equiv_list_nil":
 "@[simp]\ntheorem path_equiv_list_nil : path_equiv_list path.nil = ([] : list α) :=\n  rfl\n#align path_equiv_list_nil path_equiv_list_nil\n\n",
 "path_equiv_list_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem path_equiv_list_cons (p : path (star α) (star α)) (a : «expr ⟶ » (star α) (star α)) :\n    path_equiv_list (path.cons p a) = a :: path_to_list p :=\n  rfl\n#align path_equiv_list_cons path_equiv_list_cons\n\n",
 "list_to_path_to_list":
 "theorem list_to_path_to_list (l : list α) : path_to_list (list_to_path l) = l :=\n  by\n  induction' l with a l ih\n  rfl\n  simp [ih]\n#align list_to_path_to_list list_to_path_to_list\n\n"}