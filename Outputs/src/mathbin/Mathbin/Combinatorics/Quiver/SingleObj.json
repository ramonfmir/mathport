{"to_prefunctor_symm_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­qÂ» -/\n@[simp]\ntheorem to_prefunctor_symm_id : toPrefunctor.symm ((Â«exprğŸ­qÂ») (SingleObj Î±)) = id :=\n  rfl\n#align to_prefunctor_symm_id to_prefunctor_symm_id\n\n",
 "to_prefunctor_symm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\n@[simp]\ntheorem to_prefunctor_symm_comp (f : Â«expr â¥¤q Â» (SingleObj Î±) (SingleObj Î²))\n    (g : Â«expr â¥¤q Â» (SingleObj Î²) (SingleObj Î³)) :\n    toPrefunctor.symm (Â«expr â‹™q Â» f g) = toPrefunctor.symm g âˆ˜ toPrefunctor.symm f := by\n  simp only [Equiv.symm_apply_eq, to_prefunctor_comp, Equiv.apply_symm_apply]\n#align to_prefunctor_symm_comp to_prefunctor_symm_comp\n\n",
 "to_prefunctor_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­qÂ» -/\n/-\nCopyright (c) 2023 Antoine Labelle. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Antoine Labelle\n-/\n-- See note [reducible non-instances]\n-- See note [reducible non-instances]\ntheorem to_prefunctor_id : toPrefunctor id = (Â«exprğŸ­qÂ») (SingleObj Î±) :=\n  rfl\n#align to_prefunctor_id to_prefunctor_id\n\n",
 "to_prefunctor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\ntheorem to_prefunctor_comp (f : Î± â†’ Î²) (g : Î² â†’ Î³) :\n    toPrefunctor (g âˆ˜ f) = Â«expr â‹™q Â» (toPrefunctor f) (toPrefunctor g) :=\n  rfl\n#align to_prefunctor_comp to_prefunctor_comp\n\n",
 "path_to_list_to_path":
 "theorem path_to_list_to_path {x : SingleObj Î±} (p : Path (star Î±) x) :\n    listToPath (pathToList p) = p.cast rfl unit.ext :=\n  by\n  induction' p with y z p a ih\n  rfl\n  tidy\n#align path_to_list_to_path path_to_list_to_path\n\n",
 "path_equiv_list_symm_nil":
 "@[simp]\ntheorem path_equiv_list_symm_nil : pathEquivList.symm ([] : List Î±) = path.nil :=\n  rfl\n#align path_equiv_list_symm_nil path_equiv_list_symm_nil\n\n",
 "path_equiv_list_symm_cons":
 "@[simp]\ntheorem path_equiv_list_symm_cons (l : List Î±) (a : Î±) :\n    pathEquivList.symm (a :: l) = path.cons (pathEquivList.symm l) a :=\n  rfl\n#align path_equiv_list_symm_cons path_equiv_list_symm_cons\n\n",
 "path_equiv_list_nil":
 "@[simp]\ntheorem path_equiv_list_nil : pathEquivList path.nil = ([] : List Î±) :=\n  rfl\n#align path_equiv_list_nil path_equiv_list_nil\n\n",
 "path_equiv_list_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem path_equiv_list_cons (p : Path (star Î±) (star Î±)) (a : Â«expr âŸ¶ Â» (star Î±) (star Î±)) :\n    pathEquivList (path.cons p a) = a :: pathToList p :=\n  rfl\n#align path_equiv_list_cons path_equiv_list_cons\n\n",
 "list_to_path_to_list":
 "theorem list_to_path_to_list (l : List Î±) : pathToList (listToPath l) = l :=\n  by\n  induction' l with a l ih\n  rfl\n  simp [ih]\n#align list_to_path_to_list list_to_path_to_list\n\n"}