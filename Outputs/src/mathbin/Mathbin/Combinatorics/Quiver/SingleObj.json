{"to_prefunctor_symm_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­qÂ» -/\n@[simp]\ntheorem to_prefunctor_symm_id : to_prefunctor.symm ((Â«exprğŸ­qÂ») (single_obj Î±)) = id :=\n  rfl\n#align to_prefunctor_symm_id to_prefunctor_symm_id\n\n",
 "to_prefunctor_symm_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â¥¤q Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\n@[simp]\ntheorem to_prefunctor_symm_comp (f : Â«expr â¥¤q Â» (single_obj Î±) (single_obj Î²))\n    (g : Â«expr â¥¤q Â» (single_obj Î²) (single_obj Î³)) :\n    to_prefunctor.symm (Â«expr â‹™q Â» f g) = to_prefunctor.symm g âˆ˜ to_prefunctor.symm f := by\n  simp only [equiv.symm_apply_eq, to_prefunctor_comp, equiv.apply_symm_apply]\n#align to_prefunctor_symm_comp to_prefunctor_symm_comp\n\n",
 "to_prefunctor_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprğŸ­qÂ» -/\n/-\nCopyright (c) 2023 Antoine Labelle. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Antoine Labelle\n-/\n-- See note [reducible non-instances]\n-- See note [reducible non-instances]\ntheorem to_prefunctor_id : to_prefunctor id = (Â«exprğŸ­qÂ») (single_obj Î±) :=\n  rfl\n#align to_prefunctor_id to_prefunctor_id\n\n",
 "to_prefunctor_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‹™q Â» -/\ntheorem to_prefunctor_comp (f : Î± â†’ Î²) (g : Î² â†’ Î³) :\n    to_prefunctor (g âˆ˜ f) = Â«expr â‹™q Â» (to_prefunctor f) (to_prefunctor g) :=\n  rfl\n#align to_prefunctor_comp to_prefunctor_comp\n\n",
 "path_to_list_to_path":
 "theorem path_to_list_to_path {x : single_obj Î±} (p : path (star Î±) x) :\n    list_to_path (path_to_list p) = p.cast rfl unit.ext :=\n  by\n  induction' p with y z p a ih\n  rfl\n  tidy\n#align path_to_list_to_path path_to_list_to_path\n\n",
 "path_equiv_list_symm_nil":
 "@[simp]\ntheorem path_equiv_list_symm_nil : path_equiv_list.symm ([] : list Î±) = path.nil :=\n  rfl\n#align path_equiv_list_symm_nil path_equiv_list_symm_nil\n\n",
 "path_equiv_list_symm_cons":
 "@[simp]\ntheorem path_equiv_list_symm_cons (l : list Î±) (a : Î±) :\n    path_equiv_list.symm (a :: l) = path.cons (path_equiv_list.symm l) a :=\n  rfl\n#align path_equiv_list_symm_cons path_equiv_list_symm_cons\n\n",
 "path_equiv_list_nil":
 "@[simp]\ntheorem path_equiv_list_nil : path_equiv_list path.nil = ([] : list Î±) :=\n  rfl\n#align path_equiv_list_nil path_equiv_list_nil\n\n",
 "path_equiv_list_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŸ¶ Â» -/\n@[simp]\ntheorem path_equiv_list_cons (p : path (star Î±) (star Î±)) (a : Â«expr âŸ¶ Â» (star Î±) (star Î±)) :\n    path_equiv_list (path.cons p a) = a :: path_to_list p :=\n  rfl\n#align path_equiv_list_cons path_equiv_list_cons\n\n",
 "list_to_path_to_list":
 "theorem list_to_path_to_list (l : list Î±) : path_to_list (list_to_path l) = l :=\n  by\n  induction' l with a l ih\n  rfl\n  simp [ih]\n#align list_to_path_to_list list_to_path_to_list\n\n"}