{"transpose_adj_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem transpose_adj_matrix [Zero α] [One α] : matrix.transpose (G.adj_matrix α) = G.adj_matrix α :=\n  by\n  ext\n  simp [adj_comm]\n#align transpose_adj_matrix transpose_adj_matrix\n\n",
 "trace_adj_matrix":
 "@[simp]\ntheorem trace_adj_matrix [AddCommMonoid α] [One α] : Matrix.trace (G.adj_matrix α) = 0 := by simp [Matrix.trace]\n#align trace_adj_matrix trace_adj_matrix\n\n",
 "to_graph_compl_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem to_graph_compl_eq [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) :\n    h.compl.to_graph = «expr ᶜ» h.to_graph := by\n  ext (v w)\n  cases' h.zero_or_one v w with h h <;> by_cases hvw : v = w <;> simp [Matrix.compl, h, hvw]\n#align to_graph_compl_eq to_graph_compl_eq\n\n",
 "to_graph_adj_matrix_eq":
 "/-- The graph induced by the adjacency matrix of `G` is `G` itself. -/\ntheorem to_graph_adj_matrix_eq [MulZeroOneClass α] [Nontrivial α] : (G.is_adj_matrix_adj_matrix α).to_graph = G :=\n  by\n  ext\n  simp only [is_adj_matrix.to_graph_adj, adj_matrix_apply, ite_eq_left_iff, zero_ne_one]\n  apply Classical.not_not\n#align to_graph_adj_matrix_eq to_graph_adj_matrix_eq\n\n",
 "mul_adj_matrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem mul_adj_matrix_apply [NonAssocSemiring α] (M : Matrix V V α) (v w : V) :\n    (matrix.mul M (G.adj_matrix α)) v w =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (G.neighbor_finset w) (M v u) :=\n  by simp [mul_apply, neighbor_finset_eq_filter, sum_filter, adj_comm]\n#align mul_adj_matrix_apply mul_adj_matrix_apply\n\n",
 "is_symm_compl":
 "@[simp]\ntheorem is_symm_compl [Zero α] [One α] (h : A.is_symm) : A.compl.is_symm :=\n  by\n  ext\n  simp [compl, h.apply, eq_comm]\n#align is_symm_compl is_symm_compl\n\n",
 "is_symm_adj_matrix":
 "@[simp]\ntheorem is_symm_adj_matrix [Zero α] [One α] : (G.adj_matrix α).is_symm :=\n  transpose_adjMatrix G\n#align is_symm_adj_matrix is_symm_adj_matrix\n\n",
 "is_adj_matrix_compl":
 "@[simp]\ntheorem is_adj_matrix_compl [Zero α] [One α] (h : A.is_symm) : IsAdjMatrix A.compl :=\n  { symm := by simp [h] }\n#align is_adj_matrix_compl is_adj_matrix_compl\n\n",
 "is_adj_matrix_adj_matrix":
 "/-- The adjacency matrix of `G` is an adjacency matrix. -/\n@[simp]\ntheorem is_adj_matrix_adj_matrix [Zero α] [One α] : (G.adj_matrix α).is_adj_matrix :=\n  { zero_or_one := fun i j => by by_cases G.adj i j <;> simp [h] }\n#align is_adj_matrix_adj_matrix is_adj_matrix_adj_matrix\n\n",
 "dot_product_adj_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem dot_product_adj_matrix [NonAssocSemiring α] (v : V) (vec : V → α) :\n    dotProduct vec (G.adj_matrix α v) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (G.neighbor_finset v) (vec u) :=\n  by simp [neighbor_finset_eq_filter, dot_product, sum_filter, Finset.sum_apply]\n#align dot_product_adj_matrix dot_product_adj_matrix\n\n",
 "compl_apply_diag":
 "@[simp]\ntheorem compl_apply_diag [Zero α] [One α] (i : V) : A.compl i i = 0 := by simp [compl]\n#align compl_apply_diag compl_apply_diag\n\n",
 "compl_apply":
 "@[simp]\ntheorem compl_apply [Zero α] [One α] (i j : V) : A.compl i j = 0 ∨ A.compl i j = 1 :=\n  by\n  unfold compl\n  split_ifs <;> simp\n#align compl_apply compl_apply\n\n",
 "compl":
 "@[simp]\ntheorem compl [Zero α] [One α] (h : IsAdjMatrix A) : IsAdjMatrix A.compl :=\n  isAdjMatrix_compl A h.symm\n#align compl compl\n\n",
 "apply_ne_zero_iff":
 "@[simp]\ntheorem apply_ne_zero_iff [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) (i j : V) : ¬A i j = 0 ↔ A i j = 1 :=\n  by rw [← apply_ne_one_iff h, Classical.not_not]\n#align apply_ne_zero_iff apply_ne_zero_iff\n\n",
 "apply_ne_one_iff":
 "@[simp]\ntheorem apply_ne_one_iff [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) (i j : V) : ¬A i j = 1 ↔ A i j = 0 := by\n  obtain h | h := h.zero_or_one i j <;> simp [h]\n#align apply_ne_one_iff apply_ne_one_iff\n\n",
 "apply_diag_ne":
 "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson, Jalex Stark, Kyle Miller, Lu-Ming Zhang\n-/\n@[simp]\ntheorem apply_diag_ne [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) (i : V) : ¬A i i = 1 := by\n  simp [h.apply_diag i]\n#align apply_diag_ne apply_diag_ne\n\n",
 "adj_matrix_vec_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem adj_matrix_vec_mul_apply [NonAssocSemiring α] (v : V) (vec : V → α) :\n    ((G.adj_matrix α).vec_mul vec) v =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (G.neighbor_finset v) (vec u) :=\n  by\n  rw [← dot_product_adj_matrix, vec_mul]\n  refine' congr rfl _; ext\n  rw [← transpose_apply (adj_matrix α G) x v, transpose_adj_matrix]\n#align adj_matrix_vec_mul_apply adj_matrix_vec_mul_apply\n\n",
 "adj_matrix_to_graph_eq":
 "/-- If `A` is qualified as an adjacency matrix,\n    then the adjacency matrix of the graph induced by `A` is itself. -/\ntheorem adj_matrix_to_graph_eq [DecidableEq α] : h.to_graph.adj_matrix α = A :=\n  by\n  ext (i j)\n  obtain h' | h' := h.zero_or_one i j <;> simp [h']\n#align adj_matrix_to_graph_eq adj_matrix_to_graph_eq\n\n",
 "adj_matrix_pow_apply_eq_card_walk":
 "theorem adj_matrix_pow_apply_eq_card_walk [DecidableEq V] [Semiring α] (n : ℕ) (u v : V) :\n    (G.adj_matrix α ^ n) u v = Fintype.card { p : G.walk u v | p.length = n } :=\n  by\n  rw [card_set_walk_length_eq]\n  induction' n with n ih generalizing u v\n  · obtain rfl | h := eq_or_ne u v <;> simp [finset_walk_length, *]\n  · nth_rw 1 [Nat.succ_eq_one_add]\n    simp only [pow_add, pow_one, finset_walk_length, ih, mul_eq_mul, adj_matrix_mul_apply]\n    rw [Finset.card_bunionᵢ]\n    · norm_cast\n      simp only [Nat.cast_sum, card_map, neighbor_finset_def]\n      apply Finset.sum_toFinset_eq_subtype\n    -- Disjointness for card_bUnion\n    · rintro ⟨x, hx⟩ - ⟨y, hy⟩ - hxy\n      rw [disjoint_iff_inf_le]\n      intro p hp\n      simp only [inf_eq_inter, mem_inter, mem_map, Function.Embedding.coeFn_mk, exists_prop] at hp <;>\n        obtain ⟨⟨px, hpx, rfl⟩, ⟨py, hpy, hp⟩⟩ := hp\n      cases hp\n      simpa using hxy\n#align adj_matrix_pow_apply_eq_card_walk adj_matrix_pow_apply_eq_card_walk\n\n",
 "adj_matrix_mul_vec_const_apply_of_regular":
 "theorem adj_matrix_mul_vec_const_apply_of_regular [Semiring α] {d : ℕ} {a : α} (hd : G.is_regular_of_degree d) {v : V} :\n    (G.adj_matrix α).mul_vec (Function.const _ a) v = d * a := by simp [hd v]\n#align adj_matrix_mul_vec_const_apply_of_regular adj_matrix_mul_vec_const_apply_of_regular\n\n",
 "adj_matrix_mul_vec_const_apply":
 "@[simp]\ntheorem adj_matrix_mul_vec_const_apply [Semiring α] {a : α} {v : V} :\n    (G.adj_matrix α).mul_vec (Function.const _ a) v = G.degree v * a := by simp [degree]\n#align adj_matrix_mul_vec_const_apply adj_matrix_mul_vec_const_apply\n\n",
 "adj_matrix_mul_vec_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem adj_matrix_mul_vec_apply [NonAssocSemiring α] (v : V) (vec : V → α) :\n    ((G.adj_matrix α).mul_vec vec) v =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (G.neighbor_finset v) (vec u) :=\n  by rw [mul_vec, adj_matrix_dot_product]\n#align adj_matrix_mul_vec_apply adj_matrix_mul_vec_apply\n\n",
 "adj_matrix_mul_self_apply_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem adj_matrix_mul_self_apply_self [NonAssocSemiring α] (i : V) :\n    (matrix.mul (G.adj_matrix α) (G.adj_matrix α)) i i = degree G i := by simp [degree]\n#align adj_matrix_mul_self_apply_self adj_matrix_mul_self_apply_self\n\n",
 "adj_matrix_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem adj_matrix_mul_apply [NonAssocSemiring α] (M : Matrix V V α) (v w : V) :\n    (matrix.mul (G.adj_matrix α) M) v w =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (G.neighbor_finset v) (M u w) :=\n  by simp [mul_apply, neighbor_finset_eq_filter, sum_filter]\n#align adj_matrix_mul_apply adj_matrix_mul_apply\n\n",
 "adj_matrix_dot_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem adj_matrix_dot_product [NonAssocSemiring α] (v : V) (vec : V → α) :\n    dotProduct (G.adj_matrix α v) vec =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (G.neighbor_finset v) (vec u) :=\n  by simp [neighbor_finset_eq_filter, dot_product, sum_filter]\n#align adj_matrix_dot_product adj_matrix_dot_product\n\n",
 "adj_matrix_apply":
 "-- TODO: set as an equation lemma for `adj_matrix`, see mathlib4#3024\n@[simp]\ntheorem adj_matrix_apply (v w : V) [Zero α] [One α] : G.adj_matrix α v w = if G.adj v w then 1 else 0 :=\n  rfl\n#align adj_matrix_apply adj_matrix_apply\n\n"}