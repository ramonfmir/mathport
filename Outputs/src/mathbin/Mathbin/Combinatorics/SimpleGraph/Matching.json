{"to_edge_eq_to_edge_of_adj":
 "theorem is_matching.to_edge_eq_to_edge_of_adj {M : Subgraph G} {v w : V} (h : M.is_matching) (hv : v ∈ M.verts)\n    (hw : w ∈ M.verts) (ha : M.adj v w) : h.to_edge ⟨v, hv⟩ = h.to_edge ⟨w, hw⟩ := by\n  rw [h.to_edge_eq_of_adj hv ha, h.to_edge_eq_of_adj hw (M.symm ha), Subtype.mk_eq_mk, Sym2.eq_swap]\n#align is_matching.to_edge_eq_to_edge_of_adj is_matching.to_edge_eq_to_edge_of_adj\n\n",
 "to_edge_eq_of_adj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-\nCopyright (c) 2020 Alena Gusakov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alena Gusakov, Arthur Paulino, Kyle Miller\n-/\ntheorem is_matching.to_edge_eq_of_adj {M : Subgraph G} (h : M.is_matching) {v w : V} (hv : v ∈ M.verts)\n    (hvw : M.adj v w) : h.to_edge ⟨v, hv⟩ = ⟨«expr⟦ ⟧» (v, w), hvw⟩ :=\n  by\n  simp only [is_matching.to_edge, Subtype.mk_eq_mk]\n  congr\n  exact ((h (M.edge_vert hvw)).some_spec.2 w hvw).symm\n#align is_matching.to_edge_eq_of_adj is_matching.to_edge_eq_of_adj\n\n",
 "surjective":
 "theorem is_matching.to_edge.surjective {M : Subgraph G} (h : M.is_matching) : function.surjective h.to_edge :=\n  by\n  rintro ⟨e, he⟩\n  refine' Sym2.ind (fun x y he => _) e he\n  exact ⟨⟨x, M.edge_vert he⟩, h.to_edge_eq_of_adj _ he⟩\n#align is_matching.to_edge.surjective is_matching.to_edge.surjective\n\n",
 "support_eq_verts":
 "theorem is_matching.support_eq_verts {M : Subgraph G} (h : M.is_matching) : M.support = M.verts :=\n  by\n  refine' M.support_subset_verts.antisymm fun v hv => _\n  obtain ⟨w, hvw, -⟩ := h hv\n  exact ⟨_, hvw⟩\n#align is_matching.support_eq_verts is_matching.support_eq_verts\n\n",
 "is_perfect_matching_iff_forall_degree":
 "theorem is_perfect_matching_iff_forall_degree {M : Subgraph G} [∀ v, Fintype (M.neighbor_set v)] :\n    M.is_perfect_matching ↔ ∀ v, M.degree v = 1 := by simp [degree_eq_one_iff_unique_adj, is_perfect_matching_iff]\n#align is_perfect_matching_iff_forall_degree is_perfect_matching_iff_forall_degree\n\n",
 "is_perfect_matching_iff":
 "theorem is_perfect_matching_iff : M.is_perfect_matching ↔ ∀ v, ∃! w, M.adj v w :=\n  by\n  refine' ⟨_, fun hm => ⟨fun v hv => hm v, fun v => _⟩⟩\n  · rintro ⟨hm, hs⟩ v\n    exact hm (hs v)\n  · obtain ⟨w, hw, -⟩ := hm v\n    exact M.edge_vert hw\n#align is_perfect_matching_iff is_perfect_matching_iff\n\n",
 "is_matching_iff_forall_degree":
 "theorem is_matching_iff_forall_degree {M : Subgraph G} [∀ v : V, Fintype (M.neighbor_set v)] :\n    M.is_matching ↔ ∀ v : V, v ∈ M.verts → M.degree v = 1 := by simpa [degree_eq_one_iff_unique_adj]\n#align is_matching_iff_forall_degree is_matching_iff_forall_degree\n\n",
 "even_card":
 "theorem is_perfect_matching.even_card {M : Subgraph G} [Fintype V] (h : M.is_perfect_matching) :\n    Even (Fintype.card V) := by classical simpa [h.2.card_verts] using is_matching.even_card h.1\n#align is_perfect_matching.even_card is_perfect_matching.even_card\n\n"}