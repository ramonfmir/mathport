{"path_unique":
 "theorem is_acyclic.path_unique {G : SimpleGraph V} (h : G.is_acyclic) {v w : V} (p q : G.path v w) : p = q :=\n  by\n  obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  simp only\n  induction' p with u pu pv pw ph p ih generalizing q\n  · rw [walk.is_path_iff_eq_nil] at hq\n    exact hq.symm\n  · rw [is_acyclic_iff_forall_adj_is_bridge] at h\n    specialize h ph\n    rw [is_bridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [walk.edges_append, walk.edges_reverse, list.mem_append, List.mem_reverse'] at h\n    cases h\n    · cases q\n      · simpa [walk.is_path_def] using hp\n      · rw [walk.cons_is_path_iff] at hp hq\n        simp only [walk.edges_cons, List.mem_cons, Sym2.eq_iff] at h\n        obtain (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h := h\n        · rw [ih hp.1 _ hq.1]\n        · simpa using hq\n        · exact absurd (walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [walk.cons_is_path_iff] at hp\n      exact absurd (walk.fst_mem_support_of_mem_edges _ h) hp.2\n#align is_acyclic.path_unique is_acyclic.path_unique\n\n",
 "is_tree_iff_exists_unique_path":
 "theorem is_tree_iff_exists_unique_path : G.is_tree ↔ Nonempty V ∧ ∀ v w : V, ∃! p : G.walk v w, p.is_path := by\n  classical\n    rw [is_tree_iff, is_acyclic_iff_path_unique]\n    constructor\n    · rintro ⟨hc, hu⟩\n      refine' ⟨hc.nonempty, _⟩\n      intro v w\n      let q := (hc v w).some.to_path\n      use q\n      simp only [true_and_iff, path.is_path]\n      intro p hp\n      specialize hu ⟨p, hp⟩ q\n      exact subtype.ext_iff.mp hu\n    · rintro ⟨hV, h⟩\n      refine' ⟨connected.mk _, _⟩\n      · intro v w\n        obtain ⟨p, hp⟩ := h v w\n        exact p.reachable\n      · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n        simp only [ExistsUnique.unique (h v w) hp hq]\n#align is_tree_iff_exists_unique_path is_tree_iff_exists_unique_path\n\n",
 "is_acyclic_of_path_unique":
 "theorem is_acyclic_of_path_unique (h : ∀ (v w : V) (p q : G.path v w), p = q) : G.is_acyclic :=\n  by\n  intro v c hc\n  simp only [walk.is_cycle_def, ne.def] at hc\n  cases c\n  · exact absurd rfl hc.2.1\n  · simp only [walk.cons_is_trail_iff, not_false_iff, walk.support_cons, List.tail_cons, true_and_iff] at hc\n    specialize h _ _ ⟨c_p, by simp only [walk.is_path_def, hc.2]⟩ (path.singleton (G.symm c_h))\n    simp only [path.singleton] at h\n    simpa [-Quotient.eq', Sym2.eq_swap, h] using hc\n#align is_acyclic_of_path_unique is_acyclic_of_path_unique\n\n",
 "is_acyclic_iff_path_unique":
 "theorem is_acyclic_iff_path_unique : G.is_acyclic ↔ ∀ ⦃v w : V⦄ (p q : G.path v w), p = q :=\n  ⟨IsAcyclic.path_unique, isAcyclic_of_path_unique⟩\n#align is_acyclic_iff_path_unique is_acyclic_iff_path_unique\n\n",
 "is_acyclic_iff_forall_edge_is_bridge":
 "theorem is_acyclic_iff_forall_edge_is_bridge : G.is_acyclic ↔ ∀ ⦃e⦄, e ∈ G.edge_set → G.is_bridge e := by\n  simp [is_acyclic_iff_forall_adj_is_bridge, Sym2.forall]\n#align is_acyclic_iff_forall_edge_is_bridge is_acyclic_iff_forall_edge_is_bridge\n\n",
 "is_acyclic_iff_forall_adj_is_bridge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n-/\ntheorem is_acyclic_iff_forall_adj_is_bridge : G.is_acyclic ↔ ∀ ⦃v w : V⦄, G.adj v w → G.is_bridge («expr⟦ ⟧» (v, w)) :=\n  by\n  simp_rw [is_bridge_iff_adj_and_forall_cycle_not_mem]\n  constructor\n  · intro ha v w hvw\n    apply and.intro hvw\n    intro u p hp\n    exact absurd hp (ha _ p)\n  · rintro hb v (_ | @⟨_, _, _, ha, p⟩) hp\n    · exact hp.not_of_nil\n    · specialize hb ha\n      apply hb.2 _ hp\n      rw [walk.edges_cons]\n      apply list.mem_cons_self\n#align is_acyclic_iff_forall_adj_is_bridge is_acyclic_iff_forall_adj_is_bridge\n\n"}