{"sum_inc_matrix_apply_of_not_mem_edge_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_inc_matrix_apply_of_not_mem_edge_set (h : e ∉ G.edge_set) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (G.inc_matrix R a e) =\n      0 :=\n  sum_eq_zero fun a _ => G.inc_matrix_of_not_mem_incidence_set fun he => h he.1\n#align sum_inc_matrix_apply_of_not_mem_edge_set sum_inc_matrix_apply_of_not_mem_edge_set\n\n",
 "sum_inc_matrix_apply_of_mem_edge_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_inc_matrix_apply_of_mem_edge_set :\n    e ∈ G.edge_set →\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (G.inc_matrix R a e) =\n        2 :=\n  by\n  classical\n    refine' e.ind _\n    intro a b h\n    rw [mem_edge_set] at h\n    rw [← Nat.cast_two, ← card_doubleton h.ne]\n    simp only [inc_matrix_apply', sum_boole, mk_mem_incidence_set_iff, h, true_and_iff]\n    congr 2\n    ext e\n    simp only [mem_filter, mem_univ, true_and_iff, mem_insert, mem_singleton]\n#align sum_inc_matrix_apply_of_mem_edge_set sum_inc_matrix_apply_of_mem_edge_set\n\n",
 "sum_inc_matrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_inc_matrix_apply [DecidableEq α] [DecidableRel G.adj] :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (G.inc_matrix R a e) =\n      G.degree a :=\n  by simp [inc_matrix_apply', sum_boole, Set.filter_mem_univ_eq_toFinset]\n#align sum_inc_matrix_apply sum_inc_matrix_apply\n\n",
 "inc_matrix_transpose_mul_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem inc_matrix_transpose_mul_diag [DecidableRel G.adj] :\n    (matrix.mul (matrix.transpose (G.inc_matrix R)) (G.inc_matrix R)) e e = if e ∈ G.edge_set then 2 else 0 := by\n  classical\n    simp only [Matrix.mul_apply, inc_matrix_apply', transpose_apply, ← ite_and_mul_zero, one_mul, sum_boole,\n      and_self_iff]\n    split_ifs with h\n    · revert h\n      refine' e.ind _\n      intro v w h\n      rw [← Nat.cast_two, ← card_doubleton (G.ne_of_adj h)]\n      simp [mk_mem_incidence_set_iff, G.mem_edge_set.mp h]\n      congr 2\n      ext u\n      simp\n    · revert h\n      refine' e.ind _\n      intro v w h\n      simp [mk_mem_incidence_set_iff, G.mem_edge_set.not.mp h]\n#align inc_matrix_transpose_mul_diag inc_matrix_transpose_mul_diag\n\n",
 "inc_matrix_of_not_mem_incidence_set":
 "theorem inc_matrix_of_not_mem_incidence_set (h : e ∉ G.incidence_set a) : G.inc_matrix R a e = 0 := by\n  rw [inc_matrix_apply, Set.indicator_of_not_mem h]\n#align inc_matrix_of_not_mem_incidence_set inc_matrix_of_not_mem_incidence_set\n\n",
 "inc_matrix_of_mem_incidence_set":
 "theorem inc_matrix_of_mem_incidence_set (h : e ∈ G.incidence_set a) : G.inc_matrix R a e = 1 := by\n  rw [inc_matrix_apply, Set.indicator_of_mem h, Pi.one_apply]\n#align inc_matrix_of_mem_incidence_set inc_matrix_of_mem_incidence_set\n\n",
 "inc_matrix_mul_transpose_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem inc_matrix_mul_transpose_diag [DecidableEq α] [DecidableRel G.adj] :\n    (matrix.mul (G.inc_matrix R) (matrix.transpose (G.inc_matrix R))) a a = G.degree a :=\n  by\n  rw [← sum_inc_matrix_apply]\n  simp [Matrix.mul_apply, inc_matrix_apply', ← ite_and_mul_zero]\n#align inc_matrix_mul_transpose_diag inc_matrix_mul_transpose_diag\n\n",
 "inc_matrix_mul_transpose_apply_of_adj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem inc_matrix_mul_transpose_apply_of_adj (h : G.adj a b) :\n    (matrix.mul (G.inc_matrix R) (matrix.transpose (G.inc_matrix R))) a b = (1 : R) := by\n  classical\n    simp_rw [Matrix.mul_apply, Matrix.transpose_apply, inc_matrix_apply_mul_inc_matrix_apply, Set.indicator_apply,\n      Pi.one_apply, sum_boole]\n    convert Nat.cast_one\n    convert card_singleton («expr⟦ ⟧» (a, b))\n    rw [← coe_eq_singleton, coe_filter_univ]\n    exact G.incidence_set_inter_incidence_set_of_adj h\n#align inc_matrix_mul_transpose_apply_of_adj inc_matrix_mul_transpose_apply_of_adj\n\n",
 "inc_matrix_mul_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem inc_matrix_mul_transpose [Fintype α] [DecidableEq α] [DecidableRel G.adj] :\n    matrix.mul (G.inc_matrix R) (matrix.transpose (G.inc_matrix R)) = fun a b =>\n      if a = b then G.degree a else if G.adj a b then 1 else 0 :=\n  by\n  ext (a b)\n  split_ifs with h h'\n  · subst b\n    convert G.inc_matrix_mul_transpose_diag\n  · exact G.inc_matrix_mul_transpose_apply_of_adj h'\n  ·\n    simp only [Matrix.mul_apply, Matrix.transpose_apply, G.inc_matrix_apply_mul_inc_matrix_apply_of_not_adj h h',\n      sum_const_zero]\n#align inc_matrix_mul_transpose inc_matrix_mul_transpose\n\n",
 "inc_matrix_apply_mul_inc_matrix_apply_of_not_adj":
 "theorem inc_matrix_apply_mul_inc_matrix_apply_of_not_adj (hab : a ≠ b) (h : ¬G.adj a b) :\n    G.inc_matrix R a e * G.inc_matrix R b e = 0 :=\n  by\n  rw [inc_matrix_apply_mul_inc_matrix_apply, Set.indicator_of_not_mem]\n  rw [G.incidence_set_inter_incidence_set_of_not_adj h hab]\n  exact Set.not_mem_empty e\n#align inc_matrix_apply_mul_inc_matrix_apply_of_not_adj inc_matrix_apply_mul_inc_matrix_apply_of_not_adj\n\n",
 "inc_matrix_apply_mul_inc_matrix_apply":
 "theorem inc_matrix_apply_mul_inc_matrix_apply :\n    G.inc_matrix R a e * G.inc_matrix R b e = (G.incidence_set a ∩ G.incidence_set b).indicator 1 e := by\n  classical simp only [inc_matrix, Set.indicator_apply, ← ite_and_mul_zero, Pi.one_apply, mul_one, Set.mem_inter_iff]\n#align inc_matrix_apply_mul_inc_matrix_apply inc_matrix_apply_mul_inc_matrix_apply\n\n",
 "inc_matrix_apply_eq_zero_iff":
 "theorem inc_matrix_apply_eq_zero_iff : G.inc_matrix R a e = 0 ↔ e ∉ G.incidence_set a :=\n  by\n  simp only [inc_matrix_apply, Set.indicator_apply_eq_zero, Pi.one_apply, one_ne_zero]\n  exact iff.rfl\n#align inc_matrix_apply_eq_zero_iff inc_matrix_apply_eq_zero_iff\n\n",
 "inc_matrix_apply_eq_one_iff":
 "theorem inc_matrix_apply_eq_one_iff : G.inc_matrix R a e = 1 ↔ e ∈ G.incidence_set a :=\n  by\n  convert one_ne_zero.ite_eq_left_iff\n  infer_instance\n#align inc_matrix_apply_eq_one_iff inc_matrix_apply_eq_one_iff\n\n",
 "inc_matrix_apply'":
 "/-- Entries of the incidence matrix can be computed given additional decidable instances. -/\ntheorem inc_matrix_apply' [Zero R] [One R] [DecidableEq α] [DecidableRel G.adj] {a : α} {e : Sym2 α} :\n    G.inc_matrix R a e = if e ∈ G.incidence_set a then 1 else 0 := by convert rfl\n#align inc_matrix_apply' inc_matrix_apply'\n\n",
 "inc_matrix_apply":
 "/-\nCopyright (c) 2021 Gabriel Moise. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Gabriel Moise, Yaël Dillies, Kyle Miller\n-/\ntheorem inc_matrix_apply [Zero R] [One R] {a : α} {e : Sym2 α} :\n    G.inc_matrix R a e = (G.incidence_set a).indicator 1 e :=\n  rfl\n#align inc_matrix_apply inc_matrix_apply\n\n"}