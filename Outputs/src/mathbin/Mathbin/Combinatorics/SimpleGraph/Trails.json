{"mem_edges_iff":
 "theorem is_eulerian.mem_edges_iff {u v : V} {p : G.walk u v} (h : p.is_eulerian) {e : sym2 V} :\n    e ∈ p.edges ↔ e ∈ G.edge_set :=\n  ⟨fun h => p.edges_subset_edge_set h, fun he => by simpa using (h e he).ge⟩\n#align is_eulerian.mem_edges_iff is_eulerian.mem_edges_iff\n\n",
 "is_trail":
 "theorem is_eulerian.is_trail {u v : V} {p : G.walk u v} (h : p.is_eulerian) : p.is_trail :=\n  by\n  rw [is_trail_def, List.nodup_iff_count_le_one]\n  intro e\n  by_cases he : e ∈ p.edges\n  · exact (h e (edges_subset_edge_set _ he)).le\n  · simp [he]\n#align is_eulerian.is_trail is_eulerian.is_trail\n\n",
 "is_eulerian_of_forall_mem":
 "theorem is_trail.is_eulerian_of_forall_mem {u v : V} {p : G.walk u v} (h : p.is_trail)\n    (hc : ∀ e, e ∈ G.edge_set → e ∈ p.edges) : p.is_eulerian := fun e he =>\n  List.count_eq_one_of_mem h.edges_nodup (hc e he)\n#align is_trail.is_eulerian_of_forall_mem is_trail.is_eulerian_of_forall_mem\n\n",
 "is_eulerian_iff":
 "theorem is_eulerian_iff {u v : V} (p : G.walk u v) : p.is_eulerian ↔ p.is_trail ∧ ∀ e, e ∈ G.edge_set → e ∈ p.edges :=\n  by\n  constructor\n  · intro h\n    exact ⟨h.is_trail, fun _ => h.mem_edges_iff.mpr⟩\n  · rintro ⟨h, hl⟩\n    exact h.is_eulerian_of_forall_mem hl\n#align is_eulerian_iff is_eulerian_iff\n\n",
 "even_degree_iff":
 "theorem is_eulerian.even_degree_iff {x u v : V} {p : G.walk u v} (ht : p.is_eulerian) [fintype V]\n    [decidable_rel G.adj] : Even (G.degree x) ↔ u ≠ v → x ≠ u ∧ x ≠ v :=\n  by\n  convert ht.is_trail.even_countp_edges_iff x\n  rw [← Multiset.coe_countp, Multiset.countp_eq_card_filter, ← card_incidence_finset_eq_degree]\n  change Multiset.card _ = _\n  congr 1\n  convert_to _ = (ht.is_trail.edges_finset.filter (has_mem.mem x)).val\n  rw [ht.edges_finset_eq, G.incidence_finset_eq_filter x]\n#align is_eulerian.even_degree_iff is_eulerian.even_degree_iff\n\n",
 "even_countp_edges_iff":
 "/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n-/\ntheorem is_trail.even_countp_edges_iff {u v : V} {p : G.walk u v} (ht : p.is_trail) (x : V) :\n    Even (p.edges.countp fun e => x ∈ e) ↔ u ≠ v → x ≠ u ∧ x ≠ v :=\n  by\n  induction' p with u u v w huv p ih\n  · simp\n  · rw [cons_is_trail_iff] at ht\n    specialize ih ht.1\n    simp only [List.countp_cons, ne.def, edges_cons, sym2.mem_iff]\n    split_ifs with h\n    · obtain rfl | rfl := h\n      · rw [nat.even_add_one, ih]\n        simp only [huv.ne, imp_false, ne.def, not_false_iff, true_and_iff, not_forall, not_not, exists_prop,\n          eq_self_iff_true, not_true, false_and_iff, and_iff_right_iff_imp]\n        rintro rfl rfl\n        exact G.loopless _ huv\n      · rw [nat.even_add_one, ih, ← not_iff_not]\n        simp only [huv.ne.symm, ne.def, eq_self_iff_true, not_true, false_and_iff, not_forall, not_false_iff,\n          exists_prop, and_true_iff, not_not, true_and_iff, iff_and_self]\n        rintro rfl\n        exact huv.ne\n    · rw [not_or] at h\n      simp only [h.1, h.2, not_false_iff, true_and_iff, add_zero, ne.def] at ih⊢\n      rw [ih]\n      constructor <;>\n        · rintro h' h'' rfl\n          simp only [imp_false, eq_self_iff_true, not_true, not_not] at h'\n          cases h'\n          simpa using h\n#align is_trail.even_countp_edges_iff is_trail.even_countp_edges_iff\n\n",
 "edges_finset_eq":
 "theorem is_eulerian.edges_finset_eq [fintype G.edge_set] {u v : V} {p : G.walk u v} (h : p.is_eulerian) :\n    h.is_trail.edges_finset = G.edge_finset := by\n  ext e\n  simp [h.mem_edges_iff]\n#align is_eulerian.edges_finset_eq is_eulerian.edges_finset_eq\n\n",
 "card_odd_degree":
 "theorem is_eulerian.card_odd_degree [fintype V] [decidable_rel G.adj] {u v : V} {p : G.walk u v} (ht : p.is_eulerian) :\n    fintype.card { v : V | Odd (G.degree v) } = 0 ∨ fintype.card { v : V | Odd (G.degree v) } = 2 :=\n  by\n  rw [← set.to_finset_card]\n  apply is_eulerian.card_filter_odd_degree ht\n  ext v\n  simp\n#align is_eulerian.card_odd_degree is_eulerian.card_odd_degree\n\n",
 "card_filter_odd_degree":
 "theorem is_eulerian.card_filter_odd_degree [fintype V] [decidable_rel G.adj] {u v : V} {p : G.walk u v}\n    (ht : p.is_eulerian) {s} (h : s = (finset.univ : Finset V).filter fun v => Odd (G.degree v)) :\n    s.card = 0 ∨ s.card = 2 := by\n  subst s\n  simp only [nat.odd_iff_not_even, finset.card_eq_zero]\n  simp only [ht.even_degree_iff, ne.def, not_forall, not_and, not_not, exists_prop]\n  obtain rfl | hn := eq_or_ne u v\n  · left\n    simp\n  · right\n    convert_to _ = ({u, v} : Finset V).card\n    · simp [hn]\n    · congr\n      ext x\n      simp [hn, imp_iff_not_or]\n#align is_eulerian.card_filter_odd_degree is_eulerian.card_filter_odd_degree\n\n"}