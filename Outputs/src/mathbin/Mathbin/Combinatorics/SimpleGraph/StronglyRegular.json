{"top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Complete graphs are strongly regular. Note that `μ` can take any value\n  for complete graphs, since there are no distinct pairs of non-adjacent vertices. -/\ntheorem is_SRG_with.top :\n    («expr⊤» : simple_graph V).is_SRG_with (fintype.card V) (fintype.card V - 1) (fintype.card V - 2) μ :=\n  { card := rfl\n    regular := is_regular_of_degree.top\n    of_adj := fun v w h => by\n      rw [card_common_neighbors_top]\n      exact h\n    of_not_adj := fun v w h h' => false.elim <| by simpa using h }\n#align is_SRG_with.top is_SRG_with.top\n\n",
 "sdiff_compl_neighbor_finset_inter_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem sdiff_compl_neighbor_finset_inter_eq {v w : V} (h : G.adj v w) :\n    («expr ᶜ» (G.neighbor_finset v) ∩ «expr ᶜ» (G.neighbor_finset w)) \\ ({w} ∪ {v}) =\n      «expr ᶜ» (G.neighbor_finset v) ∩ «expr ᶜ» (G.neighbor_finset w) :=\n  by\n  ext\n  simp only [and_imp, mem_union, mem_sdiff, mem_compl, and_iff_left_iff_imp, mem_neighbor_finset, mem_inter,\n    mem_singleton]\n  rintro hnv hnw (rfl | rfl)\n  · exact hnv h\n  · apply hnw\n    rwa [adj_comm]\n#align sdiff_compl_neighbor_finset_inter_eq sdiff_compl_neighbor_finset_inter_eq\n\n",
 "compl_neighbor_finset_sdiff_inter_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem compl_neighbor_finset_sdiff_inter_eq {v w : V} :\n    «expr ᶜ» (G.neighbor_finset v) \\ {v} ∩ («expr ᶜ» (G.neighbor_finset w) \\ {w}) =\n      («expr ᶜ» (G.neighbor_finset v) ∩ «expr ᶜ» (G.neighbor_finset w)) \\ ({w} ∪ {v}) :=\n  by\n  ext\n  rw [← not_iff_not]\n  simp [imp_iff_not_or, or_assoc', or_comm', or_left_comm]\n#align compl_neighbor_finset_sdiff_inter_eq compl_neighbor_finset_sdiff_inter_eq\n\n",
 "compl_is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_SRG_with.compl_is_regular (h : G.is_SRG_with n k ℓ μ) : («expr ᶜ» G).is_regular_of_degree (n - k - 1) :=\n  by\n  rw [← h.card, nat.sub_sub, add_comm, ← nat.sub_sub]\n  exact h.regular.compl\n#align is_SRG_with.compl_is_regular is_SRG_with.compl_is_regular\n\n",
 "compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem is_SRG_with.compl (h : G.is_SRG_with n k ℓ μ) :\n    («expr ᶜ» G).is_SRG_with n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ)) :=\n  { card := h.card\n    regular := h.compl_is_regular\n    of_adj := fun v w ha => h.card_common_neighbors_eq_of_adj_compl ha\n    of_not_adj := fun v w hn hna => h.card_common_neighbors_eq_of_not_adj_compl hn hna }\n#align is_SRG_with.compl is_SRG_with.compl\n\n",
 "card_neighbor_finset_union_of_not_adj":
 "/-- Assuming `G` is strongly regular, `2*(k + 1) - m` in `G` is the number of vertices that are\n  adjacent to either `v` or `w` when `¬G.adj v w`. So it's the cardinality of\n  `G.neighbor_set v ∪ G.neighbor_set w`. -/\ntheorem is_SRG_with.card_neighbor_finset_union_of_not_adj {v w : V} (h : G.is_SRG_with n k ℓ μ) (hne : v ≠ w)\n    (ha : ¬G.adj v w) : (G.neighbor_finset v ∪ G.neighbor_finset w).card = 2 * k - μ :=\n  by\n  rw [← h.of_not_adj v w hne ha]\n  apply h.card_neighbor_finset_union_eq\n#align is_SRG_with.card_neighbor_finset_union_of_not_adj is_SRG_with.card_neighbor_finset_union_of_not_adj\n\n",
 "card_neighbor_finset_union_of_adj":
 "theorem is_SRG_with.card_neighbor_finset_union_of_adj {v w : V} (h : G.is_SRG_with n k ℓ μ) (ha : G.adj v w) :\n    (G.neighbor_finset v ∪ G.neighbor_finset w).card = 2 * k - ℓ :=\n  by\n  rw [← h.of_adj v w ha]\n  apply h.card_neighbor_finset_union_eq\n#align is_SRG_with.card_neighbor_finset_union_of_adj is_SRG_with.card_neighbor_finset_union_of_adj\n\n",
 "card_neighbor_finset_union_eq":
 "theorem is_SRG_with.card_neighbor_finset_union_eq {v w : V} (h : G.is_SRG_with n k ℓ μ) :\n    (G.neighbor_finset v ∪ G.neighbor_finset w).card = 2 * k - fintype.card (G.common_neighbors v w) :=\n  by\n  apply @nat.add_right_cancel _ (fintype.card (G.common_neighbors v w))\n  rw [nat.sub_add_cancel, ← set.to_finset_card]\n  ·\n    simp [neighbor_finset, common_neighbors, set.to_finset_inter, finset.card_union_add_card_inter, h.regular.degree_eq,\n      two_mul]\n  · apply le_trans (card_common_neighbors_le_degree_left _ _ _)\n    simp [h.regular.degree_eq, two_mul]\n#align is_SRG_with.card_neighbor_finset_union_eq is_SRG_with.card_neighbor_finset_union_eq\n\n",
 "card_common_neighbors_eq_of_not_adj_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_SRG_with.card_common_neighbors_eq_of_not_adj_compl (h : G.is_SRG_with n k ℓ μ) {v w : V} (hn : v ≠ w)\n    (hna : ¬(«expr ᶜ» G).adj v w) : fintype.card («expr↥ » ((«expr ᶜ» G).common_neighbors v w)) = n - (2 * k - ℓ) :=\n  by\n  simp only [← set.to_finset_card, common_neighbors, set.to_finset_inter, neighbor_set_compl, set.to_finset_diff,\n    set.to_finset_singleton, set.to_finset_compl, ← neighbor_finset_def]\n  simp only [not_and, not_not, compl_adj] at hna\n  have h2' := hna hn\n  simp_rw [compl_neighbor_finset_sdiff_inter_eq, sdiff_compl_neighbor_finset_inter_eq h2']\n  rwa [← finset.compl_union, card_compl, h.card_neighbor_finset_union_of_adj, ← h.card]\n#align is_SRG_with.card_common_neighbors_eq_of_not_adj_compl is_SRG_with.card_common_neighbors_eq_of_not_adj_compl\n\n",
 "card_common_neighbors_eq_of_adj_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem is_SRG_with.card_common_neighbors_eq_of_adj_compl (h : G.is_SRG_with n k ℓ μ) {v w : V}\n    (ha : («expr ᶜ» G).adj v w) : fintype.card («expr↥ » ((«expr ᶜ» G).common_neighbors v w)) = n - (2 * k - μ) - 2 :=\n  by\n  simp only [← set.to_finset_card, common_neighbors, set.to_finset_inter, neighbor_set_compl, set.to_finset_diff,\n    set.to_finset_singleton, set.to_finset_compl, ← neighbor_finset_def]\n  simp_rw [compl_neighbor_finset_sdiff_inter_eq]\n  have hne : v ≠ w := ne_of_adj _ ha\n  rw [compl_adj] at ha\n  rw [card_sdiff, ← insert_eq, card_insert_of_not_mem, card_singleton, ← finset.compl_union]\n  · change 1 + 1 with 2\n    rw [card_compl, h.card_neighbor_finset_union_of_not_adj hne ha.2, ← h.card]\n  · simp only [hne.symm, not_false_iff, mem_singleton]\n  · intro u\n    simp only [mem_union, mem_compl, mem_neighbor_finset, mem_inter, mem_singleton]\n    rintro (rfl | rfl) <;> simpa [adj_comm] using ha.2\n#align is_SRG_with.card_common_neighbors_eq_of_adj_compl is_SRG_with.card_common_neighbors_eq_of_adj_compl\n\n",
 "bot_strongly_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2021 Alena Gusakov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alena Gusakov\n-/\n/-- Empty graphs are strongly regular. Note that `ℓ` can take any value\n  for empty graphs, since there are no pairs of adjacent vertices. -/\ntheorem bot_strongly_regular : («expr⊥» : simple_graph V).is_SRG_with (fintype.card V) 0 ℓ 0 :=\n  { card := rfl\n    regular := bot_degree\n    of_adj := fun v w h => h.elim\n    of_not_adj := fun v w h =>\n      by\n      simp only [card_eq_zero, filter_congr_decidable, fintype.card_of_finset, forall_true_left, not_false_iff, bot_adj]\n      ext\n      simp [mem_common_neighbors] }\n#align bot_strongly_regular bot_strongly_regular\n\n"}