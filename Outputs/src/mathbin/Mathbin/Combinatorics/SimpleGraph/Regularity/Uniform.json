{"symm":
 "theorem is_uniform.symm : symmetric (is_uniform G Îµ) := fun s t h t' ht' s' hs' ht hs =>\n  by\n  rw [edge_density_comm _ t', edge_density_comm _ t]\n  exact h hs' ht' hs ht\n#align is_uniform.symm is_uniform.symm\n\n",
 "right_nonuniform_witnesses_subset":
 "theorem right_nonuniform_witnesses_subset (h : Â¬G.is_uniform Îµ s t) : (G.nonuniform_witnesses Îµ s t).2 âŠ† t :=\n  by\n  rw [nonuniform_witnesses, dif_pos h]\n  exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.1\n#align right_nonuniform_witnesses_subset right_nonuniform_witnesses_subset\n\n",
 "right_nonuniform_witnesses_card":
 "theorem right_nonuniform_witnesses_card (h : Â¬G.is_uniform Îµ s t) :\n    (t.card : ð•œ) * Îµ â‰¤ (G.nonuniform_witnesses Îµ s t).2.card :=\n  by\n  rw [nonuniform_witnesses, dif_pos h]\n  exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.2.2.1\n#align right_nonuniform_witnesses_card right_nonuniform_witnesses_card\n\n",
 "not_is_uniform_zero":
 "theorem not_is_uniform_zero : Â¬G.is_uniform (0 : ð•œ) s t := fun h =>\n  (abs_nonneg _).not_lt <| h (empty_subset _) (empty_subset _) (by simp) (by simp)\n#align not_is_uniform_zero not_is_uniform_zero\n\n",
 "not_is_uniform_iff":
 "theorem not_is_uniform_iff :\n    Â¬G.is_uniform Îµ s t â†”\n      âˆƒ s',\n        s' âŠ† s âˆ§\n          âˆƒ t',\n            t' âŠ† t âˆ§ â†‘s.card * Îµ â‰¤ s'.card âˆ§ â†‘t.card * Îµ â‰¤ t'.card âˆ§ Îµ â‰¤ |G.edge_density s' t' - G.edge_density s t| :=\n  by\n  unfold is_uniform\n  simp only [not_forall, not_lt, exists_prop]\n#align not_is_uniform_iff not_is_uniform_iff\n\n",
 "nonuniform_witnesses_spec":
 "theorem nonuniform_witnesses_spec (h : Â¬G.is_uniform Îµ s t) :\n    Îµ â‰¤ |G.edge_density (G.nonuniform_witnesses Îµ s t).1 (G.nonuniform_witnesses Îµ s t).2 - G.edge_density s t| :=\n  by\n  rw [nonuniform_witnesses, dif_pos h]\n  exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.2.2.2\n#align nonuniform_witnesses_spec nonuniform_witnesses_spec\n\n",
 "nonuniform_witness_subset":
 "theorem nonuniform_witness_subset (h : Â¬G.is_uniform Îµ s t) : G.nonuniform_witness Îµ s t âŠ† s :=\n  by\n  unfold nonuniform_witness\n  split_ifs\n  Â· exact G.left_nonuniform_witnesses_subset h\n  Â· exact G.right_nonuniform_witnesses_subset fun i => h i.symm\n#align nonuniform_witness_subset nonuniform_witness_subset\n\n",
 "nonuniform_witness_spec":
 "theorem nonuniform_witness_spec (hâ‚ : s â‰  t) (hâ‚‚ : Â¬G.is_uniform Îµ s t) :\n    Îµ â‰¤ |G.edge_density (G.nonuniform_witness Îµ s t) (G.nonuniform_witness Îµ t s) - G.edge_density s t| :=\n  by\n  unfold nonuniform_witness\n  rcases trichotomous_of well_ordering_rel s t with (lt | rfl | gt)\n  Â· rw [if_pos lt, if_neg (asymm lt)]\n    exact G.nonuniform_witnesses_spec hâ‚‚\n  Â· cases hâ‚ rfl\n  Â· rw [if_neg (asymm GT.gt), if_pos GT.gt, edge_density_comm, edge_density_comm _ s]\n    apply G.nonuniform_witnesses_spec fun i => hâ‚‚ i.symm\n#align nonuniform_witness_spec nonuniform_witness_spec\n\n",
 "nonuniform_witness_mem_nonuniform_witnesses":
 "theorem nonuniform_witness_mem_nonuniform_witnesses (h : Â¬G.is_uniform Îµ s t) (ht : t âˆˆ P.parts) (hst : s â‰  t) :\n    G.nonuniform_witness Îµ s t âˆˆ P.nonuniform_witnesses G Îµ s :=\n  mem_image_of_mem _ <| mem_filter.2 âŸ¨ht, hst, hâŸ©\n#align nonuniform_witness_mem_nonuniform_witnesses nonuniform_witness_mem_nonuniform_witnesses\n\n",
 "nonuniform_witness_card_le":
 "theorem nonuniform_witness_card_le (h : Â¬G.is_uniform Îµ s t) : (s.card : ð•œ) * Îµ â‰¤ (G.nonuniform_witness Îµ s t).card :=\n  by\n  unfold nonuniform_witness\n  split_ifs\n  Â· exact G.left_nonuniform_witnesses_card h\n  Â· exact G.right_nonuniform_witnesses_card fun i => h i.symm\n#align nonuniform_witness_card_le nonuniform_witness_card_le\n\n",
 "nonempty_of_not_uniform":
 "theorem nonempty_of_not_uniform (h : Â¬P.is_uniform G Îµ) : P.parts.nonempty :=\n  nonempty_of_ne_empty fun hâ‚ => h <| is_uniform_of_empty hâ‚\n#align nonempty_of_not_uniform nonempty_of_not_uniform\n\n",
 "non_uniforms_mono":
 "theorem non_uniforms_mono {Îµ Îµ' : ð•œ} (h : Îµ â‰¤ Îµ') : P.non_uniforms G Îµ' âŠ† P.non_uniforms G Îµ :=\n  monotone_filter_right _ fun uv => mt <| simple_graph.is_uniform.mono h\n#align non_uniforms_mono non_uniforms_mono\n\n",
 "non_uniforms_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem non_uniforms_bot (hÎµ : 0 < Îµ) : (Â«exprâŠ¥Â» : finpartition A).non_uniforms G Îµ = âˆ… :=\n  by\n  rw [eq_empty_iff_forall_not_mem]\n  rintro âŸ¨u, vâŸ©\n  simp only [finpartition.mk_mem_non_uniforms_iff, finpartition.parts_bot, mem_map, not_and, not_not, exists_imp]\n  rintro x hx rfl y hy rfl h\n  exact G.is_uniform_singleton hÎµ\n#align non_uniforms_bot non_uniforms_bot\n\n",
 "mono":
 "theorem is_uniform.mono {Îµ Îµ' : ð•œ} (hP : P.is_uniform G Îµ) (h : Îµ â‰¤ Îµ') : P.is_uniform G Îµ' :=\n  ((nat.cast_le.2 <| card_le_of_subset <| P.non_uniforms_mono G h).trans hP).trans <|\n    mul_le_mul_of_nonneg_left h <| nat.cast_nonneg _\n#align is_uniform.mono is_uniform.mono\n\n",
 "mk_mem_non_uniforms_iff":
 "theorem mk_mem_non_uniforms_iff (u v : Finset Î±) (Îµ : ð•œ) :\n    (u, v) âˆˆ P.non_uniforms G Îµ â†” u âˆˆ P.parts âˆ§ v âˆˆ P.parts âˆ§ u â‰  v âˆ§ Â¬G.is_uniform Îµ u v := by\n  rw [non_uniforms, mem_filter, mem_off_diag, and_assoc', and_assoc']\n#align mk_mem_non_uniforms_iff mk_mem_non_uniforms_iff\n\n",
 "left_nonuniform_witnesses_subset":
 "theorem left_nonuniform_witnesses_subset (h : Â¬G.is_uniform Îµ s t) : (G.nonuniform_witnesses Îµ s t).1 âŠ† s :=\n  by\n  rw [nonuniform_witnesses, dif_pos h]\n  exact (not_is_uniform_iff.1 h).some_spec.1\n#align left_nonuniform_witnesses_subset left_nonuniform_witnesses_subset\n\n",
 "left_nonuniform_witnesses_card":
 "theorem left_nonuniform_witnesses_card (h : Â¬G.is_uniform Îµ s t) :\n    (s.card : ð•œ) * Îµ â‰¤ (G.nonuniform_witnesses Îµ s t).1.card :=\n  by\n  rw [nonuniform_witnesses, dif_pos h]\n  exact (not_is_uniform_iff.1 h).some_spec.2.some_spec.2.1\n#align left_nonuniform_witnesses_card left_nonuniform_witnesses_card\n\n",
 "is_uniform_singleton":
 "theorem is_uniform_singleton (hÎµ : 0 < Îµ) : G.is_uniform Îµ {a} {b} :=\n  by\n  intro s' hs' t' ht' hs ht\n  rw [card_singleton, Nat.cast_one, one_mul] at hs ht\n  obtain rfl | rfl := Finset.subset_singleton_iff.1 hs'\n  Â· replace hs : Îµ â‰¤ 0 := by simpa using hs\n    exact (hÎµ.not_le hs).elim\n  obtain rfl | rfl := Finset.subset_singleton_iff.1 ht'\n  Â· replace ht : Îµ â‰¤ 0 := by simpa using ht\n    exact (hÎµ.not_le ht).elim\n  Â· rwa [sub_self, abs_zero]\n#align is_uniform_singleton is_uniform_singleton\n\n",
 "is_uniform_one":
 "theorem is_uniform_one : P.is_uniform G (1 : ð•œ) :=\n  by\n  rw [is_uniform, mul_one, nat.cast_le]\n  refine' (card_filter_le _ _).trans _\n  rw [off_diag_card, nat.mul_sub_left_distrib, mul_one]\n#align is_uniform_one is_uniform_one\n\n",
 "is_uniform_of_empty":
 "theorem is_uniform_of_empty (hP : P.parts = âˆ…) : P.is_uniform G Îµ := by simp [is_uniform, hP, non_uniforms]\n#align is_uniform_of_empty is_uniform_of_empty\n\n",
 "is_uniform_comm":
 "theorem is_uniform_comm : is_uniform G Îµ s t â†” is_uniform G Îµ t s :=\n  âŸ¨fun h => h.symm, fun h => h.symmâŸ©\n#align is_uniform_comm is_uniform_comm\n\n",
 "bot_is_uniform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\ntheorem bot_is_uniform (hÎµ : 0 < Îµ) : (Â«exprâŠ¥Â» : finpartition A).is_uniform G Îµ :=\n  by\n  rw [finpartition.is_uniform, finpartition.card_bot, non_uniforms_bot _ hÎµ, finset.card_empty, Nat.cast_zero]\n  exact mul_nonneg (nat.cast_nonneg _) hÎµ.le\n#align bot_is_uniform bot_is_uniform\n\n"}