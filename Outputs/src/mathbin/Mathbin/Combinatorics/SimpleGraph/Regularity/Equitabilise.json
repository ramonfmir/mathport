{"exists_equipartition_card_eq":
 "/-- We can find equipartitions of arbitrary size. -/\ntheorem exists_equipartition_card_eq (hn : n ≠ 0) (hs : n ≤ s.card) :\n    ∃ P : Finpartition s, P.is_equipartition ∧ P.parts.card = n :=\n  by\n  rw [← pos_iff_ne_zero] at hn\n  have : (n - s.card % n) * (s.card / n) + s.card % n * (s.card / n + 1) = s.card := by\n    rw [tsub_mul, mul_add, ← add_assoc, tsub_add_cancel_of_le (nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one,\n      add_comm, mod_add_div]\n  refine' ⟨(indiscrete (card_pos.1 <| hn.trans_le hs).ne_empty).equitabilise this, equitabilise_is_equipartition, _⟩\n  rw [card_parts_equitabilise _ _ (Nat.div_pos hs hn).ne', tsub_add_cancel_of_le (mod_lt _ hn).le]\n#align exists_equipartition_card_eq exists_equipartition_card_eq\n\n",
 "equitabilise_is_equipartition":
 "theorem equitabilise_is_equipartition : (P.equitabilise h).is_equipartition :=\n  Set.equitableOn_iff_exists_eq_eq_add_one.2 ⟨m, fun u => card_eq_of_mem_parts_equitabilise⟩\n#align equitabilise_is_equipartition equitabilise_is_equipartition\n\n",
 "equitabilise_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-\nCopyright (c) 2022 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\n/-- Given a partition `P` of `s`, as well as a proof that `a * m + b * (m + 1) = s.card`, we can\nfind a new partition `Q` of `s` where each part has size `m` or `m + 1`, every part of `P` is the\nunion of parts of `Q` plus at most `m` extra elements, there are `b` parts of size `m + 1` and\n(provided `m > 0`, because a partition does not have parts of size `0`) there are `a` parts of size\n`m` and hence `a + b` parts in total. -/\ntheorem equitabilise_aux (P : Finpartition s) (hs : a * m + b * (m + 1) = s.card) :\n    ∃ Q : Finpartition s,\n      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧\n        (∀ x, x ∈ P.parts → (x \\ (Q.parts.filter fun y => y ⊆ x).bUnion id).card ≤ m) ∧\n          (Q.parts.filter fun i => card i = m + 1).card = b :=\n  by\n  -- Get rid of the easy case `m = 0`\n  obtain rfl | m_pos := m.eq_zero_or_pos\n  · refine' ⟨«expr⊥», by simp, _, by simpa using hs.symm⟩\n    simp only [le_zero_iff, card_eq_zero, mem_bUnion, exists_prop, mem_filter, id.def, and_assoc',\n      sdiff_eq_empty_iff_subset, subset_iff]\n    exact fun x hx a ha => ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩\n  -- Prove the case `m > 0` by strong induction on `s`\n  induction' s using Finset.strongInduction with s ih generalizing P a b\n  -- If `a = b = 0`, then `s = ∅` and we can partition into zero parts\n  by_cases hab : a = 0 ∧ b = 0\n  · simp only [hab.1, hab.2, add_zero, MulZeroClass.zero_mul, eq_comm, card_eq_zero] at hs\n    subst hs\n    exact ⟨Finpartition.empty _, by simp, by simp [Unique.eq_default P], by simp [hab.2]⟩\n  simp_rw [not_and_or, ← ne.def, ← pos_iff_ne_zero] at hab\n  -- `n` will be the size of the smallest part\n  set n := if 0 < a then m else m + 1 with hn\n  -- Some easy facts about it\n  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ :\n    0 < n ∧\n      n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧ ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n :=\n    by\n    rw [hn, ← hs]\n    split_ifs <;> rw [tsub_mul, one_mul]\n    · refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]\n    · refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]\n  /- We will call the inductive hypothesis on a partition of `s \\ t` for a carefully chosen `t ⊆ s`.\n    To decide which, however, we must distinguish the case where all parts of `P` have size `m` (in\n    which case we take `t` to be an arbitrary subset of `s` of size `n`) from the case where at least\n    one part `u` of `P` has size `m + 1` (in which case we take `t` to be an arbitrary subset of `u`\n    of size `n`). The rest of each branch is just tedious calculations to satisfy the induction\n    hypothesis. -/\n  by_cases ∀ u ∈ P.parts, card u < m + 1\n  · obtain ⟨t, hts, htn⟩ := exists_smaller_set s n (hn₂.trans_eq hs)\n    have ht : t.nonempty := by rwa [← card_pos, htn]\n    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]\n    obtain ⟨R, hR₁, hR₂, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.nonempty›) (P.avoid t) (if 0 < a then a - 1 else a) (if 0 < a then b else b - 1)\n        hcard\n    refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _⟩\n    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _\n    · exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)\n    simp_rw [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]\n    split_ifs with ha\n    · rw [hR₃, if_pos ha]\n    rw [card_insert_of_not_mem fun H => _, hR₃, if_neg ha, tsub_add_cancel_of_le]\n    · exact hab.resolve_left ha\n    · exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)\n  push_neg  at h\n  obtain ⟨u, hu₁, hu₂⟩ := h\n  obtain ⟨t, htu, htn⟩ := exists_smaller_set _ _ (hn₁.trans hu₂)\n  have ht : t.nonempty := by rwa [← card_pos, htn]\n  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]\n  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=\n    @ih (s \\ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (P.avoid t) (if 0 < a then a - 1 else a)\n      (if 0 < a then b else b - 1) hcard\n  refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), _, _, _⟩\n  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]\n    exact ite_eq_or_eq _ _ _\n  · conv in _ ∈ _ => rw [← insert_erase hu₁]\n    simp only [and_imp, mem_insert, forall_eq_or_imp, ne.def, extend_parts]\n    refine' ⟨_, fun x hx => (card_le_of_subset _).trans <| hR₂ x _⟩\n    · simp only [filter_insert, if_pos htu, bUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      simp only [not_exists, mem_bUnion, and_imp, mem_union, mem_filter, mem_sdiff, id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ => ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩\n    · apply sdiff_subset_sdiff subset.rfl (bUnion_subset_bUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)\n    simp only [avoid, of_erase, mem_erase, mem_image, bot_eq_empty]\n    exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <| P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩\n  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]\n  split_ifs\n  · rw [hR₃, if_pos h]\n  · rw [card_insert_of_not_mem fun H => _, hR₃, if_neg h, nat.sub_add_cancel (hab.resolve_left h)]\n    exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)\n#align equitabilise_aux equitabilise_aux\n\n",
 "card_parts_equitabilise_subset_le":
 "theorem card_parts_equitabilise_subset_le :\n    t ∈ P.parts → (t \\ ((P.equitabilise h).parts.filter fun u => u ⊆ t).bUnion id).card ≤ m :=\n  (Classical.choose_spec <| P.equitabilise_aux h).2.1 t\n#align card_parts_equitabilise_subset_le card_parts_equitabilise_subset_le\n\n",
 "card_parts_equitabilise":
 "theorem card_parts_equitabilise (hm : m ≠ 0) : (P.equitabilise h).parts.card = a + b :=\n  by\n  rw [← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise, filter_or, card_union_eq,\n    P.card_filter_equitabilise_small _ hm, P.card_filter_equitabilise_big]\n  exact disjoint_filter.2 fun x _ h₀ h₁ => nat.succ_ne_self m <| h₁.symm.trans h₀\n  infer_instance\n#align card_parts_equitabilise card_parts_equitabilise\n\n",
 "card_filter_equitabilise_small":
 "theorem card_filter_equitabilise_small (hm : m ≠ 0) :\n    ((P.equitabilise h).parts.filter fun u : Finset α => u.card = m).card = a :=\n  by\n  refine' (mul_eq_mul_right_iff.1 <| (add_left_inj (b * (m + 1))).1 _).resolve_right hm\n  rw [h, ← (P.equitabilise h).sum_card_parts]\n  have hunion :\n    (P.equitabilise h).parts =\n      ((P.equitabilise h).parts.filter fun u => u.card = m) ∪ (P.equitabilise h).parts.filter fun u => u.card = m + 1 :=\n    by\n    rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise\n  nth_rw 2 [hunion]\n  rw [sum_union, sum_const_nat fun x hx => (mem_filter.1 hx).2, sum_const_nat fun x hx => (mem_filter.1 hx).2,\n    P.card_filter_equitabilise_big]\n  refine' disjoint_filter_filter' _ _ _\n  intro x ha hb i h\n  apply succ_ne_self m _\n  exact (hb i h).symm.trans (ha i h)\n#align card_filter_equitabilise_small card_filter_equitabilise_small\n\n",
 "card_filter_equitabilise_big":
 "theorem card_filter_equitabilise_big : ((P.equitabilise h).parts.filter fun u : Finset α => u.card = m + 1).card = b :=\n  (P.equitabilise_aux h).some_spec.2.2\n#align card_filter_equitabilise_big card_filter_equitabilise_big\n\n",
 "card_eq_of_mem_parts_equitabilise":
 "theorem card_eq_of_mem_parts_equitabilise : t ∈ (P.equitabilise h).parts → t.card = m ∨ t.card = m + 1 :=\n  (P.equitabilise_aux h).some_spec.1 _\n#align card_eq_of_mem_parts_equitabilise card_eq_of_mem_parts_equitabilise\n\n"}