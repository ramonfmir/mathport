{"of_box_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\nprotected theorem connected.of_box_prod_right (h : («expr □ » G H).connected) : H.connected :=\n  by\n  haveI := (nonempty_prod.1 h.nonempty).1\n  haveI := (nonempty_prod.1 h.nonempty).2\n  exact ⟨h.preconnected.of_box_prod_right⟩\n#align connected.of_box_prod_right connected.of_box_prod_right\n\n",
 "of_box_prod_left_box_prod_right":
 "@[simp]\ntheorem of_box_prod_left_box_prod_right [decidable_eq α] [decidable_rel G.adj] :\n    ∀ {b₁ b₂ : α} (w : G.walk b₁ b₂), (w.box_prod_right G a).of_box_prod_right = w\n  | _, _, nil => rfl\n  | _, _, cons' x y z h w =>\n    by\n    rw [walk.box_prod_right, map_cons, of_box_prod_right, Or.by_cases, dif_pos, ← walk.box_prod_right,\n      of_box_prod_left_box_prod_right]\n    exacts[rfl, ⟨h, rfl⟩]\n#align of_box_prod_left_box_prod_right of_box_prod_left_box_prod_right\n\n",
 "of_box_prod_left_box_prod_left":
 "@[simp]\ntheorem of_box_prod_left_box_prod_left [decidable_eq β] [decidable_rel G.adj] :\n    ∀ {a₁ a₂ : α} (w : G.walk a₁ a₂), (w.box_prod_left H b).of_box_prod_left = w\n  | _, _, nil => rfl\n  | _, _, cons' x y z h w =>\n    by\n    rw [walk.box_prod_left, map_cons, of_box_prod_left, Or.by_cases, dif_pos, ← walk.box_prod_left,\n      of_box_prod_left_box_prod_left]\n    exacts[rfl, ⟨h, rfl⟩]\n#align of_box_prod_left_box_prod_left of_box_prod_left_box_prod_left\n\n",
 "of_box_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\nprotected theorem connected.of_box_prod_left (h : («expr □ » G H).connected) : G.connected :=\n  by\n  haveI := (nonempty_prod.1 h.nonempty).1\n  haveI := (nonempty_prod.1 h.nonempty).2\n  exact ⟨h.preconnected.of_box_prod_left⟩\n#align connected.of_box_prod_left connected.of_box_prod_left\n\n",
 "box_prod_neighbor_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem box_prod_neighbor_set (x : α × β) :\n    («expr □ » G H).neighbor_set x =\n      finset.product (G.neighbor_set x.1) {x.2} ∪ finset.product {x.1} (H.neighbor_set x.2) :=\n  by\n  ext ⟨a', b'⟩\n  simp only [mem_neighbor_set, Set.mem_union, box_prod_adj, Set.mem_prod, Set.mem_singleton_iff]\n  simp only [eq_comm, and_comm']\n#align box_prod_neighbor_set box_prod_neighbor_set\n\n",
 "box_prod_neighbor_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem box_prod_neighbor_finset (x : α × β) [fintype (G.neighbor_set x.1)] [fintype (H.neighbor_set x.2)]\n    [fintype ((«expr □ » G H).neighbor_set x)] :\n    («expr □ » G H).neighbor_finset x =\n      (finset.product (G.neighbor_finset x.1) {x.2}).disj_union (finset.product {x.1} (H.neighbor_finset x.2))\n        (finset.disjoint_product.mpr <| or.inl <| neighbor_finset_disjoint_singleton _ _) :=\n  by\n  -- swap out the fintype instance for the canonical one\n  letI : fintype ((«expr □ » G H).neighbor_set x) := simple_graph.box_prod_fintype_neighbor_set _\n  refine' eq.trans _ Finset.attach_map_val\n  convert Finset.map_map _ (Function.Embedding.subtype _) finset.univ\n#align box_prod_neighbor_finset box_prod_neighbor_finset\n\n",
 "box_prod_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\ntheorem box_prod_degree (x : α × β) [fintype (G.neighbor_set x.1)] [fintype (H.neighbor_set x.2)]\n    [fintype ((«expr □ » G H).neighbor_set x)] : («expr □ » G H).degree x = G.degree x.1 + H.degree x.2 :=\n  by\n  rw [degree, degree, degree, box_prod_neighbor_finset, finset.card_disj_union]\n  simp_rw [finset.card_product, finset.card_singleton, mul_one, one_mul]\n#align box_prod_degree box_prod_degree\n\n",
 "box_prod_connected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n@[simp]\ntheorem box_prod_connected : («expr □ » G H).connected ↔ G.connected ∧ H.connected :=\n  ⟨fun h => ⟨h.of_box_prod_left, h.of_box_prod_right⟩, fun h => h.1.box_prod h.2⟩\n#align box_prod_connected box_prod_connected\n\n",
 "box_prod_adj_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n@[simp]\ntheorem box_prod_adj_right : («expr □ » G H).adj (a, b₁) (a, b₂) ↔ H.adj b₁ b₂ := by\n  rw [box_prod_adj, and_iff_left rfl, or_iff_right fun h : G.adj a a ∧ _ => h.1.ne rfl]\n#align box_prod_adj_right box_prod_adj_right\n\n",
 "box_prod_adj_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n@[simp]\ntheorem box_prod_adj_left : («expr □ » G H).adj (a₁, b) (a₂, b) ↔ G.adj a₁ a₂ := by\n  rw [box_prod_adj, and_iff_left rfl, or_iff_left fun h : H.adj b b ∧ _ => h.1.ne rfl]\n#align box_prod_adj_left box_prod_adj_left\n\n",
 "box_prod_adj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\n/-\nCopyright (c) 2022 George Peter Banyard, Yaël Dillies, Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: George Peter Banyard, Yaël Dillies, Kyle Miller\n-/\n@[simp]\ntheorem box_prod_adj : («expr □ » G H).adj x y ↔ G.adj x.1 y.1 ∧ x.2 = y.2 ∨ H.adj x.2 y.2 ∧ x.1 = y.1 :=\n  iff.rfl\n#align box_prod_adj box_prod_adj\n\n",
 "box_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr □ » -/\nprotected theorem connected.box_prod (hG : G.connected) (hH : H.connected) : («expr □ » G H).connected :=\n  by\n  haveI := hG.nonempty\n  haveI := hH.nonempty\n  exact ⟨hG.preconnected.box_prod hH.preconnected⟩\n#align connected.box_prod connected.box_prod\n\n"}