{"vertical_apply":
 "@[simp]\ntheorem vertical_apply {α ι ι'} (v : ι → α) (l : Line α ι') (x : α) : l.vertical v x = Sum.elim v (l x) :=\n  by\n  funext i\n  cases i <;> rfl\n#align vertical_apply vertical_apply\n\n",
 "prod_apply":
 "@[simp]\ntheorem prod_apply {α ι ι'} (l : Line α ι) (l' : Line α ι') (x : α) : l.prod l' x = Sum.elim (l x) (l' x) :=\n  by\n  funext i\n  cases i <;> rfl\n#align prod_apply prod_apply\n\n",
 "map_apply":
 "@[simp]\ntheorem map_apply {α α' ι} (f : α → α') (l : Line α ι) (x : α) : l.map f (f x) = f ∘ l x := by\n  simp only [line.apply, line.map, option.get_or_else_map]\n#align map_apply map_apply\n\n",
 "horizontal_apply":
 "@[simp]\ntheorem horizontal_apply {α ι ι'} (l : Line α ι) (v : ι' → α) (x : α) : l.horizontal v x = Sum.elim (l x) v :=\n  by\n  funext i\n  cases i <;> rfl\n#align horizontal_apply horizontal_apply\n\n",
 "exists_mono_in_high_dimension'":
 "/-- The Hales-Jewett theorem. This version has a restriction on universe levels which is necessary\nfor the proof. See `exists_mono_in_high_dimension` for a fully universe-polymorphic version. -/\nprivate theorem exists_mono_in_high_dimension' :\n    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],\n      ∃ (ι : Type)(_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.is_mono C :=\n  -- The proof proceeds by induction on `α`.\n    Finite.induction_empty_option\n    (-- We have to show that the theorem is invariant under `α ≃ α'` for the induction to work.\n    fun α α' e =>\n      forall_imp fun κ =>\n        forall_imp fun _ =>\n          Exists.imp fun ι =>\n            Exists.imp fun _ h C =>\n              let ⟨l, c, lc⟩ := h fun v => C (e ∘ v)\n              ⟨l.map e, c, e.forall_congr_left.mp fun x => by rw [← lc x, line.map_apply]⟩)\n    (by\n      -- This deals with the degenerate case where `α` is empty.\n      intro κ _\n      by_cases h : Nonempty κ\n      · skip\n        exact ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, pempty.rec _⟩⟩\n      · exact ⟨Empty, inferInstance, fun C => (h ⟨C (empty.rec _)⟩).elim⟩)\n    (by\n      -- Now we have to show that the theorem holds for `option α` if it holds for `α`.\n      intro α _ ihα κ _\n      cases nonempty_fintype κ\n      -- Later we'll need `α` to be nonempty. So we first deal with the trivial case where `α` is empty.\n      -- Then `option α` has only one element, so any line is monochromatic.\n      by_cases h : Nonempty α\n      on_goal 2 =>\n        refine' ⟨Unit, inferInstance, fun C => ⟨diagonal _ _, C fun _ => none, _⟩⟩\n        rintro (_ | ⟨a⟩); rfl; exact (h ⟨a⟩).elim\n      -- The key idea is to show that for every `r`, in high dimension we can either find\n      -- `r` color focused lines or a monochromatic line.\n      suffices key :\n        ∀ r : ℕ,\n          ∃ (ι : Type)(_ : Fintype ι),\n            ∀ C : (ι → Option α) → κ, (∃ s : color_focused C, s.lines.card = r) ∨ ∃ l, is_mono C l\n      -- Given the key claim, we simply take `r = |κ| + 1`. We cannot have this many distinct colors so\n      -- we must be in the second case, where there is a monochromatic line.\n      · obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)\n        refine' ⟨ι, _inst, fun C => (hι C).resolve_left _⟩\n        rintro ⟨s, sr⟩\n        apply nat.not_succ_le_self (Fintype.card κ)\n        rw [← nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]\n        exact Finset.card_le_univ ⟨_, s.distinct_colors⟩\n      -- We now prove the key claim, by induction on `r`.\n      intro r\n      induction' r with r ihr\n      -- The base case `r = 0` is trivial as the empty collection is color-focused.\n      · exact ⟨Empty, inferInstance, fun C => or.inl ⟨default, Multiset.card_zero⟩⟩\n      -- Supposing the key claim holds for `r`, we need to show it for `r+1`. First pick a high enough\n      -- dimension `ι` for `r`.\n      obtain ⟨ι, _inst, hι⟩ := ihr\n      skip\n      -- Then since the theorem holds for `α` with any number of colors, pick a dimension `ι'` such that\n      -- `ι' → α` always has a monochromatic line whenever it is `(ι → option α) → κ`-colored.\n      specialize ihα ((ι → Option α) → κ)\n      obtain ⟨ι', _inst, hι'⟩ := ihα\n      skip\n      -- We claim that `ι ⊕ ι'` works for `option α` and `κ`-coloring.\n      refine' ⟨Sum ι ι', inferInstance, _⟩\n      intro C\n      -- A `κ`-coloring of `ι ⊕ ι' → option α` induces an `(ι → option α) → κ`-coloring of `ι' → α`.\n      specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))\n      -- By choice of `ι'` this coloring has a monochromatic line `l'` with color class `C'`, where\n      -- `C'` is a `κ`-coloring of `ι → α`.\n      obtain ⟨l', C', hl'⟩ := hι'\n      -- If `C'` has a monochromatic line, then so does `C`. We use this in two places below.\n      have mono_of_mono : (∃ l, is_mono C' l) → ∃ l, is_mono C l :=\n        by\n        rintro ⟨l, c, hl⟩\n        refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩\n        rw [line.horizontal_apply, ← hl, ← hl']\n      -- By choice of `ι`, `C'` either has `r` color-focused lines or a monochromatic line.\n      specialize hι C'\n      rcases hι with (⟨s, sr⟩ | _)\n      on_goal 2 => exact or.inr (mono_of_mono hι)\n      -- Here we assume `C'` has `r` color focused lines. We split into cases depending on whether one of\n      -- these `r` lines has the same color as the focus point.\n      by_cases h : ∃ p ∈ s.lines, (p : almost_mono _).color = C' s.focus\n      -- If so then this is a `C'`-monochromatic line and we are done.\n      · obtain ⟨p, p_mem, hp⟩ := h\n        refine' or.inr (mono_of_mono ⟨p.line, p.color, _⟩)\n        rintro (_ | _)\n        rw [hp, s.is_focused p p_mem]\n        apply p.has_color\n      -- If not, we get `r+1` color focused lines by taking the product of the `r` lines with `l'` and\n      -- adding to this the vertical line obtained by the focus point and `l`.\n      refine'\n        or.inl\n          ⟨⟨(s.lines.map _).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => _⟩,\n              Sum.elim s.focus (l'.map some none), _, _⟩,\n            _⟩\n      -- The vertical line is almost monochromatic.\n      · rw [vertical_apply, ← congr_fun (hl' x), line.map_apply]\n      · refine' fun p => ⟨p.line.prod (l'.map some), p.color, fun x => _⟩\n        -- The product lines are almost monochromatic.\n        rw [line.prod_apply, line.map_apply, ← p.has_color, ← congr_fun (hl' x)]\n      -- Our `r+1` lines have the same endpoint.\n      · simp_rw [Multiset.mem_cons, Multiset.mem_map]\n        rintro _ (rfl | ⟨q, hq, rfl⟩)\n        · rw [line.vertical_apply]\n        · rw [line.prod_apply, s.is_focused q hq]\n      -- Our `r+1` lines have distinct colors (this is why we needed to split into cases above).\n      · rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]\n        exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩\n      -- Finally, we really do have `r+1` lines!\n      · rw [Multiset.card_cons, Multiset.card_map, sr])\n#align exists_mono_in_high_dimension' exists_mono_in_high_dimension'\n\n",
 "exists_mono_in_high_dimension":
 "/-- The Hales-Jewett theorem: for any finite types `α` and `κ`, there exists a finite type `ι` such\nthat whenever the hypercube `ι → α` is `κ`-colored, there is a monochromatic combinatorial line. -/\ntheorem exists_mono_in_high_dimension (α : Type u) [Finite α] (κ : Type v) [Finite κ] :\n    ∃ (ι : Type)(_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.is_mono C :=\n  let ⟨ι, ιfin, hι⟩ := exists_mono_in_high_dimension' α (ULift κ)\n  ⟨ι, ιfin, fun C =>\n    let ⟨l, c, hc⟩ := hι (ULift.up ∘ C)\n    ⟨l, c.down, fun x => by rw [← hc]⟩⟩\n#align exists_mono_in_high_dimension exists_mono_in_high_dimension\n\n",
 "exists_mono_homothetic_copy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A generalization of Van der Waerden's theorem: if `M` is a finitely colored commutative\nmonoid, and `S` is a finite subset, then there exists a monochromatic homothetic copy of `S`. -/\ntheorem exists_mono_homothetic_copy {M κ : Type _} [AddCommMonoid M] (S : Finset M) [Finite κ] (C : M → κ) :\n    ∃ a > 0, ∃ (b : M)(c : κ), ∀ s ∈ S, C («expr • » a s + b) = c :=\n  by\n  obtain ⟨ι, _inst, hι⟩ := line.exists_mono_in_high_dimension S κ\n  skip\n  specialize\n    hι fun v =>\n      C <|\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (v i)\n  obtain ⟨l, c, hl⟩ := hι\n  set s : Finset ι := { i ∈ Finset.univ | l.idx_fun i = none } with hs\n  refine'\n    ⟨s.card, finset.card_pos.mpr ⟨l.proper.some, _⟩,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" («expr ᶜ» s)\n        (((l.idx_fun i).map coe).get_or_else 0),\n      c, _⟩\n  · rw [hs, finset.sep_def, Finset.mem_filter]\n    exact ⟨Finset.mem_univ _, l.proper.some_spec⟩\n  intro x xs\n  rw [← hl ⟨x, xs⟩]\n  clear hl; congr\n  rw [← Finset.sum_add_sum_compl s]\n  congr 1\n  · rw [← Finset.sum_const]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, finset.sep_def, Finset.mem_filter] at hi\n    rw [l.apply_none _ _ hi.right, Subtype.coe_mk]\n  · apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, finset.sep_def, Finset.compl_filter, Finset.mem_filter] at hi\n    obtain ⟨y, hy⟩ := option.ne_none_iff_exists.mp hi.right\n    simp_rw [line.apply, ← hy, Option.map_some', option.get_or_else_some]\n#align exists_mono_homothetic_copy exists_mono_homothetic_copy\n\n",
 "diagonal_apply":
 "@[simp]\ntheorem diagonal_apply {α ι} [Nonempty ι] (x : α) : Line.diagonal α ι x = fun i => x := by\n  simp_rw [line.apply, line.diagonal, option.get_or_else_none]\n#align diagonal_apply diagonal_apply\n\n",
 "apply_of_ne_none":
 "theorem apply_of_ne_none {α ι} (l : Line α ι) (x : α) (i : ι) (h : l.idx_fun i ≠ none) : some (l x i) = l.idx_fun i :=\n  by rw [l.apply, option.get_or_else_of_ne_none h]\n#align apply_of_ne_none apply_of_ne_none\n\n",
 "apply_none":
 "theorem apply_none {α ι} (l : Line α ι) (x : α) (i : ι) (h : l.idx_fun i = none) : l x i = x := by\n  simp only [option.get_or_else_none, h, l.apply]\n#align apply_none apply_none\n\n",
 "apply":
 "/-\nCopyright (c) 2021 David Wärn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Wärn\n-/\n-- This lets us treat a line `l : line α ι` as a function `α → ι → α`.\ntheorem apply {α ι} (l : Line α ι) (x : α) : l x = fun i => (l.idx_fun i).get_or_else x :=\n  rfl\n#align apply apply\n\n"}