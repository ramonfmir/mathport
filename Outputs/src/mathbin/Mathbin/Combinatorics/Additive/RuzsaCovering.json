{"exists_subset_mul_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\n/-- **Ruzsa's covering lemma**. -/\n@[to_additive \"**Ruzsa's covering lemma**\"]\ntheorem exists_subset_mul_div (ht : t.nonempty) : ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t :=\n  by\n  haveI : ∀ u, Decidable ((u : Set α).pairwise_disjoint («expr • » · t)) := fun u => Classical.dec _\n  set C := s.powerset.filter fun u => (u : Set α).pairwise_disjoint («expr • » · t)\n  obtain ⟨u, hu, hCmax⟩ :=\n    C.exists_maximal (filter_nonempty_iff.2 ⟨∅, empty_mem_powerset _, Set.pairwiseDisjoint_empty⟩)\n  rw [mem_filter, mem_powerset] at hu\n  refine'\n    ⟨u, (card_mul_iff.2 <| pairwise_disjoint_smul_iff.1 hu.2).ge.trans (card_le_of_subset <| mul_subset_mul_right hu.1),\n      fun a ha => _⟩\n  rw [mul_div_assoc]\n  by_cases hau : a ∈ u\n  · exact subset_mul_left _ ht.one_mem_div hau\n  by_cases H : ∀ b ∈ u, Disjoint («expr • » a t) («expr • » b t)\n  · refine' (hCmax _ _ <| ssubset_insert hau).elim\n    rw [mem_filter, mem_powerset, insert_subset, coe_insert]\n    exact ⟨⟨ha, hu.1⟩, hu.2.insert fun b hb _ => H _ hb⟩\n  push_neg  at H\n  simp_rw [not_disjoint_iff, ← inv_smul_mem_iff] at H\n  obtain ⟨b, hb, c, hc₁, hc₂⟩ := H\n  exact mem_mul.2 ⟨_, _, hb, mem_div.2 ⟨_, _, hc₂, hc₁, by simp [div_eq_mul_inv a b]⟩, by simp⟩\n#align exists_subset_mul_div exists_subset_mul_div\n\n"}