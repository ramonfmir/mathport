{"multiplicative_energy_univ_right":
 "@[simp, to_additive additive_energy_univ_right]\ntheorem multiplicative_energy_univ_right : multiplicativeEnergy s univ = Fintype.card α * s.card ^ 2 := by\n  rw [multiplicative_energy_comm, multiplicative_energy_univ_left]\n#align multiplicative_energy_univ_right multiplicative_energy_univ_right\n\n",
 "multiplicative_energy_univ_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp, to_additive additive_energy_univ_left]\ntheorem multiplicative_energy_univ_left : multiplicativeEnergy univ t = Fintype.card α * t.card ^ 2 :=\n  by\n  simp only [multiplicative_energy, univ_product_univ, Fintype.card, sq, ← card_product]\n  set f : α × α × α → (α × α) × α × α := fun x => ((x.1 * x.2.2, x.1 * x.2.1), x.2) with hf\n  have : (↑(finset.product (univ : Finset α) (finset.product t t)) : Set (α × α × α)).inj_on f :=\n    by\n    rintro ⟨a₁, b₁, c₁⟩ h₁ ⟨a₂, b₂, c₂⟩ h₂ h\n    simp_rw [Prod.ext_iff] at h\n    obtain ⟨h, rfl, rfl⟩ := h\n    rw [mul_right_cancel h.1]\n  rw [← card_image_of_inj_on this]\n  congr with a\n  simp only [hf, mem_filter, mem_product, mem_univ, true_and_iff, mem_image, exists_prop, Prod.exists]\n  refine' ⟨fun h => ⟨a.1.1 * a.2.2⁻¹, _, _, h.1, by simp [mul_right_comm, h.2]⟩, _⟩\n  rintro ⟨b, c, d, hcd, rfl⟩\n  simpa [mul_right_comm]\n#align multiplicative_energy_univ_left multiplicative_energy_univ_left\n\n",
 "multiplicative_energy_pos_iff":
 "@[simp, to_additive additive_energy_pos_iff]\ntheorem multiplicative_energy_pos_iff : 0 < multiplicativeEnergy s t ↔ s.nonempty ∧ t.nonempty :=\n  ⟨fun h =>\n    of_not_not fun H => by\n      simp_rw [not_and_or, not_nonempty_iff_eq_empty] at H\n      obtain rfl | rfl := H <;> simpa [nat.not_lt_zero] using h,\n    fun h => multiplicativeEnergy_pos h.1 h.2⟩\n#align multiplicative_energy_pos_iff multiplicative_energy_pos_iff\n\n",
 "multiplicative_energy_pos":
 "@[to_additive additive_energy_pos]\ntheorem multiplicative_energy_pos (hs : s.nonempty) (ht : t.nonempty) : 0 < multiplicativeEnergy s t :=\n  (mul_pos hs.card_pos ht.card_pos).trans_le le_multiplicativeEnergy\n#align multiplicative_energy_pos multiplicative_energy_pos\n\n",
 "multiplicative_energy_mono_right":
 "@[to_additive additive_energy_mono_right]\ntheorem multiplicative_energy_mono_right (ht : t₁ ⊆ t₂) : multiplicativeEnergy s t₁ ≤ multiplicativeEnergy s t₂ :=\n  multiplicativeEnergy_mono Subset.rfl ht\n#align multiplicative_energy_mono_right multiplicative_energy_mono_right\n\n",
 "multiplicative_energy_mono_left":
 "@[to_additive additive_energy_mono_left]\ntheorem multiplicative_energy_mono_left (hs : s₁ ⊆ s₂) : multiplicativeEnergy s₁ t ≤ multiplicativeEnergy s₂ t :=\n  multiplicativeEnergy_mono hs Subset.rfl\n#align multiplicative_energy_mono_left multiplicative_energy_mono_left\n\n",
 "multiplicative_energy_mono":
 "/-\nCopyright (c) 2022 Yaël Dillies, Ella Yu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Ella Yu\n-/\n@[to_additive additive_energy_mono]\ntheorem multiplicative_energy_mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) :\n    multiplicativeEnergy s₁ t₁ ≤ multiplicativeEnergy s₂ t₂ :=\n  card_le_of_subset <|\n    filter_subset_filter _ <| product_subset_product (product_subset_product hs hs) <| product_subset_product ht ht\n#align multiplicative_energy_mono multiplicative_energy_mono\n\n",
 "multiplicative_energy_eq_zero_iff":
 "@[simp, to_additive additive_energy_eq_zero_iff]\ntheorem multiplicative_energy_eq_zero_iff : multiplicativeEnergy s t = 0 ↔ s = ∅ ∨ t = ∅ := by\n  simp [← (nat.zero_le _).not_gt_iff_eq, not_and_or]\n#align multiplicative_energy_eq_zero_iff multiplicative_energy_eq_zero_iff\n\n",
 "multiplicative_energy_empty_right":
 "@[simp, to_additive additive_energy_empty_right]\ntheorem multiplicative_energy_empty_right : multiplicativeEnergy s ∅ = 0 := by simp [multiplicative_energy]\n#align multiplicative_energy_empty_right multiplicative_energy_empty_right\n\n",
 "multiplicative_energy_empty_left":
 "@[simp, to_additive additive_energy_empty_left]\ntheorem multiplicative_energy_empty_left : multiplicativeEnergy ∅ t = 0 := by simp [multiplicative_energy]\n#align multiplicative_energy_empty_left multiplicative_energy_empty_left\n\n",
 "multiplicative_energy_comm":
 "@[to_additive additive_energy_comm]\ntheorem multiplicative_energy_comm (s t : Finset α) : multiplicativeEnergy s t = multiplicativeEnergy t s :=\n  by\n  rw [multiplicative_energy, ← Finset.card_map (Equiv.prodComm _ _).to_embedding, map_filter]\n  simp [-Finset.card_map, eq_comm, multiplicative_energy, mul_comm, map_eq_image, Function.comp]\n#align multiplicative_energy_comm multiplicative_energy_comm\n\n",
 "le_multiplicative_energy":
 "@[to_additive le_additive_energy]\ntheorem le_multiplicative_energy : s.card * t.card ≤ multiplicativeEnergy s t :=\n  by\n  rw [← card_product]\n  refine' card_le_card_of_inj_on (fun x => ((x.1, x.1), x.2, x.2)) (by simp [← and_imp]) fun a _ b _ => _\n  simp only [Prod.mk.inj_iff, and_self_iff, and_imp]\n  exact Prod.ext\n#align le_multiplicative_energy le_multiplicative_energy\n\n"}