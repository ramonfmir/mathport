{"mul_pluennecke_petridis":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (A' «expr ⊆ » A) -/\n@[to_additive]\ntheorem mul_pluennecke_petridis (C : Finset α)\n    (hA : ∀ (A') (_ : A' ⊆ A), (A * B).card * A'.card ≤ (A' * B).card * A.card) :\n    (A * B * C).card * A.card ≤ (A * B).card * (A * C).card :=\n  by\n  induction' C using Finset.induction_on with x C hc ih\n  · simp\n  set A' := A ∩ (A * C / {x}) with hA'\n  set C' := insert x C with hC'\n  have h₀ : A' * {x} = A * {x} ∩ (A * C) := by rw [hA', inter_mul_singleton, (is_unit_singleton x).div_mul_cancel]\n  have h₁ : A * B * C' = A * B * C ∪ (A * B * {x}) \\ (A' * B * {x}) :=\n    by\n    rw [hC', insert_eq, union_comm, mul_union]\n    refine' (sup_sdiff_eq_sup _).symm\n    rw [mul_right_comm, mul_right_comm A, h₀]\n    exact mul_subset_mul_right (inter_subset_right _ _)\n  have h₂ : A' * B * {x} ⊆ A * B * {x} := mul_subset_mul_right (mul_subset_mul_right <| inter_subset_left _ _)\n  have h₃ : (A * B * C').card ≤ (A * B * C).card + (A * B).card - (A' * B).card :=\n    by\n    rw [h₁]\n    refine' (card_union_le _ _).trans_eq _\n    rw [card_sdiff h₂, ← add_tsub_assoc_of_le (card_le_of_subset h₂), card_mul_singleton, card_mul_singleton]\n  refine' (mul_le_mul_right' h₃ _).trans _\n  rw [tsub_mul, add_mul]\n  refine' (tsub_le_tsub (add_le_add_right ih _) <| hA _ <| inter_subset_left _ _).trans_eq _\n  rw [← mul_add, ← mul_tsub, ← hA', insert_eq, mul_union, ← card_mul_singleton A x, ← card_mul_singleton A' x,\n    add_comm (card _), h₀, eq_tsub_of_add_eq (card_union_add_card_inter _ _)]\n#align mul_pluennecke_petridis mul_pluennecke_petridis\n\n",
 "mul_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (A' «expr ⊆ » A) -/\n-- Auxiliary lemma for Ruzsa's triangle sum inequality, and the Plünnecke-Ruzsa inequality.\n@[to_additive]\nprivate theorem mul_aux (hA : A.nonempty) (hAB : A ⊆ B)\n    (h : ∀ A' ∈ B.powerset.erase ∅, ((A * C).card : nnrat) / ↑A.card ≤ (A' * C).card / ↑A'.card) :\n    ∀ (A') (_ : A' ⊆ A), (A * C).card * A'.card ≤ (A' * C).card * A.card :=\n  by\n  rintro A' hAA'\n  obtain rfl | hA' := A'.eq_empty_or_nonempty\n  · simp\n  have hA₀ : (0 : nnrat) < A.card := cast_pos.2 hA.card_pos\n  have hA₀' : (0 : nnrat) < A'.card := cast_pos.2 hA'.card_pos\n  exact_mod_cast\n    (div_le_div_iff hA₀ hA₀').1 (h _ <| mem_erase_of_ne_of_mem hA'.ne_empty <| mem_powerset.2 <| hAA'.trans hAB)\n#align mul_aux mul_aux\n\n",
 "card_pow_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/-- Special case of the **Plünnecke-Ruzsa inequality**. Division version. -/\n@[to_additive \"Special case of the **Plünnecke-Ruzsa inequality**. Subtraction version.\"]\ntheorem card_pow_le' (hA : A.nonempty) (B : Finset α) (n : ℕ) :\n    ((B ^ n).card : nnrat) ≤ ((A / B).card / A.card) ^ n * A.card := by\n  simpa only [pow_zero, div_one] using card_pow_div_pow_le' hA _ _ 0\n#align card_pow_le' card_pow_le'\n\n",
 "card_pow_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/-- Special case of the **Plünnecke-Ruzsa inequality**. Multiplication version. -/\n@[to_additive \"Special case of the **Plünnecke-Ruzsa inequality**. Addition version.\"]\ntheorem card_pow_le (hA : A.nonempty) (B : Finset α) (n : ℕ) :\n    ((B ^ n).card : nnrat) ≤ ((A * B).card / A.card) ^ n * A.card := by\n  simpa only [pow_zero, div_one] using card_pow_div_pow_le hA _ _ 0\n#align card_pow_le card_pow_le\n\n",
 "card_pow_div_pow_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/-- The **Plünnecke-Ruzsa inequality**. Subtraction version. -/\n@[to_additive \"The **Plünnecke-Ruzsa inequality**. Subtraction version.\"]\ntheorem card_pow_div_pow_le' (hA : A.nonempty) (B : Finset α) (m n : ℕ) :\n    ((B ^ m / B ^ n).card : nnrat) ≤ ((A / B).card / A.card) ^ (m + n) * A.card :=\n  by\n  rw [← card_inv, inv_div', ← inv_pow, ← inv_pow, div_eq_mul_inv A]\n  exact card_pow_div_pow_le hA _ _ _\n#align card_pow_div_pow_le' card_pow_div_pow_le'\n\n",
 "card_pow_div_pow_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/-- The **Plünnecke-Ruzsa inequality**. Multiplication version. Note that this is genuinely harder\nthan the division version because we cannot use a double counting argument. -/\n@[to_additive\n      \"The **Plünnecke-Ruzsa inequality**. Addition version. Note that this is genuinely\\nharder than the subtraction version because we cannot use a double counting argument.\"]\ntheorem card_pow_div_pow_le (hA : A.nonempty) (B : Finset α) (m n : ℕ) :\n    ((B ^ m / B ^ n).card : nnrat) ≤ ((A * B).card / A.card) ^ (m + n) * A.card :=\n  by\n  have hA' : A ∈ A.powerset.erase ∅ := mem_erase_of_ne_of_mem hA.ne_empty (mem_powerset_self _)\n  obtain ⟨C, hC, hCA⟩ := exists_min_image (A.powerset.erase ∅) (fun C => (C * B).card / C.card : _ → nnrat) ⟨A, hA'⟩\n  rw [mem_erase, mem_powerset, ← nonempty_iff_ne_empty] at hC\n  refine' (mul_le_mul_right <| cast_pos.2 hC.1.card_pos).1 _\n  norm_cast\n  refine' (cast_le.2 <| card_div_mul_le_card_mul_mul_card_mul _ _ _).trans _\n  push_cast\n  rw [mul_comm _ C]\n  refine'\n    (mul_le_mul (card_mul_pow_le (mul_aux hC.1 hC.2 hCA) _) (card_mul_pow_le (mul_aux hC.1 hC.2 hCA) _) (zero_le _) <|\n          zero_le _).trans\n      _\n  rw [mul_mul_mul_comm, ← pow_add, ← mul_assoc]\n  exact\n    mul_le_mul_of_nonneg_right\n      (mul_le_mul (pow_le_pow_of_le_left (zero_le _) (hCA _ hA') _) (cast_le.2 <| card_le_of_subset hC.2) (zero_le _) <|\n        zero_le _)\n      (zero_le _)\n#align card_pow_div_pow_le card_pow_div_pow_le\n\n",
 "card_mul_pow_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (A' «expr ⊆ » A) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n@[to_additive]\ntheorem card_mul_pow_le (hAB : ∀ (A') (_ : A' ⊆ A), (A * B).card * A'.card ≤ (A' * B).card * A.card) (n : ℕ) :\n    ((A * B ^ n).card : nnrat) ≤ ((A * B).card / A.card) ^ n * A.card :=\n  by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  · simp\n  induction' n with n ih\n  · simp\n  rw [pow_succ, ← mul_assoc, pow_succ, @mul_assoc (nnrat), ← mul_div_right_comm, le_div_iff, ← cast_mul]\n  swap; exact cast_pos.2 hA.card_pos\n  refine' (cast_le.2 <| mul_pluennecke_petridis _ hAB).trans _\n  rw [cast_mul]\n  exact mul_le_mul_of_nonneg_left ih (zero_le _)\n#align card_mul_pow_le card_mul_pow_le\n\n",
 "card_mul_mul_le_card_mul_mul_card_div":
 "/-- **Ruzsa's triangle inequality**. Mul-mul-div version. -/\n@[to_additive card_add_mul_le_card_add_mul_card_sub \"**Ruzsa's triangle inequality**. Add-add-sub version.\"]\ntheorem card_mul_mul_le_card_mul_mul_card_div (A B C : Finset α) :\n    (A * C).card * B.card ≤ (A * B).card * (B / C).card :=\n  by\n  rw [← div_inv_eq_mul, div_eq_mul_inv B]\n  exact card_div_mul_le_card_mul_mul_card_mul _ _ _\n#align card_mul_mul_le_card_mul_mul_card_div card_mul_mul_le_card_mul_mul_card_div\n\n",
 "card_mul_mul_le_card_div_mul_card_mul":
 "/-- **Ruzsa's triangle inequality**. Mul-div-div version. -/\n@[to_additive card_add_mul_le_card_sub_mul_card_add \"**Ruzsa's triangle inequality**. Add-sub-sub version.\"]\ntheorem card_mul_mul_le_card_div_mul_card_mul (A B C : Finset α) :\n    (A * C).card * B.card ≤ (A / B).card * (B * C).card :=\n  by\n  rw [← div_inv_eq_mul, ← div_inv_eq_mul B]\n  exact card_div_mul_le_card_div_mul_card_div _ _ _\n#align card_mul_mul_le_card_div_mul_card_mul card_mul_mul_le_card_div_mul_card_mul\n\n",
 "card_mul_mul_le_card_div_mul_card_div":
 "/-- **Ruzsa's triangle inequality**. Add-sub-sub version. -/\ntheorem card_mul_mul_le_card_div_mul_card_div (A B C : Finset α) :\n    (A * C).card * B.card ≤ (A / B).card * (B / C).card :=\n  by\n  rw [div_eq_mul_inv, ← card_inv B, ← card_inv (B / C), inv_div', div_inv_eq_mul]\n  exact card_mul_mul_card_le_card_mul_mul_card_mul _ _ _\n#align card_mul_mul_le_card_div_mul_card_div card_mul_mul_le_card_div_mul_card_div\n\n",
 "card_mul_mul_card_le_card_mul_mul_card_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\n/-- **Ruzsa's triangle inequality**. Multiplication version. -/\n@[to_additive card_add_mul_card_le_card_add_mul_card_add \"**Ruzsa's triangle inequality**. Addition version.\"]\ntheorem card_mul_mul_card_le_card_mul_mul_card_mul (A B C : Finset α) :\n    (A * C).card * B.card ≤ (A * B).card * (B * C).card :=\n  by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · simp\n  have hB' : B ∈ B.powerset.erase ∅ := mem_erase_of_ne_of_mem hB.ne_empty (mem_powerset_self _)\n  obtain ⟨U, hU, hUA⟩ := exists_min_image (B.powerset.erase ∅) (fun U => (U * A).card / U.card : _ → nnrat) ⟨B, hB'⟩\n  rw [mem_erase, mem_powerset, ← nonempty_iff_ne_empty] at hU\n  refine' cast_le.1 (_ : (_ : nnrat) ≤ _)\n  push_cast\n  refine' (le_div_iff <| cast_pos.2 hB.card_pos).1 _\n  rw [mul_div_right_comm, mul_comm _ B]\n  refine' (cast_le.2 <| card_le_card_mul_left _ hU.1).trans _\n  refine'\n    le_trans _\n      (mul_le_mul (hUA _ hB') (cast_le.2 <| card_le_of_subset <| mul_subset_mul_right hU.2) (zero_le _) <| zero_le _)\n  rw [← mul_div_right_comm, ← mul_assoc]\n  refine' (le_div_iff <| cast_pos.2 hU.1.card_pos).2 _\n  exact_mod_cast mul_pluennecke_petridis C (mul_aux hU.1 hU.2 hUA)\n#align card_mul_mul_card_le_card_mul_mul_card_mul card_mul_mul_card_le_card_mul_mul_card_mul\n\n",
 "card_div_mul_le_card_mul_mul_card_mul":
 "/-- **Ruzsa's triangle inequality**. Div-mul-mul version. -/\n@[to_additive card_sub_mul_le_card_add_mul_card_add \"**Ruzsa's triangle inequality**. Sub-add-add version.\"]\ntheorem card_div_mul_le_card_mul_mul_card_mul (A B C : Finset α) :\n    (A / C).card * B.card ≤ (A * B).card * (B * C).card :=\n  by\n  rw [← div_inv_eq_mul, ← card_inv B, ← card_inv (B * C), mul_inv, ← div_eq_mul_inv]\n  exact card_div_mul_le_card_div_mul_card_div _ _ _\n#align card_div_mul_le_card_mul_mul_card_mul card_div_mul_le_card_mul_mul_card_mul\n\n",
 "card_div_mul_le_card_mul_mul_card_div":
 "/-- **Ruzsa's triangle inequality**. Sub-add-sub version. -/\ntheorem card_div_mul_le_card_mul_mul_card_div (A B C : Finset α) :\n    (A / C).card * B.card ≤ (A * B).card * (B / C).card :=\n  by\n  rw [div_eq_mul_inv, div_eq_mul_inv]\n  exact card_mul_mul_card_le_card_mul_mul_card_mul _ _ _\n#align card_div_mul_le_card_mul_mul_card_div card_div_mul_le_card_mul_mul_card_div\n\n",
 "card_div_mul_le_card_div_mul_card_mul":
 "/-- **Ruzsa's triangle inequality**. Sub-sub-add version. -/\ntheorem card_div_mul_le_card_div_mul_card_mul (A B C : Finset α) :\n    (A / C).card * B.card ≤ (A / B).card * (B * C).card :=\n  by\n  rw [← div_inv_eq_mul, div_eq_mul_inv]\n  exact card_mul_mul_le_card_div_mul_card_div _ _ _\n#align card_div_mul_le_card_div_mul_card_mul card_div_mul_le_card_div_mul_card_mul\n\n",
 "card_div_mul_le_card_div_mul_card_div":
 "/-\nCopyright (c) 2022 Yaël Dillies, George Shakan. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, George Shakan\n-/\n/-- **Ruzsa's triangle inequality**. Division version. -/\n@[to_additive card_sub_mul_le_card_sub_mul_card_sub \"**Ruzsa's triangle inequality**. Subtraction version.\"]\ntheorem card_div_mul_le_card_div_mul_card_div (A B C : Finset α) :\n    (A / C).card * B.card ≤ (A / B).card * (B / C).card :=\n  by\n  rw [← card_product (A / B), ← mul_one (Finset.product _ _).card]\n  refine'\n    card_mul_le_card_mul (fun b ac => ac.1 * ac.2 = b) (fun x hx => _) fun x hx =>\n      card_le_one_iff.2 fun u v hu hv => ((mem_bipartite_below _).1 hu).2.symm.trans ((mem_bipartite_below _).1 hv).2\n  obtain ⟨a, c, ha, hc, rfl⟩ := mem_div.1 hx\n  refine' card_le_card_of_inj_on (fun b => (a / b, b / c)) (fun b hb => _) fun b₁ _ b₂ _ h => _\n  · rw [mem_bipartite_above]\n    exact ⟨mk_mem_product (div_mem_div ha hb) (div_mem_div hb hc), div_mul_div_cancel' _ _ _⟩\n  · exact div_right_injective (Prod.ext_iff.1 h).1\n#align card_div_mul_le_card_div_mul_card_div card_div_mul_le_card_div_mul_card_div\n\n",
 "card_add_nsmul_le":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (A' «expr ⊆ » A) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnrat -/\ntheorem card_add_nsmul_le {α : Type _} [AddCommGroup α] [DecidableEq α] {A B : Finset α}\n    (hAB : ∀ (A') (_ : A' ⊆ A), (A + B).card * A'.card ≤ (A' + B).card * A.card) (n : ℕ) :\n    ((A + «expr • » n B).card : nnrat) ≤ ((A + B).card / A.card) ^ n * A.card :=\n  by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  · simp\n  induction' n with n ih\n  · simp\n  rw [succ_nsmul, ← add_assoc, pow_succ, mul_assoc, ← mul_div_right_comm, le_div_iff, ← cast_mul]\n  swap; exact cast_pos.2 hA.card_pos\n  refine' (cast_le.2 <| add_pluennecke_petridis _ hAB).trans _\n  rw [cast_mul]\n  exact mul_le_mul_of_nonneg_left ih (zero_le _)\n#align card_add_nsmul_le card_add_nsmul_le\n\n"}