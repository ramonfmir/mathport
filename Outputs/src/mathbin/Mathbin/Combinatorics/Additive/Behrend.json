{"two_le_n_value":
 "theorem two_le_n_value (hN : 3 ≤ N) : 2 ≤ n_value N :=\n  by\n  refine' succ_le_of_lt (lt_ceil.2 <| lt_sqrt_of_sq_lt _)\n  rw [cast_one, one_pow, lt_log_iff_exp_lt]\n  refine' lt_of_lt_of_le _ (cast_le.2 hN)\n  · exact exp_one_lt_d9.trans_le (by norm_num)\n  rw [cast_pos]\n  exact (zero_lt_succ _).trans_le hN\n#align two_le_n_value two_le_n_value\n\n",
 "two_div_one_sub_two_div_e_le_eight":
 "theorem two_div_one_sub_two_div_e_le_eight : 2 / (1 - 2 / exp 1) ≤ 8 :=\n  by\n  rw [div_le_iff, mul_sub, mul_one, mul_div_assoc', le_sub_comm, div_le_iff (exp_pos _)]\n  · linarith [exp_one_gt_d9]\n  rw [sub_pos, div_lt_one] <;> exact exp_one_gt_d9.trans' (by norm_num)\n#align two_div_one_sub_two_div_e_le_eight two_div_one_sub_two_div_e_le_eight\n\n",
 "three_le_n_value":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem three_le_n_value (hN : 64 ≤ N) : 3 ≤ n_value N :=\n  by\n  rw [n_value, ← lt_iff_add_one_le, lt_ceil, cast_two]\n  apply lt_sqrt_of_sq_lt\n  have : (2 : exprℝ) ^ ((6 : ℕ) : exprℝ) ≤ N := by\n    rw [rpow_nat_cast]\n    exact (cast_le.2 hN).trans' (by norm_num1)\n  apply lt_of_lt_of_le _ ((log_le_log (rpow_pos_of_pos zero_lt_two _) _).2 this)\n  rw [log_rpow zero_lt_two, cast_bit0, cast_bit1, cast_one, ← div_lt_iff']\n  · exact log_two_gt_d9.trans_le' (by norm_num1)\n  · norm_num1\n  rw [cast_pos]\n  exact hN.trans_lt' (by norm_num1)\n#align three_le_n_value three_le_n_value\n\n",
 "sum_sq_le_of_mem_box":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_sq_le_of_mem_box (hx : x ∈ box n d) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (x i ^ 2) ≤\n      n * (d - 1) ^ 2 :=\n  by\n  rw [mem_box] at hx\n  have : ∀ i, x i ^ 2 ≤ (d - 1) ^ 2 := fun i => Nat.pow_le_pow_of_le_left (Nat.le_pred_of_lt (hx i)) _\n  exact (sum_le_card_nsmul univ _ _ fun i _ => this i).trans (by rw [card_fin, smul_eq_mul])\n#align sum_sq_le_of_mem_box sum_sq_le_of_mem_box\n\n",
 "sum_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_lt :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (d * (2 * d + 1) ^ (i : ℕ)) <\n      (2 * d + 1) ^ n :=\n  sum_eq.trans_lt <| (nat.div_le_self _ 2).trans_lt <| pred_lt (pow_pos (succ_pos _) _).ne'\n#align sum_lt sum_lt\n\n",
 "sum_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_eq :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (d * (2 * d + 1) ^ (i : ℕ)) =\n      ((2 * d + 1) ^ n - 1) / 2 :=\n  by\n  refine' (Nat.div_eq_of_eq_mul_left zero_lt_two _).symm\n  rw [← sum_range fun i => d * (2 * d + 1) ^ (i : ℕ), ← mul_sum, mul_right_comm, mul_comm d, ← geom_sum_mul_add,\n    add_tsub_cancel_right, mul_comm]\n#align sum_eq sum_eq\n\n",
 "sphere_zero_subset":
 "theorem sphere_zero_subset : sphere n d 0 ⊆ 0 := fun x => by\n  simp (config := { contextual := true }) [sphere, function.funext_iff]\n#align sphere_zero_subset sphere_zero_subset\n\n",
 "sphere_zero_right":
 "@[simp]\ntheorem sphere_zero_right (n k : ℕ) : sphere (n + 1) 0 k = ∅ := by simp [sphere]\n#align sphere_zero_right sphere_zero_right\n\n",
 "sphere_subset_preimage_metric_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem sphere_subset_preimage_metric_sphere :\n    (sphere n d k : set (fin n → ℕ)) ⊆\n      «expr ⁻¹' » (fun x : fin n → ℕ => (pi_Lp.equiv 2 _).symm (coe ∘ x : fin n → exprℝ))\n        (metric.sphere (0 : pi_Lp 2 fun _ : fin n => exprℝ) (sqrt k)) :=\n  fun x hx => by rw [Set.mem_preimage, mem_sphere_zero_iff_norm, norm_of_mem_sphere hx]\n#align sphere_subset_preimage_metric_sphere sphere_subset_preimage_metric_sphere\n\n",
 "sphere_subset_box":
 "theorem sphere_subset_box : sphere n d k ⊆ box n d :=\n  filter_subset _ _\n#align sphere_subset_box sphere_subset_box\n\n",
 "roth_lower_bound_explicit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem roth_lower_bound_explicit (hN : 4096 ≤ N) : (N : exprℝ) * exp (-4 * sqrt (log N)) < roth_number_nat N :=\n  by\n  let n := n_value N\n  have hn : 0 < (n : exprℝ) := cast_pos.2 (n_value_pos <| hN.trans' <| by norm_num1)\n  have hd : 0 < d_value N := d_value_pos (hN.trans' <| by norm_num1)\n  have hN₀ : 0 < (N : exprℝ) := cast_pos.2 (hN.trans' <| by norm_num1)\n  have hn₂ : 2 ≤ n := two_le_n_value (hN.trans' <| by norm_num1)\n  have : (2 * d_value N - 1) ^ n ≤ N := le_N (hN.trans' <| by norm_num1)\n  refine' ((bound_aux hd.ne' hn₂).trans <| cast_le.2 <| roth_number_nat.mono this).trans_lt' _\n  refine' (div_lt_div_of_lt hn <| pow_lt_pow_of_lt_left (bound hN) _ _).trans_le' _\n  · exact div_nonneg (rpow_nonneg_of_nonneg (cast_nonneg _) _) (exp_pos _).le\n  · exact tsub_pos_of_lt (three_le_n_value <| hN.trans' <| by norm_num1)\n  rw [← rpow_nat_cast, div_rpow (rpow_nonneg_of_nonneg hN₀.le _) (exp_pos _).le, ← rpow_mul hN₀.le, mul_comm (_ / _),\n    mul_one_div, cast_sub hn₂, cast_two, same_sub_div hn.ne', exp_one_rpow, div_div, rpow_sub hN₀, rpow_one, div_div,\n    div_eq_mul_inv]\n  refine' mul_le_mul_of_nonneg_left _ (cast_nonneg _)\n  rw [mul_inv, mul_inv, ← exp_neg, ← rpow_neg (cast_nonneg _), neg_sub, ← div_eq_mul_inv]\n  have : exp (-4 * sqrt (log N)) = exp (-2 * sqrt (log N)) * exp (-2 * sqrt (log N)) :=\n    by\n    rw [← exp_add, ← add_mul]\n    norm_num\n  rw [this]\n  refine'\n    mul_le_mul _ (exp_neg_two_mul_le <| real.sqrt_pos.2 <| log_pos _).le (exp_pos _).le <|\n      rpow_nonneg_of_nonneg (cast_nonneg _) _\n  · rw [← le_log_iff_exp_le (rpow_pos_of_pos hN₀ _), log_rpow hN₀, ← le_div_iff, mul_div_assoc, div_sqrt, neg_mul,\n      neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]\n    · exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two\n    refine' real.sqrt_pos.2 (log_pos _)\n    rw [one_lt_cast]\n    exact hN.trans_lt' (by norm_num1)\n  · rw [one_lt_cast]\n    exact hN.trans_lt' (by norm_num1)\n#align roth_lower_bound_explicit roth_lower_bound_explicit\n\n",
 "roth_lower_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem roth_lower_bound : (N : exprℝ) * exp (-4 * sqrt (log N)) ≤ roth_number_nat N :=\n  by\n  obtain rfl | hN := nat.eq_zero_or_pos N\n  · norm_num\n  obtain h₁ | h₁ := le_or_lt 4096 N\n  · exact (roth_lower_bound_explicit h₁).le\n  · apply (lower_bound_le_one hN h₁.le).trans\n    simpa using roth_number_nat.monotone hN\n#align roth_lower_bound roth_lower_bound\n\n",
 "norm_of_mem_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem norm_of_mem_sphere {x : fin n → ℕ} (hx : x ∈ sphere n d k) :\n    «expr‖ ‖» ((pi_Lp.equiv 2 _).symm (coe ∘ x : fin n → exprℝ)) = sqrt k :=\n  by\n  rw [euclidean_space.norm_eq]\n  dsimp\n  simp_rw [abs_cast, ← cast_pow, ← cast_sum, (mem_filter.1 hx).2]\n#align norm_of_mem_sphere norm_of_mem_sphere\n\n",
 "n_value_pos":
 "theorem n_value_pos (hN : 2 ≤ N) : 0 < n_value N :=\n  ceil_pos.2 <| real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 <| hN\n#align n_value_pos n_value_pos\n\n",
 "mem_box":
 "/-\nCopyright (c) 2022 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\ntheorem mem_box : x ∈ box n d ↔ ∀ i, x i < d := by simp only [box, fintype.mem_pi_finset, mem_range]\n#align mem_box mem_box\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero (d : ℕ) (a : fin 0 → ℕ) : map d a = 0 := by simp [map]\n#align map_zero map_zero\n-/\n\n",
 "map_succ'":
 "theorem map_succ' (a : fin (n + 1) → ℕ) : map d a = a 0 + map d (a ∘ fin.succ) * d :=\n  map_succ _\n#align map_succ' map_succ'\n\n",
 "map_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem map_succ (a : fin (n + 1) → ℕ) :\n    map d a =\n      a 0 +\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (a x.succ * d ^ (x : ℕ)) *\n          d :=\n  by simp [map, fin.sum_univ_succ, pow_succ', ← mul_assoc, ← sum_mul]\n#align map_succ map_succ\n\n",
 "map_monotone":
 "theorem map_monotone (d : ℕ) : monotone (map d : (fin n → ℕ) → ℕ) := fun x y h =>\n  by\n  dsimp\n  exact sum_le_sum fun i _ => nat.mul_le_mul_right _ <| h i\n#align map_monotone map_monotone\n\n",
 "map_mod":
 "theorem map_mod (a : fin n.succ → ℕ) : map d a % d = a 0 % d := by rw [map_succ, nat.add_mul_mod_self_right]\n#align map_mod map_mod\n\n",
 "map_le_of_mem_box":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem map_le_of_mem_box (hx : x ∈ box n d) :\n    map (2 * d - 1) x ≤\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((d - 1) * (2 * d - 1) ^ (i : ℕ)) :=\n  map_monotone (2 * d - 1) fun _ => Nat.le_pred_of_lt <| mem_box.1 hx _\n#align map_le_of_mem_box map_le_of_mem_box\n\n",
 "map_inj_on":
 "theorem map_inj_on : { x : fin n → ℕ | ∀ i, x i < d }.inj_on (map d) :=\n  by\n  intro x₁ hx₁ x₂ hx₂ h\n  induction' n with n ih\n  · simp\n  ext i\n  have x := (map_eq_iff hx₁ hx₂).1 h\n  refine' Fin.cases x.1 (congr_fun <| ih (fun _ => _) (fun _ => _) x.2) i\n  · exact hx₁ _\n  · exact hx₂ _\n#align map_inj_on map_inj_on\n\n",
 "map_eq_iff":
 "theorem map_eq_iff {x₁ x₂ : fin n.succ → ℕ} (hx₁ : ∀ i, x₁ i < d) (hx₂ : ∀ i, x₂ i < d) :\n    map d x₁ = map d x₂ ↔ x₁ 0 = x₂ 0 ∧ map d (x₁ ∘ fin.succ) = map d (x₂ ∘ fin.succ) :=\n  by\n  refine' ⟨fun h => _, fun h => by rw [map_succ', map_succ', h.1, h.2]⟩\n  have : x₁ 0 = x₂ 0 := by rw [← mod_eq_of_lt (hx₁ _), ← map_mod, ← mod_eq_of_lt (hx₂ _), ← map_mod, h]\n  rw [map_succ, map_succ, this, add_right_inj, mul_eq_mul_right_iff] at h\n  exact ⟨this, h.resolve_right (pos_of_gt (hx₁ 0)).ne'⟩\n#align map_eq_iff map_eq_iff\n\n",
 "lower_bound_le_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lower_bound_le_one' (hN : 2 ≤ N) (hN' : N ≤ 4096) : (N : exprℝ) * exp (-4 * sqrt (log N)) ≤ 1 :=\n  by\n  rw [← log_le_log (mul_pos (cast_pos.2 (zero_lt_two.trans_le hN)) (exp_pos _)) zero_lt_one, log_one,\n    log_mul (cast_pos.2 (zero_lt_two.trans_le hN)).ne' (exp_pos _).ne', log_exp, neg_mul, ← sub_eq_add_neg, sub_nonpos,\n    ← div_le_iff (real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 <| one_lt_two.trans_le hN), div_sqrt,\n    sqrt_le_left (zero_le_bit0.2 zero_le_two), log_le_iff_le_exp (cast_pos.2 (zero_lt_two.trans_le hN))]\n  norm_num1\n  apply le_trans _ four_zero_nine_six_lt_exp_sixteen.le\n  exact_mod_cast hN'\n#align lower_bound_le_one' lower_bound_le_one'\n\n",
 "lower_bound_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lower_bound_le_one (hN : 1 ≤ N) (hN' : N ≤ 4096) : (N : exprℝ) * exp (-4 * sqrt (log N)) ≤ 1 :=\n  by\n  obtain rfl | hN := hN.eq_or_lt\n  · norm_num\n  · exact lower_bound_le_one' hN hN'\n#align lower_bound_le_one lower_bound_le_one\n\n",
 "log_two_mul_two_le_sqrt_log_eight":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem log_two_mul_two_le_sqrt_log_eight : log 2 * 2 ≤ sqrt (log 8) :=\n  by\n  rw [show (8 : exprℝ) = 2 ^ ((3 : ℕ) : exprℝ) by norm_num1, log_rpow zero_lt_two (3 : ℕ)]\n  apply le_sqrt_of_sq_le\n  rw [mul_pow, sq (log 2), mul_assoc, mul_comm]\n  refine' mul_le_mul_of_nonneg_right _ (log_nonneg one_le_two)\n  rw [← le_div_iff]\n  apply log_two_lt_d9.le.trans\n  all_goals norm_num1\n#align log_two_mul_two_le_sqrt_log_eight log_two_mul_two_le_sqrt_log_eight\n\n",
 "le_sqrt_log":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem le_sqrt_log (hN : 4096 ≤ N) : log (2 / (1 - 2 / exp 1)) * (69 / 50) ≤ sqrt (log ↑N) :=\n  by\n  have : ((12 : ℕ) : exprℝ) * log 2 ≤ log N :=\n    by\n    rw [← log_rpow zero_lt_two, log_le_log, rpow_nat_cast]\n    · norm_num1\n      exact_mod_cast hN\n    · exact rpow_pos_of_pos zero_lt_two _\n    rw [cast_pos]\n    exact hN.trans_lt' (by norm_num1)\n  refine'\n    (mul_le_mul_of_nonneg_right ((log_le_log _ <| by norm_num1).2 two_div_one_sub_two_div_e_le_eight) <| by\n          norm_num1).trans\n      _\n  · refine' div_pos zero_lt_two _\n    rw [sub_pos, div_lt_one (exp_pos _)]\n    exact exp_one_gt_d9.trans_le' (by norm_num1)\n  have l8 : log 8 = (3 : ℕ) * log 2 := by\n    rw [← log_rpow zero_lt_two, rpow_nat_cast]\n    norm_num\n  rw [l8, cast_bit1, cast_one]\n  apply le_sqrt_of_sq_le (le_trans _ this)\n  simp only [cast_bit0, cast_bit1, cast_one]\n  rw [mul_right_comm, mul_pow, sq (log 2), ← mul_assoc]\n  apply mul_le_mul_of_nonneg_right _ (log_nonneg one_le_two)\n  rw [← le_div_iff']\n  · exact log_two_lt_d9.le.trans (by norm_num1)\n  exact sq_pos_of_ne_zero _ (by norm_num1)\n#align le_sqrt_log le_sqrt_log\n\n",
 "le_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem le_N (hN : 2 ≤ N) : (2 * d_value N - 1) ^ n_value N ≤ N :=\n  by\n  have : (2 * d_value N - 1) ^ n_value N ≤ (2 * d_value N) ^ n_value N := Nat.pow_le_pow_of_le_left (nat.sub_le _ _) _\n  apply this.trans\n  suffices ((2 * d_value N) ^ n_value N : exprℝ) ≤ N by exact_mod_cast this\n  rw [← rpow_nat_cast]\n  suffices i : (2 * d_value N : exprℝ) ≤ (N : exprℝ) ^ (1 / n_value N : exprℝ)\n  · apply (rpow_le_rpow (mul_nonneg zero_le_two (cast_nonneg _)) i (cast_nonneg _)).trans\n    rw [← rpow_mul (cast_nonneg _), one_div_mul_cancel, rpow_one]\n    rw [cast_ne_zero]\n    apply (n_value_pos hN).ne'\n  rw [← le_div_iff']\n  · exact floor_le (div_nonneg (rpow_nonneg_of_nonneg (cast_nonneg _) _) zero_le_two)\n  apply zero_lt_two\n#align le_N le_N\n\n",
 "four_zero_nine_six_lt_exp_sixteen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem four_zero_nine_six_lt_exp_sixteen : 4096 < exp 16 :=\n  by\n  rw [← log_lt_iff_lt_exp (show (0 : exprℝ) < 4096 by norm_num), show (4096 : exprℝ) = 2 ^ 12 by norm_num, ←\n    rpow_nat_cast, log_rpow zero_lt_two, cast_bit0, cast_bit0, cast_bit1, cast_one]\n  linarith [log_two_lt_d9]\n#align four_zero_nine_six_lt_exp_sixteen four_zero_nine_six_lt_exp_sixteen\n\n",
 "exp_neg_two_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\ntheorem exp_neg_two_mul_le {x : exprℝ} (hx : 0 < x) : exp (-2 * x) < exp (2 - «expr⌈ ⌉₊» x) / «expr⌈ ⌉₊» x :=\n  by\n  have h₁ := ceil_lt_add_one hx.le\n  have h₂ : 1 - x ≤ 2 - «expr⌈ ⌉₊» x := by\n    rw [le_sub_iff_add_le]\n    apply (add_le_add_left h₁.le _).trans_eq\n    rw [← add_assoc, sub_add_cancel]\n    rfl\n  have h₃ : exp (-(x + 1)) ≤ 1 / (x + 1) := by\n    rw [exp_neg, inv_eq_one_div]\n    refine' one_div_le_one_div_of_le (add_pos hx zero_lt_one) _\n    apply le_trans _ (add_one_le_exp_of_nonneg <| add_nonneg hx.le zero_le_one)\n    exact le_add_of_nonneg_right zero_le_one\n  refine' lt_of_le_of_lt _ (div_lt_div_of_lt_left (exp_pos _) (cast_pos.2 <| ceil_pos.2 hx) h₁)\n  refine' le_trans _ (div_le_div_of_le_of_nonneg (exp_le_exp.2 h₂) <| add_nonneg hx.le zero_le_one)\n  rw [le_div_iff (add_pos hx zero_lt_one), ← le_div_iff' (exp_pos _), ← exp_sub, neg_mul, sub_neg_eq_add, two_mul,\n    sub_add_add_cancel, add_comm _ x]\n  refine' le_trans _ (add_one_le_exp_of_nonneg <| add_nonneg hx.le zero_le_one)\n  exact le_add_of_nonneg_right zero_le_one\n#align exp_neg_two_mul_le exp_neg_two_mul_le\n\n",
 "exp_four_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exp_four_lt : exp 4 < 64 :=\n  by\n  rw [show (64 : exprℝ) = 2 ^ ((6 : ℕ) : exprℝ) by norm_num1, ← lt_log_iff_exp_lt (rpow_pos_of_pos zero_lt_two _),\n    log_rpow zero_lt_two, ← div_lt_iff']\n  exact log_two_gt_d9.trans_le' (by norm_num1)\n  norm_num\n#align exp_four_lt exp_four_lt\n\n",
 "exists_large_sphere_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_large_sphere_aux (n d : ℕ) :\n    ∃ k ∈ range (n * (d - 1) ^ 2 + 1), (↑(d ^ n) / (↑(n * (d - 1) ^ 2) + 1) : exprℝ) ≤ (sphere n d k).card :=\n  by\n  refine' exists_le_card_fiber_of_nsmul_le_card_of_maps_to (fun x hx => _) nonempty_range_succ _\n  · rw [mem_range, lt_succ_iff]\n    exact sum_sq_le_of_mem_box hx\n  · rw [card_range, _root_.nsmul_eq_mul, mul_div_assoc', cast_add_one, mul_div_cancel_left, card_box]\n    exact (cast_add_one_pos _).ne'\n#align exists_large_sphere_aux exists_large_sphere_aux\n\n",
 "exists_large_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_large_sphere (n d : ℕ) : ∃ k, (d ^ n / ↑(n * d ^ 2) : exprℝ) ≤ (sphere n d k).card :=\n  by\n  obtain ⟨k, -, hk⟩ := exists_large_sphere_aux n d\n  refine' ⟨k, _⟩\n  obtain rfl | hn := n.eq_zero_or_pos\n  · simp\n  obtain rfl | hd := d.eq_zero_or_pos\n  · simp\n  rw [← cast_pow]\n  refine' (div_le_div_of_le_left _ _ _).trans hk\n  · exact cast_nonneg _\n  · exact cast_add_one_pos _\n  simp only [← le_sub_iff_add_le', cast_mul, ← mul_sub, cast_pow, cast_sub hd, sub_sq, one_pow, cast_one, mul_one,\n    sub_add, sub_sub_self]\n  apply one_le_mul_of_one_le_of_one_le\n  · rwa [one_le_cast]\n  rw [le_sub_iff_add_le]\n  norm_num\n  exact one_le_cast.2 hd\n#align exists_large_sphere exists_large_sphere\n\n",
 "div_lt_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem div_lt_floor {x : exprℝ} (hx : 2 / (1 - 2 / exp 1) ≤ x) : x / exp 1 < («expr⌊ ⌋₊» (x / 2) : exprℝ) :=\n  by\n  apply lt_of_le_of_lt _ (sub_one_lt_floor _)\n  have : 0 < 1 - 2 / exp 1 := by\n    rw [sub_pos, div_lt_one (exp_pos _)]\n    exact lt_of_le_of_lt (by norm_num) exp_one_gt_d9\n  rwa [le_sub_comm, div_eq_mul_one_div x, div_eq_mul_one_div x, ← mul_sub, div_sub', ← div_eq_mul_one_div,\n    mul_div_assoc', one_le_div, ← div_le_iff this]\n  · exact zero_lt_two\n  · exact two_ne_zero\n#align div_lt_floor div_lt_floor\n\n",
 "d_value_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem d_value_pos (hN₃ : 8 ≤ N) : 0 < d_value N :=\n  by\n  have hN₀ : 0 < (N : exprℝ) := cast_pos.2 (succ_pos'.trans_le hN₃)\n  rw [d_value, floor_pos, ← log_le_log zero_lt_one, log_one, log_div _ two_ne_zero, log_rpow hN₀, div_mul_eq_mul_div,\n    one_mul, sub_nonneg, le_div_iff]\n  · have : (n_value N : exprℝ) ≤ 2 * sqrt (log N) :=\n      by\n      apply (ceil_lt_add_one <| sqrt_nonneg _).le.trans\n      rw [two_mul, add_le_add_iff_left]\n      apply le_sqrt_of_sq_le\n      rw [one_pow, le_log_iff_exp_le hN₀]\n      exact (exp_one_lt_d9.le.trans <| by norm_num).trans (cast_le.2 hN₃)\n    apply (mul_le_mul_of_nonneg_left this <| log_nonneg one_le_two).trans _\n    rw [← mul_assoc, ← le_div_iff (real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 _), div_sqrt]\n    · apply log_two_mul_two_le_sqrt_log_eight.trans\n      apply real.sqrt_le_sqrt\n      rw [log_le_log _ hN₀]\n      · exact_mod_cast hN₃\n      · norm_num\n    exact hN₃.trans_lt' (by norm_num)\n  · exact cast_pos.2 (n_value_pos <| hN₃.trans' <| by norm_num)\n  · exact (rpow_pos_of_pos hN₀ _).ne'\n  · exact div_pos (rpow_pos_of_pos hN₀ _) zero_lt_two\n#align d_value_pos d_value_pos\n\n",
 "ceil_lt_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ceil_lt_mul {x : exprℝ} (hx : 50 / 19 ≤ x) : («expr⌈ ⌉₊» x : exprℝ) < 1.38 * x :=\n  by\n  refine' (ceil_lt_add_one <| hx.trans' <| by norm_num).trans_le _\n  rwa [← le_sub_iff_add_le', ← sub_one_mul, show (69 / 50 - 1 : exprℝ) = (50 / 19)⁻¹ by norm_num1, ← div_eq_inv_mul,\n    one_le_div]\n  norm_num1\n#align ceil_lt_mul ceil_lt_mul\n\n",
 "card_sphere_le_roth_number_nat":
 "theorem card_sphere_le_roth_number_nat (n d k : ℕ) : (sphere n d k).card ≤ roth_number_nat ((2 * d - 1) ^ n) :=\n  by\n  cases n\n  · refine' (card_le_univ _).trans_eq _\n    rw [pow_zero]\n    exact fintype.card_unique\n  cases d\n  · simp\n  refine' add_salem_spencer_image_sphere.le_roth_number_nat _ _ (card_image_of_inj_on _)\n  · simp only [subset_iff, mem_image, and_imp, forall_exists_index, mem_range, forall_apply_eq_imp_iff₂, sphere,\n      mem_filter]\n    rintro _ x hx _ rfl\n    exact (map_le_of_mem_box hx).trans_lt sum_lt\n  refine' map_inj_on.mono fun x => _\n  simp only [mem_coe, sphere, mem_filter, mem_box, and_imp, two_mul]\n  exact fun h _ i => (h i).trans_le le_self_add\n#align card_sphere_le_roth_number_nat card_sphere_le_roth_number_nat\n\n",
 "card_box":
 "@[simp]\ntheorem card_box : (box n d).card = d ^ n := by simp [box]\n#align card_box card_box\n\n",
 "box_zero":
 "@[simp]\ntheorem box_zero : box (n + 1) 0 = ∅ := by simp [box]\n#align box_zero box_zero\n\n",
 "bound_aux'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem bound_aux' (n d : ℕ) : (d ^ n / ↑(n * d ^ 2) : exprℝ) ≤ roth_number_nat ((2 * d - 1) ^ n) :=\n  let ⟨k, h⟩ := exists_large_sphere n d\n  h.trans <| cast_le.2 <| card_sphere_le_roth_number_nat _ _ _\n#align bound_aux' bound_aux'\n\n",
 "bound_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem bound_aux (hd : d ≠ 0) (hn : 2 ≤ n) : (d ^ (n - 2) / n : exprℝ) ≤ roth_number_nat ((2 * d - 1) ^ n) :=\n  by\n  convert bound_aux' n d using 1\n  rw [cast_mul, cast_pow, mul_comm, ← div_div, pow_sub₀ _ _ hn, ← div_eq_mul_inv]\n  rwa [cast_ne_zero]\n#align bound_aux bound_aux\n\n",
 "bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem bound (hN : 4096 ≤ N) : (N : exprℝ) ^ (1 / n_value N : exprℝ) / exp 1 < d_value N :=\n  by\n  apply div_lt_floor _\n  rw [← log_le_log, log_rpow, mul_comm, ← div_eq_mul_one_div]\n  · apply le_trans _ (div_le_div_of_le_left _ _ (ceil_lt_mul _).le)\n    rw [mul_comm, ← div_div, div_sqrt, le_div_iff]\n    · exact le_sqrt_log hN\n    · norm_num1\n    · apply log_nonneg\n      rw [one_le_cast]\n      exact hN.trans' (by norm_num1)\n    · rw [cast_pos, lt_ceil, cast_zero, real.sqrt_pos]\n      apply log_pos\n      rw [one_lt_cast]\n      exact hN.trans_lt' (by norm_num1)\n    apply le_sqrt_of_sq_le\n    have : ((12 : ℕ) : exprℝ) * log 2 ≤ log N :=\n      by\n      rw [← log_rpow zero_lt_two, log_le_log, rpow_nat_cast]\n      · norm_num1\n        exact_mod_cast hN\n      · exact rpow_pos_of_pos zero_lt_two _\n      rw [cast_pos]\n      exact hN.trans_lt' (by norm_num1)\n    refine' le_trans _ this\n    simp only [cast_bit0, cast_bit1, cast_one]\n    rw [← div_le_iff']\n    · exact log_two_gt_d9.le.trans' (by norm_num1)\n    · norm_num1\n  · rw [cast_pos]\n    exact hN.trans_lt' (by norm_num1)\n  · refine' div_pos zero_lt_two _\n    rw [sub_pos, div_lt_one (exp_pos _)]\n    exact lt_of_le_of_lt (by norm_num1) exp_one_gt_d9\n  apply rpow_pos_of_pos\n  rw [cast_pos]\n  exact hN.trans_lt' (by norm_num1)\n#align bound bound\n\n",
 "add_salem_spencer_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_salem_spencer_sphere : add_salem_spencer (sphere n d k : set (fin n → ℕ)) :=\n  by\n  set f : «expr →+ » (fin n → ℕ) (euclidean_space (exprℝ) (fin n)) :=\n    { to_fun := fun f => (coe : ℕ → exprℝ) ∘ f\n      map_zero' := funext fun _ => cast_zero\n      map_add' := fun _ _ => funext fun _ => cast_add _ _ }\n  refine' add_salem_spencer.of_image (f.to_add_freiman_hom (sphere n d k) 2) _ _\n  · exact cast_injective.comp_left.inj_on _\n  refine' (add_salem_spencer_sphere 0 <| sqrt k).mono (Set.image_subset_iff.2 fun x => _)\n  rw [Set.mem_preimage, mem_sphere_zero_iff_norm]\n  exact norm_of_mem_sphere\n#align add_salem_spencer_sphere add_salem_spencer_sphere\n\n",
 "add_salem_spencer_image_sphere":
 "theorem add_salem_spencer_image_sphere : add_salem_spencer ((sphere n d k).image (map (2 * d - 1)) : set ℕ) :=\n  by\n  rw [coe_image]\n  refine'\n    @add_salem_spencer.image _ (fin n → ℕ) ℕ _ _ (sphere n d k) _ (map (2 * d - 1)) (map_inj_on.mono _)\n      add_salem_spencer_sphere\n  rw [set.add_subset_iff]\n  rintro a ha b hb i\n  have hai := mem_box.1 (sphere_subset_box ha) i\n  have hbi := mem_box.1 (sphere_subset_box hb) i\n  rw [lt_tsub_iff_right, ← succ_le_iff, two_mul]\n  exact (add_add_add_comm _ _ 1 1).trans_le (add_le_add hai hbi)\n#align add_salem_spencer_image_sphere add_salem_spencer_image_sphere\n\n"}