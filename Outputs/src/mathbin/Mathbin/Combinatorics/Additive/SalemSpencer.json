{"roth_number_nat_zero":
 "@[simp]\ntheorem roth_number_nat_zero : roth_number_nat 0 = 0 :=\n  rfl\n#align roth_number_nat_zero roth_number_nat_zero\n\n",
 "roth_number_nat_spec":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» range[finset.range] n) -/\ntheorem roth_number_nat_spec (n : â„•) :\n    âˆƒ (t : _)(_ : t âŠ† range n), t.card = roth_number_nat n âˆ§ add_salem_spencer (t : Set â„•) :=\n  add_roth_number_spec _\n#align roth_number_nat_spec roth_number_nat_spec\n\n",
 "roth_number_nat_le":
 "theorem roth_number_nat_le (N : â„•) : roth_number_nat N â‰¤ N :=\n  (add_roth_number_le _).trans (card_range _).le\n#align roth_number_nat_le roth_number_nat_le\n\n",
 "roth_number_nat_is_O_with_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem roth_number_nat_is_O_with_id : IsBigOWith 1 atTop (fun N => (roth_number_nat N : exprâ„)) fun N => (N : exprâ„) :=\n  isBigOWith_of_le _ <| by simpa only [Real.norm_coe_nat, Nat.cast_le] using roth_number_nat_le\n#align roth_number_nat_is_O_with_id roth_number_nat_is_O_with_id\n\n",
 "roth_number_nat_is_O_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr =O[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- The Roth number has the trivial bound `roth_number_nat N = O(N)`. -/\ntheorem roth_number_nat_is_O_id : Â«expr =O[ ] Â» (fun N => (roth_number_nat N : exprâ„)) atTop fun N => (N : exprâ„) :=\n  roth_number_nat_is_O_with_id.is_O\n#align roth_number_nat_is_O_id roth_number_nat_is_O_id\n\n",
 "roth_number_nat_def":
 "theorem roth_number_nat_def (n : â„•) : roth_number_nat n = add_roth_number (range n) :=\n  rfl\n#align roth_number_nat_def roth_number_nat_def\n\n",
 "roth_number_nat_add_le":
 "/-- The Roth number is a subadditive function. Note that by Fekete's lemma this shows that\nthe limit `roth_number_nat N / N` exists, but Roth's theorem gives the stronger result that this\nlimit is actually `0`. -/\ntheorem roth_number_nat_add_le (M N : â„•) : roth_number_nat (M + N) â‰¤ roth_number_nat M + roth_number_nat N :=\n  by\n  simp_rw [roth_number_nat_def]\n  rw [range_add_eq_union, â† add_roth_number_map_add_left (range N) M]\n  exact add_roth_number_union_le _ _\n#align roth_number_nat_add_le roth_number_nat_add_le\n\n",
 "roth_number_eq":
 "@[to_additive]\ntheorem mul_salem_spencer.roth_number_eq (hs : mul_salem_spencer (s : Set Î±)) : mul_roth_number s = s.card :=\n  (mul_roth_number_le _).antisymm <| hs.le_mul_roth_number <| Subset.refl _\n#align mul_salem_spencer.roth_number_eq mul_salem_spencer.roth_number_eq\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[to_additive add_salem_spencer.prod]\ntheorem mul_salem_spencer.prod {t : Set Î²} (hs : mul_salem_spencer s) (ht : mul_salem_spencer t) :\n    mul_salem_spencer (lower_set.prod s t) := fun a b c ha hb hc h =>\n  Prod.ext (hs ha.1 hb.1 hc.1 (Prod.ext_iff.1 h).1) (ht ha.2 hb.2 hc.2 (Prod.ext_iff.1 h).2)\n#align mul_salem_spencer.prod mul_salem_spencer.prod\n\n",
 "of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem mul_salem_spencer.of_image [FunLike F Î± fun _ => Î²] [FreimanHomClass F s Î² 2] (f : F) (hf : s.inj_on f)\n    (h : mul_salem_spencer (Â«expr '' Â» f s)) : mul_salem_spencer s := fun a b c ha hb hc habc =>\n  hf ha hb <|\n    h (mem_image_of_mem _ ha) (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) <|\n      map_mul_map_eq_map_mul_map f ha hb hc hc habc\n#align mul_salem_spencer.of_image mul_salem_spencer.of_image\n\n",
 "mul_salem_spencer_singleton":
 "@[simp, to_additive]\ntheorem mul_salem_spencer_singleton (a : Î±) : mul_salem_spencer ({a} : Set Î±) :=\n  subsingleton_singleton.mul_salem_spencer\n#align mul_salem_spencer_singleton mul_salem_spencer_singleton\n\n",
 "mul_salem_spencer_pi":
 "@[to_additive]\ntheorem mul_salem_spencer_pi {Î¹ : Type _} {Î± : Î¹ â†’ Type _} [âˆ€ i, Monoid (Î± i)] {s : âˆ€ i, Set (Î± i)}\n    (hs : âˆ€ i, mul_salem_spencer (s i)) : mul_salem_spencer ((univ : Set Î¹).pi s) := fun a b c ha hb hc h =>\n  funext fun i => hs i (ha i trivial) (hb i trivial) (hc i trivial) <| congr_fun h i\n#align mul_salem_spencer_pi mul_salem_spencer_pi\n\n",
 "mul_salem_spencer_pair":
 "@[simp, to_additive]\ntheorem mul_salem_spencer_pair (a b : Î±) : mul_salem_spencer ({a, b} : Set Î±) :=\n  by\n  rw [mul_salem_spencer_insert]\n  refine' âŸ¨mul_salem_spencer_singleton _, _, _âŸ©\n  Â· rintro c d (rfl : c = b) (rfl : d = c)\n    exact mul_right_cancel\n  Â· rintro c d (rfl : c = b) (rfl : d = c) _\n    rfl\n#align mul_salem_spencer_pair mul_salem_spencer_pair\n\n",
 "mul_salem_spencer_mul_right_iffâ‚€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mul_salem_spencer_mul_right_iffâ‚€ (ha : a â‰  0) :\n    mul_salem_spencer (Â«expr '' Â» (Â· * a) s) â†” mul_salem_spencer s :=\n  âŸ¨fun hs b c d hb hc hd h =>\n    mul_right_cancelâ‚€ ha\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    fun hs => hs.mul_rightâ‚€ haâŸ©\n#align mul_salem_spencer_mul_right_iffâ‚€ mul_salem_spencer_mul_right_iffâ‚€\n\n",
 "mul_salem_spencer_mul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem mul_salem_spencer_mul_right_iff : mul_salem_spencer (Â«expr '' Â» (Â· * a) s) â†” mul_salem_spencer s :=\n  âŸ¨fun hs b c d hb hc hd h =>\n    mul_right_cancel\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    mul_salem_spencer.mul_rightâŸ©\n#align mul_salem_spencer_mul_right_iff mul_salem_spencer_mul_right_iff\n\n",
 "mul_salem_spencer_mul_left_iffâ‚€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mul_salem_spencer_mul_left_iffâ‚€ (ha : a â‰  0) :\n    mul_salem_spencer (Â«expr '' Â» ((Â· * Â·) a) s) â†” mul_salem_spencer s :=\n  âŸ¨fun hs b c d hb hc hd h =>\n    mul_left_cancelâ‚€ ha\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    fun hs => hs.mul_leftâ‚€ haâŸ©\n#align mul_salem_spencer_mul_left_iffâ‚€ mul_salem_spencer_mul_left_iffâ‚€\n\n",
 "mul_salem_spencer_mul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem mul_salem_spencer_mul_left_iff : mul_salem_spencer (Â«expr '' Â» ((Â· * Â·) a) s) â†” mul_salem_spencer s :=\n  âŸ¨fun hs b c d hb hc hd h =>\n    mul_left_cancel\n      (hs (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) (mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    mul_salem_spencer.mul_leftâŸ©\n#align mul_salem_spencer_mul_left_iff mul_salem_spencer_mul_left_iff\n\n",
 "mul_salem_spencer_insert_of_lt":
 "@[to_additive]\ntheorem mul_salem_spencer_insert_of_lt (hs : âˆ€ i âˆˆ s, i < a) :\n    mul_salem_spencer (insert a s) â†” mul_salem_spencer s âˆ§ âˆ€ â¦ƒb câ¦„, b âˆˆ s â†’ c âˆˆ s â†’ a * b = c * c â†’ a = b :=\n  by\n  refine' mul_salem_spencer_insert.trans _\n  rw [â† and_assoc']\n  exact and_iff_left fun b c hb hc h => ((mul_lt_mul_of_lt_of_lt (hs _ hb) (hs _ hc)).ne h).elim\n#align mul_salem_spencer_insert_of_lt mul_salem_spencer_insert_of_lt\n\n",
 "mul_salem_spencer_insert":
 "@[to_additive]\ntheorem mul_salem_spencer_insert :\n    mul_salem_spencer (insert a s) â†”\n      mul_salem_spencer s âˆ§\n        (âˆ€ â¦ƒb câ¦„, b âˆˆ s â†’ c âˆˆ s â†’ a * b = c * c â†’ a = b) âˆ§ âˆ€ â¦ƒb câ¦„, b âˆˆ s â†’ c âˆˆ s â†’ b * c = a * a â†’ b = c :=\n  by\n  refine'\n    âŸ¨fun hs =>\n      âŸ¨hs.mono (subset_insert _ _), fun b c hb hc => hs (or.inl rfl) (or.inr hb) (or.inr hc), fun b c hb hc =>\n        hs (or.inr hb) (or.inr hc) (or.inl rfl)âŸ©,\n      _âŸ©\n  rintro âŸ¨hs, ha, ha'âŸ© b c d hb hc hd h\n  rw [mem_insert_iff] at hb hc hd\n  obtain rfl | hb := hb <;> obtain rfl | hc := hc\n  Â· rfl\n  all_goals obtain rfl | hd := hd\n  Â· exact (mul_left_cancel h).symm\n  Â· exact ha hc hd h\n  Â· exact mul_right_cancel h\n  Â· exact (ha hb hd <| (mul_comm _ _).trans h).symm\n  Â· exact ha' hb hc h\n  Â· exact hs hb hc hd h\n#align mul_salem_spencer_insert mul_salem_spencer_insert\n\n",
 "mul_salem_spencer_empty":
 "@[simp, to_additive]\ntheorem mul_salem_spencer_empty : mul_salem_spencer (âˆ… : Set Î±) := fun a _ _ ha => ha.elim\n#align mul_salem_spencer_empty mul_salem_spencer_empty\n\n",
 "mul_salem_spencer":
 "@[to_additive]\ntheorem set.subsingleton.mul_salem_spencer (hs : s.subsingleton) : mul_salem_spencer s := fun a b _ ha hb _ _ =>\n  hs ha hb\n#align set.subsingleton.mul_salem_spencer set.subsingleton.mul_salem_spencer\n\n",
 "mul_roth_number_union_le":
 "@[to_additive]\ntheorem mul_roth_number_union_le (s t : Finset Î±) : mul_roth_number (s âˆª t) â‰¤ mul_roth_number s + mul_roth_number t :=\n  let âŸ¨u, hus, hcard, huâŸ© := mul_roth_number_spec (s âˆª t)\n  calc\n    mul_roth_number (s âˆª t) = u.card := hcard.symm\n    _ = (u âˆ© s âˆª u âˆ© t).card := by rw [â† inter_distrib_left, (inter_eq_left_iff_subset _ _).2 hus]\n    _ â‰¤ (u âˆ© s).card + (u âˆ© t).card := (card_union_le _ _)\n    _ â‰¤ mul_roth_number s + mul_roth_number t :=\n      add_le_add ((hu.mono <| inter_subset_left _ _).le_mul_roth_number <| inter_subset_right _ _)\n        ((hu.mono <| inter_subset_left _ _).le_mul_roth_number <| inter_subset_right _ _)\n    \n#align mul_roth_number_union_le mul_roth_number_union_le\n\n",
 "mul_roth_number_spec":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t Â«expr âŠ† Â» s) -/\n@[to_additive]\ntheorem mul_roth_number_spec : âˆƒ (t : _)(_ : t âŠ† s), t.card = mul_roth_number s âˆ§ mul_salem_spencer (t : Set Î±) :=\n  @Nat.findGreatest_spec _ _ (fun m => âˆƒ (t : _)(_ : t âŠ† s), t.card = m âˆ§ mul_salem_spencer (t : Set Î±)) _\n    (nat.zero_le _) âŸ¨âˆ…, empty_subset _, card_empty, mul_salem_spencer_emptyâŸ©\n#align mul_roth_number_spec mul_roth_number_spec\n\n",
 "mul_roth_number_singleton":
 "@[simp, to_additive]\ntheorem mul_roth_number_singleton (a : Î±) : mul_roth_number ({a} : Finset Î±) = 1 :=\n  by\n  convert mul_salem_spencer.roth_number_eq _\n  rw [coe_singleton]\n  exact mul_salem_spencer_singleton a\n#align mul_roth_number_singleton mul_roth_number_singleton\n\n",
 "mul_roth_number_map_mul_right":
 "@[simp, to_additive]\ntheorem mul_roth_number_map_mul_right : mul_roth_number (s.map <| mulRightEmbedding a) = mul_roth_number s := by\n  rw [â† mul_left_embedding_eq_mul_right_embedding, mul_roth_number_map_mul_left s a]\n#align mul_roth_number_map_mul_right mul_roth_number_map_mul_right\n\n",
 "mul_roth_number_map_mul_left":
 "@[simp, to_additive]\ntheorem mul_roth_number_map_mul_left : mul_roth_number (s.map <| mulLeftEmbedding a) = mul_roth_number s :=\n  by\n  refine' le_antisymm _ _\n  Â· obtain âŸ¨u, hus, hcard, huâŸ© := mul_roth_number_spec (s.map <| mulLeftEmbedding a)\n    rw [subset_map_iff] at hus\n    obtain âŸ¨u, hus, rflâŸ© := hus\n    rw [coe_map] at hu\n    rw [â† hcard, card_map]\n    exact (mul_salem_spencer_mul_left_iff.1 hu).le_mul_roth_number hus\n  Â· obtain âŸ¨u, hus, hcard, huâŸ© := mul_roth_number_spec s\n    have h : mul_salem_spencer (u.map <| mulLeftEmbedding a : Set Î±) :=\n      by\n      rw [coe_map]\n      exact hu.mul_left\n    convert h.le_mul_roth_number (map_subset_map.2 hus)\n    rw [card_map, hcard]\n#align mul_roth_number_map_mul_left mul_roth_number_map_mul_left\n\n",
 "mul_roth_number_lt_of_forall_not_mul_salem_spencer":
 "@[to_additive]\ntheorem mul_roth_number_lt_of_forall_not_mul_salem_spencer\n    (h : âˆ€ t âˆˆ powersetLen n s, Â¬mul_salem_spencer ((t : Finset Î±) : Set Î±)) : mul_roth_number s < n :=\n  by\n  obtain âŸ¨t, hts, hcard, htâŸ© := mul_roth_number_spec s\n  rw [â† hcard, â† not_le]\n  intro hn\n  obtain âŸ¨u, hut, rflâŸ© := exists_smaller_set t n hn\n  exact h _ (mem_powerset_len.2 âŸ¨hut.trans hts, rflâŸ©) (ht.mono hut)\n#align mul_roth_number_lt_of_forall_not_mul_salem_spencer mul_roth_number_lt_of_forall_not_mul_salem_spencer\n\n",
 "mul_roth_number_le":
 "@[to_additive]\ntheorem mul_roth_number_le : mul_roth_number s â‰¤ s.card := by convert Nat.findGreatest_le s.card\n#align mul_roth_number_le mul_roth_number_le\n\n",
 "mul_roth_number_empty":
 "@[simp, to_additive]\ntheorem mul_roth_number_empty : mul_roth_number (âˆ… : Finset Î±) = 0 :=\n  nat.eq_zero_of_le_zero <| (mul_roth_number_le _).trans card_empty.le\n#align mul_roth_number_empty mul_roth_number_empty\n\n",
 "mul_rightâ‚€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mul_salem_spencer.mul_rightâ‚€ (hs : mul_salem_spencer s) (ha : a â‰  0) :\n    mul_salem_spencer (Â«expr '' Â» (Â· * a) s) :=\n  by\n  rintro _ _ _ âŸ¨b, hb, rflâŸ© âŸ¨c, hc, rflâŸ© âŸ¨d, hd, rflâŸ© h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm d] at h\n  rw [hs hb hc hd (mul_right_cancelâ‚€ (mul_ne_zero ha ha) h)]\n#align mul_salem_spencer.mul_rightâ‚€ mul_salem_spencer.mul_rightâ‚€\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem mul_salem_spencer.mul_right (hs : mul_salem_spencer s) : mul_salem_spencer (Â«expr '' Â» (Â· * a) s) :=\n  by\n  rintro _ _ _ âŸ¨b, hb, rflâŸ© âŸ¨c, hc, rflâŸ© âŸ¨d, hd, rflâŸ© h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm d] at h\n  rw [hs hb hc hd (mul_right_cancel h)]\n#align mul_salem_spencer.mul_right mul_salem_spencer.mul_right\n\n",
 "mul_leftâ‚€":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mul_salem_spencer.mul_leftâ‚€ (hs : mul_salem_spencer s) (ha : a â‰  0) :\n    mul_salem_spencer (Â«expr '' Â» ((Â· * Â·) a) s) :=\n  by\n  rintro _ _ _ âŸ¨b, hb, rflâŸ© âŸ¨c, hc, rflâŸ© âŸ¨d, hd, rflâŸ© h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm a d] at h\n  rw [hs hb hc hd (mul_left_cancelâ‚€ (mul_ne_zero ha ha) h)]\n#align mul_salem_spencer.mul_leftâ‚€ mul_salem_spencer.mul_leftâ‚€\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[to_additive]\ntheorem mul_salem_spencer.mul_left (hs : mul_salem_spencer s) : mul_salem_spencer (Â«expr '' Â» ((Â· * Â·) a) s) :=\n  by\n  rintro _ _ _ âŸ¨b, hb, rflâŸ© âŸ¨c, hc, rflâŸ© âŸ¨d, hd, rflâŸ© h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm a d] at h\n  rw [hs hb hc hd (mul_left_cancel h)]\n#align mul_salem_spencer.mul_left mul_salem_spencer.mul_left\n\n",
 "mono":
 "/-\nCopyright (c) 2021 YaÃ«l Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: YaÃ«l Dillies, Bhavik Mehta\n-/\n@[to_additive]\ntheorem mul_salem_spencer.mono (h : t âŠ† s) (hs : mul_salem_spencer s) : mul_salem_spencer t := fun a b c ha hb hc =>\n  hs (h ha) (h hb) (h hc)\n#align mul_salem_spencer.mono mul_salem_spencer.mono\n\n",
 "le_roth_number_nat":
 "/-- A verbose specialization of `add_salem_spencer.le_add_roth_number`, sometimes convenient in\npractice. -/\ntheorem add_salem_spencer.le_roth_number_nat (s : Finset â„•) (hs : add_salem_spencer (s : Set â„•)) (hsn : âˆ€ x âˆˆ s, x < n)\n    (hsk : s.card = k) : k â‰¤ roth_number_nat n :=\n  hsk.ge.trans <| hs.le_add_roth_number fun x hx => mem_range.2 <| hsn x hx\n#align add_salem_spencer.le_roth_number_nat add_salem_spencer.le_roth_number_nat\n\n",
 "le_mul_roth_number_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[to_additive]\ntheorem le_mul_roth_number_product (s : Finset Î±) (t : Finset Î²) :\n    mul_roth_number s * mul_roth_number t â‰¤ mul_roth_number (lower_set.prod s t) :=\n  by\n  obtain âŸ¨u, hus, hucard, huâŸ© := mul_roth_number_spec s\n  obtain âŸ¨v, hvt, hvcard, hvâŸ© := mul_roth_number_spec t\n  rw [â† hucard, â† hvcard, â† card_product]\n  refine' mul_salem_spencer.le_mul_roth_number _ (product_subset_product hus hvt)\n  rw [coe_product]\n  exact hu.prod hv\n#align le_mul_roth_number_product le_mul_roth_number_product\n\n",
 "le_mul_roth_number":
 "@[to_additive]\ntheorem mul_salem_spencer.le_mul_roth_number (hs : mul_salem_spencer (s : Set Î±)) (h : s âŠ† t) :\n    s.card â‰¤ mul_roth_number t :=\n  le_findGreatest (card_le_of_subset h) âŸ¨s, h, rfl, hsâŸ©\n#align mul_salem_spencer.le_mul_roth_number mul_salem_spencer.le_mul_roth_number\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n-- TODO: Generalize to Freiman homs\n@[to_additive]\ntheorem mul_salem_spencer.image [MulHomClass F Î± Î²] (f : F) (hf : (s * s).inj_on f) (h : mul_salem_spencer s) :\n    mul_salem_spencer (Â«expr '' Â» f s) :=\n  by\n  rintro _ _ _ âŸ¨a, ha, rflâŸ© âŸ¨b, hb, rflâŸ© âŸ¨c, hc, rflâŸ© habc\n  rw [h ha hb hc (hf (mul_mem_mul ha hb) (mul_mem_mul hc hc) <| by rwa [map_mul, map_mul])]\n#align mul_salem_spencer.image mul_salem_spencer.image\n\n",
 "add_salem_spencer_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem add_salem_spencer_sphere [NormedAddCommGroup E] [NormedSpace (exprâ„) E] [strict_convex_space (exprâ„) E] (x : E)\n    (r : exprâ„) : add_salem_spencer (sphere x r) :=\n  by\n  obtain rfl | hr := eq_or_ne r 0\n  Â· rw [sphere_zero]\n    exact add_salem_spencer_singleton _\n  Â· convert add_salem_spencer_frontier is_closed_ball (strict_convex_closed_ball (exprâ„) x r)\n    exact (frontier_closedBall _ hr).symm\n#align add_salem_spencer_sphere add_salem_spencer_sphere\n\n",
 "add_salem_spencer_iff_eq_right":
 "theorem add_salem_spencer_iff_eq_right {s : Set â„•} :\n    add_salem_spencer s â†” âˆ€ â¦ƒa b câ¦„, a âˆˆ s â†’ b âˆˆ s â†’ c âˆˆ s â†’ a + b = c + c â†’ a = c :=\n  by\n  refine' forallâ‚„_congr fun a b c _ => forallâ‚ƒ_congr fun _ _ habc => âŸ¨_, _âŸ©\n  Â· rintro rfl\n    simp_rw [â† two_mul] at habc\n    exact mul_left_cancelâ‚€ two_ne_zero habc\n  Â· rintro rfl\n    exact (add_left_cancel habc).symm\n#align add_salem_spencer_iff_eq_right add_salem_spencer_iff_eq_right\n\n",
 "add_salem_spencer_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- The frontier of a closed strictly convex set only contains trivial arithmetic progressions.\nThe idea is that an arithmetic progression is contained on a line and the frontier of a strictly\nconvex set does not contain lines. -/\ntheorem add_salem_spencer_frontier [LinearOrderedField ğ•œ] [TopologicalSpace E] [AddCommMonoid E] [Module ğ•œ E]\n    {s : Set E} (hsâ‚€ : IsClosed s) (hsâ‚ : StrictConvex ğ•œ s) : add_salem_spencer (frontier s) :=\n  by\n  intro a b c ha hb hc habc\n  obtain rfl : Â«expr â€¢ Â» (1 / 2 : ğ•œ) a + Â«expr â€¢ Â» (1 / 2 : ğ•œ) b = c := by\n    rwa [â† smul_add, one_div, inv_smul_eq_iffâ‚€ (show (2 : ğ•œ) â‰  0 by norm_num), two_smul]\n  exact hsâ‚.eq (hsâ‚€.frontier_subset ha) (hsâ‚€.frontier_subset hb) one_half_pos one_half_pos (add_halves _) hc.2\n#align add_salem_spencer_frontier add_salem_spencer_frontier\n\n",
 "add_roth_number_Ico":
 "theorem add_roth_number_Ico (a b : â„•) : add_roth_number (Ico a b) = roth_number_nat (b - a) :=\n  by\n  obtain h | h := le_total b a\n  Â· rw [tsub_eq_zero_of_le h, Ico_eq_empty_of_le h, roth_number_nat_zero, add_roth_number_empty]\n  convert add_roth_number_map_add_left _ a\n  rw [range_eq_Ico, map_eq_image]\n  convert(image_add_left_Ico 0 (b - a) _).symm\n  exact (add_tsub_cancel_of_le h).symm\n#align add_roth_number_Ico add_roth_number_Ico\n\n"}