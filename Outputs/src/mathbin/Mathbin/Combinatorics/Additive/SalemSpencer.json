{"roth_number_nat_zero":
 "@[simp]\ntheorem roth_number_nat_zero : roth_number_nat 0 = 0 :=\n  rfl\n#align roth_number_nat_zero roth_number_nat_zero\n\n",
 "roth_number_nat_spec":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » range[finset.range] n) -/\ntheorem roth_number_nat_spec (n : ℕ) :\n    ∃ (t : _)(_ : t ⊆ range n), t.card = roth_number_nat n ∧ add_salem_spencer (t : Set ℕ) :=\n  add_roth_number_spec _\n#align roth_number_nat_spec roth_number_nat_spec\n\n",
 "roth_number_nat_le":
 "theorem roth_number_nat_le (N : ℕ) : roth_number_nat N ≤ N :=\n  (add_roth_number_le _).trans (card_range _).le\n#align roth_number_nat_le roth_number_nat_le\n\n",
 "roth_number_nat_is_O_with_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem roth_number_nat_is_O_with_id : IsBigOWith 1 atTop (fun N => (roth_number_nat N : exprℝ)) fun N => (N : exprℝ) :=\n  isBigOWith_of_le _ <| by simpa only [Real.norm_coe_nat, Nat.cast_le] using roth_number_nat_le\n#align roth_number_nat_is_O_with_id roth_number_nat_is_O_with_id\n\n",
 "roth_number_nat_is_O_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =O[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The Roth number has the trivial bound `roth_number_nat N = O(N)`. -/\ntheorem roth_number_nat_is_O_id : «expr =O[ ] » (fun N => (roth_number_nat N : exprℝ)) atTop fun N => (N : exprℝ) :=\n  roth_number_nat_is_O_with_id.is_O\n#align roth_number_nat_is_O_id roth_number_nat_is_O_id\n\n",
 "roth_number_nat_def":
 "theorem roth_number_nat_def (n : ℕ) : roth_number_nat n = add_roth_number (range n) :=\n  rfl\n#align roth_number_nat_def roth_number_nat_def\n\n",
 "roth_number_nat_add_le":
 "/-- The Roth number is a subadditive function. Note that by Fekete's lemma this shows that\nthe limit `roth_number_nat N / N` exists, but Roth's theorem gives the stronger result that this\nlimit is actually `0`. -/\ntheorem roth_number_nat_add_le (M N : ℕ) : roth_number_nat (M + N) ≤ roth_number_nat M + roth_number_nat N :=\n  by\n  simp_rw [roth_number_nat_def]\n  rw [range_add_eq_union, ← add_roth_number_map_add_left (range N) M]\n  exact add_roth_number_union_le _ _\n#align roth_number_nat_add_le roth_number_nat_add_le\n\n",
 "roth_number_eq":
 "@[to_additive]\ntheorem mul_salem_spencer.roth_number_eq (hs : mul_salem_spencer (s : Set α)) : mul_roth_number s = s.card :=\n  (mul_roth_number_le _).antisymm <| hs.le_mul_roth_number <| Subset.refl _\n#align mul_salem_spencer.roth_number_eq mul_salem_spencer.roth_number_eq\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[to_additive add_salem_spencer.prod]\ntheorem mul_salem_spencer.prod {t : Set β} (hs : mul_salem_spencer s) (ht : mul_salem_spencer t) :\n    mul_salem_spencer (lower_set.prod s t) := fun a b c ha hb hc h =>\n  Prod.ext (hs ha.1 hb.1 hc.1 (Prod.ext_iff.1 h).1) (ht ha.2 hb.2 hc.2 (Prod.ext_iff.1 h).2)\n#align mul_salem_spencer.prod mul_salem_spencer.prod\n\n",
 "of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mul_salem_spencer.of_image [FunLike F α fun _ => β] [FreimanHomClass F s β 2] (f : F) (hf : s.inj_on f)\n    (h : mul_salem_spencer («expr '' » f s)) : mul_salem_spencer s := fun a b c ha hb hc habc =>\n  hf ha hb <|\n    h (mem_image_of_mem _ ha) (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) <|\n      map_mul_map_eq_map_mul_map f ha hb hc hc habc\n#align mul_salem_spencer.of_image mul_salem_spencer.of_image\n\n",
 "mul_salem_spencer_singleton":
 "@[simp, to_additive]\ntheorem mul_salem_spencer_singleton (a : α) : mul_salem_spencer ({a} : Set α) :=\n  subsingleton_singleton.mul_salem_spencer\n#align mul_salem_spencer_singleton mul_salem_spencer_singleton\n\n",
 "mul_salem_spencer_pi":
 "@[to_additive]\ntheorem mul_salem_spencer_pi {ι : Type _} {α : ι → Type _} [∀ i, Monoid (α i)] {s : ∀ i, Set (α i)}\n    (hs : ∀ i, mul_salem_spencer (s i)) : mul_salem_spencer ((univ : Set ι).pi s) := fun a b c ha hb hc h =>\n  funext fun i => hs i (ha i trivial) (hb i trivial) (hc i trivial) <| congr_fun h i\n#align mul_salem_spencer_pi mul_salem_spencer_pi\n\n",
 "mul_salem_spencer_pair":
 "@[simp, to_additive]\ntheorem mul_salem_spencer_pair (a b : α) : mul_salem_spencer ({a, b} : Set α) :=\n  by\n  rw [mul_salem_spencer_insert]\n  refine' ⟨mul_salem_spencer_singleton _, _, _⟩\n  · rintro c d (rfl : c = b) (rfl : d = c)\n    exact mul_right_cancel\n  · rintro c d (rfl : c = b) (rfl : d = c) _\n    rfl\n#align mul_salem_spencer_pair mul_salem_spencer_pair\n\n",
 "mul_salem_spencer_mul_right_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mul_salem_spencer_mul_right_iff₀ (ha : a ≠ 0) :\n    mul_salem_spencer («expr '' » (· * a) s) ↔ mul_salem_spencer s :=\n  ⟨fun hs b c d hb hc hd h =>\n    mul_right_cancel₀ ha\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    fun hs => hs.mul_right₀ ha⟩\n#align mul_salem_spencer_mul_right_iff₀ mul_salem_spencer_mul_right_iff₀\n\n",
 "mul_salem_spencer_mul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mul_salem_spencer_mul_right_iff : mul_salem_spencer («expr '' » (· * a) s) ↔ mul_salem_spencer s :=\n  ⟨fun hs b c d hb hc hd h =>\n    mul_right_cancel\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    mul_salem_spencer.mul_right⟩\n#align mul_salem_spencer_mul_right_iff mul_salem_spencer_mul_right_iff\n\n",
 "mul_salem_spencer_mul_left_iff₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mul_salem_spencer_mul_left_iff₀ (ha : a ≠ 0) :\n    mul_salem_spencer («expr '' » ((· * ·) a) s) ↔ mul_salem_spencer s :=\n  ⟨fun hs b c d hb hc hd h =>\n    mul_left_cancel₀ ha\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    fun hs => hs.mul_left₀ ha⟩\n#align mul_salem_spencer_mul_left_iff₀ mul_salem_spencer_mul_left_iff₀\n\n",
 "mul_salem_spencer_mul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mul_salem_spencer_mul_left_iff : mul_salem_spencer («expr '' » ((· * ·) a) s) ↔ mul_salem_spencer s :=\n  ⟨fun hs b c d hb hc hd h =>\n    mul_left_cancel\n      (hs (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) (mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    mul_salem_spencer.mul_left⟩\n#align mul_salem_spencer_mul_left_iff mul_salem_spencer_mul_left_iff\n\n",
 "mul_salem_spencer_insert_of_lt":
 "@[to_additive]\ntheorem mul_salem_spencer_insert_of_lt (hs : ∀ i ∈ s, i < a) :\n    mul_salem_spencer (insert a s) ↔ mul_salem_spencer s ∧ ∀ ⦃b c⦄, b ∈ s → c ∈ s → a * b = c * c → a = b :=\n  by\n  refine' mul_salem_spencer_insert.trans _\n  rw [← and_assoc']\n  exact and_iff_left fun b c hb hc h => ((mul_lt_mul_of_lt_of_lt (hs _ hb) (hs _ hc)).ne h).elim\n#align mul_salem_spencer_insert_of_lt mul_salem_spencer_insert_of_lt\n\n",
 "mul_salem_spencer_insert":
 "@[to_additive]\ntheorem mul_salem_spencer_insert :\n    mul_salem_spencer (insert a s) ↔\n      mul_salem_spencer s ∧\n        (∀ ⦃b c⦄, b ∈ s → c ∈ s → a * b = c * c → a = b) ∧ ∀ ⦃b c⦄, b ∈ s → c ∈ s → b * c = a * a → b = c :=\n  by\n  refine'\n    ⟨fun hs =>\n      ⟨hs.mono (subset_insert _ _), fun b c hb hc => hs (or.inl rfl) (or.inr hb) (or.inr hc), fun b c hb hc =>\n        hs (or.inr hb) (or.inr hc) (or.inl rfl)⟩,\n      _⟩\n  rintro ⟨hs, ha, ha'⟩ b c d hb hc hd h\n  rw [mem_insert_iff] at hb hc hd\n  obtain rfl | hb := hb <;> obtain rfl | hc := hc\n  · rfl\n  all_goals obtain rfl | hd := hd\n  · exact (mul_left_cancel h).symm\n  · exact ha hc hd h\n  · exact mul_right_cancel h\n  · exact (ha hb hd <| (mul_comm _ _).trans h).symm\n  · exact ha' hb hc h\n  · exact hs hb hc hd h\n#align mul_salem_spencer_insert mul_salem_spencer_insert\n\n",
 "mul_salem_spencer_empty":
 "@[simp, to_additive]\ntheorem mul_salem_spencer_empty : mul_salem_spencer (∅ : Set α) := fun a _ _ ha => ha.elim\n#align mul_salem_spencer_empty mul_salem_spencer_empty\n\n",
 "mul_salem_spencer":
 "@[to_additive]\ntheorem set.subsingleton.mul_salem_spencer (hs : s.subsingleton) : mul_salem_spencer s := fun a b _ ha hb _ _ =>\n  hs ha hb\n#align set.subsingleton.mul_salem_spencer set.subsingleton.mul_salem_spencer\n\n",
 "mul_roth_number_union_le":
 "@[to_additive]\ntheorem mul_roth_number_union_le (s t : Finset α) : mul_roth_number (s ∪ t) ≤ mul_roth_number s + mul_roth_number t :=\n  let ⟨u, hus, hcard, hu⟩ := mul_roth_number_spec (s ∪ t)\n  calc\n    mul_roth_number (s ∪ t) = u.card := hcard.symm\n    _ = (u ∩ s ∪ u ∩ t).card := by rw [← inter_distrib_left, (inter_eq_left_iff_subset _ _).2 hus]\n    _ ≤ (u ∩ s).card + (u ∩ t).card := (card_union_le _ _)\n    _ ≤ mul_roth_number s + mul_roth_number t :=\n      add_le_add ((hu.mono <| inter_subset_left _ _).le_mul_roth_number <| inter_subset_right _ _)\n        ((hu.mono <| inter_subset_left _ _).le_mul_roth_number <| inter_subset_right _ _)\n    \n#align mul_roth_number_union_le mul_roth_number_union_le\n\n",
 "mul_roth_number_spec":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n@[to_additive]\ntheorem mul_roth_number_spec : ∃ (t : _)(_ : t ⊆ s), t.card = mul_roth_number s ∧ mul_salem_spencer (t : Set α) :=\n  @Nat.findGreatest_spec _ _ (fun m => ∃ (t : _)(_ : t ⊆ s), t.card = m ∧ mul_salem_spencer (t : Set α)) _\n    (nat.zero_le _) ⟨∅, empty_subset _, card_empty, mul_salem_spencer_empty⟩\n#align mul_roth_number_spec mul_roth_number_spec\n\n",
 "mul_roth_number_singleton":
 "@[simp, to_additive]\ntheorem mul_roth_number_singleton (a : α) : mul_roth_number ({a} : Finset α) = 1 :=\n  by\n  convert mul_salem_spencer.roth_number_eq _\n  rw [coe_singleton]\n  exact mul_salem_spencer_singleton a\n#align mul_roth_number_singleton mul_roth_number_singleton\n\n",
 "mul_roth_number_map_mul_right":
 "@[simp, to_additive]\ntheorem mul_roth_number_map_mul_right : mul_roth_number (s.map <| mulRightEmbedding a) = mul_roth_number s := by\n  rw [← mul_left_embedding_eq_mul_right_embedding, mul_roth_number_map_mul_left s a]\n#align mul_roth_number_map_mul_right mul_roth_number_map_mul_right\n\n",
 "mul_roth_number_map_mul_left":
 "@[simp, to_additive]\ntheorem mul_roth_number_map_mul_left : mul_roth_number (s.map <| mulLeftEmbedding a) = mul_roth_number s :=\n  by\n  refine' le_antisymm _ _\n  · obtain ⟨u, hus, hcard, hu⟩ := mul_roth_number_spec (s.map <| mulLeftEmbedding a)\n    rw [subset_map_iff] at hus\n    obtain ⟨u, hus, rfl⟩ := hus\n    rw [coe_map] at hu\n    rw [← hcard, card_map]\n    exact (mul_salem_spencer_mul_left_iff.1 hu).le_mul_roth_number hus\n  · obtain ⟨u, hus, hcard, hu⟩ := mul_roth_number_spec s\n    have h : mul_salem_spencer (u.map <| mulLeftEmbedding a : Set α) :=\n      by\n      rw [coe_map]\n      exact hu.mul_left\n    convert h.le_mul_roth_number (map_subset_map.2 hus)\n    rw [card_map, hcard]\n#align mul_roth_number_map_mul_left mul_roth_number_map_mul_left\n\n",
 "mul_roth_number_lt_of_forall_not_mul_salem_spencer":
 "@[to_additive]\ntheorem mul_roth_number_lt_of_forall_not_mul_salem_spencer\n    (h : ∀ t ∈ powersetLen n s, ¬mul_salem_spencer ((t : Finset α) : Set α)) : mul_roth_number s < n :=\n  by\n  obtain ⟨t, hts, hcard, ht⟩ := mul_roth_number_spec s\n  rw [← hcard, ← not_le]\n  intro hn\n  obtain ⟨u, hut, rfl⟩ := exists_smaller_set t n hn\n  exact h _ (mem_powerset_len.2 ⟨hut.trans hts, rfl⟩) (ht.mono hut)\n#align mul_roth_number_lt_of_forall_not_mul_salem_spencer mul_roth_number_lt_of_forall_not_mul_salem_spencer\n\n",
 "mul_roth_number_le":
 "@[to_additive]\ntheorem mul_roth_number_le : mul_roth_number s ≤ s.card := by convert Nat.findGreatest_le s.card\n#align mul_roth_number_le mul_roth_number_le\n\n",
 "mul_roth_number_empty":
 "@[simp, to_additive]\ntheorem mul_roth_number_empty : mul_roth_number (∅ : Finset α) = 0 :=\n  nat.eq_zero_of_le_zero <| (mul_roth_number_le _).trans card_empty.le\n#align mul_roth_number_empty mul_roth_number_empty\n\n",
 "mul_right₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mul_salem_spencer.mul_right₀ (hs : mul_salem_spencer s) (ha : a ≠ 0) :\n    mul_salem_spencer («expr '' » (· * a) s) :=\n  by\n  rintro _ _ _ ⟨b, hb, rfl⟩ ⟨c, hc, rfl⟩ ⟨d, hd, rfl⟩ h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm d] at h\n  rw [hs hb hc hd (mul_right_cancel₀ (mul_ne_zero ha ha) h)]\n#align mul_salem_spencer.mul_right₀ mul_salem_spencer.mul_right₀\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mul_salem_spencer.mul_right (hs : mul_salem_spencer s) : mul_salem_spencer («expr '' » (· * a) s) :=\n  by\n  rintro _ _ _ ⟨b, hb, rfl⟩ ⟨c, hc, rfl⟩ ⟨d, hd, rfl⟩ h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm d] at h\n  rw [hs hb hc hd (mul_right_cancel h)]\n#align mul_salem_spencer.mul_right mul_salem_spencer.mul_right\n\n",
 "mul_left₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mul_salem_spencer.mul_left₀ (hs : mul_salem_spencer s) (ha : a ≠ 0) :\n    mul_salem_spencer («expr '' » ((· * ·) a) s) :=\n  by\n  rintro _ _ _ ⟨b, hb, rfl⟩ ⟨c, hc, rfl⟩ ⟨d, hd, rfl⟩ h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm a d] at h\n  rw [hs hb hc hd (mul_left_cancel₀ (mul_ne_zero ha ha) h)]\n#align mul_salem_spencer.mul_left₀ mul_salem_spencer.mul_left₀\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem mul_salem_spencer.mul_left (hs : mul_salem_spencer s) : mul_salem_spencer («expr '' » ((· * ·) a) s) :=\n  by\n  rintro _ _ _ ⟨b, hb, rfl⟩ ⟨c, hc, rfl⟩ ⟨d, hd, rfl⟩ h\n  rw [mul_mul_mul_comm, mul_mul_mul_comm a d] at h\n  rw [hs hb hc hd (mul_left_cancel h)]\n#align mul_salem_spencer.mul_left mul_salem_spencer.mul_left\n\n",
 "mono":
 "/-\nCopyright (c) 2021 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta\n-/\n@[to_additive]\ntheorem mul_salem_spencer.mono (h : t ⊆ s) (hs : mul_salem_spencer s) : mul_salem_spencer t := fun a b c ha hb hc =>\n  hs (h ha) (h hb) (h hc)\n#align mul_salem_spencer.mono mul_salem_spencer.mono\n\n",
 "le_roth_number_nat":
 "/-- A verbose specialization of `add_salem_spencer.le_add_roth_number`, sometimes convenient in\npractice. -/\ntheorem add_salem_spencer.le_roth_number_nat (s : Finset ℕ) (hs : add_salem_spencer (s : Set ℕ)) (hsn : ∀ x ∈ s, x < n)\n    (hsk : s.card = k) : k ≤ roth_number_nat n :=\n  hsk.ge.trans <| hs.le_add_roth_number fun x hx => mem_range.2 <| hsn x hx\n#align add_salem_spencer.le_roth_number_nat add_salem_spencer.le_roth_number_nat\n\n",
 "le_mul_roth_number_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `lower_set.prod -/\n@[to_additive]\ntheorem le_mul_roth_number_product (s : Finset α) (t : Finset β) :\n    mul_roth_number s * mul_roth_number t ≤ mul_roth_number (lower_set.prod s t) :=\n  by\n  obtain ⟨u, hus, hucard, hu⟩ := mul_roth_number_spec s\n  obtain ⟨v, hvt, hvcard, hv⟩ := mul_roth_number_spec t\n  rw [← hucard, ← hvcard, ← card_product]\n  refine' mul_salem_spencer.le_mul_roth_number _ (product_subset_product hus hvt)\n  rw [coe_product]\n  exact hu.prod hv\n#align le_mul_roth_number_product le_mul_roth_number_product\n\n",
 "le_mul_roth_number":
 "@[to_additive]\ntheorem mul_salem_spencer.le_mul_roth_number (hs : mul_salem_spencer (s : Set α)) (h : s ⊆ t) :\n    s.card ≤ mul_roth_number t :=\n  le_findGreatest (card_le_of_subset h) ⟨s, h, rfl, hs⟩\n#align mul_salem_spencer.le_mul_roth_number mul_salem_spencer.le_mul_roth_number\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- TODO: Generalize to Freiman homs\n@[to_additive]\ntheorem mul_salem_spencer.image [MulHomClass F α β] (f : F) (hf : (s * s).inj_on f) (h : mul_salem_spencer s) :\n    mul_salem_spencer («expr '' » f s) :=\n  by\n  rintro _ _ _ ⟨a, ha, rfl⟩ ⟨b, hb, rfl⟩ ⟨c, hc, rfl⟩ habc\n  rw [h ha hb hc (hf (mul_mem_mul ha hb) (mul_mem_mul hc hc) <| by rwa [map_mul, map_mul])]\n#align mul_salem_spencer.image mul_salem_spencer.image\n\n",
 "add_salem_spencer_sphere":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_salem_spencer_sphere [NormedAddCommGroup E] [NormedSpace (exprℝ) E] [strict_convex_space (exprℝ) E] (x : E)\n    (r : exprℝ) : add_salem_spencer (sphere x r) :=\n  by\n  obtain rfl | hr := eq_or_ne r 0\n  · rw [sphere_zero]\n    exact add_salem_spencer_singleton _\n  · convert add_salem_spencer_frontier is_closed_ball (strict_convex_closed_ball (exprℝ) x r)\n    exact (frontier_closedBall _ hr).symm\n#align add_salem_spencer_sphere add_salem_spencer_sphere\n\n",
 "add_salem_spencer_iff_eq_right":
 "theorem add_salem_spencer_iff_eq_right {s : Set ℕ} :\n    add_salem_spencer s ↔ ∀ ⦃a b c⦄, a ∈ s → b ∈ s → c ∈ s → a + b = c + c → a = c :=\n  by\n  refine' forall₄_congr fun a b c _ => forall₃_congr fun _ _ habc => ⟨_, _⟩\n  · rintro rfl\n    simp_rw [← two_mul] at habc\n    exact mul_left_cancel₀ two_ne_zero habc\n  · rintro rfl\n    exact (add_left_cancel habc).symm\n#align add_salem_spencer_iff_eq_right add_salem_spencer_iff_eq_right\n\n",
 "add_salem_spencer_frontier":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The frontier of a closed strictly convex set only contains trivial arithmetic progressions.\nThe idea is that an arithmetic progression is contained on a line and the frontier of a strictly\nconvex set does not contain lines. -/\ntheorem add_salem_spencer_frontier [LinearOrderedField 𝕜] [TopologicalSpace E] [AddCommMonoid E] [Module 𝕜 E]\n    {s : Set E} (hs₀ : IsClosed s) (hs₁ : StrictConvex 𝕜 s) : add_salem_spencer (frontier s) :=\n  by\n  intro a b c ha hb hc habc\n  obtain rfl : «expr • » (1 / 2 : 𝕜) a + «expr • » (1 / 2 : 𝕜) b = c := by\n    rwa [← smul_add, one_div, inv_smul_eq_iff₀ (show (2 : 𝕜) ≠ 0 by norm_num), two_smul]\n  exact hs₁.eq (hs₀.frontier_subset ha) (hs₀.frontier_subset hb) one_half_pos one_half_pos (add_halves _) hc.2\n#align add_salem_spencer_frontier add_salem_spencer_frontier\n\n",
 "add_roth_number_Ico":
 "theorem add_roth_number_Ico (a b : ℕ) : add_roth_number (Ico a b) = roth_number_nat (b - a) :=\n  by\n  obtain h | h := le_total b a\n  · rw [tsub_eq_zero_of_le h, Ico_eq_empty_of_le h, roth_number_nat_zero, add_roth_number_empty]\n  convert add_roth_number_map_add_left _ a\n  rw [range_eq_Ico, map_eq_image]\n  convert(image_add_left_Ico 0 (b - a) _).symm\n  exact (add_tsub_cancel_of_le h).symm\n#align add_roth_number_Ico add_roth_number_Ico\n\n"}