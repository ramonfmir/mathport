{"success_iff":
 "theorem success_iff : (∀ pos' err, p cb n ≠ fail pos' err) ↔ ∃ (pos' : ℕ)(result : α), p cb n = done pos' result := by\n  cases p cb n <;> simp\n#align success_iff success_iff\n\n",
 "str_iff":
 "theorem str_iff {s : string} : (str s).prog ↔ s ≠ \"\" := by\n  simp [str_eq_char_buf, char_buf_iff, ← String.toList_inj, buffer.ext_iff]\n#align str_iff str_iff\n\n",
 "str_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+: » -/\ntheorem str_eq_done {s : string} :\n    str s cb n = done n' u ↔ n + s.length = n' ∧ «expr <+: » s.to_list (cb.to_list.drop n) := by\n  simp [str_eq_char_buf, char_buf_eq_done]\n#align str_eq_done str_eq_done\n\n",
 "str_eq_char_buf":
 "theorem str_eq_char_buf (s : string) : str s = char_buf s.to_list.to_buffer :=\n  by\n  ext (cb n)\n  rw [str, char_buf]\n  congr\n  · simp [buffer.to_string, String.asString_inv_toList]\n  · simp\n#align str_eq_char_buf str_eq_char_buf\n\n",
 "seq_right_eq_fail":
 "theorem seq_right_eq_fail {p : parser α} {q : parser β} :\n    (p *> q) cb n = fail n' err ↔\n      p cb n = fail n' err ∨ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ q cb np = fail n' err :=\n  by simp [seq_right_eq, seq_eq_fail]\n#align seq_right_eq_fail seq_right_eq_fail\n\n",
 "seq_right_eq_done":
 "theorem seq_right_eq_done {p : parser α} {q : parser β} :\n    (p *> q) cb n = done n' b ↔ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ q cb np = done n' b := by\n  simp [seq_right_eq, seq_eq_done, map_eq_done, and_comm, and_assoc]\n#align seq_right_eq_done seq_right_eq_done\n\n",
 "seq_left_eq_fail":
 "theorem seq_left_eq_fail {p : parser α} {q : parser β} :\n    (p <* q) cb n = fail n' err ↔\n      p cb n = fail n' err ∨ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ q cb np = fail n' err :=\n  by simp [seq_left_eq, seq_eq_fail]\n#align seq_left_eq_fail seq_left_eq_fail\n\n",
 "seq_left_eq_done":
 "theorem seq_left_eq_done {p : parser α} {q : parser β} :\n    (p <* q) cb n = done n' a ↔ ∃ (np : ℕ)(b : β), p cb n = done np a ∧ q cb np = done n' b :=\n  by\n  have : ∀ p q : ℕ → α → Prop, (∃ (np : ℕ)(x : α), p np x ∧ q np x ∧ x = a) ↔ ∃ np : ℕ, p np a ∧ q np a := fun _ _ =>\n    ⟨fun ⟨np, x, hp, hq, rfl⟩ => ⟨np, hp, hq⟩, fun ⟨np, hp, hq⟩ => ⟨np, a, hp, hq, rfl⟩⟩\n  simp [seq_left_eq, seq_eq_done, map_eq_done, this]\n#align seq_left_eq_done seq_left_eq_done\n\n",
 "seq_eq_fail":
 "theorem seq_eq_fail {f : parser (α → β)} {p : parser α} :\n    (f <*> p) cb n = fail n' err ↔\n      f cb n = fail n' err ∨ ∃ (nf : ℕ)(f' : α → β), f cb n = done nf f' ∧ p cb nf = fail n' err :=\n  by simp [seq_eq_bind_map]\n#align seq_eq_fail seq_eq_fail\n\n",
 "seq_eq_done":
 "theorem seq_eq_done {f : parser (α → β)} {p : parser α} :\n    (f <*> p) cb n = done n' b ↔ ∃ (nf : ℕ)(f' : α → β)(a : α), f cb n = done nf f' ∧ p cb nf = done n' a ∧ f' a = b :=\n  by simp [seq_eq_bind_map]\n#align seq_eq_done seq_eq_done\n\n",
 "sep_by_eq_done_nil":
 "theorem sep_by_eq_done_nil {sep : parser Unit} {p : parser α} :\n    sep_by sep p cb n = done n' [] ↔ n = n' ∧ ∃ err, sep_by1 sep p cb n = fail n err := by simp [sep_by, pure_eq_done]\n#align sep_by_eq_done_nil sep_by_eq_done_nil\n\n",
 "sep_by1_ne_done_nil":
 "@[simp]\ntheorem sep_by1_ne_done_nil {sep : parser Unit} {p : parser α} : sep_by1 sep p cb n ≠ done n' [] := by\n  simp [sep_by1, seq_eq_done]\n#align sep_by1_ne_done_nil sep_by1_ne_done_nil\n\n",
 "sep_by1_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem sep_by1_eq_done {sep : parser Unit} {p : parser α} {l : List α} :\n    sep_by1 sep p cb n = done n' (sym.cons' a l) ↔ ∃ np : ℕ, p cb n = done np a ∧ (sep >> p).many cb np = done n' l :=\n  by simp [sep_by1, seq_eq_done]\n#align sep_by1_eq_done sep_by1_eq_done\n\n",
 "sat_iff":
 "theorem sat_iff {p : char → Prop} [DecidablePred p] : static (sat p) ↔ ∀ c, ¬p c :=\n  by\n  constructor\n  · intro\n    intro c hc\n    have : sat p [c].to_buffer 0 = done 1 c := by simp [sat_eq_done, hc]\n    exact zero_ne_one (of_done this)\n  · contrapose!\n    simp only [iff, sat_eq_done, and_imp, exists_prop, exists_and_right, exists_and_left, exists_imp, not_forall]\n    rintro _ _ _ a h hne rfl hp -\n    exact ⟨a, hp⟩\n#align sat_iff sat_iff\n\n",
 "sat_eq_fail":
 "theorem sat_eq_fail {p : char → Prop} [DecidablePred p] :\n    sat p cb n = fail n' err ↔ n = n' ∧ err = dlist.empty ∧ ∀ h : n < cb.size, ¬p (cb.read ⟨n, h⟩) :=\n  by\n  dsimp only [sat]\n  split_ifs <;> simp [*, eq_comm]\n#align sat_eq_fail sat_eq_fail\n\n",
 "sat_eq_done":
 "theorem sat_eq_done {p : char → Prop} [DecidablePred p] :\n    sat p cb n = done n' c ↔ ∃ hn : n < cb.size, p c ∧ n' = n + 1 ∧ cb.read ⟨n, hn⟩ = c :=\n  by\n  by_cases hn : n < cb.size\n  · by_cases hp : p (cb.read ⟨n, hn⟩)\n    · simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true]\n      constructor\n      · rintro ⟨rfl, rfl⟩\n        simp [hp]\n      · rintro ⟨-, rfl, rfl⟩\n        simp\n    · simp only [sat, hn, hp, dif_pos, false_iff_iff, not_and, exists_prop_of_true, if_false]\n      rintro H - rfl\n      exact hp H\n  · simp [sat, hn]\n#align sat_eq_done sat_eq_done\n\n",
 "sat":
 "theorem sat : conditionally_unfailing (sat fun _ => True) :=\n  ⟨fun _ _ hn => by simp [success_iff, sat_eq_done, hn]⟩\n#align sat sat\n\n",
 "return_eq_pure":
 "@[simp]\ntheorem return_eq_pure : @return parser _ _ a = pure a :=\n  rfl\n#align return_eq_pure return_eq_pure\n\n",
 "remaining_ne_fail":
 "theorem remaining_ne_fail : remaining cb n ≠ fail n' err := by simp [remaining]\n#align remaining_ne_fail remaining_ne_fail\n\n",
 "remaining_eq_done":
 "theorem remaining_eq_done {r : ℕ} : remaining cb n = done n' r ↔ n = n' ∧ cb.size - n = r := by simp [remaining]\n#align remaining_eq_done remaining_eq_done\n\n",
 "remaining":
 "theorem remaining : ¬remaining.prog := by\n  intro h\n  have : remaining buffer.nil 0 = done 0 0 := by simp [remaining_eq_done]\n  replace this : 0 < 0 := prog.of_done this\n  exact (lt_irrefl _) this\n#align remaining remaining\n\n",
 "pure_ne_fail":
 "@[simp]\ntheorem pure_ne_fail : (pure a : parser α) cb n ≠ fail n' err := by simp [pure_eq_done]\n#align pure_ne_fail pure_ne_fail\n\n",
 "pure_eq_done":
 "theorem pure_eq_done : @pure parser _ _ a = fun _ n => done n a :=\n  rfl\n#align pure_eq_done pure_eq_done\n\n",
 "pure":
 "-- see Note [lower instance priority]\ntheorem pure (a : α) : ¬prog (pure a) := by\n  intro h\n  have : (pure a : parser α) buffer.nil 0 = done 0 a := by simp [pure_eq_done]\n  replace this : 0 < 0 := prog.of_done this\n  exact (lt_irrefl _) this\n#align pure pure\n\n",
 "orelse_pure_eq_fail":
 "@[simp]\ntheorem orelse_pure_eq_fail : (p <|> pure a) cb n = fail n' err ↔ p cb n = fail n' err ∧ n ≠ n' :=\n  by\n  by_cases hn : n = n'\n  · simp [hn, pure_eq_done]\n  · simp [orelse_eq_fail_of_mono_ne, hn]\n#align orelse_pure_eq_fail orelse_pure_eq_fail\n\n",
 "orelse_eq_orelse":
 "@[simp]\ntheorem orelse_eq_orelse : p.orelse q = (p <|> q) :=\n  rfl\n#align orelse_eq_orelse orelse_eq_orelse\n\n",
 "orelse_eq_fail_of_mono_ne":
 "theorem orelse_eq_fail_of_mono_ne [q.mono] (hn : n ≠ n') : (p <|> q) cb n = fail n' err ↔ p cb n = fail n' err :=\n  by\n  cases' hp : p cb n with np resp np errp\n  · simp [hp, ← orelse_eq_orelse, parser.orelse]\n  · by_cases h : np = n\n    · cases' hq : q cb n with nq resq nq errq\n      · simp [hp, h, hn, hq, hn, ← orelse_eq_orelse, parser.orelse]\n      · have : n ≤ nq := mono.of_fail hq\n        rcases eq_or_lt_of_le this with (rfl | H)\n        · simp [hp, hq, h, hn, lt_irrefl, ← orelse_eq_orelse, parser.orelse]\n        · simp [hp, hq, h, hn, H, ← orelse_eq_orelse, parser.orelse]\n    · simp [hp, h, ← orelse_eq_orelse, parser.orelse]\n#align orelse_eq_fail_of_mono_ne orelse_eq_fail_of_mono_ne\n\n",
 "orelse_eq_fail_not_mono_lt":
 "theorem orelse_eq_fail_not_mono_lt (hn : n' < n) :\n    (p <|> q) cb n = fail n' err ↔ p cb n = fail n' err ∨ q cb n = fail n' err ∧ ∃ errp, p cb n = fail n errp :=\n  by\n  cases' hp : p cb n with np resp np errp\n  · simp [hp, ← orelse_eq_orelse, parser.orelse]\n  · by_cases h : np = n\n    · cases' hq : q cb n with nq resq nq errq\n      · simp [hp, h, hn, hq, ne_of_gt hn, ← orelse_eq_orelse, parser.orelse]\n      · rcases lt_trichotomy nq n with (H | H | H)\n        · simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ← orelse_eq_orelse, parser.orelse]\n        · simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ← orelse_eq_orelse, parser.orelse]\n        · simp [hp, hq, h, H, ne_of_gt (hn.trans H), ← orelse_eq_orelse, parser.orelse]\n    · simp [hp, h, ← orelse_eq_orelse, parser.orelse]\n#align orelse_eq_fail_not_mono_lt orelse_eq_fail_not_mono_lt\n\n",
 "orelse_eq_fail_eq":
 "@[simp]\ntheorem orelse_eq_fail_eq :\n    (p <|> q) cb n = fail n err ↔\n      (p cb n = fail n err ∧ ∃ nq errq, n < nq ∧ q cb n = fail nq errq) ∨\n        ∃ errp errq, p cb n = fail n errp ∧ q cb n = fail n errq ∧ errp ++ errq = err :=\n  by\n  cases' hp : p cb n with np resp np errp\n  · simp [hp, ← orelse_eq_orelse, parser.orelse]\n  · by_cases hn : np = n\n    · cases' hq : q cb n with nq resq nq errq\n      · simp [hp, hn, hq, ← orelse_eq_orelse, parser.orelse]\n      ·\n        rcases lt_trichotomy nq n with (H | rfl | H) <;>\n          first\n            |simp [hp, hq, hn, ← orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H,\n              not_lt_of_lt H]|simp [hp, hq, hn, ← orelse_eq_orelse, parser.orelse, lt_irrefl]\n    · simp [hp, hn, ← orelse_eq_orelse, parser.orelse]\n#align orelse_eq_fail_eq orelse_eq_fail_eq\n\n",
 "orelse_eq_done":
 "@[simp]\ntheorem orelse_eq_done :\n    (p <|> q) cb n = done n' a ↔ p cb n = done n' a ∨ q cb n = done n' a ∧ ∃ err, p cb n = fail n err :=\n  by\n  cases' hp : p cb n with np resp np errp\n  · simp [hp, ← orelse_eq_orelse, parser.orelse]\n  · by_cases hn : np = n\n    · cases' hq : q cb n with nq resq nq errq\n      · simp [hp, hn, hq, ← orelse_eq_orelse, parser.orelse]\n      ·\n        rcases lt_trichotomy nq n with (H | rfl | H) <;>\n          first\n            |simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ← orelse_eq_orelse,\n              parser.orelse]|simp [hp, hn, hq, lt_irrefl, ← orelse_eq_orelse, parser.orelse]\n    · simp [hp, hn, ← orelse_eq_orelse, parser.orelse]\n#align orelse_eq_done orelse_eq_done\n\n",
 "one_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem one_of_iff {cs : List char} : static (one_of cs) ↔ cs = [] :=\n  by\n  cases' cs with hd tl\n  · simp [one_of, static.decorate_errors]\n  · have : one_of (sym.cons' hd tl) (sym.cons' hd tl).to_buffer 0 = done 1 hd := by simp [one_of_eq_done]\n    simpa using not_of_ne this zero_ne_one\n#align one_of_iff one_of_iff\n\n",
 "one_of_eq_done":
 "theorem one_of_eq_done {cs : List char} :\n    one_of cs cb n = done n' c ↔ ∃ hn : n < cb.size, c ∈ cs ∧ n' = n + 1 ∧ cb.read ⟨n, hn⟩ = c := by\n  simp [one_of, sat_eq_done]\n#align one_of_eq_done one_of_eq_done\n\n",
 "one_of'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem one_of'_iff {cs : List char} : static (one_of' cs) ↔ cs = [] :=\n  by\n  cases' cs with hd tl\n  · simp [one_of', static.bind]\n  · have : one_of' (sym.cons' hd tl) (sym.cons' hd tl).to_buffer 0 = done 1 () := by simp [one_of'_eq_done]\n    simpa using not_of_ne this zero_ne_one\n#align one_of'_iff one_of'_iff\n\n",
 "one_of'_eq_done":
 "theorem one_of'_eq_done {cs : List char} :\n    one_of' cs cb n = done n' u ↔ ∃ hn : n < cb.size, cb.read ⟨n, hn⟩ ∈ cs ∧ n' = n + 1 :=\n  by\n  simp only [one_of', one_of_eq_done, eps_eq_done, and_comm, and_then_eq_bind, bind_eq_done, exists_eq_left,\n    exists_and_left]\n  constructor\n  · rintro ⟨c, hc, rfl, hn, rfl⟩\n    exact ⟨rfl, hn, hc⟩\n  · rintro ⟨rfl, hn, hc⟩\n    exact ⟨cb.read ⟨n, hn⟩, hc, rfl, hn, rfl⟩\n#align one_of'_eq_done one_of'_eq_done\n\n",
 "of_fail":
 "theorem conditionally_unfailing.of_fail [p.conditionally_unfailing] (h : p cb n = fail n' err) (hn : n < cb.size) :\n    False := by\n  obtain ⟨np, a, hp⟩ := p.exists_done_in_bounds hn\n  simpa [hp] using h\n#align conditionally_unfailing.of_fail conditionally_unfailing.of_fail\n\n",
 "of_done":
 "theorem bounded.of_done [p.bounded] (h : p cb n = done n' a) : n < cb.size :=\n  by\n  contrapose! h\n  obtain ⟨np, err, hp⟩ := bounded.exists p h\n  simp [hp]\n#align bounded.of_done bounded.of_done\n\n",
 "of_bounded":
 "theorem of_bounded [p.bounded] : ¬unfailing p := by\n  intro\n  cases h : p buffer.nil 0\n  · simpa [lt_irrefl] using bounded.of_done h\n  · exact of_fail h\n#align of_bounded of_bounded\n\n",
 "not_step_of_static_done":
 "theorem not_step_of_static_done [static p] (h : ∃ cb n n' a, p cb n = done n' a) : ¬step p :=\n  by\n  intro\n  rcases h with ⟨cb, n, n', a, h⟩\n  have hs := static.of_done h\n  simpa [← hs] using of_done h\n#align not_step_of_static_done not_step_of_static_done\n\n",
 "not_of_ne":
 "theorem not_of_ne (h : p cb n = fail n' err) (hne : n ≠ n') : ¬err_static p :=\n  by\n  intro\n  exact hne (of_fail h)\n#align not_of_ne not_of_ne\n\n",
 "not_failure_eq_done":
 "theorem not_failure_eq_done : ¬(failure : parser α) cb n = done n' a := by simp\n#align not_failure_eq_done not_failure_eq_done\n\n",
 "nat_of_done_bounded":
 "/-- If we know that `parser.nat` was successful, starting at position `n` and ending at position `n'`,\nthen it must be the case that for the ending position `n'`, either it is beyond the end of the\n`cb : char_buffer`, or the character at that position is not \"numeric\", that is,  between `'0'` and\n`'9'` inclusive.\n\nThis is a necessary part of proving one of the directions of `nat_eq_done`.\n-/\ntheorem nat_of_done_bounded {val : ℕ} (h : nat cb n = done n' val) :\n    ∀ hn : n' < cb.size, '0' ≤ cb.read ⟨n', hn⟩ → '9' < cb.read ⟨n', hn⟩ :=\n  by\n  -- The properties to be shown for the characters involved rely solely on the success of\n  -- `parser.digit` at the relevant positions, and not on the actual value `parser.nat` produced.\n  -- We break done the success of `parser.nat` into the `parser.digit` success and throw away\n  -- the resulting value given by `parser.nat`, and focus solely on the `list ℕ` generated by\n  -- `parser.digit.many1`.\n  -- We deal with the case of `n'` is \"out-of-bounds\" right away by requiring that\n  -- `∀ (hn : n' < cb.size)`. Thus we only have to prove the lemma for the cases where `n'` is still\n  -- \"in-bounds\".\n  simp only [Nat, pure_eq_done, and_left_comm, decorate_error_eq_done, bind_eq_done, exists_eq_left, exists_and_left] at\n    h\n  obtain ⟨xs, h, -⟩ := h\n  -- We want to avoid having to make statements about the `cb : char_buffer` itself. Instead, we\n  -- induct on the `xs : list ℕ` that `parser.digit.many1` produced.\n  induction' xs with hd tl hl generalizing n n'\n  ·-- Base case: `xs` is empty. But this is a contradiction because `many1` always produces a\n    -- nonempty list, as proven by `many1_ne_done_nil`.\n    simpa using h\n  -- Inductive case: at least one character has been parsed in, starting at position `n`.\n  -- We know that the size of `cb : char_buffer` must be at least `n + 1` because\n  -- `parser.digit.many1` is `bounded` (`n < cb.size`).\n  -- We show that either we parsed in just that one character, or we use the inductive hypothesis.\n  obtain ⟨k, hk⟩ : ∃ k, cb.size = n + k + 1 := Nat.exists_eq_add_of_lt (bounded.of_done h)\n  cases tl\n  · -- Case where `tl = []`, so we parsed in only `hd`. That must mean that `parser.digit` failed\n    -- at `n + 1`.\n    simp only [many1_eq_done, many_eq_done_nil, and_left_comm, exists_and_right, exists_eq_left] at h\n    -- We throw away the success information of what happened at position `n`, and we do not need\n    -- the \"error\" value that the failure produced.\n    obtain ⟨-, _, h⟩ := h\n    -- If `parser.digit` failed at `n + 1`, then either we hit a non-numeric character, or\n    -- we are out of bounds. `digit_eq_fail` provides us with those two cases.\n    simp only [digit_eq_done, and_comm, and_left_comm, digit_eq_fail, true_and_iff, exists_eq_left, eq_self_iff_true,\n      exists_and_left] at h\n    obtain ⟨rfl, h⟩ | ⟨h, -⟩ := h\n    · -- First case: we are still in bounds, but the character is not numeric. We must prove\n      -- that we are still in bounds. But we know that from our initial requirement.\n      intro hn\n      simpa using h hn\n    ·-- Second case: we are out of bounds, and somehow the fold that `many1` relied on failed.\n      -- But we know that `parser.digit` is mono, that is, it never goes backward in position,\n      -- in neither success nor in failure. We also have that `foldr_core` respects `mono`.\n      -- But in this case, `foldr_core` is starting at position `n' + 1` but failing at\n      -- position `n'`, which is a contradiction, because otherwise we would have `n' + 1 ≤ n'`.\n      simpa using mono.of_fail h\n  · -- Case where `tl ≠ []`. But that means that `many` produced a nonempty list as a result, so\n    -- `many1` would have successfully parsed at this position too. We use this statement to\n    -- rewrite our hypothesis into something that works with the induction hypothesis, and apply it.\n    rw [many1_eq_done] at h\n    obtain ⟨_, -, h⟩ := h\n    rw [← many1_eq_done_iff_many_eq_done] at h\n    exact hl h\n#align nat_of_done_bounded nat_of_done_bounded\n\n",
 "nat_of_done_as_digit":
 "/-- If we know that `parser.nat` was successful, starting at position `n` and ending at position `n'`,\nthen it must be the case that for all `k : ℕ`, `n ≤ k`, `k < n'`, the character at the `k`th\nposition in `cb : char_buffer` is \"numeric\", that is, is between `'0'` and `'9'` inclusive.\n\nThis is a necessary part of proving one of the directions of `nat_eq_done`.\n-/\ntheorem nat_of_done_as_digit {val : ℕ} (h : nat cb n = done n' val) :\n    ∀ (hn : n' ≤ cb.size) (k) (hk : k < n'),\n      n ≤ k → '0' ≤ cb.read ⟨k, hk.trans_le hn⟩ ∧ cb.read ⟨k, hk.trans_le hn⟩ ≤ '9' :=\n  by\n  -- The properties to be shown for the characters involved rely solely on the success of\n  -- `parser.digit` at the relevant positions, and not on the actual value `parser.nat` produced.\n  -- We break done the success of `parser.nat` into the `parser.digit` success and throw away\n  -- the resulting value given by `parser.nat`, and focus solely on the `list ℕ` generated by\n  -- `parser.digit.many1`.\n  simp only [Nat, pure_eq_done, and_left_comm, decorate_error_eq_done, bind_eq_done, exists_eq_left, exists_and_left] at\n    h\n  obtain ⟨xs, h, -⟩ := h\n  -- We want to avoid having to make statements about the `cb : char_buffer` itself. Instead, we\n  -- induct on the `xs : list ℕ` that `parser.digit.many1` produced.\n  induction' xs with hd tl hl generalizing n n'\n  ·-- Base case: `xs` is empty. But this is a contradiction because `many1` always produces a\n    -- nonempty list, as proven by `many1_ne_done_nil`.\n    simpa using h\n  -- Inductive case: we prove that the `parser.digit.many1` produced a valid `(hd :: tl) : list ℕ`,\n  -- by showing that is the case for the character at position `n`, which gave `hd`, and use the\n  -- induction hypothesis on the remaining `tl`.\n  -- We break apart a `many1` success into a success of the underlying `parser.digit` to give `hd`\n  -- and a `parser.digit.many` which gives `tl`. We first deal with the `hd`.\n  rw [many1_eq_done] at h\n  -- Right away, we can throw away the information about the \"new\" position that `parser.digit`\n  -- ended on because we will soon prove that it must have been `n + 1`.\n  obtain ⟨_, hp, h⟩ := h\n  -- The main lemma here is `digit_eq_done`, which already proves the necessary conditions about\n  -- the character at hand. What is left to do is properly unpack the information.\n  simp only [digit_eq_done, and_comm, and_left_comm, digit_eq_fail, true_and_iff, exists_eq_left, eq_self_iff_true,\n    exists_and_left, exists_and_left] at hp\n  obtain ⟨rfl, -, hn, ge0, le9, rfl⟩ := hp\n  -- Let's now consider a position `k` between `n` and `n'`, excluding `n'`.\n  intro hn k hk hk'\n  -- What if we are at `n`? What if we are past `n`? We case on the `n ≤ k`.\n  rcases hk'.eq_or_lt with (rfl | hk')\n  ·-- The `n = k` case. But this is exactly what we know already, so we provide the\n    -- relevant hypotheses.\n    exact ⟨ge0, le9⟩\n  -- The `n < k` case. First, we check if there would have even been digits parsed in. So, we\n  -- case on `tl : list ℕ`\n  cases tl\n  · -- Case where `tl = []`. But that means `many` gave us a `[]` so either the character at\n    -- position `k` was not \"numeric\" or we are out of bounds. More importantly, when `many`\n    -- successfully produces a `[]`, it does not progress the parser head, so we have that\n    -- `n + 1 = n'`. This will lead to a contradiction because now we have `n < k` and `k < n + 1`.\n    simp only [many_eq_done_nil, exists_and_right] at h\n    -- Extract out just the `n + 1 = n'`.\n    obtain ⟨rfl, -⟩ := h\n    -- Form the contradictory hypothesis, and discharge the goal.\n    have : k < k := hk.trans_le (nat.succ_le_of_lt hk')\n    exact absurd this (lt_irrefl _)\n  · -- Case where `tl ≠ []`. But that means that `many` produced a nonempty list as a result, so\n    -- `many1` would have successfully parsed at this position too. We use this statement to\n    -- rewrite our hypothesis into something that works with the induction hypothesis, and apply it.\n    rw [← many1_eq_done_iff_many_eq_done] at h\n    apply hl h\n    -- All that is left to prove is that our `k` is at least our new \"lower bound\" `n + 1`, which\n    -- we have from our original split of the `n ≤ k`, since we are now on the `n < k` case.\n    exact nat.succ_le_of_lt hk'\n#align nat_of_done_as_digit nat_of_done_as_digit\n\n",
 "nat_of_done":
 "/-- The `val : ℕ` produced by a successful parse of a `cb : char_buffer` is the numerical value\nrepresented by the string of decimal digits (possibly padded with 0s on the left)\nstarting from the parsing position `n` and ending at position `n'`. The number\nof characters parsed in is necessarily `n' - n`.\n\nThis is one of the directions of `nat_eq_done`.\n-/\ntheorem nat_of_done {val : ℕ} (h : nat cb n = done n' val) :\n    val = Nat.ofDigits 10 (((cb.to_list.drop n).take (n' - n)).reverse.map fun c => c.to_nat - '0'.to_nat) :=\n  by\n  /- The parser `parser.nat` that generates a decimal number from a string of digit characters does\n    several things. First it ingests in as many digits as it can with `many1 digit`. Then, it folds\n    over the resulting `list ℕ` using a helper function that keeps track of both the running sum an\n    and the magnitude so far, using a `(sum, magnitude) : (ℕ × ℕ)` pair. The final sum is extracted\n    using a `prod.fst`.\n  \n    To prove that the value that `parser.nat` produces, after moving precisely `n' - n` steps, is\n    precisely what `nat.of_digits` would give, if supplied the string that is in the ingested\n    `char_buffer` (modulo conversion from `char` to `ℕ ), we need to induct over the length `n' - n`\n    of `cb : char_buffer` ingested, and prove that the parser must have terminated due to hitting\n    either the end of the `char_buffer` or a non-digit character.\n  \n    The statement of the lemma is phrased using a combination of `list.drop` and `list.map` because\n    there is no currently better way to extract an \"interval\" from a `char_buffer`. Additionally, the\n    statement uses a `list.reverse` because `nat.of_digits` is little-endian.\n  \n    We try to stop referring to the `cb : char_buffer` as soon as possible, so that we can instead\n    regard a `list char` instead, which lends itself better to proofs via induction.\n    -/\n  /- We first prove some helper lemmas about the definition of `parser.nat`. Since it is defined\n    in core, we have to work with how it is defined instead of changing its definition.\n    In its definition, the function that folds over the parsed in digits is defined internally,\n    as a lambda with anonymous destructor syntax, which leads to an unpleasant `nat._match_1` term\n    when rewriting the definition of `parser.nat` away. Since we know exactly what the function is,\n    we have a `rfl`-like lemma here to rewrite it back into a readable form.\n    -/\n  have natm : nat._match_1 = fun (d : ℕ) p => ⟨p.1 + d * p.2, p.2 * 10⟩ :=\n    by\n    ext1\n    ext1 ⟨⟩\n    rfl\n  -- We also have to prove what is the `prod.snd` of the result of the fold of a `list (ℕ × ℕ)` with\n  -- the function above. We use this lemma later when we finish our inductive case.\n  have hpow :\n    ∀ l,\n      (list.foldr (fun (digit : ℕ) (x : ℕ × ℕ) => (x.fst + digit * x.snd, x.snd * 10)) (0, 1) l).snd = 10 ^ l.length :=\n    by\n    intro l\n    induction' l with hd tl hl\n    · simp\n    · simp [hl, pow_succ, mul_comm]\n  -- We convert the hypothesis that `parser.nat` has succeeded into an existential that there is\n  -- some list of digits that it has parsed in, and that those digits, when folded over by the\n  -- function above, give the value at hand.\n  simp only [Nat, pure_eq_done, natm, decorate_error_eq_done, bind_eq_done] at h\n  obtain ⟨n', l, hp, rfl, rfl⟩ := h\n  -- We now want to stop working with the `cb : char_buffer` and parse positions `n` and `n'`,\n  -- and just deal with the parsed digit list `l : list ℕ`. To do so, we have to show that\n  -- this is precisely the list that could have been parsed in, no smaller and no greater.\n  induction' l with lhd ltl IH generalizing n n' cb\n  ·-- Base case: we parsed in no digits whatsoever. But this is impossible because `parser.many1`\n    -- must produce a list that is not `list.nil`, by `many1_ne_done_nil`.\n    simpa using hp\n  -- Inductive case:\n  -- We must prove that the first digit parsed in `lhd : ℕ` is precisely the digit that is\n  -- represented by the character at position `n` in `cb : char_buffer`.\n  -- We will also prove the correspondence between the subsequent digits `ltl : list ℕ` and the\n  -- remaining characters past position `n` up to position `n'`.\n  cases' hx : list.drop n (buffer.to_list cb) with chd ctl\n  · -- Are there even characters left to parse, at position `n` in the `cb : char_buffer`? In other\n    -- words, are we already out of bounds, and thus could not have parsed in any value\n    -- successfully. But this must be a contradiction because `parser.digit` is a `bounded` parser,\n    -- (due to its being defined via `parser.decorate_error`), which means it only succeeds\n    -- in-bounds, and the `many1` parser combinator retains that property.\n    have : cb.size ≤ n := by simpa using list.drop_eq_nil_iff_le.mp hx\n    exact absurd (bounded.of_done hp) this.not_lt\n  -- We prove that the first digit parsed in is precisely the digit that is represented by the\n  -- character at position `n`, which we now call `chd : char`.\n  have chdh : chd.to_nat - '0'.to_nat = lhd :=\n    by\n    simp only [many1_eq_done] at hp\n    -- We know that `parser.digit` succeeded, so it has moved to a possibly different position.\n    -- In fact, we know that this new position is `n + 1`, by the `step` property of\n    -- `parser.digit`.\n    obtain ⟨_, hp, -⟩ := hp\n    obtain rfl := step.of_done hp\n    -- We now unfold what it means for `parser.digit` to succeed, which means that the character\n    -- parsed in was \"numeric\" (for some definition of that property), and, more importantly,\n    -- that the `n`th character of `cb`, let's say `c`, when converted to a `ℕ` via\n    -- `char.to_nat c - '0'.to_nat`, must be equal to the resulting value, `lhd` in our case.\n    simp only [digit_eq_done, buffer.read_eq_nth_le_to_list, hx, buffer.length_to_list, true_and_iff, add_left_inj,\n      list.length, List.nthLe, eq_self_iff_true, exists_and_left, Fin.val_mk] at hp\n    rcases hp with ⟨_, hn, rfl, _, _⟩\n    -- But we already know the list corresponding to `cb : char_buffer` from position `n` and on\n    -- is equal to `(chd :: ctl) : list char`, so our `c` above must satisfy `c = chd`.\n    have hn' : n < cb.to_list.length := by simpa using hn\n    rw [← List.cons_nthLe_drop_succ hn'] at hx\n    -- We can ignore proving any correspondence of `ctl : list char` to the other portions of the\n    -- `cb : char_buffer`.\n    simp only at hx\n    simp [hx]\n  -- We know that we parsed in more than one character because of the `prog` property of\n  -- `parser.digit`, which the `many1` parser combinator retains. In other words, we know that\n  -- `n < n'`, and so, the list of digits `ltl` must correspond to the list of digits that\n  -- `digit.many1 cb (n + 1)` would produce. We know that the shift of `1` in `n ↦ n + 1` holds\n  -- due to the `step` property of `parser.digit`.\n  -- We also get here `k : ℕ` which will indicate how many characters we parsed in past position\n  -- `n`. We will prove later that this must be the number of digits we produced as well in `ltl`.\n  obtain ⟨k, hk⟩ : ∃ k, n' = n + k + 1 := Nat.exists_eq_add_of_lt (prog.of_done hp)\n  have hdm : ltl = [] ∨ digit.many1 cb (n + 1) = done n' ltl :=\n    by\n    cases ltl\n    · simp\n    · rw [many1_eq_done] at hp\n      obtain ⟨_, hp, hp'⟩ := hp\n      simpa [step.of_done hp, many1_eq_done_iff_many_eq_done] using hp'\n  -- Now we case on the two possibilities, that there was only a single digit parsed in, and\n  -- `ltl = []`, or, had we started parsing at `n + 1` instead, we'd parse in the value associated\n  -- with `ltl`.\n  -- We prove that the LHS, which is a fold over a `list ℕ` is equal to the RHS, which is that\n  -- the `val : ℕ` that `nat.of_digits` produces when supplied a `list ℕ that has been produced\n  -- via mapping a `list char` using `char.to_nat`. Specifically, that `list char` are the\n  -- characters in the `cb : char_buffer`, from position `n` to position `n'` (excluding `n'`),\n  -- in reverse.\n  rcases hdm with (rfl | hdm)\n  · -- Case that `ltl = []`.\n    simp only [many1_eq_done, many_eq_done_nil, exists_and_right] at hp\n    -- This means we must have failed parsing with `parser.digit` at some other position,\n    -- which we prove must be `n + 1` via the `step` property.\n    obtain ⟨_, hp, rfl, hp'⟩ := hp\n    obtain rfl := step.of_done hp\n    -- Now we rely on the simplifier, which simplfies the LHS, which is a fold over a singleton\n    -- list. On the RHS, `list.take (n + 1 - n)` also produces a singleton list, which, when\n    -- reversed, is the same list. `nat.of_digits` of a singleton list is precisely the value in\n    -- the list. And we already have that `chd.to_nat - '0'.to_nat = lhd`.\n    simp [chdh]\n  -- We now have to deal with the case where we parsed in more than one digit, and thus\n  -- `n + 1 < n'`, which means `ctl` has one or more elements. Similarly, `ltl` has one or more\n  -- elements.\n  -- We finish ridding ourselves of references to `cb : char_buffer`, by relying on the fact that\n  -- our `ctl : list char` must be the appropriate portion of `cb` once enough elements have been\n  -- dropped and taken.\n  have rearr : list.take (n + (k + 1) - (n + 1)) (list.drop (n + 1) (buffer.to_list cb)) = ctl.take k := by\n    simp [← List.tail_drop, hx, nat.sub_succ, hk]\n  -- We have to prove that the number of digits produced (given by `ltl`) is equal to the number\n  -- of characters parsed in, as given by `ctl.take k`, and that this is precisely `k`. We phrase it\n  -- in the statement using `min`, because lemmas about `list.length (list.take ...)` simplify to\n  -- a statement that uses `min`. The `list.length` term appears from the reduction of the folding\n  -- function, as proven above.\n  have ltll : min k ctl.length = ltl.length :=\n    by\n    -- Here is an example of how statements about the `list.length` of `list.take` simplify.\n    have : (ctl.take k).length = min k ctl.length := by simp\n    -- We bring back the underlying definition of `ctl` as the result of a sequence of `list.take`\n    -- and `list.drop`, so that lemmas about `list.length` of those can fire.\n    rw [← this, ← rearr, many1_length_of_done hdm]\n    -- Likewise, we rid ourselves of the `k` we generated earlier.\n    have : k = n' - n - 1 := by simp [hk, add_assoc]\n    subst this\n    simp only [nat.sub_succ, add_comm, ← Nat.pred_sub, buffer.length_to_list, Nat.pred_one_add, min_eq_left_iff,\n      list.length_drop, add_tsub_cancel_left, list.length_take, tsub_zero]\n    -- We now have a goal of proving an inequality dealing with `nat` subtraction and `nat.pred`,\n    -- both of which require special care to provide positivity hypotheses.\n    rw [tsub_le_tsub_iff_right, Nat.pred_le_iff]\n    · -- We know that `n' ≤ cb.size` because of the `bounded` property, that a parser will not\n      -- produce a `done` result at a position farther than the size of the underlying\n      -- `char_buffer`.\n      convert many1_bounded_of_done hp\n      -- What is now left to prove is that `0 < cb.size`, which can be rephrased\n      -- as proving that it is nonempty.\n      cases hc : cb.size\n      · -- Proof by contradiction. Let's say that `cb.size = 0`. But we know that we succeeded\n        -- parsing in at position `n` using a `bounded` parser, so we must have that\n        -- `n < cb.size`.\n        have := bounded.of_done hp\n        rw [hc] at this\n        -- But then `n < 0`, a contradiction.\n        exact absurd n.zero_le this.not_le\n      · simp\n    ·-- Here, we use the same result as above, that `n < cb.size`, and relate it to\n      -- `n ≤ cb.size.pred`.\n      exact Nat.le_pred_of_lt (bounded.of_done hp)\n  -- Finally, we simplify. On the LHS, we have a fold over `lhd :: ltl`, which simplifies to\n  -- the operation of the summing folding function on `lhd` and the fold over `ltl`. To that we can\n  -- apply the induction hypothesis, because we know that our parser would have succeeded had we\n  -- started at position `n + 1`. We replace mentions of `cb : char_buffer` with the appropriate\n  -- `chd :: ctl`, replace `lhd` with the appropriate statement of how it is calculated from `chd`,\n  -- and use the lemmas describing the length of `ltl` and how it is associated with `k`. We also\n  -- remove mentions of `n'` and replace with an expression using solely `n + k + 1`.\n  -- We use the lemma we proved above about how the folding function produces the\n  -- `prod.snd` value, which is `10` to the power of the length of the list provided to the fold.\n  -- Finally, we rely on `nat.of_digits_append` for the related statement of how digits given\n  -- are used in the `nat.of_digits` calculation, which also involves `10 ^ list.length ...`.\n  -- The `list.append` operation appears due to the `list.reverse (chd :: ctl)`.\n  -- We include some addition and multiplication lemmas to help the simplifier rearrange terms.\n  simp [IH _ hdm, hx, hk, rearr, ← chdh, ← ltll, hpow, add_assoc, Nat.ofDigits_append, mul_comm]\n#align nat_of_done nat_of_done\n\n",
 "nat_eq_done":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:564:6: unsupported: specialize @hyp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/-- The `val : ℕ` produced by a successful parse of a `cb : char_buffer` is the numerical value\nrepresented by the string of decimal digits (possibly padded with 0s on the left)\nstarting from the parsing position `n` and ending at position `n'`, where `n < n'`. The number\nof characters parsed in is necessarily `n' - n`. Additionally, all of the characters in the `cb`\nstarting at position `n` (inclusive) up to position `n'` (exclusive) are \"numeric\", in that they\nare between `'0'` and `'9'` inclusive. Such a `char_buffer` would produce the `ℕ` value encoded\nby its decimal characters.\n-/\ntheorem nat_eq_done {val : ℕ} :\n    nat cb n = done n' val ↔\n      ∃ hn : n < n',\n        val = Nat.ofDigits 10 (((cb.to_list.drop n).take (n' - n)).reverse.map fun c => c.to_nat - '0'.to_nat) ∧\n          (∀ hn' : n' < cb.size, '0' ≤ cb.read ⟨n', hn'⟩ → '9' < cb.read ⟨n', hn'⟩) ∧\n            ∃ hn'' : n' ≤ cb.size,\n              ∀ (k) (hk : k < n'), n ≤ k → '0' ≤ cb.read ⟨k, hk.trans_le hn''⟩ ∧ cb.read ⟨k, hk.trans_le hn''⟩ ≤ '9' :=\n  by\n  -- To prove this iff, we have most of the way in the forward direction, using the lemmas proven\n  -- above. First, we must use that `parser.nat` is `prog`, which means that on success, it must\n  -- move forward. We also have to prove the statement that a success means the parsed in\n  -- characters were properly \"numeric\". It involves first generating ane existential witness\n  -- that the parse was completely \"in-bounds\".\n  -- For the reverse direction, we first discharge the goals that deal with proving that our parser\n  -- succeeded because it encountered characters with the proper \"numeric\" properties, was\n  -- \"in-bounds\" and hit a nonnumeric character. The more difficult portion is proving that the\n  -- list of characters from positions `n` to `n'`, when folded over by the function defined inside\n  -- `parser.nat` gives exactly the same value as `nat.of_digits` when supplied with the same\n  -- (modulo rearrangement) list. To reach this goal, we try to remove any reliance on the\n  -- underlying `cb : char_buffer` or parsers as soon as possible, via a cased-induction.\n  refine' ⟨fun h => ⟨prog.of_done h, nat_of_done h, nat_of_done_bounded h, _⟩, _⟩\n  · -- To provide the existential witness that `n'` is within the bounds of the `cb : char_buffer`,\n    -- we rely on the fact that `parser.nat` is primarily a `parser.digit.many1`, and that `many1`,\n    -- must finish with the bounds of the `cb`, as long as the underlying parser is `step` and\n    -- `bounded`, which `digit` is. We do not prove this as a separate lemma about `parser.nat`\n    -- because it would almost always be only relevant in this larger theorem.\n    -- We clone the success hypothesis `h` so that we can supply it back later.\n    have H := h\n    -- We unwrap the `parser.nat` success down to the `many1` success, throwing away other info.\n    rw [Nat] at h\n    simp only [decorate_error_eq_done, bind_eq_done, pure_eq_done, and_left_comm, exists_eq_left, exists_and_left] at h\n    obtain ⟨_, h, -⟩ := h\n    -- Now we get our existential witness that `n' ≤ cb.size`.\n    replace h := many1_bounded_of_done h\n    -- With that, we can use the lemma proved above that our characters are \"numeric\"\n    exact ⟨h, nat_of_done_as_digit H h⟩\n  -- We now prove that given the `cb : char_buffer` with characters within the `n ≤ k < n'` interval\n  -- properly \"numeric\" and such that their `nat.of_digits` generates the `val : ℕ`, `parser.nat`\n  -- of that `cb`, when starting at `n`, will finish at `n'` and produce the same `val`.\n  -- We first introduce the relevant hypotheses, including the fact that we have a valid interval\n  -- where `n < n'` and that characters at `n'` and beyond are no longer numeric.\n  rintro ⟨hn, hv, hb, hn', ho⟩\n  -- We first unwrap the `parser.nat` definition to the underlying `parser.digit.many1` success\n  -- and the fold function of the digits.\n  rw [Nat]\n  simp only [and_left_comm, pure_eq_done, hv, decorate_error_eq_done, List.map_reverse, bind_eq_done, exists_eq_left,\n    exists_and_left]\n  -- We won't actually need the `val : ℕ` itself, since it is entirely characterized by the\n  -- underlying characters. Instead, we will induct over the `list char` of characters from\n  -- position `n` onwards, showing that if we could have provided a list at `n`, we could have\n  -- provided a valid list of characters at `n + 1` too.\n  clear hv val\n  /- We first prove some helper lemmas about the definition of `parser.nat`. Since it is defined\n    in core, we have to work with how it is defined instead of changing its definition.\n    In its definition, the function that folds over the parsed in digits is defined internally,\n    as a lambda with anonymous destructor syntax, which leads to an unpleasant `nat._match_1` term\n    when rewriting the definition of `parser.nat` away. Since we know exactly what the function is,\n    we have a `rfl`-like lemma here to rewrite it back into a readable form.\n    -/\n  have natm : nat._match_1 = fun (d : ℕ) p => ⟨p.1 + d * p.2, p.2 * 10⟩ :=\n    by\n    ext1\n    ext1 ⟨⟩\n    rfl\n  -- We induct over the characters available at position `n` and onwards. Because `cb` is used\n  -- in other expressions, we utilize the `induction H : ...` tactic to induct separately from\n  -- destructing `cb` itself.\n  induction' H : cb.to_list.drop n with hd tl IH generalizing n\n  · -- Base case: there are no characters at position `n` or onwards, which means that\n    -- `cb.size ≤ n`. But this is a contradiction, since we have `n < n' ≤ cb.size`.\n    rw [List.drop_eq_nil_iff_le] at H\n    refine' absurd ((lt_of_le_of_lt H hn).trans_le hn') _\n    simp\n  · -- Inductive case: we prove that if we could have parsed from `n + 1`, we could have also parsed\n    -- from `n`, if there was a valid numerical character at `n`. Most of the body\n    -- of this inductive case is generating the appropriate conditions for use of the inductive\n    -- hypothesis.\n    specialize IH (n + 1)\n    -- We have, by the inductive case, that there is at least one character `hd` at position `n`,\n    -- with the rest at `tl`. We rearrange our inductive case to make `tl` be expressed as\n    -- list.drop (n + 1), which fits out induction hypothesis conditions better. To use the\n    -- rearranging lemma, we must prove that we are \"dropping\" in bounds, which we supply on-the-fly\n    simp only [← List.cons_nthLe_drop_succ (show n < cb.to_list.length by simpa using hn.trans_le hn')] at H\n    -- We prove that parsing our `n`th character, `hd`, would have resulted in a success from\n    -- `parser.digit`, with the appropriate `ℕ` success value. We use this later to simplify the\n    -- unwrapped fold, since `hd` is our head character.\n    have hdigit : digit cb n = done (n + 1) (hd.to_nat - '0'.to_nat) :=\n      by\n      -- By our necessary condition, we know that `n` is in bounds, and that the `n`th character\n      -- has the necessary \"numeric\" properties.\n      specialize ho n hn le_rfl\n      -- We prove an additional result that the conversion of `hd : char` to a `ℕ` would give a\n      -- value `x ≤ 9`, since that is part of the iff statement in the `digit_eq_done` lemma.\n      have : (buffer.read cb ⟨n, hn.trans_le hn'⟩).to_nat - '0'.to_nat ≤ 9 :=\n        by\n        -- We rewrite the statement to be a statement about characters instead, and split the\n        -- inequality into the case that our hypotheses prove, and that `'0' ≤ '9'`, which\n        -- is true by computation, handled by `dec_trivial`.\n        rw [show 9 = '9'.to_nat - '0'.to_nat by decide, tsub_le_tsub_iff_right]\n        · exact ho.right\n        · decide\n      -- We rely on the simplifier, mostly powered by `digit_eq_done`, and supply all the\n      -- necessary conditions of bounds and identities about `hd`.\n      simp [digit_eq_done, this, ← H.left, buffer.nth_le_to_list, hn.trans_le hn', ho]\n    -- We now case on whether we've moved to the end of our parse or not. We phrase this as\n    -- casing on either `n + 1 < n` or `n ≤ n + 1`. The more difficult goal comes first.\n    cases' lt_or_ge (n + 1) n' with hn'' hn''\n    · -- Case `n + 1 < n'`. We can directly supply this to our induction hypothesis.\n      -- We now have to prove, for the induction hypothesis, that the characters at positions `k`,\n      -- `n + 1 ≤ k < n'` are \"numeric\". We already had this for `n ≤ k < n`, so we just rearrange\n      -- the hypotheses we already have.\n      specialize IH hn'' _ H.right\n      · intro k hk hk'\n        apply ho\n        exact nat.le_of_succ_le hk'\n      -- With the induction hypothesis conditions satisfier, we can extract out a list that\n      -- `parser.digit.many1` would have generated from position `n + 1`, as well as the associated\n      -- property of the list, that it folds into what `nat.of_digits` generates from the\n      -- characters in `cb : char_buffer`, now known as `hd :: tl`.\n      obtain ⟨l, hdl, hvl⟩ := IH\n      -- Of course, the parsed in list from position `n` would be `l` prepended with the result\n      -- of parsing in `hd`, which is provided explicitly.\n      use sym.cons' (hd.to_nat - '0'.to_nat) l\n      -- We case on `l : list ℕ` so that we can make statements about the fold on `l`\n      cases' l with lhd ltl\n      ·-- As before, if `l = []` then `many1` produced a `[]` success, which is a contradiction.\n        simpa using hdl\n      -- Case `l = lhd :: ltl`. We can rewrite the fold of the function inside `parser.nat` on\n      -- `lhd :: ltl`, which will be used to rewrite in the goal.\n      simp only [natm, list.foldr] at hvl\n      -- We also expand the fold in the goal, using the expanded fold from our hypothesis, powered\n      -- by `many1_eq_done` to proceed in the parsing. We know exactly what the next `many` will\n      -- produce from `many1_eq_done_iff_many_eq_done.mp` of our `hdl` hypothesis. Finally,\n      -- we also use `hdigit` to express what the single `parser.digit` result would be at `n`.\n      simp only [natm, hvl, many1_eq_done, hdigit, many1_eq_done_iff_many_eq_done.mp hdl, true_and_iff, and_true_iff,\n        eq_self_iff_true, list.foldr, exists_eq_left']\n      -- Now our goal is solely about the equality of two different folding functions, one from the\n      -- function defined inside `parser.nat` and the other as `nat.of_digits`, when applied to\n      -- similar list inputs.\n      -- First, we rid ourselves of `n'` by replacing with `n + m + 1`, which allows us to\n      -- simplify the term of how many elements we are keeping using a `list.take`.\n      obtain ⟨m, rfl⟩ : ∃ m, n' = n + m + 1 := Nat.exists_eq_add_of_lt hn\n      -- The following rearrangement lemma is to simplify the `list.take (n' - n)` expression we had\n      have : n + m + 1 - n = m + 1 :=\n        by\n        rw [add_assoc, tsub_eq_iff_eq_add_of_le, add_comm]\n        exact nat.le_add_right _ _\n      -- We also have to prove what is the `prod.snd` of the result of the fold of a `list (ℕ × ℕ)`\n      -- with the function above. We use this lemma to finish our inductive case.\n      have hpow :\n        ∀ l,\n          (list.foldr (fun (digit : ℕ) (x : ℕ × ℕ) => (x.fst + digit * x.snd, x.snd * 10)) (0, 1) l).snd =\n            10 ^ l.length :=\n        by\n        intro l\n        induction' l with hd tl hl\n        · simp\n        · simp [hl, pow_succ, mul_comm]\n      -- We prove that the parsed list of digits `(lhd :: ltl) : list ℕ` must be of length `m`\n      -- which is used later when the `parser.nat` fold places `ltl.length` in the exponent.\n      have hml : ltl.length + 1 = m := by simpa using many1_length_of_done hdl\n      -- A simplified `list.length (list.take ...)` expression refers to the minimum of the\n      -- underlying length and the amount of elements taken. We know that `m ≤ tl.length`, so\n      -- we provide this auxiliary lemma so that the simplified \"take-length\" can simplify further\n      have ltll : min m tl.length = m :=\n        by-- On the way to proving this, we have to actually show that `m ≤ tl.length`, by showing\n        -- that since `tl` was a subsequence in `cb`, and was retrieved from `n + 1` to `n + m + 1`,\n        -- then since `n + m + 1 ≤ cb.size`, we have that `tl` must be at least `m` in length.\n        simpa [← H.right, le_tsub_iff_right (hn''.trans_le hn').le, add_comm, add_assoc, add_left_comm] using hn'\n      -- Finally, we rely on the simplifier. We already expressions of `nat.of_digits` on both\n      -- the LHS and RHS. All that is left to do is to prove that the summand on the LHS is produced\n      -- by the fold of `nat.of_digits` on the RHS of `hd :: tl`. The `nat.of_digits_append` is used\n      -- because of the append that forms from the included `list.reverse`. The lengths of the lists\n      -- are placed in the exponents with `10` as a base, and are combined using `←pow_succ 10`.\n      -- Any complicated expression about list lengths is further simplified by the auxiliary\n      -- lemmas we just proved. Finally, we assist the simplifier by rearranging terms with our\n      -- `n + m + 1 - n = m + 1` proof and `mul_comm`.\n      simp [this, hpow, Nat.ofDigits_append, mul_comm, ← pow_succ 10, hml, ltll]\n    · -- Consider the case that `n' ≤ n + 1`. But then since `n < n' ≤ n + 1`, `n' = n + 1`.\n      obtain rfl : n' = n + 1 := le_antisymm hn'' (nat.succ_le_of_lt hn)\n      -- This means we have only parsed in a single character, so the resulting parsed in list\n      -- is explicitly formed from an expression we can construct from `hd`.\n      use [hd.to_nat - '0'.to_nat]\n      -- Our list expression simplifies nicely because it is a fold over a singleton, so we\n      -- do not have to supply any auxiliary lemmas for it, other than what we already know about\n      -- `hd` and the function defined in `parser.nat`. However, we will have to prove that our\n      -- parse ended because of a good reason: either we are out of bounds or we hit a nonnumeric\n      -- character.\n      simp only [many1_eq_done, many_eq_done_nil, digit_eq_fail, natm, and_comm, and_left_comm, hdigit, true_and_iff,\n        mul_one, Nat.ofDigits_singleton, list.take, exists_eq_left, exists_and_right, add_tsub_cancel_left,\n        eq_self_iff_true, List.reverse_singleton, zero_add, list.foldr, list.map]\n      -- We take the route of proving that we hit a nonnumeric character, since we already have\n      -- a hypothesis that says that characters at `n'` and past it are nonnumeric. (Note, by now\n      -- we have substituted `n + 1` for `n'.\n      -- We are also asked to provide the error value that our failed parse would report. But\n      -- `digit_eq_fail` already knows what it is, so we can discharge that with an inline `rfl`.\n      refine' ⟨_, or.inl ⟨rfl, _⟩⟩\n      -- The nonnumeric condition looks almost exactly like the hypothesis we already have, so\n      -- we let the simplifier align them for us\n      simpa using hb\n#align nat_eq_done nat_eq_done\n\n",
 "mmap_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem mmap_eq_done {f : α → parser β} {a : α} {l : List α} {b : β} {l' : List β} :\n    (sym.cons' a l).mmap f cb n = done n' (sym.cons' b l') ↔\n      ∃ np : ℕ, f a cb n = done np b ∧ l.mmap f cb np = done n' l' :=\n  by simp [mmap, and_comm, and_assoc, and_left_comm, pure_eq_done]\n#align mmap_eq_done mmap_eq_done\n\n",
 "mmap'_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem mmap'_eq_done {f : α → parser β} {a : α} {l : List α} :\n    (sym.cons' a l).mmap' f cb n = done n' () ↔\n      ∃ (np : ℕ)(b : β), f a cb n = done np b ∧ l.mmap' f cb np = done n' () :=\n  by simp [mmap']\n#align mmap'_eq_done mmap'_eq_done\n\n",
 "map_rev_const_eq_fail":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr $> » -/\ntheorem map_rev_const_eq_fail : («expr $> » p b) cb n = fail n' err ↔ p cb n = fail n' err :=\n  map_const_eq_fail\n#align map_rev_const_eq_fail map_rev_const_eq_fail\n\n",
 "map_eq_fail":
 "@[simp]\ntheorem map_eq_fail : (f <$> p) cb n = fail n' err ↔ p cb n = fail n' err := by\n  simp [← bind_pure_comp_eq_map, pure_eq_done]\n#align map_eq_fail map_eq_fail\n\n",
 "map_eq_done":
 "@[simp]\ntheorem map_eq_done : (f <$> p) cb n = done n' b ↔ ∃ a : α, p cb n = done n' a ∧ f a = b := by\n  cases hp : p cb n <;> simp [← is_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc', pure_eq_done]\n#align map_eq_done map_eq_done\n\n",
 "map_const_rev_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr $> » -/\ntheorem map_const_rev_eq_done {b'} : («expr $> » p b) cb n = done n' b' ↔ ∃ a : α, p cb n = done n' a ∧ b = b' :=\n  map_const_eq_done\n#align map_const_rev_eq_done map_const_rev_eq_done\n\n",
 "map_const_eq_fail":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <$ » -/\n@[simp]\ntheorem map_const_eq_fail : («expr <$ » b p) cb n = fail n' err ↔ p cb n = fail n' err := by\n  simp only [map_const_eq, map_eq_fail]\n#align map_const_eq_fail map_const_eq_fail\n\n",
 "map_const_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <$ » -/\n@[simp]\ntheorem map_const_eq_done {b'} : («expr <$ » b p) cb n = done n' b' ↔ ∃ a : α, p cb n = done n' a ∧ b = b' := by\n  simp [map_const_eq]\n#align map_const_eq_done map_const_eq_done\n\n",
 "many_sublist_of_done":
 "-- TODO: generalize to p.prog instead of p.step\ntheorem many_sublist_of_done [p.step] [p.bounded] {l : List α} (h : p.many cb n = done n' l) :\n    ∀ k < n' - n, p.many cb (n + k) = done n' (l.drop k) :=\n  by\n  induction' l with hd tl hl generalizing n\n  · rw [many_eq_done_nil] at h\n    simp [h.left]\n  intro m hm\n  cases m\n  · exact h\n  rw [list.drop, nat.add_succ, ← nat.succ_add]\n  apply hl\n  · rw [← many1_eq_done_iff_many_eq_done, many1_eq_done] at h\n    obtain ⟨_, hp, h⟩ := h\n    convert h\n    exact (step.of_done hp).symm\n  · exact nat.lt_pred_iff.mpr hm\n#align many_sublist_of_done many_sublist_of_done\n\n",
 "many_eq_nil_of_out_of_bound":
 "theorem many_eq_nil_of_out_of_bound [p.bounded] {l : List α} (h : p.many cb n = done n' l) (hn : cb.size < n) :\n    n' = n ∧ l = [] := by\n  cases l\n  · rw [many_eq_done_nil] at h\n    exact ⟨h.left.symm, rfl⟩\n  · rw [many_eq_done] at h\n    obtain ⟨np, hp, -⟩ := h\n    exact absurd (bounded.of_done hp) hn.not_lt\n#align many_eq_nil_of_out_of_bound many_eq_nil_of_out_of_bound\n\n",
 "many_eq_nil_of_done":
 "theorem many_eq_nil_of_done [p.step] [p.bounded] {l : List α} (h : p.many cb n = done n' l) :\n    p.many cb n' = done n' [] := by\n  induction' l with hd tl hl generalizing n\n  · convert h\n    rw [many_eq_done_nil] at h\n    exact h.left.symm\n  · rw [← many1_eq_done_iff_many_eq_done, many1_eq_done] at h\n    obtain ⟨_, -, h⟩ := h\n    exact hl h\n#align many_eq_nil_of_done many_eq_nil_of_done\n\n",
 "many_eq_fail":
 "theorem many_eq_fail {p : parser α} {err : dlist string} :\n    many p cb n = fail n' err ↔\n      n ≠ n' ∧\n        (p cb n = fail n' err ∨\n          ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldr_core List.cons p [] (cb.size - n) cb np = fail n' err) :=\n  by simp [many, foldr_eq_fail]\n#align many_eq_fail many_eq_fail\n\n",
 "many_eq_done_nil":
 "theorem many_eq_done_nil {p : parser α} :\n    many p cb n = done n' (@List.nil α) ↔\n      n = n' ∧\n        ∃ err,\n          p cb n = fail n err ∨\n            ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldr_core List.cons p [] (cb.size - n) cb np = fail n err :=\n  by simp [many, foldr_eq_done]\n#align many_eq_done_nil many_eq_done_nil\n\n",
 "many_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem many_eq_done {p : parser α} {x : α} {xs : List α} :\n    many p cb n = done n' (sym.cons' x xs) ↔\n      ∃ np : ℕ, p cb n = done np x ∧ foldr_core List.cons p [] (cb.size - n) cb np = done n' xs :=\n  by simp [many, foldr_eq_done, and_comm, and_assoc, and_left_comm]\n#align many_eq_done many_eq_done\n\n",
 "many_char_eq_many_of_to_list":
 "theorem many_char_eq_many_of_to_list {p : parser char} {s : string} :\n    many_char p cb n = done n' s ↔ many p cb n = done n' s.to_list := by simp [many_char, List.asString_eq]\n#align many_char_eq_many_of_to_list many_char_eq_many_of_to_list\n\n",
 "many_char_eq_done_not_empty":
 "theorem many_char_eq_done_not_empty {p : parser char} {s : string} (h : s ≠ \"\") :\n    many_char p cb n = done n' s ↔\n      ∃ np : ℕ,\n        p cb n = done np s.head ∧\n          foldr_core List.cons p List.nil (buffer.size cb - n) cb np = done n' (s.popn 1).to_list :=\n  by simp [many_char, List.asString_eq, String.toList_nonempty h, many_eq_done]\n#align many_char_eq_done_not_empty many_char_eq_done_not_empty\n\n",
 "many_char_eq_done_empty":
 "theorem many_char_eq_done_empty {p : parser char} :\n    many_char p cb n = done n' string.empty ↔\n      n = n' ∧\n        ∃ err,\n          p cb n = fail n err ∨\n            ∃ (np : ℕ)(c : char), p cb n = done np c ∧ foldr_core List.cons p [] (cb.size - n) cb np = fail n err :=\n  by simp [many_char, many_eq_done_nil, map_eq_done, List.asString_eq]\n#align many_char_eq_done_empty many_char_eq_done_empty\n\n",
 "many_char1_ne_empty":
 "@[simp]\ntheorem many_char1_ne_empty {p : parser char} : many_char1 p cb n ≠ done n' \"\" := by\n  simp [many_char1, ← String.nil_asString_eq_empty]\n#align many_char1_ne_empty many_char1_ne_empty\n\n",
 "many_char1_eq_done":
 "theorem many_char1_eq_done {p : parser char} {s : string} (h : s ≠ \"\") :\n    many_char1 p cb n = done n' s ↔ ∃ np : ℕ, p cb n = done np s.head ∧ many_char p cb np = done n' (s.popn 1) := by\n  simp [many_char1, List.asString_eq, String.toList_nonempty h, many1_eq_done, many_char_eq_many_of_to_list]\n#align many_char1_eq_done many_char1_eq_done\n\n",
 "many_char":
 "theorem many_char {pc : parser char} [pc.bounded] (he : ∀ cb n n' err, pc cb n = fail n' err → n ≠ n') :\n    pc.many_char.bounded := by\n  convert bounded.map\n  exact many he\n#align many_char many_char\n\n",
 "many1_ne_done_nil":
 "@[simp]\ntheorem many1_ne_done_nil {p : parser α} : many1 p cb n ≠ done n' [] := by simp [many1, seq_eq_done]\n#align many1_ne_done_nil many1_ne_done_nil\n\n",
 "many1_length_of_done":
 "theorem many1_length_of_done [p.mono] [p.step] [p.bounded] {l : List α} (h : many1 p cb n = done n' l) :\n    l.length = n' - n := by\n  induction' l with hd tl hl generalizing n n'\n  · simpa using h\n  · obtain ⟨k, hk⟩ : ∃ k, n' = n + k + 1 := Nat.exists_eq_add_of_lt (prog.of_done h)\n    subst hk\n    simp only [many1_eq_done] at h\n    obtain ⟨_, hp, h⟩ := h\n    obtain rfl := step.of_done hp\n    cases tl\n    · simp only [many_eq_done_nil, add_left_inj, exists_and_right, self_eq_add_right] at h\n      rcases h with ⟨rfl, -⟩\n      simp\n    rw [← many1_eq_done_iff_many_eq_done] at h\n    specialize hl h\n    simp [hl, add_comm, add_assoc, nat.sub_succ]\n#align many1_length_of_done many1_length_of_done\n\n",
 "many1_eq_fail":
 "theorem many1_eq_fail {p : parser α} {err : dlist string} :\n    many1 p cb n = fail n' err ↔\n      p cb n = fail n' err ∨ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ many p cb np = fail n' err :=\n  by simp [many1, seq_eq_fail]\n#align many1_eq_fail many1_eq_fail\n\n",
 "many1_eq_done_iff_many_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem many1_eq_done_iff_many_eq_done [p.step] [p.bounded] {x : α} {xs : List α} :\n    many1 p cb n = done n' (sym.cons' x xs) ↔ many p cb n = done n' (sym.cons' x xs) :=\n  by\n  induction' hx : sym.cons' x xs with hd tl IH generalizing x xs n n'\n  · simpa using hx\n  constructor\n  · simp only [many1_eq_done, and_imp, exists_imp]\n    intro np hp hm\n    have : np = n + 1 := step.of_done hp\n    have hn : n < cb.size := bounded.of_done hp\n    subst this\n    obtain ⟨k, hk⟩ : ∃ k, cb.size - n = k + 1 := nat.exists_eq_succ_of_ne_zero (ne_of_gt (tsub_pos_of_lt hn))\n    cases k\n    · cases tl <;> simpa [many_eq_done_nil, nat.sub_succ, hk, many_eq_done, hp, foldr_core_eq_done] using hm\n    cases' tl with hd' tl'\n    · simpa [many_eq_done_nil, nat.sub_succ, hk, many_eq_done, hp, foldr_core_eq_done] using hm\n    · rw [← @IH hd' tl'] at hm\n      swap\n      rfl\n      simp only [many1_eq_done, many, foldr] at hm\n      obtain ⟨np, hp', hf⟩ := hm\n      obtain rfl : np = n + 1 + 1 := step.of_done hp'\n      simpa [nat.sub_succ, many_eq_done, hp, hk, foldr_core_eq_done, hp'] using hf\n  · simp only [many_eq_done, many1_eq_done, and_imp, exists_imp]\n    intro np hp hm\n    have : np = n + 1 := step.of_done hp\n    have hn : n < cb.size := bounded.of_done hp\n    subst this\n    obtain ⟨k, hk⟩ : ∃ k, cb.size - n = k + 1 := nat.exists_eq_succ_of_ne_zero (ne_of_gt (tsub_pos_of_lt hn))\n    cases k\n    · cases tl <;> simpa [many_eq_done_nil, nat.sub_succ, hk, many_eq_done, hp, foldr_core_eq_done] using hm\n    cases' tl with hd' tl'\n    · simpa [many_eq_done_nil, nat.sub_succ, hk, many_eq_done, hp, foldr_core_eq_done] using hm\n    · simp [hp]\n      rw [← @IH hd' tl' (n + 1) n']\n      swap\n      rfl\n      rw [hk, foldr_core_eq_done, or_comm] at hm\n      obtain hm | ⟨np, hd', tl', hp', hf, hm⟩ := hm\n      · simpa using hm\n      simp only at hm\n      obtain ⟨rfl, rfl⟩ := hm\n      obtain rfl : np = n + 1 + 1 := step.of_done hp'\n      simp [nat.sub_succ, many, many1_eq_done, hp, hk, foldr_core_eq_done, hp', ← hf, foldr]\n#align many1_eq_done_iff_many_eq_done many1_eq_done_iff_many_eq_done\n\n",
 "many1_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem many1_eq_done {p : parser α} {l : List α} :\n    many1 p cb n = done n' (sym.cons' a l) ↔ ∃ np : ℕ, p cb n = done np a ∧ many p cb np = done n' l := by\n  simp [many1, seq_eq_done, map_eq_done]\n#align many1_eq_done many1_eq_done\n\n",
 "many1_bounded_of_done":
 "theorem many1_bounded_of_done [p.step] [p.bounded] {l : List α} (h : many1 p cb n = done n' l) : n' ≤ cb.size :=\n  by\n  induction' l with hd tl hl generalizing n n'\n  · simpa using h\n  · simp only [many1_eq_done] at h\n    obtain ⟨np, hp, h⟩ := h\n    obtain rfl := step.of_done hp\n    cases tl\n    · simp only [many_eq_done_nil, exists_and_right] at h\n      simpa [← h.left] using bounded.of_done hp\n    · rw [← many1_eq_done_iff_many_eq_done] at h\n      exact hl h\n#align many1_bounded_of_done many1_bounded_of_done\n\n",
 "many'_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem many'_eq_done {p : parser α} :\n    many' p cb n = done n' u ↔\n      many p cb n = done n' [] ∨\n        ∃ (np : ℕ)(a : α)(l : List α),\n          many p cb n = done n' (sym.cons' a l) ∧\n            p cb n = done np a ∧ foldr_core List.cons p [] (buffer.size cb - n) cb np = done n' l :=\n  by\n  simp only [many', eps_eq_done, many, foldr, and_then_eq_bind, exists_and_right, bind_eq_done, exists_eq_right]\n  constructor\n  · rintro ⟨_ | ⟨hd, tl⟩, hl⟩\n    · exact or.inl hl\n    · have hl2 := hl\n      simp only [foldr_core_eq_done, or_false_iff, exists_and_left, and_false_iff, false_and_iff,\n        exists_eq_right_right] at hl\n      obtain ⟨np, hp, h⟩ := hl\n      refine' or.inr ⟨np, _, _, hl2, hp, h⟩\n  · rintro (h | ⟨np, a, l, hp, h⟩)\n    · exact ⟨[], h⟩\n    · refine' ⟨sym.cons' a l, hp⟩\n#align many'_eq_done many'_eq_done\n\n",
 "many'":
 "theorem many' : p.many'.bounded := by\n  convert bounded.and_then\n  exact many he\n#align many' many'\n\n",
 "many": "theorem many : p.many.bounded :=\n  foldr he\n#align many many\n\n",
 "le":
 "/-\nCopyright (c) 2020 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\ntheorem mono.le [p.mono] : n ≤ (p cb n).pos :=\n  mono.le' cb n\n#align mono.le mono.le\n\n",
 "iff":
 "theorem static.iff : static p ↔ ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n = n' :=\n  ⟨fun h _ _ _ _ hp =>\n    haveI := h\n    static.of_done hp,\n    fun h => ⟨h⟩⟩\n#align static.iff static.iff\n\n",
 "guard_true":
 "#print guard_true /-\ntheorem guard_true : ¬prog (guard True) :=\n  pure _\n#align guard_true guard_true\n-/\n\n",
 "guard_iff":
 "theorem guard_iff {p : Prop} [Decidable p] : bounded (guard p) ↔ ¬p := by\n  simpa [guard, apply_ite bounded, pure, failure] using fun _ => bounded.failure\n#align guard_iff guard_iff\n\n",
 "guard_eq_fail":
 "theorem guard_eq_fail {p : Prop} [Decidable p] :\n    @guard parser _ p _ cb n = fail n' err ↔ ¬p ∧ n = n' ∧ err = dlist.empty := by\n  by_cases hp : p <;> simp [guard, hp, eq_comm, pure_eq_done]\n#align guard_eq_fail guard_eq_fail\n\n",
 "guard_eq_done":
 "theorem guard_eq_done {p : Prop} [Decidable p] {u : Unit} : @guard parser _ p _ cb n = done n' u ↔ p ∧ n = n' := by\n  by_cases hp : p <;> simp [guard, hp, pure_eq_done]\n#align guard_eq_done guard_eq_done\n\n",
 "guard":
 "#print guard /-\ntheorem guard : ¬unfailing (guard False) :=\n  unfailing.failure\n#align guard guard\n-/\n\n",
 "foldr_eq_fail_iff_mono_at_end":
 "theorem foldr_eq_fail_iff_mono_at_end {f : α → β → β} {p : parser α} {err : dlist string} [p.mono] (hc : cb.size ≤ n) :\n    foldr f p b cb n = fail n' err ↔\n      n < n' ∧ (p cb n = fail n' err ∨ ∃ a : α, p cb n = done n' a ∧ err = dlist.empty) :=\n  by\n  have : cb.size - n = 0 := tsub_eq_zero_iff_le.mpr hc\n  simp only [foldr, foldr_core_succ_eq_fail, this, and_left_comm, foldr_core_zero_eq_fail, ne_iff_lt_iff_le,\n    exists_and_right, exists_eq_left, and_congr_left_iff, exists_and_left]\n  rintro (h | ⟨⟨a, h⟩, rfl⟩)\n  · exact mono.of_fail h\n  · exact mono.of_done h\n#align foldr_eq_fail_iff_mono_at_end foldr_eq_fail_iff_mono_at_end\n\n",
 "foldr_eq_fail":
 "theorem foldr_eq_fail {f : α → β → β} {p : parser α} {err : dlist string} :\n    foldr f p b cb n = fail n' err ↔\n      n ≠ n' ∧\n        (p cb n = fail n' err ∨\n          ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldr_core f p b (cb.size - n) cb np = fail n' err) :=\n  by simp [foldr, foldr_core_succ_eq_fail]\n#align foldr_eq_fail foldr_eq_fail\n\n",
 "foldr_eq_done":
 "theorem foldr_eq_done {f : α → β → β} {p : parser α} {b' : β} :\n    foldr f p b cb n = done n' b' ↔\n      (∃ (np : ℕ)(a : α)(x : β), p cb n = done np a ∧ foldr_core f p b (cb.size - n) cb np = done n' x ∧ f a x = b') ∨\n        n = n' ∧\n          b = b' ∧\n            ∃ err,\n              p cb n = parse_result.fail n err ∨\n                ∃ (np : ℕ)(x : α), p cb n = done np x ∧ foldr_core f p b (cb.size - n) cb np = fail n err :=\n  by simp [foldr, foldr_core_eq_done]\n#align foldr_eq_done foldr_eq_done\n\n",
 "foldr_core_zero_eq_fail":
 "@[simp]\ntheorem foldr_core_zero_eq_fail {f : α → β → β} {p : parser α} {err : dlist string} :\n    foldr_core f p b 0 cb n = fail n' err ↔ n = n' ∧ err = dlist.empty := by simp [foldr_core, eq_comm]\n#align foldr_core_zero_eq_fail foldr_core_zero_eq_fail\n\n",
 "foldr_core_zero_eq_done":
 "@[simp]\ntheorem foldr_core_zero_eq_done {f : α → β → β} {p : parser α} {b' : β} : foldr_core f p b 0 cb n ≠ done n' b' := by\n  simp [foldr_core]\n#align foldr_core_zero_eq_done foldr_core_zero_eq_done\n\n",
 "foldr_core_zero":
 "theorem foldr_core_zero {f : α → β → β} {b : β} : ¬(foldr_core f p b 0).unfailing :=\n  unfailing.failure\n#align foldr_core_zero foldr_core_zero\n\n",
 "foldr_core_succ_eq_fail":
 "theorem foldr_core_succ_eq_fail {f : α → β → β} {p : parser α} {reps : ℕ} {err : dlist string} :\n    foldr_core f p b (reps + 1) cb n = fail n' err ↔\n      n ≠ n' ∧\n        (p cb n = fail n' err ∨ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldr_core f p b reps cb np = fail n' err) :=\n  by simp [foldr_core, and_comm']\n#align foldr_core_succ_eq_fail foldr_core_succ_eq_fail\n\n",
 "foldr_core_eq_done":
 "theorem foldr_core_eq_done {f : α → β → β} {p : parser α} {reps : ℕ} {b' : β} :\n    foldr_core f p b (reps + 1) cb n = done n' b' ↔\n      (∃ (np : ℕ)(a : α)(xs : β), p cb n = done np a ∧ foldr_core f p b reps cb np = done n' xs ∧ f a xs = b') ∨\n        n = n' ∧\n          b = b' ∧\n            ∃ err,\n              p cb n = fail n err ∨ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldr_core f p b reps cb np = fail n err :=\n  by simp [foldr_core, and_comm, and_assoc, pure_eq_done]\n#align foldr_core_eq_done foldr_core_eq_done\n\n",
 "foldr_core":
 "theorem foldr_core {f : α → β → β} : (foldr_core f p b reps).bounded :=\n  by\n  cases reps\n  · exact bounded.foldr_core_zero\n  constructor\n  intro cb n hn\n  obtain ⟨np, errp, hp⟩ := bounded.exists p hn\n  simpa [foldr_core_succ_eq_fail, hp] using he cb n np errp\n#align foldr_core foldr_core\n\n",
 "foldr":
 "theorem foldr {f : α → β → β} : bounded (foldr f p b) :=\n  by\n  constructor\n  intro cb n hn\n  haveI : (parser.foldr_core f p b (cb.size - n + 1)).bounded := foldr_core he\n  obtain ⟨np, errp, hp⟩ := bounded.exists (parser.foldr_core f p b (cb.size - n + 1)) hn\n  simp [foldr, hp]\n#align foldr foldr\n\n",
 "foldl_eq_fail_iff_mono_at_end":
 "theorem foldl_eq_fail_iff_mono_at_end {f : β → α → β} {p : parser α} {err : dlist string} [p.mono] (hc : cb.size ≤ n) :\n    foldl f b p cb n = fail n' err ↔\n      n < n' ∧ (p cb n = fail n' err ∨ ∃ a : α, p cb n = done n' a ∧ err = dlist.empty) :=\n  by\n  have : cb.size - n = 0 := tsub_eq_zero_iff_le.mpr hc\n  simp only [foldl, foldl_core_succ_eq_fail, this, and_left_comm, ne_iff_lt_iff_le, exists_eq_left, exists_and_right,\n    and_congr_left_iff, exists_and_left, foldl_core_zero_eq_fail]\n  rintro (h | ⟨⟨a, h⟩, rfl⟩)\n  · exact mono.of_fail h\n  · exact mono.of_done h\n#align foldl_eq_fail_iff_mono_at_end foldl_eq_fail_iff_mono_at_end\n\n",
 "foldl_eq_fail":
 "theorem foldl_eq_fail {f : β → α → β} {p : parser α} {err : dlist string} :\n    foldl f b p cb n = fail n' err ↔\n      n ≠ n' ∧\n        (p cb n = fail n' err ∨\n          ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldl_core f (f b a) p (cb.size - n) cb np = fail n' err) :=\n  by simp [foldl, foldl_core_succ_eq_fail]\n#align foldl_eq_fail foldl_eq_fail\n\n",
 "foldl_eq_done":
 "theorem foldl_eq_done {f : β → α → β} {p : parser α} {b' : β} :\n    foldl f b p cb n = done n' b' ↔\n      (∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldl_core f (f b a) p (cb.size - n) cb np = done n' b') ∨\n        n = n' ∧\n          b = b' ∧\n            ∃ err,\n              p cb n = fail n err ∨\n                ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldl_core f (f b a) p (cb.size - n) cb np = fail n err :=\n  by simp [foldl, foldl_core_eq_done]\n#align foldl_eq_done foldl_eq_done\n\n",
 "foldl_core_zero_eq_fail":
 "@[simp]\ntheorem foldl_core_zero_eq_fail {f : β → α → β} {p : parser α} {err : dlist string} :\n    foldl_core f b p 0 cb n = fail n' err ↔ n = n' ∧ err = dlist.empty := by simp [foldl_core, eq_comm]\n#align foldl_core_zero_eq_fail foldl_core_zero_eq_fail\n\n",
 "foldl_core_zero_eq_done":
 "@[simp]\ntheorem foldl_core_zero_eq_done {f : β → α → β} {p : parser α} {b' : β} :\n    foldl_core f b p 0 cb n = done n' b' ↔ False := by simp [foldl_core]\n#align foldl_core_zero_eq_done foldl_core_zero_eq_done\n\n",
 "foldl_core_succ_eq_fail":
 "theorem foldl_core_succ_eq_fail {f : β → α → β} {p : parser α} {reps : ℕ} {err : dlist string} :\n    foldl_core f b p (reps + 1) cb n = fail n' err ↔\n      n ≠ n' ∧\n        (p cb n = fail n' err ∨\n          ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldl_core f (f b a) p reps cb np = fail n' err) :=\n  by simp [foldl_core, and_comm']\n#align foldl_core_succ_eq_fail foldl_core_succ_eq_fail\n\n",
 "foldl_core_eq_done":
 "theorem foldl_core_eq_done {f : β → α → β} {p : parser α} {reps : ℕ} {b' : β} :\n    foldl_core f b p (reps + 1) cb n = done n' b' ↔\n      (∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldl_core f (f b a) p reps cb np = done n' b') ∨\n        n = n' ∧\n          b = b' ∧\n            ∃ err,\n              p cb n = fail n err ∨\n                ∃ (np : ℕ)(a : α), p cb n = done np a ∧ foldl_core f (f b a) p reps cb np = fail n err :=\n  by simp [foldl_core, and_assoc, pure_eq_done]\n#align foldl_core_eq_done foldl_core_eq_done\n\n",
 "foldl_core":
 "theorem foldl_core {f : β → α → β} : (foldl_core f b p reps).bounded :=\n  by\n  cases reps\n  · exact bounded.foldl_core_zero\n  constructor\n  intro cb n hn\n  obtain ⟨np, errp, hp⟩ := bounded.exists p hn\n  simpa [foldl_core_succ_eq_fail, hp] using he cb n np errp\n#align foldl_core foldl_core\n\n",
 "foldl":
 "theorem foldl {f : β → α → β} : bounded (foldl f b p) :=\n  by\n  constructor\n  intro cb n hn\n  haveI : (parser.foldl_core f b p (cb.size - n + 1)).bounded := foldl_core he\n  obtain ⟨np, errp, hp⟩ := bounded.exists (parser.foldl_core f b p (cb.size - n + 1)) hn\n  simp [foldl, hp]\n#align foldl foldl\n\n",
 "fix_core_ne_done_zero":
 "@[simp]\ntheorem fix_core_ne_done_zero {F : parser α → parser α} : fix_core F 0 cb n ≠ done n' a := by simp [fix_core]\n#align fix_core_ne_done_zero fix_core_ne_done_zero\n\n",
 "fix_core_eq_done":
 "theorem fix_core_eq_done {F : parser α → parser α} {max_depth : ℕ} :\n    fix_core F (max_depth + 1) cb n = done n' a ↔ F (fix_core F max_depth) cb n = done n' a := by simp [fix_core]\n#align fix_core_eq_done fix_core_eq_done\n\n",
 "fix_core":
 "-- TODO: add foldr and foldl, many, etc, fix_core\ntheorem fix_core {F : parser α → parser α} (hF : ∀ p : parser α, p.prog → (F p).prog) :\n    ∀ max_depth : ℕ, prog (fix_core F max_depth)\n  | 0 => prog.failure\n  | max_depth + 1 => hF _ (fix_core _)\n#align fix_core fix_core\n\n",
 "fix":
 "theorem fix {F : parser α → parser α} (hF : ∀ p : parser α, p.prog → (F p).prog) : prog (fix F) :=\n  ⟨fun cb n _ _ h => by\n    haveI := fix_core hF (cb.size - n + 1)\n    dsimp [fix] at h\n    exact of_done h⟩\n#align fix fix\n\n",
 "failure_eq_failure":
 "@[simp]\ntheorem failure_eq_failure : @parser.failure α = failure :=\n  rfl\n#align failure_eq_failure failure_eq_failure\n\n",
 "failure_eq_fail":
 "theorem failure_eq_fail : (failure : parser α) cb n = fail n' err ↔ n = n' ∧ err = dlist.empty := by simp [eq_comm]\n#align failure_eq_fail failure_eq_fail\n\n",
 "failure_def":
 "@[simp]\ntheorem failure_def : (failure : parser α) cb n = fail n dlist.empty :=\n  rfl\n#align failure_def failure_def\n\n",
 "failure":
 "theorem failure : ¬@parser.unfailing α failure := by\n  intro h\n  have : (failure : parser α) buffer.nil 0 = fail 0 dlist.empty := by simp\n  exact of_fail this\n#align failure failure\n\n",
 "fail_iff":
 "theorem fail_iff :\n    (∀ pos' result, p cb n ≠ done pos' result) ↔ ∃ (pos' : ℕ)(err : dlist string), p cb n = fail pos' err := by\n  cases p cb n <;> simp\n#align fail_iff fail_iff\n\n",
 "exists_done_in_bounds":
 "-- see Note [lower instance priority]\ntheorem exists_done_in_bounds (p : parser α) [p.conditionally_unfailing] {cb : char_buffer} {n : ℕ} (h : n < cb.size) :\n    ∃ (n' : ℕ)(a : α), p cb n = done n' a :=\n  conditionally_unfailing.ex' h\n#align exists_done_in_bounds exists_done_in_bounds\n\n",
 "exists_done":
 "theorem exists_done (p : parser α) [p.unfailing] (cb : char_buffer) (n : ℕ) : ∃ (n' : ℕ)(a : α), p cb n = done n' a :=\n  unfailing.ex' cb n\n#align exists_done exists_done\n\n",
 "exists":
 "theorem bounded.exists (p : parser α) [p.bounded] {cb : char_buffer} {n : ℕ} (h : cb.size ≤ n) :\n    ∃ (n' : ℕ)(err : dlist string), p cb n = fail n' err :=\n  bounded.ex' h\n#align bounded.exists bounded.exists\n\n",
 "eps_eq_done":
 "theorem eps_eq_done : eps cb n = done n' u ↔ n = n' := by simp [eps, pure_eq_done]\n#align eps_eq_done eps_eq_done\n\n",
 "eps": "theorem eps : ¬prog eps :=\n  prog.pure ()\n#align eps eps\n\n",
 "eof_eq_done":
 "theorem eof_eq_done {u : Unit} : eof cb n = done n' u ↔ n = n' ∧ cb.size ≤ n := by\n  simp [eof, guard_eq_done, remaining_eq_done, tsub_eq_zero_iff_le, and_comm', and_assoc']\n#align eof_eq_done eof_eq_done\n\n",
 "eof":
 "theorem eof : ¬eof.prog := by\n  intro h\n  have : eof buffer.nil 0 = done 0 () := by simpa [remaining_eq_done]\n  replace this : 0 < 0 := prog.of_done this\n  exact (lt_irrefl _) this\n#align eof eof\n\n",
 "done_of_unbounded":
 "theorem done_of_unbounded (h : ¬p.bounded) : ∃ (cb : char_buffer)(n n' : ℕ)(a : α), p cb n = done n' a ∧ cb.size ≤ n :=\n  by\n  contrapose! h\n  constructor\n  intro cb n hn\n  cases hp : p cb n\n  · exact absurd hn (h _ _ _ _ hp).not_le\n  · simp [hp]\n#align done_of_unbounded done_of_unbounded\n\n",
 "digit_eq_fail":
 "theorem digit_eq_fail :\n    digit cb n = fail n' err ↔\n      n = n' ∧ err = dlist.of_list [\"<digit>\"] ∧ ∀ h : n < cb.size, ¬(fun c => '0' ≤ c ∧ c ≤ '9') (cb.read ⟨n, h⟩) :=\n  by simp [digit, sat_eq_fail]\n#align digit_eq_fail digit_eq_fail\n\n",
 "digit_eq_done":
 "theorem digit_eq_done {k : ℕ} :\n    digit cb n = done n' k ↔\n      ∃ hn : n < cb.size,\n        n' = n + 1 ∧\n          k ≤ 9 ∧ (cb.read ⟨n, hn⟩).to_nat - '0'.to_nat = k ∧ '0' ≤ cb.read ⟨n, hn⟩ ∧ cb.read ⟨n, hn⟩ ≤ '9' :=\n  by\n  have c9 : '9'.to_nat - '0'.to_nat = 9 := rfl\n  have l09 : '0'.to_nat ≤ '9'.to_nat := by decide\n  have le_iff_le : ∀ {c c' : char}, c ≤ c' ↔ c.to_nat ≤ c'.to_nat := fun _ _ => iff.rfl\n  constructor\n  · simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ← c9]\n    rintro ⟨np, c, ⟨hn, ⟨ge0, le9⟩, rfl, rfl⟩, rfl, rfl⟩\n    simpa [hn, ge0, le9, true_and_iff, and_true_iff, eq_self_iff_true, exists_prop_of_true, tsub_le_tsub_iff_right,\n      l09] using le_iff_le.mp le9\n  · simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ← c9, le_iff_le]\n    rintro ⟨hn, rfl, -, rfl, ge0, le9⟩\n    use n + 1, cb.read ⟨n, hn⟩\n    simp [hn, ge0, le9]\n#align digit_eq_done digit_eq_done\n\n",
 "digit":
 "-- TODO: add foldr and foldl, many, etc, fix_core\ntheorem digit : ¬digit.unfailing :=\n  of_bounded\n#align digit digit\n\n",
 "decorate_errors_success":
 "theorem decorate_errors_success (h : p cb n = done n' a) : @decorate_errors α msgs p cb n = done n' a := by\n  simp [decorate_errors, h]\n#align decorate_errors_success decorate_errors_success\n\n",
 "decorate_errors_iff":
 "theorem decorate_errors_iff : (@parser.decorate_errors α msgs p).prog ↔ p.prog :=\n  by\n  constructor\n  · intro\n    constructor\n    intro cb n n' a h\n    have : (@parser.decorate_errors α msgs p) cb n = done n' a := by simpa using h\n    exact of_done this\n  · intro\n    constructor\n    intro _ _ _ _ h\n    rw [decorate_errors_eq_done] at h\n    exact of_done h\n#align decorate_errors_iff decorate_errors_iff\n\n",
 "decorate_errors_fail":
 "theorem decorate_errors_fail (h : p cb n = fail n' err) :\n    @decorate_errors α msgs p cb n = fail n (Std.DList.lazy_ofList (msgs ())) := by simp [decorate_errors, h]\n#align decorate_errors_fail decorate_errors_fail\n\n",
 "decorate_errors_eq_fail":
 "@[simp]\ntheorem decorate_errors_eq_fail :\n    @decorate_errors α msgs p cb n = fail n' err ↔\n      n = n' ∧ err = Std.DList.lazy_ofList (msgs ()) ∧ ∃ np err', p cb n = fail np err' :=\n  by cases h : p cb n <;> simp [decorate_errors, h, eq_comm]\n#align decorate_errors_eq_fail decorate_errors_eq_fail\n\n",
 "decorate_errors_eq_done":
 "@[simp]\ntheorem decorate_errors_eq_done : @decorate_errors α msgs p cb n = done n' a ↔ p cb n = done n' a := by\n  cases h : p cb n <;> simp [decorate_errors, h]\n#align decorate_errors_eq_done decorate_errors_eq_done\n\n",
 "decorate_error_success":
 "theorem decorate_error_success (h : p cb n = done n' a) : @decorate_error α msg p cb n = done n' a :=\n  decorate_errors_success h\n#align decorate_error_success decorate_error_success\n\n",
 "decorate_error_iff":
 "theorem decorate_error_iff : (@parser.decorate_error α msg p).prog ↔ p.prog :=\n  decorate_errors_iff\n#align decorate_error_iff decorate_error_iff\n\n",
 "decorate_error_fail":
 "theorem decorate_error_fail (h : p cb n = fail n' err) :\n    @decorate_error α msg p cb n = fail n (Std.DList.lazy_ofList [msg ()]) :=\n  decorate_errors_fail h\n#align decorate_error_fail decorate_error_fail\n\n",
 "decorate_error_eq_fail":
 "@[simp]\ntheorem decorate_error_eq_fail :\n    @decorate_error α msg p cb n = fail n' err ↔\n      n = n' ∧ err = Std.DList.lazy_ofList [msg ()] ∧ ∃ np err', p cb n = fail np err' :=\n  decorate_errors_eq_fail\n#align decorate_error_eq_fail decorate_error_eq_fail\n\n",
 "decorate_error_eq_done":
 "@[simp]\ntheorem decorate_error_eq_done : @decorate_error α msg p cb n = done n' a ↔ p cb n = done n' a :=\n  decorate_errors_eq_done\n#align decorate_error_eq_done decorate_error_eq_done\n\n",
 "char_buf_iff":
 "theorem char_buf_iff {cb' : char_buffer} : (char_buf cb').prog ↔ cb' ≠ buffer.nil :=\n  by\n  have : cb' ≠ buffer.nil ↔ cb'.to_list ≠ [] :=\n    not_congr ⟨fun h => by simp [h], fun h => by simpa using congr_arg list.to_buffer h⟩\n  rw [char_buf, this, decorate_error_iff]\n  cases cb'.to_list\n  · simp [pure]\n  · simp only [iff_true_iff, ne.def, not_false_iff]\n    infer_instance\n#align char_buf_iff char_buf_iff\n\n",
 "char_buf_eq_done":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+: » -/\ntheorem char_buf_eq_done {cb' : char_buffer} :\n    char_buf cb' cb n = done n' u ↔ n + cb'.size = n' ∧ «expr <+: » cb'.to_list (cb.to_list.drop n) :=\n  by\n  simp only [char_buf, decorate_error_eq_done, ne.def, ← buffer.length_to_list]\n  induction' cb'.to_list with hd tl hl generalizing cb n n'\n  · simp [pure_eq_done, mmap'_eq_done, -buffer.length_to_list, List.nil_prefix]\n  · simp only [ch_eq_done, and_comm, and_assoc, and_left_comm, hl, mmap', and_then_eq_bind, bind_eq_done, list.length,\n      exists_and_left, exists_const]\n    constructor\n    · rintro ⟨np, h, rfl, rfl, hn, rfl⟩\n      simp only [add_comm, add_left_comm, h, true_and_iff, eq_self_iff_true, and_true_iff]\n      have : n < cb.to_list.length := by simpa using hn\n      rwa [← buffer.nth_le_to_list _ this, ← List.cons_nthLe_drop_succ this, List.prefix_cons_inj]\n    · rintro ⟨h, rfl⟩\n      by_cases hn : n < cb.size\n      · have : n < cb.to_list.length := by simpa using hn\n        rw [← List.cons_nthLe_drop_succ this, List.cons_prefix_iff] at h\n        use n + 1, h.right\n        simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm\n      · have : cb.to_list.length ≤ n := by simpa using hn\n        rw [List.drop_eq_nil_of_le this] at h\n        simpa using h\n#align char_buf_eq_done char_buf_eq_done\n\n",
 "ch_eq_done":
 "theorem ch_eq_done : ch c cb n = done n' u ↔ ∃ hn : n < cb.size, n' = n + 1 ∧ cb.read ⟨n, hn⟩ = c := by\n  simp [ch, eps_eq_done, sat_eq_done, and_comm, @eq_comm _ n']\n#align ch_eq_done ch_eq_done\n\n",
 "ch":
 "theorem ch (c : char) : ¬static (ch c) :=\n  haveI : ch c [c].to_buffer 0 = done 1 () :=\n    by\n    have : 0 < [c].to_buffer.size := by decide\n    simp [ch_eq_done, this]\n  not_of_ne this zero_ne_one\n#align ch ch\n\n",
 "bind_eq_fail":
 "@[simp]\ntheorem bind_eq_fail :\n    (p >>= f) cb n = fail n' err ↔\n      p cb n = fail n' err ∨ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ f a cb np = fail n' err :=\n  by cases hp : p cb n <;> simp [hp, ← bind_eq_bind, parser.bind, and_assoc']\n#align bind_eq_fail bind_eq_fail\n\n",
 "bind_eq_done":
 "@[simp]\ntheorem bind_eq_done : (p >>= f) cb n = done n' b ↔ ∃ (np : ℕ)(a : α), p cb n = done np a ∧ f a cb np = done n' b := by\n  cases hp : p cb n <;> simp [hp, ← bind_eq_bind, parser.bind, and_assoc']\n#align bind_eq_done bind_eq_done\n\n",
 "bind_eq_bind":
 "@[simp]\ntheorem bind_eq_bind : p.bind f = p >>= f :=\n  rfl\n#align bind_eq_bind bind_eq_bind\n\n",
 "any_char_eq_fail":
 "theorem any_char_eq_fail : any_char cb n = fail n' err ↔ n = n' ∧ err = dlist.empty ∧ cb.size ≤ n :=\n  by\n  simp_rw [any_char]\n  split_ifs with h <;> simp [← not_lt, h, eq_comm]\n#align any_char_eq_fail any_char_eq_fail\n\n",
 "any_char_eq_done":
 "theorem any_char_eq_done : any_char cb n = done n' c ↔ ∃ hn : n < cb.size, n' = n + 1 ∧ cb.read ⟨n, hn⟩ = c :=\n  by\n  simp_rw [any_char]\n  split_ifs with h <;> simp [h, eq_comm]\n#align any_char_eq_done any_char_eq_done\n\n",
 "any_char":
 "theorem any_char : ¬static any_char :=\n  haveI : any_char \"s\".to_char_buffer 0 = done 1 's' :=\n    by\n    have : 0 < \"s\".to_char_buffer.size := by decide\n    simpa [any_char_eq_done, this]\n  not_of_ne this zero_ne_one\n#align any_char any_char\n\n",
 "and_then_success":
 "theorem and_then_success : (p >> return ()) cb n = parse_result.done n' () ↔ ∃ a, p cb n = done n' a := by\n  simp [pure_eq_done]\n#align and_then_success and_then_success\n\n",
 "and_then_fail":
 "theorem and_then_fail : (p >> return ()) cb n = parse_result.fail n' err ↔ p cb n = fail n' err := by\n  simp [pure_eq_done]\n#align and_then_fail and_then_fail\n\n",
 "and_then_eq_bind":
 "@[simp]\ntheorem and_then_eq_bind {α β : Type} {m : Type → Type} [monad m] (a : m α) (b : m β) : a >> b = a >>= fun _ => b :=\n  rfl\n#align and_then_eq_bind and_then_eq_bind\n\n",
 "Nat":
 "#print Nat /-\ntheorem Nat : ¬nat.unfailing :=\n  of_bounded\n#align nat Nat\n-/\n\n"}