{"map_obj_append1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n-- TODO: this technical theorem is used in one place in constructing the initial algebra.\n-- Can it be avoided?\ntheorem map_obj_append1 {α γ : typevec n} (g : typevec.arrow α γ) (a : P.A) (f' : typevec.arrow (P.drop.B a) α)\n    (f : P.last.B a → P.W α) :\n    mvfunctor.map (append_fun g (P.W_map g)) (P.obj_append1 a f' f) =\n      P.obj_append1 a (typevec.comp g f') fun x => P.W_map g (f x) :=\n  by rw [obj_append1, obj_append1, map_eq, append_fun, ← split_fun_comp] <;> rfl\n#align map_obj_append1 map_obj_append1\n\n",
 "comp_W_path_cases_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\ntheorem comp_W_path_cases_on {α β : typevec n} (h : typevec.arrow α β) {a : P.A} {f : P.last.B a → P.last.W}\n    (g' : typevec.arrow (P.drop.B a) α) (g : ∀ j : P.last.B a, typevec.arrow (P.W_path (f j)) α) :\n    typevec.comp h (P.W_path_cases_on g' g) = P.W_path_cases_on (typevec.comp h g') fun i => typevec.comp h (g i) := by\n  ext (i x) <;> cases x <;> rfl\n#align comp_W_path_cases_on comp_W_path_cases_on\n\n",
 "Wp_rec_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem Wp_rec_eq {α : typevec n} {C : Type _}\n    (g : ∀ (a : P.A) (f : P.last.B a → P.last.W), typevec.arrow (P.W_path ⟨a, f⟩) α → (P.last.B a → C) → C) (a : P.A)\n    (f : P.last.B a → P.last.W) (f' : typevec.arrow (P.W_path ⟨a, f⟩) α) :\n    P.Wp_rec g ⟨a, f⟩ f' = g a f f' fun i => P.Wp_rec g (f i) (P.W_path_dest_right f' i) :=\n  rfl\n#align Wp_rec_eq Wp_rec_eq\n\n",
 "Wp_ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n-- Note: we could replace Prop by Type* and obtain a dependent recursor\ntheorem Wp_ind {α : typevec n} {C : ∀ x : P.last.W, typevec.arrow (P.W_path x) α → Prop}\n    (ih :\n      ∀ (a : P.A) (f : P.last.B a → P.last.W) (f' : typevec.arrow (P.W_path ⟨a, f⟩) α),\n        (∀ i : P.last.B a, C (f i) (P.W_path_dest_right f' i)) → C ⟨a, f⟩ f') :\n    ∀ (x : P.last.W) (f' : typevec.arrow (P.W_path x) α), C x f'\n  | ⟨a, f⟩, f' => ih a f f' fun i => Wp_ind _ _\n#align Wp_ind Wp_ind\n\n",
 "W_rec_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/-- Defining equation for the recursor of `W` -/\ntheorem W_rec_eq {α : typevec n} {C : Type _}\n    (g : ∀ a : P.A, typevec.arrow (P.drop.B a) α → (P.last.B a → P.W α) → (P.last.B a → C) → C) (a : P.A)\n    (f' : typevec.arrow (P.drop.B a) α) (f : P.last.B a → P.W α) :\n    P.W_rec g (P.W_mk a f' f) = g a f' f fun i => P.W_rec g (f i) :=\n  by\n  rw [W_mk, W_rec]; dsimp; rw [Wp_rec_eq]\n  dsimp only [W_path_dest_left_W_path_cases_on, W_path_dest_right_W_path_cases_on]\n  congr <;> ext1 i <;> cases f i <;> rfl\n#align W_rec_eq W_rec_eq\n\n",
 "W_path_dest_right_W_path_cases_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem W_path_dest_right_W_path_cases_on {α : typevec n} {a : P.A} {f : P.last.B a → P.last.W}\n    (g' : typevec.arrow (P.drop.B a) α) (g : ∀ j : P.last.B a, typevec.arrow (P.W_path (f j)) α) :\n    P.W_path_dest_right (P.W_path_cases_on g' g) = g :=\n  rfl\n#align W_path_dest_right_W_path_cases_on W_path_dest_right_W_path_cases_on\n\n",
 "W_path_dest_left_W_path_cases_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Simon Hudon\n-/\ntheorem W_path_dest_left_W_path_cases_on {α : typevec n} {a : P.A} {f : P.last.B a → P.last.W}\n    (g' : typevec.arrow (P.drop.B a) α) (g : ∀ j : P.last.B a, typevec.arrow (P.W_path (f j)) α) :\n    P.W_path_dest_left (P.W_path_cases_on g' g) = g' :=\n  rfl\n#align W_path_dest_left_W_path_cases_on W_path_dest_left_W_path_cases_on\n\n",
 "W_path_cases_on_eta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem W_path_cases_on_eta {α : typevec n} {a : P.A} {f : P.last.B a → P.last.W}\n    (h : typevec.arrow (P.W_path ⟨a, f⟩) α) : P.W_path_cases_on (P.W_path_dest_left h) (P.W_path_dest_right h) = h := by\n  ext (i x) <;> cases x <;> rfl\n#align W_path_cases_on_eta W_path_cases_on_eta\n\n",
 "W_mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem W_mk_eq {α : typevec n} (a : P.A) (f : P.last.B a → P.last.W) (g' : typevec.arrow (P.drop.B a) α)\n    (g : ∀ j : P.last.B a, typevec.arrow (P.W_path (f j)) α) :\n    (P.W_mk a g' fun i => ⟨f i, g i⟩) = ⟨⟨a, f⟩, P.W_path_cases_on g' g⟩ :=\n  rfl\n#align W_mk_eq W_mk_eq\n\n",
 "W_map_W_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem W_map_W_mk {α β : typevec n} (g : typevec.arrow α β) (a : P.A) (f' : typevec.arrow (P.drop.B a) α)\n    (f : P.last.B a → P.W α) :\n    mvfunctor.map g (P.W_mk a f' f) = P.W_mk a (typevec.comp g f') fun i => mvfunctor.map g (f i) :=\n  by\n  show _ = P.W_mk a (typevec.comp g f') (mvfunctor.map g ∘ f)\n  have : mvfunctor.map g ∘ f = fun i => ⟨(f i).fst, typevec.comp g (f i).snd⟩ :=\n    by\n    ext i : 1\n    dsimp [function.comp]\n    cases f i\n    rfl\n  rw [this]\n  have : f = fun i => ⟨(f i).fst, (f i).snd⟩ := by\n    ext1\n    cases f x\n    rfl\n  rw [this]\n  dsimp\n  rw [W_mk_eq, W_mk_eq]\n  have h := mvpfunctor.map_eq P.Wp g\n  rw [h, comp_W_path_cases_on]\n#align W_map_W_mk W_map_W_mk\n\n",
 "W_ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/-- Induction principle for `W` -/\ntheorem W_ind {α : typevec n} {C : P.W α → Prop}\n    (ih :\n      ∀ (a : P.A) (f' : typevec.arrow (P.drop.B a) α) (f : P.last.B a → P.W α), (∀ i, C (f i)) → C (P.W_mk a f' f)) :\n    ∀ x, C x := by\n  intro x; cases' x with a f\n  apply @Wp_ind n P α fun a f => C ⟨a, f⟩; dsimp\n  intro a f f' ih'\n  dsimp [W_mk] at ih\n  let ih'' := ih a (P.W_path_dest_left f') fun i => ⟨f i, P.W_path_dest_right f' i⟩\n  dsimp at ih''; rw [W_path_cases_on_eta] at ih''\n  apply ih''\n  apply ih'\n#align W_ind W_ind\n\n",
 "W_dest'_W_mk'":
 "theorem W_dest'_W_mk' {α : typevec n} (x : P.obj (α.append1 (P.W α))) : P.W_dest' (P.W_mk' x) = x := by\n  cases' x with a f <;> rw [W_mk', W_dest'_W_mk, split_drop_fun_last_fun]\n#align W_dest'_W_mk' W_dest'_W_mk'\n\n",
 "W_dest'_W_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem W_dest'_W_mk {α : typevec n} (a : P.A) (f' : typevec.arrow (P.drop.B a) α) (f : P.last.B a → P.W α) :\n    P.W_dest' (P.W_mk a f' f) = ⟨a, split_fun f' f⟩ := by rw [W_dest', W_rec_eq]\n#align W_dest'_W_mk W_dest'_W_mk\n\n",
 "W_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem W_cases {α : typevec n} {C : P.W α → Prop}\n    (ih : ∀ (a : P.A) (f' : typevec.arrow (P.drop.B a) α) (f : P.last.B a → P.W α), C (P.W_mk a f' f)) : ∀ x, C x :=\n  P.W_ind fun a f' f ih' => ih a f' f\n#align W_cases W_cases\n\n"}