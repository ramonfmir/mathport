{"map_dest":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem M.map_dest {α β : TypeVec n} (g : typevec.arrow (typevec.append_fun α (P.M α)) (typevec.append_fun β (P.M β)))\n    (x : P.M α) (h : ∀ x : P.M α, lastFun g x = (mvfunctor.map (dropFun g) x : P.M β)) :\n    mvfunctor.map g (M.dest P x) = M.dest P (mvfunctor.map (dropFun g) x) :=\n  by\n  rw [M.dest_map]; congr\n  apply eq_of_drop_last_eq <;> simp\n  ext1; apply h\n#align M.map_dest M.map_dest\n\n",
 "dest_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem M.dest_map {α β : TypeVec n} (g : typevec.arrow α β) (x : P.M α) :\n    M.dest P (mvfunctor.map g x) = mvfunctor.map (appendFun g fun x => mvfunctor.map g x) (M.dest P x) :=\n  by\n  cases' x with a f\n  rw [map_eq]\n  conv =>\n    rhs\n    rw [M.dest, M.dest', map_eq, append_fun_comp_split_fun]\n  rfl\n#align M.dest_map M.dest_map\n\n",
 "dest_eq_dest'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem M.dest_eq_dest' {α : TypeVec n} {x : P.last.M} {a : P.A} {f : P.last.B a → P.last.M}\n    (h : PFunctor.M.dest x = ⟨a, f⟩) (f' : typevec.arrow (M.Path P x) α) : M.dest P ⟨x, f'⟩ = M.dest' P h f' :=\n  M.dest'_eq_dest' _ _ _ _\n#align M.dest_eq_dest' M.dest_eq_dest'\n\n",
 "dest_corec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem M.dest_corec' {α : TypeVec.{u} n} {β : Type u} (g₀ : β → P.A) (g₁ : ∀ b : β, typevec.arrow (P.drop.B (g₀ b)) α)\n    (g₂ : ∀ b : β, P.last.B (g₀ b) → β) (x : β) :\n    M.dest P (M.corec' P g₀ g₁ g₂ x) = ⟨g₀ x, splitFun (g₁ x) (M.corec' P g₀ g₁ g₂ ∘ g₂ x)⟩ :=\n  rfl\n#align M.dest_corec' M.dest_corec'\n\n",
 "dest_corec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem M.dest_corec {α : TypeVec n} {β : Type u} (g : β → P.obj (α.append1 β)) (x : β) :\n    M.dest P (M.corec P g x) = mvfunctor.map (appendFun id (M.corec P g)) (g x) :=\n  by\n  trans; apply M.dest_corec'\n  cases' g x with a f; dsimp\n  rw [MvPFunctor.map_eq]; congr\n  conv =>\n    rhs\n    rw [← split_drop_fun_last_fun f, append_fun_comp_split_fun]\n  rfl\n#align M.dest_corec M.dest_corec\n\n",
 "dest'_eq_dest'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Mario Carneiro, Simon Hudon\n-/\ntheorem M.dest'_eq_dest' {α : TypeVec n} {x : P.last.M} {a₁ : P.A} {f₁ : P.last.B a₁ → P.last.M}\n    (h₁ : PFunctor.M.dest x = ⟨a₁, f₁⟩) {a₂ : P.A} {f₂ : P.last.B a₂ → P.last.M} (h₂ : PFunctor.M.dest x = ⟨a₂, f₂⟩)\n    (f' : typevec.arrow (M.Path P x) α) : M.dest' P h₁ f' = M.dest' P h₂ f' := by cases h₁.symm.trans h₂ <;> rfl\n#align M.dest'_eq_dest' M.dest'_eq_dest'\n\n",
 "bisim₀":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem M.bisim₀ {α : TypeVec n} (R : P.M α → P.M α → Prop) (h₀ : equivalence R)\n    (h :\n      ∀ x y,\n        R x y →\n          mvfunctor.map (typevec.append_fun id (Quot.mk R)) (M.dest _ x) =\n            mvfunctor.map (typevec.append_fun id (Quot.mk R)) (M.dest _ y))\n    (x y) (r : R x y) : x = y := by\n  apply M.bisim P R _ _ _ r\n  clear r x y\n  introv Hr\n  specialize h _ _ Hr\n  clear Hr\n  rcases M.dest P x with ⟨ax, fx⟩\n  rcases M.dest P y with ⟨ay, fy⟩\n  intro h\n  rw [map_eq, map_eq] at h\n  injection h with h₀ h₁\n  subst ay\n  simp at h₁\n  clear h\n  have Hdrop : drop_fun fx = drop_fun fy :=\n    by\n    replace h₁ := congr_arg drop_fun h₁\n    simpa using h₁\n  exists ax, drop_fun fx, last_fun fx, last_fun fy\n  rw [split_drop_fun_last_fun, Hdrop, split_drop_fun_last_fun]\n  simp\n  intro i\n  replace h₁ := congr_fun (congr_fun h₁ fin2.fz) i\n  simp [(typevec.comp · ·), append_fun, split_fun] at h₁\n  replace h₁ := Quot.exact _ h₁\n  rw [h₀.eqv_gen_iff] at h₁\n  exact h₁\n#align M.bisim₀ M.bisim₀\n\n",
 "bisim_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem M.bisim_lemma {α : TypeVec n} {a₁ : (mp P).A} {f₁ : typevec.arrow ((mp P).B a₁) α} {a' : P.A}\n    {f' : typevec.arrow (P.B a').drop α} {f₁' : (P.B a').last → M P α}\n    (e₁ : M.dest P ⟨a₁, f₁⟩ = ⟨a', splitFun f' f₁'⟩) :\n    ∃ (g₁' : _)(e₁' : PFunctor.M.dest a₁ = ⟨a', g₁'⟩),\n      f' = M.pathDestLeft P e₁' f₁ ∧ f₁' = fun x : (last P).B a' => ⟨g₁' x, M.pathDestRight P e₁' f₁ x⟩ :=\n  by\n  generalize ef : @split_fun n _ (append1 α (M P α)) f' f₁' = ff at e₁\n  cases' e₁' : PFunctor.M.dest a₁ with a₁' g₁'\n  rw [M.dest_eq_dest' _ e₁'] at e₁\n  cases e₁; exact ⟨_, e₁', split_fun_inj ef⟩\n#align M.bisim_lemma M.bisim_lemma\n\n",
 "bisim'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem M.bisim' {α : TypeVec n} (R : P.M α → P.M α → Prop)\n    (h :\n      ∀ x y,\n        R x y →\n          mvfunctor.map (typevec.append_fun id (Quot.mk R)) (M.dest _ x) =\n            mvfunctor.map (typevec.append_fun id (Quot.mk R)) (M.dest _ y))\n    (x y) (r : R x y) : x = y := by\n  have := M.bisim₀ P (EqvGen R) _ _\n  · solve_by_elim [eqv_gen.rel]\n  · apply eqv_gen.is_equivalence\n  · clear r x y\n    introv Hr\n    have : ∀ x y, R x y → EqvGen R x y := @eqv_gen.rel _ R\n    induction Hr\n    · rw [← Quot.factor_mk_eq R (EqvGen R) this]\n      rwa [append_fun_comp_id, ← MvFunctor.map_map, ← MvFunctor.map_map, h]\n    all_goals cc\n#align M.bisim' M.bisim'\n\n",
 "bisim":
 "theorem M.bisim {α : TypeVec n} (R : P.M α → P.M α → Prop)\n    (h :\n      ∀ x y,\n        R x y → ∃ a f f₁ f₂, M.dest P x = ⟨a, splitFun f f₁⟩ ∧ M.dest P y = ⟨a, splitFun f f₂⟩ ∧ ∀ i, R (f₁ i) (f₂ i))\n    (x y) (r : R x y) : x = y := by\n  cases' x with a₁ f₁\n  cases' y with a₂ f₂\n  dsimp [Mp] at *\n  have : a₁ = a₂ :=\n    by\n    refine' PFunctor.M.bisim (fun a₁ a₂ => ∃ x y, R x y ∧ x.1 = a₁ ∧ y.1 = a₂) _ _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩\n    rintro _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩\n    rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h'⟩\n    rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩\n    rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', _, rfl⟩\n    rw [e₁', e₂']\n    exact ⟨_, _, _, rfl, rfl, fun b => ⟨_, _, h' b, rfl, rfl⟩⟩\n  subst this\n  congr with (i p)\n  induction' p with x a f h' i c x a f h' i c p IH generalizing f₁ f₂ <;>\n    try\n      rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h''⟩\n      rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩\n      rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', e₃, rfl⟩\n      cases h'.symm.trans e₁'\n      cases h'.symm.trans e₂'\n  · exact (congr_fun (congr_fun e₃ i) c : _)\n  · exact IH _ _ (h'' _)\n#align M.bisim M.bisim\n\n"}