{"supp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_eq {α : typevec n} (a : P.A) (f : typevec.arrow (P.B a) α) (i) :\n    @supp.{u} _ P.obj _ α (⟨a, f⟩ : P.obj α) i = «expr '' » (f i) univ :=\n  by\n  ext; simp only [supp, image_univ, mem_range, mem_set_of_eq]\n  constructor <;> intro h\n  · apply @h fun i x => ∃ y : P.B a i, f i y = x\n    rw [liftp_iff']\n    intros\n    refine' ⟨_, rfl⟩\n  · simp only [liftp_iff']\n    cases h\n    subst x\n    tauto\n#align supp_eq supp_eq\n\n",
 "mk_get":
 "@[simp]\ntheorem comp.mk_get (x : (comp P Q).obj α) : comp.mk (comp.get x) = x :=\n  by\n  cases x\n  dsimp [comp.get, comp.mk]\n  ext : 2 <;> intros ; rfl; rfl\n  congr ; ext1 <;> intros <;> rfl\n  ext : 2; congr ; rcases x_1 with ⟨a, b, c⟩ <;> rfl\n#align comp.mk_get comp.mk_get\n\n",
 "map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Simon Hudon\n-/\ntheorem map_eq {α β : typevec n} (g : typevec.arrow α β) (a : P.A) (f : typevec.arrow (P.B a) α) :\n    @mvfunctor.map _ P.obj _ _ _ g ⟨a, f⟩ = ⟨a, typevec.comp g f⟩ :=\n  rfl\n#align map_eq map_eq\n\n",
 "liftr_iff":
 "theorem liftr_iff {α : typevec n} (r : ∀ ⦃i⦄, α i → α i → Prop) (x y : P.obj α) :\n    liftr r x y ↔ ∃ a f₀ f₁, x = ⟨a, f₀⟩ ∧ y = ⟨a, f₁⟩ ∧ ∀ i j, r (f₀ i j) (f₁ i j) :=\n  by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : u with a f\n    use a, fun i j => (f i j).val.fst, fun i j => (f i j).val.snd\n    constructor\n    · rw [← xeq, h]\n      rfl\n    constructor\n    · rw [← yeq, h]\n      rfl\n    intro i j\n    exact (f i j).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use ⟨a, fun i j => ⟨(f₀ i j, f₁ i j), h i j⟩⟩\n  dsimp; constructor\n  · rw [xeq]\n    rfl\n  rw [yeq]; rfl\n#align liftr_iff liftr_iff\n\n",
 "liftp_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\ntheorem liftp_iff' {α : typevec n} (p : ∀ ⦃i⦄, α i → Prop) (a : P.A) (f : typevec.arrow (P.B a) α) :\n    @liftp.{u} _ P.obj _ α p ⟨a, f⟩ ↔ ∀ i x, p (f i x) :=\n  by\n  simp only [liftp_iff, sigma.mk.inj_iff] <;> constructor <;> intro\n  · casesm*Exists _, _ ∧ _\n    subst_vars\n    assumption\n  repeat' first |constructor|assumption\n#align liftp_iff' liftp_iff'\n\n",
 "liftp_iff":
 "/-\nlifting predicates and relations\n-/\ntheorem liftp_iff {α : typevec n} (p : ∀ ⦃i⦄, α i → Prop) (x : P.obj α) :\n    liftp p x ↔ ∃ a f, x = ⟨a, f⟩ ∧ ∀ i j, p (f i j) :=\n  by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : y with a f\n    refine' ⟨a, fun i j => (f i j).val, _, fun i j => (f i j).property⟩\n    rw [← hy, h, map_eq]\n    rfl\n  rintro ⟨a, f, xeq, pf⟩\n  use ⟨a, fun i j => ⟨f i j, pf i j⟩⟩\n  rw [xeq]; rfl\n#align liftp_iff liftp_iff\n\n",
 "id_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem id_map {α : typevec n} : ∀ x : P.obj α, mvfunctor.map typevec.id x = x\n  | ⟨a, g⟩ => rfl\n#align id_map id_map\n\n",
 "get_mk":
 "@[simp]\ntheorem comp.get_mk (x : P.obj fun i => (Q i).obj α) : comp.get (comp.mk x) = x :=\n  by\n  cases x\n  simp! [comp.get, comp.mk]\n#align comp.get_mk comp.get_mk\n\n",
 "get_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem comp.get_map (f : typevec.arrow α β) (x : (comp P Q).obj α) :\n    comp.get (mvfunctor.map f x) = mvfunctor.map (fun i (x : (Q i).obj α) => mvfunctor.map f x) (comp.get x) :=\n  by\n  cases x\n  rfl\n#align comp.get_map comp.get_map\n\n",
 "comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem comp_map {α β γ : typevec n} (f : typevec.arrow α β) (g : typevec.arrow β γ) :\n    ∀ x : P.obj α, mvfunctor.map (typevec.comp g f) x = mvfunctor.map g (mvfunctor.map f x)\n  | ⟨a, h⟩ => rfl\n#align comp_map comp_map\n\n"}