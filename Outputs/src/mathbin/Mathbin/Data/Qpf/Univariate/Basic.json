{"symm":
 "theorem Wequiv.symm (x y : q.P.W) : Wequiv x y → Wequiv y x :=\n  by\n  cases' x with a f; cases' y with b g\n  intro h; induction h\n  case ind a f f' h ih => exact Wequiv.ind _ _ _ ih\n  case abs a f a' f' h => exact Wequiv.abs _ _ _ _ h.symm\n  case trans x y z e₁ e₂ ih₁ ih₂ => exact qpf.Wequiv.trans _ _ _ ih₂ ih₁\n#align Wequiv.symm Wequiv.symm\n\n",
 "supp_preservation_iff_uniform":
 "theorem supp_preservation_iff_uniform : q.supp_preservation ↔ q.is_uniform :=\n  by\n  constructor\n  · intro h α a a' f f' h'\n    rw [← PFunctor.supp_eq, ← PFunctor.supp_eq, ← h, h', h]\n  · rintro h α ⟨a, f⟩\n    rwa [supp_eq_of_is_uniform, PFunctor.supp_eq]\n#align supp_preservation_iff_uniform supp_preservation_iff_uniform\n\n",
 "supp_preservation_iff_liftp_preservation":
 "theorem supp_preservation_iff_liftp_preservation : q.supp_preservation ↔ q.liftp_preservation :=\n  by\n  constructor <;> intro h\n  · rintro α p ⟨a, f⟩\n    have h' := h\n    rw [supp_preservation_iff_uniform] at h'\n    dsimp only [supp_preservation, supp] at h\n    rwa [liftp_iff_of_is_uniform, supp_eq_of_is_uniform, PFunctor.liftp_iff'] <;> try assumption\n    · simp only [image_univ, mem_range, exists_imp]\n      constructor <;> intros <;> subst_vars <;> solve_by_elim\n  · rintro α ⟨a, f⟩\n    simp only [liftp_preservation] at h\n    simp only [supp, h]\n#align supp_preservation_iff_liftp_preservation supp_preservation_iff_liftp_preservation\n\n",
 "supp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_map (h : q.is_uniform) {α β : Type u} (g : α → β) (x : F α) : supp (g <$> x) = «expr '' » g (supp x) :=\n  by\n  rw [← abs_repr x]; cases' repr x with a f; rw [← abs_map, PFunctor.map_eq]\n  rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, image_comp]\n#align supp_map supp_map\n\n",
 "supp_eq_of_is_uniform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_eq_of_is_uniform (h : q.is_uniform) {α : Type u} (a : q.P.A) (f : q.P.B a → α) :\n    supp (abs ⟨a, f⟩) = «expr '' » f univ := by\n  ext u; rw [mem_supp]; constructor\n  · intro h'\n    apply h' _ _ rfl\n  intro h' a' f' e\n  rw [← h _ _ _ _ e.symm]; apply h'\n#align supp_eq_of_is_uniform supp_eq_of_is_uniform\n\n",
 "supp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_eq {α : Type u} (x : F α) : supp x = { u | ∀ a f, abs ⟨a, f⟩ = x → u ∈ «expr '' » f univ } := by\n  ext <;> apply mem_supp\n#align supp_eq supp_eq\n\n",
 "refl":
 "theorem Wequiv.refl (x : q.P.W) : Wequiv x x := by cases' x with a f <;> exact Wequiv.abs a f a f rfl\n#align Wequiv.refl Wequiv.refl\n\n",
 "rec_unique":
 "theorem fix.rec_unique {α : Type u} (g : F α → α) (h : Fix F → α) (hyp : ∀ x, h (Fix.mk x) = g (h <$> x)) :\n    Fix.rec g = h := by\n  ext x\n  apply fix.ind_rec\n  intro x hyp'\n  rw [hyp, ← hyp', fix.rec_eq]\n#align fix.rec_unique fix.rec_unique\n\n",
 "rec_eq":
 "theorem fix.rec_eq {α : Type _} (g : F α → α) (x : F (Fix F)) : Fix.rec g (Fix.mk x) = g (Fix.rec g <$> x) :=\n  by\n  have : recF g ∘ fixToW = Fix.rec g := by\n    apply funext\n    apply quotient.ind\n    intro x\n    apply recF_eq_of_Wequiv\n    rw [fix_to_W]\n    apply Wrepr_equiv\n  conv =>\n    lhs\n    rw [fix.rec, fix.mk]\n    dsimp\n  cases' h : repr x with a f\n  rw [PFunctor.map_eq, recF_eq, ← PFunctor.map_eq, PFunctor.W.dest_mk, ← PFunctor.comp_map, abs_map, ← h, abs_repr,\n    this]\n#align fix.rec_eq fix.rec_eq\n\n",
 "recF_eq_of_Wequiv":
 "/-- recF is insensitive to the representation -/\ntheorem recF_eq_of_Wequiv {α : Type u} (u : F α → α) (x y : q.P.W) : Wequiv x y → recF u x = recF u y :=\n  by\n  cases' x with a f; cases' y with b g\n  intro h; induction h\n  case ind a f f' h ih => simp only [recF_eq', PFunctor.map_eq, Function.comp, ih]\n  case abs a f a' f' h => simp only [recF_eq', abs_map, h]\n  case trans x y z e₁ e₂ ih₁ ih₂ => exact Eq.trans ih₁ ih₂\n#align recF_eq_of_Wequiv recF_eq_of_Wequiv\n\n",
 "recF_eq'":
 "theorem recF_eq' {α : Type _} (g : F α → α) (a : q.P.A) (f : q.P.B a → q.P.W) :\n    recF g ⟨a, f⟩ = g (abs (recF g <$> ⟨a, f⟩)) :=\n  rfl\n#align recF_eq' recF_eq'\n\n",
 "recF_eq":
 "/-\nThink of trees in the `W` type corresponding to `P` as representatives of elements of the\nleast fixed point of `F`, and assign a canonical representative to each equivalence class\nof trees.\n-/\ntheorem recF_eq {α : Type _} (g : F α → α) (x : q.P.W) : recF g x = g (abs (recF g <$> x.dest)) := by cases x <;> rfl\n#align recF_eq recF_eq\n\n",
 "mk_dest":
 "theorem fix.mk_dest (x : Fix F) : Fix.mk (Fix.dest x) = x :=\n  by\n  change (fix.mk ∘ fix.dest) x = id x\n  apply fix.ind_rec\n  intro x; dsimp\n  rw [fix.dest, fix.rec_eq, id_map, comp_map]\n  intro h; rw [h]\n#align fix.mk_dest fix.mk_dest\n\n",
 "mem_supp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nComposition of qpfs.\n-/\n/-\nQuotients.\n\nWe show that if `F` is a qpf and `G` is a suitable quotient of `F`, then `G` is a qpf.\n-/\n/-\nSupport.\n-/\ntheorem mem_supp {α : Type u} (x : F α) (u : α) : u ∈ supp x ↔ ∀ a f, abs ⟨a, f⟩ = x → u ∈ «expr '' » f univ :=\n  by\n  rw [supp]; dsimp; constructor\n  · intro h a f haf\n    have : liftp (fun u => u ∈ «expr '' » f univ) x :=\n      by\n      rw [liftp_iff]\n      refine' ⟨a, f, haf.symm, fun i => mem_image_of_mem _ (mem_univ _)⟩\n    exact h this\n  intro h p; rw [liftp_iff]\n  rintro ⟨a, f, xeq, h'⟩\n  rcases h a f xeq.symm with ⟨i, _, hi⟩\n  rw [← hi]; apply h'\n#align mem_supp mem_supp\n\n",
 "liftr_iff":
 "theorem liftr_iff {α : Type u} (r : α → α → Prop) (x y : F α) :\n    Liftr r x y ↔ ∃ a f₀ f₁, x = abs ⟨a, f₀⟩ ∧ y = abs ⟨a, f₁⟩ ∧ ∀ i, r (f₀ i) (f₁ i) :=\n  by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : repr u with a f\n    use a, fun i => (f i).val.fst, fun i => (f i).val.snd\n    constructor\n    · rw [← xeq, ← abs_repr u, h, ← abs_map]\n      rfl\n    constructor\n    · rw [← yeq, ← abs_repr u, h, ← abs_map]\n      rfl\n    intro i\n    exact (f i).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use abs ⟨a, fun i => ⟨(f₀ i, f₁ i), h i⟩⟩\n  dsimp; constructor\n  · rw [xeq, ← abs_map]\n    rfl\n  rw [yeq, ← abs_map]; rfl\n#align liftr_iff liftr_iff\n\n",
 "liftp_preservation_iff_uniform":
 "theorem liftp_preservation_iff_uniform : q.liftp_preservation ↔ q.is_uniform := by\n  rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]\n#align liftp_preservation_iff_uniform liftp_preservation_iff_uniform\n\n",
 "liftp_iff_of_is_uniform":
 "theorem liftp_iff_of_is_uniform (h : q.is_uniform) {α : Type u} (x : F α) (p : α → Prop) :\n    Liftp p x ↔ ∀ u ∈ supp x, p u := by\n  rw [liftp_iff, ← abs_repr x]\n  cases' repr x with a f; constructor\n  · rintro ⟨a', f', abseq, hf⟩ u\n    rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq]\n    rintro ⟨i, _, hi⟩\n    rw [← hi]\n    apply hf\n  intro h'\n  refine' ⟨a, f, rfl, fun i => h' _ _⟩\n  rw [supp_eq_of_is_uniform h]\n  exact ⟨i, mem_univ i, rfl⟩\n#align liftp_iff_of_is_uniform liftp_iff_of_is_uniform\n\n",
 "liftp_iff'":
 "theorem liftp_iff' {α : Type u} (p : α → Prop) (x : F α) : Liftp p x ↔ ∃ u : q.P.obj α, abs u = x ∧ ∀ i, p (u.snd i) :=\n  by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : repr y with a f\n    use ⟨a, fun i => (f i).val⟩\n    dsimp\n    constructor\n    · rw [← hy, ← abs_repr y, h, ← abs_map]\n      rfl\n    intro i\n    apply (f i).property\n  rintro ⟨⟨a, f⟩, h₀, h₁⟩; dsimp at *\n  use abs ⟨a, fun i => ⟨f i, h₁ i⟩⟩\n  rw [← abs_map, ← h₀]; rfl\n#align liftp_iff' liftp_iff'\n\n",
 "liftp_iff":
 "/-\nLifting predicates and relations\n-/\ntheorem liftp_iff {α : Type u} (p : α → Prop) (x : F α) : Liftp p x ↔ ∃ a f, x = abs ⟨a, f⟩ ∧ ∀ i, p (f i) :=\n  by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : repr y with a f\n    use a, fun i => (f i).val\n    constructor\n    · rw [← hy, ← abs_repr y, h, ← abs_map]\n      rfl\n    intro i\n    apply (f i).property\n  rintro ⟨a, f, h₀, h₁⟩; dsimp at *\n  use abs ⟨a, fun i => ⟨f i, h₁ i⟩⟩\n  rw [← abs_map, h₀]; rfl\n#align liftp_iff liftp_iff\n\n",
 "ind_rec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem fix.ind_rec {α : Type u} (g₁ g₂ : Fix F → α)\n    (h : ∀ x : F (Fix F), g₁ <$> x = g₂ <$> x → g₁ (Fix.mk x) = g₂ (Fix.mk x)) : ∀ x, g₁ x = g₂ x :=\n  by\n  apply Quot.ind\n  intro x\n  induction' x with a f ih\n  change g₁ («expr⟦ ⟧» ⟨a, f⟩) = g₂ («expr⟦ ⟧» ⟨a, f⟩)\n  rw [← fix.ind_aux a f]; apply h\n  rw [← abs_map, ← abs_map, PFunctor.map_eq, PFunctor.map_eq]\n  dsimp [Function.comp]\n  congr with x; apply ih\n#align fix.ind_rec fix.ind_rec\n\n",
 "ind_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem fix.ind_aux (a : q.P.A) (f : q.P.B a → q.P.W) : Fix.mk (abs ⟨a, fun x => «expr⟦ ⟧» (f x)⟩) = «expr⟦ ⟧» ⟨a, f⟩ :=\n  by\n  have : Fix.mk (abs ⟨a, fun x => «expr⟦ ⟧» (f x)⟩) = «expr⟦ ⟧» (Wrepr ⟨a, f⟩) :=\n    by\n    apply quot.sound; apply Wequiv.abs'\n    rw [PFunctor.W.dest_mk, abs_map, abs_repr, ← abs_map, PFunctor.map_eq]\n    conv =>\n      rhs\n      simp only [Wrepr, recF_eq, PFunctor.W.dest_mk, abs_repr]\n    rfl\n  rw [this]\n  apply quot.sound\n  apply Wrepr_equiv\n#align fix.ind_aux fix.ind_aux\n\n",
 "ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem fix.ind (p : Fix F → Prop) (h : ∀ x : F (Fix F), Liftp p x → p (Fix.mk x)) : ∀ x, p x :=\n  by\n  apply Quot.ind\n  intro x\n  induction' x with a f ih\n  change p («expr⟦ ⟧» ⟨a, f⟩)\n  rw [← fix.ind_aux a f]\n  apply h\n  rw [liftp_iff]\n  refine' ⟨_, _, rfl, _⟩\n  apply ih\n#align fix.ind fix.ind\n\n",
 "id_map":
 "/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad\n-/\n/-\nShow that every qpf is a lawful functor.\n\nNote: every functor has a field, `map_const`, and is_lawful_functor has the defining\ncharacterization. We can only propagate the assumption.\n-/\ntheorem id_map {α : Type _} (x : F α) : id <$> x = x :=\n  by\n  rw [← abs_repr x]\n  cases' repr x with a f\n  rw [← abs_map]\n  rfl\n#align id_map id_map\n\n",
 "has_good_supp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem has_good_supp_iff {α : Type u} (x : F α) :\n    (∀ p, Liftp p x ↔ ∀ u ∈ supp x, p u) ↔\n      ∃ a f, abs ⟨a, f⟩ = x ∧ ∀ a' f', abs ⟨a', f'⟩ = x → «expr '' » f univ ⊆ «expr '' » f' univ :=\n  by\n  constructor\n  · intro h\n    have : liftp (supp x) x := by rw [h] <;> intro u <;> exact id\n    rw [liftp_iff] at this\n    rcases this with ⟨a, f, xeq, h'⟩\n    refine' ⟨a, f, xeq.symm, _⟩\n    intro a' f' h''\n    rintro u ⟨i, _, hfi⟩\n    have : u ∈ supp x := by rw [← hfi] <;> apply h'\n    exact (mem_supp x u).mp this _ _ h''\n  rintro ⟨a, f, xeq, h⟩ p; rw [liftp_iff]; constructor\n  · rintro ⟨a', f', xeq', h'⟩ u usuppx\n    rcases(mem_supp x u).mp usuppx a' f' xeq'.symm with ⟨i, _, f'ieq⟩\n    rw [← f'ieq]\n    apply h'\n  intro h'\n  refine' ⟨a, f, xeq.symm, _⟩; intro i\n  apply h'; rw [mem_supp]\n  intro a' f' xeq'\n  apply h a' f' xeq'\n  apply mem_image_of_mem _ (mem_univ _)\n#align has_good_supp_iff has_good_supp_iff\n\n",
 "dest_mk":
 "theorem fix.dest_mk (x : F (Fix F)) : Fix.dest (Fix.mk x) = x :=\n  by\n  unfold fix.dest; rw [fix.rec_eq, ← fix.dest, ← comp_map]\n  conv =>\n    rhs\n    rw [← id_map x]\n  congr with x; apply fix.mk_dest\n#align fix.dest_mk fix.dest_mk\n\n",
 "dest_corec":
 "-- Equivalence\ntheorem cofix.dest_corec {α : Type u} (g : α → F α) (x : α) : Cofix.dest (Cofix.corec g x) = Cofix.corec g <$> g x :=\n  by\n  conv =>\n    lhs\n    rw [cofix.dest, cofix.corec];\n  dsimp\n  rw [corecF_eq, abs_map, abs_repr, ← comp_map]; rfl\n#align cofix.dest_corec cofix.dest_corec\n\n",
 "corecF_eq":
 "/-\nConstruct the final coalgebra to a qpf.\n-/\ntheorem corecF_eq {α : Type _} (g : α → F α) (x : α) : PFunctor.M.dest (corecF g x) = corecF g <$> repr (g x) := by\n  rw [corecF, PFunctor.M.dest_corec]\n#align corecF_eq corecF_eq\n\n",
 "comp_map":
 "theorem comp_map {α β γ : Type _} (f : α → β) (g : β → γ) (x : F α) : (g ∘ f) <$> x = g <$> f <$> x :=\n  by\n  rw [← abs_repr x]\n  cases' repr x with a f\n  rw [← abs_map, ← abs_map, ← abs_map]\n  rfl\n#align comp_map comp_map\n\n",
 "bisim_rel":
 "theorem cofix.bisim_rel (r : Cofix F → Cofix F → Prop)\n    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) : ∀ x y, r x y → x = y :=\n  by\n  let r' (x y) := x = y ∨ r x y\n  intro x y rxy\n  apply cofix.bisim_aux r'\n  · intro x\n    left\n    rfl\n  · intro x y r'xy\n    cases r'xy\n    · rw [r'xy]\n    have : ∀ x y, r x y → r' x y := fun x y h => or.inr h\n    rw [← Quot.factor_mk_eq _ _ this]\n    dsimp\n    rw [@comp_map _ _ q _ _ _ (Quot.mk r), @comp_map _ _ q _ _ _ (Quot.mk r)]\n    rw [h _ _ r'xy]\n  right; exact rxy\n#align cofix.bisim_rel cofix.bisim_rel\n\n",
 "bisim_aux":
 "private theorem cofix.bisim_aux (r : Cofix F → Cofix F → Prop) (h' : ∀ x, r x x)\n    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) : ∀ x y, r x y → x = y :=\n  by\n  intro x\n  apply Quot.inductionOn x\n  clear x\n  intro x y\n  apply Quot.inductionOn y\n  clear y\n  intro y rxy\n  apply quot.sound\n  let r' x y := r (Quot.mk _ x) (Quot.mk _ y)\n  have : is_precongr r' := by\n    intro a b r'ab\n    have h₀ :\n      Quot.mk r <$> Quot.mk Mcongr <$> abs (PFunctor.M.dest a) =\n        Quot.mk r <$> Quot.mk Mcongr <$> abs (PFunctor.M.dest b) :=\n      h _ _ r'ab\n    have h₁ : ∀ u v : q.P.M, Mcongr u v → Quot.mk r' u = Quot.mk r' v :=\n      by\n      intro u v cuv\n      apply quot.sound\n      dsimp [r']\n      rw [quot.sound cuv]\n      apply h'\n    let f : Quot r → Quot r' :=\n      Quot.lift (Quot.lift (Quot.mk r') h₁)\n        (by\n          intro c; apply Quot.inductionOn c; clear c\n          intro c d; apply Quot.inductionOn d; clear d\n          intro d rcd; apply quot.sound; apply rcd)\n    have : f ∘ Quot.mk r ∘ Quot.mk Mcongr = Quot.mk r' := rfl\n    rw [← this, PFunctor.comp_map _ _ f, PFunctor.comp_map _ _ (Quot.mk r), abs_map, abs_map, abs_map, h₀]\n    rw [PFunctor.comp_map _ _ f, PFunctor.comp_map _ _ (Quot.mk r), abs_map, abs_map, abs_map]\n  refine' ⟨r', this, rxy⟩\n#align cofix.bisim_aux cofix.bisim_aux\n\n",
 "bisim'":
 "theorem cofix.bisim' {α : Type _} (Q : α → Prop) (u v : α → Cofix F)\n    (h :\n      ∀ x,\n        Q x →\n          ∃ a f f',\n            Cofix.dest (u x) = abs ⟨a, f⟩ ∧\n              Cofix.dest (v x) = abs ⟨a, f'⟩ ∧ ∀ i, ∃ x', Q x' ∧ f i = u x' ∧ f' i = v x') :\n    ∀ x, Q x → u x = v x := fun x Qx =>\n  let R := fun w z : Cofix F => ∃ x', Q x' ∧ w = u x' ∧ z = v x'\n  Cofix.bisim R\n    (fun x y ⟨x', Qx', xeq, yeq⟩ => by\n      rcases h x' Qx' with ⟨a, f, f', ux'eq, vx'eq, h'⟩\n      rw [liftr_iff]\n      refine' ⟨a, f, f', xeq.symm ▸ ux'eq, yeq.symm ▸ vx'eq, h'⟩)\n    _ _ ⟨x, Qx, rfl, rfl⟩\n#align cofix.bisim' cofix.bisim'\n\n",
 "bisim":
 "theorem cofix.bisim (r : Cofix F → Cofix F → Prop) (h : ∀ x y, r x y → Liftr r (Cofix.dest x) (Cofix.dest y)) :\n    ∀ x y, r x y → x = y := by\n  apply cofix.bisim_rel\n  intro x y rxy\n  rcases(liftr_iff r _ _).mp (h x y rxy) with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩\n  rw [dxeq, dyeq, ← abs_map, ← abs_map, PFunctor.map_eq, PFunctor.map_eq]\n  congr 2 with i\n  apply quot.sound\n  apply h'\n#align cofix.bisim cofix.bisim\n\n",
 "abs'":
 "theorem Wequiv.abs' (x y : q.P.W) (h : abs x.dest = abs y.dest) : Wequiv x y :=\n  by\n  cases x\n  cases y\n  apply Wequiv.abs\n  apply h\n#align Wequiv.abs' Wequiv.abs'\n\n",
 "Wrepr_equiv":
 "theorem Wrepr_equiv (x : q.P.W) : Wequiv (Wrepr x) x :=\n  by\n  induction' x with a f ih\n  apply Wequiv.trans\n  · change Wequiv (Wrepr ⟨a, f⟩) (PFunctor.W.mk (Wrepr <$> ⟨a, f⟩))\n    apply Wequiv.abs'\n    have : Wrepr ⟨a, f⟩ = PFunctor.W.mk (repr (abs (Wrepr <$> ⟨a, f⟩))) := rfl\n    rw [this, PFunctor.W.dest_mk, abs_repr]\n    rfl\n  apply Wequiv.ind; exact ih\n#align Wrepr_equiv Wrepr_equiv\n\n",
 "LawfulFunctor":
 "#print LawfulFunctor /-\ntheorem LawfulFunctor (h : ∀ α β : Type u, @functor.map_const F _ α _ = functor.map ∘ Function.const β) :\n    LawfulFunctor F :=\n  { map_const_eq := h\n    id_map := @id_map F _ _\n    comp_map := @comp_map F _ _ }\n#align is_lawful_functor LawfulFunctor\n-/\n\n"}