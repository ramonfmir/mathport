{"mk_dest":
 "theorem cofix.mk_dest {α : TypeVec n} (x : cofix F α) : cofix.mk (cofix.dest x) = x :=\n  by\n  apply cofix.bisim_rel (fun x y : cofix F α => x = cofix.mk (cofix.dest y)) _ _ _ rfl; dsimp\n  intro x y h; rw [h]\n  conv =>\n    lhs\n    congr\n    skip\n    rw [cofix.mk]\n    rw [cofix.dest_corec]\n  rw [← comp_map, ← append_fun_comp, id_comp]\n  rw [← comp_map, ← append_fun_comp, id_comp, ← cofix.mk]\n  congr 2 with u; apply quot.sound; rfl\n#align cofix.mk_dest cofix.mk_dest\n\n",
 "liftr_map_last'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem liftr_map_last' [LawfulMvFunctor F] {α : TypeVec n} {ι} (R : ι → ι → Prop) (x : F (typevec.append_fun α ι))\n    (f : ι → ι) (hh : ∀ x : ι, R (f x) x) : LiftR' (RelLast' _ R) (mvfunctor.map (typevec.append_fun id f) x) x :=\n  by\n  have := liftr_map_last R x f id hh\n  rwa [append_fun_id_id, MvFunctor.id_map] at this\n#align liftr_map_last' liftr_map_last'\n\n",
 "liftr_map_last":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.prod.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem liftr_map_last [LawfulMvFunctor F] {α : TypeVec n} {ι ι'} (R : ι' → ι' → Prop) (x : F (typevec.append_fun α ι))\n    (f g : ι → ι') (hh : ∀ x : ι, R (f x) (g x)) :\n    LiftR' (RelLast' _ R) (mvfunctor.map (typevec.append_fun id f) x) (mvfunctor.map (typevec.append_fun id g) x) :=\n  let h : ι → { x : ι' × ι' // uncurry R x } := fun x => ⟨(f x, g x), hh x⟩\n  let b : typevec.arrow (typevec.append_fun α ι) _ := typevec.append_fun (@diagSub n α) h\n  let c :\n    typevec.arrow (typevec.append_fun (Subtype_ α.repeat_eq) { x // uncurry R x })\n      (typevec.append_fun (fun i : Fin2 n => { x // ofRepeat (α.rel_last' R i.fs x) }) (Subtype (uncurry R))) :=\n    typevec.append_fun (ofSubtype _) id\n  have hh :\n    typevec.comp (subtypeVal _) (typevec.comp (toSubtype _) (typevec.comp fromAppend1DropLast (typevec.comp c b))) =\n      typevec.comp (typevec.prod.map (typevec.append_fun id f) (typevec.append_fun id g)) prod.diag :=\n    by\n    dsimp [c, b]\n    apply eq_of_drop_last_eq\n    · dsimp\n      simp only [prod_map_id, drop_fun_prod, drop_fun_append_fun, drop_fun_diag, id_comp, drop_fun_to_subtype]\n      erw [to_subtype_of_subtype_assoc, id_comp]\n      clear * -\n      ext (i x) : 2\n      induction i\n      rfl\n      apply i_ih\n    simp only [h, last_fun_from_append1_drop_last, last_fun_to_subtype, last_fun_append_fun, last_fun_subtype_val,\n      comp.left_id, last_fun_comp, last_fun_prod]\n    dsimp\n    ext1\n    rfl\n  liftr_map _ _ _ _ (typevec.comp (toSubtype _) (typevec.comp fromAppend1DropLast (typevec.comp c b))) hh\n#align liftr_map_last liftr_map_last\n\n",
 "liftr_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.prod.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem liftr_map {α β : TypeVec n} {F' : TypeVec n → Type u} [MvFunctor F'] [LawfulMvFunctor F']\n    (R : typevec.arrow (typevec.prod β β) (repeat n Prop)) (x : F' α) (f g : typevec.arrow α β)\n    (h : typevec.arrow α (Subtype_ R))\n    (hh : typevec.comp (subtypeVal _) h = typevec.comp (typevec.prod.map f g) prod.diag) :\n    LiftR' R (mvfunctor.map f x) (mvfunctor.map g x) :=\n  by\n  rw [liftr_def]\n  exists mvfunctor.map h x\n  rw [MvFunctor.map_map, comp_assoc, hh, ← comp_assoc, fst_prod_mk, comp_assoc, fst_diag]\n  rw [MvFunctor.map_map, comp_assoc, hh, ← comp_assoc, snd_prod_mk, comp_assoc, snd_diag]\n  dsimp [liftr']; constructor <;> rfl\n#align liftr_map liftr_map\n\n",
 "ext_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem cofix.ext_mk {α : TypeVec n} (x y : F (typevec.append_fun α (cofix F α))) (h : cofix.mk x = cofix.mk y) :\n    x = y := by rw [← cofix.dest_mk x, h, cofix.dest_mk]\n#align cofix.ext_mk cofix.ext_mk\n\n",
 "ext":
 "theorem cofix.ext {α : TypeVec n} (x y : cofix F α) (h : x.dest = y.dest) : x = y := by\n  rw [← cofix.mk_dest x, h, cofix.mk_dest]\n#align cofix.ext cofix.ext\n\n",
 "dest_mk":
 "theorem cofix.dest_mk {α : TypeVec n} (x : F (α.append1 <| cofix F α)) : cofix.dest (cofix.mk x) = x :=\n  by\n  have : cofix.mk ∘ cofix.dest = @_root_.id (cofix F α) := funext cofix.mk_dest\n  rw [cofix.mk, cofix.dest_corec, ← comp_map, ← cofix.mk, ← append_fun_comp, this, id_comp, append_fun_id_id,\n    MvFunctor.id_map]\n#align cofix.dest_mk cofix.dest_mk\n\n",
 "dest_corec₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem cofix.dest_corec₁ {α : TypeVec n} {β : Type u} (g : ∀ {X}, (cofix F α → X) → (β → X) → β → F (α.append1 X))\n    (x : β)\n    (h :\n      ∀ (X Y) (f : cofix F α → X) (f' : β → X) (k : X → Y),\n        g (k ∘ f) (k ∘ f') x = mvfunctor.map (typevec.append_fun id k) (g f f' x)) :\n    cofix.dest (cofix.corec₁ (@g) x) = g id (cofix.corec₁ @g) x := by rw [cofix.corec₁, cofix.dest_corec', ← h] <;> rfl\n#align cofix.dest_corec₁ cofix.dest_corec₁\n\n",
 "dest_corec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem cofix.dest_corec' {α : TypeVec n} {β : Type u} (g : β → F (α.append1 (Sum (cofix F α) β))) (x : β) :\n    cofix.dest (cofix.corec' g x) = mvfunctor.map (appendFun id (Sum.elim id (cofix.corec' g))) (g x) :=\n  by\n  rw [cofix.corec', cofix.dest_corec]; dsimp\n  congr with (i | i) <;> rw [corec_roll] <;> dsimp [cofix.corec']\n  · mv_bisim i\n    rw [Ha, Hb, cofix.dest_corec]\n    dsimp [(· ∘ ·)]\n    repeat' rw [MvFunctor.map_map, ← append_fun_comp_id]\n    apply liftr_map_last'\n    dsimp [(· ∘ ·), R]\n    intros\n    exact ⟨_, rfl, rfl⟩\n  · congr with y\n    erw [append_fun_id_id]\n    simp [MvFunctor.id_map]\n#align cofix.dest_corec' cofix.dest_corec'\n\n",
 "dest_corec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem cofix.dest_corec {α : TypeVec n} {β : Type u} (g : β → F (α.append1 β)) (x : β) :\n    cofix.dest (cofix.corec g x) = mvfunctor.map (appendFun id (cofix.corec g)) (g x) :=\n  by\n  conv =>\n    lhs\n    rw [cofix.dest, cofix.corec];\n  dsimp\n  rw [corecF_eq, abs_map, abs_repr, ← comp_map, ← append_fun_comp]; rfl\n#align cofix.dest_corec cofix.dest_corec\n\n",
 "corec_roll":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem corec_roll {α : TypeVec n} {X Y} {x₀ : X} (f : X → Y) (g : Y → F (typevec.append_fun α X)) :\n    cofix.corec (g ∘ f) x₀ = cofix.corec (mvfunctor.map (typevec.append_fun id f) ∘ g) (f x₀) :=\n  by\n  mv_bisim x₀\n  rw [Ha, Hb, cofix.dest_corec, cofix.dest_corec]\n  rw [MvFunctor.map_map, ← append_fun_comp_id]\n  refine' liftr_map_last _ _ _ _ _\n  intro a; refine' ⟨a, rfl, rfl⟩\n#align corec_roll corec_roll\n\n",
 "corecF_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Simon Hudon\n-/\ntheorem corecF_eq {α : TypeVec n} {β : Type _} (g : β → F (α.append1 β)) (x : β) :\n    M.dest q.P (corecF g x) = mvfunctor.map (appendFun id (corecF g)) (repr (g x)) := by rw [corecF, M.dest_corec]\n#align corecF_eq corecF_eq\n\n",
 "bisim₂":
 "/-- Bisimulation principle using `liftr'` to match and relate children of two trees. -/\ntheorem cofix.bisim₂ {α : TypeVec n} (r : cofix F α → cofix F α → Prop)\n    (h : ∀ x y, r x y → LiftR' (RelLast' α r) (cofix.dest x) (cofix.dest y)) : ∀ x y, r x y → x = y :=\n  cofix.bisim _ <| by intros <;> rw [← liftr_last_rel_iff] <;> apply h <;> assumption\n#align cofix.bisim₂ cofix.bisim₂\n\n",
 "bisim_rel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/-- Bisimulation principle using `map` and `quot.mk` to match and relate children of two trees. -/\ntheorem cofix.bisim_rel {α : TypeVec n} (r : cofix F α → cofix F α → Prop)\n    (h :\n      ∀ x y,\n        r x y →\n          mvfunctor.map (appendFun id (Quot.mk r)) (cofix.dest x) =\n            mvfunctor.map (appendFun id (Quot.mk r)) (cofix.dest y)) :\n    ∀ x y, r x y → x = y := by\n  let r' (x y) := x = y ∨ r x y\n  intro x y rxy\n  apply cofix.bisim_aux r'\n  · intro x\n    left\n    rfl\n  · intro x y r'xy\n    cases r'xy\n    · rw [r'xy]\n    have : ∀ x y, r x y → r' x y := fun x y h => or.inr h\n    rw [← Quot.factor_mk_eq _ _ this]\n    dsimp\n    rw [append_fun_comp_id, append_fun_comp_id]\n    rw [@comp_map _ _ _ q _ _ _ (append_fun id (Quot.mk r)), @comp_map _ _ _ q _ _ _ (append_fun id (Quot.mk r))]\n    rw [h _ _ r'xy]\n  right; exact rxy\n#align cofix.bisim_rel cofix.bisim_rel\n\n",
 "bisim_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\nprivate theorem cofix.bisim_aux {α : TypeVec n} (r : cofix F α → cofix F α → Prop) (h' : ∀ x, r x x)\n    (h :\n      ∀ x y,\n        r x y →\n          mvfunctor.map (appendFun id (Quot.mk r)) (cofix.dest x) =\n            mvfunctor.map (appendFun id (Quot.mk r)) (cofix.dest y)) :\n    ∀ x y, r x y → x = y := by\n  intro x\n  apply Quot.inductionOn x\n  clear x\n  intro x y\n  apply Quot.inductionOn y\n  clear y\n  intro y rxy\n  apply quot.sound\n  let r' x y := r (Quot.mk _ x) (Quot.mk _ y)\n  have : is_precongr r' := by\n    intro a b r'ab\n    have h₀ :\n      mvfunctor.map (append_fun id (Quot.mk r ∘ Quot.mk Mcongr)) (abs (M.dest q.P a)) =\n        mvfunctor.map (append_fun id (Quot.mk r ∘ Quot.mk Mcongr)) (abs (M.dest q.P b)) :=\n      by rw [append_fun_comp_id, comp_map, comp_map] <;> exact h _ _ r'ab\n    have h₁ : ∀ u v : q.P.M α, Mcongr u v → Quot.mk r' u = Quot.mk r' v :=\n      by\n      intro u v cuv\n      apply quot.sound\n      dsimp [r']\n      rw [quot.sound cuv]\n      apply h'\n    let f : Quot r → Quot r' :=\n      Quot.lift (Quot.lift (Quot.mk r') h₁)\n        (by\n          intro c; apply Quot.inductionOn c; clear c\n          intro c d; apply Quot.inductionOn d; clear d\n          intro d rcd; apply quot.sound; apply rcd)\n    have : f ∘ Quot.mk r ∘ Quot.mk Mcongr = Quot.mk r' := rfl\n    rw [← this, append_fun_comp_id, q.P.comp_map, q.P.comp_map, abs_map, abs_map, abs_map, abs_map, h₀]\n  refine' ⟨r', this, rxy⟩\n#align cofix.bisim_aux cofix.bisim_aux\n\n",
 "bisim'":
 "/-- Bisimulation principle the values `⟨a,f⟩` of the polynomial functor representing\n`cofix F α` as well as an invariant `Q : β → Prop` and a state `β` generating the\nleft-hand side and right-hand side of the equality through functions `u v : β → cofix F α` -/\ntheorem cofix.bisim' {α : TypeVec n} {β : Type _} (Q : β → Prop) (u v : β → cofix F α)\n    (h :\n      ∀ x,\n        Q x →\n          ∃ a f' f₀ f₁,\n            cofix.dest (u x) = abs ⟨a, q.P.append_contents f' f₀⟩ ∧\n              cofix.dest (v x) = abs ⟨a, q.P.append_contents f' f₁⟩ ∧ ∀ i, ∃ x', Q x' ∧ f₀ i = u x' ∧ f₁ i = v x') :\n    ∀ x, Q x → u x = v x := fun x Qx =>\n  let R := fun w z : cofix F α => ∃ x', Q x' ∧ w = u x' ∧ z = v x'\n  cofix.bisim R\n    (fun x y ⟨x', Qx', xeq, yeq⟩ =>\n      by\n      rcases h x' Qx' with ⟨a, f', f₀, f₁, ux'eq, vx'eq, h'⟩\n      rw [liftr_iff]\n      refine' ⟨a, q.P.append_contents f' f₀, q.P.append_contents f' f₁, xeq.symm ▸ ux'eq, yeq.symm ▸ vx'eq, _⟩\n      intro i; cases i\n      · apply h'\n      · intro j\n        apply Eq.refl)\n    _ _ ⟨x, Qx, rfl, rfl⟩\n#align cofix.bisim' cofix.bisim'\n\n",
 "bisim":
 "/-- Bisimulation principle using `liftr` to match and relate children of two trees. -/\ntheorem cofix.bisim {α : TypeVec n} (r : cofix F α → cofix F α → Prop)\n    (h : ∀ x y, r x y → LiftR (RelLast α r) (cofix.dest x) (cofix.dest y)) : ∀ x y, r x y → x = y :=\n  by\n  apply cofix.bisim_rel\n  intro x y rxy\n  rcases(liftr_iff (rel_last α r) _ _).mp (h x y rxy) with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩\n  rw [dxeq, dyeq, ← abs_map, ← abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]\n  rw [← split_drop_fun_last_fun f₀, ← split_drop_fun_last_fun f₁]\n  rw [append_fun_comp_split_fun, append_fun_comp_split_fun]\n  rw [id_comp, id_comp]\n  congr 2 with (i j); cases' i with _ i <;> dsimp\n  · apply quot.sound\n    apply h' _ j\n  · change f₀ _ j = f₁ _ j\n    apply h' _ j\n#align cofix.bisim cofix.bisim\n\n",
 "abs_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem cofix.abs_repr {α} (x : cofix F α) : Quot.mk _ (cofix.repr x) = x :=\n  by\n  let R := fun x y : cofix F α => cofix.abs (cofix.repr y) = x\n  refine' cofix.bisim₂ R _ _ _ rfl\n  clear x; rintro x y h; dsimp [R] at h; subst h\n  dsimp [cofix.dest, cofix.abs]\n  induction y using Quot.ind\n  simp only [cofix.repr, M.dest_corec, abs_map, abs_repr]\n  conv =>\n    congr\n    skip\n    rw [cofix.dest]\n  dsimp; rw [MvFunctor.map_map, MvFunctor.map_map, ← append_fun_comp_id, ← append_fun_comp_id]\n  let f : typevec.arrow (typevec.append_fun α ((P F).M α)) (subtype_ (α.rel_last' R)) :=\n    split_fun diag_sub fun x => ⟨(cofix.abs (cofix.abs x).repr, cofix.abs x), _⟩\n  refine' liftr_map _ _ _ _ f _\n  · simp only [← append_prod_append_fun, prod_map_id]\n    apply eq_of_drop_last_eq\n    · dsimp\n      simp only [drop_fun_diag]\n      erw [subtype_val_diag_sub]\n    ext1\n    simp only [cofix.abs, Prod.mk.inj_iff, Prod_map, Function.comp_apply, last_fun_append_fun, last_fun_subtype_val,\n      last_fun_comp, last_fun_split_fun]\n    dsimp [drop_fun_rel_last, last_fun, prod.diag]\n    constructor <;> rfl\n  dsimp [rel_last', split_fun, function.uncurry, R]\n  rfl\n#align cofix.abs_repr cofix.abs_repr\n\n"}