{"symm":
 "theorem Wequiv.symm {α : TypeVec n} (x y : q.P.W α) : WEquiv x y → WEquiv y x :=\n  by\n  intro h; induction h\n  case ind a f' f₀ f₁ h ih => exact Wequiv.ind _ _ _ _ ih\n  case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h => exact Wequiv.abs _ _ _ _ _ _ h.symm\n  case trans x y z e₁ e₂ ih₁ ih₂ => exact mvqpf.Wequiv.trans _ _ _ ih₂ ih₁\n#align Wequiv.symm Wequiv.symm\n\n",
 "refl":
 "theorem Wequiv.refl {α : TypeVec n} (x : q.P.W α) : WEquiv x x := by\n  apply q.P.W_cases _ x <;> intro a f' f <;> exact Wequiv.abs a f' f a f' f rfl\n#align Wequiv.refl Wequiv.refl\n\n",
 "rec_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem fix.rec_unique {β : Type _} (g : F (append1 α β) → β) (h : Fix F α → β)\n    (hyp : ∀ x, h (Fix.mk x) = g (mvfunctor.map (appendFun id h) x)) : Fix.rec g = h :=\n  by\n  ext x\n  apply fix.ind_rec\n  intro x hyp'\n  rw [hyp, ← hyp', fix.rec_eq]\n#align fix.rec_unique fix.rec_unique\n\n",
 "rec_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem fix.rec_eq {β : Type u} (g : F (append1 α β) → β) (x : F (append1 α (Fix F α))) :\n    Fix.rec g (Fix.mk x) = g (mvfunctor.map (appendFun id (Fix.rec g)) x) :=\n  by\n  have : recF g ∘ fixToW = Fix.rec g := by\n    apply funext\n    apply quotient.ind\n    intro x\n    apply recF_eq_of_Wequiv\n    apply Wrepr_equiv\n  conv =>\n    lhs\n    rw [fix.rec, fix.mk]\n    dsimp\n  cases' h : repr x with a f\n  rw [MvPFunctor.map_eq, recF_eq', ← MvPFunctor.map_eq, MvPFunctor.wDest'_wMk']\n  rw [← MvPFunctor.comp_map, abs_map, ← h, abs_repr, ← append_fun_comp, id_comp, this]\n#align fix.rec_eq fix.rec_eq\n\n",
 "recF_eq_of_Wequiv":
 "theorem recF_eq_of_Wequiv (α : TypeVec n) {β : Type _} (u : F (α.append1 β) → β) (x y : q.P.W α) :\n    WEquiv x y → recF u x = recF u y := by\n  apply q.P.W_cases _ x\n  intro a₀ f'₀ f₀\n  apply q.P.W_cases _ y\n  intro a₁ f'₁ f₁\n  intro h; induction h\n  case ind a f' f₀ f₁ h ih => simp only [recF_eq, Function.comp, ih]\n  case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h => simp only [recF_eq', abs_map, MvPFunctor.wDest'_wMk, h]\n  case trans x y z e₁ e₂ ih₁ ih₂ => exact Eq.trans ih₁ ih₂\n#align recF_eq_of_Wequiv recF_eq_of_Wequiv\n\n",
 "recF_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem recF_eq' {α : TypeVec n} {β : Type _} (g : F (α.append1 β) → β) (x : q.P.W α) :\n    recF g x = g (abs (mvfunctor.map (appendFun id (recF g)) (q.P.W_dest' x))) :=\n  by\n  apply q.P.W_cases _ x\n  intro a f' f\n  rw [recF_eq, q.P.W_dest'_W_mk, MvPFunctor.map_eq, append_fun_comp_split_fun, TypeVec.id_comp]\n#align recF_eq' recF_eq'\n\n",
 "recF_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Simon Hudon\n-/\ntheorem recF_eq {α : TypeVec n} {β : Type _} (g : F (α.append1 β) → β) (a : q.P.A) (f' : typevec.arrow (q.P.drop.B a) α)\n    (f : q.P.last.B a → q.P.W α) : recF g (q.P.W_mk a f' f) = g (abs ⟨a, splitFun f' (recF g ∘ f)⟩) := by\n  rw [recF, MvPFunctor.wRec_eq] <;> rfl\n#align recF_eq recF_eq\n\n",
 "mk_dest":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem fix.mk_dest (x : Fix F α) : Fix.mk (Fix.dest x) = x :=\n  by\n  change (fix.mk ∘ fix.dest) x = x\n  apply fix.ind_rec\n  intro x; dsimp\n  rw [fix.dest, fix.rec_eq, ← comp_map, ← append_fun_comp, id_comp]\n  intro h; rw [h]\n  show fix.mk (mvfunctor.map (append_fun id id) x) = fix.mk x\n  rw [append_fun_id_id, MvFunctor.id_map]\n#align fix.mk_dest fix.mk_dest\n\n",
 "ind_rec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem fix.ind_rec {β : Type _} (g₁ g₂ : Fix F α → β)\n    (h :\n      ∀ x : F (append1 α (Fix F α)),\n        mvfunctor.map (appendFun id g₁) x = mvfunctor.map (appendFun id g₂) x → g₁ (Fix.mk x) = g₂ (Fix.mk x)) :\n    ∀ x, g₁ x = g₂ x := by\n  apply Quot.ind\n  intro x\n  apply q.P.W_ind _ x\n  intro a f' f ih\n  show g₁ («expr⟦ ⟧» (q.P.W_mk a f' f)) = g₂ («expr⟦ ⟧» (q.P.W_mk a f' f))\n  rw [← fix.ind_aux a f' f]\n  apply h\n  rw [← abs_map, ← abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]\n  congr 2\n  rw [MvPFunctor.appendContents, append_fun, append_fun, ← split_fun_comp, ← split_fun_comp]\n  have : (g₁ ∘ fun x => «expr⟦ ⟧» (f x)) = g₂ ∘ fun x => «expr⟦ ⟧» (f x) :=\n    by\n    ext x\n    exact ih x\n  rw [this]\n#align fix.ind_rec fix.ind_rec\n\n",
 "ind_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem fix.ind_aux (a : q.P.A) (f' : typevec.arrow (q.P.drop.B a) α) (f : q.P.last.B a → q.P.W α) :\n    Fix.mk (abs ⟨a, q.P.append_contents f' fun x => «expr⟦ ⟧» (f x)⟩) = «expr⟦ ⟧» (q.P.W_mk a f' f) :=\n  by\n  have : Fix.mk (abs ⟨a, q.P.append_contents f' fun x => «expr⟦ ⟧» (f x)⟩) = «expr⟦ ⟧» (wrepr (q.P.W_mk a f' f)) :=\n    by\n    apply quot.sound; apply Wequiv.abs'\n    rw [MvPFunctor.wDest'_wMk', abs_map, abs_repr, ← abs_map, MvPFunctor.map_eq]\n    conv =>\n      rhs\n      rw [Wrepr_W_mk, q.P.W_dest'_W_mk', abs_repr, MvPFunctor.map_eq]\n    congr 2; rw [MvPFunctor.appendContents, MvPFunctor.appendContents]\n    rw [append_fun, append_fun, ← split_fun_comp, ← split_fun_comp]\n    rfl\n  rw [this]\n  apply quot.sound\n  apply Wrepr_equiv\n#align fix.ind_aux fix.ind_aux\n\n",
 "ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem fix.ind {α : TypeVec n} (p : Fix F α → Prop)\n    (h : ∀ x : F (α.append1 (Fix F α)), LiftP (PredLast α p) x → p (Fix.mk x)) : ∀ x, p x :=\n  by\n  apply Quot.ind\n  intro x\n  apply q.P.W_ind _ x; intro a f' f ih\n  change p («expr⟦ ⟧» (q.P.W_mk a f' f))\n  rw [← fix.ind_aux a f' f]\n  apply h\n  rw [MvQPF.liftP_iff]\n  refine' ⟨_, _, rfl, _⟩\n  intro i j\n  cases i\n  · apply ih\n  · trivial\n#align fix.ind fix.ind\n\n",
 "dest_mk":
 "theorem fix.dest_mk (x : F (append1 α (Fix F α))) : Fix.dest (Fix.mk x) = x :=\n  by\n  unfold fix.dest\n  rw [fix.rec_eq, ← fix.dest, ← comp_map]\n  conv =>\n    rhs\n    rw [← MvFunctor.id_map x]\n  rw [← append_fun_comp, id_comp]\n  have : fix.mk ∘ fix.dest = id := by\n    ext x\n    apply fix.mk_dest\n  rw [this, append_fun_id_id]\n#align fix.dest_mk fix.dest_mk\n\n",
 "abs'":
 "theorem Wequiv.abs' {α : TypeVec n} (x y : q.P.W α) (h : abs (q.P.W_dest' x) = abs (q.P.W_dest' y)) : WEquiv x y :=\n  by\n  revert h\n  apply q.P.W_cases _ x\n  intro a₀ f'₀ f₀\n  apply q.P.W_cases _ y\n  intro a₁ f'₁ f₁\n  apply Wequiv.abs\n#align Wequiv.abs' Wequiv.abs'\n\n",
 "Wrepr_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem Wrepr_equiv {α : TypeVec n} (x : q.P.W α) : WEquiv (wrepr x) x :=\n  by\n  apply q.P.W_ind _ x; intro a f' f ih\n  apply Wequiv.trans _ (q.P.W_mk' (mvfunctor.map (append_fun id Wrepr) ⟨a, q.P.append_contents f' f⟩))\n  · apply Wequiv.abs'\n    rw [Wrepr_W_mk, q.P.W_dest'_W_mk', q.P.W_dest'_W_mk', abs_repr]\n  rw [q.P.map_eq, MvPFunctor.wMk', append_fun_comp_split_fun, id_comp]\n  apply Wequiv.ind; exact ih\n#align Wrepr_equiv Wrepr_equiv\n\n",
 "Wrepr_W_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem Wrepr_W_mk {α : TypeVec n} (a : q.P.A) (f' : typevec.arrow (q.P.drop.B a) α) (f : q.P.last.B a → q.P.W α) :\n    wrepr (q.P.W_mk a f' f) =\n      q.P.W_mk' (repr (abs (mvfunctor.map (appendFun id wrepr) ⟨a, q.P.append_contents f' f⟩))) :=\n  by rw [Wrepr, recF_eq', q.P.W_dest'_W_mk] <;> rfl\n#align Wrepr_W_mk Wrepr_W_mk\n\n",
 "Wequiv_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem Wequiv_map {α β : TypeVec n} (g : typevec.arrow α β) (x y : q.P.W α) :\n    WEquiv x y → WEquiv (mvfunctor.map g x) (mvfunctor.map g y) :=\n  by\n  intro h; induction h\n  case ind a f' f₀ f₁ h ih => rw [q.P.W_map_W_mk, q.P.W_map_W_mk]; apply Wequiv.ind; apply ih\n  case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h =>\n    rw [q.P.W_map_W_mk, q.P.W_map_W_mk]; apply Wequiv.abs\n    show\n      abs (q.P.obj_append1 a₀ (typevec.comp g f'₀) fun x => q.P.W_map g (f₀ x)) =\n        abs (q.P.obj_append1 a₁ (typevec.comp g f'₁) fun x => q.P.W_map g (f₁ x))\n    rw [← q.P.map_obj_append1, ← q.P.map_obj_append1, abs_map, abs_map, h]\n  case trans x y z e₁ e₂ ih₁ ih₂ => apply mvqpf.Wequiv.trans; apply ih₁; apply ih₂\n#align Wequiv_map Wequiv_map\n\n"}