{"supp_preservation_iff_uniform":
 "theorem supp_preservation_iff_uniform : q.supp_preservation ↔ q.is_uniform :=\n  by\n  constructor\n  · intro h α a a' f f' h' i\n    rw [← MvPFunctor.supp_eq, ← MvPFunctor.supp_eq, ← h, h', h]\n  · rintro h α ⟨a, f⟩\n    ext\n    rwa [supp_eq_of_is_uniform, MvPFunctor.supp_eq]\n#align supp_preservation_iff_uniform supp_preservation_iff_uniform\n\n",
 "supp_preservation_iff_liftp_preservation":
 "theorem supp_preservation_iff_liftp_preservation : q.supp_preservation ↔ q.liftp_preservation :=\n  by\n  constructor <;> intro h\n  · rintro α p ⟨a, f⟩\n    have h' := h\n    rw [supp_preservation_iff_uniform] at h'\n    dsimp only [supp_preservation, supp] at h\n    simp only [liftp_iff_of_is_uniform, supp_eq_of_is_uniform, MvPFunctor.liftP_iff', h', image_univ, mem_range,\n      exists_imp]\n    constructor <;> intros <;> subst_vars <;> solve_by_elim\n  · rintro α ⟨a, f⟩\n    simp only [liftp_preservation] at h\n    ext\n    simp [supp, h]\n#align supp_preservation_iff_liftp_preservation supp_preservation_iff_liftp_preservation\n\n",
 "supp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_map (h : q.is_uniform) {α β : TypeVec n} (g : typevec.arrow α β) (x : F α) (i) :\n    supp (mvfunctor.map g x) i = «expr '' » (g i) (supp x i) :=\n  by\n  rw [← abs_repr x]; cases' repr x with a f; rw [← abs_map, MvPFunctor.map_eq]\n  rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, ← image_comp]\n  rfl\n#align supp_map supp_map\n\n",
 "supp_eq_of_is_uniform":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_eq_of_is_uniform (h : q.is_uniform) {α : TypeVec n} (a : q.P.A) (f : typevec.arrow (q.P.B a) α) :\n    ∀ i, supp (abs ⟨a, f⟩) i = «expr '' » (f i) univ := by\n  intro ; ext u; rw [mem_supp]; constructor\n  · intro h'\n    apply h' _ _ rfl\n  intro h' a' f' e\n  rw [← h _ _ _ _ e.symm]; apply h'\n#align supp_eq_of_is_uniform supp_eq_of_is_uniform\n\n",
 "supp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supp_eq {α : TypeVec n} {i} (x : F α) : supp x i = { u | ∀ a f, abs ⟨a, f⟩ = x → u ∈ «expr '' » (f i) univ } :=\n  by ext <;> apply mem_supp\n#align supp_eq supp_eq\n\n",
 "mem_supp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_supp {α : TypeVec n} (x : F α) (i) (u : α i) :\n    u ∈ supp x i ↔ ∀ a f, abs ⟨a, f⟩ = x → u ∈ «expr '' » (f i) univ :=\n  by\n  rw [supp]; dsimp; constructor\n  · intro h a f haf\n    have : liftp (fun i u => u ∈ «expr '' » (f i) univ) x :=\n      by\n      rw [liftp_iff]\n      refine' ⟨a, f, haf.symm, _⟩\n      intro i u\n      exact mem_image_of_mem _ (mem_univ _)\n    exact h this\n  intro h p; rw [liftp_iff]\n  rintro ⟨a, f, xeq, h'⟩\n  rcases h a f xeq.symm with ⟨i, _, hi⟩\n  rw [← hi]; apply h'\n#align mem_supp mem_supp\n\n",
 "liftr_iff":
 "theorem liftr_iff {α : TypeVec n} (r : ∀ ⦃i⦄, α i → α i → Prop) (x y : F α) :\n    LiftR r x y ↔ ∃ a f₀ f₁, x = abs ⟨a, f₀⟩ ∧ y = abs ⟨a, f₁⟩ ∧ ∀ i j, r (f₀ i j) (f₁ i j) :=\n  by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : repr u with a f\n    use a, fun i j => (f i j).val.fst, fun i j => (f i j).val.snd\n    constructor\n    · rw [← xeq, ← abs_repr u, h, ← abs_map]\n      rfl\n    constructor\n    · rw [← yeq, ← abs_repr u, h, ← abs_map]\n      rfl\n    intro i j\n    exact (f i j).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use abs ⟨a, fun i j => ⟨(f₀ i j, f₁ i j), h i j⟩⟩\n  dsimp; constructor\n  · rw [xeq, ← abs_map]\n    rfl\n  rw [yeq, ← abs_map]; rfl\n#align liftr_iff liftr_iff\n\n",
 "liftp_preservation_iff_uniform":
 "theorem liftp_preservation_iff_uniform : q.liftp_preservation ↔ q.is_uniform := by\n  rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]\n#align liftp_preservation_iff_uniform liftp_preservation_iff_uniform\n\n",
 "liftp_iff_of_is_uniform":
 "theorem liftp_iff_of_is_uniform (h : q.is_uniform) {α : TypeVec n} (x : F α) (p : ∀ i, α i → Prop) :\n    LiftP p x ↔ ∀ (i), ∀ u ∈ supp x i, p i u :=\n  by\n  rw [liftp_iff, ← abs_repr x]\n  cases' repr x with a f; constructor\n  · rintro ⟨a', f', abseq, hf⟩ u\n    rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq]\n    rintro b ⟨i, _, hi⟩\n    rw [← hi]\n    apply hf\n  intro h'\n  refine' ⟨a, f, rfl, fun _ i => h' _ _ _⟩\n  rw [supp_eq_of_is_uniform h]\n  exact ⟨i, mem_univ i, rfl⟩\n#align liftp_iff_of_is_uniform liftp_iff_of_is_uniform\n\n",
 "liftp_iff":
 "-- Lifting predicates and relations\ntheorem liftp_iff {α : TypeVec n} (p : ∀ ⦃i⦄, α i → Prop) (x : F α) :\n    LiftP p x ↔ ∃ a f, x = abs ⟨a, f⟩ ∧ ∀ i j, p (f i j) :=\n  by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : repr y with a f\n    use a, fun i j => (f i j).val\n    constructor\n    · rw [← hy, ← abs_repr y, h, ← abs_map]\n      rfl\n    intro i j\n    apply (f i j).property\n  rintro ⟨a, f, h₀, h₁⟩; dsimp at *\n  use abs ⟨a, fun i j => ⟨f i j, h₁ i j⟩⟩\n  rw [← abs_map, h₀]; rfl\n#align liftp_iff liftp_iff\n\n",
 "id_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Simon Hudon\n-/\nprotected theorem id_map {α : TypeVec n} (x : F α) : mvfunctor.map TypeVec.id x = x :=\n  by\n  rw [← abs_repr x]\n  cases' repr x with a f\n  rw [← abs_map]\n  rfl\n#align id_map id_map\n\n",
 "has_good_supp_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem has_good_supp_iff {α : TypeVec n} (x : F α) :\n    (∀ p, LiftP p x ↔ ∀ (i), ∀ u ∈ supp x i, p i u) ↔\n      ∃ a f, abs ⟨a, f⟩ = x ∧ ∀ i a' f', abs ⟨a', f'⟩ = x → «expr '' » (f i) univ ⊆ «expr '' » (f' i) univ :=\n  by\n  constructor\n  · intro h\n    have : liftp (supp x) x := by\n      rw [h]\n      introv\n      exact id\n    rw [liftp_iff] at this\n    rcases this with ⟨a, f, xeq, h'⟩\n    refine' ⟨a, f, xeq.symm, _⟩\n    intro a' f' h''\n    rintro hu u ⟨j, h₂, hfi⟩\n    have hh : u ∈ supp x a' := by rw [← hfi] <;> apply h'\n    refine' (mem_supp x _ u).mp hh _ _ hu\n  rintro ⟨a, f, xeq, h⟩ p; rw [liftp_iff]; constructor\n  · rintro ⟨a', f', xeq', h'⟩ i u usuppx\n    rcases(mem_supp x _ u).mp (@usuppx) a' f' xeq'.symm with ⟨i, _, f'ieq⟩\n    rw [← f'ieq]\n    apply h'\n  intro h'\n  refine' ⟨a, f, xeq.symm, _⟩; intro j y\n  apply h'; rw [mem_supp]\n  intro a' f' xeq'\n  apply h _ a' f' xeq'\n  apply mem_image_of_mem _ (mem_univ _)\n#align has_good_supp_iff has_good_supp_iff\n\n",
 "comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n@[simp]\ntheorem comp_map {α β γ : TypeVec n} (f : typevec.arrow α β) (g : typevec.arrow β γ) (x : F α) :\n    mvfunctor.map (typevec.comp g f) x = mvfunctor.map g (mvfunctor.map f x) :=\n  by\n  rw [← abs_repr x]\n  cases' repr x with a f\n  rw [← abs_map, ← abs_map, ← abs_map]\n  rfl\n#align comp_map comp_map\n\n"}