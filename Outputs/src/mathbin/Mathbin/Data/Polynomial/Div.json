{"zero_mod_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n@[simp]\ntheorem zero_mod_by_monic (p : polynomial R) : «expr %ₘ » 0 p = 0 :=\n  by\n  unfold mod_by_monic div_mod_by_monic_aux\n  by_cases hp : monic p\n  · rw [dif_pos hp, if_neg (mt And.right (not_not_intro rfl))]\n  · rw [dif_neg hp]\n#align zero_mod_by_monic zero_mod_by_monic\n\n",
 "zero_div_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n@[simp]\ntheorem zero_div_by_monic (p : polynomial R) : «expr /ₘ » 0 p = 0 :=\n  by\n  unfold div_by_monic div_mod_by_monic_aux\n  by_cases hp : monic p\n  · rw [dif_pos hp, if_neg (mt And.right (not_not_intro rfl))]\n  · rw [dif_neg hp]\n#align zero_div_by_monic zero_div_by_monic\n\n",
 "sum_mod_by_monic_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem sum_mod_by_monic_coeff (hq : q.monic) {n : ℕ} (hn : q.degree ≤ n) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (monomial i ((«expr %ₘ » p q).coeff i)) =\n      «expr %ₘ » p q :=\n  by\n  nontriviality R\n  exact\n    (sum_fin (fun i c => monomial i c) (by simp) ((degree_mod_by_monic_lt _ hq).trans_le hn)).trans (sum_monomial_eq _)\n#align sum_mod_by_monic_coeff sum_mod_by_monic_coeff\n\n",
 "sub_dvd_eval_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem sub_dvd_eval_sub (a b : R) (p : polynomial R) : a - b ∣ p.eval a - p.eval b :=\n  by\n  suffices X - C b ∣ p - C (p.eval b) by\n    simpa only [coe_eval_ring_hom, eval_sub, eval_X, eval_C] using (eval_ring_hom a).map_dvd this\n  simp [dvd_iff_is_root]\n#align sub_dvd_eval_sub sub_dvd_eval_sub\n\n",
 "root_multiplicity_zero":
 "@[simp]\ntheorem root_multiplicity_zero {x : R} : rootMultiplicity x 0 = 0 :=\n  dif_pos rfl\n#align root_multiplicity_zero root_multiplicity_zero\n\n",
 "root_multiplicity_pos'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem root_multiplicity_pos' {p : polynomial R} {x : R} : 0 < rootMultiplicity x p ↔ p ≠ 0 ∧ IsRoot p x := by\n  rw [pos_iff_ne_zero, ne.def, root_multiplicity_eq_zero_iff, not_imp, and_comm]\n#align root_multiplicity_pos' root_multiplicity_pos'\n\n",
 "root_multiplicity_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_pos {p : polynomial R} (hp : p ≠ 0) {x : R} : 0 < rootMultiplicity x p ↔ IsRoot p x :=\n  rootMultiplicity_pos'.trans (and_iff_right hp)\n#align root_multiplicity_pos root_multiplicity_pos\n\n",
 "root_multiplicity_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem root_multiplicity_eq_zero_iff {p : polynomial R} {x : R} : rootMultiplicity x p = 0 ↔ IsRoot p x → p = 0 := by\n  simp only [root_multiplicity_eq_multiplicity, dite_eq_left_iff, PartENat.get_eq_iff_eq_coe, Nat.cast_zero,\n    multiplicity.multiplicity_eq_zero, dvd_iff_is_root, not_imp_not]\n#align root_multiplicity_eq_zero_iff root_multiplicity_eq_zero_iff\n\n",
 "root_multiplicity_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_eq_zero {p : polynomial R} {x : R} (h : ¬IsRoot p x) : rootMultiplicity x p = 0 :=\n  rootMultiplicity_eq_zero_iff.2 fun h' => (h h').elim\n#align root_multiplicity_eq_zero root_multiplicity_eq_zero\n\n",
 "root_multiplicity_eq_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_eq_multiplicity (p : polynomial R) (a : R) :\n    rootMultiplicity a p =\n      if h0 : p = 0 then 0 else (multiplicity (X - C a) p).get (multiplicity_X_sub_C_finite a h0) :=\n  by simp [multiplicity, root_multiplicity, part.dom] <;> congr <;> funext <;> congr\n#align root_multiplicity_eq_multiplicity root_multiplicity_eq_multiplicity\n\n",
 "root_multiplicity_C":
 "@[simp]\ntheorem root_multiplicity_C (r a : R) : rootMultiplicity a (C r) = 0 := by\n  simp only [root_multiplicity_eq_zero_iff, is_root, eval_C, C_eq_zero, imp_self]\n#align root_multiplicity_C root_multiplicity_C\n\n",
 "pow_root_multiplicity_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem pow_root_multiplicity_dvd (p : polynomial R) (a : R) : (X - C a) ^ rootMultiplicity a p ∣ p :=\n  if h : p = 0 then by simp [h]\n  else by rw [root_multiplicity_eq_multiplicity, dif_neg h] <;> exact multiplicity.pow_multiplicity_dvd _\n#align pow_root_multiplicity_dvd pow_root_multiplicity_dvd\n\n",
 "not_is_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_is_field : ¬IsField (polynomial R) := by\n  nontriviality R\n  rw [Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top]\n  use Ideal.span {Polynomial.X}\n  constructor\n  · rw [bot_lt_iff_ne_bot, ne.def, Ideal.span_singleton_eq_bot]\n    exact Polynomial.X_ne_zero\n  · rw [lt_top_iff_ne_top, ne.def, Ideal.eq_top_iff_one, Ideal.mem_span_singleton, Polynomial.X_dvd_iff,\n      Polynomial.coeff_one_zero]\n    exact one_ne_zero\n#align not_is_field not_is_field\n\n",
 "nat_degree_div_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem nat_degree_div_by_monic {R : Type u} [CommRing R] (f : polynomial R) {g : polynomial R} (hg : g.monic) :\n    natDegree («expr /ₘ » f g) = natDegree f - natDegree g :=\n  by\n  nontriviality R\n  by_cases hfg : «expr /ₘ » f g = 0\n  · rw [hfg, nat_degree_zero]\n    rw [div_by_monic_eq_zero_iff hg] at hfg\n    rw [tsub_eq_zero_iff_le.mpr (nat_degree_le_nat_degree <| le_of_lt hfg)]\n  have hgf := hfg\n  rw [div_by_monic_eq_zero_iff hg] at hgf\n  push_neg  at hgf\n  have := degree_add_div_by_monic hg hgf\n  have hf : f ≠ 0 := by\n    intro hf\n    apply hfg\n    rw [hf, zero_div_by_monic]\n  rw [degree_eq_nat_degree hf, degree_eq_nat_degree hg.ne_zero, degree_eq_nat_degree hfg, ← WithBot.coe_add,\n    WithBot.coe_eq_coe] at this\n  rw [← this, add_tsub_cancel_left]\n#align nat_degree_div_by_monic nat_degree_div_by_monic\n\n",
 "multiplicity_finite_of_degree_pos_of_monic":
 "theorem multiplicity_finite_of_degree_pos_of_monic (hp : (0 : WithBot ℕ) < degree p) (hmp : Monic p) (hq : q ≠ 0) :\n    multiplicity.Finite p q :=\n  have zn0 : (0 : R) ≠ 1 :=\n    haveI := nontrivial.of_polynomial_ne hq\n    zero_ne_one\n  ⟨natDegree q, fun ⟨r, hr⟩ =>\n    by\n    have hp0 : p ≠ 0 := fun hp0 => by simp [hp0] at hp <;> contradiction\n    have hr0 : r ≠ 0 := fun hr0 => by simp_all\n    have hpn1 : leadingCoeff p ^ (natDegree q + 1) = 1 := by simp [show _ = _ from hmp]\n    have hpn0' : leadingCoeff p ^ (natDegree q + 1) ≠ 0 := hpn1.symm ▸ zn0.symm\n    have hpnr0 : leadingCoeff (p ^ (natDegree q + 1)) * leadingCoeff r ≠ 0 := by\n      simp only [leading_coeff_pow' hpn0', leading_coeff_eq_zero, hpn1, one_pow, one_mul, ne.def, hr0] <;> simp\n    have hnp : 0 < natDegree p := by rw [← WithBot.coe_lt_coe, ← degree_eq_nat_degree hp0] <;> exact hp\n    have := congr_arg nat_degree hr\n    rw [nat_degree_mul' hpnr0, nat_degree_pow' hpn0', add_mul, add_assoc] at this\n    exact\n      ne_of_lt\n        (lt_add_of_le_of_pos (le_mul_of_one_le_right (nat.zero_le _) hnp)\n          (add_pos_of_pos_of_nonneg (by rwa [one_mul]) (nat.zero_le _)))\n        this⟩\n#align multiplicity_finite_of_degree_pos_of_monic multiplicity_finite_of_degree_pos_of_monic\n\n",
 "multiplicity_X_sub_C_finite":
 "theorem multiplicity_X_sub_C_finite (a : R) (h0 : p ≠ 0) : multiplicity.Finite (X - C a) p :=\n  by\n  haveI := nontrivial.of_polynomial_ne h0\n  refine' multiplicity_finite_of_degree_pos_of_monic _ (monic_X_sub_C _) h0\n  rw [degree_X_sub_C]\n  decide\n#align multiplicity_X_sub_C_finite multiplicity_X_sub_C_finite\n\n",
 "mul_div_mod_by_monic_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem mul_div_mod_by_monic_cancel_left (p : polynomial R) {q : polynomial R} (hmo : q.monic) :\n    «expr /ₘ » (q * p) q = p := by\n  nontriviality R\n  refine' (div_mod_by_monic_unique _ 0 hmo ⟨by rw [zero_add], _⟩).1\n  rw [degree_zero]\n  exact Ne.bot_lt fun h => hmo.ne_zero (degree_eq_bot.1 h)\n#align mul_div_mod_by_monic_cancel_left mul_div_mod_by_monic_cancel_left\n\n",
 "mul_div_by_monic_eq_iff_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem mul_div_by_monic_eq_iff_is_root : (X - C a) * «expr /ₘ » p (X - C a) = p ↔ IsRoot p a :=\n  ⟨fun h => by rw [← h, is_root.def, eval_mul, eval_sub, eval_X, eval_C, sub_self, MulZeroClass.zero_mul],\n    fun h : p.eval a = 0 => by\n    conv =>\n        rhs\n        rw [← mod_by_monic_add_div p (monic_X_sub_C a)] <;>\n      rw [mod_by_monic_X_sub_C_eq_C_eval, h, C_0, zero_add]⟩\n#align mul_div_by_monic_eq_iff_is_root mul_div_by_monic_eq_iff_is_root\n\n",
 "mod_by_monic_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n@[simp]\ntheorem mod_by_monic_zero (p : polynomial R) : «expr %ₘ » p 0 = p :=\n  if h : Monic (0 : polynomial R) then by\n    haveI := monic_zero_iff_subsingleton.mp h\n    simp\n  else by unfold mod_by_monic div_mod_by_monic_aux <;> rw [dif_neg h]\n#align mod_by_monic_zero mod_by_monic_zero\n\n",
 "mod_by_monic_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n@[simp]\ntheorem mod_by_monic_one (p : polynomial R) : «expr %ₘ » p 1 = 0 :=\n  (dvd_iff_modByMonic_eq_zero (by convert monic_one)).2 (one_dvd _)\n#align mod_by_monic_one mod_by_monic_one\n\n",
 "mod_by_monic_eq_sub_mul_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem mod_by_monic_eq_sub_mul_div :\n    ∀ (p : polynomial R) {q : polynomial R} (hq : Monic q), «expr %ₘ » p q = p - q * «expr /ₘ » p q\n  | p => fun q hq =>\n    if h : degree q ≤ degree p ∧ p ≠ 0 then by\n      have wf := div_wf_lemma h hq\n      have ih := mod_by_monic_eq_sub_mul_div (p - C (leadingCoeff p) * X ^ (natDegree p - natDegree q) * q) hq\n      unfold mod_by_monic div_by_monic div_mod_by_monic_aux\n      rw [dif_pos hq, if_pos h]\n      rw [mod_by_monic, dif_pos hq] at ih\n      refine' ih.trans _\n      unfold div_by_monic\n      rw [dif_pos hq, dif_pos hq, if_pos h, mul_add, sub_add_eq_sub_sub, mul_comm]\n    else by\n      unfold mod_by_monic div_by_monic div_mod_by_monic_aux\n      rw [dif_pos hq, if_neg h, dif_pos hq, if_neg h, MulZeroClass.mul_zero, sub_zero]\n#align mod_by_monic_eq_sub_mul_div mod_by_monic_eq_sub_mul_div\n\n",
 "mod_by_monic_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem mod_by_monic_eq_self_iff [Nontrivial R] (hq : Monic q) : «expr %ₘ » p q = p ↔ degree p < degree q :=\n  ⟨fun h => h ▸ degree_modByMonic_lt _ hq, fun h =>\n    by\n    have : ¬degree q ≤ degree p := not_le_of_gt h\n    unfold mod_by_monic div_mod_by_monic_aux <;> rw [dif_pos hq, if_neg (mt And.left this)]⟩\n#align mod_by_monic_eq_self_iff mod_by_monic_eq_self_iff\n\n",
 "mod_by_monic_eq_of_not_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem mod_by_monic_eq_of_not_monic (p : polynomial R) (hq : ¬Monic q) : «expr %ₘ » p q = p :=\n  dif_neg hq\n#align mod_by_monic_eq_of_not_monic mod_by_monic_eq_of_not_monic\n\n",
 "mod_by_monic_add_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem mod_by_monic_add_div (p : polynomial R) {q : polynomial R} (hq : Monic q) :\n    «expr %ₘ » p q + q * «expr /ₘ » p q = p :=\n  eq_sub_iff_add_eq.1 (modByMonic_eq_sub_mul_div p hq)\n#align mod_by_monic_add_div mod_by_monic_add_div\n\n",
 "mod_by_monic_X_sub_C_eq_C_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n@[simp]\ntheorem mod_by_monic_X_sub_C_eq_C_eval (p : polynomial R) (a : R) : «expr %ₘ » p (X - C a) = C (p.eval a) :=\n  by\n  nontriviality R\n  have h : («expr %ₘ » p (X - C a)).eval a = p.eval a := by\n    rw [mod_by_monic_eq_sub_mul_div _ (monic_X_sub_C a), eval_sub, eval_mul, eval_sub, eval_X, eval_C, sub_self,\n      MulZeroClass.zero_mul, sub_zero]\n  have : degree («expr %ₘ » p (X - C a)) < 1 := degree_X_sub_C a ▸ degree_mod_by_monic_lt p (monic_X_sub_C a)\n  have : degree («expr %ₘ » p (X - C a)) ≤ 0 :=\n    by\n    cases degree («expr %ₘ » p (X - C a))\n    · exact bot_le\n    · exact WithBot.some_le_some.2 (nat.le_of_lt_succ (WithBot.some_lt_some.1 this))\n  rw [eq_C_of_degree_le_zero this, eval_C] at h\n  rw [eq_C_of_degree_le_zero this, h]\n#align mod_by_monic_X_sub_C_eq_C_eval mod_by_monic_X_sub_C_eq_C_eval\n\n",
 "mod_by_monic_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem mod_by_monic_X (p : polynomial R) : «expr %ₘ » p X = C (p.eval 0) := by\n  rw [← mod_by_monic_X_sub_C_eq_C_eval, C_0, sub_zero]\n#align mod_by_monic_X mod_by_monic_X\n\n",
 "map_mod_div_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem map_mod_div_by_monic [CommRing S] (f : «expr →+* » R S) (hq : Monic q) :\n    («expr /ₘ » p q).map f = «expr /ₘ » (p.map f) (q.map f) ∧ («expr %ₘ » p q).map f = «expr %ₘ » (p.map f) (q.map f) :=\n  by\n  nontriviality S\n  haveI : Nontrivial R := f.domain_nontrivial\n  have :\n    «expr /ₘ » (map f p) (map f q) = map f («expr /ₘ » p q) ∧ «expr %ₘ » (map f p) (map f q) = map f («expr %ₘ » p q) :=\n    div_mod_by_monic_unique ((«expr /ₘ » p q).map f) _ (hq.map f)\n      ⟨Eq.symm <| by rw [← Polynomial.map_mul, ← Polynomial.map_add, mod_by_monic_add_div _ hq],\n        calc\n          _ ≤ degree («expr %ₘ » p q) := degree_map_le _ _\n          _ < degree q := (degree_mod_by_monic_lt _ hq)\n          _ = _ :=\n            Eq.symm <|\n              degree_map_eq_of_leading_coeff_ne_zero _ (by rw [monic.def.1 hq, f.map_one] <;> exact one_ne_zero)\n          ⟩\n  exact ⟨this.1.symm, this.2.symm⟩\n#align map_mod_div_by_monic map_mod_div_by_monic\n\n",
 "map_mod_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem map_mod_by_monic [CommRing S] (f : «expr →+* » R S) (hq : Monic q) :\n    («expr %ₘ » p q).map f = «expr %ₘ » (p.map f) (q.map f) :=\n  (map_mod_divByMonic f hq).2\n#align map_mod_by_monic map_mod_by_monic\n\n",
 "map_dvd_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_dvd_map [CommRing S] (f : «expr →+* » R S) (hf : function.injective f) {x y : polynomial R} (hx : x.monic) :\n    x.map f ∣ y.map f ↔ x ∣ y :=\n  by\n  rw [← dvd_iff_mod_by_monic_eq_zero hx, ← dvd_iff_mod_by_monic_eq_zero (hx.map f), ← map_mod_by_monic f hx]\n  exact ⟨fun H => map_injective f hf <| by rw [H, Polynomial.map_zero], fun H => by rw [H, Polynomial.map_zero]⟩\n#align map_dvd_map map_dvd_map\n\n",
 "map_div_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem map_div_by_monic [CommRing S] (f : «expr →+* » R S) (hq : Monic q) :\n    («expr /ₘ » p q).map f = «expr /ₘ » (p.map f) (q.map f) :=\n  (map_mod_divByMonic f hq).1\n#align map_div_by_monic map_div_by_monic\n\n",
 "ker_eval_ring_hom":
 "theorem ker_eval_ring_hom (x : R) : (evalRingHom x).ker = Ideal.span {X - C x} :=\n  by\n  ext y\n  simpa only [Ideal.mem_span_singleton, dvd_iff_is_root]\n#align ker_eval_ring_hom ker_eval_ring_hom\n\n",
 "eval₂_mod_by_monic_eq_self_of_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem eval₂_mod_by_monic_eq_self_of_root [CommRing S] {f : «expr →+* » R S} {p q : polynomial R} (hq : q.monic)\n    {x : S} (hx : q.eval₂ f x = 0) : («expr %ₘ » p q).eval₂ f x = p.eval₂ f x := by\n  rw [mod_by_monic_eq_sub_mul_div p hq, eval₂_sub, eval₂_mul, hx, MulZeroClass.zero_mul, sub_zero]\n#align eval₂_mod_by_monic_eq_self_of_root eval₂_mod_by_monic_eq_self_of_root\n\n",
 "eval_div_by_monic_pow_root_multiplicity_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem eval_div_by_monic_pow_root_multiplicity_ne_zero {p : polynomial R} (a : R) (hp : p ≠ 0) :\n    eval a («expr /ₘ » p ((X - C a) ^ rootMultiplicity a p)) ≠ 0 :=\n  by\n  haveI : Nontrivial R := nontrivial.of_polynomial_ne hp\n  rw [ne.def, ← is_root.def, ← dvd_iff_is_root]\n  rintro ⟨q, hq⟩\n  have := div_by_monic_mul_pow_root_multiplicity_eq p a\n  rw [mul_comm, hq, ← mul_assoc, ← pow_succ', root_multiplicity_eq_multiplicity, dif_neg hp] at this\n  exact\n    multiplicity.is_greatest'\n      (multiplicity_finite_of_degree_pos_of_monic\n        (show (0 : WithBot ℕ) < degree (X - C a) by rw [degree_X_sub_C] <;> exact by decide) (monic_X_sub_C _) hp)\n      (nat.lt_succ_self _) (dvd_of_mul_right_eq _ this)\n#align eval_div_by_monic_pow_root_multiplicity_ne_zero eval_div_by_monic_pow_root_multiplicity_ne_zero\n\n",
 "dvd_iff_mod_by_monic_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem dvd_iff_mod_by_monic_eq_zero (hq : Monic q) : «expr %ₘ » p q = 0 ↔ q ∣ p :=\n  ⟨fun h => by rw [← mod_by_monic_add_div p hq, h, zero_add] <;> exact dvd_mul_right _ _, fun h =>\n    by\n    nontriviality R\n    obtain ⟨r, hr⟩ := exists_eq_mul_right_of_dvd h\n    by_contra hpq0\n    have hmod : «expr %ₘ » p q = q * (r - «expr /ₘ » p q) := by rw [mod_by_monic_eq_sub_mul_div _ hq, mul_sub, ← hr]\n    have : degree (q * (r - «expr /ₘ » p q)) < degree q := hmod ▸ degree_mod_by_monic_lt _ hq\n    have hrpq0 : leading_coeff (r - «expr /ₘ » p q) ≠ 0 := fun h =>\n      hpq0 <|\n        leading_coeff_eq_zero.1 (by rw [hmod, leading_coeff_eq_zero.1 h, MulZeroClass.mul_zero, leading_coeff_zero])\n    have hlc : leading_coeff q * leading_coeff (r - «expr /ₘ » p q) ≠ 0 := by rwa [monic.def.1 hq, one_mul]\n    rw [degree_mul' hlc, degree_eq_nat_degree hq.ne_zero, degree_eq_nat_degree (mt leading_coeff_eq_zero.2 hrpq0)] at\n      this\n    exact not_lt_of_ge (nat.le_add_right _ _) (WithBot.some_lt_some.1 this)⟩\n#align dvd_iff_mod_by_monic_eq_zero dvd_iff_mod_by_monic_eq_zero\n\n",
 "dvd_iff_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem dvd_iff_is_root : X - C a ∣ p ↔ IsRoot p a :=\n  ⟨fun h => by\n    rwa [← dvd_iff_mod_by_monic_eq_zero (monic_X_sub_C _), mod_by_monic_X_sub_C_eq_C_eval, ← C_0, C_inj] at h, fun h =>\n    ⟨«expr /ₘ » p (X - C a), by rw [mul_div_by_monic_eq_iff_is_root.2 h]⟩⟩\n#align dvd_iff_is_root dvd_iff_is_root\n\n",
 "div_wf_lemma":
 "theorem div_wf_lemma (h : degree q ≤ degree p ∧ p ≠ 0) (hq : Monic q) :\n    degree (p - C (leadingCoeff p) * X ^ (natDegree p - natDegree q) * q) < degree p :=\n  have hp : leadingCoeff p ≠ 0 := mt leadingCoeff_eq_zero.1 h.2\n  have hq0 : q ≠ 0 := hq.ne_zero_of_polynomial_ne h.2\n  have hlt : natDegree q ≤ natDegree p :=\n    WithBot.coe_le_coe.1 (by rw [← degree_eq_nat_degree h.2, ← degree_eq_nat_degree hq0] <;> exact h.1)\n  degree_sub_lt\n    (by\n      rw [hq.degree_mul, degree_C_mul_X_pow _ hp, degree_eq_nat_degree h.2, degree_eq_nat_degree hq0, ← WithBot.coe_add,\n        tsub_add_cancel_of_le hlt])\n    h.2 (by rw [leading_coeff_mul_monic hq, leading_coeff_mul_X_pow, leading_coeff_C])\n#align div_wf_lemma div_wf_lemma\n\n",
 "div_mod_by_monic_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem div_mod_by_monic_unique {f g} (q r : polynomial R) (hg : Monic g) (h : r + g * q = f ∧ degree r < degree g) :\n    «expr /ₘ » f g = q ∧ «expr %ₘ » f g = r := by\n  nontriviality R\n  have h₁ : r - «expr %ₘ » f g = -g * (q - «expr /ₘ » f g) :=\n    eq_of_sub_eq_zero\n      (by\n        rw [← sub_eq_zero_of_eq (h.1.trans (mod_by_monic_add_div f hg).symm)] <;>\n          simp [mul_add, mul_comm, sub_eq_add_neg, add_comm, add_left_comm, add_assoc])\n  have h₂ : degree (r - «expr %ₘ » f g) = degree (g * (q - «expr /ₘ » f g)) := by simp [h₁]\n  have h₄ : degree (r - «expr %ₘ » f g) < degree g :=\n    calc\n      degree (r - «expr %ₘ » f g) ≤ max (degree r) (degree («expr %ₘ » f g)) := degree_sub_le _ _\n      _ < degree g := max_lt_iff.2 ⟨h.2, degree_mod_by_monic_lt _ hg⟩\n      \n  have h₅ : q - «expr /ₘ » f g = 0 :=\n    by_contradiction fun hqf =>\n      not_le_of_gt h₄ <|\n        calc\n          degree g ≤ degree g + degree (q - «expr /ₘ » f g) := by\n            erw [degree_eq_nat_degree hg.ne_zero, degree_eq_nat_degree hqf, WithBot.coe_le_coe] <;>\n              exact nat.le_add_right _ _\n          _ = degree (r - «expr %ₘ » f g) := by rw [h₂, degree_mul'] <;> simpa [monic.def.1 hg]\n          \n  exact ⟨Eq.symm <| eq_of_sub_eq_zero h₅, Eq.symm <| eq_of_sub_eq_zero <| by simpa [h₅] using h₁⟩\n#align div_mod_by_monic_unique div_mod_by_monic_unique\n\n",
 "div_by_monic_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n@[simp]\ntheorem div_by_monic_zero (p : polynomial R) : «expr /ₘ » p 0 = 0 :=\n  if h : Monic (0 : polynomial R) then by\n    haveI := monic_zero_iff_subsingleton.mp h\n    simp\n  else by unfold div_by_monic div_mod_by_monic_aux <;> rw [dif_neg h]\n#align div_by_monic_zero div_by_monic_zero\n\n",
 "div_by_monic_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n@[simp]\ntheorem div_by_monic_one (p : polynomial R) : «expr /ₘ » p 1 = p := by\n  conv_rhs => rw [← mod_by_monic_add_div p monic_one] <;> simp\n#align div_by_monic_one div_by_monic_one\n\n",
 "div_by_monic_mul_pow_root_multiplicity_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem div_by_monic_mul_pow_root_multiplicity_eq (p : polynomial R) (a : R) :\n    «expr /ₘ » p ((X - C a) ^ rootMultiplicity a p) * (X - C a) ^ rootMultiplicity a p = p :=\n  by\n  have : Monic ((X - C a) ^ rootMultiplicity a p) := (monic_X_sub_C _).pow _\n  conv_rhs =>\n      rw [← mod_by_monic_add_div p this, (dvd_iff_mod_by_monic_eq_zero this).2 (pow_root_multiplicity_dvd _ _)] <;>\n    simp [mul_comm]\n#align div_by_monic_mul_pow_root_multiplicity_eq div_by_monic_mul_pow_root_multiplicity_eq\n\n",
 "div_by_monic_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem div_by_monic_eq_zero_iff [Nontrivial R] (hq : Monic q) : «expr /ₘ » p q = 0 ↔ degree p < degree q :=\n  ⟨fun h => by\n    have := mod_by_monic_add_div p hq <;> rwa [h, MulZeroClass.mul_zero, add_zero, mod_by_monic_eq_self_iff hq] at this,\n    fun h => by\n    have : ¬degree q ≤ degree p := not_le_of_gt h\n    unfold div_by_monic div_mod_by_monic_aux <;> rw [dif_pos hq, if_neg (mt And.left this)]⟩\n#align div_by_monic_eq_zero_iff div_by_monic_eq_zero_iff\n\n",
 "div_by_monic_eq_of_not_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem div_by_monic_eq_of_not_monic (p : polynomial R) (hq : ¬Monic q) : «expr /ₘ » p q = 0 :=\n  dif_neg hq\n#align div_by_monic_eq_of_not_monic div_by_monic_eq_of_not_monic\n\n",
 "degree_mod_by_monic_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem degree_mod_by_monic_lt [Nontrivial R] :\n    ∀ (p : polynomial R) {q : polynomial R} (hq : Monic q), degree («expr %ₘ » p q) < degree q\n  | p => fun q hq =>\n    if h : degree q ≤ degree p ∧ p ≠ 0 then\n      by\n      have wf := div_wf_lemma ⟨h.1, h.2⟩ hq\n      have : degree («expr %ₘ » (p - C (leadingCoeff p) * X ^ (natDegree p - natDegree q) * q) q) < degree q :=\n        degree_mod_by_monic_lt (p - C (leadingCoeff p) * X ^ (natDegree p - natDegree q) * q) hq\n      unfold mod_by_monic at this⊢\n      unfold div_mod_by_monic_aux\n      rw [dif_pos hq] at this⊢\n      rw [if_pos h]\n      exact this\n    else\n      or.cases_on (not_and_or.1 h)\n        (by\n          unfold mod_by_monic div_mod_by_monic_aux\n          rw [dif_pos hq, if_neg h]\n          exact lt_of_not_ge)\n        (by\n          intro hp\n          unfold mod_by_monic div_mod_by_monic_aux\n          rw [dif_pos hq, if_neg h, Classical.not_not.1 hp]\n          exact lt_of_le_of_ne bot_le (ne.symm (mt degree_eq_bot.1 hq.ne_zero)))\n#align degree_mod_by_monic_lt degree_mod_by_monic_lt\n\n",
 "degree_mod_by_monic_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem degree_mod_by_monic_le (p : polynomial R) {q : polynomial R} (hq : Monic q) :\n    degree («expr %ₘ » p q) ≤ degree q := by\n  nontriviality R\n  exact (degree_mod_by_monic_lt _ hq).le\n#align degree_mod_by_monic_le degree_mod_by_monic_le\n\n",
 "degree_div_by_monic_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem degree_div_by_monic_lt (p : polynomial R) {q : polynomial R} (hq : Monic q) (hp0 : p ≠ 0) (h0q : 0 < degree q) :\n    degree («expr /ₘ » p q) < degree p :=\n  if hpq : degree p < degree q then by\n    haveI := nontrivial.of_polynomial_ne hp0\n    rw [(div_by_monic_eq_zero_iff hq).2 hpq, degree_eq_nat_degree hp0]\n    exact WithBot.bot_lt_coe _\n  else by\n    haveI := nontrivial.of_polynomial_ne hp0\n    rw [← degree_add_div_by_monic hq (not_lt.1 hpq), degree_eq_nat_degree hq.ne_zero,\n      degree_eq_nat_degree (mt (div_by_monic_eq_zero_iff hq).1 hpq)]\n    exact WithBot.coe_lt_coe.2 (nat.lt_add_of_pos_left (WithBot.coe_lt_coe.1 <| degree_eq_nat_degree hq.ne_zero ▸ h0q))\n#align degree_div_by_monic_lt degree_div_by_monic_lt\n\n",
 "degree_div_by_monic_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem degree_div_by_monic_le (p q : polynomial R) : degree («expr /ₘ » p q) ≤ degree p :=\n  if hp0 : p = 0 then by simp only [hp0, zero_div_by_monic, le_refl]\n  else\n    if hq : Monic q then\n      if h : degree q ≤ degree p then by\n        haveI := nontrivial.of_polynomial_ne hp0 <;>\n            rw [← degree_add_div_by_monic hq h, degree_eq_nat_degree hq.ne_zero,\n              degree_eq_nat_degree (mt (div_by_monic_eq_zero_iff hq).1 (not_lt.2 h))] <;>\n          exact WithBot.coe_le_coe.2 (nat.le_add_left _ _)\n      else by\n        unfold div_by_monic div_mod_by_monic_aux <;>\n          simp only [dif_pos hq, h, false_and_iff, if_false, degree_zero, bot_le]\n    else (divByMonic_eq_of_not_monic p hq).symm ▸ bot_le\n#align degree_div_by_monic_le degree_div_by_monic_le\n\n",
 "degree_add_div_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem degree_add_div_by_monic (hq : Monic q) (h : degree q ≤ degree p) :\n    degree q + degree («expr /ₘ » p q) = degree p :=\n  by\n  nontriviality R\n  have hdiv0 : «expr /ₘ » p q ≠ 0 := by rwa [(· ≠ ·), div_by_monic_eq_zero_iff hq, not_lt]\n  have hlc : leading_coeff q * leading_coeff («expr /ₘ » p q) ≠ 0 := by\n    rwa [monic.def.1 hq, one_mul, (· ≠ ·), leading_coeff_eq_zero]\n  have hmod : degree («expr %ₘ » p q) < degree (q * «expr /ₘ » p q) :=\n    calc\n      degree («expr %ₘ » p q) < degree q := degree_mod_by_monic_lt _ hq\n      _ ≤ _ := by\n        rw [degree_mul' hlc, degree_eq_nat_degree hq.ne_zero, degree_eq_nat_degree hdiv0, ← WithBot.coe_add,\n            WithBot.coe_le_coe] <;>\n          exact nat.le_add_right _ _\n      \n  calc\n    degree q + degree («expr /ₘ » p q) = degree (q * «expr /ₘ » p q) := Eq.symm (degree_mul' hlc)\n    _ = degree («expr %ₘ » p q + q * «expr /ₘ » p q) := (degree_add_eq_right_of_degree_lt hmod).symm\n    _ = _ := congr_arg _ (mod_by_monic_add_div _ hq)\n    \n#align degree_add_div_by_monic degree_add_div_by_monic\n\n",
 "X_pow_dvd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem X_pow_dvd_iff {f : polynomial R} {n : ℕ} : X ^ n ∣ f ↔ ∀ d < n, f.coeff d = 0 :=\n  ⟨fun ⟨g, hgf⟩ d hd => by simp only [hgf, coeff_X_pow_mul', ite_eq_right_iff, not_le_of_lt hd, IsEmpty.forall_iff],\n    fun hd => by\n    induction' n with n hn\n    · simp only [pow_zero, one_dvd]\n    · obtain ⟨g, hgf⟩ := hn fun d : ℕ => fun H : d < n => hd _ (nat.lt_succ_of_lt H)\n      have := coeff_X_pow_mul g n 0\n      rw [zero_add, ← hgf, hd n (nat.lt_succ_self n)] at this\n      obtain ⟨k, hgk⟩ := polynomial.X_dvd_iff.mpr this.symm\n      use k\n      rwa [pow_succ, mul_comm X _, mul_assoc, ← hgk]⟩\n#align X_pow_dvd_iff X_pow_dvd_iff\n\n",
 "X_dvd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker\n-/\ntheorem X_dvd_iff {f : polynomial R} : X ∣ f ↔ f.coeff 0 = 0 :=\n  ⟨fun ⟨g, hfg⟩ => by rw [hfg, mul_comm, coeff_mul_X_zero], fun hf =>\n    ⟨f.div_X, by rw [mul_comm, ← add_zero (f.div_X * X), ← C_0, ← hf, div_X_mul_X_add]⟩⟩\n#align X_dvd_iff X_dvd_iff\n\n"}