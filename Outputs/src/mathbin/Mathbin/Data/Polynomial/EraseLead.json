{"self_sub_monomial_nat_degree_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem self_sub_monomial_nat_degree_leading_coeff {R : Type _} [Ring R] (f : polynomial R) :\n    f - monomial f.nat_degree f.leading_coeff = f.erase_lead :=\n  (eq_sub_iff_add_eq.mpr (erase_lead_add_monomial_nat_degree_leading_coeff f)).symm\n#align self_sub_monomial_nat_degree_leading_coeff self_sub_monomial_nat_degree_leading_coeff\n\n",
 "self_sub_C_mul_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem self_sub_C_mul_X_pow {R : Type _} [Ring R] (f : polynomial R) :\n    f - C f.leading_coeff * X ^ f.nat_degree = f.erase_lead := by\n  rw [C_mul_X_pow_eq_monomial, self_sub_monomial_nat_degree_leading_coeff]\n#align self_sub_C_mul_X_pow self_sub_C_mul_X_pow\n\n",
 "ne_nat_degree_of_mem_erase_lead_support":
 "theorem ne_nat_degree_of_mem_erase_lead_support {a : ℕ} (h : a ∈ (erase_lead f).support) : a ≠ f.nat_degree :=\n  (lt_nat_degree_of_mem_erase_lead_support h).ne\n#align ne_nat_degree_of_mem_erase_lead_support ne_nat_degree_of_mem_erase_lead_support\n\n",
 "nat_degree_not_mem_erase_lead_support":
 "theorem nat_degree_not_mem_erase_lead_support : f.nat_degree ∉ (erase_lead f).support := fun h =>\n  ne_nat_degree_of_mem_erase_lead_support h rfl\n#align nat_degree_not_mem_erase_lead_support nat_degree_not_mem_erase_lead_support\n\n",
 "mono_map_nat_degree_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Let `φ : R[x] → S[x]` be an additive map, `k : ℕ` a bound, and `fu : ℕ → ℕ` a\n\"sufficiently monotone\" map.  Assume also that\n* `φ` maps to `0` all monomials of degree less than `k`,\n* `φ` maps each monomial `m` in `R[x]` to a polynomial `φ m` of degree `fu (deg m)`.\nThen, `φ` maps each polynomial `p` in `R[x]` to a polynomial of degree `fu (deg p)`. -/\ntheorem mono_map_nat_degree_eq {S F : Type _} [Semiring S] [AddMonoidHomClass F (polynomial R) (polynomial S)] {φ : F}\n    {p : polynomial R} (k : ℕ) (fu : ℕ → ℕ) (fu0 : ∀ {n}, n ≤ k → fu n = 0) (fc : ∀ {n m}, k ≤ n → n < m → fu n < fu m)\n    (φ_k : ∀ {f : polynomial R}, f.nat_degree < k → φ f = 0)\n    (φ_mon_nat : ∀ n c, c ≠ 0 → (φ (monomial n c)).nat_degree = fu n) : (φ p).nat_degree = fu p.nat_degree :=\n  by\n  refine' induction_with_nat_degree_le (fun p => _ = fu _) p.nat_degree (by simp [fu0]) _ _ _ rfl.le\n  · intro n r r0 np\n    rw [nat_degree_C_mul_X_pow _ _ r0, C_mul_X_pow_eq_monomial, φ_mon_nat _ _ r0]\n  · intro f g fg gp fk gk\n    rw [nat_degree_add_eq_right_of_nat_degree_lt fg, _root_.map_add]\n    by_cases FG : k ≤ f.nat_degree\n    · rw [nat_degree_add_eq_right_of_nat_degree_lt, gk]\n      rw [fk, gk]\n      exact fc FG fg\n    · cases k\n      · exact (FG (nat.zero_le _)).elim\n      · rwa [φ_k (not_le.mp FG), zero_add]\n#align mono_map_nat_degree_eq mono_map_nat_degree_eq\n\n",
 "map_nat_degree_eq_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_nat_degree_eq_sub {S F : Type _} [Semiring S] [AddMonoidHomClass F (polynomial R) (polynomial S)] {φ : F}\n    {p : polynomial R} {k : ℕ} (φ_k : ∀ f : polynomial R, f.nat_degree < k → φ f = 0)\n    (φ_mon : ∀ n c, c ≠ 0 → (φ (monomial n c)).nat_degree = n - k) : (φ p).nat_degree = p.nat_degree - k :=\n  mono_map_nat_degree_eq k (fun j => j - k) (by simp) (fun m n h => (tsub_lt_tsub_iff_right h).mpr) φ_k φ_mon\n#align map_nat_degree_eq_sub map_nat_degree_eq_sub\n\n",
 "map_nat_degree_eq_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_nat_degree_eq_nat_degree {S F : Type _} [Semiring S] [AddMonoidHomClass F (polynomial R) (polynomial S)]\n    {φ : F} (p) (φ_mon_nat : ∀ n c, c ≠ 0 → (φ (monomial n c)).nat_degree = n) : (φ p).nat_degree = p.nat_degree :=\n  (map_nat_degree_eq_sub (fun f h => (nat.not_lt_zero _ h).elim) (by simpa)).trans p.nat_degree.sub_zero\n#align map_nat_degree_eq_nat_degree map_nat_degree_eq_nat_degree\n\n",
 "lt_nat_degree_of_mem_erase_lead_support":
 "theorem lt_nat_degree_of_mem_erase_lead_support {a : ℕ} (h : a ∈ (erase_lead f).support) : a < f.nat_degree :=\n  by\n  rw [erase_lead_support, mem_erase] at h\n  exact (le_nat_degree_of_mem_supp a h.2).lt_of_ne h.1\n#align lt_nat_degree_of_mem_erase_lead_support lt_nat_degree_of_mem_erase_lead_support\n\n",
 "induction_with_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. -/\ntheorem induction_with_nat_degree_le (P : polynomial R → Prop) (N : ℕ) (P_0 : P 0)\n    (P_C_mul_pow : ∀ n : ℕ, ∀ r : R, r ≠ 0 → n ≤ N → P (C r * X ^ n))\n    (P_C_add : ∀ f g : polynomial R, f.nat_degree < g.nat_degree → g.nat_degree ≤ N → P f → P g → P (f + g)) :\n    ∀ f : polynomial R, f.nat_degree ≤ N → P f := by\n  intro f df\n  generalize hd : card f.support = c\n  revert f\n  induction' c with c hc\n  · intro f df f0\n    convert P_0\n    simpa only [support_eq_empty, card_eq_zero] using f0\n  · intro f df f0\n    rw [← erase_lead_add_C_mul_X_pow f]\n    cases c\n    · convert P_C_mul_pow f.nat_degree f.leading_coeff _ df\n      · convert zero_add _\n        rw [← card_support_eq_zero, erase_lead_card_support f0]\n      · rw [leading_coeff_ne_zero, ne.def, ← card_support_eq_zero, f0]\n        exact zero_ne_one.symm\n    refine' P_C_add f.erase_lead _ _ _ _ _\n    · refine' (erase_lead_nat_degree_lt _).trans_le (le_of_eq _)\n      · exact (nat.succ_le_succ (nat.succ_le_succ (nat.zero_le _))).trans f0.ge\n      · rw [nat_degree_C_mul_X_pow _ _ (leading_coeff_ne_zero.mpr _)]\n        rintro rfl\n        simpa using f0\n    · exact (nat_degree_C_mul_X_pow_le f.leading_coeff f.nat_degree).trans df\n    · exact hc _ (erase_lead_nat_degree_le_aux.trans df) (erase_lead_card_support f0)\n    · refine' P_C_mul_pow _ _ _ df\n      rw [ne.def, leading_coeff_eq_zero, ← card_support_eq_zero, f0]\n      exact nat.succ_ne_zero _\n#align induction_with_nat_degree_le induction_with_nat_degree_le\n\n",
 "erase_lead_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem erase_lead_zero : erase_lead (0 : polynomial R) = 0 := by simp only [erase_lead, erase_zero]\n#align erase_lead_zero erase_lead_zero\n\n",
 "erase_lead_support_card_lt":
 "theorem erase_lead_support_card_lt (h : f ≠ 0) : (erase_lead f).support.card < f.support.card :=\n  by\n  rw [erase_lead_support]\n  exact card_lt_card (erase_ssubset <| nat_degree_mem_support_of_nonzero h)\n#align erase_lead_support_card_lt erase_lead_support_card_lt\n\n",
 "erase_lead_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\ntheorem erase_lead_support (f : polynomial R) : f.erase_lead.support = f.support.erase f.nat_degree := by\n  simp only [erase_lead, support_erase]\n#align erase_lead_support erase_lead_support\n\n",
 "erase_lead_ne_zero":
 "theorem erase_lead_ne_zero (f0 : 2 ≤ f.support.card) : erase_lead f ≠ 0 :=\n  by\n  rw [ne, ← card_support_eq_zero, erase_lead_support]\n  exact (zero_lt_one.trans_le <| (tsub_le_tsub_right f0 1).trans finset.pred_card_le_card_erase).ne.symm\n#align erase_lead_ne_zero erase_lead_ne_zero\n\n",
 "erase_lead_nat_degree_lt_or_erase_lead_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem erase_lead_nat_degree_lt_or_erase_lead_eq_zero (f : polynomial R) :\n    (erase_lead f).nat_degree < f.nat_degree ∨ f.erase_lead = 0 :=\n  by\n  by_cases h : f.support.card ≤ 1\n  · right\n    rw [← C_mul_X_pow_eq_self h]\n    simp\n  · left\n    apply erase_lead_nat_degree_lt (lt_of_not_ge h)\n#align erase_lead_nat_degree_lt_or_erase_lead_eq_zero erase_lead_nat_degree_lt_or_erase_lead_eq_zero\n\n",
 "erase_lead_nat_degree_lt":
 "theorem erase_lead_nat_degree_lt (f0 : 2 ≤ f.support.card) : (erase_lead f).nat_degree < f.nat_degree :=\n  lt_of_le_of_ne erase_lead_nat_degree_le_aux <|\n    ne_nat_degree_of_mem_erase_lead_support <| nat_degree_mem_support_of_nonzero <| erase_lead_ne_zero f0\n#align erase_lead_nat_degree_lt erase_lead_nat_degree_lt\n\n",
 "erase_lead_nat_degree_le_aux":
 "theorem erase_lead_nat_degree_le_aux : (erase_lead f).nat_degree ≤ f.nat_degree :=\n  nat_degree_le_nat_degree erase_lead_degree_le\n#align erase_lead_nat_degree_le_aux erase_lead_nat_degree_le_aux\n\n",
 "erase_lead_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem erase_lead_nat_degree_le (f : polynomial R) : (erase_lead f).nat_degree ≤ f.nat_degree - 1 :=\n  by\n  rcases f.erase_lead_nat_degree_lt_or_erase_lead_eq_zero with (h | h)\n  · exact Nat.le_pred_of_lt h\n  · simp only [h, nat_degree_zero, zero_le]\n#align erase_lead_nat_degree_le erase_lead_nat_degree_le\n\n",
 "erase_lead_monomial":
 "@[simp]\ntheorem erase_lead_monomial (i : ℕ) (r : R) : erase_lead (monomial i r) = 0 :=\n  by\n  by_cases hr : r = 0\n  · subst r\n    simp only [monomial_zero_right, erase_lead_zero]\n  · rw [erase_lead, nat_degree_monomial, if_neg hr, erase_monomial]\n#align erase_lead_monomial erase_lead_monomial\n\n",
 "erase_lead_degree_le":
 "theorem erase_lead_degree_le : (erase_lead f).degree ≤ f.degree :=\n  f.degree_erase_le _\n#align erase_lead_degree_le erase_lead_degree_le\n\n",
 "erase_lead_coeff_of_ne":
 "theorem erase_lead_coeff_of_ne (i : ℕ) (hi : i ≠ f.nat_degree) : f.erase_lead.coeff i = f.coeff i := by\n  simp [erase_lead_coeff, hi]\n#align erase_lead_coeff_of_ne erase_lead_coeff_of_ne\n\n",
 "erase_lead_coeff_nat_degree":
 "@[simp]\ntheorem erase_lead_coeff_nat_degree : f.erase_lead.coeff f.nat_degree = 0 := by simp [erase_lead_coeff]\n#align erase_lead_coeff_nat_degree erase_lead_coeff_nat_degree\n\n",
 "erase_lead_coeff":
 "theorem erase_lead_coeff (i : ℕ) : f.erase_lead.coeff i = if i = f.nat_degree then 0 else f.coeff i := by\n  simp only [erase_lead, coeff_erase]\n#align erase_lead_coeff erase_lead_coeff\n\n",
 "erase_lead_card_support'":
 "theorem erase_lead_card_support' {c : ℕ} (fc : f.support.card = c + 1) : f.erase_lead.support.card = c :=\n  erase_lead_card_support fc\n#align erase_lead_card_support' erase_lead_card_support'\n\n",
 "erase_lead_card_support":
 "theorem erase_lead_card_support {c : ℕ} (fc : f.support.card = c) : f.erase_lead.support.card = c - 1 :=\n  by\n  by_cases f0 : f = 0\n  · rw [← fc, f0, erase_lead_zero, support_zero, card_empty]\n  · rw [erase_lead_support, card_erase_of_mem (nat_degree_mem_support_of_nonzero f0), fc]\n#align erase_lead_card_support erase_lead_card_support\n\n",
 "erase_lead_add_of_nat_degree_lt_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem erase_lead_add_of_nat_degree_lt_right {p q : polynomial R} (pq : p.nat_degree < q.nat_degree) :\n    (p + q).erase_lead = p + q.erase_lead := by\n  ext n\n  by_cases nd : n = q.nat_degree\n  · rw [nd, erase_lead_coeff, if_pos (nat_degree_add_eq_right_of_nat_degree_lt pq).symm]\n    simpa using (coeff_eq_zero_of_nat_degree_lt pq).symm\n  · rw [erase_lead_coeff, coeff_add, coeff_add, erase_lead_coeff, if_neg, if_neg nd]\n    rintro rfl\n    exact nd (nat_degree_add_eq_right_of_nat_degree_lt pq)\n#align erase_lead_add_of_nat_degree_lt_right erase_lead_add_of_nat_degree_lt_right\n\n",
 "erase_lead_add_of_nat_degree_lt_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem erase_lead_add_of_nat_degree_lt_left {p q : polynomial R} (pq : q.nat_degree < p.nat_degree) :\n    (p + q).erase_lead = p.erase_lead + q := by\n  ext n\n  by_cases nd : n = p.nat_degree\n  · rw [nd, erase_lead_coeff, if_pos (nat_degree_add_eq_left_of_nat_degree_lt pq).symm]\n    simpa using (coeff_eq_zero_of_nat_degree_lt pq).symm\n  · rw [erase_lead_coeff, coeff_add, coeff_add, erase_lead_coeff, if_neg, if_neg nd]\n    rintro rfl\n    exact nd (nat_degree_add_eq_left_of_nat_degree_lt pq)\n#align erase_lead_add_of_nat_degree_lt_left erase_lead_add_of_nat_degree_lt_left\n\n",
 "erase_lead_add_monomial_nat_degree_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem erase_lead_add_monomial_nat_degree_leading_coeff (f : polynomial R) :\n    f.erase_lead + monomial f.nat_degree f.leading_coeff = f :=\n  (add_comm _ _).trans (f.monomial_add_erase _)\n#align erase_lead_add_monomial_nat_degree_leading_coeff erase_lead_add_monomial_nat_degree_leading_coeff\n\n",
 "erase_lead_add_C_mul_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem erase_lead_add_C_mul_X_pow (f : polynomial R) : f.erase_lead + C f.leading_coeff * X ^ f.nat_degree = f := by\n  rw [C_mul_X_pow_eq_monomial, erase_lead_add_monomial_nat_degree_leading_coeff]\n#align erase_lead_add_C_mul_X_pow erase_lead_add_C_mul_X_pow\n\n",
 "erase_lead_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem erase_lead_X_pow (n : ℕ) : erase_lead (X ^ n : polynomial R) = 0 := by\n  rw [X_pow_eq_monomial, erase_lead_monomial]\n#align erase_lead_X_pow erase_lead_X_pow\n\n",
 "erase_lead_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem erase_lead_X : erase_lead (X : polynomial R) = 0 :=\n  erase_lead_monomial _ _\n#align erase_lead_X erase_lead_X\n\n",
 "erase_lead_C_mul_X_pow":
 "@[simp]\ntheorem erase_lead_C_mul_X_pow (r : R) (n : ℕ) : erase_lead (C r * X ^ n) = 0 := by\n  rw [C_mul_X_pow_eq_monomial, erase_lead_monomial]\n#align erase_lead_C_mul_X_pow erase_lead_C_mul_X_pow\n\n",
 "erase_lead_C":
 "@[simp]\ntheorem erase_lead_C (r : R) : erase_lead (C r) = 0 :=\n  erase_lead_monomial _ _\n#align erase_lead_C erase_lead_C\n\n",
 "card_support_eq_two":
 "theorem card_support_eq_two :\n    f.support.card = 2 ↔ ∃ (k m : ℕ)(hkm : k < m)(x y : R)(hx : x ≠ 0)(hy : y ≠ 0), f = C x * X ^ k + C y * X ^ m :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h\n    refine' ⟨k 0, k 1, hk nat.zero_lt_one, x 0, x 1, hx 0, hx 1, _⟩\n    rw [fin.sum_univ_cast_succ, fin.sum_univ_one]\n    rfl\n  · rintro ⟨k, m, hkm, x, y, hx, hy, rfl⟩\n    exact card_support_binomial hkm.ne hx hy\n#align card_support_eq_two card_support_eq_two\n\n",
 "card_support_eq_three":
 "theorem card_support_eq_three :\n    f.support.card = 3 ↔\n      ∃ (k m n : ℕ)(hkm : k < m)(hmn : m < n)(x y z : R)(hx : x ≠ 0)(hy : y ≠ 0)(hz : z ≠ 0),\n        f = C x * X ^ k + C y * X ^ m + C z * X ^ n :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h\n    refine' ⟨k 0, k 1, k 2, hk nat.zero_lt_one, hk (nat.lt_succ_self 1), x 0, x 1, x 2, hx 0, hx 1, hx 2, _⟩\n    rw [fin.sum_univ_cast_succ, fin.sum_univ_cast_succ, fin.sum_univ_one]\n    rfl\n  · rintro ⟨k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl⟩\n    exact card_support_trinomial hkm hmn hx hy hz\n#align card_support_eq_three card_support_eq_three\n\n",
 "card_support_eq_one":
 "theorem card_support_eq_one : f.support.card = 1 ↔ ∃ (k : ℕ)(x : R)(hx : x ≠ 0), f = C x * X ^ k :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h\n    exact ⟨k 0, x 0, hx 0, fin.sum_univ_one _⟩\n  · rintro ⟨k, x, hx, rfl⟩\n    rw [support_C_mul_X_pow k hx, card_singleton]\n#align card_support_eq_one card_support_eq_one\n\n",
 "card_support_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem card_support_eq' {n : ℕ} (k : fin n → ℕ) (x : fin n → R) (hk : function.injective k) (hx : ∀ i, x i ≠ 0) :\n    (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (C (x i) * X ^ k i)).support.card =\n      n :=\n  by\n  suffices\n    (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (C (x i) * X ^ k i)).support =\n      image k univ\n    by rw [this, univ.card_image_of_injective hk, card_fin]\n  simp_rw [Finset.ext_iff, mem_support_iff, finset_sum_coeff, coeff_C_mul_X_pow, mem_image, mem_univ, exists_true_left]\n  refine' fun i => ⟨fun h => _, _⟩\n  · obtain ⟨j, hj, h⟩ := exists_ne_zero_of_sum_ne_zero h\n    exact ⟨j, (ite_ne_right_iff.mp h).1.symm⟩\n  · rintro ⟨j, rfl⟩\n    rw [sum_eq_single_of_mem j (mem_univ j), if_pos rfl]\n    · exact hx j\n    · exact fun m hm hmj => if_neg fun h => hmj.symm (hk h)\n#align card_support_eq' card_support_eq'\n\n",
 "card_support_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem card_support_eq {n : ℕ} :\n    f.support.card = n ↔\n      ∃ (k : fin n → ℕ)(x : fin n → R)(hk : strict_mono k)(hx : ∀ i, x i ≠ 0),\n        f =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (C (x i) * X ^ k i) :=\n  by\n  refine' ⟨_, fun ⟨k, x, hk, hx, hf⟩ => hf.symm ▸ card_support_eq' k x hk.injective hx⟩\n  induction' n with n hn generalizing f\n  · exact fun hf => ⟨0, 0, is_empty_elim, is_empty_elim, card_support_eq_zero.mp hf⟩\n  · intro h\n    obtain ⟨k, x, hk, hx, hf⟩ := hn (erase_lead_card_support' h)\n    have H : ¬∃ k : fin n, k.cast_succ = Fin.last n :=\n      by\n      rintro ⟨i, hi⟩\n      exact i.cast_succ_lt_last.ne hi\n    refine'\n      ⟨function.extend Fin.castSucc k fun _ => f.nat_degree, function.extend Fin.castSucc x fun _ => f.leading_coeff, _,\n        _, _⟩\n    · intro i j hij\n      have hi : i ∈ Set.range (Fin.castSucc : «expr ↪o » (fin n) (fin (n + 1))) :=\n        by\n        rw [Fin.range_castSucc, Set.mem_def]\n        exact lt_of_lt_of_le hij (nat.lt_succ_iff.mp j.2)\n      obtain ⟨i, rfl⟩ := hi\n      rw [fin.cast_succ.injective.extend_apply]\n      by_cases hj : ∃ j₀, Fin.castSucc j₀ = j\n      · obtain ⟨j, rfl⟩ := hj\n        rwa [fin.cast_succ.injective.extend_apply, hk.lt_iff_lt, ← Fin.castSucc_lt_castSucc_iff]\n      · rw [function.extend_apply' _ _ _ hj]\n        apply lt_nat_degree_of_mem_erase_lead_support\n        rw [mem_support_iff, hf, finset_sum_coeff]\n        rw [sum_eq_single, coeff_C_mul, coeff_X_pow_self, mul_one]\n        · exact hx i\n        · intro j hj hji\n          rw [coeff_C_mul, coeff_X_pow, if_neg (hk.injective.ne hji.symm), mul_zero]\n        · exact fun hi => (hi (mem_univ i)).elim\n    · intro i\n      by_cases hi : ∃ i₀, Fin.castSucc i₀ = i\n      · obtain ⟨i, rfl⟩ := hi\n        rw [fin.cast_succ.injective.extend_apply]\n        exact hx i\n      · rw [function.extend_apply' _ _ _ hi, ne, leading_coeff_eq_zero, ← card_support_eq_zero, h]\n        exact n.succ_ne_zero\n    · rw [fin.sum_univ_cast_succ]\n      simp only [fin.cast_succ.injective.extend_apply]\n      rw [← hf, function.extend_apply', function.extend_apply', erase_lead_add_C_mul_X_pow]\n      all_goals exact H\n#align card_support_eq card_support_eq\n\n"}