{"nat_trailing_degree_mul_mirror":
 "theorem nat_trailing_degree_mul_mirror : (p * p.mirror).nat_trailing_degree = 2 * p.nat_trailing_degree :=\n  by\n  by_cases hp : p = 0\n  · rw [hp, zero_mul, nat_trailing_degree_zero, mul_zero]\n  rw [nat_trailing_degree_mul hp (mt mirror_eq_zero.mp hp), mirror_nat_trailing_degree, two_mul]\n#align nat_trailing_degree_mul_mirror nat_trailing_degree_mul_mirror\n\n",
 "nat_degree_mul_mirror":
 "theorem nat_degree_mul_mirror : (p * p.mirror).nat_degree = 2 * p.nat_degree :=\n  by\n  by_cases hp : p = 0\n  · rw [hp, zero_mul, nat_degree_zero, mul_zero]\n  rw [nat_degree_mul hp (mt mirror_eq_zero.mp hp), mirror_nat_degree, two_mul]\n#align nat_degree_mul_mirror nat_degree_mul_mirror\n\n",
 "mirror_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\n@[simp]\ntheorem mirror_zero : (0 : polynomial R).mirror = 0 := by simp [mirror]\n#align mirror_zero mirror_zero\n\n",
 "mirror_trailing_coeff":
 "@[simp]\ntheorem mirror_trailing_coeff : p.mirror.trailing_coeff = p.leading_coeff := by\n  rw [leading_coeff, trailing_coeff, mirror_nat_trailing_degree, coeff_mirror, rev_at_le (nat.le_add_left _ _),\n    add_tsub_cancel_right]\n#align mirror_trailing_coeff mirror_trailing_coeff\n\n",
 "mirror_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mirror_smul (a : R) : («expr • » a p).mirror = «expr • » a p.mirror := by\n  rw [← C_mul', ← C_mul', mirror_mul_of_domain, mirror_C]\n#align mirror_smul mirror_smul\n\n",
 "mirror_neg":
 "theorem mirror_neg : (-p).mirror = -p.mirror := by\n  rw [mirror, mirror, reverse_neg, nat_trailing_degree_neg, neg_mul_eq_neg_mul]\n#align mirror_neg mirror_neg\n\n",
 "mirror_nat_trailing_degree":
 "theorem mirror_nat_trailing_degree : p.mirror.nat_trailing_degree = p.nat_trailing_degree :=\n  by\n  by_cases hp : p = 0\n  · rw [hp, mirror_zero]\n  · rw [mirror, nat_trailing_degree_mul_X_pow ((mt reverse_eq_zero.mp) hp), reverse_nat_trailing_degree, zero_add]\n#align mirror_nat_trailing_degree mirror_nat_trailing_degree\n\n",
 "mirror_nat_degree":
 "theorem mirror_nat_degree : p.mirror.nat_degree = p.nat_degree :=\n  by\n  by_cases hp : p = 0\n  · rw [hp, mirror_zero]\n  nontriviality R\n  rw [mirror, nat_degree_mul', reverse_nat_degree, nat_degree_X_pow,\n    tsub_add_cancel_of_le p.nat_trailing_degree_le_nat_degree]\n  rwa [leading_coeff_X_pow, mul_one, reverse_leading_coeff, ne, trailing_coeff_eq_zero]\n#align mirror_nat_degree mirror_nat_degree\n\n",
 "mirror_mul_of_domain":
 "theorem mirror_mul_of_domain : (p * q).mirror = p.mirror * q.mirror :=\n  by\n  by_cases hp : p = 0\n  · rw [hp, zero_mul, mirror_zero, zero_mul]\n  by_cases hq : q = 0\n  · rw [hq, mul_zero, mirror_zero, mul_zero]\n  rw [mirror, mirror, mirror, reverse_mul_of_domain, nat_trailing_degree_mul hp hq, pow_add]\n  rw [mul_assoc, ← mul_assoc q.reverse]\n  conv_lhs =>\n    congr\n    skip\n    congr\n    rw [← X_pow_mul]\n  repeat' rw [mul_assoc]\n#align mirror_mul_of_domain mirror_mul_of_domain\n\n",
 "mirror_monomial":
 "theorem mirror_monomial (n : ℕ) (a : R) : (monomial n a).mirror = monomial n a := by\n  classical\n    by_cases ha : a = 0\n    · rw [ha, monomial_zero_right, mirror_zero]\n    ·\n      rw [mirror, reverse, nat_degree_monomial n a, if_neg ha, nat_trailing_degree_monomial ha, ←\n        C_mul_X_pow_eq_monomial, reflect_C_mul_X_pow, rev_at_le (le_refl n), tsub_self, pow_zero, mul_one]\n#align mirror_monomial mirror_monomial\n\n",
 "mirror_mirror":
 "theorem mirror_mirror : p.mirror.mirror = p :=\n  polynomial.ext fun n => by\n    rw [coeff_mirror, coeff_mirror, mirror_nat_degree, mirror_nat_trailing_degree, rev_at_invol]\n#align mirror_mirror mirror_mirror\n\n",
 "mirror_leading_coeff":
 "@[simp]\ntheorem mirror_leading_coeff : p.mirror.leading_coeff = p.trailing_coeff := by\n  rw [← p.mirror_mirror, mirror_trailing_coeff, p.mirror_mirror]\n#align mirror_leading_coeff mirror_leading_coeff\n\n",
 "mirror_involutive":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mirror_involutive : function.involutive (mirror : polynomial R → polynomial R) :=\n  mirror_mirror\n#align mirror_involutive mirror_involutive\n\n",
 "mirror_inj":
 "@[simp]\ntheorem mirror_inj : p.mirror = q.mirror ↔ p = q :=\n  mirror_involutive.injective.eq_iff\n#align mirror_inj mirror_inj\n\n",
 "mirror_eval_one":
 "--TODO: Extract `finset.sum_range_rev_at` lemma.\ntheorem mirror_eval_one : p.mirror.eval 1 = p.eval 1 :=\n  by\n  simp_rw [eval_eq_sum_range, one_pow, mul_one, mirror_nat_degree]\n  refine' finset.sum_bij_ne_zero _ _ _ _ _\n  · exact fun n hn hp => rev_at (p.nat_degree + p.nat_trailing_degree) n\n  · intro n hn hp\n    rw [Finset.mem_range_succ_iff] at *\n    rw [rev_at_le (hn.trans (nat.le_add_right _ _))]\n    rw [tsub_le_iff_tsub_le, add_comm, add_tsub_cancel_right, ← mirror_nat_trailing_degree]\n    exact nat_trailing_degree_le_of_ne_zero hp\n  · exact fun n₁ n₂ hn₁ hp₁ hn₂ hp₂ h => by rw [← @rev_at_invol _ n₁, h, rev_at_invol]\n  · intro n hn hp\n    use rev_at (p.nat_degree + p.nat_trailing_degree) n\n    refine' ⟨_, _, rev_at_invol.symm⟩\n    · rw [Finset.mem_range_succ_iff] at *\n      rw [rev_at_le (hn.trans (nat.le_add_right _ _))]\n      rw [tsub_le_iff_tsub_le, add_comm, add_tsub_cancel_right]\n      exact nat_trailing_degree_le_of_ne_zero hp\n    · change p.mirror.coeff _ ≠ 0\n      rwa [coeff_mirror, rev_at_invol]\n  · exact fun n hn hp => p.coeff_mirror n\n#align mirror_eval_one mirror_eval_one\n\n",
 "mirror_eq_zero":
 "@[simp]\ntheorem mirror_eq_zero : p.mirror = 0 ↔ p = 0 :=\n  ⟨fun h => by rw [← p.mirror_mirror, h, mirror_zero], fun h => by rw [h, mirror_zero]⟩\n#align mirror_eq_zero mirror_eq_zero\n\n",
 "mirror_eq_iff":
 "theorem mirror_eq_iff : p.mirror = q ↔ p = q.mirror :=\n  mirror_involutive.eq_iff\n#align mirror_eq_iff mirror_eq_iff\n\n",
 "mirror_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mirror_X : X.mirror = (X : polynomial R) :=\n  mirror_monomial 1 (1 : R)\n#align mirror_X mirror_X\n\n",
 "mirror_C":
 "theorem mirror_C (a : R) : (C a).mirror = C a :=\n  mirror_monomial 0 a\n#align mirror_C mirror_C\n\n",
 "irreducible_of_mirror":
 "theorem irreducible_of_mirror (h1 : ¬is_unit f)\n    (h2 : ∀ k, f * f.mirror = k * k.mirror → k = f ∨ k = -f ∨ k = f.mirror ∨ k = -f.mirror)\n    (h3 : ∀ g, g ∣ f → g ∣ f.mirror → is_unit g) : Irreducible f :=\n  by\n  constructor\n  · exact h1\n  · intro g h fgh\n    let k := g * h.mirror\n    have key : f * f.mirror = k * k.mirror := by\n      rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror,\n        mul_assoc, ← mul_assoc]\n    have g_dvd_f : g ∣ f := by\n      rw [fgh]\n      exact dvd_mul_right g h\n    have h_dvd_f : h ∣ f := by\n      rw [fgh]\n      exact dvd_mul_left h g\n    have g_dvd_k : g ∣ k := dvd_mul_right g h.mirror\n    have h_dvd_k_rev : h ∣ k.mirror := by\n      rw [mirror_mul_of_domain, mirror_mirror]\n      exact dvd_mul_left h g.mirror\n    have hk := h2 k key\n    rcases hk with (hk | hk | hk | hk)\n    · exact or.inr (h3 h h_dvd_f (by rwa [← hk]))\n    · exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg]))\n    · exact or.inl (h3 g g_dvd_f (by rwa [← hk]))\n    · exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg]))\n#align irreducible_of_mirror irreducible_of_mirror\n\n",
 "coeff_mul_mirror":
 "theorem coeff_mul_mirror : (p * p.mirror).coeff (p.nat_degree + p.nat_trailing_degree) = p.sum fun n => (· ^ 2) :=\n  by\n  rw [coeff_mul, finset.nat.sum_antidiagonal_eq_sum_range_succ_mk]\n  refine'\n    (finset.sum_congr rfl fun n hn => _).trans\n      (p.sum_eq_of_subset (fun n => (· ^ 2)) (fun n => zero_pow zero_lt_two) _ fun n hn =>\n          finset.mem_range_succ_iff.mpr ((le_nat_degree_of_mem_supp n hn).trans (nat.le_add_right _ _))).symm\n  rw [coeff_mirror, ← rev_at_le (finset.mem_range_succ_iff.mp hn), rev_at_invol, ← sq]\n#align coeff_mul_mirror coeff_mul_mirror\n\n",
 "coeff_mirror":
 "theorem coeff_mirror (n : ℕ) : p.mirror.coeff n = p.coeff (rev_at (p.nat_degree + p.nat_trailing_degree) n) :=\n  by\n  by_cases h2 : p.nat_degree < n\n  · rw [coeff_eq_zero_of_nat_degree_lt (by rwa [mirror_nat_degree])]\n    by_cases h1 : n ≤ p.nat_degree + p.nat_trailing_degree\n    · rw [rev_at_le h1, coeff_eq_zero_of_lt_nat_trailing_degree]\n      exact (tsub_lt_iff_left h1).mpr (nat.add_lt_add_right h2 _)\n    · rw [← rev_at_fun_eq, rev_at_fun, if_neg h1, coeff_eq_zero_of_nat_degree_lt h2]\n  rw [not_lt] at h2\n  rw [rev_at_le (h2.trans (nat.le_add_right _ _))]\n  by_cases h3 : p.nat_trailing_degree ≤ n\n  ·\n    rw [← tsub_add_eq_add_tsub h2, ← tsub_tsub_assoc h2 h3, mirror, coeff_mul_X_pow', if_pos h3, coeff_reverse,\n      rev_at_le (tsub_le_self.trans h2)]\n  rw [not_le] at h3\n  rw [coeff_eq_zero_of_nat_degree_lt (lt_tsub_iff_right.mpr (nat.add_lt_add_left h3 _))]\n  exact coeff_eq_zero_of_lt_nat_trailing_degree (by rwa [mirror_nat_trailing_degree])\n#align coeff_mirror coeff_mirror\n\n"}