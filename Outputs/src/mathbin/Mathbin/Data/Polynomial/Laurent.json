{"trunc_to_laurent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem _root_.polynomial.trunc_to_laurent (f : polynomial R) : trunc f.to_laurent = f :=\n  left_inverse_trunc_to_laurent _\n#align polynomial.trunc_to_laurent polynomial.trunc_to_laurent\n\n",
 "trunc_C_mul_T":
 "@[simp]\ntheorem trunc_C_mul_T (n : ℤ) (r : R) : trunc (C r * T n) = ite (0 ≤ n) (monomial n.to_nat r) 0 :=\n  by\n  apply (to_finsupp_iso R).injective\n  rw [← single_eq_C_mul_T, trunc, AddMonoidHom.coe_comp, Function.comp_apply, comap_domain.add_monoid_hom_apply,\n    to_finsupp_iso_apply]\n  by_cases n0 : 0 ≤ n\n  · lift n to ℕ using n0\n    erw [comap_domain_single, to_finsupp_iso_symm_apply]\n    simp only [int.coe_nat_nonneg, Int.toNat_coe_nat, if_true, to_finsupp_iso_apply, to_finsupp_monomial]\n  · lift -n to ℕ using (neg_pos.mpr (not_le.mp n0)).le with m\n    rw [to_finsupp_iso_apply, to_finsupp_inj, if_neg n0]\n    erw [to_finsupp_iso_symm_apply]\n    ext a\n    have := ((not_le.mp n0).trans_le (Int.ofNat_zero_le a)).ne'\n    simp only [coeff, comap_domain_apply, Int.ofNat_eq_coe, coeff_zero, single_apply_eq_zero, this, is_empty.forall_iff]\n#align trunc_C_mul_T trunc_C_mul_T\n\n",
 "to_laurent_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The support of a polynomial `f` is a finset in `ℕ`.  The lemma `to_laurent_support f`\nshows that the support of `f.to_laurent` is the same finset, but viewed in `ℤ` under the natural\ninclusion `ℕ ↪ ℤ`. -/\ntheorem to_laurent_support (f : polynomial R) : f.to_laurent.support = f.support.map Nat.castEmbedding :=\n  by\n  generalize hd : f.support = s\n  revert f\n  refine' Finset.induction_on s _ _ <;> clear s\n  ·\n    simp (config := { contextual := true }) only [polynomial.support_eq_empty, map_zero, finsupp.support_zero,\n      eq_self_iff_true, imp_true_iff, Finset.map_empty]\n  · intro a s as hf f fs\n    have : (erase a f).to_laurent.support = s.map Nat.castEmbedding :=\n      hf (f.erase a)\n        (by simp only [fs, Finset.erase_eq_of_not_mem as, polynomial.support_erase, Finset.erase_insert_eq_erase])\n    rw [← monomial_add_erase f a, Finset.map_insert, ← this, map_add, polynomial.to_laurent_C_mul_T, support_add_eq,\n      Finset.insert_eq]\n    · congr\n      exact support_C_mul_T_of_ne_zero (polynomial.mem_support_iff.mp (by simp [fs])) _\n    · rw [this]\n      exact Disjoint.mono_left (support_C_mul_T _ _) (by simpa)\n#align to_laurent_support to_laurent_support\n\n",
 "to_laurent_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem _root_.polynomial.to_laurent_one : (polynomial.to_laurent : polynomial R → «expr [T;T⁻¹]» R) 1 = 1 :=\n  map_one polynomial.to_laurent\n#align polynomial.to_laurent_one polynomial.to_laurent_one\n\n",
 "to_laurent_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem _root_.polynomial.to_laurent_ne_zero {f : polynomial R} : f ≠ 0 ↔ f.to_laurent ≠ 0 :=\n  (map_ne_zero_iff _ polynomial.to_laurent_injective).symm\n#align polynomial.to_laurent_ne_zero polynomial.to_laurent_ne_zero\n\n",
 "to_laurent_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem _root_.polynomial.to_laurent_injective :\n    function.injective (polynomial.to_laurent : polynomial R → «expr [T;T⁻¹]» R) :=\n  left_inverse_trunc_to_laurent.injective\n#align polynomial.to_laurent_injective polynomial.to_laurent_injective\n\n",
 "to_laurent_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem _root_.polynomial.to_laurent_inj (f g : polynomial R) : f.to_laurent = g.to_laurent ↔ f = g :=\n  ⟨fun h => polynomial.to_laurent_injective h, congr_arg _⟩\n#align polynomial.to_laurent_inj polynomial.to_laurent_inj\n\n",
 "to_laurent_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2022 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\n/-- This is not a simp lemma, as it is usually preferable to use the lemmas about `C` and `X`\ninstead. -/\ntheorem polynomial.to_laurent_apply [Semiring R] (p : polynomial R) : p.to_laurent = p.to_finsupp.map_domain coe :=\n  rfl\n#align polynomial.to_laurent_apply polynomial.to_laurent_apply\n\n",
 "to_laurent_alg_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem polynomial.to_laurent_alg_apply [CommSemiring R] (f : polynomial R) : f.to_laurent_alg = f.to_laurent :=\n  rfl\n#align polynomial.to_laurent_alg_apply polynomial.to_laurent_alg_apply\n\n",
 "to_laurent_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem _root_.polynomial.to_laurent_X_pow (n : ℕ) : (X ^ n : polynomial R).to_laurent = T n := by\n  simp only [map_pow, polynomial.to_laurent_X, T_pow, mul_one]\n#align polynomial.to_laurent_X_pow polynomial.to_laurent_X_pow\n\n",
 "to_laurent_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem _root_.polynomial.to_laurent_X : (polynomial.X.to_laurent : «expr [T;T⁻¹]» R) = T 1 :=\n  by\n  have : (polynomial.X : polynomial R) = monomial 1 1 := by simp [← C_mul_X_pow_eq_monomial]\n  simp [this, polynomial.to_laurent_C_mul_T]\n#align polynomial.to_laurent_X polynomial.to_laurent_X\n\n",
 "to_laurent_C_mul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem _root_.polynomial.to_laurent_C_mul_eq (r : R) (f : polynomial R) :\n    (polynomial.C r * f).to_laurent = C r * f.to_laurent := by simp only [_root_.map_mul, polynomial.to_laurent_C]\n#align polynomial.to_laurent_C_mul_eq polynomial.to_laurent_C_mul_eq\n\n",
 "to_laurent_C_mul_X_pow":
 "@[simp]\ntheorem _root_.polynomial.to_laurent_C_mul_X_pow (n : ℕ) (r : R) : (polynomial.C r * X ^ n).to_laurent = C r * T n := by\n  simp only [_root_.map_mul, polynomial.to_laurent_C, polynomial.to_laurent_X_pow]\n#align polynomial.to_laurent_C_mul_X_pow polynomial.to_laurent_C_mul_X_pow\n\n",
 "to_laurent_C_mul_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n-- This lemma locks in the right changes and is what Lean proved directly.\n-- The actual `simp`-normal form of a Laurent monomial is `C a * T n`, whenever it can be reached.\n@[simp]\ntheorem _root_.polynomial.to_laurent_C_mul_T (n : ℕ) (r : R) :\n    ((polynomial.monomial n r).to_laurent : «expr [T;T⁻¹]» R) = C r * T n :=\n  show map_domain coe (monomial n r).to_finsupp = (C r * T n : «expr [T;T⁻¹]» R) by\n    rw [to_finsupp_monomial, map_domain_single, single_eq_C_mul_T]\n#align polynomial.to_laurent_C_mul_T polynomial.to_laurent_C_mul_T\n\n",
 "to_laurent_C":
 "@[simp]\ntheorem _root_.polynomial.to_laurent_C (r : R) : (polynomial.C r).to_laurent = C r :=\n  by\n  convert polynomial.to_laurent_C_mul_T 0 r\n  simp only [Int.ofNat_zero, T_zero, mul_one]\n#align polynomial.to_laurent_C polynomial.to_laurent_C\n\n",
 "support_C_mul_T_of_ne_zero":
 "theorem support_C_mul_T_of_ne_zero {a : R} (a0 : a ≠ 0) (n : ℤ) : (C a * T n).support = {n} :=\n  by\n  rw [← single_eq_C_mul_T]\n  exact support_single_ne_zero _ a0\n#align support_C_mul_T_of_ne_zero support_C_mul_T_of_ne_zero\n\n",
 "support_C_mul_T":
 "theorem support_C_mul_T (a : R) (n : ℤ) : (C a * T n).support ⊆ {n} := by\n  simpa only [← single_eq_C_mul_T] using support_single_subset\n#align support_C_mul_T support_C_mul_T\n\n",
 "single_zero_one_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem single_zero_one_eq_one : (single 0 1 : «expr [T;T⁻¹]» R) = (1 : «expr [T;T⁻¹]» R) :=\n  rfl\n#align single_zero_one_eq_one single_zero_one_eq_one\n\n",
 "single_eq_C_mul_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem single_eq_C_mul_T (r : R) (n : ℤ) : (single n r : «expr [T;T⁻¹]» R) = (C r * T n : «expr [T;T⁻¹]» R) := by\n  convert single_mul_single.symm <;> simp\n#align single_eq_C_mul_T single_eq_C_mul_T\n\n",
 "single_eq_C":
 "theorem single_eq_C (r : R) : single 0 r = C r :=\n  rfl\n#align single_eq_C single_eq_C\n\n",
 "reduce_to_polynomial_of_mul_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Suppose that `Q` is a statement about Laurent polynomials such that\n* `Q` is true on *ordinary* polynomials;\n* `Q (f * T)` implies `Q f`;\nit follow that `Q` is true on all Laurent polynomials. -/\ntheorem reduce_to_polynomial_of_mul_T (f : «expr [T;T⁻¹]» R) {Q : «expr [T;T⁻¹]» R → Prop}\n    (Qf : ∀ f : polynomial R, Q f.to_laurent) (QT : ∀ f, Q (f * T 1) → Q f) : Q f :=\n  by\n  induction' f using laurent_polynomial.induction_on_mul_T with f n\n  induction' n with n hn\n  · simpa only [Int.ofNat_zero, neg_zero, T_zero, mul_one] using Qf _\n  · convert QT _ _\n    simpa using hn\n#align reduce_to_polynomial_of_mul_T reduce_to_polynomial_of_mul_T\n\n",
 "mul_T_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/-- The `simp` version of `mul_assoc`, in the presence of `T`'s. -/\n@[simp]\ntheorem mul_T_assoc (f : «expr [T;T⁻¹]» R) (m n : ℤ) : f * T m * T n = f * T (m + n) := by simp [← T_add, mul_assoc]\n#align mul_T_assoc mul_T_assoc\n\n",
 "left_inverse_trunc_to_laurent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem left_inverse_trunc_to_laurent :\n    function.left_inverse (trunc : «expr [T;T⁻¹]» R → polynomial R) polynomial.to_laurent :=\n  by\n  refine' fun f => f.induction_on' _ _\n  · exact fun f g hf hg => by simp only [hf, hg, _root_.map_add]\n  ·\n    exact fun n r => by\n      simp only [polynomial.to_laurent_C_mul_T, trunc_C_mul_T, int.coe_nat_nonneg, Int.toNat_coe_nat, if_true]\n#align left_inverse_trunc_to_laurent left_inverse_trunc_to_laurent\n\n",
 "is_unit_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem is_unit_T (n : ℤ) : is_unit (T n : «expr [T;T⁻¹]» R) :=\n  isUnit_of_invertible _\n#align is_unit_T is_unit_T\n\n",
 "is_localization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem is_localization : is_localization (Submonoid.closure ({X} : set (polynomial R))) («expr [T;T⁻¹]» R) :=\n  { map_units := fun t => by\n      cases' t with t ht\n      rcases submonoid.mem_closure_singleton.mp ht with ⟨n, rfl⟩\n      simp only [is_unit_T n, [anonymous], algebra_map_eq_to_laurent, polynomial.to_laurent_X_pow]\n    surj := fun f => by\n      induction' f using laurent_polynomial.induction_on_mul_T with f n\n      have := (Submonoid.closure ({X} : set (polynomial R))).pow_mem submonoid.mem_closure_singleton_self n\n      refine' ⟨(f, ⟨_, this⟩), _⟩\n      simp only [[anonymous], algebra_map_eq_to_laurent, polynomial.to_laurent_X_pow, mul_T_assoc, add_left_neg, T_zero,\n        mul_one]\n    eq_iff_exists := fun f g =>\n      by\n      rw [algebra_map_eq_to_laurent, algebra_map_eq_to_laurent, polynomial.to_laurent_inj]\n      refine' ⟨_, _⟩\n      · rintro rfl\n        exact ⟨1, rfl⟩\n      · rintro ⟨⟨h, hX⟩, h⟩\n        rcases submonoid.mem_closure_singleton.mp hX with ⟨n, rfl⟩\n        exact mul_X_pow_injective n (by simpa only [X_pow_mul] using h) }\n#align is_localization is_localization\n\n",
 "inv_of_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem inv_of_T (n : ℤ) : («expr⅟») (T n : «expr [T;T⁻¹]» R) = T (-n) :=\n  rfl\n#align inv_of_T inv_of_T\n\n",
 "induction_on_mul_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- This is a version of `exists_T_pow` stated as an induction principle. -/\n@[elab_as_elim]\ntheorem induction_on_mul_T {Q : «expr [T;T⁻¹]» R → Prop} (f : «expr [T;T⁻¹]» R)\n    (Qf : ∀ {f : polynomial R} {n : ℕ}, Q (f.to_laurent * T (-n))) : Q f :=\n  by\n  rcases f.exists_T_pow with ⟨n, f', hf⟩\n  rw [← mul_one f, ← T_zero, ← Nat.cast_zero, ← nat.sub_self n, Nat.cast_sub rfl.le, T_sub, ← mul_assoc, ← hf]\n  exact Qf\n#align induction_on_mul_T induction_on_mul_T\n\n",
 "induction_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/-- To prove something about Laurent polynomials, it suffices to show that\n* the condition is closed under taking sums, and\n* it holds for monomials.\n-/\n@[elab_as_elim]\nprotected theorem induction_on' {M : «expr [T;T⁻¹]» R → Prop} (p : «expr [T;T⁻¹]» R)\n    (h_add : ∀ p q, M p → M q → M (p + q)) (h_C_mul_T : ∀ (n : ℤ) (a : R), M (C a * T n)) : M p :=\n  by\n  refine' p.induction_on (fun a => _) h_add _ _ <;> try exact fun n f _ => h_C_mul_T _ f\n  convert h_C_mul_T 0 a\n  exact (mul_one _).symm\n#align induction_on' induction_on'\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[elab_as_elim]\nprotected theorem induction_on {M : «expr [T;T⁻¹]» R → Prop} (p : «expr [T;T⁻¹]» R) (h_C : ∀ a, M (C a))\n    (h_add : ∀ {p q}, M p → M q → M (p + q)) (h_C_mul_T : ∀ (n : ℕ) (a : R), M (C a * T n) → M (C a * T (n + 1)))\n    (h_C_mul_T_Z : ∀ (n : ℕ) (a : R), M (C a * T (-n)) → M (C a * T (-n - 1))) : M p :=\n  by\n  have A : ∀ {n : ℤ} {a : R}, M (C a * T n) := by\n    intro n a\n    apply n.induction_on\n    · simpa only [T_zero, mul_one] using h_C a\n    · exact fun m => h_C_mul_T m a\n    · exact fun m => h_C_mul_T_Z m a\n  have B : ∀ s : Finset ℤ, M (s.sum fun n : ℤ => C (p.to_fun n) * T n) :=\n    by\n    apply Finset.induction\n    · convert h_C 0\n      simp only [finset.sum_empty, _root_.map_zero]\n    · intro n s ns ih\n      rw [finset.sum_insert ns]\n      exact h_add A ih\n  convert B p.support\n  ext a\n  simp_rw [← single_eq_C_mul_T, finset.sum_apply', single_apply, finset.sum_ite_eq']\n  split_ifs with h h\n  · rfl\n  · exact finsupp.not_mem_support_iff.mp h\n#align induction_on induction_on\n\n",
 "exists_T_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_T_pow (f : «expr [T;T⁻¹]» R) : ∃ (n : ℕ)(f' : polynomial R), f'.to_laurent = f * T n :=\n  by\n  apply f.induction_on' _ fun n a => _ <;> clear f\n  · rintro f g ⟨m, fn, hf⟩ ⟨n, gn, hg⟩\n    refine' ⟨m + n, fn * X ^ n + gn * X ^ m, _⟩\n    simp only [hf, hg, add_mul, add_comm (n : ℤ), map_add, map_mul, polynomial.to_laurent_X_pow, mul_T_assoc,\n      Int.ofNat_add]\n  · cases' n with n n\n    · exact ⟨0, polynomial.C a * X ^ n, by simp⟩\n    · refine' ⟨n + 1, polynomial.C a, _⟩\n      simp only [Int.negSucc_eq, polynomial.to_laurent_C, Int.ofNat_succ, mul_T_assoc, add_left_neg, T_zero, mul_one]\n#align exists_T_pow exists_T_pow\n\n",
 "degree_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem degree_zero : degree (0 : «expr [T;T⁻¹]» R) = «expr⊥» :=\n  rfl\n#align degree_zero degree_zero\n\n",
 "degree_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem degree_eq_bot_iff {f : «expr [T;T⁻¹]» R} : f.degree = «expr⊥» ↔ f = 0 :=\n  by\n  refine' ⟨fun h => _, fun h => by rw [h, degree_zero]⟩\n  rw [degree, finset.max_eq_sup_with_bot] at h\n  ext n\n  refine' not_not.mp fun f0 => _\n  simp_rw [finset.sup_eq_bot_iff, finsupp.mem_support_iff, ne.def, WithBot.coe_ne_bot] at h\n  exact h n f0\n#align degree_eq_bot_iff degree_eq_bot_iff\n\n",
 "degree_T_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem degree_T_le (n : ℤ) : (T n : «expr [T;T⁻¹]» R).degree ≤ n :=\n  (le_of_eq (by rw [map_one, one_mul])).trans (degree_C_mul_T_le n (1 : R))\n#align degree_T_le degree_T_le\n\n",
 "degree_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem degree_T [nontrivial R] (n : ℤ) : (T n : «expr [T;T⁻¹]» R).degree = n :=\n  by\n  rw [← one_mul (T n), ← map_one C]\n  exact degree_C_mul_T n 1 (one_ne_zero : (1 : R) ≠ 0)\n#align degree_T degree_T\n\n",
 "degree_C_mul_T_le":
 "theorem degree_C_mul_T_le (n : ℤ) (a : R) : (C a * T n).degree ≤ n :=\n  by\n  by_cases a0 : a = 0\n  · simp only [a0, map_zero, zero_mul, degree_zero, bot_le]\n  · exact (degree_C_mul_T n a a0).le\n#align degree_C_mul_T_le degree_C_mul_T_le\n\n",
 "degree_C_mul_T_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem degree_C_mul_T_ite (n : ℤ) (a : R) : (C a * T n).degree = ite (a = 0) («expr⊥») n := by\n  split_ifs with h h <;> simp only [h, map_zero, zero_mul, degree_zero, degree_C_mul_T, ne.def, not_false_iff]\n#align degree_C_mul_T_ite degree_C_mul_T_ite\n\n",
 "degree_C_mul_T":
 "@[simp]\ntheorem degree_C_mul_T (n : ℤ) (a : R) (a0 : a ≠ 0) : (C a * T n).degree = n :=\n  by\n  rw [degree]\n  convert finset.max_singleton\n  refine' support_eq_singleton.mpr _\n  simp only [← single_eq_C_mul_T, single_eq_same, a0, ne.def, not_false_iff, eq_self_iff_true, and_self_iff]\n#align degree_C_mul_T degree_C_mul_T\n\n",
 "degree_C_le":
 "theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=\n  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)\n#align degree_C_le degree_C_le\n\n",
 "degree_C_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem degree_C_ite (a : R) : (C a).degree = ite (a = 0) («expr⊥») 0 := by\n  split_ifs with h h <;> simp only [h, map_zero, degree_zero, degree_C, ne.def, not_false_iff]\n#align degree_C_ite degree_C_ite\n\n",
 "degree_C":
 "theorem degree_C {a : R} (a0 : a ≠ 0) : (C a).degree = 0 :=\n  by\n  rw [← mul_one (C a), ← T_zero]\n  exact degree_C_mul_T 0 a a0\n#align degree_C degree_C\n\n",
 "commute_T":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem commute_T (n : ℤ) (f : «expr [T;T⁻¹]» R) : Commute (T n) f :=\n  f.induction_on' (fun p q Tp Tq => Commute.add_right Tp Tq) fun m a =>\n    show T n * _ = _ by\n      rw [T, T, ← single_eq_C, single_mul_single, single_mul_single, single_mul_single]\n      simp [add_comm]\n#align commute_T commute_T\n\n",
 "algebra_map_eq_to_laurent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem algebra_map_eq_to_laurent (f : polynomial R) : algebra_map (polynomial R) («expr [T;T⁻¹]» R) f = f.to_laurent :=\n  rfl\n#align algebra_map_eq_to_laurent algebra_map_eq_to_laurent\n\n",
 "algebra_map_apply":
 "theorem algebra_map_apply {R A : Type _} [CommSemiring R] [Semiring A] [algebra R A] (r : R) :\n    algebra_map R (laurent_polynomial A) r = C (algebra_map R A r) :=\n  rfl\n#align algebra_map_apply algebra_map_apply\n\n",
 "algebra_map_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem algebra_map_X_pow (n : ℕ) : algebra_map (polynomial R) («expr [T;T⁻¹]» R) (X ^ n) = T n :=\n  polynomial.to_laurent_X_pow n\n#align algebra_map_X_pow algebra_map_X_pow\n\n",
 "T_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem T_zero : (T 0 : «expr [T;T⁻¹]» R) = 1 :=\n  rfl\n#align T_zero T_zero\n\n",
 "T_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem T_sub (m n : ℤ) : (T (m - n) : «expr [T;T⁻¹]» R) = T m * T (-n) := by rw [← T_add, sub_eq_add_neg]\n#align T_sub T_sub\n\n",
 "T_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem T_pow (m : ℤ) (n : ℕ) : (T m ^ n : «expr [T;T⁻¹]» R) = T (n * m) := by\n  rw [T, T, single_pow n, one_pow, nsmul_eq_mul]\n#align T_pow T_pow\n\n",
 "T_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n@[simp]\ntheorem T_mul (n : ℤ) (f : «expr [T;T⁻¹]» R) : T n * f = f * T n :=\n  (commute_T n f).eq\n#align T_mul T_mul\n\n",
 "T_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\ntheorem T_add (m n : ℤ) : (T (m + n) : «expr [T;T⁻¹]» R) = T m * T n :=\n  by\n  convert single_mul_single.symm\n  simp [T]\n#align T_add T_add\n\n",
 "C_eq_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr [T;T⁻¹]» -/\n/-- When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[T;T⁻¹]`.\n(But note that `C` is defined when `R` is not necessarily commutative, in which case\n`algebra_map` is not available.)\n-/\ntheorem C_eq_algebra_map {R : Type _} [CommSemiring R] (r : R) : C r = algebra_map R («expr [T;T⁻¹]» R) r :=\n  rfl\n#align C_eq_algebra_map C_eq_algebra_map\n\n"}