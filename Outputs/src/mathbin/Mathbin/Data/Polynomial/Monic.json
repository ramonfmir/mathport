{"sub_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.sub_of_right {p q : polynomial R} (hq : q.leading_coeff = -1) (hpq : degree p < degree q) :\n    Monic (p - q) :=\n  by\n  have : (-q).coeff (-q).nat_degree = 1 := by\n    rw [nat_degree_neg, coeff_neg, show q.coeff q.nat_degree = -1 from hq, neg_neg]\n  rw [sub_eq_add_neg]\n  apply monic.add_of_right this\n  rwa [degree_neg]\n#align monic.sub_of_right monic.sub_of_right\n\n",
 "sub_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.sub_of_left {p q : polynomial R} (hp : Monic p) (hpq : degree q < degree p) : Monic (p - q) :=\n  by\n  rw [sub_eq_add_neg]\n  apply hp.add_of_left\n  rwa [degree_neg]\n#align monic.sub_of_left monic.sub_of_left\n\n",
 "pow":
 "theorem monic.pow (hp : Monic p) : ∀ n : ℕ, Monic (p ^ n)\n  | 0 => monic_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact hp.mul (monic.pow n)\n#align monic.pow monic.pow\n\n",
 "of_mul_monic_right":
 "theorem monic.of_mul_monic_right (hq : q.monic) (hpq : (p * q).monic) : p.monic :=\n  by\n  contrapose! hpq\n  rw [monic.def] at hpq⊢\n  rwa [leading_coeff_mul_monic hq]\n#align monic.of_mul_monic_right monic.of_mul_monic_right\n\n",
 "of_mul_monic_left":
 "theorem monic.of_mul_monic_left (hp : p.monic) (hpq : (p * q).monic) : q.monic :=\n  by\n  contrapose! hpq\n  rw [monic.def] at hpq⊢\n  rwa [leading_coeff_monic_mul hp]\n#align monic.of_mul_monic_left monic.of_mul_monic_left\n\n",
 "not_monic_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_monic_zero_iff : ¬Monic (0 : polynomial R) ↔ (0 : R) ≠ 1 :=\n  (monic_zero_iff_subsingleton.trans subsingleton_iff_zero_eq_one.symm).not\n#align not_monic_zero_iff not_monic_zero_iff\n\n",
 "not_monic_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem not_monic_zero : ¬Monic (0 : polynomial R) :=\n  not_monic_zero_iff.mp zero_ne_one\n#align not_monic_zero not_monic_zero\n\n",
 "not_is_unit_X_pow_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_is_unit_X_pow_sub_one (R : Type _) [CommRing R] [Nontrivial R] (n : ℕ) :\n    ¬IsUnit (X ^ n - 1 : polynomial R) := by\n  intro h\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simpa using h\n  apply hn\n  rw [← @nat_degree_one R, ← (monic_X_pow_sub_C _ hn).eq_one_of_is_unit h, nat_degree_X_pow_sub_C]\n#align not_is_unit_X_pow_sub_one not_is_unit_X_pow_sub_one\n\n",
 "not_dvd_of_nat_degree_lt":
 "theorem not_dvd_of_nat_degree_lt (hp : Monic p) (h0 : q ≠ 0) (hl : natDegree q < natDegree p) : ¬p ∣ q :=\n  by\n  rintro ⟨r, rfl⟩\n  rw [hp.nat_degree_mul' <| right_ne_zero_of_mul h0] at hl\n  exact hl.not_le (nat.le_add_right _ _)\n#align not_dvd_of_nat_degree_lt not_dvd_of_nat_degree_lt\n\n",
 "not_dvd_of_degree_lt":
 "theorem not_dvd_of_degree_lt (hp : Monic p) (h0 : q ≠ 0) (hl : degree q < degree p) : ¬p ∣ q :=\n  Monic.not_dvd_of_natDegree_lt hp h0 <| natDegree_lt_natDegree h0 hl\n#align not_dvd_of_degree_lt not_dvd_of_degree_lt\n\n",
 "next_coeff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem monic.next_coeff_prod (s : Finset ι) (f : ι → polynomial R) (h : ∀ i ∈ s, Monic (f i)) :\n    nextCoeff\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (nextCoeff (f i)) :=\n  Monic.nextCoeff_multiset_prod s.1 f h\n#align monic.next_coeff_prod monic.next_coeff_prod\n\n",
 "next_coeff_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.next_coeff_multiset_prod (t : Multiset ι) (f : ι → polynomial R) (h : ∀ i ∈ t, Monic (f i)) :\n    nextCoeff (t.map f).prod = (t.map fun i => nextCoeff (f i)).sum :=\n  by\n  revert h\n  refine' Multiset.induction_on t _ fun a t ih ht => _\n  · simp only [Multiset.not_mem_zero, forall_prop_of_true, forall_prop_of_false, Multiset.map_zero, Multiset.prod_zero,\n      Multiset.sum_zero, not_false_iff, forall_true_iff]\n    rw [← C_1]\n    rw [next_coeff_C_eq_zero]\n  · rw [Multiset.map_cons, Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons, monic.next_coeff_mul, ih]\n    exacts[fun i hi => ht i (Multiset.mem_cons_of_mem hi), ht a (Multiset.mem_cons_self _ _),\n      monic_multiset_prod_of_monic _ _ fun b bs => ht _ (Multiset.mem_cons_of_mem bs)]\n#align monic.next_coeff_multiset_prod monic.next_coeff_multiset_prod\n\n",
 "next_coeff_mul":
 "theorem next_coeff_mul (hp : Monic p) (hq : Monic q) : nextCoeff (p * q) = nextCoeff p + nextCoeff q :=\n  by\n  nontriviality\n  simp only [← coeff_one_reverse]\n  rw [reverse_mul] <;> simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]\n#align next_coeff_mul next_coeff_mul\n\n",
 "next_coeff_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem next_coeff_map (p : polynomial R) : (p.map f).next_coeff = f p.next_coeff :=\n  by\n  unfold next_coeff\n  rw [nat_degree_map_eq_of_injective hf]\n  split_ifs <;> simp\n#align next_coeff_map next_coeff_map\n\n",
 "ne_zero_of_ne_zero_of_monic":
 "theorem ne_zero_of_ne_zero_of_monic (hp : p ≠ 0) (hq : Monic q) : q ≠ 0 :=\n  by\n  rintro rfl\n  rw [monic.def, leading_coeff_zero] at hq\n  rw [← mul_one p, ← C_1, ← hq, C_0, MulZeroClass.mul_zero] at hp\n  exact hp rfl\n#align ne_zero_of_ne_zero_of_monic ne_zero_of_ne_zero_of_monic\n\n",
 "nat_degree_smul_of_smul_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem nat_degree_smul_of_smul_regular {S : Type _} [Monoid S] [DistribMulAction S R] {k : S} (p : polynomial R)\n    (h : IsSMulRegular R k) : («expr • » k p).nat_degree = p.nat_degree :=\n  by\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [← WithBot.coe_eq_coe, ← degree_eq_nat_degree hp, ← degree_eq_nat_degree, degree_smul_of_smul_regular p h]\n  contrapose! hp\n  rw [← smul_zero k] at hp\n  exact h.polynomial hp\n#align nat_degree_smul_of_smul_regular nat_degree_smul_of_smul_regular\n\n",
 "nat_degree_pow_X_add_C":
 "@[simp]\ntheorem nat_degree_pow_X_add_C [Nontrivial R] (n : ℕ) (r : R) : ((X + C r) ^ n).nat_degree = n := by\n  rw [(monic_X_add_C r).nat_degree_pow, nat_degree_X_add_C, mul_one]\n#align nat_degree_pow_X_add_C nat_degree_pow_X_add_C\n\n",
 "nat_degree_pow":
 "theorem nat_degree_pow (hp : p.monic) (n : ℕ) : (p ^ n).nat_degree = n * p.nat_degree :=\n  by\n  induction' n with n hn\n  · simp\n  · rw [pow_succ, hp.nat_degree_mul (hp.pow n), hn]\n    ring\n#align nat_degree_pow nat_degree_pow\n\n",
 "nat_degree_mul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_mul_comm (hp : p.monic) (q : polynomial R) : (p * q).nat_degree = (q * p).nat_degree :=\n  by\n  by_cases h : q = 0\n  · simp [h]\n  rw [hp.nat_degree_mul' h, Polynomial.natDegree_mul', add_comm]\n  simpa [hp.leading_coeff, leading_coeff_ne_zero]\n#align nat_degree_mul_comm nat_degree_mul_comm\n\n",
 "nat_degree_mul'":
 "theorem nat_degree_mul' (hp : p.monic) (hq : q ≠ 0) : (p * q).nat_degree = p.nat_degree + q.nat_degree :=\n  by\n  rw [nat_degree_mul', add_comm]\n  simpa [hp.leading_coeff, leading_coeff_ne_zero]\n#align nat_degree_mul' nat_degree_mul'\n\n",
 "nat_degree_mul":
 "theorem nat_degree_mul (hp : p.monic) (hq : q.monic) : (p * q).nat_degree = p.nat_degree + q.nat_degree :=\n  by\n  nontriviality R\n  apply nat_degree_mul'\n  simp [hp.leading_coeff, hq.leading_coeff]\n#align nat_degree_mul nat_degree_mul\n\n",
 "nat_degree_map_eq_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_map_eq_of_injective (p : polynomial R) : natDegree (p.map f) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_map_eq_of_injective hf p)\n#align nat_degree_map_eq_of_injective nat_degree_map_eq_of_injective\n\n",
 "nat_degree_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem monic.nat_degree_map [Semiring S] [Nontrivial S] {P : polynomial R} (hmo : P.monic) (f : «expr →+* » R S) :\n    (P.map f).nat_degree = P.nat_degree :=\n  by\n  refine' le_antisymm (nat_degree_map_le _ _) (le_nat_degree_of_ne_zero _)\n  rw [coeff_map, monic.coeff_nat_degree hmo, RingHom.map_one]\n  exact one_ne_zero\n#align monic.nat_degree_map monic.nat_degree_map\n\n",
 "nat_degree_eq_zero_iff_eq_one":
 "@[simp]\ntheorem nat_degree_eq_zero_iff_eq_one (hp : p.monic) : p.nat_degree = 0 ↔ p = 1 :=\n  by\n  constructor <;> intro h\n  swap\n  · rw [h]\n    exact nat_degree_one\n  have : p = C (p.coeff 0) := by\n    rw [← Polynomial.degree_le_zero_iff]\n    rwa [Polynomial.natDegree_eq_zero_iff_degree_le_zero] at h\n  rw [this]\n  convert C_1\n  rw [← h]\n  apply hp\n#align nat_degree_eq_zero_iff_eq_one nat_degree_eq_zero_iff_eq_one\n\n",
 "mul_right_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.mul_right_ne_zero (hp : Monic p) {q : polynomial R} (hq : q ≠ 0) : p * q ≠ 0 :=\n  by\n  by_cases h : p = 1\n  · simpa [h]\n  rw [ne.def, ← degree_eq_bot, hp.degree_mul_comm, hp.degree_mul, WithBot.add_eq_bot, not_or, degree_eq_bot]\n  refine' ⟨hq, _⟩\n  rw [← hp.degree_le_zero_iff_eq_one, not_le] at h\n  refine' (lt_trans _ h).ne'\n  simp\n#align monic.mul_right_ne_zero monic.mul_right_ne_zero\n\n",
 "mul_right_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.mul_right_eq_zero_iff (h : Monic p) {q : polynomial R} : p * q = 0 ↔ q = 0 := by\n  by_cases hq : q = 0 <;> simp [h.mul_right_ne_zero, hq]\n#align monic.mul_right_eq_zero_iff monic.mul_right_eq_zero_iff\n\n",
 "mul_nat_degree_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.mul_nat_degree_lt_iff (h : Monic p) {q : polynomial R} :\n    (p * q).nat_degree < p.nat_degree ↔ p ≠ 1 ∧ q = 0 :=\n  by\n  by_cases hq : q = 0\n  · suffices 0 < p.nat_degree ↔ p.nat_degree ≠ 0 by simpa [hq, ← h.nat_degree_eq_zero_iff_eq_one]\n    exact ⟨fun h => h.ne', fun h => lt_of_le_of_ne (nat.zero_le _) h.symm⟩\n  · simp [h.nat_degree_mul', hq]\n#align monic.mul_nat_degree_lt_iff monic.mul_nat_degree_lt_iff\n\n",
 "mul_left_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- TODO: using gh-8537, rephrase lemmas that involve commutation around `*` using the op-ring\ntheorem monic.mul_left_ne_zero (hp : Monic p) {q : polynomial R} (hq : q ≠ 0) : q * p ≠ 0 :=\n  by\n  by_cases h : p = 1\n  · simpa [h]\n  rw [ne.def, ← degree_eq_bot, hp.degree_mul, WithBot.add_eq_bot, not_or, degree_eq_bot]\n  refine' ⟨hq, _⟩\n  rw [← hp.degree_le_zero_iff_eq_one, not_le] at h\n  refine' (lt_trans _ h).ne'\n  simp\n#align monic.mul_left_ne_zero monic.mul_left_ne_zero\n\n",
 "mul_left_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.mul_left_eq_zero_iff (h : Monic p) {q : polynomial R} : q * p = 0 ↔ q = 0 := by\n  by_cases hq : q = 0 <;> simp [h.mul_left_ne_zero, hq]\n#align monic.mul_left_eq_zero_iff monic.mul_left_eq_zero_iff\n\n",
 "mul":
 "theorem monic.mul (hp : Monic p) (hq : Monic q) : Monic (p * q) :=\n  if h0 : (0 : R) = 1 then\n    haveI := subsingleton_of_zero_eq_one h0\n    subsingleton.elim _ _\n  else by\n    have : leadingCoeff p * leadingCoeff q ≠ 0 := by simp [monic.def.1 hp, monic.def.1 hq, ne.symm h0]\n    rw [monic.def, leading_coeff_mul' this, monic.def.1 hp, monic.def.1 hq, one_mul]\n#align monic.mul monic.mul\n\n",
 "monic_zero_iff_subsingleton'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_zero_iff_subsingleton' : Monic (0 : polynomial R) ↔ (∀ f g : polynomial R, f = g) ∧ ∀ a b : R, a = b :=\n  Polynomial.monic_zero_iff_subsingleton.trans\n    ⟨by\n      intro\n      simp, fun h => subsingleton_iff.mpr h.2⟩\n#align monic_zero_iff_subsingleton' monic_zero_iff_subsingleton'\n\n",
 "monic_zero_iff_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker\n-/\ntheorem monic_zero_iff_subsingleton : Monic (0 : polynomial R) ↔ subsingleton R :=\n  subsingleton_iff_zero_eq_one\n#align monic_zero_iff_subsingleton monic_zero_iff_subsingleton\n\n",
 "monic_prod_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem monic_prod_of_monic (s : Finset ι) (f : ι → polynomial R) (hs : ∀ i ∈ s, Monic (f i)) :\n    Monic (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) :=\n  monic_multiset_prod_of_monic s.1 f hs\n#align monic_prod_of_monic monic_prod_of_monic\n\n",
 "monic_of_is_unit_leading_coeff_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem monic_of_is_unit_leading_coeff_inv_smul (h : IsUnit p.leading_coeff) : Monic («expr • » h.unit⁻¹ p) :=\n  by\n  rw [monic.def, leading_coeff_smul_of_smul_regular _ (isSMulRegular_of_group _), Units.smul_def]\n  obtain ⟨k, hk⟩ := h\n  simp only [← hk, smul_eq_mul, ← Units.val_mul, Units.val_eq_one, inv_mul_eq_iff_eq_mul]\n  simp [Units.ext_iff, IsUnit.unit_spec]\n#align monic_of_is_unit_leading_coeff_inv_smul monic_of_is_unit_leading_coeff_inv_smul\n\n",
 "monic_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_of_injective {p : polynomial R} (hp : (p.map f).monic) : p.monic :=\n  by\n  apply hf\n  rw [← leading_coeff_of_injective hf, hp.leading_coeff, f.map_one]\n#align monic_of_injective monic_of_injective\n\n",
 "monic_of_degree_le":
 "theorem monic_of_degree_le (n : ℕ) (H1 : degree p ≤ n) (H2 : coeff p n = 1) : Monic p :=\n  decidable.by_cases (fun H : degree p < n => eq_of_zero_eq_one (H2 ▸ (coeff_eq_zero_of_degree_lt H).symm) _ _)\n    fun H : ¬degree p < n => by rwa [monic, leading_coeff, nat_degree, (lt_or_eq_of_le H1).resolve_left H]\n#align monic_of_degree_le monic_of_degree_le\n\n",
 "monic_multiset_prod_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_multiset_prod_of_monic (t : Multiset ι) (f : ι → polynomial R) (ht : ∀ i ∈ t, Monic (f i)) :\n    Monic (t.map f).prod := by\n  revert ht\n  refine' t.induction_on _ _; · simp\n  intro a t ih ht\n  rw [Multiset.map_cons, Multiset.prod_cons]\n  exact (ht _ (Multiset.mem_cons_self _ _)).mul (ih fun _ hi => ht _ (Multiset.mem_cons_of_mem hi))\n#align monic_multiset_prod_of_monic monic_multiset_prod_of_monic\n\n",
 "monic_mul_C_of_leading_coeff_mul_eq_one":
 "theorem monic_mul_C_of_leading_coeff_mul_eq_one {b : R} (hp : p.leading_coeff * b = 1) : Monic (p * C b) :=\n  by\n  nontriviality\n  rw [monic, leading_coeff_mul' _] <;> simp [leading_coeff_C b, hp]\n#align monic_mul_C_of_leading_coeff_mul_eq_one monic_mul_C_of_leading_coeff_mul_eq_one\n\n",
 "monic_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Function.Injective.monic_map_iff /-\ntheorem Function.Injective.monic_map_iff {p : polynomial R} : p.monic ↔ (p.map f).monic :=\n  ⟨Monic.map _, Polynomial.monic_of_injective hf⟩\n#align function.injective.monic_map_iff Function.Injective.monic_map_iff\n-/\n\n",
 "monic_X_sub_C":
 "theorem monic_X_sub_C (x : R) : Monic (X - C x) := by simpa only [sub_eq_add_neg, C_neg] using monic_X_add_C (-x)\n#align monic_X_sub_C monic_X_sub_C\n\n",
 "monic_X_pow_sub_C":
 "/-- `X ^ n - a` is monic. -/\ntheorem monic_X_pow_sub_C {R : Type u} [Ring R] (a : R) {n : ℕ} (h : n ≠ 0) : (X ^ n - C a).monic :=\n  by\n  obtain ⟨k, hk⟩ := nat.exists_eq_succ_of_ne_zero h\n  convert monic_X_pow_sub _\n  exact le_trans degree_C_le Nat.WithBot.coe_nonneg\n#align monic_X_pow_sub_C monic_X_pow_sub_C\n\n",
 "monic_X_pow_sub":
 "theorem monic_X_pow_sub {n : ℕ} (H : degree p ≤ n) : Monic (X ^ (n + 1) - p) := by\n  simpa [sub_eq_add_neg] using monic_X_pow_add (show degree (-p) ≤ n by rwa [← degree_neg p] at H)\n#align monic_X_pow_sub monic_X_pow_sub\n\n",
 "monic_X_pow_add":
 "theorem monic_X_pow_add {n : ℕ} (H : degree p ≤ n) : Monic (X ^ (n + 1) + p) :=\n  have H1 : degree p < n + 1 := lt_of_le_of_lt H (WithBot.coe_lt_coe.2 (nat.lt_succ_self n))\n  monic_of_degree_le (n + 1) (le_trans (degree_add_le _ _) (max_le (degree_X_pow_le _) (le_of_lt H1)))\n    (by rw [coeff_add, coeff_X_pow, if_pos rfl, coeff_eq_zero_of_degree_lt H1, add_zero])\n#align monic_X_pow_add monic_X_pow_add\n\n",
 "monic_X_add_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_X_add_C (x : R) : Monic (X + C x) :=\n  pow_one (X : polynomial R) ▸ monic_X_pow_add degree_C_le\n#align monic_X_add_C monic_X_add_C\n\n",
 "monic_C_mul_of_mul_leading_coeff_eq_one":
 "theorem monic_C_mul_of_mul_leading_coeff_eq_one {b : R} (hp : b * p.leading_coeff = 1) : Monic (C b * p) :=\n  by\n  nontriviality\n  rw [monic, leading_coeff_mul' _] <;> simp [leading_coeff_C b, hp]\n#align monic_C_mul_of_mul_leading_coeff_eq_one monic_C_mul_of_mul_leading_coeff_eq_one\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem monic.map [Semiring S] (f : «expr →+* » R S) (hp : Monic p) : Monic (p.map f) :=\n  by\n  nontriviality\n  have : f (leading_coeff p) ≠ 0 := by\n    rw [show _ = _ from hp, f.map_one]\n    exact one_ne_zero\n  rw [monic, leading_coeff, coeff_map]\n  suffices p.coeff (map f p).nat_degree = 1 by simp [this]\n  rwa [nat_degree_eq_of_degree_eq (degree_map_eq_of_leading_coeff_ne_zero f this)]\n#align monic.map monic.map\n\n",
 "leading_coeff_smul_of_smul_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem leading_coeff_smul_of_smul_regular {S : Type _} [Monoid S] [DistribMulAction S R] {k : S} (p : polynomial R)\n    (h : IsSMulRegular R k) : («expr • » k p).leading_coeff = «expr • » k p.leading_coeff := by\n  rw [leading_coeff, leading_coeff, coeff_smul, nat_degree_smul_of_smul_regular p h]\n#align leading_coeff_smul_of_smul_regular leading_coeff_smul_of_smul_regular\n\n",
 "leading_coeff_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem leading_coeff_of_injective (p : polynomial R) : leadingCoeff (p.map f) = f (leadingCoeff p) :=\n  by\n  delta leading_coeff\n  rw [coeff_map f, nat_degree_map_eq_of_injective hf p]\n#align leading_coeff_of_injective leading_coeff_of_injective\n\n",
 "leading_coeff_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem leading_coeff_map' (p : polynomial R) : leadingCoeff (p.map f) = f (leadingCoeff p) :=\n  by\n  unfold leading_coeff\n  rw [coeff_map, nat_degree_map_eq_of_injective hf p]\n#align leading_coeff_map' leading_coeff_map'\n\n",
 "is_unit_leading_coeff_mul_right_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_unit_leading_coeff_mul_right_eq_zero_iff (h : IsUnit p.leading_coeff) {q : polynomial R} :\n    p * q = 0 ↔ q = 0 := by\n  constructor\n  · intro hp\n    rw [← smul_eq_zero_iff_eq h.unit⁻¹] at hp\n    have : «expr • » h.unit⁻¹ (p * q) = «expr • » h.unit⁻¹ p * q :=\n      by\n      ext\n      simp only [Units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum]\n      refine' sum_congr rfl fun x hx => _\n      rw [← mul_assoc]\n    rwa [this, monic.mul_right_eq_zero_iff] at hp\n    exact monic_of_is_unit_leading_coeff_inv_smul _\n  · rintro rfl\n    simp\n#align is_unit_leading_coeff_mul_right_eq_zero_iff is_unit_leading_coeff_mul_right_eq_zero_iff\n\n",
 "is_unit_leading_coeff_mul_left_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_unit_leading_coeff_mul_left_eq_zero_iff (h : IsUnit p.leading_coeff) {q : polynomial R} :\n    q * p = 0 ↔ q = 0 := by\n  constructor\n  · intro hp\n    replace hp := congr_arg (· * C ↑h.unit⁻¹) hp\n    simp only [MulZeroClass.zero_mul] at hp\n    rwa [mul_assoc, monic.mul_left_eq_zero_iff] at hp\n    refine' monic_mul_C_of_leading_coeff_mul_eq_one _\n    simp [Units.mul_inv_eq_iff_eq_mul, IsUnit.unit_spec]\n  · rintro rfl\n    rw [MulZeroClass.zero_mul]\n#align is_unit_leading_coeff_mul_left_eq_zero_iff is_unit_leading_coeff_mul_left_eq_zero_iff\n\n",
 "is_unit_iff":
 "theorem monic.is_unit_iff (hm : p.monic) : IsUnit p ↔ p = 1 :=\n  ⟨hm.eq_one_of_is_unit, fun h => h.symm ▸ isUnit_one⟩\n#align monic.is_unit_iff monic.is_unit_iff\n\n",
 "is_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.is_regular {R : Type _} [Ring R] {p : polynomial R} (hp : Monic p) : IsRegular p :=\n  by\n  constructor\n  · intro q r h\n    rw [← sub_eq_zero, ← hp.mul_right_eq_zero_iff, mul_sub, h, sub_self]\n  · intro q r h\n    simp only at h\n    rw [← sub_eq_zero, ← hp.mul_left_eq_zero_iff, sub_mul, h, sub_self]\n#align monic.is_regular monic.is_regular\n\n",
 "eq_one_of_map_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_one_of_map_eq_one {S : Type _} [Semiring S] [Nontrivial S] (f : «expr →+* » R S) (hp : p.monic)\n    (map_eq : p.map f = 1) : p = 1 := by\n  nontriviality R\n  have hdeg : p.degree = 0 :=\n    by\n    rw [← degree_map_eq_of_leading_coeff_ne_zero f _, map_eq, degree_one]\n    · rw [hp.leading_coeff, f.map_one]\n      exact one_ne_zero\n  have hndeg : p.nat_degree = 0 := with_bot.coe_eq_coe.mp ((degree_eq_nat_degree hp.ne_zero).symm.trans hdeg)\n  convert eq_C_of_degree_eq_zero hdeg\n  rw [← hndeg, ← Polynomial.leadingCoeff, hp.leading_coeff, C.map_one]\n#align eq_one_of_map_eq_one eq_one_of_map_eq_one\n\n",
 "eq_one_of_is_unit":
 "theorem monic.eq_one_of_is_unit (hm : Monic p) (hpu : IsUnit p) : p = 1 :=\n  by\n  nontriviality R\n  obtain ⟨q, h⟩ := hpu.exists_right_inv\n  have := hm.nat_degree_mul' (right_ne_zero_of_mul_eq_one h)\n  rw [h, nat_degree_one, eq_comm, add_eq_zero_iff] at this\n  exact hm.nat_degree_eq_zero_iff_eq_one.mp this.1\n#align monic.eq_one_of_is_unit monic.eq_one_of_is_unit\n\n",
 "degree_smul_of_smul_regular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem degree_smul_of_smul_regular {S : Type _} [Monoid S] [DistribMulAction S R] {k : S} (p : polynomial R)\n    (h : IsSMulRegular R k) : («expr • » k p).degree = p.degree :=\n  by\n  refine' le_antisymm _ _\n  · rw [degree_le_iff_coeff_zero]\n    intro m hm\n    rw [degree_lt_iff_coeff_zero] at hm\n    simp [hm m le_rfl]\n  · rw [degree_le_iff_coeff_zero]\n    intro m hm\n    rw [degree_lt_iff_coeff_zero] at hm\n    refine' h _\n    simpa using hm m le_rfl\n#align degree_smul_of_smul_regular degree_smul_of_smul_regular\n\n",
 "degree_mul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_mul_comm (hp : p.monic) (q : polynomial R) : (p * q).degree = (q * p).degree :=\n  by\n  by_cases h : q = 0\n  · simp [h]\n  rw [degree_mul', hp.degree_mul]\n  · exact add_comm _ _\n  · rwa [hp.leading_coeff, one_mul, leading_coeff_ne_zero]\n#align degree_mul_comm degree_mul_comm\n\n",
 "degree_map_eq_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_map_eq_of_injective (p : polynomial R) : degree (p.map f) = degree p :=\n  if h : p = 0 then by simp [h]\n  else\n    degree_map_eq_of_leadingCoeff_ne_zero _\n      (by rw [← f.map_zero] <;> exact mt hf.eq_iff.1 (mt leading_coeff_eq_zero.1 h))\n#align degree_map_eq_of_injective degree_map_eq_of_injective\n\n",
 "degree_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem monic.degree_map [Semiring S] [Nontrivial S] {P : polynomial R} (hmo : P.monic) (f : «expr →+* » R S) :\n    (P.map f).degree = P.degree := by\n  by_cases hP : P = 0\n  · simp [hP]\n  · refine' le_antisymm (degree_map_le _ _) _\n    rw [degree_eq_nat_degree hP]\n    refine' le_degree_of_ne_zero _\n    rw [coeff_map, monic.coeff_nat_degree hmo, RingHom.map_one]\n    exact one_ne_zero\n#align monic.degree_map monic.degree_map\n\n",
 "degree_le_zero_iff_eq_one":
 "@[simp]\ntheorem degree_le_zero_iff_eq_one (hp : p.monic) : p.degree ≤ 0 ↔ p = 1 := by\n  rw [← hp.nat_degree_eq_zero_iff_eq_one, nat_degree_eq_zero_iff_degree_le_zero]\n#align degree_le_zero_iff_eq_one degree_le_zero_iff_eq_one\n\n",
 "as_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem monic.as_sum (hp : p.monic) :\n    p =\n      X ^ p.nat_degree +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (range p.nat_degree) (C (p.coeff i) * X ^ i) :=\n  by\n  conv_lhs => rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm]\n  suffices C (p.coeff p.nat_degree) = 1 by rw [this, one_mul]\n  exact congr_arg C hp\n#align monic.as_sum monic.as_sum\n\n",
 "add_of_right":
 "theorem monic.add_of_right (hq : Monic q) (hpq : degree p < degree q) : Monic (p + q) := by\n  rwa [monic, leading_coeff_add_of_degree_lt hpq]\n#align monic.add_of_right monic.add_of_right\n\n",
 "add_of_left":
 "theorem monic.add_of_left (hp : Monic p) (hpq : degree q < degree p) : Monic (p + q) := by\n  rwa [monic, add_comm, leading_coeff_add_of_degree_lt hpq]\n#align monic.add_of_left monic.add_of_left\n\n"}