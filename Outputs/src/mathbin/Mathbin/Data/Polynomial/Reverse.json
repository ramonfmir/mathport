{"trailing_coeff_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem trailing_coeff_mul {R : Type _} [Ring R] [NoZeroDivisors R] (p q : polynomial R) :\n    (p * q).trailing_coeff = p.trailing_coeff * q.trailing_coeff := by\n  rw [← reverse_leading_coeff, reverse_mul_of_domain, leading_coeff_mul, reverse_leading_coeff, reverse_leading_coeff]\n#align trailing_coeff_mul trailing_coeff_mul\n\n",
 "reverse_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reverse_zero : reverse (0 : polynomial R) = 0 :=\n  rfl\n#align reverse_zero reverse_zero\n\n",
 "reverse_trailing_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reverse_trailing_coeff (f : polynomial R) : f.reverse.trailing_coeff = f.leading_coeff := by\n  rw [trailing_coeff, reverse_nat_trailing_degree, coeff_zero_reverse]\n#align reverse_trailing_coeff reverse_trailing_coeff\n\n",
 "reverse_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reverse_neg (f : polynomial R) : reverse (-f) = -reverse f := by\n  rw [reverse, reverse, reflect_neg, nat_degree_neg]\n#align reverse_neg reverse_neg\n\n",
 "reverse_nat_trailing_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reverse_nat_trailing_degree (f : polynomial R) : f.reverse.nat_trailing_degree = 0 :=\n  by\n  by_cases hf : f = 0\n  · rw [hf, reverse_zero, nat_trailing_degree_zero]\n  · rw [← le_zero_iff]\n    apply nat_trailing_degree_le_of_ne_zero\n    rw [coeff_zero_reverse]\n    exact mt leading_coeff_eq_zero.mp hf\n#align reverse_nat_trailing_degree reverse_nat_trailing_degree\n\n",
 "reverse_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reverse_nat_degree_le (f : polynomial R) : f.reverse.nat_degree ≤ f.nat_degree :=\n  by\n  rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero]\n  intro n hn\n  rw [WithBot.coe_lt_coe] at hn\n  rw [coeff_reverse, rev_at, Function.Embedding.coeFn_mk, if_neg (not_le_of_gt hn), coeff_eq_zero_of_nat_degree_lt hn]\n#align reverse_nat_degree_le reverse_nat_degree_le\n\n",
 "reverse_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reverse_nat_degree (f : polynomial R) : f.reverse.nat_degree = f.nat_degree - f.nat_trailing_degree := by\n  rw [f.nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree, add_tsub_cancel_right]\n#align reverse_nat_degree reverse_nat_degree\n\n",
 "reverse_mul_of_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reverse_mul_of_domain {R : Type _} [Ring R] [NoZeroDivisors R] (f g : polynomial R) :\n    reverse (f * g) = reverse f * reverse g := by\n  by_cases f0 : f = 0\n  · simp only [f0, MulZeroClass.zero_mul, reverse_zero]\n  by_cases g0 : g = 0\n  · rw [g0, MulZeroClass.mul_zero, reverse_zero, MulZeroClass.mul_zero]\n  simp [reverse_mul, *]\n#align reverse_mul_of_domain reverse_mul_of_domain\n\n",
 "reverse_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reverse_mul {f g : polynomial R} (fg : f.leading_coeff * g.leading_coeff ≠ 0) :\n    reverse (f * g) = reverse f * reverse g := by\n  unfold reverse\n  rw [nat_degree_mul' fg, reflect_mul f g rfl.le rfl.le]\n#align reverse_mul reverse_mul\n\n",
 "reverse_leading_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reverse_leading_coeff (f : polynomial R) : f.reverse.leading_coeff = f.trailing_coeff := by\n  rw [leading_coeff, reverse_nat_degree, ← rev_at_le f.nat_trailing_degree_le_nat_degree, coeff_reverse, rev_at_invol,\n    trailing_coeff]\n#align reverse_leading_coeff reverse_leading_coeff\n\n",
 "reverse_eq_zero":
 "@[simp]\ntheorem reverse_eq_zero : f.reverse = 0 ↔ f = 0 := by simp [reverse]\n#align reverse_eq_zero reverse_eq_zero\n\n",
 "rev_at_zero":
 "@[simp]\ntheorem rev_at_zero (N : ℕ) : revAt N 0 = N := by simp [rev_at]\n#align rev_at_zero rev_at_zero\n\n",
 "rev_at_le":
 "@[simp]\ntheorem rev_at_le {N i : ℕ} (H : i ≤ N) : revAt N i = N - i :=\n  if_pos H\n#align rev_at_le rev_at_le\n\n",
 "rev_at_invol":
 "@[simp]\ntheorem rev_at_invol {N i : ℕ} : (revAt N) (revAt N i) = i :=\n  revAtFun_invol\n#align rev_at_invol rev_at_invol\n\n",
 "rev_at_fun_invol":
 "/-\nCopyright (c) 2020 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\ntheorem rev_at_fun_invol {N i : ℕ} : revAtFun N (revAtFun N i) = i :=\n  by\n  unfold rev_at_fun\n  split_ifs with h j\n  · exact tsub_tsub_cancel_of_le h\n  · exfalso\n    apply j\n    exact nat.sub_le N i\n  · rfl\n#align rev_at_fun_invol rev_at_fun_invol\n\n",
 "rev_at_fun_inj":
 "theorem rev_at_fun_inj {N : ℕ} : function.injective (revAtFun N) :=\n  by\n  intro a b hab\n  rw [← @rev_at_fun_invol N a, hab, rev_at_fun_invol]\n#align rev_at_fun_inj rev_at_fun_inj\n\n",
 "rev_at_fun_eq":
 "/-- We prefer to use the bundled `rev_at` over unbundled `rev_at_fun`. -/\n@[simp]\ntheorem rev_at_fun_eq (N i : ℕ) : revAtFun N i = revAt N i :=\n  rfl\n#align rev_at_fun_eq rev_at_fun_eq\n\n",
 "rev_at_add":
 "theorem rev_at_add {N O n o : ℕ} (hn : n ≤ N) (ho : o ≤ O) : revAt (N + O) (n + o) = revAt N n + revAt O o :=\n  by\n  rcases nat.le.dest hn with ⟨n', rfl⟩\n  rcases nat.le.dest ho with ⟨o', rfl⟩\n  repeat' rw [rev_at_le (le_add_right rfl.le)]\n  rw [add_assoc, add_left_comm n' o, ← add_assoc, rev_at_le (le_add_right rfl.le)]\n  repeat' rw [add_tsub_cancel_left]\n#align rev_at_add rev_at_add\n\n",
 "reflect_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_zero {N : ℕ} : reflect N (0 : polynomial R) = 0 :=\n  rfl\n#align reflect_zero reflect_zero\n\n",
 "reflect_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reflect_support (N : ℕ) (f : polynomial R) : (reflect N f).support = Finset.image (revAt N) f.support :=\n  by\n  rcases f with ⟨⟩\n  ext1\n  simp only [reflect, support_of_finsupp, support_emb_domain, Finset.mem_map, Finset.mem_image]\n#align reflect_support reflect_support\n\n",
 "reflect_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_sub (f g : polynomial R) (N : ℕ) : reflect N (f - g) = reflect N f - reflect N g := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, reflect_add, reflect_neg]\n#align reflect_sub reflect_sub\n\n",
 "reflect_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_neg (f : polynomial R) (N : ℕ) : reflect N (-f) = -reflect N f := by\n  rw [neg_eq_neg_one_mul, ← C_1, ← C_neg, reflect_C_mul, C_neg, C_1, ← neg_eq_neg_one_mul]\n#align reflect_neg reflect_neg\n\n",
 "reflect_mul_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem reflect_mul_induction (cf cg : ℕ) :\n    ∀ N O : ℕ,\n      ∀ f g : polynomial R,\n        f.support.card ≤ cf.succ →\n          g.support.card ≤ cg.succ →\n            f.nat_degree ≤ N → g.nat_degree ≤ O → reflect (N + O) (f * g) = reflect N f * reflect O g :=\n  by\n  induction' cf with cf hcf\n  --first induction (left): base case\n  · induction' cg with cg hcg\n    -- second induction (right): base case\n    · intro N O f g Cf Cg Nf Og\n      rw [← C_mul_X_pow_eq_self Cf, ← C_mul_X_pow_eq_self Cg]\n      simp_rw [mul_assoc, X_pow_mul, mul_assoc, ← pow_add (X : polynomial R), reflect_C_mul, reflect_monomial, add_comm,\n        rev_at_add Nf Og, mul_assoc, X_pow_mul, mul_assoc, ← pow_add (X : polynomial R), add_comm]\n    -- second induction (right): induction step\n    · intro N O f g Cf Cg Nf Og\n      by_cases g0 : g = 0\n      · rw [g0, reflect_zero, MulZeroClass.mul_zero, MulZeroClass.mul_zero, reflect_zero]\n      rw [← erase_lead_add_C_mul_X_pow g, mul_add, reflect_add, reflect_add, mul_add, hcg, hcg] <;> try assumption\n      · exact le_add_left card_support_C_mul_X_pow_le_one\n      · exact le_trans (nat_degree_C_mul_X_pow_le g.leading_coeff g.nat_degree) Og\n      · exact nat.lt_succ_iff.mp (gt_of_ge_of_gt Cg (erase_lead_support_card_lt g0))\n      · exact le_trans erase_lead_nat_degree_le_aux Og\n  --first induction (left): induction step\n  · intro N O f g Cf Cg Nf Og\n    by_cases f0 : f = 0\n    · rw [f0, reflect_zero, MulZeroClass.zero_mul, MulZeroClass.zero_mul, reflect_zero]\n    rw [← erase_lead_add_C_mul_X_pow f, add_mul, reflect_add, reflect_add, add_mul, hcf, hcf] <;> try assumption\n    · exact le_add_left card_support_C_mul_X_pow_le_one\n    · exact le_trans (nat_degree_C_mul_X_pow_le f.leading_coeff f.nat_degree) Nf\n    · exact nat.lt_succ_iff.mp (gt_of_ge_of_gt Cf (erase_lead_support_card_lt f0))\n    · exact le_trans erase_lead_nat_degree_le_aux Nf\n#align reflect_mul_induction reflect_mul_induction\n\n",
 "reflect_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_mul (f g : polynomial R) {F G : ℕ} (Ff : f.nat_degree ≤ F) (Gg : g.nat_degree ≤ G) :\n    reflect (F + G) (f * g) = reflect F f * reflect G g :=\n  reflect_mul_induction _ _ F G f g f.support.card.le_succ g.support.card.le_succ Ff Gg\n#align reflect_mul reflect_mul\n\n",
 "reflect_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_monomial (N n : ℕ) : reflect N ((X : polynomial R) ^ n) = X ^ revAt N n := by\n  rw [← one_mul (X ^ n), ← one_mul (X ^ rev_at N n), ← C_1, reflect_C_mul_X_pow]\n#align reflect_monomial reflect_monomial\n\n",
 "reflect_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_eq_zero_iff {N : ℕ} {f : polynomial R} : reflect N (f : polynomial R) = 0 ↔ f = 0 :=\n  by\n  rcases f with ⟨⟩\n  simp [reflect]\n#align reflect_eq_zero_iff reflect_eq_zero_iff\n\n",
 "reflect_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_add (f g : polynomial R) (N : ℕ) : reflect N (f + g) = reflect N f + reflect N g :=\n  by\n  ext\n  simp only [coeff_add, coeff_reflect]\n#align reflect_add reflect_add\n\n",
 "reflect_C_mul_X_pow":
 "@[simp]\ntheorem reflect_C_mul_X_pow (N n : ℕ) {c : R} : reflect N (C c * X ^ n) = C c * X ^ revAt N n :=\n  by\n  ext\n  rw [reflect_C_mul, coeff_C_mul, coeff_C_mul, coeff_X_pow, coeff_reflect]\n  split_ifs with h j\n  · rw [h, rev_at_invol, coeff_X_pow_self]\n  · rw [not_mem_support_iff.mp]\n    intro a\n    rw [← one_mul (X ^ n), ← C_1] at a\n    apply h\n    rw [← mem_support_C_mul_X_pow a, rev_at_invol]\n#align reflect_C_mul_X_pow reflect_C_mul_X_pow\n\n",
 "reflect_C_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem reflect_C_mul (f : polynomial R) (r : R) (N : ℕ) : reflect N (C r * f) = C r * reflect N f :=\n  by\n  ext\n  simp only [coeff_reflect, coeff_C_mul]\n#align reflect_C_mul reflect_C_mul\n\n",
 "reflect_C":
 "@[simp]\ntheorem reflect_C (r : R) (N : ℕ) : reflect N (C r) = C r * X ^ N := by\n  conv_lhs => rw [← mul_one (C r), ← pow_zero X, reflect_C_mul_X_pow, rev_at_zero]\n#align reflect_C reflect_C\n\n",
 "nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree (f : polynomial R) :\n    f.nat_degree = f.reverse.nat_degree + f.nat_trailing_degree :=\n  by\n  by_cases hf : f = 0\n  · rw [hf, reverse_zero, nat_degree_zero, nat_trailing_degree_zero]\n  apply le_antisymm\n  · refine' tsub_le_iff_right.mp _\n    apply le_nat_degree_of_ne_zero\n    rw [reverse, coeff_reflect, ← rev_at_le f.nat_trailing_degree_le_nat_degree, rev_at_invol]\n    exact trailing_coeff_nonzero_iff_nonzero.mpr hf\n  · rw [← le_tsub_iff_left f.reverse_nat_degree_le]\n    apply nat_trailing_degree_le_of_ne_zero\n    have key := mt leading_coeff_eq_zero.mp (mt reverse_eq_zero.mp hf)\n    rwa [leading_coeff, coeff_reverse, rev_at_le f.reverse_nat_degree_le] at key\n#align nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree\n\n",
 "eval₂_reverse_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem eval₂_reverse_mul_pow (i : «expr →+* » R S) (x : S) [Invertible x] (f : polynomial R) :\n    eval₂ i ((«expr⅟») x) (reverse f) * x ^ f.nat_degree = eval₂ i x f :=\n  eval₂_reflect_mul_pow i _ _ f le_rfl\n#align eval₂_reverse_mul_pow eval₂_reverse_mul_pow\n\n",
 "eval₂_reverse_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n@[simp]\ntheorem eval₂_reverse_eq_zero_iff (i : «expr →+* » R S) (x : S) [Invertible x] (f : polynomial R) :\n    eval₂ i ((«expr⅟») x) (reverse f) = 0 ↔ eval₂ i x f = 0 :=\n  eval₂_reflect_eq_zero_iff i x _ _ le_rfl\n#align eval₂_reverse_eq_zero_iff eval₂_reverse_eq_zero_iff\n\n",
 "eval₂_reflect_mul_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem eval₂_reflect_mul_pow (i : «expr →+* » R S) (x : S) [Invertible x] (N : ℕ) (f : polynomial R)\n    (hf : f.nat_degree ≤ N) : eval₂ i ((«expr⅟») x) (reflect N f) * x ^ N = eval₂ i x f :=\n  by\n  refine' induction_with_nat_degree_le (fun f => eval₂ i ((«expr⅟») x) (reflect N f) * x ^ N = eval₂ i x f) _ _ _ _ f hf\n  · simp\n  · intro n r hr0 hnN\n    simp only [rev_at_le hnN, reflect_C_mul_X_pow, eval₂_X_pow, eval₂_C, eval₂_mul]\n    conv in x ^ N => rw [← nat.sub_add_cancel hnN]\n    rw [pow_add, ← mul_assoc, mul_assoc (i r), ← mul_pow, invOf_mul_self, one_pow, mul_one]\n  · intros\n    simp [*, add_mul]\n#align eval₂_reflect_mul_pow eval₂_reflect_mul_pow\n\n",
 "eval₂_reflect_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem eval₂_reflect_eq_zero_iff (i : «expr →+* » R S) (x : S) [Invertible x] (N : ℕ) (f : polynomial R)\n    (hf : f.nat_degree ≤ N) : eval₂ i ((«expr⅟») x) (reflect N f) = 0 ↔ eval₂ i x f = 0 :=\n  by\n  conv_rhs => rw [← eval₂_reflect_mul_pow i x N f hf]\n  constructor\n  · intro h\n    rw [h, MulZeroClass.zero_mul]\n  · intro h\n    rw [← mul_one (eval₂ i ((«expr⅟») x) _), ← one_pow N, ← mul_invOf_self x, mul_pow, ← mul_assoc, h,\n      MulZeroClass.zero_mul]\n#align eval₂_reflect_eq_zero_iff eval₂_reflect_eq_zero_iff\n\n",
 "coeff_zero_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_zero_reverse (f : polynomial R) : coeff (reverse f) 0 = leadingCoeff f := by\n  rw [coeff_reverse, rev_at_le (zero_le f.nat_degree), tsub_zero, leading_coeff]\n#align coeff_zero_reverse coeff_zero_reverse\n\n",
 "coeff_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_reverse (f : polynomial R) (n : ℕ) : f.reverse.coeff n = f.coeff (revAt f.nat_degree n) := by\n  rw [reverse, coeff_reflect]\n#align coeff_reverse coeff_reverse\n\n",
 "coeff_reflect":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_reflect (N : ℕ) (f : polynomial R) (i : ℕ) : coeff (reflect N f) i = f.coeff (revAt N i) :=\n  by\n  rcases f with ⟨⟩\n  simp only [reflect, coeff]\n  calc\n    Finsupp.embDomain (rev_at N) f i = Finsupp.embDomain (rev_at N) f (rev_at N (rev_at N i)) := by rw [rev_at_invol]\n    _ = f (rev_at N i) := Finsupp.embDomain_apply _ _ _\n    \n#align coeff_reflect coeff_reflect\n\n",
 "coeff_one_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coeff_one_reverse (f : polynomial R) : coeff (reverse f) 1 = nextCoeff f :=\n  by\n  rw [coeff_reverse, next_coeff]\n  split_ifs with hf\n  · have : coeff f 1 = 0 := coeff_eq_zero_of_nat_degree_lt (by simp only [hf, zero_lt_one])\n    simp [*, rev_at]\n  · rw [rev_at_le]\n    exact Nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf)\n#align coeff_one_reverse coeff_one_reverse\n\n"}