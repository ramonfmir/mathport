{"sum_roots_eq_next_coeff_of_monic_of_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a monic polynomial that splits, then `P.next_coeff` equals the sum of the roots. -/\ntheorem sum_roots_eq_next_coeff_of_monic_of_split {P : polynomial K} (hmo : P.monic) (hP : P.splits (RingHom.id K)) :\n    P.next_coeff = -P.roots.sum :=\n  by\n  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]\n  rw [monic.next_coeff_multiset_prod _ _ fun a ha => _]\n  · simp_rw [next_coeff_X_sub_C, Multiset.sum_map_neg']\n  · exact monic_X_sub_C a\n#align sum_roots_eq_next_coeff_of_monic_of_split sum_roots_eq_next_coeff_of_monic_of_split\n\n",
 "splits_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n@[simp]\ntheorem splits_zero : Splits i (0 : polynomial K) :=\n  or.inl (Polynomial.map_zero i)\n#align splits_zero splits_zero\n\n",
 "splits_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem splits_prod_iff {ι : Type u} {s : ι → polynomial K} {t : Finset ι} :\n    (∀ j ∈ t, s j ≠ 0) →\n      ((finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t\n              (s x)).splits\n          i ↔\n        ∀ j ∈ t, (s j).splits i) :=\n  by\n  refine' Finset.induction_on t (fun _ => ⟨fun _ _ h => h.elim, fun _ => splits_one i⟩) fun a t hat ih ht => _\n  rw [Finset.forall_mem_insert] at ht⊢\n  rw [Finset.prod_insert hat, splits_mul_iff i ht.1 (Finset.prod_ne_zero_iff.2 ht.2), ih ht.2]\n#align splits_prod_iff splits_prod_iff\n\n",
 "splits_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem splits_prod {ι : Type u} {s : ι → polynomial K} {t : Finset ι} :\n    (∀ j ∈ t, (s j).splits i) →\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (s x)).splits\n        i :=\n  by\n  refine' Finset.induction_on t (fun _ => splits_one i) fun a t hat ih ht => _\n  rw [Finset.forall_mem_insert] at ht; rw [Finset.prod_insert hat]\n  exact splits_mul i ht.1 (ih ht.2)\n#align splits_prod splits_prod\n\n",
 "splits_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_pow {f : polynomial K} (hf : f.splits i) (n : ℕ) : (f ^ n).splits i :=\n  by\n  rw [← Finset.card_range n, ← Finset.prod_const]\n  exact splits_prod i fun j hj => hf\n#align splits_pow splits_pow\n\n",
 "splits_one":
 "theorem splits_one : Splits i 1 :=\n  splits_C i 1\n#align splits_one splits_one\n\n",
 "splits_of_splits_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_splits_of_dvd {f g : polynomial K} (hf0 : f ≠ 0) (hf : Splits i f) (hgf : g ∣ f) : Splits i g :=\n  by\n  obtain ⟨f, rfl⟩ := hgf\n  exact (splits_of_splits_mul i hf0 hf).1\n#align splits_of_splits_of_dvd splits_of_splits_of_dvd\n\n",
 "splits_of_splits_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_splits_mul' {f g : polynomial K} (hfg : (f * g).map i ≠ 0) (h : Splits i (f * g)) :\n    Splits i f ∧ Splits i g :=\n  ⟨or.inr fun g hgi hg => or.resolve_left h hfg hgi (by rw [Polynomial.map_mul] <;> exact hg.trans (dvd_mul_right _ _)),\n    or.inr fun g hgi hg => or.resolve_left h hfg hgi (by rw [Polynomial.map_mul] <;> exact hg.trans (dvd_mul_left _ _))⟩\n#align splits_of_splits_mul' splits_of_splits_mul'\n\n",
 "splits_of_splits_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_splits_mul {f g : polynomial K} (hfg : f * g ≠ 0) (h : Splits i (f * g)) : Splits i f ∧ Splits i g :=\n  splits_of_splits_mul' i (map_ne_zero hfg) h\n#align splits_of_splits_mul splits_of_splits_mul\n\n",
 "splits_of_splits_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_splits_id {f : polynomial K} : Splits (RingHom.id K) f → Splits i f :=\n  UniqueFactorizationMonoid.induction_on_prime f (fun _ => splits_zero _)\n    (fun _ hu _ => splits_of_degree_le_one _ ((isUnit_iff_degree_eq_zero.1 hu).symm ▸ by decide))\n    fun a p ha0 hp ih hfi =>\n    splits_mul _\n      (splits_of_degree_eq_one _\n        ((splits_of_splits_mul _ (mul_ne_zero hp.1 ha0) hfi).1.def.resolve_left hp.1 hp.irreducible (by rw [map_id])))\n      (ih (splits_of_splits_mul _ (mul_ne_zero hp.1 ha0) hfi).2)\n#align splits_of_splits_id splits_of_splits_id\n\n",
 "splits_of_splits_gcd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_splits_gcd_right {f g : polynomial K} (hg0 : g ≠ 0) (hg : Splits i g) :\n    Splits i (EuclideanDomain.gcd f g) :=\n  Polynomial.splits_of_splits_of_dvd i hg0 hg (EuclideanDomain.gcd_dvd_right f g)\n#align splits_of_splits_gcd_right splits_of_splits_gcd_right\n\n",
 "splits_of_splits_gcd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_splits_gcd_left {f g : polynomial K} (hf0 : f ≠ 0) (hf : Splits i f) :\n    Splits i (EuclideanDomain.gcd f g) :=\n  Polynomial.splits_of_splits_of_dvd i hf0 hf (EuclideanDomain.gcd_dvd_left f g)\n#align splits_of_splits_gcd_left splits_of_splits_gcd_left\n\n",
 "splits_of_nat_degree_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_nat_degree_le_one {f : polynomial K} (hf : natDegree f ≤ 1) : Splits i f :=\n  splits_of_degree_le_one i (degree_le_of_natDegree_le hf)\n#align splits_of_nat_degree_le_one splits_of_nat_degree_le_one\n\n",
 "splits_of_nat_degree_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_nat_degree_eq_one {f : polynomial K} (hf : natDegree f = 1) : Splits i f :=\n  splits_of_natDegree_le_one i (le_of_eq hf)\n#align splits_of_nat_degree_eq_one splits_of_nat_degree_eq_one\n\n",
 "splits_of_map_eq_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_map_eq_C {f : polynomial K} {a : L} (h : f.map i = C a) : Splits i f :=\n  if ha : a = 0 then or.inl (h.trans (ha.symm ▸ C_0))\n  else\n    or.inr fun g hg ⟨p, hp⟩ =>\n      absurd hg.1 <|\n        Classical.not_not.2 <|\n          isUnit_iff_degree_eq_zero.2 <| by\n            have := congr_arg degree hp\n            rw [h, degree_C ha, degree_mul, @eq_comm (WithBot ℕ) 0, Nat.WithBot.add_eq_zero_iff] at this\n            exact this.1\n#align splits_of_map_eq_C splits_of_map_eq_C\n\n",
 "splits_of_map_degree_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_map_degree_eq_one {f : polynomial K} (hf : degree (f.map i) = 1) : Splits i f :=\n  or.inr fun g hg ⟨p, hp⟩ => by\n    have := congr_arg degree hp <;>\n          simp [Nat.WithBot.add_eq_one_iff, hf, @eq_comm (WithBot ℕ) 1, mt is_unit_iff_degree_eq_zero.2 hg.1] at\n            this <;>\n        clear _fun_match <;>\n      tauto\n#align splits_of_map_degree_eq_one splits_of_map_degree_eq_one\n\n",
 "splits_of_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_is_unit [IsDomain K] {u : polynomial K} (hu : IsUnit u) : u.splits i :=\n  (isUnit_iff.mp hu).some_spec.2 ▸ splits_C _ _\n#align splits_of_is_unit splits_of_is_unit\n\n",
 "splits_of_exists_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_exists_multiset {f : polynomial K} {s : Multiset L}\n    (hs : f.map i = C (i f.leading_coeff) * (s.map fun a : L => X - C a).prod) : Splits i f :=\n  if hf0 : f = 0 then hf0.symm ▸ splits_zero i\n  else\n    or.inr fun p hp hdp => by\n      rw [irreducible_iff_prime] at hp\n      rw [hs, ← Multiset.prod_toList] at hdp\n      obtain hd | hd := hp.2.2 _ _ hdp\n      · refine' (hp.2.1 <| isUnit_of_dvd_unit hd _).elim\n        exact is_unit_C.2 ((leading_coeff_ne_zero.2 hf0).is_unit.map i)\n      · obtain ⟨q, hq, hd⟩ := hp.dvd_prod_iff.1 hd\n        obtain ⟨a, ha, rfl⟩ := Multiset.mem_map.1 (Multiset.mem_toList.1 hq)\n        rw [degree_eq_degree_of_associated ((hp.dvd_prime_iff_associated <| prime_X_sub_C a).1 hd)]\n        exact degree_X_sub_C a\n#align splits_of_exists_multiset splits_of_exists_multiset\n\n",
 "splits_of_degree_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_degree_le_one {f : polynomial K} (hf : degree f ≤ 1) : Splits i f :=\n  if hif : degree (f.map i) ≤ 0 then splits_of_map_eq_C i (degree_le_zero_iff.mp hif)\n  else by\n    push_neg  at hif\n    rw [← Order.succ_le_iff, ← WithBot.coe_zero, WithBot.succ_coe, Nat.succ_eq_succ] at hif\n    exact splits_of_map_degree_eq_one i (le_antisymm ((degree_map_le i _).trans hf) hif)\n#align splits_of_degree_le_one splits_of_degree_le_one\n\n",
 "splits_of_degree_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_of_degree_eq_one {f : polynomial K} (hf : degree f = 1) : Splits i f :=\n  splits_of_degree_le_one i hf.le\n#align splits_of_degree_eq_one splits_of_degree_eq_one\n\n",
 "splits_mul_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_mul_iff {f g : polynomial K} (hf : f ≠ 0) (hg : g ≠ 0) : (f * g).splits i ↔ f.splits i ∧ g.splits i :=\n  ⟨splits_of_splits_mul i (mul_ne_zero hf hg), fun ⟨hfs, hgs⟩ => splits_mul i hfs hgs⟩\n#align splits_mul_iff splits_mul_iff\n\n",
 "splits_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_mul {f g : polynomial K} (hf : Splits i f) (hg : Splits i g) : Splits i (f * g) :=\n  if h : (f * g).map i = 0 then or.inl h\n  else\n    or.inr fun p hp hpf =>\n      ((PrincipalIdealRing.irreducible_iff_prime.1 hp).2.2 _ _\n            (show p ∣ map i f * map i g by convert hpf <;> rw [Polynomial.map_mul])).elim\n        (hf.resolve_left (fun hf => by simpa [hf] using h) hp) (hg.resolve_left (fun hg => by simpa [hg] using h) hp)\n#align splits_mul splits_mul\n\n",
 "splits_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_map_iff (j : «expr →+* » L F) {f : polynomial K} : Splits j (f.map i) ↔ Splits (j.comp i) f := by\n  simp [splits, Polynomial.map_map]\n#align splits_map_iff splits_map_iff\n\n",
 "splits_iff_exists_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_iff_exists_multiset {f : polynomial K} :\n    Splits i f ↔ ∃ s : Multiset L, f.map i = C (i f.leading_coeff) * (s.map fun a : L => X - C a).prod :=\n  ⟨fun hf => ⟨(f.map i).roots, eq_prod_roots_of_splits hf⟩, fun ⟨s, hs⟩ => splits_of_exists_multiset i hs⟩\n#align splits_iff_exists_multiset splits_iff_exists_multiset\n\n",
 "splits_iff_card_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem splits_iff_card_roots {p : polynomial K} : Splits (RingHom.id K) p ↔ p.roots.card = p.nat_degree :=\n  by\n  constructor\n  · intro H\n    rw [nat_degree_eq_card_roots H, map_id]\n  · intro hroots\n    rw [splits_iff_exists_multiset (RingHom.id K)]\n    use p.roots\n    simp only [RingHom.id_apply, map_id]\n    exact (C_leading_coeff_mul_prod_multiset_X_sub_C hroots).symm\n#align splits_iff_card_roots splits_iff_card_roots\n\n",
 "splits_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- This lemma is for polynomials over a field. -/\ntheorem splits_iff (f : polynomial K) :\n    Splits i f ↔ f = 0 ∨ ∀ {g : polynomial L}, Irreducible g → g ∣ f.map i → degree g = 1 := by rw [splits, map_eq_zero]\n#align splits_iff splits_iff\n\n",
 "splits_id_iff_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_id_iff_splits {f : polynomial K} : (f.map i).splits (RingHom.id L) ↔ f.splits i := by\n  rw [splits_map_iff, RingHom.id_comp]\n#align splits_id_iff_splits splits_id_iff_splits\n\n",
 "splits_comp_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_comp_of_splits (j : «expr →+* » L F) {f : polynomial K} (h : Splits i f) : Splits (j.comp i) f :=\n  by\n  change i with (RingHom.id _).comp i at h\n  rw [← splits_map_iff]\n  rw [← splits_map_iff i] at h\n  exact splits_of_splits_id _ h\n#align splits_comp_of_splits splits_comp_of_splits\n\n",
 "splits_X_sub_C":
 "theorem splits_X_sub_C {x : K} : (X - C x).splits i :=\n  splits_of_degree_le_one _ <| degree_X_sub_C_le _\n#align splits_X_sub_C splits_X_sub_C\n\n",
 "splits_X_pow":
 "theorem splits_X_pow (n : ℕ) : (X ^ n).splits i :=\n  splits_pow i (splits_X i) n\n#align splits_X_pow splits_X_pow\n\n",
 "splits_X":
 "theorem splits_X : X.splits i :=\n  splits_of_degree_le_one _ degree_X_le\n#align splits_X splits_X\n\n",
 "splits_C":
 "@[simp]\ntheorem splits_C (a : K) : Splits i (C a) :=\n  splits_of_map_eq_C i (map_C i)\n#align splits_C splits_C\n\n",
 "roots_ne_zero_of_splits'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_ne_zero_of_splits' {f : polynomial K} (hs : Splits i f) (hf0 : natDegree (f.map i) ≠ 0) :\n    (f.map i).roots ≠ 0 :=\n  let ⟨x, hx⟩ := exists_root_of_splits' i hs fun h => hf0 <| natDegree_eq_of_degree_eq_some h\n  fun h => by\n  rw [← eval_map] at hx\n  cases h.subst ((mem_roots _).2 hx)\n  exact ne_zero_of_nat_degree_gt (nat.pos_of_ne_zero hf0)\n#align roots_ne_zero_of_splits' roots_ne_zero_of_splits'\n\n",
 "roots_ne_zero_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_ne_zero_of_splits {f : polynomial K} (hs : Splits i f) (hf0 : natDegree f ≠ 0) : (f.map i).roots ≠ 0 :=\n  roots_ne_zero_of_splits' i hs (ne_of_eq_of_ne (natDegree_map i) hf0)\n#align roots_ne_zero_of_splits roots_ne_zero_of_splits\n\n",
 "roots_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_map {f : polynomial K} (hf : f.splits <| RingHom.id K) : (f.map i).roots = f.roots.map i :=\n  (roots_map_of_injective_of_card_eq_natDegree i.injective <|\n      by\n      convert(nat_degree_eq_card_roots hf).symm\n      rw [map_id]).symm\n#align roots_map roots_map\n\n",
 "root_of_splits'_eq_root_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- `root_of_splits'` is definitionally equal to `root_of_splits`. -/\ntheorem root_of_splits'_eq_root_of_splits {f : polynomial K} (hf : f.splits i) (hfd) :\n    rootOfSplits' i hf hfd = rootOfSplits i hf (f.degree_map i ▸ hfd) :=\n  rfl\n#align root_of_splits'_eq_root_of_splits root_of_splits'_eq_root_of_splits\n\n",
 "prod_roots_eq_coeff_zero_of_monic_of_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. -/\ntheorem prod_roots_eq_coeff_zero_of_monic_of_split {P : polynomial K} (hmo : P.monic) (hP : P.splits (RingHom.id K)) :\n    coeff P 0 = (-1) ^ P.nat_degree * P.roots.prod :=\n  by\n  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]\n  rw [coeff_zero_eq_eval_zero, eval_multiset_prod, Multiset.map_map]\n  simp_rw [Function.comp_apply, eval_sub, eval_X, zero_sub, eval_C]\n  conv_lhs =>\n    congr\n    congr\n    ext\n    rw [neg_eq_neg_one_mul]\n  rw [Multiset.prod_map_mul, Multiset.map_const, Multiset.prod_replicate, Multiset.map_id', splits_iff_card_roots.1 hP]\n#align prod_roots_eq_coeff_zero_of_monic_of_split prod_roots_eq_coeff_zero_of_monic_of_split\n\n",
 "nat_degree_eq_card_roots'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem nat_degree_eq_card_roots' {p : polynomial K} {i : «expr →+* » K L} (hsplit : Splits i p) :\n    (p.map i).nat_degree = (p.map i).roots.card :=\n  by\n  by_cases hp : p.map i = 0\n  · rw [hp, nat_degree_zero, roots_zero, Multiset.card_zero]\n  obtain ⟨q, he, hd, hr⟩ := exists_prod_multiset_X_sub_C_mul (p.map i)\n  rw [← splits_id_iff_splits, ← he] at hsplit\n  rw [← he] at hp\n  have hq : q ≠ 0 := fun h => hp (by rw [h, MulZeroClass.mul_zero])\n  rw [← hd, add_right_eq_self]\n  by_contra\n  have h' : (map (RingHom.id L) q).nat_degree ≠ 0 := by simp [h]\n  have := roots_ne_zero_of_splits' (RingHom.id L) (splits_of_splits_mul' _ _ hsplit).2 h'\n  · rw [map_id] at this\n    exact this hr\n  · rw [map_id]\n    exact mul_ne_zero monic_prod_multiset_X_sub_C.ne_zero hq\n#align nat_degree_eq_card_roots' nat_degree_eq_card_roots'\n\n",
 "nat_degree_eq_card_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem nat_degree_eq_card_roots {p : polynomial K} {i : «expr →+* » K L} (hsplit : Splits i p) :\n    p.nat_degree = (p.map i).roots.card :=\n  (natDegree_map i).symm.trans <| natDegree_eq_card_roots' hsplit\n#align nat_degree_eq_card_roots nat_degree_eq_card_roots\n\n",
 "mem_lift_of_splits_of_roots_mem_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_lift_of_splits_of_roots_mem_range (R : Type _) [CommRing R] [Algebra R K] {f : polynomial K}\n    (hs : f.splits (RingHom.id K)) (hm : f.monic) (hr : ∀ a ∈ f.roots, a ∈ (algebraMap R K).range) :\n    f ∈ Polynomial.lifts (algebraMap R K) :=\n  by\n  rw [eq_prod_roots_of_monic_of_splits_id hm hs, lifts_iff_lifts_ring]\n  refine' Subring.multiset_prod_mem _ _ fun P hP => _\n  obtain ⟨b, hb, rfl⟩ := Multiset.mem_map.1 hP\n  exact Subring.sub_mem _ (X_mem_lifts _) (C'_mem_lifts (hr _ hb))\n#align mem_lift_of_splits_of_roots_mem_range mem_lift_of_splits_of_roots_mem_range\n\n",
 "map_root_of_splits'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_root_of_splits' {f : polynomial K} (hf : f.splits i) (hfd) : f.eval₂ i (rootOfSplits' i hf hfd) = 0 :=\n  Classical.choose_spec <| exists_root_of_splits' i hf hfd\n#align map_root_of_splits' map_root_of_splits'\n\n",
 "map_root_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_root_of_splits {f : polynomial K} (hf : f.splits i) (hfd) : f.eval₂ i (rootOfSplits i hf hfd) = 0 :=\n  map_rootOfSplits' i hf (ne_of_eq_of_ne (degree_map f i) hfd)\n#align map_root_of_splits map_root_of_splits\n\n",
 "image_root_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_root_set [Algebra F K] [Algebra F L] {p : polynomial F} (h : p.splits (algebraMap F K))\n    (f : «expr →ₐ[ ] » K F L) : «expr '' » f (p.root_set K) = p.root_set L := by\n  classical rw [root_set, ← Finset.coe_image, ← Multiset.toFinset_map, ← f.coe_to_ring_hom, ←\n      roots_map (↑f) ((splits_id_iff_splits (algebraMap F K)).mpr h), map_map, f.comp_algebra_map, ← root_set]\n#align image_root_set image_root_set\n\n",
 "exists_root_of_splits'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_root_of_splits' {f : polynomial K} (hs : Splits i f) (hf0 : degree (f.map i) ≠ 0) :\n    ∃ x, eval₂ i x f = 0 :=\n  if hf0' : f.map i = 0 then by simp [eval₂_eq_eval_map, hf0']\n  else\n    let ⟨g, hg⟩ :=\n      WfDvdMonoid.exists_irreducible_factor (show ¬IsUnit (f.map i) from mt isUnit_iff_degree_eq_zero.1 hf0) hf0'\n    let ⟨x, hx⟩ := exists_root_of_degree_eq_one (hs.resolve_left hf0' hg.1 hg.2)\n    let ⟨i, hi⟩ := hg.2\n    ⟨x, by rw [← eval_map, hi, eval_mul, show _ = _ from hx, MulZeroClass.zero_mul]⟩\n#align exists_root_of_splits' exists_root_of_splits'\n\n",
 "exists_root_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_root_of_splits {f : polynomial K} (hs : Splits i f) (hf0 : degree f ≠ 0) : ∃ x, eval₂ i x f = 0 :=\n  exists_root_of_splits' i hs ((f.degree_map i).symm ▸ hf0)\n#align exists_root_of_splits exists_root_of_splits\n\n",
 "eq_prod_roots_of_splits_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_prod_roots_of_splits_id {p : polynomial K} (hsplit : Splits (RingHom.id K) p) :\n    p = C p.leading_coeff * (p.roots.map fun a => X - C a).prod := by simpa using eq_prod_roots_of_splits hsplit\n#align eq_prod_roots_of_splits_id eq_prod_roots_of_splits_id\n\n",
 "eq_prod_roots_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_prod_roots_of_splits {p : polynomial K} {i : «expr →+* » K L} (hsplit : Splits i p) :\n    p.map i = C (i p.leading_coeff) * ((p.map i).roots.map fun a => X - C a).prod :=\n  by\n  rw [← leading_coeff_map]; symm\n  apply C_leading_coeff_mul_prod_multiset_X_sub_C\n  rw [nat_degree_map]; exact (nat_degree_eq_card_roots hsplit).symm\n#align eq_prod_roots_of_splits eq_prod_roots_of_splits\n\n",
 "eq_prod_roots_of_monic_of_splits_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_prod_roots_of_monic_of_splits_id {p : polynomial K} (m : Monic p) (hsplit : Splits (RingHom.id K) p) :\n    p = (p.roots.map fun a => X - C a).prod :=\n  by\n  convert eq_prod_roots_of_splits_id hsplit\n  simp [m]\n#align eq_prod_roots_of_monic_of_splits_id eq_prod_roots_of_monic_of_splits_id\n\n",
 "eq_X_sub_C_of_splits_of_single_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_X_sub_C_of_splits_of_single_root {x : K} {h : polynomial K} (h_splits : Splits i h)\n    (h_roots : (h.map i).roots = {i x}) : h = C h.leading_coeff * (X - C x) :=\n  by\n  apply Polynomial.map_injective _ i.injective\n  rw [eq_prod_roots_of_splits h_splits, h_roots]\n  simp\n#align eq_X_sub_C_of_splits_of_single_root eq_X_sub_C_of_splits_of_single_root\n\n",
 "degree_eq_one_of_irreducible_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_eq_one_of_irreducible_of_splits {p : polynomial K} (hp : Irreducible p)\n    (hp_splits : Splits (RingHom.id K) p) : p.degree = 1 :=\n  by\n  rcases hp_splits with ⟨⟩\n  · exfalso\n    simp_all\n  · apply hp_splits hp\n    simp\n#align degree_eq_one_of_irreducible_of_splits degree_eq_one_of_irreducible_of_splits\n\n",
 "degree_eq_card_roots'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem degree_eq_card_roots' {p : polynomial K} {i : «expr →+* » K L} (p_ne_zero : p.map i ≠ 0) (hsplit : Splits i p) :\n    (p.map i).degree = (p.map i).roots.card := by rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots' hsplit]\n#align degree_eq_card_roots' degree_eq_card_roots'\n\n",
 "degree_eq_card_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem degree_eq_card_roots {p : polynomial K} {i : «expr →+* » K L} (p_ne_zero : p ≠ 0) (hsplit : Splits i p) :\n    p.degree = (p.map i).roots.card := by rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots hsplit]\n#align degree_eq_card_roots degree_eq_card_roots\n\n",
 "def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- This lemma is for polynomials over a field. -/\ntheorem splits.def {i : «expr →+* » K L} {f : polynomial K} (h : Splits i f) :\n    f = 0 ∨ ∀ {g : polynomial L}, Irreducible g → g ∣ f.map i → degree g = 1 :=\n  (splits_iff i f).mp h\n#align splits.def splits.def\n\n",
 "aeval_root_derivative_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem aeval_root_derivative_of_splits [Algebra K L] {P : polynomial K} (hmo : P.monic)\n    (hP : P.splits (algebraMap K L)) {r : L} (hr : r ∈ (P.map (algebraMap K L)).roots) :\n    aeval r P.derivative = (((P.map <| algebraMap K L).roots.erase r).map fun a => r - a).prod :=\n  by\n  replace hmo := hmo.map (algebraMap K L)\n  replace hP := (splits_id_iff_splits (algebraMap K L)).2 hP\n  rw [aeval_def, ← eval_map, ← derivative_map]\n  nth_rw 1 [eq_prod_roots_of_monic_of_splits_id hmo hP]\n  rw [eval_multiset_prod_X_sub_C_derivative hr]\n#align aeval_root_derivative_of_splits aeval_root_derivative_of_splits\n\n",
 "adjoin_root_set_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_root_set_eq_range [Algebra F K] [Algebra F L] {p : polynomial F} (h : p.splits (algebraMap F K))\n    (f : «expr →ₐ[ ] » K F L) : Algebra.adjoin F (p.root_set L) = f.range ↔ Algebra.adjoin F (p.root_set K) = «expr⊤» :=\n  by\n  rw [← image_root_set h f, Algebra.adjoin_image, ← Algebra.map_top]\n  exact (Subalgebra.map_injective f.to_ring_hom.injective).eq_iff\n#align adjoin_root_set_eq_range adjoin_root_set_eq_range\n\n"}