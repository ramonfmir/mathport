{"div_eq_quo_add_sum_rem_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\n-/\ntheorem div_eq_quo_add_sum_rem_div (f : polynomial R) {ι : Type _} {g : ι → polynomial R} {s : Finset ι}\n    (hg : ∀ i ∈ s, (g i).monic) (hcop : Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) :\n    ∃ (q : polynomial R)(r : ι → polynomial R),\n      (∀ i ∈ s, (r i).degree < (g i).degree) ∧\n        (↑f : K) /\n            finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s ↑(g i) =\n          ↑q +\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n              (↑(r i) / ↑(g i)) :=\n  by\n  induction' s using Finset.induction_on with a b hab Hind f generalizing f\n  · refine' ⟨f, fun i : ι => (0 : polynomial R), fun i => _, by simp⟩\n    rintro ⟨⟩\n  obtain ⟨q₀, r₁, r₂, hdeg₁, hdeg₂, hf : (↑f : K) / _ = _⟩ :=\n    div_eq_quo_add_rem_div_add_rem_div R K f (_ : monic (g a))\n      (_ :\n        monic\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" b (g i)))\n      _\n  · obtain ⟨q, r, hrdeg, IH⟩ :=\n      Hind (fun i hi => hg i (Finset.mem_insert_of_mem hi))\n        (Set.Pairwise.mono (Finset.coe_subset.2 fun i hi => Finset.mem_insert_of_mem hi) hcop) r₂\n    refine' ⟨q₀ + q, fun i => if i = a then r₁ else r i, _, _⟩\n    · intro i\n      split_ifs with h1\n      · cases h1\n        intro\n        exact hdeg₁\n      · intro hi\n        exact hrdeg i (Finset.mem_of_mem_insert_of_ne hi h1)\n    norm_cast  at hf IH⊢\n    rw [finset.prod_insert hab, hf, IH, finset.sum_insert hab, if_pos rfl]\n    trans\n      (↑(q₀ + q : polynomial R) : K) +\n        (↑r₁ / ↑(g a) +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" b\n            (↑(r i) / ↑(g i)))\n    · push_cast\n      ring\n    congr 2\n    refine' finset.sum_congr rfl fun x hxb => _\n    rw [if_neg]\n    rintro rfl\n    exact hab hxb\n  · exact hg a (b.mem_insert_self a)\n  · exact monic_prod_of_monic _ _ fun i hi => hg i (Finset.mem_insert_of_mem hi)\n  · refine'\n      is_coprime.prod_right fun i hi =>\n        hcop (Finset.mem_coe.2 (b.mem_insert_self a)) (Finset.mem_coe.2 (Finset.mem_insert_of_mem hi)) _\n    rintro rfl\n    exact hab hi\n#align div_eq_quo_add_sum_rem_div div_eq_quo_add_sum_rem_div\n\n",
 "div_eq_quo_add_rem_div_add_rem_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) Sidharth Hariharan. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Buzzard, Sidharth Hariharan\n-/\n/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂).\n-/\ntheorem div_eq_quo_add_rem_div_add_rem_div (f : polynomial R) {g₁ g₂ : polynomial R} (hg₁ : g₁.monic) (hg₂ : g₂.monic)\n    (hcoprime : IsCoprime g₁ g₂) :\n    ∃ q r₁ r₂ : polynomial R,\n      r₁.degree < g₁.degree ∧ r₂.degree < g₂.degree ∧ (↑f : K) / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ :=\n  by\n  rcases hcoprime with ⟨c, d, hcd⟩\n  refine'\n    ⟨«expr /ₘ » (f * d) g₁ + «expr /ₘ » (f * c) g₂, «expr %ₘ » (f * d) g₁, «expr %ₘ » (f * c) g₂,\n      degree_mod_by_monic_lt _ hg₁, degree_mod_by_monic_lt _ hg₂, _⟩\n  have hg₁' : (↑g₁ : K) ≠ 0 := by\n    norm_cast\n    exact hg₁.ne_zero_of_ne zero_ne_one\n  have hg₂' : (↑g₂ : K) ≠ 0 := by\n    norm_cast\n    exact hg₂.ne_zero_of_ne zero_ne_one\n  have hfc := mod_by_monic_add_div (f * c) hg₂\n  have hfd := mod_by_monic_add_div (f * d) hg₁\n  field_simp\n  norm_cast\n  linear_combination -1 * f * hcd + -1 * g₁ * hfc + -1 * g₂ * hfd\n#align div_eq_quo_add_rem_div_add_rem_div div_eq_quo_add_rem_div_add_rem_div\n\n"}