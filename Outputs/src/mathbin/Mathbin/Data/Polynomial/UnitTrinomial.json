{"trinomial_trailing_coeff'":
 "theorem trinomial_trailing_coeff' (hkm : k < m) (hmn : m < n) : (trinomial k m n u v w).coeff k = u := by\n  rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow, if_pos rfl,\n    if_neg hkm.ne, if_neg (hkm.trans hmn).ne, add_zero, add_zero]\n#align trinomial_trailing_coeff' trinomial_trailing_coeff'\n\n",
 "trinomial_trailing_coeff":
 "theorem trinomial_trailing_coeff (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) :\n    (trinomial k m n u v w).trailing_coeff = u := by\n  rw [trailing_coeff, trinomial_nat_trailing_degree hkm hmn hu, trinomial_trailing_coeff' hkm hmn]\n#align trinomial_trailing_coeff trinomial_trailing_coeff\n\n",
 "trinomial_support":
 "theorem trinomial_support (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) (hv : v ≠ 0) (hw : w ≠ 0) :\n    (trinomial k m n u v w).support = {k, m, n} :=\n  support_trinomial hkm hmn hu hv hw\n#align trinomial_support trinomial_support\n\n",
 "trinomial_nat_trailing_degree":
 "theorem trinomial_nat_trailing_degree (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) :\n    (trinomial k m n u v w).nat_trailing_degree = k :=\n  by\n  refine'\n    nat_trailing_degree_eq_of_trailing_degree_eq_some\n      ((finset.le_inf fun i h => _).antisymm <|\n          le_trailing_degree_of_ne_zero <| by rwa [trinomial_trailing_coeff' hkm hmn]).symm\n  replace h := support_trinomial' k m n u v w h\n  rw [mem_insert, mem_insert, mem_singleton] at h\n  rcases h with (rfl | rfl | rfl)\n  · exact le_rfl\n  · exact with_top.coe_le_coe.mpr hkm.le\n  · exact with_top.coe_le_coe.mpr (hkm.trans hmn).le\n#align trinomial_nat_trailing_degree trinomial_nat_trailing_degree\n\n",
 "trinomial_nat_degree":
 "theorem trinomial_nat_degree (hkm : k < m) (hmn : m < n) (hw : w ≠ 0) : (trinomial k m n u v w).nat_degree = n :=\n  by\n  refine'\n    nat_degree_eq_of_degree_eq_some\n      ((finset.sup_le fun i h => _).antisymm <| le_degree_of_ne_zero <| by rwa [trinomial_leading_coeff' hkm hmn])\n  replace h := support_trinomial' k m n u v w h\n  rw [mem_insert, mem_insert, mem_singleton] at h\n  rcases h with (rfl | rfl | rfl)\n  · exact with_bot.coe_le_coe.mpr (hkm.trans hmn).le\n  · exact with_bot.coe_le_coe.mpr hmn.le\n  · exact le_rfl\n#align trinomial_nat_degree trinomial_nat_degree\n\n",
 "trinomial_monic":
 "theorem trinomial_monic (hkm : k < m) (hmn : m < n) : (trinomial k m n u v 1).monic :=\n  by\n  cases' subsingleton_or_nontrivial R with h h\n  · apply subsingleton.elim\n  · exact trinomial_leading_coeff hkm hmn one_ne_zero\n#align trinomial_monic trinomial_monic\n\n",
 "trinomial_mirror":
 "theorem trinomial_mirror (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) (hw : w ≠ 0) :\n    (trinomial k m n u v w).mirror = trinomial k (n - m + k) n w v u := by\n  rw [mirror, trinomial_nat_trailing_degree hkm hmn hu, reverse, trinomial_nat_degree hkm hmn hw, trinomial_def,\n    reflect_add, reflect_add, reflect_C_mul_X_pow, reflect_C_mul_X_pow, reflect_C_mul_X_pow,\n    rev_at_le (hkm.trans hmn).le, rev_at_le hmn.le, rev_at_le le_rfl, add_mul, add_mul, mul_assoc, mul_assoc, mul_assoc,\n    ← pow_add, ← pow_add, ← pow_add, nat.sub_add_cancel (hkm.trans hmn).le, nat.sub_self, zero_add, add_comm,\n    add_comm (C u * X ^ n), ← add_assoc, ← trinomial_def]\n#align trinomial_mirror trinomial_mirror\n\n",
 "trinomial_middle_coeff":
 "theorem trinomial_middle_coeff (hkm : k < m) (hmn : m < n) : (trinomial k m n u v w).coeff m = v := by\n  rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow, if_neg hkm.ne',\n    if_pos rfl, if_neg hmn.ne, zero_add, add_zero]\n#align trinomial_middle_coeff trinomial_middle_coeff\n\n",
 "trinomial_leading_coeff'":
 "theorem trinomial_leading_coeff' (hkm : k < m) (hmn : m < n) : (trinomial k m n u v w).coeff n = w := by\n  rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,\n    if_neg (hkm.trans hmn).ne', if_neg hmn.ne', if_pos rfl, zero_add, zero_add]\n#align trinomial_leading_coeff' trinomial_leading_coeff'\n\n",
 "trinomial_leading_coeff":
 "theorem trinomial_leading_coeff (hkm : k < m) (hmn : m < n) (hw : w ≠ 0) : (trinomial k m n u v w).leading_coeff = w :=\n  by rw [leading_coeff, trinomial_nat_degree hkm hmn hw, trinomial_leading_coeff' hkm hmn]\n#align trinomial_leading_coeff trinomial_leading_coeff\n\n",
 "trinomial_def":
 "/-\nCopyright (c) 2022 Thomas Browning. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning\n-/\ntheorem trinomial_def : trinomial k m n u v w = C u * X ^ k + C v * X ^ m + C w * X ^ n :=\n  rfl\n#align trinomial_def trinomial_def\n\n",
 "trailing_coeff_is_unit":
 "theorem trailing_coeff_is_unit (hp : p.is_unit_trinomial) : is_unit p.trailing_coeff :=\n  hp.coeff_is_unit (nat_trailing_degree_mem_support_of_nonzero hp.ne_zero)\n#align trailing_coeff_is_unit trailing_coeff_is_unit\n\n",
 "not_is_unit":
 "theorem not_is_unit (hp : p.is_unit_trinomial) : ¬is_unit p :=\n  by\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩ := hp\n  exact fun h =>\n    ne_zero_of_lt hmn\n      ((trinomial_nat_degree hkm hmn w.ne_zero).symm.trans\n        (nat_degree_eq_of_degree_eq_some (degree_eq_zero_of_is_unit h)))\n#align not_is_unit not_is_unit\n\n",
 "ne_zero":
 "theorem ne_zero (hp : p.is_unit_trinomial) : p ≠ 0 := by\n  rintro rfl\n  exact Nat.zero_ne_bit1 1 hp.card_support_eq_three\n#align ne_zero ne_zero\n\n",
 "leading_coeff_is_unit":
 "theorem leading_coeff_is_unit (hp : p.is_unit_trinomial) : is_unit p.leading_coeff :=\n  hp.coeff_is_unit (nat_degree_mem_support_of_nonzero hp.ne_zero)\n#align leading_coeff_is_unit leading_coeff_is_unit\n\n",
 "is_unit_trinomial_iff''":
 "theorem is_unit_trinomial_iff'' (h : p * p.mirror = q * q.mirror) : p.is_unit_trinomial ↔ q.is_unit_trinomial := by\n  rw [is_unit_trinomial_iff', is_unit_trinomial_iff', h]\n#align is_unit_trinomial_iff'' is_unit_trinomial_iff''\n\n",
 "is_unit_trinomial_iff'":
 "theorem is_unit_trinomial_iff' :\n    p.is_unit_trinomial ↔\n      (p * p.mirror).coeff (((p * p.mirror).nat_degree + (p * p.mirror).nat_trailing_degree) / 2) = 3 :=\n  by\n  rw [nat_degree_mul_mirror, nat_trailing_degree_mul_mirror, ← mul_add, nat.mul_div_right _ zero_lt_two,\n    coeff_mul_mirror]\n  refine' ⟨_, fun hp => _⟩\n  · rintro ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩\n    rw [sum_def, trinomial_support hkm hmn u.ne_zero v.ne_zero w.ne_zero,\n      sum_insert (mt mem_insert.mp (not_or_of_not hkm.ne (mt mem_singleton.mp (hkm.trans hmn).ne))),\n      sum_insert (mt mem_singleton.mp hmn.ne), sum_singleton, trinomial_leading_coeff' hkm hmn,\n      trinomial_middle_coeff hkm hmn, trinomial_trailing_coeff' hkm hmn]\n    simp_rw [← Units.val_pow_eq_pow_val, Int.units_sq, Units.val_one, ← add_assoc, bit1, bit0]\n  · have key : ∀ k ∈ p.support, p.coeff k ^ 2 = 1 := fun k hk =>\n      Int.sq_eq_one_of_sq_le_three ((single_le_sum (fun k hk => sq_nonneg (p.coeff k)) hk).trans hp.le)\n        (mem_support_iff.mp hk)\n    refine' is_unit_trinomial_iff.mpr ⟨_, fun k hk => isUnit_ofPowEqOne (key k hk) two_ne_zero⟩\n    rw [sum_def, sum_congr rfl key, sum_const, Nat.smul_one_eq_coe] at hp\n    exact Nat.cast_injective hp\n#align is_unit_trinomial_iff' is_unit_trinomial_iff'\n\n",
 "is_unit_trinomial_iff":
 "theorem is_unit_trinomial_iff : p.is_unit_trinomial ↔ p.support.card = 3 ∧ ∀ k ∈ p.support, is_unit (p.coeff k) :=\n  by\n  refine' ⟨fun hp => ⟨hp.card_support_eq_three, fun k => hp.coeff_is_unit⟩, fun hp => _⟩\n  obtain ⟨k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl⟩ := card_support_eq_three.mp hp.1\n  rw [support_trinomial hkm hmn hx hy hz] at hp\n  replace hx := hp.2 k (mem_insert_self k {m, n})\n  replace hy := hp.2 m (mem_insert_of_mem (mem_insert_self m {n}))\n  replace hz := hp.2 n (mem_insert_of_mem (mem_insert_of_mem (mem_singleton_self n)))\n  simp_rw [coeff_add, coeff_C_mul, coeff_X_pow_self, mul_one, coeff_X_pow] at hx hy hz\n  rw [if_neg hkm.ne, if_neg (hkm.trans hmn).ne] at hx\n  rw [if_neg hkm.ne', if_neg hmn.ne] at hy\n  rw [if_neg (hkm.trans hmn).ne', if_neg hmn.ne'] at hz\n  simp_rw [mul_zero, zero_add, add_zero] at hx hy hz\n  exact ⟨k, m, n, hkm, hmn, hx.unit, hy.unit, hz.unit, rfl⟩\n#align is_unit_trinomial_iff is_unit_trinomial_iff\n\n",
 "irreducible_of_is_coprime":
 "/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem irreducible_of_is_coprime (hp : p.is_unit_trinomial) (h : IsCoprime p p.mirror) : Irreducible p :=\n  irreducible_of_coprime hp fun q => h.is_unit_of_dvd'\n#align irreducible_of_is_coprime irreducible_of_is_coprime\n\n",
 "irreducible_of_coprime'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem irreducible_of_coprime' (hp : is_unit_trinomial p)\n    (h : ∀ z : exprℂ, ¬(aeval z p = 0 ∧ aeval z (mirror p) = 0)) : Irreducible p :=\n  by\n  refine' hp.irreducible_of_coprime fun q hq hq' => _\n  suffices ¬0 < q.nat_degree by\n    rcases hq with ⟨p, rfl⟩\n    replace hp := hp.leading_coeff_is_unit\n    rw [leading_coeff_mul] at hp\n    replace hp := isUnit_of_mul_isUnit_left hp\n    rw [not_lt, le_zero_iff] at this\n    rwa [eq_C_of_nat_degree_eq_zero this, is_unit_C, ← this]\n  intro hq''\n  rw [nat_degree_pos_iff_degree_pos] at hq''\n  rw [← degree_map_eq_of_injective (algebra_map ℤ (exprℂ)).injective_int] at hq''\n  cases' complex.exists_root hq'' with z hz\n  rw [is_root, eval_map, ← aeval_def] at hz\n  refine' h z ⟨_, _⟩\n  · cases' hq with g' hg'\n    rw [hg', aeval_mul, hz, zero_mul]\n  · cases' hq' with g' hg'\n    rw [hg', aeval_mul, hz, zero_mul]\n#align irreducible_of_coprime' irreducible_of_coprime'\n\n",
 "irreducible_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem irreducible_of_coprime (hp : p.is_unit_trinomial) (h : ∀ q : polynomial ℤ, q ∣ p → q ∣ p.mirror → is_unit q) :\n    Irreducible p := by\n  refine' irreducible_of_mirror hp.not_is_unit (fun q hpq => _) h\n  have hq : is_unit_trinomial q := (is_unit_trinomial_iff'' hpq).mp hp\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, hp⟩ := hp\n  obtain ⟨k', m', n', hkm', hmn', x, y, z, hq⟩ := hq\n  have hk : k = k' := by\n    rw [← mul_right_inj' (show 2 ≠ 0 from two_ne_zero), ← trinomial_nat_trailing_degree hkm hmn u.ne_zero, ← hp, ←\n      nat_trailing_degree_mul_mirror, hpq, nat_trailing_degree_mul_mirror, hq,\n      trinomial_nat_trailing_degree hkm' hmn' x.ne_zero]\n  have hn : n = n' := by\n    rw [← mul_right_inj' (show 2 ≠ 0 from two_ne_zero), ← trinomial_nat_degree hkm hmn w.ne_zero, ← hp, ←\n      nat_degree_mul_mirror, hpq, nat_degree_mul_mirror, hq, trinomial_nat_degree hkm' hmn' z.ne_zero]\n  subst hk\n  subst hn\n  rcases eq_or_eq_neg_of_sq_eq_sq (↑y) (↑v) ((Int.isUnit_sq y.is_unit).trans (Int.isUnit_sq v.is_unit).symm) with\n    (h1 | h1)\n  · rw [h1] at *\n    rcases irreducible_aux3 hkm hmn hkm' hmn' u v w x z hp hq hpq with (h2 | h2)\n    · exact or.inl h2\n    · exact or.inr (or.inr (or.inl h2))\n  · rw [h1] at *\n    rw [trinomial_def] at hp\n    rw [← neg_inj, neg_add, neg_add, ← neg_mul, ← neg_mul, ← neg_mul, ← C_neg, ← C_neg, ← C_neg] at hp\n    rw [← neg_mul_neg, ← mirror_neg] at hpq\n    rcases irreducible_aux3 hkm hmn hkm' hmn' (-u) (-v) (-w) x z hp hq hpq with (rfl | rfl)\n    · exact or.inr (or.inl rfl)\n    · exact or.inr (or.inr (or.inr p.mirror_neg))\n#align irreducible_of_coprime irreducible_of_coprime\n\n",
 "irreducible_aux3":
 "theorem irreducible_aux3 {k m m' n : ℕ} (hkm : k < m) (hmn : m < n) (hkm' : k < m') (hmn' : m' < n)\n    (u v w x z : Units ℤ) (hp : p = trinomial k m n u v w) (hq : q = trinomial k m' n x v z)\n    (h : p * p.mirror = q * q.mirror) : q = p ∨ q = p.mirror :=\n  by\n  have hmul := congr_arg leading_coeff h\n  rw [leading_coeff_mul, leading_coeff_mul, mirror_leading_coeff, mirror_leading_coeff, hp, hq,\n    trinomial_leading_coeff hkm hmn w.ne_zero, trinomial_leading_coeff hkm' hmn' z.ne_zero,\n    trinomial_trailing_coeff hkm hmn u.ne_zero, trinomial_trailing_coeff hkm' hmn' x.ne_zero] at hmul\n  have hadd := congr_arg (eval 1) h\n  rw [eval_mul, eval_mul, mirror_eval_one, mirror_eval_one, ← sq, ← sq, hp, hq] at hadd\n  simp only [eval_add, eval_C_mul, eval_pow, eval_X, one_pow, mul_one, trinomial_def] at hadd\n  rw [add_assoc, add_assoc, add_comm ↑u, add_comm ↑x, add_assoc, add_assoc] at hadd\n  simp only [add_sq', add_assoc, add_right_inj, ← Units.val_pow_eq_pow_val, Int.units_sq] at hadd\n  rw [mul_assoc, hmul, ← mul_assoc, add_right_inj,\n    mul_right_inj' (show 2 * (v : ℤ) ≠ 0 from mul_ne_zero two_ne_zero v.ne_zero)] at hadd\n  replace hadd := (Int.isUnit_add_isUnit_eq_isUnit_add_isUnit w.is_unit u.is_unit z.is_unit x.is_unit).mp hadd\n  simp only [Units.eq_iff] at hadd\n  rcases hadd with (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n  · exact irreducible_aux2 hkm hmn hkm' hmn' u v w hp hq h\n  · rw [← mirror_inj, trinomial_mirror hkm' hmn' w.ne_zero u.ne_zero] at hq\n    rw [mul_comm q, ← q.mirror_mirror, q.mirror.mirror_mirror] at h\n    rw [← mirror_inj, or_comm', ← mirror_eq_iff]\n    exact\n      irreducible_aux2 hkm hmn (lt_add_of_pos_left k (tsub_pos_of_lt hmn'))\n        (lt_tsub_iff_right.mp ((tsub_lt_tsub_iff_left_of_le hmn'.le).mpr hkm')) u v w hp hq h\n#align irreducible_aux3 irreducible_aux3\n\n",
 "irreducible_aux2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem irreducible_aux2 {k m m' n : ℕ} (hkm : k < m) (hmn : m < n) (hkm' : k < m') (hmn' : m' < n) (u v w : Units ℤ)\n    (hp : p = trinomial k m n u v w) (hq : q = trinomial k m' n u v w) (h : p * p.mirror = q * q.mirror) :\n    q = p ∨ q = p.mirror :=\n  by\n  let f : polynomial ℤ → polynomial ℤ := fun p => ⟨finsupp.filter (Set.Ioo (k + n) (n + n)) p.to_finsupp⟩\n  replace h := congr_arg f h\n  replace h := (irreducible_aux1 hkm hmn u v w hp).trans h\n  replace h := h.trans (irreducible_aux1 hkm' hmn' u v w hq).symm\n  rw [(is_unit_C.mpr v.is_unit).mul_right_inj] at h\n  rw [binomial_eq_binomial u.ne_zero w.ne_zero] at h\n  simp only [add_left_inj, Units.eq_iff] at h\n  rcases h with (⟨rfl, -⟩ | ⟨rfl, rfl, h⟩ | ⟨-, hm, hm'⟩)\n  · exact or.inl (hq.trans hp.symm)\n  · refine' or.inr _\n    rw [← trinomial_mirror hkm' hmn' u.ne_zero u.ne_zero, eq_comm, mirror_eq_iff] at hp\n    exact hq.trans hp\n  · suffices m = m' by\n      rw [this] at hp\n      exact or.inl (hq.trans hp.symm)\n    rw [tsub_add_eq_add_tsub hmn.le, eq_tsub_iff_add_eq_of_le, ← two_mul] at hm\n    rw [tsub_add_eq_add_tsub hmn'.le, eq_tsub_iff_add_eq_of_le, ← two_mul] at hm'\n    exact mul_left_cancel₀ two_ne_zero (hm.trans hm'.symm)\n    exact hmn'.le.trans (nat.le_add_right n k)\n    exact hmn.le.trans (nat.le_add_right n k)\n#align irreducible_aux2 irreducible_aux2\n\n",
 "irreducible_aux1":
 "theorem irreducible_aux1 {k m n : ℕ} (hkm : k < m) (hmn : m < n) (u v w : Units ℤ) (hp : p = trinomial k m n u v w) :\n    C ↑v * (C ↑u * X ^ (m + n) + C ↑w * X ^ (n - m + k + n)) =\n      ⟨finsupp.filter (Set.Ioo (k + n) (n + n)) (p * p.mirror).to_finsupp⟩ :=\n  by\n  have key : n - m + k < n := by rwa [← lt_tsub_iff_right, tsub_lt_tsub_iff_left_of_le hmn.le]\n  rw [hp, trinomial_mirror hkm hmn u.ne_zero w.ne_zero]\n  simp_rw [trinomial_def, C_mul_X_pow_eq_monomial, add_mul, mul_add, monomial_mul_monomial, to_finsupp_add,\n    to_finsupp_monomial, finsupp.filter_add]\n  rw [finsupp.filter_single_of_neg, finsupp.filter_single_of_neg, finsupp.filter_single_of_neg,\n    finsupp.filter_single_of_neg, finsupp.filter_single_of_neg, finsupp.filter_single_of_pos,\n    finsupp.filter_single_of_neg, finsupp.filter_single_of_pos, finsupp.filter_single_of_neg]\n  · simp only [add_zero, zero_add, of_finsupp_add, of_finsupp_single]\n    rw [C_mul_monomial, C_mul_monomial, mul_comm ↑v ↑w, add_comm (n - m + k) n]\n  · exact fun h => h.2.ne rfl\n  · refine' ⟨_, add_lt_add_left key n⟩\n    rwa [add_comm, add_lt_add_iff_left, lt_add_iff_pos_left, tsub_pos_iff_lt]\n  · exact fun h => h.1.ne (add_comm k n)\n  · exact ⟨add_lt_add_right hkm n, add_lt_add_right hmn n⟩\n  · rw [← add_assoc, add_tsub_cancel_of_le hmn.le, add_comm]\n    exact fun h => h.1.ne rfl\n  · intro h\n    have := h.1\n    rw [add_comm, add_lt_add_iff_right] at this\n    exact asymm this hmn\n  · exact fun h => h.1.ne rfl\n  · exact fun h => asymm ((add_lt_add_iff_left k).mp h.1) key\n  · exact fun h => asymm ((add_lt_add_iff_left k).mp h.1) (hkm.trans hmn)\n#align irreducible_aux1 irreducible_aux1\n\n",
 "coeff_is_unit":
 "theorem coeff_is_unit (hp : p.is_unit_trinomial) {k : ℕ} (hk : k ∈ p.support) : is_unit (p.coeff k) :=\n  by\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩ := hp\n  have := support_trinomial' k m n (↑u) (↑v) (↑w) hk\n  rw [mem_insert, mem_insert, mem_singleton] at this\n  rcases this with (rfl | rfl | rfl)\n  · refine' ⟨u, by rw [trinomial_trailing_coeff' hkm hmn]⟩\n  · refine' ⟨v, by rw [trinomial_middle_coeff hkm hmn]⟩\n  · refine' ⟨w, by rw [trinomial_leading_coeff' hkm hmn]⟩\n#align coeff_is_unit coeff_is_unit\n\n",
 "card_support_eq_three":
 "theorem card_support_eq_three (hp : p.is_unit_trinomial) : p.support.card = 3 :=\n  by\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩ := hp\n  exact card_support_trinomial hkm hmn u.ne_zero v.ne_zero w.ne_zero\n#align card_support_eq_three card_support_eq_three\n\n"}