{"zero_is_root_of_coeff_zero_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem zero_is_root_of_coeff_zero_eq_zero {p : polynomial R} (hp : p.coeff 0 = 0) : is_root p 0 := by\n  rwa [coeff_zero_eq_eval_zero] at hp\n#align zero_is_root_of_coeff_zero_eq_zero zero_is_root_of_coeff_zero_eq_zero\n\n",
 "zero_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem zero_comp : comp (0 : polynomial R) p = 0 := by rw [← C_0, C_comp]\n#align zero_comp zero_comp\n\n",
 "support_map_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem support_map_subset [Semiring R] [Semiring S] (f : «expr →+* » R S) (p : polynomial R) :\n    (map f p).support ⊆ p.support := by\n  intro x\n  contrapose!\n  simp (config := { contextual := true })\n#align support_map_subset support_map_subset\n\n",
 "support_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem support_map_of_injective [Semiring R] [Semiring S] (p : polynomial R) {f : «expr →+* » R S}\n    (hf : function.injective f) : (map f p).support = p.support := by\n  simp_rw [Finset.ext_iff, mem_support_iff, coeff_map, ← map_zero f, hf.ne_iff, iff_self_iff, forall_const]\n#align support_map_of_injective support_map_of_injective\n\n",
 "sub_comp":
 "@[simp]\ntheorem sub_comp : (p - q).comp r = p.comp r - q.comp r :=\n  eval₂_sub _\n#align sub_comp sub_comp\n\n",
 "smul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_comp [monoid S] [DistribMulAction S R] [IsScalarTower S R R] (s : S) (p q : polynomial R) :\n    («expr • » s p).comp q = «expr • » s (p.comp q) := by\n  rw [← smul_one_smul R s p, comp, comp, eval₂_smul, ← smul_eq_C_mul, smul_assoc, one_smul]\n#align smul_comp smul_comp\n\n",
 "root_mul_right_of_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_mul_right_of_is_root {p : polynomial R} (q : polynomial R) : is_root p a → is_root (p * q) a := fun H => by\n  rw [is_root, eval_mul, is_root.def.1 H, zero_mul]\n#align root_mul_right_of_is_root root_mul_right_of_is_root\n\n",
 "root_mul_left_of_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_mul_left_of_is_root (p : polynomial R) {q : polynomial R} : is_root q a → is_root (p * q) a := fun H => by\n  rw [is_root, eval_mul, is_root.def.1 H, mul_zero]\n#align root_mul_left_of_is_root root_mul_left_of_is_root\n\n",
 "root_X_sub_C":
 "theorem root_X_sub_C : is_root (X - C a) b ↔ a = b := by\n  rw [is_root.def, eval_sub, eval_X, eval_C, sub_eq_zero, eq_comm]\n#align root_X_sub_C root_X_sub_C\n\n",
 "prod_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_comp {ι : Type _} (s : Finset ι) (p : ι → polynomial R) (q : polynomial R) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p j)).comp q =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ((p j).comp q) :=\n  map_prod (comp_ring_hom q) _ _\n#align prod_comp prod_comp\n\n",
 "pow_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem pow_comp {R : Type _} [CommSemiring R] (p q : polynomial R) (n : ℕ) : (p ^ n).comp q = p.comp q ^ n :=\n  ((monoid_hom.mk fun r : polynomial R => r.comp q) one_comp fun r s => mul_comp r s q).map_pow p n\n#align pow_comp pow_comp\n\n",
 "one_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem one_comp : comp (1 : polynomial R) p = 1 := by rw [← C_1, C_comp]\n#align one_comp one_comp\n\n",
 "of_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_root.of_map {R} [CommRing R] {f : «expr →+* » R S} {x : R} {p : polynomial R} (h : is_root (p.map f) (f x))\n    (hf : function.injective f) : is_root p x := by\n  rwa [is_root, ← (injective_iff_map_eq_zero' f).mp hf, ← eval₂_hom, ← eval_map]\n#align is_root.of_map is_root.of_map\n\n",
 "not_is_root_C":
 "theorem not_is_root_C (r a : R) (hr : r ≠ 0) : ¬is_root (C r) a := by simpa using hr\n#align not_is_root_C not_is_root_C\n\n",
 "neg_comp":
 "@[simp]\ntheorem neg_comp : (-p).comp q = -p.comp q :=\n  eval₂_neg _\n#align neg_comp neg_comp\n\n",
 "nat_degree_map_of_leading_coeff_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem nat_degree_map_of_leading_coeff_ne_zero (f : «expr →+* » R S) (hf : f (leading_coeff p) ≠ 0) :\n    nat_degree (p.map f) = nat_degree p :=\n  nat_degree_eq_of_degree_eq (degree_map_eq_of_leading_coeff_ne_zero f hf)\n#align nat_degree_map_of_leading_coeff_ne_zero nat_degree_map_of_leading_coeff_ne_zero\n\n",
 "nat_degree_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_map_le (p : polynomial R) : nat_degree (p.map f) ≤ nat_degree p :=\n  nat_degree_le_nat_degree (degree_map_le f p)\n#align nat_degree_map_le nat_degree_map_le\n\n",
 "nat_cast_mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_cast_mul_comp {n : ℕ} : ((n : polynomial R) * p).comp r = n * p.comp r := by\n  rw [← C_eq_nat_cast, C_mul_comp, C_eq_nat_cast]\n#align nat_cast_mul_comp nat_cast_mul_comp\n\n",
 "nat_cast_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_cast_comp {n : ℕ} : (n : polynomial R).comp p = n := by rw [← C_eq_nat_cast, C_comp]\n#align nat_cast_comp nat_cast_comp\n\n",
 "multiset_prod_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem multiset_prod_comp (s : Multiset (polynomial R)) (q : polynomial R) :\n    s.prod.comp q = (s.map fun p : polynomial R => p.comp q).prod :=\n  map_multiset_prod (comp_ring_hom q) _\n#align multiset_prod_comp multiset_prod_comp\n\n",
 "mul_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem mul_comp {R : Type _} [CommSemiring R] (p q r : polynomial R) : (p * q).comp r = p.comp r * q.comp r :=\n  eval₂_mul _ _\n#align mul_comp mul_comp\n\n",
 "mul_X_pow_comp":
 "@[simp]\ntheorem mul_X_pow_comp {k : ℕ} : (p * X ^ k).comp r = p.comp r * r ^ k :=\n  by\n  induction' k with k ih\n  · simp\n  · simp [ih, pow_succ', ← mul_assoc, mul_X_comp]\n#align mul_X_pow_comp mul_X_pow_comp\n\n",
 "mul_X_comp":
 "@[simp]\ntheorem mul_X_comp : (p * X).comp r = p.comp r * r :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q hp hq\n    simp only [hp, hq, add_mul, add_comp]\n  · intro n b\n    simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp]\n#align mul_X_comp mul_X_comp\n\n",
 "monomial_comp":
 "@[simp]\ntheorem monomial_comp (n : ℕ) : (monomial n a).comp p = C a * p ^ n :=\n  eval₂_monomial _ _\n#align monomial_comp monomial_comp\n\n",
 "mem_map_srange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_map_srange {p : polynomial S} : p ∈ (map_ring_hom f).srange ↔ ∀ n, p.coeff n ∈ f.srange :=\n  by\n  constructor\n  · rintro ⟨p, rfl⟩ n\n    rw [coe_map_ring_hom, coeff_map]\n    exact Set.mem_range_self _\n  · intro h\n    rw [p.as_sum_range_C_mul_X_pow]\n    refine' (map_ring_hom f).srange.sum_mem _\n    intro i hi\n    rcases h i with ⟨c, hc⟩\n    use C c * X ^ i\n    rw [coe_map_ring_hom, polynomial.map_mul, map_C, hc, polynomial.map_pow, map_X]\n#align mem_map_srange mem_map_srange\n\n",
 "mem_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_map_range {R S : Type _} [Ring R] [Ring S] (f : «expr →+* » R S) {p : polynomial S} :\n    p ∈ (map_ring_hom f).range ↔ ∀ n, p.coeff n ∈ f.range :=\n  mem_map_srange f\n#align mem_map_range mem_map_range\n\n",
 "map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print map_zero /-\n@[simp]\nprotected theorem map_zero : (0 : polynomial R).map f = 0 :=\n  eval₂_zero _ _\n#align map_zero map_zero\n-/\n\n",
 "map_surjective":
 "theorem map_surjective (hf : function.surjective f) : function.surjective (map f) := fun p =>\n  polynomial.induction_on' p\n    (fun p q hp hq =>\n      let ⟨p', hp'⟩ := hp\n      let ⟨q', hq'⟩ := hq\n      ⟨p' + q', by rw [polynomial.map_add f, hp', hq']⟩)\n    fun n s =>\n    let ⟨r, hr⟩ := hf s\n    ⟨monomial n r, by rw [map_monomial f, hr]⟩\n#align map_surjective map_surjective\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\nprotected theorem map_sum {ι : Type _} (g : ι → polynomial R) (s : Finset ι) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)).map f =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s ((g i).map f) :=\n  (map_ring_hom f).map_sum _ _\n#align map_sum map_sum\n\n",
 "map_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print map_sub /-\n@[simp]\nprotected theorem map_sub {S} [Ring S] (f : «expr →+* » R S) : (p - q).map f = p.map f - q.map f :=\n  (map_ring_hom f).map_sub p q\n#align map_sub map_sub\n-/\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\nprotected theorem map_smul (r : R) : («expr • » r p).map f = «expr • » (f r) (p.map f) := by\n  rw [map, eval₂_smul, RingHom.comp_apply, C_mul']\n#align map_smul map_smul\n\n",
 "map_ring_hom_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem map_ring_hom_id : map_ring_hom (RingHom.id R) = RingHom.id (polynomial R) :=\n  RingHom.ext fun x => map_id\n#align map_ring_hom_id map_ring_hom_id\n\n",
 "map_ring_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_ring_hom_comp [Semiring T] (f : «expr →+* » S T) (g : «expr →+* » R S) :\n    (map_ring_hom f).comp (map_ring_hom g) = map_ring_hom (f.comp g) :=\n  RingHom.ext <| polynomial.map_map g f\n#align map_ring_hom_comp map_ring_hom_comp\n\n",
 "map_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\nprotected theorem map_prod {ι : Type _} (g : ι → polynomial R) (s : Finset ι) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)).map f =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ((g i).map f) :=\n  (map_ring_hom f).map_prod _ _\n#align map_prod map_prod\n\n",
 "map_pow":
 "#print map_pow /-\n@[simp]\nprotected theorem map_pow (n : ℕ) : (p ^ n).map f = p.map f ^ n :=\n  (map_ring_hom f).map_pow _ _\n#align map_pow map_pow\n-/\n\n",
 "map_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print map_one /-\n@[simp]\nprotected theorem map_one : (1 : polynomial R).map f = 1 :=\n  eval₂_one _ _\n#align map_one map_one\n-/\n\n",
 "map_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print map_neg /-\n@[simp]\nprotected theorem map_neg {S} [Ring S] (f : «expr →+* » R S) : (-p).map f = -p.map f :=\n  (map_ring_hom f).map_neg p\n#align map_neg map_neg\n-/\n\n",
 "map_ne_zero_iff":
 "#print map_ne_zero_iff /-\nprotected theorem map_ne_zero_iff (hf : function.injective f) : p.map f ≠ 0 ↔ p ≠ 0 :=\n  (polynomial.map_eq_zero_iff hf).not\n#align map_ne_zero_iff map_ne_zero_iff\n-/\n\n",
 "map_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- This is protected to not clash with the global `map_nat_cast`.\n@[simp]\nprotected theorem map_nat_cast (n : ℕ) : (n : polynomial R).map f = n :=\n  map_nat_cast (map_ring_hom f) n\n#align map_nat_cast map_nat_cast\n\n",
 "map_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print map_multiset_prod /-\nprotected theorem map_multiset_prod (m : Multiset (polynomial R)) : m.prod.map f = (m.map <| map f).prod :=\n  eq.symm <| Multiset.prod_hom _ (map_ring_hom f).to_monoid_hom\n#align map_multiset_prod map_multiset_prod\n-/\n\n",
 "map_mul":
 "#print map_mul /-\n@[simp]\nprotected theorem map_mul : (p * q).map f = p.map f * q.map f :=\n  by\n  rw [map, eval₂_mul_noncomm]\n  exact fun k => (commute_X _).symm\n#align map_mul map_mul\n-/\n\n",
 "map_monomial":
 "@[simp]\ntheorem map_monomial {n a} : (monomial n a).map f = monomial n (f a) :=\n  by\n  dsimp only [map]\n  rw [eval₂_monomial, ← C_mul_X_pow_eq_monomial]; rfl\n#align map_monomial map_monomial\n\n",
 "map_monic_ne_zero":
 "theorem map_monic_ne_zero (hp : p.monic) [nontrivial S] : p.map f ≠ 0 := fun h =>\n  f.map_one_ne_zero ((map_monic_eq_zero_iff hp).mp h _)\n#align map_monic_ne_zero map_monic_ne_zero\n\n",
 "map_monic_eq_zero_iff":
 "theorem map_monic_eq_zero_iff (hp : p.monic) : p.map f = 0 ↔ ∀ x, f x = 0 :=\n  ⟨fun hfp x =>\n    calc\n      f x = f x * f p.leading_coeff := by simp only [mul_one, hp.leading_coeff, f.map_one]\n      _ = f x * (p.map f).coeff p.nat_degree := congr_arg _ (coeff_map _ _).symm\n      _ = 0 := by simp only [hfp, mul_zero, coeff_zero]\n      ,\n    fun h => ext fun n => by simp only [h, coeff_map, coeff_zero]⟩\n#align map_monic_eq_zero_iff map_monic_eq_zero_iff\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_map [Semiring T] (g : «expr →+* » S T) (p : polynomial R) : (p.map f).map g = p.map (g.comp f) :=\n  ext (by simp [coeff_map])\n#align map_map map_map\n\n",
 "map_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print map_list_prod /-\nprotected theorem map_list_prod (L : list (polynomial R)) : L.prod.map f = (L.map <| map f).prod :=\n  eq.symm <| List.prod_hom _ (map_ring_hom f).to_monoid_hom\n#align map_list_prod map_list_prod\n-/\n\n",
 "map_intCast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print map_intCast /-\n@[simp]\ntheorem map_intCast {S} [Ring S] (f : «expr →+* » R S) (n : ℤ) : map f ↑n = ↑n :=\n  map_intCast (map_ring_hom f) n\n#align map_int_cast map_intCast\n-/\n\n",
 "map_injective":
 "theorem map_injective (hf : function.injective f) : function.injective (map f) := fun p q h =>\n  ext fun m => hf <| by rw [← coeff_map f, ← coeff_map f, h]\n#align map_injective map_injective\n\n",
 "map_id":
 "@[simp]\ntheorem map_id : p.map (RingHom.id _) = p := by simp [polynomial.ext_iff, coeff_map]\n#align map_id map_id\n\n",
 "map_eq_zero_iff":
 "#print map_eq_zero_iff /-\nprotected theorem map_eq_zero_iff (hf : function.injective f) : p.map f = 0 ↔ p = 0 :=\n  map_eq_zero_iff (map_ring_hom f) (map_injective f hf)\n#align map_eq_zero_iff map_eq_zero_iff\n-/\n\n",
 "map_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print map_dvd /-\n--TODO rename to `map_dvd_map`\ntheorem map_dvd (f : «expr →+* » R S) {x y : polynomial R} : x ∣ y → x.map f ∣ y.map f :=\n  (map_ring_hom f).map_dvd\n#align map_dvd map_dvd\n-/\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_comp (p q : polynomial R) : map f (p.comp q) = (map f p).comp (map f q) :=\n  polynomial.induction_on p (by simp only [map_C, forall_const, C_comp, eq_self_iff_true])\n    (by\n      simp (config := { contextual := true }) only [polynomial.map_add, add_comp, forall_const, imp_true_iff,\n        eq_self_iff_true])\n    (by\n      simp (config := { contextual := true }) only [pow_succ', ← mul_assoc, comp, forall_const, eval₂_mul_X,\n        imp_true_iff, eq_self_iff_true, map_X, polynomial.map_mul])\n#align map_comp map_comp\n\n",
 "map_bit1":
 "@[simp]\nprotected theorem map_bit1 : (bit1 p).map f = bit1 (p.map f) :=\n  map_bit1 (map_ring_hom f) p\n#align map_bit1 map_bit1\n\n",
 "map_bit0":
 "#print map_bit0 /-\n@[simp]\nprotected theorem map_bit0 : (bit0 p).map f = bit0 (p.map f) :=\n  map_bit0 (map_ring_hom f) p\n#align map_bit0 map_bit0\n-/\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\nprotected theorem map_add : (p + q).map f = p.map f + q.map f :=\n  eval₂_add _ _\n#align map_add map_add\n-/\n\n",
 "map_X":
 "@[simp]\ntheorem map_X : X.map f = X :=\n  eval₂_X _ _\n#align map_X map_X\n\n",
 "map_C":
 "@[simp]\ntheorem map_C : (C a).map f = C (f a) :=\n  eval₂_C _ _\n#align map_C map_C\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_root.map {f : «expr →+* » R S} {x : R} {p : polynomial R} (h : is_root p x) : is_root (p.map f) (f x) := by\n  rw [is_root, eval_map, eval₂_hom, h.eq_zero, f.map_zero]\n#align is_root.map is_root.map\n\n",
 "list_prod_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem list_prod_comp (l : list (polynomial R)) (q : polynomial R) :\n    l.prod.comp q = (l.map fun p : polynomial R => p.comp q).prod :=\n  map_list_prod (comp_ring_hom q) _\n#align list_prod_comp list_prod_comp\n\n",
 "leading_coeff_map_of_leading_coeff_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem leading_coeff_map_of_leading_coeff_ne_zero (f : «expr →+* » R S) (hf : f (leading_coeff p) ≠ 0) :\n    leading_coeff (p.map f) = f (leading_coeff p) :=\n  by\n  unfold leading_coeff\n  rw [coeff_map, nat_degree_map_of_leading_coeff_ne_zero f hf]\n#align leading_coeff_map_of_leading_coeff_ne_zero leading_coeff_map_of_leading_coeff_ne_zero\n\n",
 "is_root_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem is_root_prod {R} [CommRing R] [IsDomain R] {ι : Type _} (s : Finset ι) (p : ι → polynomial R) (x : R) :\n    is_root (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p j))\n        x ↔\n      ∃ i ∈ s, is_root (p i) x :=\n  by simp only [is_root, eval_prod, finset.prod_eq_zero_iff]\n#align is_root_prod is_root_prod\n\n",
 "is_root_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_root_map_iff {R : Type _} [CommRing R] {f : «expr →+* » R S} {x : R} {p : polynomial R}\n    (hf : function.injective f) : is_root (p.map f) (f x) ↔ is_root p x :=\n  ⟨fun h => h.of_map hf, fun h => h.map⟩\n#align is_root_map_iff is_root_map_iff\n\n",
 "hom_eval₂":
 "theorem hom_eval₂ (x : S) : g (p.eval₂ f x) = p.eval₂ (g.comp f) (g x) := by rw [← eval₂_map, eval₂_at_apply, eval_map]\n#align hom_eval₂ hom_eval₂\n\n",
 "eval₂_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval₂_zero : (0 : polynomial R).eval₂ f x = 0 := by simp [eval₂_eq_sum]\n#align eval₂_zero eval₂_zero\n\n",
 "eval₂_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_sum (p : polynomial T) (g : ℕ → T → polynomial R) (x : S) :\n    (p.sum g).eval₂ f x = p.sum fun n a => (g n a).eval₂ f x :=\n  by\n  let T : «expr →+ » (polynomial R) S :=\n    { to_fun := eval₂ f x\n      map_zero' := eval₂_zero _ _\n      map_add' := fun p q => eval₂_add _ _ }\n  have A : ∀ y, eval₂ f x y = T y := fun y => rfl\n  simp only [A]\n  rw [sum, T.map_sum, sum]\n#align eval₂_sum eval₂_sum\n\n",
 "eval₂_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_sub {S} [Ring S] (f : «expr →+* » R S) {x : S} : (p - q).eval₂ f x = p.eval₂ f x - q.eval₂ f x := by\n  rw [sub_eq_add_neg, eval₂_add, eval₂_neg, sub_eq_add_neg]\n#align eval₂_sub eval₂_sub\n\n",
 "eval₂_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem eval₂_smul (g : «expr →+* » R S) (p : polynomial R) (x : S) {s : R} :\n    eval₂ g x («expr • » s p) = g s * eval₂ g x p :=\n  by\n  have A : p.nat_degree < p.nat_degree.succ := nat.lt_succ_self _\n  have B : («expr • » s p).nat_degree < p.nat_degree.succ := (nat_degree_smul_le _ _).trans_lt A\n  rw [eval₂_eq_sum, eval₂_eq_sum, sum_over_range' _ _ _ A, sum_over_range' _ _ _ B] <;> simp [mul_sum, mul_assoc]\n#align eval₂_smul eval₂_smul\n\n",
 "eval₂_pow":
 "theorem eval₂_pow (n : ℕ) : (p ^ n).eval₂ f x = p.eval₂ f x ^ n :=\n  (eval₂_ring_hom _ _).map_pow _ _\n#align eval₂_pow eval₂_pow\n\n",
 "eval₂_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval₂_one : (1 : polynomial R).eval₂ f x = 1 := by rw [← C_1, eval₂_C, f.map_one]\n#align eval₂_one eval₂_one\n\n",
 "eval₂_of_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_of_finsupp {f : «expr →+* » R S} {x : S} {p : add_monoid_algebra R ℕ} :\n    eval₂ f x (⟨p⟩ : polynomial R) = lift_nc (↑f) (powersHom S x) p :=\n  by\n  simp only [eval₂_eq_sum, sum, to_finsupp_sum, support, coeff]\n  rfl\n#align eval₂_of_finsupp eval₂_of_finsupp\n\n",
 "eval₂_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_neg {S} [Ring S] (f : «expr →+* » R S) {x : S} : (-p).eval₂ f x = -p.eval₂ f x := by\n  rw [eq_neg_iff_add_eq_zero, ← eval₂_add, add_left_neg, eval₂_zero]\n#align eval₂_neg eval₂_neg\n\n",
 "eval₂_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval₂_nat_cast (n : ℕ) : (n : polynomial R).eval₂ f x = n :=\n  by\n  induction' n with n ih\n  · simp only [eval₂_zero, Nat.cast_zero]\n  · rw [n.cast_succ, eval₂_add, ih, eval₂_one, n.cast_succ]\n#align eval₂_nat_cast eval₂_nat_cast\n\n",
 "eval₂_multiset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_multiset_sum (s : Multiset (polynomial R)) (x : S) : eval₂ f x s.sum = (s.map (eval₂ f x)).sum :=\n  map_multiset_sum (eval₂_add_monoid_hom f x) s\n#align eval₂_multiset_sum eval₂_multiset_sum\n\n",
 "eval₂_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_multiset_prod (s : Multiset (polynomial R)) (x : S) : eval₂ f x s.prod = (s.map (eval₂ f x)).prod :=\n  map_multiset_prod (eval₂_ring_hom f x) s\n#align eval₂_multiset_prod eval₂_multiset_prod\n\n",
 "eval₂_mul_noncomm":
 "theorem eval₂_mul_noncomm (hf : ∀ k, Commute (f <| q.coeff k) x) : eval₂ f x (p * q) = eval₂ f x p * eval₂ f x q :=\n  by\n  rcases p with ⟨⟩; rcases q with ⟨⟩\n  simp only [coeff] at hf\n  simp only [← of_finsupp_mul, eval₂_of_finsupp]\n  exact lift_nc_mul _ _ p q fun k n hn => (hf k).pow_right n\n#align eval₂_mul_noncomm eval₂_mul_noncomm\n\n",
 "eval₂_mul_eq_zero_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_mul_eq_zero_of_right (p : polynomial R) (hq : q.eval₂ f x = 0) : (p * q).eval₂ f x = 0 :=\n  by\n  rw [eval₂_mul f x]\n  exact mul_eq_zero_of_right (p.eval₂ f x) hq\n#align eval₂_mul_eq_zero_of_right eval₂_mul_eq_zero_of_right\n\n",
 "eval₂_mul_eq_zero_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_mul_eq_zero_of_left (q : polynomial R) (hp : p.eval₂ f x = 0) : (p * q).eval₂ f x = 0 :=\n  by\n  rw [eval₂_mul f x]\n  exact mul_eq_zero_of_left hp (q.eval₂ f x)\n#align eval₂_mul_eq_zero_of_left eval₂_mul_eq_zero_of_left\n\n",
 "eval₂_mul_X":
 "@[simp]\ntheorem eval₂_mul_X : eval₂ f x (p * X) = eval₂ f x p * x :=\n  by\n  refine' trans (eval₂_mul_noncomm _ _ fun k => _) (by rw [eval₂_X])\n  rcases em (k = 1) with (rfl | hk)\n  · simp\n  · simp [coeff_X_of_ne_one hk]\n#align eval₂_mul_X eval₂_mul_X\n\n",
 "eval₂_mul_C'":
 "theorem eval₂_mul_C' (h : Commute (f a) x) : eval₂ f x (p * C a) = eval₂ f x p * f a :=\n  by\n  rw [eval₂_mul_noncomm, eval₂_C]\n  intro k\n  by_cases hk : k = 0\n  · simp only [hk, h, coeff_C_zero, coeff_C_ne_zero]\n  · simp only [coeff_C_ne_zero hk, RingHom.map_zero, Commute.zero_left]\n#align eval₂_mul_C' eval₂_mul_C'\n\n",
 "eval₂_mul":
 "@[simp]\ntheorem eval₂_mul : (p * q).eval₂ f x = p.eval₂ f x * q.eval₂ f x :=\n  eval₂_mul_noncomm _ _ fun k => Commute.all _ _\n#align eval₂_mul eval₂_mul\n\n",
 "eval₂_monomial":
 "@[simp]\ntheorem eval₂_monomial {n : ℕ} {r : R} : (monomial n r).eval₂ f x = f r * x ^ n := by simp [eval₂_eq_sum]\n#align eval₂_monomial eval₂_monomial\n\n",
 "eval₂_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_map [Semiring T] (g : «expr →+* » S T) (x : T) : (p.map f).eval₂ g x = p.eval₂ (g.comp f) x := by\n  rw [eval₂_eq_eval_map, eval₂_eq_eval_map, map_map]\n#align eval₂_map eval₂_map\n\n",
 "eval₂_list_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_list_sum (l : list (polynomial R)) (x : S) : eval₂ f x l.sum = (l.map (eval₂ f x)).sum :=\n  map_list_sum (eval₂_add_monoid_hom f x) l\n#align eval₂_list_sum eval₂_list_sum\n\n",
 "eval₂_list_prod_noncomm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_list_prod_noncomm (ps : list (polynomial R)) (hf : ∀ p ∈ ps, ∀ (k), Commute (f <| coeff p k) x) :\n    eval₂ f x ps.prod = (ps.map (polynomial.eval₂ f x)).prod :=\n  by\n  induction' ps using List.reverseRecOn with ps p ihp\n  · simp\n  · simp only [List.forall_mem_append, List.forall_mem_singleton] at hf\n    simp [eval₂_mul_noncomm _ _ hf.2, ihp hf.1]\n#align eval₂_list_prod_noncomm eval₂_list_prod_noncomm\n\n",
 "eval₂_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_list_prod (l : list (polynomial R)) (x : S) : eval₂ f x l.prod = (l.map (eval₂ f x)).prod :=\n  map_list_prod (eval₂_ring_hom f x) l\n#align eval₂_list_prod eval₂_list_prod\n\n",
 "eval₂_hom":
 "theorem eval₂_hom (x : R) : p.eval₂ f (f x) = f (p.eval x) :=\n  RingHom.comp_id f ▸ (hom_eval₂ p (RingHom.id R) f x).symm\n#align eval₂_hom eval₂_hom\n\n",
 "eval₂_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval₂_finset_sum (s : Finset ι) (g : ι → polynomial R) (x : S) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)).eval₂ f\n        x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((g i).eval₂ f x) :=\n  map_sum (eval₂_add_monoid_hom f x) _ _\n#align eval₂_finset_sum eval₂_finset_sum\n\n",
 "eval₂_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem eval₂_finset_prod (s : Finset ι) (g : ι → polynomial R) (x : S) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (g i)).eval₂ f\n        x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ((g i).eval₂ f x) :=\n  map_prod (eval₂_ring_hom f x) _ _\n#align eval₂_finset_prod eval₂_finset_prod\n\n",
 "eval₂_eq_zero_of_dvd_of_eval₂_eq_zero":
 "theorem eval₂_eq_zero_of_dvd_of_eval₂_eq_zero (h : p ∣ q) (h0 : eval₂ f x p = 0) : eval₂ f x q = 0 :=\n  zero_dvd_iff.mp (h0 ▸ eval₂_dvd f x h)\n#align eval₂_eq_zero_of_dvd_of_eval₂_eq_zero eval₂_eq_zero_of_dvd_of_eval₂_eq_zero\n\n",
 "eval₂_eq_sum_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval₂_eq_sum_range' (f : «expr →+* » R S) {p : polynomial R} {n : ℕ} (hn : p.nat_degree < n) (x : S) :\n    eval₂ f x p =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (f (p.coeff i) * x ^ i) :=\n  by\n  rw [eval₂_eq_sum, p.sum_over_range' _ _ hn]\n  intro i\n  rw [f.map_zero, zero_mul]\n#align eval₂_eq_sum_range' eval₂_eq_sum_range'\n\n",
 "eval₂_eq_sum_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval₂_eq_sum_range :\n    p.eval₂ f x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (p.nat_degree + 1)) (f (p.coeff i) * x ^ i) :=\n  trans (congr_arg _ p.as_sum_range) (trans (eval₂_finset_sum f _ _ x) (congr_arg _ (by simp)))\n#align eval₂_eq_sum_range eval₂_eq_sum_range\n\n",
 "eval₂_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker\n-/\ntheorem eval₂_eq_sum {f : «expr →+* » R S} {x : S} : p.eval₂ f x = p.sum fun e a => f a * x ^ e := by rw [eval₂]\n#align eval₂_eq_sum eval₂_eq_sum\n\n",
 "eval₂_eq_eval_map":
 "theorem eval₂_eq_eval_map {x : S} : p.eval₂ f x = (p.map f).eval x :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q hp hq\n    simp [hp, hq]\n  · intro n r\n    simp\n#align eval₂_eq_eval_map eval₂_eq_eval_map\n\n",
 "eval₂_dvd":
 "theorem eval₂_dvd : p ∣ q → eval₂ f x p ∣ eval₂ f x q :=\n  (eval₂_ring_hom f x).map_dvd\n#align eval₂_dvd eval₂_dvd\n\n",
 "eval₂_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_congr {R S : Type _} [Semiring R] [Semiring S] {f g : «expr →+* » R S} {s t : S} {φ ψ : polynomial R} :\n    f = g → s = t → φ = ψ → eval₂ f s φ = eval₂ g t ψ := by rintro rfl rfl rfl <;> rfl\n#align eval₂_congr eval₂_congr\n\n",
 "eval₂_comp":
 "theorem eval₂_comp {x : S} : eval₂ f x (p.comp q) = eval₂ f (eval₂ f x q) p := by\n  rw [comp, p.as_sum_range] <;> simp [eval₂_finset_sum, eval₂_pow]\n#align eval₂_comp eval₂_comp\n\n",
 "eval₂_bit1":
 "@[simp]\ntheorem eval₂_bit1 : (bit1 p).eval₂ f x = bit1 (p.eval₂ f x) := by rw [bit1, eval₂_add, eval₂_bit0, eval₂_one, bit1]\n#align eval₂_bit1 eval₂_bit1\n\n",
 "eval₂_bit0":
 "@[simp]\ntheorem eval₂_bit0 : (bit0 p).eval₂ f x = bit0 (p.eval₂ f x) := by rw [bit0, eval₂_add, bit0]\n#align eval₂_bit0 eval₂_bit0\n\n",
 "eval₂_at_zero":
 "@[simp]\ntheorem eval₂_at_zero : p.eval₂ f 0 = f (coeff p 0) := by\n  simp (config := { contextual := true }) only [eval₂_eq_sum, zero_pow_eq, mul_ite, mul_zero, mul_one, sum, not_not,\n    mem_support_iff, sum_ite_eq', ite_eq_left_iff, RingHom.map_zero, imp_true_iff, eq_self_iff_true]\n#align eval₂_at_zero eval₂_at_zero\n\n",
 "eval₂_at_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_at_one {S : Type _} [Semiring S] (f : «expr →+* » R S) : p.eval₂ f 1 = f (p.eval 1) :=\n  by\n  convert eval₂_at_apply f 1\n  simp\n#align eval₂_at_one eval₂_at_one\n\n",
 "eval₂_at_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_at_nat_cast {S : Type _} [Semiring S] (f : «expr →+* » R S) (n : ℕ) : p.eval₂ f n = f (p.eval n) :=\n  by\n  convert eval₂_at_apply f n\n  simp\n#align eval₂_at_nat_cast eval₂_at_nat_cast\n\n",
 "eval₂_at_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_at_apply {S : Type _} [Semiring S] (f : «expr →+* » R S) (r : R) : p.eval₂ f (f r) = f (p.eval r) :=\n  by\n  rw [eval₂_eq_sum, eval_eq_sum, sum, sum, f.map_sum]\n  simp only [f.map_mul, f.map_pow]\n#align eval₂_at_apply eval₂_at_apply\n\n",
 "eval₂_add":
 "@[simp]\ntheorem eval₂_add : (p + q).eval₂ f x = p.eval₂ f x + q.eval₂ f x :=\n  by\n  simp only [eval₂_eq_sum]\n  apply sum_add_index <;> simp [add_mul]\n#align eval₂_add eval₂_add\n\n",
 "eval₂_X_pow":
 "@[simp]\ntheorem eval₂_X_pow {n : ℕ} : (X ^ n).eval₂ f x = x ^ n :=\n  by\n  rw [X_pow_eq_monomial]\n  convert eval₂_monomial f x\n  simp\n#align eval₂_X_pow eval₂_X_pow\n\n",
 "eval₂_X_mul":
 "@[simp]\ntheorem eval₂_X_mul : eval₂ f x (X * p) = eval₂ f x p * x := by rw [X_mul, eval₂_mul_X]\n#align eval₂_X_mul eval₂_X_mul\n\n",
 "eval₂_X":
 "@[simp]\ntheorem eval₂_X : X.eval₂ f x = x := by simp [eval₂_eq_sum]\n#align eval₂_X eval₂_X\n\n",
 "eval₂_C_X":
 "@[simp]\ntheorem eval₂_C_X : eval₂ C X p = p :=\n  polynomial.induction_on' p (fun p q hp hq => by simp [hp, hq]) fun n x => by\n    rw [eval₂_monomial, ← smul_X_eq_monomial, C_mul']\n#align eval₂_C_X eval₂_C_X\n\n",
 "eval₂_C":
 "@[simp]\ntheorem eval₂_C : (C a).eval₂ f x = f a := by simp [eval₂_eq_sum]\n#align eval₂_C eval₂_C\n\n",
 "eval_zero_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_zero_map (f : «expr →+* » R S) (p : polynomial R) : (p.map f).eval 0 = f (p.eval 0) := by\n  simp [← coeff_zero_eq_eval_zero]\n#align eval_zero_map eval_zero_map\n\n",
 "eval_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_zero : (0 : polynomial R).eval x = 0 :=\n  eval₂_zero _ _\n#align eval_zero eval_zero\n\n",
 "eval_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval_sum (p : polynomial R) (f : ℕ → R → polynomial R) (x : R) :\n    (p.sum f).eval x = p.sum fun n a => (f n a).eval x :=\n  eval₂_sum _ _ _ _\n#align eval_sum eval_sum\n\n",
 "eval_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_sub (p q : polynomial R) (x : R) : (p - q).eval x = p.eval x - q.eval x :=\n  eval₂_sub _\n#align eval_sub eval_sub\n\n",
 "eval_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem eval_smul [monoid S] [DistribMulAction S R] [IsScalarTower S R R] (s : S) (p : polynomial R) (x : R) :\n    («expr • » s p).eval x = «expr • » s (p.eval x) := by\n  rw [← smul_one_smul R s p, eval, eval₂_smul, RingHom.id_apply, smul_one_mul]\n#align eval_smul eval_smul\n\n",
 "eval_ring_hom_zero":
 "theorem eval_ring_hom_zero : eval_ring_hom 0 = constant_coeff :=\n  fun_like.ext _ _ fun p => p.coeff_zero_eq_eval_zero.symm\n#align eval_ring_hom_zero eval_ring_hom_zero\n\n",
 "eval_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Polynomial evaluation commutes with `finset.prod`\n-/\ntheorem eval_prod {ι : Type _} (s : Finset ι) (p : ι → polynomial R) (x : R) :\n    eval x (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p j)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (eval x (p j)) :=\n  (eval_ring_hom x).map_prod _ _\n#align eval_prod eval_prod\n\n",
 "eval_pow":
 "@[simp]\ntheorem eval_pow (n : ℕ) : (p ^ n).eval x = p.eval x ^ n :=\n  eval₂_pow _ _ _\n#align eval_pow eval_pow\n\n",
 "eval_one_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_one_map (f : «expr →+* » R S) (p : polynomial R) : (p.map f).eval 1 = f (p.eval 1) :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q hp hq\n    simp only [hp, hq, polynomial.map_add, RingHom.map_add, eval_add]\n  · intro n r\n    simp only [one_pow, mul_one, eval_monomial, map_monomial]\n#align eval_one_map eval_one_map\n\n",
 "eval_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_one : (1 : polynomial R).eval x = 1 :=\n  eval₂_one _ _\n#align eval_one eval_one\n\n",
 "eval_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_neg (p : polynomial R) (x : R) : (-p).eval x = -p.eval x :=\n  eval₂_neg _\n#align eval_neg eval_neg\n\n",
 "eval_nat_cast_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_nat_cast_mul {n : ℕ} : ((n : polynomial R) * p).eval x = n * p.eval x := by\n  rw [← C_eq_nat_cast, eval_C_mul]\n#align eval_nat_cast_mul eval_nat_cast_mul\n\n",
 "eval_nat_cast_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_nat_cast_map (f : «expr →+* » R S) (p : polynomial R) (n : ℕ) : (p.map f).eval n = f (p.eval n) :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q hp hq\n    simp only [hp, hq, polynomial.map_add, RingHom.map_add, eval_add]\n  · intro n r\n    simp only [map_nat_cast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]\n#align eval_nat_cast_map eval_nat_cast_map\n\n",
 "eval_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_nat_cast {n : ℕ} : (n : polynomial R).eval x = n := by simp only [← C_eq_nat_cast, eval_C]\n#align eval_nat_cast eval_nat_cast\n\n",
 "eval_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Polynomial evaluation commutes with `multiset.prod`\n-/\ntheorem eval_multiset_prod (s : Multiset (polynomial R)) (x : R) : eval x s.prod = (s.map (eval x)).prod :=\n  (eval_ring_hom x).map_multiset_prod s\n#align eval_multiset_prod eval_multiset_prod\n\n",
 "eval_mul_X_pow":
 "@[simp]\ntheorem eval_mul_X_pow {k : ℕ} : (p * X ^ k).eval x = p.eval x * x ^ k :=\n  by\n  induction' k with k ih\n  · simp\n  · simp [pow_succ', ← mul_assoc, ih]\n#align eval_mul_X_pow eval_mul_X_pow\n\n",
 "eval_mul_X":
 "@[simp]\ntheorem eval_mul_X : (p * X).eval x = p.eval x * x :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q ph qh\n    simp only [add_mul, eval_add, ph, qh]\n  · intro n a\n    simp only [← monomial_one_one_eq_X, monomial_mul_monomial, eval_monomial, mul_one, pow_succ', mul_assoc]\n#align eval_mul_X eval_mul_X\n\n",
 "eval_mul":
 "@[simp]\ntheorem eval_mul : (p * q).eval x = p.eval x * q.eval x :=\n  eval₂_mul _ _\n#align eval_mul eval_mul\n\n",
 "eval_monomial_one_add_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A reformulation of the expansion of (1 + y)^d:\n$$(d + 1) (1 + y)^d - (d + 1)y^d = \\sum_{i = 0}^d {d + 1 \\choose i} \\cdot i \\cdot y^{i - 1}.$$\n-/\ntheorem eval_monomial_one_add_sub [CommRing S] (d : ℕ) (y : S) :\n    eval (1 + y) (monomial d (d + 1 : S)) - eval y (monomial d (d + 1 : S)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (d + 1))\n        (↑((d + 1).choose x_1) * (↑x_1 * y ^ (x_1 - 1))) :=\n  by\n  have cast_succ : (d + 1 : S) = ((d.succ : ℕ) : S) := by simp only [Nat.cast_succ]\n  rw [cast_succ, eval_monomial, eval_monomial, add_comm, add_pow]\n  conv_lhs =>\n    congr\n    congr\n    skip\n    apply_congr\n    skip\n    rw [one_pow, mul_one, mul_comm]\n  rw [sum_range_succ, mul_add, Nat.choose_self, Nat.cast_one, one_mul, add_sub_cancel, mul_sum, sum_range_succ',\n    Nat.cast_zero, zero_mul, mul_zero, add_zero]\n  apply sum_congr rfl fun y hy => _\n  rw [← mul_assoc, ← mul_assoc, ← nat.cast_mul, Nat.succ_mul_choose_eq, nat.cast_mul, nat.add_sub_cancel]\n#align eval_monomial_one_add_sub eval_monomial_one_add_sub\n\n",
 "eval_monomial":
 "@[simp]\ntheorem eval_monomial {n a} : (monomial n a).eval x = a * x ^ n :=\n  eval₂_monomial _ _\n#align eval_monomial eval_monomial\n\n",
 "eval_map":
 "theorem eval_map (x : S) : (p.map f).eval x = p.eval₂ f x :=\n  (eval₂_eq_eval_map f).symm\n#align eval_map eval_map\n\n",
 "eval_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Polynomial evaluation commutes with `list.prod`\n-/\ntheorem eval_list_prod (l : list (polynomial R)) (x : R) : eval x l.prod = (l.map (eval x)).prod :=\n  (eval_ring_hom x).map_list_prod l\n#align eval_list_prod eval_list_prod\n\n",
 "eval_int_cast_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_int_cast_map {R S : Type _} [Ring R] [Ring S] (f : «expr →+* » R S) (p : polynomial R) (i : ℤ) :\n    (p.map f).eval i = f (p.eval i) := by\n  apply polynomial.induction_on' p\n  · intro p q hp hq\n    simp only [hp, hq, polynomial.map_add, RingHom.map_add, eval_add]\n  · intro n r\n    simp only [map_intCast, eval_monomial, map_monomial, map_pow, map_mul]\n#align eval_int_cast_map eval_int_cast_map\n\n",
 "eval_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem eval_int_cast {n : ℤ} {x : R} : (n : polynomial R).eval x = n := by simp only [← C_eq_int_cast, eval_C]\n#align eval_int_cast eval_int_cast\n\n",
 "eval_geom_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem eval_geom_sum {R} [CommSemiring R] {n : ℕ} {x : R} :\n    eval x\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (X ^ i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n        (x ^ i) :=\n  by simp [eval_finset_sum]\n#align eval_geom_sum eval_geom_sum\n\n",
 "eval_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval_finset_sum (s : Finset ι) (g : ι → polynomial R) (x : R) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g i)).eval x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((g i).eval x) :=\n  eval₂_finset_sum _ _ _ _\n#align eval_finset_sum eval_finset_sum\n\n",
 "eval_eq_zero_of_dvd_of_eval_eq_zero":
 "theorem eval_eq_zero_of_dvd_of_eval_eq_zero : p ∣ q → eval x p = 0 → eval x q = 0 :=\n  eval₂_eq_zero_of_dvd_of_eval₂_eq_zero _ _\n#align eval_eq_zero_of_dvd_of_eval_eq_zero eval_eq_zero_of_dvd_of_eval_eq_zero\n\n",
 "eval_eq_sum_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval_eq_sum_range' {p : polynomial R} {n : ℕ} (hn : p.nat_degree < n) (x : R) :\n    p.eval x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (p.coeff i * x ^ i) :=\n  by rw [eval_eq_sum, p.sum_over_range' _ _ hn] <;> simp\n#align eval_eq_sum_range' eval_eq_sum_range'\n\n",
 "eval_eq_sum_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval_eq_sum_range {p : polynomial R} (x : R) :\n    p.eval x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range (p.nat_degree + 1)) (p.coeff i * x ^ i) :=\n  by rw [eval_eq_sum, sum_over_range] <;> simp\n#align eval_eq_sum_range eval_eq_sum_range\n\n",
 "eval_eq_sum":
 "theorem eval_eq_sum : p.eval x = p.sum fun e a => a * x ^ e :=\n  by\n  rw [eval, eval₂_eq_sum]\n  rfl\n#align eval_eq_sum eval_eq_sum\n\n",
 "eval_dvd":
 "theorem eval_dvd : p ∣ q → eval x p ∣ eval x q :=\n  eval₂_dvd _ _\n#align eval_dvd eval_dvd\n\n",
 "eval_comp":
 "@[simp]\ntheorem eval_comp : (p.comp q).eval x = p.eval (q.eval x) :=\n  by\n  apply polynomial.induction_on' p\n  · intro r s hr hs\n    simp [add_comp, hr, hs]\n  · intro n a\n    simp\n#align eval_comp eval_comp\n\n",
 "eval_bit1":
 "@[simp]\ntheorem eval_bit1 : (bit1 p).eval x = bit1 (p.eval x) :=\n  eval₂_bit1 _ _\n#align eval_bit1 eval_bit1\n\n",
 "eval_bit0":
 "@[simp]\ntheorem eval_bit0 : (bit0 p).eval x = bit0 (p.eval x) :=\n  eval₂_bit0 _ _\n#align eval_bit0 eval_bit0\n\n",
 "eval_add":
 "@[simp]\ntheorem eval_add : (p + q).eval x = p.eval x + q.eval x :=\n  eval₂_add _ _\n#align eval_add eval_add\n\n",
 "eval_X":
 "@[simp]\ntheorem eval_X : X.eval x = x :=\n  eval₂_X _ _\n#align eval_X eval_X\n\n",
 "eval_C_mul":
 "@[simp]\ntheorem eval_C_mul : (C a * p).eval x = a * p.eval x :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q ph qh\n    simp only [mul_add, eval_add, ph, qh]\n  · intro n b\n    simp only [mul_assoc, C_mul_monomial, eval_monomial]\n#align eval_C_mul eval_C_mul\n\n",
 "eval_C":
 "@[simp]\ntheorem eval_C : (C a).eval x = a :=\n  eval₂_C _ _\n#align eval_C eval_C\n\n",
 "eq_zero":
 "theorem is_root.eq_zero (h : is_root p x) : eval x p = 0 :=\n  h\n#align is_root.eq_zero is_root.eq_zero\n\n",
 "dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_root.dvd {R : Type _} [CommSemiring R] {p q : polynomial R} {x : R} (h : p.is_root x) (hpq : p ∣ q) :\n    q.is_root x := by rwa [is_root, eval, eval₂_eq_zero_of_dvd_of_eval₂_eq_zero _ _ hpq]\n#align is_root.dvd is_root.dvd\n\n",
 "degree_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_map_le (p : polynomial R) : degree (p.map f) ≤ degree p :=\n  by\n  apply (degree_le_iff_coeff_zero _ _).2 fun m hm => _\n  rw [degree_lt_iff_coeff_zero] at hm\n  simp [hm m le_rfl]\n#align degree_map_le degree_map_le\n\n",
 "degree_map_eq_of_leading_coeff_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem degree_map_eq_of_leading_coeff_ne_zero (f : «expr →+* » R S) (hf : f (leading_coeff p) ≠ 0) :\n    degree (p.map f) = degree p :=\n  le_antisymm (degree_map_le f _) <|\n    by\n    have hp0 : p ≠ 0 := leading_coeff_ne_zero.mp fun hp0 => hf (trans (congr_arg _ hp0) f.map_zero)\n    rw [degree_eq_nat_degree hp0]\n    refine' le_degree_of_ne_zero _\n    rw [coeff_map]\n    exact hf\n#align degree_map_eq_of_leading_coeff_ne_zero degree_map_eq_of_leading_coeff_ne_zero\n\n",
 "def":
 "@[simp]\ntheorem is_root.def : is_root p a ↔ p.eval a = 0 :=\n  iff.rfl\n#align is_root.def is_root.def\n\n",
 "comp_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem comp_zero : p.comp (0 : polynomial R) = C (p.eval 0) := by rw [← C_0, comp_C]\n#align comp_zero comp_zero\n\n",
 "comp_one":
 "@[simp]\ntheorem comp_one : p.comp 1 = C (p.eval 1) := by rw [← C_1, comp_C]\n#align comp_one comp_one\n\n",
 "comp_eq_sum_left":
 "theorem comp_eq_sum_left : p.comp q = p.sum fun e a => C a * q ^ e := by rw [comp, eval₂_eq_sum]\n#align comp_eq_sum_left comp_eq_sum_left\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem comp_assoc {R : Type _} [CommSemiring R] (φ ψ χ : polynomial R) : (φ.comp ψ).comp χ = φ.comp (ψ.comp χ) := by\n  apply polynomial.induction_on φ <;>\n    · intros\n      simp_all only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc]\n#align comp_assoc comp_assoc\n\n",
 "comp_X":
 "@[simp]\ntheorem comp_X : p.comp X = p := by\n  simp only [comp, eval₂, C_mul_X_pow_eq_monomial]\n  exact sum_monomial_eq _\n#align comp_X comp_X\n\n",
 "comp_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem comp_C : p.comp (C a) = C (p.eval a) := by simp [comp, (C : «expr →+* » R _).map_sum]\n#align comp_C comp_C\n\n",
 "coeff_zero_eq_eval_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_zero_eq_eval_zero (p : polynomial R) : coeff p 0 = p.eval 0 :=\n  calc\n    coeff p 0 = coeff p 0 * 0 ^ 0 := by simp\n    _ = p.eval 0 := by\n      symm\n      rw [eval_eq_sum]\n      exact finset.sum_eq_single _ (fun b _ hb => by simp [zero_pow (nat.pos_of_ne_zero hb)]) (by simp)\n    \n#align coeff_zero_eq_eval_zero coeff_zero_eq_eval_zero\n\n",
 "coeff_map":
 "@[simp]\ntheorem coeff_map (n : ℕ) : coeff (p.map f) n = f (coeff p n) :=\n  by\n  rw [map, eval₂, coeff_sum, sum]\n  conv_rhs => rw [← sum_C_mul_X_pow_eq p, coeff_sum, sum, ring_hom.map_sum]\n  refine' finset.sum_congr rfl fun x hx => _\n  simp [function.comp, coeff_C_mul_X_pow, f.map_mul]\n  split_ifs <;> simp [f.map_zero]\n#align coeff_map coeff_map\n\n",
 "coeff_comp_degree_mul_degree":
 "theorem coeff_comp_degree_mul_degree (hqd0 : nat_degree q ≠ 0) :\n    coeff (p.comp q) (nat_degree p * nat_degree q) = leading_coeff p * leading_coeff q ^ nat_degree p :=\n  by\n  rw [comp, eval₂, coeff_sum]\n  convert finset.sum_eq_single p.nat_degree _ _\n  · simp only [coeff_nat_degree, coeff_C_mul, coeff_pow_mul_nat_degree]\n  · intro b hbs hbp\n    refine' coeff_eq_zero_of_nat_degree_lt (nat_degree_mul_le.trans_lt _)\n    rw [nat_degree_C, zero_add]\n    refine' nat_degree_pow_le.trans_lt ((mul_lt_mul_right (pos_iff_ne_zero.mpr hqd0)).mpr _)\n    exact lt_of_le_of_ne (le_nat_degree_of_mem_supp _ hbs) hbp\n  · simp (config := { contextual := true })\n#align coeff_comp_degree_mul_degree coeff_comp_degree_mul_degree\n\n",
 "coe_map_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n-- `map` is a ring-hom unconditionally, and theoretically the definition could be replaced,\n-- but this turns out not to be easy because `p.map f` does not resolve to `polynomial.map`\n-- if `map` is a `ring_hom` instead of a plain function; the elaborator does not try to coerce\n-- to a function before trying field (dot) notation (this may be technically infeasible);\n-- the relevant code is (both lines): https://github.com/leanprover-community/\n-- lean/blob/487ac5d7e9b34800502e1ddf3c7c806c01cf9d51/src/frontends/lean/elaborator.cpp#L1876-L1913\n@[simp]\ntheorem coe_map_ring_hom (f : «expr →+* » R S) : «expr⇑ » (map_ring_hom f) = map f :=\n  rfl\n#align coe_map_ring_hom coe_map_ring_hom\n\n",
 "coe_eval₂_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_eval₂_ring_hom (f : «expr →+* » R S) (x) : «expr⇑ » (eval₂_ring_hom f x) = eval₂ f x :=\n  rfl\n#align coe_eval₂_ring_hom coe_eval₂_ring_hom\n\n",
 "coe_eval_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coe_eval_ring_hom (r : R) : (eval_ring_hom r : polynomial R → R) = eval r :=\n  rfl\n#align coe_eval_ring_hom coe_eval_ring_hom\n\n",
 "coe_comp_ring_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coe_comp_ring_hom_apply (p q : polynomial R) : (comp_ring_hom q : polynomial R → polynomial R) p = comp p q :=\n  rfl\n#align coe_comp_ring_hom_apply coe_comp_ring_hom_apply\n\n",
 "coe_comp_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coe_comp_ring_hom (q : polynomial R) : (comp_ring_hom q : polynomial R → polynomial R) = fun p => comp p q :=\n  rfl\n#align coe_comp_ring_hom coe_comp_ring_hom\n\n",
 "cast_int_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem cast_int_comp (i : ℤ) : comp (i : polynomial R) p = i := by cases i <;> simp\n#align cast_int_comp cast_int_comp\n\n",
 "bit1_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem bit1_comp : comp (bit1 p : polynomial R) q = bit1 (p.comp q) := by\n  simp only [bit1, add_comp, bit0_comp, one_comp]\n#align bit1_comp bit1_comp\n\n",
 "bit0_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem bit0_comp : comp (bit0 p : polynomial R) q = bit0 (p.comp q) := by simp only [bit0, add_comp]\n#align bit0_comp bit0_comp\n\n",
 "add_comp":
 "@[simp]\ntheorem add_comp : (p + q).comp r = p.comp r + q.comp r :=\n  eval₂_add _ _\n#align add_comp add_comp\n\n",
 "X_pow_comp":
 "@[simp]\ntheorem X_pow_comp {k : ℕ} : (X ^ k).comp p = p ^ k :=\n  by\n  induction' k with k ih\n  · simp\n  · simp [pow_succ', mul_X_comp, ih]\n#align X_pow_comp X_pow_comp\n\n",
 "X_comp":
 "@[simp]\ntheorem X_comp : X.comp p = p :=\n  eval₂_X _ _\n#align X_comp X_comp\n\n",
 "C_sub":
 "theorem C_sub : C (a - b) = C a - C b :=\n  RingHom.map_sub C a b\n#align C_sub C_sub\n\n",
 "C_neg":
 "theorem C_neg : C (-a) = -C a :=\n  RingHom.map_neg C a\n#align C_neg C_neg\n\n",
 "C_mul_comp":
 "@[simp]\ntheorem C_mul_comp : (C a * p).comp r = C a * p.comp r :=\n  by\n  apply polynomial.induction_on' p\n  · intro p q hp hq\n    simp [hp, hq, mul_add]\n  · intro n b\n    simp [mul_assoc]\n#align C_mul_comp C_mul_comp\n\n",
 "C_comp":
 "@[simp]\ntheorem C_comp : (C a).comp p = C a :=\n  eval₂_C _ _\n#align C_comp C_comp\n\n"}