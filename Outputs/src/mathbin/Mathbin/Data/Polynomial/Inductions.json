{"nat_degree_ne_zero_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A property holds for all polynomials of non-zero `nat_degree` with coefficients in a\nsemiring `R` if it holds for\n* `p + a`, with `a ∈ R`, `p ∈ R[X]`,\n* `p + q`, with `p, q ∈ R[X]`,\n* monomials with nonzero coefficient and non-zero exponent,\nwith appropriate restrictions on each term.\nNote that multiplication is \"hidden\" in the assumption on monomials, so there is no explicit\nmultiplication in the statement.\nSee `degree_pos_induction_on` for a similar statement involving more explicit multiplications.\n -/\n@[elab_as_elim]\ntheorem nat_degree_ne_zero_induction_on {M : polynomial R → Prop} {f : polynomial R} (f0 : f.nat_degree ≠ 0)\n    (h_C_add : ∀ {a p}, M p → M (C a + p)) (h_add : ∀ {p q}, M p → M q → M (p + q))\n    (h_monomial : ∀ {n : ℕ} {a : R}, a ≠ 0 → n ≠ 0 → M (monomial n a)) : M f :=\n  by\n  suffices f.nat_degree = 0 ∨ M f from or.dcases_on this (fun h => (f0 h).elim) id\n  apply f.induction_on\n  · exact fun a => or.inl (nat_degree_C _)\n  · rintro p q (hp | hp) (hq | hq)\n    · refine' or.inl _\n      rw [eq_C_of_nat_degree_eq_zero hp, eq_C_of_nat_degree_eq_zero hq, ← C_add, nat_degree_C]\n    · refine' or.inr _\n      rw [eq_C_of_nat_degree_eq_zero hp]\n      exact h_C_add hq\n    · refine' or.inr _\n      rw [eq_C_of_nat_degree_eq_zero hq, add_comm]\n      exact h_C_add hp\n    · exact or.inr (h_add hp hq)\n  · intro n a hi\n    by_cases a0 : a = 0\n    · exact or.inl (by rw [a0, C_0, zero_mul, nat_degree_zero])\n    · refine' or.inr _\n      rw [C_mul_X_pow_eq_monomial]\n      exact h_monomial a0 n.succ_ne_zero\n#align nat_degree_ne_zero_induction_on nat_degree_ne_zero_induction_on\n\n",
 "div_X_mul_X_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem div_X_mul_X_add (p : polynomial R) : div_X p * X + C (p.coeff 0) = p :=\n  ext <| by rintro ⟨_ | _⟩ <;> simp [coeff_C, nat.succ_ne_zero, coeff_mul_X]\n#align div_X_mul_X_add div_X_mul_X_add\n\n",
 "div_X_eq_zero_iff":
 "theorem div_X_eq_zero_iff : div_X p = 0 ↔ p = C (p.coeff 0) :=\n  ⟨fun h => by simpa [eq_comm, h] using div_X_mul_X_add p, fun h => by rw [h, div_X_C]⟩\n#align div_X_eq_zero_iff div_X_eq_zero_iff\n\n",
 "div_X_add":
 "theorem div_X_add : div_X (p + q) = div_X p + div_X q :=\n  ext <| by simp\n#align div_X_add div_X_add\n\n",
 "div_X_C":
 "@[simp]\ntheorem div_X_C (a : R) : div_X (C a) = 0 :=\n  ext fun n => by simp [div_X, coeff_C] <;> simp [coeff]\n#align div_X_C div_X_C\n\n",
 "degree_pos_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A property holds for all polynomials of positive `degree` with coefficients in a semiring `R`\nif it holds for\n* `a * X`, with `a ∈ R`,\n* `p * X`, with `p ∈ R[X]`,\n* `p + a`, with `a ∈ R`, `p ∈ R[X]`,\nwith appropriate restrictions on each term.\n\nSee `nat_degree_ne_zero_induction_on` for a similar statement involving no explicit multiplication.\n -/\n@[elab_as_elim]\ntheorem degree_pos_induction_on {P : polynomial R → Prop} (p : polynomial R) (h0 : 0 < degree p)\n    (hC : ∀ {a}, a ≠ 0 → P (C a * X)) (hX : ∀ {p}, 0 < degree p → P p → P (p * X))\n    (hadd : ∀ {p} {a}, 0 < degree p → P p → P (p + C a)) : P p :=\n  rec_on_horner p (fun h => by rw [degree_zero] at h <;> exact absurd h (by decide))\n    (fun p a _ _ ih h0 =>\n      have : 0 < degree p :=\n        lt_of_not_ge fun h => not_lt_of_ge degree_C_le <| by rwa [eq_C_of_degree_le_zero h, ← C_add] at h0\n      hadd this (ih this))\n    (fun p _ ih h0' =>\n      if h0 : 0 < degree p then hX h0 (ih h0)\n      else by\n        rw [eq_C_of_degree_le_zero (le_of_not_gt h0)] at * <;>\n          exact hC fun h : coeff p 0 = 0 => by simpa [h, nat.not_lt_zero] using h0')\n    h0\n#align degree_pos_induction_on degree_pos_induction_on\n\n",
 "degree_div_X_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_div_X_lt (hp0 : p ≠ 0) : (div_X p).degree < p.degree := by\n  haveI := nontrivial.of_polynomial_ne hp0 <;>\n    calc\n      (div_X p).degree < (div_X p * X + C (p.coeff 0)).degree :=\n        if h : degree p ≤ 0 then\n          by\n          have h' : C (p.coeff 0) ≠ 0 := by rwa [← eq_C_of_degree_le_zero h]\n          rw [eq_C_of_degree_le_zero h, div_X_C, degree_zero, zero_mul, zero_add]\n          exact lt_of_le_of_ne bot_le (ne.symm (mt degree_eq_bot.1 <| by simp [h']))\n        else by\n          have hXp0 : div_X p ≠ 0 := by simpa [div_X_eq_zero_iff, -not_le, degree_le_zero_iff] using h\n          have : leading_coeff (div_X p) * leading_coeff X ≠ 0 := by simpa\n          have : degree (C (p.coeff 0)) < degree (div_X p * X) :=\n            calc\n              degree (C (p.coeff 0)) ≤ 0 := degree_C_le\n              _ < 1 := by decide\n              _ = degree (X : polynomial R) := degree_X.symm\n              _ ≤ degree (div_X p * X) := by\n                rw [← zero_add (degree X), degree_mul' this] <;>\n                  exact\n                    add_le_add\n                      (by\n                        rw [zero_le_degree_iff, ne.def, div_X_eq_zero_iff] <;>\n                          exact fun h0 => h (h0.symm ▸ degree_C_le))\n                      le_rfl\n              \n          rw [degree_add_eq_left_of_degree_lt this] <;> exact degree_lt_degree_mul_X hXp0\n      _ = p.degree := congr_arg _ (div_X_mul_X_add _)\n      \n#align degree_div_X_lt degree_div_X_lt\n\n",
 "coeff_div_X":
 "/-\nCopyright (c) 2021 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Damiano Testa, Jens Wagemaker\n-/\n@[simp]\ntheorem coeff_div_X : (div_X p).coeff n = p.coeff (n + 1) :=\n  by\n  simp only [div_X, coeff_monomial, true_and_iff, finset_sum_coeff, not_lt, mem_Ico, zero_le, finset.sum_ite_eq',\n    ite_eq_left_iff]\n  intro h\n  rw [coeff_eq_zero_of_nat_degree_lt (nat.lt_succ_of_le h)]\n#align coeff_div_X coeff_div_X\n\n"}