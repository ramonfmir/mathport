{"nat_degree_sum_eq_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem nat_degree_sum_eq_of_disjoint (f : S → polynomial R) (s : Finset S)\n    (h : Set.Pairwise { i | i ∈ s ∧ f i ≠ 0 } («expr on » ne (nat_degree ∘ f))) :\n    nat_degree (s.sum f) = s.sup fun i => nat_degree (f i) :=\n  by\n  by_cases H : ∃ x ∈ s, f x ≠ 0\n  · obtain ⟨x, hx, hx'⟩ := H\n    have hs : s.nonempty := ⟨x, hx⟩\n    refine' nat_degree_eq_of_degree_eq_some _\n    rw [degree_sum_eq_of_disjoint]\n    · rw [← finset.sup'_eq_sup hs, ← finset.sup'_eq_sup hs, finset.coe_sup', ← finset.sup'_eq_sup hs]\n      refine' le_antisymm _ _\n      · rw [finset.sup'_le_iff]\n        intro b hb\n        by_cases hb' : f b = 0\n        · simpa [hb'] using hs\n        rw [degree_eq_nat_degree hb']\n        exact finset.le_sup' _ hb\n      · rw [finset.sup'_le_iff]\n        intro b hb\n        simp only [finset.le_sup'_iff, exists_prop, Function.comp_apply]\n        by_cases hb' : f b = 0\n        · refine' ⟨x, hx, _⟩\n          contrapose! hx'\n          simpa [hb', degree_eq_bot] using hx'\n        exact ⟨b, hb, (degree_eq_nat_degree hb').ge⟩\n    · exact h.imp fun x y hxy hxy' => hxy (nat_degree_eq_of_degree_eq hxy')\n  · push_neg  at H\n    rw [finset.sum_eq_zero H, nat_degree_zero, eq_comm, show 0 = «expr⊥» from rfl, finset.sup_eq_bot_iff]\n    intro x hx\n    simp [H x hx]\n#align nat_degree_sum_eq_of_disjoint nat_degree_sum_eq_of_disjoint\n\n",
 "nat_degree_sub_le_iff_right":
 "theorem nat_degree_sub_le_iff_right (pn : p.nat_degree ≤ n) : (p - q).nat_degree ≤ n ↔ q.nat_degree ≤ n := by\n  rwa [nat_degree_sub, nat_degree_sub_le_iff_left]\n#align nat_degree_sub_le_iff_right nat_degree_sub_le_iff_right\n\n",
 "nat_degree_sub_le_iff_left":
 "theorem nat_degree_sub_le_iff_left (qn : q.nat_degree ≤ n) : (p - q).nat_degree ≤ n ↔ p.nat_degree ≤ n :=\n  by\n  rw [← nat_degree_neg] at qn\n  rw [sub_eq_add_neg, nat_degree_add_le_iff_left _ _ qn]\n#align nat_degree_sub_le_iff_left nat_degree_sub_le_iff_left\n\n",
 "nat_degree_sub":
 "theorem nat_degree_sub : (p - q).nat_degree = (q - p).nat_degree := by rw [← nat_degree_neg, neg_sub]\n#align nat_degree_sub nat_degree_sub\n\n",
 "nat_degree_pos_of_eval₂_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem nat_degree_pos_of_eval₂_root {p : polynomial R} (hp : p ≠ 0) (f : «expr →+* » R S) {z : S}\n    (hz : eval₂ f z p = 0) (inj : ∀ x : R, f x = 0 → x = 0) : 0 < nat_degree p :=\n  lt_of_not_ge fun hlt => by\n    have A : p = C (p.coeff 0) := eq_C_of_nat_degree_le_zero hlt\n    rw [A, eval₂_C] at hz\n    simp only [inj (p.coeff 0) hz, RingHom.map_zero] at A\n    exact hp A\n#align nat_degree_pos_of_eval₂_root nat_degree_pos_of_eval₂_root\n\n",
 "nat_degree_mul_C_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_mul_C_le (f : polynomial R) (a : R) : (f * C a).nat_degree ≤ f.nat_degree :=\n  calc\n    (f * C a).nat_degree ≤ f.nat_degree + (C a).nat_degree := nat_degree_mul_le\n    _ = f.nat_degree + 0 := by rw [nat_degree_C a]\n    _ = f.nat_degree := add_zero _\n    \n#align nat_degree_mul_C_le nat_degree_mul_C_le\n\n",
 "nat_degree_mul_C_eq_of_mul_ne_zero":
 "/-- Although not explicitly stated, the assumptions of lemma `nat_degree_mul_C_eq_of_mul_ne_zero`\nforce the polynomial `p` to be non-zero, via `p.leading_coeff ≠ 0`.\n-/\ntheorem nat_degree_mul_C_eq_of_mul_ne_zero (h : p.leading_coeff * a ≠ 0) : (p * C a).nat_degree = p.nat_degree :=\n  by\n  refine' eq_nat_degree_of_le_mem_support (nat_degree_mul_C_le p a) _\n  refine' mem_support_iff.mpr _\n  rwa [coeff_mul_C]\n#align nat_degree_mul_C_eq_of_mul_ne_zero nat_degree_mul_C_eq_of_mul_ne_zero\n\n",
 "nat_degree_mul_C_eq_of_mul_eq_one":
 "theorem nat_degree_mul_C_eq_of_mul_eq_one {ai : R} (au : a * ai = 1) : (p * C a).nat_degree = p.nat_degree :=\n  le_antisymm (nat_degree_mul_C_le p a)\n    (calc\n      p.nat_degree = (p * 1).nat_degree := by nth_rw 1 [← mul_one p]\n      _ = (p * C a * C ai).nat_degree := by rw [← C_1, ← au, RingHom.map_mul, ← mul_assoc]\n      _ ≤ (p * C a).nat_degree := nat_degree_mul_C_le (p * C a) ai\n      )\n#align nat_degree_mul_C_eq_of_mul_eq_one nat_degree_mul_C_eq_of_mul_eq_one\n\n",
 "nat_degree_mul_C":
 "theorem nat_degree_mul_C (a0 : a ≠ 0) : (p * C a).nat_degree = p.nat_degree := by\n  simp only [nat_degree, degree_mul_C a0]\n#align nat_degree_mul_C nat_degree_mul_C\n\n",
 "nat_degree_lt_coeff_mul":
 "theorem nat_degree_lt_coeff_mul (h : p.nat_degree + q.nat_degree < m + n) : (p * q).coeff (m + n) = 0 :=\n  coeff_eq_zero_of_nat_degree_lt (nat_degree_mul_le.trans_lt h)\n#align nat_degree_lt_coeff_mul nat_degree_lt_coeff_mul\n\n",
 "nat_degree_le_iff_coeff_eq_zero":
 "theorem nat_degree_le_iff_coeff_eq_zero : p.nat_degree ≤ n ↔ ∀ N : ℕ, n < N → p.coeff N = 0 := by\n  simp_rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero, WithBot.coe_lt_coe]\n#align nat_degree_le_iff_coeff_eq_zero nat_degree_le_iff_coeff_eq_zero\n\n",
 "nat_degree_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker\n-/\ntheorem nat_degree_comp_le : nat_degree (p.comp q) ≤ nat_degree p * nat_degree q :=\n  if h0 : p.comp q = 0 then by rw [h0, nat_degree_zero] <;> exact nat.zero_le _\n  else\n    WithBot.coe_le_coe.1 <|\n      calc\n        ↑(nat_degree (p.comp q)) = degree (p.comp q) := (degree_eq_nat_degree h0).symm\n        _ = _ := congr_arg degree comp_eq_sum_left\n        _ ≤ _ := degree_sum_le _ _\n        _ ≤ _ :=\n          finset.sup_le fun n hn =>\n            calc\n              degree (C (coeff p n) * q ^ n) ≤ degree (C (coeff p n)) + degree (q ^ n) := degree_mul_le _ _\n              _ ≤ nat_degree (C (coeff p n)) + «expr • » n (degree q) :=\n                add_le_add degree_le_nat_degree (degree_pow_le _ _)\n              _ ≤ nat_degree (C (coeff p n)) + «expr • » n (nat_degree q) :=\n                add_le_add_left (nsmul_le_nsmul_of_le_right (@degree_le_nat_degree _ _ q) n) _\n              _ = (n * nat_degree q : ℕ) := by\n                rw [nat_degree_C, with_bot.coe_zero, zero_add, ← WithBot.coe_nsmul, nsmul_eq_mul] <;> simp\n              _ ≤ (nat_degree p * nat_degree q : ℕ) :=\n                WithBot.coe_le_coe.2 <|\n                  mul_le_mul_of_nonneg_right (le_nat_degree_of_ne_zero (mem_support_iff.1 hn)) (nat.zero_le _)\n              \n        \n#align nat_degree_comp_le nat_degree_comp_le\n\n",
 "nat_degree_comp":
 "theorem nat_degree_comp : nat_degree (p.comp q) = nat_degree p * nat_degree q :=\n  by\n  by_cases q0 : q.nat_degree = 0\n  ·\n    rw [degree_le_zero_iff.mp (nat_degree_eq_zero_iff_degree_le_zero.mp q0), comp_C, nat_degree_C, nat_degree_C,\n      mul_zero]\n  · by_cases p0 : p = 0\n    · simp only [p0, zero_comp, nat_degree_zero, zero_mul]\n    refine' le_antisymm nat_degree_comp_le (le_nat_degree_of_ne_zero _)\n    simp only [coeff_comp_degree_mul_degree q0, p0, mul_eq_zero, leading_coeff_eq_zero, or_self_iff,\n      ne_zero_of_nat_degree_gt (nat.pos_of_ne_zero q0), pow_ne_zero, ne.def, not_false_iff]\n#align nat_degree_comp nat_degree_comp\n\n",
 "nat_degree_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_bit1 (a : polynomial R) : (bit1 a).nat_degree ≤ a.nat_degree :=\n  (nat_degree_add_le _ _).trans (by simp [nat_degree_bit0])\n#align nat_degree_bit1 nat_degree_bit1\n\n",
 "nat_degree_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_bit0 (a : polynomial R) : (bit0 a).nat_degree ≤ a.nat_degree :=\n  (nat_degree_add_le _ _).trans (max_self _).le\n#align nat_degree_bit0 nat_degree_bit0\n\n",
 "nat_degree_add_le_iff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_add_le_iff_right {n : ℕ} (p q : polynomial R) (pn : p.nat_degree ≤ n) :\n    (p + q).nat_degree ≤ n ↔ q.nat_degree ≤ n := by\n  rw [add_comm]\n  exact nat_degree_add_le_iff_left _ _ pn\n#align nat_degree_add_le_iff_right nat_degree_add_le_iff_right\n\n",
 "nat_degree_add_le_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_add_le_iff_left {n : ℕ} (p q : polynomial R) (qn : q.nat_degree ≤ n) :\n    (p + q).nat_degree ≤ n ↔ p.nat_degree ≤ n :=\n  by\n  refine' ⟨fun h => _, fun h => nat_degree_add_le_of_degree_le h qn⟩\n  refine' nat_degree_le_iff_coeff_eq_zero.mpr fun m hm => _\n  convert nat_degree_le_iff_coeff_eq_zero.mp h m hm using 1\n  rw [coeff_add, nat_degree_le_iff_coeff_eq_zero.mp qn _ hm, add_zero]\n#align nat_degree_add_le_iff_left nat_degree_add_le_iff_left\n\n",
 "nat_degree_add_coeff_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_add_coeff_mul (f g : polynomial R) :\n    (f * g).coeff (f.nat_degree + g.nat_degree) = f.coeff f.nat_degree * g.coeff g.nat_degree := by\n  simp only [coeff_nat_degree, coeff_mul_degree_add_degree]\n#align nat_degree_add_coeff_mul nat_degree_add_coeff_mul\n\n",
 "nat_degree_C_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_C_mul_le (a : R) (f : polynomial R) : (C a * f).nat_degree ≤ f.nat_degree :=\n  calc\n    (C a * f).nat_degree ≤ (C a).nat_degree + f.nat_degree := nat_degree_mul_le\n    _ = 0 + f.nat_degree := by rw [nat_degree_C a]\n    _ = f.nat_degree := zero_add _\n    \n#align nat_degree_C_mul_le nat_degree_C_mul_le\n\n",
 "nat_degree_C_mul_eq_of_mul_ne_zero":
 "/-- Although not explicitly stated, the assumptions of lemma `nat_degree_C_mul_eq_of_mul_ne_zero`\nforce the polynomial `p` to be non-zero, via `p.leading_coeff ≠ 0`.\n-/\ntheorem nat_degree_C_mul_eq_of_mul_ne_zero (h : a * p.leading_coeff ≠ 0) : (C a * p).nat_degree = p.nat_degree :=\n  by\n  refine' eq_nat_degree_of_le_mem_support (nat_degree_C_mul_le a p) _\n  refine' mem_support_iff.mpr _\n  rwa [coeff_C_mul]\n#align nat_degree_C_mul_eq_of_mul_ne_zero nat_degree_C_mul_eq_of_mul_ne_zero\n\n",
 "nat_degree_C_mul_eq_of_mul_eq_one":
 "theorem nat_degree_C_mul_eq_of_mul_eq_one {ai : R} (au : ai * a = 1) : (C a * p).nat_degree = p.nat_degree :=\n  le_antisymm (nat_degree_C_mul_le a p)\n    (calc\n      p.nat_degree = (1 * p).nat_degree := by nth_rw 1 [← one_mul p]\n      _ = (C ai * (C a * p)).nat_degree := by rw [← C_1, ← au, RingHom.map_mul, ← mul_assoc]\n      _ ≤ (C a * p).nat_degree := nat_degree_C_mul_le ai (C a * p)\n      )\n#align nat_degree_C_mul_eq_of_mul_eq_one nat_degree_C_mul_eq_of_mul_eq_one\n\n",
 "nat_degree_C_mul":
 "theorem nat_degree_C_mul (a0 : a ≠ 0) : (C a * p).nat_degree = p.nat_degree := by\n  simp only [nat_degree, degree_C_mul a0]\n#align nat_degree_C_mul nat_degree_C_mul\n\n",
 "leading_coeff_comp":
 "theorem leading_coeff_comp (hq : nat_degree q ≠ 0) :\n    leading_coeff (p.comp q) = leading_coeff p * leading_coeff q ^ nat_degree p := by\n  rw [← coeff_comp_degree_mul_degree hq, ← nat_degree_comp, coeff_nat_degree]\n#align leading_coeff_comp leading_coeff_comp\n\n",
 "eq_nat_degree_of_le_mem_support":
 "theorem eq_nat_degree_of_le_mem_support (pn : p.nat_degree ≤ n) (ns : n ∈ p.support) : p.nat_degree = n :=\n  le_antisymm pn (le_nat_degree_of_mem_supp _ ns)\n#align eq_nat_degree_of_le_mem_support eq_nat_degree_of_le_mem_support\n\n",
 "degree_sum_eq_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem degree_sum_eq_of_disjoint (f : S → polynomial R) (s : Finset S)\n    (h : Set.Pairwise { i | i ∈ s ∧ f i ≠ 0 } («expr on » ne (degree ∘ f))) :\n    degree (s.sum f) = s.sup fun i => degree (f i) :=\n  by\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, finset.sum_insert, not_false_iff, finset.sup_insert]\n    specialize IH (h.mono fun _ => by simp (config := { contextual := true }))\n    rcases lt_trichotomy (degree (f x)) (degree (s.sum f)) with (H | H | H)\n    · rw [← IH, sup_eq_right.mpr H.le, degree_add_eq_right_of_degree_lt H]\n    · rcases s.eq_empty_or_nonempty with (rfl | hs)\n      · simp\n      obtain ⟨y, hy, hy'⟩ := finset.exists_mem_eq_sup s hs fun i => degree (f i)\n      rw [IH, hy'] at H\n      by_cases hx0 : f x = 0\n      · simp [hx0, IH]\n      have hy0 : f y ≠ 0 := by\n        contrapose! H\n        simpa [H, degree_eq_bot] using hx0\n      refine' absurd H (h _ _ fun H => hx _)\n      · simp [hx0]\n      · simp [hy, hy0]\n      · exact H.symm ▸ hy\n    · rw [← IH, sup_eq_left.mpr H.le, degree_add_eq_left_of_degree_lt H]\n#align degree_sum_eq_of_disjoint degree_sum_eq_of_disjoint\n\n",
 "degree_pos_of_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_pos_of_root {p : polynomial R} (hp : p ≠ 0) (h : is_root p a) : 0 < degree p :=\n  lt_of_not_ge fun hlt => by\n    have := eq_C_of_degree_le_zero hlt\n    rw [is_root, this, eval_C] at h\n    simp only [h, RingHom.map_zero] at this\n    exact hp this\n#align degree_pos_of_root degree_pos_of_root\n\n",
 "degree_pos_of_eval₂_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem degree_pos_of_eval₂_root {p : polynomial R} (hp : p ≠ 0) (f : «expr →+* » R S) {z : S} (hz : eval₂ f z p = 0)\n    (inj : ∀ x : R, f x = 0 → x = 0) : 0 < degree p :=\n  nat_degree_pos_iff_degree_pos.mp (nat_degree_pos_of_eval₂_root hp f hz inj)\n#align degree_pos_of_eval₂_root degree_pos_of_eval₂_root\n\n",
 "degree_mul_C":
 "theorem degree_mul_C (a0 : a ≠ 0) : (p * C a).degree = p.degree := by rw [degree_mul, degree_C a0, add_zero]\n#align degree_mul_C degree_mul_C\n\n",
 "degree_C_mul":
 "theorem degree_C_mul (a0 : a ≠ 0) : (C a * p).degree = p.degree := by rw [degree_mul, degree_C a0, zero_add]\n#align degree_C_mul degree_C_mul\n\n",
 "coeff_sub_eq_neg_right_of_lt":
 "theorem coeff_sub_eq_neg_right_of_lt (df : p.nat_degree < n) : (p - q).coeff n = -q.coeff n := by\n  rwa [sub_eq_add_neg, coeff_add_eq_right_of_lt, coeff_neg]\n#align coeff_sub_eq_neg_right_of_lt coeff_sub_eq_neg_right_of_lt\n\n",
 "coeff_sub_eq_left_of_lt":
 "theorem coeff_sub_eq_left_of_lt (dg : q.nat_degree < n) : (p - q).coeff n = p.coeff n :=\n  by\n  rw [← nat_degree_neg] at dg\n  rw [sub_eq_add_neg, coeff_add_eq_left_of_lt dg]\n#align coeff_sub_eq_left_of_lt coeff_sub_eq_left_of_lt\n\n",
 "coeff_pow_of_nat_degree_le":
 "theorem coeff_pow_of_nat_degree_le (pn : p.nat_degree ≤ n) : (p ^ m).coeff (n * m) = p.coeff n ^ m :=\n  by\n  induction' m with m hm\n  · simp\n  · rw [pow_succ', pow_succ', ← hm, nat.mul_succ, coeff_mul_of_nat_degree_le _ pn]\n    refine' nat_degree_pow_le.trans (le_trans _ (mul_comm _ _).le)\n    exact mul_le_mul_of_nonneg_left pn m.zero_le\n#align coeff_pow_of_nat_degree_le coeff_pow_of_nat_degree_le\n\n",
 "coeff_mul_of_nat_degree_le":
 "theorem coeff_mul_of_nat_degree_le (pm : p.nat_degree ≤ m) (qn : q.nat_degree ≤ n) :\n    (p * q).coeff (m + n) = p.coeff m * q.coeff n :=\n  by\n  rcases eq_or_lt_of_le pm with (rfl | hm) <;> rcases eq_or_lt_of_le qn with (rfl | hn)\n  · exact nat_degree_add_coeff_mul _ _\n  · rw [coeff_eq_zero_of_nat_degree_lt hn, mul_zero]\n    exact nat_degree_lt_coeff_mul (add_lt_add_left hn _)\n  · rw [coeff_eq_zero_of_nat_degree_lt hm, zero_mul]\n    exact nat_degree_lt_coeff_mul (add_lt_add_right hm _)\n  · rw [coeff_eq_zero_of_nat_degree_lt hn, mul_zero]\n    exact nat_degree_lt_coeff_mul (add_lt_add hm hn)\n#align coeff_mul_of_nat_degree_le coeff_mul_of_nat_degree_le\n\n",
 "coeff_add_eq_right_of_lt":
 "theorem coeff_add_eq_right_of_lt (pn : p.nat_degree < n) : (p + q).coeff n = q.coeff n :=\n  by\n  rw [add_comm]\n  exact coeff_add_eq_left_of_lt pn\n#align coeff_add_eq_right_of_lt coeff_add_eq_right_of_lt\n\n",
 "coeff_add_eq_left_of_lt":
 "theorem coeff_add_eq_left_of_lt (qn : q.nat_degree < n) : (p + q).coeff n = p.coeff n :=\n  (coeff_add _ _ _).trans <| (congr_arg _ <| coeff_eq_zero_of_nat_degree_lt <| qn).trans <| add_zero _\n#align coeff_add_eq_left_of_lt coeff_add_eq_left_of_lt\n\n",
 "coe_lt_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coe_lt_degree {p : polynomial R} {n : ℕ} : (n : WithBot ℕ) < degree p ↔ n < nat_degree p :=\n  by\n  by_cases h : p = 0\n  · simp [h]\n  rw [degree_eq_nat_degree h, WithBot.coe_lt_coe]\n#align coe_lt_degree coe_lt_degree\n\n"}