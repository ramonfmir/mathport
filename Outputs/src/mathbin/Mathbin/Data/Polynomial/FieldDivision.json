{"roots_normalize":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_normalize {p : polynomial R} : (normalize p).roots = p.roots := by\n  rw [normalize_apply, mul_comm, coe_norm_unit, roots_C_mul _ (norm_unit (leading_coeff p)).ne_zero]\n#align roots_normalize roots_normalize\n\n",
 "root_set_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem root_set_prod [CommRing S] [IsDomain S] [Algebra R S] {ι : Type _} (f : ι → polynomial R) (s : Finset ι)\n    (h : s.prod f ≠ 0) :\n    (s.prod f).root_set S =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ((f i).root_set S) :=\n  by\n  simp only [root_set, ← Finset.mem_coe]\n  rw [Polynomial.map_prod, roots_prod, Finset.bind_toFinset, s.val_to_finset, Finset.coe_bunionᵢ]\n  rwa [← Polynomial.map_prod, ne, map_eq_zero]\n#align root_set_prod root_set_prod\n\n",
 "root_set_monomial":
 "theorem root_set_monomial [CommRing S] [IsDomain S] [Algebra R S] {n : ℕ} (hn : n ≠ 0) {a : R} (ha : a ≠ 0) :\n    (monomial n a).root_set S = {0} := by\n  rw [root_set, map_monomial, roots_monomial ((_root_.map_ne_zero (algebraMap R S)).2 ha),\n    Multiset.toFinset_nsmul _ _ hn, Multiset.toFinset_singleton, Finset.coe_singleton]\n#align root_set_monomial root_set_monomial\n\n",
 "root_set_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_set_X_pow [CommRing S] [IsDomain S] [Algebra R S] {n : ℕ} (hn : n ≠ 0) :\n    (X ^ n : polynomial R).root_set S = {0} :=\n  by\n  rw [← one_mul (X ^ n : polynomial R), ← C_1, root_set_C_mul_X_pow hn]\n  exact one_ne_zero\n#align root_set_X_pow root_set_X_pow\n\n",
 "root_set_C_mul_X_pow":
 "theorem root_set_C_mul_X_pow [CommRing S] [IsDomain S] [Algebra R S] {n : ℕ} (hn : n ≠ 0) {a : R} (ha : a ≠ 0) :\n    (C a * X ^ n).root_set S = {0} := by rw [C_mul_X_pow_eq_monomial, root_set_monomial hn ha]\n#align root_set_C_mul_X_pow root_set_C_mul_X_pow\n\n",
 "root_right_of_root_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_right_of_root_gcd [CommSemiring k] {ϕ : «expr →+* » R k} {f g : polynomial R} {α : k}\n    (hα : (EuclideanDomain.gcd f g).eval₂ ϕ α = 0) : g.eval₂ ϕ α = 0 :=\n  by\n  cases' EuclideanDomain.gcd_dvd_right f g with p hp\n  rw [hp, Polynomial.eval₂_mul, hα, MulZeroClass.zero_mul]\n#align root_right_of_root_gcd root_right_of_root_gcd\n\n",
 "root_multiplicity_sub_one_le_derivative_root_multiplicity":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_sub_one_le_derivative_root_multiplicity [CharZero R] (p : polynomial R) (t : R) :\n    p.root_multiplicity t - 1 ≤ p.derivative.root_multiplicity t :=\n  by\n  by_cases p.is_root t\n  · exact (derivative_root_multiplicity_of_root h).symm.le\n  · rw [root_multiplicity_eq_zero h, zero_tsub]\n    exact zero_le _\n#align root_multiplicity_sub_one_le_derivative_root_multiplicity root_multiplicity_sub_one_le_derivative_root_multiplicity\n\n",
 "root_left_of_root_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_left_of_root_gcd [CommSemiring k] {ϕ : «expr →+* » R k} {f g : polynomial R} {α : k}\n    (hα : (EuclideanDomain.gcd f g).eval₂ ϕ α = 0) : f.eval₂ ϕ α = 0 :=\n  by\n  cases' EuclideanDomain.gcd_dvd_left f g with p hp\n  rw [hp, Polynomial.eval₂_mul, hα, MulZeroClass.zero_mul]\n#align root_left_of_root_gcd root_left_of_root_gcd\n\n",
 "root_gcd_iff_root_left_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_gcd_iff_root_left_right [CommSemiring k] {ϕ : «expr →+* » R k} {f g : polynomial R} {α : k} :\n    (EuclideanDomain.gcd f g).eval₂ ϕ α = 0 ↔ f.eval₂ ϕ α = 0 ∧ g.eval₂ ϕ α = 0 :=\n  ⟨fun h => ⟨root_left_of_root_gcd h, root_right_of_root_gcd h⟩, fun h => eval₂_gcd_eq_zero h.1 h.2⟩\n#align root_gcd_iff_root_left_right root_gcd_iff_root_left_right\n\n",
 "remainder_lt_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\nprivate theorem remainder_lt_aux (p : polynomial R) (hq : q ≠ 0) : degree (mod p q) < degree q := by\n  rw [← degree_mul_leading_coeff_inv q hq] <;> exact degree_mod_by_monic_lt p (monic_mul_leading_coeff_inv hq)\n#align remainder_lt_aux remainder_lt_aux\n\n",
 "quotient_mul_add_remainder_eq_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\nprivate theorem quotient_mul_add_remainder_eq_aux (p q : polynomial R) : q * div p q + mod p q = p :=\n  if h : q = 0 then by simp only [h, MulZeroClass.zero_mul, mod, mod_by_monic_zero, zero_add]\n  else\n    by\n    conv =>\n      rhs\n      rw [← mod_by_monic_add_div p (monic_mul_leading_coeff_inv h)]\n    rw [div, mod, add_comm, mul_assoc]\n#align quotient_mul_add_remainder_eq_aux quotient_mul_add_remainder_eq_aux\n\n",
 "prime_of_degree_eq_one":
 "theorem prime_of_degree_eq_one (hp1 : degree p = 1) : Prime p :=\n  have : Prime (normalize p) :=\n    Monic.prime_of_degree_eq_one (hp1 ▸ degree_normalize)\n      (monic_normalize fun hp0 => absurd hp1 (hp0.symm ▸ by simp <;> exact by decide))\n  (normalize_associated _).prime this\n#align prime_of_degree_eq_one prime_of_degree_eq_one\n\n",
 "not_irreducible_C":
 "theorem not_irreducible_C (x : R) : ¬Irreducible (C x) :=\n  if H : x = 0 then by\n    rw [H, C_0]\n    exact not_irreducible_zero\n  else fun hx => irreducible.not_unit hx <| isUnit_C.2 <| isUnit_iff_ne_zero.2 H\n#align not_irreducible_C not_irreducible_C\n\n",
 "normalize_monic":
 "theorem normalize_monic (h : Monic p) : normalize p = p := by simp [h]\n#align normalize_monic normalize_monic\n\n",
 "normalize_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.normalize_eq_self {p : polynomial R} (hp : p.monic) : normalize p = p := by\n  simp only [Polynomial.coe_normUnit, normalize_apply, hp.leading_coeff, normUnit_one, Units.val_one,\n    polynomial.C.map_one, mul_one]\n#align monic.normalize_eq_self monic.normalize_eq_self\n\n",
 "nat_degree_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem nat_degree_map [DivisionRing k] (f : «expr →+* » R k) : natDegree (p.map f) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_map _ f)\n#align nat_degree_map nat_degree_map\n\n",
 "mul_div_eq_iff_is_root":
 "theorem mul_div_eq_iff_is_root : (X - C a) * (p / (X - C a)) = p ↔ IsRoot p a :=\n  divByMonic_eq_div p (monic_X_sub_C a) ▸ mul_divByMonic_eq_iff_isRoot\n#align mul_div_eq_iff_is_root mul_div_eq_iff_is_root\n\n",
 "monic_normalize":
 "theorem monic_normalize (hp0 : p ≠ 0) : Monic (normalize p) :=\n  by\n  rw [ne.def, ← leading_coeff_eq_zero, ← ne.def, ← isUnit_iff_ne_zero] at hp0\n  rw [monic, leading_coeff_normalize, normalize_eq_one]\n  apply hp0\n#align monic_normalize monic_normalize\n\n",
 "monic_mul_leading_coeff_inv":
 "theorem monic_mul_leading_coeff_inv (h : p ≠ 0) : Monic (p * C (leadingCoeff p)⁻¹) := by\n  rw [monic, leading_coeff_mul, leading_coeff_C,\n    mul_inv_cancel (show leading_coeff p ≠ 0 from mt leading_coeff_eq_zero.1 h)]\n#align monic_mul_leading_coeff_inv monic_mul_leading_coeff_inv\n\n",
 "monic_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic_map_iff [DivisionRing k] {f : «expr →+* » R k} {p : polynomial R} : (p.map f).monic ↔ p.monic := by\n  rw [monic, leading_coeff_map, ← f.map_one, Function.Injective.eq_iff f.injective, monic]\n#align monic_map_iff monic_map_iff\n\n",
 "mod_eq_self_iff":
 "theorem mod_eq_self_iff (hq0 : q ≠ 0) : p % q = p ↔ degree p < degree q :=\n  ⟨fun h => h ▸ EuclideanDomain.mod_lt _ hq0, fun h =>\n    by\n    have : ¬degree (q * C (leadingCoeff q)⁻¹) ≤ degree p := not_le_of_gt <| by rwa [degree_mul_leading_coeff_inv q hq0]\n    rw [mod_def, mod_by_monic, dif_pos (monic_mul_leading_coeff_inv hq0)]\n    unfold div_mod_by_monic_aux\n    simp only [this, false_and_iff, if_false]⟩\n#align mod_eq_self_iff mod_eq_self_iff\n\n",
 "mod_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem mod_def : p % q = «expr %ₘ » p (q * C (leadingCoeff q)⁻¹) :=\n  rfl\n#align mod_def mod_def\n\n",
 "mod_by_monic_eq_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem mod_by_monic_eq_mod (p : polynomial R) (hq : Monic q) : «expr %ₘ » p q = p % q :=\n  show «expr %ₘ » p q = «expr %ₘ » p (q * C (leadingCoeff q)⁻¹) by simp only [monic.def.1 hq, inv_one, mul_one, C_1]\n#align mod_by_monic_eq_mod mod_by_monic_eq_mod\n\n",
 "mod_X_sub_C_eq_C_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mod_X_sub_C_eq_C_eval (p : polynomial R) (a : R) : p % (X - C a) = C (p.eval a) :=\n  modByMonic_eq_mod p (monic_X_sub_C a) ▸ modByMonic_X_sub_C_eq_C_eval _ _\n#align mod_X_sub_C_eq_C_eval mod_X_sub_C_eq_C_eval\n\n",
 "mem_roots_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem mem_roots_map [CommRing k] [IsDomain k] {f : «expr →+* » R k} {x : k} (hp : p ≠ 0) :\n    x ∈ (p.map f).roots ↔ p.eval₂ f x = 0 := by\n  rw [mem_roots (map_ne_zero hp), is_root, Polynomial.eval_map] <;> infer_instance\n#align mem_roots_map mem_roots_map\n\n",
 "map_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print map_ne_zero /-\ntheorem map_ne_zero [Semiring S] [Nontrivial S] {f : «expr →+* » R S} (hp : p ≠ 0) : p.map f ≠ 0 :=\n  mt (map_eq_zero f).1 hp\n#align map_ne_zero map_ne_zero\n-/\n\n",
 "map_mod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_mod [Field k] (f : «expr →+* » R k) : (p % q).map f = p.map f % q.map f :=\n  if hq0 : q = 0 then by simp [hq0]\n  else by\n    rw [mod_def, mod_def, leading_coeff_map f, ← map_inv₀ f, ← map_C f, ← Polynomial.map_mul f,\n      map_mod_by_monic f (monic_mul_leading_coeff_inv hq0)]\n#align map_mod map_mod\n\n",
 "map_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print map_eq_zero /-\n@[simp]\ntheorem map_eq_zero [Semiring S] [Nontrivial S] (f : «expr →+* » R S) : p.map f = 0 ↔ p = 0 := by\n  simp only [Polynomial.ext_iff, map_eq_zero, coeff_map, coeff_zero]\n#align map_eq_zero map_eq_zero\n-/\n\n",
 "map_dvd_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem map_dvd_map' [Field k] (f : «expr →+* » R k) {x y : polynomial R} : x.map f ∣ y.map f ↔ x ∣ y :=\n  if H : x = 0 then by rw [H, Polynomial.map_zero, zero_dvd_iff, zero_dvd_iff, map_eq_zero]\n  else by\n    rw [← normalize_dvd_iff, ← @normalize_dvd_iff (polynomial R), normalize_apply, normalize_apply,\n      coe_norm_unit_of_ne_zero H, coe_norm_unit_of_ne_zero (mt (map_eq_zero f).1 H), leading_coeff_map, ← map_inv₀ f, ←\n      map_C, ← Polynomial.map_mul, map_dvd_map _ f.injective (monic_mul_leading_coeff_inv H)]\n#align map_dvd_map' map_dvd_map'\n\n",
 "map_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n#print map_div /-\ntheorem map_div [Field k] (f : «expr →+* » R k) : (p / q).map f = p.map f / q.map f :=\n  if hq0 : q = 0 then by simp [hq0]\n  else by\n    rw [div_def, div_def, Polynomial.map_mul, map_div_by_monic f (monic_mul_leading_coeff_inv hq0)] <;>\n      simp [coeff_map f]\n#align map_div map_div\n-/\n\n",
 "leading_coeff_normalize":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem leading_coeff_normalize (p : polynomial R) : leadingCoeff (normalize p) = normalize (leadingCoeff p) := by simp\n#align leading_coeff_normalize leading_coeff_normalize\n\n",
 "leading_coeff_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem leading_coeff_map [DivisionRing k] (f : «expr →+* » R k) : leadingCoeff (p.map f) = f (leadingCoeff p) := by\n  simp only [← coeff_nat_degree, coeff_map f, nat_degree_map]\n#align leading_coeff_map leading_coeff_map\n\n",
 "leading_coeff_div":
 "theorem leading_coeff_div (hpq : q.degree ≤ p.degree) : (p / q).leading_coeff = p.leading_coeff / q.leading_coeff :=\n  by\n  by_cases hq : q = 0; · simp [hq]\n  rw [div_def, leading_coeff_mul, leading_coeff_C,\n    leading_coeff_div_by_monic_of_monic (monic_mul_leading_coeff_inv hq) _, mul_comm, div_eq_mul_inv]\n  rwa [degree_mul_leading_coeff_inv q hq]\n#align leading_coeff_div leading_coeff_div\n\n",
 "is_unit_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_unit_map [Field k] (f : «expr →+* » R k) : IsUnit (p.map f) ↔ IsUnit p := by\n  simp_rw [is_unit_iff_degree_eq_zero, degree_map]\n#align is_unit_map is_unit_map\n\n",
 "is_unit_iff_degree_eq_zero":
 "theorem is_unit_iff_degree_eq_zero : IsUnit p ↔ degree p = 0 :=\n  ⟨degree_eq_zero_of_isUnit, fun h =>\n    have : degree p ≤ 0 := by simp [*, le_refl]\n    have hc : coeff p 0 ≠ 0 := fun hc => by rw [eq_C_of_degree_le_zero this, hc] at h <;> simpa using h\n    isUnit_iff_dvd_one.2\n      ⟨C (coeff p 0)⁻¹, by\n        conv in p => rw [eq_C_of_degree_le_zero this]\n        rw [← C_mul, _root_.mul_inv_cancel hc, C_1]⟩⟩\n#align is_unit_iff_degree_eq_zero is_unit_iff_degree_eq_zero\n\n",
 "is_root_gcd_iff_is_root_left_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_root_gcd_iff_is_root_left_right {f g : polynomial R} {α : R} :\n    (EuclideanDomain.gcd f g).is_root α ↔ f.is_root α ∧ g.is_root α :=\n  root_gcd_iff_root_left_right\n#align is_root_gcd_iff_is_root_left_right is_root_gcd_iff_is_root_left_right\n\n",
 "is_coprime_of_is_root_of_eval_derivative_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/-- If `f` is a polynomial over a field, and `a : K` satisfies `f' a ≠ 0`,\nthen `f / (X - a)` is coprime with `X - a`.\nNote that we do not assume `f a = 0`, because `f / (X - a) = (f - f a) / (X - a)`. -/\ntheorem is_coprime_of_is_root_of_eval_derivative_ne_zero {K : Type _} [Field K] (f : polynomial K) (a : K)\n    (hf' : f.derivative.eval a ≠ 0) : IsCoprime (X - C a : polynomial K) («expr /ₘ » f (X - C a)) :=\n  by\n  refine'\n    or.resolve_left\n      (EuclideanDomain.dvd_or_coprime (X - C a) («expr /ₘ » f (X - C a))\n        (irreducible_of_degree_eq_one (Polynomial.degree_X_sub_C a)))\n      _\n  contrapose! hf' with h\n  have key : (X - C a) * «expr /ₘ » f (X - C a) = f - «expr %ₘ » f (X - C a) :=\n    by\n    rw [eq_sub_iff_add_eq, ← eq_sub_iff_add_eq', mod_by_monic_eq_sub_mul_div]\n    exact monic_X_sub_C a\n  replace key := congr_arg derivative key\n  simp only [derivative_X, derivative_mul, one_mul, sub_zero, derivative_sub, mod_by_monic_X_sub_C_eq_C_eval,\n    derivative_C] at key\n  have : X - C a ∣ derivative f := key ▸ dvd_add h (dvd_mul_right _ _)\n  rw [← dvd_iff_mod_by_monic_eq_zero (monic_X_sub_C _), mod_by_monic_X_sub_C_eq_C_eval] at this\n  rw [← C_inj, this, C_0]\n#align is_coprime_of_is_root_of_eval_derivative_ne_zero is_coprime_of_is_root_of_eval_derivative_ne_zero\n\n",
 "is_coprime_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_coprime_map [Field k] (f : «expr →+* » R k) : IsCoprime (p.map f) (q.map f) ↔ IsCoprime p q := by\n  rw [← EuclideanDomain.gcd_isUnit_iff, ← EuclideanDomain.gcd_isUnit_iff, gcd_map, is_unit_map]\n#align is_coprime_map is_coprime_map\n\n",
 "irreducible_of_degree_eq_one":
 "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p :=\n  (prime_of_degree_eq_one hp1).irreducible\n#align irreducible_of_degree_eq_one irreducible_of_degree_eq_one\n\n",
 "gcd_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem gcd_map [Field k] (f : «expr →+* » R k) : gcd (p.map f) (q.map f) = (gcd p q).map f :=\n  GCD.induction p q (fun x => by simp_rw [Polynomial.map_zero, EuclideanDomain.gcd_zero_left]) fun x y hx ih => by\n    rw [gcd_val, ← map_mod, ih, ← gcd_val]\n#align gcd_map gcd_map\n\n",
 "exists_root_of_degree_eq_one":
 "theorem exists_root_of_degree_eq_one (h : degree p = 1) : ∃ x, IsRoot p x :=\n  ⟨-(p.coeff 0 / p.coeff 1),\n    by\n    have : p.coeff 1 ≠ 0 := by\n      rw [← nat_degree_eq_of_degree_eq_some h] <;> exact mt leading_coeff_eq_zero.1 fun h0 => by simpa [h0] using h\n    conv in p => rw [eq_X_add_C_of_degree_le_one (show degree p ≤ 1 by rw [h] <;> exact le_rfl)] <;>\n      simp [is_root, mul_div_cancel' _ this]⟩\n#align exists_root_of_degree_eq_one exists_root_of_degree_eq_one\n\n",
 "eval₂_gcd_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval₂_gcd_eq_zero [CommSemiring k] {ϕ : «expr →+* » R k} {f g : polynomial R} {α : k} (hf : f.eval₂ ϕ α = 0)\n    (hg : g.eval₂ ϕ α = 0) : (EuclideanDomain.gcd f g).eval₂ ϕ α = 0 := by\n  rw [EuclideanDomain.gcd_eq_gcd_ab f g, Polynomial.eval₂_add, Polynomial.eval₂_mul, Polynomial.eval₂_mul, hf, hg,\n    MulZeroClass.zero_mul, MulZeroClass.zero_mul, zero_add]\n#align eval₂_gcd_eq_zero eval₂_gcd_eq_zero\n\n",
 "eval_gcd_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval_gcd_eq_zero {f g : polynomial R} {α : R} (hf : f.eval α = 0) (hg : g.eval α = 0) :\n    (EuclideanDomain.gcd f g).eval α = 0 :=\n  eval₂_gcd_eq_zero hf hg\n#align eval_gcd_eq_zero eval_gcd_eq_zero\n\n",
 "dvd_C_mul":
 "theorem dvd_C_mul (ha : a ≠ 0) : p ∣ Polynomial.C a * q ↔ p ∣ q :=\n  ⟨fun ⟨r, hr⟩ =>\n    ⟨C a⁻¹ * r, by rw [mul_left_comm p, ← hr, ← mul_assoc, ← C.map_mul, _root_.inv_mul_cancel ha, C.map_one, one_mul]⟩,\n    fun h => dvd_trans h (dvd_mul_left _ _)⟩\n#align dvd_C_mul dvd_C_mul\n\n",
 "div_eq_zero_iff":
 "#print div_eq_zero_iff /-\ntheorem div_eq_zero_iff (hq0 : q ≠ 0) : p / q = 0 ↔ degree p < degree q :=\n  ⟨fun h => by\n    have := EuclideanDomain.div_add_mod p q <;> rwa [h, MulZeroClass.mul_zero, zero_add, mod_eq_self_iff hq0] at this,\n    fun h =>\n    by\n    have hlt : degree p < degree (q * C (leadingCoeff q)⁻¹) := by rwa [degree_mul_leading_coeff_inv q hq0]\n    have hm : Monic (q * C (leadingCoeff q)⁻¹) := monic_mul_leadingCoeff_inv hq0\n    rw [div_def, (div_by_monic_eq_zero_iff hm).2 hlt, MulZeroClass.mul_zero]⟩\n#align div_eq_zero_iff div_eq_zero_iff\n-/\n\n",
 "div_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem div_def : p / q = C (leadingCoeff q)⁻¹ * «expr /ₘ » p (q * C (leadingCoeff q)⁻¹) :=\n  rfl\n#align div_def div_def\n\n",
 "div_by_monic_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem div_by_monic_eq_div (p : polynomial R) (hq : Monic q) : «expr /ₘ » p q = p / q :=\n  show «expr /ₘ » p q = C (leadingCoeff q)⁻¹ * «expr /ₘ » p (q * C (leadingCoeff q)⁻¹) by\n    simp only [monic.def.1 hq, inv_one, C_1, one_mul, mul_one]\n#align div_by_monic_eq_div div_by_monic_eq_div\n\n",
 "div_C_mul":
 "theorem div_C_mul : p / (C a * q) = C a⁻¹ * (p / q) :=\n  by\n  by_cases ha : a = 0\n  · simp [ha]\n  simp only [div_def, leading_coeff_mul, mul_inv, leading_coeff_C, C.map_mul, mul_assoc]\n  congr 3\n  rw [mul_left_comm q, ← mul_assoc, ← C.map_mul, mul_inv_cancel ha, C.map_one, one_mul]\n#align div_C_mul div_C_mul\n\n",
 "derivative_root_multiplicity_of_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker\n-/\ntheorem derivative_root_multiplicity_of_root [CharZero R] {p : polynomial R} {t : R} (hpt : p.is_root t) :\n    p.derivative.root_multiplicity t = p.root_multiplicity t - 1 :=\n  by\n  rcases eq_or_ne p 0 with (rfl | hp)\n  · simp\n  nth_rw 1 [← p.div_by_monic_mul_pow_root_multiplicity_eq t]\n  simp only [derivative_pow, derivative_mul, derivative_sub, derivative_X, derivative_C, sub_zero, mul_one]\n  set n := p.root_multiplicity t - 1\n  have hn : n + 1 = _ := tsub_add_cancel_of_le ((root_multiplicity_pos hp).mpr hpt)\n  rw [← hn]\n  set q := «expr /ₘ » p ((X - C t) ^ (n + 1)) with hq\n  convert_to root_multiplicity t ((X - C t) ^ n * (derivative q * (X - C t) + q * C ↑(n + 1))) = n\n  · congr\n    rw [mul_add, mul_left_comm <| (X - C t) ^ n, ← pow_succ']\n    congr 1\n    rw [mul_left_comm <| (X - C t) ^ n, mul_comm <| (X - C t) ^ n]\n  have h : (derivative q * (X - C t) + q * C ↑(n + 1)).eval t ≠ 0 :=\n    by\n    suffices eval t q * ↑(n + 1) ≠ 0 by simpa\n    refine' mul_ne_zero _ (nat.cast_ne_zero.mpr n.succ_ne_zero)\n    convert eval_div_by_monic_pow_root_multiplicity_ne_zero t hp\n    exact hn ▸ hq\n  rw [root_multiplicity_mul, root_multiplicity_X_sub_C_pow, root_multiplicity_eq_zero h, add_zero]\n  refine' mul_ne_zero (pow_ne_zero n <| X_sub_C_ne_zero t) _\n  contrapose! h\n  rw [h, eval_zero]\n#align derivative_root_multiplicity_of_root derivative_root_multiplicity_of_root\n\n",
 "degree_pos_of_ne_zero_of_nonunit":
 "theorem degree_pos_of_ne_zero_of_nonunit (hp0 : p ≠ 0) (hp : ¬IsUnit p) : 0 < degree p :=\n  lt_of_not_ge fun h => by\n    rw [eq_C_of_degree_le_zero h] at hp0 hp\n    exact hp (IsUnit.map C (IsUnit.mk0 (coeff p 0) (mt C_inj.2 (by simpa using hp0))))\n#align degree_pos_of_ne_zero_of_nonunit degree_pos_of_ne_zero_of_nonunit\n\n",
 "degree_pos_of_irreducible":
 "theorem degree_pos_of_irreducible (hp : Irreducible p) : 0 < p.degree :=\n  lt_of_not_ge fun hp0 =>\n    have := eq_C_of_degree_le_zero hp0\n    not_irreducible_C (p.coeff 0) <| this ▸ hp\n#align degree_pos_of_irreducible degree_pos_of_irreducible\n\n",
 "degree_normalize":
 "theorem degree_normalize : degree (normalize p) = degree p := by simp\n#align degree_normalize degree_normalize\n\n",
 "degree_mul_leading_coeff_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_mul_leading_coeff_inv (p : polynomial R) (h : q ≠ 0) : degree (p * C (leadingCoeff q)⁻¹) = degree p :=\n  by\n  have h₁ : (leadingCoeff q)⁻¹ ≠ 0 := inv_ne_zero (mt leadingCoeff_eq_zero.1 h)\n  rw [degree_mul, degree_C h₁, add_zero]\n#align degree_mul_leading_coeff_inv degree_mul_leading_coeff_inv\n\n",
 "degree_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem degree_map [DivisionRing k] (p : polynomial R) (f : «expr →+* » R k) : degree (p.map f) = degree p :=\n  p.degree_map_eq_of_injective f.injective\n#align degree_map degree_map\n\n",
 "degree_div_lt":
 "theorem degree_div_lt (hp : p ≠ 0) (hq : 0 < degree q) : degree (p / q) < degree p :=\n  by\n  have hq0 : q ≠ 0 := fun hq0 => by simpa [hq0] using hq\n  rw [div_def, mul_comm, degree_mul_leading_coeff_inv _ hq0] <;>\n    exact\n      degree_div_by_monic_lt _ (monic_mul_leading_coeff_inv hq0) hp\n        (by rw [degree_mul_leading_coeff_inv _ hq0] <;> exact hq)\n#align degree_div_lt degree_div_lt\n\n",
 "degree_div_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_div_le (p q : polynomial R) : degree (p / q) ≤ degree p :=\n  if hq : q = 0 then by simp [hq]\n  else by rw [div_def, mul_comm, degree_mul_leading_coeff_inv _ hq] <;> exact degree_div_by_monic_le _ _\n#align degree_div_le degree_div_le\n\n",
 "degree_add_div":
 "theorem degree_add_div (hq0 : q ≠ 0) (hpq : degree q ≤ degree p) : degree q + degree (p / q) = degree p :=\n  by\n  have : degree (p % q) < degree (q * (p / q)) :=\n    calc\n      degree (p % q) < degree q := EuclideanDomain.mod_lt _ hq0\n      _ ≤ _ := degree_le_mul_left _ (mt (div_eq_zero_iff hq0).1 (not_lt_of_ge hpq))\n      \n  conv_rhs => rw [← EuclideanDomain.div_add_mod p q, degree_add_eq_left_of_degree_lt this, degree_mul]\n#align degree_add_div degree_add_div\n\n",
 "coeff_inv_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_inv_units (u : «expr ˣ» (polynomial R)) (n : ℕ) :\n    ((↑u : polynomial R).coeff n)⁻¹ = (↑u⁻¹ : polynomial R).coeff n :=\n  by\n  rw [eq_C_of_degree_eq_zero (degree_coe_units u), eq_C_of_degree_eq_zero (degree_coe_units u⁻¹), coeff_C, coeff_C,\n    inv_eq_one_div]\n  split_ifs\n  ·\n    rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ←\n        eval_mul, ← Units.val_mul, inv_mul_self] <;>\n      simp\n  · simp\n#align coeff_inv_units coeff_inv_units\n\n",
 "coe_norm_unit_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coe_norm_unit_of_ne_zero (hp : p ≠ 0) : (norm_unit p : polynomial R) = C p.leading_coeff⁻¹ :=\n  by\n  have : p.leading_coeff ≠ 0 := mt leadingCoeff_eq_zero.mp hp\n  simp [CommGroupWithZero.coe_normUnit _ this]\n#align coe_norm_unit_of_ne_zero coe_norm_unit_of_ne_zero\n\n",
 "coe_norm_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem coe_norm_unit {p : polynomial R} : (norm_unit p : polynomial R) = C ↑(norm_unit p.leading_coeff) := by\n  simp [norm_unit]\n#align coe_norm_unit coe_norm_unit\n\n",
 "C_mul_dvd":
 "theorem C_mul_dvd (ha : a ≠ 0) : C a * p ∣ q ↔ p ∣ q :=\n  ⟨fun h => dvd_trans (dvd_mul_left _ _) h, fun ⟨r, hr⟩ =>\n    ⟨C a⁻¹ * r, by\n      rw [mul_assoc, mul_left_comm p, ← mul_assoc, ← C.map_mul, _root_.mul_inv_cancel ha, C.map_one, one_mul, hr]⟩⟩\n#align C_mul_dvd C_mul_dvd\n\n"}