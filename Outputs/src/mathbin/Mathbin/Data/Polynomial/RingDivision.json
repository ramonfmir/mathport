{"zero_of_eval_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem zero_of_eval_zero [Infinite R] (p : polynomial R) (h : ∀ x, p.eval x = 0) : p = 0 := by\n  classical by_contra hp <;>\n      exact fintype.false ⟨p.roots.to_finset, fun x => multiset.mem_to_finset.mpr ((mem_roots hp).mpr (h _))⟩\n#align zero_of_eval_zero zero_of_eval_zero\n\n",
 "units_coeff_zero_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem units_coeff_zero_smul (c : «expr ˣ» (polynomial R)) (p : polynomial R) :\n    «expr • » ((c : polynomial R).coeff 0) p = c * p := by\n  rw [← polynomial.C_mul', ← polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]\n#align units_coeff_zero_smul units_coeff_zero_smul\n\n",
 "trailing_degree_mul":
 "theorem trailing_degree_mul : (p * q).trailing_degree = p.trailing_degree + q.trailing_degree :=\n  by\n  by_cases hp : p = 0\n  · rw [hp, zero_mul, trailing_degree_zero, top_add]\n  by_cases hq : q = 0\n  · rw [hq, mul_zero, trailing_degree_zero, add_top]\n  rw [trailing_degree_eq_nat_trailing_degree hp, trailing_degree_eq_nat_trailing_degree hq,\n    trailing_degree_eq_nat_trailing_degree (mul_ne_zero hp hq), nat_trailing_degree_mul hp hq, WithTop.coe_add]\n#align trailing_degree_mul trailing_degree_mul\n\n",
 "smul_mod_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem smul_mod_by_monic (c : R) (p : polynomial R) : «expr %ₘ » («expr • » c p) q = «expr • » c («expr %ₘ » p q) :=\n  by\n  by_cases hq : q.monic\n  · nontriviality R\n    exact\n      (div_mod_by_monic_unique («expr • » c («expr /ₘ » p q)) («expr • » c («expr %ₘ » p q)) hq\n          ⟨by rw [mul_smul_comm, ← smul_add, mod_by_monic_add_div p hq],\n            (degree_smul_le _ _).trans_lt (degree_mod_by_monic_lt _ hq)⟩).2\n  · simp_rw [mod_by_monic_eq_of_not_monic _ hq]\n#align smul_mod_by_monic smul_mod_by_monic\n\n",
 "roots_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem roots_zero : (0 : polynomial R).roots = 0 :=\n  dif_pos rfl\n#align roots_zero roots_zero\n\n",
 "roots_smul_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem roots_smul_nonzero (p : polynomial R) (ha : a ≠ 0) : («expr • » a p).roots = p.roots := by\n  rw [smul_eq_C_mul, roots_C_mul _ ha]\n#align roots_smul_nonzero roots_smul_nonzero\n\n",
 "roots_prod_X_sub_C":
 "theorem roots_prod_X_sub_C (s : Finset R) : (s.prod fun a => X - C a).roots = s.val :=\n  (roots_prod (fun a => X - C a) s (prod_ne_zero_iff.mpr fun a _ => X_sub_C_ne_zero a)).trans\n    (by simp_rw [roots_X_sub_C, Multiset.bind_singleton, Multiset.map_id'])\n#align roots_prod_X_sub_C roots_prod_X_sub_C\n\n",
 "roots_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_prod {ι : Type _} (f : ι → polynomial R) (s : Finset ι) :\n    s.prod f ≠ 0 → (s.prod f).roots = s.val.bind fun i => roots (f i) :=\n  by\n  rcases s with ⟨m, hm⟩\n  simpa [Multiset.prod_eq_zero_iff, bind_map] using roots_multiset_prod (m.map f)\n#align roots_prod roots_prod\n\n",
 "roots_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem roots_pow (p : polynomial R) (n : ℕ) : (p ^ n).roots = «expr • » n p.roots :=\n  by\n  induction' n with n ihn\n  · rw [pow_zero, roots_one, zero_smul, empty_eq_zero]\n  · rcases eq_or_ne p 0 with (rfl | hp)\n    · rw [zero_pow n.succ_pos, roots_zero, smul_zero]\n    · rw [pow_succ', roots_mul (mul_ne_zero (pow_ne_zero _ hp) hp), ihn, nat.succ_eq_add_one, add_smul, one_smul]\n#align roots_pow roots_pow\n\n",
 "roots_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem roots_one : (1 : polynomial R).roots = ∅ :=\n  roots_C 1\n#align roots_one roots_one\n\n",
 "roots_multiset_prod_X_sub_C":
 "@[simp]\ntheorem roots_multiset_prod_X_sub_C (s : Multiset R) : (s.map fun a => X - C a).prod.roots = s :=\n  by\n  rw [roots_multiset_prod, Multiset.bind_map]\n  · simp_rw [roots_X_sub_C, Multiset.bind_singleton, Multiset.map_id']\n  · rw [Multiset.mem_map]\n    rintro ⟨a, -, h⟩\n    exact X_sub_C_ne_zero a h\n#align roots_multiset_prod_X_sub_C roots_multiset_prod_X_sub_C\n\n",
 "roots_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_multiset_prod (m : Multiset (polynomial R)) : (0 : polynomial R) ∉ m → m.prod.roots = m.bind roots :=\n  by\n  rcases m with ⟨L⟩\n  simpa only [Multiset.coe_prod, quot_mk_to_coe''] using roots_list_prod L\n#align roots_multiset_prod roots_multiset_prod\n\n",
 "roots_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_mul {p q : polynomial R} (hpq : p * q ≠ 0) : (p * q).roots = p.roots + q.roots :=\n  Multiset.ext.mpr fun r => by rw [count_add, count_roots, count_roots, count_roots, root_multiplicity_mul hpq]\n#align roots_mul roots_mul\n\n",
 "roots_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem roots_monomial (ha : a ≠ 0) (n : ℕ) : (monomial n a).roots = «expr • » n {0} := by\n  rw [← C_mul_X_pow_eq_monomial, roots_C_mul_X_pow ha]\n#align roots_monomial roots_monomial\n\n",
 "roots_map_of_injective_of_card_eq_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem roots_map_of_injective_of_card_eq_nat_degree [IsDomain A] [IsDomain B] {p : polynomial A} {f : «expr →+* » A B}\n    (hf : function.injective f) (hroots : p.roots.card = p.nat_degree) : p.roots.map f = (p.map f).roots :=\n  by\n  apply Multiset.eq_of_le_of_card_le (map_roots_le_of_injective p hf)\n  simpa only [Multiset.card_map, hroots] using (card_roots' _).trans (nat_degree_map_le f p)\n#align roots_map_of_injective_of_card_eq_nat_degree roots_map_of_injective_of_card_eq_nat_degree\n\n",
 "roots_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_list_prod (L : list (polynomial R)) :\n    (0 : polynomial R) ∉ L → L.prod.roots = (L : Multiset (polynomial R)).bind roots :=\n  list.rec_on L (fun _ => roots_one) fun hd tl ih H =>\n    by\n    rw [List.mem_cons, not_or] at H\n    rw [List.prod_cons, roots_mul (mul_ne_zero (ne.symm H.1) <| List.prod_ne_zero H.2), ← Multiset.cons_coe,\n      Multiset.cons_bind, ih H.2]\n#align roots_list_prod roots_list_prod\n\n",
 "roots_X_sub_C":
 "@[simp]\ntheorem roots_X_sub_C (r : R) : roots (X - C r) = {r} := by\n  ext s\n  rw [count_roots, root_multiplicity_X_sub_C, count_singleton]\n#align roots_X_sub_C roots_X_sub_C\n\n",
 "roots_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem roots_X_pow (n : ℕ) : (X ^ n : polynomial R).roots = «expr • » n {0} := by rw [roots_pow, roots_X]\n#align roots_X_pow roots_X_pow\n\n",
 "roots_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem roots_X : roots (X : polynomial R) = {0} := by rw [← roots_X_sub_C, C_0, sub_zero]\n#align roots_X roots_X\n\n",
 "roots_C_mul_X_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem roots_C_mul_X_pow (ha : a ≠ 0) (n : ℕ) : (C a * X ^ n).roots = «expr • » n {0} := by\n  rw [roots_C_mul _ ha, roots_X_pow]\n#align roots_C_mul_X_pow roots_C_mul_X_pow\n\n",
 "roots_C_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem roots_C_mul (p : polynomial R) (ha : a ≠ 0) : (C a * p).roots = p.roots := by\n  by_cases hp : p = 0 <;>\n    simp only [roots_mul, *, ne.def, mul_eq_zero, C_eq_zero, or_self_iff, not_false_iff, roots_C, zero_add, mul_zero]\n#align roots_C_mul roots_C_mul\n\n",
 "roots_C":
 "@[simp]\ntheorem roots_C (x : R) : (C x).roots = 0 :=\n  if H : x = 0 then by rw [H, C_0, roots_zero]\n  else Multiset.ext.mpr fun r => by rw [count_roots, count_zero, root_multiplicity_eq_zero (not_is_root_C _ _ H)]\n#align roots_C roots_C\n\n",
 "root_set_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem root_set_zero (S) [CommRing S] [IsDomain S] [algebra T S] : (0 : polynomial T).root_set S = ∅ := by\n  rw [← C_0, root_set_C]\n#align root_set_zero root_set_zero\n\n",
 "root_set_maps_to'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem root_set_maps_to' {p : polynomial T} {S S'} [CommRing S] [IsDomain S] [algebra T S] [CommRing S'] [IsDomain S']\n    [algebra T S'] (hp : p.map (algebra_map T S') = 0 → p.map (algebra_map T S) = 0) (f : «expr →ₐ[ ] » S T S') :\n    (p.root_set S).maps_to f (p.root_set S') := fun x hx =>\n  by\n  rw [mem_root_set'] at hx⊢\n  rw [aeval_alg_hom, alg_hom.comp_apply, hx.2, _root_.map_zero]\n  exact ⟨mt hp hx.1, rfl⟩\n#align root_set_maps_to' root_set_maps_to'\n\n",
 "root_set_maps_to":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem root_set_maps_to {p : polynomial T} {S S'} [CommRing S] [IsDomain S] [algebra T S] [CommRing S'] [IsDomain S']\n    [algebra T S'] [NoZeroSMulDivisors T S'] (f : «expr →ₐ[ ] » S T S') : (p.root_set S).maps_to f (p.root_set S') :=\n  by\n  refine' root_set_maps_to' (fun h₀ => _) f\n  obtain rfl : p = 0 :=\n    map_injective _ (no_zero_smul_divisors.algebra_map_injective T S') (by rwa [polynomial.map_zero])\n  exact polynomial.map_zero _\n#align root_set_maps_to root_set_maps_to\n\n",
 "root_set_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_set_finite (p : polynomial T) (S : Type _) [CommRing S] [IsDomain S] [algebra T S] :\n    (p.root_set S).finite :=\n  set.to_finite _\n#align root_set_finite root_set_finite\n\n",
 "root_set_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_set_def (p : polynomial T) (S) [CommRing S] [IsDomain S] [algebra T S] :\n    p.root_set S = (p.map (algebra_map T S)).roots.to_finset :=\n  rfl\n#align root_set_def root_set_def\n\n",
 "root_set_C":
 "@[simp]\ntheorem root_set_C [CommRing S] [IsDomain S] [algebra T S] (a : T) : (C a).root_set S = ∅ := by\n  rw [root_set_def, map_C, roots_C, Multiset.toFinset_zero, Finset.coe_empty]\n#align root_set_C root_set_C\n\n",
 "root_or_root_of_root_mul":
 "theorem root_or_root_of_root_mul (h : is_root (p * q) a) : is_root p a ∨ is_root q a :=\n  root_mul.1 h\n#align root_or_root_of_root_mul root_or_root_of_root_mul\n\n",
 "root_multiplicity_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_mul {p q : polynomial R} {x : R} (hpq : p * q ≠ 0) :\n    root_multiplicity x (p * q) = root_multiplicity x p + root_multiplicity x q :=\n  by\n  have hp : p ≠ 0 := left_ne_zero_of_mul hpq\n  have hq : q ≠ 0 := right_ne_zero_of_mul hpq\n  rw [root_multiplicity_eq_multiplicity (p * q), dif_neg hpq, root_multiplicity_eq_multiplicity p, dif_neg hp,\n    root_multiplicity_eq_multiplicity q, dif_neg hq, multiplicity.mul' (prime_X_sub_C x)]\n#align root_multiplicity_mul root_multiplicity_mul\n\n",
 "root_multiplicity_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_le_iff {p : polynomial R} (p0 : p ≠ 0) (a : R) (n : ℕ) :\n    root_multiplicity a p ≤ n ↔ ¬(X - C a) ^ (n + 1) ∣ p := by\n  rw [← (le_root_multiplicity_iff p0).not, not_le, Nat.lt_add_one_iff]\n#align root_multiplicity_le_iff root_multiplicity_le_iff\n\n",
 "root_multiplicity_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem root_multiplicity_add {p q : polynomial R} (a : R) (hzero : p + q ≠ 0) :\n    min (root_multiplicity a p) (root_multiplicity a q) ≤ root_multiplicity a (p + q) :=\n  by\n  rw [le_root_multiplicity_iff hzero]\n  have hdivp : (X - C a) ^ root_multiplicity a p ∣ p := pow_root_multiplicity_dvd p a\n  have hdivq : (X - C a) ^ root_multiplicity a q ∣ q := pow_root_multiplicity_dvd q a\n  exact min_pow_dvd_add hdivp hdivq\n#align root_multiplicity_add root_multiplicity_add\n\n",
 "root_multiplicity_X_sub_C_self":
 "theorem root_multiplicity_X_sub_C_self {x : R} : root_multiplicity x (X - C x) = 1 := by\n  rw [root_multiplicity_eq_multiplicity, dif_neg (X_sub_C_ne_zero x), multiplicity.get_multiplicity_self]\n#align root_multiplicity_X_sub_C_self root_multiplicity_X_sub_C_self\n\n",
 "root_multiplicity_X_sub_C_pow":
 "/-- The multiplicity of `a` as root of `(X - a) ^ n` is `n`. -/\ntheorem root_multiplicity_X_sub_C_pow (a : R) (n : ℕ) : root_multiplicity a ((X - C a) ^ n) = n :=\n  by\n  induction' n with n hn\n  · refine' root_multiplicity_eq_zero _\n    simp only [eval_one, is_root.def, not_false_iff, one_ne_zero, pow_zero]\n  have hzero := pow_ne_zero n.succ (X_sub_C_ne_zero a)\n  rw [pow_succ (X - C a) n] at hzero⊢\n  simp only [root_multiplicity_mul hzero, root_multiplicity_X_sub_C_self, hn, Nat.one_add]\n#align root_multiplicity_X_sub_C_pow root_multiplicity_X_sub_C_pow\n\n",
 "root_multiplicity_X_sub_C":
 "theorem root_multiplicity_X_sub_C {x y : R} : root_multiplicity x (X - C y) = if x = y then 1 else 0 :=\n  by\n  split_ifs with hxy\n  · rw [hxy]\n    exact root_multiplicity_X_sub_C_self\n  exact root_multiplicity_eq_zero (mt root_X_sub_C.mp (ne.symm hxy))\n#align root_multiplicity_X_sub_C root_multiplicity_X_sub_C\n\n",
 "root_mul":
 "theorem root_mul : is_root (p * q) a ↔ is_root p a ∨ is_root q a := by simp_rw [is_root, eval_mul, mul_eq_zero]\n#align root_mul root_mul\n\n",
 "prod_multiset_root_eq_finset_root":
 "theorem prod_multiset_root_eq_finset_root :\n    (p.roots.map fun a => X - C a).prod = p.roots.to_finset.prod fun a => (X - C a) ^ root_multiplicity a p := by\n  simp only [count_roots, finset.prod_multiset_map_count]\n#align prod_multiset_root_eq_finset_root prod_multiset_root_eq_finset_root\n\n",
 "prod_multiset_X_sub_C_of_monic_of_roots_card_eq":
 "/-- A monic polynomial `p` that has as many roots as its degree\ncan be written `p = ∏(X - a)`, for `a` in `p.roots`. -/\ntheorem prod_multiset_X_sub_C_of_monic_of_roots_card_eq (hp : p.monic) (hroots : p.roots.card = p.nat_degree) :\n    (p.roots.map fun a => X - C a).prod = p :=\n  by\n  convert C_leading_coeff_mul_prod_multiset_X_sub_C hroots\n  rw [hp.leading_coeff, C_1, one_mul]\n#align prod_multiset_X_sub_C_of_monic_of_roots_card_eq prod_multiset_X_sub_C_of_monic_of_roots_card_eq\n\n",
 "prod_multiset_X_sub_C_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The product `∏ (X - a)` for `a` inside the multiset `p.roots` divides `p`. -/\ntheorem prod_multiset_X_sub_C_dvd (p : polynomial R) : (p.roots.map fun a => X - C a).prod ∣ p :=\n  by\n  rw [← map_dvd_map _ (is_fraction_ring.injective R <| fraction_ring R) monic_prod_multiset_X_sub_C]\n  rw [prod_multiset_root_eq_finset_root, polynomial.map_prod]\n  refine' finset.prod_dvd_of_coprime (fun a _ b _ h => _) fun a _ => _\n  · simp_rw [polynomial.map_pow, polynomial.map_sub, map_C, map_X]\n    exact (pairwise_coprime_X_sub_C (is_fraction_ring.injective R <| fraction_ring R) h).pow\n  · exact polynomial.map_dvd _ (pow_root_multiplicity_dvd p a)\n#align prod_multiset_X_sub_C_dvd prod_multiset_X_sub_C_dvd\n\n",
 "prod_X_sub_C_dvd_iff_le_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A Galois connection. -/\ntheorem _root_.multiset.prod_X_sub_C_dvd_iff_le_roots {p : polynomial R} (hp : p ≠ 0) (s : Multiset R) :\n    (s.map fun a => X - C a).prod ∣ p ↔ s ≤ p.roots :=\n  ⟨fun h =>\n    Multiset.le_iff_count.2 fun r =>\n      by\n      rw [count_roots, le_root_multiplicity_iff hp, ← Multiset.prod_replicate, ←\n        Multiset.map_replicate fun a => X - C a, ← Multiset.filter_eq]\n      exact (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| s.filter_le _).trans h,\n    fun h => (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map h).trans p.prod_multiset_X_sub_C_dvd⟩\n#align multiset.prod_X_sub_C_dvd_iff_le_roots multiset.prod_X_sub_C_dvd_iff_le_roots\n\n",
 "prime_of_degree_eq_one":
 "theorem monic.prime_of_degree_eq_one (hp1 : degree p = 1) (hm : monic p) : Prime p :=\n  have : p = X - C (-p.coeff 0) := by simpa [hm.leading_coeff] using eq_X_add_C_of_degree_eq_one hp1\n  this.symm ▸ prime_X_sub_C _\n#align monic.prime_of_degree_eq_one monic.prime_of_degree_eq_one\n\n",
 "prime_X_sub_C":
 "theorem prime_X_sub_C (r : R) : Prime (X - C r) :=\n  ⟨X_sub_C_ne_zero r, not_is_unit_X_sub_C r, fun _ _ =>\n    by\n    simp_rw [dvd_iff_is_root, is_root.def, eval_mul, mul_eq_zero]\n    exact id⟩\n#align prime_X_sub_C prime_X_sub_C\n\n",
 "prime_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem prime_X : Prime (X : polynomial R) :=\n  by\n  convert prime_X_sub_C (0 : R)\n  simp\n#align prime_X prime_X\n\n",
 "pow_root_multiplicity_not_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem pow_root_multiplicity_not_dvd {p : polynomial R} (p0 : p ≠ 0) (a : R) :\n    ¬(X - C a) ^ (root_multiplicity a p + 1) ∣ p := by rw [← root_multiplicity_le_iff p0]\n#align pow_root_multiplicity_not_dvd pow_root_multiplicity_not_dvd\n\n",
 "pairwise_coprime_X_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem pairwise_coprime_X_sub_C {K} [Field K] {I : Type v} {s : I → K} (H : function.injective s) :\n    Pairwise («expr on » IsCoprime fun i : I => X - C (s i)) := fun i j hij =>\n  is_coprime_X_sub_C_of_is_unit_sub (sub_ne_zero_of_ne <| H.ne hij).is_unit\n#align pairwise_coprime_X_sub_C pairwise_coprime_X_sub_C\n\n",
 "nth_roots_zero":
 "@[simp]\ntheorem nth_roots_zero (r : R) : nth_roots 0 r = 0 := by\n  simp only [empty_eq_zero, pow_zero, nth_roots, ← C_1, ← C_sub, roots_C]\n#align nth_roots_zero nth_roots_zero\n\n",
 "nth_roots_two_eq_zero_iff":
 "@[simp]\ntheorem nth_roots_two_eq_zero_iff {r : R} : nth_roots 2 r = 0 ↔ ¬IsSquare r := by\n  simp_rw [isSquare_iff_exists_sq, eq_zero_iff_forall_not_mem, mem_nth_roots (by norm_num : 0 < 2), ← not_exists,\n    eq_comm]\n#align nth_roots_two_eq_zero_iff nth_roots_two_eq_zero_iff\n\n",
 "nth_roots_finset_zero":
 "@[simp]\ntheorem nth_roots_finset_zero : nth_roots_finset 0 R = ∅ := by simp [nth_roots_finset]\n#align nth_roots_finset_zero nth_roots_finset_zero\n\n",
 "not_irreducible_iff_exists_add_mul_eq_coeff":
 "theorem monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.monic) (hnd : p.nat_degree = 2) :\n    ¬Irreducible p ↔ ∃ c₁ c₂, p.coeff 0 = c₁ * c₂ ∧ p.coeff 1 = c₁ + c₂ :=\n  by\n  cases subsingleton_or_nontrivial R\n  · simpa only [nat_degree_of_subsingleton] using hnd\n  rw [hm.irreducible_iff_nat_degree', and_iff_right, hnd]\n  push_neg; constructor\n  · rintro ⟨a, b, ha, hb, rfl, hdb | ⟨⟨⟩⟩⟩\n    have hda := hnd\n    rw [ha.nat_degree_mul hb, hdb] at hda\n    use a.coeff 0, b.coeff 0, mul_coeff_zero a b\n    simpa only [next_coeff, hnd, add_right_cancel hda, hdb] using ha.next_coeff_mul hb\n  · rintro ⟨c₁, c₂, hmul, hadd⟩\n    refine' ⟨X + C c₁, X + C c₂, monic_X_add_C _, monic_X_add_C _, _, or.inl <| nat_degree_X_add_C _⟩\n    rw [p.as_sum_range_C_mul_X_pow, hnd, finset.sum_range_succ, finset.sum_range_succ, finset.sum_range_one, ← hnd,\n      hm.coeff_nat_degree, hnd, hmul, hadd, C_mul, C_add, C_1]\n    ring\n  · rintro rfl\n    simpa only [nat_degree_one] using hnd\n#align monic.not_irreducible_iff_exists_add_mul_eq_coeff monic.not_irreducible_iff_exists_add_mul_eq_coeff\n\n",
 "not_dvd_of_nat_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_dvd_of_nat_degree_lt {p q : polynomial R} (h0 : q ≠ 0) (hl : q.nat_degree < p.nat_degree) : ¬p ∣ q :=\n  by\n  by_contra hcontra\n  exact h0 (eq_zero_of_dvd_of_nat_degree_lt hcontra hl)\n#align not_dvd_of_nat_degree_lt not_dvd_of_nat_degree_lt\n\n",
 "not_dvd_of_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_dvd_of_degree_lt {p q : polynomial R} (h0 : q ≠ 0) (hl : q.degree < p.degree) : ¬p ∣ q :=\n  by\n  by_contra hcontra\n  exact h0 (eq_zero_of_dvd_of_degree_lt hcontra hl)\n#align not_dvd_of_degree_lt not_dvd_of_degree_lt\n\n",
 "ne_zero_of_mem_roots":
 "theorem ne_zero_of_mem_roots (h : a ∈ p.roots) : p ≠ 0 :=\n  (mem_roots'.1 h).1\n#align ne_zero_of_mem_roots ne_zero_of_mem_roots\n\n",
 "ne_zero_of_mem_root_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem ne_zero_of_mem_root_set {p : polynomial T} [CommRing S] [IsDomain S] [algebra T S] {a : S}\n    (h : a ∈ p.root_set S) : p ≠ 0 := fun hf => by rwa [hf, root_set_zero] at h\n#align ne_zero_of_mem_root_set ne_zero_of_mem_root_set\n\n",
 "nat_degree_sub_eq_of_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- This lemma is useful for working with the `int_degree` of a rational function. -/\ntheorem nat_degree_sub_eq_of_prod_eq {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0)\n    (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) :\n    (p₁.nat_degree : ℤ) - q₁.nat_degree = (p₂.nat_degree : ℤ) - q₂.nat_degree :=\n  by\n  rw [sub_eq_sub_iff_add_eq_add]\n  norm_cast\n  rw [← nat_degree_mul hp₁ hq₂, ← nat_degree_mul hp₂ hq₁, h_eq]\n#align nat_degree_sub_eq_of_prod_eq nat_degree_sub_eq_of_prod_eq\n\n",
 "nat_degree_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_pow (p : polynomial R) (n : ℕ) : nat_degree (p ^ n) = n * nat_degree p :=\n  if hp0 : p = 0 then\n    if hn0 : n = 0 then by simp [hp0, hn0] else by rw [hp0, zero_pow (nat.pos_of_ne_zero hn0)] <;> simp\n  else nat_degree_pow' (by rw [← leading_coeff_pow, ne.def, leading_coeff_eq_zero] <;> exact pow_ne_zero _ hp0)\n#align nat_degree_pow nat_degree_pow\n\n",
 "nat_degree_pos_of_aeval_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johannes Hölzl, Scott Morrison, Jens Wagemaker, Johan Commelin\n-/\ntheorem nat_degree_pos_of_aeval_root [algebra R S] {p : polynomial R} (hp : p ≠ 0) {z : S} (hz : aeval z p = 0)\n    (inj : ∀ x : R, algebra_map R S x = 0 → x = 0) : 0 < p.nat_degree :=\n  nat_degree_pos_of_eval₂_root hp (algebra_map R S) hz inj\n#align nat_degree_pos_of_aeval_root nat_degree_pos_of_aeval_root\n\n",
 "nat_degree_multiset_prod_X_sub_C_eq_card":
 "@[simp]\ntheorem nat_degree_multiset_prod_X_sub_C_eq_card (s : Multiset R) : (s.map fun a => X - C a).prod.nat_degree = s.card :=\n  by\n  rw [nat_degree_multiset_prod_of_monic, Multiset.map_map]\n  · simp only [(· ∘ ·), nat_degree_X_sub_C, Multiset.map_const, multiset.sum_replicate, smul_eq_mul, mul_one]\n  · exact Multiset.forall_mem_map_iff.2 fun a _ => monic_X_sub_C a\n#align nat_degree_multiset_prod_X_sub_C_eq_card nat_degree_multiset_prod_X_sub_C_eq_card\n\n",
 "nat_degree_mul":
 "theorem nat_degree_mul (hp : p ≠ 0) (hq : q ≠ 0) : nat_degree (p * q) = nat_degree p + nat_degree q := by\n  rw [← WithBot.coe_eq_coe, ← degree_eq_nat_degree (mul_ne_zero hp hq), WithBot.coe_add, ← degree_eq_nat_degree hp, ←\n    degree_eq_nat_degree hq, degree_mul]\n#align nat_degree_mul nat_degree_mul\n\n",
 "nat_degree_le_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_le_of_dvd {p q : polynomial R} (h1 : p ∣ q) (h2 : q ≠ 0) : p.nat_degree ≤ q.nat_degree :=\n  by\n  rcases h1 with ⟨q, rfl⟩; rw [mul_ne_zero_iff] at h2\n  rw [nat_degree_mul h2.1 h2.2]; exact nat.le_add_right _ _\n#align nat_degree_le_of_dvd nat_degree_le_of_dvd\n\n",
 "nat_degree_eq_zero_of_is_unit":
 "theorem nat_degree_eq_zero_of_is_unit (h : is_unit p) : nat_degree p = 0 :=\n  by\n  nontriviality R\n  obtain ⟨q, hq⟩ := h.exists_right_inv\n  have := nat_degree_mul (left_ne_zero_of_mul_eq_one hq) (right_ne_zero_of_mul_eq_one hq)\n  rw [hq, nat_degree_one, eq_comm, add_eq_zero_iff] at this\n  exact this.1\n#align nat_degree_eq_zero_of_is_unit nat_degree_eq_zero_of_is_unit\n\n",
 "nat_degree_coe_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_coe_units (u : «expr ˣ» (polynomial R)) : nat_degree (u : polynomial R) = 0 :=\n  nat_degree_eq_of_degree_eq_some (degree_coe_units u)\n#align nat_degree_coe_units nat_degree_coe_units\n\n",
 "nat_degree_bit1_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_bit1_eq (p : polynomial R) : nat_degree (bit1 p) = nat_degree p :=\n  by\n  rw [bit1]\n  apply le_antisymm\n  convert nat_degree_add_le _ _\n  · simp\n  by_cases h : p.nat_degree = 0\n  · simp [h]\n  apply le_nat_degree_of_ne_zero\n  intro hh\n  apply h\n  simp_all [coeff_one, if_neg (ne.symm h)]\n#align nat_degree_bit1_eq nat_degree_bit1_eq\n\n",
 "nat_degree_bit0_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem nat_degree_bit0_eq (p : polynomial R) : nat_degree (bit0 p) = nat_degree p :=\n  nat_degree_eq_of_degree_eq <| degree_bit0_eq p\n#align nat_degree_bit0_eq nat_degree_bit0_eq\n\n",
 "monic_prod_multiset_X_sub_C":
 "theorem monic_prod_multiset_X_sub_C : monic (p.roots.map fun a => X - C a).prod :=\n  monic_multiset_prod_of_monic _ _ fun a _ => monic_X_sub_C a\n#align monic_prod_multiset_X_sub_C monic_prod_multiset_X_sub_C\n\n",
 "mod_by_monic_eq_of_dvd_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem mod_by_monic_eq_of_dvd_sub (hq : q.monic) {p₁ p₂ : polynomial R} (h : q ∣ p₁ - p₂) :\n    «expr %ₘ » p₁ q = «expr %ₘ » p₂ q := by\n  nontriviality R\n  obtain ⟨f, sub_eq⟩ := h\n  refine' (div_mod_by_monic_unique («expr /ₘ » p₂ q + f) _ hq ⟨_, degree_mod_by_monic_lt _ hq⟩).2\n  rw [sub_eq_iff_eq_add.mp sub_eq, mul_add, ← add_assoc, mod_by_monic_add_div _ hq, add_comm]\n#align mod_by_monic_eq_of_dvd_sub mod_by_monic_eq_of_dvd_sub\n\n",
 "mem_roots_sub_C'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_roots_sub_C' {p : polynomial R} {a x : R} : x ∈ (p - C a).roots ↔ p ≠ C a ∧ p.eval x = a := by\n  rw [mem_roots', is_root.def, sub_ne_zero, eval_sub, sub_eq_zero, eval_C]\n#align mem_roots_sub_C' mem_roots_sub_C'\n\n",
 "mem_roots_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_roots_sub_C {p : polynomial R} {a x : R} (hp0 : 0 < degree p) : x ∈ (p - C a).roots ↔ p.eval x = a :=\n  mem_roots_sub_C'.trans <| and_iff_right fun hp => hp0.not_le <| hp.symm ▸ degree_C_le\n#align mem_roots_sub_C mem_roots_sub_C\n\n",
 "mem_roots'":
 "@[simp]\ntheorem mem_roots' : a ∈ p.roots ↔ p ≠ 0 ∧ is_root p a := by rw [← count_pos, count_roots p, root_multiplicity_pos']\n#align mem_roots' mem_roots'\n\n",
 "mem_roots":
 "theorem mem_roots (hp : p ≠ 0) : a ∈ p.roots ↔ is_root p a :=\n  mem_roots'.trans <| and_iff_right hp\n#align mem_roots mem_roots\n\n",
 "mem_root_set_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_root_set_of_ne {p : polynomial T} {S : Type _} [CommRing S] [IsDomain S] [algebra T S]\n    [NoZeroSMulDivisors T S] (hp : p ≠ 0) {a : S} : a ∈ p.root_set S ↔ aeval a p = 0 :=\n  mem_root_set.trans <| and_iff_right hp\n#align mem_root_set_of_ne mem_root_set_of_ne\n\n",
 "mem_root_set'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_root_set' {p : polynomial T} {S : Type _} [CommRing S] [IsDomain S] [algebra T S] {a : S} :\n    a ∈ p.root_set S ↔ p.map (algebra_map T S) ≠ 0 ∧ aeval a p = 0 := by\n  rw [root_set, Finset.mem_coe, mem_to_finset, mem_roots', is_root.def, ← eval₂_eq_eval_map, aeval_def]\n#align mem_root_set' mem_root_set'\n\n",
 "mem_root_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_root_set {p : polynomial T} {S : Type _} [CommRing S] [IsDomain S] [algebra T S] [NoZeroSMulDivisors T S]\n    {a : S} : a ∈ p.root_set S ↔ p ≠ 0 ∧ aeval a p = 0 := by\n  rw [mem_root_set',\n    (map_injective _ (no_zero_smul_divisors.algebra_map_injective T S)).ne_iff' (polynomial.map_zero _)]\n#align mem_root_set mem_root_set\n\n",
 "mem_nth_roots_finset":
 "@[simp]\ntheorem mem_nth_roots_finset {n : ℕ} (h : 0 < n) {x : R} : x ∈ nth_roots_finset n R ↔ x ^ (n : ℕ) = 1 := by\n  rw [nth_roots_finset, mem_to_finset, mem_nth_roots h]\n#align mem_nth_roots_finset mem_nth_roots_finset\n\n",
 "mem_nth_roots":
 "@[simp]\ntheorem mem_nth_roots {n : ℕ} (hn : 0 < n) {a x : R} : x ∈ nth_roots n a ↔ x ^ n = a := by\n  rw [nth_roots, mem_roots (X_pow_sub_C_ne_zero hn a), is_root.def, eval_sub, eval_C, eval_pow, eval_X, sub_eq_zero]\n#align mem_nth_roots mem_nth_roots\n\n",
 "map_roots_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_roots_le_of_injective [IsDomain A] [IsDomain B] (p : polynomial A) {f : «expr →+* » A B}\n    (hf : function.injective f) : p.roots.map f ≤ (p.map f).roots :=\n  by\n  by_cases hp0 : p = 0; · simp only [hp0, roots_zero, Multiset.map_zero, polynomial.map_zero]\n  exact map_roots_le ((polynomial.map_ne_zero_iff hf).mpr hp0)\n#align map_roots_le_of_injective map_roots_le_of_injective\n\n",
 "map_roots_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_roots_le [IsDomain A] [IsDomain B] {p : polynomial A} {f : «expr →+* » A B} (h : p.map f ≠ 0) :\n    p.roots.map f ≤ (p.map f).roots :=\n  Multiset.le_iff_count.2 fun b => by\n    rw [count_roots]\n    apply count_map_roots h\n#align map_roots_le map_roots_le\n\n",
 "leading_coeff_div_by_monic_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/-- Division by a monic polynomial doesn't change the leading coefficient. -/\ntheorem leading_coeff_div_by_monic_of_monic {R : Type u} [CommRing R] {p q : polynomial R} (hmonic : q.monic)\n    (hdegree : q.degree ≤ p.degree) : («expr /ₘ » p q).leading_coeff = p.leading_coeff :=\n  by\n  nontriviality\n  have h : q.leading_coeff * («expr /ₘ » p q).leading_coeff ≠ 0 := by\n    simpa [div_by_monic_eq_zero_iff hmonic, hmonic.leading_coeff, Nat.WithBot.one_le_iff_zero_lt] using hdegree\n  nth_rw_rhs 1 [← mod_by_monic_add_div p hmonic]\n  rw [leading_coeff_add_of_degree_lt, leading_coeff_monic_mul hmonic]\n  rw [degree_mul' h, degree_add_div_by_monic hmonic hdegree]\n  exact (degree_mod_by_monic_lt p hmonic).trans_le hdegree\n#align leading_coeff_div_by_monic_of_monic leading_coeff_div_by_monic_of_monic\n\n",
 "leading_coeff_div_by_monic_X_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\ntheorem leading_coeff_div_by_monic_X_sub_C (p : polynomial R) (hp : degree p ≠ 0) (a : R) :\n    leading_coeff («expr /ₘ » p (X - C a)) = leading_coeff p :=\n  by\n  nontriviality\n  cases' hp.lt_or_lt with hd hd\n  · rw [degree_eq_bot.mp <| (Nat.WithBot.lt_zero_iff _).mp hd, zero_div_by_monic]\n  refine' leading_coeff_div_by_monic_of_monic (monic_X_sub_C a) _\n  rwa [degree_X_sub_C, Nat.WithBot.one_le_iff_zero_lt]\n#align leading_coeff_div_by_monic_X_sub_C leading_coeff_div_by_monic_X_sub_C\n\n",
 "le_root_multiplicity_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem le_root_multiplicity_map {p : polynomial A} {f : «expr →+* » A B} (hmap : map f p ≠ 0) (a : A) :\n    root_multiplicity a p ≤ root_multiplicity (f a) (p.map f) :=\n  by\n  rw [le_root_multiplicity_iff hmap]\n  refine' trans _ ((map_ring_hom f).map_dvd (pow_root_multiplicity_dvd p a))\n  rw [map_pow, map_sub, coe_map_ring_hom, map_X, map_C]\n#align le_root_multiplicity_map le_root_multiplicity_map\n\n",
 "le_root_multiplicity_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n  `(X - a) ^ n` divides `p`. -/\ntheorem le_root_multiplicity_iff {p : polynomial R} (p0 : p ≠ 0) {a : R} {n : ℕ} :\n    n ≤ root_multiplicity a p ↔ (X - C a) ^ n ∣ p :=\n  by\n  simp_rw [root_multiplicity, dif_neg p0, Nat.le_find_iff, not_not]\n  refine' ⟨fun h => _, fun h m hm => (pow_dvd_pow _ hm).trans h⟩\n  cases n;\n  · rw [pow_zero]\n    apply one_dvd; · exact h n n.lt_succ_self\n#align le_root_multiplicity_iff le_root_multiplicity_iff\n\n",
 "le_of_dvd":
 "theorem roots.le_of_dvd (h : q ≠ 0) : p ∣ q → roots p ≤ roots q :=\n  by\n  rintro ⟨k, rfl⟩\n  exact multiset.le_iff_exists_add.mpr ⟨k.roots, roots_mul h⟩\n#align roots.le_of_dvd roots.le_of_dvd\n\n",
 "is_unit_of_is_unit_leading_coeff_of_is_unit_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_unit_of_is_unit_leading_coeff_of_is_unit_map {f : polynomial R} (hf : is_unit f.leading_coeff)\n    (H : is_unit (map φ f)) : is_unit f :=\n  by\n  have dz := degree_eq_zero_of_is_unit H\n  rw [degree_map_eq_of_leading_coeff_ne_zero] at dz\n  · rw [eq_C_of_degree_eq_zero dz]\n    refine' IsUnit.map C _\n    convert hf\n    rw [(degree_eq_iff_nat_degree_eq _).1 dz]\n    rintro rfl\n    simpa using H\n  · intro h\n    have u : is_unit (φ f.leading_coeff) := IsUnit.map φ hf\n    rw [h] at u\n    simpa using u\n#align is_unit_of_is_unit_leading_coeff_of_is_unit_map is_unit_of_is_unit_leading_coeff_of_is_unit_map\n\n",
 "is_unit_iff":
 "theorem is_unit_iff : is_unit p ↔ ∃ r : R, is_unit r ∧ C r = p :=\n  ⟨fun hp =>\n    ⟨p.coeff 0,\n      let h := eq_C_of_nat_degree_eq_zero (nat_degree_eq_zero_of_is_unit hp)\n      ⟨is_unit_C.1 (h ▸ hp), h.symm⟩⟩,\n    fun ⟨r, hr, hrp⟩ => hrp ▸ is_unit_C.2 hr⟩\n#align is_unit_iff is_unit_iff\n\n",
 "is_root_of_mem_roots":
 "theorem is_root_of_mem_roots (h : a ∈ p.roots) : is_root p a :=\n  (mem_roots'.1 h).2\n#align is_root_of_mem_roots is_root_of_mem_roots\n\n",
 "is_coprime_X_sub_C_of_is_unit_sub":
 "theorem is_coprime_X_sub_C_of_is_unit_sub {R} [CommRing R] {a b : R} (h : is_unit (a - b)) :\n    IsCoprime (X - C a) (X - C b) :=\n  ⟨-C h.unit⁻¹.val, C h.unit⁻¹.val,\n    by\n    rw [neg_mul_comm, ← left_distrib, neg_add_eq_sub, sub_sub_sub_cancel_left, ← C_sub, ← C_mul]\n    convert C_1\n    exact h.coe_inv_mul⟩\n#align is_coprime_X_sub_C_of_is_unit_sub is_coprime_X_sub_C_of_is_unit_sub\n\n",
 "irreducible_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem irreducible_of_monic (hp : p.monic) (hp1 : p ≠ 1) :\n    Irreducible p ↔ ∀ f g : polynomial R, f.monic → g.monic → f * g = p → f = 1 ∨ g = 1 :=\n  by\n  refine'\n    ⟨fun h f g hf hg hp => (h.2 f g hp.symm).imp hf.eq_one_of_is_unit hg.eq_one_of_is_unit, fun h =>\n      ⟨hp1 ∘ hp.eq_one_of_is_unit, fun f g hfg =>\n        (h (g * C f.leading_coeff) (f * C g.leading_coeff) _ _ _).symm.imp (isUnit_of_mul_eq_one f _)\n          (isUnit_of_mul_eq_one g _)⟩⟩\n  · rwa [monic, leading_coeff_mul, leading_coeff_C, ← leading_coeff_mul, mul_comm, ← hfg, ← monic]\n  · rwa [monic, leading_coeff_mul, leading_coeff_C, ← leading_coeff_mul, ← hfg, ← monic]\n  · rw [mul_mul_mul_comm, ← C_mul, ← leading_coeff_mul, ← hfg, hp.leading_coeff, C_1, mul_one, mul_comm, ← hfg]\n#align irreducible_of_monic irreducible_of_monic\n\n",
 "irreducible_of_irreducible_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A polynomial over an integral domain `R` is irreducible if it is monic and\n  irreducible after mapping into an integral domain `S`.\n\nA special case of this lemma is that a polynomial over `ℤ` is irreducible if\n  it is monic and irreducible over `ℤ/pℤ` for some prime `p`.\n-/\ntheorem monic.irreducible_of_irreducible_map (f : polynomial R) (h_mon : monic f) (h_irr : Irreducible (map φ f)) :\n    Irreducible f := by\n  refine' ⟨h_irr.not_unit ∘ IsUnit.map (map_ring_hom φ), fun a b h => _⟩\n  dsimp [monic] at h_mon\n  have q := (leading_coeff_mul a b).symm\n  rw [← h, h_mon] at q\n  refine' (h_irr.is_unit_or_is_unit <| (congr_arg (map φ) h).trans (polynomial.map_mul φ)).imp _ _ <;>\n      apply is_unit_of_is_unit_leading_coeff_of_is_unit_map <;>\n    apply isUnit_of_mul_eq_one\n  · exact q;\n  · rw [mul_comm]\n    exact q\n#align monic.irreducible_of_irreducible_map monic.irreducible_of_irreducible_map\n\n",
 "irreducible_of_degree_eq_one":
 "theorem monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : monic p) : Irreducible p :=\n  (hm.prime_of_degree_eq_one hp1).irreducible\n#align monic.irreducible_of_degree_eq_one monic.irreducible_of_degree_eq_one\n\n",
 "irreducible_iff_nat_degree'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.irreducible_iff_nat_degree' (hp : p.monic) :\n    Irreducible p ↔\n      p ≠ 1 ∧ ∀ f g : polynomial R, f.monic → g.monic → f * g = p → g.nat_degree ∉ Ioc 0 (p.nat_degree / 2) :=\n  by\n  simp_rw [hp.irreducible_iff_nat_degree, mem_Ioc, nat.le_div_iff_mul_le zero_lt_two, mul_two]\n  apply and_congr_right'\n  constructor <;> intro h f g hf hg he <;> subst he\n  · rw [hf.nat_degree_mul hg, add_le_add_iff_right]\n    exact fun ha => (h f g hf hg rfl).elim (ha.1.trans_le ha.2).ne' ha.1.ne'\n  · simp_rw [hf.nat_degree_mul hg, pos_iff_ne_zero] at h\n    contrapose! h\n    obtain hl | hl := le_total f.nat_degree g.nat_degree\n    · exact ⟨g, f, hg, hf, mul_comm g f, h.1, add_le_add_left hl _⟩\n    · exact ⟨f, g, hf, hg, rfl, h.2, add_le_add_right hl _⟩\n#align monic.irreducible_iff_nat_degree' monic.irreducible_iff_nat_degree'\n\n",
 "irreducible_iff_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monic.irreducible_iff_nat_degree (hp : p.monic) :\n    Irreducible p ↔ p ≠ 1 ∧ ∀ f g : polynomial R, f.monic → g.monic → f * g = p → f.nat_degree = 0 ∨ g.nat_degree = 0 :=\n  by\n  by_cases hp1 : p = 1; · simp [hp1]\n  rw [irreducible_of_monic hp hp1, and_iff_right hp1]\n  refine' forall₄_congr fun a b ha hb => _\n  rw [ha.nat_degree_eq_zero_iff_eq_one, hb.nat_degree_eq_zero_iff_eq_one]\n#align monic.irreducible_iff_nat_degree monic.irreducible_iff_nat_degree\n\n",
 "irreducible_X_sub_C":
 "theorem irreducible_X_sub_C (r : R) : Irreducible (X - C r) :=\n  (prime_X_sub_C r).irreducible\n#align irreducible_X_sub_C irreducible_X_sub_C\n\n",
 "irreducible_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem irreducible_X : Irreducible (X : polynomial R) :=\n  Prime.irreducible prime_X\n#align irreducible_X irreducible_X\n\n",
 "funext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print funext /-\ntheorem funext [Infinite R] {p q : polynomial R} (ext : ∀ r : R, p.eval r = q.eval r) : p = q :=\n  by\n  rw [← sub_eq_zero]\n  apply zero_of_eval_zero\n  intro x\n  rw [eval_sub, sub_eq_zero, ext]\n#align funext funext\n-/\n\n",
 "finite_set_of_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem finite_set_of_is_root {p : polynomial R} (hp : p ≠ 0) : set.finite { x | is_root p x } := by\n  simpa only [← Finset.setOf_mem, mem_to_finset, mem_roots hp] using p.roots.to_finset.finite_to_set\n#align finite_set_of_is_root finite_set_of_is_root\n\n",
 "exists_prod_multiset_X_sub_C_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_prod_multiset_X_sub_C_mul (p : polynomial R) :\n    ∃ q, (p.roots.map fun a => X - C a).prod * q = p ∧ p.roots.card + q.nat_degree = p.nat_degree ∧ q.roots = 0 :=\n  by\n  obtain ⟨q, he⟩ := p.prod_multiset_X_sub_C_dvd\n  use q, he.symm\n  obtain rfl | hq := eq_or_ne q 0\n  · rw [mul_zero] at he\n    subst he\n    simp\n  constructor\n  · conv_rhs => rw [he]\n    rw [monic_prod_multiset_X_sub_C.nat_degree_mul' hq, nat_degree_multiset_prod_X_sub_C_eq_card]\n  · replace he := congr_arg roots he.symm\n    rw [roots_mul, roots_multiset_prod_X_sub_C] at he\n    exacts[add_right_eq_self.1 he, mul_ne_zero monic_prod_multiset_X_sub_C.ne_zero hq]\n#align exists_prod_multiset_X_sub_C_mul exists_prod_multiset_X_sub_C_mul\n\n",
 "exists_multiset_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_multiset_roots :\n    ∀ {p : polynomial R} (hp : p ≠ 0),\n      ∃ s : Multiset R, (s.card : WithBot ℕ) ≤ degree p ∧ ∀ a, s.count a = root_multiplicity a p\n  | p => fun hp =>\n    haveI := classical.prop_decidable (∃ x, is_root p x)\n    if h : ∃ x, is_root p x then\n      let ⟨x, hx⟩ := h\n      have hpd : 0 < degree p := degree_pos_of_root hp hx\n      have hd0 : «expr /ₘ » p (X - C x) ≠ 0 := fun h => by\n        rw [← mul_div_by_monic_eq_iff_is_root.2 hx, h, mul_zero] at hp <;> exact hp rfl\n      have wf : degree («expr /ₘ » p _) < degree p :=\n        degree_div_by_monic_lt _ (monic_X_sub_C x) hp ((degree_X_sub_C x).symm ▸ by decide)\n      let ⟨t, htd, htr⟩ := @exists_multiset_roots («expr /ₘ » p (X - C x)) hd0\n      have hdeg : degree (X - C x) ≤ degree p :=\n        by\n        rw [degree_X_sub_C, degree_eq_nat_degree hp]\n        rw [degree_eq_nat_degree hp] at hpd\n        exact WithBot.coe_le_coe.2 (WithBot.coe_lt_coe.1 hpd)\n      have hdiv0 : «expr /ₘ » p (X - C x) ≠ 0 := mt (div_by_monic_eq_zero_iff (monic_X_sub_C x)).1 <| not_lt.2 hdeg\n      ⟨«expr ::ₘ » x t,\n        calc\n          (card («expr ::ₘ » x t) : WithBot ℕ) = t.card + 1 := by exact_mod_cast card_cons _ _\n          _ ≤ degree p := by\n            rw [← degree_add_div_by_monic (monic_X_sub_C x) hdeg, degree_X_sub_C, add_comm] <;>\n              exact add_le_add (le_refl (1 : WithBot ℕ)) htd\n          ,\n        by\n        intro a\n        conv_rhs => rw [← mul_div_by_monic_eq_iff_is_root.mpr hx]\n        rw [root_multiplicity_mul (mul_ne_zero (X_sub_C_ne_zero x) hdiv0), root_multiplicity_X_sub_C, ← htr a]\n        split_ifs with ha\n        · rw [ha, count_cons_self, nat.succ_eq_add_one, add_comm]\n        · rw [count_cons_of_ne ha, zero_add]⟩\n    else\n      ⟨0, (degree_eq_nat_degree hp).symm ▸ WithBot.coe_le_coe.2 (nat.zero_le _),\n        by\n        intro a\n        rw [count_zero, root_multiplicity_eq_zero (not_exists.mp h a)]⟩\n#align exists_multiset_roots exists_multiset_roots\n\n",
 "exists_min_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_min_root [linear_order R] (p : polynomial R) (hp : p ≠ 0) : ∃ x₀, ∀ x, p.is_root x → x₀ ≤ x :=\n  set.exists_lower_bound_image _ _ <| finite_set_of_is_root hp\n#align exists_min_root exists_min_root\n\n",
 "exists_max_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_max_root [linear_order R] (p : polynomial R) (hp : p ≠ 0) : ∃ x₀, ∀ x, p.is_root x → x ≤ x₀ :=\n  set.exists_upper_bound_image _ _ <| finite_set_of_is_root hp\n#align exists_max_root exists_max_root\n\n",
 "eq_zero_of_infinite_is_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_zero_of_infinite_is_root (p : polynomial R) (h : set.infinite { x | is_root p x }) : p = 0 :=\n  not_imp_comm.mp finite_set_of_is_root h\n#align eq_zero_of_infinite_is_root eq_zero_of_infinite_is_root\n\n",
 "eq_zero_of_dvd_of_nat_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_zero_of_dvd_of_nat_degree_lt {p q : polynomial R} (h₁ : p ∣ q) (h₂ : nat_degree q < nat_degree p) : q = 0 :=\n  by\n  by_contra hc\n  exact (lt_iff_not_ge _ _).mp h₂ (nat_degree_le_of_dvd h₁ hc)\n#align eq_zero_of_dvd_of_nat_degree_lt eq_zero_of_dvd_of_nat_degree_lt\n\n",
 "eq_zero_of_dvd_of_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_zero_of_dvd_of_degree_lt {p q : polynomial R} (h₁ : p ∣ q) (h₂ : degree q < degree p) : q = 0 :=\n  by\n  by_contra hc\n  exact (lt_iff_not_ge _ _).mp h₂ (degree_le_of_dvd h₁ hc)\n#align eq_zero_of_dvd_of_degree_lt eq_zero_of_dvd_of_degree_lt\n\n",
 "eq_root_multiplicity_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_root_multiplicity_map {p : polynomial A} {f : «expr →+* » A B} (hf : function.injective f) (a : A) :\n    root_multiplicity a p = root_multiplicity (f a) (p.map f) :=\n  by\n  by_cases hp0 : p = 0; · simp only [hp0, root_multiplicity_zero, polynomial.map_zero]\n  apply le_antisymm (le_root_multiplicity_map ((polynomial.map_ne_zero_iff hf).mpr hp0) a)\n  rw [le_root_multiplicity_iff hp0, ← map_dvd_map f hf ((monic_X_sub_C a).pow _), polynomial.map_pow,\n    polynomial.map_sub, map_X, map_C]\n  apply pow_root_multiplicity_dvd\n#align eq_root_multiplicity_map eq_root_multiplicity_map\n\n",
 "eq_of_monic_of_dvd_of_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_of_monic_of_dvd_of_nat_degree_le {R} [CommRing R] {p q : polynomial R} (hp : p.monic) (hq : q.monic)\n    (hdiv : p ∣ q) (hdeg : q.nat_degree ≤ p.nat_degree) : q = p :=\n  by\n  convert eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le hp hdiv hdeg\n  rw [hq.leading_coeff, C_1, one_mul]\n#align eq_of_monic_of_dvd_of_nat_degree_le eq_of_monic_of_dvd_of_nat_degree_le\n\n",
 "eq_of_monic_of_associated":
 "theorem eq_of_monic_of_associated (hp : p.monic) (hq : q.monic) (hpq : Associated p q) : p = q :=\n  by\n  obtain ⟨u, hu⟩ := hpq\n  unfold monic at hp hq\n  rw [eq_C_of_degree_le_zero (degree_coe_units _).le] at hu\n  rw [← hu, leading_coeff_mul, hp, one_mul, leading_coeff_C] at hq\n  rwa [hq, C_1, mul_one] at hu\n  all_goals infer_instance\n#align eq_of_monic_of_associated eq_of_monic_of_associated\n\n",
 "eq_of_infinite_eval_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_of_infinite_eval_eq (p q : polynomial R) (h : set.infinite { x | eval x p = eval x q }) : p = q :=\n  by\n  rw [← sub_eq_zero]\n  apply eq_zero_of_infinite_is_root\n  simpa only [is_root, eval_sub, sub_eq_zero]\n#align eq_of_infinite_eval_eq eq_of_infinite_eval_eq\n\n",
 "eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le {R} [CommRing R] {p q : polynomial R} (hp : p.monic)\n    (hdiv : p ∣ q) (hdeg : q.nat_degree ≤ p.nat_degree) : q = C q.leading_coeff * p :=\n  by\n  obtain ⟨r, hr⟩ := hdiv\n  obtain rfl | hq := eq_or_ne q 0; · simp\n  have rzero : r ≠ 0 := fun h => by simpa [h, hq] using hr\n  rw [hr, nat_degree_mul'] at hdeg; swap\n  · rw [hp.leading_coeff, one_mul, leading_coeff_ne_zero]\n    exact rzero\n  rw [mul_comm, @eq_C_of_nat_degree_eq_zero _ _ r] at hr\n  · convert hr\n    convert leading_coeff_C _ using 1\n    rw [hr, leading_coeff_mul_monic hp]\n  · exact (add_right_inj _).1 (le_antisymm hdeg <| nat.le.intro rfl)\n#align eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le\n\n",
 "degree_pos_of_aeval_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_pos_of_aeval_root [algebra R S] {p : polynomial R} (hp : p ≠ 0) {z : S} (hz : aeval z p = 0)\n    (inj : ∀ x : R, algebra_map R S x = 0 → x = 0) : 0 < p.degree :=\n  nat_degree_pos_iff_degree_pos.mp (nat_degree_pos_of_aeval_root hp hz inj)\n#align degree_pos_of_aeval_root degree_pos_of_aeval_root\n\n",
 "degree_le_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_le_of_dvd {p q : polynomial R} (h1 : p ∣ q) (h2 : q ≠ 0) : degree p ≤ degree q :=\n  by\n  rcases h1 with ⟨q, rfl⟩; rw [mul_ne_zero_iff] at h2\n  exact degree_le_mul_left p h2.2\n#align degree_le_of_dvd degree_le_of_dvd\n\n",
 "degree_le_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_le_mul_left (p : polynomial R) (hq : q ≠ 0) : degree p ≤ degree (p * q) :=\n  if hp : p = 0 then by simp only [hp, zero_mul, le_refl]\n  else by\n    rw [degree_mul, degree_eq_nat_degree hp, degree_eq_nat_degree hq] <;>\n      exact WithBot.coe_le_coe.2 (nat.le_add_right _ _)\n#align degree_le_mul_left degree_le_mul_left\n\n",
 "degree_eq_zero_of_is_unit":
 "theorem degree_eq_zero_of_is_unit [nontrivial R] (h : is_unit p) : degree p = 0 :=\n  (nat_degree_eq_zero_iff_degree_le_zero.mp <| nat_degree_eq_zero_of_is_unit h).antisymm\n    (zero_le_degree_iff.mpr h.ne_zero)\n#align degree_eq_zero_of_is_unit degree_eq_zero_of_is_unit\n\n",
 "degree_eq_one_of_irreducible_of_root":
 "theorem degree_eq_one_of_irreducible_of_root (hi : Irreducible p) {x : R} (hx : is_root p x) : degree p = 1 :=\n  let ⟨g, hg⟩ := dvd_iff_is_root.2 hx\n  have : is_unit (X - C x) ∨ is_unit g := hi.is_unit_or_is_unit hg\n  this.elim\n    (fun h => by\n      have h₁ : degree (X - C x) = 1 := degree_X_sub_C x\n      have h₂ : degree (X - C x) = 0 := degree_eq_zero_of_is_unit h\n      rw [h₁] at h₂ <;> exact absurd h₂ (by decide))\n    fun hgu => by rw [hg, degree_mul, degree_X_sub_C, degree_eq_zero_of_is_unit hgu, add_zero]\n#align degree_eq_one_of_irreducible_of_root degree_eq_one_of_irreducible_of_root\n\n",
 "degree_eq_degree_of_associated":
 "theorem degree_eq_degree_of_associated (h : Associated p q) : degree p = degree q :=\n  by\n  let ⟨u, hu⟩ := h\n  simp [hu.symm]\n#align degree_eq_degree_of_associated degree_eq_degree_of_associated\n\n",
 "degree_coe_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_coe_units [nontrivial R] (u : «expr ˣ» (polynomial R)) : degree (u : polynomial R) = 0 :=\n  degree_eq_zero_of_is_unit ⟨u, rfl⟩\n#align degree_coe_units degree_coe_units\n\n",
 "degree_bit1_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_bit1_eq {p : polynomial R} (hp : 0 < degree p) : degree (bit1 p) = degree p :=\n  by\n  rw [bit1, degree_add_eq_left_of_degree_lt, degree_bit0_eq]\n  rwa [degree_one, degree_bit0_eq]\n#align degree_bit1_eq degree_bit1_eq\n\n",
 "degree_bit0_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem degree_bit0_eq (p : polynomial R) : degree (bit0 p) = degree p := by\n  rw [bit0_eq_two_mul, degree_mul, (by simp : (2 : polynomial R) = C 2), @polynomial.degree_C R _ _ two_ne_zero,\n    zero_add]\n#align degree_bit0_eq degree_bit0_eq\n\n",
 "count_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem count_roots (p : polynomial R) : p.roots.count a = root_multiplicity a p :=\n  by\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [roots, dif_neg hp]\n  exact (Classical.choose_spec (exists_multiset_roots hp)).2 a\n#align count_roots count_roots\n\n",
 "count_map_roots_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem count_map_roots_of_injective [IsDomain A] (p : polynomial A) {f : «expr →+* » A B} (hf : function.injective f)\n    (b : B) : (p.roots.map f).count b ≤ root_multiplicity b (p.map f) :=\n  by\n  by_cases hp0 : p = 0\n  · simp only [hp0, roots_zero, Multiset.map_zero, Multiset.count_zero, polynomial.map_zero, root_multiplicity_zero]\n  · exact count_map_roots ((polynomial.map_ne_zero_iff hf).mpr hp0) b\n#align count_map_roots_of_injective count_map_roots_of_injective\n\n",
 "count_map_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem count_map_roots [IsDomain A] {p : polynomial A} {f : «expr →+* » A B} (hmap : map f p ≠ 0) (b : B) :\n    (p.roots.map f).count b ≤ root_multiplicity b (p.map f) :=\n  by\n  rw [le_root_multiplicity_iff hmap, ← Multiset.prod_replicate, ← Multiset.map_replicate fun a => X - C a]\n  rw [← Multiset.filter_eq]\n  refine' (Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| Multiset.filter_le _ _).trans _\n  convert polynomial.map_dvd _ p.prod_multiset_X_sub_C_dvd\n  simp only [polynomial.map_multiset_prod, Multiset.map_map]\n  congr ; ext1\n  simp only [Function.comp_apply, polynomial.map_sub, map_X, map_C]\n#align count_map_roots count_map_roots\n\n",
 "comp_eq_zero_iff":
 "theorem comp_eq_zero_iff : p.comp q = 0 ↔ p = 0 ∨ p.eval (q.coeff 0) = 0 ∧ q = C (q.coeff 0) :=\n  by\n  constructor\n  · intro h\n    have key : p.nat_degree = 0 ∨ q.nat_degree = 0 := by rw [← mul_eq_zero, ← nat_degree_comp, h, nat_degree_zero]\n    replace key := Or.imp eq_C_of_nat_degree_eq_zero eq_C_of_nat_degree_eq_zero key\n    cases key\n    · rw [key, C_comp] at h\n      exact or.inl (key.trans h)\n    · rw [key, comp_C, C_eq_zero] at h\n      exact or.inr ⟨h, key⟩\n  · exact fun h => or.rec (fun h => by rw [h, zero_comp]) (fun h => by rw [h.2, comp_C, h.1, C_0]) h\n#align comp_eq_zero_iff comp_eq_zero_iff\n\n",
 "comp_X_sub_C":
 "theorem monic.comp_X_sub_C (hp : p.monic) (r : R) : (p.comp (X - C r)).monic := by simpa using hp.comp_X_add_C (-r)\n#align monic.comp_X_sub_C monic.comp_X_sub_C\n\n",
 "comp_X_add_C":
 "theorem monic.comp_X_add_C (hp : p.monic) (r : R) : (p.comp (X + C r)).monic :=\n  by\n  refine' hp.comp (monic_X_add_C _) fun ha => _\n  rw [nat_degree_X_add_C] at ha\n  exact one_ne_zero ha\n#align monic.comp_X_add_C monic.comp_X_add_C\n\n",
 "comp":
 "theorem monic.comp (hp : p.monic) (hq : q.monic) (h : q.nat_degree ≠ 0) : (p.comp q).monic := by\n  rw [monic.def, leading_coeff_comp h, monic.def.1 hp, monic.def.1 hq, one_pow, one_mul]\n#align monic.comp monic.comp\n\n",
 "coeff_coe_units_zero_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem coeff_coe_units_zero_ne_zero (u : «expr ˣ» (polynomial R)) : coeff (u : polynomial R) 0 ≠ 0 :=\n  by\n  conv in 0 => rw [← nat_degree_coe_units u]\n  rw [← leading_coeff, ne.def, leading_coeff_eq_zero]\n  exact Units.ne_zero _\n#align coeff_coe_units_zero_ne_zero coeff_coe_units_zero_ne_zero\n\n",
 "card_roots_sub_C'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_roots_sub_C' {p : polynomial R} {a : R} (hp0 : 0 < degree p) : (p - C a).roots.card ≤ nat_degree p :=\n  WithBot.coe_le_coe.1\n    (le_trans (card_roots_sub_C hp0) (le_of_eq <| degree_eq_nat_degree fun h => by simp_all [lt_irrefl]))\n#align card_roots_sub_C' card_roots_sub_C'\n\n",
 "card_roots_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_roots_sub_C {p : polynomial R} {a : R} (hp0 : 0 < degree p) :\n    ((p - C a).roots.card : WithBot ℕ) ≤ degree p :=\n  calc\n    ((p - C a).roots.card : WithBot ℕ) ≤ degree (p - C a) :=\n      card_roots <| mt sub_eq_zero.1 fun h => not_le_of_gt hp0 <| h.symm ▸ degree_C_le\n    _ = degree p := by rw [sub_eq_add_neg, ← C_neg] <;> exact degree_add_C hp0\n    \n#align card_roots_sub_C card_roots_sub_C\n\n",
 "card_roots_le_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem card_roots_le_map_of_injective [IsDomain A] [IsDomain B] {p : polynomial A} {f : «expr →+* » A B}\n    (hf : function.injective f) : p.roots.card ≤ (p.map f).roots.card :=\n  by\n  by_cases hp0 : p = 0; · simp only [hp0, roots_zero, polynomial.map_zero, Multiset.card_zero]\n  exact card_roots_le_map ((polynomial.map_ne_zero_iff hf).mpr hp0)\n#align card_roots_le_map_of_injective card_roots_le_map_of_injective\n\n",
 "card_roots_le_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem card_roots_le_map [IsDomain A] [IsDomain B] {p : polynomial A} {f : «expr →+* » A B} (h : p.map f ≠ 0) :\n    p.roots.card ≤ (p.map f).roots.card := by\n  rw [← p.roots.card_map f]\n  exact Multiset.card_le_of_le (map_roots_le h)\n#align card_roots_le_map card_roots_le_map\n\n",
 "card_roots_X_pow_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_roots_X_pow_sub_C {n : ℕ} (hn : 0 < n) (a : R) : (roots ((X : polynomial R) ^ n - C a)).card ≤ n :=\n  WithBot.coe_le_coe.1 <|\n    calc\n      ((roots ((X : polynomial R) ^ n - C a)).card : WithBot ℕ) ≤ degree ((X : polynomial R) ^ n - C a) :=\n        card_roots (X_pow_sub_C_ne_zero hn a)\n      _ = n := degree_X_pow_sub_C hn a\n      \n#align card_roots_X_pow_sub_C card_roots_X_pow_sub_C\n\n",
 "card_roots'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_roots' (p : polynomial R) : p.roots.card ≤ nat_degree p :=\n  by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  exact WithBot.coe_le_coe.1 (le_trans (card_roots hp0) (le_of_eq <| degree_eq_nat_degree hp0))\n#align card_roots' card_roots'\n\n",
 "card_roots":
 "theorem card_roots (hp0 : p ≠ 0) : ((roots p).card : WithBot ℕ) ≤ degree p :=\n  by\n  unfold roots\n  rw [dif_neg hp0]\n  exact (Classical.choose_spec (exists_multiset_roots hp0)).1\n#align card_roots card_roots\n\n",
 "card_nth_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_nth_roots (n : ℕ) (a : R) : (nth_roots n a).card ≤ n :=\n  if hn : n = 0 then\n    if h : (X : polynomial R) ^ n - C a = 0 then by\n      simp only [nat.zero_le, nth_roots, roots, h, dif_pos rfl, empty_eq_zero, card_zero]\n    else\n      WithBot.coe_le_coe.1\n        (le_trans (card_roots h)\n          (by\n            rw [hn, pow_zero, ← C_1, ← RingHom.map_sub]\n            exact degree_C_le))\n  else by\n    rw [← WithBot.coe_le_coe, ← degree_X_pow_sub_C (nat.pos_of_ne_zero hn) a] <;>\n      exact card_roots (X_pow_sub_C_ne_zero (nat.pos_of_ne_zero hn) a)\n#align card_nth_roots card_nth_roots\n\n",
 "card_le_degree_of_subset_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_le_degree_of_subset_roots {p : polynomial R} {Z : Finset R} (h : Z.val ⊆ p.roots) :\n    Z.card ≤ p.nat_degree :=\n  (Multiset.card_le_of_le (Finset.val_le_iff_val_subset.2 h)).trans (polynomial.card_roots' p)\n#align card_le_degree_of_subset_roots card_le_degree_of_subset_roots\n\n",
 "bUnion_roots_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The set of roots of all polynomials of bounded degree and having coefficients in a finite set\nis finite. -/\ntheorem bUnion_roots_finite {R S : Type _} [Semiring R] [CommRing S] [IsDomain S] (m : «expr →+* » R S) (d : ℕ)\n    {U : set R} (h : U.finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ((f.map m).roots.to_finset : set S)).finite :=\n  set.finite.bUnion\n    (by\n      -- We prove that the set of polynomials under consideration is finite because its\n      -- image by the injective map `π` is finite\n      let π : polynomial R → fin (d + 1) → R := fun f i => f.coeff i\n      refine' ((set.finite.pi fun e => h).subset <| _).of_finite_image (_ : Set.InjOn π _)\n      · exact Set.image_subset_iff.2 fun f hf i _ => hf.2 i\n      · refine' fun x hx y hy hxy => (ext_iff_nat_degree_le hx.1 hy.1).2 fun i hi => _\n        exact id congr_fun hxy ⟨i, nat.lt_succ_of_le hi⟩)\n    fun i hi => finset.finite_to_set _\n#align bUnion_roots_finite bUnion_roots_finite\n\n",
 "aeval_mod_by_monic_eq_self_of_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem aeval_mod_by_monic_eq_self_of_root [algebra R S] {p q : polynomial R} (hq : q.monic) {x : S}\n    (hx : aeval x q = 0) : aeval x («expr %ₘ » p q) = aeval x p :=\n  by-- `eval₂_mod_by_monic_eq_self_of_root` doesn't work here as it needs commutativity\n  rw [mod_by_monic_eq_sub_mul_div p hq, _root_.map_sub, _root_.map_mul, hx, zero_mul, sub_zero]\n#align aeval_mod_by_monic_eq_self_of_root aeval_mod_by_monic_eq_self_of_root\n\n",
 "aeval_eq_zero_of_mem_root_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem aeval_eq_zero_of_mem_root_set {p : polynomial T} [CommRing S] [IsDomain S] [algebra T S] {a : S}\n    (hx : a ∈ p.root_set S) : aeval a p = 0 :=\n  (mem_root_set'.1 hx).2\n#align aeval_eq_zero_of_mem_root_set aeval_eq_zero_of_mem_root_set\n\n",
 "add_mod_by_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr /ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\ntheorem add_mod_by_monic (p₁ p₂ : polynomial R) : «expr %ₘ » (p₁ + p₂) q = «expr %ₘ » p₁ q + «expr %ₘ » p₂ q :=\n  by\n  by_cases hq : q.monic\n  · nontriviality R\n    exact\n      (div_mod_by_monic_unique («expr /ₘ » p₁ q + «expr /ₘ » p₂ q) _ hq\n          ⟨by\n            rw [mul_add, add_left_comm, add_assoc, mod_by_monic_add_div _ hq, ← add_assoc, add_comm (q * _),\n              mod_by_monic_add_div _ hq],\n            (degree_add_le _ _).trans_lt (max_lt (degree_mod_by_monic_lt _ hq) (degree_mod_by_monic_lt _ hq))⟩).2\n  · simp_rw [mod_by_monic_eq_of_not_monic _ hq]\n#align add_mod_by_monic add_mod_by_monic\n\n",
 "C_leading_coeff_mul_prod_multiset_X_sub_C":
 "/-- A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leading_coeff * ∏(X - a)`, for `a` in `p.roots`. -/\ntheorem C_leading_coeff_mul_prod_multiset_X_sub_C (hroots : p.roots.card = p.nat_degree) :\n    C p.leading_coeff * (p.roots.map fun a => X - C a).prod = p :=\n  (eq_leading_coeff_mul_of_monic_of_dvd_of_nat_degree_le monic_prod_multiset_X_sub_C p.prod_multiset_X_sub_C_dvd\n      ((nat_degree_multiset_prod_X_sub_C_eq_card _).trans hroots).ge).symm\n#align C_leading_coeff_mul_prod_multiset_X_sub_C C_leading_coeff_mul_prod_multiset_X_sub_C\n\n"}