{"smul_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `p` lifts and `(r : R)` then `r • p` lifts. -/\ntheorem smul_mem_lifts {p : polynomial S} (r : R) (hp : p ∈ lifts (algebraMap R S)) :\n    «expr • » r p ∈ lifts (algebraMap R S) :=\n  by\n  rw [mem_lifts_iff_mem_alg] at hp⊢\n  exact Subalgebra.smul_mem (map_alg R S).range hp r\n#align smul_mem_lifts smul_mem_lifts\n\n",
 "monomial_mem_lifts_and_degree_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem monomial_mem_lifts_and_degree_eq {s : S} {n : ℕ} (hl : monomial n s ∈ lifts f) :\n    ∃ q : polynomial R, map f q = monomial n s ∧ q.degree = (monomial n s).degree :=\n  by\n  by_cases hzero : s = 0\n  · use 0\n    simp only [hzero, degree_zero, eq_self_iff_true, and_self_iff, monomial_zero_right, Polynomial.map_zero]\n  rw [lifts_iff_set_range] at hl\n  obtain ⟨q, hq⟩ := hl\n  replace hq := (ext_iff.1 hq) n\n  have hcoeff : f (q.coeff n) = s := by\n    simp [coeff_monomial] at hq\n    exact hq\n  use monomial n (q.coeff n)\n  constructor\n  · simp only [hcoeff, map_monomial]\n  have hqzero : q.coeff n ≠ 0 := by\n    intro habs\n    simp only [habs, RingHom.map_zero] at hcoeff\n    exact hzero hcoeff.symm\n  repeat' rw [← C_mul_X_pow_eq_monomial]\n  simp only [hzero, hqzero, ne.def, not_false_iff, degree_C_mul_X_pow]\n#align monomial_mem_lifts_and_degree_eq monomial_mem_lifts_and_degree_eq\n\n",
 "monomial_mem_lifts":
 "/-- If `(s : S)` is in the image of `f`, then `monomial n s` lifts. -/\ntheorem monomial_mem_lifts {s : S} (n : ℕ) (h : s ∈ Set.range f) : monomial n s ∈ lifts f :=\n  by\n  obtain ⟨r, rfl⟩ := Set.mem_range.1 h\n  use monomial n r\n  simp only [coe_map_ring_hom, Set.mem_univ, map_monomial, Subsemiring.coe_top, eq_self_iff_true, and_self_iff]\n#align monomial_mem_lifts monomial_mem_lifts\n\n",
 "mem_lifts_iff_mem_alg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A polynomial `p` lifts if and only if it is in the image of `map_alg`. -/\ntheorem mem_lifts_iff_mem_alg (R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S] (p : polynomial S) :\n    p ∈ lifts (algebraMap R S) ↔ p ∈ AlgHom.range (@mapAlg R _ S _ _) := by\n  simp only [coe_map_ring_hom, lifts, map_alg_eq_map, AlgHom.mem_range, RingHom.mem_rangeS]\n#align mem_lifts_iff_mem_alg mem_lifts_iff_mem_alg\n\n",
 "mem_lifts_and_degree_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A polynomial lifts if and only if it can be lifted to a polynomial of the same degree. -/\ntheorem mem_lifts_and_degree_eq {p : polynomial S} (hlifts : p ∈ lifts f) :\n    ∃ q : polynomial R, map f q = p ∧ q.degree = p.degree :=\n  by\n  generalize hd : p.nat_degree = d\n  revert hd p\n  apply nat.strong_induction_on d\n  intro n hn p hlifts hdeg\n  by_cases erase_zero : p.erase_lead = 0\n  · rw [← erase_lead_add_monomial_nat_degree_leading_coeff p, erase_zero, zero_add, leading_coeff]\n    exact\n      monomial_mem_lifts_and_degree_eq\n        (monomial_mem_lifts p.nat_degree ((lifts_iff_coeff_lifts p).1 hlifts p.nat_degree))\n  have deg_erase := or.resolve_right (erase_lead_nat_degree_lt_or_erase_lead_eq_zero p) erase_zero\n  have pzero : p ≠ 0 := by\n    intro habs\n    exfalso\n    rw [habs, erase_lead_zero, eq_self_iff_true, not_true] at erase_zero\n    exact erase_zero\n  have lead_zero : p.coeff p.nat_degree ≠ 0 := by rw [← leading_coeff, ne.def, leading_coeff_eq_zero] <;> exact pzero\n  obtain ⟨lead, hlead⟩ :=\n    monomial_mem_lifts_and_degree_eq (monomial_mem_lifts p.nat_degree ((lifts_iff_coeff_lifts p).1 hlifts p.nat_degree))\n  have deg_lead : lead.degree = p.nat_degree := by\n    rw [hlead.2, ← C_mul_X_pow_eq_monomial, degree_C_mul_X_pow p.nat_degree lead_zero]\n  rw [hdeg] at deg_erase\n  obtain ⟨erase, herase⟩ :=\n    hn p.erase_lead.nat_degree deg_erase (erase_mem_lifts p.nat_degree hlifts) (refl p.erase_lead.nat_degree)\n  use erase + lead\n  constructor\n  · simp only [hlead, herase, Polynomial.map_add]\n    nth_rw 1 [erase_lead_add_monomial_nat_degree_leading_coeff p]\n  rw [← hdeg, erase_lead] at deg_erase\n  replace deg_erase := lt_of_le_of_lt degree_le_nat_degree (WithBot.coe_lt_coe.2 deg_erase)\n  rw [← deg_lead, ← herase.2] at deg_erase\n  rw [degree_add_eq_right_of_degree_lt deg_erase, deg_lead, degree_eq_nat_degree pzero]\n#align mem_lifts_and_degree_eq mem_lifts_and_degree_eq\n\n",
 "mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem mem_lifts (p : polynomial S) : p ∈ lifts f ↔ ∃ q : polynomial R, map f q = p := by\n  simp only [coe_map_ring_hom, lifts, RingHom.mem_rangeS]\n#align mem_lifts mem_lifts\n\n",
 "map_alg_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- `map_alg` is the morphism induced by `R → S`. -/\ntheorem map_alg_eq_map (p : polynomial R) : mapAlg R S p = map (algebraMap R S) p := by\n  simp only [map_alg, aeval_def, eval₂, map, algebraMap_apply, RingHom.coe_comp]\n#align map_alg_eq_map map_alg_eq_map\n\n",
 "lifts_iff_set_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem lifts_iff_set_range (p : polynomial S) : p ∈ lifts f ↔ p ∈ Set.range (map f) := by\n  simp only [coe_map_ring_hom, lifts, Set.mem_range, RingHom.mem_rangeS]\n#align lifts_iff_set_range lifts_iff_set_range\n\n",
 "lifts_iff_ring_hom_srange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem lifts_iff_ring_hom_srange (p : polynomial S) : p ∈ lifts f ↔ p ∈ (mapRingHom f).srange := by\n  simp only [coe_map_ring_hom, lifts, Set.mem_range, RingHom.mem_rangeS]\n#align lifts_iff_ring_hom_srange lifts_iff_ring_hom_srange\n\n",
 "lifts_iff_lifts_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `R` and `S` are rings, `p` is in the subring of polynomials that lift if and only if it is in\nthe subsemiring of polynomials that lift. -/\ntheorem lifts_iff_lifts_ring (p : polynomial S) : p ∈ lifts f ↔ p ∈ liftsRing f := by\n  simp only [lifts, lifts_ring, RingHom.mem_range, RingHom.mem_rangeS]\n#align lifts_iff_lifts_ring lifts_iff_lifts_ring\n\n",
 "lifts_iff_coeff_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem lifts_iff_coeff_lifts (p : polynomial S) : p ∈ lifts f ↔ ∀ n : ℕ, p.coeff n ∈ Set.range f :=\n  by\n  rw [lifts_iff_ring_hom_srange, mem_map_srange f]\n  rfl\n#align lifts_iff_coeff_lifts lifts_iff_coeff_lifts\n\n",
 "lifts_and_nat_degree_eq_and_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem lifts_and_nat_degree_eq_and_monic {p : polynomial S} (hlifts : p ∈ lifts f) (hp : p.monic) :\n    ∃ q : polynomial R, map f q = p ∧ q.nat_degree = p.nat_degree ∧ q.monic :=\n  by\n  cases' subsingleton_or_nontrivial S with hR hR\n  · obtain rfl : p = 1 := subsingleton.elim _ _\n    refine' ⟨1, subsingleton.elim _ _, by simp, by simp⟩\n  obtain ⟨p', h₁, h₂, h₃⟩ := lifts_and_degree_eq_and_monic hlifts hp\n  exact ⟨p', h₁, nat_degree_eq_of_degree_eq h₂, h₃⟩\n#align lifts_and_nat_degree_eq_and_monic lifts_and_nat_degree_eq_and_monic\n\n",
 "lifts_and_degree_eq_and_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- A monic polynomial lifts if and only if it can be lifted to a monic polynomial\nof the same degree. -/\ntheorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : polynomial S} (hlifts : p ∈ lifts f) (hp : p.monic) :\n    ∃ q : polynomial R, map f q = p ∧ q.degree = p.degree ∧ q.monic :=\n  by\n  cases' subsingleton_or_nontrivial R with hR hR\n  · obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq hlifts\n    exact ⟨q, hq.1, hq.2, monic_of_subsingleton _⟩\n  have H : erase p.nat_degree p + X ^ p.nat_degree = p := by\n    simpa only [hp.leading_coeff, C_1, one_mul, erase_lead] using erase_lead_add_C_mul_X_pow p\n  by_cases h0 : erase p.nat_degree p = 0\n  · rw [← H, h0, zero_add]\n    refine' ⟨X ^ p.nat_degree, _, _, monic_X_pow p.nat_degree⟩\n    · rw [Polynomial.map_pow, map_X]\n    · rw [degree_X_pow, degree_X_pow]\n  obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq (erase_mem_lifts p.nat_degree hlifts)\n  have hdeg : q.degree < (X ^ p.nat_degree).degree :=\n    by\n    rw [@degree_X_pow R, hq.2, degree_eq_nat_degree h0, WithBot.coe_lt_coe]\n    exact or.resolve_right (erase_lead_nat_degree_lt_or_erase_lead_eq_zero p) h0\n  refine' ⟨q + X ^ p.nat_degree, _, _, (monic_X_pow _).add_of_right hdeg⟩\n  · rw [Polynomial.map_add, hq.1, Polynomial.map_pow, map_X, H]\n  · rw [degree_add_eq_right_of_degree_lt hdeg, degree_X_pow, degree_eq_nat_degree hp.ne_zero]\n#align lifts_and_degree_eq_and_monic lifts_and_degree_eq_and_monic\n\n",
 "erase_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `p` lifts then `p.erase n` lifts. -/\ntheorem erase_mem_lifts {p : polynomial S} (n : ℕ) (h : p ∈ lifts f) : p.erase n ∈ lifts f :=\n  by\n  rw [lifts_iff_ring_hom_srange, mem_map_srange] at h⊢\n  intro k\n  by_cases hk : k = n\n  · use 0\n    simp only [hk, RingHom.map_zero, erase_same]\n  obtain ⟨i, hi⟩ := h k\n  use i\n  simp only [hi, hk, erase_ne, ne.def, not_false_iff]\n#align erase_mem_lifts erase_mem_lifts\n\n",
 "base_mul_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `p` lifts and `(r : R)` then `r * p` lifts. -/\ntheorem base_mul_mem_lifts {p : polynomial S} (r : R) (hp : p ∈ lifts f) : C (f r) * p ∈ lifts f :=\n  by\n  simp only [lifts, RingHom.mem_rangeS] at hp⊢\n  obtain ⟨p₁, rfl⟩ := hp\n  use C r * p₁\n  simp only [coe_map_ring_hom, map_C, map_mul]\n#align base_mul_mem_lifts base_mul_mem_lifts\n\n",
 "X_pow_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The polynomial `X ^ n` lifts. -/\ntheorem X_pow_mem_lifts (f : «expr →+* » R S) (n : ℕ) : (X ^ n : polynomial S) ∈ lifts f :=\n  ⟨X ^ n, by\n    simp only [coe_map_ring_hom, map_pow, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, map_X, and_self_iff]⟩\n#align X_pow_mem_lifts X_pow_mem_lifts\n\n",
 "X_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The polynomial `X` lifts. -/\ntheorem X_mem_lifts (f : «expr →+* » R S) : (X : polynomial S) ∈ lifts f :=\n  ⟨X, by simp only [coe_map_ring_hom, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, map_X, and_self_iff]⟩\n#align X_mem_lifts X_mem_lifts\n\n",
 "C_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `(r : R)`, then `C (f r)` lifts. -/\ntheorem C_mem_lifts (f : «expr →+* » R S) (r : R) : C (f r) ∈ lifts f :=\n  ⟨C r, by simp only [coe_map_ring_hom, map_C, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, and_self_iff]⟩\n#align C_mem_lifts C_mem_lifts\n\n",
 "C'_mem_lifts":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `(s : S)` is in the image of `f`, then `C s` lifts. -/\ntheorem C'_mem_lifts {f : «expr →+* » R S} {s : S} (h : s ∈ Set.range f) : C s ∈ lifts f :=\n  by\n  obtain ⟨r, rfl⟩ := Set.mem_range.1 h\n  use C r\n  simp only [coe_map_ring_hom, map_C, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, and_self_iff]\n#align C'_mem_lifts C'_mem_lifts\n\n"}