{"one_le_pow_mul_abs_eval_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Evaluating a polynomial with integer coefficients at a rational number and clearing\ndenominators, yields a number greater than or equal to one.  The target can be any\n`linear_ordered_field K`.\nThe assumption on `K` could be weakened to `linear_ordered_comm_ring` assuming that the\nimage of the denominator is invertible in `K`. -/\ntheorem one_le_pow_mul_abs_eval_div {K : Type _} [LinearOrderedField K] {f : polynomial ℤ} {a b : ℤ} (b0 : 0 < b)\n    (fab : eval ((a : K) / b) (f.map (algebra_map ℤ K)) ≠ 0) :\n    (1 : K) ≤ b ^ f.nat_degree * |eval ((a : K) / b) (f.map (algebra_map ℤ K))| :=\n  by\n  obtain ⟨ev, bi, bu, hF⟩ :=\n    @denoms_clearable_nat_degree _ _ _ _ b _ (algebra_map ℤ K) f a\n      (by\n        rw [eq_intCast, one_div_mul_cancel]\n        rw [Int.cast_ne_zero]\n        exact b0.ne.symm)\n  obtain Fa := congr_arg abs hF\n  rw [eq_one_div_of_mul_eq_one_left bu, eq_intCast, eq_intCast, abs_mul] at Fa\n  rw [abs_of_pos (pow_pos (int.cast_pos.mpr b0) _ : 0 < (b : K) ^ _), one_div, eq_intCast] at Fa\n  rw [div_eq_mul_inv, ← Fa, ← Int.cast_abs, ← Int.cast_one, Int.cast_le]\n  refine' int.le_of_lt_add_one ((lt_add_iff_pos_left 1).mpr (abs_pos.mpr fun F0 => fab _))\n  rw [eq_one_div_of_mul_eq_one_left bu, F0, one_div, eq_intCast, Int.cast_zero, zero_eq_mul] at hF\n  cases' hF with hF hF\n  · exact (not_le.mpr b0 (le_of_eq (int.cast_eq_zero.mp (pow_eq_zero hF)))).elim\n  · rwa [div_eq_mul_inv]\n#align one_le_pow_mul_abs_eval_div one_le_pow_mul_abs_eval_div\n\n",
 "denoms_clearable_zero":
 "/-\nCopyright (c) 2020 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\n-- TODO: use hypothesis (ub : is_unit (i b)) to work with localizations.\ntheorem denoms_clearable_zero (N : ℕ) (a : R) (bu : bi * i b = 1) : denoms_clearable a b N 0 i :=\n  ⟨0, bi, bu, by simp only [eval_zero, RingHom.map_zero, mul_zero, polynomial.map_zero]⟩\n#align denoms_clearable_zero denoms_clearable_zero\n\n",
 "denoms_clearable_of_nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem denoms_clearable_of_nat_degree_le (N : ℕ) (a : R) (bu : bi * i b = 1) :\n    ∀ f : polynomial R, f.nat_degree ≤ N → denoms_clearable a b N f i :=\n  induction_with_nat_degree_le _ N (denoms_clearable_zero N a bu) (fun N_1 r r0 => denoms_clearable_C_mul_X_pow a bu r)\n    fun f g fg gN df dg => df.add dg\n#align denoms_clearable_of_nat_degree_le denoms_clearable_of_nat_degree_le\n\n",
 "denoms_clearable_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `i : R → K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`,\n`a, b` are elements of `R`, with `i b` invertible, then there is a `D ∈ R` such that\n`b ^ f.nat_degree * f (a / b)` equals `i D`. -/\ntheorem denoms_clearable_nat_degree (i : «expr →+* » R K) (f : polynomial R) (a : R) (bu : bi * i b = 1) :\n    denoms_clearable a b f.nat_degree f i :=\n  denoms_clearable_of_nat_degree_le f.nat_degree a bu f le_rfl\n#align denoms_clearable_nat_degree denoms_clearable_nat_degree\n\n",
 "denoms_clearable_C_mul_X_pow":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { occs := occurrences.pos[occurrences.pos] «expr[ ,]»([2]) } -/\ntheorem denoms_clearable_C_mul_X_pow {N : ℕ} (a : R) (bu : bi * i b = 1) {n : ℕ} (r : R) (nN : n ≤ N) :\n    denoms_clearable a b N (C r * X ^ n) i :=\n  by\n  refine' ⟨r * a ^ n * b ^ (N - n), bi, bu, _⟩\n  rw [C_mul_X_pow_eq_monomial, map_monomial, ← C_mul_X_pow_eq_monomial, eval_mul, eval_pow, eval_C]\n  rw [RingHom.map_mul, RingHom.map_mul, RingHom.map_pow, RingHom.map_pow, eval_X, mul_comm]\n  rw [← tsub_add_cancel_of_le nN]\n  rw [pow_add, mul_assoc, mul_comm (i b ^ n), mul_pow, mul_assoc, mul_assoc (i a ^ n), ← mul_pow]\n  rw [bu, one_pow, mul_one]\n#align denoms_clearable_C_mul_X_pow denoms_clearable_C_mul_X_pow\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem denoms_clearable.add {N : ℕ} {f g : polynomial R} :\n    denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i :=\n  fun ⟨Df, bf, bfu, Hf⟩ ⟨Dg, bg, bgu, Hg⟩ =>\n  ⟨Df + Dg, bf, bfu, by\n    rw [RingHom.map_add, polynomial.map_add, eval_add, mul_add, Hf, Hg]\n    congr\n    refine' @inv_unique K _ (i b) bg bf _ _ <;> rwa [mul_comm]⟩\n#align denoms_clearable.add denoms_clearable.add\n\n"}