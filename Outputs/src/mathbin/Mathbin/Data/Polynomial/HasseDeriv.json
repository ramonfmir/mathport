{"nat_degree_hasse_deriv_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_hasse_deriv_le (p : polynomial R) (n : ℕ) : natDegree (hasseDeriv n p) ≤ natDegree p - n := by\n  classical\n    rw [hasse_deriv_apply, sum_def]\n    refine' (nat_degree_sum_le _ _).trans _\n    simp_rw [Function.comp, nat_degree_monomial]\n    rw [Finset.fold_ite, Finset.fold_const]\n    · simp only [if_t_t, max_eq_right, zero_le', Finset.fold_max_le, true_and_iff, and_imp, tsub_le_iff_right,\n        mem_support_iff, ne.def, Finset.mem_filter]\n      intro x hx hx'\n      have hxp : x ≤ p.nat_degree := le_nat_degree_of_ne_zero hx\n      have hxn : n ≤ x := by\n        contrapose! hx'\n        simp [Nat.choose_eq_zero_of_lt hx']\n      rwa [tsub_add_cancel_of_le (hxn.trans hxp)]\n    · simp\n#align nat_degree_hasse_deriv_le nat_degree_hasse_deriv_le\n\n",
 "nat_degree_hasse_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_hasse_deriv [NoZeroSMulDivisors ℕ R] (p : polynomial R) (n : ℕ) :\n    natDegree (hasseDeriv n p) = natDegree p - n :=\n  by\n  cases' lt_or_le p.nat_degree n with hn hn\n  · simpa [hasse_deriv_eq_zero_of_lt_nat_degree, hn] using (tsub_eq_zero_of_le hn.le).symm\n  · refine' map_nat_degree_eq_sub _ _\n    · exact fun h => hasse_deriv_eq_zero_of_lt_nat_degree _ _\n    ·\n      classical\n        simp only [ite_eq_right_iff, ne.def, nat_degree_monomial, hasse_deriv_monomial]\n        intro k c c0 hh\n        -- this is where we use the `smul_eq_zero` from `no_zero_smul_divisors`\n        rw [← nsmul_eq_mul, smul_eq_zero, Nat.choose_eq_zero_iff] at hh\n        exact (tsub_eq_zero_of_le (or.resolve_right hh c0).le).symm\n#align nat_degree_hasse_deriv nat_degree_hasse_deriv\n\n",
 "hasse_deriv_zero'":
 "theorem hasse_deriv_zero' : hasseDeriv 0 f = f := by\n  simp only [hasse_deriv_apply, tsub_zero, Nat.choose_zero_right, Nat.cast_one, one_mul, sum_monomial_eq]\n#align hasse_deriv_zero' hasse_deriv_zero'\n\n",
 "hasse_deriv_zero":
 "@[simp]\ntheorem hasse_deriv_zero : @hasseDeriv R _ 0 = LinearMap.id :=\n  LinearMap.ext <| hasseDeriv_zero'\n#align hasse_deriv_zero hasse_deriv_zero\n\n",
 "hasse_deriv_one'":
 "theorem hasse_deriv_one' : hasseDeriv 1 f = derivative f := by\n  simp only [hasse_deriv_apply, derivative_apply, ← C_mul_X_pow_eq_monomial, Nat.choose_one_right,\n    (Nat.cast_commute _ _).eq]\n#align hasse_deriv_one' hasse_deriv_one'\n\n",
 "hasse_deriv_one":
 "@[simp]\ntheorem hasse_deriv_one : @hasseDeriv R _ 1 = derivative :=\n  LinearMap.ext <| hasseDeriv_one'\n#align hasse_deriv_one hasse_deriv_one\n\n",
 "hasse_deriv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem hasse_deriv_mul (f g : polynomial R) :\n    hasseDeriv k (f * g) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (antidiagonal k)\n        (hasseDeriv ij.1 f * hasseDeriv ij.2 g) :=\n  by\n  let D k := (@hasse_deriv R _ k).to_add_monoid_hom\n  let Φ := @AddMonoidHom.mul (polynomial R) _\n  show\n    (comp_hom (D k)).comp Φ f g =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (antidiagonal k)\n        (((comp_hom.comp ((comp_hom Φ) (D ij.1))).flip (D ij.2) f) g)\n  simp only [← finset_sum_apply]\n  congr 2\n  clear f g\n  ext (m r n s) : 4\n  simp only [finset_sum_apply, coe_mul_left, coe_comp, flip_apply, comp_app, hasse_deriv_monomial,\n    LinearMap.toAddMonoidHom_coe, comp_hom_apply_apply, coe_mul, monomial_mul_monomial]\n  have aux :\n    ∀ x : ℕ × ℕ,\n      x ∈ antidiagonal k →\n        monomial (m - x.1 + (n - x.2)) (↑(m.choose x.1) * r * (↑(n.choose x.2) * s)) =\n          monomial (m + n - k) (↑(m.choose x.1) * ↑(n.choose x.2) * (r * s)) :=\n    by\n    intro x hx\n    rw [Finset.Nat.mem_antidiagonal] at hx\n    subst hx\n    by_cases hm : m < x.1\n    · simp only [Nat.choose_eq_zero_of_lt hm, Nat.cast_zero, MulZeroClass.zero_mul, monomial_zero_right]\n    by_cases hn : n < x.2\n    ·\n      simp only [Nat.choose_eq_zero_of_lt hn, Nat.cast_zero, MulZeroClass.zero_mul, MulZeroClass.mul_zero,\n        monomial_zero_right]\n    push_neg  at hm hn\n    rw [tsub_add_eq_add_tsub hm, ← add_tsub_assoc_of_le hn, ← tsub_add_eq_tsub_tsub, add_comm x.2 x.1, mul_assoc, ←\n      mul_assoc r, ← (Nat.cast_commute _ r).eq, mul_assoc, mul_assoc]\n  conv_rhs =>\n    apply_congr\n    skip\n    rw [aux _ H]\n  rw_mod_cast [← LinearMap.map_sum, ← Finset.sum_mul, ← Nat.add_choose_eq]\n#align hasse_deriv_mul hasse_deriv_mul\n\n",
 "hasse_deriv_monomial":
 "@[simp]\ntheorem hasse_deriv_monomial (n : ℕ) (r : R) : hasseDeriv k (monomial n r) = monomial (n - k) (↑(n.choose k) * r) :=\n  by\n  ext i\n  simp only [hasse_deriv_coeff, coeff_monomial]\n  by_cases hnik : n = i + k\n  · rw [if_pos hnik, if_pos, ← hnik]\n    apply tsub_eq_of_eq_add_rev\n    rwa [add_comm]\n  · rw [if_neg hnik, MulZeroClass.mul_zero]\n    by_cases hkn : k ≤ n\n    · rw [← tsub_eq_iff_eq_add_of_le hkn] at hnik\n      rw [if_neg hnik]\n    · push_neg  at hkn\n      rw [Nat.choose_eq_zero_of_lt hkn, Nat.cast_zero, MulZeroClass.zero_mul, if_t_t]\n#align hasse_deriv_monomial hasse_deriv_monomial\n\n",
 "hasse_deriv_eq_zero_of_lt_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem hasse_deriv_eq_zero_of_lt_nat_degree (p : polynomial R) (n : ℕ) (h : p.nat_degree < n) : hasseDeriv n p = 0 :=\n  by\n  rw [hasse_deriv_apply, sum_def]\n  refine' Finset.sum_eq_zero fun x hx => _\n  simp [Nat.choose_eq_zero_of_lt ((le_nat_degree_of_mem_supp _ hx).trans_lt h)]\n#align hasse_deriv_eq_zero_of_lt_nat_degree hasse_deriv_eq_zero_of_lt_nat_degree\n\n",
 "hasse_deriv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem hasse_deriv_comp (k l : ℕ) :\n    (@hasseDeriv R _ k).comp (hasseDeriv l) = «expr • » ((k + l).choose k) (hasseDeriv (k + l)) :=\n  by\n  ext i : 2\n  simp only [LinearMap.smul_apply, comp_app, LinearMap.coe_comp, smul_monomial, hasse_deriv_apply, mul_one,\n    monomial_eq_zero_iff, sum_monomial_index, MulZeroClass.mul_zero, ← tsub_add_eq_tsub_tsub, add_comm l k]\n  rw_mod_cast [nsmul_eq_mul]\n  congr 2\n  by_cases hikl : i < k + l\n  · rw [choose_eq_zero_of_lt hikl, MulZeroClass.mul_zero]\n    by_cases hil : i < l\n    · rw [choose_eq_zero_of_lt hil, MulZeroClass.mul_zero]\n    · push_neg  at hil\n      rw [← tsub_lt_iff_right hil] at hikl\n      rw [choose_eq_zero_of_lt hikl, MulZeroClass.zero_mul]\n  push_neg  at hikl\n  apply @cast_injective (exprℚ)\n  have h1 : l ≤ i := le_of_add_le_right hikl\n  have h2 : k ≤ i - l := le_tsub_of_add_le_right hikl\n  have h3 : k ≤ k + l := le_self_add\n  have H : ∀ n : ℕ, (nat.factorial n : exprℚ) ≠ 0 := by exact_mod_cast factorial_ne_zero\n  -- why can't `field_simp` help me here?\n  simp only [cast_mul, cast_choose (exprℚ), h1, h2, h3, hikl, -one_div, -mul_eq_zero, succ_sub_succ_eq_sub,\n    add_tsub_cancel_right, add_tsub_cancel_left, field_simps]\n  rw [eq_div_iff_mul_eq, eq_comm, div_mul_eq_mul_div, eq_div_iff_mul_eq, ← tsub_add_eq_tsub_tsub, add_comm l k]\n  · ring\n  all_goals apply_rules [mul_ne_zero, H]\n#align hasse_deriv_comp hasse_deriv_comp\n\n",
 "hasse_deriv_coeff":
 "theorem hasse_deriv_coeff (n : ℕ) : (hasseDeriv k f).coeff n = (n + k).choose k * f.coeff (n + k) :=\n  by\n  rw [hasse_deriv_apply, coeff_sum, sum_def, Finset.sum_eq_single (n + k), coeff_monomial]\n  · simp only [if_true, add_tsub_cancel_right, eq_self_iff_true]\n  · intro i hi hink\n    rw [coeff_monomial]\n    by_cases hik : i < k\n    · simp only [Nat.choose_eq_zero_of_lt hik, if_t_t, Nat.cast_zero, MulZeroClass.zero_mul]\n    · push_neg  at hik\n      rw [if_neg]\n      contrapose! hink\n      exact (tsub_eq_iff_eq_add_of_le hik).mp hink\n  · intro h\n    simp only [not_mem_support_iff.mp h, monomial_zero_right, MulZeroClass.mul_zero, coeff_zero]\n#align hasse_deriv_coeff hasse_deriv_coeff\n\n",
 "hasse_deriv_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem hasse_deriv_apply_one (hk : 0 < k) : hasseDeriv k (1 : polynomial R) = 0 := by rw [← C_1, hasse_deriv_C k _ hk]\n#align hasse_deriv_apply_one hasse_deriv_apply_one\n\n",
 "hasse_deriv_apply":
 "/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\ntheorem hasse_deriv_apply : hasseDeriv k f = f.sum fun i r => monomial (i - k) (↑(i.choose k) * r) := by\n  simpa only [← nsmul_eq_mul]\n#align hasse_deriv_apply hasse_deriv_apply\n\n",
 "hasse_deriv_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem hasse_deriv_X (hk : 1 < k) : hasseDeriv k (X : polynomial R) = 0 := by\n  rw [← monomial_one_one_eq_X, hasse_deriv_monomial, Nat.choose_eq_zero_of_lt hk, Nat.cast_zero, MulZeroClass.zero_mul,\n    monomial_zero_right]\n#align hasse_deriv_X hasse_deriv_X\n\n",
 "hasse_deriv_C":
 "theorem hasse_deriv_C (r : R) (hk : 0 < k) : hasseDeriv k (C r) = 0 := by\n  rw [← monomial_zero_left, hasse_deriv_monomial, Nat.choose_eq_zero_of_lt hk, Nat.cast_zero, MulZeroClass.zero_mul,\n    monomial_zero_right]\n#align hasse_deriv_C hasse_deriv_C\n\n",
 "factorial_smul_hasse_deriv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem factorial_smul_hasse_deriv :\n    «expr⇑ » («expr • » (nat.factorial k) (@hasseDeriv R _ k)) = «expr ^[ ]» (@derivative R _) k :=\n  by\n  induction' k with k ih\n  · rw [hasse_deriv_zero, factorial_zero, iterate_zero, one_smul, LinearMap.id_coe]\n  ext (f n) : 2\n  rw [iterate_succ_apply', ← ih]\n  simp only [LinearMap.smul_apply, coeff_smul, LinearMap.map_smul_of_tower, coeff_derivative, hasse_deriv_coeff, ←\n    @choose_symm_add _ k]\n  simp only [nsmul_eq_mul, factorial_succ, mul_assoc, succ_eq_add_one, ← add_assoc, add_right_comm n 1 k, ← cast_succ]\n  rw [← (cast_commute (n + 1) (f.coeff (n + k + 1))).eq]\n  simp only [← mul_assoc]\n  norm_cast\n  congr 2\n  apply @cast_injective (exprℚ)\n  have h1 : n + 1 ≤ n + k + 1 := succ_le_succ le_self_add\n  have h2 : k + 1 ≤ n + k + 1 := succ_le_succ le_add_self\n  have H : ∀ n : ℕ, (nat.factorial n : exprℚ) ≠ 0 := by exact_mod_cast factorial_ne_zero\n  -- why can't `field_simp` help me here?\n  simp only [cast_mul, cast_choose (exprℚ), h1, h2, -one_div, -mul_eq_zero, succ_sub_succ_eq_sub, add_tsub_cancel_right,\n    add_tsub_cancel_left, field_simps]\n  rw [eq_div_iff_mul_eq (mul_ne_zero (H _) (H _)), eq_comm, div_mul_eq_mul_div,\n    eq_div_iff_mul_eq (mul_ne_zero (H _) (H _))]\n  norm_cast\n  simp only [factorial_succ, succ_eq_add_one]\n  ring\n#align factorial_smul_hasse_deriv factorial_smul_hasse_deriv\n\n"}