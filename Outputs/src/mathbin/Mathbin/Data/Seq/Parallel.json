{"terminates_parallel":
 "theorem terminates_parallel {S : WSeq (Computation α)} {c} (h : c ∈ S) [T : Terminates c] : Terminates (parallel S) :=\n  by\n  suffices\n    ∀ (n) (l : List (Computation α)) (S c),\n      c ∈ l ∨ some (some c) = Seq.get? S n → Terminates c → Terminates (corec parallel.aux1 (l, S))\n    from\n    let ⟨n, h⟩ := h\n    this n [] S c (or.inr h) T\n  intro n; induction' n with n IH <;> intro l S c o T\n  · cases' o with a a\n    · exact terminates_parallel.aux a T\n    have H : seq.destruct S = some (some c, _) :=\n      by\n      unfold seq.destruct functor.map\n      rw [← a]\n      simp\n    induction' h : parallel.aux2 l with a l' <;> have C : corec parallel.aux1 (l, S) = _\n    · apply destruct_eq_ret\n      simp [parallel.aux1]\n      rw [h]\n      simp [rmap]\n    · rw [C]\n      skip\n      infer_instance\n    · apply destruct_eq_think\n      simp [parallel.aux1]\n      rw [h, H]\n      simp [rmap]\n    · rw [C]\n      apply @Computation.think_terminates _ _ _\n      apply terminates_parallel.aux _ T\n      simp\n  · cases' o with a a\n    · exact terminates_parallel.aux a T\n    induction' h : parallel.aux2 l with a l' <;> have C : corec parallel.aux1 (l, S) = _\n    · apply destruct_eq_ret\n      simp [parallel.aux1]\n      rw [h]\n      simp [rmap]\n    · rw [C]\n      skip\n      infer_instance\n    · apply destruct_eq_think\n      simp [parallel.aux1]\n      rw [h]\n      simp [rmap]\n    · rw [C]\n      apply @Computation.think_terminates _ _ _\n      have TT : ∀ l', terminates (corec parallel.aux1 (l', S.tail)) :=\n        by\n        intro\n        apply IH _ _ _ (or.inr _) T\n        rw [a]\n        cases' S with f al\n        rfl\n      induction' e : seq.nth S 0 with o\n      · have D : seq.destruct S = none := by\n          dsimp [seq.destruct]\n          rw [e]\n          rfl\n        rw [D]\n        simp [parallel.aux1]\n        have TT := TT l'\n        rwa [seq.destruct_eq_nil D, seq.tail_nil] at TT\n      · have D : seq.destruct S = some (o, S.tail) :=\n          by\n          dsimp [seq.destruct]\n          rw [e]\n          rfl\n        rw [D]\n        cases' o with c <;> simp [parallel.aux1, TT]\n#align terminates_parallel terminates_parallel\n\n",
 "parallel_promises":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\n-- The reason this isn't trivial from exists_of_mem_parallel is because it eliminates to Sort\ntheorem parallel_promises {S : WSeq (Computation α)} {a} (H : ∀ s ∈ S, «expr ~> » s a) : «expr ~> » (parallel S) a :=\n  fun a' ma' =>\n  let ⟨c, cs, ac⟩ := exists_of_mem_parallel ma'\n  H _ cs ac\n#align parallel_promises parallel_promises\n\n",
 "parallel_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\ntheorem parallel_empty (S : WSeq (Computation α)) (h : «expr ~> » S.head none) : parallel S = empty _ :=\n  eq_empty_of_not_terminates fun ⟨⟨a, m⟩⟩ =>\n    by\n    let ⟨c, cs, ac⟩ := exists_of_mem_parallel m\n    let ⟨n, nm⟩ := WSeq.exists_get?_of_mem cs\n    let ⟨c', h'⟩ := WSeq.head_some_of_get?_some nm\n    injection h h'\n#align parallel_empty parallel_empty\n\n",
 "parallel_congr_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem parallel_congr_right {S T : WSeq (Computation α)} {a} (h2 : ∀ t ∈ T, «expr ~> » t a) (H : S.lift_rel Equiv T) :\n    equiv (parallel S) (parallel T) :=\n  parallel_congr_left ((parallel_congr_lem H).2 h2) H\n#align parallel_congr_right parallel_congr_right\n\n",
 "parallel_congr_lem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\ntheorem parallel_congr_lem {S T : WSeq (Computation α)} {a} (H : S.lift_rel Equiv T) :\n    (∀ s ∈ S, «expr ~> » s a) ↔ ∀ t ∈ T, «expr ~> » t a :=\n  ⟨fun h1 t tT =>\n    let ⟨s, sS, se⟩ := WSeq.exists_of_liftRel_right H tT\n    (promises_congr se _).1 (h1 _ sS),\n    fun h2 s sS =>\n    let ⟨t, tT, se⟩ := WSeq.exists_of_liftRel_left H sS\n    (promises_congr se _).2 (h2 _ tT)⟩\n#align parallel_congr_lem parallel_congr_lem\n\n",
 "parallel_congr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n-- The parallel operation is only deterministic when all computation paths lead to the same value\ntheorem parallel_congr_left {S T : WSeq (Computation α)} {a} (h1 : ∀ s ∈ S, «expr ~> » s a) (H : S.lift_rel Equiv T) :\n    equiv (parallel S) (parallel T) :=\n  let h2 := (parallel_congr_lem H).1 h1\n  fun a' =>\n  ⟨fun h => by\n    have aa := parallel_promises h1 h <;> rw [← aa] <;> rw [← aa] at h <;>\n      exact\n        let ⟨s, sS, as⟩ := exists_of_mem_parallel h\n        let ⟨t, tT, st⟩ := wseq.exists_of_lift_rel_left H sS\n        let aT := (st _).1 as\n        mem_parallel h2 tT aT,\n    fun h => by\n    have aa := parallel_promises h2 h <;> rw [← aa] <;> rw [← aa] at h <;>\n      exact\n        let ⟨s, sS, as⟩ := exists_of_mem_parallel h\n        let ⟨t, tT, st⟩ := wseq.exists_of_lift_rel_right H sS\n        let aT := (st _).2 as\n        mem_parallel h1 tT aT⟩\n#align parallel_congr_left parallel_congr_left\n\n",
 "mem_parallel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ~> » -/\ntheorem mem_parallel {S : WSeq (Computation α)} {a} (H : ∀ s ∈ S, «expr ~> » s a) {c} (cs : c ∈ S) (ac : a ∈ c) :\n    a ∈ parallel S := by\n  haveI := terminates_of_mem ac <;> haveI := terminates_parallel cs <;> exact mem_of_promises _ (parallel_promises H)\n#align mem_parallel mem_parallel\n\n",
 "map_parallel":
 "theorem map_parallel (f : α → β) (S) : map f (parallel S) = parallel (S.map (map f)) :=\n  by\n  refine'\n    eq_of_bisim\n      (fun c1 c2 =>\n        ∃ l S, c1 = map f (corec parallel.aux1 (l, S)) ∧ c2 = corec parallel.aux1 (l.map (map f), S.map (map f)))\n      _ ⟨[], S, rfl, rfl⟩\n  intro c1 c2 h;\n  exact\n    match c1, c2, h with\n    | _, _, ⟨l, S, rfl, rfl⟩ => by\n      clear _match\n      have : parallel.aux2 (l.map (map f)) = lmap f (rmap (list.map (map f)) (parallel.aux2 l)) :=\n        by\n        simp [parallel.aux2]\n        induction' l with c l IH <;> simp\n        rw [IH]\n        cases list.foldr parallel.aux2._match_1 (Sum.inr List.nil) l <;> simp [parallel.aux2]\n        cases destruct c <;> simp\n      simp [parallel.aux1]\n      rw [this]\n      cases' parallel.aux2 l with a l' <;> simp\n      apply S.rec_on _ (fun c S => _) fun S => _ <;> simp <;> simp [parallel.aux1] <;> exact ⟨_, _, rfl, rfl⟩\n#align map_parallel map_parallel\n\n",
 "exists_of_mem_parallel":
 "theorem exists_of_mem_parallel {S : WSeq (Computation α)} {a} (h : a ∈ parallel S) : ∃ c ∈ S, a ∈ c :=\n  by\n  suffices ∀ C, a ∈ C → ∀ (l : List (Computation α)) (S), corec parallel.aux1 (l, S) = C → ∃ c, (c ∈ l ∨ c ∈ S) ∧ a ∈ c\n    from\n    let ⟨c, h1, h2⟩ := this _ h [] S rfl\n    ⟨c, h1.resolve_left id, h2⟩\n  let F : List (Computation α) → Sum α (List (Computation α)) → Prop :=\n    by\n    intro l a\n    cases' a with a l'\n    exact ∃ c ∈ l, a ∈ c\n    exact ∀ a', (∃ c ∈ l', a' ∈ c) → ∃ c ∈ l, a' ∈ c\n  have lem1 : ∀ l : List (Computation α), F l (parallel.aux2 l) :=\n    by\n    intro l\n    induction' l with c l IH <;> simp [parallel.aux2]\n    · intro a h\n      rcases h with ⟨c, hn, _⟩\n      exact false.elim hn\n    · simp [parallel.aux2] at IH\n      cases' list.foldr parallel.aux2._match_1 (Sum.inr List.nil) l with a ls <;> simp [parallel.aux2]\n      · rcases IH with ⟨c', cl, ac⟩\n        refine' ⟨c', or.inr cl, ac⟩\n      · induction' h : destruct c with a c' <;> simp [rmap]\n        · refine' ⟨c, list.mem_cons_self _ _, _⟩\n          rw [destruct_eq_ret h]\n          apply ret_mem\n        · intro a' h\n          rcases h with ⟨d, dm, ad⟩\n          simp at dm\n          cases' dm with e dl\n          · rw [e] at ad\n            refine' ⟨c, list.mem_cons_self _ _, _⟩\n            rw [destruct_eq_think h]\n            exact think_mem ad\n          · cases' IH a' ⟨d, dl, ad⟩ with d dm\n            cases' dm with dm ad\n            exact ⟨d, or.inr dm, ad⟩\n  intro C aC\n  refine' mem_rec_on aC _ fun C' IH => _ <;> intro l S e <;> have e' := congr_arg destruct e <;> have := lem1 l <;>\n        simp [parallel.aux1] at e' <;>\n      cases' parallel.aux2 l with a' l' <;>\n    injection e' with h'\n  · rw [h'] at this\n    rcases this with ⟨c, cl, ac⟩\n    exact ⟨c, or.inl cl, ac⟩\n  · induction' e : seq.destruct S with a <;> rw [e] at h'\n    ·\n      exact\n        let ⟨d, o, ad⟩ := IH _ _ h'\n        let ⟨c, cl, ac⟩ := this a ⟨d, o.resolve_right (wseq.not_mem_nil _), ad⟩\n        ⟨c, or.inl cl, ac⟩\n    · cases' a with o S'\n      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with ⟨d, dl | dS', ad⟩\n      ·\n        exact\n          let ⟨c, cl, ac⟩ := this a ⟨d, dl, ad⟩\n          ⟨c, or.inl cl, ac⟩\n      · refine' ⟨d, or.inr _, ad⟩\n        rw [seq.destruct_eq_cons e]\n        exact seq.mem_cons_of_mem _ dS'\n      · simp at dl\n        cases' dl with dc dl\n        · rw [dc] at ad\n          refine' ⟨c, or.inr _, ad⟩\n          rw [seq.destruct_eq_cons e]\n          apply seq.mem_cons\n        ·\n          exact\n            let ⟨c, cl, ac⟩ := this a ⟨d, dl, ad⟩\n            ⟨c, or.inl cl, ac⟩\n      · refine' ⟨d, or.inr _, ad⟩\n        rw [seq.destruct_eq_cons e]\n        exact seq.mem_cons_of_mem _ dS'\n#align exists_of_mem_parallel exists_of_mem_parallel\n\n",
 "aux":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n\nParallel computation of a computable sequence of computations by\na diagonal enumeration.\nThe important theorems of this operation are proven as\nterminates_parallel and exists_of_mem_parallel.\n(This operation is nondeterministic in the sense that it does not\nhonor sequence equivalence (irrelevance of computation time).)\n-/\ntheorem terminates_parallel.aux :\n    ∀ {l : List (Computation α)} {S c}, c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) :=\n  by\n  have lem1 : ∀ l S, (∃ a : α, parallel.aux2 l = Sum.inl a) → terminates (corec parallel.aux1 (l, S)) :=\n    by\n    intro l S e\n    cases' e with a e\n    have : corec parallel.aux1 (l, S) = return a :=\n      by\n      apply destruct_eq_ret\n      simp [parallel.aux1]\n      rw [e]\n      simp [rmap]\n    rw [this]\n    infer_instance\n  intro l S c m T\n  revert l S\n  apply @terminates_rec_on _ _ c T _ _\n  · intro a l S m\n    apply lem1\n    induction' l with c l IH generalizing m <;> simp at m\n    · contradiction\n    cases' m with e m\n    · rw [← e]\n      simp [parallel.aux2]\n      cases' list.foldr parallel.aux2._match_1 (Sum.inr List.nil) l with a' ls\n      exacts[⟨a', rfl⟩, ⟨a, rfl⟩]\n    · cases' IH m with a' e\n      simp [parallel.aux2]\n      simp [parallel.aux2] at e\n      rw [e]\n      exact ⟨a', rfl⟩\n  · intro s IH l S m\n    have H1 : ∀ l', parallel.aux2 l = Sum.inr l' → s ∈ l' :=\n      by\n      induction' l with c l IH' generalizing m <;> intro l' e' <;> simp at m\n      · contradiction\n      cases' m with e m <;> simp [parallel.aux2] at e'\n      · rw [← e] at e'\n        cases' list.foldr parallel.aux2._match_1 (Sum.inr List.nil) l with a' ls <;> injection e' with e'\n        rw [← e']\n        simp\n      · induction' e : list.foldr parallel.aux2._match_1 (Sum.inr List.nil) l with a' ls <;> rw [e] at e'\n        · contradiction\n        have := IH' m _ e\n        simp [parallel.aux2] at e'\n        cases destruct c <;> injection e' with h'\n        rw [← h']\n        simp [this]\n    induction' h : parallel.aux2 l with a l'\n    · exact lem1 _ _ ⟨a, h⟩\n    · have H2 : corec parallel.aux1 (l, S) = think _ :=\n        by\n        apply destruct_eq_think\n        simp [parallel.aux1]\n        rw [h]\n        simp [rmap]\n      rw [H2]\n      apply @Computation.think_terminates _ _ _\n      have := H1 _ h\n      rcases seq.destruct S with (_ | ⟨_ | c, S'⟩) <;> simp [parallel.aux1] <;> apply IH <;> simp [this]\n#align terminates_parallel.aux terminates_parallel.aux\n\n"}