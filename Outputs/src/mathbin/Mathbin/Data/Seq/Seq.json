{"val_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n/-\ncoinductive seq (α : Type u) : Type u\n| nil : seq α\n| cons : α → seq α → seq α\n-/\n@[simp]\ntheorem val_cons (s : seq α) (x : α) : (cons x s).val = stream.cons (some x) s.val :=\n  rfl\n#align val_cons val_cons\n\n",
 "terminated_stable":
 "/-- If a sequence terminated at position `n`, it also terminated at `m ≥ n `. -/\ntheorem terminated_stable : ∀ (s : seq α) {m n : ℕ}, m ≤ n → s.terminated_at m → s.terminated_at n :=\n  le_stable\n#align terminated_stable terminated_stable\n\n",
 "tail_nil":
 "@[simp]\ntheorem tail_nil : tail (nil : seq α) = nil :=\n  rfl\n#align tail_nil tail_nil\n\n",
 "tail_cons":
 "@[simp]\ntheorem tail_cons (a : α) (s) : tail (cons a s) = s := by\n  cases' s with f al <;> apply subtype.eq <;> dsimp [tail, cons] <;> rw [Stream'.tail_cons]\n#align tail_cons tail_cons\n\n",
 "ret_bind":
 "@[simp]\ntheorem ret_bind (a : α) (f : α → seq1 β) : bind (ret a) f = f a :=\n  by\n  simp [ret, bind, map]\n  cases' f a with a s\n  apply rec_on s <;> intros <;> simp\n#align ret_bind ret_bind\n\n",
 "of_stream_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n@[simp]\ntheorem of_stream_cons (a : α) (s) : of_stream (stream.cons a s) = cons a (of_stream s) := by\n  apply subtype.eq <;> simp [of_stream, cons] <;> rw [Stream'.map_cons]\n#align of_stream_cons of_stream_cons\n\n",
 "of_stream_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ++ₛ » -/\n@[simp]\ntheorem of_stream_append (l : list α) (s : Stream' α) :\n    of_stream («expr ++ₛ » l s) = append (of_list l) (of_stream s) := by\n  induction l <;> simp [*, Stream'.nil_append_stream, Stream'.cons_append_stream]\n#align of_stream_append of_stream_append\n\n",
 "of_mem_append":
 "theorem of_mem_append {s₁ s₂ : seq α} {a : α} (h : a ∈ append s₁ s₂) : a ∈ s₁ ∨ a ∈ s₂ :=\n  by\n  have := h; revert this\n  generalize e : append s₁ s₂ = ss; intro h; revert s₁\n  apply mem_rec_on h _\n  intro b s' o s₁\n  apply s₁.rec_on _ fun c t₁ => _ <;> intro m e <;> have := congr_arg destruct e\n  · apply or.inr\n    simpa using m\n  · cases' show a = c ∨ a ∈ append t₁ s₂ by simpa using m with e' m\n    · rw [e']\n      exact or.inl (mem_cons _ _)\n    · cases' show c = b ∧ append t₁ s₂ = s' by simpa with i1 i2\n      cases' o with e' IH\n      · simp [i1, e']\n      · exact or.imp_left (mem_cons_of_mem _) (IH m i2)\n#align of_mem_append of_mem_append\n\n",
 "of_list_nth":
 "@[simp]\ntheorem of_list_nth (l : list α) (n : ℕ) : (of_list l).nth n = l.nth n :=\n  rfl\n#align of_list_nth of_list_nth\n\n",
 "of_list_nil":
 "@[simp]\ntheorem of_list_nil : of_list [] = (nil : seq α) :=\n  rfl\n#align of_list_nil of_list_nil\n\n",
 "of_list_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n@[simp]\ntheorem of_list_cons (a : α) (l : list α) : of_list (stream.cons a l) = cons a (of_list l) := by ext1 (_ | n) <;> rfl\n#align of_list_cons of_list_cons\n\n",
 "of_list_append":
 "@[simp]\ntheorem of_list_append (l l' : list α) : of_list (l ++ l') = append (of_list l) (of_list l') := by\n  induction l <;> simp [*]\n#align of_list_append of_list_append\n\n",
 "nth_zip_with":
 "@[simp]\ntheorem nth_zip_with (f : α → β → γ) (s s' n) : (zip_with f s s').nth n = Option.map₂ f (s.nth n) (s'.nth n) :=\n  rfl\n#align nth_zip_with nth_zip_with\n\n",
 "nth_zip":
 "theorem nth_zip (s : seq α) (t : seq β) (n : ℕ) : nth (zip s t) n = Option.map₂ prod.mk (nth s n) (nth t n) :=\n  nth_zip_with _ _ _ _\n#align nth_zip nth_zip\n\n",
 "nth_tail":
 "@[simp]\ntheorem nth_tail (s : seq α) (n) : nth (tail s) n = nth s (n + 1) :=\n  rfl\n#align nth_tail nth_tail\n\n",
 "nth_nil":
 "@[simp]\ntheorem nth_nil (n : ℕ) : (@nil α).nth n = none :=\n  rfl\n#align nth_nil nth_nil\n\n",
 "nth_mk":
 "@[simp]\ntheorem nth_mk (f hf) : @nth α ⟨f, hf⟩ = f :=\n  rfl\n#align nth_mk nth_mk\n\n",
 "nth_enum":
 "@[simp]\ntheorem nth_enum (s : seq α) (n : ℕ) : nth (enum s) n = option.map (prod.mk n) (nth s n) :=\n  nth_zip _ _ _\n#align nth_enum nth_enum\n\n",
 "nth_cons_zero":
 "@[simp]\ntheorem nth_cons_zero (a : α) (s : seq α) : (cons a s).nth 0 = some a :=\n  rfl\n#align nth_cons_zero nth_cons_zero\n\n",
 "nth_cons_succ":
 "@[simp]\ntheorem nth_cons_succ (a : α) (s : seq α) (n : ℕ) : (cons a s).nth (n + 1) = s.nth n :=\n  rfl\n#align nth_cons_succ nth_cons_succ\n\n",
 "not_terminates_iff":
 "theorem not_terminates_iff {s : seq α} : ¬s.terminates ↔ ∀ n, (s.nth n).is_some := by\n  simp [terminates, terminated_at, ← ne.def, Option.ne_none_iff_isSome]\n#align not_terminates_iff not_terminates_iff\n\n",
 "not_mem_nil":
 "theorem not_mem_nil (a : α) : a ∉ @nil α := fun ⟨n, (h : some a = none)⟩ => by injection h\n#align not_mem_nil not_mem_nil\n\n",
 "nil_append":
 "@[simp]\ntheorem nil_append (s : seq α) : append nil s = s :=\n  by\n  apply coinduction2; intro s\n  dsimp [append]; rw [corec_eq]\n  dsimp [append]; apply rec_on s _ _\n  · trivial\n  · intro x s\n    rw [destruct_cons]\n    dsimp\n    exact ⟨rfl, s, rfl, rfl⟩\n#align nil_append nil_append\n\n",
 "nats_nth":
 "@[simp]\ntheorem nats_nth (n : ℕ) : nats.nth n = some n :=\n  rfl\n#align nats_nth nats_nth\n\n",
 "mem_rec_on":
 "theorem mem_rec_on {C : seq α → Prop} {a s} (M : a ∈ s) (h1 : ∀ b s', a = b ∨ C s' → C (cons b s')) : C s :=\n  by\n  cases' M with k e; unfold Stream'.nth at e\n  induction' k with k IH generalizing s\n  · have TH : s = cons a (tail s) := by\n      apply destruct_eq_cons\n      unfold destruct nth functor.map\n      rw [← e]\n      rfl\n    rw [TH]\n    apply h1 _ _ (or.inl rfl)\n  revert e; apply s.rec_on _ fun b s' => _ <;> intro e\n  · injection e\n  · have h_eq : (cons b s').val (nat.succ k) = s'.val k := by cases s' <;> rfl\n    rw [h_eq] at e\n    apply h1 _ _ (or.inr (IH e))\n#align mem_rec_on mem_rec_on\n\n",
 "mem_map":
 "theorem mem_map (f : α → β) {a : α} : ∀ {s : seq α}, a ∈ s → f a ∈ map f s\n  | ⟨g, al⟩ => Stream'.mem_map (option.map f)\n#align mem_map mem_map\n\n",
 "mem_cons_of_mem":
 "theorem mem_cons_of_mem (y : α) {a : α} : ∀ {s : seq α}, a ∈ s → a ∈ cons y s\n  | ⟨f, al⟩ => Stream'.mem_cons_of_mem (some y)\n#align mem_cons_of_mem mem_cons_of_mem\n\n",
 "mem_cons_iff":
 "@[simp]\ntheorem mem_cons_iff {a b : α} {s : seq α} : a ∈ cons b s ↔ a = b ∨ a ∈ s :=\n  ⟨eq_or_mem_of_mem_cons, by rintro (rfl | m) <;> [apply mem_cons, exact mem_cons_of_mem _ m]⟩\n#align mem_cons_iff mem_cons_iff\n\n",
 "mem_cons":
 "theorem mem_cons (a : α) : ∀ s : seq α, a ∈ cons a s\n  | ⟨f, al⟩ => Stream'.mem_cons (some a) _\n#align mem_cons mem_cons\n\n",
 "mem_append_left":
 "theorem mem_append_left {s₁ s₂ : seq α} {a : α} (h : a ∈ s₁) : a ∈ append s₁ s₂ := by\n  apply mem_rec_on h <;> intros <;> simp [*]\n#align mem_append_left mem_append_left\n\n",
 "map_tail":
 "@[simp]\ntheorem map_tail (f : α → β) : ∀ s, map f (tail s) = tail (map f s)\n  | ⟨s, al⟩ => by apply subtype.eq <;> dsimp [tail, map] <;> rw [Stream'.map_tail] <;> rfl\n#align map_tail map_tail\n\n",
 "map_nth":
 "@[simp]\ntheorem map_nth (f : α → β) : ∀ s n, nth (map f s) n = (nth s n).map f\n  | ⟨s, al⟩, n => rfl\n#align map_nth map_nth\n\n",
 "map_nil":
 "@[simp]\ntheorem map_nil (f : α → β) : map f nil = nil :=\n  rfl\n#align map_nil map_nil\n\n",
 "map_join'":
 "@[simp]\ntheorem map_join' (f : α → β) (S) : seq.map f (seq.join S) = seq.join (seq.map (map f) S) :=\n  by\n  apply\n    eq_of_bisim fun s1 s2 =>\n      ∃ s S, s1 = append s (seq.map f (seq.join S)) ∧ s2 = append s (seq.join (seq.map (map f) S))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, S, rfl, rfl⟩ => by\n        apply rec_on s <;> simp\n        · apply rec_on S <;> simp\n          · intro x S\n            cases' x with a s <;> simp [map]\n            exact ⟨_, _, rfl, rfl⟩\n        · intro x s\n          refine' ⟨s, S, rfl, rfl⟩\n  · refine' ⟨nil, S, _, _⟩ <;> simp\n#align map_join' map_join'\n\n",
 "map_join":
 "@[simp]\ntheorem map_join (f : α → β) : ∀ S, map f (join S) = join (map (map f) S)\n  | ((a, s), S) => by apply rec_on s <;> intros <;> simp [map]\n#align map_join map_join\n\n",
 "map_id":
 "theorem map_id : ∀ s : seq1 α, map id s = s\n  | ⟨a, s⟩ => by simp [map]\n#align map_id map_id\n\n",
 "map_cons":
 "@[simp]\ntheorem map_cons (f : α → β) (a) : ∀ s, map f (cons a s) = cons (f a) (map f s)\n  | ⟨s, al⟩ => by apply subtype.eq <;> dsimp [cons, map] <;> rw [Stream'.map_cons] <;> rfl\n#align map_cons map_cons\n\n",
 "map_comp":
 "theorem map_comp (f : α → β) (g : β → γ) : ∀ s : seq α, map (g ∘ f) s = map g (map f s)\n  | ⟨s, al⟩ => by\n    apply subtype.eq <;> dsimp [map]\n    rw [Stream'.map_map]\n    apply congr_arg fun f : _ → option γ => Stream'.map f s\n    ext ⟨⟩ <;> rfl\n#align map_comp map_comp\n\n",
 "map_append":
 "@[simp]\ntheorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) :=\n  by\n  apply eq_of_bisim (fun s1 s2 => ∃ s t, s1 = map f (append s t) ∧ s2 = append (map f s) (map f t)) _ ⟨s, t, rfl, rfl⟩\n  intro s1 s2 h;\n  exact\n    match s1, s2, h with\n    | _, _, ⟨s, t, rfl, rfl⟩ => by\n      apply rec_on s <;> simp\n      · apply rec_on t <;> simp\n        · intro x t\n          refine' ⟨nil, t, _, _⟩ <;> simp\n      · intro x s\n        refine' ⟨s, t, rfl, rfl⟩\n#align map_append map_append\n\n",
 "le_stable":
 "theorem le_stable (s : seq α) {m n} (h : m ≤ n) : s.nth m = none → s.nth n = none :=\n  by\n  cases' s with f al\n  induction' h with n h IH\n  exacts[id, fun h2 => al (IH h2)]\n#align le_stable le_stable\n\n",
 "join_nil":
 "@[simp]\ntheorem join_nil (a : α) (S) : join ((a, nil), S) = (a, seq.join S) :=\n  rfl\n#align join_nil join_nil\n\n",
 "join_map_ret":
 "@[simp]\ntheorem join_map_ret (s : seq α) : seq.join (seq.map ret s) = s := by\n  apply coinduction2 s <;> intro s <;> apply rec_on s <;> simp [ret]\n#align join_map_ret join_map_ret\n\n",
 "join_join":
 "@[simp]\ntheorem join_join (SS : seq (seq1 (seq1 α))) : seq.join (seq.join SS) = seq.join (seq.map join SS) :=\n  by\n  apply\n    eq_of_bisim fun s1 s2 =>\n      ∃ s SS, s1 = seq.append s (seq.join (seq.join SS)) ∧ s2 = seq.append s (seq.join (seq.map join SS))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, SS, rfl, rfl⟩ => by\n        apply rec_on s <;> simp\n        · apply rec_on SS <;> simp\n          · intro S SS\n            cases' S with s S <;> cases' s with x s <;> simp [map]\n            apply rec_on s <;> simp\n            · exact ⟨_, _, rfl, rfl⟩\n            · intro x s\n              refine' ⟨cons x (append s (seq.join S)), SS, _, _⟩ <;> simp\n        · intro x s\n          exact ⟨s, SS, rfl, rfl⟩\n  · refine' ⟨nil, SS, _, _⟩ <;> simp\n#align join_join join_join\n\n",
 "join_cons_nil":
 "@[simp]\ntheorem join_cons_nil (a : α) (S) : join (cons (a, nil) S) = cons a (join S) :=\n  destruct_eq_cons <| by simp [join]\n#align join_cons_nil join_cons_nil\n\n",
 "join_cons_cons":
 "@[simp]\ntheorem join_cons_cons (a b : α) (s S) : join (cons (a, cons b s) S) = cons a (join (cons (b, s) S)) :=\n  destruct_eq_cons <| by simp [join]\n#align join_cons_cons join_cons_cons\n\n",
 "join_cons":
 "@[simp]\ntheorem join_cons (a b : α) (s S) : join ((a, cons b s), S) = (a, seq.join (cons (b, s) S)) := by\n  dsimp [join] <;> rw [destruct_cons] <;> rfl\n#align join_cons join_cons\n\n",
 "join_append":
 "@[simp]\ntheorem join_append (S T : seq (seq1 α)) : join (append S T) = append (join S) (join T) :=\n  by\n  apply eq_of_bisim fun s1 s2 => ∃ s S T, s1 = append s (join (append S T)) ∧ s2 = append s (append (join S) (join T))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, S, T, rfl, rfl⟩ => by\n        apply rec_on s <;> simp\n        · apply rec_on S <;> simp\n          · apply rec_on T\n            · simp\n            · intro s T\n              cases' s with a s <;> simp\n              refine' ⟨s, nil, T, _, _⟩ <;> simp\n          · intro s S\n            cases' s with a s <;> simp\n            exact ⟨s, S, T, rfl, rfl⟩\n        · intro x s\n          exact ⟨s, S, T, rfl, rfl⟩\n  · refine' ⟨nil, S, T, _, _⟩ <;> simp\n#align join_append join_append\n\n",
 "head_nil":
 "@[simp]\ntheorem head_nil : head (nil : seq α) = none :=\n  rfl\n#align head_nil head_nil\n\n",
 "head_eq_destruct":
 "theorem head_eq_destruct (s : seq α) : head s = prod.fst <$> destruct s := by\n  unfold destruct head <;> cases nth s 0 <;> rfl\n#align head_eq_destruct head_eq_destruct\n\n",
 "head_dropn":
 "@[simp]\ntheorem head_dropn (s : seq α) (n) : head (drop s n) = nth s n :=\n  by\n  induction' n with n IH generalizing s; · rfl\n  rw [nat.succ_eq_add_one, ← nth_tail, ← dropn_tail]; apply IH\n#align head_dropn head_dropn\n\n",
 "head_cons":
 "@[simp]\ntheorem head_cons (a : α) (s) : head (cons a s) = some a := by rw [head_eq_destruct, destruct_cons] <;> rfl\n#align head_cons head_cons\n\n",
 "ge_stable":
 "/-- If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such\nthat `s.nth = some aₘ` for `m ≤ n`.\n-/\ntheorem ge_stable (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = some aₙ) :\n    ∃ aₘ : α, s.nth m = some aₘ :=\n  have : s.nth n ≠ none := by simp [s_nth_eq_some]\n  have : s.nth m ≠ none := mt (s.le_stable m_le_n) this\n  option.ne_none_iff_exists'.mp this\n#align ge_stable ge_stable\n\n",
 "ext":
 "@[ext]\nprotected theorem ext {s t : seq α} (h : ∀ n : ℕ, s.nth n = t.nth n) : s = t :=\n  subtype.eq <| funext h\n#align ext ext\n\n",
 "exists_of_mem_map":
 "theorem exists_of_mem_map {f} {b : β} : ∀ {s : seq α}, b ∈ map f s → ∃ a, a ∈ s ∧ f a = b\n  | ⟨g, al⟩, h => by\n    let ⟨o, om, oe⟩ := Stream'.exists_of_mem_map h\n    cases' o with a <;> injection oe with h' <;> exact ⟨a, om, h'⟩\n#align exists_of_mem_map exists_of_mem_map\n\n",
 "eq_or_mem_of_mem_cons":
 "theorem eq_or_mem_of_mem_cons {a b : α} : ∀ {s : seq α}, a ∈ cons b s → a = b ∨ a ∈ s\n  | ⟨f, al⟩, h => (Stream'.eq_or_mem_of_mem_cons h).imp_left fun h => by injection h\n#align eq_or_mem_of_mem_cons eq_or_mem_of_mem_cons\n\n",
 "eq_of_bisim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `R -/\n-- If two streams are bisimilar, then they are equal\ntheorem eq_of_bisim (bisim : is_bisimulation R) {s₁ s₂} (r : R s₁ s₂) : s₁ = s₂ :=\n  by\n  apply subtype.eq\n  apply Stream'.eq_of_bisim fun x y => ∃ s s' : seq α, s.1 = x ∧ s'.1 = y ∧ R s s'\n  dsimp [Stream'.IsBisimulation]\n  intro t₁ t₂ e\n  exact\n    match t₁, t₂, e with\n    | _, _, ⟨s, s', rfl, rfl, r⟩ =>\n      by\n      suffices head s = head s' ∧ R (tail s) (tail s') from\n        and.imp id (fun r => ⟨tail s, tail s', by cases s <;> rfl, by cases s' <;> rfl, r⟩) this\n      have := bisim r; revert r this\n      apply rec_on s _ _ <;> intros <;> apply rec_on s' _ _ <;> intros <;> intro r this\n      · constructor\n        rfl\n        assumption\n      · rw [destruct_nil, destruct_cons] at this\n        exact false.elim this\n      · rw [destruct_nil, destruct_cons] at this\n        exact false.elim this\n      · rw [destruct_cons, destruct_cons] at this\n        rw [head_cons, head_cons, tail_cons, tail_cons]\n        cases' this with h1 h2\n        constructor\n        rw [h1]\n        exact h2\n  exact ⟨s₁, s₂, rfl, rfl, r⟩\n#align eq_of_bisim eq_of_bisim\n\n",
 "enum_nil":
 "@[simp]\ntheorem enum_nil : enum (nil : seq α) = nil :=\n  rfl\n#align enum_nil enum_nil\n\n",
 "enum_cons":
 "@[simp]\ntheorem enum_cons (s : seq α) (x : α) : enum (cons x s) = cons (0, x) (map (prod.map nat.succ id) (enum s)) :=\n  by\n  ext ⟨n⟩ : 1\n  · simp\n  · simp only [nth_enum, nth_cons_succ, map_nth, option.map_map]\n    congr\n#align enum_cons enum_cons\n\n",
 "dropn_tail":
 "theorem dropn_tail (s : seq α) (n) : drop (tail s) n = drop s (n + 1) := by rw [add_comm] <;> symm <;> apply dropn_add\n#align dropn_tail dropn_tail\n\n",
 "dropn_add":
 "theorem dropn_add (s : seq α) (m) : ∀ n, drop s (m + n) = drop (drop s m) n\n  | 0 => rfl\n  | n + 1 => congr_arg tail (dropn_add n)\n#align dropn_add dropn_add\n\n",
 "destruct_nil":
 "@[simp]\ntheorem destruct_nil : destruct (nil : seq α) = none :=\n  rfl\n#align destruct_nil destruct_nil\n\n",
 "destruct_eq_nil":
 "theorem destruct_eq_nil {s : seq α} : destruct s = none → s = nil :=\n  by\n  dsimp [destruct]\n  induction' f0 : nth s 0 with <;> intro h\n  · apply subtype.eq\n    funext n\n    induction' n with n IH\n    exacts[f0, s.2 IH]\n  · contradiction\n#align destruct_eq_nil destruct_eq_nil\n\n",
 "destruct_eq_cons":
 "/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers [] [] [] [] [] [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `destruct_eq_cons [])\n      (Command.declSig\n       [(Term.implicitBinder \"{\" [`s] [\":\" (Term.app `seq [`α])] \"}\") (Term.implicitBinder \"{\" [`a `s'] [] \"}\")]\n       (Term.typeSpec\n        \":\"\n        (Term.arrow\n         («term_=_» (Term.app `destruct [`s]) \"=\" (Term.app `some [(Term.tuple \"(\" [`a \",\" [`s']] \")\")]))\n         \"→\"\n         («term_=_» `s \"=\" (Term.app `cons [`a `s'])))))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.dsimp \"dsimp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `destruct)] \"]\"] [])\n           []\n           (Tactic.«tactic_<;>_»\n            (Tactic.induction'\n             \"induction'\"\n             [(Tactic.casesTarget [`f0 \":\"] (Term.app `nth [`s (num \"0\")]))]\n             []\n             [\"with\" [(Lean.binderIdent `a')]]\n             [])\n            \"<;>\"\n            (Tactic.intro \"intro\" [`h]))\n           []\n           (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.contradiction \"contradiction\")])\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.cases'\n              \"cases'\"\n              [(Tactic.casesTarget [] `s)]\n              []\n              [\"with\" [(Lean.binderIdent `f) (Lean.binderIdent `al)]])\n             []\n             (Tactic.injections \"injections\" [\"_\" `h1 `h2])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `h2)] \"]\")\n              [])\n             []\n             (Tactic.apply \"apply\" `subtype.eq)\n             []\n             (Tactic.dsimp\n              \"dsimp\"\n              []\n              []\n              []\n              [\"[\" [(Tactic.simpLemma [] [] `tail) \",\" (Tactic.simpLemma [] [] `cons)] \"]\"]\n              [])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `h1)] \"]\")\n              [(Tactic.location \"at\" (Tactic.locationHyp [`f0] []))])\n             []\n             (Tactic.rwSeq\n              \"rw\"\n              []\n              (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `f0)] \"]\")\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.proj (Term.app `Stream'.eta [`f]) \".\" `symm))])])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.dsimp \"dsimp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `destruct)] \"]\"] [])\n          []\n          (Tactic.«tactic_<;>_»\n           (Tactic.induction'\n            \"induction'\"\n            [(Tactic.casesTarget [`f0 \":\"] (Term.app `nth [`s (num \"0\")]))]\n            []\n            [\"with\" [(Lean.binderIdent `a')]]\n            [])\n           \"<;>\"\n           (Tactic.intro \"intro\" [`h]))\n          []\n          (tactic__ (cdotTk (patternIgnore (token.«· » \"·\"))) [(Tactic.contradiction \"contradiction\")])\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.cases'\n             \"cases'\"\n             [(Tactic.casesTarget [] `s)]\n             []\n             [\"with\" [(Lean.binderIdent `f) (Lean.binderIdent `al)]])\n            []\n            (Tactic.injections \"injections\" [\"_\" `h1 `h2])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `h2)] \"]\")\n             [])\n            []\n            (Tactic.apply \"apply\" `subtype.eq)\n            []\n            (Tactic.dsimp\n             \"dsimp\"\n             []\n             []\n             []\n             [\"[\" [(Tactic.simpLemma [] [] `tail) \",\" (Tactic.simpLemma [] [] `cons)] \"]\"]\n             [])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `h1)] \"]\")\n             [(Tactic.location \"at\" (Tactic.locationHyp [`f0] []))])\n            []\n            (Tactic.rwSeq\n             \"rw\"\n             []\n             (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `f0)] \"]\")\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.proj (Term.app `Stream'.eta [`f]) \".\" `symm))])])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Tactic.cases' \"cases'\" [(Tactic.casesTarget [] `s)] [] [\"with\" [(Lean.binderIdent `f) (Lean.binderIdent `al)]])\n        []\n        (Tactic.injections \"injections\" [\"_\" `h1 `h2])\n        []\n        (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `h2)] \"]\") [])\n        []\n        (Tactic.apply \"apply\" `subtype.eq)\n        []\n        (Tactic.dsimp \"dsimp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `tail) \",\" (Tactic.simpLemma [] [] `cons)] \"]\"] [])\n        []\n        (Tactic.rwSeq\n         \"rw\"\n         []\n         (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `h1)] \"]\")\n         [(Tactic.location \"at\" (Tactic.locationHyp [`f0] []))])\n        []\n        (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `f0)] \"]\") [])\n        []\n        (Tactic.exact \"exact\" (Term.proj (Term.app `Stream'.eta [`f]) \".\" `symm))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.proj (Term.app `Stream'.eta [`f]) \".\" `symm))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.proj (Term.app `Stream'.eta [`f]) \".\" `symm)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1024, term))\n      (Term.app `Stream'.eta [`f])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `f\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `Stream'.eta\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (some 1024, term)\n[PrettyPrinter.parenthesize] parenthesized: (Term.paren \"(\" (Term.app `Stream'.eta [`f]) \")\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `f0)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `f0\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq\n       \"rw\"\n       []\n       (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [] `h1)] \"]\")\n       [(Tactic.location \"at\" (Tactic.locationHyp [`f0] []))])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.locationHyp', expected 'Lean.Parser.Tactic.locationWildcard'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `f0\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h1\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.dsimp \"dsimp\" [] [] [] [\"[\" [(Tactic.simpLemma [] [] `tail) \",\" (Tactic.simpLemma [] [] `cons)] \"]\"] [])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `cons\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.simpLemma', expected 'Lean.Parser.Tactic.simpErase'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `tail\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.apply \"apply\" `subtype.eq)\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `subtype.eq\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.rwSeq \"rw\" [] (Tactic.rwRuleSeq \"[\" [(Tactic.rwRule [(patternIgnore (token.«← » \"←\"))] `h2)] \"]\") [])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `h2\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.injections \"injections\" [\"_\" `h1 `h2])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'ident'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '_', expected 'Lean.Parser.Term.hole'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\ntheorem\n  destruct_eq_cons\n  { s : seq α } { a s' } : destruct s = some ( a , s' ) → s = cons a s'\n  :=\n    by\n      dsimp [ destruct ]\n        induction' f0 : nth s 0 with a' <;> intro h\n        · contradiction\n        ·\n          cases' s with f al\n            injections _ h1 h2\n            rw [ ← h2 ]\n            apply subtype.eq\n            dsimp [ tail , cons ]\n            rw [ h1 ] at f0\n            rw [ ← f0 ]\n            exact Stream'.eta f . symm\n#align destruct_eq_cons destruct_eq_cons\n\n",
 "destruct_cons":
 "@[simp]\ntheorem destruct_cons (a : α) : ∀ s, destruct (cons a s) = some (a, s)\n  | ⟨f, al⟩ => by\n    unfold cons destruct functor.map\n    apply congr_arg fun s => some (a, s)\n    apply subtype.eq; dsimp [tail]; rw [Stream'.tail_cons]\n#align destruct_cons destruct_cons\n\n",
 "corec_eq":
 "@[simp]\ntheorem corec_eq (f : β → option (α × β)) (b : β) : destruct (corec f b) = omap (corec f) (f b) :=\n  by\n  dsimp [corec, destruct, nth]\n  change Stream'.corec' (corec.F f) (some b) 0 with (corec.F f (some b)).1\n  dsimp [corec.F]\n  induction' h : f b with s; · rfl\n  cases' s with a b'; dsimp [corec.F]\n  apply congr_arg fun b' => some (a, b')\n  apply subtype.eq\n  dsimp [corec, tail]\n  rw [Stream'.corec'_eq, Stream'.tail_cons]\n  dsimp [corec.F]; rw [h]; rfl\n#align corec_eq corec_eq\n\n",
 "cons_right_injective":
 "theorem cons_right_injective (x : α) : function.injective (cons x) :=\n  cons_injective2.right _\n#align cons_right_injective cons_right_injective\n\n",
 "cons_left_injective":
 "theorem cons_left_injective (s : seq α) : function.injective fun x => cons x s :=\n  cons_injective2.left _\n#align cons_left_injective cons_left_injective\n\n",
 "cons_injective2":
 "theorem cons_injective2 : function.injective2 (cons : α → seq α → seq α) := fun x y s t h =>\n  ⟨by rw [← option.some_inj, ← nth_cons_zero, h, nth_cons_zero],\n    seq.ext fun n => by simp_rw [← nth_cons_succ x s n, h, nth_cons_succ]⟩\n#align cons_injective2 cons_injective2\n\n",
 "cons_append":
 "@[simp]\ntheorem cons_append (a : α) (s t) : append (cons a s) t = cons a (append s t) :=\n  destruct_eq_cons <| by\n    dsimp [append]; rw [corec_eq]\n    dsimp [append]; rw [destruct_cons]\n    dsimp [append]; rfl\n#align cons_append cons_append\n\n",
 "coinduction2":
 "theorem coinduction2 (s) (f g : seq α → seq β)\n    (H : ∀ s, bisim_o (fun s1 s2 : seq β => ∃ s : seq α, s1 = f s ∧ s2 = g s) (destruct (f s)) (destruct (g s))) :\n    f s = g s := by\n  refine' eq_of_bisim (fun s1 s2 => ∃ s, s1 = f s ∧ s2 = g s) _ ⟨s, rfl, rfl⟩\n  intro s1 s2 h; rcases h with ⟨s, h1, h2⟩\n  rw [h1, h2]; apply H\n#align coinduction2 coinduction2\n\n",
 "coinduction":
 "theorem coinduction :\n    ∀ {s₁ s₂ : seq α},\n      head s₁ = head s₂ → (∀ (β : Type u) (fr : seq α → β), fr s₁ = fr s₂ → fr (tail s₁) = fr (tail s₂)) → s₁ = s₂\n  | ⟨f₁, a₁⟩, ⟨f₂, a₂⟩, hh, ht => subtype.eq (Stream'.coinduction hh fun β fr => ht β fun s => fr s.1)\n#align coinduction coinduction\n\n",
 "bind_ret":
 "@[simp]\ntheorem bind_ret (f : α → β) : ∀ s, bind s (ret ∘ f) = map f s\n  | ⟨a, s⟩ => by\n    dsimp [bind, map]; change fun x => ret (f x) with ret ∘ f\n    rw [map_comp]; simp [function.comp, ret]\n#align bind_ret bind_ret\n\n",
 "bind_assoc":
 "@[simp]\ntheorem bind_assoc (s : seq1 α) (f : α → seq1 β) (g : β → seq1 γ) :\n    bind (bind s f) g = bind s fun x : α => bind (f x) g :=\n  by\n  cases' s with a s\n  simp [bind, map]\n  rw [← map_comp]\n  change fun x => join (map g (f x)) with join ∘ map g ∘ f\n  rw [map_comp _ join]\n  generalize seq.map (map g ∘ f) s = SS\n  rcases map g (f a) with ⟨⟨a, s⟩, S⟩\n  apply rec_on s <;> intros <;> apply rec_on S <;> intros <;> simp\n  · cases' x with x t\n    apply rec_on t <;> intros <;> simp\n  · cases' x_1 with y t <;> simp\n#align bind_assoc bind_assoc\n\n",
 "append_nil":
 "@[simp]\ntheorem append_nil (s : seq α) : append s nil = s :=\n  by\n  apply coinduction2 s; intro s\n  apply rec_on s _ _\n  · trivial\n  · intro x s\n    rw [cons_append, destruct_cons, destruct_cons]\n    dsimp\n    exact ⟨rfl, s, rfl, rfl⟩\n#align append_nil append_nil\n\n",
 "append_assoc":
 "@[simp]\ntheorem append_assoc (s t u : seq α) : append (append s t) u = append s (append t u) :=\n  by\n  apply eq_of_bisim fun s1 s2 => ∃ s t u, s1 = append (append s t) u ∧ s2 = append s (append t u)\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, t, u, rfl, rfl⟩ => by\n        apply rec_on s <;> simp\n        · apply rec_on t <;> simp\n          · apply rec_on u <;> simp\n            · intro x u\n              refine' ⟨nil, nil, u, _, _⟩ <;> simp\n          · intro x t\n            refine' ⟨nil, t, u, _, _⟩ <;> simp\n        · intro x s\n          exact ⟨s, t, u, rfl, rfl⟩\n  · exact ⟨s, t, u, rfl, rfl⟩\n#align append_assoc append_assoc\n\n"}