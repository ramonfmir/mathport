{"trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[trans]\ntheorem equiv.trans : ∀ {s t u : wseq α}, equiv s t → equiv t u → equiv s u :=\n  lift_rel.trans (· = ·) (@eq.trans _)\n#align equiv.trans equiv.trans\n\n",
 "to_seq_of_seq":
 "theorem to_seq_of_seq (s : seq α) : to_seq (of_seq s) = s :=\n  by\n  apply subtype.eq; funext n\n  dsimp [to_seq]; apply get_eq_of_mem\n  rw [nth_of_seq]; apply ret_mem\n#align to_seq_of_seq to_seq_of_seq\n\n",
 "to_list_of_list":
 "theorem to_list_of_list (l : list α) : l ∈ to_list (of_list l) := by\n  induction' l with a l IH <;> simp [ret_mem] <;> exact think_mem (mem_map _ IH)\n#align to_list_of_list to_list_of_list\n\n",
 "to_list_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem to_list_nil : to_list (nil : wseq α) = (exprreturn) [] :=\n  destruct_eq_ret rfl\n#align to_list_nil to_list_nil\n\n",
 "to_list_cons":
 "@[simp]\ntheorem to_list_cons (a : α) (s) : to_list (cons a s) = (list.cons a <$> to_list s).think :=\n  destruct_eq_think <| by unfold to_list <;> simp <;> rw [to_list'_map] <;> simp <;> rfl\n#align to_list_cons to_list_cons\n\n",
 "to_list'_think":
 "@[simp]\ntheorem to_list'_think (l : list α) (s : wseq α) :\n    corec to_list._match_2 (l, think s) = (corec to_list._match_2 (l, s)).think :=\n  destruct_eq_think <| by simp [to_list, think]\n#align to_list'_think to_list'_think\n\n",
 "to_list'_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem to_list'_nil (l : list α) : corec to_list._match_2 (l, nil) = (exprreturn) l.reverse :=\n  destruct_eq_ret rfl\n#align to_list'_nil to_list'_nil\n\n",
 "to_list'_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\ntheorem to_list'_map (l : list α) (s : wseq α) : corec to_list._match_2 (l, s) = (· ++ ·) l.reverse <$> to_list s :=\n  by\n  refine'\n    eq_of_bisim\n      (fun c1 c2 =>\n        ∃ (l' : list α)(s : wseq α),\n          c1 = corec to_list._match_2 (l' ++ l, s) ∧\n            c2 = computation.map ((· ++ ·) l.reverse) (corec to_list._match_2 (l', s)))\n      _ ⟨[], s, rfl, rfl⟩\n  intro s1 s2 h; rcases h with ⟨l', s, h⟩; rw [h.left, h.right]\n  apply s.rec_on _ (fun a s => _) fun s => _ <;> repeat' simp [to_list, nil, cons, think, length]\n  · refine' ⟨stream.cons a l', s, _, _⟩ <;> simp\n  · refine' ⟨l', s, _, _⟩ <;> simp\n#align to_list'_map to_list'_map\n\n",
 "to_list'_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n@[simp]\ntheorem to_list'_cons (l : list α) (s : wseq α) (a : α) :\n    corec to_list._match_2 (l, cons a s) = (corec to_list._match_2 (stream.cons a l, s)).think :=\n  destruct_eq_think <| by simp [to_list, cons]\n#align to_list'_cons to_list'_cons\n\n",
 "think_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem think_equiv (s : wseq α) : equiv (think s) s := by unfold equiv <;> simp <;> apply equiv.refl\n#align think_equiv think_equiv\n\n",
 "think_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem think_congr {s t : wseq α} (a : α) (h : equiv s t) : equiv (think s) (think t) := by\n  unfold equiv <;> simp <;> exact h\n#align think_congr think_congr\n\n",
 "think_append":
 "@[simp]\ntheorem think_append (s t : wseq α) : append (think s) t = think (append s t) :=\n  seq.cons_append _ _ _\n#align think_append think_append\n\n",
 "tail_think":
 "@[simp]\ntheorem tail_think (s : wseq α) : tail (think s) = (tail s).think := by simp [tail]\n#align tail_think tail_think\n\n",
 "tail_of_seq":
 "@[simp]\ntheorem tail_of_seq (s : seq α) : tail (of_seq s) = of_seq s.tail :=\n  by\n  simp [tail]; apply s.rec_on _ fun x s => _ <;> simp [of_seq]; · rfl\n  rw [seq.head_cons, seq.tail_cons]; rfl\n#align tail_of_seq tail_of_seq\n\n",
 "tail_nil":
 "@[simp]\ntheorem tail_nil : tail (nil : wseq α) = nil := by simp [tail]\n#align tail_nil tail_nil\n\n",
 "tail_cons":
 "@[simp]\ntheorem tail_cons (a : α) (s) : tail (cons a s) = s := by simp [tail]\n#align tail_cons tail_cons\n\n",
 "tail_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem tail_congr {s t : wseq α} (h : equiv s t) : equiv (tail s) (tail t) :=\n  by\n  apply flatten_congr\n  unfold functor.map; rw [← bind_ret, ← bind_ret]\n  apply lift_rel_bind _ _ (destruct_congr h)\n  intro a b h; simp\n  cases' a with a <;> cases' b with b\n  · trivial\n  · cases h\n  · cases a\n    cases h\n  · cases' a with a s'\n    cases' b with b t'\n    exact h.right\n#align tail_congr tail_congr\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[symm]\ntheorem equiv.symm : ∀ {s t : wseq α}, equiv s t → equiv t s :=\n  lift_rel.symm (· = ·) (@eq.symm _)\n#align equiv.symm equiv.symm\n\n",
 "swap_lem":
 "theorem lift_rel.swap_lem {R : α → β → Prop} {s1 s2} (h : lift_rel R s1 s2) : lift_rel (swap R) s2 s1 :=\n  by\n  refine' ⟨swap (lift_rel R), h, fun s t (h : lift_rel R t s) => _⟩\n  rw [← lift_rel_o.swap, computation.lift_rel.swap]\n  apply lift_rel_destruct h\n#align lift_rel.swap_lem lift_rel.swap_lem\n\n",
 "swap":
 "theorem lift_rel.swap (R : α → β → Prop) : swap (lift_rel R) = lift_rel (swap R) :=\n  funext fun x => funext fun y => propext ⟨lift_rel.swap_lem, lift_rel.swap_lem⟩\n#align lift_rel.swap lift_rel.swap\n\n",
 "seq_destruct_think":
 "@[simp]\ntheorem seq_destruct_think (s : wseq α) : seq.destruct (think s) = some (none, s) :=\n  seq.destruct_cons _ _\n#align seq_destruct_think seq_destruct_think\n\n",
 "seq_destruct_nil":
 "@[simp]\ntheorem seq_destruct_nil : seq.destruct (nil : wseq α) = none :=\n  seq.destruct_nil\n#align seq_destruct_nil seq_destruct_nil\n\n",
 "seq_destruct_cons":
 "@[simp]\ntheorem seq_destruct_cons (a : α) (s) : seq.destruct (cons a s) = some (some a, s) :=\n  seq.destruct_cons _ _\n#align seq_destruct_cons seq_destruct_cons\n\n",
 "ret_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem ret_bind (a : α) (f : α → wseq β) : equiv (bind (ret a) f) (f a) := by simp [bind]\n#align ret_bind ret_bind\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[refl]\ntheorem equiv.refl : ∀ s : wseq α, equiv s s :=\n  lift_rel.refl (· = ·) eq.refl\n#align equiv.refl equiv.refl\n\n",
 "productive_iff":
 "theorem productive_iff (s : wseq α) : productive s ↔ ∀ n, (nth s n).terminates :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n#align productive_iff productive_iff\n\n",
 "productive_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem productive_congr {s t : wseq α} (h : equiv s t) : productive s ↔ productive t := by\n  simp only [productive_iff] <;> exact forall_congr' fun n => terminates_congr <| nth_congr h _\n#align productive_congr productive_congr\n\n",
 "of_mem_append":
 "theorem of_mem_append {s₁ s₂ : wseq α} {a : α} : a ∈ append s₁ s₂ → a ∈ s₁ ∨ a ∈ s₂ :=\n  seq.of_mem_append\n#align of_mem_append of_mem_append\n\n",
 "of_list_nil":
 "@[simp]\ntheorem of_list_nil : of_list [] = (nil : wseq α) :=\n  rfl\n#align of_list_nil of_list_nil\n\n",
 "of_list_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n@[simp]\ntheorem of_list_cons (a : α) (l) : of_list (stream.cons a l) = cons a (of_list l) :=\n  show seq.map some (seq.of_list (stream.cons a l)) = seq.cons (some a) (seq.map some (seq.of_list l)) by simp\n#align of_list_cons of_list_cons\n\n",
 "nth_terminates_le":
 "theorem nth_terminates_le {s : wseq α} {m n} (h : m ≤ n) : terminates (nth s n) → terminates (nth s m) := by\n  induction' h with m' h IH <;> [exact id, exact fun T => IH (@head_terminates_of_head_tail_terminates _ _ T)]\n#align nth_terminates_le nth_terminates_le\n\n",
 "nth_tail":
 "theorem nth_tail (s : wseq α) (n) : nth (tail s) n = nth s (n + 1) :=\n  congr_arg head (dropn_tail _ _)\n#align nth_tail nth_tail\n\n",
 "nth_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\ntheorem nth_of_seq (s : seq α) (n) : nth (of_seq s) n = (exprreturn) (seq.nth s n) := by\n  dsimp [nth] <;> rw [dropn_of_seq, head_of_seq, seq.head_dropn]\n#align nth_of_seq nth_of_seq\n\n",
 "nth_mem":
 "theorem nth_mem {s : wseq α} {a n} : some a ∈ nth s n → a ∈ s :=\n  by\n  revert s; induction' n with n IH <;> intro s h\n  · rcases exists_of_mem_map h with ⟨o, h1, h2⟩\n    cases' o with o <;> injection h2 with h'\n    cases' o with a' s'\n    exact (eq_or_mem_iff_mem h1).2 (or.inl h'.symm)\n  · have := @IH (tail s)\n    rw [nth_tail] at this\n    exact mem_of_mem_tail (this h)\n#align nth_mem nth_mem\n\n",
 "nth_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem nth_congr {s t : wseq α} (h : equiv s t) (n) : equiv (nth s n) (nth t n) :=\n  head_congr (dropn_congr h _)\n#align nth_congr nth_congr\n\n",
 "nth_add":
 "theorem nth_add (s : wseq α) (m n) : nth s (m + n) = nth (drop s m) n :=\n  congr_arg head (dropn_add _ _ _)\n#align nth_add nth_add\n\n",
 "not_mem_nil":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n/-\ncoinductive wseq (α : Type u) : Type u\n| nil : wseq α\n| cons : α → wseq α → wseq α\n| think : wseq α → wseq α\n-/\ntheorem not_mem_nil (a : α) : a ∉ @nil α :=\n  seq.not_mem_nil a\n#align not_mem_nil not_mem_nil\n\n",
 "nil_append":
 "@[simp]\ntheorem nil_append (s : wseq α) : append nil s = s :=\n  seq.nil_append _\n#align nil_append nil_append\n\n",
 "mem_think":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\n@[simp]\ntheorem mem_think (s : wseq α) (a) : a ∈ think s ↔ a ∈ s :=\n  by\n  cases' s with f al\n  change some (some a) ∈ stream.cons (some none) f ↔ some (some a) ∈ f\n  constructor <;> intro h\n  · apply (Stream'.eq_or_mem_of_mem_cons h).resolve_left\n    intro\n    injections\n  · apply Stream'.mem_cons_of_mem _ h\n#align mem_think mem_think\n\n",
 "mem_rec_on":
 "theorem mem_rec_on {C : wseq α → Prop} {a s} (M : a ∈ s) (h1 : ∀ b s', a = b ∨ C s' → C (cons b s'))\n    (h2 : ∀ s, C s → C (think s)) : C s := by\n  apply seq.mem_rec_on M\n  intro o s' h; cases' o with b\n  · apply h2\n    cases h\n    · contradiction\n    · assumption\n  · apply h1\n    apply or.imp_left _ h\n    intro h\n    injection h\n#align mem_rec_on mem_rec_on\n\n",
 "mem_of_mem_tail":
 "theorem mem_of_mem_tail {s : wseq α} {a} : a ∈ tail s → a ∈ s :=\n  by\n  intro h; have := h; cases' h with n e; revert s; simp [Stream'.nth]\n  induction' n with n IH <;> intro s <;> apply s.rec_on _ (fun x s => _) fun s => _ <;> repeat' simp <;> intro m e <;>\n    injections\n  · exact or.inr m\n  · exact or.inr m\n  · apply IH m\n    rw [e]\n    cases tail s\n    rfl\n#align mem_of_mem_tail mem_of_mem_tail\n\n",
 "mem_of_mem_dropn":
 "theorem mem_of_mem_dropn {s : wseq α} {a} : ∀ {n}, a ∈ drop s n → a ∈ s\n  | 0, h => h\n  | n + 1, h => @mem_of_mem_dropn n (mem_of_mem_tail h)\n#align mem_of_mem_dropn mem_of_mem_dropn\n\n",
 "mem_map":
 "theorem mem_map (f : α → β) {a : α} {s : wseq α} : a ∈ s → f a ∈ map f s :=\n  seq.mem_map (option.map f)\n#align mem_map mem_map\n\n",
 "mem_cons_of_mem":
 "theorem mem_cons_of_mem {s : wseq α} (b) {a} (h : a ∈ s) : a ∈ cons b s :=\n  (mem_cons_iff _ _).2 (or.inr h)\n#align mem_cons_of_mem mem_cons_of_mem\n\n",
 "mem_cons_iff":
 "@[simp]\ntheorem mem_cons_iff (s : wseq α) (b) {a} : a ∈ cons b s ↔ a = b ∨ a ∈ s :=\n  eq_or_mem_iff_mem <| by simp [ret_mem]\n#align mem_cons_iff mem_cons_iff\n\n",
 "mem_cons":
 "theorem mem_cons (s : wseq α) (a) : a ∈ cons a s :=\n  (mem_cons_iff _ _).2 (or.inl rfl)\n#align mem_cons mem_cons\n\n",
 "mem_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem mem_congr {s t : wseq α} (h : equiv s t) (a) : a ∈ s ↔ a ∈ t :=\n  suffices ∀ {s t : wseq α}, equiv s t → a ∈ s → a ∈ t from ⟨this h, this h.symm⟩\n  fun s t h as =>\n  let ⟨n, hn⟩ := exists_nth_of_mem as\n  nth_mem ((nth_congr h _ _).1 hn)\n#align mem_congr mem_congr\n\n",
 "mem_append_left":
 "theorem mem_append_left {s₁ s₂ : wseq α} {a : α} : a ∈ s₁ → a ∈ append s₁ s₂ :=\n  seq.mem_append_left\n#align mem_append_left mem_append_left\n\n",
 "map_think":
 "@[simp]\ntheorem map_think (f : α → β) (s) : map f (think s) = think (map f s) :=\n  seq.map_cons _ _ _\n#align map_think map_think\n\n",
 "map_ret":
 "@[simp]\ntheorem map_ret (f : α → β) (a) : map f (ret a) = ret (f a) := by simp [ret]\n#align map_ret map_ret\n\n",
 "map_nil":
 "@[simp]\ntheorem map_nil (f : α → β) : map f nil = nil :=\n  rfl\n#align map_nil map_nil\n\n",
 "map_join":
 "@[simp]\ntheorem map_join (f : α → β) (S) : map f (join S) = join (map (map f) S) :=\n  by\n  apply seq.eq_of_bisim fun s1 s2 => ∃ s S, s1 = append s (map f (join S)) ∧ s2 = append s (join (map (map f) S))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, S, rfl, rfl⟩ => by\n        apply wseq.rec_on s _ (fun a s => _) fun s => _ <;> simp\n        · apply wseq.rec_on S _ (fun s S => _) fun S => _ <;> simp\n          · exact ⟨map f s, S, rfl, rfl⟩\n          · refine' ⟨nil, S, _, _⟩ <;> simp\n        · exact ⟨_, _, rfl, rfl⟩\n        · exact ⟨_, _, rfl, rfl⟩\n  · refine' ⟨nil, S, _, _⟩ <;> simp\n#align map_join map_join\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (s : wseq α) : map id s = s := by simp [map]\n#align map_id map_id\n\n",
 "map_cons":
 "@[simp]\ntheorem map_cons (f : α → β) (a s) : map f (cons a s) = cons (f a) (map f s) :=\n  seq.map_cons _ _ _\n#align map_cons map_cons\n\n",
 "map_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n#print map_congr /-\ntheorem map_congr (f : α → β) {s t : wseq α} (h : equiv s t) : equiv (map f s) (map f t) :=\n  lift_rel_map _ _ h fun _ _ => congr_arg _\n#align map_congr map_congr\n-/\n\n",
 "map_comp":
 "theorem map_comp (f : α → β) (g : β → γ) (s : wseq α) : map (g ∘ f) s = map g (map f s) :=\n  by\n  dsimp [map]; rw [← seq.map_comp]\n  apply congr_fun; apply congr_arg\n  ext ⟨⟩ <;> rfl\n#align map_comp map_comp\n\n",
 "map_append":
 "@[simp]\ntheorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) :=\n  seq.map_append _ _ _\n#align map_append map_append\n\n",
 "lift_rel_think_right":
 "@[simp]\ntheorem lift_rel_think_right (R : α → β → Prop) (s t) : lift_rel R s (think t) ↔ lift_rel R s t := by\n  rw [lift_rel_destruct_iff, lift_rel_destruct_iff] <;> simp\n#align lift_rel_think_right lift_rel_think_right\n\n",
 "lift_rel_think_left":
 "@[simp]\ntheorem lift_rel_think_left (R : α → β → Prop) (s t) : lift_rel R (think s) t ↔ lift_rel R s t := by\n  rw [lift_rel_destruct_iff, lift_rel_destruct_iff] <;> simp\n#align lift_rel_think_left lift_rel_think_left\n\n",
 "lift_rel_nil":
 "@[simp]\ntheorem lift_rel_nil (R : α → β → Prop) : lift_rel R nil nil := by rw [lift_rel_destruct_iff] <;> simp\n#align lift_rel_nil lift_rel_nil\n\n",
 "lift_rel_map":
 "theorem lift_rel_map {δ} (R : α → β → Prop) (S : γ → δ → Prop) {s1 : wseq α} {s2 : wseq β} {f1 : α → γ} {f2 : β → δ}\n    (h1 : lift_rel R s1 s2) (h2 : ∀ {a b}, R a b → S (f1 a) (f2 b)) : lift_rel S (map f1 s1) (map f2 s2) :=\n  ⟨fun s1 s2 => ∃ s t, s1 = map f1 s ∧ s2 = map f2 t ∧ lift_rel R s t, ⟨s1, s2, rfl, rfl, h1⟩, fun s1 s2 h =>\n    match s1, s2, h with\n    | _, _, ⟨s, t, rfl, rfl, h⟩ => by\n      simp [destruct_map]; apply computation.lift_rel_map _ _ (lift_rel_destruct h)\n      intro o p h\n      cases' o with a <;> cases' p with b <;> simp\n      · cases b <;> cases h\n      · cases a <;> cases h\n      · cases' a with a s <;> cases' b with b t\n        cases' h with r h\n        exact ⟨h2 r, s, rfl, t, rfl, h⟩⟩\n#align lift_rel_map lift_rel_map\n\n",
 "lift_rel_join":
 "theorem lift_rel_join (R : α → β → Prop) {S : wseq (wseq α)} {T : wseq (wseq β)} (h : lift_rel (lift_rel R) S T) :\n    lift_rel R (join S) (join T) :=\n  ⟨fun s1 s2 => ∃ s t S T, s1 = append s (join S) ∧ s2 = append t (join T) ∧ lift_rel R s t ∧ lift_rel (lift_rel R) S T,\n    ⟨nil, nil, S, T, by simp, by simp, by simp, h⟩, fun s1 s2 ⟨s, t, S, T, h1, h2, st, ST⟩ =>\n    by\n    clear _fun_match _x\n    rw [h1, h2]; rw [destruct_append, destruct_append]\n    apply computation.lift_rel_bind _ _ (lift_rel_destruct st)\n    exact fun o p h =>\n      match o, p, h with\n      | some (a, s), some (b, t), ⟨h1, h2⟩ => by simp <;> exact ⟨h1, s, t, S, rfl, T, rfl, h2, ST⟩\n      | none, none, _ => by\n        dsimp [destruct_append.aux, computation.lift_rel]; constructor\n        · intro\n          apply lift_rel_join.lem _ ST fun _ _ => id\n        · intro b mb\n          rw [← lift_rel_o.swap]\n          apply lift_rel_join.lem (swap R)\n          · rw [← lift_rel.swap R, ← lift_rel.swap]\n            apply ST\n          · rw [← lift_rel.swap R, ← lift_rel.swap (lift_rel R)]\n            exact fun s1 s2 ⟨s, t, S, T, h1, h2, st, ST⟩ => ⟨t, s, T, S, h2, h1, st, ST⟩\n          · exact mb⟩\n#align lift_rel_join lift_rel_join\n\n",
 "lift_rel_flatten":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\ntheorem lift_rel_flatten {R : α → β → Prop} {c1 : computation (wseq α)} {c2 : computation (wseq β)}\n    (h : c1.lift_rel (lift_rel R) c2) : lift_rel R (flatten c1) (flatten c2) :=\n  let S s t := ∃ c1 c2, s = flatten c1 ∧ t = flatten c2 ∧ computation.lift_rel (lift_rel R) c1 c2\n  ⟨S, ⟨c1, c2, rfl, rfl, h⟩, fun s t h =>\n    match s, t, h with\n    | _, _, ⟨c1, c2, rfl, rfl, h⟩ => by\n      simp; apply lift_rel_bind _ _ h\n      intro a b ab; apply computation.lift_rel.imp _ _ _ (lift_rel_destruct ab)\n      intro a b; apply lift_rel_o.imp_right\n      intro s t h; refine' ⟨(exprreturn) s, (exprreturn) t, _, _, _⟩ <;> simp [h]⟩\n#align lift_rel_flatten lift_rel_flatten\n\n",
 "lift_rel_dropn_destruct":
 "theorem lift_rel_dropn_destruct {R : α → β → Prop} {s t} (H : lift_rel R s t) :\n    ∀ n, computation.lift_rel (lift_rel_o R (lift_rel R)) (destruct (drop s n)) (destruct (drop t n))\n  | 0 => lift_rel_destruct H\n  | n + 1 => by\n    simp [destruct_tail]\n    apply lift_rel_bind\n    apply lift_rel_dropn_destruct n\n    exact fun a b o =>\n      match a, b, o with\n      | none, none, _ => by simp\n      | some (a, s), some (b, t), ⟨h1, h2⟩ => by simp [tail.aux] <;> apply lift_rel_destruct h2\n#align lift_rel_dropn_destruct lift_rel_dropn_destruct\n\n",
 "lift_rel_destruct_iff":
 "theorem lift_rel_destruct_iff {R : α → β → Prop} {s : wseq α} {t : wseq β} :\n    lift_rel R s t ↔ computation.lift_rel (lift_rel_o R (lift_rel R)) (destruct s) (destruct t) :=\n  ⟨lift_rel_destruct, fun h =>\n    ⟨fun s t => lift_rel R s t ∨ computation.lift_rel (lift_rel_o R (lift_rel R)) (destruct s) (destruct t), or.inr h,\n      fun s t h =>\n      by\n      have h : computation.lift_rel (lift_rel_o R (lift_rel R)) (destruct s) (destruct t) :=\n        by\n        cases' h with h h\n        exact lift_rel_destruct h\n        assumption\n      apply computation.lift_rel.imp _ _ _ h\n      intro a b\n      apply lift_rel_o.imp_right\n      intro s t\n      apply or.inl⟩⟩\n#align lift_rel_destruct_iff lift_rel_destruct_iff\n\n",
 "lift_rel_destruct":
 "theorem lift_rel_destruct {R : α → β → Prop} {s : wseq α} {t : wseq β} :\n    lift_rel R s t → computation.lift_rel (lift_rel_o R (lift_rel R)) (destruct s) (destruct t)\n  | ⟨R, h1, h2⟩ => by\n    refine' computation.lift_rel.imp _ _ _ (h2 h1) <;> apply lift_rel_o.imp_right <;> exact fun s' t' h' => ⟨R, h', @h2⟩\n#align lift_rel_destruct lift_rel_destruct\n\n",
 "lift_rel_cons":
 "@[simp]\ntheorem lift_rel_cons (R : α → β → Prop) (a b s t) : lift_rel R (cons a s) (cons b t) ↔ R a b ∧ lift_rel R s t := by\n  rw [lift_rel_destruct_iff] <;> simp\n#align lift_rel_cons lift_rel_cons\n\n",
 "lift_rel_bind":
 "theorem lift_rel_bind {δ} (R : α → β → Prop) (S : γ → δ → Prop) {s1 : wseq α} {s2 : wseq β} {f1 : α → wseq γ}\n    {f2 : β → wseq δ} (h1 : lift_rel R s1 s2) (h2 : ∀ {a b}, R a b → lift_rel S (f1 a) (f2 b)) :\n    lift_rel S (bind s1 f1) (bind s2 f2) :=\n  lift_rel_join _ (lift_rel_map _ _ h1 @h2)\n#align lift_rel_bind lift_rel_bind\n\n",
 "lift_rel_append":
 "theorem lift_rel_append (R : α → β → Prop) {s1 s2 : wseq α} {t1 t2 : wseq β} (h1 : lift_rel R s1 t1)\n    (h2 : lift_rel R s2 t2) : lift_rel R (append s1 s2) (append t1 t2) :=\n  ⟨fun s t => lift_rel R s t ∨ ∃ s1 t1, s = append s1 s2 ∧ t = append t1 t2 ∧ lift_rel R s1 t1,\n    or.inr ⟨s1, t1, rfl, rfl, h1⟩, fun s t h =>\n    match s, t, h with\n    | s, t, or.inl h => by\n      apply computation.lift_rel.imp _ _ _ (lift_rel_destruct h)\n      intro a b; apply lift_rel_o.imp_right\n      intro s t; apply or.inl\n    | _, _, or.inr ⟨s1, t1, rfl, rfl, h⟩ => by\n      simp [destruct_append]\n      apply computation.lift_rel_bind _ _ (lift_rel_destruct h)\n      intro o p h\n      cases' o with a <;> cases' p with b\n      · simp\n        apply computation.lift_rel.imp _ _ _ (lift_rel_destruct h2)\n        intro a b\n        apply lift_rel_o.imp_right\n        intro s t\n        apply or.inl\n      · cases b <;> cases h\n      · cases a <;> cases h\n      · cases' a with a s <;> cases' b with b t\n        cases' h with r h\n        simp\n        exact ⟨r, or.inr ⟨s, rfl, t, rfl, h⟩⟩⟩\n#align lift_rel_append lift_rel_append\n\n",
 "length_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `stream.cons -/\ntheorem length_eq_map (s : wseq α) : length s = computation.map list.length (to_list s) :=\n  by\n  refine'\n    eq_of_bisim\n      (fun c1 c2 =>\n        ∃ (l : list α)(s : wseq α),\n          c1 = corec length._match_2 (l.length, s) ∧ c2 = computation.map list.length (corec to_list._match_2 (l, s)))\n      _ ⟨[], s, rfl, rfl⟩\n  intro s1 s2 h; rcases h with ⟨l, s, h⟩; rw [h.left, h.right]\n  apply s.rec_on _ (fun a s => _) fun s => _ <;> repeat' simp [to_list, nil, cons, think, length]\n  · refine' ⟨stream.cons a l, s, _, _⟩ <;> simp\n  · refine' ⟨l, s, _, _⟩ <;> simp\n#align length_eq_map length_eq_map\n\n",
 "lem":
 "theorem lift_rel_join.lem (R : α → β → Prop) {S T} {U : wseq α → wseq β → Prop} (ST : lift_rel (lift_rel R) S T)\n    (HU :\n      ∀ s1 s2,\n        (∃ s t S T, s1 = append s (join S) ∧ s2 = append t (join T) ∧ lift_rel R s t ∧ lift_rel (lift_rel R) S T) →\n          U s1 s2)\n    {a} (ma : a ∈ destruct (join S)) : ∃ b, b ∈ destruct (join T) ∧ lift_rel_o R U a b :=\n  by\n  cases' exists_results_of_mem ma with n h; clear ma; revert a S T\n  apply nat.strong_induction_on n _\n  intro n IH a S T ST ra; simp [destruct_join] at ra;\n  exact\n    let ⟨o, m, k, rs1, rs2, en⟩ := of_results_bind ra\n    let ⟨p, mT, rop⟩ := computation.exists_of_lift_rel_left (lift_rel_destruct ST) rs1.mem\n    match o, p, rop, rs1, rs2, mT with\n    | none, none, _, rs1, rs2, mT => by\n      simp only [destruct_join] <;> exact ⟨none, mem_bind mT (ret_mem _), by rw [eq_of_ret_mem rs2.mem] <;> trivial⟩\n    | some (s, S'), some (t, T'), ⟨st, ST'⟩, rs1, rs2, mT => by\n      simp [destruct_append] at rs2 <;>\n        exact\n          let ⟨k1, rs3, ek⟩ := of_results_think rs2\n          let ⟨o', m1, n1, rs4, rs5, ek1⟩ := of_results_bind rs3\n          let ⟨p', mt, rop'⟩ := computation.exists_of_lift_rel_left (lift_rel_destruct st) rs4.mem\n          match o', p', rop', rs4, rs5, mt with\n          | none, none, _, rs4, rs5', mt =>\n            by\n            have : n1 < n := by\n              rw [en, ek, ek1]\n              apply lt_of_lt_of_le _ (nat.le_add_right _ _)\n              apply nat.lt_succ_of_le (nat.le_add_right _ _)\n            let ⟨ob, mb, rob⟩ := IH _ this ST' rs5'\n            refine' ⟨ob, _, rob⟩ <;>\n              · simp [destruct_join]\n                apply mem_bind mT\n                simp [destruct_append]\n                apply think_mem\n                apply mem_bind mt\n                exact mb\n          | some (a, s'), some (b, t'), ⟨ab, st'⟩, rs4, rs5, mt =>\n            by\n            simp at rs5\n            refine' ⟨some (b, append t' (join T')), _, _⟩\n            · simp [destruct_join]\n              apply mem_bind mT\n              simp [destruct_append]\n              apply think_mem\n              apply mem_bind mt\n              apply ret_mem\n            rw [eq_of_ret_mem rs5.mem]\n            exact ⟨ab, HU _ _ ⟨s', t', S', T', rfl, rfl, st', ST'⟩⟩\n#align lift_rel_join.lem lift_rel_join.lem\n\n",
 "join_think":
 "@[simp]\ntheorem join_think (S : wseq (wseq α)) : join (think S) = think (join S) :=\n  by\n  simp [think, join]\n  unfold functor.map\n  simp [join, seq1.ret]\n#align join_think join_think\n\n",
 "join_ret":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem join_ret (s : wseq α) : equiv (join (ret s)) s := by simp [ret] <;> apply think_equiv\n#align join_ret join_ret\n\n",
 "join_nil":
 "@[simp]\ntheorem join_nil : join nil = (nil : wseq α) :=\n  seq.join_nil\n#align join_nil join_nil\n\n",
 "join_map_ret":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem join_map_ret (s : wseq α) : equiv (join (map ret s)) s :=\n  by\n  refine' ⟨fun s1 s2 => join (map ret s2) = s1, rfl, _⟩\n  intro s' s h; rw [← h]\n  apply lift_rel_rec fun c1 c2 => ∃ s, c1 = destruct (join (map ret s)) ∧ c2 = destruct s\n  ·\n    exact fun c1 c2 h =>\n      match c1, c2, h with\n      | _, _, ⟨s, rfl, rfl⟩ => by\n        clear h _match\n        have : ∀ s, ∃ s' : wseq α, (map ret s).join.destruct = (map ret s').join.destruct ∧ destruct s = s'.destruct :=\n          fun s => ⟨s, rfl, rfl⟩\n        apply s.rec_on _ (fun a s => _) fun s => _ <;> simp [ret, ret_mem, this, option.exists]\n  · exact ⟨s, rfl, rfl⟩\n#align join_map_ret join_map_ret\n\n",
 "join_join":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem join_join (SS : wseq (wseq (wseq α))) : equiv (join (join SS)) (join (map join SS)) :=\n  by\n  refine'\n    ⟨fun s1 s2 =>\n      ∃ s S SS, s1 = append s (join (append S (join SS))) ∧ s2 = append s (append (join S) (join (map join SS))),\n      ⟨nil, nil, SS, by simp, by simp⟩, _⟩\n  intro s1 s2 h\n  apply\n    lift_rel_rec\n      (fun c1 c2 =>\n        ∃ s S SS,\n          c1 = destruct (append s (join (append S (join SS)))) ∧\n            c2 = destruct (append s (append (join S) (join (map join SS)))))\n      _ (destruct s1) (destruct s2)\n      (let ⟨s, S, SS, h1, h2⟩ := h\n      ⟨s, S, SS, by simp [h1], by simp [h2]⟩)\n  intro c1 c2 h\n  exact\n    match c1, c2, h with\n    | _, _, ⟨s, S, SS, rfl, rfl⟩ => by\n      clear _match h h\n      apply wseq.rec_on s _ (fun a s => _) fun s => _ <;> simp\n      · apply wseq.rec_on S _ (fun s S => _) fun S => _ <;> simp\n        · apply wseq.rec_on SS _ (fun S SS => _) fun SS => _ <;> simp\n          · refine' ⟨nil, S, SS, _, _⟩ <;> simp\n          · refine' ⟨nil, nil, SS, _, _⟩ <;> simp\n        · exact ⟨s, S, SS, rfl, rfl⟩\n        · refine' ⟨nil, S, SS, _, _⟩ <;> simp\n      · exact ⟨s, S, SS, rfl, rfl⟩\n      · exact ⟨s, S, SS, rfl, rfl⟩\n#align join_join join_join\n\n",
 "join_cons":
 "@[simp]\ntheorem join_cons (s : wseq α) (S) : join (cons s S) = think (append s (join S)) :=\n  by\n  simp [think, join]\n  unfold functor.map\n  simp [join, cons, append]\n#align join_cons join_cons\n\n",
 "join_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem join_congr {S T : wseq (wseq α)} (h : lift_rel equiv S T) : equiv (join S) (join T) :=\n  lift_rel_join _ h\n#align join_congr join_congr\n\n",
 "join_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem join_append (S T : wseq (wseq α)) : equiv (join (append S T)) (append (join S) (join T)) :=\n  by\n  refine'\n    ⟨fun s1 s2 => ∃ s S T, s1 = append s (join (append S T)) ∧ s2 = append s (append (join S) (join T)),\n      ⟨nil, S, T, by simp, by simp⟩, _⟩\n  intro s1 s2 h\n  apply\n    lift_rel_rec\n      (fun c1 c2 =>\n        ∃ (s : wseq α)(S T : _),\n          c1 = destruct (append s (join (append S T))) ∧ c2 = destruct (append s (append (join S) (join T))))\n      _ _ _\n      (let ⟨s, S, T, h1, h2⟩ := h\n      ⟨s, S, T, congr_arg destruct h1, congr_arg destruct h2⟩)\n  intro c1 c2 h\n  exact\n    match c1, c2, h with\n    | _, _, ⟨s, S, T, rfl, rfl⟩ => by\n      clear _match h h\n      apply wseq.rec_on s _ (fun a s => _) fun s => _ <;> simp\n      · apply wseq.rec_on S _ (fun s S => _) fun S => _ <;> simp\n        · apply wseq.rec_on T _ (fun s T => _) fun T => _ <;> simp\n          · refine' ⟨s, nil, T, _, _⟩ <;> simp\n          · refine' ⟨nil, nil, T, _, _⟩ <;> simp\n        · exact ⟨s, S, T, rfl, rfl⟩\n        · refine' ⟨nil, S, T, _, _⟩ <;> simp\n      · exact ⟨s, S, T, rfl, rfl⟩\n      · exact ⟨s, S, T, rfl, rfl⟩\n#align join_append join_append\n\n",
 "imp_right":
 "theorem lift_rel_o.imp_right (R : α → β → Prop) {C D : wseq α → wseq β → Prop} (H : ∀ s t, C s t → D s t) {o p} :\n    lift_rel_o R C o p → lift_rel_o R D o p :=\n  lift_rel_o.imp (fun _ _ => id) H\n#align lift_rel_o.imp_right lift_rel_o.imp_right\n\n",
 "imp":
 "theorem bisim_o.imp {R S : wseq α → wseq α → Prop} (H : ∀ s t, R s t → S s t) {o p} : bisim_o R o p → bisim_o S o p :=\n  lift_rel_o.imp_right _ H\n#align bisim_o.imp bisim_o.imp\n\n",
 "head_think":
 "@[simp]\ntheorem head_think (s : wseq α) : head (think s) = (head s).think := by simp [head] <;> rfl\n#align head_think head_think\n\n",
 "head_terminates_of_nth_terminates":
 "theorem head_terminates_of_nth_terminates {s : wseq α} {n} : terminates (nth s n) → terminates (head s) :=\n  nth_terminates_le (nat.zero_le n)\n#align head_terminates_of_nth_terminates head_terminates_of_nth_terminates\n\n",
 "head_terminates_of_mem":
 "theorem head_terminates_of_mem {s : wseq α} {a} (h : a ∈ s) : terminates (head s) :=\n  let ⟨n, h⟩ := exists_nth_of_mem h\n  head_terminates_of_nth_terminates ⟨⟨_, h⟩⟩\n#align head_terminates_of_mem head_terminates_of_mem\n\n",
 "head_terminates_of_head_tail_terminates":
 "theorem head_terminates_of_head_tail_terminates (s : wseq α) [T : terminates (head (tail s))] : terminates (head s) :=\n  (head_terminates_iff _).2 <| by\n    rcases(head_terminates_iff _).1 T with ⟨⟨a, h⟩⟩\n    simp [tail] at h\n    rcases exists_of_mem_bind h with ⟨s', h1, h2⟩\n    unfold functor.map at h1\n    exact\n      let ⟨t, h3, h4⟩ := exists_of_mem_map h1\n      terminates_of_mem h3\n#align head_terminates_of_head_tail_terminates head_terminates_of_head_tail_terminates\n\n",
 "head_terminates_iff":
 "theorem head_terminates_iff (s : wseq α) : terminates (head s) ↔ terminates (destruct s) :=\n  terminates_map_iff _ (destruct s)\n#align head_terminates_iff head_terminates_iff\n\n",
 "head_some_of_nth_some":
 "theorem head_some_of_nth_some {s : wseq α} {a n} (h : some a ∈ nth s n) : ∃ a', some a' ∈ head s :=\n  by\n  revert a; induction' n with n IH <;> intros\n  exacts[⟨_, h⟩,\n    let ⟨a', h'⟩ := head_some_of_head_tail_some h\n    IH h']\n#align head_some_of_nth_some head_some_of_nth_some\n\n",
 "head_some_of_head_tail_some":
 "theorem head_some_of_head_tail_some {s : wseq α} {a} (h : some a ∈ head (tail s)) : ∃ a', some a' ∈ head s :=\n  by\n  unfold head at h\n  rcases exists_of_mem_map h with ⟨o, md, e⟩; clear h\n  cases' o with o <;> injection e with h'; clear e h'\n  cases' destruct_some_of_destruct_tail_some md with a am\n  exact ⟨_, mem_map ((· <$> ·) (@prod.fst α (wseq α))) am⟩\n#align head_some_of_head_tail_some head_some_of_head_tail_some\n\n",
 "head_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem head_of_seq (s : seq α) : head (of_seq s) = (exprreturn) s.head := by simp [head] <;> cases seq.head s <;> rfl\n#align head_of_seq head_of_seq\n\n",
 "head_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem head_nil : head (nil : wseq α) = (exprreturn) none := by simp [head] <;> rfl\n#align head_nil head_nil\n\n",
 "head_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem head_cons (a : α) (s) : head (cons a s) = (exprreturn) (some a) := by simp [head] <;> rfl\n#align head_cons head_cons\n\n",
 "head_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem head_congr : ∀ {s t : wseq α}, equiv s t → equiv (head s) (head t) :=\n  by\n  suffices ∀ {s t : wseq α}, equiv s t → ∀ {o}, o ∈ head s → o ∈ head t from fun s t h o => ⟨this h, this h.symm⟩\n  intro s t h o ho\n  rcases@computation.exists_of_mem_map _ _ _ _ (destruct s) ho with ⟨ds, dsm, dse⟩\n  rw [← dse]\n  cases' destruct_congr h with l r\n  rcases l dsm with ⟨dt, dtm, dst⟩\n  cases' ds with a <;> cases' dt with b\n  · apply mem_map _ dtm\n  · cases b\n    cases dst\n  · cases a\n    cases dst\n  · cases' a with a s'\n    cases' b with b t'\n    rw [dst.left]\n    exact @mem_map _ _ (@functor.map _ _ (α × wseq α) _ prod.fst) _ (destruct t) dtm\n#align head_congr head_congr\n\n",
 "flatten_think":
 "@[simp]\ntheorem flatten_think (c : computation (wseq α)) : flatten c.think = think (flatten c) :=\n  seq.destruct_eq_cons <| by simp [flatten, think]\n#align flatten_think flatten_think\n\n",
 "flatten_ret":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem flatten_ret (s : wseq α) : flatten ((exprreturn) s) = s :=\n  by\n  refine' seq.eq_of_bisim (fun s1 s2 => flatten ((exprreturn) s2) = s1) _ rfl\n  intro s' s h; rw [← h]; simp [flatten]\n  cases seq.destruct s; · simp\n  · cases' val with o s'\n    simp\n#align flatten_ret flatten_ret\n\n",
 "flatten_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem flatten_equiv {c : computation (wseq α)} {s} (h : s ∈ c) : equiv (flatten c) s :=\n  by\n  apply computation.mem_rec_on h; · simp\n  · intro s'\n    apply equiv.trans\n    simp [think_equiv]\n#align flatten_equiv flatten_equiv\n\n",
 "flatten_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem flatten_congr {c1 c2 : computation (wseq α)} :\n    computation.lift_rel equiv c1 c2 → equiv (flatten c1) (flatten c2) :=\n  lift_rel_flatten\n#align flatten_congr flatten_congr\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem equiv.ext {s t : wseq α} (h : ∀ n, equiv (nth s n) (nth t n)) : equiv s t :=\n  ⟨fun s t => ∀ n, equiv (nth s n) (nth t n), h, fun s t h =>\n    by\n    refine' lift_rel_def.2 ⟨_, _⟩\n    · rw [← head_terminates_iff, ← head_terminates_iff]\n      exact terminates_congr (h 0)\n    · intro a b ma mb\n      cases' a with a <;> cases' b with b\n      · trivial\n      · injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb))\n      · injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb))\n      · cases' a with a s'\n        cases' b with b t'\n        injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) with ab\n        refine' ⟨ab, fun n => _⟩\n        refine'\n          (nth_congr (flatten_equiv (mem_map _ ma)) n).symm.trans\n            ((_ : equiv (nth (tail s) n) (nth (tail t) n)).trans (nth_congr (flatten_equiv (mem_map _ mb)) n))\n        rw [nth_tail, nth_tail]\n        apply h⟩\n#align equiv.ext equiv.ext\n\n",
 "exists_of_mem_map":
 "theorem exists_of_mem_map {f} {b : β} : ∀ {s : wseq α}, b ∈ map f s → ∃ a, a ∈ s ∧ f a = b\n  | ⟨g, al⟩, h => by\n    let ⟨o, om, oe⟩ := seq.exists_of_mem_map h\n    cases' o with a <;> injection oe with h' <;> exact ⟨a, om, h'⟩\n#align exists_of_mem_map exists_of_mem_map\n\n",
 "exists_of_mem_join":
 "-- The converse is not true without additional assumptions\ntheorem exists_of_mem_join {a : α} : ∀ {S : wseq (wseq α)}, a ∈ join S → ∃ s, s ∈ S ∧ a ∈ s :=\n  by\n  suffices ∀ ss : wseq α, a ∈ ss → ∀ s S, append s (join S) = ss → a ∈ append s (join S) → a ∈ s ∨ ∃ s, s ∈ S ∧ a ∈ s\n    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)\n  intro ss h; apply mem_rec_on h (fun b ss o => _) fun ss IH => _ <;> intro s S\n  · refine' s.rec_on (S.rec_on _ (fun s S => _) fun S => _) (fun b' s => _) fun s => _ <;> intro ej m <;> simp at ej <;>\n            have := congr_arg seq.destruct ej <;> simp at this <;> try cases this <;> try contradiction\n    substs b' ss\n    simp at m⊢\n    cases' o with e IH\n    · simp [e]\n    cases' m with e m\n    · simp [e]\n    exact or.imp_left or.inr (IH _ _ rfl m)\n  · refine' s.rec_on (S.rec_on _ (fun s S => _) fun S => _) (fun b' s => _) fun s => _ <;> intro ej m <;> simp at ej <;>\n            have := congr_arg seq.destruct ej <;> simp at this <;> try try have := this.1; contradiction <;> subst ss\n    · apply or.inr\n      simp at m⊢\n      cases' IH s S rfl m with as ex\n      · exact ⟨s, or.inl rfl, as⟩\n      · rcases ex with ⟨s', sS, as⟩\n        exact ⟨s', or.inr sS, as⟩\n    · apply or.inr\n      simp at m\n      rcases(IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ⟨s, sS, as⟩\n      exact ⟨s, by simp [sS], as⟩\n    · simp at m IH⊢\n      apply IH _ _ rfl m\n#align exists_of_mem_join exists_of_mem_join\n\n",
 "exists_of_mem_bind":
 "theorem exists_of_mem_bind {s : wseq α} {f : α → wseq β} {b} (h : b ∈ bind s f) : ∃ a ∈ s, b ∈ f a :=\n  let ⟨t, tm, bt⟩ := exists_of_mem_join h\n  let ⟨a, as, e⟩ := exists_of_mem_map tm\n  ⟨a, as, by rwa [e]⟩\n#align exists_of_mem_bind exists_of_mem_bind\n\n",
 "exists_of_lift_rel_right":
 "theorem exists_of_lift_rel_right {R : α → β → Prop} {s t} (H : lift_rel R s t) {b} (h : b ∈ t) : ∃ a, a ∈ s ∧ R a b :=\n  by rw [← lift_rel.swap] at H <;> exact exists_of_lift_rel_left H h\n#align exists_of_lift_rel_right exists_of_lift_rel_right\n\n",
 "exists_of_lift_rel_left":
 "theorem exists_of_lift_rel_left {R : α → β → Prop} {s t} (H : lift_rel R s t) {a} (h : a ∈ s) : ∃ b, b ∈ t ∧ R a b :=\n  let ⟨n, h⟩ := exists_nth_of_mem h\n  let ⟨some (_, s'), sd, rfl⟩ := exists_of_mem_map h\n  let ⟨some (b, t'), td, ⟨ab, _⟩⟩ := (lift_rel_dropn_destruct H n).left sd\n  ⟨b, nth_mem (mem_map ((· <$> ·) prod.fst.{v, v}) td), ab⟩\n#align exists_of_lift_rel_left exists_of_lift_rel_left\n\n",
 "exists_nth_of_mem":
 "theorem exists_nth_of_mem {s : wseq α} {a} (h : a ∈ s) : ∃ n, some a ∈ nth s n :=\n  by\n  apply mem_rec_on h\n  · intro a' s' h\n    cases' h with h h\n    · exists 0\n      simp [nth]\n      rw [h]\n      apply ret_mem\n    · cases' h with n h\n      exists n + 1\n      simp [nth]\n      exact h\n  · intro s' h\n    cases' h with n h\n    exists n\n    simp [nth]\n    apply think_mem h\n#align exists_nth_of_mem exists_nth_of_mem\n\n",
 "exists_dropn_of_mem":
 "theorem exists_dropn_of_mem {s : wseq α} {a} (h : a ∈ s) : ∃ n s', some (a, s') ∈ destruct (drop s n) :=\n  let ⟨n, h⟩ := exists_nth_of_mem h\n  ⟨n, by\n    rcases(head_terminates_iff _).1 ⟨⟨_, h⟩⟩ with ⟨⟨o, om⟩⟩\n    have := mem_unique (mem_map _ om) h\n    cases' o with o <;> injection this with i\n    cases' o with a' s'; dsimp at i\n    rw [i] at om; exact ⟨_, om⟩⟩\n#align exists_dropn_of_mem exists_dropn_of_mem\n\n",
 "equivalence":
 "theorem equiv.equivalence : equivalence (@equiv α) :=\n  ⟨@equiv.refl _, @equiv.symm _, @equiv.trans _⟩\n#align equiv.equivalence equiv.equivalence\n\n",
 "equiv":
 "theorem lift_rel.equiv (R : α → α → Prop) : equivalence R → equivalence (lift_rel R)\n  | ⟨refl, symm, trans⟩ => ⟨lift_rel.refl R refl, lift_rel.symm R symm, lift_rel.trans R trans⟩\n#align lift_rel.equiv lift_rel.equiv\n\n",
 "eq_or_mem_iff_mem":
 "theorem eq_or_mem_iff_mem {s : wseq α} {a a' s'} : some (a', s') ∈ destruct s → (a ∈ s ↔ a = a' ∨ a ∈ s') :=\n  by\n  generalize e : destruct s = c; intro h\n  revert s;\n  apply computation.mem_rec_on h _ fun c IH => _ <;> intro s <;> apply s.rec_on _ (fun x s => _) fun s => _ <;>\n          intro m <;>\n        have := congr_arg computation.destruct m <;>\n      simp at this <;>\n    cases' this with i1 i2\n  · rw [i1, i2]\n    cases' s' with f al\n    unfold cons has_mem.mem wseq.mem seq.mem seq.cons\n    simp\n    have h_a_eq_a' : a = a' ↔ some (some a) = some (some a') := by simp\n    rw [h_a_eq_a']\n    refine' ⟨Stream'.eq_or_mem_of_mem_cons, fun o => _⟩\n    · cases' o with e m\n      · rw [e]\n        apply Stream'.mem_cons\n      · exact Stream'.mem_cons_of_mem _ m\n  · simp\n    exact IH this\n#align eq_or_mem_iff_mem eq_or_mem_iff_mem\n\n",
 "dropn_think":
 "@[simp]\ntheorem dropn_think (s : wseq α) (n) : drop (think s) n = (drop s n).think := by induction n <;> simp [*, drop]\n#align dropn_think dropn_think\n\n",
 "dropn_tail":
 "theorem dropn_tail (s : wseq α) (n) : drop (tail s) n = drop s (n + 1) := by rw [add_comm] <;> symm <;> apply dropn_add\n#align dropn_tail dropn_tail\n\n",
 "dropn_of_seq":
 "@[simp]\ntheorem dropn_of_seq (s : seq α) : ∀ n, drop (of_seq s) n = of_seq (s.drop n)\n  | 0 => rfl\n  | n + 1 => by dsimp [drop] <;> rw [dropn_of_seq, tail_of_seq]\n#align dropn_of_seq dropn_of_seq\n\n",
 "dropn_nil":
 "@[simp]\ntheorem dropn_nil (n) : drop (nil : wseq α) n = nil := by induction n <;> simp [*, drop]\n#align dropn_nil dropn_nil\n\n",
 "dropn_cons":
 "@[simp]\ntheorem dropn_cons (a : α) (s) (n) : drop (cons a s) (n + 1) = drop s n := by induction n <;> simp [*, drop]\n#align dropn_cons dropn_cons\n\n",
 "dropn_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem dropn_congr {s t : wseq α} (h : equiv s t) (n) : equiv (drop s n) (drop t n) := by\n  induction n <;> simp [*, tail_congr]\n#align dropn_congr dropn_congr\n\n",
 "dropn_add":
 "theorem dropn_add (s : wseq α) (m) : ∀ n, drop s (m + n) = drop (drop s m) n\n  | 0 => rfl\n  | n + 1 => congr_arg tail (dropn_add n)\n#align dropn_add dropn_add\n\n",
 "destruct_think":
 "@[simp]\ntheorem destruct_think (s : wseq α) : destruct (think s) = (destruct s).think :=\n  computation.destruct_eq_think <| by simp [destruct, think, computation.rmap]\n#align destruct_think destruct_think\n\n",
 "destruct_terminates_of_nth_terminates":
 "theorem destruct_terminates_of_nth_terminates {s : wseq α} {n} (T : terminates (nth s n)) : terminates (destruct s) :=\n  (head_terminates_iff _).1 <| head_terminates_of_nth_terminates T\n#align destruct_terminates_of_nth_terminates destruct_terminates_of_nth_terminates\n\n",
 "destruct_tail":
 "theorem destruct_tail (s : wseq α) : destruct (tail s) = destruct s >>= tail.aux :=\n  by\n  simp [tail]; rw [← bind_pure_comp_eq_map, is_lawful_monad.bind_assoc]\n  apply congr_arg; ext1 (_ | ⟨a, s⟩) <;> apply (@pure_bind computation _ _ _ _ _ _).trans _ <;> simp\n#align destruct_tail destruct_tail\n\n",
 "destruct_some_of_destruct_tail_some":
 "theorem destruct_some_of_destruct_tail_some {s : wseq α} {a} (h : some a ∈ destruct (tail s)) :\n    ∃ a', some a' ∈ destruct s := by\n  unfold tail functor.map at h; simp at h\n  rcases exists_of_mem_bind h with ⟨t, tm, td⟩; clear h\n  rcases exists_of_mem_map tm with ⟨t', ht', ht2⟩; clear tm\n  cases' t' with t' <;> rw [← ht2] at td <;> simp at td\n  · have := mem_unique td (ret_mem _)\n    contradiction\n  · exact ⟨_, ht'⟩\n#align destruct_some_of_destruct_tail_some destruct_some_of_destruct_tail_some\n\n",
 "destruct_of_seq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem destruct_of_seq (s : seq α) : destruct (of_seq s) = (exprreturn) (s.head.map fun a => (a, of_seq s.tail)) :=\n  destruct_eq_ret <| by\n    simp [of_seq, head, destruct, seq.destruct, seq.head]\n    rw [show seq.nth (some <$> s) 0 = some <$> seq.nth s 0 by apply seq.map_nth]\n    cases' seq.nth s 0 with a; · rfl\n    unfold functor.map\n    simp [destruct]\n#align destruct_of_seq destruct_of_seq\n\n",
 "destruct_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem destruct_nil : destruct (nil : wseq α) = (exprreturn) none :=\n  computation.destruct_eq_ret rfl\n#align destruct_nil destruct_nil\n\n",
 "destruct_map":
 "theorem destruct_map (f : α → β) (s : wseq α) :\n    destruct (map f s) = computation.map (option.map (prod.map f (map f))) (destruct s) :=\n  by\n  apply\n    eq_of_bisim fun c1 c2 =>\n      ∃ s, c1 = destruct (map f s) ∧ c2 = computation.map (option.map (prod.map f (map f))) (destruct s)\n  · intro c1 c2 h\n    cases' h with s h\n    rw [h.left, h.right]\n    apply s.rec_on _ (fun a s => _) fun s => _ <;> simp\n    exact ⟨s, rfl, rfl⟩\n  · exact ⟨s, rfl, rfl⟩\n#align destruct_map destruct_map\n\n",
 "destruct_join":
 "theorem destruct_join (S : wseq (wseq α)) : destruct (join S) = (destruct S).bind destruct_join.aux :=\n  by\n  apply\n    eq_of_bisim (fun c1 c2 => c1 = c2 ∨ ∃ S, c1 = destruct (join S) ∧ c2 = (destruct S).bind destruct_join.aux) _\n      (or.inr ⟨S, rfl, rfl⟩)\n  intro c1 c2 h;\n  exact\n    match c1, c2, h with\n    | _, _, or.inl <| eq.refl c => by cases c.destruct <;> simp\n    | _, _, or.inr ⟨S, rfl, rfl⟩ => by\n      apply S.rec_on _ (fun s S => _) fun S => _ <;> simp\n      · refine' or.inr ⟨S, rfl, rfl⟩\n#align destruct_join destruct_join\n\n",
 "destruct_flatten":
 "@[simp]\ntheorem destruct_flatten (c : computation (wseq α)) : destruct (flatten c) = c >>= destruct :=\n  by\n  refine'\n    computation.eq_of_bisim (fun c1 c2 => c1 = c2 ∨ ∃ c, c1 = destruct (flatten c) ∧ c2 = computation.bind c destruct) _\n      (or.inr ⟨c, rfl, rfl⟩)\n  intro c1 c2 h;\n  exact\n    match c1, c2, h with\n    | _, _, or.inl <| eq.refl c => by cases c.destruct <;> simp\n    | _, _, or.inr ⟨c, rfl, rfl⟩ =>\n      by\n      apply c.rec_on (fun a => _) fun c' => _ <;> repeat' simp\n      · cases (destruct a).destruct <;> simp\n      · exact or.inr ⟨c', rfl, rfl⟩\n#align destruct_flatten destruct_flatten\n\n",
 "destruct_dropn":
 "theorem destruct_dropn : ∀ (s : wseq α) (n), destruct (drop s n) = destruct s >>= drop.aux n\n  | s, 0 => (bind_ret' _).symm\n  | s, n + 1 => by rw [← dropn_tail, destruct_dropn _ n, destruct_tail, is_lawful_monad.bind_assoc] <;> rfl\n#align destruct_dropn destruct_dropn\n\n",
 "destruct_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n@[simp]\ntheorem destruct_cons (a : α) (s) : destruct (cons a s) = (exprreturn) (some (a, s)) :=\n  computation.destruct_eq_ret <| by simp [destruct, cons, computation.rmap]\n#align destruct_cons destruct_cons\n\n",
 "destruct_congr_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `equiv -/\ntheorem destruct_congr_iff {s t : wseq α} :\n    equiv s t ↔ computation.lift_rel (bisim_o (equiv · ·)) (destruct s) (destruct t) :=\n  lift_rel_destruct_iff\n#align destruct_congr_iff destruct_congr_iff\n\n",
 "destruct_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:228:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `equiv -/\ntheorem destruct_congr {s t : wseq α} :\n    equiv s t → computation.lift_rel (bisim_o (equiv · ·)) (destruct s) (destruct t) :=\n  lift_rel_destruct\n#align destruct_congr destruct_congr\n\n",
 "destruct_append":
 "theorem destruct_append (s t : wseq α) : destruct (append s t) = (destruct s).bind (destruct_append.aux t) :=\n  by\n  apply\n    eq_of_bisim (fun c1 c2 => ∃ s t, c1 = destruct (append s t) ∧ c2 = (destruct s).bind (destruct_append.aux t)) _\n      ⟨s, t, rfl, rfl⟩\n  intro c1 c2 h; rcases h with ⟨s, t, h⟩; rw [h.left, h.right]\n  apply s.rec_on _ (fun a s => _) fun s => _ <;> simp\n  · apply t.rec_on _ (fun b t => _) fun t => _ <;> simp\n    · refine' ⟨nil, t, _, _⟩ <;> simp\n  · exact ⟨s, t, rfl, rfl⟩\n#align destruct_append destruct_append\n\n",
 "cons_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\ntheorem cons_congr {s t : wseq α} (a : α) (h : equiv s t) : equiv (cons a s) (cons a t) := by\n  unfold equiv <;> simp <;> exact h\n#align cons_congr cons_congr\n\n",
 "cons_append":
 "@[simp]\ntheorem cons_append (a : α) (s t) : append (cons a s) t = cons a (append s t) :=\n  seq.cons_append _ _ _\n#align cons_append cons_append\n\n",
 "bind_ret":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem bind_ret (f : α → β) (s) : equiv (bind s (ret ∘ f)) (map f s) :=\n  by\n  dsimp [bind]; change fun x => ret (f x) with ret ∘ f\n  rw [map_comp]; apply join_map_ret\n#align bind_ret bind_ret\n\n",
 "bind_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n#print bind_congr /-\ntheorem bind_congr {s1 s2 : wseq α} {f1 f2 : α → wseq β} (h1 : equiv s1 s2) (h2 : ∀ a, equiv (f1 a) (f2 a)) :\n    equiv (bind s1 f1) (bind s2 f2) :=\n  lift_rel_bind _ _ h1 fun a b h => by rw [h] <;> apply h2\n#align bind_congr bind_congr\n-/\n\n",
 "bind_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `equiv -/\n@[simp]\ntheorem bind_assoc (s : wseq α) (f : α → wseq β) (g : β → wseq γ) :\n    equiv (bind (bind s f) g) (bind s fun x : α => bind (f x) g) :=\n  by\n  simp [bind]; rw [← map_comp f (map g), map_comp (map g ∘ f) join]\n  apply join_join\n#align bind_assoc bind_assoc\n\n",
 "aux_none":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprreturn -/\ntheorem drop.aux_none : ∀ n, @drop.aux α n none = (exprreturn) none\n  | 0 => rfl\n  | n + 1 => show computation.bind ((exprreturn) none) (drop.aux n) = (exprreturn) none by rw [ret_bind, drop.aux_none]\n#align drop.aux_none drop.aux_none\n\n",
 "append_nil":
 "@[simp]\ntheorem append_nil (s : wseq α) : append s nil = s :=\n  seq.append_nil _\n#align append_nil append_nil\n\n",
 "append_assoc":
 "@[simp]\ntheorem append_assoc (s t u : wseq α) : append (append s t) u = append s (append t u) :=\n  seq.append_assoc _ _ _\n#align append_assoc append_assoc\n\n"}