{"weak_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem bounded.weak_right : ∀ {t : Ordnode α} {o₁ o₂}, bounded t o₁ o₂ → bounded t o₁ («expr⊤»)\n  | nil, o₁, o₂, h => by cases o₁ <;> try trivial <;> exact h\n  | node s l x r, _, _, ⟨ol, or⟩ => ⟨ol, or.weak_right⟩\n#align bounded.weak_right bounded.weak_right\n\n",
 "weak_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem bounded.weak_left : ∀ {t : Ordnode α} {o₁ o₂}, bounded t o₁ o₂ → bounded t («expr⊥») o₂\n  | nil, o₁, o₂, h => by cases o₂ <;> try trivial <;> exact h\n  | node s l x r, _, _, ⟨ol, or⟩ => ⟨ol.weak_left, or⟩\n#align bounded.weak_left bounded.weak_left\n\n",
 "weak":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem bounded.weak {t : Ordnode α} {o₁ o₂} (h : bounded t o₁ o₂) : bounded t («expr⊥») («expr⊤») :=\n  h.weak_left.weak_right\n#align bounded.weak bounded.weak\n\n",
 "valid_singleton":
 "theorem valid_singleton {x : α} : valid (singleton x : Ordnode α) :=\n  valid'_singleton ⟨⟩ ⟨⟩\n#align valid_singleton valid_singleton\n\n",
 "valid_nil":
 "theorem valid_nil : valid (@nil α) :=\n  valid'_nil ⟨⟩\n#align valid_nil valid_nil\n\n",
 "valid_aux":
 "theorem insert_with.valid_aux [is_total α (· ≤ ·)] [@DecidableRel α (· ≤ ·)] (f : α → α) (x : α)\n    (hf : ∀ y, x ≤ y ∧ y ≤ x → x ≤ f y ∧ f y ≤ x) :\n    ∀ {t o₁ o₂},\n      valid' o₁ t o₂ →\n        bounded nil o₁ ↑x →\n          bounded nil (↑x) o₂ → valid' o₁ (insertWith f x t) o₂ ∧ raised (size t) (size (insertWith f x t))\n  | nil, o₁, o₂, _, bl, br => ⟨valid'_singleton bl br, or.inr rfl⟩\n  | node sz l y r, o₁, o₂, h, bl, br => by\n    rw [insert_with, cmpLE]\n    split_ifs <;> rw [insert_with]\n    · rcases h with ⟨⟨lx, xr⟩, hs, hb⟩\n      rcases hf _ ⟨h_1, h_2⟩ with ⟨xf, fx⟩\n      refine' ⟨⟨⟨lx.mono_right (le_trans h_2 xf), xr.mono_left (le_trans fx h_1)⟩, hs, hb⟩, or.inl rfl⟩\n    · rcases insert_with.valid_aux h.left bl (lt_of_le_not_le h_1 h_2) with ⟨vl, e⟩\n      suffices H\n      · refine' ⟨vl.balance_l h.right H, _⟩\n        rw [size_balance_l vl.3 h.3.2.2 vl.2 h.2.2.2 H, h.2.size_eq]\n        refine' (e.add_right _).add_right _\n      · exact or.inl ⟨_, e, h.3.1⟩\n    · have : y < x := lt_of_le_not_le ((total_of (· ≤ ·) _ _).resolve_left h_1) h_1\n      rcases insert_with.valid_aux h.right this br with ⟨vr, e⟩\n      suffices H\n      · refine' ⟨h.left.balance_r vr H, _⟩\n        rw [size_balance_r h.3.2.1 vr.3 h.2.2.1 vr.2 H, h.2.size_eq]\n        refine' (e.add_left _).add_right _\n      · exact or.inr ⟨_, e, h.3.1⟩\n#align insert_with.valid_aux insert_with.valid_aux\n\n",
 "valid'_singleton":
 "theorem valid'_singleton {x : α} {o₁ o₂} (h₁ : bounded nil o₁ ↑x) (h₂ : bounded nil (↑x) o₂) :\n    valid' o₁ (singleton x : Ordnode α) o₂ :=\n  (valid'_nil h₁).node (valid'_nil h₂) (or.inl zero_le_one) rfl\n#align valid'_singleton valid'_singleton\n\n",
 "valid'_nil":
 "theorem valid'_nil {o₁ o₂} (h : bounded nil o₁ o₂) : valid' o₁ (@nil α) o₂ :=\n  ⟨h, ⟨⟩, ⟨⟩⟩\n#align valid'_nil valid'_nil\n\n",
 "valid":
 "theorem erase.valid [@DecidableRel α (· ≤ ·)] (x : α) {t} (h : valid t) : valid (erase x t) :=\n  (valid'.erase_aux x h).1\n#align erase.valid erase.valid\n\n",
 "trans_right":
 "theorem valid'.trans_right {t₁ t₂ : Ordnode α} {x : α} {o₁ o₂} (H : valid' o₁ t₁ ↑x) (h : bounded t₂ (↑x) o₂) :\n    valid' o₁ t₁ o₂ :=\n  ⟨H.1.trans_right h, H.2, H.3⟩\n#align valid'.trans_right valid'.trans_right\n\n",
 "trans_left":
 "theorem valid'.trans_left {t₁ t₂ : Ordnode α} {x : α} {o₁ o₂} (h : bounded t₁ o₁ ↑x) (H : valid' (↑x) t₂ o₂) :\n    valid' o₁ t₂ o₂ :=\n  ⟨h.trans_left H.1, H.2, H.3⟩\n#align valid'.trans_left valid'.trans_left\n\n",
 "to_sep":
 "theorem bounded.to_sep {t₁ t₂ o₁ o₂} {x : α} (h₁ : bounded t₁ o₁ ↑x) (h₂ : bounded t₂ (↑x) o₂) :\n    t₁.all fun y => t₂.all fun z : α => y < z :=\n  h₁.mem_lt.imp fun y yx => h₂.mem_gt.imp fun z xz => lt_trans yx xz\n#align bounded.to_sep bounded.to_sep\n\n",
 "to_nil":
 "theorem bounded.to_nil {t : Ordnode α} : ∀ {o₁ o₂}, bounded t o₁ o₂ → bounded nil o₁ o₂\n  | none, _, h => ⟨⟩\n  | some _, none, h => ⟨⟩\n  | some x, some y, h => h.to_lt\n#align bounded.to_nil bounded.to_nil\n\n",
 "to_lt":
 "theorem bounded.to_lt : ∀ {t : Ordnode α} {x y : α}, bounded t x y → x < y\n  | nil, x, y, h => h\n  | node _ l y r, x, z, ⟨h₁, h₂⟩ => lt_trans h₁.to_lt h₂.to_lt\n#align bounded.to_lt bounded.to_lt\n\n",
 "to_list_node":
 "@[simp]\ntheorem to_list_node (s l x r) : toList (@node α s l x r) = toList l ++ x :: toList r := by\n  rw [to_list, foldr, foldr_cons_eq_to_list] <;> rfl\n#align to_list_node to_list_node\n\n",
 "to_list_nil":
 "@[simp]\ntheorem to_list_nil : toList (@nil α) = [] :=\n  rfl\n#align to_list_nil to_list_nil\n\n",
 "symm":
 "theorem balanced_sz.symm {l r : ℕ} : balanced_sz l r → balanced_sz r l :=\n  Or.imp (by rw [add_comm] <;> exact id) And.symm\n#align balanced_sz.symm balanced_sz.symm\n\n",
 "split_min_eq":
 "theorem split_min_eq : ∀ (s l) (x : α) (r), splitMin' l x r = (findMin' l x, eraseMin (node s l x r))\n  | _, nil, x, r => rfl\n  | _, node ls ll lx lr, x, r => by rw [split_min', split_min_eq, split_min', find_min', erase_min]\n#align split_min_eq split_min_eq\n\n",
 "split_max_eq":
 "theorem split_max_eq : ∀ (s l) (x : α) (r), splitMax' l x r = (eraseMax (node s l x r), findMax' x r)\n  | _, l, x, nil => rfl\n  | _, l, x, node ls ll lx lr => by rw [split_max', split_max_eq, split_max', find_max', erase_max]\n#align split_max_eq split_max_eq\n\n",
 "size_erase_of_mem":
 "theorem size_erase_of_mem [@DecidableRel α (· ≤ ·)] {x : α} {t a₁ a₂} (h : valid' a₁ t a₂) (h_mem : x ∈ t) :\n    size (erase x t) = size t - 1 := by\n  induction t generalizing a₁ a₂ h h_mem\n  · contradiction\n  · have t_ih_l' := t_ih_l h.left\n    have t_ih_r' := t_ih_r h.right\n    clear t_ih_l t_ih_r\n    unfold has_mem.mem mem at h_mem\n    unfold erase\n    cases cmpLE x t_x <;> simp [mem._match_1] at h_mem <;> simp [erase._match_1]\n    · have t_ih_l := t_ih_l' h_mem\n      clear t_ih_l' t_ih_r'\n      have t_l_h := valid'.erase_aux x h.left\n      cases' t_l_h with t_l_valid t_l_size\n      rw [size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz\n          (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1)))]\n      rw [t_ih_l, h.sz.1]\n      have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem\n      cases' t_l.size with t_l_size\n      · cases h_pos_t_l_size\n      simp [nat.succ_add]\n    · rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1]\n      rfl\n    · have t_ih_r := t_ih_r' h_mem\n      clear t_ih_l' t_ih_r'\n      have t_r_h := valid'.erase_aux x h.right\n      cases' t_r_h with t_r_valid t_r_size\n      rw [size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz\n          (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1)))]\n      rw [t_ih_r, h.sz.1]\n      have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem\n      cases' t_r.size with t_r_size\n      · cases h_pos_t_r_size\n      simp [nat.succ_add, nat.add_succ]\n#align size_erase_of_mem size_erase_of_mem\n\n",
 "size_eq_zero":
 "@[simp]\ntheorem sized.size_eq_zero {t : Ordnode α} (ht : sized t) : size t = 0 ↔ t = nil := by cases t <;> [simp, simp [ht.1]]\n#align sized.size_eq_zero sized.size_eq_zero\n\n",
 "size_eq_real_size":
 "theorem size_eq_real_size : ∀ {t : Ordnode α}, sized t → size t = real_size t\n  | nil, _ => rfl\n  | node s l x r, ⟨h₁, h₂, h₃⟩ => by rw [size, h₁, size_eq_real_size h₂, size_eq_real_size h₃] <;> rfl\n#align size_eq_real_size size_eq_real_size\n\n",
 "size_eq":
 "theorem valid.size_eq {s l x r} (H : valid (@node α s l x r)) : size (@node α s l x r) = size l + size r + 1 :=\n  H.2.1\n#align valid.size_eq valid.size_eq\n\n",
 "size_dual":
 "@[simp]\ntheorem size_dual (t : Ordnode α) : size (dual t) = size t := by cases t <;> rfl\n#align size_dual size_dual\n\n",
 "size_balance_r":
 "theorem size_balance_r {l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r)\n    (H : (∃ l', raised (size l) l' ∧ balanced_sz l' (size r)) ∨ ∃ r', raised r' (size r) ∧ balanced_sz (size l) r') :\n    size (@balanceR α l x r) = size l + size r + 1 := by rw [balance_r_eq_balance' hl hr sl sr H, size_balance' sl sr]\n#align size_balance_r size_balance_r\n\n",
 "size_balance_l":
 "theorem size_balance_l {l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r)\n    (H : (∃ l', raised l' (size l) ∧ balanced_sz l' (size r)) ∨ ∃ r', raised (size r) r' ∧ balanced_sz (size l) r') :\n    size (@balanceL α l x r) = size l + size r + 1 := by rw [balance_l_eq_balance' hl hr sl sr H, size_balance' sl sr]\n#align size_balance_l size_balance_l\n\n",
 "size_balance'":
 "theorem size_balance' {l x r} (hl : @sized α l) (hr : sized r) : size (@balance' α l x r) = size l + size r + 1 :=\n  by\n  unfold balance'; split_ifs\n  · rfl\n  · exact hr.rotate_l_size\n  · exact hl.rotate_r_size\n  · rfl\n#align size_balance' size_balance'\n\n",
 "rotate_r_size":
 "theorem sized.rotate_r_size {l x r} (hl : sized l) : size (@rotate_r α l x r) = size l + size r + 1 := by\n  rw [← size_dual, dual_rotate_r, hl.dual.rotate_l_size, size_dual, size_dual, add_comm (size l)]\n#align sized.rotate_r_size sized.rotate_r_size\n\n",
 "rotate_r":
 "theorem valid'.rotate_r {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂) (H1 : ¬size l + size r ≤ 1)\n    (H2 : delta * size r < size l) (H3 : 2 * size l ≤ 9 * size r + 5 ∨ size l ≤ 3) : valid' o₁ (@rotate_r α l x r) o₂ :=\n  by\n  refine' valid'.dual_iff.2 _\n  rw [dual_rotate_r]\n  refine' hr.dual.rotate_l hl.dual _ _ _\n  · rwa [size_dual, size_dual, add_comm]\n  · rwa [size_dual, size_dual]\n  · rwa [size_dual, size_dual]\n#align valid'.rotate_r valid'.rotate_r\n\n",
 "rotate_l_size":
 "theorem sized.rotate_l_size {l x r} (hm : sized r) : size (@rotate_l α l x r) = size l + size r + 1 :=\n  by\n  cases r <;> simp [rotate_l]\n  simp [size, hm.1, add_comm, add_left_comm]; rw [← add_assoc, ← bit0]; simp\n  split_ifs <;> simp [node3_l_size, node4_l_size hm.2.1, add_comm, add_left_comm]\n#align sized.rotate_l_size sized.rotate_l_size\n\n",
 "rotate_l_lemma₄":
 "theorem valid'.rotate_l_lemma₄ {a b : ℕ} (H3 : 2 * b ≤ 9 * a + 3) : 3 * b ≤ 16 * a + 9 := by linarith\n#align valid'.rotate_l_lemma₄ valid'.rotate_l_lemma₄\n\n",
 "rotate_l_lemma₃":
 "theorem valid'.rotate_l_lemma₃ {a b c : ℕ} (H2 : 3 * a ≤ b + c) (h : b < 2 * c) : a + b < 3 * c := by linarith\n#align valid'.rotate_l_lemma₃ valid'.rotate_l_lemma₃\n\n",
 "rotate_l_lemma₂":
 "theorem valid'.rotate_l_lemma₂ {a b c : ℕ} (H3 : 2 * (b + c) ≤ 9 * a + 3) (h : b < 2 * c) : b < 3 * a + 1 := by linarith\n#align valid'.rotate_l_lemma₂ valid'.rotate_l_lemma₂\n\n",
 "rotate_l_lemma₁":
 "theorem valid'.rotate_l_lemma₁ {a b c : ℕ} (H2 : 3 * a ≤ b + c) (hb₂ : c ≤ 3 * b) : a ≤ 3 * b := by linarith\n#align valid'.rotate_l_lemma₁ valid'.rotate_l_lemma₁\n\n",
 "rotate_l":
 "theorem valid'.rotate_l {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂) (H1 : ¬size l + size r ≤ 1)\n    (H2 : delta * size l < size r) (H3 : 2 * size r ≤ 9 * size l + 5 ∨ size r ≤ 3) : valid' o₁ (@rotate_l α l x r) o₂ :=\n  by\n  cases' r with rs rl rx rr\n  · cases H2\n  rw [hr.2.size_eq, Nat.lt_succ_iff] at H2\n  rw [hr.2.size_eq] at H3\n  replace H3 : 2 * (size rl + size rr) ≤ 9 * size l + 3 ∨ size rl + size rr ≤ 2 :=\n    H3.imp (@Nat.le_of_add_le_add_right 2 _ _) nat.le_of_succ_le_succ\n  have H3_0 : size l = 0 → size rl + size rr ≤ 2 := by\n    intro l0\n    rw [l0] at H3\n    exact (or_iff_right_of_imp fun h => (mul_le_mul_left (by decide)).1 (le_trans h (by decide))).1 H3\n  have H3p : size l > 0 → 2 * (size rl + size rr) ≤ 9 * size l + 3 := fun l0 : 1 ≤ size l =>\n    (or_iff_left_of_imp <| by intro <;> linarith).1 H3\n  have ablem : ∀ {a b : ℕ}, 1 ≤ a → a + b ≤ 2 → b ≤ 1 := by\n    intros\n    linarith\n  have hlp : size l > 0 → ¬size rl + size rr ≤ 1 := fun l0 hb =>\n    absurd (le_trans (le_trans (nat.mul_le_mul_left _ l0) H2) hb) (by decide)\n  rw [rotate_l]\n  split_ifs\n  · have rr0 : size rr > 0 := (mul_lt_mul_left (by decide)).1 (lt_of_le_of_lt (nat.zero_le _) h : ratio * 0 < _)\n    suffices balanced_sz (size l) (size rl) ∧ balanced_sz (size l + size rl + 1) (size rr) by\n      exact hl.node3_l hr.left hr.right this.1 this.2\n    cases' nat.eq_zero_or_pos (size l) with l0 l0\n    · rw [l0]\n      replace H3 := H3_0 l0\n      have := hr.3.1\n      cases' nat.eq_zero_or_pos (size rl) with rl0 rl0\n      · rw [rl0] at this⊢\n        rw [le_antisymm (balanced_sz_zero.1 this.symm) rr0]\n        exact by decide\n      have rr1 : size rr = 1 := le_antisymm (ablem rl0 H3) rr0\n      rw [add_comm] at H3\n      rw [rr1, show size rl = 1 from le_antisymm (ablem rr0 H3) rl0]\n      exact by decide\n    replace H3 := H3p l0\n    rcases hr.3.1.resolve_left (hlp l0) with ⟨hb₁, hb₂⟩\n    refine' ⟨or.inr ⟨_, _⟩, or.inr ⟨_, _⟩⟩\n    · exact valid'.rotate_l_lemma₁ H2 hb₂\n    · exact nat.le_of_lt_succ (valid'.rotate_l_lemma₂ H3 h)\n    · exact valid'.rotate_l_lemma₃ H2 h\n    · exact le_trans hb₂ (nat.mul_le_mul_left _ <| le_trans (nat.le_add_left _ _) (nat.le_add_right _ _))\n  · cases' nat.eq_zero_or_pos (size rl) with rl0 rl0\n    · rw [rl0, not_lt, le_zero_iff, Nat.mul_eq_zero] at h\n      replace h := h.resolve_left (by decide)\n      rw [rl0, h, le_zero_iff, Nat.mul_eq_zero] at H2\n      rw [hr.2.size_eq, rl0, h, H2.resolve_left (by decide)] at H1\n      cases H1 (by decide)\n    refine' hl.node4_l hr.left hr.right rl0 _\n    cases' nat.eq_zero_or_pos (size l) with l0 l0\n    · replace H3 := H3_0 l0\n      cases' nat.eq_zero_or_pos (size rr) with rr0 rr0\n      · have := hr.3.1\n        rw [rr0] at this\n        exact or.inl ⟨l0, le_antisymm (balanced_sz_zero.1 this) rl0, rr0.symm ▸ zero_le_one⟩\n      exact or.inl ⟨l0, le_antisymm (ablem rr0 <| by rwa [add_comm]) rl0, ablem rl0 H3⟩\n    exact or.inr ⟨l0, not_lt.1 h, H2, valid'.rotate_l_lemma₄ (H3p l0), (hr.3.1.resolve_left (hlp l0)).1⟩\n#align valid'.rotate_l valid'.rotate_l\n\n",
 "right":
 "theorem valid.right {s l x r} (H : valid (@node α s l x r)) : valid r :=\n  H.right.valid\n#align valid.right valid.right\n\n",
 "raised_iff":
 "theorem raised_iff {n m} : raised n m ↔ n ≤ m ∧ m ≤ n + 1 :=\n  by\n  constructor; rintro (rfl | rfl)\n  · exact ⟨le_rfl, nat.le_succ _⟩\n  · exact ⟨nat.le_succ _, le_rfl⟩\n  · rintro ⟨h₁, h₂⟩\n    rcases eq_or_lt_of_le h₁ with (rfl | h₁)\n    · exact or.inl rfl\n    · exact or.inr (le_antisymm h₂ h₁)\n#align raised_iff raised_iff\n\n",
 "pos_size_of_mem":
 "theorem pos_size_of_mem {x : α} {t : ordset α} (h_mem : x ∈ t) : 0 < size t :=\n  by\n  simp [has_mem.mem, mem] at h_mem\n  apply ordnode.pos_size_of_mem t.property.sz h_mem\n#align pos_size_of_mem pos_size_of_mem\n\n",
 "pos":
 "theorem sized.pos {s l x r} (h : sized (@node α s l x r)) : 0 < s := by rw [h.1] <;> apply nat.le_add_left\n#align sized.pos sized.pos\n\n",
 "of_lt":
 "theorem valid'.of_lt {t : Ordnode α} {x : α} {o₁ o₂} (H : valid' o₁ t o₂) (h₁ : bounded nil o₁ ↑x)\n    (h₂ : All (· < x) t) : valid' o₁ t ↑x :=\n  ⟨H.1.of_lt h₁ h₂, H.2, H.3⟩\n#align valid'.of_lt valid'.of_lt\n\n",
 "of_gt":
 "theorem valid'.of_gt {t : Ordnode α} {x : α} {o₁ o₂} (H : valid' o₁ t o₂) (h₁ : bounded nil (↑x) o₂)\n    (h₂ : All (· > x) t) : valid' (↑x) t o₂ :=\n  ⟨H.1.of_gt h₁ h₂, H.2, H.3⟩\n#align valid'.of_gt valid'.of_gt\n\n",
 "not_le_delta":
 "/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem not_le_delta {s} (H : 1 ≤ s) : ¬s ≤ delta * 0 :=\n  not_le_of_gt H\n#align not_le_delta not_le_delta\n\n",
 "node4_l_size":
 "theorem node4_l_size {l x m y r} (hm : sized m) : size (@node4_l α l x m y r) = size l + size m + size r + 2 := by\n  cases m <;> simp [node4_l, node3_l, node', add_comm, add_left_comm] <;> [skip, simp [size, hm.1]] <;>\n      rw [← add_assoc, ← bit0] <;>\n    simp [add_comm, add_left_comm]\n#align node4_l_size node4_l_size\n\n",
 "node4_l_lemma₅":
 "theorem valid'.node4_l_lemma₅ {a b c d : ℕ} (lr₂ : 3 * (b + c + 1 + d) ≤ 16 * a + 9) (mr₁ : 2 * d ≤ b + c + 1)\n    (mm₂ : c ≤ 3 * b) : c + d + 1 ≤ 3 * (a + b + 1) := by linarith\n#align valid'.node4_l_lemma₅ valid'.node4_l_lemma₅\n\n",
 "node4_l_lemma₄":
 "theorem valid'.node4_l_lemma₄ {a b c d : ℕ} (lr₁ : 3 * a ≤ b + c + 1 + d) (mr₂ : b + c + 1 ≤ 3 * d) (mm₁ : b ≤ 3 * c) :\n    a + b + 1 ≤ 3 * (c + d + 1) := by linarith\n#align valid'.node4_l_lemma₄ valid'.node4_l_lemma₄\n\n",
 "node4_l_lemma₃":
 "theorem valid'.node4_l_lemma₃ {b c d : ℕ} (mr₁ : 2 * d ≤ b + c + 1) (mm₁ : b ≤ 3 * c) : d ≤ 3 * c := by linarith\n#align valid'.node4_l_lemma₃ valid'.node4_l_lemma₃\n\n",
 "node4_l_lemma₂":
 "theorem valid'.node4_l_lemma₂ {b c d : ℕ} (mr₂ : b + c + 1 ≤ 3 * d) : c ≤ 3 * d := by linarith\n#align valid'.node4_l_lemma₂ valid'.node4_l_lemma₂\n\n",
 "node4_l_lemma₁":
 "theorem valid'.node4_l_lemma₁ {a b c d : ℕ} (lr₂ : 3 * (b + c + 1 + d) ≤ 16 * a + 9) (mr₂ : b + c + 1 ≤ 3 * d)\n    (mm₁ : b ≤ 3 * c) : b < 3 * a + 1 := by linarith\n#align valid'.node4_l_lemma₁ valid'.node4_l_lemma₁\n\n",
 "node4_l":
 "theorem valid'.node4_l {l x m y r o₁ o₂} (hl : valid' o₁ l ↑x) (hm : valid' (↑x) m ↑y) (hr : valid' (↑y) r o₂)\n    (Hm : 0 < size m)\n    (H :\n      size l = 0 ∧ size m = 1 ∧ size r ≤ 1 ∨\n        0 < size l ∧\n          ratio * size r ≤ size m ∧\n            delta * size l ≤ size m + size r ∧ 3 * (size m + size r) ≤ 16 * size l + 9 ∧ size m ≤ delta * size r) :\n    valid' o₁ (@node4_l α l x m y r) o₂ := by\n  cases' m with s ml z mr; · cases Hm\n  suffices :\n    balanced_sz (size l) (size ml) ∧\n      balanced_sz (size mr) (size r) ∧ balanced_sz (size l + size ml + 1) (size mr + size r + 1)\n  exact valid'.node' (hl.node' hm.left this.1) (hm.right.node' hr this.2.1) this.2.2\n  rcases H with (⟨l0, m1, r0⟩ | ⟨l0, mr₁, lr₁, lr₂, mr₂⟩)\n  · rw [hm.2.size_eq, Nat.succ_inj', add_eq_zero_iff] at m1\n    rw [l0, m1.1, m1.2]\n    rcases size r with (_ | _ | _) <;> exact by decide\n  · cases' nat.eq_zero_or_pos (size r) with r0 r0\n    · rw [r0] at mr₂\n      cases not_le_of_lt Hm mr₂\n    rw [hm.2.size_eq] at lr₁ lr₂ mr₁ mr₂\n    by_cases mm : size ml + size mr ≤ 1\n    · have r1 := le_antisymm ((mul_le_mul_left (by decide)).1 (le_trans mr₁ (nat.succ_le_succ mm) : _ ≤ ratio * 1)) r0\n      rw [r1, add_assoc] at lr₁\n      have l1 := le_antisymm ((mul_le_mul_left (by decide)).1 (le_trans lr₁ (add_le_add_right mm 2) : _ ≤ delta * 1)) l0\n      rw [l1, r1]\n      cases size ml <;> cases size mr\n      · exact by decide\n      · rw [zero_add] at mm\n        rcases mm with (_ | ⟨⟨⟩⟩)\n        exact by decide\n      · rcases mm with (_ | ⟨⟨⟩⟩)\n        exact by decide\n      · rw [nat.succ_add] at mm\n        rcases mm with (_ | ⟨⟨⟩⟩)\n    rcases hm.3.1.resolve_left mm with ⟨mm₁, mm₂⟩\n    cases' nat.eq_zero_or_pos (size ml) with ml0 ml0\n    · rw [ml0, MulZeroClass.mul_zero, le_zero_iff] at mm₂\n      rw [ml0, mm₂] at mm\n      cases mm (by decide)\n    have : 2 * size l ≤ size ml + size mr + 1 :=\n      by\n      have := nat.mul_le_mul_left _ lr₁\n      rw [mul_left_comm, mul_add] at this\n      have := le_trans this (add_le_add_left mr₁ _)\n      rw [← nat.succ_mul] at this\n      exact (mul_le_mul_left (by decide)).1 this\n    refine' ⟨or.inr ⟨_, _⟩, or.inr ⟨_, _⟩, or.inr ⟨_, _⟩⟩\n    · refine' (mul_le_mul_left (by decide)).1 (le_trans this _)\n      rw [two_mul, Nat.succ_le_iff]\n      refine' add_lt_add_of_lt_of_le _ mm₂\n      simpa using (mul_lt_mul_right ml0).2 (by decide : 1 < 3)\n    · exact nat.le_of_lt_succ (valid'.node4_l_lemma₁ lr₂ mr₂ mm₁)\n    · exact valid'.node4_l_lemma₂ mr₂\n    · exact valid'.node4_l_lemma₃ mr₁ mm₁\n    · exact valid'.node4_l_lemma₄ lr₁ mr₂ mm₁\n    · exact valid'.node4_l_lemma₅ lr₂ mr₁ mm₂\n#align valid'.node4_l valid'.node4_l\n\n",
 "node3_r_size":
 "theorem node3_r_size {l x m y r} : size (@node3_r α l x m y r) = size l + size m + size r + 2 := by\n  dsimp [node3_r, node', size] <;> rw [← add_assoc, ← add_assoc]\n#align node3_r_size node3_r_size\n\n",
 "node3_r":
 "theorem valid'.node3_r {l x m y r o₁ o₂} (hl : valid' o₁ l ↑x) (hm : valid' (↑x) m ↑y) (hr : valid' (↑y) r o₂)\n    (H1 : balanced_sz (size l) (size m + size r + 1)) (H2 : balanced_sz (size m) (size r)) :\n    valid' o₁ (@node3_r α l x m y r) o₂ :=\n  hl.node' (hm.node' hr H2) H1\n#align valid'.node3_r valid'.node3_r\n\n",
 "node3_l_size":
 "theorem node3_l_size {l x m y r} : size (@node3_l α l x m y r) = size l + size m + size r + 2 := by\n  dsimp [node3_l, node', size] <;> rw [add_right_comm _ 1]\n#align node3_l_size node3_l_size\n\n",
 "node3_l":
 "theorem valid'.node3_l {l x m y r o₁ o₂} (hl : valid' o₁ l ↑x) (hm : valid' (↑x) m ↑y) (hr : valid' (↑y) r o₂)\n    (H1 : balanced_sz (size l) (size m)) (H2 : balanced_sz (size l + size m + 1) (size r)) :\n    valid' o₁ (@node3_l α l x m y r) o₂ :=\n  (hl.node' hm H1).node' hr H2\n#align valid'.node3_l valid'.node3_l\n\n",
 "node'":
 "theorem valid'.node' {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂) (H : balanced_sz (size l) (size r)) :\n    valid' o₁ (@node' α l x r) o₂ :=\n  hl.node hr H rfl\n#align valid'.node' valid'.node'\n\n",
 "node":
 "theorem valid'.node {s l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂) (H : balanced_sz (size l) (size r))\n    (hs : s = size l + size r + 1) : valid' o₁ (@node α s l x r) o₂ :=\n  ⟨⟨hl.1, hr.1⟩, ⟨hs, hl.2, hr.2⟩, ⟨H, hl.3, hr.3⟩⟩\n#align valid'.node valid'.node\n\n",
 "mono_right":
 "theorem valid'.mono_right {x y : α} (xy : x ≤ y) {t : Ordnode α} {o} (h : valid' o t ↑x) : valid' o t ↑y :=\n  ⟨h.1.mono_right xy, h.2, h.3⟩\n#align valid'.mono_right valid'.mono_right\n\n",
 "mono_left":
 "theorem valid'.mono_left {x y : α} (xy : x ≤ y) {t : Ordnode α} {o} (h : valid' (↑y) t o) : valid' (↑x) t o :=\n  ⟨h.1.mono_left xy, h.2, h.3⟩\n#align valid'.mono_left valid'.mono_left\n\n",
 "merge_node":
 "@[simp]\ntheorem merge_node {ls ll lx lr rs rl rx rr} :\n    merge (@node α ls ll lx lr) (node rs rl rx rr) =\n      if delta * ls < rs then balanceL (merge (node ls ll lx lr) rl) rx rr\n      else\n        if delta * rs < ls then balanceR ll lx (merge lr (node rs rl rx rr))\n        else glue (node ls ll lx lr) (node rs rl rx rr) :=\n  rfl\n#align merge_node merge_node\n\n",
 "merge_nil_right":
 "@[simp]\ntheorem merge_nil_right (t : Ordnode α) : merge nil t = t :=\n  rfl\n#align merge_nil_right merge_nil_right\n\n",
 "merge_nil_left":
 "@[simp]\ntheorem merge_nil_left (t : Ordnode α) : merge t nil = t := by cases t <;> rfl\n#align merge_nil_left merge_nil_left\n\n",
 "merge_lemma":
 "theorem valid'.merge_lemma {a b c : ℕ} (h₁ : 3 * a < b + c + 1) (h₂ : b ≤ 3 * c) : 2 * (a + b) ≤ 9 * c + 5 := by\n  linarith\n#align valid'.merge_lemma valid'.merge_lemma\n\n",
 "merge_aux₁":
 "theorem valid'.merge_aux₁ {o₁ o₂ ls ll lx lr rs rl rx rr t} (hl : valid' o₁ (@node α ls ll lx lr) o₂)\n    (hr : valid' o₁ (node rs rl rx rr) o₂) (h : delta * ls < rs) (v : valid' o₁ t ↑rx) (e : size t = ls + size rl) :\n    valid' o₁ (balanceL t rx rr) o₂ ∧ size (balanceL t rx rr) = ls + rs :=\n  by\n  rw [hl.2.1] at e\n  rw [hl.2.1, hr.2.1, delta] at h\n  rcases hr.3.1 with (H | ⟨hr₁, hr₂⟩); · linarith\n  suffices H₂; suffices H₁\n  refine' ⟨valid'.balance_l_aux v hr.right H₁ H₂ _, _⟩\n  · rw [e]\n    exact or.inl (valid'.merge_lemma h hr₁)\n  · rw [balance_l_eq_balance v.2 hr.2.2.2 H₁ H₂, balance_eq_balance' v.3 hr.3.2.2 v.2 hr.2.2.2,\n      size_balance' v.2 hr.2.2.2, e, hl.2.1, hr.2.1]\n    simp [add_comm, add_left_comm]\n  · rw [e, add_right_comm]\n    rintro ⟨⟩\n  · intro _ h₁\n    rw [e]\n    unfold delta at hr₂⊢\n    linarith\n#align valid'.merge_aux₁ valid'.merge_aux₁\n\n",
 "merge_aux":
 "theorem valid'.merge_aux {l r o₁ o₂} (hl : valid' o₁ l o₂) (hr : valid' o₁ r o₂)\n    (sep : l.all fun x => r.all fun y => x < y) : valid' o₁ (@merge α l r) o₂ ∧ size (merge l r) = size l + size r :=\n  by\n  induction' l with ls ll lx lr IHll IHlr generalizing o₁ o₂ r\n  · exact ⟨hr, (zero_add _).symm⟩\n  induction' r with rs rl rx rr IHrl IHrr generalizing o₁ o₂\n  · exact ⟨hl, rfl⟩\n  rw [merge_node]; split_ifs\n  · cases' IHrl (sep.imp fun x h => h.1) (hl.of_lt hr.1.1.to_nil <| sep.imp fun x h => h.2.1) hr.left with v e\n    exact valid'.merge_aux₁ hl hr h v e\n  · cases' IHlr hl.right (hr.of_gt hl.1.2.to_nil sep.2.1) sep.2.2 with v e\n    have := valid'.merge_aux₁ hr.dual hl.dual h_1 v.dual\n    rw [size_dual, add_comm, size_dual, ← dual_balance_r, ← valid'.dual_iff, size_dual, add_comm rs] at this\n    exact this e\n  · refine' valid'.glue_aux hl hr sep (or.inr ⟨not_lt.1 h_1, not_lt.1 h⟩)\n#align valid'.merge_aux valid'.merge_aux\n\n",
 "merge":
 "theorem valid.merge {l r} (hl : valid l) (hr : valid r) (sep : l.all fun x => r.all fun y => x < y) :\n    valid (@merge α l r) :=\n  (valid'.merge_aux hl hr sep).1\n#align valid.merge valid.merge\n\n",
 "mem_lt":
 "theorem bounded.mem_lt : ∀ {t o} {x : α}, bounded t o ↑x → All (· < x) t\n  | nil, o, x, _ => ⟨⟩\n  | node _ l y r, o, x, ⟨h₁, h₂⟩ => ⟨h₁.mem_lt.imp fun z h => lt_trans h h₂.to_lt, h₂.to_lt, h₂.mem_lt⟩\n#align bounded.mem_lt bounded.mem_lt\n\n",
 "mem_gt":
 "theorem bounded.mem_gt : ∀ {t o} {x : α}, bounded t (↑x) o → All (· > x) t\n  | nil, o, x, _ => ⟨⟩\n  | node _ l y r, o, x, ⟨h₁, h₂⟩ => ⟨h₁.mem_gt, h₁.to_lt, h₂.mem_gt.imp fun z => lt_trans h₁.to_lt⟩\n#align bounded.mem_gt bounded.mem_gt\n\n",
 "map_aux":
 "theorem valid'.map_aux {β} [preorder β] {f : α → β} (f_strict_mono : StrictMono f) {t a₁ a₂} (h : valid' a₁ t a₂) :\n    valid' (option.map f a₁) (map f t) (option.map f a₂) ∧ (map f t).size = t.size :=\n  by\n  induction t generalizing a₁ a₂\n  · simp [map]\n    apply valid'_nil\n    cases a₁\n    · trivial\n    cases a₂\n    · trivial\n    simp [bounded]\n    exact f_strict_mono h.ord\n  · have t_ih_l' := t_ih_l h.left\n    have t_ih_r' := t_ih_r h.right\n    clear t_ih_l t_ih_r\n    cases' t_ih_l' with t_l_valid t_l_size\n    cases' t_ih_r' with t_r_valid t_r_size\n    simp [map]\n    constructor\n    · exact and.intro t_l_valid.ord t_r_valid.ord\n    · repeat' constructor\n      · rw [t_l_size, t_r_size]\n        exact h.sz.1\n      · exact t_l_valid.sz\n      · exact t_r_valid.sz\n    · repeat' constructor\n      · rw [t_l_size, t_r_size]\n        exact h.bal.1\n      · exact t_l_valid.bal\n      · exact t_r_valid.bal\n#align valid'.map_aux valid'.map_aux\n\n",
 "length_to_list'":
 "theorem length_to_list' : ∀ t : Ordnode α, (toList t).length = t.real_size\n  | nil => rfl\n  | node _ l _ r => by rw [to_list_node, list.length_append, list.length_cons, length_to_list', length_to_list'] <;> rfl\n#align length_to_list' length_to_list'\n\n",
 "length_to_list":
 "theorem length_to_list {t : Ordnode α} (h : sized t) : (toList t).length = t.size := by\n  rw [length_to_list', size_eq_real_size h]\n#align length_to_list length_to_list\n\n",
 "left":
 "theorem valid.left {s l x r} (H : valid (@node α s l x r)) : valid l :=\n  H.left.valid\n#align valid.left valid.left\n\n",
 "insert_eq_insert_with":
 "theorem insert_eq_insert_with [@DecidableRel α (· ≤ ·)] (x : α) : ∀ t, Ordnode.insert x t = insertWith (fun _ => x) x t\n  | nil => rfl\n  | node _ l y r => by\n    unfold Ordnode.insert insert_with <;> cases cmpLE x y <;> unfold Ordnode.insert insert_with <;>\n      simp [insert_eq_insert_with]\n#align insert_eq_insert_with insert_eq_insert_with\n\n",
 "insert'_eq_insert_with":
 "theorem insert'_eq_insert_with [@DecidableRel α (· ≤ ·)] (x : α) : ∀ t, insert' x t = insertWith id x t\n  | nil => rfl\n  | node _ l y r => by\n    unfold insert' insert_with <;> cases cmpLE x y <;> unfold insert' insert_with <;> simp [insert'_eq_insert_with]\n#align insert'_eq_insert_with insert'_eq_insert_with\n\n",
 "induction":
 "@[elab_as_elim]\ntheorem sized.induction {t} (hl : @sized α t) {C : Ordnode α → Prop} (H0 : C nil)\n    (H1 : ∀ l x r, C l → C r → C (node' l x r)) : C t :=\n  by\n  induction t; · exact H0\n  rw [hl.eq_node']\n  exact H1 _ _ _ (t_ih_l hl.2.1) (t_ih_r hl.2.2)\n#align sized.induction sized.induction\n\n",
 "imp":
 "theorem any.imp {P Q : α → Prop} (H : ∀ a, P a → Q a) : ∀ {t}, Any P t → Any Q t\n  | nil => id\n  | node _ l x r => Or.imp any.imp <| Or.imp (H _) any.imp\n#align any.imp any.imp\n\n",
 "glue_aux":
 "theorem valid'.glue_aux {l r o₁ o₂} (hl : valid' o₁ l o₂) (hr : valid' o₁ r o₂)\n    (sep : l.all fun x => r.all fun y => x < y) (bal : balanced_sz (size l) (size r)) :\n    valid' o₁ (@glue α l r) o₂ ∧ size (glue l r) = size l + size r :=\n  by\n  cases' l with ls ll lx lr; · exact ⟨hr, (zero_add _).symm⟩\n  cases' r with rs rl rx rr; · exact ⟨hl, rfl⟩\n  dsimp [glue]; split_ifs\n  · rw [split_max_eq, glue]\n    cases' valid'.erase_max_aux hl with v e\n    suffices H\n    refine' ⟨valid'.balance_r v (hr.of_gt _ _) H, _⟩\n    · refine' find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _)\n      exact fun x h => hr.1.2.to_nil.mono_left (le_of_lt h.2.1)\n    · exact @find_max'_all _ (fun a => all (· > a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2\n    · rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ← e, hl.2.1]\n      rfl\n    · refine' or.inl ⟨_, or.inr e, _⟩\n      rwa [hl.2.eq_node'] at bal\n  · rw [split_min_eq, glue]\n    cases' valid'.erase_min_aux hr with v e\n    suffices H\n    refine' ⟨valid'.balance_l (hl.of_lt _ _) v H, _⟩\n    · refine' @find_min'_all _ (fun a => bounded nil o₁ ↑a) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil\n      exact fun y h => hl.1.1.to_nil.mono_right (le_of_lt h)\n    ·\n      exact\n        @find_min'_all _ (fun a => all (· < a) (node ls ll lx lr)) rl rx\n          (all_iff_forall.2 fun x hx => sep.imp fun y hy => all_iff_forall.1 hy.1 _ hx) (sep.imp fun y hy => hy.2.1)\n    · rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ← e, hr.2.1]\n      rfl\n    · refine' or.inr ⟨_, or.inr e, _⟩\n      rwa [hr.2.eq_node'] at bal\n#align valid'.glue_aux valid'.glue_aux\n\n",
 "glue":
 "theorem valid'.glue {l x r o₁ o₂} (hl : valid' o₁ l ↑(x : α)) (hr : valid' (↑x) r o₂) :\n    balanced_sz (size l) (size r) → valid' o₁ (@glue α l r) o₂ ∧ size (@glue α l r) = size l + size r :=\n  valid'.glue_aux (hl.trans_right hr.1) (hr.trans_left hl.1) (hl.1.to_sep hr.1)\n#align valid'.glue valid'.glue\n\n",
 "foldr_cons_eq_to_list":
 "theorem foldr_cons_eq_to_list : ∀ (t : Ordnode α) (r : List α), t.foldr List.cons r = toList t ++ r\n  | nil, r => rfl\n  | node _ l x r, r' => by\n    rw [foldr, foldr_cons_eq_to_list, foldr_cons_eq_to_list, ← list.cons_append, ← list.append_assoc, ←\n        foldr_cons_eq_to_list] <;>\n      rfl\n#align foldr_cons_eq_to_list foldr_cons_eq_to_list\n\n",
 "find_min_dual":
 "theorem find_min_dual : ∀ t : Ordnode α, findMin (dual t) = findMax t\n  | nil => rfl\n  | node _ l x r => congr_arg some <| find_min'_dual _ _\n#align find_min_dual find_min_dual\n\n",
 "find_min'_dual":
 "theorem find_min'_dual : ∀ (t) (x : α), findMin' (dual t) x = findMax' x t\n  | nil, x => rfl\n  | node _ l x r, _ => find_min'_dual r x\n#align find_min'_dual find_min'_dual\n\n",
 "find_min'_all":
 "@[elab_as_elim]\ntheorem find_min'_all {P : α → Prop} : ∀ (t) (x : α), All P t → P x → P (findMin' t x)\n  | nil, x, h, hx => hx\n  | node _ ll lx lr, x, ⟨h₁, h₂, h₃⟩, hx => find_min'_all _ _ h₁ h₂\n#align find_min'_all find_min'_all\n\n",
 "find_max_dual":
 "theorem find_max_dual (t : Ordnode α) : findMax (dual t) = findMin t := by rw [← find_min_dual, dual_dual]\n#align find_max_dual find_max_dual\n\n",
 "find_max'_dual":
 "theorem find_max'_dual (t) (x : α) : findMax' x (dual t) = findMin' t x := by rw [← find_min'_dual, dual_dual]\n#align find_max'_dual find_max'_dual\n\n",
 "find_max'_all":
 "@[elab_as_elim]\ntheorem find_max'_all {P : α → Prop} : ∀ (x : α) (t), P x → All P t → P (findMax' x t)\n  | x, nil, hx, h => hx\n  | x, node _ ll lx lr, hx, ⟨h₁, h₂, h₃⟩ => find_max'_all _ _ h₂ h₃\n#align find_max'_all find_max'_all\n\n",
 "erase_min_aux":
 "theorem valid'.erase_min_aux {s l x r o₁ o₂} (H : valid' o₁ (node s l x r) o₂) :\n    valid' (↑(findMin' l x)) (@eraseMin α (node' l x r)) o₂ ∧ size (node' l x r) = size (eraseMin (node' l x r)) + 1 :=\n  by\n  have := H.dual.erase_max_aux <;>\n    rwa [← dual_node', size_dual, ← dual_erase_min, size_dual, ← valid'.dual_iff, find_max'_dual] at this\n#align valid'.erase_min_aux valid'.erase_min_aux\n\n",
 "erase_max_aux":
 "theorem valid'.erase_max_aux {s l x r o₁ o₂} (H : valid' o₁ (node s l x r) o₂) :\n    valid' o₁ (@eraseMax α (node' l x r)) ↑(findMax' x r) ∧ size (node' l x r) = size (eraseMax (node' l x r)) + 1 :=\n  by\n  have := H.2.eq_node'; rw [this] at H; clear this\n  induction' r with rs rl rx rr IHrl IHrr generalizing l x o₁\n  · exact ⟨H.left, rfl⟩\n  have := H.2.2.2.eq_node'; rw [this] at H⊢\n  rcases IHrr H.right with ⟨h, e⟩\n  refine' ⟨valid'.balance_l H.left h (or.inr ⟨_, or.inr e, H.3.1⟩), _⟩\n  rw [erase_max, size_balance_l H.3.2.1 h.3 H.2.2.1 h.2 (or.inr ⟨_, or.inr e, H.3.1⟩)]\n  rw [size, e]; rfl\n#align valid'.erase_max_aux valid'.erase_max_aux\n\n",
 "erase_aux":
 "theorem valid'.erase_aux [@DecidableRel α (· ≤ ·)] (x : α) {t a₁ a₂} (h : valid' a₁ t a₂) :\n    valid' a₁ (erase x t) a₂ ∧ raised (erase x t).size t.size :=\n  by\n  induction t generalizing a₁ a₂\n  · simp [erase, raised]\n    exact h\n  · simp [erase]\n    have t_ih_l' := t_ih_l h.left\n    have t_ih_r' := t_ih_r h.right\n    clear t_ih_l t_ih_r\n    cases' t_ih_l' with t_l_valid t_l_size\n    cases' t_ih_r' with t_r_valid t_r_size\n    cases cmpLE x t_x <;> simp [erase._match_1] <;> rw [h.sz.1]\n    · suffices h_balanceable\n      constructor\n      · exact valid'.balance_r t_l_valid h.right h_balanceable\n      · rw [size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable]\n        repeat' apply raised.add_right\n        exact t_l_size\n      · left\n        exists t_l.size\n        exact and.intro t_l_size h.bal.1\n    · have h_glue := valid'.glue h.left h.right h.bal.1\n      cases' h_glue with h_glue_valid h_glue_sized\n      constructor\n      · exact h_glue_valid\n      · right\n        rw [h_glue_sized]\n    · suffices h_balanceable\n      constructor\n      · exact valid'.balance_l h.left t_r_valid h_balanceable\n      · rw [size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable]\n        apply raised.add_right\n        apply raised.add_left\n        exact t_r_size\n      · right\n        exists t_r.size\n        exact and.intro t_r_size h.bal.1\n#align valid'.erase_aux valid'.erase_aux\n\n",
 "equiv_iff":
 "theorem equiv_iff {t₁ t₂ : Ordnode α} (h₁ : sized t₁) (h₂ : sized t₂) : Equiv t₁ t₂ ↔ toList t₁ = toList t₂ :=\n  and_iff_right_of_imp fun h => by rw [← length_to_list h₁, h, length_to_list h₂]\n#align equiv_iff equiv_iff\n\n",
 "eq_node'":
 "theorem sized.eq_node' {s l x r} (h : @sized α (node s l x r)) : node s l x r = node' l x r := by rw [h.1] <;> rfl\n#align sized.eq_node' sized.eq_node'\n\n",
 "empty_iff":
 "theorem empty_iff {s : ordset α} : s = ∅ ↔ s.1.empty :=\n  ⟨fun h => by cases h <;> exact rfl, fun h => by cases s <;> cases s_val <;> [exact rfl, cases h]⟩\n#align empty_iff empty_iff\n\n",
 "emem_iff_mem_to_list":
 "theorem emem_iff_mem_to_list {x : α} {t} : Emem x t ↔ x ∈ toList t := by\n  unfold emem <;> induction t <;> simp [any, *, or_assoc']\n#align emem_iff_mem_to_list emem_iff_mem_to_list\n\n",
 "emem_iff_all":
 "theorem emem_iff_all {x : α} {t} : Emem x t ↔ ∀ P, All P t → P x :=\n  ⟨fun h P al => all_iff_forall.1 al _ h, fun H => H _ <| all_iff_forall.2 fun _ => id⟩\n#align emem_iff_all emem_iff_all\n\n",
 "dual_rotate_r":
 "theorem dual_rotate_r (l : Ordnode α) (x : α) (r : Ordnode α) : dual (rotate_r l x r) = rotate_l (dual r) x (dual l) :=\n  by rw [← dual_dual (rotate_l _ _ _), dual_rotate_l, dual_dual, dual_dual]\n#align dual_rotate_r dual_rotate_r\n\n",
 "dual_rotate_l":
 "theorem dual_rotate_l (l : Ordnode α) (x : α) (r : Ordnode α) : dual (rotate_l l x r) = rotate_r (dual r) x (dual l) :=\n  by cases r <;> simp [rotate_l, rotate_r, dual_node'] <;> split_ifs <;> simp [dual_node3_l, dual_node4_l]\n#align dual_rotate_l dual_rotate_l\n\n",
 "dual_node4_r":
 "theorem dual_node4_r (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node4_r l x m y r) = node4_l (dual r) y (dual m) x (dual l) := by\n  cases m <;> simp [node4_l, node4_r, dual_node3_r, dual_node']\n#align dual_node4_r dual_node4_r\n\n",
 "dual_node4_l":
 "theorem dual_node4_l (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node4_l l x m y r) = node4_r (dual r) y (dual m) x (dual l) := by\n  cases m <;> simp [node4_l, node4_r, dual_node3_l, dual_node']\n#align dual_node4_l dual_node4_l\n\n",
 "dual_node3_r":
 "theorem dual_node3_r (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node3_r l x m y r) = node3_l (dual r) y (dual m) x (dual l) := by simp [node3_l, node3_r, dual_node']\n#align dual_node3_r dual_node3_r\n\n",
 "dual_node3_l":
 "theorem dual_node3_l (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node3_l l x m y r) = node3_r (dual r) y (dual m) x (dual l) := by simp [node3_l, node3_r, dual_node']\n#align dual_node3_l dual_node3_l\n\n",
 "dual_node'":
 "-- should not happen\n-- should not happen\n-- should not happen\n-- should not happen\ntheorem dual_node' (l : Ordnode α) (x : α) (r : Ordnode α) : dual (node' l x r) = node' (dual r) x (dual l) := by\n  simp [node', add_comm]\n#align dual_node' dual_node'\n\n",
 "dual_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem dual_insert [preorder α] [is_total α (· ≤ ·)] [@DecidableRel α (· ≤ ·)] (x : α) :\n    ∀ t : Ordnode α, dual (Ordnode.insert x t) = @Ordnode.insert («expr ᵒᵈ» α) _ _ x (dual t)\n  | nil => rfl\n  | node _ l y r => by\n    have : @cmpLE («expr ᵒᵈ» α) _ _ x y = cmpLE y x := rfl\n    rw [Ordnode.insert, dual, Ordnode.insert, this, ← cmpLE_swap x y]\n    cases cmpLE x y <;> simp [ordering.swap, Ordnode.insert, dual_balance_l, dual_balance_r, dual_insert]\n#align dual_insert dual_insert\n\n",
 "dual_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem valid.dual_iff {t : Ordnode α} : valid t ↔ @valid («expr ᵒᵈ» α) _ (dual t) :=\n  valid'.dual_iff\n#align valid.dual_iff valid.dual_iff\n\n",
 "dual_erase_min":
 "theorem dual_erase_min : ∀ t : Ordnode α, dual (eraseMin t) = eraseMax (dual t)\n  | nil => rfl\n  | node _ nil x r => rfl\n  | node _ (l@(node _ _ _ _)) x r => by rw [erase_min, dual_balance_r, dual_erase_min, dual, dual, dual, erase_max]\n#align dual_erase_min dual_erase_min\n\n",
 "dual_erase_max":
 "theorem dual_erase_max (t : Ordnode α) : dual (eraseMax t) = eraseMin (dual t) := by\n  rw [← dual_dual (erase_min _), dual_erase_min, dual_dual]\n#align dual_erase_max dual_erase_max\n\n",
 "dual_dual":
 "theorem dual_dual : ∀ t : Ordnode α, dual (dual t) = t\n  | nil => rfl\n  | node s l x r => by rw [dual, dual, dual_dual, dual_dual]\n#align dual_dual dual_dual\n\n",
 "dual_balance_r":
 "theorem dual_balance_r (l : Ordnode α) (x : α) (r : Ordnode α) : dual (balanceR l x r) = balanceL (dual r) x (dual l) :=\n  by rw [← dual_dual (balance_l _ _ _), dual_balance_l, dual_dual, dual_dual]\n#align dual_balance_r dual_balance_r\n\n",
 "dual_balance_l":
 "theorem dual_balance_l (l : Ordnode α) (x : α) (r : Ordnode α) : dual (balanceL l x r) = balanceR (dual r) x (dual l) :=\n  by\n  unfold balance_l balance_r\n  cases' r with rs rl rx rr\n  · cases' l with ls ll lx lr\n    · rfl\n    cases' ll with lls lll llx llr <;> cases' lr with lrs lrl lrx lrr <;> dsimp only [dual] <;> try rfl\n    split_ifs <;> repeat' simp [h, add_comm]\n  · cases' l with ls ll lx lr\n    · rfl\n    dsimp only [dual]\n    split_ifs\n    swap\n    · simp [add_comm]\n    cases' ll with lls lll llx llr <;> cases' lr with lrs lrl lrx lrr <;> try rfl\n    dsimp only [dual]\n    split_ifs <;> simp [h, add_comm]\n#align dual_balance_l dual_balance_l\n\n",
 "dual_balance'":
 "theorem dual_balance' (l : Ordnode α) (x : α) (r : Ordnode α) : dual (balance' l x r) = balance' (dual r) x (dual l) :=\n  by\n  simp [balance', add_comm]; split_ifs <;> simp [dual_node', dual_rotate_l, dual_rotate_r]\n  cases delta_lt_false h_1 h_2\n#align dual_balance' dual_balance'\n\n",
 "dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem valid.dual {t : Ordnode α} : valid t → @valid («expr ᵒᵈ» α) _ (dual t) :=\n  valid'.dual\n#align valid.dual valid.dual\n\n",
 "dist_le'":
 "theorem raised.dist_le' {n m} (H : raised n m) : Nat.dist m n ≤ 1 := by rw [Nat.dist_comm] <;> exact H.dist_le\n#align raised.dist_le' raised.dist_le'\n\n",
 "dist_le":
 "theorem raised.dist_le {n m} (H : raised n m) : Nat.dist n m ≤ 1 := by\n  cases' raised_iff.1 H with H1 H2 <;> rwa [Nat.dist_eq_sub_of_le H1, tsub_le_iff_left]\n#align raised.dist_le raised.dist_le\n\n",
 "delta_lt_false":
 "theorem delta_lt_false {a b : ℕ} (h₁ : delta * a < b) (h₂ : delta * b < a) : False :=\n  not_le_of_lt (lt_trans ((mul_lt_mul_left (by decide)).2 h₁) h₂) <| by\n    simpa [mul_assoc] using nat.mul_le_mul_right a (by decide : 1 ≤ delta * delta)\n#align delta_lt_false delta_lt_false\n\n",
 "balanced_sz_zero":
 "theorem balanced_sz_zero {l : ℕ} : balanced_sz l 0 ↔ l ≤ 1 := by simp (config := { contextual := true }) [balanced_sz]\n#align balanced_sz_zero balanced_sz_zero\n\n",
 "balanced_sz_up":
 "theorem balanced_sz_up {l r₁ r₂ : ℕ} (h₁ : r₁ ≤ r₂) (h₂ : l + r₂ ≤ 1 ∨ r₂ ≤ delta * l) (H : balanced_sz l r₁) :\n    balanced_sz l r₂ := by\n  refine' or_iff_not_imp_left.2 fun h => _\n  refine' ⟨_, h₂.resolve_left h⟩\n  cases H\n  · cases r₂\n    · cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H)\n    · exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _)\n  · exact le_trans H.1 (nat.mul_le_mul_left _ h₁)\n#align balanced_sz_up balanced_sz_up\n\n",
 "balanced_sz_down":
 "theorem balanced_sz_down {l r₁ r₂ : ℕ} (h₁ : r₁ ≤ r₂) (h₂ : l + r₂ ≤ 1 ∨ l ≤ delta * r₁) (H : balanced_sz l r₂) :\n    balanced_sz l r₁ :=\n  have : l + r₂ ≤ 1 → balanced_sz l r₁ := fun H => or.inl (le_trans (nat.add_le_add_left h₁ _) H)\n  or.cases_on H this fun H => or.cases_on h₂ this fun h₂ => or.inr ⟨h₂, le_trans h₁ H.2⟩\n#align balanced_sz_down balanced_sz_down\n\n",
 "balance_sz_dual":
 "theorem balance_sz_dual {l r}\n    (H :\n      (∃ l', raised (@size α l) l' ∧ balanced_sz l' (@size α r)) ∨ ∃ r', raised r' (size r) ∧ balanced_sz (size l) r') :\n    (∃ l', raised l' (size (dual r)) ∧ balanced_sz l' (size (dual l))) ∨\n      ∃ r', raised (size (dual l)) r' ∧ balanced_sz (size (dual r)) r' :=\n  by\n  rw [size_dual, size_dual]\n  exact\n    H.symm.imp (Exists.imp fun _ => And.imp_right balanced_sz.symm) (Exists.imp fun _ => And.imp_right balanced_sz.symm)\n#align balance_sz_dual balance_sz_dual\n\n",
 "balance_r_eq_balance'":
 "theorem balance_r_eq_balance' {l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r)\n    (H : (∃ l', raised (size l) l' ∧ balanced_sz l' (size r)) ∨ ∃ r', raised r' (size r) ∧ balanced_sz (size l) r') :\n    @balanceR α l x r = balance' l x r := by\n  rw [← dual_dual (balance_r l x r), dual_balance_r,\n    balance_l_eq_balance' hr.dual hl.dual sr.dual sl.dual (balance_sz_dual H), ← dual_balance', dual_dual]\n#align balance_r_eq_balance' balance_r_eq_balance'\n\n",
 "balance_r_aux":
 "theorem valid'.balance_r_aux {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂) (H₁ : size r = 0 → size l ≤ 1)\n    (H₂ : 1 ≤ size r → 1 ≤ size l → size l ≤ delta * size r) (H₃ : 2 * @size α r ≤ 9 * size l + 5 ∨ size r ≤ 3) :\n    valid' o₁ (@balanceR α l x r) o₂ := by\n  rw [valid'.dual_iff, dual_balance_r]\n  have := hr.dual.balance_l_aux hl.dual\n  rw [size_dual, size_dual] at this\n  exact this H₁ H₂ H₃\n#align valid'.balance_r_aux valid'.balance_r_aux\n\n",
 "balance_r":
 "theorem valid'.balance_r {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂)\n    (H : (∃ l', raised (size l) l' ∧ balanced_sz l' (size r)) ∨ ∃ r', raised r' (size r) ∧ balanced_sz (size l) r') :\n    valid' o₁ (@balanceR α l x r) o₂ := by\n  rw [valid'.dual_iff, dual_balance_r] <;> exact hr.dual.balance_l hl.dual (balance_sz_dual H)\n#align valid'.balance_r valid'.balance_r\n\n",
 "balance_l_eq_balance'":
 "theorem balance_l_eq_balance' {l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r)\n    (H : (∃ l', raised l' (size l) ∧ balanced_sz l' (size r)) ∨ ∃ r', raised (size r) r' ∧ balanced_sz (size l) r') :\n    @balanceL α l x r = balance' l x r :=\n  by\n  rw [← balance_eq_balance' hl hr sl sr, balance_l_eq_balance sl sr]\n  · intro l0\n    rw [l0] at H\n    rcases H with (⟨_, ⟨⟨⟩⟩ | ⟨⟨⟩⟩, H⟩ | ⟨r', e, H⟩)\n    · exact balanced_sz_zero.1 H.symm\n    exact le_trans (raised_iff.1 e).1 (balanced_sz_zero.1 H.symm)\n  · intro l1 r1\n    rcases H with (⟨l', e, H | ⟨H₁, H₂⟩⟩ | ⟨r', e, H | ⟨H₁, H₂⟩⟩)\n    · exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos (by decide) l1 : (0 : ℕ) < _)\n    · exact le_trans H₂ (nat.mul_le_mul_left _ (raised_iff.1 e).1)\n    · cases raised_iff.1 e\n      unfold delta\n      linarith\n    · exact le_trans (raised_iff.1 e).1 H₂\n#align balance_l_eq_balance' balance_l_eq_balance'\n\n",
 "balance_l_eq_balance":
 "theorem balance_l_eq_balance {l x r} (sl : sized l) (sr : sized r) (H1 : size l = 0 → size r ≤ 1)\n    (H2 : 1 ≤ size l → 1 ≤ size r → size r ≤ delta * size l) : @balanceL α l x r = balance l x r :=\n  by\n  cases' r with rs rl rx rr\n  · rfl\n  · cases' l with ls ll lx lr\n    · have : size rl = 0 ∧ size rr = 0 := by\n        have := H1 rfl\n        rwa [size, sr.1, Nat.succ_le_succ_iff, le_zero_iff, add_eq_zero_iff] at this\n      cases sr.2.1.size_eq_zero.1 this.1\n      cases sr.2.2.size_eq_zero.1 this.2\n      rw [sr.eq_node']\n      rfl\n    · replace H2 : ¬rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos)\n      simp [balance_l, balance, H2] <;> split_ifs <;> simp [add_comm]\n#align balance_l_eq_balance balance_l_eq_balance\n\n",
 "balance_l_aux":
 "theorem valid'.balance_l_aux {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂) (H₁ : size l = 0 → size r ≤ 1)\n    (H₂ : 1 ≤ size l → 1 ≤ size r → size r ≤ delta * size l) (H₃ : 2 * @size α l ≤ 9 * size r + 5 ∨ size l ≤ 3) :\n    valid' o₁ (@balanceL α l x r) o₂ :=\n  by\n  rw [balance_l_eq_balance hl.2 hr.2 H₁ H₂, balance_eq_balance' hl.3 hr.3 hl.2 hr.2]\n  refine' hl.balance'_aux hr (or.inl _) H₃\n  cases' nat.eq_zero_or_pos (size r) with r0 r0\n  · rw [r0]\n    exact nat.zero_le _\n  cases' nat.eq_zero_or_pos (size l) with l0 l0\n  · rw [l0]\n    exact le_trans (nat.mul_le_mul_left _ (H₁ l0)) (by decide)\n  replace H₂ : _ ≤ 3 * _ := H₂ l0 r0; linarith\n#align valid'.balance_l_aux valid'.balance_l_aux\n\n",
 "balance_l":
 "theorem valid'.balance_l {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂)\n    (H : (∃ l', raised l' (size l) ∧ balanced_sz l' (size r)) ∨ ∃ r', raised (size r) r' ∧ balanced_sz (size l) r') :\n    valid' o₁ (@balanceL α l x r) o₂ :=\n  by\n  rw [balance_l_eq_balance' hl.3 hr.3 hl.2 hr.2 H]\n  refine' hl.balance' hr _\n  rcases H with (⟨l', e, H⟩ | ⟨r', e, H⟩)\n  · exact ⟨_, _, H, or.inl ⟨e.dist_le', rfl⟩⟩\n  · exact ⟨_, _, H, or.inr ⟨e.dist_le, rfl⟩⟩\n#align valid'.balance_l valid'.balance_l\n\n",
 "balance_eq_balance'":
 "theorem balance_eq_balance' {l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r) :\n    @balance α l x r = balance' l x r := by\n  cases' l with ls ll lx lr\n  · cases' r with rs rl rx rr\n    · rfl\n    · rw [sr.eq_node'] at hr⊢\n      cases' rl with rls rll rlx rlr <;> cases' rr with rrs rrl rrx rrr <;> dsimp [balance, balance']\n      · rfl\n      · have : size rrl = 0 ∧ size rrr = 0 :=\n          by\n          have := balanced_sz_zero.1 hr.1.symm\n          rwa [size, sr.2.2.1, Nat.succ_le_succ_iff, le_zero_iff, add_eq_zero_iff] at this\n        cases sr.2.2.2.1.size_eq_zero.1 this.1\n        cases sr.2.2.2.2.size_eq_zero.1 this.2\n        obtain rfl : rrs = 1 := sr.2.2.1\n        rw [if_neg, if_pos, rotate_l, if_pos]\n        · rfl\n        all_goals exact by decide\n      · have : size rll = 0 ∧ size rlr = 0 := by\n          have := balanced_sz_zero.1 hr.1\n          rwa [size, sr.2.1.1, Nat.succ_le_succ_iff, le_zero_iff, add_eq_zero_iff] at this\n        cases sr.2.1.2.1.size_eq_zero.1 this.1\n        cases sr.2.1.2.2.size_eq_zero.1 this.2\n        obtain rfl : rls = 1 := sr.2.1.1\n        rw [if_neg, if_pos, rotate_l, if_neg]\n        · rfl\n        all_goals exact by decide\n      · symm\n        rw [zero_add, if_neg, if_pos, rotate_l]\n        · split_ifs\n          · simp [node3_l, node', add_comm, add_left_comm]\n          · simp [node4_l, node', sr.2.1.1, add_comm, add_left_comm]\n        · exact by decide\n        · exact not_le_of_gt (nat.succ_lt_succ (add_pos sr.2.1.pos sr.2.2.pos))\n  · cases' r with rs rl rx rr\n    · rw [sl.eq_node'] at hl⊢\n      cases' ll with lls lll llx llr <;> cases' lr with lrs lrl lrx lrr <;> dsimp [balance, balance']\n      · rfl\n      · have : size lrl = 0 ∧ size lrr = 0 :=\n          by\n          have := balanced_sz_zero.1 hl.1.symm\n          rwa [size, sl.2.2.1, Nat.succ_le_succ_iff, le_zero_iff, add_eq_zero_iff] at this\n        cases sl.2.2.2.1.size_eq_zero.1 this.1\n        cases sl.2.2.2.2.size_eq_zero.1 this.2\n        obtain rfl : lrs = 1 := sl.2.2.1\n        rw [if_neg, if_neg, if_pos, rotate_r, if_neg]\n        · rfl\n        all_goals exact by decide\n      · have : size lll = 0 ∧ size llr = 0 := by\n          have := balanced_sz_zero.1 hl.1\n          rwa [size, sl.2.1.1, Nat.succ_le_succ_iff, le_zero_iff, add_eq_zero_iff] at this\n        cases sl.2.1.2.1.size_eq_zero.1 this.1\n        cases sl.2.1.2.2.size_eq_zero.1 this.2\n        obtain rfl : lls = 1 := sl.2.1.1\n        rw [if_neg, if_neg, if_pos, rotate_r, if_pos]\n        · rfl\n        all_goals exact by decide\n      · symm\n        rw [if_neg, if_neg, if_pos, rotate_r]\n        · split_ifs\n          · simp [node3_r, node', add_comm, add_left_comm]\n          · simp [node4_r, node', sl.2.2.1, add_comm, add_left_comm]\n        · exact by decide\n        · exact by decide\n        · exact not_le_of_gt (nat.succ_lt_succ (add_pos sl.2.1.pos sl.2.2.pos))\n    · simp [balance, balance']\n      symm\n      rw [if_neg]\n      · split_ifs\n        · have rd : delta ≤ size rl + size rr :=\n            by\n            have := lt_of_le_of_lt (nat.mul_le_mul_left _ sl.pos) h\n            rwa [sr.1, Nat.lt_succ_iff] at this\n          cases' rl with rls rll rlx rlr\n          · rw [size, zero_add] at rd\n            exact absurd (le_trans rd (balanced_sz_zero.1 hr.1.symm)) (by decide)\n          cases' rr with rrs rrl rrx rrr\n          · exact absurd (le_trans rd (balanced_sz_zero.1 hr.1)) (by decide)\n          dsimp [rotate_l]\n          split_ifs\n          · simp [node3_l, node', sr.1, add_comm, add_left_comm]\n          · simp [node4_l, node', sr.1, sr.2.1.1, add_comm, add_left_comm]\n        · have ld : delta ≤ size ll + size lr :=\n            by\n            have := lt_of_le_of_lt (nat.mul_le_mul_left _ sr.pos) h_1\n            rwa [sl.1, Nat.lt_succ_iff] at this\n          cases' ll with lls lll llx llr\n          · rw [size, zero_add] at ld\n            exact absurd (le_trans ld (balanced_sz_zero.1 hl.1.symm)) (by decide)\n          cases' lr with lrs lrl lrx lrr\n          · exact absurd (le_trans ld (balanced_sz_zero.1 hl.1)) (by decide)\n          dsimp [rotate_r]\n          split_ifs\n          · simp [node3_r, node', sl.1, add_comm, add_left_comm]\n          · simp [node4_r, node', sl.1, sl.2.2.1, add_comm, add_left_comm]\n        · simp [node']\n      · exact not_le_of_gt (add_le_add sl.pos sr.pos : 2 ≤ ls + rs)\n#align balance_eq_balance' balance_eq_balance'\n\n",
 "balance'_lemma":
 "theorem valid'.balance'_lemma {α l l' r r'} (H1 : balanced_sz l' r')\n    (H2 : Nat.dist (@size α l) l' ≤ 1 ∧ size r = r' ∨ Nat.dist (size r) r' ≤ 1 ∧ size l = l') :\n    2 * @size α r ≤ 9 * size l + 5 ∨ size r ≤ 3 :=\n  by\n  suffices @size α r ≤ 3 * (size l + 1)\n    by\n    cases' nat.eq_zero_or_pos (size l) with l0 l0\n    · apply or.inr\n      rwa [l0] at this\n    change 1 ≤ _ at l0\n    apply or.inl\n    linarith\n  rcases H2 with (⟨hl, rfl⟩ | ⟨hr, rfl⟩) <;> rcases H1 with (h | ⟨h₁, h₂⟩)\n  · exact le_trans (nat.le_add_left _ _) (le_trans h (nat.le_add_left _ _))\n  · exact le_trans h₂ (nat.mul_le_mul_left _ <| le_trans (Nat.dist_tri_right _ _) (nat.add_le_add_left hl _))\n  · exact le_trans (Nat.dist_tri_left' _ _) (le_trans (add_le_add hr (le_trans (nat.le_add_left _ _) h)) (by decide))\n  · rw [nat.mul_succ]\n    exact le_trans (Nat.dist_tri_right' _ _) (add_le_add h₂ (le_trans hr (by decide)))\n#align valid'.balance'_lemma valid'.balance'_lemma\n\n",
 "balance'_aux":
 "theorem valid'.balance'_aux {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂)\n    (H₁ : 2 * @size α r ≤ 9 * size l + 5 ∨ size r ≤ 3) (H₂ : 2 * @size α l ≤ 9 * size r + 5 ∨ size l ≤ 3) :\n    valid' o₁ (@balance' α l x r) o₂ := by\n  rw [balance']; split_ifs\n  · exact hl.node' hr (or.inl h)\n  · exact hl.rotate_l hr h h_1 H₁\n  · exact hl.rotate_r hr h h_2 H₂\n  · exact hl.node' hr (or.inr ⟨not_lt.1 h_2, not_lt.1 h_1⟩)\n#align valid'.balance'_aux valid'.balance'_aux\n\n",
 "balance'":
 "theorem valid'.balance' {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂)\n    (H :\n      ∃ l' r', balanced_sz l' r' ∧ (Nat.dist (size l) l' ≤ 1 ∧ size r = r' ∨ Nat.dist (size r) r' ≤ 1 ∧ size l = l')) :\n    valid' o₁ (@balance' α l x r) o₂ :=\n  let ⟨l', r', H1, H2⟩ := H\n  valid'.balance'_aux hl hr (valid'.balance'_lemma H1 H2) (valid'.balance'_lemma H1.symm H2.symm)\n#align valid'.balance' valid'.balance'\n\n",
 "balance":
 "theorem valid'.balance {l x r o₁ o₂} (hl : valid' o₁ l ↑x) (hr : valid' (↑x) r o₂)\n    (H :\n      ∃ l' r', balanced_sz l' r' ∧ (Nat.dist (size l) l' ≤ 1 ∧ size r = r' ∨ Nat.dist (size r) r' ≤ 1 ∧ size l = l')) :\n    valid' o₁ (@balance α l x r) o₂ := by rw [balance_eq_balance' hl.3 hr.3 hl.2 hr.2] <;> exact hl.balance' hr H\n#align valid'.balance valid'.balance\n\n",
 "any_singleton":
 "theorem any_singleton {P : α → Prop} {x : α} : Any P (singleton x) ↔ P x :=\n  ⟨by rintro (⟨⟨⟩⟩ | h | ⟨⟨⟩⟩) <;> exact h, fun h => or.inr (or.inl h)⟩\n#align any_singleton any_singleton\n\n",
 "any_iff_exists":
 "theorem any_iff_exists {P : α → Prop} : ∀ {t}, Any P t ↔ ∃ x, Emem x t ∧ P x\n  | nil => ⟨by rintro ⟨⟩, by rintro ⟨_, ⟨⟩, _⟩⟩\n  | node _ l x r => by simp [any, emem, any_iff_exists, or_and_right, exists_or]\n#align any_iff_exists any_iff_exists\n\n",
 "all_singleton":
 "theorem all_singleton {P : α → Prop} {x : α} : All P (singleton x) ↔ P x :=\n  ⟨fun h => h.2.1, fun h => ⟨⟨⟩, h, ⟨⟩⟩⟩\n#align all_singleton all_singleton\n\n",
 "all_rotate_r":
 "theorem all_rotate_r {P l x r} : @All α P (rotate_r l x r) ↔ All P l ∧ P x ∧ All P r := by\n  rw [← all_dual, dual_rotate_r, all_rotate_l] <;> simp [all_dual, and_comm', and_left_comm]\n#align all_rotate_r all_rotate_r\n\n",
 "all_rotate_l":
 "theorem all_rotate_l {P l x r} : @All α P (rotate_l l x r) ↔ All P l ∧ P x ∧ All P r := by\n  cases r <;> simp [rotate_l, all_node'] <;> split_ifs <;> simp [all_node3_l, all_node4_l, all]\n#align all_rotate_l all_rotate_l\n\n",
 "all_node4_r":
 "theorem all_node4_r {P l x m y r} : @All α P (node4_r l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r := by\n  cases m <;> simp [node4_r, all_node', all, all_node3_r, and_assoc']\n#align all_node4_r all_node4_r\n\n",
 "all_node4_l":
 "theorem all_node4_l {P l x m y r} : @All α P (node4_l l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r := by\n  cases m <;> simp [node4_l, all_node', all, all_node3_l, and_assoc']\n#align all_node4_l all_node4_l\n\n",
 "all_node3_r":
 "theorem all_node3_r {P l x m y r} : @All α P (node3_r l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r :=\n  iff.rfl\n#align all_node3_r all_node3_r\n\n",
 "all_node3_l":
 "theorem all_node3_l {P l x m y r} : @All α P (node3_l l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r := by\n  simp [node3_l, all_node', and_assoc']\n#align all_node3_l all_node3_l\n\n",
 "all_node'":
 "theorem all_node' {P l x r} : @All α P (node' l x r) ↔ All P l ∧ P x ∧ All P r :=\n  iff.rfl\n#align all_node' all_node'\n\n",
 "all_iff_forall":
 "theorem all_iff_forall {P : α → Prop} : ∀ {t}, All P t ↔ ∀ x, Emem x t → P x\n  | nil => (iff_true_intro <| by rintro _ ⟨⟩).symm\n  | node _ l x r => by simp [all, emem, all_iff_forall, any, or_imp, forall_and]\n#align all_iff_forall all_iff_forall\n\n",
 "all_dual":
 "theorem all_dual {P : α → Prop} : ∀ {t : Ordnode α}, All P (dual t) ↔ All P t\n  | nil => iff.rfl\n  | node s l x r =>\n    ⟨fun ⟨hr, hx, hl⟩ => ⟨all_dual.1 hl, hx, all_dual.1 hr⟩, fun ⟨hl, hx, hr⟩ => ⟨all_dual.2 hr, hx, all_dual.2 hl⟩⟩\n#align all_dual all_dual\n\n",
 "all_balance_r":
 "theorem all_balance_r {P l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r)\n    (H : (∃ l', raised (size l) l' ∧ balanced_sz l' (size r)) ∨ ∃ r', raised r' (size r) ∧ balanced_sz (size l) r') :\n    All P (@balanceR α l x r) ↔ All P l ∧ P x ∧ All P r := by rw [balance_r_eq_balance' hl hr sl sr H, all_balance']\n#align all_balance_r all_balance_r\n\n",
 "all_balance_l":
 "theorem all_balance_l {P l x r} (hl : balanced l) (hr : balanced r) (sl : sized l) (sr : sized r)\n    (H : (∃ l', raised l' (size l) ∧ balanced_sz l' (size r)) ∨ ∃ r', raised (size r) r' ∧ balanced_sz (size l) r') :\n    All P (@balanceL α l x r) ↔ All P l ∧ P x ∧ All P r := by rw [balance_l_eq_balance' hl hr sl sr H, all_balance']\n#align all_balance_l all_balance_l\n\n",
 "all_balance'":
 "theorem all_balance' {P l x r} : @All α P (balance' l x r) ↔ All P l ∧ P x ∧ All P r := by\n  rw [balance'] <;> split_ifs <;> simp [all_node', all_rotate_l, all_rotate_r]\n#align all_balance' all_balance'\n\n",
 "add_right":
 "theorem raised.add_right (k) {n m} (H : raised n m) : raised (n + k) (m + k) := by\n  rw [add_comm, add_comm m] <;> exact H.add_left _\n#align raised.add_right raised.add_right\n\n",
 "add_left":
 "theorem raised.add_left (k) {n m} (H : raised n m) : raised (k + n) (k + m) :=\n  by\n  rcases H with (rfl | rfl)\n  · exact or.inl rfl\n  · exact or.inr rfl\n#align raised.add_left raised.add_left\n\n"}