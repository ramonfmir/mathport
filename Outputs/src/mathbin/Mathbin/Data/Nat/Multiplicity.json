{"pow_dvd_factorial_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\n  This sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` -/\ntheorem pow_dvd_factorial_iff {p : ℕ} {n r b : ℕ} (hp : p.prime) (hbn : log p n < b) :\n    p ^ r ∣ nat.factorial n ↔\n      r ≤\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 b)\n          (n / p ^ i) :=\n  by rw [← PartENat.coe_le_coe, ← hp.multiplicity_factorial hbn, ← pow_dvd_iff_le_multiplicity]\n#align pow_dvd_factorial_iff pow_dvd_factorial_iff\n\n",
 "multiplicity_two_factorial_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem multiplicity_two_factorial_lt : ∀ {n : ℕ} (h : n ≠ 0), multiplicity 2 (nat.factorial n) < n :=\n  by\n  have h2 := prime_two.prime\n  refine' binary_rec _ _\n  · contradiction\n  · intro b n ih h\n    by_cases hn : n = 0\n    · subst hn\n      simp at h\n      simp [h, one_right h2.not_unit]\n    have : multiplicity 2 (nat.factorial (2 * n)) < (2 * n : ℕ) :=\n      by\n      rw [prime_two.multiplicity_factorial_mul]\n      refine' (PartENat.add_lt_add_right (ih hn) (PartENat.natCast_ne_top _)).trans_le _\n      rw [two_mul]\n      norm_cast\n    cases b\n    · simpa [bit0_eq_two_mul n]\n    · suffices multiplicity 2 (2 * n + 1) + multiplicity 2 (nat.factorial (2 * n)) < ↑(2 * n) + 1 by\n        simpa [succ_eq_add_one, multiplicity.mul, h2, prime_two, Nat.bit1_eq_succ_bit0, bit0_eq_two_mul n]\n      rw [multiplicity_eq_zero.2 (two_not_dvd_two_mul_add_one n), zero_add]\n      refine' this.trans _\n      exact_mod_cast lt_succ_self _\n#align multiplicity_two_factorial_lt multiplicity_two_factorial_lt\n\n",
 "multiplicity_self":
 "theorem multiplicity_self {p : ℕ} (hp : p.prime) : multiplicity p p = 1 :=\n  multiplicity_self hp.prime.not_unit hp.ne_zero\n#align multiplicity_self multiplicity_self\n\n",
 "multiplicity_pow_self":
 "theorem multiplicity_pow_self {p n : ℕ} (hp : p.prime) : multiplicity p (p ^ n) = n :=\n  multiplicity_pow_self hp.ne_zero hp.prime.not_unit n\n#align multiplicity_pow_self multiplicity_pow_self\n\n",
 "multiplicity_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem multiplicity_pow {p m n : ℕ} (hp : p.prime) : multiplicity p (m ^ n) = «expr • » n (multiplicity p m) :=\n  multiplicity.pow hp.prime\n#align multiplicity_pow multiplicity_pow\n\n",
 "multiplicity_one":
 "theorem multiplicity_one {p : ℕ} (hp : p.prime) : multiplicity p 1 = 0 :=\n  multiplicity.one_right hp.prime.not_unit\n#align multiplicity_one multiplicity_one\n\n",
 "multiplicity_mul":
 "theorem multiplicity_mul {p m n : ℕ} (hp : p.prime) : multiplicity p (m * n) = multiplicity p m + multiplicity p n :=\n  multiplicity.mul hp.prime\n#align multiplicity_mul multiplicity_mul\n\n",
 "multiplicity_le_multiplicity_choose_add":
 "/-- A lower bound on the multiplicity of `p` in `choose n k`. -/\ntheorem multiplicity_le_multiplicity_choose_add {p : ℕ} (hp : p.prime) :\n    ∀ n k : ℕ, multiplicity p n ≤ multiplicity p (choose n k) + multiplicity p k\n  | _, 0 => by simp\n  | 0, _ + 1 => by simp\n  | n + 1, k + 1 => by\n    rw [← hp.multiplicity_mul]\n    refine' multiplicity_le_multiplicity_of_dvd_right _\n    rw [← succ_mul_choose_eq]\n    exact dvd_mul_right _ _\n#align multiplicity_le_multiplicity_choose_add multiplicity_le_multiplicity_choose_add\n\n",
 "multiplicity_factorial_mul_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- The multiplicity of `p` in `(p * (n + 1))!` is one more than the sum\n  of the multiplicities of `p` in `(p * n)!` and `n + 1`. -/\ntheorem multiplicity_factorial_mul_succ {n p : ℕ} (hp : p.prime) :\n    multiplicity p (nat.factorial (p * (n + 1))) =\n      multiplicity p (nat.factorial (p * n)) + multiplicity p (n + 1) + 1 :=\n  by\n  have hp' := hp.prime\n  have h0 : 2 ≤ p := hp.two_le\n  have h1 : 1 ≤ p * n + 1 := nat.le_add_left _ _\n  have h2 : p * n + 1 ≤ p * (n + 1)\n  linarith\n  have h3 : p * n + 1 ≤ p * (n + 1) + 1\n  linarith\n  have hm : multiplicity p (nat.factorial (p * n)) ≠ «expr⊤» :=\n    by\n    rw [ne.def, eq_top_iff_not_finite, Classical.not_not, finite_nat_iff]\n    exact ⟨hp.ne_one, factorial_pos _⟩\n  revert hm\n  have h4 : ∀ m ∈ Ico (p * n + 1) (p * (n + 1)), multiplicity p m = 0 :=\n    by\n    intro m hm\n    rw [multiplicity_eq_zero, ← not_dvd_iff_between_consec_multiples _ hp.pos]\n    rw [mem_Ico] at hm\n    exact ⟨n, lt_of_succ_le hm.1, hm.2⟩\n  simp_rw [← prod_Ico_id_eq_factorial, multiplicity.Finset.prod hp', ← sum_Ico_consecutive _ h1 h3, add_assoc]\n  intro h\n  rw [PartENat.add_left_cancel_iff h, sum_Ico_succ_top h2, multiplicity.mul hp', hp.multiplicity_self, sum_congr rfl h4,\n    sum_const_zero, zero_add, add_comm (1 : PartENat)]\n#align multiplicity_factorial_mul_succ multiplicity_factorial_mul_succ\n\n",
 "multiplicity_factorial_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- The multiplicity of `p` in `(p * n)!` is `n` more than that of `n!`. -/\ntheorem multiplicity_factorial_mul {n p : ℕ} (hp : p.prime) :\n    multiplicity p (nat.factorial (p * n)) = multiplicity p (nat.factorial n) + n :=\n  by\n  induction' n with n ih\n  · simp\n  · simp only [succ_eq_add_one, multiplicity.mul, hp, hp.prime, ih, multiplicity_factorial_mul_succ, ← add_assoc,\n      Nat.cast_one, Nat.cast_add, factorial_succ]\n    congr 1\n    rw [add_comm, add_assoc]\n#align multiplicity_factorial_mul multiplicity_factorial_mul\n\n",
 "multiplicity_factorial_le_div_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem multiplicity_factorial_le_div_pred {p : ℕ} (hp : p.prime) (n : ℕ) :\n    multiplicity p (nat.factorial n) ≤ (n / (p - 1) : ℕ) :=\n  by\n  rw [hp.multiplicity_factorial (lt_succ_self _), PartENat.coe_le_coe]\n  exact Nat.geom_sum_Ico_le hp.two_le _ _\n#align multiplicity_factorial_le_div_pred multiplicity_factorial_le_div_pred\n\n",
 "multiplicity_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- **Legendre's Theorem**\n\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem multiplicity_factorial {p : ℕ} (hp : p.prime) :\n    ∀ {n b : ℕ},\n      log p n < b →\n        multiplicity p (nat.factorial n) =\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 b)\n              (n / p ^ i) :\n            ℕ)\n  | 0, b, hb => by simp [Ico, hp.multiplicity_one]\n  | n + 1, b, hb =>\n    calc\n      multiplicity p (nat.factorial (n + 1)) = multiplicity p (nat.factorial n) + multiplicity p (n + 1) := by\n        rw [factorial_succ, hp.multiplicity_mul, add_comm]\n      _ =\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 b)\n                (n / p ^ i) :\n              ℕ) +\n            ((Finset.Ico 1 b).filter fun i => p ^ i ∣ n + 1).card :=\n        by\n        rw [multiplicity_factorial ((log_mono_right <| le_succ _).trans_lt hb), ←\n          multiplicity_eq_card_pow_dvd hp.ne_one (succ_pos _) hb]\n      _ =\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 b)\n              (n / p ^ i + if p ^ i ∣ n + 1 then 1 else 0) :\n            ℕ) :=\n        by\n        rw [sum_add_distrib, sum_boole]\n        simp\n      _ =\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Ico 1 b)\n              ((n + 1) / p ^ i) :\n            ℕ) :=\n        congr_arg coe <| Finset.sum_congr rfl fun _ _ => (succ_div _ _).symm\n      \n#align multiplicity_factorial multiplicity_factorial\n\n",
 "multiplicity_eq_card_pow_dvd":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- The multiplicity of `m` in `n` is the number of positive natural numbers `i` such that `m ^ i`\ndivides `n`. This set is expressed by filtering `Ico 1 b` where `b` is any bound greater than\n`log m n`. -/\ntheorem multiplicity_eq_card_pow_dvd {m n b : ℕ} (hm : m ≠ 1) (hn : 0 < n) (hb : log m n < b) :\n    multiplicity m n = ↑((Finset.Ico 1 b).filter fun i => m ^ i ∣ n).card :=\n  calc\n    multiplicity m n = ↑(Ico 1 <| (multiplicity m n).get (finite_nat_iff.2 ⟨hm, hn⟩) + 1).card := by simp\n    _ = ↑((Finset.Ico 1 b).filter fun i => m ^ i ∣ n).card :=\n      congr_arg coe <|\n        congr_arg card <|\n          Finset.ext fun i =>\n            by\n            rw [mem_filter, mem_Ico, mem_Ico, lt_succ_iff, ← @PartENat.coe_le_coe i, PartENat.natCast_get, ←\n              pow_dvd_iff_le_multiplicity, and_right_comm]\n            refine' (and_iff_left_of_imp fun h => lt_of_le_of_lt _ hb).symm\n            cases m\n            · rw [zero_pow, zero_dvd_iff] at h\n              exacts[(hn.ne' h.2).elim, h.1]\n            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 ⟨m.succ_ne_zero, hm⟩) (le_of_dvd hn h.2)\n    \n#align multiplicity_eq_card_pow_dvd multiplicity_eq_card_pow_dvd\n\n",
 "multiplicity_choose_prime_pow_add_multiplicity":
 "theorem multiplicity_choose_prime_pow_add_multiplicity (hp : p.prime) (hkn : k ≤ p ^ n) (hk0 : k ≠ 0) :\n    multiplicity p (choose (p ^ n) k) + multiplicity p k = n :=\n  le_antisymm\n    (by\n      have hdisj :\n        Disjoint ((Ico 1 n.succ).filter fun i => p ^ i ≤ k % p ^ i + (p ^ n - k) % p ^ i)\n          ((Ico 1 n.succ).filter fun i => p ^ i ∣ k) :=\n        by\n        simp (config := { contextual := true }) [disjoint_right, *, dvd_iff_mod_eq_zero,\n          nat.mod_lt _ (pow_pos hp.pos _)]\n      rw [multiplicity_choose hp hkn (lt_succ_self _),\n        multiplicity_eq_card_pow_dvd (ne_of_gt hp.one_lt) hk0.bot_lt (lt_succ_of_le (log_mono_right hkn)), ←\n        Nat.cast_add, PartENat.coe_le_coe, log_pow hp.one_lt, ← card_disjoint_union hdisj, filter_union_right]\n      have filter_le_Ico := (Ico 1 n.succ).card_filter_le _\n      rwa [card_Ico 1 n.succ] at filter_le_Ico)\n    (by rw [← hp.multiplicity_pow_self] <;> exact multiplicity_le_multiplicity_choose_add hp _ _)\n#align multiplicity_choose_prime_pow_add_multiplicity multiplicity_choose_prime_pow_add_multiplicity\n\n",
 "multiplicity_choose_prime_pow":
 "theorem multiplicity_choose_prime_pow {p n k : ℕ} (hp : p.prime) (hkn : k ≤ p ^ n) (hk0 : k ≠ 0) :\n    multiplicity p (choose (p ^ n) k) = ↑(n - (multiplicity p k).get (finite_nat_iff.2 ⟨hp.ne_one, hk0.bot_lt⟩)) :=\n  PartENat.eq_natCast_sub_of_add_eq_natCast <| multiplicity_choose_prime_pow_add_multiplicity hp hkn hk0\n#align multiplicity_choose_prime_pow multiplicity_choose_prime_pow\n\n",
 "multiplicity_choose_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem multiplicity_choose_aux {p n b k : ℕ} (hp : p.prime) (hkn : k ≤ n) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico 1 b)\n        (n / p ^ i) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico 1 b)\n            (k / p ^ i) +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (Finset.Ico 1 b) ((n - k) / p ^ i) +\n        ((Finset.Ico 1 b).filter fun i => p ^ i ≤ k % p ^ i + (n - k) % p ^ i).card :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico 1 b)\n          (n / p ^ i) =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico 1 b)\n          ((k + (n - k)) / p ^ i) :=\n      by simp only [add_tsub_cancel_of_le hkn]\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Ico 1 b)\n          (k / p ^ i + (n - k) / p ^ i + if p ^ i ≤ k % p ^ i + (n - k) % p ^ i then 1 else 0) :=\n      by simp only [Nat.add_div (pow_pos hp.pos _)]\n    _ = _ := by simp [sum_add_distrib, sum_boole]\n    \n#align multiplicity_choose_aux multiplicity_choose_aux\n\n",
 "multiplicity_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- The multiplicity of `p` in `choose n k` is the number of carries when `k` and `n - k`\n  are added in base `p`. The set is expressed by filtering `Ico 1 b` where `b`\n  is any bound greater than `log p n`. -/\ntheorem multiplicity_choose {p n k b : ℕ} (hp : p.prime) (hkn : k ≤ n) (hnb : log p n < b) :\n    multiplicity p (choose n k) = ((Ico 1 b).filter fun i => p ^ i ≤ k % p ^ i + (n - k) % p ^ i).card :=\n  have h₁ :\n    multiplicity p (choose n k) + multiplicity p (nat.factorial k * nat.factorial (n - k)) =\n      ((Finset.Ico 1 b).filter fun i => p ^ i ≤ k % p ^ i + (n - k) % p ^ i).card +\n        multiplicity p (nat.factorial k * nat.factorial (n - k)) :=\n    by\n    rw [← hp.multiplicity_mul, ← mul_assoc, choose_mul_factorial_mul_factorial hkn, hp.multiplicity_factorial hnb,\n      hp.multiplicity_mul, hp.multiplicity_factorial ((log_mono_right hkn).trans_lt hnb),\n      hp.multiplicity_factorial (lt_of_le_of_lt (log_mono_right tsub_le_self) hnb), multiplicity_choose_aux hp hkn]\n    simp [add_comm]\n  (PartENat.add_right_cancel_iff\n        (PartENat.ne_top_iff_dom.2 <|\n          finite_nat_iff.2 ⟨ne_of_gt hp.one_lt, mul_pos (factorial_pos k) (factorial_pos (n - k))⟩)).1\n    h₁\n#align multiplicity_choose multiplicity_choose\n\n",
 "dvd_choose_pow_iff":
 "theorem dvd_choose_pow_iff (hp : Prime p) : p ∣ (p ^ n).choose k ↔ k ≠ 0 ∧ k ≠ p ^ n := by\n  refine' ⟨fun h => ⟨_, _⟩, fun h => dvd_choose_pow hp h.1 h.2⟩ <;> rintro rfl <;> simpa [hp.ne_one] using h\n#align dvd_choose_pow_iff dvd_choose_pow_iff\n\n",
 "dvd_choose_pow":
 "theorem dvd_choose_pow (hp : Prime p) (hk : k ≠ 0) (hkp : k ≠ p ^ n) : p ∣ (p ^ n).choose k :=\n  by\n  obtain hkp | hkp := hkp.symm.lt_or_lt\n  · simp [choose_eq_zero_of_lt hkp]\n  refine' multiplicity_ne_zero.1 fun h => hkp.not_le <| nat.le_of_dvd hk.bot_lt _\n  have H := hp.multiplicity_choose_prime_pow_add_multiplicity hkp.le hk\n  rw [h, zero_add, eq_coe_iff] at H\n  exact H.1\n#align dvd_choose_pow dvd_choose_pow\n\n"}