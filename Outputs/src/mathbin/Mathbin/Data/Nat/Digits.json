{"zmodeq_of_digits_digits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem zmodeq_of_digits_digits (b b' : ℕ) (c : ℤ) (h : «expr ≡ [ZMOD ]» b' c b) (n : ℕ) :\n    «expr ≡ [ZMOD ]» n (of_digits c (digits b' n)) b :=\n  by\n  conv =>\n    congr\n    skip\n    rw [← of_digits_digits b' n]\n  rw [coe_int_of_digits]\n  apply of_digits_zmodeq' _ _ _ h\n#align zmodeq_of_digits_digits zmodeq_of_digits_digits\n\n",
 "three_dvd_iff":
 "/-- **Divisibility by 3 Rule** -/\ntheorem three_dvd_iff (n : ℕ) : 3 ∣ n ↔ 3 ∣ (digits 10 n).sum :=\n  dvd_iff_dvd_digits_sum 3 10 (by norm_num) n\n#align three_dvd_iff three_dvd_iff\n\n",
 "pow_length_le_mul_of_digits":
 "theorem pow_length_le_mul_of_digits {b : ℕ} {l : list ℕ} (hl : l ≠ []) (hl2 : l.last hl ≠ 0) :\n    (b + 2) ^ l.length ≤ (b + 2) * of_digits (b + 2) l :=\n  by\n  rw [← List.dropLast_append_getLast hl]\n  simp only [list.length_append, list.length, zero_add, List.length_dropLast, of_digits_append, List.length_dropLast,\n    of_digits_singleton, add_comm (l.length - 1), pow_add, pow_one]\n  apply nat.mul_le_mul_left\n  refine' le_trans _ (nat.le_add_left _ _)\n  have : 0 < l.last hl := by rwa [pos_iff_ne_zero]\n  convert nat.mul_le_mul_left _ this\n  rw [mul_one]\n#align pow_length_le_mul_of_digits pow_length_le_mul_of_digits\n\n",
 "of_digits_zmodeq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem of_digits_zmodeq' (b b' : ℤ) (k : ℕ) (h : «expr ≡ [ZMOD ]» b b' k) (L : list ℕ) :\n    «expr ≡ [ZMOD ]» (of_digits b L) (of_digits b' L) k :=\n  by\n  induction' L with d L ih\n  · rfl\n  · dsimp [of_digits]\n    dsimp [Int.ModEq] at *\n    conv_lhs => rw [Int.add_emod, Int.mul_emod, h, ih]\n    conv_rhs => rw [Int.add_emod, Int.mul_emod]\n#align of_digits_zmodeq' of_digits_zmodeq'\n\n",
 "of_digits_zmodeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem of_digits_zmodeq (b : ℤ) (k : ℕ) (L : list ℕ) : «expr ≡ [ZMOD ]» (of_digits b L) (of_digits (b % k) L) k :=\n  of_digits_zmodeq' b (b % k) k (b.mod_modeq ↑k).symm L\n#align of_digits_zmodeq of_digits_zmodeq\n\n",
 "of_digits_zmod":
 "theorem of_digits_zmod (b : ℤ) (k : ℕ) (L : list ℕ) : of_digits b L % k = of_digits (b % k) L % k :=\n  of_digits_zmodeq b k L\n#align of_digits_zmod of_digits_zmod\n\n",
 "of_digits_singleton":
 "@[simp]\ntheorem of_digits_singleton {b n : ℕ} : of_digits b [n] = n := by simp [of_digits]\n#align of_digits_singleton of_digits_singleton\n\n",
 "of_digits_one_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp]\ntheorem of_digits_one_cons {α : Type _} [Semiring α] (h : ℕ) (L : list ℕ) :\n    of_digits (1 : α) (sym.cons' h L) = h + of_digits 1 L := by simp [of_digits]\n#align of_digits_one_cons of_digits_one_cons\n\n",
 "of_digits_one":
 "theorem of_digits_one (L : list ℕ) : of_digits 1 L = L.sum :=\n  by\n  induction' L with d L ih\n  · rfl\n  · simp [of_digits, list.sum_cons, ih]\n#align of_digits_one of_digits_one\n\n",
 "of_digits_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem of_digits_neg_one : ∀ L : list ℕ, of_digits (-1 : ℤ) L = (L.map fun n : ℕ => (n : ℤ)).alternating_sum\n  | [] => rfl\n  | [n] => by simp [of_digits, List.alternatingSum]\n  | sym.cons' a (sym.cons' b t) =>\n    by\n    simp only [of_digits, List.alternatingSum, list.map_cons, of_digits_neg_one t]\n    ring\n#align of_digits_neg_one of_digits_neg_one\n\n",
 "of_digits_modeq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem of_digits_modeq' (b b' : ℕ) (k : ℕ) (h : «expr ≡ [MOD ]» b b' k) (L : list ℕ) :\n    «expr ≡ [MOD ]» (of_digits b L) (of_digits b' L) k :=\n  by\n  induction' L with d L ih\n  · rfl\n  · dsimp [of_digits]\n    dsimp [Nat.ModEq] at *\n    conv_lhs => rw [Nat.add_mod, Nat.mul_mod, h, ih]\n    conv_rhs => rw [Nat.add_mod, Nat.mul_mod]\n#align of_digits_modeq' of_digits_modeq'\n\n",
 "of_digits_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem of_digits_modeq (b k : ℕ) (L : list ℕ) : «expr ≡ [MOD ]» (of_digits b L) (of_digits (b % k) L) k :=\n  of_digits_modeq' b (b % k) k (b.mod_modeq k).symm L\n#align of_digits_modeq of_digits_modeq\n\n",
 "of_digits_mod":
 "theorem of_digits_mod (b k : ℕ) (L : list ℕ) : of_digits b L % k = of_digits (b % k) L % k :=\n  of_digits_modeq b k L\n#align of_digits_mod of_digits_mod\n\n",
 "of_digits_lt_base_pow_length'":
 "/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem of_digits_lt_base_pow_length' {b : ℕ} {l : list ℕ} (hl : ∀ x ∈ l, x < b + 2) :\n    of_digits (b + 2) l < (b + 2) ^ l.length :=\n  by\n  induction' l with hd tl IH\n  · simp [of_digits]\n  · rw [of_digits, list.length_cons, pow_succ]\n    have : (of_digits (b + 2) tl + 1) * (b + 2) ≤ (b + 2) ^ tl.length * (b + 2) :=\n      mul_le_mul (IH fun x hx => hl _ (list.mem_cons_of_mem _ hx)) (by rfl) (by decide) (nat.zero_le _)\n    suffices ↑hd < b + 2 by linarith\n    norm_cast\n    exact hl hd (list.mem_cons_self _ _)\n#align of_digits_lt_base_pow_length' of_digits_lt_base_pow_length'\n\n",
 "of_digits_lt_base_pow_length":
 "/-- an n-digit number in base b is less than b^n if b > 1 -/\ntheorem of_digits_lt_base_pow_length {b : ℕ} {l : list ℕ} (hb : 1 < b) (hl : ∀ x ∈ l, x < b) :\n    of_digits b l < b ^ l.length := by\n  rcases b with (_ | _ | b) <;> try linarith\n  exact of_digits_lt_base_pow_length' hl\n#align of_digits_lt_base_pow_length of_digits_lt_base_pow_length\n\n",
 "of_digits_eq_sum_map_with_index_aux":
 "theorem of_digits_eq_sum_map_with_index_aux (b : ℕ) (l : list ℕ) :\n    ((list.range l.length).zip_with ((fun i a : ℕ => a * b ^ i) ∘ succ) l).sum =\n      b * ((list.range l.length).zip_with (fun i a => a * b ^ i) l).sum :=\n  by\n  suffices\n    (list.range l.length).zip_with ((fun i a : ℕ => a * b ^ i) ∘ succ) l =\n      (list.range l.length).zip_with (fun i a => b * (a * b ^ i)) l\n    by simp [this]\n  congr\n  ext\n  simp [pow_succ]\n  ring\n#align of_digits_eq_sum_map_with_index_aux of_digits_eq_sum_map_with_index_aux\n\n",
 "of_digits_eq_sum_map_with_index":
 "theorem of_digits_eq_sum_map_with_index (b : ℕ) (L : list ℕ) :\n    of_digits b L = (L.map_with_index fun i a => a * b ^ i).sum :=\n  by\n  rw [list.map_with_index_eq_enum_map, List.enum_eq_zip_range, List.map_uncurry_zip_eq_zipWith, of_digits_eq_foldr]\n  induction' L with hd tl hl\n  · simp\n  · simpa [List.range_succ_eq_map, List.zipWith_map_left, of_digits_eq_sum_map_with_index_aux] using or.inl hl\n#align of_digits_eq_sum_map_with_index of_digits_eq_sum_map_with_index\n\n",
 "of_digits_eq_foldr":
 "-- If we had a function converting a list into a polynomial,\n-- and appropriate lemmas about that function,\n-- we could rewrite this in terms of that.\ntheorem of_digits_eq_foldr {α : Type _} [Semiring α] (b : α) (L : list ℕ) :\n    of_digits b L = L.foldr (fun x y => x + b * y) 0 :=\n  by\n  induction' L with d L ih\n  · rfl\n  · dsimp [of_digits]\n    rw [ih]\n#align of_digits_eq_foldr of_digits_eq_foldr\n\n",
 "of_digits_digits_append_digits":
 "theorem of_digits_digits_append_digits {b m n : ℕ} :\n    of_digits b (digits b n ++ digits b m) = n + b ^ (digits b n).length * m := by\n  rw [of_digits_append, of_digits_digits, of_digits_digits]\n#align of_digits_digits_append_digits of_digits_digits_append_digits\n\n",
 "of_digits_digits":
 "theorem of_digits_digits (b n : ℕ) : of_digits b (digits b n) = n :=\n  by\n  cases' b with b\n  · cases' n with n\n    · rfl\n    · change of_digits 0 [n + 1] = n + 1\n      dsimp [of_digits]\n      simp\n  · cases' b with b\n    · induction' n with n ih\n      · rfl\n      · simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ]\n    · apply nat.strong_induction_on n _\n      clear n\n      intro n h\n      cases n\n      · rw [digits_zero]\n        rfl\n      · simp only [nat.succ_eq_add_one, digits_add_two_add_one]\n        dsimp [of_digits]\n        rw [h _ (Nat.div_lt_self' n b)]\n        rw [nat.mod_add_div]\n#align of_digits_digits of_digits_digits\n\n",
 "of_digits_append":
 "theorem of_digits_append {b : ℕ} {l1 l2 : list ℕ} :\n    of_digits b (l1 ++ l2) = of_digits b l1 + b ^ l1.length * of_digits b l2 :=\n  by\n  induction' l1 with hd tl IH\n  · simp [of_digits]\n  · rw [of_digits, list.cons_append, of_digits, IH, list.length_cons, pow_succ']\n    ring\n#align of_digits_append of_digits_append\n\n",
 "nine_dvd_iff":
 "theorem nine_dvd_iff (n : ℕ) : 9 ∣ n ↔ 9 ∣ (digits 10 n).sum :=\n  dvd_iff_dvd_digits_sum 9 10 (by norm_num) n\n#align nine_dvd_iff nine_dvd_iff\n\n",
 "modeq_three_digits_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_three_digits_sum (n : ℕ) : «expr ≡ [MOD ]» n (digits 10 n).sum 3 :=\n  modeq_digits_sum 3 10 (by norm_num) n\n#align modeq_three_digits_sum modeq_three_digits_sum\n\n",
 "modeq_nine_digits_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_nine_digits_sum (n : ℕ) : «expr ≡ [MOD ]» n (digits 10 n).sum 9 :=\n  modeq_digits_sum 9 10 (by norm_num) n\n#align modeq_nine_digits_sum modeq_nine_digits_sum\n\n",
 "modeq_eleven_digits_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\ntheorem modeq_eleven_digits_sum (n : ℕ) :\n    «expr ≡ [ZMOD ]» n ((digits 10 n).map fun n : ℕ => (n : ℤ)).alternating_sum 11 :=\n  by\n  have t := zmodeq_of_digits_digits 11 10 (-1 : ℤ) (by unfold Int.ModEq <;> norm_num) n\n  rwa [of_digits_neg_one] at t\n#align modeq_eleven_digits_sum modeq_eleven_digits_sum\n\n",
 "modeq_digits_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_digits_sum (b b' : ℕ) (h : b' % b = 1) (n : ℕ) : «expr ≡ [MOD ]» n (digits b' n).sum b :=\n  by\n  rw [← of_digits_one]\n  conv =>\n    congr\n    skip\n    rw [← of_digits_digits b' n]\n  convert of_digits_modeq _ _ _\n  exact h.symm\n#align modeq_digits_sum modeq_digits_sum\n\n",
 "lt_base_pow_length_digits'":
 "/-- Any number m is less than (b+2)^(number of digits in the base b + 2 representation of m) -/\ntheorem lt_base_pow_length_digits' {b m : ℕ} : m < (b + 2) ^ (digits (b + 2) m).length :=\n  by\n  convert of_digits_lt_base_pow_length' fun _ => digits_lt_base'\n  rw [of_digits_digits (b + 2) m]\n#align lt_base_pow_length_digits' lt_base_pow_length_digits'\n\n",
 "lt_base_pow_length_digits":
 "/-- Any number m is less than b^(number of digits in the base b representation of m) -/\ntheorem lt_base_pow_length_digits {b m : ℕ} (hb : 1 < b) : m < b ^ (digits b m).length :=\n  by\n  rcases b with (_ | _ | b) <;> try linarith\n  exact lt_base_pow_length_digits'\n#align lt_base_pow_length_digits lt_base_pow_length_digits\n\n",
 "le_digits_len_le":
 "theorem le_digits_len_le (b n m : ℕ) (h : n ≤ m) : (digits b n).length ≤ (digits b m).length :=\n  monotone_nat_of_le_succ (digits_len_le_digits_len_succ b) h\n#align le_digits_len_le le_digits_len_le\n\n",
 "last_digit_ne_zero":
 "theorem last_digit_ne_zero (b : ℕ) {m : ℕ} (hm : m ≠ 0) : (digits b m).last (digits_ne_nil_iff_ne_zero.mpr hm) ≠ 0 :=\n  by\n  rcases b with (_ | _ | b)\n  · cases m\n    · cases hm rfl\n    · simp\n  · cases m\n    · cases hm rfl\n    simpa only [digits_one, List.getLast_replicate_succ m 1] using one_ne_zero\n  revert hm\n  apply nat.strong_induction_on m\n  intro n IH hn\n  by_cases hnb : n < b + 2\n  · simpa only [digits_of_lt (b + 2) n hn hnb]\n  · rw [digits_last n (show 2 ≤ b + 2 by decide)]\n    refine' IH _ (nat.div_lt_self hn.bot_lt (by decide)) _\n    · rw [← pos_iff_ne_zero]\n      exact Nat.div_pos (le_of_not_lt hnb) (by decide)\n#align last_digit_ne_zero last_digit_ne_zero\n\n",
 "injective":
 "theorem digits.injective (b : ℕ) : function.injective b.digits :=\n  function.left_inverse.injective (of_digits_digits b)\n#align digits.injective digits.injective\n\n",
 "eleven_dvd_of_palindrome":
 "theorem eleven_dvd_of_palindrome (p : (digits 10 n).palindrome) (h : Even (digits 10 n).length) : 11 ∣ n :=\n  by\n  let dig := (digits 10 n).map (coe : ℕ → ℤ)\n  replace h : Even dig.length := by rwa [list.length_map]\n  refine' eleven_dvd_iff.2 ⟨0, (_ : dig.alternating_sum = 0)⟩\n  have := dig.alternating_sum_reverse\n  rw [(p.map _).reverse_eq, pow_succ, h.neg_one_pow, mul_one, neg_one_zsmul] at this\n  exact eq_zero_of_neg_eq this.symm\n#align eleven_dvd_of_palindrome eleven_dvd_of_palindrome\n\n",
 "eleven_dvd_iff":
 "theorem eleven_dvd_iff : 11 ∣ n ↔ (11 : ℤ) ∣ ((digits 10 n).map fun n : ℕ => (n : ℤ)).alternating_sum :=\n  by\n  have t := dvd_iff_dvd_of_digits 11 10 (-1 : ℤ) (by norm_num) n\n  rw [of_digits_neg_one] at t\n  exact t\n#align eleven_dvd_iff eleven_dvd_iff\n\n",
 "dvd_of_digits_sub_of_digits":
 "-- This is really a theorem about polynomials.\ntheorem dvd_of_digits_sub_of_digits {α : Type _} [CommRing α] {a b k : α} (h : k ∣ a - b) (L : list ℕ) :\n    k ∣ of_digits a L - of_digits b L := by\n  induction' L with d L ih\n  · change k ∣ 0 - 0\n    simp\n  · simp only [of_digits, add_sub_add_left_eq_sub]\n    exact dvd_mul_sub_mul h ih\n#align dvd_of_digits_sub_of_digits dvd_of_digits_sub_of_digits\n\n",
 "dvd_iff_dvd_of_digits":
 "theorem dvd_iff_dvd_of_digits (b b' : ℕ) (c : ℤ) (h : (b : ℤ) ∣ (b' : ℤ) - c) (n : ℕ) :\n    b ∣ n ↔ (b : ℤ) ∣ of_digits c (digits b' n) :=\n  by\n  rw [← Int.coe_nat_dvd]\n  exact dvd_iff_dvd_of_dvd_sub (zmodeq_of_digits_digits b b' c (Int.modEq_iff_dvd.2 h).symm _).symm.dvd\n#align dvd_iff_dvd_of_digits dvd_iff_dvd_of_digits\n\n",
 "dvd_iff_dvd_digits_sum":
 "theorem dvd_iff_dvd_digits_sum (b b' : ℕ) (h : b' % b = 1) (n : ℕ) : b ∣ n ↔ b ∣ (digits b' n).sum :=\n  by\n  rw [← of_digits_one]\n  conv_lhs => rw [← of_digits_digits b' n]\n  rw [nat.dvd_iff_mod_eq_zero, nat.dvd_iff_mod_eq_zero, of_digits_mod, h]\n#align dvd_iff_dvd_digits_sum dvd_iff_dvd_digits_sum\n\n",
 "digits_zero_zero":
 "@[simp]\ntheorem digits_zero_zero : digits 0 0 = [] :=\n  rfl\n#align digits_zero_zero digits_zero_zero\n\n",
 "digits_zero_succ'":
 "theorem digits_zero_succ' : ∀ {n : ℕ}, n ≠ 0 → digits 0 n = [n]\n  | 0, h => (h rfl).elim\n  | n + 1, _ => rfl\n#align digits_zero_succ' digits_zero_succ'\n\n",
 "digits_zero_succ":
 "@[simp]\ntheorem digits_zero_succ (n : ℕ) : digits 0 n.succ = [n + 1] :=\n  rfl\n#align digits_zero_succ digits_zero_succ\n\n",
 "digits_zero_of_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem digits_zero_of_eq_zero {b : ℕ} (h : b ≠ 0) : ∀ {L : list ℕ} (h0 : of_digits b L = 0), ∀ l ∈ L, l = 0\n  | sym.cons' a L, h0, l, or.inl rfl => nat.eq_zero_of_add_eq_zero_right h0\n  | sym.cons' a L, h0, l, or.inr hL =>\n    digits_zero_of_eq_zero (mul_right_injective₀ h (nat.eq_zero_of_add_eq_zero_left h0)) _ hL\n#align digits_zero_of_eq_zero digits_zero_of_eq_zero\n\n",
 "digits_zero":
 "@[simp]\ntheorem digits_zero (b : ℕ) : digits b 0 = [] := by\n  rcases b with (_ | ⟨_ | ⟨_⟩⟩) <;> simp [digits, digits_aux_0, digits_aux_1]\n#align digits_zero digits_zero\n\n",
 "digits_two_eq_bits":
 "theorem digits_two_eq_bits (n : ℕ) : digits 2 n = n.bits.map fun b => cond b 1 0 :=\n  by\n  induction' n using Nat.binaryRecFromOne with b n h ih\n  · simp\n  · simp\n  rw [bits_append_bit _ _ fun hn => absurd hn h]\n  cases b\n  · rw [digits_def' one_lt_two]\n    · simpa [Nat.bit, Nat.bit0_val n]\n    · simpa [pos_iff_ne_zero, bit_eq_zero_iff]\n  · simpa [Nat.bit, Nat.bit1_val n, add_comm, digits_add 2 one_lt_two 1 n]\n#align digits_two_eq_bits digits_two_eq_bits\n\n",
 "digits_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem digits_succ (b n m r l) (e : r + b * m = n) (hr : r < b) (h : nat.digits b m = l ∧ 1 < b ∧ 0 < m) :\n    nat.digits b n = sym.cons' r l ∧ 1 < b ∧ 0 < n :=\n  by\n  rcases h with ⟨h, b2, m0⟩\n  have b0 : 0 < b := by linarith\n  have n0 : 0 < n := by linarith [mul_pos b0 m0]\n  refine' ⟨_, b2, n0⟩\n  obtain ⟨rfl, rfl⟩ := (Nat.div_mod_unique b0).2 ⟨e, hr⟩\n  subst h; exact nat.digits_def' b2 n0\n#align digits_succ digits_succ\n\n",
 "digits_one_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp]\ntheorem digits_one_succ (n : ℕ) : digits 1 (n + 1) = sym.cons' 1 (digits 1 n) :=\n  rfl\n#align digits_one_succ digits_one_succ\n\n",
 "digits_one":
 "theorem digits_one (b n) (n0 : 0 < n) (nb : n < b) : nat.digits b n = [n] ∧ 1 < b ∧ 0 < n :=\n  by\n  have b2 : 1 < b := by linarith\n  refine' ⟨_, b2, n0⟩\n  rw [nat.digits_def' b2 n0, nat.mod_eq_of_lt nb, (Nat.div_eq_zero_iff ((zero_le n).trans_lt nb)).2 nb, nat.digits_zero]\n#align digits_one digits_one\n\n",
 "digits_of_lt":
 "@[simp]\ntheorem digits_of_lt (b x : ℕ) (hx : x ≠ 0) (hxb : x < b) : digits b x = [x] :=\n  by\n  rcases exists_eq_succ_of_ne_zero hx with ⟨x, rfl⟩\n  rcases exists_eq_add_of_le' ((nat.le_add_left 1 x).trans_lt hxb) with ⟨b, rfl⟩\n  rw [digits_add_two_add_one, div_eq_of_lt hxb, digits_zero, mod_eq_of_lt hxb]\n#align digits_of_lt digits_of_lt\n\n",
 "digits_of_digits":
 "theorem digits_of_digits (b : ℕ) (h : 1 < b) (L : list ℕ) (w₁ : ∀ l ∈ L, l < b) (w₂ : ∀ h : L ≠ [], L.last h ≠ 0) :\n    digits b (of_digits b L) = L := by\n  induction' L with d L ih\n  · dsimp [of_digits]\n    simp\n  · dsimp [of_digits]\n    replace w₂ := w₂ (by simp)\n    rw [digits_add b h]\n    · rw [ih]\n      · intro l m\n        apply w₁\n        exact list.mem_cons_of_mem _ m\n      · intro h\n        · rw [List.getLast_cons h] at w₂\n          convert w₂\n    · exact w₁ d (list.mem_cons_self _ _)\n    · by_cases h' : L = []\n      · rcases h' with rfl\n        left\n        simpa using w₂\n      · right\n        contrapose! w₂\n        refine' digits_zero_of_eq_zero h.ne_bot w₂ _ _\n        rw [List.getLast_cons h']\n        exact List.getLast_mem h'\n#align digits_of_digits digits_of_digits\n\n",
 "digits_ne_nil_iff_ne_zero":
 "theorem digits_ne_nil_iff_ne_zero {b n : ℕ} : digits b n ≠ [] ↔ n ≠ 0 :=\n  not_congr digits_eq_nil_iff_eq_zero\n#align digits_ne_nil_iff_ne_zero digits_ne_nil_iff_ne_zero\n\n",
 "digits_lt_base'":
 "/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem digits_lt_base' {b m : ℕ} : ∀ {d}, d ∈ digits (b + 2) m → d < b + 2 :=\n  by\n  apply nat.strong_induction_on m\n  intro n IH d hd\n  cases' n with n\n  · rw [digits_zero] at hd\n    cases hd\n  -- base b+2 expansion of 0 has no digits\n  rw [digits_add_two_add_one] at hd\n  cases hd\n  · rw [hd]\n    exact n.succ.mod_lt (by linarith)\n  · exact IH _ (nat.div_lt_self (nat.succ_pos _) (by linarith)) hd\n#align digits_lt_base' digits_lt_base'\n\n",
 "digits_lt_base":
 "/-- The digits in the base b expansion of n are all less than b, if b ≥ 2 -/\ntheorem digits_lt_base {b m d : ℕ} (hb : 1 < b) (hd : d ∈ digits b m) : d < b :=\n  by\n  rcases b with (_ | _ | b) <;> try linarith\n  exact digits_lt_base' hd\n#align digits_lt_base digits_lt_base\n\n",
 "digits_len_le_digits_len_succ":
 "theorem digits_len_le_digits_len_succ (b n : ℕ) : (digits b n).length ≤ (digits b (n + 1)).length :=\n  by\n  rcases decidable.eq_or_ne n 0 with (rfl | hn)\n  · simp\n  cases' le_or_lt b 1 with hb hb\n  · interval_cases b <;> simp [digits_zero_succ', hn]\n  simpa [digits_len, hb, hn] using log_mono_right (le_succ _)\n#align digits_len_le_digits_len_succ digits_len_le_digits_len_succ\n\n",
 "digits_len":
 "theorem digits_len (b n : ℕ) (hb : 1 < b) (hn : n ≠ 0) : (b.digits n).length = b.log n + 1 :=\n  by\n  induction' n using nat.strong_induction_on with n IH\n  rw [digits_eq_cons_digits_div hb hn, list.length]\n  by_cases h : n / b = 0\n  · have hb0 : b ≠ 0 := (Nat.succ_le_iff.1 hb).ne_bot\n    simp [h, log_eq_zero_iff, ← Nat.div_eq_zero_iff hb0.bot_lt]\n  · have hb' : 1 < b := one_lt_two.trans_le hb\n    have : n / b < n := div_lt_self (nat.pos_of_ne_zero hn) hb'\n    rw [IH _ this h, log_div_base, tsub_add_cancel_of_le]\n    refine' nat.succ_le_of_lt (log_pos hb' _)\n    contrapose! h\n    exact div_eq_of_lt h\n#align digits_len digits_len\n\n",
 "digits_last":
 "theorem digits_last {b : ℕ} (m : ℕ) (h : 1 < b) (p q) : (digits b m).last p = (digits b (m / b)).last q :=\n  by\n  by_cases hm : m = 0\n  · simp [hm]\n  simp only [digits_eq_cons_digits_div h hm]\n  rw [List.getLast_cons]\n#align digits_last digits_last\n\n",
 "digits_inj_iff":
 "@[simp]\ntheorem digits_inj_iff {b n m : ℕ} : b.digits n = b.digits m ↔ n = m :=\n  (digits.injective b).eq_iff\n#align digits_inj_iff digits_inj_iff\n\n",
 "digits_eq_nil_iff_eq_zero":
 "theorem digits_eq_nil_iff_eq_zero {b n : ℕ} : digits b n = [] ↔ n = 0 :=\n  by\n  constructor\n  · intro h\n    have : of_digits b (digits b n) = of_digits b [] := by rw [h]\n    convert this\n    rw [of_digits_digits]\n  · rintro rfl\n    simp\n#align digits_eq_nil_iff_eq_zero digits_eq_nil_iff_eq_zero\n\n",
 "digits_eq_cons_digits_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem digits_eq_cons_digits_div {b n : ℕ} (h : 1 < b) (w : n ≠ 0) :\n    digits b n = sym.cons' (n % b) (digits b (n / b)) :=\n  by\n  rcases b with (_ | _ | b)\n  · rw [digits_zero_succ' w, nat.mod_zero, nat.div_zero, nat.digits_zero_zero]\n  · norm_num at h\n  rcases n with (_ | n)\n  · norm_num at w\n  simp\n#align digits_eq_cons_digits_div digits_eq_cons_digits_div\n\n",
 "digits_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem digits_def' : ∀ {b : ℕ} (h : 1 < b) {n : ℕ} (w : 0 < n), digits b n = sym.cons' (n % b) (digits b (n / b))\n  | 0, h => absurd h (by decide)\n  | 1, h => absurd h (by decide)\n  | b + 2, h => digits_aux_def _ _\n#align digits_def' digits_def'\n\n",
 "digits_aux_zero":
 "/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Shing Tak Lam, Mario Carneiro\n-/\n@[simp]\ntheorem digits_aux_zero (b : ℕ) (h : 2 ≤ b) : digits_aux b h 0 = [] := by rw [digits_aux]\n#align digits_aux_zero digits_aux_zero\n\n",
 "digits_aux_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem digits_aux_def (b : ℕ) (h : 2 ≤ b) (n : ℕ) (w : 0 < n) :\n    digits_aux b h n = sym.cons' (n % b) (digits_aux b h (n / b)) :=\n  by\n  cases n\n  · cases w\n  · rw [digits_aux]\n#align digits_aux_def digits_aux_def\n\n",
 "digits_add_two_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp]\ntheorem digits_add_two_add_one (b n : ℕ) :\n    digits (b + 2) (n + 1) = sym.cons' ((n + 1) % (b + 2)) (digits (b + 2) ((n + 1) / (b + 2))) :=\n  by\n  rw [digits, digits_aux_def]\n  exact succ_pos n\n#align digits_add_two_add_one digits_add_two_add_one\n\n",
 "digits_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem digits_add (b : ℕ) (h : 1 < b) (x y : ℕ) (hxb : x < b) (hxy : x ≠ 0 ∨ y ≠ 0) :\n    digits b (x + b * y) = sym.cons' x (digits b y) :=\n  by\n  rcases exists_eq_add_of_le' h with ⟨b, rfl : _ = _ + 2⟩\n  cases y\n  · simp [hxb, hxy.resolve_right (absurd rfl)]\n  dsimp [digits]\n  rw [digits_aux_def]\n  · congr\n    · simp [Nat.add_mod, mod_eq_of_lt hxb]\n    · simp [add_mul_div_left, div_eq_of_lt hxb]\n  · apply nat.succ_pos\n#align digits_add digits_add\n\n",
 "coe_of_digits":
 "@[norm_cast]\ntheorem coe_of_digits (α : Type _) [Semiring α] (b : ℕ) (L : list ℕ) :\n    ((of_digits b L : ℕ) : α) = of_digits (b : α) L :=\n  by\n  induction' L with d L ih\n  · simp [of_digits]\n  · dsimp [of_digits]\n    push_cast\n    rw [ih]\n#align coe_of_digits coe_of_digits\n\n",
 "coe_int_of_digits":
 "@[norm_cast]\ntheorem coe_int_of_digits (b : ℕ) (L : list ℕ) : ((of_digits b L : ℕ) : ℤ) = of_digits (b : ℤ) L :=\n  by\n  induction' L with d L ih\n  · rfl\n  · dsimp [of_digits]\n    push_cast\n#align coe_int_of_digits coe_int_of_digits\n\n",
 "base_pow_length_digits_le'":
 "/-- Any non-zero natural number `m` is greater than\n(b+2)^((number of digits in the base (b+2) representation of m) - 1)\n-/\ntheorem base_pow_length_digits_le' (b m : ℕ) (hm : m ≠ 0) : (b + 2) ^ (digits (b + 2) m).length ≤ (b + 2) * m :=\n  by\n  have : digits (b + 2) m ≠ [] := digits_ne_nil_iff_ne_zero.mpr hm\n  convert pow_length_le_mul_of_digits this (last_digit_ne_zero _ hm)\n  rwa [of_digits_digits]\n#align base_pow_length_digits_le' base_pow_length_digits_le'\n\n",
 "base_pow_length_digits_le":
 "/-- Any non-zero natural number `m` is greater than\nb^((number of digits in the base b representation of m) - 1)\n-/\ntheorem base_pow_length_digits_le (b m : ℕ) (hb : 1 < b) : m ≠ 0 → b ^ (digits b m).length ≤ b * m :=\n  by\n  rcases b with (_ | _ | b) <;> try linarith\n  exact base_pow_length_digits_le' b m\n#align base_pow_length_digits_le base_pow_length_digits_le\n\n"}