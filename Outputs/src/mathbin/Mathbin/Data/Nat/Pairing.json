{"unpair_zero":
 "@[simp]\ntheorem unpair_zero : unpair 0 = 0 := by\n  rw [unpair]\n  simp\n#align unpair_zero unpair_zero\n\n",
 "unpair_right_le":
 "theorem unpair_right_le (n : ℕ) : (unpair n).2 ≤ n := by simpa using right_le_mkpair n.unpair.1 n.unpair.2\n#align unpair_right_le unpair_right_le\n\n",
 "unpair_mkpair":
 "@[simp]\ntheorem unpair_mkpair (a b : ℕ) : unpair (mkpair a b) = (a, b) :=\n  by\n  dsimp only [mkpair]; split_ifs\n  · show unpair (b * b + a) = (a, b)\n    have be : sqrt (b * b + a) = b := sqrt_add_eq _ (le_trans (le_of_lt h) (nat.le_add_left _ _))\n    simp [unpair, be, add_tsub_cancel_right, h]\n  · show unpair (a * a + a + b) = (a, b)\n    have ae : sqrt (a * a + (a + b)) = a := by\n      rw [sqrt_add_eq]\n      exact add_le_add_left (le_of_not_gt h) _\n    simp [unpair, ae, nat.not_lt_zero, add_assoc]\n#align unpair_mkpair unpair_mkpair\n\n",
 "unpair_lt":
 "theorem unpair_lt {n : ℕ} (n1 : 1 ≤ n) : (unpair n).1 < n :=\n  by\n  let s := sqrt n\n  simp [unpair]; change sqrt n with s\n  by_cases h : n - s * s < s <;> simp [h]\n  · exact lt_of_lt_of_le h (sqrt_le_self _)\n  · simp at h\n    have s0 : 0 < s := sqrt_pos.2 n1\n    exact lt_of_le_of_lt h (tsub_lt_self n1 (mul_pos s0 s0))\n#align unpair_lt unpair_lt\n\n",
 "unpair_left_le":
 "theorem unpair_left_le : ∀ n : ℕ, (unpair n).1 ≤ n\n  | 0 => by simp\n  | n + 1 => le_of_lt (unpair_lt (nat.succ_pos _))\n#align unpair_left_le unpair_left_le\n\n",
 "unpair_add_le":
 "theorem unpair_add_le (n : ℕ) : (unpair n).1 + (unpair n).2 ≤ n :=\n  (add_le_mkpair _ _).trans_eq (mkpair_unpair _)\n#align unpair_add_le unpair_add_le\n\n",
 "surjective_unpair":
 "theorem surjective_unpair : surjective unpair :=\n  mkpairEquiv.symm.surjective\n#align surjective_unpair surjective_unpair\n\n",
 "supᵢ_unpair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_unpair /-\ntheorem supᵢ_unpair {α} [CompleteLattice α] (f : ℕ → ℕ → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (f n.unpair.1 n.unpair.2) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j) :=\n  by\n  rw [←\n    (supᵢ_prod :\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i.1 i.2) = _),\n    ← nat.surjective_unpair.supr_comp]\n#align supr_unpair supᵢ_unpair\n-/\n\n",
 "right_le_mkpair":
 "theorem right_le_mkpair (a b : ℕ) : b ≤ mkpair a b :=\n  by\n  by_cases h : a < b <;> simp [mkpair, h]\n  exact le_trans (le_mul_self _) (nat.le_add_right _ _)\n#align right_le_mkpair right_le_mkpair\n\n",
 "mkpair_unpair'":
 "theorem mkpair_unpair' {n a b} (H : unpair n = (a, b)) : mkpair a b = n := by simpa [H] using mkpair_unpair n\n#align mkpair_unpair' mkpair_unpair'\n\n",
 "mkpair_unpair":
 "/-\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura, Mario Carneiro\n-/\n@[simp]\ntheorem mkpair_unpair (n : ℕ) : mkpair (unpair n).1 (unpair n).2 = n :=\n  by\n  dsimp only [unpair]; set s := sqrt n\n  have sm : s * s + (n - s * s) = n := add_tsub_cancel_of_le (sqrt_le _)\n  split_ifs\n  · simp [mkpair, h, sm]\n  · have hl : n - s * s - s ≤ s :=\n      tsub_le_iff_left.mpr (tsub_le_iff_left.mpr <| by rw [← add_assoc] <;> apply sqrt_le_add)\n    simp [mkpair, hl.not_lt, add_assoc, add_tsub_cancel_of_le (le_of_not_gt h), sm]\n#align mkpair_unpair mkpair_unpair\n\n",
 "mkpair_lt_mkpair_right":
 "theorem mkpair_lt_mkpair_right (a) {b₁ b₂} (h : b₁ < b₂) : mkpair a b₁ < mkpair a b₂ :=\n  by\n  by_cases h₁ : a < b₁ <;> simp [mkpair, h₁, add_assoc]\n  · simp [mkpair, lt_trans h₁ h, h]\n    exact mul_self_lt_mul_self h\n  · by_cases h₂ : a < b₂ <;> simp [mkpair, h₂, h]\n    simp at h₁\n    rw [add_comm, add_comm _ a, add_assoc, add_lt_add_iff_left]\n    rwa [add_comm, ← sqrt_lt, sqrt_add_eq]\n    exact le_trans h₁ (nat.le_add_left _ _)\n#align mkpair_lt_mkpair_right mkpair_lt_mkpair_right\n\n",
 "mkpair_lt_mkpair_left":
 "theorem mkpair_lt_mkpair_left {a₁ a₂} (b) (h : a₁ < a₂) : mkpair a₁ b < mkpair a₂ b :=\n  by\n  by_cases h₁ : a₁ < b <;> simp [mkpair, h₁, add_assoc]\n  · by_cases h₂ : a₂ < b <;> simp [mkpair, h₂, h]\n    simp at h₂\n    apply add_lt_add_of_le_of_lt\n    exact mul_self_le_mul_self h₂\n    exact lt_add_right _ _ _ h\n  · simp at h₁\n    simp [not_lt_of_gt (lt_of_le_of_lt h₁ h)]\n    apply add_lt_add\n    exact mul_self_lt_mul_self h\n    apply add_lt_add_right <;> assumption\n#align mkpair_lt_mkpair_left mkpair_lt_mkpair_left\n\n",
 "mkpair_lt_max_add_one_sq":
 "theorem mkpair_lt_max_add_one_sq (m n : ℕ) : mkpair m n < (max m n + 1) ^ 2 :=\n  by\n  rw [mkpair, add_sq, mul_one, two_mul, sq, add_assoc, add_assoc]\n  cases lt_or_le m n\n  · rw [if_pos h, max_eq_right h.le, add_lt_add_iff_left, add_assoc]\n    exact h.trans_le (self_le_add_right n _)\n  · rw [if_neg h.not_lt, max_eq_left h, add_lt_add_iff_left, add_assoc, add_lt_add_iff_left]\n    exact lt_succ_of_le h\n#align mkpair_lt_max_add_one_sq mkpair_lt_max_add_one_sq\n\n",
 "mkpair_eq_mkpair":
 "@[simp]\ntheorem mkpair_eq_mkpair {a b c d : ℕ} : mkpair a b = mkpair c d ↔ a = c ∧ b = d :=\n  mkpairEquiv.injective.eq_iff.trans (@prod.ext_iff ℕ ℕ (a, b) (c, d))\n#align mkpair_eq_mkpair mkpair_eq_mkpair\n\n",
 "max_sq_add_min_le_mkpair":
 "theorem max_sq_add_min_le_mkpair (m n : ℕ) : max m n ^ 2 + min m n ≤ mkpair m n :=\n  by\n  rw [mkpair]\n  cases lt_or_le m n\n  · rw [if_pos h, max_eq_right h.le, min_eq_left h.le, sq]\n  · rw [if_neg h.not_lt, max_eq_left h, min_eq_right h, sq, add_assoc, add_le_add_iff_left]\n    exact le_add_self\n#align max_sq_add_min_le_mkpair max_sq_add_min_le_mkpair\n\n",
 "left_le_mkpair":
 "theorem left_le_mkpair (a b : ℕ) : a ≤ mkpair a b := by simpa using unpair_left_le (mkpair a b)\n#align left_le_mkpair left_le_mkpair\n\n",
 "infᵢ_unpair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_unpair /-\ntheorem infᵢ_unpair {α} [CompleteLattice α] (f : ℕ → ℕ → α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (f n.unpair.1 n.unpair.2) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j) :=\n  supᵢ_unpair (show ℕ → ℕ → «expr ᵒᵈ» α from f)\n#align infi_unpair infᵢ_unpair\n-/\n\n",
 "add_le_mkpair":
 "theorem add_le_mkpair (m n : ℕ) : m + n ≤ mkpair m n :=\n  (max_sq_add_min_le_mkpair _ _).trans' <|\n    by\n    rw [sq, ← min_add_max, add_comm, add_le_add_iff_right]\n    exact le_mul_self _\n#align add_le_mkpair add_le_mkpair\n\n",
 "Union_unpair_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_unpair_prod {α β} {s : ℕ → set α} {t : ℕ → set β} :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (set.prod (s n.unpair.fst) (t n.unpair.snd)) =\n      set.prod («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n))\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t n)) :=\n  by\n  rw [← Union_prod]\n  convert surjective_unpair.Union_comp _\n  rfl\n#align Union_unpair_prod Union_unpair_prod\n\n",
 "Union_unpair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_unpair {α} (f : ℕ → ℕ → set α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (f n.unpair.1 n.unpair.2) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i j) :=\n  supᵢ_unpair f\n#align Union_unpair Union_unpair\n\n",
 "Inter_unpair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem Inter_unpair {α} (f : ℕ → ℕ → set α) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (f n.unpair.1 n.unpair.2) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i j) :=\n  infᵢ_unpair f\n#align Inter_unpair Inter_unpair\n\n"}