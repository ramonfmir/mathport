{"sum_divisors_filter_squarefree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_divisors_filter_squarefree {n : ℕ} (h0 : n ≠ 0) {α : Type _} [add_comm_monoid α] {f : ℕ → α} :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (n.divisors.filter squarefree) (f i) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (unique_factorization_monoid.normalized_factors n).to_finset.powerset (f i.val.prod) :=\n  by rw [finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, Multiset.map_map, finset.sum_eq_multiset_sum]\n#align sum_divisors_filter_squarefree sum_divisors_filter_squarefree\n\n",
 "squarefree_two":
 "theorem squarefree_two : squarefree 2 := by rw [squarefree_iff_nodup_factors] <;> norm_num\n#align squarefree_two squarefree_two\n\n",
 "squarefree_pow_iff":
 "theorem squarefree_pow_iff {n k : ℕ} (hn : n ≠ 1) (hk : k ≠ 0) : squarefree (n ^ k) ↔ squarefree n ∧ k = 1 :=\n  by\n  refine'\n    ⟨fun h => _, by\n      rintro ⟨hn, rfl⟩\n      simpa⟩\n  rcases eq_or_ne n 0 with (rfl | hn₀)\n  · simpa [zero_pow hk.bot_lt] using h\n  refine' ⟨h.squarefree_of_dvd (dvd_pow_self _ hk), by_contradiction fun h₁ => _⟩\n  have : 2 ≤ k := k.two_le_iff.mpr ⟨hk, h₁⟩\n  apply hn (Nat.isUnit_iff.1 (h _ _))\n  rw [← sq]\n  exact pow_dvd_pow _ this\n#align squarefree_pow_iff squarefree_pow_iff\n\n",
 "squarefree_of_factorization_le_one":
 "theorem squarefree_of_factorization_le_one {n : ℕ} (hn : n ≠ 0) (hn' : ∀ p, n.factorization p ≤ 1) : squarefree n :=\n  by\n  rw [squarefree_iff_nodup_factors hn, List.nodup_iff_count_le_one]\n  intro a\n  rw [factors_count_eq]\n  apply hn'\n#align squarefree_of_factorization_le_one squarefree_of_factorization_le_one\n\n",
 "squarefree_mul":
 "/-- `squarefree` is multiplicative. Note that the → direction does not require `hmn`\nand generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and\n`squarefree.of_mul_right` above for auxiliary lemmas. -/\ntheorem squarefree_mul {m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n :=\n  by\n  simp only [squarefree_iff_prime_squarefree, ← sq, ← forall_and]\n  refine' ball_congr fun p hp => _\n  simp only [hmn.is_prime_pow_dvd_mul (hp.is_prime_pow.pow two_ne_zero), not_or]\n#align squarefree_mul squarefree_mul\n\n",
 "squarefree_iff_prime_squarefree":
 "theorem squarefree_iff_prime_squarefree {n : ℕ} : squarefree n ↔ ∀ x, Prime x → ¬x * x ∣ n :=\n  squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible ⟨_, prime_two⟩\n#align squarefree_iff_prime_squarefree squarefree_iff_prime_squarefree\n\n",
 "squarefree_iff_nodup_factors":
 "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\ntheorem squarefree_iff_nodup_factors {n : ℕ} (h0 : n ≠ 0) : squarefree n ↔ n.factors.nodup :=\n  by\n  rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors h0, nat.factors_eq]\n  simp\n#align squarefree_iff_nodup_factors squarefree_iff_nodup_factors\n\n",
 "squarefree_iff_min_sq_fac":
 "theorem squarefree_iff_min_sq_fac {n : ℕ} : squarefree n ↔ n.min_sq_fac = none :=\n  by\n  have := min_sq_fac_has_prop n\n  constructor <;> intro H\n  · cases' n.min_sq_fac with d\n    · rfl\n    cases squarefree_iff_prime_squarefree.1 H _ this.1 this.2.1\n  · rwa [H] at this\n#align squarefree_iff_min_sq_fac squarefree_iff_min_sq_fac\n\n",
 "squarefree_iff_factorization_le_one":
 "theorem squarefree_iff_factorization_le_one {n : ℕ} (hn : n ≠ 0) : squarefree n ↔ ∀ p, n.factorization p ≤ 1 :=\n  ⟨fun p hn => squarefree.factorization_le_one hn p, squarefree_of_factorization_le_one hn⟩\n#align squarefree_iff_factorization_le_one squarefree_iff_factorization_le_one\n\n",
 "squarefree_helper_4":
 "theorem squarefree_helper_4 (n k k' : ℕ) (e : bit1 k * bit1 k = k') (hd : bit1 n < k') : squarefree_helper n k :=\n  by\n  cases' nat.eq_zero_or_pos n with h h\n  · subst n\n    exact fun _ _ => squarefree_one\n  subst e\n  refine' fun k0 ih => irreducible.squarefree (Nat.prime_def_le_sqrt.2 ⟨bit1_lt_bit1.2 h, _⟩)\n  intro m m2 hm md\n  obtain ⟨p, pp, hp⟩ := Nat.exists_prime_and_dvd (ne_of_gt m2)\n  have := (ih p pp (dvd_trans hp md)).trans (le_trans (nat.le_of_dvd (lt_of_lt_of_le (by decide) m2) hp) hm)\n  rw [Nat.le_sqrt] at this\n  exact not_le_of_lt hd this\n#align squarefree_helper_4 squarefree_helper_4\n\n",
 "squarefree_helper_3":
 "theorem squarefree_helper_3 (n n' k k' c : ℕ) (e : k + 1 = k') (hn' : bit1 n' * bit1 k = bit1 n)\n    (hc : bit1 n' % bit1 k = c) (c0 : 0 < c) (H : squarefree_helper n' k') : squarefree_helper n k := fun k0 ih =>\n  by\n  subst e\n  have k0' : 0 < bit1 k := bit1_pos (nat.zero_le _)\n  have dn' : bit1 n' ∣ bit1 n := ⟨_, hn'.symm⟩\n  have dk : bit1 k ∣ bit1 n := ⟨_, ((mul_comm _ _).trans hn').symm⟩\n  have : bit1 n / bit1 k = bit1 n' := by rw [← hn', nat.mul_div_cancel _ k0']\n  have k2 : 2 ≤ bit1 k := nat.succ_le_succ (bit0_pos k0)\n  have pk : (bit1 k).prime :=\n    by\n    refine' Nat.prime_def_minFac.2 ⟨k2, le_antisymm (Nat.minFac_le k0') _⟩\n    exact ih _ (Nat.minFac_prime (ne_of_gt k2)) (dvd_trans (Nat.minFac_dvd _) dk)\n  have dkk' : ¬bit1 k ∣ bit1 n' := by\n    rw [nat.dvd_iff_mod_eq_zero, hc]\n    exact ne_of_gt c0\n  have dkk : ¬bit1 k * bit1 k ∣ bit1 n := by rwa [← Nat.dvd_div_iff dk, this]\n  refine' @nat.min_sq_fac_prop_div _ _ pk dk dkk none _\n  rw [this]\n  refine' H (nat.succ_pos _) fun p pp dp => _\n  refine' (squarefree_helper_0 k0 pp (ih p pp <| dvd_trans dp dn')).resolve_right fun e => _\n  subst e\n  contradiction\n#align squarefree_helper_3 squarefree_helper_3\n\n",
 "squarefree_helper_2":
 "theorem squarefree_helper_2 (n k k' c : ℕ) (e : k + 1 = k') (hc : bit1 n % bit1 k = c) (c0 : 0 < c)\n    (h : squarefree_helper n k') : squarefree_helper n k :=\n  by\n  refine' squarefree_helper_1 _ _ _ e (fun _ => _) h\n  refine' mt _ (ne_of_gt c0); intro e₁\n  rwa [← hc, ← nat.dvd_iff_mod_eq_zero]\n#align squarefree_helper_2 squarefree_helper_2\n\n",
 "squarefree_helper_1":
 "theorem squarefree_helper_1 (n k k' : ℕ) (e : k + 1 = k') (hk : Nat.Prime (bit1 k) → ¬bit1 k ∣ bit1 n)\n    (H : squarefree_helper n k') : squarefree_helper n k := fun k0 ih =>\n  by\n  subst e\n  refine' H (nat.succ_pos _) fun p pp dp => _\n  refine' (squarefree_helper_0 k0 pp (ih p pp dp)).resolve_right fun hp => _\n  subst hp; cases hk pp dp\n#align squarefree_helper_1 squarefree_helper_1\n\n",
 "squarefree_helper_0":
 "theorem squarefree_helper_0 {k} (k0 : 0 < k) {p : ℕ} (pp : Nat.Prime p) (h : bit1 k ≤ p) :\n    bit1 (k + 1) ≤ p ∨ bit1 k = p :=\n  by\n  rcases lt_or_eq_of_le h with ((hp : _ + 1 ≤ _) | hp)\n  · rw [bit1, bit0_eq_two_mul] at hp\n    change 2 * (_ + 1) ≤ _ at hp\n    rw [bit1, bit0_eq_two_mul]\n    refine' or.inl (lt_of_le_of_ne hp _)\n    rintro rfl\n    exact Nat.not_prime_mul (by decide) (lt_add_of_pos_left _ k0) pp\n  · exact or.inr hp\n#align squarefree_helper_0 squarefree_helper_0\n\n",
 "squarefree_bit10":
 "theorem squarefree_bit10 (n : ℕ) (h : squarefree_helper n 1) : squarefree (bit0 (bit1 n)) :=\n  by\n  refine' @nat.min_sq_fac_prop_div _ _ Nat.prime_two two_dvd_bit0 _ none _\n  · rw [bit0_eq_two_mul (bit1 n), mul_dvd_mul_iff_left (two_ne_zero' ℕ)]\n    exact Nat.not_two_dvd_bit1 _\n  · rw [bit0_eq_two_mul, nat.mul_div_right _ (by decide : 0 < 2)]\n    refine' h (by decide) fun p pp dp => nat.succ_le_of_lt (lt_of_le_of_ne pp.two_le _)\n    rintro rfl\n    exact Nat.not_two_dvd_bit1 _ dp\n#align squarefree_bit10 squarefree_bit10\n\n",
 "squarefree_bit1":
 "theorem squarefree_bit1 (n : ℕ) (h : squarefree_helper n 1) : squarefree (bit1 n) :=\n  by\n  refine' h (by decide) fun p pp dp => nat.succ_le_of_lt (lt_of_le_of_ne pp.two_le _)\n  rintro rfl; exact Nat.not_two_dvd_bit1 _ dp\n#align squarefree_bit1 squarefree_bit1\n\n",
 "squarefree_and_prime_pow_iff_prime":
 "theorem squarefree_and_prime_pow_iff_prime {n : ℕ} : squarefree n ∧ is_prime_pow n ↔ Prime n :=\n  by\n  refine' iff.symm ⟨fun hn => ⟨hn.squarefree, hn.is_prime_pow⟩, _⟩\n  rw [is_prime_pow_nat_iff]\n  rintro ⟨h, p, k, hp, hk, rfl⟩\n  rw [squarefree_pow_iff hp.ne_one hk.ne'] at h\n  rwa [h.2, pow_one]\n#align squarefree_and_prime_pow_iff_prime squarefree_and_prime_pow_iff_prime\n\n",
 "sq_mul_squarefree_of_pos'":
 "theorem sq_mul_squarefree_of_pos' {n : ℕ} (h : 0 < n) : ∃ a b : ℕ, (b + 1) ^ 2 * (a + 1) = n ∧ squarefree (a + 1) :=\n  by\n  obtain ⟨a₁, b₁, ha₁, hb₁, hab₁, hab₂⟩ := sq_mul_squarefree_of_pos h\n  refine' ⟨a₁.pred, b₁.pred, _, _⟩ <;> simpa only [add_one, succ_pred_eq_of_pos, ha₁, hb₁]\n#align sq_mul_squarefree_of_pos' sq_mul_squarefree_of_pos'\n\n",
 "sq_mul_squarefree_of_pos":
 "theorem sq_mul_squarefree_of_pos {n : ℕ} (hn : 0 < n) : ∃ a b : ℕ, 0 < a ∧ 0 < b ∧ b ^ 2 * a = n ∧ squarefree a :=\n  by\n  let S := { s ∈ Finset.range (n + 1) | s ∣ n ∧ ∃ x, s = x ^ 2 }\n  have hSne : S.nonempty := by\n    use 1\n    have h1 : 0 < n ∧ ∃ x : ℕ, 1 = x ^ 2 := ⟨hn, ⟨1, (one_pow 2).symm⟩⟩\n    simpa [S]\n  let s := finset.max' S hSne\n  have hs : s ∈ S := finset.max'_mem S hSne\n  simp only [finset.sep_def, S, Finset.mem_filter, Finset.mem_range] at hs\n  obtain ⟨hsn1, ⟨a, hsa⟩, ⟨b, hsb⟩⟩ := hs\n  rw [hsa] at hn\n  obtain ⟨hlts, hlta⟩ := canonically_ordered_comm_semiring.mul_pos.mp hn\n  rw [hsb] at hsa hn hlts\n  refine' ⟨a, b, hlta, (pow_pos_iff zero_lt_two).mp hlts, hsa.symm, _⟩\n  rintro x ⟨y, hy⟩\n  rw [Nat.isUnit_iff]\n  by_contra hx\n  refine' lt_le_antisymm _ (finset.le_max' S ((b * x) ^ 2) _)\n  · simp_rw [S, hsa, finset.sep_def, Finset.mem_filter, Finset.mem_range]\n    refine' ⟨lt_succ_iff.mpr (le_of_dvd hn _), _, ⟨b * x, rfl⟩⟩ <;> use y <;> rw [hy] <;> ring\n  · convert\n      lt_mul_of_one_lt_right hlts\n        (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr ⟨fun h => by simp_all, hx⟩))\n    rw [mul_pow]\n#align sq_mul_squarefree_of_pos sq_mul_squarefree_of_pos\n\n",
 "sq_mul_squarefree":
 "theorem sq_mul_squarefree (n : ℕ) : ∃ a b : ℕ, b ^ 2 * a = n ∧ squarefree a :=\n  by\n  cases n\n  · exact ⟨1, 0, by simp, squarefree_one⟩\n  · obtain ⟨a, b, -, -, h₁, h₂⟩ := sq_mul_squarefree_of_pos (succ_pos n)\n    exact ⟨a, b, h₁, h₂⟩\n#align sq_mul_squarefree sq_mul_squarefree\n\n",
 "not_squarefree_mul":
 "theorem not_squarefree_mul (a aa b n : ℕ) (ha : a * a = aa) (hb : aa * b = n) (h₁ : 1 < a) : ¬squarefree n :=\n  by\n  rw [← hb, ← ha]\n  exact fun H => ne_of_gt h₁ (Nat.isUnit_iff.1 <| H _ ⟨_, rfl⟩)\n#align not_squarefree_mul not_squarefree_mul\n\n",
 "min_sq_fac_prop_div":
 "theorem min_sq_fac_prop_div (n) {k} (pk : Prime k) (dk : k ∣ n) (dkk : ¬k * k ∣ n) {o} (H : min_sq_fac_prop (n / k) o) :\n    min_sq_fac_prop n o :=\n  by\n  have : ∀ p, Prime p → p * p ∣ n → k * (p * p) ∣ n := fun p pp dp =>\n    have :=\n      (coprime_primes pk pp).2 fun e => by\n        subst e\n        contradiction\n    (coprime_mul_iff_right.2 ⟨this, this⟩).mul_dvd_of_dvd_of_dvd dk dp\n  cases' o with d\n  · rw [min_sq_fac_prop, squarefree_iff_prime_squarefree] at H⊢\n    exact fun p pp dp => H p pp ((dvd_div_iff dk).2 (this _ pp dp))\n  · obtain ⟨H1, H2, H3⟩ := H\n    simp only [dvd_div_iff dk] at H2 H3\n    exact ⟨H1, dvd_trans (dvd_mul_left _ _) H2, fun p pp dp => H3 _ pp (this _ pp dp)⟩\n#align min_sq_fac_prop_div min_sq_fac_prop_div\n\n",
 "min_sq_fac_prime":
 "theorem min_sq_fac_prime {n d : ℕ} (h : n.min_sq_fac = some d) : Prime d :=\n  by\n  have := min_sq_fac_has_prop n\n  rw [h] at this\n  exact this.1\n#align min_sq_fac_prime min_sq_fac_prime\n\n",
 "min_sq_fac_le_of_dvd":
 "theorem min_sq_fac_le_of_dvd {n d : ℕ} (h : n.min_sq_fac = some d) {m} (m2 : 2 ≤ m) (md : m * m ∣ n) : d ≤ m :=\n  by\n  have := min_sq_fac_has_prop n; rw [h] at this\n  have fd := min_fac_dvd m\n  exact\n    le_trans (this.2.2 _ (min_fac_prime <| ne_of_gt m2) (dvd_trans (mul_dvd_mul fd fd) md))\n      (min_fac_le <| lt_of_lt_of_le (by decide) m2)\n#align min_sq_fac_le_of_dvd min_sq_fac_le_of_dvd\n\n",
 "min_sq_fac_has_prop":
 "theorem min_sq_fac_has_prop (n : ℕ) : min_sq_fac_prop n (min_sq_fac n) :=\n  by\n  dsimp only [min_sq_fac]; split_ifs with d2 d4\n  · exact ⟨prime_two, (dvd_div_iff d2).1 d4, fun p pp _ => pp.two_le⟩\n  · cases' nat.eq_zero_or_pos n with n0 n0\n    · subst n0\n      cases d4 (by decide)\n    refine' min_sq_fac_prop_div _ prime_two d2 (mt (dvd_div_iff d2).2 d4) _\n    refine' min_sq_fac_aux_has_prop 3 (Nat.div_pos (le_of_dvd n0 d2) (by decide)) 0 rfl _\n    refine' fun p pp dp => succ_le_of_lt (lt_of_le_of_ne pp.two_le _)\n    rintro rfl\n    contradiction\n  · cases' nat.eq_zero_or_pos n with n0 n0\n    · subst n0\n      cases d2 (by decide)\n    refine' min_sq_fac_aux_has_prop _ n0 0 rfl _\n    refine' fun p pp dp => succ_le_of_lt (lt_of_le_of_ne pp.two_le _)\n    rintro rfl\n    contradiction\n#align min_sq_fac_has_prop min_sq_fac_has_prop\n\n",
 "min_sq_fac_dvd":
 "theorem min_sq_fac_dvd {n d : ℕ} (h : n.min_sq_fac = some d) : d * d ∣ n :=\n  by\n  have := min_sq_fac_has_prop n\n  rw [h] at this\n  exact this.2.1\n#align min_sq_fac_dvd min_sq_fac_dvd\n\n",
 "min_sq_fac_aux_has_prop":
 "theorem min_sq_fac_aux_has_prop :\n    ∀ {n : ℕ} (k), 0 < n → ∀ i, k = 2 * i + 3 → (∀ m, Prime m → m ∣ n → k ≤ m) → min_sq_fac_prop n (min_sq_fac_aux n k)\n  | n, k => fun n0 i e ih => by\n    rw [min_sq_fac_aux]\n    by_cases h : n < k * k <;> simp [h]\n    · refine' squarefree_iff_prime_squarefree.2 fun p pp d => _\n      have := ih p pp (dvd_trans ⟨_, rfl⟩ d)\n      have := nat.mul_le_mul this this\n      exact not_le_of_lt h (le_trans this (le_of_dvd n0 d))\n    have k2 : 2 ≤ k := by\n      subst e\n      exact by decide\n    have k0 : 0 < k := lt_of_lt_of_le (by decide) k2\n    have IH : ∀ n', n' ∣ n → ¬k ∣ n' → min_sq_fac_prop n' (n'.min_sq_fac_aux (k + 2)) :=\n      by\n      intro n' nd' nk\n      have hn' := le_of_dvd n0 nd'\n      refine'\n        have : nat.sqrt n' - k < nat.sqrt n + 2 - k :=\n          lt_of_le_of_lt (nat.sub_le_sub_right (Nat.sqrt_le_sqrt hn') _) (Nat.minFac_lemma n k h)\n        @min_sq_fac_aux_has_prop n' (k + 2) (pos_of_dvd_of_pos nd' n0) (i + 1) (by simp [e, left_distrib]) fun m m2 d =>\n          _\n      cases' nat.eq_or_lt_of_le (ih m m2 (dvd_trans d nd')) with me ml\n      · subst me\n        contradiction\n      apply (nat.eq_or_lt_of_le ml).resolve_left\n      intro me\n      rw [← me, e] at d\n      change 2 * (i + 2) ∣ n' at d\n      have := ih _ prime_two (dvd_trans (dvd_of_mul_right_dvd d) nd')\n      rw [e] at this\n      exact absurd this (by decide)\n    have pk : k ∣ n → Prime k :=\n      by\n      refine' fun dk => prime_def_min_fac.2 ⟨k2, le_antisymm (min_fac_le k0) _⟩\n      exact ih _ (min_fac_prime (ne_of_gt k2)) (dvd_trans (min_fac_dvd _) dk)\n    split_ifs with dk dkk\n    · exact ⟨pk dk, (Nat.dvd_div_iff dk).1 dkk, fun p pp d => ih p pp (dvd_trans ⟨_, rfl⟩ d)⟩\n    · specialize IH (n / k) (div_dvd_of_dvd dk) dkk\n      exact min_sq_fac_prop_div _ (pk dk) dk (mt (Nat.dvd_div_iff dk).2 dkk) IH\n    · exact IH n (dvd_refl _) dk termination_by' ⟨_, measure_wf fun ⟨n, k⟩ => nat.sqrt n + 2 - k⟩\n#align min_sq_fac_aux_has_prop min_sq_fac_aux_has_prop\n\n",
 "factorization_le_one":
 "theorem squarefree.factorization_le_one {n : ℕ} (p : ℕ) (hn : squarefree n) : n.factorization p ≤ 1 :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn')\n  · simp\n  rw [multiplicity.squarefree_iff_multiplicity_le_one] at hn\n  by_cases hp : p.prime\n  · have := hn p\n    simp only [multiplicity_eq_factorization hp hn', Nat.isUnit_iff, hp.ne_one, or_false_iff] at this\n    exact_mod_cast this\n  · rw [factorization_eq_zero_of_non_prime _ hp]\n    exact zero_le_one\n#align squarefree.factorization_le_one squarefree.factorization_le_one\n\n",
 "ext_iff":
 "theorem squarefree.ext_iff {n m : ℕ} (hn : squarefree n) (hm : squarefree m) : n = m ↔ ∀ p, Prime p → (p ∣ n ↔ p ∣ m) :=\n  by\n  refine'\n    ⟨by\n      rintro rfl\n      simp, fun h => eq_of_factorization_eq hn.ne_zero hm.ne_zero fun p => _⟩\n  by_cases hp : p.prime\n  · have h₁ := h _ hp\n    rw [← not_iff_not, hp.dvd_iff_one_le_factorization hn.ne_zero, not_le, lt_one_iff,\n      hp.dvd_iff_one_le_factorization hm.ne_zero, not_le, lt_one_iff] at h₁\n    have h₂ := squarefree.factorization_le_one p hn\n    have h₃ := squarefree.factorization_le_one p hm\n    rw [Nat.le_add_one_iff, le_zero_iff] at h₂ h₃\n    cases h₂\n    · rwa [h₂, eq_comm, ← h₁]\n    · rw [h₂, h₃.resolve_left]\n      rw [← h₁, h₂]\n      simp only [nat.one_ne_zero, not_false_iff]\n  rw [factorization_eq_zero_of_non_prime _ hp, factorization_eq_zero_of_non_prime _ hp]\n#align squarefree.ext_iff squarefree.ext_iff\n\n",
 "divisors_filter_squarefree":
 "theorem divisors_filter_squarefree {n : ℕ} (h0 : n ≠ 0) :\n    (n.divisors.filter squarefree).val =\n      (unique_factorization_monoid.normalized_factors n).to_finset.powerset.val.map fun x => x.val.prod :=\n  by\n  rw [(finset.nodup _).ext ((finset.nodup _).map_on _)]\n  · intro a\n    simp only [Multiset.mem_filter, id.def, Multiset.mem_map, Finset.filter_val, ← Finset.mem_def, mem_divisors]\n    constructor\n    · rintro ⟨⟨an, h0⟩, hsq⟩\n      use (unique_factorization_monoid.normalized_factors a).to_finset\n      simp only [id.def, finset.mem_powerset]\n      rcases an with ⟨b, rfl⟩\n      rw [mul_ne_zero_iff] at h0\n      rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors h0.1] at hsq\n      rw [Multiset.toFinset_subset, Multiset.toFinset_val, hsq.dedup, ← associated_iff_eq,\n        normalized_factors_mul h0.1 h0.2]\n      exact ⟨Multiset.subset_of_le (Multiset.le_add_right _ _), normalized_factors_prod h0.1⟩\n    · rintro ⟨s, hs, rfl⟩\n      rw [finset.mem_powerset, ← Finset.val_le_iff, Multiset.toFinset_val] at hs\n      have hs0 : s.val.prod ≠ 0 := by\n        rw [ne.def, Multiset.prod_eq_zero_iff]\n        simp only [exists_prop, id.def, exists_eq_right]\n        intro con\n        apply\n          not_irreducible_zero (irreducible_of_normalized_factor 0 (Multiset.mem_dedup.1 (Multiset.mem_of_le hs con)))\n      rw [(normalized_factors_prod h0).symm.dvd_iff_dvd_right]\n      refine' ⟨⟨Multiset.prod_dvd_prod_of_le (le_trans hs (Multiset.dedup_le _)), h0⟩, _⟩\n      have h :=\n        unique_factorization_monoid.factors_unique irreducible_of_normalized_factor\n          (fun x hx => irreducible_of_normalized_factor x (Multiset.mem_of_le (le_trans hs (Multiset.dedup_le _)) hx))\n          (normalized_factors_prod hs0)\n      rw [associated_eq_eq, Multiset.rel_eq] at h\n      rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors hs0, h]\n      apply s.nodup\n  · intro x hx y hy h\n    rw [← Finset.val_inj, ← Multiset.rel_eq, ← associated_eq_eq]\n    rw [← Finset.mem_def, finset.mem_powerset] at hx hy\n    apply unique_factorization_monoid.factors_unique _ _ (associated_iff_eq.2 h)\n    · intro z hz\n      apply irreducible_of_normalized_factor z\n      rw [← Multiset.mem_toFinset]\n      apply hx hz\n    · intro z hz\n      apply irreducible_of_normalized_factor z\n      rw [← Multiset.mem_toFinset]\n      apply hy hz\n#align divisors_filter_squarefree divisors_filter_squarefree\n\n"}