{"totient_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n@[simp]\ntheorem totient_zero : (nat.totient) 0 = 0 :=\n  rfl\n#align totient_zero totient_zero\n\n",
 "totient_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n@[simp]\ntheorem totient_two : (nat.totient) 2 = 1 :=\n  (totient_prime prime_two).trans rfl\n#align totient_two totient_two\n\n",
 "totient_super_multiplicative":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_super_multiplicative (a b : ℕ) : (nat.totient) a * (nat.totient) b ≤ (nat.totient) (a * b) :=\n  by\n  let d := a.gcd b\n  rcases(zero_le a).eq_or_lt with (rfl | ha0)\n  · simp\n  have hd0 : 0 < d := nat.gcd_pos_of_pos_left _ ha0\n  rw [← mul_le_mul_right hd0, ← totient_gcd_mul_totient_mul a b, mul_comm]\n  apply mul_le_mul_left' (nat.totient_le d)\n#align totient_super_multiplicative totient_super_multiplicative\n\n",
 "totient_prime_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem totient_prime_pow_succ {p : ℕ} (hp : p.prime) (n : ℕ) : (nat.totient) (p ^ (n + 1)) = p ^ n * (p - 1) :=\n  calc\n    (nat.totient) (p ^ (n + 1)) = ((range (p ^ (n + 1))).filter (coprime (p ^ (n + 1)))).card :=\n      totient_eq_card_coprime _\n    _ = (range (p ^ (n + 1)) \\ (range (p ^ n)).image (· * p)).card :=\n      congr_arg card\n        (by\n          rw [sdiff_eq_filter]\n          apply filter_congr\n          simp only [mem_range, mem_filter, coprime_pow_left_iff n.succ_pos, mem_image, not_exists,\n            hp.coprime_iff_not_dvd]\n          intro a ha\n          constructor\n          · rintro hap b _ rfl\n            exact hap (dvd_mul_left _ _)\n          · rintro h ⟨b, rfl⟩\n            rw [pow_succ] at ha\n            exact h b (lt_of_mul_lt_mul_left ha (zero_le _)) (mul_comm _ _))\n    _ = _ := by\n      have h1 : function.injective (· * p) := mul_left_injective₀ hp.ne_zero\n      have h2 : (range (p ^ n)).image (· * p) ⊆ range (p ^ (n + 1)) := fun a =>\n        by\n        simp only [mem_image, mem_range, exists_imp]\n        rintro b h rfl\n        rw [pow_succ']\n        exact (mul_lt_mul_right hp.pos).2 h\n      rw [card_sdiff h2, card_image_of_inj_on (h1.inj_on _), card_range, card_range, ← one_mul (p ^ n), pow_succ, ←\n        tsub_mul, one_mul, mul_comm]\n    \n#align totient_prime_pow_succ totient_prime_pow_succ\n\n",
 "totient_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem totient_prime_pow {p : ℕ} (hp : p.prime) {n : ℕ} (hn : 0 < n) : (nat.totient) (p ^ n) = p ^ (n - 1) * (p - 1) :=\n  by rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with ⟨m, rfl⟩ <;> exact totient_prime_pow_succ hp _\n#align totient_prime_pow totient_prime_pow\n\n",
 "totient_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_prime {p : ℕ} (hp : p.prime) : (nat.totient) p = p - 1 := by\n  rw [← pow_one p, totient_prime_pow hp] <;> simp\n#align totient_prime totient_prime\n\n",
 "totient_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_pos : ∀ {n : ℕ}, 0 < n → 0 < (nat.totient) n\n  | 0 => by decide\n  | 1 => by simp [totient]\n  | n + 2 => fun h => card_pos.2 ⟨1, mem_filter.2 ⟨mem_range.2 (by decide), coprime_one_right _⟩⟩\n#align totient_pos totient_pos\n\n",
 "totient_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n@[simp]\ntheorem totient_one : (nat.totient) 1 = 1 := by simp [totient]\n#align totient_one totient_one\n\n",
 "totient_mul_prod_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Euler's product formula for the totient function. -/\ntheorem totient_mul_prod_factors (n : ℕ) :\n    (nat.totient) n *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          n.factors.to_finset p =\n      n *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          n.factors.to_finset (p - 1) :=\n  by\n  by_cases hn : n = 0; · simp [hn]\n  rw [totient_eq_prod_factorization hn]\n  nth_rw 3 [← factorization_prod_pow_eq_self hn]\n  simp only [← prod_factorization_eq_prod_factors, ← finsupp.prod_mul]\n  refine' finsupp.prod_congr fun p hp => _\n  rw [finsupp.mem_support_iff, ← zero_lt_iff] at hp\n  rw [mul_comm, ← mul_assoc, ← pow_succ, nat.sub_add_cancel hp]\n#align totient_mul_prod_factors totient_mul_prod_factors\n\n",
 "totient_mul_of_prime_of_not_dvd":
 "theorem totient_mul_of_prime_of_not_dvd {p n : ℕ} (hp : p.prime) (h : ¬p ∣ n) : (p * n).totient = (p - 1) * n.totient :=\n  by\n  rw [totient_mul _, totient_prime hp]\n  simpa [h] using coprime_or_dvd_of_prime hp n\n#align totient_mul_of_prime_of_not_dvd totient_mul_of_prime_of_not_dvd\n\n",
 "totient_mul_of_prime_of_dvd":
 "theorem totient_mul_of_prime_of_dvd {p n : ℕ} (hp : p.prime) (h : p ∣ n) : (p * n).totient = p * n.totient :=\n  by\n  have h1 := totient_gcd_mul_totient_mul p n\n  rw [gcd_eq_left h, mul_assoc] at h1\n  simpa [(totient_pos hp.pos).ne', mul_comm] using h1\n#align totient_mul_of_prime_of_dvd totient_mul_of_prime_of_dvd\n\n",
 "totient_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_mul {m n : ℕ} (h : m.coprime n) : (nat.totient) (m * n) = (nat.totient) m * (nat.totient) n :=\n  if hmn0 : m * n = 0 then by cases' Nat.mul_eq_zero.1 hmn0 with h h <;> simp only [totient_zero, mul_zero, zero_mul, h]\n  else by\n    haveI : ne_zero (m * n) := ⟨hmn0⟩\n    haveI : ne_zero m := ⟨left_ne_zero_of_mul hmn0⟩\n    haveI : ne_zero n := ⟨right_ne_zero_of_mul hmn0⟩\n    simp only [← zmod.card_units_eq_totient]\n    rw [fintype.card_congr (Units.mapEquiv (zmod.chinese_remainder h).to_mul_equiv).to_equiv,\n      fintype.card_congr (@MulEquiv.prodUnits (zmod m) (zmod n) _ _).to_equiv, fintype.card_prod]\n#align totient_mul totient_mul\n\n",
 "totient_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_lt (n : ℕ) (hn : 1 < n) : (nat.totient) n < n :=\n  (card_lt_card (filter_ssubset.2 ⟨0, by simp [hn.ne', pos_of_gt hn]⟩)).trans_eq (card_range n)\n#align totient_lt totient_lt\n\n",
 "totient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_le (n : ℕ) : (nat.totient) n ≤ n :=\n  ((range n).card_filter_le _).trans_eq (card_range n)\n#align totient_le totient_le\n\n",
 "totient_gcd_mul_totient_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_gcd_mul_totient_mul (a b : ℕ) :\n    (nat.totient) (a.gcd b) * (nat.totient) (a * b) = (nat.totient) a * (nat.totient) b * a.gcd b :=\n  by\n  have shuffle :\n    ∀ a1 a2 b1 b2 c1 c2 : ℕ, b1 ∣ a1 → b2 ∣ a2 → a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2) :=\n    by\n    intro a1 a2 b1 b2 c1 c2 h1 h2\n    calc\n      a1 / b1 * c1 * (a2 / b2 * c2) = a1 / b1 * (a2 / b2) * (c1 * c2) := by apply mul_mul_mul_comm\n      _ = a1 * a2 / (b1 * b2) * (c1 * c2) := by\n        congr 1\n        exact div_mul_div_comm h1 h2\n      \n  simp only [totient_eq_div_factors_mul]\n  rw [shuffle, shuffle]\n  rotate_left\n  repeat' apply prod_prime_factors_dvd\n  · simp only [prod_factors_gcd_mul_prod_factors_mul]\n    rw [eq_comm, mul_comm, ← mul_assoc, ← Nat.mul_div_assoc]\n    exact mul_dvd_mul (prod_prime_factors_dvd a) (prod_prime_factors_dvd b)\n#align totient_gcd_mul_totient_mul totient_gcd_mul_totient_mul\n\n",
 "totient_even":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem totient_even {n : ℕ} (hn : 2 < n) : Even n.totient :=\n  by\n  haveI : fact (1 < n) := ⟨one_lt_two.trans hn⟩\n  haveI : ne_zero n := NeZero.of_gt hn\n  suffices 2 = order_of (-1 : «expr ˣ» (zmod n))\n    by\n    rw [← zmod.card_units_eq_totient, even_iff_two_dvd, this]\n    exact order_of_dvd_card_univ\n  rw [← order_of_units, Units.coe_neg_one, order_of_neg_one, ring_char.eq (zmod n) n, if_neg hn.ne']\n#align totient_even totient_even\n\n",
 "totient_eq_prod_factorization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- Euler's product formula for the totient function. -/\ntheorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :\n    (nat.totient) n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) :=\n  by\n  rw [multiplicative_factorization (nat.totient) (@totient_mul) totient_one hn]\n  apply finsupp.prod_congr fun p hp => _\n  have h := zero_lt_iff.mpr (finsupp.mem_support_iff.mp hp)\n  rw [totient_prime_pow (prime_of_mem_factorization hp) h]\n#align totient_eq_prod_factorization totient_eq_prod_factorization\n\n",
 "totient_eq_one_iff":
 "theorem totient_eq_one_iff : ∀ {n : ℕ}, n.totient = 1 ↔ n = 1 ∨ n = 2\n  | 0 => by simp\n  | 1 => by simp\n  | 2 => by simp\n  | n + 3 => by\n    have : 3 ≤ n + 3 := le_add_self\n    simp only [succ_succ_ne_one, false_or_iff]\n    exact ⟨fun h => not_even_one.elim <| h ▸ totient_even this, by rintro ⟨⟩⟩\n#align totient_eq_one_iff totient_eq_one_iff\n\n",
 "totient_eq_mul_prod_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Euler's product formula for the totient function. -/\ntheorem totient_eq_mul_prod_factors (n : ℕ) :\n    ((nat.totient) n : exprℚ) =\n      n *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          n.factors.to_finset (1 - p⁻¹) :=\n  by\n  by_cases hn : n = 0\n  · simp [hn]\n  have hn' : (n : exprℚ) ≠ 0 := by simp [hn]\n  have hpQ :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        n.factors.to_finset (p : exprℚ) ≠\n      0 :=\n    by\n    rw [← cast_prod, cast_ne_zero, ← zero_lt_iff, ← prod_factorization_eq_prod_factors]\n    exact prod_pos fun p hp => pos_of_mem_factorization hp\n  simp only [totient_eq_div_factors_mul n, prod_prime_factors_dvd n, cast_mul, cast_prod, cast_div_char_zero,\n    mul_comm_div, mul_right_inj' hn', div_eq_iff hpQ, ← prod_mul_distrib]\n  refine' prod_congr rfl fun p hp => _\n  have hp := pos_of_mem_factors (list.mem_to_finset.mp hp)\n  have hp' : (p : exprℚ) ≠ 0 := cast_ne_zero.mpr hp.ne.symm\n  rw [sub_mul, one_mul, mul_comm, mul_inv_cancel hp', cast_pred hp]\n#align totient_eq_mul_prod_factors totient_eq_mul_prod_factors\n\n",
 "totient_eq_iff_prime":
 "theorem totient_eq_iff_prime {p : ℕ} (hp : 0 < p) : p.totient = p - 1 ↔ p.prime :=\n  by\n  refine' ⟨fun h => _, totient_prime⟩\n  replace hp : 1 < p\n  · apply lt_of_le_of_ne\n    · rwa [succ_le_iff]\n    · rintro rfl\n      rw [totient_one, tsub_self] at h\n      exact one_ne_zero h\n  rw [totient_eq_card_coprime, range_eq_Ico, ← Ico_insert_succ_left hp.le, Finset.filter_insert,\n    if_neg (not_coprime_of_dvd_of_dvd hp (dvd_refl p) (dvd_zero p)), ← nat.card_Ico 1 p] at h\n  refine' p.prime_of_coprime hp fun n hn hnz => finset.filter_card_eq h n <| finset.mem_Ico.mpr ⟨_, hn⟩\n  rwa [succ_le_iff, pos_iff_ne_zero]\n#align totient_eq_iff_prime totient_eq_iff_prime\n\n",
 "totient_eq_div_factors_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Euler's product formula for the totient function. -/\ntheorem totient_eq_div_factors_mul (n : ℕ) :\n    (nat.totient) n =\n      n /\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n            n.factors.to_finset p *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          n.factors.to_finset (p - 1) :=\n  by\n  rw [← mul_div_left n.totient, totient_mul_prod_factors, mul_comm, Nat.mul_div_assoc _ (prod_prime_factors_dvd n),\n    mul_comm]\n  simpa [prod_factorization_eq_prod_factors] using prod_pos fun p => pos_of_mem_factorization\n#align totient_eq_div_factors_mul totient_eq_div_factors_mul\n\n",
 "totient_eq_card_lt_and_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- A characterisation of `nat.totient` that avoids `finset`. -/\ntheorem totient_eq_card_lt_and_coprime (n : ℕ) : (nat.totient) n = nat.card { m | m < n ∧ n.coprime m } :=\n  by\n  let e : «expr ≃ » { m | m < n ∧ n.coprime m } (Finset.filter n.coprime (Finset.range n)) :=\n    { to_fun := fun m => ⟨m, by simpa only [Finset.mem_filter, Finset.mem_range] using m.property⟩\n      inv_fun := fun m => ⟨m, by simpa only [Finset.mem_filter, Finset.mem_range] using m.property⟩\n      left_inv := fun m => by simp only [subtype.coe_mk, subtype.coe_eta]\n      right_inv := fun m => by simp only [subtype.coe_mk, subtype.coe_eta] }\n  rw [totient_eq_card_coprime, card_congr e, card_eq_fintype_card, fintype.card_coe]\n#align totient_eq_card_lt_and_coprime totient_eq_card_lt_and_coprime\n\n",
 "totient_eq_card_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_eq_card_coprime (n : ℕ) : (nat.totient) n = ((range n).filter n.coprime).card :=\n  rfl\n#align totient_eq_card_coprime totient_eq_card_coprime\n\n",
 "totient_dvd_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem totient_dvd_of_dvd {a b : ℕ} (h : a ∣ b) : (nat.totient) a ∣ (nat.totient) b :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha0)\n  · simp [zero_dvd_iff.1 h]\n  rcases eq_or_ne b 0 with (rfl | hb0)\n  · simp\n  have hab' : a.factorization.support ⊆ b.factorization.support :=\n    by\n    intro p\n    simp only [support_factorization, List.mem_toFinset]\n    apply factors_subset_of_dvd h hb0\n  rw [totient_eq_prod_factorization ha0, totient_eq_prod_factorization hb0]\n  refine' finsupp.prod_dvd_prod_of_subset_of_dvd hab' fun p hp => mul_dvd_mul _ dvd_rfl\n  exact pow_dvd_pow p (tsub_le_tsub_right ((factorization_le_iff_dvd ha0 hb0).2 h p) 1)\n#align totient_dvd_of_dvd totient_dvd_of_dvd\n\n",
 "totient_div_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- For `d ∣ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` -/\ntheorem totient_div_of_dvd {n d : ℕ} (hnd : d ∣ n) :\n    (nat.totient) (n / d) = (filter (fun k : ℕ => n.gcd k = d) (range n)).card :=\n  by\n  rcases d.eq_zero_or_pos with (rfl | hd0); · simp [eq_zero_of_zero_dvd hnd]\n  rcases hnd with ⟨x, rfl⟩\n  rw [nat.mul_div_cancel_left x hd0]\n  apply finset.card_congr fun k _ => d * k\n  · simp only [mem_filter, mem_range, and_imp, coprime]\n    refine' fun a ha1 ha2 => ⟨(mul_lt_mul_left hd0).2 ha1, _⟩\n    rw [gcd_mul_left, ha2, mul_one]\n  · simp [hd0.ne']\n  · simp only [mem_filter, mem_range, exists_prop, and_imp]\n    refine' fun b hb1 hb2 => _\n    have : d ∣ b := by\n      rw [← hb2]\n      apply gcd_dvd_right\n    rcases this with ⟨q, rfl⟩\n    refine' ⟨q, ⟨⟨(mul_lt_mul_left hd0).1 hb1, _⟩, rfl⟩⟩\n    rwa [gcd_mul_left, mul_right_eq_self_iff hd0] at hb2\n#align totient_div_of_dvd totient_div_of_dvd\n\n",
 "sum_totient'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem sum_totient' (n : ℕ) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        ((range n.succ).filter (· ∣ n)) ((nat.totient) m) =\n      n :=\n  by\n  convert sum_totient _ using 1\n  simp only [nat.divisors, sum_filter, range_eq_Ico]\n  rw [sum_eq_sum_Ico_succ_bot] <;> simp\n#align sum_totient' sum_totient'\n\n",
 "sum_totient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\ntheorem sum_totient (n : ℕ) : n.divisors.sum (nat.totient) = n :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  rw [← sum_div_divisors n (nat.totient)]\n  have :\n    n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" n.divisors\n        (filter (fun k : ℕ => n.gcd k = d) (range n)).card :=\n    by\n    nth_rw_lhs 1 [← card_range n]\n    refine' card_eq_sum_card_fiberwise fun x hx => mem_divisors.2 ⟨_, hn.ne'⟩\n    apply gcd_dvd_left\n  nth_rw_rhs 1 [this]\n  exact sum_congr rfl fun x hx => totient_div_of_dvd (dvd_of_mem_divisors hx)\n#align sum_totient sum_totient\n\n",
 "prime_iff_card_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem prime_iff_card_units (p : ℕ) [fintype («expr ˣ» (zmod p))] :\n    p.prime ↔ fintype.card («expr ˣ» (zmod p)) = p - 1 :=\n  by\n  cases' eq_zero_or_neZero p with hp hp\n  · subst hp\n    simp only [zmod, not_prime_zero, false_iff_iff, zero_tsub]\n    -- the substI created an non-defeq but subsingleton instance diamond; resolve it\n    suffices fintype.card («expr ˣ» ℤ) ≠ 0 by convert this\n    simp\n  rw [zmod.card_units_eq_totient, nat.totient_eq_iff_prime <| NeZero.pos p]\n#align prime_iff_card_units prime_iff_card_units\n\n",
 "filter_coprime_Ico_eq_totient":
 "theorem filter_coprime_Ico_eq_totient (a n : ℕ) : ((Ico n (n + a)).filter (coprime a)).card = totient a :=\n  by\n  rw [totient, filter_Ico_card_eq_of_periodic, count_eq_card_filter_range]\n  exact periodic_coprime a\n#align filter_coprime_Ico_eq_totient filter_coprime_Ico_eq_totient\n\n",
 "card_units_zmod_lt_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem card_units_zmod_lt_sub_one {p : ℕ} (hp : 1 < p) [fintype («expr ˣ» (zmod p))] :\n    fintype.card («expr ˣ» (zmod p)) ≤ p - 1 :=\n  by\n  haveI : ne_zero p := ⟨(pos_of_gt hp).ne'⟩\n  rw [zmod.card_units_eq_totient p]\n  exact Nat.le_pred_of_lt (nat.totient_lt p hp)\n#align card_units_zmod_lt_sub_one card_units_zmod_lt_sub_one\n\n",
 "card_units_eq_totient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- Note this takes an explicit `fintype ((zmod n)ˣ)` argument to avoid trouble with instance\ndiamonds. -/\n@[simp]\ntheorem _root_.zmod.card_units_eq_totient (n : ℕ) [ne_zero n] [fintype («expr ˣ» (zmod n))] :\n    fintype.card («expr ˣ» (zmod n)) = (nat.totient) n :=\n  calc\n    fintype.card («expr ˣ» (zmod n)) = fintype.card { x : zmod n // x.val.coprime n } :=\n      fintype.card_congr zmod.units_equiv_coprime\n    _ = (nat.totient) n :=\n      by\n      obtain ⟨m, rfl⟩ : ∃ m, n = m + 1 := exists_eq_succ_of_ne_zero ne_zero.out\n      simp only [totient, finset.card_eq_sum_ones, fintype.card_subtype, finset.sum_filter, ← fin.sum_univ_eq_sum_range,\n        @nat.coprime_comm (m + 1)]\n      rfl\n    \n#align zmod.card_units_eq_totient zmod.card_units_eq_totient\n\n",
 "Ico_filter_coprime_le":
 "theorem Ico_filter_coprime_le {a : ℕ} (k n : ℕ) (a_pos : 0 < a) :\n    ((Ico k (k + n)).filter (coprime a)).card ≤ totient a * (n / a + 1) :=\n  by\n  conv_lhs => rw [← nat.mod_add_div n a]\n  induction' n / a with i ih\n  · rw [← filter_coprime_Ico_eq_totient a k]\n    simp only [add_zero, mul_one, mul_zero, le_of_lt (mod_lt n a_pos)]\n    mono\n    refine' monotone_filter_left a.coprime _\n    simp only [Finset.le_eq_subset]\n    exact Ico_subset_Ico rfl.le (add_le_add_left (le_of_lt (mod_lt n a_pos)) k)\n  simp only [mul_succ]\n  simp_rw [← add_assoc] at ih⊢\n  calc\n    (filter a.coprime (Ico k (k + n % a + a * i + a))).card =\n        (filter a.coprime (Ico k (k + n % a + a * i) ∪ Ico (k + n % a + a * i) (k + n % a + a * i + a))).card :=\n      by\n      congr\n      rw [Ico_union_Ico_eq_Ico]\n      rw [add_assoc]\n      exact le_self_add\n      exact le_self_add\n    _ ≤ (filter a.coprime (Ico k (k + n % a + a * i))).card + a.totient :=\n      by\n      rw [filter_union, ← filter_coprime_Ico_eq_totient a (k + n % a + a * i)]\n      apply card_union_le\n    _ ≤ a.totient * i + a.totient + a.totient := add_le_add_right ih (totient a)\n    \n#align Ico_filter_coprime_le Ico_filter_coprime_le\n\n"}