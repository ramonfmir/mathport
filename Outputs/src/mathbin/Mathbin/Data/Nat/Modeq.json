{"zero_modeq_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print Dvd.dvd.zero_modEq_nat /-\ntheorem Dvd.dvd.zero_modEq_nat (h : n ∣ a) : «expr ≡ [MOD ]» 0 a n :=\n  h.modeq_zero_nat.symm\n#align has_dvd.dvd.zero_modeq_nat Dvd.dvd.zero_modEq_nat\n-/\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print trans /-\n@[trans]\nprotected theorem trans : «expr ≡ [MOD ]» a b n → «expr ≡ [MOD ]» b c n → «expr ≡ [MOD ]» a c n :=\n  Eq.trans\n#align trans trans\n-/\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print symm /-\n@[symm]\nprotected theorem symm : «expr ≡ [MOD ]» a b n → «expr ≡ [MOD ]» b a n :=\n  Eq.symm\n#align symm symm\n-/\n\n",
 "rfl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print rfl /-\nprotected theorem rfl : «expr ≡ [MOD ]» a a n :=\n  ModEq.refl _\n#align rfl rfl\n-/\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print refl /-\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n@[refl]\nprotected theorem refl (a : ℕ) : «expr ≡ [MOD ]» a a n :=\n  @rfl _ _\n#align refl refl\n-/\n\n",
 "pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem pow (m : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (a ^ m) (b ^ m) n :=\n  by\n  induction' m with d hd; · rfl\n  rw [pow_succ, pow_succ]\n  exact h.mul hd\n#align pow pow\n\n",
 "of_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- Cancel right multiplication in the modulus.\n\nFor cancelling right multiplication on both sides of the `≡`, see `nat.modeq.mul_right_cancel'`. -/\ntheorem of_mul_right (m : ℕ) : «expr ≡ [MOD ]» a b (n * m) → «expr ≡ [MOD ]» a b n :=\n  mul_comm m n ▸ of_mul_left _\n#align of_mul_right of_mul_right\n\n",
 "of_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- Cancel left multiplication in the modulus.\n\nFor cancelling left multiplication on both sides of the `≡`, see `nat.modeq.mul_left_cancel'`. -/\ntheorem of_mul_left (m : ℕ) (h : «expr ≡ [MOD ]» a b (m * n)) : «expr ≡ [MOD ]» a b n :=\n  by\n  rw [modeq_iff_dvd] at *\n  exact (dvd_mul_left (n : ℤ) (m : ℤ)).trans h\n#align of_mul_left of_mul_left\n\n",
 "of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem of_dvd (d : m ∣ n) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» a b m :=\n  modEq_of_dvd ((Int.coe_nat_dvd.2 d).trans h.dvd)\n#align of_dvd of_dvd\n\n",
 "of_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem of_div (h : «expr ≡ [MOD ]» (a / c) (b / c) (m / c)) (ha : c ∣ a) (ha : c ∣ b) (ha : c ∣ m) :\n    «expr ≡ [MOD ]» a b m := by convert h.mul_left' c <;> rwa [Nat.mul_div_cancel']\n#align of_div of_div\n\n",
 "odd_of_mod_four_eq_three":
 "theorem odd_of_mod_four_eq_three {n : ℕ} : n % 4 = 3 → n % 2 = 1 := by\n  simpa [modeq, show 2 * 2 = 4 by norm_num, show 3 % 4 = 3 by norm_num] using @modeq.of_mul_left 2 n 3 2\n#align odd_of_mod_four_eq_three odd_of_mod_four_eq_three\n\n",
 "odd_of_mod_four_eq_one":
 "theorem odd_of_mod_four_eq_one {n : ℕ} : n % 4 = 1 → n % 2 = 1 := by\n  simpa [modeq, show 2 * 2 = 4 by norm_num] using @modeq.of_mul_left 2 n 1 2\n#align odd_of_mod_four_eq_one odd_of_mod_four_eq_one\n\n",
 "odd_mul_odd_div_two":
 "theorem odd_mul_odd_div_two {m n : ℕ} (hm1 : m % 2 = 1) (hn1 : n % 2 = 1) : m * n / 2 = m * (n / 2) + m / 2 :=\n  have hm0 : 0 < m := nat.pos_of_ne_zero fun h => by simp_all\n  have hn0 : 0 < n := nat.pos_of_ne_zero fun h => by simp_all\n  mul_right_injective₀ two_ne_zero <| by\n    rw [mul_add, two_mul_odd_div_two hm1, mul_left_comm, two_mul_odd_div_two hn1,\n      two_mul_odd_div_two (Nat.odd_mul_odd hm1 hn1), mul_tsub, mul_one, ← add_tsub_assoc_of_le (succ_le_of_lt hm0),\n      tsub_add_cancel_of_le (le_mul_of_one_le_right (nat.zero_le _) hn0)]\n#align odd_mul_odd_div_two odd_mul_odd_div_two\n\n",
 "odd_mul_odd":
 "theorem odd_mul_odd {n m : ℕ} : n % 2 = 1 → m % 2 = 1 → n * m % 2 = 1 := by simpa [Nat.ModEq] using @modeq.mul 2 n 1 m 1\n#align odd_mul_odd odd_mul_odd\n\n",
 "odd_mod_four_iff":
 "/-- A natural number is odd iff it has residue `1` or `3` mod `4`-/\ntheorem odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n  have help : ∀ m : ℕ, m < 4 → m % 2 = 1 → m = 1 ∨ m = 3 := by decide\n  ⟨fun hn => help (n % 4) (mod_lt n (by norm_num)) <| (mod_mod_of_dvd n (by norm_num : 2 ∣ 4)).trans hn, fun h =>\n    or.dcases_on h odd_of_mod_four_eq_one odd_of_mod_four_eq_three⟩\n#align odd_mod_four_iff odd_mod_four_iff\n\n",
 "mul_right_cancel_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul_right_cancel_iff' {a b c m : ℕ} (hc : c ≠ 0) :\n    «expr ≡ [MOD ]» (a * c) (b * c) (m * c) ↔ «expr ≡ [MOD ]» a b m :=\n  ⟨ModEq.mul_right_cancel' hc, ModEq.mul_right' _⟩\n#align mul_right_cancel_iff' mul_right_cancel_iff'\n\n",
 "mul_right_cancel'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- Cancel right multiplication on both sides of the `≡` and in the modulus.\n\nFor cancelling right multiplication in the modulus, see `nat.modeq.of_mul_right`. -/\nprotected theorem mul_right_cancel' {a b c m : ℕ} (hc : c ≠ 0) :\n    «expr ≡ [MOD ]» (a * c) (b * c) (m * c) → «expr ≡ [MOD ]» a b m := by\n  simp [modeq_iff_dvd, ← sub_mul, mul_dvd_mul_iff_right (by simp [hc] : (c : ℤ) ≠ 0)]\n#align mul_right_cancel' mul_right_cancel'\n\n",
 "mul_right'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul_right' (c : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (a * c) (b * c) (n * c) := by\n  rw [mul_comm a, mul_comm b, mul_comm n] <;> exact h.mul_left' c\n#align mul_right' mul_right'\n\n",
 "mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul_right (c : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (a * c) (b * c) n := by\n  rw [mul_comm a, mul_comm b] <;> exact h.mul_left c\n#align mul_right mul_right\n\n",
 "mul_left_cancel_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul_left_cancel_iff' {a b c m : ℕ} (hc : c ≠ 0) :\n    «expr ≡ [MOD ]» (c * a) (c * b) (c * m) ↔ «expr ≡ [MOD ]» a b m :=\n  ⟨ModEq.mul_left_cancel' hc, ModEq.mul_left' _⟩\n#align mul_left_cancel_iff' mul_left_cancel_iff'\n\n",
 "mul_left_cancel'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- Cancel left multiplication on both sides of the `≡` and in the modulus.\n\nFor cancelling left multiplication in the modulus, see `nat.modeq.of_mul_left`. -/\nprotected theorem mul_left_cancel' {a b c m : ℕ} (hc : c ≠ 0) :\n    «expr ≡ [MOD ]» (c * a) (c * b) (c * m) → «expr ≡ [MOD ]» a b m := by\n  simp [modeq_iff_dvd, ← mul_sub, mul_dvd_mul_iff_left (by simp [hc] : (c : ℤ) ≠ 0)]\n#align mul_left_cancel' mul_left_cancel'\n\n",
 "mul_left'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul_left' (c : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (c * a) (c * b) (c * n) := by\n  unfold modeq at * <;> rw [mul_mod_mul_left, mul_mod_mul_left, h]\n#align mul_left' mul_left'\n\n",
 "mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul_left (c : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (c * a) (c * b) n :=\n  (h.mul_left' _).of_dvd (dvd_mul_left _ _)\n#align mul_left mul_left\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem mul (h₁ : «expr ≡ [MOD ]» a b n) (h₂ : «expr ≡ [MOD ]» c d n) : «expr ≡ [MOD ]» (a * c) (b * d) n :=\n  (h₂.mul_left _).trans (h₁.mul_right _)\n#align mul mul\n\n",
 "modeq_zero_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print Dvd.dvd.modEq_zero_nat /-\ntheorem Dvd.dvd.modEq_zero_nat (h : n ∣ a) : «expr ≡ [MOD ]» a 0 n :=\n  modEq_zero_iff_dvd.2 h\n#align has_dvd.dvd.modeq_zero_nat Dvd.dvd.modEq_zero_nat\n-/\n\n",
 "modeq_zero_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_zero_iff_dvd : «expr ≡ [MOD ]» a 0 n ↔ n ∣ a := by rw [modeq, zero_mod, dvd_iff_mod_eq_zero]\n#align modeq_zero_iff_dvd modeq_zero_iff_dvd\n\n",
 "modeq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n@[simp]\ntheorem modeq_zero_iff : «expr ≡ [MOD ]» a b 0 ↔ a = b := by rw [modeq, mod_zero, mod_zero]\n#align modeq_zero_iff modeq_zero_iff\n\n",
 "modeq_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_sub (h : b ≤ a) : «expr ≡ [MOD ]» a b (a - b) :=\n  (modEq_of_dvd <| by rw [Int.ofNat_sub h]).symm\n#align modeq_sub modeq_sub\n\n",
 "modeq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_one : «expr ≡ [MOD ]» a b 1 :=\n  modEq_of_dvd <| one_dvd _\n#align modeq_one modeq_one\n\n",
 "modeq_iff_dvd'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- A variant of `modeq_iff_dvd` with `nat` divisibility -/\ntheorem modeq_iff_dvd' (h : a ≤ b) : «expr ≡ [MOD ]» a b n ↔ n ∣ b - a := by\n  rw [modeq_iff_dvd, ← Int.coe_nat_dvd, Int.ofNat_sub h]\n#align modeq_iff_dvd' modeq_iff_dvd'\n\n",
 "modeq_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_iff_dvd : «expr ≡ [MOD ]» a b n ↔ (n : ℤ) ∣ b - a := by\n  rw [modeq, eq_comm, ← Int.coe_nat_inj', Int.coe_nat_mod, Int.coe_nat_mod, Int.emod_eq_emod_iff_emod_sub_eq_zero,\n    Int.dvd_iff_emod_eq_zero]\n#align modeq_iff_dvd modeq_iff_dvd\n\n",
 "modeq_and_modeq_iff_modeq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem modeq_and_modeq_iff_modeq_mul {a b m n : ℕ} (hmn : coprime m n) :\n    «expr ≡ [MOD ]» a b m ∧ «expr ≡ [MOD ]» a b n ↔ «expr ≡ [MOD ]» a b (m * n) :=\n  ⟨fun h =>\n    by\n    rw [Nat.modEq_iff_dvd, Nat.modEq_iff_dvd, ← Int.dvd_natAbs, Int.coe_nat_dvd, ← Int.dvd_natAbs, Int.coe_nat_dvd] at h\n    rw [Nat.modEq_iff_dvd, ← Int.dvd_natAbs, Int.coe_nat_dvd]\n    exact hmn.mul_dvd_of_dvd_of_dvd h.1 h.2, fun h => ⟨h.of_mul_right _, h.of_mul_left _⟩⟩\n#align modeq_and_modeq_iff_modeq_mul modeq_and_modeq_iff_modeq_mul\n\n",
 "mod_mul_right_mod":
 "@[simp]\ntheorem mod_mul_right_mod (a b c : ℕ) : a % (b * c) % b = a % b :=\n  (mod_modEq _ _).of_mul_right _\n#align mod_mul_right_mod mod_mul_right_mod\n\n",
 "mod_mul_left_mod":
 "@[simp]\ntheorem mod_mul_left_mod (a b c : ℕ) : a % (b * c) % c = a % c :=\n  (mod_modEq _ _).of_mul_left _\n#align mod_mul_left_mod mod_mul_left_mod\n\n",
 "mod_modeq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem mod_modeq (a n) : «expr ≡ [MOD ]» (a % n) a n :=\n  mod_mod _ _\n#align mod_modeq mod_modeq\n\n",
 "le_of_lt_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem le_of_lt_add (h1 : «expr ≡ [MOD ]» a b m) (h2 : a < b + m) : a ≤ b :=\n  (le_total a b).elim id fun h3 =>\n    nat.le_of_sub_eq_zero (eq_zero_of_dvd_of_lt ((modEq_iff_dvd' h3).mp h1.symm) ((tsub_lt_iff_left h3).mpr h2))\n#align le_of_lt_add le_of_lt_add\n\n",
 "le_mod_add_mod_of_dvd_add_of_not_dvd":
 "theorem le_mod_add_mod_of_dvd_add_of_not_dvd {a b c : ℕ} (h : c ∣ a + b) (ha : ¬c ∣ a) : c ≤ a % c + b % c :=\n  by_contradiction fun hc =>\n    by\n    have : (a + b) % c = a % c + b % c := add_mod_of_add_mod_lt (lt_of_not_ge hc)\n    simp_all [dvd_iff_mod_eq_zero]\n#align le_mod_add_mod_of_dvd_add_of_not_dvd le_mod_add_mod_of_dvd_add_of_not_dvd\n\n",
 "gcd_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem gcd_eq (h : «expr ≡ [MOD ]» a b m) : gcd a m = gcd b m :=\n  by\n  have h1 := gcd_dvd_right a m\n  have h2 := gcd_dvd_right b m\n  exact\n    dvd_antisymm (dvd_gcd ((h.dvd_iff h1).mp (gcd_dvd_left a m)) h1)\n      (dvd_gcd ((h.dvd_iff h2).mpr (gcd_dvd_left b m)) h2)\n#align gcd_eq gcd_eq\n\n",
 "eq_of_lt_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem eq_of_lt_of_lt (h : «expr ≡ [MOD ]» a b m) (ha : a < m) (hb : b < m) : a = b :=\n  h.eq_of_abs_lt <|\n    abs_sub_lt_iff.2\n      ⟨(sub_le_self _ <| Int.coe_nat_nonneg _).trans_lt <| cast_lt.2 hb,\n        (sub_le_self _ <| Int.coe_nat_nonneg _).trans_lt <| cast_lt.2 ha⟩\n#align eq_of_lt_of_lt eq_of_lt_of_lt\n\n",
 "eq_of_abs_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem eq_of_abs_lt (h : «expr ≡ [MOD ]» a b m) (h2 : |(b - a : ℤ)| < m) : a = b :=\n  by\n  apply Int.ofNat.inj\n  rw [eq_comm, ← sub_eq_zero]\n  exact Int.eq_zero_of_abs_lt_dvd (modeq_iff_dvd.mp h) h2\n#align eq_of_abs_lt eq_of_abs_lt\n\n",
 "dvd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem dvd_iff (h : «expr ≡ [MOD ]» a b m) (hdm : d ∣ m) : d ∣ a ↔ d ∣ b :=\n  by\n  simp only [← modeq_zero_iff_dvd]\n  replace h := h.of_dvd hdm\n  exact ⟨h.symm.trans, h.trans⟩\n#align dvd_iff dvd_iff\n\n",
 "div_mod_eq_mod_mul_div":
 "theorem div_mod_eq_mod_mul_div (a b c : ℕ) : a / b % c = a % (b * c) / b :=\n  if hb0 : b = 0 then by simp [hb0]\n  else by\n    rw [← @add_right_cancel_iff _ _ _ (c * (a / b / c)), mod_add_div, nat.div_div_eq_div_mul, ← mul_right_inj' hb0, ←\n      @add_left_cancel_iff _ _ _ (a % b), mod_add_div, mul_add, ← @add_left_cancel_iff _ _ _ (a % (b * c) % b),\n      add_left_comm, ← add_assoc (a % (b * c) % b), mod_add_div, ← mul_assoc, mod_add_div, mod_mul_right_mod]\n#align div_mod_eq_mod_mul_div div_mod_eq_mod_mul_div\n\n",
 "coprime_of_mul_modeq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem coprime_of_mul_modeq_one (b : ℕ) {a n : ℕ} (h : «expr ≡ [MOD ]» (a * b) 1 n) : coprime a n :=\n  by\n  obtain ⟨g, hh⟩ := Nat.gcd_dvd_right a n\n  rw [Nat.coprime_iff_gcd_eq_one, ← Nat.dvd_one, ← Nat.modEq_zero_iff_dvd]\n  calc\n    «expr ≡ [MOD ]» 1 (a * b) (a.gcd n) := Nat.ModEq.of_mul_right g (hh.subst h).symm\n    «expr ≡ [MOD ]» _ (0 * b) (a.gcd n) := ((nat.modeq_zero_iff_dvd.mpr (Nat.gcd_dvd_left _ _)).mul_right b)\n    _ = 0 := by rw [MulZeroClass.zero_mul]\n    \n#align coprime_of_mul_modeq_one coprime_of_mul_modeq_one\n\n",
 "comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print comm /-\nprotected theorem comm : «expr ≡ [MOD ]» a b n ↔ «expr ≡ [MOD ]» b a n :=\n  ⟨ModEq.symm, ModEq.symm⟩\n#align comm comm\n-/\n\n",
 "chinese_remainder_lt_mul":
 "theorem chinese_remainder_lt_mul (co : coprime n m) (a b : ℕ) (hn : n ≠ 0) (hm : m ≠ 0) :\n    ↑(chineseRemainder co a b) < n * m :=\n  lt_of_lt_of_le (chineseRemainder'_lt_lcm _ hn hm) (le_of_eq co.lcm_eq_mul)\n#align chinese_remainder_lt_mul chinese_remainder_lt_mul\n\n",
 "chinese_remainder'_lt_lcm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem chinese_remainder'_lt_lcm (h : «expr ≡ [MOD ]» a b (gcd n m)) (hn : n ≠ 0) (hm : m ≠ 0) :\n    ↑(chineseRemainder' h) < lcm n m := by\n  dsimp only [chinese_remainder']\n  rw [dif_neg hn, dif_neg hm, Subtype.coe_mk, xgcd_val, ← Int.toNat_coe_nat (lcm n m)]\n  have lcm_pos := int.coe_nat_pos.mpr (nat.pos_of_ne_zero (lcm_ne_zero hn hm))\n  exact (Int.toNat_lt_toNat lcm_pos).mpr (Int.emod_lt_of_pos _ lcm_pos)\n#align chinese_remainder'_lt_lcm chinese_remainder'_lt_lcm\n\n",
 "cancel_right_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- A common factor that's coprime with the modulus can be cancelled from a `modeq` -/\ntheorem cancel_right_of_coprime (hmc : gcd m c = 1) (h : «expr ≡ [MOD ]» (a * c) (b * c) m) : «expr ≡ [MOD ]» a b m :=\n  cancel_left_of_coprime hmc <| by simpa [mul_comm] using h\n#align cancel_right_of_coprime cancel_right_of_coprime\n\n",
 "cancel_right_div_gcd'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem cancel_right_div_gcd' (hm : 0 < m) (hcd : «expr ≡ [MOD ]» c d m) (h : «expr ≡ [MOD ]» (a * c) (b * d) m) :\n    «expr ≡ [MOD ]» a b (m / gcd m c) :=\n  hcd.cancel_left_div_gcd' hm <| by simpa [mul_comm] using h\n#align cancel_right_div_gcd' cancel_right_div_gcd'\n\n",
 "cancel_right_div_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem cancel_right_div_gcd (hm : 0 < m) (h : «expr ≡ [MOD ]» (a * c) (b * c) m) : «expr ≡ [MOD ]» a b (m / gcd m c) :=\n  by\n  apply cancel_left_div_gcd hm\n  simpa [mul_comm] using h\n#align cancel_right_div_gcd cancel_right_div_gcd\n\n",
 "cancel_left_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- A common factor that's coprime with the modulus can be cancelled from a `modeq` -/\ntheorem cancel_left_of_coprime (hmc : gcd m c = 1) (h : «expr ≡ [MOD ]» (c * a) (c * b) m) : «expr ≡ [MOD ]» a b m :=\n  by\n  rcases m.eq_zero_or_pos with (rfl | hm)\n  · simp only [gcd_zero_left] at hmc\n    simp only [gcd_zero_left, hmc, one_mul, modeq_zero_iff] at h\n    subst h\n  simpa [hmc] using h.cancel_left_div_gcd hm\n#align cancel_left_of_coprime cancel_left_of_coprime\n\n",
 "cancel_left_div_gcd'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem cancel_left_div_gcd' (hm : 0 < m) (hcd : «expr ≡ [MOD ]» c d m) (h : «expr ≡ [MOD ]» (c * a) (d * b) m) :\n    «expr ≡ [MOD ]» a b (m / gcd m c) :=\n  (h.trans (ModEq.mul_right b hcd).symm).cancel_left_div_gcd hm\n#align cancel_left_div_gcd' cancel_left_div_gcd'\n\n",
 "cancel_left_div_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/-- To cancel a common factor `c` from a `modeq` we must divide the modulus `m` by `gcd m c` -/\ntheorem cancel_left_div_gcd (hm : 0 < m) (h : «expr ≡ [MOD ]» (c * a) (c * b) m) : «expr ≡ [MOD ]» a b (m / gcd m c) :=\n  by\n  let d := gcd m c\n  have hmd := gcd_dvd_left m c\n  have hcd := gcd_dvd_right m c\n  rw [modeq_iff_dvd]\n  refine' Int.dvd_of_dvd_mul_right_of_gcd_one _ _\n  show (m / d : ℤ) ∣ c / d * (b - a)\n  · rw [mul_comm, ← Int.mul_ediv_assoc (b - a) (int.coe_nat_dvd.mpr hcd), mul_comm]\n    apply Int.ediv_dvd_ediv (int.coe_nat_dvd.mpr hmd)\n    rw [mul_sub]\n    exact modeq_iff_dvd.mp h\n  show int.gcd (m / d) (c / d) = 1\n  ·\n    simp only [← Int.coe_nat_div, Int.coe_nat_gcd (m / d) (c / d), gcd_div hmd hcd,\n      nat.div_self (gcd_pos_of_pos_left c hm)]\n#align cancel_left_div_gcd cancel_left_div_gcd\n\n",
 "add_right_cancel'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem add_right_cancel' (c : ℕ) (h : «expr ≡ [MOD ]» (a + c) (b + c) n) : «expr ≡ [MOD ]» a b n :=\n  ModEq.rfl.add_right_cancel h\n#align add_right_cancel' add_right_cancel'\n\n",
 "add_right_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print add_right_cancel /-\nprotected theorem add_right_cancel (h₁ : «expr ≡ [MOD ]» c d n) (h₂ : «expr ≡ [MOD ]» (a + c) (b + d) n) :\n    «expr ≡ [MOD ]» a b n := by\n  rw [add_comm a, add_comm b] at h₂\n  exact h₁.add_left_cancel h₂\n#align add_right_cancel add_right_cancel\n-/\n\n",
 "add_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem add_right (c : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (a + c) (b + c) n :=\n  h.add ModEq.rfl\n#align add_right add_right\n\n",
 "add_modeq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n@[simp]\ntheorem add_modeq_right : «expr ≡ [MOD ]» (a + n) a n := by rw [modeq, add_mod_right]\n#align add_modeq_right add_modeq_right\n\n",
 "add_modeq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n@[simp]\ntheorem add_modeq_left : «expr ≡ [MOD ]» (n + a) a n := by rw [modeq, add_mod_left]\n#align add_modeq_left add_modeq_left\n\n",
 "add_mod_of_add_mod_lt":
 "theorem add_mod_of_add_mod_lt {a b c : ℕ} (hc : a % c + b % c < c) : (a + b) % c = a % c + b % c := by\n  rw [← add_mod_add_ite, if_neg (not_le_of_lt hc), add_zero]\n#align add_mod_of_add_mod_lt add_mod_of_add_mod_lt\n\n",
 "add_mod_add_of_le_add_mod":
 "theorem add_mod_add_of_le_add_mod {a b c : ℕ} (hc : c ≤ a % c + b % c) : (a + b) % c + c = a % c + b % c := by\n  rw [← add_mod_add_ite, if_pos hc]\n#align add_mod_add_of_le_add_mod add_mod_add_of_le_add_mod\n\n",
 "add_mod_add_ite":
 "theorem add_mod_add_ite (a b c : ℕ) : ((a + b) % c + if c ≤ a % c + b % c then c else 0) = a % c + b % c :=\n  have : (a + b) % c = (a % c + b % c) % c := ((mod_modEq _ _).add <| mod_modEq _ _).symm\n  if hc0 : c = 0 then by simp [hc0]\n  else by\n    rw [this]\n    split_ifs\n    · have h2 : (a % c + b % c) / c < 2 :=\n        Nat.div_lt_of_lt_mul\n          (by\n            rw [mul_two] <;>\n              exact add_lt_add (nat.mod_lt _ (nat.pos_of_ne_zero hc0)) (nat.mod_lt _ (nat.pos_of_ne_zero hc0)))\n      have h0 : 0 < (a % c + b % c) / c := Nat.div_pos h (nat.pos_of_ne_zero hc0)\n      rw [← @add_right_cancel_iff _ _ _ (c * ((a % c + b % c) / c)), add_comm _ c, add_assoc, mod_add_div,\n        le_antisymm (le_of_lt_succ h2) h0, mul_one, add_comm]\n    · rw [nat.mod_eq_of_lt (lt_of_not_ge h), add_zero]\n#align add_mod_add_ite add_mod_add_ite\n\n",
 "add_left_cancel'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem add_left_cancel' (c : ℕ) (h : «expr ≡ [MOD ]» (c + a) (c + b) n) : «expr ≡ [MOD ]» a b n :=\n  ModEq.rfl.add_left_cancel h\n#align add_left_cancel' add_left_cancel'\n\n",
 "add_left_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n#print add_left_cancel /-\nprotected theorem add_left_cancel (h₁ : «expr ≡ [MOD ]» a b n) (h₂ : «expr ≡ [MOD ]» (a + c) (b + d) n) :\n    «expr ≡ [MOD ]» c d n := by\n  simp only [modeq_iff_dvd, Int.ofNat_add] at *\n  rw [add_sub_add_comm] at h₂\n  convert _root_.dvd_sub h₂ h₁ using 1\n  rw [add_sub_cancel']\n#align add_left_cancel add_left_cancel\n-/\n\n",
 "add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem add_left (c : ℕ) (h : «expr ≡ [MOD ]» a b n) : «expr ≡ [MOD ]» (c + a) (c + b) n :=\n  ModEq.rfl.add h\n#align add_left add_left\n\n",
 "add_le_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\ntheorem add_le_of_lt (h1 : «expr ≡ [MOD ]» a b m) (h2 : a < b) : a + m ≤ b :=\n  le_of_lt_add (add_modEq_right.trans h1) (add_lt_add_right h2 m)\n#align add_le_of_lt add_le_of_lt\n\n",
 "add_div_of_dvd_right":
 "protected theorem add_div_of_dvd_right {a b c : ℕ} (hca : c ∣ a) : (a + b) / c = a / c + b / c :=\n  if h : c = 0 then by simp [h]\n  else\n    add_div_eq_of_add_mod_lt\n      (by\n        rw [nat.mod_eq_zero_of_dvd hca, zero_add]\n        exact nat.mod_lt _ (pos_iff_ne_zero.mpr h))\n#align add_div_of_dvd_right add_div_of_dvd_right\n\n",
 "add_div_of_dvd_left":
 "protected theorem add_div_of_dvd_left {a b c : ℕ} (hca : c ∣ b) : (a + b) / c = a / c + b / c := by\n  rwa [add_comm, Nat.add_div_of_dvd_right, add_comm]\n#align add_div_of_dvd_left add_div_of_dvd_left\n\n",
 "add_div_le_add_div":
 "theorem add_div_le_add_div (a b c : ℕ) : a / c + b / c ≤ (a + b) / c :=\n  if hc0 : c = 0 then by simp [hc0] else by rw [Nat.add_div (nat.pos_of_ne_zero hc0)] <;> exact nat.le_add_right _ _\n#align add_div_le_add_div add_div_le_add_div\n\n",
 "add_div_eq_of_le_mod_add_mod":
 "theorem add_div_eq_of_le_mod_add_mod {a b c : ℕ} (hc : c ≤ a % c + b % c) (hc0 : 0 < c) :\n    (a + b) / c = a / c + b / c + 1 := by rw [add_div hc0, if_pos hc]\n#align add_div_eq_of_le_mod_add_mod add_div_eq_of_le_mod_add_mod\n\n",
 "add_div_eq_of_add_mod_lt":
 "theorem add_div_eq_of_add_mod_lt {a b c : ℕ} (hc : a % c + b % c < c) : (a + b) / c = a / c + b / c :=\n  if hc0 : c = 0 then by simp [hc0] else by rw [add_div (nat.pos_of_ne_zero hc0), if_neg (not_le_of_lt hc), add_zero]\n#align add_div_eq_of_add_mod_lt add_div_eq_of_add_mod_lt\n\n",
 "add_div":
 "#print add_div /-\ntheorem add_div {a b c : ℕ} (hc0 : 0 < c) : (a + b) / c = a / c + b / c + if c ≤ a % c + b % c then 1 else 0 :=\n  by\n  rw [← mul_right_inj' hc0.ne', ← @add_left_cancel_iff _ _ _ ((a + b) % c + a % c + b % c)]\n  suffices\n    (a + b) % c + c * ((a + b) / c) + a % c + b % c =\n      (a % c + c * (a / c) + (b % c + c * (b / c)) + c * if c ≤ a % c + b % c then 1 else 0) + (a + b) % c\n    by simpa only [mul_add, add_comm, add_left_comm, add_assoc]\n  rw [mod_add_div, mod_add_div, mod_add_div, mul_ite, add_assoc, add_assoc]\n  conv_lhs => rw [← add_mod_add_ite]\n  simp\n  ac_rfl\n#align add_div add_div\n-/\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\nprotected theorem add (h₁ : «expr ≡ [MOD ]» a b n) (h₂ : «expr ≡ [MOD ]» c d n) : «expr ≡ [MOD ]» (a + c) (b + d) n :=\n  by\n  rw [modeq_iff_dvd, Int.ofNat_add, Int.ofNat_add, add_sub_add_comm]\n  exact dvd_add h₁.dvd h₂.dvd\n#align add add\n\n"}