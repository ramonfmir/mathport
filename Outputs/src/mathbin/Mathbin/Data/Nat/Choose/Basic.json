{"triangle_succ":
 "-- The `n+1`-st triangle number is `n` more than the `n`-th triangle number\ntheorem triangle_succ (n : ℕ) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n :=\n  by\n  rw [← add_mul_div_left, mul_comm 2 n, ← mul_add, add_tsub_cancel_right, mul_comm]\n  cases n <;> rfl; apply zero_lt_succ\n#align triangle_succ triangle_succ\n\n",
 "succ_mul_choose_eq":
 "theorem succ_mul_choose_eq : ∀ n k, succ n * choose n k = choose (succ n) (succ k) * succ k\n  | 0, 0 => by decide\n  | 0, k + 1 => by simp [choose]\n  | n + 1, 0 => by simp\n  | n + 1, k + 1 => by\n    rw [choose_succ_succ (succ n) (succ k), add_mul, ← succ_mul_choose_eq, mul_succ, ← succ_mul_choose_eq,\n      add_right_comm, ← mul_add, ← choose_succ_succ, ← succ_mul]\n#align succ_mul_choose_eq succ_mul_choose_eq\n\n",
 "multichoose_zero_succ":
 "@[simp]\ntheorem multichoose_zero_succ (k : ℕ) : multichoose 0 (k + 1) = 0 := by simp [multichoose]\n#align multichoose_zero_succ multichoose_zero_succ\n\n",
 "multichoose_zero_right":
 "@[simp]\ntheorem multichoose_zero_right (n : ℕ) : multichoose n 0 = 1 := by cases n <;> simp [multichoose]\n#align multichoose_zero_right multichoose_zero_right\n\n",
 "multichoose_two":
 "@[simp]\ntheorem multichoose_two (k : ℕ) : multichoose 2 k = k + 1 :=\n  by\n  induction' k with k IH; · simp\n  simp [multichoose_succ_succ 1 k, IH]\n  rw [add_comm]\n#align multichoose_two multichoose_two\n\n",
 "multichoose_succ_succ":
 "theorem multichoose_succ_succ (n k : ℕ) : multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k :=\n  by simp [multichoose]\n#align multichoose_succ_succ multichoose_succ_succ\n\n",
 "multichoose_one_right":
 "@[simp]\ntheorem multichoose_one_right (n : ℕ) : multichoose n 1 = n :=\n  by\n  induction' n with n IH; · simp\n  simp [multichoose_succ_succ n 0, IH]\n#align multichoose_one_right multichoose_one_right\n\n",
 "multichoose_one":
 "@[simp]\ntheorem multichoose_one (k : ℕ) : multichoose 1 k = 1 :=\n  by\n  induction' k with k IH; · simp\n  simp [multichoose_succ_succ 0 k, IH]\n#align multichoose_one multichoose_one\n\n",
 "multichoose_eq":
 "theorem multichoose_eq : ∀ n k : ℕ, multichoose n k = (n + k - 1).choose k\n  | _, 0 => by simp\n  | 0, k + 1 => by simp\n  | n + 1, k + 1 =>\n    by\n    rw [multichoose_succ_succ, add_comm, Nat.succ_add_sub_one, ← add_assoc, Nat.choose_succ_succ]\n    simp [multichoose_eq]\n#align multichoose_eq multichoose_eq\n\n",
 "factorial_mul_factorial_dvd_factorial_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_mul_factorial_dvd_factorial_add (i j : ℕ) :\n    nat.factorial i * nat.factorial j ∣ nat.factorial (i + j) :=\n  by\n  convert factorial_mul_factorial_dvd_factorial (le.intro rfl)\n  rw [add_tsub_cancel_left]\n#align factorial_mul_factorial_dvd_factorial_add factorial_mul_factorial_dvd_factorial_add\n\n",
 "factorial_mul_factorial_dvd_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_mul_factorial_dvd_factorial {n k : ℕ} (hk : k ≤ n) :\n    nat.factorial k * nat.factorial (n - k) ∣ nat.factorial n := by\n  rw [← choose_mul_factorial_mul_factorial hk, mul_assoc] <;> exact dvd_mul_left _ _\n#align factorial_mul_factorial_dvd_factorial factorial_mul_factorial_dvd_factorial\n\n",
 "factorial_dvd_desc_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_dvd_desc_factorial (n k : ℕ) : nat.factorial k ∣ n.desc_factorial k :=\n  ⟨n.choose k, descFactorial_eq_factorial_mul_choose _ _⟩\n#align factorial_dvd_desc_factorial factorial_dvd_desc_factorial\n\n",
 "factorial_dvd_asc_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_dvd_asc_factorial (n k : ℕ) : nat.factorial k ∣ n.asc_factorial k :=\n  ⟨(n + k).choose k, ascFactorial_eq_factorial_mul_choose _ _⟩\n#align factorial_dvd_asc_factorial factorial_dvd_asc_factorial\n\n",
 "desc_factorial_eq_factorial_mul_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem desc_factorial_eq_factorial_mul_choose (n k : ℕ) : n.desc_factorial k = nat.factorial k * n.choose k :=\n  by\n  obtain h | h := nat.lt_or_ge n k\n  · rw [desc_factorial_eq_zero_iff_lt.2 h, choose_eq_zero_of_lt h, MulZeroClass.mul_zero]\n  rw [mul_comm]\n  apply mul_right_cancel₀ (factorial_ne_zero (n - k))\n  rw [choose_mul_factorial_mul_factorial h, ← factorial_mul_desc_factorial h, mul_comm]\n#align desc_factorial_eq_factorial_mul_choose desc_factorial_eq_factorial_mul_choose\n\n",
 "choose_zero_succ":
 "@[simp]\ntheorem choose_zero_succ (k : ℕ) : choose 0 (succ k) = 0 :=\n  rfl\n#align choose_zero_succ choose_zero_succ\n\n",
 "choose_zero_right":
 "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Bhavik Mehta, Stuart Presnell\n-/\n@[simp]\ntheorem choose_zero_right (n : ℕ) : choose n 0 = 1 := by cases n <;> rfl\n#align choose_zero_right choose_zero_right\n\n",
 "choose_two_right":
 "/-- `choose n 2` is the `n`-th triangle number. -/\ntheorem choose_two_right (n : ℕ) : choose n 2 = n * (n - 1) / 2 :=\n  by\n  induction' n with n ih\n  simp\n  · rw [triangle_succ n]\n    simp [choose, ih]\n    rw [add_comm]\n#align choose_two_right choose_two_right\n\n",
 "choose_symm_of_eq_add":
 "theorem choose_symm_of_eq_add {n a b : ℕ} (h : n = a + b) : Nat.choose n a = Nat.choose n b :=\n  by\n  convert Nat.choose_symm (nat.le_add_left _ _)\n  rw [add_tsub_cancel_right]\n#align choose_symm_of_eq_add choose_symm_of_eq_add\n\n",
 "choose_symm_half":
 "theorem choose_symm_half (m : ℕ) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m :=\n  by\n  apply choose_symm_of_eq_add\n  rw [add_comm m 1, add_assoc 1 m m, add_comm (2 * m) 1, two_mul m]\n#align choose_symm_half choose_symm_half\n\n",
 "choose_symm_add":
 "theorem choose_symm_add {a b : ℕ} : choose (a + b) a = choose (a + b) b :=\n  choose_symm_of_eq_add rfl\n#align choose_symm_add choose_symm_add\n\n",
 "choose_symm":
 "@[simp]\ntheorem choose_symm {n k : ℕ} (hk : k ≤ n) : choose n (n - k) = choose n k := by\n  rw [choose_eq_factorial_div_factorial hk, choose_eq_factorial_div_factorial (nat.sub_le _ _),\n    tsub_tsub_cancel_of_le hk, mul_comm]\n#align choose_symm choose_symm\n\n",
 "choose_succ_succ":
 "theorem choose_succ_succ (n k : ℕ) : choose (succ n) (succ k) = choose n k + choose n (succ k) :=\n  rfl\n#align choose_succ_succ choose_succ_succ\n\n",
 "choose_succ_self_right":
 "@[simp]\ntheorem choose_succ_self_right : ∀ n : ℕ, (n + 1).choose n = n + 1\n  | 0 => rfl\n  | n + 1 => by rw [choose_succ_succ, choose_succ_self_right, choose_self]\n#align choose_succ_self_right choose_succ_self_right\n\n",
 "choose_succ_self":
 "@[simp]\ntheorem choose_succ_self (n : ℕ) : choose n (succ n) = 0 :=\n  choose_eq_zero_of_lt (lt_succ_self _)\n#align choose_succ_self choose_succ_self\n\n",
 "choose_succ_right_eq":
 "theorem choose_succ_right_eq (n k : ℕ) : choose n (k + 1) * (k + 1) = choose n k * (n - k) :=\n  by\n  have e : (n + 1) * choose n k = choose n k * (k + 1) + choose n (k + 1) * (k + 1)\n  rw [← right_distrib, ← choose_succ_succ, succ_mul_choose_eq]\n  rw [← tsub_eq_of_eq_add_rev e, mul_comm, ← mul_tsub, add_tsub_add_eq_tsub_right]\n#align choose_succ_right_eq choose_succ_right_eq\n\n",
 "choose_self":
 "@[simp]\ntheorem choose_self (n : ℕ) : choose n n = 1 := by\n  induction n <;> simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]\n#align choose_self choose_self\n\n",
 "choose_pos":
 "theorem choose_pos : ∀ {n k}, k ≤ n → 0 < choose n k\n  | 0, _, hk => by rw [nat.eq_zero_of_le_zero hk] <;> exact by decide\n  | n + 1, 0, hk => by simp <;> exact by decide\n  | n + 1, k + 1, hk => by\n    rw [choose_succ_succ] <;> exact add_pos_of_pos_of_nonneg (choose_pos (le_of_succ_le_succ hk)) (nat.zero_le _)\n#align choose_pos choose_pos\n\n",
 "choose_one_right":
 "@[simp]\ntheorem choose_one_right (n : ℕ) : choose n 1 = n := by induction n <;> simp [*, choose, add_comm]\n#align choose_one_right choose_one_right\n\n",
 "choose_mul_succ_eq":
 "theorem choose_mul_succ_eq (n k : ℕ) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k) :=\n  by\n  induction' k with k ih; · simp\n  obtain hk | hk := le_or_lt (k + 1) (n + 1)\n  ·\n    rw [choose_succ_succ, add_mul, succ_sub_succ, ← choose_succ_right_eq, ← succ_sub_succ, mul_tsub,\n      add_tsub_cancel_of_le (nat.mul_le_mul_left _ hk)]\n  rw [choose_eq_zero_of_lt hk, choose_eq_zero_of_lt (n.lt_succ_self.trans hk), MulZeroClass.zero_mul,\n    MulZeroClass.zero_mul]\n#align choose_mul_succ_eq choose_mul_succ_eq\n\n",
 "choose_mul_factorial_mul_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem choose_mul_factorial_mul_factorial :\n    ∀ {n k}, k ≤ n → choose n k * nat.factorial k * nat.factorial (n - k) = nat.factorial n\n  | 0, _, hk => by simp [nat.eq_zero_of_le_zero hk]\n  | n + 1, 0, hk => by simp\n  | n + 1, succ k, hk => by\n    cases' lt_or_eq_of_le hk with hk₁ hk₁\n    · have h : choose n k * nat.factorial k.succ * nat.factorial (n - k) = (k + 1) * nat.factorial n := by\n        rw [← choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)] <;>\n          simp [factorial_succ, mul_comm, mul_left_comm]\n      have h₁ : nat.factorial (n - k) = (n - k) * nat.factorial (n - k.succ) := by\n        rw [← succ_sub_succ, succ_sub (le_of_lt_succ hk₁), factorial_succ]\n      have h₂ :\n        choose n (succ k) * nat.factorial k.succ * ((n - k) * nat.factorial (n - k.succ)) = (n - k) * nat.factorial n :=\n        by\n        rw [← choose_mul_factorial_mul_factorial (le_of_lt_succ hk₁)] <;>\n          simp [factorial_succ, mul_comm, mul_left_comm, mul_assoc]\n      have h₃ : k * nat.factorial n ≤ n * nat.factorial n := nat.mul_le_mul_right _ (le_of_succ_le_succ hk)\n      rw [choose_succ_succ, add_mul, add_mul, succ_sub_succ, h, h₁, h₂, add_mul, tsub_mul, factorial_succ, ←\n        add_tsub_assoc_of_le h₃, add_assoc, ← add_mul, add_tsub_cancel_left, add_comm]\n    · simp [hk₁, mul_comm, choose, tsub_self]\n#align choose_mul_factorial_mul_factorial choose_mul_factorial_mul_factorial\n\n",
 "choose_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem choose_mul {n k s : ℕ} (hkn : k ≤ n) (hsk : s ≤ k) :\n    n.choose k * k.choose s = n.choose s * (n - s).choose (k - s) :=\n  by\n  have h : nat.factorial (n - k) * nat.factorial (k - s) * nat.factorial s ≠ 0 := by\n    apply_rules [mul_ne_zero, factorial_ne_zero]\n  refine' mul_right_cancel₀ h _\n  calc\n    n.choose k * k.choose s * (nat.factorial (n - k) * nat.factorial (k - s) * nat.factorial s) =\n        n.choose k * (k.choose s * nat.factorial s * nat.factorial (k - s)) * nat.factorial (n - k) :=\n      by\n      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc _ (nat.factorial s), mul_assoc, mul_comm (nat.factorial (n - k)),\n        mul_comm (nat.factorial s)]\n    _ = nat.factorial n := by rw [choose_mul_factorial_mul_factorial hsk, choose_mul_factorial_mul_factorial hkn]\n    _ =\n        n.choose s * nat.factorial s *\n          ((n - s).choose (k - s) * nat.factorial (k - s) * nat.factorial (n - s - (k - s))) :=\n      by\n      rw [choose_mul_factorial_mul_factorial (tsub_le_tsub_right hkn _),\n        choose_mul_factorial_mul_factorial (hsk.trans hkn)]\n    _ = n.choose s * (n - s).choose (k - s) * (nat.factorial (n - k) * nat.factorial (k - s) * nat.factorial s) := by\n      rw [tsub_tsub_tsub_cancel_right hsk, mul_assoc, mul_left_comm (nat.factorial s), mul_assoc,\n        mul_comm (nat.factorial (k - s)), mul_comm (nat.factorial s), mul_right_comm, ← mul_assoc]\n    \n#align choose_mul choose_mul\n\n",
 "choose_mono":
 "theorem choose_mono (b : ℕ) : Monotone fun a => choose a b := fun _ _ => choose_le_choose b\n#align choose_mono choose_mono\n\n",
 "choose_le_succ_of_lt_half_left":
 "/-- Show that `nat.choose` is increasing for small values of the right argument. -/\ntheorem choose_le_succ_of_lt_half_left {r n : ℕ} (h : r < n / 2) : choose n r ≤ choose n (r + 1) :=\n  by\n  refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2)))\n  rw [← choose_succ_right_eq]\n  apply nat.mul_le_mul_left\n  rw [← Nat.lt_iff_add_one_le, lt_tsub_iff_left, ← mul_two]\n  exact lt_of_lt_of_le (mul_lt_mul_of_pos_right h zero_lt_two) (n.div_mul_le_self 2)\n#align choose_le_succ_of_lt_half_left choose_le_succ_of_lt_half_left\n\n",
 "choose_le_succ":
 "theorem choose_le_succ (a c : ℕ) : choose a c ≤ choose a.succ c := by cases c <;> simp [Nat.choose_succ_succ]\n#align choose_le_succ choose_le_succ\n\n",
 "choose_le_middle_of_le_half_left":
 "/-- Show that for small values of the right argument, the middle value is largest. -/\nprivate theorem choose_le_middle_of_le_half_left {n r : ℕ} (hr : r ≤ n / 2) : choose n r ≤ choose n (n / 2) :=\n  decreasingInduction\n    (fun _ k a =>\n      (eq_or_lt_of_le a).elim (fun t => t.symm ▸ le_rfl) fun h => (choose_le_succ_of_lt_half_left h).trans (k h))\n    hr (fun _ => le_rfl) hr\n#align choose_le_middle_of_le_half_left choose_le_middle_of_le_half_left\n\n",
 "choose_le_middle":
 "/-- `choose n r` is maximised when `r` is `n/2`. -/\ntheorem choose_le_middle (r n : ℕ) : choose n r ≤ choose n (n / 2) :=\n  by\n  cases' le_or_gt r n with b b\n  · cases' le_or_lt r (n / 2) with a h\n    · apply choose_le_middle_of_le_half_left a\n    · rw [← choose_symm b]\n      apply choose_le_middle_of_le_half_left\n      rw [div_lt_iff_lt_mul' zero_lt_two] at h\n      rw [le_div_iff_mul_le' zero_lt_two, tsub_mul, tsub_le_iff_tsub_le, mul_two, add_tsub_cancel_right]\n      exact le_of_lt h\n  · rw [choose_eq_zero_of_lt b]\n    apply zero_le\n#align choose_le_middle choose_le_middle\n\n",
 "choose_le_choose":
 "theorem choose_le_choose {a b : ℕ} (c : ℕ) (h : a ≤ b) : choose a c ≤ choose b c :=\n  add_tsub_cancel_of_le h ▸ choose_le_add a (b - a) c\n#align choose_le_choose choose_le_choose\n\n",
 "choose_le_add":
 "theorem choose_le_add (a b c : ℕ) : choose a c ≤ choose (a + b) c :=\n  by\n  induction' b with b_n b_ih\n  · simp\n  exact le_trans b_ih (choose_le_succ (a + b_n) c)\n#align choose_le_add choose_le_add\n\n",
 "choose_eq_zero_of_lt":
 "theorem choose_eq_zero_of_lt : ∀ {n k}, n < k → choose n k = 0\n  | _, 0, hk => absurd hk (by decide)\n  | 0, k + 1, hk => choose_zero_succ _\n  | n + 1, k + 1, hk => by\n    have hnk : n < k := lt_of_succ_lt_succ hk\n    have hnk1 : n < k + 1 := lt_of_succ_lt hk\n    rw [choose_succ_succ, choose_eq_zero_of_lt hnk, choose_eq_zero_of_lt hnk1]\n#align choose_eq_zero_of_lt choose_eq_zero_of_lt\n\n",
 "choose_eq_zero_iff":
 "theorem choose_eq_zero_iff {n k : ℕ} : n.choose k = 0 ↔ n < k :=\n  ⟨fun h => lt_of_not_ge (mt Nat.choose_pos h.symm.not_lt), Nat.choose_eq_zero_of_lt⟩\n#align choose_eq_zero_iff choose_eq_zero_iff\n\n",
 "choose_eq_factorial_div_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem choose_eq_factorial_div_factorial {n k : ℕ} (hk : k ≤ n) :\n    choose n k = nat.factorial n / (nat.factorial k * nat.factorial (n - k)) :=\n  by\n  rw [← choose_mul_factorial_mul_factorial hk, mul_assoc]\n  exact (mul_div_left _ (mul_pos (factorial_pos _) (factorial_pos _))).symm\n#align choose_eq_factorial_div_factorial choose_eq_factorial_div_factorial\n\n",
 "choose_eq_desc_factorial_div_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem choose_eq_desc_factorial_div_factorial (n k : ℕ) : n.choose k = n.desc_factorial k / nat.factorial k :=\n  by\n  apply mul_left_cancel₀ (factorial_ne_zero k)\n  rw [← desc_factorial_eq_factorial_mul_choose]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_desc_factorial _ _).symm\n#align choose_eq_desc_factorial_div_factorial choose_eq_desc_factorial_div_factorial\n\n",
 "choose_eq_asc_factorial_div_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem choose_eq_asc_factorial_div_factorial (n k : ℕ) : (n + k).choose k = n.asc_factorial k / nat.factorial k :=\n  by\n  apply mul_left_cancel₀ (factorial_ne_zero k)\n  rw [← asc_factorial_eq_factorial_mul_choose]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_asc_factorial _ _).symm\n#align choose_eq_asc_factorial_div_factorial choose_eq_asc_factorial_div_factorial\n\n",
 "asc_factorial_eq_factorial_mul_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem asc_factorial_eq_factorial_mul_choose (n k : ℕ) : n.asc_factorial k = nat.factorial k * (n + k).choose k :=\n  by\n  rw [mul_comm]\n  apply mul_right_cancel₀ (factorial_ne_zero (n + k - k))\n  rw [choose_mul_factorial_mul_factorial, add_tsub_cancel_right, ← factorial_mul_asc_factorial, mul_comm]\n  exact nat.le_add_left k n\n#align asc_factorial_eq_factorial_mul_choose asc_factorial_eq_factorial_mul_choose\n\n",
 "add_choose_mul_factorial_mul_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem add_choose_mul_factorial_mul_factorial (i j : ℕ) :\n    (i + j).choose j * nat.factorial i * nat.factorial j = nat.factorial (i + j) := by\n  rw [← choose_mul_factorial_mul_factorial (nat.le_add_left _ _), add_tsub_cancel_right, mul_right_comm]\n#align add_choose_mul_factorial_mul_factorial add_choose_mul_factorial_mul_factorial\n\n",
 "add_choose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem add_choose (i j : ℕ) : (i + j).choose j = nat.factorial (i + j) / (nat.factorial i * nat.factorial j) := by\n  rw [choose_eq_factorial_div_factorial (nat.le_add_left j i), add_tsub_cancel_right, mul_comm]\n#align add_choose add_choose\n\n"}