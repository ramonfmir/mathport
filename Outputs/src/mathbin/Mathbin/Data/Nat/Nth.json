{"nth_zero_of_zero":
 "@[simp]\ntheorem nth_zero_of_zero (h : p 0) : nth p 0 = 0 := by simp [nth_zero, h]\n#align nth_zero_of_zero nth_zero_of_zero\n\n",
 "nth_zero_of_nth_zero":
 "theorem nth_zero_of_nth_zero (h₀ : ¬p 0) {a b : ℕ} (hab : a ≤ b) (ha : nth p a = 0) : nth p b = 0 :=\n  by\n  rw [nth, Inf_eq_zero] at ha⊢\n  cases ha\n  · exact (h₀ ha.1).elim\n  · refine' or.inr (Set.eq_empty_of_subset_empty fun x hx => _)\n    rw [← ha]\n    exact ⟨hx.1, fun k hk => hx.2 k <| hk.trans_le hab⟩\n#align nth_zero_of_nth_zero nth_zero_of_nth_zero\n\n",
 "nth_zero_of_exists":
 "theorem nth_zero_of_exists [decidable_pred p] (h : ∃ n, p n) : nth p 0 = nat.find h :=\n  by\n  rw [nth_zero]\n  convert nat.Inf_def h\n#align nth_zero_of_exists nth_zero_of_exists\n\n",
 "nth_zero":
 "/-\nCopyright (c) 2021 Vladimir Goryachev. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Vladimir Goryachev, Kyle Miller, Scott Morrison, Eric Rodriguez\n-/\ntheorem nth_zero : nth p 0 = infₛ { i : ℕ | p i } := by\n  rw [nth]\n  simp\n#align nth_zero nth_zero\n\n",
 "nth_strict_mono_of_finite":
 "theorem nth_strict_mono_of_finite {m n : ℕ} (hp : (set_of p).finite) (hlt : n < hp.to_finset.card) (hmn : m < n) :\n    nth p m < nth p n :=\n  (nth_mem_of_lt_card_finite_aux p _ hp hlt).2 _ hmn\n#align nth_strict_mono_of_finite nth_strict_mono_of_finite\n\n",
 "nth_strict_mono":
 "theorem nth_strict_mono (hp : (set_of p).infinite) : strict_mono (nth p) := fun a b =>\n  (nth_mem_of_infinite_aux p hp b).2 _\n#align nth_strict_mono nth_strict_mono\n\n",
 "nth_set_nonempty_of_lt_card":
 "theorem nth_set_nonempty_of_lt_card {n : ℕ} (hp : (set_of p).finite) (hlt : n < hp.to_finset.card) :\n    { i : ℕ | p i ∧ ∀ k < n, nth p k < i }.nonempty :=\n  by\n  have hp' : { i : ℕ | p i ∧ ∀ k : ℕ, k < n → nth p k < i }.finite := hp.subset fun x hx => hx.1\n  rw [← hp'.to_finset_nonempty, ← finset.card_pos, nth_set_card p hp]\n  exact nat.sub_pos_of_lt hlt\n#align nth_set_nonempty_of_lt_card nth_set_nonempty_of_lt_card\n\n",
 "nth_set_card_aux":
 "theorem nth_set_card_aux {n : ℕ} (hp : (set_of p).finite) (hp' : { i : ℕ | p i ∧ ∀ t < n, nth p t < i }.finite)\n    (hle : n ≤ hp.to_finset.card) : hp'.to_finset.card = hp.to_finset.card - n :=\n  by\n  induction' n with k hk\n  · congr\n    simp only [is_empty.forall_iff, nat.not_lt_zero, forall_const, and_true_iff]\n  have hp'' : { i : ℕ | p i ∧ ∀ t, t < k → nth p t < i }.finite :=\n    by\n    refine' hp.subset fun x hx => _\n    rw [Set.mem_setOf_eq] at hx\n    exact hx.left\n  have hle' := nat.sub_pos_of_lt hle\n  specialize hk hp'' (k.le_succ.trans hle)\n  rw [Nat.sub_succ', ← hk]\n  convert_to (Finset.erase hp''.to_finset (nth p k)).card = _\n  · congr\n    ext a\n    simp only [set.finite.mem_to_finset, ne.def, Set.mem_setOf_eq, Finset.mem_erase]\n    refine' ⟨fun ⟨hp, hlt⟩ => ⟨(hlt _ (lt_add_one k)).ne', ⟨hp, fun n hn => hlt n (hn.trans_le k.le_succ)⟩⟩, _⟩\n    rintro ⟨hak : _ ≠ _, hp, hlt⟩\n    refine' ⟨hp, fun n hn => _⟩\n    rw [lt_succ_iff] at hn\n    obtain hnk | rfl := hn.lt_or_eq\n    · exact hlt _ hnk\n    · refine' lt_of_le_of_ne _ (ne.symm hak)\n      rw [nth]\n      apply nat.Inf_le\n      simpa [hp] using hlt\n  apply finset.card_erase_of_mem\n  rw [nth, set.finite.mem_to_finset]\n  apply cinfₛ_mem\n  rwa [← hp''.to_finset_nonempty, ← finset.card_pos, hk]\n#align nth_set_card_aux nth_set_card_aux\n\n",
 "nth_set_card":
 "theorem nth_set_card {n : ℕ} (hp : (set_of p).finite) (hp' : { i : ℕ | p i ∧ ∀ k < n, nth p k < i }.finite) :\n    hp'.to_finset.card = hp.to_finset.card - n :=\n  by\n  obtain hn | hn := le_or_lt n hp.to_finset.card\n  · exact nth_set_card_aux p hp _ hn\n  rw [nat.sub_eq_zero_of_le hn.le]\n  simp only [finset.card_eq_zero, set.finite.to_finset_eq_empty, ← Set.subset_empty_iff]\n  convert_to _ ⊆ { i : ℕ | p i ∧ ∀ k : ℕ, k < hp.to_finset.card → nth p k < i }\n  · symm\n    rw [← set.finite.to_finset_eq_empty, ← finset.card_eq_zero, ← nat.sub_self hp.to_finset.card]\n    · apply nth_set_card_aux p hp _ le_rfl\n    · exact hp.subset fun x hx => hx.1\n  exact fun x hx => ⟨hx.1, fun k hk => hx.2 _ (hk.trans hn)⟩\n#align nth_set_card nth_set_card\n\n",
 "nth_monotone":
 "theorem nth_monotone (hp : (set_of p).infinite) : monotone (nth p) :=\n  (nth_strict_mono p hp).monotone\n#align nth_monotone nth_monotone\n\n",
 "nth_mono_of_finite":
 "theorem nth_mono_of_finite {a b : ℕ} (hp : (set_of p).finite) (hb : b < hp.to_finset.card) (hab : a ≤ b) :\n    nth p a ≤ nth p b := by\n  obtain rfl | h := hab.eq_or_lt\n  · exact le_rfl\n  · exact (nth_strict_mono_of_finite p hp hb h).le\n#align nth_mono_of_finite nth_mono_of_finite\n\n",
 "nth_mem_of_lt_card_finite_aux":
 "theorem nth_mem_of_lt_card_finite_aux (n : ℕ) (hp : (set_of p).finite) (hlt : n < hp.to_finset.card) :\n    nth p n ∈ { i : ℕ | p i ∧ ∀ k < n, nth p k < i } :=\n  by\n  rw [nth]\n  apply cinfₛ_mem\n  exact nth_set_nonempty_of_lt_card _ _ hlt\n#align nth_mem_of_lt_card_finite_aux nth_mem_of_lt_card_finite_aux\n\n",
 "nth_mem_of_lt_card_finite":
 "theorem nth_mem_of_lt_card_finite {n : ℕ} (hp : (set_of p).finite) (hlt : n < hp.to_finset.card) : p (nth p n) :=\n  (nth_mem_of_lt_card_finite_aux p n hp hlt).1\n#align nth_mem_of_lt_card_finite nth_mem_of_lt_card_finite\n\n",
 "nth_mem_of_infinite_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem nth_mem_of_infinite_aux (hp : (set_of p).infinite) (n : ℕ) : nth p n ∈ { i : ℕ | p i ∧ ∀ k < n, nth p k < i } :=\n  by\n  rw [nth]\n  apply cinfₛ_mem\n  let s : set ℕ :=\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n      { i : ℕ | nth p k ≥ i }\n  convert_to (set_of p \\ s).nonempty\n  · ext i\n    simp\n  refine' (hp.diff <| (set.finite_lt_nat _).bUnion _).nonempty\n  exact fun k h => set.finite_le_nat _\n#align nth_mem_of_infinite_aux nth_mem_of_infinite_aux\n\n",
 "nth_mem_of_infinite":
 "theorem nth_mem_of_infinite (hp : (set_of p).infinite) (n : ℕ) : p (nth p n) :=\n  (nth_mem_of_infinite_aux p hp n).1\n#align nth_mem_of_infinite nth_mem_of_infinite\n\n",
 "nth_lt_of_lt_count":
 "theorem nth_lt_of_lt_count (n k : ℕ) (h : k < count p n) : nth p k < n :=\n  by\n  obtain hp | hp := em (set_of p).finite\n  · refine' (count_monotone p).reflect_lt _\n    rwa [count_nth_of_lt_card_finite p hp]\n    refine' h.trans_le _\n    rw [count_eq_card_filter_range]\n    exact finset.card_le_of_subset fun x hx => hp.mem_to_finset.2 (mem_filter.1 hx).2\n  · rwa [← lt_nth_iff_count_lt _ hp]\n#align nth_lt_of_lt_count nth_lt_of_lt_count\n\n",
 "nth_injective_of_infinite":
 "theorem nth_injective_of_infinite (hp : (set_of p).infinite) : function.injective (nth p) :=\n  by\n  intro m n h\n  wlog h' : m ≤ n\n  rw [le_iff_lt_or_eq] at h'\n  obtain h' | rfl := h'\n  · simpa [h] using nth_strict_mono p hp h'\n  · rfl\n#align nth_injective_of_infinite nth_injective_of_infinite\n\n",
 "nth_eq_order_iso_of_nat":
 "/-- When `p` is true infinitely often, `nth` agrees with `nat.subtype.order_iso_of_nat`. -/\ntheorem nth_eq_order_iso_of_nat (i : Infinite (set_of p)) (n : ℕ) :\n    nth p n = nat.subtype.order_iso_of_nat (set_of p) n := by\n  classical\n    have hi := set.infinite_coe_iff.mp i\n    induction' n with k hk <;> simp only [subtype.order_iso_of_nat_apply, subtype.of_nat, nat_zero_eq_zero]\n    · rw [Nat.Subtype.coe_bot, nth_zero_of_exists]\n    · simp only [nat.subtype.succ, Set.mem_setOf_eq, subtype.coe_mk, subtype.val_eq_coe]\n      rw [subtype.order_iso_of_nat_apply] at hk\n      set b := nth p k.succ - nth p k - 1 with hb\n      replace hb : p (↑(subtype.of_nat (set_of p) k) + b + 1)\n      · rw [hb, ← hk, tsub_right_comm]\n        have hn11 : nth p k.succ - 1 + 1 = nth p k.succ :=\n          by\n          rw [tsub_add_cancel_iff_le]\n          exact succ_le_of_lt (pos_of_gt (nth_strict_mono p hi (lt_add_one k)))\n        rw [add_tsub_cancel_of_le]\n        · rw [hn11]\n          apply nth_mem_of_infinite p hi\n        · rw [← lt_succ_iff, ← nat.add_one, hn11]\n          apply nth_strict_mono p hi\n          exact lt_add_one k\n      have H : ∃ n : ℕ, p (↑(subtype.of_nat (set_of p) k) + n + 1) := ⟨b, hb⟩\n      set t := nat.find H with ht\n      obtain ⟨hp, hmin⟩ := (Nat.find_eq_iff _).mp ht\n      rw [← ht, ← hk] at hp hmin⊢\n      rw [nth, Inf_def ⟨_, nth_mem_of_infinite_aux p hi k.succ⟩, Nat.find_eq_iff]\n      refine' ⟨⟨by convert hp, fun r hr => _⟩, fun n hn => _⟩\n      · rw [lt_succ_iff] at hr⊢\n        exact (nth_monotone p hi hr).trans (by simp)\n      simp only [exists_prop, not_and, not_lt, Set.mem_setOf_eq, not_forall]\n      refine' fun hpn => ⟨k, lt_add_one k, _⟩\n      by_contra' hlt\n      replace hn : n - nth p k - 1 < t\n      · rw [tsub_lt_iff_left]\n        · rw [tsub_lt_iff_left hlt.le]\n          convert hn using 1\n          ac_rfl\n        exact le_tsub_of_add_le_left (succ_le_of_lt hlt)\n      refine' hmin (n - nth p k - 1) hn _\n      convert hpn\n      have hn11 : n - 1 + 1 = n := nat.sub_add_cancel (pos_of_gt hlt)\n      rwa [tsub_right_comm, add_tsub_cancel_of_le]\n      rwa [← hn11, lt_succ_iff] at hlt\n#align nth_eq_order_iso_of_nat nth_eq_order_iso_of_nat\n\n",
 "nth_count_le":
 "theorem nth_count_le (hp : (set_of p).infinite) (n : ℕ) : n ≤ nth p (count p n) :=\n  by\n  rw [nth_count_eq_Inf]\n  suffices h : Inf { i : ℕ | p i ∧ n ≤ i } ∈ { i : ℕ | p i ∧ n ≤ i }\n  · exact h.2\n  apply cinfₛ_mem\n  obtain ⟨m, hp, hn⟩ := hp.exists_nat_lt n\n  exact ⟨m, hp, hn.le⟩\n#align nth_count_le nth_count_le\n\n",
 "nth_count_eq_Inf":
 "theorem nth_count_eq_Inf {n : ℕ} : nth p (count p n) = infₛ { i : ℕ | p i ∧ n ≤ i } :=\n  by\n  rw [nth]\n  congr\n  ext a\n  simp only [Set.mem_setOf_eq, and_congr_right_iff]\n  intro hpa\n  refine' ⟨fun h => _, fun hn k hk => lt_of_lt_of_le _ hn⟩\n  · by_contra ha\n    simp only [not_le] at ha\n    have hn : nth p (count p a) < a := h _ (count_strict_mono hpa ha)\n    rwa [nth_count p hpa, lt_self_iff_false] at hn\n  · apply (count_monotone p).reflect_lt\n    convert hk\n    obtain hp | hp : (set_of p).finite ∨ (set_of p).infinite := em (set_of p).finite\n    · rw [count_nth_of_lt_card_finite _ hp]\n      exact hk.trans ((count_monotone _ hn).trans_lt (count_lt_card hp hpa))\n    · apply count_nth_of_infinite p hp\n#align nth_count_eq_Inf nth_count_eq_Inf\n\n",
 "nth_count":
 "@[simp]\ntheorem nth_count {n : ℕ} (hpn : p n) : nth p (count p n) = n :=\n  by\n  obtain hp | hp := em (set_of p).finite\n  · refine' count_injective _ hpn _\n    · apply nth_mem_of_lt_card_finite p hp\n      exact count_lt_card hp hpn\n    · exact count_nth_of_lt_card_finite _ _ (count_lt_card hp hpn)\n  · apply count_injective (nth_mem_of_infinite _ hp _) hpn\n    apply count_nth_of_infinite p hp\n#align nth_count nth_count\n\n",
 "lt_nth_iff_count_lt":
 "theorem lt_nth_iff_count_lt (hp : (set_of p).infinite) {a b : ℕ} : a < count p b ↔ nth p a < b :=\n  lt_iff_lt_of_le_iff_le <| count_le_iff_le_nth p hp\n#align lt_nth_iff_count_lt lt_nth_iff_count_lt\n\n",
 "le_nth_of_lt_nth_succ_infinite":
 "theorem le_nth_of_lt_nth_succ_infinite {k a : ℕ} (hp : (set_of p).infinite) (h : a < nth p k.succ) (ha : p a) :\n    a ≤ nth p k := by\n  by_contra' hak\n  refine' h.not_le _\n  rw [nth]\n  apply nat.Inf_le\n  exact ⟨ha, fun n hn => (nth_monotone p hp (le_of_lt_succ hn)).trans_lt hak⟩\n#align le_nth_of_lt_nth_succ_infinite le_nth_of_lt_nth_succ_infinite\n\n",
 "le_nth_of_lt_nth_succ_finite":
 "theorem le_nth_of_lt_nth_succ_finite {k a : ℕ} (hp : (set_of p).finite) (hlt : k.succ < hp.to_finset.card)\n    (h : a < nth p k.succ) (ha : p a) : a ≤ nth p k :=\n  by\n  by_contra' hak\n  refine' h.not_le _\n  rw [nth]\n  apply nat.Inf_le\n  refine' ⟨ha, fun n hn => lt_of_le_of_lt _ hak⟩\n  exact nth_mono_of_finite p hp (k.le_succ.trans_lt hlt) (le_of_lt_succ hn)\n#align le_nth_of_lt_nth_succ_finite le_nth_of_lt_nth_succ_finite\n\n",
 "le_nth_of_count_le":
 "theorem le_nth_of_count_le (n k : ℕ) (h : n ≤ nth p k) : count p n ≤ k :=\n  by\n  by_contra hc\n  apply not_lt.mpr h\n  apply nth_lt_of_lt_count\n  simpa using hc\n#align le_nth_of_count_le le_nth_of_count_le\n\n",
 "filter_range_nth_eq_insert_of_infinite":
 "theorem filter_range_nth_eq_insert_of_infinite (hp : (set_of p).infinite) (k : ℕ) :\n    (Finset.range (nth p k.succ)).filter p = insert (nth p k) ((Finset.range (nth p k)).filter p) :=\n  by\n  ext a\n  simp_rw [mem_insert, mem_filter, mem_range]\n  constructor\n  · rintro ⟨ha, hpa⟩\n    rw [nth] at ha\n    refine' or_iff_not_imp_left.mpr fun hne => ⟨(le_of_not_lt fun h => _).lt_of_ne hne, hpa⟩\n    exact ha.not_le (nat.Inf_le ⟨hpa, fun b hb => (nth_monotone p hp (le_of_lt_succ hb)).trans_lt h⟩)\n  · rintro (rfl | ⟨ha, hpa⟩)\n    · exact ⟨nth_strict_mono p hp (lt_succ_self k), nth_mem_of_infinite p hp _⟩\n    · exact ⟨ha.trans (nth_strict_mono p hp (lt_succ_self k)), hpa⟩\n#align filter_range_nth_eq_insert_of_infinite filter_range_nth_eq_insert_of_infinite\n\n",
 "filter_range_nth_eq_insert_of_finite":
 "theorem filter_range_nth_eq_insert_of_finite (hp : (set_of p).finite) {k : ℕ} (hlt : k.succ < hp.to_finset.card) :\n    Finset.filter p (Finset.range (nth p k.succ)) = insert (nth p k) (Finset.filter p (Finset.range (nth p k))) :=\n  by\n  ext a\n  simp_rw [mem_insert, mem_filter, mem_range]\n  constructor\n  · rintro ⟨ha, hpa⟩\n    refine' or_iff_not_imp_left.mpr fun h => ⟨lt_of_le_of_ne _ h, hpa⟩\n    exact le_nth_of_lt_nth_succ_finite p hp hlt ha hpa\n  · rintro (ha | ⟨ha, hpa⟩)\n    · rw [ha]\n      refine' ⟨nth_strict_mono_of_finite p hp hlt (lt_add_one _), _⟩\n      apply nth_mem_of_lt_card_finite p hp\n      exact k.le_succ.trans_lt hlt\n    refine' ⟨ha.trans _, hpa⟩\n    exact nth_strict_mono_of_finite p hp hlt (lt_add_one _)\n#align filter_range_nth_eq_insert_of_finite filter_range_nth_eq_insert_of_finite\n\n",
 "count_nth_zero":
 "@[simp]\ntheorem count_nth_zero : count p (nth p 0) = 0 :=\n  by\n  rw [count_eq_card_filter_range, finset.card_eq_zero, nth_zero]\n  ext a\n  simp_rw [not_mem_empty, mem_filter, mem_range, iff_false_iff]\n  rintro ⟨ha, hp⟩\n  exact ha.not_le (nat.Inf_le hp)\n#align count_nth_zero count_nth_zero\n\n",
 "count_nth_of_lt_card_finite":
 "theorem count_nth_of_lt_card_finite {n : ℕ} (hp : (set_of p).finite) (hlt : n < hp.to_finset.card) :\n    count p (nth p n) = n := by\n  induction' n with k hk\n  · exact count_nth_zero _\n  · rw [count_eq_card_filter_range, filter_range_nth_eq_insert_of_finite p hp hlt, finset.card_insert_of_not_mem, ←\n      count_eq_card_filter_range, hk (lt_of_succ_lt hlt)]\n    simp\n#align count_nth_of_lt_card_finite count_nth_of_lt_card_finite\n\n",
 "count_nth_of_infinite":
 "theorem count_nth_of_infinite (hp : (set_of p).infinite) (n : ℕ) : count p (nth p n) = n :=\n  by\n  induction' n with k hk\n  · exact count_nth_zero _\n  · rw [count_eq_card_filter_range, filter_range_nth_eq_insert_of_infinite p hp, finset.card_insert_of_not_mem, ←\n      count_eq_card_filter_range, hk]\n    simp\n#align count_nth_of_infinite count_nth_of_infinite\n\n",
 "count_nth_gc":
 "theorem count_nth_gc (hp : (set_of p).infinite) : GaloisConnection (count p) (nth p) :=\n  by\n  rintro x y\n  rw [nth, le_cinfₛ_iff ⟨0, fun _ _ => nat.zero_le _⟩ ⟨nth p y, nth_mem_of_infinite_aux p hp y⟩]\n  dsimp\n  refine' ⟨_, fun h => _⟩\n  · rintro hy n ⟨hn, h⟩\n    obtain hy' | rfl := hy.lt_or_eq\n    · exact (nth_count_le p hp x).trans (h (count p x) hy').le\n    · specialize h (count p n)\n      replace hn : nth p (count p n) = n := nth_count _ hn\n      replace h : count p x ≤ count p n := by rwa [hn, lt_self_iff_false, imp_false, not_lt] at h\n      refine' (nth_count_le p hp x).trans _\n      rw [← hn]\n      exact nth_monotone p hp h\n  · rw [← count_nth_of_infinite p hp y]\n    exact count_monotone _ (h (nth p y) ⟨nth_mem_of_infinite p hp y, fun k hk => nth_strict_mono p hp hk⟩)\n#align count_nth_gc count_nth_gc\n\n",
 "count_le_iff_le_nth":
 "theorem count_le_iff_le_nth (hp : (set_of p).infinite) {a b : ℕ} : count p a ≤ b ↔ a ≤ nth p b :=\n  count_nth_gc p hp _ _\n#align count_le_iff_le_nth count_le_iff_le_nth\n\n"}