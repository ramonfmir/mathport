{"mul_divisors_filter_prime_pow":
 "theorem nat.mul_divisors_filter_prime_pow {a b : ℕ} (hab : a.coprime b) :\n    (a * b).divisors.filter is_prime_pow = (a.divisors ∪ b.divisors).filter is_prime_pow :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [nat.coprime_zero_left] at hab\n    simp [hab, Finset.filter_singleton, not_is_prime_pow_one]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp only [nat.coprime_zero_right] at hab\n    simp [hab, Finset.filter_singleton, not_is_prime_pow_one]\n  ext n\n  simp only [ha, hb, Finset.mem_union, Finset.mem_filter, Nat.mul_eq_zero, and_true_iff, ne.def, and_congr_left_iff,\n    not_false_iff, nat.mem_divisors, or_self_iff]\n  apply hab.is_prime_pow_dvd_mul\n#align nat.mul_divisors_filter_prime_pow nat.mul_divisors_filter_prime_pow\n\n",
 "min_fac_pow_factorization_eq":
 "/-\nCopyright (c) 2022 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\ntheorem is_prime_pow.min_fac_pow_factorization_eq {n : ℕ} (hn : is_prime_pow n) :\n    n.min_fac ^ n.factorization n.min_fac = n :=\n  by\n  obtain ⟨p, k, hp, hk, rfl⟩ := hn\n  rw [← Nat.prime_iff] at hp\n  rw [hp.pow_min_fac hk.ne', hp.factorization_pow, finsupp.single_eq_same]\n#align is_prime_pow.min_fac_pow_factorization_eq is_prime_pow.min_fac_pow_factorization_eq\n\n",
 "is_prime_pow_pow_iff":
 "theorem is_prime_pow_pow_iff {n k : ℕ} (hk : k ≠ 0) : is_prime_pow (n ^ k) ↔ is_prime_pow n :=\n  by\n  simp only [is_prime_pow_iff_unique_prime_dvd]\n  apply exists_unique_congr\n  simp only [and_congr_right_iff]\n  intro p hp\n  exact ⟨hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)⟩\n#align is_prime_pow_pow_iff is_prime_pow_pow_iff\n\n",
 "is_prime_pow_of_min_fac_pow_factorization_eq":
 "theorem is_prime_pow_of_min_fac_pow_factorization_eq {n : ℕ} (h : n.min_fac ^ n.factorization n.min_fac = n)\n    (hn : n ≠ 1) : is_prime_pow n := by\n  rcases eq_or_ne n 0 with (rfl | hn')\n  · simpa using h\n  refine' ⟨_, _, (Nat.minFac_prime hn).prime, _, h⟩\n  rw [pos_iff_ne_zero, ← finsupp.mem_support_iff, nat.factor_iff_mem_factorization,\n    nat.mem_factors_iff_dvd hn' (Nat.minFac_prime hn)]\n  apply Nat.minFac_dvd\n#align is_prime_pow_of_min_fac_pow_factorization_eq is_prime_pow_of_min_fac_pow_factorization_eq\n\n",
 "is_prime_pow_iff_unique_prime_dvd":
 "/-- An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime\ndividing it. -/\ntheorem is_prime_pow_iff_unique_prime_dvd {n : ℕ} : is_prime_pow n ↔ ∃! p : ℕ, p.prime ∧ p ∣ n :=\n  by\n  rw [is_prime_pow_nat_iff]\n  constructor\n  · rintro ⟨p, k, hp, hk, rfl⟩\n    refine' ⟨p, ⟨hp, dvd_pow_self _ hk.ne'⟩, _⟩\n    rintro q ⟨hq, hq'⟩\n    exact (Nat.prime_dvd_prime_iff_eq hq hp).1 (hq.dvd_of_dvd_pow hq')\n  rintro ⟨p, ⟨hp, hn⟩, hq⟩\n  rcases eq_or_ne n 0 with (rfl | hn₀)\n  · cases (hq 2 ⟨Nat.prime_two, dvd_zero 2⟩).trans (hq 3 ⟨Nat.prime_three, dvd_zero 3⟩).symm\n  refine' ⟨p, n.factorization p, hp, hp.factorization_pos_of_dvd hn₀ hn, _⟩\n  simp only [and_imp] at hq\n  apply nat.dvd_antisymm (nat.ord_proj_dvd _ _)\n  -- We need to show n ∣ p ^ n.factorization p\n  apply nat.dvd_of_factors_subperm hn₀\n  rw [hp.factors_pow, List.subperm_ext_iff]\n  intro q hq'\n  rw [nat.mem_factors hn₀] at hq'\n  cases hq _ hq'.1 hq'.2\n  simp\n#align is_prime_pow_iff_unique_prime_dvd is_prime_pow_iff_unique_prime_dvd\n\n",
 "is_prime_pow_iff_min_fac_pow_factorization_eq":
 "theorem is_prime_pow_iff_min_fac_pow_factorization_eq {n : ℕ} (hn : n ≠ 1) :\n    is_prime_pow n ↔ n.min_fac ^ n.factorization n.min_fac = n :=\n  ⟨fun h => h.min_fac_pow_factorization_eq, fun h => is_prime_pow_of_min_fac_pow_factorization_eq h hn⟩\n#align is_prime_pow_iff_min_fac_pow_factorization_eq is_prime_pow_iff_min_fac_pow_factorization_eq\n\n",
 "is_prime_pow_iff_factorization_eq_single":
 "theorem is_prime_pow_iff_factorization_eq_single {n : ℕ} :\n    is_prime_pow n ↔ ∃ p k : ℕ, 0 < k ∧ n.factorization = finsupp.single p k :=\n  by\n  rw [is_prime_pow_nat_iff]\n  refine' exists₂_congr fun p k => _\n  constructor\n  · rintro ⟨hp, hk, hn⟩\n    exact ⟨hk, by rw [← hn, nat.prime.factorization_pow hp]⟩\n  · rintro ⟨hk, hn⟩\n    have hn0 : n ≠ 0 := by\n      rintro rfl\n      simpa only [finsupp.single_eq_zero, eq_comm, nat.factorization_zero, hk.ne'] using hn\n    rw [nat.eq_pow_of_factorization_eq_single hn0 hn]\n    exact ⟨nat.prime_of_mem_factorization (by simp [hn, hk.ne'] : p ∈ n.factorization.support), hk, rfl⟩\n#align is_prime_pow_iff_factorization_eq_single is_prime_pow_iff_factorization_eq_single\n\n",
 "is_prime_pow_iff_card_support_factorization_eq_one":
 "theorem is_prime_pow_iff_card_support_factorization_eq_one {n : ℕ} :\n    is_prime_pow n ↔ n.factorization.support.card = 1 := by\n  simp_rw [is_prime_pow_iff_factorization_eq_single, finsupp.card_support_eq_one', exists_prop, pos_iff_ne_zero]\n#align is_prime_pow_iff_card_support_factorization_eq_one is_prime_pow_iff_card_support_factorization_eq_one\n\n",
 "is_prime_pow_dvd_mul":
 "theorem nat.coprime.is_prime_pow_dvd_mul {n a b : ℕ} (hab : nat.coprime a b) (hn : is_prime_pow n) :\n    n ∣ a * b ↔ n ∣ a ∨ n ∣ b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [nat.coprime_zero_left] at hab\n    simp [hab, Finset.filter_singleton, not_is_prime_pow_one]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp only [nat.coprime_zero_right] at hab\n    simp [hab, Finset.filter_singleton, not_is_prime_pow_one]\n  refine' ⟨_, fun h => or.elim h (fun i => i.trans (dvd_mul_right _ _)) fun i => i.trans (dvd_mul_left _ _)⟩\n  obtain ⟨p, k, hp, hk, rfl⟩ := (is_prime_pow_nat_iff _).1 hn\n  simp only [hp.pow_dvd_iff_le_factorization (mul_ne_zero ha hb), nat.factorization_mul ha hb,\n    hp.pow_dvd_iff_le_factorization ha, hp.pow_dvd_iff_le_factorization hb, pi.add_apply, finsupp.coe_add]\n  have : a.factorization p = 0 ∨ b.factorization p = 0 :=\n    by\n    rw [← finsupp.not_mem_support_iff, ← finsupp.not_mem_support_iff, ← not_and_or, ← Finset.mem_inter]\n    exact fun t => (nat.factorization_disjoint_of_coprime hab).le_bot t\n  cases this <;> simp [this, imp_or]\n#align nat.coprime.is_prime_pow_dvd_mul nat.coprime.is_prime_pow_dvd_mul\n\n",
 "exists_ord_compl_eq_one_iff_is_prime_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem exists_ord_compl_eq_one_iff_is_prime_pow {n : ℕ} (hn : n ≠ 1) :\n    is_prime_pow n ↔ ∃ p : ℕ, p.prime ∧ «exprord_compl[ ] » p n = 1 :=\n  by\n  refine' ⟨fun h => is_prime_pow.exists_ord_compl_eq_one h, fun h => _⟩\n  rcases h with ⟨p, pp, h⟩\n  rw [is_prime_pow_nat_iff]\n  rw [← Nat.eq_of_dvd_of_div_eq_one (nat.ord_proj_dvd n p) h] at hn⊢\n  refine' ⟨p, n.factorization p, pp, _, by simp⟩\n  contrapose! hn\n  simp [le_zero_iff.1 hn]\n#align exists_ord_compl_eq_one_iff_is_prime_pow exists_ord_compl_eq_one_iff_is_prime_pow\n\n",
 "exists_ord_compl_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem is_prime_pow.exists_ord_compl_eq_one {n : ℕ} (h : is_prime_pow n) :\n    ∃ p : ℕ, p.prime ∧ «exprord_compl[ ] » p n = 1 :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn0); · cases not_is_prime_pow_zero h\n  rcases is_prime_pow_iff_factorization_eq_single.mp h with ⟨p, k, hk0, h1⟩\n  rcases em' p.prime with (pp | pp)\n  · refine' absurd _ hk0.ne'\n    simp [← nat.factorization_eq_zero_of_non_prime n pp, h1]\n  refine' ⟨p, pp, _⟩\n  refine' nat.eq_of_factorization_eq (nat.ord_compl_pos p hn0).ne' (by simp) fun q => _\n  rw [nat.factorization_ord_compl n p, h1]\n  simp\n#align is_prime_pow.exists_ord_compl_eq_one is_prime_pow.exists_ord_compl_eq_one\n\n"}