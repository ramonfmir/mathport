{"mul_divisors_filter_prime_pow":
 "#print Nat.mul_divisors_filter_prime_pow /-\ntheorem Nat.mul_divisors_filter_prime_pow {a b : ℕ} (hab : a.coprime b) :\n    (a * b).divisors.filter IsPrimePow = (a.divisors ∪ b.divisors).filter IsPrimePow :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [Nat.coprime_zero_left] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp only [Nat.coprime_zero_right] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  ext n\n  simp only [ha, hb, Finset.mem_union, Finset.mem_filter, Nat.mul_eq_zero, and_true_iff, ne.def, and_congr_left_iff,\n    not_false_iff, Nat.mem_divisors, or_self_iff]\n  apply hab.is_prime_pow_dvd_mul\n#align nat.mul_divisors_filter_prime_pow Nat.mul_divisors_filter_prime_pow\n-/\n\n",
 "minFac_pow_factorization_eq":
 "#print IsPrimePow.minFac_pow_factorization_eq /-\n/-\nCopyright (c) 2022 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\ntheorem IsPrimePow.minFac_pow_factorization_eq {n : ℕ} (hn : IsPrimePow n) :\n    n.min_fac ^ n.factorization n.min_fac = n :=\n  by\n  obtain ⟨p, k, hp, hk, rfl⟩ := hn\n  rw [← Nat.prime_iff] at hp\n  rw [hp.pow_min_fac hk.ne', hp.factorization_pow, Finsupp.single_eq_same]\n#align is_prime_pow.min_fac_pow_factorization_eq IsPrimePow.minFac_pow_factorization_eq\n-/\n\n",
 "isPrimePow_pow_iff":
 "#print isPrimePow_pow_iff /-\ntheorem isPrimePow_pow_iff {n k : ℕ} (hk : k ≠ 0) : IsPrimePow (n ^ k) ↔ IsPrimePow n :=\n  by\n  simp only [isPrimePow_iff_unique_prime_dvd]\n  apply exists_unique_congr\n  simp only [and_congr_right_iff]\n  intro p hp\n  exact ⟨hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)⟩\n#align is_prime_pow_pow_iff isPrimePow_pow_iff\n-/\n\n",
 "isPrimePow_of_minFac_pow_factorization_eq":
 "#print isPrimePow_of_minFac_pow_factorization_eq /-\ntheorem isPrimePow_of_minFac_pow_factorization_eq {n : ℕ} (h : n.min_fac ^ n.factorization n.min_fac = n) (hn : n ≠ 1) :\n    IsPrimePow n := by\n  rcases eq_or_ne n 0 with (rfl | hn')\n  · simpa using h\n  refine' ⟨_, _, (Nat.minFac_prime hn).prime, _, h⟩\n  rw [pos_iff_ne_zero, ← Finsupp.mem_support_iff, Nat.factor_iff_mem_factorization,\n    Nat.mem_factors_iff_dvd hn' (Nat.minFac_prime hn)]\n  apply Nat.minFac_dvd\n#align is_prime_pow_of_min_fac_pow_factorization_eq isPrimePow_of_minFac_pow_factorization_eq\n-/\n\n",
 "isPrimePow_iff_unique_prime_dvd":
 "#print isPrimePow_iff_unique_prime_dvd /-\n/-- An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime\ndividing it. -/\ntheorem isPrimePow_iff_unique_prime_dvd {n : ℕ} : IsPrimePow n ↔ ∃! p : ℕ, p.prime ∧ p ∣ n :=\n  by\n  rw [isPrimePow_nat_iff]\n  constructor\n  · rintro ⟨p, k, hp, hk, rfl⟩\n    refine' ⟨p, ⟨hp, dvd_pow_self _ hk.ne'⟩, _⟩\n    rintro q ⟨hq, hq'⟩\n    exact (Nat.prime_dvd_prime_iff_eq hq hp).1 (hq.dvd_of_dvd_pow hq')\n  rintro ⟨p, ⟨hp, hn⟩, hq⟩\n  rcases eq_or_ne n 0 with (rfl | hn₀)\n  · cases (hq 2 ⟨Nat.prime_two, dvd_zero 2⟩).trans (hq 3 ⟨Nat.prime_three, dvd_zero 3⟩).symm\n  refine' ⟨p, n.factorization p, hp, hp.factorization_pos_of_dvd hn₀ hn, _⟩\n  simp only [and_imp] at hq\n  apply nat.dvd_antisymm (Nat.ord_proj_dvd _ _)\n  -- We need to show n ∣ p ^ n.factorization p\n  apply Nat.dvd_of_factors_subperm hn₀\n  rw [hp.factors_pow, List.subperm_ext_iff]\n  intro q hq'\n  rw [Nat.mem_factors hn₀] at hq'\n  cases hq _ hq'.1 hq'.2\n  simp\n#align is_prime_pow_iff_unique_prime_dvd isPrimePow_iff_unique_prime_dvd\n-/\n\n",
 "isPrimePow_iff_minFac_pow_factorization_eq":
 "#print isPrimePow_iff_minFac_pow_factorization_eq /-\ntheorem isPrimePow_iff_minFac_pow_factorization_eq {n : ℕ} (hn : n ≠ 1) :\n    IsPrimePow n ↔ n.min_fac ^ n.factorization n.min_fac = n :=\n  ⟨fun h => h.min_fac_pow_factorization_eq, fun h => isPrimePow_of_minFac_pow_factorization_eq h hn⟩\n#align is_prime_pow_iff_min_fac_pow_factorization_eq isPrimePow_iff_minFac_pow_factorization_eq\n-/\n\n",
 "isPrimePow_iff_factorization_eq_single":
 "#print isPrimePow_iff_factorization_eq_single /-\ntheorem isPrimePow_iff_factorization_eq_single {n : ℕ} :\n    IsPrimePow n ↔ ∃ p k : ℕ, 0 < k ∧ n.factorization = Finsupp.single p k :=\n  by\n  rw [isPrimePow_nat_iff]\n  refine' exists₂_congr fun p k => _\n  constructor\n  · rintro ⟨hp, hk, hn⟩\n    exact ⟨hk, by rw [← hn, Nat.Prime.factorization_pow hp]⟩\n  · rintro ⟨hk, hn⟩\n    have hn0 : n ≠ 0 := by\n      rintro rfl\n      simpa only [Finsupp.single_eq_zero, eq_comm, Nat.factorization_zero, hk.ne'] using hn\n    rw [Nat.eq_pow_of_factorization_eq_single hn0 hn]\n    exact ⟨Nat.prime_of_mem_factorization (by simp [hn, hk.ne'] : p ∈ n.factorization.support), hk, rfl⟩\n#align is_prime_pow_iff_factorization_eq_single isPrimePow_iff_factorization_eq_single\n-/\n\n",
 "isPrimePow_iff_card_support_factorization_eq_one":
 "#print isPrimePow_iff_card_support_factorization_eq_one /-\ntheorem isPrimePow_iff_card_support_factorization_eq_one {n : ℕ} : IsPrimePow n ↔ n.factorization.support.card = 1 := by\n  simp_rw [isPrimePow_iff_factorization_eq_single, Finsupp.card_support_eq_one', exists_prop, pos_iff_ne_zero]\n#align is_prime_pow_iff_card_support_factorization_eq_one isPrimePow_iff_card_support_factorization_eq_one\n-/\n\n",
 "isPrimePow_dvd_mul":
 "#print Nat.coprime.isPrimePow_dvd_mul /-\ntheorem Nat.coprime.isPrimePow_dvd_mul {n a b : ℕ} (hab : Nat.coprime a b) (hn : IsPrimePow n) :\n    n ∣ a * b ↔ n ∣ a ∨ n ∣ b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [Nat.coprime_zero_left] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp only [Nat.coprime_zero_right] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  refine' ⟨_, fun h => or.elim h (fun i => i.trans (dvd_mul_right _ _)) fun i => i.trans (dvd_mul_left _ _)⟩\n  obtain ⟨p, k, hp, hk, rfl⟩ := (isPrimePow_nat_iff _).1 hn\n  simp only [hp.pow_dvd_iff_le_factorization (mul_ne_zero ha hb), Nat.factorization_mul ha hb,\n    hp.pow_dvd_iff_le_factorization ha, hp.pow_dvd_iff_le_factorization hb, Pi.add_apply, Finsupp.coe_add]\n  have : a.factorization p = 0 ∨ b.factorization p = 0 :=\n    by\n    rw [← Finsupp.not_mem_support_iff, ← Finsupp.not_mem_support_iff, ← not_and_or, ← Finset.mem_inter]\n    exact fun t => (Nat.factorization_disjoint_of_coprime hab).le_bot t\n  cases this <;> simp [this, imp_or]\n#align nat.coprime.is_prime_pow_dvd_mul Nat.coprime.isPrimePow_dvd_mul\n-/\n\n",
 "exists_ord_compl_eq_one_iff_isPrimePow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n#print exists_ord_compl_eq_one_iff_isPrimePow /-\ntheorem exists_ord_compl_eq_one_iff_isPrimePow {n : ℕ} (hn : n ≠ 1) :\n    IsPrimePow n ↔ ∃ p : ℕ, p.prime ∧ «exprord_compl[ ] » p n = 1 :=\n  by\n  refine' ⟨fun h => IsPrimePow.exists_ord_compl_eq_one h, fun h => _⟩\n  rcases h with ⟨p, pp, h⟩\n  rw [isPrimePow_nat_iff]\n  rw [← Nat.eq_of_dvd_of_div_eq_one (Nat.ord_proj_dvd n p) h] at hn⊢\n  refine' ⟨p, n.factorization p, pp, _, by simp⟩\n  contrapose! hn\n  simp [le_zero_iff.1 hn]\n#align exists_ord_compl_eq_one_iff_is_prime_pow exists_ord_compl_eq_one_iff_isPrimePow\n-/\n\n",
 "exists_ord_compl_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n#print IsPrimePow.exists_ord_compl_eq_one /-\ntheorem IsPrimePow.exists_ord_compl_eq_one {n : ℕ} (h : IsPrimePow n) :\n    ∃ p : ℕ, p.prime ∧ «exprord_compl[ ] » p n = 1 :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn0); · cases not_isPrimePow_zero h\n  rcases is_prime_pow_iff_factorization_eq_single.mp h with ⟨p, k, hk0, h1⟩\n  rcases em' p.prime with (pp | pp)\n  · refine' absurd _ hk0.ne'\n    simp [← Nat.factorization_eq_zero_of_non_prime n pp, h1]\n  refine' ⟨p, pp, _⟩\n  refine' Nat.eq_of_factorization_eq (Nat.ord_compl_pos p hn0).ne' (by simp) fun q => _\n  rw [Nat.factorization_ord_compl n p, h1]\n  simp\n#align is_prime_pow.exists_ord_compl_eq_one IsPrimePow.exists_ord_compl_eq_one\n-/\n\n"}