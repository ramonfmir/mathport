{"support_factorization":
 "/-- The support of `n.factorization` is exactly `n.factors.to_finset` -/\n@[simp]\ntheorem support_factorization {n : ℕ} : n.factorization.support = n.factors.to_finset := by simp [factorization]\n#align support_factorization support_factorization\n\n",
 "set_of_pow_dvd_eq_Icc_factorization":
 "theorem set_of_pow_dvd_eq_Icc_factorization {n p : ℕ} (pp : p.prime) (hn : n ≠ 0) :\n    { i : ℕ | i ≠ 0 ∧ p ^ i ∣ n } = Set.Icc 1 (n.factorization p) :=\n  by\n  ext\n  simp [lt_succ_iff, one_le_iff_ne_zero, pp.pow_dvd_iff_le_factorization hn]\n#align set_of_pow_dvd_eq_Icc_factorization set_of_pow_dvd_eq_Icc_factorization\n\n",
 "prod_prime_factors_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_prime_factors_dvd (n : ℕ) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        n.factors.to_finset p ∣\n      n :=\n  by\n  by_cases hn : n = 0;\n  · subst hn\n    simp\n  simpa [prod_factors hn] using multiset.to_finset_prod_dvd_prod (n.factors : Multiset ℕ)\n#align prod_prime_factors_dvd prod_prime_factors_dvd\n\n",
 "prod_pow_prime_padic_val_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem prod_pow_prime_padic_val_nat (n : nat) (hn : n ≠ 0) (m : nat) (pr : n < m) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (Finset.filter Nat.Prime (Finset.range m)) (p ^ padic_val_nat p n) =\n      n :=\n  by\n  nth_rw_rhs 1 [← factorization_prod_pow_eq_self hn]\n  rw [eq_comm]\n  apply finset.prod_subset_one_on_sdiff\n  ·\n    exact fun p hp =>\n      finset.mem_filter.mpr\n        ⟨finset.mem_range.mpr (gt_of_gt_of_ge pr (le_of_mem_factorization hp)), prime_of_mem_factorization hp⟩\n  · intro p hp\n    cases' finset.mem_sdiff.mp hp with hp1 hp2\n    rw [← factorization_def n (finset.mem_filter.mp hp1).2]\n    simp [finsupp.not_mem_support_iff.mp hp2]\n  · intro p hp\n    simp [factorization_def n (prime_of_mem_factorization hp)]\n#align prod_pow_prime_padic_val_nat prod_pow_prime_padic_val_nat\n\n",
 "prod_pow_factorization_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Any finsupp `f : ℕ →₀ ℕ` whose support is in the primes is equal to the factorization of\nthe product `∏ (a : ℕ) in f.support, a ^ f a`. -/\ntheorem prod_pow_factorization_eq_self {f : «expr →₀ » ℕ ℕ} (hf : ∀ p : ℕ, p ∈ f.support → Prime p) :\n    (f.prod pow).factorization = f :=\n  by\n  have h : ∀ x : ℕ, x ∈ f.support → x ^ f x ≠ 0 := fun p hp => pow_ne_zero _ (Prime.ne_zero (hf p hp))\n  simp only [finsupp.prod, factorization_prod h]\n  nth_rw_rhs 1 [(sum_single f).symm]\n  exact sum_congr rfl fun p hp => prime.factorization_pow (hf p hp)\n#align prod_pow_factorization_eq_self prod_pow_factorization_eq_self\n\n",
 "prod_factors_gcd_mul_prod_factors_mul":
 "@[to_additive sum_factors_gcd_add_sum_factors_mul]\ntheorem prod_factors_gcd_mul_prod_factors_mul {β : Type _} [comm_monoid β] (m n : ℕ) (f : ℕ → β) :\n    (m.gcd n).factors.to_finset.prod f * (m * n).factors.to_finset.prod f =\n      m.factors.to_finset.prod f * n.factors.to_finset.prod f :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hm0); · simp\n  rcases eq_or_ne m 0 with (rfl | hn0); · simp\n  rw [← @finset.prod_union_inter _ _ m.factors.to_finset n.factors.to_finset, mul_comm]\n  congr\n  · apply factors_mul_to_finset <;> assumption\n  · simp only [← support_factorization, factorization_gcd hn0 hm0, finsupp.support_inf]\n#align prod_factors_gcd_mul_prod_factors_mul prod_factors_gcd_mul_prod_factors_mul\n\n",
 "prod_factorization_eq_prod_factors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If a product over `n.factorization` doesn't use the multiplicities of the prime factors\nthen it's equal to the corresponding product over `n.factors.to_finset` -/\ntheorem prod_factorization_eq_prod_factors {n : ℕ} {β : Type _} [comm_monoid β] (f : ℕ → β) :\n    (n.factorization.prod fun p k => f p) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        n.factors.to_finset (f p) :=\n  by\n  apply prod_congr support_factorization\n  simp\n#align prod_factorization_eq_prod_factors prod_factorization_eq_prod_factors\n\n",
 "prime_of_mem_factorization":
 "theorem prime_of_mem_factorization {n p : ℕ} (hp : p ∈ n.factorization.support) : p.prime :=\n  prime_of_mem_factors (factor_iff_mem_factorization.mp hp)\n#align prime_of_mem_factorization prime_of_mem_factorization\n\n",
 "pow_succ_factorization_not_dvd":
 "theorem pow_succ_factorization_not_dvd {n p : ℕ} (hn : n ≠ 0) (hp : p.prime) : ¬p ^ (n.factorization p + 1) ∣ n :=\n  by\n  intro h\n  rw [← factorization_le_iff_dvd (pow_pos hp.pos _).ne' hn] at h\n  simpa [hp.factorization] using h p\n#align pow_succ_factorization_not_dvd pow_succ_factorization_not_dvd\n\n",
 "pow_dvd_iff_le_factorization":
 "theorem prime.pow_dvd_iff_le_factorization {p k n : ℕ} (pp : Prime p) (hn : n ≠ 0) :\n    p ^ k ∣ n ↔ k ≤ n.factorization p := by\n  rw [← factorization_le_iff_dvd (pow_pos pp.pos k).ne' hn, pp.factorization_pow, single_le_iff]\n#align prime.pow_dvd_iff_le_factorization prime.pow_dvd_iff_le_factorization\n\n",
 "pow_dvd_iff_dvd_ord_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem prime.pow_dvd_iff_dvd_ord_proj {p k n : ℕ} (pp : Prime p) (hn : n ≠ 0) :\n    p ^ k ∣ n ↔ p ^ k ∣ «exprord_proj[ ] » p n := by\n  rw [pow_dvd_pow_iff_le_right pp.one_lt, pp.pow_dvd_iff_le_factorization hn]\n#align prime.pow_dvd_iff_dvd_ord_proj prime.pow_dvd_iff_dvd_ord_proj\n\n",
 "pos_of_mem_factorization":
 "theorem pos_of_mem_factorization {n p : ℕ} (hp : p ∈ n.factorization.support) : 0 < p :=\n  Prime.pos (prime_of_mem_factorization hp)\n#align pos_of_mem_factorization pos_of_mem_factorization\n\n",
 "ord_proj_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem ord_proj_pos (n p : ℕ) : 0 < «exprord_proj[ ] » p n :=\n  by\n  by_cases pp : p.prime\n  · simp [pow_pos pp.pos]\n  · simp [pp]\n#align ord_proj_pos ord_proj_pos\n\n",
 "ord_proj_of_not_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\n@[simp]\ntheorem ord_proj_of_not_prime (n p : ℕ) (hp : ¬p.prime) : «exprord_proj[ ] » p n = 1 := by\n  simp [factorization_eq_zero_of_non_prime n hp]\n#align ord_proj_of_not_prime ord_proj_of_not_prime\n\n",
 "ord_proj_mul_ord_compl_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_proj_mul_ord_compl_eq_self (n p : ℕ) : «exprord_proj[ ] » p n * «exprord_compl[ ] » p n = n :=\n  Nat.mul_div_cancel' (ord_proj_dvd n p)\n#align ord_proj_mul_ord_compl_eq_self ord_proj_mul_ord_compl_eq_self\n\n",
 "ord_proj_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem ord_proj_mul {a b : ℕ} (p : ℕ) (ha : a ≠ 0) (hb : b ≠ 0) :\n    «exprord_proj[ ] » p (a * b) = «exprord_proj[ ] » p a * «exprord_proj[ ] » p b := by\n  simp [factorization_mul ha hb, pow_add]\n#align ord_proj_mul ord_proj_mul\n\n",
 "ord_proj_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem ord_proj_le {n : ℕ} (p : ℕ) (hn : n ≠ 0) : «exprord_proj[ ] » p n ≤ n :=\n  le_of_dvd hn.bot_lt (nat.ord_proj_dvd n p)\n#align ord_proj_le ord_proj_le\n\n",
 "ord_proj_dvd_ord_proj_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem ord_proj_dvd_ord_proj_of_dvd {a b : ℕ} (hb0 : b ≠ 0) (hab : a ∣ b) (p : ℕ) :\n    «exprord_proj[ ] » p a ∣ «exprord_proj[ ] » p b :=\n  by\n  rcases em' p.prime with (pp | pp); · simp [pp]\n  rcases eq_or_ne a 0 with (rfl | ha0); · simp\n  rw [pow_dvd_pow_iff_le_right pp.one_lt]\n  exact (factorization_le_iff_dvd ha0 hb0).2 hab p\n#align ord_proj_dvd_ord_proj_of_dvd ord_proj_dvd_ord_proj_of_dvd\n\n",
 "ord_proj_dvd_ord_proj_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem ord_proj_dvd_ord_proj_iff_dvd {a b : ℕ} (ha0 : a ≠ 0) (hb0 : b ≠ 0) :\n    (∀ p : ℕ, «exprord_proj[ ] » p a ∣ «exprord_proj[ ] » p b) ↔ a ∣ b :=\n  by\n  refine' ⟨fun h => _, fun hab p => ord_proj_dvd_ord_proj_of_dvd hb0 hab p⟩\n  rw [← factorization_le_iff_dvd ha0 hb0]\n  intro q\n  rcases le_or_lt q 1 with (hq_le | hq1); · interval_cases q <;> simp\n  exact (pow_dvd_pow_iff_le_right hq1).1 (h q)\n#align ord_proj_dvd_ord_proj_iff_dvd ord_proj_dvd_ord_proj_iff_dvd\n\n",
 "ord_proj_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem ord_proj_dvd (n p : ℕ) : «exprord_proj[ ] » p n ∣ n :=\n  by\n  by_cases hp : p.prime; swap; · simp [hp]\n  rw [← factors_count_eq]\n  apply dvd_of_factors_subperm (pow_ne_zero _ hp.ne_zero)\n  rw [hp.factors_pow, List.subperm_ext_iff]\n  intro q hq\n  simp [list.eq_of_mem_replicate hq]\n#align ord_proj_dvd ord_proj_dvd\n\n",
 "ord_compl_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_compl_pos {n : ℕ} (p : ℕ) (hn : n ≠ 0) : 0 < «exprord_compl[ ] » p n :=\n  by\n  cases' em' p.prime with pp pp\n  · simpa [nat.factorization_eq_zero_of_non_prime n pp] using hn.bot_lt\n  exact Nat.div_pos (ord_proj_le p hn) (ord_proj_pos n p)\n#align ord_compl_pos ord_compl_pos\n\n",
 "ord_compl_of_not_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n@[simp]\ntheorem ord_compl_of_not_prime (n p : ℕ) (hp : ¬p.prime) : «exprord_compl[ ] » p n = n := by\n  simp [factorization_eq_zero_of_non_prime n hp]\n#align ord_compl_of_not_prime ord_compl_of_not_prime\n\n",
 "ord_compl_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_compl_mul (a b p : ℕ) : «exprord_compl[ ] » p (a * b) = «exprord_compl[ ] » p a * «exprord_compl[ ] » p b :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha); · simp\n  rcases eq_or_ne b 0 with (rfl | hb); · simp\n  simp only [ord_proj_mul p ha hb]\n  rw [mul_div_mul_comm_of_dvd_dvd (ord_proj_dvd a p) (ord_proj_dvd b p)]\n#align ord_compl_mul ord_compl_mul\n\n",
 "ord_compl_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_compl_le (n p : ℕ) : «exprord_compl[ ] » p n ≤ n :=\n  nat.div_le_self _ _\n#align ord_compl_le ord_compl_le\n\n",
 "ord_compl_dvd_ord_compl_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_compl_dvd_ord_compl_of_dvd {a b : ℕ} (hab : a ∣ b) (p : ℕ) :\n    «exprord_compl[ ] » p a ∣ «exprord_compl[ ] » p b :=\n  by\n  rcases em' p.prime with (pp | pp); · simp [pp, hab]\n  rcases eq_or_ne b 0 with (rfl | hb0); · simp\n  rcases eq_or_ne a 0 with (rfl | ha0); · cases hb0 (zero_dvd_iff.1 hab)\n  have ha := (Nat.div_pos (ord_proj_le p ha0) (ord_proj_pos a p)).ne'\n  have hb := (Nat.div_pos (ord_proj_le p hb0) (ord_proj_pos b p)).ne'\n  rw [← factorization_le_iff_dvd ha hb, factorization_ord_compl a p, factorization_ord_compl b p]\n  intro q\n  rcases eq_or_ne q p with (rfl | hqp); · simp\n  simp_rw [erase_ne hqp]\n  exact (factorization_le_iff_dvd ha0 hb0).2 hab q\n#align ord_compl_dvd_ord_compl_of_dvd ord_compl_dvd_ord_compl_of_dvd\n\n",
 "ord_compl_dvd_ord_compl_iff_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_compl_dvd_ord_compl_iff_dvd (a b : ℕ) :\n    (∀ p : ℕ, «exprord_compl[ ] » p a ∣ «exprord_compl[ ] » p b) ↔ a ∣ b :=\n  by\n  refine' ⟨fun h => _, fun hab p => ord_compl_dvd_ord_compl_of_dvd hab p⟩\n  rcases eq_or_ne b 0 with (rfl | hb0); · simp\n  by_cases pa : a.prime; swap; · simpa [pa] using h a\n  by_cases pb : b.prime; swap; · simpa [pb] using h b\n  rw [prime_dvd_prime_iff_eq pa pb]\n  by_contra hab\n  apply pa.ne_one\n  rw [← Nat.dvd_one, ← Nat.mul_dvd_mul_iff_left hb0.bot_lt, mul_one]\n  simpa [prime.factorization_self pb, prime.factorization pa, hab] using h b\n#align ord_compl_dvd_ord_compl_iff_dvd ord_compl_dvd_ord_compl_iff_dvd\n\n",
 "ord_compl_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem ord_compl_dvd (n p : ℕ) : «exprord_compl[ ] » p n ∣ n :=\n  div_dvd_of_dvd (ord_proj_dvd n p)\n#align ord_compl_dvd ord_compl_dvd\n\n",
 "not_dvd_ord_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem not_dvd_ord_compl {n p : ℕ} (hp : Prime p) (hn : n ≠ 0) : ¬p ∣ «exprord_compl[ ] » p n :=\n  by\n  rw [nat.prime.dvd_iff_one_le_factorization hp (ord_compl_pos p hn).ne']\n  rw [nat.factorization_div (nat.ord_proj_dvd n p)]\n  simp [hp.factorization]\n#align not_dvd_ord_compl not_dvd_ord_compl\n\n",
 "multiplicity_eq_factorization":
 "theorem multiplicity_eq_factorization {n p : ℕ} (pp : p.prime) (hn : n ≠ 0) : multiplicity p n = n.factorization p := by\n  simp [factorization, pp, padic_val_nat_def' pp.ne_one hn.bot_lt]\n#align multiplicity_eq_factorization multiplicity_eq_factorization\n\n",
 "multiplicative_factorization'":
 "/-- For any multiplicative function `f` with `f 1 = 1` and `f 0 = 1`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` -/\ntheorem multiplicative_factorization' {β : Type _} [comm_monoid β] (f : ℕ → β)\n    (h_mult : ∀ x y : ℕ, coprime x y → f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) :\n    ∀ {n : ℕ}, f n = n.factorization.prod fun p k => f (p ^ k) :=\n  by\n  apply nat.rec_on_pos_prime_pos_coprime\n  · intro p k hp hk\n    simp only [hp.factorization_pow]\n    rw [prod_single_index _]\n    simp [hf1]\n  · simp [hf0]\n  · rw [factorization_one, hf1]\n    simp\n  · intro a b _ _ hab ha hb\n    rw [h_mult a b hab, ha, hb, factorization_mul_of_coprime hab, ← prod_add_index_of_disjoint]\n    convert factorization_disjoint_of_coprime hab\n#align multiplicative_factorization' multiplicative_factorization'\n\n",
 "multiplicative_factorization":
 "-- the awkward `let` stuff here is because `factorization` is noncomputable (finsupp);\n-- we get around this by using the computable `factors.count`, and rewriting when we want\n-- to use the `factorization` API\n/-- For any multiplicative function `f` with `f 1 = 1` and any `n ≠ 0`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` -/\ntheorem multiplicative_factorization {β : Type _} [comm_monoid β] (f : ℕ → β)\n    (h_mult : ∀ x y : ℕ, coprime x y → f (x * y) = f x * f y) (hf : f 1 = 1) :\n    ∀ {n : ℕ}, n ≠ 0 → f n = n.factorization.prod fun p k => f (p ^ k) :=\n  by\n  apply nat.rec_on_pos_prime_pos_coprime\n  · intro p k hp hk hpk\n    simp [prime.factorization_pow hp, finsupp.prod_single_index _, hf]\n  · simp\n  · rintro -\n    rw [factorization_one, hf]\n    simp\n  · intro a b _ _ hab ha hb hab_pos\n    rw [h_mult a b hab, ha (left_ne_zero_of_mul hab_pos), hb (right_ne_zero_of_mul hab_pos),\n      factorization_mul_of_coprime hab, ← prod_add_index_of_disjoint]\n    convert factorization_disjoint_of_coprime hab\n#align multiplicative_factorization multiplicative_factorization\n\n",
 "le_of_mem_factorization":
 "theorem le_of_mem_factorization {n p : ℕ} (h : p ∈ n.factorization.support) : p ≤ n :=\n  le_of_mem_factors (factor_iff_mem_factorization.mp h)\n#align le_of_mem_factorization le_of_mem_factorization\n\n",
 "factors_count_eq":
 "/-- We can write both `n.factorization p` and `n.factors.count p` to represent the power\nof `p` in the factorization of `n`: we declare the former to be the simp-normal form. -/\n@[simp]\ntheorem factors_count_eq {n p : ℕ} : n.factors.count p = n.factorization p :=\n  by\n  rcases n.eq_zero_or_pos with (rfl | hn0); · simp [factorization]\n  by_cases pp : p.prime; swap\n  · rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]\n    simp [factorization, pp]\n  simp only [factorization, coe_mk, pp, if_true]\n  rw [← part_enat.coe_inj, padic_val_nat_def' pp.ne_one hn0,\n    unique_factorization_monoid.multiplicity_eq_count_normalized_factors pp hn0.ne']\n  simp [factors_eq]\n#align factors_count_eq factors_count_eq\n\n",
 "factorization_zero_right":
 "@[simp]\ntheorem factorization_zero_right (n : ℕ) : n.factorization 0 = 0 :=\n  factorization_eq_zero_of_non_prime _ not_prime_zero\n#align factorization_zero_right factorization_zero_right\n\n",
 "factorization_zero":
 "@[simp]\ntheorem factorization_zero : factorization 0 = 0 := by simpa [factorization]\n#align factorization_zero factorization_zero\n\n",
 "factorization_self":
 "/-- The multiplicity of prime `p` in `p` is `1` -/\n@[simp]\ntheorem prime.factorization_self {p : ℕ} (hp : Prime p) : p.factorization p = 1 := by simp [hp]\n#align prime.factorization_self prime.factorization_self\n\n",
 "factorization_prod_pow_eq_self":
 "@[simp]\ntheorem factorization_prod_pow_eq_self {n : ℕ} (hn : n ≠ 0) : n.factorization.prod pow = n :=\n  by\n  rw [factorization_eq_factors_multiset n]\n  simp only [← prod_to_multiset, factorization, Multiset.coe_prod, multiset.to_finsupp_to_multiset]\n  exact prod_factors hn\n#align factorization_prod_pow_eq_self factorization_prod_pow_eq_self\n\n",
 "factorization_prod":
 "/-- For any `p : ℕ` and any function `g : α → ℕ` that's non-zero on `S : finset α`,\nthe power of `p` in `S.prod g` equals the sum over `x ∈ S` of the powers of `p` in `g x`.\nGeneralises `factorization_mul`, which is the special case where `S.card = 2` and `g = id`. -/\ntheorem factorization_prod {α : Type _} {S : Finset α} {g : α → ℕ} (hS : ∀ x ∈ S, g x ≠ 0) :\n    (S.prod g).factorization = S.sum fun x => (g x).factorization := by\n  classical\n    ext p\n    apply Finset.induction_on' S\n    · simp\n    · intro x T hxS hTS hxT IH\n      have hT : T.prod g ≠ 0 := prod_ne_zero_iff.mpr fun x hx => hS x (hTS hx)\n      simp [prod_insert hxT, sum_insert hxT, ← IH, factorization_mul (hS x hxS) hT]\n#align factorization_prod factorization_prod\n\n",
 "factorization_prime_le_iff_dvd":
 "theorem factorization_prime_le_iff_dvd {d n : ℕ} (hd : d ≠ 0) (hn : n ≠ 0) :\n    (∀ p : ℕ, p.prime → d.factorization p ≤ n.factorization p) ↔ d ∣ n :=\n  by\n  rw [← factorization_le_iff_dvd hd hn]\n  refine' ⟨fun h p => (em p.prime).elim (h p) fun hp => _, fun h p _ => h p⟩\n  simp_rw [factorization_eq_zero_of_non_prime _ hp]\n#align factorization_prime_le_iff_dvd factorization_prime_le_iff_dvd\n\n",
 "factorization_pow":
 "/-- For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` -/\ntheorem prime.factorization_pow {p k : ℕ} (hp : Prime p) : factorization (p ^ k) = single p k := by simp [hp]\n#align prime.factorization_pow prime.factorization_pow\n\n",
 "factorization_pos_of_dvd":
 "theorem prime.factorization_pos_of_dvd {n p : ℕ} (hp : p.prime) (hn : n ≠ 0) (h : p ∣ n) : 0 < n.factorization p := by\n  rwa [← factors_count_eq, count_pos, mem_factors_iff_dvd hn hp]\n#align prime.factorization_pos_of_dvd prime.factorization_pos_of_dvd\n\n",
 "factorization_ord_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem factorization_ord_compl (n p : ℕ) : («exprord_compl[ ] » p n).factorization = n.factorization.erase p :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn); · simp\n  by_cases pp : p.prime; swap; · simp [pp]\n  ext q\n  rcases eq_or_ne q p with (rfl | hqp)\n  · simp only [finsupp.erase_same, factorization_eq_zero_iff, not_dvd_ord_compl pp hn]\n    simp\n  · rw [finsupp.erase_ne hqp, factorization_div (ord_proj_dvd n p)]\n    simp [pp.factorization, hqp.symm]\n#align factorization_ord_compl factorization_ord_compl\n\n",
 "factorization_one_right":
 "@[simp]\ntheorem factorization_one_right (n : ℕ) : n.factorization 1 = 0 :=\n  factorization_eq_zero_of_non_prime _ not_prime_one\n#align factorization_one_right factorization_one_right\n\n",
 "factorization_one":
 "@[simp]\ntheorem factorization_one : factorization 1 = 0 := by simpa [factorization]\n#align factorization_one factorization_one\n\n",
 "factorization_mul_support_of_coprime":
 "/-- For coprime `a` and `b` the prime factorization `a * b` is the union of those of `a` and `b` -/\ntheorem factorization_mul_support_of_coprime {a b : ℕ} (hab : coprime a b) :\n    (a * b).factorization.support = a.factorization.support ∪ b.factorization.support :=\n  by\n  rw [factorization_mul_of_coprime hab]\n  exact support_add_eq (factorization_disjoint_of_coprime hab)\n#align factorization_mul_support_of_coprime factorization_mul_support_of_coprime\n\n",
 "factorization_mul_support":
 "theorem factorization_mul_support {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a * b).factorization.support = a.factorization.support ∪ b.factorization.support :=\n  by\n  ext q\n  simp only [Finset.mem_union, factor_iff_mem_factorization]\n  exact mem_factors_mul ha hb\n#align factorization_mul_support factorization_mul_support\n\n",
 "factorization_mul_of_coprime":
 "/-- For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\ntheorem factorization_mul_of_coprime {a b : ℕ} (hab : coprime a b) :\n    (a * b).factorization = a.factorization + b.factorization :=\n  by\n  ext q\n  simp only [finsupp.coe_add, add_apply, ← factors_count_eq, factorization_mul_apply_of_coprime hab]\n#align factorization_mul_of_coprime factorization_mul_of_coprime\n\n",
 "factorization_mul_apply_of_coprime":
 "/-- For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\ntheorem factorization_mul_apply_of_coprime {p a b : ℕ} (hab : coprime a b) :\n    (a * b).factorization p = a.factorization p + b.factorization p := by\n  simp only [← factors_count_eq, perm_iff_count.mp (perm_factors_mul_of_coprime hab), count_append]\n#align factorization_mul_apply_of_coprime factorization_mul_apply_of_coprime\n\n",
 "factorization_mul":
 "/-- For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\n@[simp]\ntheorem factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a * b).factorization = a.factorization + b.factorization :=\n  by\n  ext p\n  simp only [add_apply, ← factors_count_eq, perm_iff_count.mp (perm_factors_mul ha hb) p, count_append]\n#align factorization_mul factorization_mul\n\n",
 "factorization_lt":
 "/-- A crude upper bound on `n.factorization p` -/\ntheorem factorization_lt {n : ℕ} (p : ℕ) (hn : n ≠ 0) : n.factorization p < n :=\n  by\n  by_cases pp : p.prime; swap;\n  · simp [factorization_eq_zero_of_non_prime n pp]\n    exact hn.bot_lt\n  rw [← pow_lt_iff_lt_right pp.two_le]\n  apply lt_of_le_of_lt (ord_proj_le p hn)\n  exact lt_of_lt_of_le (lt_two_pow n) (pow_le_pow_of_le_left (by linarith) pp.two_le n)\n#align factorization_lt factorization_lt\n\n",
 "factorization_le_of_le_pow":
 "/-- An upper bound on `n.factorization p` -/\ntheorem factorization_le_of_le_pow {n p b : ℕ} (hb : n ≤ p ^ b) : n.factorization p ≤ b :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn); · simp\n  by_cases pp : p.prime\n  · exact (pow_le_iff_le_right pp.two_le).1 (le_trans (ord_proj_le p hn) hb)\n  · simp [factorization_eq_zero_of_non_prime n pp]\n#align factorization_le_of_le_pow factorization_le_of_le_pow\n\n",
 "factorization_le_iff_dvd":
 "theorem factorization_le_iff_dvd {d n : ℕ} (hd : d ≠ 0) (hn : n ≠ 0) : d.factorization ≤ n.factorization ↔ d ∣ n :=\n  by\n  constructor\n  · intro hdn\n    set K := n.factorization - d.factorization with hK\n    use K.prod pow\n    rw [← factorization_prod_pow_eq_self hn, ← factorization_prod_pow_eq_self hd, ←\n      finsupp.prod_add_index' pow_zero pow_add, hK, add_tsub_cancel_of_le hdn]\n  · rintro ⟨c, rfl⟩\n    rw [factorization_mul hd (right_ne_zero_of_mul hn)]\n    simp\n#align factorization_le_iff_dvd factorization_le_iff_dvd\n\n",
 "factorization_le_factorization_mul_right":
 "theorem factorization_le_factorization_mul_right {a b : ℕ} (ha : a ≠ 0) : b.factorization ≤ (a * b).factorization :=\n  by\n  rw [mul_comm]\n  apply factorization_le_factorization_mul_left ha\n#align factorization_le_factorization_mul_right factorization_le_factorization_mul_right\n\n",
 "factorization_le_factorization_mul_left":
 "theorem factorization_le_factorization_mul_left {a b : ℕ} (hb : b ≠ 0) : a.factorization ≤ (a * b).factorization :=\n  by\n  rcases eq_or_ne a 0 with (rfl | ha); · simp\n  rw [factorization_le_iff_dvd ha <| mul_ne_zero ha hb]\n  exact Dvd.intro b rfl\n#align factorization_le_factorization_mul_left factorization_le_factorization_mul_left\n\n",
 "factorization_lcm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem factorization_lcm {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a.lcm b).factorization = «expr ⊔ » a.factorization b.factorization :=\n  by\n  rw [← add_right_inj (a.gcd b).factorization, ←\n    factorization_mul (mt gcd_eq_zero_iff.1 fun h => ha h.1) (lcm_ne_zero ha hb), gcd_mul_lcm, factorization_gcd ha hb,\n    factorization_mul ha hb]\n  ext1; exact (min_add_max _ _).symm\n#align factorization_lcm factorization_lcm\n\n",
 "factorization_inj":
 "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem factorization_inj : Set.InjOn factorization { x : ℕ | x ≠ 0 } := fun a ha b hb h =>\n  eq_of_factorization_eq ha hb fun p => by simp [h]\n#align factorization_inj factorization_inj\n\n",
 "factorization_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem factorization_gcd {a b : ℕ} (ha_pos : a ≠ 0) (hb_pos : b ≠ 0) :\n    (gcd a b).factorization = «expr ⊓ » a.factorization b.factorization :=\n  by\n  let dfac := «expr ⊓ » a.factorization b.factorization\n  let d := dfac.prod pow\n  have dfac_prime : ∀ p : ℕ, p ∈ dfac.support → Prime p :=\n    by\n    intro p hp\n    have : p ∈ a.factors ∧ p ∈ b.factors := by simpa using hp\n    exact prime_of_mem_factors this.1\n  have h1 : d.factorization = dfac := prod_pow_factorization_eq_self dfac_prime\n  have hd_pos : d ≠ 0 := (factorization_equiv.inv_fun ⟨dfac, dfac_prime⟩).2.ne.symm\n  suffices d = gcd a b by rwa [← this]\n  apply gcd_greatest\n  · rw [← factorization_le_iff_dvd hd_pos ha_pos, h1]\n    exact inf_le_left\n  · rw [← factorization_le_iff_dvd hd_pos hb_pos, h1]\n    exact inf_le_right\n  · intro e hea heb\n    rcases decidable.eq_or_ne e 0 with (rfl | he_pos)\n    · simp only [zero_dvd_iff] at hea\n      contradiction\n    have hea' := (factorization_le_iff_dvd he_pos ha_pos).mpr hea\n    have heb' := (factorization_le_iff_dvd he_pos hb_pos).mpr heb\n    simp [← factorization_le_iff_dvd he_pos hd_pos, h1, hea', heb']\n#align factorization_gcd factorization_gcd\n\n",
 "factorization_equiv_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem factorization_equiv_inv_apply {f : «expr →₀ » ℕ ℕ} (hf : ∀ p ∈ f.support, Prime p) :\n    (factorization_equiv.symm ⟨f, hf⟩).1 = f.prod pow :=\n  rfl\n#align factorization_equiv_inv_apply factorization_equiv_inv_apply\n\n",
 "factorization_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem factorization_equiv_apply (n : «exprℕ+») : (factorization_equiv n).1 = n.1.factorization :=\n  by\n  cases n\n  rfl\n#align factorization_equiv_apply factorization_equiv_apply\n\n",
 "factorization_eq_zero_of_remainder":
 "theorem factorization_eq_zero_of_remainder {p r : ℕ} (i : ℕ) (hr : ¬p ∣ r) : (p * i + r).factorization p = 0 :=\n  by\n  apply factorization_eq_zero_of_not_dvd\n  rwa [← nat.dvd_add_iff_right (Dvd.intro i rfl)]\n#align factorization_eq_zero_of_remainder factorization_eq_zero_of_remainder\n\n",
 "factorization_eq_zero_of_not_dvd":
 "theorem factorization_eq_zero_of_not_dvd {n p : ℕ} (h : ¬p ∣ n) : n.factorization p = 0 := by\n  simp [factorization_eq_zero_iff, h]\n#align factorization_eq_zero_of_not_dvd factorization_eq_zero_of_not_dvd\n\n",
 "factorization_eq_zero_of_non_prime":
 "@[simp]\ntheorem factorization_eq_zero_of_non_prime (n : ℕ) {p : ℕ} (hp : ¬p.prime) : n.factorization p = 0 := by\n  simp [factorization_eq_zero_iff, hp]\n#align factorization_eq_zero_of_non_prime factorization_eq_zero_of_non_prime\n\n",
 "factorization_eq_zero_of_lt":
 "theorem factorization_eq_zero_of_lt {n p : ℕ} (h : n < p) : n.factorization p = 0 :=\n  finsupp.not_mem_support_iff.mp (mt le_of_mem_factorization (not_le_of_lt h))\n#align factorization_eq_zero_of_lt factorization_eq_zero_of_lt\n\n",
 "factorization_eq_zero_iff_remainder":
 "theorem factorization_eq_zero_iff_remainder {p r : ℕ} (i : ℕ) (pp : p.prime) (hr0 : r ≠ 0) :\n    ¬p ∣ r ↔ (p * i + r).factorization p = 0 :=\n  by\n  refine' ⟨factorization_eq_zero_of_remainder i, fun h => _⟩\n  rw [factorization_eq_zero_iff] at h\n  contrapose! h\n  refine' ⟨pp, _, _⟩\n  · rwa [← nat.dvd_add_iff_right (Dvd.intro i rfl)]\n  · contrapose! hr0\n    exact (_root_.add_eq_zero_iff.mp hr0).2\n#align factorization_eq_zero_iff_remainder factorization_eq_zero_iff_remainder\n\n",
 "factorization_eq_zero_iff'":
 "/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem factorization_eq_zero_iff' (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1 :=\n  by\n  rw [factorization_eq_factors_multiset n]\n  simp [factorization, AddEquiv.map_eq_zero_iff, Multiset.coe_eq_zero]\n#align factorization_eq_zero_iff' factorization_eq_zero_iff'\n\n",
 "factorization_eq_zero_iff":
 "theorem factorization_eq_zero_iff (n p : ℕ) : n.factorization p = 0 ↔ ¬p.prime ∨ ¬p ∣ n ∨ n = 0 :=\n  by\n  rw [← not_mem_support_iff, support_factorization, mem_to_finset]\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  · simp [hn, nat.mem_factors, not_and_or]\n#align factorization_eq_zero_iff factorization_eq_zero_iff\n\n",
 "factorization_eq_of_coprime_right":
 "/-- If `p` is a prime factor of `b` then the power of `p` in `b` is the same that in `a * b`,\nfor any `a` coprime to `b`. -/\ntheorem factorization_eq_of_coprime_right {p a b : ℕ} (hab : coprime a b) (hpb : p ∈ b.factors) :\n    (a * b).factorization p = b.factorization p := by\n  rw [mul_comm]\n  exact factorization_eq_of_coprime_left (coprime_comm.mp hab) hpb\n#align factorization_eq_of_coprime_right factorization_eq_of_coprime_right\n\n",
 "factorization_eq_of_coprime_left":
 "/-- If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\nfor any `b` coprime to `a`. -/\ntheorem factorization_eq_of_coprime_left {p a b : ℕ} (hab : coprime a b) (hpa : p ∈ a.factors) :\n    (a * b).factorization p = a.factorization p :=\n  by\n  rw [factorization_mul_apply_of_coprime hab, ← factors_count_eq, ← factors_count_eq]\n  simpa only [count_eq_zero_of_not_mem (coprime_factors_disjoint hab hpa)]\n#align factorization_eq_of_coprime_left factorization_eq_of_coprime_left\n\n",
 "factorization_eq_factors_multiset":
 "theorem factorization_eq_factors_multiset (n : ℕ) : n.factorization = (n.factors : Multiset ℕ).to_finsupp :=\n  by\n  ext p\n  simp\n#align factorization_eq_factors_multiset factorization_eq_factors_multiset\n\n",
 "factorization_eq_card_pow_dvd":
 "theorem factorization_eq_card_pow_dvd (n : ℕ) {p : ℕ} (pp : p.prime) :\n    n.factorization p = ((Ico 1 n).filter fun i => p ^ i ∣ n).card := by simp [← Icc_factorization_eq_pow_dvd n pp]\n#align factorization_eq_card_pow_dvd factorization_eq_card_pow_dvd\n\n",
 "factorization_div":
 "@[simp]\ntheorem factorization_div {d n : ℕ} (h : d ∣ n) : (n / d).factorization = n.factorization - d.factorization :=\n  by\n  rcases eq_or_ne d 0 with (rfl | hd); · simp [zero_dvd_iff.mp h]\n  rcases eq_or_ne n 0 with (rfl | hn); · simp\n  apply add_left_injective d.factorization\n  simp only\n  rw [tsub_add_cancel_of_le <| (nat.factorization_le_iff_dvd hd hn).mpr h, ←\n    nat.factorization_mul (Nat.div_pos (nat.le_of_dvd hn.bot_lt h) hd.bot_lt).ne' hd, Nat.div_mul_cancel h]\n#align factorization_div factorization_div\n\n",
 "factorization_disjoint_of_coprime":
 "/-- The prime factorizations of coprime `a` and `b` are disjoint -/\ntheorem factorization_disjoint_of_coprime {a b : ℕ} (hab : coprime a b) :\n    Disjoint a.factorization.support b.factorization.support := by\n  simpa only [support_factorization] using disjoint_to_finset_iff_disjoint.mpr (coprime_factors_disjoint hab)\n#align factorization_disjoint_of_coprime factorization_disjoint_of_coprime\n\n",
 "factorization_def":
 "/-\nCopyright (c) 2021 Stuart Presnell. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Stuart Presnell\n-/\ntheorem factorization_def (n : ℕ) {p : ℕ} (pp : p.prime) : n.factorization p = padic_val_nat p n := by\n  simpa [factorization] using absurd pp\n#align factorization_def factorization_def\n\n",
 "factorization":
 "/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/\n@[simp]\ntheorem prime.factorization {p : ℕ} (hp : Prime p) : p.factorization = single p 1 :=\n  by\n  ext q\n  rw [← factors_count_eq, factors_prime hp, single_apply, count_singleton', if_congr eq_comm] <;> rfl\n#align prime.factorization prime.factorization\n\n",
 "factor_iff_mem_factorization":
 "theorem factor_iff_mem_factorization {n p : ℕ} : p ∈ n.factorization.support ↔ p ∈ n.factors := by\n  simp only [support_factorization, List.mem_toFinset]\n#align factor_iff_mem_factorization factor_iff_mem_factorization\n\n",
 "exists_factorization_lt_of_lt":
 "theorem exists_factorization_lt_of_lt {a b : ℕ} (ha : a ≠ 0) (hab : a < b) :\n    ∃ p : ℕ, a.factorization p < b.factorization p :=\n  by\n  have hb : b ≠ 0 := (ha.bot_lt.trans hab).ne'\n  contrapose! hab\n  rw [← finsupp.le_def, factorization_le_iff_dvd hb ha] at hab\n  exact le_of_dvd ha.bot_lt hab\n#align exists_factorization_lt_of_lt exists_factorization_lt_of_lt\n\n",
 "exists_eq_pow_mul_and_not_dvd":
 "/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem exists_eq_pow_mul_and_not_dvd {n : ℕ} (hn : n ≠ 0) (p : ℕ) (hp : p ≠ 1) :\n    ∃ e n' : ℕ, ¬p ∣ n' ∧ n = p ^ e * n' :=\n  let ⟨a', h₁, h₂⟩ :=\n    multiplicity.exists_eq_pow_mul_and_not_dvd (multiplicity.finite_nat_iff.mpr ⟨hp, nat.pos_of_ne_zero hn⟩)\n  ⟨_, a', h₂, h₁⟩\n#align exists_eq_pow_mul_and_not_dvd exists_eq_pow_mul_and_not_dvd\n\n",
 "eq_pow_of_factorization_eq_single":
 "/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem eq_pow_of_factorization_eq_single {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) :\n    n = p ^ k := by\n  rw [← nat.factorization_prod_pow_eq_self hn, h]\n  simp\n#align eq_pow_of_factorization_eq_single eq_pow_of_factorization_eq_single\n\n",
 "eq_of_factorization_pos":
 "/-- The only prime factor of prime `p` is `p` itself. -/\ntheorem prime.eq_of_factorization_pos {p q : ℕ} (hp : Prime p) (h : p.factorization q ≠ 0) : p = q := by\n  simpa [hp.factorization, single_apply] using h\n#align prime.eq_of_factorization_pos prime.eq_of_factorization_pos\n\n",
 "eq_of_factorization_eq":
 "theorem eq_of_factorization_eq {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : ∀ p : ℕ, a.factorization p = b.factorization p) : a = b :=\n  eq_of_perm_factors ha hb (by simpa only [List.perm_iff_count, factors_count_eq] using h)\n#align eq_of_factorization_eq eq_of_factorization_eq\n\n",
 "eq_iff_prime_padic_val_nat_eq":
 "/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem eq_iff_prime_padic_val_nat_eq (a b : ℕ) (ha : a ≠ 0) (hb : b ≠ 0) :\n    a = b ↔ ∀ p : ℕ, p.prime → padic_val_nat p a = padic_val_nat p b :=\n  by\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    refine' eq_of_factorization_eq ha hb fun p => _\n    by_cases pp : p.prime\n    · simp [factorization_def, pp, h p pp]\n    · simp [factorization_eq_zero_of_non_prime, pp]\n#align eq_iff_prime_padic_val_nat_eq eq_iff_prime_padic_val_nat_eq\n\n",
 "eq_factorization_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem eq_factorization_iff {n : ℕ} {f : «expr →₀ » ℕ ℕ} (hn : n ≠ 0) (hf : ∀ p ∈ f.support, Prime p) :\n    f = n.factorization ↔ f.prod pow = n :=\n  ⟨fun h => by rw [h, factorization_prod_pow_eq_self hn], fun h => by rw [← h, prod_pow_factorization_eq_self hf]⟩\n#align eq_factorization_iff eq_factorization_iff\n\n",
 "dvd_ord_proj_of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_proj[ ] » -/\ntheorem dvd_ord_proj_of_dvd {n p : ℕ} (hn : n ≠ 0) (pp : p.prime) (h : p ∣ n) : p ∣ «exprord_proj[ ] » p n :=\n  dvd_pow_self p (prime.factorization_pos_of_dvd pp hn h).ne'\n#align dvd_ord_proj_of_dvd dvd_ord_proj_of_dvd\n\n",
 "dvd_ord_compl_of_dvd_not_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\n-- `ord_compl[p] n` is the largest divisor of `n` not divisible by `p`.\ntheorem dvd_ord_compl_of_dvd_not_dvd {p d n : ℕ} (hdn : d ∣ n) (hpd : ¬p ∣ d) : d ∣ «exprord_compl[ ] » p n :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn0); · simp\n  rcases eq_or_ne d 0 with (rfl | hd0);\n  · simp at hpd\n    cases hpd\n  rw [← factorization_le_iff_dvd hd0 (ord_compl_pos p hn0).ne', factorization_ord_compl]\n  intro q\n  rcases eq_or_ne q p with (rfl | hqp)\n  · simp [factorization_eq_zero_iff, hpd]\n  · simp [hqp, (factorization_le_iff_dvd hd0 hn0).2 hdn q]\n#align dvd_ord_compl_of_dvd_not_dvd dvd_ord_compl_of_dvd_not_dvd\n\n",
 "dvd_of_mem_factorization":
 "theorem dvd_of_mem_factorization {n p : ℕ} (h : p ∈ n.factorization.support) : p ∣ n :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn); · simp\n  simp [← mem_factors_iff_dvd hn (prime_of_mem_factorization h), factor_iff_mem_factorization.mp h]\n#align dvd_of_mem_factorization dvd_of_mem_factorization\n\n",
 "dvd_of_factorization_pos":
 "theorem dvd_of_factorization_pos {n p : ℕ} (hn : n.factorization p ≠ 0) : p ∣ n :=\n  dvd_of_mem_factors (factor_iff_mem_factorization.1 (mem_support_iff.2 hn))\n#align dvd_of_factorization_pos dvd_of_factorization_pos\n\n",
 "dvd_iff_prime_pow_dvd_dvd":
 "theorem dvd_iff_prime_pow_dvd_dvd (n d : ℕ) : d ∣ n ↔ ∀ p k : ℕ, Prime p → p ^ k ∣ d → p ^ k ∣ n :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn); · simp\n  rcases eq_or_ne d 0 with (rfl | hd)\n  · simp only [zero_dvd_iff, hn, false_iff_iff, not_forall]\n    exact ⟨2, n, prime_two, dvd_zero _, mt (le_of_dvd hn.bot_lt) (lt_two_pow n).not_le⟩\n  refine' ⟨fun h p k _ hpkd => dvd_trans hpkd h, _⟩\n  rw [← factorization_prime_le_iff_dvd hd hn]\n  intro h p pp\n  simp_rw [← pp.pow_dvd_iff_le_factorization hn]\n  exact h p _ pp (ord_proj_dvd _ _)\n#align dvd_iff_prime_pow_dvd_dvd dvd_iff_prime_pow_dvd_dvd\n\n",
 "dvd_iff_one_le_factorization":
 "theorem prime.dvd_iff_one_le_factorization {p n : ℕ} (pp : Prime p) (hn : n ≠ 0) : p ∣ n ↔ 1 ≤ n.factorization p :=\n  iff.trans (by simp) (pp.pow_dvd_iff_le_factorization hn)\n#align prime.dvd_iff_one_le_factorization prime.dvd_iff_one_le_factorization\n\n",
 "dvd_iff_div_factorization_eq_tsub":
 "theorem dvd_iff_div_factorization_eq_tsub {d n : ℕ} (hd : d ≠ 0) (hdn : d ≤ n) :\n    d ∣ n ↔ (n / d).factorization = n.factorization - d.factorization :=\n  by\n  refine' ⟨factorization_div, _⟩\n  rcases eq_or_lt_of_le hdn with (rfl | hd_lt_n); · simp\n  have h1 : n / d ≠ 0 := fun H => nat.lt_asymm hd_lt_n ((Nat.div_eq_zero_iff hd.bot_lt).mp H)\n  intro h\n  rw [dvd_iff_le_div_mul n d]\n  by_contra h2\n  cases' exists_factorization_lt_of_lt (mul_ne_zero h1 hd) (not_le.mp h2) with p hp\n  rwa [factorization_mul h1 hd, add_apply, ← lt_tsub_iff_right, h, tsub_apply, lt_self_iff_false] at hp\n#align dvd_iff_div_factorization_eq_tsub dvd_iff_div_factorization_eq_tsub\n\n",
 "coprime_ord_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprord_compl[ ] » -/\ntheorem coprime_ord_compl {n p : ℕ} (hp : Prime p) (hn : n ≠ 0) : coprime p («exprord_compl[ ] » p n) :=\n  (or_iff_left (not_dvd_ord_compl hp hn)).mp <| coprime_or_dvd_of_prime hp _\n#align coprime_ord_compl coprime_ord_compl\n\n",
 "card_multiples":
 "-- TODO: Port lemmas from `data/nat/multiplicity` to here, re-written in terms of `factorization`\n/-- Exactly `n / p` naturals in `[1, n]` are multiples of `p`. -/\ntheorem card_multiples (n p : ℕ) : card ((Finset.range n).filter fun e => p ∣ e + 1) = n / p :=\n  by\n  induction' n with n hn; · simp\n  simp [Nat.succ_div, add_ite, add_zero, Finset.range_succ, filter_insert, apply_ite card, card_insert_of_not_mem, hn]\n#align card_multiples card_multiples\n\n",
 "Ioc_filter_dvd_card_eq_div":
 "/-- Exactly `n / p` naturals in `(0, n]` are multiples of `p`. -/\ntheorem Ioc_filter_dvd_card_eq_div (n p : ℕ) : ((Ioc 0 n).filter fun x => p ∣ x).card = n / p :=\n  by\n  induction' n with n IH\n  · simp\n  -- TODO: Golf away `h1` after Yaël PRs a lemma asserting this\n  have h1 : Ioc 0 n.succ = insert n.succ (Ioc 0 n) :=\n    by\n    rcases n.eq_zero_or_pos with (rfl | hn)\n    · simp\n    simp_rw [← Ico_succ_succ, Ico_insert_right (succ_le_succ hn.le), Ico_succ_right]\n  simp [Nat.succ_div, add_ite, add_zero, h1, filter_insert, apply_ite card, card_insert_eq_ite, IH, Finset.mem_filter,\n    mem_Ioc, not_le.2 (lt_add_one n)]\n#align Ioc_filter_dvd_card_eq_div Ioc_filter_dvd_card_eq_div\n\n",
 "Ico_filter_pow_dvd_eq":
 "theorem Ico_filter_pow_dvd_eq {n p b : ℕ} (pp : p.prime) (hn : n ≠ 0) (hb : n ≤ p ^ b) :\n    ((Ico 1 n).filter fun i => p ^ i ∣ n) = (Icc 1 b).filter fun i => p ^ i ∣ n :=\n  by\n  ext x\n  simp only [Finset.mem_filter, mem_Ico, mem_Icc, and_congr_left_iff, and_congr_right_iff]\n  rintro h1 -\n  simp [lt_of_pow_dvd_right hn pp.two_le h1, (pow_le_iff_le_right pp.two_le).1 ((le_of_dvd hn.bot_lt h1).trans hb)]\n#align Ico_filter_pow_dvd_eq Ico_filter_pow_dvd_eq\n\n",
 "Icc_factorization_eq_pow_dvd":
 "/-- The set of positive powers of prime `p` that divide `n` is exactly the set of\npositive natural numbers up to `n.factorization p`. -/\ntheorem Icc_factorization_eq_pow_dvd (n : ℕ) {p : ℕ} (pp : Prime p) :\n    Icc 1 (n.factorization p) = (Ico 1 n).filter fun i : ℕ => p ^ i ∣ n :=\n  by\n  rcases eq_or_ne n 0 with (rfl | hn); · simp\n  ext x\n  simp only [mem_Icc, Finset.mem_filter, mem_Ico, and_assoc', and_congr_right_iff, pp.pow_dvd_iff_le_factorization hn,\n    iff_and_self]\n  exact fun H1 H2 => lt_of_le_of_lt H2 (factorization_lt p hn)\n#align Icc_factorization_eq_pow_dvd Icc_factorization_eq_pow_dvd\n\n"}