{"zero_desc_factorial_succ":
 "theorem zero_desc_factorial_succ (k : ℕ) : (0 : ℕ).desc_factorial k.succ = 0 := by\n  rw [desc_factorial_succ, zero_tsub, zero_mul]\n#align zero_desc_factorial_succ zero_desc_factorial_succ\n\n",
 "zero_asc_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n@[simp]\ntheorem zero_asc_factorial (k : ℕ) : (0 : ℕ).asc_factorial k = nat.factorial k :=\n  by\n  induction' k with t ht\n  · rfl\n  rw [asc_factorial, ht, zero_add, Nat.factorial_succ]\n#align zero_asc_factorial zero_asc_factorial\n\n",
 "succ_desc_factorial_succ":
 "@[simp]\ntheorem succ_desc_factorial_succ (n : ℕ) : ∀ k : ℕ, (n + 1).desc_factorial (k + 1) = (n + 1) * n.desc_factorial k\n  | 0 => by rw [desc_factorial_zero, desc_factorial_one, mul_one]\n  | succ k => by rw [desc_factorial_succ, succ_desc_factorial_succ, desc_factorial_succ, succ_sub_succ, mul_left_comm]\n#align succ_desc_factorial_succ succ_desc_factorial_succ\n\n",
 "succ_desc_factorial":
 "theorem succ_desc_factorial (n : ℕ) : ∀ k, (n + 1 - k) * (n + 1).desc_factorial k = (n + 1) * n.desc_factorial k\n  | 0 => by rw [tsub_zero, desc_factorial_zero, desc_factorial_zero]\n  | k + 1 => by rw [desc_factorial, succ_desc_factorial, desc_factorial_succ, succ_sub_succ, mul_left_comm]\n#align succ_desc_factorial succ_desc_factorial\n\n",
 "succ_asc_factorial":
 "theorem succ_asc_factorial (n : ℕ) : ∀ k, (n + 1) * n.succ.asc_factorial k = (n + k + 1) * n.asc_factorial k\n  | 0 => by rw [add_zero, asc_factorial_zero, asc_factorial_zero]\n  | k + 1 => by rw [asc_factorial, mul_left_comm, succ_asc_factorial, asc_factorial, succ_add, ← add_assoc]\n#align succ_asc_factorial succ_asc_factorial\n\n",
 "self_le_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem self_le_factorial : ∀ n : ℕ, n ≤ nat.factorial n\n  | 0 => zero_le_one\n  | k + 1 => le_mul_of_one_le_right k.zero_lt_succ.le (Nat.one_le_of_lt <| Nat.factorial_pos _)\n#align self_le_factorial self_le_factorial\n\n",
 "pow_succ_le_asc_factorial":
 "theorem pow_succ_le_asc_factorial (n : ℕ) : ∀ k : ℕ, (n + 1) ^ k ≤ n.asc_factorial k\n  | 0 => by rw [asc_factorial_zero, pow_zero]\n  | k + 1 => by\n    rw [pow_succ]\n    exact nat.mul_le_mul (nat.add_le_add_right le_self_add _) (pow_succ_le_asc_factorial k)\n#align pow_succ_le_asc_factorial pow_succ_le_asc_factorial\n\n",
 "pow_sub_lt_desc_factorial'":
 "theorem pow_sub_lt_desc_factorial' {n : ℕ} : ∀ {k : ℕ}, k + 2 ≤ n → (n - (k + 1)) ^ (k + 2) < n.desc_factorial (k + 2)\n  | 0 => fun h => by\n    rw [desc_factorial_succ, pow_succ, pow_one, desc_factorial_one]\n    exact nat.mul_lt_mul_of_pos_left (tsub_lt_self (lt_of_lt_of_le zero_lt_two h) zero_lt_one) (tsub_pos_of_lt h)\n  | k + 1 => fun h => by\n    rw [desc_factorial_succ, pow_succ]\n    refine'\n      nat.mul_lt_mul_of_pos_left ((Nat.pow_le_pow_of_le_left (tsub_le_tsub_right (le_succ n) _) _).trans_lt _)\n        (tsub_pos_of_lt h)\n    rw [succ_sub_succ]\n    exact pow_sub_lt_desc_factorial' ((le_succ _).trans h)\n#align pow_sub_lt_desc_factorial' pow_sub_lt_desc_factorial'\n\n",
 "pow_sub_lt_desc_factorial":
 "theorem pow_sub_lt_desc_factorial {n : ℕ} : ∀ {k : ℕ}, 2 ≤ k → k ≤ n → (n + 1 - k) ^ k < n.desc_factorial k\n  | 0 => by rintro ⟨⟩\n  | 1 => by rintro (_ | ⟨⟨⟩⟩)\n  | k + 2 => fun _ h => by\n    rw [succ_sub_succ]\n    exact pow_sub_lt_desc_factorial' h\n#align pow_sub_lt_desc_factorial pow_sub_lt_desc_factorial\n\n",
 "pow_sub_le_desc_factorial":
 "theorem pow_sub_le_desc_factorial (n : ℕ) : ∀ k : ℕ, (n + 1 - k) ^ k ≤ n.desc_factorial k\n  | 0 => by rw [desc_factorial_zero, pow_zero]\n  | k + 1 => by\n    rw [desc_factorial_succ, pow_succ, succ_sub_succ]\n    exact\n      nat.mul_le_mul_of_nonneg_left\n        (le_trans (Nat.pow_le_pow_of_le_left (tsub_le_tsub_right (le_succ _) _) k) (pow_sub_le_desc_factorial k))\n#align pow_sub_le_desc_factorial pow_sub_le_desc_factorial\n\n",
 "pow_lt_asc_factorial'":
 "theorem pow_lt_asc_factorial' (n k : ℕ) : (n + 1) ^ (k + 2) < n.asc_factorial (k + 2) :=\n  by\n  rw [pow_succ]\n  exact\n    Nat.mul_lt_mul (nat.add_lt_add_right (nat.lt_add_of_pos_right succ_pos') 1) (pow_succ_le_asc_factorial n _)\n      (pow_pos succ_pos' _)\n#align pow_lt_asc_factorial' pow_lt_asc_factorial'\n\n",
 "pow_lt_asc_factorial":
 "theorem pow_lt_asc_factorial (n : ℕ) : ∀ {k : ℕ}, 2 ≤ k → (n + 1) ^ k < n.asc_factorial k\n  | 0 => by rintro ⟨⟩\n  | 1 => by rintro (_ | ⟨⟨⟩⟩)\n  | k + 2 => fun _ => pow_lt_asc_factorial' n k\n#align pow_lt_asc_factorial pow_lt_asc_factorial\n\n",
 "one_lt_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem one_lt_factorial : 1 < nat.factorial n ↔ 1 < n :=\n  factorial_lt one_pos\n#align one_lt_factorial one_lt_factorial\n\n",
 "mul_factorial_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem mul_factorial_pred (hn : 0 < n) : n * nat.factorial (n - 1) = nat.factorial n :=\n  tsub_add_cancel_of_le (nat.succ_le_of_lt hn) ▸ rfl\n#align mul_factorial_pred mul_factorial_pred\n\n",
 "monotone_factorial":
 "theorem monotone_factorial : monotone factorial := fun n m => factorial_le\n#align monotone_factorial monotone_factorial\n\n",
 "lt_factorial_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem lt_factorial_self {n : ℕ} (hi : 3 ≤ n) : n < nat.factorial n :=\n  by\n  rw [← succ_pred_eq_of_pos ((zero_lt_two.trans (lt.base 2)).trans_le hi), factorial_succ]\n  exact\n    lt_mul_of_one_lt_right (pred n).succ_pos\n      ((one_lt_two.trans_le (le_pred_of_lt (succ_le_iff.mp hi))).trans_le (self_le_factorial _))\n#align lt_factorial_self lt_factorial_self\n\n",
 "factorial_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Chris Hughes, Floris van Doorn, Yaël Dillies\n-/\n@[simp]\ntheorem factorial_zero : nat.factorial 0 = 1 :=\n  rfl\n#align factorial_zero factorial_zero\n\n",
 "factorial_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n@[simp]\ntheorem factorial_two : nat.factorial 2 = 2 :=\n  rfl\n#align factorial_two factorial_two\n\n",
 "factorial_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n@[simp]\ntheorem factorial_succ (n : ℕ) : nat.factorial n.succ = (n + 1) * nat.factorial n :=\n  rfl\n#align factorial_succ factorial_succ\n\n",
 "factorial_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_pos : ∀ n, 0 < nat.factorial n\n  | 0 => zero_lt_one\n  | succ n => mul_pos (succ_pos _) (factorial_pos n)\n#align factorial_pos factorial_pos\n\n",
 "factorial_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n@[simp]\ntheorem factorial_one : nat.factorial 1 = 1 :=\n  rfl\n#align factorial_one factorial_one\n\n",
 "factorial_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_ne_zero (n : ℕ) : nat.factorial n ≠ 0 :=\n  ne_of_gt (factorial_pos _)\n#align factorial_ne_zero factorial_ne_zero\n\n",
 "factorial_mul_pow_sub_le_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_mul_pow_sub_le_factorial {n m : ℕ} (hnm : n ≤ m) : nat.factorial n * n ^ (m - n) ≤ nat.factorial m :=\n  by\n  suffices nat.factorial n * (n + 1) ^ (m - n) ≤ nat.factorial m\n    by\n    apply trans _ this\n    rw [mul_le_mul_left]\n    apply pow_le_pow_of_le_left (zero_le n) (le_succ n)\n    exact factorial_pos n\n  convert Nat.factorial_mul_pow_le_factorial\n  exact (add_tsub_cancel_of_le hnm).symm\n#align factorial_mul_pow_sub_le_factorial factorial_mul_pow_sub_le_factorial\n\n",
 "factorial_mul_pow_le_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_mul_pow_le_factorial : ∀ {m n : ℕ}, nat.factorial m * m.succ ^ n ≤ nat.factorial (m + n)\n  | m, 0 => by simp\n  | m, n + 1 => by\n    rw [← add_assoc, Nat.factorial_succ, mul_comm (nat.succ _), pow_succ', ← mul_assoc] <;>\n      exact\n        mul_le_mul factorial_mul_pow_le_factorial (nat.succ_le_succ (nat.le_add_right _ _)) (nat.zero_le _)\n          (nat.zero_le _)\n#align factorial_mul_pow_le_factorial factorial_mul_pow_le_factorial\n\n",
 "factorial_mul_desc_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- `n.desc_factorial k = n! / (n - k)!` but without ℕ-division. See `nat.desc_factorial_eq_div`\nfor the version using ℕ-division. -/\ntheorem factorial_mul_desc_factorial : ∀ {n k : ℕ}, k ≤ n → nat.factorial (n - k) * n.desc_factorial k = nat.factorial n\n  | n, 0 => fun _ => by rw [desc_factorial_zero, mul_one, tsub_zero]\n  | 0, succ k => fun h => by\n    exfalso\n    exact not_succ_le_zero k h\n  | succ n, succ k => fun h => by\n    rw [succ_desc_factorial_succ, succ_sub_succ, ← mul_assoc, mul_comm (nat.factorial (n - k)), mul_assoc,\n      factorial_mul_desc_factorial (nat.succ_le_succ_iff.1 h), factorial_succ]\n#align factorial_mul_desc_factorial factorial_mul_desc_factorial\n\n",
 "factorial_mul_asc_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- `n.asc_factorial k = (n + k)! / n!` but without ℕ-division. See `nat.asc_factorial_eq_div` for\nthe version with ℕ-division. -/\ntheorem factorial_mul_asc_factorial (n : ℕ) : ∀ k, nat.factorial n * n.asc_factorial k = nat.factorial (n + k)\n  | 0 => by rw [asc_factorial, add_zero, mul_one]\n  | k + 1 => by rw [asc_factorial_succ, mul_left_comm, factorial_mul_asc_factorial, ← add_assoc, factorial]\n#align factorial_mul_asc_factorial factorial_mul_asc_factorial\n\n",
 "factorial_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_lt (hn : 0 < n) : nat.factorial n < nat.factorial m ↔ n < m :=\n  by\n  refine' ⟨fun h => not_le.mp fun hmn => not_le_of_lt h (factorial_le hmn), fun h => _⟩\n  have : ∀ {n}, 0 < n → nat.factorial n < nat.factorial n.succ :=\n    by\n    intro k hk\n    rw [factorial_succ, succ_mul, lt_add_iff_pos_left]\n    exact mul_pos hk k.factorial_pos\n  induction' h with k hnk ih generalizing hn\n  · exact this hn\n  · exact (ih hn).trans (this <| hn.trans <| lt_of_succ_le hnk)\n#align factorial_lt factorial_lt\n\n",
 "factorial_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n@[mono]\ntheorem factorial_le {m n} (h : m ≤ n) : nat.factorial m ≤ nat.factorial n :=\n  le_of_dvd (factorial_pos _) (factorial_dvd_factorial h)\n#align factorial_le factorial_le\n\n",
 "factorial_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_inj (hn : 1 < nat.factorial n) : nat.factorial n = nat.factorial m ↔ n = m :=\n  by\n  refine' ⟨fun h => _, congr_arg _⟩\n  obtain hnm | rfl | hnm := lt_trichotomy n m\n  · rw [← factorial_lt <| pos_of_gt <| one_lt_factorial.mp hn, h] at hnm\n    cases lt_irrefl _ hnm\n  · rfl\n  rw [h, one_lt_factorial] at hn\n  rw [← factorial_lt (lt_trans one_pos hn), h] at hnm\n  cases lt_irrefl _ hnm\n#align factorial_inj factorial_inj\n\n",
 "factorial_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_eq_one : nat.factorial n = 1 ↔ n ≤ 1 :=\n  by\n  refine' ⟨fun h => _, by rintro (_ | _ | _) <;> rfl⟩\n  rw [← not_lt, ← one_lt_factorial, h]\n  apply lt_irrefl\n#align factorial_eq_one factorial_eq_one\n\n",
 "factorial_dvd_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem factorial_dvd_factorial {m n} (h : m ≤ n) : nat.factorial m ∣ nat.factorial n :=\n  by\n  induction' n with n IH\n  · simp [nat.eq_zero_of_le_zero h]\n  obtain rfl | hl := h.eq_or_lt\n  · simp\n  exact (IH (le_of_lt_succ hl)).mul_left _\n#align factorial_dvd_factorial factorial_dvd_factorial\n\n",
 "dvd_factorial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem dvd_factorial : ∀ {m n}, 0 < m → m ≤ n → m ∣ nat.factorial n\n  | succ m, n, _, h => dvd_of_mul_right_dvd (factorial_dvd_factorial h)\n#align dvd_factorial dvd_factorial\n\n",
 "desc_factorial_zero":
 "@[simp]\ntheorem desc_factorial_zero (n : ℕ) : n.desc_factorial 0 = 1 :=\n  rfl\n#align desc_factorial_zero desc_factorial_zero\n\n",
 "desc_factorial_succ":
 "@[simp]\ntheorem desc_factorial_succ (n k : ℕ) : n.desc_factorial k.succ = (n - k) * n.desc_factorial k :=\n  rfl\n#align desc_factorial_succ desc_factorial_succ\n\n",
 "desc_factorial_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem desc_factorial_self : ∀ n : ℕ, n.desc_factorial n = nat.factorial n\n  | 0 => by rw [desc_factorial_zero, factorial_zero]\n  | succ n => by rw [succ_desc_factorial_succ, desc_factorial_self, factorial_succ]\n#align desc_factorial_self desc_factorial_self\n\n",
 "desc_factorial_one":
 "@[simp]\ntheorem desc_factorial_one (n : ℕ) : n.desc_factorial 1 = n := by\n  rw [desc_factorial_succ, desc_factorial_zero, mul_one, tsub_zero]\n#align desc_factorial_one desc_factorial_one\n\n",
 "desc_factorial_lt_pow":
 "theorem desc_factorial_lt_pow {n : ℕ} (hn : 1 ≤ n) : ∀ {k : ℕ}, 2 ≤ k → n.desc_factorial k < n ^ k\n  | 0 => by rintro ⟨⟩\n  | 1 => by rintro (_ | ⟨⟨⟩⟩)\n  | k + 2 => fun _ => by\n    rw [desc_factorial_succ, pow_succ', mul_comm]\n    exact Nat.mul_lt_mul' (desc_factorial_le_pow _ _) (tsub_lt_self hn k.zero_lt_succ) (pow_pos hn _)\n#align desc_factorial_lt_pow desc_factorial_lt_pow\n\n",
 "desc_factorial_le_pow":
 "theorem desc_factorial_le_pow (n : ℕ) : ∀ k : ℕ, n.desc_factorial k ≤ n ^ k\n  | 0 => by rw [desc_factorial_zero, pow_zero]\n  | k + 1 => by\n    rw [desc_factorial_succ, pow_succ]\n    exact nat.mul_le_mul (nat.sub_le _ _) (desc_factorial_le_pow k)\n#align desc_factorial_le_pow desc_factorial_le_pow\n\n",
 "desc_factorial_eq_zero_iff_lt":
 "@[simp]\ntheorem desc_factorial_eq_zero_iff_lt {n : ℕ} : ∀ {k : ℕ}, n.desc_factorial k = 0 ↔ n < k\n  | 0 => by simp only [desc_factorial_zero, nat.one_ne_zero, nat.not_lt_zero]\n  | succ k =>\n    by\n    rw [desc_factorial_succ, mul_eq_zero, desc_factorial_eq_zero_iff_lt, lt_succ_iff, tsub_eq_zero_iff_le,\n      lt_iff_le_and_ne, or_iff_left_iff_imp, and_imp]\n    exact fun h _ => h\n#align desc_factorial_eq_zero_iff_lt desc_factorial_eq_zero_iff_lt\n\n",
 "desc_factorial_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- Avoid in favor of `nat.factorial_mul_desc_factorial` if you can. ℕ-division isn't worth it. -/\ntheorem desc_factorial_eq_div {n k : ℕ} (h : k ≤ n) : n.desc_factorial k = nat.factorial n / nat.factorial (n - k) :=\n  by\n  apply mul_left_cancel₀ (factorial_ne_zero (n - k))\n  rw [factorial_mul_desc_factorial h]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| nat.sub_le n k).symm\n#align desc_factorial_eq_div desc_factorial_eq_div\n\n",
 "asc_factorial_zero":
 "@[simp]\ntheorem asc_factorial_zero (n : ℕ) : n.asc_factorial 0 = 1 :=\n  rfl\n#align asc_factorial_zero asc_factorial_zero\n\n",
 "asc_factorial_succ":
 "theorem asc_factorial_succ {n k : ℕ} : n.asc_factorial k.succ = (n + k + 1) * n.asc_factorial k :=\n  rfl\n#align asc_factorial_succ asc_factorial_succ\n\n",
 "asc_factorial_pos":
 "theorem asc_factorial_pos (n k : ℕ) : 0 < n.asc_factorial k :=\n  (pow_pos (succ_pos n) k).trans_le (pow_succ_le_asc_factorial n k)\n#align asc_factorial_pos asc_factorial_pos\n\n",
 "asc_factorial_of_sub":
 "theorem asc_factorial_of_sub {n k : ℕ} (h : k < n) :\n    (n - k) * (n - k).asc_factorial k = (n - (k + 1)).asc_factorial (k + 1) :=\n  by\n  set t := n - k.succ with ht\n  suffices h' : n - k = t.succ; · rw [← ht, h', succ_asc_factorial, asc_factorial_succ]\n  rw [ht, succ_eq_add_one, ← tsub_tsub_assoc (succ_le_of_lt h) (succ_pos _), succ_sub_one]\n#align asc_factorial_of_sub asc_factorial_of_sub\n\n",
 "asc_factorial_lt_pow_add":
 "theorem asc_factorial_lt_pow_add (n : ℕ) : ∀ {k : ℕ}, 2 ≤ k → n.asc_factorial k < (n + k) ^ k\n  | 0 => by rintro ⟨⟩\n  | 1 => by rintro (_ | ⟨⟨⟩⟩)\n  | k + 2 => fun _ => by\n    rw [asc_factorial_succ, pow_succ]\n    refine'\n      Nat.mul_lt_mul' le_rfl\n        ((asc_factorial_le_pow_add n _).trans_lt (pow_lt_pow_of_lt_left (lt_add_one _) (succ_pos _))) (succ_pos _)\n#align asc_factorial_lt_pow_add asc_factorial_lt_pow_add\n\n",
 "asc_factorial_le_pow_add":
 "theorem asc_factorial_le_pow_add (n : ℕ) : ∀ k : ℕ, n.asc_factorial k ≤ (n + k) ^ k\n  | 0 => by rw [asc_factorial_zero, pow_zero]\n  | k + 1 => by\n    rw [asc_factorial_succ, pow_succ]\n    exact nat.mul_le_mul_of_nonneg_left ((asc_factorial_le_pow_add k).trans (Nat.pow_le_pow_of_le_left (le_succ _) _))\n#align asc_factorial_le_pow_add asc_factorial_le_pow_add\n\n",
 "asc_factorial_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-- Avoid in favor of `nat.factorial_mul_asc_factorial` if you can. ℕ-division isn't worth it. -/\ntheorem asc_factorial_eq_div (n k : ℕ) : n.asc_factorial k = nat.factorial (n + k) / nat.factorial n :=\n  by\n  apply mul_left_cancel₀ n.factorial_ne_zero\n  rw [factorial_mul_asc_factorial]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| le.intro rfl).symm\n#align asc_factorial_eq_div asc_factorial_eq_div\n\n",
 "add_factorial_succ_lt_factorial_add_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem add_factorial_succ_lt_factorial_add_succ {i : ℕ} (n : ℕ) (hi : 2 ≤ i) :\n    i + nat.factorial (n + 1) < nat.factorial (i + n + 1) :=\n  by\n  rw [factorial_succ (i + _), add_mul, one_mul]\n  have : i ≤ i + n := le.intro rfl\n  exact\n    add_lt_add_of_lt_of_le\n      (this.trans_lt\n        ((lt_mul_iff_one_lt_right (zero_lt_two.trans_le (hi.trans this))).mpr\n          (lt_iff_le_and_ne.mpr\n            ⟨(i + n).factorial_pos, fun g =>\n              nat.not_succ_le_self 1 ((hi.trans this).trans (factorial_eq_one.mp g.symm))⟩)))\n      (factorial_le ((le_of_eq (add_comm n 1)).trans ((add_le_add_iff_right n).mpr (one_le_two.trans hi))))\n#align add_factorial_succ_lt_factorial_add_succ add_factorial_succ_lt_factorial_add_succ\n\n",
 "add_factorial_succ_le_factorial_add_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem add_factorial_succ_le_factorial_add_succ (i : ℕ) (n : ℕ) :\n    i + nat.factorial (n + 1) ≤ nat.factorial (i + (n + 1)) :=\n  by\n  obtain i2 | _ | i0 := le_or_lt 2 i\n  · exact (n.add_factorial_succ_lt_factorial_add_succ i2).le\n  · rw [← add_assoc, factorial_succ (1 + n), add_mul, one_mul, add_comm 1 n]\n    exact (add_le_add_iff_right _).mpr (one_le_mul (nat.le_add_left 1 n) (n + 1).factorial_pos)\n  rw [le_zero_iff.mp (nat.succ_le_succ_iff.mp i0), zero_add, zero_add]\n#align add_factorial_succ_le_factorial_add_succ add_factorial_succ_le_factorial_add_succ\n\n",
 "add_factorial_lt_factorial_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem add_factorial_lt_factorial_add {i n : ℕ} (hi : 2 ≤ i) (hn : 1 ≤ n) :\n    i + nat.factorial n < nat.factorial (i + n) := by\n  cases hn\n  · rw [factorial_one]\n    exact lt_factorial_self (succ_le_succ hi)\n  exact add_factorial_succ_lt_factorial_add_succ _ hi\n#align add_factorial_lt_factorial_add add_factorial_lt_factorial_add\n\n",
 "add_factorial_le_factorial_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem add_factorial_le_factorial_add (i : ℕ) {n : ℕ} (n1 : 1 ≤ n) : i + nat.factorial n ≤ nat.factorial (i + n) :=\n  by\n  cases' n1 with h\n  · exact self_le_factorial _\n  exact add_factorial_succ_le_factorial_add_succ i h\n#align add_factorial_le_factorial_add add_factorial_le_factorial_add\n\n",
 "add_desc_factorial_eq_asc_factorial":
 "theorem add_desc_factorial_eq_asc_factorial (n : ℕ) : ∀ k : ℕ, (n + k).desc_factorial k = n.asc_factorial k\n  | 0 => by rw [asc_factorial_zero, desc_factorial_zero]\n  | succ k => by rw [nat.add_succ, succ_desc_factorial_succ, asc_factorial_succ, add_desc_factorial_eq_asc_factorial]\n#align add_desc_factorial_eq_asc_factorial add_desc_factorial_eq_asc_factorial\n\n"}