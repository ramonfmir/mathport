{"supr_lt_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_lt_succ' (u : ℕ → α) (n : ℕ) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u k) =\n      «expr ⊔ » (u 0)\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u (k + 1))) :=\n  by\n  rw [← sup_supᵢ_nat_succ]\n  simp\n#align supr_lt_succ' supr_lt_succ'\n\n",
 "supr_lt_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_lt_succ (u : ℕ → α) (n : ℕ) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u k) =\n      «expr ⊔ » («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (u k))\n        (u n) :=\n  by simp [Nat.lt_succ_iff_lt_or_eq, supᵢ_or, supᵢ_sup_eq]\n#align supr_lt_succ supr_lt_succ\n\n",
 "not_mem_of_lt_Inf":
 "theorem not_mem_of_lt_Inf {s : set ℕ} {m : ℕ} (hm : m < infₛ s) : m ∉ s :=\n  by\n  cases eq_empty_or_nonempty s\n  · subst h\n    apply not_mem_empty\n  · rw [nat.Inf_def h] at hm\n    exact nat.find_min h hm\n#align not_mem_of_lt_Inf not_mem_of_lt_Inf\n\n",
 "nonempty_of_pos_Inf":
 "theorem nonempty_of_pos_Inf {s : set ℕ} (h : 0 < infₛ s) : s.nonempty :=\n  by\n  by_contra contra\n  rw [Set.not_nonempty_iff_eq_empty] at contra\n  have h' : Inf s ≠ 0 := ne_of_gt h\n  apply h'\n  rw [nat.Inf_eq_zero]\n  right\n  assumption\n#align nonempty_of_pos_Inf nonempty_of_pos_Inf\n\n",
 "nonempty_of_Inf_eq_succ":
 "theorem nonempty_of_Inf_eq_succ {s : set ℕ} {k : ℕ} (h : infₛ s = k + 1) : s.nonempty :=\n  nonempty_of_pos_Inf (h.symm ▸ succ_pos k : infₛ s > 0)\n#align nonempty_of_Inf_eq_succ nonempty_of_Inf_eq_succ\n\n",
 "infₛ_le":
 "#print infₛ_le /-\nprotected theorem infₛ_le {s : set ℕ} {m : ℕ} (hm : m ∈ s) : infₛ s ≤ m :=\n  by\n  rw [nat.Inf_def ⟨m, hm⟩]\n  exact nat.find_min' ⟨m, hm⟩ hm\n#align Inf_le infₛ_le\n-/\n\n",
 "infₛ_empty":
 "#print infₛ_empty /-\n@[simp]\ntheorem infₛ_empty : infₛ ∅ = 0 := by\n  rw [Inf_eq_zero]\n  right\n  rfl\n#align Inf_empty infₛ_empty\n-/\n\n",
 "infₛ_add":
 "#print infₛ_add /-\ntheorem infₛ_add {n : ℕ} {p : ℕ → Prop} (hn : n ≤ infₛ { m | p m }) : infₛ { m | p (m + n) } + n = infₛ { m | p m } :=\n  by\n  obtain h | ⟨m, hm⟩ := { m | p (m + n) }.eq_empty_or_nonempty\n  · rw [h, nat.Inf_empty, zero_add]\n    obtain hnp | hnp := hn.eq_or_lt\n    · exact hnp\n    suffices hp : p (Inf { m | p m } - n + n)\n    · exact (h.subset hp).elim\n    rw [tsub_add_cancel_of_le hn]\n    exact cinfₛ_mem (nonempty_of_pos_Inf <| n.zero_le.trans_lt hnp)\n  · have hp : ∃ n, n ∈ { m | p m } := ⟨_, hm⟩\n    rw [nat.Inf_def ⟨m, hm⟩, nat.Inf_def hp]\n    rw [nat.Inf_def hp] at hn\n    exact find_add hn\n#align Inf_add infₛ_add\n-/\n\n",
 "infᵢ_of_empty":
 "#print infᵢ_of_empty /-\n@[simp]\ntheorem infᵢ_of_empty {ι : Sort _} [is_empty ι] (f : ι → ℕ) : infᵢ f = 0 := by rw [infᵢ_of_empty', infₛ_empty]\n#align infi_of_empty infᵢ_of_empty\n-/\n\n",
 "infi_lt_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_lt_succ' (u : ℕ → α) (n : ℕ) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u k) =\n      «expr ⊓ » (u 0)\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u (k + 1))) :=\n  @supr_lt_succ' («expr ᵒᵈ» α) _ _ _\n#align infi_lt_succ' infi_lt_succ'\n\n",
 "infi_lt_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_lt_succ (u : ℕ → α) (n : ℕ) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u k) =\n      «expr ⊓ » («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (u k))\n        (u n) :=\n  @supr_lt_succ («expr ᵒᵈ» α) _ _ _\n#align infi_lt_succ infi_lt_succ\n\n",
 "eq_Ici_of_nonempty_of_upward_closed":
 "theorem eq_Ici_of_nonempty_of_upward_closed {s : set ℕ} (hs : s.nonempty)\n    (hs' : ∀ k₁ k₂ : ℕ, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s) : s = Ici (infₛ s) :=\n  ext fun n => ⟨fun H => nat.Inf_le H, fun H => hs' (infₛ s) n H (Inf_mem hs)⟩\n#align eq_Ici_of_nonempty_of_upward_closed eq_Ici_of_nonempty_of_upward_closed\n\n",
 "cinfₛ_mem":
 "#print cinfₛ_mem /-\ntheorem cinfₛ_mem {s : set ℕ} (h : s.nonempty) : infₛ s ∈ s :=\n  by\n  rw [nat.Inf_def h]\n  exact nat.find_spec h\n#align Inf_mem cinfₛ_mem\n-/\n\n",
 "bUnion_lt_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem bUnion_lt_succ' (u : ℕ → set α) (n : ℕ) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u k) =\n      u 0 ∪\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u (k + 1)) :=\n  nat.supr_lt_succ' u n\n#align bUnion_lt_succ' bUnion_lt_succ'\n\n",
 "bUnion_lt_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem bUnion_lt_succ (u : ℕ → set α) (n : ℕ) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u k) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u k) ∪ u n :=\n  nat.supr_lt_succ u n\n#align bUnion_lt_succ bUnion_lt_succ\n\n",
 "bInter_lt_succ'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem bInter_lt_succ' (u : ℕ → set α) (n : ℕ) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u k) =\n      u 0 ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u (k + 1)) :=\n  nat.infi_lt_succ' u n\n#align bInter_lt_succ' bInter_lt_succ'\n\n",
 "bInter_lt_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem bInter_lt_succ (u : ℕ → set α) (n : ℕ) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u k) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u k) ∩ u n :=\n  nat.infi_lt_succ u n\n#align bInter_lt_succ bInter_lt_succ\n\n",
 "Sup_mem":
 "theorem Sup_mem {s : set ℕ} (h₁ : s.nonempty) (h₂ : BddAbove s) : supₛ s ∈ s :=\n  let ⟨k, hk⟩ := h₂\n  h₁.cSup_mem ((finite_le_nat k).subset hk)\n#align Sup_mem Sup_mem\n\n",
 "Sup_eq_zero":
 "theorem _root_.set.infinite.nat.Sup_eq_zero {s : set ℕ} (h : s.infinite) : supₛ s = 0 :=\n  dif_neg fun ⟨n, hn⟩ =>\n    let ⟨k, hks, hk⟩ := h.exists_nat_lt n\n    (hn k hks).not_lt hk\n#align set.infinite.nat.Sup_eq_zero set.infinite.nat.Sup_eq_zero\n\n",
 "Sup_def":
 "theorem Sup_def {s : set ℕ} (h : ∃ n, ∀ a ∈ s, a ≤ n) : supₛ s = @nat.find (fun n => ∀ a ∈ s, a ≤ n) _ h :=\n  dif_pos _\n#align Sup_def Sup_def\n\n",
 "Inf_upward_closed_eq_succ_iff":
 "theorem Inf_upward_closed_eq_succ_iff {s : set ℕ} (hs : ∀ k₁ k₂ : ℕ, k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s) (k : ℕ) :\n    infₛ s = k + 1 ↔ k + 1 ∈ s ∧ k ∉ s := by\n  constructor\n  · intro H\n    rw [eq_Ici_of_nonempty_of_upward_closed (nonempty_of_Inf_eq_succ H) hs, H, mem_Ici, mem_Ici]\n    exact ⟨le_rfl, k.not_succ_le_self⟩\n  · rintro ⟨H, H'⟩\n    rw [Inf_def (⟨_, H⟩ : s.nonempty), find_eq_iff]\n    exact ⟨H, fun n hnk hns => H' <| hs n k (lt_succ_iff.mp hnk) hns⟩\n#align Inf_upward_closed_eq_succ_iff Inf_upward_closed_eq_succ_iff\n\n",
 "Inf_eq_zero":
 "@[simp]\ntheorem Inf_eq_zero {s : set ℕ} : infₛ s = 0 ↔ 0 ∈ s ∨ s = ∅ :=\n  by\n  cases eq_empty_or_nonempty s\n  · subst h\n    simp only [or_true_iff, eq_self_iff_true, iff_true_iff, Inf, InfSet.infₛ, mem_empty_iff_false, exists_false,\n      dif_neg, not_false_iff]\n  · simp only [h.ne_empty, or_false_iff, nat.Inf_def, h, Nat.find_eq_zero]\n#align Inf_eq_zero Inf_eq_zero\n\n",
 "Inf_def":
 "/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Floris van Doorn, Gabriel Ebner, Yury Kudryashov\n-/\ntheorem Inf_def {s : set ℕ} (h : s.nonempty) : infₛ s = @nat.find (fun n => n ∈ s) _ h :=\n  dif_pos _\n#align Inf_def Inf_def\n\n",
 "Inf_add'":
 "theorem Inf_add' {n : ℕ} {p : ℕ → Prop} (h : 0 < infₛ { m | p m }) : infₛ { m | p m } + n = infₛ { m | p (m - n) } :=\n  by\n  convert infₛ_add _\n  · simp_rw [add_tsub_cancel_right]\n  obtain ⟨m, hm⟩ := nonempty_of_pos_Inf h\n  refine'\n    le_cinfₛ ⟨m + n, _⟩ fun b hb =>\n      le_of_not_lt fun hbn => ne_of_mem_of_not_mem _ (not_mem_of_lt_Inf h) (tsub_eq_zero_of_le hbn.le)\n  · dsimp\n    rwa [add_tsub_cancel_right]\n  · exact hb\n#align Inf_add' Inf_add'\n\n"}