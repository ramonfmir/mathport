{"zip_right_nil_right":
 "@[simp]\ntheorem zip_right_nil_right : zipRight as ([] : list β) = [] :=\n  rfl\n#align zip_right_nil_right zip_right_nil_right\n\n",
 "zip_right_nil_left":
 "@[simp]\ntheorem zip_right_nil_left : zipRight ([] : list α) bs = bs.map fun b => (none, b) := by cases bs <;> rfl\n#align zip_right_nil_left zip_right_nil_left\n\n",
 "zip_right_nil_cons":
 "@[simp]\ntheorem zip_right_nil_cons : zipRight ([] : list α) (b :: bs) = (none, b) :: bs.map fun b => (none, b) :=\n  rfl\n#align zip_right_nil_cons zip_right_nil_cons\n\n",
 "zip_right_eq_zip_right'":
 "theorem zip_right_eq_zip_right' : zipRight as bs = (zipRight' as bs).fst := by\n  simp only [zip_right, zip_right', map₂_right_eq_map₂_right']\n#align zip_right_eq_zip_right' zip_right_eq_zip_right'\n\n",
 "zip_right_cons_cons":
 "@[simp]\ntheorem zip_right_cons_cons : zipRight (a :: as) (b :: bs) = (some a, b) :: zipRight as bs :=\n  rfl\n#align zip_right_cons_cons zip_right_cons_cons\n\n",
 "zip_right'_nil_right":
 "@[simp]\ntheorem zip_right'_nil_right : zipRight' as ([] : list β) = ([], as) :=\n  rfl\n#align zip_right'_nil_right zip_right'_nil_right\n\n",
 "zip_right'_nil_left":
 "@[simp]\ntheorem zip_right'_nil_left : zipRight' ([] : list α) bs = (bs.map fun b => (none, b), []) := by cases bs <;> rfl\n#align zip_right'_nil_left zip_right'_nil_left\n\n",
 "zip_right'_nil_cons":
 "@[simp]\ntheorem zip_right'_nil_cons : zipRight' ([] : list α) (b :: bs) = ((none, b) :: bs.map fun b => (none, b), []) :=\n  rfl\n#align zip_right'_nil_cons zip_right'_nil_cons\n\n",
 "zip_right'_cons_cons":
 "@[simp]\ntheorem zip_right'_cons_cons :\n    zipRight' (a :: as) (b :: bs) =\n      let rec := zipRight' as bs\n      ((some a, b) :: rec.fst, rec.snd) :=\n  rfl\n#align zip_right'_cons_cons zip_right'_cons_cons\n\n",
 "zip_left_nil_right":
 "@[simp]\ntheorem zip_left_nil_right : zipLeft as ([] : list β) = as.map fun a => (a, none) := by cases as <;> rfl\n#align zip_left_nil_right zip_left_nil_right\n\n",
 "zip_left_nil_left":
 "@[simp]\ntheorem zip_left_nil_left : zipLeft ([] : list α) bs = [] :=\n  rfl\n#align zip_left_nil_left zip_left_nil_left\n\n",
 "zip_left_eq_zip_left'":
 "theorem zip_left_eq_zip_left' : zipLeft as bs = (zipLeft' as bs).fst := by\n  simp only [zip_left, zip_left', map₂_left_eq_map₂_left']\n#align zip_left_eq_zip_left' zip_left_eq_zip_left'\n\n",
 "zip_left_cons_nil":
 "@[simp]\ntheorem zip_left_cons_nil : zipLeft (a :: as) ([] : list β) = (a, none) :: as.map fun a => (a, none) :=\n  rfl\n#align zip_left_cons_nil zip_left_cons_nil\n\n",
 "zip_left_cons_cons":
 "@[simp]\ntheorem zip_left_cons_cons : zipLeft (a :: as) (b :: bs) = (a, some b) :: zipLeft as bs :=\n  rfl\n#align zip_left_cons_cons zip_left_cons_cons\n\n",
 "zip_left'_nil_right":
 "@[simp]\ntheorem zip_left'_nil_right : zipLeft' as ([] : list β) = (as.map fun a => (a, none), []) := by cases as <;> rfl\n#align zip_left'_nil_right zip_left'_nil_right\n\n",
 "zip_left'_nil_left":
 "@[simp]\ntheorem zip_left'_nil_left : zipLeft' ([] : list α) bs = ([], bs) :=\n  rfl\n#align zip_left'_nil_left zip_left'_nil_left\n\n",
 "zip_left'_cons_nil":
 "@[simp]\ntheorem zip_left'_cons_nil : zipLeft' (a :: as) ([] : list β) = ((a, none) :: as.map fun a => (a, none), []) :=\n  rfl\n#align zip_left'_cons_nil zip_left'_cons_nil\n\n",
 "zip_left'_cons_cons":
 "@[simp]\ntheorem zip_left'_cons_cons :\n    zipLeft' (a :: as) (b :: bs) =\n      let rec := zipLeft' as bs\n      ((a, some b) :: rec.fst, rec.snd) :=\n  rfl\n#align zip_left'_cons_cons zip_left'_cons_cons\n\n",
 "update_nth_succ":
 "@[simp]\ntheorem update_nth_succ (x : α) (xs : list α) (n : ℕ) (a : α) :\n    (x :: xs).update_nth n.succ a = x :: xs.update_nth n a :=\n  rfl\n#align update_nth_succ update_nth_succ\n\n",
 "update_nth_nil":
 "@[simp]\ntheorem update_nth_nil (n : ℕ) (a : α) : [].update_nth n a = [] :=\n  rfl\n#align update_nth_nil update_nth_nil\n\n",
 "update_nth_length":
 "@[simp]\ntheorem update_nth_length (l : list α) (n) (a : α) : length (set l n a) = length l := by\n  simp only [update_nth_eq_modify_nth, modify_nth_length]\n#align update_nth_length update_nth_length\n\n",
 "update_nth_eq_take_cons_drop":
 "theorem update_nth_eq_take_cons_drop (a : α) {n l} (h : n < length l) : set l n a = take n l ++ a :: drop (n + 1) l :=\n  by rw [update_nth_eq_modify_nth, modify_nth_eq_take_cons_drop _ h]\n#align update_nth_eq_take_cons_drop update_nth_eq_take_cons_drop\n\n",
 "update_nth_eq_nil":
 "@[simp]\ntheorem update_nth_eq_nil (l : list α) (n : ℕ) (a : α) : l.update_nth n a = [] ↔ l = [] := by\n  cases l <;> cases n <;> simp only [update_nth]\n#align update_nth_eq_nil update_nth_eq_nil\n\n",
 "update_nth_eq_modify_nth":
 "theorem update_nth_eq_modify_nth (a : α) : ∀ (n) (l : list α), set l n a = modifyNth (fun _ => a) n l\n  | 0, l => by cases l <;> rfl\n  | n + 1, [] => rfl\n  | n + 1, b :: l => congr_arg (cons _) (update_nth_eq_modify_nth _ _)\n#align update_nth_eq_modify_nth update_nth_eq_modify_nth\n\n",
 "update_nth_comm":
 "theorem update_nth_comm (a b : α) :\n    ∀ {n m : ℕ} (l : list α) (h : n ≠ m), (l.update_nth n a).update_nth m b = (l.update_nth m b).update_nth n a\n  | _, _, [], _ => by simp\n  | 0, 0, x :: t, h => absurd rfl h\n  | n + 1, 0, x :: t, h => by simp [List.set]\n  | 0, m + 1, x :: t, h => by simp [List.set]\n  | n + 1, m + 1, x :: t, h => by\n    simp only [update_nth, true_and_iff, eq_self_iff_true]\n    exact update_nth_comm t fun h' => h <| nat.succ_inj'.mpr h'\n#align update_nth_comm update_nth_comm\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[trans]\ntheorem sublist.trans {l₁ l₂ l₃ : list α} (h₁ : «expr <+ » l₁ l₂) (h₂ : «expr <+ » l₂ l₃) : «expr <+ » l₁ l₃ :=\n  sublist.rec_on h₂ (fun _ s => s) (fun l₂ l₃ a h₂ IH l₁ h₁ => sublist.cons _ _ _ (IH l₁ h₁))\n    (fun l₂ l₃ a h₂ IH l₁ h₁ =>\n      @sublist.cases_on _ (fun l₁ l₂' => l₂' = a :: l₂ → «expr <+ » l₁ (a :: l₃)) _ _ h₁ (fun _ => nil_sublist _)\n        (fun l₁ l₂' a' h₁' e =>\n          match a', l₂', e, h₁' with\n          | _, _, rfl, h₁ => sublist.cons _ _ _ (IH _ h₁))\n        (fun l₁ l₂' a' h₁' e =>\n          match a', l₂', e, h₁' with\n          | _, _, rfl, h₁ => Sublist.cons₂ _ _ _ (IH _ h₁))\n        rfl)\n    l₁ h₁\n#align sublist.trans sublist.trans\n\n",
 "to_chunks_nil":
 "@[simp]\ntheorem to_chunks_nil (n) : @toChunks α n [] = [] := by cases n <;> rfl\n#align to_chunks_nil to_chunks_nil\n\n",
 "to_chunks_length_le":
 "theorem to_chunks_length_le : ∀ n xs, n ≠ 0 → ∀ l : list α, l ∈ @toChunks α n xs → l.length ≤ n\n  | 0, _, e, _ => (e rfl).elim\n  | n + 1, xs, _, l => by\n    refine' (measure_wf length).induction xs _; intro xs IH h\n    by_cases x0 : xs = [];\n    · subst xs\n      cases h\n    rw [to_chunks_eq_cons' _ x0] at h; rcases h with (rfl | h)\n    · apply length_take_le\n    · refine' IH _ _ h\n      simp only [measure, inv_image, length_drop]\n      exact tsub_lt_self (length_pos_iff_ne_nil.2 x0) (succ_pos _)\n#align to_chunks_length_le to_chunks_length_le\n\n",
 "to_chunks_join":
 "@[simp]\ntheorem to_chunks_join : ∀ n xs, (@toChunks α n xs).join = xs\n  | n, [] => by cases n <;> rfl\n  | 0, x :: xs => by simp only [to_chunks, join] <;> rw [append_nil]\n  | n + 1, x :: xs => by\n    rw [to_chunks]\n    cases' e : to_chunks_aux n xs n with l L\n    exact (congr_arg (cons x) (to_chunks_aux_join e) : _)\n#align to_chunks_join to_chunks_join\n\n",
 "to_chunks_eq_cons'":
 "theorem to_chunks_eq_cons' (n) :\n    ∀ {xs : list α} (h : xs ≠ []), xs.to_chunks (n + 1) = xs.take (n + 1) :: (xs.drop (n + 1)).to_chunks (n + 1)\n  | [], e => (e rfl).elim\n  | x :: xs, _ => by rw [to_chunks, to_chunks_aux_eq] <;> rfl\n#align to_chunks_eq_cons' to_chunks_eq_cons'\n\n",
 "to_chunks_eq_cons":
 "theorem to_chunks_eq_cons :\n    ∀ {n} {xs : list α} (n0 : n ≠ 0) (x0 : xs ≠ []), xs.to_chunks n = xs.take n :: (xs.drop n).to_chunks n\n  | 0, _, e => (e rfl).elim\n  | n + 1, xs, _ => [anonymous] _\n#align to_chunks_eq_cons to_chunks_eq_cons\n\n",
 "to_chunks_aux_join":
 "theorem to_chunks_aux_join {n} : ∀ {xs i l L}, @toChunksAux α n xs i = (l, L) → l ++ L.join = xs\n  | [], _, _, _, rfl => rfl\n  | x :: xs, i, l, L, e => by\n    cases i <;> [cases' e' : to_chunks_aux n xs n with l L, cases' e' : to_chunks_aux n xs i with l L] <;>\n      · rw [to_chunks_aux, e', to_chunks_aux] at e\n        cases e\n        exact (congr_arg (cons x) (to_chunks_aux_join e') : _)\n#align to_chunks_aux_join to_chunks_aux_join\n\n",
 "to_chunks_aux_eq":
 "theorem to_chunks_aux_eq (n) : ∀ xs i, @toChunksAux α n xs i = (xs.take i, (xs.drop i).to_chunks (n + 1))\n  | [], i => by cases i <;> rfl\n  | x :: xs, 0 => by rw [to_chunks_aux, drop, to_chunks] <;> cases to_chunks_aux n xs n <;> rfl\n  | x :: xs, i + 1 => by rw [to_chunks_aux, to_chunks_aux_eq] <;> rfl\n#align to_chunks_aux_eq to_chunks_aux_eq\n\n",
 "take_zero":
 "@[simp]\ntheorem take_zero (l : list α) : take 0 l = [] :=\n  rfl\n#align take_zero take_zero\n\n",
 "take_while_take_while":
 "theorem take_while_take_while (p q : α → Prop) [decidable_pred p] [decidable_pred q] (l : list α) :\n    takeWhile p (takeWhile q l) = takeWhile (fun a => p a ∧ q a) l :=\n  by\n  induction' l with hd tl IH\n  · simp [take_while]\n  · by_cases hp : p hd <;> by_cases hq : q hd <;> simp [take_while, hp, hq, IH]\n#align take_while_take_while take_while_take_while\n\n",
 "take_while_idem":
 "theorem take_while_idem : takeWhile p (takeWhile p l) = takeWhile p l := by\n  simp_rw [take_while_take_while, and_self_iff]\n#align take_while_idem take_while_idem\n\n",
 "take_while_eq_self_iff":
 "@[simp]\ntheorem take_while_eq_self_iff : takeWhile p l = l ↔ ∀ x ∈ l, p x :=\n  by\n  induction' l with x xs IH\n  · simp [take_while]\n  · by_cases hp : p x <;> simp [hp, take_while, IH]\n#align take_while_eq_self_iff take_while_eq_self_iff\n\n",
 "take_while_eq_nil_iff":
 "@[simp]\ntheorem take_while_eq_nil_iff : takeWhile p l = [] ↔ ∀ hl : 0 < l.length, ¬p (l.nth_le 0 hl) :=\n  by\n  induction' l with x xs IH\n  · simp\n  · by_cases hp : p x <;> simp [hp, take_while, IH]\n#align take_while_eq_nil_iff take_while_eq_nil_iff\n\n",
 "take_while_append_drop":
 "@[simp]\ntheorem take_while_append_drop : ∀ l : list α, takeWhile p l ++ dropWhile p l = l\n  | [] => rfl\n  | a :: l =>\n    if pa : p a then by rw [take_while, drop_while, if_pos pa, if_pos pa, cons_append, take_while_append_drop l]\n    else by rw [take_while, drop_while, if_neg pa, if_neg pa, nil_append]\n#align take_while_append_drop take_while_append_drop\n\n",
 "take_take":
 "theorem take_take : ∀ (n m) (l : list α), take n (take m l) = take (min n m) l\n  | n, 0, l => by rw [min_zero, take_zero, take_nil]\n  | 0, m, l => by rw [zero_min, take_zero, take_zero]\n  | succ n, succ m, nil => by simp only [take_nil]\n  | succ n, succ m, a :: l => by simp only [take, min_succ_succ, take_take n m l] <;> constructor <;> rfl\n#align take_take take_take\n\n",
 "take_succ":
 "theorem take_succ {l : list α} {n : ℕ} : l.take (n + 1) = l.take n ++ (l.nth n).to_list :=\n  by\n  induction' l with hd tl hl generalizing n\n  · simp only [option.to_list, nth, take_nil, append_nil]\n  · cases n\n    · simp only [option.to_list, nth, eq_self_iff_true, and_self_iff, take, nil_append]\n    · simp only [hl, cons_append, nth, eq_self_iff_true, and_self_iff, take]\n#align take_succ take_succ\n\n",
 "take_replicate":
 "theorem take_replicate (a : α) : ∀ n m : ℕ, take n (replicate m a) = replicate (min n m) a\n  | n, 0 => by simp\n  | 0, m => by simp\n  | succ n, succ m => by simp [min_succ_succ, take_replicate]\n#align take_replicate take_replicate\n\n",
 "take_one_drop_eq_of_lt_length":
 "theorem take_one_drop_eq_of_lt_length {l : list α} {n : ℕ} (h : n < l.length) : (l.drop n).take 1 = [l.nth_le n h] :=\n  by\n  induction' l with x l ih generalizing n\n  · cases h\n  · by_cases h₁ : l = []\n    · subst h₁\n      rw [nth_le_singleton]\n      simp [lt_succ_iff] at h\n      subst h\n      simp\n    have h₂ := h\n    rw [length_cons, Nat.lt_succ_iff, le_iff_eq_or_lt] at h₂\n    cases n\n    · simp\n    rw [drop, nth_le]\n    apply ih\n#align take_one_drop_eq_of_lt_length take_one_drop_eq_of_lt_length\n\n",
 "take_nil":
 "@[simp]\ntheorem take_nil : ∀ n, take n [] = ([] : list α)\n  | 0 => rfl\n  | n + 1 => rfl\n#align take_nil take_nil\n\n",
 "take_length":
 "@[simp]\ntheorem take_length : ∀ l : list α, take (length l) l = l\n  | [] => rfl\n  | a :: l => by change a :: take (length l) l = a :: l; rw [take_length]\n#align take_length take_length\n\n",
 "take_left'":
 "theorem take_left' {l₁ l₂ : list α} {n} (h : length l₁ = n) : take n (l₁ ++ l₂) = l₁ := by rw [← h] <;> apply take_left\n#align take_left' take_left'\n\n",
 "take_left":
 "@[simp]\ntheorem take_left : ∀ l₁ l₂ : list α, take (length l₁) (l₁ ++ l₂) = l₁\n  | [], l₂ => rfl\n  | a :: l₁, l₂ => congr_arg (cons a) (take_left l₁ l₂)\n#align take_left take_left\n\n",
 "take_eq_take":
 "theorem take_eq_take : ∀ {l : list α} {m n : ℕ}, l.take m = l.take n ↔ min m l.length = min n l.length\n  | [], m, n => by simp\n  | x :: xs, 0, 0 => by simp\n  | x :: xs, m + 1, 0 => by simp\n  | x :: xs, 0, n + 1 => by simp [@eq_comm ℕ 0]\n  | x :: xs, m + 1, n + 1 => by simp [nat.min_succ_succ, take_eq_take]\n#align take_eq_take take_eq_take\n\n",
 "take_eq_nil_iff":
 "@[simp]\ntheorem take_eq_nil_iff {l : list α} {k : ℕ} : l.take k = [] ↔ l = [] ∨ k = 0 := by\n  cases l <;> cases k <;> simp [nat.succ_ne_zero]\n#align take_eq_nil_iff take_eq_nil_iff\n\n",
 "take_cons":
 "theorem take_cons (n) (a : α) (l : list α) : take (succ n) (a :: l) = a :: take n l :=\n  rfl\n#align take_cons take_cons\n\n",
 "take_append_of_le_length":
 "theorem take_append_of_le_length {l₁ l₂ : list α} {n : ℕ} (h : n ≤ l₁.length) : (l₁ ++ l₂).take n = l₁.take n := by\n  simp [take_append_eq_append_take, tsub_eq_zero_iff_le.mpr h]\n#align take_append_of_le_length take_append_of_le_length\n\n",
 "take_append_eq_append_take":
 "/-- Taking the first `n` elements in `l₁ ++ l₂` is the same as appending the first `n` elements\nof `l₁` to the first `n - l₁.length` elements of `l₂`. -/\ntheorem take_append_eq_append_take {l₁ l₂ : list α} {n : ℕ} :\n    take n (l₁ ++ l₂) = take n l₁ ++ take (n - l₁.length) l₂ :=\n  by\n  induction l₁ generalizing n; · simp\n  cases n; · simp; simp [*]\n#align take_append_eq_append_take take_append_eq_append_take\n\n",
 "take_append_drop":
 "@[simp]\ntheorem take_append_drop : ∀ (n : ℕ) (l : list α), take n l ++ drop n l = l\n  | 0, a => rfl\n  | succ n, [] => rfl\n  | succ n, x :: xs => congr_arg (cons x) <| take_append_drop n xs\n#align take_append_drop take_append_drop\n\n",
 "take_append":
 "/-- Taking the first `l₁.length + i` elements in `l₁ ++ l₂` is the same as appending the first\n`i` elements of `l₂` to `l₁`. -/\ntheorem take_append {l₁ l₂ : list α} (i : ℕ) : take (l₁.length + i) (l₁ ++ l₂) = l₁ ++ take i l₂ := by\n  simp [take_append_eq_append_take, take_all_of_le le_self_add]\n#align take_append take_append\n\n",
 "take_all_of_le":
 "theorem take_all_of_le : ∀ {n} {l : list α}, length l ≤ n → take n l = l\n  | 0, [], h => rfl\n  | 0, a :: l, h => absurd h (not_le_of_gt (zero_lt_succ _))\n  | n + 1, [], h => rfl\n  | n + 1, a :: l, h => by\n    change a :: take n l = a :: l\n    rw [take_all_of_le (le_of_succ_le_succ h)]\n#align take_all_of_le take_all_of_le\n\n",
 "take_add":
 "theorem take_add (l : list α) (m n : ℕ) : l.take (m + n) = l.take m ++ (l.drop m).take n :=\n  by\n  convert_to take (m + n) (take m l ++ drop m l) = take m l ++ take n (drop m l)\n  · rw [take_append_drop]\n  rw [take_append_eq_append_take, take_all_of_le, append_right_inj]; swap\n  · trans m\n    · apply length_take_le\n    · simp\n  simp only [take_eq_take, length_take, length_drop]\n  generalize l.length = k; by_cases h : m ≤ k\n  · simp [min_eq_left_iff.mpr h]\n  · push_neg  at h\n    simp [nat.sub_eq_zero_of_le (le_of_lt h)]\n#align take_add take_add\n\n",
 "take'_nil":
 "@[simp]\ntheorem take'_nil : ∀ n, takeI n (@nil α) = replicate n default\n  | 0 => rfl\n  | n + 1 => congr_arg (cons _) (take'_nil _)\n#align take'_nil take'_nil\n\n",
 "take'_length":
 "@[simp]\ntheorem take'_length : ∀ n l, length (@takeI α _ n l) = n\n  | 0, l => rfl\n  | n + 1, l => congr_arg succ (take'_length _ _)\n#align take'_length take'_length\n\n",
 "take'_left'":
 "theorem take'_left' {l₁ l₂ : list α} {n} (h : length l₁ = n) : takeI n (l₁ ++ l₂) = l₁ := by\n  rw [← h] <;> apply take'_left\n#align take'_left' take'_left'\n\n",
 "take'_left":
 "@[simp]\ntheorem take'_left (l₁ l₂ : list α) : takeI (length l₁) (l₁ ++ l₂) = l₁ :=\n  (takeI_eq_take (by simp only [length_append, nat.le_add_right])).trans (take_left _ _)\n#align take'_left take'_left\n\n",
 "take'_eq_take":
 "theorem take'_eq_take : ∀ {n} {l : list α}, n ≤ length l → takeI n l = take n l\n  | 0, l, h => rfl\n  | n + 1, a :: l, h => congr_arg (cons _) <| take'_eq_take <| le_of_succ_le_succ h\n#align take'_eq_take take'_eq_take\n\n",
 "tail_replicate":
 "@[simp]\ntheorem tail_replicate (n) (a : α) : tail (replicate n a) = replicate (n - 1) a := by cases n <;> rfl\n#align tail_replicate tail_replicate\n\n",
 "tail_nil":
 "@[simp]\ntheorem tail_nil : tail (@nil α) = [] :=\n  rfl\n#align tail_nil tail_nil\n\n",
 "tail_eq_of_cons_eq":
 "theorem tail_eq_of_cons_eq {h₁ h₂ : α} {t₁ t₂ : list α} : h₁ :: t₁ = h₂ :: t₂ → t₁ = t₂ := fun Peq =>\n  list.no_confusion Peq fun Pheq Pteq => Pteq\n#align tail_eq_of_cons_eq tail_eq_of_cons_eq\n\n",
 "tail_drop":
 "theorem tail_drop (l : list α) (n : ℕ) : (l.drop n).tail = l.drop (n + 1) :=\n  by\n  induction' l with hd tl hl generalizing n\n  · simp\n  · cases n\n    · simp\n    · simp [hl]\n#align tail_drop tail_drop\n\n",
 "tail_cons":
 "@[simp]\ntheorem tail_cons (a : α) (l : list α) : tail (a :: l) = l :=\n  rfl\n#align tail_cons tail_cons\n\n",
 "tail_append_singleton_of_ne_nil":
 "theorem tail_append_singleton_of_ne_nil {a : α} {l : list α} (h : l ≠ nil) : tail (l ++ [a]) = tail l ++ [a] :=\n  by\n  induction l\n  contradiction\n  rw [tail, cons_append, tail]\n#align tail_append_singleton_of_ne_nil tail_append_singleton_of_ne_nil\n\n",
 "tail_append_of_ne_nil":
 "theorem tail_append_of_ne_nil (l l' : list α) (h : l ≠ []) : (l ++ l').tail = l.tail ++ l' :=\n  by\n  cases l\n  · contradiction\n  · simp\n#align tail_append_of_ne_nil tail_append_of_ne_nil\n\n",
 "surjective_tail":
 "theorem surjective_tail : surjective (@tail α)\n  | [] => ⟨[], rfl⟩\n  | a :: l => ⟨a :: a :: l, rfl⟩\n#align surjective_tail surjective_tail\n\n",
 "surjective_head'":
 "theorem surjective_head' : surjective (@head? α) :=\n  option.forall.2 ⟨⟨[], rfl⟩, fun x => ⟨[x], rfl⟩⟩\n#align surjective_head' surjective_head'\n\n",
 "surjective_head":
 "theorem surjective_head [inhabited α] : surjective (@headI α _) := fun x => ⟨[x], rfl⟩\n#align surjective_head surjective_head\n\n",
 "subset_singleton_iff":
 "theorem subset_singleton_iff {a : α} {L : list α} : L ⊆ [a] ↔ ∃ n, L = replicate n a := by\n  simp only [eq_replicate, subset_def, mem_singleton, exists_eq_left']\n#align subset_singleton_iff subset_singleton_iff\n\n",
 "subset_def":
 "theorem subset_def {l₁ l₂ : list α} : l₁ ⊆ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₁ → a ∈ l₂ :=\n  iff.rfl\n#align subset_def subset_def\n\n",
 "subset_append_of_subset_right":
 "theorem subset_append_of_subset_right (l l₁ l₂ : list α) : l ⊆ l₂ → l ⊆ l₁ ++ l₂ := fun s =>\n  subset.trans s <| subset_append_right _ _\n#align subset_append_of_subset_right subset_append_of_subset_right\n\n",
 "subset_append_of_subset_left":
 "theorem subset_append_of_subset_left (l l₁ l₂ : list α) : l ⊆ l₁ → l ⊆ l₁ ++ l₂ := fun s =>\n  subset.trans s <| subset_append_left _ _\n#align subset_append_of_subset_left subset_append_of_subset_left\n\n",
 "subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.subset : ∀ {l₁ l₂ : list α}, «expr <+ » l₁ l₂ → l₁ ⊆ l₂\n  | _, _, sublist.slnil, b, h => h\n  | _, _, sublist.cons l₁ l₂ a s, b, h => mem_cons_of_mem _ (sublist.subset s h)\n  | _, _, sublist.cons2 l₁ l₂ a s, b, h =>\n    match eq_or_mem_of_mem_cons h with\n    | or.inl h => h ▸ mem_cons_self _ _\n    | or.inr h => mem_cons_of_mem _ (sublist.subset s h)\n#align sublist.subset sublist.subset\n\n",
 "sublist_replicate_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_replicate_iff {l : list α} {a : α} {n : ℕ} :\n    «expr <+ » l (replicate n a) ↔ ∃ k ≤ n, l = replicate k a :=\n  ⟨fun h =>\n    ⟨l.length, h.length_le.trans (length_replicate _ _).le,\n      eq_replicate_length.mpr fun b hb => eq_of_mem_replicate (h.subset hb)⟩,\n    by\n    rintro ⟨k, h, rfl⟩\n    exact (replicate_sublist_replicate _).mpr h⟩\n#align sublist_replicate_iff sublist_replicate_iff\n\n",
 "sublist_or_mem_of_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_or_mem_of_sublist {l l₁ l₂ : list α} {a : α} (h : «expr <+ » l (l₁ ++ a :: l₂)) :\n    «expr <+ » l (l₁ ++ l₂) ∨ a ∈ l := by\n  induction' l₁ with b l₁ IH generalizing l\n  · cases h\n    · left\n      exact ‹«expr <+ » l l₂›\n    · right\n      apply mem_cons_self\n  · cases' h with _ _ _ h _ _ _ h\n    · exact or.imp_left (sublist_cons_of_sublist _) (IH h)\n    · exact (IH h).imp (sublist.cons_cons _) (mem_cons_of_mem _)\n#align sublist_or_mem_of_sublist sublist_or_mem_of_sublist\n\n",
 "sublist_of_cons_sublist_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_of_cons_sublist_cons {l₁ l₂ : list α} : ∀ {a : α}, «expr <+ » (a :: l₁) (a :: l₂) → «expr <+ » l₁ l₂\n  | _, sublist.cons _ _ a s => sublist_of_cons_sublist s\n  | _, sublist.cons2 _ _ a s => s\n#align sublist_of_cons_sublist_cons sublist_of_cons_sublist_cons\n\n",
 "sublist_of_cons_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_of_cons_sublist {a : α} {l₁ l₂ : list α} : «expr <+ » (a :: l₁) l₂ → «expr <+ » l₁ l₂ :=\n  Sublist.trans (sublist_cons a l₁)\n#align sublist_of_cons_sublist sublist_of_cons_sublist\n\n",
 "sublist_nil_iff_eq_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem sublist_nil_iff_eq_nil {l : list α} : «expr <+ » l [] ↔ l = [] :=\n  ⟨eq_nil_of_sublist_nil, fun H => H ▸ Sublist.refl _⟩\n#align sublist_nil_iff_eq_nil sublist_nil_iff_eq_nil\n\n",
 "sublist_cons_of_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_cons_of_sublist (a : α) {l₁ l₂ : list α} : «expr <+ » l₁ l₂ → «expr <+ » l₁ (a :: l₂) :=\n  sublist.cons _ _ _\n#align sublist_cons_of_sublist sublist_cons_of_sublist\n\n",
 "sublist_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem sublist_cons (a : α) (l : list α) : «expr <+ » l (a :: l) :=\n  sublist.cons _ _ _ (Sublist.refl l)\n#align sublist_cons sublist_cons\n\n",
 "sublist_append_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem sublist_append_right : ∀ l₁ l₂ : list α, «expr <+ » l₂ (l₁ ++ l₂)\n  | [], l₂ => Sublist.refl _\n  | a :: l₁, l₂ => sublist.cons _ _ _ (sublist_append_right l₁ l₂)\n#align sublist_append_right sublist_append_right\n\n",
 "sublist_append_of_sublist_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_append_of_sublist_right {l l₁ l₂ : list α} (s : «expr <+ » l l₂) : «expr <+ » l (l₁ ++ l₂) :=\n  s.trans <| sublist_append_right _ _\n#align sublist_append_of_sublist_right sublist_append_of_sublist_right\n\n",
 "sublist_append_of_sublist_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_append_of_sublist_left {l l₁ l₂ : list α} (s : «expr <+ » l l₁) : «expr <+ » l (l₁ ++ l₂) :=\n  s.trans <| sublist_append_left _ _\n#align sublist_append_of_sublist_left sublist_append_of_sublist_left\n\n",
 "sublist_append_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem sublist_append_left : ∀ l₁ l₂ : list α, «expr <+ » l₁ (l₁ ++ l₂)\n  | [], l₂ => nil_sublist _\n  | a :: l₁, l₂ => (sublist_append_left l₁ l₂).cons_cons _\n#align sublist_append_left sublist_append_left\n\n",
 "split_on_p_spec":
 "/-- The original list `L` can be recovered by joining the lists produced by `split_on_p p L`,\ninterspersed with the elements `L.filter p`. -/\ntheorem split_on_p_spec (as : list α) :\n    join (zip_with (· ++ ·) (splitOnP p as) (((as.filter p).map fun x => [x]) ++ [[]])) = as :=\n  by\n  rw [split_on_p, split_on_p_aux_nil]\n  suffices\n    ∀ xs, join (zip_with (· ++ ·) (split_on_p_aux' p as xs) (((as.filter p).map fun x => [x]) ++ [[]])) = xs ++ as\n    by\n    rw [this]\n    rfl\n  induction as <;> intro <;> simp! only [split_on_p_aux', append_nil]\n  split_ifs <;> simp [zip_with, join, *]\n#align split_on_p_spec split_on_p_spec\n\n",
 "split_on_p_nil":
 "@[simp]\ntheorem split_on_p_nil : [].split_on_p p = [[]] :=\n  rfl\n#align split_on_p_nil split_on_p_nil\n\n",
 "split_on_p_ne_nil":
 "theorem split_on_p_ne_nil : xs.split_on_p p ≠ [] :=\n  [anonymous] _ _ id\n#align split_on_p_ne_nil split_on_p_ne_nil\n\n",
 "split_on_p_first":
 "/-- When a list of the form `[...xs, sep, ...as]` is split on `p`, the first element is `xs`,\n  assuming no element in `xs` satisfies `p` but `sep` does satisfy `p` -/\ntheorem split_on_p_first (h : ∀ x ∈ xs, ¬p x) (sep : α) (hsep : p sep) (as : list α) :\n    (xs ++ sep :: as).split_on_p p = xs :: as.split_on_p p :=\n  by\n  induction' xs with hd tl ih\n  · simp [hsep]\n  simp [h hd _, ih fun t ht => h t (or.inr ht)]\n#align split_on_p_first split_on_p_first\n\n",
 "split_on_p_eq_single":
 "/-- If no element satisfies `p` in the list `xs`, then `xs.split_on_p p = [xs]` -/\ntheorem split_on_p_eq_single (h : ∀ x ∈ xs, ¬p x) : xs.split_on_p p = [xs] :=\n  by\n  induction' xs with hd tl ih\n  · rfl\n  simp [h hd _, ih fun t ht => h t (or.inr ht)]\n#align split_on_p_eq_single split_on_p_eq_single\n\n",
 "split_on_p_cons":
 "@[simp]\ntheorem split_on_p_cons (x : α) (xs : list α) :\n    (x :: xs).split_on_p p = if p x then [] :: xs.split_on_p p else (xs.split_on_p p).modify_head (cons x) :=\n  by\n  simp only [split_on_p, split_on_p_aux]\n  split_ifs\n  · simp\n  rw [split_on_p_aux_spec]\n  rfl\n#align split_on_p_cons split_on_p_cons\n\n",
 "split_on_p_aux_spec":
 "theorem split_on_p_aux_spec : split_on_p_aux p xs f = (xs.split_on_p p).modify_head f :=\n  by\n  simp only [split_on_p]\n  induction' xs with hd tl ih generalizing f; · simp [split_on_p_aux]\n  simp only [split_on_p_aux]; split_ifs; · simp\n  rw [ih fun l => f (hd :: l), ih fun l => id (hd :: l)]\n  simp\n#align split_on_p_aux_spec split_on_p_aux_spec\n\n",
 "split_on_p_aux_nil":
 "theorem split_on_p_aux_nil : split_on_p_aux p xs id = [anonymous] p xs [] :=\n  by\n  rw [split_on_p_aux_eq]\n  rfl\n#align split_on_p_aux_nil split_on_p_aux_nil\n\n",
 "split_on_p_aux_ne_nil":
 "theorem split_on_p_aux_ne_nil : split_on_p_aux p xs f ≠ [] :=\n  by\n  induction' xs with _ _ ih generalizing f; · trivial\n  simp only [split_on_p_aux]; split_ifs; · trivial; exact ih _\n#align split_on_p_aux_ne_nil split_on_p_aux_ne_nil\n\n",
 "split_on_p_aux_eq":
 "theorem split_on_p_aux_eq : [anonymous] p xs ys = split_on_p_aux p xs ((· ++ ·) ys) :=\n  by\n  induction' xs with a t ih generalizing ys <;> simp! only [append_nil, eq_self_iff_true, and_self_iff]\n  split_ifs <;> rw [ih]\n  · refine' ⟨rfl, rfl⟩\n  · congr\n    ext\n    simp\n#align split_on_p_aux_eq split_on_p_aux_eq\n\n",
 "split_on_nil":
 "@[simp]\ntheorem split_on_nil {α : Type u} [decidable_eq α] (a : α) : [].split_on a = [[]] :=\n  rfl\n#align split_on_nil split_on_nil\n\n",
 "split_on_intercalate":
 "/-- `split_on x` is the left inverse of `intercalate [x]`, on the domain\n  consisting of each nonempty list of lists `ls` whose elements do not contain `x`  -/\ntheorem split_on_intercalate [decidable_eq α] (x : α) (hx : ∀ l ∈ ls, x ∉ l) (hls : ls ≠ []) :\n    ([x].intercalate ls).split_on x = ls := by\n  simp only [intercalate]\n  induction' ls with hd tl ih; · contradiction\n  cases tl\n  · suffices hd.split_on x = [hd] by simpa [join]\n    refine' split_on_p_eq_single _ _ _\n    intro y hy H\n    rw [H] at hy\n    refine' hx hd _ hy\n    simp\n  · simp only [intersperse_cons_cons, singleton_append, join]\n    specialize ih _ _\n    · intro l hl\n      apply hx l\n      simp at hl⊢\n      tauto\n    · trivial\n    have := split_on_p_first (· = x) hd _ x rfl _\n    · simp only [split_on] at ih⊢\n      rw [this]\n      rw [ih]\n    intro y hy H\n    rw [H] at hy\n    exact hx hd (or.inl rfl) hy\n#align split_on_intercalate split_on_intercalate\n\n",
 "split_at_eq_take_drop":
 "@[simp]\ntheorem split_at_eq_take_drop : ∀ (n : ℕ) (l : list α), splitAt n l = (take n l, drop n l)\n  | 0, a => rfl\n  | succ n, [] => rfl\n  | succ n, x :: xs => by simp only [split_at, split_at_eq_take_drop n xs, take, drop]\n#align split_at_eq_take_drop split_at_eq_take_drop\n\n",
 "span_eq_take_drop":
 "@[simp]\ntheorem span_eq_take_drop : ∀ l : list α, span p l = (takeWhile p l, dropWhile p l)\n  | [] => rfl\n  | a :: l =>\n    if pa : p a then by simp only [span, if_pos pa, span_eq_take_drop l, take_while, drop_while]\n    else by simp only [span, take_while, drop_while, if_neg pa]\n#align span_eq_take_drop span_eq_take_drop\n\n",
 "some_nth_le_eq":
 "theorem some_nth_le_eq {l : list α} {n : ℕ} {h} : some (l.nth_le n h) = l.nth n :=\n  by\n  symm\n  rw [nth_eq_some]\n  tauto\n#align some_nth_le_eq some_nth_le_eq\n\n",
 "slice_eq":
 "theorem slice_eq (xs : list α) (n m : ℕ) : dropSlice n m xs = xs.take n ++ xs.drop (n + m) :=\n  by\n  induction n generalizing xs\n  · simp [slice]\n  · cases xs <;> simp [slice, *, nat.succ_add]\n#align slice_eq slice_eq\n\n",
 "sizeof_slice_lt":
 "theorem sizeof_slice_lt [SizeOf α] (i j : ℕ) (hj : 0 < j) (xs : list α) (hi : i < xs.length) :\n    SizeOf.sizeOf (List.dropSlice i j xs) < SizeOf.sizeOf xs :=\n  by\n  induction xs generalizing i j\n  case nil i j h => cases hi\n  case cons x xs xs_ih i j h =>\n    cases i <;> simp only [-slice_eq, List.dropSlice]\n    · cases j\n      cases h\n      dsimp only [drop]\n      unfold_wf\n      apply @lt_of_le_of_lt _ _ _ xs.sizeof\n      · clear * -\n        induction xs generalizing j <;> unfold_wf\n        case nil j => rfl\n        case cons xs_hd xs_tl xs_ih j =>\n          cases j <;> unfold_wf; rfl\n          trans; apply xs_ih\n          simp\n      unfold_wf\n    · unfold_wf\n      apply xs_ih _ _ h\n      apply lt_of_succ_lt_succ hi\n#align sizeof_slice_lt sizeof_slice_lt\n\n",
 "sizeof_lt_sizeof_of_mem":
 "theorem sizeof_lt_sizeof_of_mem [SizeOf α] {x : α} {l : list α} (hx : x ∈ l) : SizeOf.sizeOf x < SizeOf.sizeOf l :=\n  by\n  induction' l with h t ih <;> cases hx\n  · rw [hx]\n    exact lt_add_of_lt_of_nonneg (lt_one_add _) (nat.zero_le _)\n  · exact lt_add_of_pos_of_le (zero_lt_one_add _) (le_of_lt (ih hx))\n#align sizeof_lt_sizeof_of_mem sizeof_lt_sizeof_of_mem\n\n",
 "singleton_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem singleton_sublist {a : α} {l} : «expr <+ » [a] l ↔ a ∈ l :=\n  ⟨fun h => h.subset (mem_singleton_self _), fun h =>\n    let ⟨s, t, e⟩ := mem_split h\n    e.symm ▸ ((nil_sublist _).cons_cons _).trans (sublist_append_right _ _)⟩\n#align singleton_sublist singleton_sublist\n\n",
 "singleton_injective":
 "theorem singleton_injective : injective fun a : α => [a] := fun a b h => (cons_eq_cons.1 h).1\n#align singleton_injective singleton_injective\n\n",
 "singleton_inj":
 "theorem singleton_inj {a b : α} : [a] = [b] ↔ a = b :=\n  singleton_injective.eq_iff\n#align singleton_inj singleton_inj\n\n",
 "singleton_eq":
 "theorem singleton_eq (x : α) : ({x} : list α) = [x] :=\n  rfl\n#align singleton_eq singleton_eq\n\n",
 "singleton_append":
 "@[simp]\ntheorem singleton_append {x : α} {l : list α} : [x] ++ l = x :: l :=\n  rfl\n#align singleton_append singleton_append\n\n",
 "set_of_mem_cons":
 "theorem set_of_mem_cons (l : list α) (a : α) : { x | x ∈ a :: l } = insert a { x | x ∈ l } :=\n  rfl\n#align set_of_mem_cons set_of_mem_cons\n\n",
 "scanr_nil":
 "-- scanr\n@[simp]\ntheorem scanr_nil (f : α → β → β) (b : β) : scanr f b [] = [b] :=\n  rfl\n#align scanr_nil scanr_nil\n\n",
 "scanr_cons":
 "@[simp]\ntheorem scanr_cons (f : α → β → β) (b : β) (a : α) (l : list α) :\n    scanr f b (a :: l) = foldr f b (a :: l) :: scanr f b l := by\n  simp only [scanr, scanr_aux_cons, foldr_cons] <;> constructor <;> rfl\n#align scanr_cons scanr_cons\n\n",
 "scanr_aux_cons":
 "@[simp]\ntheorem scanr_aux_cons (f : α → β → β) (b : β) :\n    ∀ (a : α) (l : list α), scanr_aux f b (a :: l) = (foldr f b (a :: l), scanr f b l)\n  | a, [] => rfl\n  | a, x :: l => by\n    let t := scanr_aux_cons x l\n    simp only [scanr, scanr_aux, t, foldr_cons]\n#align scanr_aux_cons scanr_aux_cons\n\n",
 "scanl_nil":
 "@[simp]\ntheorem scanl_nil (b : β) : scanl f b nil = [b] :=\n  rfl\n#align scanl_nil scanl_nil\n\n",
 "scanl_cons":
 "@[simp]\ntheorem scanl_cons : scanl f b (a :: l) = [b] ++ scanl f (f b a) l := by\n  simp only [scanl, eq_self_iff_true, singleton_append, and_self_iff]\n#align scanl_cons scanl_cons\n\n",
 "reverse_take":
 "theorem reverse_take {α} {xs : list α} (n : ℕ) (h : n ≤ xs.length) :\n    xs.reverse.take n = (xs.drop (xs.length - n)).reverse :=\n  by\n  induction xs generalizing n <;> simp only [reverse_cons, drop, reverse_nil, zero_tsub, length, take_nil]\n  cases' h.lt_or_eq_dec with h' h'\n  · replace h' := le_of_succ_le_succ h'\n    rwa [take_append_of_le_length, xs_ih _ h']\n    rw [show xs_tl.length + 1 - n = succ (xs_tl.length - n) from _, drop]\n    · rwa [succ_eq_add_one, ← tsub_add_eq_add_tsub]\n    · rwa [length_reverse]\n  · subst h'\n    rw [length, tsub_self, drop]\n    suffices xs_tl.length + 1 = (xs_tl.reverse ++ [xs_hd]).length by rw [this, take_length, reverse_cons]\n    rw [length_append, length_reverse]\n    rfl\n#align reverse_take reverse_take\n\n",
 "reverse_surjective":
 "theorem reverse_surjective : surjective (@reverse α) :=\n  reverse_involutive.surjective\n#align reverse_surjective reverse_surjective\n\n",
 "reverse_sublist_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem reverse_sublist_iff {l₁ l₂ : list α} : «expr <+ » l₁.reverse l₂.reverse ↔ «expr <+ » l₁ l₂ :=\n  ⟨fun h => l₁.reverse_reverse ▸ l₂.reverse_reverse ▸ h.reverse, Sublist.reverse⟩\n#align reverse_sublist_iff reverse_sublist_iff\n\n",
 "reverse_singleton":
 "@[simp]\ntheorem reverse_singleton (a : α) : reverse [a] = [a] :=\n  rfl\n#align reverse_singleton reverse_singleton\n\n",
 "reverse_reverse":
 "@[simp]\ntheorem reverse_reverse (l : list α) : reverse (reverse l) = l := by\n  induction l <;> [rfl, simp only [*, reverse_cons, reverse_append]] <;> rfl\n#align reverse_reverse reverse_reverse\n\n",
 "reverse_replicate":
 "@[simp]\ntheorem reverse_replicate (n) (a : α) : reverse (replicate n a) = replicate n a :=\n  eq_replicate.2 ⟨by rw [length_reverse, length_replicate], fun b h => eq_of_mem_replicate (mem_reverse'.1 h)⟩\n#align reverse_replicate reverse_replicate\n\n",
 "reverse_nil":
 "@[simp]\ntheorem reverse_nil : reverse (@nil α) = [] :=\n  rfl\n#align reverse_nil reverse_nil\n\n",
 "reverse_involutive":
 "@[simp]\ntheorem reverse_involutive : involutive (@reverse α) :=\n  reverse_reverse\n#align reverse_involutive reverse_involutive\n\n",
 "reverse_injective":
 "@[simp]\ntheorem reverse_injective : injective (@reverse α) :=\n  reverse_involutive.injective\n#align reverse_injective reverse_injective\n\n",
 "reverse_inj":
 "@[simp]\ntheorem reverse_inj {l₁ l₂ : list α} : reverse l₁ = reverse l₂ ↔ l₁ = l₂ :=\n  reverse_injective.eq_iff\n#align reverse_inj reverse_inj\n\n",
 "reverse_foldl":
 "@[simp]\ntheorem reverse_foldl {l : list α} : reverse (foldl (fun t h => h :: t) [] l) = l := by rw [← foldr_reverse] <;> simp\n#align reverse_foldl reverse_foldl\n\n",
 "reverse_eq_nil":
 "@[simp]\ntheorem reverse_eq_nil {l : list α} : reverse l = [] ↔ l = [] :=\n  @reverse_inj _ l []\n#align reverse_eq_nil reverse_eq_nil\n\n",
 "reverse_eq_iff":
 "theorem reverse_eq_iff {l l' : list α} : l.reverse = l' ↔ l = l'.reverse :=\n  reverse_involutive.eq_iff\n#align reverse_eq_iff reverse_eq_iff\n\n",
 "reverse_core_eq":
 "theorem reverse_core_eq (l₁ l₂ : list α) : reverseAux l₁ l₂ = reverse l₁ ++ l₂ := by\n  induction l₁ generalizing l₂ <;> [rfl, simp only [*, reverse_core, reverse_cons, append_assoc]] <;> rfl\n#align reverse_core_eq reverse_core_eq\n\n",
 "reverse_cons'":
 "theorem reverse_cons' (a : α) (l : list α) : reverse (a :: l) = concat (reverse l) a := by\n  simp only [reverse_cons, concat_eq_append]\n#align reverse_cons' reverse_cons'\n\n",
 "reverse_cons":
 "@[simp]\ntheorem reverse_cons (a : α) (l : list α) : reverse (a :: l) = reverse l ++ [a] :=\n  have aux : ∀ l₁ l₂, reverseAux l₁ l₂ ++ [a] = reverseAux l₁ (l₂ ++ [a]) := by\n    intro l₁ <;> induction l₁ <;> intros <;> [rfl, simp only [*, reverse_core, cons_append]]\n  (aux l nil).symm\n#align reverse_cons reverse_cons\n\n",
 "reverse_concat":
 "theorem reverse_concat (l : list α) (a : α) : reverse (concat l a) = a :: reverse l := by\n  rw [concat_eq_append, reverse_append, reverse_singleton, singleton_append]\n#align reverse_concat reverse_concat\n\n",
 "reverse_bijective":
 "theorem reverse_bijective : bijective (@reverse α) :=\n  reverse_involutive.bijective\n#align reverse_bijective reverse_bijective\n\n",
 "reverse_append":
 "@[simp]\ntheorem reverse_append (s t : list α) : reverse (s ++ t) = reverse t ++ reverse s := by\n  induction s <;> [rw [nil_append, reverse_nil, append_nil], simp only [*, cons_append, reverse_cons, append_assoc]]\n#align reverse_append reverse_append\n\n",
 "reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.reverse {l₁ l₂ : list α} (h : «expr <+ » l₁ l₂) : «expr <+ » l₁.reverse l₂.reverse :=\n  by\n  induction' h with _ _ _ _ ih _ _ a _ ih; · rfl\n  · rw [reverse_cons]\n    exact sublist_append_of_sublist_left ih\n  · rw [reverse_cons, reverse_cons]\n    exact ih.append_right [a]\n#align sublist.reverse sublist.reverse\n\n",
 "replicate_zero":
 "@[simp]\ntheorem replicate_zero (a : α) : replicate 0 a = [] :=\n  rfl\n#align replicate_zero replicate_zero\n\n",
 "replicate_succ'":
 "theorem replicate_succ' (n) (a : α) : replicate (n + 1) a = replicate n a ++ [a] :=\n  replicate_add n 1 a\n#align replicate_succ' replicate_succ'\n\n",
 "replicate_succ":
 "@[simp]\ntheorem replicate_succ (a : α) (n) : replicate (n + 1) a = a :: replicate n a :=\n  rfl\n#align replicate_succ replicate_succ\n\n",
 "replicate_subset_singleton":
 "theorem replicate_subset_singleton (n) (a : α) : replicate n a ⊆ [a] := fun b h =>\n  mem_singleton.2 (eq_of_mem_replicate h)\n#align replicate_subset_singleton replicate_subset_singleton\n\n",
 "replicate_sublist_replicate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem replicate_sublist_replicate (a : α) {m n} : «expr <+ » (replicate m a) (replicate n a) ↔ m ≤ n :=\n  ⟨fun h => by simpa only [length_replicate] using h.length_le, fun h => by\n    induction h <;> [rfl, simp only [*, replicate_succ, sublist.cons]]⟩\n#align replicate_sublist_replicate replicate_sublist_replicate\n\n",
 "replicate_right_injective":
 "theorem replicate_right_injective {n : ℕ} (hn : n ≠ 0) : injective (replicate n : α → list α) := fun _ _ h =>\n  (eq_replicate.1 h).2 _ <| mem_replicate.2 ⟨hn, rfl⟩\n#align replicate_right_injective replicate_right_injective\n\n",
 "replicate_right_inj'":
 "@[simp]\ntheorem replicate_right_inj' {a b : α} : ∀ {n}, replicate n a = replicate n b ↔ n = 0 ∨ a = b\n  | 0 => by simp\n  | n + 1 => (replicate_right_inj n.succ_ne_zero).trans <| by simp only [n.succ_ne_zero, false_or_iff]\n#align replicate_right_inj' replicate_right_inj'\n\n",
 "replicate_right_inj":
 "theorem replicate_right_inj {a b : α} {n : ℕ} (hn : n ≠ 0) : replicate n a = replicate n b ↔ a = b :=\n  (replicate_right_injective hn).eq_iff\n#align replicate_right_inj replicate_right_inj\n\n",
 "replicate_one":
 "theorem replicate_one (a : α) : replicate 1 a = [a] :=\n  rfl\n#align replicate_one replicate_one\n\n",
 "replicate_left_injective":
 "theorem replicate_left_injective (a : α) : injective fun n => replicate n a :=\n  left_inverse.injective fun n => length_replicate n a\n#align replicate_left_injective replicate_left_injective\n\n",
 "replicate_left_inj":
 "@[simp]\ntheorem replicate_left_inj {a : α} {n m : ℕ} : replicate n a = replicate m a ↔ n = m :=\n  (replicate_left_injective a).eq_iff\n#align replicate_left_inj replicate_left_inj\n\n",
 "replicate_add":
 "theorem replicate_add (m n) (a : α) : replicate (m + n) a = replicate m a ++ replicate n a := by\n  induction m <;> simp only [*, zero_add, succ_add, replicate] <;> rfl\n#align replicate_add replicate_add\n\n",
 "remove_nth_insert_nth":
 "theorem remove_nth_insert_nth (n : ℕ) (l : list α) : (l.insert_nth n a).remove_nth n = l := by\n  rw [remove_nth_eq_nth_tail, insert_nth, modify_nth_tail_modify_nth_tail_same] <;> exact modify_nth_tail_id _ _\n#align remove_nth_insert_nth remove_nth_insert_nth\n\n",
 "remove_nth_eq_nth_tail":
 "theorem remove_nth_eq_nth_tail : ∀ (n) (l : list α), remove_nth l n = modifyNthTail tail n l\n  | 0, l => by cases l <;> rfl\n  | n + 1, [] => rfl\n  | n + 1, a :: l => congr_arg (cons _) (remove_nth_eq_nth_tail _ _)\n#align remove_nth_eq_nth_tail remove_nth_eq_nth_tail\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[refl, simp]\ntheorem sublist.refl : ∀ l : list α, «expr <+ » l l\n  | [] => sublist.slnil\n  | a :: l => Sublist.cons₂ _ _ a (sublist.refl l)\n#align sublist.refl sublist.refl\n\n",
 "reduce_option_singleton":
 "theorem reduce_option_singleton (x : option α) : [x].reduce_option = x.to_list := by cases x <;> rfl\n#align reduce_option_singleton reduce_option_singleton\n\n",
 "reduce_option_nth_iff":
 "theorem reduce_option_nth_iff {l : list (option α)} {x : α} :\n    (∃ i, l.nth i = some (some x)) ↔ ∃ i, l.reduce_option.nth i = some x := by\n  rw [← mem_iff_nth, ← mem_iff_nth, reduce_option_mem_iff]\n#align reduce_option_nth_iff reduce_option_nth_iff\n\n",
 "reduce_option_nil":
 "@[simp]\ntheorem reduce_option_nil : @reduceOption α [] = [] :=\n  rfl\n#align reduce_option_nil reduce_option_nil\n\n",
 "reduce_option_mem_iff":
 "theorem reduce_option_mem_iff {l : list (option α)} {x : α} : x ∈ l.reduce_option ↔ some x ∈ l := by\n  simp only [reduce_option, id.def, mem_filter_map, exists_eq_right]\n#align reduce_option_mem_iff reduce_option_mem_iff\n\n",
 "reduce_option_map":
 "@[simp]\ntheorem reduce_option_map {l : list (option α)} {f : α → β} :\n    reduceOption (map (option.map f) l) = map f (reduceOption l) :=\n  by\n  induction' l with hd tl hl\n  · simp only [reduce_option_nil, map_nil]\n  · cases hd <;> simpa only [true_and_iff, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl\n#align reduce_option_map reduce_option_map\n\n",
 "reduce_option_length_lt_iff":
 "theorem reduce_option_length_lt_iff {l : list (option α)} : l.reduce_option.length < l.length ↔ none ∈ l :=\n  by\n  rw [(reduce_option_length_le l).lt_iff_ne, ne, reduce_option_length_eq_iff]\n  induction l <;> simp [*]\n  rw [eq_comm, ← Option.not_isSome_iff_eq_none, decidable.imp_iff_not_or]\n#align reduce_option_length_lt_iff reduce_option_length_lt_iff\n\n",
 "reduce_option_length_le":
 "theorem reduce_option_length_le (l : list (option α)) : l.reduce_option.length ≤ l.length :=\n  by\n  induction' l with hd tl hl\n  · simp only [reduce_option_nil, length]\n  · cases hd\n    · exact nat.le_succ_of_le hl\n    · simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl\n#align reduce_option_length_le reduce_option_length_le\n\n",
 "reduce_option_length_eq_iff":
 "theorem reduce_option_length_eq_iff {l : list (option α)} :\n    l.reduce_option.length = l.length ↔ ∀ x ∈ l, option.is_some x :=\n  by\n  induction' l with hd tl hl\n  ·\n    simp only [forall_const, reduce_option_nil, not_mem_nil, forall_prop_of_false, eq_self_iff_true, length,\n      not_false_iff]\n  · cases hd\n    · simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and_iff, reduce_option_cons_of_none, length,\n        Option.isSome_none, iff_false_iff]\n      intro H\n      have := reduce_option_length_le tl\n      rw [H] at this\n      exact absurd (nat.lt_succ_self _) (not_lt_of_le this)\n    ·\n      simp only [hl, true_and_iff, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length,\n        Option.isSome_some, reduce_option_cons_of_some]\n#align reduce_option_length_eq_iff reduce_option_length_eq_iff\n\n",
 "reduce_option_cons_of_some":
 "@[simp]\ntheorem reduce_option_cons_of_some (x : α) (l : list (option α)) : reduceOption (some x :: l) = x :: l.reduce_option :=\n  by simp only [reduce_option, filter_map, id.def, eq_self_iff_true, and_self_iff]\n#align reduce_option_cons_of_some reduce_option_cons_of_some\n\n",
 "reduce_option_cons_of_none":
 "@[simp]\ntheorem reduce_option_cons_of_none (l : list (option α)) : reduceOption (none :: l) = l.reduce_option := by\n  simp only [reduce_option, filter_map, id.def]\n#align reduce_option_cons_of_none reduce_option_cons_of_none\n\n",
 "reduce_option_concat_of_some":
 "theorem reduce_option_concat_of_some (l : list (option α)) (x : α) :\n    (l.concat (some x)).reduce_option = l.reduce_option.concat x := by\n  simp only [reduce_option_nil, concat_eq_append, reduce_option_append, reduce_option_cons_of_some]\n#align reduce_option_concat_of_some reduce_option_concat_of_some\n\n",
 "reduce_option_concat":
 "theorem reduce_option_concat (l : list (option α)) (x : option α) :\n    (l.concat x).reduce_option = l.reduce_option ++ x.to_list :=\n  by\n  induction' l with hd tl hl generalizing x\n  · cases x <;> simp [option.to_list]\n  · simp only [concat_eq_append, reduce_option_append] at hl\n    cases hd <;> simp [hl, reduce_option_append]\n#align reduce_option_concat reduce_option_concat\n\n",
 "reduce_option_append":
 "theorem reduce_option_append (l l' : list (option α)) : (l ++ l').reduce_option = l.reduce_option ++ l'.reduce_option :=\n  filterMap_append l l' id\n#align reduce_option_append reduce_option_append\n\n",
 "pmap_map":
 "theorem pmap_map {p : β → Prop} (g : ∀ b, p b → γ) (f : α → β) (l H) :\n    pmap g (map f l) H = pmap (fun a h => g (f a) h) l fun a h => H _ (mem_map_of_mem _ h) := by\n  induction l <;> [rfl, simp only [*, pmap, map]] <;> constructor <;> rfl\n#align pmap_map pmap_map\n\n",
 "pmap_eq_nil":
 "@[simp]\ntheorem pmap_eq_nil {p : α → Prop} {f : ∀ a, p a → β} {l H} : pmap f l H = [] ↔ l = [] := by\n  rw [← length_eq_zero, length_pmap, length_eq_zero]\n#align pmap_eq_nil pmap_eq_nil\n\n",
 "pmap_eq_map_attach":
 "theorem pmap_eq_map_attach {p : α → Prop} (f : ∀ a, p a → β) (l H) :\n    pmap f l H = l.attach.map fun x => f x.1 (H _ x.2) := by\n  rw [attach, map_pmap] <;> exact pmap_congr l fun _ _ _ _ => rfl\n#align pmap_eq_map_attach pmap_eq_map_attach\n\n",
 "pmap_eq_map":
 "@[simp]\ntheorem pmap_eq_map (p : α → Prop) (f : α → β) (l : list α) (H) : @pmap _ _ p (fun a _ => f a) l H = map f l := by\n  induction l <;> [rfl, simp only [*, pmap, map]] <;> constructor <;> rfl\n#align pmap_eq_map pmap_eq_map\n\n",
 "pmap_congr":
 "theorem pmap_congr {p q : α → Prop} {f : ∀ a, p a → β} {g : ∀ a, q a → β} (l : list α) {H₁ H₂}\n    (h : ∀ a ∈ l, ∀ (h₁ h₂), f a h₁ = g a h₂) : pmap f l H₁ = pmap g l H₂ :=\n  by\n  induction' l with _ _ ih\n  · rfl\n  · rw [pmap, pmap, h _ (mem_cons_self _ _), ih fun a ha => h a (mem_cons_of_mem _ ha)]\n#align pmap_congr pmap_congr\n\n",
 "pmap_append'":
 "theorem pmap_append' {α β : Type _} {p : α → Prop} (f : ∀ a : α, p a → β) (l₁ l₂ : list α) (h₁ : ∀ a ∈ l₁, p a)\n    (h₂ : ∀ a ∈ l₂, p a) :\n    ((l₁ ++ l₂).pmap f fun a ha => (list.mem_append.1 ha).elim (h₁ a) (h₂ a)) = l₁.pmap f h₁ ++ l₂.pmap f h₂ :=\n  pmap_append f l₁ l₂ _\n#align pmap_append' pmap_append'\n\n",
 "pmap_append":
 "theorem pmap_append {p : ι → Prop} (f : ∀ a : ι, p a → α) (l₁ l₂ : list ι) (h : ∀ a ∈ l₁ ++ l₂, p a) :\n    (l₁ ++ l₂).pmap f h =\n      (l₁.pmap f fun a ha => h a (mem_append_left l₂ ha)) ++ l₂.pmap f fun a ha => h a (mem_append_right l₁ ha) :=\n  by\n  induction' l₁ with _ _ ih\n  · rfl\n  · dsimp only [pmap, cons_append]\n    rw [ih]\n#align pmap_append pmap_append\n\n",
 "or_exists_of_exists_mem_cons":
 "theorem or_exists_of_exists_mem_cons {p : α → Prop} {a : α} {l : list α} (h : ∃ x ∈ a :: l, p x) : p a ∨ ∃ x ∈ l, p x :=\n  BEx.elim h fun x xal px =>\n    or.elim (eq_or_mem_of_mem_cons xal) (fun this : x = a => by rw [← this]; left; exact px) fun this : x ∈ l =>\n      or.inr (BEx.intro x this px)\n#align or_exists_of_exists_mem_cons or_exists_of_exists_mem_cons\n\n",
 "of_mem_filter":
 "theorem of_mem_filter {a : α} : ∀ {l}, a ∈ filter p l → p a\n  | b :: l, ain =>\n    if pb : p b then\n      have : a ∈ b :: filter p l := by simpa only [filter_cons_of_pos _ pb] using ain\n      or.elim (eq_or_mem_of_mem_cons this) (fun this : a = b => by rw [← this] at pb; exact pb)\n        fun this : a ∈ filter p l => of_mem_filter this\n    else by simp only [filter_cons_of_neg _ pb] at ain; exact of_mem_filter ain\n#align of_mem_filter of_mem_filter\n\n",
 "nthd_singleton_default_eq":
 "@[simp]\ntheorem nthd_singleton_default_eq (n : ℕ) : [d].nthd n d = d := by cases n <;> simp\n#align nthd_singleton_default_eq nthd_singleton_default_eq\n\n",
 "nthd_replicate_default_eq":
 "@[simp]\ntheorem nthd_replicate_default_eq (r n : ℕ) : (replicate r d).nthd n d = d :=\n  by\n  induction' r with r IH generalizing n\n  · simp\n  · cases n <;> simp [IH]\n#align nthd_replicate_default_eq nthd_replicate_default_eq\n\n",
 "nthd_nil":
 "@[simp]\ntheorem nthd_nil : getD [] n d = d :=\n  rfl\n#align nthd_nil nthd_nil\n\n",
 "nthd_eq_nth_le":
 "theorem nthd_eq_nth_le {n : ℕ} (hn : n < l.length) : l.nthd n d = l.nth_le n hn :=\n  by\n  induction' l with hd tl IH generalizing n\n  · exact absurd hn (not_lt_of_ge (nat.zero_le _))\n  · cases n\n    · exact nthd_cons_zero _ _ _\n    · exact IH _\n#align nthd_eq_nth_le nthd_eq_nth_le\n\n",
 "nthd_eq_get_or_else_nth":
 "theorem nthd_eq_get_or_else_nth (n : ℕ) : l.nthd n d = (l.nth n).get_or_else d :=\n  by\n  cases' lt_or_le _ _ with h h\n  · rw [nthd_eq_nth_le _ _ h, nth_le_nth h, option.get_or_else_some]\n  · rw [nthd_eq_default _ _ h, nth_eq_none_iff.mpr h, option.get_or_else_none]\n#align nthd_eq_get_or_else_nth nthd_eq_get_or_else_nth\n\n",
 "nthd_eq_default":
 "theorem nthd_eq_default {n : ℕ} (hn : l.length ≤ n) : l.nthd n d = d :=\n  by\n  induction' l with hd tl IH generalizing n\n  · exact nthd_nil _ _\n  · cases n\n    · refine' absurd (nat.zero_lt_succ _) (not_lt_of_ge hn)\n    · exact IH (nat.le_of_succ_le_succ hn)\n#align nthd_eq_default nthd_eq_default\n\n",
 "nthd_default_eq_inth":
 "theorem nthd_default_eq_inth : l.nthd n default = l.inth n :=\n  rfl\n#align nthd_default_eq_inth nthd_default_eq_inth\n\n",
 "nthd_cons_zero":
 "@[simp]\ntheorem nthd_cons_zero : getD (x :: xs) 0 d = x :=\n  rfl\n#align nthd_cons_zero nthd_cons_zero\n\n",
 "nthd_cons_succ":
 "@[simp]\ntheorem nthd_cons_succ : getD (x :: xs) (n + 1) d = getD xs n d :=\n  rfl\n#align nthd_cons_succ nthd_cons_succ\n\n",
 "nthd_append_right":
 "theorem nthd_append_right (l l' : list α) (d : α) (n : ℕ) (h : l.length ≤ n) :\n    (l ++ l').nthd n d = l'.nthd (n - l.length) d :=\n  by\n  cases' lt_or_le _ _ with h' h'\n  · rw [nthd_eq_nth_le _ _ h', nth_le_append_right h h', nthd_eq_nth_le]\n  · rw [nthd_eq_default _ _ h', nthd_eq_default]\n    rwa [le_tsub_iff_left h, ← length_append]\n#align nthd_append_right nthd_append_right\n\n",
 "nthd_append":
 "theorem nthd_append (l l' : list α) (d : α) (n : ℕ) (h : n < l.length)\n    (h' : n < (l ++ l').length := h.trans_le ((length_append l l').symm ▸ le_self_add)) :\n    (l ++ l').nthd n d = l.nthd n d := by rw [nthd_eq_nth_le _ _ h', nth_le_append h' h, nthd_eq_nth_le]\n#align nthd_append nthd_append\n\n",
 "nth_zero_scanl":
 "@[simp]\ntheorem nth_zero_scanl : (scanl f b l).nth 0 = some b :=\n  by\n  cases l\n  · simp only [nth, scanl_nil]\n  · simp only [nth, scanl_cons, singleton_append]\n#align nth_zero_scanl nth_zero_scanl\n\n",
 "nth_zero":
 "theorem nth_zero (l : list α) : l.nth 0 = l.head' := by cases l <;> rfl\n#align nth_zero nth_zero\n\n",
 "nth_update_nth_of_lt":
 "theorem nth_update_nth_of_lt (a : α) {n} {l : list α} (h : n < length l) : get? (set l n a) n = some a := by\n  rw [nth_update_nth_eq, nth_le_nth h] <;> rfl\n#align nth_update_nth_of_lt nth_update_nth_of_lt\n\n",
 "nth_update_nth_ne":
 "theorem nth_update_nth_ne (a : α) {m n} (l : list α) (h : m ≠ n) : get? (set l m a) n = get? l n := by\n  simp only [update_nth_eq_modify_nth, nth_modify_nth_ne _ _ h]\n#align nth_update_nth_ne nth_update_nth_ne\n\n",
 "nth_update_nth_eq":
 "theorem nth_update_nth_eq (a : α) (n) (l : list α) : get? (set l n a) n = (fun _ => a) <$> get? l n := by\n  simp only [update_nth_eq_modify_nth, nth_modify_nth_eq]\n#align nth_update_nth_eq nth_update_nth_eq\n\n",
 "nth_take_of_succ":
 "@[simp]\ntheorem nth_take_of_succ {l : list α} {n : ℕ} : (l.take (n + 1)).nth n = l.nth n :=\n  get?_take (nat.lt_succ_self n)\n#align nth_take_of_succ nth_take_of_succ\n\n",
 "nth_take":
 "theorem nth_take {l : list α} {n m : ℕ} (h : m < n) : (l.take n).nth m = l.nth m :=\n  by\n  induction' n with n hn generalizing l m\n  · simp only [Nat.zero_eq] at h\n    exact absurd h (not_lt_of_le m.zero_le)\n  · cases' l with hd tl\n    · simp only [take_nil]\n    · cases m\n      · simp only [nth, take]\n      · simpa only using hn (nat.lt_of_succ_lt_succ h)\n#align nth_take nth_take\n\n",
 "nth_succ_scanl":
 "theorem nth_succ_scanl {i : ℕ} :\n    (scanl f b l).nth (i + 1) = ((scanl f b l).nth i).bind fun x => (l.nth i).map fun y => f x y :=\n  by\n  induction' l with hd tl hl generalizing b i\n  · symm\n    simp only [option.bind_eq_none', nth, forall₂_true_iff, not_false_iff, option.map_none', scanl_nil,\n      option.not_mem_none, forall_true_iff]\n  · simp only [nth, scanl_cons, singleton_append]\n    cases i\n    · simp only [option.map_some', nth_zero_scanl, nth, option.some_bind']\n    · simp only [hl, nth]\n#align nth_succ_scanl nth_succ_scanl\n\n",
 "nth_pmap":
 "theorem nth_pmap {p : α → Prop} (f : ∀ a, p a → β) {l : list α} (h : ∀ a ∈ l, p a) (n : ℕ) :\n    get? (pmap f l h) n = option.pmap f (get? l n) fun x H => h x (get?_mem H) :=\n  by\n  induction' l with hd tl hl generalizing n\n  · simp\n  · cases n <;> simp [hl]\n#align nth_pmap nth_pmap\n\n",
 "nth_of_mem":
 "theorem nth_of_mem {a} {l : list α} (h : a ∈ l) : ∃ n, get? l n = some a :=\n  let ⟨n, h, e⟩ := nthLe_of_mem h\n  ⟨n, by rw [nth_le_nth, e]⟩\n#align nth_of_mem nth_of_mem\n\n",
 "nth_modify_nth_ne":
 "@[simp]\ntheorem nth_modify_nth_ne (f : α → α) {m n} (l : list α) (h : m ≠ n) : get? (modifyNth f m l) n = get? l n := by\n  simp only [nth_modify_nth, if_neg h, id_map']\n#align nth_modify_nth_ne nth_modify_nth_ne\n\n",
 "nth_modify_nth_eq":
 "@[simp]\ntheorem nth_modify_nth_eq (f : α → α) (n) (l : list α) : get? (modifyNth f n l) n = f <$> get? l n := by\n  simp only [nth_modify_nth, if_pos]\n#align nth_modify_nth_eq nth_modify_nth_eq\n\n",
 "nth_modify_nth":
 "theorem nth_modify_nth (f : α → α) :\n    ∀ (n) (l : list α) (m), get? (modifyNth f n l) m = (fun a => if n = m then f a else a) <$> get? l m\n  | n, l, 0 => by cases l <;> cases n <;> rfl\n  | n, [], m + 1 => by cases n <;> rfl\n  | 0, a :: l, m + 1 => by cases nth l m <;> rfl\n  | n + 1, a :: l, m + 1 =>\n    (nth_modify_nth n l m).trans <| by\n      cases' nth l m with b <;> by_cases n = m <;>\n        simp only [h, if_pos, if_true, if_false, option.map_none, option.map_some, mt succ.inj, not_false_iff]\n#align nth_modify_nth nth_modify_nth\n\n",
 "nth_mem":
 "theorem nth_mem {l : list α} {n a} (e : get? l n = some a) : a ∈ l :=\n  let ⟨h, e⟩ := get?_eq_some'.1 e\n  e ▸ nthLe_mem _ _ _\n#align nth_mem nth_mem\n\n",
 "nth_map":
 "@[simp]\ntheorem nth_map (f : α → β) : ∀ l n, get? (map f l) n = (get? l n).map f\n  | [], n => rfl\n  | a :: l, 0 => rfl\n  | a :: l, n + 1 => nth_map l n\n#align nth_map nth_map\n\n",
 "nth_length":
 "@[simp]\ntheorem nth_length (l : list α) : l.nth l.length = none :=\n  get?_len_le le_rfl\n#align nth_length nth_length\n\n",
 "nth_len_le":
 "theorem nth_len_le : ∀ {l : list α} {n}, length l ≤ n → get? l n = none\n  | [], n, h => rfl\n  | a :: l, n + 1, h => nth_len_le (le_of_succ_le_succ h)\n#align nth_len_le nth_len_le\n\n",
 "nth_le_zero_scanl":
 "@[simp]\ntheorem nth_le_zero_scanl {h : 0 < (scanl f b l).length} : (scanl f b l).nth_le 0 h = b :=\n  by\n  cases l\n  · simp only [nth_le, scanl_nil]\n  · simp only [nth_le, scanl_cons, singleton_append]\n#align nth_le_zero_scanl nth_le_zero_scanl\n\n",
 "nth_le_zero":
 "theorem nth_le_zero [inhabited α] {L : list α} (h : 0 < L.length) : L.nth_le 0 h = L.head :=\n  by\n  cases L\n  cases h\n  simp\n#align nth_le_zero nth_le_zero\n\n",
 "nth_le_update_nth_of_ne":
 "@[simp]\ntheorem nth_le_update_nth_of_ne {l : list α} {i j : ℕ} (h : i ≠ j) (a : α) (hj : j < (l.update_nth i a).length) :\n    (l.update_nth i a).nth_le j hj = l.nth_le j (by simpa using hj) := by\n  rw [← option.some_inj, ← List.nthLe_get?, List.get?_set_ne _ _ h, List.nthLe_get?]\n#align nth_le_update_nth_of_ne nth_le_update_nth_of_ne\n\n",
 "nth_le_update_nth_eq":
 "@[simp]\ntheorem nth_le_update_nth_eq (l : list α) (i : ℕ) (a : α) (h : i < (l.update_nth i a).length) :\n    (l.update_nth i a).nth_le i h = a := by\n  rw [← option.some_inj, ← nth_le_nth, nth_update_nth_eq, nth_le_nth] <;> simp_all\n#align nth_le_update_nth_eq nth_le_update_nth_eq\n\n",
 "nth_le_take'":
 "/-- The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the small list to the big list. -/\ntheorem nth_le_take' (L : list α) {i j : ℕ} (hi : i < (L.take j).length) :\n    nthLe (L.take j) i hi = nthLe L i (lt_of_lt_of_le hi (by simp [le_refl])) :=\n  by\n  simp at hi\n  rw [nth_le_take L _ hi.1]\n#align nth_le_take' nth_le_take'\n\n",
 "nth_le_take":
 "/-- The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the big list to the small list. -/\ntheorem nth_le_take (L : list α) {i j : ℕ} (hi : i < L.length) (hj : i < j) :\n    nthLe L i hi =\n      nthLe (L.take j) i\n        (by\n          rw [length_take]\n          exact lt_min hj hi) :=\n  by\n  rw [nth_le_of_eq (take_append_drop j L).symm hi]\n  exact nth_le_append _ _\n#align nth_le_take nth_le_take\n\n",
 "nth_le_tail":
 "@[simp]\ntheorem nth_le_tail (l : list α) (i) (h : i < l.tail.length)\n    (h' : i + 1 < l.length := (by simpa [← lt_tsub_iff_right] using h)) : l.tail.nth_le i h = l.nth_le (i + 1) h' :=\n  by\n  cases l\n  · cases h\n  · simpa\n#align nth_le_tail nth_le_tail\n\n",
 "nth_le_succ_scanl":
 "theorem nth_le_succ_scanl {i : ℕ} {h : i + 1 < (scanl f b l).length} :\n    (scanl f b l).nth_le (i + 1) h =\n      f ((scanl f b l).nth_le i (nat.lt_of_succ_lt h))\n        (l.nth_le i (nat.lt_of_succ_lt_succ (lt_of_lt_of_le h (le_of_eq (length_scanl b l))))) :=\n  by\n  induction' i with i hi generalizing b l\n  · cases l\n    · simp only [length, zero_add, scanl_nil] at h\n      exact absurd h (lt_irrefl 1)\n    · simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le]\n  · cases l\n    · simp only [length, add_lt_iff_neg_right, scanl_nil] at h\n      exact absurd h (not_lt_of_lt Nat.succ_pos')\n    · simp_rw [scanl_cons]\n      rw [nth_le_append_right _]\n      · simpa only [hi, length, succ_add_sub_one]\n      · simp only [length, nat.zero_le, le_add_iff_nonneg_left]\n#align nth_le_succ_scanl nth_le_succ_scanl\n\n",
 "nth_le_singleton":
 "@[simp]\ntheorem nth_le_singleton (a : α) {n : ℕ} (hn : n < 1) : nthLe [a] n hn = a :=\n  by\n  have hn0 : n = 0 := nat.eq_zero_of_le_zero (le_of_lt_succ hn)\n  subst hn0 <;> rfl\n#align nth_le_singleton nth_le_singleton\n\n",
 "nth_le_reverse_aux2":
 "theorem nth_le_reverse_aux2 :\n    ∀ (l r : list α) (i : nat) (h1) (h2), nthLe (reverseAux l r) (length l - 1 - i) h1 = nthLe l i h2\n  | [], r, i, h1, h2 => absurd h2 (nat.not_lt_zero _)\n  | a :: l, r, 0, h1, h2 => by\n    have aux := nth_le_reverse_aux1 l (a :: r) 0\n    rw [zero_add] at aux\n    exact aux _ (zero_lt_succ _)\n  | a :: l, r, i + 1, h1, h2 => by\n    have aux := nth_le_reverse_aux2 l (a :: r) i\n    have heq :=\n      calc\n        length (a :: l) - 1 - (i + 1) = length l - (1 + i) := by rw [add_comm] <;> rfl\n        _ = length l - 1 - i := by rw [← tsub_add_eq_tsub_tsub]\n        \n    rw [← HEq] at aux\n    apply aux\n#align nth_le_reverse_aux2 nth_le_reverse_aux2\n\n",
 "nth_le_reverse_aux1":
 "theorem nth_le_reverse_aux1 : ∀ (l r : list α) (i h1 h2), nthLe (reverseAux l r) (i + length l) h1 = nthLe r i h2\n  | [], r, i => fun h1 h2 => rfl\n  | a :: l, r, i => by\n    rw [show i + length (a :: l) = i + 1 + length l from add_right_comm i (length l) 1] <;>\n      exact fun h1 h2 => nth_le_reverse_aux1 l (a :: r) (i + 1) h1 (succ_lt_succ h2)\n#align nth_le_reverse_aux1 nth_le_reverse_aux1\n\n",
 "nth_le_reverse'":
 "theorem nth_le_reverse' (l : list α) (n : ℕ) (hn : n < l.reverse.length) (hn') :\n    l.reverse.nth_le n hn = l.nth_le (l.length - 1 - n) hn' :=\n  by\n  rw [eq_comm]\n  convert nth_le_reverse l.reverse _ _ _ using 1\n  · simp\n  · simpa\n#align nth_le_reverse' nth_le_reverse'\n\n",
 "nth_le_reverse":
 "@[simp]\ntheorem nth_le_reverse (l : list α) (i : nat) (h1 h2) : nthLe (reverse l) (length l - 1 - i) h1 = nthLe l i h2 :=\n  get_reverse_aux₂ _ _ _ _ _\n#align nth_le_reverse nth_le_reverse\n\n",
 "nth_le_replicate":
 "@[simp]\ntheorem nth_le_replicate (a : α) {n m : ℕ} (h : m < (list.replicate n a).length) :\n    (list.replicate n a).nth_le m h = a :=\n  eq_of_mem_replicate (nthLe_mem _ _ _)\n#align nth_le_replicate nth_le_replicate\n\n",
 "nth_le_pmap":
 "theorem nth_le_pmap {p : α → Prop} (f : ∀ a, p a → β) {l : list α} (h : ∀ a ∈ l, p a) {n : ℕ}\n    (hn : n < (pmap f l h).length) :\n    nthLe (pmap f l h) n hn =\n      f (nthLe l n (@length_pmap _ _ p f l h ▸ hn)) (h _ (nthLe_mem l n (@length_pmap _ _ p f l h ▸ hn))) :=\n  by\n  induction' l with hd tl hl generalizing n\n  · simp only [length, pmap] at hn\n    exact absurd hn (not_lt_of_le n.zero_le)\n  · cases n\n    · simp\n    · simpa [hl]\n#align nth_le_pmap nth_le_pmap\n\n",
 "nth_le_of_mem":
 "theorem nth_le_of_mem : ∀ {a} {l : list α}, a ∈ l → ∃ n h, nthLe l n h = a\n  | a, _ :: l, or.inl rfl => ⟨0, succ_pos _, rfl⟩\n  | a, b :: l, or.inr m =>\n    let ⟨n, h, e⟩ := nth_le_of_mem m\n    ⟨n + 1, succ_lt_succ h, e⟩\n#align nth_le_of_mem nth_le_of_mem\n\n",
 "nth_le_of_eq":
 "/-- If one has `nth_le L i hi` in a formula and `h : L = L'`, one can not `rw h` in the formula as\n`hi` gives `i < L.length` and not `i < L'.length`. The lemma `nth_le_of_eq` can be used to make\nsuch a rewrite, with `rw (nth_le_of_eq h)`. -/\ntheorem nth_le_of_eq {L L' : list α} (h : L = L') {i : ℕ} (hi : i < L.length) : nthLe L i hi = nthLe L' i (h ▸ hi) :=\n  by\n  congr\n  exact h\n#align nth_le_of_eq nth_le_of_eq\n\n",
 "nth_le_nth":
 "theorem nth_le_nth : ∀ {l : list α} {n} (h), get? l n = some (nthLe l n h)\n  | a :: l, 0, h => rfl\n  | a :: l, n + 1, h => @nth_le_nth l n _\n#align nth_le_nth nth_le_nth\n\n",
 "nth_le_mem":
 "theorem nth_le_mem : ∀ (l : list α) (n h), nthLe l n h ∈ l\n  | a :: l, 0, h => mem_cons_self _ _\n  | a :: l, n + 1, h => mem_cons_of_mem _ (nth_le_mem l _ _)\n#align nth_le_mem nth_le_mem\n\n",
 "nth_le_map_rev":
 "/-- A version of `nth_le_map` that can be used for rewriting. -/\ntheorem nth_le_map_rev (f : α → β) {l n} (H) : f (nthLe l n H) = nthLe (map f l) n ((length_map f l).symm ▸ H) :=\n  (nthLe_map f _ _).symm\n#align nth_le_map_rev nth_le_map_rev\n\n",
 "nth_le_map'":
 "@[simp]\ntheorem nth_le_map' (f : α → β) {l n} (H) : nthLe (map f l) n H = f (nthLe l n (length_map f l ▸ H)) :=\n  nthLe_map f _ _\n#align nth_le_map' nth_le_map'\n\n",
 "nth_le_map":
 "theorem nth_le_map (f : α → β) {l n} (H1 H2) : nthLe (map f l) n H1 = f (nthLe l n H2) :=\n  option.some.inj <| by rw [← nth_le_nth, nth_map, nth_le_nth] <;> rfl\n#align nth_le_map nth_le_map\n\n",
 "nth_le_length_sub_one":
 "theorem nth_le_length_sub_one {l : list α} (h : l.length - 1 < l.length) :\n    l.nth_le (l.length - 1) h =\n      l.last\n        (by\n          rintro rfl\n          exact nat.lt_irrefl 0 h) :=\n  (getLast_eq_nthLe l _).symm\n#align nth_le_length_sub_one nth_le_length_sub_one\n\n",
 "nth_le_insert_nth_self":
 "@[simp]\ntheorem nth_le_insert_nth_self (l : list α) (x : α) (n : ℕ) (hn : n ≤ l.length)\n    (hn' : n < (insertNth n x l).length := (by rwa [length_insert_nth _ _ hn, Nat.lt_succ_iff])) :\n    (insertNth n x l).nth_le n hn' = x :=\n  by\n  induction' l with hd tl IH generalizing n\n  · simp only [length, nonpos_iff_eq_zero] at hn\n    simp [hn]\n  · cases n\n    · simp\n    · simp only [nat.succ_le_succ_iff, length] at hn\n      simpa using IH _ hn\n#align nth_le_insert_nth_self nth_le_insert_nth_self\n\n",
 "nth_le_insert_nth_of_lt":
 "theorem nth_le_insert_nth_of_lt (l : list α) (x : α) (n k : ℕ) (hn : k < n) (hk : k < l.length)\n    (hk' : k < (insertNth n x l).length := hk.trans_le (length_le_length_insertNth _ _ _)) :\n    (insertNth n x l).nth_le k hk' = l.nth_le k hk :=\n  by\n  induction' n with n IH generalizing k l\n  · simpa using hn\n  · cases' l with hd tl\n    · simp\n    · cases k\n      · simp\n      · rw [Nat.succ_lt_succ_iff] at hn\n        simpa using IH _ _ hn _\n#align nth_le_insert_nth_of_lt nth_le_insert_nth_of_lt\n\n",
 "nth_le_insert_nth_add_succ":
 "theorem nth_le_insert_nth_add_succ (l : list α) (x : α) (n k : ℕ) (hk' : n + k < l.length)\n    (hk : n + k + 1 < (insertNth n x l).length :=\n      (by rwa [length_insert_nth _ _ (le_self_add.trans hk'.le), Nat.succ_lt_succ_iff])) :\n    (insertNth n x l).nth_le (n + k + 1) hk = nthLe l (n + k) hk' :=\n  by\n  induction' l with hd tl IH generalizing n k\n  · simpa using hk'\n  · cases n\n    · simpa\n    · simpa [succ_add] using IH _ _ _\n#align nth_le_insert_nth_add_succ nth_le_insert_nth_add_succ\n\n",
 "nth_le_eq_iff":
 "theorem nth_le_eq_iff {l : list α} {n : ℕ} {x : α} {h} : l.nth_le n h = x ↔ l.nth n = some x :=\n  by\n  rw [nth_eq_some]\n  tauto\n#align nth_le_eq_iff nth_le_eq_iff\n\n",
 "nth_le_enum_from":
 "theorem nth_le_enum_from (l : list α) (n i : ℕ) (hi' : i < (l.enum_from n).length)\n    (hi : i < l.length := (by simpa [length_enum_from] using hi')) :\n    (l.enum_from n).nth_le i hi' = (n + i, l.nth_le i hi) :=\n  by\n  rw [← option.some_inj, ← nth_le_nth]\n  simp [enum_from_nth, nth_le_nth hi]\n#align nth_le_enum_from nth_le_enum_from\n\n",
 "nth_le_enum":
 "theorem nth_le_enum (l : list α) (i : ℕ) (hi' : i < l.enum.length)\n    (hi : i < l.length := (by simpa [length_enum] using hi')) : l.enum.nth_le i hi' = (i, l.nth_le i hi) :=\n  by\n  convert nth_le_enum_from _ _ _ hi'\n  exact (zero_add _).symm\n#align nth_le_enum nth_le_enum\n\n",
 "nth_le_drop'":
 "/-- The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the small list to the big list. -/\ntheorem nth_le_drop' (L : list α) {i j : ℕ} (h : j < (L.drop i).length) :\n    nthLe (L.drop i) j h = nthLe L (i + j) (lt_tsub_iff_left.mp (length_drop i L ▸ h)) := by rw [nth_le_drop]\n#align nth_le_drop' nth_le_drop'\n\n",
 "nth_le_drop":
 "/-- The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the big list to the small list. -/\ntheorem nth_le_drop (L : list α) {i j : ℕ} (h : i + j < L.length) :\n    nthLe L (i + j) h =\n      nthLe (L.drop i) j\n        (by\n          have A : i < L.length := lt_of_le_of_lt (nat.le.intro rfl) h\n          rw [(take_append_drop i L).symm] at h\n          simpa only [le_of_lt A, min_eq_left, add_lt_add_iff_left, length_take, length_append] using h) :=\n  by\n  have A : length (take i L) = i := by simp [le_of_lt (lt_of_le_of_lt (nat.le.intro rfl) h)]\n  rw [nth_le_of_eq (take_append_drop i L).symm h, nth_le_append_right] <;> simp [A]\n#align nth_le_drop nth_le_drop\n\n",
 "nth_le_cons_length":
 "theorem nth_le_cons_length (x : α) (xs : list α) (n : ℕ) (h : n = xs.length) :\n    (x :: xs).nth_le n (by simp [h]) = (x :: xs).last (cons_ne_nil x xs) :=\n  by\n  rw [last_eq_nth_le]\n  congr\n  simp [h]\n#align nth_le_cons_length nth_le_cons_length\n\n",
 "nth_le_cons_aux":
 "theorem nth_le_cons_aux {l : list α} {a : α} {n} (hn : n ≠ 0) (h : n < (a :: l).length) : n - 1 < l.length :=\n  by\n  contrapose! h\n  rw [length_cons]\n  convert succ_le_succ h\n  exact (nat.succ_pred_eq_of_pos hn.bot_lt).symm\n#align nth_le_cons_aux nth_le_cons_aux\n\n",
 "nth_le_cons":
 "theorem nth_le_cons {l : list α} {a : α} {n} (hl) :\n    (a :: l).nth_le n hl = if hn : n = 0 then a else l.nth_le (n - 1) (nthLe_cons_aux hn hl) :=\n  by\n  split_ifs\n  · simp [nth_le, h]\n  cases l\n  · rw [length_singleton, lt_succ_iff, nonpos_iff_eq_zero] at hl\n    contradiction\n  cases n\n  · contradiction\n  rfl\n#align nth_le_cons nth_le_cons\n\n",
 "nth_le_attach":
 "@[simp]\ntheorem nth_le_attach (L : list α) (i) (H : i < L.attach.length) :\n    (L.attach.nth_le i H).1 = L.nth_le i (length_attach L ▸ H) :=\n  calc\n    (L.attach.nth_le i H).1 = (L.attach.map subtype.val).nth_le i (by simpa using H) := by rw [nth_le_map']\n    _ = L.nth_le i _ := by congr <;> apply attach_map_val\n    \n#align nth_le_attach nth_le_attach\n\n",
 "nth_le_append_right_aux":
 "theorem nth_le_append_right_aux {l₁ l₂ : list α} {n : ℕ} (h₁ : l₁.length ≤ n) (h₂ : n < (l₁ ++ l₂).length) :\n    n - l₁.length < l₂.length := by\n  rw [list.length_append] at h₂\n  apply lt_of_add_lt_add_right\n  rwa [nat.sub_add_cancel h₁, nat.add_comm]\n#align nth_le_append_right_aux nth_le_append_right_aux\n\n",
 "nth_le_append_right":
 "theorem nth_le_append_right :\n    ∀ {l₁ l₂ : list α} {n : ℕ} (h₁ : l₁.length ≤ n) (h₂),\n      (l₁ ++ l₂).nth_le n h₂ = l₂.nth_le (n - l₁.length) (get_append_right_aux h₁ h₂)\n  | [], _, n, h₁, h₂ => rfl\n  | a :: l, _, n + 1, h₁, h₂ => by\n    dsimp\n    conv =>\n      rhs\n      congr\n      skip\n      rw [nat.add_sub_add_right]\n    rw [nth_le_append_right (nat.lt_succ_iff.mp h₁)]\n#align nth_le_append_right nth_le_append_right\n\n",
 "nth_le_append":
 "theorem nth_le_append : ∀ {l₁ l₂ : list α} {n : ℕ} (hn₁) (hn₂), (l₁ ++ l₂).nth_le n hn₁ = l₁.nth_le n hn₂\n  | [], _, n, hn₁, hn₂ => (nat.not_lt_zero _ hn₂).elim\n  | a :: l, _, 0, hn₁, hn₂ => rfl\n  | a :: l, _, n + 1, hn₁, hn₂ => by simp only [nth_le, cons_append] <;> exact nth_le_append _ _\n#align nth_le_append nth_le_append\n\n",
 "nth_injective":
 "theorem nth_injective {α : Type u} {xs : list α} {i j : ℕ} (h₀ : i < xs.length) (h₁ : Nodup xs)\n    (h₂ : xs.nth i = xs.nth j) : i = j :=\n  by\n  induction' xs with x xs generalizing i j\n  · cases h₀\n  · cases i <;> cases j\n    case zero.zero => rfl\n    case succ.succ =>\n      congr ; cases h₁\n      apply xs_ih <;> solve_by_elim [lt_of_succ_lt_succ]\n    iterate 2 \n      dsimp at h₂\n      cases' h₁ with _ _ h h'\n      cases h x _ rfl\n      rw [mem_iff_nth]\n      first |exact ⟨_, h₂.symm⟩|exact ⟨_, h₂⟩\n#align nth_injective nth_injective\n\n",
 "nth_eq_some":
 "theorem nth_eq_some {l : list α} {n a} : get? l n = some a ↔ ∃ h, nthLe l n h = a :=\n  ⟨fun e =>\n    have h : n < length l := lt_of_not_ge fun hn => by rw [nth_len_le hn] at e <;> contradiction\n    ⟨h, by rw [nth_le_nth h] at e <;> injection e with e <;> apply nth_le_mem⟩,\n    fun ⟨h, e⟩ => e ▸ nthLe_get? _⟩\n#align nth_eq_some nth_eq_some\n\n",
 "nth_eq_none_iff":
 "@[simp]\ntheorem nth_eq_none_iff : ∀ {l : list α} {n}, get? l n = none ↔ length l ≤ n :=\n  by\n  intros ; constructor\n  · intro h\n    by_contra h'\n    have h₂ : ∃ h, l.nth_le n h = l.nth_le n (lt_of_not_ge h') := ⟨lt_of_not_ge h', rfl⟩\n    rw [← nth_eq_some, h] at h₂\n    cases h₂\n  · solve_by_elim [nth_len_le]\n#align nth_eq_none_iff nth_eq_none_iff\n\n",
 "nth_drop":
 "theorem nth_drop (L : list α) (i j : ℕ) : get? (L.drop i) j = get? L (i + j) :=\n  by\n  ext\n  simp only [nth_eq_some, nth_le_drop', option.mem_def]\n  constructor <;> exact fun ⟨h, ha⟩ => ⟨by simpa [lt_tsub_iff_left] using h, ha⟩\n#align nth_drop nth_drop\n\n",
 "nth_concat_length":
 "@[simp]\ntheorem nth_concat_length : ∀ (l : list α) (a : α), (l ++ [a]).nth l.length = some a\n  | [], a => rfl\n  | b :: l, a => by rw [cons_append, length_cons, nth, nth_concat_length]\n#align nth_concat_length nth_concat_length\n\n",
 "nth_append_right":
 "theorem nth_append_right {l₁ l₂ : list α} {n : ℕ} (hn : l₁.length ≤ n) : (l₁ ++ l₂).nth n = l₂.nth (n - l₁.length) :=\n  by\n  by_cases hl : n < (l₁ ++ l₂).length\n  · rw [nth_le_nth hl, nth_le_nth, nth_le_append_right hn]\n  · rw [nth_len_le (le_of_not_lt hl), nth_len_le]\n    rw [not_lt, length_append] at hl\n    exact le_tsub_of_add_le_left hl\n#align nth_append_right nth_append_right\n\n",
 "nth_append":
 "theorem nth_append {l₁ l₂ : list α} {n : ℕ} (hn : n < l₁.length) : (l₁ ++ l₂).nth n = l₁.nth n :=\n  by\n  have hn' : n < (l₁ ++ l₂).length := lt_of_lt_of_le hn (by rw [length_append] <;> exact nat.le_add_right _ _)\n  rw [nth_le_nth hn, nth_le_nth hn', nth_le_append]\n#align nth_append nth_append\n\n",
 "not_mem_of_not_mem_cons":
 "theorem not_mem_of_not_mem_cons {a b : α} {l : list α} : a ∉ b :: l → a ∉ l := fun nin nainl =>\n  absurd (or.inr nainl) nin\n#align not_mem_of_not_mem_cons not_mem_of_not_mem_cons\n\n",
 "not_mem_cons_of_ne_of_not_mem":
 "theorem not_mem_cons_of_ne_of_not_mem {a y : α} {l : list α} : a ≠ y → a ∉ l → a ∉ y :: l := fun p1 p2 =>\n  not.intro fun Pain => absurd (eq_or_mem_of_mem_cons Pain) (not_or_of_not p1 p2)\n#align not_mem_cons_of_ne_of_not_mem not_mem_cons_of_ne_of_not_mem\n\n",
 "not_mem_append":
 "theorem not_mem_append {a : α} {s t : list α} (h₁ : a ∉ s) (h₂ : a ∉ t) : a ∉ s ++ t :=\n  mt mem_append.1 <| not_or.2 ⟨h₁, h₂⟩\n#align not_mem_append not_mem_append\n\n",
 "not_exists_mem_nil":
 "theorem not_exists_mem_nil (p : α → Prop) : ¬∃ x ∈ @nil α, p x :=\n  fun.\n#align not_exists_mem_nil not_exists_mem_nil\n\n",
 "nil_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem nil_sublist : ∀ l : list α, «expr <+ » [] l\n  | [] => sublist.slnil\n  | a :: l => sublist.cons _ _ a (nil_sublist l)\n#align nil_sublist nil_sublist\n\n",
 "nil_map₂":
 "theorem nil_map₂ (f : α → β → γ) (l : list β) : zipWith f [] l = [] := by cases l <;> rfl\n#align nil_map₂ nil_map₂\n\n",
 "nil_eq_append_iff":
 "@[simp]\ntheorem nil_eq_append_iff {a b : list α} : [] = a ++ b ↔ a = [] ∧ b = [] := by rw [eq_comm, append_eq_nil]\n#align nil_eq_append_iff nil_eq_append_iff\n\n",
 "nil_diff":
 "@[simp]\ntheorem nil_diff (l : list α) : [].diff l = [] := by\n  induction l <;> [rfl, simp only [*, diff_cons, erase_of_not_mem (not_mem_nil _)]]\n#align nil_diff nil_diff\n\n",
 "ne_of_not_mem_cons":
 "theorem ne_of_not_mem_cons {a b : α} {l : list α} : a ∉ b :: l → a ≠ b := fun nin aeqb => absurd (or.inl aeqb) nin\n#align ne_of_not_mem_cons ne_of_not_mem_cons\n\n",
 "ne_nil_of_mem":
 "theorem ne_nil_of_mem {a : α} {l : list α} (h : a ∈ l) : l ≠ [] := by intro e <;> rw [e] at h <;> cases h\n#align ne_nil_of_mem ne_nil_of_mem\n\n",
 "ne_nil_of_length_pos":
 "theorem ne_nil_of_length_pos {l : list α} : 0 < length l → l ≠ [] := fun h1 h2 =>\n  lt_irrefl 0 ((length_eq_zero.2 h2).subst h1)\n#align ne_nil_of_length_pos ne_nil_of_length_pos\n\n",
 "ne_and_not_mem_of_not_mem_cons":
 "theorem ne_and_not_mem_of_not_mem_cons {a y : α} {l : list α} : a ∉ y :: l → a ≠ y ∧ a ∉ l := fun p =>\n  and.intro (ne_of_not_mem_cons p) (not_mem_of_not_mem_cons p)\n#align ne_and_not_mem_of_not_mem_cons ne_and_not_mem_of_not_mem_cons\n\n",
 "monotone_filter_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem monotone_filter_right (l : list α) ⦃p q : α → Prop⦄ [decidable_pred p] [decidable_pred q] (h : p ≤ q) :\n    «expr <+ » (l.filter p) (l.filter q) := by\n  induction' l with hd tl IH\n  · rfl\n  · by_cases hp : p hd\n    · rw [filter_cons_of_pos _ hp, filter_cons_of_pos _ (h _ hp)]\n      exact IH.cons_cons hd\n    · rw [filter_cons_of_neg _ hp]\n      by_cases hq : q hd\n      · rw [filter_cons_of_pos _ hq]\n        exact sublist_cons_of_sublist hd IH\n      · rw [filter_cons_of_neg _ hq]\n        exact IH\n#align monotone_filter_right monotone_filter_right\n\n",
 "monotone_filter_left":
 "theorem monotone_filter_left (p : α → Prop) [decidable_pred p] ⦃l l' : list α⦄ (h : l ⊆ l') :\n    filter p l ⊆ filter p l' := by\n  intro x hx\n  rw [mem_filter] at hx⊢\n  exact ⟨h hx.left, hx.right⟩\n#align monotone_filter_left monotone_filter_left\n\n",
 "modify_nth_tail_modify_nth_tail_same":
 "theorem modify_nth_tail_modify_nth_tail_same {f g : list α → list α} (n : ℕ) (l : list α) :\n    (l.modify_nth_tail f n).modify_nth_tail g n = l.modify_nth_tail (g ∘ f) n := by\n  rw [modify_nth_tail_modify_nth_tail_le n n l (le_refl n), tsub_self] <;> rfl\n#align modify_nth_tail_modify_nth_tail_same modify_nth_tail_modify_nth_tail_same\n\n",
 "modify_nth_tail_modify_nth_tail_le":
 "theorem modify_nth_tail_modify_nth_tail_le {f g : list α → list α} (m n : ℕ) (l : list α) (h : n ≤ m) :\n    (l.modify_nth_tail f n).modify_nth_tail g m = l.modify_nth_tail (fun l => (f l).modify_nth_tail g (m - n)) n :=\n  by\n  rcases exists_add_of_le h with ⟨m, rfl⟩\n  rw [add_tsub_cancel_left, add_comm, modify_nth_tail_modify_nth_tail]\n#align modify_nth_tail_modify_nth_tail_le modify_nth_tail_modify_nth_tail_le\n\n",
 "modify_nth_tail_modify_nth_tail":
 "theorem modify_nth_tail_modify_nth_tail {f g : list α → list α} (m : ℕ) :\n    ∀ (n) (l : list α),\n      (l.modify_nth_tail f n).modify_nth_tail g (m + n) = l.modify_nth_tail (fun l => (f l).modify_nth_tail g m) n\n  | 0, l => rfl\n  | n + 1, [] => rfl\n  | n + 1, a :: l => congr_arg (list.cons a) (modify_nth_tail_modify_nth_tail n l)\n#align modify_nth_tail_modify_nth_tail modify_nth_tail_modify_nth_tail\n\n",
 "modify_nth_tail_length":
 "theorem modify_nth_tail_length (f : list α → list α) (H : ∀ l, length (f l) = length l) :\n    ∀ n l, length (modifyNthTail f n l) = length l\n  | 0, l => H _\n  | n + 1, [] => rfl\n  | n + 1, a :: l => @congr_arg _ _ _ _ (· + 1) (modify_nth_tail_length _ _)\n#align modify_nth_tail_length modify_nth_tail_length\n\n",
 "modify_nth_tail_id":
 "theorem modify_nth_tail_id : ∀ (n) (l : list α), l.modify_nth_tail id n = l\n  | 0, l => rfl\n  | n + 1, [] => rfl\n  | n + 1, a :: l => congr_arg (list.cons a) (modify_nth_tail_id n l)\n#align modify_nth_tail_id modify_nth_tail_id\n\n",
 "modify_nth_tail_eq_take_drop":
 "theorem modify_nth_tail_eq_take_drop (f : list α → list α) (H : f [] = []) :\n    ∀ n l, modifyNthTail f n l = take n l ++ f (drop n l)\n  | 0, l => rfl\n  | n + 1, [] => H.symm\n  | n + 1, b :: l => congr_arg (cons b) (modify_nth_tail_eq_take_drop n l)\n#align modify_nth_tail_eq_take_drop modify_nth_tail_eq_take_drop\n\n",
 "modify_nth_length":
 "@[simp]\ntheorem modify_nth_length (f : α → α) : ∀ n l, length (modifyNth f n l) = length l :=\n  length_modifyNthTail _ fun l => by cases l <;> rfl\n#align modify_nth_length modify_nth_length\n\n",
 "modify_nth_eq_update_nth":
 "theorem modify_nth_eq_update_nth (f : α → α) :\n    ∀ (n) (l : list α), modifyNth f n l = ((fun a => set l n (f a)) <$> get? l n).get_or_else l\n  | 0, l => by cases l <;> rfl\n  | n + 1, [] => rfl\n  | n + 1, b :: l => (congr_arg (cons b) (modify_nth_eq_update_nth n l)).trans <| by cases nth l n <;> rfl\n#align modify_nth_eq_update_nth modify_nth_eq_update_nth\n\n",
 "modify_nth_eq_take_drop":
 "theorem modify_nth_eq_take_drop (f : α → α) : ∀ n l, modifyNth f n l = take n l ++ modifyHead f (drop n l) :=\n  modifyNthTail_eq_take_drop _ rfl\n#align modify_nth_eq_take_drop modify_nth_eq_take_drop\n\n",
 "modify_nth_eq_take_cons_drop":
 "theorem modify_nth_eq_take_cons_drop (f : α → α) {n l} (h) :\n    modifyNth f n l = take n l ++ f (nthLe l n h) :: drop (n + 1) l := by\n  rw [modify_nth_eq_take_drop, drop_eq_nth_le_cons h] <;> rfl\n#align modify_nth_eq_take_cons_drop modify_nth_eq_take_cons_drop\n\n",
 "modify_head_modify_head":
 "@[simp]\ntheorem modify_head_modify_head (l : list α) (f g : α → α) : (l.modify_head f).modify_head g = l.modify_head (g ∘ f) :=\n  by cases l <;> simp\n#align modify_head_modify_head modify_head_modify_head\n\n",
 "mfoldr_nil":
 "@[simp]\ntheorem mfoldr_nil (f : α → β → m β) {b} : foldrM f b [] = pure b :=\n  rfl\n#align mfoldr_nil mfoldr_nil\n\n",
 "mfoldr_eq_foldr":
 "theorem mfoldr_eq_foldr (f : α → β → m β) (b l) : foldrM f b l = foldr (fun a mb => mb >>= f a) (pure b) l := by\n  induction l <;> simp [*]\n#align mfoldr_eq_foldr mfoldr_eq_foldr\n\n",
 "mfoldr_cons":
 "@[simp]\ntheorem mfoldr_cons {f : α → β → m β} {b a l} : foldrM f b (a :: l) = foldrM f b l >>= f a :=\n  rfl\n#align mfoldr_cons mfoldr_cons\n\n",
 "mfoldr_append":
 "@[simp]\ntheorem mfoldr_append {f : α → β → m β} : ∀ {b l₁ l₂}, foldrM f b (l₁ ++ l₂) = foldrM f b l₂ >>= fun x => foldrM f x l₁\n  | _, [], _ => by simp only [nil_append, mfoldr_nil, bind_pure]\n  | _, _ :: _, _ => by simp only [mfoldr_cons, cons_append, mfoldr_append, is_lawful_monad.bind_assoc]\n#align mfoldr_append mfoldr_append\n\n",
 "mfoldl_nil":
 "@[simp]\ntheorem mfoldl_nil (f : β → α → m β) {b} : foldlM f b [] = pure b :=\n  rfl\n#align mfoldl_nil mfoldl_nil\n\n",
 "mfoldl_eq_foldl":
 "theorem mfoldl_eq_foldl (f : β → α → m β) (b l) : foldlM f b l = foldl (fun mb a => mb >>= fun b => f b a) (pure b) l :=\n  by\n  suffices h : ∀ mb : m β, (mb >>= fun b => mfoldl f b l) = foldl (fun mb a => mb >>= fun b => f b a) mb l\n  · simp [← h (pure b)]\n  induction l <;> intro\n  · simp\n  · simp only [mfoldl, foldl, ← l_ih, functor_norm]\n#align mfoldl_eq_foldl mfoldl_eq_foldl\n\n",
 "mfoldl_cons":
 "@[simp]\ntheorem mfoldl_cons {f : β → α → m β} {b a l} : foldlM f b (a :: l) = f b a >>= fun b' => foldlM f b' l :=\n  rfl\n#align mfoldl_cons mfoldl_cons\n\n",
 "mfoldl_append":
 "@[simp]\ntheorem mfoldl_append {f : β → α → m β} : ∀ {b l₁ l₂}, foldlM f b (l₁ ++ l₂) = foldlM f b l₁ >>= fun x => foldlM f x l₂\n  | _, [], _ => by simp only [nil_append, mfoldl_nil, pure_bind]\n  | _, _ :: _, _ => by simp only [cons_append, mfoldl_cons, mfoldl_append, is_lawful_monad.bind_assoc]\n#align mfoldl_append mfoldl_append\n\n",
 "mem_take_while_imp":
 "theorem mem_take_while_imp {x : α} (hx : x ∈ takeWhile p l) : p x :=\n  by\n  induction' l with hd tl IH\n  · simpa [take_while] using hx\n  · simp only [take_while] at hx\n    split_ifs  at hx\n    · rw [mem_cons_iff] at hx\n      rcases hx with (rfl | hx)\n      · exact h\n      · exact IH hx\n    · simpa using hx\n#align mem_take_while_imp mem_take_while_imp\n\n",
 "mem_split":
 "theorem mem_split {a : α} {l : list α} (h : a ∈ l) : ∃ s t : list α, l = s ++ a :: t :=\n  by\n  induction' l with b l ih; · cases h; rcases h with (rfl | h)\n  · exact ⟨[], l, rfl⟩\n  · rcases ih h with ⟨s, t, rfl⟩\n    exact ⟨b :: s, t, rfl⟩\n#align mem_split mem_split\n\n",
 "mem_singleton_self":
 "theorem mem_singleton_self (a : α) : a ∈ [a] :=\n  mem_cons_self _ _\n#align mem_singleton_self mem_singleton_self\n\n",
 "mem_singleton":
 "@[simp]\ntheorem mem_singleton {a b : α} : a ∈ [b] ↔ a = b :=\n  ⟨eq_of_mem_singleton, or.inl⟩\n#align mem_singleton mem_singleton\n\n",
 "mem_reverse":
 "@[simp]\ntheorem mem_reverse {a : α} {l : list α} : a ∈ reverse l ↔ a ∈ l := by\n  induction l <;> [rfl,\n    simp only [*, reverse_cons, mem_append, mem_singleton, mem_cons_iff, not_mem_nil, false_or_iff, or_false_iff,\n      or_comm']]\n#align mem_reverse mem_reverse\n\n",
 "mem_replicate":
 "theorem mem_replicate {a b : α} : ∀ {n}, b ∈ replicate n a ↔ n ≠ 0 ∧ b = a\n  | 0 => by simp\n  | n + 1 => by simp [mem_replicate]\n#align mem_replicate mem_replicate\n\n",
 "mem_pure":
 "@[simp]\ntheorem mem_pure {α} (x y : α) : x ∈ (pure y : list α) ↔ x = y := by simp! [pure, List.ret]\n#align mem_pure mem_pure\n\n",
 "mem_pmap":
 "@[simp]\ntheorem mem_pmap {p : α → Prop} {f : ∀ a, p a → β} {l H b} : b ∈ pmap f l H ↔ ∃ (a : _)(h : a ∈ l), f a (H a h) = b :=\n  by simp only [pmap_eq_map_attach, mem_map, mem_attach, true_and_iff, subtype.exists]\n#align mem_pmap mem_pmap\n\n",
 "mem_or_eq_of_mem_update_nth":
 "theorem mem_or_eq_of_mem_update_nth : ∀ {l : list α} {n : ℕ} {a b : α} (h : a ∈ l.update_nth n b), a ∈ l ∨ a = b\n  | [], n, a, b, h => false.elim h\n  | c :: l, 0, a, b, h => ((mem_cons _ _ _).1 h).elim or.inr (or.inl ∘ mem_cons_of_mem _)\n  | c :: l, n + 1, a, b, h =>\n    ((mem_cons _ _ _).1 h).elim (fun h => h ▸ or.inl (mem_cons_self _ _)) fun h =>\n      (mem_or_eq_of_mem_update_nth h).elim (or.inl ∘ mem_cons_of_mem _) or.inr\n#align mem_or_eq_of_mem_update_nth mem_or_eq_of_mem_update_nth\n\n",
 "mem_of_ne_of_mem":
 "theorem mem_of_ne_of_mem {a y : α} {l : list α} (h₁ : a ≠ y) (h₂ : a ∈ y :: l) : a ∈ l :=\n  or.elim (eq_or_mem_of_mem_cons h₂) (fun e => absurd e h₁) fun r => r\n#align mem_of_ne_of_mem mem_of_ne_of_mem\n\n",
 "mem_of_mem_last'":
 "theorem mem_of_mem_last' {l : list α} {a : α} (ha : a ∈ l.last') : a ∈ l :=\n  let ⟨h₁, h₂⟩ := mem_getLast?_eq_getLast ha\n  h₂.symm ▸ getLast_mem _\n#align mem_of_mem_last' mem_of_mem_last'\n\n",
 "mem_of_mem_head'":
 "theorem mem_of_mem_head' {x : α} {l : list α} (h : x ∈ l.head') : x ∈ l :=\n  (eq_cons_of_mem_head? h).symm ▸ mem_cons_self _ _\n#align mem_of_mem_head' mem_of_mem_head'\n\n",
 "mem_of_mem_filter":
 "theorem mem_of_mem_filter {a : α} {l} (h : a ∈ filter p l) : a ∈ l :=\n  filter_subset l h\n#align mem_of_mem_filter mem_of_mem_filter\n\n",
 "mem_of_mem_erasep":
 "theorem mem_of_mem_erasep {a : α} {l : list α} : a ∈ l.erasep p → a ∈ l :=\n  @eraseP_subset _ _ _ _ _\n#align mem_of_mem_erasep mem_of_mem_erasep\n\n",
 "mem_of_mem_erase":
 "theorem mem_of_mem_erase {a b : α} {l : list α} : a ∈ l.erase b → a ∈ l :=\n  @erase_subset _ _ _ _ _\n#align mem_of_mem_erase mem_of_mem_erase\n\n",
 "mem_of_mem_cons_of_mem":
 "theorem mem_of_mem_cons_of_mem {a b : α} {l : list α} : a ∈ b :: l → b ∈ l → a ∈ l := fun ainbl binl =>\n  or.elim (eq_or_mem_of_mem_cons ainbl) (fun this : a = b => by subst a; exact binl) fun this : a ∈ l => this\n#align mem_of_mem_cons_of_mem mem_of_mem_cons_of_mem\n\n",
 "mem_map_swap":
 "@[simp]\ntheorem mem_map_swap (x : α) (y : β) (xs : list (α × β)) : (y, x) ∈ map prod.swap xs ↔ (x, y) ∈ xs :=\n  by\n  induction' xs with x xs\n  · simp only [not_mem_nil, map_nil]\n  · cases' x with a b\n    simp only [mem_cons_iff, prod.mk.inj_iff, map, prod.swap_prod_mk, prod.exists, xs_ih, and_comm']\n#align mem_map_swap mem_map_swap\n\n",
 "mem_map_of_mem":
 "theorem mem_map_of_mem (f : α → β) {a : α} {l : list α} (h : a ∈ l) : f a ∈ map f l :=\n  mem_map'.2 ⟨a, h, rfl⟩\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_of_involutive":
 "theorem mem_map_of_involutive {f : α → α} (hf : involutive f) {a : α} {l : list α} : a ∈ map f l ↔ f a ∈ l := by\n  rw [mem_map, hf.exists_mem_and_apply_eq_iff]\n#align mem_map_of_involutive mem_map_of_involutive\n\n",
 "mem_map_of_injective":
 "theorem mem_map_of_injective {f : α → β} (H : injective f) {a : α} {l : list α} : f a ∈ map f l ↔ a ∈ l :=\n  ⟨fun m =>\n    let ⟨a', m', e⟩ := exists_of_mem_map' m\n    H e ▸ m',\n    mem_map_of_mem _⟩\n#align mem_map_of_injective mem_map_of_injective\n\n",
 "mem_map":
 "@[simp]\ntheorem mem_map {f : α → β} {b : β} {l : list α} : b ∈ map f l ↔ ∃ a, a ∈ l ∧ f a = b :=\n  by\n  -- This proof uses no axioms, that's why it's longer that `induction`; simp [...]\n  induction' l with a l ihl\n  · constructor\n    · rintro ⟨_⟩\n    · rintro ⟨a, ⟨_⟩, _⟩\n  · refine' (or_congr eq_comm ihl).trans _\n    constructor\n    · rintro (h | ⟨c, hcl, h⟩)\n      exacts[⟨a, or.inl rfl, h⟩, ⟨c, or.inr hcl, h⟩]\n    · rintro ⟨c, hc | hc, h⟩\n      exacts[or.inl <| (congr_arg f hc.symm).trans h, or.inr ⟨c, hc, h⟩]\n#align mem_map mem_map\n\n",
 "mem_last'_eq_last":
 "theorem mem_last'_eq_last : ∀ {l : list α} {x : α}, x ∈ l.last' → ∃ h, x = getLast l h\n  | [], x, hx => false.elim <| by simpa using hx\n  | [a], x, hx =>\n    have : a = x := by simpa using hx\n    this ▸ ⟨cons_ne_nil a [], rfl⟩\n  | a :: b :: l, x, hx => by\n    rw [last'] at hx\n    rcases mem_last'_eq_last hx with ⟨h₁, h₂⟩\n    use cons_ne_nil _ _\n    rwa [last_cons]\n#align mem_last'_eq_last mem_last'_eq_last\n\n",
 "mem_last'_cons":
 "theorem mem_last'_cons {x y : α} : ∀ {l : list α} (h : x ∈ l.last'), x ∈ (y :: l).last'\n  | [], _ => by contradiction\n  | a :: l, h => h\n#align mem_last'_cons mem_last'_cons\n\n",
 "mem_join_of_mem":
 "theorem mem_join_of_mem {a : α} {L : list (list α)} {l} (lL : l ∈ L) (al : a ∈ l) : a ∈ join L :=\n  mem_join.2 ⟨l, lL, al⟩\n#align mem_join_of_mem mem_join_of_mem\n\n",
 "mem_join":
 "@[simp]\ntheorem mem_join {a : α} : ∀ {L : list (list α)}, a ∈ join L ↔ ∃ l, l ∈ L ∧ a ∈ l\n  | [] => ⟨false.elim, fun ⟨_, h, _⟩ => false.elim h⟩\n  | c :: L => by simp only [join, mem_append, @mem_join L, mem_cons_iff, or_and_right, exists_or, exists_eq_left]\n#align mem_join mem_join\n\n",
 "mem_insert_nth":
 "theorem mem_insert_nth {a b : α} : ∀ {n : ℕ} {l : list α} (hi : n ≤ l.length), a ∈ l.insert_nth n b ↔ a = b ∨ a ∈ l\n  | 0, as, h => iff.rfl\n  | n + 1, [], h => (nat.not_succ_le_zero _ h).elim\n  | n + 1, a' :: as, h => by\n    dsimp [List.insertNth]\n    erw [mem_insert_nth (nat.le_of_succ_le_succ h), ← or_assoc, or_comm' (a = a'), or_assoc]\n#align mem_insert_nth mem_insert_nth\n\n",
 "mem_iff_nth_le":
 "theorem mem_iff_nth_le {a} {l : list α} : a ∈ l ↔ ∃ n h, nthLe l n h = a :=\n  ⟨nthLe_of_mem, fun ⟨n, h, e⟩ => e ▸ nthLe_mem _ _ _⟩\n#align mem_iff_nth_le mem_iff_nth_le\n\n",
 "mem_iff_nth":
 "theorem mem_iff_nth {a} {l : list α} : a ∈ l ↔ ∃ n, get? l n = some a :=\n  mem_iff_nthLe.trans <| exists_congr fun n => get?_eq_some'.symm\n#align mem_iff_nth mem_iff_nth\n\n",
 "mem_filter_of_mem":
 "theorem mem_filter_of_mem {a : α} : ∀ {l}, a ∈ l → p a → a ∈ filter p l\n  | _ :: l, or.inl rfl, pa => by rw [filter_cons_of_pos _ pa] <;> apply mem_cons_self\n  | b :: l, or.inr ain, pa =>\n    if pb : p b then by rw [filter_cons_of_pos _ pb] <;> apply mem_cons_of_mem <;> apply mem_filter_of_mem ain pa\n    else by rw [filter_cons_of_neg _ pb] <;> apply mem_filter_of_mem ain pa\n#align mem_filter_of_mem mem_filter_of_mem\n\n",
 "mem_filter_map":
 "@[simp]\ntheorem mem_filter_map (f : α → option β) (l : list α) {b : β} : b ∈ filter_map f l ↔ ∃ a, a ∈ l ∧ f a = some b :=\n  by\n  induction' l with a l IH\n  · constructor\n    · intro H\n      cases H\n    · rintro ⟨_, H, _⟩\n      cases H\n  cases' h : f a with b'\n  · have : f a ≠ some b := by\n      rw [h]\n      intro\n      contradiction\n    simp only [filter_map_cons_none _ _ h, IH, mem_cons_iff, or_and_right, exists_or, exists_eq_left, this,\n      false_or_iff]\n  · have : f a = some b ↔ b = b' := by\n      constructor <;> intro t\n      · rw [t] at h <;> injection h\n      · exact t.symm ▸ h\n    simp only [filter_map_cons_some _ _ _ h, IH, mem_cons_iff, or_and_right, exists_or, this, exists_eq_left]\n#align mem_filter_map mem_filter_map\n\n",
 "mem_filter":
 "@[simp]\ntheorem mem_filter {a : α} {l} : a ∈ filter p l ↔ a ∈ l ∧ p a :=\n  ⟨fun h => ⟨mem_of_mem_filter h, of_mem_filter h⟩, fun ⟨h₁, h₂⟩ => mem_filter_of_mem h₁ h₂⟩\n#align mem_filter mem_filter\n\n",
 "mem_erasep_of_neg":
 "@[simp]\ntheorem mem_erasep_of_neg {a : α} {l : list α} (pa : ¬p a) : a ∈ l.erasep p ↔ a ∈ l :=\n  ⟨mem_of_mem_eraseP, fun al =>\n    by\n    rcases exists_or_eq_self_of_erasep p l with (h | ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩)\n    · rwa [h]\n    · rw [h₄]\n      rw [h₃] at al\n      have : a ≠ c := by\n        rintro rfl\n        exact pa.elim h₂\n      simpa [this] using al⟩\n#align mem_erasep_of_neg mem_erasep_of_neg\n\n",
 "mem_erase_of_ne":
 "@[simp]\ntheorem mem_erase_of_ne {a b : α} {l : list α} (ab : a ≠ b) : a ∈ l.erase b ↔ a ∈ l := by\n  rw [erase_eq_erasep] <;> exact mem_erasep_of_neg ab.symm\n#align mem_erase_of_ne mem_erase_of_ne\n\n",
 "mem_enum_from":
 "theorem mem_enum_from {x : α} {i : ℕ} :\n    ∀ {j : ℕ} (xs : list α), (i, x) ∈ xs.enum_from j → j ≤ i ∧ i < j + xs.length ∧ x ∈ xs\n  | j, [] => by simp [enum_from]\n  | j, y :: ys =>\n    by\n    suffices i = j ∧ x = y ∨ (i, x) ∈ enum_from (j + 1) ys → j ≤ i ∧ i < j + (length ys + 1) ∧ (x = y ∨ x ∈ ys) by\n      simpa [enum_from, mem_enum_from ys]\n    rintro (h | h)\n    · refine' ⟨le_of_eq h.1.symm, h.1 ▸ _, or.inl h.2⟩\n      apply nat.lt_add_of_pos_right <;> simp\n    · obtain ⟨hji, hijlen, hmem⟩ := mem_enum_from _ h\n      refine' ⟨_, _, _⟩\n      · exact le_trans (nat.le_succ _) hji\n      · convert hijlen using 1\n        ac_rfl\n      · simp [hmem]\n#align mem_enum_from mem_enum_from\n\n",
 "mem_diff_of_mem":
 "theorem mem_diff_of_mem {a : α} : ∀ {l₁ l₂ : list α}, a ∈ l₁ → a ∉ l₂ → a ∈ l₁.diff l₂\n  | l₁, [], h₁, h₂ => h₁\n  | l₁, b :: l₂, h₁, h₂ => by\n    rw [diff_cons] <;>\n      exact mem_diff_of_mem ((mem_erase_of_ne (ne_of_not_mem_cons h₂)).2 h₁) (not_mem_of_not_mem_cons h₂)\n#align mem_diff_of_mem mem_diff_of_mem\n\n",
 "mem_bind_of_mem":
 "theorem mem_bind_of_mem {b : β} {l : list α} {f : α → list β} {a} (al : a ∈ l) (h : b ∈ f a) : b ∈ list.bind l f :=\n  mem_bind.2 ⟨a, al, h⟩\n#align mem_bind_of_mem mem_bind_of_mem\n\n",
 "mem_bind":
 "@[simp]\ntheorem mem_bind {b : β} {l : list α} {f : α → list β} : b ∈ list.bind l f ↔ ∃ a ∈ l, b ∈ f a :=\n  iff.trans mem_join\n    ⟨fun ⟨l', h1, h2⟩ =>\n      let ⟨a, al, fa⟩ := exists_of_mem_map' h1\n      ⟨a, al, fa.symm ▸ h2⟩,\n      fun ⟨a, al, bfa⟩ => ⟨f a, mem_map_of_mem _ al, bfa⟩⟩\n#align mem_bind mem_bind\n\n",
 "mem_attach":
 "@[simp]\ntheorem mem_attach (l : list α) : ∀ x, x ∈ l.attach\n  | ⟨a, h⟩ => by\n    have := mem_map.1 (by rw [attach_map_val] <;> exact h) <;>\n      · rcases this with ⟨⟨_, _⟩, m, rfl⟩\n        exact m\n#align mem_attach mem_attach\n\n",
 "map₂_right_nil_right":
 "@[simp]\ntheorem map₂_right_nil_right : map₂Right f as [] = [] :=\n  rfl\n#align map₂_right_nil_right map₂_right_nil_right\n\n",
 "map₂_right_nil_left":
 "@[simp]\ntheorem map₂_right_nil_left : map₂Right f [] bs = bs.map (f none) := by cases bs <;> rfl\n#align map₂_right_nil_left map₂_right_nil_left\n\n",
 "map₂_right_nil_cons":
 "@[simp]\ntheorem map₂_right_nil_cons : map₂Right f [] (b :: bs) = f none b :: bs.map (f none) :=\n  rfl\n#align map₂_right_nil_cons map₂_right_nil_cons\n\n",
 "map₂_right_eq_map₂_right'":
 "theorem map₂_right_eq_map₂_right' : map₂Right f as bs = (map₂Right' f as bs).fst := by\n  simp only [map₂_right, map₂_right', map₂_left_eq_map₂_left']\n#align map₂_right_eq_map₂_right' map₂_right_eq_map₂_right'\n\n",
 "map₂_right_eq_map₂":
 "theorem map₂_right_eq_map₂ (h : length bs ≤ length as) : map₂Right f as bs = zipWith (fun a b => f (some a) b) as bs :=\n  by\n  have : (fun a b => flip f a (some b)) = flip fun a b => f (some a) b := rfl\n  simp only [map₂_right, map₂_left_eq_map₂, map₂_flip, *]\n#align map₂_right_eq_map₂ map₂_right_eq_map₂\n\n",
 "map₂_right_cons_cons":
 "@[simp]\ntheorem map₂_right_cons_cons : map₂Right f (a :: as) (b :: bs) = f (some a) b :: map₂Right f as bs :=\n  rfl\n#align map₂_right_cons_cons map₂_right_cons_cons\n\n",
 "map₂_right'_nil_right":
 "@[simp]\ntheorem map₂_right'_nil_right : map₂Right' f as [] = ([], as) :=\n  rfl\n#align map₂_right'_nil_right map₂_right'_nil_right\n\n",
 "map₂_right'_nil_left":
 "@[simp]\ntheorem map₂_right'_nil_left : map₂Right' f [] bs = (bs.map (f none), []) := by cases bs <;> rfl\n#align map₂_right'_nil_left map₂_right'_nil_left\n\n",
 "map₂_right'_nil_cons":
 "@[simp]\ntheorem map₂_right'_nil_cons : map₂Right' f [] (b :: bs) = (f none b :: bs.map (f none), []) :=\n  rfl\n#align map₂_right'_nil_cons map₂_right'_nil_cons\n\n",
 "map₂_right'_cons_cons":
 "@[simp]\ntheorem map₂_right'_cons_cons :\n    map₂Right' f (a :: as) (b :: bs) =\n      let rec := map₂Right' f as bs\n      (f (some a) b :: rec.fst, rec.snd) :=\n  rfl\n#align map₂_right'_cons_cons map₂_right'_cons_cons\n\n",
 "map₂_nil":
 "theorem map₂_nil (f : α → β → γ) (l : list α) : zipWith f l [] = [] := by cases l <;> rfl\n#align map₂_nil map₂_nil\n\n",
 "map₂_left_nil_right":
 "-- The definitional equalities for `map₂_left` can already be used by the\n-- simplifier because `map₂_left` is marked `@[simp]`.\n@[simp]\ntheorem map₂_left_nil_right : map₂Left f as [] = as.map fun a => f a none := by cases as <;> rfl\n#align map₂_left_nil_right map₂_left_nil_right\n\n",
 "map₂_left_eq_map₂_left'":
 "theorem map₂_left_eq_map₂_left' : ∀ as bs, map₂Left f as bs = (map₂Left' f as bs).fst\n  | [], bs => by simp!\n  | a :: as, [] => by simp!\n  | a :: as, b :: bs => by simp! [*]\n#align map₂_left_eq_map₂_left' map₂_left_eq_map₂_left'\n\n",
 "map₂_left_eq_map₂":
 "theorem map₂_left_eq_map₂ : ∀ as bs, length as ≤ length bs → map₂Left f as bs = zipWith (fun a b => f a (some b)) as bs\n  | [], [], h => by simp!\n  | [], b :: bs, h => by simp!\n  | a :: as, [], h => by\n    simp at h\n    contradiction\n  | a :: as, b :: bs, h => by\n    simp at h\n    simp! [*]\n#align map₂_left_eq_map₂ map₂_left_eq_map₂\n\n",
 "map₂_left'_nil_right":
 "-- The definitional equalities for `map₂_left'` can already be used by the\n-- simplifie because `map₂_left'` is marked `@[simp]`.\n@[simp]\ntheorem map₂_left'_nil_right (f : α → option β → γ) (as) : map₂Left' f as [] = (as.map fun a => f a none, []) := by\n  cases as <;> rfl\n#align map₂_left'_nil_right map₂_left'_nil_right\n\n",
 "map₂_flip":
 "@[simp]\ntheorem map₂_flip (f : α → β → γ) : ∀ as bs, zipWith (flip f) bs as = zipWith f as bs\n  | [], [] => rfl\n  | [], b :: bs => rfl\n  | a :: as, [] => rfl\n  | a :: as, b :: bs => by\n    simp! [map₂_flip]\n    rfl\n#align map₂_flip map₂_flip\n\n",
 "map_take":
 "theorem map_take {α β : Type _} (f : α → β) : ∀ (L : list α) (i : ℕ), (L.take i).map f = (L.map f).take i\n  | [], i => by simp\n  | L, 0 => by simp\n  | h :: t, n + 1 => by\n    dsimp\n    rw [map_take]\n#align map_take map_take\n\n",
 "map_tail":
 "@[simp]\ntheorem map_tail (f : α → β) (l) : map f (tail l) = tail (map f l) := by cases l <;> rfl\n#align map_tail map_tail\n\n",
 "map_subset_iff":
 "theorem map_subset_iff {l₁ l₂ : list α} (f : α → β) (h : injective f) : map f l₁ ⊆ map f l₂ ↔ l₁ ⊆ l₂ :=\n  by\n  refine' ⟨_, map_subset f⟩; intro h2 x hx\n  rcases mem_map.1 (h2 (mem_map_of_mem f hx)) with ⟨x', hx', hxx'⟩\n  cases h hxx'; exact hx'\n#align map_subset_iff map_subset_iff\n\n",
 "map_subset":
 "theorem map_subset {l₁ l₂ : list α} (f : α → β) (H : l₁ ⊆ l₂) : map f l₁ ⊆ map f l₂ := fun x => by\n  simp only [mem_map, not_and, exists_imp, and_imp] <;> exact fun a h e => ⟨a, H h, e⟩\n#align map_subset map_subset\n\n",
 "map_reverse_core":
 "theorem map_reverse_core (f : α → β) (l₁ l₂ : list α) : map f (reverseAux l₁ l₂) = reverseAux (map f l₁) (map f l₂) :=\n  by simp only [reverse_core_eq, map_append, map_reverse]\n#align map_reverse_core map_reverse_core\n\n",
 "map_reverse":
 "@[simp]\ntheorem map_reverse (f : α → β) (l : list α) : map f (reverse l) = reverse (map f l) := by\n  induction l <;> [rfl, simp only [*, map, reverse_cons, map_append]]\n#align map_reverse map_reverse\n\n",
 "map_replicate":
 "@[simp]\ntheorem map_replicate (f : α → β) (n a) : map f (replicate n a) = replicate n (f a) := by\n  induction n <;> [rfl, simp only [*, replicate, map]] <;> constructor <;> rfl\n#align map_replicate map_replicate\n\n",
 "map_pmap":
 "theorem map_pmap {p : α → Prop} (g : β → γ) (f : ∀ a, p a → β) (l H) :\n    map g (pmap f l H) = pmap (fun a h => g (f a h)) l H := by\n  induction l <;> [rfl, simp only [*, pmap, map]] <;> constructor <;> rfl\n#align map_pmap map_pmap\n\n",
 "map_nil":
 "@[simp]\ntheorem map_nil (f : α → β) : map f [] = [] :=\n  rfl\n#align map_nil map_nil\n\n",
 "map_join":
 "@[simp]\ntheorem map_join (f : α → β) (L : list (list α)) : map f (join L) = join (map (map f) L) := by\n  induction L <;> [rfl, simp only [*, join, map, map_append]]\n#align map_join map_join\n\n",
 "map_injective_iff":
 "@[simp]\ntheorem map_injective_iff {f : α → β} : injective (map f) ↔ injective f :=\n  by\n  constructor <;> intro h x y hxy\n  · suffices [x] = [y] by simpa using this\n    apply h\n    simp [hxy]\n  · induction y generalizing x\n    simpa using hxy\n    cases x\n    simpa using hxy\n    simp at hxy\n    simp [y_ih hxy.2, h hxy.1]\n#align map_injective_iff map_injective_iff\n\n",
 "map_id''":
 "@[simp]\ntheorem map_id'' (l : list α) : map (fun x => x) l = l :=\n  map_id _\n#align map_id'' map_id''\n\n",
 "map_id'":
 "theorem map_id' {f : α → α} (h : ∀ x, f x = x) (l : list α) : map f l = l := by simp [show f = id from funext h]\n#align map_id' map_id'\n\n",
 "map_fst_add_enum_from_eq_enum_from":
 "theorem map_fst_add_enum_from_eq_enum_from (l : list α) (n k : ℕ) :\n    map (prod.map (· + n) id) (enum_from k l) = enum_from (n + k) l :=\n  by\n  induction' l with hd tl IH generalizing n k\n  · simp [enum_from]\n  · simp only [enum_from, map, zero_add, prod.map_mk, id.def, eq_self_iff_true, true_and_iff]\n    simp [IH, add_comm n k, add_assoc, add_left_comm]\n#align map_fst_add_enum_from_eq_enum_from map_fst_add_enum_from_eq_enum_from\n\n",
 "map_fst_add_enum_eq_enum_from":
 "theorem map_fst_add_enum_eq_enum_from (l : list α) (n : ℕ) : map (prod.map (· + n) id) (enum l) = enum_from n l :=\n  map_fst_add_enumFrom_eq_enumFrom l _ _\n#align map_fst_add_enum_eq_enum_from map_fst_add_enum_eq_enum_from\n\n",
 "map_foldl_erase":
 "theorem map_foldl_erase [decidable_eq β] {f : α → β} (finj : injective f) {l₁ l₂ : list α} :\n    map f (foldl List.erase l₁ l₂) = foldl (fun l a => l.erase (f a)) (map f l₁) l₂ := by\n  induction l₂ generalizing l₁ <;> [rfl, simp only [foldl_cons, map_erase finj, *]]\n#align map_foldl_erase map_foldl_erase\n\n",
 "map_filter_map_some_eq_filter_map_is_some":
 "theorem map_filter_map_some_eq_filter_map_is_some (f : α → option β) (l : list α) :\n    (l.filter_map f).map some = (l.map f).filter fun b => b.is_some :=\n  by\n  induction' l with x xs ih\n  · simp\n  · cases h : f x <;> rw [List.filterMap_cons, h] <;> simp [h, ih]\n#align map_filter_map_some_eq_filter_map_is_some map_filter_map_some_eq_filter_map_is_some\n\n",
 "map_filter_map_of_inv":
 "theorem map_filter_map_of_inv (f : α → option β) (g : β → α) (H : ∀ x : α, (f x).map g = some x) (l : list α) :\n    map g (filter_map f l) = l := by simp only [map_filter_map, H, filter_map_some]\n#align map_filter_map_of_inv map_filter_map_of_inv\n\n",
 "map_filter_map":
 "theorem map_filter_map (f : α → option β) (g : β → γ) (l : list α) :\n    map g (filter_map f l) = filter_map (fun x => (f x).map g) l := by\n  rw [← filter_map_eq_map, filter_map_filter_map] <;> rfl\n#align map_filter_map map_filter_map\n\n",
 "map_filter_eq_foldr":
 "theorem map_filter_eq_foldr (f : α → β) (p : α → Prop) [decidable_pred p] (as : list α) :\n    map f (filter p as) = foldr (fun a bs => if p a then f a :: bs else bs) [] as :=\n  by\n  induction as\n  · rfl\n  · simp! [*, apply_ite (map f)]\n#align map_filter_eq_foldr map_filter_eq_foldr\n\n",
 "map_filter":
 "theorem map_filter (f : β → α) (l : list β) : filter p (map f l) = map f (filter (p ∘ f) l) := by\n  rw [← filter_map_eq_map, filter_filter_map, filter_map_filter] <;> rfl\n#align map_filter map_filter\n\n",
 "map_erase":
 "theorem map_erase [decidable_eq β] {f : α → β} (finj : injective f) {a : α} (l : list α) :\n    map f (l.erase a) = (map f l).erase (f a) :=\n  by\n  have this : eq a = eq (f a) ∘ f := by ext b; simp [finj.eq_iff]\n  simp [erase_eq_erasep, erase_eq_erasep, erasep_map, this]\n#align map_erase map_erase\n\n",
 "map_eq_replicate_iff":
 "theorem map_eq_replicate_iff {l : list α} {f : α → β} {b : β} : l.map f = replicate l.length b ↔ ∀ x ∈ l, f x = b := by\n  simp [eq_replicate]\n#align map_eq_replicate_iff map_eq_replicate_iff\n\n",
 "map_eq_nil":
 "@[simp]\ntheorem map_eq_nil {f : α → β} {l : list α} : list.map f l = [] ↔ l = [] :=\n  ⟨by cases l <;> simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff], fun h => h.symm ▸ rfl⟩\n#align map_eq_nil map_eq_nil\n\n",
 "map_eq_map_iff":
 "theorem map_eq_map_iff {f g : α → β} {l : list α} : map f l = map g l ↔ ∀ x ∈ l, f x = g x :=\n  by\n  refine' ⟨_, map_congr⟩; intro h x hx\n  rw [mem_iff_nth_le] at hx; rcases hx with ⟨n, hn, rfl⟩\n  rw [nth_le_map_rev f, nth_le_map_rev g]; congr ; exact h\n#align map_eq_map_iff map_eq_map_iff\n\n",
 "map_eq_map":
 "@[simp]\ntheorem map_eq_map {α β} (f : α → β) (l : list α) : f <$> l = map f l :=\n  rfl\n#align map_eq_map map_eq_map\n\n",
 "map_eq_foldr":
 "theorem map_eq_foldr (f : α → β) (l : list α) : map f l = foldr (fun a bs => f a :: bs) [] l := by\n  induction l <;> simp [*]\n#align map_eq_foldr map_eq_foldr\n\n",
 "map_eq_bind":
 "theorem map_eq_bind {α β} (f : α → β) (l : list α) : map f l = l.bind fun x => [f x] :=\n  by\n  trans\n  rw [← bind_singleton' l, bind_map]\n  rfl\n#align map_eq_bind map_eq_bind\n\n",
 "map_eq_append_split":
 "theorem map_eq_append_split {f : α → β} {l : list α} {s₁ s₂ : list β} (h : map f l = s₁ ++ s₂) :\n    ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂ :=\n  by\n  have := h; rw [← take_append_drop (length s₁) l] at this⊢\n  rw [map_append] at this\n  refine' ⟨_, _, rfl, append_inj this _⟩\n  rw [length_map, length_take, min_eq_left]\n  rw [← length_map f l, h, length_append]\n  apply nat.le_add_right\n#align map_eq_append_split map_eq_append_split\n\n",
 "map_drop":
 "theorem map_drop {α β : Type _} (f : α → β) : ∀ (L : list α) (i : ℕ), (L.drop i).map f = (L.map f).drop i\n  | [], i => by simp\n  | L, 0 => by simp\n  | h :: t, n + 1 => by\n    dsimp\n    rw [map_drop]\n#align map_drop map_drop\n\n",
 "map_diff":
 "@[simp]\ntheorem map_diff [decidable_eq β] {f : α → β} (finj : injective f) {l₁ l₂ : list α} :\n    map f (l₁.diff l₂) = (map f l₁).diff (map f l₂) := by simp only [diff_eq_foldl, foldl_map, map_foldl_erase finj]\n#align map_diff map_diff\n\n",
 "map_const'":
 "-- Not a `simp` lemma because `function.const` is reducible in Lean 3\ntheorem map_const' (l : list α) (b : β) : map (fun _ => b) l = replicate l.length b :=\n  map_const l b\n#align map_const' map_const'\n\n",
 "map_const":
 "@[simp]\ntheorem map_const (l : list α) (b : β) : map (const α b) l = replicate l.length b :=\n  map_eq_replicate_iff.mpr fun x _ => rfl\n#align map_const map_const\n\n",
 "map_congr":
 "#print map_congr /-\ntheorem map_congr {f g : α → β} : ∀ {l : list α}, (∀ x ∈ l, f x = g x) → map f l = map g l\n  | [], _ => rfl\n  | a :: l, h => by\n    let ⟨h₁, h₂⟩ := forall_mem_cons.1 h\n    rw [map, map, h₁, map_congr h₂]\n#align map_congr map_congr\n-/\n\n",
 "map_concat":
 "theorem map_concat (f : α → β) (a : α) (l : list α) : map f (concat l a) = concat (map f l) (f a) := by\n  induction l <;> [rfl, simp only [*, concat_eq_append, cons_append, map, map_append]] <;> constructor <;> rfl\n#align map_concat map_concat\n\n",
 "map_comp_map":
 "/-- Composing a `list.map` with another `list.map` is equal to\na single `list.map` of composed functions.\n-/\n@[simp]\ntheorem map_comp_map (g : β → γ) (f : α → β) : map g ∘ map f = map (g ∘ f) :=\n  by\n  ext l\n  rw [comp_map]\n#align map_comp_map map_comp_map\n\n",
 "map_bind":
 "#print map_bind /-\ntheorem map_bind (g : β → list γ) (f : α → β) : ∀ l : list α, (list.map f l).bind g = l.bind fun a => g (f a)\n  | [] => rfl\n  | a :: l => by simp only [cons_bind, map_cons, map_bind l]\n#align map_bind map_bind\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.map (f : α → β) {l₁ l₂ : list α} (s : «expr <+ » l₁ l₂) : «expr <+ » (map f l₁) (map f l₂) :=\n  filterMap_eq_map f ▸ s.filter_map _\n#align sublist.map sublist.map\n\n",
 "lookmap_some":
 "theorem lookmap_some : ∀ l : list α, l.lookmap some = l\n  | [] => rfl\n  | a :: l => rfl\n#align lookmap_some lookmap_some\n\n",
 "lookmap_of_forall_not":
 "theorem lookmap_of_forall_not {l : list α} (H : ∀ a ∈ l, f a = none) : l.lookmap f = l :=\n  (lookmap_congr H).trans (lookmap_none l)\n#align lookmap_of_forall_not lookmap_of_forall_not\n\n",
 "lookmap_none":
 "theorem lookmap_none : ∀ l : list α, (l.lookmap fun _ => none) = l\n  | [] => rfl\n  | a :: l => congr_arg (cons a) (lookmap_none l)\n#align lookmap_none lookmap_none\n\n",
 "lookmap_nil":
 "@[simp]\ntheorem lookmap_nil : [].lookmap f = [] :=\n  rfl\n#align lookmap_nil lookmap_nil\n\n",
 "lookmap_map_eq":
 "theorem lookmap_map_eq (g : α → β) (h : ∀ (a), ∀ b ∈ f a, g a = g b) : ∀ l : list α, map g (l.lookmap f) = map g l\n  | [] => rfl\n  | a :: l => by\n    cases' h' : f a with b\n    · simp [h', lookmap_map_eq]\n    · simp [lookmap_cons_some _ _ h', h _ _ h']\n#align lookmap_map_eq lookmap_map_eq\n\n",
 "lookmap_id'":
 "theorem lookmap_id' (h : ∀ (a), ∀ b ∈ f a, a = b) (l : list α) : l.lookmap f = l := by\n  rw [← map_id (l.lookmap f), lookmap_map_eq, map_id] <;> exact h\n#align lookmap_id' lookmap_id'\n\n",
 "lookmap_cons_some":
 "@[simp]\ntheorem lookmap_cons_some {a b : α} (l : list α) (h : f a = some b) : (a :: l).lookmap f = b :: l := by\n  simp [lookmap, h]\n#align lookmap_cons_some lookmap_cons_some\n\n",
 "lookmap_cons_none":
 "@[simp]\ntheorem lookmap_cons_none {a : α} (l : list α) (h : f a = none) : (a :: l).lookmap f = a :: l.lookmap f := by\n  simp [lookmap, h]\n#align lookmap_cons_none lookmap_cons_none\n\n",
 "lookmap_congr":
 "theorem lookmap_congr {f g : α → option α} : ∀ {l : list α}, (∀ a ∈ l, f a = g a) → l.lookmap f = l.lookmap g\n  | [], H => rfl\n  | a :: l, H => by\n    cases' forall_mem_cons.1 H with H₁ H₂\n    cases' h : g a with b\n    · simp [h, H₁.trans h, lookmap_congr H₂]\n    · simp [lookmap_cons_some _ _ h, lookmap_cons_some _ _ (H₁.trans h)]\n#align lookmap_congr lookmap_congr\n\n",
 "length_singleton":
 "@[simp]\ntheorem length_singleton (a : α) : length [a] = 1 :=\n  rfl\n#align length_singleton length_singleton\n\n",
 "length_scanl":
 "-- scanl\ntheorem length_scanl : ∀ a l, length (scanl f a l) = l.length + 1\n  | a, [] => rfl\n  | a, x :: l => by erw [length_cons, length_cons, length_scanl]\n#align length_scanl length_scanl\n\n",
 "length_reverse":
 "@[simp]\ntheorem length_reverse (l : list α) : length (reverse l) = length l := by\n  induction l <;> [rfl, simp only [*, reverse_cons, length_append, length]]\n#align length_reverse length_reverse\n\n",
 "length_replicate":
 "@[simp]\ntheorem length_replicate : ∀ (n) (a : α), length (replicate n a) = n\n  | 0, a => rfl\n  | n + 1, a => congr_arg nat.succ (length_replicate n a)\n#align length_replicate length_replicate\n\n",
 "length_pos_of_ne_nil":
 "theorem length_pos_of_ne_nil {l : list α} : l ≠ [] → 0 < length l := fun h =>\n  pos_iff_ne_zero.2 fun h0 => h <| length_eq_zero.1 h0\n#align length_pos_of_ne_nil length_pos_of_ne_nil\n\n",
 "length_pos_of_mem":
 "theorem length_pos_of_mem {a : α} : ∀ {l : list α}, a ∈ l → 0 < length l\n  | b :: l, _ => zero_lt_succ _\n#align length_pos_of_mem length_pos_of_mem\n\n",
 "length_pos_iff_ne_nil":
 "theorem length_pos_iff_ne_nil {l : list α} : 0 < length l ↔ l ≠ [] :=\n  ⟨ne_nil_of_length_pos, length_pos_of_ne_nil⟩\n#align length_pos_iff_ne_nil length_pos_iff_ne_nil\n\n",
 "length_pos_iff_exists_mem":
 "theorem length_pos_iff_exists_mem {l : list α} : 0 < length l ↔ ∃ a, a ∈ l :=\n  ⟨exists_mem_of_length_pos, fun ⟨a, h⟩ => length_pos_of_mem h⟩\n#align length_pos_iff_exists_mem length_pos_iff_exists_mem\n\n",
 "length_pmap":
 "@[simp]\ntheorem length_pmap {p : α → Prop} {f : ∀ a, p a → β} {l H} : length (pmap f l H) = length l := by\n  induction l <;> [rfl, simp only [*, pmap, length]]\n#align length_pmap length_pmap\n\n",
 "length_lookmap":
 "theorem length_lookmap (l : list α) : length (l.lookmap f) = length l := by\n  rw [← length_map, lookmap_map_eq _ fun _ => (), length_map] <;> simp\n#align length_lookmap length_lookmap\n\n",
 "length_le_length_insert_nth":
 "theorem length_le_length_insert_nth (l : list α) (x : α) (n : ℕ) : l.length ≤ (insertNth n x l).length :=\n  by\n  cases' le_or_lt n l.length with hn hn\n  · rw [length_insert_nth _ _ hn]\n    exact (nat.lt_succ_self _).le\n  · rw [insert_nth_of_length_lt _ _ _ hn]\n#align length_le_length_insert_nth length_le_length_insert_nth\n\n",
 "length_insert_nth_le_succ":
 "theorem length_insert_nth_le_succ (l : list α) (x : α) (n : ℕ) : (insertNth n x l).length ≤ l.length + 1 :=\n  by\n  cases' le_or_lt n l.length with hn hn\n  · rw [length_insert_nth _ _ hn]\n  · rw [insert_nth_of_length_lt _ _ _ hn]\n    exact (nat.lt_succ_self _).le\n#align length_insert_nth_le_succ length_insert_nth_le_succ\n\n",
 "length_insert_nth":
 "theorem length_insert_nth : ∀ n as, n ≤ length as → length (insertNth n a as) = length as + 1\n  | 0, as, h => rfl\n  | n + 1, [], h => (nat.not_succ_le_zero _ h).elim\n  | n + 1, a' :: as, h => congr_arg nat.succ <| length_insert_nth n as (nat.le_of_succ_le_succ h)\n#align length_insert_nth length_insert_nth\n\n",
 "length_injective_iff":
 "@[simp]\ntheorem length_injective_iff : injective (list.length : list α → ℕ) ↔ subsingleton α :=\n  by\n  constructor\n  · intro h\n    refine' ⟨fun x y => _⟩\n    suffices [x] = [y] by simpa using this\n    apply h\n    rfl\n  · intro hα l1 l2 hl\n    induction l1 generalizing l2 <;> cases l2\n    · rfl\n    · cases hl\n    · cases hl\n    congr\n    exact subsingleton.elim _ _\n    apply l1_ih\n    simpa using hl\n#align length_injective_iff length_injective_iff\n\n",
 "length_injective":
 "@[simp]\ntheorem length_injective [subsingleton α] : injective (length : list α → ℕ) :=\n  length_injective_iff.mpr <| by infer_instance\n#align length_injective length_injective\n\n",
 "length_init":
 "@[simp]\ntheorem length_init : ∀ l : list α, length (dropLast l) = length l - 1\n  | [] => rfl\n  | [a] => rfl\n  | a :: b :: l => by\n    rw [init]\n    simp only [add_left_inj, length, succ_add_sub_one]\n    exact length_init (b :: l)\n#align length_init length_init\n\n",
 "length_filter_map_le":
 "theorem length_filter_map_le (f : α → option β) (l : list α) : (list.filter_map f l).length ≤ l.length :=\n  by\n  rw [← list.length_map some, List.map_filterMap_some_eq_filter_map_is_some, ← list.length_map f]\n  apply List.length_filter_le\n#align length_filter_map_le length_filter_map_le\n\n",
 "length_filter_le":
 "theorem length_filter_le (p : α → Prop) [decidable_pred p] (l : list α) : (l.filter p).length ≤ l.length :=\n  (List.filter_sublist _).length_le\n#align length_filter_le length_filter_le\n\n",
 "length_erasep_of_mem":
 "@[simp]\ntheorem length_erasep_of_mem {l : list α} {a} (al : a ∈ l) (pa : p a) : length (l.erasep p) = pred (length l) := by\n  rcases exists_of_erasep al pa with ⟨_, l₁, l₂, _, _, e₁, e₂⟩ <;> rw [e₂] <;> simp [-add_comm, e₁] <;> rfl\n#align length_erasep_of_mem length_erasep_of_mem\n\n",
 "length_erasep_add_one":
 "@[simp]\ntheorem length_erasep_add_one {l : list α} {a} (al : a ∈ l) (pa : p a) : (l.erasep p).length + 1 = l.length :=\n  by\n  let ⟨_, l₁, l₂, _, _, h₁, h₂⟩ := exists_of_eraseP al pa\n  rw [h₂, h₁, length_append, length_append]\n  rfl\n#align length_erasep_add_one length_erasep_add_one\n\n",
 "length_erase_of_mem":
 "@[simp]\ntheorem length_erase_of_mem {a : α} {l : list α} (h : a ∈ l) : length (l.erase a) = pred (length l) := by\n  rw [erase_eq_erasep] <;> exact length_erasep_of_mem h rfl\n#align length_erase_of_mem length_erase_of_mem\n\n",
 "length_erase_add_one":
 "@[simp]\ntheorem length_erase_add_one {a : α} {l : list α} (h : a ∈ l) : (l.erase a).length + 1 = l.length := by\n  rw [erase_eq_erasep, length_erasep_add_one h rfl]\n#align length_erase_add_one length_erase_add_one\n\n",
 "length_eq_zero":
 "theorem length_eq_zero {l : list α} : length l = 0 ↔ l = [] :=\n  ⟨eq_nil_of_length_eq_zero, fun h => h.symm ▸ rfl⟩\n#align length_eq_zero length_eq_zero\n\n",
 "length_eq_two":
 "theorem length_eq_two {l : list α} : l.length = 2 ↔ ∃ a b, l = [a, b] :=\n  ⟨match l with\n    | [a, b], _ => ⟨a, b, rfl⟩,\n    fun ⟨a, b, e⟩ => e.symm ▸ rfl⟩\n#align length_eq_two length_eq_two\n\n",
 "length_eq_three":
 "theorem length_eq_three {l : list α} : l.length = 3 ↔ ∃ a b c, l = [a, b, c] :=\n  ⟨match l with\n    | [a, b, c], _ => ⟨a, b, c, rfl⟩,\n    fun ⟨a, b, c, e⟩ => e.symm ▸ rfl⟩\n#align length_eq_three length_eq_three\n\n",
 "length_eq_one":
 "theorem length_eq_one {l : list α} : length l = 1 ↔ ∃ a, l = [a] :=\n  ⟨match l with\n    | [a], _ => ⟨a, rfl⟩,\n    fun ⟨a, e⟩ => e.symm ▸ rfl⟩\n#align length_eq_one length_eq_one\n\n",
 "length_enum_from":
 "theorem length_enum_from : ∀ (n) (l : list α), length (enum_from n l) = length l\n  | n, [] => rfl\n  | n, a :: l => congr_arg nat.succ (length_enum_from _ _)\n#align length_enum_from length_enum_from\n\n",
 "length_enum":
 "theorem length_enum : ∀ l : list α, length (enum l) = length l :=\n  length_enumFrom _\n#align length_enum length_enum\n\n",
 "length_concat":
 "theorem length_concat (a : α) (l : list α) : length (concat l a) = succ (length l) := by\n  simp only [concat_eq_append, length_append, length]\n#align length_concat length_concat\n\n",
 "length_attach":
 "@[simp]\ntheorem length_attach (L : list α) : L.attach.length = L.length :=\n  length_pmap\n#align length_attach length_attach\n\n",
 "last_singleton":
 "@[simp]\ntheorem last_singleton (a : α) : getLast [a] (cons_ne_nil a []) = a :=\n  rfl\n#align last_singleton last_singleton\n\n",
 "last_reverse":
 "-- `list.sum`\n-- `list.alternating_sum`\ntheorem last_reverse {l : list α} (hl : l.reverse ≠ [])\n    (hl' : 0 < l.length :=\n      (by\n        contrapose! hl\n        simpa [length_eq_zero] using hl)) :\n    l.reverse.last hl = l.nth_le 0 hl' :=\n  by\n  rw [last_eq_nth_le, nth_le_reverse']\n  · simp\n  · simpa using hl'\n#align last_reverse last_reverse\n\n",
 "last_replicate_succ":
 "theorem last_replicate_succ (m : ℕ) (a : α) :\n    (replicate (m + 1) a).last (ne_nil_of_length_eq_succ (length_replicate (m + 1) a)) = a :=\n  by\n  simp only [replicate_succ']\n  exact last_append_singleton _\n#align last_replicate_succ last_replicate_succ\n\n",
 "last_pmap":
 "theorem last_pmap {α β : Type _} (p : α → Prop) (f : ∀ a, p a → β) (l : list α) (hl₁ : ∀ a ∈ l, p a) (hl₂ : l ≠ []) :\n    (l.pmap f hl₁).last (mt List.pmap_eq_nil.1 hl₂) = f (l.last hl₂) (hl₁ _ (List.getLast_mem hl₂)) :=\n  by\n  induction' l with l_hd l_tl l_ih\n  · apply (hl₂ rfl).elim\n  · cases l_tl\n    · simp\n    · apply l_ih\n#align last_pmap last_pmap\n\n",
 "last_mem":
 "theorem last_mem : ∀ {l : list α} (h : l ≠ []), getLast l h ∈ l\n  | [], h => absurd rfl h\n  | [a], h => or.inl rfl\n  | a :: b :: l, h =>\n    or.inr <| by\n      rw [last_cons_cons]\n      exact last_mem (cons_ne_nil b l)\n#align last_mem last_mem\n\n",
 "last_map":
 "theorem last_map (f : α → β) {l : list α} (hl : l ≠ []) : (l.map f).last (mt eq_nil_of_map_eq_nil hl) = f (l.last hl) :=\n  by\n  induction' l with l_hd l_tl l_ih\n  · apply (hl rfl).elim\n  · cases l_tl\n    · simp\n    · simpa using l_ih\n#align last_map last_map\n\n",
 "last_eq_of_concat_eq":
 "theorem last_eq_of_concat_eq {a b : α} {l : list α} : concat l a = concat l b → a = b :=\n  by\n  intro h\n  rw [concat_eq_append, concat_eq_append] at h\n  exact head_eq_of_cons_eq (append_left_cancel h)\n#align last_eq_of_concat_eq last_eq_of_concat_eq\n\n",
 "last_eq_nth_le":
 "theorem last_eq_nth_le :\n    ∀ (l : list α) (h : l ≠ []), getLast l h = l.nth_le (l.length - 1) (nat.sub_lt (length_pos_of_ne_nil h) one_pos)\n  | [], h => rfl\n  | [a], h => by rw [last_singleton, nth_le_singleton]\n  | a :: b :: l, h => by\n    rw [last_cons, last_eq_nth_le (b :: l)]\n    rfl\n    exact cons_ne_nil b l\n#align last_eq_nth_le last_eq_nth_le\n\n",
 "last_cons_cons":
 "@[simp]\ntheorem last_cons_cons (a₁ a₂ : α) (l : list α) :\n    getLast (a₁ :: a₂ :: l) (cons_ne_nil _ _) = getLast (a₂ :: l) (cons_ne_nil a₂ l) :=\n  rfl\n#align last_cons_cons last_cons_cons\n\n",
 "last_cons":
 "@[simp]\ntheorem last_cons {a : α} {l : list α} : ∀ h : l ≠ nil, getLast (a :: l) (cons_ne_nil a l) = getLast l h :=\n  by\n  induction l <;> intros\n  contradiction\n  rfl\n#align last_cons last_cons\n\n",
 "last_congr":
 "theorem last_congr {l₁ l₂ : list α} (h₁ : l₁ ≠ []) (h₂ : l₂ ≠ []) (h₃ : l₁ = l₂) : getLast l₁ h₁ = getLast l₂ h₂ := by\n  subst l₁\n#align last_congr last_congr\n\n",
 "last_concat":
 "theorem last_concat {a : α} (l : list α) : getLast (concat l a) (concat_ne_nil a l) = a := by\n  simp only [concat_eq_append, last_append_singleton]\n#align last_concat last_concat\n\n",
 "last_append_singleton":
 "@[simp]\ntheorem last_append_singleton {a : α} (l : list α) :\n    getLast (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a := by\n  induction l <;> [rfl, simp only [cons_append, last_cons fun H => cons_ne_nil _ _ (append_eq_nil.1 H).2, *]]\n#align last_append_singleton last_append_singleton\n\n",
 "last_append":
 "theorem last_append (l₁ l₂ : list α) (h : l₂ ≠ []) :\n    getLast (l₁ ++ l₂) (append_ne_nil_of_ne_nil_right l₁ l₂ h) = getLast l₂ h :=\n  by\n  induction' l₁ with _ _ ih\n  · simp\n  · simp only [cons_append]\n    rw [List.getLast_cons]\n    exact ih\n#align last_append last_append\n\n",
 "last'_is_some":
 "@[simp]\ntheorem last'_is_some : ∀ {l : list α}, l.last'.is_some ↔ l ≠ []\n  | [] => by simp\n  | [a] => by simp\n  | a :: b :: l => by simp [@last'_is_some (b :: l)]\n#align last'_is_some last'_is_some\n\n",
 "last'_is_none":
 "@[simp]\ntheorem last'_is_none : ∀ {l : list α}, (getLast? l).is_none ↔ l = []\n  | [] => by simp\n  | [a] => by simp\n  | a :: b :: l => by simp [@last'_is_none (b :: l)]\n#align last'_is_none last'_is_none\n\n",
 "last'_eq_last_of_ne_nil":
 "theorem last'_eq_last_of_ne_nil : ∀ {l : list α} (h : l ≠ []), l.last' = some (l.last h)\n  | [], h => (h rfl).elim\n  | [a], _ => by\n    unfold last\n    unfold last'\n  | a :: b :: l, _ => @last'_eq_last_of_ne_nil (b :: l) (cons_ne_nil _ _)\n#align last'_eq_last_of_ne_nil last'_eq_last_of_ne_nil\n\n",
 "last'_cons_cons":
 "@[simp]\ntheorem last'_cons_cons (x y : α) (l : list α) : getLast? (x :: y :: l) = getLast? (y :: l) :=\n  rfl\n#align last'_cons_cons last'_cons_cons\n\n",
 "last'_append_of_ne_nil":
 "theorem last'_append_of_ne_nil (l₁ : list α) : ∀ {l₂ : list α} (hl₂ : l₂ ≠ []), getLast? (l₁ ++ l₂) = getLast? l₂\n  | [], hl₂ => by contradiction\n  | b :: l₂, _ => getLast?_append_cons l₁ b l₂\n#align last'_append_of_ne_nil last'_append_of_ne_nil\n\n",
 "last'_append_cons":
 "@[simp]\ntheorem last'_append_cons : ∀ (l₁ : list α) (a : α) (l₂ : list α), getLast? (l₁ ++ a :: l₂) = getLast? (a :: l₂)\n  | [], a, l₂ => rfl\n  | [b], a, l₂ => rfl\n  | b :: c :: l₁, a, l₂ => by rw [cons_append, cons_append, last', ← cons_append, last'_append_cons]\n#align last'_append_cons last'_append_cons\n\n",
 "last'_append":
 "theorem last'_append {l₁ l₂ : list α} {x : α} (h : x ∈ l₂.last') : x ∈ (l₁ ++ l₂).last' :=\n  by\n  cases l₂\n  · contradiction\n  · rw [List.getLast?_append_cons]\n    exact h\n#align last'_append last'_append\n\n",
 "join_replicate_nil":
 "@[simp]\ntheorem join_replicate_nil (n : ℕ) : join (replicate n []) = @nil α := by\n  induction n <;> [rfl, simp only [*, replicate, join, append_nil]]\n#align join_replicate_nil join_replicate_nil\n\n",
 "inth_zero_eq_head":
 "theorem inth_zero_eq_head : l.inth 0 = l.head := by cases l <;> rfl\n#align inth_zero_eq_head inth_zero_eq_head\n\n",
 "inth_nil":
 "@[simp]\ntheorem inth_nil : getI ([] : list α) n = default :=\n  rfl\n#align inth_nil inth_nil\n\n",
 "inth_eq_nth_le":
 "theorem inth_eq_nth_le {n : ℕ} (hn : n < l.length) : l.inth n = l.nth_le n hn :=\n  getD_eq_nthLe _ _ _\n#align inth_eq_nth_le inth_eq_nth_le\n\n",
 "inth_eq_iget_nth":
 "theorem inth_eq_iget_nth (n : ℕ) : l.inth n = (l.nth n).iget := by\n  rw [← nthd_default_eq_inth, nthd_eq_get_or_else_nth, Option.getD_default_eq_iget]\n#align inth_eq_iget_nth inth_eq_iget_nth\n\n",
 "inth_eq_default":
 "theorem inth_eq_default {n : ℕ} (hn : l.length ≤ n) : l.inth n = default :=\n  getD_eq_default _ _ hn\n#align inth_eq_default inth_eq_default\n\n",
 "inth_cons_zero":
 "@[simp]\ntheorem inth_cons_zero : getI (x :: xs) 0 = x :=\n  rfl\n#align inth_cons_zero inth_cons_zero\n\n",
 "inth_cons_succ":
 "@[simp]\ntheorem inth_cons_succ : getI (x :: xs) (n + 1) = getI xs n :=\n  rfl\n#align inth_cons_succ inth_cons_succ\n\n",
 "inth_append_right":
 "theorem inth_append_right (l l' : list α) (n : ℕ) (h : l.length ≤ n) : (l ++ l').inth n = l'.inth (n - l.length) :=\n  getD_append_right _ _ _ _ h\n#align inth_append_right inth_append_right\n\n",
 "inth_append":
 "theorem inth_append (l l' : list α) (n : ℕ) (h : n < l.length)\n    (h' : n < (l ++ l').length := h.trans_le ((length_append l l').symm ▸ le_self_add)) : (l ++ l').inth n = l.inth n :=\n  getD_append _ _ _ _ h h'\n#align inth_append inth_append\n\n",
 "intersperse_singleton":
 "@[simp]\ntheorem intersperse_singleton {α : Type u} (a b : α) : intersperse a [b] = [b] :=\n  rfl\n#align intersperse_singleton intersperse_singleton\n\n",
 "intersperse_nil":
 "@[simp]\ntheorem intersperse_nil {α : Type u} (a : α) : intersperse a [] = [] :=\n  rfl\n#align intersperse_nil intersperse_nil\n\n",
 "intersperse_cons_cons":
 "@[simp]\ntheorem intersperse_cons_cons {α : Type u} (a b c : α) (tl : list α) :\n    intersperse a (b :: c :: tl) = b :: a :: intersperse a (c :: tl) :=\n  rfl\n#align intersperse_cons_cons intersperse_cons_cons\n\n",
 "intercalate_split_on":
 "/-- `intercalate [x]` is the left inverse of `split_on x`  -/\ntheorem intercalate_split_on (x : α) [decidable_eq α] : [x].intercalate (xs.split_on x) = xs :=\n  by\n  simp only [intercalate, split_on]\n  induction' xs with hd tl ih; · simp [join]; simp only [split_on_p_cons]\n  cases' h' : split_on_p (· = x) tl with hd' tl'; · exact (split_on_p_ne_nil _ tl h').elim\n  rw [h'] at ih; split_ifs;\n  · subst h\n    simp [ih, join]\n  cases tl' <;> simpa [join] using ih\n#align intercalate_split_on intercalate_split_on\n\n",
 "insert_pos":
 "theorem insert_pos [decidable_eq α] {x : α} {l : list α} (h : x ∈ l) : has_insert.insert x l = l :=\n  if_pos h\n#align insert_pos insert_pos\n\n",
 "insert_nth_zero":
 "@[simp]\ntheorem insert_nth_zero (s : list α) (x : α) : insertNth 0 x s = x :: s :=\n  rfl\n#align insert_nth_zero insert_nth_zero\n\n",
 "insert_nth_succ_nil":
 "@[simp]\ntheorem insert_nth_succ_nil (n : ℕ) (a : α) : insertNth (n + 1) a [] = [] :=\n  rfl\n#align insert_nth_succ_nil insert_nth_succ_nil\n\n",
 "insert_nth_succ_cons":
 "@[simp]\ntheorem insert_nth_succ_cons (s : list α) (hd x : α) (n : ℕ) : insertNth (n + 1) x (hd :: s) = hd :: insertNth n x s :=\n  rfl\n#align insert_nth_succ_cons insert_nth_succ_cons\n\n",
 "insert_nth_remove_nth_of_le":
 "theorem insert_nth_remove_nth_of_le :\n    ∀ n m as, n < length as → m ≤ n → insertNth m a (as.remove_nth n) = (as.insert_nth m a).remove_nth (n + 1)\n  | n, 0, a :: as, has, hmn => rfl\n  | n + 1, m + 1, a :: as, has, hmn =>\n    congr_arg (cons a) <| insert_nth_remove_nth_of_le n m as (nat.lt_of_succ_lt_succ has) (nat.le_of_succ_le_succ hmn)\n#align insert_nth_remove_nth_of_le insert_nth_remove_nth_of_le\n\n",
 "insert_nth_remove_nth_of_ge":
 "theorem insert_nth_remove_nth_of_ge :\n    ∀ n m as, n < length as → n ≤ m → insertNth m a (as.remove_nth n) = (as.insert_nth (m + 1) a).remove_nth n\n  | 0, 0, [], has, _ => (lt_irrefl _ has).elim\n  | 0, 0, a :: as, has, hmn => by simp [remove_nth, insert_nth]\n  | 0, m + 1, a :: as, has, hmn => rfl\n  | n + 1, m + 1, a :: as, has, hmn =>\n    congr_arg (cons a) <| insert_nth_remove_nth_of_ge n m as (nat.lt_of_succ_lt_succ has) (nat.le_of_succ_le_succ hmn)\n#align insert_nth_remove_nth_of_ge insert_nth_remove_nth_of_ge\n\n",
 "insert_nth_of_length_lt":
 "theorem insert_nth_of_length_lt (l : list α) (x : α) (n : ℕ) (h : l.length < n) : insertNth n x l = l :=\n  by\n  induction' l with hd tl IH generalizing n\n  · cases n\n    · simpa using h\n    · simp\n  · cases n\n    · simpa using h\n    · simp only [Nat.succ_lt_succ_iff, length] at h\n      simpa using IH _ h\n#align insert_nth_of_length_lt insert_nth_of_length_lt\n\n",
 "insert_nth_length_self":
 "@[simp]\ntheorem insert_nth_length_self (l : list α) (x : α) : insertNth l.length x l = l ++ [x] :=\n  by\n  induction' l with hd tl IH\n  · simp\n  · simpa using IH\n#align insert_nth_length_self insert_nth_length_self\n\n",
 "insert_nth_injective":
 "theorem insert_nth_injective (n : ℕ) (x : α) : function.injective (insertNth n x) :=\n  by\n  induction' n with n IH\n  · have : insert_nth 0 x = cons x := funext fun _ => rfl\n    simp [this]\n  · rintro (_ | ⟨a, as⟩) (_ | ⟨b, bs⟩) h <;> first |simpa [IH.eq_iff] using h|rfl\n#align insert_nth_injective insert_nth_injective\n\n",
 "insert_nth_comm":
 "theorem insert_nth_comm (a b : α) :\n    ∀ (i j : ℕ) (l : list α) (h : i ≤ j) (hj : j ≤ length l),\n      (l.insert_nth i a).insert_nth (j + 1) b = (l.insert_nth j b).insert_nth i a\n  | 0, j, l => by simp [insert_nth]\n  | i + 1, 0, l => fun h => (nat.not_lt_zero _ h).elim\n  | i + 1, j + 1, [] => by simp\n  | i + 1, j + 1, c :: l => fun h₀ h₁ => by\n    simp [insert_nth] <;> exact insert_nth_comm i j l (nat.le_of_succ_le_succ h₀) (nat.le_of_succ_le_succ h₁)\n#align insert_nth_comm insert_nth_comm\n\n",
 "insert_neg":
 "theorem insert_neg [decidable_eq α] {x : α} {l : list α} (h : x ∉ l) : has_insert.insert x l = x :: l :=\n  if_neg h\n#align insert_neg insert_neg\n\n",
 "injective_foldl_comp":
 "theorem injective_foldl_comp {α : Type _} {l : list (α → α)} {f : α → α} (hl : ∀ f ∈ l, function.injective f)\n    (hf : function.injective f) : function.injective (@list.foldl (α → α) (α → α) function.comp f l) :=\n  by\n  induction l generalizing f\n  · exact hf\n  · apply l_ih fun _ h => hl _ (list.mem_cons_of_mem _ h)\n    apply function.injective.comp hf\n    apply hl _ (list.mem_cons_self _ _)\n#align injective_foldl_comp injective_foldl_comp\n\n",
 "init_take":
 "theorem init_take {n : ℕ} {l : list α} (h : n < l.length) : (l.take n).init = l.take n.pred := by\n  simp [init_eq_take, min_eq_left_of_lt h, take_take, pred_le]\n#align init_take init_take\n\n",
 "init_eq_take":
 "theorem init_eq_take (l : list α) : l.init = l.take l.length.pred :=\n  by\n  cases' l with x l\n  · simp [init]\n  · induction' l with hd tl hl generalizing x\n    · simp [init]\n    · simp [init, hl]\n#align init_eq_take init_eq_take\n\n",
 "init_eq_of_concat_eq":
 "theorem init_eq_of_concat_eq {a : α} {l₁ l₂ : list α} : concat l₁ a = concat l₂ a → l₁ = l₂ :=\n  by\n  intro h\n  rw [concat_eq_append, concat_eq_append] at h\n  exact append_right_cancel h\n#align init_eq_of_concat_eq init_eq_of_concat_eq\n\n",
 "init_cons_of_ne_nil":
 "@[simp]\ntheorem init_cons_of_ne_nil {α : Type _} {x : α} : ∀ {l : list α} (h : l ≠ []), (x :: l).init = x :: l.init\n  | [], h => false.elim (h rfl)\n  | a :: l, _ => by simp [init]\n#align init_cons_of_ne_nil init_cons_of_ne_nil\n\n",
 "init_append_of_ne_nil":
 "@[simp]\ntheorem init_append_of_ne_nil {α : Type _} {l : list α} : ∀ (l' : list α) (h : l ≠ []), (l' ++ l).init = l' ++ l.init\n  | [], _ => by simp only [nil_append]\n  | a :: l', h => by simp [append_ne_nil_of_ne_nil_right l' l h, init_append_of_ne_nil l' h]\n#align init_append_of_ne_nil init_append_of_ne_nil\n\n",
 "init_append_last'":
 "theorem init_append_last' : ∀ {l : list α}, ∀ a ∈ l.last', dropLast l ++ [a] = l\n  | [], a, ha => (option.not_mem_none a ha).elim\n  | [a], _, rfl => rfl\n  | a :: b :: l, c, hc => by\n    rw [last'] at hc\n    rw [init, cons_append, init_append_last' _ hc]\n#align init_append_last' init_append_last'\n\n",
 "init_append_last":
 "theorem init_append_last : ∀ {l : list α} (h : l ≠ []), dropLast l ++ [getLast l h] = l\n  | [], h => absurd rfl h\n  | [a], h => rfl\n  | a :: b :: l, h => by\n    rw [init, cons_append, last_cons (cons_ne_nil _ _)]\n    congr\n    exact init_append_last (cons_ne_nil b l)\n#align init_append_last init_append_last\n\n",
 "index_of_of_not_mem":
 "@[simp]\ntheorem index_of_of_not_mem {l : list α} {a : α} : a ∉ l → indexOf a l = length l :=\n  indexOf_eq_length.2\n#align index_of_of_not_mem index_of_of_not_mem\n\n",
 "index_of_nth_le":
 "@[simp]\ntheorem index_of_nth_le [decidable_eq α] {a : α} : ∀ {l : list α} (h), nthLe l (indexOf a l) h = a\n  | b :: l, h => by by_cases h' : a = b <;> simp only [h', if_pos, if_false, index_of_cons, nth_le, @index_of_nth_le l]\n#align index_of_nth_le index_of_nth_le\n\n",
 "index_of_nth":
 "@[simp]\ntheorem index_of_nth [decidable_eq α] {a : α} {l : list α} (h : a ∈ l) : get? l (indexOf a l) = some a := by\n  rw [nth_le_nth, index_of_nth_le (index_of_lt_length.2 h)]\n#align index_of_nth index_of_nth\n\n",
 "index_of_nil":
 "@[simp]\ntheorem index_of_nil (a : α) : indexOf a [] = 0 :=\n  rfl\n#align index_of_nil index_of_nil\n\n",
 "index_of_lt_length":
 "theorem index_of_lt_length {a} {l : list α} : indexOf a l < length l ↔ a ∈ l :=\n  ⟨fun h => decidable.by_contradiction fun al => ne_of_lt h <| indexOf_eq_length.2 al, fun al =>\n    lt_of_le_of_ne indexOf_le_length fun h => indexOf_eq_length.1 h al⟩\n#align index_of_lt_length index_of_lt_length\n\n",
 "index_of_le_length":
 "theorem index_of_le_length {a : α} {l : list α} : indexOf a l ≤ length l :=\n  by\n  induction' l with b l ih; · rfl\n  simp only [length, index_of_cons]\n  by_cases h : a = b;\n  · rw [if_pos h]\n    exact nat.zero_le _\n  rw [if_neg h]; exact succ_le_succ ih\n#align index_of_le_length index_of_le_length\n\n",
 "index_of_inj":
 "theorem index_of_inj [decidable_eq α] {l : list α} {x y : α} (hx : x ∈ l) (hy : y ∈ l) :\n    indexOf x l = indexOf y l ↔ x = y :=\n  ⟨fun h =>\n    by\n    have : nthLe l (indexOf x l) (indexOf_lt_length.2 hx) = nthLe l (indexOf y l) (indexOf_lt_length.2 hy) := by\n      simp only [h]\n    simpa only [index_of_nth_le] , fun h => by subst h⟩\n#align index_of_inj index_of_inj\n\n",
 "index_of_eq_length":
 "theorem index_of_eq_length {a : α} {l : list α} : indexOf a l = length l ↔ a ∉ l :=\n  by\n  induction' l with b l ih\n  · exact iff_of_true rfl (not_mem_nil _)\n  simp only [length, mem_cons_iff, index_of_cons]; split_ifs\n  · exact iff_of_false (by rintro ⟨⟩) fun H => H <| or.inl h\n  · simp only [h, false_or_iff]\n    rw [← ih]\n    exact succ_inj'\n#align index_of_eq_length index_of_eq_length\n\n",
 "index_of_cons_self":
 "@[simp]\ntheorem index_of_cons_self (a : α) (l : list α) : indexOf a (a :: l) = 0 :=\n  indexOf_cons_eq _ rfl\n#align index_of_cons_self index_of_cons_self\n\n",
 "index_of_cons_ne":
 "@[simp]\ntheorem index_of_cons_ne {a b : α} (l : list α) : a ≠ b → indexOf a (b :: l) = succ (indexOf a l) := fun n => if_neg n\n#align index_of_cons_ne index_of_cons_ne\n\n",
 "index_of_cons_eq":
 "theorem index_of_cons_eq {a b : α} (l : list α) : a = b → indexOf a (b :: l) = 0 := fun e => if_pos e\n#align index_of_cons_eq index_of_cons_eq\n\n",
 "index_of_cons":
 "theorem index_of_cons (a b : α) (l : list α) : indexOf a (b :: l) = if a = b then 0 else succ (indexOf a l) :=\n  rfl\n#align index_of_cons index_of_cons\n\n",
 "index_of_append_of_not_mem":
 "theorem index_of_append_of_not_mem {a : α} (h : a ∉ l₁) : indexOf a (l₁ ++ l₂) = l₁.length + indexOf a l₂ :=\n  by\n  induction' l₁ with d₁ t₁ ih\n  · rw [list.nil_append, list.length, zero_add]\n  rw [list.cons_append, index_of_cons_ne _ (ne_of_not_mem_cons h), list.length, ih (not_mem_of_not_mem_cons h),\n    nat.succ_add]\n#align index_of_append_of_not_mem index_of_append_of_not_mem\n\n",
 "index_of_append_of_mem":
 "theorem index_of_append_of_mem {a : α} (h : a ∈ l₁) : indexOf a (l₁ ++ l₂) = indexOf a l₁ :=\n  by\n  induction' l₁ with d₁ t₁ ih\n  · exfalso\n    exact not_mem_nil a h\n  rw [list.cons_append]\n  by_cases hh : a = d₁\n  · iterate 2 rw [index_of_cons_eq _ hh]\n  rw [index_of_cons_ne _ hh, index_of_cons_ne _ hh, ih (mem_of_ne_of_mem hh h)]\n#align index_of_append_of_mem index_of_append_of_mem\n\n",
 "imp":
 "theorem all₂.imp (h : ∀ x, p x → q x) : ∀ {l : list α}, All₂ p l → All₂ q l\n  | [] => id\n  | x :: l => by simpa using and.imp (h x) all₂.imp\n#align all₂.imp all₂.imp\n\n",
 "ilast_eq_last'":
 "theorem ilast_eq_last' [inhabited α] : ∀ l : list α, l.ilast = l.last'.iget\n  | [] => by simp [ilast, Inhabited.default]\n  | [a] => rfl\n  | [a, b] => rfl\n  | [a, b, c] => rfl\n  | a :: b :: c :: l => by simp [ilast, ilast_eq_last' (c :: l)]\n#align ilast_eq_last' ilast_eq_last'\n\n",
 "ilast'_mem":
 "theorem ilast'_mem : ∀ a l, @ilast' α a l ∈ a :: l\n  | a, [] => or.inl rfl\n  | a, b :: l => or.inr (ilast'_mem b l)\n#align ilast'_mem ilast'_mem\n\n",
 "head_mem_self":
 "theorem head_mem_self [inhabited α] {l : list α} (h : l ≠ nil) : l.head ∈ l :=\n  by\n  have h' := mem_cons_self l.head l.tail\n  rwa [cons_head_tail h] at h'\n#align head_mem_self head_mem_self\n\n",
 "head_mem_head'":
 "theorem head_mem_head' [inhabited α] : ∀ {l : list α} (h : l ≠ []), headI l ∈ head? l\n  | [], h => by contradiction\n  | a :: l, h => rfl\n#align head_mem_head' head_mem_head'\n\n",
 "head_eq_of_cons_eq":
 "theorem head_eq_of_cons_eq {h₁ h₂ : α} {t₁ t₂ : list α} : h₁ :: t₁ = h₂ :: t₂ → h₁ = h₂ := fun Peq =>\n  list.no_confusion Peq fun Pheq Pteq => Pheq\n#align head_eq_of_cons_eq head_eq_of_cons_eq\n\n",
 "head_eq_head'":
 "theorem head_eq_head' [inhabited α] (l : list α) : headI l = (head? l).iget := by cases l <;> rfl\n#align head_eq_head' head_eq_head'\n\n",
 "head_cons":
 "@[simp]\ntheorem head_cons [inhabited α] (a : α) (l : list α) : headI (a :: l) = a :=\n  rfl\n#align head_cons head_cons\n\n",
 "head_append":
 "@[simp]\ntheorem head_append [inhabited α] (t : list α) {s : list α} (h : s ≠ []) : headI (s ++ t) = headI s :=\n  by\n  induction s\n  contradiction\n  rfl\n#align head_append head_append\n\n",
 "head'_map":
 "@[simp]\ntheorem head'_map (f : α → β) (l) : head? (map f l) = (head? l).map f := by cases l <;> rfl\n#align head'_map head'_map\n\n",
 "head'_append_of_ne_nil":
 "theorem head'_append_of_ne_nil : ∀ (l₁ : list α) {l₂ : list α} (hl₁ : l₁ ≠ []), head? (l₁ ++ l₂) = head? l₁\n  | [], _, hl₁ => by contradiction\n  | x :: l₁, _, _ => rfl\n#align head'_append_of_ne_nil head'_append_of_ne_nil\n\n",
 "head'_append":
 "theorem head'_append {s t : list α} {x : α} (h : x ∈ s.head') : x ∈ (s ++ t).head' :=\n  by\n  cases s\n  contradiction\n  exact h\n#align head'_append head'_append\n\n",
 "forall_mem_singleton":
 "theorem forall_mem_singleton {p : α → Prop} {a : α} : (∀ x ∈ [a], p x) ↔ p a := by simp only [mem_singleton, forall_eq]\n#align forall_mem_singleton forall_mem_singleton\n\n",
 "forall_mem_of_forall_mem_cons":
 "theorem forall_mem_of_forall_mem_cons {p : α → Prop} {a : α} {l : list α} (h : ∀ x ∈ a :: l, p x) : ∀ x ∈ l, p x :=\n  (forall_mem_cons.1 h).2\n#align forall_mem_of_forall_mem_cons forall_mem_of_forall_mem_cons\n\n",
 "forall_mem_nil":
 "theorem forall_mem_nil (p : α → Prop) : ∀ x ∈ @nil α, p x :=\n  fun.\n#align forall_mem_nil forall_mem_nil\n\n",
 "forall_mem_map_iff":
 "theorem forall_mem_map_iff {f : α → β} {l : list α} {P : β → Prop} : (∀ i ∈ l.map f, P i) ↔ ∀ j ∈ l, P (f j) :=\n  by\n  constructor\n  · intro H j hj\n    exact H (f j) (mem_map_of_mem f hj)\n  · intro H i hi\n    rcases mem_map.1 hi with ⟨j, hj, ji⟩\n    rw [← ji]\n    exact H j hj\n#align forall_mem_map_iff forall_mem_map_iff\n\n",
 "forall_mem_cons":
 "theorem forall_mem_cons : ∀ {p : α → Prop} {a : α} {l : list α}, (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x :=\n  ball_cons\n#align forall_mem_cons forall_mem_cons\n\n",
 "forall_mem_append":
 "theorem forall_mem_append {p : α → Prop} {l₁ l₂ : list α} : (∀ x ∈ l₁ ++ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ ∀ x ∈ l₂, p x :=\n  by simp only [mem_append, or_imp, forall_and]\n#align forall_mem_append forall_mem_append\n\n",
 "foldr_reverse":
 "theorem foldr_reverse (f : α → β → β) (a : β) (l : list α) : foldr f a (reverse l) = foldl (fun x y => f y x) a l :=\n  by\n  let t := foldl_reverse (fun x y => f y x) a (reverse l)\n  rw [reverse_reverse l] at t <;> rwa [t]\n#align foldr_reverse foldr_reverse\n\n",
 "foldr_rec_on_nil":
 "@[simp]\ntheorem foldr_rec_on_nil {C : β → Sort _} (op : α → β → β) (b) (hb : C b) (hl) : foldrRecOn [] op b hb hl = hb :=\n  rfl\n#align foldr_rec_on_nil foldr_rec_on_nil\n\n",
 "foldr_rec_on_cons":
 "@[simp]\ntheorem foldr_rec_on_cons {C : β → Sort _} (x : α) (l : list α) (op : α → β → β) (b) (hb : C b)\n    (hl : ∀ (b : β) (hb : C b) (a : α) (ha : a ∈ x :: l), C (op a b)) :\n    foldrRecOn (x :: l) op b hb hl =\n      hl _ (foldrRecOn l op b hb fun b hb a ha => hl b hb a (mem_cons_of_mem _ ha)) x (mem_cons_self _ _) :=\n  rfl\n#align foldr_rec_on_cons foldr_rec_on_cons\n\n",
 "foldr_nil":
 "@[simp]\ntheorem foldr_nil (f : α → β → β) (b : β) : foldr f b [] = b :=\n  rfl\n#align foldr_nil foldr_nil\n\n",
 "foldr_map'":
 "theorem foldr_map' {α β : Type u} (g : α → β) (f : α → α → α) (f' : β → β → β) (a : α) (l : list α)\n    (h : ∀ x y, f' (g x) (g y) = g (f x y)) : list.foldr f' (g a) (l.map g) = g (list.foldr f a l) :=\n  by\n  induction l generalizing a\n  · simp; · simp [l_ih, h]\n#align foldr_map' foldr_map'\n\n",
 "foldr_map":
 "@[simp]\ntheorem foldr_map (g : β → γ) (f : γ → α → α) (a : α) (l : list β) : foldr f a (map g l) = foldr (f ∘ g) a l := by\n  revert a <;> induction l <;> intros <;> [rfl, simp only [*, map, foldr]]\n#align foldr_map foldr_map\n\n",
 "foldr_join":
 "@[simp]\ntheorem foldr_join (f : α → β → β) :\n    ∀ (b : β) (L : list (list α)), foldr f b (join L) = foldr (fun l b => foldr f b l) b L\n  | a, [] => rfl\n  | a, l :: L => by simp only [join, foldr_append, foldr_join a L, foldr_cons]\n#align foldr_join foldr_join\n\n",
 "foldr_hom₂":
 "theorem foldr_hom₂ (l : list ι) (f : α → β → γ) (op₁ : ι → α → α) (op₂ : ι → β → β) (op₃ : ι → γ → γ) (a : α) (b : β)\n    (h : ∀ a b i, f (op₁ i a) (op₂ i b) = op₃ i (f a b)) : foldr op₃ (f a b) l = f (foldr op₁ a l) (foldr op₂ b l) :=\n  by\n  revert a\n  induction l <;> intros <;> [rfl, simp only [*, foldr]]\n#align foldr_hom₂ foldr_hom₂\n\n",
 "foldr_hom":
 "theorem foldr_hom (l : list γ) (f : α → β) (op : γ → α → α) (op' : γ → β → β) (a : α)\n    (h : ∀ x a, f (op x a) = op' x (f a)) : foldr op' (f a) l = f (foldr op a l) :=\n  by\n  revert a\n  induction l <;> intros <;> [rfl, simp only [*, foldr]]\n#align foldr_hom foldr_hom\n\n",
 "foldr_fixed'":
 "theorem foldr_fixed' {f : α → β → β} {b : β} (hf : ∀ a, f a b = b) : ∀ l : list α, foldr f b l = b\n  | [] => rfl\n  | a :: l => by rw [foldr_cons, foldr_fixed' l, hf a]\n#align foldr_fixed' foldr_fixed'\n\n",
 "foldr_fixed":
 "@[simp]\ntheorem foldr_fixed {b : β} : ∀ l : list α, foldr (fun a b => b) b l = b :=\n  foldr_fixed' fun _ => rfl\n#align foldr_fixed foldr_fixed\n\n",
 "foldr_ext":
 "theorem foldr_ext (f g : α → β → β) (b : β) {l : list α} (H : ∀ a ∈ l, ∀ b : β, f a b = g a b) :\n    foldr f b l = foldr g b l := by\n  induction' l with hd tl ih; · rfl\n  simp only [mem_cons_iff, or_imp, forall_and, forall_eq] at H\n  simp only [foldr, ih H.2, H.1]\n#align foldr_ext foldr_ext\n\n",
 "foldr_eta":
 "@[simp]\ntheorem foldr_eta : ∀ l : list α, foldr cons [] l = l\n  | [] => rfl\n  | x :: l => by simp only [foldr_cons, foldr_eta l] <;> constructor <;> rfl\n#align foldr_eta foldr_eta\n\n",
 "foldr_eq_of_comm'":
 "theorem foldr_eq_of_comm' : ∀ a b l, foldr f a (b :: l) = foldr f (f b a) l\n  | a, b, [] => rfl\n  | a, b, c :: l => by rw [foldr, foldr, foldr, hf, ← foldr_eq_of_comm'] <;> rfl\n#align foldr_eq_of_comm' foldr_eq_of_comm'\n\n",
 "foldr_cons":
 "@[simp]\ntheorem foldr_cons (f : α → β → β) (b : β) (a : α) (l : list α) : foldr f b (a :: l) = f a (foldr f b l) :=\n  rfl\n#align foldr_cons foldr_cons\n\n",
 "foldr_append":
 "@[simp]\ntheorem foldr_append (f : α → β → β) : ∀ (b : β) (l₁ l₂ : list α), foldr f b (l₁ ++ l₂) = foldr f (foldr f b l₂) l₁\n  | b, [], l₂ => rfl\n  | b, a :: l₁, l₂ => by simp only [cons_append, foldr_cons, foldr_append b l₁ l₂]\n#align foldr_append foldr_append\n\n",
 "foldl_reverse":
 "theorem foldl_reverse (f : α → β → α) (a : α) (l : list β) : foldl f a (reverse l) = foldr (fun x y => f y x) a l := by\n  induction l <;> [rfl, simp only [*, reverse_cons, foldl_append, foldl_cons, foldl_nil, foldr]]\n#align foldl_reverse foldl_reverse\n\n",
 "foldl_rec_on_nil":
 "@[simp]\ntheorem foldl_rec_on_nil {C : β → Sort _} (op : β → α → β) (b) (hb : C b) (hl) : foldlRecOn [] op b hb hl = hb :=\n  rfl\n#align foldl_rec_on_nil foldl_rec_on_nil\n\n",
 "foldl_op_eq_op_foldr_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `op -/\ntheorem foldl_op_eq_op_foldr_assoc : ∀ {l : list α} {a₁ a₂}, op (foldl l a₁) a₂ = op a₁ (l.foldr (op · ·) a₂)\n  | [], a₁, a₂ => rfl\n  | a :: l, a₁, a₂ => by simp only [foldl_cons, foldr_cons, foldl_assoc, ha.assoc] <;> rw [foldl_op_eq_op_foldr_assoc]\n#align foldl_op_eq_op_foldr_assoc foldl_op_eq_op_foldr_assoc\n\n",
 "foldl_nil":
 "@[simp]\ntheorem foldl_nil (f : α → β → α) (a : α) : foldl f a [] = a :=\n  rfl\n#align foldl_nil foldl_nil\n\n",
 "foldl_map'":
 "theorem foldl_map' {α β : Type u} (g : α → β) (f : α → α → α) (f' : β → β → β) (a : α) (l : list α)\n    (h : ∀ x y, f' (g x) (g y) = g (f x y)) : list.foldl f' (g a) (l.map g) = g (list.foldl f a l) :=\n  by\n  induction l generalizing a\n  · simp; · simp [l_ih, h]\n#align foldl_map' foldl_map'\n\n",
 "foldl_map":
 "@[simp]\ntheorem foldl_map (g : β → γ) (f : α → γ → α) (a : α) (l : list β) :\n    foldl f a (map g l) = foldl (fun x y => f x (g y)) a l := by\n  revert a <;> induction l <;> intros <;> [rfl, simp only [*, map, foldl]]\n#align foldl_map foldl_map\n\n",
 "foldl_join":
 "@[simp]\ntheorem foldl_join (f : α → β → α) : ∀ (a : α) (L : list (list β)), foldl f a (join L) = foldl (foldl f) a L\n  | a, [] => rfl\n  | a, l :: L => by simp only [join, foldl_append, foldl_cons, foldl_join (foldl f a l) L]\n#align foldl_join foldl_join\n\n",
 "foldl_hom₂":
 "theorem foldl_hom₂ (l : list ι) (f : α → β → γ) (op₁ : α → ι → α) (op₂ : β → ι → β) (op₃ : γ → ι → γ) (a : α) (b : β)\n    (h : ∀ a b i, f (op₁ a i) (op₂ b i) = op₃ (f a b) i) : foldl op₃ (f a b) l = f (foldl op₁ a l) (foldl op₂ b l) :=\n  eq.symm <| by\n    revert a b\n    induction l <;> intros <;> [rfl, simp only [*, foldl]]\n#align foldl_hom₂ foldl_hom₂\n\n",
 "foldl_hom":
 "theorem foldl_hom (l : list γ) (f : α → β) (op : α → γ → α) (op' : β → γ → β) (a : α)\n    (h : ∀ a x, f (op a x) = op' (f a) x) : foldl op' (f a) l = f (foldl op a l) :=\n  eq.symm <| by\n    revert a\n    induction l <;> intros <;> [rfl, simp only [*, foldl]]\n#align foldl_hom foldl_hom\n\n",
 "foldl_fixed'":
 "theorem foldl_fixed' {f : α → β → α} {a : α} (hf : ∀ b, f a b = a) : ∀ l : list β, foldl f a l = a\n  | [] => rfl\n  | b :: l => by rw [foldl_cons, hf b, foldl_fixed' l]\n#align foldl_fixed' foldl_fixed'\n\n",
 "foldl_fixed":
 "@[simp]\ntheorem foldl_fixed {a : α} : ∀ l : list β, foldl (fun a b => a) a l = a :=\n  foldl_fixed' fun _ => rfl\n#align foldl_fixed foldl_fixed\n\n",
 "foldl_ext":
 "theorem foldl_ext (f g : α → β → α) (a : α) {l : list β} (H : ∀ a : α, ∀ b ∈ l, f a b = g a b) :\n    foldl f a l = foldl g a l := by\n  induction' l with hd tl ih generalizing a; · rfl\n  unfold foldl\n  rw [ih fun a b bin => H a b <| mem_cons_of_mem _ bin, H a hd (mem_cons_self _ _)]\n#align foldl_ext foldl_ext\n\n",
 "foldl_eq_of_comm_of_assoc":
 "theorem foldl_eq_of_comm_of_assoc : ∀ a b l, foldl f a (b :: l) = f b (foldl f a l)\n  | a, b, nil => hcomm a b\n  | a, b, c :: l => by simp only [foldl_cons] <;> rw [← foldl_eq_of_comm_of_assoc, right_comm _ hcomm hassoc] <;> rfl\n#align foldl_eq_of_comm_of_assoc foldl_eq_of_comm_of_assoc\n\n",
 "foldl_eq_of_comm'":
 "theorem foldl_eq_of_comm' : ∀ a b l, foldl f a (b :: l) = f (foldl f a l) b\n  | a, b, [] => rfl\n  | a, b, c :: l => by rw [foldl, foldl, foldl, ← foldl_eq_of_comm', foldl, hf]\n#align foldl_eq_of_comm' foldl_eq_of_comm'\n\n",
 "foldl_eq_foldr'":
 "theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l\n  | a, [] => rfl\n  | a, b :: l => by rw [foldl_eq_of_comm' hf, foldr, foldl_eq_foldr'] <;> rfl\n#align foldl_eq_foldr' foldl_eq_foldr'\n\n",
 "foldl_eq_foldr":
 "theorem foldl_eq_foldr : ∀ a l, foldl f a l = foldr f a l\n  | a, nil => rfl\n  | a, b :: l => by simp only [foldr_cons, foldl_eq_of_comm_of_assoc hcomm hassoc] <;> rw [foldl_eq_foldr a l]\n#align foldl_eq_foldr foldl_eq_foldr\n\n",
 "foldl_cons":
 "@[simp]\ntheorem foldl_cons (f : α → β → α) (a : α) (b : β) (l : list β) : foldl f a (b :: l) = foldl f (f a b) l :=\n  rfl\n#align foldl_cons foldl_cons\n\n",
 "foldl_assoc_comm_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\ntheorem foldl_assoc_comm_cons {l : list α} {a₁ a₂} : foldl (a₁ :: l) a₂ = op a₁ (foldl l a₂) := by\n  rw [foldl_cons, hc.comm, foldl_assoc]\n#align foldl_assoc_comm_cons foldl_assoc_comm_cons\n\n",
 "foldl_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `op -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\ntheorem foldl_assoc : ∀ {l : list α} {a₁ a₂}, foldl l (op a₁ a₂) = op a₁ (foldl l a₂)\n  | [], a₁, a₂ => rfl\n  | a :: l, a₁, a₂ =>\n    calc\n      foldl (a :: l) (op a₁ a₂) = foldl l (op a₁ (op a₂ a)) := by simp only [foldl_cons, ha.assoc]\n      _ = op a₁ (foldl (a :: l) a₂) := by rw [foldl_assoc, foldl_cons]\n      \n#align foldl_assoc foldl_assoc\n\n",
 "foldl_append":
 "@[simp]\ntheorem foldl_append (f : α → β → α) : ∀ (a : α) (l₁ l₂ : list β), foldl f a (l₁ ++ l₂) = foldl f (foldl f a l₁) l₂\n  | a, [], l₂ => rfl\n  | a, b :: l₁, l₂ => by simp only [cons_append, foldl_cons, foldl_append (f a b) l₁ l₂]\n#align foldl_append foldl_append\n\n",
 "foldl1_eq_foldr1":
 "-- foldl and foldr coincide when f is commutative and associative\ntheorem foldl1_eq_foldr1 : ∀ a b l, foldl f a (l ++ [b]) = foldr f b (a :: l)\n  | a, b, nil => rfl\n  | a, b, c :: l => by simp only [cons_append, foldl_cons, foldr_cons, foldl1_eq_foldr1 _ _ l] <;> rw [hassoc]\n#align foldl1_eq_foldr1 foldl1_eq_foldr1\n\n",
 "find_some":
 "theorem find_some (H : find? p l = some a) : p a :=\n  by\n  induction' l with b l IH; · contradiction\n  by_cases h : p b\n  · rw [find_cons_of_pos _ h] at H\n    cases H\n    exact h\n  · rw [find_cons_of_neg _ h] at H\n    exact IH H\n#align find_some find_some\n\n",
 "find_nil":
 "@[simp]\ntheorem find_nil (p : α → Prop) [decidable_pred p] : find? p [] = none :=\n  rfl\n#align find_nil find_nil\n\n",
 "find_mem":
 "@[simp]\ntheorem find_mem (H : find? p l = some a) : a ∈ l :=\n  by\n  induction' l with b l IH; · contradiction\n  by_cases h : p b\n  · rw [find_cons_of_pos _ h] at H\n    cases H\n    apply mem_cons_self\n  · rw [find_cons_of_neg _ h] at H\n    exact mem_cons_of_mem _ (IH H)\n#align find_mem find_mem\n\n",
 "find_eq_none":
 "@[simp]\ntheorem find_eq_none : find? p l = none ↔ ∀ x ∈ l, ¬p x :=\n  by\n  induction' l with a l IH\n  · exact iff_of_true rfl (forall_mem_nil _)\n  rw [forall_mem_cons]; by_cases h : p a\n  · simp only [find_cons_of_pos _ h, h, not_true, false_and_iff]\n  · rwa [find_cons_of_neg _ h, iff_true_intro h, true_and_iff]\n#align find_eq_none find_eq_none\n\n",
 "find_cons_of_pos":
 "@[simp]\ntheorem find_cons_of_pos (l) (h : p a) : find? p (a :: l) = some a :=\n  if_pos h\n#align find_cons_of_pos find_cons_of_pos\n\n",
 "find_cons_of_neg":
 "@[simp]\ntheorem find_cons_of_neg (l) (h : ¬p a) : find? p (a :: l) = find? p l :=\n  if_neg h\n#align find_cons_of_neg find_cons_of_neg\n\n",
 "filter_true":
 "@[simp]\ntheorem filter_true {h : decidable_pred fun a : α => true} (l : list α) : @filter α (fun _ => true) h l = l := by\n  convert filter_eq_self.2 fun _ _ => trivial\n#align filter_true filter_true\n\n",
 "filter_subset":
 "@[simp]\ntheorem filter_subset (l : list α) : filter p l ⊆ l :=\n  (filter_sublist l).subset\n#align filter_subset filter_subset\n\n",
 "filter_singleton":
 "theorem filter_singleton {a : α} : [a].filter p = if p a then [a] else [] :=\n  rfl\n#align filter_singleton filter_singleton\n\n",
 "filter_map_some":
 "@[simp]\ntheorem filter_map_some (l : list α) : filter_map some l = l := by rw [filter_map_eq_map] <;> apply map_id\n#align filter_map_some filter_map_some\n\n",
 "filter_map_nil":
 "@[simp]\ntheorem filter_map_nil (f : α → option β) : filter_map f [] = [] :=\n  rfl\n#align filter_map_nil filter_map_nil\n\n",
 "filter_map_map":
 "theorem filter_map_map (f : α → β) (g : β → option γ) (l : list α) : filter_map g (map f l) = filter_map (g ∘ f) l := by\n  rw [← filter_map_eq_map, filter_map_filter_map] <;> rfl\n#align filter_map_map filter_map_map\n\n",
 "filter_map_join":
 "@[simp]\ntheorem filter_map_join (f : α → option β) (L : list (list α)) : filter_map f (join L) = join (map (filter_map f) L) :=\n  by\n  induction' L with hd tl ih\n  · rfl\n  · rw [map, join, join, filter_map_append, ih]\n#align filter_map_join filter_map_join\n\n",
 "filter_map_filter_map":
 "theorem filter_map_filter_map (f : α → option β) (g : β → option γ) (l : list α) :\n    filter_map g (filter_map f l) = filter_map (fun x => (f x).bind g) l :=\n  by\n  induction' l with a l IH; · rfl\n  cases' h : f a with b\n  · rw [filter_map_cons_none _ _ h, filter_map_cons_none, IH]\n    simp only [h, option.none_bind']\n  rw [filter_map_cons_some _ _ _ h]\n  cases' h' : g b with c <;> [rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH],\n      rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH]] <;>\n    simp only [h, h', option.some_bind']\n#align filter_map_filter_map filter_map_filter_map\n\n",
 "filter_map_filter":
 "theorem filter_map_filter (p : α → Prop) [decidable_pred p] (f : α → option β) (l : list α) :\n    filter_map f (filter p l) = filter_map (fun x => if p x then f x else none) l :=\n  by\n  rw [← filter_map_eq_filter, filter_map_filter_map]; congr\n  funext x\n  show (option.guard p x).bind f = ite (p x) (f x) none\n  by_cases h : p x\n  · simp only [option.guard, if_pos h, option.some_bind']\n  · simp only [option.guard, if_neg h, option.none_bind']\n#align filter_map_filter filter_map_filter\n\n",
 "filter_map_eq_map":
 "theorem filter_map_eq_map (f : α → β) : filter_map (some ∘ f) = map f :=\n  by\n  funext l\n  induction' l with a l IH; · rfl\n  simp only [filter_map_cons_some (some ∘ f) _ _ rfl, IH, map_cons]; constructor <;> rfl\n#align filter_map_eq_map filter_map_eq_map\n\n",
 "filter_map_eq_filter":
 "theorem filter_map_eq_filter (p : α → Prop) [decidable_pred p] : filter_map (option.guard p) = filter p :=\n  by\n  funext l\n  induction' l with a l IH; · rfl\n  by_cases pa : p a\n  · simp only [filter_map, option.guard, IH, if_pos pa, filter_cons_of_pos _ pa]\n    constructor <;> rfl\n  · simp only [filter_map, option.guard, IH, if_neg pa, filter_cons_of_neg _ pa]\n#align filter_map_eq_filter filter_map_eq_filter\n\n",
 "filter_map_cons_some":
 "@[simp]\ntheorem filter_map_cons_some (f : α → option β) (a : α) (l : list α) {b : β} (h : f a = some b) :\n    filter_map f (a :: l) = b :: filter_map f l := by simp only [filter_map, h] <;> constructor <;> rfl\n#align filter_map_cons_some filter_map_cons_some\n\n",
 "filter_map_cons_none":
 "@[simp]\ntheorem filter_map_cons_none {f : α → option β} (a : α) (l : list α) (h : f a = none) :\n    filter_map f (a :: l) = filter_map f l := by simp only [filter_map, h]\n#align filter_map_cons_none filter_map_cons_none\n\n",
 "filter_map_cons":
 "theorem filter_map_cons (f : α → option β) (a : α) (l : list α) :\n    filter_map f (a :: l) = option.cases_on (f a) (filter_map f l) fun b => b :: filter_map f l :=\n  by\n  generalize eq : f a = b\n  cases b\n  · rw [filter_map_cons_none _ _ eq]\n  · rw [filter_map_cons_some _ _ _ eq]\n#align filter_map_cons filter_map_cons\n\n",
 "filter_map_append":
 "theorem filter_map_append {α β : Type _} (l l' : list α) (f : α → option β) :\n    filter_map f (l ++ l') = filter_map f l ++ filter_map f l' :=\n  by\n  induction' l with hd tl hl generalizing l'\n  · simp\n  · rw [cons_append, filter_map, filter_map]\n    cases f hd <;> simp only [filter_map, hl, cons_append, eq_self_iff_true, and_self_iff]\n#align filter_map_append filter_map_append\n\n",
 "filter_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.filter_map (f : α → option β) {l₁ l₂ : list α} (s : «expr <+ » l₁ l₂) :\n    «expr <+ » (filter_map f l₁) (filter_map f l₂) := by\n  induction' s with l₁ l₂ a s IH l₁ l₂ a s IH <;> simp only [filter_map] <;> cases' f a with b <;>\n    simp only [filter_map, IH, sublist.cons, sublist.cons2]\n#align sublist.filter_map sublist.filter_map\n\n",
 "filter_length_eq_length":
 "theorem filter_length_eq_length {l} : (filter p l).length = l.length ↔ ∀ a ∈ l, p a :=\n  iff.trans ⟨l.filter_sublist.eq_of_length, congr_arg list.length⟩ filter_eq_self\n#align filter_length_eq_length filter_length_eq_length\n\n",
 "filter_filter_map":
 "theorem filter_filter_map (f : α → option β) (p : β → Prop) [decidable_pred p] (l : list α) :\n    filter p (filter_map f l) = filter_map (fun x => (f x).filter p) l := by\n  rw [← filter_map_eq_filter, filter_map_filter_map] <;> rfl\n#align filter_filter_map filter_filter_map\n\n",
 "filter_filter":
 "@[simp]\ntheorem filter_filter (q) [decidable_pred q] : ∀ l, filter p (filter q l) = filter (fun a => p a ∧ q a) l\n  | [] => rfl\n  | a :: l => by\n    by_cases hp : p a <;> by_cases hq : q a <;>\n      simp only [hp, hq, filter, if_true, if_false, true_and_iff, false_and_iff, filter_filter l, eq_self_iff_true]\n#align filter_filter filter_filter\n\n",
 "filter_false":
 "@[simp]\ntheorem filter_false {h : decidable_pred fun a : α => false} (l : list α) : @filter α (fun _ => false) h l = [] := by\n  convert filter_eq_nil.2 fun _ _ => id\n#align filter_false filter_false\n\n",
 "filter_eq_self":
 "theorem filter_eq_self {l} : filter p l = l ↔ ∀ a ∈ l, p a :=\n  by\n  induction' l with a l ih\n  · exact iff_of_true rfl (forall_mem_nil _)\n  rw [forall_mem_cons]; by_cases p a\n  · rw [filter_cons_of_pos _ h, cons_inj, ih, and_iff_right h]\n  · refine' iff_of_false (fun hl => h <| of_mem_filter (_ : a ∈ filter p (a :: l))) (mt And.left h)\n    rw [hl]\n    exact mem_cons_self _ _\n#align filter_eq_self filter_eq_self\n\n",
 "filter_eq_nil":
 "theorem filter_eq_nil {l} : filter p l = [] ↔ ∀ a ∈ l, ¬p a := by\n  simp only [eq_nil_iff_forall_not_mem, mem_filter, not_and]\n#align filter_eq_nil filter_eq_nil\n\n",
 "filter_eq_foldr":
 "theorem filter_eq_foldr (p : α → Prop) [decidable_pred p] (l : list α) :\n    filter p l = foldr (fun a out => if p a then a :: out else out) [] l := by induction l <;> simp [*, filter]\n#align filter_eq_foldr filter_eq_foldr\n\n",
 "filter_congr'":
 "theorem filter_congr' {p q : α → Prop} [decidable_pred p] [decidable_pred q] :\n    ∀ {l : list α}, (∀ x ∈ l, p x ↔ q x) → filter p l = filter q l\n  | [], _ => rfl\n  | a :: l, h => by\n    rw [forall_mem_cons] at h <;> by_cases pa : p a <;>\n          [simp only [filter_cons_of_pos _ pa, filter_cons_of_pos _ (h.1.1 pa), filter_congr' h.2],\n          simp only [filter_cons_of_neg _ pa, filter_cons_of_neg _ (mt h.1.2 pa), filter_congr' h.2]] <;>\n        constructor <;>\n      rfl\n#align filter_congr' filter_congr'\n\n",
 "filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.filter {l₁ l₂} (s : «expr <+ » l₁ l₂) : «expr <+ » (filter p l₁) (filter p l₂) :=\n  filterMap_eq_filter p ▸ s.filter_map _\n#align sublist.filter sublist.filter\n\n",
 "extractp_eq_find_erasep":
 "@[simp]\ntheorem extractp_eq_find_erasep : ∀ l : list α, extractp p l = (find? p l, eraseP p l)\n  | [] => rfl\n  | a :: l => by by_cases pa : p a <;> simp [extractp, pa, extractp_eq_find_erasep l]\n#align extractp_eq_find_erasep extractp_eq_find_erasep\n\n",
 "ext_le":
 "theorem ext_le {l₁ l₂ : list α} (hl : length l₁ = length l₂) (h : ∀ n h₁ h₂, nthLe l₁ n h₁ = nthLe l₂ n h₂) : l₁ = l₂ :=\n  ext fun n =>\n    if h₁ : n < length l₁ then by rw [nth_le_nth, nth_le_nth, h n h₁ (by rwa [← hl])]\n    else by\n      let h₁ := le_of_not_gt h₁\n      rw [nth_len_le h₁, nth_len_le]\n      rwa [← hl]\n#align ext_le ext_le\n\n",
 "ext":
 "@[ext]\ntheorem ext : ∀ {l₁ l₂ : list α}, (∀ n, get? l₁ n = get? l₂ n) → l₁ = l₂\n  | [], [], h => rfl\n  | a :: l₁, [], h => by have h0 := h 0 <;> contradiction\n  | [], a' :: l₂, h => by have h0 := h 0 <;> contradiction\n  | a :: l₁, a' :: l₂, h => by\n    have h0 : some a = some a' := h 0 <;> injection h0 with aa <;> simp only [aa, ext fun n => h (n + 1)] <;>\n        constructor <;>\n      rfl\n#align ext ext\n\n",
 "exists_or_eq_self_of_erasep":
 "theorem exists_or_eq_self_of_erasep (p : α → Prop) [decidable_pred p] (l : list α) :\n    l.erasep p = l ∨ ∃ a l₁ l₂, (∀ b ∈ l₁, ¬p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ l.erasep p = l₁ ++ l₂ :=\n  by\n  by_cases h : ∃ a ∈ l, p a\n  · rcases h with ⟨a, ha, pa⟩\n    exact or.inr (exists_of_erasep ha pa)\n  · simp at h\n    exact or.inl (erasep_of_forall_not h)\n#align exists_or_eq_self_of_erasep exists_or_eq_self_of_erasep\n\n",
 "exists_of_mem_join":
 "theorem exists_of_mem_join {a : α} {L : list (list α)} : a ∈ join L → ∃ l, l ∈ L ∧ a ∈ l :=\n  mem_join.1\n#align exists_of_mem_join exists_of_mem_join\n\n",
 "exists_of_mem_bind":
 "theorem exists_of_mem_bind {b : β} {l : list α} {f : α → list β} : b ∈ list.bind l f → ∃ a ∈ l, b ∈ f a :=\n  mem_bind.1\n#align exists_of_mem_bind exists_of_mem_bind\n\n",
 "exists_of_length_succ":
 "theorem exists_of_length_succ {n} : ∀ l : list α, l.length = n + 1 → ∃ h t, l = h :: t\n  | [], H => absurd H.symm <| succ_ne_zero n\n  | h :: t, H => ⟨h, t, rfl⟩\n#align exists_of_length_succ exists_of_length_succ\n\n",
 "exists_of_erasep":
 "theorem exists_of_erasep {l : list α} {a} (al : a ∈ l) (pa : p a) :\n    ∃ a l₁ l₂, (∀ b ∈ l₁, ¬p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ l.erasep p = l₁ ++ l₂ :=\n  by\n  induction' l with b l IH; · cases al\n  by_cases pb : p b\n  · exact ⟨b, [], l, forall_mem_nil _, pb, by simp [pb]⟩\n  · rcases al with (rfl | al)\n    · exact pb.elim pa\n    rcases IH al with ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩\n    exact ⟨c, b :: l₁, l₂, forall_mem_cons.2 ⟨pb, h₁⟩, h₂, by rw [h₃] <;> rfl, by simp [pb, h₄]⟩\n#align exists_of_erasep exists_of_erasep\n\n",
 "exists_mem_of_ne_nil":
 "theorem exists_mem_of_ne_nil (l : list α) (h : l ≠ []) : ∃ x, x ∈ l :=\n  exists_mem_of_length_pos (length_pos_of_ne_nil h)\n#align exists_mem_of_ne_nil exists_mem_of_ne_nil\n\n",
 "exists_mem_of_length_pos":
 "theorem exists_mem_of_length_pos : ∀ {l : list α}, 0 < length l → ∃ a, a ∈ l\n  | b :: l, _ => ⟨b, mem_cons_self _ _⟩\n#align exists_mem_of_length_pos exists_mem_of_length_pos\n\n",
 "exists_mem_cons_of_exists":
 "theorem exists_mem_cons_of_exists {p : α → Prop} {a : α} {l : list α} (h : ∃ x ∈ l, p x) : ∃ x ∈ a :: l, p x :=\n  BEx.elim h fun x xl px => BEx.intro x (mem_cons_of_mem _ xl) px\n#align exists_mem_cons_of_exists exists_mem_cons_of_exists\n\n",
 "exists_mem_cons_of":
 "theorem exists_mem_cons_of {p : α → Prop} {a : α} (l : list α) (h : p a) : ∃ x ∈ a :: l, p x :=\n  BEx.intro a (mem_cons_self _ _) h\n#align exists_mem_cons_of exists_mem_cons_of\n\n",
 "exists_mem_cons_iff":
 "theorem exists_mem_cons_iff (p : α → Prop) (a : α) (l : list α) : (∃ x ∈ a :: l, p x) ↔ p a ∨ ∃ x ∈ l, p x :=\n  iff.intro or_exists_of_exists_mem_cons fun h => or.elim h (exists_mem_cons_of l) exists_mem_cons_of_exists\n#align exists_mem_cons_iff exists_mem_cons_iff\n\n",
 "exists_mem_and_apply_eq_iff":
 "#print Function.Involutive.exists_mem_and_apply_eq_iff /-\n@[simp]\ntheorem Function.Involutive.exists_mem_and_apply_eq_iff {f : α → α} (hf : function.involutive f) (x : α) (l : list α) :\n    (∃ y : α, y ∈ l ∧ f y = x) ↔ f x ∈ l :=\n  ⟨by\n    rintro ⟨y, h, rfl⟩\n    rwa [hf y], fun h => ⟨f x, h, hf _⟩⟩\n#align function.involutive.exists_mem_and_apply_eq_iff Function.Involutive.exists_mem_and_apply_eq_iff\n-/\n\n",
 "exists_erase_eq":
 "theorem exists_erase_eq {a : α} {l : list α} (h : a ∈ l) : ∃ l₁ l₂, a ∉ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂ :=\n  by\n  rcases exists_of_erasep h rfl with ⟨_, l₁, l₂, h₁, rfl, h₂, h₃⟩ <;> rw [erase_eq_erasep] <;>\n    exact ⟨l₁, l₂, fun h => h₁ _ h rfl, h₂, h₃⟩\n#align exists_erase_eq exists_erase_eq\n\n",
 "exists_cons_of_ne_nil":
 "theorem exists_cons_of_ne_nil {l : list α} (h : l ≠ nil) : ∃ b L, l = b :: L :=\n  by\n  induction' l with c l'\n  contradiction\n  use c, l'\n#align exists_cons_of_ne_nil exists_cons_of_ne_nil\n\n",
 "erasep_subset":
 "theorem erasep_subset (l : list α) : l.erasep p ⊆ l :=\n  (eraseP_sublist l).subset\n#align erasep_subset erasep_subset\n\n",
 "erasep_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem erasep_sublist (l : list α) : «expr <+ » (l.erasep p) l := by\n  rcases exists_or_eq_self_of_erasep p l with (h | ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩) <;> [rw [h],\n    · rw [h₄, h₃]\n      simp]\n#align erasep_sublist erasep_sublist\n\n",
 "erasep_of_forall_not":
 "theorem erasep_of_forall_not {l : list α} (h : ∀ a ∈ l, ¬p a) : l.erasep p = l := by\n  induction' l with _ _ ih <;> [rfl, simp [h _ (or.inl rfl), ih (forall_mem_of_forall_mem_cons h)]]\n#align erasep_of_forall_not erasep_of_forall_not\n\n",
 "erasep_nil":
 "@[simp]\ntheorem erasep_nil : [].erasep p = [] :=\n  rfl\n#align erasep_nil erasep_nil\n\n",
 "erasep_map":
 "theorem erasep_map (f : β → α) : ∀ l : list β, (map f l).erasep p = map f (l.erasep (p ∘ f))\n  | [] => rfl\n  | b :: l => by by_cases p (f b) <;> simp [h, erasep_map l]\n#align erasep_map erasep_map\n\n",
 "erasep_cons_of_pos":
 "@[simp]\ntheorem erasep_cons_of_pos {a : α} {l : list α} (h : p a) : (a :: l).erasep p = l := by simp [erasep_cons, h]\n#align erasep_cons_of_pos erasep_cons_of_pos\n\n",
 "erasep_cons_of_neg":
 "@[simp]\ntheorem erasep_cons_of_neg {a : α} {l : list α} (h : ¬p a) : (a :: l).erasep p = a :: l.erasep p := by\n  simp [erasep_cons, h]\n#align erasep_cons_of_neg erasep_cons_of_neg\n\n",
 "erasep_cons":
 "theorem erasep_cons (a : α) (l : list α) : (a :: l).erasep p = if p a then l else a :: l.erasep p :=\n  rfl\n#align erasep_cons erasep_cons\n\n",
 "erasep_append_right":
 "theorem erasep_append_right : ∀ {l₁ : list α} (l₂), (∀ b ∈ l₁, ¬p b) → (l₁ ++ l₂).erasep p = l₁ ++ l₂.erasep p\n  | [], l₂, h => rfl\n  | x :: xs, l₂, h => by simp [(forall_mem_cons.1 h).1, erasep_append_right _ (forall_mem_cons.1 h).2]\n#align erasep_append_right erasep_append_right\n\n",
 "erasep_append_left":
 "theorem erasep_append_left {a : α} (pa : p a) : ∀ {l₁ : list α} (l₂), a ∈ l₁ → (l₁ ++ l₂).erasep p = l₁.erasep p ++ l₂\n  | x :: xs, l₂, h => by\n    by_cases h' : p x <;> simp [h']\n    rw [erasep_append_left l₂ (mem_of_ne_of_mem (mt _ h') h)]\n    rintro rfl; exact pa\n#align erasep_append_left erasep_append_left\n\n",
 "erasep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.erasep {l₁ l₂ : list α} (s : «expr <+ » l₁ l₂) : «expr <+ » (l₁.erasep p) (l₂.erasep p) :=\n  by\n  induction s\n  case slnil => rfl\n  case cons l₁ l₂ a s IH =>\n    by_cases h : p a <;> simp [h]\n    exacts[IH.trans (erasep_sublist _), IH.cons _ _ _]\n  case cons2 l₁ l₂ a s IH =>\n    by_cases h : p a <;> simp [h]\n    exacts[s, IH.cons2 _ _ _]\n#align sublist.erasep sublist.erasep\n\n",
 "erase_subset":
 "theorem erase_subset (a : α) (l : list α) : l.erase a ⊆ l :=\n  (erase_sublist a l).subset\n#align erase_subset erase_subset\n\n",
 "erase_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem erase_sublist (a : α) (l : list α) : «expr <+ » (l.erase a) l := by\n  rw [erase_eq_erasep] <;> apply erasep_sublist\n#align erase_sublist erase_sublist\n\n",
 "erase_of_not_mem":
 "@[simp]\ntheorem erase_of_not_mem {a : α} {l : list α} (h : a ∉ l) : l.erase a = l := by\n  rw [erase_eq_erasep, erasep_of_forall_not] <;> rintro b h' rfl <;> exact h h'\n#align erase_of_not_mem erase_of_not_mem\n\n",
 "erase_nil":
 "@[simp]\ntheorem erase_nil (a : α) : [].erase a = [] :=\n  rfl\n#align erase_nil erase_nil\n\n",
 "erase_eq_erasep":
 "theorem erase_eq_erasep (a : α) (l : list α) : l.erase a = l.erasep (eq a) :=\n  by\n  induction' l with b l\n  · rfl\n  by_cases a = b <;> [simp [h], simp [h, ne.symm h, *]]\n#align erase_eq_erasep erase_eq_erasep\n\n",
 "erase_diff_erase_sublist_of_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem erase_diff_erase_sublist_of_sublist {a : α} :\n    ∀ {l₁ l₂ : list α}, «expr <+ » l₁ l₂ → «expr <+ » ((l₂.erase a).diff (l₁.erase a)) (l₂.diff l₁)\n  | [], l₂, h => erase_sublist _ _\n  | b :: l₁, l₂, h =>\n    if heq : b = a then by simp only [HEq, erase_cons_head, diff_cons]\n    else by\n      simpa only [erase_cons_head, erase_cons_tail _ HEq, diff_cons, erase_comm a b l₂] using\n        erase_diff_erase_sublist_of_sublist (h.erase b)\n#align erase_diff_erase_sublist_of_sublist erase_diff_erase_sublist_of_sublist\n\n",
 "erase_cons_tail":
 "@[simp]\ntheorem erase_cons_tail {a b : α} (l : list α) (h : b ≠ a) : (b :: l).erase a = b :: l.erase a := by\n  simp only [erase_cons, if_neg h] <;> constructor <;> rfl\n#align erase_cons_tail erase_cons_tail\n\n",
 "erase_cons_head":
 "@[simp]\ntheorem erase_cons_head (a : α) (l : list α) : (a :: l).erase a = l := by simp only [erase_cons, if_pos rfl]\n#align erase_cons_head erase_cons_head\n\n",
 "erase_cons":
 "theorem erase_cons (a b : α) (l : list α) : (b :: l).erase a = if b = a then l else b :: l.erase a :=\n  rfl\n#align erase_cons erase_cons\n\n",
 "erase_comm":
 "theorem erase_comm (a b : α) (l : list α) : (l.erase a).erase b = (l.erase b).erase a :=\n  if ab : a = b then by rw [ab]\n  else\n    if ha : a ∈ l then\n      if hb : b ∈ l then\n        match l, l.erase a, exists_erase_eq ha, hb with\n        | _, _, ⟨l₁, l₂, ha', rfl, rfl⟩, hb =>\n          if h₁ : b ∈ l₁ then by\n            rw [erase_append_left _ h₁, erase_append_left _ h₁, erase_append_right _ (mt mem_of_mem_erase ha'),\n              erase_cons_head]\n          else by\n            rw [erase_append_right _ h₁, erase_append_right _ h₁, erase_append_right _ ha', erase_cons_tail _ ab,\n              erase_cons_head]\n      else by simp only [erase_of_not_mem hb, erase_of_not_mem (mt mem_of_mem_erase hb)]\n    else by simp only [erase_of_not_mem ha, erase_of_not_mem (mt mem_of_mem_erase ha)]\n#align erase_comm erase_comm\n\n",
 "erase_append_right":
 "theorem erase_append_right {a : α} {l₁ : list α} (l₂) (h : a ∉ l₁) : (l₁ ++ l₂).erase a = l₁ ++ l₂.erase a := by\n  rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right] <;> rintro b h' rfl <;> exact h h'\n#align erase_append_right erase_append_right\n\n",
 "erase_append_left":
 "theorem erase_append_left {a : α} {l₁ : list α} (l₂) (h : a ∈ l₁) : (l₁ ++ l₂).erase a = l₁.erase a ++ l₂ := by\n  simp [erase_eq_erasep] <;> exact erasep_append_left (by rfl) l₂ h\n#align erase_append_left erase_append_left\n\n",
 "erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.erase (a : α) {l₁ l₂ : list α} (h : «expr <+ » l₁ l₂) : «expr <+ » (l₁.erase a) (l₂.erase a) := by\n  simp [erase_eq_erasep] <;> exact sublist.erasep h\n#align sublist.erase sublist.erase\n\n",
 "eq_replicate_length":
 "theorem eq_replicate_length {a : α} : ∀ {l : list α}, l = replicate l.length a ↔ ∀ b ∈ l, b = a\n  | [] => by simp\n  | b :: l => by simp [eq_replicate_length]\n#align eq_replicate_length eq_replicate_length\n\n",
 "eq_replicate":
 "theorem eq_replicate {a : α} {n} {l : list α} : l = replicate n a ↔ length l = n ∧ ∀ b ∈ l, b = a :=\n  ⟨fun h => h.symm ▸ ⟨length_replicate _ _, fun b => eq_of_mem_replicate⟩, fun ⟨e, al⟩ => e ▸ eq_replicate_of_mem al⟩\n#align eq_replicate eq_replicate\n\n",
 "eq_or_ne_mem_of_mem":
 "theorem eq_or_ne_mem_of_mem {a b : α} {l : list α} : a ∈ b :: l → a = b ∨ a ≠ b ∧ a ∈ l := by\n  classical exact Decidable.List.eq_or_ne_mem_of_mem\n#align eq_or_ne_mem_of_mem eq_or_ne_mem_of_mem\n\n",
 "eq_of_mem_singleton":
 "theorem eq_of_mem_singleton {a b : α} : a ∈ [b] → a = b := fun this : a ∈ [b] =>\n  or.elim (eq_or_mem_of_mem_cons this) (fun this : a = b => this) fun this : a ∈ [] => absurd this (not_mem_nil a)\n#align eq_of_mem_singleton eq_of_mem_singleton\n\n",
 "eq_of_mem_replicate":
 "theorem eq_of_mem_replicate {a b : α} {n} (h : b ∈ replicate n a) : b = a :=\n  (mem_replicate.1 h).2\n#align eq_of_mem_replicate eq_of_mem_replicate\n\n",
 "eq_of_mem_map_const":
 "theorem eq_of_mem_map_const {b₁ b₂ : β} {l : list α} (h : b₁ ∈ map (const α b₂) l) : b₁ = b₂ := by\n  rw [map_const] at h <;> exact eq_of_mem_replicate h\n#align eq_of_mem_map_const eq_of_mem_map_const\n\n",
 "eq_of_length_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.eq_of_length_le (s : «expr <+ » l₁ l₂) (h : length l₂ ≤ length l₁) : l₁ = l₂ :=\n  s.eq_of_length <| s.length_le.antisymm h\n#align sublist.eq_of_length_le sublist.eq_of_length_le\n\n",
 "eq_of_length":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.eq_of_length : ∀ {l₁ l₂ : list α}, «expr <+ » l₁ l₂ → length l₁ = length l₂ → l₁ = l₂\n  | _, _, sublist.slnil, h => rfl\n  | _, _, sublist.cons l₁ l₂ a s, h => by cases s.length_le.not_lt (by rw [h] <;> apply lt_succ_self)\n  | _, _, sublist.cons2 l₁ l₂ a s, h => by rw [length, length] at h <;> injection h with h <;> rw [s.eq_of_length h]\n#align sublist.eq_of_length sublist.eq_of_length\n\n",
 "eq_nil_of_subset_nil":
 "theorem eq_nil_of_subset_nil : ∀ {l : list α}, l ⊆ [] → l = []\n  | [], s => rfl\n  | a :: l, s => false.elim <| s <| mem_cons_self a l\n#align eq_nil_of_subset_nil eq_nil_of_subset_nil\n\n",
 "eq_nil_of_sublist_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem eq_nil_of_sublist_nil {l : list α} (s : «expr <+ » l []) : l = [] :=\n  eq_nil_of_subset_nil <| s.subset\n#align eq_nil_of_sublist_nil eq_nil_of_sublist_nil\n\n",
 "eq_nil_of_map_eq_nil":
 "theorem eq_nil_of_map_eq_nil {f : α → β} {l : list α} (h : map f l = nil) : l = nil :=\n  eq_nil_of_length_eq_zero <| by rw [← length_map f l, h] <;> rfl\n#align eq_nil_of_map_eq_nil eq_nil_of_map_eq_nil\n\n",
 "eq_nil_iff_forall_not_mem":
 "theorem eq_nil_iff_forall_not_mem {l : list α} : l = [] ↔ ∀ a, a ∉ l :=\n  show l = [] ↔ l ⊆ [] from ⟨fun e => e ▸ subset.refl _, eq_nil_of_subset_nil⟩\n#align eq_nil_iff_forall_not_mem eq_nil_iff_forall_not_mem\n\n",
 "eq_cons_of_mem_head'":
 "theorem eq_cons_of_mem_head' {x : α} : ∀ {l : list α}, x ∈ l.head' → l = x :: tail l\n  | [], h => (option.not_mem_none _ h).elim\n  | a :: l, h => by\n    simp only [head', option.mem_def] at h\n    exact h ▸ rfl\n#align eq_cons_of_mem_head' eq_cons_of_mem_head'\n\n",
 "eq_cons_of_length_one":
 "theorem eq_cons_of_length_one {l : list α} (h : l.length = 1) : l = [l.nth_le 0 (h.symm ▸ zero_lt_one)] :=\n  by\n  refine' ext_le (by convert h) fun n h₁ h₂ => _\n  simp only [nth_le_singleton]\n  congr\n  exact eq_bot_iff.mpr (nat.lt_succ_iff.mp h₂)\n#align eq_cons_of_length_one eq_cons_of_length_one\n\n",
 "enum_singleton":
 "@[simp]\ntheorem enum_singleton (x : α) : enum [x] = [(0, x)] :=\n  rfl\n#align enum_singleton enum_singleton\n\n",
 "enum_nth":
 "@[simp]\ntheorem enum_nth : ∀ (l : list α) (n), get? (enum l) n = (fun a => (n, a)) <$> get? l n := by\n  simp only [enum, enum_from_nth, zero_add] <;> intros <;> rfl\n#align enum_nth enum_nth\n\n",
 "enum_nil":
 "@[simp]\ntheorem enum_nil : enum ([] : list α) = [] :=\n  rfl\n#align enum_nil enum_nil\n\n",
 "enum_map_snd":
 "@[simp]\ntheorem enum_map_snd : ∀ l : list α, map prod.snd (enum l) = l :=\n  enumFrom_map_snd _\n#align enum_map_snd enum_map_snd\n\n",
 "enum_from_singleton":
 "@[simp]\ntheorem enum_from_singleton (x : α) (n : ℕ) : enum_from n [x] = [(n, x)] :=\n  rfl\n#align enum_from_singleton enum_from_singleton\n\n",
 "enum_from_nth":
 "@[simp]\ntheorem enum_from_nth : ∀ (n) (l : list α) (m), get? (enum_from n l) m = (fun a => (n + m, a)) <$> get? l m\n  | n, [], m => rfl\n  | n, a :: l, 0 => rfl\n  | n, a :: l, m + 1 => (enum_from_nth (n + 1) l m).trans <| by rw [add_right_comm] <;> rfl\n#align enum_from_nth enum_from_nth\n\n",
 "enum_from_nil":
 "@[simp]\ntheorem enum_from_nil (n : ℕ) : enum_from n ([] : list α) = [] :=\n  rfl\n#align enum_from_nil enum_from_nil\n\n",
 "enum_from_map_snd":
 "@[simp]\ntheorem enum_from_map_snd : ∀ (n) (l : list α), map prod.snd (enum_from n l) = l\n  | n, [] => rfl\n  | n, a :: l => congr_arg (cons _) (enum_from_map_snd _ _)\n#align enum_from_map_snd enum_from_map_snd\n\n",
 "enum_from_cons":
 "@[simp]\ntheorem enum_from_cons (x : α) (xs : list α) (n : ℕ) : enum_from n (x :: xs) = (n, x) :: enum_from (n + 1) xs :=\n  rfl\n#align enum_from_cons enum_from_cons\n\n",
 "enum_from_append":
 "theorem enum_from_append (xs ys : list α) (n : ℕ) :\n    enum_from n (xs ++ ys) = enum_from n xs ++ enum_from (n + xs.length) ys :=\n  by\n  induction' xs with x xs IH generalizing ys n\n  · simp\n  · rw [cons_append, enum_from_cons, IH, ← cons_append, ← enum_from_cons, length, add_right_comm, add_assoc]\n#align enum_from_append enum_from_append\n\n",
 "enum_cons":
 "@[simp]\ntheorem enum_cons (x : α) (xs : list α) : enum (x :: xs) = (0, x) :: enum_from 1 xs :=\n  rfl\n#align enum_cons enum_cons\n\n",
 "enum_append":
 "theorem enum_append (xs ys : list α) : enum (xs ++ ys) = enum xs ++ enum_from xs.length ys := by\n  simp [enum, enum_from_append]\n#align enum_append enum_append\n\n",
 "empty_iff_eq_nil":
 "theorem empty_iff_eq_nil {l : list α} : l.empty ↔ l = [] :=\n  list.cases_on l (by simp) (by simp)\n#align empty_iff_eq_nil empty_iff_eq_nil\n\n",
 "empty_eq":
 "theorem empty_eq : (∅ : list α) = [] := by rfl\n#align empty_eq empty_eq\n\n",
 "drop_while_nth_le_zero_not":
 "theorem drop_while_nth_le_zero_not (l : list α) (hl : 0 < (l.drop_while p).length) :\n    ¬p ((l.drop_while p).nth_le 0 hl) := by\n  induction' l with hd tl IH\n  · cases hl\n  · simp only [drop_while]\n    split_ifs with hp\n    · exact IH _\n    · simpa using hp\n#align drop_while_nth_le_zero_not drop_while_nth_le_zero_not\n\n",
 "drop_while_eq_nil_iff":
 "@[simp]\ntheorem drop_while_eq_nil_iff : dropWhile p l = [] ↔ ∀ x ∈ l, p x :=\n  by\n  induction' l with x xs IH\n  · simp [drop_while]\n  · by_cases hp : p x <;> simp [hp, drop_while, IH]\n#align drop_while_eq_nil_iff drop_while_eq_nil_iff\n\n",
 "drop_take":
 "theorem drop_take : ∀ (m : ℕ) (n : ℕ) (l : list α), drop m (take (m + n) l) = take n (drop m l)\n  | 0, n, _ => by simp\n  | m + 1, n, nil => by simp\n  | m + 1, n, _ :: l => by\n    have h : m + 1 + n = m + n + 1 := by ac_rfl\n    simpa [take_cons, h] using drop_take m n l\n#align drop_take drop_take\n\n",
 "drop_sizeof_le":
 "theorem drop_sizeof_le [SizeOf α] (l : list α) : ∀ n : ℕ, (l.drop n).sizeof ≤ l.sizeof :=\n  by\n  induction' l with _ _ lih <;> intro n\n  · rw [drop_nil]\n  · induction' n with n nih\n    · rfl\n    · exact trans (lih _) le_add_self\n#align drop_sizeof_le drop_sizeof_le\n\n",
 "drop_one":
 "@[simp]\ntheorem drop_one : ∀ l : list α, drop 1 l = tail l\n  | [] => rfl\n  | a :: l => rfl\n#align drop_one drop_one\n\n",
 "drop_nil":
 "theorem drop_nil : ∀ n, drop n [] = ([] : list α) := fun _ => drop_eq_nil_of_le (nat.zero_le _)\n#align drop_nil drop_nil\n\n",
 "drop_length_cons":
 "theorem drop_length_cons {l : list α} (h : l ≠ []) (a : α) : (a :: l).drop l.length = [l.last h] :=\n  by\n  induction' l with y l ih generalizing a\n  · cases h rfl\n  · simp only [drop, length]\n    by_cases h₁ : l = []\n    · simp [h₁]\n    rw [last_cons h₁]\n    exact ih h₁ y\n#align drop_length_cons drop_length_cons\n\n",
 "drop_length":
 "@[simp]\ntheorem drop_length (l : list α) : l.drop l.length = [] :=\n  calc\n    l.drop l.length = (l ++ []).drop l.length := by simp\n    _ = [] := drop_left _ _\n    \n#align drop_length drop_length\n\n",
 "drop_left'":
 "theorem drop_left' {l₁ l₂ : list α} {n} (h : length l₁ = n) : drop n (l₁ ++ l₂) = l₂ := by rw [← h] <;> apply drop_left\n#align drop_left' drop_left'\n\n",
 "drop_left":
 "@[simp]\ntheorem drop_left : ∀ l₁ l₂ : list α, drop (length l₁) (l₁ ++ l₂) = l₂\n  | [], l₂ => rfl\n  | a :: l₁, l₂ => drop_left l₁ l₂\n#align drop_left drop_left\n\n",
 "drop_eq_nth_le_cons":
 "theorem drop_eq_nth_le_cons : ∀ {n} {l : list α} (h), drop n l = nthLe l n h :: drop (n + 1) l\n  | 0, a :: l, h => rfl\n  | n + 1, a :: l, h => @drop_eq_nth_le_cons n _ _\n#align drop_eq_nth_le_cons drop_eq_nth_le_cons\n\n",
 "drop_eq_nil_of_le":
 "@[simp]\ntheorem drop_eq_nil_of_le {l : list α} {k : ℕ} (h : l.length ≤ k) : l.drop k = [] := by\n  simpa [← length_eq_zero] using tsub_eq_zero_iff_le.mpr h\n#align drop_eq_nil_of_le drop_eq_nil_of_le\n\n",
 "drop_eq_nil_iff_le":
 "theorem drop_eq_nil_iff_le {l : list α} {k : ℕ} : l.drop k = [] ↔ l.length ≤ k :=\n  by\n  refine' ⟨fun h => _, drop_eq_nil_of_le⟩\n  induction' k with k hk generalizing l\n  · simp only [drop] at h\n    simp [h]\n  · cases l\n    · simp\n    · simp only [drop] at h\n      simpa [nat.succ_le_succ_iff] using hk h\n#align drop_eq_nil_iff_le drop_eq_nil_iff_le\n\n",
 "drop_drop":
 "@[simp]\ntheorem drop_drop (n : ℕ) : ∀ (m) (l : list α), drop n (drop m l) = drop (n + m) l\n  | m, [] => by simp\n  | 0, l => by simp\n  | m + 1, a :: l =>\n    calc\n      drop n (drop (m + 1) (a :: l)) = drop n (drop m l) := rfl\n      _ = drop (n + m) l := drop_drop m l\n      _ = drop (n + (m + 1)) (a :: l) := rfl\n      \n#align drop_drop drop_drop\n\n",
 "drop_append_of_le_length":
 "theorem drop_append_of_le_length {l₁ l₂ : list α} {n : ℕ} (h : n ≤ l₁.length) : (l₁ ++ l₂).drop n = l₁.drop n ++ l₂ :=\n  by simp [drop_append_eq_append_drop, tsub_eq_zero_iff_le.mpr h]\n#align drop_append_of_le_length drop_append_of_le_length\n\n",
 "drop_append_eq_append_drop":
 "/-- Dropping the elements up to `n` in `l₁ ++ l₂` is the same as dropping the elements up to `n`\nin `l₁`, dropping the elements up to `n - l₁.length` in `l₂`, and appending them. -/\ntheorem drop_append_eq_append_drop {l₁ l₂ : list α} {n : ℕ} :\n    drop n (l₁ ++ l₂) = drop n l₁ ++ drop (n - l₁.length) l₂ :=\n  by\n  induction l₁ generalizing n; · simp\n  cases n; · simp; simp [*]\n#align drop_append_eq_append_drop drop_append_eq_append_drop\n\n",
 "drop_append":
 "/-- Dropping the elements up to `l₁.length + i` in `l₁ + l₂` is the same as dropping the elements\nup to `i` in `l₂`. -/\ntheorem drop_append {l₁ l₂ : list α} (i : ℕ) : drop (l₁.length + i) (l₁ ++ l₂) = drop i l₂ := by\n  simp [drop_append_eq_append_drop, take_all_of_le le_self_add]\n#align drop_append drop_append\n\n",
 "drop_add":
 "theorem drop_add : ∀ (m n) (l : list α), drop (m + n) l = drop m (drop n l)\n  | m, 0, l => rfl\n  | m, n + 1, [] => (drop_nil _).symm\n  | m, n + 1, a :: l => drop_add m n _\n#align drop_add drop_add\n\n",
 "doubleton_eq":
 "theorem doubleton_eq [decidable_eq α] {x y : α} (h : x ≠ y) : ({x, y} : list α) = [x, y] :=\n  by\n  rw [insert_neg, singleton_eq]\n  rwa [singleton_eq, mem_singleton]\n#align doubleton_eq doubleton_eq\n\n",
 "diff_subset":
 "theorem diff_subset (l₁ l₂ : list α) : l₁.diff l₂ ⊆ l₁ :=\n  (diff_sublist _ _).subset\n#align diff_subset diff_subset\n\n",
 "diff_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem diff_sublist : ∀ l₁ l₂ : list α, «expr <+ » (l₁.diff l₂) l₁\n  | l₁, [] => Sublist.refl _\n  | l₁, a :: l₂ =>\n    calc\n      l₁.diff (a :: l₂) = (l₁.erase a).diff l₂ := diff_cons _ _ _\n      «expr <+ » _ (l₁.erase a) := diff_sublist _ _\n      «expr <+ » _ l₁ := List.erase_sublist _ _\n      \n#align diff_sublist diff_sublist\n\n",
 "diff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.diff_right : ∀ {l₁ l₂ l₃ : list α}, «expr <+ » l₁ l₂ → «expr <+ » (l₁.diff l₃) (l₂.diff l₃)\n  | l₁, l₂, [], h => h\n  | l₁, l₂, a :: l₃, h => by simp only [diff_cons, (h.erase _).diff_right]\n#align sublist.diff_right sublist.diff_right\n\n",
 "diff_nil":
 "@[simp]\ntheorem diff_nil (l : list α) : l.diff [] = l :=\n  rfl\n#align diff_nil diff_nil\n\n",
 "diff_erase":
 "theorem diff_erase (l₁ l₂ : list α) (a : α) : (l₁.diff l₂).erase a = (l₁.erase a).diff l₂ := by\n  rw [← diff_cons_right, diff_cons]\n#align diff_erase diff_erase\n\n",
 "diff_eq_foldl":
 "theorem diff_eq_foldl : ∀ l₁ l₂ : list α, l₁.diff l₂ = foldl List.erase l₁ l₂\n  | l₁, [] => rfl\n  | l₁, a :: l₂ => (diff_cons l₁ l₂ a).trans (diff_eq_foldl _ _)\n#align diff_eq_foldl diff_eq_foldl\n\n",
 "diff_cons_right":
 "theorem diff_cons_right (l₁ l₂ : list α) (a : α) : l₁.diff (a :: l₂) = (l₁.diff l₂).erase a :=\n  by\n  induction' l₂ with b l₂ ih generalizing l₁ a\n  · simp_rw [diff_cons, diff_nil]\n  · rw [diff_cons, diff_cons, erase_comm, ← diff_cons, ih, ← diff_cons]\n#align diff_cons_right diff_cons_right\n\n",
 "diff_cons":
 "@[simp]\ntheorem diff_cons (l₁ l₂ : list α) (a : α) : l₁.diff (a :: l₂) = (l₁.erase a).diff l₂ :=\n  if h : a ∈ l₁ then by simp only [List.diff, if_pos h] else by simp only [List.diff, if_neg h, erase_of_not_mem h]\n#align diff_cons diff_cons\n\n",
 "diff_append":
 "@[simp]\ntheorem diff_append (l₁ l₂ l₃ : list α) : l₁.diff (l₂ ++ l₃) = (l₁.diff l₂).diff l₃ := by\n  simp only [diff_eq_foldl, foldl_append]\n#align diff_append diff_append\n\n",
 "cons_subset_of_subset_of_mem":
 "theorem cons_subset_of_subset_of_mem {a : α} {l m : list α} (ainm : a ∈ m) (lsubm : l ⊆ m) : a :: l ⊆ m :=\n  cons_subset.2 ⟨ainm, lsubm⟩\n#align cons_subset_of_subset_of_mem cons_subset_of_subset_of_mem\n\n",
 "cons_subset":
 "@[simp]\ntheorem cons_subset {a : α} {l m : list α} : a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m := by\n  simp only [subset_def, mem_cons_iff, or_imp, forall_and, forall_eq]\n#align cons_subset cons_subset\n\n",
 "cons_sublist_cons_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem cons_sublist_cons_iff {l₁ l₂ : list α} {a : α} : «expr <+ » (a :: l₁) (a :: l₂) ↔ «expr <+ » l₁ l₂ :=\n  ⟨sublist_of_cons_sublist_cons, Sublist.cons_cons _⟩\n#align cons_sublist_cons_iff cons_sublist_cons_iff\n\n",
 "cons_nth_le_drop_succ":
 "theorem cons_nth_le_drop_succ {l : list α} {n : ℕ} (hn : n < l.length) : l.nth_le n hn :: l.drop (n + 1) = l.drop n :=\n  by\n  induction' l with hd tl hl generalizing n\n  · exact absurd n.zero_le (not_le_of_lt (by simpa using hn))\n  · cases n\n    · simp\n    · simp only [Nat.succ_lt_succ_iff, list.length] at hn\n      simpa [List.nthLe, list.drop] using hl hn\n#align cons_nth_le_drop_succ cons_nth_le_drop_succ\n\n",
 "cons_ne_self":
 "theorem cons_ne_self (a : α) (l : list α) : a :: l ≠ l :=\n  mt (congr_arg length) (nat.succ_ne_self _)\n#align cons_ne_self cons_ne_self\n\n",
 "cons_ne_nil":
 "/-\nCopyright (c) 2014 Parikshit Khanna. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Parikshit Khanna, Jeremy Avigad, Leonardo de Moura, Floris van Doorn, Mario Carneiro\n-/\ntheorem cons_ne_nil (a : α) (l : list α) : a :: l ≠ [] :=\n  fun.\n#align cons_ne_nil cons_ne_nil\n\n",
 "cons_injective":
 "@[simp]\ntheorem cons_injective {a : α} : injective (cons a) := fun l₁ l₂ => fun Pe => tail_eq_of_cons_eq Pe\n#align cons_injective cons_injective\n\n",
 "cons_inj":
 "theorem cons_inj (a : α) {l l' : list α} : a :: l = a :: l' ↔ l = l' :=\n  cons_injective.eq_iff\n#align cons_inj cons_inj\n\n",
 "cons_head_tail":
 "theorem cons_head_tail [inhabited α] {l : list α} (h : l ≠ []) : headI l :: tail l = l :=\n  cons_head?_tail (head!_mem_head? h)\n#align cons_head_tail cons_head_tail\n\n",
 "cons_head'_tail":
 "theorem cons_head'_tail : ∀ {l : list α} {a : α} (h : a ∈ head? l), a :: tail l = l\n  | [], a, h => by contradiction\n  | b :: l, a, h => by\n    simp at h\n    simp [h]\n#align cons_head'_tail cons_head'_tail\n\n",
 "cons_eq_cons":
 "theorem cons_eq_cons {a b : α} {l l' : list α} : a :: l = b :: l' ↔ a = b ∧ l = l' :=\n  ⟨list.cons.inj, fun h => h.1 ▸ h.2 ▸ rfl⟩\n#align cons_eq_cons cons_eq_cons\n\n",
 "cons_eq_append_iff":
 "theorem cons_eq_append_iff {a b c : list α} {x : α} :\n    (x :: c : list α) = a ++ b ↔ a = [] ∧ b = x :: c ∨ ∃ a', a = x :: a' ∧ c = a' ++ b := by\n  rw [eq_comm, append_eq_cons_iff]\n#align cons_eq_append_iff cons_eq_append_iff\n\n",
 "cons_diff_of_not_mem":
 "theorem cons_diff_of_not_mem {a : α} {l₂ : list α} (h : a ∉ l₂) (l₁ : list α) : (a :: l₁).diff l₂ = a :: l₁.diff l₂ :=\n  by rw [cons_diff, if_neg h]\n#align cons_diff_of_not_mem cons_diff_of_not_mem\n\n",
 "cons_diff_of_mem":
 "theorem cons_diff_of_mem {a : α} {l₂ : list α} (h : a ∈ l₂) (l₁ : list α) : (a :: l₁).diff l₂ = l₁.diff (l₂.erase a) :=\n  by rw [cons_diff, if_pos h]\n#align cons_diff_of_mem cons_diff_of_mem\n\n",
 "cons_diff":
 "theorem cons_diff (a : α) (l₁ l₂ : list α) :\n    (a :: l₁).diff l₂ = if a ∈ l₂ then l₁.diff (l₂.erase a) else a :: l₁.diff l₂ :=\n  by\n  induction' l₂ with b l₂ ih; · rfl\n  rcases eq_or_ne a b with (rfl | hne)\n  · simp\n  · simp only [mem_cons_iff, *, false_or_iff, diff_cons_right]\n    split_ifs with h₂ <;> simp [diff_erase, List.erase, hne, hne.symm]\n#align cons_diff cons_diff\n\n",
 "cons_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.cons_cons {l₁ l₂ : list α} (a : α) (s : «expr <+ » l₁ l₂) : «expr <+ » (a :: l₁) (a :: l₂) :=\n  Sublist.cons₂ _ _ _ s\n#align sublist.cons_cons sublist.cons_cons\n\n",
 "concat_nil":
 "theorem concat_nil (a : α) : concat [] a = [a] :=\n  rfl\n#align concat_nil concat_nil\n\n",
 "concat_ne_nil":
 "theorem concat_ne_nil (a : α) (l : list α) : concat l a ≠ [] := by simp\n#align concat_ne_nil concat_ne_nil\n\n",
 "concat_eq_reverse_cons":
 "theorem concat_eq_reverse_cons (a : α) (l : list α) : concat l a = reverse (a :: reverse l) := by\n  simp only [concat_eq_append, reverse_cons, reverse_reverse]\n#align concat_eq_reverse_cons concat_eq_reverse_cons\n\n",
 "concat_eq_append":
 "@[simp]\ntheorem concat_eq_append (a : α) (l : list α) : concat l a = l ++ [a] := by\n  induction l <;> simp only [*, concat] <;> constructor <;> rfl\n#align concat_eq_append concat_eq_append\n\n",
 "concat_cons":
 "theorem concat_cons (a b : α) (l : list α) : concat (a :: l) b = a :: concat l b :=\n  rfl\n#align concat_cons concat_cons\n\n",
 "concat_append":
 "theorem concat_append (a : α) (l₁ l₂ : list α) : concat l₁ a ++ l₂ = l₁ ++ a :: l₂ := by simp\n#align concat_append concat_append\n\n",
 "comp_map":
 "/-- A single `list.map` of a composition of functions is equal to\ncomposing a `list.map` with another `list.map`, fully applied.\nThis is the reverse direction of `list.map_map`.\n-/\ntheorem comp_map (h : β → γ) (g : α → β) (l : list α) : map (h ∘ g) l = map h (map g l) :=\n  (map_map _ _ _).symm\n#align comp_map comp_map\n\n",
 "choose_spec":
 "theorem choose_spec (hp : ∃ a, a ∈ l ∧ p a) : choose p l hp ∈ l ∧ p (choose p l hp) :=\n  (chooseX p l hp).property\n#align choose_spec choose_spec\n\n",
 "choose_property":
 "theorem choose_property (hp : ∃ a, a ∈ l ∧ p a) : p (choose p l hp) :=\n  (choose_spec _ _ _).2\n#align choose_property choose_property\n\n",
 "choose_mem":
 "theorem choose_mem (hp : ∃ a, a ∈ l ∧ p a) : choose p l hp ∈ l :=\n  (choose_spec _ _ _).1\n#align choose_mem choose_mem\n\n",
 "bind_singleton'":
 "@[simp]\ntheorem bind_singleton' (l : list α) : (l.bind fun x => [x]) = l :=\n  bind_pure l\n#align bind_singleton' bind_singleton'\n\n",
 "bind_singleton":
 "@[simp]\ntheorem bind_singleton (f : α → list β) (x : α) : [x].bind f = f x :=\n  append_nil (f x)\n#align bind_singleton bind_singleton\n\n",
 "bind_ret_eq_map":
 "theorem bind_ret_eq_map (f : α → β) (l : list α) : l.bind (List.ret ∘ f) = map f l := by\n  unfold list.bind <;> induction l <;> simp only [map, join, List.ret, cons_append, nil_append, *] <;> constructor <;>\n    rfl\n#align bind_ret_eq_map bind_ret_eq_map\n\n",
 "bind_map":
 "theorem bind_map {g : α → list β} {f : β → γ} : ∀ l : list α, list.map f (l.bind g) = l.bind fun a => (g a).map f\n  | [] => rfl\n  | a :: l => by simp only [cons_bind, map_append, bind_map l]\n#align bind_map bind_map\n\n",
 "bind_eq_bind":
 "@[simp]\ntheorem bind_eq_bind {α β} (f : α → list β) (l : list α) : l >>= f = l.bind f :=\n  rfl\n#align bind_eq_bind bind_eq_bind\n\n",
 "bind_congr":
 "#print bind_congr /-\ntheorem bind_congr {l : list α} {f g : α → list β} (h : ∀ x ∈ l, f x = g x) : list.bind l f = list.bind l g :=\n  (congr_arg list.join <| map_congr h : _)\n#align bind_congr bind_congr\n-/\n\n",
 "bind_assoc":
 "theorem bind_assoc {α β} (l : list α) (f : α → list β) (g : β → list γ) :\n    (l.bind f).bind g = l.bind fun x => (f x).bind g := by induction l <;> simp [*]\n#align bind_assoc bind_assoc\n\n",
 "bind_append":
 "-- TODO: duplicate of a lemma in core\ntheorem bind_append (f : α → list β) (l₁ l₂ : list α) : (l₁ ++ l₂).bind f = l₁.bind f ++ l₂.bind f :=\n  append_bind _ _ _\n#align bind_append bind_append\n\n",
 "attach_map_val'":
 "theorem attach_map_val' (l : list α) (f : α → β) : (l.attach.map fun i => f i.val) = l.map f :=\n  attach_map_coe' _ _\n#align attach_map_val' attach_map_val'\n\n",
 "attach_map_val":
 "theorem attach_map_val (l : list α) : l.attach.map subtype.val = l :=\n  attach_map_val _\n#align attach_map_val attach_map_val\n\n",
 "attach_map_coe'":
 "@[simp]\ntheorem attach_map_coe' (l : list α) (f : α → β) : (l.attach.map fun i => f i) = l.map f := by\n  rw [attach, map_pmap] <;> exact pmap_eq_map _ _ _ _\n#align attach_map_coe' attach_map_coe'\n\n",
 "attach_map_coe":
 "@[simp]\ntheorem attach_map_coe (l : list α) : l.attach.map (coe : _ → α) = l :=\n  (attach_map_coe' _ _).trans l.map_id\n#align attach_map_coe attach_map_coe\n\n",
 "attach_eq_nil":
 "@[simp]\ntheorem attach_eq_nil (l : list α) : l.attach = [] ↔ l = [] :=\n  pmap_eq_nil\n#align attach_eq_nil attach_eq_nil\n\n",
 "append_subset_of_subset_of_subset":
 "theorem append_subset_of_subset_of_subset {l₁ l₂ l : list α} (l₁subl : l₁ ⊆ l) (l₂subl : l₂ ⊆ l) : l₁ ++ l₂ ⊆ l :=\n  fun a h => (mem_append.1 h).elim (@l₁subl _) (@l₂subl _)\n#align append_subset_of_subset_of_subset append_subset_of_subset_of_subset\n\n",
 "append_subset_iff":
 "@[simp]\ntheorem append_subset_iff {l₁ l₂ l : list α} : l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l :=\n  by\n  constructor\n  · intro h\n    simp only [subset_def] at *\n    constructor <;> intros <;> simp [*]\n  · rintro ⟨h1, h2⟩\n    apply append_subset_of_subset_of_subset h1 h2\n#align append_subset_iff append_subset_iff\n\n",
 "append_sublist_append_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem append_sublist_append_right {l₁ l₂ : list α} (l) : «expr <+ » (l₁ ++ l) (l₂ ++ l) ↔ «expr <+ » l₁ l₂ :=\n  ⟨fun h => by simpa only [reverse_append, append_sublist_append_left, reverse_sublist_iff] using h.reverse, fun h =>\n    h.append_right l⟩\n#align append_sublist_append_right append_sublist_append_right\n\n",
 "append_sublist_append_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[simp]\ntheorem append_sublist_append_left {l₁ l₂ : list α} : ∀ l, «expr <+ » (l ++ l₁) (l ++ l₂) ↔ «expr <+ » l₁ l₂\n  | [] => iff.rfl\n  | a :: l => cons_sublist_cons_iff.trans (append_sublist_append_left l)\n#align append_sublist_append_left append_sublist_append_left\n\n",
 "append_right_injective":
 "theorem append_right_injective (s : list α) : injective fun t => s ++ t := fun t₁ t₂ => append_left_cancel\n#align append_right_injective append_right_injective\n\n",
 "append_right_inj":
 "theorem append_right_inj {t₁ t₂ : list α} (s) : s ++ t₁ = s ++ t₂ ↔ t₁ = t₂ :=\n  (append_right_injective s).eq_iff\n#align append_right_inj append_right_inj\n\n",
 "append_right_cancel":
 "theorem append_right_cancel {s₁ s₂ t : list α} (h : s₁ ++ t = s₂ ++ t) : s₁ = s₂ :=\n  append_inj_left' h rfl\n#align append_right_cancel append_right_cancel\n\n",
 "append_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.append_right {l₁ l₂ : list α} (h : «expr <+ » l₁ l₂) (l) : «expr <+ » (l₁ ++ l) (l₂ ++ l) :=\n  by\n  induction' h with _ _ a _ ih _ _ a _ ih\n  · rfl\n  · apply sublist_cons_of_sublist a ih\n  · apply ih.cons_cons a\n#align sublist.append_right sublist.append_right\n\n",
 "append_ne_nil_of_ne_nil_right":
 "theorem append_ne_nil_of_ne_nil_right (s t : list α) : t ≠ [] → s ++ t ≠ [] := by\n  induction s <;> intros <;> contradiction\n#align append_ne_nil_of_ne_nil_right append_ne_nil_of_ne_nil_right\n\n",
 "append_ne_nil_of_ne_nil_left":
 "theorem append_ne_nil_of_ne_nil_left (s t : list α) : s ≠ [] → s ++ t ≠ [] := by\n  induction s <;> intros <;> contradiction\n#align append_ne_nil_of_ne_nil_left append_ne_nil_of_ne_nil_left\n\n",
 "append_left_injective":
 "theorem append_left_injective (t : list α) : injective fun s => s ++ t := fun s₁ s₂ => append_right_cancel\n#align append_left_injective append_left_injective\n\n",
 "append_left_inj":
 "theorem append_left_inj {s₁ s₂ : list α} (t) : s₁ ++ t = s₂ ++ t ↔ s₁ = s₂ :=\n  (append_left_injective t).eq_iff\n#align append_left_inj append_left_inj\n\n",
 "append_left_cancel":
 "theorem append_left_cancel {s t₁ t₂ : list α} (h : s ++ t₁ = s ++ t₂) : t₁ = t₂ :=\n  append_inj_right h rfl\n#align append_left_cancel append_left_cancel\n\n",
 "append_inj_right'":
 "theorem append_inj_right' {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length t₁ = length t₂) : t₁ = t₂ :=\n  (append_inj' h hl).right\n#align append_inj_right' append_inj_right'\n\n",
 "append_inj_right":
 "theorem append_inj_right {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length s₁ = length s₂) : t₁ = t₂ :=\n  (append_inj h hl).right\n#align append_inj_right append_inj_right\n\n",
 "append_inj_left'":
 "theorem append_inj_left' {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length t₁ = length t₂) : s₁ = s₂ :=\n  (append_inj' h hl).left\n#align append_inj_left' append_inj_left'\n\n",
 "append_inj_left":
 "theorem append_inj_left {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length s₁ = length s₂) : s₁ = s₂ :=\n  (append_inj h hl).left\n#align append_inj_left append_inj_left\n\n",
 "append_inj'":
 "theorem append_inj' {s₁ s₂ t₁ t₂ : list α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length t₁ = length t₂) : s₁ = s₂ ∧ t₁ = t₂ :=\n  append_inj h <|\n    @nat.add_right_cancel _ (length t₁) _ <| by\n      let hap := congr_arg length h\n      simp only [length_append] at hap <;> rwa [← hl] at hap\n#align append_inj' append_inj'\n\n",
 "append_inj":
 "-- TODO(Leo): cleanup proof after arith dec proc\ntheorem append_inj : ∀ {s₁ s₂ t₁ t₂ : list α}, s₁ ++ t₁ = s₂ ++ t₂ → length s₁ = length s₂ → s₁ = s₂ ∧ t₁ = t₂\n  | [], [], t₁, t₂, h, hl => ⟨rfl, h⟩\n  | a :: s₁, [], t₁, t₂, h, hl => list.no_confusion <| eq_nil_of_length_eq_zero hl\n  | [], b :: s₂, t₁, t₂, h, hl => list.no_confusion <| eq_nil_of_length_eq_zero hl.symm\n  | a :: s₁, b :: s₂, t₁, t₂, h, hl =>\n    list.no_confusion h fun ab hap =>\n      by\n      let ⟨e1, e2⟩ := @append_inj s₁ s₂ t₁ t₂ hap (succ.inj hl)\n      rw [ab, e1, e2] <;> exact ⟨rfl, rfl⟩\n#align append_inj append_inj\n\n",
 "append_eq_nil":
 "@[simp]\ntheorem append_eq_nil {p q : list α} : p ++ q = [] ↔ p = [] ∧ q = [] := by\n  cases p <;> simp only [nil_append, cons_append, eq_self_iff_true, true_and_iff, false_and_iff]\n#align append_eq_nil append_eq_nil\n\n",
 "append_eq_has_append":
 "theorem append_eq_has_append {L₁ L₂ : list α} : list.append L₁ L₂ = L₁ ++ L₂ :=\n  rfl\n#align append_eq_has_append append_eq_has_append\n\n",
 "append_eq_cons_iff":
 "theorem append_eq_cons_iff {a b c : list α} {x : α} :\n    a ++ b = x :: c ↔ a = [] ∧ b = x :: c ∨ ∃ a', a = x :: a' ∧ c = a' ++ b := by\n  cases a <;>\n    simp only [and_assoc', @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and_iff, false_and_iff,\n      exists_false, false_or_iff, or_false_iff, exists_and_left, exists_eq_left']\n#align append_eq_cons_iff append_eq_cons_iff\n\n",
 "append_eq_append_iff":
 "theorem append_eq_append_iff {a b c d : list α} :\n    a ++ b = c ++ d ↔ (∃ a', c = a ++ a' ∧ b = a' ++ d) ∨ ∃ c', a = c ++ c' ∧ d = c' ++ b :=\n  by\n  induction a generalizing c\n  case nil =>\n    rw [nil_append]; constructor\n    · rintro rfl\n      left\n      exact ⟨_, rfl, rfl⟩\n    · rintro (⟨a', rfl, rfl⟩ | ⟨a', H, rfl⟩)\n      · rfl\n      · rw [← append_assoc, ← H]\n        rfl\n  case cons a as ih =>\n    cases c\n    · simp only [cons_append, nil_append, false_and_iff, exists_false, false_or_iff, exists_eq_left']\n      exact eq_comm\n    · simp only [cons_append, @eq_comm _ a, ih, and_assoc', and_or_left, exists_and_left]\n#align append_eq_append_iff append_eq_append_iff\n\n",
 "append_concat":
 "theorem append_concat (a : α) (l₁ l₂ : list α) : l₁ ++ concat l₂ a = concat (l₁ ++ l₂) a := by simp\n#align append_concat append_concat\n\n",
 "append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.append {l₁ l₂ r₁ r₂ : list α} (hl : «expr <+ » l₁ l₂) (hr : «expr <+ » r₁ r₂) :\n    «expr <+ » (l₁ ++ r₁) (l₂ ++ r₂) :=\n  (hl.append_right _).trans ((append_sublist_append_left _).2 hr)\n#align sublist.append sublist.append\n\n",
 "antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.antisymm (s₁ : «expr <+ » l₁ l₂) (s₂ : «expr <+ » l₂ l₁) : l₁ = l₂ :=\n  s₁.eq_of_length_le s₂.length_le\n#align sublist.antisymm sublist.antisymm\n\n",
 "all₂_map_iff":
 "@[simp]\ntheorem all₂_map_iff {p : β → Prop} (f : α → β) : All₂ p (l.map f) ↔ All₂ (p ∘ f) l := by induction l <;> simp [*]\n#align all₂_map_iff all₂_map_iff\n\n",
 "all₂_iff_forall":
 "theorem all₂_iff_forall : ∀ {l : list α}, All₂ p l ↔ ∀ x ∈ l, p x\n  | [] => (iff_true_intro <| forall_mem_nil _).symm\n  | x :: l => by rw [ball_cons, all₂_cons, all₂_iff_forall]\n#align all₂_iff_forall all₂_iff_forall\n\n",
 "all₂_cons":
 "@[simp]\ntheorem all₂_cons (p : α → Prop) (x : α) : ∀ l : list α, All₂ p (x :: l) ↔ p x ∧ All₂ p l\n  | [] => (and_true_iff _).symm\n  | x :: l => iff.rfl\n#align all₂_cons all₂_cons\n\n"}