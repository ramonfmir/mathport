{"rel_sections":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_sections {r : α → β → Prop} : («expr ⇒ » (Forall₂ (Forall₂ r)) (Forall₂ (Forall₂ r))) sections sections\n  | _, _, forall₂.nil => Forall₂.cons Forall₂.nil Forall₂.nil\n  | _, _, forall₂.cons h₀ h₁ => rel_bind (rel_sections h₁) fun _ _ hl => rel_map (fun _ _ ha => Forall₂.cons ha hl) h₀\n#align rel_sections rel_sections\n\n",
 "mem_sections_length":
 "theorem mem_sections_length {L : List (List α)} {f} (h : f ∈ sections L) : length f = length L :=\n  (mem_sections.1 h).length_eq\n#align mem_sections_length mem_sections_length\n\n",
 "mem_sections":
 "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem mem_sections {L : List (List α)} {f} : f ∈ sections L ↔ Forall₂ (· ∈ ·) f L :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · induction L generalizing f\n    · cases mem_singleton.1 h\n      exact forall₂.nil\n    simp only [sections, bind_eq_bind, mem_bind, mem_map] at h\n    rcases h with ⟨_, _, _, _, rfl⟩\n    simp only [*, forall₂_cons, true_and_iff]\n  · induction' h with a l f L al fL fs\n    · exact or.inl rfl\n    simp only [sections, bind_eq_bind, mem_bind, mem_map]\n    exact ⟨_, fs, _, al, rfl, rfl⟩\n#align mem_sections mem_sections\n\n"}