{"range_map_coe":
 "theorem range_map_coe (s : set α) : Set.range (map (coe : s → α)) = { l | ∀ x ∈ l, x ∈ s } := by\n  rw [range_map, Subtype.range_coe]\n#align range_map_coe range_map_coe\n\n",
 "range_map":
 "/-\nCopyright (c) 2021 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky, Yury Kudryashov\n-/\ntheorem range_map (f : α → β) : Set.range (map f) = { l | ∀ x ∈ l, x ∈ Set.range f } :=\n  by\n  refine'\n    Set.Subset.antisymm (Set.range_subset_iff.2 fun l => forall_mem_map_iff.2 fun y _ => Set.mem_range_self _)\n      fun l hl => _\n  induction' l with a l ihl; · exact ⟨[], rfl⟩\n  rcases ihl fun x hx => hl x <| subset_cons _ _ hx with ⟨l, rfl⟩\n  rcases hl a (mem_cons_self _ _) with ⟨a, rfl⟩\n  exact ⟨a :: l, map_cons _ _ _⟩\n#align range_map range_map\n\n",
 "inj_on_insert_nth_index_of_not_mem":
 "theorem inj_on_insert_nth_index_of_not_mem (l : list α) (x : α) (hx : x ∉ l) :\n    Set.InjOn (fun k => insertNth k x l) { n | n ≤ l.length } :=\n  by\n  induction' l with hd tl IH\n  · intro n hn m hm h\n    simp only [Set.mem_singleton_iff, Set.setOf_eq_eq_singleton, length, nonpos_iff_eq_zero] at hn hm\n    simp [hn, hm]\n  · intro n hn m hm h\n    simp only [length, Set.mem_setOf_eq] at hn hm\n    simp only [mem_cons_iff, not_or] at hx\n    cases n <;> cases m\n    · rfl\n    · simpa [hx.left] using h\n    · simpa [ne.symm hx.left] using h\n    · simp only [true_and_iff, eq_self_iff_true, insert_nth_succ_cons] at h\n      rw [Nat.succ_inj']\n      refine' IH hx.right _ _ h\n      · simpa [nat.succ_le_succ_iff] using hn\n      · simpa [nat.succ_le_succ_iff] using hm\n#align inj_on_insert_nth_index_of_not_mem inj_on_insert_nth_index_of_not_mem\n\n"}