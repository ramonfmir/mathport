{"permutations_nil":
 "@[simp]\ntheorem permutations_nil : permutations ([] : List α) = [[]] := by rw [permutations, permutations_aux_nil]\n#align permutations_nil permutations_nil\n\n",
 "permutations_aux_nil":
 "@[simp]\ntheorem permutations_aux_nil (is : List α) : permutationsAux [] is = [] := by\n  rw [permutations_aux, permutations_aux.rec]\n#align permutations_aux_nil permutations_aux_nil\n\n",
 "permutations_aux_cons":
 "@[simp]\ntheorem permutations_aux_cons (t : α) (ts is : List α) :\n    permutationsAux (t :: ts) is =\n      foldr (fun y r => (permutationsAux2 t ts r y id).2) (permutationsAux ts (t :: is)) (permutations is) :=\n  by rw [permutations_aux, permutations_aux.rec] <;> rfl\n#align permutations_aux_cons permutations_aux_cons\n\n",
 "permutations_aux_append":
 "theorem permutations_aux_append (is is' ts : List α) :\n    permutationsAux (is ++ ts) is' = (permutationsAux is is').map (· ++ ts) ++ permutationsAux ts (is.reverse ++ is') :=\n  by\n  induction' is with t is ih generalizing is'; · simp\n  simp [foldr_permutations_aux2, ih, bind_map]\n  congr 2; funext ys; rw [map_permutations_aux2]\n  simp (config := { singlePass := true }) only [← permutations_aux2_comp_append]\n  simp only [id, append_assoc]\n#align permutations_aux_append permutations_aux_append\n\n",
 "permutations_aux2_snd_nil":
 "@[simp]\ntheorem permutations_aux2_snd_nil (t : α) (ts : List α) (r : List β) (f : List α → β) :\n    (permutationsAux2 t ts r [] f).2 = r :=\n  rfl\n#align permutations_aux2_snd_nil permutations_aux2_snd_nil\n\n",
 "permutations_aux2_snd_eq":
 "/-- An expository lemma to show how all of `ts`, `r`, and `f` can be eliminated from\n`permutations_aux2`.\n\n`(permutations_aux2 t [] [] ys id).2`, which appears on the RHS, is a list whose elements are\nproduced by inserting `t` into every non-terminal position of `ys` in order. As an example:\n```lean\n#eval permutations_aux2 1 [] [] [2, 3, 4] id\n-- [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4]]\n```\n-/\ntheorem permutations_aux2_snd_eq (t : α) (ts : List α) (r : List β) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts r ys f).2 = ((permutationsAux2 t [] [] ys id).2.map fun x => f (x ++ ts)) ++ r := by\n  rw [← permutations_aux2_append, map_permutations_aux2, permutations_aux2_comp_append]\n#align permutations_aux2_snd_eq permutations_aux2_snd_eq\n\n",
 "permutations_aux2_snd_cons":
 "@[simp]\ntheorem permutations_aux2_snd_cons (t : α) (ts : List α) (r : List β) (y : α) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts r (y :: ys) f).2 =\n      f (t :: y :: ys ++ ts) :: (permutationsAux2 t ts r ys fun x : List α => f (y :: x)).2 :=\n  match (motive :=\n    ∀ o : List α × List β, o.1 = ys ++ ts → (permutations_aux2._match_1 t y f o).2 = f (t :: y :: ys ++ ts) :: o.2) _,\n    permutationsAux2_fst t ts r _ _ with\n  | ⟨_, zs⟩, rfl => rfl\n#align permutations_aux2_snd_cons permutations_aux2_snd_cons\n\n",
 "permutations_aux2_fst":
 "/-\nCopyright (c) 2014 Parikshit Khanna. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Parikshit Khanna, Jeremy Avigad, Leonardo de Moura, Floris van Doorn, Mario Carneiro\n-/\ntheorem permutations_aux2_fst (t : α) (ts : List α) (r : List β) :\n    ∀ (ys : List α) (f : List α → β), (permutationsAux2 t ts r ys f).1 = ys ++ ts\n  | [], f => rfl\n  | y :: ys, f =>\n    match (motive := ∀ o : List α × List β, o.1 = ys ++ ts → (permutations_aux2._match_1 t y f o).1 = y :: ys ++ ts) _,\n      permutations_aux2_fst ys _ with\n    | ⟨_, zs⟩, rfl => rfl\n#align permutations_aux2_fst permutations_aux2_fst\n\n",
 "permutations_aux2_comp_append":
 "/-- The `ts` argument to `permutations_aux2` can be folded into the `f` argument. -/\ntheorem permutations_aux2_comp_append {t : α} {ts ys : List α} {r : List β} (f : List α → β) :\n    (permutationsAux2 t [] r ys fun x => f (x ++ ts)).2 = (permutationsAux2 t ts r ys f).2 :=\n  by\n  induction ys generalizing f\n  · simp\n  · simp [ys_ih fun xs => f (ys_hd :: xs)]\n#align permutations_aux2_comp_append permutations_aux2_comp_append\n\n",
 "permutations_aux2_append":
 "/-- The `r` argument to `permutations_aux2` is the same as appending. -/\ntheorem permutations_aux2_append (t : α) (ts : List α) (r : List β) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts nil ys f).2 ++ r = (permutationsAux2 t ts r ys f).2 := by\n  induction ys generalizing f <;> simp [*]\n#align permutations_aux2_append permutations_aux2_append\n\n",
 "permutations_append":
 "theorem permutations_append (is ts : List α) :\n    permutations (is ++ ts) = (permutations is).map (· ++ ts) ++ permutationsAux ts is.reverse := by\n  simp [permutations, permutations_aux_append]\n#align permutations_append permutations_append\n\n",
 "permutations'_aux_eq_permutations_aux2":
 "theorem permutations'_aux_eq_permutations_aux2 (t : α) (ts : List α) :\n    permutations'Aux t ts = (permutationsAux2 t [] [ts ++ [t]] ts id).2 :=\n  by\n  induction' ts with a ts ih; · rfl\n  simp [permutations'_aux, permutations_aux2_snd_cons, ih]\n  simp (config := { singlePass := true }) only [← permutations_aux2_append]\n  simp [map_permutations_aux2]\n#align permutations'_aux_eq_permutations_aux2 permutations'_aux_eq_permutations_aux2\n\n",
 "mem_permutations_aux2'":
 "theorem mem_permutations_aux2' {t : α} {ts : List α} {ys : List α} {l : List α} :\n    l ∈ (permutationsAux2 t ts [] ys id).2 ↔ ∃ l₁ l₂, l₂ ≠ [] ∧ ys = l₁ ++ l₂ ∧ l = l₁ ++ t :: l₂ ++ ts := by\n  rw [show @id (List α) = append nil by funext <;> rfl] <;> apply mem_permutations_aux2\n#align mem_permutations_aux2' mem_permutations_aux2'\n\n",
 "mem_permutations_aux2":
 "theorem mem_permutations_aux2 {t : α} {ts : List α} {ys : List α} {l l' : List α} :\n    l' ∈ (permutationsAux2 t ts [] ys (append l)).2 ↔\n      ∃ l₁ l₂, l₂ ≠ [] ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts :=\n  by\n  induction' ys with y ys ih generalizing l\n  · simp (config := { contextual := true })\n  rw [permutations_aux2_snd_cons, show (fun x : List α => l ++ y :: x) = append (l ++ [y]) by funext <;> simp,\n    mem_cons_iff, ih]\n  constructor\n  · rintro (rfl | ⟨l₁, l₂, l0, rfl, rfl⟩)\n    · exact ⟨[], y :: ys, by simp⟩\n    · exact ⟨y :: l₁, l₂, l0, by simp⟩\n  · rintro ⟨_ | ⟨y', l₁⟩, l₂, l0, ye, rfl⟩\n    · simp [ye]\n    · simp only [cons_append] at ye\n      rcases ye with ⟨rfl, rfl⟩\n      exact or.inr ⟨l₁, l₂, l0, by simp⟩\n#align mem_permutations_aux2 mem_permutations_aux2\n\n",
 "mem_foldr_permutations_aux2":
 "theorem mem_foldr_permutations_aux2 {t : α} {ts : List α} {r L : List (List α)} {l' : List α} :\n    l' ∈ foldr (fun y r => (permutationsAux2 t ts r y id).2) r L ↔\n      l' ∈ r ∨ ∃ l₁ l₂, l₁ ++ l₂ ∈ L ∧ l₂ ≠ [] ∧ l' = l₁ ++ t :: l₂ ++ ts :=\n  by\n  have :\n    (∃ a : List α, a ∈ L ∧ ∃ l₁ l₂ : List α, ¬l₂ = nil ∧ a = l₁ ++ l₂ ∧ l' = l₁ ++ t :: (l₂ ++ ts)) ↔\n      ∃ l₁ l₂ : List α, ¬l₂ = nil ∧ l₁ ++ l₂ ∈ L ∧ l' = l₁ ++ t :: (l₂ ++ ts) :=\n    ⟨fun ⟨a, aL, l₁, l₂, l0, e, h⟩ => ⟨l₁, l₂, l0, e ▸ aL, h⟩, fun ⟨l₁, l₂, l0, aL, h⟩ => ⟨_, aL, l₁, l₂, l0, rfl, h⟩⟩\n  rw [foldr_permutations_aux2] <;>\n    simp [mem_permutations_aux2', this, or_comm, or_left_comm, or_assoc, and_comm, and_left_comm, and_assoc]\n#align mem_foldr_permutations_aux2 mem_foldr_permutations_aux2\n\n",
 "map_permutations_aux2'":
 "theorem map_permutations_aux2' {α β α' β'} (g : α → α') (g' : β → β') (t : α) (ts ys : List α) (r : List β)\n    (f : List α → β) (f' : List α' → β') (H : ∀ a, g' (f a) = f' (map g a)) :\n    map g' (permutationsAux2 t ts r ys f).2 = (permutationsAux2 (g t) (map g ts) (map g' r) (map g ys) f').2 :=\n  by\n  induction ys generalizing f f' <;> simp [*]\n  apply ys_ih; simp [H]\n#align map_permutations_aux2' map_permutations_aux2'\n\n",
 "map_permutations_aux2":
 "/-- The `f` argument to `permutations_aux2` when `r = []` can be eliminated. -/\ntheorem map_permutations_aux2 (t : α) (ts : List α) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts [] ys id).2.map f = (permutationsAux2 t ts [] ys f).2 :=\n  by\n  rw [map_permutations_aux2' id, map_id, map_id]; rfl\n  simp\n#align map_permutations_aux2 map_permutations_aux2\n\n",
 "map_permutations_aux":
 "theorem map_permutations_aux (f : α → β) :\n    ∀ ts is : List α, map (map f) (permutationsAux ts is) = permutationsAux (map f ts) (map f is) :=\n  by\n  refine' permutations_aux.rec (by simp) _\n  introv IH1 IH2; rw [map] at IH2\n  simp only [foldr_permutations_aux2, map_append, map, map_map_permutations_aux2, permutations, bind_map, IH1,\n    append_assoc, permutations_aux_cons, cons_bind, ← IH2, map_bind]\n#align map_permutations_aux map_permutations_aux\n\n",
 "map_permutations'":
 "theorem map_permutations' (f : α → β) (ts : List α) : map (map f) (permutations' ts) = permutations' (map f ts) := by\n  induction' ts with t ts ih <;> [rfl, simp [← ih, map_bind, ← map_map_permutations'_aux, bind_map]]\n#align map_permutations' map_permutations'\n\n",
 "map_permutations":
 "theorem map_permutations (f : α → β) (ts : List α) : map (map f) (permutations ts) = permutations (map f ts) := by\n  rw [permutations, permutations, map, map_permutations_aux, map]\n#align map_permutations map_permutations\n\n",
 "map_map_permutations_aux2":
 "theorem map_map_permutations_aux2 {α α'} (g : α → α') (t : α) (ts ys : List α) :\n    map (map g) (permutationsAux2 t ts [] ys id).2 = (permutationsAux2 (g t) (map g ts) [] (map g ys) id).2 :=\n  map_permutationsAux2' _ _ _ _ _ _ _ _ fun _ => rfl\n#align map_map_permutations_aux2 map_map_permutations_aux2\n\n",
 "map_map_permutations'_aux":
 "theorem map_map_permutations'_aux (f : α → β) (t : α) (ts : List α) :\n    map (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts) := by\n  induction' ts with a ts ih <;> [rfl,\n    · simp [← ih]\n      rfl]\n#align map_map_permutations'_aux map_map_permutations'_aux\n\n",
 "length_permutations_aux2":
 "theorem length_permutations_aux2 (t : α) (ts : List α) (ys : List α) (f : List α → β) :\n    length (permutationsAux2 t ts [] ys f).2 = length ys := by induction ys generalizing f <;> simp [*]\n#align length_permutations_aux2 length_permutations_aux2\n\n",
 "length_foldr_permutations_aux2'":
 "theorem length_foldr_permutations_aux2' (t : α) (ts : List α) (r L : List (List α)) (n) (H : ∀ l ∈ L, length l = n) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) = n * length L + length r :=\n  by\n  rw [length_foldr_permutations_aux2, (_ : Sum (map length L) = n * length L)]\n  induction' L with l L ih; · simp\n  have sum_map : Sum (map length L) = n * length L := ih fun l m => H l (mem_cons_of_mem _ m)\n  have length_l : length l = n := H _ (mem_cons_self _ _)\n  simp [sum_map, length_l, mul_add, add_comm]\n#align length_foldr_permutations_aux2' length_foldr_permutations_aux2'\n\n",
 "length_foldr_permutations_aux2":
 "theorem length_foldr_permutations_aux2 (t : α) (ts : List α) (r L : List (List α)) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) = sum (map length L) + length r := by\n  simp [foldr_permutations_aux2, (· ∘ ·), length_permutations_aux2]\n#align length_foldr_permutations_aux2 length_foldr_permutations_aux2\n\n",
 "foldr_permutations_aux2":
 "theorem foldr_permutations_aux2 (t : α) (ts : List α) (r L : List (List α)) :\n    foldr (fun y r => (permutationsAux2 t ts r y id).2) r L =\n      (L.bind fun y => (permutationsAux2 t ts [] y id).2) ++ r :=\n  by\n  induction' L with l L ih <;> [rfl,\n    · simp [ih]\n      rw [← permutations_aux2_append]]\n#align foldr_permutations_aux2 foldr_permutations_aux2\n\n"}