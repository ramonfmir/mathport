{"union_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.union_right {l₁ l₂ : List α} (t₁ : List α) (h : list.perm l₁ l₂) : list.perm (l₁ ∪ t₁) (l₂ ∪ t₁) :=\n  by\n  induction' h with a _ _ _ ih _ _ _ _ _ _ _ _ ih_1 ih_2 <;> try simp\n  · exact ih.insert a\n  · apply perm_insert_swap\n  · exact ih_1.trans ih_2\n#align perm.union_right perm.union_right\n\n",
 "union_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.union_left (l : List α) {t₁ t₂ : List α} (h : list.perm t₁ t₂) : list.perm (l ∪ t₁) (l ∪ t₂) := by\n  induction l <;> simp [*, perm.insert]\n#align perm.union_left perm.union_left\n\n",
 "union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n-- @[congr]\ntheorem perm.union {l₁ l₂ t₁ t₂ : List α} (p₁ : list.perm l₁ l₂) (p₂ : list.perm t₁ t₂) :\n    list.perm (l₁ ∪ t₁) (l₂ ∪ t₂) :=\n  (p₁.union_right t₁).trans (p₂.union_left l₂)\n#align perm.union perm.union\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n@[trans]\ntheorem subperm.trans {l₁ l₂ l₃ : List α} : «expr <+~ » l₁ l₂ → «expr <+~ » l₂ l₃ → «expr <+~ » l₁ l₃\n  | s, ⟨l₂', p₂, s₂⟩ =>\n    let ⟨l₁', p₁, s₁⟩ := p₂.subperm_left.2 s\n    ⟨l₁', p₁, s₁.trans s₂⟩\n#align subperm.trans subperm.trans\n\n",
 "take_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.take_inter {α} [DecidableEq α] {xs ys : List α} (n : ℕ) (h : list.perm xs ys) (h' : ys.nodup) :\n    list.perm (xs.take n) (ys.inter (xs.take n)) :=\n  by\n  simp only [list.inter] at *\n  induction h generalizing n\n  case nil n => simp only [not_mem_nil, filter_false, take_nil]\n  case\n    cons h_x h_l₁ h_l₂ h_a h_ih n =>\n    cases n <;>\n      simp only [mem_cons_iff, true_or_iff, eq_self_iff_true, filter_cons_of_pos, perm_cons, take, not_mem_nil,\n        filter_false]\n    cases' h' with _ _ h₁ h₂\n    convert h_ih h₂ n using 1\n    apply filter_congr'\n    introv h; simp only [(h₁ x h).symm, false_or_iff]\n  case swap h_x h_y h_l n =>\n    cases' h' with _ _ h₁ h₂\n    cases' h₂ with _ _ h₂ h₃\n    have := h₁ _ (or.inl rfl)\n    cases n <;> simp only [mem_cons_iff, not_mem_nil, filter_false, take]\n    cases n <;>\n      simp only [mem_cons_iff, false_or_iff, true_or_iff, Filter, *, Nat.zero_eq, if_true, not_mem_nil,\n        eq_self_iff_true, or_false_iff, if_false, perm_cons, take]\n    · rw [filter_eq_nil.2]\n      intros\n      solve_by_elim [ne.symm]\n    · convert perm.swap _ _ _\n      rw [@filter_congr' _ _ (· ∈ take n h_l)]\n      · clear h₁\n        induction n generalizing h_l\n        · simp\n        cases h_l <;>\n          simp only [mem_cons_iff, true_or_iff, eq_self_iff_true, filter_cons_of_pos, true_and_iff, take, not_mem_nil,\n            filter_false, take_nil]\n        cases' h₃ with _ _ h₃ h₄\n        rwa [@filter_congr' _ _ (· ∈ take n_n h_l_tl), n_ih]\n        · introv h\n          apply h₂ _ (or.inr h)\n        · introv h\n          simp only [(h₃ x h).symm, false_or_iff]\n      · introv h\n        simp only [(h₂ x h).symm, (h₁ x (or.inr h)).symm, false_or_iff]\n  case trans h_l₁ h_l₂ h_l₃ h₀ h₁ h_ih₀ h_ih₁ n =>\n    trans\n    · apply h_ih₀\n      rwa [h₁.nodup_iff]\n    · apply perm.filter _ h₁\n#align perm.take_inter perm.take_inter\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[symm]\nprotected theorem perm.symm {l₁ l₂ : List α} (p : list.perm l₁ l₂) : list.perm l₂ l₁ :=\n  perm.rec_on p perm.nil (fun x l₁ l₂ p₁ r₁ => r₁.cons x) (fun x y l => swap y x l) fun l₁ l₂ l₃ p₁ p₂ r₁ r₂ =>\n    r₂.trans r₁\n#align perm.symm perm.symm\n\n",
 "swap'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.swap' (x y : α) {l₁ l₂ : List α} (p : list.perm l₁ l₂) : list.perm (y :: x :: l₁) (x :: y :: l₂) :=\n  (swap _ _ _).trans ((p.cons _).cons _)\n#align perm.swap' perm.swap'\n\n",
 "subset_cons_diff":
 "theorem subset_cons_diff {a : α} {l₁ l₂ : List α} : (a :: l₁).diff l₂ ⊆ a :: l₁.diff l₂ :=\n  subperm_cons_diff.subset\n#align subset_cons_diff subset_cons_diff\n\n",
 "subset_congr_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.subset_congr_right {l₁ l₂ l₃ : List α} (h : list.perm l₁ l₂) : l₃ ⊆ l₁ ↔ l₃ ⊆ l₂ :=\n  ⟨fun h' => h'.trans h.subset, fun h' => h'.trans h.symm.subset⟩\n#align perm.subset_congr_right perm.subset_congr_right\n\n",
 "subset_congr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.subset_congr_left {l₁ l₂ l₃ : List α} (h : list.perm l₁ l₂) : l₁ ⊆ l₃ ↔ l₂ ⊆ l₃ :=\n  ⟨h.symm.subset.trans, h.subset.trans⟩\n#align perm.subset_congr_left perm.subset_congr_left\n\n",
 "subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.subset {l₁ l₂ : List α} : «expr <+~ » l₁ l₂ → l₁ ⊆ l₂\n  | ⟨l, p, s⟩ => subset.trans p.symm.subset s.subset\n#align subperm.subset subperm.subset\n\n",
 "subperm_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n@[simp]\ntheorem subperm_singleton_iff {α} {l : List α} {a : α} : «expr <+~ » [a] l ↔ a ∈ l :=\n  ⟨fun ⟨s, hla, h⟩ => by rwa [perm_singleton.mp hla, singleton_sublist] at h, fun h =>\n    ⟨[a], Perm.refl _, singleton_sublist.mpr h⟩⟩\n#align subperm_singleton_iff subperm_singleton_iff\n\n",
 "subperm_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem perm.subperm_right {l₁ l₂ l : List α} (p : list.perm l₁ l₂) : «expr <+~ » l₁ l ↔ «expr <+~ » l₂ l :=\n  ⟨fun ⟨u, pu, su⟩ => ⟨u, pu.trans p, su⟩, fun ⟨u, pu, su⟩ => ⟨u, pu.trans p.symm, su⟩⟩\n#align perm.subperm_right perm.subperm_right\n\n",
 "subperm_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem perm.subperm_left {l l₁ l₂ : List α} (p : list.perm l₁ l₂) : «expr <+~ » l l₁ ↔ «expr <+~ » l l₂ :=\n  suffices ∀ {l₁ l₂ : List α}, list.perm l₁ l₂ → «expr <+~ » l l₁ → «expr <+~ » l l₂ from ⟨this p, this p.symm⟩\n  fun l₁ l₂ p ⟨u, pu, su⟩ =>\n  let ⟨v, pv, sv⟩ := exists_perm_sublist su p\n  ⟨v, pv.trans pu, sv⟩\n#align perm.subperm_left perm.subperm_left\n\n",
 "subperm_ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/-- The list version of `multiset.le_iff_count`. -/\ntheorem subperm_ext_iff {l₁ l₂ : List α} : «expr <+~ » l₁ l₂ ↔ ∀ x ∈ l₁, count x l₁ ≤ count x l₂ :=\n  by\n  refine' ⟨fun h x hx => subperm.count_le h x, fun h => _⟩\n  suffices «expr <+~ » l₁ (l₂.diff l₁ ++ l₁)\n    by\n    refine' this.trans (perm.subperm _)\n    exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h)\n  convert(subperm_append_right _).mpr nil_subperm using 1\n#align subperm_ext_iff subperm_ext_iff\n\n",
 "subperm_cons_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm_cons_erase (a : α) (l : List α) : «expr <+~ » l (a :: l.erase a) :=\n  by\n  by_cases h : a ∈ l\n  · exact (perm_cons_erase h).subperm\n  · rw [erase_of_not_mem h]\n    exact (sublist_cons _ _).subperm\n#align subperm_cons_erase subperm_cons_erase\n\n",
 "subperm_cons_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm_cons_diff {a : α} : ∀ {l₁ l₂ : List α}, «expr <+~ » ((a :: l₁).diff l₂) (a :: l₁.diff l₂)\n  | l₁, [] => ⟨a :: l₁, by simp⟩\n  | l₁, b :: l₂ => by\n    simp only [diff_cons]\n    refine' ((erase_cons_subperm_cons_erase a b l₁).diff_right l₂).trans _\n    apply subperm_cons_diff\n#align subperm_cons_diff subperm_cons_diff\n\n",
 "subperm_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm_cons (a : α) {l₁ l₂ : List α} : «expr <+~ » (a :: l₁) (a :: l₂) ↔ «expr <+~ » l₁ l₂ :=\n  ⟨fun ⟨l, p, s⟩ => by\n    cases' s with _ _ _ s' u _ _ s'\n    · exact (p.subperm_left.2 <| (sublist_cons _ _).subperm).trans s'.subperm\n    · exact ⟨u, p.cons_inv, s'⟩, fun ⟨l, p, s⟩ => ⟨a :: l, p.cons a, s.cons2 _ _ _⟩⟩\n#align subperm_cons subperm_cons\n\n",
 "subperm_append_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm_append_right {l₁ l₂ : List α} (l) : «expr <+~ » (l₁ ++ l) (l₂ ++ l) ↔ «expr <+~ » l₁ l₂ :=\n  (perm_append_comm.subperm_left.trans perm_append_comm.subperm_right).trans (subperm_append_left l)\n#align subperm_append_right subperm_append_right\n\n",
 "subperm_append_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm_append_left {l₁ l₂ : List α} : ∀ l, «expr <+~ » (l ++ l₁) (l ++ l₂) ↔ «expr <+~ » l₁ l₂\n  | [] => iff.rfl\n  | a :: l => (subperm_cons a).trans (subperm_append_left l)\n#align subperm_append_left subperm_append_left\n\n",
 "subperm_append_diff_self_of_count_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/-- The list version of `add_tsub_cancel_of_le` for multisets. -/\ntheorem subperm_append_diff_self_of_count_le {l₁ l₂ : List α} (h : ∀ x ∈ l₁, count x l₁ ≤ count x l₂) :\n    list.perm (l₁ ++ l₂.diff l₁) l₂ :=\n  by\n  induction' l₁ with hd tl IH generalizing l₂\n  · simp\n  · have : hd ∈ l₂ := by\n      rw [← count_pos]\n      exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _))\n    replace this : list.perm l₂ (hd :: l₂.erase hd) := perm_cons_erase this\n    refine' perm.trans _ this.symm\n    rw [cons_append, diff_cons, perm_cons]\n    refine' IH fun x hx => _\n    specialize h x (mem_cons_of_mem _ hx)\n    rw [perm_iff_count.mp this] at h\n    by_cases hx : x = hd\n    · subst hd\n      simpa [Nat.succ_le_succ_iff] using h\n    · simpa [hx] using h\n#align subperm_append_diff_self_of_count_le subperm_append_diff_self_of_count_le\n\n",
 "subperm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\nprotected theorem nodup.subperm (d : Nodup l₁) (H : l₁ ⊆ l₂) : «expr <+~ » l₁ l₂ :=\n  by\n  induction' d with a l₁' h d IH\n  · exact ⟨nil, perm.nil, nil_sublist _⟩\n  · cases' forall_mem_cons.1 H with H₁ H₂\n    simp at h\n    exact cons_subperm_of_mem d h H₁ (IH H₂)\n#align nodup.subperm nodup.subperm\n\n",
 "sublist_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem nodup.sublist_ext {l₁ l₂ l : List α} (d : Nodup l) (s₁ : «expr <+ » l₁ l) (s₂ : «expr <+ » l₂ l) :\n    list.perm l₁ l₂ ↔ l₁ = l₂ :=\n  ⟨fun h => by\n    induction' s₂ with l₂ l a s₂ IH l₂ l a s₂ IH generalizing l₁\n    · exact h.eq_nil\n    · simp at d\n      cases' s₁ with _ _ _ s₁ l₁ _ _ s₁\n      · exact IH d.2 s₁ h\n      · apply d.1.elim\n        exact subperm.subset ⟨_, h.symm, s₂⟩ (mem_cons_self _ _)\n    · simp at d\n      cases' s₁ with _ _ _ s₁ l₁ _ _ s₁\n      · apply d.1.elim\n        exact subperm.subset ⟨_, h, s₁⟩ (mem_cons_self _ _)\n      · rw [IH d.2 s₁ h.cons_inv], fun h => by rw [h]⟩\n#align nodup.sublist_ext nodup.sublist_ext\n\n",
 "slice_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.slice_inter {α} [DecidableEq α] {xs ys : List α} (n m : ℕ) (h : list.perm xs ys) (h' : ys.nodup) :\n    list.perm (List.dropSlice n m xs) (ys ∩ List.dropSlice n m xs) :=\n  by\n  simp only [slice_eq]\n  have : n ≤ n + m := nat.le_add_right _ _\n  have := h.nodup_iff.2 h'\n  apply perm.trans _ (perm.inter_append _).symm <;>\n    solve_by_elim (config := { max_depth := 7 }) [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h,\n      h']\n#align perm.slice_inter perm.slice_inter\n\n",
 "sizeof_eq_sizeof":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.sizeof_eq_sizeof [SizeOf α] {l₁ l₂ : List α} (h : list.perm l₁ l₂) : l₁.sizeof = l₂.sizeof :=\n  by\n  induction' h with hd l₁ l₂ h₁₂ h_sz₁₂ a b l l₁ l₂ l₃ h₁₂ h₂₃ h_sz₁₂ h_sz₂₃\n  · rfl\n  · simp only [list.sizeof, h_sz₁₂]\n  · simp only [list.sizeof, add_left_comm]\n  · simp only [h_sz₁₂, h_sz₂₃]\n#align perm.sizeof_eq_sizeof perm.sizeof_eq_sizeof\n\n",
 "singleton_perm_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem singleton_perm_singleton {a b : α} : list.perm [a] [b] ↔ a = b := by simp\n#align singleton_perm_singleton singleton_perm_singleton\n\n",
 "singleton_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem singleton_perm {a : α} {l : List α} : list.perm [a] l ↔ [a] = l :=\n  @replicate_perm α 1 a l\n#align singleton_perm singleton_perm\n\n",
 "reverse_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem reverse_perm : ∀ l : List α, list.perm (reverse l) l\n  | [] => perm.nil\n  | a :: l => by\n    rw [reverse_cons]\n    exact (perm_append_singleton _ _).trans ((reverse_perm l).cons a)\n#align reverse_perm reverse_perm\n\n",
 "replicate_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem replicate_perm {n : ℕ} {a : α} {l : List α} : list.perm (replicate n a) l ↔ replicate n a = l :=\n  (perm_comm.trans perm_replicate).trans eq_comm\n#align replicate_perm replicate_perm\n\n",
 "rel_perm_imp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_perm_imp (hr : RightUnique r) : («expr ⇒ » (Forall₂ r) («expr ⇒ » (Forall₂ r) implies)) Perm Perm :=\n  fun a b h₁ c d h₂ h =>\n  have : («expr ∘r » (flip (Forall₂ r)) («expr ∘r » Perm (Forall₂ r))) b d := ⟨a, h₁, c, h, h₂⟩\n  have : («expr ∘r » («expr ∘r » (flip (Forall₂ r)) (Forall₂ r)) Perm) b d := by\n    rwa [← forall₂_comp_perm_eq_perm_comp_forall₂, ← Relation.comp_assoc] at this\n  let ⟨b', ⟨c', hbc, hcb⟩, hbd⟩ := this\n  have : b' = b := right_unique_forall₂' hr hcb hbc\n  this ▸ hbd\n#align rel_perm_imp rel_perm_imp\n\n",
 "rel_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_perm (hr : BiUnique r) : («expr ⇒ » (Forall₂ r) («expr ⇒ » (Forall₂ r) (· ↔ ·))) Perm Perm :=\n  fun a b hab c d hcd => iff.intro (rel_perm_imp hr.2 hab hcd) (rel_perm_imp hr.left.flip hab.flip hcd.flip)\n#align rel_perm rel_perm\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n@[refl]\ntheorem subperm.refl (l : List α) : «expr <+~ » l l :=\n  (Perm.refl _).subperm\n#align subperm.refl subperm.refl\n\n",
 "rec_heq":
 "theorem perm.rec_heq {β : List α → Sort _} {f : ∀ a l, β l → β (a :: l)} {b : β []} {l l' : List α} (hl : Perm l l')\n    (f_congr : ∀ {a l l' b b'}, Perm l l' → HEq b b' → HEq (f a l b) (f a l' b'))\n    (f_swap : ∀ {a a' l b}, HEq (f a (a' :: l) (f a' l b)) (f a' (a :: l) (f a l b))) :\n    HEq (@list.rec α β b f l) (@list.rec α β b f l') :=\n  by\n  induction hl\n  case nil => rfl\n  case cons a l l' h ih => exact f_congr h ih\n  case swap a a' l => exact f_swap\n  case trans l₁ l₂ l₃ h₁ h₂ ih₁ ih₂ => exact heq.trans ih₁ ih₂\n#align perm.rec_heq perm.rec_heq\n\n",
 "product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.product_right {l₁ l₂ : List α} (t₁ : List β) (p : list.perm l₁ l₂) :\n    list.perm (product l₁ t₁) (product l₂ t₁) :=\n  p.bind_right _\n#align perm.product_right perm.product_right\n\n",
 "product_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.product_left (l : List α) {t₁ t₂ : List β} (p : list.perm t₁ t₂) :\n    list.perm (product l t₁) (product l t₂) :=\n  Perm.bind_left _ fun a ha => p.map _\n#align perm.product_left perm.product_left\n\n",
 "product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[congr]\ntheorem perm.product {l₁ l₂ : List α} {t₁ t₂ : List β} (p₁ : list.perm l₁ l₂) (p₂ : list.perm t₁ t₂) :\n    list.perm (product l₁ t₁) (product l₂ t₂) :=\n  (p₁.product_right t₁).trans (p₂.product_left l₂)\n#align perm.product perm.product\n\n",
 "prod_reverse":
 "@[to_additive]\ntheorem prod_reverse (l : List α) : prod l.reverse = prod l :=\n  (reverse_perm l).prod_eq\n#align prod_reverse prod_reverse\n\n",
 "prod_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/-- If elements of a list commute with each other, then their product does not\ndepend on the order of elements. -/\n@[to_additive\n      \"If elements of a list additively commute with each other, then their sum does not\\ndepend on the order of elements.\"]\ntheorem perm.prod_eq' [Monoid α] {l₁ l₂ : List α} (h : list.perm l₁ l₂) (hc : l₁.pairwise Commute) :\n    l₁.prod = l₂.prod :=\n  h.foldl_eq'\n    ((Pairwise.forall_of_forall (fun x y h z => (h z).symm) fun x hx z => rfl) <|\n      hc.imp fun x y h z => by simp only [mul_assoc, h.eq])\n    _\n#align perm.prod_eq' perm.prod_eq'\n\n",
 "prod_eq":
 "@[to_additive]\ntheorem perm.prod_eq {l₁ l₂ : List α} (h : Perm l₁ l₂) : prod l₁ = prod l₂ :=\n  h.fold_op_eq\n#align perm.prod_eq perm.prod_eq\n\n",
 "pmap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.pmap {p : α → Prop} (f : ∀ a, p a → β) {l₁ l₂ : List α} (p : list.perm l₁ l₂) {H₁ H₂} :\n    list.perm (pmap f l₁ H₁) (pmap f l₂ H₂) :=\n  by\n  induction' p with x l₂ l₂' p IH x y l₂ l₂ m₂ r₂ p₁ p₂ IH₁ IH₂\n  · simp\n  · simp [IH, perm.cons]\n  · simp [swap]\n  · refine' IH₁.trans IH₂\n    exact fun a m => H₂ a (p₂.subset m)\n#align perm.pmap perm.pmap\n\n",
 "permutations_perm_permutations'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem permutations_perm_permutations' (ts : List α) : list.perm ts.permutations ts.permutations' :=\n  by\n  obtain ⟨n, h⟩ : ∃ n, length ts < n := ⟨_, nat.lt_succ_self _⟩\n  induction' n with n IH generalizing ts; · cases h\n  refine' List.reverseRecOn ts (fun h => _) (fun ts t _ h => _) h; · simp [permutations]\n  rw [← concat_eq_append, length_concat, Nat.succ_lt_succ_iff] at h\n  have IH₂ := (IH ts.reverse (by rwa [length_reverse])).trans (reverse_perm _).permutations'\n  simp only [permutations_append, foldr_permutations_aux2, permutations_aux_nil, permutations_aux_cons, append_nil]\n  refine'\n    (perm_append_comm.trans ((IH₂.bind_right _).append ((IH _ h).map _))).trans\n      (perm.trans _ perm_append_comm.permutations')\n  rw [map_eq_bind, singleton_append, permutations']\n  convert bind_append_perm _ _ _; funext ys\n  rw [permutations'_aux_eq_permutations_aux2, permutations_aux2_append]\n#align permutations_perm_permutations' permutations_perm_permutations'\n\n",
 "permutations'_aux_nth_le_zero":
 "@[simp]\ntheorem permutations'_aux_nth_le_zero (s : List α) (x : α) (hn : 0 < length (permutations'Aux x s) := (by simp)) :\n    (permutations'Aux x s).nth_le 0 hn = x :: s :=\n  nthLe_permutations'Aux _ _ _ _\n#align permutations'_aux_nth_le_zero permutations'_aux_nth_le_zero\n\n",
 "permutations'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.permutations' {s t : List α} (p : list.perm s t) : list.perm (permutations' s) (permutations' t) :=\n  by\n  induction' p with a s t p IH a b l s t u p₁ p₂ IH₁ IH₂; · simp\n  · simp only [permutations']\n    exact IH.bind_right _\n  · simp only [permutations']\n    rw [bind_assoc, bind_assoc]\n    apply perm.bind_left\n    intro l' hl'\n    apply perm_permutations'_aux_comm\n  · exact IH₁.trans IH₂\n#align perm.permutations' perm.permutations'\n\n",
 "permutations":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.permutations {s t : List α} (h : list.perm s t) : list.perm (permutations s) (permutations t) :=\n  (permutations_perm_permutations' _).trans <| h.permutations'.trans (permutations_perm_permutations' _).symm\n#align perm.permutations perm.permutations\n\n",
 "perm_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_singleton {a : α} {l : List α} : list.perm l [a] ↔ l = [a] :=\n  @perm_replicate α 1 a l\n#align perm_singleton perm_singleton\n\n",
 "perm_replicate_append_replicate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_replicate_append_replicate {l : List α} {a b : α} {m n : ℕ} (h : a ≠ b) :\n    list.perm l (replicate m a ++ replicate n b) ↔ count a l = m ∧ count b l = n ∧ l ⊆ [a, b] :=\n  by\n  rw [perm_iff_count, ← Decidable.and_forall_ne a, ← Decidable.and_forall_ne b]\n  suffices l ⊆ [a, b] ↔ ∀ c, c ≠ b → c ≠ a → c ∉ l by\n    simp (config := { contextual := true }) [count_replicate, h, h.symm, this]\n  simp_rw [ne.def, ← and_imp, ← not_or, Decidable.not_imp_not, subset_def, mem_cons_iff, not_mem_nil, or_false_iff,\n    or_comm']\n#align perm_replicate_append_replicate perm_replicate_append_replicate\n\n",
 "perm_replicate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_replicate {n : ℕ} {a : α} {l : List α} : list.perm l (replicate n a) ↔ l = replicate n a :=\n  ⟨fun p => eq_replicate.2 ⟨p.length_eq.trans <| length_replicate _ _, fun b m => eq_of_mem_replicate <| p.subset m⟩,\n    fun h => h ▸ Perm.refl _⟩\n#align perm_replicate perm_replicate\n\n",
 "perm_permutations_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_permutations_iff {s t : List α} : list.perm (permutations s) (permutations t) ↔ list.perm s t :=\n  ⟨fun h => mem_permutations.1 <| h.mem_iff.1 <| mem_permutations.2 (Perm.refl _), Perm.permutations⟩\n#align perm_permutations_iff perm_permutations_iff\n\n",
 "perm_permutations'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_permutations'_iff {s t : List α} : list.perm (permutations' s) (permutations' t) ↔ list.perm s t :=\n  ⟨fun h => mem_permutations'.1 <| h.mem_iff.1 <| mem_permutations'.2 (Perm.refl _), Perm.permutations'⟩\n#align perm_permutations'_iff perm_permutations'_iff\n\n",
 "perm_permutations'_aux_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_permutations'_aux_comm (a b : α) (l : List α) :\n    list.perm ((permutations'Aux a l).bind (permutations'Aux b)) ((permutations'Aux b l).bind (permutations'Aux a)) :=\n  by\n  induction' l with c l ih\n  · simp [swap]\n  simp [permutations'_aux]\n  apply perm.swap'\n  have :\n    ∀ a b,\n      list.perm ((map (cons c) (permutations'_aux a l)).bind (permutations'_aux b))\n        (map (cons b ∘ cons c) (permutations'_aux a l) ++\n          map (cons c) ((permutations'_aux a l).bind (permutations'_aux b))) :=\n    by\n    intros\n    simp only [map_bind, permutations'_aux]\n    refine' (bind_append_perm _ (fun x => [_]) _).symm.trans _\n    rw [← map_eq_bind, ← bind_map]\n  refine' (((this _ _).append_left _).trans _).trans ((this _ _).append_left _).symm\n  rw [← append_assoc, ← append_assoc]\n  exact perm_append_comm.append (ih.map _)\n#align perm_permutations'_aux_comm perm_permutations'_aux_comm\n\n",
 "perm_option_to_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_option_to_list {o₁ o₂ : Option α} : list.perm o₁.to_list o₂.to_list ↔ o₁ = o₂ :=\n  by\n  refine' ⟨fun p => _, fun e => e ▸ perm.refl _⟩\n  cases' o₁ with a <;> cases' o₂ with b; · rfl\n  · cases p.length_eq\n  · cases p.length_eq\n  · exact Option.mem_toList.1 (p.symm.subset <| by simp)\n#align perm_option_to_list perm_option_to_list\n\n",
 "perm_of_mem_permutations_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n-- enumerating permutations\ntheorem perm_of_mem_permutations_aux : ∀ {ts is l : List α}, l ∈ permutationsAux ts is → list.perm l (ts ++ is) :=\n  by\n  refine' permutations_aux.rec (by simp) _\n  introv IH1 IH2 m\n  rw [permutations_aux_cons, permutations, mem_foldr_permutations_aux2] at m\n  rcases m with (m | ⟨l₁, l₂, m, _, e⟩)\n  · exact (IH1 m).trans perm_middle\n  · subst e\n    have p : list.perm (l₁ ++ l₂) is := by\n      simp [permutations] at m\n      cases' m with e m\n      · simp [e]\n      exact is.append_nil ▸ IH2 m\n    exact ((perm_middle.trans (p.cons _)).append_right _).trans (perm_append_comm.cons _)\n#align perm_of_mem_permutations_aux perm_of_mem_permutations_aux\n\n",
 "perm_of_mem_permutations":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_of_mem_permutations {l₁ l₂ : List α} (h : l₁ ∈ permutations l₂) : list.perm l₁ l₂ :=\n  (eq_or_mem_of_mem_cons h).elim (fun e => e ▸ Perm.refl _) fun m => append_nil l₂ ▸ perm_of_mem_permutationsAux m\n#align perm_of_mem_permutations perm_of_mem_permutations\n\n",
 "perm_of_length_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem subperm.perm_of_length_le {l₁ l₂ : List α} : «expr <+~ » l₁ l₂ → length l₂ ≤ length l₁ → list.perm l₁ l₂\n  | ⟨l, p, s⟩, h => (s.eq_of_length_le <| p.symm.length_eq ▸ h) ▸ p.symm\n#align subperm.perm_of_length_le subperm.perm_of_length_le\n\n",
 "perm_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_nil {l₁ : List α} : list.perm l₁ [] ↔ l₁ = [] :=\n  ⟨fun p => p.eq_nil, fun e => e ▸ Perm.refl _⟩\n#align perm_nil perm_nil\n\n",
 "perm_middle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_middle {a : α} : ∀ {l₁ l₂ : List α}, list.perm (l₁ ++ a :: l₂) (a :: (l₁ ++ l₂))\n  | [], l₂ => Perm.refl _\n  | b :: l₁, l₂ => ((@perm_middle l₁ l₂).cons _).trans (swap a b _)\n#align perm_middle perm_middle\n\n",
 "perm_lookmap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_lookmap (f : α → Option α) {l₁ l₂ : List α}\n    (H : Pairwise (fun a b => ∀ c ∈ f a, ∀ d ∈ f b, a = b ∧ c = d) l₁) (p : list.perm l₁ l₂) :\n    list.perm (lookmap f l₁) (lookmap f l₂) :=\n  by\n  let F a b := ∀ c ∈ f a, ∀ d ∈ f b, a = b ∧ c = d\n  change Pairwise F l₁ at H\n  induction' p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ p₂ IH₁ IH₂; · simp\n  · cases h : f a\n    · simp [h]\n      exact IH (pairwise_cons.1 H).2\n    · simp [lookmap_cons_some _ _ h, p]\n  · cases' h₁ : f a with c <;> cases' h₂ : f b with d\n    · simp [h₁, h₂]\n      apply swap\n    · simp [h₁, lookmap_cons_some _ _ h₂]\n      apply swap\n    · simp [lookmap_cons_some _ _ h₁, h₂]\n      apply swap\n    · simp [lookmap_cons_some _ _ h₁, lookmap_cons_some _ _ h₂]\n      rcases(pairwise_cons.1 H).1 _ (or.inl rfl) _ h₂ _ h₁ with ⟨rfl, rfl⟩\n      rfl\n  · refine' (IH₁ H).trans (IH₂ ((p₁.pairwise_iff _).1 H))\n    exact fun a b h c h₁ d h₂ => (h d h₂ c h₁).imp Eq.symm Eq.symm\n#align perm_lookmap perm_lookmap\n\n",
 "perm_inv_core":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_inv_core {a : α} {l₁ l₂ r₁ r₂ : List α} :\n    list.perm (l₁ ++ a :: r₁) (l₂ ++ a :: r₂) → list.perm (l₁ ++ r₁) (l₂ ++ r₂) :=\n  by\n  generalize e₁ : l₁ ++ a :: r₁ = s₁; generalize e₂ : l₂ ++ a :: r₂ = s₂\n  intro p; revert l₁ l₂ r₁ r₂ e₁ e₂\n  refine' perm_induction_on p _ (fun x t₁ t₂ p IH => _) (fun x y t₁ t₂ p IH => _) fun t₁ t₂ t₃ p₁ p₂ IH₁ IH₂ => _ <;>\n    intro l₁ l₂ r₁ r₂ e₁ e₂\n  · apply (not_mem_nil a).elim\n    rw [← e₁]\n    simp\n  · cases' l₁ with y l₁ <;> cases' l₂ with z l₂ <;> dsimp at e₁ e₂ <;> injections <;> subst x\n    · substs t₁ t₂\n      exact p\n    · substs z t₁ t₂\n      exact p.trans perm_middle\n    · substs y t₁ t₂\n      exact perm_middle.symm.trans p\n    · substs z t₁ t₂\n      exact (IH rfl rfl).cons y\n  · rcases l₁ with (_ | ⟨y, _ | ⟨z, l₁⟩⟩) <;> rcases l₂ with (_ | ⟨u, _ | ⟨v, l₂⟩⟩) <;> dsimp at e₁ e₂ <;>\n        injections <;> substs x y\n    · substs r₁ r₂\n      exact p.cons a\n    · substs r₁ r₂\n      exact p.cons u\n    · substs r₁ v t₂\n      exact (p.trans perm_middle).cons u\n    · substs r₁ r₂\n      exact p.cons y\n    · substs r₁ r₂ y u\n      exact p.cons a\n    · substs r₁ u v t₂\n      exact ((p.trans perm_middle).cons y).trans (swap _ _ _)\n    · substs r₂ z t₁\n      exact (perm_middle.symm.trans p).cons y\n    · substs r₂ y z t₁\n      exact (swap _ _ _).trans ((perm_middle.symm.trans p).cons u)\n    · substs u v t₁ t₂\n      exact (IH rfl rfl).swap' _ _\n  · substs t₁ t₃\n    have : a ∈ t₂ := p₁.subset (by simp)\n    rcases mem_split this with ⟨l₂, r₂, e₂⟩\n    subst t₂\n    exact (IH₁ rfl rfl).trans (IH₂ rfl rfl)\n#align perm_inv_core perm_inv_core\n\n",
 "perm_insert_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_insert_swap (x y : α) (l : List α) : list.perm (insert x (insert y l)) (insert y (insert x l)) :=\n  by\n  by_cases xl : x ∈ l <;> by_cases yl : y ∈ l <;> simp [xl, yl]\n  by_cases xy : x = y; · simp [xy]\n  simp [not_mem_cons_of_ne_of_not_mem xy xl, not_mem_cons_of_ne_of_not_mem (ne.symm xy) yl]\n  constructor\n#align perm_insert_swap perm_insert_swap\n\n",
 "perm_insert_nth":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_insert_nth {α} (x : α) (l : List α) {n} (h : n ≤ l.length) : list.perm (insertNth n x l) (x :: l) :=\n  by\n  induction l generalizing n\n  · cases n\n    rfl\n    cases h\n  cases n\n  · simp [insert_nth]\n  · simp only [insert_nth, modify_nth_tail]\n    trans\n    · apply perm.cons\n      apply l_ih\n      apply nat.le_of_succ_le_succ h\n    · apply perm.swap\n#align perm_insert_nth perm_insert_nth\n\n",
 "perm_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[elab_as_elim]\ntheorem perm_induction_on {P : List α → List α → Prop} {l₁ l₂ : List α} (p : list.perm l₁ l₂) (h₁ : P [] [])\n    (h₂ : ∀ x l₁ l₂, list.perm l₁ l₂ → P l₁ l₂ → P (x :: l₁) (x :: l₂))\n    (h₃ : ∀ x y l₁ l₂, list.perm l₁ l₂ → P l₁ l₂ → P (y :: x :: l₁) (x :: y :: l₂))\n    (h₄ : ∀ l₁ l₂ l₃, list.perm l₁ l₂ → list.perm l₂ l₃ → P l₁ l₂ → P l₂ l₃ → P l₁ l₃) : P l₁ l₂ :=\n  have P_refl : ∀ l, P l l := fun l => list.rec_on l h₁ fun x xs ih => h₂ x xs xs (Perm.refl xs) ih\n  perm.rec_on p h₁ h₂ (fun x y l => h₃ x y l l (Perm.refl l) (P_refl l)) h₄\n#align perm_induction_on perm_induction_on\n\n",
 "perm_iff_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_iff_count {l₁ l₂ : List α} : list.perm l₁ l₂ ↔ ∀ a, count a l₁ = count a l₂ :=\n  ⟨Perm.count_eq, fun H => by\n    induction' l₁ with a l₁ IH generalizing l₂\n    · cases' l₂ with b l₂\n      · rfl\n      specialize H b\n      simp at H\n      contradiction\n    · have : a ∈ l₂ := count_pos.1 (by rw [← H] <;> simp <;> apply nat.succ_pos)\n      refine' ((IH fun b => _).cons a).trans (perm_cons_erase this).symm\n      specialize H b\n      rw [(perm_cons_erase this).count_eq] at H\n      by_cases b = a <;> simp [h] at H⊢ <;> assumption⟩\n#align perm_iff_count perm_iff_count\n\n",
 "perm_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_ext {l₁ l₂ : List α} (d₁ : Nodup l₁) (d₂ : Nodup l₂) : list.perm l₁ l₂ ↔ ∀ a, a ∈ l₁ ↔ a ∈ l₂ :=\n  ⟨fun p a => p.mem_iff, fun H => (d₁.subperm fun a => (H a).1).antisymm <| d₂.subperm fun a => (H a).2⟩\n#align perm_ext perm_ext\n\n",
 "perm_cons_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_cons_erase [DecidableEq α] {a : α} {l : List α} (h : a ∈ l) : list.perm l (a :: l.erase a) :=\n  let ⟨l₁, l₂, _, e₁, e₂⟩ := exists_erase_eq h\n  e₂.symm ▸ e₁.symm ▸ perm_middle\n#align perm_cons_erase perm_cons_erase\n\n",
 "perm_cons_append_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_cons_append_cons {l l₁ l₂ : List α} (a : α) (p : list.perm l (l₁ ++ l₂)) :\n    list.perm (a :: l) (l₁ ++ a :: l₂) :=\n  (p.cons a).trans perm_middle.symm\n#align perm_cons_append_cons perm_cons_append_cons\n\n",
 "perm_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_cons (a : α) {l₁ l₂ : List α} : list.perm (a :: l₁) (a :: l₂) ↔ list.perm l₁ l₂ :=\n  ⟨Perm.cons_inv, perm.cons a⟩\n#align perm_cons perm_cons\n\n",
 "perm_comp_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\ntheorem perm_comp_perm : («expr ∘r » Perm Perm : List α → List α → Prop) = Perm :=\n  by\n  funext a c; apply propext\n  constructor\n  · exact fun ⟨b, hab, hba⟩ => perm.trans hab hba\n  · exact fun h => ⟨a, perm.refl a, h⟩\n#align perm_comp_perm perm_comp_perm\n\n",
 "perm_comp_forall₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\ntheorem perm_comp_forall₂ {l u v} (hlu : Perm l u) (huv : Forall₂ r u v) : («expr ∘r » (Forall₂ r) Perm) l v :=\n  by\n  induction hlu generalizing v\n  case nil => cases huv; exact ⟨[], forall₂.nil, perm.nil⟩\n  case cons a l u hlu ih =>\n    cases' huv with _ b _ v hab huv'\n    rcases ih huv' with ⟨l₂, h₁₂, h₂₃⟩\n    exact ⟨b :: l₂, forall₂.cons hab h₁₂, h₂₃.cons _⟩\n  case swap a₁ a₂ l₁ l₂ h₂₃ =>\n    cases' h₂₃ with _ b₁ _ l₂ h₁ hr_₂₃\n    cases' hr_₂₃ with _ b₂ _ l₂ h₂ h₁₂\n    exact ⟨b₂ :: b₁ :: l₂, forall₂.cons h₂ (forall₂.cons h₁ h₁₂), perm.swap _ _ _⟩\n  case trans la₁ la₂ la₃ _ _ ih₁ ih₂ =>\n    rcases ih₂ huv with ⟨lb₂, hab₂, h₂₃⟩\n    rcases ih₁ hab₂ with ⟨lb₁, hab₁, h₁₂⟩\n    exact ⟨lb₁, hab₁, perm.trans h₁₂ h₂₃⟩\n#align perm_comp_forall₂ perm_comp_forall₂\n\n",
 "perm_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_comm {l₁ l₂ : List α} : list.perm l₁ l₂ ↔ list.perm l₂ l₁ :=\n  ⟨Perm.symm, Perm.symm⟩\n#align perm_comm perm_comm\n\n",
 "perm_append_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem perm_append_singleton (a : α) (l : List α) : list.perm (l ++ [a]) (a :: l) :=\n  perm_middle.trans <| by rw [append_nil]\n#align perm_append_singleton perm_append_singleton\n\n",
 "perm_append_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_append_right_iff {l₁ l₂ : List α} (l) : list.perm (l₁ ++ l) (l₂ ++ l) ↔ list.perm l₁ l₂ :=\n  ⟨fun p => (perm_append_left_iff _).1 <| perm_append_comm.trans <| p.trans perm_append_comm, Perm.append_right _⟩\n#align perm_append_right_iff perm_append_right_iff\n\n",
 "perm_append_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_append_left_iff {l₁ l₂ : List α} : ∀ l, list.perm (l ++ l₁) (l ++ l₂) ↔ list.perm l₁ l₂\n  | [] => iff.rfl\n  | a :: l => (perm_cons a).trans (perm_append_left_iff l)\n#align perm_append_left_iff perm_append_left_iff\n\n",
 "perm_append_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_append_comm : ∀ {l₁ l₂ : List α}, list.perm (l₁ ++ l₂) (l₂ ++ l₁)\n  | [], l₂ => by simp\n  | a :: t, l₂ => (perm_append_comm.cons _).trans perm_middle.symm\n#align perm_append_comm perm_append_comm\n\n",
 "perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem pairwise.perm {R : α → α → Prop} {l l' : List α} (hR : l.pairwise R) (hl : list.perm l l')\n    (hsymm : symmetric R) : l'.pairwise R :=\n  (hl.pairwise_iff hsymm).mp hR\n#align pairwise.perm pairwise.perm\n\n",
 "pairwise_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.pairwise_iff {R : α → α → Prop} (S : symmetric R) :\n    ∀ {l₁ l₂ : List α} (p : list.perm l₁ l₂), Pairwise R l₁ ↔ Pairwise R l₂ :=\n  suffices ∀ {l₁ l₂}, list.perm l₁ l₂ → Pairwise R l₁ → Pairwise R l₂ from fun l₁ l₂ p => ⟨this p, this p.symm⟩\n  fun l₁ l₂ p d => by\n  induction' d with a l₁ h d IH generalizing l₂\n  · rw [← p.nil_eq]\n    constructor\n  · have : a ∈ l₂ := p.subset (mem_cons_self _ _)\n    rcases mem_split this with ⟨s₂, t₂, rfl⟩\n    have p' := (p.trans perm_middle).cons_inv\n    refine' (pairwise_middle S).2 (pairwise_cons.2 ⟨fun b m => _, IH _ p'⟩)\n    exact h _ (p'.symm.subset m)\n#align perm.pairwise_iff perm.pairwise_iff\n\n",
 "pairwise":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.pairwise {R : α → α → Prop} {l l' : List α} (hl : list.perm l l') (hR : l.pairwise R)\n    (hsymm : symmetric R) : l'.pairwise R :=\n  hR.perm hl hsymm\n#align perm.pairwise perm.pairwise\n\n",
 "nth_le_permutations'_aux":
 "theorem nth_le_permutations'_aux (s : List α) (x : α) (n : ℕ) (hn : n < length (permutations'Aux x s)) :\n    (permutations'Aux x s).nth_le n hn = s.insert_nth n x :=\n  by\n  induction' s with y s IH generalizing n\n  · simp only [length, permutations'_aux, Nat.lt_one_iff] at hn\n    simp [hn]\n  · cases n\n    · simp\n    · simpa using IH _ _\n#align nth_le_permutations'_aux nth_le_permutations'_aux\n\n",
 "not_perm_nil_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem not_perm_nil_cons (x : α) (l : List α) : ¬list.perm [] (x :: l)\n  | p => by injection p.symm.eq_nil\n#align not_perm_nil_cons not_perm_nil_cons\n\n",
 "nodup_permutations'_aux_of_not_mem":
 "theorem nodup_permutations'_aux_of_not_mem (s : List α) (x : α) (hx : x ∉ s) : Nodup (permutations'Aux x s) :=\n  by\n  induction' s with y s IH\n  · simp\n  · simp only [not_or, mem_cons_iff] at hx\n    simp only [not_and, exists_eq_right_right, mem_map, permutations'_aux, nodup_cons]\n    refine' ⟨fun _ => ne.symm hx.left, _⟩\n    rw [nodup_map_iff]\n    · exact IH hx.right\n    · simp\n#align nodup_permutations'_aux_of_not_mem nodup_permutations'_aux_of_not_mem\n\n",
 "nodup_permutations'_aux_iff":
 "theorem nodup_permutations'_aux_iff {s : List α} {x : α} : Nodup (permutations'Aux x s) ↔ x ∉ s :=\n  by\n  refine' ⟨fun h => _, nodup_permutations'_aux_of_not_mem _ _⟩\n  intro H\n  obtain ⟨k, hk, hk'⟩ := nth_le_of_mem H\n  rw [nodup_iff_nth_le_inj] at h\n  suffices k = k + 1 by simpa using this\n  refine' h k (k + 1) _ _ _\n  · simpa [Nat.lt_succ_iff] using hk.le\n  · simpa using hk\n  rw [nth_le_permutations'_aux, nth_le_permutations'_aux]\n  have hl : length (insert_nth k x s) = length (insert_nth (k + 1) x s) := by\n    rw [length_insert_nth _ _ hk.le, length_insert_nth _ _ (nat.succ_le_of_lt hk)]\n  refine' ext_le hl fun n hn hn' => _\n  rcases lt_trichotomy n k with (H | rfl | H)\n  · rw [nth_le_insert_nth_of_lt _ _ _ _ H (H.trans hk), nth_le_insert_nth_of_lt _ _ _ _ (H.trans (nat.lt_succ_self _))]\n  · rw [nth_le_insert_nth_self _ _ _ hk.le, nth_le_insert_nth_of_lt _ _ _ _ (nat.lt_succ_self _) hk, hk']\n  · rcases(nat.succ_le_of_lt H).eq_or_lt with (rfl | H')\n    · rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)]\n      convert hk' using 1\n      convert nth_le_insert_nth_add_succ _ _ _ 0 _\n      simpa using hk\n    · obtain ⟨m, rfl⟩ := Nat.exists_eq_add_of_lt H'\n      rw [length_insert_nth _ _ hk.le, Nat.succ_lt_succ_iff, nat.succ_add] at hn\n      rw [nth_le_insert_nth_add_succ]\n      convert nth_le_insert_nth_add_succ s x k m.succ _ using 2\n      · simp [nat.add_succ, nat.succ_add]\n      · simp [add_left_comm, add_comm]\n      · simpa [nat.add_succ] using hn\n      · simpa [nat.succ_add] using hn\n#align nodup_permutations'_aux_iff nodup_permutations'_aux_iff\n\n",
 "nodup_permutations":
 "theorem nodup_permutations (s : List α) (hs : Nodup s) : Nodup s.permutations :=\n  by\n  rw [(permutations_perm_permutations' s).nodup_iff]\n  induction' hs with x l h h' IH\n  · simp\n  · rw [permutations']\n    rw [nodup_bind]\n    constructor\n    · intro ys hy\n      rw [mem_permutations'] at hy\n      rw [nodup_permutations'_aux_iff, hy.mem_iff]\n      exact fun H => h x H rfl\n    · refine' IH.pairwise_of_forall_ne fun as ha bs hb H => _\n      rw [disjoint_iff_ne]\n      rintro a ha' b hb' rfl\n      obtain ⟨n, hn, hn'⟩ := nth_le_of_mem ha'\n      obtain ⟨m, hm, hm'⟩ := nth_le_of_mem hb'\n      rw [mem_permutations'] at ha hb\n      have hl : as.length = bs.length := (ha.trans hb.symm).length_eq\n      simp only [Nat.lt_succ_iff, length_permutations'_aux] at hn hm\n      rw [nth_le_permutations'_aux] at hn' hm'\n      have hx : nth_le (insert_nth n x as) m (by rwa [length_insert_nth _ _ hn, Nat.lt_succ_iff, hl]) = x := by\n        simp [hn', ← hm', hm]\n      have hx' : nth_le (insert_nth m x bs) n (by rwa [length_insert_nth _ _ hm, Nat.lt_succ_iff, ← hl]) = x := by\n        simp [hm', ← hn', hn]\n      rcases lt_trichotomy n m with (ht | ht | ht)\n      · suffices x ∈ bs by exact h x (hb.subset this) rfl\n        rw [← hx', nth_le_insert_nth_of_lt _ _ _ _ ht (ht.trans_le hm)]\n        exact nth_le_mem _ _ _\n      · simp only [ht] at hm' hn'\n        rw [← hm'] at hn'\n        exact H (insert_nth_injective _ _ hn')\n      · suffices x ∈ as by exact h x (ha.subset this) rfl\n        rw [← hx, nth_le_insert_nth_of_lt _ _ _ _ ht (ht.trans_le hn)]\n        exact nth_le_mem _ _ _\n#align nodup_permutations nodup_permutations\n\n",
 "nodup_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.nodup_iff {l₁ l₂ : List α} : list.perm l₁ l₂ → (Nodup l₁ ↔ Nodup l₂) :=\n  Perm.pairwise_iff <| @ne.symm α\n#align perm.nodup_iff perm.nodup_iff\n\n",
 "nil_subperm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem nil_subperm {l : List α} : «expr <+~ » [] l :=\n  ⟨[], perm.nil, by simp⟩\n#align nil_subperm nil_subperm\n\n",
 "nil_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem nil_perm {l₁ : List α} : list.perm [] l₁ ↔ l₁ = [] :=\n  perm_comm.trans perm_nil\n#align nil_perm nil_perm\n\n",
 "nil_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.nil_eq {l : List α} (p : list.perm [] l) : [] = l :=\n  p.symm.eq_nil.symm\n#align perm.nil_eq perm.nil_eq\n\n",
 "mem_permutations_of_perm_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (ts' list.perm «expr[ ,]»([])) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem mem_permutations_of_perm_lemma {is l : List α}\n    (H : list.perm l ([] ++ is) → (∃ (ts' : _)(_ : list.perm ts' []), l = ts' ++ is) ∨ l ∈ permutationsAux is []) :\n    list.perm l is → l ∈ permutations is := by simpa [permutations, perm_nil] using H\n#align mem_permutations_of_perm_lemma mem_permutations_of_perm_lemma\n\n",
 "mem_permutations_aux_of_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (is' list.perm is) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem mem_permutations_aux_of_perm :\n    ∀ {ts is l : List α},\n      list.perm l (is ++ ts) → (∃ (is' : _)(_ : list.perm is' is), l = is' ++ ts) ∨ l ∈ permutationsAux ts is :=\n  by\n  refine' permutations_aux.rec (by simp) _\n  intro t ts is IH1 IH2 l p\n  rw [permutations_aux_cons, mem_foldr_permutations_aux2]\n  rcases IH1 (p.trans perm_middle) with (⟨is', p', e⟩ | m)\n  · clear p\n    subst e\n    rcases mem_split (p'.symm.subset (mem_cons_self _ _)) with ⟨l₁, l₂, e⟩\n    subst is'\n    have p := (perm_middle.symm.trans p').cons_inv\n    cases' l₂ with a l₂'\n    · exact or.inl ⟨l₁, by simpa using p⟩\n    · exact or.inr (or.inr ⟨l₁, a :: l₂', mem_permutations_of_perm_lemma IH2 p, by simp⟩)\n  · exact or.inr (or.inl m)\n#align mem_permutations_aux_of_perm mem_permutations_aux_of_perm\n\n",
 "mem_permutations'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem mem_permutations' {s t : List α} : s ∈ permutations' t ↔ list.perm s t :=\n  (permutations_perm_permutations' _).symm.mem_iff.trans mem_permutations\n#align mem_permutations' mem_permutations'\n\n",
 "mem_permutations":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem mem_permutations {s t : List α} : s ∈ permutations t ↔ list.perm s t :=\n  ⟨perm_of_mem_permutations, mem_permutations_of_perm_lemma mem_permutationsAux_of_perm⟩\n#align mem_permutations mem_permutations\n\n",
 "mem_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.mem_iff {a : α} {l₁ l₂ : List α} (h : list.perm l₁ l₂) : a ∈ l₁ ↔ a ∈ l₂ :=\n  iff.intro (fun m => h.subset m) fun m => h.symm.subset m\n#align perm.mem_iff perm.mem_iff\n\n",
 "map_append_bind_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem map_append_bind_perm (l : List α) (f : α → β) (g : α → List β) :\n    list.perm (l.map f ++ l.bind g) (l.bind fun x => f x :: g x) := by\n  simpa [← map_eq_bind] using bind_append_perm l (fun x => [f x]) g\n#align map_append_bind_perm map_append_bind_perm\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[congr]\ntheorem perm.map (f : α → β) {l₁ l₂ : List α} (p : list.perm l₁ l₂) : list.perm (map f l₁) (map f l₂) :=\n  filterMap_eq_map f ▸ p.filter_map _\n#align perm.map perm.map\n\n",
 "length_permutations_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem length_permutations_aux :\n    ∀ ts is : List α,\n      length (permutationsAux ts is) + nat.factorial is.length = nat.factorial (length ts + length is) :=\n  by\n  refine' permutations_aux.rec (by simp) _\n  intro t ts is IH1 IH2\n  have IH2 : length (permutations_aux is nil) + 1 = nat.factorial is.length := by simpa using IH2\n  simp [-add_comm, Nat.factorial, nat.add_succ, mul_comm] at IH1\n  rw [permutations_aux_cons,\n    length_foldr_permutations_aux2' _ _ _ _ _ fun l m => (perm_of_mem_permutations m).length_eq, permutations, length,\n    length, IH2, nat.succ_add, Nat.factorial_succ, mul_comm (nat.succ _), ← IH1, add_comm (_ * _), add_assoc,\n    nat.mul_succ, mul_comm]\n#align length_permutations_aux length_permutations_aux\n\n",
 "length_permutations'_aux":
 "@[simp]\ntheorem length_permutations'_aux (s : List α) (x : α) : length (permutations'Aux x s) = length s + 1 :=\n  by\n  induction' s with y s IH\n  · simp\n  · simpa using IH\n#align length_permutations'_aux length_permutations'_aux\n\n",
 "length_permutations":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem length_permutations (l : List α) : length (permutations l) = nat.factorial (length l) :=\n  length_permutationsAux l []\n#align length_permutations length_permutations\n\n",
 "length_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.length_le {l₁ l₂ : List α} : «expr <+~ » l₁ l₂ → length l₁ ≤ length l₂\n  | ⟨l, p, s⟩ => p.length_eq ▸ s.length_le\n#align subperm.length_le subperm.length_le\n\n",
 "length_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.length_eq {l₁ l₂ : List α} (p : list.perm l₁ l₂) : length l₁ = length l₂ :=\n  perm.rec_on p rfl (fun x l₁ l₂ p r => by simp [r]) (fun x y l => by simp) fun l₁ l₂ l₃ p₁ p₂ r₁ r₂ => Eq.trans r₁ r₂\n#align perm.length_eq perm.length_eq\n\n",
 "join_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.join_congr : ∀ {l₁ l₂ : List (List α)} (h : List.Forall₂ (list.perm · ·) l₁ l₂), list.perm l₁.join l₂.join\n  | _, _, forall₂.nil => Perm.refl _\n  | a :: as, b :: bs, forall₂.cons h₁ h₂ => h₁.append (perm.join_congr h₂)\n#align perm.join_congr perm.join_congr\n\n",
 "join":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.join {l₁ l₂ : List (List α)} (h : list.perm l₁ l₂) : list.perm l₁.join l₂.join :=\n  perm.rec_on h (Perm.refl _) (fun x xs₁ xs₂ hxs ih => ih.append_left x)\n    (fun x₁ x₂ xs => by simpa only [join, append_assoc] using perm_append_comm.append_right _)\n    fun xs₁ xs₂ xs₃ h₁₂ h₂₃ => perm.trans\n#align perm.join perm.join\n\n",
 "inter_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.inter_right {l₁ l₂ : List α} (t₁ : List α) : list.perm l₁ l₂ → list.perm (l₁ ∩ t₁) (l₂ ∩ t₁) :=\n  Perm.filter _\n#align perm.inter_right perm.inter_right\n\n",
 "inter_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.inter_left (l : List α) {t₁ t₂ : List α} (p : list.perm t₁ t₂) : l ∩ t₁ = l ∩ t₂ :=\n  filter_congr' fun a _ => p.mem_iff\n#align perm.inter_left perm.inter_left\n\n",
 "inter_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.inter_append {l t₁ t₂ : List α} (h : Disjoint t₁ t₂) : list.perm (l ∩ (t₁ ++ t₂)) (l ∩ t₁ ++ l ∩ t₂) :=\n  by\n  induction l\n  case nil => simp\n  case cons x xs l_ih =>\n    by_cases h₁ : x ∈ t₁\n    · have h₂ : x ∉ t₂ := h h₁\n      simp [*]\n    by_cases h₂ : x ∈ t₂\n    · simp only [*, inter_cons_of_not_mem, false_or_iff, mem_append, inter_cons_of_mem, not_false_iff]\n      trans\n      · apply perm.cons _ l_ih\n      change list.perm ([x] ++ xs ∩ t₁ ++ xs ∩ t₂) (xs ∩ t₁ ++ ([x] ++ xs ∩ t₂))\n      rw [← list.append_assoc]\n      solve_by_elim [perm.append_right, perm_append_comm]\n    · simp [*]\n#align perm.inter_append perm.inter_append\n\n",
 "inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n-- @[congr]\ntheorem perm.inter {l₁ l₂ t₁ t₂ : List α} (p₁ : list.perm l₁ l₂) (p₂ : list.perm t₁ t₂) :\n    list.perm (l₁ ∩ t₁) (l₂ ∩ t₂) :=\n  p₂.inter_left l₂ ▸ p₁.inter_right t₁\n#align perm.inter perm.inter\n\n",
 "insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n-- attribute [congr]\ntheorem perm.insert (a : α) {l₁ l₂ : List α} (p : list.perm l₁ l₂) : list.perm (insert a l₁) (insert a l₂) :=\n  if h : a ∈ l₁ then by simpa [h, p.subset h] using p else by simpa [h, mt p.mem_iff.2 h] using p.cons a\n#align perm.insert perm.insert\n\n",
 "injective_permutations'_aux":
 "theorem injective_permutations'_aux (x : α) : function.injective (permutations'Aux x) :=\n  by\n  intro s t h\n  apply insert_nth_injective s.length x\n  have hl : s.length = t.length := by simpa using congr_arg length h\n  rw [← nth_le_permutations'_aux s x s.length (by simp), ← nth_le_permutations'_aux t x s.length (by simp [hl])]\n  simp [h, hl]\n#align injective_permutations'_aux injective_permutations'_aux\n\n",
 "forall₂_comp_perm_eq_perm_comp_forall₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘r » -/\ntheorem forall₂_comp_perm_eq_perm_comp_forall₂ : «expr ∘r » (Forall₂ r) Perm = «expr ∘r » Perm (Forall₂ r) :=\n  by\n  funext l₁ l₃; apply propext\n  constructor\n  · intro h\n    rcases h with ⟨l₂, h₁₂, h₂₃⟩\n    have : forall₂ (flip r) l₂ l₁ := h₁₂.flip\n    rcases perm_comp_forall₂ h₂₃.symm this with ⟨l', h₁, h₂⟩\n    exact ⟨l', h₂.symm, h₁.flip⟩\n  · exact fun ⟨l₂, h₁₂, h₂₃⟩ => perm_comp_forall₂ h₁₂ h₂₃\n#align forall₂_comp_perm_eq_perm_comp_forall₂ forall₂_comp_perm_eq_perm_comp_forall₂\n\n",
 "foldr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.foldr_eq {f : α → β → β} {l₁ l₂ : List α} (lcomm : left_commutative f) (p : list.perm l₁ l₂) :\n    ∀ b, foldr f b l₁ = foldr f b l₂ :=\n  perm_induction_on p (fun b => rfl) (fun x t₁ t₂ p r b => by simp <;> rw [r b])\n    (fun x y t₁ t₂ p r b => by simp <;> rw [lcomm, r b]) fun t₁ t₂ t₃ p₁ p₂ r₁ r₂ a => Eq.trans (r₁ a) (r₂ a)\n#align perm.foldr_eq perm.foldr_eq\n\n",
 "foldl_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.foldl_eq' {f : β → α → β} {l₁ l₂ : List α} (p : list.perm l₁ l₂) :\n    (∀ x ∈ l₁, ∀ y ∈ l₁, ∀ (z), f (f z x) y = f (f z y) x) → ∀ b, foldl f b l₁ = foldl f b l₂ :=\n  perm_induction_on p (fun H b => rfl) (fun x t₁ t₂ p r H b => r (fun x hx y hy => H _ (or.inr hx) _ (or.inr hy)) _)\n    (fun x y t₁ t₂ p r H b => by\n      simp only [foldl]\n      rw [H x (or.inr <| or.inl rfl) y (or.inl rfl)]\n      exact r (fun x hx y hy => H _ (or.inr <| or.inr hx) _ (or.inr <| or.inr hy)) _)\n    fun t₁ t₂ t₃ p₁ p₂ r₁ r₂ H b =>\n    Eq.trans (r₁ H b) (r₂ (fun x hx y hy => H _ (p₁.symm.subset hx) _ (p₁.symm.subset hy)) b)\n#align perm.foldl_eq' perm.foldl_eq'\n\n",
 "foldl_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.foldl_eq {f : β → α → β} {l₁ l₂ : List α} (rcomm : right_commutative f) (p : list.perm l₁ l₂) :\n    ∀ b, foldl f b l₁ = foldl f b l₂ :=\n  p.foldl_eq' fun x hx y hy z => rcomm z x y\n#align perm.foldl_eq perm.foldl_eq\n\n",
 "fold_op_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `foldl -/\ntheorem perm.fold_op_eq {l₁ l₂ : List α} {a : α} (h : list.perm l₁ l₂) : foldl l₁ a = foldl l₂ a :=\n  h.foldl_eq (right_comm _ is_commutative.comm is_associative.assoc) _\n#align perm.fold_op_eq perm.fold_op_eq\n\n",
 "filter_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[congr]\ntheorem perm.filter_map (f : α → Option β) {l₁ l₂ : List α} (p : list.perm l₁ l₂) :\n    list.perm (filter_map f l₁) (filter_map f l₂) :=\n  by\n  induction' p with x l₂ l₂' p IH x y l₂ l₂ m₂ r₂ p₁ p₂ IH₁ IH₂\n  · simp\n  · simp only [filter_map]\n    cases' f x with a <;> simp [filter_map, IH, perm.cons]\n  · simp only [filter_map]\n    cases' f x with a <;> cases' f y with b <;> simp [filter_map, swap]\n  · exact IH₁.trans IH₂\n#align perm.filter_map perm.filter_map\n\n",
 "filter_append_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem filter_append_perm (p : α → Prop) [DecidablePred p] (l : List α) :\n    list.perm (filter p l ++ filter (fun x => ¬p x) l) l :=\n  by\n  induction' l with x l ih\n  · rfl\n  · by_cases h : p x\n    · simp only [h, filter_cons_of_pos, filter_cons_of_neg, not_true, not_false_iff, cons_append]\n      exact ih.cons x\n    · simp only [h, filter_cons_of_neg, not_false_iff, filter_cons_of_pos]\n      refine' perm.trans _ (ih.cons x)\n      exact perm_append_comm.trans (perm_append_comm.cons _)\n#align filter_append_perm filter_append_perm\n\n",
 "filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.filter (p : α → Prop) [DecidablePred p] ⦃l l' : List α⦄ (h : «expr <+~ » l l') :\n    «expr <+~ » (filter p l) (filter p l') := by\n  obtain ⟨xs, hp, h⟩ := h\n  exact ⟨_, hp.filter p, h.filter p⟩\n#align subperm.filter subperm.filter\n\n",
 "exists_perm_sublist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (l₁' list.perm l₁) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem exists_perm_sublist {l₁ l₂ l₂' : List α} (s : «expr <+ » l₁ l₂) (p : list.perm l₂ l₂') :\n    ∃ (l₁' : _)(_ : list.perm l₁' l₁), «expr <+ » l₁' l₂' :=\n  by\n  induction' p with x l₂ l₂' p IH x y l₂ l₂ m₂ r₂ p₁ p₂ IH₁ IH₂ generalizing l₁ s\n  · exact ⟨[], eq_nil_of_sublist_nil s ▸ perm.refl _, nil_sublist _⟩\n  · cases' s with _ _ _ s l₁ _ _ s\n    ·\n      exact\n        let ⟨l₁', p', s'⟩ := IH s\n        ⟨l₁', p', s'.cons _ _ _⟩\n    ·\n      exact\n        let ⟨l₁', p', s'⟩ := IH s\n        ⟨x :: l₁', p'.cons x, s'.cons2 _ _ _⟩\n  · cases' s with _ _ _ s l₁ _ _ s <;> cases' s with _ _ _ s l₁ _ _ s\n    · exact ⟨l₁, perm.refl _, (s.cons _ _ _).cons _ _ _⟩\n    · exact ⟨x :: l₁, perm.refl _, (s.cons _ _ _).cons2 _ _ _⟩\n    · exact ⟨y :: l₁, perm.refl _, (s.cons2 _ _ _).cons _ _ _⟩\n    · exact ⟨x :: y :: l₁, perm.swap _ _ _, (s.cons2 _ _ _).cons2 _ _ _⟩\n  ·\n    exact\n      let ⟨m₁, pm, sm⟩ := IH₁ s\n      let ⟨r₁, pr, sr⟩ := IH₂ sm\n      ⟨r₁, pr.trans pm, sr⟩\n#align exists_perm_sublist exists_perm_sublist\n\n",
 "exists_perm_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem sublist.exists_perm_append : ∀ {l₁ l₂ : List α}, «expr <+ » l₁ l₂ → ∃ l, list.perm l₂ (l₁ ++ l)\n  | _, _, sublist.slnil => ⟨nil, Perm.refl _⟩\n  | _, _, sublist.cons l₁ l₂ a s =>\n    let ⟨l, p⟩ := sublist.exists_perm_append s\n    ⟨a :: l, (p.cons a).trans perm_middle.symm⟩\n  | _, _, sublist.cons2 l₁ l₂ a s =>\n    let ⟨l, p⟩ := sublist.exists_perm_append s\n    ⟨l, p.cons a⟩\n#align sublist.exists_perm_append sublist.exists_perm_append\n\n",
 "exists_of_length_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.exists_of_length_lt {l₁ l₂ : List α} :\n    «expr <+~ » l₁ l₂ → length l₁ < length l₂ → ∃ a, «expr <+~ » (a :: l₁) l₂\n  | ⟨l, p, s⟩, h =>\n    by\n    suffices length l < length l₂ → ∃ a : α, «expr <+~ » (a :: l) l₂ from\n      (this <| p.symm.length_eq ▸ h).imp fun a => (p.cons a).subperm_right.1\n    clear subperm.exists_of_length_lt p h l₁; rename' l₂ => u\n    induction' s with l₁ l₂ a s IH _ _ b s IH <;> intro h\n    · cases h\n    · cases' lt_or_eq_of_le (nat.le_of_lt_succ h : length l₁ ≤ length l₂) with h h\n      · exact (IH h).imp fun a s => s.trans (sublist_cons _ _).subperm\n      · exact ⟨a, s.eq_of_length h ▸ subperm.refl _⟩\n    · exact (IH <| nat.lt_of_succ_lt_succ h).imp fun a s => (swap _ _ _).subperm_right.1 <| (subperm_cons _).2 s\n#align subperm.exists_of_length_lt subperm.exists_of_length_lt\n\n",
 "erasep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.erasep (f : α → Prop) [DecidablePred f] {l₁ l₂ : List α} (H : Pairwise (fun a b => f a → f b → False) l₁)\n    (p : list.perm l₁ l₂) : list.perm (eraseP f l₁) (eraseP f l₂) :=\n  by\n  let F a b := f a → f b → False\n  change Pairwise F l₁ at H\n  induction' p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ p₂ IH₁ IH₂; · simp\n  · by_cases h : f a\n    · simp [h, p]\n    · simp [h]\n      exact IH (pairwise_cons.1 H).2\n  · by_cases h₁ : f a <;> by_cases h₂ : f b <;> simp [h₁, h₂]\n    · cases (pairwise_cons.1 H).1 _ (or.inl rfl) h₂ h₁\n    · apply swap\n  · refine' (IH₁ H).trans (IH₂ ((p₁.pairwise_iff _).1 H))\n    exact fun a b h h₁ h₂ => h h₂ h₁\n#align perm.erasep perm.erasep\n\n",
 "erase_subperm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem erase_subperm (a : α) (l : List α) : «expr <+~ » (l.erase a) l :=\n  (erase_sublist _ _).subperm\n#align erase_subperm erase_subperm\n\n",
 "erase_cons_subperm_cons_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem erase_cons_subperm_cons_erase (a b : α) (l : List α) : «expr <+~ » ((a :: l).erase b) (a :: l.erase b) :=\n  by\n  by_cases h : a = b\n  · subst b\n    rw [erase_cons_head]\n    apply subperm_cons_erase\n  · rw [erase_cons_tail _ h]\n#align erase_cons_subperm_cons_erase erase_cons_subperm_cons_erase\n\n",
 "erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.erase {l₁ l₂ : List α} (a : α) (h : «expr <+~ » l₁ l₂) : «expr <+~ » (l₁.erase a) (l₂.erase a) :=\n  let ⟨l, hp, hs⟩ := h\n  ⟨l.erase a, hp.erase _, hs.erase _⟩\n#align subperm.erase subperm.erase\n\n",
 "eqv":
 "theorem perm.eqv (α) : equivalence (@Perm α) :=\n  Equivalence.mk (@Perm α) (@Perm.refl α) (@Perm.symm α) (@perm.trans α)\n#align perm.eqv perm.eqv\n\n",
 "eq_nil":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.eq_nil {l : List α} (p : list.perm l []) : l = [] :=\n  eq_nil_of_length_eq_zero p.length_eq\n#align perm.eq_nil perm.eq_nil\n\n",
 "drop_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.drop_inter {α} [DecidableEq α] {xs ys : List α} (n : ℕ) (h : list.perm xs ys) (h' : ys.nodup) :\n    list.perm (xs.drop n) (ys.inter (xs.drop n)) :=\n  by\n  by_cases h'' : n ≤ xs.length\n  · let n' := xs.length - n\n    have h₀ : n = xs.length - n' := by\n      dsimp [n']\n      rwa [tsub_tsub_cancel_of_le]\n    have h₁ : n' ≤ xs.length := by apply tsub_le_self\n    have h₂ : xs.drop n = (xs.reverse.take n').reverse := by rw [reverse_take _ h₁, h₀, reverse_reverse]\n    rw [h₂]\n    apply (reverse_perm _).trans\n    rw [inter_reverse]\n    apply perm.take_inter _ _ h'\n    apply (reverse_perm _).trans <;> assumption\n  · have : drop n xs = [] := by\n      apply eq_nil_of_length_eq_zero\n      rw [length_drop, tsub_eq_zero_iff_le]\n      apply le_of_not_ge h''\n    simp [this, list.inter]\n#align perm.drop_inter perm.drop_inter\n\n",
 "diff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.diff_right {l₁ l₂ : List α} (h : «expr <+~ » l₁ l₂) (t : List α) :\n    «expr <+~ » (l₁.diff t) (l₂.diff t) := by induction t generalizing l₁ l₂ h <;> simp [*, subperm.erase]\n#align subperm.diff_right subperm.diff_right\n\n",
 "diff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.diff_left (l : List α) {t₁ t₂ : List α} (h : list.perm t₁ t₂) : l.diff t₁ = l.diff t₂ := by\n  induction h generalizing l <;> first |simp [*, perm.erase, erase_comm]|exact (ih_1 _).trans (ih_2 _)\n#align perm.diff_left perm.diff_left\n\n",
 "diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.diff {l₁ l₂ t₁ t₂ : List α} (hl : list.perm l₁ l₂) (ht : list.perm t₁ t₂) :\n    list.perm (l₁.diff t₁) (l₂.diff t₂) :=\n  ht.diff_left l₂ ▸ hl.diff_right _\n#align perm.diff perm.diff\n\n",
 "dedup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n-- @[congr]\ntheorem perm.dedup {l₁ l₂ : List α} (p : list.perm l₁ l₂) : list.perm (dedup l₁) (dedup l₂) :=\n  perm_iff_count.2 fun a => if h : a ∈ l₁ then by simp [nodup_dedup, h, p.subset h] else by simp [h, mt p.mem_iff.2 h]\n#align perm.dedup perm.dedup\n\n",
 "countp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.countp_le (p : α → Prop) [DecidablePred p] {l₁ l₂ : List α} :\n    «expr <+~ » l₁ l₂ → countp p l₁ ≤ countp p l₂\n  | ⟨l, p', s⟩ => p'.countp_eq p ▸ s.countp_le p\n#align subperm.countp_le subperm.countp_le\n\n",
 "countp_eq_countp_filter_add":
 "theorem countp_eq_countp_filter_add (l : List α) (p q : α → Prop) [DecidablePred p] [DecidablePred q] :\n    l.countp p = (l.filter q).countp p + (l.filter fun a => ¬q a).countp p :=\n  by\n  rw [← countp_append]\n  exact perm.countp_eq _ (filter_append_perm _ _).symm\n#align countp_eq_countp_filter_add countp_eq_countp_filter_add\n\n",
 "countp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.countp_eq (p : α → Prop) [DecidablePred p] {l₁ l₂ : List α} (s : list.perm l₁ l₂) :\n    countp p l₁ = countp p l₂ := by\n  rw [countp_eq_length_filter, countp_eq_length_filter] <;> exact (s.filter _).length_eq\n#align perm.countp_eq perm.countp_eq\n\n",
 "countp_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.countp_congr (s : list.perm l₁ l₂) {p p' : α → Prop} [DecidablePred p] [DecidablePred p']\n    (hp : ∀ x ∈ l₁, p x = p' x) : l₁.countp p = l₂.countp p' :=\n  by\n  rw [← s.countp_eq p']\n  clear s\n  induction' l₁ with y s hs\n  · rfl\n  · simp only [mem_cons_iff, forall_eq_or_imp] at hp\n    simp only [countp_cons, hs hp.2, hp.1]\n#align perm.countp_congr perm.countp_congr\n\n",
 "count_permutations'_aux_self":
 "theorem count_permutations'_aux_self [DecidableEq α] (l : List α) (x : α) :\n    count (x :: l) (permutations'Aux x l) = length (takeWhile ((· = ·) x) l) + 1 :=\n  by\n  induction' l with y l IH generalizing x\n  · simp [take_while]\n  · rw [permutations'_aux, count_cons_self]\n    by_cases hx : x = y\n    · subst hx\n      simpa [take_while, Nat.succ_inj'] using IH _\n    · rw [take_while]\n      rw [if_neg hx]\n      cases' permutations'_aux x l with a as\n      · simp\n      · rw [count_eq_zero_of_not_mem, length, zero_add]\n        simp [hx, ne.symm hx]\n#align count_permutations'_aux_self count_permutations'_aux_self\n\n",
 "count_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.count_le [DecidableEq α] {l₁ l₂ : List α} (s : «expr <+~ » l₁ l₂) (a) : count a l₁ ≤ count a l₂ :=\n  s.countp_le _\n#align subperm.count_le subperm.count_le\n\n",
 "count_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.count_eq [DecidableEq α] {l₁ l₂ : List α} (p : list.perm l₁ l₂) (a) : count a l₁ = count a l₂ :=\n  p.countp_eq _\n#align perm.count_eq perm.count_eq\n\n",
 "cons_subperm_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem cons_subperm_of_mem {a : α} {l₁ l₂ : List α} (d₁ : Nodup l₁) (h₁ : a ∉ l₁) (h₂ : a ∈ l₂)\n    (s : «expr <+~ » l₁ l₂) : «expr <+~ » (a :: l₁) l₂ :=\n  by\n  rcases s with ⟨l, p, s⟩\n  induction s generalizing l₁\n  case slnil => cases h₂\n  case cons r₁ r₂ b s' ih =>\n    simp at h₂\n    cases' h₂ with e m\n    · subst b\n      exact ⟨a :: r₁, p.cons a, s'.cons2 _ _ _⟩\n    · rcases ih m d₁ h₁ p with ⟨t, p', s'⟩\n      exact ⟨t, p', s'.cons _ _ _⟩\n  case cons2 r₁ r₂ b s' ih =>\n    have bm : b ∈ l₁ := p.subset <| mem_cons_self _ _\n    have am : a ∈ r₂ := h₂.resolve_left fun e => h₁ <| e.symm ▸ bm\n    rcases mem_split bm with ⟨t₁, t₂, rfl⟩\n    have st : «expr <+ » (t₁ ++ t₂) (t₁ ++ b :: t₂) := by simp\n    rcases ih am (d₁.sublist st) (mt (fun x => st.subset x) h₁) (perm.cons_inv <| p.trans perm_middle) with ⟨t, p', s'⟩\n    exact ⟨b :: t, (p'.cons b).trans <| (swap _ _ _).trans (perm_middle.symm.cons a), s'.cons2 _ _ _⟩\n#align cons_subperm_of_mem cons_subperm_of_mem\n\n",
 "cons_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.cons_right {α : Type _} {l l' : List α} (x : α) (h : «expr <+~ » l l') : «expr <+~ » l (x :: l') :=\n  h.trans (sublist_cons x l').subperm\n#align subperm.cons_right subperm.cons_right\n\n",
 "cons_perm_iff_perm_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem cons_perm_iff_perm_erase {a : α} {l₁ l₂ : List α} :\n    list.perm (a :: l₁) l₂ ↔ a ∈ l₂ ∧ list.perm l₁ (l₂.erase a) :=\n  ⟨fun h =>\n    have : a ∈ l₂ := h.subset (mem_cons_self a l₁)\n    ⟨this, (h.trans <| perm_cons_erase this).cons_inv⟩,\n    fun ⟨m, h⟩ => (h.cons a).trans (perm_cons_erase m).symm⟩\n#align cons_perm_iff_perm_erase cons_perm_iff_perm_erase\n\n",
 "cons_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\ntheorem subperm.cons_left {l₁ l₂ : List α} (h : «expr <+~ » l₁ l₂) (x : α) (hx : count x l₁ < count x l₂) :\n    «expr <+~ » (x :: l₁) l₂ := by\n  rw [subperm_ext_iff] at h⊢\n  intro y hy\n  by_cases hy' : y = x\n  · subst x\n    simpa using nat.succ_le_of_lt hx\n  · rw [count_cons_of_ne hy']\n    refine' h y _\n    simpa [hy'] using hy\n#align subperm.cons_left subperm.cons_left\n\n",
 "cons_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.cons_inv {a : α} {l₁ l₂ : List α} : list.perm (a :: l₁) (a :: l₂) → list.perm l₁ l₂ :=\n  @perm_inv_core _ _ [] [] _ _\n#align perm.cons_inv perm.cons_inv\n\n",
 "concat_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem concat_perm (l : List α) (a : α) : list.perm (concat l a) (a :: l) := by simp\n#align concat_perm concat_perm\n\n",
 "bind_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.bind_right {l₁ l₂ : List α} (f : α → List β) (p : list.perm l₁ l₂) : list.perm (l₁.bind f) (l₂.bind f) :=\n  (p.map _).join\n#align perm.bind_right perm.bind_right\n\n",
 "bind_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.bind_left (l : List α) {f g : α → List β} (h : ∀ a ∈ l, list.perm (f a) (g a)) :\n    list.perm (l.bind f) (l.bind g) :=\n  Perm.join_congr <| by rwa [List.forall₂_map_right_iff, List.forall₂_map_left_iff, List.forall₂_same]\n#align perm.bind_left perm.bind_left\n\n",
 "bind_append_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem bind_append_perm (l : List α) (f g : α → List β) :\n    list.perm (l.bind f ++ l.bind g) (l.bind fun x => f x ++ g x) :=\n  by\n  induction' l with a l IH <;> simp\n  refine' (perm.trans _ (IH.append_left _)).append_left _\n  rw [← append_assoc, ← append_assoc]\n  exact perm_append_comm.append_right _\n#align bind_append_perm bind_append_perm\n\n",
 "bag_inter_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.bag_inter_right {l₁ l₂ : List α} (t : List α) (h : list.perm l₁ l₂) :\n    list.perm (l₁.bag_inter t) (l₂.bag_inter t) :=\n  by\n  induction' h with x _ _ _ _ x y _ _ _ _ _ _ ih_1 ih_2 generalizing t; · simp\n  · by_cases x ∈ t <;> simp [*, perm.cons]\n  · by_cases x = y\n    · simp [h]\n    by_cases xt : x ∈ t <;> by_cases yt : y ∈ t\n    · simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap]\n    · simp [xt, yt, mt mem_of_mem_erase, perm.cons]\n    · simp [xt, yt, mt mem_of_mem_erase, perm.cons]\n    · simp [xt, yt]\n  · exact (ih_1 _).trans (ih_2 _)\n#align perm.bag_inter_right perm.bag_inter_right\n\n",
 "bag_inter_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.bag_inter_left (l : List α) {t₁ t₂ : List α} (p : list.perm t₁ t₂) : l.bag_inter t₁ = l.bag_inter t₂ :=\n  by\n  induction' l with a l IH generalizing t₁ t₂ p; · simp\n  by_cases a ∈ t₁\n  · simp [h, p.subset h, IH (p.erase _)]\n  · simp [h, mt p.mem_iff.2 h, IH p]\n#align perm.bag_inter_left perm.bag_inter_left\n\n",
 "bag_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.bag_inter {l₁ l₂ t₁ t₂ : List α} (hl : list.perm l₁ l₂) (ht : list.perm t₁ t₂) :\n    list.perm (l₁.bag_inter t₁) (l₂.bag_inter t₂) :=\n  ht.bag_inter_left l₂ ▸ hl.bag_inter_right _\n#align perm.bag_inter perm.bag_inter\n\n",
 "append_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.append_right {l₁ l₂ : List α} (t₁ : List α) (p : list.perm l₁ l₂) : list.perm (l₁ ++ t₁) (l₂ ++ t₁) :=\n  perm.rec_on p (Perm.refl ([] ++ t₁)) (fun x l₁ l₂ p₁ r₁ => r₁.cons x) (fun x y l => swap x y _)\n    fun l₁ l₂ l₃ p₁ p₂ r₁ r₂ => r₁.trans r₂\n#align perm.append_right perm.append_right\n\n",
 "append_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.append_left {t₁ t₂ : List α} : ∀ l : List α, list.perm t₁ t₂ → list.perm (l ++ t₁) (l ++ t₂)\n  | [], p => p\n  | x :: xs, p => (perm.append_left xs p).cons x\n#align perm.append_left perm.append_left\n\n",
 "append_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.append_cons (a : α) {h₁ h₂ t₁ t₂ : List α} (p₁ : list.perm h₁ h₂) (p₂ : list.perm t₁ t₂) :\n    list.perm (h₁ ++ a :: t₁) (h₂ ++ a :: t₂) :=\n  p₁.append (p₂.cons a)\n#align perm.append_cons perm.append_cons\n\n",
 "append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm.append {l₁ l₂ t₁ t₂ : List α} (p₁ : list.perm l₁ l₂) (p₂ : list.perm t₁ t₂) :\n    list.perm (l₁ ++ t₁) (l₂ ++ t₂) :=\n  (p₁.append_right t₁).trans (p₂.append_left l₂)\n#align perm.append perm.append\n\n",
 "antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem subperm.antisymm {l₁ l₂ : List α} (h₁ : «expr <+~ » l₁ l₂) (h₂ : «expr <+~ » l₂ l₁) : list.perm l₁ l₂ :=\n  h₁.perm_of_length_le h₂.length_le\n#align subperm.antisymm subperm.antisymm\n\n"}