{"nodup_antidiagonal":
 "/-- The antidiagonal of `n` does not contain duplicate entries. -/\ntheorem nodup_antidiagonal (n : ℕ) : Nodup (antidiagonal n) :=\n  (nodup_range _).map (@left_inverse.injective ℕ (ℕ × ℕ) Prod.fst (fun i => (i, n - i)) fun i => rfl)\n#align nodup_antidiagonal nodup_antidiagonal\n\n",
 "mem_antidiagonal":
 "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n/-- A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. -/\n@[simp]\ntheorem mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ antidiagonal n ↔ x.1 + x.2 = n :=\n  by\n  rw [antidiagonal, mem_map]; constructor\n  · rintro ⟨i, hi, rfl⟩\n    rw [mem_range, lt_succ_iff] at hi\n    exact add_tsub_cancel_of_le hi\n  · rintro rfl\n    refine' ⟨x.fst, _, _⟩\n    · rw [mem_range, add_assoc, lt_add_iff_pos_right]\n      exact zero_lt_succ _\n    · exact Prod.ext rfl (add_tsub_cancel_left _ _)\n#align mem_antidiagonal mem_antidiagonal\n\n",
 "map_swap_antidiagonal":
 "theorem map_swap_antidiagonal {n : ℕ} : (antidiagonal n).map Prod.swap = (antidiagonal n).reverse :=\n  by\n  rw [antidiagonal, map_map, Prod.swap, ← List.map_reverse, range_eq_range', reverse_range', ← range_eq_range', map_map]\n  apply map_congr\n  simp (config := { contextual := true }) [nat.sub_sub_self, lt_succ_iff]\n#align map_swap_antidiagonal map_swap_antidiagonal\n\n",
 "length_antidiagonal":
 "/-- The length of the antidiagonal of `n` is `n + 1`. -/\n@[simp]\ntheorem length_antidiagonal (n : ℕ) : (antidiagonal n).length = n + 1 := by rw [antidiagonal, length_map, length_range]\n#align length_antidiagonal length_antidiagonal\n\n",
 "antidiagonal_zero":
 "/-- The antidiagonal of `0` is the list `[(0, 0)]` -/\n@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = [(0, 0)] :=\n  rfl\n#align antidiagonal_zero antidiagonal_zero\n\n",
 "antidiagonal_succ_succ'":
 "theorem antidiagonal_succ_succ' {n : ℕ} :\n    antidiagonal (n + 2) = (0, n + 2) :: (antidiagonal n).map (prod.map nat.succ nat.succ) ++ [(n + 2, 0)] :=\n  by\n  rw [antidiagonal_succ']\n  simpa\n#align antidiagonal_succ_succ' antidiagonal_succ_succ'\n\n",
 "antidiagonal_succ'":
 "theorem antidiagonal_succ' {n : ℕ} :\n    antidiagonal (n + 1) = (antidiagonal n).map (prod.map id nat.succ) ++ [(n + 1, 0)] :=\n  by\n  simp only [antidiagonal, range_succ, add_tsub_cancel_left, map_append, append_assoc, tsub_self, singleton_append,\n    map_map, map]\n  congr 1\n  apply map_congr\n  simp (config := { contextual := true }) [le_of_lt, nat.succ_eq_add_one, nat.sub_add_comm]\n#align antidiagonal_succ' antidiagonal_succ'\n\n",
 "antidiagonal_succ":
 "@[simp]\ntheorem antidiagonal_succ {n : ℕ} : antidiagonal (n + 1) = (0, n + 1) :: (antidiagonal n).map (prod.map nat.succ id) :=\n  by\n  simp only [antidiagonal, range_succ_eq_map, map_cons, true_and_iff, Nat.add_succ_sub_one, add_zero, id.def,\n    eq_self_iff_true, tsub_zero, map_map, Prod.map_mk]\n  apply congr (congr rfl _) rfl\n  ext <;> simp\n#align antidiagonal_succ antidiagonal_succ\n\n"}