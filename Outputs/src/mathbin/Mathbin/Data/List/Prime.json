{"perm_of_prod_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n#print perm_of_prod_eq_prod /-\ntheorem perm_of_prod_eq_prod :\n    ∀ {l₁ l₂ : List M}, l₁.prod = l₂.prod → (∀ p ∈ l₁, Prime p) → (∀ p ∈ l₂, Prime p) → Perm l₁ l₂\n  | [], [], _, _, _ => perm.nil\n  | [], a :: l, h₁, h₂, h₃ =>\n    have ha : a ∣ 1 := @prod_nil M _ ▸ h₁.symm ▸ (@prod_cons _ _ l a).symm ▸ dvd_mul_right _ _\n    absurd ha (Prime.not_dvd_one (h₃ a (mem_cons_self _ _)))\n  | a :: l, [], h₁, h₂, h₃ =>\n    have ha : a ∣ 1 := @prod_nil M _ ▸ h₁ ▸ (@prod_cons _ _ l a).symm ▸ dvd_mul_right _ _\n    absurd ha (Prime.not_dvd_one (h₂ a (mem_cons_self _ _)))\n  | a :: l₁, b :: l₂, h, hl₁, hl₂ => by\n    classical\n      have hl₁' : ∀ p ∈ l₁, Prime p := fun p hp => hl₁ p (mem_cons_of_mem _ hp)\n      have hl₂' : ∀ p ∈ (b :: l₂).erase a, Prime p := fun p hp => hl₂ p (mem_of_mem_erase hp)\n      have ha : a ∈ b :: l₂ :=\n        mem_list_primes_of_dvd_prod (hl₁ a (mem_cons_self _ _)) hl₂ (h ▸ by rw [prod_cons] <;> exact dvd_mul_right _ _)\n      have hb : list.perm (b :: l₂) (a :: (b :: l₂).erase a) := perm_cons_erase ha\n      have hl : Prod l₁ = Prod ((b :: l₂).erase a) :=\n        (mul_right_inj' (hl₁ a (mem_cons_self _ _)).ne_zero).1 <| by rwa [← prod_cons, ← prod_cons, ← hb.prod_eq]\n      exact perm.trans ((perm_of_prod_eq_prod hl hl₁' hl₂').cons _) hb.symm\n#align perm_of_prod_eq_prod perm_of_prod_eq_prod\n-/\n\n",
 "not_dvd_prod":
 "#print Prime.not_dvd_prod /-\ntheorem Prime.not_dvd_prod {p : M} {L : List M} (pp : Prime p) (hL : ∀ a ∈ L, ¬p ∣ a) : ¬p ∣ L.prod :=\n  mt (Prime.dvd_prod_iff pp).mp <| not_bex.mpr hL\n#align prime.not_dvd_prod Prime.not_dvd_prod\n-/\n\n",
 "mem_list_primes_of_dvd_prod":
 "#print mem_list_primes_of_dvd_prod /-\ntheorem mem_list_primes_of_dvd_prod {p : M} (hp : Prime p) {L : List M} (hL : ∀ q ∈ L, Prime q) (hpL : p ∣ L.prod) :\n    p ∈ L := by\n  obtain ⟨x, hx1, hx2⟩ := hp.dvd_prod_iff.mp hpL\n  rwa [(prime_dvd_prime_iff_eq hp (hL x hx1)).mp hx2]\n#align mem_list_primes_of_dvd_prod mem_list_primes_of_dvd_prod\n-/\n\n",
 "dvd_prod_iff":
 "#print Prime.dvd_prod_iff /-\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Jens Wagemaker, Anne Baanen\n-/\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` -/\ntheorem Prime.dvd_prod_iff {p : M} {L : List M} (pp : Prime p) : p ∣ L.prod ↔ ∃ a ∈ L, p ∣ a :=\n  by\n  constructor\n  · intro h\n    induction' L with L_hd L_tl L_ih\n    · rw [prod_nil] at h\n      exact absurd h pp.not_dvd_one\n    · rw [prod_cons] at h\n      cases' pp.dvd_or_dvd h with hd hd\n      · exact ⟨L_hd, mem_cons_self L_hd L_tl, hd⟩\n      · obtain ⟨x, hx1, hx2⟩ := L_ih hd\n        exact ⟨x, mem_cons_of_mem L_hd hx1, hx2⟩\n  · exact fun ⟨a, ha1, ha2⟩ => dvd_trans ha2 (dvd_prod ha1)\n#align prime.dvd_prod_iff Prime.dvd_prod_iff\n-/\n\n"}