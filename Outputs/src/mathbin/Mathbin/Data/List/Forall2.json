{"tail_sublist_forall₂_self":
 "theorem tail_sublist_forall₂_self [is_refl α Rₐ] (l : list α) : SublistForall₂ Rₐ l.tail l :=\n  l.tail_sublist.sublist_forall₂\n#align tail_sublist_forall₂_self tail_sublist_forall₂_self\n\n",
 "sublist_forall₂_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_forall₂_iff {l₁ : list α} {l₂ : list β} :\n    SublistForall₂ R l₁ l₂ ↔ ∃ l, Forall₂ R l₁ l ∧ «expr <+ » l l₂ :=\n  by\n  constructor <;> intro h\n  · induction' h with _ a b l1 l2 rab rll ih b l1 l2 hl ih\n    · exact ⟨nil, forall₂.nil, nil_sublist _⟩\n    · obtain ⟨l, hl1, hl2⟩ := ih\n      refine' ⟨b :: l, forall₂.cons rab hl1, hl2.cons_cons b⟩\n    · obtain ⟨l, hl1, hl2⟩ := ih\n      exact ⟨l, hl1, hl2.trans (sublist.cons _ _ _ (sublist.refl _))⟩\n  · obtain ⟨l, hl1, hl2⟩ := h\n    revert l₁\n    induction' hl2 with _ _ _ _ ih _ _ _ _ ih <;> intro l₁ hl1\n    · rw [forall₂_nil_right_iff.1 hl1]\n      exact sublist_forall₂.nil\n    · exact sublist_forall₂.cons_right (ih hl1)\n    · cases' hl1 with _ _ _ _ hr hl _\n      exact sublist_forall₂.cons hr (ih hl)\n#align sublist_forall₂_iff sublist_forall₂_iff\n\n",
 "sublist_forall₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist.sublist_forall₂ {l₁ l₂ : list α} (h : «expr <+ » l₁ l₂) [is_refl α Rₐ] : SublistForall₂ Rₐ l₁ l₂ :=\n  sublistForall₂_iff.2 ⟨l₁, forall₂_refl l₁, h⟩\n#align sublist.sublist_forall₂ sublist.sublist_forall₂\n\n",
 "right_unique_forall₂'":
 "theorem right_unique_forall₂' (hr : right_unique R) : ∀ {a b c}, Forall₂ R a b → Forall₂ R a c → b = c\n  | nil, a₀, a₁, forall₂.nil, forall₂.nil => rfl\n  | b :: l, a₀ :: l₀, a₁ :: l₁, forall₂.cons ha₀ h₀, forall₂.cons ha₁ h₁ =>\n    hr ha₀ ha₁ ▸ right_unique_forall₂' h₀ h₁ ▸ rfl\n#align right_unique_forall₂' right_unique_forall₂'\n\n",
 "rel_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_reverse : («expr ⇒ » (Forall₂ R) (Forall₂ R)) reverse reverse\n  | [], [], forall₂.nil => Forall₂.nil\n  | a :: as, b :: bs, forall₂.cons h₁ h₂ => by\n    simp only [reverse_cons]\n    exact rel_append (rel_reverse h₂) (forall₂.cons h₁ forall₂.nil)\n#align rel_reverse rel_reverse\n\n",
 "rel_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n@[to_additive]\ntheorem rel_prod [monoid α] [monoid β] (h : R 1 1) (hf : («expr ⇒ » R («expr ⇒ » R R)) (· * ·) (· * ·)) :\n    («expr ⇒ » (Forall₂ R) R) prod prod :=\n  rel_foldl hf h\n#align rel_prod rel_prod\n\n",
 "rel_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_mem (hr : bi_unique R) : («expr ⇒ » R («expr ⇒ » (Forall₂ R) iff)) (· ∈ ·) (· ∈ ·)\n  | a, b, h, [], [], forall₂.nil => by simp only [not_mem_nil]\n  | a, b, h, a' :: as, b' :: bs, forall₂.cons h₁ h₂ => rel_or (rel_eq hr h h₁) (rel_mem h h₂)\n#align rel_mem rel_mem\n\n",
 "rel_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_map : («expr ⇒ » («expr ⇒ » R P) («expr ⇒ » (Forall₂ R) (Forall₂ P))) map map\n  | f, g, h, [], [], forall₂.nil => Forall₂.nil\n  | f, g, h, a :: as, b :: bs, forall₂.cons h₁ h₂ => Forall₂.cons (h h₁) (rel_map (@h) h₂)\n#align rel_map rel_map\n\n",
 "rel_join":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_join : («expr ⇒ » (Forall₂ (Forall₂ R)) (Forall₂ R)) join join\n  | [], [], forall₂.nil => Forall₂.nil\n  | a :: as, b :: bs, forall₂.cons h₁ h₂ => rel_append h₁ (rel_join h₂)\n#align rel_join rel_join\n\n",
 "rel_foldr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_foldr : («expr ⇒ » («expr ⇒ » R («expr ⇒ » P P)) («expr ⇒ » P («expr ⇒ » (Forall₂ R) P))) foldr foldr\n  | f, g, hfg, _, _, h, _, _, forall₂.nil => h\n  | f, g, hfg, x, y, hxy, _, _, forall₂.cons hab hs => hfg hab (rel_foldr (@hfg) hxy hs)\n#align rel_foldr rel_foldr\n\n",
 "rel_foldl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_foldl : («expr ⇒ » («expr ⇒ » P («expr ⇒ » R P)) («expr ⇒ » P («expr ⇒ » (Forall₂ R) P))) foldl foldl\n  | f, g, hfg, _, _, h, _, _, forall₂.nil => h\n  | f, g, hfg, x, y, hxy, _, _, forall₂.cons hab hs => rel_foldl (@hfg) (hfg hxy hab) hs\n#align rel_foldl rel_foldl\n\n",
 "rel_filter_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_filter_map :\n    («expr ⇒ » («expr ⇒ » R (option.rel P)) («expr ⇒ » (Forall₂ R) (Forall₂ P))) filter_map filter_map\n  | f, g, hfg, _, _, forall₂.nil => Forall₂.nil\n  | f, g, hfg, a :: as, b :: bs, forall₂.cons h₁ h₂ => by\n    rw [filter_map_cons, filter_map_cons] <;>\n      exact\n        match f a, g b, hfg h₁ with\n        | _, _, option.rel.none => rel_filter_map (@hfg) h₂\n        | _, _, option.rel.some h => forall₂.cons h (rel_filter_map (@hfg) h₂)\n#align rel_filter_map rel_filter_map\n\n",
 "rel_filter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_filter {p : α → Prop} {q : β → Prop} [decidable_pred p] [decidable_pred q]\n    (hpq : («expr ⇒ » R (· ↔ ·)) p q) : («expr ⇒ » (Forall₂ R) (Forall₂ R)) (filter p) (filter q)\n  | _, _, forall₂.nil => Forall₂.nil\n  | a :: as, b :: bs, forall₂.cons h₁ h₂ => by\n    by_cases p a\n    · have : q b := by rwa [← hpq h₁]\n      simp only [filter_cons_of_pos _ h, filter_cons_of_pos _ this, forall₂_cons, h₁, rel_filter h₂, and_true_iff]\n    · have : ¬q b := by rwa [← hpq h₁]\n      simp only [filter_cons_of_neg _ h, filter_cons_of_neg _ this, rel_filter h₂]\n#align rel_filter rel_filter\n\n",
 "rel_bind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_bind : («expr ⇒ » (Forall₂ R) («expr ⇒ » («expr ⇒ » R (Forall₂ P)) (Forall₂ P))) list.bind list.bind :=\n  fun a b h₁ f g h₂ => rel_join (rel_map (@h₂) h₁)\n#align rel_bind rel_bind\n\n",
 "rel_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⇒ » -/\ntheorem rel_append : («expr ⇒ » (Forall₂ R) («expr ⇒ » (Forall₂ R) (Forall₂ R))) append append\n  | [], [], h, l₁, l₂, hl => hl\n  | a :: as, b :: bs, forall₂.cons h₁ h₂, l₁, l₂, hl => Forall₂.cons h₁ (rel_append h₂ hl)\n#align rel_append rel_append\n\n",
 "nth_le":
 "theorem forall₂.nth_le :\n    ∀ {x : list α} {y : list β} (h : Forall₂ R x y) ⦃i : ℕ⦄ (hx : i < x.length) (hy : i < y.length),\n      R (x.nth_le i hx) (y.nth_le i hy)\n  | a₁ :: l₁, a₂ :: l₂, forall₂.cons ha hl, 0, hx, hy => ha\n  | a₁ :: l₁, a₂ :: l₂, forall₂.cons ha hl, succ i, hx, hy => hl.nth_le _ _\n#align forall₂.nth_le forall₂.nth_le\n\n",
 "mp":
 "theorem forall₂.mp {Q : α → β → Prop} (h : ∀ a b, Q a b → R a b → S a b) :\n    ∀ {l₁ l₂}, Forall₂ Q l₁ l₂ → Forall₂ R l₁ l₂ → Forall₂ S l₁ l₂\n  | [], [], forall₂.nil, forall₂.nil => Forall₂.nil\n  | a :: l₁, b :: l₂, forall₂.cons hr hrs, forall₂.cons hq hqs => Forall₂.cons (h a b hr hq) (forall₂.mp hrs hqs)\n#align forall₂.mp forall₂.mp\n\n",
 "length_eq":
 "theorem forall₂.length_eq : ∀ {l₁ l₂}, Forall₂ R l₁ l₂ → length l₁ = length l₂\n  | _, _, forall₂.nil => rfl\n  | _, _, forall₂.cons h₁ h₂ => congr_arg succ (forall₂.length_eq h₂)\n#align forall₂.length_eq forall₂.length_eq\n\n",
 "left_unique_forall₂'":
 "theorem left_unique_forall₂' (hr : left_unique R) : ∀ {a b c}, Forall₂ R a c → Forall₂ R b c → a = b\n  | a₀, nil, a₁, forall₂.nil, forall₂.nil => rfl\n  | a₀ :: l₀, b :: l, a₁ :: l₁, forall₂.cons ha₀ h₀, forall₂.cons ha₁ h₁ =>\n    hr ha₀ ha₁ ▸ left_unique_forall₂' h₀ h₁ ▸ rfl\n#align left_unique_forall₂' left_unique_forall₂'\n\n",
 "imp":
 "theorem forall₂.imp (H : ∀ a b, R a b → S a b) {l₁ l₂} (h : Forall₂ R l₁ l₂) : Forall₂ S l₁ l₂ := by\n  induction h <;> constructor <;> solve_by_elim\n#align forall₂.imp forall₂.imp\n\n",
 "forall₂_zip":
 "theorem forall₂_zip : ∀ {l₁ l₂}, Forall₂ R l₁ l₂ → ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b\n  | _, _, forall₂.cons h₁ h₂, x, y, or.inl rfl => h₁\n  | _, _, forall₂.cons h₁ h₂, x, y, or.inr h₃ => forall₂_zip h₂ h₃\n#align forall₂_zip forall₂_zip\n\n",
 "forall₂_take_append":
 "theorem forall₂_take_append (l : list α) (l₁ : list β) (l₂ : list β) (h : Forall₂ R l (l₁ ++ l₂)) :\n    Forall₂ R (list.take (length l₁) l) l₁ :=\n  by\n  have h' : Forall₂ R (take (length l₁) l) (take (length l₁) (l₁ ++ l₂)) := forall₂_take (length l₁) h\n  rwa [take_left] at h'\n#align forall₂_take_append forall₂_take_append\n\n",
 "forall₂_take":
 "theorem forall₂_take : ∀ (n) {l₁ l₂}, Forall₂ R l₁ l₂ → Forall₂ R (take n l₁) (take n l₂)\n  | 0, _, _, _ => by simp only [forall₂.nil, take]\n  | n + 1, _, _, forall₂.nil => by simp only [forall₂.nil, take]\n  | n + 1, _, _, forall₂.cons h₁ h₂ => by simp [and.intro h₁ h₂, forall₂_take n]\n#align forall₂_take forall₂_take\n\n",
 "forall₂_same":
 "@[simp]\ntheorem forall₂_same : ∀ {l : list α}, Forall₂ Rₐ l l ↔ ∀ x ∈ l, Rₐ x x\n  | [] => by simp\n  | a :: l => by simp [@forall₂_same l]\n#align forall₂_same forall₂_same\n\n",
 "forall₂_reverse_iff":
 "@[simp]\ntheorem forall₂_reverse_iff {l₁ l₂} : Forall₂ R (reverse l₁) (reverse l₂) ↔ Forall₂ R l₁ l₂ :=\n  iff.intro\n    (fun h => by\n      rw [← reverse_reverse l₁, ← reverse_reverse l₂]\n      exact rel_reverse h)\n    fun h => rel_reverse h\n#align forall₂_reverse_iff forall₂_reverse_iff\n\n",
 "forall₂_refl":
 "theorem forall₂_refl [is_refl α Rₐ] (l : list α) : Forall₂ Rₐ l l :=\n  forall₂_same.2 fun a h => refl _\n#align forall₂_refl forall₂_refl\n\n",
 "forall₂_of_length_eq_of_nth_le":
 "theorem forall₂_of_length_eq_of_nth_le :\n    ∀ {x : list α} {y : list β}, x.length = y.length → (∀ i h₁ h₂, R (x.nth_le i h₁) (y.nth_le i h₂)) → Forall₂ R x y\n  | [], [], hl, h => Forall₂.nil\n  | a₁ :: l₁, a₂ :: l₂, hl, h =>\n    Forall₂.cons (h 0 (nat.zero_lt_succ _) (nat.zero_lt_succ _))\n      (forall₂_of_length_eq_of_nth_le (succ.inj hl) fun i h₁ h₂ => h i.succ (succ_lt_succ h₁) (succ_lt_succ h₂))\n#align forall₂_of_length_eq_of_nth_le forall₂_of_length_eq_of_nth_le\n\n",
 "forall₂_nil_right_iff":
 "@[simp]\ntheorem forall₂_nil_right_iff {l} : Forall₂ R l nil ↔ l = nil :=\n  ⟨fun H => by cases H <;> rfl, by rintro rfl <;> exact forall₂.nil⟩\n#align forall₂_nil_right_iff forall₂_nil_right_iff\n\n",
 "forall₂_nil_left_iff":
 "@[simp]\ntheorem forall₂_nil_left_iff {l} : Forall₂ R nil l ↔ l = nil :=\n  ⟨fun H => by cases H <;> rfl, by rintro rfl <;> exact forall₂.nil⟩\n#align forall₂_nil_left_iff forall₂_nil_left_iff\n\n",
 "forall₂_map_right_iff":
 "@[simp]\ntheorem forall₂_map_right_iff {f : γ → β} : ∀ {l u}, Forall₂ R l (map f u) ↔ Forall₂ (fun a c => R a (f c)) l u\n  | _, [] => by simp only [map, forall₂_nil_right_iff]\n  | _, b :: u => by simp only [map, forall₂_cons_right_iff, forall₂_map_right_iff]\n#align forall₂_map_right_iff forall₂_map_right_iff\n\n",
 "forall₂_map_left_iff":
 "@[simp]\ntheorem forall₂_map_left_iff {f : γ → α} : ∀ {l u}, Forall₂ R (map f l) u ↔ Forall₂ (fun c b => R (f c) b) l u\n  | [], _ => by simp only [map, forall₂_nil_left_iff]\n  | a :: l, _ => by simp only [map, forall₂_cons_left_iff, forall₂_map_left_iff]\n#align forall₂_map_left_iff forall₂_map_left_iff\n\n",
 "forall₂_iff_zip":
 "theorem forall₂_iff_zip {l₁ l₂} : Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=\n  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h =>\n    by\n    cases' h with h₁ h₂\n    induction' l₁ with a l₁ IH generalizing l₂\n    · cases length_eq_zero.1 h₁.symm\n      constructor\n    · cases' l₂ with b l₂ <;> injection h₁ with h₁\n      exact forall₂.cons (h₂ <| or.inl rfl) (IH h₁ fun a b h => h₂ <| or.inr h)⟩\n#align forall₂_iff_zip forall₂_iff_zip\n\n",
 "forall₂_iff_nth_le":
 "theorem forall₂_iff_nth_le {l₁ : list α} {l₂ : list β} :\n    Forall₂ R l₁ l₂ ↔ l₁.length = l₂.length ∧ ∀ i h₁ h₂, R (l₁.nth_le i h₁) (l₂.nth_le i h₂) :=\n  ⟨fun h => ⟨h.length_eq, h.nth_le⟩, and.rec forall₂_of_length_eq_of_nthLe⟩\n#align forall₂_iff_nth_le forall₂_iff_nth_le\n\n",
 "forall₂_eq_eq_eq":
 "@[simp]\ntheorem forall₂_eq_eq_eq : Forall₂ ((· = ·) : α → α → Prop) = (· = ·) :=\n  by\n  funext a b; apply propext\n  constructor\n  · intro h\n    induction h\n    · rfl\n    simp only [*] <;> constructor <;> rfl\n  · rintro rfl\n    exact forall₂_refl _\n#align forall₂_eq_eq_eq forall₂_eq_eq_eq\n\n",
 "forall₂_drop_append":
 "theorem forall₂_drop_append (l : list α) (l₁ : list β) (l₂ : list β) (h : Forall₂ R l (l₁ ++ l₂)) :\n    Forall₂ R (list.drop (length l₁) l) l₂ :=\n  by\n  have h' : Forall₂ R (drop (length l₁) l) (drop (length l₁) (l₁ ++ l₂)) := forall₂_drop (length l₁) h\n  rwa [drop_left] at h'\n#align forall₂_drop_append forall₂_drop_append\n\n",
 "forall₂_drop":
 "theorem forall₂_drop : ∀ (n) {l₁ l₂}, Forall₂ R l₁ l₂ → Forall₂ R (drop n l₁) (drop n l₂)\n  | 0, _, _, h => by simp only [drop, h]\n  | n + 1, _, _, forall₂.nil => by simp only [forall₂.nil, drop]\n  | n + 1, _, _, forall₂.cons h₁ h₂ => by simp [and.intro h₁ h₂, forall₂_drop n]\n#align forall₂_drop forall₂_drop\n\n",
 "forall₂_cons_right_iff":
 "theorem forall₂_cons_right_iff {b l u} : Forall₂ R u (b :: l) ↔ ∃ a u', R a b ∧ Forall₂ R u' l ∧ u = a :: u' :=\n  iff.intro\n    (fun h =>\n      match u, h with\n      | b :: u', forall₂.cons h₁ h₂ => ⟨b, u', h₁, h₂, rfl⟩)\n    fun h =>\n    match u, h with\n    | _, ⟨b, u', h₁, h₂, rfl⟩ => Forall₂.cons h₁ h₂\n#align forall₂_cons_right_iff forall₂_cons_right_iff\n\n",
 "forall₂_cons_left_iff":
 "theorem forall₂_cons_left_iff {a l u} : Forall₂ R (a :: l) u ↔ ∃ b u', R a b ∧ Forall₂ R l u' ∧ u = b :: u' :=\n  iff.intro\n    (fun h =>\n      match u, h with\n      | b :: u', forall₂.cons h₁ h₂ => ⟨b, u', h₁, h₂, rfl⟩)\n    fun h =>\n    match u, h with\n    | _, ⟨b, u', h₁, h₂, rfl⟩ => Forall₂.cons h₁ h₂\n#align forall₂_cons_left_iff forall₂_cons_left_iff\n\n",
 "forall₂_cons":
 "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Johannes Hölzl\n-/\n@[simp]\ntheorem forall₂_cons {a b l₁ l₂} : Forall₂ R (a :: l₁) (b :: l₂) ↔ R a b ∧ Forall₂ R l₁ l₂ :=\n  ⟨fun h => by cases' h with h₁ h₂ <;> constructor <;> assumption, fun ⟨h₁, h₂⟩ => Forall₂.cons h₁ h₂⟩\n#align forall₂_cons forall₂_cons\n\n",
 "forall₂_and_left":
 "theorem forall₂_and_left {p : α → Prop} : ∀ l u, Forall₂ (fun a b => p a ∧ R a b) l u ↔ (∀ a ∈ l, p a) ∧ Forall₂ R l u\n  | [], u => by simp only [forall₂_nil_left_iff, forall_prop_of_false (not_mem_nil _), imp_true_iff, true_and_iff]\n  | a :: l, u => by\n    simp only [forall₂_and_left l, forall₂_cons_left_iff, forall_mem_cons, and_assoc', and_comm', and_left_comm,\n      exists_and_distrib_left.symm]\n#align forall₂_and_left forall₂_and_left\n\n",
 "forall₂":
 "#print Relator.BiUnique.forall₂ /-\ntheorem Relator.BiUnique.forall₂ (hr : bi_unique R) : bi_unique (Forall₂ R) :=\n  ⟨hr.left.forall₂, hr.right.forall₂⟩\n#align relator.bi_unique.forall₂ Relator.BiUnique.forall₂\n-/\n\n",
 "flip":
 "theorem forall₂.flip : ∀ {a b}, Forall₂ (flip R) b a → Forall₂ R a b\n  | _, _, forall₂.nil => Forall₂.nil\n  | a :: as, b :: bs, forall₂.cons h₁ h₂ => Forall₂.cons h₁ h₂.flip\n#align forall₂.flip forall₂.flip\n\n"}