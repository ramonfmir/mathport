{"sublist_of_order_embedding_nth_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/-- If there is `f`, an order-preserving embedding of `ℕ` into `ℕ` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`,\nthen `sublist l l'`.\n-/\ntheorem sublist_of_order_embedding_nth_eq {l l' : list α} (f : «expr ↪o » ℕ ℕ)\n    (hf : ∀ ix : ℕ, l.nth ix = l'.nth (f ix)) : «expr <+ » l l' :=\n  by\n  induction' l with hd tl IH generalizing l' f\n  · simp\n  have : some hd = _ := hf 0\n  rw [eq_comm, List.get?_eq_some'] at this\n  obtain ⟨w, h⟩ := this\n  let f' : «expr ↪o » ℕ ℕ :=\n    OrderEmbedding.ofMapLeIff (fun i => f (i + 1) - (f 0 + 1)) fun a b => by\n      simp [tsub_le_tsub_iff_right, Nat.succ_le_iff, Nat.lt_succ_iff]\n  have : ∀ ix, tl.nth ix = (l'.drop (f 0 + 1)).nth (f' ix) :=\n    by\n    intro ix\n    simp [List.get?_drop, add_tsub_cancel_of_le, Nat.succ_le_iff, ← hf]\n  rw [← List.take_append_drop (f 0 + 1) l', ← List.singleton_append]\n  apply List.Sublist.append _ (IH _ this)\n  rw [List.singleton_sublist, ← h, l'.nth_le_take _ (nat.lt_succ_self _)]\n  apply List.nthLe_mem\n#align sublist_of_order_embedding_nth_eq sublist_of_order_embedding_nth_eq\n\n",
 "sublist_iff_exists_order_embedding_nth_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/-- A `l : list α` is `sublist l l'` for `l' : list α` iff\nthere is `f`, an order-preserving embedding of `ℕ` into `ℕ` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`.\n-/\ntheorem sublist_iff_exists_order_embedding_nth_eq {l l' : list α} :\n    «expr <+ » l l' ↔ ∃ f : «expr ↪o » ℕ ℕ, ∀ ix : ℕ, l.nth ix = l'.nth (f ix) :=\n  by\n  constructor\n  · intro H\n    induction' H with xs ys y H IH xs ys x H IH\n    · simp\n    · obtain ⟨f, hf⟩ := IH\n      refine' ⟨f.trans (OrderEmbedding.ofStrictMono (· + 1) fun _ => by simp), _⟩\n      simpa using hf\n    · obtain ⟨f, hf⟩ := IH\n      refine' ⟨OrderEmbedding.ofMapLeIff (fun ix : ℕ => if ix = 0 then 0 else (f ix.pred).succ) _, _⟩\n      · rintro ⟨_ | a⟩ ⟨_ | b⟩ <;> simp [nat.succ_le_succ_iff]\n      · rintro ⟨_ | i⟩\n        · simp\n        · simpa using hf _\n  · rintro ⟨f, hf⟩\n    exact sublist_of_order_embedding_nth_eq f hf\n#align sublist_iff_exists_order_embedding_nth_eq sublist_iff_exists_order_embedding_nth_eq\n\n",
 "sublist_iff_exists_fin_order_embedding_nth_le_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n/-- A `l : list α` is `sublist l l'` for `l' : list α` iff\nthere is `f`, an order-preserving embedding of `fin l.length` into `fin l'.length` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`.\n-/\ntheorem sublist_iff_exists_fin_order_embedding_nth_le_eq {l l' : list α} :\n    «expr <+ » l l' ↔\n      ∃ f : «expr ↪o » (fin l.length) (fin l'.length),\n        ∀ ix : fin l.length, l.nth_le ix ix.is_lt = l'.nth_le (f ix) (f ix).is_lt :=\n  by\n  rw [sublist_iff_exists_order_embedding_nth_eq]\n  constructor\n  · rintro ⟨f, hf⟩\n    have h : ∀ {i : ℕ} (h : i < l.length), f i < l'.length :=\n      by\n      intro i hi\n      specialize hf i\n      rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf\n      obtain ⟨h, -⟩ := hf\n      exact h\n    refine' ⟨OrderEmbedding.ofMapLeIff (fun ix => ⟨f ix, h ix.is_lt⟩) _, _⟩\n    · simp\n    · intro i\n      apply option.some_injective\n      simpa [← nth_le_nth] using hf _\n  · rintro ⟨f, hf⟩\n    refine' ⟨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ⟨i, hi⟩ else i + l'.length) _, _⟩\n    · intro i j h\n      dsimp only\n      split_ifs with hi hj hj hi\n      · simpa using h\n      · rw [add_comm]\n        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)\n      · exact absurd (h.trans hj) hi\n      · simpa using h\n    · intro i\n      simp only [OrderEmbedding.coe_ofStrictMono]\n      split_ifs with hi\n      · rw [nth_le_nth hi, nth_le_nth, ← hf]\n        simp\n      · rw [nth_len_le, nth_len_le]\n        · simp\n        · simpa using hi\n#align sublist_iff_exists_fin_order_embedding_nth_le_eq sublist_iff_exists_fin_order_embedding_nth_le_eq\n\n",
 "nth_le_strict_mono":
 "theorem nth_le_strict_mono (h : l.sorted (· < ·)) : strict_mono fun i : fin l.length => l.nth_le i i.2 := fun i j =>\n  h.rel_nth_le_of_lt _ _\n#align nth_le_strict_mono nth_le_strict_mono\n\n",
 "nth_le_mono":
 "/-\nCopyright (c) 2020 Yury G. Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury G. Kudryashov\n-/\ntheorem nth_le_mono (h : l.sorted (· ≤ ·)) : monotone fun i : fin l.length => l.nth_le i i.2 := fun i j =>\n  h.rel_nth_le_of_le _ _\n#align nth_le_mono nth_le_mono\n\n",
 "duplicate_iff_exists_distinct_nth_le":
 "/-- An element `x : α` of `l : list α` is a duplicate iff it can be found\nat two distinct indices `n m : ℕ` inside the list `l`.\n-/\ntheorem duplicate_iff_exists_distinct_nth_le {l : list α} {x : α} :\n    l.duplicate x ↔\n      ∃ (n : ℕ)(hn : n < l.length)(m : ℕ)(hm : m < l.length)(h : n < m), x = l.nth_le n hn ∧ x = l.nth_le m hm :=\n  by\n  classical\n    rw [duplicate_iff_two_le_count, le_count_iff_replicate_sublist, sublist_iff_exists_fin_order_embedding_nth_le_eq]\n    constructor\n    · rintro ⟨f, hf⟩\n      refine' ⟨f ⟨0, by simp⟩, Fin.is_lt _, f ⟨1, by simp⟩, Fin.is_lt _, by simp, _, _⟩\n      · simpa using hf ⟨0, by simp⟩\n      · simpa using hf ⟨1, by simp⟩\n    · rintro ⟨n, hn, m, hm, hnm, h, h'⟩\n      refine' ⟨OrderEmbedding.ofStrictMono (fun i => if (i : ℕ) = 0 then ⟨n, hn⟩ else ⟨m, hm⟩) _, _⟩\n      · rintro ⟨⟨_ | i⟩, hi⟩ ⟨⟨_ | j⟩, hj⟩\n        · simp\n        · simp [hnm]\n        · simp\n        · simp only [Nat.lt_succ_iff, nat.succ_le_succ_iff, replicate, length, nonpos_iff_eq_zero] at hi hj\n          simp [hi, hj]\n      · rintro ⟨⟨_ | i⟩, hi⟩\n        · simpa using h\n        · simpa using h'\n#align duplicate_iff_exists_distinct_nth_le duplicate_iff_exists_distinct_nth_le\n\n",
 "coe_nth_le_iso_symm_apply":
 "@[simp]\ntheorem coe_nth_le_iso_symm_apply : ((H.nth_le_iso l).symm x : ℕ) = indexOf (↑x) l :=\n  rfl\n#align coe_nth_le_iso_symm_apply coe_nth_le_iso_symm_apply\n\n",
 "coe_nth_le_iso_apply":
 "@[simp]\ntheorem coe_nth_le_iso_apply : (H.nth_le_iso l i : α) = nthLe l i i.2 :=\n  rfl\n#align coe_nth_le_iso_apply coe_nth_le_iso_apply\n\n"}