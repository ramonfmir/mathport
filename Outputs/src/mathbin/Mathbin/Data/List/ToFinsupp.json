{"to_finsupp_support":
 "theorem to_finsupp_support : l.to_finsupp.support = (Finset.range l.length).filter fun i => getD l i 0 ≠ 0 :=\n  rfl\n#align to_finsupp_support to_finsupp_support\n\n",
 "to_finsupp_singleton":
 "theorem to_finsupp_singleton (x : M) [DecidablePred fun i => getD [x] i 0 ≠ 0] : toFinsupp [x] = Finsupp.single 0 x :=\n  by ext ⟨_ | i⟩ <;> simp [Finsupp.single_apply, (nat.zero_lt_succ _).ne]\n#align to_finsupp_singleton to_finsupp_singleton\n\n",
 "to_finsupp_nil":
 "@[simp]\ntheorem to_finsupp_nil [DecidablePred fun i => getD ([] : List M) i 0 ≠ 0] : toFinsupp ([] : List M) = 0 :=\n  by\n  ext\n  simp\n#align to_finsupp_nil to_finsupp_nil\n\n",
 "to_finsupp_eq_sum_map_enum_single":
 "theorem to_finsupp_eq_sum_map_enum_single {R : Type _} [AddMonoid R] (l : List R)\n    [DecidablePred fun i => getD l i 0 ≠ 0] :\n    toFinsupp l = (l.enum.map fun nr : ℕ × R => Finsupp.single nr.1 nr.2).sum :=\n  by\n  induction' l using List.reverseRecOn with xs x IH\n  · convert to_finsupp_nil\n  · simp only [enum_append, map, enum_from_singleton, map_append, sum_append, sum_cons, sum_nil, add_zero]\n    classical\n      convert to_finsupp_concat_eq_to_finsupp_add_single _ _\n      exact IH.symm\n#align to_finsupp_eq_sum_map_enum_single to_finsupp_eq_sum_map_enum_single\n\n",
 "to_finsupp_cons_eq_single_add_emb_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem to_finsupp_cons_eq_single_add_emb_domain {R : Type _} [AddZeroClass R] (x : R) (xs : List R)\n    [DecidablePred fun i => getD (sym.cons' x xs) i 0 ≠ 0] [DecidablePred fun i => getD xs i 0 ≠ 0] :\n    toFinsupp (sym.cons' x xs) = Finsupp.single 0 x + (toFinsupp xs).emb_domain ⟨nat.succ, Nat.succ_injective⟩ :=\n  by\n  ext (_ | i)\n  · simp only [Nat.zero_eq, to_finsupp_cons_apply_zero, Finsupp.coe_add, Pi.add_apply, Finsupp.single_eq_same]\n    rw [Finsupp.embDomain_notin_range]\n    · exact (add_zero _).symm\n    · simp\n  · simp only [to_finsupp_cons_apply_succ, Finsupp.coe_add, Pi.add_apply]\n    have hi : i.succ = (⟨nat.succ, Nat.succ_injective⟩ : «expr ↪ » ℕ ℕ) i := rfl\n    rw [finsupp.single_apply_eq_zero.mpr, zero_add, hi, Finsupp.embDomain_apply]\n    simp\n#align to_finsupp_cons_eq_single_add_emb_domain to_finsupp_cons_eq_single_add_emb_domain\n\n",
 "to_finsupp_cons_apply_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp]\ntheorem to_finsupp_cons_apply_zero (x : M) (xs : List M) [DecidablePred fun i => getD (sym.cons' x xs) i 0 ≠ 0] :\n    (sym.cons' x xs).to_finsupp 0 = x :=\n  rfl\n#align to_finsupp_cons_apply_zero to_finsupp_cons_apply_zero\n\n",
 "to_finsupp_cons_apply_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n@[simp]\ntheorem to_finsupp_cons_apply_succ (x : M) (xs : List M) (n : ℕ) [DecidablePred fun i => getD (sym.cons' x xs) i 0 ≠ 0]\n    [DecidablePred fun i => getD xs i 0 ≠ 0] : (sym.cons' x xs).to_finsupp n.succ = xs.to_finsupp n :=\n  rfl\n#align to_finsupp_cons_apply_succ to_finsupp_cons_apply_succ\n\n",
 "to_finsupp_concat_eq_to_finsupp_add_single":
 "theorem to_finsupp_concat_eq_to_finsupp_add_single {R : Type _} [AddZeroClass R] (x : R) (xs : List R)\n    [DecidablePred fun i => getD (xs ++ [x]) i 0 ≠ 0] [DecidablePred fun i => getD xs i 0 ≠ 0] :\n    toFinsupp (xs ++ [x]) = toFinsupp xs + Finsupp.single xs.length x :=\n  by\n  ext i\n  simp only [Finsupp.coe_add, Pi.add_apply, Finsupp.single_apply]\n  rcases lt_trichotomy xs.length i with (hi | rfl | hi)\n  · rw [to_finsupp_apply_le _ _ hi.le, to_finsupp_apply_le, if_neg hi.ne, add_zero]\n    simpa using nat.succ_le_of_lt hi\n  · rw [to_finsupp_apply_lt, to_finsupp_apply_le _ _ le_rfl, if_pos rfl, zero_add, nth_le_append_right le_rfl]\n    · simp\n    · simp\n  · rw [to_finsupp_apply_lt _ _ hi, to_finsupp_apply_lt, if_neg hi.ne', add_zero, nth_le_append]\n    simpa using nat.lt_succ_of_lt hi\n#align to_finsupp_concat_eq_to_finsupp_add_single to_finsupp_concat_eq_to_finsupp_add_single\n\n",
 "to_finsupp_apply_lt":
 "theorem to_finsupp_apply_lt (hn : n < l.length) : l.to_finsupp n = l.nth_le n hn :=\n  getD_eq_nthLe _ _ _\n#align to_finsupp_apply_lt to_finsupp_apply_lt\n\n",
 "to_finsupp_apply_le":
 "theorem to_finsupp_apply_le (hn : l.length ≤ n) : l.to_finsupp n = 0 :=\n  getD_eq_default _ _ hn\n#align to_finsupp_apply_le to_finsupp_apply_le\n\n",
 "to_finsupp_apply":
 "@[simp, norm_cast]\ntheorem to_finsupp_apply (i : ℕ) : (l.to_finsupp : ℕ → M) i = l.nthd i 0 :=\n  rfl\n#align to_finsupp_apply to_finsupp_apply\n\n",
 "coe_to_finsupp":
 "/-\nCopyright (c) 2022 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\n@[norm_cast]\ntheorem coe_to_finsupp : (l.to_finsupp : ℕ → M) = fun i => l.nthd i 0 :=\n  rfl\n#align coe_to_finsupp coe_to_finsupp\n\n"}