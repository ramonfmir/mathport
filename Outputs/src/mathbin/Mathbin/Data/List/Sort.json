{"tail":
 "theorem sorted.tail {r : α → α → Prop} {l : list α} (h : sorted r l) : sorted r l.tail :=\n  h.tail\n#align sorted.tail sorted.tail\n\n",
 "sublist_of_subperm_of_sorted":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem sublist_of_subperm_of_sorted [is_antisymm α r] {l₁ l₂ : list α} (p : «expr <+~ » l₁ l₂) (s₁ : l₁.sorted r)\n    (s₂ : l₂.sorted r) : «expr <+ » l₁ l₂ := by\n  let ⟨_, h, h'⟩ := p\n  rwa [← eq_of_perm_of_sorted h (s₂.sublist h') s₁]\n#align sublist_of_subperm_of_sorted sublist_of_subperm_of_sorted\n\n",
 "split_cons_of_eq":
 "-- TODO(Jeremy): observation: if instead we write (a :: (split l).1, b :: (split l).2), the\n-- equation compiler can't prove the third equation\ntheorem split_cons_of_eq (a : α) {l l₁ l₂ : list α} (h : split l = (l₁, l₂)) : split (a :: l) = (a :: l₂, l₁) := by\n  rw [split, h] <;> rfl\n#align split_cons_of_eq split_cons_of_eq\n\n",
 "sorted_singleton":
 "@[simp]\ntheorem sorted_singleton (a : α) : sorted r [a] :=\n  pairwise_singleton _ _\n#align sorted_singleton sorted_singleton\n\n",
 "sorted_nil":
 "/-\nCopyright (c) 2016 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad\n-/\n@[simp]\ntheorem sorted_nil : sorted r [] :=\n  pairwise.nil\n#align sorted_nil sorted_nil\n\n",
 "sorted_merge_sort":
 "theorem sorted_merge_sort : ∀ l : list α, sorted r (merge_sort r l)\n  | [] => by simp [merge_sort]\n  | [a] => by simp [merge_sort]\n  | a :: b :: l => by\n    cases' e : split (a :: b :: l) with l₁ l₂\n    cases' length_split_lt e with h₁ h₂\n    rw [merge_sort_cons_cons r e]\n    exact (sorted_merge_sort l₁).merge (sorted_merge_sort l₂)termination_by' ⟨_, inv_image.wf length Nat.lt_wfRel⟩\n#align sorted_merge_sort sorted_merge_sort\n\n",
 "sorted_insertion_sort":
 "/-- The list `list.insertion_sort r l` is `list.sorted` with respect to `r`. -/\ntheorem sorted_insertion_sort : ∀ l, sorted r (insertion_sort r l)\n  | [] => sorted_nil\n  | a :: l => (sorted_insertion_sort l).ordered_insert a _\n#align sorted_insertion_sort sorted_insertion_sort\n\n",
 "sorted_cons":
 "@[simp]\ntheorem sorted_cons {a : α} {l : list α} : sorted r (a :: l) ↔ (∀ b ∈ l, r a b) ∧ sorted r l :=\n  pairwise_cons\n#align sorted_cons sorted_cons\n\n",
 "rel_of_sorted_cons":
 "theorem rel_of_sorted_cons {a : α} {l : list α} : sorted r (a :: l) → ∀ b ∈ l, r a b :=\n  rel_of_pairwise_cons\n#align rel_of_sorted_cons rel_of_sorted_cons\n\n",
 "rel_of_mem_take_of_mem_drop":
 "theorem sorted.rel_of_mem_take_of_mem_drop {l : list α} (h : list.sorted r l) {k : ℕ} {x y : α} (hx : x ∈ list.take k l)\n    (hy : y ∈ list.drop k l) : r x y :=\n  by\n  obtain ⟨iy, hiy, rfl⟩ := nth_le_of_mem hy\n  obtain ⟨ix, hix, rfl⟩ := nth_le_of_mem hx\n  rw [nth_le_take', nth_le_drop']\n  rw [length_take] at hix\n  exact h.rel_nth_le_of_lt _ _ (ix.lt_add_right _ _ (lt_min_iff.mp hix).left)\n#align sorted.rel_of_mem_take_of_mem_drop sorted.rel_of_mem_take_of_mem_drop\n\n",
 "rel_nth_le_of_lt":
 "theorem sorted.rel_nth_le_of_lt {l : list α} (h : l.sorted r) {a b : ℕ} (ha : a < l.length) (hb : b < l.length)\n    (hab : a < b) : r (l.nth_le a ha) (l.nth_le b hb) :=\n  List.pairwise_iff_nthLe.1 h a b hb hab\n#align sorted.rel_nth_le_of_lt sorted.rel_nth_le_of_lt\n\n",
 "rel_nth_le_of_le":
 "theorem sorted.rel_nth_le_of_le [is_refl α r] {l : list α} (h : l.sorted r) {a b : ℕ} (ha : a < l.length)\n    (hb : b < l.length) (hab : a ≤ b) : r (l.nth_le a ha) (l.nth_le b hb) :=\n  by\n  cases' eq_or_lt_of_le hab with H H\n  · subst H\n    exact refl _\n  · exact h.rel_nth_le_of_lt _ _ H\n#align sorted.rel_nth_le_of_le sorted.rel_nth_le_of_le\n\n",
 "perm_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_split : ∀ {l l₁ l₂ : list α}, split l = (l₁, l₂) → list.perm l (l₁ ++ l₂)\n  | [], _, _, rfl => Perm.refl _\n  | a :: l, l₁', l₂', h => by\n    cases' e : split l with l₁ l₂\n    injection (split_cons_of_eq _ e).symm.trans h; substs l₁' l₂'\n    exact ((perm_split e).trans perm_append_comm).cons a\n#align perm_split perm_split\n\n",
 "perm_ordered_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_ordered_insert (a) : ∀ l : list α, list.perm (ordered_insert r a l) (a :: l)\n  | [] => Perm.refl _\n  | b :: l => by\n    by_cases «expr ≼ » a b <;> [simp [ordered_insert, h],\n      simpa [ordered_insert, h] using ((perm_ordered_insert l).cons _).trans (perm.swap _ _ _)]\n#align perm_ordered_insert perm_ordered_insert\n\n",
 "perm_merge_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_merge_sort : ∀ l : list α, list.perm (merge_sort r l) l\n  | [] => by simp [merge_sort]\n  | [a] => by simp [merge_sort]\n  | a :: b :: l => by\n    cases' e : split (a :: b :: l) with l₁ l₂\n    cases' length_split_lt e with h₁ h₂\n    rw [merge_sort_cons_cons r e]\n    apply (perm_merge r _ _).trans\n    exact ((perm_merge_sort l₁).append (perm_merge_sort l₂)).trans (perm_split e).symm termination_by'\n  ⟨_, inv_image.wf length Nat.lt_wfRel⟩\n#align perm_merge_sort perm_merge_sort\n\n",
 "perm_merge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_merge : ∀ l l' : list α, list.perm (merge r l l') (l ++ l')\n  | [], [] => by simp [merge]\n  | [], b :: l' => by simp [merge]\n  | a :: l, [] => by simp [merge]\n  | a :: l, b :: l' => by\n    by_cases «expr ≼ » a b\n    · simpa [merge, h] using perm_merge _ _\n    · suffices list.perm (b :: merge r (a :: l) l') (a :: (l ++ b :: l')) by simpa [merge, h]\n      exact ((perm_merge _ _).cons _).trans ((swap _ _ _).trans (perm_middle.symm.cons _))\n#align perm_merge perm_merge\n\n",
 "perm_insertion_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_insertion_sort : ∀ l : list α, list.perm (insertion_sort r l) l\n  | [] => perm.nil\n  | b :: l => by simpa [insertion_sort] using (perm_ordered_insert _ _ _).trans ((perm_insertion_sort l).cons b)\n#align perm_insertion_sort perm_insertion_sort\n\n",
 "ordered_insert_nil":
 "@[simp]\ntheorem ordered_insert_nil (a : α) : [].ordered_insert r a = [a] :=\n  rfl\n#align ordered_insert_nil ordered_insert_nil\n\n",
 "ordered_insert_length":
 "theorem ordered_insert_length : ∀ (L : list α) (a : α), (L.ordered_insert r a).length = L.length + 1\n  | [], a => rfl\n  | hd :: tl, a => by\n    dsimp [ordered_insert]\n    split_ifs <;> simp [ordered_insert_length]\n#align ordered_insert_length ordered_insert_length\n\n",
 "ordered_insert_eq_take_drop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\n/-- An alternative definition of `ordered_insert` using `take_while` and `drop_while`. -/\ntheorem ordered_insert_eq_take_drop (a : α) :\n    ∀ l : list α,\n      l.ordered_insert r a = (l.take_while fun b => ¬«expr ≼ » a b) ++ a :: l.drop_while fun b => ¬«expr ≼ » a b\n  | [] => rfl\n  | b :: l => by\n    dsimp only [ordered_insert]\n    split_ifs <;> simp [take_while, drop_while, *]\n#align ordered_insert_eq_take_drop ordered_insert_eq_take_drop\n\n",
 "ordered_insert_count":
 "theorem ordered_insert_count [decidable_eq α] (L : list α) (a b : α) :\n    count a (L.ordered_insert r b) = count a L + if a = b then 1 else 0 :=\n  by\n  rw [(L.perm_ordered_insert r b).count_eq, count_cons]\n  split_ifs <;> simp only [nat.succ_eq_add_one, add_zero]\n#align ordered_insert_count ordered_insert_count\n\n",
 "ordered_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\ntheorem sorted.ordered_insert (a : α) : ∀ l, sorted r l → sorted r (ordered_insert r a l)\n  | [], h => sorted_singleton a\n  | b :: l, h => by\n    by_cases h' : «expr ≼ » a b\n    · simpa [ordered_insert, h', h] using fun b' bm => trans h' (rel_of_sorted_cons h _ bm)\n    · suffices ∀ b' : α, b' ∈ ordered_insert r a l → r b b' by simpa [ordered_insert, h', h.of_cons.ordered_insert l]\n      intro b' bm\n      cases' show b' = a ∨ b' ∈ l by simpa using (perm_ordered_insert _ _ _).subset bm with be bm\n      · subst b'\n        exact (total_of r _ _).resolve_left h'\n      · exact rel_of_sorted_cons h _ bm\n#align sorted.ordered_insert sorted.ordered_insert\n\n",
 "of_fn_sorted":
 "/-- The list obtained from a monotone tuple is sorted. -/\ntheorem monotone.of_fn_sorted (h : monotone f) : (ofFn f).sorted (· ≤ ·) :=\n  monotone_iff_of_fn_sorted.1 h\n#align monotone.of_fn_sorted monotone.of_fn_sorted\n\n",
 "of_cons":
 "theorem sorted.of_cons : sorted r (a :: l) → sorted r l :=\n  pairwise.of_cons\n#align sorted.of_cons sorted.of_cons\n\n",
 "nodup":
 "protected theorem sorted.nodup {r : α → α → Prop} [is_irrefl α r] {l : list α} (h : sorted r l) : Nodup l :=\n  h.nodup\n#align sorted.nodup sorted.nodup\n\n",
 "monotone_iff_of_fn_sorted":
 "/-- A tuple is monotone if and only if the list obtained from it is sorted. -/\ntheorem monotone_iff_of_fn_sorted : monotone f ↔ (ofFn f).sorted (· ≤ ·) :=\n  by\n  simp_rw [sorted, pairwise_iff_nth_le, length_of_fn, nth_le_of_fn', monotone_iff_forall_lt]\n  exact ⟨fun h i j hj hij => h <| fin.mk_lt_mk.mpr hij, fun h ⟨i, _⟩ ⟨j, hj⟩ hij => h i j hj hij⟩\n#align monotone_iff_of_fn_sorted monotone_iff_of_fn_sorted\n\n",
 "merge_sort_singleton":
 "@[simp]\ntheorem merge_sort_singleton (a : α) : [a].merge_sort r = [a] := by rw [list.merge_sort]\n#align merge_sort_singleton merge_sort_singleton\n\n",
 "merge_sort_nil":
 "@[simp]\ntheorem merge_sort_nil : [].merge_sort r = [] := by rw [list.merge_sort]\n#align merge_sort_nil merge_sort_nil\n\n",
 "merge_sort_eq_self":
 "theorem merge_sort_eq_self [is_antisymm α r] {l : list α} : sorted r l → merge_sort r l = l :=\n  eq_of_perm_of_sorted (perm_merge_sort _ _) (sorted_merge_sort _ _)\n#align merge_sort_eq_self merge_sort_eq_self\n\n",
 "merge_sort_eq_insertion_sort":
 "theorem merge_sort_eq_insertion_sort [is_antisymm α r] (l : list α) : merge_sort r l = insertion_sort r l :=\n  eq_of_perm_of_sorted ((perm_merge_sort r l).trans (perm_insertion_sort r l).symm) (sorted_merge_sort r l)\n    (sorted_insertion_sort r l)\n#align merge_sort_eq_insertion_sort merge_sort_eq_insertion_sort\n\n",
 "merge_sort_cons_cons":
 "theorem merge_sort_cons_cons {a b} {l l₁ l₂ : list α} (h : split (a :: b :: l) = (l₁, l₂)) :\n    merge_sort r (a :: b :: l) = merge r (merge_sort r l₁) (merge_sort r l₂) :=\n  by\n  suffices\n    ∀ (L : list α) (h1),\n      @and.rec (fun a a (_ : length l₁ < length l + 1 + 1 ∧ length l₂ < length l + 1 + 1) => L) h1 h1 = L\n    by\n    simp [merge_sort, h]\n    apply this\n  intros\n  cases h1\n  rfl\n#align merge_sort_cons_cons merge_sort_cons_cons\n\n",
 "merge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\ntheorem sorted.merge : ∀ {l l' : list α}, sorted r l → sorted r l' → sorted r (merge r l l')\n  | [], [], h₁, h₂ => by simp [merge]\n  | [], b :: l', h₁, h₂ => by simpa [merge] using h₂\n  | a :: l, [], h₁, h₂ => by simpa [merge] using h₁\n  | a :: l, b :: l', h₁, h₂ => by\n    by_cases «expr ≼ » a b\n    · suffices ∀ (b' : α) (_ : b' ∈ merge r l (b :: l')), r a b' by simpa [merge, h, h₁.of_cons.merge h₂]\n      intro b' bm\n      rcases show b' = b ∨ b' ∈ l ∨ b' ∈ l' by simpa [or_left_comm] using (perm_merge _ _ _).subset bm with\n        (be | bl | bl')\n      · subst b'\n        assumption\n      · exact rel_of_sorted_cons h₁ _ bl\n      · exact trans h (rel_of_sorted_cons h₂ _ bl')\n    · suffices ∀ (b' : α) (_ : b' ∈ merge r (a :: l) l'), r b b' by simpa [merge, h, h₁.merge h₂.of_cons]\n      intro b' bm\n      have ba : «expr ≼ » b a := (total_of r _ _).resolve_left h\n      rcases show b' = a ∨ b' ∈ l ∨ b' ∈ l' by simpa using (perm_merge _ _ _).subset bm with (be | bl | bl')\n      · subst b'\n        assumption\n      · exact trans ba (rel_of_sorted_cons h₁ _ bl)\n      · exact rel_of_sorted_cons h₂ _ bl'\n#align sorted.merge sorted.merge\n\n",
 "length_split_lt":
 "theorem length_split_lt {a b} {l l₁ l₂ : list α} (h : split (a :: b :: l) = (l₁, l₂)) :\n    length l₁ < length (a :: b :: l) ∧ length l₂ < length (a :: b :: l) :=\n  by\n  cases' e : split l with l₁' l₂'\n  injection (split_cons_of_eq _ (split_cons_of_eq _ e)).symm.trans h; substs l₁ l₂\n  cases' length_split_le e with h₁ h₂\n  exact ⟨nat.succ_le_succ (nat.succ_le_succ h₁), nat.succ_le_succ (nat.succ_le_succ h₂)⟩\n#align length_split_lt length_split_lt\n\n",
 "length_split_le":
 "theorem length_split_le : ∀ {l l₁ l₂ : list α}, split l = (l₁, l₂) → length l₁ ≤ length l ∧ length l₂ ≤ length l\n  | [], _, _, rfl => ⟨nat.le_refl 0, nat.le_refl 0⟩\n  | a :: l, l₁', l₂', h => by\n    cases' e : split l with l₁ l₂\n    injection (split_cons_of_eq _ e).symm.trans h; substs l₁' l₂'\n    cases' length_split_le e with h₁ h₂\n    exact ⟨nat.succ_le_succ h₂, nat.le_succ_of_le h₁⟩\n#align length_split_le length_split_le\n\n",
 "length_merge_sort":
 "@[simp]\ntheorem length_merge_sort (l : list α) : (merge_sort r l).length = l.length :=\n  (perm_merge_sort r _).length_eq\n#align length_merge_sort length_merge_sort\n\n",
 "insertion_sort_eq":
 "/-- If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change\nit. -/\ntheorem sorted.insertion_sort_eq : ∀ {l : list α} (h : sorted r l), insertion_sort r l = l\n  | [], _ => rfl\n  | [a], _ => rfl\n  | a :: b :: l, h => by\n    rw [insertion_sort, sorted.insertion_sort_eq, ordered_insert, if_pos]\n    exacts[rel_of_sorted_cons h _ (or.inl rfl), h.tail]\n#align sorted.insertion_sort_eq sorted.insertion_sort_eq\n\n",
 "insertion_sort_cons_eq_take_drop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≼ » -/\ntheorem insertion_sort_cons_eq_take_drop (a : α) (l : list α) :\n    insertion_sort r (a :: l) =\n      ((insertion_sort r l).take_while fun b => ¬«expr ≼ » a b) ++\n        a :: (insertion_sort r l).drop_while fun b => ¬«expr ≼ » a b :=\n  ordered_insert_eq_take_drop r a _\n#align insertion_sort_cons_eq_take_drop insertion_sort_cons_eq_take_drop\n\n",
 "eq_of_perm_of_sorted":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem eq_of_perm_of_sorted [is_antisymm α r] {l₁ l₂ : list α} (p : list.perm l₁ l₂) (s₁ : sorted r l₁)\n    (s₂ : sorted r l₂) : l₁ = l₂ :=\n  by\n  induction' s₁ with a l₁ h₁ s₁ IH generalizing l₂\n  · exact p.nil_eq\n  · have : a ∈ l₂ := p.subset (mem_cons_self _ _)\n    rcases mem_split this with ⟨u₂, v₂, rfl⟩\n    have p' := (perm_cons a).1 (p.trans perm_middle)\n    obtain rfl := IH p' (s₂.sublist <| by simp)\n    change a :: u₂ ++ v₂ = u₂ ++ ([a] ++ v₂)\n    rw [← append_assoc]\n    congr\n    have : ∀ (x : α) (h : x ∈ u₂), x = a := fun x m =>\n      antisymm ((pairwise_append.1 s₂).2.2 _ m a (mem_cons_self _ _)) (h₁ _ (by simp [m]))\n    rw [(@eq_replicate _ a (length u₂ + 1) (a :: u₂)).2, (@eq_replicate _ a (length u₂ + 1) (u₂ ++ [a])).2] <;>\n        constructor <;>\n      simp [iff_true_intro this, or_comm']\n#align eq_of_perm_of_sorted eq_of_perm_of_sorted\n\n"}