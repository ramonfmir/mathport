{"two_mul_card_image_off_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem two_mul_card_image_off_diag (s : Finset α) : 2 * (s.off_diag.image Quotient.mk'').card = s.off_diag.card :=\n  by\n  rw [card_eq_sum_card_fiberwise\n      (fun x => mem_image_of_mem _ : ∀ x ∈ s.off_diag, Quotient.mk'' x ∈ s.off_diag.image Quotient.mk''),\n    sum_const_nat (quotient.ind _), mul_comm]\n  rintro ⟨x, y⟩ hxy\n  simp_rw [mem_image, exists_prop, mem_off_diag, quotient.eq] at hxy\n  obtain ⟨a, ⟨ha₁, ha₂, ha⟩, h⟩ := hxy\n  obtain ⟨hx, hy, hxy⟩ : x ∈ s ∧ y ∈ s ∧ x ≠ y := by cases h <;> have := ha.symm <;> exact ⟨‹_›, ‹_›, ‹_›⟩\n  have hxy' : y ≠ x := hxy.symm\n  have : (s.off_diag.filter fun z => «expr⟦ ⟧» z = «expr⟦ ⟧» (x, y)) = ({(x, y), (y, x)} : Finset _) :=\n    by\n    ext ⟨x₁, y₁⟩\n    rw [mem_filter, mem_insert, mem_singleton, sym2.eq_iff, prod.mk.inj_iff, prod.mk.inj_iff, and_iff_right_iff_imp]\n    rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) <;> rw [mem_off_diag] <;> exact ⟨‹_›, ‹_›, ‹_›⟩\n  -- hxy' is used here\n  rw [this, card_insert_of_not_mem, card_singleton]\n  simp only [not_and, prod.mk.inj_iff, mem_singleton]\n  exact fun _ => hxy'\n#align two_mul_card_image_off_diag two_mul_card_image_off_diag\n\n",
 "card_sym_fin_eq_multichoose":
 "/-\nCopyright (c) 2021 Yaël Dillies, Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies, Bhavik Mehta, Huỳnh Trần Khanh, Stuart Presnell\n-/\ntheorem card_sym_fin_eq_multichoose (n k : ℕ) : card (sym (fin n) k) = multichoose n k :=\n  by\n  apply @pincer_recursion fun n k => card (sym (fin n) k) = multichoose n k\n  · simp\n  · intro b\n    induction' b with b IHb\n    · simp\n    rw [multichoose_zero_succ, card_eq_zero_iff]\n    infer_instance\n  · intro x y h1 h2\n    rw [multichoose_succ_succ, ← h1, ← h2, add_comm]\n    cases x\n    · simp only [card_eq_zero_iff, card_unique, self_eq_add_right]\n      infer_instance\n    rw [← card_sum]\n    refine' fintype.card_congr (equiv.symm _)\n    apply (Equiv.sumCongr sym.E1.symm sym.E2.symm).trans\n    apply Equiv.sumCompl\n#align card_sym_fin_eq_multichoose card_sym_fin_eq_multichoose\n\n",
 "card_sym_eq_multichoose":
 "/-- For any fintype `α` of cardinality `n`, `card (sym α k) = multichoose (card α) k` -/\ntheorem card_sym_eq_multichoose (α : Type _) (k : ℕ) [fintype α] [fintype (sym α k)] :\n    card (sym α k) = multichoose (card α) k :=\n  by\n  rw [← card_sym_fin_eq_multichoose]\n  exact card_congr (equiv_congr (equiv_fin α))\n#align card_sym_eq_multichoose card_sym_eq_multichoose\n\n",
 "card_sym_eq_choose":
 "/-- The *stars and bars* lemma: the cardinality of `sym α k` is equal to\n`nat.choose (card α + k - 1) k`. -/\ntheorem card_sym_eq_choose {α : Type _} [fintype α] (k : ℕ) [fintype (sym α k)] :\n    card (sym α k) = (card α + k - 1).choose k := by rw [card_sym_eq_multichoose, Nat.multichoose_eq]\n#align card_sym_eq_choose card_sym_eq_choose\n\n",
 "card_sym2":
 "/-- Finset **stars and bars** for the case `n = 2`. -/\ntheorem _root_.finset.card_sym2 (s : Finset α) : s.sym2.card = s.card * (s.card + 1) / 2 :=\n  by\n  rw [← image_diag_union_image_off_diag, card_union_eq, sym2.card_image_diag, sym2.card_image_off_diag,\n    Nat.choose_two_right, add_comm, ← Nat.triangle_succ, nat.succ_sub_one, mul_comm]\n  rw [disjoint_left]\n  rintro m ha hb\n  rw [mem_image] at ha hb\n  obtain ⟨⟨a, ha, rfl⟩, ⟨b, hb, hab⟩⟩ := ha, hb\n  refine' not_is_diag_mk_of_mem_off_diag hb _\n  rw [hab]\n  exact is_diag_mk_of_mem_diag ha\n#align finset.card_sym2 finset.card_sym2\n\n",
 "card_subtype_not_diag":
 "theorem card_subtype_not_diag [fintype α] : card { a : sym2 α // ¬a.is_diag } = (card α).choose 2 :=\n  by\n  convert card_image_off_diag (univ : Finset α)\n  rw [fintype.card_of_subtype, ← filter_image_quotient_mk_not_is_diag]\n  rintro x\n  rw [mem_filter, univ_product_univ, mem_image]\n  obtain ⟨a, ha⟩ := quotient.exists_rep x\n  exact and_iff_right ⟨a, mem_univ _, ha⟩\n#align card_subtype_not_diag card_subtype_not_diag\n\n",
 "card_subtype_diag":
 "theorem card_subtype_diag [fintype α] : card { a : sym2 α // a.is_diag } = card α :=\n  by\n  convert card_image_diag (univ : Finset α)\n  rw [fintype.card_of_subtype, ← filter_image_quotient_mk_is_diag]\n  rintro x\n  rw [mem_filter, univ_product_univ, mem_image]\n  obtain ⟨a, ha⟩ := quotient.exists_rep x\n  exact and_iff_right ⟨a, mem_univ _, ha⟩\n#align card_subtype_diag card_subtype_diag\n\n",
 "card_image_off_diag":
 "/-- The `off_diag` of `s : finset α` is sent on a finset of `sym2 α` of card `s.off_diag.card / 2`.\nThis is because every element `⟦(x, y)⟧` of `sym2 α` not on the diagonal comes from exactly two\npairs: `(x, y)` and `(y, x)`. -/\ntheorem card_image_off_diag (s : Finset α) : (s.off_diag.image Quotient.mk'').card = s.card.choose 2 := by\n  rw [Nat.choose_two_right, mul_tsub, mul_one, ← off_diag_card,\n    Nat.div_eq_of_eq_mul_right zero_lt_two (two_mul_card_image_off_diag s).symm]\n#align card_image_off_diag card_image_off_diag\n\n",
 "card_image_diag":
 "/-- The `diag` of `s : finset α` is sent on a finset of `sym2 α` of card `s.card`. -/\ntheorem card_image_diag (s : Finset α) : (s.diag.image Quotient.mk'').card = s.card :=\n  by\n  rw [card_image_of_inj_on, diag_card]\n  rintro ⟨x₀, x₁⟩ hx _ _ h\n  cases quotient.eq.1 h\n  · rfl\n  · simp only [mem_coe, mem_diag] at hx\n    rw [hx.2]\n#align card_image_diag card_image_diag\n\n",
 "card":
 "/-- Type **stars and bars** for the case `n = 2`. -/\nprotected theorem card [fintype α] : card (sym2 α) = card α * (card α + 1) / 2 :=\n  finset.card_sym2 _\n#align card card\n\n"}