{"to_lex_update_lt_self_iff":
 "@[simp]\ntheorem to_lex_update_lt_self_iff : to_lex (update x i a) < to_lex x ↔ a < x i :=\n  by\n  refine' ⟨_, fun h => to_lex_strict_mono <| update_lt_self_iff.2 h⟩\n  rintro ⟨j, hj, h⟩\n  dsimp at h\n  obtain rfl : j = i := by\n    by_contra H\n    rw [update_noteq H] at h\n    exact h.false\n  · rwa [update_same] at h\n#align to_lex_update_lt_self_iff to_lex_update_lt_self_iff\n\n",
 "to_lex_update_le_self_iff":
 "@[simp]\ntheorem to_lex_update_le_self_iff : to_lex (update x i a) ≤ to_lex x ↔ a ≤ x i := by\n  simp_rw [le_iff_lt_or_eq, to_lex_update_lt_self_iff, toLex_inj, update_eq_self_iff]\n#align to_lex_update_le_self_iff to_lex_update_le_self_iff\n\n",
 "to_lex_strict_mono":
 "theorem to_lex_strict_mono : strict_mono (@to_lex (∀ i, β i)) := fun a b h =>\n  let ⟨i, hi, hl⟩ := is_well_founded.wf.has_min { i | a i ≠ b i } (function.ne_iff.1 h.ne)\n  ⟨i, fun j hj => by\n    contrapose! hl\n    exact ⟨j, hl, hj⟩, (h.le i).lt_of_ne hi⟩\n#align to_lex_strict_mono to_lex_strict_mono\n\n",
 "to_lex_monotone":
 "theorem to_lex_monotone : monotone (@to_lex (∀ i, β i)) := fun a b h =>\n  or_iff_not_imp_left.2 fun hne =>\n    let ⟨i, hi, hl⟩ := is_well_founded.wf.has_min { i | a i ≠ b i } (function.ne_iff.1 hne)\n    ⟨i, fun j hj => by\n      contrapose! hl\n      exact ⟨j, hl, hj⟩, (h i).lt_of_ne hi⟩\n#align to_lex_monotone to_lex_monotone\n\n",
 "to_lex_apply":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/- This unfortunately results in a type that isn't delta-reduced, so we keep the notation out of the\nbasic API, just in case -/\n@[simp]\ntheorem to_lex_apply (x : ∀ i, β i) (i : ι) : to_lex x i = x i :=\n  rfl\n#align to_lex_apply to_lex_apply\n\n",
 "of_lex_apply":
 "@[simp]\ntheorem of_lex_apply (x : lex (∀ i, β i)) (i : ι) : of_lex x i = x i :=\n  rfl\n#align of_lex_apply of_lex_apply\n\n",
 "no_max_order'":
 "theorem lex.no_max_order' [preorder ι] [∀ i, LT (β i)] (i : ι) [NoMaxOrder (β i)] : NoMaxOrder (lex (∀ i, β i)) :=\n  ⟨fun a =>\n    let ⟨b, hb⟩ := exists_gt (a i)\n    ⟨a.update i b, i, fun j hj => (a.update_noteq hj.ne b).symm, by rwa [a.update_same i b]⟩⟩\n#align lex.no_max_order' lex.no_max_order'\n\n",
 "lt_to_lex_update_self_iff":
 "@[simp]\ntheorem lt_to_lex_update_self_iff : to_lex x < to_lex (update x i a) ↔ x i < a :=\n  by\n  refine' ⟨_, fun h => to_lex_strict_mono <| lt_update_self_iff.2 h⟩\n  rintro ⟨j, hj, h⟩\n  dsimp at h\n  obtain rfl : j = i := by\n    by_contra H\n    rw [update_noteq H] at h\n    exact h.false\n  · rwa [update_same] at h\n#align lt_to_lex_update_self_iff lt_to_lex_update_self_iff\n\n",
 "lex_lt_of_lt_of_preorder":
 "theorem lex_lt_of_lt_of_preorder [∀ i, preorder (β i)] {r} (hwf : well_founded r) {x y : ∀ i, β i} (hlt : x < y) :\n    ∃ i, (∀ j, r j i → x j ≤ y j ∧ y j ≤ x j) ∧ x i < y i :=\n  let h' := Pi.lt_def.1 hlt\n  let ⟨i, hi, hl⟩ := hwf.has_min _ h'.2\n  ⟨i, fun j hj => ⟨h'.1 j, not_not.1 fun h => hl j (lt_of_le_not_le (h'.1 j) h) hj⟩, hi⟩\n#align lex_lt_of_lt_of_preorder lex_lt_of_lt_of_preorder\n\n",
 "lex_lt_of_lt":
 "theorem lex_lt_of_lt [∀ i, partial_order (β i)] {r} (hwf : well_founded r) {x y : ∀ i, β i} (hlt : x < y) :\n    Pi.Lex r (fun i => (· < ·)) x y := by\n  simp_rw [Pi.Lex, le_antisymm_iff]\n  exact lex_lt_of_lt_of_preorder hwf hlt\n#align lex_lt_of_lt lex_lt_of_lt\n\n",
 "lex_desc":
 "--we might want the analog of `pi.ordered_cancel_comm_monoid` as well in the future\n/-- If we swap two strictly decreasing values in a function, then the result is lexicographically\nsmaller than the original function. -/\ntheorem lex_desc {α} [preorder ι] [decidable_eq ι] [preorder α] {f : ι → α} {i j : ι} (h₁ : i < j) (h₂ : f j < f i) :\n    to_lex (f ∘ Equiv.swap i j) < to_lex f :=\n  ⟨i, fun k hik => congr_arg f (Equiv.swap_apply_of_ne_of_ne hik.ne (hik.trans h₁).ne), by\n    simpa only [Pi.toLex_apply, Function.comp_apply, Equiv.swap_apply_left] using h₂⟩\n#align lex_desc lex_desc\n\n",
 "le_to_lex_update_self_iff":
 "@[simp]\ntheorem le_to_lex_update_self_iff : to_lex x ≤ to_lex (update x i a) ↔ x i ≤ a := by\n  simp_rw [le_iff_lt_or_eq, lt_to_lex_update_self_iff, toLex_inj, eq_update_self_iff]\n#align le_to_lex_update_self_iff le_to_lex_update_self_iff\n\n",
 "is_trichotomous_lex":
 "theorem is_trichotomous_lex [∀ i, is_trichotomous (β i) s] (wf : well_founded r) :\n    is_trichotomous (∀ i, β i) (Pi.Lex r @s) :=\n  {\n    trichotomous := fun a b => by\n      cases' eq_or_ne a b with hab hab\n      · exact or.inr (or.inl hab)\n      · rw [function.ne_iff] at hab\n        let i := wf.min _ hab\n        have hri : ∀ j, r j i → a j = b j := by\n          intro j\n          rw [← not_imp_not]\n          exact fun h' => wf.not_lt_min _ _ h'\n        have hne : a i ≠ b i := wf.min_mem _ hab\n        cases' trichotomous_of s (a i) (b i) with hi hi\n        exacts[or.inl ⟨i, hri, hi⟩, or.inr <| or.inr <| ⟨i, fun j hj => (hri j hj).symm, hi.resolve_left hne⟩] }\n#align is_trichotomous_lex is_trichotomous_lex\n\n"}