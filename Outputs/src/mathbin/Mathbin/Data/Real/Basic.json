{"zero_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print zero_lt_one /-\nprotected theorem zero_lt_one : (0 : exprℝ) < 1 := by\n  convert rat_cast_lt.2 zero_lt_one <;> simp [← of_cauchy_rat_cast, of_cauchy_one, of_cauchy_zero]\n#align zero_lt_one zero_lt_one\n-/\n\n",
 "supₛ_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print supₛ_univ /-\ntheorem supₛ_univ : supₛ (@Set.univ (exprℝ)) = 0 :=\n  real.Sup_of_not_bdd_above fun ⟨x, h⟩ => not_le_of_lt (lt_add_one _) <| h (Set.mem_univ _)\n#align Sup_univ supₛ_univ\n-/\n\n",
 "supₛ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print supₛ_empty /-\n@[simp]\ntheorem supₛ_empty : supₛ (∅ : set (exprℝ)) = 0 :=\n  dif_neg <| by simp\n#align Sup_empty supₛ_empty\n-/\n\n",
 "supr_of_not_bdd_above":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_of_not_bdd_above {α : Sort _} {f : α → exprℝ} (hf : ¬BddAbove (Set.range f)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = 0 :=\n  Sup_of_not_bdd_above hf\n#align supr_of_not_bdd_above supr_of_not_bdd_above\n\n",
 "rat_cast_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { md := tactic.transparency.semireducible[tactic.transparency.semireducible] } -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem rat_cast_lt {x y : exprℚ} : (x : exprℝ) < (y : exprℝ) ↔ x < y :=\n  by\n  rw [mk_lt]\n  exact const_lt\n#align rat_cast_lt rat_cast_lt\n\n",
 "of_rat_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Floris van Doorn\n-/\n-- this can't go in `data.real.cau_seq_completion` as the structure on `rat` isn't available\n@[simp]\ntheorem of_rat_rat {abv : exprℚ → exprℚ} [IsAbsoluteValue abv] (q : exprℚ) :\n    ofRat (q : exprℚ) = (q : @Cauchy _ _ _ _ abv _) :=\n  rfl\n#align of_rat_rat of_rat_rat\n\n",
 "of_near":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_near (f : ℕ → exprℚ) (x : exprℝ) (h : ∀ ε > 0, ∃ i, ∀ j ≥ i, |(f j : exprℝ) - x| < ε) :\n    ∃ h', real.mk ⟨f, h'⟩ = x :=\n  ⟨is_cau_seq_iff_lift.2 (of_near _ (const abs x) h),\n    sub_eq_zero.1 <|\n      abs_eq_zero.1 <|\n        eq_of_le_of_forall_le_of_dense (abs_nonneg _) fun ε ε0 =>\n          mk_near_of_forall_near <| (h _ ε0).imp fun i h j ij => le_of_lt (h j ij)⟩\n#align of_near of_near\n\n",
 "of_cauchy_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- irreducible doesn't work for instances: https://github.com/leanprover-community/lean/issues/511\ntheorem of_cauchy_zero : (⟨0⟩ : exprℝ) = 0 :=\n  show _ = zero by rw [zero]\n#align of_cauchy_zero of_cauchy_zero\n\n",
 "of_cauchy_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem of_cauchy_sup (a b) : (⟨«expr⟦ ⟧» («expr ⊔ » a b)⟩ : exprℝ) = «expr ⊔ » ⟨«expr⟦ ⟧» a⟩ ⟨«expr⟦ ⟧» b⟩ :=\n  show _ = sup _ _ by\n    rw [sup]\n    rfl\n#align of_cauchy_sup of_cauchy_sup\n\n",
 "of_cauchy_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_sub (a b) : (⟨a - b⟩ : exprℝ) = ⟨a⟩ - ⟨b⟩ :=\n  by\n  rw [sub_eq_add_neg, of_cauchy_add, of_cauchy_neg]\n  rfl\n#align of_cauchy_sub of_cauchy_sub\n\n",
 "of_cauchy_rat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_rat_cast (q : exprℚ) : (⟨q⟩ : exprℝ) = q :=\n  rfl\n#align of_cauchy_rat_cast of_cauchy_rat_cast\n\n",
 "of_cauchy_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_one : (⟨1⟩ : exprℝ) = 1 :=\n  show _ = one by rw [one]\n#align of_cauchy_one of_cauchy_one\n\n",
 "of_cauchy_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_neg (a) : (⟨-a⟩ : exprℝ) = -⟨a⟩ :=\n  show _ = neg _ by rw [neg]\n#align of_cauchy_neg of_cauchy_neg\n\n",
 "of_cauchy_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_nat_cast (n : ℕ) : (⟨n⟩ : exprℝ) = n :=\n  rfl\n#align of_cauchy_nat_cast of_cauchy_nat_cast\n\n",
 "of_cauchy_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_mul (a b) : (⟨a * b⟩ : exprℝ) = ⟨a⟩ * ⟨b⟩ :=\n  show _ = mul _ _ by rw [mul]\n#align of_cauchy_mul of_cauchy_mul\n\n",
 "of_cauchy_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_inv {f} : (⟨f⁻¹⟩ : exprℝ) = ⟨f⟩⁻¹ :=\n  show _ = inv' _ by rw [inv']\n#align of_cauchy_inv of_cauchy_inv\n\n",
 "of_cauchy_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_int_cast (z : ℤ) : (⟨z⟩ : exprℝ) = z :=\n  rfl\n#align of_cauchy_int_cast of_cauchy_int_cast\n\n",
 "of_cauchy_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem of_cauchy_inf (a b) : (⟨«expr⟦ ⟧» («expr ⊓ » a b)⟩ : exprℝ) = «expr ⊓ » ⟨«expr⟦ ⟧» a⟩ ⟨«expr⟦ ⟧» b⟩ :=\n  show _ = inf _ _ by\n    rw [inf]\n    rfl\n#align of_cauchy_inf of_cauchy_inf\n\n",
 "of_cauchy_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem of_cauchy_add (a b) : (⟨a + b⟩ : exprℝ) = ⟨a⟩ + ⟨b⟩ :=\n  show _ = add _ _ by rw [add]\n#align of_cauchy_add of_cauchy_add\n\n",
 "mul_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print mul_pos /-\nprotected theorem mul_pos {a b : exprℝ} : 0 < a → 0 < b → 0 < a * b :=\n  by\n  induction' a using real.ind_mk with a\n  induction' b using real.ind_mk with b\n  simpa only [mk_lt, mk_pos, ← mk_mul] using CauSeq.mul_pos\n#align mul_pos mul_pos\n-/\n\n",
 "mk_zero":
 "theorem mk_zero : mk 0 = 0 := by rw [← of_cauchy_zero] <;> rfl\n#align mk_zero mk_zero\n\n",
 "mk_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem mk_sup (a b) : (mk («expr ⊔ » a b) : exprℝ) = «expr ⊔ » (mk a) (mk b) :=\n  of_cauchy_sup _ _\n#align mk_sup mk_sup\n\n",
 "mk_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem mk_pos {f : CauSeq (exprℚ) abs} : 0 < mk f ↔ pos f := by\n  rw [← mk_zero, mk_lt] <;> exact iff_of_eq (congr_arg pos (sub_zero f))\n#align mk_pos mk_pos\n\n",
 "mk_one":
 "theorem mk_one : mk 1 = 1 := by rw [← of_cauchy_one] <;> rfl\n#align mk_one mk_one\n\n",
 "mk_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mk_neg {f : CauSeq (exprℚ) abs} : mk (-f) = -mk f := by simp [mk, ← of_cauchy_neg]\n#align mk_neg mk_neg\n\n",
 "mk_near_of_forall_near":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mk_near_of_forall_near {f : CauSeq (exprℚ) abs} {x : exprℝ} {ε : exprℝ}\n    (H : ∃ i, ∀ j ≥ i, |(f j : exprℝ) - x| ≤ ε) : |mk f - x| ≤ ε :=\n  abs_sub_le_iff.2\n    ⟨sub_le_iff_le_add'.2 <|\n        mk_le_of_forall_le <| H.imp fun i h j ij => sub_le_iff_le_add'.1 (abs_sub_le_iff.1 <| h j ij).1,\n      sub_le_comm.1 <| le_mk_of_forall_le <| H.imp fun i h j ij => sub_le_comm.1 (abs_sub_le_iff.1 <| h j ij).2⟩\n#align mk_near_of_forall_near mk_near_of_forall_near\n\n",
 "mk_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mk_mul {f g : CauSeq (exprℚ) abs} : mk (f * g) = mk f * mk g := by simp [mk, ← of_cauchy_mul]\n#align mk_mul mk_mul\n\n",
 "mk_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem mk_lt {f g : CauSeq (exprℚ) abs} : mk f < mk g ↔ f < g :=\n  lt_cauchy\n#align mk_lt mk_lt\n\n",
 "mk_le_of_forall_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mk_le_of_forall_le {f : CauSeq (exprℚ) abs} {x : exprℝ} (h : ∃ i, ∀ j ≥ i, (f j : exprℝ) ≤ x) : mk f ≤ x :=\n  by\n  cases' h with i H\n  rw [← neg_le_neg_iff, ← mk_neg]\n  exact le_mk_of_forall_le ⟨i, fun j ij => by simp [H _ ij]⟩\n#align mk_le_of_forall_le mk_le_of_forall_le\n\n",
 "mk_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem mk_le {f g : CauSeq (exprℚ) abs} : mk f ≤ mk g ↔ f ≤ g := by simp [le_def, mk_eq] <;> rfl\n#align mk_le mk_le\n\n",
 "mk_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mk_inf (a b) : (mk («expr ⊓ » a b) : exprℝ) = «expr ⊓ » (mk a) (mk b) :=\n  of_cauchy_inf _ _\n#align mk_inf mk_inf\n\n",
 "mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mk_eq {f g : CauSeq (exprℚ) abs} : mk f = mk g ↔ f ≈ g :=\n  ext_cauchy_iff.trans mk_eq\n#align mk_eq mk_eq\n\n",
 "mk_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mk_add {f g : CauSeq (exprℚ) abs} : mk (f + g) = mk f + mk g := by simp [mk, ← of_cauchy_add]\n#align mk_add mk_add\n\n",
 "lt_cauchy":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\ntheorem lt_cauchy {f g} : (⟨«expr⟦ ⟧» f⟩ : exprℝ) < ⟨«expr⟦ ⟧» g⟩ ↔ f < g :=\n  show lt _ _ ↔ _ by rw [lt] <;> rfl\n#align lt_cauchy lt_cauchy\n\n",
 "lt_Inf_add_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem lt_Inf_add_pos {s : set (exprℝ)} (h : s.nonempty) {ε : exprℝ} (hε : 0 < ε) : ∃ a ∈ s, a < infₛ s + ε :=\n  exists_lt_of_cinfₛ_lt h <| lt_add_of_pos_right _ hε\n#align lt_Inf_add_pos lt_Inf_add_pos\n\n",
 "le_supₛ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print le_supₛ_iff /-\ntheorem le_supₛ_iff {s : set (exprℝ)} (h : BddAbove s) (h' : s.nonempty) {a : exprℝ} :\n    a ≤ supₛ s ↔ ∀ ε, ε < 0 → ∃ x ∈ s, a + ε < x :=\n  by\n  rw [le_iff_forall_pos_lt_add]\n  refine' ⟨fun H ε ε_neg => _, fun H ε ε_pos => _⟩\n  · exact exists_lt_of_lt_csupₛ h' (lt_sub_iff_add_lt.mp (H _ (neg_pos.mpr ε_neg)))\n  · rcases H _ (neg_lt_zero.mpr ε_pos) with ⟨x, x_in, hx⟩\n    exact sub_lt_iff_lt_add.mp (lt_csupₛ_of_lt h x_in hx)\n#align le_Sup_iff le_supₛ_iff\n-/\n\n",
 "le_mk_of_forall_le":
 "/- ./././Mathport/Syntax/Translate/Tactic/Lean3.lean:132:4: warning: unsupported: rw with cfg: { md := tactic.transparency.semireducible[tactic.transparency.semireducible] } -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- Extra instances to short-circuit type class resolution \n-- Extra instances to short-circuit type class resolution \n-- Extra instances to short-circuit type class resolution\ntheorem le_mk_of_forall_le {f : CauSeq (exprℚ) abs} : (∃ i, ∀ j ≥ i, x ≤ f j) → x ≤ mk f :=\n  by\n  intro h\n  induction' x using real.ind_mk with x\n  apply le_of_not_lt\n  rw [mk_lt]\n  rintro ⟨K, K0, hK⟩\n  obtain ⟨i, H⟩ := exists_forall_ge_and h (exists_forall_ge_and hK (f.cauchy₃ <| half_pos K0))\n  apply not_lt_of_le (H _ le_rfl).1\n  rw [mk_lt]\n  refine' ⟨_, half_pos K0, i, fun j ij => _⟩\n  have := add_le_add (H _ ij).2.1 (le_of_lt (abs_lt.1 <| (H _ le_rfl).2.2 _ ij).1)\n  rwa [← sub_eq_add_neg, sub_self_div_two, sub_apply, sub_add_sub_cancel] at this\n#align le_mk_of_forall_le le_mk_of_forall_le\n\n",
 "le_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprivate theorem le_def {x y : exprℝ} : x ≤ y ↔ x < y ∨ x = y :=\n  show le _ _ ↔ _ by rw [le]\n#align le_def le_def\n\n",
 "is_cau_seq_iff_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem is_cau_seq_iff_lift {f : ℕ → exprℚ} : IsCauSeq abs f ↔ IsCauSeq abs fun i => (f i : exprℝ) :=\n  ⟨fun H ε ε0 =>\n    let ⟨δ, δ0, δε⟩ := exists_pos_rat_lt ε0\n    (H _ δ0).imp fun i hi j ij => lt_trans (by simpa using (@Rat.cast_lt (exprℝ) _ _ _).2 (hi _ ij)) δε,\n    fun H ε ε0 =>\n    (H _ (Rat.cast_pos.2 ε0)).imp fun i hi j ij => (@Rat.cast_lt (exprℝ) _ _ _).1 <| by simpa using hi _ ij⟩\n#align is_cau_seq_iff_lift is_cau_seq_iff_lift\n\n",
 "isLUB_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print isLUB_supₛ /-\nprotected theorem isLUB_supₛ (S : set (exprℝ)) (h₁ : S.nonempty) (h₂ : BddAbove S) : IsLUB S (supₛ S) :=\n  by\n  simp only [Sup_def, dif_pos (and.intro h₁ h₂)]\n  apply Classical.choose_spec\n#align is_lub_Sup isLUB_supₛ\n-/\n\n",
 "isGLB_infₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print isGLB_infₛ /-\nprotected theorem isGLB_infₛ (S : set (exprℝ)) (h₁ : S.nonempty) (h₂ : BddBelow S) : IsGLB S (infₛ S) :=\n  by\n  rw [Inf_def, ← isLUB_neg', neg_neg]\n  exact real.is_lub_Sup _ h₁.neg h₂.neg\n#align is_glb_Inf isGLB_infₛ\n-/\n\n",
 "infₛ_le_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print infₛ_le_supₛ /-\ntheorem infₛ_le_supₛ (s : set (exprℝ)) (h₁ : BddBelow s) (h₂ : BddAbove s) : infₛ s ≤ supₛ s :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · rw [infₛ_empty, supₛ_empty]\n  · exact cinfₛ_le_csupₛ h₁ h₂ hne\n#align Inf_le_Sup infₛ_le_supₛ\n-/\n\n",
 "infₛ_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print infₛ_le_iff /-\ntheorem infₛ_le_iff {s : set (exprℝ)} (h : BddBelow s) (h' : s.nonempty) {a : exprℝ} :\n    infₛ s ≤ a ↔ ∀ ε, 0 < ε → ∃ x ∈ s, x < a + ε :=\n  by\n  rw [le_iff_forall_pos_lt_add]\n  constructor <;> intro H ε ε_pos\n  · exact exists_lt_of_cinfₛ_lt h' (H ε ε_pos)\n  · rcases H ε ε_pos with ⟨x, x_in, hx⟩\n    exact cinfₛ_lt_of_lt h x_in hx\n#align Inf_le_iff infₛ_le_iff\n-/\n\n",
 "infₛ_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print infₛ_empty /-\n@[simp]\ntheorem infₛ_empty : infₛ (∅ : set (exprℝ)) = 0 := by simp [Inf_def, supₛ_empty]\n#align Inf_empty infₛ_empty\n-/\n\n",
 "infi_of_not_bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_of_not_bdd_below {α : Sort _} {f : α → exprℝ} (hf : ¬BddBelow (Set.range f)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) = 0 :=\n  Inf_of_not_bdd_below hf\n#align infi_of_not_bdd_below infi_of_not_bdd_below\n\n",
 "ind_mk":
 "@[elab_as_elim]\nprotected theorem ind_mk {C : real → Prop} (x : real) (h : ∀ y, C (mk y)) : C x :=\n  by\n  cases' x with x\n  induction' x using Quot.inductionOn with x\n  exact h x\n#align ind_mk ind_mk\n\n",
 "fact_zero_lt_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\nprotected theorem fact_zero_lt_one : fact ((0 : exprℝ) < 1) :=\n  ⟨real.zero_lt_one⟩\n#align fact_zero_lt_one fact_zero_lt_one\n\n",
 "ext_cauchy_iff":
 "theorem ext_cauchy_iff : ∀ {x y : real}, x = y ↔ x.cauchy = y.cauchy\n  | ⟨a⟩, ⟨b⟩ => by constructor <;> cc\n#align ext_cauchy_iff ext_cauchy_iff\n\n",
 "ext_cauchy":
 "theorem ext_cauchy {x y : real} : x.cauchy = y.cauchy → x = y :=\n  ext_cauchy_iff.2\n#align ext_cauchy ext_cauchy\n\n",
 "exists_is_lub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (j k «expr ≥ » «expr⌈ ⌉₊»(«expr ⁻¹»(ε))) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem exists_is_lub (S : set (exprℝ)) (hne : S.nonempty) (hbdd : BddAbove S) : ∃ x, IsLUB S x :=\n  by\n  rcases hne, hbdd with ⟨⟨L, hL⟩, ⟨U, hU⟩⟩\n  have : ∀ d : ℕ, BddAbove { m : ℤ | ∃ y ∈ S, (m : exprℝ) ≤ y * d } :=\n    by\n    cases' exists_int_gt U with k hk\n    refine' fun d => ⟨k * d, fun z h => _⟩\n    rcases h with ⟨y, yS, hy⟩\n    refine' Int.cast_le.1 (hy.trans _)\n    push_cast\n    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg\n  choose f hf using fun d : ℕ => Int.exists_greatest_of_bdd (this d) ⟨«expr⌊ ⌋» (L * d), L, hL, Int.floor_le _⟩\n  have hf₁ : ∀ n > 0, ∃ y ∈ S, ((f n / n : exprℚ) : exprℝ) ≤ y := fun n n0 =>\n    let ⟨y, yS, hy⟩ := (hf n).1\n    ⟨y, yS, by simpa using (div_le_iff (nat.cast_pos.2 n0 : (_ : exprℝ) < _)).2 hy⟩\n  have hf₂ : ∀ n > 0, ∀ y ∈ S, (y - (n : ℕ)⁻¹ : exprℝ) < (f n / n : exprℚ) :=\n    by\n    intro n n0 y yS\n    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ ⟨y, yS, Int.floor_le _⟩)\n    simp [-sub_eq_add_neg]\n    rwa [lt_div_iff (nat.cast_pos.2 n0 : (_ : exprℝ) < _), sub_mul, _root_.inv_mul_cancel]\n    exact ne_of_gt (nat.cast_pos.2 n0)\n  have hg : IsCauSeq abs (fun n => f n / n : ℕ → exprℚ) :=\n    by\n    intro ε ε0\n    suffices ∀ (j) (_ : j ≥ «expr⌈ ⌉₊» ε⁻¹) (k) (_ : k ≥ «expr⌈ ⌉₊» ε⁻¹), (f j / j - f k / k : exprℚ) < ε\n      by\n      refine' ⟨_, fun j ij => abs_lt.2 ⟨_, this _ ij _ le_rfl⟩⟩\n      rw [neg_lt, neg_sub]\n      exact this _ le_rfl _ ij\n    intro j ij k ik\n    replace ij := le_trans (Nat.le_ceil _) (nat.cast_le.2 ij)\n    replace ik := le_trans (Nat.le_ceil _) (nat.cast_le.2 ik)\n    have j0 := nat.cast_pos.1 ((inv_pos.2 ε0).trans_le ij)\n    have k0 := nat.cast_pos.1 ((inv_pos.2 ε0).trans_le ik)\n    rcases hf₁ _ j0 with ⟨y, yS, hy⟩\n    refine' lt_of_lt_of_le ((@Rat.cast_lt (exprℝ) _ _ _).1 _) ((inv_le ε0 (nat.cast_pos.2 k0)).1 ik)\n    simpa using sub_lt_iff_lt_add'.2 (lt_of_le_of_lt hy <| sub_lt_iff_lt_add.1 <| hf₂ _ k0 _ yS)\n  let g : CauSeq (exprℚ) abs := ⟨fun n => f n / n, hg⟩\n  refine' ⟨mk g, ⟨fun x xS => _, fun y h => _⟩⟩\n  · refine' le_of_forall_ge_of_dense fun z xz => _\n    cases' exists_nat_gt (x - z)⁻¹ with K hK\n    refine' le_mk_of_forall_le ⟨K, fun n nK => _⟩\n    replace xz := sub_pos.2 xz\n    replace hK := hK.le.trans (nat.cast_le.2 nK)\n    have n0 : 0 < n := nat.cast_pos.1 ((inv_pos.2 xz).trans_le hK)\n    refine' le_trans _ (hf₂ _ n0 _ xS).le\n    rwa [le_sub_comm, inv_le (nat.cast_pos.2 n0 : (_ : exprℝ) < _) xz]\n  ·\n    exact\n      mk_le_of_forall_le\n        ⟨1, fun n n1 =>\n          let ⟨x, xS, hx⟩ := hf₁ _ n1\n          le_trans hx (h xS)⟩\n#align exists_is_lub exists_is_lub\n\n",
 "exists_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print exists_floor /-\ntheorem exists_floor (x : exprℝ) : ∃ ub : ℤ, (ub : exprℝ) ≤ x ∧ ∀ z : ℤ, (z : exprℝ) ≤ x → z ≤ ub :=\n  Int.exists_greatest_of_bdd\n    (let ⟨n, hn⟩ := exists_int_gt x\n    ⟨n, fun z h' => Int.cast_le.1 <| le_trans h' <| le_of_lt hn⟩)\n    (let ⟨n, hn⟩ := exists_int_lt x\n    ⟨n, le_of_lt hn⟩)\n#align exists_floor exists_floor\n-/\n\n",
 "csupr_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem csupr_empty {α : Sort _} [is_empty α] (f : α → exprℝ) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) = 0 :=\n  by\n  dsimp [supᵢ]\n  convert real.Sup_empty\n  rw [Set.range_eq_empty_iff]\n  infer_instance\n#align csupr_empty csupr_empty\n\n",
 "csupr_const_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem csupr_const_zero {α : Sort _} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (0 : exprℝ) = 0 :=\n  by\n  cases isEmpty_or_nonempty α\n  · exact real.csupr_empty _\n  · exact csupᵢ_const\n#align csupr_const_zero csupr_const_zero\n\n",
 "cinfi_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem cinfi_empty {α : Sort _} [is_empty α] (f : α → exprℝ) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i) = 0 := by\n  rw [infᵢ_of_empty', infₛ_empty]\n#align cinfi_empty cinfi_empty\n\n",
 "cinfi_const_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem cinfi_const_zero {α : Sort _} :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (0 : exprℝ) = 0 :=\n  by\n  cases isEmpty_or_nonempty α\n  · exact real.cinfi_empty _\n  · exact cinfᵢ_const\n#align cinfi_const_zero cinfi_const_zero\n\n",
 "cauchy_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_zero : (0 : exprℝ).cauchy = 0 :=\n  show zero.cauchy = 0 by rw [zero]\n#align cauchy_zero cauchy_zero\n\n",
 "cauchy_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_sub : ∀ a b, (a - b : exprℝ).cauchy = a.cauchy - b.cauchy\n  | ⟨a⟩, ⟨b⟩ => by\n    rw [sub_eq_add_neg, ← cauchy_neg, ← cauchy_add]\n    rfl\n#align cauchy_sub cauchy_sub\n\n",
 "cauchy_rat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_rat_cast (q : exprℚ) : (q : exprℝ).cauchy = q :=\n  rfl\n#align cauchy_rat_cast cauchy_rat_cast\n\n",
 "cauchy_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_one : (1 : exprℝ).cauchy = 1 :=\n  show one.cauchy = 1 by rw [one]\n#align cauchy_one cauchy_one\n\n",
 "cauchy_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_neg : ∀ a, (-a : exprℝ).cauchy = -a.cauchy\n  | ⟨a⟩ => show (neg _).cauchy = _ by rw [neg]\n#align cauchy_neg cauchy_neg\n\n",
 "cauchy_nat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_nat_cast (n : ℕ) : (n : exprℝ).cauchy = n :=\n  rfl\n#align cauchy_nat_cast cauchy_nat_cast\n\n",
 "cauchy_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_mul : ∀ a b, (a * b : exprℝ).cauchy = a.cauchy * b.cauchy\n  | ⟨a⟩, ⟨b⟩ => show (mul _ _).cauchy = _ by rw [mul]\n#align cauchy_mul cauchy_mul\n\n",
 "cauchy_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_inv : ∀ f, (f⁻¹ : exprℝ).cauchy = f.cauchy⁻¹\n  | ⟨f⟩ => show (inv' _).cauchy = _ by rw [inv']\n#align cauchy_inv cauchy_inv\n\n",
 "cauchy_int_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_int_cast (z : ℤ) : (z : exprℝ).cauchy = z :=\n  rfl\n#align cauchy_int_cast cauchy_int_cast\n\n",
 "cauchy_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cauchy_add : ∀ a b, (a + b : exprℝ).cauchy = a.cauchy + b.cauchy\n  | ⟨a⟩, ⟨b⟩ => show (add _ _).cauchy = _ by rw [add]\n#align cauchy_add cauchy_add\n\n",
 "cau_seq_converges":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem cau_seq_converges (f : CauSeq (exprℝ) abs) : ∃ x, f ≈ const abs x :=\n  by\n  let S := { x : exprℝ | const abs x < f }\n  have lb : ∃ x, x ∈ S := exists_lt f\n  have ub' : ∀ x, f < const abs x → ∀ y ∈ S, y ≤ x := fun x h y yS => le_of_lt <| const_lt.1 <| CauSeq.lt_trans yS h\n  have ub : ∃ x, ∀ y ∈ S, y ≤ x := (exists_gt f).imp ub'\n  refine' ⟨Sup S, ((lt_total _ _).resolve_left fun h => _).resolve_right fun h => _⟩\n  · rcases h with ⟨ε, ε0, i, ih⟩\n    refine' (csupₛ_le lb (ub' _ _)).not_lt (sub_lt_self _ (half_pos ε0))\n    refine' ⟨_, half_pos ε0, i, fun j ij => _⟩\n    rw [sub_apply, const_apply, sub_right_comm, le_sub_iff_add_le, add_halves]\n    exact ih _ ij\n  · rcases h with ⟨ε, ε0, i, ih⟩\n    refine' (le_csupₛ ub _).not_lt ((lt_add_iff_pos_left _).2 (half_pos ε0))\n    refine' ⟨_, half_pos ε0, i, fun j ij => _⟩\n    rw [sub_apply, const_apply, add_comm, ← sub_sub, le_sub_iff_add_le, add_halves]\n    exact ih _ ij\n#align cau_seq_converges cau_seq_converges\n\n",
 "add_neg_lt_Sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem add_neg_lt_Sup {s : set (exprℝ)} (h : s.nonempty) {ε : exprℝ} (hε : ε < 0) : ∃ a ∈ s, supₛ s + ε < a :=\n  exists_lt_of_lt_csupₛ h <| add_lt_iff_neg_left.2 hε\n#align add_neg_lt_Sup add_neg_lt_Sup\n\n",
 "add_lt_add_iff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print add_lt_add_iff_left /-\ntheorem add_lt_add_iff_left {a b : exprℝ} (c : exprℝ) : c + a < c + b ↔ a < b :=\n  by\n  induction a using real.ind_mk\n  induction b using real.ind_mk\n  induction c using real.ind_mk\n  simp only [mk_lt, ← mk_add]\n  show pos _ ↔ pos _; rw [add_sub_add_left_eq_sub]\n#align add_lt_add_iff_left add_lt_add_iff_left\n-/\n\n",
 "Sup_of_not_bdd_above":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Sup_of_not_bdd_above {s : set (exprℝ)} (hs : ¬BddAbove s) : supₛ s = 0 :=\n  dif_neg fun h => hs h.2\n#align Sup_of_not_bdd_above Sup_of_not_bdd_above\n\n",
 "Sup_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- As `0` is the default value for `real.Sup` of the empty set, it suffices to show that `S` is\nbounded above by `0` to show that `Sup S ≤ 0`.\n-/\ntheorem Sup_nonpos (S : set (exprℝ)) (hS : ∀ x ∈ S, x ≤ (0 : exprℝ)) : supₛ S ≤ 0 :=\n  by\n  rcases S.eq_empty_or_nonempty with (rfl | hS₂)\n  exacts[Sup_empty.le, csupₛ_le hS₂ hS]\n#align Sup_nonpos Sup_nonpos\n\n",
 "Sup_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- As `0` is the default value for `real.Sup` of the empty set or sets which are not bounded above, it\nsuffices to show that `S` is bounded below by `0` to show that `0 ≤ Inf S`.\n-/\ntheorem Sup_nonneg (S : set (exprℝ)) (hS : ∀ x ∈ S, (0 : exprℝ) ≤ x) : 0 ≤ supₛ S :=\n  by\n  rcases S.eq_empty_or_nonempty with (rfl | ⟨y, hy⟩)\n  · exact Sup_empty.ge\n  · apply dite _ (fun h => le_csupₛ_of_le h hy <| hS y hy) fun h => (Sup_of_not_bdd_above h).ge\n#align Sup_nonneg Sup_nonneg\n\n",
 "Sup_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Sup_def (S : set (exprℝ)) :\n    supₛ S = if h : S.nonempty ∧ BddAbove S then Classical.choose (exists_is_lub S h.1 h.2) else 0 :=\n  rfl\n#align Sup_def Sup_def\n\n",
 "Inf_of_not_bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Inf_of_not_bdd_below {s : set (exprℝ)} (hs : ¬BddBelow s) : infₛ s = 0 :=\n  neg_eq_zero.2 <| Sup_of_not_bdd_above <| mt bddAbove_neg.1 hs\n#align Inf_of_not_bdd_below Inf_of_not_bdd_below\n\n",
 "Inf_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- As `0` is the default value for `real.Inf` of the empty set or sets which are not bounded below, it\nsuffices to show that `S` is bounded above by `0` to show that `Inf S ≤ 0`.\n-/\ntheorem Inf_nonpos (S : set (exprℝ)) (hS : ∀ x ∈ S, x ≤ (0 : exprℝ)) : infₛ S ≤ 0 :=\n  by\n  rcases S.eq_empty_or_nonempty with (rfl | ⟨y, hy⟩)\n  · exact Inf_empty.le\n  · apply dite _ (fun h => cinfₛ_le_of_le h hy <| hS y hy) fun h => (Inf_of_not_bdd_below h).le\n#align Inf_nonpos Inf_nonpos\n\n",
 "Inf_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- As `0` is the default value for `real.Inf` of the empty set, it suffices to show that `S` is\nbounded below by `0` to show that `0 ≤ Inf S`.\n-/\ntheorem Inf_nonneg (S : set (exprℝ)) (hS : ∀ x ∈ S, (0 : exprℝ) ≤ x) : 0 ≤ infₛ S :=\n  by\n  rcases S.eq_empty_or_nonempty with (rfl | hS₂)\n  exacts[Inf_empty.ge, le_cinfₛ hS₂ hS]\n#align Inf_nonneg Inf_nonneg\n\n",
 "Inf_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem Inf_def (S : set (exprℝ)) : infₛ S = -supₛ (-S) :=\n  rfl\n#align Inf_def Inf_def\n\n"}