{"summable_cantor_function":
 "theorem summable_cantor_function (f : ℕ → bool) (h1 : 0 ≤ c) (h2 : c < 1) : summable (cantor_function_aux c f) :=\n  by\n  apply (summable_geometric_of_lt_1 h1 h2).summable_of_eq_zero_or_self\n  intro n; cases h : f n <;> simp [h]\n#align summable_cantor_function summable_cantor_function\n\n",
 "not_countable_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Non-Denumerability of the Continuum**: The reals are not countable. -/\ntheorem not_countable_real : ¬(Set.univ : set (exprℝ)).countable :=\n  by\n  rw [← le_aleph_0_iff_set_countable, not_le, mk_univ_real]\n  apply cantor\n#align not_countable_real not_countable_real\n\n",
 "mk_univ_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the reals, as a set. -/\ntheorem mk_univ_real : cardinal.mk (Set.univ : set (exprℝ)) = cardinal.continuum := by rw [mk_univ, mk_real]\n#align mk_univ_real mk_univ_real\n\n",
 "mk_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the reals, as a type. -/\ntheorem mk_real : cardinal.mk (exprℝ) = cardinal.continuum :=\n  by\n  apply le_antisymm\n  · rw [real.equiv_Cauchy.cardinal_eq]\n    apply mk_quotient_le.trans\n    apply (mk_subtype_le _).trans_eq\n    rw [← power_def, mk_nat, mk_rat, aleph_0_power_aleph_0]\n  · convert mk_le_of_injective (cantor_function_injective _ _)\n    rw [← power_def, mk_bool, mk_nat, two_power_aleph_0]\n    exact 1 / 3\n    norm_num\n    norm_num\n#align mk_real mk_real\n\n",
 "mk_Ioo_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval (a, b). -/\ntheorem mk_Ioo_real {a b : exprℝ} (h : a < b) : cardinal.mk (Ioo a b) = cardinal.continuum :=\n  by\n  refine' le_antisymm (mk_real ▸ mk_set_le _) _\n  have h1 : cardinal.mk («expr '' » (fun x => x - a) (Ioo a b)) ≤ cardinal.mk (Ioo a b) := mk_image_le\n  refine' le_trans _ h1\n  rw [image_sub_const_Ioo, sub_self]\n  replace h := sub_pos_of_lt h\n  have h2 : cardinal.mk («expr '' » has_inv.inv (Ioo 0 (b - a))) ≤ cardinal.mk (Ioo 0 (b - a)) := mk_image_le\n  refine' le_trans _ h2\n  rw [image_inv, inv_Ioo_0_left h, mk_Ioi_real]\n#align mk_Ioo_real mk_Ioo_real\n\n",
 "mk_Ioi_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval (a, ∞). -/\ntheorem mk_Ioi_real (a : exprℝ) : cardinal.mk (Ioi a) = cardinal.continuum :=\n  by\n  refine' le_antisymm (mk_real ▸ mk_set_le _) _\n  rw [← not_lt]\n  intro h\n  refine' ne_of_lt _ mk_univ_real\n  have hu : Iio a ∪ {a} ∪ Ioi a = Set.univ := by\n    convert Iic_union_Ioi\n    exact Iio_union_right\n  rw [← hu]\n  refine' lt_of_le_of_lt (mk_union_le _ _) _\n  refine' lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) _\n  have h2 : «expr '' » (fun x => a + a - x) (Ioi a) = Iio a :=\n    by\n    convert image_const_sub_Ioi _ _\n    simp\n  rw [← h2]\n  refine' add_lt_of_lt (cantor _).le _ h\n  refine' add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) _\n  rw [mk_singleton]\n  exact one_lt_aleph_0.trans (cantor _)\n#align mk_Ioi_real mk_Ioi_real\n\n",
 "mk_Ioc_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval (a, b]. -/\ntheorem mk_Ioc_real {a b : exprℝ} (h : a < b) : cardinal.mk (Ioc a b) = cardinal.continuum :=\n  le_antisymm (mk_real ▸ mk_set_le _) (mk_Ioo_real h ▸ mk_le_mk_of_subset Ioo_subset_Ioc_self)\n#align mk_Ioc_real mk_Ioc_real\n\n",
 "mk_Iio_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval (-∞, a). -/\ntheorem mk_Iio_real (a : exprℝ) : cardinal.mk (Iio a) = cardinal.continuum :=\n  by\n  refine' le_antisymm (mk_real ▸ mk_set_le _) _\n  have h2 : «expr '' » (fun x => a + a - x) (Iio a) = Ioi a :=\n    by\n    convert image_const_sub_Iio _ _\n    simp\n  exact mk_Ioi_real a ▸ h2 ▸ mk_image_le\n#align mk_Iio_real mk_Iio_real\n\n",
 "mk_Iic_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval (-∞, a]. -/\ntheorem mk_Iic_real (a : exprℝ) : cardinal.mk (Iic a) = cardinal.continuum :=\n  le_antisymm (mk_real ▸ mk_set_le _) (mk_Iio_real a ▸ mk_le_mk_of_subset Iio_subset_Iic_self)\n#align mk_Iic_real mk_Iic_real\n\n",
 "mk_Ico_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval [a, b). -/\ntheorem mk_Ico_real {a b : exprℝ} (h : a < b) : cardinal.mk (Ico a b) = cardinal.continuum :=\n  le_antisymm (mk_real ▸ mk_set_le _) (mk_Ioo_real h ▸ mk_le_mk_of_subset Ioo_subset_Ico_self)\n#align mk_Ico_real mk_Ico_real\n\n",
 "mk_Ici_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval [a, ∞). -/\ntheorem mk_Ici_real (a : exprℝ) : cardinal.mk (Ici a) = cardinal.continuum :=\n  le_antisymm (mk_real ▸ mk_set_le _) (mk_Ioi_real a ▸ mk_le_mk_of_subset Ioi_subset_Ici_self)\n#align mk_Ici_real mk_Ici_real\n\n",
 "mk_Icc_real":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.continuum -/\n/-- The cardinality of the interval [a, b]. -/\ntheorem mk_Icc_real {a b : exprℝ} (h : a < b) : cardinal.mk (Icc a b) = cardinal.continuum :=\n  le_antisymm (mk_real ▸ mk_set_le _) (mk_Ioo_real h ▸ mk_le_mk_of_subset Ioo_subset_Icc_self)\n#align mk_Icc_real mk_Icc_real\n\n",
 "increasing_cantor_function":
 "/-- `cantor_function c` is strictly increasing with if `0 < c < 1/2`, if we endow `ℕ → bool` with a\nlexicographic order. The lexicographic order doesn't exist for these infinitary products, so we\nexplicitly write out what it means. -/\ntheorem increasing_cantor_function (h1 : 0 < c) (h2 : c < 1 / 2) {n : ℕ} {f g : ℕ → bool} (hn : ∀ k < n, f k = g k)\n    (fn : f n = ff) (gn : g n = tt) : cantor_function c f < cantor_function c g :=\n  by\n  have h3 : c < 1 := by\n    apply h2.trans\n    norm_num\n  induction' n with n ih generalizing f g\n  · let f_max : ℕ → bool := fun n => nat.rec ff (fun _ _ => tt) n\n    have hf_max : ∀ n, f n → f_max n := by\n      intro n hn\n      cases n\n      rw [fn] at hn\n      contradiction\n      apply rfl\n    let g_min : ℕ → bool := fun n => nat.rec tt (fun _ _ => ff) n\n    have hg_min : ∀ n, g_min n → g n := by\n      intro n hn\n      cases n\n      rw [gn]\n      apply rfl\n      contradiction\n    apply (cantor_function_le (le_of_lt h1) h3 hf_max).trans_lt\n    refine' lt_of_lt_of_le _ (cantor_function_le (le_of_lt h1) h3 hg_min)\n    have : c / (1 - c) < 1 := by\n      rw [div_lt_one, lt_sub_iff_add_lt]\n      · convert add_lt_add h2 h2\n        norm_num\n      rwa [sub_pos]\n    convert this\n    · rw [cantor_function_succ _ (le_of_lt h1) h3, div_eq_mul_inv, ← tsum_geometric_of_lt_1 (le_of_lt h1) h3]\n      apply zero_add\n    · refine' (tsum_eq_single 0 _).trans _\n      · intro n hn\n        cases n\n        contradiction\n        rfl\n      · exact cantor_function_aux_zero _\n  rw [cantor_function_succ f (le_of_lt h1) h3, cantor_function_succ g (le_of_lt h1) h3]\n  rw [hn 0 <| zero_lt_succ n]\n  apply add_lt_add_left\n  rw [mul_lt_mul_left h1]\n  exact ih (fun k hk => hn _ <| nat.succ_lt_succ hk) fn gn\n#align increasing_cantor_function increasing_cantor_function\n\n",
 "cantor_function_succ":
 "theorem cantor_function_succ (f : ℕ → bool) (h1 : 0 ≤ c) (h2 : c < 1) :\n    cantor_function c f = cond (f 0) 1 0 + c * cantor_function c fun n => f (n + 1) :=\n  by\n  rw [cantor_function, tsum_eq_zero_add (summable_cantor_function f h1 h2)]\n  rw [cantor_function_aux_succ, tsum_mul_left, cantor_function_aux, pow_zero]\n  rfl\n#align cantor_function_succ cantor_function_succ\n\n",
 "cantor_function_le":
 "theorem cantor_function_le (h1 : 0 ≤ c) (h2 : c < 1) (h3 : ∀ n, f n → g n) :\n    cantor_function c f ≤ cantor_function c g :=\n  by\n  apply tsum_le_tsum _ (summable_cantor_function f h1 h2) (summable_cantor_function g h1 h2)\n  intro n; cases h : f n; simp [h, cantor_function_aux_nonneg h1]\n  replace h3 : g n = tt := h3 n h; simp [h, h3]\n#align cantor_function_le cantor_function_le\n\n",
 "cantor_function_injective":
 "/-- `cantor_function c` is injective if `0 < c < 1/2`. -/\ntheorem cantor_function_injective (h1 : 0 < c) (h2 : c < 1 / 2) : function.injective (cantor_function c) :=\n  by\n  intro f g hfg\n  classical\n    by_contra h\n    revert hfg\n    have : ∃ n, f n ≠ g n := by\n      rw [← not_forall]\n      intro h'\n      apply h\n      ext\n      apply h'\n    let n := nat.find this\n    have hn : ∀ k : ℕ, k < n → f k = g k := by\n      intro k hk\n      apply of_not_not\n      exact nat.find_min this hk\n    cases fn : f n\n    · apply ne_of_lt\n      refine' increasing_cantor_function h1 h2 hn fn _\n      apply Bool.eq_true_of_not_eq_false\n      rw [← fn]\n      apply ne.symm\n      exact nat.find_spec this\n    · apply ne_of_gt\n      refine' increasing_cantor_function h1 h2 (fun k hk => (hn k hk).symm) _ fn\n      apply Bool.eq_false_of_not_eq_true\n      rw [← fn]\n      apply ne.symm\n      exact nat.find_spec this\n#align cantor_function_injective cantor_function_injective\n\n",
 "cantor_function_aux_zero":
 "theorem cantor_function_aux_zero (f : ℕ → bool) : cantor_function_aux c f 0 = cond (f 0) 1 0 := by\n  cases h : f 0 <;> simp [h]\n#align cantor_function_aux_zero cantor_function_aux_zero\n\n",
 "cantor_function_aux_tt":
 "/-\nCopyright (c) 2019 Floris van Doorn. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Floris van Doorn\n-/\n@[simp]\ntheorem cantor_function_aux_tt (h : f n = tt) : cantor_function_aux c f n = c ^ n := by simp [cantor_function_aux, h]\n#align cantor_function_aux_tt cantor_function_aux_tt\n\n",
 "cantor_function_aux_succ":
 "theorem cantor_function_aux_succ (f : ℕ → bool) :\n    (fun n => cantor_function_aux c f (n + 1)) = fun n => c * cantor_function_aux c (fun n => f (n + 1)) n :=\n  by\n  ext n\n  cases h : f (n + 1) <;> simp [h, pow_succ]\n#align cantor_function_aux_succ cantor_function_aux_succ\n\n",
 "cantor_function_aux_nonneg":
 "theorem cantor_function_aux_nonneg (h : 0 ≤ c) : 0 ≤ cantor_function_aux c f n :=\n  by\n  cases h' : f n <;> simp [h']\n  apply pow_nonneg h\n#align cantor_function_aux_nonneg cantor_function_aux_nonneg\n\n",
 "cantor_function_aux_ff":
 "@[simp]\ntheorem cantor_function_aux_ff (h : f n = ff) : cantor_function_aux c f n = 0 := by simp [cantor_function_aux, h]\n#align cantor_function_aux_ff cantor_function_aux_ff\n\n",
 "cantor_function_aux_eq":
 "theorem cantor_function_aux_eq (h : f n = g n) : cantor_function_aux c f n = cantor_function_aux c g n := by\n  simp [cantor_function_aux, h]\n#align cantor_function_aux_eq cantor_function_aux_eq\n\n"}