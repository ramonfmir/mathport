{"tendsto_prod_pi_div_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/-- Wallis' product formula for `π / 2`. -/\ntheorem real.tendsto_prod_pi_div_two :\n    Tendsto\n      (fun k =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (range k)\n          (((2 : exprℝ) * i + 2) / (2 * i + 1) * ((2 * i + 2) / (2 * i + 3))))\n      atTop ((nhds) (real.pi / 2)) :=\n  real.wallis.tendsto_W_nhds_pi_div_two\n#align real.tendsto_prod_pi_div_two real.tendsto_prod_pi_div_two\n\n",
 "tendsto_W_nhds_pi_div_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem tendsto_W_nhds_pi_div_two : Tendsto W atTop (nhds <| real.pi / 2) :=\n  by\n  refine' tendsto_of_tendsto_of_tendsto_of_le_of_le _ tendsto_const_nhds le_W W_le\n  have : (nhds) (real.pi / 2) = (nhds) ((1 - 0) * (real.pi / 2)) := by rw [sub_zero, one_mul]\n  rw [this]\n  refine' tendsto.mul _ tendsto_const_nhds\n  have h : ∀ n : ℕ, ((2 : exprℝ) * n + 1) / (2 * n + 2) = 1 - 1 / (2 * n + 2) :=\n    by\n    intro n\n    rw [sub_div' _ _ _\n        (ne_of_gt (add_pos_of_nonneg_of_pos (mul_nonneg (two_pos : 0 < (2 : exprℝ)).le (Nat.cast_nonneg _)) two_pos)),\n      one_mul]\n    congr 1\n    ring\n  simp_rw [h]\n  refine' (tendsto_const_nhds.div_at_top _).const_sub _\n  refine' tendsto.at_top_add _ tendsto_const_nhds\n  exact tendsto_coe_nat_at_top_at_top.const_mul_at_top two_pos\n#align tendsto_W_nhds_pi_div_two tendsto_W_nhds_pi_div_two\n\n",
 "le_W":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem le_W (k : ℕ) : ((2 : exprℝ) * k + 1) / (2 * k + 2) * (real.pi / 2) ≤ W k :=\n  by\n  rw [← le_div_iff pi_div_two_pos, div_eq_inv_mul (W k) _]\n  rw [W_eq_integral_sin_pow_div_integral_sin_pow, le_div_iff (integral_sin_pow_pos _)]\n  convert integral_sin_pow_succ_le (2 * k + 1)\n  rw [integral_sin_pow (2 * k)]\n  simp only [sin_zero, zero_pow', ne.def, nat.succ_ne_zero, not_false_iff, MulZeroClass.zero_mul, sin_pi, tsub_zero,\n    Nat.cast_mul, Nat.cast_bit0, algebraMap.coe_one, zero_div, zero_add]\n#align le_W le_W\n\n",
 "W_succ":
 "/-\nCopyright (c) 2021 Hanting Zhang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Hanting Zhang\n-/\ntheorem W_succ (k : ℕ) : W (k + 1) = W k * ((2 * k + 2) / (2 * k + 1) * ((2 * k + 2) / (2 * k + 3))) :=\n  prod_range_succ _ _\n#align W_succ W_succ\n\n",
 "W_pos":
 "theorem W_pos (k : ℕ) : 0 < W k := by\n  induction' k with k hk\n  · unfold W\n    simp\n  · rw [W_succ]\n    refine' mul_pos hk (mul_pos (div_pos _ _) (div_pos _ _)) <;> positivity\n#align W_pos W_pos\n\n",
 "W_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem W_le (k : ℕ) : W k ≤ real.pi / 2 :=\n  by\n  rw [← div_le_one pi_div_two_pos, div_eq_inv_mul]\n  rw [W_eq_integral_sin_pow_div_integral_sin_pow, div_le_one (integral_sin_pow_pos _)]\n  apply integral_sin_pow_succ_le\n#align W_le W_le\n\n",
 "W_eq_integral_sin_pow_div_integral_sin_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `real.pi -/\ntheorem W_eq_integral_sin_pow_div_integral_sin_pow (k : ℕ) :\n    (real.pi / 2)⁻¹ * W k =\n      «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n          (real.pi) (sin x ^ (2 * k + 1)) /\n        «expr∫ in .. , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in .. , »\" 0\n          (real.pi) (sin x ^ (2 * k)) :=\n  by\n  rw [integral_sin_pow_even, integral_sin_pow_odd, mul_div_mul_comm, ← prod_div_distrib, inv_div]\n  simp_rw [div_div_div_comm, div_div_eq_mul_div, mul_div_assoc]\n  rfl\n#align W_eq_integral_sin_pow_div_integral_sin_pow W_eq_integral_sin_pow_div_integral_sin_pow\n\n",
 "W_eq_factorial_ratio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem W_eq_factorial_ratio (n : ℕ) :\n    W n = 2 ^ (4 * n) * nat.factorial n ^ 4 / (nat.factorial (2 * n) ^ 2 * (2 * n + 1)) :=\n  by\n  induction' n with n IH\n  ·\n    simp only [W, prod_range_zero, Nat.factorial_zero, MulZeroClass.mul_zero, pow_zero, algebraMap.coe_one, one_pow,\n      mul_one, algebraMap.coe_zero, zero_add, div_self, ne.def, one_ne_zero, not_false_iff]\n  · unfold W at IH⊢\n    rw [prod_range_succ, IH, _root_.div_mul_div_comm, _root_.div_mul_div_comm]\n    refine' (div_eq_div_iff _ _).mpr _\n    any_goals exact ne_of_gt (by positivity)\n    simp_rw [nat.mul_succ, Nat.factorial_succ, pow_succ]\n    push_cast\n    ring_nf\n#align W_eq_factorial_ratio W_eq_factorial_ratio\n\n"}