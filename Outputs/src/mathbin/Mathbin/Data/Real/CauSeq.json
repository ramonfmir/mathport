{"zero_lim_zero":
 "theorem zero_lim_zero : LimZero (0 : CauSeq β abv)\n  | ε, ε0 => ⟨0, fun j ij => by simpa [abv_zero abv] using ε0⟩\n#align zero_lim_zero zero_lim_zero\n\n",
 "zero_apply":
 "@[simp, norm_cast]\ntheorem zero_apply (i) : (0 : CauSeq β abv) i = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "trichotomy":
 "theorem trichotomy (f : CauSeq α abs) : Pos f ∨ LimZero f ∨ Pos (-f) :=\n  by\n  cases classical.em (lim_zero f) <;> simp [*]\n  rcases abv_pos_of_not_lim_zero h with ⟨K, K0, hK⟩\n  rcases exists_forall_ge_and hK (f.cauchy₃ K0) with ⟨i, hi⟩\n  refine' (le_total 0 (f i)).imp _ _ <;> refine' fun h => ⟨K, K0, i, fun j ij => _⟩ <;> have := (hi _ ij).1 <;>\n    cases' hi _ le_rfl with h₁ h₂\n  · rwa [abs_of_nonneg] at this\n    rw [abs_of_nonneg h] at h₁\n    exact (le_add_iff_nonneg_right _).1 (le_trans h₁ <| neg_le_sub_iff_le_add'.1 <| le_of_lt (abs_lt.1 <| h₂ _ ij).1)\n  · rwa [abs_of_nonpos] at this\n    rw [abs_of_nonpos h] at h₁\n    rw [← sub_le_sub_iff_right, zero_sub]\n    exact le_trans (le_of_lt (abs_lt.1 <| h₂ _ ij).2) h₁\n#align trichotomy trichotomy\n\n",
 "sup_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\nprotected theorem sup_lt {a b c : CauSeq α abs} (ha : a < c) (hb : b < c) : «expr ⊔ » a b < c :=\n  by\n  obtain ⟨⟨εa, εa0, ia, ha⟩, ⟨εb, εb0, ib, hb⟩⟩ := ha, hb\n  refine' ⟨«expr ⊓ » εa εb, lt_inf_iff.mpr ⟨εa0, εb0⟩, «expr ⊔ » ia ib, fun i hi => _⟩\n  have := min_le_min (ha _ (sup_le_iff.mp hi).1) (hb _ (sup_le_iff.mp hi).2)\n  exact this.trans_eq (min_sub_sub_left _ _ _)\n#align sup_lt sup_lt\n\n",
 "sup_lim_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_lim_zero {f g : CauSeq α abs} (hf : LimZero f) (hg : LimZero g) : LimZero («expr ⊔ » f g)\n  | ε, ε0 =>\n    (exists_forall_ge_and (hf _ ε0) (hg _ ε0)).imp fun i H j ij =>\n      by\n      let ⟨H₁, H₂⟩ := H _ ij\n      rw [abs_lt] at H₁ H₂⊢\n      exact ⟨lt_sup_iff.mpr (or.inl H₁.1), sup_lt_iff.mpr ⟨H₁.2, H₂.2⟩⟩\n#align sup_lim_zero sup_lim_zero\n\n",
 "sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_le /-\nprotected theorem sup_le {a b c : CauSeq α abs} (ha : a ≤ c) (hb : b ≤ c) : «expr ⊔ » a b ≤ c :=\n  by\n  cases' ha with ha ha\n  · cases' hb with hb hb\n    · exact or.inl (CauSeq.sup_lt ha hb)\n    · replace ha := le_of_le_of_eq ha.le (setoid.symm hb)\n      refine' le_of_le_of_eq (or.inr _) hb\n      exact CauSeq.sup_eq_right ha\n  · replace hb := le_of_le_of_eq hb (setoid.symm ha)\n    refine' le_of_le_of_eq (or.inr _) ha\n    exact CauSeq.sup_eq_left hb\n#align sup_le sup_le\n-/\n\n",
 "sup_inf_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\nprotected theorem sup_inf_distrib_right (a b c : CauSeq α abs) :\n    «expr ⊔ » («expr ⊓ » a b) c = «expr ⊓ » («expr ⊔ » a c) («expr ⊔ » b c) :=\n  Subtype.ext <| funext fun i => max_min_distrib_right\n#align sup_inf_distrib_right sup_inf_distrib_right\n\n",
 "sup_inf_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\nprotected theorem sup_inf_distrib_left (a b c : CauSeq α abs) :\n    «expr ⊔ » a («expr ⊓ » b c) = «expr ⊓ » («expr ⊔ » a b) («expr ⊔ » a c) :=\n  Subtype.ext <| funext fun i => max_min_distrib_left\n#align sup_inf_distrib_left sup_inf_distrib_left\n\n",
 "sup_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_idem /-\n@[simp]\nprotected theorem sup_idem (a : CauSeq α abs) : «expr ⊔ » a a = a :=\n  Subtype.ext sup_idem\n#align sup_idem sup_idem\n-/\n\n",
 "sup_equiv_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_equiv_sup {a₁ b₁ a₂ b₂ : CauSeq α abs} (ha : a₁ ≈ a₂) (hb : b₁ ≈ b₂) : «expr ⊔ » a₁ b₁ ≈ «expr ⊔ » a₂ b₂ :=\n  by\n  intro ε ε0\n  obtain ⟨ai, hai⟩ := ha ε ε0\n  obtain ⟨bi, hbi⟩ := hb ε ε0\n  exact\n    ⟨«expr ⊔ » ai bi, fun i hi =>\n      (abs_max_sub_max_le_max (a₁ i) (b₁ i) (a₂ i) (b₂ i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))⟩\n#align sup_equiv_sup sup_equiv_sup\n\n",
 "sup_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_eq_right /-\nprotected theorem sup_eq_right {a b : CauSeq α abs} (h : a ≤ b) : «expr ⊔ » a b ≈ b :=\n  by\n  obtain ⟨ε, ε0 : _ < _, i, h⟩ | h := h\n  · intro _ _\n    refine' ⟨i, fun j hj => _⟩\n    dsimp\n    erw [← max_sub_sub_right]\n    rwa [sub_self, max_eq_right, abs_zero]\n    rw [sub_nonpos, ← sub_nonneg]\n    exact ε0.le.trans (h _ hj)\n  · refine' setoid.trans (sup_equiv_sup h (setoid.refl _)) _\n    rw [CauSeq.sup_idem]\n    exact setoid.refl _\n#align sup_eq_right sup_eq_right\n-/\n\n",
 "sup_eq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_eq_left /-\nprotected theorem sup_eq_left {a b : CauSeq α abs} (h : b ≤ a) : «expr ⊔ » a b ≈ a := by\n  simpa only [CauSeq.sup_comm] using CauSeq.sup_eq_right h\n#align sup_eq_left sup_eq_left\n-/\n\n",
 "sup_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print sup_comm /-\nprotected theorem sup_comm (a b : CauSeq α abs) : «expr ⊔ » a b = «expr ⊔ » b a :=\n  Subtype.ext sup_comm\n#align sup_comm sup_comm\n-/\n\n",
 "sub_lim_zero":
 "theorem sub_lim_zero {f g : CauSeq β abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f - g) := by\n  simpa only [sub_eq_add_neg] using add_lim_zero hf (neg_lim_zero hg)\n#align sub_lim_zero sub_lim_zero\n\n",
 "sub_equiv_sub":
 "theorem sub_equiv_sub {f1 f2 g1 g2 : CauSeq β abv} (hf : f1 ≈ f2) (hg : g1 ≈ g2) : f1 - g1 ≈ f2 - g2 := by\n  simpa only [sub_eq_add_neg] using add_equiv_add hf (neg_equiv_neg hg)\n#align sub_equiv_sub sub_equiv_sub\n\n",
 "sub_apply":
 "@[simp, norm_cast]\ntheorem sub_apply (f g : CauSeq β abv) (i : ℕ) : (f - g) i = f i - g i :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "smul_equiv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_equiv_smul [SMul G β] [IsScalarTower G β β] {f1 f2 : CauSeq β abv} (c : G) (hf : f1 ≈ f2) :\n    «expr • » c f1 ≈ «expr • » c f2 := by\n  simpa [const_smul, smul_one_mul _ _] using mul_equiv_mul (const_equiv.mpr <| Eq.refl <| «expr • » c 1) hf\n#align smul_equiv_smul smul_equiv_smul\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem smul_apply (a : G) (f : CauSeq β abv) (i : ℕ) : («expr • » a f) i = «expr • » a (f i) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "rat_sup_continuous_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print CauSeq.rat_sup_continuous_lemma /-\n-- so named to match `rat_add_continuous_lemma`\ntheorem CauSeq.rat_sup_continuous_lemma {ε : α} {a₁ a₂ b₁ b₂ : α} :\n    abs (a₁ - b₁) < ε → abs (a₂ - b₂) < ε → abs («expr ⊔ » a₁ a₂ - «expr ⊔ » b₁ b₂) < ε := fun h₁ h₂ =>\n  (abs_max_sub_max_le_max _ _ _ _).trans_lt (max_lt h₁ h₂)\n#align rat_sup_continuous_lemma CauSeq.rat_sup_continuous_lemma\n-/\n\n",
 "rat_mul_continuous_lemma":
 "#print rat_mul_continuous_lemma /-\ntheorem rat_mul_continuous_lemma {ε K₁ K₂ : α} (ε0 : 0 < ε) :\n    ∃ δ > 0,\n      ∀ {a₁ a₂ b₁ b₂ : β},\n        abv a₁ < K₁ → abv b₂ < K₂ → abv (a₁ - b₁) < δ → abv (a₂ - b₂) < δ → abv (a₁ * a₂ - b₁ * b₂) < ε :=\n  by\n  have K0 : (0 : α) < max 1 (max K₁ K₂) := lt_of_lt_of_le zero_lt_one (le_max_left _ _)\n  have εK := div_pos (half_pos ε0) K0\n  refine' ⟨_, εK, fun a₁ a₂ b₁ b₂ ha₁ hb₂ h₁ h₂ => _⟩\n  replace ha₁ := lt_of_lt_of_le ha₁ (le_trans (le_max_left _ K₂) (le_max_right 1 _))\n  replace hb₂ := lt_of_lt_of_le hb₂ (le_trans (le_max_right K₁ _) (le_max_right 1 _))\n  have :=\n    add_lt_add (mul_lt_mul' (le_of_lt h₁) hb₂ (abv_nonneg abv _) εK)\n      (mul_lt_mul' (le_of_lt h₂) ha₁ (abv_nonneg abv _) εK)\n  rw [← abv_mul abv, mul_comm, div_mul_cancel _ (ne_of_gt K0), ← abv_mul abv, add_halves] at this\n  simpa [mul_add, add_mul, sub_eq_add_neg, add_comm, add_left_comm] using lt_of_le_of_lt (abv_add abv _ _) this\n#align rat_mul_continuous_lemma rat_mul_continuous_lemma\n-/\n\n",
 "rat_inv_continuous_lemma":
 "#print rat_inv_continuous_lemma /-\ntheorem rat_inv_continuous_lemma {β : Type _} [DivisionRing β] (abv : β → α) [IsAbsoluteValue abv] {ε K : α}\n    (ε0 : 0 < ε) (K0 : 0 < K) : ∃ δ > 0, ∀ {a b : β}, K ≤ abv a → K ≤ abv b → abv (a - b) < δ → abv (a⁻¹ - b⁻¹) < ε :=\n  by\n  refine' ⟨K * ε * K, mul_pos (mul_pos K0 ε0) K0, fun a b ha hb h => _⟩\n  have a0 := K0.trans_le ha\n  have b0 := K0.trans_le hb\n  rw [inv_sub_inv' ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_mul abv, abv_mul abv, abv_inv abv, abv_inv abv,\n    abv_sub abv]\n  refine' lt_of_mul_lt_mul_left (lt_of_mul_lt_mul_right _ b0.le) a0.le\n  rw [mul_assoc, inv_mul_cancel_right₀ b0.ne', ← mul_assoc, mul_inv_cancel a0.ne', one_mul]\n  refine' h.trans_le _\n  exact mul_le_mul (mul_le_mul ha le_rfl ε0.le a0.le) hb K0.le (mul_nonneg a0.le ε0.le)\n#align rat_inv_continuous_lemma rat_inv_continuous_lemma\n-/\n\n",
 "rat_inf_continuous_lemma":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print CauSeq.rat_inf_continuous_lemma /-\n-- so named to match `rat_add_continuous_lemma`\ntheorem CauSeq.rat_inf_continuous_lemma {ε : α} {a₁ a₂ b₁ b₂ : α} :\n    abs (a₁ - b₁) < ε → abs (a₂ - b₂) < ε → abs («expr ⊓ » a₁ a₂ - «expr ⊓ » b₁ b₂) < ε := fun h₁ h₂ =>\n  (abs_min_sub_min_le_max _ _ _ _).trans_lt (max_lt h₁ h₂)\n#align rat_inf_continuous_lemma CauSeq.rat_inf_continuous_lemma\n-/\n\n",
 "rat_add_continuous_lemma":
 "#print rat_add_continuous_lemma /-\ntheorem rat_add_continuous_lemma {ε : α} (ε0 : 0 < ε) :\n    ∃ δ > 0, ∀ {a₁ a₂ b₁ b₂ : β}, abv (a₁ - b₁) < δ → abv (a₂ - b₂) < δ → abv (a₁ + a₂ - (b₁ + b₂)) < ε :=\n  ⟨ε / 2, half_pos ε0, fun a₁ a₂ b₁ b₂ h₁ h₂ => by\n    simpa [add_halves, sub_eq_add_neg, add_comm, add_left_comm, add_assoc] using\n      lt_of_le_of_lt (abv_add abv _ _) (add_lt_add h₁ h₂)⟩\n#align rat_add_continuous_lemma rat_add_continuous_lemma\n-/\n\n",
 "pow_equiv_pow":
 "theorem pow_equiv_pow {f1 f2 : CauSeq β abv} (hf : f1 ≈ f2) (n : ℕ) : f1 ^ n ≈ f2 ^ n :=\n  by\n  induction' n with n ih\n  · simp only [pow_zero, setoid.refl]\n  · simpa only [pow_succ] using mul_equiv_mul hf ih\n#align pow_equiv_pow pow_equiv_pow\n\n",
 "pow_apply":
 "@[simp, norm_cast]\ntheorem pow_apply (f : CauSeq β abv) (n i : ℕ) : (f ^ n) i = f i ^ n :=\n  rfl\n#align pow_apply pow_apply\n\n",
 "pos_add_lim_zero":
 "theorem pos_add_lim_zero {f g : CauSeq α abs} : Pos f → LimZero g → Pos (f + g)\n  | ⟨F, F0, hF⟩, H =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF (H _ (half_pos F0))\n    ⟨_, half_pos F0, i, fun j ij => by\n      cases' h j ij with h₁ h₂\n      have := add_le_add h₁ (le_of_lt (abs_lt.1 h₂).1)\n      rwa [← sub_eq_add_neg, sub_self_div_two] at this⟩\n#align pos_add_lim_zero pos_add_lim_zero\n\n",
 "one_not_equiv_zero":
 "theorem one_not_equiv_zero : ¬const abv 1 ≈ const abv 0 := fun h =>\n  have : ∀ ε > 0, ∃ i, ∀ k, i ≤ k → abv (1 - 0) < ε := h\n  have h1 : abv 1 ≤ 0 :=\n    le_of_not_gt fun h2 : 0 < abv 1 =>\n      exists.elim (this _ h2) fun i hi => lt_irrefl (abv 1) <| by simpa using hi _ le_rfl\n  have h2 : 0 ≤ abv 1 := IsAbsoluteValue.abv_nonneg _ _\n  have : abv 1 = 0 := le_antisymm h1 h2\n  have : (1 : β) = 0 := (IsAbsoluteValue.abv_eq_zero abv).1 this\n  absurd this one_ne_zero\n#align one_not_equiv_zero one_not_equiv_zero\n\n",
 "one_apply":
 "@[simp, norm_cast]\ntheorem one_apply (i) : (1 : CauSeq β abv) i = 1 :=\n  rfl\n#align one_apply one_apply\n\n",
 "of_near":
 "theorem of_near (f : ℕ → β) (g : CauSeq β abv) (h : ∀ ε > 0, ∃ i, ∀ j ≥ i, abv (f j - g j) < ε) : IsCauSeq abv f\n  | ε, ε0 =>\n    let ⟨i, hi⟩ := exists_forall_ge_and (h _ (half_pos <| half_pos ε0)) (g.cauchy₃ <| half_pos ε0)\n    ⟨i, fun j ij => by\n      cases' hi _ le_rfl with h₁ h₂; rw [abv_sub abv] at h₁\n      have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add (hi _ ij).1 h₁)\n      have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add this (h₂ _ ij))\n      rwa [add_halves, add_halves, add_right_comm, sub_add_sub_cancel, sub_add_sub_cancel] at this⟩\n#align of_near of_near\n\n",
 "not_lim_zero_of_pos":
 "theorem not_lim_zero_of_pos {f : CauSeq α abs} : Pos f → ¬LimZero f\n  | ⟨F, F0, hF⟩, H =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF (H _ F0)\n    let ⟨h₁, h₂⟩ := h _ le_rfl\n    not_lt_of_le h₁ (abs_lt.1 h₂).2\n#align not_lim_zero_of_pos not_lim_zero_of_pos\n\n",
 "not_lim_zero_of_not_congr_zero":
 "theorem not_lim_zero_of_not_congr_zero {f : CauSeq _ abv} (hf : ¬f ≈ 0) : ¬LimZero f := fun this : LimZero f =>\n  have : LimZero (f - 0) := by simpa\n  hf this\n#align not_lim_zero_of_not_congr_zero not_lim_zero_of_not_congr_zero\n\n",
 "neg_lim_zero":
 "theorem neg_lim_zero {f : CauSeq β abv} (hf : LimZero f) : LimZero (-f) := by\n  rw [← neg_one_mul] <;> exact mul_lim_zero_right _ hf\n#align neg_lim_zero neg_lim_zero\n\n",
 "neg_equiv_neg":
 "theorem neg_equiv_neg {f g : CauSeq β abv} (hf : f ≈ g) : -f ≈ -g := by simpa only [neg_sub'] using neg_lim_zero hf\n#align neg_equiv_neg neg_equiv_neg\n\n",
 "neg_apply":
 "@[simp, norm_cast]\ntheorem neg_apply (f : CauSeq β abv) (i) : (-f) i = -f i :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mul_pos":
 "#print mul_pos /-\nprotected theorem mul_pos {f g : CauSeq α abs} : Pos f → Pos g → Pos (f * g)\n  | ⟨F, F0, hF⟩, ⟨G, G0, hG⟩ =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF hG\n    ⟨_, mul_pos F0 G0, i, fun j ij =>\n      let ⟨h₁, h₂⟩ := h _ ij\n      mul_le_mul h₁ h₂ (le_of_lt G0) (le_trans (le_of_lt F0) h₁)⟩\n#align mul_pos mul_pos\n-/\n\n",
 "mul_not_equiv_zero":
 "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) : ¬f * g ≈ 0 :=\n  fun this : LimZero (f * g - 0) => by\n  have hlz : LimZero (f * g) := by simpa\n  have hf' : ¬LimZero f := by simpa using show ¬lim_zero (f - 0) from hf\n  have hg' : ¬LimZero g := by simpa using show ¬lim_zero (g - 0) from hg\n  rcases abv_pos_of_not_lim_zero hf' with ⟨a1, ha1, N1, hN1⟩\n  rcases abv_pos_of_not_lim_zero hg' with ⟨a2, ha2, N2, hN2⟩\n  have : 0 < a1 * a2 := mul_pos ha1 ha2\n  cases' hlz _ this with N hN\n  let i := max N (max N1 N2)\n  have hN' := hN i (le_max_left _ _)\n  have hN1' := hN1 i (le_trans (le_max_left _ _) (le_max_right _ _))\n  have hN1' := hN2 i (le_trans (le_max_right _ _) (le_max_right _ _))\n  apply not_le_of_lt hN'\n  change _ ≤ abv (_ * _)\n  rw [IsAbsoluteValue.abv_mul abv]\n  apply mul_le_mul <;> try assumption\n  · apply le_of_lt ha2\n  · apply IsAbsoluteValue.abv_nonneg abv\n#align mul_not_equiv_zero mul_not_equiv_zero\n\n",
 "mul_lim_zero_right":
 "theorem mul_lim_zero_right (f : CauSeq β abv) {g} (hg : LimZero g) : LimZero (f * g)\n  | ε, ε0 =>\n    let ⟨F, F0, hF⟩ := f.bounded' 0\n    (hg _ <| div_pos ε0 F0).imp fun i H j ij => by\n      have := mul_lt_mul' (le_of_lt <| hF j) (H _ ij) (abv_nonneg abv _) F0 <;>\n        rwa [mul_comm F, div_mul_cancel _ (ne_of_gt F0), ← abv_mul abv] at this\n#align mul_lim_zero_right mul_lim_zero_right\n\n",
 "mul_lim_zero_left":
 "theorem mul_lim_zero_left {f} (g : CauSeq β abv) (hg : LimZero f) : LimZero (f * g)\n  | ε, ε0 =>\n    let ⟨G, G0, hG⟩ := g.bounded' 0\n    (hg _ <| div_pos ε0 G0).imp fun i H j ij => by\n      have := mul_lt_mul'' (H _ ij) (hG j) (abv_nonneg abv _) (abv_nonneg abv _) <;>\n        rwa [div_mul_cancel _ (ne_of_gt G0), ← abv_mul abv] at this\n#align mul_lim_zero_left mul_lim_zero_left\n\n",
 "mul_inv_cancel":
 "#print mul_inv_cancel /-\ntheorem mul_inv_cancel {f : CauSeq β abv} (hf) : f * inv f hf ≈ 1 := fun ε ε0 =>\n  let ⟨K, K0, i, H⟩ := abv_pos_of_not_limZero hf\n  ⟨i, fun j ij => by simpa [(abv_pos abv).1 (lt_of_lt_of_le K0 (H _ ij)), abv_zero abv] using ε0⟩\n#align mul_inv_cancel mul_inv_cancel\n-/\n\n",
 "mul_equiv_zero'":
 "theorem mul_equiv_zero' (g : CauSeq _ abv) {f : CauSeq _ abv} (hf : f ≈ 0) : f * g ≈ 0 :=\n  have : LimZero (f - 0) := hf\n  have : LimZero (f * g) := mul_limZero_left _ <| by simpa\n  show LimZero (f * g - 0) by simpa\n#align mul_equiv_zero' mul_equiv_zero'\n\n",
 "mul_equiv_zero":
 "theorem mul_equiv_zero (g : CauSeq _ abv) {f : CauSeq _ abv} (hf : f ≈ 0) : g * f ≈ 0 :=\n  have : LimZero (f - 0) := hf\n  have : LimZero (g * f) := mul_limZero_right _ <| by simpa\n  show LimZero (g * f - 0) by simpa\n#align mul_equiv_zero mul_equiv_zero\n\n",
 "mul_equiv_mul":
 "theorem mul_equiv_mul {f1 f2 g1 g2 : CauSeq β abv} (hf : f1 ≈ f2) (hg : g1 ≈ g2) : f1 * g1 ≈ f2 * g2 := by\n  simpa only [mul_sub, sub_mul, sub_add_sub_cancel] using\n    add_lim_zero (mul_lim_zero_left g1 hf) (mul_lim_zero_right f2 hg)\n#align mul_equiv_mul mul_equiv_mul\n\n",
 "mul_apply":
 "@[simp, norm_cast]\ntheorem mul_apply (f g : CauSeq β abv) (i : ℕ) : (f * g) i = f i * g i :=\n  rfl\n#align mul_apply mul_apply\n\n",
 "mk_to_fun":
 "@[simp]\ntheorem mk_to_fun (f) (hf : IsCauSeq abv f) : @coe_fn (CauSeq β abv) _ _ ⟨f, hf⟩ = f :=\n  rfl\n#align mk_to_fun mk_to_fun\n\n",
 "lt_trans":
 "#print lt_trans /-\ntheorem lt_trans {f g h : CauSeq α abs} (fg : f < g) (gh : g < h) : f < h :=\n  show Pos (h - f) by simpa [sub_eq_add_neg, add_comm, add_left_comm] using add_pos fg gh\n#align lt_trans lt_trans\n-/\n\n",
 "lt_total":
 "theorem lt_total (f g : CauSeq α abs) : f < g ∨ f ≈ g ∨ g < f :=\n  (trichotomy (g - f)).imp_right fun h => h.imp (fun h => setoid.symm h) fun h => by rwa [neg_sub] at h\n#align lt_total lt_total\n\n",
 "lt_of_lt_of_eq":
 "#print lt_of_lt_of_eq /-\ntheorem lt_of_lt_of_eq {f g h : CauSeq α abs} (fg : f < g) (gh : g ≈ h) : f < h :=\n  show Pos (h - f) by simpa [sub_eq_add_neg, add_comm, add_left_comm] using pos_add_lim_zero fg (neg_lim_zero gh)\n#align lt_of_lt_of_eq lt_of_lt_of_eq\n-/\n\n",
 "lt_of_eq_of_lt":
 "#print lt_of_eq_of_lt /-\ntheorem lt_of_eq_of_lt {f g h : CauSeq α abs} (fg : f ≈ g) (gh : g < h) : f < h := by\n  have := pos_add_lim_zero gh (neg_lim_zero fg) <;> rwa [← sub_eq_add_neg, sub_sub_sub_cancel_right] at this\n#align lt_of_eq_of_lt lt_of_eq_of_lt\n-/\n\n",
 "lt_irrefl":
 "#print lt_irrefl /-\ntheorem lt_irrefl {f : CauSeq α abs} : ¬f < f\n  | h => not_limZero_of_pos h (by simp [zero_lim_zero])\n#align lt_irrefl lt_irrefl\n-/\n\n",
 "lt_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\nprotected theorem lt_inf {a b c : CauSeq α abs} (hb : a < b) (hc : a < c) : a < «expr ⊓ » b c :=\n  by\n  obtain ⟨⟨εb, εb0, ib, hb⟩, ⟨εc, εc0, ic, hc⟩⟩ := hb, hc\n  refine' ⟨«expr ⊓ » εb εc, lt_inf_iff.mpr ⟨εb0, εc0⟩, «expr ⊔ » ib ic, fun i hi => _⟩\n  have := min_le_min (hb _ (sup_le_iff.mp hi).1) (hc _ (sup_le_iff.mp hi).2)\n  exact this.trans_eq (min_sub_sub_right _ _ _)\n#align lt_inf lt_inf\n\n",
 "lim_zero_sub_rev":
 "theorem lim_zero_sub_rev {f g : CauSeq β abv} (hfg : LimZero (f - g)) : LimZero (g - f) := by\n  simpa using neg_lim_zero hfg\n#align lim_zero_sub_rev lim_zero_sub_rev\n\n",
 "lim_zero_congr":
 "theorem lim_zero_congr {f g : CauSeq β abv} (h : f ≈ g) : LimZero f ↔ LimZero g :=\n  ⟨fun l => by simpa using add_lim_zero (setoid.symm h) l, fun l => by simpa using add_lim_zero h l⟩\n#align lim_zero_congr lim_zero_congr\n\n",
 "le_total":
 "#print le_total /-\ntheorem le_total (f g : CauSeq α abs) : f ≤ g ∨ g ≤ f :=\n  (or_assoc.2 (lt_total f g)).imp_right or.inl\n#align le_total le_total\n-/\n\n",
 "le_sup_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print le_sup_right /-\nprotected theorem le_sup_right {a b : CauSeq α abs} : b ≤ «expr ⊔ » a b :=\n  le_of_exists ⟨0, fun j hj => le_sup_right⟩\n#align le_sup_right le_sup_right\n-/\n\n",
 "le_sup_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print le_sup_left /-\nprotected theorem le_sup_left {a b : CauSeq α abs} : a ≤ «expr ⊔ » a b :=\n  le_of_exists ⟨0, fun j hj => le_sup_left⟩\n#align le_sup_left le_sup_left\n-/\n\n",
 "le_of_le_of_eq":
 "#print le_of_le_of_eq /-\ntheorem le_of_le_of_eq {f g h : CauSeq α abs} (hfg : f ≤ g) (hgh : g ≈ h) : f ≤ h :=\n  hfg.elim (fun h => or.inl (CauSeq.lt_of_lt_of_eq h hgh)) fun h => or.inr (setoid.trans h hgh)\n#align le_of_le_of_eq le_of_le_of_eq\n-/\n\n",
 "le_of_exists":
 "theorem le_of_exists {f g : CauSeq α abs} (h : ∃ i, ∀ j ≥ i, f j ≤ g j) : f ≤ g :=\n  let ⟨i, hi⟩ := h\n  (or_assoc.2 (CauSeq.lt_total f g)).elim id fun hgf =>\n    false.elim\n      (let ⟨K, hK0, j, hKj⟩ := hgf\n      not_lt_of_ge (hi (max i j) (le_max_left _ _)) (sub_pos.1 (lt_of_lt_of_le hK0 (hKj _ (le_max_right _ _)))))\n#align le_of_exists le_of_exists\n\n",
 "le_of_eq_of_le":
 "#print le_of_eq_of_le /-\ntheorem le_of_eq_of_le {f g h : CauSeq α abs} (hfg : f ≈ g) (hgh : g ≤ h) : f ≤ h :=\n  hgh.elim (or.inl ∘ CauSeq.lt_of_eq_of_lt hfg) (or.inr ∘ setoid.trans hfg)\n#align le_of_eq_of_le le_of_eq_of_le\n-/\n\n",
 "le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print le_inf /-\nprotected theorem le_inf {a b c : CauSeq α abs} (hb : a ≤ b) (hc : a ≤ c) : a ≤ «expr ⊓ » b c :=\n  by\n  cases' hb with hb hb\n  · cases' hc with hc hc\n    · exact or.inl (CauSeq.lt_inf hb hc)\n    · replace hb := le_of_eq_of_le (setoid.symm hc) hb.le\n      refine' le_of_eq_of_le hc (or.inr _)\n      exact setoid.symm (CauSeq.inf_eq_right hb)\n  · replace hc := le_of_eq_of_le (setoid.symm hb) hc\n    refine' le_of_eq_of_le hb (or.inr _)\n    exact setoid.symm (CauSeq.inf_eq_left hc)\n#align le_inf le_inf\n-/\n\n",
 "le_antisymm":
 "#print le_antisymm /-\ntheorem le_antisymm {f g : CauSeq α abs} (fg : f ≤ g) (gf : g ≤ f) : f ≈ g :=\n  fg.resolve_left (not_lt_of_le gf)\n#align le_antisymm le_antisymm\n-/\n\n",
 "is_cau":
 "theorem is_cau (f : CauSeq β abv) : IsCauSeq abv f :=\n  f.2\n#align is_cau is_cau\n\n",
 "inv_mul_cancel":
 "#print inv_mul_cancel /-\ntheorem inv_mul_cancel {f : CauSeq β abv} (hf) : inv f hf * f ≈ 1 := fun ε ε0 =>\n  let ⟨K, K0, i, H⟩ := abv_pos_of_not_limZero hf\n  ⟨i, fun j ij => by simpa [(abv_pos abv).1 (lt_of_lt_of_le K0 (H _ ij)), abv_zero abv] using ε0⟩\n#align inv_mul_cancel inv_mul_cancel\n-/\n\n",
 "inv_aux":
 "theorem inv_aux {f : CauSeq β abv} (hf : ¬LimZero f) : ∀ ε > 0, ∃ i, ∀ j ≥ i, abv ((f j)⁻¹ - (f i)⁻¹) < ε\n  | ε, ε0 =>\n    let ⟨K, K0, HK⟩ := abv_pos_of_not_limZero hf\n    let ⟨δ, δ0, Hδ⟩ := rat_inv_continuous_lemma abv ε0 K0\n    let ⟨i, H⟩ := exists_forall_ge_and HK (f.cauchy₃ δ0)\n    ⟨i, fun j ij =>\n      let ⟨iK, H'⟩ := H _ le_rfl\n      Hδ (H _ ij).1 iK (H' _ ij)⟩\n#align inv_aux inv_aux\n\n",
 "inv_apply":
 "@[simp, norm_cast]\ntheorem inv_apply {f : CauSeq β abv} (hf i) : inv f hf i = (f i)⁻¹ :=\n  rfl\n#align inv_apply inv_apply\n\n",
 "inf_lim_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_lim_zero {f g : CauSeq α abs} (hf : LimZero f) (hg : LimZero g) : LimZero («expr ⊓ » f g)\n  | ε, ε0 =>\n    (exists_forall_ge_and (hf _ ε0) (hg _ ε0)).imp fun i H j ij =>\n      by\n      let ⟨H₁, H₂⟩ := H _ ij\n      rw [abs_lt] at H₁ H₂⊢\n      exact ⟨lt_inf_iff.mpr ⟨H₁.1, H₂.1⟩, inf_lt_iff.mpr (or.inl H₁.2)⟩\n#align inf_lim_zero inf_lim_zero\n\n",
 "inf_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_le_right /-\nprotected theorem inf_le_right {a b : CauSeq α abs} : «expr ⊓ » a b ≤ b :=\n  le_of_exists ⟨0, fun j hj => inf_le_right⟩\n#align inf_le_right inf_le_right\n-/\n\n",
 "inf_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_le_left /-\nprotected theorem inf_le_left {a b : CauSeq α abs} : «expr ⊓ » a b ≤ a :=\n  le_of_exists ⟨0, fun j hj => inf_le_left⟩\n#align inf_le_left inf_le_left\n-/\n\n",
 "inf_idem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_idem /-\n@[simp]\nprotected theorem inf_idem (a : CauSeq α abs) : «expr ⊓ » a a = a :=\n  Subtype.ext inf_idem\n#align inf_idem inf_idem\n-/\n\n",
 "inf_equiv_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_equiv_inf {a₁ b₁ a₂ b₂ : CauSeq α abs} (ha : a₁ ≈ a₂) (hb : b₁ ≈ b₂) : «expr ⊓ » a₁ b₁ ≈ «expr ⊓ » a₂ b₂ :=\n  by\n  intro ε ε0\n  obtain ⟨ai, hai⟩ := ha ε ε0\n  obtain ⟨bi, hbi⟩ := hb ε ε0\n  exact\n    ⟨«expr ⊔ » ai bi, fun i hi =>\n      (abs_min_sub_min_le_max (a₁ i) (b₁ i) (a₂ i) (b₂ i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))⟩\n#align inf_equiv_inf inf_equiv_inf\n\n",
 "inf_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_eq_right /-\nprotected theorem inf_eq_right {a b : CauSeq α abs} (h : b ≤ a) : «expr ⊓ » a b ≈ b :=\n  by\n  obtain ⟨ε, ε0 : _ < _, i, h⟩ | h := h\n  · intro _ _\n    refine' ⟨i, fun j hj => _⟩\n    dsimp\n    erw [← min_sub_sub_right]\n    rwa [sub_self, min_eq_right, abs_zero]\n    exact ε0.le.trans (h _ hj)\n  · refine' setoid.trans (inf_equiv_inf (setoid.symm h) (setoid.refl _)) _\n    rw [CauSeq.inf_idem]\n    exact setoid.refl _\n#align inf_eq_right inf_eq_right\n-/\n\n",
 "inf_eq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_eq_left /-\nprotected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : «expr ⊓ » a b ≈ a := by\n  simpa only [CauSeq.inf_comm] using CauSeq.inf_eq_right h\n#align inf_eq_left inf_eq_left\n-/\n\n",
 "inf_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print inf_comm /-\nprotected theorem inf_comm (a b : CauSeq α abs) : «expr ⊓ » a b = «expr ⊓ » b a :=\n  Subtype.ext inf_comm\n#align inf_comm inf_comm\n-/\n\n",
 "ext":
 "theorem ext {f g : CauSeq β abv} (h : ∀ i, f i = g i) : f = g :=\n  Subtype.eq (funext h)\n#align ext ext\n\n",
 "exists_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem exists_lt (f : CauSeq α abs) : ∃ a : α, (exprconst) a < f :=\n  let ⟨a, h⟩ := (-f).exists_gt\n  ⟨-a, show Pos _ by rwa [const_neg, sub_neg_eq_add, add_comm, ← sub_neg_eq_add]⟩\n#align exists_lt exists_lt\n\n",
 "exists_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem exists_gt (f : CauSeq α abs) : ∃ a : α, f < (exprconst) a :=\n  let ⟨K, H⟩ := f.bounded\n  ⟨K + 1, 1, zero_lt_one, 0, fun i _ =>\n    by\n    rw [sub_apply, const_apply, le_sub_iff_add_le', add_le_add_iff_right]\n    exact le_of_lt (abs_lt.1 (H _)).2⟩\n#align exists_gt exists_gt\n\n",
 "exists_forall_ge_and":
 "#print exists_forall_ge_and /-\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem exists_forall_ge_and {α} [linear_order α] {P Q : α → Prop} :\n    (∃ i, ∀ j ≥ i, P j) → (∃ i, ∀ j ≥ i, Q j) → ∃ i, ∀ j ≥ i, P j ∧ Q j\n  | ⟨a, h₁⟩, ⟨b, h₂⟩ =>\n    let ⟨c, ac, bc⟩ := exists_ge_of_linear a b\n    ⟨c, fun j hj => ⟨h₁ _ (le_trans ac hj), h₂ _ (le_trans bc hj)⟩⟩\n#align exists_forall_ge_and exists_forall_ge_and\n-/\n\n",
 "equiv_def₃":
 "theorem equiv_def₃ {f g : CauSeq β abv} (h : f ≈ g) {ε : α} (ε0 : 0 < ε) : ∃ i, ∀ j ≥ i, ∀ k ≥ j, abv (f k - g j) < ε :=\n  (exists_forall_ge_and (h _ <| half_pos ε0) (f.cauchy₃ <| half_pos ε0)).imp fun i H j ij k jk =>\n    by\n    let ⟨h₁, h₂⟩ := H _ ij\n    have := lt_of_le_of_lt (abv_add abv (f j - g j) _) (add_lt_add h₁ (h₂ _ jk)) <;>\n      rwa [sub_add_sub_cancel', add_halves] at this\n#align equiv_def₃ equiv_def₃\n\n",
 "const_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n@[simp]\ntheorem const_zero : (exprconst) 0 = 0 :=\n  rfl\n#align const_zero const_zero\n\n",
 "const_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_sub (x y : β) : (exprconst) (x - y) = (exprconst) x - (exprconst) y :=\n  rfl\n#align const_sub const_sub\n\n",
 "const_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_smul (a : G) (x : β) : (exprconst) («expr • » a x) = «expr • » a ((exprconst) x) :=\n  rfl\n#align const_smul const_smul\n\n",
 "const_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_pow (x : β) (n : ℕ) : (exprconst) (x ^ n) = (exprconst) x ^ n :=\n  rfl\n#align const_pow const_pow\n\n",
 "const_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_pos {x : α} : Pos ((exprconst) x) ↔ 0 < x :=\n  ⟨fun ⟨K, K0, i, h⟩ => lt_of_lt_of_le K0 (h _ le_rfl), fun h => ⟨x, h, 0, fun j _ => le_rfl⟩⟩\n#align const_pos const_pos\n\n",
 "const_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n@[simp]\ntheorem const_one : (exprconst) 1 = 1 :=\n  rfl\n#align const_one const_one\n\n",
 "const_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_neg (x : β) : (exprconst) (-x) = -(exprconst) x :=\n  rfl\n#align const_neg const_neg\n\n",
 "const_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_mul (x y : β) : (exprconst) (x * y) = (exprconst) x * (exprconst) y :=\n  rfl\n#align const_mul const_mul\n\n",
 "const_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_lt {x y : α} : (exprconst) x < (exprconst) y ↔ x < y :=\n  show Pos _ ↔ _ by rw [← const_sub, const_pos, sub_pos]\n#align const_lt const_lt\n\n",
 "const_lim_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_lim_zero {x : β} : LimZero ((exprconst) x) ↔ x = 0 :=\n  ⟨fun H =>\n    (abv_eq_zero abv).1 <|\n      eq_of_le_of_forall_le_of_dense (abv_nonneg abv _) fun ε ε0 =>\n        let ⟨i, hi⟩ := H _ ε0\n        le_of_lt <| hi _ le_rfl,\n    fun e => e.symm ▸ zero_limZero⟩\n#align const_lim_zero const_lim_zero\n\n",
 "const_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_le {x y : α} : (exprconst) x ≤ (exprconst) y ↔ x ≤ y := by\n  rw [le_iff_lt_or_eq] <;> exact or_congr const_lt const_equiv\n#align const_le const_le\n\n",
 "const_inv":
 "theorem const_inv {x : β} (hx : x ≠ 0) : const abv x⁻¹ = inv (const abv x) (by rwa [const_lim_zero]) :=\n  rfl\n#align const_inv const_inv\n\n",
 "const_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_inj {x y : β} : ((exprconst) x : CauSeq β abv) = (exprconst) y ↔ x = y :=\n  ⟨fun h => congr_arg (fun f : CauSeq β abv => (f : ℕ → β) 0) h, congr_arg _⟩\n#align const_inj const_inj\n\n",
 "const_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_equiv {x y : β} : (exprconst) x ≈ (exprconst) y ↔ x = y :=\n  show LimZero _ ↔ _ by rw [← const_sub, const_lim_zero, sub_eq_zero]\n#align const_equiv const_equiv\n\n",
 "const_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n@[simp, norm_cast]\ntheorem const_apply (x : β) (i : ℕ) : ((exprconst) x : ℕ → β) i = x :=\n  rfl\n#align const_apply const_apply\n\n",
 "const_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\ntheorem const_add (x y : β) : (exprconst) (x + y) = (exprconst) x + (exprconst) y :=\n  rfl\n#align const_add const_add\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_zero : «expr⇑ » (0 : CauSeq β abv) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp, norm_cast]\ntheorem coe_sup (f g : CauSeq α abs) : «expr⇑ » («expr ⊔ » f g) = «expr ⊔ » f g :=\n  rfl\n#align coe_sup coe_sup\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_sub (f g : CauSeq β abv) : «expr⇑ » (f - g) = f - g :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, norm_cast]\ntheorem coe_smul (a : G) (f : CauSeq β abv) : «expr⇑ » («expr • » a f) = «expr • » a f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_pow (f : CauSeq β abv) (n : ℕ) : «expr⇑ » (f ^ n) = f ^ n :=\n  rfl\n#align coe_pow coe_pow\n\n",
 "coe_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_one : «expr⇑ » (1 : CauSeq β abv) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_neg (f : CauSeq β abv) : «expr⇑ » (-f) = -f :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_mul (f g : CauSeq β abv) : «expr⇑ » (f * g) = f * g :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_inv {f : CauSeq β abv} (hf) : «expr⇑ » (inv f hf) = f⁻¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf (f g : CauSeq α abs) : «expr⇑ » («expr ⊓ » f g) = «expr ⊓ » f g :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprconst -/\n@[simp, norm_cast]\ntheorem coe_const (x : β) : «expr⇑ » ((exprconst) x) = Function.const _ x :=\n  rfl\n#align coe_const coe_const\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_add (f g : CauSeq β abv) : «expr⇑ » (f + g) = f + g :=\n  rfl\n#align coe_add coe_add\n\n",
 "cauchy₃":
 "theorem cauchy₃ (f : CauSeq β abv) {ε} : 0 < ε → ∃ i, ∀ j ≥ i, ∀ k ≥ j, abv (f k - f j) < ε :=\n  f.2.cauchy₃\n#align cauchy₃ cauchy₃\n\n",
 "cauchy₂":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (j k «expr ≥ » i) -/\n-- see Note [nolint_ge]\n@[nolint ge_or_gt]\ntheorem cauchy₂ (f : CauSeq β abv) {ε} : 0 < ε → ∃ i, ∀ (j) (_ : j ≥ i) (k) (_ : k ≥ i), abv (f j - f k) < ε :=\n  f.2.cauchy₂\n#align cauchy₂ cauchy₂\n\n",
 "bounded'":
 "theorem bounded' (f : CauSeq β abv) (x : α) : ∃ r > x, ∀ i, abv (f i) < r :=\n  let ⟨r, h⟩ := f.bounded\n  ⟨max r (x + 1), lt_of_lt_of_le (lt_add_one _) (le_max_right _ _), fun i => lt_of_lt_of_le (h i) (le_max_left _ _)⟩\n#align bounded' bounded'\n\n",
 "bounded":
 "theorem bounded (f : CauSeq β abv) : ∃ r, ∀ i, abv (f i) < r :=\n  by\n  cases' f.cauchy zero_lt_one with i h\n  set R : ℕ → α := @nat.rec (fun n => α) (abv (f 0)) fun i c => max c (abv (f i.succ)) with hR\n  have : ∀ i, ∀ j ≤ i, abv (f j) ≤ R i := by\n    refine' nat.rec (by simp [hR]) _\n    rintro i hi j (rfl | hj)\n    · simp\n    exact (hi j hj).trans (le_max_left _ _)\n  refine' ⟨R i + 1, fun j => _⟩\n  cases' lt_or_le j i with ij ij\n  · exact lt_of_le_of_lt (this i _ (le_of_lt ij)) (lt_add_one _)\n  · have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add_of_le_of_lt (this i _ le_rfl) (h _ ij))\n    rw [add_sub, add_comm] at this\n    simpa\n#align bounded bounded\n\n",
 "add_pos":
 "#print add_pos /-\ntheorem add_pos {f g : CauSeq α abs} : Pos f → Pos g → Pos (f + g)\n  | ⟨F, F0, hF⟩, ⟨G, G0, hG⟩ =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF hG\n    ⟨_, add_pos F0 G0, i, fun j ij =>\n      let ⟨h₁, h₂⟩ := h _ ij\n      add_le_add h₁ h₂⟩\n#align add_pos add_pos\n-/\n\n",
 "add_lim_zero":
 "theorem add_lim_zero {f g : CauSeq β abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f + g)\n  | ε, ε0 =>\n    (exists_forall_ge_and (hf _ <| half_pos ε0) (hg _ <| half_pos ε0)).imp fun i H j ij =>\n      by\n      let ⟨H₁, H₂⟩ := H _ ij\n      simpa [add_halves ε] using lt_of_le_of_lt (abv_add abv _ _) (add_lt_add H₁ H₂)\n#align add_lim_zero add_lim_zero\n\n",
 "add_equiv_add":
 "theorem add_equiv_add {f1 f2 g1 g2 : CauSeq β abv} (hf : f1 ≈ f2) (hg : g1 ≈ g2) : f1 + g1 ≈ f2 + g2 := by\n  simpa only [← add_sub_add_comm] using add_lim_zero hf hg\n#align add_equiv_add add_equiv_add\n\n",
 "add_apply":
 "@[simp, norm_cast]\ntheorem add_apply (f g : CauSeq β abv) (i : ℕ) : (f + g) i = f i + g i :=\n  rfl\n#align add_apply add_apply\n\n",
 "add":
 "theorem add (hf : IsCauSeq abv f) (hg : IsCauSeq abv g) : IsCauSeq abv (f + g) := fun ε ε0 =>\n  let ⟨δ, δ0, Hδ⟩ := rat_add_continuous_lemma abv ε0\n  let ⟨i, H⟩ := exists_forall_ge_and (hf.cauchy₃ δ0) (hg.cauchy₃ δ0)\n  ⟨i, fun j ij =>\n    let ⟨H₁, H₂⟩ := H _ le_rfl\n    Hδ (H₁ _ ij) (H₂ _ ij)⟩\n#align add add\n\n",
 "abv_pos_of_not_lim_zero":
 "theorem abv_pos_of_not_lim_zero {f : CauSeq β abv} (hf : ¬LimZero f) : ∃ K > 0, ∃ i, ∀ j ≥ i, K ≤ abv (f j) :=\n  by\n  haveI := classical.prop_decidable\n  by_contra nk\n  refine' hf fun ε ε0 => _\n  simp [not_forall] at nk\n  cases' f.cauchy₃ (half_pos ε0) with i hi\n  rcases nk _ (half_pos ε0) i with ⟨j, ij, hj⟩\n  refine' ⟨j, fun k jk => _⟩\n  have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add (hi j ij k jk) hj)\n  rwa [sub_add_cancel, add_halves] at this\n#align abv_pos_of_not_lim_zero abv_pos_of_not_lim_zero\n\n",
 "Cauchy":
 "#print Cauchy /-\ntheorem Cauchy (f : CauSeq β abv) : ∀ {ε}, 0 < ε → ∃ i, ∀ j ≥ i, abv (f j - f i) < ε :=\n  f.2\n#align cauchy Cauchy\n-/\n\n"}