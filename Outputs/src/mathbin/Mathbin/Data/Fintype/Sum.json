{"univ_disj_sum_univ":
 "/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n@[simp]\ntheorem finset.univ_disj_sum_univ {α β : Type _} [fintype α] [fintype β] :\n    univ.disj_sum univ = (univ : Finset (Sum α β)) :=\n  rfl\n#align finset.univ_disj_sum_univ finset.univ_disj_sum_univ\n\n",
 "infinite_sum":
 "@[simp]\ntheorem infinite_sum : Infinite (Sum α β) ↔ Infinite α ∨ Infinite β :=\n  by\n  refine' ⟨fun H => _, fun H => H.elim (@sum.infinite_of_left α β) (@sum.infinite_of_right α β)⟩\n  contrapose! H; haveI := fintype_of_not_infinite H.1; haveI := fintype_of_not_infinite H.2\n  exact Infinite.false\n#align infinite_sum infinite_sum\n\n",
 "image_subtype_univ_ssubset_image_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem image_subtype_univ_ssubset_image_univ [fintype α] (k : β) (b : α → β) (hk : k ∈ image b univ) (p : β → Prop)\n    [decidable_pred p] (hp : ¬p k) : «expr ⊂ » (image (fun i : { a // p (b a) } => b ↑i) univ) (image b univ) :=\n  by\n  constructor\n  · intro x hx\n    rcases mem_image.1 hx with ⟨y, _, hy⟩\n    exact hy ▸ mem_image_of_mem b (mem_univ y)\n  · intro h\n    rw [mem_image] at hk\n    rcases hk with ⟨k', _, hk'⟩\n    subst hk'\n    have := h (mem_image_of_mem b (mem_univ k'))\n    rw [mem_image] at this\n    rcases this with ⟨j, hj, hj'⟩\n    exact hp (hj' ▸ j.2)\n#align image_subtype_univ_ssubset_image_univ image_subtype_univ_ssubset_image_univ\n\n",
 "image_subtype_ne_univ_eq_image_erase":
 "theorem image_subtype_ne_univ_eq_image_erase [fintype α] (k : β) (b : α → β) :\n    image (fun i : { a // b a ≠ k } => b ↑i) univ = (image b univ).erase k :=\n  by\n  apply subset_antisymm\n  · rw [image_subset_iff]\n    intro i _\n    apply mem_erase_of_ne_of_mem i.2 (mem_image_of_mem _ (mem_univ _))\n  · intro i hi\n    rw [mem_image]\n    rcases mem_image.1 (erase_subset _ _ hi) with ⟨a, _, ha⟩\n    subst ha\n    exact ⟨⟨a, ne_of_mem_erase hi⟩, mem_univ _, rfl⟩\n#align image_subtype_ne_univ_eq_image_erase image_subtype_ne_univ_eq_image_erase\n\n",
 "exists_equiv_extend_of_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- Any injection from a set `s` in a fintype `α` to a finset `t` of the same cardinality as `α`\ncan be extended to a bijection between `α` and `t`. -/\ntheorem set.maps_to.exists_equiv_extend_of_card_eq [fintype α] {t : Finset β} (hαt : fintype.card α = t.card)\n    {s : set α} {f : α → β} (hfst : s.maps_to f t) (hfs : Set.InjOn f s) :\n    ∃ g : «expr ≃ » α t, ∀ i ∈ s, (g i : β) = f i := by\n  classical\n    let s' : Finset α := s.to_finset\n    have hfst' : s'.image f ⊆ t := by simpa [← Finset.coe_subset] using hfst\n    have hfs' : Set.InjOn f s' := by simpa using hfs\n    obtain ⟨g, hg⟩ := finset.exists_equiv_extend_of_card_eq hαt hfst' hfs'\n    refine' ⟨g, fun i hi => _⟩\n    apply hg\n    simpa using hi\n#align set.maps_to.exists_equiv_extend_of_card_eq set.maps_to.exists_equiv_extend_of_card_eq\n\n",
 "card_sum":
 "@[simp]\ntheorem fintype.card_sum [fintype α] [fintype β] : fintype.card (Sum α β) = fintype.card α + fintype.card β :=\n  card_disj_sum _ _\n#align fintype.card_sum fintype.card_sum\n\n",
 "card_subtype_or_disjoint":
 "theorem fintype.card_subtype_or_disjoint (p q : α → Prop) (h : Disjoint p q) [fintype { x // p x }]\n    [fintype { x // q x }] [fintype { x // p x ∨ q x }] :\n    fintype.card { x // p x ∨ q x } = fintype.card { x // p x } + fintype.card { x // q x } := by\n  classical\n    convert fintype.card_congr (subtypeOrEquiv p q h)\n    simp\n#align fintype.card_subtype_or_disjoint fintype.card_subtype_or_disjoint\n\n",
 "card_subtype_or":
 "theorem fintype.card_subtype_or (p q : α → Prop) [fintype { x // p x }] [fintype { x // q x }]\n    [fintype { x // p x ∨ q x }] :\n    fintype.card { x // p x ∨ q x } ≤ fintype.card { x // p x } + fintype.card { x // q x } := by\n  classical\n    convert fintype.card_le_of_embedding (subtypeOrLeftEmbedding p q)\n    rw [fintype.card_sum]\n#align fintype.card_subtype_or fintype.card_subtype_or\n\n"}