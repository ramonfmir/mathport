{"univ_disjSum_univ":
 "#print Finset.univ_disjSum_univ /-\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n@[simp]\ntheorem Finset.univ_disjSum_univ {α β : Type _} [Fintype α] [Fintype β] :\n    univ.disj_sum univ = (univ : Finset (Sum α β)) :=\n  rfl\n#align finset.univ_disj_sum_univ Finset.univ_disjSum_univ\n-/\n\n",
 "infinite_sum":
 "#print infinite_sum /-\n@[simp]\ntheorem infinite_sum : Infinite (Sum α β) ↔ Infinite α ∨ Infinite β :=\n  by\n  refine' ⟨fun H => _, fun H => H.elim (@Sum.infinite_of_left α β) (@Sum.infinite_of_right α β)⟩\n  contrapose! H; haveI := fintypeOfNotInfinite H.1; haveI := fintypeOfNotInfinite H.2\n  exact Infinite.false\n#align infinite_sum infinite_sum\n-/\n\n",
 "image_subtype_univ_ssubset_image_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n#print image_subtype_univ_ssubset_image_univ /-\ntheorem image_subtype_univ_ssubset_image_univ [Fintype α] [DecidableEq β] (k : β) (b : α → β) (hk : k ∈ image b univ)\n    (p : β → Prop) [DecidablePred p] (hp : ¬p k) :\n    «expr ⊂ » (image (fun i : { a // p (b a) } => b ↑i) univ) (image b univ) :=\n  by\n  constructor\n  · intro x hx\n    rcases mem_image.1 hx with ⟨y, _, hy⟩\n    exact hy ▸ mem_image_of_mem b (mem_univ y)\n  · intro h\n    rw [mem_image] at hk\n    rcases hk with ⟨k', _, hk'⟩\n    subst hk'\n    have := h (mem_image_of_mem b (mem_univ k'))\n    rw [mem_image] at this\n    rcases this with ⟨j, hj, hj'⟩\n    exact hp (hj' ▸ j.2)\n#align image_subtype_univ_ssubset_image_univ image_subtype_univ_ssubset_image_univ\n-/\n\n",
 "image_subtype_ne_univ_eq_image_erase":
 "#print image_subtype_ne_univ_eq_image_erase /-\ntheorem image_subtype_ne_univ_eq_image_erase [Fintype α] [DecidableEq β] (k : β) (b : α → β) :\n    image (fun i : { a // b a ≠ k } => b ↑i) univ = (image b univ).erase k :=\n  by\n  apply subset_antisymm\n  · rw [image_subset_iff]\n    intro i _\n    apply mem_erase_of_ne_of_mem i.2 (mem_image_of_mem _ (mem_univ _))\n  · intro i hi\n    rw [mem_image]\n    rcases mem_image.1 (erase_subset _ _ hi) with ⟨a, _, ha⟩\n    subst ha\n    exact ⟨⟨a, ne_of_mem_erase hi⟩, mem_univ _, rfl⟩\n#align image_subtype_ne_univ_eq_image_erase image_subtype_ne_univ_eq_image_erase\n-/\n\n",
 "exists_equiv_extend_of_card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Set.MapsTo.exists_equiv_extend_of_card_eq /-\n/-- Any injection from a set `s` in a fintype `α` to a finset `t` of the same cardinality as `α`\ncan be extended to a bijection between `α` and `t`. -/\ntheorem Set.MapsTo.exists_equiv_extend_of_card_eq [Fintype α] {t : Finset β} (hαt : Fintype.card α = t.card) {s : Set α}\n    {f : α → β} (hfst : s.maps_to f t) (hfs : Set.InjOn f s) : ∃ g : «expr ≃ » α t, ∀ i ∈ s, (g i : β) = f i := by\n  classical\n    let s' : Finset α := s.to_finset\n    have hfst' : s'.image f ⊆ t := by simpa [← Finset.coe_subset] using hfst\n    have hfs' : Set.InjOn f s' := by simpa using hfs\n    obtain ⟨g, hg⟩ := Finset.exists_equiv_extend_of_card_eq hαt hfst' hfs'\n    refine' ⟨g, fun i hi => _⟩\n    apply hg\n    simpa using hi\n#align set.maps_to.exists_equiv_extend_of_card_eq Set.MapsTo.exists_equiv_extend_of_card_eq\n-/\n\n",
 "card_sum":
 "#print Fintype.card_sum /-\n@[simp]\ntheorem Fintype.card_sum [Fintype α] [Fintype β] : Fintype.card (Sum α β) = Fintype.card α + Fintype.card β :=\n  card_disjSum _ _\n#align fintype.card_sum Fintype.card_sum\n-/\n\n",
 "card_subtype_or_disjoint":
 "#print Fintype.card_subtype_or_disjoint /-\ntheorem Fintype.card_subtype_or_disjoint (p q : α → Prop) (h : Disjoint p q) [Fintype { x // p x }]\n    [Fintype { x // q x }] [Fintype { x // p x ∨ q x }] :\n    Fintype.card { x // p x ∨ q x } = Fintype.card { x // p x } + Fintype.card { x // q x } := by\n  classical\n    convert Fintype.card_congr (subtypeOrEquiv p q h)\n    simp\n#align fintype.card_subtype_or_disjoint Fintype.card_subtype_or_disjoint\n-/\n\n",
 "card_subtype_or":
 "#print Fintype.card_subtype_or /-\ntheorem Fintype.card_subtype_or (p q : α → Prop) [Fintype { x // p x }] [Fintype { x // q x }]\n    [Fintype { x // p x ∨ q x }] :\n    Fintype.card { x // p x ∨ q x } ≤ Fintype.card { x // p x } + Fintype.card { x // q x } := by\n  classical\n    convert Fintype.card_le_of_embedding (subtypeOrLeftEmbedding p q)\n    rw [Fintype.card_sum]\n#align fintype.card_subtype_or Fintype.card_subtype_or\n-/\n\n"}