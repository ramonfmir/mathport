{"univ_option":
 "#print univ_option /-\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem univ_option (α : Type _) [Fintype α] : (univ : Finset (Option α)) = insertNone univ :=\n  rfl\n#align univ_option univ_option\n-/\n\n",
 "induction_empty_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Finite.induction_empty_option /-\n/-- An induction principle for finite types, analogous to `nat.rec`. It effectively says\nthat every `fintype` is either `empty` or `option α`, up to an `equiv`. -/\ntheorem Finite.induction_empty_option {P : Type u → Prop} (of_equiv : ∀ {α β}, «expr ≃ » α β → P α → P β)\n    (h_empty : P PEmpty) (h_option : ∀ {α} [Fintype α], P α → P (Option α)) (α : Type u) [Finite α] : P α :=\n  by\n  cases nonempty_fintype α\n  refine' Fintype.induction_empty_option _ _ _ α\n  exacts[fun α β _ => of_equiv, h_empty, @h_option]\n#align finite.induction_empty_option Finite.induction_empty_option\n-/\n\n",
 "card_option":
 "#print Fintype.card_option /-\n@[simp]\ntheorem Fintype.card_option {α : Type _} [Fintype α] : Fintype.card (Option α) = Fintype.card α + 1 :=\n  (Finset.card_cons _).trans <| congr_arg₂ _ (card_map _) rfl\n#align fintype.card_option Fintype.card_option\n-/\n\n"}