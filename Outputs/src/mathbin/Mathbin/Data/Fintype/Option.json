{"univ_option":
 "/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem univ_option (α : Type _) [fintype α] : (univ : Finset (option α)) = insert_none univ :=\n  rfl\n#align univ_option univ_option\n\n",
 "induction_empty_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- An induction principle for finite types, analogous to `nat.rec`. It effectively says\nthat every `fintype` is either `empty` or `option α`, up to an `equiv`. -/\ntheorem finite.induction_empty_option {P : Type u → Prop} (of_equiv : ∀ {α β}, «expr ≃ » α β → P α → P β)\n    (h_empty : P PEmpty) (h_option : ∀ {α} [fintype α], P α → P (option α)) (α : Type u) [Finite α] : P α :=\n  by\n  cases nonempty_fintype α\n  refine' fintype.induction_empty_option _ _ _ α\n  exacts[fun α β _ => of_equiv, h_empty, @h_option]\n#align finite.induction_empty_option finite.induction_empty_option\n\n",
 "card_option":
 "@[simp]\ntheorem fintype.card_option {α : Type _} [fintype α] : fintype.card (option α) = fintype.card α + 1 :=\n  (finset.card_cons _).trans <| congr_arg₂ _ (card_map _) rfl\n#align fintype.card_option fintype.card_option\n\n"}