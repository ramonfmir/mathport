{"card_filter_univ_succ'":
 "theorem card_filter_univ_succ' (p : fin (n + 1) → Prop) [decidable_pred p] :\n    (univ.filter p).card = ite (p 0) 1 0 + (univ.filter (p ∘ fin.succ)).card :=\n  by\n  rw [fin.univ_succ, filter_cons, card_disj_union, filter_map, card_map]\n  split_ifs <;> simp\n#align card_filter_univ_succ' card_filter_univ_succ'\n\n",
 "card_filter_univ_succ":
 "theorem card_filter_univ_succ (p : fin (n + 1) → Prop) [decidable_pred p] :\n    (univ.filter p).card = if p 0 then (univ.filter (p ∘ fin.succ)).card + 1 else (univ.filter (p ∘ fin.succ)).card :=\n  (card_filter_univ_succ' p).trans (by split_ifs <;> simp [add_comm 1])\n#align card_filter_univ_succ card_filter_univ_succ\n\n",
 "card_filter_univ_eq_vector_nth_eq_count":
 "theorem card_filter_univ_eq_vector_nth_eq_count [decidable_eq α] (a : α) (v : Vector α n) :\n    (univ.filter fun i => a = v.nth i).card = v.to_list.count a :=\n  by\n  induction' v using vector.induction_on with n x xs hxs\n  · simp\n  ·\n    simp_rw [card_filter_univ_succ', vector.nth_cons_zero, Vector.toList_cons, function.comp, vector.nth_cons_succ, hxs,\n      List.count_cons', add_comm (ite (a = x) 1 0)]\n#align card_filter_univ_eq_vector_nth_eq_count card_filter_univ_eq_vector_nth_eq_count\n\n",
 "Ioi_zero_eq_map":
 "/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n@[simp]\ntheorem Ioi_zero_eq_map : Ioi (0 : fin n.succ) = univ.map (Fin.succEmbedding _).to_embedding :=\n  by\n  ext i\n  simp only [mem_Ioi, mem_map, mem_univ, Function.Embedding.coeFn_mk, exists_true_left]\n  constructor\n  · refine' cases _ _ i\n    · rintro ⟨⟨⟩⟩\n    · intro j _\n      exact ⟨j, rfl⟩\n  · rintro ⟨i, _, rfl⟩\n    exact succ_pos _\n#align Ioi_zero_eq_map Ioi_zero_eq_map\n\n",
 "Ioi_succ":
 "@[simp]\ntheorem Ioi_succ (i : fin n) : Ioi i.succ = (Ioi i).map (Fin.succEmbedding _).to_embedding :=\n  by\n  ext i\n  simp only [mem_filter, mem_Ioi, mem_map, mem_univ, true_and_iff, Function.Embedding.coeFn_mk, exists_true_left]\n  constructor\n  · refine' cases _ _ i\n    · rintro ⟨⟨⟩⟩\n    · intro i hi\n      refine' ⟨i, succ_lt_succ_iff.mp hi, rfl⟩\n  · rintro ⟨i, hi, rfl⟩\n    simpa\n#align Ioi_succ Ioi_succ\n\n"}