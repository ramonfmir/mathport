{"map_subtype_embedding_univ":
 "/-\nCopyright (c) 2021 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n-- TODO: replace `subtype` with `coe` in the name of this lemma and `fin.map_subtype_embedding_Iio`\ntheorem map_subtype_embedding_univ : (Finset.univ : Finset (Fin n)).map Fin.valEmbedding = Iio n :=\n  by\n  ext\n  simp [order_iso_subtype.symm.surjective.exists, OrderIso.symm]\n#align map_subtype_embedding_univ map_subtype_embedding_univ\n\n",
 "card_filter_univ_succ'":
 "theorem card_filter_univ_succ' (p : Fin (n + 1) → Prop) [DecidablePred p] :\n    (univ.filter p).card = ite (p 0) 1 0 + (univ.filter (p ∘ fin.succ)).card :=\n  by\n  rw [Fin.univ_succ, filter_cons, card_disj_union, filter_map, card_map]\n  split_ifs <;> simp\n#align card_filter_univ_succ' card_filter_univ_succ'\n\n",
 "card_filter_univ_succ":
 "theorem card_filter_univ_succ (p : Fin (n + 1) → Prop) [DecidablePred p] :\n    (univ.filter p).card = if p 0 then (univ.filter (p ∘ fin.succ)).card + 1 else (univ.filter (p ∘ fin.succ)).card :=\n  (card_filter_univ_succ' p).trans (by split_ifs <;> simp [add_comm 1])\n#align card_filter_univ_succ card_filter_univ_succ\n\n",
 "card_filter_univ_eq_vector_nth_eq_count":
 "theorem card_filter_univ_eq_vector_nth_eq_count [DecidableEq α] (a : α) (v : Vector α n) :\n    (univ.filter fun i => a = v.nth i).card = v.to_list.count a :=\n  by\n  induction' v using Vector.inductionOn with n x xs hxs\n  · simp\n  ·\n    simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Function.comp, Vector.get_cons_succ, hxs,\n      List.count_cons', add_comm (ite (a = x) 1 0)]\n#align card_filter_univ_eq_vector_nth_eq_count card_filter_univ_eq_vector_nth_eq_count\n\n",
 "Ioi_zero_eq_map":
 "@[simp]\ntheorem Ioi_zero_eq_map : Ioi (0 : Fin n.succ) = univ.map (Fin.succEmbedding _).to_embedding :=\n  by\n  ext i\n  simp only [mem_Ioi, mem_map, mem_univ, Function.Embedding.coeFn_mk, exists_true_left]\n  constructor\n  · refine' cases _ _ i\n    · rintro ⟨⟨⟩⟩\n    · intro j _\n      exact ⟨j, rfl⟩\n  · rintro ⟨i, _, rfl⟩\n    exact succ_pos _\n#align Ioi_zero_eq_map Ioi_zero_eq_map\n\n",
 "Ioi_succ":
 "@[simp]\ntheorem Ioi_succ (i : Fin n) : Ioi i.succ = (Ioi i).map (Fin.succEmbedding _).to_embedding :=\n  by\n  ext i\n  simp only [mem_filter, mem_Ioi, mem_map, mem_univ, true_and_iff, Function.Embedding.coeFn_mk, exists_true_left]\n  constructor\n  · refine' cases _ _ i\n    · rintro ⟨⟨⟩⟩\n    · intro i hi\n      refine' ⟨i, succ_lt_succ_iff.mp hi, rfl⟩\n  · rintro ⟨i, hi, rfl⟩\n    simpa\n#align Ioi_succ Ioi_succ\n\n",
 "Iio_last_eq_map":
 "@[simp]\ntheorem Iio_last_eq_map : Iio (Fin.last n) = Finset.univ.map Fin.castSucc.to_embedding :=\n  by\n  apply Finset.map_injective Fin.valEmbedding\n  rw [Finset.map_map, Fin.map_valEmbedding_Iio, Fin.val_last]\n  exact map_subtype_embedding_univ.symm\n#align Iio_last_eq_map Iio_last_eq_map\n\n",
 "Iio_cast_succ":
 "@[simp]\ntheorem Iio_cast_succ (i : Fin n) : Iio (castSucc i) = (Iio i).map Fin.castSucc.to_embedding :=\n  by\n  apply Finset.map_injective Fin.valEmbedding\n  rw [Finset.map_map, Fin.map_valEmbedding_Iio]\n  exact (Fin.map_valEmbedding_Iio i).symm\n#align Iio_cast_succ Iio_cast_succ\n\n"}