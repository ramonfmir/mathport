{"nodup_perms_of_list":
 "theorem nodup_perms_of_list : ∀ {l : list α} (hl : l.nodup), (perms_of_list l).nodup\n  | [], hl => by simp [perms_of_list]\n  | a :: l, hl => by\n    have hl' : l.nodup := hl.of_cons\n    have hln' : (perms_of_list l).nodup := nodup_perms_of_list hl'\n    have hmeml : ∀ {f : perm α}, f ∈ perms_of_list l → f a = a := fun f hf =>\n      not_not.1 (mt (mem_of_mem_perms_of_list hf) (nodup_cons.1 hl).1)\n    rw [perms_of_list, List.nodup_append, List.nodup_bind, pairwise_iff_nth_le] <;>\n      exact\n        ⟨hln',\n          ⟨fun _ _ => hln'.map fun _ _ => mul_left_cancel, fun i j hj hij x hx₁ hx₂ =>\n            let ⟨f, hf⟩ := List.mem_map'.1 hx₁\n            let ⟨g, hg⟩ := List.mem_map'.1 hx₂\n            have hix : x a = nth_le l i (lt_trans hij hj) := by rw [← hf.2, mul_apply, hmeml hf.1, swap_apply_left]\n            have hiy : x a = nth_le l j hj := by rw [← hg.2, mul_apply, hmeml hg.1, swap_apply_left]\n            absurd (hf.2.trans hg.2.symm) fun h =>\n              ne_of_lt hij <| nodup_iff_nth_le_inj.1 hl' i j (lt_trans hij hj) hj <| by rw [← hix, hiy]⟩,\n          fun f hf₁ hf₂ =>\n          let ⟨x, hx, hx'⟩ := List.mem_bind.1 hf₂\n          let ⟨g, hg⟩ := List.mem_map'.1 hx'\n          have hgxa : g⁻¹ x = a := f.injective <| by rw [hmeml hf₁, ← hg.2] <;> simp\n          have hxa : x ≠ a := fun h => (List.nodup_cons.1 hl).1 (h ▸ hx)\n          (List.nodup_cons.1 hl).1 <| hgxa ▸ mem_of_mem_perms_of_list hg.1 (by rwa [apply_inv_self, hgxa])⟩\n#align nodup_perms_of_list nodup_perms_of_list\n\n",
 "mem_perms_of_list_of_mem":
 "theorem mem_perms_of_list_of_mem {l : list α} {f : perm α} (h : ∀ x, f x ≠ x → x ∈ l) : f ∈ perms_of_list l :=\n  by\n  induction' l with a l IH generalizing f h\n  · exact List.mem_singleton.2 (equiv.ext fun x => decidable.by_contradiction <| h _)\n  by_cases hfa : f a = a\n  · refine' mem_append_left _ (IH fun x hx => mem_of_ne_of_mem _ (h x hx))\n    rintro rfl\n    exact hx hfa\n  have hfa' : f (f a) ≠ f a := mt (fun h => f.injective h) hfa\n  have : ∀ x : α, (swap a (f a) * f) x ≠ x → x ∈ l := by\n    intro x hx\n    have hxa : x ≠ a := by\n      rintro rfl\n      apply hx\n      simp only [mul_apply, swap_apply_right]\n    refine' List.mem_of_ne_of_mem hxa (h x fun h => _)\n    simp only [h, mul_apply, swap_apply_def, mul_apply, ne.def, apply_eq_iff_eq] at hx <;> split_ifs  at hx\n    exacts[hxa (h.symm.trans h_1), hx h]\n  suffices f ∈ perms_of_list l ∨ ∃ b ∈ l, ∃ g ∈ perms_of_list l, swap a b * g = f by\n    simpa only [perms_of_list, exists_prop, List.mem_map', mem_append, List.mem_bind]\n  refine' or_iff_not_imp_left.2 fun hfl => ⟨f a, _, swap a (f a) * f, IH this, _⟩\n  · exact mem_of_ne_of_mem hfa (h _ hfa')\n  · rw [← mul_assoc, mul_def (swap a (f a)) (swap a (f a)), swap_swap, ← perm.one_def, one_mul]\n#align mem_perms_of_list_of_mem mem_perms_of_list_of_mem\n\n",
 "mem_perms_of_list_iff":
 "theorem mem_perms_of_list_iff {l : list α} {f : perm α} : f ∈ perms_of_list l ↔ ∀ {x}, f x ≠ x → x ∈ l :=\n  ⟨mem_of_mem_perms_of_list, mem_perms_of_list_of_mem⟩\n#align mem_perms_of_list_iff mem_perms_of_list_iff\n\n",
 "mem_perms_of_finset_iff":
 "theorem mem_perms_of_finset_iff : ∀ {s : Finset α} {f : perm α}, f ∈ perms_of_finset s ↔ ∀ {x}, f x ≠ x → x ∈ s := by\n  rintro ⟨⟨l⟩, hs⟩ f <;> exact mem_perms_of_list_iff\n#align mem_perms_of_finset_iff mem_perms_of_finset_iff\n\n",
 "mem_of_mem_perms_of_list":
 "theorem mem_of_mem_perms_of_list : ∀ {l : list α} {f : perm α}, f ∈ perms_of_list l → ∀ {x}, f x ≠ x → x ∈ l\n  | [], f, h => by\n    have : f = 1 := by simpa [perms_of_list] using h\n    rw [this] <;> simp\n  | a :: l, f, h =>\n    (mem_append.1 h).elim (fun h x hx => mem_cons_of_mem _ (mem_of_mem_perms_of_list h hx)) fun h x hx =>\n      let ⟨y, hy, hy'⟩ := List.mem_bind.1 h\n      let ⟨g, hg₁, hg₂⟩ := List.mem_map'.1 hy'\n      if hxa : x = a then by simp [hxa]\n      else\n        if hxy : x = y then mem_cons_of_mem _ <| by rwa [hxy]\n        else\n          mem_cons_of_mem _ <|\n            mem_of_mem_perms_of_list hg₁ <| by\n              rw [eq_inv_mul_iff_mul_eq.2 hg₂, mul_apply, swap_inv, swap_apply_def] <;> split_ifs <;>\n                [exact ne.symm hxy, exact ne.symm hxa, exact hx]\n#align mem_of_mem_perms_of_list mem_of_mem_perms_of_list\n\n",
 "length_perms_of_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem length_perms_of_list : ∀ l : list α, length (perms_of_list l) = nat.factorial l.length\n  | [] => rfl\n  | a :: l => by\n    rw [length_cons, Nat.factorial_succ]\n    simp [perms_of_list, length_bind, length_perms_of_list, function.comp, nat.succ_mul]\n    cc\n#align length_perms_of_list length_perms_of_list\n\n",
 "card_perms_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem card_perms_of_finset : ∀ s : Finset α, (perms_of_finset s).card = nat.factorial s.card := by\n  rintro ⟨⟨l⟩, hs⟩ <;> exact length_perms_of_list l\n#align card_perms_of_finset card_perms_of_finset\n\n",
 "card_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem fintype.card_perm [fintype α] : fintype.card (perm α) = nat.factorial (fintype.card α) :=\n  subsingleton.elim (@fintype_perm α _ _) (@equiv.fintype α α _ _ _ _) ▸ card_perms_of_finset _\n#align fintype.card_perm fintype.card_perm\n\n",
 "card_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\ntheorem fintype.card_equiv [fintype α] [fintype β] (e : «expr ≃ » α β) :\n    fintype.card («expr ≃ » α β) = nat.factorial (fintype.card α) :=\n  fintype.card_congr (equiv_congr (equiv.refl α) e) ▸ fintype.card_perm\n#align fintype.card_equiv fintype.card_equiv\n\n"}