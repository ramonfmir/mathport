{"nodup_permsOfList":
 "#print nodup_permsOfList /-\ntheorem nodup_permsOfList : ∀ {l : List α} (hl : l.nodup), (permsOfList l).nodup\n  | [], hl => by simp [permsOfList]\n  | a :: l, hl => by\n    have hl' : l.nodup := hl.of_cons\n    have hln' : (permsOfList l).nodup := nodup_permsOfList hl'\n    have hmeml : ∀ {f : Perm α}, f ∈ permsOfList l → f a = a := fun f hf =>\n      Classical.not_not.1 (mt (mem_of_mem_permsOfList hf) (nodup_cons.1 hl).1)\n    rw [permsOfList, List.nodup_append, List.nodup_bind, pairwise_iff_nth_le] <;>\n      exact\n        ⟨hln',\n          ⟨fun _ _ => hln'.map fun _ _ => mul_left_cancel, fun i j hj hij x hx₁ hx₂ =>\n            let ⟨f, hf⟩ := List.mem_map.1 hx₁\n            let ⟨g, hg⟩ := List.mem_map.1 hx₂\n            have hix : x a = nth_le l i (lt_trans hij hj) := by rw [← hf.2, mul_apply, hmeml hf.1, swap_apply_left]\n            have hiy : x a = nth_le l j hj := by rw [← hg.2, mul_apply, hmeml hg.1, swap_apply_left]\n            absurd (hf.2.trans hg.2.symm) fun h =>\n              ne_of_lt hij <| nodup_iff_nth_le_inj.1 hl' i j (lt_trans hij hj) hj <| by rw [← hix, hiy]⟩,\n          fun f hf₁ hf₂ =>\n          let ⟨x, hx, hx'⟩ := List.mem_bind.1 hf₂\n          let ⟨g, hg⟩ := List.mem_map.1 hx'\n          have hgxa : g⁻¹ x = a := f.injective <| by rw [hmeml hf₁, ← hg.2] <;> simp\n          have hxa : x ≠ a := fun h => (List.nodup_cons.1 hl).1 (h ▸ hx)\n          (List.nodup_cons.1 hl).1 <| hgxa ▸ mem_of_mem_permsOfList hg.1 (by rwa [apply_inv_self, hgxa])⟩\n#align nodup_perms_of_list nodup_permsOfList\n-/\n\n",
 "mem_perms_of_finset_iff":
 "#print mem_perms_of_finset_iff /-\ntheorem mem_perms_of_finset_iff : ∀ {s : Finset α} {f : Perm α}, f ∈ permsOfFinset s ↔ ∀ {x}, f x ≠ x → x ∈ s := by\n  rintro ⟨⟨l⟩, hs⟩ f <;> exact mem_permsOfList_iff\n#align mem_perms_of_finset_iff mem_perms_of_finset_iff\n-/\n\n",
 "mem_permsOfList_of_mem":
 "#print mem_permsOfList_of_mem /-\ntheorem mem_permsOfList_of_mem {l : List α} {f : Perm α} (h : ∀ x, f x ≠ x → x ∈ l) : f ∈ permsOfList l :=\n  by\n  induction' l with a l IH generalizing f h\n  · exact List.mem_singleton.2 (Equiv.ext fun x => decidable.by_contradiction <| h _)\n  by_cases hfa : f a = a\n  · refine' mem_append_left _ (IH fun x hx => mem_of_ne_of_mem _ (h x hx))\n    rintro rfl\n    exact hx hfa\n  have hfa' : f (f a) ≠ f a := mt (fun h => f.injective h) hfa\n  have : ∀ x : α, (swap a (f a) * f) x ≠ x → x ∈ l := by\n    intro x hx\n    have hxa : x ≠ a := by\n      rintro rfl\n      apply hx\n      simp only [mul_apply, swap_apply_right]\n    refine' List.mem_of_ne_of_mem hxa (h x fun h => _)\n    simp only [h, mul_apply, swap_apply_def, mul_apply, ne.def, apply_eq_iff_eq] at hx <;> split_ifs  at hx\n    exacts[hxa (h.symm.trans h_1), hx h]\n  suffices f ∈ permsOfList l ∨ ∃ b ∈ l, ∃ g ∈ permsOfList l, swap a b * g = f by\n    simpa only [permsOfList, exists_prop, List.mem_map, mem_append, List.mem_bind]\n  refine' or_iff_not_imp_left.2 fun hfl => ⟨f a, _, swap a (f a) * f, IH this, _⟩\n  · exact mem_of_ne_of_mem hfa (h _ hfa')\n  · rw [← mul_assoc, mul_def (swap a (f a)) (swap a (f a)), swap_swap, ← perm.one_def, one_mul]\n#align mem_perms_of_list_of_mem mem_permsOfList_of_mem\n-/\n\n",
 "mem_permsOfList_iff":
 "#print mem_permsOfList_iff /-\ntheorem mem_permsOfList_iff {l : List α} {f : Perm α} : f ∈ permsOfList l ↔ ∀ {x}, f x ≠ x → x ∈ l :=\n  ⟨mem_of_mem_permsOfList, mem_permsOfList_of_mem⟩\n#align mem_perms_of_list_iff mem_permsOfList_iff\n-/\n\n",
 "mem_of_mem_permsOfList":
 "#print mem_of_mem_permsOfList /-\ntheorem mem_of_mem_permsOfList : ∀ {l : List α} {f : Perm α}, f ∈ permsOfList l → ∀ {x}, f x ≠ x → x ∈ l\n  | [], f, h => by\n    have : f = 1 := by simpa [permsOfList] using h\n    rw [this] <;> simp\n  | a :: l, f, h =>\n    (mem_append.1 h).elim (fun h x hx => mem_cons_of_mem _ (mem_of_mem_permsOfList h hx)) fun h x hx =>\n      let ⟨y, hy, hy'⟩ := List.mem_bind.1 h\n      let ⟨g, hg₁, hg₂⟩ := List.mem_map.1 hy'\n      if hxa : x = a then by simp [hxa]\n      else\n        if hxy : x = y then mem_cons_of_mem _ <| by rwa [hxy]\n        else\n          mem_cons_of_mem _ <|\n            mem_of_mem_permsOfList hg₁ <| by\n              rw [eq_inv_mul_iff_mul_eq.2 hg₂, mul_apply, swap_inv, swap_apply_def] <;> split_ifs <;>\n                [exact ne.symm hxy, exact ne.symm hxa, exact hx]\n#align mem_of_mem_perms_of_list mem_of_mem_permsOfList\n-/\n\n",
 "length_permsOfList":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n#print length_permsOfList /-\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem length_permsOfList : ∀ l : List α, length (permsOfList l) = nat.factorial l.length\n  | [] => rfl\n  | a :: l => by\n    rw [length_cons, Nat.factorial_succ]\n    simp [permsOfList, length_bind, length_permsOfList, Function.comp, nat.succ_mul]\n    cc\n#align length_perms_of_list length_permsOfList\n-/\n\n",
 "card_perms_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n#print card_perms_of_finset /-\ntheorem card_perms_of_finset : ∀ s : Finset α, (permsOfFinset s).card = nat.factorial s.card := by\n  rintro ⟨⟨l⟩, hs⟩ <;> exact length_permsOfList l\n#align card_perms_of_finset card_perms_of_finset\n-/\n\n",
 "card_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n#print Fintype.card_perm /-\ntheorem Fintype.card_perm [Fintype α] : Fintype.card (Perm α) = nat.factorial (Fintype.card α) :=\n  subsingleton.elim (@fintypePerm α _ _) (@equiv.fintype α α _ _ _ _) ▸ card_perms_of_finset _\n#align fintype.card_perm Fintype.card_perm\n-/\n\n",
 "card_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.factorial -/\n#print Fintype.card_equiv /-\ntheorem Fintype.card_equiv [Fintype α] [Fintype β] (e : «expr ≃ » α β) :\n    Fintype.card («expr ≃ » α β) = nat.factorial (Fintype.card α) :=\n  Fintype.card_congr (equivCongr (Equiv.refl α) e) ▸ Fintype.card_perm\n#align fintype.card_equiv Fintype.card_equiv\n-/\n\n"}