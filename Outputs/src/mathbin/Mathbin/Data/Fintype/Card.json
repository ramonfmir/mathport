{"well_founded_of_trans_of_irrefl":
 "theorem well_founded_of_trans_of_irrefl (r : α → α → Prop) [is_trans α r] [is_irrefl α r] : well_founded r := by\n  classical cases nonempty_fintype α <;>\n      exact\n        have : ∀ x y, r x y → (univ.filter fun z => r z x).card < (univ.filter fun z => r z y).card := fun x y hxy =>\n          Finset.card_lt_card <| by\n            simp only [finset.lt_iff_ssubset.symm, lt_iff_le_not_le, Finset.le_iff_subset, Finset.subset_iff,\n                mem_filter, true_and_iff, mem_univ, hxy] <;>\n              exact ⟨fun z hzx => trans hzx hxy, not_forall_of_exists_not ⟨x, not_imp.2 ⟨hxy, irrefl x⟩⟩⟩\n        subrelation.wf this (measure_wf _)\n#align well_founded_of_trans_of_irrefl well_founded_of_trans_of_irrefl\n\n",
 "well_founded_lt":
 "theorem preorder.well_founded_lt [preorder α] : well_founded ((· < ·) : α → α → Prop) :=\n  wellFounded_of_trans_of_irrefl _\n#align preorder.well_founded_lt preorder.well_founded_lt\n\n",
 "well_founded_gt":
 "theorem preorder.well_founded_gt [preorder α] : well_founded ((· > ·) : α → α → Prop) :=\n  wellFounded_of_trans_of_irrefl _\n#align preorder.well_founded_gt preorder.well_founded_gt\n\n",
 "univ_map_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n#print Finset.univ_map_embedding /-\n@[simp]\ntheorem Finset.univ_map_embedding {α : Type _} [Fintype α] (e : «expr ↪ » α α) : univ.map e = univ := by\n  rw [← e.equiv_of_fintype_self_embedding_to_embedding, univ_map_equiv_to_embedding]\n#align finset.univ_map_embedding Finset.univ_map_embedding\n-/\n\n",
 "univ_eq_singleton_of_card_one":
 "#print univ_eq_singleton_of_card_one /-\ntheorem univ_eq_singleton_of_card_one {α} [Fintype α] (x : α) (h : Fintype.card α = 1) : (univ : Finset α) = {x} :=\n  by\n  symm\n  apply eq_of_subset_of_card_le (subset_univ {x})\n  apply le_of_eq\n  simp [h, Finset.card_univ]\n#align univ_eq_singleton_of_card_one univ_eq_singleton_of_card_one\n-/\n\n",
 "two_lt_card_iff":
 "theorem two_lt_card_iff : 2 < card α ↔ ∃ a b c : α, a ≠ b ∧ a ≠ c ∧ b ≠ c := by\n  simp_rw [← Finset.card_univ, two_lt_card_iff, mem_univ, true_and_iff]\n#align two_lt_card_iff two_lt_card_iff\n\n",
 "to_finset_card":
 "-- We use an arbitrary `[fintype s]` instance here,\n-- not necessarily coming from a `[fintype α]`.\n@[simp]\ntheorem to_finset_card {α : Type _} (s : Set α) [Fintype s] : s.to_finset.card = Fintype.card s :=\n  Multiset.card_map Subtype.val Finset.univ.val\n#align to_finset_card to_finset_card\n\n",
 "surjective_iff_bijective":
 "theorem surjective_iff_bijective {f : α → α} : surjective f ↔ bijective f := by\n  simp [bijective, injective_iff_surjective]\n#align surjective_iff_bijective surjective_iff_bijective\n\n",
 "subtype_card":
 "/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem subtype_card {p : α → Prop} (s : Finset α) (H : ∀ x : α, x ∈ s ↔ p x) :\n    @card { x // p x } (Fintype.subtype s H) = s.card :=\n  Multiset.card_pmap _ _ _\n#align subtype_card subtype_card\n\n",
 "set_fintype_card_le_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n#print set_fintype_card_le_univ /-\ntheorem set_fintype_card_le_univ [Fintype α] (s : Set α) [Fintype («expr↥ » s)] :\n    Fintype.card («expr↥ » s) ≤ Fintype.card α :=\n  Fintype.card_le_of_embedding (Function.Embedding.subtype s)\n#align set_fintype_card_le_univ set_fintype_card_le_univ\n-/\n\n",
 "set_fintype_card_eq_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n#print set_fintype_card_eq_univ_iff /-\ntheorem set_fintype_card_eq_univ_iff [Fintype α] (s : Set α) [Fintype («expr↥ » s)] :\n    Fintype.card s = Fintype.card α ↔ s = Set.univ := by\n  rw [← Set.toFinset_card, Finset.card_eq_iff_eq_univ, ← Set.toFinset_univ, Set.toFinset_inj]\n#align set_fintype_card_eq_univ_iff set_fintype_card_eq_univ_iff\n-/\n\n",
 "right_inverse_of_card_le":
 "#print Function.LeftInverse.rightInverse_of_card_le /-\ntheorem Function.LeftInverse.rightInverse_of_card_le {f : α → β} {g : β → α} (hfg : left_inverse f g)\n    (hcard : card α ≤ card β) : right_inverse f g :=\n  have hsurj : surjective f := surjective_iff_hasRightInverse.2 ⟨g, hfg⟩\n  rightInverse_of_injective_of_leftInverse\n    ((bijective_iff_surjective_and_card _).2 ⟨hsurj, le_antisymm hcard (card_le_of_surjective f hsurj)⟩).1 hfg\n#align function.left_inverse.right_inverse_of_card_le Function.LeftInverse.rightInverse_of_card_le\n-/\n\n",
 "one_lt_card_iff_nontrivial":
 "theorem one_lt_card_iff_nontrivial : 1 < card α ↔ Nontrivial α := by\n  classical\n    rw [← not_iff_not]\n    push_neg\n    rw [not_nontrivial_iff_subsingleton, card_le_one_iff_subsingleton]\n#align one_lt_card_iff_nontrivial one_lt_card_iff_nontrivial\n\n",
 "one_lt_card_iff":
 "theorem one_lt_card_iff : 1 < card α ↔ ∃ a b : α, a ≠ b :=\n  one_lt_card_iff_nontrivial.trans nontrivial_iff\n#align one_lt_card_iff one_lt_card_iff\n\n",
 "one_lt_card":
 "theorem one_lt_card [h : Nontrivial α] : 1 < Fintype.card α :=\n  Fintype.one_lt_card_iff_nontrivial.mpr h\n#align one_lt_card one_lt_card\n\n",
 "of_surjective_from_set":
 "/-- If `s : set α` is a proper subset of `α` and `f : s → α` is surjective, then `α` is infinite. -/\ntheorem of_surjective_from_set {s : Set α} (hs : s ≠ Set.univ) {f : s → α} (hf : surjective f) : Infinite α :=\n  of_injective_to_set hs (injective_surjInv hf)\n#align of_surjective_from_set of_surjective_from_set\n\n",
 "of_surjective":
 "theorem of_surjective {α β} [Infinite β] (f : α → β) (hf : surjective f) : Infinite α :=\n  ⟨fun I => (Finite.of_surjective f hf).false⟩\n#align of_surjective of_surjective\n\n",
 "of_not_fintype":
 "theorem of_not_fintype (h : Fintype α → False) : Infinite α :=\n  is_empty_fintype.mp ⟨h⟩\n#align of_not_fintype of_not_fintype\n\n",
 "of_injective_to_set":
 "/-- If `s : set α` is a proper subset of `α` and `f : α → s` is injective, then `α` is infinite. -/\ntheorem of_injective_to_set {s : Set α} (hs : s ≠ Set.univ) {f : α → s} (hf : injective f) : Infinite α :=\n  of_not_fintype fun h => by\n    skip\n    classical\n      refine' lt_irrefl (Fintype.card α) _\n      calc\n        Fintype.card α ≤ Fintype.card s := Fintype.card_le_of_injective f hf\n        _ = s.to_finset.card := s.to_finset_card.symm\n        _ < Fintype.card α := Finset.card_lt_card <| by rwa [Set.toFinset_ssubset_univ, Set.ssubset_univ_iff]\n        \n#align of_injective_to_set of_injective_to_set\n\n",
 "of_injective":
 "theorem of_injective {α β} [Infinite β] (f : β → α) (hf : injective f) : Infinite α :=\n  ⟨fun I => (Finite.of_injective f hf).false⟩\n#align of_injective of_injective\n\n",
 "of_equiv_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem of_equiv_card [Fintype α] (f : «expr ≃ » α β) : @card β (ofEquiv α f) = card α :=\n  Multiset.card_map _ _\n#align of_equiv_card of_equiv_card\n\n",
 "not_surjective_finite_infinite":
 "#print not_surjective_finite_infinite /-\ntheorem not_surjective_finite_infinite {α β} [Finite α] [Infinite β] (f : α → β) : ¬surjective f := fun hf =>\n  (Infinite.of_surjective f hf).not_finite ‹_›\n#align not_surjective_finite_infinite not_surjective_finite_infinite\n-/\n\n",
 "not_injective_infinite_finite":
 "#print not_injective_infinite_finite /-\ntheorem not_injective_infinite_finite {α β} [Infinite α] [Finite β] (f : α → β) : ¬injective f := fun hf =>\n  (Finite.of_injective f hf).false\n#align not_injective_infinite_finite not_injective_infinite_finite\n-/\n\n",
 "nonempty_of_card_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem nonempty_of_card_le [Fintype α] [Fintype β] (h : Fintype.card α ≤ Fintype.card β) : Nonempty («expr ↪ » α β) :=\n  by classical exact (trunc_of_card_le h).nonempty\n#align nonempty_of_card_le nonempty_of_card_le\n\n",
 "nonempty_iff_card_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem nonempty_iff_card_le [Fintype α] [Fintype β] : Nonempty («expr ↪ » α β) ↔ Fintype.card α ≤ Fintype.card β :=\n  ⟨fun ⟨e⟩ => Fintype.card_le_of_embedding e, nonempty_of_card_le⟩\n#align nonempty_iff_card_le nonempty_iff_card_le\n\n",
 "nonempty_fintype":
 "#print nonempty_fintype /-\n/-- See also `nonempty_encodable`, `nonempty_denumerable`. -/\ntheorem nonempty_fintype (α : Type _) [Finite α] : Nonempty (Fintype α) :=\n  (finite_iff_nonempty_fintype α).mp ‹_›\n#align nonempty_fintype nonempty_fintype\n-/\n\n",
 "nat_embedding_aux_injective":
 "private theorem nat_embedding_aux_injective (α : Type _) [Infinite α] : function.injective (nat_embedding_aux α) :=\n  by\n  rintro m n h\n  letI := Classical.decEq α\n  wlog hmlen : m ≤ n generalizing m n\n  · exact (this h.symm <| le_of_not_le hmlen).symm\n  by_contra hmn\n  have hmn : m < n := lt_of_le_of_ne hmlen hmn\n  refine'\n    (Classical.choose_spec\n        (exists_not_mem_finset\n          ((Multiset.range n).pmap (fun m (hm : m < n) => nat_embedding_aux α m) fun _ =>\n              Multiset.mem_range.1).to_finset))\n      _\n  refine' Multiset.mem_toFinset.2 (Multiset.mem_pmap.2 ⟨m, Multiset.mem_range.2 hmn, _⟩)\n  rw [h, nat_embedding_aux]\n#align nat_embedding_aux_injective nat_embedding_aux_injective\n\n",
 "length_le_card":
 "#print List.Nodup.length_le_card /-\ntheorem List.Nodup.length_le_card {α : Type _} [Fintype α] {l : List α} (h : l.nodup) : l.length ≤ Fintype.card α := by\n  classical exact List.toFinset_card_of_nodup h ▸ l.to_finset.card_le_univ\n#align list.nodup.length_le_card List.Nodup.length_le_card\n-/\n\n",
 "left_inverse_of_card_le":
 "#print Function.RightInverse.leftInverse_of_card_le /-\ntheorem Function.RightInverse.leftInverse_of_card_le {f : α → β} {g : β → α} (hfg : right_inverse f g)\n    (hcard : card β ≤ card α) : left_inverse f g :=\n  Function.LeftInverse.rightInverse_of_card_le hfg hcard\n#align function.right_inverse.left_inverse_of_card_le Function.RightInverse.leftInverse_of_card_le\n-/\n\n",
 "is_empty_of_card_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/-- If `‖β‖ < ‖α‖` there are no embeddings `α ↪ β`.\nThis is a formulation of the pigeonhole principle.\n\nNote this cannot be an instance as it needs `h`. -/\n@[simp]\ntheorem is_empty_of_card_lt [Fintype α] [Fintype β] (h : Fintype.card β < Fintype.card α) : IsEmpty («expr ↪ » α β) :=\n  ⟨fun f =>\n    let ⟨x, y, ne, feq⟩ := Fintype.exists_ne_map_eq_of_card_lt f h\n    ne <| f.injective feq⟩\n#align is_empty_of_card_lt is_empty_of_card_lt\n\n",
 "is_empty_fintype":
 "#print is_empty_fintype /-\n@[simp]\ntheorem is_empty_fintype {α : Type _} : IsEmpty (Fintype α) ↔ Infinite α :=\n  ⟨fun ⟨h⟩ => ⟨fun h' => (@nonempty_fintype α h').elim h⟩, fun ⟨h⟩ => ⟨fun h' => h h'.finite⟩⟩\n#align is_empty_fintype is_empty_fintype\n-/\n\n",
 "injective_iff_surjective_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem injective_iff_surjective_of_equiv {f : α → β} (e : «expr ≃ » α β) : injective f ↔ surjective f :=\n  have : injective (e.symm ∘ f) ↔ surjective (e.symm ∘ f) := injective_iff_surjective\n  ⟨fun hinj => by simpa [Function.comp] using e.surjective.comp (this.1 (e.symm.injective.comp hinj)), fun hsurj => by\n    simpa [Function.comp] using e.injective.comp (this.2 (e.symm.surjective.comp hsurj))⟩\n#align injective_iff_surjective_of_equiv injective_iff_surjective_of_equiv\n\n",
 "injective_iff_surjective":
 "theorem injective_iff_surjective {f : α → α} : injective f ↔ surjective f := by\n  haveI := classical.prop_decidable <;> cases nonempty_fintype α <;>\n    exact\n      have : ∀ {f : α → α}, injective f → surjective f := fun f hinj x =>\n        have h₁ : image f univ = univ :=\n          eq_of_subset_of_card_le (subset_univ _) ((card_image_of_injective univ hinj).symm ▸ le_rfl)\n        have h₂ : x ∈ image f univ := h₁.symm ▸ mem_univ _\n        exists_of_bex (mem_image.1 h₂)\n      ⟨this, fun hsurj =>\n        has_left_inverse.injective\n          ⟨surj_inv hsurj,\n            left_inverse_of_surjective_of_right_inverse (this (injective_surj_inv _)) (right_inverse_surj_inv _)⟩⟩\n#align injective_iff_surjective injective_iff_surjective\n\n",
 "injective_iff_bijective":
 "theorem injective_iff_bijective {f : α → α} : injective f ↔ bijective f := by simp [bijective, injective_iff_surjective]\n#align injective_iff_bijective injective_iff_bijective\n\n",
 "induction_subsingleton_or_nontrivial":
 "#print Fintype.induction_subsingleton_or_nontrivial /-\n/-- A custom induction principle for fintypes. The base case is a subsingleton type,\nand the induction step is for non-trivial types, and one can assume the hypothesis for\nsmaller types (via `fintype.card`).\n\nThe major premise is `fintype α`, so to use this with the `induction` tactic you have to give a name\nto that instance and use that name.\n-/\n@[elab_as_elim]\ntheorem Fintype.induction_subsingleton_or_nontrivial {P : ∀ (α) [Fintype α], Prop} (α : Type _) [Fintype α]\n    (hbase : ∀ (α) [Fintype α] [subsingleton α], P α)\n    (hstep :\n      ∀ (α) [Fintype α] [Nontrivial α], ∀ ih : ∀ (β) [Fintype β], ∀ h : Fintype.card β < Fintype.card α, P β, P α) :\n    P α := by\n  obtain ⟨n, hn⟩ : ∃ n, Fintype.card α = n := ⟨Fintype.card α, rfl⟩\n  induction' n using nat.strong_induction_on with n ih generalizing α\n  cases' subsingleton_or_nontrivial α with hsing hnontriv\n  · apply hbase\n  · apply hstep\n    intro β _ hlt\n    rw [hn] at hlt\n    exact ih (Fintype.card β) hlt _ rfl\n#align fintype.induction_subsingleton_or_nontrivial Fintype.induction_subsingleton_or_nontrivial\n-/\n\n",
 "finite_iff_nonempty_fintype":
 "#print finite_iff_nonempty_fintype /-\ntheorem finite_iff_nonempty_fintype (α : Type _) : Finite α ↔ Nonempty (Fintype α) :=\n  ⟨fun h =>\n    let ⟨k, ⟨e⟩⟩ := @Finite.exists_equiv_fin α h\n    ⟨Fintype.ofEquiv _ e.symm⟩,\n    fun ⟨_⟩ => inferInstance⟩\n#align finite_iff_nonempty_fintype finite_iff_nonempty_fintype\n-/\n\n",
 "finite":
 "#print Fintype.finite /-\n@[nolint fintype_finite]\nprotected theorem Fintype.finite {α : Type _} (h : Fintype α) : Finite α :=\n  ⟨Fintype.equivFin α⟩\n#align fintype.finite Fintype.finite\n-/\n\n",
 "fin_injective":
 "#print fin_injective /-\n/-- `fin` as a map from `ℕ` to `Type` is injective. Note that since this is a statement about\nequality of types, using it should be avoided if possible. -/\ntheorem fin_injective : function.injective Fin := fun m n h =>\n  (Fintype.card_fin m).symm.trans <| (Fintype.card_congr <| Equiv.cast h).trans (Fintype.card_fin n)\n#align fin_injective fin_injective\n-/\n\n",
 "false":
 "#print Fintype.false /-\n@[nolint fintype_finite]\nprotected theorem Fintype.false [Infinite α] (h : Fintype α) : False :=\n  not_finite α\n#align fintype.false Fintype.false\n-/\n\n",
 "exists_univ_list":
 "#print Finite.exists_univ_list /-\ntheorem Finite.exists_univ_list (α) [Finite α] : ∃ l : List α, l.nodup ∧ ∀ x : α, x ∈ l :=\n  by\n  cases nonempty_fintype α\n  obtain ⟨l, e⟩ := quotient.exists_rep (@univ α _).1\n  have := and.intro univ.2 mem_univ_val\n  exact ⟨_, by rwa [← e] at this⟩\n#align finite.exists_univ_list Finite.exists_univ_list\n-/\n\n",
 "exists_superset_card_eq":
 "/-- See `infinite.exists_subset_card_eq` for a version that provides an arbitrary\n`s : finset α` for any cardinality. -/\ntheorem exists_superset_card_eq [Infinite α] (s : Finset α) (n : ℕ) (hn : s.card ≤ n) :\n    ∃ t : Finset α, s ⊆ t ∧ t.card = n :=\n  by\n  induction' n with n IH generalizing s\n  · exact ⟨s, subset_refl _, nat.eq_zero_of_le_zero hn⟩\n  · cases' hn.eq_or_lt with hn' hn'\n    · exact ⟨s, subset_refl _, hn'⟩\n    obtain ⟨t, hs, ht⟩ := IH _ (nat.le_of_lt_succ hn')\n    obtain ⟨x, hx⟩ := exists_not_mem_finset t\n    refine' ⟨Finset.cons x t hx, hs.trans (Finset.subset_cons _), _⟩\n    simp [hx, ht]\n#align exists_superset_card_eq exists_superset_card_eq\n\n",
 "exists_subset_card_eq":
 "/-- See `infinite.exists_superset_card_eq` for a version that, for a `s : finset α`,\nprovides a superset `t : finset α`, `s ⊆ t` such that `t.card` is fixed. -/\ntheorem exists_subset_card_eq (α : Type _) [Infinite α] (n : ℕ) : ∃ s : Finset α, s.card = n :=\n  ⟨(range n).map (natEmbedding α), by rw [card_map, card_range]⟩\n#align exists_subset_card_eq exists_subset_card_eq\n\n",
 "exists_pair_of_one_lt_card":
 "theorem exists_pair_of_one_lt_card (h : 1 < card α) : ∃ a b : α, a ≠ b :=\n  haveI : Nontrivial α := one_lt_card_iff_nontrivial.1 h\n  exists_pair_ne α\n#align exists_pair_of_one_lt_card exists_pair_of_one_lt_card\n\n",
 "exists_of_card_le_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem exists_of_card_le_finset [Fintype α] {s : Finset β} (h : Fintype.card α ≤ s.card) :\n    ∃ f : «expr ↪ » α β, Set.range f ⊆ s := by\n  rw [← Fintype.card_coe] at h\n  rcases nonempty_of_card_le h with ⟨f⟩\n  exact ⟨f.trans (embedding.subtype _), by simp [Set.range_subset_iff]⟩\n#align exists_of_card_le_finset exists_of_card_le_finset\n\n",
 "exists_not_mem_finset":
 "theorem exists_not_mem_finset [Infinite α] (s : Finset α) : ∃ x, x ∉ s :=\n  not_forall.1 fun h => Fintype.false ⟨s, h⟩\n#align exists_not_mem_finset exists_not_mem_finset\n\n",
 "exists_ne_of_one_lt_card":
 "theorem exists_ne_of_one_lt_card (h : 1 < card α) (a : α) : ∃ b : α, b ≠ a :=\n  haveI : Nontrivial α := one_lt_card_iff_nontrivial.1 h\n  exists_ne a\n#align exists_ne_of_one_lt_card exists_ne_of_one_lt_card\n\n",
 "exists_ne_map_eq_of_infinite":
 "#print Finite.exists_ne_map_eq_of_infinite /-\n/-- The pigeonhole principle for infinitely many pigeons in finitely many pigeonholes. If there are\ninfinitely many pigeons in finitely many pigeonholes, then there are at least two pigeons in the\nsame pigeonhole.\n\nSee also: `fintype.exists_ne_map_eq_of_card_lt`, `finite.exists_infinite_fiber`.\n-/\ntheorem Finite.exists_ne_map_eq_of_infinite {α β} [Infinite α] [Finite β] (f : α → β) : ∃ x y : α, x ≠ y ∧ f x = f y :=\n  by simpa only [injective, not_forall, not_imp, and_comm] using not_injective_infinite_finite f\n#align finite.exists_ne_map_eq_of_infinite Finite.exists_ne_map_eq_of_infinite\n-/\n\n",
 "exists_ne_map_eq_of_card_lt":
 "/-- The pigeonhole principle for finitely many pigeons and pigeonholes.\nThis is the `fintype` version of `finset.exists_ne_map_eq_of_card_lt_of_maps_to`.\n-/\ntheorem exists_ne_map_eq_of_card_lt (f : α → β) (h : Fintype.card β < Fintype.card α) : ∃ x y, x ≠ y ∧ f x = f y :=\n  let ⟨x, _, y, _, h⟩ := Finset.exists_ne_map_eq_of_card_lt_of_maps_to h fun x _ => mem_univ (f x)\n  ⟨x, y, h⟩\n#align exists_ne_map_eq_of_card_lt exists_ne_map_eq_of_card_lt\n\n",
 "exists_minimal":
 "#print Finset.exists_minimal /-\ntheorem Finset.exists_minimal {α : Type _} [preorder α] (s : Finset α) (h : s.nonempty) : ∃ m ∈ s, ∀ x ∈ s, ¬x < m :=\n  by\n  obtain ⟨c, hcs : c ∈ s⟩ := h\n  have : well_founded (@LT.lt { x // x ∈ s } _) := Finite.wellFounded_of_trans_of_irrefl _\n  obtain ⟨⟨m, hms : m ∈ s⟩, -, H⟩ := this.has_min Set.univ ⟨⟨c, hcs⟩, trivial⟩\n  exact ⟨m, hms, fun x hx hxm => H ⟨x, hx⟩ trivial hxm⟩\n#align finset.exists_minimal Finset.exists_minimal\n-/\n\n",
 "exists_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print Finset.exists_maximal /-\ntheorem Finset.exists_maximal {α : Type _} [preorder α] (s : Finset α) (h : s.nonempty) : ∃ m ∈ s, ∀ x ∈ s, ¬m < x :=\n  @Finset.exists_minimal («expr ᵒᵈ» α) _ s h\n#align finset.exists_maximal Finset.exists_maximal\n-/\n\n",
 "exists_infinite_fiber":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Finite.exists_infinite_fiber /-\n/-- The strong pigeonhole principle for infinitely many pigeons in\nfinitely many pigeonholes.  If there are infinitely many pigeons in\nfinitely many pigeonholes, then there is a pigeonhole with infinitely\nmany pigeons.\n\nSee also: `finite.exists_ne_map_eq_of_infinite`\n-/\ntheorem Finite.exists_infinite_fiber [Infinite α] [Finite β] (f : α → β) : ∃ y : β, Infinite («expr ⁻¹' » f {y}) := by\n  classical\n    by_contra' hf\n    cases nonempty_fintype β\n    haveI := fun y => fintypeOfNotInfinite <| hf y\n    let key : Fintype α :=\n      { elems := univ.bUnion fun y : β => («expr ⁻¹' » f {y}).to_finset\n        complete := by simp }\n    exact key.false\n#align finite.exists_infinite_fiber Finite.exists_infinite_fiber\n-/\n\n",
 "equiv_of_fintype_self_embedding_to_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n@[simp]\ntheorem equiv_of_fintype_self_embedding_to_embedding [Finite α] (e : «expr ↪ » α α) :\n    e.equiv_of_fintype_self_embedding.to_embedding = e := by\n  ext\n  rfl\n#align equiv_of_fintype_self_embedding_to_embedding equiv_of_fintype_self_embedding_to_embedding\n\n",
 "equiv_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Fin.equiv_iff_eq /-\ntheorem Fin.equiv_iff_eq {m n : ℕ} : Nonempty («expr ≃ » (Fin m) (Fin n)) ↔ m = n :=\n  ⟨fun ⟨h⟩ => by simpa using Fintype.card_congr h, fun h => ⟨Equiv.cast <| h ▸ rfl⟩⟩\n#align fin.equiv_iff_eq Fin.equiv_iff_eq\n-/\n\n",
 "eq_univ_of_card":
 "#print Finset.eq_univ_of_card /-\ntheorem Finset.eq_univ_of_card [Fintype α] (s : Finset α) (hs : s.card = Fintype.card α) : s = univ :=\n  eq_of_subset_of_card_le (subset_univ _) <| by rw [hs, Finset.card_univ]\n#align finset.eq_univ_of_card Finset.eq_univ_of_card\n-/\n\n",
 "cast_eq_cast'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print Fin.cast_eq_cast' /-\n/-- A reversed version of `fin.cast_eq_cast` that is easier to rewrite with. -/\ntheorem Fin.cast_eq_cast' {n m : ℕ} (h : Fin n = Fin m) : cast h = «expr⇑ » (Fin.cast <| fin_injective h) :=\n  (Fin.cast_eq_cast _).symm\n#align fin.cast_eq_cast' Fin.cast_eq_cast'\n-/\n\n",
 "card_univ_pos":
 "private theorem card_univ_pos (α : Type _) [Fintype α] [Nonempty α] : 0 < (Finset.univ : Finset α).card :=\n  Finset.univ_nonempty.card_pos\n#align card_univ_pos card_univ_pos\n\n",
 "card_univ_diff":
 "#print Finset.card_univ_diff /-\ntheorem Finset.card_univ_diff [DecidableEq α] [Fintype α] (s : Finset α) :\n    (Finset.univ \\ s).card = Fintype.card α - s.card :=\n  Finset.card_sdiff (subset_univ s)\n#align finset.card_univ_diff Finset.card_univ_diff\n-/\n\n",
 "card_univ":
 "#print Finset.card_univ /-\ntheorem Finset.card_univ [Fintype α] : (Finset.univ : Finset α).card = Fintype.card α :=\n  rfl\n#align finset.card_univ Finset.card_univ\n-/\n\n",
 "card_unit":
 "#print Fintype.card_unit /-\ntheorem Fintype.card_unit : Fintype.card Unit = 1 :=\n  rfl\n#align fintype.card_unit Fintype.card_unit\n-/\n\n",
 "card_unique":
 "@[simp]\ntheorem card_unique [Unique α] [h : Fintype α] : Fintype.card α = 1 :=\n  subsingleton.elim (ofSubsingleton default) h ▸ card_ofSubsingleton _\n#align card_unique card_unique\n\n",
 "card_ulift":
 "#print Fintype.card_ulift /-\n@[simp]\ntheorem Fintype.card_ulift (α : Type _) [Fintype α] : Fintype.card (ULift α) = Fintype.card α :=\n  Fintype.ofEquiv_card _\n#align fintype.card_ulift Fintype.card_ulift\n-/\n\n",
 "card_subtype_mono":
 "#print Fintype.card_subtype_mono /-\ntheorem Fintype.card_subtype_mono (p q : α → Prop) (h : p ≤ q) [Fintype { x // p x }] [Fintype { x // q x }] :\n    Fintype.card { x // p x } ≤ Fintype.card { x // q x } :=\n  Fintype.card_le_of_embedding (Subtype.impEmbedding _ _ h)\n#align fintype.card_subtype_mono Fintype.card_subtype_mono\n-/\n\n",
 "card_subtype_lt":
 "#print Fintype.card_subtype_lt /-\ntheorem Fintype.card_subtype_lt [Fintype α] {p : α → Prop} [DecidablePred p] {x : α} (hx : ¬p x) :\n    Fintype.card { x // p x } < Fintype.card α :=\n  Fintype.card_lt_of_injective_of_not_mem coe Subtype.coe_injective <| by rwa [Subtype.range_coe_subtype]\n#align fintype.card_subtype_lt Fintype.card_subtype_lt\n-/\n\n",
 "card_subtype_le":
 "#print Fintype.card_subtype_le /-\ntheorem Fintype.card_subtype_le [Fintype α] (p : α → Prop) [DecidablePred p] :\n    Fintype.card { x // p x } ≤ Fintype.card α :=\n  Fintype.card_le_of_embedding (Function.Embedding.subtype _)\n#align fintype.card_subtype_le Fintype.card_subtype_le\n-/\n\n",
 "card_subtype_eq'":
 "#print Fintype.card_subtype_eq' /-\n@[simp]\ntheorem Fintype.card_subtype_eq' (y : α) [Fintype { x // y = x }] : Fintype.card { x // y = x } = 1 :=\n  Fintype.card_unique\n#align fintype.card_subtype_eq' Fintype.card_subtype_eq'\n-/\n\n",
 "card_subtype_eq":
 "#print Fintype.card_subtype_eq /-\n@[simp]\ntheorem Fintype.card_subtype_eq (y : α) [Fintype { x // x = y }] : Fintype.card { x // x = y } = 1 :=\n  Fintype.card_unique\n#align fintype.card_subtype_eq Fintype.card_subtype_eq\n-/\n\n",
 "card_subtype_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Fintype.card_subtype_compl /-\n@[simp]\ntheorem Fintype.card_subtype_compl [Fintype α] (p : α → Prop) [Fintype { x // p x }] [Fintype { x // ¬p x }] :\n    Fintype.card { x // ¬p x } = Fintype.card α - Fintype.card { x // p x } := by\n  classical rw [Fintype.card_of_subtype (Set.toFinset («expr ᶜ» p)), Set.toFinset_compl p, Finset.card_compl,\n            Fintype.card_of_subtype (Set.toFinset p)] <;>\n          intro <;>\n        simp only [Set.mem_toFinset, Set.mem_compl_iff] <;>\n      rfl\n#align fintype.card_subtype_compl Fintype.card_subtype_compl\n-/\n\n",
 "card_subtype":
 "#print Fintype.card_subtype /-\ntheorem Fintype.card_subtype [Fintype α] (p : α → Prop) [DecidablePred p] :\n    Fintype.card { x // p x } = ((Finset.univ : Finset α).filter p).card :=\n  by\n  refine' Fintype.card_of_subtype _ _\n  simp\n#align fintype.card_subtype Fintype.card_subtype\n-/\n\n",
 "card_range_le":
 "theorem card_range_le {α β : Type _} (f : α → β) [Fintype α] [Fintype (Set.range f)] :\n    Fintype.card (Set.range f) ≤ Fintype.card α :=\n  Fintype.card_le_of_surjective (fun a => ⟨f a, by simp⟩) fun ⟨_, a, ha⟩ => ⟨a, by simpa using ha⟩\n#align card_range_le card_range_le\n\n",
 "card_range":
 "theorem card_range {α β F : Type _} [EmbeddingLike F α β] (f : F) [Fintype α] [Fintype (Set.range f)] :\n    Fintype.card (Set.range f) = Fintype.card α :=\n  Eq.symm <| Fintype.card_congr <| Equiv.ofInjective _ <| EmbeddingLike.injective f\n#align card_range card_range\n\n",
 "card_quotient_lt":
 "#print Fintype.card_quotient_lt /-\ntheorem Fintype.card_quotient_lt [Fintype α] {s : setoid α} [DecidableRel ((· ≈ ·) : α → α → Prop)] {x y : α}\n    (h1 : x ≠ y) (h2 : x ≈ y) : Fintype.card (quotient s) < Fintype.card α :=\n  Fintype.card_lt_of_surjective_not_injective _ (surjective_quotient_mk _) fun w => h1 (w <| Quotient.eq'.mpr h2)\n#align fintype.card_quotient_lt Fintype.card_quotient_lt\n-/\n\n",
 "card_quotient_le":
 "#print Fintype.card_quotient_le /-\ntheorem Fintype.card_quotient_le [Fintype α] (s : setoid α) [DecidableRel ((· ≈ ·) : α → α → Prop)] :\n    Fintype.card (quotient s) ≤ Fintype.card α :=\n  Fintype.card_le_of_surjective _ (surjective_quotient_mk _)\n#align fintype.card_quotient_le Fintype.card_quotient_le\n-/\n\n",
 "card_punit":
 "#print Fintype.card_punit /-\n@[simp]\ntheorem Fintype.card_punit : Fintype.card PUnit = 1 :=\n  rfl\n#align fintype.card_punit Fintype.card_punit\n-/\n\n",
 "card_pos_iff":
 "theorem card_pos_iff : 0 < card α ↔ Nonempty α :=\n  pos_iff_ne_zero.trans <| not_iff_comm.mp <| not_nonempty_iff.trans card_eq_zero_iff.symm\n#align card_pos_iff card_pos_iff\n\n",
 "card_pos":
 "theorem card_pos [h : Nonempty α] : 0 < card α :=\n  card_pos_iff.mpr h\n#align card_pos card_pos\n\n",
 "card_plift":
 "#print Fintype.card_plift /-\n@[simp]\ntheorem Fintype.card_plift (α : Type _) [Fintype α] : Fintype.card (PLift α) = Fintype.card α :=\n  Fintype.ofEquiv_card _\n#align fintype.card_plift Fintype.card_plift\n-/\n\n",
 "card_pempty":
 "#print Fintype.card_pempty /-\n@[simp]\ntheorem Fintype.card_pempty : Fintype.card PEmpty = 0 :=\n  rfl\n#align fintype.card_pempty Fintype.card_pempty\n-/\n\n",
 "card_orderDual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print Fintype.card_orderDual /-\n@[simp]\ntheorem Fintype.card_orderDual (α : Type _) [Fintype α] : Fintype.card («expr ᵒᵈ» α) = Fintype.card α :=\n  rfl\n#align fintype.card_order_dual Fintype.card_orderDual\n-/\n\n",
 "card_of_subtype":
 "theorem card_of_subtype {p : α → Prop} (s : Finset α) (H : ∀ x : α, x ∈ s ↔ p x) [Fintype { x // p x }] :\n    card { x // p x } = s.card := by\n  rw [← subtype_card s H]\n  congr\n#align card_of_subtype card_of_subtype\n\n",
 "card_of_subsingleton":
 "/-- Note: this lemma is specifically about `fintype.of_subsingleton`. For a statement about\narbitrary `fintype` instances, use either `fintype.card_le_one_iff_subsingleton` or\n`fintype.card_unique`. -/\n@[simp]\ntheorem card_of_subsingleton (a : α) [subsingleton α] : @Fintype.card _ (ofSubsingleton a) = 1 :=\n  rfl\n#align card_of_subsingleton card_of_subsingleton\n\n",
 "card_of_is_empty":
 "/-- Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about\narbitrary `fintype` instances, use `fintype.card_eq_zero_iff`. -/\n@[simp]\ntheorem card_of_is_empty [IsEmpty α] : Fintype.card α = 0 :=\n  rfl\n#align card_of_is_empty card_of_is_empty\n\n",
 "card_of_finset'":
 "theorem card_of_finset' {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) [Fintype p] : Fintype.card p = s.card := by\n  rw [← card_of_finset s H] <;> congr\n#align card_of_finset' card_of_finset'\n\n",
 "card_of_finset":
 "@[simp]\ntheorem card_of_finset {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) : @Fintype.card p (ofFinset s H) = s.card :=\n  Fintype.subtype_card s H\n#align card_of_finset card_of_finset\n\n",
 "card_of_bijective":
 "theorem card_of_bijective {f : α → β} (hf : bijective f) : card α = card β :=\n  card_congr (Equiv.ofBijective f hf)\n#align card_of_bijective card_of_bijective\n\n",
 "card_ne_zero":
 "theorem card_ne_zero [Nonempty α] : card α ≠ 0 :=\n  ne_of_gt card_pos\n#align card_ne_zero card_ne_zero\n\n",
 "card_lt_univ_of_not_mem":
 "#print Finset.card_lt_univ_of_not_mem /-\ntheorem Finset.card_lt_univ_of_not_mem [Fintype α] {s : Finset α} {x : α} (hx : x ∉ s) : s.card < Fintype.card α :=\n  card_lt_card ⟨subset_univ s, not_forall.2 ⟨x, fun hx' => hx (hx' <| mem_univ x)⟩⟩\n#align finset.card_lt_univ_of_not_mem Finset.card_lt_univ_of_not_mem\n-/\n\n",
 "card_lt_of_surjective_not_injective":
 "theorem card_lt_of_surjective_not_injective [Fintype α] [Fintype β] (f : α → β) (h : function.surjective f)\n    (h' : ¬function.injective f) : card β < card α :=\n  card_lt_of_injective_not_surjective _ (Function.injective_surjInv h) fun hg =>\n    have w : function.bijective (Function.surjInv h) := ⟨Function.injective_surjInv h, hg⟩\n    h' <| h.injective_of_fintype (Equiv.ofBijective _ w).symm\n#align card_lt_of_surjective_not_injective card_lt_of_surjective_not_injective\n\n",
 "card_lt_of_injective_of_not_mem":
 "theorem card_lt_of_injective_of_not_mem (f : α → β) (h : function.injective f) {b : β} (w : b ∉ Set.range f) :\n    card α < card β :=\n  calc\n    card α = (univ.map ⟨f, h⟩).card := (card_map _).symm\n    _ < card β := Finset.card_lt_univ_of_not_mem <| by rwa [← mem_coe, coe_map, coe_univ, Set.image_univ]\n    \n#align card_lt_of_injective_of_not_mem card_lt_of_injective_of_not_mem\n\n",
 "card_lt_of_injective_not_surjective":
 "theorem card_lt_of_injective_not_surjective (f : α → β) (h : function.injective f) (h' : ¬function.surjective f) :\n    card α < card β :=\n  let ⟨y, hy⟩ := not_forall.1 h'\n  card_lt_of_injective_of_not_mem f h hy\n#align card_lt_of_injective_not_surjective card_lt_of_injective_not_surjective\n\n",
 "card_lt_iff_ne_univ":
 "#print Finset.card_lt_iff_ne_univ /-\ntheorem Finset.card_lt_iff_ne_univ [Fintype α] (s : Finset α) : s.card < Fintype.card α ↔ s ≠ Finset.univ :=\n  s.card_le_univ.lt_iff_ne.trans (not_congr s.card_eq_iff_eq_univ)\n#align finset.card_lt_iff_ne_univ Finset.card_lt_iff_ne_univ\n-/\n\n",
 "card_lex":
 "#print Fintype.card_lex /-\n@[simp]\ntheorem Fintype.card_lex (α : Type _) [Fintype α] : Fintype.card (Lex α) = Fintype.card α :=\n  rfl\n#align fintype.card_lex Fintype.card_lex\n-/\n\n",
 "card_le_univ":
 "#print Finset.card_le_univ /-\ntheorem Finset.card_le_univ [Fintype α] (s : Finset α) : s.card ≤ Fintype.card α :=\n  card_le_of_subset (subset_univ s)\n#align finset.card_le_univ Finset.card_le_univ\n-/\n\n",
 "card_le_one_iff_subsingleton":
 "theorem card_le_one_iff_subsingleton : card α ≤ 1 ↔ subsingleton α :=\n  card_le_one_iff.trans subsingleton_iff.symm\n#align card_le_one_iff_subsingleton card_le_one_iff_subsingleton\n\n",
 "card_le_one_iff":
 "theorem card_le_one_iff : card α ≤ 1 ↔ ∀ a b : α, a = b :=\n  let n := card α\n  have hn : n = card α := rfl\n  match n, hn with\n  | 0 => fun ha => ⟨fun h => fun a => (card_eq_zero_iff.1 ha.symm).elim a, fun _ => ha ▸ nat.le_succ _⟩\n  | 1 => fun ha =>\n    ⟨fun h => fun a b => by\n      let ⟨x, hx⟩ := card_eq_one_iff.1 ha.symm\n      rw [hx a, hx b], fun _ => ha ▸ le_rfl⟩\n  | n + 2 => fun ha =>\n    ⟨fun h => by rw [← ha] at h <;> exact absurd h (by decide), fun h =>\n      card_unit ▸ card_le_of_injective (fun _ => ()) fun _ _ _ => h _ _⟩\n#align card_le_one_iff card_le_one_iff\n\n",
 "card_le_of_surjective":
 "#print card_le_of_surjective /-\ntheorem card_le_of_surjective (f : α → β) (h : function.surjective f) : card β ≤ card α :=\n  card_le_of_injective _ (Function.injective_surjInv h)\n#align card_le_of_surjective card_le_of_surjective\n-/\n\n",
 "card_le_of_injective":
 "#print card_le_of_injective /-\ntheorem card_le_of_injective (f : α → β) (hf : function.injective f) : card α ≤ card β :=\n  Finset.card_le_card_of_inj_on f (fun _ _ => Finset.mem_univ _) fun _ _ _ _ h => hf h\n#align card_le_of_injective card_le_of_injective\n-/\n\n",
 "card_le_of_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem card_le_of_embedding (f : «expr ↪ » α β) : card α ≤ card β :=\n  card_le_of_injective f f.2\n#align card_le_of_embedding card_le_of_embedding\n\n",
 "card_finset_fin_le":
 "#print card_finset_fin_le /-\ntheorem card_finset_fin_le {n : ℕ} (s : Finset (Fin n)) : s.card ≤ n := by\n  simpa only [Fintype.card_fin] using s.card_le_univ\n#align card_finset_fin_le card_finset_fin_le\n-/\n\n",
 "card_fin":
 "#print Finset.card_fin /-\n@[simp]\ntheorem Finset.card_fin (n : ℕ) : Finset.card (Finset.univ : Finset (Fin n)) = n := by\n  rw [Finset.card_univ, Fintype.card_fin]\n#align finset.card_fin Finset.card_fin\n-/\n\n",
 "card_eq_zero_iff":
 "theorem card_eq_zero_iff : card α = 0 ↔ IsEmpty α := by rw [card, Finset.card_eq_zero, univ_eq_empty_iff]\n#align card_eq_zero_iff card_eq_zero_iff\n\n",
 "card_eq_zero":
 "theorem card_eq_zero [IsEmpty α] : card α = 0 :=\n  card_eq_zero_iff.2 ‹_›\n#align card_eq_zero card_eq_zero\n\n",
 "card_eq_one_of_forall_eq":
 "theorem card_eq_one_of_forall_eq {i : α} (h : ∀ j, j = i) : card α = 1 :=\n  Fintype.card_eq_one_iff.2 ⟨i, h⟩\n#align card_eq_one_of_forall_eq card_eq_one_of_forall_eq\n\n",
 "card_eq_one_iff_nonempty_unique":
 "theorem card_eq_one_iff_nonempty_unique : card α = 1 ↔ Nonempty (Unique α) :=\n  ⟨fun h =>\n    let ⟨d, h⟩ := Fintype.card_eq_one_iff.mp h\n    ⟨{  default := d\n        uniq := h }⟩,\n    fun ⟨h⟩ => Fintype.card_unique⟩\n#align card_eq_one_iff_nonempty_unique card_eq_one_iff_nonempty_unique\n\n",
 "card_eq_one_iff":
 "theorem card_eq_one_iff : card α = 1 ↔ ∃ x : α, ∀ y, y = x := by\n  rw [← card_unit, card_eq] <;>\n    exact\n      ⟨fun ⟨a⟩ => ⟨a.symm (), fun y => a.injective (subsingleton.elim _ _)⟩, fun ⟨x, hx⟩ =>\n        ⟨⟨fun _ => (), fun _ => x, fun _ => (hx _).trans (hx _).symm, fun _ => subsingleton.elim _ _⟩⟩⟩\n#align card_eq_one_iff card_eq_one_iff\n\n",
 "card_eq_iff_eq_univ":
 "#print Finset.card_eq_iff_eq_univ /-\ntheorem Finset.card_eq_iff_eq_univ [Fintype α] (s : Finset α) : s.card = Fintype.card α ↔ s = Finset.univ :=\n  ⟨s.eq_univ_of_card, by\n    rintro rfl\n    exact Finset.card_univ⟩\n#align finset.card_eq_iff_eq_univ Finset.card_eq_iff_eq_univ\n-/\n\n",
 "card_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem card_eq {α β} [F : Fintype α] [G : Fintype β] : card α = card β ↔ Nonempty («expr ≃ » α β) :=\n  ⟨fun h =>\n    haveI := classical.prop_decidable\n    (trunc_equiv_of_card_eq h).nonempty,\n    fun ⟨f⟩ => card_congr f⟩\n#align card_eq card_eq\n\n",
 "card_empty":
 "#print Fintype.card_empty /-\n@[simp]\ntheorem Fintype.card_empty : Fintype.card Empty = 0 :=\n  rfl\n#align fintype.card_empty Fintype.card_empty\n-/\n\n",
 "card_congr'":
 "@[congr]\ntheorem card_congr' {α β} [Fintype α] [Fintype β] (h : α = β) : card α = card β :=\n  card_congr (by rw [h])\n#align card_congr' card_congr'\n\n",
 "card_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem card_congr {α β} [Fintype α] [Fintype β] (f : «expr ≃ » α β) : card α = card β := by\n  rw [← of_equiv_card f] <;> congr\n#align card_congr card_congr\n\n",
 "card_compl_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Fintype.card_compl_set /-\ntheorem Fintype.card_compl_set [Fintype α] (s : Set α) [Fintype s] [Fintype («expr↥ » («expr ᶜ» s))] :\n    Fintype.card («expr↥ » («expr ᶜ» s)) = Fintype.card α - Fintype.card s := by\n  classical rw [← Set.toFinset_card, ← Set.toFinset_card, ← Finset.card_compl, Set.toFinset_compl]\n#align fintype.card_compl_set Fintype.card_compl_set\n-/\n\n",
 "card_compl_lt_iff_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Finset.card_compl_lt_iff_nonempty /-\ntheorem Finset.card_compl_lt_iff_nonempty [Fintype α] [DecidableEq α] (s : Finset α) :\n    («expr ᶜ» s).card < Fintype.card α ↔ s.nonempty :=\n  («expr ᶜ» s).card_lt_iff_ne_univ.trans s.compl_ne_univ_iff_nonempty\n#align finset.card_compl_lt_iff_nonempty Finset.card_compl_lt_iff_nonempty\n-/\n\n",
 "card_compl_eq_card_compl":
 "#print Fintype.card_compl_eq_card_compl /-\n/-- If two subtypes of a fintype have equal cardinality, so do their complements. -/\ntheorem Fintype.card_compl_eq_card_compl [Finite α] (p q : α → Prop) [Fintype { x // p x }] [Fintype { x // ¬p x }]\n    [Fintype { x // q x }] [Fintype { x // ¬q x }] (h : Fintype.card { x // p x } = Fintype.card { x // q x }) :\n    Fintype.card { x // ¬p x } = Fintype.card { x // ¬q x } :=\n  by\n  cases nonempty_fintype α\n  simp only [Fintype.card_subtype_compl, h]\n#align fintype.card_compl_eq_card_compl Fintype.card_compl_eq_card_compl\n-/\n\n",
 "card_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n#print Finset.card_compl /-\ntheorem Finset.card_compl [DecidableEq α] [Fintype α] (s : Finset α) : («expr ᶜ» s).card = Fintype.card α - s.card :=\n  Finset.card_univ_diff s\n#align finset.card_compl Finset.card_compl\n-/\n\n",
 "card_coe":
 "#print Fintype.card_coe /-\n@[simp]\ntheorem Fintype.card_coe (s : Finset α) [Fintype s] : Fintype.card s = s.card :=\n  Fintype.card_of_finset' s fun _ => iff.rfl\n#align fintype.card_coe Fintype.card_coe\n-/\n\n",
 "card_bool":
 "#print Fintype.card_bool /-\n@[simp]\ntheorem Fintype.card_bool : Fintype.card Bool = 2 :=\n  rfl\n#align fintype.card_bool Fintype.card_bool\n-/\n\n",
 "card_Prop":
 "#print Fintype.card_Prop /-\n@[simp]\ntheorem Fintype.card_Prop : Fintype.card Prop = 2 :=\n  rfl\n#align fintype.card_Prop Fintype.card_Prop\n-/\n\n",
 "bijective_iff_surjective_and_card":
 "theorem bijective_iff_surjective_and_card (f : α → β) : bijective f ↔ surjective f ∧ card α = card β :=\n  ⟨fun h => ⟨h.2, card_of_bijective h⟩, fun h => ⟨h.1.injective_of_fintype <| equivOfCardEq h.2, h.1⟩⟩\n#align bijective_iff_surjective_and_card bijective_iff_surjective_and_card\n\n",
 "bijective_iff_injective_and_card":
 "theorem bijective_iff_injective_and_card (f : α → β) : bijective f ↔ injective f ∧ card α = card β :=\n  ⟨fun h => ⟨h.1, card_of_bijective h⟩, fun h => ⟨h.1, h.1.surjective_of_fintype <| equivOfCardEq h.2⟩⟩\n#align bijective_iff_injective_and_card bijective_iff_injective_and_card\n\n",
 "Nonempty":
 "#print Nonempty /-\n-- see Note [lower instance priority]\nprotected theorem Nonempty (α : Type _) [Infinite α] : Nonempty α := by infer_instance\n#align nonempty Nonempty\n-/\n\n"}