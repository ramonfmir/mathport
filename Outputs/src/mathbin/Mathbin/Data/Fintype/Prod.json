{"univ_product_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print Finset.univ_product_univ /-\n@[simp]\ntheorem Finset.univ_product_univ {α β : Type _} [Fintype α] [Fintype β] :\n    finset.product (univ : Finset α) (univ : Finset β) = univ :=\n  rfl\n#align finset.univ_product_univ Finset.univ_product_univ\n-/\n\n",
 "to_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem to_finset_prod (s : Set α) (t : Set β) [Fintype s] [Fintype t] [Fintype (finset.product s t)] :\n    (finset.product s t).to_finset = finset.product s.to_finset t.to_finset :=\n  by\n  ext\n  simp\n#align to_finset_prod to_finset_prod\n\n",
 "to_finset_off_diag":
 "theorem to_finset_off_diag {s : Set α} [DecidableEq α] [Fintype s] [Fintype s.off_diag] :\n    s.off_diag.to_finset = s.to_finset.off_diag :=\n  Finset.ext <| by simp\n#align to_finset_off_diag to_finset_off_diag\n\n",
 "infinite_prod":
 "#print infinite_prod /-\n@[simp]\ntheorem infinite_prod : Infinite (α × β) ↔ Infinite α ∧ Nonempty β ∨ Nonempty α ∧ Infinite β :=\n  by\n  refine'\n    ⟨fun H => _, fun H => H.elim (and_imp.2 <| @Prod.infinite_of_left α β) (and_imp.2 <| @Prod.infinite_of_right α β)⟩\n  rw [and_comm]; contrapose! H; intro H'\n  rcases Infinite.nonempty (α × β) with ⟨a, b⟩\n  haveI := fintypeOfNotInfinite (H.1 ⟨b⟩); haveI := fintypeOfNotInfinite (H.2 ⟨a⟩)\n  exact H'.false\n#align infinite_prod infinite_prod\n-/\n\n",
 "infinite_of_exists_right":
 "#print Pi.infinite_of_exists_right /-\n/-- If at least one `π i` is infinite and the rest nonempty, the pi type of all `π` is infinite. -/\ntheorem Pi.infinite_of_exists_right {ι : Type _} {π : ι → Type _} (i : ι) [Infinite <| π i] [∀ i, Nonempty <| π i] :\n    Infinite (∀ i : ι, π i) :=\n  let ⟨m⟩ := @pi.nonempty ι π _\n  Infinite.of_injective _ (update_injective m i)\n#align pi.infinite_of_exists_right Pi.infinite_of_exists_right\n-/\n\n",
 "card_prod":
 "#print Fintype.card_prod /-\n@[simp]\ntheorem Fintype.card_prod (α β : Type _) [Fintype α] [Fintype β] :\n    Fintype.card (α × β) = Fintype.card α * Fintype.card β :=\n  card_product _ _\n#align fintype.card_prod Fintype.card_prod\n-/\n\n"}