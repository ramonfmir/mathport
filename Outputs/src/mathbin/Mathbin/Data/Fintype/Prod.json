{"univ_product_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem finset.univ_product_univ {α β : Type _} [fintype α] [fintype β] :\n    finset.product (univ : Finset α) (univ : Finset β) = univ :=\n  rfl\n#align finset.univ_product_univ finset.univ_product_univ\n\n",
 "to_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\ntheorem to_finset_prod (s : set α) (t : set β) [fintype s] [fintype t] [fintype (finset.product s t)] :\n    (finset.product s t).to_finset = finset.product s.to_finset t.to_finset :=\n  by\n  ext\n  simp\n#align to_finset_prod to_finset_prod\n\n",
 "to_finset_off_diag":
 "theorem to_finset_off_diag {s : set α} [decidable_eq α] [fintype s] [fintype s.off_diag] :\n    s.off_diag.to_finset = s.to_finset.off_diag :=\n  Finset.ext <| by simp\n#align to_finset_off_diag to_finset_off_diag\n\n",
 "infinite_prod":
 "@[simp]\ntheorem infinite_prod : Infinite (α × β) ↔ Infinite α ∧ nonempty β ∨ nonempty α ∧ Infinite β :=\n  by\n  refine'\n    ⟨fun H => _, fun H => H.elim (and_imp.2 <| @prod.infinite_of_left α β) (and_imp.2 <| @prod.infinite_of_right α β)⟩\n  rw [and_comm]; contrapose! H; intro H'\n  rcases infinite.nonempty (α × β) with ⟨a, b⟩\n  haveI := fintype_of_not_infinite (H.1 ⟨b⟩); haveI := fintype_of_not_infinite (H.2 ⟨a⟩)\n  exact H'.false\n#align infinite_prod infinite_prod\n\n",
 "infinite_of_exists_right":
 "/-- If at least one `π i` is infinite and the rest nonempty, the pi type of all `π` is infinite. -/\ntheorem pi.infinite_of_exists_right {ι : Type _} {π : ι → Type _} (i : ι) [Infinite <| π i] [∀ i, nonempty <| π i] :\n    Infinite (∀ i : ι, π i) :=\n  let ⟨m⟩ := @pi.nonempty ι π _\n  infinite.of_injective _ (update_injective m i)\n#align pi.infinite_of_exists_right pi.infinite_of_exists_right\n\n",
 "card_prod":
 "@[simp]\ntheorem fintype.card_prod (α β : Type _) [fintype α] [fintype β] :\n    fintype.card (α × β) = fintype.card α * fintype.card β :=\n  card_product _ _\n#align fintype.card_prod fintype.card_prod\n\n"}