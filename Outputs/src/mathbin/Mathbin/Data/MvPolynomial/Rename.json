{"support_rename_of_injective":
 "theorem support_rename_of_injective {p : MvPolynomial σ R} {f : σ → τ} (h : function.injective f) :\n    (rename f p).support = Finset.image (mapDomain f) p.support :=\n  by\n  rw [rename_eq]\n  exact Finsupp.mapDomain_support_of_injective (map_domain_injective h) _\n#align support_rename_of_injective support_rename_of_injective\n\n",
 "rename_rename":
 "@[simp]\ntheorem rename_rename (f : σ → τ) (g : τ → α) (p : MvPolynomial σ R) : rename g (rename f p) = rename (g ∘ f) p :=\n  show rename g (eval₂ C (X ∘ f) p) = _ by\n    simp only [rename, aeval_eq_eval₂_hom]\n    simp [eval₂_comp_left _ C (X ∘ f) p, (· ∘ ·), eval₂_C, eval_X]\n    apply eval₂_hom_congr _ rfl rfl\n    ext1; simp only [comp_app, RingHom.coe_comp, eval₂_hom_C]\n#align rename_rename rename_rename\n\n",
 "rename_prodmk_eval₂":
 "theorem rename_prodmk_eval₂ (j : τ) (g : σ → MvPolynomial σ R) :\n    rename (prod.mk j) (p.eval₂ C g) = p.eval₂ C fun x => rename (prod.mk j) (g x) := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n#align rename_prodmk_eval₂ rename_prodmk_eval₂\n\n",
 "rename_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem rename_monomial (f : σ → τ) (d : «expr →₀ » σ ℕ) (r : R) :\n    rename f (monomial d r) = monomial (d.map_domain f) r :=\n  by\n  rw [rename, aeval_monomial, monomial_eq, Finsupp.prod_mapDomain_index]\n  · rfl\n  · exact fun n => pow_zero _\n  · exact fun n i₁ i₂ => pow_add _ _ _\n#align rename_monomial rename_monomial\n\n",
 "rename_injective":
 "theorem rename_injective (f : σ → τ) (hf : function.injective f) :\n    function.injective (rename f : MvPolynomial σ R → MvPolynomial τ R) :=\n  by\n  have : (rename f : MvPolynomial σ R → MvPolynomial τ R) = Finsupp.mapDomain (Finsupp.mapDomain f) :=\n    funext (rename_eq f)\n  rw [this]\n  exact Finsupp.mapDomain_injective (Finsupp.mapDomain_injective hf)\n#align rename_injective rename_injective\n\n",
 "rename_id":
 "@[simp]\ntheorem rename_id (p : MvPolynomial σ R) : rename id p = p :=\n  eval₂_eta p\n#align rename_id rename_id\n\n",
 "rename_eval₂":
 "theorem rename_eval₂ (g : τ → MvPolynomial σ R) : rename k (p.eval₂ C (g ∘ k)) = (rename k p).eval₂ C (rename k ∘ g) :=\n  by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n#align rename_eval₂ rename_eval₂\n\n",
 "rename_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem rename_equiv_trans (e : «expr ≃ » σ τ) (f : «expr ≃ » τ α) :\n    (renameEquiv R e).trans (renameEquiv R f) = renameEquiv R (e.trans f) :=\n  AlgEquiv.ext (rename_rename e f)\n#align rename_equiv_trans rename_equiv_trans\n\n",
 "rename_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem rename_equiv_symm (f : «expr ≃ » σ τ) : (renameEquiv R f).symm = renameEquiv R f.symm :=\n  rfl\n#align rename_equiv_symm rename_equiv_symm\n\n",
 "rename_equiv_refl":
 "@[simp]\ntheorem rename_equiv_refl : renameEquiv R (Equiv.refl σ) = AlgEquiv.refl :=\n  AlgEquiv.ext rename_id\n#align rename_equiv_refl rename_equiv_refl\n\n",
 "rename_eq":
 "theorem rename_eq (f : σ → τ) (p : MvPolynomial σ R) : rename f p = Finsupp.mapDomain (Finsupp.mapDomain f) p :=\n  by\n  simp only [rename, aeval_def, eval₂, Finsupp.mapDomain, algebra_map_eq, X_pow_eq_monomial, ←\n    monomial_finsupp_sum_index]\n  rfl\n#align rename_eq rename_eq\n\n",
 "rename_X":
 "@[simp]\ntheorem rename_X (f : σ → τ) (i : σ) : rename f (X i : MvPolynomial σ R) = X (f i) :=\n  eval₂_X _ _ _\n#align rename_X rename_X\n\n",
 "rename_C":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Johan Commelin, Mario Carneiro\n-/\n@[simp]\ntheorem rename_C (f : σ → τ) (r : R) : rename f (C r) = C r :=\n  eval₂_C _ _ _\n#align rename_C rename_C\n\n",
 "map_rename":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_rename (f : «expr →+* » R S) (g : σ → τ) (p : MvPolynomial σ R) : map f (rename g p) = rename g (map f p) :=\n  MvPolynomial.induction_on p (fun a => by simp only [map_C, rename_C])\n    (fun p q hp hq => by simp only [hp, hq, AlgHom.map_add, RingHom.map_add]) fun p n hp => by\n    simp only [hp, rename_X, map_X, RingHom.map_mul, AlgHom.map_mul]\n#align map_rename map_rename\n\n",
 "kill_compl_rename_app":
 "@[simp]\ntheorem kill_compl_rename_app (p : MvPolynomial σ R) : killCompl hf (rename f p) = p :=\n  AlgHom.congr_fun (killCompl_comp_rename hf) p\n#align kill_compl_rename_app kill_compl_rename_app\n\n",
 "kill_compl_comp_rename":
 "theorem kill_compl_comp_rename : (killCompl hf).comp (rename f) = AlgHom.id R _ :=\n  algHom_ext fun i => by\n    dsimp\n    rw [rename, kill_compl, aeval_X, aeval_X, dif_pos, Equiv.ofInjective_symm_apply]\n#align kill_compl_comp_rename kill_compl_comp_rename\n\n",
 "exists_finset_rename₂":
 "/-- `exists_finset_rename` for two polyonomials at once: for any two polynomials `p₁`, `p₂` in a\n  polynomial semiring `R[σ]` of possibly infinitely many variables, `exists_finset_rename₂` yields\n  a finite subset `s` of `σ` such that both `p₁` and `p₂` are contained in the polynomial semiring\n  `R[s]` of finitely many variables. -/\ntheorem exists_finset_rename₂ (p₁ p₂ : MvPolynomial σ R) :\n    ∃ (s : Finset σ)(q₁ q₂ : MvPolynomial s R), p₁ = rename coe q₁ ∧ p₂ = rename coe q₂ :=\n  by\n  obtain ⟨s₁, q₁, rfl⟩ := exists_finset_rename p₁\n  obtain ⟨s₂, q₂, rfl⟩ := exists_finset_rename p₂\n  classical\n    use s₁ ∪ s₂\n    use rename (Set.inclusion <| s₁.subset_union_left s₂) q₁\n    use rename (Set.inclusion <| s₁.subset_union_right s₂) q₂\n    constructor <;> simpa\n#align exists_finset_rename₂ exists_finset_rename₂\n\n",
 "exists_finset_rename":
 "/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem exists_finset_rename (p : MvPolynomial σ R) :\n    ∃ (s : Finset σ)(q : MvPolynomial { x // x ∈ s } R), p = rename coe q :=\n  by\n  apply induction_on p\n  · intro r\n    exact ⟨∅, C r, by rw [rename_C]⟩\n  · rintro p q ⟨s, p, rfl⟩ ⟨t, q, rfl⟩\n    refine' ⟨s ∪ t, ⟨_, _⟩⟩\n    ·\n      refine' rename (Subtype.map id _) p + rename (Subtype.map id _) q <;>\n        simp (config := { contextual := true }) only [id.def, true_or_iff, or_true_iff, Finset.mem_union,\n          forall_true_iff]\n    · simp only [rename_rename, AlgHom.map_add]\n      rfl\n  · rintro p n ⟨s, p, rfl⟩\n    refine' ⟨insert n s, ⟨_, _⟩⟩\n    · refine' rename (Subtype.map id _) p * X ⟨n, s.mem_insert_self n⟩\n      simp (config := { contextual := true }) only [id.def, or_true_iff, Finset.mem_insert, forall_true_iff]\n    · simp only [rename_rename, rename_X, Subtype.coe_mk, AlgHom.map_mul]\n      rfl\n#align exists_finset_rename exists_finset_rename\n\n",
 "exists_fin_rename":
 "/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem exists_fin_rename (p : MvPolynomial σ R) :\n    ∃ (n : ℕ)(f : Fin n → σ)(hf : injective f)(q : MvPolynomial (Fin n) R), p = rename f q :=\n  by\n  obtain ⟨s, q, rfl⟩ := exists_finset_rename p\n  let n := Fintype.card { x // x ∈ s }\n  let e := Fintype.equivFin { x // x ∈ s }\n  refine' ⟨n, coe ∘ e.symm, subtype.val_injective.comp e.symm.injective, rename e q, _⟩\n  rw [← rename_rename, rename_rename e]\n  simp only [Function.comp, Equiv.symm_apply_apply, rename_rename]\n#align exists_fin_rename exists_fin_rename\n\n",
 "eval₂_rename_prodmk":
 "theorem eval₂_rename_prodmk (g : σ × τ → S) (i : σ) (p : MvPolynomial τ R) :\n    (rename (prod.mk i) p).eval₂ f g = eval₂ f (fun j => g (i, j)) p := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n#align eval₂_rename_prodmk eval₂_rename_prodmk\n\n",
 "eval₂_rename":
 "theorem eval₂_rename : (rename k p).eval₂ f g = p.eval₂ f (g ∘ k) := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n#align eval₂_rename eval₂_rename\n\n",
 "eval₂_hom_rename":
 "theorem eval₂_hom_rename : eval₂Hom f g (rename k p) = eval₂Hom f (g ∘ k) p :=\n  eval₂_rename _ _ _ _\n#align eval₂_hom_rename eval₂_hom_rename\n\n",
 "eval₂_cast_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_cast_comp (f : σ → τ) (c : «expr →+* » ℤ R) (g : τ → R) (p : MvPolynomial σ ℤ) :\n    eval₂ c (g ∘ f) p = eval₂ c g (rename f p) :=\n  MvPolynomial.induction_on p (fun n => by simp only [eval₂_C, rename_C])\n    (fun p q hp hq => by simp only [hp, hq, rename, eval₂_add, AlgHom.map_add]) fun p n hp => by\n    simp only [hp, rename, aeval_def, eval₂_X, eval₂_mul]\n#align eval₂_cast_comp eval₂_cast_comp\n\n",
 "eval_rename_prodmk":
 "theorem eval_rename_prodmk (g : σ × τ → R) (i : σ) (p : MvPolynomial τ R) :\n    eval g (rename (prod.mk i) p) = eval (fun j => g (i, j)) p :=\n  eval₂_rename_prod_mk (RingHom.id _) _ _ _\n#align eval_rename_prodmk eval_rename_prodmk\n\n",
 "constant_coeff_rename":
 "@[simp]\ntheorem constant_coeff_rename {τ : Type _} (f : σ → τ) (φ : MvPolynomial σ R) :\n    constantCoeff (rename f φ) = constantCoeff φ :=\n  by\n  apply φ.induction_on\n  · intro a\n    simp only [constant_coeff_C, rename_C]\n  · intro p q hp hq\n    simp only [hp, hq, RingHom.map_add, AlgHom.map_add]\n  · intro p n hp\n    simp only [hp, rename_X, constant_coeff_X, RingHom.map_mul, AlgHom.map_mul]\n#align constant_coeff_rename constant_coeff_rename\n\n",
 "coeff_rename_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coeff_rename_ne_zero (f : σ → τ) (φ : MvPolynomial σ R) (d : «expr →₀ » τ ℕ) (h : (rename f φ).coeff d ≠ 0) :\n    ∃ u : «expr →₀ » σ ℕ, u.map_domain f = d ∧ φ.coeff u ≠ 0 :=\n  by\n  contrapose! h\n  apply coeff_rename_eq_zero _ _ _ h\n#align coeff_rename_ne_zero coeff_rename_ne_zero\n\n",
 "coeff_rename_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeff_rename_map_domain (f : σ → τ) (hf : injective f) (φ : MvPolynomial σ R) (d : «expr →₀ » σ ℕ) :\n    (rename f φ).coeff (d.map_domain f) = φ.coeff d :=\n  by\n  apply induction_on' φ\n  · intro u r\n    rw [rename_monomial, coeff_monomial, coeff_monomial]\n    simp only [(Finsupp.mapDomain_injective hf).eq_iff]\n  · intros\n    simp only [*, AlgHom.map_add, coeff_add]\n#align coeff_rename_map_domain coeff_rename_map_domain\n\n",
 "coeff_rename_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coeff_rename_eq_zero (f : σ → τ) (φ : MvPolynomial σ R) (d : «expr →₀ » τ ℕ)\n    (h : ∀ u : «expr →₀ » σ ℕ, u.map_domain f = d → φ.coeff u = 0) : (rename f φ).coeff d = 0 :=\n  by\n  rw [rename_eq, ← not_mem_support_iff]\n  intro H\n  replace H := map_domain_support H\n  rw [Finset.mem_image] at H\n  obtain ⟨u, hu, rfl⟩ := H\n  specialize h u rfl\n  simp at h hu\n  contradiction\n#align coeff_rename_eq_zero coeff_rename_eq_zero\n\n",
 "aeval_rename":
 "theorem aeval_rename [Algebra R S] : aeval g (rename k p) = aeval (g ∘ k) p :=\n  eval₂Hom_rename _ _ _ _\n#align aeval_rename aeval_rename\n\n"}