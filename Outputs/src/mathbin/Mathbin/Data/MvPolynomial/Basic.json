{"support_zero":
 "@[simp]\ntheorem support_zero : (0 : MvPolynomial σ R).support = ∅ :=\n  rfl\n#align support_zero support_zero\n\n",
 "support_symm_diff_support_subset_support_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\ntheorem support_symm_diff_support_subset_support_add [DecidableEq σ] (p q : MvPolynomial σ R) :\n    «expr ∆ » p.support q.support ⊆ (p + q).support :=\n  by\n  rw [symmDiff_def, Finset.sup_eq_union]\n  apply Finset.union_subset\n  · exact support_sdiff_support_subset_support_add p q\n  · rw [add_comm]\n    exact support_sdiff_support_subset_support_add q p\n#align support_symm_diff_support_subset_support_add support_symm_diff_support_subset_support_add\n\n",
 "support_sum_monomial_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem support_sum_monomial_coeff (p : MvPolynomial σ R) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" p.support\n        (monomial v (coeff v p)) =\n      p :=\n  Finsupp.sum_single p\n#align support_sum_monomial_coeff support_sum_monomial_coeff\n\n",
 "support_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem support_sum {α : Type _} {s : Finset α} {f : α → MvPolynomial σ R} :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)).support ⊆\n      s.bUnion fun x => (f x).support :=\n  Finsupp.support_finset_sum\n#align support_sum support_sum\n\n",
 "support_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem support_smul_eq {S₁ : Type _} [Semiring S₁] [Module S₁ R] [NoZeroSMulDivisors S₁ R] {a : S₁} (h : a ≠ 0)\n    (p : MvPolynomial σ R) : («expr • » a p).support = p.support :=\n  Finsupp.support_smul_eq h\n#align support_smul_eq support_smul_eq\n\n",
 "support_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem support_smul {S₁ : Type _} [SMulZeroClass S₁ R] {a : S₁} {f : MvPolynomial σ R} :\n    («expr • » a f).support ⊆ f.support :=\n  Finsupp.support_smul\n#align support_smul support_smul\n\n",
 "support_sdiff_support_subset_support_add":
 "theorem support_sdiff_support_subset_support_add [DecidableEq σ] (p q : MvPolynomial σ R) :\n    p.support \\ q.support ⊆ (p + q).support := by\n  intro m hm\n  simp only [Classical.not_not, mem_support_iff, Finset.mem_sdiff, ne.def] at hm\n  simp [hm.2, hm.1]\n#align support_sdiff_support_subset_support_add support_sdiff_support_subset_support_add\n\n",
 "support_mul_X":
 "@[simp]\ntheorem support_mul_X (s : σ) (p : MvPolynomial σ R) :\n    (p * X s).support = p.support.map (addRightEmbedding (single s 1)) :=\n  AddMonoidAlgebra.support_mul_single p _ (by simp) _\n#align support_mul_X support_mul_X\n\n",
 "support_mul":
 "theorem support_mul (p q : MvPolynomial σ R) :\n    (p * q).support ⊆ p.support.bUnion fun a => q.support.bUnion fun b => {a + b} := by\n  convert AddMonoidAlgebra.support_mul p q <;> ext <;> convert iff.rfl\n#align support_mul support_mul\n\n",
 "support_monomial_subset":
 "theorem support_monomial_subset : (monomial s a).support ⊆ {s} :=\n  support_single_subset\n#align support_monomial_subset support_monomial_subset\n\n",
 "support_monomial":
 "theorem support_monomial [Decidable (a = 0)] : (monomial s a).support = if a = 0 then ∅ else {s} := by convert rfl\n#align support_monomial support_monomial\n\n",
 "support_map_subset":
 "theorem support_map_subset (p : MvPolynomial σ R) : (map f p).support ⊆ p.support :=\n  by\n  intro x\n  simp only [mem_support_iff]\n  contrapose!\n  change p.coeff x = 0 → (map f p).coeff x = 0\n  rw [coeff_map]\n  intro hx\n  rw [hx]\n  exact RingHom.map_zero f\n#align support_map_subset support_map_subset\n\n",
 "support_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem support_map_of_injective (p : MvPolynomial σ R) {f : «expr →+* » R S₁} (hf : injective f) :\n    (map f p).support = p.support := by\n  apply Finset.Subset.antisymm\n  · exact MvPolynomial.support_map_subset _ _\n  intro x hx\n  rw [mem_support_iff]\n  contrapose! hx\n  simp only [Classical.not_not, mem_support_iff]\n  change (map f p).coeff x = 0 at hx\n  rw [coeff_map, ← f.map_zero] at hx\n  exact hf hx\n#align support_map_of_injective support_map_of_injective\n\n",
 "support_eq_empty":
 "@[simp]\ntheorem support_eq_empty {p : MvPolynomial σ R} : p.support = ∅ ↔ p = 0 :=\n  Finsupp.support_eq_empty\n#align support_eq_empty support_eq_empty\n\n",
 "support_add":
 "theorem support_add : (p + q).support ⊆ p.support ∪ q.support :=\n  Finsupp.support_add\n#align support_add support_add\n\n",
 "support_X_pow":
 "theorem support_X_pow [Nontrivial R] (s : σ) (n : ℕ) : (X s ^ n : MvPolynomial σ R).support = {Finsupp.single s n} := by\n  rw [X_pow_eq_monomial, support_monomial, if_neg (one_ne_zero' R)]\n#align support_X_pow support_X_pow\n\n",
 "support_X_mul":
 "@[simp]\ntheorem support_X_mul (s : σ) (p : MvPolynomial σ R) :\n    (X s * p).support = p.support.map (addLeftEmbedding (single s 1)) :=\n  AddMonoidAlgebra.support_single_mul p _ (by simp) _\n#align support_X_mul support_X_mul\n\n",
 "support_X":
 "theorem support_X [Nontrivial R] : (X n : MvPolynomial σ R).support = {single n 1} := by\n  rw [X, support_monomial, if_neg] <;> exact one_ne_zero\n#align support_X support_X\n\n",
 "sum_monomial_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_monomial_eq {A : Type _} [AddCommMonoid A] {u : «expr →₀ » σ ℕ} {r : R} {b : «expr →₀ » σ ℕ → R → A}\n    (w : b u 0 = 0) : Sum (monomial u r) b = b u r :=\n  sum_single_index w\n#align sum_monomial_eq sum_monomial_eq\n\n",
 "sum_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_def {A} [AddCommMonoid A] {p : MvPolynomial σ R} {b : «expr →₀ » σ ℕ → R → A} :\n    p.sum b =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" p.support\n        (b m (p.coeff m)) :=\n  by simp [support, Finsupp.sum, coeff]\n#align sum_def sum_def\n\n",
 "sum_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sum_C {A : Type _} [AddCommMonoid A] {b : «expr →₀ » σ ℕ → R → A} (w : b 0 0 = 0) : Sum (C a) b = b 0 a :=\n  sum_monomial_eq w\n#align sum_C sum_C\n\n",
 "smul_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_monomial {S₁ : Type _} [SMulZeroClass S₁ R] (r : S₁) :\n    «expr • » r (monomial s a) = monomial s («expr • » r a) :=\n  Finsupp.smul_single _ _ _\n#align smul_monomial smul_monomial\n\n",
 "smul_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_eval (x) (p : MvPolynomial σ R) (s) : eval x («expr • » s p) = s * eval x p := by\n  rw [smul_eq_C_mul, (eval x).map_mul, eval_C]\n#align smul_eval smul_eval\n\n",
 "smul_eq_C_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_eq_C_mul (p : MvPolynomial σ R) (a : R) : «expr • » a p = C a * p :=\n  C_mul'.symm\n#align smul_eq_C_mul smul_eq_C_mul\n\n",
 "single_eq_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Johan Commelin, Mario Carneiro\n-/\n-- Register with high priority to avoid timeout in `data.mv_polynomial.pderiv`\ntheorem single_eq_monomial (s : «expr →₀ » σ ℕ) (a : R) : single s a = monomial s a :=\n  rfl\n#align single_eq_monomial single_eq_monomial\n\n",
 "ring_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem ring_hom_ext' {A : Type _} [Semiring A] {f g : «expr →+* » (MvPolynomial σ R) A} (hC : f.comp C = g.comp C)\n    (hX : ∀ i, f (X i) = g (X i)) : f = g :=\n  ringHom_ext (RingHom.ext_iff.1 hC) hX\n#align ring_hom_ext' ring_hom_ext'\n\n",
 "ring_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem ring_hom_ext {A : Type _} [Semiring A] {f g : «expr →+* » (MvPolynomial σ R) A} (hC : ∀ r, f (C r) = g (C r))\n    (hX : ∀ i, f (X i) = g (X i)) : f = g := by\n  ext\n  exacts[hC _, hX _]\n#align ring_hom_ext ring_hom_ext\n\n",
 "not_mem_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem not_mem_support_iff {p : MvPolynomial σ R} {m : «expr →₀ » σ ℕ} : m ∉ p.support ↔ p.coeff m = 0 := by simp\n#align not_mem_support_iff not_mem_support_iff\n\n",
 "neZero_iff":
 "#print neZero_iff /-\ntheorem neZero_iff {p : MvPolynomial σ R} : p ≠ 0 ↔ ∃ d, coeff d p ≠ 0 :=\n  by\n  rw [ne.def, eq_zero_iff]\n  push_neg\n#align ne_zero_iff neZero_iff\n-/\n\n",
 "mul_def":
 "theorem mul_def : p * q = p.sum fun m a => q.sum fun n b => monomial (m + n) (a * b) :=\n  rfl\n#align mul_def mul_def\n\n",
 "monomial_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem monomial_zero' : (monomial (0 : «expr →₀ » σ ℕ) : R → MvPolynomial σ R) = C :=\n  rfl\n#align monomial_zero' monomial_zero'\n\n",
 "monomial_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem monomial_zero {s : «expr →₀ » σ ℕ} : monomial s (0 : R) = 0 :=\n  single_zero _\n#align monomial_zero monomial_zero\n\n",
 "monomial_sum_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem monomial_sum_one {α : Type _} (s : Finset α) (f : α → «expr →₀ » σ ℕ) :\n    (monomial (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i))\n          1 :\n        MvPolynomial σ R) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (monomial (f i) 1) :=\n  (monomialOneHom R σ).map_prod (fun i => Multiplicative.ofAdd (f i)) s\n#align monomial_sum_one monomial_sum_one\n\n",
 "monomial_sum_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem monomial_sum_index {α : Type _} (s : Finset α) (f : α → «expr →₀ » σ ℕ) (a : R) :\n    monomial (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i))\n        a =\n      C a *\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (monomial (f i) 1) :=\n  by rw [← monomial_sum_one, C_mul', ← (monomial _).map_smul, smul_eq_mul, mul_one]\n#align monomial_sum_index monomial_sum_index\n\n",
 "monomial_single_add":
 "theorem monomial_single_add : monomial (single n e + s) a = X n ^ e * monomial s a := by\n  rw [X_pow_eq_monomial, monomial_mul, one_mul]\n#align monomial_single_add monomial_single_add\n\n",
 "monomial_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem monomial_pow : monomial s a ^ e = monomial («expr • » e s) (a ^ e) :=\n  AddMonoidAlgebra.single_pow e\n#align monomial_pow monomial_pow\n\n",
 "monomial_one_hom_apply":
 "@[simp]\ntheorem monomial_one_hom_apply : monomialOneHom R σ s = (monomial s 1 : MvPolynomial σ R) :=\n  rfl\n#align monomial_one_hom_apply monomial_one_hom_apply\n\n",
 "monomial_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem monomial_mul {s s' : «expr →₀ » σ ℕ} {a b : R} : monomial s a * monomial s' b = monomial (s + s') (a * b) :=\n  AddMonoidAlgebra.single_mul_single\n#align monomial_mul monomial_mul\n\n",
 "monomial_left_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem monomial_left_injective {r : R} (hr : r ≠ 0) : function.injective fun s : «expr →₀ » σ ℕ => monomial s r :=\n  Finsupp.single_left_injective hr\n#align monomial_left_injective monomial_left_injective\n\n",
 "monomial_left_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem monomial_left_inj {s t : «expr →₀ » σ ℕ} {r : R} (hr : r ≠ 0) : monomial s r = monomial t r ↔ s = t :=\n  Finsupp.single_left_inj hr\n#align monomial_left_inj monomial_left_inj\n\n",
 "monomial_finsupp_sum_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem monomial_finsupp_sum_index {α β : Type _} [Zero β] (f : «expr →₀ » α β) (g : α → β → «expr →₀ » σ ℕ) (a : R) :\n    monomial (f.sum g) a = C a * f.prod fun a b => monomial (g a b) 1 :=\n  monomial_sum_index _ _ _\n#align monomial_finsupp_sum_index monomial_finsupp_sum_index\n\n",
 "monomial_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem monomial_eq_zero {s : «expr →₀ » σ ℕ} {b : R} : monomial s b = 0 ↔ b = 0 :=\n  Finsupp.single_eq_zero\n#align monomial_eq_zero monomial_eq_zero\n\n",
 "monomial_eq_monomial_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem monomial_eq_monomial_iff {α : Type _} (a₁ a₂ : «expr →₀ » α ℕ) (b₁ b₂ : R) :\n    monomial a₁ b₁ = monomial a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂ ∨ b₁ = 0 ∧ b₂ = 0 :=\n  Finsupp.single_eq_single_iff _ _ _ _\n#align monomial_eq_monomial_iff monomial_eq_monomial_iff\n\n",
 "monomial_eq":
 "theorem monomial_eq : monomial s a = C a * (s.prod fun n e => X n ^ e : MvPolynomial σ R) := by\n  simp only [X_pow_eq_monomial, ← monomial_finsupp_sum_index, Finsupp.sum_single]\n#align monomial_eq monomial_eq\n\n",
 "monomial_add_single":
 "theorem monomial_add_single : monomial (s + single n e) a = monomial s a * X n ^ e := by\n  rw [X_pow_eq_monomial, monomial_mul, mul_one]\n#align monomial_add_single monomial_add_single\n\n",
 "monic_monomial_eq":
 "theorem monic_monomial_eq (m) : monomial m (1 : R) = (m.prod fun n e => X n ^ e : MvPolynomial σ R) := by\n  simp [monomial_eq]\n#align monic_monomial_eq monic_monomial_eq\n\n",
 "mem_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem mem_support_iff {p : MvPolynomial σ R} {m : «expr →₀ » σ ℕ} : m ∈ p.support ↔ p.coeff m ≠ 0 := by\n  simp [support, coeff]\n#align mem_support_iff mem_support_iff\n\n",
 "map_surjective":
 "theorem map_surjective (hf : function.surjective f) :\n    function.surjective (map f : MvPolynomial σ R → MvPolynomial σ S₁) := fun p =>\n  by\n  induction' p using MvPolynomial.induction_on' with i fr a b ha hb\n  · obtain ⟨r, rfl⟩ := hf fr\n    exact ⟨monomial i r, map_monomial _ _ _⟩\n  · obtain ⟨a, rfl⟩ := ha\n    obtain ⟨b, rfl⟩ := hb\n    exact ⟨a + b, RingHom.map_add _ _ _⟩\n#align map_surjective map_surjective\n\n",
 "map_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f` is a right-inverse of `g` then `map f` is a right-inverse of `map g`. -/\ntheorem map_right_inverse {f : «expr →+* » R S₁} {g : «expr →+* » S₁ R} (hf : function.right_inverse f g) :\n    function.right_inverse (map f : MvPolynomial σ R → MvPolynomial σ S₁) (map g) :=\n  (map_leftInverse hf.left_inverse).right_inverse\n#align map_right_inverse map_right_inverse\n\n",
 "map_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_monomial (s : «expr →₀ » σ ℕ) (a : R) : map f (monomial s a) = monomial s (f a) :=\n  (eval₂_monomial _ _).trans monomial_eq.symm\n#align map_monomial map_monomial\n\n",
 "map_map_range_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map_range_eq_iff (f : «expr →+* » R S₁) (g : S₁ → R) (hg : g 0 = 0) (φ : MvPolynomial σ S₁) :\n    map f (Finsupp.mapRange g hg φ) = φ ↔ ∀ d, f (g (coeff d φ)) = coeff d φ :=\n  by\n  rw [MvPolynomial.ext_iff]\n  apply forall_congr'; intro m\n  rw [coeff_map]\n  apply eq_iff_eq_cancel_right.mpr\n  rfl\n#align map_map_range_eq_iff map_map_range_eq_iff\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map [CommSemiring S₂] (g : «expr →+* » S₁ S₂) (p : MvPolynomial σ R) : map g (map f p) = map (g.comp f) p :=\n  (eval₂_comp_left (map g) (C.comp f) X p).trans <| by\n    congr\n    · ext1 a\n      simp only [map_C, comp_app, RingHom.coe_comp]\n    · ext1 n\n      simp only [map_X, comp_app]\n#align map_map map_map\n\n",
 "map_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f` is a left-inverse of `g` then `map f` is a left-inverse of `map g`. -/\ntheorem map_left_inverse {f : «expr →+* » R S₁} {g : «expr →+* » S₁ R} (hf : function.left_inverse f g) :\n    function.left_inverse (map f : MvPolynomial σ R → MvPolynomial σ S₁) (map g) := fun x => by\n  rw [map_map, (RingHom.ext hf : f.comp g = RingHom.id _), map_id]\n#align map_left_inverse map_left_inverse\n\n",
 "map_injective":
 "theorem map_injective (hf : function.injective f) : function.injective (map f : MvPolynomial σ R → MvPolynomial σ S₁) :=\n  by\n  intro p q h\n  simp only [ext_iff, coeff_map] at h⊢\n  intro m\n  exact hf (h m)\n#align map_injective map_injective\n\n",
 "map_id":
 "theorem map_id : ∀ p : MvPolynomial σ R, map (RingHom.id R) p = p :=\n  eval₂_eta\n#align map_id map_id\n\n",
 "map_eval₂_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_eval₂_hom [CommSemiring S₂] (f : «expr →+* » R S₁) (g : σ → S₁) (φ : «expr →+* » S₁ S₂)\n    (p : MvPolynomial σ R) : φ (eval₂Hom f g p) = eval₂Hom (φ.comp f) (fun i => φ (g i)) p :=\n  by\n  rw [← comp_eval₂_hom]\n  rfl\n#align map_eval₂_hom map_eval₂_hom\n\n",
 "map_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_eval₂ (f : «expr →+* » R S₁) (g : S₂ → MvPolynomial S₃ R) (p : MvPolynomial S₂ R) :\n    map f (eval₂ C g p) = eval₂ C (map f ∘ g) (map f p) :=\n  by\n  apply MvPolynomial.induction_on p\n  · intro r\n    rw [eval₂_C, map_C, map_C, eval₂_C]\n  · intro p q hp hq\n    rw [eval₂_add, (map f).map_add, hp, hq, (map f).map_add, eval₂_add]\n  · intro p s hp\n    rw [eval₂_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval₂_mul, eval₂_X, eval₂_X]\n#align map_eval₂ map_eval₂\n\n",
 "map_alg_hom_id":
 "@[simp]\ntheorem map_alg_hom_id [Algebra R S₁] : mapAlgHom (AlgHom.id R S₁) = AlgHom.id R (MvPolynomial σ S₁) :=\n  AlgHom.ext map_id\n#align map_alg_hom_id map_alg_hom_id\n\n",
 "map_alg_hom_coe_ring_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_alg_hom_coe_ring_hom [CommSemiring S₂] [Algebra R S₁] [Algebra R S₂] (f : «expr →ₐ[ ] » S₁ R S₂) :\n    ↑(mapAlgHom f : «expr →ₐ[ ] » _ R (MvPolynomial σ S₂)) =\n      (map ↑f : «expr →+* » (MvPolynomial σ S₁) (MvPolynomial σ S₂)) :=\n  RingHom.mk_coe _ _ _ _ _\n#align map_alg_hom_coe_ring_hom map_alg_hom_coe_ring_hom\n\n",
 "map_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem map_aeval {B : Type _} [CommSemiring B] (g : σ → S₁) (φ : «expr →+* » S₁ B) (p : MvPolynomial σ R) :\n    φ (aeval g p) = eval₂Hom (φ.comp (algebraMap R S₁)) (fun i => φ (g i)) p :=\n  by\n  rw [← comp_eval₂_hom]\n  rfl\n#align map_aeval map_aeval\n\n",
 "map_X":
 "@[simp]\ntheorem map_X : ∀ n : σ, map f (X n : MvPolynomial σ R) = X n :=\n  eval₂_X _ _\n#align map_X map_X\n\n",
 "map_C":
 "@[simp]\ntheorem map_C : ∀ a : R, map f (C a : MvPolynomial σ R) = C (f a) :=\n  map_monomial _ _\n#align map_C map_C\n\n",
 "linear_map_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n@[ext]\ntheorem linear_map_ext {M : Type _} [AddCommMonoid M] [Module R M] {f g : «expr →ₗ[ ] » (MvPolynomial σ R) R M}\n    (h : ∀ s, «expr ∘ₗ » f (monomial s) = «expr ∘ₗ » g (monomial s)) : f = g :=\n  Finsupp.lhom_ext' h\n#align linear_map_ext linear_map_ext\n\n",
 "is_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem is_id (f : «expr →+* » (MvPolynomial σ R) (MvPolynomial σ R)) (hC : f.comp C = C) (hX : ∀ n : σ, f (X n) = X n)\n    (p : MvPolynomial σ R) : f p = p :=\n  hom_eq_hom f (RingHom.id _) hC hX p\n#align is_id is_id\n\n",
 "induction_on_monomial":
 "theorem induction_on_monomial {M : MvPolynomial σ R → Prop} (h_C : ∀ a, M (C a)) (h_X : ∀ p n, M p → M (p * X n)) :\n    ∀ s a, M (monomial s a) := by\n  intro s a\n  apply @Finsupp.induction σ ℕ _ _ s\n  · show M (monomial 0 a)\n    exact h_C a\n  · intro n e p hpn he ih\n    have : ∀ e : ℕ, M (monomial p a * X n ^ e) := by\n      intro e\n      induction e\n      · simp [ih]\n      · simp [ih, pow_succ', (mul_assoc _ _ _).symm, h_X, e_ih]\n    simp [add_comm, monomial_add_single, this]\n#align induction_on_monomial induction_on_monomial\n\n",
 "induction_on'''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Similar to `mv_polynomial.induction_on` but only a weak form of `h_add` is required.-/\ntheorem induction_on''' {M : MvPolynomial σ R → Prop} (p : MvPolynomial σ R) (h_C : ∀ a, M (C a))\n    (h_add_weak :\n      ∀ (a : «expr →₀ » σ ℕ) (b : R) (f : «expr →₀ » («expr →₀ » σ ℕ) R),\n        a ∉ f.support → b ≠ 0 → M f → M (monomial a b + f)) :\n    M p :=\n  Finsupp.induction p (C_0.rec <| h_C 0) h_add_weak\n#align induction_on''' induction_on'''\n\n",
 "induction_on''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Similar to `mv_polynomial.induction_on` but only a yet weaker form of `h_add` is required.-/\ntheorem induction_on'' {M : MvPolynomial σ R → Prop} (p : MvPolynomial σ R) (h_C : ∀ a, M (C a))\n    (h_add_weak :\n      ∀ (a : «expr →₀ » σ ℕ) (b : R) (f : «expr →₀ » («expr →₀ » σ ℕ) R),\n        a ∉ f.support → b ≠ 0 → M f → M (monomial a b) → M (monomial a b + f))\n    (h_X : ∀ (p : MvPolynomial σ R) (n : σ), M p → M (p * MvPolynomial.X n)) : M p :=\n  induction_on''' p h_C fun a b f ha hb hf => h_add_weak a b f ha hb hf <| induction_on_monomial h_C h_X a b\n#align induction_on'' induction_on''\n\n",
 "induction_on'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Analog of `polynomial.induction_on'`.\nTo prove something about mv_polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\n@[elab_as_elim]\ntheorem induction_on' {P : MvPolynomial σ R → Prop} (p : MvPolynomial σ R)\n    (h1 : ∀ (u : «expr →₀ » σ ℕ) (a : R), P (monomial u a)) (h2 : ∀ p q : MvPolynomial σ R, P p → P q → P (p + q)) :\n    P p :=\n  Finsupp.induction p\n    (suffices P (monomial 0 0) by rwa [monomial_zero] at this\n    show P (monomial 0 0) from h1 0 0)\n    fun a b f ha hb hPf => h2 _ _ (h1 _ _) hPf\n#align induction_on' induction_on'\n\n",
 "induction_on":
 "/-- Analog of `polynomial.induction_on`.-/\n@[recursor 5]\ntheorem induction_on {M : MvPolynomial σ R → Prop} (p : MvPolynomial σ R) (h_C : ∀ a, M (C a))\n    (h_add : ∀ p q, M p → M q → M (p + q)) (h_X : ∀ p n, M p → M (p * X n)) : M p :=\n  induction_on'' p h_C (fun a b f ha hb hf hm => h_add (monomial a b) f hm hf) h_X\n#align induction_on induction_on\n\n",
 "hom_eq_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem hom_eq_hom [Semiring S₂] (f g : «expr →+* » (MvPolynomial σ R) S₂) (hC : f.comp C = g.comp C)\n    (hX : ∀ n : σ, f (X n) = g (X n)) (p : MvPolynomial σ R) : f p = g p :=\n  RingHom.congr_fun (ringHom_ext' hC hX) p\n#align hom_eq_hom hom_eq_hom\n\n",
 "finsupp_support_eq_support":
 "theorem finsupp_support_eq_support (p : MvPolynomial σ R) : Finsupp.support p = p.support :=\n  rfl\n#align finsupp_support_eq_support finsupp_support_eq_support\n\n",
 "ext_iff":
 "theorem ext_iff (p q : MvPolynomial σ R) : p = q ↔ ∀ m, coeff m p = coeff m q :=\n  ⟨fun h m => by rw [h], ext p q⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext (p q : MvPolynomial σ R) : (∀ m, coeff m p = coeff m q) → p = q :=\n  ext\n#align ext ext\n\n",
 "exists_coeff_ne_zero":
 "theorem exists_coeff_ne_zero {p : MvPolynomial σ R} (h : p ≠ 0) : ∃ d, coeff d p ≠ 0 :=\n  ne_zero_iff.mp h\n#align exists_coeff_ne_zero exists_coeff_ne_zero\n\n",
 "eval₂_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_zero_apply (f : «expr →+* » R S₂) (p : MvPolynomial σ R) : eval₂ f (0 : σ → S₂) p = f (constantCoeff p) :=\n  eval₂Hom_zero_apply _ _\n#align eval₂_zero_apply eval₂_zero_apply\n\n",
 "eval₂_zero'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_zero'_apply (f : «expr →+* » R S₂) (p : MvPolynomial σ R) :\n    eval₂ f (fun _ => 0 : σ → S₂) p = f (constantCoeff p) :=\n  eval₂_zero_apply f p\n#align eval₂_zero'_apply eval₂_zero'_apply\n\n",
 "eval₂_zero":
 "@[simp]\ntheorem eval₂_zero : (0 : MvPolynomial σ R).eval₂ f g = 0 :=\n  Finsupp.sum_zero_index\n#align eval₂_zero eval₂_zero\n\n",
 "eval₂_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem eval₂_sum (s : Finset S₂) (p : S₂ → MvPolynomial σ R) :\n    eval₂ f g\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (p x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (eval₂ f g (p x)) :=\n  (eval₂Hom f g).map_sum _ s\n#align eval₂_sum eval₂_sum\n\n",
 "eval₂_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem eval₂_prod (s : Finset S₂) (p : S₂ → MvPolynomial σ R) :\n    eval₂ f g\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p x)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (eval₂ f g (p x)) :=\n  (eval₂Hom f g).map_prod _ s\n#align eval₂_prod eval₂_prod\n\n",
 "eval₂_pow":
 "@[simp]\ntheorem eval₂_pow {p : MvPolynomial σ R} : ∀ {n : ℕ}, (p ^ n).eval₂ f g = p.eval₂ f g ^ n\n  | 0 => by\n    rw [pow_zero, pow_zero]\n    exact eval₂_one _ _\n  | n + 1 => by rw [pow_add, pow_one, pow_add, pow_one, eval₂_mul, eval₂_pow]\n#align eval₂_pow eval₂_pow\n\n",
 "eval₂_one":
 "@[simp]\ntheorem eval₂_one : (1 : MvPolynomial σ R).eval₂ f g = 1 :=\n  (eval₂_C _ _ _).trans f.map_one\n#align eval₂_one eval₂_one\n\n",
 "eval₂_mul_monomial":
 "theorem eval₂_mul_monomial : ∀ {s a}, (p * monomial s a).eval₂ f g = p.eval₂ f g * f a * s.prod fun n e => g n ^ e :=\n  by\n  apply MvPolynomial.induction_on p\n  · intro a' s a\n    simp [C_mul_monomial, eval₂_monomial, f.map_mul]\n  · intro p q ih_p ih_q\n    simp [add_mul, eval₂_add, ih_p, ih_q]\n  · intro p n ih s a\n    exact\n      calc\n        (p * X n * monomial s a).eval₂ f g = (p * monomial (single n 1 + s) a).eval₂ f g := by\n          rw [monomial_single_add, pow_one, mul_assoc]\n        _ = (p * monomial (single n 1) 1).eval₂ f g * f a * s.prod fun n e => g n ^ e := by\n          simp [ih, prod_single_index, prod_add_index, pow_one, pow_add, mul_assoc, mul_left_comm, f.map_one, -add_comm]\n        \n#align eval₂_mul_monomial eval₂_mul_monomial\n\n",
 "eval₂_mul_C":
 "theorem eval₂_mul_C : (p * C a).eval₂ f g = p.eval₂ f g * f a :=\n  (eval₂_mul_monomial _ _).trans <| by simp\n#align eval₂_mul_C eval₂_mul_C\n\n",
 "eval₂_mul":
 "@[simp]\ntheorem eval₂_mul : ∀ {p}, (p * q).eval₂ f g = p.eval₂ f g * q.eval₂ f g :=\n  by\n  apply MvPolynomial.induction_on q\n  · simp [eval₂_C, eval₂_mul_C]\n  · simp (config := { contextual := true }) [mul_add, eval₂_add]\n  · simp (config := { contextual := true }) [X, eval₂_monomial, eval₂_mul_monomial, ← mul_assoc]\n#align eval₂_mul eval₂_mul\n\n",
 "eval₂_monomial":
 "@[simp]\ntheorem eval₂_monomial : (monomial s a).eval₂ f g = f a * s.prod fun n e => g n ^ e :=\n  Finsupp.sum_single_index (by simp [f.map_zero])\n#align eval₂_monomial eval₂_monomial\n\n",
 "eval₂_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_mem {f : «expr →+* » R S} {p : MvPolynomial σ R} {s : subS} (hs : ∀ i ∈ p.support, f (p.coeff i) ∈ s)\n    {v : σ → S} (hv : ∀ i, v i ∈ s) : MvPolynomial.eval₂ f v p ∈ s := by\n  classical\n    replace hs : ∀ i, f (p.coeff i) ∈ s\n    · intro i\n      by_cases hi : i ∈ p.support\n      · exact hs i hi\n      · rw [MvPolynomial.not_mem_support_iff.1 hi, f.map_zero]\n        exact zero_mem s\n    induction' p using MvPolynomial.induction_on''' with a a b f ha hb0 ih generalizing hs\n    · simpa using hs 0\n    rw [eval₂_add, eval₂_monomial]\n    refine' add_mem (mul_mem _ <| prod_mem fun i hi => pow_mem (hv _) _) (ih fun i => _)\n    · simpa only [coeff_add, coeff_monomial, if_pos rfl, MvPolynomial.not_mem_support_iff.1 ha, add_zero] using hs a\n    have := hs i\n    rw [coeff_add, coeff_monomial] at this\n    split_ifs  at this with h h\n    · subst h\n      rw [MvPolynomial.not_mem_support_iff.1 ha, map_zero]\n      exact zero_mem _\n    · rwa [zero_add] at this\n#align eval₂_mem eval₂_mem\n\n",
 "eval₂_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_map [CommSemiring S₂] (f : «expr →+* » R S₁) (g : σ → S₂) (φ : «expr →+* » S₁ S₂) (p : MvPolynomial σ R) :\n    eval₂ φ g (map f p) = eval₂ (φ.comp f) g p := by rw [← eval_map, ← eval_map, map_map]\n#align eval₂_map eval₂_map\n\n",
 "eval₂_id":
 "@[simp]\ntheorem eval₂_id (p : MvPolynomial σ R) (g : σ → R) : eval₂ (RingHom.id _) g p = eval g p :=\n  rfl\n#align eval₂_id eval₂_id\n\n",
 "eval₂_hom_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_hom_zero_apply (f : «expr →+* » R S₂) (p : MvPolynomial σ R) :\n    eval₂Hom f (0 : σ → S₂) p = f (constantCoeff p) :=\n  RingHom.congr_fun (eval₂Hom_zero f) p\n#align eval₂_hom_zero_apply eval₂_hom_zero_apply\n\n",
 "eval₂_hom_zero'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_hom_zero'_apply (f : «expr →+* » R S₂) (p : MvPolynomial σ R) :\n    eval₂Hom f (fun _ => 0 : σ → S₂) p = f (constantCoeff p) :=\n  eval₂Hom_zero_apply f p\n#align eval₂_hom_zero'_apply eval₂_hom_zero'_apply\n\n",
 "eval₂_hom_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_hom_zero' (f : «expr →+* » R S₂) : eval₂Hom f (fun _ => 0 : σ → S₂) = f.comp constantCoeff :=\n  eval₂Hom_zero f\n#align eval₂_hom_zero' eval₂_hom_zero'\n\n",
 "eval₂_hom_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_hom_zero (f : «expr →+* » R S₂) : eval₂Hom f (0 : σ → S₂) = f.comp constantCoeff := by ext <;> simp\n#align eval₂_hom_zero eval₂_hom_zero\n\n",
 "eval₂_hom_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem eval₂_hom_monomial (f : «expr →+* » R S₁) (g : σ → S₁) (d : «expr →₀ » σ ℕ) (r : R) :\n    eval₂Hom f g (monomial d r) = f r * d.prod fun i k => g i ^ k := by\n  simp only [monomial_eq, RingHom.map_mul, eval₂_hom_C, Finsupp.prod, RingHom.map_prod, RingHom.map_pow, eval₂_hom_X']\n#align eval₂_hom_monomial eval₂_hom_monomial\n\n",
 "eval₂_hom_map_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_hom_map_hom [CommSemiring S₂] (f : «expr →+* » R S₁) (g : σ → S₂) (φ : «expr →+* » S₁ S₂)\n    (p : MvPolynomial σ R) : eval₂Hom φ g (map f p) = eval₂Hom (φ.comp f) g p :=\n  eval₂_map f g φ p\n#align eval₂_hom_map_hom eval₂_hom_map_hom\n\n",
 "eval₂_hom_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_hom_eq_zero (f : «expr →+* » R S₂) (g : σ → S₂) (φ : MvPolynomial σ R)\n    (h : ∀ d, φ.coeff d ≠ 0 → ∃ i ∈ d.support, g i = 0) : eval₂Hom f g φ = 0 :=\n  by\n  rw [φ.as_sum, RingHom.map_sum, Finset.sum_eq_zero]\n  intro d hd\n  obtain ⟨i, hi, hgi⟩ : ∃ i ∈ d.support, g i = 0 := h d (finsupp.mem_support_iff.mp hd)\n  rw [eval₂_hom_monomial, Finsupp.prod, Finset.prod_eq_zero hi, MulZeroClass.mul_zero]\n  rw [hgi, zero_pow]\n  rwa [pos_iff_ne_zero, ← Finsupp.mem_support_iff]\n#align eval₂_hom_eq_zero eval₂_hom_eq_zero\n\n",
 "eval₂_hom_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_hom_congr {f₁ f₂ : «expr →+* » R S₁} {g₁ g₂ : σ → S₁} {p₁ p₂ : MvPolynomial σ R} :\n    f₁ = f₂ → g₁ = g₂ → p₁ = p₂ → eval₂Hom f₁ g₁ p₁ = eval₂Hom f₂ g₂ p₂ := by rintro rfl rfl rfl <;> rfl\n#align eval₂_hom_congr eval₂_hom_congr\n\n",
 "eval₂_hom_X'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_hom_X' (f : «expr →+* » R S₁) (g : σ → S₁) (i : σ) : eval₂Hom f g (X i) = g i :=\n  eval₂_X f g i\n#align eval₂_hom_X' eval₂_hom_X'\n\n",
 "eval₂_hom_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval₂_hom_C (f : «expr →+* » R S₁) (g : σ → S₁) (r : R) : eval₂Hom f g (C r) = f r :=\n  eval₂_C f g r\n#align eval₂_hom_C eval₂_hom_C\n\n",
 "eval₂_eta":
 "@[simp]\ntheorem eval₂_eta (p : MvPolynomial σ R) : eval₂ C X p = p := by\n  apply MvPolynomial.induction_on p <;> simp (config := { contextual := true }) [eval₂_add, eval₂_mul]\n#align eval₂_eta eval₂_eta\n\n",
 "eval₂_eq_eval_map":
 "theorem eval₂_eq_eval_map (g : σ → S₁) (p : MvPolynomial σ R) : p.eval₂ f g = eval g (map f p) :=\n  by\n  unfold map eval; simp only [coe_eval₂_hom]\n  have h := eval₂_comp_left (eval₂_hom _ g)\n  dsimp at h\n  rw [h]\n  congr\n  · ext1 a\n    simp only [coe_eval₂_hom, RingHom.id_apply, comp_app, eval₂_C, RingHom.coe_comp]\n  · ext1 n\n    simp only [comp_app, eval₂_X]\n#align eval₂_eq_eval_map eval₂_eq_eval_map\n\n",
 "eval₂_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem eval₂_eq' [Fintype σ] (g : «expr →+* » R S₁) (x : σ → S₁) (f : MvPolynomial σ R) :\n    f.eval₂ g x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.support\n        (g (f.coeff d) *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (x i ^ d i)) :=\n  by\n  simp only [eval₂_eq, ← Finsupp.prod_pow]\n  rfl\n#align eval₂_eq' eval₂_eq'\n\n",
 "eval₂_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem eval₂_eq (g : «expr →+* » R S₁) (x : σ → S₁) (f : MvPolynomial σ R) :\n    f.eval₂ g x =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.support\n        (g (f.coeff d) *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" d.support\n            (x i ^ d i)) :=\n  rfl\n#align eval₂_eq eval₂_eq\n\n",
 "eval₂_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem eval₂_congr (g₁ g₂ : σ → S₁) (h : ∀ {i : σ} {c : «expr →₀ » σ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :\n    p.eval₂ f g₁ = p.eval₂ f g₂ := by\n  apply Finset.sum_congr rfl\n  intro c hc; dsimp; congr 1\n  apply Finset.prod_congr rfl\n  intro i hi; dsimp; congr 1\n  apply h hi\n  rwa [Finsupp.mem_support_iff] at hc\n#align eval₂_congr eval₂_congr\n\n",
 "eval₂_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_comp_right {S₂} [CommSemiring S₂] (k : «expr →+* » S₁ S₂) (f : «expr →+* » R S₁) (g : σ → S₁) (p) :\n    k (eval₂ f g p) = eval₂ k (k ∘ g) (map f p) :=\n  by\n  apply MvPolynomial.induction_on p\n  · intro r\n    rw [eval₂_C, map_C, eval₂_C]\n  · intro p q hp hq\n    rw [eval₂_add, k.map_add, (map f).map_add, eval₂_add, hp, hq]\n  · intro p s hp\n    rw [eval₂_mul, k.map_mul, (map f).map_mul, eval₂_mul, map_X, hp, eval₂_X, eval₂_X]\n#align eval₂_comp_right eval₂_comp_right\n\n",
 "eval₂_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_comp_left {S₂} [CommSemiring S₂] (k : «expr →+* » S₁ S₂) (f : «expr →+* » R S₁) (g : σ → S₁) (p) :\n    k (eval₂ f g p) = eval₂ (k.comp f) (k ∘ g) p := by\n  apply MvPolynomial.induction_on p <;>\n    simp (config := { contextual := true }) [eval₂_add, k.map_add, eval₂_mul, k.map_mul]\n#align eval₂_comp_left eval₂_comp_left\n\n",
 "eval₂_assoc":
 "theorem eval₂_assoc (q : S₂ → MvPolynomial σ R) (p : MvPolynomial S₂ R) :\n    eval₂ f (fun t => eval₂ f g (q t)) p = eval₂ f g (eval₂ C q p) :=\n  by\n  show _ = eval₂_hom f g (eval₂ C q p)\n  rw [eval₂_comp_left (eval₂_hom f g)]; congr with a; simp\n#align eval₂_assoc eval₂_assoc\n\n",
 "eval₂_add":
 "@[simp]\ntheorem eval₂_add : (p + q).eval₂ f g = p.eval₂ f g + q.eval₂ f g :=\n  Finsupp.sum_add_index (by simp [f.map_zero]) (by simp [add_mul, f.map_add])\n#align eval₂_add eval₂_add\n\n",
 "eval₂_X":
 "@[simp]\ntheorem eval₂_X (n) : (X n).eval₂ f g = g n := by simp [eval₂_monomial, f.map_one, X, prod_single_index, pow_one]\n#align eval₂_X eval₂_X\n\n",
 "eval₂_C":
 "@[simp]\ntheorem eval₂_C (a) : (C a).eval₂ f g = f a := by rw [C_apply, eval₂_monomial, prod_zero_index, mul_one]\n#align eval₂_C eval₂_C\n\n",
 "eval_zero'":
 "@[simp]\ntheorem eval_zero' : eval (fun _ => 0 : σ → R) = constantCoeff :=\n  eval₂Hom_zero _\n#align eval_zero' eval_zero'\n\n",
 "eval_zero":
 "@[simp]\ntheorem eval_zero : eval (0 : σ → R) = constantCoeff :=\n  eval₂Hom_zero _\n#align eval_zero eval_zero\n\n",
 "eval_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem eval_sum {ι : Type _} (s : Finset ι) (f : ι → MvPolynomial σ R) (g : σ → R) :\n    eval g (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (eval g (f i)) :=\n  (eval g).map_sum _ _\n#align eval_sum eval_sum\n\n",
 "eval_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem eval_prod {ι : Type _} (s : Finset ι) (f : ι → MvPolynomial σ R) (g : σ → R) :\n    eval g (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (eval g (f i)) :=\n  (eval g).map_prod _ _\n#align eval_prod eval_prod\n\n",
 "eval_monomial":
 "theorem eval_monomial : eval f (monomial s a) = a * s.prod fun n e => f n ^ e :=\n  eval₂_monomial _ _\n#align eval_monomial eval_monomial\n\n",
 "eval_mem":
 "theorem eval_mem {p : MvPolynomial σ S} {s : subS} (hs : ∀ i ∈ p.support, p.coeff i ∈ s) {v : σ → S}\n    (hv : ∀ i, v i ∈ s) : MvPolynomial.eval v p ∈ s :=\n  eval₂_mem hs hv\n#align eval_mem eval_mem\n\n",
 "eval_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem eval_map (f : «expr →+* » R S₁) (g : σ → S₁) (p : MvPolynomial σ R) : eval g (map f p) = eval₂ f g p := by\n  apply MvPolynomial.induction_on p <;> · simp (config := { contextual := true })\n#align eval_map eval_map\n\n",
 "eval_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval_eval₂ {τ : Type _} (f : «expr →+* » R (MvPolynomial τ S₁)) (g : σ → MvPolynomial τ S₁)\n    (p : MvPolynomial σ R) (x : τ → S₁) : eval x (eval₂ f g p) = eval₂ ((eval x).comp f) (fun s => eval x (g s)) p :=\n  by\n  apply induction_on p\n  · simp\n  · intro p q hp hq\n    simp [hp, hq]\n  · intro p n hp\n    simp [hp]\n#align eval_eval₂ eval_eval₂\n\n",
 "eval_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem eval_eq' [Fintype σ] (x : σ → R) (f : MvPolynomial σ R) :\n    eval x f =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.support\n        (f.coeff d *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (x i ^ d i)) :=\n  eval₂_eq' (RingHom.id R) x f\n#align eval_eq' eval_eq'\n\n",
 "eval_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem eval_eq (x : σ → R) (f : MvPolynomial σ R) :\n    eval x f =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.support\n        (f.coeff d *\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" d.support\n            (x i ^ d i)) :=\n  rfl\n#align eval_eq eval_eq\n\n",
 "eval_assoc":
 "theorem eval_assoc {τ} (f : σ → MvPolynomial τ R) (g : τ → R) (p : MvPolynomial σ R) :\n    eval (eval g ∘ f) p = eval g (eval₂ C f p) :=\n  by\n  rw [eval₂_comp_left (eval g)]\n  unfold eval; simp only [coe_eval₂_hom]\n  congr with a; simp\n#align eval_assoc eval_assoc\n\n",
 "eval_X":
 "@[simp]\ntheorem eval_X : ∀ n, eval f (X n) = f n :=\n  eval₂_X _ _\n#align eval_X eval_X\n\n",
 "eval_C":
 "@[simp]\ntheorem eval_C : ∀ a, eval f (C a) = a :=\n  eval₂_C _ _\n#align eval_C eval_C\n\n",
 "eq_zero_iff":
 "theorem eq_zero_iff {p : MvPolynomial σ R} : p = 0 ↔ ∀ d, coeff d p = 0 :=\n  by\n  rw [ext_iff]\n  simp only [coeff_zero]\n#align eq_zero_iff eq_zero_iff\n\n",
 "constant_coeff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem constant_coeff_smul {R : Type _} [SMulZeroClass R S₁] (a : R) (f : MvPolynomial σ S₁) :\n    constantCoeff («expr • » a f) = «expr • » a (constantCoeff f) :=\n  rfl\n#align constant_coeff_smul constant_coeff_smul\n\n",
 "constant_coeff_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem constant_coeff_monomial [DecidableEq σ] (d : «expr →₀ » σ ℕ) (r : R) :\n    constantCoeff (monomial d r) = if d = 0 then r else 0 := by rw [constant_coeff_eq, coeff_monomial]\n#align constant_coeff_monomial constant_coeff_monomial\n\n",
 "constant_coeff_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem constant_coeff_map (f : «expr →+* » R S₁) (φ : MvPolynomial σ R) :\n    constantCoeff (MvPolynomial.map f φ) = f (constantCoeff φ) :=\n  coeff_map f φ 0\n#align constant_coeff_map constant_coeff_map\n\n",
 "constant_coeff_eq":
 "theorem constant_coeff_eq : (constantCoeff : MvPolynomial σ R → R) = coeff 0 :=\n  rfl\n#align constant_coeff_eq constant_coeff_eq\n\n",
 "constant_coeff_comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem constant_coeff_comp_map (f : «expr →+* » R S₁) :\n    (constantCoeff : «expr →+* » (MvPolynomial σ S₁) S₁).comp (MvPolynomial.map f) = f.comp constantCoeff := by\n  ext <;> simp\n#align constant_coeff_comp_map constant_coeff_comp_map\n\n",
 "constant_coeff_comp_algebra_map":
 "@[simp]\ntheorem constant_coeff_comp_algebra_map : constantCoeff.comp (algebraMap R (MvPolynomial σ R)) = RingHom.id R :=\n  constantCoeff_comp_C _ _\n#align constant_coeff_comp_algebra_map constant_coeff_comp_algebra_map\n\n",
 "constant_coeff_comp_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem constant_coeff_comp_C : constantCoeff.comp (C : «expr →+* » R (MvPolynomial σ R)) = RingHom.id R :=\n  by\n  ext x\n  exact constant_coeff_C σ x\n#align constant_coeff_comp_C constant_coeff_comp_C\n\n",
 "constant_coeff_X":
 "@[simp]\ntheorem constant_coeff_X (i : σ) : constantCoeff (X i : MvPolynomial σ R) = 0 := by simp [constant_coeff_eq]\n#align constant_coeff_X constant_coeff_X\n\n",
 "constant_coeff_C":
 "@[simp]\ntheorem constant_coeff_C (r : R) : constantCoeff (C r : MvPolynomial σ R) = r := by simp [constant_coeff_eq]\n#align constant_coeff_C constant_coeff_C\n\n",
 "comp_eval₂_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem comp_eval₂_hom [CommSemiring S₂] (f : «expr →+* » R S₁) (g : σ → S₁) (φ : «expr →+* » S₁ S₂) :\n    φ.comp (eval₂Hom f g) = eval₂Hom (φ.comp f) fun i => φ (g i) :=\n  by\n  apply MvPolynomial.ringHom_ext\n  · intro r\n    rw [RingHom.comp_apply, eval₂_hom_C, eval₂_hom_C, RingHom.comp_apply]\n  · intro i\n    rw [RingHom.comp_apply, eval₂_hom_X', eval₂_hom_X']\n#align comp_eval₂_hom comp_eval₂_hom\n\n",
 "comp_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp_aeval {B : Type _} [CommSemiring B] [Algebra R B] (φ : «expr →ₐ[ ] » S₁ R B) :\n    φ.comp (aeval f) = aeval fun i => φ (f i) := by\n  ext i\n  simp\n#align comp_aeval comp_aeval\n\n",
 "coeff_zero_one":
 "@[simp]\ntheorem coeff_zero_one : coeff 0 (1 : MvPolynomial σ R) = 1 :=\n  coeff_zero_C 1\n#align coeff_zero_one coeff_zero_one\n\n",
 "coeff_zero_X":
 "@[simp]\ntheorem coeff_zero_X (i : σ) : coeff 0 (X i : MvPolynomial σ R) = 0 :=\n  single_eq_of_ne fun h => by cases single_eq_zero.1 h\n#align coeff_zero_X coeff_zero_X\n\n",
 "coeff_zero_C":
 "@[simp]\ntheorem coeff_zero_C (a) : coeff 0 (C a : MvPolynomial σ R) = a :=\n  single_eq_same\n#align coeff_zero_C coeff_zero_C\n\n",
 "coeff_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeff_zero (m : «expr →₀ » σ ℕ) : coeff m (0 : MvPolynomial σ R) = 0 :=\n  rfl\n#align coeff_zero coeff_zero\n\n",
 "coeff_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem coeff_sum {X : Type _} (s : Finset X) (f : X → MvPolynomial σ R) (m : «expr →₀ » σ ℕ) :\n    coeff m (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (coeff m (f x)) :=\n  (@coeffAddMonoidHom R σ _ _).map_sum _ s\n#align coeff_sum coeff_sum\n\n",
 "coeff_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coeff_smul {S₁ : Type _} [SMulZeroClass S₁ R] (m : «expr →₀ » σ ℕ) (c : S₁) (p : MvPolynomial σ R) :\n    coeff m («expr • » c p) = «expr • » c (coeff m p) :=\n  smul_apply c p m\n#align coeff_smul coeff_smul\n\n",
 "coeff_one":
 "theorem coeff_one [DecidableEq σ] (m) : coeff m (1 : MvPolynomial σ R) = if 0 = m then 1 else 0 :=\n  coeff_C m 1\n#align coeff_one coeff_one\n\n",
 "coeff_mul_monomial'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coeff_mul_monomial' (m) (s : «expr →₀ » σ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff m (p * monomial s r) = if s ≤ m then coeff (m - s) p * r else 0 :=\n  by\n  obtain rfl | hr := eq_or_ne r 0\n  · simp only [monomial_zero, coeff_zero, MulZeroClass.mul_zero, if_t_t]\n  haveI : Nontrivial R := nontrivial_of_ne _ _ hr\n  split_ifs with h h\n  · conv_rhs => rw [← coeff_mul_monomial _ s]\n    congr with t\n    rw [tsub_add_cancel_of_le h]\n  · rw [← not_mem_support_iff]\n    intro hm\n    apply h\n    have H := support_mul _ _ hm\n    simp only [Finset.mem_bunionᵢ] at H\n    rcases H with ⟨j, hj, i', hi', H⟩\n    rw [support_monomial, if_neg hr, Finset.mem_singleton] at hi'\n    subst i'\n    rw [Finset.mem_singleton] at H\n    subst m\n    exact le_add_left le_rfl\n#align coeff_mul_monomial' coeff_mul_monomial'\n\n",
 "coeff_mul_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeff_mul_monomial (m) (s : «expr →₀ » σ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff (m + s) (p * monomial s r) = coeff m p * r :=\n  AddMonoidAlgebra.mul_single_apply_aux p _ _ _ _ fun a => add_left_inj _\n#align coeff_mul_monomial coeff_mul_monomial\n\n",
 "coeff_mul_X'":
 "theorem coeff_mul_X' [DecidableEq σ] (m) (s : σ) (p : MvPolynomial σ R) :\n    coeff m (p * X s) = if s ∈ m.support then coeff (m - single s 1) p else 0 :=\n  by\n  refine' (coeff_mul_monomial' _ _ _ _).trans _\n  simp_rw [Finsupp.single_le_iff, Finsupp.mem_support_iff, Nat.succ_le_iff, pos_iff_ne_zero, mul_one]\n#align coeff_mul_X' coeff_mul_X'\n\n",
 "coeff_mul_X":
 "@[simp]\ntheorem coeff_mul_X (m) (s : σ) (p : MvPolynomial σ R) : coeff (m + single s 1) (p * X s) = coeff m p :=\n  (coeff_mul_monomial _ _ _ _).trans (mul_one _)\n#align coeff_mul_X coeff_mul_X\n\n",
 "coeff_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem coeff_mul (p q : MvPolynomial σ R) (n : «expr →₀ » σ ℕ) :\n    coeff n (p * q) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (antidiagonal n)\n        (coeff x.1 p * coeff x.2 q) :=\n  AddMonoidAlgebra.mul_apply_antidiagonal p q _ _ fun p => mem_antidiagonal\n#align coeff_mul coeff_mul\n\n",
 "coeff_monomial_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coeff_monomial_mul' (m) (s : «expr →₀ » σ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff m (monomial s r * p) = if s ≤ m then r * coeff (m - s) p else 0 :=\n  by\n  -- note that if we allow `R` to be non-commutative we will have to duplicate the proof above.\n  rw [mul_comm, mul_comm r]\n  exact coeff_mul_monomial' _ _ _ _\n#align coeff_monomial_mul' coeff_monomial_mul'\n\n",
 "coeff_monomial_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeff_monomial_mul (m) (s : «expr →₀ » σ ℕ) (r : R) (p : MvPolynomial σ R) :\n    coeff (s + m) (monomial s r * p) = r * coeff m p :=\n  AddMonoidAlgebra.single_mul_apply_aux p _ _ _ _ fun a => add_right_inj _\n#align coeff_monomial_mul coeff_monomial_mul\n\n",
 "coeff_monomial":
 "@[simp]\ntheorem coeff_monomial [DecidableEq σ] (m n) (a) : coeff m (monomial n a : MvPolynomial σ R) = if n = m then a else 0 :=\n  single_apply\n#align coeff_monomial coeff_monomial\n\n",
 "coeff_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coeff_map (p : MvPolynomial σ R) : ∀ m : «expr →₀ » σ ℕ, coeff m (map f p) = f (coeff m p) :=\n  by\n  apply MvPolynomial.induction_on p <;> clear p\n  · intro r m\n    rw [map_C]\n    simp only [coeff_C]\n    split_ifs\n    · rfl\n    rw [f.map_zero]\n  · intro p q hp hq m\n    simp only [hp, hq, (map f).map_add, coeff_add]\n    rw [f.map_add]\n  · intro p i hp m\n    simp only [hp, (map f).map_mul, map_X]\n    simp only [hp, mem_support_iff, coeff_mul_X']\n    split_ifs\n    · rfl\n    rw [f.map_zero]\n#align coeff_map coeff_map\n\n",
 "coeff_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeff_add (m : «expr →₀ » σ ℕ) (p q : MvPolynomial σ R) : coeff m (p + q) = coeff m p + coeff m q :=\n  add_apply p q m\n#align coeff_add coeff_add\n\n",
 "coeff_X_pow":
 "theorem coeff_X_pow [DecidableEq σ] (i : σ) (m) (k : ℕ) :\n    coeff m (X i ^ k : MvPolynomial σ R) = if single i k = m then 1 else 0 :=\n  by\n  have := coeff_monomial m (Finsupp.single i k) (1 : R)\n  rwa [@monomial_eq _ _ (1 : R) (Finsupp.single i k) _, C_1, one_mul, Finsupp.prod_single_index] at this\n  exact pow_zero _\n#align coeff_X_pow coeff_X_pow\n\n",
 "coeff_X_mul'":
 "theorem coeff_X_mul' [DecidableEq σ] (m) (s : σ) (p : MvPolynomial σ R) :\n    coeff m (X s * p) = if s ∈ m.support then coeff (m - single s 1) p else 0 :=\n  by\n  refine' (coeff_monomial_mul' _ _ _ _).trans _\n  simp_rw [Finsupp.single_le_iff, Finsupp.mem_support_iff, Nat.succ_le_iff, pos_iff_ne_zero, one_mul]\n#align coeff_X_mul' coeff_X_mul'\n\n",
 "coeff_X_mul":
 "@[simp]\ntheorem coeff_X_mul (m) (s : σ) (p : MvPolynomial σ R) : coeff (single s 1 + m) (X s * p) = coeff m p :=\n  (coeff_monomial_mul _ _ _ _).trans (one_mul _)\n#align coeff_X_mul coeff_X_mul\n\n",
 "coeff_X'":
 "theorem coeff_X' [DecidableEq σ] (i : σ) (m) : coeff m (X i : MvPolynomial σ R) = if single i 1 = m then 1 else 0 := by\n  rw [← coeff_X_pow, pow_one]\n#align coeff_X' coeff_X'\n\n",
 "coeff_X":
 "@[simp]\ntheorem coeff_X (i : σ) : coeff (single i 1) (X i : MvPolynomial σ R) = 1 := by rw [coeff_X', if_pos rfl]\n#align coeff_X coeff_X\n\n",
 "coeff_C_mul":
 "@[simp]\ntheorem coeff_C_mul (m) (a : R) (p : MvPolynomial σ R) : coeff m (C a * p) = a * coeff m p :=\n  by\n  rw [mul_def, sum_C]\n  · simp (config := { contextual := true }) [sum_def, coeff_sum]\n  simp\n#align coeff_C_mul coeff_C_mul\n\n",
 "coeff_C":
 "@[simp]\ntheorem coeff_C [DecidableEq σ] (m) (a) : coeff m (C a : MvPolynomial σ R) = if 0 = m then a else 0 :=\n  single_apply\n#align coeff_C coeff_C\n\n",
 "coe_eval₂_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_eval₂_hom (f : «expr →+* » R S₁) (g : σ → S₁) : «expr⇑ » (eval₂Hom f g) = eval₂ f g :=\n  rfl\n#align coe_eval₂_hom coe_eval₂_hom\n\n",
 "as_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem as_sum (p : MvPolynomial σ R) :\n    p =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" p.support\n        (monomial v (coeff v p)) :=\n  (support_sum_monomial_coeff p).symm\n#align as_sum as_sum\n\n",
 "algebra_map_eq":
 "theorem algebra_map_eq : algebraMap R (MvPolynomial σ R) = C :=\n  rfl\n#align algebra_map_eq algebra_map_eq\n\n",
 "algebraMap_apply":
 "#print algebraMap_apply /-\ntheorem algebraMap_apply (r : R) : algebraMap R (MvPolynomial σ S₁) r = C (algebraMap R S₁ r) :=\n  rfl\n#align algebra_map_apply algebraMap_apply\n-/\n\n",
 "alg_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[ext]\ntheorem alg_hom_ext' {A B : Type _} [CommSemiring A] [CommSemiring B] [Algebra R A] [Algebra R B]\n    {f g : «expr →ₐ[ ] » (MvPolynomial σ A) R B}\n    (h₁ :\n      f.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)) = g.comp (IsScalarTower.toAlgHom R A (MvPolynomial σ A)))\n    (h₂ : ∀ i, f (X i) = g (X i)) : f = g :=\n  AlgHom.coe_ringHom_injective (MvPolynomial.ringHom_ext' (congr_arg alg_hom.to_ring_hom h₁) h₂)\n#align alg_hom_ext' alg_hom_ext'\n\n",
 "alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[ext]\ntheorem alg_hom_ext {A : Type _} [Semiring A] [Algebra R A] {f g : «expr →ₐ[ ] » (MvPolynomial σ R) R A}\n    (hf : ∀ i : σ, f (X i) = g (X i)) : f = g :=\n  AddMonoidAlgebra.algHom_ext' (mulHom_ext' fun x : σ => MonoidHom.ext_mnat (hf x))\n#align alg_hom_ext alg_hom_ext\n\n",
 "alg_hom_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem alg_hom_C (f : «expr →ₐ[ ] » (MvPolynomial σ R) R (MvPolynomial σ R)) (r : R) : f (C r) = C r :=\n  f.commutes r\n#align alg_hom_C alg_hom_C\n\n",
 "aeval_zero'":
 "@[simp]\ntheorem aeval_zero' (p : MvPolynomial σ R) : aeval (fun _ => 0 : σ → S₁) p = algebraMap _ _ (constantCoeff p) :=\n  aeval_zero p\n#align aeval_zero' aeval_zero'\n\n",
 "aeval_zero":
 "@[simp]\ntheorem aeval_zero (p : MvPolynomial σ R) : aeval (0 : σ → S₁) p = algebraMap _ _ (constantCoeff p) :=\n  eval₂Hom_zero_apply (algebraMap R S₁) p\n#align aeval_zero aeval_zero\n\n",
 "aeval_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem aeval_unique (φ : «expr →ₐ[ ] » (MvPolynomial σ R) R S₁) : φ = aeval (φ ∘ X) :=\n  by\n  ext i\n  simp\n#align aeval_unique aeval_unique\n\n",
 "aeval_tower_to_alg_hom":
 "theorem aeval_tower_to_alg_hom (x : R) : aevalTower g y (IsScalarTower.toAlgHom S R (MvPolynomial σ R) x) = g x :=\n  aevalTower_algebraMap _ _ _\n#align aeval_tower_to_alg_hom aeval_tower_to_alg_hom\n\n",
 "aeval_tower_of_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem aeval_tower_of_id : aevalTower (Algebra.ofId S A) = (aeval : (σ → A) → «expr →ₐ[ ] » (MvPolynomial σ S) S A) :=\n  by\n  ext\n  simp only [aeval_X, aeval_tower_X]\n#align aeval_tower_of_id aeval_tower_of_id\n\n",
 "aeval_tower_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem aeval_tower_id : aevalTower (AlgHom.id S S) = (aeval : (σ → S) → «expr →ₐ[ ] » (MvPolynomial σ S) S S) :=\n  by\n  ext\n  simp only [aeval_tower_X, aeval_X]\n#align aeval_tower_id aeval_tower_id\n\n",
 "aeval_tower_comp_to_alg_hom":
 "@[simp]\ntheorem aeval_tower_comp_to_alg_hom : (aevalTower g y).comp (IsScalarTower.toAlgHom S R (MvPolynomial σ R)) = g :=\n  AlgHom.coe_ringHom_injective <| aevalTower_comp_algebraMap _ _\n#align aeval_tower_comp_to_alg_hom aeval_tower_comp_to_alg_hom\n\n",
 "aeval_tower_comp_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem aeval_tower_comp_algebra_map :\n    (aevalTower g y : «expr →+* » (MvPolynomial σ R) A).comp (algebraMap R (MvPolynomial σ R)) = g :=\n  aevalTower_comp_C _ _\n#align aeval_tower_comp_algebra_map aeval_tower_comp_algebra_map\n\n",
 "aeval_tower_comp_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem aeval_tower_comp_C : (aevalTower g y : «expr →+* » (MvPolynomial σ R) A).comp C = g :=\n  RingHom.ext <| aevalTower_C _ _\n#align aeval_tower_comp_C aeval_tower_comp_C\n\n",
 "aeval_tower_algebra_map":
 "@[simp]\ntheorem aeval_tower_algebra_map (x : R) : aevalTower g y (algebraMap R (MvPolynomial σ R) x) = g x :=\n  eval₂_C _ _ _\n#align aeval_tower_algebra_map aeval_tower_algebra_map\n\n",
 "aeval_tower_X":
 "@[simp]\ntheorem aeval_tower_X (i : σ) : aevalTower g y (X i) = y i :=\n  eval₂_X _ _ _\n#align aeval_tower_X aeval_tower_X\n\n",
 "aeval_tower_C":
 "@[simp]\ntheorem aeval_tower_C (x : R) : aevalTower g y (C x) = g x :=\n  eval₂_C _ _ _\n#align aeval_tower_C aeval_tower_C\n\n",
 "aeval_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem aeval_sum {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) :\n    aeval f (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (φ i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (aeval f (φ i)) :=\n  (MvPolynomial.aeval f).map_sum _ _\n#align aeval_sum aeval_sum\n\n",
 "aeval_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem aeval_prod {ι : Type _} (s : Finset ι) (φ : ι → MvPolynomial σ R) :\n    aeval f\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (φ i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (aeval f (φ i)) :=\n  (MvPolynomial.aeval f).map_prod _ _\n#align aeval_prod aeval_prod\n\n",
 "aeval_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem aeval_monomial (g : σ → S₁) (d : «expr →₀ » σ ℕ) (r : R) :\n    aeval g (monomial d r) = algebraMap _ _ r * d.prod fun i k => g i ^ k :=\n  eval₂Hom_monomial _ _ _ _\n#align aeval_monomial aeval_monomial\n\n",
 "aeval_eq_zero":
 "theorem aeval_eq_zero [Algebra R S₂] (f : σ → S₂) (φ : MvPolynomial σ R)\n    (h : ∀ d, φ.coeff d ≠ 0 → ∃ i ∈ d.support, f i = 0) : aeval f φ = 0 :=\n  eval₂Hom_eq_zero _ _ _ h\n#align aeval_eq_zero aeval_eq_zero\n\n",
 "aeval_eq_eval₂_hom":
 "theorem aeval_eq_eval₂_hom (p : MvPolynomial σ R) : aeval f p = eval₂Hom (algebraMap R S₁) f p :=\n  rfl\n#align aeval_eq_eval₂_hom aeval_eq_eval₂_hom\n\n",
 "aeval_def":
 "theorem aeval_def (p : MvPolynomial σ R) : aeval f p = eval₂ (algebraMap R S₁) f p :=\n  rfl\n#align aeval_def aeval_def\n\n",
 "aeval_X_left_apply":
 "theorem aeval_X_left_apply (p : MvPolynomial σ R) : aeval X p = p :=\n  AlgHom.congr_fun aeval_X_left p\n#align aeval_X_left_apply aeval_X_left_apply\n\n",
 "aeval_X_left":
 "theorem aeval_X_left : aeval X = AlgHom.id R (MvPolynomial σ R) :=\n  (aeval_unique (AlgHom.id R _)).symm\n#align aeval_X_left aeval_X_left\n\n",
 "aeval_X":
 "@[simp]\ntheorem aeval_X (s : σ) : aeval f (X s : MvPolynomial _ R) = f s :=\n  eval₂_X _ _ _\n#align aeval_X aeval_X\n\n",
 "aeval_C":
 "@[simp]\ntheorem aeval_C (r : R) : aeval f (C r) = algebraMap R S₁ r :=\n  eval₂_C _ _ _\n#align aeval_C aeval_C\n\n",
 "adjoin_range_eq_range_aeval":
 "#print Algebra.adjoin_range_eq_range_aeval /-\ntheorem Algebra.adjoin_range_eq_range_aeval : Algebra.adjoin R (Set.range f) = (MvPolynomial.aeval f).range := by\n  simp only [← Algebra.map_top, ← MvPolynomial.adjoin_range_X, AlgHom.map_adjoin, ← Set.range_comp, (· ∘ ·),\n    MvPolynomial.aeval_X]\n#align algebra.adjoin_range_eq_range_aeval Algebra.adjoin_range_eq_range_aeval\n-/\n\n",
 "adjoin_range_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem adjoin_range_X : Algebra.adjoin R (range (X : σ → MvPolynomial σ R)) = «expr⊤» :=\n  by\n  set S := Algebra.adjoin R (range (X : σ → MvPolynomial σ R))\n  refine' top_unique fun p hp => _; clear hp\n  induction p using MvPolynomial.induction_on\n  case h_C => exact S.algebra_map_mem _\n  case h_add p q hp hq => exact S.add_mem hp hq\n  case h_X p i hp => exact S.mul_mem hp (Algebra.subset_adjoin <| mem_range_self _)\n#align adjoin_range_X adjoin_range_X\n\n",
 "adjoin_eq_range":
 "#print Algebra.adjoin_eq_range /-\ntheorem Algebra.adjoin_eq_range (s : Set S₁) : Algebra.adjoin R s = (MvPolynomial.aeval (coe : s → S₁)).range := by\n  rw [← Algebra.adjoin_range_eq_range_aeval, Subtype.range_coe]\n#align algebra.adjoin_eq_range Algebra.adjoin_eq_range\n-/\n\n",
 "X_pow_eq_monomial":
 "theorem X_pow_eq_monomial : X n ^ e = monomial (single n e) (1 : R) := by simp [X, monomial_pow]\n#align X_pow_eq_monomial X_pow_eq_monomial\n\n",
 "X_injective":
 "theorem X_injective [Nontrivial R] : function.injective (X : σ → MvPolynomial σ R) :=\n  (monomial_left_injective one_ne_zero).comp (Finsupp.single_left_injective one_ne_zero)\n#align X_injective X_injective\n\n",
 "X_inj":
 "@[simp]\ntheorem X_inj [Nontrivial R] (m n : σ) : X m = (X n : MvPolynomial σ R) ↔ m = n :=\n  X_injective.eq_iff\n#align X_inj X_inj\n\n",
 "C_surjective":
 "theorem C_surjective {R : Type _} [CommSemiring R] (σ : Type _) [IsEmpty σ] :\n    function.surjective (C : R → MvPolynomial σ R) :=\n  by\n  refine' fun p => ⟨p.to_fun 0, Finsupp.ext fun a => _⟩\n  simpa [(Finsupp.ext isEmptyElim : a = 0), C_apply, monomial]\n#align C_surjective C_surjective\n\n",
 "C_pow":
 "@[simp]\ntheorem C_pow (a : R) (n : ℕ) : (C (a ^ n) : MvPolynomial σ R) = C a ^ n := by induction n <;> simp [pow_succ, *]\n#align C_pow C_pow\n\n",
 "C_mul_monomial":
 "theorem C_mul_monomial : C a * monomial s a' = monomial s (a * a') := by simp [C_apply, monomial, single_mul_single]\n#align C_mul_monomial C_mul_monomial\n\n",
 "C_mul_X_pow_eq_monomial":
 "theorem C_mul_X_pow_eq_monomial {s : σ} {a : R} {n : ℕ} : C a * X s ^ n = monomial (single s n) a := by\n  rw [← zero_add (single s n), monomial_add_single, C_apply]\n#align C_mul_X_pow_eq_monomial C_mul_X_pow_eq_monomial\n\n",
 "C_mul_X_eq_monomial":
 "theorem C_mul_X_eq_monomial {s : σ} {a : R} : C a * X s = monomial (single s 1) a := by\n  rw [← C_mul_X_pow_eq_monomial, pow_one]\n#align C_mul_X_eq_monomial C_mul_X_eq_monomial\n\n",
 "C_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem C_mul' : MvPolynomial.C a * p = «expr • » a p :=\n  (Algebra.smul_def a p).symm\n#align C_mul' C_mul'\n\n",
 "C_mul":
 "@[simp]\ntheorem C_mul : (C (a * a') : MvPolynomial σ R) = C a * C a' :=\n  C_mul_monomial.symm\n#align C_mul C_mul\n\n",
 "C_injective":
 "theorem C_injective (σ : Type _) (R : Type _) [CommSemiring R] : function.injective (C : R → MvPolynomial σ R) :=\n  Finsupp.single_injective _\n#align C_injective C_injective\n\n",
 "C_inj":
 "@[simp]\ntheorem C_inj {σ : Type _} (R : Type _) [CommSemiring R] (r s : R) : (C r : MvPolynomial σ R) = C s ↔ r = s :=\n  (C_injective σ R).eq_iff\n#align C_inj C_inj\n\n",
 "C_eq_smul_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem C_eq_smul_one : (C a : MvPolynomial σ R) = «expr • » a 1 := by rw [← C_mul', mul_one]\n#align C_eq_smul_one C_eq_smul_one\n\n",
 "C_eq_coe_nat":
 "theorem C_eq_coe_nat (n : ℕ) : (C ↑n : MvPolynomial σ R) = n := by induction n <;> simp [nat.succ_eq_add_one, *]\n#align C_eq_coe_nat C_eq_coe_nat\n\n",
 "C_dvd_iff_map_hom_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem C_dvd_iff_map_hom_eq_zero (q : «expr →+* » R S₁) (r : R) (hr : ∀ r' : R, q r' = 0 ↔ r ∣ r')\n    (φ : MvPolynomial σ R) : C r ∣ φ ↔ map q φ = 0 :=\n  by\n  rw [C_dvd_iff_dvd_coeff, MvPolynomial.ext_iff]\n  simp only [coeff_map, coeff_zero, hr]\n#align C_dvd_iff_map_hom_eq_zero C_dvd_iff_map_hom_eq_zero\n\n",
 "C_dvd_iff_dvd_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem C_dvd_iff_dvd_coeff (r : R) (φ : MvPolynomial σ R) : C r ∣ φ ↔ ∀ i, r ∣ φ.coeff i :=\n  by\n  constructor\n  · rintro ⟨φ, rfl⟩ c\n    rw [coeff_C_mul]\n    apply dvd_mul_right\n  · intro h\n    choose c hc using h\n    classical\n      let c' : «expr →₀ » σ ℕ → R := fun i => if i ∈ φ.support then c i else 0\n      let ψ : MvPolynomial σ R :=\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" φ.support\n          (monomial i (c' i))\n      use ψ\n      apply MvPolynomial.ext\n      intro i\n      simp only [coeff_C_mul, coeff_sum, coeff_monomial, Finset.sum_ite_eq', c']\n      split_ifs with hi hi\n      · rw [hc]\n      · rw [not_mem_support_iff] at hi\n        rwa [MulZeroClass.mul_zero]\n#align C_dvd_iff_dvd_coeff C_dvd_iff_dvd_coeff\n\n",
 "C_apply":
 "theorem C_apply : (C a : MvPolynomial σ R) = monomial 0 a :=\n  rfl\n#align C_apply C_apply\n\n",
 "C_add":
 "@[simp]\ntheorem C_add : (C (a + a') : MvPolynomial σ R) = C a + C a' :=\n  single_add _ _ _\n#align C_add C_add\n\n",
 "C_1":
 "@[simp]\ntheorem C_1 : C 1 = (1 : MvPolynomial σ R) :=\n  rfl\n#align C_1 C_1\n\n",
 "C_0":
 "@[simp]\ntheorem C_0 : C 0 = (0 : MvPolynomial σ R) := by simp [C_apply, monomial]\n#align C_0 C_0\n\n"}