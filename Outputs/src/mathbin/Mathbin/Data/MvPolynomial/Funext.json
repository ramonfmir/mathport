{"funext_iff":
 "theorem funext_iff {σ : Type _} {p q : MvPolynomial σ R} : p = q ↔ ∀ x : σ → R, eval x p = eval x q :=\n  ⟨by rintro rfl <;> simp only [forall_const, eq_self_iff_true], funext⟩\n#align funext_iff funext_iff\n\n",
 "funext_fin":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\nprivate theorem funext_fin {n : ℕ} {p : MvPolynomial (Fin n) R} (h : ∀ x : Fin n → R, eval x p = 0) : p = 0 :=\n  by\n  induction' n with n ih\n  · apply (MvPolynomial.isEmptyRingEquiv R (Fin 0)).injective\n    rw [RingEquiv.map_zero]\n    convert h _\n  · apply (finSuccEquiv R n).injective\n    simp only [AlgEquiv.map_zero]\n    refine' Polynomial.funext fun q => _\n    rw [Polynomial.eval_zero]\n    apply ih fun x => _\n    calc\n      _ = _ := eval_polynomial_eval_fin_succ_equiv p _ _\n      _ = 0 := h _\n      \n#align funext_fin funext_fin\n\n",
 "funext":
 "#print funext /-\n/-- Two multivariate polynomials over an infinite integral domain are equal\nif they are equal upon evaluating them on an arbitrary assignment of the variables. -/\ntheorem funext {σ : Type _} {p q : MvPolynomial σ R} (h : ∀ x : σ → R, eval x p = eval x q) : p = q :=\n  by\n  suffices ∀ p, (∀ x : σ → R, eval x p = 0) → p = 0\n    by\n    rw [← sub_eq_zero, this (p - q)]\n    simp only [h, RingHom.map_sub, forall_const, sub_self]\n  clear h p q\n  intro p h\n  obtain ⟨n, f, hf, p, rfl⟩ := exists_fin_rename p\n  suffices p = 0 by rw [this, AlgHom.map_zero]\n  apply funext_fin\n  intro x\n  classical\n    convert h (Function.extend f x 0)\n    simp only [eval, eval₂_hom_rename, Function.extend_comp hf]\n#align funext funext\n-/\n\n"}