{"funext_iff":
 "theorem funext_iff {σ : Type _} {p q : mv_polynomial σ R} : p = q ↔ ∀ x : σ → R, eval x p = eval x q :=\n  ⟨by rintro rfl <;> simp only [forall_const, eq_self_iff_true], funext⟩\n#align funext_iff funext_iff\n\n",
 "funext_fin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\nprivate theorem funext_fin {n : ℕ} {p : mv_polynomial (fin n) R} (h : ∀ x : fin n → R, eval x p = 0) : p = 0 :=\n  by\n  induction' n with n ih generalizing R\n  · let e := mv_polynomial.is_empty_ring_equiv R (fin 0)\n    apply e.injective\n    rw [RingEquiv.map_zero]\n    convert h finZeroElim\n    suffices\n      (eval₂_hom (RingHom.id _) (is_empty.elim' fin.is_empty)) p =\n        (eval finZeroElim : «expr →+* » (mv_polynomial (fin 0) R) R) p\n      by\n      rw [← this]\n      simp only [coe_eval₂_hom, is_empty_ring_equiv_apply, RingEquiv.trans_apply, aeval_eq_eval₂_hom]\n      congr\n    exact eval₂_hom_congr rfl (subsingleton.elim _ _) rfl\n  · let e := (fin_succ_equiv R n).to_ring_equiv\n    apply e.injective\n    simp only [RingEquiv.map_zero]\n    apply polynomial.funext\n    intro q\n    rw [polynomial.eval_zero]\n    apply ih\n    swap\n    · infer_instance\n    intro x\n    dsimp [e]\n    rw [fin_succ_equiv_apply]\n    calc\n      _ = eval _ p := _\n      _ = 0 := h _\n      \n    · intro i\n      exact Fin.cases (eval x q) x i\n    apply induction_on p\n    · intro r\n      simp only [eval_C, polynomial.eval_C, RingHom.coe_comp, eval₂_hom_C]\n    · intros\n      simp only [*, RingHom.map_add, polynomial.eval_add]\n    · intro φ i hφ\n      simp only [*, eval_X, polynomial.eval_mul, RingHom.map_mul, eval₂_hom_X']\n      congr 1\n      by_cases hi : i = 0\n      · subst hi\n        simp only [polynomial.eval_X, Fin.cases_zero]\n      · rw [← Fin.succ_pred i hi]\n        simp only [eval_X, polynomial.eval_C, Fin.cases_succ]\n    · infer_instance\n#align funext_fin funext_fin\n\n",
 "funext":
 "#print funext /-\n/-- Two multivariate polynomials over an infinite integral domain are equal\nif they are equal upon evaluating them on an arbitrary assignment of the variables. -/\ntheorem funext {σ : Type _} {p q : mv_polynomial σ R} (h : ∀ x : σ → R, eval x p = eval x q) : p = q :=\n  by\n  suffices ∀ p, (∀ x : σ → R, eval x p = 0) → p = 0\n    by\n    rw [← sub_eq_zero, this (p - q)]\n    simp only [h, RingHom.map_sub, forall_const, sub_self]\n  clear h p q\n  intro p h\n  obtain ⟨n, f, hf, p, rfl⟩ := exists_fin_rename p\n  suffices p = 0 by rw [this, alg_hom.map_zero]\n  apply funext_fin\n  intro x\n  classical\n    convert h (function.extend f x 0)\n    simp only [eval, eval₂_hom_rename, function.extend_comp hf]\n#align funext funext\n-/\n\n"}