{"supported_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem supported_univ : supported R (Set.univ : set σ) = «expr⊤» := by simp [algebra.eq_top_iff, mem_supported]\n#align supported_univ supported_univ\n\n",
 "supported_strict_mono":
 "theorem supported_strict_mono [nontrivial R] : strict_mono (supported R : set σ → subalgebra R (mv_polynomial σ R)) :=\n  strictMono_of_le_iff_le fun _ _ => supported_le_supported_iff.symm\n#align supported_strict_mono supported_strict_mono\n\n",
 "supported_mono":
 "theorem supported_mono (st : s ⊆ t) : supported R s ≤ supported R t :=\n  algebra.adjoin_mono (Set.image_subset _ st)\n#align supported_mono supported_mono\n\n",
 "supported_le_supported_iff":
 "@[simp]\ntheorem supported_le_supported_iff [nontrivial R] : supported R s ≤ supported R t ↔ s ⊆ t :=\n  by\n  constructor\n  · intro h i\n    simpa using @h (X i)\n  · exact supported_mono\n#align supported_le_supported_iff supported_le_supported_iff\n\n",
 "supported_equiv_mv_polynomial_symm_X":
 "@[simp]\ntheorem supported_equiv_mv_polynomial_symm_X (s : set σ) (i : s) :\n    (↑((supported_equiv_mv_polynomial s).symm (X i : mv_polynomial s R)) : mv_polynomial σ R) = X i := by\n  simp [supported_equiv_mv_polynomial]\n#align supported_equiv_mv_polynomial_symm_X supported_equiv_mv_polynomial_symm_X\n\n",
 "supported_equiv_mv_polynomial_symm_C":
 "@[simp]\ntheorem supported_equiv_mv_polynomial_symm_C (s : set σ) (x : R) :\n    (supported_equiv_mv_polynomial s).symm (C x) = algebra_map R (supported R s) x :=\n  by\n  ext1\n  simp [supported_equiv_mv_polynomial, mv_polynomial.algebra_map_eq]\n#align supported_equiv_mv_polynomial_symm_C supported_equiv_mv_polynomial_symm_C\n\n",
 "supported_eq_vars_subset":
 "theorem supported_eq_vars_subset : (supported R s : set (mv_polynomial σ R)) = { p | ↑p.vars ⊆ s } :=\n  Set.ext fun _ => mem_supported\n#align supported_eq_vars_subset supported_eq_vars_subset\n\n",
 "supported_eq_range_rename":
 "/-\nCopyright (c) 2021 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\ntheorem supported_eq_range_rename (s : set σ) : supported R s = (rename (coe : s → σ)).range := by\n  rw [supported, Set.image_eq_range, adjoin_range_eq_range_aeval, rename]\n#align supported_eq_range_rename supported_eq_range_rename\n\n",
 "supported_eq_adjoin_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supported_eq_adjoin_X : supported R s = algebra.adjoin R («expr '' » X s) :=\n  rfl\n#align supported_eq_adjoin_X supported_eq_adjoin_X\n\n",
 "supported_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem supported_empty : supported R (∅ : set σ) = «expr⊥» := by simp [supported_eq_adjoin_X]\n#align supported_empty supported_empty\n\n",
 "mem_supported_vars":
 "@[simp]\ntheorem mem_supported_vars (p : mv_polynomial σ R) : p ∈ supported R (↑p.vars : set σ) := by rw [mem_supported]\n#align mem_supported_vars mem_supported_vars\n\n",
 "mem_supported":
 "theorem mem_supported : p ∈ supported R s ↔ ↑p.vars ⊆ s :=\n  by\n  rw [supported_eq_range_rename, alg_hom.mem_range]\n  constructor\n  · rintro ⟨p, rfl⟩\n    refine' trans (Finset.coe_subset.2 (vars_rename _ _)) _\n    simp\n  · intro hs\n    exact exists_rename_eq_of_vars_subset_range p (coe : s → σ) subtype.val_injective (by simpa)\n#align mem_supported mem_supported\n\n",
 "exists_restrict_to_vars":
 "theorem exists_restrict_to_vars (R : Type _) [CommRing R] {F : mv_polynomial σ ℤ} (hF : ↑F.vars ⊆ s) :\n    ∃ f : (s → R) → R, ∀ x : σ → R, f (x ∘ coe : s → R) = aeval x F := by\n  classical\n    rw [← mem_supported, supported_eq_range_rename, alg_hom.mem_range] at hF\n    cases' hF with F' hF'\n    use fun z => aeval z F'\n    intro x\n    simp only [← hF', aeval_rename]\n#align exists_restrict_to_vars exists_restrict_to_vars\n\n",
 "X_mem_supported":
 "@[simp]\ntheorem X_mem_supported [nontrivial R] {i : σ} : X i ∈ supported R s ↔ i ∈ s := by simp [mem_supported]\n#align X_mem_supported X_mem_supported\n\n"}