{"vars_sum_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem vars_sum_subset :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (φ i)).vars ⊆\n      Finset.bunionᵢ t fun i => (φ i).vars :=\n  by\n  apply t.induction_on\n  · simp\n  · intro a s has hsum\n    rw [Finset.bunionᵢ_insert, Finset.sum_insert has]\n    refine' Finset.Subset.trans (vars_add_subset _ _) (Finset.union_subset_union (Finset.Subset.refl _) _)\n    assumption\n#align vars_sum_subset vars_sum_subset\n\n",
 "vars_sum_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem vars_sum_of_disjoint (h : Pairwise <| «expr on » Disjoint fun i => (φ i).vars) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (φ i)).vars =\n      Finset.bunionᵢ t fun i => (φ i).vars :=\n  by\n  apply t.induction_on\n  · simp\n  · intro a s has hsum\n    rw [Finset.bunionᵢ_insert, Finset.sum_insert has, vars_add_of_disjoint, hsum]\n    unfold Pairwise on_fun at h\n    rw [hsum]\n    simp only [Finset.disjoint_iff_ne] at h⊢\n    intro v hv v2 hv2\n    rw [Finset.mem_bunionᵢ] at hv2\n    rcases hv2 with ⟨i, his, hi⟩\n    refine' h _ _ hv _ hi\n    rintro rfl\n    contradiction\n#align vars_sum_of_disjoint vars_sum_of_disjoint\n\n",
 "vars_rename":
 "theorem vars_rename (f : σ → τ) (φ : MvPolynomial σ R) : (rename f φ).vars ⊆ φ.vars.image f :=\n  by\n  intro i hi\n  simp only [vars, exists_prop, Multiset.mem_toFinset, Finset.mem_image] at hi⊢\n  simpa only [Multiset.mem_map] using degrees_rename _ _ hi\n#align vars_rename vars_rename\n\n",
 "vars_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The variables of the product of a family of polynomials\nare a subset of the union of the sets of variables of each polynomial.\n-/\ntheorem vars_prod {ι : Type _} {s : Finset ι} (f : ι → MvPolynomial σ R) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f i)).vars ⊆\n      s.bUnion fun i => (f i).vars :=\n  by\n  apply s.induction_on\n  · simp\n  · intro a s hs hsub\n    simp only [hs, Finset.bunionᵢ_insert, Finset.prod_insert, not_false_iff]\n    apply Finset.Subset.trans (vars_mul _ _)\n    exact Finset.union_subset_union (Finset.Subset.refl _) hsub\n#align vars_prod vars_prod\n\n",
 "vars_pow":
 "theorem vars_pow (φ : MvPolynomial σ R) (n : ℕ) : (φ ^ n).vars ⊆ φ.vars :=\n  by\n  induction' n with n ih\n  · simp\n  · rw [pow_succ]\n    apply Finset.Subset.trans (vars_mul _ _)\n    exact Finset.union_subset (Finset.Subset.refl _) ih\n#align vars_pow vars_pow\n\n",
 "vars_one":
 "@[simp]\ntheorem vars_one : (1 : MvPolynomial σ R).vars = ∅ :=\n  vars_C\n#align vars_one vars_one\n\n",
 "vars_mul":
 "theorem vars_mul (φ ψ : MvPolynomial σ R) : (φ * ψ).vars ⊆ φ.vars ∪ ψ.vars :=\n  by\n  intro i\n  simp only [mem_vars, Finset.mem_union]\n  rintro ⟨d, hd, hi⟩\n  rw [mem_support_iff, coeff_mul] at hd\n  contrapose! hd\n  cases hd\n  rw [Finset.sum_eq_zero]\n  rintro ⟨d₁, d₂⟩ H\n  rw [Finsupp.mem_antidiagonal] at H\n  subst H\n  obtain H | H : i ∈ d₁.support ∨ i ∈ d₂.support := by simpa only [Finset.mem_union] using Finsupp.support_add hi\n  · suffices coeff d₁ φ = 0 by simp [this]\n    rw [coeff, ← Finsupp.not_mem_support_iff]\n    intro\n    solve_by_elim\n  · suffices coeff d₂ ψ = 0 by simp [this]\n    rw [coeff, ← Finsupp.not_mem_support_iff]\n    intro\n    solve_by_elim\n#align vars_mul vars_mul\n\n",
 "vars_monomial_single":
 "theorem vars_monomial_single (i : σ) {e : ℕ} {r : R} (he : e ≠ 0) (hr : r ≠ 0) :\n    (monomial (Finsupp.single i e) r).vars = {i} := by rw [vars_monomial hr, Finsupp.support_single_ne_zero _ he]\n#align vars_monomial_single vars_monomial_single\n\n",
 "vars_monomial":
 "@[simp]\ntheorem vars_monomial (h : r ≠ 0) : (monomial s r).vars = s.support := by\n  rw [vars, degrees_monomial_eq _ _ h, Finsupp.toFinset_toMultiset]\n#align vars_monomial vars_monomial\n\n",
 "vars_map_of_injective":
 "theorem vars_map_of_injective (hf : injective f) : (map f p).vars = p.vars := by\n  simp [vars, degrees_map_of_injective _ hf]\n#align vars_map_of_injective vars_map_of_injective\n\n",
 "vars_map":
 "theorem vars_map : (map f p).vars ⊆ p.vars := by simp [vars, degrees_map]\n#align vars_map vars_map\n\n",
 "vars_eq_support_bUnion_support":
 "theorem vars_eq_support_bUnion_support : p.vars = p.support.bUnion Finsupp.support :=\n  by\n  ext i\n  rw [mem_vars, Finset.mem_bunionᵢ]\n#align vars_eq_support_bUnion_support vars_eq_support_bUnion_support\n\n",
 "vars_add_subset":
 "theorem vars_add_subset (p q : MvPolynomial σ R) : (p + q).vars ⊆ p.vars ∪ q.vars :=\n  by\n  intro x hx\n  simp only [vars, Finset.mem_union, Multiset.mem_toFinset] at hx⊢\n  simpa using Multiset.mem_of_le (degrees_add _ _) hx\n#align vars_add_subset vars_add_subset\n\n",
 "vars_add_of_disjoint":
 "theorem vars_add_of_disjoint (h : Disjoint p.vars q.vars) : (p + q).vars = p.vars ∪ q.vars :=\n  by\n  apply Finset.Subset.antisymm (vars_add_subset p q)\n  intro x hx\n  simp only [vars, Multiset.disjoint_toFinset] at h hx⊢\n  rw [degrees_add_of_disjoint h, Multiset.toFinset_union]\n  exact hx\n#align vars_add_of_disjoint vars_add_of_disjoint\n\n",
 "vars_X":
 "@[simp]\ntheorem vars_X [Nontrivial R] : (X n : MvPolynomial σ R).vars = {n} := by\n  rw [X, vars_monomial (one_ne_zero' R), Finsupp.support_single_ne_zero _ (one_ne_zero' ℕ)]\n#align vars_X vars_X\n\n",
 "vars_C_mul":
 "theorem vars_C_mul (a : A) (ha : a ≠ 0) (φ : MvPolynomial σ A) : (C a * φ).vars = φ.vars :=\n  by\n  ext1 i\n  simp only [mem_vars, exists_prop, mem_support_iff]\n  apply exists_congr\n  intro d\n  apply and_congr _ iff.rfl\n  rw [coeff_C_mul, mul_ne_zero_iff, eq_true ha, true_and_iff]\n#align vars_C_mul vars_C_mul\n\n",
 "vars_C":
 "@[simp]\ntheorem vars_C : (C r : MvPolynomial σ R).vars = ∅ := by rw [vars, degrees_C, Multiset.toFinset_zero]\n#align vars_C vars_C\n\n",
 "vars_0":
 "@[simp]\ntheorem vars_0 : (0 : MvPolynomial σ R).vars = ∅ := by rw [vars, degrees_zero, Multiset.toFinset_zero]\n#align vars_0 vars_0\n\n",
 "total_degree_zero":
 "@[simp]\ntheorem total_degree_zero : (0 : MvPolynomial σ R).total_degree = 0 := by rw [← C_0] <;> exact total_degree_C (0 : R)\n#align total_degree_zero total_degree_zero\n\n",
 "total_degree_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_degree_smul_le [CommSemiring S] [DistribMulAction R S] (a : R) (f : MvPolynomial σ S) :\n    («expr • » a f).total_degree ≤ f.total_degree :=\n  Finset.sup_mono support_smul\n#align total_degree_smul_le total_degree_smul_le\n\n",
 "total_degree_rename_le":
 "theorem total_degree_rename_le (f : σ → τ) (p : MvPolynomial σ R) : (rename f p).total_degree ≤ p.total_degree :=\n  Finset.sup_le fun b => by\n    intro h\n    rw [rename_eq] at h\n    have h' := Finsupp.mapDomain_support h\n    rw [Finset.mem_image] at h'\n    rcases h' with ⟨s, hs, rfl⟩\n    rw [Finsupp.sum_mapDomain_index]\n    exact le_trans le_rfl (Finset.le_sup hs)\n    exact fun _ => rfl\n    exact fun _ _ _ => rfl\n#align total_degree_rename_le total_degree_rename_le\n\n",
 "total_degree_pow":
 "theorem total_degree_pow (a : MvPolynomial σ R) (n : ℕ) : (a ^ n).total_degree ≤ n * a.total_degree :=\n  by\n  induction' n with n ih\n  · simp only [Nat.zero_eq, MulZeroClass.zero_mul, pow_zero, total_degree_one]\n  rw [pow_succ]\n  calc\n    total_degree (a * a ^ n) ≤ a.total_degree + (a ^ n).total_degree := total_degree_mul _ _\n    _ ≤ a.total_degree + n * a.total_degree := (add_le_add_left ih _)\n    _ = (n + 1) * a.total_degree := by rw [add_mul, one_mul, add_comm]\n    \n#align total_degree_pow total_degree_pow\n\n",
 "total_degree_one":
 "@[simp]\ntheorem total_degree_one : (1 : MvPolynomial σ R).total_degree = 0 :=\n  totalDegree_C (1 : R)\n#align total_degree_one total_degree_one\n\n",
 "total_degree_multiset_prod":
 "theorem total_degree_multiset_prod (s : Multiset (MvPolynomial σ R)) :\n    s.prod.total_degree ≤ (s.map MvPolynomial.totalDegree).sum :=\n  by\n  refine' Quotient.inductionOn s fun l => _\n  rw [Multiset.quot_mk_to_coe, Multiset.coe_prod, Multiset.coe_map, Multiset.coe_sum]\n  exact total_degree_list_prod l\n#align total_degree_multiset_prod total_degree_multiset_prod\n\n",
 "total_degree_mul":
 "theorem total_degree_mul (a b : MvPolynomial σ R) : (a * b).total_degree ≤ a.total_degree + b.total_degree :=\n  Finset.sup_le fun n hn => by\n    have := AddMonoidAlgebra.support_mul a b hn\n    simp only [Finset.mem_bunionᵢ, Finset.mem_singleton] at this\n    rcases this with ⟨a₁, h₁, a₂, h₂, rfl⟩\n    rw [Finsupp.sum_add_index']\n    · exact add_le_add (Finset.le_sup h₁) (Finset.le_sup h₂)\n    · intro a\n      rfl\n    · intro a b₁ b₂\n      rfl\n#align total_degree_mul total_degree_mul\n\n",
 "total_degree_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_degree_monomial (s : «expr →₀ » σ ℕ) {c : R} (hc : c ≠ 0) :\n    (monomial s c : MvPolynomial σ R).total_degree = s.sum fun _ e => e := by\n  simp [total_degree, support_monomial, if_neg hc]\n#align total_degree_monomial total_degree_monomial\n\n",
 "total_degree_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\ntheorem total_degree_list_prod :\n    ∀ s : List (MvPolynomial σ R), s.prod.total_degree ≤ (s.map MvPolynomial.totalDegree).sum\n  | [] => by rw [@List.prod_nil (MvPolynomial σ R) _, total_degree_one] <;> rfl\n  | sym.cons' p ps => by\n    rw [@List.prod_cons (MvPolynomial σ R) _, list.map, List.sum_cons]\n    exact le_trans (total_degree_mul _ _) (add_le_add_left (total_degree_list_prod ps) _)\n#align total_degree_list_prod total_degree_list_prod\n\n",
 "total_degree_le_degrees_card":
 "theorem total_degree_le_degrees_card (p : MvPolynomial σ R) : p.total_degree ≤ p.degrees.card :=\n  by\n  rw [total_degree_eq]\n  exact Finset.sup_le fun s hs => Multiset.card_le_of_le <| Finset.le_sup hs\n#align total_degree_le_degrees_card total_degree_le_degrees_card\n\n",
 "total_degree_finset_sum":
 "theorem total_degree_finset_sum {ι : Type _} (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (s.sum f).total_degree ≤ Finset.sup s fun i => (f i).total_degree :=\n  by\n  induction' s using Finset.cons_induction with a s has hind\n  · exact zero_le _\n  · rw [Finset.sum_cons, Finset.sup_cons, sup_eq_max]\n    exact (MvPolynomial.totalDegree_add _ _).trans (max_le_max le_rfl hind)\n#align total_degree_finset_sum total_degree_finset_sum\n\n",
 "total_degree_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem total_degree_finset_prod {ι : Type _} (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (s.prod f).total_degree ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (f i).total_degree :=\n  by\n  refine' le_trans (total_degree_multiset_prod _) _\n  rw [Multiset.map_map]\n  rfl\n#align total_degree_finset_prod total_degree_finset_prod\n\n",
 "total_degree_eq":
 "theorem total_degree_eq (p : MvPolynomial σ R) : p.total_degree = p.support.sup fun m => m.to_multiset.card :=\n  by\n  rw [total_degree]\n  congr ; funext m\n  exact (Finsupp.card_toMultiset _).symm\n#align total_degree_eq total_degree_eq\n\n",
 "total_degree_add_eq_right_of_total_degree_lt":
 "theorem total_degree_add_eq_right_of_total_degree_lt {p q : MvPolynomial σ R} (h : q.total_degree < p.total_degree) :\n    (q + p).total_degree = p.total_degree := by rw [add_comm, total_degree_add_eq_left_of_total_degree_lt h]\n#align total_degree_add_eq_right_of_total_degree_lt total_degree_add_eq_right_of_total_degree_lt\n\n",
 "total_degree_add_eq_left_of_total_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_degree_add_eq_left_of_total_degree_lt {p q : MvPolynomial σ R} (h : q.total_degree < p.total_degree) :\n    (p + q).total_degree = p.total_degree := by\n  classical\n    apply le_antisymm\n    · rw [← max_eq_left_of_lt h]\n      exact total_degree_add p q\n    by_cases hp : p = 0\n    · simp [hp]\n    obtain ⟨b, hb₁, hb₂⟩ :=\n      p.support.exists_mem_eq_sup (finsupp.support_nonempty_iff.mpr hp) fun m : «expr →₀ » σ ℕ => m.to_multiset.card\n    have hb : ¬b ∈ q.support := by\n      contrapose! h\n      rw [total_degree_eq p, hb₂, total_degree_eq]\n      apply Finset.le_sup h\n    have hbb : b ∈ (p + q).support := by\n      apply support_sdiff_support_subset_support_add\n      rw [Finset.mem_sdiff]\n      exact ⟨hb₁, hb⟩\n    rw [total_degree_eq, hb₂, total_degree_eq]\n    exact Finset.le_sup hbb\n#align total_degree_add_eq_left_of_total_degree_lt total_degree_add_eq_left_of_total_degree_lt\n\n",
 "total_degree_add":
 "theorem total_degree_add (a b : MvPolynomial σ R) : (a + b).total_degree ≤ max a.total_degree b.total_degree :=\n  Finset.sup_le fun n hn => by\n    have := Finsupp.support_add hn\n    rw [Finset.mem_union] at this\n    cases this\n    · exact le_max_of_le_left (Finset.le_sup this)\n    · exact le_max_of_le_right (Finset.le_sup this)\n#align total_degree_add total_degree_add\n\n",
 "total_degree_X_pow":
 "@[simp]\ntheorem total_degree_X_pow [Nontrivial R] (s : σ) (n : ℕ) : (X s ^ n : MvPolynomial σ R).total_degree = n := by\n  simp [X_pow_eq_monomial, one_ne_zero]\n#align total_degree_X_pow total_degree_X_pow\n\n",
 "total_degree_X":
 "@[simp]\ntheorem total_degree_X {R} [CommSemiring R] [Nontrivial R] (s : σ) : (X s : MvPolynomial σ R).total_degree = 1 :=\n  by\n  rw [total_degree, support_X]\n  simp only [Finset.sup, sum_single_index, Finset.fold_singleton, sup_bot_eq]\n#align total_degree_X total_degree_X\n\n",
 "total_degree_C":
 "@[simp]\ntheorem total_degree_C (a : R) : (C a : MvPolynomial σ R).total_degree = 0 :=\n  nat.eq_zero_of_le_zero <|\n    Finset.sup_le fun n hn => by\n      have := Finsupp.support_single_subset hn\n      rw [Finset.mem_singleton] at this\n      subst this\n      exact le_rfl\n#align total_degree_C total_degree_C\n\n",
 "monomial_le_degree_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem monomial_le_degree_of (i : σ) {f : MvPolynomial σ R} {m : «expr →₀ » σ ℕ} (h_m : m ∈ f.support) :\n    m i ≤ degreeOf i f := by\n  rw [degree_of_eq_sup i]\n  apply Finset.le_sup h_m\n#align monomial_le_degree_of monomial_le_degree_of\n\n",
 "mem_vars_rename":
 "theorem mem_vars_rename (f : σ → τ) (φ : MvPolynomial σ R) {j : τ} (h : j ∈ (rename f φ).vars) :\n    ∃ i : σ, i ∈ φ.vars ∧ f i = j := by simpa only [exists_prop, Finset.mem_image] using vars_rename f φ h\n#align mem_vars_rename mem_vars_rename\n\n",
 "mem_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_vars (i : σ) : i ∈ p.vars ↔ ∃ (d : «expr →₀ » σ ℕ)(H : d ∈ p.support), i ∈ d.support := by\n  simp only [vars, Multiset.mem_toFinset, mem_degrees, mem_support_iff, exists_prop]\n#align mem_vars mem_vars\n\n",
 "mem_support_not_mem_vars_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_support_not_mem_vars_zero {f : MvPolynomial σ R} {x : «expr →₀ » σ ℕ} (H : x ∈ f.support) {v : σ}\n    (h : v ∉ vars f) : x v = 0 := by\n  rw [vars, Multiset.mem_toFinset] at h\n  rw [← Finsupp.not_mem_support_iff]\n  contrapose! h\n  unfold degrees\n  rw [show f.support = insert x f.support from Eq.symm <| Finset.insert_eq_of_mem H]\n  rw [Finset.sup_insert]\n  simp only [Multiset.mem_union, Multiset.sup_eq_union]\n  left\n  rwa [← to_finset_to_multiset, Multiset.mem_toFinset] at h\n#align mem_support_not_mem_vars_zero mem_support_not_mem_vars_zero\n\n",
 "mem_degrees":
 "theorem mem_degrees {p : MvPolynomial σ R} {i : σ} : i ∈ p.degrees ↔ ∃ d, p.coeff d ≠ 0 ∧ i ∈ d.support := by\n  simp only [degrees, Multiset.mem_sup, ← mem_support_iff, Finsupp.mem_toMultiset, exists_prop]\n#align mem_degrees mem_degrees\n\n",
 "le_degrees_add":
 "theorem le_degrees_add {p q : MvPolynomial σ R} (h : p.degrees.disjoint q.degrees) : p.degrees ≤ (p + q).degrees :=\n  by\n  apply Finset.sup_le\n  intro d hd\n  rw [Multiset.disjoint_iff_ne] at h\n  rw [Multiset.le_iff_count]\n  intro i\n  rw [degrees, Multiset.count_finset_sup]\n  simp only [Finsupp.count_toMultiset]\n  by_cases h0 : d = 0\n  · simp only [h0, zero_le, Finsupp.zero_apply]\n  · refine' @Finset.le_sup _ _ _ _ (p + q).support _ d _\n    rw [mem_support_iff, coeff_add]\n    suffices q.coeff d = 0 by rwa [this, add_zero, coeff, ← Finsupp.mem_support_iff]\n    rw [← Finsupp.support_eq_empty, ← ne.def, ← Finset.nonempty_iff_ne_empty] at h0\n    obtain ⟨j, hj⟩ := h0\n    contrapose! h\n    rw [mem_support_iff] at hd\n    refine' ⟨j, _, j, _, rfl⟩\n    all_goals rw [mem_degrees]; refine' ⟨d, _, hj⟩; assumption\n#align le_degrees_add le_degrees_add\n\n",
 "hom_congr_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If `f₁` and `f₂` are ring homs out of the polynomial ring and `p₁` and `p₂` are polynomials,\n  then `f₁ p₁ = f₂ p₂` if `p₁ = p₂` and `f₁` and `f₂` are equal on `R` and on the variables\n  of `p₁`.  -/\ntheorem hom_congr_vars {f₁ f₂ : «expr →+* » (MvPolynomial σ R) S} {p₁ p₂ : MvPolynomial σ R}\n    (hC : f₁.comp C = f₂.comp C) (hv : ∀ i, i ∈ p₁.vars → i ∈ p₂.vars → f₁ (X i) = f₂ (X i)) (hp : p₁ = p₂) :\n    f₁ p₁ = f₂ p₂ :=\n  calc\n    f₁ p₁ = eval₂Hom (f₁.comp C) (f₁ ∘ X) p₁ := RingHom.congr_fun (by ext <;> simp) _\n    _ = eval₂Hom (f₂.comp C) (f₂ ∘ X) p₂ := (eval₂Hom_congr' hC hv hp)\n    _ = f₂ p₂ := RingHom.congr_fun (by ext <;> simp) _\n    \n#align hom_congr_vars hom_congr_vars\n\n",
 "exists_rename_eq_of_vars_subset_range":
 "theorem exists_rename_eq_of_vars_subset_range (p : MvPolynomial σ R) (f : τ → σ) (hfi : injective f)\n    (hf : ↑p.vars ⊆ Set.range f) : ∃ q : MvPolynomial τ R, rename f q = p :=\n  ⟨aeval (fun i : σ => Option.elim' 0 X <| partialInv f i) p,\n    by\n    show (rename f).to_ring_hom.comp _ p = RingHom.id _ p\n    refine' hom_congr_vars _ _ _\n    · ext1\n      simp [algebra_map_eq]\n    · intro i hip _\n      rcases hf hip with ⟨i, rfl⟩\n      simp [partial_inv_left hfi]\n    · rfl⟩\n#align exists_rename_eq_of_vars_subset_range exists_rename_eq_of_vars_subset_range\n\n",
 "exists_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem exists_degree_lt [Fintype σ] (f : MvPolynomial σ R) (n : ℕ) (h : f.total_degree < n * Fintype.card σ)\n    {d : «expr →₀ » σ ℕ} (hd : d ∈ f.support) : ∃ i, d i < n :=\n  by\n  contrapose! h\n  calc\n    n * Fintype.card σ =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" n :=\n      by rw [Finset.sum_const, Nat.nsmul_eq_mul, mul_comm, Finset.card_univ]\n    _ ≤\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (d s) :=\n      (Finset.sum_le_sum fun s _ => h s)\n    _ ≤ d.sum fun i e => e := by\n      rw [Finsupp.sum_fintype]\n      intros\n      rfl\n    _ ≤ f.total_degree := Finset.le_sup hd\n    \n#align exists_degree_lt exists_degree_lt\n\n",
 "eval₂_hom_eq_constant_coeff_of_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_hom_eq_constant_coeff_of_vars (f : «expr →+* » R S) {g : σ → S} {p : MvPolynomial σ R}\n    (hp : ∀ i ∈ p.vars, g i = 0) : eval₂Hom f g p = f (constantCoeff p) :=\n  by\n  conv_lhs => rw [p.as_sum]\n  simp only [RingHom.map_sum, eval₂_hom_monomial]\n  by_cases h0 : constant_coeff p = 0\n  on_goal 1 =>\n    rw [h0, f.map_zero, Finset.sum_eq_zero]\n    intro d hd\n  on_goal 2 =>\n    rw [Finset.sum_eq_single (0 : «expr →₀ » σ ℕ)]\n    · rw [Finsupp.prod_zero_index, mul_one]\n      rfl\n    intro d hd hd0\n  repeat'\n    obtain ⟨i, hi⟩ : d.support.nonempty :=\n      by\n      rw [constant_coeff_eq, coeff, ← Finsupp.not_mem_support_iff] at h0\n      rw [Finset.nonempty_iff_ne_empty, ne.def, Finsupp.support_eq_empty]\n      rintro rfl\n      contradiction\n    rw [Finsupp.prod, Finset.prod_eq_zero hi, MulZeroClass.mul_zero]\n    rw [hp, zero_pow (nat.pos_of_ne_zero <| finsupp.mem_support_iff.mp hi)]\n    rw [mem_vars]\n    exact ⟨d, hd, hi⟩\n  · rw [constant_coeff_eq, coeff, ← ne.def, ← Finsupp.mem_support_iff] at h0\n    intro\n    contradiction\n#align eval₂_hom_eq_constant_coeff_of_vars eval₂_hom_eq_constant_coeff_of_vars\n\n",
 "eval₂_hom_congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eval₂_hom_congr' {f₁ f₂ : «expr →+* » R S} {g₁ g₂ : σ → S} {p₁ p₂ : MvPolynomial σ R} :\n    f₁ = f₂ → (∀ i, i ∈ p₁.vars → i ∈ p₂.vars → g₁ i = g₂ i) → p₁ = p₂ → eval₂Hom f₁ g₁ p₁ = eval₂Hom f₂ g₂ p₂ :=\n  by\n  rintro rfl h rfl\n  rename' p₁ => p, f₁ => f\n  rw [p.as_sum]\n  simp only [RingHom.map_sum, eval₂_hom_monomial]\n  apply Finset.sum_congr rfl\n  intro d hd\n  congr 1\n  simp only [Finsupp.prod]\n  apply Finset.prod_congr rfl\n  intro i hi\n  have : i ∈ p.vars := by\n    rw [mem_vars]\n    exact ⟨d, hd, hi⟩\n  rw [h i this this]\n#align eval₂_hom_congr' eval₂_hom_congr'\n\n",
 "degrees_zero":
 "@[simp]\ntheorem degrees_zero : degrees (0 : MvPolynomial σ R) = 0 :=\n  by\n  rw [← C_0]\n  exact degrees_C 0\n#align degrees_zero degrees_zero\n\n",
 "degrees_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem degrees_sum {ι : Type _} (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i)).degrees ≤\n      s.sup fun i => (f i).degrees :=\n  by\n  refine' s.induction _ _\n  · simp only [Finset.sum_empty, Finset.sup_empty, degrees_zero]\n    exact le_rfl\n  · intro i s his ih\n    rw [Finset.sup_insert, Finset.sum_insert his]\n    exact le_trans (degrees_add _ _) (sup_le_sup_left ih _)\n#align degrees_sum degrees_sum\n\n",
 "degrees_rename_of_injective":
 "theorem degrees_rename_of_injective {p : MvPolynomial σ R} {f : σ → τ} (h : function.injective f) :\n    degrees (rename f p) = (degrees p).map f :=\n  by\n  simp only [degrees, Multiset.map_finset_sup p.support Finsupp.toMultiset f h, support_rename_of_injective h,\n    Finset.sup_image]\n  refine' Finset.sup_congr rfl fun x hx => _\n  exact (Finsupp.toMultiset_map _ _).symm\n#align degrees_rename_of_injective degrees_rename_of_injective\n\n",
 "degrees_rename":
 "theorem degrees_rename (f : σ → τ) (φ : MvPolynomial σ R) : (rename f φ).degrees ⊆ φ.degrees.map f :=\n  by\n  intro i\n  rw [mem_degrees, Multiset.mem_map]\n  rintro ⟨d, hd, hi⟩\n  obtain ⟨x, rfl, hx⟩ := coeff_rename_ne_zero _ _ _ hd\n  simp only [map_domain, Finsupp.mem_support_iff] at hi\n  rw [sum_apply, Finsupp.sum] at hi\n  contrapose! hi\n  rw [Finset.sum_eq_zero]\n  intro j hj\n  simp only [exists_prop, mem_degrees] at hi\n  specialize hi j ⟨x, hx, hj⟩\n  rw [single_apply, if_neg hi]\n#align degrees_rename degrees_rename\n\n",
 "degrees_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem degrees_prod {ι : Type _} (s : Finset ι) (f : ι → MvPolynomial σ R) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (f i)).degrees ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f i).degrees :=\n  by\n  refine' s.induction _ _\n  · simp only [Finset.prod_empty, Finset.sum_empty, degrees_one]\n  · intro i s his ih\n    rw [Finset.prod_insert his, Finset.sum_insert his]\n    exact le_trans (degrees_mul _ _) (add_le_add_left ih _)\n#align degrees_prod degrees_prod\n\n",
 "degrees_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem degrees_pow (p : MvPolynomial σ R) : ∀ n : ℕ, (p ^ n).degrees ≤ «expr • » n p.degrees\n  | 0 => by rw [pow_zero, degrees_one]; exact Multiset.zero_le _\n  | n + 1 => by\n    rw [pow_succ, add_smul, add_comm, one_smul]\n    exact le_trans (degrees_mul _ _) (add_le_add_left (degrees_pow n) _)\n#align degrees_pow degrees_pow\n\n",
 "degrees_one":
 "@[simp]\ntheorem degrees_one : degrees (1 : MvPolynomial σ R) = 0 :=\n  degrees_C 1\n#align degrees_one degrees_one\n\n",
 "degrees_mul":
 "theorem degrees_mul (p q : MvPolynomial σ R) : (p * q).degrees ≤ p.degrees + q.degrees :=\n  by\n  refine' Finset.sup_le fun b hb => _\n  have := support_mul p q hb\n  simp only [Finset.mem_bunionᵢ, Finset.mem_singleton] at this\n  rcases this with ⟨a₁, h₁, a₂, h₂, rfl⟩\n  rw [Finsupp.toMultiset_add]\n  exact add_le_add (Finset.le_sup h₁) (Finset.le_sup h₂)\n#align degrees_mul degrees_mul\n\n",
 "degrees_monomial_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem degrees_monomial_eq (s : «expr →₀ » σ ℕ) (a : R) (ha : a ≠ 0) : degrees (monomial s a) = s.to_multiset :=\n  le_antisymm (degrees_monomial s a) <| Finset.le_sup <| by rw [support_monomial, if_neg ha, Finset.mem_singleton]\n#align degrees_monomial_eq degrees_monomial_eq\n\n",
 "degrees_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Johan Commelin, Mario Carneiro\n-/\ntheorem degrees_monomial (s : «expr →₀ » σ ℕ) (a : R) : degrees (monomial s a) ≤ s.to_multiset :=\n  Finset.sup_le fun t h => by\n    have := Finsupp.support_single_subset h\n    rw [Finset.mem_singleton] at this\n    rw [this]\n#align degrees_monomial degrees_monomial\n\n",
 "degrees_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem degrees_map_of_injective [CommSemiring S] (p : MvPolynomial σ R) {f : «expr →+* » R S} (hf : injective f) :\n    (map f p).degrees = p.degrees := by simp only [degrees, MvPolynomial.support_map_of_injective _ hf]\n#align degrees_map_of_injective degrees_map_of_injective\n\n",
 "degrees_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem degrees_map [CommSemiring S] (p : MvPolynomial σ R) (f : «expr →+* » R S) : (map f p).degrees ⊆ p.degrees :=\n  by\n  dsimp only [degrees]\n  apply Multiset.subset_of_le\n  apply Finset.sup_mono\n  apply MvPolynomial.support_map_subset\n#align degrees_map degrees_map\n\n",
 "degrees_add_of_disjoint":
 "theorem degrees_add_of_disjoint {p q : MvPolynomial σ R} (h : Multiset.Disjoint p.degrees q.degrees) :\n    (p + q).degrees = p.degrees ∪ q.degrees := by\n  apply le_antisymm\n  · apply degrees_add\n  · apply Multiset.union_le\n    · apply le_degrees_add h\n    · rw [add_comm]\n      apply le_degrees_add h.symm\n#align degrees_add_of_disjoint degrees_add_of_disjoint\n\n",
 "degrees_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem degrees_add (p q : MvPolynomial σ R) : (p + q).degrees ≤ «expr ⊔ » p.degrees q.degrees :=\n  by\n  refine' Finset.sup_le fun b hb => _\n  have := Finsupp.support_add hb; rw [Finset.mem_union] at this\n  cases this\n  · exact le_sup_of_le_left (Finset.le_sup this)\n  · exact le_sup_of_le_right (Finset.le_sup this)\n#align degrees_add degrees_add\n\n",
 "degrees_X'":
 "theorem degrees_X' (n : σ) : degrees (X n : MvPolynomial σ R) ≤ {n} :=\n  le_trans (degrees_monomial _ _) <| le_of_eq <| toMultiset_single _ _\n#align degrees_X' degrees_X'\n\n",
 "degrees_X":
 "@[simp]\ntheorem degrees_X [Nontrivial R] (n : σ) : degrees (X n : MvPolynomial σ R) = {n} :=\n  (degrees_monomial_eq _ (1 : R) one_ne_zero).trans (toMultiset_single _ _)\n#align degrees_X degrees_X\n\n",
 "degrees_C":
 "theorem degrees_C (a : R) : degrees (C a : MvPolynomial σ R) = 0 :=\n  Multiset.le_zero.1 <| degrees_monomial _ _\n#align degrees_C degrees_C\n\n",
 "degree_of_zero":
 "@[simp]\ntheorem degree_of_zero (n : σ) : degreeOf n (0 : MvPolynomial σ R) = 0 := by\n  simp only [degree_of, degrees_zero, Multiset.count_zero]\n#align degree_of_zero degree_of_zero\n\n",
 "degree_of_rename_of_injective":
 "theorem degree_of_rename_of_injective {p : MvPolynomial σ R} {f : σ → τ} (h : function.injective f) (i : σ) :\n    degreeOf (f i) (rename f p) = degreeOf i p := by\n  simp only [degree_of, degrees_rename_of_injective h, Multiset.count_map_eq_count' f p.degrees h]\n#align degree_of_rename_of_injective degree_of_rename_of_injective\n\n",
 "degree_of_mul_le":
 "-- TODO we can prove equality here if R is a domain\ntheorem degree_of_mul_le (i : σ) (f g : MvPolynomial σ R) : degreeOf i (f * g) ≤ degreeOf i f + degreeOf i g :=\n  by\n  repeat' rw [degree_of]\n  convert Multiset.count_le_of_le i (degrees_mul f g)\n  rw [Multiset.count_add]\n#align degree_of_mul_le degree_of_mul_le\n\n",
 "degree_of_mul_X_ne":
 "theorem degree_of_mul_X_ne {i j : σ} (f : MvPolynomial σ R) (h : i ≠ j) : degreeOf i (f * X j) = degreeOf i f :=\n  by\n  repeat' rw [degree_of_eq_sup i]\n  rw [support_mul_X]\n  simp only [Finset.sup_map]\n  congr\n  ext\n  simp only [single, nat.one_ne_zero, add_right_eq_self, addRightEmbedding_apply, coe_mk, Pi.add_apply, comp_app,\n    ite_eq_right_iff, Finsupp.coe_add, Pi.single_eq_of_ne h]\n#align degree_of_mul_X_ne degree_of_mul_X_ne\n\n",
 "degree_of_mul_X_eq":
 "-- TODO in the following we have equality iff f ≠ 0\ntheorem degree_of_mul_X_eq (j : σ) (f : MvPolynomial σ R) : degreeOf j (f * X j) ≤ degreeOf j f + 1 :=\n  by\n  repeat' rw [degree_of]\n  apply (Multiset.count_le_of_le j (degrees_mul f (X j))).trans\n  simp only [Multiset.count_add, add_le_add_iff_left]\n  convert Multiset.count_le_of_le j (degrees_X' j)\n  rw [Multiset.count_singleton_self]\n#align degree_of_mul_X_eq degree_of_mul_X_eq\n\n",
 "degree_of_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem degree_of_lt_iff {n : σ} {f : MvPolynomial σ R} {d : ℕ} (h : 0 < d) :\n    degreeOf n f < d ↔ ∀ m : «expr →₀ » σ ℕ, m ∈ f.support → m n < d := by rwa [degree_of_eq_sup n f, Finset.sup_lt_iff]\n#align degree_of_lt_iff degree_of_lt_iff\n\n",
 "degree_of_eq_sup":
 "theorem degree_of_eq_sup (n : σ) (f : MvPolynomial σ R) : degreeOf n f = f.support.sup fun m => m n :=\n  by\n  rw [degree_of, degrees, Multiset.count_finset_sup]\n  congr\n  ext\n  simp\n#align degree_of_eq_sup degree_of_eq_sup\n\n",
 "degree_of_add_le":
 "theorem degree_of_add_le (n : σ) (f g : MvPolynomial σ R) : degreeOf n (f + g) ≤ max (degreeOf n f) (degreeOf n g) :=\n  by\n  repeat' rw [degree_of]\n  apply (Multiset.count_le_of_le n (degrees_add f g)).trans\n  dsimp\n  rw [Multiset.count_union]\n#align degree_of_add_le degree_of_add_le\n\n",
 "degree_of_X":
 "theorem degree_of_X (i j : σ) [Nontrivial R] : degreeOf i (X j : MvPolynomial σ R) = if i = j then 1 else 0 :=\n  by\n  by_cases c : i = j\n  · simp only [c, if_true, eq_self_iff_true, degree_of, degrees_X, Multiset.count_singleton]\n  simp [c, if_false, degree_of, degrees_X]\n#align degree_of_X degree_of_X\n\n",
 "degree_of_C":
 "@[simp]\ntheorem degree_of_C (a : R) (x : σ) : degreeOf x (C a : MvPolynomial σ R) = 0 := by simp [degree_of, degrees_C]\n#align degree_of_C degree_of_C\n\n",
 "coeff_eq_zero_of_total_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem coeff_eq_zero_of_total_degree_lt {f : MvPolynomial σ R} {d : «expr →₀ » σ ℕ}\n    (h :\n      f.total_degree <\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" d.support\n          (d i)) :\n    coeff d f = 0 := by\n  classical\n    rw [total_degree, Finset.sup_lt_iff] at h\n    · specialize h d\n      rw [mem_support_iff] at h\n      refine' not_not.mp (mt h _)\n      exact lt_irrefl _\n    · exact lt_of_le_of_lt (nat.zero_le _) h\n#align coeff_eq_zero_of_total_degree_lt coeff_eq_zero_of_total_degree_lt\n\n",
 "aeval_eq_constant_coeff_of_vars":
 "theorem aeval_eq_constant_coeff_of_vars [Algebra R S] {g : σ → S} {p : MvPolynomial σ R} (hp : ∀ i ∈ p.vars, g i = 0) :\n    aeval g p = algebraMap _ _ (constantCoeff p) :=\n  eval₂Hom_eq_constantCoeff_of_vars _ hp\n#align aeval_eq_constant_coeff_of_vars aeval_eq_constant_coeff_of_vars\n\n"}