{"support_fin_succ_equiv_nonempty":
 "theorem support_fin_succ_equiv_nonempty {f : mv_polynomial (fin (n + 1)) R} (h : f ≠ 0) :\n    (fin_succ_equiv R n f).support.nonempty := by\n  by_contra c\n  simp only [Finset.not_nonempty_iff_eq_empty, polynomial.support_eq_empty] at c\n  have t'' : fin_succ_equiv R n f ≠ 0 := by\n    let ii := (fin_succ_equiv R n).symm\n    have h' : f = 0 :=\n      calc\n        f = ii (fin_succ_equiv R n f) := by\n          simpa only [ii, ← alg_equiv.inv_fun_eq_symm] using ((fin_succ_equiv R n).left_inv f).symm\n        _ = ii 0 := by rw [c]\n        _ = 0 := by simp\n        \n    simpa [h'] using h\n  simpa [c] using h\n#align support_fin_succ_equiv_nonempty support_fin_succ_equiv_nonempty\n\n",
 "support_coeff_fin_succ_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem support_coeff_fin_succ_equiv {f : mv_polynomial (fin (n + 1)) R} {i : ℕ} {m : «expr →₀ » (fin n) ℕ} :\n    m ∈ (polynomial.coeff ((fin_succ_equiv R n) f) i).support ↔ finsupp.cons i m ∈ f.support :=\n  by\n  apply iff.intro\n  · intro h\n    simpa [← fin_succ_equiv_coeff_coeff] using h\n  · intro h\n    simpa [mem_support_iff, ← fin_succ_equiv_coeff_coeff m f i] using h\n#align support_coeff_fin_succ_equiv support_coeff_fin_succ_equiv\n\n",
 "sum_to_iter_Xr":
 "@[simp]\ntheorem sum_to_iter_Xr (c : S₂) : sum_to_iter R S₁ S₂ (X (sum.inr c)) = C (X c) :=\n  eval₂_X _ _ (sum.inr c)\n#align sum_to_iter_Xr sum_to_iter_Xr\n\n",
 "sum_to_iter_Xl":
 "@[simp]\ntheorem sum_to_iter_Xl (b : S₁) : sum_to_iter R S₁ S₂ (X (sum.inl b)) = X b :=\n  eval₂_X _ _ (sum.inl b)\n#align sum_to_iter_Xl sum_to_iter_Xl\n\n",
 "sum_to_iter_C":
 "@[simp]\ntheorem sum_to_iter_C (a : R) : sum_to_iter R S₁ S₂ (C a) = C (C a) :=\n  eval₂_C _ _ a\n#align sum_to_iter_C sum_to_iter_C\n\n",
 "nat_degree_fin_succ_equiv":
 "theorem nat_degree_fin_succ_equiv (f : mv_polynomial (fin (n + 1)) R) :\n    (fin_succ_equiv R n f).nat_degree = degree_of 0 f :=\n  by\n  by_cases c : f = 0\n  · rw [c, (fin_succ_equiv R n).map_zero, polynomial.nat_degree_zero, degree_of_zero]\n  · rw [polynomial.nat_degree, degree_fin_succ_equiv (by simpa only [ne.def] )]\n    simp\n#align nat_degree_fin_succ_equiv nat_degree_fin_succ_equiv\n\n",
 "map_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_trans [CommSemiring S₁] [CommSemiring S₂] [CommSemiring S₃] (e : «expr ≃+* » S₁ S₂)\n    (f : «expr ≃+* » S₂ S₃) : (map_equiv σ e).trans (map_equiv σ f) = map_equiv σ (e.trans f) :=\n  RingEquiv.ext (map_map e f)\n#align map_equiv_trans map_equiv_trans\n\n",
 "map_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_symm [CommSemiring S₁] [CommSemiring S₂] (e : «expr ≃+* » S₁ S₂) :\n    (map_equiv σ e).symm = map_equiv σ e.symm :=\n  rfl\n#align map_equiv_symm map_equiv_symm\n\n",
 "map_equiv_refl":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Johan Commelin, Mario Carneiro\n-/\n@[simp]\ntheorem map_equiv_refl : map_equiv σ (RingEquiv.refl R) = RingEquiv.refl _ :=\n  RingEquiv.ext map_id\n#align map_equiv_refl map_equiv_refl\n\n",
 "map_alg_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_alg_equiv_trans (e : «expr ≃ₐ[ ] » A₁ R A₂) (f : «expr ≃ₐ[ ] » A₂ R A₃) :\n    (map_alg_equiv σ e).trans (map_alg_equiv σ f) = map_alg_equiv σ (e.trans f) :=\n  alg_equiv.ext (map_map e f)\n#align map_alg_equiv_trans map_alg_equiv_trans\n\n",
 "map_alg_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_alg_equiv_symm (e : «expr ≃ₐ[ ] » A₁ R A₂) : (map_alg_equiv σ e).symm = map_alg_equiv σ e.symm :=\n  rfl\n#align map_alg_equiv_symm map_alg_equiv_symm\n\n",
 "map_alg_equiv_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_alg_equiv_refl : map_alg_equiv σ (alg_equiv.refl : «expr ≃ₐ[ ] » A₁ R A₁) = alg_equiv.refl :=\n  alg_equiv.ext map_id\n#align map_alg_equiv_refl map_alg_equiv_refl\n\n",
 "iter_to_sum_X":
 "theorem iter_to_sum_X (b : S₁) : iter_to_sum R S₁ S₂ (X b) = X (sum.inl b) :=\n  eval₂_X _ _ _\n#align iter_to_sum_X iter_to_sum_X\n\n",
 "iter_to_sum_C_X":
 "theorem iter_to_sum_C_X (c : S₂) : iter_to_sum R S₁ S₂ (C (X c)) = X (sum.inr c) :=\n  eq.trans (eval₂_C _ _ (X c)) (eval₂_X _ _ _)\n#align iter_to_sum_C_X iter_to_sum_C_X\n\n",
 "iter_to_sum_C_C":
 "theorem iter_to_sum_C_C (a : R) : iter_to_sum R S₁ S₂ (C (C a)) = C a :=\n  eq.trans (eval₂_C _ _ (C a)) (eval₂_C _ _ _)\n#align iter_to_sum_C_C iter_to_sum_C_C\n\n",
 "fin_succ_equiv_support'":
 "theorem fin_succ_equiv_support' {f : mv_polynomial (fin (n + 1)) R} {i : ℕ} :\n    Finset.image (finsupp.cons i) (polynomial.coeff ((fin_succ_equiv R n) f) i).support =\n      f.support.filter fun m => m 0 = i :=\n  by\n  ext m\n  rw [Finset.mem_filter, Finset.mem_image, mem_support_iff]\n  conv_lhs =>\n    congr\n    ext\n    rw [mem_support_iff, fin_succ_equiv_coeff_coeff, ne.def]\n  constructor\n  · rintro ⟨m', ⟨h, hm'⟩⟩\n    simp only [← hm']\n    exact ⟨h, by rw [cons_zero]⟩\n  · intro h\n    use tail m\n    rw [← h.2, cons_tail]\n    simp [h.1]\n#align fin_succ_equiv_support' fin_succ_equiv_support'\n\n",
 "fin_succ_equiv_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem fin_succ_equiv_support (f : mv_polynomial (fin (n + 1)) R) :\n    (fin_succ_equiv R n f).support = Finset.image (fun m : «expr →₀ » (fin (n + 1)) ℕ => m 0) f.support :=\n  by\n  ext i\n  rw [polynomial.mem_support_iff, Finset.mem_image, nonzero_iff_exists]\n  constructor\n  · rintro ⟨m, hm⟩\n    refine' ⟨cons i m, _, cons_zero _ _⟩\n    rw [← support_coeff_fin_succ_equiv]\n    simpa using hm\n  · rintro ⟨m, h, rfl⟩\n    refine' ⟨tail m, _⟩\n    rwa [← coeff, ← mem_support_iff, support_coeff_fin_succ_equiv, cons_tail]\n#align fin_succ_equiv_support fin_succ_equiv_support\n\n",
 "fin_succ_equiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- this speeds up typeclass search in the lemma below\ntheorem fin_succ_equiv_eq :\n    (fin_succ_equiv R n : «expr →+* » (mv_polynomial (fin (n + 1)) R) (polynomial (mv_polynomial (fin n) R))) =\n      eval₂_hom (polynomial.C.comp (C : «expr →+* » R (mv_polynomial (fin n) R))) fun i : fin (n + 1) =>\n        Fin.cases polynomial.X (fun k => polynomial.C (X k)) i :=\n  by\n  ext : 2\n  · simp only [fin_succ_equiv, option_equiv_left_apply, aeval_C, alg_equiv.coe_trans, RingHom.coe_coe, coe_eval₂_hom,\n      comp_app, rename_equiv_apply, eval₂_C, RingHom.coe_comp, rename_C]\n    rfl\n  · intro i\n    refine' Fin.cases _ _ i <;> simp [fin_succ_equiv]\n#align fin_succ_equiv_eq fin_succ_equiv_eq\n\n",
 "fin_succ_equiv_comp_C_eq_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem fin_succ_equiv_comp_C_eq_C {R : Type u} [CommSemiring R] (n : ℕ) :\n    (↑(mv_polynomial.fin_succ_equiv R n).symm : «expr →+* » (polynomial (mv_polynomial (fin n) R)) _).comp\n        (polynomial.C.comp mv_polynomial.C) =\n      (mv_polynomial.C : «expr →+* » R (mv_polynomial (fin n.succ) R)) :=\n  by\n  refine' RingHom.ext fun x => _\n  rw [RingHom.comp_apply]\n  refine' (mv_polynomial.fin_succ_equiv R n).injective (trans ((mv_polynomial.fin_succ_equiv R n).apply_symm_apply _) _)\n  simp only [mv_polynomial.fin_succ_equiv_apply, mv_polynomial.eval₂_hom_C]\n#align fin_succ_equiv_comp_C_eq_C fin_succ_equiv_comp_C_eq_C\n\n",
 "fin_succ_equiv_coeff_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- The coefficient of `m` in the `i`-th coefficient of `fin_succ_equiv R n f` equals the\n    coefficient of `finsupp.cons i m` in `f`. -/\ntheorem fin_succ_equiv_coeff_coeff (m : «expr →₀ » (fin n) ℕ) (f : mv_polynomial (fin (n + 1)) R) (i : ℕ) :\n    coeff m (polynomial.coeff (fin_succ_equiv R n f) i) = coeff (m.cons i) f :=\n  by\n  induction' f using mv_polynomial.induction_on' with j r p q hp hq generalizing i m\n  swap\n  · simp only [(fin_succ_equiv R n).map_add, polynomial.coeff_add, coeff_add, hp, hq]\n  simp only [fin_succ_equiv_apply, coe_eval₂_hom, eval₂_monomial, RingHom.coe_comp, prod_pow, polynomial.coeff_C_mul,\n    coeff_C_mul, coeff_monomial, fin.prod_univ_succ, Fin.cases_zero, Fin.cases_succ, ← ring_hom.map_prod, ←\n    RingHom.map_pow]\n  rw [← mul_boole, mul_comm (polynomial.X ^ j 0), polynomial.coeff_C_mul_X_pow]; congr 1\n  obtain rfl | hjmi := eq_or_ne j (m.cons i)\n  · simpa only [cons_zero, cons_succ, if_pos rfl, monomial_eq, C_1, one_mul, prod_pow] using coeff_monomial m m (1 : R)\n  · simp only [hjmi, if_false]\n    obtain hij | rfl := ne_or_eq i (j 0)\n    · simp only [hij, if_false, coeff_zero]\n    simp only [eq_self_iff_true, if_true]\n    have hmj : m ≠ j.tail := by\n      rintro rfl\n      rw [cons_tail] at hjmi\n      contradiction\n    simpa only [monomial_eq, C_1, one_mul, prod_pow, finsupp.tail_apply, if_neg hmj.symm] using\n      coeff_monomial m j.tail (1 : R)\n#align fin_succ_equiv_coeff_coeff fin_succ_equiv_coeff_coeff\n\n",
 "fin_succ_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem fin_succ_equiv_apply (p : mv_polynomial (fin (n + 1)) R) :\n    fin_succ_equiv R n p =\n      eval₂_hom (polynomial.C.comp (C : «expr →+* » R (mv_polynomial (fin n) R)))\n        (fun i : fin (n + 1) => Fin.cases polynomial.X (fun k => polynomial.C (X k)) i) p :=\n  by\n  rw [← fin_succ_equiv_eq]\n  rfl\n#align fin_succ_equiv_apply fin_succ_equiv_apply\n\n",
 "fin_succ_equiv_X_zero":
 "theorem fin_succ_equiv_X_zero : fin_succ_equiv R n (X 0) = polynomial.X := by simp\n#align fin_succ_equiv_X_zero fin_succ_equiv_X_zero\n\n",
 "fin_succ_equiv_X_succ":
 "theorem fin_succ_equiv_X_succ {j : fin n} : fin_succ_equiv R n (X j.succ) = polynomial.C (X j) := by simp\n#align fin_succ_equiv_X_succ fin_succ_equiv_X_succ\n\n",
 "eval_eq_eval_mv_eval'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval_eq_eval_mv_eval' (s : fin n → R) (y : R) (f : mv_polynomial (fin (n + 1)) R) :\n    eval (fin.cons y s : fin (n + 1) → R) f = polynomial.eval y (polynomial.map (eval s) (fin_succ_equiv R n f)) :=\n  by\n  -- turn this into a def `polynomial.map_alg_hom`\n  let φ : «expr →ₐ[ ] » (polynomial (mv_polynomial (fin n) R)) R (polynomial R) :=\n    { polynomial.map_ring_hom (eval s) with\n      commutes' := fun r => by\n        convert polynomial.map_C _\n        exact (eval_C _).symm }\n  show aeval (fin.cons y s : fin (n + 1) → R) f = (polynomial.aeval y).comp (φ.comp (fin_succ_equiv R n).to_alg_hom) f\n  congr 2\n  apply mv_polynomial.alg_hom_ext\n  rw [Fin.forall_fin_succ]\n  simp only [aeval_X, fin.cons_zero, alg_equiv.to_alg_hom_eq_coe, alg_hom.coe_comp, polynomial.coe_aeval_eq_eval,\n    polynomial.map_C, alg_hom.coe_mk, RingHom.toFun_eq_coe, polynomial.coe_map_ring_hom, alg_equiv.coe_alg_hom,\n    comp_app, fin_succ_equiv_apply, eval₂_hom_X', Fin.cases_zero, polynomial.map_X, polynomial.eval_X, eq_self_iff_true,\n    fin.cons_succ, Fin.cases_succ, eval_X, polynomial.eval_C, imp_true_iff, and_self_iff]\n#align eval_eq_eval_mv_eval' eval_eq_eval_mv_eval'\n\n",
 "degree_of_coeff_fin_succ_equiv":
 "theorem degree_of_coeff_fin_succ_equiv (p : mv_polynomial (fin (n + 1)) R) (j : fin n) (i : ℕ) :\n    degree_of j (polynomial.coeff (fin_succ_equiv R n p) i) ≤ degree_of j.succ p :=\n  by\n  rw [degree_of_eq_sup, degree_of_eq_sup, finset.sup_le_iff]\n  intro m hm\n  rw [← finsupp.cons_succ j i m]\n  convert finset.le_sup (support_coeff_fin_succ_equiv.1 hm)\n  rfl\n#align degree_of_coeff_fin_succ_equiv degree_of_coeff_fin_succ_equiv\n\n",
 "degree_fin_succ_equiv":
 "theorem degree_fin_succ_equiv {f : mv_polynomial (fin (n + 1)) R} (h : f ≠ 0) :\n    (fin_succ_equiv R n f).degree = degree_of 0 f :=\n  by\n  have h' : ((fin_succ_equiv R n f).support.sup fun x => x) = degree_of 0 f := by\n    rw [degree_of_eq_sup, fin_succ_equiv_support f, finset.sup_image]\n  rw [polynomial.degree, ← h', finset.coe_sup_of_nonempty (support_fin_succ_equiv_nonempty h), finset.max_eq_sup_coe]\n#align degree_fin_succ_equiv degree_fin_succ_equiv\n\n",
 "coeff_eval_eq_eval_coeff":
 "theorem coeff_eval_eq_eval_coeff (s' : fin n → R) (f : polynomial (mv_polynomial (fin n) R)) (i : ℕ) :\n    polynomial.coeff (polynomial.map (eval s') f) i = eval s' (polynomial.coeff f i) := by\n  simp only [polynomial.coeff_map]\n#align coeff_eval_eq_eval_coeff coeff_eval_eq_eval_coeff\n\n"}