{"support_fin_succ_equiv_nonempty":
 "theorem support_fin_succ_equiv_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ≠ 0) :\n    (finSuccEquiv R n f).support.nonempty := by\n  by_contra c\n  simp only [Finset.not_nonempty_iff_eq_empty, Polynomial.support_eq_empty] at c\n  have t'' : finSuccEquiv R n f ≠ 0 := by\n    let ii := (finSuccEquiv R n).symm\n    have h' : f = 0 :=\n      calc\n        f = ii (finSuccEquiv R n f) := by\n          simpa only [ii, ← AlgEquiv.invFun_eq_symm] using ((finSuccEquiv R n).left_inv f).symm\n        _ = ii 0 := by rw [c]\n        _ = 0 := by simp\n        \n    simpa [h'] using h\n  simpa [c] using h\n#align support_fin_succ_equiv_nonempty support_fin_succ_equiv_nonempty\n\n",
 "support_coeff_fin_succ_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem support_coeff_fin_succ_equiv {f : MvPolynomial (Fin (n + 1)) R} {i : ℕ} {m : «expr →₀ » (Fin n) ℕ} :\n    m ∈ (Polynomial.coeff ((finSuccEquiv R n) f) i).support ↔ Finsupp.cons i m ∈ f.support :=\n  by\n  apply iff.intro\n  · intro h\n    simpa [← fin_succ_equiv_coeff_coeff] using h\n  · intro h\n    simpa [mem_support_iff, ← fin_succ_equiv_coeff_coeff m f i] using h\n#align support_coeff_fin_succ_equiv support_coeff_fin_succ_equiv\n\n",
 "sum_to_iter_Xr":
 "@[simp]\ntheorem sum_to_iter_Xr (c : S₂) : sumToIter R S₁ S₂ (X (Sum.inr c)) = C (X c) :=\n  eval₂_X _ _ (Sum.inr c)\n#align sum_to_iter_Xr sum_to_iter_Xr\n\n",
 "sum_to_iter_Xl":
 "@[simp]\ntheorem sum_to_iter_Xl (b : S₁) : sumToIter R S₁ S₂ (X (Sum.inl b)) = X b :=\n  eval₂_X _ _ (Sum.inl b)\n#align sum_to_iter_Xl sum_to_iter_Xl\n\n",
 "sum_to_iter_C":
 "@[simp]\ntheorem sum_to_iter_C (a : R) : sumToIter R S₁ S₂ (C a) = C (C a) :=\n  eval₂_C _ _ a\n#align sum_to_iter_C sum_to_iter_C\n\n",
 "nat_degree_fin_succ_equiv":
 "theorem nat_degree_fin_succ_equiv (f : MvPolynomial (Fin (n + 1)) R) : (finSuccEquiv R n f).nat_degree = degreeOf 0 f :=\n  by\n  by_cases c : f = 0\n  · rw [c, (finSuccEquiv R n).map_zero, Polynomial.natDegree_zero, degree_of_zero]\n  · rw [Polynomial.natDegree, degree_fin_succ_equiv (by simpa only [ne.def] )]\n    simp\n#align nat_degree_fin_succ_equiv nat_degree_fin_succ_equiv\n\n",
 "map_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_trans [CommSemiring S₁] [CommSemiring S₂] [CommSemiring S₃] (e : «expr ≃+* » S₁ S₂)\n    (f : «expr ≃+* » S₂ S₃) : (mapEquiv σ e).trans (mapEquiv σ f) = mapEquiv σ (e.trans f) :=\n  RingEquiv.ext (map_map e f)\n#align map_equiv_trans map_equiv_trans\n\n",
 "map_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem map_equiv_symm [CommSemiring S₁] [CommSemiring S₂] (e : «expr ≃+* » S₁ S₂) :\n    (mapEquiv σ e).symm = mapEquiv σ e.symm :=\n  rfl\n#align map_equiv_symm map_equiv_symm\n\n",
 "map_equiv_refl":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Johan Commelin, Mario Carneiro\n-/\n@[simp]\ntheorem map_equiv_refl : mapEquiv σ (RingEquiv.refl R) = RingEquiv.refl _ :=\n  RingEquiv.ext map_id\n#align map_equiv_refl map_equiv_refl\n\n",
 "map_alg_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_alg_equiv_trans (e : «expr ≃ₐ[ ] » A₁ R A₂) (f : «expr ≃ₐ[ ] » A₂ R A₃) :\n    (mapAlgEquiv σ e).trans (mapAlgEquiv σ f) = mapAlgEquiv σ (e.trans f) :=\n  AlgEquiv.ext (map_map e f)\n#align map_alg_equiv_trans map_alg_equiv_trans\n\n",
 "map_alg_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_alg_equiv_symm (e : «expr ≃ₐ[ ] » A₁ R A₂) : (mapAlgEquiv σ e).symm = mapAlgEquiv σ e.symm :=\n  rfl\n#align map_alg_equiv_symm map_alg_equiv_symm\n\n",
 "map_alg_equiv_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem map_alg_equiv_refl : mapAlgEquiv σ (AlgEquiv.refl : «expr ≃ₐ[ ] » A₁ R A₁) = AlgEquiv.refl :=\n  AlgEquiv.ext map_id\n#align map_alg_equiv_refl map_alg_equiv_refl\n\n",
 "iter_to_sum_X":
 "theorem iter_to_sum_X (b : S₁) : iterToSum R S₁ S₂ (X b) = X (Sum.inl b) :=\n  eval₂_X _ _ _\n#align iter_to_sum_X iter_to_sum_X\n\n",
 "iter_to_sum_C_X":
 "theorem iter_to_sum_C_X (c : S₂) : iterToSum R S₁ S₂ (C (X c)) = X (Sum.inr c) :=\n  Eq.trans (eval₂_C _ _ (X c)) (eval₂_X _ _ _)\n#align iter_to_sum_C_X iter_to_sum_C_X\n\n",
 "iter_to_sum_C_C":
 "theorem iter_to_sum_C_C (a : R) : iterToSum R S₁ S₂ (C (C a)) = C a :=\n  Eq.trans (eval₂_C _ _ (C a)) (eval₂_C _ _ _)\n#align iter_to_sum_C_C iter_to_sum_C_C\n\n",
 "fin_succ_equiv_support'":
 "theorem fin_succ_equiv_support' {f : MvPolynomial (Fin (n + 1)) R} {i : ℕ} :\n    Finset.image (Finsupp.cons i) (Polynomial.coeff ((finSuccEquiv R n) f) i).support =\n      f.support.filter fun m => m 0 = i :=\n  by\n  ext m\n  rw [Finset.mem_filter, Finset.mem_image, mem_support_iff]\n  conv_lhs =>\n    congr\n    ext\n    rw [mem_support_iff, fin_succ_equiv_coeff_coeff, ne.def]\n  constructor\n  · rintro ⟨m', ⟨h, hm'⟩⟩\n    simp only [← hm']\n    exact ⟨h, by rw [cons_zero]⟩\n  · intro h\n    use tail m\n    rw [← h.2, cons_tail]\n    simp [h.1]\n#align fin_succ_equiv_support' fin_succ_equiv_support'\n\n",
 "fin_succ_equiv_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem fin_succ_equiv_support (f : MvPolynomial (Fin (n + 1)) R) :\n    (finSuccEquiv R n f).support = Finset.image (fun m : «expr →₀ » (Fin (n + 1)) ℕ => m 0) f.support :=\n  by\n  ext i\n  rw [Polynomial.mem_support_iff, Finset.mem_image, nonzero_iff_exists]\n  constructor\n  · rintro ⟨m, hm⟩\n    refine' ⟨cons i m, _, cons_zero _ _⟩\n    rw [← support_coeff_fin_succ_equiv]\n    simpa using hm\n  · rintro ⟨m, h, rfl⟩\n    refine' ⟨tail m, _⟩\n    rwa [← coeff, ← mem_support_iff, support_coeff_fin_succ_equiv, cons_tail]\n#align fin_succ_equiv_support fin_succ_equiv_support\n\n",
 "fin_succ_equiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n-- this speeds up typeclass search in the lemma below\ntheorem fin_succ_equiv_eq :\n    (finSuccEquiv R n : «expr →+* » (MvPolynomial (Fin (n + 1)) R) (Polynomial (MvPolynomial (Fin n) R))) =\n      eval₂Hom (Polynomial.C.comp (C : «expr →+* » R (MvPolynomial (Fin n) R))) fun i : Fin (n + 1) =>\n        Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i :=\n  by\n  ext : 2\n  · simp only [finSuccEquiv, option_equiv_left_apply, aeval_C, AlgEquiv.coe_trans, RingHom.coe_coe, coe_eval₂_hom,\n      comp_app, rename_equiv_apply, eval₂_C, RingHom.coe_comp, rename_C]\n    rfl\n  · intro i\n    refine' Fin.cases _ _ i <;> simp [finSuccEquiv]\n#align fin_succ_equiv_eq fin_succ_equiv_eq\n\n",
 "fin_succ_equiv_comp_C_eq_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem fin_succ_equiv_comp_C_eq_C {R : Type u} [CommSemiring R] (n : ℕ) :\n    (↑(MvPolynomial.finSuccEquiv R n).symm : «expr →+* » (Polynomial (MvPolynomial (Fin n) R)) _).comp\n        (Polynomial.C.comp MvPolynomial.C) =\n      (MvPolynomial.C : «expr →+* » R (MvPolynomial (Fin n.succ) R)) :=\n  by\n  refine' RingHom.ext fun x => _\n  rw [RingHom.comp_apply]\n  refine' (MvPolynomial.finSuccEquiv R n).injective (trans ((MvPolynomial.finSuccEquiv R n).apply_symm_apply _) _)\n  simp only [MvPolynomial.finSuccEquiv_apply, MvPolynomial.eval₂Hom_C]\n#align fin_succ_equiv_comp_C_eq_C fin_succ_equiv_comp_C_eq_C\n\n",
 "fin_succ_equiv_coeff_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- The coefficient of `m` in the `i`-th coefficient of `fin_succ_equiv R n f` equals the\n    coefficient of `finsupp.cons i m` in `f`. -/\ntheorem fin_succ_equiv_coeff_coeff (m : «expr →₀ » (Fin n) ℕ) (f : MvPolynomial (Fin (n + 1)) R) (i : ℕ) :\n    coeff m (Polynomial.coeff (finSuccEquiv R n f) i) = coeff (m.cons i) f :=\n  by\n  induction' f using MvPolynomial.induction_on' with j r p q hp hq generalizing i m\n  swap\n  · simp only [(finSuccEquiv R n).map_add, Polynomial.coeff_add, coeff_add, hp, hq]\n  simp only [fin_succ_equiv_apply, coe_eval₂_hom, eval₂_monomial, RingHom.coe_comp, prod_pow, Polynomial.coeff_C_mul,\n    coeff_C_mul, coeff_monomial, Fin.prod_univ_succ, Fin.cases_zero, Fin.cases_succ, ← RingHom.map_prod, ←\n    RingHom.map_pow]\n  rw [← mul_boole, mul_comm (Polynomial.X ^ j 0), Polynomial.coeff_C_mul_X_pow]; congr 1\n  obtain rfl | hjmi := eq_or_ne j (m.cons i)\n  · simpa only [cons_zero, cons_succ, if_pos rfl, monomial_eq, C_1, one_mul, prod_pow] using coeff_monomial m m (1 : R)\n  · simp only [hjmi, if_false]\n    obtain hij | rfl := ne_or_eq i (j 0)\n    · simp only [hij, if_false, coeff_zero]\n    simp only [eq_self_iff_true, if_true]\n    have hmj : m ≠ j.tail := by\n      rintro rfl\n      rw [cons_tail] at hjmi\n      contradiction\n    simpa only [monomial_eq, C_1, one_mul, prod_pow, Finsupp.tail_apply, if_neg hmj.symm] using\n      coeff_monomial m j.tail (1 : R)\n#align fin_succ_equiv_coeff_coeff fin_succ_equiv_coeff_coeff\n\n",
 "fin_succ_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem fin_succ_equiv_apply (p : MvPolynomial (Fin (n + 1)) R) :\n    finSuccEquiv R n p =\n      eval₂Hom (Polynomial.C.comp (C : «expr →+* » R (MvPolynomial (Fin n) R)))\n        (fun i : Fin (n + 1) => Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i) p :=\n  by\n  rw [← fin_succ_equiv_eq]\n  rfl\n#align fin_succ_equiv_apply fin_succ_equiv_apply\n\n",
 "fin_succ_equiv_X_zero":
 "theorem fin_succ_equiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X := by simp\n#align fin_succ_equiv_X_zero fin_succ_equiv_X_zero\n\n",
 "fin_succ_equiv_X_succ":
 "theorem fin_succ_equiv_X_succ {j : Fin n} : finSuccEquiv R n (X j.succ) = Polynomial.C (X j) := by simp\n#align fin_succ_equiv_X_succ fin_succ_equiv_X_succ\n\n",
 "eval_eq_eval_mv_eval'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval_eq_eval_mv_eval' (s : Fin n → R) (y : R) (f : MvPolynomial (Fin (n + 1)) R) :\n    eval (Fin.cons y s : Fin (n + 1) → R) f = Polynomial.eval y (Polynomial.map (eval s) (finSuccEquiv R n f)) :=\n  by\n  -- turn this into a def `polynomial.map_alg_hom`\n  let φ : «expr →ₐ[ ] » (polynomial (MvPolynomial (Fin n) R)) R (polynomial R) :=\n    { Polynomial.mapRingHom (eval s) with\n      commutes' := fun r => by\n        convert Polynomial.map_C _\n        exact (eval_C _).symm }\n  show aeval (Fin.cons y s : Fin (n + 1) → R) f = (Polynomial.aeval y).comp (φ.comp (finSuccEquiv R n).to_alg_hom) f\n  congr 2\n  apply MvPolynomial.algHom_ext\n  rw [Fin.forall_fin_succ]\n  simp only [aeval_X, Fin.cons_zero, AlgEquiv.toAlgHom_eq_coe, AlgHom.coe_comp, Polynomial.coe_aeval_eq_eval,\n    Polynomial.map_C, AlgHom.coe_mks, RingHom.toFun_eq_coe, Polynomial.coe_mapRingHom, AlgEquiv.coe_algHom, comp_app,\n    fin_succ_equiv_apply, eval₂_hom_X', Fin.cases_zero, Polynomial.map_X, Polynomial.eval_X, eq_self_iff_true,\n    Fin.cons_succ, Fin.cases_succ, eval_X, Polynomial.eval_C, imp_true_iff, and_self_iff]\n#align eval_eq_eval_mv_eval' eval_eq_eval_mv_eval'\n\n",
 "degree_of_coeff_fin_succ_equiv":
 "theorem degree_of_coeff_fin_succ_equiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (i : ℕ) :\n    degreeOf j (Polynomial.coeff (finSuccEquiv R n p) i) ≤ degreeOf j.succ p :=\n  by\n  rw [degree_of_eq_sup, degree_of_eq_sup, Finset.sup_le_iff]\n  intro m hm\n  rw [← Finsupp.cons_succ j i m]\n  convert Finset.le_sup (support_coeff_fin_succ_equiv.1 hm)\n  rfl\n#align degree_of_coeff_fin_succ_equiv degree_of_coeff_fin_succ_equiv\n\n",
 "degree_fin_succ_equiv":
 "theorem degree_fin_succ_equiv {f : MvPolynomial (Fin (n + 1)) R} (h : f ≠ 0) :\n    (finSuccEquiv R n f).degree = degreeOf 0 f :=\n  by\n  have h' : ((finSuccEquiv R n f).support.sup fun x => x) = degree_of 0 f := by\n    rw [degree_of_eq_sup, fin_succ_equiv_support f, Finset.sup_image]\n  rw [Polynomial.degree, ← h', Finset.coe_sup_of_nonempty (support_fin_succ_equiv_nonempty h), Finset.max_eq_sup_coe]\n#align degree_fin_succ_equiv degree_fin_succ_equiv\n\n",
 "coeff_eval_eq_eval_coeff":
 "theorem coeff_eval_eq_eval_coeff (s' : Fin n → R) (f : Polynomial (MvPolynomial (Fin n) R)) (i : ℕ) :\n    Polynomial.coeff (Polynomial.map (eval s') f) i = eval s' (Polynomial.coeff f i) := by\n  simp only [Polynomial.coeff_map]\n#align coeff_eval_eq_eval_coeff coeff_eval_eq_eval_coeff\n\n"}