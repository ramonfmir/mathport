{"mk_derivationₗ_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem mk_derivationₗ_monomial (f : σ → A) (s : «expr →₀ » σ ℕ) (r : R) :\n    mk_derivationₗ R f (monomial s r) =\n      «expr • » r (s.sum fun i k => «expr • » (monomial (s - finsupp.single i 1) (k : R)) (f i)) :=\n  sum_monomial_eq <| linear_map.map_zero _\n#align mk_derivationₗ_monomial mk_derivationₗ_monomial\n\n",
 "mk_derivationₗ_X":
 "theorem mk_derivationₗ_X (f : σ → A) (i : σ) : mk_derivationₗ R f (X i) = f i :=\n  (mk_derivationₗ_monomial f _ _).trans <| by simp\n#align mk_derivationₗ_X mk_derivationₗ_X\n\n",
 "mk_derivationₗ_C":
 "theorem mk_derivationₗ_C (f : σ → A) (r : R) : mk_derivationₗ R f (C r) = 0 :=\n  (mk_derivationₗ_monomial f _ _).trans (smul_zero _)\n#align mk_derivationₗ_C mk_derivationₗ_C\n\n",
 "mk_derivation_monomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk_derivation_monomial (f : σ → A) (s : «expr →₀ » σ ℕ) (r : R) :\n    mk_derivation R f (monomial s r) =\n      «expr • » r (s.sum fun i k => «expr • » (monomial (s - finsupp.single i 1) (k : R)) (f i)) :=\n  mk_derivationₗ_monomial f s r\n#align mk_derivation_monomial mk_derivation_monomial\n\n",
 "mk_derivation_X":
 "@[simp]\ntheorem mk_derivation_X (f : σ → A) (i : σ) : mk_derivation R f (X i) = f i :=\n  mk_derivationₗ_X f i\n#align mk_derivation_X mk_derivation_X\n\n",
 "leibniz_iff_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem leibniz_iff_X (D : «expr →ₗ[ ] » (mv_polynomial σ R) R A) (h₁ : D 1 = 0) :\n    (∀ p q, D (p * q) = «expr • » p (D q) + «expr • » q (D p)) ↔\n      ∀ s i,\n        D (monomial s 1 * X i) =\n          «expr • » (monomial s 1 : mv_polynomial σ R) (D (X i)) +\n            «expr • » (X i : mv_polynomial σ R) (D (monomial s 1)) :=\n  by\n  refine' ⟨fun H p i => H _ _, fun H => _⟩\n  have hC : ∀ r, D (C r) = 0 := by\n    intro r\n    rw [C_eq_smul_one, D.map_smul, h₁, smul_zero]\n  have : ∀ p i, D (p * X i) = «expr • » p (D (X i)) + «expr • » (X i : mv_polynomial σ R) (D p) :=\n    by\n    intro p i\n    induction' p using mv_polynomial.induction_on' with s r p q hp hq\n    · rw [← mul_one r, ← C_mul_monomial, mul_assoc, C_mul', D.map_smul, H, C_mul', smul_assoc, smul_add, D.map_smul,\n        smul_comm r (X i)]\n      infer_instance\n    · rw [add_mul, map_add, map_add, hp, hq, add_smul, smul_add, add_add_add_comm]\n  intro p q\n  induction q using mv_polynomial.induction_on\n  case h_C c => rw [mul_comm, C_mul', hC, smul_zero, zero_add, D.map_smul, C_eq_smul_one, smul_one_smul]\n  case h_add q₁ q₂ h₁ h₂ => simp only [mul_add, map_add, h₁, h₂, smul_add, add_smul]; abel\n  case h_X q i hq => simp only [this, ← mul_assoc, hq, mul_smul, smul_add, smul_comm (X i), add_assoc]\n#align leibniz_iff_X leibniz_iff_X\n\n",
 "derivation_ext":
 "@[ext]\ntheorem derivation_ext {D₁ D₂ : derivation R (mv_polynomial σ R) A} (h : ∀ i, D₁ (X i) = D₂ (X i)) : D₁ = D₂ :=\n  derivation.ext fun f => derivation_eq_of_forall_mem_vars fun i _ => h i\n#align derivation_ext derivation_ext\n\n",
 "derivation_eq_zero_of_forall_mem_vars":
 "theorem derivation_eq_zero_of_forall_mem_vars {D : derivation R (mv_polynomial σ R) A} {f : mv_polynomial σ R}\n    (h : ∀ i ∈ f.vars, D (X i) = 0) : D f = 0 :=\n  show D f = (0 : derivation R (mv_polynomial σ R) A) f from derivation_eq_of_forall_mem_vars h\n#align derivation_eq_zero_of_forall_mem_vars derivation_eq_zero_of_forall_mem_vars\n\n",
 "derivation_eq_on_supported":
 "/-- If two derivations agree on `X i`, `i ∈ s`, then they agree on all polynomials from\n`mv_polynomial.supported R s`. -/\ntheorem derivation_eq_on_supported {D₁ D₂ : derivation R (mv_polynomial σ R) A} {s : set σ}\n    (h : Set.EqOn (D₁ ∘ X) (D₂ ∘ X) s) {f : mv_polynomial σ R} (hf : f ∈ supported R s) : D₁ f = D₂ f :=\n  derivation.eq_on_adjoin (Set.ball_image_iff.2 h) hf\n#align derivation_eq_on_supported derivation_eq_on_supported\n\n",
 "derivation_eq_of_forall_mem_vars":
 "theorem derivation_eq_of_forall_mem_vars {D₁ D₂ : derivation R (mv_polynomial σ R) A} {f : mv_polynomial σ R}\n    (h : ∀ i ∈ f.vars, D₁ (X i) = D₂ (X i)) : D₁ f = D₂ f :=\n  derivation_eq_on_supported h f.mem_supported_vars\n#align derivation_eq_of_forall_mem_vars derivation_eq_of_forall_mem_vars\n\n",
 "derivation_C_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem derivation_C_mul (D : derivation R (mv_polynomial σ R) A) (a : R) (f : mv_polynomial σ R) :\n    D (C a * f) = «expr • » a (D f) := by rw [C_mul', D.map_smul]\n#align derivation_C_mul derivation_C_mul\n\n",
 "derivation_C":
 "@[simp]\ntheorem derivation_C (D : derivation R (mv_polynomial σ R) A) (a : R) : D (C a) = 0 :=\n  D.map_algebra_map a\n#align derivation_C derivation_C\n\n"}