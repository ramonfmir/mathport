{"num_pos_iff_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- Extra instances to short-circuit type class resolution\ntheorem num_pos_iff_pos {a : exprℚ} : 0 < a.num ↔ 0 < a :=\n  lt_iff_lt_of_le_iff_le <| by simpa [(by cases a <;> rfl : (-a).num = -a.num)] using @num_nonneg_iff_zero_le (-a)\n#align num_pos_iff_pos num_pos_iff_pos\n\n",
 "num_nonneg_iff_zero_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem num_nonneg_iff_zero_le : ∀ {a : exprℚ}, 0 ≤ a.num ↔ 0 ≤ a\n  | ⟨n, d, h, c⟩ => @nonneg_iff_zero_le ⟨n, d, h, c⟩\n#align num_nonneg_iff_zero_le num_nonneg_iff_zero_le\n\n",
 "nonneg_total":
 "protected theorem nonneg_total : Rat.Nonneg a ∨ Rat.Nonneg (-a) := by\n  cases' a with n <;> exact or.imp_right neg_nonneg_of_nonpos (le_total 0 n)\n#align nonneg_total nonneg_total\n\n",
 "nonneg_mul":
 "protected theorem nonneg_mul {a b} : Rat.Nonneg a → Rat.Nonneg b → Rat.Nonneg (a * b) :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ =>\n      by\n      have d₁0 : 0 < (d₁ : ℤ) := Int.coe_nat_pos.2 (nat.pos_of_ne_zero h₁)\n      have d₂0 : 0 < (d₂ : ℤ) := Int.coe_nat_pos.2 (nat.pos_of_ne_zero h₂)\n      simp (config := { contextual := true }) [d₁0, d₂0, h₁, h₂, mul_pos d₁0 d₂0, mul_nonneg]\n#align nonneg_mul nonneg_mul\n\n",
 "nonneg_iff_zero_le":
 "theorem nonneg_iff_zero_le {a} : Rat.Nonneg a ↔ 0 ≤ a :=\n  show Rat.Nonneg a ↔ Rat.Nonneg (a - 0) by simp\n#align nonneg_iff_zero_le nonneg_iff_zero_le\n\n",
 "nonneg_antisymm":
 "protected theorem nonneg_antisymm {a} : Rat.Nonneg a → Rat.Nonneg (-a) → a = 0 :=\n  numDenCasesOn' a fun n d h =>\n    by\n    have d0 : 0 < (d : ℤ) := Int.coe_nat_pos.2 (nat.pos_of_ne_zero h)\n    simp [d0, h]\n    exact fun h₁ h₂ => le_antisymm h₂ h₁\n#align nonneg_antisymm nonneg_antisymm\n\n",
 "nonneg_add":
 "protected theorem nonneg_add {a b} : Rat.Nonneg a → Rat.Nonneg b → Rat.Nonneg (a + b) :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ =>\n      by\n      have d₁0 : 0 < (d₁ : ℤ) := Int.coe_nat_pos.2 (nat.pos_of_ne_zero h₁)\n      have d₂0 : 0 < (d₂ : ℤ) := Int.coe_nat_pos.2 (nat.pos_of_ne_zero h₂)\n      simp [d₁0, d₂0, h₁, h₂, mul_pos d₁0 d₂0]\n      intro n₁0 n₂0\n      apply add_nonneg <;> apply mul_nonneg <;> · first |assumption|apply Int.ofNat_zero_le\n#align nonneg_add nonneg_add\n\n",
 "mul_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print mul_nonneg /-\nprotected theorem mul_nonneg {a b : exprℚ} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b := by\n  rw [← nonneg_iff_zero_le] at ha hb⊢ <;> exact Rat.nonneg_mul ha hb\n#align mul_nonneg mul_nonneg\n-/\n\n",
 "mk_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp]\ntheorem mk_nonneg (a : ℤ) {b : ℤ} (h : 0 < b) : (rat.mk a b).nonneg ↔ 0 ≤ a :=\n  by\n  generalize ha : rat.mk a b = x; cases' x with n₁ d₁ h₁ c₁; rw [num_denom'] at ha\n  simp [Rat.Nonneg]\n  have d0 := Int.ofNat_lt.2 h₁\n  have := (mk_eq (ne_of_gt h) (ne_of_gt d0)).1 ha\n  constructor <;> intro h₂\n  · apply nonneg_of_mul_nonneg_left _ d0\n    rw [this]\n    exact mul_nonneg h₂ (le_of_lt h)\n  · apply nonneg_of_mul_nonneg_left _ h\n    rw [← this]\n    exact mul_nonneg h₂ (Int.ofNat_zero_le _)\n#align mk_nonneg mk_nonneg\n\n",
 "lt_one_iff_num_lt_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem lt_one_iff_num_lt_denom {q : exprℚ} : q < 1 ↔ q.num < q.denom := by simp [Rat.lt_def]\n#align lt_one_iff_num_lt_denom lt_one_iff_num_lt_denom\n\n",
 "lt_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprotected theorem lt_def {p q : exprℚ} : p < q ↔ p.num * q.denom < q.num * p.denom :=\n  by\n  rw [lt_iff_le_and_ne, Rat.le_def']\n  suffices p ≠ q ↔ p.num * q.denom ≠ q.num * p.denom\n    by\n    constructor <;> intro h\n    · exact lt_iff_le_and_ne.elim_right ⟨h.left, this.elim_left h.right⟩\n    · have tmp := lt_iff_le_and_ne.elim_left h\n      exact ⟨tmp.left, this.elim_right tmp.right⟩\n  exact not_iff_not.elim_right eq_iff_mul_eq_mul\n#align lt_def lt_def\n\n",
 "le_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print le_trans /-\nprotected theorem le_trans {a b c : exprℚ} (hab : a ≤ b) (hbc : b ≤ c) : a ≤ c :=\n  by\n  have : Rat.Nonneg (b - a + (c - b)) := Rat.nonneg_add hab hbc\n  simpa [sub_eq_add_neg, add_comm, add_left_comm]\n#align le_trans le_trans\n-/\n\n",
 "le_total":
 "#print le_total /-\nprotected theorem le_total : a ≤ b ∨ b ≤ a := by have := Rat.nonneg_total (b - a) <;> rwa [neg_sub] at this\n#align le_total le_total\n-/\n\n",
 "le_refl":
 "#print le_refl /-\nprotected theorem le_refl : a ≤ a :=\n  show Rat.Nonneg (a - a) by rw [sub_self] <;> exact le_refl (0 : ℤ)\n#align le_refl le_refl\n-/\n\n",
 "le_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- Extra instances to short-circuit type class resolution\nprotected theorem le_def' {p q : exprℚ} : p ≤ q ↔ p.num * q.denom ≤ q.num * p.denom :=\n  by\n  rw [← @num_denom q, ← @num_denom p]\n  conv_rhs => simp only [num_denom]\n  exact Rat.le_def (by exact_mod_cast p.pos) (by exact_mod_cast q.pos)\n#align le_def' le_def'\n\n",
 "le_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\nprotected theorem le_def {a b c d : ℤ} (b0 : 0 < b) (d0 : 0 < d) : rat.mk a b ≤ rat.mk c d ↔ a * d ≤ c * b :=\n  by\n  show Rat.Nonneg _ ↔ _\n  rw [← sub_nonneg]\n  simp [sub_eq_add_neg, ne_of_gt b0, ne_of_gt d0, mul_pos d0 b0]\n#align le_def le_def\n\n",
 "le_antisymm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print le_antisymm /-\nprotected theorem le_antisymm {a b : exprℚ} (hab : a ≤ b) (hba : b ≤ a) : a = b :=\n  by\n  have := eq_neg_of_add_eq_zero_left (Rat.nonneg_antisymm hba <| by rwa [← sub_eq_add_neg, neg_sub])\n  rwa [neg_neg] at this\n#align le_antisymm le_antisymm\n-/\n\n",
 "div_lt_div_iff_mul_lt_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem div_lt_div_iff_mul_lt_mul {a b c d : ℤ} (b_pos : 0 < b) (d_pos : 0 < d) :\n    (a : exprℚ) / b < c / d ↔ a * d < c * b :=\n  by\n  simp only [lt_iff_le_not_le]\n  apply and_congr\n  · simp [div_num_denom, Rat.le_def b_pos d_pos]\n  · apply not_congr\n    simp [div_num_denom, Rat.le_def d_pos b_pos]\n#align div_lt_div_iff_mul_lt_mul div_lt_div_iff_mul_lt_mul\n\n",
 "add_le_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print add_le_add_left /-\nprotected theorem add_le_add_left {a b c : exprℚ} : c + a ≤ c + b ↔ a ≤ b := by\n  unfold LE.le Rat.le' <;> rw [add_sub_add_left_eq_sub]\n#align add_le_add_left add_le_add_left\n-/\n\n",
 "abs_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem abs_def (q : exprℚ) : |q| = rat.mk q.num.nat_abs q.denom :=\n  by\n  cases' le_total q 0 with hq hq\n  · rw [abs_of_nonpos hq]\n    rw [← @num_denom q, ← mk_zero_one, Rat.le_def (Int.coe_nat_pos.2 q.pos) zero_lt_one, mul_one,\n      MulZeroClass.zero_mul] at hq\n    rw [Int.ofNat_natAbs_of_nonpos hq, ← neg_def, num_denom]\n  · rw [abs_of_nonneg hq]\n    rw [← @num_denom q, ← mk_zero_one, Rat.le_def zero_lt_one (Int.coe_nat_pos.2 q.pos), mul_one,\n      MulZeroClass.zero_mul] at hq\n    rw [Int.natAbs_of_nonneg hq, num_denom]\n#align abs_def abs_def\n\n"}