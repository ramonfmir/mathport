{"substr_num_denom'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem substr_num_denom' (q r : exprℚ) :\n    (q - r).num * q.denom * r.denom = (q.num * r.denom - r.num * q.denom) * (q - r).denom := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, ← neg_mul, ← num_neg_eq_neg_num, ← denom_neg_eq_denom r, add_num_denom' q (-r)]\n#align substr_num_denom' substr_num_denom'\n\n",
 "pnat_denom_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem pnat_denom_zero : (0 : exprℚ).pnat_denom = 1 :=\n  rfl\n#align pnat_denom_zero pnat_denom_zero\n\n",
 "pnat_denom_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem pnat_denom_one : (1 : exprℚ).pnat_denom = 1 :=\n  rfl\n#align pnat_denom_one pnat_denom_one\n\n",
 "pnat_denom_eq_iff_denom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem pnat_denom_eq_iff_denom_eq {x : exprℚ} {n : «exprℕ+»} : x.pnat_denom = n ↔ x.denom = ↑n :=\n  Subtype.ext_iff\n#align pnat_denom_eq_iff_denom_eq pnat_denom_eq_iff_denom_eq\n\n",
 "num_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem num_mk (n d : ℤ) : (rat.mk n d).num = d.sign * n / n.gcd d := by\n  rcases d with ((_ | _) | _) <;>\n    simp [rat.mk, mk_nat, mk_pnat, Nat.succPNat, int.sign, int.gcd, -Nat.cast_succ, -Int.ofNat_succ, Int.zero_div]\n#align num_mk num_mk\n\n",
 "num_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\ntheorem num_dvd (a) {b : ℤ} (b0 : b ≠ 0) : (rat.mk a b).num ∣ a :=\n  by\n  cases' e : rat.mk a b with n d h c\n  rw [Rat.num_den', Rat.divInt_eq_iff b0 (ne_of_gt (Int.coe_nat_pos.2 h))] at e\n  refine' Int.natAbs_dvd.1 <| Int.dvd_natAbs.1 <| Int.coe_nat_dvd.2 <| c.dvd_of_dvd_mul_right _\n  have := congr_arg Int.natAbs e\n  simp only [Int.natAbs_mul, Int.natAbs_ofNat] at this; simp [this]\n#align num_dvd num_dvd\n\n",
 "num_div_eq_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem num_div_eq_of_coprime {a b : ℤ} (hb0 : 0 < b) (h : Nat.coprime a.nat_abs b.nat_abs) : (a / b : exprℚ).num = a :=\n  by\n  lift b to ℕ using le_of_lt hb0\n  norm_cast  at hb0 h\n  rw [← Rat.divInt_eq_div, ← [anonymous] a b hb0, [anonymous], PNat.mk_coe, h.gcd_eq_one, Int.ofNat_one, Int.div_one]\n#align num_div_eq_of_coprime num_div_eq_of_coprime\n\n",
 "num_denom_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem num_denom_mk {q : exprℚ} {n d : ℤ} (hd : d ≠ 0) (qdf : q = rat.mk n d) :\n    ∃ c : ℤ, n = c * q.num ∧ d = c * q.denom :=\n  by\n  obtain rfl | hn := eq_or_ne n 0\n  · simp [qdf]\n  have : q.num * d = n * ↑q.denom := by\n    refine' (Rat.divInt_eq_iff _ hd).mp _\n    · exact int.coe_nat_ne_zero.mpr (Rat.den_nz _)\n    · rwa [num_denom]\n  have hqdn : q.num ∣ n := by\n    rw [qdf]\n    exact Rat.num_dvd _ hd\n  refine' ⟨n / q.num, _, _⟩\n  · rw [Int.ediv_mul_cancel hqdn]\n  · refine' Int.eq_mul_div_of_mul_eq_mul_of_dvd_left _ hqdn this\n    rw [qdf]\n    exact Rat.num_ne_zero_of_ne_zero ((mk_ne_zero hd).mpr hn)\n#align num_denom_mk num_denom_mk\n\n",
 "mul_self_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mul_self_num (q : exprℚ) : (q * q).num = q.num * q.num := by\n  rw [mul_num, Int.natAbs_mul, Nat.coprime.gcd_eq_one, Int.ofNat_one, Int.div_one] <;>\n    exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)\n#align mul_self_num mul_self_num\n\n",
 "mul_self_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mul_self_denom (q : exprℚ) : (q * q).denom = q.denom * q.denom := by\n  rw [Rat.mul_den, Int.natAbs_mul, Nat.coprime.gcd_eq_one, nat.div_one] <;>\n    exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)\n#align mul_self_denom mul_self_denom\n\n",
 "mul_num_denom'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mul_num_denom' (q r : exprℚ) : (q * r).num * q.denom * r.denom = q.num * r.num * (q * r).denom :=\n  by\n  let s := rat.mk (q.num * r.num) (q.denom * r.denom : ℤ)\n  have hs : (q.denom * r.denom : ℤ) ≠ 0 := int.coe_nat_ne_zero_iff_pos.mpr (mul_pos q.pos r.pos)\n  obtain ⟨c, ⟨c_mul_num, c_mul_denom⟩⟩ := exists_eq_mul_div_num_and_eq_mul_div_denom (q.num * r.num) hs\n  rw [c_mul_num, mul_assoc, mul_comm]\n  nth_rw 1 [c_mul_denom]\n  repeat' rw [mul_assoc]\n  apply mul_eq_mul_left_iff.2\n  rw [or_iff_not_imp_right]\n  intro c_pos\n  have h : _ = s :=\n    @mul_def q.num q.denom r.num r.denom (int.coe_nat_ne_zero_iff_pos.mpr q.pos) (int.coe_nat_ne_zero_iff_pos.mpr r.pos)\n  rw [num_denom, num_denom] at h\n  rw [h]\n  rw [mul_comm]\n  apply rat.eq_iff_mul_eq_mul.mp\n  rw [← mk_eq_div]\n#align mul_num_denom' mul_num_denom'\n\n",
 "mul_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mul_num (q₁ q₂ : exprℚ) :\n    (q₁ * q₂).num = q₁.num * q₂.num / Nat.gcd (q₁.num * q₂.num).nat_abs (q₁.denom * q₂.denom) := by\n  cases q₁ <;> cases q₂ <;> rfl\n#align mul_num mul_num\n\n",
 "mul_denom_eq_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem mul_denom_eq_num {q : exprℚ} : q * q.denom = q.num :=\n  by\n  suffices mk q.num ↑q.denom * mk (↑q.denom) 1 = mk q.num 1\n    by\n    conv => pattern (occs := 1) q <;> (rw [← @num_denom q])\n    rwa [coe_int_eq_mk, coe_nat_eq_mk]\n  have : (q.denom : ℤ) ≠ 0 := ne_of_gt (by exact_mod_cast q.pos)\n  rw [Rat.mul_def' this one_ne_zero, mul_comm (q.denom : ℤ) 1, div_mk_div_cancel_left this]\n#align mul_denom_eq_num mul_denom_eq_num\n\n",
 "mul_denom_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mul_denom_dvd (q₁ q₂ : exprℚ) : (q₁ * q₂).denom ∣ q₁.denom * q₂.denom :=\n  by\n  cases q₁\n  cases q₂\n  apply mk_pnat_denom_dvd\n#align mul_denom_dvd mul_denom_dvd\n\n",
 "mul_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mul_denom (q₁ q₂ : exprℚ) :\n    (q₁ * q₂).denom = q₁.denom * q₂.denom / Nat.gcd (q₁.num * q₂.num).nat_abs (q₁.denom * q₂.denom) := by\n  cases q₁ <;> cases q₂ <;> rfl\n#align mul_denom mul_denom\n\n",
 "mk_pnat_pnat_denom_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem mk_pnat_pnat_denom_eq (x : exprℚ) : [anonymous] x.num x.pnat_denom = x := by\n  rw [pnat_denom, mk_pnat_eq, num_denom]\n#align mk_pnat_pnat_denom_eq mk_pnat_pnat_denom_eq\n\n",
 "mk_pnat_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem mk_pnat_num (n : ℤ) (d : «exprℕ+») : ([anonymous] n d).num = n / Nat.gcd n.nat_abs d := by cases d <;> rfl\n#align mk_pnat_num mk_pnat_num\n\n",
 "mk_pnat_denom_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem mk_pnat_denom_dvd (n : ℤ) (d : «exprℕ+») : ([anonymous] n d).denom ∣ d.1 :=\n  by\n  rw [mk_pnat_denom]\n  apply Nat.div_dvd_of_dvd\n  apply Nat.gcd_dvd_right\n#align mk_pnat_denom_dvd mk_pnat_denom_dvd\n\n",
 "mk_pnat_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem mk_pnat_denom (n : ℤ) (d : «exprℕ+») : ([anonymous] n d).denom = d / Nat.gcd n.nat_abs d := by cases d <;> rfl\n#align mk_pnat_denom mk_pnat_denom\n\n",
 "inv_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print inv_neg /-\nprotected theorem inv_neg (q : exprℚ) : (-q)⁻¹ = -q⁻¹ :=\n  by\n  rw [← @num_denom q]\n  simp [-num_denom]\n#align inv_neg inv_neg\n-/\n\n",
 "inv_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem inv_def' {q : exprℚ} : q⁻¹ = (q.denom : exprℚ) / q.num :=\n  by\n  conv_lhs => rw [← @num_denom q]\n  rw [inv_def, mk_eq_div, Int.cast_ofNat]\n#align inv_def' inv_def'\n\n",
 "inv_coe_nat_num_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem inv_coe_nat_num_of_pos {a : ℕ} (ha0 : 0 < a) : (a : exprℚ)⁻¹.num = 1 :=\n  inv_coe_int_num_of_pos (by exact_mod_cast ha0 : 0 < (a : ℤ))\n#align inv_coe_nat_num_of_pos inv_coe_nat_num_of_pos\n\n",
 "inv_coe_nat_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem inv_coe_nat_num (a : ℕ) : (a : exprℚ)⁻¹.num = int.sign a :=\n  inv_coe_int_num a\n#align inv_coe_nat_num inv_coe_nat_num\n\n",
 "inv_coe_nat_denom_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem inv_coe_nat_denom_of_pos {a : ℕ} (ha0 : 0 < a) : (a : exprℚ)⁻¹.denom = a :=\n  by\n  rw [← Int.ofNat_inj, ← Int.cast_ofNat a, inv_coe_int_denom_of_pos]\n  rwa [← Nat.cast_zero, Nat.cast_lt]\n#align inv_coe_nat_denom_of_pos inv_coe_nat_denom_of_pos\n\n",
 "inv_coe_nat_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem inv_coe_nat_denom (a : ℕ) : (a : exprℚ)⁻¹.denom = if a = 0 then 1 else a := by simpa using inv_coe_int_denom a\n#align inv_coe_nat_denom inv_coe_nat_denom\n\n",
 "inv_coe_int_num_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem inv_coe_int_num_of_pos {a : ℤ} (ha0 : 0 < a) : (a : exprℚ)⁻¹.num = 1 :=\n  by\n  rw [Rat.inv_def'', Rat.coe_int_num, Rat.coe_int_den, Nat.cast_one, ← Int.cast_one]\n  apply num_div_eq_of_coprime ha0\n  rw [Int.natAbs_one]\n  exact Nat.coprime_one_left _\n#align inv_coe_int_num_of_pos inv_coe_int_num_of_pos\n\n",
 "inv_coe_int_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem inv_coe_int_num (a : ℤ) : (a : exprℚ)⁻¹.num = int.sign a := by\n  induction a using Int.induction_on <;>\n    simp [← Int.negSucc_coe', Int.negSucc_coe, -neg_add_rev, Rat.inv_neg, Int.ofNat_add_one_out, -Nat.cast_succ,\n      inv_coe_nat_num_of_pos, -Int.cast_negSucc, @eq_comm ℤ 1, int.sign_eq_one_of_pos]\n#align inv_coe_int_num inv_coe_int_num\n\n",
 "inv_coe_int_denom_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem inv_coe_int_denom_of_pos {a : ℤ} (ha0 : 0 < a) : ((a : exprℚ)⁻¹.denom : ℤ) = a :=\n  by\n  rw [Rat.inv_def'', Rat.coe_int_num, Rat.coe_int_den, Nat.cast_one, ← Int.cast_one]\n  apply denom_div_eq_of_coprime ha0\n  rw [Int.natAbs_one]\n  exact Nat.coprime_one_left _\n#align inv_coe_int_denom_of_pos inv_coe_int_denom_of_pos\n\n",
 "inv_coe_int_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem inv_coe_int_denom (a : ℤ) : (a : exprℚ)⁻¹.denom = if a = 0 then 1 else a.nat_abs := by\n  induction a using Int.induction_on <;>\n    simp [← Int.negSucc_coe', Int.negSucc_coe, -neg_add_rev, Rat.inv_neg, Int.ofNat_add_one_out, -Nat.cast_succ,\n      inv_coe_nat_denom_of_pos, -Int.cast_negSucc]\n#align inv_coe_int_denom inv_coe_int_denom\n\n",
 "forall":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprotected theorem forall {p : exprℚ → Prop} : (∀ r, p r) ↔ ∀ a b : ℤ, p (a / b) :=\n  ⟨fun h _ _ => h _, fun h q => show q = q.num / q.denom by simp [Rat.div_num_den].symm ▸ h q.1 q.2⟩\n#align forall forall\n\n",
 "exists_eq_mul_div_num_and_eq_mul_div_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem exists_eq_mul_div_num_and_eq_mul_div_denom (n : ℤ) {d : ℤ} (d_ne_zero : d ≠ 0) :\n    ∃ c : ℤ, n = c * ((n : exprℚ) / d).num ∧ (d : ℤ) = c * ((n : exprℚ) / d).denom :=\n  haveI : (n : exprℚ) / d = rat.mk n d := by rw [← Rat.divInt_eq_div]\n  Rat.num_den_mk d_ne_zero this\n#align exists_eq_mul_div_num_and_eq_mul_div_denom exists_eq_mul_div_num_and_eq_mul_div_denom\n\n",
 "exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprotected theorem exists {p : exprℚ → Prop} : (∃ r, p r) ↔ ∃ a b : ℤ, p (a / b) :=\n  ⟨fun ⟨r, hr⟩ => ⟨r.num, r.denom, by rwa [← mk_eq_div, num_denom]⟩, fun ⟨a, b, h⟩ => ⟨_, h⟩⟩\n#align exists exists\n\n",
 "div_int_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem div_int_inj {a b c d : ℤ} (hb0 : 0 < b) (hd0 : 0 < d) (h1 : Nat.coprime a.nat_abs b.nat_abs)\n    (h2 : Nat.coprime c.nat_abs d.nat_abs) (h : (a : exprℚ) / b = (c : exprℚ) / d) : a = c ∧ b = d :=\n  by\n  apply and.intro\n  · rw [← num_div_eq_of_coprime hb0 h1, h, num_div_eq_of_coprime hd0 h2]\n  · rw [← denom_div_eq_of_coprime hb0 h1, h, denom_div_eq_of_coprime hd0 h2]\n#align div_int_inj div_int_inj\n\n",
 "denom_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem denom_mk (n d : ℤ) : (rat.mk n d).denom = if d = 0 then 1 else d.nat_abs / n.gcd d := by\n  rcases d with ((_ | _) | _) <;>\n    simp [rat.mk, mk_nat, mk_pnat, Nat.succPNat, int.sign, int.gcd, -Nat.cast_succ, -Int.ofNat_succ]\n#align denom_mk denom_mk\n\n",
 "denom_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem denom_dvd (a b : ℤ) : ((rat.mk a b).denom : ℤ) ∣ b :=\n  by\n  by_cases b0 : b = 0; · simp [b0]\n  cases' e : rat.mk a b with n d h c\n  rw [num_denom', mk_eq b0 (ne_of_gt (Int.coe_nat_pos.2 h))] at e\n  refine' Int.dvd_natAbs.1 <| Int.coe_nat_dvd.2 <| c.symm.dvd_of_dvd_mul_left _\n  rw [← Int.natAbs_mul, ← Int.coe_nat_dvd, Int.dvd_natAbs, ← e]; simp\n#align denom_dvd denom_dvd\n\n",
 "denom_div_eq_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem denom_div_eq_of_coprime {a b : ℤ} (hb0 : 0 < b) (h : Nat.coprime a.nat_abs b.nat_abs) :\n    ((a / b : exprℚ).denom : ℤ) = b := by\n  lift b to ℕ using le_of_lt hb0\n  norm_cast  at hb0 h\n  rw [← Rat.divInt_eq_div, ← [anonymous] a b hb0, [anonymous], PNat.mk_coe, h.gcd_eq_one, nat.div_one]\n#align denom_div_eq_of_coprime denom_div_eq_of_coprime\n\n",
 "denom_div_cast_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem denom_div_cast_eq_one_iff (m n : ℤ) (hn : n ≠ 0) : ((m : exprℚ) / n).denom = 1 ↔ n ∣ m :=\n  by\n  replace hn : (n : exprℚ) ≠ 0; · rwa [ne.def, ← Int.cast_zero, coe_int_inj]\n  constructor\n  · intro h\n    lift (m : exprℚ) / n to ℤ using h with k hk\n    use k\n    rwa [eq_div_iff_mul_eq hn, ← Int.cast_mul, mul_comm, eq_comm, coe_int_inj] at hk\n  · rintro ⟨d, rfl⟩\n    rw [Int.cast_mul, mul_comm, mul_div_cancel _ hn, Rat.coe_int_den]\n#align denom_div_cast_eq_one_iff denom_div_cast_eq_one_iff\n\n",
 "coe_pnat_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem coe_pnat_denom (x : exprℚ) : (x.pnat_denom : ℕ) = x.denom :=\n  rfl\n#align coe_pnat_denom coe_pnat_denom\n\n",
 "coe_nat_div_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem coe_nat_div_self (n : ℕ) : ((n / n : ℕ) : exprℚ) = n / n :=\n  coe_int_div_self n\n#align coe_nat_div_self coe_nat_div_self\n\n",
 "coe_nat_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coe_nat_div (a b : ℕ) (h : b ∣ a) : ((a / b : ℕ) : exprℚ) = a / b :=\n  by\n  rcases h with ⟨c, rfl⟩\n  simp only [mul_comm b, Nat.mul_div_assoc c (dvd_refl b), Nat.cast_mul, mul_div_assoc, coe_nat_div_self]\n#align coe_nat_div coe_nat_div\n\n",
 "coe_int_div_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem coe_int_div_self (n : ℤ) : ((n / n : ℤ) : exprℚ) = n / n :=\n  by\n  by_cases hn : n = 0\n  · subst hn\n    simp only [Int.cast_zero, Int.zero_div, zero_div]\n  · have : (n : exprℚ) ≠ 0 := by rwa [← coe_int_inj] at hn\n    simp only [Int.ediv_self hn, Int.cast_one, ne.def, not_false_iff, div_self this]\n#align coe_int_div_self coe_int_div_self\n\n",
 "coe_int_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coe_int_div (a b : ℤ) (h : b ∣ a) : ((a / b : ℤ) : exprℚ) = a / b :=\n  by\n  rcases h with ⟨c, rfl⟩\n  simp only [mul_comm b, Int.mul_ediv_assoc c (dvd_refl b), Int.cast_mul, mul_div_assoc, coe_int_div_self]\n#align coe_int_div coe_int_div\n\n",
 "add_num_denom'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem add_num_denom' (q r : exprℚ) :\n    (q + r).num * q.denom * r.denom = (q.num * r.denom + r.num * q.denom) * (q + r).denom :=\n  by\n  let s := mk (q.num * r.denom + r.num * q.denom) (q.denom * r.denom : ℤ)\n  have hs : (q.denom * r.denom : ℤ) ≠ 0 := int.coe_nat_ne_zero_iff_pos.mpr (mul_pos q.pos r.pos)\n  obtain ⟨c, ⟨c_mul_num, c_mul_denom⟩⟩ :=\n    exists_eq_mul_div_num_and_eq_mul_div_denom (q.num * r.denom + r.num * q.denom) hs\n  rw [c_mul_num, mul_assoc, mul_comm]\n  nth_rw 1 [c_mul_denom]\n  repeat' rw [mul_assoc]\n  apply mul_eq_mul_left_iff.2\n  rw [or_iff_not_imp_right]\n  intro c_pos\n  have h : _ = s :=\n    @add_def q.num q.denom r.num r.denom (int.coe_nat_ne_zero_iff_pos.mpr q.pos) (int.coe_nat_ne_zero_iff_pos.mpr r.pos)\n  rw [num_denom, num_denom] at h\n  rw [h]\n  rw [mul_comm]\n  apply rat.eq_iff_mul_eq_mul.mp\n  rw [← mk_eq_div]\n#align add_num_denom' add_num_denom'\n\n",
 "add_num_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem add_num_denom (q r : exprℚ) :\n    q + r = rat.mk (q.num * r.denom + q.denom * r.num : ℤ) (↑q.denom * ↑r.denom : ℤ) :=\n  by\n  have hqd : (q.denom : ℤ) ≠ 0 := Int.coe_nat_ne_zero_iff_pos.2 q.3\n  have hrd : (r.denom : ℤ) ≠ 0 := Int.coe_nat_ne_zero_iff_pos.2 r.3\n  conv_lhs => rw [← @num_denom q, ← @num_denom r, Rat.add_def'' hqd hrd] <;> simp [mul_comm]\n#align add_num_denom add_num_denom\n\n",
 "add_denom_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem add_denom_dvd (q₁ q₂ : exprℚ) : (q₁ + q₂).denom ∣ q₁.denom * q₂.denom :=\n  by\n  cases q₁\n  cases q₂\n  apply mk_pnat_denom_dvd\n#align add_denom_dvd add_denom_dvd\n\n"}