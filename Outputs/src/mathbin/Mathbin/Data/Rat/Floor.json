{"round_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem round_cast (x : exprℚ) : round (x : α) = round x :=\n  by\n  have : ((x + 1 / 2 : exprℚ) : α) = x + 1 / 2 := by simp\n  rw [round_eq, round_eq, ← this, floor_cast]\n#align round_cast round_cast\n\n",
 "num_lt_succ_floor_mul_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\ntheorem num_lt_succ_floor_mul_denom (q : exprℚ) : q.num < («expr⌊ ⌋» q + 1) * q.denom :=\n  by\n  suffices (q.num : exprℚ) < («expr⌊ ⌋» q + 1) * q.denom by exact_mod_cast this\n  suffices (q.num : exprℚ) < (q - fract q + 1) * q.denom\n    by\n    have : («expr⌊ ⌋» q : exprℚ) = q - fract q := eq_sub_of_add_eq <| floor_add_fract q\n    rwa [this]\n  suffices (q.num : exprℚ) < q.num + (1 - fract q) * q.denom\n    by\n    have : (q - fract q + 1) * q.denom = q.num + (1 - fract q) * q.denom\n    calc\n      (q - fract q + 1) * q.denom = (q + (1 - fract q)) * q.denom := by ring\n      _ = q * q.denom + (1 - fract q) * q.denom := by rw [add_mul]\n      _ = q.num + (1 - fract q) * q.denom := by simp\n      \n    rwa [this]\n  suffices 0 < (1 - fract q) * q.denom by\n    rw [← sub_lt_iff_lt_add']\n    simpa\n  have : 0 < 1 - fract q := by\n    have : fract q < 1 := fract_lt_one q\n    have : 0 + fract q < 1 := by simp [this]\n    rwa [lt_sub_iff_add_lt]\n  exact mul_pos this (by exact_mod_cast q.pos)\n#align num_lt_succ_floor_mul_denom num_lt_succ_floor_mul_denom\n\n",
 "mod_nat_eq_sub_mul_floor_rat_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print Int.mod_nat_eq_sub_mul_floor_rat_div /-\ntheorem Int.mod_nat_eq_sub_mul_floor_rat_div {n : ℤ} {d : ℕ} : n % d = n - d * «expr⌊ ⌋» ((n : exprℚ) / d) := by\n  rw [eq_sub_of_add_eq <| Int.emod_add_ediv n d, Rat.floor_int_div_nat_eq_div]\n#align int.mod_nat_eq_sub_mul_floor_rat_div Int.mod_nat_eq_sub_mul_floor_rat_div\n-/\n\n",
 "le_floor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Kevin Kappelmann\n-/\nprotected theorem le_floor {z : ℤ} : ∀ {r : exprℚ}, z ≤ Rat.floor r ↔ (z : exprℚ) ≤ r\n  | ⟨n, d, h, c⟩ => by\n    simp [Rat.floor]\n    rw [num_denom']\n    have h' := Int.ofNat_lt.2 h\n    conv =>\n      rhs\n      rw [coe_int_eq_mk, Rat.le_def zero_lt_one h', mul_one]\n    exact Int.le_ediv_iff_mul_le h'\n#align le_floor le_floor\n\n",
 "fract_inv_num_lt_num_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem fract_inv_num_lt_num_of_pos {q : exprℚ} (q_pos : 0 < q) : (fract q⁻¹).num < q.num :=\n  by\n  -- we know that the numerator must be positive\n  have q_num_pos : 0 < q.num := rat.num_pos_iff_pos.elim_right q_pos\n  -- we will work with the absolute value of the numerator, which is equal to the numerator\n  have q_num_abs_eq_q_num : (q.num.nat_abs : ℤ) = q.num := Int.natAbs_of_nonneg q_num_pos.le\n  set q_inv := (q.denom : exprℚ) / q.num with q_inv_def\n  have q_inv_eq : q⁻¹ = q_inv := Rat.inv_def''\n  suffices (q_inv - «expr⌊ ⌋» q_inv).num < q.num by rwa [q_inv_eq]\n  suffices ((q.denom - q.num * «expr⌊ ⌋» q_inv : exprℚ) / q.num).num < q.num by field_simp [this, ne_of_gt q_num_pos]\n  suffices (q.denom : ℤ) - q.num * «expr⌊ ⌋» q_inv < q.num\n    by\n    -- use that `q.num` and `q.denom` are coprime to show that the numerator stays unreduced\n    have : ((q.denom - q.num * «expr⌊ ⌋» q_inv : exprℚ) / q.num).num = q.denom - q.num * «expr⌊ ⌋» q_inv :=\n      by\n      suffices ((q.denom : ℤ) - q.num * «expr⌊ ⌋» q_inv).nat_abs.coprime q.num.nat_abs by\n        exact_mod_cast Rat.num_div_eq_of_coprime q_num_pos this\n      have tmp := Nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm\n      simpa only [Nat.cast_natAbs, abs_of_nonneg q_num_pos.le] using tmp\n    rwa [this]\n  -- to show the claim, start with the following inequality\n  have q_inv_num_denom_ineq : q⁻¹.num - «expr⌊ ⌋» q⁻¹ * q⁻¹.denom < q⁻¹.denom :=\n    by\n    have : q⁻¹.num < («expr⌊ ⌋» q⁻¹ + 1) * q⁻¹.denom := Rat.num_lt_succ_floor_mul_den q⁻¹\n    have : q⁻¹.num < «expr⌊ ⌋» q⁻¹ * q⁻¹.denom + q⁻¹.denom := by rwa [right_distrib, one_mul] at this\n    rwa [← sub_lt_iff_lt_add'] at this\n  -- use that `q.num` and `q.denom` are coprime to show that q_inv is the unreduced reciprocal\n  -- of `q`\n  have : q_inv.num = q.denom ∧ q_inv.denom = q.num.nat_abs :=\n    by\n    have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs := q.cop.symm\n    have : Int.natAbs q.denom = q.denom := by simp\n    rw [← this] at coprime_q_denom_q_num\n    rw [q_inv_def]\n    constructor\n    · exact_mod_cast Rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n    · suffices (((q.denom : exprℚ) / q.num).denom : ℤ) = q.num.nat_abs by exact_mod_cast this\n      rw [q_num_abs_eq_q_num]\n      exact_mod_cast Rat.den_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n  rwa [q_inv_eq, this.left, this.right, q_num_abs_eq_q_num, mul_comm] at q_inv_num_denom_ineq\n#align fract_inv_num_lt_num_of_pos fract_inv_num_lt_num_of_pos\n\n",
 "floor_int_div_nat_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem floor_int_div_nat_eq_div {n : ℤ} {d : ℕ} : «expr⌊ ⌋» ((↑n : exprℚ) / (↑d : exprℚ)) = n / (↑d : ℤ) :=\n  by\n  rw [Rat.floor_def]\n  obtain rfl | hd := @eq_zero_or_pos _ _ d\n  · simp\n  set q := (n : exprℚ) / d with q_eq\n  obtain ⟨c, n_eq_c_mul_num, d_eq_c_mul_denom⟩ : ∃ c, n = c * q.num ∧ (d : ℤ) = c * q.denom :=\n    by\n    rw [q_eq]\n    exact_mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (by exact_mod_cast hd.ne')\n  rw [n_eq_c_mul_num, d_eq_c_mul_denom]\n  refine' (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left _ <| Int.coe_nat_nonneg q.denom).symm\n  rwa [← d_eq_c_mul_denom, Int.coe_nat_pos]\n#align floor_int_div_nat_eq_div floor_int_div_nat_eq_div\n\n",
 "floor_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\nprotected theorem floor_def {q : exprℚ} : «expr⌊ ⌋» q = q.num / q.denom :=\n  by\n  cases q\n  rfl\n#align floor_def floor_def\n\n",
 "floor_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n@[simp, norm_cast]\ntheorem floor_cast (x : exprℚ) : «expr⌊ ⌋» (x : α) = «expr⌊ ⌋» x :=\n  floor_eq_iff.2 (by exact_mod_cast floor_eq_iff.1 (Eq.refl («expr⌊ ⌋» x)))\n#align floor_cast floor_cast\n\n",
 "coprime_sub_mul_floor_rat_div_of_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌊ ⌋» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print Nat.coprime_sub_mul_floor_rat_div_of_coprime /-\ntheorem Nat.coprime_sub_mul_floor_rat_div_of_coprime {n d : ℕ} (n_coprime_d : n.coprime d) :\n    ((n : ℤ) - d * «expr⌊ ⌋» ((n : exprℚ) / d)).nat_abs.coprime d :=\n  by\n  have : (n : ℤ) % d = n - d * «expr⌊ ⌋» ((n : exprℚ) / d) := Int.mod_nat_eq_sub_mul_floor_rat_div\n  rw [← this]\n  have : d.coprime n := n_coprime_d.symm\n  rwa [Nat.coprime, Nat.gcd_rec] at this\n#align nat.coprime_sub_mul_floor_rat_div_of_coprime Nat.coprime_sub_mul_floor_rat_div_of_coprime\n-/\n\n",
 "ceil_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⌈ ⌉» -/\n@[simp, norm_cast]\ntheorem ceil_cast (x : exprℚ) : «expr⌈ ⌉» (x : α) = «expr⌈ ⌉» x := by\n  rw [← neg_inj, ← floor_neg, ← floor_neg, ← Rat.cast_neg, Rat.floor_cast]\n#align ceil_cast ceil_cast\n\n",
 "cast_fract":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_fract (x : exprℚ) : (↑(fract x) : α) = fract x := by simp only [fract, cast_sub, cast_coe_int, floor_cast]\n#align cast_fract cast_fract\n\n"}