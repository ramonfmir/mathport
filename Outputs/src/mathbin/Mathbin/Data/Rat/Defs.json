{"zero_of_num_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem zero_of_num_zero {q : exprℚ} (hq : q.num = 0) : q = 0 :=\n  by\n  have : q = rat.mk q.num q.denom := num_den.symm\n  simpa [hq]\n#align zero_of_num_zero zero_of_num_zero\n\n",
 "zero_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print zero_ne_one /-\nprotected theorem zero_ne_one : 0 ≠ (1 : exprℚ) :=\n  by\n  rw [ne_comm, ← mk_one_one, mk_ne_zero one_ne_zero]\n  exact one_ne_zero\n#align zero_ne_one zero_ne_one\n-/\n\n",
 "zero_mk_pnat":
 "@[simp]\ntheorem zero_mk_pnat (n) : [anonymous] 0 n = 0 :=\n  by\n  cases' n with n npos\n  simp only [mk_pnat, Int.natAbs_zero, nat.div_self npos, Nat.gcd_zero_left, Int.zero_div]\n  rfl\n#align zero_mk_pnat zero_mk_pnat\n\n",
 "zero_mk_nat":
 "@[simp]\ntheorem zero_mk_nat (n) : mkRat 0 n = 0 := by by_cases n = 0 <;> simp [*, mk_nat]\n#align zero_mk_nat zero_mk_nat\n\n",
 "zero_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem zero_mk (n) : rat.mk 0 n = 0 := by cases n <;> simp [mk]\n#align zero_mk zero_mk\n\n",
 "zero_iff_num_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem zero_iff_num_zero {q : exprℚ} : q = 0 ↔ q.num = 0 :=\n  ⟨fun _ => by simp [*], zero_of_num_zero⟩\n#align zero_iff_num_zero zero_iff_num_zero\n\n",
 "zero_add":
 "#print zero_add /-\nprotected theorem zero_add : 0 + a = a :=\n  numDenCasesOn' a fun n d h => by rw [← zero_mk d] <;> simp [h, -zero_mk]\n#align zero_add zero_add\n-/\n\n",
 "sub_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem sub_def {a b c d : ℤ} (b0 : b ≠ 0) (d0 : d ≠ 0) : rat.mk a b - rat.mk c d = rat.mk (a * d - c * b) (b * d) := by\n  simp [b0, d0, sub_eq_add_neg]\n#align sub_def sub_def\n\n",
 "one_mul":
 "#print one_mul /-\nprotected theorem one_mul : 1 * a = a :=\n  numDenCasesOn' a fun n d h => by\n    rw [← mk_one_one]\n    simp [h, -mk_one_one]\n#align one_mul one_mul\n-/\n\n",
 "of_int_eq_cast":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp]\ntheorem of_int_eq_cast (n : ℤ) : ofInt n = n :=\n  rfl\n#align of_int_eq_cast of_int_eq_cast\n\n",
 "num_zero":
 "@[simp]\ntheorem num_zero : rat.num 0 = 0 :=\n  rfl\n#align num_zero num_zero\n\n",
 "num_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem num_one : (1 : exprℚ).num = 1 :=\n  rfl\n#align num_one num_one\n\n",
 "num_neg_eq_neg_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem num_neg_eq_neg_num (q : exprℚ) : (-q).num = -q.num :=\n  rfl\n#align num_neg_eq_neg_num num_neg_eq_neg_num\n\n",
 "num_ne_zero_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem num_ne_zero_of_ne_zero {q : exprℚ} (h : q ≠ 0) : q.num ≠ 0 := fun this : q.num = 0 => h <| zero_of_num_zero this\n#align num_ne_zero_of_ne_zero num_ne_zero_of_ne_zero\n\n",
 "num_div_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem num_div_denom (r : exprℚ) : (r.num / r.denom : exprℚ) = r := by rw [← Int.cast_ofNat, ← mk_eq_div, num_denom]\n#align num_div_denom num_div_denom\n\n",
 "num_denom'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem num_denom' {n d h c} : (⟨n, d, h, c⟩ : exprℚ) = rat.mk n d :=\n  num_den.symm\n#align num_denom' num_denom'\n\n",
 "num_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem num_denom : ∀ {a : exprℚ}, rat.mk a.num a.denom = a\n  | ⟨n, d, h, (c : _ = 1)⟩ => show mkRat n d = _ by simp [mk_nat, ne_of_gt h, mk_pnat, c]\n#align num_denom num_denom\n\n",
 "neg_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem neg_def {a b : ℤ} : -rat.mk a b = rat.mk (-a) b :=\n  by\n  by_cases b0 : b = 0;\n  · subst b0\n    simp\n    rfl\n  generalize ha : rat.mk a b = x; cases' x with n₁ d₁ h₁ c₁; rw [num_denom'] at ha\n  show rat.mk' _ _ _ _ = _; rw [num_denom']\n  have d0 := ne_of_gt (Int.ofNat_lt.2 h₁)\n  apply (mk_eq d0 b0).2; have h₁ := (mk_eq b0 d0).1 ha\n  simp only [neg_mul, congr_arg has_neg.neg h₁]\n#align neg_def neg_def\n\n",
 "mul_one":
 "#print mul_one /-\nprotected theorem mul_one : a * 1 = a :=\n  numDenCasesOn' a fun n d h => by\n    rw [← mk_one_one]\n    simp [h, -mk_one_one]\n#align mul_one mul_one\n-/\n\n",
 "mul_num_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mul_num_denom (q r : exprℚ) : q * r = rat.mk (q.num * r.num) ↑(q.denom * r.denom) :=\n  by\n  have hq' : (↑q.denom : ℤ) ≠ 0 := by have := denom_ne_zero q <;> simpa\n  have hr' : (↑r.denom : ℤ) ≠ 0 := by have := denom_ne_zero r <;> simpa\n  suffices rat.mk q.num ↑q.denom * rat.mk r.num ↑r.denom = rat.mk (q.num * r.num) ↑(q.denom * r.denom) by\n    simpa using this\n  simp [mul_def hq' hr', -num_denom]\n#align mul_num_denom mul_num_denom\n\n",
 "mul_inv_cancel":
 "#print mul_inv_cancel /-\nprotected theorem mul_inv_cancel : a ≠ 0 → a * a⁻¹ = 1 :=\n  numDenCasesOn' a fun n d h a0 =>\n    by\n    have n0 : n ≠ 0 :=\n      mt\n        (by\n          rintro rfl\n          simp)\n        a0\n    simpa [h, n0, mul_comm] using @div_mk_div_cancel_left 1 1 _ n0\n#align mul_inv_cancel mul_inv_cancel\n-/\n\n",
 "mul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mul_def {a b c d : ℤ} (b0 : b ≠ 0) (d0 : d ≠ 0) : rat.mk a b * rat.mk c d = rat.mk (a * c) (b * d) :=\n  by\n  apply lift_binop_eq Rat.mul <;> intros <;> try assumption\n  · apply mk_pnat_eq\n  · apply mul_ne_zero d₁0 d₂0\n  cc\n#align mul_def mul_def\n\n",
 "mul_comm":
 "#print mul_comm /-\nprotected theorem mul_comm : a * b = b * a :=\n  numDenCasesOn' a fun n₁ d₁ h₁ => numDenCasesOn' b fun n₂ d₂ h₂ => by simp [h₁, h₂, mul_comm]\n#align mul_comm mul_comm\n-/\n\n",
 "mul_assoc":
 "#print mul_assoc /-\nprotected theorem mul_assoc : a * b * c = a * (b * c) :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ =>\n      numDenCasesOn' c fun n₃ d₃ h₃ => by simp [h₁, h₂, h₃, mul_ne_zero, mul_comm, mul_left_comm]\n#align mul_assoc mul_assoc\n-/\n\n",
 "mul_add":
 "#print mul_add /-\nprotected theorem mul_add : a * (b + c) = a * b + a * c := by\n  rw [Rat.mul_comm, Rat.add_mul, Rat.mul_comm, Rat.mul_comm c a]\n#align mul_add mul_add\n-/\n\n",
 "mk_zero_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mk_zero_one : rat.mk 0 1 = 0 :=\n  show [anonymous] _ _ = _ by\n    rw [mk_pnat]\n    simp\n    rfl\n#align mk_zero_one mk_zero_one\n\n",
 "mk_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mk_zero (n) : rat.mk n 0 = 0 :=\n  rfl\n#align mk_zero mk_zero\n\n",
 "mk_pnat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_pnat_eq (n d h) : [anonymous] n ⟨d, h⟩ = rat.mk n d := by\n  change rat.mk n d with dite _ _ _ <;> simp [ne_of_gt h]\n#align mk_pnat_eq mk_pnat_eq\n\n",
 "mk_one_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mk_one_one : rat.mk 1 1 = 1 :=\n  show [anonymous] _ _ = _ by\n    rw [mk_pnat]\n    simp\n    rfl\n#align mk_one_one mk_one_one\n\n",
 "mk_num_ne_zero_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_num_ne_zero_of_ne_zero {q : exprℚ} {n d : ℤ} (hq : q ≠ 0) (hqnd : q = rat.mk n d) : n ≠ 0 :=\n  fun this : n = 0 => hq <| by simpa [this] using hqnd\n#align mk_num_ne_zero_of_ne_zero mk_num_ne_zero_of_ne_zero\n\n",
 "mk_neg_one_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mk_neg_one_one : rat.mk (-1) 1 = -1 :=\n  show [anonymous] _ _ = _ by\n    rw [mk_pnat]\n    simp\n    rfl\n#align mk_neg_one_one mk_neg_one_one\n\n",
 "mk_neg_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mk_neg_denom (n d : ℤ) : rat.mk n (-d) = rat.mk (-n) d := by\n  by_cases hd : d = 0 <;> simp [Rat.divInt_eq_iff, hd]\n#align mk_neg_denom mk_neg_denom\n\n",
 "mk_ne_zero_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_ne_zero_of_ne_zero {n d : ℤ} (h : n ≠ 0) (hd : d ≠ 0) : rat.mk n d ≠ 0 :=\n  (divInt_ne_zero hd).mpr h\n#align mk_ne_zero_of_ne_zero mk_ne_zero_of_ne_zero\n\n",
 "mk_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_ne_zero {a b : ℤ} (b0 : b ≠ 0) : rat.mk a b ≠ 0 ↔ a ≠ 0 :=\n  (divInt_eq_zero b0).not\n#align mk_ne_zero mk_ne_zero\n\n",
 "mk_nat_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_nat_eq (n d) : mkRat n d = rat.mk n d :=\n  rfl\n#align mk_nat_eq mk_nat_eq\n\n",
 "mk_mul_mk_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_mul_mk_cancel {x : ℤ} (hx : x ≠ 0) (n d : ℤ) : rat.mk n x * rat.mk x d = rat.mk n d :=\n  by\n  by_cases hd : d = 0\n  · rw [hd]\n    simp\n  rw [mul_def hx hd, mul_comm x, div_mk_div_cancel_left hx]\n#align mk_mul_mk_cancel mk_mul_mk_cancel\n\n",
 "mk_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem mk_eq_zero {a b : ℤ} (b0 : b ≠ 0) : rat.mk a b = 0 ↔ a = 0 :=\n  by\n  refine'\n    ⟨fun h => _, by\n      rintro rfl\n      simp⟩\n  have : ∀ {a b}, mk_pnat a b = 0 → a = 0 := by\n    rintro a ⟨b, h⟩ e\n    injection e with e\n    apply Int.eq_mul_of_ediv_eq_right gcd_abs_dvd_left e\n  cases' b with b <;> simp only [mk, mk_nat, Int.ofNat_eq_coe, dite_eq_left_iff] at h\n  · simp only [mt (congr_arg int.of_nat) b0, not_false_iff, forall_true_left] at h\n    exact this h\n  · apply neg_injective\n    simp [this h]\n#align mk_eq_zero mk_eq_zero\n\n",
 "mk_eq_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem mk_eq_div (n d : ℤ) : rat.mk n d = (n : exprℚ) / d :=\n  by\n  by_cases d0 : d = 0; · simp [d0, div_zero]\n  simp [division_def, coe_int_eq_mk, mul_def one_ne_zero d0]\n#align mk_eq_div mk_eq_div\n\n",
 "mk_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_eq : ∀ {a b c d : ℤ} (hb : b ≠ 0) (hd : d ≠ 0), rat.mk a b = rat.mk c d ↔ a * d = c * b :=\n  by\n  suffices ∀ a b c d hb hd, [anonymous] a ⟨b, hb⟩ = [anonymous] c ⟨d, hd⟩ ↔ a * d = c * b\n    by\n    intros ; cases' b with b b <;> simp [mk, mk_nat, Nat.succPNat]\n    simp [mt (congr_arg int.of_nat) hb]\n    all_goals\n      cases' d with d d <;> simp [mk, mk_nat, Nat.succPNat]\n      simp [mt (congr_arg int.of_nat) hd]\n      all_goals rw [this]; try rfl\n    · change a * ↑d.succ = -c * ↑b ↔ a * -d.succ = c * b\n      constructor <;> intro h <;> apply neg_injective <;>\n        simpa [left_distrib, neg_add_eq_iff_eq_add, eq_neg_iff_add_eq_zero, neg_eq_iff_add_eq_zero] using h\n    · change -a * ↑d = c * b.succ ↔ a * d = c * -b.succ\n      constructor <;> intro h <;> apply neg_injective <;> simpa [left_distrib, eq_comm] using h\n    · change -a * d.succ = -c * b.succ ↔ a * -d.succ = c * -b.succ\n      simp [left_distrib, sub_eq_add_neg]\n      cc\n  intros ; simp [mk_pnat]; constructor <;> intro h\n  · cases' h with ha hb\n    have ha := by\n      have dv := @gcd_abs_dvd_left\n      have := Int.eq_mul_of_ediv_eq_right dv ha\n      rw [← Int.mul_ediv_assoc _ dv] at this\n      exact Int.eq_mul_of_ediv_eq_left (dv.mul_left _) this.symm\n    have hb := by\n      have dv := fun {a b} => Nat.gcd_dvd_right (Int.natAbs a) b\n      have := Nat.eq_mul_of_div_eq_right dv hb\n      rw [← Nat.mul_div_assoc _ dv] at this\n      exact Nat.eq_mul_of_div_eq_left (dv.mul_left _) this.symm\n    have m0 : (a.nat_abs.gcd b * c.nat_abs.gcd d : ℤ) ≠ 0 :=\n      by\n      refine' Int.coe_nat_ne_zero.2 (ne_of_gt _)\n      apply mul_pos <;> apply Nat.gcd_pos_of_pos_right <;> assumption\n    apply mul_right_cancel₀ m0\n    simpa [mul_comm, mul_left_comm] using congr (congr_arg (· * ·) ha.symm) (congr_arg coe hb)\n  · suffices ∀ a c, a * d = c * b → a / a.gcd b = c / c.gcd d ∧ b / a.gcd b = d / c.gcd d\n      by\n      cases' this a.nat_abs c.nat_abs (by simpa [Int.natAbs_mul] using congr_arg Int.natAbs h) with h₁ h₂\n      have hs := congr_arg int.sign h\n      simp [int.sign_eq_one_of_pos (Int.ofNat_lt.2 hb), int.sign_eq_one_of_pos (Int.ofNat_lt.2 hd)] at hs\n      conv in a => rw [← Int.sign_mul_natAbs a]\n      conv in c => rw [← Int.sign_mul_natAbs c]\n      rw [Int.mul_ediv_assoc, Int.mul_ediv_assoc]\n      exact ⟨congr (congr_arg (· * ·) hs) (congr_arg coe h₁), h₂⟩\n      all_goals exact Int.coe_nat_dvd.2 (Nat.gcd_dvd_left _ _)\n    intro a c h\n    suffices bd : b / a.gcd b = d / c.gcd d\n    · refine' ⟨mul_left_cancel₀ hb.ne' _, bd⟩\n      rw [← Nat.mul_div_assoc _ (Nat.gcd_dvd_left _ _), mul_comm, Nat.mul_div_assoc _ (Nat.gcd_dvd_right _ _), bd, ←\n        Nat.mul_div_assoc _ (Nat.gcd_dvd_right _ _), h, mul_comm, Nat.mul_div_assoc _ (Nat.gcd_dvd_left _ _)]\n    suffices ∀ {a c : ℕ}, ∀ b > 0, ∀ d > 0, a * d = c * b → b / a.gcd b ≤ d / c.gcd d by\n      exact le_antisymm (this _ hb _ hd h) (this _ hd _ hb h.symm)\n    intro a c b hb d hd h\n    have gb0 := Nat.gcd_pos_of_pos_right a hb\n    have gd0 := Nat.gcd_pos_of_pos_right c hd\n    apply nat.le_of_dvd\n    apply (nat.le_div_iff_mul_le gd0).2\n    simp\n    apply nat.le_of_dvd hd (Nat.gcd_dvd_right _ _)\n    apply (Nat.coprime_div_gcd_div_gcd gb0).symm.dvd_of_dvd_mul_left\n    refine' ⟨c / c.gcd d, _⟩\n    rw [← Nat.mul_div_assoc _ (Nat.gcd_dvd_left _ _), ← Nat.mul_div_assoc _ (Nat.gcd_dvd_right _ _)]\n    apply congr_arg (· / c.gcd d)\n    rw [mul_comm, ← Nat.mul_div_assoc _ (Nat.gcd_dvd_left _ _), mul_comm, h,\n      Nat.mul_div_assoc _ (Nat.gcd_dvd_right _ _), mul_comm]\n#align mk_eq mk_eq\n\n",
 "mk_div_mk_cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_div_mk_cancel_right {x : ℤ} (hx : x ≠ 0) (n d : ℤ) : rat.mk x n / rat.mk x d = rat.mk d n := by\n  rw [div_eq_mul_inv, inv_def, mul_comm, mk_mul_mk_cancel hx]\n#align mk_div_mk_cancel_right mk_div_mk_cancel_right\n\n",
 "mk_div_mk_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_div_mk_cancel_left {x : ℤ} (hx : x ≠ 0) (n d : ℤ) : rat.mk n x / rat.mk d x = rat.mk n d := by\n  rw [div_eq_mul_inv, inv_def, mk_mul_mk_cancel hx]\n#align mk_div_mk_cancel_left mk_div_mk_cancel_left\n\n",
 "mk_denom_ne_zero_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem mk_denom_ne_zero_of_ne_zero {q : exprℚ} {n d : ℤ} (hq : q ≠ 0) (hqnd : q = rat.mk n d) : d ≠ 0 :=\n  fun this : d = 0 => hq <| by simpa [this] using hqnd\n#align mk_denom_ne_zero_of_ne_zero mk_denom_ne_zero_of_ne_zero\n\n",
 "lift_binop_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem lift_binop_eq (f : exprℚ → exprℚ → exprℚ) (f₁ : ℤ → ℤ → ℤ → ℤ → ℤ) (f₂ : ℤ → ℤ → ℤ → ℤ → ℤ)\n    (fv : ∀ {n₁ d₁ h₁ c₁ n₂ d₂ h₂ c₂}, f ⟨n₁, d₁, h₁, c₁⟩ ⟨n₂, d₂, h₂, c₂⟩ = rat.mk (f₁ n₁ d₁ n₂ d₂) (f₂ n₁ d₁ n₂ d₂))\n    (f0 : ∀ {n₁ d₁ n₂ d₂} (d₁0 : d₁ ≠ 0) (d₂0 : d₂ ≠ 0), f₂ n₁ d₁ n₂ d₂ ≠ 0) (a b c d : ℤ) (b0 : b ≠ 0) (d0 : d ≠ 0)\n    (H :\n      ∀ {n₁ d₁ n₂ d₂} (h₁ : a * d₁ = n₁ * b) (h₂ : c * d₂ = n₂ * d),\n        f₁ n₁ d₁ n₂ d₂ * f₂ a b c d = f₁ a b c d * f₂ n₁ d₁ n₂ d₂) :\n    f (rat.mk a b) (rat.mk c d) = rat.mk (f₁ a b c d) (f₂ a b c d) :=\n  by\n  generalize ha : rat.mk a b = x; cases' x with n₁ d₁ h₁ c₁; rw [num_denom'] at ha\n  generalize hc : rat.mk c d = x; cases' x with n₂ d₂ h₂ c₂; rw [num_denom'] at hc\n  rw [fv]\n  have d₁0 := ne_of_gt (Int.ofNat_lt.2 h₁)\n  have d₂0 := ne_of_gt (Int.ofNat_lt.2 h₂)\n  exact (mk_eq (f0 d₁0 d₂0) (f0 b0 d0)).2 (H ((mk_eq b0 d₁0).1 ha) ((mk_eq d0 d₂0).1 hc))\n#align lift_binop_eq lift_binop_eq\n\n",
 "inv_mul_cancel":
 "#print inv_mul_cancel /-\nprotected theorem inv_mul_cancel (h : a ≠ 0) : a⁻¹ * a = 1 :=\n  Eq.trans (Rat.mul_comm _ _) (Rat.mul_inv_cancel _ h)\n#align inv_mul_cancel inv_mul_cancel\n-/\n\n",
 "inv_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem inv_def {a b : ℤ} : (rat.mk a b)⁻¹ = rat.mk b a :=\n  by\n  by_cases a0 : a = 0\n  · subst a0\n    simp\n    rfl\n  by_cases b0 : b = 0\n  · subst b0\n    simp\n    rfl\n  generalize ha : rat.mk a b = x\n  cases' x with n d h c\n  rw [num_denom'] at ha\n  refine' Eq.trans (_ : Rat.inv ⟨n, d, h, c⟩ = rat.mk d n) _\n  · cases' n with n <;> [cases' n with n, skip]\n    · rfl\n    · change int.of_nat n.succ with (n + 1 : ℕ)\n      unfold Rat.inv\n      rw [num_denom']\n    · unfold Rat.inv\n      rw [num_denom']\n      rfl\n  have n0 : n ≠ 0 := by\n    rintro rfl\n    rw [Rat.zero_divInt, mk_eq_zero b0] at ha\n    exact a0 ha\n  have d0 := ne_of_gt (Int.ofNat_lt.2 h)\n  have ha := (mk_eq b0 d0).1 ha\n  apply (mk_eq n0 a0).2\n  cc\n#align inv_def inv_def\n\n",
 "gcd_abs_dvd_left":
 "private theorem gcd_abs_dvd_left {a b} : (Nat.gcd (Int.natAbs a) b : ℤ) ∣ a :=\n  Int.dvd_natAbs.1 <| Int.coe_nat_dvd.2 <| Nat.gcd_dvd_left (Int.natAbs a) b\n#align gcd_abs_dvd_left gcd_abs_dvd_left\n\n",
 "eq_iff_mul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem eq_iff_mul_eq_mul {p q : exprℚ} : p = q ↔ p.num * q.denom = q.num * p.denom :=\n  by\n  conv =>\n    lhs\n    rw [← @num_denom p, ← @num_denom q]\n  apply Rat.divInt_eq_iff <;>\n    · rw [← Nat.cast_zero, ne, Int.ofNat_inj]\n      apply denom_ne_zero\n#align eq_iff_mul_eq_mul eq_iff_mul_eq_mul\n\n",
 "div_num_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem div_num_denom (q r : exprℚ) : q / r = rat.mk (q.num * r.denom) (q.denom * r.num) :=\n  if hr : r.num = 0 then by\n    have hr' : r = 0 := zero_of_num_zero hr\n    simp [*]\n  else\n    calc\n      q / r = q * r⁻¹ := div_eq_mul_inv q r\n      _ = rat.mk q.num q.denom * (rat.mk r.num r.denom)⁻¹ := by simp\n      _ = rat.mk q.num q.denom * rat.mk r.denom r.num := by rw [inv_def]\n      _ = rat.mk (q.num * r.denom) (q.denom * r.num) := mul_def' (by simpa using denom_ne_zero q) hr\n      \n#align div_num_denom div_num_denom\n\n",
 "div_mk_div_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem div_mk_div_cancel_left {a b c : ℤ} (c0 : c ≠ 0) : rat.mk (a * c) (b * c) = rat.mk a b :=\n  by\n  by_cases b0 : b = 0;\n  · subst b0\n    simp\n  apply (mk_eq (mul_ne_zero b0 c0) b0).2; simp [mul_comm, mul_assoc]\n#align div_mk_div_cancel_left div_mk_div_cancel_left\n\n",
 "denom_zero":
 "@[simp]\ntheorem denom_zero : Rat.den 0 = 1 :=\n  rfl\n#align denom_zero denom_zero\n\n",
 "denom_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem denom_one : (1 : exprℚ).denom = 1 :=\n  rfl\n#align denom_one denom_one\n\n",
 "denom_neg_eq_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem denom_neg_eq_denom (q : exprℚ) : (-q).denom = q.denom :=\n  rfl\n#align denom_neg_eq_denom denom_neg_eq_denom\n\n",
 "denom_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- Important: We do not set `nat_cast := λ n, ((n : ℤ) : ℚ)` (even though it's defeq) as that\n  makes `int.cast_coe_nat` and `coe_coe` loop in `simp`. -/\n-- Extra instances to short-circuit type class resolution \n-- TODO(Mario): this instance slows down data.real.basic\n--instance : ring ℚ             := by apply_instance\ntheorem denom_ne_zero (q : exprℚ) : q.denom ≠ 0 :=\n  ne_of_gt q.pos\n#align denom_ne_zero denom_ne_zero\n\n",
 "denom_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem denom_eq_one_iff (r : exprℚ) : r.denom = 1 ↔ ↑r.num = r :=\n  ⟨Rat.coe_int_num_of_den_eq_one, fun h => h ▸ Rat.coe_int_den r.num⟩\n#align denom_eq_one_iff denom_eq_one_iff\n\n",
 "coe_nat_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem coe_nat_num (n : ℕ) : (n : exprℚ).num = n := by rw [← Int.cast_ofNat, coe_int_num]\n#align coe_nat_num coe_nat_num\n\n",
 "coe_nat_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem coe_nat_eq_mk (n : ℕ) : ↑n = rat.mk n 1 := by rw [← Int.cast_ofNat, coe_int_eq_mk]\n#align coe_nat_eq_mk coe_nat_eq_mk\n\n",
 "coe_nat_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem coe_nat_denom (n : ℕ) : (n : exprℚ).denom = 1 := by rw [← Int.cast_ofNat, coe_int_denom]\n#align coe_nat_denom coe_nat_denom\n\n",
 "coe_int_num_of_denom_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem coe_int_num_of_denom_eq_one {q : exprℚ} (hq : q.denom = 1) : ↑q.num = q :=\n  by\n  conv_rhs => rw [← @num_denom q, hq]\n  rw [coe_int_eq_mk]\n  rfl\n#align coe_int_num_of_denom_eq_one coe_int_num_of_denom_eq_one\n\n",
 "coe_int_num":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem coe_int_num (n : ℤ) : (n : exprℚ).num = n :=\n  rfl\n#align coe_int_num coe_int_num\n\n",
 "coe_int_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n-- Will be subsumed by `int.coe_inj` after we have defined\n-- `linear_ordered_field ℚ` (which implies characteristic zero).\ntheorem coe_int_inj (m n : ℤ) : (m : exprℚ) = n ↔ m = n :=\n  ⟨congr_arg num, congr_arg _⟩\n#align coe_int_inj coe_int_inj\n\n",
 "coe_int_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem coe_int_eq_mk (z : ℤ) : (z : exprℚ) = rat.mk z 1 :=\n  num_den'\n#align coe_int_eq_mk coe_int_eq_mk\n\n",
 "coe_int_div_eq_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\ntheorem coe_int_div_eq_mk {n d : ℤ} : (n : exprℚ) / ↑d = rat.mk n d :=\n  by\n  repeat' rw [coe_int_eq_mk]\n  exact mk_div_mk_cancel_left one_ne_zero n d\n#align coe_int_div_eq_mk coe_int_div_eq_mk\n\n",
 "coe_int_denom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem coe_int_denom (n : ℤ) : (n : exprℚ).denom = 1 :=\n  rfl\n#align coe_int_denom coe_int_denom\n\n",
 "add_zero":
 "#print add_zero /-\nprotected theorem add_zero : a + 0 = a :=\n  numDenCasesOn' a fun n d h => by rw [← zero_mk d] <;> simp [h, -zero_mk]\n#align add_zero add_zero\n-/\n\n",
 "add_mul":
 "#print add_mul /-\nprotected theorem add_mul : (a + b) * c = a * c + b * c :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ =>\n      numDenCasesOn' c fun n₃ d₃ h₃ => by\n        simp [h₁, h₂, h₃, mul_ne_zero] <;> refine' (div_mk_div_cancel_left (Int.coe_nat_ne_zero.2 h₃)).symm.trans _ <;>\n          simp [mul_add, mul_comm, mul_assoc, mul_left_comm]\n#align add_mul add_mul\n-/\n\n",
 "add_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\nprotected theorem add_mk (a b c : ℤ) : rat.mk (a + b) c = rat.mk a c + rat.mk b c :=\n  if h : c = 0 then by simp [h]\n  else by\n    rw [add_def h h, mk_eq h (mul_ne_zero h h)]\n    simp [add_mul, mul_assoc]\n#align add_mk add_mk\n\n",
 "add_left_neg":
 "#print add_left_neg /-\nprotected theorem add_left_neg : -a + a = 0 :=\n  numDenCasesOn' a fun n d h => by simp [h]\n#align add_left_neg add_left_neg\n-/\n\n",
 "add_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[simp]\ntheorem add_def {a b c d : ℤ} (b0 : b ≠ 0) (d0 : d ≠ 0) : rat.mk a b + rat.mk c d = rat.mk (a * d + c * b) (b * d) :=\n  by\n  apply lift_binop_eq Rat.add <;> intros <;> try assumption\n  · apply mk_pnat_eq\n  · apply mul_ne_zero d₁0 d₂0\n  calc\n    (n₁ * d₂ + n₂ * d₁) * (b * d) = n₁ * b * d₂ * d + n₂ * d * (d₁ * b) := by simp [mul_add, mul_comm, mul_left_comm]\n    _ = a * d₁ * d₂ * d + c * d₂ * (d₁ * b) := by rw [h₁, h₂]\n    _ = (a * d + c * b) * (d₁ * d₂) := by simp [mul_add, mul_comm, mul_left_comm]\n    \n#align add_def add_def\n\n",
 "add_comm":
 "#print add_comm /-\nprotected theorem add_comm : a + b = b + a :=\n  numDenCasesOn' a fun n₁ d₁ h₁ => numDenCasesOn' b fun n₂ d₂ h₂ => by simp [h₁, h₂] <;> cc\n#align add_comm add_comm\n-/\n\n",
 "add_assoc":
 "#print add_assoc /-\nprotected theorem add_assoc : a + b + c = a + (b + c) :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ =>\n      numDenCasesOn' c fun n₃ d₃ h₃ => by\n        simp [h₁, h₂, h₃, mul_ne_zero, mul_add, mul_comm, mul_left_comm, add_left_comm, add_assoc]\n#align add_assoc add_assoc\n-/\n\n"}