{"unop_rat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp, norm_cast]\ntheorem unop_rat_cast (r : exprℚ) : unop (r : «expr ᵐᵒᵖ» α) = r := by\n  rw [cast_def, div_eq_mul_inv, unop_mul, unop_inv, unop_nat_cast, unop_int_cast, (Commute.cast_int_right _ r.num).eq,\n    cast_def, div_eq_mul_inv]\n#align unop_rat_cast unop_rat_cast\n\n",
 "preimage_cast_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Ioo (a b : exprℚ) : «expr ⁻¹' » coe (Ioo (a : K) b) = Ioo a b :=\n  by\n  ext x\n  simp\n#align preimage_cast_Ioo preimage_cast_Ioo\n\n",
 "preimage_cast_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Ioi (a : exprℚ) : «expr ⁻¹' » coe (Ioi (a : K)) = Ioi a :=\n  by\n  ext x\n  simp\n#align preimage_cast_Ioi preimage_cast_Ioi\n\n",
 "preimage_cast_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Ioc (a b : exprℚ) : «expr ⁻¹' » coe (Ioc (a : K) b) = Ioc a b :=\n  by\n  ext x\n  simp\n#align preimage_cast_Ioc preimage_cast_Ioc\n\n",
 "preimage_cast_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Iio (a : exprℚ) : «expr ⁻¹' » coe (Iio (a : K)) = Iio a :=\n  by\n  ext x\n  simp\n#align preimage_cast_Iio preimage_cast_Iio\n\n",
 "preimage_cast_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Iic (a : exprℚ) : «expr ⁻¹' » coe (Iic (a : K)) = Iic a :=\n  by\n  ext x\n  simp\n#align preimage_cast_Iic preimage_cast_Iic\n\n",
 "preimage_cast_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Ico (a b : exprℚ) : «expr ⁻¹' » coe (Ico (a : K) b) = Ico a b :=\n  by\n  ext x\n  simp\n#align preimage_cast_Ico preimage_cast_Ico\n\n",
 "preimage_cast_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Ici (a : exprℚ) : «expr ⁻¹' » coe (Ici (a : K)) = Ici a :=\n  by\n  ext x\n  simp\n#align preimage_cast_Ici preimage_cast_Ici\n\n",
 "preimage_cast_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_cast_Icc (a b : exprℚ) : «expr ⁻¹' » coe (Icc (a : K) b) = Icc a b :=\n  by\n  ext x\n  simp\n#align preimage_cast_Icc preimage_cast_Icc\n\n",
 "op_rat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp, norm_cast]\ntheorem op_rat_cast (r : exprℚ) : op (r : α) = (↑r : «expr ᵐᵒᵖ» α) := by\n  rw [cast_def, div_eq_mul_inv, op_mul, op_inv, op_nat_cast, op_int_cast, (Commute.cast_int_right _ r.num).eq, cast_def,\n    div_eq_mul_inv]\n#align op_rat_cast op_rat_cast\n\n",
 "map_ratCast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print map_ratCast /-\n@[simp]\ntheorem map_ratCast [DivisionRing α] [DivisionRing β] [RingHomClass F α β] (f : F) (q : exprℚ) : f q = q := by\n  rw [cast_def, map_div₀, map_intCast, map_nat_cast, cast_def]\n#align map_rat_cast map_ratCast\n-/\n\n",
 "ext_rat_on_pnat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →*₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- Positive integer values of a morphism `φ` and its value on `-1` completely determine `φ`. -/\ntheorem ext_rat_on_pnat (same_on_neg_one : f (-1) = g (-1)) (same_on_pnat : ∀ n : ℕ, 0 < n → f n = g n) : f = g :=\n  ext_rat' <|\n    fun_like.congr_fun <|\n      show\n        (f : «expr →*₀ » (exprℚ) M₀).comp (Int.castRingHom (exprℚ) : «expr →*₀ » ℤ (exprℚ)) =\n          (g : «expr →*₀ » (exprℚ) M₀).comp (Int.castRingHom (exprℚ) : «expr →*₀ » ℤ (exprℚ))\n        from ext_int' (by simpa) (by simpa)\n#align ext_rat_on_pnat ext_rat_on_pnat\n\n",
 "ext_rat'":
 "/-- If `f` and `g` agree on the integers then they are equal `φ`. -/\ntheorem ext_rat' (h : ∀ m : ℤ, f m = g m) : f = g :=\n  fun_like.ext f g fun r => by\n    rw [← r.num_div_denom, div_eq_mul_inv, map_mul, map_mul, h, ← Int.cast_ofNat, eq_on_inv₀ f g (h _)]\n#align ext_rat' ext_rat'\n\n",
 "ext_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print RingHom.ext_rat /-\n/-- Any two ring homomorphisms from `ℚ` to a semiring are equal. If the codomain is a division ring,\nthen this lemma follows from `eq_rat_cast`. -/\ntheorem RingHom.ext_rat {R : Type _} [Semiring R] [RingHomClass F (exprℚ) R] (f g : F) : f = g :=\n  MonoidWithZeroHom.ext_rat' <|\n    RingHom.congr_fun <|\n      ((f : «expr →+* » (exprℚ) R).comp (Int.castRingHom (exprℚ))).ext_int\n        ((g : «expr →+* » (exprℚ) R).comp (Int.castRingHom (exprℚ)))\n#align ring_hom.ext_rat RingHom.ext_rat\n-/\n\n",
 "eq_ratCast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print eq_ratCast /-\n@[simp]\ntheorem eq_ratCast {k} [DivisionRing k] [RingHomClass F (exprℚ) k] (f : F) (r : exprℚ) : f r = r := by\n  rw [← map_ratCast f, Rat.cast_id]\n#align eq_rat_cast eq_ratCast\n-/\n\n",
 "commute_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem commute_cast (a : α) (r : exprℚ) : Commute a r :=\n  (r.cast_commute a).symm\n#align commute_cast commute_cast\n\n",
 "coe_cast_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_cast_hom : «expr⇑ » (castHom α) = coe :=\n  rfl\n#align coe_cast_hom coe_cast_hom\n\n",
 "cast_zpow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_zpow (q : exprℚ) (n : ℤ) : ((q ^ n : exprℚ) : α) = q ^ n :=\n  map_zpow₀ (castHom α) q n\n#align cast_zpow cast_zpow\n\n",
 "cast_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_zero : ((0 : exprℚ) : α) = 0 :=\n  (cast_coe_int _).trans Int.cast_zero\n#align cast_zero cast_zero\n\n",
 "cast_sub_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem cast_sub_of_ne_zero {m n : exprℚ} (m0 : (m.denom : α) ≠ 0) (n0 : (n.denom : α) ≠ 0) :\n    ((m - n : exprℚ) : α) = m - n :=\n  by\n  have : ((-n).denom : α) ≠ 0 := by cases n <;> exact n0\n  simp [sub_eq_add_neg, cast_add_of_ne_zero m0 this]\n#align cast_sub_of_ne_zero cast_sub_of_ne_zero\n\n",
 "cast_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_sub [CharZero α] (m n) : ((m - n : exprℚ) : α) = m - n :=\n  cast_sub_of_ne_zero (Nat.cast_ne_zero.2 <| ne_of_gt m.pos) (Nat.cast_ne_zero.2 <| ne_of_gt n.pos)\n#align cast_sub cast_sub\n\n",
 "cast_strict_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[mono]\ntheorem cast_strict_mono : strict_mono (coe : exprℚ → K) := fun m n => by\n  simpa only [sub_pos, cast_sub] using @cast_pos_of_pos K _ (n - m)\n#align cast_strict_mono cast_strict_mono\n\n",
 "cast_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_pow (q) (k : ℕ) : ((q ^ k : exprℚ) : α) = q ^ k :=\n  (castHom α).map_pow q k\n#align cast_pow cast_pow\n\n",
 "cast_pos_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem cast_pos_of_pos {r : exprℚ} (hr : 0 < r) : (0 : K) < r :=\n  by\n  rw [Rat.cast_def]\n  exact div_pos (Int.cast_pos.2 <| num_pos_iff_pos.2 hr) (nat.cast_pos.2 r.pos)\n#align cast_pos_of_pos cast_pos_of_pos\n\n",
 "cast_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_pos {n : exprℚ} : (0 : K) < n ↔ 0 < n := by norm_cast\n#align cast_pos cast_pos\n\n",
 "cast_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_one : ((1 : exprℚ) : α) = 1 :=\n  (cast_coe_int _).trans Int.cast_one\n#align cast_one cast_one\n\n",
 "cast_nonpos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_nonpos {n : exprℚ} : (n : K) ≤ 0 ↔ n ≤ 0 := by norm_cast\n#align cast_nonpos cast_nonpos\n\n",
 "cast_nonneg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_nonneg {n : exprℚ} : 0 ≤ (n : K) ↔ 0 ≤ n := by norm_cast\n#align cast_nonneg cast_nonneg\n\n",
 "cast_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_neg : ∀ n, ((-n : exprℚ) : α) = -n\n  | ⟨n, d, h, c⟩ => by\n    simpa only [cast_def] using\n      show (↑(-n) / d : α) = -(n / d) by rw [div_eq_mul_inv, div_eq_mul_inv, Int.cast_neg, neg_mul_eq_neg_mul]\n#align cast_neg cast_neg\n\n",
 "cast_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem cast_ne_zero [CharZero α] {n : exprℚ} : (n : α) ≠ 0 ↔ n ≠ 0 :=\n  not_congr cast_eq_zero\n#align cast_ne_zero cast_ne_zero\n\n",
 "cast_mul_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem cast_mul_of_ne_zero : ∀ {m n : exprℚ}, (m.denom : α) ≠ 0 → (n.denom : α) ≠ 0 → ((m * n : exprℚ) : α) = m * n\n  | ⟨n₁, d₁, h₁, c₁⟩, ⟨n₂, d₂, h₂, c₂⟩ => fun (d₁0 : (d₁ : α) ≠ 0) (d₂0 : (d₂ : α) ≠ 0) =>\n    by\n    have d₁0' : (d₁ : ℤ) ≠ 0 := Int.coe_nat_ne_zero.2 fun e => by rw [e] at d₁0 <;> exact d₁0 Nat.cast_zero\n    have d₂0' : (d₂ : ℤ) ≠ 0 := Int.coe_nat_ne_zero.2 fun e => by rw [e] at d₂0 <;> exact d₂0 Nat.cast_zero\n    rw [num_denom', num_denom', mul_def d₁0' d₂0']\n    suffices (n₁ * (n₂ * d₂⁻¹ * d₁⁻¹) : α) = n₁ * (d₁⁻¹ * (n₂ * d₂⁻¹))\n      by\n      rw [cast_mk_of_ne_zero, cast_mk_of_ne_zero, cast_mk_of_ne_zero]\n      · simpa [division_def, mul_inv_rev, d₁0, d₂0, mul_assoc]\n      all_goals simp [d₁0, d₂0]\n    rw [(d₁.commute_cast (_ : α)).inv_right₀.eq]\n#align cast_mul_of_ne_zero cast_mul_of_ne_zero\n\n",
 "cast_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_mul [CharZero α] (m n) : ((m * n : exprℚ) : α) = m * n :=\n  cast_mul_of_ne_zero (Nat.cast_ne_zero.2 <| ne_of_gt m.pos) (Nat.cast_ne_zero.2 <| ne_of_gt n.pos)\n#align cast_mul cast_mul\n\n",
 "cast_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[mono]\ntheorem cast_mono : monotone (coe : exprℚ → K) :=\n  cast_strictMono.monotone\n#align cast_mono cast_mono\n\n",
 "cast_mk_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[norm_cast]\ntheorem cast_mk_of_ne_zero (a b : ℤ) (b0 : (b : α) ≠ 0) : (rat.mk a b : α) = a / b :=\n  by\n  have b0' : b ≠ 0 := by\n    refine' mt _ b0\n    simp (config := { contextual := true })\n  cases' e : rat.mk a b with n d h c\n  have d0 : (d : α) ≠ 0 := by\n    intro d0\n    have dd := denom_dvd a b\n    cases' show (d : ℤ) ∣ b by rwa [e] at dd with k ke\n    have : (b : α) = (d : α) * (k : α) := by rw [ke, Int.cast_mul, Int.cast_ofNat]\n    rw [d0, zero_mul] at this\n    contradiction\n  rw [num_denom'] at e\n  have := congr_arg (coe : ℤ → α) ((mk_eq b0' <| ne_of_gt <| Int.coe_nat_pos.2 h).1 e)\n  rw [Int.cast_mul, Int.cast_mul, Int.cast_ofNat] at this\n  symm\n  rw [cast_def, div_eq_mul_inv, eq_div_iff_mul_eq d0, mul_assoc, (d.commute_cast _).eq, ← mul_assoc, this, mul_assoc,\n    mul_inv_cancel b0, mul_one]\n#align cast_mk_of_ne_zero cast_mk_of_ne_zero\n\n",
 "cast_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `rat.mk -/\n@[norm_cast]\ntheorem cast_mk (a b : ℤ) : (rat.mk a b : α) = a / b := by simp only [mk_eq_div, cast_div, cast_coe_int]\n#align cast_mk cast_mk\n\n",
 "cast_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_min {a b : exprℚ} : (↑(min a b) : K) = min a b :=\n  (@cast_mono K _).map_min\n#align cast_min cast_min\n\n",
 "cast_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_max {a b : exprℚ} : (↑(max a b) : K) = max a b :=\n  (@cast_mono K _).map_max\n#align cast_max cast_max\n\n",
 "cast_lt_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_lt_zero {n : exprℚ} : (n : K) < 0 ↔ n < 0 := by norm_cast\n#align cast_lt_zero cast_lt_zero\n\n",
 "cast_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_lt {m n : exprℚ} : (m : K) < n ↔ m < n :=\n  cast_strictMono.lt_iff_lt\n#align cast_lt cast_lt\n\n",
 "cast_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_le {m n : exprℚ} : (m : K) ≤ n ↔ m ≤ n :=\n  castOrderEmbedding.le_iff_le\n#align cast_le cast_le\n\n",
 "cast_inv_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem cast_inv_of_ne_zero : ∀ {n : exprℚ}, (n.num : α) ≠ 0 → (n.denom : α) ≠ 0 → ((n⁻¹ : exprℚ) : α) = n⁻¹\n  | ⟨n, d, h, c⟩ => fun (n0 : (n : α) ≠ 0) (d0 : (d : α) ≠ 0) =>\n    by\n    have n0' : (n : ℤ) ≠ 0 := fun e => by rw [e] at n0 <;> exact n0 Int.cast_zero\n    have d0' : (d : ℤ) ≠ 0 := Int.coe_nat_ne_zero.2 fun e => by rw [e] at d0 <;> exact d0 Nat.cast_zero\n    rw [num_denom', inv_def]\n    rw [cast_mk_of_ne_zero, cast_mk_of_ne_zero, inv_div] <;> simp [n0, d0]\n#align cast_inv_of_ne_zero cast_inv_of_ne_zero\n\n",
 "cast_inv_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_inv_nat (n : ℕ) : ((n⁻¹ : exprℚ) : α) = n⁻¹ :=\n  by\n  cases n; · simp\n  simp_rw [coe_nat_eq_mk, inv_def, mk, mk_nat, dif_neg n.succ_ne_zero, mk_pnat]\n  simp [cast_def]\n#align cast_inv_nat cast_inv_nat\n\n",
 "cast_inv_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_inv_int (n : ℤ) : ((n⁻¹ : exprℚ) : α) = n⁻¹ :=\n  by\n  cases n\n  · simp [cast_inv_nat]\n  · simp only [Int.cast_negSucc, ← Nat.cast_succ, cast_neg, inv_neg, cast_inv_nat]\n#align cast_inv_int cast_inv_int\n\n",
 "cast_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_inv (n) : ((n⁻¹ : exprℚ) : α) = n⁻¹ :=\n  map_inv₀ (castHom α) _\n#align cast_inv cast_inv\n\n",
 "cast_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem cast_injective [CharZero α] : function.injective (coe : exprℚ → α)\n  | m, n => cast_inj.1\n#align cast_injective cast_injective\n\n",
 "cast_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n#print cast_inj /-\n@[simp, norm_cast]\ntheorem cast_inj [CharZero α] : ∀ {m n : exprℚ}, (m : α) = n ↔ m = n\n  | ⟨n₁, d₁, h₁, c₁⟩, ⟨n₂, d₂, h₂, c₂⟩ => by\n    refine' ⟨fun h => _, congr_arg _⟩\n    have d₁0 : d₁ ≠ 0 := ne_of_gt h₁\n    have d₂0 : d₂ ≠ 0 := ne_of_gt h₂\n    have d₁a : (d₁ : α) ≠ 0 := Nat.cast_ne_zero.2 d₁0\n    have d₂a : (d₂ : α) ≠ 0 := Nat.cast_ne_zero.2 d₂0\n    rw [num_denom', num_denom'] at h⊢\n    rw [cast_mk_of_ne_zero, cast_mk_of_ne_zero] at h <;> simp [d₁0, d₂0] at h⊢\n    rwa [eq_div_iff_mul_eq d₂a, division_def, mul_assoc, (d₁.cast_commute (d₂ : α)).inv_left₀.eq, ← mul_assoc, ←\n      division_def, eq_comm, eq_div_iff_mul_eq d₁a, eq_comm, ← Int.cast_ofNat d₁, ← Int.cast_mul, ← Int.cast_ofNat d₂, ←\n      Int.cast_mul, Int.cast_inj, ← mk_eq (Int.coe_nat_ne_zero.2 d₁0) (Int.coe_nat_ne_zero.2 d₂0)] at h\n#align cast_inj cast_inj\n-/\n\n",
 "cast_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem cast_id (n : exprℚ) : (↑n : exprℚ) = n := by rw [cast_def, num_div_denom]\n#align cast_id cast_id\n\n",
 "cast_hom_rat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_hom_rat : castHom (exprℚ) = RingHom.id (exprℚ) :=\n  RingHom.ext cast_id\n#align cast_hom_rat cast_hom_rat\n\n",
 "cast_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_eq_zero [CharZero α] {n : exprℚ} : (n : α) = 0 ↔ n = 0 := by rw [← cast_zero, cast_inj]\n#align cast_eq_zero cast_eq_zero\n\n",
 "cast_eq_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem cast_eq_id : (coe : exprℚ → exprℚ) = id :=\n  funext cast_id\n#align cast_eq_id cast_eq_id\n\n",
 "cast_div_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem cast_div_of_ne_zero {m n : exprℚ} (md : (m.denom : α) ≠ 0) (nn : (n.num : α) ≠ 0) (nd : (n.denom : α) ≠ 0) :\n    ((m / n : exprℚ) : α) = m / n :=\n  by\n  have : (n⁻¹.denom : ℤ) ∣ n.num := by conv in n⁻¹.denom => rw [← @num_denom n, inv_def] <;> apply denom_dvd\n  have : (n⁻¹.denom : α) = 0 → (n.num : α) = 0 := fun h =>\n    by\n    let ⟨k, e⟩ := this\n    have := congr_arg (coe : ℤ → α) e <;> rwa [Int.cast_mul, Int.cast_ofNat, h, zero_mul] at this\n  rw [division_def, cast_mul_of_ne_zero md (mt this nn), cast_inv_of_ne_zero nn nd, division_def]\n#align cast_div_of_ne_zero cast_div_of_ne_zero\n\n",
 "cast_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_div (m n) : ((m / n : exprℚ) : α) = m / n :=\n  map_div₀ (castHom α) _ _\n#align cast_div cast_div\n\n",
 "cast_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem cast_commute (r : exprℚ) (a : α) : Commute (↑r) a := by\n  simpa only [cast_def] using (r.1.cast_commute a).div_left (r.2.cast_commute a)\n#align cast_commute cast_commute\n\n",
 "cast_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem cast_comm (r : exprℚ) (a : α) : (r : α) * a = a * r :=\n  (cast_commute r a).eq\n#align cast_comm cast_comm\n\n",
 "cast_coe_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_coe_nat (n : ℕ) : ((n : exprℚ) : α) = n := by rw [← Int.cast_ofNat, cast_coe_int, Int.cast_ofNat]\n#align cast_coe_nat cast_coe_nat\n\n",
 "cast_coe_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro\n-/\n@[simp, norm_cast]\ntheorem cast_coe_int (n : ℤ) : ((n : exprℚ) : α) = n :=\n  (cast_def _).trans <| show (n / (1 : ℕ) : α) = n by rw [Nat.cast_one, div_one]\n#align cast_coe_int cast_coe_int\n\n",
 "cast_bit1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_bit1 [CharZero α] (n : exprℚ) : ((bit1 n : exprℚ) : α) = bit1 n := by\n  rw [bit1, cast_add, cast_one, cast_bit0] <;> rfl\n#align cast_bit1 cast_bit1\n\n",
 "cast_bit0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_bit0 [CharZero α] (n : exprℚ) : ((bit0 n : exprℚ) : α) = bit0 n :=\n  cast_add _ _\n#align cast_bit0 cast_bit0\n\n",
 "cast_add_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[norm_cast]\ntheorem cast_add_of_ne_zero : ∀ {m n : exprℚ}, (m.denom : α) ≠ 0 → (n.denom : α) ≠ 0 → ((m + n : exprℚ) : α) = m + n\n  | ⟨n₁, d₁, h₁, c₁⟩, ⟨n₂, d₂, h₂, c₂⟩ => fun (d₁0 : (d₁ : α) ≠ 0) (d₂0 : (d₂ : α) ≠ 0) =>\n    by\n    have d₁0' : (d₁ : ℤ) ≠ 0 := Int.coe_nat_ne_zero.2 fun e => by rw [e] at d₁0 <;> exact d₁0 Nat.cast_zero\n    have d₂0' : (d₂ : ℤ) ≠ 0 := Int.coe_nat_ne_zero.2 fun e => by rw [e] at d₂0 <;> exact d₂0 Nat.cast_zero\n    rw [num_denom', num_denom', add_def d₁0' d₂0']\n    suffices (n₁ * (d₂ * (d₂⁻¹ * d₁⁻¹)) + n₂ * (d₁ * d₂⁻¹) * d₁⁻¹ : α) = n₁ * d₁⁻¹ + n₂ * d₂⁻¹\n      by\n      rw [cast_mk_of_ne_zero, cast_mk_of_ne_zero, cast_mk_of_ne_zero]\n      · simpa [division_def, left_distrib, right_distrib, mul_inv_rev, d₁0, d₂0, mul_assoc]\n      all_goals simp [d₁0, d₂0]\n    rw [← mul_assoc (d₂ : α), mul_inv_cancel d₂0, one_mul, (nat.cast_commute _ _).eq]\n    simp [d₁0, mul_assoc]\n#align cast_add_of_ne_zero cast_add_of_ne_zero\n\n",
 "cast_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_add [CharZero α] (m n) : ((m + n : exprℚ) : α) = m + n :=\n  cast_add_of_ne_zero (Nat.cast_ne_zero.2 <| ne_of_gt m.pos) (Nat.cast_ne_zero.2 <| ne_of_gt n.pos)\n#align cast_add cast_add\n\n",
 "cast_abs":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_abs {q : exprℚ} : ((|q| : exprℚ) : K) = |q| := by simp [abs_eq_max_neg]\n#align cast_abs cast_abs\n\n"}