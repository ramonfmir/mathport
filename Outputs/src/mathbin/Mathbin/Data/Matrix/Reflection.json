{"vec_mulᵣ_eq":
 "/-- This can be used to prove\n```lean\nexample [non_unital_non_assoc_semiring α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁ b₂ : α) :\n  vec_mul ![b₁, b₂] !![a₁₁, a₁₂;\n                       a₂₁, a₂₂] = ![b₁*a₁₁ + b₂*a₂₁, b₁*a₁₂ + b₂*a₂₂] :=\n(vec_mulᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem vec_mulᵣ_eq [NonUnitalNonAssocSemiring α] (v : Fin l → α) (A : Matrix (Fin l) (Fin m) α) :\n    vecMulᵣ v A = vecMul v A := by\n  simp [vec_mulᵣ, Function.comp]\n  rfl\n#align vec_mulᵣ_eq vec_mulᵣ_eq\n\n",
 "transposeᵣ_eq":
 "/-- This can be used to prove\n```lean\nexample (a b c d : α) : transpose !![a, b; c, d] = !![a, c; b, d] := (transposeᵣ_eq _).symm\n```\n-/\n@[simp]\ntheorem transposeᵣ_eq : ∀ {m n} (A : Matrix (Fin m) (Fin n) α), transposeᵣ A = transpose A\n  | _, 0, A => subsingleton.elim _ _\n  | m, n + 1, A =>\n    Matrix.ext fun i j => by\n      simp_rw [transposeᵣ, transposeᵣ_eq]\n      refine' i.cases _ fun i => _\n      · dsimp\n        rw [FinVec.map_eq]\n      · simp only [of_apply, Matrix.cons_val_succ]\n        rfl\n#align transposeᵣ_eq transposeᵣ_eq\n\n",
 "mulᵣ_eq":
 "/-- This can be used to prove\n```lean\nexample [add_comm_monoid α] [has_mul α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α) :\n  !![a₁₁, a₁₂;\n     a₂₁, a₂₂] ⬝ !![b₁₁, b₁₂;\n                    b₂₁, b₂₂] =\n  !![a₁₁*b₁₁ + a₁₂*b₂₁, a₁₁*b₁₂ + a₁₂*b₂₂;\n     a₂₁*b₁₁ + a₂₂*b₂₁, a₂₁*b₁₂ + a₂₂*b₂₂] :=\n(mulᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem mulᵣ_eq [Mul α] [AddCommMonoid α] (A : Matrix (Fin l) (Fin m) α) (B : Matrix (Fin m) (Fin n) α) :\n    mulᵣ A B = A.mul B := by\n  simp [mulᵣ, Function.comp, Matrix.mul, Matrix.transpose]\n  rfl\n#align mulᵣ_eq mulᵣ_eq\n\n",
 "mul_vecᵣ_eq":
 "/-- This can be used to prove\n```lean\nexample [non_unital_non_assoc_semiring α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁ b₂ : α) :\n  !![a₁₁, a₁₂;\n     a₂₁, a₂₂].mul_vec ![b₁, b₂] = ![a₁₁*b₁ + a₁₂*b₂, a₂₁*b₁ + a₂₂*b₂] :=\n(mul_vecᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem mul_vecᵣ_eq [NonUnitalNonAssocSemiring α] (A : Matrix (Fin l) (Fin m) α) (v : Fin m → α) :\n    mulVecᵣ A v = A.mul_vec v := by\n  simp [mul_vecᵣ, Function.comp]\n  rfl\n#align mul_vecᵣ_eq mul_vecᵣ_eq\n\n",
 "forall_iff":
 "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n/-- This can be use to prove\n```lean\nexample (P : matrix (fin 2) (fin 3) α → Prop) :\n  (∀ x, P x) ↔ ∀ a b c d e f, P !![a, b, c; d, e, f] :=\n(forall_iff _).symm\n```\n-/\ntheorem forall_iff : ∀ {m n} (P : Matrix (Fin m) (Fin n) α → Prop), Forall P ↔ ∀ x, P x\n  | 0, n, P => iff.symm Fin.forall_fin_zero_pi\n  | m + 1, n, P => by\n    simp only [forall, FinVec.forall_iff, forall_iff]\n    exact iff.symm Fin.forall_fin_succ_pi\n#align forall_iff forall_iff\n\n",
 "exists_iff":
 "/-- This can be use to prove\n```lean\nexample (P : matrix (fin 2) (fin 3) α → Prop) :\n  (∃ x, P x) ↔ ∃ a b c d e f, P !![a, b, c; d, e, f] :=\n(exists_iff _).symm\n```\n-/\ntheorem exists_iff : ∀ {m n} (P : Matrix (Fin m) (Fin n) α → Prop), Exists P ↔ ∃ x, P x\n  | 0, n, P => iff.symm Fin.exists_fin_zero_pi\n  | m + 1, n, P => by\n    simp only [exists, FinVec.exists_iff, exists_iff]\n    exact iff.symm Fin.exists_fin_succ_pi\n#align exists_iff exists_iff\n\n",
 "eta_expand_eq":
 "/-- This can be used to prove\n```lean\nexample (A : matrix (fin 2) (fin 2) α) :\n  A = !![A 0 0, A 0 1;\n         A 1 0, A 1 1] :=\n(eta_expand_eq _).symm\n```\n-/\ntheorem eta_expand_eq {m n} (A : Matrix (Fin m) (Fin n) α) : etaExpand A = A := by\n  simp_rw [eta_expand, FinVec.etaExpand_eq, Matrix.of, Equiv.refl_apply]\n#align eta_expand_eq eta_expand_eq\n\n",
 "dot_productᵣ_eq":
 "/-- This can be used to prove\n```lean\nexample (a b c d : α) [has_mul α] [add_comm_monoid α] :\n  dot_product ![a, b] ![c, d] = a * c + b * d :=\n(dot_productᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem dot_productᵣ_eq [Mul α] [AddCommMonoid α] {m} (a b : Fin m → α) : dotProductᵣ a b = dotProduct a b := by\n  simp_rw [dot_productᵣ, dot_product, FinVec.sum_eq, FinVec.seq_eq, FinVec.map_eq]\n#align dot_productᵣ_eq dot_productᵣ_eq\n\n"}