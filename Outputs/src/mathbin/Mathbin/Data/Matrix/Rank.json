{"rank_zero":
 "@[simp]\ntheorem rank_zero [Nontrivial R] : rank (0 : Matrix m n R) = 0 := by\n  rw [rank, mul_vec_lin_zero, LinearMap.range_zero, finrank_bot]\n#align rank_zero rank_zero\n\n",
 "rank_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem rank_unit [StrongRankCondition R] [DecidableEq n] (A : «expr ˣ» (Matrix n n R)) :\n    (A : Matrix n n R).rank = Fintype.card n :=\n  by\n  refine' le_antisymm (rank_le_card_width A) _\n  have := rank_mul_le_left (A : Matrix n n R) (↑A⁻¹ : Matrix n n R)\n  rwa [← mul_eq_mul, ← Units.val_mul, mul_inv_self, Units.val_one, rank_one] at this\n#align rank_unit rank_unit\n\n",
 "rank_transpose_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem rank_transpose_mul_self (A : Matrix m n R) : (matrix.mul (matrix.transpose A) A).rank = A.rank :=\n  by\n  dsimp only [rank]\n  refine' add_left_injective (finrank R A.mul_vec_lin.ker) _\n  dsimp only\n  rw [LinearMap.finrank_range_add_finrank_ker, ←\n    (matrix.mul (matrix.transpose A) A).mul_vec_lin.finrank_range_add_finrank_ker]\n  congr 1\n  rw [ker_mul_vec_lin_transpose_mul_self]\n#align rank_transpose_mul_self rank_transpose_mul_self\n\n",
 "rank_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/-- TODO: prove this in greater generality. -/\n@[simp]\ntheorem rank_transpose (A : Matrix m n R) : (matrix.transpose A).rank = A.rank :=\n  le_antisymm ((rank_transpose_mul_self _).symm.trans_le <| rank_mul_le_left _ _)\n    ((rank_transpose_mul_self _).symm.trans_le <| rank_mul_le_left _ _)\n#align rank_transpose rank_transpose\n\n",
 "rank_submatrix_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- Taking a subset of the rows and permuting the columns reduces the rank. -/\ntheorem rank_submatrix_le [StrongRankCondition R] [Fintype m] (f : n → m) (e : «expr ≃ » n m) (A : Matrix m m R) :\n    rank (A.submatrix f e) ≤ rank A :=\n  by\n  rw [rank, rank, mul_vec_lin_submatrix, LinearMap.range_comp, LinearMap.range_comp,\n    show LinearMap.funLeft R R e.symm = LinearEquiv.funCongrLeft R R e.symm from rfl, LinearEquiv.range,\n    Submodule.map_top]\n  exact Submodule.finrank_map_le _ _\n#align rank_submatrix_le rank_submatrix_le\n\n",
 "rank_submatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem rank_submatrix [Fintype m] (A : Matrix m m R) (e₁ e₂ : «expr ≃ » n m) : rank (A.submatrix e₁ e₂) = rank A := by\n  simpa only [reindex_apply] using rank_reindex e₁.symm e₂.symm A\n#align rank_submatrix rank_submatrix\n\n",
 "rank_self_mul_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem rank_self_mul_transpose (A : Matrix m n R) : (matrix.mul A (matrix.transpose A)).rank = A.rank := by\n  simpa only [rank_transpose, transpose_transpose] using rank_transpose_mul_self (matrix.transpose A)\n#align rank_self_mul_transpose rank_self_mul_transpose\n\n",
 "rank_self_mul_conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n@[simp]\ntheorem rank_self_mul_conj_transpose (A : Matrix m n R) : (matrix.mul A (matrix.conj_transpose A)).rank = A.rank := by\n  simpa only [rank_conj_transpose, conj_transpose_conj_transpose] using\n    rank_conj_transpose_mul_self (matrix.conj_transpose A)\n#align rank_self_mul_conj_transpose rank_self_mul_conj_transpose\n\n",
 "rank_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem rank_reindex [Fintype m] (e₁ e₂ : «expr ≃ » m n) (A : Matrix m m R) : rank (reindex e₁ e₂ A) = rank A := by\n  rw [rank, rank, mul_vec_lin_reindex, LinearMap.range_comp, LinearMap.range_comp, LinearEquiv.range, Submodule.map_top,\n    LinearEquiv.finrank_map_eq]\n#align rank_reindex rank_reindex\n\n",
 "rank_one":
 "/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Eric Wieer\n-/\n@[simp]\ntheorem rank_one [StrongRankCondition R] [DecidableEq n] : rank (1 : Matrix n n R) = Fintype.card n := by\n  rw [rank, mul_vec_lin_one, LinearMap.range_id, finrank_top, finrank_pi]\n#align rank_one rank_one\n\n",
 "rank_of_is_unit":
 "theorem rank_of_is_unit [StrongRankCondition R] [DecidableEq n] (A : Matrix n n R) (h : IsUnit A) :\n    A.rank = Fintype.card n := by\n  obtain ⟨A, rfl⟩ := h\n  exact rank_unit A\n#align rank_of_is_unit rank_of_is_unit\n\n",
 "rank_mul_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem rank_mul_le_right [StrongRankCondition R] (A : Matrix l m R) (B : Matrix m n R) :\n    (matrix.mul A B).rank ≤ B.rank := by\n  rw [rank, rank, mul_vec_lin_mul]\n  exact finrank_le_finrank_of_rank_le_rank (LinearMap.lift_rank_comp_le_right _ _) (rank_lt_aleph_0 _ _)\n#align rank_mul_le_right rank_mul_le_right\n\n",
 "rank_mul_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem rank_mul_le_left [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (matrix.mul A B).rank ≤ A.rank := by\n  rw [rank, rank, mul_vec_lin_mul]\n  exact Cardinal.toNat_le_of_le_of_lt_aleph0 (rank_lt_aleph_0 _ _) (LinearMap.rank_comp_le_left _ _)\n#align rank_mul_le_left rank_mul_le_left\n\n",
 "rank_mul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem rank_mul_le [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (matrix.mul A B).rank ≤ min A.rank B.rank :=\n  le_min (rank_mul_le_left _ _) (rank_mul_le_right _ _)\n#align rank_mul_le rank_mul_le\n\n",
 "rank_le_width":
 "theorem rank_le_width [StrongRankCondition R] {m n : ℕ} (A : Matrix (Fin m) (Fin n) R) : A.rank ≤ n :=\n  A.rank_le_card_width.trans <| (Fintype.card_fin n).le\n#align rank_le_width rank_le_width\n\n",
 "rank_le_height":
 "theorem rank_le_height [StrongRankCondition R] {m n : ℕ} (A : Matrix (Fin m) (Fin n) R) : A.rank ≤ m :=\n  A.rank_le_card_height.trans <| (Fintype.card_fin m).le\n#align rank_le_height rank_le_height\n\n",
 "rank_le_card_width":
 "theorem rank_le_card_width [StrongRankCondition R] (A : Matrix m n R) : A.rank ≤ Fintype.card n :=\n  by\n  haveI : Module.Finite R (n → R) := Module.Finite.pi\n  haveI : Module.Free R (n → R) := Module.Free.pi _ _\n  exact A.mul_vec_lin.finrank_range_le.trans_eq (finrank_pi _)\n#align rank_le_card_width rank_le_card_width\n\n",
 "rank_le_card_height":
 "theorem rank_le_card_height [StrongRankCondition R] (A : Matrix m n R) : A.rank ≤ Fintype.card m :=\n  by\n  haveI : Module.Finite R (m → R) := Module.Finite.pi\n  haveI : Module.Free R (m → R) := Module.Free.pi _ _\n  exact (Submodule.finrank_le _).trans (finrank_pi R).le\n#align rank_le_card_height rank_le_card_height\n\n",
 "rank_eq_finrank_span_row":
 "/-- The rank of a matrix is the rank of the space spanned by its rows.\n\nTODO: prove this in a generality that works for `ℂ` too, not just `ℚ` and `ℝ`. -/\ntheorem rank_eq_finrank_span_row [LinearOrderedField R] [Finite m] (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range A)) :=\n  by\n  cases nonempty_fintype m\n  rw [← rank_transpose, rank_eq_finrank_span_cols, transpose_transpose]\n#align rank_eq_finrank_span_row rank_eq_finrank_span_row\n\n",
 "rank_eq_finrank_span_cols":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/-- The rank of a matrix is the rank of the space spanned by its columns. -/\ntheorem rank_eq_finrank_span_cols (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range (matrix.transpose A))) := by rw [rank, Matrix.range_mulVecLin]\n#align rank_eq_finrank_span_cols rank_eq_finrank_span_cols\n\n",
 "rank_eq_finrank_range_to_lin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem rank_eq_finrank_range_to_lin [DecidableEq n] {M₁ M₂ : Type _} [AddCommGroup M₁] [AddCommGroup M₂] [Module R M₁]\n    [Module R M₂] (A : Matrix m n R) (v₁ : Basis m R M₁) (v₂ : Basis n R M₂) :\n    A.rank = finrank R (toLin v₂ v₁ A).range :=\n  by\n  let e₁ := (Pi.basisFun R m).equiv v₁ (Equiv.refl _)\n  let e₂ := (Pi.basisFun R n).equiv v₂ (Equiv.refl _)\n  have range_e₂ : (e₂ : «expr →ₗ[ ] » (n → R) R M₂).range = «expr⊤» :=\n    by\n    rw [LinearMap.range_eq_top]\n    exact e₂.surjective\n  refine' LinearEquiv.finrank_eq (e₁.of_submodules _ _ _)\n  rw [← LinearMap.range_comp, ← LinearMap.range_comp_of_range_eq_top (to_lin v₂ v₁ A) range_e₂]\n  congr 1\n  apply LinearMap.pi_ext'\n  rintro i\n  apply LinearMap.ext_ring\n  have aux₁ := to_lin_self (Pi.basisFun R n) (Pi.basisFun R m) A i\n  have aux₂ := Basis.equiv_apply (Pi.basisFun R n) i v₂\n  rw [to_lin_eq_to_lin', to_lin'_apply'] at aux₁\n  rw [Pi.basisFun_apply, LinearMap.coe_stdBasis] at aux₁ aux₂\n  simp only [LinearMap.comp_apply, e₁, e₂, LinearEquiv.coe_coe, Equiv.refl_apply, aux₁, aux₂, LinearMap.coe_single,\n    to_lin_self, LinearEquiv.map_sum, LinearEquiv.map_smul, Basis.equiv_apply]\n#align rank_eq_finrank_range_to_lin rank_eq_finrank_range_to_lin\n\n",
 "rank_conj_transpose_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem rank_conj_transpose_mul_self (A : Matrix m n R) : (matrix.mul (matrix.conj_transpose A) A).rank = A.rank :=\n  by\n  dsimp only [rank]\n  refine' add_left_injective (finrank R A.mul_vec_lin.ker) _\n  dsimp only\n  rw [LinearMap.finrank_range_add_finrank_ker, ←\n    (matrix.mul (matrix.conj_transpose A) A).mul_vec_lin.finrank_range_add_finrank_ker]\n  congr 1\n  rw [ker_mul_vec_lin_conj_transpose_mul_self]\n#align rank_conj_transpose_mul_self rank_conj_transpose_mul_self\n\n",
 "rank_conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n-- this follows the proof here https://math.stackexchange.com/a/81903/1896\n/-- TODO: prove this in greater generality. -/\n@[simp]\ntheorem rank_conj_transpose (A : Matrix m n R) : (matrix.conj_transpose A).rank = A.rank :=\n  le_antisymm\n    (((rank_conjTranspose_mul_self _).symm.trans_le <| rank_mul_le_left _ _).trans_eq <|\n      congr_arg _ <| conjTranspose_conjTranspose _)\n    ((rank_conjTranspose_mul_self _).symm.trans_le <| rank_mul_le_left _ _)\n#align rank_conj_transpose rank_conj_transpose\n\n",
 "ker_mul_vec_lin_transpose_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem ker_mul_vec_lin_transpose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (matrix.mul (matrix.transpose A) A).mul_vec_lin = LinearMap.ker (mulVecLin A) :=\n  by\n  ext x\n  simp only [LinearMap.mem_ker, mul_vec_lin_apply, ← mul_vec_mul_vec]\n  constructor\n  · intro h\n    replace h := congr_arg (dot_product x) h\n    rwa [dot_product_mul_vec, dot_product_zero, vec_mul_transpose, dot_product_self_eq_zero] at h\n  · intro h\n    rw [h, mul_vec_zero]\n#align ker_mul_vec_lin_transpose_mul_self ker_mul_vec_lin_transpose_mul_self\n\n",
 "ker_mul_vec_lin_conj_transpose_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem ker_mul_vec_lin_conj_transpose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (matrix.mul (matrix.conj_transpose A) A).mul_vec_lin = LinearMap.ker (mulVecLin A) :=\n  by\n  ext x\n  simp only [LinearMap.mem_ker, mul_vec_lin_apply, ← mul_vec_mul_vec]\n  constructor\n  · intro h\n    replace h := congr_arg (dot_product (star x)) h\n    rwa [dot_product_mul_vec, dot_product_zero, vec_mul_conj_transpose, star_star, dot_product_star_self_eq_zero] at h\n  · intro h\n    rw [h, mul_vec_zero]\n#align ker_mul_vec_lin_conj_transpose_mul_self ker_mul_vec_lin_conj_transpose_mul_self\n\n"}