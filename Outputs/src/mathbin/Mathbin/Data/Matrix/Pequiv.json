{"to_pequiv_mul_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem to_pequiv_mul_matrix [Fintype m] [DecidableEq m] [Semiring α] (f : «expr ≃ » m m) (M : Matrix m n α) :\n    matrix.mul f.to_pequiv.to_matrix M = fun i => M (f i) :=\n  by\n  ext (i j)\n  rw [mul_matrix_apply, Equiv.toPEquiv_apply]\n#align to_pequiv_mul_matrix to_pequiv_mul_matrix\n\n",
 "to_matrix_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem to_matrix_trans [Fintype m] [DecidableEq m] [DecidableEq n] [Semiring α] (f : «expr ≃. » l m)\n    (g : «expr ≃. » m n) : ((f.trans g).to_matrix : Matrix l n α) = matrix.mul f.to_matrix g.to_matrix :=\n  by\n  ext (i j)\n  rw [mul_matrix_apply]\n  dsimp [to_matrix, PEquiv.trans]\n  cases f i <;> simp\n#align to_matrix_trans to_matrix_trans\n\n",
 "to_matrix_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem to_matrix_symm [DecidableEq m] [DecidableEq n] [Zero α] [One α] (f : «expr ≃. » m n) :\n    (f.symm.to_matrix : Matrix n m α) = matrix.transpose f.to_matrix := by\n  ext <;> simp only [transpose, mem_iff_mem f, to_matrix_apply] <;> congr\n#align to_matrix_symm to_matrix_symm\n\n",
 "to_matrix_swap":
 "theorem to_matrix_swap [DecidableEq n] [Ring α] (i j : n) :\n    (Equiv.swap i j).to_pequiv.to_matrix =\n      (1 : Matrix n n α) - (single i i).to_matrix - (single j j).to_matrix + (single i j).to_matrix +\n        (single j i).to_matrix :=\n  by\n  ext\n  dsimp [to_matrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]\n  split_ifs <;>\n    first\n      |· simp_all|·\n        exfalso\n        assumption\n#align to_matrix_swap to_matrix_swap\n\n",
 "to_matrix_refl":
 "@[simp]\ntheorem to_matrix_refl [DecidableEq n] [Zero α] [One α] : ((PEquiv.refl n).to_matrix : Matrix n n α) = 1 := by\n  ext <;> simp [to_matrix_apply, one_apply] <;> congr\n#align to_matrix_refl to_matrix_refl\n\n",
 "to_matrix_injective":
 "theorem to_matrix_injective [DecidableEq n] [MonoidWithZero α] [Nontrivial α] :\n    function.injective (@toMatrix m n α _ _ _) := by\n  classical\n    intro f g\n    refine' not_imp_not.1 _\n    simp only [matrix.ext_iff.symm, to_matrix_apply, PEquiv.ext_iff, not_forall, exists_imp]\n    intro i hi\n    use i\n    cases' hf : f i with fi\n    · cases' hg : g i with gi\n      · cc\n      · use gi\n        simp\n    · use fi\n      simp [hf.symm, ne.symm hi]\n#align to_matrix_injective to_matrix_injective\n\n",
 "to_matrix_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem to_matrix_bot [DecidableEq n] [Zero α] [One α] : ((«expr⊥» : PEquiv m n).to_matrix : Matrix m n α) = 0 :=\n  rfl\n#align to_matrix_bot to_matrix_bot\n\n",
 "to_matrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃. » -/\n/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n-- TODO: set as an equation lemma for `to_matrix`, see mathlib4#3024\n@[simp]\ntheorem to_matrix_apply [DecidableEq n] [Zero α] [One α] (f : «expr ≃. » m n) (i j) :\n    toMatrix f i j = if j ∈ f i then (1 : α) else 0 :=\n  rfl\n#align to_matrix_apply to_matrix_apply\n\n",
 "single_mul_single_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Restatement of `single_mul_single`, which will simplify expressions in `simp` normal form,\n  when associativity may otherwise need to be carefully applied. -/\n@[simp]\ntheorem single_mul_single_right [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k] [DecidableEq m] [Semiring α]\n    (a : m) (b : n) (c : k) (M : Matrix k l α) :\n    matrix.mul (single a b).to_matrix (matrix.mul (single b c).to_matrix M) = matrix.mul (single a c).to_matrix M := by\n  rw [← Matrix.mul_assoc, single_mul_single]\n#align single_mul_single_right single_mul_single_right\n\n",
 "single_mul_single_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem single_mul_single_of_ne [Fintype n] [DecidableEq n] [DecidableEq k] [DecidableEq m] [Semiring α] {b₁ b₂ : n}\n    (hb : b₁ ≠ b₂) (a : m) (c : k) : matrix.mul ((single a b₁).to_matrix : Matrix _ _ α) (single b₂ c).to_matrix = 0 :=\n  by rw [← to_matrix_trans, single_trans_single_of_ne hb, to_matrix_bot]\n#align single_mul_single_of_ne single_mul_single_of_ne\n\n",
 "single_mul_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem single_mul_single [Fintype n] [DecidableEq k] [DecidableEq m] [DecidableEq n] [Semiring α] (a : m) (b : n)\n    (c : k) : matrix.mul ((single a b).to_matrix : Matrix _ _ α) (single b c).to_matrix = (single a c).to_matrix := by\n  rw [← to_matrix_trans, single_trans_single]\n#align single_mul_single single_mul_single\n\n",
 "mul_to_pequiv_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem mul_to_pequiv_to_matrix {m n α : Type _} [Fintype n] [DecidableEq n] [Semiring α] (f : «expr ≃ » n n)\n    (M : Matrix m n α) : matrix.mul M f.to_pequiv.to_matrix = M.submatrix id f.symm :=\n  Matrix.ext fun i j => by\n    rw [PEquiv.matrix_mul_apply, ← Equiv.toPEquiv_symm, Equiv.toPEquiv_apply, Matrix.submatrix_apply, id.def]\n#align mul_to_pequiv_to_matrix mul_to_pequiv_to_matrix\n\n",
 "mul_matrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem mul_matrix_apply [Fintype m] [DecidableEq m] [Semiring α] (f : «expr ≃. » l m) (M : Matrix m n α) (i j) :\n    (matrix.mul f.to_matrix M) i j = option.cases_on (f i) 0 fun fi => M fi j :=\n  by\n  dsimp [to_matrix, Matrix.mul_apply]\n  cases' h : f i with fi\n  · simp [h]\n  · rw [Finset.sum_eq_single fi] <;> simp (config := { contextual := true }) [h, eq_comm]\n#align mul_matrix_apply mul_matrix_apply\n\n",
 "matrix_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃. » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem matrix_mul_apply [Fintype m] [Semiring α] [DecidableEq n] (M : Matrix l m α) (f : «expr ≃. » m n) (i j) :\n    (matrix.mul M f.to_matrix) i j = option.cases_on (f.symm j) 0 fun fj => M i fj :=\n  by\n  dsimp [to_matrix, Matrix.mul_apply]\n  cases' h : f.symm j with fj\n  · simp [h, ← f.eq_some_iff]\n  · rw [Finset.sum_eq_single fj]\n    · simp [h, ← f.eq_some_iff]\n    · intro b H n\n      simp [h, ← f.eq_some_iff, n.symm]\n    · simp\n#align matrix_mul_apply matrix_mul_apply\n\n",
 "equiv_to_pequiv_to_matrix":
 "/-- We can also define permutation matrices by permuting the rows of the identity matrix. -/\ntheorem equiv_to_pequiv_to_matrix [DecidableEq n] [Zero α] [One α] (σ : Equiv n n) (i j : n) :\n    σ.to_pequiv.to_matrix i j = (1 : Matrix n n α) (σ i) j :=\n  if_congr Option.some_inj rfl rfl\n#align equiv_to_pequiv_to_matrix equiv_to_pequiv_to_matrix\n\n"}