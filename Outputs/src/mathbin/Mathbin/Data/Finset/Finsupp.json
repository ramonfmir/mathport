{"mem_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem mem_pi {f : «expr →₀ » ι (Finset α)} {g : «expr →₀ » ι α} : g ∈ f.pi ↔ ∀ i, g i ∈ f i :=\n  mem_finsupp_iff_of_support_subset <| Subset.refl _\n#align mem_pi mem_pi\n\n",
 "mem_finsupp_iff_of_support_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- When `t` is supported on `s`, `f ∈ s.finsupp t` precisely means that `f` is pointwise in `t`. -/\n@[simp]\ntheorem mem_finsupp_iff_of_support_subset {t : «expr →₀ » ι (Finset α)} (ht : t.support ⊆ s) :\n    f ∈ s.finsupp t ↔ ∀ i, f i ∈ t i :=\n  by\n  refine'\n    mem_finsupp_iff.trans\n      (forall_and_distrib.symm.trans <|\n        forall_congr' fun i =>\n          ⟨fun h => _, fun h => ⟨fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi _, fun _ => h⟩⟩)\n  · by_cases hi : i ∈ s\n    · exact h.2 hi\n    · rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 fun H => hi <| ht H]\n      exact zero_mem_zero\n  · rwa [H, mem_zero] at h\n#align mem_finsupp_iff_of_support_subset mem_finsupp_iff_of_support_subset\n\n",
 "mem_finsupp_iff":
 "/-\nCopyright (c) 2022 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\ntheorem mem_finsupp_iff {t : ι → Finset α} : f ∈ s.finsupp t ↔ f.support ⊆ s ∧ ∀ i ∈ s, f i ∈ t i :=\n  by\n  refine' mem_map.trans ⟨_, _⟩\n  · rintro ⟨f, hf, rfl⟩\n    refine' ⟨support_indicator_subset _ _, fun i hi => _⟩\n    convert mem_pi.1 hf i hi\n    exact indicator_of_mem hi _\n  · refine' fun h => ⟨fun i _ => f i, mem_pi.2 h.2, _⟩\n    ext i\n    exact ite_eq_left_iff.2 fun hi => (not_mem_support_iff.1 fun H => hi <| h.1 H).symm\n#align mem_finsupp_iff mem_finsupp_iff\n\n",
 "card_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem card_pi (f : «expr →₀ » ι (Finset α)) : f.pi.card = f.prod fun i => (f i).card :=\n  by\n  rw [pi, card_finsupp]\n  exact Finset.prod_congr rfl fun i _ => by simp only [Pi.nat_apply, Nat.cast_id]\n#align card_pi card_pi\n\n",
 "card_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem card_finsupp (s : Finset ι) (t : ι → Finset α) :\n    (s.finsupp t).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (t i).card :=\n  (card_map _).trans <| card_pi _ _\n#align card_finsupp card_finsupp\n\n"}