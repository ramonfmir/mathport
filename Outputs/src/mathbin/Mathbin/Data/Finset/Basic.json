{"val_to_finset":
 "@[simp]\ntheorem val_to_finset [decidable_eq α] (s : Finset α) : s.val.to_finset = s :=\n  by\n  ext\n  rw [Multiset.mem_toFinset, ← mem_def]\n#align val_to_finset val_to_finset\n\n",
 "val_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem val_lt_iff {s₁ s₂ : Finset α} : s₁.1 < s₂.1 ↔ «expr ⊂ » s₁ s₂ :=\n  and_congr val_le_iff <| not_congr val_le_iff\n#align val_lt_iff val_lt_iff\n\n",
 "val_le_iff_val_subset":
 "theorem val_le_iff_val_subset {a : Finset α} {b : Multiset α} : a.val ≤ b ↔ a.val ⊆ b :=\n  Multiset.le_iff_subset a.nodup\n#align val_le_iff_val_subset val_le_iff_val_subset\n\n",
 "val_le_iff":
 "@[simp]\ntheorem val_le_iff {s₁ s₂ : Finset α} : s₁.1 ≤ s₂.1 ↔ s₁ ⊆ s₂ :=\n  le_iff_subset s₁.2\n#align val_le_iff val_le_iff\n\n",
 "val_injective":
 "theorem val_injective : injective (val : Finset α → Multiset α) := fun _ _ => eq_of_veq\n#align val_injective val_injective\n\n",
 "val_inj":
 "@[simp]\ntheorem val_inj {s t : Finset α} : s.1 = t.1 ↔ s = t :=\n  val_injective.eq_iff\n#align val_inj val_inj\n\n",
 "val_eq_zero":
 "@[simp]\ntheorem val_eq_zero {s : Finset α} : s.1 = 0 ↔ s = ∅ :=\n  @val_inj _ s ∅\n#align val_eq_zero val_eq_zero\n\n",
 "update_piecewise_of_not_mem":
 "theorem update_piecewise_of_not_mem [decidable_eq α] {i : α} (hi : i ∉ s) (v : δ i) :\n    update (s.piecewise f g) i v = s.piecewise f (update g i v) :=\n  by\n  rw [update_piecewise]\n  refine' s.piecewise_congr (fun j hj => update_noteq _ _ _) fun _ _ => rfl\n  exact fun h => hi (h ▸ hj)\n#align update_piecewise_of_not_mem update_piecewise_of_not_mem\n\n",
 "update_piecewise_of_mem":
 "theorem update_piecewise_of_mem [decidable_eq α] {i : α} (hi : i ∈ s) (v : δ i) :\n    update (s.piecewise f g) i v = s.piecewise (update f i v) g :=\n  by\n  rw [update_piecewise]\n  refine' s.piecewise_congr (fun _ _ => rfl) fun j hj => update_noteq _ _ _\n  exact fun h => hj (h.symm ▸ hi)\n#align update_piecewise_of_mem update_piecewise_of_mem\n\n",
 "update_piecewise":
 "theorem update_piecewise [decidable_eq α] (i : α) (v : δ i) :\n    update (s.piecewise f g) i v = s.piecewise (update f i v) (update g i v) :=\n  by\n  ext j\n  rcases em (j = i) with (rfl | hj) <;> by_cases hs : j ∈ s <;> simp [*]\n#align update_piecewise update_piecewise\n\n",
 "update_eq_piecewise":
 "theorem update_eq_piecewise {β : Type _} [decidable_eq α] (f : α → β) (i : α) (v : β) :\n    update f i v = piecewise (singleton i) (fun j => v) f :=\n  (piecewise_singleton _ _ _).symm\n#align update_eq_piecewise update_eq_piecewise\n\n",
 "union_val_nd":
 "theorem union_val_nd (s t : Finset α) : (s ∪ t).1 = ndunion s.1 t.1 :=\n  rfl\n#align union_val_nd union_val_nd\n\n",
 "union_val":
 "@[simp]\ntheorem union_val (s t : Finset α) : (s ∪ t).1 = s.1 ∪ t.1 :=\n  ndunion_eq_union s.2\n#align union_val union_val\n\n",
 "union_union_union_comm":
 "theorem union_union_union_comm (s t u v : Finset α) : s ∪ t ∪ (u ∪ v) = s ∪ u ∪ (t ∪ v) :=\n  sup_sup_sup_comm _ _ _ _\n#align union_union_union_comm union_union_union_comm\n\n",
 "union_union_distrib_right":
 "theorem union_union_distrib_right (s t u : Finset α) : s ∪ t ∪ u = s ∪ u ∪ (t ∪ u) :=\n  sup_sup_distrib_right _ _ _\n#align union_union_distrib_right union_union_distrib_right\n\n",
 "union_union_distrib_left":
 "theorem union_union_distrib_left (s t u : Finset α) : s ∪ (t ∪ u) = s ∪ t ∪ (s ∪ u) :=\n  sup_sup_distrib_left _ _ _\n#align union_union_distrib_left union_union_distrib_left\n\n",
 "union_subset_union":
 "theorem union_subset_union (hsu : s ⊆ u) (htv : t ⊆ v) : s ∪ t ⊆ u ∪ v :=\n  sup_le_sup (le_iff_subset.2 hsu) htv\n#align union_subset_union union_subset_union\n\n",
 "union_subset_right":
 "theorem union_subset_right {s t u : Finset α} (h : s ∪ t ⊆ u) : t ⊆ u :=\n  Subset.trans (subset_union_right _ _) h\n#align union_subset_right union_subset_right\n\n",
 "union_subset_left":
 "theorem union_subset_left (h : s ∪ t ⊆ u) : s ⊆ u :=\n  (subset_union_left _ _).trans h\n#align union_subset_left union_subset_left\n\n",
 "union_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem union_subset_iff : s ∪ t ⊆ u ↔ s ⊆ u ∧ t ⊆ u :=\n  (sup_le_iff : «expr ⊔ » s t ≤ u ↔ s ≤ u ∧ t ≤ u)\n#align union_subset_iff union_subset_iff\n\n",
 "union_subset":
 "theorem union_subset (hs : s ⊆ u) : t ⊆ u → s ∪ t ⊆ u :=\n  sup_le <| le_iff_subset.2 hs\n#align union_subset union_subset\n\n",
 "union_self":
 "theorem union_self (s : Finset α) : s ∪ s = s :=\n  union_idempotent s\n#align union_self union_self\n\n",
 "union_sdiff_symm":
 "theorem union_sdiff_symm : s ∪ t \\ s = t ∪ s \\ t := by simp [union_comm]\n#align union_sdiff_symm union_sdiff_symm\n\n",
 "union_sdiff_self_eq_union":
 "@[simp]\ntheorem union_sdiff_self_eq_union : s ∪ t \\ s = s ∪ t :=\n  sup_sdiff_self_right _ _\n#align union_sdiff_self_eq_union union_sdiff_self_eq_union\n\n",
 "union_sdiff_self":
 "theorem union_sdiff_self (s t : Finset α) : (s ∪ t) \\ t = s \\ t :=\n  sup_sdiff_right_self\n#align union_sdiff_self union_sdiff_self\n\n",
 "union_sdiff_right":
 "theorem union_sdiff_right (s t : Finset α) : (s ∪ t) \\ t = s \\ t :=\n  sup_sdiff_right_self\n#align union_sdiff_right union_sdiff_right\n\n",
 "union_sdiff_of_subset":
 "theorem union_sdiff_of_subset (h : s ⊆ t) : s ∪ t \\ s = t :=\n  sup_sdiff_cancel_right h\n#align union_sdiff_of_subset union_sdiff_of_subset\n\n",
 "union_sdiff_left":
 "theorem union_sdiff_left (s t : Finset α) : (s ∪ t) \\ s = t \\ s :=\n  sup_sdiff_left_self\n#align union_sdiff_left union_sdiff_left\n\n",
 "union_sdiff_distrib":
 "theorem union_sdiff_distrib (s₁ s₂ t : Finset α) : (s₁ ∪ s₂) \\ t = s₁ \\ t ∪ s₂ \\ t :=\n  sup_sdiff\n#align union_sdiff_distrib union_sdiff_distrib\n\n",
 "union_right_idem":
 "@[simp]\ntheorem union_right_idem (s t : Finset α) : s ∪ t ∪ t = s ∪ t :=\n  sup_right_idem\n#align union_right_idem union_right_idem\n\n",
 "union_right_comm":
 "theorem union_right_comm (s t u : Finset α) : s ∪ t ∪ u = s ∪ u ∪ t :=\n  ext fun x => by simp only [mem_union, or_assoc', or_comm' (x ∈ t)]\n#align union_right_comm union_right_comm\n\n",
 "union_left_idem":
 "@[simp]\ntheorem union_left_idem (s t : Finset α) : s ∪ (s ∪ t) = s ∪ t :=\n  sup_left_idem\n#align union_left_idem union_left_idem\n\n",
 "union_left_comm":
 "theorem union_left_comm (s t u : Finset α) : s ∪ (t ∪ u) = t ∪ (s ∪ u) :=\n  ext fun _ => by simp only [mem_union, or_left_comm]\n#align union_left_comm union_left_comm\n\n",
 "union_inter_cancel_right":
 "@[simp]\ntheorem union_inter_cancel_right {s t : Finset α} : (s ∪ t) ∩ t = t := by\n  rw [← coe_inj, coe_inter, coe_union, Set.union_inter_cancel_right]\n#align union_inter_cancel_right union_inter_cancel_right\n\n",
 "union_inter_cancel_left":
 "@[simp]\ntheorem union_inter_cancel_left {s t : Finset α} : (s ∪ t) ∩ s = s := by\n  rw [← coe_inj, coe_inter, coe_union, Set.union_inter_cancel_left]\n#align union_inter_cancel_left union_inter_cancel_left\n\n",
 "union_insert":
 "@[simp]\ntheorem union_insert (a : α) (s t : Finset α) : s ∪ insert a t = insert a (s ∪ t) := by\n  simp only [insert_eq, union_left_comm]\n#align union_insert union_insert\n\n",
 "union_idempotent":
 "@[simp]\ntheorem union_idempotent (s : Finset α) : s ∪ s = s :=\n  sup_idem\n#align union_idempotent union_idempotent\n\n",
 "union_eq_union_iff_right":
 "theorem union_eq_union_iff_right : s ∪ u = t ∪ u ↔ s ⊆ t ∪ u ∧ t ⊆ s ∪ u :=\n  sup_eq_sup_iff_right\n#align union_eq_union_iff_right union_eq_union_iff_right\n\n",
 "union_eq_union_iff_left":
 "theorem union_eq_union_iff_left : s ∪ t = s ∪ u ↔ t ⊆ s ∪ u ∧ u ⊆ s ∪ t :=\n  sup_eq_sup_iff_left\n#align union_eq_union_iff_left union_eq_union_iff_left\n\n",
 "union_eq_sdiff_union_sdiff_union_inter":
 "theorem union_eq_sdiff_union_sdiff_union_inter (s t : Finset α) : s ∪ t = s \\ t ∪ t \\ s ∪ s ∩ t :=\n  sup_eq_sdiff_sup_sdiff_sup_inf\n#align union_eq_sdiff_union_sdiff_union_inter union_eq_sdiff_union_sdiff_union_inter\n\n",
 "union_eq_right_iff_subset":
 "@[simp]\ntheorem union_eq_right_iff_subset {s t : Finset α} : s ∪ t = t ↔ s ⊆ t :=\n  sup_eq_right\n#align union_eq_right_iff_subset union_eq_right_iff_subset\n\n",
 "union_eq_left_iff_subset":
 "@[simp]\ntheorem union_eq_left_iff_subset {s t : Finset α} : s ∪ t = s ↔ t ⊆ s :=\n  sup_eq_left\n#align union_eq_left_iff_subset union_eq_left_iff_subset\n\n",
 "union_eq_empty_iff":
 "theorem union_eq_empty_iff (A B : Finset α) : A ∪ B = ∅ ↔ A = ∅ ∧ B = ∅ :=\n  sup_eq_bot_iff\n#align union_eq_empty_iff union_eq_empty_iff\n\n",
 "union_empty":
 "@[simp]\ntheorem union_empty (s : Finset α) : s ∪ ∅ = s :=\n  ext fun x => mem_union.trans <| or_false_iff _\n#align union_empty union_empty\n\n",
 "union_distrib_right":
 "theorem union_distrib_right (s t u : Finset α) : s ∩ t ∪ u = (s ∪ u) ∩ (t ∪ u) :=\n  sup_inf_right\n#align union_distrib_right union_distrib_right\n\n",
 "union_distrib_left":
 "theorem union_distrib_left (s t u : Finset α) : s ∪ t ∩ u = (s ∪ t) ∩ (s ∪ u) :=\n  sup_inf_left\n#align union_distrib_left union_distrib_left\n\n",
 "union_congr_right":
 "theorem union_congr_right (hs : s ⊆ t ∪ u) (ht : t ⊆ s ∪ u) : s ∪ u = t ∪ u :=\n  sup_congr_right hs ht\n#align union_congr_right union_congr_right\n\n",
 "union_congr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem union_congr_left (ht : t ⊆ s ∪ u) (hu : u ⊆ s ∪ t) : s ∪ t = «expr ⊔ » s u :=\n  sup_congr_left ht hu\n#align union_congr_left union_congr_left\n\n",
 "union_comm":
 "theorem union_comm (s₁ s₂ : Finset α) : s₁ ∪ s₂ = s₂ ∪ s₁ :=\n  sup_comm\n#align union_comm union_comm\n\n",
 "union_assoc":
 "@[simp]\ntheorem union_assoc (s₁ s₂ s₃ : Finset α) : s₁ ∪ s₂ ∪ s₃ = s₁ ∪ (s₂ ∪ s₃) :=\n  sup_assoc\n#align union_assoc union_assoc\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\ntheorem superset.trans {s₁ s₂ s₃ : Finset α} : «expr ⊇ » s₁ s₂ → «expr ⊇ » s₂ s₃ → «expr ⊇ » s₁ s₃ := fun h' h =>\n  Subset.trans h h'\n#align superset.trans superset.trans\n\n",
 "to_type":
 "theorem nonempty.to_type {s : Finset α} : s.nonempty → nonempty α := fun ⟨x, hx⟩ => ⟨x⟩\n#align nonempty.to_type nonempty.to_type\n\n",
 "to_subtype":
 "theorem nonempty.to_subtype {s : Finset α} : s.nonempty → nonempty s :=\n  nonempty_coe_sort.2\n#align nonempty.to_subtype nonempty.to_subtype\n\n",
 "to_list_to_finset":
 "@[simp]\ntheorem to_list_to_finset [decidable_eq α] (s : Finset α) : s.to_list.to_finset = s :=\n  by\n  ext\n  simp\n#align to_list_to_finset to_list_to_finset\n\n",
 "to_list_ne_nil":
 "theorem nonempty.to_list_ne_nil {s : Finset α} (hs : s.nonempty) : s.to_list ≠ [] :=\n  mt toList_eq_nil.mp hs.ne_empty\n#align nonempty.to_list_ne_nil nonempty.to_list_ne_nil\n\n",
 "to_list_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem to_list_insert [decidable_eq α] {a : α} {s : Finset α} (h : a ∉ s) :\n    list.perm (insert a s).to_list (a :: s.to_list) :=\n  cons_eq_insert _ _ h ▸ toList_cons _\n#align to_list_insert to_list_insert\n\n",
 "to_list_eq_nil":
 "@[simp]\ntheorem to_list_eq_nil {s : Finset α} : s.to_list = [] ↔ s = ∅ :=\n  toList_eq_nil.trans val_eq_zero\n#align to_list_eq_nil to_list_eq_nil\n\n",
 "to_list_empty":
 "@[simp]\ntheorem to_list_empty : (∅ : Finset α).to_list = [] :=\n  toList_eq_nil.mpr rfl\n#align to_list_empty to_list_empty\n\n",
 "to_list_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem to_list_cons {a : α} {s : Finset α} (h : a ∉ s) : list.perm (cons a s h).to_list (a :: s.to_list) :=\n  (List.perm_ext (nodup_toList _) (by simp [h, nodup_to_list s])).2 fun x => by\n    simp only [List.mem_cons, Finset.mem_toList, Finset.mem_cons]\n#align to_list_cons to_list_cons\n\n",
 "to_finset_zero":
 "@[simp]\ntheorem to_finset_zero : toFinset (0 : Multiset α) = ∅ :=\n  rfl\n#align to_finset_zero to_finset_zero\n\n",
 "to_finset_val":
 "@[simp]\ntheorem to_finset_val (l : list α) : l.to_finset.1 = (l.dedup : Multiset α) :=\n  rfl\n#align to_finset_val to_finset_val\n\n",
 "to_finset_union":
 "@[simp]\ntheorem to_finset_union (l l' : list α) : (l ∪ l').to_finset = l.to_finset ∪ l'.to_finset :=\n  by\n  ext\n  simp\n#align to_finset_union to_finset_union\n\n",
 "to_finset_surjective":
 "theorem to_finset_surjective : surjective (toFinset : list α → Finset α) := fun s =>\n  let ⟨l, _, hls⟩ := toFinset_surj_on (Set.mem_univ s)\n  ⟨l, hls⟩\n#align to_finset_surjective to_finset_surjective\n\n",
 "to_finset_surj_on":
 "theorem to_finset_surj_on : Set.SurjOn toFinset { l : list α | l.nodup } Set.univ :=\n  by\n  rintro ⟨⟨l⟩, hl⟩ _\n  exact ⟨l, hl, (to_finset_eq hl).symm⟩\n#align to_finset_surj_on to_finset_surj_on\n\n",
 "to_finset_subset":
 "@[simp]\ntheorem to_finset_subset : s.to_finset ⊆ t.to_finset ↔ s ⊆ t := by\n  simp only [Finset.subset_iff, Multiset.subset_iff, Multiset.mem_toFinset]\n#align to_finset_subset to_finset_subset\n\n",
 "to_finset_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem to_finset_ssubset : «expr ⊂ » s.to_finset t.to_finset ↔ «expr ⊂ » s t :=\n  by\n  simp_rw [Finset.ssubset_def, to_finset_subset]\n  rfl\n#align to_finset_ssubset to_finset_ssubset\n\n",
 "to_finset_singleton":
 "@[simp]\ntheorem to_finset_singleton (a : α) : toFinset ({a} : Multiset α) = {a} := by\n  rw [← cons_zero, to_finset_cons, to_finset_zero, is_lawful_singleton.insert_emptyc_eq]\n#align to_finset_singleton to_finset_singleton\n\n",
 "to_finset_reverse":
 "@[simp]\ntheorem to_finset_reverse {l : list α} : toFinset l.reverse = l.to_finset :=\n  toFinset_eq_of_perm _ _ (reverse_perm l)\n#align to_finset_reverse to_finset_reverse\n\n",
 "to_finset_replicate_of_ne_zero":
 "theorem to_finset_replicate_of_ne_zero {n : ℕ} (hn : n ≠ 0) : (list.replicate n a).to_finset = {a} :=\n  by\n  ext x\n  simp [hn, list.mem_replicate]\n#align to_finset_replicate_of_ne_zero to_finset_replicate_of_ne_zero\n\n",
 "to_finset_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem to_finset_nsmul (s : Multiset α) : ∀ (n : ℕ) (hn : n ≠ 0), («expr • » n s).to_finset = s.to_finset\n  | 0, h => by contradiction\n  | n + 1, h => by\n    by_cases n = 0\n    · rw [h, zero_add, one_nsmul]\n    · rw [add_nsmul, to_finset_add, one_nsmul, to_finset_nsmul n h, Finset.union_idempotent]\n#align to_finset_nsmul to_finset_nsmul\n\n",
 "to_finset_nil":
 "@[simp]\ntheorem to_finset_nil : toFinset (@nil α) = ∅ :=\n  rfl\n#align to_finset_nil to_finset_nil\n\n",
 "to_finset_inter":
 "@[simp]\ntheorem to_finset_inter (l l' : list α) : (l ∩ l').to_finset = l.to_finset ∩ l'.to_finset :=\n  by\n  ext\n  simp\n#align to_finset_inter to_finset_inter\n\n",
 "to_finset_inj":
 "theorem nodup.to_finset_inj {l l' : Multiset α} (hl : Nodup l) (hl' : Nodup l') (h : l.to_finset = l'.to_finset) :\n    l = l' := by simpa [← to_finset_eq hl, ← to_finset_eq hl'] using h\n#align nodup.to_finset_inj nodup.to_finset_inj\n\n",
 "to_finset_eq_of_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem to_finset_eq_of_perm (l l' : list α) (h : list.perm l l') : l.to_finset = l'.to_finset :=\n  toFinset_eq_iff_perm_dedup.mpr h.dedup\n#align to_finset_eq_of_perm to_finset_eq_of_perm\n\n",
 "to_finset_eq_iff_perm_dedup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem to_finset_eq_iff_perm_dedup : l.to_finset = l'.to_finset ↔ list.perm l.dedup l'.dedup := by\n  simp [Finset.ext_iff, perm_ext (nodup_dedup _) (nodup_dedup _)]\n#align to_finset_eq_iff_perm_dedup to_finset_eq_iff_perm_dedup\n\n",
 "to_finset_eq_empty_iff":
 "@[simp]\ntheorem to_finset_eq_empty_iff (l : list α) : l.to_finset = ∅ ↔ l = nil := by cases l <;> simp\n#align to_finset_eq_empty_iff to_finset_eq_empty_iff\n\n",
 "to_finset_eq_empty":
 "@[simp]\ntheorem to_finset_eq_empty {m : Multiset α} : m.to_finset = ∅ ↔ m = 0 :=\n  Finset.val_inj.symm.trans Multiset.dedup_eq_zero\n#align to_finset_eq_empty to_finset_eq_empty\n\n",
 "to_finset_eq":
 "theorem to_finset_eq (n : Nodup l) : @finset.mk α l n = l.to_finset :=\n  Multiset.toFinset_eq n\n#align to_finset_eq to_finset_eq\n\n",
 "to_finset_dedup":
 "@[simp]\ntheorem to_finset_dedup (m : Multiset α) : m.dedup.to_finset = m.to_finset := by simp_rw [to_finset, dedup_idempotent]\n#align to_finset_dedup to_finset_dedup\n\n",
 "to_finset_cons":
 "@[simp]\ntheorem to_finset_cons : toFinset (a :: l) = insert a (toFinset l) :=\n  Finset.eq_of_veq <| by by_cases h : a ∈ l <;> simp [Finset.insert_val', Multiset.dedup_cons, h]\n#align to_finset_cons to_finset_cons\n\n",
 "to_finset_coe":
 "@[simp]\ntheorem to_finset_coe (l : list α) : (l : Multiset α).to_finset = l.to_finset :=\n  rfl\n#align to_finset_coe to_finset_coe\n\n",
 "to_finset_bind_dedup":
 "@[simp]\ntheorem to_finset_bind_dedup [decidable_eq β] (m : Multiset α) (f : α → Multiset β) :\n    (m.dedup.bind f).to_finset = (m.bind f).to_finset := by simp_rw [to_finset, dedup_bind_dedup]\n#align to_finset_bind_dedup to_finset_bind_dedup\n\n",
 "to_finset_append":
 "@[simp]\ntheorem to_finset_append : toFinset (l ++ l') = l.to_finset ∪ l'.to_finset :=\n  by\n  induction' l with hd tl hl\n  · simp\n  · simp [hl]\n#align to_finset_append to_finset_append\n\n",
 "to_finset_add":
 "@[simp]\ntheorem to_finset_add (s t : Multiset α) : toFinset (s + t) = toFinset s ∪ toFinset t :=\n  Finset.ext <| by simp\n#align to_finset_add to_finset_add\n\n",
 "sup_eq_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_eq_union : ((«expr ⊔ » · ·) : Finset α → Finset α → Finset α) = (· ∪ ·) :=\n  rfl\n#align sup_eq_union sup_eq_union\n\n",
 "subset_union_right":
 "theorem subset_union_right (s₁ s₂ : Finset α) : s₂ ⊆ s₁ ∪ s₂ := fun x => mem_union_right _\n#align subset_union_right subset_union_right\n\n",
 "subset_union_left":
 "theorem subset_union_left (s₁ s₂ : Finset α) : s₁ ⊆ s₁ ∪ s₂ := fun x => mem_union_left _\n#align subset_union_left subset_union_left\n\n",
 "subset_union_elim":
 "theorem subset_union_elim {s : Finset α} {t₁ t₂ : set α} (h : ↑s ⊆ t₁ ∪ t₂) :\n    ∃ s₁ s₂ : Finset α, s₁ ∪ s₂ = s ∧ ↑s₁ ⊆ t₁ ∧ ↑s₂ ⊆ t₂ \\ t₁ := by\n  classical\n    refine' ⟨s.filter (· ∈ t₁), s.filter (· ∉ t₁), _, _, _⟩\n    · simp [filter_union_right, em]\n    · intro x\n      simp\n    · intro x\n      simp\n      intro hx hx₂\n      refine' ⟨or.resolve_left (h hx) hx₂, hx₂⟩\n#align subset_union_elim subset_union_elim\n\n",
 "subset_singleton_iff'":
 "theorem subset_singleton_iff' {s : Finset α} {a : α} : s ⊆ {a} ↔ ∀ b ∈ s, b = a :=\n  forall₂_congr fun _ _ => mem_singleton\n#align subset_singleton_iff' subset_singleton_iff'\n\n",
 "subset_singleton_iff":
 "protected theorem nonempty.subset_singleton_iff {s : Finset α} {a : α} (h : s.nonempty) : s ⊆ {a} ↔ s = {a} :=\n  subset_singleton_iff.trans <| or_iff_right h.ne_empty\n#align nonempty.subset_singleton_iff nonempty.subset_singleton_iff\n\n",
 "subset_sdiff":
 "theorem subset_sdiff : s ⊆ t \\ u ↔ s ⊆ t ∧ Disjoint s u :=\n  le_iff_subset.symm.trans le_sdiff\n#align subset_sdiff subset_sdiff\n\n",
 "subset_of_eq":
 "#print subset_of_eq /-\nprotected theorem subset_of_eq {s t : Finset α} (h : s = t) : s ⊆ t :=\n  h ▸ Subset.refl _\n#align subset_of_eq subset_of_eq\n-/\n\n",
 "subset_inter_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem subset_inter_iff : s ⊆ t ∩ u ↔ s ⊆ t ∧ s ⊆ u :=\n  (le_inf_iff : s ≤ «expr ⊓ » t u ↔ s ≤ t ∧ s ≤ u)\n#align subset_inter_iff subset_inter_iff\n\n",
 "subset_inter":
 "theorem subset_inter {s₁ s₂ u : Finset α} : s₁ ⊆ s₂ → s₁ ⊆ u → s₁ ⊆ s₂ ∩ u := by\n  simp (config := { contextual := true }) only [subset_iff, mem_inter] <;> intros <;> constructor <;> trivial\n#align subset_inter subset_inter\n\n",
 "subset_insert_iff_of_not_mem":
 "theorem subset_insert_iff_of_not_mem (h : a ∉ s) : s ⊆ insert a t ↔ s ⊆ t := by\n  rw [subset_insert_iff, erase_eq_of_not_mem h]\n#align subset_insert_iff_of_not_mem subset_insert_iff_of_not_mem\n\n",
 "subset_insert_iff":
 "theorem subset_insert_iff {a : α} {s t : Finset α} : s ⊆ insert a t ↔ erase s a ⊆ t := by\n  simp only [subset_iff, or_iff_not_imp_left, mem_erase, mem_insert, and_imp] <;>\n    exact forall_congr' fun x => forall_swap\n#align subset_insert_iff subset_insert_iff\n\n",
 "subset_insert":
 "theorem subset_insert (a : α) (s : Finset α) : s ⊆ insert a s := fun b => mem_insert_of_mem\n#align subset_insert subset_insert\n\n",
 "subset_iff":
 "theorem subset_iff {s₁ s₂ : Finset α} : s₁ ⊆ s₂ ↔ ∀ ⦃x⦄, x ∈ s₁ → x ∈ s₂ :=\n  iff.rfl\n#align subset_iff subset_iff\n\n",
 "subset_erase":
 "theorem subset_erase {a : α} {s t : Finset α} : s ⊆ t.erase a ↔ s ⊆ t ∧ a ∉ s :=\n  ⟨fun h => ⟨h.trans (erase_subset _ _), fun ha => not_mem_erase _ _ (h ha)⟩, fun h b hb =>\n    mem_erase.2 ⟨ne_of_mem_of_not_mem hb h.2, h.1 hb⟩⟩\n#align subset_erase subset_erase\n\n",
 "subset_empty":
 "theorem subset_empty {s : Finset α} : s ⊆ ∅ ↔ s = ∅ :=\n  subset_zero.trans val_eq_zero\n#align subset_empty subset_empty\n\n",
 "subset_def":
 "theorem subset_def : s ⊆ t ↔ s.1 ⊆ t.1 :=\n  iff.rfl\n#align subset_def subset_def\n\n",
 "subset_cons":
 "theorem subset_cons (h : a ∉ s) : s ⊆ s.cons a h :=\n  subset_cons _ _\n#align subset_cons subset_cons\n\n",
 "subset_coe_filter_of_subset_forall":
 "theorem subset_coe_filter_of_subset_forall (s : Finset α) {t : set α} (h₁ : t ⊆ s) (h₂ : ∀ x ∈ t, p x) :\n    t ⊆ s.filter p := fun x hx => (s.coe_filter p).symm ▸ ⟨h₁ hx, h₂ x hx⟩\n#align subset_coe_filter_of_subset_forall subset_coe_filter_of_subset_forall\n\n",
 "subset_bUnion_of_mem":
 "theorem subset_bUnion_of_mem (u : α → Finset β) {x : α} (xs : x ∈ s) : u x ⊆ s.bUnion u :=\n  singleton_bunionᵢ.superset.trans <| bunionᵢ_subset_bunionᵢ_of_subset_left u <| singleton_subset_iff.2 xs\n#align subset_bUnion_of_mem subset_bUnion_of_mem\n\n",
 "ssubset_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem ssubset_singleton_iff {s : Finset α} {a : α} : «expr ⊂ » s {a} ↔ s = ∅ := by\n  rw [← coe_ssubset, coe_singleton, Set.ssubset_singleton_iff, coe_eq_empty]\n#align ssubset_singleton_iff ssubset_singleton_iff\n\n",
 "ssubset_of_subset_of_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n#print ssubset_of_subset_of_ssubset /-\ntheorem ssubset_of_subset_of_ssubset {s₁ s₂ s₃ : Finset α} (hs₁s₂ : s₁ ⊆ s₂) (hs₂s₃ : «expr ⊂ » s₂ s₃) :\n    «expr ⊂ » s₁ s₃ :=\n  Set.ssubset_of_subset_of_ssubset hs₁s₂ hs₂s₃\n#align ssubset_of_subset_of_ssubset ssubset_of_subset_of_ssubset\n-/\n\n",
 "ssubset_of_ssubset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n#print ssubset_of_ssubset_of_subset /-\ntheorem ssubset_of_ssubset_of_subset {s₁ s₂ s₃ : Finset α} (hs₁s₂ : «expr ⊂ » s₁ s₂) (hs₂s₃ : s₂ ⊆ s₃) :\n    «expr ⊂ » s₁ s₃ :=\n  Set.ssubset_of_ssubset_of_subset hs₁s₂ hs₂s₃\n#align ssubset_of_ssubset_of_subset ssubset_of_ssubset_of_subset\n-/\n\n",
 "ssubset_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem ssubset_insert (h : a ∉ s) : «expr ⊂ » s (insert a s) :=\n  ssubset_iff.mpr ⟨a, h, Subset.rfl⟩\n#align ssubset_insert ssubset_insert\n\n",
 "ssubset_iff_subset_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n#print ssubset_iff_subset_ne /-\ntheorem ssubset_iff_subset_ne {s t : Finset α} : «expr ⊂ » s t ↔ s ⊆ t ∧ s ≠ t :=\n  @lt_iff_le_and_ne _ _ s t\n#align ssubset_iff_subset_ne ssubset_iff_subset_ne\n-/\n\n",
 "ssubset_iff_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem ssubset_iff_of_subset {s₁ s₂ : Finset α} (h : s₁ ⊆ s₂) : «expr ⊂ » s₁ s₂ ↔ ∃ x ∈ s₂, x ∉ s₁ :=\n  Set.ssubset_iff_of_subset h\n#align ssubset_iff_of_subset ssubset_iff_of_subset\n\n",
 "ssubset_iff_exists_subset_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem ssubset_iff_exists_subset_erase {s t : Finset α} : «expr ⊂ » s t ↔ ∃ a ∈ t, s ⊆ t.erase a :=\n  by\n  refine' ⟨fun h => _, fun ⟨a, ha, h⟩ => ssubset_of_subset_of_ssubset h <| erase_ssubset ha⟩\n  obtain ⟨a, ht, hs⟩ := not_subset.1 h.2\n  exact ⟨a, ht, subset_erase.2 ⟨h.1, hs⟩⟩\n#align ssubset_iff_exists_subset_erase ssubset_iff_exists_subset_erase\n\n",
 "ssubset_iff_exists_cons_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem ssubset_iff_exists_cons_subset : «expr ⊂ » s t ↔ ∃ (a : _)(h : a ∉ s), s.cons a h ⊆ t :=\n  by\n  refine' ⟨fun h => _, fun ⟨a, ha, h⟩ => ssubset_of_ssubset_of_subset (ssubset_cons _) h⟩\n  obtain ⟨a, hs, ht⟩ := not_subset.1 h.2\n  exact ⟨a, ht, cons_subset.2 ⟨hs, h.subset⟩⟩\n#align ssubset_iff_exists_cons_subset ssubset_iff_exists_cons_subset\n\n",
 "ssubset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a «expr ∉ » s) -/\ntheorem ssubset_iff : «expr ⊂ » s t ↔ ∃ (a : _)(_ : a ∉ s), insert a s ⊆ t := by\n  exact_mod_cast @Set.ssubset_iff_insert α s t\n#align ssubset_iff ssubset_iff\n\n",
 "ssubset_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem ssubset_def : «expr ⊂ » s t ↔ s ⊆ t ∧ ¬t ⊆ s :=\n  iff.rfl\n#align ssubset_def ssubset_def\n\n",
 "ssubset_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem ssubset_cons (h : a ∉ s) : «expr ⊂ » s (s.cons a h) :=\n  ssubset_cons h\n#align ssubset_cons ssubset_cons\n\n",
 "sizeof_lt_sizeof_of_mem":
 "theorem sizeof_lt_sizeof_of_mem [SizeOf α] {x : α} {s : Finset α} (hx : x ∈ s) : SizeOf.sizeOf x < SizeOf.sizeOf s :=\n  by\n  cases s\n  dsimp [SizeOf.sizeOf, SizeOf.sizeOf, finset.sizeof]\n  apply lt_add_left\n  exact Multiset.sizeOf_lt_sizeOf_of_mem hx\n#align sizeof_lt_sizeof_of_mem sizeof_lt_sizeof_of_mem\n\n",
 "singleton_val":
 "@[simp]\ntheorem singleton_val (a : α) : ({a} : Finset α).1 = {a} :=\n  rfl\n#align singleton_val singleton_val\n\n",
 "singleton_subset_singleton":
 "theorem singleton_subset_singleton : ({a} : Finset α) ⊆ {b} ↔ a = b := by simp\n#align singleton_subset_singleton singleton_subset_singleton\n\n",
 "singleton_subset_set_iff":
 "theorem singleton_subset_set_iff {s : set α} {a : α} : ↑({a} : Finset α) ⊆ s ↔ a ∈ s := by\n  rw [coe_singleton, Set.singleton_subset_iff]\n#align singleton_subset_set_iff singleton_subset_set_iff\n\n",
 "singleton_subset_iff":
 "@[simp]\ntheorem singleton_subset_iff {s : Finset α} {a : α} : {a} ⊆ s ↔ a ∈ s :=\n  singleton_subset_set_iff\n#align singleton_subset_iff singleton_subset_iff\n\n",
 "singleton_nonempty":
 "@[simp]\ntheorem singleton_nonempty (a : α) : ({a} : Finset α).nonempty :=\n  ⟨a, mem_singleton_self a⟩\n#align singleton_nonempty singleton_nonempty\n\n",
 "singleton_ne_empty":
 "@[simp]\ntheorem singleton_ne_empty (a : α) : ({a} : Finset α) ≠ ∅ :=\n  (singleton_nonempty a).ne_empty\n#align singleton_ne_empty singleton_ne_empty\n\n",
 "singleton_inter_of_not_mem":
 "@[simp]\ntheorem singleton_inter_of_not_mem {a : α} {s : Finset α} (H : a ∉ s) : {a} ∩ s = ∅ :=\n  eq_empty_of_forall_not_mem <| by simp only [mem_inter, mem_singleton] <;> rintro x ⟨rfl, h⟩ <;> exact H h\n#align singleton_inter_of_not_mem singleton_inter_of_not_mem\n\n",
 "singleton_inter_of_mem":
 "@[simp]\ntheorem singleton_inter_of_mem {a : α} {s : Finset α} (H : a ∈ s) : {a} ∩ s = {a} :=\n  show insert a ∅ ∩ s = insert a ∅ by rw [insert_inter_of_mem H, empty_inter]\n#align singleton_inter_of_mem singleton_inter_of_mem\n\n",
 "singleton_injective":
 "theorem singleton_injective : injective (singleton : α → Finset α) := fun a b h =>\n  mem_singleton.1 (h ▸ mem_singleton_self _)\n#align singleton_injective singleton_injective\n\n",
 "singleton_inj":
 "@[simp]\ntheorem singleton_inj : ({a} : Finset α) = {b} ↔ a = b :=\n  singleton_injective.eq_iff\n#align singleton_inj singleton_inj\n\n",
 "singleton_iff_unique_mem":
 "theorem singleton_iff_unique_mem (s : Finset α) : (∃ a, s = {a}) ↔ ∃! a, a ∈ s := by\n  simp only [eq_singleton_iff_unique_mem, exists_unique]\n#align singleton_iff_unique_mem singleton_iff_unique_mem\n\n",
 "singleton_disj_union":
 "theorem singleton_disj_union (a : α) (t : Finset α) (h : Disjoint {a} t) :\n    disjUnion {a} t h = cons a t (disjoint_singleton_left.mp h) :=\n  eq_of_veq <| Multiset.singleton_add _ _\n#align singleton_disj_union singleton_disj_union\n\n",
 "singleton_disj_Union":
 "@[simp]\ntheorem singleton_disj_Union (a : α) {h} : Finset.disjUnion {a} t h = t a :=\n  eq_of_veq <| Multiset.singleton_bind _ _\n#align singleton_disj_Union singleton_disj_Union\n\n",
 "singleton_bUnion":
 "@[simp]\ntheorem singleton_bUnion {a : α} : Finset.bunionᵢ {a} t = t a := by\n  classical rw [← insert_emptyc_eq, bUnion_insert, bUnion_empty, union_empty]\n#align singleton_bUnion singleton_bUnion\n\n",
 "set_of_mem":
 "@[simp]\ntheorem set_of_mem {α} {s : Finset α} : { a | a ∈ s } = s :=\n  rfl\n#align set_of_mem set_of_mem\n\n",
 "sep_def":
 "@[simp]\ntheorem sep_def {α : Type _} (s : Finset α) (p : α → Prop) : { x ∈ s | p x } = s.filter p :=\n  rfl\n#align sep_def sep_def\n\n",
 "self_mem_range_succ":
 "@[simp]\ntheorem self_mem_range_succ (n : ℕ) : n ∈ range (n + 1) :=\n  Multiset.self_mem_range_succ n\n#align self_mem_range_succ self_mem_range_succ\n\n",
 "sdiff_val":
 "@[simp]\ntheorem sdiff_val (s₁ s₂ : Finset α) : (s₁ \\ s₂).val = s₁.val - s₂.val :=\n  rfl\n#align sdiff_val sdiff_val\n\n",
 "sdiff_union_self_eq_union":
 "@[simp]\ntheorem sdiff_union_self_eq_union : s \\ t ∪ t = s ∪ t :=\n  sup_sdiff_self_left _ _\n#align sdiff_union_self_eq_union sdiff_union_self_eq_union\n\n",
 "sdiff_union_of_subset":
 "theorem sdiff_union_of_subset {s₁ s₂ : Finset α} (h : s₁ ⊆ s₂) : s₂ \\ s₁ ∪ s₁ = s₂ :=\n  (union_comm _ _).trans (union_sdiff_of_subset h)\n#align sdiff_union_of_subset sdiff_union_of_subset\n\n",
 "sdiff_union_inter":
 "theorem sdiff_union_inter (s t : Finset α) : s \\ t ∪ s ∩ t = s :=\n  sup_sdiff_inf _ _\n#align sdiff_union_inter sdiff_union_inter\n\n",
 "sdiff_union_distrib":
 "theorem sdiff_union_distrib (s t₁ t₂ : Finset α) : s \\ (t₁ ∪ t₂) = s \\ t₁ ∩ (s \\ t₂) :=\n  sdiff_sup\n#align sdiff_union_distrib sdiff_union_distrib\n\n",
 "sdiff_subset_sdiff":
 "@[mono]\ntheorem sdiff_subset_sdiff (hst : s ⊆ t) (hvu : v ⊆ u) : s \\ u ⊆ t \\ v :=\n  sdiff_le_sdiff ‹s ≤ t› ‹v ≤ u›\n#align sdiff_subset_sdiff sdiff_subset_sdiff\n\n",
 "sdiff_subset":
 "@[simp]\ntheorem sdiff_subset (s t : Finset α) : s \\ t ⊆ s :=\n  show s \\ t ≤ s from sdiff_le\n#align sdiff_subset sdiff_subset\n\n",
 "sdiff_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem sdiff_ssubset (h : t ⊆ s) (ht : t.nonempty) : «expr ⊂ » (s \\ t) s :=\n  sdiff_lt ‹t ≤ s› ht.ne_empty\n#align sdiff_ssubset sdiff_ssubset\n\n",
 "sdiff_singleton_not_mem_eq_self":
 "@[simp]\ntheorem sdiff_singleton_not_mem_eq_self (s : Finset α) {a : α} (ha : a ∉ s) : s \\ {a} = s := by\n  simp only [sdiff_singleton_eq_erase, ha, erase_eq_of_not_mem, not_false_iff]\n#align sdiff_singleton_not_mem_eq_self sdiff_singleton_not_mem_eq_self\n\n",
 "sdiff_singleton_eq_erase":
 "theorem sdiff_singleton_eq_erase (a : α) (s : Finset α) : s \\ singleton a = erase s a :=\n  by\n  ext\n  rw [mem_erase, mem_sdiff, mem_singleton]\n  tauto\n#align sdiff_singleton_eq_erase sdiff_singleton_eq_erase\n\n",
 "sdiff_self":
 "#print sdiff_self /-\n@[simp]\ntheorem sdiff_self (s₁ : Finset α) : s₁ \\ s₁ = ∅ :=\n  sdiff_self\n#align sdiff_self sdiff_self\n-/\n\n",
 "sdiff_sdiff_self_left":
 "theorem sdiff_sdiff_self_left (s t : Finset α) : s \\ (s \\ t) = s ∩ t :=\n  sdiff_sdiff_right_self\n#align sdiff_sdiff_self_left sdiff_sdiff_self_left\n\n",
 "sdiff_sdiff_left'":
 "#print sdiff_sdiff_left' /-\ntheorem sdiff_sdiff_left' (s t u : Finset α) : (s \\ t) \\ u = s \\ t ∩ (s \\ u) :=\n  sdiff_sdiff_left'\n#align sdiff_sdiff_left' sdiff_sdiff_left'\n-/\n\n",
 "sdiff_sdiff_eq_self":
 "#print sdiff_sdiff_eq_self /-\ntheorem sdiff_sdiff_eq_self (h : t ⊆ s) : s \\ (s \\ t) = t :=\n  sdiff_sdiff_eq_self h\n#align sdiff_sdiff_eq_self sdiff_sdiff_eq_self\n-/\n\n",
 "sdiff_nonempty":
 "theorem sdiff_nonempty : (s \\ t).nonempty ↔ ¬s ⊆ t :=\n  nonempty_iff_ne_empty.trans sdiff_eq_empty_iff_subset.not\n#align sdiff_nonempty sdiff_nonempty\n\n",
 "sdiff_inter_self_right":
 "@[simp]\ntheorem sdiff_inter_self_right (s t : Finset α) : s \\ (t ∩ s) = s \\ t :=\n  sdiff_inf_self_right _ _\n#align sdiff_inter_self_right sdiff_inter_self_right\n\n",
 "sdiff_inter_self_left":
 "@[simp]\ntheorem sdiff_inter_self_left (s t : Finset α) : s \\ (s ∩ t) = s \\ t :=\n  sdiff_inf_self_left _ _\n#align sdiff_inter_self_left sdiff_inter_self_left\n\n",
 "sdiff_inter_self":
 "@[simp]\ntheorem sdiff_inter_self (s₁ s₂ : Finset α) : s₂ \\ s₁ ∩ s₁ = ∅ :=\n  inf_sdiff_self_left\n#align sdiff_inter_self sdiff_inter_self\n\n",
 "sdiff_inter_distrib_right":
 "theorem sdiff_inter_distrib_right (s t u : Finset α) : s \\ (t ∩ u) = s \\ t ∪ s \\ u :=\n  sdiff_inf\n#align sdiff_inter_distrib_right sdiff_inter_distrib_right\n\n",
 "sdiff_insert_of_not_mem":
 "theorem sdiff_insert_of_not_mem {x : α} (h : x ∉ s) (t : Finset α) : s \\ insert x t = s \\ t :=\n  by\n  refine' subset.antisymm (sdiff_subset_sdiff (subset.refl _) (subset_insert _ _)) fun y hy => _\n  simp only [mem_sdiff, mem_insert, not_or] at hy⊢\n  exact ⟨hy.1, fun hxy => h <| hxy ▸ hy.1, hy.2⟩\n#align sdiff_insert_of_not_mem sdiff_insert_of_not_mem\n\n",
 "sdiff_insert_insert_of_mem_of_not_mem":
 "theorem sdiff_insert_insert_of_mem_of_not_mem {s t : Finset α} {x : α} (hxs : x ∈ s) (hxt : x ∉ t) :\n    insert x (s \\ insert x t) = s \\ t := by rw [sdiff_insert, insert_erase (mem_sdiff.mpr ⟨hxs, hxt⟩)]\n#align sdiff_insert_insert_of_mem_of_not_mem sdiff_insert_insert_of_mem_of_not_mem\n\n",
 "sdiff_insert":
 "theorem sdiff_insert (s t : Finset α) (x : α) : s \\ insert x t = (s \\ t).erase x := by\n  simp_rw [← sdiff_singleton_eq_erase, insert_eq, sdiff_sdiff_left', sdiff_union_distrib, inter_comm]\n#align sdiff_insert sdiff_insert\n\n",
 "sdiff_idem":
 "#print sdiff_idem /-\n@[simp]\ntheorem sdiff_idem (s t : Finset α) : (s \\ t) \\ t = s \\ t :=\n  sdiff_idem\n#align sdiff_idem sdiff_idem\n-/\n\n",
 "sdiff_erase":
 "theorem sdiff_erase {x : α} (hx : x ∈ s) : s \\ s.erase x = {x} :=\n  by\n  rw [← sdiff_singleton_eq_erase, sdiff_sdiff_right_self]\n  exact inf_eq_right.2 (singleton_subset_iff.2 hx)\n#align sdiff_erase sdiff_erase\n\n",
 "sdiff_eq_self_of_disjoint":
 "theorem sdiff_eq_self_of_disjoint (h : Disjoint s t) : s \\ t = s :=\n  sdiff_eq_self_iff_disjoint.2 h\n#align sdiff_eq_self_of_disjoint sdiff_eq_self_of_disjoint\n\n",
 "sdiff_eq_self_iff_disjoint":
 "#print sdiff_eq_self_iff_disjoint /-\ntheorem sdiff_eq_self_iff_disjoint : s \\ t = s ↔ Disjoint s t :=\n  sdiff_eq_self_iff_disjoint'\n#align sdiff_eq_self_iff_disjoint sdiff_eq_self_iff_disjoint\n-/\n\n",
 "sdiff_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊇ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊇ » -/\ntheorem sdiff_eq_self (s₁ s₂ : Finset α) : s₁ \\ s₂ = s₁ ↔ s₁ ∩ s₂ ⊆ ∅ :=\n  by\n  simp [subset.antisymm_iff]\n  constructor <;> intro h\n  · trans s₁ \\ s₂ ∩ s₂\n    mono\n    simp\n  ·\n    calc\n      «expr ⊇ » (s₁ \\ s₂) (s₁ \\ (s₁ ∩ s₂)) := by simp [(«expr ⊇ » · ·)]\n      «expr ⊇ » _ (s₁ \\ ∅) := by mono using («expr ⊇ » · ·)\n      «expr ⊇ » _ s₁ := by simp [(«expr ⊇ » · ·)]\n      \n#align sdiff_eq_self sdiff_eq_self\n\n",
 "sdiff_eq_sdiff_iff_inter_eq_inter":
 "theorem sdiff_eq_sdiff_iff_inter_eq_inter {s t₁ t₂ : Finset α} : s \\ t₁ = s \\ t₂ ↔ s ∩ t₁ = s ∩ t₂ :=\n  sdiff_eq_sdiff_iff_inf_eq_inf\n#align sdiff_eq_sdiff_iff_inter_eq_inter sdiff_eq_sdiff_iff_inter_eq_inter\n\n",
 "sdiff_eq_filter":
 "theorem sdiff_eq_filter (s₁ s₂ : Finset α) : s₁ \\ s₂ = filter (· ∉ s₂) s₁ :=\n  ext fun _ => by simp only [mem_sdiff, mem_filter]\n#align sdiff_eq_filter sdiff_eq_filter\n\n",
 "sdiff_eq_empty_iff_subset":
 "@[simp]\ntheorem sdiff_eq_empty_iff_subset : s \\ t = ∅ ↔ s ⊆ t :=\n  sdiff_eq_bot_iff\n#align sdiff_eq_empty_iff_subset sdiff_eq_empty_iff_subset\n\n",
 "sdiff_empty":
 "@[simp]\ntheorem sdiff_empty : s \\ ∅ = s :=\n  sdiff_bot\n#align sdiff_empty sdiff_empty\n\n",
 "sdiff_disjoint":
 "--TODO@Yaël: Kill lemmas duplicate with `boolean_algebra`\ntheorem sdiff_disjoint : Disjoint (t \\ s) s :=\n  disjoint_left.2 fun a ha => (mem_sdiff.1 ha).2\n#align sdiff_disjoint sdiff_disjoint\n\n",
 "right_eq_union_iff_subset":
 "@[simp]\ntheorem right_eq_union_iff_subset {s t : Finset α} : s = t ∪ s ↔ t ⊆ s := by rw [← union_eq_right_iff_subset, eq_comm]\n#align right_eq_union_iff_subset right_eq_union_iff_subset\n\n",
 "rfl":
 "protected theorem subset.rfl {s : Finset α} : s ⊆ s :=\n  Subset.refl _\n#align subset.rfl subset.rfl\n\n",
 "refl":
 "@[simp]\ntheorem subset.refl (s : Finset α) : s ⊆ s :=\n  Subset.refl _\n#align subset.refl subset.refl\n\n",
 "range_zero":
 "@[simp]\ntheorem range_zero : range 0 = ∅ :=\n  rfl\n#align range_zero range_zero\n\n",
 "range_val":
 "@[simp]\ntheorem range_val (n : ℕ) : (range n).1 = Multiset.range n :=\n  rfl\n#align range_val range_val\n\n",
 "range_succ":
 "theorem range_succ : range (succ n) = insert n (range n) :=\n  eq_of_veq <| (range_succ n).trans <| (ndinsert_of_not_mem not_mem_range_self).symm\n#align range_succ range_succ\n\n",
 "range_subset":
 "@[simp]\ntheorem range_subset {n m} : range n ⊆ range m ↔ n ≤ m :=\n  range_subset\n#align range_subset range_subset\n\n",
 "range_one":
 "@[simp]\ntheorem range_one : range 1 = {0} :=\n  rfl\n#align range_one range_one\n\n",
 "range_mono":
 "theorem range_mono : monotone range := fun _ _ => range_subset.2\n#align range_mono range_mono\n\n",
 "range_filter_eq":
 "@[simp]\ntheorem range_filter_eq {n m : ℕ} : (range n).filter (· = m) = if m < n then {m} else ∅ :=\n  by\n  convert filter_eq (range n) m\n  · ext\n    exact comm\n  · simp\n#align range_filter_eq range_filter_eq\n\n",
 "range_eq_empty_iff":
 "@[simp]\ntheorem range_eq_empty_iff : range n = ∅ ↔ n = 0 := by rw [← not_nonempty_iff_eq_empty, nonempty_range_iff, not_not]\n#align range_eq_empty_iff range_eq_empty_iff\n\n",
 "range_add_one":
 "theorem range_add_one : range (n + 1) = insert n (range n) :=\n  range_succ\n#align range_add_one range_add_one\n\n",
 "piecewise_singleton":
 "theorem piecewise_singleton [decidable_eq α] (i : α) : piecewise {i} f g = update g i (f i) := by\n  rw [← insert_emptyc_eq, piecewise_insert, piecewise_empty]\n#align piecewise_singleton piecewise_singleton\n\n",
 "piecewise_piecewise_of_subset_right":
 "theorem piecewise_piecewise_of_subset_right {s t : Finset α} [∀ i, decidable (i ∈ s)] [∀ i, decidable (i ∈ t)]\n    (h : t ⊆ s) (f g₁ g₂ : ∀ a, δ a) : s.piecewise f (t.piecewise g₁ g₂) = s.piecewise f g₂ :=\n  s.piecewise_congr (fun _ _ => rfl) fun i hi => t.piecewise_eq_of_not_mem _ _ (mt (@h _) hi)\n#align piecewise_piecewise_of_subset_right piecewise_piecewise_of_subset_right\n\n",
 "piecewise_piecewise_of_subset_left":
 "theorem piecewise_piecewise_of_subset_left {s t : Finset α} [∀ i, decidable (i ∈ s)] [∀ i, decidable (i ∈ t)]\n    (h : s ⊆ t) (f₁ f₂ g : ∀ a, δ a) : s.piecewise (t.piecewise f₁ f₂) g = s.piecewise f₁ g :=\n  s.piecewise_congr (fun i hi => piecewise_eq_of_mem _ _ _ (h hi)) fun _ _ => rfl\n#align piecewise_piecewise_of_subset_left piecewise_piecewise_of_subset_left\n\n",
 "piecewise_mem_set_pi":
 "theorem piecewise_mem_set_pi {δ : α → Type _} {t : set α} {t' : ∀ i, set (δ i)} {f g} (hf : f ∈ Set.pi t t')\n    (hg : g ∈ Set.pi t t') : s.piecewise f g ∈ Set.pi t t' := by\n  classical\n    rw [← piecewise_coe]\n    exact Set.piecewise_mem_pi (↑s) hf hg\n#align piecewise_mem_set_pi piecewise_mem_set_pi\n\n",
 "piecewise_mem_Icc_of_mem_of_mem":
 "theorem piecewise_mem_Icc_of_mem_of_mem {δ : α → Type _} [∀ i, preorder (δ i)] {f f₁ g g₁ : ∀ i, δ i}\n    (hf : f ∈ Set.Icc f₁ g₁) (hg : g ∈ Set.Icc f₁ g₁) : s.piecewise f g ∈ Set.Icc f₁ g₁ :=\n  ⟨le_piecewise_of_le_of_le _ hf.1 hg.1, piecewise_le_of_le_of_le _ hf.2 hg.2⟩\n#align piecewise_mem_Icc_of_mem_of_mem piecewise_mem_Icc_of_mem_of_mem\n\n",
 "piecewise_mem_Icc'":
 "theorem piecewise_mem_Icc' {δ : α → Type _} [∀ i, preorder (δ i)] {f g : ∀ i, δ i} (h : g ≤ f) :\n    s.piecewise f g ∈ Set.Icc g f :=\n  piecewise_mem_Icc_of_mem_of_mem _ (Set.right_mem_Icc.2 h) (Set.left_mem_Icc.2 h)\n#align piecewise_mem_Icc' piecewise_mem_Icc'\n\n",
 "piecewise_mem_Icc":
 "theorem piecewise_mem_Icc {δ : α → Type _} [∀ i, preorder (δ i)] {f g : ∀ i, δ i} (h : f ≤ g) :\n    s.piecewise f g ∈ Set.Icc f g :=\n  piecewise_mem_Icc_of_mem_of_mem _ (Set.left_mem_Icc.2 h) (Set.right_mem_Icc.2 h)\n#align piecewise_mem_Icc piecewise_mem_Icc\n\n",
 "piecewise_le_piecewise'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∉ » s) -/\ntheorem piecewise_le_piecewise' {δ : α → Type _} [∀ i, preorder (δ i)] {f g f' g' : ∀ i, δ i} (Hf : ∀ x ∈ s, f x ≤ f' x)\n    (Hg : ∀ (x) (_ : x ∉ s), g x ≤ g' x) : s.piecewise f g ≤ s.piecewise f' g' := fun x => by\n  by_cases hx : x ∈ s <;> simp [hx, *]\n#align piecewise_le_piecewise' piecewise_le_piecewise'\n\n",
 "piecewise_le_piecewise":
 "theorem piecewise_le_piecewise {δ : α → Type _} [∀ i, preorder (δ i)] {f g f' g' : ∀ i, δ i} (Hf : f ≤ f')\n    (Hg : g ≤ g') : s.piecewise f g ≤ s.piecewise f' g' :=\n  s.piecewise_le_piecewise' (fun x _ => Hf x) fun x _ => Hg x\n#align piecewise_le_piecewise piecewise_le_piecewise\n\n",
 "piecewise_le_of_le_of_le":
 "theorem piecewise_le_of_le_of_le {δ : α → Type _} [∀ i, preorder (δ i)] {f g h : ∀ i, δ i} (Hf : f ≤ h) (Hg : g ≤ h) :\n    s.piecewise f g ≤ h := fun x => piecewise_cases s f g (· ≤ h x) (Hf x) (Hg x)\n#align piecewise_le_of_le_of_le piecewise_le_of_le_of_le\n\n",
 "piecewise_insert_self":
 "@[simp]\ntheorem piecewise_insert_self [decidable_eq α] {j : α} [∀ i, decidable (i ∈ insert j s)] :\n    (insert j s).piecewise f g j = f j := by simp [piecewise]\n#align piecewise_insert_self piecewise_insert_self\n\n",
 "piecewise_insert_of_ne":
 "@[simp]\ntheorem piecewise_insert_of_ne [decidable_eq α] {i j : α} [∀ i, decidable (i ∈ insert j s)] (h : i ≠ j) :\n    (insert j s).piecewise f g i = s.piecewise f g i := by simp [piecewise, h]\n#align piecewise_insert_of_ne piecewise_insert_of_ne\n\n",
 "piecewise_insert":
 "theorem piecewise_insert [decidable_eq α] (j : α) [∀ i, decidable (i ∈ insert j s)] :\n    (insert j s).piecewise f g = update (s.piecewise f g) j (f j) := by\n  classical simp only [← piecewise_coe, coe_insert, ← Set.piecewise_insert]\n#align piecewise_insert piecewise_insert\n\n",
 "piecewise_idem_right":
 "@[simp]\ntheorem piecewise_idem_right (f g₁ g₂ : ∀ a, δ a) : s.piecewise f (s.piecewise g₁ g₂) = s.piecewise f g₂ :=\n  piecewise_piecewise_of_subset_right (Subset.refl _) f g₁ g₂\n#align piecewise_idem_right piecewise_idem_right\n\n",
 "piecewise_idem_left":
 "@[simp]\ntheorem piecewise_idem_left (f₁ f₂ g : ∀ a, δ a) : s.piecewise (s.piecewise f₁ f₂) g = s.piecewise f₁ g :=\n  piecewise_piecewise_of_subset_left (Subset.refl _) _ _ _\n#align piecewise_idem_left piecewise_idem_left\n\n",
 "piecewise_eq_of_not_mem":
 "@[simp]\ntheorem piecewise_eq_of_not_mem {i : α} (hi : i ∉ s) : s.piecewise f g i = g i := by simp [piecewise, hi]\n#align piecewise_eq_of_not_mem piecewise_eq_of_not_mem\n\n",
 "piecewise_eq_of_mem":
 "@[simp]\ntheorem piecewise_eq_of_mem {i : α} (hi : i ∈ s) : s.piecewise f g i = f i := by simp [piecewise, hi]\n#align piecewise_eq_of_mem piecewise_eq_of_mem\n\n",
 "piecewise_empty":
 "@[simp]\ntheorem piecewise_empty [∀ i : α, decidable (i ∈ (∅ : Finset α))] : piecewise ∅ f g = g :=\n  by\n  ext i\n  simp [piecewise]\n#align piecewise_empty piecewise_empty\n\n",
 "piecewise_congr":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i «expr ∉ » s) -/\ntheorem piecewise_congr {f f' g g' : ∀ i, δ i} (hf : ∀ i ∈ s, f i = f' i) (hg : ∀ (i) (_ : i ∉ s), g i = g' i) :\n    s.piecewise f g = s.piecewise f' g' :=\n  funext fun i => if_ctx_congr iff.rfl (hf i) (hg i)\n#align piecewise_congr piecewise_congr\n\n",
 "piecewise_coe":
 "-- TODO: fix this in norm_cast\n@[norm_cast move]\ntheorem piecewise_coe [∀ j, decidable (j ∈ (s : set α))] : (s : set α).piecewise f g = s.piecewise f g :=\n  by\n  ext\n  congr\n#align piecewise_coe piecewise_coe\n\n",
 "piecewise_cases":
 "theorem piecewise_cases {i} (p : δ i → Prop) (hf : p (f i)) (hg : p (g i)) : p (s.piecewise f g i) := by\n  by_cases hi : i ∈ s <;> simpa [hi]\n#align piecewise_cases piecewise_cases\n\n",
 "perm_of_nodup_nodup_to_finset_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem perm_of_nodup_nodup_to_finset_eq (hl : Nodup l) (hl' : Nodup l') (h : l.to_finset = l'.to_finset) :\n    list.perm l l' := by\n  rw [← Multiset.coe_eq_coe]\n  exact Multiset.Nodup.toFinset_inj hl hl' h\n#align perm_of_nodup_nodup_to_finset_eq perm_of_nodup_nodup_to_finset_eq\n\n",
 "pairwise_subtype_iff_pairwise_finset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem pairwise_subtype_iff_pairwise_finset' (r : β → β → Prop) (f : α → β) :\n    Pairwise («expr on » r fun x : s => f x) ↔ (s : set α).pairwise («expr on » r f) :=\n  pairwise_subtype_iff_pairwise_set (s : set α) («expr on » r f)\n#align pairwise_subtype_iff_pairwise_finset' pairwise_subtype_iff_pairwise_finset'\n\n",
 "pairwise_subtype_iff_pairwise_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem pairwise_subtype_iff_pairwise_finset (r : α → α → Prop) :\n    Pairwise («expr on » r fun x : s => x) ↔ (s : set α).pairwise r :=\n  pairwise_subtype_iff_pairwise_finset' r id\n#align pairwise_subtype_iff_pairwise_finset pairwise_subtype_iff_pairwise_finset\n\n",
 "pairwise_disjoint_coe":
 "@[simp, norm_cast]\ntheorem pairwise_disjoint_coe {ι : Type _} {s : set ι} {f : ι → Finset α} :\n    s.pairwise_disjoint (fun i => f i : ι → set α) ↔ s.pairwise_disjoint f :=\n  forall₅_congr fun _ _ _ _ _ => disjoint_coe\n#align pairwise_disjoint_coe pairwise_disjoint_coe\n\n",
 "pairwise_cons'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem pairwise_cons' {a : α} (ha : a ∉ s) (r : β → β → Prop) (f : α → β) :\n    Pairwise («expr on » r fun a : s.cons a ha => f a) ↔\n      Pairwise («expr on » r fun a : s => f a) ∧ ∀ b ∈ s, r (f a) (f b) ∧ r (f b) (f a) :=\n  by\n  simp only [pairwise_subtype_iff_pairwise_finset', Finset.coe_cons, Set.pairwise_insert, Finset.mem_coe,\n    and_congr_right_iff]\n  exact fun hsr =>\n    ⟨fun h b hb =>\n      h b hb <| by\n        rintro rfl\n        contradiction,\n      fun h b hb _ => h b hb⟩\n#align pairwise_cons' pairwise_cons'\n\n",
 "pairwise_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\ntheorem pairwise_cons {a : α} (ha : a ∉ s) (r : α → α → Prop) :\n    Pairwise («expr on » r fun a : s.cons a ha => a) ↔\n      Pairwise («expr on » r fun a : s => a) ∧ ∀ b ∈ s, r a b ∧ r b a :=\n  pairwise_cons' ha r id\n#align pairwise_cons pairwise_cons\n\n",
 "pair_eq_singleton":
 "@[simp]\ntheorem pair_eq_singleton (a : α) : ({a, a} : Finset α) = {a} :=\n  insert_eq_of_mem <| mem_singleton_self _\n#align pair_eq_singleton pair_eq_singleton\n\n",
 "pair_comm":
 "theorem pair_comm (a b : α) : ({a, b} : Finset α) = {b, a} :=\n  Insert.comm a b ∅\n#align pair_comm pair_comm\n\n",
 "not_subset":
 "theorem not_subset : ¬s ⊆ t ↔ ∃ x ∈ s, x ∉ t := by simp only [← coe_subset, Set.not_subset, mem_coe]\n#align not_subset not_subset\n\n",
 "not_ssubset_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem not_ssubset_empty (s : Finset α) : ¬«expr ⊂ » s ∅ := fun h =>\n  let ⟨x, he, hs⟩ := exists_of_ssubset h\n  he\n#align not_ssubset_empty not_ssubset_empty\n\n",
 "not_nonempty_iff_eq_empty":
 "@[simp]\ntheorem not_nonempty_iff_eq_empty {s : Finset α} : ¬s.nonempty ↔ s = ∅ :=\n  nonempty_iff_ne_empty.not.trans not_not\n#align not_nonempty_iff_eq_empty not_nonempty_iff_eq_empty\n\n",
 "not_nonempty_empty":
 "#print not_nonempty_empty /-\n@[simp]\ntheorem not_nonempty_empty : ¬(∅ : Finset α).nonempty := fun ⟨x, hx⟩ => not_mem_empty x hx\n#align not_nonempty_empty not_nonempty_empty\n-/\n\n",
 "not_mem_union":
 "theorem not_mem_union : a ∉ s ∪ t ↔ a ∉ s ∧ a ∉ t := by rw [mem_union, not_or]\n#align not_mem_union not_mem_union\n\n",
 "not_mem_singleton":
 "theorem not_mem_singleton {a b : α} : a ∉ ({b} : Finset α) ↔ a ≠ b :=\n  not_congr mem_singleton\n#align not_mem_singleton not_mem_singleton\n\n",
 "not_mem_sdiff_of_not_mem_left":
 "theorem not_mem_sdiff_of_not_mem_left (h : a ∉ s) : a ∉ s \\ t := by simpa\n#align not_mem_sdiff_of_not_mem_left not_mem_sdiff_of_not_mem_left\n\n",
 "not_mem_sdiff_of_mem_right":
 "theorem not_mem_sdiff_of_mem_right (h : a ∈ t) : a ∉ s \\ t := by\n  simp only [mem_sdiff, h, not_true, not_false_iff, and_false_iff]\n#align not_mem_sdiff_of_mem_right not_mem_sdiff_of_mem_right\n\n",
 "not_mem_range_self":
 "@[simp]\ntheorem not_mem_range_self : n ∉ range n :=\n  not_mem_range_self\n#align not_mem_range_self not_mem_range_self\n\n",
 "not_mem_mono":
 "theorem not_mem_mono {s t : Finset α} (h : s ⊆ t) {a : α} : a ∉ t → a ∉ s :=\n  mt <| @h _\n#align not_mem_mono not_mem_mono\n\n",
 "not_mem_erase":
 "theorem not_mem_erase (a : α) (s : Finset α) : a ∉ erase s a :=\n  s.2.not_mem_erase\n#align not_mem_erase not_mem_erase\n\n",
 "not_mem_empty":
 "@[simp]\ntheorem not_mem_empty (a : α) : a ∉ (∅ : Finset α) :=\n  id\n#align not_mem_empty not_mem_empty\n\n",
 "not_empty_to_list":
 "theorem nonempty.not_empty_to_list {s : Finset α} (hs : s.nonempty) : ¬s.to_list.empty :=\n  mt empty_toList.mp hs.ne_empty\n#align nonempty.not_empty_to_list nonempty.not_empty_to_list\n\n",
 "not_disjoint_iff_nonempty_inter":
 "theorem not_disjoint_iff_nonempty_inter : ¬Disjoint s t ↔ (s ∩ t).nonempty :=\n  not_disjoint_iff.trans <| by simp [Finset.Nonempty]\n#align not_disjoint_iff_nonempty_inter not_disjoint_iff_nonempty_inter\n\n",
 "not_disjoint_iff":
 "theorem not_disjoint_iff : ¬Disjoint s t ↔ ∃ a, a ∈ s ∧ a ∈ t :=\n  disjoint_left.not.trans <| not_forall.trans <| exists_congr fun _ => by rw [not_imp, not_not]\n#align not_disjoint_iff not_disjoint_iff\n\n",
 "nonempty_range_succ":
 "theorem nonempty_range_succ : (range <| n + 1).nonempty :=\n  nonempty_range_iff.2 n.succ_ne_zero\n#align nonempty_range_succ nonempty_range_succ\n\n",
 "nonempty_range_iff":
 "@[simp]\ntheorem nonempty_range_iff : (range n).nonempty ↔ n ≠ 0 :=\n  ⟨fun ⟨k, hk⟩ => ((zero_le k).trans_lt <| mem_range.1 hk).ne', fun h => ⟨0, mem_range.2 <| pos_iff_ne_zero.2 h⟩⟩\n#align nonempty_range_iff nonempty_range_iff\n\n",
 "nonempty_of_ne_empty":
 "theorem nonempty_of_ne_empty {s : Finset α} (h : s ≠ ∅) : s.nonempty :=\n  exists_mem_of_ne_zero (mt val_eq_zero.1 h)\n#align nonempty_of_ne_empty nonempty_of_ne_empty\n\n",
 "nonempty_mk":
 "@[simp]\ntheorem nonempty_mk {m : Multiset α} {hm} : (⟨m, hm⟩ : Finset α).nonempty ↔ m ≠ 0 := by\n  induction m using Multiset.induction_on <;> simp\n#align nonempty_mk nonempty_mk\n\n",
 "nonempty_iff_ne_empty":
 "theorem nonempty_iff_ne_empty {s : Finset α} : s.nonempty ↔ s ≠ ∅ :=\n  ⟨Nonempty.ne_empty, nonempty_of_ne_empty⟩\n#align nonempty_iff_ne_empty nonempty_iff_ne_empty\n\n",
 "nonempty_iff_eq_singleton_default":
 "theorem nonempty_iff_eq_singleton_default [unique α] {s : Finset α} : s.nonempty ↔ s = {default} := by\n  simp [eq_singleton_iff_nonempty_unique_mem]\n#align nonempty_iff_eq_singleton_default nonempty_iff_eq_singleton_default\n\n",
 "nonempty_cons":
 "@[simp]\ntheorem nonempty_cons (h : a ∉ s) : (cons a s h).nonempty :=\n  ⟨a, mem_cons.2 <| or.inl rfl⟩\n#align nonempty_cons nonempty_cons\n\n",
 "nonempty_coe_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[simp]\ntheorem nonempty_coe_sort {s : Finset α} : nonempty («expr↥ » s) ↔ s.nonempty :=\n  nonempty_subtype\n#align nonempty_coe_sort nonempty_coe_sort\n\n",
 "nodup_to_list":
 "theorem nodup_to_list (s : Finset α) : s.to_list.nodup :=\n  by\n  rw [to_list, ← Multiset.coe_nodup, Multiset.coe_toList]\n  exact s.nodup\n#align nodup_to_list nodup_to_list\n\n",
 "ne_of_mem_erase":
 "theorem ne_of_mem_erase : b ∈ erase s a → b ≠ a := fun h => (mem_erase.1 h).1\n#align ne_of_mem_erase ne_of_mem_erase\n\n",
 "ne_insert_of_not_mem":
 "theorem ne_insert_of_not_mem (s t : Finset α) {a : α} (h : a ∉ s) : s ≠ insert a t :=\n  by\n  contrapose! h\n  simp [h]\n#align ne_insert_of_not_mem ne_insert_of_not_mem\n\n",
 "ne_empty_of_mem":
 "theorem ne_empty_of_mem {a : α} {s : Finset α} (h : a ∈ s) : s ≠ ∅ := fun e => not_mem_empty a <| e ▸ h\n#align ne_empty_of_mem ne_empty_of_mem\n\n",
 "ne_empty":
 "theorem nonempty.ne_empty {s : Finset α} (h : s.nonempty) : s ≠ ∅ :=\n  exists.elim h fun a => ne_empty_of_mem\n#align nonempty.ne_empty nonempty.ne_empty\n\n",
 "monotone_filter_right":
 "theorem monotone_filter_right (s : Finset α) ⦃p q : α → Prop⦄ [decidable_pred p] [decidable_pred q] (h : p ≤ q) :\n    s.filter p ≤ s.filter q :=\n  Multiset.subset_of_le (Multiset.monotone_filter_right s.val h)\n#align monotone_filter_right monotone_filter_right\n\n",
 "monotone_filter_left":
 "theorem monotone_filter_left : monotone (filter p) := fun _ _ => filter_subset_filter p\n#align monotone_filter_left monotone_filter_left\n\n",
 "mono":
 "theorem nonempty.mono {s t : Finset α} (hst : s ⊆ t) (hs : s.nonempty) : t.nonempty :=\n  Set.Nonempty.mono hst hs\n#align nonempty.mono nonempty.mono\n\n",
 "mk_zero":
 "@[simp]\ntheorem mk_zero : (⟨0, nodup_zero⟩ : Finset α) = ∅ :=\n  rfl\n#align mk_zero mk_zero\n\n",
 "mk_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem mk_cons {s : Multiset α} (h : («expr ::ₘ » a s).nodup) :\n    (⟨«expr ::ₘ » a s, h⟩ : Finset α) = cons a ⟨s, (nodup_cons.1 h).2⟩ (nodup_cons.1 h).1 :=\n  rfl\n#align mk_cons mk_cons\n\n",
 "mk_coe":
 "@[simp]\ntheorem mk_coe {s : Finset α} (x : (s : set α)) {h} : (⟨x, h⟩ : (s : set α)) = x :=\n  subtype.coe_eta _ _\n#align mk_coe mk_coe\n\n",
 "mem_val":
 "@[simp]\ntheorem mem_val {a : α} {s : Finset α} : a ∈ s.1 ↔ a ∈ s :=\n  iff.rfl\n#align mem_val mem_val\n\n",
 "mem_union_right":
 "theorem mem_union_right (s : Finset α) (h : a ∈ t) : a ∈ s ∪ t :=\n  mem_union.2 <| or.inr h\n#align mem_union_right mem_union_right\n\n",
 "mem_union_left":
 "theorem mem_union_left (t : Finset α) (h : a ∈ s) : a ∈ s ∪ t :=\n  mem_union.2 <| or.inl h\n#align mem_union_left mem_union_left\n\n",
 "mem_union":
 "@[simp]\ntheorem mem_union : a ∈ s ∪ t ↔ a ∈ s ∨ a ∈ t :=\n  mem_ndunion\n#align mem_union mem_union\n\n",
 "mem_to_list":
 "@[simp]\ntheorem mem_to_list {a : α} {s : Finset α} : a ∈ s.to_list ↔ a ∈ s :=\n  mem_to_list\n#align mem_to_list mem_to_list\n\n",
 "mem_to_finset":
 "@[simp]\ntheorem mem_to_finset : a ∈ l.to_finset ↔ a ∈ l :=\n  mem_dedup\n#align mem_to_finset mem_to_finset\n\n",
 "mem_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\ntheorem mem_symm_diff : a ∈ «expr ∆ » s t ↔ a ∈ s ∧ a ∉ t ∨ a ∈ t ∧ a ∉ s := by\n  simp_rw [symmDiff, sup_eq_union, mem_union, mem_sdiff]\n#align mem_symm_diff mem_symm_diff\n\n",
 "mem_singleton_self":
 "theorem mem_singleton_self (a : α) : a ∈ ({a} : Finset α) :=\n  or.inl rfl\n#align mem_singleton_self mem_singleton_self\n\n",
 "mem_singleton":
 "@[simp]\ntheorem mem_singleton {a b : α} : b ∈ ({a} : Finset α) ↔ b = a :=\n  mem_singleton\n#align mem_singleton mem_singleton\n\n",
 "mem_sdiff":
 "@[simp]\ntheorem mem_sdiff : a ∈ s \\ t ↔ a ∈ s ∧ a ∉ t :=\n  mem_sub_of_nodup s.2\n#align mem_sdiff mem_sdiff\n\n",
 "mem_range_succ_iff":
 "theorem mem_range_succ_iff {a b : ℕ} : a ∈ Finset.range b.succ ↔ a ≤ b :=\n  Finset.mem_range.trans Nat.lt_succ_iff\n#align mem_range_succ_iff mem_range_succ_iff\n\n",
 "mem_range_sub_ne_zero":
 "theorem mem_range_sub_ne_zero {n x : ℕ} (hx : x ∈ range n) : n - x ≠ 0 :=\n  ne_of_gt <| tsub_pos_of_lt <| mem_range.1 hx\n#align mem_range_sub_ne_zero mem_range_sub_ne_zero\n\n",
 "mem_range_le":
 "theorem mem_range_le {n x : ℕ} (hx : x ∈ range n) : x ≤ n :=\n  (mem_range.1 hx).le\n#align mem_range_le mem_range_le\n\n",
 "mem_range":
 "@[simp]\ntheorem mem_range : m ∈ range n ↔ m < n :=\n  mem_range\n#align mem_range mem_range\n\n",
 "mem_of_subset":
 "theorem mem_of_subset {s₁ s₂ : Finset α} {a : α} : s₁ ⊆ s₂ → a ∈ s₁ → a ∈ s₂ :=\n  mem_of_subset\n#align mem_of_subset mem_of_subset\n\n",
 "mem_of_mem_inter_right":
 "theorem mem_of_mem_inter_right {a : α} {s₁ s₂ : Finset α} (h : a ∈ s₁ ∩ s₂) : a ∈ s₂ :=\n  (mem_inter.1 h).2\n#align mem_of_mem_inter_right mem_of_mem_inter_right\n\n",
 "mem_of_mem_inter_left":
 "theorem mem_of_mem_inter_left {a : α} {s₁ s₂ : Finset α} (h : a ∈ s₁ ∩ s₂) : a ∈ s₁ :=\n  (mem_inter.1 h).1\n#align mem_of_mem_inter_left mem_of_mem_inter_left\n\n",
 "mem_of_mem_insert_of_ne":
 "theorem mem_of_mem_insert_of_ne (h : b ∈ insert a s) : b ≠ a → b ∈ s :=\n  (mem_insert.1 h).resolve_left\n#align mem_of_mem_insert_of_ne mem_of_mem_insert_of_ne\n\n",
 "mem_of_mem_filter":
 "theorem mem_of_mem_filter {s : Finset α} (x : α) (h : x ∈ s.filter p) : x ∈ s :=\n  mem_of_mem_filter h\n#align mem_of_mem_filter mem_of_mem_filter\n\n",
 "mem_of_mem_erase":
 "theorem mem_of_mem_erase : b ∈ erase s a → b ∈ s :=\n  mem_of_mem_erase\n#align mem_of_mem_erase mem_of_mem_erase\n\n",
 "mem_mk":
 "@[simp]\ntheorem mem_mk {a : α} {s nd} : a ∈ @finset.mk α s nd ↔ a ∈ s :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_inter_of_mem":
 "theorem mem_inter_of_mem {a : α} {s₁ s₂ : Finset α} : a ∈ s₁ → a ∈ s₂ → a ∈ s₁ ∩ s₂ :=\n  and_imp.1 mem_inter.2\n#align mem_inter_of_mem mem_inter_of_mem\n\n",
 "mem_inter":
 "@[simp]\ntheorem mem_inter {a : α} {s₁ s₂ : Finset α} : a ∈ s₁ ∩ s₂ ↔ a ∈ s₁ ∧ a ∈ s₂ :=\n  mem_ndinter\n#align mem_inter mem_inter\n\n",
 "mem_insert_self":
 "theorem mem_insert_self (a : α) (s : Finset α) : a ∈ insert a s :=\n  mem_ndinsert_self a s.1\n#align mem_insert_self mem_insert_self\n\n",
 "mem_insert_of_mem":
 "theorem mem_insert_of_mem (h : a ∈ s) : a ∈ insert b s :=\n  mem_ndinsert_of_mem h\n#align mem_insert_of_mem mem_insert_of_mem\n\n",
 "mem_insert_coe":
 "theorem mem_insert_coe {s : Finset α} {x y : α} : x ∈ insert y s ↔ x ∈ insert y (s : set α) := by simp\n#align mem_insert_coe mem_insert_coe\n\n",
 "mem_insert":
 "@[simp]\ntheorem mem_insert : a ∈ insert b s ↔ a = b ∨ a ∈ s :=\n  mem_ndinsert\n#align mem_insert mem_insert\n\n",
 "mem_filter":
 "@[simp]\ntheorem mem_filter {s : Finset α} {a : α} : a ∈ s.filter p ↔ a ∈ s ∧ p a :=\n  mem_filter\n#align mem_filter mem_filter\n\n",
 "mem_erase_of_ne_of_mem":
 "theorem mem_erase_of_ne_of_mem : a ≠ b → a ∈ s → a ∈ erase s b := by simp only [mem_erase] <;> exact and.intro\n#align mem_erase_of_ne_of_mem mem_erase_of_ne_of_mem\n\n",
 "mem_erase":
 "@[simp]\ntheorem mem_erase {a b : α} {s : Finset α} : a ∈ erase s b ↔ a ≠ b ∧ a ∈ s :=\n  s.2.mem_erase_iff\n#align mem_erase mem_erase\n\n",
 "mem_disj_union":
 "@[simp]\ntheorem mem_disj_union {α s t h a} : a ∈ @disjUnion α s t h ↔ a ∈ s ∨ a ∈ t := by\n  rcases s with ⟨⟨s⟩⟩ <;> rcases t with ⟨⟨t⟩⟩ <;> apply list.mem_append\n#align mem_disj_union mem_disj_union\n\n",
 "mem_disj_Union":
 "@[simp]\ntheorem mem_disj_Union {b : β} {h} : b ∈ s.disj_Union t h ↔ ∃ a ∈ s, b ∈ t a := by\n  simp only [mem_def, disj_Union_val, mem_bind, exists_prop]\n#align mem_disj_Union mem_disj_Union\n\n",
 "mem_def":
 "theorem mem_def {a : α} {s : Finset α} : a ∈ s ↔ a ∈ s.1 :=\n  iff.rfl\n#align mem_def mem_def\n\n",
 "mem_cons_self":
 "@[simp]\ntheorem mem_cons_self (a : α) (s : Finset α) {h} : a ∈ cons a s h :=\n  mem_cons_self _ _\n#align mem_cons_self mem_cons_self\n\n",
 "mem_cons":
 "@[simp]\ntheorem mem_cons {h} : b ∈ s.cons a h ↔ b = a ∨ b ∈ s :=\n  mem_cons\n#align mem_cons mem_cons\n\n",
 "mem_coe":
 "@[simp, norm_cast]\ntheorem mem_coe {a : α} {s : Finset α} : a ∈ (s : set α) ↔ a ∈ s :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "mem_bUnion":
 "@[simp]\ntheorem mem_bUnion {b : β} : b ∈ s.bUnion t ↔ ∃ a ∈ s, b ∈ t a := by\n  simp only [mem_def, bUnion_val, mem_dedup, mem_bind, exists_prop]\n#align mem_bUnion mem_bUnion\n\n",
 "mem_attach":
 "@[simp]\ntheorem mem_attach (s : Finset α) : ∀ x, x ∈ s.attach :=\n  mem_attach _\n#align mem_attach mem_attach\n\n",
 "lt_iff_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem lt_iff_ssubset {s₁ s₂ : Finset α} : s₁ < s₂ ↔ «expr ⊂ » s₁ s₂ :=\n  iff.rfl\n#align lt_iff_ssubset lt_iff_ssubset\n\n",
 "lt_eq_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊂ » -/\n@[simp]\ntheorem lt_eq_subset : ((· < ·) : Finset α → Finset α → Prop) = («expr ⊂ » · ·) :=\n  rfl\n#align lt_eq_subset lt_eq_subset\n\n",
 "left_eq_union_iff_subset":
 "@[simp]\ntheorem left_eq_union_iff_subset {s t : Finset α} : s = s ∪ t ↔ t ⊆ s := by rw [← union_eq_left_iff_subset, eq_comm]\n#align left_eq_union_iff_subset left_eq_union_iff_subset\n\n",
 "le_piecewise_of_le_of_le":
 "theorem le_piecewise_of_le_of_le {δ : α → Type _} [∀ i, preorder (δ i)] {f g h : ∀ i, δ i} (Hf : h ≤ f) (Hg : h ≤ g) :\n    h ≤ s.piecewise f g := fun x => piecewise_cases s f g (fun y => h x ≤ y) (Hf x) (Hg x)\n#align le_piecewise_of_le_of_le le_piecewise_of_le_of_le\n\n",
 "le_iff_subset":
 "theorem le_iff_subset {s₁ s₂ : Finset α} : s₁ ≤ s₂ ↔ s₁ ⊆ s₂ :=\n  iff.rfl\n#align le_iff_subset le_iff_subset\n\n",
 "le_eq_subset":
 "@[simp]\ntheorem le_eq_subset : ((· ≤ ·) : Finset α → Finset α → Prop) = (· ⊆ ·) :=\n  rfl\n#align le_eq_subset le_eq_subset\n\n",
 "ite_subset_union":
 "theorem ite_subset_union (s s' : Finset α) (P : Prop) [decidable P] : ite P s s' ⊆ s ∪ s' :=\n  ite_le_sup s s' P\n#align ite_subset_union ite_subset_union\n\n",
 "is_empty_coe_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[simp]\ntheorem is_empty_coe_sort {s : Finset α} : is_empty («expr↥ » s) ↔ s = ∅ := by simpa using @Set.isEmpty_coe_sort α s\n#align is_empty_coe_sort is_empty_coe_sort\n\n",
 "inter_val_nd":
 "theorem inter_val_nd (s₁ s₂ : Finset α) : (s₁ ∩ s₂).1 = ndinter s₁.1 s₂.1 :=\n  rfl\n#align inter_val_nd inter_val_nd\n\n",
 "inter_val":
 "@[simp]\ntheorem inter_val (s₁ s₂ : Finset α) : (s₁ ∩ s₂).1 = s₁.1 ∩ s₂.1 :=\n  ndinter_eq_inter s₁.2\n#align inter_val inter_val\n\n",
 "inter_union_self":
 "@[simp]\ntheorem inter_union_self (s t : Finset α) : s ∩ (t ∪ s) = s := by rw [inter_comm, union_inter_cancel_right]\n#align inter_union_self inter_union_self\n\n",
 "inter_subset_union":
 "theorem inter_subset_union : s ∩ t ⊆ s ∪ t :=\n  le_iff_subset.1 inf_le_sup\n#align inter_subset_union inter_subset_union\n\n",
 "inter_subset_right":
 "theorem inter_subset_right (s₁ s₂ : Finset α) : s₁ ∩ s₂ ⊆ s₂ := fun a => mem_of_mem_inter_right\n#align inter_subset_right inter_subset_right\n\n",
 "inter_subset_left":
 "theorem inter_subset_left (s₁ s₂ : Finset α) : s₁ ∩ s₂ ⊆ s₁ := fun a => mem_of_mem_inter_left\n#align inter_subset_left inter_subset_left\n\n",
 "inter_subset_ite":
 "theorem inter_subset_ite (s s' : Finset α) (P : Prop) [decidable P] : s ∩ s' ⊆ ite P s s' :=\n  inf_le_ite s s' P\n#align inter_subset_ite inter_subset_ite\n\n",
 "inter_subset_inter_right":
 "theorem inter_subset_inter_right (h : s ⊆ t) : s ∩ u ⊆ t ∩ u :=\n  inter_subset_inter h Subset.rfl\n#align inter_subset_inter_right inter_subset_inter_right\n\n",
 "inter_subset_inter_left":
 "theorem inter_subset_inter_left (h : t ⊆ u) : s ∩ t ⊆ s ∩ u :=\n  inter_subset_inter Subset.rfl h\n#align inter_subset_inter_left inter_subset_inter_left\n\n",
 "inter_subset_inter":
 "@[mono]\ntheorem inter_subset_inter {x y s t : Finset α} (h : x ⊆ y) (h' : s ⊆ t) : x ∩ s ⊆ y ∩ t :=\n  by\n  intro a a_in\n  rw [Finset.mem_inter] at a_in⊢\n  exact ⟨h a_in.1, h' a_in.2⟩\n#align inter_subset_inter inter_subset_inter\n\n",
 "inter_singleton_of_not_mem":
 "@[simp]\ntheorem inter_singleton_of_not_mem {a : α} {s : Finset α} (h : a ∉ s) : s ∩ {a} = ∅ := by\n  rw [inter_comm, singleton_inter_of_not_mem h]\n#align inter_singleton_of_not_mem inter_singleton_of_not_mem\n\n",
 "inter_singleton_of_mem":
 "@[simp]\ntheorem inter_singleton_of_mem {a : α} {s : Finset α} (h : a ∈ s) : s ∩ {a} = {a} := by\n  rw [inter_comm, singleton_inter_of_mem h]\n#align inter_singleton_of_mem inter_singleton_of_mem\n\n",
 "inter_self":
 "@[simp]\ntheorem inter_self (s : Finset α) : s ∩ s = s :=\n  ext fun _ => mem_inter.trans <| and_self_iff _\n#align inter_self inter_self\n\n",
 "inter_sdiff_self":
 "@[simp]\ntheorem inter_sdiff_self (s₁ s₂ : Finset α) : s₁ ∩ (s₂ \\ s₁) = ∅ :=\n  eq_empty_of_forall_not_mem <| by simp only [mem_inter, mem_sdiff] <;> rintro x ⟨h, _, hn⟩ <;> exact hn h\n#align inter_sdiff_self inter_sdiff_self\n\n",
 "inter_sdiff":
 "theorem inter_sdiff (s t u : Finset α) : s ∩ (t \\ u) = (s ∩ t) \\ u :=\n  by\n  ext x\n  simp [and_assoc']\n#align inter_sdiff inter_sdiff\n\n",
 "inter_right_idem":
 "@[simp]\ntheorem inter_right_idem (s t : Finset α) : s ∩ t ∩ t = s ∩ t :=\n  inf_right_idem\n#align inter_right_idem inter_right_idem\n\n",
 "inter_right_comm":
 "theorem inter_right_comm (s₁ s₂ s₃ : Finset α) : s₁ ∩ s₂ ∩ s₃ = s₁ ∩ s₃ ∩ s₂ :=\n  ext fun _ => by simp only [mem_inter, and_right_comm]\n#align inter_right_comm inter_right_comm\n\n",
 "inter_left_idem":
 "@[simp]\ntheorem inter_left_idem (s t : Finset α) : s ∩ (s ∩ t) = s ∩ t :=\n  inf_left_idem\n#align inter_left_idem inter_left_idem\n\n",
 "inter_left_comm":
 "theorem inter_left_comm (s₁ s₂ s₃ : Finset α) : s₁ ∩ (s₂ ∩ s₃) = s₂ ∩ (s₁ ∩ s₃) :=\n  ext fun _ => by simp only [mem_inter, and_left_comm]\n#align inter_left_comm inter_left_comm\n\n",
 "inter_inter_inter_comm":
 "theorem inter_inter_inter_comm (s t u v : Finset α) : s ∩ t ∩ (u ∩ v) = s ∩ u ∩ (t ∩ v) :=\n  inf_inf_inf_comm _ _ _ _\n#align inter_inter_inter_comm inter_inter_inter_comm\n\n",
 "inter_inter_distrib_right":
 "theorem inter_inter_distrib_right (s t u : Finset α) : s ∩ t ∩ u = s ∩ u ∩ (t ∩ u) :=\n  inf_inf_distrib_right _ _ _\n#align inter_inter_distrib_right inter_inter_distrib_right\n\n",
 "inter_inter_distrib_left":
 "theorem inter_inter_distrib_left (s t u : Finset α) : s ∩ (t ∩ u) = s ∩ t ∩ (s ∩ u) :=\n  inf_inf_distrib_left _ _ _\n#align inter_inter_distrib_left inter_inter_distrib_left\n\n",
 "inter_insert_of_not_mem":
 "@[simp]\ntheorem inter_insert_of_not_mem {s₁ s₂ : Finset α} {a : α} (h : a ∉ s₁) : s₁ ∩ insert a s₂ = s₁ ∩ s₂ := by\n  rw [inter_comm, insert_inter_of_not_mem h, inter_comm]\n#align inter_insert_of_not_mem inter_insert_of_not_mem\n\n",
 "inter_insert_of_mem":
 "@[simp]\ntheorem inter_insert_of_mem {s₁ s₂ : Finset α} {a : α} (h : a ∈ s₁) : s₁ ∩ insert a s₂ = insert a (s₁ ∩ s₂) := by\n  rw [inter_comm, insert_inter_of_mem h, inter_comm]\n#align inter_insert_of_mem inter_insert_of_mem\n\n",
 "inter_filter":
 "theorem inter_filter (s t : Finset α) : s ∩ filter p t = filter p (s ∩ t) := by\n  rw [inter_comm, filter_inter, inter_comm]\n#align inter_filter inter_filter\n\n",
 "inter_eq_right_iff_subset":
 "@[simp]\ntheorem inter_eq_right_iff_subset (s t : Finset α) : t ∩ s = s ↔ s ⊆ t :=\n  inf_eq_right\n#align inter_eq_right_iff_subset inter_eq_right_iff_subset\n\n",
 "inter_eq_left_iff_subset":
 "@[simp]\ntheorem inter_eq_left_iff_subset (s t : Finset α) : s ∩ t = s ↔ s ⊆ t :=\n  inf_eq_left\n#align inter_eq_left_iff_subset inter_eq_left_iff_subset\n\n",
 "inter_eq_inter_iff_right":
 "theorem inter_eq_inter_iff_right : s ∩ u = t ∩ u ↔ t ∩ u ⊆ s ∧ s ∩ u ⊆ t :=\n  inf_eq_inf_iff_right\n#align inter_eq_inter_iff_right inter_eq_inter_iff_right\n\n",
 "inter_eq_inter_iff_left":
 "theorem inter_eq_inter_iff_left : s ∩ t = s ∩ u ↔ s ∩ u ⊆ t ∧ s ∩ t ⊆ u :=\n  inf_eq_inf_iff_left\n#align inter_eq_inter_iff_left inter_eq_inter_iff_left\n\n",
 "inter_empty":
 "@[simp]\ntheorem inter_empty (s : Finset α) : s ∩ ∅ = ∅ :=\n  ext fun _ => mem_inter.trans <| and_false_iff _\n#align inter_empty inter_empty\n\n",
 "inter_distrib_right":
 "theorem inter_distrib_right (s t u : Finset α) : (s ∪ t) ∩ u = s ∩ u ∪ t ∩ u :=\n  inf_sup_right\n#align inter_distrib_right inter_distrib_right\n\n",
 "inter_distrib_left":
 "theorem inter_distrib_left (s t u : Finset α) : s ∩ (t ∪ u) = s ∩ t ∪ s ∩ u :=\n  inf_sup_left\n#align inter_distrib_left inter_distrib_left\n\n",
 "inter_congr_right":
 "theorem inter_congr_right (hs : t ∩ u ⊆ s) (ht : s ∩ u ⊆ t) : s ∩ u = t ∩ u :=\n  inf_congr_right hs ht\n#align inter_congr_right inter_congr_right\n\n",
 "inter_congr_left":
 "theorem inter_congr_left (ht : s ∩ u ⊆ t) (hu : s ∩ t ⊆ u) : s ∩ t = s ∩ u :=\n  inf_congr_left ht hu\n#align inter_congr_left inter_congr_left\n\n",
 "inter_comm":
 "theorem inter_comm (s₁ s₂ : Finset α) : s₁ ∩ s₂ = s₂ ∩ s₁ :=\n  ext fun _ => by simp only [mem_inter, and_comm']\n#align inter_comm inter_comm\n\n",
 "inter_bUnion":
 "theorem inter_bUnion (t : Finset β) (s : Finset α) (f : α → Finset β) : t ∩ s.bUnion f = s.bUnion fun x => t ∩ f x := by\n  rw [inter_comm, bUnion_inter] <;> simp [inter_comm]\n#align inter_bUnion inter_bUnion\n\n",
 "inter_assoc":
 "@[simp]\ntheorem inter_assoc (s₁ s₂ s₃ : Finset α) : s₁ ∩ s₂ ∩ s₃ = s₁ ∩ (s₂ ∩ s₃) :=\n  ext fun _ => by simp only [mem_inter, and_assoc']\n#align inter_assoc inter_assoc\n\n",
 "insert_val_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem insert_val_of_not_mem {a : α} {s : Finset α} (h : a ∉ s) : (insert a s).1 = «expr ::ₘ » a s.1 := by\n  rw [insert_val, ndinsert_of_not_mem h]\n#align insert_val_of_not_mem insert_val_of_not_mem\n\n",
 "insert_val'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem insert_val' (a : α) (s : Finset α) : (insert a s).1 = dedup («expr ::ₘ » a s.1) := by\n  rw [dedup_cons, dedup_eq_self] <;> rfl\n#align insert_val' insert_val'\n\n",
 "insert_val":
 "@[simp]\ntheorem insert_val (a : α) (s : Finset α) : (insert a s).1 = ndinsert a s.1 :=\n  rfl\n#align insert_val insert_val\n\n",
 "insert_union_distrib":
 "theorem insert_union_distrib (a : α) (s t : Finset α) : insert a (s ∪ t) = insert a s ∪ insert a t := by\n  simp only [insert_union, union_insert, insert_idem]\n#align insert_union_distrib insert_union_distrib\n\n",
 "insert_union":
 "@[simp]\ntheorem insert_union (a : α) (s t : Finset α) : insert a s ∪ t = insert a (s ∪ t) := by\n  simp only [insert_eq, union_assoc]\n#align insert_union insert_union\n\n",
 "insert_subset_insert":
 "theorem insert_subset_insert (a : α) {s t : Finset α} (h : s ⊆ t) : insert a s ⊆ insert a t :=\n  insert_subset.2 ⟨mem_insert_self _ _, Subset.trans h (subset_insert _ _)⟩\n#align insert_subset_insert insert_subset_insert\n\n",
 "insert_subset":
 "theorem insert_subset : insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t := by\n  simp only [subset_iff, mem_insert, forall_eq, or_imp, forall_and]\n#align insert_subset insert_subset\n\n",
 "insert_sdiff_of_not_mem":
 "theorem insert_sdiff_of_not_mem (s : Finset α) {t : Finset α} {x : α} (h : x ∉ t) : insert x s \\ t = insert x (s \\ t) :=\n  by\n  rw [← coe_inj, coe_insert, coe_sdiff, coe_sdiff, coe_insert]\n  exact Set.insert_diff_of_not_mem s h\n#align insert_sdiff_of_not_mem insert_sdiff_of_not_mem\n\n",
 "insert_sdiff_of_mem":
 "theorem insert_sdiff_of_mem (s : Finset α) {x : α} (h : x ∈ t) : insert x s \\ t = s \\ t :=\n  by\n  rw [← coe_inj, coe_sdiff, coe_sdiff, coe_insert]\n  exact Set.insert_diff_of_mem s h\n#align insert_sdiff_of_mem insert_sdiff_of_mem\n\n",
 "insert_sdiff_insert":
 "@[simp]\ntheorem insert_sdiff_insert (s t : Finset α) (x : α) : insert x s \\ insert x t = s \\ insert x t :=\n  insert_sdiff_of_mem _ (mem_insert_self _ _)\n#align insert_sdiff_insert insert_sdiff_insert\n\n",
 "insert_nonempty":
 "@[simp]\ntheorem insert_nonempty (a : α) (s : Finset α) : (insert a s).nonempty :=\n  ⟨a, mem_insert_self a s⟩\n#align insert_nonempty insert_nonempty\n\n",
 "insert_ne_self":
 "theorem insert_ne_self : insert a s ≠ s ↔ a ∉ s :=\n  insert_eq_self.not\n#align insert_ne_self insert_ne_self\n\n",
 "insert_ne_empty":
 "@[simp]\ntheorem insert_ne_empty (a : α) (s : Finset α) : insert a s ≠ ∅ :=\n  (insert_nonempty a s).ne_empty\n#align insert_ne_empty insert_ne_empty\n\n",
 "insert_inter_of_not_mem":
 "@[simp]\ntheorem insert_inter_of_not_mem {s₁ s₂ : Finset α} {a : α} (h : a ∉ s₂) : insert a s₁ ∩ s₂ = s₁ ∩ s₂ :=\n  ext fun x => by\n    have : ¬(x = a ∧ x ∈ s₂) := by rintro ⟨rfl, H⟩ <;> exact h H\n    simp only [mem_inter, mem_insert, or_and_right, this, false_or_iff]\n#align insert_inter_of_not_mem insert_inter_of_not_mem\n\n",
 "insert_inter_of_mem":
 "@[simp]\ntheorem insert_inter_of_mem {s₁ s₂ : Finset α} {a : α} (h : a ∈ s₂) : insert a s₁ ∩ s₂ = insert a (s₁ ∩ s₂) :=\n  ext fun x => by\n    have : x = a ∨ x ∈ s₂ ↔ x ∈ s₂ := or_iff_right_of_imp <| by rintro rfl <;> exact h\n    simp only [mem_inter, mem_insert, or_and_left, this]\n#align insert_inter_of_mem insert_inter_of_mem\n\n",
 "insert_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem insert_inj_on (s : Finset α) : Set.InjOn (fun a => insert a s) («expr ᶜ» s) := fun a h b _ => (insert_inj h).1\n#align insert_inj_on insert_inj_on\n\n",
 "insert_inj":
 "theorem insert_inj (ha : a ∉ s) : insert a s = insert b s ↔ a = b :=\n  ⟨fun h => eq_of_not_mem_of_mem_insert (h.subst <| mem_insert_self _ _) ha, congr_arg _⟩\n#align insert_inj insert_inj\n\n",
 "insert_idem":
 "@[simp]\ntheorem insert_idem (a : α) (s : Finset α) : insert a (insert a s) = insert a s :=\n  ext fun x => by simp only [mem_insert, or.assoc.symm, or_self_iff]\n#align insert_idem insert_idem\n\n",
 "insert_erase_subset":
 "theorem insert_erase_subset (a : α) (s : Finset α) : s ⊆ insert a (erase s a) :=\n  subset_insert_iff.2 <| subset.rfl\n#align insert_erase_subset insert_erase_subset\n\n",
 "insert_erase":
 "theorem insert_erase {a : α} {s : Finset α} (h : a ∈ s) : insert a (erase s a) = s :=\n  ext fun x => by\n    simp only [mem_insert, mem_erase, or_and_left, dec_em, true_and_iff] <;> apply or_iff_right_of_imp <;>\n        rintro rfl <;>\n      exact h\n#align insert_erase insert_erase\n\n",
 "insert_eq_self":
 "@[simp]\ntheorem insert_eq_self : insert a s = s ↔ a ∈ s :=\n  ⟨fun h => h ▸ mem_insert_self _ _, insert_eq_of_mem⟩\n#align insert_eq_self insert_eq_self\n\n",
 "insert_eq_of_mem":
 "@[simp]\ntheorem insert_eq_of_mem (h : a ∈ s) : insert a s = s :=\n  eq_of_veq <| ndinsert_of_mem h\n#align insert_eq_of_mem insert_eq_of_mem\n\n",
 "insert_eq":
 "theorem insert_eq (a : α) (s : Finset α) : insert a s = {a} ∪ s :=\n  rfl\n#align insert_eq insert_eq\n\n",
 "insert_def":
 "theorem insert_def (a : α) (s : Finset α) : insert a s = ⟨_, s.2.ndinsert a⟩ :=\n  rfl\n#align insert_def insert_def\n\n",
 "inf_eq_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_eq_inter : ((«expr ⊓ » · ·) : Finset α → Finset α → Finset α) = (· ∩ ·) :=\n  rfl\n#align inf_eq_inter inf_eq_inter\n\n",
 "induction_on_union":
 "/-- To prove a relation on pairs of `finset X`, it suffices to show that it is\n  * symmetric,\n  * it holds when one of the `finset`s is empty,\n  * it holds for pairs of singletons,\n  * if it holds for `[a, c]` and for `[b, c]`, then it holds for `[a ∪ b, c]`.\n-/\ntheorem induction_on_union (P : Finset α → Finset α → Prop) (symm : ∀ {a b}, P a b → P b a) (empty_right : ∀ {a}, P a ∅)\n    (singletons : ∀ {a b}, P {a} {b}) (union_of : ∀ {a b c}, P a c → P b c → P (a ∪ b) c) : ∀ a b, P a b :=\n  by\n  intro a b\n  refine' Finset.induction_on b empty_right fun x s xs hi => symm _\n  rw [Finset.insert_eq]\n  apply union_of _ (symm hi)\n  refine' Finset.induction_on a empty_right fun a t ta hi => symm _\n  rw [Finset.insert_eq]\n  exact union_of singletons (symm hi)\n#align induction_on_union induction_on_union\n\n",
 "induction_on'":
 "/-- To prove a proposition about `S : finset α`,\nit suffices to prove it for the empty `finset`,\nand to show that if it holds for some `finset α ⊆ S`,\nthen it holds for the `finset` obtained by inserting a new element of `S`.\n-/\n@[elab_as_elim]\ntheorem induction_on' {α : Type _} {p : Finset α → Prop} [decidable_eq α] (S : Finset α) (h₁ : p ∅)\n    (h₂ : ∀ {a s}, a ∈ S → s ⊆ S → a ∉ s → p s → p (insert a s)) : p S :=\n  @Finset.induction_on α (fun T => T ⊆ S → p T) _ S (fun _ => h₁)\n    (fun a s has hqs hs =>\n      let ⟨hS, sS⟩ := Finset.insert_subset.1 hs\n      h₂ hS sS has (hqs sS))\n    (Finset.Subset.refl S)\n#align induction_on' induction_on'\n\n",
 "induction_on":
 "/-- To prove a proposition about an arbitrary `finset α`,\nit suffices to prove it for the empty `finset`,\nand to show that if it holds for some `finset α`,\nthen it holds for the `finset` obtained by inserting a new element.\n-/\n@[elab_as_elim]\nprotected theorem induction_on {α : Type _} {p : Finset α → Prop} [decidable_eq α] (s : Finset α) (h₁ : p ∅)\n    (h₂ : ∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (insert a s)) : p s :=\n  Finset.induction h₁ h₂ s\n#align induction_on induction_on\n\n",
 "induction":
 "@[elab_as_elim]\nprotected theorem induction {α : Type _} {p : Finset α → Prop} [decidable_eq α] (h₁ : p ∅)\n    (h₂ : ∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (insert a s)) : ∀ s, p s :=\n  cons_induction h₁ fun a s ha => (s.cons_eq_insert a ha).symm ▸ h₂ ha\n#align induction induction\n\n",
 "forall_ne_finset":
 "#print Disjoint.forall_ne_finset /-\ntheorem Disjoint.forall_ne_finset (h : Disjoint s t) (ha : a ∈ s) (hb : b ∈ t) : a ≠ b :=\n  disjoint_iff_ne.1 h _ ha _ hb\n#align disjoint.forall_ne_finset Disjoint.forall_ne_finset\n-/\n\n",
 "forall_mem_union":
 "theorem forall_mem_union {p : α → Prop} : (∀ a ∈ s ∪ t, p a) ↔ (∀ a ∈ s, p a) ∧ ∀ a ∈ t, p a :=\n  ⟨fun h => ⟨fun a => h a ∘ mem_union_left _, fun b => h b ∘ mem_union_right _⟩, fun h ab hab =>\n    (mem_union.mp hab).elim (h.1 _) (h.2 _)⟩\n#align forall_mem_union forall_mem_union\n\n",
 "forall_mem_insert":
 "theorem forall_mem_insert [decidable_eq α] (a : α) (s : Finset α) (p : α → Prop) :\n    (∀ x, x ∈ insert a s → p x) ↔ p a ∧ ∀ x, x ∈ s → p x := by simp only [mem_insert, or_imp, forall_and, forall_eq]\n#align forall_mem_insert forall_mem_insert\n\n",
 "forall_mem_empty_iff":
 "theorem forall_mem_empty_iff (p : α → Prop) : (∀ x, x ∈ (∅ : Finset α) → p x) ↔ true :=\n  iff_true_intro fun _ => false.elim\n#align forall_mem_empty_iff forall_mem_empty_iff\n\n",
 "forall_mem_cons":
 "theorem forall_mem_cons (h : a ∉ s) (p : α → Prop) : (∀ x, x ∈ cons a s h → p x) ↔ p a ∧ ∀ x, x ∈ s → p x := by\n  simp only [mem_cons, or_imp, forall_and, forall_eq]\n#align forall_mem_cons forall_mem_cons\n\n",
 "forall_const":
 "theorem nonempty.forall_const {s : Finset α} (h : s.nonempty) {p : Prop} : (∀ x ∈ s, p) ↔ p :=\n  let ⟨x, hx⟩ := h\n  ⟨fun h => h x hx, fun h x hx => h⟩\n#align nonempty.forall_const nonempty.forall_const\n\n",
 "forall_coe":
 "@[simp]\nprotected theorem forall_coe {α : Type _} (s : Finset α) (p : s → Prop) :\n    (∀ x : s, p x) ↔ ∀ (x : α) (h : x ∈ s), p ⟨x, h⟩ :=\n  subtype.forall\n#align forall_coe forall_coe\n\n",
 "filter_val":
 "@[simp]\ntheorem filter_val (s : Finset α) : (filter p s).1 = s.1.filter p :=\n  rfl\n#align filter_val filter_val\n\n",
 "filter_union_right":
 "theorem filter_union_right (s : Finset α) : s.filter p ∪ s.filter q = s.filter fun x => p x ∨ q x :=\n  ext fun x => by simp only [mem_filter, mem_union, and_or_distrib_left.symm]\n#align filter_union_right filter_union_right\n\n",
 "filter_union_filter_of_codisjoint":
 "theorem filter_union_filter_of_codisjoint (s : Finset α) (h : Codisjoint p q) : s.filter p ∪ s.filter q = s :=\n  (filter_or _ _ _).symm.trans <| filter_true_of_mem fun x hx => h.top_le x trivial\n#align filter_union_filter_of_codisjoint filter_union_filter_of_codisjoint\n\n",
 "filter_union_filter_neg_eq":
 "theorem filter_union_filter_neg_eq [decidable_pred fun a => ¬p a] (s : Finset α) :\n    (s.filter p ∪ s.filter fun a => ¬p a) = s :=\n  filter_union_filter_of_codisjoint _ _ _ codisjoint_hnot_right\n#align filter_union_filter_neg_eq filter_union_filter_neg_eq\n\n",
 "filter_union":
 "theorem filter_union (s₁ s₂ : Finset α) : (s₁ ∪ s₂).filter p = s₁.filter p ∪ s₂.filter p :=\n  ext fun _ => by simp only [mem_filter, mem_union, or_and_right]\n#align filter_union filter_union\n\n",
 "filter_true_of_mem":
 "/-- If all elements of a `finset` satisfy the predicate `p`, `s.filter p` is `s`. -/\n@[simp]\ntheorem filter_true_of_mem {s : Finset α} (h : ∀ x ∈ s, p x) : s.filter p = s :=\n  (filter_eq_self s).mpr h\n#align filter_true_of_mem filter_true_of_mem\n\n",
 "filter_true":
 "theorem filter_true {s : Finset α} [h : decidable_pred fun _ => true] : @Finset.filter α (fun _ => true) h s = s := by\n  ext <;> simp\n#align filter_true filter_true\n\n",
 "filter_subset_filter":
 "theorem filter_subset_filter {s t : Finset α} (h : s ⊆ t) : s.filter p ⊆ t.filter p := fun a ha =>\n  mem_filter.2 ⟨h (mem_filter.1 ha).1, (mem_filter.1 ha).2⟩\n#align filter_subset_filter filter_subset_filter\n\n",
 "filter_subset":
 "@[simp]\ntheorem filter_subset (s : Finset α) : s.filter p ⊆ s :=\n  filter_subset _ _\n#align filter_subset filter_subset\n\n",
 "filter_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem filter_ssubset {s : Finset α} : «expr ⊂ » (s.filter p) s ↔ ∃ x ∈ s, ¬p x :=\n  ⟨fun h =>\n    let ⟨x, hs, hp⟩ := Set.exists_of_ssubset h\n    ⟨x, hs, mt (fun hp => mem_filter.2 ⟨hs, hp⟩) hp⟩,\n    fun ⟨x, hs, hp⟩ => ⟨s.filter_subset _, fun h => hp (mem_filter.1 (h hs)).2⟩⟩\n#align filter_ssubset filter_ssubset\n\n",
 "filter_singleton":
 "theorem filter_singleton (a : α) : filter p (singleton a) = if p a then singleton a else ∅ := by\n  classical\n    ext x\n    simp\n    split_ifs with h <;> by_cases h' : x = a <;> simp [h, h']\n#align filter_singleton filter_singleton\n\n",
 "filter_or":
 "theorem filter_or [decidable_pred fun a => p a ∨ q a] (s : Finset α) :\n    (s.filter fun a => p a ∨ q a) = s.filter p ∪ s.filter q :=\n  ext fun _ => by simp only [mem_filter, mem_union, and_or_left]\n#align filter_or filter_or\n\n",
 "filter_not":
 "theorem filter_not [decidable_pred fun a => ¬p a] (s : Finset α) : (s.filter fun a => ¬p a) = s \\ s.filter p :=\n  ext <| by\n    simpa only [mem_filter, mem_sdiff, and_comm', not_and] using fun a =>\n      and_congr_right fun h : a ∈ s => (imp_iff_right h).symm.trans imp_not_comm\n#align filter_not filter_not\n\n",
 "filter_nonempty_iff":
 "theorem filter_nonempty_iff {s : Finset α} : (s.filter p).nonempty ↔ ∃ a ∈ s, p a := by\n  simp only [nonempty_iff_ne_empty, ne.def, filter_eq_empty_iff, not_not, not_forall]\n#align filter_nonempty_iff filter_nonempty_iff\n\n",
 "filter_ne'":
 "theorem filter_ne' [decidable_eq β] (s : Finset β) (b : β) : (s.filter fun a => a ≠ b) = s.erase b :=\n  trans (filter_congr fun _ _ => ⟨ne.symm, ne.symm⟩) (filter_ne s b)\n#align filter_ne' filter_ne'\n\n",
 "filter_ne":
 "theorem filter_ne [decidable_eq β] (s : Finset β) (b : β) : (s.filter fun a => b ≠ a) = s.erase b :=\n  by\n  ext\n  simp only [mem_filter, mem_erase, ne.def]\n  tauto\n#align filter_ne filter_ne\n\n",
 "filter_mem_eq_inter":
 "theorem filter_mem_eq_inter {s t : Finset α} [∀ i, decidable (i ∈ t)] : (s.filter fun i => i ∈ t) = s ∩ t :=\n  ext fun i => by rw [mem_filter, mem_inter]\n#align filter_mem_eq_inter filter_mem_eq_inter\n\n",
 "filter_inter_filter_neg_eq":
 "theorem filter_inter_filter_neg_eq [decidable_pred fun a => ¬p a] (s t : Finset α) :\n    (s.filter p ∩ t.filter fun a => ¬p a) = ∅ :=\n  (disjoint_filter_filter_neg s t p).eq_bot\n#align filter_inter_filter_neg_eq filter_inter_filter_neg_eq\n\n",
 "filter_inter_distrib":
 "theorem filter_inter_distrib (s t : Finset α) : (s ∩ t).filter p = s.filter p ∩ t.filter p :=\n  by\n  ext\n  simp only [mem_filter, mem_inter]\n  exact and_and_right _ _ _\n#align filter_inter_distrib filter_inter_distrib\n\n",
 "filter_inter":
 "theorem filter_inter (s t : Finset α) : filter p s ∩ t = filter p (s ∩ t) :=\n  by\n  ext\n  simp only [mem_inter, mem_filter, and_right_comm]\n#align filter_inter filter_inter\n\n",
 "filter_insert":
 "theorem filter_insert (a : α) (s : Finset α) :\n    filter p (insert a s) = if p a then insert a (filter p s) else filter p s :=\n  by\n  ext x\n  simp\n  split_ifs with h <;> by_cases h' : x = a <;> simp [h, h']\n#align filter_insert filter_insert\n\n",
 "filter_filter":
 "theorem filter_filter (s : Finset α) : (s.filter p).filter q = s.filter fun a => p a ∧ q a :=\n  ext fun a => by simp only [mem_filter, and_comm', and_left_comm]\n#align filter_filter filter_filter\n\n",
 "filter_false_of_mem":
 "/-- If all elements of a `finset` fail to satisfy the predicate `p`, `s.filter p` is `∅`. -/\ntheorem filter_false_of_mem {s : Finset α} (h : ∀ x ∈ s, ¬p x) : s.filter p = ∅ :=\n  eq_empty_of_forall_not_mem (by simpa)\n#align filter_false_of_mem filter_false_of_mem\n\n",
 "filter_false":
 "@[simp]\ntheorem filter_false {h} (s : Finset α) : @filter α (fun a => false) h s = ∅ :=\n  ext fun a => by simp only [mem_filter, and_false_iff] <;> rfl\n#align filter_false filter_false\n\n",
 "filter_erase":
 "theorem filter_erase (a : α) (s : Finset α) : filter p (erase s a) = erase (filter p s) a :=\n  by\n  ext x\n  simp only [and_assoc', mem_filter, iff_self_iff, mem_erase]\n#align filter_erase filter_erase\n\n",
 "filter_eq_self":
 "theorem filter_eq_self (s : Finset α) : s.filter p = s ↔ ∀ x ∈ s, p x := by simp [Finset.ext_iff]\n#align filter_eq_self filter_eq_self\n\n",
 "filter_eq_empty_iff":
 "theorem filter_eq_empty_iff (s : Finset α) : s.filter p = ∅ ↔ ∀ x ∈ s, ¬p x :=\n  by\n  refine' ⟨_, filter_false_of_mem⟩\n  intro hs\n  injection hs with hs'\n  rwa [filter_eq_nil] at hs'\n#align filter_eq_empty_iff filter_eq_empty_iff\n\n",
 "filter_eq'":
 "/-- After filtering out everything that does not equal a given value, at most that value remains.\n\n  This is equivalent to `filter_eq` with the equality the other way.\n-/\ntheorem filter_eq' [decidable_eq β] (s : Finset β) (b : β) : (s.filter fun a => a = b) = ite (b ∈ s) {b} ∅ :=\n  trans (filter_congr fun _ _ => ⟨eq.symm, eq.symm⟩) (filter_eq s b)\n#align filter_eq' filter_eq'\n\n",
 "filter_eq":
 "-- This is not a good simp lemma, as it would prevent `finset.mem_filter` from firing\n-- on, e.g. `x ∈ s.filter(eq b)`.\n/-- After filtering out everything that does not equal a given value, at most that value remains.\n\n  This is equivalent to `filter_eq'` with the equality the other way.\n-/\ntheorem filter_eq [decidable_eq β] (s : Finset β) (b : β) : s.filter (eq b) = ite (b ∈ s) {b} ∅ :=\n  by\n  split_ifs\n  · ext\n    simp only [mem_filter, mem_singleton]\n    exact\n      ⟨fun h => h.2.symm, by\n        rintro ⟨h⟩\n        exact ⟨h, rfl⟩⟩\n  · ext\n    simp only [mem_filter, not_and, iff_false_iff, not_mem_empty]\n    rintro m ⟨e⟩\n    exact h m\n#align filter_eq filter_eq\n\n",
 "filter_empty":
 "theorem filter_empty : filter p ∅ = ∅ :=\n  subset_empty.1 <| filter_subset _ _\n#align filter_empty filter_empty\n\n",
 "filter_disj_union":
 "theorem filter_disj_union (s : Finset α) (t : Finset α) (h : Disjoint s t) :\n    filter p (disjUnion s t h) = (filter p s).disj_union (filter p t) (disjoint_filter_filter h) :=\n  eq_of_veq <| Multiset.filter_add _ _ _\n#align filter_disj_union filter_disj_union\n\n",
 "filter_cons_of_pos":
 "theorem filter_cons_of_pos (a : α) (s : Finset α) (ha : a ∉ s) (hp : p a) :\n    filter p (cons a s ha) = cons a (filter p s) (mem_filter.not.mpr <| mt And.left ha) :=\n  eq_of_veq <| Multiset.filter_cons_of_pos s.val hp\n#align filter_cons_of_pos filter_cons_of_pos\n\n",
 "filter_cons_of_neg":
 "theorem filter_cons_of_neg (a : α) (s : Finset α) (ha : a ∉ s) (hp : ¬p a) : filter p (cons a s ha) = filter p s :=\n  eq_of_veq <| Multiset.filter_cons_of_neg s.val hp\n#align filter_cons_of_neg filter_cons_of_neg\n\n",
 "filter_cons":
 "theorem filter_cons {a : α} (s : Finset α) (ha : a ∉ s) :\n    filter p (cons a s ha) =\n      (if p a then {a} else ∅ : Finset α).disj_union (filter p s)\n        (by\n          split_ifs\n          · rw [disjoint_singleton_left]\n            exact mem_filter.not.mpr <| mt And.left ha\n          · exact disjoint_empty_left _) :=\n  by\n  split_ifs with h\n  · rw [filter_cons_of_pos _ _ _ ha h, singleton_disj_union]\n  · rw [filter_cons_of_neg _ _ _ ha h, empty_disj_union]\n#align filter_cons filter_cons\n\n",
 "filter_congr_decidable":
 "-- We can simplify an application of filter where the decidability is inferred in \"the wrong way\"\n@[simp]\ntheorem filter_congr_decidable {α} (s : Finset α) (p : α → Prop) (h : decidable_pred p) [decidable_pred p] :\n    @filter α p h s = s.filter p := by congr\n#align filter_congr_decidable filter_congr_decidable\n\n",
 "filter_congr":
 "theorem filter_congr {s : Finset α} (H : ∀ x ∈ s, p x ↔ q x) : filter p s = filter q s :=\n  eq_of_veq <| filter_congr H\n#align filter_congr filter_congr\n\n",
 "filter_bUnion":
 "theorem filter_bUnion (s : Finset α) (f : α → Finset β) (p : β → Prop) [decidable_pred p] :\n    (s.bUnion f).filter p = s.bUnion fun a => (f a).filter p :=\n  by\n  ext b\n  simp only [mem_bUnion, exists_prop, mem_filter]\n  constructor\n  · rintro ⟨⟨a, ha, hba⟩, hb⟩\n    exact ⟨a, ha, hba, hb⟩\n  · rintro ⟨a, ha, hba, hb⟩\n    exact ⟨⟨a, ha, hba⟩, hb⟩\n#align filter_bUnion filter_bUnion\n\n",
 "filter_and":
 "theorem filter_and [decidable_pred fun a => p a ∧ q a] (s : Finset α) :\n    (s.filter fun a => p a ∧ q a) = s.filter p ∩ s.filter q :=\n  ext fun _ => by simp only [mem_filter, mem_inter, and_comm', and_left_comm, and_self_iff]\n#align filter_and filter_and\n\n",
 "ext_iff":
 "theorem to_finset.ext_iff {a b : list α} : a.to_finset = b.to_finset ↔ ∀ x, x ∈ a ↔ x ∈ b := by\n  simp only [Finset.ext_iff, mem_to_finset]\n#align to_finset.ext_iff to_finset.ext_iff\n\n",
 "ext":
 "theorem to_finset.ext : (∀ x, x ∈ l ↔ x ∈ l') → l.to_finset = l'.to_finset :=\n  toFinset.ext_iff.mpr\n#align to_finset.ext to_finset.ext\n\n",
 "exists_of_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem exists_of_ssubset {s₁ s₂ : Finset α} (h : «expr ⊂ » s₁ s₂) : ∃ x ∈ s₂, x ∉ s₁ :=\n  Set.exists_of_ssubset h\n#align exists_of_ssubset exists_of_ssubset\n\n",
 "exists_mem_subset_of_finset_subset_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print DirectedOn.exists_mem_subset_of_finset_subset_bunionᵢ /-\ntheorem DirectedOn.exists_mem_subset_of_finset_subset_bunionᵢ {α ι : Type _} {f : ι → set α} {c : set ι}\n    (hn : c.nonempty) (hc : DirectedOn (fun i j => f i ⊆ f j) c) {s : Finset α}\n    (hs :\n      (s : set α) ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)) :\n    ∃ i ∈ c, (s : set α) ⊆ f i := by\n  rw [Set.bunionᵢ_eq_unionᵢ] at hs\n  haveI := hn.coe_sort\n  obtain ⟨⟨i, hic⟩, hi⟩ := (directed_comp.2 hc.directed_coe).exists_mem_subset_of_finset_subset_bUnion hs\n  exact ⟨i, hic, hi⟩\n#align directed_on.exists_mem_subset_of_finset_subset_bUnion DirectedOn.exists_mem_subset_of_finset_subset_bunionᵢ\n-/\n\n",
 "exists_mem_insert":
 "theorem exists_mem_insert [decidable_eq α] (a : α) (s : Finset α) (p : α → Prop) :\n    (∃ x, x ∈ insert a s ∧ p x) ↔ p a ∨ ∃ x, x ∈ s ∧ p x := by\n  simp only [mem_insert, or_and_right, exists_or, exists_eq_left]\n#align exists_mem_insert exists_mem_insert\n\n",
 "exists_mem_empty_iff":
 "-- useful rules for calculations with quantifiers\ntheorem exists_mem_empty_iff (p : α → Prop) : (∃ x, x ∈ (∅ : Finset α) ∧ p x) ↔ false := by\n  simp only [not_mem_empty, false_and_iff, exists_false]\n#align exists_mem_empty_iff exists_mem_empty_iff\n\n",
 "exists_list_nodup_eq":
 "theorem exists_list_nodup_eq [decidable_eq α] (s : Finset α) : ∃ l : list α, l.nodup ∧ l.to_finset = s :=\n  ⟨s.to_list, s.nodup_to_list, s.to_list_to_finset⟩\n#align exists_list_nodup_eq exists_list_nodup_eq\n\n",
 "exists_eq_singleton_or_nontrivial":
 "theorem nonempty.exists_eq_singleton_or_nontrivial : s.nonempty → (∃ a, s = {a}) ∨ (s : set α).nontrivial :=\n  fun ⟨a, ha⟩ => (eq_singleton_or_nontrivial ha).imp_left <| exists.intro a\n#align nonempty.exists_eq_singleton_or_nontrivial nonempty.exists_eq_singleton_or_nontrivial\n\n",
 "exists_coe":
 "@[simp]\nprotected theorem exists_coe {α : Type _} (s : Finset α) (p : s → Prop) :\n    (∃ x : s, p x) ↔ ∃ (x : α)(h : x ∈ s), p ⟨x, h⟩ :=\n  subtype.exists\n#align exists_coe exists_coe\n\n",
 "erase_val":
 "@[simp]\ntheorem erase_val (s : Finset α) (a : α) : (erase s a).1 = s.1.erase a :=\n  rfl\n#align erase_val erase_val\n\n",
 "erase_subset_iff_of_mem":
 "theorem erase_subset_iff_of_mem (h : a ∈ t) : s.erase a ⊆ t ↔ s ⊆ t := by rw [← subset_insert_iff, insert_eq_of_mem h]\n#align erase_subset_iff_of_mem erase_subset_iff_of_mem\n\n",
 "erase_subset_erase":
 "theorem erase_subset_erase (a : α) {s t : Finset α} (h : s ⊆ t) : erase s a ⊆ erase t a :=\n  val_le_iff.1 <| erase_le_erase _ <| val_le_iff.2 h\n#align erase_subset_erase erase_subset_erase\n\n",
 "erase_subset":
 "theorem erase_subset (a : α) (s : Finset α) : erase s a ⊆ s :=\n  erase_subset _ _\n#align erase_subset erase_subset\n\n",
 "erase_ssubset_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem erase_ssubset_insert (s : Finset α) (a : α) : «expr ⊂ » (s.erase a) (insert a s) :=\n  ssubset_iff_exists_subset_erase.2 ⟨a, mem_insert_self _ _, erase_subset_erase _ <| subset_insert _ _⟩\n#align erase_ssubset_insert erase_ssubset_insert\n\n",
 "erase_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem erase_ssubset {a : α} {s : Finset α} (h : a ∈ s) : «expr ⊂ » (s.erase a) s :=\n  calc\n    «expr ⊂ » (s.erase a) (insert a (s.erase a)) := ssubset_insert <| not_mem_erase _ _\n    _ = _ := insert_erase h\n    \n#align erase_ssubset erase_ssubset\n\n",
 "erase_singleton":
 "@[simp]\ntheorem erase_singleton (a : α) : ({a} : Finset α).erase a = ∅ :=\n  by\n  ext x\n  rw [mem_erase, mem_singleton, not_and_self_iff]\n  rfl\n#align erase_singleton erase_singleton\n\n",
 "erase_right_comm":
 "theorem erase_right_comm {a b : α} {s : Finset α} : erase (erase s a) b = erase (erase s b) a :=\n  by\n  ext x\n  simp only [mem_erase, ← and_assoc']\n  rw [and_comm' (x ≠ a)]\n#align erase_right_comm erase_right_comm\n\n",
 "erase_ne_self":
 "theorem erase_ne_self : s.erase a ≠ s ↔ a ∈ s :=\n  erase_eq_self.not_left\n#align erase_ne_self erase_ne_self\n\n",
 "erase_insert_subset":
 "theorem erase_insert_subset (a : α) (s : Finset α) : erase (insert a s) a ⊆ s :=\n  subset_insert_iff.1 <| subset.rfl\n#align erase_insert_subset erase_insert_subset\n\n",
 "erase_insert_of_ne":
 "theorem erase_insert_of_ne {a b : α} {s : Finset α} (h : a ≠ b) : erase (insert a s) b = insert a (erase s b) :=\n  ext fun x => by\n    have : x ≠ b ∧ x = a ↔ x = a := and_iff_right_of_imp fun hx => hx.symm ▸ h\n    simp only [mem_erase, mem_insert, and_or_left, this]\n#align erase_insert_of_ne erase_insert_of_ne\n\n",
 "erase_insert_eq_erase":
 "@[simp]\ntheorem erase_insert_eq_erase (s : Finset α) (a : α) : (insert a s).erase a = s.erase a :=\n  ext fun x => by\n    simp (config := { contextual := true }) only [mem_erase, mem_insert, and_congr_right_iff, false_or_iff,\n      iff_self_iff, imp_true_iff]\n#align erase_insert_eq_erase erase_insert_eq_erase\n\n",
 "erase_insert":
 "theorem erase_insert {a : α} {s : Finset α} (h : a ∉ s) : erase (insert a s) a = s := by\n  rw [erase_insert_eq_erase, erase_eq_of_not_mem h]\n#align erase_insert erase_insert\n\n",
 "erase_inj_on'":
 "theorem erase_inj_on' (a : α) : { s : Finset α | a ∈ s }.inj_on fun s => erase s a :=\n  fun s hs t ht (h : s.erase a = _) => by rw [← insert_erase hs, ← insert_erase ht, h]\n#align erase_inj_on' erase_inj_on'\n\n",
 "erase_inj_on":
 "theorem erase_inj_on (s : Finset α) : Set.InjOn s.erase s := fun _ _ _ _ => (erase_inj s ‹_›).mp\n#align erase_inj_on erase_inj_on\n\n",
 "erase_inj":
 "theorem erase_inj {x y : α} (s : Finset α) (hx : x ∈ s) : s.erase x = s.erase y ↔ x = y :=\n  by\n  refine' ⟨fun h => _, congr_arg _⟩\n  rw [eq_of_mem_of_not_mem_erase hx]\n  rw [← h]\n  simp\n#align erase_inj erase_inj\n\n",
 "erase_idem":
 "theorem erase_idem {a : α} {s : Finset α} : erase (erase s a) a = erase s a := by simp\n#align erase_idem erase_idem\n\n",
 "erase_eq_self":
 "@[simp]\ntheorem erase_eq_self : s.erase a = s ↔ a ∉ s :=\n  ⟨fun h => h ▸ not_mem_erase _ _, erase_eq_of_not_mem⟩\n#align erase_eq_self erase_eq_self\n\n",
 "erase_eq_of_not_mem":
 "@[simp]\ntheorem erase_eq_of_not_mem {a : α} {s : Finset α} (h : a ∉ s) : erase s a = s :=\n  eq_of_veq <| erase_of_not_mem h\n#align erase_eq_of_not_mem erase_eq_of_not_mem\n\n",
 "erase_eq_empty_iff":
 "theorem erase_eq_empty_iff (s : Finset α) (a : α) : s.erase a = ∅ ↔ s = ∅ ∨ s = {a} := by\n  rw [← sdiff_singleton_eq_erase, sdiff_eq_empty_iff_subset, subset_singleton_iff]\n#align erase_eq_empty_iff erase_eq_empty_iff\n\n",
 "erase_empty":
 "-- While this can be solved by `simp`, this lemma is eligible for `dsimp`\n@[nolint simp_nf, simp]\ntheorem erase_empty (a : α) : erase ∅ a = ∅ :=\n  rfl\n#align erase_empty erase_empty\n\n",
 "erase_cons_of_ne":
 "theorem erase_cons_of_ne {a b : α} {s : Finset α} (ha : a ∉ s) (hb : a ≠ b) :\n    erase (cons a s ha) b = cons a (erase s b) fun h => ha <| erase_subset _ _ h := by\n  simp only [cons_eq_insert, erase_insert_of_ne hb]\n#align erase_cons_of_ne erase_cons_of_ne\n\n",
 "erase_cons":
 "theorem erase_cons {s : Finset α} {a : α} (h : a ∉ s) : (s.cons a h).erase a = s := by\n  rw [cons_eq_insert, erase_insert_eq_erase, erase_eq_of_not_mem h]\n#align erase_cons erase_cons\n\n",
 "erase_bUnion":
 "theorem erase_bUnion (f : α → Finset β) (s : Finset α) (b : β) :\n    (s.bUnion f).erase b = s.bUnion fun x => (f x).erase b :=\n  by\n  ext\n  simp only [Finset.mem_bunionᵢ, iff_self_iff, exists_and_left, Finset.mem_erase]\n#align erase_bUnion erase_bUnion\n\n",
 "eq_singleton_or_nontrivial":
 "theorem eq_singleton_or_nontrivial (ha : a ∈ s) : s = {a} ∨ (s : set α).nontrivial :=\n  by\n  rw [← coe_eq_singleton]\n  exact Set.eq_singleton_or_nontrivial ha\n#align eq_singleton_or_nontrivial eq_singleton_or_nontrivial\n\n",
 "eq_singleton_iff_unique_mem":
 "theorem eq_singleton_iff_unique_mem {s : Finset α} {a : α} : s = {a} ↔ a ∈ s ∧ ∀ x ∈ s, x = a :=\n  by\n  constructor <;> intro t\n  rw [t]\n  refine' ⟨Finset.mem_singleton_self _, fun _ => Finset.mem_singleton.1⟩\n  ext; rw [Finset.mem_singleton]\n  refine' ⟨t.right _, fun r => r.symm ▸ t.left⟩\n#align eq_singleton_iff_unique_mem eq_singleton_iff_unique_mem\n\n",
 "eq_singleton_iff_nonempty_unique_mem":
 "theorem eq_singleton_iff_nonempty_unique_mem {s : Finset α} {a : α} : s = {a} ↔ s.nonempty ∧ ∀ x ∈ s, x = a :=\n  by\n  constructor\n  · rintro rfl\n    simp\n  · rintro ⟨hne, h_uniq⟩\n    rw [eq_singleton_iff_unique_mem]\n    refine' ⟨_, h_uniq⟩\n    rw [← h_uniq hne.some hne.some_spec]\n    exact hne.some_spec\n#align eq_singleton_iff_nonempty_unique_mem eq_singleton_iff_nonempty_unique_mem\n\n",
 "eq_of_veq":
 "/-\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura, Jeremy Avigad, Minchao Wu, Mario Carneiro\n-/\ntheorem eq_of_veq : ∀ {s t : Finset α}, s.1 = t.1 → s = t\n  | ⟨s, _⟩, ⟨t, _⟩, rfl => rfl\n#align eq_of_veq eq_of_veq\n\n",
 "eq_of_not_mem_of_mem_insert":
 "theorem eq_of_not_mem_of_mem_insert (ha : b ∈ insert a s) (hb : b ∉ s) : b = a :=\n  (mem_insert.1 ha).resolve_right hb\n#align eq_of_not_mem_of_mem_insert eq_of_not_mem_of_mem_insert\n\n",
 "eq_of_mem_singleton":
 "theorem eq_of_mem_singleton {x y : α} (h : x ∈ ({y} : Finset α)) : x = y :=\n  mem_singleton.1 h\n#align eq_of_mem_singleton eq_of_mem_singleton\n\n",
 "eq_of_mem_of_not_mem_erase":
 "/-- An element of `s` that is not an element of `erase s a` must be\n`a`. -/\ntheorem eq_of_mem_of_not_mem_erase (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a :=\n  by\n  rw [mem_erase, not_and] at hsa\n  exact not_imp_not.mp hsa hs\n#align eq_of_mem_of_not_mem_erase eq_of_mem_of_not_mem_erase\n\n",
 "eq_empty_or_nonempty":
 "theorem eq_empty_or_nonempty (s : Finset α) : s = ∅ ∨ s.nonempty :=\n  by_cases or.inl fun h => or.inr (nonempty_of_ne_empty h)\n#align eq_empty_or_nonempty eq_empty_or_nonempty\n\n",
 "eq_empty_of_ssubset_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem eq_empty_of_ssubset_singleton {s : Finset α} {x : α} (hs : «expr ⊂ » s {x}) : s = ∅ :=\n  ssubset_singleton_iff.1 hs\n#align eq_empty_of_ssubset_singleton eq_empty_of_ssubset_singleton\n\n",
 "eq_empty_of_is_empty":
 "/-- A `finset` for an empty type is empty. -/\ntheorem eq_empty_of_is_empty [is_empty α] (s : Finset α) : s = ∅ :=\n  Finset.eq_empty_of_forall_not_mem is_empty_elim\n#align eq_empty_of_is_empty eq_empty_of_is_empty\n\n",
 "eq_empty_of_forall_not_mem":
 "theorem eq_empty_of_forall_not_mem {s : Finset α} (H : ∀ x, x ∉ s) : s = ∅ :=\n  eq_of_veq (eq_zero_of_forall_not_mem H)\n#align eq_empty_of_forall_not_mem eq_empty_of_forall_not_mem\n\n",
 "eq_empty_iff_forall_not_mem":
 "theorem eq_empty_iff_forall_not_mem {s : Finset α} : s = ∅ ↔ ∀ x, x ∉ s :=\n  ⟨by rintro rfl x <;> exact id, fun h => eq_empty_of_forall_not_mem h⟩\n#align eq_empty_iff_forall_not_mem eq_empty_iff_forall_not_mem\n\n",
 "empty_val":
 "@[simp]\ntheorem empty_val : (∅ : Finset α).1 = 0 :=\n  rfl\n#align empty_val empty_val\n\n",
 "empty_union":
 "@[simp]\ntheorem empty_union (s : Finset α) : ∅ ∪ s = s :=\n  ext fun x => mem_union.trans <| false_or_iff _\n#align empty_union empty_union\n\n",
 "empty_to_list":
 "@[simp]\ntheorem empty_to_list {s : Finset α} : s.to_list.empty ↔ s = ∅ :=\n  List.isEmpty_iff_eq_nil.trans toList_eq_nil\n#align empty_to_list empty_to_list\n\n",
 "empty_subset":
 "@[simp]\ntheorem empty_subset (s : Finset α) : ∅ ⊆ s :=\n  zero_subset _\n#align empty_subset empty_subset\n\n",
 "empty_ssubset_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem empty_ssubset_singleton : «expr ⊂ » (∅ : Finset α) {a} :=\n  (singleton_nonempty _).empty_ssubset\n#align empty_ssubset_singleton empty_ssubset_singleton\n\n",
 "empty_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem empty_ssubset : «expr ⊂ » ∅ s ↔ s.nonempty :=\n  (@bot_lt_iff_ne_bot (Finset α) _ _ _).trans nonempty_iff_ne_empty.symm\n#align empty_ssubset empty_ssubset\n\n",
 "empty_sdiff":
 "@[simp]\ntheorem empty_sdiff (s : Finset α) : ∅ \\ s = ∅ :=\n  bot_sdiff\n#align empty_sdiff empty_sdiff\n\n",
 "empty_inter":
 "@[simp]\ntheorem empty_inter (s : Finset α) : ∅ ∩ s = ∅ :=\n  ext fun _ => mem_inter.trans <| false_and_iff _\n#align empty_inter empty_inter\n\n",
 "empty_disj_union":
 "@[simp]\ntheorem empty_disj_union (t : Finset α) (h : Disjoint ∅ t := disjoint_bot_left) : disjUnion ∅ t h = t :=\n  eq_of_veq <| zero_add _\n#align empty_disj_union empty_disj_union\n\n",
 "disjoint_val":
 "@[simp]\ntheorem disjoint_val : s.1.disjoint t.1 ↔ Disjoint s t :=\n  disjoint_left.symm\n#align disjoint_val disjoint_val\n\n",
 "disjoint_union_right":
 "@[simp]\ntheorem disjoint_union_right : Disjoint s (t ∪ u) ↔ Disjoint s t ∧ Disjoint s u := by\n  simp only [disjoint_right, mem_union, or_imp, forall_and]\n#align disjoint_union_right disjoint_union_right\n\n",
 "disjoint_union_left":
 "@[simp]\ntheorem disjoint_union_left : Disjoint (s ∪ t) u ↔ Disjoint s u ∧ Disjoint t u := by\n  simp only [disjoint_left, mem_union, or_imp, forall_and]\n#align disjoint_union_left disjoint_union_left\n\n",
 "disjoint_to_finset_iff_disjoint":
 "theorem disjoint_to_finset_iff_disjoint : Disjoint l.to_finset l'.to_finset ↔ l.disjoint l' :=\n  Multiset.disjoint_toFinset\n#align disjoint_to_finset_iff_disjoint disjoint_to_finset_iff_disjoint\n\n",
 "disjoint_to_finset":
 "theorem disjoint_to_finset {m1 m2 : Multiset α} : Disjoint m1.to_finset m2.to_finset ↔ m1.disjoint m2 :=\n  by\n  rw [Finset.disjoint_iff_ne]\n  refine' ⟨fun h a ha1 ha2 => _, _⟩\n  · rw [← Multiset.mem_toFinset] at ha1 ha2\n    exact h _ ha1 _ ha2 rfl\n  · rintro h a ha b hb rfl\n    rw [Multiset.mem_toFinset] at ha hb\n    exact h ha hb\n#align disjoint_to_finset disjoint_to_finset\n\n",
 "disjoint_singleton_right":
 "@[simp]\ntheorem disjoint_singleton_right : Disjoint s (singleton a) ↔ a ∉ s :=\n  disjoint_comm.trans disjoint_singleton_left\n#align disjoint_singleton_right disjoint_singleton_right\n\n",
 "disjoint_singleton_left":
 "@[simp]\ntheorem disjoint_singleton_left : Disjoint (singleton a) s ↔ a ∉ s := by\n  simp only [disjoint_left, mem_singleton, forall_eq]\n#align disjoint_singleton_left disjoint_singleton_left\n\n",
 "disjoint_singleton":
 "@[simp]\ntheorem disjoint_singleton : Disjoint ({a} : Finset α) {b} ↔ a ≠ b := by rw [disjoint_singleton_left, mem_singleton]\n#align disjoint_singleton disjoint_singleton\n\n",
 "disjoint_self_iff_empty":
 "theorem disjoint_self_iff_empty (s : Finset α) : Disjoint s s ↔ s = ∅ :=\n  disjoint_self\n#align disjoint_self_iff_empty disjoint_self_iff_empty\n\n",
 "disjoint_sdiff_inter":
 "theorem disjoint_sdiff_inter (s t : Finset α) : Disjoint (s \\ t) (s ∩ t) :=\n  disjoint_of_subset_right (inter_subset_right _ _) sdiff_disjoint\n#align disjoint_sdiff_inter disjoint_sdiff_inter\n\n",
 "disjoint_sdiff":
 "theorem disjoint_sdiff : Disjoint s (t \\ s) :=\n  sdiff_disjoint.symm\n#align disjoint_sdiff disjoint_sdiff\n\n",
 "disjoint_right":
 "theorem disjoint_right : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ t → a ∉ s := by rw [disjoint_comm, disjoint_left]\n#align disjoint_right disjoint_right\n\n",
 "disjoint_or_nonempty_inter":
 "theorem disjoint_or_nonempty_inter (s t : Finset α) : Disjoint s t ∨ (s ∩ t).nonempty :=\n  by\n  rw [← not_disjoint_iff_nonempty_inter]\n  exact em _\n#align disjoint_or_nonempty_inter disjoint_or_nonempty_inter\n\n",
 "disjoint_of_subset_right":
 "theorem disjoint_of_subset_right (h : t ⊆ u) (d : Disjoint s u) : Disjoint s t :=\n  disjoint_right.2 fun x m₁ => (disjoint_right.1 d) (h m₁)\n#align disjoint_of_subset_right disjoint_of_subset_right\n\n",
 "disjoint_of_subset_left":
 "theorem disjoint_of_subset_left (h : s ⊆ u) (d : Disjoint u t) : Disjoint s t :=\n  disjoint_left.2 fun x m₁ => (disjoint_left.1 d) (h m₁)\n#align disjoint_of_subset_left disjoint_of_subset_left\n\n",
 "disjoint_left":
 "theorem disjoint_left : Disjoint s t ↔ ∀ ⦃a⦄, a ∈ s → a ∉ t :=\n  ⟨fun h a hs ht => singleton_subset_iff.mp (h (singleton_subset_iff.mpr hs) (singleton_subset_iff.mpr ht)),\n    fun h x hs ht a ha => h (hs ha) (ht ha)⟩\n#align disjoint_left disjoint_left\n\n",
 "disjoint_insert_right":
 "@[simp]\ntheorem disjoint_insert_right : Disjoint s (insert a t) ↔ a ∉ s ∧ Disjoint s t :=\n  disjoint_comm.trans <| by rw [disjoint_insert_left, disjoint_comm]\n#align disjoint_insert_right disjoint_insert_right\n\n",
 "disjoint_insert_left":
 "@[simp]\ntheorem disjoint_insert_left : Disjoint (insert a s) t ↔ a ∉ t ∧ Disjoint s t := by\n  simp only [disjoint_left, mem_insert, or_imp, forall_and, forall_eq]\n#align disjoint_insert_left disjoint_insert_left\n\n",
 "disjoint_iff_ne":
 "theorem disjoint_iff_ne : Disjoint s t ↔ ∀ a ∈ s, ∀ b ∈ t, a ≠ b := by\n  simp only [disjoint_left, imp_not_comm, forall_eq']\n#align disjoint_iff_ne disjoint_iff_ne\n\n",
 "disjoint_iff_inter_eq_empty":
 "theorem disjoint_iff_inter_eq_empty : Disjoint s t ↔ s ∩ t = ∅ :=\n  disjoint_iff\n#align disjoint_iff_inter_eq_empty disjoint_iff_inter_eq_empty\n\n",
 "disjoint_filter_filter_neg":
 "theorem disjoint_filter_filter_neg (s t : Finset α) (p : α → Prop) [decidable_pred p] [decidable_pred fun a => ¬p a] :\n    Disjoint (s.filter p) (t.filter fun a => ¬p a) :=\n  disjoint_filter_filter' s t disjoint_compl_right\n#align disjoint_filter_filter_neg disjoint_filter_filter_neg\n\n",
 "disjoint_filter_filter'":
 "theorem disjoint_filter_filter' (s t : Finset α) {p q : α → Prop} [decidable_pred p] [decidable_pred q]\n    (h : Disjoint p q) : Disjoint (s.filter p) (t.filter q) :=\n  by\n  simp_rw [disjoint_left, mem_filter]\n  rintro a ⟨hs, hp⟩ ⟨ht, hq⟩\n  exact h.le_bot _ ⟨hp, hq⟩\n#align disjoint_filter_filter' disjoint_filter_filter'\n\n",
 "disjoint_filter_filter":
 "theorem disjoint_filter_filter {s t : Finset α} {p q : α → Prop} [decidable_pred p] [decidable_pred q] :\n    Disjoint s t → Disjoint (s.filter p) (t.filter q) :=\n  Disjoint.mono (filter_subset _ _) (filter_subset _ _)\n#align disjoint_filter_filter disjoint_filter_filter\n\n",
 "disjoint_filter":
 "theorem disjoint_filter {s : Finset α} {p q : α → Prop} [decidable_pred p] [decidable_pred q] :\n    Disjoint (s.filter p) (s.filter q) ↔ ∀ x ∈ s, p x → ¬q x := by\n  constructor <;> simp (config := { contextual := true }) [disjoint_left]\n#align disjoint_filter disjoint_filter\n\n",
 "disjoint_empty_right":
 "@[simp]\ntheorem disjoint_empty_right (s : Finset α) : Disjoint s ∅ :=\n  disjoint_bot_right\n#align disjoint_empty_right disjoint_empty_right\n\n",
 "disjoint_empty_left":
 "@[simp]\ntheorem disjoint_empty_left (s : Finset α) : Disjoint ∅ s :=\n  disjoint_bot_left\n#align disjoint_empty_left disjoint_empty_left\n\n",
 "disjoint_coe":
 "@[simp, norm_cast]\ntheorem disjoint_coe : Disjoint (s : set α) t ↔ Disjoint s t :=\n  by\n  rw [Finset.disjoint_left, Set.disjoint_left]\n  rfl\n#align disjoint_coe disjoint_coe\n\n",
 "disjoint_bUnion_right":
 "theorem disjoint_bUnion_right (s : Finset β) (t : Finset α) (f : α → Finset β) :\n    Disjoint s (t.bUnion f) ↔ ∀ i ∈ t, Disjoint s (f i) := by\n  simpa only [disjoint_comm] using disjoint_bUnion_left t f s\n#align disjoint_bUnion_right disjoint_bUnion_right\n\n",
 "disjoint_bUnion_left":
 "theorem disjoint_bUnion_left (s : Finset α) (f : α → Finset β) (t : Finset β) :\n    Disjoint (s.bUnion f) t ↔ ∀ i ∈ s, Disjoint (f i) t := by\n  classical\n    refine' s.induction _ _\n    · simp only [forall_mem_empty_iff, bUnion_empty, disjoint_empty_left]\n    · intro i s his ih\n      simp only [disjoint_union_left, bUnion_insert, his, forall_mem_insert, ih]\n#align disjoint_bUnion_left disjoint_bUnion_left\n\n",
 "disj_union_singleton":
 "theorem disj_union_singleton (s : Finset α) (a : α) (h : Disjoint s {a}) :\n    disjUnion s {a} h = cons a s (disjoint_singleton_right.mp h) := by rw [disj_union_comm, singleton_disj_union]\n#align disj_union_singleton disj_union_singleton\n\n",
 "disj_union_eq_union":
 "@[simp]\ntheorem disj_union_eq_union (s t h) : @disjUnion α s t h = s ∪ t :=\n  ext fun a => by simp\n#align disj_union_eq_union disj_union_eq_union\n\n",
 "disj_union_empty":
 "@[simp]\ntheorem disj_union_empty (s : Finset α) (h : Disjoint s ∅ := disjoint_bot_right) : disjUnion s ∅ h = s :=\n  eq_of_veq <| add_zero _\n#align disj_union_empty disj_union_empty\n\n",
 "disj_union_comm":
 "theorem disj_union_comm (s t : Finset α) (h : Disjoint s t) : disjUnion s t h = disjUnion t s h.symm :=\n  eq_of_veq <| add_comm _ _\n#align disj_union_comm disj_union_comm\n\n",
 "disj_Union_val":
 "@[simp]\ntheorem disj_Union_val (s : Finset α) (t : α → Finset β) (h) : (s.disj_Union t h).1 = s.1.bind fun a => (t a).1 :=\n  rfl\n#align disj_Union_val disj_Union_val\n\n",
 "disj_Union_filter_eq_of_maps_to":
 "theorem disj_Union_filter_eq_of_maps_to [decidable_eq β] {s : Finset α} {t : Finset β} {f : α → β}\n    (h : ∀ x ∈ s, f x ∈ t) :\n    (t.disj_Union (fun a => s.filter fun c => f c = a) fun x' hx y' hy hne =>\n        disjoint_filter_filter' _ _\n          (by\n            simp_rw [Pi.disjoint_iff, Prop.disjoint_iff]\n            rintro i ⟨rfl, rfl⟩\n            exact hne rfl)) =\n      s :=\n  ext fun b => by simpa using h b\n#align disj_Union_filter_eq_of_maps_to disj_Union_filter_eq_of_maps_to\n\n",
 "disj_Union_eq_bUnion":
 "@[simp]\ntheorem disj_Union_eq_bUnion (s : Finset α) (f : α → Finset β) (hf) : s.disj_Union f hf = s.bUnion f :=\n  by\n  dsimp [disj_Union, Finset.bunionᵢ, function.comp]\n  generalize_proofs h\n  exact eq_of_veq h.dedup.symm\n#align disj_Union_eq_bUnion disj_Union_eq_bUnion\n\n",
 "disj_Union_empty":
 "@[simp]\ntheorem disj_Union_empty (t : α → Finset β) : disjUnion ∅ t (by simp) = ∅ :=\n  rfl\n#align disj_Union_empty disj_Union_empty\n\n",
 "disj_Union_disj_Union":
 "theorem disj_Union_disj_Union (s : Finset α) (f : α → Finset β) (g : β → Finset γ) (h1 h2) :\n    (s.disj_Union f h1).disj_Union g h2 =\n      s.attach.disj_Union\n        (fun a =>\n          (f a).disj_Union g fun b hb c hc =>\n            h2 (mem_disjUnionᵢ.mpr ⟨_, a.prop, hb⟩) (mem_disjUnionᵢ.mpr ⟨_, a.prop, hc⟩))\n        fun a ha b hb hab =>\n        disjoint_left.mpr fun x hxa hxb =>\n          by\n          obtain ⟨xa, hfa, hga⟩ := mem_disj_Union.mp hxa\n          obtain ⟨xb, hfb, hgb⟩ := mem_disj_Union.mp hxb\n          refine'\n            disjoint_left.mp (h2 (mem_disj_Union.mpr ⟨_, a.prop, hfa⟩) (mem_disj_Union.mpr ⟨_, b.prop, hfb⟩) _) hga hgb\n          rintro rfl\n          exact disjoint_left.mp (h1 a.prop b.prop <| subtype.coe_injective.ne hab) hfa hfb :=\n  eq_of_veq <| Multiset.bind_assoc.trans (Multiset.attach_bind_coe _ _).symm\n#align disj_Union_disj_Union disj_Union_disj_Union\n\n",
 "disj_Union_cons":
 "@[simp]\ntheorem disj_Union_cons (a : α) (s : Finset α) (ha : a ∉ s) (f : α → Finset β) (H) :\n    disjUnion (cons a s ha) f H =\n      (f a).disj_union (s.disj_Union f fun b hb c hc => H (mem_cons_of_mem hb) (mem_cons_of_mem hc))\n        (disjoint_left.mpr fun b hb h =>\n          let ⟨c, hc, h⟩ := mem_disjUnionᵢ.mp h\n          disjoint_left.mp (H (mem_cons_self a s) (mem_cons_of_mem hc) (ne_of_mem_of_not_mem hc ha).symm) hb h) :=\n  eq_of_veq <| Multiset.cons_bind _ _ _\n#align disj_Union_cons disj_Union_cons\n\n",
 "dedup_eq_self":
 "@[simp]\ntheorem dedup_eq_self [decidable_eq α] (s : Finset α) : dedup s.1 = s.1 :=\n  s.2.dedup\n#align dedup_eq_self dedup_eq_self\n\n",
 "cons_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_val (h : a ∉ s) : (cons a s h).1 = «expr ::ₘ » a s.1 :=\n  rfl\n#align cons_val cons_val\n\n",
 "cons_subset_cons":
 "@[simp]\ntheorem cons_subset_cons {hs ht} : s.cons a hs ⊆ t.cons a ht ↔ s ⊆ t := by\n  rwa [← coe_subset, coe_cons, coe_cons, Set.insert_subset_insert_iff, coe_subset]\n#align cons_subset_cons cons_subset_cons\n\n",
 "cons_subset":
 "theorem cons_subset {h : a ∉ s} : s.cons a h ⊆ t ↔ a ∈ t ∧ s ⊆ t :=\n  cons_subset\n#align cons_subset cons_subset\n\n",
 "cons_induction_on":
 "@[elab_as_elim]\ntheorem cons_induction_on {α : Type _} {p : Finset α → Prop} (s : Finset α) (h₁ : p ∅)\n    (h₂ : ∀ ⦃a : α⦄ {s : Finset α} (h : a ∉ s), p s → p (cons a s h)) : p s :=\n  cons_induction h₁ h₂ s\n#align cons_induction_on cons_induction_on\n\n",
 "cons_induction":
 "/-- To prove a proposition about a nonempty `s : finset α`, it suffices to show it holds for all\nsingletons and that if it holds for nonempty `t : finset α`, then it also holds for the `finset`\nobtained by inserting an element in `t`. -/\n@[elab_as_elim]\ntheorem nonempty.cons_induction {α : Type _} {p : ∀ s : Finset α, s.nonempty → Prop}\n    (h₀ : ∀ a, p {a} (singleton_nonempty _))\n    (h₁ : ∀ ⦃a⦄ (s) (h : a ∉ s) (hs), p s hs → p (Finset.cons a s h) (nonempty_cons h)) {s : Finset α}\n    (hs : s.nonempty) : p s hs :=\n  by\n  induction' s using Finset.cons_induction with a t ha h\n  · exact (not_nonempty_empty hs).elim\n  obtain rfl | ht := t.eq_empty_or_nonempty\n  · exact h₀ a\n  · exact h₁ t ha ht (h ht)\n#align nonempty.cons_induction nonempty.cons_induction\n\n",
 "cons_eq_insert":
 "@[simp]\ntheorem cons_eq_insert (a s h) : @cons α a s h = insert a s :=\n  ext fun a => by simp\n#align cons_eq_insert cons_eq_insert\n\n",
 "comm":
 "theorem insert.comm (a b : α) (s : Finset α) : insert a (insert b s) = insert b (insert a s) :=\n  ext fun x => by simp only [mem_insert, or_left_comm]\n#align insert.comm insert.comm\n\n",
 "coe_union":
 "@[simp, norm_cast]\ntheorem coe_union (s₁ s₂ : Finset α) : ↑(s₁ ∪ s₂) = (s₁ ∪ s₂ : set α) :=\n  Set.ext fun x => mem_union\n#align coe_union coe_union\n\n",
 "coe_to_list":
 "@[simp, norm_cast]\ntheorem coe_to_list (s : Finset α) : (s.to_list : Multiset α) = s.val :=\n  s.val.coe_to_list\n#align coe_to_list coe_to_list\n\n",
 "coe_to_finset":
 "@[simp, norm_cast]\ntheorem coe_to_finset (l : list α) : (l.to_finset : set α) = { a | a ∈ l } :=\n  Set.ext fun _ => List.mem_toFinset\n#align coe_to_finset coe_to_finset\n\n",
 "coe_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n@[simp, norm_cast]\ntheorem coe_symm_diff : (↑(«expr ∆ » s t) : set α) = «expr ∆ » s t :=\n  Set.ext fun _ => mem_symmDiff\n#align coe_symm_diff coe_symm_diff\n\n",
 "coe_subset":
 "@[simp, norm_cast]\ntheorem coe_subset {s₁ s₂ : Finset α} : (s₁ : set α) ⊆ s₂ ↔ s₁ ⊆ s₂ :=\n  iff.rfl\n#align coe_subset coe_subset\n\n",
 "coe_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp, norm_cast]\ntheorem coe_ssubset {s₁ s₂ : Finset α} : «expr ⊂ » (s₁ : set α) s₂ ↔ «expr ⊂ » s₁ s₂ :=\n  show «expr ⊂ » (s₁ : set α) s₂ ↔ s₁ ⊆ s₂ ∧ ¬s₂ ⊆ s₁ by simp only [Set.ssubset_def, Finset.coe_subset]\n#align coe_ssubset coe_ssubset\n\n",
 "coe_sort_coe":
 "@[simp, norm_cast]\ntheorem coe_sort_coe (s : Finset α) : ((s : set α) : Sort _) = s :=\n  rfl\n#align coe_sort_coe coe_sort_coe\n\n",
 "coe_singleton":
 "@[simp, norm_cast]\ntheorem coe_singleton (a : α) : (({a} : Finset α) : set α) = {a} :=\n  by\n  ext\n  simp\n#align coe_singleton coe_singleton\n\n",
 "coe_sdiff":
 "@[simp, norm_cast]\ntheorem coe_sdiff (s₁ s₂ : Finset α) : ↑(s₁ \\ s₂) = (s₁ \\ s₂ : set α) :=\n  Set.ext fun _ => mem_sdiff\n#align coe_sdiff coe_sdiff\n\n",
 "coe_range":
 "@[simp, norm_cast]\ntheorem coe_range (n : ℕ) : (range n : set ℕ) = Set.Iio n :=\n  Set.ext fun _ => mem_range\n#align coe_range coe_range\n\n",
 "coe_pair":
 "@[simp, norm_cast]\ntheorem coe_pair {a b : α} : (({a, b} : Finset α) : set α) = {a, b} :=\n  by\n  ext\n  simp\n#align coe_pair coe_pair\n\n",
 "coe_notMemRangeEquiv_symm":
 "#print coe_notMemRangeEquiv_symm /-\n@[simp]\ntheorem coe_notMemRangeEquiv_symm (k : ℕ) :\n    ((notMemRangeEquiv k).symm : ℕ → { n // n ∉ range k }) = fun j => ⟨j + k, by simp⟩ :=\n  rfl\n#align coe_not_mem_range_equiv_symm coe_notMemRangeEquiv_symm\n-/\n\n",
 "coe_notMemRangeEquiv":
 "#print coe_notMemRangeEquiv /-\n@[simp]\ntheorem coe_notMemRangeEquiv (k : ℕ) : (notMemRangeEquiv k : { n // n ∉ range k } → ℕ) = fun i => i - k :=\n  rfl\n#align coe_not_mem_range_equiv coe_notMemRangeEquiv\n-/\n\n",
 "coe_nonempty":
 "@[simp, norm_cast]\ntheorem coe_nonempty {s : Finset α} : (s : set α).nonempty ↔ s.nonempty :=\n  iff.rfl\n#align coe_nonempty coe_nonempty\n\n",
 "coe_mem":
 "@[simp]\ntheorem coe_mem {s : Finset α} (x : (s : set α)) : ↑x ∈ s :=\n  x.2\n#align coe_mem coe_mem\n\n",
 "coe_inter":
 "@[simp, norm_cast]\ntheorem coe_inter (s₁ s₂ : Finset α) : ↑(s₁ ∩ s₂) = (s₁ ∩ s₂ : set α) :=\n  Set.ext fun _ => mem_inter\n#align coe_inter coe_inter\n\n",
 "coe_insert":
 "@[simp, norm_cast]\ntheorem coe_insert (a : α) (s : Finset α) : ↑(insert a s) = (insert a s : set α) :=\n  Set.ext fun x => by simp only [mem_coe, mem_insert, Set.mem_insert_iff]\n#align coe_insert coe_insert\n\n",
 "coe_injective":
 "theorem coe_injective {α} : injective (coe : Finset α → set α) := fun s t => coe_inj.1\n#align coe_injective coe_injective\n\n",
 "coe_inj":
 "@[simp, norm_cast]\ntheorem coe_inj {s₁ s₂ : Finset α} : (s₁ : set α) = s₂ ↔ s₁ = s₂ :=\n  Set.ext_iff.trans ext_iff.symm\n#align coe_inj coe_inj\n\n",
 "coe_filter":
 "@[simp, norm_cast]\ntheorem coe_filter (s : Finset α) : ↑(s.filter p) = ({ x ∈ ↑s | p x } : set α) :=\n  Set.ext fun _ => mem_filter\n#align coe_filter coe_filter\n\n",
 "coe_erase":
 "@[simp, norm_cast]\ntheorem coe_erase (a : α) (s : Finset α) : ↑(erase s a) = (s \\ {a} : set α) :=\n  Set.ext fun _ => mem_erase.trans <| by rw [and_comm', Set.mem_diff, Set.mem_singleton_iff] <;> rfl\n#align coe_erase coe_erase\n\n",
 "coe_eq_singleton":
 "@[simp, norm_cast]\ntheorem coe_eq_singleton {s : Finset α} {a : α} : (s : set α) = {a} ↔ s = {a} := by rw [← coe_singleton, coe_inj]\n#align coe_eq_singleton coe_eq_singleton\n\n",
 "coe_eq_pair":
 "@[simp, norm_cast]\ntheorem coe_eq_pair {s : Finset α} {a b : α} : (s : set α) = {a, b} ↔ s = {a, b} := by rw [← coe_pair, coe_inj]\n#align coe_eq_pair coe_eq_pair\n\n",
 "coe_eq_empty":
 "@[simp, norm_cast]\ntheorem coe_eq_empty {s : Finset α} : (s : set α) = ∅ ↔ s = ∅ := by rw [← coe_empty, coe_inj]\n#align coe_eq_empty coe_eq_empty\n\n",
 "coe_empty":
 "@[simp, norm_cast]\ntheorem coe_empty : ((∅ : Finset α) : set α) = ∅ :=\n  rfl\n#align coe_empty coe_empty\n\n",
 "coe_disj_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp, norm_cast]\ntheorem coe_disj_Union {h} :\n    (s.disj_Union t h : set β) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x) :=\n  by simp only [Set.ext_iff, mem_disj_Union, Set.mem_unionᵢ, iff_self_iff, mem_coe, imp_true_iff]\n#align coe_disj_Union coe_disj_Union\n\n",
 "coe_cons":
 "@[simp]\ntheorem coe_cons {a s h} : (@cons α a s h : set α) = insert a s :=\n  by\n  ext\n  simp\n#align coe_cons coe_cons\n\n",
 "coe_coe_emb":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪o » -/\n-- TODO: these should be global attributes, but this will require fixing other files\n@[simp]\ntheorem coe_coe_emb : «expr⇑ » (coeEmb : «expr ↪o » (Finset α) (set α)) = coe :=\n  rfl\n#align coe_coe_emb coe_coe_emb\n\n",
 "coe_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp, norm_cast]\ntheorem coe_bUnion :\n    (s.bUnion t : set β) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x) :=\n  by simp only [Set.ext_iff, mem_bUnion, Set.mem_unionᵢ, iff_self_iff, mem_coe, imp_true_iff]\n#align coe_bUnion coe_bUnion\n\n",
 "choose_spec":
 "theorem choose_spec (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l ∧ p (choose p l hp) :=\n  (chooseX p l hp).property\n#align choose_spec choose_spec\n\n",
 "choose_property":
 "theorem choose_property (hp : ∃! a, a ∈ l ∧ p a) : p (choose p l hp) :=\n  (choose_spec _ _ _).2\n#align choose_property choose_property\n\n",
 "choose_mem":
 "theorem choose_mem (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l :=\n  (choose_spec _ _ _).1\n#align choose_mem choose_mem\n\n",
 "bot_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_eq_empty : («expr⊥» : Finset α) = ∅ :=\n  rfl\n#align bot_eq_empty bot_eq_empty\n\n",
 "bind_to_finset":
 "theorem bind_to_finset [decidable_eq α] (s : Multiset α) (t : α → Multiset β) :\n    (s.bind t).to_finset = s.to_finset.bUnion fun a => (t a).to_finset :=\n  ext fun x => by simp only [Multiset.mem_toFinset, mem_bUnion, Multiset.mem_bind, exists_prop]\n#align bind_to_finset bind_to_finset\n\n",
 "bex":
 "theorem nonempty.bex {s : Finset α} (h : s.nonempty) : ∃ x : α, x ∈ s :=\n  h\n#align nonempty.bex nonempty.bex\n\n",
 "bUnion_val":
 "@[simp]\ntheorem bUnion_val (s : Finset α) (t : α → Finset β) : (s.bUnion t).1 = (s.1.bind fun a => (t a).1).dedup :=\n  rfl\n#align bUnion_val bUnion_val\n\n",
 "bUnion_subset_iff_forall_subset":
 "@[simp]\ntheorem bUnion_subset_iff_forall_subset {α β : Type _} [decidable_eq β] {s : Finset α} {t : Finset β}\n    {f : α → Finset β} : s.bUnion f ⊆ t ↔ ∀ x ∈ s, f x ⊆ t :=\n  ⟨fun h x hx => (subset_bunionᵢ_of_mem f hx).trans h, fun h x hx =>\n    let ⟨a, ha₁, ha₂⟩ := mem_bunionᵢ.mp hx\n    h _ ha₁ ha₂⟩\n#align bUnion_subset_iff_forall_subset bUnion_subset_iff_forall_subset\n\n",
 "bUnion_subset_bUnion_of_subset_left":
 "theorem bUnion_subset_bUnion_of_subset_left (t : α → Finset β) (h : s₁ ⊆ s₂) : s₁.bUnion t ⊆ s₂.bUnion t :=\n  by\n  intro x\n  simp only [and_imp, mem_bUnion, exists_prop]\n  exact Exists.imp fun a ha => ⟨h ha.1, ha.2⟩\n#align bUnion_subset_bUnion_of_subset_left bUnion_subset_bUnion_of_subset_left\n\n",
 "bUnion_subset":
 "theorem bUnion_subset {s' : Finset β} : s.bUnion t ⊆ s' ↔ ∀ x ∈ s, t x ⊆ s' := by\n  simp only [subset_iff, mem_bUnion] <;> exact ⟨fun H a ha b hb => H ⟨a, ha, hb⟩, fun H b ⟨a, ha, hb⟩ => H a ha hb⟩\n#align bUnion_subset bUnion_subset\n\n",
 "bUnion_singleton_eq_self":
 "@[simp]\ntheorem bUnion_singleton_eq_self [decidable_eq α] : s.bUnion (singleton : α → Finset α) = s :=\n  ext fun x => by simp only [mem_bUnion, mem_singleton, exists_prop, exists_eq_right']\n#align bUnion_singleton_eq_self bUnion_singleton_eq_self\n\n",
 "bUnion_nonempty":
 "@[simp]\ntheorem bUnion_nonempty : (s.bUnion t).nonempty ↔ ∃ x ∈ s, (t x).nonempty := by\n  simp [Finset.Nonempty, ← exists_and_left, @exists_swap α]\n#align bUnion_nonempty bUnion_nonempty\n\n",
 "bUnion_mono":
 "theorem bUnion_mono (h : ∀ a ∈ s, t₁ a ⊆ t₂ a) : s.bUnion t₁ ⊆ s.bUnion t₂ :=\n  by\n  have : ∀ b a, a ∈ s → b ∈ t₁ a → ∃ a : α, a ∈ s ∧ b ∈ t₂ a := fun b a ha hb =>\n    ⟨a, ha, Finset.mem_of_subset (h a ha) hb⟩\n  simpa only [subset_iff, mem_bUnion, exists_imp, and_imp, exists_prop]\n#align bUnion_mono bUnion_mono\n\n",
 "bUnion_inter":
 "theorem bUnion_inter (s : Finset α) (f : α → Finset β) (t : Finset β) : s.bUnion f ∩ t = s.bUnion fun x => f x ∩ t :=\n  by\n  ext x\n  simp only [mem_bUnion, mem_inter]\n  tauto\n#align bUnion_inter bUnion_inter\n\n",
 "bUnion_insert":
 "@[simp]\ntheorem bUnion_insert [decidable_eq α] {a : α} : (insert a s).bUnion t = t a ∪ s.bUnion t :=\n  ext fun x => by simp only [mem_bUnion, exists_prop, mem_union, mem_insert, or_and_right, exists_or, exists_eq_left]\n#align bUnion_insert bUnion_insert\n\n",
 "bUnion_filter_eq_of_maps_to":
 "theorem bUnion_filter_eq_of_maps_to [decidable_eq α] {s : Finset α} {t : Finset β} {f : α → β} (h : ∀ x ∈ s, f x ∈ t) :\n    (t.bUnion fun a => s.filter fun c => f c = a) = s := by\n  simpa only [disj_Union_eq_bUnion] using disj_Union_filter_eq_of_maps_to h\n#align bUnion_filter_eq_of_maps_to bUnion_filter_eq_of_maps_to\n\n",
 "bUnion_empty":
 "@[simp]\ntheorem bUnion_empty : Finset.bunionᵢ ∅ t = ∅ :=\n  rfl\n#align bUnion_empty bUnion_empty\n\n",
 "bUnion_congr":
 "-- ext $ λ x, by simp [or_and_distrib_right, exists_or_distrib]\ntheorem bUnion_congr (hs : s₁ = s₂) (ht : ∀ a ∈ s₁, t₁ a = t₂ a) : s₁.bUnion t₁ = s₂.bUnion t₂ :=\n  ext fun x => by simp (config := { contextual := true }) [hs, ht]\n#align bUnion_congr bUnion_congr\n\n",
 "bUnion_bUnion":
 "theorem bUnion_bUnion [decidable_eq γ] (s : Finset α) (f : α → Finset β) (g : β → Finset γ) :\n    (s.bUnion f).bUnion g = s.bUnion fun a => (f a).bUnion g :=\n  by\n  ext\n  simp only [Finset.mem_bunionᵢ, exists_prop]\n  simp_rw [← exists_and_right, ← exists_and_left, and_assoc']\n  rw [exists_comm]\n#align bUnion_bUnion bUnion_bUnion\n\n",
 "bUnion":
 "theorem nonempty.bUnion (hs : s.nonempty) (ht : ∀ x ∈ s, (t x).nonempty) : (s.bUnion t).nonempty :=\n  bunionᵢ_nonempty.2 <| hs.imp fun x hx => ⟨hx, ht x hx⟩\n#align nonempty.bUnion nonempty.bUnion\n\n",
 "attach_val":
 "@[simp]\ntheorem attach_val (s : Finset α) : s.attach.1 = s.1.attach :=\n  rfl\n#align attach_val attach_val\n\n",
 "attach_nonempty_iff":
 "@[simp]\ntheorem attach_nonempty_iff (s : Finset α) : s.attach.nonempty ↔ s.nonempty := by simp [Finset.Nonempty]\n#align attach_nonempty_iff attach_nonempty_iff\n\n",
 "attach_eq_empty_iff":
 "@[simp]\ntheorem attach_eq_empty_iff (s : Finset α) : s.attach = ∅ ↔ s = ∅ := by simpa [eq_empty_iff_forall_not_mem]\n#align attach_eq_empty_iff attach_eq_empty_iff\n\n",
 "attach_empty":
 "@[simp]\ntheorem attach_empty : attach (∅ : Finset α) = ∅ :=\n  rfl\n#align attach_empty attach_empty\n\n",
 "antisymm_iff":
 "theorem subset.antisymm_iff {s₁ s₂ : Finset α} : s₁ = s₂ ↔ s₁ ⊆ s₂ ∧ s₂ ⊆ s₁ :=\n  le_antisymm_iff\n#align subset.antisymm_iff subset.antisymm_iff\n\n",
 "antisymm":
 "theorem subset.antisymm {s₁ s₂ : Finset α} (H₁ : s₁ ⊆ s₂) (H₂ : s₂ ⊆ s₁) : s₁ = s₂ :=\n  ext fun a => ⟨@H₁ a, @H₂ a⟩\n#align subset.antisymm subset.antisymm\n\n"}