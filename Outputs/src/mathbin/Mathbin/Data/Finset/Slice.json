{"univ_mem_iff":
 "theorem sized.univ_mem_iff [fintype Œ±] (hA : A.sized r) : finset.univ ‚àà A ‚Üî A = {finset.univ} :=\n  hA.is_antichain.top_mem_iff\n#align sized.univ_mem_iff sized.univ_mem_iff\n\n",
 "sum_card_slice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n@[simp]\ntheorem sum_card_slice :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Iic (fintype.card Œ±)) (finset.slice ùíú r).card =\n      ùíú.card :=\n  by\n  letI := classical.dec_eq Œ±\n  rw [‚Üê card_bUnion, bUnion_slice]\n  exact finset.pairwise_disjoint_slice.subset (Set.subset_univ _)\n#align sum_card_slice sum_card_slice\n\n",
 "subsingleton'":
 "theorem sized.subsingleton' [fintype Œ±] (hA : A.sized (fintype.card Œ±)) : A.subsingleton :=\n  subsingleton_of_forall_eq finset.univ fun s hs => s.card_eq_iff_eq_univ.1 <| hA hs\n#align sized.subsingleton' sized.subsingleton'\n\n",
 "subsingleton":
 "protected theorem sized.subsingleton (hA : A.sized 0) : A.subsingleton :=\n  subsingleton_of_forall_eq ‚àÖ fun s hs => card_eq_zero.1 <| hA hs\n#align sized.subsingleton sized.subsingleton\n\n",
 "subset_powerset_len_univ_iff":
 "theorem subset_powerset_len_univ_iff : ùíú ‚äÜ powerset_len r univ ‚Üî (ùíú : set (Finset Œ±)).sized r :=\n  forall_congr' fun A => by rw [mem_powerset_len_univ_iff, mem_coe]\n#align subset_powerset_len_univ_iff subset_powerset_len_univ_iff\n\n",
 "slice_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- The `r`-th slice of `ùíú` is a subset of `ùíú`. -/\ntheorem slice_subset : finset.slice ùíú r ‚äÜ ùíú :=\n  filter_subset _ _\n#align slice_subset slice_subset\n\n",
 "sized_union":
 "theorem sized_union : (A ‚à™ B).sized r ‚Üî A.sized r ‚àß B.sized r :=\n  ‚ü®fun hA => ‚ü®hA.mono <| subset_union_left _ _, hA.mono <| subset_union_right _ _‚ü©, fun hA x hx =>\n    hx.elim (fun h => hA.1 h) fun h => hA.2 h‚ü©\n#align sized_union sized_union\n\n",
 "sized_slice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- Everything in the `r`-th slice of `ùíú` has size `r`. -/\ntheorem sized_slice : (finset.slice ùíú r : set (Finset Œ±)).sized r := fun _ => And.right ‚àò mem_slice.mp\n#align sized_slice sized_slice\n\n",
 "sized_powerset_len":
 "theorem sized_powerset_len (s : Finset Œ±) (r : ‚Ñï) : (powerset_len r s : set (Finset Œ±)).sized r := fun t ht =>\n  (mem_powerset_len.1 ht).2\n#align sized_powerset_len sized_powerset_len\n\n",
 "sized_Union‚ÇÇ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n@[simp]\ntheorem sized_Union‚ÇÇ {f : ‚àÄ i, Œ∫ i ‚Üí set (Finset Œ±)} :\n    (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (f i j)).sized r ‚Üî\n      ‚àÄ i j, (f i j).sized r :=\n  by simp_rw [sized_Union]\n#align sized_Union‚ÇÇ sized_Union‚ÇÇ\n\n",
 "sized_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª -/\n--TODO: A `forall_Union` lemma would be handy here.\n@[simp]\ntheorem sized_Union {f : Œπ ‚Üí set (Finset Œ±)} :\n    (¬´expr‚ãÉ , ¬ª \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `¬´expr‚ãÉ , ¬ª\" (f i)).sized r ‚Üî\n      ‚àÄ i, (f i).sized r :=\n  by\n  simp_rw [set.sized, Set.mem_union·µ¢, forall_exists_index]\n  exact forall_swap\n#align sized_Union sized_Union\n\n",
 "pairwise_disjoint_slice":
 "theorem pairwise_disjoint_slice : (Set.univ : set ‚Ñï).pairwise_disjoint (slice ùíú) := fun m _ n _ hmn =>\n  disjoint_filter.2 fun s hs hm hn => hmn <| hm.symm.trans hn\n#align pairwise_disjoint_slice pairwise_disjoint_slice\n\n",
 "ne_of_mem_slice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- Elements in distinct slices must be distinct. -/\ntheorem ne_of_mem_slice (h‚ÇÅ : A‚ÇÅ ‚àà finset.slice ùíú r‚ÇÅ) (h‚ÇÇ : A‚ÇÇ ‚àà finset.slice ùíú r‚ÇÇ) : r‚ÇÅ ‚â† r‚ÇÇ ‚Üí A‚ÇÅ ‚â† A‚ÇÇ :=\n  mt fun h => (sized_slice h‚ÇÅ).symm.trans ((congr_arg card h).trans (sized_slice h‚ÇÇ))\n#align ne_of_mem_slice ne_of_mem_slice\n\n",
 "mono":
 "/-\nCopyright (c) 2021 Bhavik Mehta, Ya√´l Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta, Alena Gusakov, Ya√´l Dillies\n-/\ntheorem sized.mono (h : A ‚äÜ B) (hB : B.sized r) : A.sized r := fun x hx => hB <| h hx\n#align sized.mono sized.mono\n\n",
 "mem_slice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/-- `A` is in the `r`-th slice of `ùíú` iff it's in `ùíú` and has cardinality `r`. -/\ntheorem mem_slice : A ‚àà finset.slice ùíú r ‚Üî A ‚àà ùíú ‚àß A.card = r :=\n  mem_filter\n#align mem_slice mem_slice\n\n",
 "is_antichain":
 "protected theorem sized.is_antichain (hA : A.sized r) : IsAntichain (¬∑ ‚äÜ ¬∑) A := fun s hs t ht h hst =>\n  h <| finset.eq_of_subset_of_card_le hst ((hA ht).trans (hA hs).symm).le\n#align sized.is_antichain sized.is_antichain\n\n",
 "eq_of_mem_slice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.slice -/\ntheorem eq_of_mem_slice (h‚ÇÅ : A ‚àà finset.slice ùíú r‚ÇÅ) (h‚ÇÇ : A ‚àà finset.slice ùíú r‚ÇÇ) : r‚ÇÅ = r‚ÇÇ :=\n  (sized_slice h‚ÇÅ).symm.trans <| sized_slice h‚ÇÇ\n#align eq_of_mem_slice eq_of_mem_slice\n\n",
 "empty_mem_iff":
 "theorem sized.empty_mem_iff (hA : A.sized r) : ‚àÖ ‚àà A ‚Üî A = {‚àÖ} :=\n  hA.is_antichain.bot_mem_iff\n#align sized.empty_mem_iff sized.empty_mem_iff\n\n",
 "card_le":
 "theorem _root_.set.sized.card_le (hùíú : (ùíú : set (Finset Œ±)).sized r) : card ùíú ‚â§ (fintype.card Œ±).choose r :=\n  by\n  rw [fintype.card, ‚Üê card_powerset_len]\n  exact card_le_of_subset hùíú.subset_powerset_len_univ\n#align set.sized.card_le set.sized.card_le\n\n",
 "bUnion_slice":
 "@[simp]\ntheorem bUnion_slice [decidable_eq Œ±] : (Iic <| fintype.card Œ±).bUnion ùíú.slice = ùíú :=\n  Subset.antisymm (bunion·µ¢_subset.2 fun r _ => slice_subset) fun s hs =>\n    mem_bunion·µ¢.2 ‚ü®s.card, mem_Iic.2 <| s.card_le_univ, mem_slice.2 <| ‚ü®hs, rfl‚ü©‚ü©\n#align bUnion_slice bUnion_slice\n\n"}