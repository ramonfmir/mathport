{"induction_on_pi_of_choice":
 "/-\nCopyright (c) 2021 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n/-- General theorem for `finset.induction_on_pi`-style induction principles. -/\ntheorem induction_on_pi_of_choice (r : ∀ i, α i → Finset (α i) → Prop)\n    (H_ex : ∀ (i) (s : Finset (α i)) (hs : s.nonempty), ∃ x ∈ s, r i x (s.erase x)) {p : (∀ i, Finset (α i)) → Prop}\n    (f : ∀ i, Finset (α i)) (h0 : p fun _ => ∅)\n    (step : ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i), r i x (g i) → p g → p (update g i (insert x (g i)))) : p f :=\n  by\n  cases nonempty_fintype ι\n  induction' hs : univ.sigma f using Finset.strongInductionOn with s ihs generalizing f; subst s\n  cases' eq_empty_or_nonempty (univ.sigma f) with he hne\n  · convert h0\n    simpa [funext_iff] using he\n  · rcases sigma_nonempty.1 hne with ⟨i, -, hi⟩\n    rcases H_ex i (f i) hi with ⟨x, x_mem, hr⟩\n    set g := update f i ((f i).erase x) with hg\n    clear_value g\n    have hx' : x ∉ g i := by\n      rw [hg, update_same]\n      apply not_mem_erase\n    obtain rfl : f = update g i (insert x (g i)) := by\n      rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self]\n    clear hg\n    rw [update_same, erase_insert hx'] at hr\n    refine' step _ _ _ hr (ihs (univ.sigma g) _ _ rfl)\n    rw [ssubset_iff_of_subset (sigma_mono (subset.refl _) _)]\n    exacts[⟨⟨i, x⟩, mem_sigma.2 ⟨mem_univ _, by simp⟩, by simp [hx']⟩,\n      (@le_update_iff _ _ _ _ g g i _).2 ⟨subset_insert _ _, fun _ _ => le_rfl⟩]\n#align induction_on_pi_of_choice induction_on_pi_of_choice\n\n",
 "induction_on_pi_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- Given a predicate on functions `Π i, finset (α i)` defined on a finite type, it is true on all\nmaps provided that it is true on `λ _, ∅` and for any function `g : Π i, finset (α i)`, an index\n`i : ι`, and an element`x : α i` that is strictly less than all elements of `g i`, `p g` implies\n`p (update g i (insert x (g i)))`.\n\nThis lemma requires `linear_order` instances on all `α i`. See also `finset.induction_on_pi` for a\nversion that `x ∉ g i` instead of ` does not need `Π i, linear_order (α i)`. -/\ntheorem induction_on_pi_min [∀ i, linear_order (α i)] {p : (∀ i, Finset (α i)) → Prop} (f : ∀ i, Finset (α i))\n    (h0 : p fun _ => ∅)\n    (step : ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i), (∀ y ∈ g i, x < y) → p g → p (update g i (insert x (g i)))) :\n    p f :=\n  @induction_on_pi_max ι (fun i => «expr ᵒᵈ» (α i)) _ _ _ _ _ _ h0 step\n#align induction_on_pi_min induction_on_pi_min\n\n",
 "induction_on_pi_max":
 "/-- Given a predicate on functions `Π i, finset (α i)` defined on a finite type, it is true on all\nmaps provided that it is true on `λ _, ∅` and for any function `g : Π i, finset (α i)`, an index\n`i : ι`, and an element`x : α i` that is strictly greater than all elements of `g i`, `p g` implies\n`p (update g i (insert x (g i)))`.\n\nThis lemma requires `linear_order` instances on all `α i`. See also `finset.induction_on_pi` for a\nversion that `x ∉ g i` instead of ` does not need `Π i, linear_order (α i)`. -/\ntheorem induction_on_pi_max [∀ i, linear_order (α i)] {p : (∀ i, Finset (α i)) → Prop} (f : ∀ i, Finset (α i))\n    (h0 : p fun _ => ∅)\n    (step : ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i), (∀ y ∈ g i, y < x) → p g → p (update g i (insert x (g i)))) :\n    p f :=\n  induction_on_pi_of_choice (fun i x s => ∀ y ∈ s, y < x)\n    (fun i s hs => ⟨s.max' hs, s.max'_mem hs, fun y => s.lt_max'_of_mem_erase_max' _⟩) f h0 step\n#align induction_on_pi_max induction_on_pi_max\n\n",
 "induction_on_pi":
 "/-- Given a predicate on functions `Π i, finset (α i)` defined on a finite type, it is true on all\nmaps provided that it is true on `λ _, ∅` and for any function `g : Π i, finset (α i)`, an index\n`i : ι`, and `x ∉ g i`, `p g` implies `p (update g i (insert x (g i)))`.\n\nSee also `finset.induction_on_pi_max` and `finset.induction_on_pi_min` for specialized versions\nthat require `Π i, linear_order (α i)`.  -/\ntheorem induction_on_pi {p : (∀ i, Finset (α i)) → Prop} (f : ∀ i, Finset (α i)) (h0 : p fun _ => ∅)\n    (step : ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i) (hx : x ∉ g i), p g → p (update g i (insert x (g i)))) : p f :=\n  induction_on_pi_of_choice (fun i x s => x ∉ s) (fun i s ⟨x, hx⟩ => ⟨x, hx, not_mem_erase x s⟩) f h0 step\n#align induction_on_pi induction_on_pi\n\n"}