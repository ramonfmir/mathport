{"uIcc_to_dual":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_to_dual (a b : α) : finset.uIcc (toDual a) (toDual b) = (finset.uIcc a b).map toDual.to_embedding :=\n  Icc_to_dual _ _\n#align uIcc_to_dual uIcc_to_dual\n\n",
 "uIcc_subset_uIcc_union_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/-- A sort of triangle inequality. -/\ntheorem uIcc_subset_uIcc_union_uIcc : finset.uIcc a c ⊆ finset.uIcc a b ∪ finset.uIcc b c :=\n  coe_subset.1 <| by\n    push_cast\n    exact set.uIcc_subset_uIcc_union_uIcc\n#align uIcc_subset_uIcc_union_uIcc uIcc_subset_uIcc_union_uIcc\n\n",
 "uIcc_subset_uIcc_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_subset_uIcc_right (h : x ∈ finset.uIcc a b) : finset.uIcc x b ⊆ finset.uIcc a b :=\n  uIcc_subset_uIcc h right_mem_uIcc\n#align uIcc_subset_uIcc_right uIcc_subset_uIcc_right\n\n",
 "uIcc_subset_uIcc_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_subset_uIcc_left (h : x ∈ finset.uIcc a b) : finset.uIcc a x ⊆ finset.uIcc a b :=\n  uIcc_subset_uIcc left_mem_uIcc h\n#align uIcc_subset_uIcc_left uIcc_subset_uIcc_left\n\n",
 "uIcc_subset_uIcc_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_subset_uIcc_iff_mem :\n    finset.uIcc a₁ b₁ ⊆ finset.uIcc a₂ b₂ ↔ a₁ ∈ finset.uIcc a₂ b₂ ∧ b₁ ∈ finset.uIcc a₂ b₂ :=\n  ⟨fun h => ⟨h left_mem_uIcc, h right_mem_uIcc⟩, fun h => uIcc_subset_uIcc h.1 h.2⟩\n#align uIcc_subset_uIcc_iff_mem uIcc_subset_uIcc_iff_mem\n\n",
 "uIcc_subset_uIcc_iff_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem uIcc_subset_uIcc_iff_le' :\n    finset.uIcc a₁ b₁ ⊆ finset.uIcc a₂ b₂ ↔ «expr ⊓ » a₂ b₂ ≤ «expr ⊓ » a₁ b₁ ∧ «expr ⊔ » a₁ b₁ ≤ «expr ⊔ » a₂ b₂ :=\n  Icc_subset_Icc_iff inf_le_sup\n#align uIcc_subset_uIcc_iff_le' uIcc_subset_uIcc_iff_le'\n\n",
 "uIcc_subset_uIcc_iff_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_subset_uIcc_iff_le :\n    finset.uIcc a₁ b₁ ⊆ finset.uIcc a₂ b₂ ↔ min a₂ b₂ ≤ min a₁ b₁ ∧ max a₁ b₁ ≤ max a₂ b₂ :=\n  uIcc_subset_uIcc_iff_le'\n#align uIcc_subset_uIcc_iff_le uIcc_subset_uIcc_iff_le\n\n",
 "uIcc_subset_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_subset_uIcc (h₁ : a₁ ∈ finset.uIcc a₂ b₂) (h₂ : b₁ ∈ finset.uIcc a₂ b₂) :\n    finset.uIcc a₁ b₁ ⊆ finset.uIcc a₂ b₂ := by\n  rw [mem_uIcc] at h₁ h₂\n  exact Icc_subset_Icc (le_inf h₁.1 h₂.1) (sup_le h₁.2 h₂.2)\n#align uIcc_subset_uIcc uIcc_subset_uIcc\n\n",
 "uIcc_subset_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_subset_Icc (ha : a₁ ∈ Icc a₂ b₂) (hb : b₁ ∈ Icc a₂ b₂) : finset.uIcc a₁ b₁ ⊆ Icc a₂ b₂ :=\n  by\n  rw [mem_Icc] at ha hb\n  exact Icc_subset_Icc (le_inf ha.1 hb.1) (sup_le ha.2 hb.2)\n#align uIcc_subset_Icc uIcc_subset_Icc\n\n",
 "uIcc_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n@[simp]\ntheorem uIcc_self : finset.uIcc a a = {a} := by simp [uIcc]\n#align uIcc_self uIcc_self\n\n",
 "uIcc_of_not_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_of_not_le (h : ¬a ≤ b) : finset.uIcc a b = Icc b a :=\n  uIcc_of_ge <| le_of_not_ge h\n#align uIcc_of_not_le uIcc_of_not_le\n\n",
 "uIcc_of_not_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_of_not_ge (h : ¬b ≤ a) : finset.uIcc a b = Icc a b :=\n  uIcc_of_le <| le_of_not_ge h\n#align uIcc_of_not_ge uIcc_of_not_ge\n\n",
 "uIcc_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n@[simp]\ntheorem uIcc_of_le (h : a ≤ b) : finset.uIcc a b = Icc a b := by rw [uIcc, inf_eq_left.2 h, sup_eq_right.2 h]\n#align uIcc_of_le uIcc_of_le\n\n",
 "uIcc_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n@[simp]\ntheorem uIcc_of_ge (h : b ≤ a) : finset.uIcc a b = Icc b a := by rw [uIcc, inf_eq_right.2 h, sup_eq_left.2 h]\n#align uIcc_of_ge uIcc_of_ge\n\n",
 "uIcc_injective_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_injective_right (a : α) : injective fun b => finset.uIcc b a := fun b c h =>\n  by\n  rw [ext_iff] at h\n  exact eq_of_mem_uIcc_of_mem_uIcc ((h _).1 left_mem_uIcc) ((h _).2 left_mem_uIcc)\n#align uIcc_injective_right uIcc_injective_right\n\n",
 "uIcc_injective_left":
 "theorem uIcc_injective_left (a : α) : injective (uIcc a) := by simpa only [uIcc_comm] using uIcc_injective_right a\n#align uIcc_injective_left uIcc_injective_left\n\n",
 "uIcc_eq_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_eq_union : finset.uIcc a b = Icc a b ∪ Icc b a :=\n  coe_injective <| by\n    push_cast\n    exact set.uIcc_eq_union\n#align uIcc_eq_union uIcc_eq_union\n\n",
 "uIcc_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem uIcc_comm (a b : α) : finset.uIcc a b = finset.uIcc b a := by rw [uIcc, uIcc, inf_comm, sup_comm]\n#align uIcc_comm uIcc_comm\n\n",
 "right_not_mem_Ioo":
 "@[simp]\ntheorem right_not_mem_Ioo : b ∉ Ioo a b := fun h => lt_irrefl _ (mem_Ioo.1 h).2\n#align right_not_mem_Ioo right_not_mem_Ioo\n\n",
 "right_not_mem_Ico":
 "@[simp]\ntheorem right_not_mem_Ico : b ∉ Ico a b := fun h => lt_irrefl _ (mem_Ico.1 h).2\n#align right_not_mem_Ico right_not_mem_Ico\n\n",
 "right_mem_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n@[simp]\ntheorem right_mem_uIcc : b ∈ finset.uIcc a b :=\n  mem_Icc.2 ⟨inf_le_right, le_sup_right⟩\n#align right_mem_uIcc right_mem_uIcc\n\n",
 "right_mem_Ioc":
 "@[simp]\ntheorem right_mem_Ioc : b ∈ Ioc a b ↔ a < b := by simp only [mem_Ioc, and_true_iff, le_rfl]\n#align right_mem_Ioc right_mem_Ioc\n\n",
 "right_mem_Icc":
 "@[simp]\ntheorem right_mem_Icc : b ∈ Icc a b ↔ a ≤ b := by simp only [mem_Icc, and_true_iff, le_rfl]\n#align right_mem_Icc right_mem_Icc\n\n",
 "prod_prod_Ioi_mul_eq_prod_prod_off_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[to_additive]\ntheorem prod_prod_Ioi_mul_eq_prod_prod_off_diag [fintype ι] [linear_order ι] [locally_finite_order_top ι]\n    [locally_finite_order_bot ι] [comm_monoid α] (f : ι → ι → α) :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ioi i)\n          (f j i * f i j)) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          («expr ᶜ» {i}) (f j i)) :=\n  by\n  simp_rw [← Ioi_disj_union_Iio, prod_disj_union, prod_mul_distrib]\n  congr 1\n  rw [prod_sigma', prod_sigma']\n  refine' prod_bij' (fun i hi => ⟨i.2, i.1⟩) _ _ (fun i hi => ⟨i.2, i.1⟩) _ _ _ <;> simp\n#align prod_prod_Ioi_mul_eq_prod_prod_off_diag prod_prod_Ioi_mul_eq_prod_prod_off_diag\n\n",
 "not_mem_uIcc_of_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem not_mem_uIcc_of_lt : c < a → c < b → c ∉ finset.uIcc a b :=\n  by\n  rw [mem_uIcc]\n  exact set.not_mem_uIcc_of_lt\n#align not_mem_uIcc_of_lt not_mem_uIcc_of_lt\n\n",
 "not_mem_uIcc_of_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem not_mem_uIcc_of_gt : a < c → b < c → c ∉ finset.uIcc a b :=\n  by\n  rw [mem_uIcc]\n  exact set.not_mem_uIcc_of_gt\n#align not_mem_uIcc_of_gt not_mem_uIcc_of_gt\n\n",
 "not_mem_Ioi_self":
 "@[simp]\ntheorem not_mem_Ioi_self {b : α} : b ∉ Ioi b := fun h => lt_irrefl _ (mem_Ioi.1 h)\n#align not_mem_Ioi_self not_mem_Ioi_self\n\n",
 "not_mem_Iio_self":
 "@[simp]\ntheorem not_mem_Iio_self {b : α} : b ∉ Iio b := fun h => lt_irrefl _ (mem_Iio.1 h)\n#align not_mem_Iio_self not_mem_Iio_self\n\n",
 "nonempty_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n@[simp]\ntheorem nonempty_uIcc : Finset.Nonempty (finset.uIcc a b) :=\n  nonempty_Icc.2 inf_le_sup\n#align nonempty_uIcc nonempty_uIcc\n\n",
 "nonempty_Ioo":
 "@[simp]\ntheorem nonempty_Ioo [DenselyOrdered α] : (Ioo a b).nonempty ↔ a < b := by\n  rw [← coe_nonempty, coe_Ioo, Set.nonempty_Ioo]\n#align nonempty_Ioo nonempty_Ioo\n\n",
 "nonempty_Ioc":
 "@[simp]\ntheorem nonempty_Ioc : (Ioc a b).nonempty ↔ a < b := by rw [← coe_nonempty, coe_Ioc, Set.nonempty_Ioc]\n#align nonempty_Ioc nonempty_Ioc\n\n",
 "nonempty_Ico":
 "@[simp]\ntheorem nonempty_Ico : (Ico a b).nonempty ↔ a < b := by rw [← coe_nonempty, coe_Ico, Set.nonempty_Ico]\n#align nonempty_Ico nonempty_Ico\n\n",
 "nonempty_Icc":
 "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Yaël Dillies\n-/\n@[simp]\ntheorem nonempty_Icc : (Icc a b).nonempty ↔ a ≤ b := by rw [← coe_nonempty, coe_Icc, Set.nonempty_Icc]\n#align nonempty_Icc nonempty_Icc\n\n",
 "mem_uIcc_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem mem_uIcc_of_le (ha : a ≤ x) (hb : x ≤ b) : x ∈ finset.uIcc a b :=\n  Icc_subset_uIcc <| mem_Icc.2 ⟨ha, hb⟩\n#align mem_uIcc_of_le mem_uIcc_of_le\n\n",
 "mem_uIcc_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem mem_uIcc_of_ge (hb : b ≤ x) (ha : x ≤ a) : x ∈ finset.uIcc a b :=\n  Icc_subset_uIcc' <| mem_Icc.2 ⟨hb, ha⟩\n#align mem_uIcc_of_ge mem_uIcc_of_ge\n\n",
 "mem_uIcc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem mem_uIcc' : a ∈ finset.uIcc b c ↔ b ≤ a ∧ a ≤ c ∨ c ≤ a ∧ a ≤ b := by simp [uIcc_eq_union]\n#align mem_uIcc' mem_uIcc'\n\n",
 "map_add_right_Ioo":
 "@[simp]\ntheorem map_add_right_Ioo (a b c : α) : (Ioo a b).map (addRightEmbedding c) = Ioo (a + c) (b + c) :=\n  by\n  rw [← coe_inj, coe_map, coe_Ioo, coe_Ioo]\n  exact Set.image_add_const_Ioo _ _ _\n#align map_add_right_Ioo map_add_right_Ioo\n\n",
 "map_add_right_Ioc":
 "@[simp]\ntheorem map_add_right_Ioc (a b c : α) : (Ioc a b).map (addRightEmbedding c) = Ioc (a + c) (b + c) :=\n  by\n  rw [← coe_inj, coe_map, coe_Ioc, coe_Ioc]\n  exact Set.image_add_const_Ioc _ _ _\n#align map_add_right_Ioc map_add_right_Ioc\n\n",
 "map_add_right_Ico":
 "@[simp]\ntheorem map_add_right_Ico (a b c : α) : (Ico a b).map (addRightEmbedding c) = Ico (a + c) (b + c) :=\n  by\n  rw [← coe_inj, coe_map, coe_Ico, coe_Ico]\n  exact Set.image_add_const_Ico _ _ _\n#align map_add_right_Ico map_add_right_Ico\n\n",
 "map_add_right_Icc":
 "@[simp]\ntheorem map_add_right_Icc (a b c : α) : (Icc a b).map (addRightEmbedding c) = Icc (a + c) (b + c) :=\n  by\n  rw [← coe_inj, coe_map, coe_Icc, coe_Icc]\n  exact Set.image_add_const_Icc _ _ _\n#align map_add_right_Icc map_add_right_Icc\n\n",
 "map_add_left_Ioo":
 "@[simp]\ntheorem map_add_left_Ioo (a b c : α) : (Ioo a b).map (addLeftEmbedding c) = Ioo (c + a) (c + b) :=\n  by\n  rw [← coe_inj, coe_map, coe_Ioo, coe_Ioo]\n  exact Set.image_const_add_Ioo _ _ _\n#align map_add_left_Ioo map_add_left_Ioo\n\n",
 "map_add_left_Ioc":
 "@[simp]\ntheorem map_add_left_Ioc (a b c : α) : (Ioc a b).map (addLeftEmbedding c) = Ioc (c + a) (c + b) :=\n  by\n  rw [← coe_inj, coe_map, coe_Ioc, coe_Ioc]\n  exact Set.image_const_add_Ioc _ _ _\n#align map_add_left_Ioc map_add_left_Ioc\n\n",
 "map_add_left_Ico":
 "@[simp]\ntheorem map_add_left_Ico (a b c : α) : (Ico a b).map (addLeftEmbedding c) = Ico (c + a) (c + b) :=\n  by\n  rw [← coe_inj, coe_map, coe_Ico, coe_Ico]\n  exact Set.image_const_add_Ico _ _ _\n#align map_add_left_Ico map_add_left_Ico\n\n",
 "map_add_left_Icc":
 "@[simp]\ntheorem map_add_left_Icc (a b c : α) : (Icc a b).map (addLeftEmbedding c) = Icc (c + a) (c + b) :=\n  by\n  rw [← coe_inj, coe_map, coe_Icc, coe_Icc]\n  exact Set.image_const_add_Icc _ _ _\n#align map_add_left_Icc map_add_left_Icc\n\n",
 "left_not_mem_Ioo":
 "@[simp]\ntheorem left_not_mem_Ioo : a ∉ Ioo a b := fun h => lt_irrefl _ (mem_Ioo.1 h).1\n#align left_not_mem_Ioo left_not_mem_Ioo\n\n",
 "left_not_mem_Ioc":
 "@[simp]\ntheorem left_not_mem_Ioc : a ∉ Ioc a b := fun h => lt_irrefl _ (mem_Ioc.1 h).1\n#align left_not_mem_Ioc left_not_mem_Ioc\n\n",
 "left_mem_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n@[simp]\ntheorem left_mem_uIcc : a ∈ finset.uIcc a b :=\n  mem_Icc.2 ⟨inf_le_left, le_sup_left⟩\n#align left_mem_uIcc left_mem_uIcc\n\n",
 "left_mem_Ico":
 "@[simp]\ntheorem left_mem_Ico : a ∈ Ico a b ↔ a < b := by simp only [mem_Ico, true_and_iff, le_refl]\n#align left_mem_Ico left_mem_Ico\n\n",
 "left_mem_Icc":
 "@[simp]\ntheorem left_mem_Icc : a ∈ Icc a b ↔ a ≤ b := by simp only [mem_Icc, true_and_iff, le_rfl]\n#align left_mem_Icc left_mem_Icc\n\n",
 "image_add_right_Ioo":
 "theorem image_add_right_Ioo (a b c : α) : (Ioo a b).image (· + c) = Ioo (a + c) (b + c) :=\n  by\n  rw [← map_add_right_Ioo, map_eq_image]\n  rfl\n#align image_add_right_Ioo image_add_right_Ioo\n\n",
 "image_add_right_Ioc":
 "theorem image_add_right_Ioc (a b c : α) : (Ioc a b).image (· + c) = Ioc (a + c) (b + c) :=\n  by\n  rw [← map_add_right_Ioc, map_eq_image]\n  rfl\n#align image_add_right_Ioc image_add_right_Ioc\n\n",
 "image_add_right_Ico":
 "theorem image_add_right_Ico (a b c : α) : (Ico a b).image (· + c) = Ico (a + c) (b + c) :=\n  by\n  rw [← map_add_right_Ico, map_eq_image]\n  rfl\n#align image_add_right_Ico image_add_right_Ico\n\n",
 "image_add_right_Icc":
 "@[simp]\ntheorem image_add_right_Icc (a b c : α) : (Icc a b).image (· + c) = Icc (a + c) (b + c) :=\n  by\n  rw [← map_add_right_Icc, map_eq_image]\n  rfl\n#align image_add_right_Icc image_add_right_Icc\n\n",
 "image_add_left_Ioo":
 "@[simp]\ntheorem image_add_left_Ioo (a b c : α) : (Ioo a b).image ((· + ·) c) = Ioo (c + a) (c + b) :=\n  by\n  rw [← map_add_left_Ioo, map_eq_image]\n  rfl\n#align image_add_left_Ioo image_add_left_Ioo\n\n",
 "image_add_left_Ioc":
 "@[simp]\ntheorem image_add_left_Ioc (a b c : α) : (Ioc a b).image ((· + ·) c) = Ioc (c + a) (c + b) :=\n  by\n  rw [← map_add_left_Ioc, map_eq_image]\n  rfl\n#align image_add_left_Ioc image_add_left_Ioc\n\n",
 "image_add_left_Ico":
 "@[simp]\ntheorem image_add_left_Ico (a b c : α) : (Ico a b).image ((· + ·) c) = Ico (c + a) (c + b) :=\n  by\n  rw [← map_add_left_Ico, map_eq_image]\n  rfl\n#align image_add_left_Ico image_add_left_Ico\n\n",
 "image_add_left_Icc":
 "@[simp]\ntheorem image_add_left_Icc (a b c : α) : (Icc a b).image ((· + ·) c) = Icc (c + a) (c + b) :=\n  by\n  rw [← map_add_left_Icc, map_eq_image]\n  rfl\n#align image_add_left_Icc image_add_left_Icc\n\n",
 "finite_of_bdd_above":
 "theorem _root_.bdd_below.finite_of_bdd_above {s : set α} (h₀ : BddBelow s) (h₁ : BddAbove s) : s.finite :=\n  by\n  let ⟨a, ha⟩ := h₀\n  let ⟨b, hb⟩ := h₁\n  classical exact ⟨set.fintype_of_mem_bounds ha hb⟩\n#align bdd_below.finite_of_bdd_above bdd_below.finite_of_bdd_above\n\n",
 "finite":
 "theorem _root_.bdd_above.finite {s : set α} (hs : BddAbove s) : s.finite :=\n  hs.dual.finite\n#align bdd_above.finite bdd_above.finite\n\n",
 "filter_lt_lt_eq_Ioo":
 "theorem filter_lt_lt_eq_Ioo [decidable_pred fun j => a < j ∧ j < b] : (univ.filter fun j => a < j ∧ j < b) = Ioo a b :=\n  by\n  ext\n  simp\n#align filter_lt_lt_eq_Ioo filter_lt_lt_eq_Ioo\n\n",
 "filter_lt_le_eq_Ioc":
 "theorem filter_lt_le_eq_Ioc [decidable_pred fun j => a < j ∧ j ≤ b] : (univ.filter fun j => a < j ∧ j ≤ b) = Ioc a b :=\n  by\n  ext\n  simp\n#align filter_lt_le_eq_Ioc filter_lt_le_eq_Ioc\n\n",
 "filter_lt_eq_Ioi":
 "theorem filter_lt_eq_Ioi [decidable_pred ((· < ·) a)] : univ.filter ((· < ·) a) = Ioi a :=\n  by\n  ext\n  simp\n#align filter_lt_eq_Ioi filter_lt_eq_Ioi\n\n",
 "filter_le_lt_eq_Ico":
 "theorem filter_le_lt_eq_Ico [decidable_pred fun j => a ≤ j ∧ j < b] : (univ.filter fun j => a ≤ j ∧ j < b) = Ico a b :=\n  by\n  ext\n  simp\n#align filter_le_lt_eq_Ico filter_le_lt_eq_Ico\n\n",
 "filter_le_le_eq_Icc":
 "theorem filter_le_le_eq_Icc [decidable_pred fun j => a ≤ j ∧ j ≤ b] : (univ.filter fun j => a ≤ j ∧ j ≤ b) = Icc a b :=\n  by\n  ext\n  simp\n#align filter_le_le_eq_Icc filter_le_le_eq_Icc\n\n",
 "filter_le_eq_Ici":
 "theorem filter_le_eq_Ici [decidable_pred ((· ≤ ·) a)] : univ.filter ((· ≤ ·) a) = Ici a :=\n  by\n  ext\n  simp\n#align filter_le_eq_Ici filter_le_eq_Ici\n\n",
 "filter_gt_eq_Iio":
 "theorem filter_gt_eq_Iio [decidable_pred (· < a)] : univ.filter (· < a) = Iio a :=\n  by\n  ext\n  simp\n#align filter_gt_eq_Iio filter_gt_eq_Iio\n\n",
 "filter_ge_eq_Iic":
 "theorem filter_ge_eq_Iic [decidable_pred (· ≤ a)] : univ.filter (· ≤ a) = Iic a :=\n  by\n  ext\n  simp\n#align filter_ge_eq_Iic filter_ge_eq_Iic\n\n",
 "eq_of_mem_uIcc_of_mem_uIcc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem eq_of_mem_uIcc_of_mem_uIcc' : b ∈ finset.uIcc a c → c ∈ finset.uIcc a b → b = c :=\n  by\n  simp_rw [mem_uIcc]\n  exact set.eq_of_mem_uIcc_of_mem_uIcc'\n#align eq_of_mem_uIcc_of_mem_uIcc' eq_of_mem_uIcc_of_mem_uIcc'\n\n",
 "eq_of_mem_uIcc_of_mem_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem eq_of_mem_uIcc_of_mem_uIcc : a ∈ finset.uIcc b c → b ∈ finset.uIcc a c → a = b :=\n  by\n  simp_rw [mem_uIcc]\n  exact set.eq_of_mem_uIcc_of_mem_uIcc\n#align eq_of_mem_uIcc_of_mem_uIcc eq_of_mem_uIcc_of_mem_uIcc\n\n",
 "disjoint_Ioi_Iio":
 "theorem disjoint_Ioi_Iio (a : α) : Disjoint (Ioi a) (Iio a) :=\n  disjoint_left.2 fun b hab hba => (mem_Ioi.1 hab).not_lt <| mem_Iio.1 hba\n#align disjoint_Ioi_Iio disjoint_Ioi_Iio\n\n",
 "card_Ioo_eq_card_Ioc_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem card_Ioo_eq_card_Ioc_sub_one (a b : α) : (Ioo a b).card = (Ioc a b).card - 1 :=\n  @card_Ioo_eq_card_Ico_sub_one («expr ᵒᵈ» α) _ _ _ _\n#align card_Ioo_eq_card_Ioc_sub_one card_Ioo_eq_card_Ioc_sub_one\n\n",
 "card_Ioo_eq_card_Ico_sub_one":
 "theorem card_Ioo_eq_card_Ico_sub_one (a b : α) : (Ioo a b).card = (Ico a b).card - 1 := by\n  classical\n    by_cases h : a ≤ b\n    · obtain rfl | h' := h.eq_or_lt\n      · rw [Ioo_self, Ico_self, card_empty]\n      rw [← Ioo_insert_left h', card_insert_of_not_mem left_not_mem_Ioo]\n      exact (nat.add_sub_cancel _ _).symm\n    · rw [Ioo_eq_empty fun h' => h h'.le, Ico_eq_empty fun h' => h h'.le, card_empty, zero_tsub]\n#align card_Ioo_eq_card_Ico_sub_one card_Ioo_eq_card_Ico_sub_one\n\n",
 "card_Ioo_eq_card_Icc_sub_two":
 "theorem card_Ioo_eq_card_Icc_sub_two (a b : α) : (Ioo a b).card = (Icc a b).card - 2 :=\n  by\n  rw [card_Ioo_eq_card_Ico_sub_one, card_Ico_eq_card_Icc_sub_one]\n  rfl\n#align card_Ioo_eq_card_Icc_sub_two card_Ioo_eq_card_Icc_sub_two\n\n",
 "card_Ioi_eq_card_Ici_sub_one":
 "theorem card_Ioi_eq_card_Ici_sub_one (a : α) : (Ioi a).card = (Ici a).card - 1 := by\n  rw [Ici_eq_cons_Ioi, card_cons, add_tsub_cancel_right]\n#align card_Ioi_eq_card_Ici_sub_one card_Ioi_eq_card_Ici_sub_one\n\n",
 "card_Ioc_eq_card_Icc_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem card_Ioc_eq_card_Icc_sub_one (a b : α) : (Ioc a b).card = (Icc a b).card - 1 :=\n  @card_Ico_eq_card_Icc_sub_one («expr ᵒᵈ» α) _ _ _ _\n#align card_Ioc_eq_card_Icc_sub_one card_Ioc_eq_card_Icc_sub_one\n\n",
 "card_Iio_eq_card_Iic_sub_one":
 "theorem card_Iio_eq_card_Iic_sub_one (a : α) : (Iio a).card = (Iic a).card - 1 := by\n  rw [Iic_eq_cons_Iio, card_cons, add_tsub_cancel_right]\n#align card_Iio_eq_card_Iic_sub_one card_Iio_eq_card_Iic_sub_one\n\n",
 "card_Ico_eq_card_Icc_sub_one":
 "theorem card_Ico_eq_card_Icc_sub_one (a b : α) : (Ico a b).card = (Icc a b).card - 1 := by\n  classical\n    by_cases h : a ≤ b\n    · rw [← Ico_insert_right h, card_insert_of_not_mem right_not_mem_Ico]\n      exact (nat.add_sub_cancel _ _).symm\n    · rw [Ico_eq_empty fun h' => h h'.le, Icc_eq_empty h, card_empty, zero_tsub]\n#align card_Ico_eq_card_Icc_sub_one card_Ico_eq_card_Icc_sub_one\n\n",
 "Ioo_subset_Ioo_right":
 "theorem Ioo_subset_Ioo_right (h : b₁ ≤ b₂) : Ioo a b₁ ⊆ Ioo a b₂ :=\n  Ioo_subset_Ioo le_rfl h\n#align Ioo_subset_Ioo_right Ioo_subset_Ioo_right\n\n",
 "Ioo_subset_Ioo_left":
 "theorem Ioo_subset_Ioo_left (h : a₁ ≤ a₂) : Ioo a₂ b ⊆ Ioo a₁ b :=\n  Ioo_subset_Ioo h le_rfl\n#align Ioo_subset_Ioo_left Ioo_subset_Ioo_left\n\n",
 "Ioo_subset_Ioo":
 "theorem Ioo_subset_Ioo (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Ioo a₁ b₁ ⊆ Ioo a₂ b₂ := by\n  simpa [← coe_subset] using Set.Ioo_subset_Ioo ha hb\n#align Ioo_subset_Ioo Ioo_subset_Ioo\n\n",
 "Ioo_subset_Ioi_self":
 "theorem Ioo_subset_Ioi_self : Ioo a b ⊆ Ioi a := by simpa [← coe_subset] using Set.Ioo_subset_Ioi_self\n#align Ioo_subset_Ioi_self Ioo_subset_Ioi_self\n\n",
 "Ioo_subset_Ioc_self":
 "theorem Ioo_subset_Ioc_self : Ioo a b ⊆ Ioc a b :=\n  by\n  rw [← coe_subset, coe_Ioo, coe_Ioc]\n  exact Set.Ioo_subset_Ioc_self\n#align Ioo_subset_Ioc_self Ioo_subset_Ioc_self\n\n",
 "Ioo_subset_Iio_self":
 "theorem Ioo_subset_Iio_self : Ioo a b ⊆ Iio b := by simpa [← coe_subset] using Set.Ioo_subset_Iio_self\n#align Ioo_subset_Iio_self Ioo_subset_Iio_self\n\n",
 "Ioo_subset_Iic_self":
 "theorem Ioo_subset_Iic_self : Ioo a b ⊆ Iic b :=\n  Ioo_subset_Ioc_self.trans Ioc_subset_Iic_self\n#align Ioo_subset_Iic_self Ioo_subset_Iic_self\n\n",
 "Ioo_subset_Ico_self":
 "theorem Ioo_subset_Ico_self : Ioo a b ⊆ Ico a b :=\n  by\n  rw [← coe_subset, coe_Ioo, coe_Ico]\n  exact Set.Ioo_subset_Ico_self\n#align Ioo_subset_Ico_self Ioo_subset_Ico_self\n\n",
 "Ioo_subset_Ici_self":
 "theorem Ioo_subset_Ici_self : Ioo a b ⊆ Ici a :=\n  Ioo_subset_Ico_self.trans Ico_subset_Ici_self\n#align Ioo_subset_Ici_self Ioo_subset_Ici_self\n\n",
 "Ioo_subset_Icc_self":
 "theorem Ioo_subset_Icc_self : Ioo a b ⊆ Icc a b :=\n  Ioo_subset_Ico_self.trans Ico_subset_Icc_self\n#align Ioo_subset_Icc_self Ioo_subset_Icc_self\n\n",
 "Ioo_self":
 "@[simp]\ntheorem Ioo_self : Ioo a a = ∅ :=\n  Ioo_eq_empty <| lt_irrefl _\n#align Ioo_self Ioo_self\n\n",
 "Ioo_insert_right":
 "@[simp]\ntheorem Ioo_insert_right (h : a < b) : insert b (Ioo a b) = Ioc a b := by\n  rw [← coe_inj, coe_insert, coe_Ioo, coe_Ioc, Set.insert_eq, Set.union_comm, Set.Ioo_union_right h]\n#align Ioo_insert_right Ioo_insert_right\n\n",
 "Ioo_insert_left":
 "@[simp]\ntheorem Ioo_insert_left (h : a < b) : insert a (Ioo a b) = Ico a b := by\n  rw [← coe_inj, coe_insert, coe_Ioo, coe_Ico, Set.insert_eq, Set.union_comm, Set.Ioo_union_left h]\n#align Ioo_insert_left Ioo_insert_left\n\n",
 "Ioo_filter_lt":
 "@[simp]\ntheorem Ioo_filter_lt (a b c : α) : (Ioo a b).filter (· < c) = Ioo a (min b c) :=\n  by\n  ext\n  simp [and_assoc']\n#align Ioo_filter_lt Ioo_filter_lt\n\n",
 "Ioo_eq_empty_of_le":
 "@[simp]\ntheorem Ioo_eq_empty_of_le (h : b ≤ a) : Ioo a b = ∅ :=\n  Ioo_eq_empty h.not_lt\n#align Ioo_eq_empty_of_le Ioo_eq_empty_of_le\n\n",
 "Ioo_eq_empty_iff":
 "@[simp]\ntheorem Ioo_eq_empty_iff [DenselyOrdered α] : Ioo a b = ∅ ↔ ¬a < b := by\n  rw [← coe_eq_empty, coe_Ioo, Set.Ioo_eq_empty_iff]\n#align Ioo_eq_empty_iff Ioo_eq_empty_iff\n\n",
 "Ioo_eq_empty":
 "@[simp]\ntheorem Ioo_eq_empty (h : ¬a < b) : Ioo a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun x hx => h ((mem_Ioo.1 hx).1.trans (mem_Ioo.1 hx).2)\n#align Ioo_eq_empty Ioo_eq_empty\n\n",
 "Ioi_subset_Ici_self":
 "theorem Ioi_subset_Ici_self : Ioi a ⊆ Ici a := by simpa [← coe_subset] using Set.Ioi_subset_Ici_self\n#align Ioi_subset_Ici_self Ioi_subset_Ici_self\n\n",
 "Ioi_insert":
 "@[simp]\ntheorem Ioi_insert [decidable_eq α] (a : α) : insert a (Ioi a) = Ici a :=\n  by\n  ext\n  simp_rw [Finset.mem_insert, mem_Ici, mem_Ioi, le_iff_lt_or_eq, or_comm', eq_comm]\n#align Ioi_insert Ioi_insert\n\n",
 "Ioi_disj_union_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem Ioi_disj_union_Iio (a : α) : (Ioi a).disj_union (Iio a) (disjoint_Ioi_Iio a) = «expr ᶜ» ({a} : Finset α) :=\n  by\n  ext\n  simp [eq_comm]\n#align Ioi_disj_union_Iio Ioi_disj_union_Iio\n\n",
 "Ioc_union_Ioc_eq_Ioc":
 "@[simp]\ntheorem Ioc_union_Ioc_eq_Ioc {a b c : α} (h₁ : a ≤ b) (h₂ : b ≤ c) : Ioc a b ∪ Ioc b c = Ioc a c := by\n  rw [← coe_inj, coe_union, coe_Ioc, coe_Ioc, coe_Ioc, Set.Ioc_union_Ioc_eq_Ioc h₁ h₂]\n#align Ioc_union_Ioc_eq_Ioc Ioc_union_Ioc_eq_Ioc\n\n",
 "Ioc_subset_Ioo_right":
 "theorem Ioc_subset_Ioo_right (h : b₁ < b₂) : Ioc a b₁ ⊆ Ioo a b₂ :=\n  by\n  rw [← coe_subset, coe_Ioc, coe_Ioo]\n  exact Set.Ioc_subset_Ioo_right h\n#align Ioc_subset_Ioo_right Ioc_subset_Ioo_right\n\n",
 "Ioc_subset_Ioi_self":
 "theorem Ioc_subset_Ioi_self : Ioc a b ⊆ Ioi a := by simpa [← coe_subset] using Set.Ioc_subset_Ioi_self\n#align Ioc_subset_Ioi_self Ioc_subset_Ioi_self\n\n",
 "Ioc_subset_Ioc_right":
 "theorem Ioc_subset_Ioc_right (h : b₁ ≤ b₂) : Ioc a b₁ ⊆ Ioc a b₂ :=\n  Ioc_subset_Ioc le_rfl h\n#align Ioc_subset_Ioc_right Ioc_subset_Ioc_right\n\n",
 "Ioc_subset_Ioc_left":
 "theorem Ioc_subset_Ioc_left (h : a₁ ≤ a₂) : Ioc a₂ b ⊆ Ioc a₁ b :=\n  Ioc_subset_Ioc h le_rfl\n#align Ioc_subset_Ioc_left Ioc_subset_Ioc_left\n\n",
 "Ioc_subset_Ioc":
 "theorem Ioc_subset_Ioc (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ := by\n  simpa [← coe_subset] using Set.Ioc_subset_Ioc ha hb\n#align Ioc_subset_Ioc Ioc_subset_Ioc\n\n",
 "Ioc_subset_Iic_self":
 "theorem Ioc_subset_Iic_self : Ioc a b ⊆ Iic b := by simpa [← coe_subset] using Set.Ioc_subset_Iic_self\n#align Ioc_subset_Iic_self Ioc_subset_Iic_self\n\n",
 "Ioc_subset_Ici_self":
 "theorem Ioc_subset_Ici_self : Ioc a b ⊆ Ici a :=\n  Ioc_subset_Icc_self.trans Icc_subset_Ici_self\n#align Ioc_subset_Ici_self Ioc_subset_Ici_self\n\n",
 "Ioc_subset_Icc_self":
 "theorem Ioc_subset_Icc_self : Ioc a b ⊆ Icc a b :=\n  by\n  rw [← coe_subset, coe_Ioc, coe_Icc]\n  exact Set.Ioc_subset_Icc_self\n#align Ioc_subset_Icc_self Ioc_subset_Icc_self\n\n",
 "Ioc_self":
 "@[simp]\ntheorem Ioc_self : Ioc a a = ∅ :=\n  Ioc_eq_empty <| lt_irrefl _\n#align Ioc_self Ioc_self\n\n",
 "Ioc_insert_left":
 "@[simp]\ntheorem Ioc_insert_left (h : a ≤ b) : insert a (Ioc a b) = Icc a b := by\n  rw [← coe_inj, coe_insert, coe_Ioc, coe_Icc, Set.insert_eq, Set.union_comm, Set.Ioc_union_left h]\n#align Ioc_insert_left Ioc_insert_left\n\n",
 "Ioc_filter_lt_of_lt_right":
 "theorem Ioc_filter_lt_of_lt_right {a b c : α} [decidable_pred (· < c)] (h : b < c) :\n    (Ioc a b).filter (· < c) = Ioc a b :=\n  (Finset.filter_eq_self _).2 fun x hx => lt_of_le_of_lt (mem_Ioc.1 hx).2 h\n#align Ioc_filter_lt_of_lt_right Ioc_filter_lt_of_lt_right\n\n",
 "Ioc_erase_right":
 "@[simp]\ntheorem Ioc_erase_right (a b : α) : (Ioc a b).erase b = Ioo a b := by simp [← coe_inj]\n#align Ioc_erase_right Ioc_erase_right\n\n",
 "Ioc_eq_empty_of_le":
 "@[simp]\ntheorem Ioc_eq_empty_of_le (h : b ≤ a) : Ioc a b = ∅ :=\n  Ioc_eq_empty h.not_lt\n#align Ioc_eq_empty_of_le Ioc_eq_empty_of_le\n\n",
 "Ioc_eq_empty_iff":
 "@[simp]\ntheorem Ioc_eq_empty_iff : Ioc a b = ∅ ↔ ¬a < b := by rw [← coe_eq_empty, coe_Ioc, Set.Ioc_eq_empty_iff]\n#align Ioc_eq_empty_iff Ioc_eq_empty_iff\n\n",
 "Ioc_diff_Ioo_self":
 "@[simp]\ntheorem Ioc_diff_Ioo_self (h : a < b) : Ioc a b \\ Ioo a b = {b} := by simp [← coe_inj, h]\n#align Ioc_diff_Ioo_self Ioc_diff_Ioo_self\n\n",
 "Iio_subset_Iic_self":
 "theorem Iio_subset_Iic_self : Iio a ⊆ Iic a := by simpa [← coe_subset] using Set.Iio_subset_Iic_self\n#align Iio_subset_Iic_self Iio_subset_Iic_self\n\n",
 "Iio_insert":
 "@[simp]\ntheorem Iio_insert [decidable_eq α] (b : α) : insert b (Iio b) = Iic b :=\n  by\n  ext\n  simp_rw [Finset.mem_insert, mem_Iic, mem_Iio, le_iff_lt_or_eq, or_comm']\n#align Iio_insert Iio_insert\n\n",
 "Iio_filter_lt":
 "@[simp]\ntheorem Iio_filter_lt {α} [linear_order α] [locally_finite_order_bot α] (a b : α) :\n    (Iio a).filter (· < b) = Iio (min a b) := by\n  ext\n  simp [and_assoc']\n#align Iio_filter_lt Iio_filter_lt\n\n",
 "Iic_filter_lt_of_lt_right":
 "theorem Iic_filter_lt_of_lt_right {α} [preorder α] [locally_finite_order_bot α] {a c : α} [decidable_pred (· < c)]\n    (h : a < c) : (Iic a).filter (· < c) = Iic a :=\n  (Finset.filter_eq_self _).2 fun x hx => lt_of_le_of_lt (mem_Iic.1 hx) h\n#align Iic_filter_lt_of_lt_right Iic_filter_lt_of_lt_right\n\n",
 "Iic_erase":
 "@[simp]\ntheorem Iic_erase [decidable_eq α] (b : α) : (Iic b).erase b = Iio b :=\n  by\n  ext\n  simp_rw [Finset.mem_erase, mem_Iic, mem_Iio, lt_iff_le_and_ne, and_comm']\n#align Iic_erase Iic_erase\n\n",
 "Iic_eq_cons_Iio":
 "-- Purposefully written the other way around\ntheorem Iic_eq_cons_Iio (b : α) : Iic b = (Iio b).cons b not_mem_Iio_self := by\n  classical rw [cons_eq_insert, Iio_insert]\n#align Iic_eq_cons_Iio Iic_eq_cons_Iio\n\n",
 "Ico_union_Ico_eq_Ico":
 "theorem Ico_union_Ico_eq_Ico {a b c : α} (hab : a ≤ b) (hbc : b ≤ c) : Ico a b ∪ Ico b c = Ico a c := by\n  rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico_eq_Ico hab hbc]\n#align Ico_union_Ico_eq_Ico Ico_union_Ico_eq_Ico\n\n",
 "Ico_union_Ico'":
 "theorem Ico_union_Ico' {a b c d : α} (hcb : c ≤ b) (had : a ≤ d) : Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by\n  rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico' hcb had]\n#align Ico_union_Ico' Ico_union_Ico'\n\n",
 "Ico_union_Ico":
 "theorem Ico_union_Ico {a b c d : α} (h₁ : min a b ≤ max c d) (h₂ : min c d ≤ max a b) :\n    Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by\n  rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico h₁ h₂]\n#align Ico_union_Ico Ico_union_Ico\n\n",
 "Ico_subset_Ioo_left":
 "theorem Ico_subset_Ioo_left (h : a₁ < a₂) : Ico a₂ b ⊆ Ioo a₁ b :=\n  by\n  rw [← coe_subset, coe_Ico, coe_Ioo]\n  exact Set.Ico_subset_Ioo_left h\n#align Ico_subset_Ioo_left Ico_subset_Ioo_left\n\n",
 "Ico_subset_Iio_self":
 "theorem Ico_subset_Iio_self : Ico a b ⊆ Iio b := by simpa [← coe_subset] using Set.Ico_subset_Iio_self\n#align Ico_subset_Iio_self Ico_subset_Iio_self\n\n",
 "Ico_subset_Iic_self":
 "theorem Ico_subset_Iic_self : Ico a b ⊆ Iic b :=\n  Ico_subset_Icc_self.trans Icc_subset_Iic_self\n#align Ico_subset_Iic_self Ico_subset_Iic_self\n\n",
 "Ico_subset_Ico_union_Ico":
 "theorem Ico_subset_Ico_union_Ico {a b c : α} : Ico a c ⊆ Ico a b ∪ Ico b c :=\n  by\n  rw [← coe_subset, coe_union, coe_Ico, coe_Ico, coe_Ico]\n  exact Set.Ico_subset_Ico_union_Ico\n#align Ico_subset_Ico_union_Ico Ico_subset_Ico_union_Ico\n\n",
 "Ico_subset_Ico_right":
 "theorem Ico_subset_Ico_right (h : b₁ ≤ b₂) : Ico a b₁ ⊆ Ico a b₂ :=\n  Ico_subset_Ico le_rfl h\n#align Ico_subset_Ico_right Ico_subset_Ico_right\n\n",
 "Ico_subset_Ico_left":
 "theorem Ico_subset_Ico_left (h : a₁ ≤ a₂) : Ico a₂ b ⊆ Ico a₁ b :=\n  Ico_subset_Ico h le_rfl\n#align Ico_subset_Ico_left Ico_subset_Ico_left\n\n",
 "Ico_subset_Ico_iff":
 "theorem Ico_subset_Ico_iff {a₁ b₁ a₂ b₂ : α} (h : a₁ < b₁) : Ico a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ := by\n  rw [← coe_subset, coe_Ico, coe_Ico, Set.Ico_subset_Ico_iff h]\n#align Ico_subset_Ico_iff Ico_subset_Ico_iff\n\n",
 "Ico_subset_Ico":
 "theorem Ico_subset_Ico (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Ico a₁ b₁ ⊆ Ico a₂ b₂ := by\n  simpa [← coe_subset] using Set.Ico_subset_Ico ha hb\n#align Ico_subset_Ico Ico_subset_Ico\n\n",
 "Ico_subset_Ici_self":
 "theorem Ico_subset_Ici_self : Ico a b ⊆ Ici a := by simpa [← coe_subset] using Set.Ico_subset_Ici_self\n#align Ico_subset_Ici_self Ico_subset_Ici_self\n\n",
 "Ico_subset_Icc_self":
 "theorem Ico_subset_Icc_self : Ico a b ⊆ Icc a b :=\n  by\n  rw [← coe_subset, coe_Ico, coe_Icc]\n  exact Set.Ico_subset_Icc_self\n#align Ico_subset_Icc_self Ico_subset_Icc_self\n\n",
 "Ico_self":
 "@[simp]\ntheorem Ico_self : Ico a a = ∅ :=\n  Ico_eq_empty <| lt_irrefl _\n#align Ico_self Ico_self\n\n",
 "Ico_inter_Ico_consecutive":
 "@[simp]\ntheorem Ico_inter_Ico_consecutive (a b c : α) : Ico a b ∩ Ico b c = ∅ :=\n  (Ico_disjoint_Ico_consecutive a b c).eq_bot\n#align Ico_inter_Ico_consecutive Ico_inter_Ico_consecutive\n\n",
 "Ico_inter_Ico":
 "theorem Ico_inter_Ico {a b c d : α} : Ico a b ∩ Ico c d = Ico (max a c) (min b d) := by\n  rw [← coe_inj, coe_inter, coe_Ico, coe_Ico, coe_Ico, ← inf_eq_min, ← sup_eq_max, Set.Ico_inter_Ico]\n#align Ico_inter_Ico Ico_inter_Ico\n\n",
 "Ico_insert_right":
 "@[simp]\ntheorem Ico_insert_right (h : a ≤ b) : insert b (Ico a b) = Icc a b := by\n  rw [← coe_inj, coe_insert, coe_Icc, coe_Ico, Set.insert_eq, Set.union_comm, Set.Ico_union_right h]\n#align Ico_insert_right Ico_insert_right\n\n",
 "Ico_filter_lt_of_right_le":
 "theorem Ico_filter_lt_of_right_le [decidable_pred (· < c)] (hbc : b ≤ c) : (Ico a b).filter (· < c) = Ico a b :=\n  filter_true_of_mem fun x hx => (mem_Ico.1 hx).2.trans_le hbc\n#align Ico_filter_lt_of_right_le Ico_filter_lt_of_right_le\n\n",
 "Ico_filter_lt_of_le_right":
 "theorem Ico_filter_lt_of_le_right [decidable_pred (· < c)] (hcb : c ≤ b) : (Ico a b).filter (· < c) = Ico a c :=\n  by\n  ext x\n  rw [mem_filter, mem_Ico, mem_Ico, and_right_comm]\n  exact and_iff_left_of_imp fun h => h.2.trans_le hcb\n#align Ico_filter_lt_of_le_right Ico_filter_lt_of_le_right\n\n",
 "Ico_filter_lt_of_le_left":
 "theorem Ico_filter_lt_of_le_left [decidable_pred (· < c)] (hca : c ≤ a) : (Ico a b).filter (· < c) = ∅ :=\n  filter_false_of_mem fun x hx => (hca.trans (mem_Ico.1 hx).1).not_lt\n#align Ico_filter_lt_of_le_left Ico_filter_lt_of_le_left\n\n",
 "Ico_filter_lt":
 "@[simp]\ntheorem Ico_filter_lt (a b c : α) : ((Ico a b).filter fun x => x < c) = Ico a (min b c) :=\n  by\n  cases le_total b c\n  · rw [Ico_filter_lt_of_right_le h, min_eq_left h]\n  · rw [Ico_filter_lt_of_le_right h, min_eq_right h]\n#align Ico_filter_lt Ico_filter_lt\n\n",
 "Ico_filter_le_of_right_le":
 "theorem Ico_filter_le_of_right_le {a b : α} [decidable_pred ((· ≤ ·) b)] : (Ico a b).filter ((· ≤ ·) b) = ∅ :=\n  filter_false_of_mem fun x hx => (mem_Ico.1 hx).2.not_le\n#align Ico_filter_le_of_right_le Ico_filter_le_of_right_le\n\n",
 "Ico_filter_le_of_left_le":
 "theorem Ico_filter_le_of_left_le {a b c : α} [decidable_pred ((· ≤ ·) c)] (hac : a ≤ c) :\n    (Ico a b).filter ((· ≤ ·) c) = Ico c b := by\n  ext x\n  rw [mem_filter, mem_Ico, mem_Ico, and_comm', and_left_comm]\n  exact and_iff_right_of_imp fun h => hac.trans h.1\n#align Ico_filter_le_of_left_le Ico_filter_le_of_left_le\n\n",
 "Ico_filter_le_of_le_left":
 "theorem Ico_filter_le_of_le_left {a b c : α} [decidable_pred ((· ≤ ·) c)] (hca : c ≤ a) :\n    (Ico a b).filter ((· ≤ ·) c) = Ico a b :=\n  filter_true_of_mem fun x hx => hca.trans (mem_Ico.1 hx).1\n#align Ico_filter_le_of_le_left Ico_filter_le_of_le_left\n\n",
 "Ico_filter_le_left":
 "theorem Ico_filter_le_left {a b : α} [decidable_pred (· ≤ a)] (hab : a < b) : ((Ico a b).filter fun x => x ≤ a) = {a} :=\n  by\n  ext x\n  rw [mem_filter, mem_Ico, mem_singleton, and_right_comm, ← le_antisymm_iff, eq_comm]\n  exact and_iff_left_of_imp fun h => h.le.trans_lt hab\n#align Ico_filter_le_left Ico_filter_le_left\n\n",
 "Ico_filter_le":
 "@[simp]\ntheorem Ico_filter_le (a b c : α) : ((Ico a b).filter fun x => c ≤ x) = Ico (max a c) b :=\n  by\n  cases le_total a c\n  · rw [Ico_filter_le_of_left_le h, max_eq_right h]\n  · rw [Ico_filter_le_of_le_left h, max_eq_left h]\n#align Ico_filter_le Ico_filter_le\n\n",
 "Ico_erase_left":
 "@[simp]\ntheorem Ico_erase_left (a b : α) : (Ico a b).erase a = Ioo a b := by simp [← coe_inj]\n#align Ico_erase_left Ico_erase_left\n\n",
 "Ico_eq_empty_of_le":
 "@[simp]\ntheorem Ico_eq_empty_of_le (h : b ≤ a) : Ico a b = ∅ :=\n  Ico_eq_empty h.not_lt\n#align Ico_eq_empty_of_le Ico_eq_empty_of_le\n\n",
 "Ico_eq_empty_iff":
 "@[simp]\ntheorem Ico_eq_empty_iff : Ico a b = ∅ ↔ ¬a < b := by rw [← coe_eq_empty, coe_Ico, Set.Ico_eq_empty_iff]\n#align Ico_eq_empty_iff Ico_eq_empty_iff\n\n",
 "Ico_disjoint_Ico_consecutive":
 "theorem Ico_disjoint_Ico_consecutive (a b c : α) : Disjoint (Ico a b) (Ico b c) :=\n  disjoint_left.2 fun x hab hbc => (mem_Ico.mp hab).2.not_le (mem_Ico.mp hbc).1\n#align Ico_disjoint_Ico_consecutive Ico_disjoint_Ico_consecutive\n\n",
 "Ico_diff_Ioo_self":
 "@[simp]\ntheorem Ico_diff_Ioo_self (h : a < b) : Ico a b \\ Ioo a b = {a} := by simp [← coe_inj, h]\n#align Ico_diff_Ioo_self Ico_diff_Ioo_self\n\n",
 "Ico_diff_Ico_right":
 "@[simp]\ntheorem Ico_diff_Ico_right (a b c : α) : Ico a b \\ Ico c b = Ico a (min b c) :=\n  by\n  cases le_total b c\n  · rw [Ico_eq_empty_of_le h, sdiff_empty, min_eq_left h]\n  · ext x\n    rw [mem_sdiff, mem_Ico, mem_Ico, mem_Ico, min_eq_right h, and_assoc', not_and', not_le]\n    exact and_congr_right' ⟨fun hx => hx.2 hx.1, fun hx => ⟨hx.trans_le h, fun _ => hx⟩⟩\n#align Ico_diff_Ico_right Ico_diff_Ico_right\n\n",
 "Ico_diff_Ico_left":
 "@[simp]\ntheorem Ico_diff_Ico_left (a b c : α) : Ico a b \\ Ico a c = Ico (max a c) b :=\n  by\n  cases le_total a c\n  · ext x\n    rw [mem_sdiff, mem_Ico, mem_Ico, mem_Ico, max_eq_right h, and_right_comm, not_and, not_lt]\n    exact and_congr_left' ⟨fun hx => hx.2 hx.1, fun hx => ⟨h.trans hx, fun _ => hx⟩⟩\n  · rw [Ico_eq_empty_of_le h, sdiff_empty, max_eq_left h]\n#align Ico_diff_Ico_left Ico_diff_Ico_left\n\n",
 "Ici_erase":
 "@[simp]\ntheorem Ici_erase [decidable_eq α] (a : α) : (Ici a).erase a = Ioi a :=\n  by\n  ext\n  simp_rw [Finset.mem_erase, mem_Ici, mem_Ioi, lt_iff_le_and_ne, and_comm', ne_comm]\n#align Ici_erase Ici_erase\n\n",
 "Ici_eq_cons_Ioi":
 "-- Purposefully written the other way around\ntheorem Ici_eq_cons_Ioi (a : α) : Ici a = (Ioi a).cons a not_mem_Ioi_self := by\n  classical rw [cons_eq_insert, Ioi_insert]\n#align Ici_eq_cons_Ioi Ici_eq_cons_Ioi\n\n",
 "Icc_subset_uIcc'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem Icc_subset_uIcc' : Icc b a ⊆ finset.uIcc a b :=\n  Icc_subset_Icc inf_le_right le_sup_left\n#align Icc_subset_uIcc' Icc_subset_uIcc'\n\n",
 "Icc_subset_uIcc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem Icc_subset_uIcc : Icc a b ⊆ finset.uIcc a b :=\n  Icc_subset_Icc inf_le_left le_sup_right\n#align Icc_subset_uIcc Icc_subset_uIcc\n\n",
 "Icc_subset_Ioo_iff":
 "theorem Icc_subset_Ioo_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioo a₂ b₂ ↔ a₂ < a₁ ∧ b₁ < b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Ioo, Set.Icc_subset_Ioo_iff h₁]\n#align Icc_subset_Ioo_iff Icc_subset_Ioo_iff\n\n",
 "Icc_subset_Ioc_iff":
 "theorem Icc_subset_Ioc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ a₂ < a₁ ∧ b₁ ≤ b₂ :=\n  (Icc_subset_Ico_iff h₁.dual).trans and_comm\n#align Icc_subset_Ioc_iff Icc_subset_Ioc_iff\n\n",
 "Icc_subset_Iic_self":
 "theorem Icc_subset_Iic_self : Icc a b ⊆ Iic b := by simpa [← coe_subset] using Set.Icc_subset_Iic_self\n#align Icc_subset_Iic_self Icc_subset_Iic_self\n\n",
 "Icc_subset_Ico_right":
 "theorem Icc_subset_Ico_right (h : b₁ < b₂) : Icc a b₁ ⊆ Ico a b₂ :=\n  by\n  rw [← coe_subset, coe_Icc, coe_Ico]\n  exact Set.Icc_subset_Ico_right h\n#align Icc_subset_Ico_right Icc_subset_Ico_right\n\n",
 "Icc_subset_Ico_iff":
 "theorem Icc_subset_Ico_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ < b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Ico, Set.Icc_subset_Ico_iff h₁]\n#align Icc_subset_Ico_iff Icc_subset_Ico_iff\n\n",
 "Icc_subset_Ici_self":
 "theorem Icc_subset_Ici_self : Icc a b ⊆ Ici a := by simpa [← coe_subset] using Set.Icc_subset_Ici_self\n#align Icc_subset_Ici_self Icc_subset_Ici_self\n\n",
 "Icc_subset_Icc_right":
 "theorem Icc_subset_Icc_right (h : b₁ ≤ b₂) : Icc a b₁ ⊆ Icc a b₂ :=\n  Icc_subset_Icc le_rfl h\n#align Icc_subset_Icc_right Icc_subset_Icc_right\n\n",
 "Icc_subset_Icc_left":
 "theorem Icc_subset_Icc_left (h : a₁ ≤ a₂) : Icc a₂ b ⊆ Icc a₁ b :=\n  Icc_subset_Icc h le_rfl\n#align Icc_subset_Icc_left Icc_subset_Icc_left\n\n",
 "Icc_subset_Icc_iff":
 "theorem Icc_subset_Icc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Icc a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Icc, Set.Icc_subset_Icc_iff h₁]\n#align Icc_subset_Icc_iff Icc_subset_Icc_iff\n\n",
 "Icc_subset_Icc":
 "theorem Icc_subset_Icc (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Icc a₁ b₁ ⊆ Icc a₂ b₂ := by\n  simpa [← coe_subset] using Set.Icc_subset_Icc ha hb\n#align Icc_subset_Icc Icc_subset_Icc\n\n",
 "Icc_ssubset_Icc_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem Icc_ssubset_Icc_right (hI : a₂ ≤ b₂) (ha : a₂ ≤ a₁) (hb : b₁ < b₂) : «expr ⊂ » (Icc a₁ b₁) (Icc a₂ b₂) :=\n  by\n  rw [← coe_ssubset, coe_Icc, coe_Icc]\n  exact Set.Icc_ssubset_Icc_right hI ha hb\n#align Icc_ssubset_Icc_right Icc_ssubset_Icc_right\n\n",
 "Icc_ssubset_Icc_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n--TODO: `Ico_subset_Ioo_iff`, `Ioc_subset_Ioo_iff`\ntheorem Icc_ssubset_Icc_left (hI : a₂ ≤ b₂) (ha : a₂ < a₁) (hb : b₁ ≤ b₂) : «expr ⊂ » (Icc a₁ b₁) (Icc a₂ b₂) :=\n  by\n  rw [← coe_ssubset, coe_Icc, coe_Icc]\n  exact Set.Icc_ssubset_Icc_left hI ha hb\n#align Icc_ssubset_Icc_left Icc_ssubset_Icc_left\n\n",
 "Icc_self":
 "@[simp]\ntheorem Icc_self (a : α) : Icc a a = {a} := by rw [← coe_eq_singleton, coe_Icc, Set.Icc_self]\n#align Icc_self Icc_self\n\n",
 "Icc_min_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.uIcc -/\ntheorem Icc_min_max : Icc (min a b) (max a b) = finset.uIcc a b :=\n  rfl\n#align Icc_min_max Icc_min_max\n\n",
 "Icc_filter_lt_of_lt_right":
 "theorem Icc_filter_lt_of_lt_right {a b c : α} [decidable_pred (· < c)] (h : b < c) :\n    (Icc a b).filter (· < c) = Icc a b :=\n  (Finset.filter_eq_self _).2 fun x hx => lt_of_le_of_lt (mem_Icc.1 hx).2 h\n#align Icc_filter_lt_of_lt_right Icc_filter_lt_of_lt_right\n\n",
 "Icc_erase_right":
 "@[simp]\ntheorem Icc_erase_right (a b : α) : (Icc a b).erase b = Ico a b := by simp [← coe_inj]\n#align Icc_erase_right Icc_erase_right\n\n",
 "Icc_erase_left":
 "@[simp]\ntheorem Icc_erase_left (a b : α) : (Icc a b).erase a = Ioc a b := by simp [← coe_inj]\n#align Icc_erase_left Icc_erase_left\n\n",
 "Icc_eq_singleton_iff":
 "@[simp]\ntheorem Icc_eq_singleton_iff : Icc a b = {c} ↔ a = c ∧ b = c := by\n  rw [← coe_eq_singleton, coe_Icc, Set.Icc_eq_singleton_iff]\n#align Icc_eq_singleton_iff Icc_eq_singleton_iff\n\n",
 "Icc_eq_empty_of_lt":
 "@[simp]\ntheorem Icc_eq_empty_of_lt (h : b < a) : Icc a b = ∅ :=\n  Icc_eq_empty h.not_le\n#align Icc_eq_empty_of_lt Icc_eq_empty_of_lt\n\n",
 "Icc_eq_empty_iff":
 "@[simp]\ntheorem Icc_eq_empty_iff : Icc a b = ∅ ↔ ¬a ≤ b := by rw [← coe_eq_empty, coe_Icc, Set.Icc_eq_empty_iff]\n#align Icc_eq_empty_iff Icc_eq_empty_iff\n\n",
 "Icc_eq_cons_Ioc":
 "theorem Icc_eq_cons_Ioc (h : a ≤ b) : Icc a b = (Ioc a b).cons a left_not_mem_Ioc := by\n  classical rw [cons_eq_insert, Ioc_insert_left h]\n#align Icc_eq_cons_Ioc Icc_eq_cons_Ioc\n\n",
 "Icc_eq_cons_Ico":
 "-- Those lemmas are purposefully the other way around\ntheorem Icc_eq_cons_Ico (h : a ≤ b) : Icc a b = (Ico a b).cons b right_not_mem_Ico := by\n  classical rw [cons_eq_insert, Ico_insert_right h]\n#align Icc_eq_cons_Ico Icc_eq_cons_Ico\n\n",
 "Icc_diff_both":
 "@[simp]\ntheorem Icc_diff_both (a b : α) : Icc a b \\ {a, b} = Ioo a b := by simp [← coe_inj]\n#align Icc_diff_both Icc_diff_both\n\n",
 "Icc_diff_Ioo_self":
 "@[simp]\ntheorem Icc_diff_Ioo_self (h : a ≤ b) : Icc a b \\ Ioo a b = {a, b} := by simp [← coe_inj, h]\n#align Icc_diff_Ioo_self Icc_diff_Ioo_self\n\n",
 "Icc_diff_Ioc_self":
 "@[simp]\ntheorem Icc_diff_Ioc_self (h : a ≤ b) : Icc a b \\ Ioc a b = {a} := by simp [← coe_inj, h]\n#align Icc_diff_Ioc_self Icc_diff_Ioc_self\n\n",
 "Icc_diff_Ico_self":
 "@[simp]\ntheorem Icc_diff_Ico_self (h : a ≤ b) : Icc a b \\ Ico a b = {b} := by simp [← coe_inj, h]\n#align Icc_diff_Ico_self Icc_diff_Ico_self\n\n"}