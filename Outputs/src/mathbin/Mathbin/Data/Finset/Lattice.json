{"to_dual_sup'":
 "@[simp]\ntheorem to_dual_sup' [SemilatticeSup α] {s : Finset ι} (hs : s.nonempty) (f : ι → α) :\n    toDual (s.sup' hs f) = s.inf' hs (toDual ∘ f) :=\n  rfl\n#align to_dual_sup' to_dual_sup'\n\n",
 "to_dual_min'":
 "theorem to_dual_min' {s : Finset α} (hs : s.nonempty) : toDual (min' s hs) = max' (s.image toDual) (hs.image _) :=\n  by\n  convert rfl\n  exact image_id\n#align to_dual_min' to_dual_min'\n\n",
 "to_dual_max'":
 "theorem to_dual_max' {s : Finset α} (hs : s.nonempty) : toDual (max' s hs) = min' (s.image toDual) (hs.image _) :=\n  by\n  convert rfl\n  exact image_id\n#align to_dual_max' to_dual_max'\n\n",
 "to_dual_inf'":
 "@[simp]\ntheorem to_dual_inf' [SemilatticeInf α] {s : Finset ι} (hs : s.nonempty) (f : ι → α) :\n    toDual (s.inf' hs f) = s.sup' hs (toDual ∘ f) :=\n  rfl\n#align to_dual_inf' to_dual_inf'\n\n",
 "toDual_sup":
 "#print toDual_sup /-\n@[simp]\ntheorem toDual_sup [SemilatticeSup α] [OrderBot α] (s : Finset β) (f : β → α) : toDual (s.sup f) = s.inf (toDual ∘ f) :=\n  rfl\n#align to_dual_sup toDual_sup\n-/\n\n",
 "toDual_inf":
 "#print toDual_inf /-\n@[simp]\ntheorem toDual_inf [SemilatticeInf α] [OrderTop α] (s : Finset β) (f : β → α) : toDual (s.inf f) = s.sup (toDual ∘ f) :=\n  rfl\n#align to_dual_inf toDual_inf\n-/\n\n",
 "supᵢ_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_union /-\ntheorem supᵢ_union {f : α → β} {s t : Finset α} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) =\n      «expr ⊔ » («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x))\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x)) :=\n  by simp [supᵢ_or, supᵢ_sup_eq]\n#align supr_union supᵢ_union\n-/\n\n",
 "supᵢ_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_singleton /-\ntheorem supᵢ_singleton (a : α) (s : α → β) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s x) = s a := by\n  simp\n#align supr_singleton supᵢ_singleton\n-/\n\n",
 "supᵢ_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_insert /-\ntheorem supᵢ_insert (a : α) (s : Finset α) (t : α → β) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t x) =\n      «expr ⊔ » (t a)\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t x)) :=\n  by\n  rw [insert_eq]\n  simp only [supᵢ_union, Finset.supᵢ_singleton]\n#align supr_insert supᵢ_insert\n-/\n\n",
 "supᵢ_eq_supᵢ_finset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_eq_supᵢ_finset' /-\n/-- Supremum of `s i`, `i : ι`, is equal to the supremum over `t : finset ι` of suprema\n`⨆ i ∈ t, s i`. This version works for `ι : Sort*`. See `supr_eq_supr_finset` for a version\nthat assumes `ι : Type*` but has no `plift`s. -/\ntheorem supᵢ_eq_supᵢ_finset' (s : ι' → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (s (PLift.down i))) :=\n  by rw [← supᵢ_eq_supᵢ_finset, ← equiv.plift.surjective.supr_comp] <;> rfl\n#align supr_eq_supr_finset' supᵢ_eq_supᵢ_finset'\n-/\n\n",
 "supᵢ_eq_supᵢ_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print supᵢ_eq_supᵢ_finset /-\n/-- Supremum of `s i`, `i : ι`, is equal to the supremum over `t : finset ι` of suprema\n`⨆ i ∈ t, s i`. This version assumes `ι` is a `Type*`. See `supr_eq_supr_finset'` for a version\nthat works for `ι : Sort*`. -/\ntheorem supᵢ_eq_supᵢ_finset (s : ι → α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s i)) :=\n  by\n  classical exact\n      le_antisymm (supᵢ_le fun b => le_supᵢ_of_le {b} <| le_supᵢ_of_le b <| le_supᵢ_of_le (by simp) <| le_rfl)\n        (supᵢ_le fun t => supᵢ_le fun b => supᵢ_le fun hb => le_supᵢ _ _)\n#align supr_eq_supr_finset supᵢ_eq_supᵢ_finset\n-/\n\n",
 "supr_option_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_option_to_finset (o : Option α) (f : α → β) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) :=\n  by simp\n#align supr_option_to_finset supr_option_to_finset\n\n",
 "supr_insert_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_insert_update {x : α} {t : Finset α} (f : α → β) {s : β} (hx : x ∉ t) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (Function.update f x s i) =\n      «expr ⊔ » s\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :=\n  by\n  simp only [Finset.supᵢ_insert, update_same]\n  rcongr (i hi); apply update_noteq; rintro rfl; exact hx hi\n#align supr_insert_update supr_insert_update\n\n",
 "supr_finset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_finset_image {f : γ → α} {g : α → β} {s : Finset γ} :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g x) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (g (f y)) :=\n  by rw [← supr_coe, coe_image, supᵢ_image, supr_coe]\n#align supr_finset_image supr_finset_image\n\n",
 "supr_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_coe [SupSet β] (f : α → β) (s : Finset α) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f x) :=\n  rfl\n#align supr_coe supr_coe\n\n",
 "supr_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_bUnion (s : Finset γ) (t : γ → Finset α) (f : α → β) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f y) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f y) :=\n  by simp [@supᵢ_comm _ α, supᵢ_and]\n#align supr_bUnion supr_bUnion\n\n",
 "sup_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_union [DecidableEq β] : (s₁ ∪ s₂).sup f = «expr ⊔ » (s₁.sup f) (s₂.sup f) :=\n  Finset.induction_on s₁ (by rw [empty_union, sup_empty, bot_sup_eq]) fun a s has ih => by\n    rw [insert_union, sup_insert, sup_insert, ih, sup_assoc]\n#align sup_union sup_union\n\n",
 "sup_to_finset":
 "@[simp]\ntheorem sup_to_finset {α β} [DecidableEq β] (s : Finset α) (f : α → Multiset β) :\n    (s.sup f).to_finset = s.sup fun x => (f x).to_finset :=\n  comp_sup_eq_sup_comp Multiset.toFinset toFinset_union rfl\n#align sup_to_finset sup_to_finset\n\n",
 "sup_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_sup : s.sup («expr ⊔ » f g) = «expr ⊔ » (s.sup f) (s.sup g) :=\n  by\n  refine' Finset.cons_induction_on s _ fun b t _ h => _\n  · rw [sup_empty, sup_empty, sup_empty, bot_sup_eq]\n  · rw [sup_cons, sup_cons, sup_cons, h]\n    exact sup_sup_sup_comm _ _ _ _\n#align sup_sup sup_sup\n\n",
 "sup_singleton''":
 "@[simp]\ntheorem sup_singleton'' [DecidableEq α] (s : Finset β) (f : β → α) : (s.sup fun b => {f b}) = s.image f :=\n  by\n  ext a\n  rw [mem_sup, mem_image]\n  simp only [mem_singleton, eq_comm]\n#align sup_singleton'' sup_singleton''\n\n",
 "sup_singleton'":
 "@[simp]\ntheorem sup_singleton' [DecidableEq α] (s : Finset α) : s.sup singleton = s :=\n  (s.sup_singleton'' _).trans image_id\n#align sup_singleton' sup_singleton'\n\n",
 "sup_singleton":
 "@[simp]\ntheorem sup_singleton {b : β} : ({b} : Finset β).sup f = f b :=\n  sup_singleton\n#align sup_singleton sup_singleton\n\n",
 "sup_set_eq_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem sup_set_eq_bUnion (s : Finset α) (f : α → Set β) :\n    s.sup f = «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) :=\n  sup_eq_supᵢ _ _\n#align sup_set_eq_bUnion sup_set_eq_bUnion\n\n",
 "sup_sdiff_right":
 "#print sup_sdiff_right /-\ntheorem sup_sdiff_right {α β : Type _} [GeneralizedBooleanAlgebra α] (s : Finset β) (f : β → α) (a : α) :\n    (s.sup fun b => f b \\ a) = s.sup f \\ a :=\n  by\n  refine' Finset.cons_induction_on s _ fun b t _ h => _\n  · rw [sup_empty, sup_empty, bot_sdiff]\n  · rw [sup_cons, sup_cons, h, sup_sdiff]\n#align sup_sdiff_right sup_sdiff_right\n-/\n\n",
 "sup_sdiff_left":
 "#print sup_sdiff_left /-\ntheorem sup_sdiff_left (s : Finset ι) (f : ι → α) (a : α) : (s.sup fun b => a \\ f b) = a \\ s.inf f :=\n  by\n  refine' Finset.cons_induction_on s _ fun b t _ h => _\n  · rw [sup_empty, inf_empty, sdiff_top]\n  · rw [sup_cons, inf_cons, h, sdiff_inf]\n#align sup_sdiff_left sup_sdiff_left\n-/\n\n",
 "sup_product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem sup_product_right (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (finset.product s t).sup f = t.sup fun i' => s.sup fun i => f ⟨i, i'⟩ := by rw [sup_product_left, Finset.sup_comm]\n#align sup_product_right sup_product_right\n\n",
 "sup_product_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- See also `finset.product_bUnion`. -/\ntheorem sup_product_left (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (finset.product s t).sup f = s.sup fun i => t.sup fun i' => f ⟨i, i'⟩ :=\n  by\n  simp only [le_antisymm_iff, Finset.sup_le_iff, mem_product, and_imp, Prod.forall]\n  exact ⟨fun b c hb hc => (le_sup hb).trans' <| le_sup hc, fun b hb c hc => le_sup <| mem_product.2 ⟨hb, hc⟩⟩\n#align sup_product_left sup_product_left\n\n",
 "sup_of_mem":
 "theorem sup_of_mem {s : Finset β} (f : β → α) {b : β} (h : b ∈ s) : ∃ a : α, s.sup (coe ∘ f : β → WithBot α) = ↑a :=\n  Exists.imp (fun a => Exists.fst) (@le_sup (WithBot α) _ _ _ _ _ _ h (f b) rfl)\n#align sup_of_mem sup_of_mem\n\n",
 "sup_mul_le_mul_sup_of_nonneg":
 "theorem sup_mul_le_mul_sup_of_nonneg [LinearOrderedSemiring α] [OrderBot α] {a b : ι → α} (s : Finset ι)\n    (ha : ∀ i ∈ s, 0 ≤ a i) (hb : ∀ i ∈ s, 0 ≤ b i) : s.sup (a * b) ≤ s.sup a * s.sup b :=\n  Finset.sup_le fun i hi => mul_le_mul (le_sup hi) (le_sup hi) (hb _ hi) ((ha _ hi).trans <| le_sup hi)\n#align sup_mul_le_mul_sup_of_nonneg sup_mul_le_mul_sup_of_nonneg\n\n",
 "sup_mono_fun":
 "theorem sup_mono_fun {g : β → α} (h : ∀ b ∈ s, f b ≤ g b) : s.sup f ≤ s.sup g :=\n  Finset.sup_le fun b hb => le_trans (h b hb) (le_sup hb)\n#align sup_mono_fun sup_mono_fun\n\n",
 "sup_mono":
 "theorem sup_mono (h : s₁ ⊆ s₂) : s₁.sup f ≤ s₂.sup f :=\n  Finset.sup_le fun b hb => le_sup <| h hb\n#align sup_mono sup_mono\n\n",
 "sup_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n-- If we acquire sublattices\n-- the hypotheses should be reformulated as `s : subsemilattice_sup_bot`\ntheorem sup_mem (s : Set α) (w₁ : «expr⊥» ∈ s) (w₂ : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), «expr ⊔ » x y ∈ s) {ι : Type _}\n    (t : Finset ι) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.sup p ∈ s :=\n  @sup_induction _ _ _ _ _ _ (· ∈ s) w₁ w₂ h\n#align sup_mem sup_mem\n\n",
 "sup_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n@[simp]\ntheorem sup_map (s : Finset γ) (f : «expr ↪ » γ β) (g : β → α) : (s.map f).sup g = s.sup (g ∘ f) :=\n  fold_map\n#align sup_map sup_map\n\n",
 "sup_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print sup_lt_iff /-\n@[simp]\nprotected theorem sup_lt_iff (ha : «expr⊥» < a) : s.sup f < a ↔ ∀ b ∈ s, f b < a :=\n  ⟨fun hs b hb => lt_of_le_of_lt (le_sup hb) hs,\n    Finset.cons_induction_on s (fun _ => ha) fun c t hc => by\n      simpa only [sup_cons, sup_lt_iff, mem_cons, forall_eq_or_imp] using And.imp_right⟩\n#align sup_lt_iff sup_lt_iff\n-/\n\n",
 "sup_le_of_le_directed":
 "theorem sup_le_of_le_directed {α : Type _} [SemilatticeSup α] [OrderBot α] (s : Set α) (hs : s.nonempty)\n    (hdir : DirectedOn (· ≤ ·) s) (t : Finset α) : (∀ x ∈ t, ∃ y ∈ s, x ≤ y) → ∃ x, x ∈ s ∧ t.sup id ≤ x := by\n  classical\n    apply Finset.induction_on t\n    ·\n      simpa only [forall_prop_of_true, and_true_iff, forall_prop_of_false, bot_le, not_false_iff, sup_empty,\n        forall_true_iff, not_mem_empty]\n    · intro a r har ih h\n      have incs : ↑r ⊆ ↑(insert a r) := by\n        rw [Finset.coe_subset]\n        apply Finset.subset_insert\n      -- x ∈ s is above the sup of r\n      obtain ⟨x, ⟨hxs, hsx_sup⟩⟩ := ih fun x hx => h x <| incs hx\n      -- y ∈ s is above a\n      obtain ⟨y, hys, hay⟩ := h a (Finset.mem_insert_self a r)\n      -- z ∈ s is above x and y\n      obtain ⟨z, hzs, ⟨hxz, hyz⟩⟩ := hdir x hxs y hys\n      use z, hzs\n      rw [sup_insert, id.def, sup_le_iff]\n      exact ⟨le_trans hay hyz, le_trans hsx_sup hxz⟩\n#align sup_le_of_le_directed sup_le_of_le_directed\n\n",
 "sup_le_iff":
 "#print sup_le_iff /-\n@[simp]\nprotected theorem sup_le_iff {a : α} : s.sup f ≤ a ↔ ∀ b ∈ s, f b ≤ a :=\n  by\n  apply iff.trans Multiset.sup_le\n  simp only [Multiset.mem_map, and_imp, exists_imp]\n  exact ⟨fun k b hb => k _ _ hb rfl, fun k a' b hb h => h ▸ k _ hb⟩\n#align sup_le_iff sup_le_iff\n-/\n\n",
 "sup_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_ite (p : β → Prop) [DecidablePred p] :\n    (s.sup fun i => ite (p i) (f i) (g i)) = «expr ⊔ » ((s.filter p).sup f) ((s.filter fun i => ¬p i).sup g) :=\n  fold_ite _\n#align sup_ite sup_ite\n\n",
 "sup_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_insert [DecidableEq β] {b : β} : (insert b s : Finset β).sup f = «expr ⊔ » (f b) (s.sup f) :=\n  fold_insert_idem\n#align sup_insert sup_insert\n\n",
 "sup_inf_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem sup_inf_distrib_right (s : Finset ι) (f : ι → α) (a : α) :\n    «expr ⊓ » (s.sup f) a = s.sup fun i => «expr ⊓ » (f i) a :=\n  by\n  rw [_root_.inf_comm, s.sup_inf_distrib_left]\n  simp_rw [_root_.inf_comm]\n#align sup_inf_distrib_right sup_inf_distrib_right\n\n",
 "sup_inf_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem sup_inf_distrib_left (s : Finset ι) (f : ι → α) (a : α) :\n    «expr ⊓ » a (s.sup f) = s.sup fun i => «expr ⊓ » a (f i) :=\n  by\n  induction' s using Finset.cons_induction with i s hi h\n  · simp_rw [Finset.sup_empty, inf_bot_eq]\n  · rw [sup_cons, sup_cons, inf_sup_left, h]\n#align sup_inf_distrib_left sup_inf_distrib_left\n\n",
 "sup_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_induction {p : α → Prop} (hb : p («expr⊥»)) (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p («expr ⊔ » a₁ a₂))\n    (hs : ∀ b ∈ s, p (f b)) : p (s.sup f) :=\n  by\n  induction' s using Finset.cons_induction with c s hc ih\n  · exact hb\n  · rw [sup_cons]\n    apply hp\n    · exact hs c (mem_cons.2 (or.inl rfl))\n    · exact ih fun b h => hs b (mem_cons.2 (or.inr h))\n#align sup_induction sup_induction\n\n",
 "sup_image":
 "theorem sup_image [DecidableEq β] (s : Finset γ) (f : γ → β) (g : β → α) : (s.image f).sup g = s.sup (g ∘ f) :=\n  fold_image_idem\n#align sup_image sup_image\n\n",
 "sup_id_set_eq_sUnion":
 "theorem sup_id_set_eq_sUnion (s : Finset (Set α)) : s.sup id = ⋃₀ ↑s :=\n  sup_id_eq_supₛ _\n#align sup_id_set_eq_sUnion sup_id_set_eq_sUnion\n\n",
 "sup_id_eq_Sup":
 "theorem sup_id_eq_Sup [CompleteLattice α] (s : Finset α) : s.sup id = supₛ s := by simp [supₛ_eq_supᵢ, sup_eq_supᵢ]\n#align sup_id_eq_Sup sup_id_eq_Sup\n\n",
 "sup_erase_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem sup_erase_bot [DecidableEq α] (s : Finset α) : (s.erase («expr⊥»)).sup id = s.sup id :=\n  by\n  refine' (sup_mono (s.erase_subset _)).antisymm (Finset.sup_le_iff.2 fun a ha => _)\n  obtain rfl | ha' := eq_or_ne a («expr⊥»)\n  · exact bot_le\n  · exact le_sup (mem_erase.2 ⟨ha', ha⟩)\n#align sup_erase_bot sup_erase_bot\n\n",
 "sup_eq_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print sup_eq_supᵢ /-\ntheorem sup_eq_supᵢ [CompleteLattice β] (s : Finset α) (f : α → β) :\n    s.sup f = «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f a) :=\n  le_antisymm (Finset.sup_le fun a ha => le_supᵢ_of_le a <| le_supᵢ _ ha) (supᵢ_le fun a => supᵢ_le fun ha => le_sup ha)\n#align sup_eq_supr sup_eq_supᵢ\n-/\n\n",
 "sup_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print sup_eq_bot_iff /-\n@[simp]\ntheorem sup_eq_bot_iff (f : β → α) (S : Finset β) : S.sup f = «expr⊥» ↔ ∀ s ∈ S, f s = «expr⊥» := by\n  classical induction' S using Finset.induction with a S haS hi <;> simp [*]\n#align sup_eq_bot_iff sup_eq_bot_iff\n-/\n\n",
 "sup_eq_bUnion":
 "theorem sup_eq_bUnion {α β} [DecidableEq β] (s : Finset α) (t : α → Finset β) : s.sup t = s.bUnion t :=\n  by\n  ext\n  rw [mem_sup, mem_bUnion]\n#align sup_eq_bUnion sup_eq_bUnion\n\n",
 "sup_eq_Sup_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem sup_eq_Sup_image [CompleteLattice β] (s : Finset α) (f : α → β) : s.sup f = supₛ («expr '' » f s) := by\n  classical rw [← Finset.coe_image, ← sup_id_eq_Sup, sup_image, function.comp.left_id]\n#align sup_eq_Sup_image sup_eq_Sup_image\n\n",
 "sup_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem sup_empty : (∅ : Finset β).sup f = «expr⊥» :=\n  fold_empty\n#align sup_empty sup_empty\n\n",
 "sup_def":
 "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n-- TODO: define with just `[has_bot α]` where some lemmas hold without requiring `[order_bot α]`\ntheorem sup_def : s.sup f = (s.1.map f).sup :=\n  rfl\n#align sup_def sup_def\n\n",
 "sup_const_le":
 "theorem sup_const_le : (s.sup fun _ => a) ≤ a :=\n  Finset.sup_le fun _ _ => le_rfl\n#align sup_const_le sup_const_le\n\n",
 "sup_const":
 "theorem sup_const {s : Finset β} (h : s.nonempty) (c : α) : (s.sup fun _ => c) = c :=\n  eq_of_forall_ge_iff fun b => Finset.sup_le_iff.trans h.forall_const\n#align sup_const sup_const\n\n",
 "sup_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_cons {b : β} (h : b ∉ s) : (cons b s h).sup f = «expr ⊔ » (f b) (s.sup f) :=\n  fold_cons h\n#align sup_cons sup_cons\n\n",
 "sup_congr":
 "theorem sup_congr {f g : β → α} (hs : s₁ = s₂) (hfg : ∀ a ∈ s₂, f a = g a) : s₁.sup f = s₂.sup g := by\n  subst hs <;> exact Finset.fold_congr hfg\n#align sup_congr sup_congr\n\n",
 "sup_comm":
 "#print sup_comm /-\nprotected theorem sup_comm (s : Finset β) (t : Finset γ) (f : β → γ → α) :\n    (s.sup fun b => t.sup (f b)) = t.sup fun c => s.sup fun b => f b c :=\n  by\n  refine' eq_of_forall_ge_iff fun a => _\n  simp_rw [Finset.sup_le_iff]\n  exact ⟨fun h c hc b hb => h b hb c hc, fun h b hb c hc => h c hc b hb⟩\n#align sup_comm sup_comm\n-/\n\n",
 "sup_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- Computing `sup` in a subtype (closed under `sup`) is the same as computing it in `α`. -/\ntheorem sup_coe {P : α → Prop} {Pbot : P («expr⊥»)} {Psup : ∀ ⦃x y⦄, P x → P y → P («expr ⊔ » x y)} (t : Finset β)\n    (f : β → { x : α // P x }) :\n    (@sup _ _ (Subtype.semilatticeSup Psup) (Subtype.orderBot Pbot) t f : α) = t.sup fun x => f x := by\n  rw [comp_sup_eq_sup_comp coe] <;> intros <;> rfl\n#align sup_coe sup_coe\n\n",
 "sup_closed_of_sup_closed":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a b «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_closed_of_sup_closed {s : Set α} (t : Finset α) (htne : t.nonempty) (h_subset : ↑t ⊆ s)\n    (h : ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), «expr ⊔ » a b ∈ s) : t.sup id ∈ s :=\n  sup'_eq_sup htne id ▸ sup'_induction _ _ h h_subset\n#align sup_closed_of_sup_closed sup_closed_of_sup_closed\n\n",
 "sup_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem sup_bot (s : Finset β) : (s.sup fun _ => «expr⊥») = («expr⊥» : α) :=\n  by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · exact sup_empty\n  · exact sup_const hs _\n#align sup_bot sup_bot\n\n",
 "sup_bUnion":
 "@[simp]\ntheorem sup_bUnion [DecidableEq β] (s : Finset γ) (t : γ → Finset β) :\n    (s.bUnion t).sup f = s.sup fun x => (t x).sup f :=\n  eq_of_forall_ge_iff fun c => by simp [@forall_swap _ β]\n#align sup_bUnion sup_bUnion\n\n",
 "sup_attach":
 "@[simp]\ntheorem sup_attach (s : Finset β) (f : β → α) : (s.attach.sup fun x => f x) = s.sup f :=\n  (s.attach.sup_map (Function.Embedding.subtype _) f).symm.trans <| congr_arg _ attach_map_val\n#align sup_attach sup_attach\n\n",
 "sup_apply":
 "@[simp]\nprotected theorem sup_apply (s : Finset α) (f : α → ∀ b : β, C b) (b : β) : s.sup f b = s.sup fun a => f a b :=\n  comp_sup_eq_sup_comp (fun x : ∀ b : β, C b => x b) (fun i j => rfl) rfl\n#align sup_apply sup_apply\n\n",
 "sup'_singleton":
 "@[simp]\ntheorem sup'_singleton {b : β} {h : ({b} : Finset β).nonempty} : ({b} : Finset β).sup' h f = f b :=\n  rfl\n#align sup'_singleton sup'_singleton\n\n",
 "sup'_mul_le_mul_sup'_of_nonneg":
 "theorem sup'_mul_le_mul_sup'_of_nonneg [LinearOrderedSemiring α] {a b : ι → α} (s : Finset ι) (H : s.nonempty)\n    (ha : ∀ i ∈ s, 0 ≤ a i) (hb : ∀ i ∈ s, 0 ≤ b i) : s.sup' H (a * b) ≤ s.sup' H a * s.sup' H b :=\n  sup'_le _ _ fun i hi => mul_le_mul (le_sup' _ hi) (le_sup' _ hi) (hb _ hi) ((ha _ hi).trans <| le_sup' _ hi)\n#align sup'_mul_le_mul_sup'_of_nonneg sup'_mul_le_mul_sup'_of_nonneg\n\n",
 "sup'_mem":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup'_mem (s : Set α) (w : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), «expr ⊔ » x y ∈ s) {ι : Type _} (t : Finset ι)\n    (H : t.nonempty) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.sup' H p ∈ s :=\n  sup'_induction H p w h\n#align sup'_mem sup'_mem\n\n",
 "sup'_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n@[simp]\ntheorem sup'_map {s : Finset γ} {f : «expr ↪ » γ β} (g : β → α) (hs : (s.map f).nonempty)\n    (hs' : s.nonempty := Finset.map_nonempty.mp hs) : (s.map f).sup' hs g = s.sup' hs' (g ∘ f) := by\n  rw [← WithBot.coe_eq_coe, coe_sup', sup_map, coe_sup']\n#align sup'_map sup'_map\n\n",
 "sup'_lt_iff":
 "@[simp]\ntheorem sup'_lt_iff : s.sup' H f < a ↔ ∀ i ∈ s, f i < a :=\n  by\n  rw [← WithBot.coe_lt_coe, coe_sup', Finset.sup_lt_iff (WithBot.bot_lt_coe a)]\n  exact ball_congr fun b hb => WithBot.coe_lt_coe\n#align sup'_lt_iff sup'_lt_iff\n\n",
 "sup'_le_iff":
 "@[simp]\ntheorem sup'_le_iff {a : α} : s.sup' H f ≤ a ↔ ∀ b ∈ s, f b ≤ a :=\n  iff.intro (fun h b hb => trans (le_sup' f hb) h) (sup'_le H f)\n#align sup'_le_iff sup'_le_iff\n\n",
 "sup'_le":
 "theorem sup'_le {a : α} (hs : ∀ b ∈ s, f b ≤ a) : s.sup' H f ≤ a :=\n  by\n  rw [← WithBot.coe_le_coe, coe_sup']\n  exact Finset.sup_le fun b h => WithBot.coe_le_coe.2 <| hs b h\n#align sup'_le sup'_le\n\n",
 "sup'_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup'_insert [DecidableEq β] {b : β} {h : (insert b s).nonempty} :\n    (insert b s).sup' h f = «expr ⊔ » (f b) (s.sup' H f) :=\n  by\n  rw [← WithBot.coe_eq_coe]\n  simp only [coe_sup', sup_insert, WithBot.coe_sup]\n#align sup'_insert sup'_insert\n\n",
 "sup'_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup'_induction {p : α → Prop} (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p («expr ⊔ » a₁ a₂)) (hs : ∀ b ∈ s, p (f b)) :\n    p (s.sup' H f) := by\n  show @WithBot.recBotCoe α (fun _ => Prop) True p ↑(s.sup' H f)\n  rw [coe_sup']\n  refine' sup_induction trivial _ hs\n  rintro (_ | a₁) h₁ a₂ h₂\n  · rw [WithBot.none_eq_bot, bot_sup_eq]\n    exact h₂\n  cases a₂\n  exacts[h₁, hp a₁ h₁ a₂ h₂]\n#align sup'_induction sup'_induction\n\n",
 "sup'_eq_sup":
 "theorem sup'_eq_sup {s : Finset β} (H : s.nonempty) (f : β → α) : s.sup' H f = s.sup f :=\n  le_antisymm (sup'_le H f fun b => le_sup) (Finset.sup_le fun b => le_sup' f)\n#align sup'_eq_sup sup'_eq_sup\n\n",
 "sup'_const":
 "@[simp]\ntheorem sup'_const (a : α) : (s.sup' H fun b => a) = a :=\n  by\n  apply le_antisymm\n  · apply sup'_le\n    intros\n    exact le_rfl\n  · apply le_sup' (fun b => a) H.some_spec\n#align sup'_const sup'_const\n\n",
 "sup'_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup'_cons {b : β} {hb : b ∉ s} {h : (cons b s hb).nonempty} :\n    (cons b s hb).sup' h f = «expr ⊔ » (f b) (s.sup' H f) :=\n  by\n  rw [← WithBot.coe_eq_coe]\n  simp only [coe_sup', sup_cons, WithBot.coe_sup]\n#align sup'_cons sup'_cons\n\n",
 "sup'_congr":
 "@[congr]\ntheorem sup'_congr {t : Finset β} {f g : β → α} (h₁ : s = t) (h₂ : ∀ x ∈ s, f x = g x) :\n    s.sup' H f = t.sup' (h₁ ▸ H) g := by\n  subst s\n  refine' eq_of_forall_ge_iff fun c => _\n  simp (config := { contextual := true }) only [sup'_le_iff, h₂]\n#align sup'_congr sup'_congr\n\n",
 "sup'_bUnion":
 "theorem sup'_bUnion [DecidableEq β] {s : Finset γ} (Hs : s.nonempty) {t : γ → Finset β} (Ht : ∀ b, (t b).nonempty) :\n    (s.bUnion t).sup' (Hs.bUnion fun b _ => Ht b) f = s.sup' Hs fun b => (t b).sup' (Ht b) f :=\n  eq_of_forall_ge_iff fun c => by simp [@forall_swap _ β]\n#align sup'_bUnion sup'_bUnion\n\n",
 "sup'_apply":
 "@[simp]\nprotected theorem sup'_apply {s : Finset α} (H : s.nonempty) (f : α → ∀ b : β, C b) (b : β) :\n    s.sup' H f b = s.sup' H fun a => f a b :=\n  comp_sup'_eq_sup'_comp H (fun x : ∀ b : β, C b => x b) fun i j => rfl\n#align sup'_apply sup'_apply\n\n",
 "subset_set_bUnion_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem subset_set_bUnion_of_mem {s : Finset α} {f : α → Set β} {x : α} (h : x ∈ s) :\n    f x ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f y) :=\n  show f x ≤ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f y) from\n    le_supᵢ_of_le x <| le_supᵢ _ h\n#align subset_set_bUnion_of_mem subset_set_bUnion_of_mem\n\n",
 "subset_range_sup_succ":
 "theorem subset_range_sup_succ (s : Finset ℕ) : s ⊆ range (s.sup id).succ := fun n hn =>\n  mem_range.2 <| nat.lt_succ_of_le <| le_sup hn\n#align subset_range_sup_succ subset_range_sup_succ\n\n",
 "set_bUnion_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_union (s t : Finset α) (u : α → Set β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u x) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u x) ∪\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (u x) :=\n  supᵢ_union\n#align set_bUnion_union set_bUnion_union\n\n",
 "set_bUnion_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_singleton (a : α) (s : α → Set β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s x) = s a :=\n  supᵢ_singleton a s\n#align set_bUnion_singleton set_bUnion_singleton\n\n",
 "set_bUnion_preimage_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem set_bUnion_preimage_singleton (f : α → β) (s : Finset β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr ⁻¹' » f {y}) =\n      «expr ⁻¹' » f s :=\n  Set.bunionᵢ_preimage_singleton f s\n#align set_bUnion_preimage_singleton set_bUnion_preimage_singleton\n\n",
 "set_bUnion_option_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_option_to_finset (o : Option α) (f : α → Set β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f x) :=\n  supᵢ_option_toFinset o f\n#align set_bUnion_option_to_finset set_bUnion_option_to_finset\n\n",
 "set_bUnion_insert_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_insert_update {x : α} {t : Finset α} (f : α → Set β) {s : Set β} (hx : x ∉ t) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (@update _ _ _ f x s i) =\n      s ∪ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) :=\n  supᵢ_insert_update f hx\n#align set_bUnion_insert_update set_bUnion_insert_update\n\n",
 "set_bUnion_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_insert (a : α) (s : Finset α) (t : α → Set β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x) =\n      t a ∪ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x) :=\n  supᵢ_insert a s t\n#align set_bUnion_insert set_bUnion_insert\n\n",
 "set_bUnion_finset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_finset_image {f : γ → α} {g : α → Set β} {s : Finset γ} :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (g x) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (g (f y)) :=\n  supᵢ_finset_image\n#align set_bUnion_finset_image set_bUnion_finset_image\n\n",
 "set_bUnion_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_coe (s : Finset α) (t : α → Set β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x) :=\n  rfl\n#align set_bUnion_coe set_bUnion_coe\n\n",
 "set_bUnion_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem set_bUnion_bUnion (s : Finset γ) (t : γ → Finset α) (f : α → Set β) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f y) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f y) :=\n  supᵢ_bunionᵢ s t f\n#align set_bUnion_bUnion set_bUnion_bUnion\n\n",
 "set_bInter_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_singleton (a : α) (s : α → Set β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s x) = s a :=\n  infᵢ_singleton a s\n#align set_bInter_singleton set_bInter_singleton\n\n",
 "set_bInter_option_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_option_to_finset (o : Option α) (f : α → Set β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f x) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f x) :=\n  infᵢ_option_toFinset o f\n#align set_bInter_option_to_finset set_bInter_option_to_finset\n\n",
 "set_bInter_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_inter (s t : Finset α) (u : α → Set β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u x) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u x) ∩\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (u x) :=\n  infᵢ_union\n#align set_bInter_inter set_bInter_inter\n\n",
 "set_bInter_insert_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_insert_update {x : α} {t : Finset α} (f : α → Set β) {s : Set β} (hx : x ∉ t) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        (@update _ _ _ f x s i) =\n      s ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f i) :=\n  infᵢ_insert_update f hx\n#align set_bInter_insert_update set_bInter_insert_update\n\n",
 "set_bInter_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_insert (a : α) (s : Finset α) (t : α → Set β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t x) =\n      t a ∩ «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t x) :=\n  infᵢ_insert a s t\n#align set_bInter_insert set_bInter_insert\n\n",
 "set_bInter_finset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_finset_image {f : γ → α} {g : α → Set β} {s : Finset γ} :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (g x) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (g (f y)) :=\n  infᵢ_finset_image\n#align set_bInter_finset_image set_bInter_finset_image\n\n",
 "set_bInter_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_coe (s : Finset α) (t : α → Set β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t x) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (t x) :=\n  rfl\n#align set_bInter_coe set_bInter_coe\n\n",
 "set_bInter_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem set_bInter_bUnion (s : Finset γ) (t : γ → Finset α) (f : α → Set β) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f y) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f y) :=\n  infᵢ_bunionᵢ s t f\n#align set_bInter_bUnion set_bInter_bUnion\n\n",
 "of_dual_sup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem of_dual_sup' [SemilatticeInf α] {s : Finset ι} (hs : s.nonempty) (f : ι → «expr ᵒᵈ» α) :\n    ofDual (s.sup' hs f) = s.inf' hs (ofDual ∘ f) :=\n  rfl\n#align of_dual_sup' of_dual_sup'\n\n",
 "of_dual_min'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem of_dual_min' {s : Finset («expr ᵒᵈ» α)} (hs : s.nonempty) :\n    ofDual (min' s hs) = max' (s.image ofDual) (hs.image _) :=\n  by\n  convert rfl\n  exact image_id\n#align of_dual_min' of_dual_min'\n\n",
 "of_dual_max'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem of_dual_max' {s : Finset («expr ᵒᵈ» α)} (hs : s.nonempty) :\n    ofDual (max' s hs) = min' (s.image ofDual) (hs.image _) :=\n  by\n  convert rfl\n  exact image_id\n#align of_dual_max' of_dual_max'\n\n",
 "of_dual_inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem of_dual_inf' [SemilatticeSup α] {s : Finset ι} (hs : s.nonempty) (f : ι → «expr ᵒᵈ» α) :\n    ofDual (s.inf' hs f) = s.sup' hs (ofDual ∘ f) :=\n  rfl\n#align of_dual_inf' of_dual_inf'\n\n",
 "ofDual_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print ofDual_sup /-\n@[simp]\ntheorem ofDual_sup [SemilatticeInf α] [OrderTop α] (s : Finset β) (f : β → «expr ᵒᵈ» α) :\n    ofDual (s.sup f) = s.inf (ofDual ∘ f) :=\n  rfl\n#align of_dual_sup ofDual_sup\n-/\n\n",
 "ofDual_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print ofDual_inf /-\n@[simp]\ntheorem ofDual_inf [SemilatticeSup α] [OrderBot α] (s : Finset β) (f : β → «expr ᵒᵈ» α) :\n    ofDual (s.inf f) = s.sup (ofDual ∘ f) :=\n  rfl\n#align of_dual_inf ofDual_inf\n-/\n\n",
 "not_mem_of_max_lt_coe":
 "theorem not_mem_of_max_lt_coe {a : α} {s : Finset α} (h : s.max < a) : a ∉ s :=\n  mt le_max h.not_le\n#align not_mem_of_max_lt_coe not_mem_of_max_lt_coe\n\n",
 "not_mem_of_max_lt":
 "theorem not_mem_of_max_lt {s : Finset α} {a b : α} (h₁ : b < a) (h₂ : s.max = ↑b) : a ∉ s :=\n  Finset.not_mem_of_max_lt_coe <| h₂.trans_lt <| WithBot.coe_lt_coe.mpr h₁\n#align not_mem_of_max_lt not_mem_of_max_lt\n\n",
 "not_mem_of_lt_min":
 "theorem not_mem_of_lt_min {s : Finset α} {a b : α} (h₁ : a < b) (h₂ : s.min = ↑b) : a ∉ s :=\n  Finset.not_mem_of_coe_lt_min <| (WithTop.coe_lt_coe.mpr h₁).trans_eq h₂.symm\n#align not_mem_of_lt_min not_mem_of_lt_min\n\n",
 "not_mem_of_coe_lt_min":
 "theorem not_mem_of_coe_lt_min {a : α} {s : Finset α} (h : ↑a < s.min) : a ∉ s :=\n  mt min_le h.not_le\n#align not_mem_of_coe_lt_min not_mem_of_coe_lt_min\n\n",
 "mul_inf_le_inf_mul_of_nonneg":
 "theorem mul_inf_le_inf_mul_of_nonneg [LinearOrderedSemiring α] [OrderTop α] {a b : ι → α} (s : Finset ι)\n    (ha : ∀ i ∈ s, 0 ≤ a i) (hb : ∀ i ∈ s, 0 ≤ b i) : s.inf a * s.inf b ≤ s.inf (a * b) :=\n  Finset.le_inf fun i hi => mul_le_mul (inf_le hi) (inf_le hi) (Finset.le_inf hb) (ha i hi)\n#align mul_inf_le_inf_mul_of_nonneg mul_inf_le_inf_mul_of_nonneg\n\n",
 "min_singleton":
 "@[simp]\ntheorem min_singleton {a : α} : Finset.min {a} = (a : WithTop α) :=\n  by\n  rw [← insert_emptyc_eq]\n  exact min_insert\n#align min_singleton min_singleton\n\n",
 "min_of_nonempty":
 "theorem min_of_nonempty {s : Finset α} (h : s.nonempty) : ∃ a : α, s.min = a :=\n  let ⟨a, ha⟩ := h\n  min_of_mem ha\n#align min_of_nonempty min_of_nonempty\n\n",
 "min_of_mem":
 "theorem min_of_mem {s : Finset α} {a : α} (h : a ∈ s) : ∃ b : α, s.min = b :=\n  (@inf_le (WithTop α) _ _ _ _ _ _ h _ rfl).imp fun b => Exists.fst\n#align min_of_mem min_of_mem\n\n",
 "min_mono":
 "theorem min_mono {s t : Finset α} (st : s ⊆ t) : t.min ≤ s.min :=\n  inf_mono st\n#align min_mono min_mono\n\n",
 "min_mem_insert_top_image_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem min_mem_insert_top_image_coe (s : Finset α) : s.min ∈ (insert («expr⊤») (s.image coe) : Finset (WithTop α)) :=\n  mem_insert.2 <| s.eq_empty_or_nonempty.imp min_eq_top.2 min_mem_image_coe\n#align min_mem_insert_top_image_coe min_mem_insert_top_image_coe\n\n",
 "min_mem_image_coe":
 "theorem min_mem_image_coe {s : Finset α} (hs : s.nonempty) : s.min ∈ (s.image coe : Finset (WithTop α)) :=\n  mem_image.2 ⟨min' s hs, min'_mem _ _, coe_min' hs⟩\n#align min_mem_image_coe min_mem_image_coe\n\n",
 "min_le_of_eq":
 "theorem min_le_of_eq {s : Finset α} {a b : α} (h₁ : b ∈ s) (h₂ : s.min = a) : a ≤ b :=\n  WithTop.coe_le_coe.mp <| h₂.ge.trans (min_le h₁)\n#align min_le_of_eq min_le_of_eq\n\n",
 "min_le":
 "theorem min_le {a : α} {s : Finset α} (as : a ∈ s) : s.min ≤ a :=\n  inf_le as\n#align min_le min_le\n\n",
 "min_insert":
 "@[simp]\ntheorem min_insert {a : α} {s : Finset α} : (insert a s).min = min (↑a) s.min :=\n  fold_insert_idem\n#align min_insert min_insert\n\n",
 "min_erase_ne_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem min_erase_ne_self {s : Finset α} : (s.erase x).min ≠ x := by convert@max_erase_ne_self («expr ᵒᵈ» α) _ _ _\n#align min_erase_ne_self min_erase_ne_self\n\n",
 "min_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print min_eq_top /-\ntheorem min_eq_top {s : Finset α} : s.min = «expr⊤» ↔ s = ∅ :=\n  ⟨fun h =>\n    s.eq_empty_or_nonempty.elim id fun H => by\n      let ⟨a, ha⟩ := min_of_nonempty H\n      rw [h] at ha <;> cases ha,\n    fun h => h.symm ▸ min_empty⟩\n#align min_eq_top min_eq_top\n-/\n\n",
 "min_eq_inf_with_top":
 "theorem min_eq_inf_with_top (s : Finset α) : s.min = inf s coe :=\n  rfl\n#align min_eq_inf_with_top min_eq_inf_with_top\n\n",
 "min_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem min_empty : (∅ : Finset α).min = «expr⊤» :=\n  rfl\n#align min_empty min_empty\n\n",
 "min'_subset":
 "theorem min'_subset {s t : Finset α} (H : s.nonempty) (hst : s ⊆ t) : t.min' (H.mono hst) ≤ s.min' H :=\n  min'_le _ _ (hst (s.min'_mem H))\n#align min'_subset min'_subset\n\n",
 "min'_singleton":
 "/-- `{a}.min' _` is `a`. -/\n@[simp]\ntheorem min'_singleton (a : α) : ({a} : Finset α).min' (singleton_nonempty _) = a := by simp [min']\n#align min'_singleton min'_singleton\n\n",
 "min'_mem":
 "theorem min'_mem : s.min' H ∈ s :=\n  mem_of_min <| by simp [min', Finset.min]\n#align min'_mem min'_mem\n\n",
 "min'_lt_of_mem_erase_min'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem min'_lt_of_mem_erase_min' [DecidableEq α] {a : α} (ha : a ∈ s.erase (s.min' H)) : s.min' H < a :=\n  @lt_max'_of_mem_erase_max' («expr ᵒᵈ» α) _ s H _ a ha\n#align min'_lt_of_mem_erase_min' min'_lt_of_mem_erase_min'\n\n",
 "min'_lt_max'_of_card":
 "/-- If there's more than 1 element, the min' is less than the max'. An alternate version of\n`min'_lt_max'` which is sometimes more convenient.\n-/\ntheorem min'_lt_max'_of_card (h₂ : 1 < card s) :\n    s.min' (Finset.card_pos.mp <| lt_trans zero_lt_one h₂) < s.max' (Finset.card_pos.mp <| lt_trans zero_lt_one h₂) :=\n  by\n  rcases one_lt_card.1 h₂ with ⟨a, ha, b, hb, hab⟩\n  exact s.min'_lt_max' ha hb hab\n#align min'_lt_max'_of_card min'_lt_max'_of_card\n\n",
 "min'_lt_max'":
 "theorem min'_lt_max' {i j} (H1 : i ∈ s) (H2 : j ∈ s) (H3 : i ≠ j) : s.min' ⟨i, H1⟩ < s.max' ⟨i, H1⟩ :=\n  isGLB_lt_isLUB_of_ne (s.is_least_min' _).is_glb (s.is_greatest_max' _).is_lub H1 H2 H3\n#align min'_lt_max' min'_lt_max'\n\n",
 "min'_le":
 "theorem min'_le (x) (H2 : x ∈ s) : s.min' ⟨x, H2⟩ ≤ x :=\n  min_le_of_eq H2 (WithTop.coe_untop _ _).symm\n#align min'_le min'_le\n\n",
 "min'_insert":
 "theorem min'_insert (a : α) (s : Finset α) (H : s.nonempty) :\n    (insert a s).min' (s.insert_nonempty a) = min (s.min' H) a :=\n  (isLeast_min' _ _).unique <| by\n    rw [coe_insert, min_comm]\n    exact (is_least_min' _ _).insert _\n#align min'_insert min'_insert\n\n",
 "min'_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem min'_image [linear_order β] {f : α → β} (hf : Monotone f) (s : Finset α) (h : (s.image f).nonempty) :\n    (s.image f).min' h = f (s.min' ((Nonempty.image_iff f).mp h)) :=\n  by\n  convert@max'_image («expr ᵒᵈ» α) («expr ᵒᵈ» β) _ _ (fun a : «expr ᵒᵈ» α => to_dual (f (of_dual a))) (by simpa) _ _ <;>\n    convert h\n  rw [nonempty.image_iff]\n#align min'_image min'_image\n\n",
 "min'_erase_ne_self":
 "theorem min'_erase_ne_self {s : Finset α} (s0 : (s.erase x).nonempty) : (s.erase x).min' s0 ≠ x :=\n  ne_of_mem_erase (min'_mem _ s0)\n#align min'_erase_ne_self min'_erase_ne_self\n\n",
 "min'_eq_inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem min'_eq_inf' : s.min' H = s.inf' H id :=\n  @max'_eq_sup' («expr ᵒᵈ» α) _ s H\n#align min'_eq_inf' min'_eq_inf'\n\n",
 "mem_sup":
 "theorem mem_sup {α β} [DecidableEq β] {s : Finset α} {f : α → Finset β} {x : β} : x ∈ s.sup f ↔ ∃ v ∈ s, x ∈ f v :=\n  by\n  change _ ↔ ∃ v ∈ s, x ∈ (f v).val\n  rw [← Multiset.mem_sup, ← Multiset.mem_toFinset, sup_to_finset]\n  simp_rw [val_to_finset]\n#align mem_sup mem_sup\n\n",
 "mem_of_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem mem_of_min {s : Finset α} : ∀ {a : α}, s.min = a → a ∈ s :=\n  @mem_of_max («expr ᵒᵈ» α) _ s\n#align mem_of_min mem_of_min\n\n",
 "mem_of_max":
 "theorem mem_of_max {s : Finset α} : ∀ {a : α}, s.max = a → a ∈ s :=\n  Finset.induction_on s (fun _ H => by cases H)\n    fun b s _ (ih : ∀ {a : α}, s.max = a → a ∈ s) a (h : (insert b s).max = a) =>\n    by\n    by_cases p : b = a\n    · induction p\n      exact mem_insert_self b s\n    · cases' max_choice (↑b) s.max with q q <;> rw [max_insert, q] at h\n      · cases h\n        cases p rfl\n      · exact mem_insert_of_mem (ih h)\n#align mem_of_max mem_of_max\n\n",
 "max_singleton":
 "@[simp]\ntheorem max_singleton {a : α} : Finset.max {a} = (a : WithBot α) :=\n  by\n  rw [← insert_emptyc_eq]\n  exact max_insert\n#align max_singleton max_singleton\n\n",
 "max_of_nonempty":
 "theorem max_of_nonempty {s : Finset α} (h : s.nonempty) : ∃ a : α, s.max = a :=\n  let ⟨a, ha⟩ := h\n  max_of_mem ha\n#align max_of_nonempty max_of_nonempty\n\n",
 "max_of_mem":
 "theorem max_of_mem {s : Finset α} {a : α} (h : a ∈ s) : ∃ b : α, s.max = b :=\n  (@le_sup (WithBot α) _ _ _ _ _ _ h _ rfl).imp fun b => Exists.fst\n#align max_of_mem max_of_mem\n\n",
 "max_mono":
 "theorem max_mono {s t : Finset α} (st : s ⊆ t) : s.max ≤ t.max :=\n  sup_mono st\n#align max_mono max_mono\n\n",
 "max_mem_insert_bot_image_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem max_mem_insert_bot_image_coe (s : Finset α) : s.max ∈ (insert («expr⊥») (s.image coe) : Finset (WithBot α)) :=\n  mem_insert.2 <| s.eq_empty_or_nonempty.imp max_eq_bot.2 max_mem_image_coe\n#align max_mem_insert_bot_image_coe max_mem_insert_bot_image_coe\n\n",
 "max_mem_image_coe":
 "theorem max_mem_image_coe {s : Finset α} (hs : s.nonempty) : s.max ∈ (s.image coe : Finset (WithBot α)) :=\n  mem_image.2 ⟨max' s hs, max'_mem _ _, coe_max' hs⟩\n#align max_mem_image_coe max_mem_image_coe\n\n",
 "max_le":
 "#print max_le /-\nprotected theorem max_le {M : WithBot α} {s : Finset α} (st : ∀ a ∈ s, (a : WithBot α) ≤ M) : s.max ≤ M :=\n  Finset.sup_le st\n#align max_le max_le\n-/\n\n",
 "max_insert":
 "@[simp]\ntheorem max_insert {a : α} {s : Finset α} : (insert a s).max = max a s.max :=\n  fold_insert_idem\n#align max_insert max_insert\n\n",
 "max_erase_ne_self":
 "theorem max_erase_ne_self {s : Finset α} : (s.erase x).max ≠ x :=\n  by\n  by_cases s0 : (s.erase x).nonempty\n  · refine' ne_of_eq_of_ne (coe_max' s0).symm _\n    exact with_bot.coe_eq_coe.not.mpr (max'_erase_ne_self _)\n  · rw [not_nonempty_iff_eq_empty.mp s0, max_empty]\n    exact WithBot.bot_ne_coe\n#align max_erase_ne_self max_erase_ne_self\n\n",
 "max_eq_sup_with_bot":
 "theorem max_eq_sup_with_bot (s : Finset α) : s.max = sup s coe :=\n  rfl\n#align max_eq_sup_with_bot max_eq_sup_with_bot\n\n",
 "max_eq_sup_coe":
 "theorem max_eq_sup_coe {s : Finset α} : s.max = s.sup coe :=\n  rfl\n#align max_eq_sup_coe max_eq_sup_coe\n\n",
 "max_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print max_eq_bot /-\ntheorem max_eq_bot {s : Finset α} : s.max = «expr⊥» ↔ s = ∅ :=\n  ⟨fun h =>\n    s.eq_empty_or_nonempty.elim id fun H => by\n      let ⟨a, ha⟩ := max_of_nonempty H\n      rw [h] at ha <;> cases ha,\n    fun h => h.symm ▸ max_empty⟩\n#align max_eq_bot max_eq_bot\n-/\n\n",
 "max_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem max_empty : (∅ : Finset α).max = «expr⊥» :=\n  rfl\n#align max_empty max_empty\n\n",
 "max'_subset":
 "theorem max'_subset {s t : Finset α} (H : s.nonempty) (hst : s ⊆ t) : s.max' H ≤ t.max' (H.mono hst) :=\n  le_max' _ _ (hst (s.max'_mem H))\n#align max'_subset max'_subset\n\n",
 "max'_singleton":
 "/-- `{a}.max' _` is `a`. -/\n@[simp]\ntheorem max'_singleton (a : α) : ({a} : Finset α).max' (singleton_nonempty _) = a := by simp [max']\n#align max'_singleton max'_singleton\n\n",
 "max'_mem":
 "theorem max'_mem : s.max' H ∈ s :=\n  mem_of_max <| by simp [max', Finset.max]\n#align max'_mem max'_mem\n\n",
 "max'_lt_iff":
 "@[simp]\ntheorem max'_lt_iff {x} : s.max' H < x ↔ ∀ y ∈ s, y < x :=\n  ⟨fun Hlt y hy => (s.le_max' y hy).trans_lt Hlt, fun H => H _ <| s.max'_mem _⟩\n#align max'_lt_iff max'_lt_iff\n\n",
 "max'_le_iff":
 "@[simp]\ntheorem max'_le_iff {x} : s.max' H ≤ x ↔ ∀ y ∈ s, y ≤ x :=\n  isLUB_le_iff (isGreatest_max' s H).is_lub\n#align max'_le_iff max'_le_iff\n\n",
 "max'_le":
 "theorem max'_le (x) (H2 : ∀ y ∈ s, y ≤ x) : s.max' H ≤ x :=\n  H2 _ <| max'_mem _ _\n#align max'_le max'_le\n\n",
 "max'_insert":
 "theorem max'_insert (a : α) (s : Finset α) (H : s.nonempty) :\n    (insert a s).max' (s.insert_nonempty a) = max (s.max' H) a :=\n  (isGreatest_max' _ _).unique <| by\n    rw [coe_insert, max_comm]\n    exact (is_greatest_max' _ _).insert _\n#align max'_insert max'_insert\n\n",
 "max'_image":
 "@[simp]\ntheorem max'_image [linear_order β] {f : α → β} (hf : Monotone f) (s : Finset α) (h : (s.image f).nonempty) :\n    (s.image f).max' h = f (s.max' ((Nonempty.image_iff f).mp h)) :=\n  by\n  refine' le_antisymm (max'_le _ _ _ fun y hy => _) (le_max' _ _ (mem_image.mpr ⟨_, max'_mem _ _, rfl⟩))\n  obtain ⟨x, hx, rfl⟩ := mem_image.mp hy\n  exact hf (le_max' _ _ hx)\n#align max'_image max'_image\n\n",
 "max'_erase_ne_self":
 "theorem max'_erase_ne_self {s : Finset α} (s0 : (s.erase x).nonempty) : (s.erase x).max' s0 ≠ x :=\n  ne_of_mem_erase (max'_mem _ s0)\n#align max'_erase_ne_self max'_erase_ne_self\n\n",
 "max'_eq_sup'":
 "theorem max'_eq_sup' : s.max' H = s.sup' H id :=\n  eq_of_forall_ge_iff fun a => (max'_le_iff _ _).trans (sup'_le_iff _ _).symm\n#align max'_eq_sup' max'_eq_sup'\n\n",
 "map_to_dual_min":
 "theorem map_to_dual_min (s : Finset α) : s.min.map toDual = (s.image toDual).max :=\n  by\n  rw [max_eq_sup_with_bot, sup_image]\n  exact congr_fun option.map_id _\n#align map_to_dual_min map_to_dual_min\n\n",
 "map_to_dual_max":
 "theorem map_to_dual_max (s : Finset α) : s.max.map toDual = (s.image toDual).min :=\n  by\n  rw [min_eq_inf_with_top, inf_image]\n  exact congr_fun option.map_id _\n#align map_to_dual_max map_to_dual_max\n\n",
 "map_of_dual_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem map_of_dual_min (s : Finset («expr ᵒᵈ» α)) : s.min.map ofDual = (s.image ofDual).max :=\n  by\n  rw [max_eq_sup_with_bot, sup_image]\n  exact congr_fun option.map_id _\n#align map_of_dual_min map_of_dual_min\n\n",
 "map_of_dual_max":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem map_of_dual_max (s : Finset («expr ᵒᵈ» α)) : s.max.map ofDual = (s.image ofDual).min :=\n  by\n  rw [min_eq_inf_with_top, inf_image]\n  exact congr_fun option.map_id _\n#align map_of_dual_max map_of_dual_max\n\n",
 "map_finset_sup":
 "#print map_finset_sup /-\ntheorem map_finset_sup [DecidableEq α] [DecidableEq β] (s : Finset γ) (f : γ → Multiset β) (g : β → α)\n    (hg : function.injective g) : map g (s.sup f) = s.sup (map g ∘ f) :=\n  Finset.comp_sup_eq_sup_comp _ (fun _ _ => map_union hg) (map_zero _)\n#align map_finset_sup map_finset_sup\n-/\n\n",
 "map_finset_inf":
 "#print map_finset_inf /-\n@[simp]\ntheorem map_finset_inf [SemilatticeInf β] [OrderTop β] [InfTopHomClass F α β] (f : F) (s : Finset ι) (g : ι → α) :\n    f (s.inf g) = s.inf (f ∘ g) :=\n  Finset.cons_induction_on s (map_top f) fun i s _ h => by rw [inf_cons, inf_cons, map_inf, h]\n#align map_finset_inf map_finset_inf\n-/\n\n",
 "lt_sup_iff":
 "#print lt_sup_iff /-\n@[simp]\nprotected theorem lt_sup_iff : a < s.sup f ↔ ∃ b ∈ s, a < f b :=\n  ⟨Finset.cons_induction_on s (fun h => absurd h not_lt_bot) fun c t hc ih => by\n      simpa using\n        @or.rec _ _ (∃ b, (b = c ∨ b ∈ t) ∧ a < f b) (fun h => ⟨c, or.inl rfl, h⟩) fun h =>\n          let ⟨b, hb, hlt⟩ := ih h\n          ⟨b, or.inr hb, hlt⟩,\n    fun ⟨b, hb, hlt⟩ => lt_of_lt_of_le hlt (le_sup hb)⟩\n#align lt_sup_iff lt_sup_iff\n-/\n\n",
 "lt_sup'_iff":
 "@[simp]\ntheorem lt_sup'_iff : a < s.sup' H f ↔ ∃ b ∈ s, a < f b :=\n  by\n  rw [← WithBot.coe_lt_coe, coe_sup', Finset.lt_sup_iff]\n  exact bex_congr fun b hb => WithBot.coe_lt_coe\n#align lt_sup'_iff lt_sup'_iff\n\n",
 "lt_min'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem lt_min'_iff : x < s.min' H ↔ ∀ y ∈ s, x < y :=\n  @max'_lt_iff («expr ᵒᵈ» α) _ _ H _\n#align lt_min'_iff lt_min'_iff\n\n",
 "lt_max'_of_mem_erase_max'":
 "theorem lt_max'_of_mem_erase_max' [DecidableEq α] {a : α} (ha : a ∈ s.erase (s.max' H)) : a < s.max' H :=\n  lt_of_le_of_ne (le_max' _ _ (mem_of_mem_erase ha)) <| ne_of_mem_of_not_mem ha <| not_mem_erase _ _\n#align lt_max'_of_mem_erase_max' lt_max'_of_mem_erase_max'\n\n",
 "lt_inf_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print lt_inf_iff /-\n@[simp]\nprotected theorem lt_inf_iff (ha : a < «expr⊤») : a < s.inf f ↔ ∀ b ∈ s, a < f b :=\n  @Finset.sup_lt_iff («expr ᵒᵈ» α) _ _ _ _ _ _ ha\n#align lt_inf_iff lt_inf_iff\n-/\n\n",
 "lt_inf'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem lt_inf'_iff : a < s.inf' H f ↔ ∀ i ∈ s, a < f i :=\n  @sup'_lt_iff («expr ᵒᵈ» α) _ _ _ H f _\n#align lt_inf'_iff lt_inf'_iff\n\n",
 "le_sup_of_le":
 "theorem le_sup_of_le {b : β} (hb : b ∈ s) (h : a ≤ f b) : a ≤ s.sup f :=\n  h.trans <| le_sup hb\n#align le_sup_of_le le_sup_of_le\n\n",
 "le_sup_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print le_sup_iff /-\n@[simp]\nprotected theorem le_sup_iff (ha : «expr⊥» < a) : a ≤ s.sup f ↔ ∃ b ∈ s, a ≤ f b :=\n  ⟨Finset.cons_induction_on s (fun h => absurd h (not_le_of_lt ha)) fun c t hc ih => by\n      simpa using\n        @or.rec _ _ (∃ b, (b = c ∨ b ∈ t) ∧ a ≤ f b) (fun h => ⟨c, or.inl rfl, h⟩) fun h =>\n          let ⟨b, hb, hle⟩ := ih h\n          ⟨b, or.inr hb, hle⟩,\n    fun ⟨b, hb, hle⟩ => trans hle (le_sup hb)⟩\n#align le_sup_iff le_sup_iff\n-/\n\n",
 "le_sup'_of_le":
 "theorem le_sup'_of_le {a : α} {b : β} (hb : b ∈ s) (h : a ≤ f b) : a ≤ s.sup' ⟨b, hb⟩ f :=\n  h.trans <| le_sup' _ hb\n#align le_sup'_of_le le_sup'_of_le\n\n",
 "le_sup'_iff":
 "@[simp]\ntheorem le_sup'_iff : a ≤ s.sup' H f ↔ ∃ b ∈ s, a ≤ f b :=\n  by\n  rw [← WithBot.coe_le_coe, coe_sup', Finset.le_sup_iff (WithBot.bot_lt_coe a)]\n  exact bex_congr fun b hb => WithBot.coe_le_coe\n#align le_sup'_iff le_sup'_iff\n\n",
 "le_sup'":
 "theorem le_sup' {b : β} (h : b ∈ s) : f b ≤ s.sup' ⟨b, h⟩ f :=\n  by\n  rw [← WithBot.coe_le_coe, coe_sup']\n  exact le_sup h\n#align le_sup' le_sup'\n\n",
 "le_sup":
 "theorem le_sup {b : β} (hb : b ∈ s) : f b ≤ s.sup f :=\n  Finset.sup_le_iff.1 le_rfl _ hb\n#align le_sup le_sup\n\n",
 "le_min'_iff":
 "@[simp]\ntheorem le_min'_iff {x} : x ≤ s.min' H ↔ ∀ y ∈ s, x ≤ y :=\n  le_isGLB_iff (isLeast_min' s H).is_glb\n#align le_min'_iff le_min'_iff\n\n",
 "le_min'":
 "theorem le_min' (x) (H2 : ∀ y ∈ s, x ≤ y) : x ≤ s.min' H :=\n  H2 _ <| min'_mem _ _\n#align le_min' le_min'\n\n",
 "le_min":
 "#print le_min /-\nprotected theorem le_min {m : WithTop α} {s : Finset α} (st : ∀ a : α, a ∈ s → m ≤ a) : m ≤ s.min :=\n  Finset.le_inf st\n#align le_min le_min\n-/\n\n",
 "le_max_of_eq":
 "theorem le_max_of_eq {s : Finset α} {a b : α} (h₁ : a ∈ s) (h₂ : s.max = b) : a ≤ b :=\n  WithBot.coe_le_coe.mp <| (le_max h₁).trans h₂.le\n#align le_max_of_eq le_max_of_eq\n\n",
 "le_max'":
 "theorem le_max' (x) (H2 : x ∈ s) : x ≤ s.max' ⟨x, H2⟩ :=\n  le_max_of_eq H2 (WithBot.coe_unbot _ _).symm\n#align le_max' le_max'\n\n",
 "le_max":
 "theorem le_max {a : α} {s : Finset α} (as : a ∈ s) : ↑a ≤ s.max :=\n  le_sup as\n#align le_max le_max\n\n",
 "le_inf_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print le_inf_iff /-\nprotected theorem le_inf_iff {a : α} : a ≤ s.inf f ↔ ∀ b ∈ s, a ≤ f b :=\n  @Finset.sup_le_iff («expr ᵒᵈ» α) _ _ _ _ _ _\n#align le_inf_iff le_inf_iff\n-/\n\n",
 "le_inf_const_le":
 "theorem le_inf_const_le : a ≤ s.inf fun _ => a :=\n  Finset.le_inf fun _ _ => le_rfl\n#align le_inf_const_le le_inf_const_le\n\n",
 "le_inf'_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem le_inf'_iff : a ≤ s.inf' H f ↔ ∀ b ∈ s, a ≤ f b :=\n  @sup'_le_iff («expr ᵒᵈ» α) _ _ _ H f _\n#align le_inf'_iff le_inf'_iff\n\n",
 "le_inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem le_inf' (hs : ∀ b ∈ s, a ≤ f b) : a ≤ s.inf' H f :=\n  @sup'_le («expr ᵒᵈ» α) _ _ _ H f _ hs\n#align le_inf' le_inf'\n\n",
 "is_lub_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_lub_mem [linear_order α] {i : α} (s : Finset α) (his : IsLUB (s : Set α) i) (hs : s.nonempty) : i ∈ s :=\n  @is_glb_mem («expr ᵒᵈ» α) _ i s his hs\n#align is_lub_mem is_lub_mem\n\n",
 "is_lub_iff_is_greatest":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem is_lub_iff_is_greatest [linear_order α] (i : α) (s : Finset α) (hs : s.nonempty) :\n    IsLUB (s : Set α) i ↔ IsGreatest (↑s) i :=\n  @is_glb_iff_is_least («expr ᵒᵈ» α) _ i s hs\n#align is_lub_iff_is_greatest is_lub_iff_is_greatest\n\n",
 "is_least_min'":
 "theorem is_least_min' : IsLeast (↑s) (s.min' H) :=\n  ⟨min'_mem _ _, min'_le _⟩\n#align is_least_min' is_least_min'\n\n",
 "is_greatest_max'":
 "theorem is_greatest_max' : IsGreatest (↑s) (s.max' H) :=\n  ⟨max'_mem _ _, le_max' _⟩\n#align is_greatest_max' is_greatest_max'\n\n",
 "is_glb_mem":
 "theorem is_glb_mem [linear_order α] {i : α} (s : Finset α) (his : IsGLB (s : Set α) i) (hs : s.nonempty) : i ∈ s :=\n  by\n  rw [← mem_coe]\n  exact ((is_glb_iff_is_least i s hs).mp his).1\n#align is_glb_mem is_glb_mem\n\n",
 "is_glb_iff_is_least":
 "theorem is_glb_iff_is_least [linear_order α] (i : α) (s : Finset α) (hs : s.nonempty) :\n    IsGLB (s : Set α) i ↔ IsLeast (↑s) i :=\n  by\n  refine' ⟨fun his => _, IsLeast.isGLB⟩\n  suffices i = min' s hs by\n    rw [this]\n    exact is_least_min' s hs\n  rw [IsGLB, IsGreatest, mem_lowerBounds, mem_upperBounds] at his\n  exact le_antisymm (his.1 (Finset.min' s hs) (Finset.min'_mem s hs)) (his.2 _ (Finset.min'_le s))\n#align is_glb_iff_is_least is_glb_iff_is_least\n\n",
 "infᵢ_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_union /-\ntheorem infᵢ_union {f : α → β} {s t : Finset α} :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x) =\n      «expr ⊓ » («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x))\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x)) :=\n  @supᵢ_union α («expr ᵒᵈ» β) _ _ _ _ _\n#align infi_union infᵢ_union\n-/\n\n",
 "infᵢ_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_singleton /-\ntheorem infᵢ_singleton (a : α) (s : α → β) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s x) = s a := by\n  simp\n#align infi_singleton infᵢ_singleton\n-/\n\n",
 "infᵢ_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_insert /-\ntheorem infᵢ_insert (a : α) (s : Finset α) (t : α → β) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (t x) =\n      «expr ⊓ » (t a)\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (t x)) :=\n  @supᵢ_insert α («expr ᵒᵈ» β) _ _ _ _ _\n#align infi_insert infᵢ_insert\n-/\n\n",
 "infᵢ_eq_infᵢ_finset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_eq_infᵢ_finset' /-\n/-- Infimum of `s i`, `i : ι`, is equal to the infimum over `t : finset ι` of infima\n`⨅ i ∈ t, s i`. This version works for `ι : Sort*`. See `infi_eq_infi_finset` for a version\nthat assumes `ι : Type*` but has no `plift`s. -/\ntheorem infᵢ_eq_infᵢ_finset' (s : ι' → α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (s (PLift.down i))) :=\n  @supᵢ_eq_supᵢ_finset' («expr ᵒᵈ» α) _ _ _\n#align infi_eq_infi_finset' infᵢ_eq_infᵢ_finset'\n-/\n\n",
 "infᵢ_eq_infᵢ_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print infᵢ_eq_infᵢ_finset /-\n/-- Infimum of `s i`, `i : ι`, is equal to the infimum over `t : finset ι` of infima\n`⨅ i ∈ t, s i`. This version assumes `ι` is a `Type*`. See `infi_eq_infi_finset'` for a version\nthat works for `ι : Sort*`. -/\ntheorem infᵢ_eq_infᵢ_finset (s : ι → α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (s i) :=\n  @supᵢ_eq_supᵢ_finset («expr ᵒᵈ» α) _ _ _\n#align infi_eq_infi_finset infᵢ_eq_infᵢ_finset\n-/\n\n",
 "infi_option_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_option_to_finset (o : Option α) (f : α → β) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x) :=\n  @supᵢ_option_toFinset _ («expr ᵒᵈ» β) _ _ _\n#align infi_option_to_finset infi_option_to_finset\n\n",
 "infi_insert_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_insert_update {x : α} {t : Finset α} (f : α → β) {s : β} (hx : x ∉ t) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (update f x s i) =\n      «expr ⊓ » s\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i)) :=\n  @supᵢ_insert_update α («expr ᵒᵈ» β) _ _ _ _ f _ hx\n#align infi_insert_update infi_insert_update\n\n",
 "infi_finset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_finset_image {f : γ → α} {g : α → β} {s : Finset γ} :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g x) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (g (f y)) :=\n  by rw [← infi_coe, coe_image, infᵢ_image, infi_coe]\n#align infi_finset_image infi_finset_image\n\n",
 "infi_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_coe [InfSet β] (f : α → β) (s : Finset α) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f x) :=\n  rfl\n#align infi_coe infi_coe\n\n",
 "infi_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem infi_bUnion (s : Finset γ) (t : γ → Finset α) (f : α → β) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f y) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f y) :=\n  @supᵢ_bunionᵢ _ («expr ᵒᵈ» β) _ _ _ _ _ _\n#align infi_bUnion infi_bUnion\n\n",
 "inf_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_union [DecidableEq β] : (s₁ ∪ s₂).inf f = «expr ⊓ » (s₁.inf f) (s₂.inf f) :=\n  @sup_union («expr ᵒᵈ» α) _ _ _ _ _ _ _\n#align inf_union inf_union\n\n",
 "inf_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem inf_top (s : Finset β) : (s.inf fun _ => «expr⊤») = («expr⊤» : α) :=\n  @sup_bot («expr ᵒᵈ» α) _ _ _ _\n#align inf_top inf_top\n\n",
 "inf_sup_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem inf_sup_distrib_right (s : Finset ι) (f : ι → α) (a : α) :\n    «expr ⊔ » (s.inf f) a = s.inf fun i => «expr ⊔ » (f i) a :=\n  @sup_inf_distrib_right («expr ᵒᵈ» α) _ _ _ _ _ _\n#align inf_sup_distrib_right inf_sup_distrib_right\n\n",
 "inf_sup_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem inf_sup_distrib_left (s : Finset ι) (f : ι → α) (a : α) :\n    «expr ⊔ » a (s.inf f) = s.inf fun i => «expr ⊔ » a (f i) :=\n  @sup_inf_distrib_left («expr ᵒᵈ» α) _ _ _ _ _ _\n#align inf_sup_distrib_left inf_sup_distrib_left\n\n",
 "inf_singleton":
 "@[simp]\ntheorem inf_singleton {b : β} : ({b} : Finset β).inf f = f b :=\n  inf_singleton\n#align inf_singleton inf_singleton\n\n",
 "inf_set_eq_bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp]\ntheorem inf_set_eq_bInter (s : Finset α) (f : α → Set β) :\n    s.inf f = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f x) :=\n  inf_eq_infᵢ _ _\n#align inf_set_eq_bInter inf_set_eq_bInter\n\n",
 "inf_sdiff_right":
 "#print inf_sdiff_right /-\ntheorem inf_sdiff_right (hs : s.nonempty) (f : ι → α) (a : α) : (s.inf fun b => f b \\ a) = s.inf f \\ a :=\n  by\n  induction' hs using Finset.Nonempty.cons_induction with b b t _ _ h\n  · rw [inf_singleton, inf_singleton]\n  · rw [inf_cons, inf_cons, h, inf_sdiff]\n#align inf_sdiff_right inf_sdiff_right\n-/\n\n",
 "inf_sdiff_left":
 "#print inf_sdiff_left /-\ntheorem inf_sdiff_left (hs : s.nonempty) (f : ι → α) (a : α) : (s.inf fun b => a \\ f b) = a \\ s.sup f :=\n  by\n  induction' hs using Finset.Nonempty.cons_induction with b b t _ _ h\n  · rw [sup_singleton, inf_singleton]\n  · rw [sup_cons, inf_cons, h, sdiff_sup]\n#align inf_sdiff_left inf_sdiff_left\n-/\n\n",
 "inf_product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem inf_product_right (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (finset.product s t).inf f = t.inf fun i' => s.inf fun i => f ⟨i, i'⟩ :=\n  @sup_product_right («expr ᵒᵈ» α) _ _ _ _ _ _ _\n#align inf_product_right inf_product_right\n\n",
 "inf_product_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem inf_product_left (s : Finset β) (t : Finset γ) (f : β × γ → α) :\n    (finset.product s t).inf f = s.inf fun i => t.inf fun i' => f ⟨i, i'⟩ :=\n  @sup_product_left («expr ᵒᵈ» α) _ _ _ _ _ _ _\n#align inf_product_left inf_product_left\n\n",
 "inf_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf_of_mem {s : Finset β} (f : β → α) {b : β} (h : b ∈ s) : ∃ a : α, s.inf (coe ∘ f : β → WithTop α) = ↑a :=\n  @sup_of_mem («expr ᵒᵈ» α) _ _ _ f _ h\n#align inf_of_mem inf_of_mem\n\n",
 "inf_mono_fun":
 "theorem inf_mono_fun {g : β → α} (h : ∀ b ∈ s, f b ≤ g b) : s.inf f ≤ s.inf g :=\n  Finset.le_inf fun b hb => le_trans (inf_le hb) (h b hb)\n#align inf_mono_fun inf_mono_fun\n\n",
 "inf_mono":
 "theorem inf_mono (h : s₁ ⊆ s₂) : s₂.inf f ≤ s₁.inf f :=\n  Finset.le_inf fun b hb => inf_le <| h hb\n#align inf_mono inf_mono\n\n",
 "inf_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_mem (s : Set α) (w₁ : «expr⊤» ∈ s) (w₂ : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), «expr ⊓ » x y ∈ s) {ι : Type _}\n    (t : Finset ι) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.inf p ∈ s :=\n  @inf_induction _ _ _ _ _ _ (· ∈ s) w₁ w₂ h\n#align inf_mem inf_mem\n\n",
 "inf_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n@[simp]\ntheorem inf_map (s : Finset γ) (f : «expr ↪ » γ β) (g : β → α) : (s.map f).inf g = s.inf (g ∘ f) :=\n  fold_map\n#align inf_map inf_map\n\n",
 "inf_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print inf_lt_iff /-\n@[simp]\nprotected theorem inf_lt_iff : s.inf f < a ↔ ∃ b ∈ s, f b < a :=\n  @Finset.lt_sup_iff («expr ᵒᵈ» α) _ _ _ _ _ _\n#align inf_lt_iff inf_lt_iff\n-/\n\n",
 "inf_le_of_le":
 "theorem inf_le_of_le {b : β} (hb : b ∈ s) (h : f b ≤ a) : s.inf f ≤ a :=\n  (inf_le hb).trans h\n#align inf_le_of_le inf_le_of_le\n\n",
 "inf_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print inf_le_iff /-\n@[simp]\nprotected theorem inf_le_iff (ha : a < «expr⊤») : s.inf f ≤ a ↔ ∃ b ∈ s, f b ≤ a :=\n  @Finset.le_sup_iff («expr ᵒᵈ» α) _ _ _ _ _ _ ha\n#align inf_le_iff inf_le_iff\n-/\n\n",
 "inf_le":
 "theorem inf_le {b : β} (hb : b ∈ s) : s.inf f ≤ f b :=\n  Finset.le_inf_iff.1 le_rfl _ hb\n#align inf_le inf_le\n\n",
 "inf_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_insert [DecidableEq β] {b : β} : (insert b s : Finset β).inf f = «expr ⊓ » (f b) (s.inf f) :=\n  fold_insert_idem\n#align inf_insert inf_insert\n\n",
 "inf_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_inf : s.inf («expr ⊓ » f g) = «expr ⊓ » (s.inf f) (s.inf g) :=\n  @sup_sup («expr ᵒᵈ» α) _ _ _ _ _ _\n#align inf_inf inf_inf\n\n",
 "inf_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_induction {p : α → Prop} (ht : p («expr⊤»)) (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p («expr ⊓ » a₁ a₂))\n    (hs : ∀ b ∈ s, p (f b)) : p (s.inf f) :=\n  @sup_induction («expr ᵒᵈ» α) _ _ _ _ _ _ ht hp hs\n#align inf_induction inf_induction\n\n",
 "inf_image":
 "theorem inf_image [DecidableEq β] (s : Finset γ) (f : γ → β) (g : β → α) : (s.image f).inf g = s.inf (g ∘ f) :=\n  fold_image_idem\n#align inf_image inf_image\n\n",
 "inf_id_set_eq_sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem inf_id_set_eq_sInter (s : Finset (Set α)) : s.inf id = «expr⋂₀ » ↑s :=\n  inf_id_eq_infₛ _\n#align inf_id_set_eq_sInter inf_id_set_eq_sInter\n\n",
 "inf_id_eq_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf_id_eq_Inf [CompleteLattice α] (s : Finset α) : s.inf id = infₛ s :=\n  @sup_id_eq_supₛ («expr ᵒᵈ» α) _ _\n#align inf_id_eq_Inf inf_id_eq_Inf\n\n",
 "inf_erase_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem inf_erase_top [DecidableEq α] (s : Finset α) : (s.erase («expr⊤»)).inf id = s.inf id :=\n  @sup_erase_bot («expr ᵒᵈ» α) _ _ _ _\n#align inf_erase_top inf_erase_top\n\n",
 "inf_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print inf_eq_top_iff /-\n@[simp]\ntheorem inf_eq_top_iff (f : β → α) (S : Finset β) : S.inf f = «expr⊤» ↔ ∀ s ∈ S, f s = «expr⊤» :=\n  @Finset.sup_eq_bot_iff («expr ᵒᵈ» α) _ _ _ _ _\n#align inf_eq_top_iff inf_eq_top_iff\n-/\n\n",
 "inf_eq_infᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print inf_eq_infᵢ /-\ntheorem inf_eq_infᵢ [CompleteLattice β] (s : Finset α) (f : α → β) :\n    s.inf f = «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f a) :=\n  @sup_eq_supᵢ _ («expr ᵒᵈ» β) _ _ _\n#align inf_eq_infi inf_eq_infᵢ\n-/\n\n",
 "inf_eq_Inf_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inf_eq_Inf_image [CompleteLattice β] (s : Finset α) (f : α → β) : s.inf f = infₛ («expr '' » f s) :=\n  @sup_eq_supₛ_image _ («expr ᵒᵈ» β) _ _ _\n#align inf_eq_Inf_image inf_eq_Inf_image\n\n",
 "inf_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem inf_empty : (∅ : Finset β).inf f = «expr⊤» :=\n  fold_empty\n#align inf_empty inf_empty\n\n",
 "inf_def":
 "-- TODO: define with just `[has_top α]` where some lemmas hold without requiring `[order_top α]`\ntheorem inf_def : s.inf f = (s.1.map f).inf :=\n  rfl\n#align inf_def inf_def\n\n",
 "inf_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf_const {s : Finset β} (h : s.nonempty) (c : α) : (s.inf fun _ => c) = c :=\n  @sup_const («expr ᵒᵈ» α) _ _ _ _ h _\n#align inf_const inf_const\n\n",
 "inf_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_cons {b : β} (h : b ∉ s) : (cons b s h).inf f = «expr ⊓ » (f b) (s.inf f) :=\n  @sup_cons («expr ᵒᵈ» α) _ _ _ _ _ _ h\n#align inf_cons inf_cons\n\n",
 "inf_congr":
 "theorem inf_congr {f g : β → α} (hs : s₁ = s₂) (hfg : ∀ a ∈ s₂, f a = g a) : s₁.inf f = s₂.inf g := by\n  subst hs <;> exact Finset.fold_congr hfg\n#align inf_congr inf_congr\n\n",
 "inf_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n#print inf_comm /-\nprotected theorem inf_comm (s : Finset β) (t : Finset γ) (f : β → γ → α) :\n    (s.inf fun b => t.inf (f b)) = t.inf fun c => s.inf fun b => f b c :=\n  @Finset.sup_comm («expr ᵒᵈ» α) _ _ _ _ _ _ _\n#align inf_comm inf_comm\n-/\n\n",
 "inf_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- Computing `inf` in a subtype (closed under `inf`) is the same as computing it in `α`. -/\ntheorem inf_coe {P : α → Prop} {Ptop : P («expr⊤»)} {Pinf : ∀ ⦃x y⦄, P x → P y → P («expr ⊓ » x y)} (t : Finset β)\n    (f : β → { x : α // P x }) :\n    (@inf _ _ (Subtype.semilatticeInf Pinf) (Subtype.orderTop Ptop) t f : α) = t.inf fun x => f x :=\n  @sup_coe («expr ᵒᵈ» α) _ _ _ _ Ptop Pinf t f\n#align inf_coe inf_coe\n\n",
 "inf_closed_of_inf_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a b «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_closed_of_inf_closed {s : Set α} (t : Finset α) (htne : t.nonempty) (h_subset : ↑t ⊆ s)\n    (h : ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), «expr ⊓ » a b ∈ s) : t.inf id ∈ s :=\n  @sup_closed_of_sup_closed («expr ᵒᵈ» α) _ _ _ t htne h_subset h\n#align inf_closed_of_inf_closed inf_closed_of_inf_closed\n\n",
 "inf_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem inf_bUnion [DecidableEq β] (s : Finset γ) (t : γ → Finset β) :\n    (s.bUnion t).inf f = s.inf fun x => (t x).inf f :=\n  @sup_bunionᵢ («expr ᵒᵈ» α) _ _ _ _ _ _ _ _\n#align inf_bUnion inf_bUnion\n\n",
 "inf_attach":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf_attach (s : Finset β) (f : β → α) : (s.attach.inf fun x => f x) = s.inf f :=\n  @sup_attach («expr ᵒᵈ» α) _ _ _ _ _\n#align inf_attach inf_attach\n\n",
 "inf_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\nprotected theorem inf_apply (s : Finset α) (f : α → ∀ b : β, C b) (b : β) : s.inf f b = s.inf fun a => f a b :=\n  @Finset.sup_apply _ _ (fun b => «expr ᵒᵈ» (C b)) _ _ s f b\n#align inf_apply inf_apply\n\n",
 "inf'_singleton":
 "@[simp]\ntheorem inf'_singleton {b : β} {h : ({b} : Finset β).nonempty} : ({b} : Finset β).inf' h f = f b :=\n  rfl\n#align inf'_singleton inf'_singleton\n\n",
 "inf'_mul_le_mul_inf'_of_nonneg":
 "theorem inf'_mul_le_mul_inf'_of_nonneg [LinearOrderedSemiring α] {a b : ι → α} (s : Finset ι) (H : s.nonempty)\n    (ha : ∀ i ∈ s, 0 ≤ a i) (hb : ∀ i ∈ s, 0 ≤ b i) : s.inf' H a * s.inf' H b ≤ s.inf' H (a * b) :=\n  le_inf' _ _ fun i hi => mul_le_mul (inf'_le _ hi) (inf'_le _ hi) (le_inf' _ _ hb) (ha _ hi)\n#align inf'_mul_le_mul_inf'_of_nonneg inf'_mul_le_mul_inf'_of_nonneg\n\n",
 "inf'_mem":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf'_mem (s : Set α) (w : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), «expr ⊓ » x y ∈ s) {ι : Type _} (t : Finset ι)\n    (H : t.nonempty) (p : ι → α) (h : ∀ i ∈ t, p i ∈ s) : t.inf' H p ∈ s :=\n  inf'_induction H p w h\n#align inf'_mem inf'_mem\n\n",
 "inf'_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n@[simp]\ntheorem inf'_map {s : Finset γ} {f : «expr ↪ » γ β} (g : β → α) (hs : (s.map f).nonempty)\n    (hs' : s.nonempty := Finset.map_nonempty.mp hs) : (s.map f).inf' hs g = s.inf' hs' (g ∘ f) :=\n  @sup'_map («expr ᵒᵈ» α) _ _ _ _ _ _ hs hs'\n#align inf'_map inf'_map\n\n",
 "inf'_lt_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem inf'_lt_iff : s.inf' H f < a ↔ ∃ i ∈ s, f i < a :=\n  @lt_sup'_iff («expr ᵒᵈ» α) _ _ _ H f _\n#align inf'_lt_iff inf'_lt_iff\n\n",
 "inf'_le_of_le":
 "theorem inf'_le_of_le (hb : b ∈ s) (h : f b ≤ a) : s.inf' ⟨b, hb⟩ f ≤ a :=\n  (inf'_le _ hb).trans h\n#align inf'_le_of_le inf'_le_of_le\n\n",
 "inf'_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem inf'_le_iff : s.inf' H f ≤ a ↔ ∃ i ∈ s, f i ≤ a :=\n  @le_sup'_iff («expr ᵒᵈ» α) _ _ _ H f _\n#align inf'_le_iff inf'_le_iff\n\n",
 "inf'_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf'_le (h : b ∈ s) : s.inf' ⟨b, h⟩ f ≤ f b :=\n  @le_sup' («expr ᵒᵈ» α) _ _ _ f _ h\n#align inf'_le inf'_le\n\n",
 "inf'_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf'_insert [DecidableEq β] {b : β} {h : (insert b s).nonempty} :\n    (insert b s).inf' h f = «expr ⊓ » (f b) (s.inf' H f) :=\n  @sup'_insert («expr ᵒᵈ» α) _ _ _ H f _ _ h\n#align inf'_insert inf'_insert\n\n",
 "inf'_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf'_induction {p : α → Prop} (hp : ∀ a₁, p a₁ → ∀ a₂, p a₂ → p («expr ⊓ » a₁ a₂)) (hs : ∀ b ∈ s, p (f b)) :\n    p (s.inf' H f) :=\n  @sup'_induction («expr ᵒᵈ» α) _ _ _ H f _ hp hs\n#align inf'_induction inf'_induction\n\n",
 "inf'_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf'_eq_inf {s : Finset β} (H : s.nonempty) (f : β → α) : s.inf' H f = s.inf f :=\n  @sup'_eq_sup («expr ᵒᵈ» α) _ _ _ _ H f\n#align inf'_eq_inf inf'_eq_inf\n\n",
 "inf'_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem inf'_const (a : α) : (s.inf' H fun b => a) = a :=\n  @sup'_const («expr ᵒᵈ» α) _ _ _ H _\n#align inf'_const inf'_const\n\n",
 "inf'_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf'_cons {b : β} {hb : b ∉ s} {h : (cons b s hb).nonempty} :\n    (cons b s hb).inf' h f = «expr ⊓ » (f b) (s.inf' H f) :=\n  @sup'_cons («expr ᵒᵈ» α) _ _ _ H f _ _ h\n#align inf'_cons inf'_cons\n\n",
 "inf'_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[congr]\ntheorem inf'_congr {t : Finset β} {f g : β → α} (h₁ : s = t) (h₂ : ∀ x ∈ s, f x = g x) :\n    s.inf' H f = t.inf' (h₁ ▸ H) g :=\n  @sup'_congr («expr ᵒᵈ» α) _ _ _ H _ _ _ h₁ h₂\n#align inf'_congr inf'_congr\n\n",
 "inf'_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem inf'_bUnion [DecidableEq β] {s : Finset γ} (Hs : s.nonempty) {t : γ → Finset β} (Ht : ∀ b, (t b).nonempty) :\n    (s.bUnion t).inf' (Hs.bUnion fun b _ => Ht b) f = s.inf' Hs fun b => (t b).inf' (Ht b) f :=\n  @sup'_bunionᵢ («expr ᵒᵈ» α) _ _ _ _ _ _ Hs _ Ht\n#align inf'_bUnion inf'_bUnion\n\n",
 "inf'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\nprotected theorem inf'_apply {s : Finset α} (H : s.nonempty) (f : α → ∀ b : β, C b) (b : β) :\n    s.inf' H f b = s.inf' H fun a => f a b :=\n  @Finset.sup'_apply _ _ (fun b => «expr ᵒᵈ» (C b)) _ _ H f b\n#align inf'_apply inf'_apply\n\n",
 "induction_on_min_value":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- Induction principle for `finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : finset α` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset α` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f a ≤ f x`, `p s` implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_min_value [DecidableEq ι] (f : ι → α) {p : Finset ι → Prop} (s : Finset ι) (h0 : p ∅)\n    (step : ∀ a s, a ∉ s → (∀ x ∈ s, f a ≤ f x) → p s → p (insert a s)) : p s :=\n  @induction_on_max_value («expr ᵒᵈ» α) ι _ _ _ _ s h0 step\n#align induction_on_min_value induction_on_min_value\n\n",
 "induction_on_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- Induction principle for `finset`s in a linearly ordered type: a predicate is true on all\n`s : finset α` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset α` and an element `a` strictly less than all elements of `s`, `p s`\n  implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_min [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h0 : p ∅)\n    (step : ∀ a s, (∀ x ∈ s, a < x) → p s → p (insert a s)) : p s :=\n  @induction_on_max («expr ᵒᵈ» α) _ _ _ s h0 step\n#align induction_on_min induction_on_min\n\n",
 "induction_on_max_value":
 "/-- Induction principle for `finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : finset α` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset α` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f x ≤ f a`, `p s` implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_max_value [DecidableEq ι] (f : ι → α) {p : Finset ι → Prop} (s : Finset ι) (h0 : p ∅)\n    (step : ∀ a s, a ∉ s → (∀ x ∈ s, f x ≤ f a) → p s → p (insert a s)) : p s :=\n  by\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases(s.image f).eq_empty_or_nonempty with (hne | hne)\n  · simp only [image_eq_empty] at hne\n    simp only [hne, h0]\n  · have H : (s.image f).max' hne ∈ s.image f := max'_mem (s.image f) hne\n    simp only [mem_image, exists_prop] at H\n    rcases H with ⟨a, has, hfa⟩\n    rw [← insert_erase has]\n    refine' step _ _ (not_mem_erase a s) (fun x hx => _) (ihs _ <| erase_ssubset has)\n    rw [hfa]\n    exact le_max' _ _ (mem_image_of_mem _ <| mem_of_mem_erase hx)\n#align induction_on_max_value induction_on_max_value\n\n",
 "induction_on_max":
 "/-- Induction principle for `finset`s in a linearly ordered type: a predicate is true on all\n`s : finset α` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset α` and an element `a` strictly greater than all elements of `s`, `p s`\n  implies `p (insert a s)`. -/\n@[elab_as_elim]\ntheorem induction_on_max [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h0 : p ∅)\n    (step : ∀ a s, (∀ x ∈ s, x < a) → p s → p (insert a s)) : p s :=\n  by\n  induction' s using Finset.strongInductionOn with s ihs\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · exact h0\n  · have H : s.max' hne ∈ s := max'_mem s hne\n    rw [← insert_erase H]\n    exact step _ _ (fun x => s.lt_max'_of_mem_erase_max' hne) (ihs _ <| erase_ssubset H)\n#align induction_on_max induction_on_max\n\n",
 "foldr_sup_eq_sup_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print List.foldr_sup_eq_sup_toFinset /-\ntheorem List.foldr_sup_eq_sup_toFinset [DecidableEq α] (l : List α) :\n    l.foldr («expr ⊔ » · ·) («expr⊥») = l.to_finset.sup id :=\n  by\n  rw [← coe_fold_r, ← Multiset.fold_dedup_idem, sup_def, ← List.toFinset_coe, to_finset_val, Multiset.map_id]\n  rfl\n#align list.foldr_sup_eq_sup_to_finset List.foldr_sup_eq_sup_toFinset\n-/\n\n",
 "foldr_inf_eq_inf_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print List.foldr_inf_eq_inf_toFinset /-\ntheorem List.foldr_inf_eq_inf_toFinset [DecidableEq α] (l : List α) :\n    l.foldr («expr ⊓ » · ·) («expr⊤») = l.to_finset.inf id :=\n  by\n  rw [← coe_fold_r, ← Multiset.fold_dedup_idem, inf_def, ← List.toFinset_coe, to_finset_val, Multiset.map_id]\n  rfl\n#align list.foldr_inf_eq_inf_to_finset List.foldr_inf_eq_inf_toFinset\n-/\n\n",
 "exists_next_right":
 "theorem exists_next_right {x : α} {s : Finset α} (h : ∃ y ∈ s, x < y) : ∃ y ∈ s, x < y ∧ ∀ z ∈ s, x < z → y ≤ z :=\n  have Hne : (s.filter ((· < ·) x)).nonempty := h.imp fun y hy => mem_filter.2 ⟨hy.fst, hy.snd⟩\n  ⟨min' _ Hne, (mem_filter.1 (min'_mem _ Hne)).1, (mem_filter.1 (min'_mem _ Hne)).2, fun z hzs hz =>\n    min'_le _ _ <| mem_filter.2 ⟨hzs, hz⟩⟩\n#align exists_next_right exists_next_right\n\n",
 "exists_next_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem exists_next_left {x : α} {s : Finset α} (h : ∃ y ∈ s, y < x) : ∃ y ∈ s, y < x ∧ ∀ z ∈ s, z < x → z ≤ y :=\n  @exists_next_right («expr ᵒᵈ» α) _ x s h\n#align exists_next_left exists_next_left\n\n",
 "exists_nat_subset_range":
 "theorem exists_nat_subset_range (s : Finset ℕ) : ∃ n : ℕ, s ⊆ range n :=\n  ⟨_, s.subset_range_sup_succ⟩\n#align exists_nat_subset_range exists_nat_subset_range\n\n",
 "exists_min_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem exists_min_image (s : Finset β) (f : β → α) (h : s.nonempty) : ∃ x ∈ s, ∀ x' ∈ s, f x ≤ f x' :=\n  @exists_max_image («expr ᵒᵈ» α) β _ s f h\n#align exists_min_image exists_min_image\n\n",
 "exists_mem_eq_sup'":
 "theorem exists_mem_eq_sup' (f : ι → α) : ∃ i, i ∈ s ∧ s.sup' H f = f i :=\n  by\n  refine' H.cons_induction (fun c => _) fun c s hc hs ih => _\n  · exact ⟨c, mem_singleton_self c, rfl⟩\n  · rcases ih with ⟨b, hb, h'⟩\n    rw [sup'_cons hs, h']\n    cases' total_of (· ≤ ·) (f b) (f c) with h h\n    · exact ⟨c, mem_cons.2 (or.inl rfl), sup_eq_left.2 h⟩\n    · exact ⟨b, mem_cons.2 (or.inr hb), sup_eq_right.2 h⟩\n#align exists_mem_eq_sup' exists_mem_eq_sup'\n\n",
 "exists_mem_eq_sup":
 "theorem exists_mem_eq_sup [OrderBot α] (s : Finset ι) (h : s.nonempty) (f : ι → α) : ∃ i, i ∈ s ∧ s.sup f = f i :=\n  sup'_eq_sup h f ▸ exists_mem_eq_sup' h f\n#align exists_mem_eq_sup exists_mem_eq_sup\n\n",
 "exists_mem_eq_inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem exists_mem_eq_inf' (f : ι → α) : ∃ i, i ∈ s ∧ s.inf' H f = f i :=\n  @exists_mem_eq_sup' («expr ᵒᵈ» α) _ _ _ H f\n#align exists_mem_eq_inf' exists_mem_eq_inf'\n\n",
 "exists_mem_eq_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem exists_mem_eq_inf [OrderTop α] (s : Finset ι) (h : s.nonempty) (f : ι → α) : ∃ i, i ∈ s ∧ s.inf f = f i :=\n  @exists_mem_eq_sup («expr ᵒᵈ» α) _ _ _ _ h f\n#align exists_mem_eq_inf exists_mem_eq_inf\n\n",
 "exists_max_image":
 "theorem exists_max_image (s : Finset β) (f : β → α) (h : s.nonempty) : ∃ x ∈ s, ∀ x' ∈ s, f x' ≤ f x :=\n  by\n  cases' max_of_nonempty (h.image f) with y hy\n  rcases mem_image.mp (mem_of_max hy) with ⟨x, hx, rfl⟩\n  exact ⟨x, hx, fun x' hx' => le_max_of_eq (mem_image_of_mem f hx') hy⟩\n#align exists_max_image exists_max_image\n\n",
 "disjoint_sup_right":
 "#print disjoint_sup_right /-\nprotected theorem disjoint_sup_right : Disjoint a (s.sup f) ↔ ∀ i ∈ s, Disjoint a (f i) := by\n  simp only [disjoint_iff, sup_inf_distrib_left, sup_eq_bot_iff]\n#align disjoint_sup_right disjoint_sup_right\n-/\n\n",
 "disjoint_sup_left":
 "#print disjoint_sup_left /-\nprotected theorem disjoint_sup_left : Disjoint (s.sup f) a ↔ ∀ i ∈ s, Disjoint (f i) a := by\n  simp only [disjoint_iff, sup_inf_distrib_right, sup_eq_bot_iff]\n#align disjoint_sup_left disjoint_sup_left\n-/\n\n",
 "count_finset_sup":
 "theorem count_finset_sup [DecidableEq β] (s : Finset α) (f : α → Multiset β) (b : β) :\n    count b (s.sup f) = s.sup fun a => count b (f a) :=\n  by\n  letI := Classical.decEq α\n  refine' s.induction _ _\n  · exact count_zero _\n  · intro i s his ih\n    rw [Finset.sup_insert, sup_eq_union, count_union, Finset.sup_insert, ih]\n    rfl\n#align count_finset_sup count_finset_sup\n\n",
 "comp_sup_eq_sup_comp_of_is_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comp_sup_eq_sup_comp_of_is_total [SemilatticeSup β] [OrderBot β] (g : α → β) (mono_g : Monotone g)\n    (bot : g («expr⊥») = «expr⊥») : g (s.sup f) = s.sup (g ∘ f) :=\n  comp_sup_eq_sup_comp g mono_g.map_sup bot\n#align comp_sup_eq_sup_comp_of_is_total comp_sup_eq_sup_comp_of_is_total\n\n",
 "comp_sup_eq_sup_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem comp_sup_eq_sup_comp [SemilatticeSup γ] [OrderBot γ] {s : Finset β} {f : β → α} (g : α → γ)\n    (g_sup : ∀ x y, g («expr ⊔ » x y) = «expr ⊔ » (g x) (g y)) (bot : g («expr⊥») = «expr⊥») :\n    g (s.sup f) = s.sup (g ∘ f) :=\n  Finset.cons_induction_on s bot fun c t hc ih => by rw [sup_cons, sup_cons, g_sup, ih]\n#align comp_sup_eq_sup_comp comp_sup_eq_sup_comp\n\n",
 "comp_sup'_eq_sup'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem comp_sup'_eq_sup'_comp [SemilatticeSup γ] {s : Finset β} (H : s.nonempty) {f : β → α} (g : α → γ)\n    (g_sup : ∀ x y, g («expr ⊔ » x y) = «expr ⊔ » (g x) (g y)) : g (s.sup' H f) = s.sup' H (g ∘ f) :=\n  by\n  rw [← WithBot.coe_eq_coe, coe_sup']\n  let g' := WithBot.map g\n  show g' ↑(s.sup' H f) = s.sup fun a => g' ↑(f a)\n  rw [coe_sup']\n  refine' comp_sup_eq_sup_comp g' _ rfl\n  intro f₁ f₂\n  induction f₁ using WithBot.recBotCoe\n  · rw [bot_sup_eq]\n    exact bot_sup_eq.symm\n  · induction f₂ using WithBot.recBotCoe\n    · rfl\n    · exact congr_arg coe (g_sup f₁ f₂)\n#align comp_sup'_eq_sup'_comp comp_sup'_eq_sup'_comp\n\n",
 "comp_inf_eq_inf_comp_of_is_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comp_inf_eq_inf_comp_of_is_total [SemilatticeInf β] [OrderTop β] (g : α → β) (mono_g : Monotone g)\n    (top : g («expr⊤») = «expr⊤») : g (s.inf f) = s.inf (g ∘ f) :=\n  comp_inf_eq_inf_comp g mono_g.map_inf top\n#align comp_inf_eq_inf_comp_of_is_total comp_inf_eq_inf_comp_of_is_total\n\n",
 "comp_inf_eq_inf_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comp_inf_eq_inf_comp [SemilatticeInf γ] [OrderTop γ] {s : Finset β} {f : β → α} (g : α → γ)\n    (g_inf : ∀ x y, g («expr ⊓ » x y) = «expr ⊓ » (g x) (g y)) (top : g («expr⊤») = «expr⊤») :\n    g (s.inf f) = s.inf (g ∘ f) :=\n  @comp_sup_eq_sup_comp («expr ᵒᵈ» α) _ («expr ᵒᵈ» γ) _ _ _ _ _ _ _ g_inf top\n#align comp_inf_eq_inf_comp comp_inf_eq_inf_comp\n\n",
 "comp_inf'_eq_inf'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comp_inf'_eq_inf'_comp [SemilatticeInf γ] {s : Finset β} (H : s.nonempty) {f : β → α} (g : α → γ)\n    (g_inf : ∀ x y, g («expr ⊓ » x y) = «expr ⊓ » (g x) (g y)) : g (s.inf' H f) = s.inf' H (g ∘ f) :=\n  @comp_sup'_eq_sup'_comp («expr ᵒᵈ» α) _ («expr ᵒᵈ» γ) _ _ _ H f g g_inf\n#align comp_inf'_eq_inf'_comp comp_inf'_eq_inf'_comp\n\n",
 "coe_sup_of_nonempty":
 "theorem coe_sup_of_nonempty {s : Finset β} (h : s.nonempty) (f : β → α) : (↑(s.sup f) : WithBot α) = s.sup (coe ∘ f) :=\n  by simp only [← sup'_eq_sup h, coe_sup' h]\n#align coe_sup_of_nonempty coe_sup_of_nonempty\n\n",
 "coe_sup'":
 "@[simp]\ntheorem coe_sup' : ((s.sup' H f : α) : WithBot α) = s.sup (coe ∘ f) := by rw [sup', WithBot.coe_unbot]\n#align coe_sup' coe_sup'\n\n",
 "coe_min'":
 "theorem coe_min' {s : Finset α} (hs : s.nonempty) : ↑(s.min' hs) = s.min :=\n  coe_inf' hs id\n#align coe_min' coe_min'\n\n",
 "coe_max'":
 "theorem coe_max' {s : Finset α} (hs : s.nonempty) : ↑(s.max' hs) = s.max :=\n  coe_sup' hs id\n#align coe_max' coe_max'\n\n",
 "coe_inf_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem coe_inf_of_nonempty {s : Finset β} (h : s.nonempty) (f : β → α) :\n    (↑(s.inf f) : WithTop α) = s.inf fun i => f i :=\n  @coe_sup_of_nonempty («expr ᵒᵈ» α) _ _ _ _ h f\n#align coe_inf_of_nonempty coe_inf_of_nonempty\n\n",
 "coe_inf'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n@[simp]\ntheorem coe_inf' : ((s.inf' H f : α) : WithTop α) = s.inf (coe ∘ f) :=\n  @coe_sup' («expr ᵒᵈ» α) _ _ _ H f\n#align coe_inf' coe_inf'\n\n",
 "card_le_of_interleaved":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/-- If finsets `s` and `t` are interleaved, then `finset.card s ≤ finset.card t + 1`. -/\ntheorem card_le_of_interleaved {s t : Finset α}\n    (h : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), x < y → (∀ z ∈ s, z ∉ Set.Ioo x y) → ∃ z ∈ t, x < z ∧ z < y) :\n    s.card ≤ t.card + 1 :=\n  by\n  replace h : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), x < y → ∃ z ∈ t, x < z ∧ z < y\n  · intro x hx y hy hxy\n    rcases exists_next_right ⟨y, hy, hxy⟩ with ⟨a, has, hxa, ha⟩\n    rcases h x hx a has hxa fun z hzs hz => hz.2.not_le <| ha _ hzs hz.1 with ⟨b, hbt, hxb, hba⟩\n    exact ⟨b, hbt, hxb, hba.trans_le <| ha _ hy hxy⟩\n  set f : α → WithTop α := fun x => (t.filter fun y => x < y).min\n  have f_mono : StrictMonoOn f s := by\n    intro x hx y hy hxy\n    rcases h x hx y hy hxy with ⟨a, hat, hxa, hay⟩\n    calc\n      f x ≤ a := min_le (mem_filter.2 ⟨hat, hxa⟩)\n      _ < f y :=\n        (Finset.lt_inf_iff <| WithTop.coe_lt_top a).2 fun b hb => WithTop.coe_lt_coe.2 <| hay.trans (mem_filter.1 hb).2\n      \n  calc\n    s.card = (s.image f).card := (card_image_of_inj_on f_mono.inj_on).symm\n    _ ≤ (insert («expr⊤») (t.image coe) : Finset (WithTop α)).card :=\n      (card_mono <|\n        image_subset_iff.2 fun x hx =>\n          insert_subset_insert _ (image_subset_image <| filter_subset _ _) (min_mem_insert_top_image_coe _))\n    _ ≤ t.card + 1 := (card_insert_le _ _).trans (add_le_add_right card_image_le _)\n    \n#align card_le_of_interleaved card_le_of_interleaved\n\n",
 "card_le_diff_of_interleaved":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » s) -/\n/-- If finsets `s` and `t` are interleaved, then `finset.card s ≤ finset.card (t \\ s) + 1`. -/\ntheorem card_le_diff_of_interleaved {s t : Finset α}\n    (h : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s), x < y → (∀ z ∈ s, z ∉ Set.Ioo x y) → ∃ z ∈ t, x < z ∧ z < y) :\n    s.card ≤ (t \\ s).card + 1 :=\n  card_le_of_interleaved fun x hx y hy hxy hs =>\n    let ⟨z, hzt, hxz, hzy⟩ := h x hx y hy hxy hs\n    ⟨z, mem_sdiff.2 ⟨hzt, fun hzs => hs z hzs ⟨hxz, hzy⟩⟩, hxz, hzy⟩\n#align card_le_diff_of_interleaved card_le_diff_of_interleaved\n\n",
 "Union_eq_Union_finset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Union of an indexed family of sets `s : ι → set α` is equal to the union of the unions\nof finite subfamilies. This version works for `ι : Sort*`. See also `Union_eq_Union_finset` for\na version that assumes `ι : Type*` but avoids `plift`s in the right hand side. -/\ntheorem Union_eq_Union_finset' (s : ι' → Set α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (s (PLift.down i))) :=\n  supᵢ_eq_supᵢ_finset' s\n#align Union_eq_Union_finset' Union_eq_Union_finset'\n\n",
 "Union_eq_Union_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Union of an indexed family of sets `s : ι → set α` is equal to the union of the unions\nof finite subfamilies. This version assumes `ι : Type*`. See also `Union_eq_Union_finset'` for\na version that works for `ι : Sort*`. -/\ntheorem Union_eq_Union_finset (s : ι → Set α) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :=\n  supᵢ_eq_supᵢ_finset s\n#align Union_eq_Union_finset Union_eq_Union_finset\n\n",
 "Inter_eq_Inter_finset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Intersection of an indexed family of sets `s : ι → set α` is equal to the intersection of the\nintersections of finite subfamilies. This version works for `ι : Sort*`. See also\n`Inter_eq_Inter_finset` for a version that assumes `ι : Type*` but avoids `plift`s in the right\nhand side. -/\ntheorem Inter_eq_Inter_finset' (s : ι' → Set α) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          (s (PLift.down i))) :=\n  infᵢ_eq_infᵢ_finset' s\n#align Inter_eq_Inter_finset' Inter_eq_Inter_finset'\n\n",
 "Inter_eq_Inter_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- Intersection of an indexed family of sets `s : ι → set α` is equal to the intersection of the\nintersections of finite subfamilies. This version assumes `ι : Type*`. See also\n`Inter_eq_Inter_finset'` for a version that works for `ι : Sort*`. -/\ntheorem Inter_eq_Inter_finset (s : ι → Set α) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) :=\n  infᵢ_eq_infᵢ_finset s\n#align Inter_eq_Inter_finset Inter_eq_Inter_finset\n\n"}