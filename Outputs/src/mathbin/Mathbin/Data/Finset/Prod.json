{"union_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem union_product [decidable_eq α] [decidable_eq β] :\n    finset.product (s ∪ s') t = finset.product s t ∪ finset.product s' t :=\n  by\n  ext ⟨x, y⟩\n  simp only [or_and_right, mem_union, mem_product]\n#align union_product union_product\n\n",
 "subset_product_image_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem subset_product_image_snd [decidable_eq β] : (finset.product s t).image prod.snd ⊆ t := fun i => by\n  simp (config := { contextual := true }) [mem_image]\n#align subset_product_image_snd subset_product_image_snd\n\n",
 "subset_product_image_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem subset_product_image_fst [decidable_eq α] : (finset.product s t).image prod.fst ⊆ s := fun i => by\n  simp (config := { contextual := true }) [mem_image]\n#align subset_product_image_fst subset_product_image_fst\n\n",
 "subset_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem subset_product [decidable_eq α] [decidable_eq β] {s : Finset (α × β)} :\n    s ⊆ finset.product (s.image prod.fst) (s.image prod.snd) := fun p hp =>\n  mem_product.2 ⟨mem_image_of_mem _ hp, mem_image_of_mem _ hp⟩\n#align subset_product subset_product\n\n",
 "snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem nonempty.snd (h : (finset.product s t).nonempty) : t.nonempty :=\n  let ⟨xy, hxy⟩ := h\n  ⟨xy.2, (mem_product.1 hxy).2⟩\n#align nonempty.snd nonempty.snd\n\n",
 "singleton_product_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem singleton_product_singleton {a : α} {b : β} : finset.product ({a} : Finset α) ({b} : Finset β) = {(a, b)} := by\n  simp only [product_singleton, Function.Embedding.coeFn_mk, map_singleton]\n#align singleton_product_singleton singleton_product_singleton\n\n",
 "singleton_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem singleton_product {a : α} : finset.product ({a} : Finset α) t = t.map ⟨prod.mk a, prod.mk.inj_left _⟩ :=\n  by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n#align singleton_product singleton_product\n\n",
 "product_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Oliver Nash\n-/\n-- This notation binds more strongly than (pre)images, unions and intersections.\n@[simp]\ntheorem product_val : (finset.product s t).1 = finset.product s.1 t.1 :=\n  rfl\n#align product_val product_val\n\n",
 "product_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem product_union [decidable_eq α] [decidable_eq β] :\n    finset.product s (t ∪ t') = finset.product s t ∪ finset.product s t' :=\n  by\n  ext ⟨x, y⟩\n  simp only [and_or_left, mem_union, mem_product]\n#align product_union product_union\n\n",
 "product_subset_product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_subset_product_right (ht : t ⊆ t') : finset.product s t ⊆ finset.product s t' :=\n  product_subset_product (Subset.refl _) ht\n#align product_subset_product_right product_subset_product_right\n\n",
 "product_subset_product_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_subset_product_left (hs : s ⊆ s') : finset.product s t ⊆ finset.product s' t :=\n  product_subset_product hs (Subset.refl _)\n#align product_subset_product_left product_subset_product_left\n\n",
 "product_subset_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_subset_product (hs : s ⊆ s') (ht : t ⊆ t') : finset.product s t ⊆ finset.product s' t' :=\n  fun ⟨x, y⟩ h => mem_product.2 ⟨hs (mem_product.1 h).1, ht (mem_product.1 h).2⟩\n#align product_subset_product product_subset_product\n\n",
 "product_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem product_singleton {b : β} : finset.product s {b} = s.map ⟨fun i => (i, b), prod.mk.inj_right _⟩ :=\n  by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n#align product_singleton product_singleton\n\n",
 "product_sdiff_off_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_sdiff_off_diag : finset.product s s \\ s.off_diag = s.diag := by\n  rw [← diag_union_off_diag, union_sdiff_self, sdiff_eq_self_of_disjoint (disjoint_diag_off_diag _)]\n#align product_sdiff_off_diag product_sdiff_off_diag\n\n",
 "product_sdiff_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_sdiff_diag : finset.product s s \\ s.diag = s.off_diag := by\n  rw [← diag_union_off_diag, union_comm, union_sdiff_self, sdiff_eq_self_of_disjoint (disjoint_diag_off_diag _).symm]\n#align product_sdiff_diag product_sdiff_diag\n\n",
 "product_inter_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_inter_product [decidable_eq α] [decidable_eq β] :\n    finset.product s t ∩ finset.product s' t' = finset.product (s ∩ s') (t ∩ t') :=\n  by\n  ext ⟨x, y⟩\n  simp only [and_assoc', and_left_comm, mem_inter, mem_product]\n#align product_inter_product product_inter_product\n\n",
 "product_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_inter [decidable_eq α] [decidable_eq β] :\n    finset.product s (t ∩ t') = finset.product s t ∩ finset.product s t' :=\n  by\n  ext ⟨x, y⟩\n  simp only [← and_and_left, mem_inter, mem_product]\n#align product_inter product_inter\n\n",
 "product_image_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_image_snd [decidable_eq β] (ht : s.nonempty) : (finset.product s t).image prod.snd = t :=\n  by\n  ext i\n  simp [mem_image, ht.bex]\n#align product_image_snd product_image_snd\n\n",
 "product_image_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_image_fst [decidable_eq α] (ht : t.nonempty) : (finset.product s t).image prod.fst = s :=\n  by\n  ext i\n  simp [mem_image, ht.bex]\n#align product_image_fst product_image_fst\n\n",
 "product_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem product_eq_empty {s : Finset α} {t : Finset β} : finset.product s t = ∅ ↔ s = ∅ ∨ t = ∅ := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_product, not_and_or, not_nonempty_iff_eq_empty, not_nonempty_iff_eq_empty]\n#align product_eq_empty product_eq_empty\n\n",
 "product_eq_bUnion_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_eq_bUnion_right [decidable_eq α] [decidable_eq β] (s : Finset α) (t : Finset β) :\n    finset.product s t = t.bUnion fun b => s.image fun a => (a, b) :=\n  ext fun ⟨x, y⟩ => by\n    simp only [mem_product, mem_bUnion, mem_image, exists_prop, prod.mk.inj_iff, and_left_comm, exists_and_left,\n      exists_eq_right, exists_eq_left]\n#align product_eq_bUnion_right product_eq_bUnion_right\n\n",
 "product_eq_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_eq_bUnion [decidable_eq α] [decidable_eq β] (s : Finset α) (t : Finset β) :\n    finset.product s t = s.bUnion fun a => t.image fun b => (a, b) :=\n  ext fun ⟨x, y⟩ => by\n    simp only [mem_product, mem_bUnion, mem_image, exists_prop, prod.mk.inj_iff, and_left_comm, exists_and_left,\n      exists_eq_right, exists_eq_left]\n#align product_eq_bUnion product_eq_bUnion\n\n",
 "product_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem product_empty (s : Finset α) : finset.product s (∅ : Finset β) = ∅ :=\n  eq_empty_of_forall_not_mem fun x h => (finset.mem_product.1 h).2\n#align product_empty product_empty\n\n",
 "product_disj_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem product_disj_union (ht : Disjoint t t') :\n    finset.product s (t.disj_union t' ht) =\n      (finset.product s t).disj_union (finset.product s t') (disjoint_product.mpr <| or.inr ht) :=\n  eq_of_veq <| Multiset.product_add _ _ _\n#align product_disj_union product_disj_union\n\n",
 "product_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-- See also `finset.sup_product_left`. -/\n@[simp]\ntheorem product_bUnion [decidable_eq γ] (s : Finset α) (t : Finset β) (f : α × β → Finset γ) :\n    (finset.product s t).bUnion f = s.bUnion fun a => t.bUnion fun b => f (a, b) := by\n  classical simp_rw [product_eq_bUnion, bUnion_bUnion, image_bUnion]\n#align product_bUnion product_bUnion\n\n",
 "product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem nonempty.product (hs : s.nonempty) (ht : t.nonempty) : (finset.product s t).nonempty :=\n  let ⟨x, hx⟩ := hs\n  let ⟨y, hy⟩ := ht\n  ⟨(x, y), mem_product.2 ⟨hx, hy⟩⟩\n#align nonempty.product nonempty.product\n\n",
 "off_diag_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem off_diag_union (h : Disjoint s t) :\n    (s ∪ t).off_diag = s.off_diag ∪ t.off_diag ∪ finset.product s t ∪ finset.product t s :=\n  coe_injective <| by\n    push_cast\n    exact Set.offDiag_union (disjoint_coe.2 h)\n#align off_diag_union off_diag_union\n\n",
 "off_diag_singleton":
 "@[simp]\ntheorem off_diag_singleton : ({a} : Finset α).off_diag = ∅ := by simp [← finset.card_eq_zero]\n#align off_diag_singleton off_diag_singleton\n\n",
 "off_diag_mono":
 "@[mono]\ntheorem off_diag_mono : monotone (off_diag : Finset α → Finset (α × α)) := fun s t h x hx =>\n  mem_off_diag.2 <| and.imp (@h _) (and.imp_left <| @h _) <| mem_off_diag.1 hx\n#align off_diag_mono off_diag_mono\n\n",
 "off_diag_inter":
 "theorem off_diag_inter : (s ∩ t).off_diag = s.off_diag ∩ t.off_diag :=\n  coe_injective <| by\n    push_cast\n    exact Set.offDiag_inter _ _\n#align off_diag_inter off_diag_inter\n\n",
 "off_diag_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem off_diag_insert (has : a ∉ s) :\n    (insert a s).off_diag = s.off_diag ∪ finset.product {a} s ∪ finset.product s {a} := by\n  rw [insert_eq, union_comm, off_diag_union (disjoint_singleton_right.2 has), off_diag_singleton, union_empty,\n    union_right_comm]\n#align off_diag_insert off_diag_insert\n\n",
 "off_diag_empty":
 "@[simp]\ntheorem off_diag_empty : (∅ : Finset α).off_diag = ∅ :=\n  rfl\n#align off_diag_empty off_diag_empty\n\n",
 "off_diag_card":
 "@[simp]\ntheorem off_diag_card : (off_diag s).card = s.card * s.card - s.card :=\n  by\n  suffices (diag s).card + (off_diag s).card = s.card * s.card\n    by\n    nth_rw 3 [← s.diag_card]\n    simp only [diag_card] at *\n    rw [tsub_eq_of_eq_add_rev]\n    rw [this]\n  rw [← card_product]\n  apply filter_card_add_filter_neg_card_eq_card\n#align off_diag_card off_diag_card\n\n",
 "nonempty_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem nonempty_product : (finset.product s t).nonempty ↔ s.nonempty ∧ t.nonempty :=\n  ⟨fun h => ⟨h.fst, h.snd⟩, fun h => h.1.product h.2⟩\n#align nonempty_product nonempty_product\n\n",
 "mk_mem_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mk_mem_product (ha : a ∈ s) (hb : b ∈ t) : (a, b) ∈ finset.product s t :=\n  mem_product.2 ⟨ha, hb⟩\n#align mk_mem_product mk_mem_product\n\n",
 "mem_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem mem_product {p : α × β} : p ∈ finset.product s t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  mem_product\n#align mem_product mem_product\n\n",
 "mem_off_diag":
 "@[simp]\ntheorem mem_off_diag : x ∈ s.off_diag ↔ x.1 ∈ s ∧ x.2 ∈ s ∧ x.1 ≠ x.2 :=\n  by\n  simp only [off_diag, mem_filter, mem_product]\n  constructor <;> intro h <;> simp only [h, ne.def, not_false_iff, and_self_iff]\n#align mem_off_diag mem_off_diag\n\n",
 "mem_diag":
 "@[simp]\ntheorem mem_diag : x ∈ s.diag ↔ x.1 ∈ s ∧ x.1 = x.2 :=\n  by\n  simp only [diag, mem_filter, mem_product]\n  constructor <;> intro h <;> simp only [h, and_true_iff, eq_self_iff_true, and_self_iff]\n  rw [← h.2]\n  exact h.1\n#align mem_diag mem_diag\n\n",
 "map_swap_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem map_swap_product (s : Finset α) (t : Finset β) :\n    (finset.product t s).map ⟨prod.swap, prod.swap_injective⟩ = finset.product s t :=\n  coe_injective <| by\n    push_cast\n    exact Set.image_swap_prod _ _\n#align map_swap_product map_swap_product\n\n",
 "inter_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem inter_product [decidable_eq α] [decidable_eq β] :\n    finset.product (s ∩ s') t = finset.product s t ∩ finset.product s' t :=\n  by\n  ext ⟨x, y⟩\n  simp only [← and_and_right, mem_inter, mem_product]\n#align inter_product inter_product\n\n",
 "image_swap_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem image_swap_product [decidable_eq α] [decidable_eq β] (s : Finset α) (t : Finset β) :\n    (finset.product t s).image prod.swap = finset.product s t :=\n  coe_injective <| by\n    push_cast\n    exact Set.image_swap_prod _ _\n#align image_swap_product image_swap_product\n\n",
 "fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem nonempty.fst (h : (finset.product s t).nonempty) : s.nonempty :=\n  let ⟨xy, hxy⟩ := h\n  ⟨xy.1, (mem_product.1 hxy).1⟩\n#align nonempty.fst nonempty.fst\n\n",
 "filter_product_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem filter_product_right (q : β → Prop) [decidable_pred q] :\n    ((finset.product s t).filter fun x : α × β => q x.2) = finset.product s (t.filter q) := by\n  simpa using filter_product (fun _ : α => true) q\n#align filter_product_right filter_product_right\n\n",
 "filter_product_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem filter_product_left (p : α → Prop) [decidable_pred p] :\n    ((finset.product s t).filter fun x : α × β => p x.1) = finset.product (s.filter p) t := by\n  simpa using filter_product p fun _ => true\n#align filter_product_left filter_product_left\n\n",
 "filter_product_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem filter_product_card (s : Finset α) (t : Finset β) (p : α → Prop) (q : β → Prop) [decidable_pred p]\n    [decidable_pred q] :\n    ((finset.product s t).filter fun x : α × β => p x.1 ↔ q x.2).card =\n      (s.filter p).card * (t.filter q).card + (s.filter (not ∘ p)).card * (t.filter (not ∘ q)).card :=\n  by\n  classical\n    rw [← card_product, ← card_product, ← filter_product, ← filter_product, ← card_union_eq]\n    · apply congr_arg\n      ext ⟨a, b⟩\n      simp only [filter_union_right, mem_filter, mem_product]\n      constructor <;> intro h <;> use h.1\n      simp only [Function.comp_apply, and_self_iff, h.2, em (q b)]\n      cases h.2 <;>\n        · try simp at h_1\n          simp [h_1]\n    · apply Finset.disjoint_filter_filter'\n      exact (disjoint_compl_right.inf_left _).inf_right _\n#align filter_product_card filter_product_card\n\n",
 "filter_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem filter_product (p : α → Prop) (q : β → Prop) [decidable_pred p] [decidable_pred q] :\n    ((finset.product s t).filter fun x : α × β => p x.1 ∧ q x.2) = finset.product (s.filter p) (t.filter q) :=\n  by\n  ext ⟨a, b⟩\n  simp only [mem_filter, mem_product]\n  exact and_and_and_comm (a ∈ s) (b ∈ t) (p a) (q b)\n#align filter_product filter_product\n\n",
 "empty_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem empty_product (t : Finset β) : finset.product (∅ : Finset α) t = ∅ :=\n  rfl\n#align empty_product empty_product\n\n",
 "disjoint_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem disjoint_product : Disjoint (finset.product s t) (finset.product s' t') ↔ Disjoint s s' ∨ Disjoint t t' := by\n  simp_rw [← disjoint_coe, coe_product, Set.disjoint_prod]\n#align disjoint_product disjoint_product\n\n",
 "disjoint_diag_off_diag":
 "@[simp]\ntheorem disjoint_diag_off_diag : Disjoint s.diag s.off_diag :=\n  disjoint_filter_filter_neg _ _ _\n#align disjoint_diag_off_diag disjoint_diag_off_diag\n\n",
 "disj_union_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem disj_union_product (hs : Disjoint s s') :\n    finset.product (s.disj_union s' hs) t =\n      (finset.product s t).disj_union (finset.product s' t) (disjoint_product.mpr <| or.inl hs) :=\n  eq_of_veq <| Multiset.add_product _ _ _\n#align disj_union_product disj_union_product\n\n",
 "diag_union_off_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem diag_union_off_diag : s.diag ∪ s.off_diag = finset.product s s :=\n  filter_union_filter_neg_eq _ _\n#align diag_union_off_diag diag_union_off_diag\n\n",
 "diag_union":
 "theorem diag_union : (s ∪ t).diag = s.diag ∪ t.diag :=\n  by\n  ext ⟨i, j⟩\n  simp only [mem_diag, mem_union, or_and_right]\n#align diag_union diag_union\n\n",
 "diag_singleton":
 "theorem diag_singleton : ({a} : Finset α).diag = {(a, a)} := by\n  rw [← product_sdiff_off_diag, off_diag_singleton, sdiff_empty, singleton_product_singleton]\n#align diag_singleton diag_singleton\n\n",
 "diag_mono":
 "@[mono]\ntheorem diag_mono : monotone (diag : Finset α → Finset (α × α)) := fun s t h x hx =>\n  mem_diag.2 <| and.imp_left (@h _) <| mem_diag.1 hx\n#align diag_mono diag_mono\n\n",
 "diag_inter":
 "theorem diag_inter : (s ∩ t).diag = s.diag ∩ t.diag :=\n  ext fun x => by simpa only [mem_diag, mem_inter] using and_and_right _ _ _\n#align diag_inter diag_inter\n\n",
 "diag_insert":
 "theorem diag_insert : (insert a s).diag = insert (a, a) s.diag := by\n  rw [insert_eq, insert_eq, diag_union, diag_singleton]\n#align diag_insert diag_insert\n\n",
 "diag_empty":
 "@[simp]\ntheorem diag_empty : (∅ : Finset α).diag = ∅ :=\n  rfl\n#align diag_empty diag_empty\n\n",
 "diag_card":
 "@[simp]\ntheorem diag_card : (diag s).card = s.card :=\n  by\n  suffices diag s = s.image fun a => (a, a) by\n    rw [this]\n    apply card_image_of_inj_on\n    exact fun x1 h1 x2 h2 h3 => (prod.mk.inj h3).1\n  ext ⟨a₁, a₂⟩\n  rw [mem_diag]\n  constructor <;> intro h <;> rw [Finset.mem_image] at *\n  · use a₁, h.1, prod.mk.inj_iff.mpr ⟨rfl, h.2⟩\n  · rcases h with ⟨a, h1, h2⟩\n    have h := prod.mk.inj h2\n    rw [← h.1, ← h.2]\n    use h1\n#align diag_card diag_card\n\n",
 "coe_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp, norm_cast]\ntheorem coe_product (s : Finset α) (t : Finset β) : (↑(finset.product s t) : set (α × β)) = finset.product s t :=\n  Set.ext fun x => finset.mem_product\n#align coe_product coe_product\n\n",
 "coe_off_diag":
 "@[simp, norm_cast]\ntheorem coe_off_diag : (s.off_diag : set (α × α)) = (s : set α).off_diag :=\n  Set.ext fun _ => mem_off_diag\n#align coe_off_diag coe_off_diag\n\n",
 "card_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem card_product (s : Finset α) (t : Finset β) : card (finset.product s t) = card s * card t :=\n  Multiset.card_product _ _\n#align card_product card_product\n\n"}