{"pi_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem _root_.monoid_hom.pi_ext [Finite ι] [decidable_eq ι] {f g : «expr →* » (∀ i, M i) γ}\n    (h : ∀ i x, f (Pi.mulSingle i x) = g (Pi.mulSingle i x)) : f = g :=\n  by\n  cases nonempty_fintype ι\n  ext x\n  rw [← noncomm_prod_mul_single x, univ.noncomm_prod_map, univ.noncomm_prod_map]\n  congr 1 with i; exact h i (x i)\n#align monoid_hom.pi_ext monoid_hom.pi_ext\n\n",
 "noncomm_prod_union_of_disjoint":
 "/-- The non-commutative version of `finset.prod_union` -/\n@[to_additive \"The non-commutative version of `finset.sum_union`\"]\ntheorem noncomm_prod_union_of_disjoint [decidable_eq α] {s t : Finset α} (h : Disjoint s t) (f : α → β)\n    (comm : { x | x ∈ s ∪ t }.pairwise fun a b => Commute (f a) (f b)) :\n    noncomm_prod (s ∪ t) f comm =\n      noncomm_prod s f (comm.mono <| coe_subset.2 <| subset_union_left _ _) *\n        noncomm_prod t f (comm.mono <| coe_subset.2 <| subset_union_right _ _) :=\n  by\n  obtain ⟨sl, sl', rfl⟩ := exists_list_nodup_eq s\n  obtain ⟨tl, tl', rfl⟩ := exists_list_nodup_eq t\n  rw [List.disjoint_toFinset_iff_disjoint] at h\n  simp [sl', tl', noncomm_prod_to_finset, ← List.prod_append, ← List.toFinset_append, sl'.append tl' h]\n#align noncomm_prod_union_of_disjoint noncomm_prod_union_of_disjoint\n\n",
 "noncomm_prod_to_finset":
 "@[simp, to_additive]\ntheorem noncomm_prod_to_finset [decidable_eq α] (l : list α) (f : α → β) (comm) (hl : l.nodup) :\n    noncomm_prod l.to_finset f comm = (l.map f).prod :=\n  by\n  rw [← List.dedup_eq_self] at hl\n  simp [noncomm_prod, hl]\n#align noncomm_prod_to_finset noncomm_prod_to_finset\n\n",
 "noncomm_prod_singleton":
 "@[simp, to_additive]\ntheorem noncomm_prod_singleton (a : α) (f : α → β) :\n    noncomm_prod ({a} : Finset α) f\n        (by\n          norm_cast\n          exact Set.pairwise_singleton _ _) =\n      f a :=\n  by simp [noncomm_prod, ← Multiset.cons_zero]\n#align noncomm_prod_singleton noncomm_prod_singleton\n\n",
 "noncomm_prod_mul_single":
 "@[to_additive]\ntheorem noncomm_prod_mul_single [fintype ι] [decidable_eq ι] (x : ∀ i, M i) :\n    (univ.noncomm_prod (fun i => Pi.mulSingle i (x i)) fun i _ j _ _ => Pi.mulSingle_apply_commute x i j) = x :=\n  by\n  ext i\n  apply (univ.noncomm_prod_map (fun i => MonoidHom.single M i (x i)) _ (Pi.evalMonoidHom M i)).trans\n  rw [← insert_erase (mem_univ i), noncomm_prod_insert_of_not_mem' _ _ _ _ (not_mem_erase _ _),\n    noncomm_prod_eq_pow_card, one_pow]\n  · simp\n  · intro i h\n    simp at h\n    simp [h]\n#align noncomm_prod_mul_single noncomm_prod_mul_single\n\n",
 "noncomm_prod_mul_distrib_aux":
 "@[protected, to_additive]\ntheorem noncomm_prod_mul_distrib_aux {s : Finset α} {f : α → β} {g : α → β}\n    (comm_ff : (s : set α).pairwise fun x y => Commute (f x) (f y))\n    (comm_gg : (s : set α).pairwise fun x y => Commute (g x) (g y))\n    (comm_gf : (s : set α).pairwise fun x y => Commute (g x) (f y)) :\n    (s : set α).pairwise fun x y => Commute ((f * g) x) ((f * g) y) :=\n  by\n  intro x hx y hy h\n  apply Commute.mul_left <;> apply Commute.mul_right\n  · exact comm_ff.of_refl hx hy\n  · exact (comm_gf hy hx h.symm).symm\n  · exact comm_gf hx hy h\n  · exact comm_gg.of_refl hx hy\n#align noncomm_prod_mul_distrib_aux noncomm_prod_mul_distrib_aux\n\n",
 "noncomm_prod_mul_distrib":
 "/-- The non-commutative version of `finset.prod_mul_distrib` -/\n@[to_additive \"The non-commutative version of `finset.sum_add_distrib`\"]\ntheorem noncomm_prod_mul_distrib {s : Finset α} (f : α → β) (g : α → β) (comm_ff comm_gg comm_gf) :\n    noncomm_prod s (f * g) (noncomm_prod_mul_distrib_aux comm_ff comm_gg comm_gf) =\n      noncomm_prod s f comm_ff * noncomm_prod s g comm_gg :=\n  by\n  classical\n    induction' s using Finset.induction_on with x s hnmem ih\n    · simp\n    simp only [finset.noncomm_prod_insert_of_not_mem _ _ _ _ hnmem]\n    specialize\n      ih (comm_ff.mono fun _ => mem_insert_of_mem) (comm_gg.mono fun _ => mem_insert_of_mem)\n        (comm_gf.mono fun _ => mem_insert_of_mem)\n    rw [ih, pi.mul_apply]\n    simp only [mul_assoc]\n    congr 1\n    simp only [← mul_assoc]\n    congr 1\n    refine' noncomm_prod_commute _ _ _ _ fun y hy => _\n    exact comm_gf (mem_insert_self x s) (mem_insert_of_mem hy) (ne_of_mem_of_not_mem hy hnmem).symm\n#align noncomm_prod_mul_distrib noncomm_prod_mul_distrib\n\n",
 "noncomm_prod_map_aux":
 "@[protected, to_additive]\ntheorem noncomm_prod_map_aux [MonoidHomClass F α β] (s : Multiset α) (comm : { x | x ∈ s }.pairwise Commute) (f : F) :\n    { x | x ∈ s.map f }.pairwise Commute := by\n  simp only [Multiset.mem_map]\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ _\n  exact (comm.of_refl hx hy).map f\n#align noncomm_prod_map_aux noncomm_prod_map_aux\n\n",
 "noncomm_prod_map":
 "@[to_additive]\ntheorem noncomm_prod_map [MonoidHomClass F β γ] (s : Finset α) (f : α → β) (comm) (g : F) :\n    g (s.noncomm_prod f comm) = s.noncomm_prod (fun i => g (f i)) fun x hx y hy h => (comm.of_refl hx hy).map g := by\n  simp [noncomm_prod, multiset.noncomm_prod_map]\n#align noncomm_prod_map noncomm_prod_map\n\n",
 "noncomm_prod_insert_of_not_mem'":
 "@[to_additive]\ntheorem noncomm_prod_insert_of_not_mem' [decidable_eq α] (s : Finset α) (a : α) (f : α → β) (comm) (ha : a ∉ s) :\n    noncomm_prod (insert a s) f comm = noncomm_prod s f (comm.mono fun _ => mem_insert_of_mem) * f a := by\n  simp [noncomm_prod, insert_val_of_not_mem ha, multiset.noncomm_prod_cons']\n#align noncomm_prod_insert_of_not_mem' noncomm_prod_insert_of_not_mem'\n\n",
 "noncomm_prod_insert_of_not_mem":
 "@[simp, to_additive]\ntheorem noncomm_prod_insert_of_not_mem [decidable_eq α] (s : Finset α) (a : α) (f : α → β) (comm) (ha : a ∉ s) :\n    noncomm_prod (insert a s) f comm = f a * noncomm_prod s f (comm.mono fun _ => mem_insert_of_mem) := by\n  simp [insert_val_of_not_mem ha, noncomm_prod]\n#align noncomm_prod_insert_of_not_mem noncomm_prod_insert_of_not_mem\n\n",
 "noncomm_prod_eq_prod":
 "@[to_additive]\ntheorem noncomm_prod_eq_prod {β : Type _} [comm_monoid β] (s : Finset α) (f : α → β) :\n    (noncomm_prod s f fun _ _ _ _ _ => Commute.all _ _) = s.prod f := by\n  classical\n    induction' s using Finset.induction_on with a s ha IH\n    · simp\n    · simp [ha, IH]\n#align noncomm_prod_eq_prod noncomm_prod_eq_prod\n\n",
 "noncomm_prod_eq_pow_card":
 "@[to_additive noncomm_sum_eq_card_nsmul]\ntheorem noncomm_prod_eq_pow_card (s : Finset α) (f : α → β) (comm) (m : β) (h : ∀ x ∈ s, f x = m) :\n    s.noncomm_prod f comm = m ^ s.card :=\n  by\n  rw [noncomm_prod, multiset.noncomm_prod_eq_pow_card _ _ m]\n  simp only [finset.card_def, Multiset.card_map]\n  simpa using h\n#align noncomm_prod_eq_pow_card noncomm_prod_eq_pow_card\n\n",
 "noncomm_prod_empty":
 "@[simp, to_additive]\ntheorem noncomm_prod_empty (f : α → β) (h) : noncomm_prod (∅ : Finset α) f h = 1 :=\n  rfl\n#align noncomm_prod_empty noncomm_prod_empty\n\n",
 "noncomm_prod_cons'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[to_additive]\ntheorem noncomm_prod_cons' (s : Multiset α) (a : α) (comm) :\n    noncomm_prod («expr ::ₘ » a s) comm = noncomm_prod s (comm.mono fun _ => mem_cons_of_mem) * a :=\n  by\n  induction' s using Quotient.inductionOn with s\n  simp only [quot_mk_to_coe, cons_coe, noncomm_prod_coe, List.prod_cons]\n  induction' s with hd tl IH\n  · simp\n  · rw [List.prod_cons, mul_assoc, ← IH, ← mul_assoc, ← mul_assoc]\n    · congr 1\n      apply comm.of_refl <;> simp\n    · intro x hx y hy\n      simp only [quot_mk_to_coe, List.mem_cons, mem_coe, cons_coe] at hx hy\n      apply comm\n      · cases hx <;> simp [hx]\n      · cases hy <;> simp [hy]\n#align noncomm_prod_cons' noncomm_prod_cons'\n\n",
 "noncomm_prod_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp, to_additive]\ntheorem noncomm_prod_cons (s : Multiset α) (a : α) (comm) :\n    noncomm_prod («expr ::ₘ » a s) comm = a * noncomm_prod s (comm.mono fun _ => mem_cons_of_mem) :=\n  by\n  induction s using Quotient.inductionOn\n  simp\n#align noncomm_prod_cons noncomm_prod_cons\n\n",
 "noncomm_prod_congr":
 "@[congr, to_additive]\ntheorem noncomm_prod_congr {s₁ s₂ : Finset α} {f g : α → β} (h₁ : s₁ = s₂) (h₂ : ∀ x ∈ s₂, f x = g x) (comm) :\n    noncomm_prod s₁ f comm =\n      noncomm_prod s₂ g fun x hx y hy h => by\n        rw [← h₂ _ hx, ← h₂ _ hy]\n        subst h₁\n        exact comm hx hy h :=\n  by simp_rw [noncomm_prod, Multiset.map_congr (congr_arg _ h₁) h₂]\n#align noncomm_prod_congr noncomm_prod_congr\n\n",
 "noncomm_prod_commute":
 "@[to_additive noncomm_sum_add_commute]\ntheorem noncomm_prod_commute (s : Finset α) (f : α → β) (comm) (y : β) (h : ∀ x ∈ s, Commute y (f x)) :\n    Commute y (s.noncomm_prod f comm) := by\n  apply multiset.noncomm_prod_commute\n  intro y\n  rw [Multiset.mem_map]\n  rintro ⟨x, ⟨hx, rfl⟩⟩\n  exact h x hx\n#align noncomm_prod_commute noncomm_prod_commute\n\n",
 "noncomm_prod_coe":
 "@[simp, to_additive]\ntheorem noncomm_prod_coe (l : list α) (comm) : noncomm_prod (l : Multiset α) comm = l.prod :=\n  by\n  rw [noncomm_prod]\n  simp only [noncomm_fold_coe]\n  induction' l with hd tl hl\n  · simp\n  · rw [List.prod_cons, list.foldr, hl]\n    intro x hx y hy\n    exact comm (list.mem_cons_of_mem _ hx) (list.mem_cons_of_mem _ hy)\n#align noncomm_prod_coe noncomm_prod_coe\n\n",
 "noncomm_prod_add":
 "@[to_additive]\ntheorem noncomm_prod_add (s t : Multiset α) (comm) :\n    noncomm_prod (s + t) comm =\n      noncomm_prod s (comm.mono <| subset_of_le <| s.le_add_right t) *\n        noncomm_prod t (comm.mono <| subset_of_le <| t.le_add_left s) :=\n  by\n  rcases s with ⟨⟩\n  rcases t with ⟨⟩\n  simp\n#align noncomm_prod_add noncomm_prod_add\n\n",
 "noncomm_foldr_eq_foldr":
 "theorem noncomm_foldr_eq_foldr (s : Multiset α) (h : left_commutative f) (b : β) :\n    noncomm_foldr f s (fun x _ y _ _ => h x y) b = foldr f h b s :=\n  by\n  induction s using Quotient.inductionOn\n  simp\n#align noncomm_foldr_eq_foldr noncomm_foldr_eq_foldr\n\n",
 "noncomm_foldr_empty":
 "@[simp]\ntheorem noncomm_foldr_empty (h) (b : β) : noncomm_foldr f (0 : Multiset α) h b = b :=\n  rfl\n#align noncomm_foldr_empty noncomm_foldr_empty\n\n",
 "noncomm_foldr_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem noncomm_foldr_cons (s : Multiset α) (a : α) (h h') (b : β) :\n    noncomm_foldr f («expr ::ₘ » a s) h b = f a (noncomm_foldr f s h' b) :=\n  by\n  induction s using Quotient.inductionOn\n  simp\n#align noncomm_foldr_cons noncomm_foldr_cons\n\n",
 "noncomm_foldr_coe":
 "/-\nCopyright (c) 2021 Yakov Pechersky. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yakov Pechersky\n-/\n@[simp]\ntheorem noncomm_foldr_coe (l : list α) (comm) (b : β) : noncomm_foldr f (l : Multiset α) comm b = l.foldr f b :=\n  by\n  simp only [noncomm_foldr, coe_foldr, coe_attach, List.attach]\n  rw [← List.foldr_map]\n  simp [List.map_pmap, List.pmap_eq_map]\n#align noncomm_foldr_coe noncomm_foldr_coe\n\n",
 "noncomm_fold_eq_fold":
 "theorem noncomm_fold_eq_fold (s : Multiset α) [is_commutative α op] (a : α) :\n    noncomm_fold op s (fun x _ y _ _ => is_commutative.comm x y) a = fold op a s :=\n  by\n  induction s using Quotient.inductionOn\n  simp\n#align noncomm_fold_eq_fold noncomm_fold_eq_fold\n\n",
 "noncomm_fold_empty":
 "@[simp]\ntheorem noncomm_fold_empty (h) (a : α) : noncomm_fold op (0 : Multiset α) h a = a :=\n  rfl\n#align noncomm_fold_empty noncomm_fold_empty\n\n",
 "noncomm_fold_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem noncomm_fold_cons (s : Multiset α) (a : α) (h h') (x : α) :\n    noncomm_fold op («expr ::ₘ » a s) h x = op a (noncomm_fold op s h' x) :=\n  by\n  induction s using Quotient.inductionOn\n  simp\n#align noncomm_fold_cons noncomm_fold_cons\n\n",
 "noncomm_fold_coe":
 "@[simp]\ntheorem noncomm_fold_coe (l : list α) (comm) (a : α) : noncomm_fold op (l : Multiset α) comm a = l.foldr op a := by\n  simp [noncomm_fold]\n#align noncomm_fold_coe noncomm_fold_coe\n\n"}