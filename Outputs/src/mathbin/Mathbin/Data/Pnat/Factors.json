{"to_of_pnat_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem to_of_pnat_multiset (v : Multiset («exprℕ+»)) (h) : (ofPNatMultiset v h : Multiset («exprℕ+»)) = v :=\n  by\n  unfold_coes; dsimp [of_pnat_multiset, to_pnat_multiset]\n  have : (fun (p : «exprℕ+») (h : p.prime) => (coe : Nat.Primes → «exprℕ+») ⟨p, h⟩) = fun p h => id p :=\n    by\n    funext p h\n    apply Subtype.eq\n    rfl\n  rw [Multiset.map_pmap, this, Multiset.pmap_eq_map, Multiset.map_id]\n#align to_of_pnat_multiset to_of_pnat_multiset\n\n",
 "to_of_nat_multiset":
 "theorem to_of_nat_multiset (v : Multiset ℕ) (h) : (ofNatMultiset v h : Multiset ℕ) = v :=\n  by\n  unfold_coes\n  dsimp [of_nat_multiset, to_nat_multiset]\n  have : (fun (p : ℕ) (h : p.prime) => ((⟨p, h⟩ : Nat.Primes) : ℕ)) = fun p h => id p :=\n    by\n    funext p h\n    rfl\n  rw [Multiset.map_pmap, this, Multiset.pmap_eq_map, Multiset.map_id]\n#align to_of_nat_multiset to_of_nat_multiset\n\n",
 "prod_zero":
 "/-- The product map gives a homomorphism from the additive monoid\nof multisets to the multiplicative monoid ℕ+. -/\ntheorem prod_zero : (0 : PrimeMultiset).prod = 1 := by\n  dsimp [Prod]\n  exact Multiset.prod_zero\n#align prod_zero prod_zero\n\n",
 "prod_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem prod_sup (u v : PrimeMultiset) : («expr ⊔ » u v).prod = PNat.lcm u.prod v.prod :=\n  by\n  let n := u.prod\n  let m := v.prod\n  change («expr ⊔ » u v).prod = PNat.lcm n m\n  have : u = n.factor_multiset := u.factor_multiset_prod.symm; rw [this]\n  have : v = m.factor_multiset := v.factor_multiset_prod.symm; rw [this]\n  rw [← PNat.factorMultiset_lcm n m, PNat.prod_factorMultiset]\n#align prod_sup prod_sup\n\n",
 "prod_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem prod_smul (d : ℕ) (u : PrimeMultiset) : («expr • » d u).prod = u.prod ^ d :=\n  by\n  induction' d with d ih\n  rfl\n  rw [succ_nsmul, prod_add, ih, nat.succ_eq_add_one, pow_succ, mul_comm]\n#align prod_smul prod_smul\n\n",
 "prod_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem prod_of_prime (p : Nat.Primes) : (ofPrime p).prod = (p : «exprℕ+») :=\n  Multiset.prod_singleton _\n#align prod_of_prime prod_of_prime\n\n",
 "prod_of_pnat_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem prod_of_pnat_multiset (v : Multiset («exprℕ+»)) (h) : ((ofPNatMultiset v h).prod : «exprℕ+») = v.prod :=\n  by\n  dsimp [Prod]\n  rw [to_of_pnat_multiset]\n#align prod_of_pnat_multiset prod_of_pnat_multiset\n\n",
 "prod_of_pnat_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem prod_of_pnat_list (l : List («exprℕ+»)) (h) : (ofPNatList l h).prod = l.prod :=\n  by\n  have := prod_of_pnat_multiset (l : Multiset («exprℕ+»)) h\n  rw [Multiset.coe_prod] at this\n  exact this\n#align prod_of_pnat_list prod_of_pnat_list\n\n",
 "prod_of_nat_multiset":
 "theorem prod_of_nat_multiset (v : Multiset ℕ) (h) : ((ofNatMultiset v h).prod : ℕ) = (v.prod : ℕ) := by\n  rw [coe_prod, to_of_nat_multiset]\n#align prod_of_nat_multiset prod_of_nat_multiset\n\n",
 "prod_of_nat_list":
 "theorem prod_of_nat_list (l : List ℕ) (h) : ((ofNatList l h).prod : ℕ) = l.prod :=\n  by\n  have := prod_of_nat_multiset (l : Multiset ℕ) h\n  rw [Multiset.coe_prod] at this\n  exact this\n#align prod_of_nat_list prod_of_nat_list\n\n",
 "prod_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem prod_inf (u v : PrimeMultiset) : («expr ⊓ » u v).prod = PNat.gcd u.prod v.prod :=\n  by\n  let n := u.prod\n  let m := v.prod\n  change («expr ⊓ » u v).prod = PNat.gcd n m\n  have : u = n.factor_multiset := u.factor_multiset_prod.symm; rw [this]\n  have : v = m.factor_multiset := v.factor_multiset_prod.symm; rw [this]\n  rw [← PNat.factorMultiset_gcd n m, PNat.prod_factorMultiset]\n#align prod_inf prod_inf\n\n",
 "prod_factor_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- The product of the factors is the original number -/\ntheorem prod_factor_multiset (n : «exprℕ+») : (factorMultiset n).prod = n :=\n  eq <| by\n    dsimp [factor_multiset]\n    rw [PrimeMultiset.prod_ofNatList]\n    exact Nat.prod_factors n.ne_zero\n#align prod_factor_multiset prod_factor_multiset\n\n",
 "prod_dvd_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem prod_dvd_iff' {u : PrimeMultiset} {n : «exprℕ+»} : u.prod ∣ n ↔ u ≤ n.factor_multiset :=\n  by\n  let h := @prod_dvd_iff u n.factor_multiset\n  rw [n.prod_factor_multiset] at h\n  exact h\n#align prod_dvd_iff' prod_dvd_iff'\n\n",
 "prod_dvd_iff":
 "theorem prod_dvd_iff {u v : PrimeMultiset} : u.prod ∣ v.prod ↔ u ≤ v :=\n  by\n  let h := @PNat.factorMultiset_le_iff' u.prod v\n  rw [u.factor_multiset_prod] at h\n  exact h.symm\n#align prod_dvd_iff prod_dvd_iff\n\n",
 "prod_add":
 "theorem prod_add (u v : PrimeMultiset) : (u + v).prod = u.prod * v.prod :=\n  by\n  change (coe_pnat_monoid_hom (u + v)).prod = _\n  rw [coe_pnat_monoid_hom.map_add]\n  exact Multiset.prod_add _ _\n#align prod_add prod_add\n\n",
 "factor_multiset_prod":
 "/-- If we start with a multiset of primes, take the product and\n then factor it, we get back the original multiset. -/\ntheorem factor_multiset_prod (v : PrimeMultiset) : v.prod.factor_multiset = v :=\n  by\n  apply PrimeMultiset.coeNat_injective\n  rw [v.prod.coe_nat_factor_multiset, PrimeMultiset.coe_prod]\n  rcases v with ⟨l⟩\n  unfold_coes\n  dsimp [PrimeMultiset.toNatMultiset]\n  rw [Multiset.coe_prod]\n  let l' := l.map (coe : Nat.Primes → ℕ)\n  have : ∀ p : ℕ, p ∈ l' → p.prime := fun p hp =>\n    by\n    rcases list.mem_map.mp hp with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩\n    exact h_eq ▸ hp'\n  exact multiset.coe_eq_coe.mpr (@Nat.factors_unique _ l' rfl this).symm\n#align factor_multiset_prod factor_multiset_prod\n\n",
 "factor_multiset_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem factor_multiset_pow (n : «exprℕ+») (m : ℕ) : factorMultiset (n ^ m) = «expr • » m (factorMultiset n) :=\n  by\n  let u := factor_multiset n\n  have : n = u.prod := (prod_factor_multiset n).symm\n  rw [this, ← PrimeMultiset.prod_smul]\n  repeat' rw [PrimeMultiset.factorMultiset_prod]\n#align factor_multiset_pow factor_multiset_pow\n\n",
 "factor_multiset_one":
 "/-- Factoring gives a homomorphism from the multiplicative\n monoid ℕ+ to the additive monoid of multisets. -/\ntheorem factor_multiset_one : factorMultiset 1 = 0 := by\n  simp [factor_multiset, PrimeMultiset.ofNatList, PrimeMultiset.ofNatMultiset]\n#align factor_multiset_one factor_multiset_one\n\n",
 "factor_multiset_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem factor_multiset_of_prime (p : Nat.Primes) : (p : «exprℕ+»).factor_multiset = PrimeMultiset.ofPrime p :=\n  by\n  apply factor_multiset_equiv.symm.injective\n  change (p : «exprℕ+»).factor_multiset.prod = (PrimeMultiset.ofPrime p).prod\n  rw [(p : «exprℕ+»).prod_factor_multiset, PrimeMultiset.prod_ofPrime]\n#align factor_multiset_of_prime factor_multiset_of_prime\n\n",
 "factor_multiset_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem factor_multiset_mul (n m : «exprℕ+») : factorMultiset (n * m) = factorMultiset n + factorMultiset m :=\n  by\n  let u := factor_multiset n\n  let v := factor_multiset m\n  have : n = u.prod := (prod_factor_multiset n).symm; rw [this]\n  have : m = v.prod := (prod_factor_multiset m).symm; rw [this]\n  rw [← PrimeMultiset.prod_add]\n  repeat' rw [PrimeMultiset.factorMultiset_prod]\n#align factor_multiset_mul factor_multiset_mul\n\n",
 "factor_multiset_le_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem factor_multiset_le_iff' {m : «exprℕ+»} {v : PrimeMultiset} : factorMultiset m ≤ v ↔ m ∣ v.prod :=\n  by\n  let h := @factor_multiset_le_iff m v.prod\n  rw [v.factor_multiset_prod] at h\n  exact h\n#align factor_multiset_le_iff' factor_multiset_le_iff'\n\n",
 "factor_multiset_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- We now have four different results that all encode the\n idea that inequality of multisets corresponds to divisibility\n of positive integers. -/\ntheorem factor_multiset_le_iff {m n : «exprℕ+»} : factorMultiset m ≤ factorMultiset n ↔ m ∣ n :=\n  by\n  constructor\n  · intro h\n    rw [← prod_factor_multiset m, ← prod_factor_multiset m]\n    apply Dvd.intro (n.factor_multiset - m.factor_multiset).prod\n    rw [← PrimeMultiset.prod_add, PrimeMultiset.factorMultiset_prod, add_tsub_cancel_of_le h, prod_factor_multiset]\n  · intro h\n    rw [← mul_div_exact h, factor_multiset_mul]\n    exact le_self_add\n#align factor_multiset_le_iff factor_multiset_le_iff\n\n",
 "factor_multiset_lcm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem factor_multiset_lcm (m n : «exprℕ+») :\n    factorMultiset (lcm m n) = «expr ⊔ » (factorMultiset m) (factorMultiset n) :=\n  by\n  apply le_antisymm\n  · rw [← PrimeMultiset.prod_dvd_iff, prod_factor_multiset]\n    apply lcm_dvd <;> rw [← factor_multiset_le_iff']\n    exact le_sup_left\n    exact le_sup_right\n  · apply sup_le_iff.mpr <;> constructor <;> apply factor_multiset_le_iff.mpr\n    exact dvd_lcm_left m n\n    exact dvd_lcm_right m n\n#align factor_multiset_lcm factor_multiset_lcm\n\n",
 "factor_multiset_gcd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- The gcd and lcm operations on positive integers correspond\n to the inf and sup operations on multisets. -/\ntheorem factor_multiset_gcd (m n : «exprℕ+») :\n    factorMultiset (gcd m n) = «expr ⊓ » (factorMultiset m) (factorMultiset n) :=\n  by\n  apply le_antisymm\n  · apply le_inf_iff.mpr <;> constructor <;> apply factor_multiset_le_iff.mpr\n    exact gcd_dvd_left m n\n    exact gcd_dvd_right m n\n  · rw [← PrimeMultiset.prod_dvd_iff, prod_factor_multiset]\n    apply dvd_gcd <;> rw [PrimeMultiset.prod_dvd_iff']\n    exact inf_le_left\n    exact inf_le_right\n#align factor_multiset_gcd factor_multiset_gcd\n\n",
 "count_factor_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/-- The number of occurrences of p in the factor multiset of m\n is the same as the p-adic valuation of m. -/\ntheorem count_factor_multiset (m : «exprℕ+») (p : Nat.Primes) (k : ℕ) :\n    (p : «exprℕ+») ^ k ∣ m ↔ k ≤ m.factor_multiset.count p :=\n  by\n  intros\n  rw [Multiset.le_count_iff_replicate_le]\n  rw [← factor_multiset_le_iff, factor_multiset_pow, factor_multiset_of_prime]\n  congr 2\n  apply multiset.eq_replicate.mpr\n  constructor\n  · rw [Multiset.card_nsmul, PrimeMultiset.card_ofPrime, mul_one]\n  · intro q h\n    rw [PrimeMultiset.ofPrime, Multiset.nsmul_singleton _ k] at h\n    exact Multiset.eq_of_mem_replicate h\n#align count_factor_multiset count_factor_multiset\n\n",
 "coe_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem coe_prod (v : PrimeMultiset) : (v.prod : ℕ) = (v : Multiset ℕ).prod :=\n  by\n  let h : (v.prod : ℕ) = ((v.map coe).map coe).prod := pnat.coe_monoid_hom.map_multiset_prod v.to_pnat_multiset\n  rw [Multiset.map_map] at h\n  have : (coe : «exprℕ+» → ℕ) ∘ (coe : Nat.Primes → «exprℕ+») = coe := funext fun p => rfl\n  rw [this] at h; exact h\n#align coe_prod coe_prod\n\n",
 "coe_pnat_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem coe_pnat_prime (v : PrimeMultiset) (p : «exprℕ+») (h : p ∈ (v : Multiset («exprℕ+»))) : p.prime :=\n  by\n  rcases multiset.mem_map.mp h with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩\n  exact h_eq ▸ hp'\n#align coe_pnat_prime coe_pnat_prime\n\n",
 "coe_pnat_of_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem coe_pnat_of_prime (p : Nat.Primes) : (ofPrime p : Multiset («exprℕ+»)) = {(p : «exprℕ+»)} :=\n  rfl\n#align coe_pnat_of_prime coe_pnat_of_prime\n\n",
 "coe_pnat_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem coe_pnat_injective : function.injective (coe : PrimeMultiset → Multiset («exprℕ+»)) :=\n  Multiset.map_injective Nat.Primes.coe_pnat_injective\n#align coe_pnat_injective coe_pnat_injective\n\n",
 "coe_nat_prime":
 "theorem coe_nat_prime (v : PrimeMultiset) (p : ℕ) (h : p ∈ (v : Multiset ℕ)) : p.prime :=\n  by\n  rcases multiset.mem_map.mp h with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩\n  exact h_eq ▸ hp'\n#align coe_nat_prime coe_nat_prime\n\n",
 "coe_nat_of_prime":
 "theorem coe_nat_of_prime (p : Nat.Primes) : (ofPrime p : Multiset ℕ) = {p} :=\n  rfl\n#align coe_nat_of_prime coe_nat_of_prime\n\n",
 "coe_nat_injective":
 "theorem coe_nat_injective : function.injective (coe : PrimeMultiset → Multiset ℕ) :=\n  Multiset.map_injective Nat.Primes.coe_nat_injective\n#align coe_nat_injective coe_nat_injective\n\n",
 "coe_nat_factor_multiset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem coe_nat_factor_multiset (n : «exprℕ+») : (factorMultiset n : Multiset ℕ) = (Nat.factors n : Multiset ℕ) :=\n  PrimeMultiset.to_ofNatMultiset (Nat.factors n) (@Nat.prime_of_mem_factors n)\n#align coe_nat_factor_multiset coe_nat_factor_multiset\n\n",
 "coe_coe_pnat_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n@[simp]\ntheorem coe_coe_pnat_monoid_hom : (coePNatMonoidHom : PrimeMultiset → Multiset («exprℕ+»)) = coe :=\n  rfl\n#align coe_coe_pnat_monoid_hom coe_coe_pnat_monoid_hom\n\n",
 "coe_coe_nat_monoid_hom":
 "@[simp]\ntheorem coe_coe_nat_monoid_hom : (coeNatMonoidHom : PrimeMultiset → Multiset ℕ) = coe :=\n  rfl\n#align coe_coe_nat_monoid_hom coe_coe_nat_monoid_hom\n\n",
 "coePNatNat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n#print coePNatNat /-\ntheorem coePNatNat (v : PrimeMultiset) : ((v : Multiset («exprℕ+»)) : Multiset ℕ) = (v : Multiset ℕ) :=\n  by\n  change (v.map (coe : Nat.Primes → «exprℕ+»)).map Subtype.val = v.map Subtype.val\n  rw [Multiset.map_map]\n  congr\n#align coe_pnat_nat coePNatNat\n-/\n\n",
 "card_of_prime":
 "/-\nCopyright (c) 2019 Neil Strickland. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Neil Strickland\n-/\n-- `@[derive]` doesn't work for `meta` instances\ntheorem card_of_prime (p : Nat.Primes) : Multiset.card (ofPrime p) = 1 :=\n  rfl\n#align card_of_prime card_of_prime\n\n"}