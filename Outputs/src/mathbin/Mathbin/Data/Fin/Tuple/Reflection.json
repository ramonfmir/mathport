{"sum_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- This can be used to prove\n```lean\nexample [add_comm_monoid α] (a : fin 3 → α) : ∑ i, a i = a 0 + a 1 + a 2 :=\n(sum_eq _).symm\n```\n-/\n@[simp]\ntheorem sum_eq [AddCommMonoid α] :\n    ∀ {m} (a : Fin m → α),\n      sum a =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (a i)\n  | 0, a => rfl\n  | 1, a => (Fintype.sum_unique a).symm\n  | n + 2, a => by rw [Fin.sum_univ_castSucc, Sum, sum_eq]\n#align sum_eq sum_eq\n\n",
 "seq_eq":
 "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp]\ntheorem seq_eq : ∀ {m} (f : Fin m → α → β) (v : Fin m → α), seq f v = fun i => f i (v i)\n  | 0, f, v => subsingleton.elim _ _\n  | n + 1, f, v =>\n    funext fun i => by\n      simp_rw [seq, seq_eq]\n      refine' i.cases _ fun i => _\n      · rfl\n      · simp only [Matrix.cons_val_succ]\n        rfl\n#align seq_eq seq_eq\n\n",
 "map_eq":
 "/-- This can be use to prove\n```lean\nexample {f : α → β} (a₁ a₂ : α) : f ∘ ![a₁, a₂] = ![f a₁, f a₂] :=\n(map_eq _ _).symm\n```\n-/\n@[simp]\ntheorem map_eq (f : α → β) {m} (v : Fin m → α) : map f v = f ∘ v :=\n  seq_eq _ _\n#align map_eq map_eq\n\n",
 "forall_iff":
 "/-- This can be use to prove\n```lean\nexample (P : (fin 2 → α) → Prop) : (∀ f, P f) ↔ (∀ a₀ a₁, P ![a₀, a₁]) := (forall_iff _).symm\n```\n-/\n@[simp]\ntheorem forall_iff : ∀ {m} (P : (Fin m → α) → Prop), Forall P ↔ ∀ x, P x\n  | 0, P => by\n    simp only [forall, Fin.forall_fin_zero_pi]\n    rfl\n  | n + 1, P => by simp only [forall, forall_iff, Fin.forall_fin_succ_pi, Matrix.vecCons]\n#align forall_iff forall_iff\n\n",
 "exists_iff":
 "/-- This can be use to prove\n```lean\nexample (P : (fin 2 → α) → Prop) : (∃ f, P f) ↔ (∃ a₀ a₁, P ![a₀, a₁]) := (exists_iff _).symm\n```\n-/\ntheorem exists_iff : ∀ {m} (P : (Fin m → α) → Prop), Exists P ↔ ∃ x, P x\n  | 0, P => by\n    simp only [exists, Fin.exists_fin_zero_pi, Matrix.vecEmpty]\n    rfl\n  | n + 1, P => by simp only [exists, exists_iff, Fin.exists_fin_succ_pi, Matrix.vecCons]\n#align exists_iff exists_iff\n\n",
 "eta_expand_eq":
 "/-- This can be use to prove\n```lean\nexample {f : α → β} (a : fin 2 → α) : a = ![a 0, a 1] := (eta_expand_eq _).symm\n```\n-/\n@[simp]\ntheorem eta_expand_eq {m} (v : Fin m → α) : etaExpand v = v :=\n  map_eq id v\n#align eta_expand_eq eta_expand_eq\n\n"}