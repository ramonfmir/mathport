{"to_enum_finset_subset_iff":
 "@[simp]\ntheorem multiset.to_enum_finset_subset_iff {m₁ m₂ : Multiset α} : m₁.to_enum_finset ⊆ m₂.to_enum_finset ↔ m₁ ≤ m₂ :=\n  by\n  refine' ⟨fun h => _, multiset.to_enum_finset_mono⟩\n  rw [Multiset.le_iff_count]\n  intro x\n  by_cases hx : x ∈ m₁\n  · apply Nat.le_of_pred_lt\n    have : (x, m₁.count x - 1) ∈ m₁.to_enum_finset :=\n      by\n      rw [multiset.mem_to_enum_finset]\n      exact nat.pred_lt (ne_of_gt (multiset.count_pos.mpr hx))\n    simpa only [multiset.mem_to_enum_finset] using h this\n  · simp [hx]\n#align multiset.to_enum_finset_subset_iff multiset.to_enum_finset_subset_iff\n\n",
 "to_enum_finset_mono":
 "@[mono]\ntheorem multiset.to_enum_finset_mono {m₁ m₂ : Multiset α} (h : m₁ ≤ m₂) : m₁.to_enum_finset ⊆ m₂.to_enum_finset :=\n  by\n  intro p\n  simp only [multiset.mem_to_enum_finset]\n  exact gt_of_ge_of_gt (multiset.le_iff_count.mp h p.1)\n#align multiset.to_enum_finset_mono multiset.to_enum_finset_mono\n\n",
 "to_enum_finset_filter_eq":
 "theorem multiset.to_enum_finset_filter_eq (m : Multiset α) (x : α) :\n    (m.to_enum_finset.filter fun p => x = p.1) = (Finset.range (m.count x)).map ⟨prod.mk x, prod.mk.inj_left x⟩ :=\n  by\n  ext ⟨y, i⟩\n  simp only [eq_comm, Finset.mem_filter, multiset.mem_to_enum_finset, Finset.mem_map, Finset.mem_range,\n    Function.Embedding.coeFn_mk, prod.mk.inj_iff, exists_prop, exists_eq_right_right', and_congr_left_iff]\n  rintro rfl\n  rfl\n#align multiset.to_enum_finset_filter_eq multiset.to_enum_finset_filter_eq\n\n",
 "to_embedding_coe_equiv_trans":
 "@[simp]\ntheorem multiset.to_embedding_coe_equiv_trans (m : Multiset α) :\n    m.coe_equiv.to_embedding.trans (Function.Embedding.subtype _) = m.coe_embedding := by ext <;> simp\n#align multiset.to_embedding_coe_equiv_trans multiset.to_embedding_coe_equiv_trans\n\n",
 "prod_to_enum_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem multiset.prod_to_enum_finset {β : Type _} [comm_monoid β] (m : Multiset α) (f : α → ℕ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m.to_enum_finset\n        (f x.1 x.2) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f x x.2) :=\n  by\n  rw [fintype.prod_equiv m.coe_equiv (fun x => f x x.2) fun x => f x.1.1 x.1.2]\n  · rw [← m.to_enum_finset.prod_coe_sort fun x => f x.1 x.2]\n    simp\n  · simp\n#align multiset.prod_to_enum_finset multiset.prod_to_enum_finset\n\n",
 "prod_eq_prod_to_enum_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem multiset.prod_eq_prod_to_enum_finset [comm_monoid α] (m : Multiset α) :\n    m.prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m.to_enum_finset\n        x.1 :=\n  by\n  congr\n  simp\n#align multiset.prod_eq_prod_to_enum_finset multiset.prod_eq_prod_to_enum_finset\n\n",
 "prod_eq_prod_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[to_additive]\ntheorem multiset.prod_eq_prod_coe [comm_monoid α] (m : Multiset α) :\n    m.prod =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" x :=\n  by\n  congr\n  simp\n#align multiset.prod_eq_prod_coe multiset.prod_eq_prod_coe\n\n",
 "mem_to_enum_finset":
 "@[simp]\ntheorem multiset.mem_to_enum_finset (m : Multiset α) (p : α × ℕ) : p ∈ m.to_enum_finset ↔ p.2 < m.count p.1 :=\n  set.mem_to_finset\n#align multiset.mem_to_enum_finset multiset.mem_to_enum_finset\n\n",
 "mem_of_mem_to_enum_finset":
 "theorem multiset.mem_of_mem_to_enum_finset {p : α × ℕ} (h : p ∈ m.to_enum_finset) : p.1 ∈ m :=\n  Multiset.count_pos.mp <| pos_of_gt <| (m.mem_to_enum_finset p).mp h\n#align multiset.mem_of_mem_to_enum_finset multiset.mem_of_mem_to_enum_finset\n\n",
 "map_univ_coe_embedding":
 "theorem multiset.map_univ_coe_embedding (m : Multiset α) :\n    (finset.univ : Finset m).map m.coe_embedding = m.to_enum_finset :=\n  by\n  ext ⟨x, i⟩\n  simp only [Fin.exists_iff, Finset.mem_map, finset.mem_univ, multiset.coe_embedding_apply, prod.mk.inj_iff,\n    exists_true_left, multiset.exists_coe, multiset.coe_mk, Fin.val_mk, exists_prop, exists_eq_right_right,\n    exists_eq_right, multiset.mem_to_enum_finset, iff_self_iff, true_and_iff]\n#align multiset.map_univ_coe_embedding multiset.map_univ_coe_embedding\n\n",
 "map_univ_coe":
 "@[simp]\ntheorem multiset.map_univ_coe (m : Multiset α) : (finset.univ : Finset m).val.map coe = m :=\n  by\n  have := m.map_to_enum_finset_fst\n  rw [← m.map_univ_coe_embedding] at this\n  simpa only [Finset.map_val, multiset.coe_embedding_apply, Multiset.map_map, Function.comp_apply] using this\n#align multiset.map_univ_coe multiset.map_univ_coe\n\n",
 "map_univ":
 "@[simp]\ntheorem multiset.map_univ {β : Type _} (m : Multiset α) (f : α → β) :\n    ((finset.univ : Finset m).val.map fun x => f x) = m.map f := by rw [← Multiset.map_map, multiset.map_univ_coe]\n#align multiset.map_univ multiset.map_univ\n\n",
 "map_to_enum_finset_fst":
 "@[simp]\ntheorem multiset.map_to_enum_finset_fst (m : Multiset α) : m.to_enum_finset.val.map prod.fst = m :=\n  by\n  ext x\n  simp only [Multiset.count_map, ← Finset.filter_val, multiset.to_enum_finset_filter_eq, Finset.map_val,\n    Finset.range_val, Multiset.card_map, Multiset.card_range]\n#align multiset.map_to_enum_finset_fst multiset.map_to_enum_finset_fst\n\n",
 "image_to_enum_finset_fst":
 "@[simp]\ntheorem multiset.image_to_enum_finset_fst (m : Multiset α) : m.to_enum_finset.image prod.fst = m.to_finset := by\n  rw [Finset.image, multiset.map_to_enum_finset_fst]\n#align multiset.image_to_enum_finset_fst multiset.image_to_enum_finset_fst\n\n",
 "fst_coe_eq_coe":
 "@[simp]\ntheorem multiset.fst_coe_eq_coe {x : m} : x.1 = x :=\n  rfl\n#align multiset.fst_coe_eq_coe multiset.fst_coe_eq_coe\n\n",
 "forall_coe":
 "@[simp]\nprotected theorem multiset.forall_coe (p : m → Prop) : (∀ x : m, p x) ↔ ∀ (x : α) (i : fin (m.count x)), p ⟨x, i⟩ :=\n  sigma.forall\n#align multiset.forall_coe multiset.forall_coe\n\n",
 "exists_coe":
 "@[simp]\nprotected theorem multiset.exists_coe (p : m → Prop) : (∃ x : m, p x) ↔ ∃ (x : α)(i : fin (m.count x)), p ⟨x, i⟩ :=\n  sigma.exists\n#align multiset.exists_coe multiset.exists_coe\n\n",
 "coe_sort_eq":
 "/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n-/\n@[simp]\ntheorem multiset.coe_sort_eq : m.to_type = m :=\n  rfl\n#align multiset.coe_sort_eq multiset.coe_sort_eq\n\n",
 "coe_mk":
 "@[simp]\ntheorem multiset.coe_mk {x : α} {i : fin (m.count x)} : ↑(m.mk_to_type x i) = x :=\n  rfl\n#align multiset.coe_mk multiset.coe_mk\n\n",
 "coe_mem":
 "@[simp]\ntheorem multiset.coe_mem {x : m} : ↑x ∈ m :=\n  Multiset.count_pos.mp (pos_of_gt x.2.2)\n#align multiset.coe_mem multiset.coe_mem\n\n",
 "coe_eq":
 "@[simp]\ntheorem multiset.coe_eq {x y : m} : (x : α) = (y : α) ↔ x.1 = y.1 :=\n  by\n  cases x\n  cases y\n  rfl\n#align multiset.coe_eq multiset.coe_eq\n\n",
 "card_to_enum_finset":
 "@[simp]\ntheorem multiset.card_to_enum_finset (m : Multiset α) : m.to_enum_finset.card = m.card :=\n  by\n  change Multiset.card _ = _\n  convert_to (m.to_enum_finset.val.map prod.fst).card = _\n  · rw [Multiset.card_map]\n  · rw [m.map_to_enum_finset_fst]\n#align multiset.card_to_enum_finset multiset.card_to_enum_finset\n\n",
 "card_coe":
 "@[simp]\ntheorem multiset.card_coe (m : Multiset α) : fintype.card m = m.card :=\n  by\n  rw [fintype.card_congr m.coe_equiv]\n  simp\n#align multiset.card_coe multiset.card_coe\n\n"}