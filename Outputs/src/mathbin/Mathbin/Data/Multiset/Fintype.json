{"toEnumFinset_subset_iff":
 "#print Multiset.toEnumFinset_subset_iff /-\n@[simp]\ntheorem Multiset.toEnumFinset_subset_iff {m₁ m₂ : Multiset α} : m₁.to_enum_finset ⊆ m₂.to_enum_finset ↔ m₁ ≤ m₂ :=\n  by\n  refine' ⟨fun h => _, Multiset.toEnumFinset_mono⟩\n  rw [Multiset.le_iff_count]\n  intro x\n  by_cases hx : x ∈ m₁\n  · apply Nat.le_of_pred_lt\n    have : (x, m₁.count x - 1) ∈ m₁.to_enum_finset :=\n      by\n      rw [Multiset.mem_toEnumFinset]\n      exact nat.pred_lt (ne_of_gt (multiset.count_pos.mpr hx))\n    simpa only [Multiset.mem_toEnumFinset] using h this\n  · simp [hx]\n#align multiset.to_enum_finset_subset_iff Multiset.toEnumFinset_subset_iff\n-/\n\n",
 "toEnumFinset_mono":
 "#print Multiset.toEnumFinset_mono /-\n@[mono]\ntheorem Multiset.toEnumFinset_mono {m₁ m₂ : Multiset α} (h : m₁ ≤ m₂) : m₁.to_enum_finset ⊆ m₂.to_enum_finset :=\n  by\n  intro p\n  simp only [Multiset.mem_toEnumFinset]\n  exact gt_of_ge_of_gt (multiset.le_iff_count.mp h p.1)\n#align multiset.to_enum_finset_mono Multiset.toEnumFinset_mono\n-/\n\n",
 "toEnumFinset_filter_eq":
 "#print Multiset.toEnumFinset_filter_eq /-\ntheorem Multiset.toEnumFinset_filter_eq (m : Multiset α) (x : α) :\n    (m.to_enum_finset.filter fun p => x = p.1) = (Finset.range (m.count x)).map ⟨prod.mk x, Prod.mk.inj_left x⟩ :=\n  by\n  ext ⟨y, i⟩\n  simp only [eq_comm, Finset.mem_filter, Multiset.mem_toEnumFinset, Finset.mem_map, Finset.mem_range,\n    Function.Embedding.coeFn_mk, Prod.mk.inj_iff, exists_prop, exists_eq_right_right', and_congr_left_iff]\n  rintro rfl\n  rfl\n#align multiset.to_enum_finset_filter_eq Multiset.toEnumFinset_filter_eq\n-/\n\n",
 "toEmbedding_coeEquiv_trans":
 "#print Multiset.toEmbedding_coeEquiv_trans /-\n@[simp]\ntheorem Multiset.toEmbedding_coeEquiv_trans (m : Multiset α) :\n    m.coe_equiv.to_embedding.trans (Function.Embedding.subtype _) = m.coe_embedding := by ext <;> simp\n#align multiset.to_embedding_coe_equiv_trans Multiset.toEmbedding_coeEquiv_trans\n-/\n\n",
 "prod_toEnumFinset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Multiset.prod_toEnumFinset /-\n@[to_additive]\ntheorem Multiset.prod_toEnumFinset {β : Type _} [CommMonoid β] (m : Multiset α) (f : α → ℕ → β) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m.to_enum_finset\n        (f x.1 x.2) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f x x.2) :=\n  by\n  rw [Fintype.prod_equiv m.coe_equiv (fun x => f x x.2) fun x => f x.1.1 x.1.2]\n  · rw [← m.to_enum_finset.prod_coe_sort fun x => f x.1 x.2]\n    simp\n  · simp\n#align multiset.prod_to_enum_finset Multiset.prod_toEnumFinset\n#align multiset.sum_to_enum_finset Multiset.sum_toEnumFinset\n-/\n\n",
 "prod_eq_prod_toEnumFinset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n#print Multiset.prod_eq_prod_toEnumFinset /-\n@[to_additive]\ntheorem Multiset.prod_eq_prod_toEnumFinset [CommMonoid α] (m : Multiset α) :\n    m.prod =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m.to_enum_finset\n        x.1 :=\n  by\n  congr\n  simp\n#align multiset.prod_eq_prod_to_enum_finset Multiset.prod_eq_prod_toEnumFinset\n#align multiset.sum_eq_sum_to_enum_finset Multiset.sum_eq_sum_toEnumFinset\n-/\n\n",
 "prod_eq_prod_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Multiset.prod_eq_prod_coe /-\n@[to_additive]\ntheorem Multiset.prod_eq_prod_coe [CommMonoid α] (m : Multiset α) :\n    m.prod =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" x :=\n  by\n  congr\n  simp\n#align multiset.prod_eq_prod_coe Multiset.prod_eq_prod_coe\n#align multiset.sum_eq_sum_coe Multiset.sum_eq_sum_coe\n-/\n\n",
 "mem_toEnumFinset":
 "#print Multiset.mem_toEnumFinset /-\n@[simp]\ntheorem Multiset.mem_toEnumFinset (m : Multiset α) (p : α × ℕ) : p ∈ m.to_enum_finset ↔ p.2 < m.count p.1 :=\n  Set.mem_toFinset\n#align multiset.mem_to_enum_finset Multiset.mem_toEnumFinset\n-/\n\n",
 "mem_of_mem_toEnumFinset":
 "#print Multiset.mem_of_mem_toEnumFinset /-\ntheorem Multiset.mem_of_mem_toEnumFinset {p : α × ℕ} (h : p ∈ m.to_enum_finset) : p.1 ∈ m :=\n  Multiset.count_pos.mp <| pos_of_gt <| (m.mem_to_enum_finset p).mp h\n#align multiset.mem_of_mem_to_enum_finset Multiset.mem_of_mem_toEnumFinset\n-/\n\n",
 "map_univ_coeEmbedding":
 "#print Multiset.map_univ_coeEmbedding /-\ntheorem Multiset.map_univ_coeEmbedding (m : Multiset α) :\n    (Finset.univ : Finset m).map m.coe_embedding = m.to_enum_finset :=\n  by\n  ext ⟨x, i⟩\n  simp only [Fin.exists_iff, Finset.mem_map, Finset.mem_univ, multiset.coe_embedding_apply, Prod.mk.inj_iff,\n    exists_true_left, Multiset.exists_coe, Multiset.coe_mk, Fin.val_mk, exists_prop, exists_eq_right_right,\n    exists_eq_right, Multiset.mem_toEnumFinset, iff_self_iff, true_and_iff]\n#align multiset.map_univ_coe_embedding Multiset.map_univ_coeEmbedding\n-/\n\n",
 "map_univ_coe":
 "#print Multiset.map_univ_coe /-\n@[simp]\ntheorem Multiset.map_univ_coe (m : Multiset α) : (Finset.univ : Finset m).val.map coe = m :=\n  by\n  have := m.map_to_enum_finset_fst\n  rw [← m.map_univ_coe_embedding] at this\n  simpa only [Finset.map_val, multiset.coe_embedding_apply, Multiset.map_map, Function.comp_apply] using this\n#align multiset.map_univ_coe Multiset.map_univ_coe\n-/\n\n",
 "map_univ":
 "#print Multiset.map_univ /-\n@[simp]\ntheorem Multiset.map_univ {β : Type _} (m : Multiset α) (f : α → β) :\n    ((Finset.univ : Finset m).val.map fun x => f x) = m.map f := by rw [← Multiset.map_map, Multiset.map_univ_coe]\n#align multiset.map_univ Multiset.map_univ\n-/\n\n",
 "map_toEnumFinset_fst":
 "#print Multiset.map_toEnumFinset_fst /-\n@[simp]\ntheorem Multiset.map_toEnumFinset_fst (m : Multiset α) : m.to_enum_finset.val.map Prod.fst = m :=\n  by\n  ext x\n  simp only [Multiset.count_map, ← Finset.filter_val, Multiset.toEnumFinset_filter_eq, Finset.map_val, Finset.range_val,\n    Multiset.card_map, Multiset.card_range]\n#align multiset.map_to_enum_finset_fst Multiset.map_toEnumFinset_fst\n-/\n\n",
 "image_toEnumFinset_fst":
 "#print Multiset.image_toEnumFinset_fst /-\n@[simp]\ntheorem Multiset.image_toEnumFinset_fst (m : Multiset α) : m.to_enum_finset.image Prod.fst = m.to_finset := by\n  rw [Finset.image, Multiset.map_toEnumFinset_fst]\n#align multiset.image_to_enum_finset_fst Multiset.image_toEnumFinset_fst\n-/\n\n",
 "forall_coe":
 "#print Multiset.forall_coe /-\n@[simp]\nprotected theorem Multiset.forall_coe (p : m → Prop) : (∀ x : m, p x) ↔ ∀ (x : α) (i : Fin (m.count x)), p ⟨x, i⟩ :=\n  Sigma.forall\n#align multiset.forall_coe Multiset.forall_coe\n-/\n\n",
 "exists_coe":
 "#print Multiset.exists_coe /-\n@[simp]\nprotected theorem Multiset.exists_coe (p : m → Prop) : (∃ x : m, p x) ↔ ∃ (x : α)(i : Fin (m.count x)), p ⟨x, i⟩ :=\n  Sigma.exists\n#align multiset.exists_coe Multiset.exists_coe\n-/\n\n",
 "coe_mk":
 "#print Multiset.coe_mk /-\n@[simp]\ntheorem Multiset.coe_mk {x : α} {i : Fin (m.count x)} : ↑(m.mk_to_type x i) = x :=\n  rfl\n#align multiset.coe_mk Multiset.coe_mk\n-/\n\n",
 "coe_mem":
 "#print Multiset.coe_mem /-\n@[simp]\ntheorem Multiset.coe_mem {x : m} : ↑x ∈ m :=\n  Multiset.count_pos.mp (pos_of_gt x.2.2)\n#align multiset.coe_mem Multiset.coe_mem\n-/\n\n",
 "coe_eq":
 "#print Multiset.coe_eq /-\n@[simp]\ntheorem Multiset.coe_eq {x y : m} : (x : α) = (y : α) ↔ x.1 = y.1 :=\n  by\n  cases x\n  cases y\n  rfl\n#align multiset.coe_eq Multiset.coe_eq\n-/\n\n",
 "card_toEnumFinset":
 "#print Multiset.card_toEnumFinset /-\n@[simp]\ntheorem Multiset.card_toEnumFinset (m : Multiset α) : m.to_enum_finset.card = m.card :=\n  by\n  change Multiset.card _ = _\n  convert_to(m.to_enum_finset.val.map Prod.fst).card = _\n  · rw [Multiset.card_map]\n  · rw [m.map_to_enum_finset_fst]\n#align multiset.card_to_enum_finset Multiset.card_toEnumFinset\n-/\n\n",
 "card_coe":
 "#print Multiset.card_coe /-\n@[simp]\ntheorem Multiset.card_coe (m : Multiset α) : Fintype.card m = m.card :=\n  by\n  rw [Fintype.card_congr m.coe_equiv]\n  simp\n#align multiset.card_coe Multiset.card_coe\n-/\n\n"}