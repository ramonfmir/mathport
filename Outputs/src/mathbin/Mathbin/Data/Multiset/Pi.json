{"pi_zero":
 "@[simp]\ntheorem pi_zero (t : ∀ a, Multiset (β a)) : pi 0 t = {Pi.empty β} :=\n  rfl\n#align pi_zero pi_zero\n\n",
 "pi_cons_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem pi_cons_injective {a : α} {b : δ a} {s : Multiset α} (hs : a ∉ s) : function.injective (Pi.cons s a b) :=\n  fun f₁ f₂ eq =>\n  funext fun a' =>\n    funext fun h' =>\n      have ne : a ≠ a' := fun h => hs <| h.symm ▸ h'\n      have : a' ∈ «expr ::ₘ » a s := mem_cons_of_mem h'\n      calc\n        f₁ a' h' = Pi.cons s a b f₁ a' this := by rw [pi.cons_ne this ne.symm]\n        _ = Pi.cons s a b f₂ a' this := by rw [Eq]\n        _ = f₂ a' h' := by rw [pi.cons_ne this ne.symm]\n        \n#align pi_cons_injective pi_cons_injective\n\n",
 "pi_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem pi_cons (m : Multiset α) (t : ∀ a, Multiset (β a)) (a : α) :\n    pi («expr ::ₘ » a m) t = (t a).bind fun b => (pi m t).map <| Pi.cons m a b :=\n  recOn_cons a m\n#align pi_cons pi_cons\n\n",
 "pi":
 "protected theorem nodup.pi {s : Multiset α} {t : ∀ a, Multiset (β a)} :\n    Nodup s → (∀ a ∈ s, Nodup (t a)) → Nodup (pi s t) :=\n  Multiset.induction_on s (fun _ _ => nodup_singleton _)\n    (by\n      intro a s ih hs ht\n      have has : a ∉ s := by simp at hs <;> exact hs.1\n      have hs : nodup s := by simp at hs <;> exact hs.2\n      simp\n      refine' ⟨fun b hb => (ih hs fun a' h' => ht a' <| mem_cons_of_mem h').map (pi_cons_injective has), _⟩\n      refine' (ht a <| mem_cons_self _ _).pairwise _\n      exact fun b₁ hb₁ b₂ hb₂ neb =>\n        disjoint_map_map.2 fun f hf g hg eq =>\n          have : pi.cons s a b₁ f a (mem_cons_self _ _) = pi.cons s a b₂ g a (mem_cons_self _ _) := by rw [Eq]\n          neb <| show b₁ = b₂ by rwa [pi.cons_same, pi.cons_same] at this)\n#align nodup.pi nodup.pi\n\n",
 "mem_pi":
 "theorem mem_pi (m : Multiset α) (t : ∀ a, Multiset (β a)) :\n    ∀ f : ∀ a ∈ m, β a, f ∈ pi m t ↔ ∀ (a) (h : a ∈ m), f a h ∈ t a :=\n  by\n  intro f\n  induction' m using Multiset.induction_on with a m ih\n  · simpa using show f = pi.empty β by funext a ha <;> exact ha.elim\n  simp_rw [pi_cons, mem_bind, mem_map, ih]\n  constructor\n  · rintro ⟨b, hb, f', hf', rfl⟩ a' ha'\n    by_cases a' = a\n    · subst h\n      rwa [pi.cons_same]\n    · rw [pi.cons_ne _ h]\n      apply hf'\n  · intro hf\n    refine' ⟨_, hf a (mem_cons_self _ _), _, fun a ha => hf a (mem_cons_of_mem ha), _⟩\n    rw [pi.cons_ext]\n#align mem_pi mem_pi\n\n",
 "cons_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem pi.cons_swap {a a' : α} {b : δ a} {b' : δ a'} {m : Multiset α} {f : ∀ a ∈ m, δ a} (h : a ≠ a') :\n    HEq (Pi.cons («expr ::ₘ » a' m) a b (Pi.cons m a' b' f)) (Pi.cons («expr ::ₘ » a m) a' b' (Pi.cons m a b f)) :=\n  by\n  apply hfunext rfl\n  rintro a'' _ rfl\n  refine' hfunext (by rw [cons_swap]) fun ha₁ ha₂ _ => _\n  rcases ne_or_eq a'' a with (h₁ | rfl)\n  rcases eq_or_ne a'' a' with (rfl | h₂)\n  all_goals simp [*, pi.cons_same, pi.cons_ne]\n#align pi.cons_swap pi.cons_swap\n\n",
 "cons_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem pi.cons_same {m : Multiset α} {a : α} {b : δ a} {f : ∀ a ∈ m, δ a} (h : a ∈ «expr ::ₘ » a m) :\n    Pi.cons m a b f a h = b :=\n  dif_pos rfl\n#align pi.cons_same pi.cons_same\n\n",
 "cons_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem pi.cons_ne {m : Multiset α} {a a' : α} {b : δ a} {f : ∀ a ∈ m, δ a} (h' : a' ∈ «expr ::ₘ » a m) (h : a' ≠ a) :\n    Pi.cons m a b f a' h' = f a' ((mem_cons.1 h').resolve_left h) :=\n  dif_neg h\n#align pi.cons_ne pi.cons_ne\n\n",
 "cons_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem pi.cons_ext {m : Multiset α} {a : α} (f : ∀ a' ∈ «expr ::ₘ » a m, δ a') :\n    (Pi.cons m a (f _ (mem_cons_self _ _)) fun a' ha' => f a' (mem_cons_of_mem ha')) = f :=\n  by\n  ext (a' h')\n  by_cases a' = a\n  · subst h\n    rw [pi.cons_same]\n  · rw [pi.cons_ne _ h]\n#align pi.cons_ext pi.cons_ext\n\n",
 "card_pi":
 "theorem card_pi (m : Multiset α) (t : ∀ a, Multiset (β a)) : card (pi m t) = prod (m.map fun a => card (t a)) :=\n  Multiset.induction_on m (by simp) (by simp (config := { contextual := true }) [mul_comm])\n#align card_pi card_pi\n\n"}