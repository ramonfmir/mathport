{"zero_subset":
 "@[simp]\ntheorem zero_subset (s : Multiset α) : 0 ⊆ s := fun a => (not_mem_nil a).elim\n#align zero_subset zero_subset\n\n",
 "zero_ne_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem zero_ne_cons {a : α} {m : Multiset α} : 0 ≠ «expr ::ₘ » a m := fun h =>\n  have : a ∈ (0 : Multiset α) := h.symm ▸ mem_cons_self _ _\n  not_mem_zero _ this\n#align zero_ne_cons zero_ne_cons\n\n",
 "zero_le":
 "#print zero_le /-\ntheorem zero_le (s : Multiset α) : 0 ≤ s :=\n  Quot.inductionOn s fun l => (nil_sublist l).subperm\n#align zero_le zero_le\n-/\n\n",
 "zero_inter":
 "@[simp]\ntheorem zero_inter (s : Multiset α) : 0 ∩ s = 0 :=\n  Quot.inductionOn s fun l => congr_arg coe l.nil_bag_inter\n#align zero_inter zero_inter\n\n",
 "zero_disjoint":
 "@[simp]\ntheorem zero_disjoint (l : Multiset α) : Disjoint 0 l\n  | a => (not_mem_nil a).elim\n#align zero_disjoint zero_disjoint\n\n",
 "well_founded_lt":
 "/-- Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded. -/\ntheorem well_founded_lt : well_founded ((· < ·) : Multiset α → Multiset α → Prop) :=\n  subrelation.wf (fun _ _ => Multiset.card_lt_of_lt) (measure_wf Multiset.card)\n#align well_founded_lt well_founded_lt\n\n",
 "union_le_union_right":
 "theorem union_le_union_right (h : s ≤ t) (u) : s ∪ u ≤ t ∪ u :=\n  add_le_add_right (tsub_le_tsub_right h _) u\n#align union_le_union_right union_le_union_right\n\n",
 "union_le_union_left":
 "theorem union_le_union_left (h : s ≤ t) (u) : u ∪ s ≤ u ∪ t :=\n  sup_le_sup_left h _\n#align union_le_union_left union_le_union_left\n\n",
 "union_le_iff":
 "@[simp]\ntheorem union_le_iff : s ∪ t ≤ u ↔ s ≤ u ∧ t ≤ u :=\n  sup_le_iff\n#align union_le_iff union_le_iff\n\n",
 "union_le_add":
 "theorem union_le_add (s t : Multiset α) : s ∪ t ≤ s + t :=\n  union_le (le_add_right _ _) (le_add_left _ _)\n#align union_le_add union_le_add\n\n",
 "union_le":
 "theorem union_le (h₁ : s ≤ u) (h₂ : t ≤ u) : s ∪ t ≤ u := by rw [← eq_union_left h₂] <;> exact union_le_union_right h₁ t\n#align union_le union_le\n\n",
 "union_def":
 "theorem union_def (s t : Multiset α) : s ∪ t = s - t + t :=\n  rfl\n#align union_def union_def\n\n",
 "union_comm":
 "theorem union_comm (s t : Multiset α) : s ∪ t = t ∪ s :=\n  sup_comm\n#align union_comm union_comm\n\n",
 "union_add_inter":
 "theorem union_add_inter (s t : Multiset α) : s ∪ t + s ∩ t = s + t :=\n  by\n  apply le_antisymm\n  · rw [union_add_distrib]\n    refine' union_le (add_le_add_left (inter_le_right _ _) _) _\n    rw [add_comm]\n    exact add_le_add_right (inter_le_left _ _) _\n  · rw [add_comm, add_inter_distrib]\n    refine' le_inter (add_le_add_right (le_union_right _ _) _) _\n    rw [add_comm]\n    exact add_le_add_right (le_union_left _ _) _\n#align union_add_inter union_add_inter\n\n",
 "union_add_distrib":
 "theorem union_add_distrib (s t u : Multiset α) : s ∪ t + u = s + u ∪ (t + u) := by\n  simpa [(· ∪ ·), union, eq_comm, add_assoc] using\n    show s + u - (t + u) = s - t by rw [add_comm t, tsub_add_eq_tsub_tsub, add_tsub_cancel_right]\n#align union_add_distrib union_add_distrib\n\n",
 "trans":
 "theorem rel.trans (r : α → α → Prop) [is_trans α r] {s t u : Multiset α} (r1 : Rel r s t) (r2 : Rel r t u) :\n    Rel r s u := by\n  induction' t using Multiset.induction_on with x t ih generalizing s u\n  · rw [rel_zero_right.mp r1, rel_zero_left.mp r2, rel_zero_left]\n  · obtain ⟨a, as, ha1, ha2, rfl⟩ := rel_cons_right.mp r1\n    obtain ⟨b, bs, hb1, hb2, rfl⟩ := rel_cons_left.mp r2\n    exact multiset.rel.cons (trans ha1 hb1) (ih ha2 hb2)\n#align rel.trans rel.trans\n\n",
 "to_list_zero":
 "@[simp]\ntheorem to_list_zero : (Multiset.toList 0 : list α) = [] :=\n  toList_eq_nil.mpr rfl\n#align to_list_zero to_list_zero\n\n",
 "to_list_singleton":
 "@[simp]\ntheorem to_list_singleton (a : α) : ({a} : Multiset α).to_list = [a] :=\n  multiset.to_list_eq_singleton_iff.2 rfl\n#align to_list_singleton to_list_singleton\n\n",
 "to_list_eq_singleton_iff":
 "@[simp]\ntheorem to_list_eq_singleton_iff {a : α} {m : Multiset α} : m.to_list = [a] ↔ m = {a} := by\n  rw [← perm_singleton, ← coe_eq_coe, coe_to_list, coe_singleton]\n#align to_list_eq_singleton_iff to_list_eq_singleton_iff\n\n",
 "to_list_eq_nil":
 "@[simp]\ntheorem to_list_eq_nil {s : Multiset α} : s.to_list = [] ↔ s = 0 := by rw [← coe_eq_zero, coe_to_list]\n#align to_list_eq_nil to_list_eq_nil\n\n",
 "symm":
 "#print Disjoint.symm /-\ntheorem Disjoint.symm {s t : Multiset α} (d : Disjoint s t) : Disjoint t s\n  | a, i₂, i₁ => d i₁ i₂\n#align disjoint.symm Disjoint.symm\n-/\n\n",
 "sup_eq_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_eq_union (s t : Multiset α) : «expr ⊔ » s t = s ∪ t :=\n  rfl\n#align sup_eq_union sup_eq_union\n\n",
 "subset_zero":
 "theorem subset_zero {s : Multiset α} : s ⊆ 0 ↔ s = 0 :=\n  ⟨eq_zero_of_subset_zero, fun xeq => xeq.symm ▸ Subset.refl 0⟩\n#align subset_zero subset_zero\n\n",
 "subset_of_le":
 "theorem subset_of_le : s ≤ t → s ⊆ t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => Subperm.subset\n#align subset_of_le subset_of_le\n\n",
 "subset_iff":
 "theorem subset_iff {s t : Multiset α} : s ⊆ t ↔ ∀ ⦃x⦄, x ∈ s → x ∈ t :=\n  iff.rfl\n#align subset_iff subset_iff\n\n",
 "subset_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem subset_cons (s : Multiset α) (a : α) : s ⊆ «expr ::ₘ » a s := fun _ => mem_cons_of_mem\n#align subset_cons subset_cons\n\n",
 "sub_zero":
 "#print sub_zero /-\n/-- This is a special case of `tsub_zero`, which should be used instead of this.\n  This is needed to prove `has_ordered_sub (multiset α)`. -/\nprotected theorem sub_zero (s : Multiset α) : s - 0 = s :=\n  Quot.inductionOn s fun l => rfl\n#align sub_zero sub_zero\n-/\n\n",
 "sub_le_iff_le_add":
 "#print sub_le_iff_le_add /-\n/-- This is a special case of `tsub_le_iff_right`, which should be used instead of this.\n  This is needed to prove `has_ordered_sub (multiset α)`. -/\nprotected theorem sub_le_iff_le_add : s - t ≤ u ↔ s ≤ u + t := by\n  revert s <;>\n    exact Multiset.induction_on t (by simp [Multiset.sub_zero]) fun a t IH s => by simp [IH, erase_le_iff_le_cons]\n#align sub_le_iff_le_add sub_le_iff_le_add\n-/\n\n",
 "sub_inter":
 "theorem sub_inter (s t : Multiset α) : s - s ∩ t = s - t :=\n  add_right_cancel <| by rw [sub_add_inter s t, tsub_add_cancel_of_le (inter_le_left s t)]\n#align sub_inter sub_inter\n\n",
 "sub_eq_fold_erase":
 "theorem sub_eq_fold_erase (s t : Multiset α) : s - t = foldl erase erase_comm s t :=\n  quotient.induction_on₂ s t fun l₁ l₂ =>\n    show ↑(l₁.diff l₂) = foldl erase erase_comm ↑l₁ ↑l₂\n      by\n      rw [diff_eq_foldl l₁ l₂]\n      symm\n      exact foldl_hom _ _ _ _ _ fun x y => rfl\n#align sub_eq_fold_erase sub_eq_fold_erase\n\n",
 "sub_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem sub_cons (a : α) (s t : Multiset α) : s - «expr ::ₘ » a t = s.erase a - t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => congr_arg coe <| diff_cons _ _ _\n#align sub_cons sub_cons\n\n",
 "sub_add_inter":
 "theorem sub_add_inter (s t : Multiset α) : s - t + s ∩ t = s :=\n  by\n  rw [inter_comm]\n  revert s; refine' Multiset.induction_on t (by simp) fun a t IH s => _\n  by_cases a ∈ s\n  · rw [cons_inter_of_pos _ h, sub_cons, add_cons, IH, cons_erase h]\n  · rw [cons_inter_of_neg _ h, sub_cons, erase_of_not_mem h, IH]\n#align sub_add_inter sub_add_inter\n\n",
 "strong_induction_eq":
 "theorem strong_induction_eq {p : Multiset α → Sort _} (s : Multiset α) (H) :\n    @strongInductionOn _ p s H = H s fun t h => @strongInductionOn _ p t H := by rw [strong_induction_on]\n#align strong_induction_eq strong_induction_eq\n\n",
 "strong_downward_induction_on_eq":
 "theorem strong_downward_induction_on_eq {p : Multiset α → Sort _} (s : Multiset α) {n : ℕ}\n    (H : ∀ t₁, (∀ {t₂ : Multiset α}, t₂.card ≤ n → t₁ < t₂ → p t₂) → t₁.card ≤ n → p t₁) :\n    s.strong_downward_induction_on H = H s fun t ht h => t.strong_downward_induction_on H ht :=\n  by\n  dsimp only [strong_downward_induction_on]\n  rw [strong_downward_induction]\n#align strong_downward_induction_on_eq strong_downward_induction_on_eq\n\n",
 "strong_downward_induction_eq":
 "theorem strong_downward_induction_eq {p : Multiset α → Sort _} {n : ℕ}\n    (H : ∀ t₁, (∀ {t₂ : Multiset α}, t₂.card ≤ n → t₁ < t₂ → p t₂) → t₁.card ≤ n → p t₁) (s : Multiset α) :\n    strongDownwardInduction H s = H s fun t ht hst => strongDownwardInduction H t ht := by\n  rw [strong_downward_induction]\n#align strong_downward_induction_eq strong_downward_induction_eq\n\n",
 "ssubset_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem ssubset_cons {s : Multiset α} {a : α} (ha : a ∉ s) : «expr ⊂ » s («expr ::ₘ » a s) :=\n  ⟨subset_cons _ _, fun h => ha <| h <| mem_cons_self _ _⟩\n#align ssubset_cons ssubset_cons\n\n",
 "sizeof_lt_sizeof_of_mem":
 "theorem sizeof_lt_sizeof_of_mem [SizeOf α] {x : α} {s : Multiset α} (hx : x ∈ s) : SizeOf.sizeOf x < SizeOf.sizeOf s :=\n  by\n  induction' s with l a b\n  exact List.sizeOf_lt_sizeOf_of_mem hx\n  rfl\n#align sizeof_lt_sizeof_of_mem sizeof_lt_sizeof_of_mem\n\n",
 "singleton_ne_zero":
 "@[simp]\ntheorem singleton_ne_zero (a : α) : ({a} : Multiset α) ≠ 0 :=\n  ne_of_gt (lt_cons_self _ _)\n#align singleton_ne_zero singleton_ne_zero\n\n",
 "singleton_le":
 "@[simp]\ntheorem singleton_le {a : α} {s : Multiset α} : {a} ≤ s ↔ a ∈ s :=\n  ⟨fun h => mem_of_le h (mem_singleton_self _), fun h =>\n    let ⟨t, e⟩ := exists_cons_of_mem h\n    e.symm ▸ cons_le_cons _ (zero_le _)⟩\n#align singleton_le singleton_le\n\n",
 "singleton_inj":
 "@[simp]\ntheorem singleton_inj {a b : α} : ({a} : Multiset α) = {b} ↔ a = b :=\n  by\n  simp_rw [← cons_zero]\n  exact cons_inj_left _\n#align singleton_inj singleton_inj\n\n",
 "singleton_eq_cons_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem singleton_eq_cons_iff {a b : α} (m : Multiset α) : {a} = «expr ::ₘ » b m ↔ a = b ∧ m = 0 :=\n  by\n  rw [← cons_zero, cons_eq_cons]\n  simp [eq_comm]\n#align singleton_eq_cons_iff singleton_eq_cons_iff\n\n",
 "singleton_disjoint":
 "@[simp]\ntheorem singleton_disjoint {l : Multiset α} {a : α} : Disjoint {a} l ↔ a ∉ l := by simp [Disjoint] <;> rfl\n#align singleton_disjoint singleton_disjoint\n\n",
 "singleton_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem singleton_add (a : α) (s : Multiset α) : {a} + s = «expr ::ₘ » a s :=\n  rfl\n#align singleton_add singleton_add\n\n",
 "replicate_zero":
 "@[simp]\ntheorem replicate_zero (a : α) : replicate 0 a = 0 :=\n  rfl\n#align replicate_zero replicate_zero\n\n",
 "replicate_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem replicate_succ (a : α) (n) : replicate (n + 1) a = «expr ::ₘ » a (replicate n a) :=\n  rfl\n#align replicate_succ replicate_succ\n\n",
 "replicate_subset_singleton":
 "theorem replicate_subset_singleton : ∀ (n) (a : α), replicate n a ⊆ {a} :=\n  replicate_subset_singleton\n#align replicate_subset_singleton replicate_subset_singleton\n\n",
 "replicate_right_injective":
 "theorem replicate_right_injective {n : ℕ} (hn : n ≠ 0) : function.injective (replicate n : α → Multiset α) :=\n  fun a b h => (eq_replicate.1 h).2 _ <| mem_replicate.2 ⟨hn, rfl⟩\n#align replicate_right_injective replicate_right_injective\n\n",
 "replicate_right_inj":
 "@[simp]\ntheorem replicate_right_inj {a b : α} {n : ℕ} (h : n ≠ 0) : replicate n a = replicate n b ↔ a = b :=\n  (replicate_right_injective h).eq_iff\n#align replicate_right_inj replicate_right_inj\n\n",
 "replicate_one":
 "theorem replicate_one (a : α) : replicate 1 a = {a} :=\n  rfl\n#align replicate_one replicate_one\n\n",
 "replicate_left_injective":
 "theorem replicate_left_injective (a : α) : function.injective fun n => replicate n a := fun m n h => by\n  rw [← (eq_replicate.1 h).1, card_replicate]\n#align replicate_left_injective replicate_left_injective\n\n",
 "replicate_le_replicate":
 "theorem replicate_le_replicate (a : α) {k n : ℕ} : replicate k a ≤ replicate n a ↔ k ≤ n :=\n  replicate_le_coe.trans <| List.replicate_sublist_replicate _\n#align replicate_le_replicate replicate_le_replicate\n\n",
 "replicate_le_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\ntheorem replicate_le_coe {a : α} {n} {l : list α} : replicate n a ≤ l ↔ «expr <+ » (list.replicate n a) l :=\n  ⟨fun ⟨l', p, s⟩ => perm_replicate.1 p ▸ s, Sublist.subperm⟩\n#align replicate_le_coe replicate_le_coe\n\n",
 "replicate_inter":
 "@[simp]\ntheorem replicate_inter (n : ℕ) (x : α) (s : Multiset α) : replicate n x ∩ s = replicate (min n (s.count x)) x :=\n  by\n  ext y\n  rw [count_inter, count_replicate, count_replicate]\n  by_cases y = x\n  · simp only [h, if_pos rfl]\n  · simp only [h, if_false, zero_min]\n#align replicate_inter replicate_inter\n\n",
 "replicate_add":
 "theorem replicate_add (m n : ℕ) (a : α) : replicate (m + n) a = replicate m a + replicate n a :=\n  congr_arg _ <| List.replicate_add _ _ _\n#align replicate_add replicate_add\n\n",
 "rel_zero_right":
 "@[simp]\ntheorem rel_zero_right {a : Multiset α} : Rel r a 0 ↔ a = 0 := by rw [rel_iff] <;> simp\n#align rel_zero_right rel_zero_right\n\n",
 "rel_zero_left":
 "@[simp]\ntheorem rel_zero_left {b : Multiset β} : Rel r 0 b ↔ b = 0 := by rw [rel_iff] <;> simp\n#align rel_zero_left rel_zero_left\n\n",
 "rel_replicate_right":
 "theorem rel_replicate_right {m : Multiset α} {a : α} {r : α → α → Prop} {n : ℕ} :\n    m.rel r (replicate n a) ↔ m.card = n ∧ ∀ x, x ∈ m → r x a :=\n  rel_flip.trans rel_replicate_left\n#align rel_replicate_right rel_replicate_right\n\n",
 "rel_replicate_left":
 "theorem rel_replicate_left {m : Multiset α} {a : α} {r : α → α → Prop} {n : ℕ} :\n    (replicate n a).rel r m ↔ m.card = n ∧ ∀ x, x ∈ m → r a x :=\n  ⟨fun h =>\n    ⟨(card_eq_card_of_rel h).symm.trans (card_replicate _ _), fun x hx =>\n      by\n      obtain ⟨b, hb1, hb2⟩ := exists_mem_of_rel_of_mem (rel_flip.2 h) hx\n      rwa [eq_of_mem_replicate hb1] at hb2⟩,\n    fun h =>\n    rel_of_forall (fun x y hx hy => (eq_of_mem_replicate hx).symm ▸ h.2 _ hy) (eq.trans (card_replicate _ _) h.1.symm)⟩\n#align rel_replicate_left rel_replicate_left\n\n",
 "rel_refl_of_refl_on":
 "theorem rel_refl_of_refl_on {m : Multiset α} {r : α → α → Prop} : (∀ x ∈ m, r x x) → Rel r m m :=\n  by\n  apply m.induction_on\n  · intros\n    apply rel.zero\n  · intro a m ih h\n    exact rel.cons (h _ (mem_cons_self _ _)) (ih fun _ ha => h _ (mem_cons_of_mem ha))\n#align rel_refl_of_refl_on rel_refl_of_refl_on\n\n",
 "rel_of_forall":
 "theorem rel_of_forall {m1 m2 : Multiset α} {r : α → α → Prop} (h : ∀ a b, a ∈ m1 → b ∈ m2 → r a b)\n    (hc : card m1 = card m2) : m1.rel r m2 := by\n  revert m1\n  apply m2.induction_on\n  · intro m h hc\n    rw [rel_zero_right, ← card_eq_zero, hc, card_zero]\n  · intro a t ih m h hc\n    rw [card_cons] at hc\n    obtain ⟨b, hb⟩ := card_pos_iff_exists_mem.1 (show 0 < card m from hc.symm ▸ nat.succ_pos _)\n    obtain ⟨m', rfl⟩ := exists_cons_of_mem hb\n    refine' rel_cons_right.mpr ⟨b, m', h _ _ hb (mem_cons_self _ _), ih _ _, rfl⟩\n    · exact fun _ _ ha hb => h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb)\n    · simpa using hc\n#align rel_of_forall rel_of_forall\n\n",
 "rel_map_right":
 "theorem rel_map_right {s : Multiset α} {t : Multiset γ} {f : γ → β} :\n    Rel r s (t.map f) ↔ Rel (fun a b => r a (f b)) s t := by rw [← rel_flip, rel_map_left, ← rel_flip] <;> rfl\n#align rel_map_right rel_map_right\n\n",
 "rel_map_left":
 "theorem rel_map_left {s : Multiset γ} {f : γ → α} : ∀ {t}, Rel r (s.map f) t ↔ Rel (fun a b => r (f a) b) s t :=\n  Multiset.induction_on s (by simp) (by simp (config := { contextual := true }) [rel_cons_left])\n#align rel_map_left rel_map_left\n\n",
 "rel_map":
 "theorem rel_map {s : Multiset α} {t : Multiset β} {f : α → γ} {g : β → δ} :\n    Rel p (s.map f) (t.map g) ↔ Rel (fun a b => p (f a) (g b)) s t :=\n  rel_map_left.trans rel_map_right\n#align rel_map rel_map\n\n",
 "rel_flip_eq":
 "theorem rel_flip_eq {s t : Multiset α} : Rel (fun a b => b = a) s t ↔ s = t :=\n  show Rel (flip (· = ·)) s t ↔ s = t by rw [rel_flip, rel_eq, eq_comm]\n#align rel_flip_eq rel_flip_eq\n\n",
 "rel_flip_aux":
 "private theorem rel_flip_aux {s t} (h : Rel r s t) : Rel (flip r) t s :=\n  rel.rec_on h rel.zero fun _ _ _ _ h₀ h₁ ih => rel.cons h₀ ih\n#align rel_flip_aux rel_flip_aux\n\n",
 "rel_flip":
 "theorem rel_flip {s t} : Rel (flip r) s t ↔ Rel r t s :=\n  ⟨rel_flip_aux, rel_flip_aux⟩\n#align rel_flip rel_flip\n\n",
 "rel_eq_refl":
 "theorem rel_eq_refl {s : Multiset α} : Rel (· = ·) s s :=\n  rel_refl_of_refl_on fun x hx => rfl\n#align rel_eq_refl rel_eq_refl\n\n",
 "rel_eq":
 "theorem rel_eq {s t : Multiset α} : Rel (· = ·) s t ↔ s = t :=\n  by\n  constructor\n  · intro h\n    induction h <;> simp [*]\n  · intro h\n    subst h\n    exact rel_eq_refl\n#align rel_eq rel_eq\n\n",
 "rel_cons_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem rel_cons_right {as b bs} :\n    Rel r as («expr ::ₘ » b bs) ↔ ∃ a as', r a b ∧ Rel r as' bs ∧ as = «expr ::ₘ » a as' :=\n  by\n  rw [← rel_flip, rel_cons_left]\n  refine' exists₂_congr fun a as' => _\n  rw [rel_flip, flip]\n#align rel_cons_right rel_cons_right\n\n",
 "rel_cons_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem rel_cons_left {a as bs} :\n    Rel r («expr ::ₘ » a as) bs ↔ ∃ b bs', r a b ∧ Rel r as bs' ∧ bs = «expr ::ₘ » b bs' :=\n  by\n  constructor\n  · generalize hm : «expr ::ₘ » a as = m\n    intro h\n    induction h generalizing as\n    case zero => simp at hm; contradiction\n    case\n      cons a' b as' bs ha'b h ih =>\n      rcases cons_eq_cons.1 hm with (⟨eq₁, eq₂⟩ | ⟨h, cs, eq₁, eq₂⟩)\n      · subst eq₁\n        subst eq₂\n        exact ⟨b, bs, ha'b, h, rfl⟩\n      · rcases ih eq₂.symm with ⟨b', bs', h₁, h₂, eq⟩\n        exact ⟨b', «expr ::ₘ » b bs', h₁, eq₁.symm ▸ rel.cons ha'b h₂, eq.symm ▸ cons_swap _ _ _⟩\n  · exact fun ⟨b, bs', hab, h, eq⟩ => eq.symm ▸ rel.cons hab h\n#align rel_cons_left rel_cons_left\n\n",
 "rel_add_right":
 "theorem rel_add_right {as bs₀ bs₁} : Rel r as (bs₀ + bs₁) ↔ ∃ as₀ as₁, Rel r as₀ bs₀ ∧ Rel r as₁ bs₁ ∧ as = as₀ + as₁ :=\n  by rw [← rel_flip, rel_add_left] <;> simp [rel_flip]\n#align rel_add_right rel_add_right\n\n",
 "rel_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem rel_add_left {as₀ as₁} :\n    ∀ {bs}, Rel r (as₀ + as₁) bs ↔ ∃ bs₀ bs₁, Rel r as₀ bs₀ ∧ Rel r as₁ bs₁ ∧ bs = bs₀ + bs₁ :=\n  Multiset.induction_on as₀ (by simp)\n    (by\n      intro a s ih bs\n      simp only [ih, cons_add, rel_cons_left]\n      constructor\n      · intro h\n        rcases h with ⟨b, bs', hab, h, rfl⟩\n        rcases h with ⟨bs₀, bs₁, h₀, h₁, rfl⟩\n        exact ⟨«expr ::ₘ » b bs₀, bs₁, ⟨b, bs₀, hab, h₀, rfl⟩, h₁, by simp⟩\n      · intro h\n        rcases h with ⟨bs₀, bs₁, h, h₁, rfl⟩\n        rcases h with ⟨b, bs, hab, h₀, rfl⟩\n        exact ⟨b, bs + bs₁, hab, ⟨bs, bs₁, h₀, h₁, rfl⟩, by simp⟩)\n#align rel_add_left rel_add_left\n\n",
 "refl":
 "@[simp]\ntheorem subset.refl (s : Multiset α) : s ⊆ s := fun a h => h\n#align subset.refl subset.refl\n\n",
 "rec_on_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem rec_on_cons (a : α) (m : Multiset α) :\n    («expr ::ₘ » a m).rec_on C_0 C_cons C_cons_heq = C_cons a m (m.rec_on C_0 C_cons C_cons_heq) :=\n  Quotient.inductionOn m fun l => rfl\n#align rec_on_cons rec_on_cons\n\n",
 "rec_on_0":
 "@[simp]\ntheorem rec_on_0 : @Multiset.recOn α C (0 : Multiset α) C_0 C_cons C_cons_heq = C_0 :=\n  rfl\n#align rec_on_0 rec_on_0\n\n",
 "quot_mk_to_coe''":
 "@[simp]\ntheorem quot_mk_to_coe'' (l : list α) : @eq (Multiset α) (Quot.mk Setoid.r l) l :=\n  rfl\n#align quot_mk_to_coe'' quot_mk_to_coe''\n\n",
 "quot_mk_to_coe'":
 "@[simp]\ntheorem quot_mk_to_coe' (l : list α) : @eq (Multiset α) (Quot.mk (· ≈ ·) l) l :=\n  rfl\n#align quot_mk_to_coe' quot_mk_to_coe'\n\n",
 "quot_mk_to_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n@[simp]\ntheorem quot_mk_to_coe (l : list α) : @eq (Multiset α) («expr⟦ ⟧» l) l :=\n  rfl\n#align quot_mk_to_coe quot_mk_to_coe\n\n",
 "pmap_zero":
 "@[simp]\ntheorem pmap_zero {p : α → Prop} (f : ∀ a, p a → β) (h : ∀ a ∈ (0 : Multiset α), p a) : pmap f 0 h = 0 :=\n  rfl\n#align pmap_zero pmap_zero\n\n",
 "pmap_eq_map_attach":
 "theorem pmap_eq_map_attach {p : α → Prop} (f : ∀ a, p a → β) (s) :\n    ∀ H, pmap f s H = s.attach.map fun x => f x (H _ x.prop) :=\n  Quot.inductionOn s fun l H => congr_arg coe <| pmap_eq_map_attach f l H\n#align pmap_eq_map_attach pmap_eq_map_attach\n\n",
 "pmap_eq_map":
 "theorem pmap_eq_map (p : α → Prop) (f : α → β) (s : Multiset α) : ∀ H, @pmap _ _ p (fun a _ => f a) s H = map f s :=\n  Quot.inductionOn s fun l H => congr_arg coe <| pmap_eq_map p f l H\n#align pmap_eq_map pmap_eq_map\n\n",
 "pmap_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem pmap_cons {p : α → Prop} (f : ∀ a, p a → β) (a : α) (m : Multiset α) :\n    ∀ h : ∀ b ∈ «expr ::ₘ » a m, p b,\n      pmap f («expr ::ₘ » a m) h =\n        «expr ::ₘ » (f a (h a (mem_cons_self a m))) (pmap f m fun a ha => h a <| mem_cons_of_mem ha) :=\n  Quotient.inductionOn m fun l h => rfl\n#align pmap_cons pmap_cons\n\n",
 "pmap_congr":
 "theorem pmap_congr {p q : α → Prop} {f : ∀ a, p a → β} {g : ∀ a, q a → β} (s : Multiset α) {H₁ H₂} :\n    (∀ a ∈ s, ∀ (h₁ h₂), f a h₁ = g a h₂) → pmap f s H₁ = pmap g s H₂ :=\n  Quot.inductionOn s (fun l H₁ H₂ h => congr_arg coe <| pmap_congr l h) H₁ H₂\n#align pmap_congr pmap_congr\n\n",
 "pairwise_nil":
 "@[simp]\ntheorem pairwise_nil (r : α → α → Prop) : Multiset.Pairwise r 0 :=\n  ⟨[], rfl, List.Pairwise.nil⟩\n#align pairwise_nil pairwise_nil\n\n",
 "pairwise_coe_iff_pairwise":
 "theorem pairwise_coe_iff_pairwise {r : α → α → Prop} (hr : symmetric r) {l : list α} :\n    Multiset.Pairwise r l ↔ l.pairwise r :=\n  iff.intro (fun ⟨l', eq, h⟩ => ((quotient.exact eq).pairwise_iff hr).2 h) fun h => ⟨l, rfl, h⟩\n#align pairwise_coe_iff_pairwise pairwise_coe_iff_pairwise\n\n",
 "pairwise_coe_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\ntheorem pairwise_coe_iff {r : α → α → Prop} {l : list α} :\n    Multiset.Pairwise r l ↔ ∃ l' : list α, list.perm l l' ∧ l'.pairwise r :=\n  exists_congr <| by simp\n#align pairwise_coe_iff pairwise_coe_iff\n\n",
 "pair_comm":
 "theorem pair_comm (x y : α) : ({x, y} : Multiset α) = {y, x} :=\n  cons_swap x y 0\n#align pair_comm pair_comm\n\n",
 "one_le_count_iff_mem":
 "theorem one_le_count_iff_mem {a : α} {s : Multiset α} : 1 ≤ count a s ↔ a ∈ s := by rw [succ_le_iff, count_pos]\n#align one_le_count_iff_mem one_le_count_iff_mem\n\n",
 "of_mem_filter":
 "theorem of_mem_filter {a : α} {s} (h : a ∈ filter p s) : p a :=\n  (mem_filter.1 h).2\n#align of_mem_filter of_mem_filter\n\n",
 "nsmul_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem nsmul_singleton (a : α) (n) : «expr • » n ({a} : Multiset α) = replicate n a :=\n  by\n  refine' eq_replicate.mpr ⟨_, fun b hb => mem_singleton.mp (mem_of_mem_nsmul hb)⟩\n  rw [card_nsmul, card_singleton, mul_one]\n#align nsmul_singleton nsmul_singleton\n\n",
 "nsmul_replicate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem nsmul_replicate {a : α} (n m : ℕ) : «expr • » n (replicate m a) = replicate (n * m) a :=\n  ((replicateAddMonoidHom a).map_nsmul _ _).symm\n#align nsmul_replicate nsmul_replicate\n\n",
 "nsmul_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem nsmul_cons {s : Multiset α} (n : ℕ) (a : α) : «expr • » n («expr ::ₘ » a s) = «expr • » n {a} + «expr • » n s :=\n  by rw [← singleton_add, nsmul_add]\n#align nsmul_cons nsmul_cons\n\n",
 "not_mem_zero":
 "@[simp]\ntheorem not_mem_zero (a : α) : a ∉ (0 : Multiset α) :=\n  id\n#align not_mem_zero not_mem_zero\n\n",
 "not_mem_mono":
 "theorem not_mem_mono (h : s ⊆ t) : a ∉ t → a ∉ s :=\n  mt <| @h _\n#align not_mem_mono not_mem_mono\n\n",
 "monotone_filter_right":
 "theorem monotone_filter_right (s : Multiset α) ⦃p q : α → Prop⦄ [decidable_pred p] [decidable_pred q] (h : p ≤ q) :\n    s.filter p ≤ s.filter q :=\n  Quotient.inductionOn s fun l => (l.monotone_filter_right h).subperm\n#align monotone_filter_right monotone_filter_right\n\n",
 "monotone_filter_left":
 "theorem monotone_filter_left : monotone (filter p) := fun s t => filter_le_filter p\n#align monotone_filter_left monotone_filter_left\n\n",
 "mono":
 "theorem rel.mono {r p : α → β → Prop} {s t} (hst : Rel r s t) (h : ∀ a ∈ s, ∀ b ∈ t, r a b → p a b) : Rel p s t :=\n  by\n  induction hst\n  case zero => exact rel.zero\n  case\n    cons a b s t hab hst ih =>\n    apply rel.cons (h a (mem_cons_self _ _) b (mem_cons_self _ _) hab)\n    exact ih fun a' ha' b' hb' h' => h a' (mem_cons_of_mem ha') b' (mem_cons_of_mem hb') h'\n#align rel.mono rel.mono\n\n",
 "mem_union":
 "@[simp]\ntheorem mem_union : a ∈ s ∪ t ↔ a ∈ s ∨ a ∈ t :=\n  ⟨fun h => (mem_add.1 h).imp_left (mem_of_le tsub_le_self),\n    or.rec (mem_of_le <| le_union_left _ _) (mem_of_le <| le_union_right _ _)⟩\n#align mem_union mem_union\n\n",
 "mem_to_list":
 "@[simp]\ntheorem mem_to_list {a : α} {s : Multiset α} : a ∈ s.to_list ↔ a ∈ s := by rw [← mem_coe, coe_to_list]\n#align mem_to_list mem_to_list\n\n",
 "mem_singleton_self":
 "theorem mem_singleton_self (a : α) : a ∈ ({a} : Multiset α) :=\n  by\n  rw [← cons_zero]\n  exact mem_cons_self _ _\n#align mem_singleton_self mem_singleton_self\n\n",
 "mem_singleton":
 "@[simp]\ntheorem mem_singleton {a b : α} : b ∈ ({a} : Multiset α) ↔ b = a := by\n  simp only [← cons_zero, mem_cons, iff_self_iff, or_false_iff, not_mem_zero]\n#align mem_singleton mem_singleton\n\n",
 "mem_replicate":
 "theorem mem_replicate {a b : α} {n : ℕ} : b ∈ replicate n a ↔ n ≠ 0 ∧ b = a :=\n  mem_replicate\n#align mem_replicate mem_replicate\n\n",
 "mem_pmap":
 "@[simp]\ntheorem mem_pmap {p : α → Prop} {f : ∀ a, p a → β} {s H b} : b ∈ pmap f s H ↔ ∃ (a : _)(h : a ∈ s), f a (H a h) = b :=\n  Quot.inductionOn s (fun l H => mem_pmap) H\n#align mem_pmap mem_pmap\n\n",
 "mem_of_subset":
 "theorem mem_of_subset {s t : Multiset α} {a : α} (h : s ⊆ t) : a ∈ s → a ∈ t :=\n  @h _\n#align mem_of_subset mem_of_subset\n\n",
 "mem_of_mem_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_of_mem_nsmul {a : α} {s : Multiset α} {n : ℕ} (h : a ∈ «expr • » n s) : a ∈ s :=\n  by\n  induction' n with n ih\n  · rw [zero_nsmul] at h\n    exact absurd h (not_mem_zero _)\n  · rw [succ_nsmul, mem_add] at h\n    exact h.elim id ih\n#align mem_of_mem_nsmul mem_of_mem_nsmul\n\n",
 "mem_of_mem_filter":
 "theorem mem_of_mem_filter {a : α} {s} (h : a ∈ filter p s) : a ∈ s :=\n  (mem_filter.1 h).1\n#align mem_of_mem_filter mem_of_mem_filter\n\n",
 "mem_of_mem_erase":
 "theorem mem_of_mem_erase {a b : α} {s : Multiset α} : a ∈ s.erase b → a ∈ s :=\n  mem_of_subset (erase_subset _ _)\n#align mem_of_mem_erase mem_of_mem_erase\n\n",
 "mem_of_le":
 "theorem mem_of_le (h : s ≤ t) : a ∈ s → a ∈ t :=\n  mem_of_subset (subset_of_le h)\n#align mem_of_le mem_of_le\n\n",
 "mem_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_nsmul {a : α} {s : Multiset α} {n : ℕ} (h0 : n ≠ 0) : a ∈ «expr • » n s ↔ a ∈ s :=\n  by\n  refine' ⟨mem_of_mem_nsmul, fun h => _⟩\n  obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero h0\n  rw [succ_nsmul, mem_add]\n  exact or.inl h\n#align mem_nsmul mem_nsmul\n\n",
 "mem_map_of_mem":
 "theorem mem_map_of_mem (f : α → β) {a : α} {s : Multiset α} (h : a ∈ s) : f a ∈ map f s :=\n  mem_map.2 ⟨_, h, rfl⟩\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_of_injective":
 "theorem mem_map_of_injective {f : α → β} (H : function.injective f) {a : α} {s : Multiset α} : f a ∈ map f s ↔ a ∈ s :=\n  Quot.inductionOn s fun l => mem_map_of_injective H\n#align mem_map_of_injective mem_map_of_injective\n\n",
 "mem_map":
 "@[simp]\ntheorem mem_map {f : α → β} {b : β} {s : Multiset α} : b ∈ map f s ↔ ∃ a, a ∈ s ∧ f a = b :=\n  Quot.inductionOn s fun l => mem_map'\n#align mem_map mem_map\n\n",
 "mem_inter":
 "@[simp]\ntheorem mem_inter : a ∈ s ∩ t ↔ a ∈ s ∧ a ∈ t :=\n  ⟨fun h => ⟨mem_of_le (inter_le_left _ _) h, mem_of_le (inter_le_right _ _) h⟩, fun ⟨h₁, h₂⟩ => by\n    rw [← cons_erase h₁, cons_inter_of_pos _ h₂] <;> apply mem_cons_self⟩\n#align mem_inter mem_inter\n\n",
 "mem_filter_of_mem":
 "theorem mem_filter_of_mem {a : α} {l} (m : a ∈ l) (h : p a) : a ∈ filter p l :=\n  mem_filter.2 ⟨m, h⟩\n#align mem_filter_of_mem mem_filter_of_mem\n\n",
 "mem_filter_map":
 "@[simp]\ntheorem mem_filter_map (f : α → option β) (s : Multiset α) {b : β} : b ∈ filterMap f s ↔ ∃ a, a ∈ s ∧ f a = some b :=\n  Quot.inductionOn s fun l => mem_filterMap f l\n#align mem_filter_map mem_filter_map\n\n",
 "mem_filter":
 "@[simp]\ntheorem mem_filter {a : α} {s} : a ∈ filter p s ↔ a ∈ s ∧ p a :=\n  Quot.inductionOn s fun l => mem_filter\n#align mem_filter mem_filter\n\n",
 "mem_erase_of_ne":
 "theorem mem_erase_of_ne {a b : α} {s : Multiset α} (ab : a ≠ b) : a ∈ s.erase b ↔ a ∈ s :=\n  Quot.inductionOn s fun l => List.mem_erase_of_ne ab\n#align mem_erase_of_ne mem_erase_of_ne\n\n",
 "mem_cons_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem mem_cons_self (a : α) (s : Multiset α) : a ∈ «expr ::ₘ » a s :=\n  mem_cons.2 (or.inl rfl)\n#align mem_cons_self mem_cons_self\n\n",
 "mem_cons_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem mem_cons_of_mem {a b : α} {s : Multiset α} (h : a ∈ s) : a ∈ «expr ::ₘ » b s :=\n  mem_cons.2 <| or.inr h\n#align mem_cons_of_mem mem_cons_of_mem\n\n",
 "mem_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem mem_cons {a b : α} {s : Multiset α} : a ∈ «expr ::ₘ » b s ↔ a = b ∨ a ∈ s :=\n  Quot.inductionOn s fun l => iff.rfl\n#align mem_cons mem_cons\n\n",
 "mem_coe":
 "@[simp]\ntheorem mem_coe {a : α} {l : list α} : a ∈ (l : Multiset α) ↔ a ∈ l :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "mem_attach":
 "@[simp]\ntheorem mem_attach (s : Multiset α) : ∀ x, x ∈ s.attach :=\n  Quot.inductionOn s fun l => mem_attach _\n#align mem_attach mem_attach\n\n",
 "mem_add":
 "@[simp]\ntheorem mem_add {a : α} {s t : Multiset α} : a ∈ s + t ↔ a ∈ s ∨ a ∈ t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => mem_append\n#align mem_add mem_add\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero (f : α → β) : map f 0 = 0 :=\n  rfl\n#align map_zero map_zero\n-/\n\n",
 "map_union":
 "@[simp]\ntheorem map_union [decidable_eq β] {f : α → β} (finj : function.injective f) {s t : Multiset α} :\n    map f (s ∪ t) = map f s ∪ map f t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => congr_arg coe (by rw [list.map_append f, List.map_diff finj])\n#align map_union map_union\n\n",
 "map_surjective_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem map_surjective_of_surjective {f : α → β} (hf : function.surjective f) : function.surjective (map f) :=\n  by\n  intro s\n  induction' s using Multiset.induction_on with x s ih\n  · exact ⟨0, map_zero _⟩\n  · obtain ⟨y, rfl⟩ := hf x\n    obtain ⟨t, rfl⟩ := ih\n    exact ⟨«expr ::ₘ » y t, map_cons _ _ _⟩\n#align map_surjective_of_surjective map_surjective_of_surjective\n\n",
 "map_subset_map":
 "@[simp]\ntheorem map_subset_map {f : α → β} {s t : Multiset α} (H : s ⊆ t) : map f s ⊆ map f t := fun b m =>\n  let ⟨a, h, e⟩ := mem_map.1 m\n  mem_map.2 ⟨a, H h, e⟩\n#align map_subset_map map_subset_map\n\n",
 "map_strict_mono":
 "theorem map_strict_mono (f : α → β) : strict_mono (map f) := fun _ _ => map_lt_map\n#align map_strict_mono map_strict_mono\n\n",
 "map_singleton":
 "@[simp]\ntheorem map_singleton (f : α → β) (a : α) : ({a} : Multiset α).map f = {f a} :=\n  rfl\n#align map_singleton map_singleton\n\n",
 "map_set_pairwise":
 "theorem map_set_pairwise {f : α → β} {r : β → β → Prop} {m : Multiset α}\n    (h : { a | a ∈ m }.pairwise fun a₁ a₂ => r (f a₁) (f a₂)) : { b | b ∈ m.map f }.pairwise r := fun b₁ h₁ b₂ h₂ hn =>\n  by\n  obtain ⟨⟨a₁, H₁, rfl⟩, a₂, H₂, rfl⟩ := Multiset.mem_map.1 h₁, Multiset.mem_map.1 h₂\n  exact h H₁ H₂ (mt (congr_arg f) hn)\n#align map_set_pairwise map_set_pairwise\n\n",
 "map_replicate":
 "@[simp]\ntheorem map_replicate (f : α → β) (a : α) (k : ℕ) : (replicate k a).map f = replicate k (f a) := by\n  simp only [← coe_replicate, coe_map, map_replicate]\n#align map_replicate map_replicate\n\n",
 "map_pmap":
 "theorem map_pmap {p : α → Prop} (g : β → γ) (f : ∀ a, p a → β) (s) :\n    ∀ H, map g (pmap f s H) = pmap (fun a h => g (f a h)) s H :=\n  Quot.inductionOn s fun l H => congr_arg coe <| map_pmap g f l H\n#align map_pmap map_pmap\n\n",
 "map_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print map_nsmul /-\ntheorem map_nsmul (f : α → β) (n : ℕ) (s) : map f («expr • » n s) = «expr • » n (map f s) :=\n  (mapAddMonoidHom f).map_nsmul _ _\n#align map_nsmul map_nsmul\n-/\n\n",
 "map_mono":
 "theorem map_mono (f : α → β) : monotone (map f) := fun _ _ => map_le_map\n#align map_mono map_mono\n\n",
 "map_mk_eq_map_mk_of_rel":
 "theorem map_mk_eq_map_mk_of_rel {r : α → α → Prop} {s t : Multiset α} (hst : s.rel r t) :\n    s.map (Quot.mk r) = t.map (Quot.mk r) :=\n  rel.rec_on hst rfl fun a b s t hab hst ih => by simp [ih, quot.sound hab]\n#align map_mk_eq_map_mk_of_rel map_mk_eq_map_mk_of_rel\n\n",
 "map_map":
 "@[simp]\ntheorem map_map (g : β → γ) (f : α → β) (s : Multiset α) : map g (map f s) = map (g ∘ f) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| list.map_map _ _ _\n#align map_map map_map\n\n",
 "map_lt_map":
 "@[simp]\ntheorem map_lt_map {f : α → β} {s t : Multiset α} (h : s < t) : s.map f < t.map f :=\n  by\n  refine' (map_le_map h.le).lt_of_not_le fun H => h.ne <| eq_of_le_of_card_le h.le _\n  rw [← s.card_map f, ← t.card_map f]\n  exact card_le_of_le H\n#align map_lt_map map_lt_map\n\n",
 "map_le_map_iff":
 "@[simp]\ntheorem map_le_map_iff {f : α → β} (hf : function.injective f) {s t : Multiset α} : s.map f ≤ t.map f ↔ s ≤ t := by\n  classical\n    refine' ⟨fun h => le_iff_count.mpr fun a => _, map_le_map⟩\n    simpa [count_map_eq_count' f _ hf] using le_iff_count.mp h (f a)\n#align map_le_map_iff map_le_map_iff\n\n",
 "map_le_map":
 "@[simp]\ntheorem map_le_map {f : α → β} {s t : Multiset α} (h : s ≤ t) : map f s ≤ map f t :=\n  leInductionOn h fun l₁ l₂ h => (h.map f).subperm\n#align map_le_map map_le_map\n\n",
 "map_injective":
 "theorem map_injective {f : α → β} (hf : function.injective f) : function.injective (Multiset.map f) := fun x y =>\n  (map_eq_map hf).1\n#align map_injective map_injective\n\n",
 "map_id'":
 "@[simp]\ntheorem map_id' (s : Multiset α) : map (fun x => x) s = s :=\n  map_id s\n#align map_id' map_id'\n\n",
 "map_id":
 "theorem map_id (s : Multiset α) : map id s = s :=\n  Quot.inductionOn s fun l => congr_arg coe <| map_id _\n#align map_id map_id\n\n",
 "map_hcongr":
 "theorem map_hcongr {β' : Type _} {m : Multiset α} {f : α → β} {f' : α → β'} (h : β = β')\n    (hf : ∀ a ∈ m, HEq (f a) (f' a)) : HEq (map f m) (map f' m) := by subst h; simp at hf; simp [map_congr rfl hf]\n#align map_hcongr map_hcongr\n\n",
 "map_filter_map_of_inv":
 "theorem map_filter_map_of_inv (f : α → option β) (g : β → α) (H : ∀ x : α, (f x).map g = some x) (s : Multiset α) :\n    map g (filterMap f s) = s :=\n  Quot.inductionOn s fun l => congr_arg coe <| map_filterMap_of_inv f g H l\n#align map_filter_map_of_inv map_filter_map_of_inv\n\n",
 "map_filter_map":
 "theorem map_filter_map (f : α → option β) (g : β → γ) (s : Multiset α) :\n    map g (filterMap f s) = filterMap (fun x => (f x).map g) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| map_filterMap f g l\n#align map_filter_map map_filter_map\n\n",
 "map_filter":
 "theorem map_filter (f : β → α) (s : Multiset β) : filter p (map f s) = map f (filter (p ∘ f) s) :=\n  Quot.inductionOn s fun l => by simp [map_filter]\n#align map_filter map_filter\n\n",
 "map_erase":
 "theorem map_erase [decidable_eq α] [decidable_eq β] (f : α → β) (hf : function.injective f) (x : α) (s : Multiset α) :\n    (s.erase x).map f = (s.map f).erase (f x) :=\n  by\n  induction' s using Multiset.induction_on with y s ih\n  · simp\n  by_cases hxy : y = x\n  · cases hxy\n    simp\n  · rw [s.erase_cons_tail hxy, map_cons, map_cons, (s.map f).erase_cons_tail (hf.ne hxy), ih]\n#align map_erase map_erase\n\n",
 "map_eq_zero":
 "#print map_eq_zero /-\n@[simp]\ntheorem map_eq_zero {s : Multiset α} {f : α → β} : s.map f = 0 ↔ s = 0 := by\n  rw [← Multiset.card_eq_zero, Multiset.card_map, Multiset.card_eq_zero]\n#align map_eq_zero map_eq_zero\n-/\n\n",
 "map_eq_singleton":
 "theorem map_eq_singleton {f : α → β} {s : Multiset α} {b : β} : map f s = {b} ↔ ∃ a : α, s = {a} ∧ f a = b :=\n  by\n  constructor\n  · intro h\n    obtain ⟨a, ha⟩ : ∃ a, s = {a} := by rw [← card_eq_one, ← card_map, h, card_singleton]\n    refine' ⟨a, ha, _⟩\n    rw [← mem_singleton, ← h, ha, map_singleton, mem_singleton]\n  · rintro ⟨a, rfl, rfl⟩\n    simp\n#align map_eq_singleton map_eq_singleton\n\n",
 "map_eq_map":
 "theorem map_eq_map {f : α → β} (hf : function.injective f) {s t : Multiset α} : s.map f = t.map f ↔ s = t :=\n  by\n  rw [← rel_eq, ← rel_eq, rel_map]\n  simp only [hf.eq_iff]\n#align map_eq_map map_eq_map\n\n",
 "map_eq_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem map_eq_cons [decidable_eq α] (f : α → β) (s : Multiset α) (t : Multiset β) (b : β) :\n    (∃ a ∈ s, f a = b ∧ (s.erase a).map f = t) ↔ s.map f = «expr ::ₘ » b t :=\n  by\n  constructor\n  · rintro ⟨a, ha, rfl, rfl⟩\n    rw [← map_cons, Multiset.cons_erase ha]\n  · intro h\n    have : b ∈ s.map f := by\n      rw [h]\n      exact mem_cons_self _ _\n    obtain ⟨a, h1, rfl⟩ := mem_map.mp this\n    obtain ⟨u, rfl⟩ := exists_cons_of_mem h1\n    rw [map_cons, cons_inj_right] at h\n    refine' ⟨a, mem_cons_self _ _, rfl, _⟩\n    rw [Multiset.erase_cons_head, h]\n#align map_eq_cons map_eq_cons\n\n",
 "map_count_true_eq_filter_card":
 "/-- Mapping a multiset through a predicate and counting the `true`s yields the cardinality of the set\nfiltered by the predicate. Note that this uses the notion of a multiset of `Prop`s - due to the\ndecidability requirements of `count`, the decidability instance on the LHS is different from the\nRHS. In particular, the decidability instance on the left leaks `classical.dec_eq`.\nSee [here](https://github.com/leanprover-community/mathlib/pull/11306#discussion_r782286812)\nfor more discussion.\n-/\n@[simp]\ntheorem map_count_true_eq_filter_card (s : Multiset α) (p : α → Prop) [decidable_pred p] :\n    (s.map p).count true = (s.filter p).card := by\n  simp only [count_eq_card_filter_eq, map_filter, card_map, function.comp.left_id, eq_true_eq_id]\n#align map_count_true_eq_filter_card map_count_true_eq_filter_card\n\n",
 "map_const'":
 "-- Not a `simp` lemma because `function.const` is reducibel in Lean 3\ntheorem map_const' (s : Multiset α) (b : β) : map (fun _ => b) s = replicate s.card b :=\n  map_const s b\n#align map_const' map_const'\n\n",
 "map_const":
 "@[simp]\ntheorem map_const (s : Multiset α) (b : β) : map (function.const α b) s = replicate s.card b :=\n  Quot.inductionOn s fun l => congr_arg coe <| map_const _ _\n#align map_const map_const\n\n",
 "map_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem map_cons (f : α → β) (a s) : map f («expr ::ₘ » a s) = «expr ::ₘ » (f a) (map f s) :=\n  Quot.inductionOn s fun l => rfl\n#align map_cons map_cons\n\n",
 "map_congr":
 "#print map_congr /-\n@[congr]\ntheorem map_congr {f g : α → β} {s t : Multiset α} : s = t → (∀ x ∈ t, f x = g x) → map f s = map g t :=\n  by\n  rintro rfl h\n  induction s using Quot.inductionOn\n  exact congr_arg coe (map_congr h)\n#align map_congr map_congr\n-/\n\n",
 "map_comp_cons":
 "theorem map_comp_cons (f : α → β) (t) : map f ∘ cons t = cons (f t) ∘ map f :=\n  by\n  ext\n  simp\n#align map_comp_cons map_comp_cons\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\ntheorem map_add (f : α → β) (s t) : map f (s + t) = map f s + map f t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => congr_arg coe <| map_append _ _ _\n#align map_add map_add\n-/\n\n",
 "lt_replicate_succ":
 "theorem lt_replicate_succ {m : Multiset α} {x : α} {n : ℕ} : m < replicate (n + 1) x ↔ m ≤ replicate n x :=\n  by\n  rw [lt_iff_cons_le]\n  constructor\n  · rintro ⟨x', hx'⟩\n    have := eq_of_mem_replicate (mem_of_le hx' (mem_cons_self _ _))\n    rwa [this, replicate_succ, cons_le_cons_iff] at hx'\n  · intro h\n    rw [replicate_succ]\n    exact ⟨x, cons_le_cons _ h⟩\n#align lt_replicate_succ lt_replicate_succ\n\n",
 "lt_iff_cons_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem lt_iff_cons_le {s t : Multiset α} : s < t ↔ ∃ a, «expr ::ₘ » a s ≤ t :=\n  ⟨quotient.induction_on₂ s t fun l₁ l₂ h => Subperm.exists_of_length_lt (le_of_lt h) (card_lt_of_lt h), fun ⟨a, h⟩ =>\n    lt_of_lt_of_le (lt_cons_self _ _) h⟩\n#align lt_iff_cons_le lt_iff_cons_le\n\n",
 "lt_cons_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem lt_cons_self (s : Multiset α) (a : α) : s < «expr ::ₘ » a s :=\n  Quot.inductionOn s fun l =>\n    suffices «expr <+~ » l (a :: l) ∧ ¬list.perm l (a :: l) by simpa [lt_iff_le_and_ne]\n    ⟨(sublist_cons _ _).subperm, fun p => ne_of_lt (lt_succ_self (length l)) p.length_eq⟩\n#align lt_cons_self lt_cons_self\n\n",
 "length_to_list":
 "@[simp]\ntheorem length_to_list (s : Multiset α) : s.to_list.length = s.card := by rw [← coe_card, coe_to_list]\n#align length_to_list length_to_list\n\n",
 "le_zero":
 "theorem le_zero : s ≤ 0 ↔ s = 0 :=\n  le_bot_iff\n#align le_zero le_zero\n\n",
 "le_union_right":
 "theorem le_union_right (s t : Multiset α) : t ≤ s ∪ t :=\n  le_add_left _ _\n#align le_union_right le_union_right\n\n",
 "le_union_left":
 "theorem le_union_left (s t : Multiset α) : s ≤ s ∪ t :=\n  le_tsub_add\n#align le_union_left le_union_left\n\n",
 "le_replicate_iff":
 "theorem le_replicate_iff {m : Multiset α} {a : α} {n : ℕ} : m ≤ replicate n a ↔ ∃ k ≤ n, m = replicate k a :=\n  ⟨fun h =>\n    ⟨m.card, (card_mono h).trans_eq (card_replicate _ _),\n      eq_replicate_card.2 fun b hb => eq_of_mem_replicate <| subset_of_le h hb⟩,\n    fun ⟨k, hkn, hm⟩ => hm.symm ▸ (replicate_le_replicate _).2 hkn⟩\n#align le_replicate_iff le_replicate_iff\n\n",
 "le_inter_iff":
 "@[simp]\ntheorem le_inter_iff : s ≤ t ∩ u ↔ s ≤ t ∧ s ≤ u :=\n  le_inf_iff\n#align le_inter_iff le_inter_iff\n\n",
 "le_inter":
 "theorem le_inter (h₁ : s ≤ t) (h₂ : s ≤ u) : s ≤ t ∩ u :=\n  by\n  revert s u; refine' Multiset.induction_on t _ fun a t IH => _ <;> intros\n  · simp [h₁]\n  by_cases a ∈ u\n  · rw [cons_inter_of_pos _ h, ← erase_le_iff_le_cons]\n    exact IH (erase_le_iff_le_cons.2 h₁) (erase_le_erase _ h₂)\n  · rw [cons_inter_of_neg _ h]\n    exact IH ((le_cons_of_not_mem <| mt (mem_of_le h₂) h).1 h₁) h₂\n#align le_inter le_inter\n\n",
 "le_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+ » -/\n@[elab_as_elim]\ntheorem le_induction_on {C : Multiset α → Multiset α → Prop} {s t : Multiset α} (h : s ≤ t)\n    (H : ∀ {l₁ l₂ : list α}, «expr <+ » l₁ l₂ → C l₁ l₂) : C s t :=\n  quotient.induction_on₂ s t (fun l₁ l₂ ⟨l, p, s⟩ => (show «expr⟦ ⟧» l = «expr⟦ ⟧» l₁ from quot.sound p) ▸ H s) h\n#align le_induction_on le_induction_on\n\n",
 "le_iff_exists_add":
 "#print le_iff_exists_add /-\ntheorem le_iff_exists_add {s t : Multiset α} : s ≤ t ↔ ∃ u, t = s + u :=\n  ⟨fun h =>\n    leInductionOn h fun l₁ l₂ s =>\n      let ⟨l, p⟩ := s.exists_perm_append\n      ⟨l, quot.sound p⟩,\n    fun ⟨u, e⟩ => e.symm ▸ le_add_right _ _⟩\n#align le_iff_exists_add le_iff_exists_add\n-/\n\n",
 "le_iff_count":
 "theorem le_iff_count {s t : Multiset α} : s ≤ t ↔ ∀ a, count a s ≤ count a t :=\n  ⟨fun h a => count_le_of_le a h, fun al => by\n    rw [← (ext.2 fun a => by simp [max_eq_right (al a)] : s ∪ t = t)] <;> apply le_union_left⟩\n#align le_iff_count le_iff_count\n\n",
 "le_filter":
 "theorem le_filter {s t} : s ≤ filter p t ↔ s ≤ t ∧ ∀ a ∈ s, p a :=\n  ⟨fun h => ⟨le_trans h (filter_le _ _), fun a m => of_mem_filter (mem_of_le h m)⟩, fun ⟨h, al⟩ =>\n    filter_eq_self.2 al ▸ filter_le_filter p h⟩\n#align le_filter le_filter\n\n",
 "le_count_iff_replicate_le":
 "theorem le_count_iff_replicate_le {a : α} {s : Multiset α} {n : ℕ} : n ≤ count a s ↔ replicate n a ≤ s :=\n  Quot.inductionOn s fun l => le_count_iff_replicate_sublist.trans replicate_le_coe.symm\n#align le_count_iff_replicate_le le_count_iff_replicate_le\n\n",
 "le_cons_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem le_cons_self (s : Multiset α) (a : α) : s ≤ «expr ::ₘ » a s :=\n  le_of_lt <| lt_cons_self _ _\n#align le_cons_self le_cons_self\n\n",
 "le_cons_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem le_cons_of_not_mem (m : a ∉ s) : s ≤ «expr ::ₘ » a t ↔ s ≤ t :=\n  by\n  refine' ⟨_, fun h => le_trans h <| le_cons_self _ _⟩\n  suffices ∀ {t'} (_ : s ≤ t') (_ : a ∈ t'), «expr ::ₘ » a s ≤ t' by\n    exact fun h => (cons_le_cons_iff a).1 (this h (mem_cons_self _ _))\n  introv h\n  revert m\n  refine' le_induction_on h _\n  introv s m₁ m₂\n  rcases mem_split m₂ with ⟨r₁, r₂, rfl⟩\n  exact perm_middle.subperm_left.2 ((subperm_cons _).2 <| ((sublist_or_mem_of_sublist s).resolve_right m₁).subperm)\n#align le_cons_of_not_mem le_cons_of_not_mem\n\n",
 "le_cons_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem le_cons_erase (s : Multiset α) (a : α) : s ≤ «expr ::ₘ » a (s.erase a) :=\n  if h : a ∈ s then le_of_eq (cons_erase h).symm else by rw [erase_of_not_mem h] <;> apply le_cons_self\n#align le_cons_erase le_cons_erase\n\n",
 "le_add_right":
 "#print le_add_right /-\ntheorem le_add_right (s t : Multiset α) : s ≤ s + t := by simpa using add_le_add_left (zero_le t) s\n#align le_add_right le_add_right\n-/\n\n",
 "le_add_left":
 "#print le_add_left /-\ntheorem le_add_left (s t : Multiset α) : s ≤ t + s := by simpa using add_le_add_right (zero_le t) s\n#align le_add_left le_add_left\n-/\n\n",
 "inter_zero":
 "@[simp]\ntheorem inter_zero (s : Multiset α) : s ∩ 0 = 0 :=\n  Quot.inductionOn s fun l => congr_arg coe l.bag_inter_nil\n#align inter_zero inter_zero\n\n",
 "inter_replicate":
 "@[simp]\ntheorem inter_replicate (s : Multiset α) (x : α) (n : ℕ) : s ∩ replicate n x = replicate (min (s.count x) n) x := by\n  rw [inter_comm, replicate_inter, min_comm]\n#align inter_replicate inter_replicate\n\n",
 "inter_le_right":
 "theorem inter_le_right (s : Multiset α) : ∀ t, s ∩ t ≤ t :=\n  Multiset.induction_on s (fun t => (zero_inter t).symm ▸ zero_le _) fun a s IH t =>\n    if h : a ∈ t then by simpa [h] using cons_le_cons a (IH (t.erase a)) else by simp [h, IH]\n#align inter_le_right inter_le_right\n\n",
 "inter_le_left":
 "theorem inter_le_left (s t : Multiset α) : s ∩ t ≤ s :=\n  quotient.induction_on₂ s t fun l₁ l₂ => (bagInter_sublist_left _ _).subperm\n#align inter_le_left inter_le_left\n\n",
 "inter_eq_zero_iff_disjoint":
 "theorem inter_eq_zero_iff_disjoint [decidable_eq α] {s t : Multiset α} : s ∩ t = 0 ↔ Disjoint s t := by\n  rw [← subset_zero] <;> simp [subset_iff, Disjoint]\n#align inter_eq_zero_iff_disjoint inter_eq_zero_iff_disjoint\n\n",
 "inter_comm":
 "theorem inter_comm (s t : Multiset α) : s ∩ t = t ∩ s :=\n  inf_comm\n#align inter_comm inter_comm\n\n",
 "inter_add_distrib":
 "theorem inter_add_distrib (s t u : Multiset α) : s ∩ t + u = (s + u) ∩ (t + u) :=\n  by\n  by_contra h\n  cases'\n    lt_iff_cons_le.1\n      (lt_of_le_of_ne (le_inter (add_le_add_right (inter_le_left s t) u) (add_le_add_right (inter_le_right s t) u))\n        h) with\n    a hl\n  rw [← cons_add] at hl\n  exact\n    not_le_of_lt (lt_cons_self (s ∩ t) a)\n      (le_inter (le_of_add_le_add_right (le_trans hl (inter_le_left _ _)))\n        (le_of_add_le_add_right (le_trans hl (inter_le_right _ _))))\n#align inter_add_distrib inter_add_distrib\n\n",
 "insert_eq_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem insert_eq_cons (a : α) (s : Multiset α) : insert a s = «expr ::ₘ » a s :=\n  rfl\n#align insert_eq_cons insert_eq_cons\n\n",
 "inf_eq_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_eq_inter (s t : Multiset α) : «expr ⊓ » s t = s ∩ t :=\n  rfl\n#align inf_eq_inter inf_eq_inter\n\n",
 "induction_on_multiset_quot":
 "theorem induction_on_multiset_quot {r : α → α → Prop} {p : Multiset (Quot r) → Prop} (s : Multiset (Quot r)) :\n    (∀ s : Multiset α, p (s.map (Quot.mk r))) → p s :=\n  match s, exists_multiset_eq_map_quot_mk s with\n  | _, ⟨t, rfl⟩ => fun h => h _\n#align induction_on_multiset_quot induction_on_multiset_quot\n\n",
 "induction_on'":
 "theorem induction_on' {p : Multiset α → Prop} (S : Multiset α) (h₁ : p 0)\n    (h₂ : ∀ {a s}, a ∈ S → s ⊆ S → p s → p (insert a s)) : p S :=\n  @Multiset.induction_on α (fun T => T ⊆ S → p T) S (fun _ => h₁)\n    (fun a s hps hs =>\n      let ⟨hS, sS⟩ := cons_subset.1 hs\n      h₂ hS sS (hps sS))\n    (Subset.refl S)\n#align induction_on' induction_on'\n\n",
 "induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[elab_as_elim]\nprotected theorem induction_on {p : Multiset α → Prop} (s : Multiset α) (h₁ : p 0)\n    (h₂ : ∀ ⦃a : α⦄ {s : Multiset α}, p s → p («expr ::ₘ » a s)) : p s :=\n  Multiset.induction h₁ h₂ s\n#align induction_on induction_on\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[recursor 5]\nprotected theorem induction {p : Multiset α → Prop} (h₁ : p 0)\n    (h₂ : ∀ ⦃a : α⦄ {s : Multiset α}, p s → p («expr ::ₘ » a s)) : ∀ s, p s := by\n  rintro ⟨l⟩ <;> induction' l with _ _ ih <;> [exact h₁, exact h₂ ih]\n#align induction induction\n\n",
 "forall_mem_map_iff":
 "theorem forall_mem_map_iff {f : α → β} {p : β → Prop} {s : Multiset α} : (∀ y ∈ s.map f, p y) ↔ ∀ x ∈ s, p (f x) :=\n  Quotient.inductionOn' s fun L => List.forall_mem_map_iff\n#align forall_mem_map_iff forall_mem_map_iff\n\n",
 "forall_mem_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem forall_mem_cons {p : α → Prop} {a : α} {s : Multiset α} : (∀ x ∈ «expr ::ₘ » a s, p x) ↔ p a ∧ ∀ x ∈ s, p x :=\n  Quotient.inductionOn' s fun L => List.forall_mem_cons\n#align forall_mem_cons forall_mem_cons\n\n",
 "foldr_zero":
 "@[simp]\ntheorem foldr_zero (f : α → β → β) (H b) : foldr f H b 0 = b :=\n  rfl\n#align foldr_zero foldr_zero\n\n",
 "foldr_swap":
 "theorem foldr_swap (f : α → β → β) (H : left_commutative f) (b : β) (s : Multiset α) :\n    foldr f H b s = foldl (fun x y => f y x) (fun x y z => (H _ _ _).symm) b s :=\n  Quot.inductionOn s fun l => coe_foldr_swap _ _ _ _\n#align foldr_swap foldr_swap\n\n",
 "foldr_singleton":
 "@[simp]\ntheorem foldr_singleton (f : α → β → β) (H b a) : foldr f H b ({a} : Multiset α) = f a b :=\n  rfl\n#align foldr_singleton foldr_singleton\n\n",
 "foldr_induction'":
 "theorem foldr_induction' (f : α → β → β) (H : left_commutative f) (x : β) (q : α → Prop) (p : β → Prop) (s : Multiset α)\n    (hpqf : ∀ a b, q a → p b → p (f a b)) (px : p x) (q_s : ∀ a ∈ s, q a) : p (foldr f H x s) :=\n  by\n  revert s\n  refine' Multiset.induction (by simp [px]) _\n  intro a s hs hsa\n  rw [foldr_cons]\n  have hps : ∀ x : α, x ∈ s → q x := fun x hxs => hsa x (mem_cons_of_mem hxs)\n  exact hpqf a (foldr f H x s) (hsa a (mem_cons_self a s)) (hs hps)\n#align foldr_induction' foldr_induction'\n\n",
 "foldr_induction":
 "theorem foldr_induction (f : α → α → α) (H : left_commutative f) (x : α) (p : α → Prop) (s : Multiset α)\n    (p_f : ∀ a b, p a → p b → p (f a b)) (px : p x) (p_s : ∀ a ∈ s, p a) : p (foldr f H x s) :=\n  foldr_induction' f H x p p s p_f px p_s\n#align foldr_induction foldr_induction\n\n",
 "foldr_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem foldr_cons (f : α → β → β) (H b a s) : foldr f H b («expr ::ₘ » a s) = f a (foldr f H b s) :=\n  Quot.inductionOn s fun l => rfl\n#align foldr_cons foldr_cons\n\n",
 "foldr_add":
 "@[simp]\ntheorem foldr_add (f : α → β → β) (H b s t) : foldr f H b (s + t) = foldr f H (foldr f H b t) s :=\n  quotient.induction_on₂ s t fun l₁ l₂ => foldr_append _ _ _ _\n#align foldr_add foldr_add\n\n",
 "foldl_zero":
 "@[simp]\ntheorem foldl_zero (f : β → α → β) (H b) : foldl f H b 0 = b :=\n  rfl\n#align foldl_zero foldl_zero\n\n",
 "foldl_swap":
 "theorem foldl_swap (f : β → α → β) (H : right_commutative f) (b : β) (s : Multiset α) :\n    foldl f H b s = foldr (fun x y => f y x) (fun x y z => (H _ _ _).symm) b s :=\n  (foldr_swap _ _ _ _).symm\n#align foldl_swap foldl_swap\n\n",
 "foldl_induction'":
 "theorem foldl_induction' (f : β → α → β) (H : right_commutative f) (x : β) (q : α → Prop) (p : β → Prop)\n    (s : Multiset α) (hpqf : ∀ a b, q a → p b → p (f b a)) (px : p x) (q_s : ∀ a ∈ s, q a) : p (foldl f H x s) :=\n  by\n  rw [foldl_swap]\n  exact foldr_induction' (fun x y => f y x) (fun x y z => (H _ _ _).symm) x q p s hpqf px q_s\n#align foldl_induction' foldl_induction'\n\n",
 "foldl_induction":
 "theorem foldl_induction (f : α → α → α) (H : right_commutative f) (x : α) (p : α → Prop) (s : Multiset α)\n    (p_f : ∀ a b, p a → p b → p (f b a)) (px : p x) (p_s : ∀ a ∈ s, p a) : p (foldl f H x s) :=\n  foldl_induction' f H x p p s p_f px p_s\n#align foldl_induction foldl_induction\n\n",
 "foldl_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem foldl_cons (f : β → α → β) (H b a s) : foldl f H b («expr ::ₘ » a s) = foldl f H (f b a) s :=\n  Quot.inductionOn s fun l => rfl\n#align foldl_cons foldl_cons\n\n",
 "foldl_add":
 "@[simp]\ntheorem foldl_add (f : β → α → β) (H b s t) : foldl f H b (s + t) = foldl f H (foldl f H b s) t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => foldl_append _ _ _ _\n#align foldl_add foldl_add\n\n",
 "filter_zero":
 "@[simp]\ntheorem filter_zero : filter p 0 = 0 :=\n  rfl\n#align filter_zero filter_zero\n\n",
 "filter_union":
 "@[simp]\ntheorem filter_union [decidable_eq α] (s t : Multiset α) : filter p (s ∪ t) = filter p s ∪ filter p t := by\n  simp [(· ∪ ·), union]\n#align filter_union filter_union\n\n",
 "filter_subset":
 "@[simp]\ntheorem filter_subset (s : Multiset α) : filter p s ⊆ s :=\n  subset_of_le <| filter_le _ _\n#align filter_subset filter_subset\n\n",
 "filter_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem filter_sub [decidable_eq α] (s t : Multiset α) : filter p (s - t) = filter p s - filter p t :=\n  by\n  revert s; refine' Multiset.induction_on t (by simp) fun a t IH s => _\n  rw [sub_cons, IH]\n  by_cases p a\n  · rw [filter_cons_of_pos _ h, sub_cons]\n    congr\n    by_cases m : a ∈ s\n    · rw [← cons_inj_right a, ← filter_cons_of_pos _ h, cons_erase (mem_filter_of_mem m h), cons_erase m]\n    · rw [erase_of_not_mem m, erase_of_not_mem (mt mem_of_mem_filter m)]\n  · rw [filter_cons_of_neg _ h]\n    by_cases m : a ∈ s\n    · rw [(by rw [filter_cons_of_neg _ h] : filter p (erase s a) = filter p («expr ::ₘ » a (erase s a))), cons_erase m]\n    · rw [erase_of_not_mem m]\n#align filter_sub filter_sub\n\n",
 "filter_singleton":
 "theorem filter_singleton {a : α} (p : α → Prop) [decidable_pred p] : filter p {a} = if p a then {a} else ∅ := by\n  simp only [singleton, filter_cons, filter_zero, add_zero, empty_eq_zero]\n#align filter_singleton filter_singleton\n\n",
 "filter_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem filter_nsmul (s : Multiset α) (n : ℕ) : filter p («expr • » n s) = «expr • » n (filter p s) :=\n  by\n  refine' s.induction_on _ _\n  · simp only [filter_zero, nsmul_zero]\n  · intro a ha ih\n    rw [nsmul_cons, filter_add, ih, filter_cons, nsmul_add]\n    congr\n    split_ifs with hp <;>\n      · simp only [filter_eq_self, nsmul_zero, filter_eq_nil]\n        intro b hb\n        rwa [mem_singleton.mp (mem_of_mem_nsmul hb)]\n#align filter_nsmul filter_nsmul\n\n",
 "filter_map_zero":
 "@[simp]\ntheorem filter_map_zero (f : α → option β) : filterMap f 0 = 0 :=\n  rfl\n#align filter_map_zero filter_map_zero\n\n",
 "filter_map_some":
 "@[simp]\ntheorem filter_map_some (s : Multiset α) : filterMap some s = s :=\n  Quot.inductionOn s fun l => congr_arg coe <| filterMap_some l\n#align filter_map_some filter_map_some\n\n",
 "filter_map_map":
 "theorem filter_map_map (f : α → β) (g : β → option γ) (s : Multiset α) : filterMap g (map f s) = filterMap (g ∘ f) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| filterMap_map f g l\n#align filter_map_map filter_map_map\n\n",
 "filter_map_le_filter_map":
 "theorem filter_map_le_filter_map (f : α → option β) {s t : Multiset α} (h : s ≤ t) : filterMap f s ≤ filterMap f t :=\n  leInductionOn h fun l₁ l₂ h => (h.filter_map _).subperm\n#align filter_map_le_filter_map filter_map_le_filter_map\n\n",
 "filter_map_filter_map":
 "theorem filter_map_filter_map (f : α → option β) (g : β → option γ) (s : Multiset α) :\n    filterMap g (filterMap f s) = filterMap (fun x => (f x).bind g) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| filterMap_filterMap f g l\n#align filter_map_filter_map filter_map_filter_map\n\n",
 "filter_map_filter":
 "theorem filter_map_filter (f : α → option β) (s : Multiset α) :\n    filterMap f (filter p s) = filterMap (fun x => if p x then f x else none) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| filterMap_filter p f l\n#align filter_map_filter filter_map_filter\n\n",
 "filter_map_eq_map":
 "theorem filter_map_eq_map (f : α → β) : filterMap (some ∘ f) = map f :=\n  funext fun s => Quot.inductionOn s fun l => @congr_arg _ _ _ _ coe <| congr_fun (filterMap_eq_map f) l\n#align filter_map_eq_map filter_map_eq_map\n\n",
 "filter_map_eq_filter":
 "theorem filter_map_eq_filter : filterMap (option.guard p) = filter p :=\n  funext fun s => Quot.inductionOn s fun l => @congr_arg _ _ _ _ coe <| congr_fun (filterMap_eq_filter p) l\n#align filter_map_eq_filter filter_map_eq_filter\n\n",
 "filter_map_cons_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem filter_map_cons_some (f : α → option β) (a : α) (s : Multiset α) {b : β} (h : f a = some b) :\n    filterMap f («expr ::ₘ » a s) = «expr ::ₘ » b (filterMap f s) :=\n  Quot.inductionOn s fun l => @congr_arg _ _ _ _ coe <| filterMap_cons_some f a l h\n#align filter_map_cons_some filter_map_cons_some\n\n",
 "filter_map_cons_none":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem filter_map_cons_none {f : α → option β} (a : α) (s : Multiset α) (h : f a = none) :\n    filterMap f («expr ::ₘ » a s) = filterMap f s :=\n  Quot.inductionOn s fun l => @congr_arg _ _ _ _ coe <| filterMap_cons_none a l h\n#align filter_map_cons_none filter_map_cons_none\n\n",
 "filter_le_filter":
 "theorem filter_le_filter {s t} (h : s ≤ t) : filter p s ≤ filter p t :=\n  leInductionOn h fun l₁ l₂ h => (h.filter p).subperm\n#align filter_le_filter filter_le_filter\n\n",
 "filter_le":
 "@[simp]\ntheorem filter_le (s : Multiset α) : filter p s ≤ s :=\n  Quot.inductionOn s fun l => (filter_sublist _).subperm\n#align filter_le filter_le\n\n",
 "filter_inter":
 "@[simp]\ntheorem filter_inter [decidable_eq α] (s t : Multiset α) : filter p (s ∩ t) = filter p s ∩ filter p t :=\n  le_antisymm (le_inter (filter_le_filter _ <| inter_le_left _ _) (filter_le_filter _ <| inter_le_right _ _)) <|\n    le_filter.2 ⟨inf_le_inf (filter_le _ _) (filter_le _ _), fun a h => of_mem_filter (mem_of_le (inter_le_left _ _) h)⟩\n#align filter_inter filter_inter\n\n",
 "filter_filter_map":
 "theorem filter_filter_map (f : α → option β) (p : β → Prop) [decidable_pred p] (s : Multiset α) :\n    filter p (filterMap f s) = filterMap (fun x => (f x).filter p) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| filter_filterMap f p l\n#align filter_filter_map filter_filter_map\n\n",
 "filter_filter":
 "@[simp]\ntheorem filter_filter (q) [decidable_pred q] (s : Multiset α) : filter p (filter q s) = filter (fun a => p a ∧ q a) s :=\n  Quot.inductionOn s fun l => congr_arg coe <| filter_filter p q l\n#align filter_filter filter_filter\n\n",
 "filter_eq_self":
 "theorem filter_eq_self {s} : filter p s = s ↔ ∀ a ∈ s, p a :=\n  Quot.inductionOn s fun l =>\n    iff.trans ⟨fun h => (filter_sublist _).eq_of_length (@congr_arg _ _ _ _ card h), congr_arg coe⟩ filter_eq_self\n#align filter_eq_self filter_eq_self\n\n",
 "filter_eq_nil":
 "theorem filter_eq_nil {s} : filter p s = 0 ↔ ∀ a ∈ s, ¬p a :=\n  Quot.inductionOn s fun l =>\n    iff.trans ⟨fun h => eq_nil_of_length_eq_zero (@congr_arg _ _ _ _ card h), congr_arg coe⟩ filter_eq_nil\n#align filter_eq_nil filter_eq_nil\n\n",
 "filter_eq'":
 "theorem filter_eq' (s : Multiset α) (b : α) : s.filter (· = b) = replicate (count b s) b :=\n  Quotient.inductionOn s fun l => congr_arg coe <| filter_eq' l b\n#align filter_eq' filter_eq'\n\n",
 "filter_eq":
 "theorem filter_eq (s : Multiset α) (b : α) : s.filter (eq b) = replicate (count b s) b := by\n  simp_rw [← filter_eq', eq_comm]\n#align filter_eq filter_eq\n\n",
 "filter_cons_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem filter_cons_of_pos {a : α} (s) : p a → filter p («expr ::ₘ » a s) = «expr ::ₘ » a (filter p s) :=\n  Quot.inductionOn s fun l h => congr_arg coe <| filter_cons_of_pos l h\n#align filter_cons_of_pos filter_cons_of_pos\n\n",
 "filter_cons_of_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem filter_cons_of_neg {a : α} (s) : ¬p a → filter p («expr ::ₘ » a s) = filter p s :=\n  Quot.inductionOn s fun l h => @congr_arg _ _ _ _ coe <| filter_cons_of_neg l h\n#align filter_cons_of_neg filter_cons_of_neg\n\n",
 "filter_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem filter_cons {a : α} (s : Multiset α) : filter p («expr ::ₘ » a s) = (if p a then {a} else 0) + filter p s :=\n  by\n  split_ifs with h\n  · rw [filter_cons_of_pos _ h, singleton_add]\n  · rw [filter_cons_of_neg _ h, zero_add]\n#align filter_cons filter_cons\n\n",
 "filter_congr":
 "theorem filter_congr {p q : α → Prop} [decidable_pred p] [decidable_pred q] {s : Multiset α} :\n    (∀ x ∈ s, p x ↔ q x) → filter p s = filter q s :=\n  Quot.inductionOn s fun l h => congr_arg coe <| filter_congr' h\n#align filter_congr filter_congr\n\n",
 "filter_add_not":
 "theorem filter_add_not (s : Multiset α) : filter p s + filter (fun a => ¬p a) s = s := by\n  rw [filter_add_filter, filter_eq_self.2, filter_eq_nil.2] <;> simp [decidable.em]\n#align filter_add_not filter_add_not\n\n",
 "filter_add_filter":
 "theorem filter_add_filter (q) [decidable_pred q] (s : Multiset α) :\n    filter p s + filter q s = filter (fun a => p a ∨ q a) s + filter (fun a => p a ∧ q a) s :=\n  Multiset.induction_on s rfl fun a s IH => by by_cases p a <;> by_cases q a <;> simp [*]\n#align filter_add_filter filter_add_filter\n\n",
 "filter_add":
 "@[simp]\ntheorem filter_add (s t : Multiset α) : filter p (s + t) = filter p s + filter p t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => congr_arg coe <| filter_append _ _\n#align filter_add filter_add\n\n",
 "ext'":
 "@[ext]\ntheorem ext' {s t : Multiset α} : (∀ a, count a s = count a t) → s = t :=\n  ext.2\n#align ext' ext'\n\n",
 "ext":
 "theorem ext {s t : Multiset α} : s = t ↔ ∀ a, count a s = count a t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => quotient.eq.trans perm_iff_count\n#align ext ext\n\n",
 "exists_multiset_eq_map_quot_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem exists_multiset_eq_map_quot_mk {r : α → α → Prop} (s : Multiset (Quot r)) :\n    ∃ t : Multiset α, s = t.map (Quot.mk r) :=\n  Multiset.induction_on s ⟨0, rfl⟩ fun a s ⟨t, ht⟩ =>\n    Quot.inductionOn a fun a => ht.symm ▸ ⟨«expr ::ₘ » a t, (map_cons _ _ _).symm⟩\n#align exists_multiset_eq_map_quot_mk exists_multiset_eq_map_quot_mk\n\n",
 "exists_mem_of_rel_of_mem":
 "theorem exists_mem_of_rel_of_mem {r : α → β → Prop} {s : Multiset α} {t : Multiset β} (h : Rel r s t) :\n    ∀ {a : α} (ha : a ∈ s), ∃ b ∈ t, r a b :=\n  by\n  induction' h with x y s t hxy hst ih\n  · simp\n  · intro a ha\n    cases' mem_cons.1 ha with ha ha\n    · exact ⟨y, mem_cons_self _ _, ha.symm ▸ hxy⟩\n    · rcases ih ha with ⟨b, hbt, hab⟩\n      exact ⟨b, mem_cons.2 (or.inr hbt), hab⟩\n#align exists_mem_of_rel_of_mem exists_mem_of_rel_of_mem\n\n",
 "exists_mem_of_ne_zero":
 "theorem exists_mem_of_ne_zero {s : Multiset α} : s ≠ 0 → ∃ a : α, a ∈ s :=\n  Quot.inductionOn s fun l hl =>\n    match l, hl with\n    | [] => fun h => false.elim <| h rfl\n    | a :: l => fun _ => ⟨a, by simp⟩\n#align exists_mem_of_ne_zero exists_mem_of_ne_zero\n\n",
 "exists_cons_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem exists_cons_of_mem {s : Multiset α} {a : α} : a ∈ s → ∃ t, s = «expr ::ₘ » a t :=\n  Quot.inductionOn s fun l (h : a ∈ l) =>\n    let ⟨l₁, l₂, e⟩ := mem_split h\n    e.symm ▸ ⟨(l₁ ++ l₂ : list α), quot.sound perm_middle⟩\n#align exists_cons_of_mem exists_cons_of_mem\n\n",
 "erase_zero":
 "@[simp]\ntheorem erase_zero (a : α) : (0 : Multiset α).erase a = 0 :=\n  rfl\n#align erase_zero erase_zero\n\n",
 "erase_subset":
 "theorem erase_subset (a : α) (s : Multiset α) : s.erase a ⊆ s :=\n  subset_of_le (erase_le a s)\n#align erase_subset erase_subset\n\n",
 "erase_singleton":
 "@[simp]\ntheorem erase_singleton (a : α) : ({a} : Multiset α).erase a = 0 :=\n  erase_cons_head a 0\n#align erase_singleton erase_singleton\n\n",
 "erase_of_not_mem":
 "@[simp]\ntheorem erase_of_not_mem {a : α} {s : Multiset α} : a ∉ s → s.erase a = s :=\n  Quot.inductionOn s fun l h => congr_arg coe <| erase_of_not_mem h\n#align erase_of_not_mem erase_of_not_mem\n\n",
 "erase_lt":
 "@[simp]\ntheorem erase_lt {a : α} {s : Multiset α} : s.erase a < s ↔ a ∈ s :=\n  ⟨fun h => not_imp_comm.1 erase_of_not_mem (ne_of_lt h), fun h => by simpa [h] using lt_cons_self (s.erase a) a⟩\n#align erase_lt erase_lt\n\n",
 "erase_le_iff_le_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem erase_le_iff_le_cons {s t : Multiset α} {a : α} : s.erase a ≤ t ↔ s ≤ «expr ::ₘ » a t :=\n  ⟨fun h => le_trans (le_cons_erase _ _) (cons_le_cons _ h), fun h =>\n    if m : a ∈ s then by rw [← cons_erase m] at h <;> exact (cons_le_cons_iff _).1 h\n    else le_trans (erase_le _ _) ((le_cons_of_not_mem m).1 h)⟩\n#align erase_le_iff_le_cons erase_le_iff_le_cons\n\n",
 "erase_le_erase":
 "theorem erase_le_erase {s t : Multiset α} (a : α) (h : s ≤ t) : s.erase a ≤ t.erase a :=\n  leInductionOn h fun l₁ l₂ h => (h.erase _).subperm\n#align erase_le_erase erase_le_erase\n\n",
 "erase_le":
 "theorem erase_le (a : α) (s : Multiset α) : s.erase a ≤ s :=\n  Quot.inductionOn s fun l => (erase_sublist a l).subperm\n#align erase_le erase_le\n\n",
 "erase_cons_tail":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem erase_cons_tail {a b : α} (s : Multiset α) (h : b ≠ a) :\n    («expr ::ₘ » b s).erase a = «expr ::ₘ » b (s.erase a) :=\n  Quot.inductionOn s fun l => congr_arg coe <| erase_cons_tail l h\n#align erase_cons_tail erase_cons_tail\n\n",
 "erase_cons_head":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem erase_cons_head (a : α) (s : Multiset α) : («expr ::ₘ » a s).erase a = s :=\n  Quot.inductionOn s fun l => congr_arg coe <| erase_cons_head a l\n#align erase_cons_head erase_cons_head\n\n",
 "erase_comm":
 "theorem erase_comm (s : Multiset α) (a b : α) : (s.erase a).erase b = (s.erase b).erase a :=\n  Quot.inductionOn s fun l => congr_arg coe <| l.erase_comm a b\n#align erase_comm erase_comm\n\n",
 "erase_add_right_pos":
 "theorem erase_add_right_pos {a : α} (s) {t : Multiset α} (h : a ∈ t) : (s + t).erase a = s + t.erase a := by\n  rw [add_comm, erase_add_left_pos s h, add_comm]\n#align erase_add_right_pos erase_add_right_pos\n\n",
 "erase_add_right_neg":
 "theorem erase_add_right_neg {a : α} {s : Multiset α} (t) : a ∉ s → (s + t).erase a = s + t.erase a :=\n  quotient.induction_on₂ s t fun l₁ l₂ h => congr_arg coe <| erase_append_right l₂ h\n#align erase_add_right_neg erase_add_right_neg\n\n",
 "erase_add_left_pos":
 "theorem erase_add_left_pos {a : α} {s : Multiset α} (t) : a ∈ s → (s + t).erase a = s.erase a + t :=\n  quotient.induction_on₂ s t fun l₁ l₂ h => congr_arg coe <| erase_append_left l₂ h\n#align erase_add_left_pos erase_add_left_pos\n\n",
 "erase_add_left_neg":
 "theorem erase_add_left_neg {a : α} (s) {t : Multiset α} (h : a ∉ t) : (s + t).erase a = s.erase a + t := by\n  rw [add_comm, erase_add_right_neg s h, add_comm]\n#align erase_add_left_neg erase_add_left_neg\n\n",
 "eq_zero_of_subset_zero":
 "theorem eq_zero_of_subset_zero {s : Multiset α} (h : s ⊆ 0) : s = 0 :=\n  eq_zero_of_forall_not_mem h\n#align eq_zero_of_subset_zero eq_zero_of_subset_zero\n\n",
 "eq_zero_of_forall_not_mem":
 "theorem eq_zero_of_forall_not_mem {s : Multiset α} : (∀ x, x ∉ s) → s = 0 :=\n  Quot.inductionOn s fun l H => by rw [eq_nil_iff_forall_not_mem.mpr H] <;> rfl\n#align eq_zero_of_forall_not_mem eq_zero_of_forall_not_mem\n\n",
 "eq_zero_iff_forall_not_mem":
 "theorem eq_zero_iff_forall_not_mem {s : Multiset α} : s = 0 ↔ ∀ a, a ∉ s :=\n  ⟨fun h => h.symm ▸ fun _ => not_false, eq_zero_of_forall_not_mem⟩\n#align eq_zero_iff_forall_not_mem eq_zero_iff_forall_not_mem\n\n",
 "eq_union_right":
 "theorem eq_union_right (h : s ≤ t) : s ∪ t = t := by rw [union_comm, eq_union_left h]\n#align eq_union_right eq_union_right\n\n",
 "eq_union_left":
 "theorem eq_union_left : t ≤ s → s ∪ t = s :=\n  tsub_add_cancel_of_le\n#align eq_union_left eq_union_left\n\n",
 "eq_replicate_card":
 "theorem eq_replicate_card {a : α} {s : Multiset α} : s = replicate s.card a ↔ ∀ b ∈ s, b = a :=\n  Quot.inductionOn s fun l => coe_eq_coe.trans <| perm_replicate.trans eq_replicate_length\n#align eq_replicate_card eq_replicate_card\n\n",
 "eq_replicate":
 "theorem eq_replicate {a : α} {n} {s : Multiset α} : s = replicate n a ↔ card s = n ∧ ∀ b ∈ s, b = a :=\n  ⟨fun h => h.symm ▸ ⟨card_replicate _ _, fun b => eq_of_mem_replicate⟩, fun ⟨e, al⟩ => e ▸ eq_replicate_of_mem al⟩\n#align eq_replicate eq_replicate\n\n",
 "eq_of_mem_replicate":
 "theorem eq_of_mem_replicate {a b : α} {n} : b ∈ replicate n a → b = a :=\n  eq_of_mem_replicate\n#align eq_of_mem_replicate eq_of_mem_replicate\n\n",
 "eq_of_mem_map_const":
 "theorem eq_of_mem_map_const {b₁ b₂ : β} {l : list α} (h : b₁ ∈ map (function.const α b₂) l) : b₁ = b₂ :=\n  eq_of_mem_replicate <| by rwa [map_const] at h\n#align eq_of_mem_map_const eq_of_mem_map_const\n\n",
 "eq_of_le_of_card_le":
 "theorem eq_of_le_of_card_le {s t : Multiset α} (h : s ≤ t) : card t ≤ card s → s = t :=\n  leInductionOn h fun l₁ l₂ s h₂ => congr_arg coe <| s.eq_of_length_le h₂\n#align eq_of_le_of_card_le eq_of_le_of_card_le\n\n",
 "empty_to_list":
 "@[simp]\ntheorem empty_to_list {s : Multiset α} : s.to_list.empty ↔ s = 0 :=\n  isEmpty_iff_eq_nil.trans toList_eq_nil\n#align empty_to_list empty_to_list\n\n",
 "empty_or_exists_mem":
 "theorem empty_or_exists_mem (s : Multiset α) : s = 0 ∨ ∃ a, a ∈ s :=\n  or_iff_not_imp_left.mpr Multiset.exists_mem_of_ne_zero\n#align empty_or_exists_mem empty_or_exists_mem\n\n",
 "empty_eq_zero":
 "@[simp]\ntheorem empty_eq_zero : (∅ : Multiset α) = 0 :=\n  rfl\n#align empty_eq_zero empty_eq_zero\n\n",
 "disjoint_union_right":
 "@[simp]\ntheorem disjoint_union_right [decidable_eq α] {s t u : Multiset α} : Disjoint s (t ∪ u) ↔ Disjoint s t ∧ Disjoint s u :=\n  by simp [Disjoint, or_imp, forall_and]\n#align disjoint_union_right disjoint_union_right\n\n",
 "disjoint_union_left":
 "@[simp]\ntheorem disjoint_union_left [decidable_eq α] {s t u : Multiset α} : Disjoint (s ∪ t) u ↔ Disjoint s u ∧ Disjoint t u :=\n  by simp [Disjoint, or_imp, forall_and]\n#align disjoint_union_left disjoint_union_left\n\n",
 "disjoint_singleton":
 "@[simp]\ntheorem disjoint_singleton {l : Multiset α} {a : α} : Disjoint l {a} ↔ a ∉ l := by\n  rw [disjoint_comm, singleton_disjoint]\n#align disjoint_singleton disjoint_singleton\n\n",
 "disjoint_right":
 "theorem disjoint_right {s t : Multiset α} : Disjoint s t ↔ ∀ {a}, a ∈ t → a ∉ s :=\n  disjoint_comm\n#align disjoint_right disjoint_right\n\n",
 "disjoint_of_subset_right":
 "theorem disjoint_of_subset_right {s t u : Multiset α} (h : t ⊆ u) (d : Disjoint s u) : Disjoint s t\n  | x, m, m₁ => d m (h m₁)\n#align disjoint_of_subset_right disjoint_of_subset_right\n\n",
 "disjoint_of_subset_left":
 "theorem disjoint_of_subset_left {s t u : Multiset α} (h : s ⊆ u) (d : Disjoint u t) : Disjoint s t\n  | x, m₁ => d (h m₁)\n#align disjoint_of_subset_left disjoint_of_subset_left\n\n",
 "disjoint_of_le_right":
 "theorem disjoint_of_le_right {s t u : Multiset α} (h : t ≤ u) : Disjoint s u → Disjoint s t :=\n  disjoint_of_subset_right (subset_of_le h)\n#align disjoint_of_le_right disjoint_of_le_right\n\n",
 "disjoint_of_le_left":
 "theorem disjoint_of_le_left {s t u : Multiset α} (h : s ≤ u) : Disjoint u t → Disjoint s t :=\n  disjoint_of_subset_left (subset_of_le h)\n#align disjoint_of_le_left disjoint_of_le_left\n\n",
 "disjoint_map_map":
 "theorem disjoint_map_map {f : α → γ} {g : β → γ} {s : Multiset α} {t : Multiset β} :\n    Disjoint (s.map f) (t.map g) ↔ ∀ a ∈ s, ∀ b ∈ t, f a ≠ g b :=\n  by\n  simp [Disjoint, @eq_comm _ (f _) (g _)]\n  rfl\n#align disjoint_map_map disjoint_map_map\n\n",
 "disjoint_left":
 "theorem disjoint_left {s t : Multiset α} : Disjoint s t ↔ ∀ {a}, a ∈ s → a ∉ t :=\n  iff.rfl\n#align disjoint_left disjoint_left\n\n",
 "disjoint_iff_ne":
 "theorem disjoint_iff_ne {s t : Multiset α} : Disjoint s t ↔ ∀ a ∈ s, ∀ b ∈ t, a ≠ b := by\n  simp [disjoint_left, imp_not_comm]\n#align disjoint_iff_ne disjoint_iff_ne\n\n",
 "disjoint_cons_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem disjoint_cons_right {a : α} {s t : Multiset α} : Disjoint s («expr ::ₘ » a t) ↔ a ∉ s ∧ Disjoint s t := by\n  rw [disjoint_comm, disjoint_cons_left] <;> tauto\n#align disjoint_cons_right disjoint_cons_right\n\n",
 "disjoint_cons_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem disjoint_cons_left {a : α} {s t : Multiset α} : Disjoint («expr ::ₘ » a s) t ↔ a ∉ t ∧ Disjoint s t :=\n  (@disjoint_add_left _ {a} s t).trans <| by rw [singleton_disjoint]\n#align disjoint_cons_left disjoint_cons_left\n\n",
 "disjoint_comm":
 "/- warning: disjoint_comm clashes with disjoint.comm -> disjoint_comm\nCase conversion may be inaccurate. Consider using '#align disjoint_comm disjoint_commₓ'. -/\n#print disjoint_comm /-\ntheorem disjoint_comm {s t : Multiset α} : Disjoint s t ↔ Disjoint t s :=\n  ⟨Disjoint.symm, Disjoint.symm⟩\n#align disjoint_comm disjoint_comm\n-/\n\n",
 "disjoint_add_right":
 "@[simp]\ntheorem disjoint_add_right {s t u : Multiset α} : Disjoint s (t + u) ↔ Disjoint s t ∧ Disjoint s u := by\n  rw [disjoint_comm, disjoint_add_left] <;> tauto\n#align disjoint_add_right disjoint_add_right\n\n",
 "disjoint_add_left":
 "@[simp]\ntheorem disjoint_add_left {s t u : Multiset α} : Disjoint (s + t) u ↔ Disjoint s u ∧ Disjoint t u := by\n  simp [Disjoint, or_imp, forall_and]\n#align disjoint_add_left disjoint_add_left\n\n",
 "countp_zero":
 "@[simp]\ntheorem countp_zero : countp p 0 = 0 :=\n  rfl\n#align countp_zero countp_zero\n\n",
 "countp_true":
 "@[simp]\ntheorem countp_true {s : Multiset α} : countp (fun _ => true) s = card s :=\n  Quot.inductionOn s fun l => List.countp_true\n#align countp_true countp_true\n\n",
 "countp_sub":
 "@[simp]\ntheorem countp_sub [decidable_eq α] {s t : Multiset α} (h : t ≤ s) : countp p (s - t) = countp p s - countp p t := by\n  simp [countp_eq_card_filter, h, filter_le_filter]\n#align countp_sub countp_sub\n\n",
 "countp_pos_of_mem":
 "theorem countp_pos_of_mem {s a} (h : a ∈ s) (pa : p a) : 0 < countp p s :=\n  countp_pos.2 ⟨_, h, pa⟩\n#align countp_pos_of_mem countp_pos_of_mem\n\n",
 "countp_pos":
 "theorem countp_pos {s} : 0 < countp p s ↔ ∃ a ∈ s, p a :=\n  Quot.inductionOn s fun l => List.countp_pos p\n#align countp_pos countp_pos\n\n",
 "countp_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem countp_nsmul (s) (n : ℕ) : countp p («expr • » n s) = n * countp p s := by\n  induction n <;> simp [*, succ_nsmul', succ_mul, zero_nsmul]\n#align countp_nsmul countp_nsmul\n\n",
 "countp_map":
 "theorem countp_map (f : α → β) (s : Multiset α) (p : β → Prop) [decidable_pred p] :\n    countp p (map f s) = (s.filter fun a => p (f a)).card :=\n  by\n  refine' Multiset.induction_on s _ fun a t IH => _\n  · rw [map_zero, countp_zero, filter_zero, card_zero]\n  · rw [map_cons, countp_cons, IH, filter_cons, card_add, apply_ite card, card_zero, card_singleton, add_comm]\n#align countp_map countp_map\n\n",
 "countp_le_of_le":
 "theorem countp_le_of_le {s t} (h : s ≤ t) : countp p s ≤ countp p t := by\n  simpa [countp_eq_card_filter] using card_le_of_le (filter_le_filter p h)\n#align countp_le_of_le countp_le_of_le\n\n",
 "countp_le_card":
 "theorem countp_le_card (s) : countp p s ≤ card s :=\n  Quot.inductionOn s fun l => countp_le_length p\n#align countp_le_card countp_le_card\n\n",
 "countp_filter":
 "@[simp]\ntheorem countp_filter (q) [decidable_pred q] (s : Multiset α) : countp p (filter q s) = countp (fun a => p a ∧ q a) s :=\n  by simp [countp_eq_card_filter]\n#align countp_filter countp_filter\n\n",
 "countp_false":
 "@[simp]\ntheorem countp_false {s : Multiset α} : countp (fun _ => false) s = 0 :=\n  Quot.inductionOn s fun l => List.countp_false\n#align countp_false countp_false\n\n",
 "countp_eq_zero":
 "theorem countp_eq_zero {s} : countp p s = 0 ↔ ∀ a ∈ s, ¬p a :=\n  Quot.inductionOn s fun l => List.countp_eq_zero p\n#align countp_eq_zero countp_eq_zero\n\n",
 "countp_eq_countp_filter_add":
 "theorem countp_eq_countp_filter_add (s) (p q : α → Prop) [decidable_pred p] [decidable_pred q] :\n    countp p s = (filter q s).countp p + (filter (fun a => ¬q a) s).countp p :=\n  Quot.inductionOn s fun l => l.countp_eq_countp_filter_add _ _\n#align countp_eq_countp_filter_add countp_eq_countp_filter_add\n\n",
 "countp_eq_card_filter":
 "theorem countp_eq_card_filter (s) : countp p s = card (filter p s) :=\n  Quot.inductionOn s fun l => l.countp_eq_length_filter p\n#align countp_eq_card_filter countp_eq_card_filter\n\n",
 "countp_eq_card":
 "theorem countp_eq_card {s} : countp p s = card s ↔ ∀ a ∈ s, p a :=\n  Quot.inductionOn s fun l => List.countp_eq_length p\n#align countp_eq_card countp_eq_card\n\n",
 "countp_eq":
 "theorem rel.countp_eq (r : α → α → Prop) [is_trans α r] [is_symm α r] {s t : Multiset α} (x : α) [decidable_pred (r x)]\n    (h : Rel r s t) : countp (r x) s = countp (r x) t :=\n  by\n  induction' s using Multiset.induction_on with y s ih generalizing t\n  · rw [rel_zero_left.mp h]\n  · obtain ⟨b, bs, hb1, hb2, rfl⟩ := rel_cons_left.mp h\n    rw [countp_cons, countp_cons, ih hb2]\n    exact congr_arg _ (if_congr ⟨fun h => trans h hb1, fun h => trans h (symm hb1)⟩ rfl rfl)\n#align rel.countp_eq rel.countp_eq\n\n",
 "countp_cons_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem countp_cons_of_pos {a : α} (s) : p a → countp p («expr ::ₘ » a s) = countp p s + 1 :=\n  Quot.inductionOn s <| countp_cons_of_pos p\n#align countp_cons_of_pos countp_cons_of_pos\n\n",
 "countp_cons_of_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem countp_cons_of_neg {a : α} (s) : ¬p a → countp p («expr ::ₘ » a s) = countp p s :=\n  Quot.inductionOn s <| countp_cons_of_neg p\n#align countp_cons_of_neg countp_cons_of_neg\n\n",
 "countp_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem countp_cons (b : α) (s) : countp p («expr ::ₘ » b s) = countp p s + if p b then 1 else 0 :=\n  Quot.inductionOn s <| by simp [List.countp_cons]\n#align countp_cons countp_cons\n\n",
 "countp_congr":
 "theorem countp_congr {s s' : Multiset α} (hs : s = s') {p p' : α → Prop} [decidable_pred p] [decidable_pred p']\n    (hp : ∀ x ∈ s, p x = p' x) : s.countp p = s'.countp p' :=\n  quot.induction_on₂ s s'\n    (fun l l' hs hp => by\n      simp only [quot_mk_to_coe'', coe_eq_coe] at hs\n      exact hs.countp_congr hp)\n    hs hp\n#align countp_congr countp_congr\n\n",
 "countp_add":
 "@[simp]\ntheorem countp_add (s t) : countp p (s + t) = countp p s + countp p t := by simp [countp_eq_card_filter]\n#align countp_add countp_add\n\n",
 "count_zero":
 "@[simp]\ntheorem count_zero (a : α) : count a 0 = 0 :=\n  rfl\n#align count_zero count_zero\n\n",
 "count_union":
 "@[simp]\ntheorem count_union (a : α) (s t : Multiset α) : count a (s ∪ t) = max (count a s) (count a t) := by\n  simp [(· ∪ ·), union, tsub_add_eq_max, -add_comm]\n#align count_union count_union\n\n",
 "count_sub":
 "@[simp]\ntheorem count_sub (a : α) (s t : Multiset α) : count a (s - t) = count a s - count a t :=\n  by\n  revert s; refine' Multiset.induction_on t (by simp) fun b t IH s => _\n  rw [sub_cons, IH]\n  by_cases ab : a = b\n  · subst b\n    rw [count_erase_self, count_cons_self, sub_succ, pred_sub]\n  · rw [count_erase_of_ne ab, count_cons_of_ne ab]\n#align count_sub count_sub\n\n",
 "count_singleton_self":
 "theorem count_singleton_self (a : α) : count a ({a} : Multiset α) = 1 :=\n  count_eq_one_of_mem (nodup_singleton a) <| mem_singleton_self a\n#align count_singleton_self count_singleton_self\n\n",
 "count_singleton":
 "theorem count_singleton (a b : α) : count a ({b} : Multiset α) = if a = b then 1 else 0 := by\n  simp only [count_cons, ← cons_zero, count_zero, zero_add]\n#align count_singleton count_singleton\n\n",
 "count_replicate_self":
 "@[simp]\ntheorem count_replicate_self (a : α) (n : ℕ) : count a (replicate n a) = n :=\n  count_replicate_self _ _\n#align count_replicate_self count_replicate_self\n\n",
 "count_replicate":
 "theorem count_replicate (a b : α) (n : ℕ) : count a (replicate n b) = if a = b then n else 0 :=\n  count_replicate _ _ _\n#align count_replicate count_replicate\n\n",
 "count_pos":
 "theorem count_pos {a : α} {s : Multiset α} : 0 < count a s ↔ a ∈ s := by simp [count, countp_pos]\n#align count_pos count_pos\n\n",
 "count_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem count_nsmul (a : α) (n s) : count a («expr • » n s) = n * count a s := by\n  induction n <;> simp [*, succ_nsmul', succ_mul, zero_nsmul]\n#align count_nsmul count_nsmul\n\n",
 "count_ne_zero":
 "theorem count_ne_zero {a : α} {s : Multiset α} : count a s ≠ 0 ↔ a ∈ s := by simp [ne.def, count_eq_zero]\n#align count_ne_zero count_ne_zero\n\n",
 "count_map_eq_count'":
 "/-- `multiset.map f` preserves `count` if `f` is injective -/\ntheorem count_map_eq_count' [decidable_eq β] (f : α → β) (s : Multiset α) (hf : function.injective f) (x : α) :\n    (s.map f).count (f x) = s.count x := by\n  by_cases H : x ∈ s\n  · exact count_map_eq_count f _ (Set.injOn_of_injective hf _) _ H\n  · rw [count_eq_zero_of_not_mem H, count_eq_zero, mem_map]\n    rintro ⟨k, hks, hkx⟩\n    rw [hf hkx] at *\n    contradiction\n#align count_map_eq_count' count_map_eq_count'\n\n",
 "count_map_eq_count":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∈ » s) -/\n/-- `multiset.map f` preserves `count` if `f` is injective on the set of elements contained in\nthe multiset -/\ntheorem count_map_eq_count [decidable_eq β] (f : α → β) (s : Multiset α) (hf : Set.InjOn f { x : α | x ∈ s }) (x)\n    (_ : x ∈ s) : (s.map f).count (f x) = s.count x :=\n  by\n  suffices (filter (fun a : α => f x = f a) s).count x = card (filter (fun a : α => f x = f a) s)\n    by\n    rw [count, countp_map, ← this]\n    exact count_filter_of_pos rfl\n  ·\n    rw [eq_replicate_card.2 fun b hb => ((hf H (mem_filter.1 hb).left) (mem_filter.1 hb).2).symm, count_replicate_self,\n      card_replicate]\n#align count_map_eq_count count_map_eq_count\n\n",
 "count_map":
 "theorem count_map {α β : Type _} (f : α → β) (s : Multiset α) [decidable_eq β] (b : β) :\n    count b (map f s) = (s.filter fun a => b = f a).card :=\n  countp_map _ _ _\n#align count_map count_map\n\n",
 "count_le_of_le":
 "theorem count_le_of_le (a : α) {s t} : s ≤ t → count a s ≤ count a t :=\n  countp_le_of_le _\n#align count_le_of_le count_le_of_le\n\n",
 "count_le_count_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem count_le_count_cons (a b : α) (s : Multiset α) : count a s ≤ count a («expr ::ₘ » b s) :=\n  count_le_of_le _ (le_cons_self _ _)\n#align count_le_count_cons count_le_count_cons\n\n",
 "count_le_card":
 "theorem count_le_card (a : α) (s) : count a s ≤ card s :=\n  countp_le_card _ _\n#align count_le_card count_le_card\n\n",
 "count_inter":
 "@[simp]\ntheorem count_inter (a : α) (s t : Multiset α) : count a (s ∩ t) = min (count a s) (count a t) :=\n  by\n  apply @nat.add_left_cancel (count a (s - t))\n  rw [← count_add, sub_add_inter, count_sub, tsub_add_min]\n#align count_inter count_inter\n\n",
 "count_filter_of_pos":
 "@[simp]\ntheorem count_filter_of_pos {p} [decidable_pred p] {a} {s : Multiset α} (h : p a) : count a (filter p s) = count a s :=\n  Quot.inductionOn s fun l => count_filter h\n#align count_filter_of_pos count_filter_of_pos\n\n",
 "count_filter_of_neg":
 "@[simp]\ntheorem count_filter_of_neg {p} [decidable_pred p] {a} {s : Multiset α} (h : ¬p a) : count a (filter p s) = 0 :=\n  Multiset.count_eq_zero_of_not_mem fun t => h (of_mem_filter t)\n#align count_filter_of_neg count_filter_of_neg\n\n",
 "count_filter":
 "theorem count_filter {p} [decidable_pred p] {a} {s : Multiset α} :\n    count a (filter p s) = if p a then count a s else 0 :=\n  by\n  split_ifs with h\n  · exact count_filter_of_pos h\n  · exact count_filter_of_neg h\n#align count_filter count_filter\n\n",
 "count_erase_self":
 "@[simp]\ntheorem count_erase_self (a : α) (s : Multiset α) : count a (erase s a) = pred (count a s) :=\n  Quotient.inductionOn s <| count_erase_self a\n#align count_erase_self count_erase_self\n\n",
 "count_erase_of_ne":
 "@[simp]\ntheorem count_erase_of_ne {a b : α} (ab : a ≠ b) (s : Multiset α) : count a (erase s b) = count a s :=\n  Quotient.inductionOn s <| count_erase_of_ne ab\n#align count_erase_of_ne count_erase_of_ne\n\n",
 "count_eq_zero_of_not_mem":
 "@[simp]\ntheorem count_eq_zero_of_not_mem {a : α} {s : Multiset α} (h : a ∉ s) : count a s = 0 :=\n  by_contradiction fun h' => h <| count_pos.1 (nat.pos_of_ne_zero h')\n#align count_eq_zero_of_not_mem count_eq_zero_of_not_mem\n\n",
 "count_eq_zero":
 "@[simp]\ntheorem count_eq_zero {a : α} {s : Multiset α} : count a s = 0 ↔ a ∉ s :=\n  iff_not_comm.1 <| count_pos.symm.trans pos_iff_ne_zero\n#align count_eq_zero count_eq_zero\n\n",
 "count_eq_card_filter_eq":
 "theorem count_eq_card_filter_eq [decidable_eq α] (s : Multiset α) (a : α) : s.count a = (s.filter (eq a)).card := by\n  rw [count, countp_eq_card_filter]\n#align count_eq_card_filter_eq count_eq_card_filter_eq\n\n",
 "count_eq_card":
 "theorem count_eq_card {a : α} {s} : count a s = card s ↔ ∀ x ∈ s, a = x :=\n  countp_eq_card\n#align count_eq_card count_eq_card\n\n",
 "count_cons_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem count_cons_self (a : α) (s : Multiset α) : count a («expr ::ₘ » a s) = succ (count a s) :=\n  countp_cons_of_pos _ rfl\n#align count_cons_self count_cons_self\n\n",
 "count_cons_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem count_cons_of_ne {a b : α} (h : a ≠ b) (s : Multiset α) : count a («expr ::ₘ » b s) = count a s :=\n  countp_cons_of_neg _ h\n#align count_cons_of_ne count_cons_of_ne\n\n",
 "count_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem count_cons (a b : α) (s : Multiset α) : count a («expr ::ₘ » b s) = count a s + if a = b then 1 else 0 :=\n  countp_cons _ _ _\n#align count_cons count_cons\n\n",
 "count_add":
 "@[simp]\ntheorem count_add (a : α) : ∀ s t, count a (s + t) = count a s + count a t :=\n  countp_add _\n#align count_add count_add\n\n",
 "cons_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_zero (a : α) : «expr ::ₘ » a 0 = {a} :=\n  rfl\n#align cons_zero cons_zero\n\n",
 "cons_union_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_union_distrib (a : α) (s t : Multiset α) : «expr ::ₘ » a (s ∪ t) = «expr ::ₘ » a s ∪ «expr ::ₘ » a t := by\n  simpa using add_union_distrib («expr ::ₘ » a 0) s t\n#align cons_union_distrib cons_union_distrib\n\n",
 "cons_swap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_swap (a b : α) (s : Multiset α) : «expr ::ₘ » a («expr ::ₘ » b s) = «expr ::ₘ » b («expr ::ₘ » a s) :=\n  Quot.inductionOn s fun l => quotient.sound <| perm.swap _ _ _\n#align cons_swap cons_swap\n\n",
 "cons_subset_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_subset_cons {a : α} {s t : Multiset α} : s ⊆ t → «expr ::ₘ » a s ⊆ «expr ::ₘ » a t :=\n  quotient.induction_on₂ s t fun _ _ => cons_subset_cons _\n#align cons_subset_cons cons_subset_cons\n\n",
 "cons_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_subset {a : α} {s t : Multiset α} : «expr ::ₘ » a s ⊆ t ↔ a ∈ t ∧ s ⊆ t := by\n  simp [subset_iff, or_imp, forall_and]\n#align cons_subset cons_subset\n\n",
 "cons_sub_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_sub_of_le (a : α) {s t : Multiset α} (h : t ≤ s) : «expr ::ₘ » a s - t = «expr ::ₘ » a (s - t) := by\n  rw [← singleton_add, ← singleton_add, add_tsub_assoc_of_le h]\n#align cons_sub_of_le cons_sub_of_le\n\n",
 "cons_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_ne_zero {a : α} {m : Multiset α} : «expr ::ₘ » a m ≠ 0 :=\n  zero_ne_cons.symm\n#align cons_ne_zero cons_ne_zero\n\n",
 "cons_le_cons_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_le_cons_iff (a : α) : «expr ::ₘ » a s ≤ «expr ::ₘ » a t ↔ s ≤ t :=\n  quotient.induction_on₂ s t fun l₁ l₂ => subperm_cons a\n#align cons_le_cons_iff cons_le_cons_iff\n\n",
 "cons_le_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_le_cons (a : α) : s ≤ t → «expr ::ₘ » a s ≤ «expr ::ₘ » a t :=\n  (cons_le_cons_iff a).2\n#align cons_le_cons cons_le_cons\n\n",
 "cons_inter_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_inter_of_pos {a} (s : Multiset α) {t} : a ∈ t → «expr ::ₘ » a s ∩ t = «expr ::ₘ » a (s ∩ t.erase a) :=\n  quotient.induction_on₂ s t fun l₁ l₂ h => congr_arg coe <| cons_bagInter_of_pos _ h\n#align cons_inter_of_pos cons_inter_of_pos\n\n",
 "cons_inter_of_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_inter_of_neg {a} (s : Multiset α) {t} : a ∉ t → «expr ::ₘ » a s ∩ t = s ∩ t :=\n  quotient.induction_on₂ s t fun l₁ l₂ h => congr_arg coe <| cons_bagInter_of_neg _ h\n#align cons_inter_of_neg cons_inter_of_neg\n\n",
 "cons_inter_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_inter_distrib (a : α) (s t : Multiset α) : «expr ::ₘ » a (s ∩ t) = «expr ::ₘ » a s ∩ «expr ::ₘ » a t := by\n  simp\n#align cons_inter_distrib cons_inter_distrib\n\n",
 "cons_inj_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_inj_right (a : α) : ∀ {s t : Multiset α}, «expr ::ₘ » a s = «expr ::ₘ » a t ↔ s = t := by\n  rintro ⟨l₁⟩ ⟨l₂⟩ <;> simp\n#align cons_inj_right cons_inj_right\n\n",
 "cons_inj_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_inj_left {a b : α} (s : Multiset α) : «expr ::ₘ » a s = «expr ::ₘ » b s ↔ a = b :=\n  ⟨Quot.inductionOn s fun l e =>\n      have : list.perm ([a] ++ l) ([b] ++ l) := quotient.exact e\n      singleton_perm_singleton.1 <| (perm_append_right_iff _).1 this,\n    congr_arg _⟩\n#align cons_inj_left cons_inj_left\n\n",
 "cons_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_erase {s : Multiset α} {a : α} : a ∈ s → «expr ::ₘ » a (s.erase a) = s :=\n  Quot.inductionOn s fun l h => quot.sound (perm_cons_erase h).symm\n#align cons_erase cons_erase\n\n",
 "cons_eq_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem cons_eq_cons {a b : α} {as bs : Multiset α} :\n    «expr ::ₘ » a as = «expr ::ₘ » b bs ↔\n      a = b ∧ as = bs ∨ a ≠ b ∧ ∃ cs, as = «expr ::ₘ » b cs ∧ bs = «expr ::ₘ » a cs :=\n  by\n  haveI : decidable_eq α := classical.dec_eq α\n  constructor\n  · intro eq\n    by_cases a = b\n    · subst h\n      simp_all\n    · have : a ∈ «expr ::ₘ » b bs := eq ▸ mem_cons_self _ _\n      have : a ∈ bs := by simpa [h]\n      rcases exists_cons_of_mem this with ⟨cs, hcs⟩\n      simp [h, hcs]\n      have : «expr ::ₘ » a as = «expr ::ₘ » b («expr ::ₘ » a cs) := by simp [eq, hcs]\n      have : «expr ::ₘ » a as = «expr ::ₘ » a («expr ::ₘ » b cs) := by rwa [cons_swap]\n      simpa using this\n  · intro h\n    rcases h with (⟨eq₁, eq₂⟩ | ⟨h, cs, eq₁, eq₂⟩)\n    · simp [*]\n    · simp [*, cons_swap a b]\n#align cons_eq_cons cons_eq_cons\n\n",
 "cons_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_coe (a : α) (l : list α) : («expr ::ₘ » a l : Multiset α) = (a :: l : list α) :=\n  rfl\n#align cons_coe cons_coe\n\n",
 "cons_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem cons_add (a : α) (s t : Multiset α) : «expr ::ₘ » a s + t = «expr ::ₘ » a (s + t) := by\n  rw [← singleton_add, ← singleton_add, add_assoc]\n#align cons_add cons_add\n\n",
 "coe_to_list":
 "@[simp, norm_cast]\ntheorem coe_to_list (s : Multiset α) : (s.to_list : Multiset α) = s :=\n  s.out_eq'\n#align coe_to_list coe_to_list\n\n",
 "coe_subsingleton_equiv":
 "@[simp]\ntheorem coe_subsingleton_equiv [subsingleton α] : (subsingletonEquiv α : list α → Multiset α) = coe :=\n  rfl\n#align coe_subsingleton_equiv coe_subsingleton_equiv\n\n",
 "coe_subset":
 "@[simp]\ntheorem coe_subset {l₁ l₂ : list α} : (l₁ : Multiset α) ⊆ l₂ ↔ l₁ ⊆ l₂ :=\n  iff.rfl\n#align coe_subset coe_subset\n\n",
 "coe_sub":
 "@[simp]\ntheorem coe_sub (s t : list α) : (s - t : Multiset α) = (s.diff t : list α) :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_singleton":
 "@[simp, norm_cast]\ntheorem coe_singleton (a : α) : ([a] : Multiset α) = {a} :=\n  rfl\n#align coe_singleton coe_singleton\n\n",
 "coe_reverse":
 "@[simp]\ntheorem coe_reverse (l : list α) : (reverse l : Multiset α) = l :=\n  quot.sound <| reverse_perm _\n#align coe_reverse coe_reverse\n\n",
 "coe_replicate":
 "theorem coe_replicate (n : ℕ) (a : α) : (list.replicate n a : Multiset α) = replicate n a :=\n  rfl\n#align coe_replicate coe_replicate\n\n",
 "coe_pmap":
 "@[simp]\ntheorem coe_pmap {p : α → Prop} (f : ∀ a, p a → β) (l : list α) (H : ∀ a ∈ l, p a) : pmap f l H = l.pmap f H :=\n  rfl\n#align coe_pmap coe_pmap\n\n",
 "coe_nil":
 "@[simp]\ntheorem coe_nil : (@nil α : Multiset α) = 0 :=\n  rfl\n#align coe_nil coe_nil\n\n",
 "coe_map_add_monoid_hom":
 "@[simp]\ntheorem coe_map_add_monoid_hom (f : α → β) : (mapAddMonoidHom f : Multiset α → Multiset β) = map f :=\n  rfl\n#align coe_map_add_monoid_hom coe_map_add_monoid_hom\n\n",
 "coe_map":
 "@[simp]\ntheorem coe_map (f : α → β) (l : list α) : map f ↑l = l.map f :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr <+~ » -/\n@[simp]\ntheorem coe_le {l₁ l₂ : list α} : (l₁ : Multiset α) ≤ l₂ ↔ «expr <+~ » l₁ l₂ :=\n  iff.rfl\n#align coe_le coe_le\n\n",
 "coe_inter":
 "@[simp]\ntheorem coe_inter (s t : list α) : (s ∩ t : Multiset α) = (s.bag_inter t : list α) := by ext <;> simp\n#align coe_inter coe_inter\n\n",
 "coe_foldr_swap":
 "theorem coe_foldr_swap (f : α → β → β) (H : left_commutative f) (b : β) (l : list α) :\n    foldr f H b l = l.foldl (fun x y => f y x) b :=\n  (congr_arg (foldr f H b) (coe_reverse l)).symm.trans <| foldr_reverse _ _ _\n#align coe_foldr_swap coe_foldr_swap\n\n",
 "coe_foldr":
 "@[simp]\ntheorem coe_foldr (f : α → β → β) (H : left_commutative f) (b : β) (l : list α) : foldr f H b l = l.foldr f b :=\n  rfl\n#align coe_foldr coe_foldr\n\n",
 "coe_foldl":
 "@[simp]\ntheorem coe_foldl (f : β → α → β) (H : right_commutative f) (b : β) (l : list α) : foldl f H b l = l.foldl f b :=\n  rfl\n#align coe_foldl coe_foldl\n\n",
 "coe_filter_map":
 "@[simp]\ntheorem coe_filter_map (f : α → option β) (l : list α) : filterMap f l = l.filter_map f :=\n  rfl\n#align coe_filter_map coe_filter_map\n\n",
 "coe_filter":
 "@[simp]\ntheorem coe_filter (l : list α) : filter p ↑l = l.filter p :=\n  rfl\n#align coe_filter coe_filter\n\n",
 "coe_erase":
 "@[simp]\ntheorem coe_erase (l : list α) (a : α) : erase (l : Multiset α) a = l.erase a :=\n  rfl\n#align coe_erase coe_erase\n\n",
 "coe_eq_zero_iff_empty":
 "theorem coe_eq_zero_iff_empty (l : list α) : (l : Multiset α) = 0 ↔ l.empty :=\n  iff.trans (coe_eq_zero l) isEmpty_iff_eq_nil.symm\n#align coe_eq_zero_iff_empty coe_eq_zero_iff_empty\n\n",
 "coe_eq_zero":
 "@[simp]\ntheorem coe_eq_zero (l : list α) : (l : Multiset α) = 0 ↔ l = [] :=\n  iff.trans coe_eq_coe perm_nil\n#align coe_eq_zero coe_eq_zero\n\n",
 "coe_eq_singleton":
 "@[simp, norm_cast]\ntheorem coe_eq_singleton {l : list α} {a : α} : (l : Multiset α) = {a} ↔ l = [a] := by\n  rw [← coe_singleton, coe_eq_coe, List.perm_singleton]\n#align coe_eq_singleton coe_eq_singleton\n\n",
 "coe_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.perm -/\n@[simp]\ntheorem coe_eq_coe {l₁ l₂ : list α} : (l₁ : Multiset α) = l₂ ↔ list.perm l₁ l₂ :=\n  quotient.eq\n#align coe_eq_coe coe_eq_coe\n\n",
 "coe_disjoint":
 "@[simp]\ntheorem coe_disjoint (l₁ l₂ : list α) : @Disjoint α l₁ l₂ ↔ l₁.disjoint l₂ :=\n  iff.rfl\n#align coe_disjoint coe_disjoint\n\n",
 "coe_countp_add_monoid_hom":
 "@[simp]\ntheorem coe_countp_add_monoid_hom : (countpAddMonoidHom p : Multiset α → ℕ) = countp p :=\n  rfl\n#align coe_countp_add_monoid_hom coe_countp_add_monoid_hom\n\n",
 "coe_countp":
 "@[simp]\ntheorem coe_countp (l : list α) : countp p l = l.countp p :=\n  rfl\n#align coe_countp coe_countp\n\n",
 "coe_count_add_monoid_hom":
 "@[simp]\ntheorem coe_count_add_monoid_hom {a : α} : (countAddMonoidHom a : Multiset α → ℕ) = count a :=\n  rfl\n#align coe_count_add_monoid_hom coe_count_add_monoid_hom\n\n",
 "coe_count":
 "@[simp]\ntheorem coe_count (a : α) (l : list α) : count a ↑l = l.count a :=\n  coe_countp _ _\n#align coe_count coe_count\n\n",
 "coe_card":
 "@[simp]\ntheorem coe_card (l : list α) : card (l : Multiset α) = length l :=\n  rfl\n#align coe_card coe_card\n\n",
 "coe_attach":
 "@[simp]\ntheorem coe_attach (l : list α) : @eq (Multiset { x // x ∈ l }) (@attach α l) l.attach :=\n  rfl\n#align coe_attach coe_attach\n\n",
 "coe_add":
 "@[simp]\ntheorem coe_add (s t : list α) : (s + t : Multiset α) = (s ++ t : list α) :=\n  rfl\n#align coe_add coe_add\n\n",
 "choose_spec":
 "theorem choose_spec (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l ∧ p (choose p l hp) :=\n  (chooseX p l hp).property\n#align choose_spec choose_spec\n\n",
 "choose_property":
 "theorem choose_property (hp : ∃! a, a ∈ l ∧ p a) : p (choose p l hp) :=\n  (choose_spec _ _ _).2\n#align choose_property choose_property\n\n",
 "choose_mem":
 "theorem choose_mem (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l :=\n  (choose_spec _ _ _).1\n#align choose_mem choose_mem\n\n",
 "case_strong_induction_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[elab_as_elim]\ntheorem case_strong_induction_on {p : Multiset α → Prop} (s : Multiset α) (h₀ : p 0)\n    (h₁ : ∀ a s, (∀ t ≤ s, p t) → p («expr ::ₘ » a s)) : p s :=\n  Multiset.strongInductionOn s fun s =>\n    Multiset.induction_on s (fun _ => h₀) fun a s _ ih => h₁ _ _ fun t h => ih _ <| lt_of_le_of_lt h <| lt_cons_self _ _\n#align case_strong_induction_on case_strong_induction_on\n\n",
 "card_zero":
 "@[simp]\ntheorem card_zero : @card α 0 = 0 :=\n  rfl\n#align card_zero card_zero\n\n",
 "card_sub":
 "@[simp]\ntheorem card_sub {s t : Multiset α} (h : t ≤ s) : card (s - t) = card s - card t :=\n  (tsub_eq_of_eq_add_rev <| by rw [add_comm, ← card_add, tsub_add_cancel_of_le h]).symm\n#align card_sub card_sub\n\n",
 "card_singleton":
 "@[simp]\ntheorem card_singleton (a : α) : card ({a} : Multiset α) = 1 := by\n  simp only [← cons_zero, card_zero, eq_self_iff_true, zero_add, card_cons]\n#align card_singleton card_singleton\n\n",
 "card_replicate":
 "@[simp]\ntheorem card_replicate : ∀ (n) (a : α), card (replicate n a) = n :=\n  length_replicate\n#align card_replicate card_replicate\n\n",
 "card_pos_iff_exists_mem":
 "theorem card_pos_iff_exists_mem {s : Multiset α} : 0 < card s ↔ ∃ a, a ∈ s :=\n  Quot.inductionOn s fun l => length_pos_iff_exists_mem\n#align card_pos_iff_exists_mem card_pos_iff_exists_mem\n\n",
 "card_pos":
 "theorem card_pos {s : Multiset α} : 0 < card s ↔ s ≠ 0 :=\n  pos_iff_ne_zero.trans <| not_congr card_eq_zero\n#align card_pos card_pos\n\n",
 "card_pmap":
 "@[simp]\ntheorem card_pmap {p : α → Prop} (f : ∀ a, p a → β) (s H) : card (pmap f s H) = card s :=\n  Quot.inductionOn s (fun l H => length_pmap) H\n#align card_pmap card_pmap\n\n",
 "card_pair":
 "theorem card_pair (a b : α) : ({a, b} : Multiset α).card = 2 := by rw [insert_eq_cons, card_cons, card_singleton]\n#align card_pair card_pair\n\n",
 "card_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem card_nsmul (s : Multiset α) (n : ℕ) : («expr • » n s).card = n * s.card := by\n  rw [card.map_nsmul s n, Nat.nsmul_eq_mul]\n#align card_nsmul card_nsmul\n\n",
 "card_mono":
 "@[mono]\ntheorem card_mono : monotone (@card α) := fun a b => card_le_of_le\n#align card_mono card_mono\n\n",
 "card_map":
 "@[simp]\ntheorem card_map (f : α → β) (s) : card (map f s) = card s :=\n  Quot.inductionOn s fun l => length_map _ _\n#align card_map card_map\n\n",
 "card_lt_of_lt":
 "theorem card_lt_of_lt {s t : Multiset α} (h : s < t) : card s < card t :=\n  lt_of_not_ge fun h₂ => ne_of_lt h <| eq_of_le_of_card_le (le_of_lt h) h₂\n#align card_lt_of_lt card_lt_of_lt\n\n",
 "card_le_of_le":
 "theorem card_le_of_le {s t : Multiset α} (h : s ≤ t) : card s ≤ card t :=\n  leInductionOn h fun l₁ l₂ => Sublist.length_le\n#align card_le_of_le card_le_of_le\n\n",
 "card_erase_of_mem":
 "@[simp]\ntheorem card_erase_of_mem {a : α} {s : Multiset α} : a ∈ s → card (s.erase a) = pred (card s) :=\n  Quot.inductionOn s fun l => length_erase_of_mem\n#align card_erase_of_mem card_erase_of_mem\n\n",
 "card_erase_lt_of_mem":
 "theorem card_erase_lt_of_mem {a : α} {s : Multiset α} : a ∈ s → card (s.erase a) < card s := fun h =>\n  card_lt_of_lt (erase_lt.mpr h)\n#align card_erase_lt_of_mem card_erase_lt_of_mem\n\n",
 "card_erase_le":
 "theorem card_erase_le {a : α} {s : Multiset α} : card (s.erase a) ≤ card s :=\n  card_le_of_le (erase_le a s)\n#align card_erase_le card_erase_le\n\n",
 "card_erase_eq_ite":
 "theorem card_erase_eq_ite {a : α} {s : Multiset α} : card (s.erase a) = if a ∈ s then pred (card s) else card s :=\n  by\n  by_cases h : a ∈ s\n  · rwa [card_erase_of_mem h, if_pos]\n  · rwa [erase_of_not_mem h, if_neg]\n#align card_erase_eq_ite card_erase_eq_ite\n\n",
 "card_erase_add_one":
 "@[simp]\ntheorem card_erase_add_one {a : α} {s : Multiset α} : a ∈ s → (s.erase a).card + 1 = s.card :=\n  Quot.inductionOn s fun l => length_erase_add_one\n#align card_erase_add_one card_erase_add_one\n\n",
 "card_eq_zero":
 "@[simp]\ntheorem card_eq_zero {s : Multiset α} : card s = 0 ↔ s = 0 :=\n  ⟨fun h => (eq_of_le_of_card_le (zero_le _) (le_of_eq h)).symm, fun e => by simp [e]⟩\n#align card_eq_zero card_eq_zero\n\n",
 "card_eq_two":
 "theorem card_eq_two {s : Multiset α} : s.card = 2 ↔ ∃ x y, s = {x, y} :=\n  ⟨Quot.inductionOn s fun l h => (List.length_eq_two.mp h).imp fun a => Exists.imp fun b => congr_arg coe,\n    fun ⟨a, b, e⟩ => e.symm ▸ rfl⟩\n#align card_eq_two card_eq_two\n\n",
 "card_eq_three":
 "theorem card_eq_three {s : Multiset α} : s.card = 3 ↔ ∃ x y z, s = {x, y, z} :=\n  ⟨Quot.inductionOn s fun l h =>\n      (List.length_eq_three.mp h).imp fun a => Exists.imp fun b => Exists.imp fun c => congr_arg coe,\n    fun ⟨a, b, c, e⟩ => e.symm ▸ rfl⟩\n#align card_eq_three card_eq_three\n\n",
 "card_eq_one":
 "theorem card_eq_one {s : Multiset α} : card s = 1 ↔ ∃ a, s = {a} :=\n  ⟨Quot.inductionOn s fun l h => (List.length_eq_one.1 h).imp fun a => congr_arg coe, fun ⟨a, e⟩ => e.symm ▸ rfl⟩\n#align card_eq_one card_eq_one\n\n",
 "card_eq_countp_add_countp":
 "theorem card_eq_countp_add_countp (s) : card s = countp p s + countp (fun x => ¬p x) s :=\n  Quot.inductionOn s fun l => by simp [l.length_eq_countp_add_countp p]\n#align card_eq_countp_add_countp card_eq_countp_add_countp\n\n",
 "card_eq_card_of_rel":
 "theorem card_eq_card_of_rel {r : α → β → Prop} {s : Multiset α} {t : Multiset β} (h : Rel r s t) : card s = card t := by\n  induction h <;> simp [*]\n#align card_eq_card_of_rel card_eq_card_of_rel\n\n",
 "card_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem card_cons (a : α) (s : Multiset α) : card («expr ::ₘ » a s) = card s + 1 :=\n  Quot.inductionOn s fun l => rfl\n#align card_cons card_cons\n\n",
 "card_attach":
 "@[simp]\ntheorem card_attach {m : Multiset α} : card (attach m) = card m :=\n  card_pmap _ _ _\n#align card_attach card_attach\n\n",
 "card_add":
 "theorem card_add (s t : Multiset α) : card (s + t) = card s + card t :=\n  card.map_add s t\n#align card_add card_add\n\n",
 "bot_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print bot_eq_zero /-\n/-- This is a `rfl` and `simp` version of `bot_eq_zero`. -/\n@[simp]\ntheorem bot_eq_zero : («expr⊥» : Multiset α) = 0 :=\n  rfl\n#align bot_eq_zero bot_eq_zero\n-/\n\n",
 "attach_zero":
 "@[simp]\ntheorem attach_zero : (0 : Multiset α).attach = 0 :=\n  rfl\n#align attach_zero attach_zero\n\n",
 "attach_map_val'":
 "theorem attach_map_val' (s : Multiset α) (f : α → β) : (s.attach.map fun i => f i.val) = s.map f :=\n  attach_map_val' _ _\n#align attach_map_val' attach_map_val'\n\n",
 "attach_map_val":
 "theorem attach_map_val (s : Multiset α) : s.attach.map subtype.val = s :=\n  attach_map_val _\n#align attach_map_val attach_map_val\n\n",
 "attach_map_coe'":
 "@[simp]\ntheorem attach_map_coe' (s : Multiset α) (f : α → β) : (s.attach.map fun i => f i) = s.map f :=\n  Quot.inductionOn s fun l => congr_arg coe <| attach_map_coe' l f\n#align attach_map_coe' attach_map_coe'\n\n",
 "attach_map_coe":
 "@[simp]\ntheorem attach_map_coe (s : Multiset α) : s.attach.map (coe : _ → α) = s :=\n  (attach_map_val' _ _).trans s.map_id\n#align attach_map_coe attach_map_coe\n\n",
 "attach_count_eq_count_coe":
 "@[simp]\ntheorem attach_count_eq_count_coe (m : Multiset α) (a) : m.attach.count a = m.count (a : α) :=\n  calc\n    m.attach.count a = (m.attach.map (coe : _ → α)).count (a : α) :=\n      (Multiset.count_map_eq_count' _ _ subtype.coe_injective _).symm\n    _ = m.count (a : α) := congr_arg _ m.attach_map_coe\n    \n#align attach_count_eq_count_coe attach_count_eq_count_coe\n\n",
 "attach_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\ntheorem attach_cons (a : α) (m : Multiset α) :\n    («expr ::ₘ » a m).attach = «expr ::ₘ » ⟨a, mem_cons_self a m⟩ (m.attach.map fun p => ⟨p.1, mem_cons_of_mem p.2⟩) :=\n  Quotient.inductionOn m fun l =>\n    congr_arg coe <|\n      congr_arg (list.cons _) <| by rw [List.map_pmap] <;> exact List.pmap_congr _ fun _ _ _ _ => subtype.eq rfl\n#align attach_cons attach_cons\n\n",
 "add_union_distrib":
 "theorem add_union_distrib (s t u : Multiset α) : s + (t ∪ u) = s + t ∪ (s + u) := by\n  rw [add_comm, union_add_distrib, add_comm s, add_comm s]\n#align add_union_distrib add_union_distrib\n\n",
 "add_singleton_eq_iff":
 "theorem add_singleton_eq_iff {s t : Multiset α} {a : α} : s + {a} = t ↔ a ∈ t ∧ s = t.erase a :=\n  by\n  rw [add_comm, singleton_add]; constructor\n  · rintro rfl\n    exact ⟨s.mem_cons_self a, (s.erase_cons_head a).symm⟩\n  · rintro ⟨h, rfl⟩\n    exact cons_erase h\n#align add_singleton_eq_iff add_singleton_eq_iff\n\n",
 "add_le_add_iff_left'":
 "private theorem add_le_add_iff_left' {s t u : Multiset α} : s + t ≤ s + u ↔ t ≤ u :=\n  quotient.induction_on₃ s t u fun l₁ l₂ l₃ => subperm_append_left _\n#align add_le_add_iff_left' add_le_add_iff_left'\n\n",
 "add_inter_distrib":
 "theorem add_inter_distrib (s t u : Multiset α) : s + t ∩ u = (s + t) ∩ (s + u) := by\n  rw [add_comm, inter_add_distrib, add_comm s, add_comm s]\n#align add_inter_distrib add_inter_distrib\n\n",
 "add_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[ext]\ntheorem add_hom_ext [add_zero_class β] ⦃f g : «expr →+ » (Multiset α) β⦄ (h : ∀ x, f {x} = g {x}) : f = g :=\n  by\n  ext s\n  induction' s using Multiset.induction_on with a s ih\n  · simp only [_root_.map_zero]\n  · simp only [← singleton_add, _root_.map_add, ih, h]\n#align add_hom_ext add_hom_ext\n\n",
 "add_eq_union_iff_disjoint":
 "theorem add_eq_union_iff_disjoint [decidable_eq α] {s t : Multiset α} : s + t = s ∪ t ↔ Disjoint s t := by\n  simp_rw [← inter_eq_zero_iff_disjoint, ext, count_add, count_union, count_inter, count_zero, Nat.min_eq_zero_iff,\n    Nat.add_eq_max_iff]\n#align add_eq_union_iff_disjoint add_eq_union_iff_disjoint\n\n",
 "add_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ₘ » -/\n@[simp]\ntheorem add_cons (a : α) (s t : Multiset α) : s + «expr ::ₘ » a t = «expr ::ₘ » a (s + t) := by\n  rw [add_comm, cons_add, add_comm]\n#align add_cons add_cons\n\n",
 "add":
 "theorem rel.add {s t u v} (hst : Rel r s t) (huv : Rel r u v) : Rel r (s + u) (t + v) :=\n  by\n  induction hst\n  case zero => simpa using huv\n  case cons a b s t hab hst ih => simpa using ih.cons hab\n#align rel.add rel.add\n\n"}