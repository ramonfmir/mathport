{"replace_aux":
 "theorem valid.replace_aux (a : α) (b : β a) :\n    ∀ l : list (Σa, β a),\n      a ∈ l.map sigma.fst →\n        ∃ (u w : list (Σa, β a))(b' : _), l = u ++ [⟨a, b'⟩] ++ w ∧ replace_aux a b l = u ++ [⟨a, b⟩] ++ w\n  | [] => false.elim\n  | ⟨a', b'⟩ :: t => by\n    by_cases e : a' = a\n    · subst a'\n      suffices\n        ∃ (u w : list (Σa, β a))(b'' : β a),\n          sigma.mk a b' :: t = u ++ ⟨a, b''⟩ :: w ∧ replace_aux a b (⟨a, b'⟩ :: t) = u ++ ⟨a, b⟩ :: w\n        by simpa\n      refine' ⟨[], t, b', _⟩\n      simp [replace_aux]\n    · suffices\n        ∀ (x : β a) (_ : sigma.mk a x ∈ t),\n          ∃ (u w : _)(b'' : β a),\n            sigma.mk a' b' :: t = u ++ ⟨a, b''⟩ :: w ∧ sigma.mk a' b' :: replace_aux a b t = u ++ ⟨a, b⟩ :: w\n        by simpa [replace_aux, ne.symm e, e]\n      intro x m\n      have IH :\n        ∀ (x : β a) (_ : sigma.mk a x ∈ t),\n          ∃ (u w : _)(b'' : β a), t = u ++ ⟨a, b''⟩ :: w ∧ replace_aux a b t = u ++ ⟨a, b⟩ :: w :=\n        by simpa using valid.replace_aux t\n      rcases IH x m with ⟨u, w, b'', hl, hfl⟩\n      exact ⟨⟨a', b'⟩ :: u, w, b'', by simp [hl, hfl.symm, ne.symm e]⟩\n#align valid.replace_aux valid.replace_aux\n\n",
 "replace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem valid.replace {n : «exprℕ+»} {bkts : bucket_array α β n} {sz : ℕ} (a : α) (b : β a)\n    (Hc : contains_aux a (bkts.read hash_fn a)) (v : valid bkts sz) :\n    valid (bkts.modify hash_fn a (replace_aux a b)) sz :=\n  by\n  have nd := v.nodup (mk_idx n (hash_fn a))\n  rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with\n    ⟨u, w, b', hl, hfl⟩\n  simp [hl, List.nodup_append] at nd\n  refine'\n      (v.modify hash_fn u [⟨a, b'⟩] [⟨a, b⟩] w hl hfl (List.nodup_singleton _) (fun a' e => by simp at e <;> rw [e])\n          (fun a' e1 e2 => _) fun a' e1 e2 => _).2 <;>\n    · revert e1\n      simp [-sigma.exists] at e2\n      subst a'\n      simp [nd]\n#align valid.replace valid.replace\n\n",
 "not_contains_empty":
 "theorem not_contains_empty (hash_fn : α → nat) (n a) : ¬(@mk_hash_map α _ β hash_fn n).contains a := by\n  apply Bool.bool_iff_false.2 <;> dsimp [contains] <;> rw [find_empty] <;> rfl\n#align not_contains_empty not_contains_empty\n\n",
 "modify":
 "theorem valid.modify {sz : ℕ} (v : valid bkts sz) :\n    v1.length ≤ sz + v2.length ∧ valid bkts' (sz + v2.length - v1.length) :=\n  by\n  rcases append_of_modify u v1 v2 w hl hfl with ⟨u', w', e₁, e₂⟩\n  rw [← v.len, e₁]\n  suffices valid bkts' (u' ++ v2 ++ w').length by\n    simpa [GE.ge, add_comm, add_left_comm, nat.le_add_right, add_tsub_cancel_left]\n  refine' ⟨congr_arg _ e₂, fun i a => _, fun i => _⟩\n  · by_cases bidx = i\n    · subst i\n      rw [bkts', array.read_write, hfl]\n      have := @valid.idx _ _ _ v bidx a\n      simp only [hl, list.mem_append, or_imp] at this⊢\n      exact ⟨⟨this.1.1, hal _⟩, this.2⟩\n    · rw [bkts', array.read_write_of_ne _ _ h]\n      apply v.idx\n  · by_cases bidx = i\n    · subst i\n      rw [bkts', array.read_write, hfl]\n      have := @valid.nodup _ _ _ v bidx\n      simp [hl, List.nodup_append] at this\n      simp [List.nodup_append, this, hvnd, djuv, djwv.symm]\n    · rw [bkts', array.read_write_of_ne _ _ h]\n      apply v.nodup\n#align valid.modify valid.modify\n\n",
 "mk_valid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem mk_valid (n : «exprℕ+») : @valid n (mkArray' n []) 0 :=\n  ⟨by simp [mk_as_list], fun i a h => by cases h, fun i => List.nodup_nil⟩\n#align mk_valid mk_valid\n\n",
 "mk_as_list":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem mk_as_list (n : «exprℕ+») : bucket_array.as_list (mkArray' n [] : bucket_array α β n) = [] :=\n  List.eq_nil_iff_forall_not_mem.mpr fun x m =>\n    let ⟨i, h⟩ := (bucket_array.mem_as_list _).1 m\n    h\n#align mk_as_list mk_as_list\n\n",
 "mem_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem mem_insert :\n    ∀ (m : hash_map α β) (a b a' b'),\n      (sigma.mk a' b' : sigma β) ∈ (m.insert a b).entries ↔ if a = a' then HEq b b' else sigma.mk a' b' ∈ m.entries\n  | ⟨hash_fn, size, n, bkts, v⟩, a, b, a', b' =>\n    by\n    let bkt := bkts.read hash_fn a\n    have nd : (bkt.map sigma.fst).nodup := v.nodup (mk_idx n (hash_fn a))\n    have lem :\n      ∀ (bkts' : bucket_array α β n) (v1 u w) (hl : bucket_array.as_list bkts = u ++ v1 ++ w)\n        (hfl : bucket_array.as_list bkts' = u ++ [⟨a, b⟩] ++ w)\n        (veq : v1 = [] ∧ ¬contains_aux a bkt ∨ ∃ b'', v1 = [⟨a, b''⟩]),\n        sigma.mk a' b' ∈ bkts'.as_list ↔ if a = a' then HEq b b' else sigma.mk a' b' ∈ bkts.as_list :=\n      by\n      intro bkts' v1 u w hl hfl veq\n      rw [hl, hfl]\n      by_cases h : a = a'\n      · subst a'\n        suffices b = b' ∨ sigma.mk a b' ∈ u ∨ sigma.mk a b' ∈ w ↔ b = b' by simpa [eq_comm, or_left_comm]\n        refine' or_iff_left_of_imp (not.elim <| not_or.2 _)\n        rcases veq with (⟨rfl, Hnc⟩ | ⟨b'', rfl⟩)\n        · have na := (not_congr <| v.contains_aux_iff _ _).1 Hnc\n          simp [hl, not_or] at na\n          simp [na]\n        · have nd' := v.as_list_nodup _\n          simp [hl, List.nodup_append] at nd'\n          simp [nd']\n      · suffices sigma.mk a' b' ∉ v1 by simp [h, ne.symm h, this]\n        rcases veq with (⟨rfl, Hnc⟩ | ⟨b'', rfl⟩) <;> simp [ne.symm h]\n    by_cases Hc : (contains_aux a bkt : Prop)\n    · rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with\n        ⟨u', w', b'', hl', hfl'⟩\n      rcases append_of_modify u' [⟨a, b''⟩] [⟨a, b⟩] w' hl' hfl' with ⟨u, w, hl, hfl⟩\n      simpa [insert, @dif_pos (contains_aux a bkt) _ Hc] using lem _ _ u w hl hfl (or.inr ⟨b'', rfl⟩)\n    · let size' := size + 1\n      let bkts' := bkts.modify hash_fn a fun l => ⟨a, b⟩ :: l\n      have mi : sigma.mk a' b' ∈ bkts'.as_list ↔ if a = a' then HEq b b' else sigma.mk a' b' ∈ bkts.as_list :=\n        let ⟨u, w, hl, hfl⟩ := append_of_modify [] [] [⟨a, b⟩] _ rfl rfl\n        lem bkts' _ u w hl hfl <| or.inl ⟨rfl, Hc⟩\n      simp [insert, @dif_neg (contains_aux a bkt) _ Hc]\n      by_cases h : size' ≤ n\n      · simpa [show size' ≤ n from h] using mi\n      · let n' : «exprℕ+» := ⟨n * 2, mul_pos n.2 (by decide)⟩\n        let bkts'' : bucket_array α β n' := bkts'.foldl (mkArray' _ []) (reinsert_aux hash_fn)\n        suffices sigma.mk a' b' ∈ bkts''.as_list ↔ sigma.mk a' b' ∈ bkts'.as_list.reverse by\n          simpa [show ¬size' ≤ n from h, mi]\n        rw [show bkts'' = bkts'.as_list.foldl _ _ from bkts'.foldl_eq _ _, ← List.foldr_reverse]\n        induction' bkts'.as_list.reverse with a l IH\n        · simp [mk_as_list]\n        · cases' a with a'' b''\n          let B :=\n            l.foldr (fun (y : sigma β) (x : bucket_array α β n') => reinsert_aux hash_fn x y.1 y.2) (mkArray' n' [])\n          rcases append_of_modify [] [] [⟨a'', b''⟩] _ rfl rfl with ⟨u, w, hl, hfl⟩\n          simp [IH.symm, or_left_comm, show B.as_list = _ from hl,\n            show (reinsert_aux hash_fn B a'' b'').as_list = _ from hfl]\n#align mem_insert mem_insert\n\n",
 "mem_erase":
 "theorem mem_erase :\n    ∀ (m : hash_map α β) (a a' b'),\n      (sigma.mk a' b' : sigma β) ∈ (m.erase a).entries ↔ a ≠ a' ∧ sigma.mk a' b' ∈ m.entries\n  | ⟨hash_fn, size, n, bkts, v⟩, a, a', b' =>\n    by\n    let bkt := bkts.read hash_fn a\n    by_cases Hc : (contains_aux a bkt : Prop)\n    · let bkts' := bkts.modify hash_fn a (erase_aux a)\n      suffices sigma.mk a' b' ∈ bkts'.as_list ↔ a ≠ a' ∧ sigma.mk a' b' ∈ bkts.as_list by\n        simpa [erase, @dif_pos (contains_aux a bkt) _ Hc]\n      have nd := v.nodup (mk_idx n (hash_fn a))\n      rcases valid.erase_aux a bkt ((contains_aux_iff nd).1 Hc) with ⟨u', w', b, hl', hfl'⟩\n      rcases append_of_modify u' [⟨a, b⟩] [] _ hl' hfl' with ⟨u, w, hl, hfl⟩\n      suffices ∀ _ : sigma.mk a' b' ∈ u ∨ sigma.mk a' b' ∈ w, a ≠ a'\n        by\n        have :\n          sigma.mk a' b' ∈ u ∨ sigma.mk a' b' ∈ w ↔\n            (¬a = a' ∧ a' = a) ∧ HEq b' b ∨ ¬a = a' ∧ (sigma.mk a' b' ∈ u ∨ sigma.mk a' b' ∈ w) :=\n          by simp [eq_comm, not_and_self_iff, and_iff_right_of_imp this]\n        simpa [hl, show bkts'.as_list = _ from hfl, and_or_left, and_comm', and_left_comm, or_left_comm]\n      rintro m rfl\n      revert m\n      apply not_or.2\n      have nd' := v.as_list_nodup _\n      simp [hl, List.nodup_append] at nd'\n      simp [nd']\n    · suffices ∀ _ : sigma.mk a' b' ∈ bucket_array.as_list bkts, a ≠ a' by\n        simp [erase, @dif_neg (contains_aux a bkt) _ Hc, entries, and_iff_right_of_imp this]\n      rintro m rfl\n      exact Hc ((v.contains_aux_iff _ _).2 (List.mem_map_of_mem sigma.fst m))\n#align mem_erase mem_erase\n\n",
 "mem_as_list":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura, Mario Carneiro\n-/\ntheorem mem_as_list {a : Σa, β a} : a ∈ data.as_list ↔ ∃ i, a ∈ array.read data i :=\n  by\n  have :\n    (∃ (l : list (Σa : α, β a))(i : fin n.val), a ∈ l ∧ array.read data i = l) ↔\n      ∃ i : fin n.val, a ∈ array.read data i :=\n    by rw [exists_swap] <;> exact exists_congr fun i => by simp\n  simp [as_list] <;> simpa [array.mem.def, and_comm']\n#align mem_as_list mem_as_list\n\n",
 "keys_empty":
 "theorem keys_empty (hash_fn : α → nat) (n) : (@mk_hash_map α _ β hash_fn n).keys = [] := by\n  dsimp [keys] <;> rw [entries_empty] <;> rfl\n#align keys_empty keys_empty\n\n",
 "insert_lemma":
 "theorem insert_lemma (hash_fn : α → nat) {n n'} {bkts : bucket_array α β n} {sz} (v : valid hash_fn bkts sz) :\n    valid hash_fn (bkts.foldl (mkArray' _ [] : bucket_array α β n') (reinsert_aux hash_fn)) sz :=\n  by\n  suffices\n    ∀ (l : list (Σa, β a)) (t : bucket_array α β n') (sz),\n      valid hash_fn t sz →\n        ((l ++ t.as_list).map sigma.fst).nodup →\n          valid hash_fn (l.foldl (fun r (a : Σa, β a) => reinsert_aux hash_fn r a.1 a.2) t) (sz + l.length)\n    by\n    have p := this bkts.as_list _ _ (mk_valid _ _)\n    rw [mk_as_list, list.append_nil, zero_add, v.len] at p\n    rw [bucket_array.foldl_eq]\n    exact p (v.as_list_nodup _)\n  intro l\n  induction' l with c l IH <;> intro t sz v nd\n  · exact v\n  rw [show sz + (c :: l).length = sz + 1 + l.length by simp [add_comm, add_assoc]]\n  rcases show\n      (l.map sigma.fst).nodup ∧\n        ((bucket_array.as_list t).map sigma.fst).nodup ∧\n          c.fst ∉ l.map sigma.fst ∧\n            c.fst ∉ (bucket_array.as_list t).map sigma.fst ∧\n              (l.map sigma.fst).disjoint ((bucket_array.as_list t).map sigma.fst)\n      by simpa [List.nodup_append, not_or, and_comm', and_left_comm] using nd with\n    ⟨nd1, nd2, nm1, nm2, dj⟩\n  have v' := v.insert _ _ c.2 fun Hc => nm2 <| (v.contains_aux_iff _ c.1).1 Hc\n  apply IH _ _ v'\n  suffices\n    ∀ ⦃a : α⦄ (b : β a), sigma.mk a b ∈ l → ∀ b' : β a, sigma.mk a b' ∈ (reinsert_aux hash_fn t c.1 c.2).as_list → false\n    by simpa [List.nodup_append, nd1, v'.as_list_nodup _, List.Disjoint]\n  intro a b m1 b' m2\n  rcases(reinsert_aux hash_fn t c.1 c.2).mem_as_list.1 m2 with ⟨i, im⟩\n  have : sigma.mk a b' ∉ array.read t i := by\n    intro m3\n    have : a ∈ list.map sigma.fst t.as_list := List.mem_map_of_mem sigma.fst (t.mem_as_list.2 ⟨_, m3⟩)\n    exact dj (List.mem_map_of_mem sigma.fst m1) this\n  by_cases h : mk_idx n' (hash_fn c.1) = i\n  · subst h\n    have e : sigma.mk a b' = ⟨c.1, c.2⟩ := by simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im\n    injection e with e\n    subst a\n    exact nm1.elim (@List.mem_map_of_mem _ _ sigma.fst _ _ m1)\n  · apply this\n    simpa [reinsert_aux, bucket_array.modify, array.read_write_of_ne _ _ h] using im\n#align insert_lemma insert_lemma\n\n",
 "insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\ntheorem valid.insert {n : «exprℕ+»} {bkts : bucket_array α β n} {sz : ℕ} (a : α) (b : β a)\n    (Hnc : ¬contains_aux a (bkts.read hash_fn a)) (v : valid bkts sz) : valid (reinsert_aux bkts a b) (sz + 1) :=\n  by\n  have nd := v.nodup (mk_idx n (hash_fn a))\n  refine'\n    (v.modify hash_fn [] [] [⟨a, b⟩] (bkts.read hash_fn a) rfl rfl (List.nodup_singleton _)\n        (fun a' e => by simp at e <;> rw [e]) (fun a' => false.elim) fun a' e1 e2 => _).2\n  simp [-sigma.exists] at e2; subst a'\n  exact Hnc ((contains_aux_iff nd).2 e1)\n#align valid.insert valid.insert\n\n",
 "idx_enum_1":
 "theorem valid.idx_enum_1 {n} {bkts : bucket_array α β n} {sz : nat} (v : valid bkts sz) {i l}\n    (he : (i, l) ∈ bkts.to_list.enum) {a} {b : β a} (hl : sigma.mk a b ∈ l) : (mk_idx n (hash_fn a)).1 = i :=\n  by\n  let ⟨h, e⟩ := v.idx_enum _ he hl\n  rw [e] <;> rfl\n#align valid.idx_enum_1 valid.idx_enum_1\n\n",
 "idx_enum":
 "theorem valid.idx_enum {n} {bkts : bucket_array α β n} {sz : nat} (v : valid bkts sz) {i l}\n    (he : (i, l) ∈ bkts.to_list.enum) {a} {b : β a} (hl : sigma.mk a b ∈ l) : ∃ h, mk_idx n (hash_fn a) = ⟨i, h⟩ :=\n  (array.mem_to_list_enum.mp he).imp fun h e => by subst e <;> exact v.idx hl\n#align valid.idx_enum valid.idx_enum\n\n",
 "foldl_eq":
 "theorem foldl_eq {δ : Type w} (d : δ) (f : δ → ∀ a, β a → δ) :\n    data.foldl d f = data.as_list.foldl (fun r a => f r a.1 a.2) d := by\n  rw [foldl, as_list, List.foldl_join, ← array.to_list_foldl]\n#align foldl_eq foldl_eq\n\n",
 "find_insert_ne":
 "theorem find_insert_ne (m : hash_map α β) (a a' : α) (b : β a) (h : a ≠ a') : (m.insert a b).find a' = m.find a' :=\n  option.eq_of_eq_some fun b' =>\n    let t := mem_insert m a b a' b'\n    (find_iff _ _ _).trans <| iff.trans (by rwa [if_neg h] at t) (find_iff _ _ _).symm\n#align find_insert_ne find_insert_ne\n\n",
 "find_insert_eq":
 "theorem find_insert_eq (m : hash_map α β) (a : α) (b : β a) : (m.insert a b).find a = some b :=\n  (find_iff (m.insert a b) a b).2 <| (mem_insert m a b a b).2 <| by rw [if_pos rfl]\n#align find_insert_eq find_insert_eq\n\n",
 "find_insert":
 "theorem find_insert (m : hash_map α β) (a' a : α) (b : β a) :\n    (m.insert a b).find a' = if h : a = a' then some (eq.rec_on h b) else m.find a' :=\n  if h : a = a' then by\n    rw [dif_pos h] <;>\n      exact\n        match a', h with\n        | _, rfl => find_insert_eq m a b\n  else by rw [dif_neg h] <;> exact find_insert_ne m a a' b h\n#align find_insert find_insert\n\n",
 "find_iff":
 "theorem find_iff (m : hash_map α β) (a : α) (b : β a) : m.find a = some b ↔ sigma.mk a b ∈ m.entries :=\n  m.is_valid.find_aux_iff _\n#align find_iff find_iff\n\n",
 "find_erase_ne":
 "theorem find_erase_ne (m : hash_map α β) (a a' : α) (h : a ≠ a') : (m.erase a).find a' = m.find a' :=\n  option.eq_of_eq_some fun b' =>\n    (find_iff _ _ _).trans <| (mem_erase m a a' b').trans <| (and_iff_right h).trans (find_iff _ _ _).symm\n#align find_erase_ne find_erase_ne\n\n",
 "find_erase_eq":
 "theorem find_erase_eq (m : hash_map α β) (a : α) : (m.erase a).find a = none :=\n  by\n  cases' h : (m.erase a).find a with b; · rfl\n  exact absurd rfl ((mem_erase m a a b).1 ((find_iff (m.erase a) a b).1 h)).left\n#align find_erase_eq find_erase_eq\n\n",
 "find_erase":
 "theorem find_erase (m : hash_map α β) (a' a : α) : (m.erase a).find a' = if a = a' then none else m.find a' :=\n  if h : a = a' then by subst a' <;> simp [find_erase_eq m a] else by rw [if_neg h] <;> exact find_erase_ne m a a' h\n#align find_erase find_erase\n\n",
 "find_empty":
 "theorem find_empty (hash_fn : α → nat) (n a) : (@mk_hash_map α _ β hash_fn n).find a = none := by\n  induction' h : (@mk_hash_map α _ β hash_fn n).find a with <;> [rfl,\n    · have := (find_iff _ _ _).1 h\n      rw [entries_empty] at this\n      contradiction]\n#align find_empty find_empty\n\n",
 "find_aux_iff":
 "theorem valid.find_aux_iff {n} {bkts : bucket_array α β n} {sz : nat} (v : valid bkts sz) {a : α} {b : β a} :\n    find_aux a (bkts.read hash_fn a) = some b ↔ sigma.mk a b ∈ bkts.as_list :=\n  (find_aux_iff (v.nodup _)).trans <| by\n    rw [bkts.mem_as_list] <;> exact ⟨fun h => ⟨_, h⟩, fun ⟨i, h⟩ => (v.idx h).symm ▸ h⟩\n#align valid.find_aux_iff valid.find_aux_iff\n\n",
 "erase_aux":
 "theorem valid.erase_aux (a : α) :\n    ∀ l : list (Σa, β a),\n      a ∈ l.map sigma.fst → ∃ (u w : list (Σa, β a))(b : _), l = u ++ [⟨a, b⟩] ++ w ∧ erase_aux a l = u ++ [] ++ w\n  | [] => false.elim\n  | ⟨a', b'⟩ :: t => by\n    by_cases e : a' = a\n    · subst a'\n      simpa [erase_aux, and_comm'] using\n        show ∃ (u w : _)(x : β a), t = u ++ w ∧ sigma.mk a b' :: t = u ++ ⟨a, x⟩ :: w from ⟨[], t, b', by simp⟩\n    · simp [erase_aux, e, ne.symm e]\n      suffices\n        ∀ (b : β a) (_ : sigma.mk a b ∈ t),\n          ∃ (u w : _)(x : β a), sigma.mk a' b' :: t = u ++ ⟨a, x⟩ :: w ∧ sigma.mk a' b' :: erase_aux a t = u ++ w\n        by simpa [replace_aux, ne.symm e, e]\n      intro b m\n      have IH :\n        ∀ (x : β a) (_ : sigma.mk a x ∈ t), ∃ (u w : _)(x : β a), t = u ++ ⟨a, x⟩ :: w ∧ erase_aux a t = u ++ w := by\n        simpa using valid.erase_aux t\n      rcases IH b m with ⟨u, w, b'', hl, hfl⟩\n      exact ⟨⟨a', b'⟩ :: u, w, b'', by simp [hl, hfl.symm]⟩\n#align valid.erase_aux valid.erase_aux\n\n",
 "erase":
 "theorem valid.erase {n} {bkts : bucket_array α β n} {sz} (a : α) (Hc : contains_aux a (bkts.read hash_fn a))\n    (v : valid bkts sz) : valid (bkts.modify hash_fn a (erase_aux a)) (sz - 1) :=\n  by\n  have nd := v.nodup (mk_idx n (hash_fn a))\n  rcases hash_map.valid.erase_aux a (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with\n    ⟨u, w, b, hl, hfl⟩\n  refine' (v.modify hash_fn u [⟨a, b⟩] [] w hl hfl List.nodup_nil _ _ _).2 <;> simp\n#align valid.erase valid.erase\n\n",
 "entries_empty":
 "theorem entries_empty (hash_fn : α → nat) (n) : (@mk_hash_map α _ β hash_fn n).entries = [] :=\n  mk_as_list _\n#align entries_empty entries_empty\n\n",
 "contains_iff":
 "theorem contains_iff (m : hash_map α β) (a : α) : m.contains a ↔ a ∈ m.keys :=\n  m.is_valid.contains_aux_iff _ _\n#align contains_iff contains_iff\n\n",
 "contains_aux_iff":
 "theorem valid.contains_aux_iff {n} {bkts : bucket_array α β n} {sz : nat} (v : valid bkts sz) (a : α) :\n    contains_aux a (bkts.read hash_fn a) ↔ a ∈ bkts.as_list.map sigma.fst := by\n  simp [contains_aux, Option.isSome_iff_exists, v.find_aux_iff hash_fn]\n#align valid.contains_aux_iff valid.contains_aux_iff\n\n",
 "as_list_nodup":
 "theorem valid.as_list_nodup {n} {bkts : bucket_array α β n} {sz : nat} (v : valid bkts sz) :\n    (bkts.as_list.map sigma.fst).nodup :=\n  by\n  suffices (bkts.to_list.map (list.map sigma.fst)).pairwise List.Disjoint\n    by\n    suffices ∀ l, array.mem l bkts → (l.map sigma.fst).nodup by simpa [bucket_array.as_list, List.nodup_join, *]\n    rintro l ⟨i, rfl⟩\n    apply v.nodup\n  rw [← List.enum_map_snd bkts.to_list, List.pairwise_map', List.pairwise_map']\n  have : (bkts.to_list.enum.map prod.fst).nodup := by simp [List.nodup_range]\n  refine' List.Pairwise.imp_of_mem _ ((List.pairwise_map' _).1 this)\n  rw [prod.forall]\n  intro i l₁\n  rw [prod.forall]\n  intro j l₂ me₁ me₂ ij\n  simp [List.Disjoint]\n  intro a b ml₁ b' ml₂\n  apply ij\n  rwa [← v.idx_enum_1 _ me₁ ml₁, ← v.idx_enum_1 _ me₂ ml₂]\n#align valid.as_list_nodup valid.as_list_nodup\n\n",
 "append_of_modify":
 "theorem append_of_modify : ∃ u' w', bkts.as_list = u' ++ v1 ++ w' ∧ bkts'.as_list = u' ++ v2 ++ w' :=\n  by\n  unfold bucket_array.as_list\n  have h : (bidx : ℕ) < bkts.to_list.length := by simp only [bidx.is_lt, array.to_list_length]\n  refine' ⟨(bkts.to_list.take bidx).join ++ u, w ++ (bkts.to_list.drop (bidx + 1)).join, _, _⟩\n  · conv =>\n      lhs\n      rw [← List.take_append_drop bidx bkts.to_list, List.drop_eq_get_cons h]\n      simp [hl]\n    simp\n  · conv =>\n      lhs\n      rw [bkts', array.write_to_list, List.set_eq_take_cons_drop _ h]\n      simp [hfl]\n    simp\n#align append_of_modify append_of_modify\n\n"}