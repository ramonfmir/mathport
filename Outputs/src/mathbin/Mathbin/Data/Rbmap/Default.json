{"to_rbtree_mem'":
 "private theorem to_rbtree_mem' [is_strict_weak_order α lt] {k : α} {m : rbmap α β lt} (v : β) :\n    k ∈ m → rbtree.mem (k, v) m := by\n  intro h\n  cases' to_rbtree_mem h with v' hm\n  apply rbtree.mem_of_mem_of_eqv hm\n  apply eqv_entries\n#align to_rbtree_mem' to_rbtree_mem'\n\n",
 "to_rbtree_mem":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\n-- Auxiliary instances \n-- Helper lemmas for reusing rbtree results.\nprivate theorem to_rbtree_mem {k : α} {m : rbmap α β lt} : k ∈ m → ∃ v : β, rbtree.mem (k, v) m :=\n  by\n  cases' m with n p <;> cases n <;> intro h\n  · exact false.elim h\n  all_goals exists n_val.2; exact h\n#align to_rbtree_mem to_rbtree_mem\n\n",
 "to_rbmap_mem":
 "private theorem to_rbmap_mem [is_strict_weak_order α lt] {k : α} {v : β} {m : rbmap α β lt} :\n    rbtree.mem (k, v) m → k ∈ m := by\n  cases' m with n p <;> cases n <;> intro h\n  · exact false.elim h\n  · simp [has_mem.mem, rbmap.mem]\n    exact @rbtree.mem_of_mem_of_eqv _ _ _ ⟨rbnode.red_node n_lchild n_val n_rchild, p⟩ _ _ h (eqv_entries _ _ _)\n  · simp [has_mem.mem, rbmap.mem]\n    exact @rbtree.mem_of_mem_of_eqv _ _ _ ⟨rbnode.black_node n_lchild n_val n_rchild, p⟩ _ _ h (eqv_entries _ _ _)\n#align to_rbmap_mem to_rbmap_mem\n\n",
 "not_mem_of_find_none":
 "theorem not_mem_of_find_none [is_strict_weak_order α lt] {k : α} {m : rbmap α β lt} : m.find k = none → k ∉ m :=\n  by\n  simp [find]; intro h\n  have := eq_none_of_to_value_eq_none h\n  exact not_mem_of_find_entry_none this\n#align not_mem_of_find_none not_mem_of_find_none\n\n",
 "not_mem_of_find_entry_none":
 "theorem not_mem_of_find_entry_none [is_strict_weak_order α lt] {k : α} {m : rbmap α β lt} :\n    m.find_entry k = none → k ∉ m := by\n  cases' m with t p; cases t <;> simp [find_entry]\n  · intros\n    simp [has_mem.mem, rbmap.mem]\n  all_goals intro h; exact rbtree.not_mem_of_find_none h\n#align not_mem_of_find_entry_none not_mem_of_find_entry_none\n\n",
 "not_mem_of_empty":
 "theorem not_mem_of_empty {m : rbmap α β lt} (k : α) : m.empty = true → k ∉ m := by\n  cases' m with n p <;> cases n <;>\n    simp [has_mem.mem, mk_rbmap, mk_rbtree, rbmap.mem, rbmap.empty, rbtree.empty, false_imp_iff]\n#align not_mem_of_empty not_mem_of_empty\n\n",
 "not_mem_mk_rbmap":
 "-- Lemmas\ntheorem not_mem_mk_rbmap : ∀ k : α, k ∉ mk_rbmap α β lt := by simp [has_mem.mem, mk_rbmap, mk_rbtree, rbmap.mem]\n#align not_mem_mk_rbmap not_mem_mk_rbmap\n\n",
 "min_is_minimal_of_total":
 "theorem min_is_minimal_of_total [is_strict_total_order α lt] {k : α} {v : β} {m : rbmap α β lt} :\n    m.min = some (k, v) → ∀ {k'}, k' ∈ m → k = k' ∨ lt k k' := fun h k' hm =>\n  match min_is_minimal h hm with\n  | or.inl h => or.inl (eq_of_eqv_lt h)\n  | or.inr h => or.inr h\n#align min_is_minimal_of_total min_is_minimal_of_total\n\n",
 "min_is_minimal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem min_is_minimal [is_strict_weak_order α lt] {k : α} {v : β} {m : rbmap α β lt} :\n    m.min = some (k, v) → ∀ {k'}, k' ∈ m → «expr ≈[ ] » k lt k' ∨ lt k k' := fun h k' hm =>\n  or.elim (rbtree.min_is_minimal h (to_rbtree_mem' v hm)) (fun h => or.inl (eqv_keys_of_eqv_entries h)) fun h =>\n    or.inr h\n#align min_is_minimal min_is_minimal\n\n",
 "mem_of_min_eq":
 "theorem mem_of_min_eq [is_strict_total_order α lt] {k : α} {v : β} {m : rbmap α β lt} : m.min = some (k, v) → k ∈ m :=\n  fun h => to_rbmap_mem (rbtree.mem_of_min_eq h)\n#align mem_of_min_eq mem_of_min_eq\n\n",
 "mem_of_mem_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem mem_of_mem_of_eqv [is_strict_weak_order α lt] {m : rbmap α β lt} {k₁ k₂ : α} :\n    k₁ ∈ m → «expr ≈[ ] » k₁ lt k₂ → k₂ ∈ m := by\n  intro h₁ h₂\n  have h₁ := to_rbtree_mem h₁; cases' h₁ with v h₁\n  exact to_rbmap_mem (rbtree.mem_of_mem_of_eqv h₁ (eqv_entries_of_eqv_keys v v h₂))\n#align mem_of_mem_of_eqv mem_of_mem_of_eqv\n\n",
 "mem_of_max_eq":
 "theorem mem_of_max_eq [is_strict_total_order α lt] {k : α} {v : β} {m : rbmap α β lt} : m.max = some (k, v) → k ∈ m :=\n  fun h => to_rbmap_mem (rbtree.mem_of_max_eq h)\n#align mem_of_max_eq mem_of_max_eq\n\n",
 "mem_of_find_some":
 "theorem mem_of_find_some [is_strict_weak_order α lt] {k : α} {v : β} {m : rbmap α β lt} : m.find k = some v → k ∈ m :=\n  by\n  simp [find]; intro h\n  have := eq_some_of_to_value_eq_some h\n  cases' this with _ he\n  exact mem_of_find_entry_some he\n#align mem_of_find_some mem_of_find_some\n\n",
 "mem_of_find_entry_some":
 "theorem mem_of_find_entry_some [is_strict_weak_order α lt] {k₁ : α} {e : α × β} {m : rbmap α β lt} :\n    m.find_entry k₁ = some e → k₁ ∈ m := by\n  cases' m with t p; cases t <;> simp [find_entry, false_imp_iff]\n  all_goals intro h; exact rbtree.mem_of_find_some h\n#align mem_of_find_entry_some mem_of_find_entry_some\n\n",
 "mem_insert_of_mem":
 "theorem mem_insert_of_mem [is_strict_weak_order α lt] {k₁ : α} {m : rbmap α β lt} (k₂ : α) (v : β) :\n    k₁ ∈ m → k₁ ∈ m.insert k₂ v := fun h => to_rbmap_mem (rbtree.mem_insert_of_mem (k₂, v) (to_rbtree_mem' v h))\n#align mem_insert_of_mem mem_insert_of_mem\n\n",
 "mem_insert_of_incomp":
 "theorem mem_insert_of_incomp [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    ¬lt k₁ k₂ ∧ ¬lt k₂ k₁ → k₁ ∈ m.insert k₂ v := fun h =>\n  to_rbmap_mem (rbtree.mem_insert_of_incomp m (eqv_entries_of_eqv_keys v v h))\n#align mem_insert_of_incomp mem_insert_of_incomp\n\n",
 "mem_insert_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem mem_insert_of_equiv [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    «expr ≈[ ] » k₁ lt k₂ → k₁ ∈ m.insert k₂ v :=\n  mem_insert_of_incomp m v\n#align mem_insert_of_equiv mem_insert_of_equiv\n\n",
 "mem_insert":
 "theorem mem_insert [is_strict_weak_order α lt] (k : α) (m : rbmap α β lt) (v : β) : k ∈ m.insert k v :=\n  to_rbmap_mem (rbtree.mem_insert (k, v) m)\n#align mem_insert mem_insert\n\n",
 "max_is_maximal_of_total":
 "theorem max_is_maximal_of_total [is_strict_total_order α lt] {k : α} {v : β} {m : rbmap α β lt} :\n    m.max = some (k, v) → ∀ {k'}, k' ∈ m → k = k' ∨ lt k' k := fun h k' hm =>\n  match max_is_maximal h hm with\n  | or.inl h => or.inl (eq_of_eqv_lt h)\n  | or.inr h => or.inr h\n#align max_is_maximal_of_total max_is_maximal_of_total\n\n",
 "max_is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem max_is_maximal [is_strict_weak_order α lt] {k : α} {v : β} {m : rbmap α β lt} :\n    m.max = some (k, v) → ∀ {k'}, k' ∈ m → «expr ≈[ ] » k lt k' ∨ lt k' k := fun h k' hm =>\n  or.elim (rbtree.max_is_maximal h (to_rbtree_mem' v hm)) (fun h => or.inl (eqv_keys_of_eqv_entries h)) fun h =>\n    or.inr h\n#align max_is_maximal max_is_maximal\n\n",
 "incomp_or_mem_of_mem_ins":
 "theorem incomp_or_mem_of_mem_ins [is_strict_weak_order α lt] {k₁ k₂ : α} {v : β} {m : rbmap α β lt} :\n    k₁ ∈ m.insert k₂ v → ¬lt k₁ k₂ ∧ ¬lt k₂ k₁ ∨ k₁ ∈ m :=\n  equiv_or_mem_of_mem_insert\n#align incomp_or_mem_of_mem_ins incomp_or_mem_of_mem_ins\n\n",
 "find_insert_of_not_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_insert_of_not_eqv [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    ¬«expr ≈[ ] » k₁ lt k₂ → (m.insert k₁ v).find k₂ = m.find k₂ := by intro h;\n  have := find_entry_insert_of_not_eqv m v h; simp [find, this]\n#align find_insert_of_not_eqv find_insert_of_not_eqv\n\n",
 "find_insert_of_ne":
 "theorem find_insert_of_ne [is_strict_total_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    k₁ ≠ k₂ → (m.insert k₁ v).find k₂ = m.find k₂ := by intro h; have := find_entry_insert_of_ne m v h;\n  simp [find, this]\n#align find_insert_of_ne find_insert_of_ne\n\n",
 "find_insert_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_insert_of_eqv [is_strict_weak_order α lt] (m : rbmap α β lt) {k₁ k₂ : α} (v : β) :\n    «expr ≈[ ] » k₁ lt k₂ → (m.insert k₁ v).find k₂ = some v :=\n  by\n  intro h\n  have := find_entry_insert_of_eqv m v h\n  simp [find, this, to_value]\n#align find_insert_of_eqv find_insert_of_eqv\n\n",
 "find_insert_of_disj":
 "theorem find_insert_of_disj [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    lt k₁ k₂ ∨ lt k₂ k₁ → (m.insert k₁ v).find k₂ = m.find k₂ := by intro h; have := find_entry_insert_of_disj m v h;\n  simp [find, this]\n#align find_insert_of_disj find_insert_of_disj\n\n",
 "find_insert":
 "theorem find_insert [is_strict_weak_order α lt] (m : rbmap α β lt) (k : α) (v : β) : (m.insert k v).find k = some v :=\n  find_insert_of_eqv m v (refl k)\n#align find_insert find_insert\n\n",
 "find_eq_find_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_eq_find_of_eqv [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) :\n    «expr ≈[ ] » k₁ lt k₂ → m.find k₁ = m.find k₂ := by intro h; simp [find]; apply congr_arg;\n  apply find_entry_eq_find_entry_of_eqv; assumption\n#align find_eq_find_of_eqv find_eq_find_of_eqv\n\n",
 "find_entry_insert_of_not_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_entry_insert_of_not_eqv [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    ¬«expr ≈[ ] » k₁ lt k₂ → (m.insert k₁ v).find_entry k₂ = m.find_entry k₂ :=\n  by\n  intro hn\n  have he : lt k₁ k₂ ∨ lt k₂ k₁ :=\n    by\n    simp [strict_weak_order.equiv, decidable.not_and_iff_or_not, decidable.not_not_iff] at hn\n    assumption\n  apply find_entry_insert_of_disj _ _ he\n#align find_entry_insert_of_not_eqv find_entry_insert_of_not_eqv\n\n",
 "find_entry_insert_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_entry_insert_of_ne [is_strict_total_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    k₁ ≠ k₂ → (m.insert k₁ v).find_entry k₂ = m.find_entry k₂ :=\n  by\n  intro h\n  have : ¬«expr ≈[ ] » k₁ lt k₂ := fun h' => h (eq_of_eqv_lt h')\n  apply find_entry_insert_of_not_eqv _ _ this\n#align find_entry_insert_of_ne find_entry_insert_of_ne\n\n",
 "find_entry_insert_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_entry_insert_of_eqv [is_strict_weak_order α lt] (m : rbmap α β lt) {k₁ k₂ : α} (v : β) :\n    «expr ≈[ ] » k₁ lt k₂ → (m.insert k₁ v).find_entry k₂ = some (k₁, v) :=\n  by\n  intro h\n  generalize h₁ : m.insert k₁ v = m'\n  cases' m' with t p; cases t\n  · have := mem_insert k₁ m v\n    rw [h₁] at this\n    apply absurd this\n    apply not_mem_mk_rbmap\n  all_goals\n    simp [find_entry]; rw [← h₁, insert]; apply rbtree.find_insert_of_eqv\n    apply eqv_entries_of_eqv_keys _ _ h\n#align find_entry_insert_of_eqv find_entry_insert_of_eqv\n\n",
 "find_entry_insert_of_disj":
 "theorem find_entry_insert_of_disj [is_strict_weak_order α lt] {k₁ k₂ : α} (m : rbmap α β lt) (v : β) :\n    lt k₁ k₂ ∨ lt k₂ k₁ → (m.insert k₁ v).find_entry k₂ = m.find_entry k₂ :=\n  by\n  intro h\n  have h' : ∀ {v₁ v₂ : β}, (rbmap_lt lt) (k₁, v₁) (k₂, v₂) ∨ (rbmap_lt lt) (k₂, v₂) (k₁, v₁) := fun _ _ => h\n  generalize h₁ : m = m₁\n  generalize h₂ : insert m₁ k₁ v = m₂\n  rw [← h₁] at h₂⊢; rw [← h₂]\n  cases' m₁ with t₁ p₁ <;> cases t₁ <;> cases' m₂ with t₂ p₂ <;> cases t₂\n  · rw [h₂, h₁]\n  iterate 2 \n    rw [h₂]\n    conv =>\n      lhs\n      simp [find_entry]\n    rw [← h₂, insert, rbtree.find_insert_of_disj _ h', h₁]\n    rfl\n  any_goals\n    simp [insert] at h₂\n    exact absurd h₂ (rbtree.insert_ne_mk_rbtree m (k₁, v))\n  any_goals\n    rw [h₂, h₁]; simp [find_entry]; rw [← h₂, ← h₁, insert, rbtree.find_insert_of_disj _ h']\n    apply rbtree.find_eq_find_of_eqv; apply eqv_entries\n#align find_entry_insert_of_disj find_entry_insert_of_disj\n\n",
 "find_entry_insert":
 "theorem find_entry_insert [is_strict_weak_order α lt] (m : rbmap α β lt) (k : α) (v : β) :\n    (m.insert k v).find_entry k = some (k, v) :=\n  find_entry_insert_of_eqv m v (refl k)\n#align find_entry_insert find_entry_insert\n\n",
 "find_entry_eq_find_entry_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_entry_eq_find_entry_of_eqv [is_strict_weak_order α lt] {m : rbmap α β lt} {k₁ k₂ : α} :\n    «expr ≈[ ] » k₁ lt k₂ → m.find_entry k₁ = m.find_entry k₂ :=\n  by\n  intro h; cases' m with t p; cases t <;> simp [find_entry]\n  all_goals apply rbtree.find_eq_find_of_eqv; apply eqv_entries_of_eqv_keys; assumption\n#align find_entry_eq_find_entry_of_eqv find_entry_eq_find_entry_of_eqv\n\n",
 "find_entry_correct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_entry_correct [is_strict_weak_order α lt] (k : α) (m : rbmap α β lt) :\n    k ∈ m ↔ ∃ e, m.find_entry k = some e ∧ «expr ≈[ ] » k lt e.1 :=\n  by\n  apply iff.intro <;> cases' m with t p\n  · intro h\n    have h := to_rbtree_mem h\n    cases' h with v h₁\n    have hex := Iff.mp (rbtree.find_correct _ _) h₁\n    cases' hex with e h₂\n    exists e\n    cases t <;> simp [find_entry] at h₂⊢\n    · simp [rbtree.find, rbnode.find] at h₂\n      cases h₂\n    · cases' h₂ with h₂₁ h₂₂\n      constructor\n      · have := rbtree.find_eq_find_of_eqv ⟨rbnode.red_node t_lchild t_val t_rchild, p⟩ (eqv_entries k v t_val.2)\n        rw [← this]\n        exact h₂₁\n      · cases e\n        apply eqv_keys_of_eqv_entries h₂₂\n    · cases' h₂ with h₂₁ h₂₂\n      constructor\n      · have := rbtree.find_eq_find_of_eqv ⟨rbnode.black_node t_lchild t_val t_rchild, p⟩ (eqv_entries k v t_val.2)\n        rw [← this]\n        exact h₂₁\n      · cases e\n        apply eqv_keys_of_eqv_entries h₂₂\n  · intro h\n    cases' h with e h\n    cases' h with h₁ h₂\n    cases t <;> simp [find_entry] at h₁\n    · contradiction\n    all_goals exact to_rbmap_mem (rbtree.mem_of_find_some h₁)\n#align find_entry_correct find_entry_correct\n\n",
 "find_correct":
 "theorem find_correct [is_strict_weak_order α lt] (k : α) (m : rbmap α β lt) : k ∈ m ↔ ∃ v, m.find k = some v :=\n  by\n  apply iff.intro\n  · intro h\n    have := Iff.mp (find_entry_correct k m) h\n    cases' this with e h\n    cases' h with h₁ h₂\n    exists e.2\n    simp [find, h₁, to_value]\n  · intro h\n    cases' h with v h\n    simp [find] at h\n    have h := eq_some_of_to_value_eq_some h\n    cases' h with k' h\n    have heqv := eqv_of_find_entry_some h\n    exact Iff.mpr (find_entry_correct k m) ⟨(k', v), ⟨h, heqv⟩⟩\n#align find_correct find_correct\n\n",
 "eqv_of_find_entry_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem eqv_of_find_entry_some [is_strict_weak_order α lt] {k₁ k₂ : α} {v : β} {m : rbmap α β lt} :\n    m.find_entry k₁ = some (k₂, v) → «expr ≈[ ] » k₁ lt k₂ :=\n  by\n  cases' m with t p; cases t <;> simp [find_entry, false_imp_iff]\n  all_goals intro h; exact eqv_keys_of_eqv_entries (rbtree.eqv_of_find_some h)\n#align eqv_of_find_entry_some eqv_of_find_entry_some\n\n",
 "eqv_keys_of_eqv_entries":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\nprivate theorem eqv_keys_of_eqv_entries {k₁ k₂ : α} {v₁ v₂ : β} :\n    «expr ≈[ ] » (k₁, v₁) (rbmap_lt lt) (k₂, v₂) → «expr ≈[ ] » k₁ lt k₂ :=\n  id\n#align eqv_keys_of_eqv_entries eqv_keys_of_eqv_entries\n\n",
 "eqv_entries_of_eqv_keys":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\nprivate theorem eqv_entries_of_eqv_keys {k₁ k₂ : α} (v₁ v₂ : β) :\n    «expr ≈[ ] » k₁ lt k₂ → «expr ≈[ ] » (k₁, v₁) (rbmap_lt lt) (k₂, v₂) :=\n  id\n#align eqv_entries_of_eqv_keys eqv_entries_of_eqv_keys\n\n",
 "eqv_entries":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\nprivate theorem eqv_entries [is_irrefl α lt] (k : α) (v₁ v₂ : β) : «expr ≈[ ] » (k, v₁) (rbmap_lt lt) (k, v₂) :=\n  and.intro (irrefl_of lt k) (irrefl_of lt k)\n#align eqv_entries eqv_entries\n\n",
 "equiv_or_mem_of_mem_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem equiv_or_mem_of_mem_insert [is_strict_weak_order α lt] {k₁ k₂ : α} {v : β} {m : rbmap α β lt} :\n    k₁ ∈ m.insert k₂ v → «expr ≈[ ] » k₁ lt k₂ ∨ k₁ ∈ m := fun h =>\n  or.elim (rbtree.equiv_or_mem_of_mem_insert (to_rbtree_mem' v h)) (fun h => or.inl (eqv_keys_of_eqv_entries h))\n    fun h => or.inr (to_rbmap_mem h)\n#align equiv_or_mem_of_mem_insert equiv_or_mem_of_mem_insert\n\n",
 "eq_some_of_to_value_eq_some":
 "theorem eq_some_of_to_value_eq_some {e : Option (α × β)} {v : β} : to_value e = some v → ∃ k, e = some (k, v) :=\n  by\n  cases' e with val <;> simp [to_value, false_imp_iff]\n  · cases val\n    simp\n#align eq_some_of_to_value_eq_some eq_some_of_to_value_eq_some\n\n",
 "eq_or_mem_of_mem_ins":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem eq_or_mem_of_mem_ins [is_strict_total_order α lt] {k₁ k₂ : α} {v : β} {m : rbmap α β lt} :\n    k₁ ∈ m.insert k₂ v → k₁ = k₂ ∨ k₁ ∈ m := fun h =>\n  suffices «expr ≈[ ] » k₁ lt k₂ ∨ k₁ ∈ m by simp [eqv_lt_iff_eq] at this <;> assumption\n  incomp_or_mem_of_mem_ins h\n#align eq_or_mem_of_mem_ins eq_or_mem_of_mem_ins\n\n",
 "eq_of_find_entry_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem eq_of_find_entry_some [is_strict_total_order α lt] {k₁ k₂ : α} {v : β} {m : rbmap α β lt} :\n    m.find_entry k₁ = some (k₂, v) → k₁ = k₂ := fun h =>\n  suffices «expr ≈[ ] » k₁ lt k₂ from eq_of_eqv_lt this\n  eqv_of_find_entry_some h\n#align eq_of_find_entry_some eq_of_find_entry_some\n\n",
 "eq_none_of_to_value_eq_none":
 "theorem eq_none_of_to_value_eq_none {e : Option (α × β)} : to_value e = none → e = none := by\n  cases e <;> simp [to_value, false_imp_iff]\n#align eq_none_of_to_value_eq_none eq_none_of_to_value_eq_none\n\n",
 "eq_leaf_of_min_eq_none":
 "theorem eq_leaf_of_min_eq_none {m : rbmap α β lt} : m.min = none → m = mk_rbmap α β lt :=\n  rbtree.eq_leaf_of_min_eq_none\n#align eq_leaf_of_min_eq_none eq_leaf_of_min_eq_none\n\n",
 "eq_leaf_of_max_eq_none":
 "theorem eq_leaf_of_max_eq_none {m : rbmap α β lt} : m.max = none → m = mk_rbmap α β lt :=\n  rbtree.eq_leaf_of_max_eq_none\n#align eq_leaf_of_max_eq_none eq_leaf_of_max_eq_none\n\n",
 "constains_correct":
 "theorem constains_correct [is_strict_weak_order α lt] (k : α) (m : rbmap α β lt) : k ∈ m ↔ m.contains k = true :=\n  by\n  apply iff.intro\n  · intro h\n    have h := Iff.mp (find_entry_correct k m) h\n    cases' h with e h\n    cases' h with h₁ h₂\n    simp [contains, h₁, option.is_some]\n  · simp [contains]\n    intro h\n    generalize he : find_entry m k = e\n    cases e\n    · simp [he, option.is_some] at h\n      contradiction\n    · exact mem_of_find_entry_some he\n#align constains_correct constains_correct\n\n"}