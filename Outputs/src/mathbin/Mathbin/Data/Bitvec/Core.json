{"to_nat_of_nat":
 "theorem to_nat_of_nat {k n : ℕ} : bitvec.to_nat (bitvec.of_nat k n) = n % 2 ^ k :=\n  by\n  induction' k with k ih generalizing n\n  · simp [nat.mod_one]\n    rfl\n  · rw [of_nat_succ, to_nat_append, ih, bits_to_nat_to_bool, mod_pow_succ, nat.mul_comm]\n#align to_nat_of_nat to_nat_of_nat\n\n",
 "to_nat_append":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ++ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\n-- mul_left_comm\ntheorem to_nat_append {m : ℕ} (xs : bitvec m) (b : bool) :\n    bitvec.to_nat («expr ++ₜ » xs («expr ::ᵥ » b nil)) = bitvec.to_nat xs * 2 + bitvec.to_nat («expr ::ᵥ » b nil) :=\n  by\n  cases' xs with xs P\n  simp [bits_to_nat_to_list]; clear P\n  unfold bits_to_nat list.foldl\n  -- generalize the accumulator of foldl\n  generalize h : 0 = x;\n  conv in add_lsb x b => rw [← h]; clear h\n  simp\n  induction' xs with x xs generalizing x\n  · simp\n    unfold list.foldl add_lsb\n    simp [nat.mul_succ]\n  · simp\n    apply xs_ih\n#align to_nat_append to_nat_append\n\n",
 "of_nat_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ++ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem of_nat_succ {k n : ℕ} :\n    bitvec.of_nat (succ k) n = «expr ++ₜ » (bitvec.of_nat k (n / 2)) («expr ::ᵥ » (decide (n % 2 = 1)) nil) :=\n  rfl\n#align of_nat_succ of_nat_succ\n\n",
 "bits_to_nat_to_list":
 "/-\nCopyright (c) 2015 Joe Hendrix. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joe Hendrix, Sebastian Ullrich\n-/\ntheorem bits_to_nat_to_list {n : ℕ} (x : bitvec n) : bitvec.to_nat x = bits_to_nat (Vector.toList x) :=\n  rfl\n#align bits_to_nat_to_list bits_to_nat_to_list\n\n",
 "bits_to_nat_to_bool":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ::ᵥ » -/\ntheorem bits_to_nat_to_bool (n : ℕ) : bitvec.to_nat («expr ::ᵥ » (decide (n % 2 = 1)) nil) = n % 2 :=\n  by\n  simp [bits_to_nat_to_list]\n  unfold bits_to_nat add_lsb list.foldl cond\n  simp [cond_to_bool_mod_two]\n#align bits_to_nat_to_bool bits_to_nat_to_bool\n\n"}