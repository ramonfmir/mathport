{"support_sum_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem finset.support_sum_subset [add_comm_monoid M] (s : Finset («expr →₀ » ι M)) :\n    (s.sum id).support ⊆ finset.sup s finsupp.support := by classical convert multiset.support_sum_subset s.1 <;> simp\n#align finset.support_sum_subset finset.support_sum_subset\n\n",
 "support_sum_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem finset.support_sum_eq [add_comm_monoid M] (s : Finset («expr →₀ » ι M))\n    (hs : (s : set («expr →₀ » ι M)).pairwise_disjoint finsupp.support) :\n    (s.sum id).support = finset.sup s finsupp.support := by\n  classical\n    convert multiset.support_sum_eq s.1 _\n    · exact (finset.sum_val _).symm\n    · obtain ⟨l, hl, hn⟩ : ∃ l : list («expr →₀ » ι M), l.to_finset = s ∧ l.nodup :=\n        by\n        refine' ⟨s.to_list, _, Finset.nodup_toList _⟩\n        simp\n      subst hl\n      rwa [List.toFinset_val, list.dedup_eq_self.mpr hn, Multiset.pairwise_coe_iff_pairwise, ←\n        list.pairwise_disjoint_iff_coe_to_finset_pairwise_disjoint hn]\n      intro x y hxy\n      exact symmetric_disjoint hxy\n#align finset.support_sum_eq finset.support_sum_eq\n\n",
 "mem_sup_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem finset.mem_sup_support_iff [Zero M] {s : Finset («expr →₀ » ι M)} {x : ι} :\n    x ∈ s.sup finsupp.support ↔ ∃ (f : «expr →₀ » ι M)(hf : f ∈ s), x ∈ f.support :=\n  multiset.mem_sup_map_support_iff\n#align finset.mem_sup_support_iff finset.mem_sup_support_iff\n\n",
 "mem_sup_map_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem multiset.mem_sup_map_support_iff [Zero M] {s : Multiset («expr →₀ » ι M)} {x : ι} :\n    x ∈ (s.map finsupp.support).sup ↔ ∃ (f : «expr →₀ » ι M)(hf : f ∈ s), x ∈ f.support :=\n  Quot.inductionOn s fun _ => by simpa using list.mem_foldr_sup_support_iff\n#align multiset.mem_sup_map_support_iff multiset.mem_sup_map_support_iff\n\n",
 "mem_foldr_sup_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem list.mem_foldr_sup_support_iff [Zero M] {l : list («expr →₀ » ι M)} {x : ι} :\n    x ∈ l.foldr ((«expr ⊔ » · ·) ∘ finsupp.support) ∅ ↔ ∃ (f : «expr →₀ » ι M)(hf : f ∈ l), x ∈ f.support :=\n  by\n  simp only [Finset.sup_eq_union, List.foldr_map, finsupp.mem_support_iff, exists_prop]\n  induction' l with hd tl IH\n  · simp\n  · simp only [IH, List.foldr_cons, Finset.mem_union, finsupp.mem_support_iff, List.mem_cons]\n    constructor\n    · rintro (h | h)\n      · exact ⟨hd, or.inl rfl, h⟩\n      · exact h.imp fun f hf => hf.imp_left or.inr\n    · rintro ⟨f, rfl | hf, h⟩\n      · exact or.inl h\n      · exact or.inr ⟨f, hf, h⟩\n#align list.mem_foldr_sup_support_iff list.mem_foldr_sup_support_iff\n\n"}