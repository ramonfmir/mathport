{"support_sum_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Finset.support_sum_subset /-\ntheorem Finset.support_sum_subset [AddCommMonoid M] (s : Finset («expr →₀ » ι M)) :\n    (s.sum id).support ⊆ Finset.sup s Finsupp.support := by classical convert Multiset.support_sum_subset s.1 <;> simp\n#align finset.support_sum_subset Finset.support_sum_subset\n-/\n\n",
 "support_sum_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Finset.support_sum_eq /-\ntheorem Finset.support_sum_eq [AddCommMonoid M] (s : Finset («expr →₀ » ι M))\n    (hs : (s : Set («expr →₀ » ι M)).pairwise_disjoint Finsupp.support) :\n    (s.sum id).support = Finset.sup s Finsupp.support := by\n  classical\n    convert Multiset.support_sum_eq s.1 _\n    · exact (Finset.sum_val _).symm\n    · obtain ⟨l, hl, hn⟩ : ∃ l : List («expr →₀ » ι M), l.to_finset = s ∧ l.nodup :=\n        by\n        refine' ⟨s.to_list, _, Finset.nodup_toList _⟩\n        simp\n      subst hl\n      rwa [List.toFinset_val, list.dedup_eq_self.mpr hn, Multiset.pairwise_coe_iff_pairwise, ←\n        List.pairwiseDisjoint_iff_coe_toFinset_pairwise_disjoint hn]\n      intro x y hxy\n      exact symmetric_disjoint hxy\n#align finset.support_sum_eq Finset.support_sum_eq\n-/\n\n",
 "mem_sup_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Finset.mem_sup_support_iff /-\ntheorem Finset.mem_sup_support_iff [Zero M] {s : Finset («expr →₀ » ι M)} {x : ι} :\n    x ∈ s.sup Finsupp.support ↔ ∃ (f : «expr →₀ » ι M)(hf : f ∈ s), x ∈ f.support :=\n  Multiset.mem_sup_map_support_iff\n#align finset.mem_sup_support_iff Finset.mem_sup_support_iff\n-/\n\n",
 "mem_sup_map_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Multiset.mem_sup_map_support_iff /-\ntheorem Multiset.mem_sup_map_support_iff [Zero M] {s : Multiset («expr →₀ » ι M)} {x : ι} :\n    x ∈ (s.map Finsupp.support).sup ↔ ∃ (f : «expr →₀ » ι M)(hf : f ∈ s), x ∈ f.support :=\n  Quot.inductionOn s fun _ => by simpa using List.mem_foldr_sup_support_iff\n#align multiset.mem_sup_map_support_iff Multiset.mem_sup_map_support_iff\n-/\n\n",
 "mem_foldr_sup_support_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print List.mem_foldr_sup_support_iff /-\ntheorem List.mem_foldr_sup_support_iff [Zero M] {l : List («expr →₀ » ι M)} {x : ι} :\n    x ∈ l.foldr ((«expr ⊔ » · ·) ∘ Finsupp.support) ∅ ↔ ∃ (f : «expr →₀ » ι M)(hf : f ∈ l), x ∈ f.support :=\n  by\n  simp only [Finset.sup_eq_union, List.foldr_map, Finsupp.mem_support_iff, exists_prop]\n  induction' l with hd tl IH\n  · simp\n  · simp only [IH, List.foldr_cons, Finset.mem_union, Finsupp.mem_support_iff, List.mem_cons]\n    constructor\n    · rintro (h | h)\n      · exact ⟨hd, or.inl rfl, h⟩\n      · exact h.imp fun f hf => hf.imp_left or.inr\n    · rintro ⟨f, rfl | hf, h⟩\n      · exact or.inl h\n      · exact or.inr ⟨f, hf, h⟩\n#align list.mem_foldr_sup_support_iff List.mem_foldr_sup_support_iff\n-/\n\n"}