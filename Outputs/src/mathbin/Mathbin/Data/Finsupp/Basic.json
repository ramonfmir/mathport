{"zero_not_mem_frange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem zero_not_mem_frange {f : «expr →₀ » α M} : (0 : M) ∉ f.frange := fun H => (mem_frange.1 H).1 rfl\n#align zero_not_mem_frange zero_not_mem_frange\n\n",
 "zero_hom_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.zero_hom_id : map_range.zero_hom (ZeroHom.id M) = ZeroHom.id («expr →₀ » α M) :=\n  ZeroHom.ext map_range_id\n#align map_range.zero_hom_id map_range.zero_hom_id\n\n",
 "zero_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.zero_hom_comp (f : ZeroHom N P) (f₂ : ZeroHom M N) :\n    (map_range.zero_hom (f.comp f₂) : ZeroHom («expr →₀ » α _) _) =\n      (map_range.zero_hom f).comp (map_range.zero_hom f₂) :=\n  ZeroHom.ext <| map_range_comp _ _ _ _ _\n#align map_range.zero_hom_comp map_range.zero_hom_comp\n\n",
 "to_alist_lookup_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem _root_.finsupp.to_alist_lookup_finsupp (f : «expr →₀ » α M) : f.to_alist.lookup_finsupp = f :=\n  by\n  ext\n  by_cases h : f a = 0\n  · suffices f.to_alist.lookup a = none by simp [h, this]\n    · simp [lookup_eq_none, h]\n  · suffices f.to_alist.lookup a = some (f a) by simp [h, this]\n    · apply mem_lookup_iff.2\n      simpa using h\n#align finsupp.to_alist_lookup_finsupp finsupp.to_alist_lookup_finsupp\n\n",
 "to_alist_keys_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem to_alist_keys_to_finset (f : «expr →₀ » α M) : f.to_alist.keys.to_finset = f.support :=\n  by\n  ext\n  simp [to_alist, AList.mem_keys, AList.keys, List.keys]\n#align to_alist_keys_to_finset to_alist_keys_to_finset\n\n",
 "support_subtype_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem support_subtype_domain [D : decidable_pred p] {f : «expr →₀ » α M} :\n    (subtype_domain p f).support = f.support.subtype p := by rw [subsingleton.elim D] <;> rfl\n#align support_subtype_domain support_subtype_domain\n\n",
 "support_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem support_smul_eq [Semiring R] [add_comm_monoid M] [Module R M] [NoZeroSMulDivisors R M] {b : R} (hb : b ≠ 0)\n    {g : «expr →₀ » α M} : («expr • » b g).support = g.support :=\n  Finset.ext fun a => by simp [finsupp.smul_apply, hb]\n#align support_smul_eq support_smul_eq\n\n",
 "support_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem support_smul {_ : monoid R} [add_monoid M] [DistribMulAction R M] {b : R} {g : «expr →₀ » α M} :\n    («expr • » b g).support ⊆ g.support := fun a =>\n  by\n  simp only [smul_apply, mem_support_iff, ne.def]\n  exact mt fun h => h.symm ▸ smul_zero _\n#align support_smul support_smul\n\n",
 "support_filter":
 "@[simp]\ntheorem support_filter [D : decidable_pred p] : (f.filter p).support = f.support.filter p := by\n  rw [subsingleton.elim D] <;> rfl\n#align support_filter support_filter\n\n",
 "support_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem support_curry [decidable_eq α] (f : «expr →₀ » (α × β) M) : f.curry.support ⊆ f.support.image prod.fst :=\n  by\n  rw [← Finset.bunionᵢ_singleton]\n  refine' Finset.Subset.trans support_sum _\n  refine' Finset.bunionᵢ_mono fun a _ => support_single_subset\n#align support_curry support_curry\n\n",
 "sum_update_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_update_add [add_comm_monoid α] [add_comm_monoid β] (f : «expr →₀ » ι α) (i : ι) (a : α) (g : ι → α → β)\n    (hg : ∀ i, g i 0 = 0) (hgg : ∀ (j : ι) (a₁ a₂ : α), g j (a₁ + a₂) = g j a₁ + g j a₂) :\n    (f.update i a).sum g + g i (f i) = f.sum g + g i a :=\n  by\n  rw [update_eq_erase_add_single, sum_add_index' hg hgg]\n  conv_rhs => rw [← finsupp.update_self f i]\n  rw [update_eq_erase_add_single, sum_add_index' hg hgg, add_assoc, add_assoc]\n  congr 1\n  rw [add_comm, sum_single_index (hg _), sum_single_index (hg _)]\n#align sum_update_add sum_update_add\n\n",
 "sum_smul_index_add_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A version of `finsupp.sum_smul_index'` for bundled additive maps. -/\ntheorem sum_smul_index_add_monoid_hom [add_monoid M] [add_comm_monoid N] [DistribSMul R M] {g : «expr →₀ » α M} {b : R}\n    {h : α → «expr →+ » M N} : ((«expr • » b g).sum fun a => h a) = g.sum fun i c => h i («expr • » b c) :=\n  sum_map_range_index fun i => (h i).map_zero\n#align sum_smul_index_add_monoid_hom sum_smul_index_add_monoid_hom\n\n",
 "sum_smul_index'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sum_smul_index' [add_monoid M] [DistribSMul R M] [add_comm_monoid N] {g : «expr →₀ » α M} {b : R}\n    {h : α → M → N} (h0 : ∀ i, h i 0 = 0) : («expr • » b g).sum h = g.sum fun i c => h i («expr • » b c) :=\n  finsupp.sum_map_range_index h0\n#align sum_smul_index' sum_smul_index'\n\n",
 "sum_smul_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sum_smul_index [Semiring R] [add_comm_monoid M] {g : «expr →₀ » α R} {b : R} {h : α → R → M}\n    (h0 : ∀ i, h i 0 = 0) : («expr • » b g).sum h = g.sum fun i a => h i (b * a) :=\n  finsupp.sum_map_range_index h0\n#align sum_smul_index sum_smul_index\n\n",
 "sum_option_index_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem sum_option_index_smul [Semiring R] [add_comm_monoid M] [Module R M] (f : «expr →₀ » (option α) R)\n    (b : option α → M) :\n    (f.sum fun o r => «expr • » r (b o)) =\n      «expr • » (f none) (b none) + f.some.sum fun a r => «expr • » r (b (option.some a)) :=\n  f.sum_option_index _ (fun _ => zero_smul _ _) fun _ _ _ => add_smul _ _ _\n#align sum_option_index_smul sum_option_index_smul\n\n",
 "sum_map_domain_index_add_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n-- Note that in `prod_map_domain_index`, `M` is still an additive monoid,\n-- so there is no analogous version in terms of `monoid_hom`.\n/-- A version of `sum_map_domain_index` that takes a bundled `add_monoid_hom`,\nrather than separate linearity hypotheses.\n-/\n@[simp]\ntheorem sum_map_domain_index_add_monoid_hom [add_comm_monoid N] {f : α → β} {s : «expr →₀ » α M}\n    (h : β → «expr →+ » M N) : ((map_domain f s).sum fun b m => h b m) = s.sum fun a m => h (f a) m :=\n  @sum_map_domain_index _ _ _ _ _ _ _ _ (fun b m => h b m) (fun b => (h b).map_zero) fun b m₁ m₂ => (h b).map_add _ _\n#align sum_map_domain_index_add_monoid_hom sum_map_domain_index_add_monoid_hom\n\n",
 "sum_finsupp_equiv_prod_finsupp_symm_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_equiv_prod_finsupp_symm_inr {α β γ : Type _} [Zero γ] (fg : «expr →₀ » α γ × «expr →₀ » β γ)\n    (y : β) : (sum_finsupp_equiv_prod_finsupp.symm fg) (sum.inr y) = fg.2 y :=\n  rfl\n#align sum_finsupp_equiv_prod_finsupp_symm_inr sum_finsupp_equiv_prod_finsupp_symm_inr\n\n",
 "sum_finsupp_equiv_prod_finsupp_symm_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_equiv_prod_finsupp_symm_inl {α β γ : Type _} [Zero γ] (fg : «expr →₀ » α γ × «expr →₀ » β γ)\n    (x : α) : (sum_finsupp_equiv_prod_finsupp.symm fg) (sum.inl x) = fg.1 x :=\n  rfl\n#align sum_finsupp_equiv_prod_finsupp_symm_inl sum_finsupp_equiv_prod_finsupp_symm_inl\n\n",
 "sum_finsupp_add_equiv_prod_finsupp_symm_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_add_equiv_prod_finsupp_symm_inr {α β : Type _} (fg : «expr →₀ » α M × «expr →₀ » β M) (y : β) :\n    (sum_finsupp_add_equiv_prod_finsupp.symm fg) (sum.inr y) = fg.2 y :=\n  rfl\n#align sum_finsupp_add_equiv_prod_finsupp_symm_inr sum_finsupp_add_equiv_prod_finsupp_symm_inr\n\n",
 "sum_finsupp_add_equiv_prod_finsupp_symm_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_add_equiv_prod_finsupp_symm_inl {α β : Type _} (fg : «expr →₀ » α M × «expr →₀ » β M) (x : α) :\n    (sum_finsupp_add_equiv_prod_finsupp.symm fg) (sum.inl x) = fg.1 x :=\n  rfl\n#align sum_finsupp_add_equiv_prod_finsupp_symm_inl sum_finsupp_add_equiv_prod_finsupp_symm_inl\n\n",
 "sum_elim_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_elim_inr {α β γ : Type _} [Zero γ] (f : «expr →₀ » α γ) (g : «expr →₀ » β γ) (x : β) :\n    sum_elim f g (sum.inr x) = g x :=\n  rfl\n#align sum_elim_inr sum_elim_inr\n\n",
 "sum_elim_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_elim_inl {α β γ : Type _} [Zero γ] (f : «expr →₀ » α γ) (g : «expr →₀ » β γ) (x : α) :\n    sum_elim f g (sum.inl x) = f x :=\n  rfl\n#align sum_elim_inl sum_elim_inl\n\n",
 "sum_elim_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_elim_apply {α β γ : Type _} [Zero γ] (f : «expr →₀ » α γ) (g : «expr →₀ » β γ) (x : Sum α β) :\n    sum_elim f g x = sum.elim f g x :=\n  rfl\n#align sum_elim_apply sum_elim_apply\n\n",
 "sum_curry_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_curry_index (f : «expr →₀ » (α × β) M) (g : α → β → M → N) (hg₀ : ∀ a b, g a b 0 = 0)\n    (hg₁ : ∀ a b c₀ c₁, g a b (c₀ + c₁) = g a b c₀ + g a b c₁) :\n    (f.curry.sum fun a f => f.sum (g a)) = f.sum fun p c => g p.1 p.2 c :=\n  by\n  rw [finsupp.curry]\n  trans\n  ·\n    exact\n      sum_sum_index (fun a => sum_zero_index) fun a b₀ b₁ =>\n        sum_add_index' (fun a => hg₀ _ _) fun c d₀ d₁ => hg₁ _ _ _ _\n  congr ; funext p c\n  trans\n  · exact sum_single_index sum_zero_index\n  exact sum_single_index (hg₀ _ _)\n#align sum_curry_index sum_curry_index\n\n",
 "sum_comap_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem sum_comap_domain [Zero M] [add_comm_monoid N] (f : α → β) (l : «expr →₀ » β M) (g : β → M → N)\n    (hf : Set.BijOn f («expr ⁻¹' » f ↑l.support) ↑l.support) : (comap_domain f l hf.inj_on).sum (g ∘ f) = l.sum g :=\n  by\n  simp only [sum, comap_domain_apply, (· ∘ ·)]\n  simp [comap_domain, finset.sum_preimage_of_bij f _ _ fun x => g x (l x)]\n#align sum_comap_domain sum_comap_domain\n\n",
 "subtype_domain_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem subtype_domain_zero : subtype_domain p (0 : «expr →₀ » α M) = 0 :=\n  rfl\n#align subtype_domain_zero subtype_domain_zero\n\n",
 "subtype_domain_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem subtype_domain_sum {s : Finset ι} {h : ι → «expr →₀ » α M} :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n            (h c)).subtype_domain\n        p =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((h c).subtype_domain p) :=\n  (subtype_domain_add_monoid_hom : «expr →+ » _ («expr →₀ » (subtype p) M)).map_sum _ s\n#align subtype_domain_sum subtype_domain_sum\n\n",
 "subtype_domain_sub":
 "@[simp]\ntheorem subtype_domain_sub : (v - v').subtype_domain p = v.subtype_domain p - v'.subtype_domain p :=\n  ext fun _ => rfl\n#align subtype_domain_sub subtype_domain_sub\n\n",
 "subtype_domain_neg":
 "@[simp]\ntheorem subtype_domain_neg : (-v).subtype_domain p = -v.subtype_domain p :=\n  ext fun _ => rfl\n#align subtype_domain_neg subtype_domain_neg\n\n",
 "subtype_domain_finsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem subtype_domain_finsupp_sum [Zero N] {s : «expr →₀ » β N} {h : β → N → «expr →₀ » α M} :\n    (s.sum h).subtype_domain p = s.sum fun c d => (h c d).subtype_domain p :=\n  subtype_domain_sum\n#align subtype_domain_finsupp_sum subtype_domain_finsupp_sum\n\n",
 "subtype_domain_eq_zero_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem subtype_domain_eq_zero_iff' {f : «expr →₀ » α M} : f.subtype_domain p = 0 ↔ ∀ x, p x → f x = 0 := by\n  simp_rw [← support_eq_empty, support_subtype_domain, subtype_eq_empty, not_mem_support_iff]\n#align subtype_domain_eq_zero_iff' subtype_domain_eq_zero_iff'\n\n",
 "subtype_domain_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem subtype_domain_eq_zero_iff {f : «expr →₀ » α M} (hf : ∀ x ∈ f.support, p x) : f.subtype_domain p = 0 ↔ f = 0 :=\n  subtype_domain_eq_zero_iff'.trans\n    ⟨fun H => ext fun x => if hx : p x then H x hx else not_mem_support_iff.1 <| mt (hf x) hx, fun H x _ => by simp [H]⟩\n#align subtype_domain_eq_zero_iff subtype_domain_eq_zero_iff\n\n",
 "subtype_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem subtype_domain_apply {a : subtype p} {v : «expr →₀ » α M} : (subtype_domain p v) a = v a.val :=\n  rfl\n#align subtype_domain_apply subtype_domain_apply\n\n",
 "subtype_domain_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem subtype_domain_add {v v' : «expr →₀ » α M} :\n    (v + v').subtype_domain p = v.subtype_domain p + v'.subtype_domain p :=\n  ext fun _ => rfl\n#align subtype_domain_add subtype_domain_add\n\n",
 "split_apply":
 "theorem split_apply (i : ι) (x : αs i) : split l i x = l ⟨i, x⟩ :=\n  by\n  dsimp only [split]\n  rw [comap_domain_apply]\n#align split_apply split_apply\n\n",
 "some_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem some_zero [Zero M] : (0 : «expr →₀ » (option α) M).some = 0 :=\n  by\n  ext\n  simp\n#align some_zero some_zero\n\n",
 "some_single_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem some_single_some [Zero M] (a : α) (m : M) :\n    (single (option.some a) m : «expr →₀ » (option α) M).some = single a m :=\n  by\n  ext b\n  simp [single_apply]\n#align some_single_some some_single_some\n\n",
 "some_single_none":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem some_single_none [Zero M] (m : M) : (single none m : «expr →₀ » (option α) M).some = 0 :=\n  by\n  ext\n  simp\n#align some_single_none some_single_none\n\n",
 "some_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem some_apply [Zero M] (f : «expr →₀ » (option α) M) (a : α) : f.some a = f (option.some a) :=\n  rfl\n#align some_apply some_apply\n\n",
 "some_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem some_add [add_comm_monoid M] (f g : «expr →₀ » (option α) M) : (f + g).some = f.some + g.some :=\n  by\n  ext\n  simp\n#align some_add some_add\n\n",
 "snd_sum_finsupp_equiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem snd_sum_finsupp_equiv_prod_finsupp {α β γ : Type _} [Zero γ] (f : «expr →₀ » (Sum α β) γ) (y : β) :\n    (sum_finsupp_equiv_prod_finsupp f).2 y = f (sum.inr y) :=\n  rfl\n#align snd_sum_finsupp_equiv_prod_finsupp snd_sum_finsupp_equiv_prod_finsupp\n\n",
 "snd_sum_finsupp_add_equiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem snd_sum_finsupp_add_equiv_prod_finsupp {α β : Type _} (f : «expr →₀ » (Sum α β) M) (y : β) :\n    (sum_finsupp_add_equiv_prod_finsupp f).2 y = f (sum.inr y) :=\n  rfl\n#align snd_sum_finsupp_add_equiv_prod_finsupp snd_sum_finsupp_add_equiv_prod_finsupp\n\n",
 "smul_single_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_single_one [Semiring R] (a : α) (b : R) : «expr • » b (single a 1) = single a b := by\n  rw [smul_single, smul_eq_mul, mul_one]\n#align smul_single_one smul_single_one\n\n",
 "smul_single'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_single' {_ : Semiring R} (c : R) (a : α) (b : R) :\n    «expr • » c (finsupp.single a b) = finsupp.single a (c * b) :=\n  smul_single _ _ _\n#align smul_single' smul_single'\n\n",
 "smul_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_single {_ : monoid R} [add_monoid M] [DistribMulAction R M] (c : R) (a : α) (b : M) :\n    «expr • » c (finsupp.single a b) = finsupp.single a («expr • » c b) :=\n  map_range_single\n#align smul_single smul_single\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply [add_monoid M] [DistribSMul R M] (b : R) (v : «expr →₀ » α M) (a : α) :\n    («expr • » b v) a = «expr • » b (v a) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "singleton_lookup_finsupp":
 "@[simp]\ntheorem singleton_lookup_finsupp (a : α) (m : M) : (singleton a m).lookup_finsupp = finsupp.single a m := by\n  simp [← AList.insert_empty]\n#align singleton_lookup_finsupp singleton_lookup_finsupp\n\n",
 "single_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem single_sub (a : α) (b₁ b₂ : G) : single a (b₁ - b₂) = single a b₁ - single a b₂ :=\n  (single_add_hom a : «expr →+ » G _).map_sub b₁ b₂\n#align single_sub single_sub\n\n",
 "single_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem single_smul (a b : α) (f : α → M) (r : R) : «expr • » (single a r b) (f a) = single a («expr • » r (f b)) b :=\n  by by_cases a = b <;> simp [h]\n#align single_smul single_smul\n\n",
 "single_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem single_neg (a : α) (b : G) : single a (-b) = -single a b :=\n  (single_add_hom a : «expr →+ » G _).map_neg b\n#align single_neg single_neg\n\n",
 "sigma_support":
 "theorem sigma_support : l.support = l.split_support.sigma fun i => (l.split i).support := by\n  simp only [Finset.ext_iff, split_support, split, comap_domain, mem_image, mem_preimage, sigma.forall, mem_sigma] <;>\n    tauto\n#align sigma_support sigma_support\n\n",
 "sigma_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sigma_sum [add_comm_monoid N] (f : (Σi : ι, αs i) → M → N) :\n    l.sum f =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (split_support l)\n        ((split l i).sum fun (a : αs i) b => f ⟨i, a⟩ b) :=\n  by simp only [sum, sigma_support, sum_sigma, split_apply]\n#align sigma_sum sigma_sum\n\n",
 "sigma_finsupp_equiv_pi_finsupp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sigma_finsupp_equiv_pi_finsupp_apply (f : «expr →₀ » (Σj, ιs j) α) (j i) :\n    sigma_finsupp_equiv_pi_finsupp f j i = f ⟨j, i⟩ :=\n  rfl\n#align sigma_finsupp_equiv_pi_finsupp_apply sigma_finsupp_equiv_pi_finsupp_apply\n\n",
 "sigma_finsupp_add_equiv_pi_finsupp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sigma_finsupp_add_equiv_pi_finsupp_apply {α : Type _} {ιs : η → Type _} [add_monoid α]\n    (f : «expr →₀ » (Σj, ιs j) α) (j i) : sigma_finsupp_add_equiv_pi_finsupp f j i = f ⟨j, i⟩ :=\n  rfl\n#align sigma_finsupp_add_equiv_pi_finsupp_apply sigma_finsupp_add_equiv_pi_finsupp_apply\n\n",
 "prod_subtype_domain_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_subtype_domain_index [comm_monoid N] {v : «expr →₀ » α M} {h : α → M → N} (hp : ∀ x ∈ v.support, p x) :\n    ((v.subtype_domain p).prod fun a b => h a b) = v.prod h :=\n  prod_bij (fun p _ => p.val) (fun _ => mem_subtype.1) (fun _ _ => rfl) (fun _ _ _ _ => subtype.eq) fun b hb =>\n    ⟨⟨b, hp b hb⟩, mem_subtype.2 hb, rfl⟩\n#align prod_subtype_domain_index prod_subtype_domain_index\n\n",
 "prod_option_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_option_index [add_comm_monoid M] [comm_monoid N] (f : «expr →₀ » (option α) M) (b : option α → M → N)\n    (h_zero : ∀ o, b o 0 = 1) (h_add : ∀ o m₁ m₂, b o (m₁ + m₂) = b o m₁ * b o m₂) :\n    f.prod b = b none (f none) * f.some.prod fun a => b (option.some a) :=\n  by\n  apply induction_linear f\n  · simp [h_zero]\n  · intro f₁ f₂ h₁ h₂\n    rw [finsupp.prod_add_index, h₁, h₂, some_add, finsupp.prod_add_index]\n    simp only [h_add, pi.add_apply, finsupp.coe_add]\n    rw [mul_mul_mul_comm]\n    all_goals simp [h_zero, h_add]\n  · rintro (_ | a) m <;> simp [h_zero, h_add]\n#align prod_option_index prod_option_index\n\n",
 "prod_map_domain_index_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_map_domain_index_inj [comm_monoid N] {f : α → β} {s : «expr →₀ » α M} {h : β → M → N}\n    (hf : function.injective f) : (s.map_domain f).prod h = s.prod fun a b => h (f a) b := by\n  rw [← Function.Embedding.coeFn_mk f hf, ← emb_domain_eq_map_domain, prod_emb_domain]\n#align prod_map_domain_index_inj prod_map_domain_index_inj\n\n",
 "prod_map_domain_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[to_additive]\ntheorem prod_map_domain_index [comm_monoid N] {f : α → β} {s : «expr →₀ » α M} {h : β → M → N} (h_zero : ∀ b, h b 0 = 1)\n    (h_add : ∀ b m₁ m₂, h b (m₁ + m₂) = h b m₁ * h b m₂) : (map_domain f s).prod h = s.prod fun a m => h (f a) m :=\n  (prod_sum_index h_zero h_add).trans <| prod_congr fun _ _ => prod_single_index (h_zero _)\n#align prod_map_domain_index prod_map_domain_index\n\n",
 "prod_filter_mul_prod_filter_not":
 "@[simp, to_additive]\ntheorem prod_filter_mul_prod_filter_not [comm_monoid N] (g : α → M → N) :\n    (f.filter p).prod g * (f.filter fun a => ¬p a).prod g = f.prod g := by\n  simp_rw [prod_filter_index, support_filter, prod_filter_mul_prod_filter_not, finsupp.prod]\n#align prod_filter_mul_prod_filter_not prod_filter_mul_prod_filter_not\n\n",
 "prod_filter_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem prod_filter_index [comm_monoid N] (g : α → M → N) :\n    (f.filter p).prod g =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (f.filter p).support (g x (f x)) :=\n  by\n  refine' finset.prod_congr rfl fun x hx => _\n  rw [support_filter, Finset.mem_filter] at hx\n  rw [filter_apply_pos _ _ hx.2]\n#align prod_filter_index prod_filter_index\n\n",
 "prod_div_prod_filter":
 "@[simp, to_additive]\ntheorem prod_div_prod_filter [comm_group G] (g : α → M → G) :\n    f.prod g / (f.filter p).prod g = (f.filter fun a => ¬p a).prod g :=\n  div_eq_of_eq_mul' (prod_filter_mul_prod_filter_not _ _ _).symm\n#align prod_div_prod_filter prod_div_prod_filter\n\n",
 "not_mem_graph_snd_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem not_mem_graph_snd_zero (a : α) (f : «expr →₀ » α M) : (a, (0 : M)) ∉ f.graph := fun h =>\n  (mem_graph_iff.1 h).2.irrefl\n#align not_mem_graph_snd_zero not_mem_graph_snd_zero\n\n",
 "mk_mem_graph_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Scott Morrison\n-/\ntheorem mk_mem_graph_iff {a : α} {m : M} {f : «expr →₀ » α M} : (a, m) ∈ f.graph ↔ f a = m ∧ m ≠ 0 :=\n  by\n  simp_rw [graph, mem_map, mem_support_iff]\n  constructor\n  · rintro ⟨b, ha, rfl, -⟩\n    exact ⟨rfl, ha⟩\n  · rintro ⟨rfl, ha⟩\n    exact ⟨a, ha, rfl⟩\n#align mk_mem_graph_iff mk_mem_graph_iff\n\n",
 "mk_mem_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mk_mem_graph (f : «expr →₀ » α M) {a : α} (ha : a ∈ f.support) : (a, f a) ∈ f.graph :=\n  mk_mem_graph_iff.2 ⟨rfl, mem_support_iff.1 ha⟩\n#align mk_mem_graph mk_mem_graph\n\n",
 "mem_to_alist":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem mem_to_alist {f : «expr →₀ » α M} {x : α} : x ∈ f.to_alist ↔ f x ≠ 0 := by\n  rw [AList.mem_keys, ← List.mem_toFinset, to_alist_keys_to_finset, mem_support_iff]\n#align mem_to_alist mem_to_alist\n\n",
 "mem_support_multiset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_support_multiset_sum [add_comm_monoid M] {s : Multiset («expr →₀ » α M)} (a : α) :\n    a ∈ s.sum.support → ∃ f ∈ s, a ∈ (f : «expr →₀ » α M).support :=\n  Multiset.induction_on s false.elim\n    (by\n      intro f s ih ha\n      by_cases a ∈ f.support\n      · exact ⟨f, Multiset.mem_cons_self _ _, h⟩\n      · simp only [multiset.sum_cons, mem_support_iff, add_apply, not_mem_support_iff.1 h, zero_add] at ha\n        rcases ih (mem_support_iff.2 ha) with ⟨f', h₀, h₁⟩\n        exact ⟨f', Multiset.mem_cons_of_mem h₀, h₁⟩)\n#align mem_support_multiset_sum mem_support_multiset_sum\n\n",
 "mem_support_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_support_finset_sum [add_comm_monoid M] {s : Finset ι} {h : ι → «expr →₀ » α M} (a : α)\n    (ha :\n      a ∈\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n            (h c)).support) :\n    ∃ c ∈ s, a ∈ (h c).support :=\n  let ⟨f, hf, hfa⟩ := mem_support_multiset_sum a ha\n  let ⟨c, hc, eq⟩ := Multiset.mem_map.1 hf\n  ⟨c, hc, eq.symm ▸ hfa⟩\n#align mem_support_finset_sum mem_support_finset_sum\n\n",
 "mem_split_support_iff_nonzero":
 "theorem mem_split_support_iff_nonzero (i : ι) : i ∈ split_support l ↔ split l i ≠ 0 :=\n  by\n  rw [split_support, mem_image, ne.def, ← support_eq_empty, ← ne.def, ← Finset.nonempty_iff_ne_empty, split,\n    comap_domain, Finset.Nonempty]\n  simp only [exists_prop, finset.mem_preimage, exists_and_right, exists_eq_right, mem_support_iff, sigma.exists, ne.def]\n#align mem_split_support_iff_nonzero mem_split_support_iff_nonzero\n\n",
 "mem_graph_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem mem_graph_iff {c : α × M} {f : «expr →₀ » α M} : c ∈ f.graph ↔ f c.1 = c.2 ∧ c.2 ≠ 0 :=\n  by\n  cases c\n  exact mk_mem_graph_iff\n#align mem_graph_iff mem_graph_iff\n\n",
 "mem_frange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_frange {f : «expr →₀ » α M} {y : M} : y ∈ f.frange ↔ y ≠ 0 ∧ ∃ x, f x = y :=\n  Finset.mem_image.trans\n    ⟨fun ⟨x, hx1, hx2⟩ => ⟨hx2 ▸ mem_support_iff.1 hx1, x, hx2⟩, fun ⟨hy, x, hx⟩ =>\n      ⟨x, mem_support_iff.2 (hx.symm ▸ hy), hx⟩⟩\n#align mem_frange mem_frange\n\n",
 "map_range_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_range_smul {_ : monoid R} [add_monoid M] [DistribMulAction R M] [add_monoid N] [DistribMulAction R N]\n    {f : M → N} {hf : f 0 = 0} (c : R) (v : «expr →₀ » α M) (hsmul : ∀ x, f («expr • » c x) = «expr • » c (f x)) :\n    map_range f hf («expr • » c v) = «expr • » c (map_range f hf v) :=\n  by\n  erw [← map_range_comp]\n  have : f ∘ («expr • » · ·) c = («expr • » · ·) c ∘ f := funext hsmul\n  simp_rw [this]\n  apply map_range_comp\n  rw [function.comp_apply, smul_zero, hf]\n#align map_range_smul map_range_smul\n\n",
 "map_range_multiset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range_multiset_sum (f : «expr →+ » M N) (m : Multiset («expr →₀ » α M)) :\n    map_range f f.map_zero m.sum = (m.map fun x => map_range f f.map_zero x).sum :=\n  (map_range.add_monoid_hom f : «expr →+ » («expr →₀ » α _) _).map_multiset_sum _\n#align map_range_multiset_sum map_range_multiset_sum\n\n",
 "map_range_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem map_range_finset_sum (f : «expr →+ » M N) (s : Finset ι) (g : ι → «expr →₀ » α M) :\n    map_range f f.map_zero\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (g x)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (map_range f f.map_zero (g x)) :=\n  (map_range.add_monoid_hom f : «expr →+ » («expr →₀ » α _) _).map_sum _ _\n#align map_range_finset_sum map_range_finset_sum\n\n",
 "map_domain_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_domain_zero {f : α → β} : map_domain f (0 : «expr →₀ » α M) = (0 : «expr →₀ » β M) :=\n  sum_zero_index\n#align map_domain_zero map_domain_zero\n\n",
 "map_domain_support_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_support_of_injective [decidable_eq β] {f : α → β} (hf : function.injective f) (s : «expr →₀ » α M) :\n    (map_domain f s).support = Finset.image f s.support :=\n  map_domain_support_of_inj_on s (hf.inj_on _)\n#align map_domain_support_of_injective map_domain_support_of_injective\n\n",
 "map_domain_support_of_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_support_of_inj_on [decidable_eq β] {f : α → β} (s : «expr →₀ » α M) (hf : Set.InjOn f s.support) :\n    (map_domain f s).support = Finset.image f s.support :=\n  Finset.Subset.antisymm map_domain_support <| by\n    intro x hx\n    simp only [mem_image, exists_prop, mem_support_iff, ne.def] at hx\n    rcases hx with ⟨hx_w, hx_h_left, rfl⟩\n    simp only [mem_support_iff, ne.def]\n    rw [map_domain_apply' (↑s.support : set _) _ _ hf]\n    · exact hx_h_left\n    · simp only [mem_coe, mem_support_iff, ne.def]\n      exact hx_h_left\n    · exact subset.refl _\n#align map_domain_support_of_inj_on map_domain_support_of_inj_on\n\n",
 "map_domain_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_support [decidable_eq β] {f : α → β} {s : «expr →₀ » α M} :\n    (s.map_domain f).support ⊆ s.support.image f :=\n  Finset.Subset.trans support_sum <|\n    Finset.Subset.trans (Finset.bunionᵢ_mono fun a ha => support_single_subset) <| by\n      rw [Finset.bunionᵢ_singleton] <;> exact subset.refl _\n#align map_domain_support map_domain_support\n\n",
 "map_domain_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_sum [Zero N] {f : α → β} {s : «expr →₀ » α N} {v : α → N → «expr →₀ » α M} :\n    map_domain f (s.sum v) = s.sum fun a b => map_domain f (v a b) :=\n  (map_domain.add_monoid_hom f : «expr →+ » («expr →₀ » α M) («expr →₀ » β M)).map_finsupp_sum _ _\n#align map_domain_sum map_domain_sum\n\n",
 "map_domain_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_domain_smul {_ : monoid R} [add_comm_monoid M] [DistribMulAction R M] {f : α → β} (b : R)\n    (v : «expr →₀ » α M) : map_domain f («expr • » b v) = «expr • » b (map_domain f v) :=\n  map_domain_map_range _ _ _ _ (smul_add b)\n#align map_domain_smul map_domain_smul\n\n",
 "map_domain_single":
 "@[simp]\ntheorem map_domain_single {f : α → β} {a : α} {b : M} : map_domain f (single a b) = single (f a) b :=\n  sum_single_index <| single_zero _\n#align map_domain_single map_domain_single\n\n",
 "map_domain_notin_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_notin_range {f : α → β} (x : «expr →₀ » α M) (a : β) (h : a ∉ Set.range f) : map_domain f x a = 0 :=\n  by\n  rw [map_domain, sum_apply, sum]\n  exact finset.sum_eq_zero fun a' h' => single_eq_of_ne fun eq => h <| eq ▸ Set.mem_range_self _\n#align map_domain_notin_range map_domain_notin_range\n\n",
 "map_domain_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- When `g` preserves addition, `map_range` and `map_domain` commute. -/\ntheorem map_domain_map_range [add_comm_monoid N] (f : α → β) (v : «expr →₀ » α M) (g : M → N) (h0 : g 0 = 0)\n    (hadd : ∀ x y, g (x + y) = g x + g y) : map_domain f (map_range g h0 v) = map_range g h0 (map_domain f v) :=\n  let g' : «expr →+ » M N :=\n    { to_fun := g\n      map_zero' := h0\n      map_add' := hadd }\n  AddMonoidHom.congr_fun (map_domain.add_monoid_hom_comp_map_range f g') v\n#align map_domain_map_range map_domain_map_range\n\n",
 "map_domain_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_injective {f : α → β} (hf : function.injective f) :\n    function.injective (map_domain f : «expr →₀ » α M → «expr →₀ » β M) :=\n  by\n  intro v₁ v₂ eq\n  ext a\n  have : map_domain f v₁ (f a) = map_domain f v₂ (f a) := by rw [eq]\n  rwa [map_domain_apply hf, map_domain_apply hf] at this\n#align map_domain_injective map_domain_injective\n\n",
 "map_domain_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_inj_on (S : set α) {f : α → β} (hf : Set.InjOn f S) :\n    Set.InjOn (map_domain f : «expr →₀ » α M → «expr →₀ » β M) { w | (w.support : set α) ⊆ S } :=\n  by\n  intro v₁ hv₁ v₂ hv₂ eq\n  ext a\n  by_cases h : a ∈ v₁.support ∪ v₂.support\n  ·\n    rw [← map_domain_apply' S _ hv₁ hf _, ← map_domain_apply' S _ hv₂ hf _, eq] <;>\n      · apply Set.union_subset hv₁ hv₂\n        exact_mod_cast h\n  · simp only [decidable.not_or_iff_and_not, mem_union, not_not, mem_support_iff] at h\n    simp [h]\n#align map_domain_inj_on map_domain_inj_on\n\n",
 "map_domain_id":
 "@[simp]\ntheorem map_domain_id : map_domain id v = v :=\n  sum_single _\n#align map_domain_id map_domain_id\n\n",
 "map_domain_finset_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem map_domain_finset_sum {f : α → β} {s : Finset ι} {v : ι → «expr →₀ » α M} :\n    map_domain f\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (v i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (map_domain f (v i)) :=\n  (map_domain.add_monoid_hom f : «expr →+ » («expr →₀ » α M) («expr →₀ » β M)).map_sum _ _\n#align map_domain_finset_sum map_domain_finset_sum\n\n",
 "map_domain_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_domain_equiv_apply {f : «expr ≃ » α β} (x : «expr →₀ » α M) (a : β) : map_domain f x a = x (f.symm a) :=\n  by\n  conv_lhs => rw [← f.apply_symm_apply a]\n  exact map_domain_apply f.injective _ _\n#align map_domain_equiv_apply map_domain_equiv_apply\n\n",
 "map_domain_congr":
 "theorem map_domain_congr {f g : α → β} (h : ∀ x ∈ v.support, f x = g x) : v.map_domain f = v.map_domain g :=\n  finset.sum_congr rfl fun _ H => by simp only [h _ H]\n#align map_domain_congr map_domain_congr\n\n",
 "map_domain_comp":
 "theorem map_domain_comp {f : α → β} {g : β → γ} : map_domain (g ∘ f) v = map_domain g (map_domain f v) :=\n  by\n  refine' ((sum_sum_index _ _).trans _).symm\n  · intro\n    exact single_zero _\n  · intro\n    exact single_add _\n  refine' sum_congr fun _ _ => sum_single_index _\n  · exact single_zero _\n#align map_domain_comp map_domain_comp\n\n",
 "map_domain_comap_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_comap_domain (hf : function.injective f) (l : «expr →₀ » β M) (hl : ↑l.support ⊆ Set.range f) :\n    map_domain f (comap_domain f l (hf.inj_on _)) = l := by\n  ext a\n  by_cases h_cases : a ∈ Set.range f\n  · rcases Set.mem_range.1 h_cases with ⟨b, hb⟩\n    rw [hb.symm, map_domain_apply hf, comap_domain_apply]\n  · rw [map_domain_notin_range _ _ h_cases]\n    by_contra h_contr\n    apply h_cases (hl <| Finset.mem_coe.2 <| mem_support_iff.2 fun h => h_contr h.symm)\n#align map_domain_comap_domain map_domain_comap_domain\n\n",
 "map_domain_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_apply' (S : set α) {f : α → β} (x : «expr →₀ » α M) (hS : (x.support : set α) ⊆ S)\n    (hf : Set.InjOn f S) {a : α} (ha : a ∈ S) : map_domain f x (f a) = x a :=\n  by\n  rw [map_domain, sum_apply, sum]\n  simp_rw [single_apply]\n  by_cases hax : a ∈ x.support\n  · rw [← finset.add_sum_erase _ _ hax, if_pos rfl]\n    convert add_zero _\n    refine' finset.sum_eq_zero fun i hi => if_neg _\n    exact (hf.mono hS).ne (Finset.mem_of_mem_erase hi) hax (Finset.ne_of_mem_erase hi)\n  · rw [not_mem_support_iff.1 hax]\n    refine' finset.sum_eq_zero fun i hi => if_neg _\n    exact hf.ne (hS hi) ha (ne_of_mem_of_not_mem hi hax)\n#align map_domain_apply' map_domain_apply'\n\n",
 "map_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain_apply {f : α → β} (hf : function.injective f) (x : «expr →₀ » α M) (a : α) :\n    map_domain f x (f a) = x a :=\n  by\n  rw [map_domain, sum_apply, sum, finset.sum_eq_single a, single_eq_same]\n  · intro b _ hba\n    exact single_eq_of_ne (hf.ne hba)\n  · intro h\n    rw [not_mem_support_iff.1 h, single_zero, zero_apply]\n#align map_domain_apply map_domain_apply\n\n",
 "map_domain_add":
 "theorem map_domain_add {f : α → β} : map_domain f (v₁ + v₂) = map_domain f v₁ + map_domain f v₂ :=\n  sum_add_index' (fun _ => single_zero _) fun _ => single_add _\n#align map_domain_add map_domain_add\n\n",
 "lookup_finsupp_surjective":
 "theorem lookup_finsupp_surjective : surjective (@lookup_finsupp α M _) := fun f =>\n  ⟨_, finsupp.to_alist_lookup_finsupp f⟩\n#align lookup_finsupp_surjective lookup_finsupp_surjective\n\n",
 "lookup_finsupp_eq_zero_iff":
 "theorem lookup_finsupp_eq_zero_iff {l : AList fun x : α => M} {a : α} :\n    l.lookup_finsupp a = 0 ↔ a ∉ l ∨ (0 : M) ∈ l.lookup a :=\n  by\n  rw [lookup_finsupp_to_fun, ← lookup_eq_none]\n  cases' lookup a l with m <;> simp\n#align lookup_finsupp_eq_zero_iff lookup_finsupp_eq_zero_iff\n\n",
 "lookup_finsupp_eq_iff_of_ne_zero":
 "theorem lookup_finsupp_eq_iff_of_ne_zero {l : AList fun x : α => M} {a : α} {x : M} (hx : x ≠ 0) :\n    l.lookup_finsupp a = x ↔ x ∈ l.lookup a :=\n  by\n  rw [lookup_finsupp_to_fun]\n  cases' lookup a l with m <;> simp [hx.symm]\n#align lookup_finsupp_eq_iff_of_ne_zero lookup_finsupp_eq_iff_of_ne_zero\n\n",
 "insert_lookup_finsupp":
 "@[simp]\ntheorem insert_lookup_finsupp (l : AList fun x : α => M) (a : α) (m : M) :\n    (l.insert a m).lookup_finsupp = l.lookup_finsupp.update a m :=\n  by\n  ext b\n  by_cases h : b = a <;> simp [h]\n#align insert_lookup_finsupp insert_lookup_finsupp\n\n",
 "image_fst_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem image_fst_graph (f : «expr →₀ » α M) : f.graph.image prod.fst = f.support := by\n  simp only [graph, map_eq_image, image_image, embedding.coe_fn_mk, (· ∘ ·), image_id']\n#align image_fst_graph image_fst_graph\n\n",
 "graph_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem graph_zero : graph (0 : «expr →₀ » α M) = ∅ := by simp [graph]\n#align graph_zero graph_zero\n\n",
 "graph_injective":
 "theorem graph_injective (α M) [Zero M] : injective (@graph α M _) :=\n  by\n  intro f g h\n  have hsup : f.support = g.support := by rw [← image_fst_graph, h, image_fst_graph]\n  refine' ext_iff'.2 ⟨hsup, fun x hx => apply_eq_of_mem_graph <| h.symm ▸ _⟩\n  exact mk_mem_graph _ (hsup ▸ hx)\n#align graph_injective graph_injective\n\n",
 "graph_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem graph_inj {f g : «expr →₀ » α M} : f.graph = g.graph ↔ f = g :=\n  (graph_injective α M).eq_iff\n#align graph_inj graph_inj\n\n",
 "graph_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem graph_eq_empty {f : «expr →₀ » α M} : f.graph = ∅ ↔ f = 0 :=\n  (graph_injective α M).eq_iff' graph_zero\n#align graph_eq_empty graph_eq_empty\n\n",
 "fst_sum_finsupp_equiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem fst_sum_finsupp_equiv_prod_finsupp {α β γ : Type _} [Zero γ] (f : «expr →₀ » (Sum α β) γ) (x : α) :\n    (sum_finsupp_equiv_prod_finsupp f).1 x = f (sum.inl x) :=\n  rfl\n#align fst_sum_finsupp_equiv_prod_finsupp fst_sum_finsupp_equiv_prod_finsupp\n\n",
 "fst_sum_finsupp_add_equiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem fst_sum_finsupp_add_equiv_prod_finsupp {α β : Type _} (f : «expr →₀ » (Sum α β) M) (x : α) :\n    (sum_finsupp_add_equiv_prod_finsupp f).1 x = f (sum.inl x) :=\n  rfl\n#align fst_sum_finsupp_add_equiv_prod_finsupp fst_sum_finsupp_add_equiv_prod_finsupp\n\n",
 "frange_single":
 "theorem frange_single {x : α} {y : M} : frange (single x y) ⊆ {y} := fun r hr =>\n  let ⟨t, ht1, ht2⟩ := mem_frange.1 hr\n  ht2 ▸ by rw [single_apply] at ht2⊢ <;> split_ifs  at ht2⊢ <;> [exact Finset.mem_singleton_self _, cc]\n#align frange_single frange_single\n\n",
 "finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem _root_.is_smul_regular.finsupp [add_monoid M] [DistribSMul R M] {k : R} (hk : IsSMulRegular M k) :\n    IsSMulRegular («expr →₀ » α M) k := fun _ _ h => ext fun i => hk (congr_fun h i)\n#align is_smul_regular.finsupp is_smul_regular.finsupp\n\n",
 "filter_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem filter_zero : (0 : «expr →₀ » α M).filter p = 0 := by\n  rw [← support_eq_empty, support_filter, support_zero, Finset.filter_empty]\n#align filter_zero filter_zero\n\n",
 "filter_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem filter_sum (s : Finset ι) (f : ι → «expr →₀ » α M) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f a)).filter p =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (filter p (f a)) :=\n  (filter_add_hom p : «expr →+ » («expr →₀ » α M) _).map_sum f s\n#align filter_sum filter_sum\n\n",
 "filter_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem filter_sub (p : α → Prop) (f₁ f₂ : «expr →₀ » α G) : filter p (f₁ - f₂) = filter p f₁ - filter p f₂ :=\n  (filter_add_hom p : «expr →+ » («expr →₀ » _ G) _).map_sub f₁ f₂\n#align filter_sub filter_sub\n\n",
 "filter_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem filter_smul {_ : monoid R} [add_monoid M] [DistribMulAction R M] {b : R} {v : «expr →₀ » α M} :\n    («expr • » b v).filter p = «expr • » b (v.filter p) :=\n  coe_fn_injective <| set.indicator_const_smul { x | p x } b v\n#align filter_smul filter_smul\n\n",
 "filter_single_of_pos":
 "@[simp]\ntheorem filter_single_of_pos {a : α} {b : M} (h : p a) : (single a b).filter p = single a b :=\n  (filter_eq_self_iff _ _).2 fun x hx => (single_apply_ne_zero.1 hx).1.symm ▸ h\n#align filter_single_of_pos filter_single_of_pos\n\n",
 "filter_single_of_neg":
 "@[simp]\ntheorem filter_single_of_neg {a : α} {b : M} (h : ¬p a) : (single a b).filter p = 0 :=\n  (filter_eq_zero_iff _ _).2 fun x hpx => single_apply_eq_zero.2 fun hxa => absurd hpx (hxa.symm ▸ h)\n#align filter_single_of_neg filter_single_of_neg\n\n",
 "filter_pos_add_filter_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem filter_pos_add_filter_neg [add_zero_class M] (f : «expr →₀ » α M) (p : α → Prop) :\n    (f.filter p + f.filter fun a => ¬p a) = f :=\n  coe_fn_injective <| set.indicator_self_add_compl { x | p x } f\n#align filter_pos_add_filter_neg filter_pos_add_filter_neg\n\n",
 "filter_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem filter_neg (p : α → Prop) (f : «expr →₀ » α G) : filter p (-f) = -filter p f :=\n  (filter_add_hom p : «expr →+ » («expr →₀ » _ G) _).map_neg f\n#align filter_neg filter_neg\n\n",
 "filter_eq_zero_iff":
 "theorem filter_eq_zero_iff : f.filter p = 0 ↔ ∀ x, p x → f x = 0 := by\n  simp only [fun_like.ext_iff, filter_eq_indicator, zero_apply, set.indicator_apply_eq_zero, Set.mem_setOf_eq]\n#align filter_eq_zero_iff filter_eq_zero_iff\n\n",
 "filter_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem filter_eq_sum (p : α → Prop) [D : decidable_pred p] (f : «expr →₀ » α M) :\n    f.filter p =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (f.support.filter p) (single i (f i)) :=\n  (f.filter p).sum_single.symm.trans <|\n    finset.sum_congr (by rw [subsingleton.elim D] <;> rfl) fun x hx => by rw [filter_apply_pos _ _ (mem_filter.1 hx).2]\n#align filter_eq_sum filter_eq_sum\n\n",
 "filter_eq_self_iff":
 "theorem filter_eq_self_iff : f.filter p = f ↔ ∀ x, f x ≠ 0 → p x := by\n  simp only [fun_like.ext_iff, filter_eq_indicator, set.indicator_apply_eq_self, Set.mem_setOf_eq, not_imp_comm]\n#align filter_eq_self_iff filter_eq_self_iff\n\n",
 "filter_eq_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem filter_eq_indicator : «expr⇑ » (f.filter p) = set.indicator { x | p x } f :=\n  rfl\n#align filter_eq_indicator filter_eq_indicator\n\n",
 "filter_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem filter_curry (f : «expr →₀ » (α × β) M) (p : α → Prop) :\n    (f.filter fun a : α × β => p a.1).curry = f.curry.filter p :=\n  by\n  rw [finsupp.curry, finsupp.curry, finsupp.sum, finsupp.sum, filter_sum, support_filter, sum_filter]\n  refine' finset.sum_congr rfl _\n  rintro ⟨a₁, a₂⟩ ha\n  dsimp only\n  split_ifs\n  · rw [filter_apply_pos, filter_single_of_pos] <;> exact h\n  · rwa [filter_single_of_neg]\n#align filter_curry filter_curry\n\n",
 "filter_apply_pos":
 "@[simp]\ntheorem filter_apply_pos {a : α} (h : p a) : f.filter p a = f a :=\n  if_pos h\n#align filter_apply_pos filter_apply_pos\n\n",
 "filter_apply_neg":
 "@[simp]\ntheorem filter_apply_neg {a : α} (h : ¬p a) : f.filter p a = 0 :=\n  if_neg h\n#align filter_apply_neg filter_apply_neg\n\n",
 "filter_apply":
 "theorem filter_apply (a : α) [D : decidable (p a)] : f.filter p a = if p a then f a else 0 := by\n  rw [subsingleton.elim D] <;> rfl\n#align filter_apply filter_apply\n\n",
 "filter_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem filter_add {v v' : «expr →₀ » α M} : (v + v').filter p = v.filter p + v'.filter p :=\n  (filter_add_hom p).map_add v v'\n#align filter_add filter_add\n\n",
 "erase_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem erase_sub (a : α) (f₁ f₂ : «expr →₀ » α G) : erase a (f₁ - f₂) = erase a f₁ - erase a f₂ :=\n  (erase_add_hom a : «expr →+ » («expr →₀ » _ G) _).map_sub f₁ f₂\n#align erase_sub erase_sub\n\n",
 "erase_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem erase_neg (a : α) (f : «expr →₀ » α G) : erase a (-f) = -erase a f :=\n  (erase_add_hom a : «expr →+ » («expr →₀ » _ G) _).map_neg f\n#align erase_neg erase_neg\n\n",
 "equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.equiv_trans (f : «expr ≃ » M N) (hf : f 0 = 0) (hf') (f₂ : «expr ≃ » N P) (hf₂ : f₂ 0 = 0) (hf₂') :\n    (map_range.equiv (f.trans f₂) (by rw [equiv.trans_apply, hf, hf₂]) (by rw [equiv.symm_trans_apply, hf₂', hf']) :\n        «expr ≃ » («expr →₀ » α _) _) =\n      (map_range.equiv f hf hf').trans (map_range.equiv f₂ hf₂ hf₂') :=\n  equiv.ext <| map_range_comp _ _ _ _ _\n#align map_range.equiv_trans map_range.equiv_trans\n\n",
 "equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.equiv_symm (f : «expr ≃ » M N) (hf hf') :\n    ((map_range.equiv f hf hf').symm : «expr ≃ » («expr →₀ » α _) _) = map_range.equiv f.symm hf' hf :=\n  equiv.ext fun x => rfl\n#align map_range.equiv_symm map_range.equiv_symm\n\n",
 "equiv_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.equiv_refl : map_range.equiv (equiv.refl M) rfl rfl = equiv.refl («expr →₀ » α M) :=\n  equiv.ext map_range_id\n#align map_range.equiv_refl map_range.equiv_refl\n\n",
 "equiv_map_domain_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem equiv_map_domain_zero {f : «expr ≃ » α β} : equiv_map_domain f (0 : «expr →₀ » α M) = (0 : «expr →₀ » β M) := by\n  ext x <;> simp only [equiv_map_domain_apply, coe_zero, pi.zero_apply]\n#align equiv_map_domain_zero equiv_map_domain_zero\n\n",
 "equiv_map_domain_trans'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem equiv_map_domain_trans' (f : «expr ≃ » α β) (g : «expr ≃ » β γ) :\n    @equiv_map_domain _ _ M _ (f.trans g) = equiv_map_domain g ∘ equiv_map_domain f := by ext x <;> rfl\n#align equiv_map_domain_trans' equiv_map_domain_trans'\n\n",
 "equiv_map_domain_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem equiv_map_domain_trans (f : «expr ≃ » α β) (g : «expr ≃ » β γ) (l : «expr →₀ » α M) :\n    equiv_map_domain (f.trans g) l = equiv_map_domain g (equiv_map_domain f l) := by ext x <;> rfl\n#align equiv_map_domain_trans equiv_map_domain_trans\n\n",
 "equiv_map_domain_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem equiv_map_domain_symm_apply (f : «expr ≃ » α β) (l : «expr →₀ » β M) (a : α) :\n    equiv_map_domain f.symm l a = l (f a) :=\n  rfl\n#align equiv_map_domain_symm_apply equiv_map_domain_symm_apply\n\n",
 "equiv_map_domain_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem equiv_map_domain_single (f : «expr ≃ » α β) (a : α) (b : M) :\n    equiv_map_domain f (single a b) = single (f a) b := by\n  ext x <;> simp only [single_apply, equiv.apply_eq_iff_eq_symm_apply, equiv_map_domain_apply] <;> congr\n#align equiv_map_domain_single equiv_map_domain_single\n\n",
 "equiv_map_domain_refl'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem equiv_map_domain_refl' : equiv_map_domain (equiv.refl _) = @id («expr →₀ » α M) := by ext x <;> rfl\n#align equiv_map_domain_refl' equiv_map_domain_refl'\n\n",
 "equiv_map_domain_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem equiv_map_domain_refl (l : «expr →₀ » α M) : equiv_map_domain (equiv.refl _) l = l := by ext x <;> rfl\n#align equiv_map_domain_refl equiv_map_domain_refl\n\n",
 "equiv_map_domain_eq_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem equiv_map_domain_eq_map_domain {M} [add_comm_monoid M] (f : «expr ≃ » α β) (l : «expr →₀ » α M) :\n    equiv_map_domain f l = map_domain f l := by ext x <;> simp [map_domain_equiv_apply]\n#align equiv_map_domain_eq_map_domain equiv_map_domain_eq_map_domain\n\n",
 "equiv_map_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem equiv_map_domain_apply (f : «expr ≃ » α β) (l : «expr →₀ » α M) (b : β) :\n    equiv_map_domain f l b = l (f.symm b) :=\n  rfl\n#align equiv_map_domain_apply equiv_map_domain_apply\n\n",
 "equiv_congr_left_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem equiv_congr_left_symm (f : «expr ≃ » α β) : (@equiv_congr_left _ _ M _ f).symm = equiv_congr_left f.symm :=\n  rfl\n#align equiv_congr_left_symm equiv_congr_left_symm\n\n",
 "equiv_congr_left_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem equiv_congr_left_apply (f : «expr ≃ » α β) (l : «expr →₀ » α M) : equiv_congr_left f l = equiv_map_domain f l :=\n  rfl\n#align equiv_congr_left_apply equiv_congr_left_apply\n\n",
 "eq_zero_of_comap_domain_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem eq_zero_of_comap_domain_eq_zero [add_comm_monoid M] (f : α → β) (l : «expr →₀ » β M)\n    (hf : Set.BijOn f («expr ⁻¹' » f ↑l.support) ↑l.support) : comap_domain f l hf.inj_on = 0 → l = 0 :=\n  by\n  rw [← support_eq_empty, ← support_eq_empty, comap_domain]\n  simp only [Finset.ext_iff, Finset.not_mem_empty, iff_false_iff, mem_preimage]\n  intro h a ha\n  cases' hf.2.2 ha with b hb\n  exact h b (hb.2.symm ▸ ha)\n#align eq_zero_of_comap_domain_eq_zero eq_zero_of_comap_domain_eq_zero\n\n",
 "empty_lookup_finsupp":
 "@[simp]\ntheorem empty_lookup_finsupp : lookup_finsupp (∅ : AList fun x : α => M) = 0 :=\n  by\n  ext\n  simp\n#align empty_lookup_finsupp empty_lookup_finsupp\n\n",
 "emb_domain_eq_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem emb_domain_eq_map_domain (f : «expr ↪ » α β) (v : «expr →₀ » α M) : emb_domain f v = map_domain f v :=\n  by\n  ext a\n  by_cases a ∈ Set.range f\n  · rcases h with ⟨a, rfl⟩\n    rw [map_domain_apply f.injective, emb_domain_apply]\n  · rw [map_domain_notin_range, emb_domain_notin_range] <;> assumption\n#align emb_domain_eq_map_domain emb_domain_eq_map_domain\n\n",
 "dom_congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_congr_trans [add_comm_monoid M] (e : «expr ≃ » α β) (f : «expr ≃ » β γ) :\n    (finsupp.dom_congr e).trans (finsupp.dom_congr f) =\n      (finsupp.dom_congr (e.trans f) : «expr ≃+ » («expr →₀ » α M) _) :=\n  AddEquiv.ext fun _ => (equiv_map_domain_trans _ _ _).symm\n#align dom_congr_trans dom_congr_trans\n\n",
 "dom_congr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_congr_symm [add_comm_monoid M] (e : «expr ≃ » α β) :\n    (finsupp.dom_congr e).symm = (finsupp.dom_congr e.symm : «expr ≃+ » («expr →₀ » β M) («expr →₀ » α M)) :=\n  AddEquiv.ext fun _ => rfl\n#align dom_congr_symm dom_congr_symm\n\n",
 "dom_congr_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_congr_refl [add_comm_monoid M] : finsupp.dom_congr (equiv.refl α) = AddEquiv.refl («expr →₀ » α M) :=\n  AddEquiv.ext fun _ => equiv_map_domain_refl _\n#align dom_congr_refl dom_congr_refl\n\n",
 "distrib_mul_action_hom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem distrib_mul_action_hom_ext' {f g : «expr →+[ ] » («expr →₀ » α M) R N}\n    (h : ∀ a : α, f.comp (distrib_mul_action_hom.single a) = g.comp (distrib_mul_action_hom.single a)) : f = g :=\n  distrib_mul_action_hom_ext fun a => DistribMulActionHom.congr_fun (h a)\n#align distrib_mul_action_hom_ext' distrib_mul_action_hom_ext'\n\n",
 "distrib_mul_action_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem distrib_mul_action_hom_ext {f g : «expr →+[ ] » («expr →₀ » α M) R N}\n    (h : ∀ (a : α) (m : M), f (single a m) = g (single a m)) : f = g :=\n  DistribMulActionHom.toAddMonoidHom_injective <| add_hom_ext h\n#align distrib_mul_action_hom_ext distrib_mul_action_hom_ext\n\n",
 "curry_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem curry_apply (f : «expr →₀ » (α × β) M) (x : α) (y : β) : f.curry x y = f (x, y) :=\n  by\n  have : ∀ b : α × β, single b.fst (single b.snd (f b)) x y = if b = (x, y) then f b else 0 :=\n    by\n    rintro ⟨b₁, b₂⟩\n    simp [single_apply, ite_apply, prod.ext_iff, ite_and]\n    split_ifs <;> simp [single_apply, *]\n  rw [finsupp.curry, sum_apply, sum_apply, finsupp.sum, finset.sum_eq_single, this, if_pos rfl]\n  · intro b hb b_ne\n    rw [this b, if_neg b_ne]\n  · intro hxy\n    rw [this (x, y), if_pos rfl, not_mem_support_iff.mp hxy]\n#align curry_apply curry_apply\n\n",
 "comap_smul_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem comap_smul_single (g : G) (a : α) (b : M) : «expr • » g (single a b) = single («expr • » g a) b :=\n  map_domain_single\n#align comap_smul_single comap_smul_single\n\n",
 "comap_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\ntheorem comap_smul_def (g : G) (f : «expr →₀ » α M) : «expr • » g f = map_domain ((«expr • » · ·) g) f :=\n  rfl\n#align comap_smul_def comap_smul_def\n\n",
 "comap_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- When `G` is a group, `finsupp.comap_has_smul` acts by precomposition with the action of `g⁻¹`.\n-/\n@[simp]\ntheorem comap_smul_apply (g : G) (f : «expr →₀ » α M) (a : α) : («expr • » g f) a = f («expr • » g⁻¹ a) :=\n  by\n  conv_lhs => rw [← smul_inv_smul g a]\n  exact map_domain_apply (MulAction.injective g) _ («expr • » g⁻¹ a)\n#align comap_smul_apply comap_smul_apply\n\n",
 "comap_domain_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Note the `hif` argument is needed for this to work in `rw`. -/\n@[simp]\ntheorem comap_domain_zero (f : α → β)\n    (hif : Set.InjOn f («expr ⁻¹' » f ↑(0 : «expr →₀ » β M).support) := Set.injOn_empty _) :\n    comap_domain f (0 : «expr →₀ » β M) hif = (0 : «expr →₀ » α M) :=\n  by\n  ext\n  rfl\n#align comap_domain_zero comap_domain_zero\n\n",
 "comap_domain_smul_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A version of `finsupp.comap_domain_smul` that's easier to use. -/\ntheorem comap_domain_smul_of_injective [add_monoid M] [monoid R] [DistribMulAction R M] {f : α → β}\n    (hf : function.injective f) (r : R) (v : «expr →₀ » β M) :\n    comap_domain f («expr • » r v) (hf.inj_on _) = «expr • » r (comap_domain f v (hf.inj_on _)) :=\n  comap_domain_smul _ _ _ _\n#align comap_domain_smul_of_injective comap_domain_smul_of_injective\n\n",
 "comap_domain_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem comap_domain_smul [add_monoid M] [monoid R] [DistribMulAction R M] {f : α → β} (r : R) (v : «expr →₀ » β M)\n    (hfv : Set.InjOn f («expr ⁻¹' » f ↑v.support))\n    (hfrv : Set.InjOn f («expr ⁻¹' » f ↑(«expr • » r v).support) :=\n      hfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :\n    comap_domain f («expr • » r v) hfrv = «expr • » r (comap_domain f v hfv) :=\n  by\n  ext\n  rfl\n#align comap_domain_smul comap_domain_smul\n\n",
 "comap_domain_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_domain_single (f : α → β) (a : α) (m : M) (hif : Set.InjOn f («expr ⁻¹' » f (single (f a) m).support)) :\n    comap_domain f (finsupp.single (f a) m) hif = finsupp.single a m :=\n  by\n  rcases eq_or_ne m 0 with (rfl | hm)\n  · simp only [single_zero, comap_domain_zero]\n  · rw [eq_single_iff, comap_domain_apply, comap_domain_support, ← Finset.coe_subset, coe_preimage,\n      support_single_ne_zero _ hm, coe_singleton, coe_singleton, single_eq_same]\n    rw [support_single_ne_zero _ hm, coe_singleton] at hif\n    exact ⟨fun x hx => hif hx rfl hx, rfl⟩\n#align comap_domain_single comap_domain_single\n\n",
 "comap_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_domain_apply [Zero M] (f : α → β) (l : «expr →₀ » β M) (hf : Set.InjOn f («expr ⁻¹' » f ↑l.support))\n    (a : α) : comap_domain f l hf a = l (f a) :=\n  rfl\n#align comap_domain_apply comap_domain_apply\n\n",
 "comap_domain_add_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- A version of `finsupp.comap_domain_add` that's easier to use. -/\ntheorem comap_domain_add_of_injective (hf : function.injective f) (v₁ v₂ : «expr →₀ » β M) :\n    comap_domain f (v₁ + v₂) (hf.inj_on _) = comap_domain f v₁ (hf.inj_on _) + comap_domain f v₂ (hf.inj_on _) :=\n  comap_domain_add _ _ _ _ _\n#align comap_domain_add_of_injective comap_domain_add_of_injective\n\n",
 "comap_domain_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_domain_add (v₁ v₂ : «expr →₀ » β M) (hv₁ : Set.InjOn f («expr ⁻¹' » f ↑v₁.support))\n    (hv₂ : Set.InjOn f («expr ⁻¹' » f ↑v₂.support)) (hv₁₂ : Set.InjOn f («expr ⁻¹' » f ↑(v₁ + v₂).support)) :\n    comap_domain f (v₁ + v₂) hv₁₂ = comap_domain f v₁ hv₁ + comap_domain f v₂ hv₂ :=\n  by\n  ext\n  simp only [comap_domain_apply, coe_add, pi.add_apply]\n#align comap_domain_add comap_domain_add\n\n",
 "coe_sum_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_sum_elim {α β γ : Type _} [Zero γ] (f : «expr →₀ » α γ) (g : «expr →₀ » β γ) :\n    «expr⇑ » (sum_elim f g) = sum.elim f g :=\n  rfl\n#align coe_sum_elim coe_sum_elim\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul [add_monoid M] [DistribSMul R M] (b : R) (v : «expr →₀ » α M) :\n    «expr⇑ » («expr • » b v) = «expr • » b v :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "cast_finsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_finsupp_sum [DivisionRing R] [CharZero R] (g : α → M → exprℚ) :\n    (↑(f.sum g) : R) = f.sum fun a b => g a b :=\n  cast_sum _ _\n#align cast_finsupp_sum cast_finsupp_sum\n\n",
 "cast_finsupp_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp, norm_cast]\ntheorem cast_finsupp_prod [Field R] [CharZero R] (g : α → M → exprℚ) : (↑(f.prod g) : R) = f.prod fun a b => g a b :=\n  cast_prod _ _\n#align cast_finsupp_prod cast_finsupp_prod\n\n",
 "apply_eq_of_mem_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem apply_eq_of_mem_graph {a : α} {m : M} {f : «expr →₀ » α M} (h : (a, m) ∈ f.graph) : f a = m :=\n  (mem_graph_iff.1 h).1\n#align apply_eq_of_mem_graph apply_eq_of_mem_graph\n\n",
 "add_monoid_hom_to_zero_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.add_monoid_hom_to_zero_hom (f : «expr →+ » M N) :\n    (map_range.add_monoid_hom f).to_zero_hom = (map_range.zero_hom f.to_zero_hom : ZeroHom («expr →₀ » α _) _) :=\n  ZeroHom.ext fun _ => rfl\n#align map_range.add_monoid_hom_to_zero_hom map_range.add_monoid_hom_to_zero_hom\n\n",
 "add_monoid_hom_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_domain.add_monoid_hom_id : map_domain.add_monoid_hom id = AddMonoidHom.id («expr →₀ » α M) :=\n  AddMonoidHom.ext fun _ => map_domain_id\n#align map_domain.add_monoid_hom_id map_domain.add_monoid_hom_id\n\n",
 "add_monoid_hom_comp_map_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem map_domain.add_monoid_hom_comp_map_range [add_comm_monoid N] (f : α → β) (g : «expr →+ » M N) :\n    (map_domain.add_monoid_hom f).comp (map_range.add_monoid_hom g) =\n      (map_range.add_monoid_hom g).comp (map_domain.add_monoid_hom f) :=\n  by\n  ext\n  simp\n#align map_domain.add_monoid_hom_comp_map_range map_domain.add_monoid_hom_comp_map_range\n\n",
 "add_monoid_hom_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_domain.add_monoid_hom_comp (f : β → γ) (g : α → β) :\n    (map_domain.add_monoid_hom (f ∘ g) : «expr →+ » («expr →₀ » α M) («expr →₀ » γ M)) =\n      (map_domain.add_monoid_hom f).comp (map_domain.add_monoid_hom g) :=\n  AddMonoidHom.ext fun _ => map_domain_comp\n#align map_domain.add_monoid_hom_comp map_domain.add_monoid_hom_comp\n\n",
 "add_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.add_equiv_trans (f : «expr ≃+ » M N) (f₂ : «expr ≃+ » N P) :\n    (map_range.add_equiv (f.trans f₂) : «expr ≃+ » («expr →₀ » α _) _) =\n      (map_range.add_equiv f).trans (map_range.add_equiv f₂) :=\n  AddEquiv.ext <| map_range_comp _ _ _ _ _\n#align map_range.add_equiv_trans map_range.add_equiv_trans\n\n",
 "add_equiv_to_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.add_equiv_to_equiv (f : «expr ≃+ » M N) :\n    (map_range.add_equiv f).to_equiv =\n      (map_range.equiv f.to_equiv f.map_zero f.symm.map_zero : «expr ≃ » («expr →₀ » α _) _) :=\n  equiv.ext fun _ => rfl\n#align map_range.add_equiv_to_equiv map_range.add_equiv_to_equiv\n\n",
 "add_equiv_to_add_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.add_equiv_to_add_monoid_hom (f : «expr ≃+ » M N) :\n    (map_range.add_equiv f : «expr ≃+ » («expr →₀ » α _) _).to_add_monoid_hom =\n      (map_range.add_monoid_hom f.to_add_monoid_hom : «expr →+ » («expr →₀ » α _) _) :=\n  AddMonoidHom.ext fun _ => rfl\n#align map_range.add_equiv_to_add_monoid_hom map_range.add_equiv_to_add_monoid_hom\n\n",
 "add_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.add_equiv_symm (f : «expr ≃+ » M N) :\n    ((map_range.add_equiv f).symm : «expr ≃+ » («expr →₀ » α _) _) = map_range.add_equiv f.symm :=\n  AddEquiv.ext fun x => rfl\n#align map_range.add_equiv_symm map_range.add_equiv_symm\n\n",
 "add_equiv_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.add_equiv_refl : map_range.add_equiv (AddEquiv.refl M) = AddEquiv.refl («expr →₀ » α M) :=\n  AddEquiv.ext map_range_id\n#align map_range.add_equiv_refl map_range.add_equiv_refl\n\n"}