{"to_matrix_conj_ae":
 "/-- The matrix representation of `conj_ae`. -/\n@[simp]\ntheorem to_matrix_conj_ae : LinearMap.toMatrix basisOneI basisOneI conjAe.to_linear_map = !![1, 0; 0, -1] :=\n  by\n  ext (i j)\n  simp [LinearMap.toMatrix_apply]\n  fin_cases i <;> fin_cases j <;> simp\n#align to_matrix_conj_ae to_matrix_conj_ae\n\n",
 "smul_re":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2020 Alexander Bentkamp, Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Sébastien Gouëzel, Eric Wieser\n-/\n/- The useless `0` multiplication in `smul` is to make sure that\n`restrict_scalars.module ℝ ℂ ℂ = complex.module` definitionally. -/\ntheorem smul_re (r : R) (z : exprℂ) : («expr • » r z).re = «expr • » r z.re := by simp [(«expr • » · ·)]\n#align smul_re smul_re\n\n",
 "smul_im":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_im (r : R) (z : exprℂ) : («expr • » r z).im = «expr • » r z.im := by simp [(«expr • » · ·)]\n#align smul_im smul_im\n\n",
 "real_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem real_smul {x : exprℝ} {z : exprℂ} : «expr • » x z = x * z :=\n  rfl\n#align real_smul real_smul\n\n",
 "real_alg_hom_eq_id_or_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- The identity and the complex conjugation are the only two `ℝ`-algebra homomorphisms of `ℂ`. -/\ntheorem real_alg_hom_eq_id_or_conj (f : «expr →ₐ[ ] » (exprℂ) (exprℝ) (exprℂ)) :\n    f = AlgHom.id (exprℝ) (exprℂ) ∨ f = conjAe :=\n  by\n  refine' (eq_or_eq_neg_of_sq_eq_sq (f I) I <| by rw [← map_pow, I_sq, map_neg, map_one]).imp _ _ <;>\n    refine' fun h => alg_hom_ext _\n  exacts[h, conj_I.symm ▸ h]\n#align real_alg_hom_eq_id_or_conj real_alg_hom_eq_id_or_conj\n\n",
 "realPart_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n#print realPart_smul /-\ntheorem realPart_smul (z : exprℂ) (a : A) :\n    (exprℜ) («expr • » z a) = «expr • » z.re ((exprℜ) a) - «expr • » z.im ((exprℑ) a) :=\n  by\n  nth_rw 1 [← re_add_im z]\n  simp [-re_add_im, add_smul, ← smul_smul, sub_eq_add_neg]\n#align real_part_smul realPart_smul\n-/\n\n",
 "realPart_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print realPart_apply_coe /-\n@[simp]\ntheorem realPart_apply_coe (a : A) : ((exprℜ) a : A) = «expr • » (2 : exprℝ)⁻¹ (a + star a) :=\n  by\n  unfold realPart\n  simp only [self_adjoint_part_apply_coe, invOf_eq_inv]\n#align real_part_apply_coe realPart_apply_coe\n-/\n\n",
 "realPart_add_I_smul_imaginaryPart":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n#print realPart_add_I_smul_imaginaryPart /-\n/-- The standard decomposition of `ℜ a + complex.I • ℑ a = a` of an element of a star module over\n`ℂ` into a linear combination of self adjoint elements. -/\ntheorem realPart_add_I_smul_imaginaryPart (a : A) : ((exprℜ) a + «expr • » I ((exprℑ) a) : A) = a := by\n  simpa only [smul_smul, realPart_apply_coe, imaginaryPart_apply_coe, neg_smul, I_mul_I, one_smul, neg_sub,\n    add_add_sub_cancel, smul_sub, smul_add, neg_sub_neg, invOf_eq_inv] using invOf_two_smul_add_invOf_two_smul (exprℝ) a\n#align real_part_add_I_smul_imaginary_part realPart_add_I_smul_imaginaryPart\n-/\n\n",
 "realPart_I_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n#print realPart_I_smul /-\n@[simp]\ntheorem realPart_I_smul (a : A) : (exprℜ) («expr • » I a) = -(exprℑ) a :=\n  by\n  ext\n  simp [smul_comm I, smul_sub, sub_eq_add_neg, add_comm]\n#align real_part_I_smul realPart_I_smul\n-/\n\n",
 "re_lm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem re_lm_coe : «expr⇑ » reLm = re :=\n  rfl\n#align re_lm_coe re_lm_coe\n\n",
 "rank_real_of_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n#print rank_real_of_complex /-\ntheorem rank_real_of_complex (E : Type _) [AddCommGroup E] [Module (exprℂ) E] :\n    Module.rank (exprℝ) E = 2 * Module.rank (exprℂ) E :=\n  Cardinal.lift_inj.1 <|\n    by\n    rw [← lift_rank_mul_lift_rank (exprℝ) (exprℂ) E, Complex.rank_real_complex]\n    simp [bit0]\n#align rank_real_of_complex rank_real_of_complex\n-/\n\n",
 "rank_real_complex'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem rank_real_complex'.{u} : Cardinal.lift.{u} (Module.rank (exprℝ) (exprℂ)) = 2 := by\n  simp [← finrank_eq_rank, finrank_real_complex, bit0]\n#align rank_real_complex' rank_real_complex'\n\n",
 "rank_real_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem rank_real_complex : Module.rank (exprℝ) (exprℂ) = 2 := by simp [← finrank_eq_rank, finrank_real_complex]\n#align rank_real_complex rank_real_complex\n\n",
 "of_real_am_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem of_real_am_coe : «expr⇑ » ofRealAm = coe :=\n  rfl\n#align of_real_am_coe of_real_am_coe\n\n",
 "map_coe_real_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print AlgHom.map_coe_real_complex /-\n/-- We need this lemma since `complex.coe_algebra_map` diverts the simp-normal form away from\n`alg_hom.commutes`. -/\n@[simp]\ntheorem AlgHom.map_coe_real_complex (f : «expr →ₐ[ ] » (exprℂ) (exprℝ) A) (x : exprℝ) : f x = algebraMap (exprℝ) A x :=\n  f.commutes x\n#align alg_hom.map_coe_real_complex AlgHom.map_coe_real_complex\n-/\n\n",
 "lift_aux_neg_I":
 "-- When applied to `-complex.I`, `lift` is conjugation, `conj`.\n@[simp]\ntheorem lift_aux_neg_I : liftAux (-I) ((neg_mul_neg _ _).trans I_mul_I) = conjAe :=\n  algHom_ext <| (liftAux_apply_I _ _).trans conj_I.symm\n#align lift_aux_neg_I lift_aux_neg_I\n\n",
 "lift_aux_apply_I":
 "theorem lift_aux_apply_I (I' : A) (hI') : liftAux I' hI' I = I' := by simp\n#align lift_aux_apply_I lift_aux_apply_I\n\n",
 "lift_aux_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- equate \"real\" and \"imaginary\" parts\n@[simp]\ntheorem lift_aux_apply (I' : A) (hI') (z : exprℂ) : liftAux I' hI' z = algebraMap (exprℝ) A z.re + «expr • » z.im I' :=\n  rfl\n#align lift_aux_apply lift_aux_apply\n\n",
 "lift_aux_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n-- When applied to `complex.I` itself, `lift` is the identity.\n@[simp]\ntheorem lift_aux_I : liftAux I I_mul_I = AlgHom.id (exprℝ) (exprℂ) :=\n  algHom_ext <| liftAux_apply_I _ _\n#align lift_aux_I lift_aux_I\n\n",
 "imaginaryPart_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n#print imaginaryPart_smul /-\ntheorem imaginaryPart_smul (z : exprℂ) (a : A) :\n    (exprℑ) («expr • » z a) = «expr • » z.re ((exprℑ) a) + «expr • » z.im ((exprℜ) a) :=\n  by\n  nth_rw 1 [← re_add_im z]\n  simp [-re_add_im, add_smul, ← smul_smul]\n#align imaginary_part_smul imaginaryPart_smul\n-/\n\n",
 "imaginaryPart_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n#print imaginaryPart_apply_coe /-\n@[simp]\ntheorem imaginaryPart_apply_coe (a : A) : ((exprℑ) a : A) = «expr • » (-I) («expr • » (2 : exprℝ)⁻¹ (a - star a)) :=\n  by\n  unfold imaginaryPart\n  simp only [LinearMap.coe_comp, skew_adjoint.neg_I_smul_apply_coe, skew_adjoint_part_apply_coe, invOf_eq_inv]\n#align imaginary_part_apply_coe imaginaryPart_apply_coe\n-/\n\n",
 "imaginaryPart_I_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℑ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℜ -/\n#print imaginaryPart_I_smul /-\n@[simp]\ntheorem imaginaryPart_I_smul (a : A) : (exprℑ) («expr • » I a) = (exprℜ) a :=\n  by\n  ext\n  simp [smul_comm I, smul_smul I]\n#align imaginary_part_I_smul imaginaryPart_I_smul\n-/\n\n",
 "im_lm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem im_lm_coe : «expr⇑ » imLm = im :=\n  rfl\n#align im_lm_coe im_lm_coe\n\n",
 "finrank_real_of_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n#print finrank_real_of_complex /-\ntheorem finrank_real_of_complex (E : Type _) [AddCommGroup E] [Module (exprℂ) E] :\n    FiniteDimensional.finrank (exprℝ) E = 2 * FiniteDimensional.finrank (exprℂ) E := by\n  rw [← FiniteDimensional.finrank_mul_finrank (exprℝ) (exprℂ) E, Complex.finrank_real_complex]\n#align finrank_real_of_complex finrank_real_of_complex\n-/\n\n",
 "finrank_real_complex_fact":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- `fact` version of the dimension of `ℂ` over `ℝ`, locally useful in the definition of the\ncircle. -/\ntheorem finrank_real_complex_fact : Fact (finrank (exprℝ) (exprℂ) = 2) :=\n  ⟨finrank_real_complex⟩\n#align finrank_real_complex_fact finrank_real_complex_fact\n\n",
 "finrank_real_complex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem finrank_real_complex : FiniteDimensional.finrank (exprℝ) (exprℂ) = 2 := by\n  rw [finrank_eq_card_basis basis_one_I, Fintype.card_fin]\n#align finrank_real_complex finrank_real_complex\n\n",
 "conj_ae_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `star_ring_end -/\n@[simp]\ntheorem conj_ae_coe : «expr⇑ » conjAe = star_ring_end :=\n  rfl\n#align conj_ae_coe conj_ae_coe\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Complex.coe_smul /-\n/- Register as an instance (with low priority) the fact that a complex vector space is also a real\nvector space. -/\n@[simp, norm_cast]\ntheorem Complex.coe_smul {E : Type _} [AddCommGroup E] [Module (exprℂ) E] (x : exprℝ) (y : E) :\n    «expr • » (x : exprℂ) y = «expr • » x y :=\n  rfl\n#align complex.coe_smul Complex.coe_smul\n-/\n\n",
 "coe_basis_one_I_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n-- why does `simp` not know how to apply `smul_cons`, which is a `@[simp]` lemma, here?\n@[simp]\ntheorem coe_basis_one_I_repr (z : exprℂ) :\n    «expr⇑ » (basisOneI.repr z) =\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\" :=\n  rfl\n#align coe_basis_one_I_repr coe_basis_one_I_repr\n\n",
 "coe_basis_one_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem coe_basis_one_I :\n    «expr⇑ » basisOneI =\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\" :=\n  funext fun i =>\n    Basis.apply_eq_iff.mpr <|\n      Finsupp.ext fun j => by\n        fin_cases i <;> fin_cases j <;>\n          simp only [coe_basis_one_I_repr, Finsupp.single_eq_of_ne, Matrix.cons_val_zero, Matrix.cons_val_one,\n            Matrix.head_cons, Fin.one_eq_zero_iff, ne.def, not_false_iff, I_re, Nat.succ_succ_ne_one, one_im, I_im,\n            one_re, Finsupp.single_eq_same, Fin.zero_eq_one_iff]\n#align coe_basis_one_I coe_basis_one_I\n\n",
 "coe_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n@[simp]\ntheorem coe_algebra_map : (algebraMap (exprℝ) (exprℂ) : exprℝ → exprℂ) = coe :=\n  rfl\n#align coe_algebra_map coe_algebra_map\n\n",
 "alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- Two `ℝ`-algebra homomorphisms from ℂ are equal if they agree on `complex.I`. -/\n@[ext]\ntheorem alg_hom_ext ⦃f g : «expr →ₐ[ ] » (exprℂ) (exprℝ) A⦄ (h : f I = g I) : f = g :=\n  by\n  ext ⟨x, y⟩\n  simp only [mk_eq_add_mul_I, AlgHom.map_add, AlgHom.map_coe_real_complex, AlgHom.map_mul, h]\n#align alg_hom_ext alg_hom_ext\n\n",
 "OrderedSMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n#print OrderedSMul /-\nprotected theorem OrderedSMul : OrderedSMul (exprℝ) (exprℂ) :=\n  OrderedSMul.mk' fun a b r hab hr => ⟨by simp [hr, hab.1.le], by simp [hab.2]⟩\n#align ordered_smul OrderedSMul\n-/\n\n",
 "I_smul_neg_I":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print skewAdjoint.I_smul_neg_I /-\ntheorem skewAdjoint.I_smul_neg_I (a : skewAdjoint A) : «expr • » I (skewAdjoint.negISMul a : A) = a := by\n  simp only [smul_smul, skew_adjoint.neg_I_smul_apply_coe, neg_smul, smul_neg, I_mul_I, one_smul, neg_neg]\n#align skew_adjoint.I_smul_neg_I skewAdjoint.I_smul_neg_I\n-/\n\n"}