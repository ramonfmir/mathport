{"two_mul_count_bool_of_even":
 "theorem two_mul_count_bool_of_even (hl : Chain' (· ≠ ·) l) (h2 : Even (length l)) (b : Bool) :\n    2 * count b l = length l := by rw [← count_bnot_add_count l b, hl.count_bnot_eq_count h2, two_mul]\n#align two_mul_count_bool_of_even two_mul_count_bool_of_even\n\n",
 "two_mul_count_bool_le_length_add_one":
 "theorem two_mul_count_bool_le_length_add_one (hl : Chain' (· ≠ ·) l) (b : Bool) : 2 * count b l ≤ length l + 1 :=\n  by\n  rw [hl.two_mul_count_bool_eq_ite]\n  split_ifs <;> simp [nat.le_succ_of_le]\n#align two_mul_count_bool_le_length_add_one two_mul_count_bool_le_length_add_one\n\n",
 "two_mul_count_bool_eq_ite":
 "theorem two_mul_count_bool_eq_ite (hl : Chain' (· ≠ ·) l) (b : Bool) :\n    2 * count b l = if Even (length l) then length l else if b ∈ l.head' then length l + 1 else length l - 1 :=\n  by\n  by_cases h2 : Even (length l)\n  · rw [if_pos h2, hl.two_mul_count_bool_of_even h2]\n  · cases' l with x l\n    · exact (h2 even_zero).elim\n    simp only [if_neg h2, count_cons', mul_add, head', Option.mem_some_iff, @eq_comm _ x]\n    rw [length_cons, Nat.even_add_one, Classical.not_not] at h2\n    replace hl : l.chain' (· ≠ ·) := hl.tail\n    rw [hl.two_mul_count_bool_of_even h2]\n    split_ifs <;> simp\n#align two_mul_count_bool_eq_ite two_mul_count_bool_eq_ite\n\n",
 "length_sub_one_le_two_mul_count_bool":
 "theorem length_sub_one_le_two_mul_count_bool (hl : Chain' (· ≠ ·) l) (b : Bool) : length l - 1 ≤ 2 * count b l :=\n  by\n  rw [hl.two_mul_count_bool_eq_ite]\n  split_ifs <;> simp [le_tsub_add, nat.le_succ_of_le]\n#align length_sub_one_le_two_mul_count_bool length_sub_one_le_two_mul_count_bool\n\n",
 "length_div_two_le_count_bool":
 "theorem length_div_two_le_count_bool (hl : Chain' (· ≠ ·) l) (b : Bool) : length l / 2 ≤ count b l :=\n  by\n  rw [Nat.div_le_iff_le_mul_add_pred two_pos, ← tsub_le_iff_right]\n  exact length_sub_one_le_two_mul_count_bool hl b\n#align length_div_two_le_count_bool length_div_two_le_count_bool\n\n",
 "count_tt_le_count_ff_add_one":
 "theorem count_tt_le_count_ff_add_one (hl : Chain' (· ≠ ·) l) : count true l ≤ count false l + 1 :=\n  hl.count_bnot_le_count_add_one false\n#align count_tt_le_count_ff_add_one count_tt_le_count_ff_add_one\n\n",
 "count_tt_add_count_ff":
 "@[simp]\ntheorem count_tt_add_count_ff (l : List Bool) : count true l + count false l = length l :=\n  count_not_add_count l false\n#align count_tt_add_count_ff count_tt_add_count_ff\n\n",
 "count_ff_le_count_tt_add_one":
 "theorem count_ff_le_count_tt_add_one (hl : Chain' (· ≠ ·) l) : count false l ≤ count true l + 1 :=\n  hl.count_bnot_le_count_add_one true\n#align count_ff_le_count_tt_add_one count_ff_le_count_tt_add_one\n\n",
 "count_ff_eq_count_tt":
 "theorem count_ff_eq_count_tt (hl : Chain' (· ≠ ·) l) (h2 : Even (length l)) : count false l = count true l :=\n  hl.count_bnot_eq_count h2 true\n#align count_ff_eq_count_tt count_ff_eq_count_tt\n\n",
 "count_ff_add_count_tt":
 "@[simp]\ntheorem count_ff_add_count_tt (l : List Bool) : count false l + count true l = length l :=\n  count_not_add_count l true\n#align count_ff_add_count_tt count_ff_add_count_tt\n\n",
 "count_bnot_le_count_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\ntheorem count_bnot_le_count_add_one (hl : Chain' (· ≠ ·) l) (b : Bool) : count («expr! » b) l ≤ count b l + 1 :=\n  by\n  cases' l with x l\n  · exact zero_le _\n  obtain rfl | rfl : b = x ∨ b = «expr! » x := by simp only [Bool.eq_not_iff, em]\n  · rw [count_cons_of_ne b.bnot_ne_self, count_cons_self, hl.count_bnot, add_assoc]\n    exact add_le_add_left (nat.mod_lt _ two_pos).le _\n  · rw [Bool.not_not, count_cons_self, count_cons_of_ne x.bnot_ne_self, hl.count_bnot]\n    exact add_le_add_right (le_add_right le_rfl) _\n#align count_bnot_le_count_add_one count_bnot_le_count_add_one\n\n",
 "count_bnot_eq_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\ntheorem count_bnot_eq_count (hl : Chain' (· ≠ ·) l) (h2 : Even (length l)) (b : Bool) :\n    count («expr! » b) l = count b l := by\n  cases' l with x l\n  · rfl\n  rw [length_cons, Nat.even_add_one, Nat.not_even_iff] at h2\n  suffices count («expr! » x) (x :: l) = count x (x :: l) by cases b <;> cases x <;> try exact this <;> exact this.symm\n  rw [count_cons_of_ne x.bnot_ne_self, hl.count_bnot, h2, count_cons_self]\n#align count_bnot_eq_count count_bnot_eq_count\n\n",
 "count_bnot_add_count":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\n/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n@[simp]\ntheorem count_bnot_add_count (l : List Bool) (b : Bool) : count («expr! » b) l + count b l = length l := by\n  simp only [length_eq_countp_add_countp (Eq («expr! » b)), Bool.not_not_eq, count]\n#align count_bnot_add_count count_bnot_add_count\n\n",
 "count_bnot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\ntheorem chain.count_bnot :\n    ∀ {b : Bool} {l : List Bool}, Chain (· ≠ ·) b l → count («expr! » b) l = count b l + length l % 2\n  | b, [], h => rfl\n  | b, x :: l, h => by\n    obtain rfl : b = «expr! » x := Bool.eq_not_iff.2 (rel_of_chain_cons h)\n    rw [Bool.not_not, count_cons_self, count_cons_of_ne x.bnot_ne_self, chain.count_bnot (chain_of_chain_cons h),\n      length, add_assoc, Nat.mod_two_add_succ_mod_two]\n#align chain.count_bnot chain.count_bnot\n\n",
 "count_add_count_bnot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr! » -/\n@[simp]\ntheorem count_add_count_bnot (l : List Bool) (b : Bool) : count b l + count («expr! » b) l = length l := by\n  rw [add_comm, count_bnot_add_count]\n#align count_add_count_bnot count_add_count_bnot\n\n"}