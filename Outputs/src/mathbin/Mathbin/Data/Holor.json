{"zero_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n#print MulZeroClass.zero_mul /-\n@[simp]\ntheorem MulZeroClass.zero_mul {α : Type} [Ring α] (x : Holor α ds₂) : «expr ⊗ » (0 : Holor α ds₁) x = 0 :=\n  funext fun t => MulZeroClass.zero_mul (x (HolorIndex.drop t))\n#align zero_mul MulZeroClass.zero_mul\n-/\n\n",
 "take_take":
 "theorem take_take : ∀ t : HolorIndex (ds₁ ++ ds₂ ++ ds₃), t.assoc_right.take = t.take.take\n  | ⟨is, h⟩ => Subtype.eq <| by simp [assoc_right, take, cast_type, List.take_take, nat.le_add_right, min_eq_left]\n#align take_take take_take\n\n",
 "sum_unit_vec_mul_slice":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/-- The original holor can be recovered from its slices by multiplying with unit vectors and\nsumming up. -/\n@[simp]\ntheorem sum_unit_vec_mul_slice [Ring α] (x : Holor α (d :: ds)) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n        (Finset.range d).attach («expr ⊗ » (unitVec d i) (slice x i (nat.succ_le_of_lt (Finset.mem_range.1 i.prop)))) =\n      x :=\n  by\n  apply slice_eq _ _ _\n  ext (i hid)\n  rw [← slice_sum]\n  simp only [slice_unit_vec_mul hid]\n  rw [Finset.sum_eq_single (subtype.mk i <| Finset.mem_range.2 hid)]\n  · simp\n  · intro (b : { x // x ∈ Finset.range d })(hb : b ∈ (Finset.range d).attach)(hbi : b ≠ ⟨i, _⟩)\n    have hbi' : i ≠ b := by simpa only [ne.def, Subtype.ext_iff, Subtype.coe_mk] using hbi.symm\n    simp [hbi']\n  · intro (hid' : subtype.mk i _ ∉ Finset.attach (Finset.range d))\n    exfalso\n    exact absurd (Finset.mem_attach _ _) hid'\n#align sum_unit_vec_mul_slice sum_unit_vec_mul_slice\n\n",
 "slice_zero":
 "theorem slice_zero [Zero α] (i : ℕ) (hid : i < d) : slice (0 : Holor α (d :: ds)) i hid = 0 :=\n  rfl\n#align slice_zero slice_zero\n\n",
 "slice_unit_vec_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\ntheorem slice_unit_vec_mul [Ring α] {i : ℕ} {j : ℕ} (hid : i < d) (x : Holor α ds) :\n    slice («expr ⊗ » (unitVec d j) x) i hid = if i = j then x else 0 :=\n  funext fun t : HolorIndex ds =>\n    if h : i = j then by simp [slice, mul, HolorIndex.take, unit_vec, HolorIndex.drop, h]\n    else by simp [slice, mul, HolorIndex.take, unit_vec, HolorIndex.drop, h] <;> rfl\n#align slice_unit_vec_mul slice_unit_vec_mul\n\n",
 "slice_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem slice_sum [AddCommMonoid α] {β : Type} (i : ℕ) (hid : i < d) (s : Finset β) (f : β → Holor α (d :: ds)) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (slice (f x) i hid) =\n      slice (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) i\n        hid :=\n  by\n  letI := Classical.decEq β\n  refine' Finset.induction_on s _ _\n  · simp [slice_zero]\n  · intro _ _ h_not_in ih\n    rw [Finset.sum_insert h_not_in, ih, slice_add, Finset.sum_insert h_not_in]\n#align slice_sum slice_sum\n\n",
 "slice_eq":
 "/-- Two holors are equal if all their slices are equal. -/\ntheorem slice_eq (x : Holor α (d :: ds)) (y : Holor α (d :: ds)) (h : slice x = slice y) : x = y :=\n  funext fun t : HolorIndex (d :: ds) =>\n    holor_index_cons_decomp (fun t => x t = y t) t fun i is hiis =>\n      have hiisdds : Forall₂ (· < ·) (i :: is) (d :: ds) := by rw [← hiis]; exact t.2\n      have hid : i < d := (forall₂_cons.1 hiisdds).1\n      have hisds : Forall₂ (· < ·) is ds := (forall₂_cons.1 hiisdds).2\n      calc\n        x ⟨i :: is, _⟩ = slice x i hid ⟨is, hisds⟩ := congr_arg (fun t => x t) (Subtype.eq rfl)\n        _ = slice y i hid ⟨is, hisds⟩ := by rw [h]\n        _ = y ⟨i :: is, _⟩ := congr_arg (fun t => y t) (Subtype.eq rfl)\n        \n#align slice_eq slice_eq\n\n",
 "slice_add":
 "theorem slice_add [Add α] (i : ℕ) (hid : i < d) (x : Holor α (d :: ds)) (y : Holor α (d :: ds)) :\n    slice x i hid + slice y i hid = slice (x + y) i hid :=\n  funext fun t => by simp [slice, (· + ·)]\n#align slice_add slice_add\n\n",
 "mul_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n#print MulZeroClass.mul_zero /-\n@[simp]\ntheorem MulZeroClass.mul_zero {α : Type} [Ring α] (x : Holor α ds₁) : «expr ⊗ » x (0 : Holor α ds₂) = 0 :=\n  funext fun t => MulZeroClass.mul_zero (x (HolorIndex.take t))\n#align mul_zero MulZeroClass.mul_zero\n-/\n\n",
 "mul_scalar_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mul_scalar_mul [Monoid α] (x : Holor α []) (y : Holor α ds) :\n    «expr ⊗ » x y = «expr • » (x ⟨[], Forall₂.nil⟩) y := by simp [mul, has_smul.smul, HolorIndex.take, HolorIndex.drop]\n#align mul_scalar_mul mul_scalar_mul\n\n",
 "mul_right_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\ntheorem mul_right_distrib [Distrib α] (x : Holor α ds₁) (y : Holor α ds₁) (z : Holor α ds₂) :\n    «expr ⊗ » (x + y) z = «expr ⊗ » x z + «expr ⊗ » y z :=\n  funext fun t => add_mul (x (HolorIndex.take t)) (y (HolorIndex.take t)) (z (HolorIndex.drop t))\n#align mul_right_distrib mul_right_distrib\n\n",
 "mul_left_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\ntheorem mul_left_distrib [Distrib α] (x : Holor α ds₁) (y : Holor α ds₂) (z : Holor α ds₂) :\n    «expr ⊗ » x (y + z) = «expr ⊗ » x y + «expr ⊗ » x z :=\n  funext fun t => left_distrib (x (HolorIndex.take t)) (y (HolorIndex.drop t)) (z (HolorIndex.drop t))\n#align mul_left_distrib mul_left_distrib\n\n",
 "mul_assoc0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\ntheorem mul_assoc0 [Semigroup α] (x : Holor α ds₁) (y : Holor α ds₂) (z : Holor α ds₃) :\n    «expr ⊗ » («expr ⊗ » x y) z = («expr ⊗ » x («expr ⊗ » y z)).assoc_left :=\n  funext fun t : HolorIndex (ds₁ ++ ds₂ ++ ds₃) => by\n    rw [assoc_left]\n    unfold mul\n    rw [mul_assoc]\n    rw [← HolorIndex.take_take, ← HolorIndex.drop_take, ← HolorIndex.drop_drop]\n    rw [cast_type]\n    rfl\n    rw [append_assoc]\n#align mul_assoc0 mul_assoc0\n\n",
 "mul_assoc":
 "#print mul_assoc /-\ntheorem mul_assoc [Semigroup α] (x : Holor α ds₁) (y : Holor α ds₂) (z : Holor α ds₃) :\n    HEq (mul (mul x y) z) (mul x (mul y z)) := by simp [cast_heq, mul_assoc0, assoc_left]\n#align mul_assoc mul_assoc\n-/\n\n",
 "holor_index_cons_decomp":
 "-- holor slices\ntheorem holor_index_cons_decomp (p : HolorIndex (d :: ds) → Prop) :\n    ∀ t : HolorIndex (d :: ds), (∀ i is, ∀ h : t.1 = i :: is, p ⟨i :: is, by rw [← h]; exact t.2⟩) → p t\n  | ⟨[], hforall₂⟩, hp => absurd (forall₂_nil_left_iff.1 hforall₂) (cons_ne_nil d ds)\n  | ⟨i :: is, hforall₂⟩, hp => hp i is rfl\n#align holor_index_cons_decomp holor_index_cons_decomp\n\n",
 "drop_take":
 "theorem drop_take : ∀ t : HolorIndex (ds₁ ++ ds₂ ++ ds₃), t.assoc_right.drop.take = t.take.drop\n  | ⟨is, h⟩ => Subtype.eq (by simp [assoc_right, take, drop, cast_type, List.drop_take])\n#align drop_take drop_take\n\n",
 "drop_drop":
 "theorem drop_drop : ∀ t : HolorIndex (ds₁ ++ ds₂ ++ ds₃), t.assoc_right.drop.drop = t.drop\n  | ⟨is, h⟩ => Subtype.eq (by simp [add_comm, assoc_right, drop, cast_type, List.drop_drop])\n#align drop_drop drop_drop\n\n",
 "cprank_upper_bound":
 "theorem cprank_upper_bound [Ring α] : ∀ {ds}, ∀ x : Holor α ds, cprank x ≤ ds.prod := fun ds (x : Holor α ds) =>\n  letI := Classical.decPred fun n : ℕ => cprank_max n x\n  nat.find_min' ⟨ds.prod, show (fun n => cprank_max n x) ds.prod from cprank_max_upper_bound x⟩\n    (cprank_max_upper_bound x)\n#align cprank_upper_bound cprank_upper_bound\n\n",
 "cprank_max_upper_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\ntheorem cprank_max_upper_bound [Ring α] : ∀ {ds}, ∀ x : Holor α ds, CPRankMax ds.prod x\n  | [], x => cprankMax_nil x\n  | d :: ds, x =>\n    by\n    have h_summands :\n      ∀ i : { x // x ∈ Finset.range d },\n        CPRankMax ds.prod («expr ⊗ » (unitVec d i.1) (slice x i.1 (mem_range.1 i.2))) :=\n      fun i => cprankMax_mul _ _ _ (cprank_max_upper_bound (slice x i.1 (mem_range.1 i.2)))\n    have h_dds_prod : (List.cons d ds).prod = Finset.card (Finset.range d) * Prod ds := by simp [Finset.card_range]\n    have :\n      CPRankMax (Finset.card (Finset.attach (Finset.range d)) * Prod ds)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.attach (Finset.range d)) («expr ⊗ » (unitVec d i.val) (slice x i.val (mem_range.1 i.2)))) :=\n      cprankMax_sum (Finset.range d).attach _ fun i _ => h_summands i\n    have h_cprank_max_sum :\n      CPRankMax (Finset.card (Finset.range d) * Prod ds)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.attach (Finset.range d)) («expr ⊗ » (unitVec d i.val) (slice x i.val (mem_range.1 i.2)))) :=\n      by rwa [Finset.card_attach] at this\n    rw [← sum_unit_vec_mul_slice x]\n    rw [h_dds_prod]\n    exact h_cprank_max_sum\n#align cprank_max_upper_bound cprank_max_upper_bound\n\n",
 "cprank_max_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem cprank_max_sum [Ring α] {β} {n : ℕ} (s : Finset β) (f : β → Holor α ds) :\n    (∀ x ∈ s, CPRankMax n (f x)) →\n      CPRankMax (s.card * n)\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) :=\n  letI := Classical.decEq β\n  Finset.induction_on s (by simp [cprank_max.zero])\n    (by\n      intro x s(h_x_notin_s : x ∉ s)ih h_cprank\n      simp only [Finset.sum_insert h_x_notin_s, Finset.card_insert_of_not_mem h_x_notin_s]\n      rw [nat.right_distrib]\n      simp only [nat.one_mul, nat.add_comm]\n      have ih' :\n        cprank_max (Finset.card s * n)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) :=\n        by\n        apply ih\n        intro (x : β)(h_x_in_s : x ∈ s)\n        simp only [h_cprank, Finset.mem_insert_of_mem, h_x_in_s]\n      exact cprank_max_add (h_cprank x (Finset.mem_insert_self x s)) ih')\n#align cprank_max_sum cprank_max_sum\n\n",
 "cprank_max_nil":
 "-- CP rank\ntheorem cprank_max_nil [Monoid α] [AddMonoid α] (x : Holor α nil) : CPRankMax 1 x :=\n  by\n  have h := cprank_max.succ 0 x 0 (cprank_max1.nil x) cprank_max.zero\n  rwa [add_zero x, zero_add] at h\n#align cprank_max_nil cprank_max_nil\n\n",
 "cprank_max_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\ntheorem cprank_max_mul [Ring α] :\n    ∀ (n : ℕ) (x : Holor α [d]) (y : Holor α ds), CPRankMax n y → CPRankMax n («expr ⊗ » x y)\n  | 0, x, _, cprank_max.zero => by simp [MulZeroClass.mul_zero x, cprank_max.zero]\n  | n + 1, x, _, cprank_max.succ k y₁ y₂ hy₁ hy₂ =>\n    by\n    rw [mul_left_distrib]\n    rw [nat.add_comm]\n    apply cprank_max_add\n    · exact cprank_max_1 (cprank_max1.cons _ _ hy₁)\n    · exact cprank_max_mul k x y₂ hy₂\n#align cprank_max_mul cprank_max_mul\n\n",
 "cprank_max_add":
 "theorem cprank_max_add [Monoid α] [AddMonoid α] :\n    ∀ {m : ℕ} {n : ℕ} {x : Holor α ds} {y : Holor α ds}, CPRankMax m x → CPRankMax n y → CPRankMax (m + n) (x + y)\n  | 0, n, x, y, cprank_max.zero, hy => by simp [hy]\n  | m + 1, n, _, y, cprank_max.succ k x₁ x₂ hx₁ hx₂, hy =>\n    by\n    simp only [add_comm, add_assoc]\n    apply cprank_max.succ\n    · assumption\n    · exact cprank_max_add hx₂ hy\n#align cprank_max_add cprank_max_add\n\n",
 "cprank_max_1":
 "theorem cprank_max_1 [Monoid α] [AddMonoid α] {x : Holor α ds} (h : CPRankMax1 x) : CPRankMax 1 x :=\n  by\n  have h' := cprank_max.succ 0 x 0 h cprank_max.zero\n  rwa [zero_add, add_zero] at h'\n#align cprank_max_1 cprank_max_1\n\n",
 "cast_type":
 "-- scalar product\ntheorem cast_type (eq : ds₁ = ds₂) (a : Holor α ds₁) :\n    cast (congr_arg (Holor α) Eq) a = fun t => a (cast (congr_arg HolorIndex Eq.symm) t) := by subst Eq <;> rfl\n#align cast_type cast_type\n\n"}