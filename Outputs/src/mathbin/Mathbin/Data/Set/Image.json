{"union_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem union_preimage_subset (s : set α) (t : set β) (f : α → β) :\n    s ∪ «expr ⁻¹' » f t ⊆ «expr ⁻¹' » f («expr '' » f s ∪ t) := fun x h =>\n  or.elim h (fun l => or.inl <| mem_image_of_mem _ l) fun r => or.inr r\n#align union_preimage_subset union_preimage_subset\n\n",
 "surjective_onto_range":
 "theorem surjective_onto_range : surjective (rangeFactorization f) := fun ⟨_, ⟨i, rfl⟩⟩ => ⟨i, rfl⟩\n#align surjective_onto_range surjective_onto_range\n\n",
 "surjective_onto_image":
 "theorem surjective_onto_image {f : α → β} {s : set α} : surjective (imageFactorization f s) := fun ⟨_, ⟨a, ha, rfl⟩⟩ =>\n  ⟨⟨a, ha⟩, rfl⟩\n#align surjective_onto_image surjective_onto_image\n\n",
 "subsingleton_range":
 "theorem subsingleton_range {α : Sort _} [subsingleton α] (f : α → β) : (range f).subsingleton :=\n  forall_range_iff.2 fun x => forall_range_iff.2 fun y => congr_arg f (subsingleton.elim x y)\n#align subsingleton_range subsingleton_range\n\n",
 "subsingleton_of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If the preimage of a set under an surjective map is a subsingleton,\nthe set is a subsingleton. -/\ntheorem subsingleton_of_preimage {α β : Type _} {f : α → β} (hf : function.surjective f) (s : set β)\n    (hs : («expr ⁻¹' » f s).subsingleton) : s.subsingleton := fun fx hx fy hy =>\n  by\n  rcases hf fx, hf fy with ⟨⟨x, rfl⟩, ⟨y, rfl⟩⟩\n  exact congr_arg f (hs hx hy)\n#align subsingleton_of_preimage subsingleton_of_preimage\n\n",
 "subsingleton_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the image of a set under an injective map is a subsingleton, the set is a subsingleton. -/\ntheorem subsingleton_of_image {α β : Type _} {f : α → β} (hf : function.injective f) (s : set α)\n    (hs : («expr '' » f s).subsingleton) : s.subsingleton :=\n  (hs.preimage hf).anti <| subset_preimage_image _ _\n#align subsingleton_of_image subsingleton_of_image\n\n",
 "subsingleton_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem injective.subsingleton_image_iff (hf : injective f) {s : set α} :\n    («expr '' » f s).subsingleton ↔ s.subsingleton :=\n  ⟨subsingleton_of_image hf s, fun h => h.image f⟩\n#align injective.subsingleton_image_iff injective.subsingleton_image_iff\n\n",
 "subset_range_iff_exists_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subset_range_iff_exists_image_eq {f : α → β} {s : set β} : s ⊆ range f ↔ ∃ t, «expr '' » f t = s :=\n  ⟨fun h => ⟨_, image_preimage_eq_iff.2 h⟩, fun ⟨t, ht⟩ => ht ▸ image_subset_range _ _⟩\n#align subset_range_iff_exists_image_eq subset_range_iff_exists_image_eq\n\n",
 "subset_preimage_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem subset_preimage_univ {s : set α} : s ⊆ «expr ⁻¹' » f univ :=\n  subset_univ _\n#align subset_preimage_univ subset_preimage_univ\n\n",
 "subset_preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subset_preimage_image (f : α → β) (s : set α) : s ⊆ «expr ⁻¹' » f («expr '' » f s) := fun x =>\n  mem_image_of_mem f\n#align subset_preimage_image subset_preimage_image\n\n",
 "subset_image_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subset_image_union (f : α → β) (s : set α) (t : set β) :\n    «expr '' » f (s ∪ «expr ⁻¹' » f t) ⊆ «expr '' » f s ∪ t :=\n  image_subset_iff.2 (union_preimage_subset _ _ _)\n#align subset_image_union subset_image_union\n\n",
 "subset_image_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\ntheorem subset_image_symm_diff : «expr ∆ » («expr '' » f s) («expr '' » f t) ⊆ «expr '' » f («expr ∆ » s t) :=\n  (union_subset_union (subset_image_diff _ _ _) <| subset_image_diff _ _ _).trans (image_union _ _ _).superset\n#align subset_image_symm_diff subset_image_symm_diff\n\n",
 "subset_image_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subset_image_diff (f : α → β) (s t : set α) : «expr '' » f s \\ «expr '' » f t ⊆ «expr '' » f (s \\ t) :=\n  by\n  rw [diff_subset_iff, ← image_union, union_diff_self]\n  exact image_subset f (subset_union_right t s)\n#align subset_image_diff subset_image_diff\n\n",
 "subset_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem subset_image_compl {f : α → β} {s : set α} (H : surjective f) :\n    «expr ᶜ» («expr '' » f s) ⊆ «expr '' » f («expr ᶜ» s) :=\n  compl_subset_iff_union.2 <| by\n    rw [← image_union]\n    simp [image_univ_of_surjective H]\n#align subset_image_compl subset_image_compl\n\n",
 "set_image":
 "#print Function.Commute.set_image /-\ntheorem Function.Commute.set_image {f g : α → α} (h : function.commute f g) : function.commute (image f) (image g) :=\n  h.set_image\n#align function.commute.set_image Function.Commute.set_image\n-/\n\n",
 "right_inverse_range_splitting":
 "theorem right_inverse_range_splitting {f : α → β} (h : injective f) :\n    right_inverse (rangeFactorization f) (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).right_inverse_of_injective fun x y hxy => h <| subtype.ext_iff.1 hxy\n#align right_inverse_range_splitting right_inverse_range_splitting\n\n",
 "range_val_subtype":
 "theorem range_val_subtype {p : α → Prop} : range (subtype.val : subtype p → α) = { x | p x } :=\n  range_coe\n#align range_val_subtype range_val_subtype\n\n",
 "range_val":
 "/-- A variant of `range_coe`. Try to use `range_coe` if possible.\n  This version is useful when defining a new type that is defined as the subtype of something.\n  In that case, the coercion doesn't fire anymore. -/\ntheorem range_val {s : set α} : range (subtype.val : s → α) = s :=\n  range_coe\n#align range_val range_val\n\n",
 "range_unique":
 "/-- The range of a function from a `unique` type contains just the\nfunction applied to its single value. -/\ntheorem range_unique [h : unique ι] : range f = {f default} :=\n  by\n  ext x\n  rw [mem_range]\n  constructor\n  · rintro ⟨i, hi⟩\n    rw [h.uniq i] at hi\n    exact hi ▸ mem_singleton _\n  · exact fun h => ⟨default, h.symm⟩\n#align range_unique range_unique\n\n",
 "range_subtype_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem range_subtype_map {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ x, p x → q (f x)) :\n    range (subtype.map f h) = «expr ⁻¹' » coe («expr '' » f { x | p x }) :=\n  by\n  ext ⟨x, hx⟩\n  simp_rw [mem_preimage, mem_range, mem_image, subtype.exists, subtype.map, subtype.coe_mk, mem_set_of, exists_prop]\n#align range_subtype_map range_subtype_map\n\n",
 "range_subset_singleton":
 "theorem range_subset_singleton {f : ι → α} {x : α} : range f ⊆ {x} ↔ f = const ι x := by\n  simp [range_subset_iff, funext_iff, mem_singleton]\n#align range_subset_singleton range_subset_singleton\n\n",
 "range_subset_iff":
 "theorem range_subset_iff : range f ⊆ s ↔ ∀ y, f y ∈ s :=\n  forall_range_iff\n#align range_subset_iff range_subset_iff\n\n",
 "range_splitting_injective":
 "theorem range_splitting_injective (f : α → β) : injective (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).injective\n#align range_splitting_injective range_splitting_injective\n\n",
 "range_some_union_none":
 "@[simp]\ntheorem range_some_union_none (α : Type _) : range (some : α → option α) ∪ {none} = univ :=\n  (isCompl_range_some_none α).sup_eq_top\n#align range_some_union_none range_some_union_none\n\n",
 "range_some_inter_none":
 "@[simp]\ntheorem range_some_inter_none (α : Type _) : range (some : α → option α) ∩ {none} = ∅ :=\n  (isCompl_range_some_none α).inf_eq_bot\n#align range_some_inter_none range_some_inter_none\n\n",
 "range_snd":
 "#print Prod.range_snd /-\n@[simp]\ntheorem Prod.range_snd [nonempty α] : range (prod.snd : α × β → β) = univ :=\n  prod.snd_surjective.range_eq\n#align prod.range_snd Prod.range_snd\n-/\n\n",
 "range_quotient_mk'":
 "@[simp]\ntheorem range_quotient_mk' {s : setoid α} : range (quotient.mk' : α → quotient s) = univ :=\n  range_quot_mk _\n#align range_quotient_mk' range_quotient_mk'\n\n",
 "range_quotient_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n@[simp]\ntheorem range_quotient_mk [setoid α] : (range fun x : α => «expr⟦ ⟧» x) = univ :=\n  range_quot_mk _\n#align range_quotient_mk range_quotient_mk\n\n",
 "range_quotient_lift_on'":
 "@[simp]\ntheorem range_quotient_lift_on' {s : setoid ι} (hf) :\n    (range fun x : quotient s => quotient.lift_on' x f hf) = range f :=\n  range_quot_lift _\n#align range_quotient_lift_on' range_quotient_lift_on'\n\n",
 "range_quotient_lift":
 "@[simp]\ntheorem range_quotient_lift [s : setoid ι] (hf) : range (quotient.lift f hf : quotient s → α) = range f :=\n  range_quot_lift _\n#align range_quotient_lift range_quotient_lift\n\n",
 "range_quot_mk":
 "@[simp]\ntheorem range_quot_mk (r : α → α → Prop) : range (Quot.mk r) = univ :=\n  (surjective_quot_mk r).range_eq\n#align range_quot_mk range_quot_mk\n\n",
 "range_quot_lift":
 "@[simp]\ntheorem range_quot_lift {r : ι → ι → Prop} (hf : ∀ x y, r x y → f x = f y) : range (Quot.lift f hf) = range f :=\n  ext fun y => (surjective_quot_mk _).exists\n#align range_quot_lift range_quot_lift\n\n",
 "range_nonempty_iff_nonempty":
 "theorem range_nonempty_iff_nonempty : (range f).nonempty ↔ nonempty ι :=\n  ⟨fun ⟨y, x, hxy⟩ => ⟨x⟩, fun ⟨x⟩ => ⟨f x, mem_range_self x⟩⟩\n#align range_nonempty_iff_nonempty range_nonempty_iff_nonempty\n\n",
 "range_nonempty":
 "theorem range_nonempty [h : nonempty ι] (f : ι → α) : (range f).nonempty :=\n  range_nonempty_iff_nonempty.2 h\n#align range_nonempty range_nonempty\n\n",
 "range_ite_subset'":
 "theorem range_ite_subset' {p : Prop} [decidable p] {f g : α → β} : range (if p then f else g) ⊆ range f ∪ range g :=\n  by\n  by_cases h : p;\n  · rw [if_pos h]\n    exact subset_union_left _ _\n  · rw [if_neg h]\n    exact subset_union_right _ _\n#align range_ite_subset' range_ite_subset'\n\n",
 "range_ite_subset":
 "theorem range_ite_subset {p : α → Prop} [decidable_pred p] {f g : α → β} :\n    (range fun x => if p x then f x else g x) ⊆ range f ∪ range g :=\n  by\n  rw [range_subset_iff]; intro x; by_cases h : p x\n  simp [if_pos h, mem_union, mem_range_self]\n  simp [if_neg h, mem_union, mem_range_self]\n#align range_ite_subset range_ite_subset\n\n",
 "range_inr_union_range_inl":
 "@[simp]\ntheorem range_inr_union_range_inl : range (sum.inr : β → Sum α β) ∪ range sum.inl = univ :=\n  isCompl_range_inl_range_inr.symm.sup_eq_top\n#align range_inr_union_range_inl range_inr_union_range_inl\n\n",
 "range_inr_inter_range_inl":
 "@[simp]\ntheorem range_inr_inter_range_inl : range (sum.inr : β → Sum α β) ∩ range sum.inl = ∅ :=\n  isCompl_range_inl_range_inr.symm.inf_eq_bot\n#align range_inr_inter_range_inl range_inr_inter_range_inl\n\n",
 "range_inl_union_range_inr":
 "@[simp]\ntheorem range_inl_union_range_inr : range (sum.inl : α → Sum α β) ∪ range sum.inr = univ :=\n  isCompl_range_inl_range_inr.sup_eq_top\n#align range_inl_union_range_inr range_inl_union_range_inr\n\n",
 "range_inl_inter_range_inr":
 "@[simp]\ntheorem range_inl_inter_range_inr : range (sum.inl : α → Sum α β) ∩ range sum.inr = ∅ :=\n  isCompl_range_inl_range_inr.inf_eq_bot\n#align range_inl_inter_range_inr range_inl_inter_range_inr\n\n",
 "range_inclusion":
 "@[simp]\ntheorem range_inclusion (h : s ⊆ t) : range (inclusion h) = { x : t | (x : α) ∈ s } :=\n  by\n  ext ⟨x, hx⟩\n  simp [inclusion]\n#align range_inclusion range_inclusion\n\n",
 "range_image":
 "theorem range_image (f : α → β) : range (image f) = 𝒫 range f :=\n  ext fun s => subset_range_iff_exists_image_eq.symm\n#align range_image range_image\n\n",
 "range_iff_surjective":
 "theorem range_iff_surjective : range f = univ ↔ surjective f :=\n  eq_univ_iff_forall\n#align range_iff_surjective range_iff_surjective\n\n",
 "range_id'":
 "@[simp]\ntheorem range_id' : (range fun x : α => x) = univ :=\n  range_id\n#align range_id' range_id'\n\n",
 "range_id":
 "@[simp]\ntheorem range_id : range (@id α) = univ :=\n  range_iff_surjective.2 surjective_id\n#align range_id range_id\n\n",
 "range_fst":
 "#print Prod.range_fst /-\n@[simp]\ntheorem Prod.range_fst [nonempty β] : range (prod.fst : α × β → α) = univ :=\n  prod.fst_surjective.range_eq\n#align prod.range_fst Prod.range_fst\n-/\n\n",
 "range_factorization_eq":
 "theorem range_factorization_eq {f : ι → β} : subtype.val ∘ rangeFactorization f = f :=\n  funext fun i => rfl\n#align range_factorization_eq range_factorization_eq\n\n",
 "range_factorization_coe":
 "@[simp]\ntheorem range_factorization_coe (f : ι → β) (a : ι) : (rangeFactorization f a : β) = f a :=\n  rfl\n#align range_factorization_coe range_factorization_coe\n\n",
 "range_eval":
 "@[simp]\ntheorem range_eval {ι : Type _} {α : ι → Sort _} [∀ i, nonempty (α i)] (i : ι) :\n    range (eval i : (∀ i, α i) → α i) = univ :=\n  (surjective_eval i).range_eq\n#align range_eval range_eval\n\n",
 "range_eq_iff":
 "theorem range_eq_iff (f : α → β) (s : set β) : range f = s ↔ (∀ a, f a ∈ s) ∧ ∀ b ∈ s, ∃ a, f a = b :=\n  by\n  rw [← range_subset_iff]\n  exact le_antisymm_iff\n#align range_eq_iff range_eq_iff\n\n",
 "range_eq_empty_iff":
 "@[simp]\ntheorem range_eq_empty_iff {f : ι → α} : range f = ∅ ↔ is_empty ι := by\n  rw [← not_nonempty_iff, ← range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]\n#align range_eq_empty_iff range_eq_empty_iff\n\n",
 "range_eq_empty":
 "theorem range_eq_empty [is_empty ι] (f : ι → α) : range f = ∅ :=\n  range_eq_empty_iff.2 ‹_›\n#align range_eq_empty range_eq_empty\n\n",
 "range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print WithTop.range_eq /-\ntheorem WithTop.range_eq {α β} (f : WithTop α → β) : range f = insert (f («expr⊤»)) (range (f ∘ coe : α → β)) :=\n  Option.range_eq f\n#align with_top.range_eq WithTop.range_eq\n-/\n\n",
 "range_diff_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem range_diff_image_subset (f : α → β) (s : set α) : range f \\ «expr '' » f s ⊆ «expr '' » f («expr ᶜ» s) :=\n  fun y ⟨⟨x, h₁⟩, h₂⟩ => ⟨x, fun h => h₂ ⟨x, h, h₁⟩, h₁⟩\n#align range_diff_image_subset range_diff_image_subset\n\n",
 "range_diff_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem range_diff_image {f : α → β} (H : injective f) (s : set α) :\n    range f \\ «expr '' » f s = «expr '' » f («expr ᶜ» s) :=\n  Subset.antisymm (range_diff_image_subset f s) fun y ⟨x, hx, hy⟩ =>\n    hy ▸ ⟨mem_range_self _, fun ⟨x', hx', eq⟩ => hx <| H eq ▸ hx'⟩\n#align range_diff_image range_diff_image\n\n",
 "range_const_subset":
 "theorem range_const_subset {c : α} : (range fun x : ι => c) ⊆ {c} :=\n  range_subset_iff.2 fun x => rfl\n#align range_const_subset range_const_subset\n\n",
 "range_const":
 "@[simp]\ntheorem range_const : ∀ [nonempty ι] {c : α}, (range fun x : ι => c) = {c}\n  | ⟨x⟩, c => Subset.antisymm range_const_subset fun y hy => (mem_singleton_iff.1 hy).symm ▸ mem_range_self x\n#align range_const range_const\n\n",
 "range_comp_subset_range":
 "theorem range_comp_subset_range (f : α → β) (g : β → γ) : range (g ∘ f) ⊆ range g := by\n  rw [range_comp] <;> apply image_subset_range\n#align range_comp_subset_range range_comp_subset_range\n\n",
 "range_comp":
 "theorem surjective.range_comp {ι' : Sort _} {f : ι → ι'} (hf : surjective f) (g : ι' → α) : range (g ∘ f) = range g :=\n  ext fun y => (@surjective.exists _ _ _ hf fun x => g x = y).symm\n#align surjective.range_comp surjective.range_comp\n\n",
 "range_coe_subtype":
 "/-- We make this the simp lemma instead of `range_coe`. The reason is that if we write\n  for `s : set α` the function `coe : s → α`, then the inferred implicit arguments of `coe` are\n  `coe α (λ x, x ∈ s)`. -/\n@[simp]\ntheorem range_coe_subtype {p : α → Prop} : range (coe : subtype p → α) = { x | p x } :=\n  range_coe\n#align range_coe_subtype range_coe_subtype\n\n",
 "range_coe":
 "theorem range_coe {s : set α} : range (coe : s → α) = s :=\n  by\n  rw [← Set.image_univ]\n  simp [-Set.image_univ, coe_image]\n#align range_coe range_coe\n\n",
 "prod_quotient_preimage_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_quotient_preimage_eq_image [s : setoid α] (g : quotient s → β) {h : α → β} (Hh : h = g ∘ Quotient.mk'')\n    (r : set (β × β)) :\n    { x : quotient s × quotient s | (g x.1, g x.2) ∈ r } =\n      «expr '' » (fun a : α × α => («expr⟦ ⟧» a.1, «expr⟦ ⟧» a.2)) («expr ⁻¹' » (fun a : α × α => (h a.1, h a.2)) r) :=\n  Hh.symm ▸\n    Set.ext fun ⟨a₁, a₂⟩ =>\n      ⟨quotient.induction_on₂ a₁ a₂ fun a₁ a₂ h => ⟨(a₁, a₂), h, rfl⟩, fun ⟨⟨b₁, b₂⟩, h₁, h₂⟩ =>\n        show (g a₁, g a₂) ∈ r from\n          have h₃ : «expr⟦ ⟧» b₁ = a₁ ∧ «expr⟦ ⟧» b₂ = a₂ := prod.ext_iff.1 h₂\n          h₃.1 ▸ h₃.2 ▸ h₁⟩\n#align prod_quotient_preimage_eq_image prod_quotient_preimage_eq_image\n\n",
 "preimage_val_eq_preimage_val_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_val_eq_preimage_val_iff (s t u : set α) :\n    «expr ⁻¹' » (subtype.val : s → α) t = «expr ⁻¹' » subtype.val u ↔ t ∩ s = u ∩ s :=\n  preimage_coe_eq_preimage_coe_iff\n#align preimage_val_eq_preimage_val_iff preimage_val_eq_preimage_val_iff\n\n",
 "preimage_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_univ : «expr ⁻¹' » f univ = univ :=\n  rfl\n#align preimage_univ preimage_univ\n\n",
 "preimage_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_union {s t : set β} : «expr ⁻¹' » f (s ∪ t) = «expr ⁻¹' » f s ∪ «expr ⁻¹' » f t :=\n  rfl\n#align preimage_union preimage_union\n\n",
 "preimage_surjective":
 "@[simp]\ntheorem preimage_surjective : surjective (preimage f) ↔ injective f :=\n  by\n  refine' ⟨fun h x x' hx => _, injective.preimage_surjective⟩\n  cases' h {x} with s hs; have := mem_singleton x\n  rwa [← hs, mem_preimage, hx, ← mem_preimage, hs, mem_singleton_iff, eq_comm] at this\n#align preimage_surjective preimage_surjective\n\n",
 "preimage_subtype_coe_eq_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_subtype_coe_eq_compl {α : Type _} {s u v : set α} (hsuv : s ⊆ u ∪ v) (H : s ∩ (u ∩ v) = ∅) :\n    «expr ⁻¹' » (coe : s → α) u = «expr ᶜ» («expr ⁻¹' » coe v) :=\n  by\n  ext ⟨x, x_in_s⟩\n  constructor\n  · intro x_in_u x_in_v\n    exact eq_empty_iff_forall_not_mem.mp H x ⟨x_in_s, ⟨x_in_u, x_in_v⟩⟩\n  · intro hx\n    exact or.elim (hsuv x_in_s) id fun hx' => hx.elim hx'\n#align preimage_subtype_coe_eq_compl preimage_subtype_coe_eq_compl\n\n",
 "preimage_subset_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem surjective.preimage_subset_preimage_iff {s t : set β} (hf : surjective f) :\n    «expr ⁻¹' » f s ⊆ «expr ⁻¹' » f t ↔ s ⊆ t :=\n  by\n  apply preimage_subset_preimage_iff\n  rw [hf.range_eq]\n  apply subset_univ\n#align surjective.preimage_subset_preimage_iff surjective.preimage_subset_preimage_iff\n\n",
 "preimage_subset_image_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_subset_image_of_inverse {f : α → β} {g : β → α} (I : left_inverse g f) (s : set β) :\n    «expr ⁻¹' » f s ⊆ «expr '' » g s := fun b h => ⟨f b, h, I b⟩\n#align preimage_subset_image_of_inverse preimage_subset_image_of_inverse\n\n",
 "preimage_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_subset_iff {A : set α} {B : set β} {f : α → β} : «expr ⁻¹' » f B ⊆ A ↔ ∀ a : α, f a ∈ B → a ∈ A :=\n  iff.rfl\n#align preimage_subset_iff preimage_subset_iff\n\n",
 "preimage_singleton_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_singleton_nonempty {f : α → β} {y : β} : («expr ⁻¹' » f {y}).nonempty ↔ y ∈ range f :=\n  iff.rfl\n#align preimage_singleton_nonempty preimage_singleton_nonempty\n\n",
 "preimage_singleton_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_singleton_eq_empty {f : α → β} {y : β} : «expr ⁻¹' » f {y} = ∅ ↔ y ∉ range f :=\n  not_nonempty_iff_eq_empty.symm.trans preimage_singleton_nonempty.not\n#align preimage_singleton_eq_empty preimage_singleton_eq_empty\n\n",
 "preimage_set_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_set_of_eq {p : α → Prop} {f : β → α} : «expr ⁻¹' » f { a | p a } = { a | p (f a) } :=\n  rfl\n#align preimage_set_of_eq preimage_set_of_eq\n\n",
 "preimage_range_splitting":
 "theorem preimage_range_splitting {f : α → β} (hf : injective f) :\n    preimage (rangeSplitting f) = image (rangeFactorization f) :=\n  (image_eq_preimage_of_inverse (rightInverse_rangeSplitting hf) (leftInverse_rangeSplitting f)).symm\n#align preimage_range_splitting preimage_range_splitting\n\n",
 "preimage_range_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_range_inter {f : α → β} {s : set β} : «expr ⁻¹' » f (range f ∩ s) = «expr ⁻¹' » f s := by\n  rw [inter_comm, preimage_inter_range]\n#align preimage_range_inter preimage_range_inter\n\n",
 "preimage_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_range (f : α → β) : «expr ⁻¹' » f (range f) = univ :=\n  eq_univ_of_forall mem_range_self\n#align preimage_range preimage_range\n\n",
 "preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem left_inverse.preimage_preimage {g : β → α} (h : left_inverse g f) (s : set α) :\n    «expr ⁻¹' » f («expr ⁻¹' » g s) = s := by rw [← preimage_comp, h.comp_eq_id, preimage_id]\n#align left_inverse.preimage_preimage left_inverse.preimage_preimage\n\n",
 "preimage_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_mono {s t : set β} (h : s ⊆ t) : «expr ⁻¹' » f s ⊆ «expr ⁻¹' » f t := fun x hx => h hx\n#align preimage_mono preimage_mono\n\n",
 "preimage_iterate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem preimage_iterate_eq {f : α → α} {n : ℕ} : Set.preimage («expr ^[ ]» f n) = «expr ^[ ]» (Set.preimage f) n :=\n  by\n  induction' n with n ih; · simp\n  rw [iterate_succ, iterate_succ', Set.preimage_comp_eq, ih]\n#align preimage_iterate_eq preimage_iterate_eq\n\n",
 "preimage_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_ite (f : α → β) (s t₁ t₂ : set β) :\n    «expr ⁻¹' » f (s.ite t₁ t₂) = («expr ⁻¹' » f s).ite («expr ⁻¹' » f t₁) («expr ⁻¹' » f t₂) :=\n  rfl\n#align preimage_ite preimage_ite\n\n",
 "preimage_inter_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_inter_range {f : α → β} {s : set β} : «expr ⁻¹' » f (s ∩ range f) = «expr ⁻¹' » f s :=\n  Set.ext fun x => and_iff_left ⟨x, rfl⟩\n#align preimage_inter_range preimage_inter_range\n\n",
 "preimage_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_inter {s t : set β} : «expr ⁻¹' » f (s ∩ t) = «expr ⁻¹' » f s ∩ «expr ⁻¹' » f t :=\n  rfl\n#align preimage_inter preimage_inter\n\n",
 "preimage_inr_range_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_inr_range_inl : «expr ⁻¹' » sum.inr (range (sum.inl : α → Sum α β)) = ∅ := by\n  rw [← image_univ, preimage_inr_image_inl]\n#align preimage_inr_range_inl preimage_inr_range_inl\n\n",
 "preimage_inr_image_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem preimage_inr_image_inl (s : set α) : «expr ⁻¹' » sum.inr («expr '' » (@sum.inl α β) s) = ∅ :=\n  by\n  ext\n  simp\n#align preimage_inr_image_inl preimage_inr_image_inl\n\n",
 "preimage_inl_range_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_inl_range_inr : «expr ⁻¹' » sum.inl (range (sum.inr : β → Sum α β)) = ∅ := by\n  rw [← image_univ, preimage_inl_image_inr]\n#align preimage_inl_range_inr preimage_inl_range_inr\n\n",
 "preimage_inl_image_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem preimage_inl_image_inr (s : set β) : «expr ⁻¹' » sum.inl («expr '' » (@sum.inr α β) s) = ∅ :=\n  by\n  ext\n  simp\n#align preimage_inl_image_inr preimage_inl_image_inr\n\n",
 "preimage_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_injective : injective (preimage f) ↔ surjective f :=\n  by\n  refine' ⟨fun h y => _, surjective.preimage_injective⟩\n  obtain ⟨x, hx⟩ : («expr ⁻¹' » f {y}).nonempty :=\n    by\n    rw [h.nonempty_apply_iff preimage_empty]\n    apply singleton_nonempty\n  exact ⟨x, hx⟩\n#align preimage_injective preimage_injective\n\n",
 "preimage_image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_image_preimage {f : α → β} {s : set β} :\n    «expr ⁻¹' » f («expr '' » f («expr ⁻¹' » f s)) = «expr ⁻¹' » f s := by\n  rw [image_preimage_eq_inter_range, preimage_inter_range]\n#align preimage_image_preimage preimage_image_preimage\n\n",
 "preimage_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_image_eq {f : α → β} (s : set α) (h : injective f) : «expr ⁻¹' » f («expr '' » f s) = s :=\n  Subset.antisymm (fun x ⟨y, hy, e⟩ => h e ▸ hy) (subset_preimage_image f s)\n#align preimage_image_eq preimage_image_eq\n\n",
 "preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem injective.preimage_image (hf : injective f) (s : set α) : «expr ⁻¹' » f («expr '' » f s) = s :=\n  preimage_image_eq s hf\n#align injective.preimage_image injective.preimage_image\n\n",
 "preimage_id_eq":
 "@[simp]\ntheorem preimage_id_eq : preimage (id : α → α) = id :=\n  rfl\n#align preimage_id_eq preimage_id_eq\n\n",
 "preimage_id'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_id' {s : set α} : «expr ⁻¹' » (fun x => x) s = s :=\n  rfl\n#align preimage_id' preimage_id'\n\n",
 "preimage_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_id {s : set α} : «expr ⁻¹' » id s = s :=\n  rfl\n#align preimage_id preimage_id\n\n",
 "preimage_eq_preimage'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_eq_preimage' {s t : set α} {f : β → α} (hs : s ⊆ range f) (ht : t ⊆ range f) :\n    «expr ⁻¹' » f s = «expr ⁻¹' » f t ↔ s = t := by\n  constructor\n  · intro h\n    apply subset.antisymm\n    rw [← preimage_subset_preimage_iff hs, h]\n    rw [← preimage_subset_preimage_iff ht, h]\n  rintro rfl; rfl\n#align preimage_eq_preimage' preimage_eq_preimage'\n\n",
 "preimage_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_eq_preimage {f : β → α} (hf : surjective f) : «expr ⁻¹' » f s = «expr ⁻¹' » f t ↔ s = t :=\n  iff.intro (fun eq => by rw [← image_preimage_eq s hf, ← image_preimage_eq t hf, eq]) fun eq => eq ▸ rfl\n#align preimage_eq_preimage preimage_eq_preimage\n\n",
 "preimage_eq_iff_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_eq_iff_eq_image {f : α → β} (hf : bijective f) {s t} : «expr ⁻¹' » f s = t ↔ s = «expr '' » f t := by\n  rw [← image_eq_image hf.1, hf.2.image_preimage]\n#align preimage_eq_iff_eq_image preimage_eq_iff_eq_image\n\n",
 "preimage_eq_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_eq_empty_iff {s : set β} : «expr ⁻¹' » f s = ∅ ↔ Disjoint s (range f) :=\n  ⟨fun h =>\n    by\n    simp only [eq_empty_iff_forall_not_mem, disjoint_iff_inter_eq_empty, not_exists, mem_inter_iff, not_and, mem_range,\n      mem_preimage] at h⊢\n    intro y hy x hx\n    rw [← hx] at hy\n    exact h x hy, preimage_eq_empty⟩\n#align preimage_eq_empty_iff preimage_eq_empty_iff\n\n",
 "preimage_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_eq_empty {f : α → β} {s : set β} (h : Disjoint s (range f)) : «expr ⁻¹' » f s = ∅ := by\n  simpa using h.preimage f\n#align preimage_eq_empty preimage_eq_empty\n\n",
 "preimage_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\n@[simp]\ntheorem preimage_empty : «expr ⁻¹' » f ∅ = ∅ :=\n  rfl\n#align preimage_empty preimage_empty\n\n",
 "preimage_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_diff (f : α → β) (s t : set β) : «expr ⁻¹' » f (s \\ t) = «expr ⁻¹' » f s \\ «expr ⁻¹' » f t :=\n  rfl\n#align preimage_diff preimage_diff\n\n",
 "preimage_const_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_const_of_not_mem {b : β} {s : set β} (h : b ∉ s) : «expr ⁻¹' » (fun x : α => b) s = ∅ :=\n  eq_empty_of_subset_empty fun x hx => h hx\n#align preimage_const_of_not_mem preimage_const_of_not_mem\n\n",
 "preimage_const_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_const_of_mem {b : β} {s : set β} (h : b ∈ s) : «expr ⁻¹' » (fun x : α => b) s = univ :=\n  eq_univ_of_forall fun x => h\n#align preimage_const_of_mem preimage_const_of_mem\n\n",
 "preimage_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_const (b : β) (s : set β) [decidable (b ∈ s)] :\n    «expr ⁻¹' » (fun x : α => b) s = if b ∈ s then univ else ∅ :=\n  by\n  split_ifs with hb hb\n  exacts[preimage_const_of_mem hb, preimage_const_of_not_mem hb]\n#align preimage_const preimage_const\n\n",
 "preimage_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_congr {f g : α → β} {s : set β} (h : ∀ x : α, f x = g x) : «expr ⁻¹' » f s = «expr ⁻¹' » g s :=\n  by\n  congr with x\n  apply_assumption\n#align preimage_congr preimage_congr\n\n",
 "preimage_compl_eq_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem preimage_compl_eq_image_compl [BooleanAlgebra α] (S : set α) : «expr ⁻¹' » compl S = «expr '' » compl S :=\n  Set.ext fun x =>\n    ⟨fun h => ⟨«expr ᶜ» x, h, compl_compl x⟩, fun h =>\n      exists.elim h fun y hy => (compl_eq_comm.mp hy.2).symm.subst hy.1⟩\n#align preimage_compl_eq_image_compl preimage_compl_eq_image_compl\n\n",
 "preimage_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_compl {s : set β} : «expr ⁻¹' » f («expr ᶜ» s) = «expr ᶜ» («expr ⁻¹' » f s) :=\n  rfl\n#align preimage_compl preimage_compl\n\n",
 "preimage_comp_eq":
 "theorem preimage_comp_eq : preimage (g ∘ f) = preimage f ∘ preimage g :=\n  rfl\n#align preimage_comp_eq preimage_comp_eq\n\n",
 "preimage_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_comp {s : set γ} : «expr ⁻¹' » (g ∘ f) s = «expr ⁻¹' » f («expr ⁻¹' » g s) :=\n  rfl\n#align preimage_comp preimage_comp\n\n",
 "preimage_coe_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_coe_nonempty {s t : set α} : («expr ⁻¹' » (coe : s → α) t).nonempty ↔ (s ∩ t).nonempty := by\n  rw [inter_comm, ← image_preimage_coe, nonempty_image_iff]\n#align preimage_coe_nonempty preimage_coe_nonempty\n\n",
 "preimage_coe_inter_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_coe_inter_self (s t : set α) : «expr ⁻¹' » (coe : s → α) (t ∩ s) = «expr ⁻¹' » coe t := by\n  rw [preimage_coe_eq_preimage_coe_iff, inter_assoc, inter_self]\n#align preimage_coe_inter_self preimage_coe_inter_self\n\n",
 "preimage_coe_eq_preimage_coe_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_coe_eq_preimage_coe_iff {s t u : set α} :\n    «expr ⁻¹' » (coe : s → α) t = «expr ⁻¹' » coe u ↔ t ∩ s = u ∩ s := by\n  rw [← image_preimage_coe, ← image_preimage_coe, coe_injective.image_injective.eq_iff]\n#align preimage_coe_eq_preimage_coe_iff preimage_coe_eq_preimage_coe_iff\n\n",
 "preimage_coe_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_coe_eq_empty {s t : set α} : «expr ⁻¹' » (coe : s → α) t = ∅ ↔ s ∩ t = ∅ := by\n  simp only [← not_nonempty_iff_eq_empty, preimage_coe_nonempty]\n#align preimage_coe_eq_empty preimage_coe_eq_empty\n\n",
 "preimage_coe_compl'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem preimage_coe_compl' (s : set α) : «expr ⁻¹' » (coe : «expr ᶜ» s → α) s = ∅ :=\n  preimage_coe_eq_empty.2 (compl_inter_self s)\n#align preimage_coe_compl' preimage_coe_compl'\n\n",
 "preimage_coe_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem preimage_coe_compl (s : set α) : «expr ⁻¹' » (coe : s → α) («expr ᶜ» s) = ∅ :=\n  preimage_coe_eq_empty.2 (inter_compl_self s)\n#align preimage_coe_compl preimage_coe_compl\n\n",
 "preimage'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem nonempty.preimage' {s : set β} (hs : s.nonempty) {f : α → β} (hf : s ⊆ Set.range f) :\n    («expr ⁻¹' » f s).nonempty :=\n  let ⟨y, hy⟩ := hs\n  let ⟨x, hx⟩ := hf hy\n  ⟨x, Set.mem_preimage.2 <| hx.symm ▸ hy⟩\n#align nonempty.preimage' nonempty.preimage'\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Disjoint.preimage /-\ntheorem Disjoint.preimage (f : α → β) {s t : set β} (h : Disjoint s t) : Disjoint («expr ⁻¹' » f s) («expr ⁻¹' » f t) :=\n  disjoint_iff_inf_le.mpr fun x hx => h.le_bot hx\n#align disjoint.preimage Disjoint.preimage\n-/\n\n",
 "of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n#print Disjoint.of_preimage /-\ntheorem Disjoint.of_preimage (hf : surjective f) {s t : set β} (h : Disjoint («expr ⁻¹' » f s) («expr ⁻¹' » f t)) :\n    Disjoint s t := by\n  rw [disjoint_iff_inter_eq_empty, ← image_preimage_eq (_ ∩ _) hf, preimage_inter, h.inter_eq, image_empty]\n#align disjoint.of_preimage Disjoint.of_preimage\n-/\n\n",
 "of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Disjoint.of_image /-\ntheorem Disjoint.of_image (h : Disjoint («expr '' » f s) («expr '' » f t)) : Disjoint s t :=\n  disjoint_iff_inf_le.mpr fun x hx => disjoint_left.1 h (mem_image_of_mem _ hx.1) (mem_image_of_mem _ hx.2)\n#align disjoint.of_image Disjoint.of_image\n-/\n\n",
 "nontrivial_of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If the preimage of a set under an injective map is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_preimage {f : α → β} (hf : function.injective f) (s : set β) (hs : («expr ⁻¹' » f s).nontrivial) :\n    s.nontrivial :=\n  (hs.image hf).mono <| image_preimage_subset _ _\n#align nontrivial_of_preimage nontrivial_of_preimage\n\n",
 "nontrivial_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_image (f : α → β) (s : set α) (hs : («expr '' » f s).nontrivial) : s.nontrivial :=\n  let ⟨_, ⟨x, hx, rfl⟩, _, ⟨y, hy, rfl⟩, hxy⟩ := hs\n  ⟨x, hx, y, hy, mt (congr_arg f) hxy⟩\n#align nontrivial_of_image nontrivial_of_image\n\n",
 "nonempty_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem surjective.nonempty_preimage (hf : surjective f) {s : set β} : («expr ⁻¹' » f s).nonempty ↔ s.nonempty := by\n  rw [← nonempty_image_iff, hf.image_preimage]\n#align surjective.nonempty_preimage surjective.nonempty_preimage\n\n",
 "nonempty_of_nonempty_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem nonempty_of_nonempty_preimage {s : set β} {f : α → β} (hf : («expr ⁻¹' » f s).nonempty) : s.nonempty :=\n  let ⟨x, hx⟩ := hf\n  ⟨f x, hx⟩\n#align nonempty_of_nonempty_preimage nonempty_of_nonempty_preimage\n\n",
 "nonempty_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem nonempty_image_iff {f : α → β} {s : set α} : («expr '' » f s).nonempty ↔ s.nonempty :=\n  ⟨Nonempty.of_image, fun h => h.image f⟩\n#align nonempty_image_iff nonempty_image_iff\n\n",
 "monotone_image":
 "/-- `set.image` is monotone. See `set.image_subset` for the statement in terms of `⊆`. -/\ntheorem monotone_image {f : α → β} : monotone (image f) := fun s t => image_subset _\n#align monotone_image monotone_image\n\n",
 "mem_set_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print Function.Injective.mem_set_image /-\ntheorem Function.Injective.mem_set_image {f : α → β} (hf : injective f) {s : set α} {a : α} :\n    f a ∈ «expr '' » f s ↔ a ∈ s :=\n  ⟨fun ⟨b, hb, eq⟩ => hf eq ▸ hb, mem_image_of_mem f⟩\n#align function.injective.mem_set_image Function.Injective.mem_set_image\n-/\n\n",
 "mem_range_succ":
 "#print Nat.mem_range_succ /-\ntheorem Nat.mem_range_succ (i : ℕ) : i ∈ range nat.succ ↔ 0 < i :=\n  ⟨by\n    rintro ⟨n, rfl⟩\n    exact nat.succ_pos n, fun h => ⟨_, nat.succ_pred_eq_of_pos h⟩⟩\n#align nat.mem_range_succ Nat.mem_range_succ\n-/\n\n",
 "mem_range_self":
 "@[simp]\ntheorem mem_range_self (i : ι) : f i ∈ range f :=\n  ⟨i, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range_of_mem_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_range_of_mem_image (f : α → β) (s) {x : β} (h : x ∈ «expr '' » f s) : x ∈ range f :=\n  image_subset_range f s h\n#align mem_range_of_mem_image mem_range_of_mem_image\n\n",
 "mem_range_iff_exists_unique":
 "theorem injective.mem_range_iff_exists_unique (hf : injective f) {b : β} : b ∈ range f ↔ ∃! a, f a = b :=\n  ⟨fun ⟨a, h⟩ => ⟨a, h, fun a' ha => hf (ha.trans h.symm)⟩, exists_unique.exists⟩\n#align injective.mem_range_iff_exists_unique injective.mem_range_iff_exists_unique\n\n",
 "mem_range":
 "@[simp]\ntheorem mem_range {x : α} : x ∈ range f ↔ ∃ y, f y = x :=\n  iff.rfl\n#align mem_range mem_range\n\n",
 "mem_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem mem_preimage {s : set β} {a : α} : a ∈ «expr ⁻¹' » f s ↔ f a ∈ s :=\n  iff.rfl\n#align mem_preimage mem_preimage\n\n",
 "mem_image_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_of_mem (f : α → β) {x : α} {a : set α} (h : x ∈ a) : f x ∈ «expr '' » f a :=\n  ⟨_, h, rfl⟩\n#align mem_image_of_mem mem_image_of_mem\n\n",
 "mem_image_iff_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_iff_of_inverse {f : α → β} {g : β → α} {b : β} {s : set α} (h₁ : left_inverse g f)\n    (h₂ : right_inverse g f) : b ∈ «expr '' » f s ↔ g b ∈ s := by rw [image_eq_preimage_of_inverse h₁ h₂] <;> rfl\n#align mem_image_iff_of_inverse mem_image_iff_of_inverse\n\n",
 "mem_image_iff_bex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_iff_bex {f : α → β} {s : set α} {y : β} : y ∈ «expr '' » f s ↔ ∃ (x : _)(_ : x ∈ s), f x = y :=\n  bex_def.symm\n#align mem_image_iff_bex mem_image_iff_bex\n\n",
 "mem_image_elim_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_elim_on {f : α → β} {s : set α} {C : β → Prop} {y : β} (h_y : y ∈ «expr '' » f s)\n    (h : ∀ x : α, x ∈ s → C (f x)) : C y :=\n  mem_image_elim h h_y\n#align mem_image_elim_on mem_image_elim_on\n\n",
 "mem_image_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_image_elim {f : α → β} {s : set α} {C : β → Prop} (h : ∀ x : α, x ∈ s → C (f x)) :\n    ∀ {y : β}, y ∈ «expr '' » f s → C y\n  | _, ⟨a, a_in, rfl⟩ => h a a_in\n#align mem_image_elim mem_image_elim\n\n",
 "mem_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem mem_image (f : α → β) (s : set α) (y : β) : y ∈ «expr '' » f s ↔ ∃ x, x ∈ s ∧ f x = y :=\n  iff.rfl\n#align mem_image mem_image\n\n",
 "mem_compl_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem mem_compl_image [BooleanAlgebra α] (t : α) (S : set α) : t ∈ «expr '' » compl S ↔ «expr ᶜ» t ∈ S := by\n  simp [← preimage_compl_eq_image_compl]\n#align mem_compl_image mem_compl_image\n\n",
 "left_inverse_range_splitting":
 "-- When `f` is injective, see also `equiv.of_injective`.\ntheorem left_inverse_range_splitting (f : α → β) : left_inverse (rangeFactorization f) (rangeSplitting f) := fun x =>\n  by\n  ext\n  simp only [range_factorization_coe]\n  apply apply_range_splitting\n#align left_inverse_range_splitting left_inverse_range_splitting\n\n",
 "is_compl_range_some_none":
 "theorem is_compl_range_some_none (α : Type _) : IsCompl (range (some : α → option α)) {none} :=\n  IsCompl.of_le (fun x ⟨⟨a, ha⟩, (hn : x = none)⟩ => option.some_ne_none _ (ha.trans hn)) fun x hx =>\n    option.cases_on x (or.inr rfl) fun x => or.inl <| mem_range_self _\n#align is_compl_range_some_none is_compl_range_some_none\n\n",
 "is_compl_range_inl_range_inr":
 "theorem is_compl_range_inl_range_inr : IsCompl (range <| @sum.inl α β) (range sum.inr) :=\n  IsCompl.of_le\n    (by\n      rintro y ⟨⟨x₁, rfl⟩, ⟨x₂, _⟩⟩\n      cc)\n    (by rintro (x | y) - <;> [left, right] <;> exact mem_range_self _)\n#align is_compl_range_inl_range_inr is_compl_range_inl_range_inr\n\n",
 "inter_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem inter_preimage_subset (s : set α) (t : set β) (f : α → β) :\n    s ∩ «expr ⁻¹' » f t ⊆ «expr ⁻¹' » f («expr '' » f s ∩ t) := fun x h => ⟨mem_image_of_mem _ h.left, h.right⟩\n#align inter_preimage_subset inter_preimage_subset\n\n",
 "insert_none_range_some":
 "@[simp]\ntheorem insert_none_range_some (α : Type _) : insert none (range (some : α → option α)) = univ :=\n  (isCompl_range_some_none α).symm.sup_eq_top\n#align insert_none_range_some insert_none_range_some\n\n",
 "insert_image_compl_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem insert_image_compl_eq_range (f : α → β) (x : α) : insert (f x) («expr '' » f («expr ᶜ» {x})) = range f :=\n  by\n  ext y; rw [mem_range, mem_insert_iff, mem_image]\n  constructor\n  · rintro (h | ⟨x', hx', h⟩)\n    · exact ⟨x, h.symm⟩\n    · exact ⟨x', h⟩\n  · rintro ⟨x', h⟩\n    by_cases hx : x' = x\n    · left\n      rw [← h, hx]\n    · right\n      refine' ⟨_, _, h⟩\n      rw [mem_compl_singleton_iff]\n      exact hx\n#align insert_image_compl_eq_range insert_image_compl_eq_range\n\n",
 "injective_iff":
 "theorem injective_iff {α β} {f : option α → β} : injective f ↔ injective (f ∘ some) ∧ f none ∉ range (f ∘ some) :=\n  by\n  simp only [mem_range, not_exists, (· ∘ ·)]\n  refine' ⟨fun hf => ⟨hf.comp (option.some_injective _), fun x => hf.ne <| option.some_ne_none _⟩, _⟩\n  rintro ⟨h_some, h_none⟩ (_ | a) (_ | b) hab\n  exacts[rfl, (h_none _ hab.symm).elim, (h_none _ hab).elim, congr_arg some (h_some hab)]\n#align injective_iff injective_iff\n\n",
 "image_univ_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_univ_of_surjective {ι : Type _} {f : ι → β} (H : surjective f) : «expr '' » f univ = univ :=\n  eq_univ_of_forall <| by simpa [image]\n#align image_univ_of_surjective image_univ_of_surjective\n\n",
 "image_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_univ {f : α → β} : «expr '' » f univ = range f :=\n  by\n  ext\n  simp [image, range]\n#align image_univ image_univ\n\n",
 "image_union_image_compl_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem image_union_image_compl_eq_range (f : α → β) : «expr '' » f s ∪ «expr '' » f («expr ᶜ» s) = range f := by\n  rw [← image_union, ← image_univ, ← union_compl_self]\n#align image_union_image_compl_eq_range image_union_image_compl_eq_range\n\n",
 "image_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_union (f : α → β) (s t : set α) : «expr '' » f (s ∪ t) = «expr '' » f s ∪ «expr '' » f t :=\n  ext fun x =>\n    ⟨by rintro ⟨a, h | h, rfl⟩ <;> [left, right] <;> exact ⟨_, h, rfl⟩, by\n      rintro (⟨a, h, rfl⟩ | ⟨a, h, rfl⟩) <;> refine' ⟨_, _, rfl⟩ <;> [left, right] <;> exact h⟩\n#align image_union image_union\n\n",
 "image_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_symm_diff (hf : injective f) (s t : set α) :\n    «expr '' » f («expr ∆ » s t) = «expr ∆ » («expr '' » f s) («expr '' » f t) := by\n  simp_rw [Set.symmDiff_def, image_union, image_diff hf]\n#align image_symm_diff image_symm_diff\n\n",
 "image_swap_eq_preimage_swap":
 "theorem image_swap_eq_preimage_swap : image (@prod.swap α β) = preimage prod.swap :=\n  image_eq_preimage_of_inverse Prod.swap_leftInverse Prod.swap_rightInverse\n#align image_swap_eq_preimage_swap image_swap_eq_preimage_swap\n\n",
 "image_surjective":
 "@[simp]\ntheorem image_surjective : surjective (image f) ↔ surjective f :=\n  by\n  refine' ⟨fun h y => _, surjective.image_surjective⟩\n  cases' h {y} with s hs\n  have := mem_singleton y; rw [← hs] at this; rcases this with ⟨x, h1x, h2x⟩\n  exact ⟨x, h2x⟩\n#align image_surjective image_surjective\n\n",
 "image_subset_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_subset_range (f : α → β) (s) : «expr '' » f s ⊆ range f := by\n  rw [← image_univ] <;> exact image_subset _ (subset_univ _)\n#align image_subset_range image_subset_range\n\n",
 "image_subset_preimage_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_subset_preimage_of_inverse {f : α → β} {g : β → α} (I : left_inverse g f) (s : set α) :\n    «expr '' » f s ⊆ «expr ⁻¹' » g s := fun b ⟨a, h, e⟩ => e ▸ ((I a).symm ▸ h : g (f a) ∈ s)\n#align image_subset_preimage_of_inverse image_subset_preimage_of_inverse\n\n",
 "image_subset_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_subset_image_iff {f : α → β} (hf : injective f) : «expr '' » f s ⊆ «expr '' » f t ↔ s ⊆ t :=\n  by\n  refine' iff.symm <| iff.intro (image_subset f) fun h => _\n  rw [← preimage_image_eq s hf, ← preimage_image_eq t hf]\n  exact preimage_mono h\n#align image_subset_image_iff image_subset_image_iff\n\n",
 "image_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- image and preimage are a Galois connection -/\n@[simp]\ntheorem image_subset_iff {s : set α} {t : set β} {f : α → β} : «expr '' » f s ⊆ t ↔ s ⊆ «expr ⁻¹' » f t :=\n  ball_image_iff\n#align image_subset_iff image_subset_iff\n\n",
 "image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- Image is monotone with respect to `⊆`. See `set.monotone_image` for the statement in\nterms of `≤`. -/\ntheorem image_subset {a b : set α} (f : α → β) (h : a ⊆ b) : «expr '' » f a ⊆ «expr '' » f b :=\n  by\n  simp only [subset_def, mem_image]\n  exact fun x => fun ⟨w, h1, h2⟩ => ⟨w, h h1, h2⟩\n#align image_subset image_subset\n\n",
 "image_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_singleton {f : α → β} {a : α} : «expr '' » f {a} = {f a} :=\n  by\n  ext\n  simp [image, eq_comm]\n#align image_singleton image_singleton\n\n",
 "image_preimage_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_val (s t : set α) : «expr '' » (subtype.val : s → α) («expr ⁻¹' » subtype.val t) = t ∩ s :=\n  image_preimage_coe s t\n#align image_preimage_val image_preimage_val\n\n",
 "image_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_subset (f : α → β) (s : set β) : «expr '' » f («expr ⁻¹' » f s) ⊆ s :=\n  image_subset_iff.2 Subset.rfl\n#align image_preimage_subset image_preimage_subset\n\n",
 "image_preimage_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_preimage_inter (f : α → β) (s : set α) (t : set β) :\n    «expr '' » f («expr ⁻¹' » f t ∩ s) = t ∩ «expr '' » f s := by simp only [inter_comm, image_inter_preimage]\n#align image_preimage_inter image_preimage_inter\n\n",
 "image_preimage_inl_union_image_preimage_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_inl_union_image_preimage_inr (s : set (Sum α β)) :\n    «expr '' » sum.inl («expr ⁻¹' » sum.inl s) ∪ «expr '' » sum.inr («expr ⁻¹' » sum.inr s) = s := by\n  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, ← inter_distrib_left, range_inl_union_range_inr,\n    inter_univ]\n#align image_preimage_inl_union_image_preimage_inr image_preimage_inl_union_image_preimage_inr\n\n",
 "image_preimage_eq_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_eq_of_subset {f : α → β} {s : set β} (hs : s ⊆ range f) : «expr '' » f («expr ⁻¹' » f s) = s :=\n  by rw [image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]\n#align image_preimage_eq_of_subset image_preimage_eq_of_subset\n\n",
 "image_preimage_eq_inter_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_eq_inter_range {f : α → β} {t : set β} : «expr '' » f («expr ⁻¹' » f t) = t ∩ range f :=\n  ext fun x =>\n    ⟨fun ⟨x, hx, HEq⟩ => HEq ▸ ⟨hx, mem_range_self _⟩, fun ⟨hx, ⟨y, h_eq⟩⟩ =>\n      h_eq ▸ mem_image_of_mem f <| show y ∈ «expr ⁻¹' » f t by simp [preimage, h_eq, hx]⟩\n#align image_preimage_eq_inter_range image_preimage_eq_inter_range\n\n",
 "image_preimage_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_eq_iff {f : α → β} {s : set β} : «expr '' » f («expr ⁻¹' » f s) = s ↔ s ⊆ range f :=\n  ⟨by\n    intro h\n    rw [← h]\n    apply image_subset_range, image_preimage_eq_of_subset⟩\n#align image_preimage_eq_iff image_preimage_eq_iff\n\n",
 "image_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_preimage_eq {f : α → β} (s : set β) (h : surjective f) : «expr '' » f («expr ⁻¹' » f s) = s :=\n  Subset.antisymm (image_preimage_subset f s) fun x hx =>\n    let ⟨y, e⟩ := h x\n    ⟨y, (e.symm ▸ hx : f y ∈ s), e⟩\n#align image_preimage_eq image_preimage_eq\n\n",
 "image_preimage_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem image_preimage_coe (s t : set α) : «expr '' » (coe : s → α) («expr ⁻¹' » coe t) = t ∩ s :=\n  image_preimage_eq_inter_range.trans <| congr_arg _ range_coe\n#align image_preimage_coe image_preimage_coe\n\n",
 "image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem surjective.image_preimage (hf : surjective f) (s : set β) : «expr '' » f («expr ⁻¹' » f s) = s :=\n  image_preimage_eq s hf\n#align surjective.image_preimage surjective.image_preimage\n\n",
 "image_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the only elements outside `s` are those left fixed by `σ`, then mapping by `σ` has no effect.\n-/\ntheorem image_perm {s : set α} {σ : equiv.perm α} (hs : { a : α | σ a ≠ a } ⊆ s) : «expr '' » σ s = s :=\n  by\n  ext i\n  obtain hi | hi := eq_or_ne (σ i) i\n  · refine' ⟨_, fun h => ⟨i, h, hi⟩⟩\n    rintro ⟨j, hj, h⟩\n    rwa [σ.injective (hi.trans h.symm)]\n  · refine' iff_of_true ⟨σ.symm i, hs fun h => hi _, σ.apply_symm_apply _⟩ (hs hi)\n    convert congr_arg σ h <;> exact (σ.apply_symm_apply _).symm\n#align image_perm image_perm\n\n",
 "image_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_pair (f : α → β) (a b : α) : «expr '' » f {a, b} = {f a, f b} := by\n  simp only [image_insert_eq, image_singleton]\n#align image_pair image_pair\n\n",
 "image_inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_inter_subset (f : α → β) (s t : set α) : «expr '' » f (s ∩ t) ⊆ «expr '' » f s ∩ «expr '' » f t :=\n  subset_inter (image_subset _ <| inter_subset_left _ _) (image_subset _ <| inter_subset_right _ _)\n#align image_inter_subset image_inter_subset\n\n",
 "image_inter_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_inter_preimage (f : α → β) (s : set α) (t : set β) :\n    «expr '' » f (s ∩ «expr ⁻¹' » f t) = «expr '' » f s ∩ t :=\n  by\n  apply subset.antisymm\n  ·\n    calc\n      «expr '' » f (s ∩ «expr ⁻¹' » f t) ⊆ «expr '' » f s ∩ «expr '' » f («expr ⁻¹' » f t) := image_inter_subset _ _ _\n      _ ⊆ «expr '' » f s ∩ t := inter_subset_inter_right _ (image_preimage_subset f t)\n      \n  · rintro _ ⟨⟨x, h', rfl⟩, h⟩\n    exact ⟨x, ⟨h', h⟩, rfl⟩\n#align image_inter_preimage image_inter_preimage\n\n",
 "image_inter_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_inter_on {f : α → β} {s t : set α} (h : ∀ x ∈ t, ∀ y ∈ s, f x = f y → x = y) :\n    «expr '' » f (s ∩ t) = «expr '' » f s ∩ «expr '' » f t :=\n  (image_inter_subset _ _ _).antisymm fun b ⟨⟨a₁, ha₁, h₁⟩, ⟨a₂, ha₂, h₂⟩⟩ =>\n    have : a₂ = a₁ := h _ ha₂ _ ha₁ (by simp [*])\n    ⟨a₁, ⟨ha₁, this ▸ ha₂⟩, h₁⟩\n#align image_inter_on image_inter_on\n\n",
 "image_inter_nonempty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem image_inter_nonempty_iff {f : α → β} {s : set α} {t : set β} :\n    («expr '' » f s ∩ t).nonempty ↔ (s ∩ «expr ⁻¹' » f t).nonempty := by rw [← image_inter_preimage, nonempty_image_iff]\n#align image_inter_nonempty_iff image_inter_nonempty_iff\n\n",
 "image_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_inter {f : α → β} {s t : set α} (H : injective f) :\n    «expr '' » f (s ∩ t) = «expr '' » f s ∩ «expr '' » f t :=\n  image_inter_on fun x _ y _ h => H h\n#align image_inter image_inter\n\n",
 "image_insert_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_insert_eq {f : α → β} {a : α} {s : set α} : «expr '' » f (insert a s) = insert (f a) («expr '' » f s) :=\n  by\n  ext\n  simp [and_or_left, exists_or, eq_comm, or_comm', and_comm']\n#align image_insert_eq image_insert_eq\n\n",
 "image_injective":
 "@[simp]\ntheorem image_injective : injective (image f) ↔ injective f :=\n  by\n  refine' ⟨fun h x x' hx => _, injective.image_injective⟩\n  rw [← singleton_eq_singleton_iff]; apply h\n  rw [image_singleton, image_singleton, hx]\n#align image_injective image_injective\n\n",
 "image_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem left_inverse.image_image {g : β → α} (h : left_inverse g f) (s : set α) : «expr '' » g («expr '' » f s) = s :=\n  by rw [← image_comp, h.comp_eq_id, image_id]\n#align left_inverse.image_image left_inverse.image_image\n\n",
 "image_id'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A variant of `image_id` -/\n@[simp]\ntheorem image_id' (s : set α) : «expr '' » (fun x => x) s = s :=\n  by\n  ext\n  simp\n#align image_id' image_id'\n\n",
 "image_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_id (s : set α) : «expr '' » id s = s := by simp\n#align image_id image_id\n\n",
 "image_factorization_eq":
 "theorem image_factorization_eq {f : α → β} {s : set α} : subtype.val ∘ imageFactorization f s = f ∘ subtype.val :=\n  funext fun p => rfl\n#align image_factorization_eq image_factorization_eq\n\n",
 "image_eta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_eta (f : α → β) : «expr '' » f s = «expr '' » (fun x => f x) s :=\n  rfl\n#align image_eta image_eta\n\n",
 "image_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_eq_range (f : α → β) (s : set α) : «expr '' » f s = range fun x : s => f x :=\n  by\n  ext\n  constructor\n  rintro ⟨x, h1, h2⟩\n  exact ⟨⟨x, h1⟩, h2⟩\n  rintro ⟨⟨x, h1⟩, h2⟩\n  exact ⟨x, h1, h2⟩\n#align image_eq_range image_eq_range\n\n",
 "image_eq_preimage_of_inverse":
 "theorem image_eq_preimage_of_inverse {f : α → β} {g : β → α} (h₁ : left_inverse g f) (h₂ : right_inverse g f) :\n    image f = preimage g :=\n  funext fun s => Subset.antisymm (image_subset_preimage_of_inverse h₁ s) (preimage_subset_image_of_inverse h₂ s)\n#align image_eq_preimage_of_inverse image_eq_preimage_of_inverse\n\n",
 "image_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_eq_image {f : α → β} (hf : injective f) : «expr '' » f s = «expr '' » f t ↔ s = t :=\n  iff.symm <| iff.intro (fun eq => eq ▸ rfl) fun eq => by rw [← preimage_image_eq s hf, ← preimage_image_eq t hf, eq]\n#align image_eq_image image_eq_image\n\n",
 "image_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_eq_empty {α β} {f : α → β} {s : set α} : «expr '' » f s = ∅ ↔ s = ∅ :=\n  by\n  simp only [eq_empty_iff_forall_not_mem]\n  exact ⟨fun H a ha => H _ ⟨_, ha, rfl⟩, fun H b ⟨_, ha, _⟩ => H _ ha⟩\n#align image_eq_empty image_eq_empty\n\n",
 "image_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem image_empty (f : α → β) : «expr '' » f ∅ = ∅ := by\n  ext\n  simp\n#align image_empty image_empty\n\n",
 "image_diff_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_diff_preimage {f : α → β} {s : set α} {t : set β} :\n    «expr '' » f (s \\ «expr ⁻¹' » f t) = «expr '' » f s \\ t := by\n  simp_rw [diff_eq, ← preimage_compl, image_inter_preimage]\n#align image_diff_preimage image_diff_preimage\n\n",
 "image_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_diff {f : α → β} (hf : injective f) (s t : set α) :\n    «expr '' » f (s \\ t) = «expr '' » f s \\ «expr '' » f t :=\n  Subset.antisymm (Subset.trans (image_inter_subset _ _ _) <| inter_subset_inter_right _ <| image_compl_subset hf)\n    (subset_image_diff f s t)\n#align image_diff image_diff\n\n",
 "image_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem nonempty.image_const {s : set α} (hs : s.nonempty) (a : β) : «expr '' » (fun _ => a) s = {a} :=\n  ext fun x =>\n    ⟨fun ⟨y, _, h⟩ => h ▸ mem_singleton _, fun h => (eq_of_mem_singleton h).symm ▸ hs.imp fun y hy => ⟨hy, rfl⟩⟩\n#align nonempty.image_const nonempty.image_const\n\n",
 "image_congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A common special case of `image_congr` -/\ntheorem image_congr' {f g : α → β} {s : set α} (h : ∀ x : α, f x = g x) : «expr '' » f s = «expr '' » g s :=\n  image_congr fun x _ => h x\n#align image_congr' image_congr'\n\n",
 "image_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[congr]\ntheorem image_congr {f g : α → β} {s : set α} (h : ∀ a ∈ s, f a = g a) : «expr '' » f s = «expr '' » g s := by\n  safe [ext_iff, iff_def]\n#align image_congr image_congr\n\n",
 "image_compl_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_compl_subset {f : α → β} {s : set α} (H : injective f) :\n    «expr '' » f («expr ᶜ» s) ⊆ «expr ᶜ» («expr '' » f s) :=\n  disjoint.subset_compl_left <| by simp [disjoint_iff_inf_le, ← image_inter H]\n#align image_compl_subset image_compl_subset\n\n",
 "image_compl_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem image_compl_preimage {f : α → β} {s : set β} : «expr '' » f («expr ᶜ» («expr ⁻¹' » f s)) = range f \\ s := by\n  rw [compl_eq_univ_diff, image_diff_preimage, image_univ]\n#align image_compl_preimage image_compl_preimage\n\n",
 "image_compl_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_compl_eq {f : α → β} {s : set α} (H : bijective f) :\n    «expr '' » f («expr ᶜ» s) = «expr ᶜ» («expr '' » f s) :=\n  Subset.antisymm (image_compl_subset H.1) (subset_image_compl H.2)\n#align image_compl_eq image_compl_eq\n\n",
 "image_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_comp (f : β → γ) (g : α → β) (a : set α) : «expr '' » (f ∘ g) a = «expr '' » f («expr '' » g a) :=\n  Subset.antisymm (ball_image_of_ball fun a ha => mem_image_of_mem _ <| mem_image_of_mem _ ha)\n    (ball_image_of_ball <| ball_image_of_ball fun a ha => mem_image_of_mem _ ha)\n#align image_comp image_comp\n\n",
 "image_comm":
 "theorem image_comm {β'} {f : β → γ} {g : α → β} {f' : α → β'} {g' : β' → γ} (h_comm : ∀ a, f (g a) = g' (f' a)) :\n    (s.image g).image f = (s.image f').image g' := by simp_rw [image_image, h_comm]\n#align image_comm image_comm\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of a nontrivial set under an injective map is nontrivial. -/\ntheorem nontrivial.image (hs : s.nontrivial) {f : α → β} (hf : function.injective f) : («expr '' » f s).nontrivial :=\n  let ⟨x, hx, y, hy, hxy⟩ := hs\n  ⟨f x, mem_image_of_mem f hx, f y, mem_image_of_mem f hy, hf.ne hxy⟩\n#align nontrivial.image nontrivial.image\n\n",
 "forall_subtype_range_iff":
 "theorem forall_subtype_range_iff {p : range f → Prop} : (∀ a : range f, p a) ↔ ∀ i, p ⟨f i, mem_range_self _⟩ :=\n  ⟨fun H i => H _, fun H ⟨y, i, hi⟩ => by\n    subst hi\n    apply H⟩\n#align forall_subtype_range_iff forall_subtype_range_iff\n\n",
 "forall_range_iff":
 "theorem forall_range_iff {p : α → Prop} : (∀ a ∈ range f, p a) ↔ ∀ i, p (f i) := by simp\n#align forall_range_iff forall_range_iff\n\n",
 "exists_unique_of_mem_range":
 "theorem injective.exists_unique_of_mem_range (hf : injective f) {b : β} (hb : b ∈ range f) : ∃! a, f a = b :=\n  hf.mem_range_iff_exists_unique.mp hb\n#align injective.exists_unique_of_mem_range injective.exists_unique_of_mem_range\n\n",
 "exists_subtype_range_iff":
 "theorem exists_subtype_range_iff {p : range f → Prop} : (∃ a : range f, p a) ↔ ∃ i, p ⟨f i, mem_range_self _⟩ :=\n  ⟨fun ⟨⟨a, i, hi⟩, ha⟩ => by\n    subst a\n    exact ⟨i, ha⟩, fun ⟨i, hi⟩ => ⟨_, hi⟩⟩\n#align exists_subtype_range_iff exists_subtype_range_iff\n\n",
 "exists_subset_range_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (s «expr ⊆ » range[set.range] f) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem exists_subset_range_iff {f : α → β} {p : set β → Prop} :\n    (∃ (s : _)(_ : s ⊆ range f), p s) ↔ ∃ s, p («expr '' » f s) := by\n  simp only [exists_prop, exists_subset_range_and_iff]\n#align exists_subset_range_iff exists_subset_range_iff\n\n",
 "exists_subset_range_and_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem exists_subset_range_and_iff {f : α → β} {p : set β → Prop} :\n    (∃ s, s ⊆ range f ∧ p s) ↔ ∃ s, p («expr '' » f s) :=\n  ⟨fun ⟨s, hsf, hps⟩ => ⟨«expr ⁻¹' » f s, (image_preimage_eq_of_subset hsf).symm ▸ hps⟩, fun ⟨s, hs⟩ =>\n    ⟨«expr '' » f s, image_subset_range _ _, hs⟩⟩\n#align exists_subset_range_and_iff exists_subset_range_and_iff\n\n",
 "exists_set_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem exists_set_subtype {t : set α} (p : set α → Prop) :\n    (∃ s : set t, p («expr '' » coe s)) ↔ ∃ s : set α, s ⊆ t ∧ p s :=\n  by\n  constructor\n  · rintro ⟨s, hs⟩\n    refine' ⟨«expr '' » coe s, _, hs⟩\n    convert image_subset_range _ _\n    rw [range_coe]\n  rintro ⟨s, hs₁, hs₂⟩; refine' ⟨«expr ⁻¹' » coe s, _⟩\n  rw [image_preimage_eq_of_subset]; exact hs₂; rw [range_coe]; exact hs₁\n#align exists_set_subtype exists_set_subtype\n\n",
 "exists_range_iff'":
 "theorem exists_range_iff' {p : α → Prop} : (∃ a, a ∈ range f ∧ p a) ↔ ∃ i, p (f i) := by\n  simpa only [exists_prop] using exists_range_iff\n#align exists_range_iff' exists_range_iff'\n\n",
 "exists_range_iff":
 "theorem exists_range_iff {p : α → Prop} : (∃ a ∈ range f, p a) ↔ ∃ i, p (f i) := by simp\n#align exists_range_iff exists_range_iff\n\n",
 "exists_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem exists_image_iff (f : α → β) (x : set α) (P : β → Prop) : (∃ a : «expr '' » f x, P a) ↔ ∃ a : x, P (f a) :=\n  ⟨fun ⟨a, h⟩ => ⟨⟨_, a.prop.some_spec.1⟩, a.prop.some_spec.2.symm ▸ h⟩, fun ⟨a, h⟩ => ⟨⟨_, _, a.prop, rfl⟩, h⟩⟩\n#align exists_image_iff exists_image_iff\n\n",
 "eq_preimage_subtype_val_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem eq_preimage_subtype_val_iff {p : α → Prop} {s : set (subtype p)} {t : set α} :\n    s = «expr ⁻¹' » subtype.val t ↔ ∀ (x) (h : p x), (⟨x, h⟩ : subtype p) ∈ s ↔ x ∈ t :=\n  ⟨fun s_eq x h => by\n    rw [s_eq]\n    simp, fun h => ext fun ⟨x, hx⟩ => by simp [h]⟩\n#align eq_preimage_subtype_val_iff eq_preimage_subtype_val_iff\n\n",
 "eq_preimage_iff_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem eq_preimage_iff_image_eq {f : α → β} (hf : bijective f) {s t} : s = «expr ⁻¹' » f t ↔ «expr '' » f s = t := by\n  rw [← image_eq_image hf.1, hf.2.image_preimage]\n#align eq_preimage_iff_image_eq eq_preimage_iff_image_eq\n\n",
 "elim_range":
 "@[simp]\ntheorem sum.elim_range (f : α → γ) (g : β → γ) : range (sum.elim f g) = range f ∪ range g :=\n  Sum.range_eq _\n#align sum.elim_range sum.elim_range\n\n",
 "disjoint_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem disjoint_preimage_iff (hf : surjective f) {s t : set β} :\n    Disjoint («expr ⁻¹' » f s) («expr ⁻¹' » f t) ↔ Disjoint s t :=\n  ⟨Disjoint.of_preimage hf, Disjoint.preimage _⟩\n#align disjoint_preimage_iff disjoint_preimage_iff\n\n",
 "disjoint_image_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem disjoint_image_of_injective {f : α → β} (hf : injective f) {s t : set α} (hd : Disjoint s t) :\n    Disjoint («expr '' » f s) («expr '' » f t) :=\n  disjoint_image_image fun x hx y hy => hf.ne fun H => Set.disjoint_iff.1 hd ⟨hx, H.symm ▸ hy⟩\n#align disjoint_image_of_injective disjoint_image_of_injective\n\n",
 "disjoint_image_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem disjoint_image_image {f : β → α} {g : γ → α} {s : set β} {t : set γ} (h : ∀ b ∈ s, ∀ c ∈ t, f b ≠ g c) :\n    Disjoint («expr '' » f s) («expr '' » g t) :=\n  disjoint_iff_inf_le.mpr <| by rintro a ⟨⟨b, hb, eq⟩, c, hc, rfl⟩ <;> exact h b hb c hc eq\n#align disjoint_image_image disjoint_image_image\n\n",
 "disjoint_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem disjoint_image_iff (hf : injective f) : Disjoint («expr '' » f s) («expr '' » f t) ↔ Disjoint s t :=\n  ⟨Disjoint.of_image, disjoint_image_of_injective hf⟩\n#align disjoint_image_iff disjoint_image_iff\n\n",
 "compl_range_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_range_some (α : Type _) : «expr ᶜ» (range (some : α → option α)) = {none} :=\n  (isCompl_range_some_none α).compl_eq\n#align compl_range_some compl_range_some\n\n",
 "compl_range_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_range_inr : «expr ᶜ» (range (sum.inr : β → Sum α β)) = range (sum.inl : α → Sum α β) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr.symm\n#align compl_range_inr compl_range_inr\n\n",
 "compl_range_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_range_inl : «expr ᶜ» (range (sum.inl : α → Sum α β)) = range (sum.inr : β → Sum α β) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr\n#align compl_range_inl compl_range_inl\n\n",
 "compl_image_set_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem compl_image_set_of {p : set α → Prop} : «expr '' » compl { s | p s } = { s | p («expr ᶜ» s) } :=\n  congr_fun compl_image p\n#align compl_image_set_of compl_image_set_of\n\n",
 "compl_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem injective.compl_image_eq (hf : injective f) (s : set α) :\n    «expr ᶜ» («expr '' » f s) = «expr '' » f («expr ᶜ» s) ∪ «expr ᶜ» (range f) :=\n  by\n  ext y\n  rcases em (y ∈ range f) with (⟨x, rfl⟩ | hx)\n  · simp [hf.eq_iff]\n  · rw [mem_range, not_exists] at hx\n    simp [hx]\n#align injective.compl_image_eq injective.compl_image_eq\n\n",
 "compl_image":
 "theorem compl_image : image (compl : set α → set α) = preimage compl :=\n  image_eq_preimage_of_inverse compl_compl compl_compl\n#align compl_image compl_image\n\n",
 "compl_compl_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem compl_compl_image [BooleanAlgebra α] (S : set α) : «expr '' » compl («expr '' » compl S) = S := by\n  rw [← image_comp, compl_comp_compl, image_id]\n#align compl_compl_image compl_compl_image\n\n",
 "comp_range_splitting":
 "@[simp]\ntheorem comp_range_splitting (f : α → β) : f ∘ rangeSplitting f = coe :=\n  by\n  ext\n  simp only [Function.comp_apply]\n  apply apply_range_splitting\n#align comp_range_splitting comp_range_splitting\n\n",
 "coe_preimage_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_preimage_self (s : set α) : «expr ⁻¹' » (coe : s → α) s = univ := by\n  rw [← preimage_range (coe : s → α), range_coe]\n#align coe_preimage_self coe_preimage_self\n\n",
 "coe_image_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem coe_image_univ (s : set α) : «expr '' » (coe : s → α) Set.univ = s :=\n  image_univ.trans range_coe\n#align coe_image_univ coe_image_univ\n\n",
 "coe_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem coe_image_subset (s : set α) (t : set s) : «expr '' » coe t ⊆ s := fun x ⟨y, yt, yvaleq⟩ => by\n  rw [← yvaleq] <;> exact y.property\n#align coe_image_subset coe_image_subset\n\n",
 "coe_image_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[simp]\ntheorem coe_image_of_subset {s t : set α} (h : t ⊆ s) : «expr '' » coe { x : «expr↥ » s | ↑x ∈ t } = t :=\n  by\n  ext x\n  rw [Set.mem_image]\n  exact ⟨fun ⟨x', hx', hx⟩ => hx ▸ hx', fun hx => ⟨⟨x, h hx⟩, hx, rfl⟩⟩\n#align coe_image_of_subset coe_image_of_subset\n\n",
 "coe_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem coe_image {p : α → Prop} {s : set (subtype p)} :\n    «expr '' » coe s = { x | ∃ h : p x, (⟨x, h⟩ : subtype p) ∈ s } :=\n  Set.ext fun a => ⟨fun ⟨⟨a', ha'⟩, in_s, h_eq⟩ => h_eq ▸ ⟨ha', in_s⟩, fun ⟨ha, in_s⟩ => ⟨⟨a, ha⟩, in_s, rfl⟩⟩\n#align coe_image coe_image\n\n",
 "coe_comp_range_factorization":
 "@[simp]\ntheorem coe_comp_range_factorization (f : ι → β) : coe ∘ rangeFactorization f = f :=\n  rfl\n#align coe_comp_range_factorization coe_comp_range_factorization\n\n",
 "bex_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem bex_image_iff {f : α → β} {s : set α} {p : β → Prop} : (∃ y ∈ «expr '' » f s, p y) ↔ ∃ x ∈ s, p (f x) := by simp\n#align bex_image_iff bex_image_iff\n\n",
 "ball_image_of_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ball_image_of_ball {f : α → β} {s : set α} {p : β → Prop} (h : ∀ x ∈ s, p (f x)) : ∀ y ∈ «expr '' » f s, p y :=\n  ball_image_iff.2 h\n#align ball_image_of_ball ball_image_of_ball\n\n",
 "ball_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem ball_image_iff {f : α → β} {s : set α} {p : β → Prop} : (∀ y ∈ «expr '' » f s, p y) ↔ ∀ x ∈ s, p (f x) := by\n  simp\n#align ball_image_iff ball_image_iff\n\n",
 "apply_range_splitting":
 "-- This can not be a `@[simp]` lemma because the head of the left hand side is a variable.\ntheorem apply_range_splitting (f : α → β) (x : range f) : f (rangeSplitting f x) = x :=\n  x.2.some_spec\n#align apply_range_splitting apply_range_splitting\n\n"}