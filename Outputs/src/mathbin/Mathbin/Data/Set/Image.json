{"union_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem union_preimage_subset (s : set Î±) (t : set Î²) (f : Î± â†’ Î²) :\n    s âˆª Â«expr â»Â¹' Â» f t âŠ† Â«expr â»Â¹' Â» f (Â«expr '' Â» f s âˆª t) := fun x h =>\n  or.elim h (fun l => or.inl <| mem_image_of_mem _ l) fun r => or.inr r\n#align union_preimage_subset union_preimage_subset\n\n",
 "surjective_onto_range":
 "theorem surjective_onto_range : surjective (rangeFactorization f) := fun âŸ¨_, âŸ¨i, rflâŸ©âŸ© => âŸ¨i, rflâŸ©\n#align surjective_onto_range surjective_onto_range\n\n",
 "surjective_onto_image":
 "theorem surjective_onto_image {f : Î± â†’ Î²} {s : set Î±} : surjective (imageFactorization f s) := fun âŸ¨_, âŸ¨a, ha, rflâŸ©âŸ© =>\n  âŸ¨âŸ¨a, haâŸ©, rflâŸ©\n#align surjective_onto_image surjective_onto_image\n\n",
 "subsingleton_range":
 "theorem subsingleton_range {Î± : Sort _} [subsingleton Î±] (f : Î± â†’ Î²) : (range f).subsingleton :=\n  forall_range_iff.2 fun x => forall_range_iff.2 fun y => congr_arg f (subsingleton.elim x y)\n#align subsingleton_range subsingleton_range\n\n",
 "subsingleton_of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- If the preimage of a set under an surjective map is a subsingleton,\nthe set is a subsingleton. -/\ntheorem subsingleton_of_preimage {Î± Î² : Type _} {f : Î± â†’ Î²} (hf : function.surjective f) (s : set Î²)\n    (hs : (Â«expr â»Â¹' Â» f s).subsingleton) : s.subsingleton := fun fx hx fy hy =>\n  by\n  rcases hf fx, hf fy with âŸ¨âŸ¨x, rflâŸ©, âŸ¨y, rflâŸ©âŸ©\n  exact congr_arg f (hs hx hy)\n#align subsingleton_of_preimage subsingleton_of_preimage\n\n",
 "subsingleton_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- If the image of a set under an injective map is a subsingleton, the set is a subsingleton. -/\ntheorem subsingleton_of_image {Î± Î² : Type _} {f : Î± â†’ Î²} (hf : function.injective f) (s : set Î±)\n    (hs : (Â«expr '' Â» f s).subsingleton) : s.subsingleton :=\n  (hs.preimage hf).anti <| subset_preimage_image _ _\n#align subsingleton_of_image subsingleton_of_image\n\n",
 "subsingleton_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem injective.subsingleton_image_iff (hf : injective f) {s : set Î±} :\n    (Â«expr '' Â» f s).subsingleton â†” s.subsingleton :=\n  âŸ¨subsingleton_of_image hf s, fun h => h.image fâŸ©\n#align injective.subsingleton_image_iff injective.subsingleton_image_iff\n\n",
 "subset_range_iff_exists_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem subset_range_iff_exists_image_eq {f : Î± â†’ Î²} {s : set Î²} : s âŠ† range f â†” âˆƒ t, Â«expr '' Â» f t = s :=\n  âŸ¨fun h => âŸ¨_, image_preimage_eq_iff.2 hâŸ©, fun âŸ¨t, htâŸ© => ht â–¸ image_subset_range _ _âŸ©\n#align subset_range_iff_exists_image_eq subset_range_iff_exists_image_eq\n\n",
 "subset_preimage_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem subset_preimage_univ {s : set Î±} : s âŠ† Â«expr â»Â¹' Â» f univ :=\n  subset_univ _\n#align subset_preimage_univ subset_preimage_univ\n\n",
 "subset_preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem subset_preimage_image (f : Î± â†’ Î²) (s : set Î±) : s âŠ† Â«expr â»Â¹' Â» f (Â«expr '' Â» f s) := fun x =>\n  mem_image_of_mem f\n#align subset_preimage_image subset_preimage_image\n\n",
 "subset_image_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem subset_image_union (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) :\n    Â«expr '' Â» f (s âˆª Â«expr â»Â¹' Â» f t) âŠ† Â«expr '' Â» f s âˆª t :=\n  image_subset_iff.2 (union_preimage_subset _ _ _)\n#align subset_image_union subset_image_union\n\n",
 "subset_image_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ† Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ† Â» -/\ntheorem subset_image_symm_diff : Â«expr âˆ† Â» (Â«expr '' Â» f s) (Â«expr '' Â» f t) âŠ† Â«expr '' Â» f (Â«expr âˆ† Â» s t) :=\n  (union_subset_union (subset_image_diff _ _ _) <| subset_image_diff _ _ _).trans (image_union _ _ _).superset\n#align subset_image_symm_diff subset_image_symm_diff\n\n",
 "subset_image_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem subset_image_diff (f : Î± â†’ Î²) (s t : set Î±) : Â«expr '' Â» f s \\ Â«expr '' Â» f t âŠ† Â«expr '' Â» f (s \\ t) :=\n  by\n  rw [diff_subset_iff, â† image_union, union_diff_self]\n  exact image_subset f (subset_union_right t s)\n#align subset_image_diff subset_image_diff\n\n",
 "subset_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem subset_image_compl {f : Î± â†’ Î²} {s : set Î±} (H : surjective f) :\n    Â«expr á¶œÂ» (Â«expr '' Â» f s) âŠ† Â«expr '' Â» f (Â«expr á¶œÂ» s) :=\n  compl_subset_iff_union.2 <| by\n    rw [â† image_union]\n    simp [image_univ_of_surjective H]\n#align subset_image_compl subset_image_compl\n\n",
 "set_image":
 "#print Function.Commute.set_image /-\ntheorem Function.Commute.set_image {f g : Î± â†’ Î±} (h : function.commute f g) : function.commute (image f) (image g) :=\n  h.set_image\n#align function.commute.set_image Function.Commute.set_image\n-/\n\n",
 "right_inverse_range_splitting":
 "theorem right_inverse_range_splitting {f : Î± â†’ Î²} (h : injective f) :\n    right_inverse (rangeFactorization f) (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).right_inverse_of_injective fun x y hxy => h <| subtype.ext_iff.1 hxy\n#align right_inverse_range_splitting right_inverse_range_splitting\n\n",
 "range_val_subtype":
 "theorem range_val_subtype {p : Î± â†’ Prop} : range (subtype.val : subtype p â†’ Î±) = { x | p x } :=\n  range_coe\n#align range_val_subtype range_val_subtype\n\n",
 "range_val":
 "/-- A variant of `range_coe`. Try to use `range_coe` if possible.\n  This version is useful when defining a new type that is defined as the subtype of something.\n  In that case, the coercion doesn't fire anymore. -/\ntheorem range_val {s : set Î±} : range (subtype.val : s â†’ Î±) = s :=\n  range_coe\n#align range_val range_val\n\n",
 "range_unique":
 "/-- The range of a function from a `unique` type contains just the\nfunction applied to its single value. -/\ntheorem range_unique [h : unique Î¹] : range f = {f default} :=\n  by\n  ext x\n  rw [mem_range]\n  constructor\n  Â· rintro âŸ¨i, hiâŸ©\n    rw [h.uniq i] at hi\n    exact hi â–¸ mem_singleton _\n  Â· exact fun h => âŸ¨default, h.symmâŸ©\n#align range_unique range_unique\n\n",
 "range_subtype_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem range_subtype_map {p : Î± â†’ Prop} {q : Î² â†’ Prop} (f : Î± â†’ Î²) (h : âˆ€ x, p x â†’ q (f x)) :\n    range (subtype.map f h) = Â«expr â»Â¹' Â» coe (Â«expr '' Â» f { x | p x }) :=\n  by\n  ext âŸ¨x, hxâŸ©\n  simp_rw [mem_preimage, mem_range, mem_image, subtype.exists, subtype.map, subtype.coe_mk, mem_set_of, exists_prop]\n#align range_subtype_map range_subtype_map\n\n",
 "range_subset_singleton":
 "theorem range_subset_singleton {f : Î¹ â†’ Î±} {x : Î±} : range f âŠ† {x} â†” f = const Î¹ x := by\n  simp [range_subset_iff, funext_iff, mem_singleton]\n#align range_subset_singleton range_subset_singleton\n\n",
 "range_subset_iff":
 "theorem range_subset_iff : range f âŠ† s â†” âˆ€ y, f y âˆˆ s :=\n  forall_range_iff\n#align range_subset_iff range_subset_iff\n\n",
 "range_splitting_injective":
 "theorem range_splitting_injective (f : Î± â†’ Î²) : injective (rangeSplitting f) :=\n  (leftInverse_rangeSplitting f).injective\n#align range_splitting_injective range_splitting_injective\n\n",
 "range_some_union_none":
 "@[simp]\ntheorem range_some_union_none (Î± : Type _) : range (some : Î± â†’ option Î±) âˆª {none} = univ :=\n  (isCompl_range_some_none Î±).sup_eq_top\n#align range_some_union_none range_some_union_none\n\n",
 "range_some_inter_none":
 "@[simp]\ntheorem range_some_inter_none (Î± : Type _) : range (some : Î± â†’ option Î±) âˆ© {none} = âˆ… :=\n  (isCompl_range_some_none Î±).inf_eq_bot\n#align range_some_inter_none range_some_inter_none\n\n",
 "range_snd":
 "#print Prod.range_snd /-\n@[simp]\ntheorem Prod.range_snd [nonempty Î±] : range (prod.snd : Î± Ã— Î² â†’ Î²) = univ :=\n  prod.snd_surjective.range_eq\n#align prod.range_snd Prod.range_snd\n-/\n\n",
 "range_quotient_mk'":
 "@[simp]\ntheorem range_quotient_mk' {s : setoid Î±} : range (quotient.mk' : Î± â†’ quotient s) = univ :=\n  range_quot_mk _\n#align range_quotient_mk' range_quotient_mk'\n\n",
 "range_quotient_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n@[simp]\ntheorem range_quotient_mk [setoid Î±] : (range fun x : Î± => Â«exprâŸ¦ âŸ§Â» x) = univ :=\n  range_quot_mk _\n#align range_quotient_mk range_quotient_mk\n\n",
 "range_quotient_lift_on'":
 "@[simp]\ntheorem range_quotient_lift_on' {s : setoid Î¹} (hf) :\n    (range fun x : quotient s => quotient.lift_on' x f hf) = range f :=\n  range_quot_lift _\n#align range_quotient_lift_on' range_quotient_lift_on'\n\n",
 "range_quotient_lift":
 "@[simp]\ntheorem range_quotient_lift [s : setoid Î¹] (hf) : range (quotient.lift f hf : quotient s â†’ Î±) = range f :=\n  range_quot_lift _\n#align range_quotient_lift range_quotient_lift\n\n",
 "range_quot_mk":
 "@[simp]\ntheorem range_quot_mk (r : Î± â†’ Î± â†’ Prop) : range (Quot.mk r) = univ :=\n  (surjective_quot_mk r).range_eq\n#align range_quot_mk range_quot_mk\n\n",
 "range_quot_lift":
 "@[simp]\ntheorem range_quot_lift {r : Î¹ â†’ Î¹ â†’ Prop} (hf : âˆ€ x y, r x y â†’ f x = f y) : range (Quot.lift f hf) = range f :=\n  ext fun y => (surjective_quot_mk _).exists\n#align range_quot_lift range_quot_lift\n\n",
 "range_nonempty_iff_nonempty":
 "theorem range_nonempty_iff_nonempty : (range f).nonempty â†” nonempty Î¹ :=\n  âŸ¨fun âŸ¨y, x, hxyâŸ© => âŸ¨xâŸ©, fun âŸ¨xâŸ© => âŸ¨f x, mem_range_self xâŸ©âŸ©\n#align range_nonempty_iff_nonempty range_nonempty_iff_nonempty\n\n",
 "range_nonempty":
 "theorem range_nonempty [h : nonempty Î¹] (f : Î¹ â†’ Î±) : (range f).nonempty :=\n  range_nonempty_iff_nonempty.2 h\n#align range_nonempty range_nonempty\n\n",
 "range_ite_subset'":
 "theorem range_ite_subset' {p : Prop} [decidable p] {f g : Î± â†’ Î²} : range (if p then f else g) âŠ† range f âˆª range g :=\n  by\n  by_cases h : p;\n  Â· rw [if_pos h]\n    exact subset_union_left _ _\n  Â· rw [if_neg h]\n    exact subset_union_right _ _\n#align range_ite_subset' range_ite_subset'\n\n",
 "range_ite_subset":
 "theorem range_ite_subset {p : Î± â†’ Prop} [decidable_pred p] {f g : Î± â†’ Î²} :\n    (range fun x => if p x then f x else g x) âŠ† range f âˆª range g :=\n  by\n  rw [range_subset_iff]; intro x; by_cases h : p x\n  simp [if_pos h, mem_union, mem_range_self]\n  simp [if_neg h, mem_union, mem_range_self]\n#align range_ite_subset range_ite_subset\n\n",
 "range_inr_union_range_inl":
 "@[simp]\ntheorem range_inr_union_range_inl : range (sum.inr : Î² â†’ Sum Î± Î²) âˆª range sum.inl = univ :=\n  isCompl_range_inl_range_inr.symm.sup_eq_top\n#align range_inr_union_range_inl range_inr_union_range_inl\n\n",
 "range_inr_inter_range_inl":
 "@[simp]\ntheorem range_inr_inter_range_inl : range (sum.inr : Î² â†’ Sum Î± Î²) âˆ© range sum.inl = âˆ… :=\n  isCompl_range_inl_range_inr.symm.inf_eq_bot\n#align range_inr_inter_range_inl range_inr_inter_range_inl\n\n",
 "range_inl_union_range_inr":
 "@[simp]\ntheorem range_inl_union_range_inr : range (sum.inl : Î± â†’ Sum Î± Î²) âˆª range sum.inr = univ :=\n  isCompl_range_inl_range_inr.sup_eq_top\n#align range_inl_union_range_inr range_inl_union_range_inr\n\n",
 "range_inl_inter_range_inr":
 "@[simp]\ntheorem range_inl_inter_range_inr : range (sum.inl : Î± â†’ Sum Î± Î²) âˆ© range sum.inr = âˆ… :=\n  isCompl_range_inl_range_inr.inf_eq_bot\n#align range_inl_inter_range_inr range_inl_inter_range_inr\n\n",
 "range_inclusion":
 "@[simp]\ntheorem range_inclusion (h : s âŠ† t) : range (inclusion h) = { x : t | (x : Î±) âˆˆ s } :=\n  by\n  ext âŸ¨x, hxâŸ©\n  simp [inclusion]\n#align range_inclusion range_inclusion\n\n",
 "range_image":
 "theorem range_image (f : Î± â†’ Î²) : range (image f) = ğ’« range f :=\n  ext fun s => subset_range_iff_exists_image_eq.symm\n#align range_image range_image\n\n",
 "range_iff_surjective":
 "theorem range_iff_surjective : range f = univ â†” surjective f :=\n  eq_univ_iff_forall\n#align range_iff_surjective range_iff_surjective\n\n",
 "range_id'":
 "@[simp]\ntheorem range_id' : (range fun x : Î± => x) = univ :=\n  range_id\n#align range_id' range_id'\n\n",
 "range_id":
 "@[simp]\ntheorem range_id : range (@id Î±) = univ :=\n  range_iff_surjective.2 surjective_id\n#align range_id range_id\n\n",
 "range_fst":
 "#print Prod.range_fst /-\n@[simp]\ntheorem Prod.range_fst [nonempty Î²] : range (prod.fst : Î± Ã— Î² â†’ Î±) = univ :=\n  prod.fst_surjective.range_eq\n#align prod.range_fst Prod.range_fst\n-/\n\n",
 "range_factorization_eq":
 "theorem range_factorization_eq {f : Î¹ â†’ Î²} : subtype.val âˆ˜ rangeFactorization f = f :=\n  funext fun i => rfl\n#align range_factorization_eq range_factorization_eq\n\n",
 "range_factorization_coe":
 "@[simp]\ntheorem range_factorization_coe (f : Î¹ â†’ Î²) (a : Î¹) : (rangeFactorization f a : Î²) = f a :=\n  rfl\n#align range_factorization_coe range_factorization_coe\n\n",
 "range_eval":
 "@[simp]\ntheorem range_eval {Î¹ : Type _} {Î± : Î¹ â†’ Sort _} [âˆ€ i, nonempty (Î± i)] (i : Î¹) :\n    range (eval i : (âˆ€ i, Î± i) â†’ Î± i) = univ :=\n  (surjective_eval i).range_eq\n#align range_eval range_eval\n\n",
 "range_eq_iff":
 "theorem range_eq_iff (f : Î± â†’ Î²) (s : set Î²) : range f = s â†” (âˆ€ a, f a âˆˆ s) âˆ§ âˆ€ b âˆˆ s, âˆƒ a, f a = b :=\n  by\n  rw [â† range_subset_iff]\n  exact le_antisymm_iff\n#align range_eq_iff range_eq_iff\n\n",
 "range_eq_empty_iff":
 "@[simp]\ntheorem range_eq_empty_iff {f : Î¹ â†’ Î±} : range f = âˆ… â†” is_empty Î¹ := by\n  rw [â† not_nonempty_iff, â† range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]\n#align range_eq_empty_iff range_eq_empty_iff\n\n",
 "range_eq_empty":
 "theorem range_eq_empty [is_empty Î¹] (f : Î¹ â†’ Î±) : range f = âˆ… :=\n  range_eq_empty_iff.2 â€¹_â€º\n#align range_eq_empty range_eq_empty\n\n",
 "range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n#print WithTop.range_eq /-\ntheorem WithTop.range_eq {Î± Î²} (f : WithTop Î± â†’ Î²) : range f = insert (f (Â«exprâŠ¤Â»)) (range (f âˆ˜ coe : Î± â†’ Î²)) :=\n  Option.range_eq f\n#align with_top.range_eq WithTop.range_eq\n-/\n\n",
 "range_diff_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem range_diff_image_subset (f : Î± â†’ Î²) (s : set Î±) : range f \\ Â«expr '' Â» f s âŠ† Â«expr '' Â» f (Â«expr á¶œÂ» s) :=\n  fun y âŸ¨âŸ¨x, hâ‚âŸ©, hâ‚‚âŸ© => âŸ¨x, fun h => hâ‚‚ âŸ¨x, h, hâ‚âŸ©, hâ‚âŸ©\n#align range_diff_image_subset range_diff_image_subset\n\n",
 "range_diff_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem range_diff_image {f : Î± â†’ Î²} (H : injective f) (s : set Î±) :\n    range f \\ Â«expr '' Â» f s = Â«expr '' Â» f (Â«expr á¶œÂ» s) :=\n  Subset.antisymm (range_diff_image_subset f s) fun y âŸ¨x, hx, hyâŸ© =>\n    hy â–¸ âŸ¨mem_range_self _, fun âŸ¨x', hx', eqâŸ© => hx <| H eq â–¸ hx'âŸ©\n#align range_diff_image range_diff_image\n\n",
 "range_const_subset":
 "theorem range_const_subset {c : Î±} : (range fun x : Î¹ => c) âŠ† {c} :=\n  range_subset_iff.2 fun x => rfl\n#align range_const_subset range_const_subset\n\n",
 "range_const":
 "@[simp]\ntheorem range_const : âˆ€ [nonempty Î¹] {c : Î±}, (range fun x : Î¹ => c) = {c}\n  | âŸ¨xâŸ©, c => Subset.antisymm range_const_subset fun y hy => (mem_singleton_iff.1 hy).symm â–¸ mem_range_self x\n#align range_const range_const\n\n",
 "range_comp_subset_range":
 "theorem range_comp_subset_range (f : Î± â†’ Î²) (g : Î² â†’ Î³) : range (g âˆ˜ f) âŠ† range g := by\n  rw [range_comp] <;> apply image_subset_range\n#align range_comp_subset_range range_comp_subset_range\n\n",
 "range_comp":
 "theorem surjective.range_comp {Î¹' : Sort _} {f : Î¹ â†’ Î¹'} (hf : surjective f) (g : Î¹' â†’ Î±) : range (g âˆ˜ f) = range g :=\n  ext fun y => (@surjective.exists _ _ _ hf fun x => g x = y).symm\n#align surjective.range_comp surjective.range_comp\n\n",
 "range_coe_subtype":
 "/-- We make this the simp lemma instead of `range_coe`. The reason is that if we write\n  for `s : set Î±` the function `coe : s â†’ Î±`, then the inferred implicit arguments of `coe` are\n  `coe Î± (Î» x, x âˆˆ s)`. -/\n@[simp]\ntheorem range_coe_subtype {p : Î± â†’ Prop} : range (coe : subtype p â†’ Î±) = { x | p x } :=\n  range_coe\n#align range_coe_subtype range_coe_subtype\n\n",
 "range_coe":
 "theorem range_coe {s : set Î±} : range (coe : s â†’ Î±) = s :=\n  by\n  rw [â† Set.image_univ]\n  simp [-Set.image_univ, coe_image]\n#align range_coe range_coe\n\n",
 "prod_quotient_preimage_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŸ¦ âŸ§Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem prod_quotient_preimage_eq_image [s : setoid Î±] (g : quotient s â†’ Î²) {h : Î± â†’ Î²} (Hh : h = g âˆ˜ Quotient.mk'')\n    (r : set (Î² Ã— Î²)) :\n    { x : quotient s Ã— quotient s | (g x.1, g x.2) âˆˆ r } =\n      Â«expr '' Â» (fun a : Î± Ã— Î± => (Â«exprâŸ¦ âŸ§Â» a.1, Â«exprâŸ¦ âŸ§Â» a.2)) (Â«expr â»Â¹' Â» (fun a : Î± Ã— Î± => (h a.1, h a.2)) r) :=\n  Hh.symm â–¸\n    Set.ext fun âŸ¨aâ‚, aâ‚‚âŸ© =>\n      âŸ¨quotient.induction_onâ‚‚ aâ‚ aâ‚‚ fun aâ‚ aâ‚‚ h => âŸ¨(aâ‚, aâ‚‚), h, rflâŸ©, fun âŸ¨âŸ¨bâ‚, bâ‚‚âŸ©, hâ‚, hâ‚‚âŸ© =>\n        show (g aâ‚, g aâ‚‚) âˆˆ r from\n          have hâ‚ƒ : Â«exprâŸ¦ âŸ§Â» bâ‚ = aâ‚ âˆ§ Â«exprâŸ¦ âŸ§Â» bâ‚‚ = aâ‚‚ := prod.ext_iff.1 hâ‚‚\n          hâ‚ƒ.1 â–¸ hâ‚ƒ.2 â–¸ hâ‚âŸ©\n#align prod_quotient_preimage_eq_image prod_quotient_preimage_eq_image\n\n",
 "preimage_val_eq_preimage_val_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_val_eq_preimage_val_iff (s t u : set Î±) :\n    Â«expr â»Â¹' Â» (subtype.val : s â†’ Î±) t = Â«expr â»Â¹' Â» subtype.val u â†” t âˆ© s = u âˆ© s :=\n  preimage_coe_eq_preimage_coe_iff\n#align preimage_val_eq_preimage_val_iff preimage_val_eq_preimage_val_iff\n\n",
 "preimage_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_univ : Â«expr â»Â¹' Â» f univ = univ :=\n  rfl\n#align preimage_univ preimage_univ\n\n",
 "preimage_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_union {s t : set Î²} : Â«expr â»Â¹' Â» f (s âˆª t) = Â«expr â»Â¹' Â» f s âˆª Â«expr â»Â¹' Â» f t :=\n  rfl\n#align preimage_union preimage_union\n\n",
 "preimage_surjective":
 "@[simp]\ntheorem preimage_surjective : surjective (preimage f) â†” injective f :=\n  by\n  refine' âŸ¨fun h x x' hx => _, injective.preimage_surjectiveâŸ©\n  cases' h {x} with s hs; have := mem_singleton x\n  rwa [â† hs, mem_preimage, hx, â† mem_preimage, hs, mem_singleton_iff, eq_comm] at this\n#align preimage_surjective preimage_surjective\n\n",
 "preimage_subtype_coe_eq_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_subtype_coe_eq_compl {Î± : Type _} {s u v : set Î±} (hsuv : s âŠ† u âˆª v) (H : s âˆ© (u âˆ© v) = âˆ…) :\n    Â«expr â»Â¹' Â» (coe : s â†’ Î±) u = Â«expr á¶œÂ» (Â«expr â»Â¹' Â» coe v) :=\n  by\n  ext âŸ¨x, x_in_sâŸ©\n  constructor\n  Â· intro x_in_u x_in_v\n    exact eq_empty_iff_forall_not_mem.mp H x âŸ¨x_in_s, âŸ¨x_in_u, x_in_vâŸ©âŸ©\n  Â· intro hx\n    exact or.elim (hsuv x_in_s) id fun hx' => hx.elim hx'\n#align preimage_subtype_coe_eq_compl preimage_subtype_coe_eq_compl\n\n",
 "preimage_subset_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem surjective.preimage_subset_preimage_iff {s t : set Î²} (hf : surjective f) :\n    Â«expr â»Â¹' Â» f s âŠ† Â«expr â»Â¹' Â» f t â†” s âŠ† t :=\n  by\n  apply preimage_subset_preimage_iff\n  rw [hf.range_eq]\n  apply subset_univ\n#align surjective.preimage_subset_preimage_iff surjective.preimage_subset_preimage_iff\n\n",
 "preimage_subset_image_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem preimage_subset_image_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} (I : left_inverse g f) (s : set Î²) :\n    Â«expr â»Â¹' Â» f s âŠ† Â«expr '' Â» g s := fun b h => âŸ¨f b, h, I bâŸ©\n#align preimage_subset_image_of_inverse preimage_subset_image_of_inverse\n\n",
 "preimage_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_subset_iff {A : set Î±} {B : set Î²} {f : Î± â†’ Î²} : Â«expr â»Â¹' Â» f B âŠ† A â†” âˆ€ a : Î±, f a âˆˆ B â†’ a âˆˆ A :=\n  iff.rfl\n#align preimage_subset_iff preimage_subset_iff\n\n",
 "preimage_singleton_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_singleton_nonempty {f : Î± â†’ Î²} {y : Î²} : (Â«expr â»Â¹' Â» f {y}).nonempty â†” y âˆˆ range f :=\n  iff.rfl\n#align preimage_singleton_nonempty preimage_singleton_nonempty\n\n",
 "preimage_singleton_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_singleton_eq_empty {f : Î± â†’ Î²} {y : Î²} : Â«expr â»Â¹' Â» f {y} = âˆ… â†” y âˆ‰ range f :=\n  not_nonempty_iff_eq_empty.symm.trans preimage_singleton_nonempty.not\n#align preimage_singleton_eq_empty preimage_singleton_eq_empty\n\n",
 "preimage_set_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_set_of_eq {p : Î± â†’ Prop} {f : Î² â†’ Î±} : Â«expr â»Â¹' Â» f { a | p a } = { a | p (f a) } :=\n  rfl\n#align preimage_set_of_eq preimage_set_of_eq\n\n",
 "preimage_range_splitting":
 "theorem preimage_range_splitting {f : Î± â†’ Î²} (hf : injective f) :\n    preimage (rangeSplitting f) = image (rangeFactorization f) :=\n  (image_eq_preimage_of_inverse (rightInverse_rangeSplitting hf) (leftInverse_rangeSplitting f)).symm\n#align preimage_range_splitting preimage_range_splitting\n\n",
 "preimage_range_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_range_inter {f : Î± â†’ Î²} {s : set Î²} : Â«expr â»Â¹' Â» f (range f âˆ© s) = Â«expr â»Â¹' Â» f s := by\n  rw [inter_comm, preimage_inter_range]\n#align preimage_range_inter preimage_range_inter\n\n",
 "preimage_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_range (f : Î± â†’ Î²) : Â«expr â»Â¹' Â» f (range f) = univ :=\n  eq_univ_of_forall mem_range_self\n#align preimage_range preimage_range\n\n",
 "preimage_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem left_inverse.preimage_preimage {g : Î² â†’ Î±} (h : left_inverse g f) (s : set Î±) :\n    Â«expr â»Â¹' Â» f (Â«expr â»Â¹' Â» g s) = s := by rw [â† preimage_comp, h.comp_eq_id, preimage_id]\n#align left_inverse.preimage_preimage left_inverse.preimage_preimage\n\n",
 "preimage_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_mono {s t : set Î²} (h : s âŠ† t) : Â«expr â»Â¹' Â» f s âŠ† Â«expr â»Â¹' Â» f t := fun x hx => h hx\n#align preimage_mono preimage_mono\n\n",
 "preimage_iterate_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\n@[simp]\ntheorem preimage_iterate_eq {f : Î± â†’ Î±} {n : â„•} : Set.preimage (Â«expr ^[ ]Â» f n) = Â«expr ^[ ]Â» (Set.preimage f) n :=\n  by\n  induction' n with n ih; Â· simp\n  rw [iterate_succ, iterate_succ', Set.preimage_comp_eq, ih]\n#align preimage_iterate_eq preimage_iterate_eq\n\n",
 "preimage_ite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_ite (f : Î± â†’ Î²) (s tâ‚ tâ‚‚ : set Î²) :\n    Â«expr â»Â¹' Â» f (s.ite tâ‚ tâ‚‚) = (Â«expr â»Â¹' Â» f s).ite (Â«expr â»Â¹' Â» f tâ‚) (Â«expr â»Â¹' Â» f tâ‚‚) :=\n  rfl\n#align preimage_ite preimage_ite\n\n",
 "preimage_inter_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_inter_range {f : Î± â†’ Î²} {s : set Î²} : Â«expr â»Â¹' Â» f (s âˆ© range f) = Â«expr â»Â¹' Â» f s :=\n  Set.ext fun x => and_iff_left âŸ¨x, rflâŸ©\n#align preimage_inter_range preimage_inter_range\n\n",
 "preimage_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_inter {s t : set Î²} : Â«expr â»Â¹' Â» f (s âˆ© t) = Â«expr â»Â¹' Â» f s âˆ© Â«expr â»Â¹' Â» f t :=\n  rfl\n#align preimage_inter preimage_inter\n\n",
 "preimage_inr_range_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_inr_range_inl : Â«expr â»Â¹' Â» sum.inr (range (sum.inl : Î± â†’ Sum Î± Î²)) = âˆ… := by\n  rw [â† image_univ, preimage_inr_image_inl]\n#align preimage_inr_range_inl preimage_inr_range_inl\n\n",
 "preimage_inr_image_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem preimage_inr_image_inl (s : set Î±) : Â«expr â»Â¹' Â» sum.inr (Â«expr '' Â» (@sum.inl Î± Î²) s) = âˆ… :=\n  by\n  ext\n  simp\n#align preimage_inr_image_inl preimage_inr_image_inl\n\n",
 "preimage_inl_range_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_inl_range_inr : Â«expr â»Â¹' Â» sum.inl (range (sum.inr : Î² â†’ Sum Î± Î²)) = âˆ… := by\n  rw [â† image_univ, preimage_inl_image_inr]\n#align preimage_inl_range_inr preimage_inl_range_inr\n\n",
 "preimage_inl_image_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem preimage_inl_image_inr (s : set Î²) : Â«expr â»Â¹' Â» sum.inl (Â«expr '' Â» (@sum.inr Î± Î²) s) = âˆ… :=\n  by\n  ext\n  simp\n#align preimage_inl_image_inr preimage_inl_image_inr\n\n",
 "preimage_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_injective : injective (preimage f) â†” surjective f :=\n  by\n  refine' âŸ¨fun h y => _, surjective.preimage_injectiveâŸ©\n  obtain âŸ¨x, hxâŸ© : (Â«expr â»Â¹' Â» f {y}).nonempty :=\n    by\n    rw [h.nonempty_apply_iff preimage_empty]\n    apply singleton_nonempty\n  exact âŸ¨x, hxâŸ©\n#align preimage_injective preimage_injective\n\n",
 "preimage_image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_image_preimage {f : Î± â†’ Î²} {s : set Î²} :\n    Â«expr â»Â¹' Â» f (Â«expr '' Â» f (Â«expr â»Â¹' Â» f s)) = Â«expr â»Â¹' Â» f s := by\n  rw [image_preimage_eq_inter_range, preimage_inter_range]\n#align preimage_image_preimage preimage_image_preimage\n\n",
 "preimage_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem preimage_image_eq {f : Î± â†’ Î²} (s : set Î±) (h : injective f) : Â«expr â»Â¹' Â» f (Â«expr '' Â» f s) = s :=\n  Subset.antisymm (fun x âŸ¨y, hy, eâŸ© => h e â–¸ hy) (subset_preimage_image f s)\n#align preimage_image_eq preimage_image_eq\n\n",
 "preimage_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem injective.preimage_image (hf : injective f) (s : set Î±) : Â«expr â»Â¹' Â» f (Â«expr '' Â» f s) = s :=\n  preimage_image_eq s hf\n#align injective.preimage_image injective.preimage_image\n\n",
 "preimage_id_eq":
 "@[simp]\ntheorem preimage_id_eq : preimage (id : Î± â†’ Î±) = id :=\n  rfl\n#align preimage_id_eq preimage_id_eq\n\n",
 "preimage_id'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_id' {s : set Î±} : Â«expr â»Â¹' Â» (fun x => x) s = s :=\n  rfl\n#align preimage_id' preimage_id'\n\n",
 "preimage_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_id {s : set Î±} : Â«expr â»Â¹' Â» id s = s :=\n  rfl\n#align preimage_id preimage_id\n\n",
 "preimage_eq_preimage'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_eq_preimage' {s t : set Î±} {f : Î² â†’ Î±} (hs : s âŠ† range f) (ht : t âŠ† range f) :\n    Â«expr â»Â¹' Â» f s = Â«expr â»Â¹' Â» f t â†” s = t := by\n  constructor\n  Â· intro h\n    apply subset.antisymm\n    rw [â† preimage_subset_preimage_iff hs, h]\n    rw [â† preimage_subset_preimage_iff ht, h]\n  rintro rfl; rfl\n#align preimage_eq_preimage' preimage_eq_preimage'\n\n",
 "preimage_eq_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_eq_preimage {f : Î² â†’ Î±} (hf : surjective f) : Â«expr â»Â¹' Â» f s = Â«expr â»Â¹' Â» f t â†” s = t :=\n  iff.intro (fun eq => by rw [â† image_preimage_eq s hf, â† image_preimage_eq t hf, eq]) fun eq => eq â–¸ rfl\n#align preimage_eq_preimage preimage_eq_preimage\n\n",
 "preimage_eq_iff_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem preimage_eq_iff_eq_image {f : Î± â†’ Î²} (hf : bijective f) {s t} : Â«expr â»Â¹' Â» f s = t â†” s = Â«expr '' Â» f t := by\n  rw [â† image_eq_image hf.1, hf.2.image_preimage]\n#align preimage_eq_iff_eq_image preimage_eq_iff_eq_image\n\n",
 "preimage_eq_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_eq_empty_iff {s : set Î²} : Â«expr â»Â¹' Â» f s = âˆ… â†” Disjoint s (range f) :=\n  âŸ¨fun h =>\n    by\n    simp only [eq_empty_iff_forall_not_mem, disjoint_iff_inter_eq_empty, not_exists, mem_inter_iff, not_and, mem_range,\n      mem_preimage] at hâŠ¢\n    intro y hy x hx\n    rw [â† hx] at hy\n    exact h x hy, preimage_eq_emptyâŸ©\n#align preimage_eq_empty_iff preimage_eq_empty_iff\n\n",
 "preimage_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_eq_empty {f : Î± â†’ Î²} {s : set Î²} (h : Disjoint s (range f)) : Â«expr â»Â¹' Â» f s = âˆ… := by\n  simpa using h.preimage f\n#align preimage_eq_empty preimage_eq_empty\n\n",
 "preimage_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\n@[simp]\ntheorem preimage_empty : Â«expr â»Â¹' Â» f âˆ… = âˆ… :=\n  rfl\n#align preimage_empty preimage_empty\n\n",
 "preimage_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_diff (f : Î± â†’ Î²) (s t : set Î²) : Â«expr â»Â¹' Â» f (s \\ t) = Â«expr â»Â¹' Â» f s \\ Â«expr â»Â¹' Â» f t :=\n  rfl\n#align preimage_diff preimage_diff\n\n",
 "preimage_const_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_const_of_not_mem {b : Î²} {s : set Î²} (h : b âˆ‰ s) : Â«expr â»Â¹' Â» (fun x : Î± => b) s = âˆ… :=\n  eq_empty_of_subset_empty fun x hx => h hx\n#align preimage_const_of_not_mem preimage_const_of_not_mem\n\n",
 "preimage_const_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_const_of_mem {b : Î²} {s : set Î²} (h : b âˆˆ s) : Â«expr â»Â¹' Â» (fun x : Î± => b) s = univ :=\n  eq_univ_of_forall fun x => h\n#align preimage_const_of_mem preimage_const_of_mem\n\n",
 "preimage_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_const (b : Î²) (s : set Î²) [decidable (b âˆˆ s)] :\n    Â«expr â»Â¹' Â» (fun x : Î± => b) s = if b âˆˆ s then univ else âˆ… :=\n  by\n  split_ifs with hb hb\n  exacts[preimage_const_of_mem hb, preimage_const_of_not_mem hb]\n#align preimage_const preimage_const\n\n",
 "preimage_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_congr {f g : Î± â†’ Î²} {s : set Î²} (h : âˆ€ x : Î±, f x = g x) : Â«expr â»Â¹' Â» f s = Â«expr â»Â¹' Â» g s :=\n  by\n  congr with x\n  apply_assumption\n#align preimage_congr preimage_congr\n\n",
 "preimage_compl_eq_image_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem preimage_compl_eq_image_compl [BooleanAlgebra Î±] (S : set Î±) : Â«expr â»Â¹' Â» compl S = Â«expr '' Â» compl S :=\n  Set.ext fun x =>\n    âŸ¨fun h => âŸ¨Â«expr á¶œÂ» x, h, compl_compl xâŸ©, fun h =>\n      exists.elim h fun y hy => (compl_eq_comm.mp hy.2).symm.subst hy.1âŸ©\n#align preimage_compl_eq_image_compl preimage_compl_eq_image_compl\n\n",
 "preimage_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_compl {s : set Î²} : Â«expr â»Â¹' Â» f (Â«expr á¶œÂ» s) = Â«expr á¶œÂ» (Â«expr â»Â¹' Â» f s) :=\n  rfl\n#align preimage_compl preimage_compl\n\n",
 "preimage_comp_eq":
 "theorem preimage_comp_eq : preimage (g âˆ˜ f) = preimage f âˆ˜ preimage g :=\n  rfl\n#align preimage_comp_eq preimage_comp_eq\n\n",
 "preimage_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_comp {s : set Î³} : Â«expr â»Â¹' Â» (g âˆ˜ f) s = Â«expr â»Â¹' Â» f (Â«expr â»Â¹' Â» g s) :=\n  rfl\n#align preimage_comp preimage_comp\n\n",
 "preimage_coe_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_coe_nonempty {s t : set Î±} : (Â«expr â»Â¹' Â» (coe : s â†’ Î±) t).nonempty â†” (s âˆ© t).nonempty := by\n  rw [inter_comm, â† image_preimage_coe, nonempty_image_iff]\n#align preimage_coe_nonempty preimage_coe_nonempty\n\n",
 "preimage_coe_inter_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem preimage_coe_inter_self (s t : set Î±) : Â«expr â»Â¹' Â» (coe : s â†’ Î±) (t âˆ© s) = Â«expr â»Â¹' Â» coe t := by\n  rw [preimage_coe_eq_preimage_coe_iff, inter_assoc, inter_self]\n#align preimage_coe_inter_self preimage_coe_inter_self\n\n",
 "preimage_coe_eq_preimage_coe_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_coe_eq_preimage_coe_iff {s t u : set Î±} :\n    Â«expr â»Â¹' Â» (coe : s â†’ Î±) t = Â«expr â»Â¹' Â» coe u â†” t âˆ© s = u âˆ© s := by\n  rw [â† image_preimage_coe, â† image_preimage_coe, coe_injective.image_injective.eq_iff]\n#align preimage_coe_eq_preimage_coe_iff preimage_coe_eq_preimage_coe_iff\n\n",
 "preimage_coe_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem preimage_coe_eq_empty {s t : set Î±} : Â«expr â»Â¹' Â» (coe : s â†’ Î±) t = âˆ… â†” s âˆ© t = âˆ… := by\n  simp only [â† not_nonempty_iff_eq_empty, preimage_coe_nonempty]\n#align preimage_coe_eq_empty preimage_coe_eq_empty\n\n",
 "preimage_coe_compl'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem preimage_coe_compl' (s : set Î±) : Â«expr â»Â¹' Â» (coe : Â«expr á¶œÂ» s â†’ Î±) s = âˆ… :=\n  preimage_coe_eq_empty.2 (compl_inter_self s)\n#align preimage_coe_compl' preimage_coe_compl'\n\n",
 "preimage_coe_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem preimage_coe_compl (s : set Î±) : Â«expr â»Â¹' Â» (coe : s â†’ Î±) (Â«expr á¶œÂ» s) = âˆ… :=\n  preimage_coe_eq_empty.2 (inter_compl_self s)\n#align preimage_coe_compl preimage_coe_compl\n\n",
 "preimage'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem nonempty.preimage' {s : set Î²} (hs : s.nonempty) {f : Î± â†’ Î²} (hf : s âŠ† Set.range f) :\n    (Â«expr â»Â¹' Â» f s).nonempty :=\n  let âŸ¨y, hyâŸ© := hs\n  let âŸ¨x, hxâŸ© := hf hy\n  âŸ¨x, Set.mem_preimage.2 <| hx.symm â–¸ hyâŸ©\n#align nonempty.preimage' nonempty.preimage'\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print Disjoint.preimage /-\ntheorem Disjoint.preimage (f : Î± â†’ Î²) {s t : set Î²} (h : Disjoint s t) : Disjoint (Â«expr â»Â¹' Â» f s) (Â«expr â»Â¹' Â» f t) :=\n  disjoint_iff_inf_le.mpr fun x hx => h.le_bot hx\n#align disjoint.preimage Disjoint.preimage\n-/\n\n",
 "of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n#print Disjoint.of_preimage /-\ntheorem Disjoint.of_preimage (hf : surjective f) {s t : set Î²} (h : Disjoint (Â«expr â»Â¹' Â» f s) (Â«expr â»Â¹' Â» f t)) :\n    Disjoint s t := by\n  rw [disjoint_iff_inter_eq_empty, â† image_preimage_eq (_ âˆ© _) hf, preimage_inter, h.inter_eq, image_empty]\n#align disjoint.of_preimage Disjoint.of_preimage\n-/\n\n",
 "of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print Disjoint.of_image /-\ntheorem Disjoint.of_image (h : Disjoint (Â«expr '' Â» f s) (Â«expr '' Â» f t)) : Disjoint s t :=\n  disjoint_iff_inf_le.mpr fun x hx => disjoint_left.1 h (mem_image_of_mem _ hx.1) (mem_image_of_mem _ hx.2)\n#align disjoint.of_image Disjoint.of_image\n-/\n\n",
 "nontrivial_of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- If the preimage of a set under an injective map is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_preimage {f : Î± â†’ Î²} (hf : function.injective f) (s : set Î²) (hs : (Â«expr â»Â¹' Â» f s).nontrivial) :\n    s.nontrivial :=\n  (hs.image hf).mono <| image_preimage_subset _ _\n#align nontrivial_of_preimage nontrivial_of_preimage\n\n",
 "nontrivial_of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem nontrivial_of_image (f : Î± â†’ Î²) (s : set Î±) (hs : (Â«expr '' Â» f s).nontrivial) : s.nontrivial :=\n  let âŸ¨_, âŸ¨x, hx, rflâŸ©, _, âŸ¨y, hy, rflâŸ©, hxyâŸ© := hs\n  âŸ¨x, hx, y, hy, mt (congr_arg f) hxyâŸ©\n#align nontrivial_of_image nontrivial_of_image\n\n",
 "nonempty_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem surjective.nonempty_preimage (hf : surjective f) {s : set Î²} : (Â«expr â»Â¹' Â» f s).nonempty â†” s.nonempty := by\n  rw [â† nonempty_image_iff, hf.image_preimage]\n#align surjective.nonempty_preimage surjective.nonempty_preimage\n\n",
 "nonempty_of_nonempty_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem nonempty_of_nonempty_preimage {s : set Î²} {f : Î± â†’ Î²} (hf : (Â«expr â»Â¹' Â» f s).nonempty) : s.nonempty :=\n  let âŸ¨x, hxâŸ© := hf\n  âŸ¨f x, hxâŸ©\n#align nonempty_of_nonempty_preimage nonempty_of_nonempty_preimage\n\n",
 "nonempty_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem nonempty_image_iff {f : Î± â†’ Î²} {s : set Î±} : (Â«expr '' Â» f s).nonempty â†” s.nonempty :=\n  âŸ¨Nonempty.of_image, fun h => h.image fâŸ©\n#align nonempty_image_iff nonempty_image_iff\n\n",
 "monotone_image":
 "/-- `set.image` is monotone. See `set.image_subset` for the statement in terms of `âŠ†`. -/\ntheorem monotone_image {f : Î± â†’ Î²} : monotone (image f) := fun s t => image_subset _\n#align monotone_image monotone_image\n\n",
 "mem_set_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n#print Function.Injective.mem_set_image /-\ntheorem Function.Injective.mem_set_image {f : Î± â†’ Î²} (hf : injective f) {s : set Î±} {a : Î±} :\n    f a âˆˆ Â«expr '' Â» f s â†” a âˆˆ s :=\n  âŸ¨fun âŸ¨b, hb, eqâŸ© => hf eq â–¸ hb, mem_image_of_mem fâŸ©\n#align function.injective.mem_set_image Function.Injective.mem_set_image\n-/\n\n",
 "mem_range_succ":
 "#print Nat.mem_range_succ /-\ntheorem Nat.mem_range_succ (i : â„•) : i âˆˆ range nat.succ â†” 0 < i :=\n  âŸ¨by\n    rintro âŸ¨n, rflâŸ©\n    exact nat.succ_pos n, fun h => âŸ¨_, nat.succ_pred_eq_of_pos hâŸ©âŸ©\n#align nat.mem_range_succ Nat.mem_range_succ\n-/\n\n",
 "mem_range_self":
 "@[simp]\ntheorem mem_range_self (i : Î¹) : f i âˆˆ range f :=\n  âŸ¨i, rflâŸ©\n#align mem_range_self mem_range_self\n\n",
 "mem_range_of_mem_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_range_of_mem_image (f : Î± â†’ Î²) (s) {x : Î²} (h : x âˆˆ Â«expr '' Â» f s) : x âˆˆ range f :=\n  image_subset_range f s h\n#align mem_range_of_mem_image mem_range_of_mem_image\n\n",
 "mem_range_iff_exists_unique":
 "theorem injective.mem_range_iff_exists_unique (hf : injective f) {b : Î²} : b âˆˆ range f â†” âˆƒ! a, f a = b :=\n  âŸ¨fun âŸ¨a, hâŸ© => âŸ¨a, h, fun a' ha => hf (ha.trans h.symm)âŸ©, exists_unique.existsâŸ©\n#align injective.mem_range_iff_exists_unique injective.mem_range_iff_exists_unique\n\n",
 "mem_range":
 "@[simp]\ntheorem mem_range {x : Î±} : x âˆˆ range f â†” âˆƒ y, f y = x :=\n  iff.rfl\n#align mem_range mem_range\n\n",
 "mem_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem mem_preimage {s : set Î²} {a : Î±} : a âˆˆ Â«expr â»Â¹' Â» f s â†” f a âˆˆ s :=\n  iff.rfl\n#align mem_preimage mem_preimage\n\n",
 "mem_image_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_image_of_mem (f : Î± â†’ Î²) {x : Î±} {a : set Î±} (h : x âˆˆ a) : f x âˆˆ Â«expr '' Â» f a :=\n  âŸ¨_, h, rflâŸ©\n#align mem_image_of_mem mem_image_of_mem\n\n",
 "mem_image_iff_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_image_iff_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} {b : Î²} {s : set Î±} (hâ‚ : left_inverse g f)\n    (hâ‚‚ : right_inverse g f) : b âˆˆ Â«expr '' Â» f s â†” g b âˆˆ s := by rw [image_eq_preimage_of_inverse hâ‚ hâ‚‚] <;> rfl\n#align mem_image_iff_of_inverse mem_image_iff_of_inverse\n\n",
 "mem_image_iff_bex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_image_iff_bex {f : Î± â†’ Î²} {s : set Î±} {y : Î²} : y âˆˆ Â«expr '' Â» f s â†” âˆƒ (x : _)(_ : x âˆˆ s), f x = y :=\n  bex_def.symm\n#align mem_image_iff_bex mem_image_iff_bex\n\n",
 "mem_image_elim_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_image_elim_on {f : Î± â†’ Î²} {s : set Î±} {C : Î² â†’ Prop} {y : Î²} (h_y : y âˆˆ Â«expr '' Â» f s)\n    (h : âˆ€ x : Î±, x âˆˆ s â†’ C (f x)) : C y :=\n  mem_image_elim h h_y\n#align mem_image_elim_on mem_image_elim_on\n\n",
 "mem_image_elim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem mem_image_elim {f : Î± â†’ Î²} {s : set Î±} {C : Î² â†’ Prop} (h : âˆ€ x : Î±, x âˆˆ s â†’ C (f x)) :\n    âˆ€ {y : Î²}, y âˆˆ Â«expr '' Â» f s â†’ C y\n  | _, âŸ¨a, a_in, rflâŸ© => h a a_in\n#align mem_image_elim mem_image_elim\n\n",
 "mem_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem mem_image (f : Î± â†’ Î²) (s : set Î±) (y : Î²) : y âˆˆ Â«expr '' Â» f s â†” âˆƒ x, x âˆˆ s âˆ§ f x = y :=\n  iff.rfl\n#align mem_image mem_image\n\n",
 "mem_compl_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem mem_compl_image [BooleanAlgebra Î±] (t : Î±) (S : set Î±) : t âˆˆ Â«expr '' Â» compl S â†” Â«expr á¶œÂ» t âˆˆ S := by\n  simp [â† preimage_compl_eq_image_compl]\n#align mem_compl_image mem_compl_image\n\n",
 "left_inverse_range_splitting":
 "-- When `f` is injective, see also `equiv.of_injective`.\ntheorem left_inverse_range_splitting (f : Î± â†’ Î²) : left_inverse (rangeFactorization f) (rangeSplitting f) := fun x =>\n  by\n  ext\n  simp only [range_factorization_coe]\n  apply apply_range_splitting\n#align left_inverse_range_splitting left_inverse_range_splitting\n\n",
 "is_compl_range_some_none":
 "theorem is_compl_range_some_none (Î± : Type _) : IsCompl (range (some : Î± â†’ option Î±)) {none} :=\n  IsCompl.of_le (fun x âŸ¨âŸ¨a, haâŸ©, (hn : x = none)âŸ© => option.some_ne_none _ (ha.trans hn)) fun x hx =>\n    option.cases_on x (or.inr rfl) fun x => or.inl <| mem_range_self _\n#align is_compl_range_some_none is_compl_range_some_none\n\n",
 "is_compl_range_inl_range_inr":
 "theorem is_compl_range_inl_range_inr : IsCompl (range <| @sum.inl Î± Î²) (range sum.inr) :=\n  IsCompl.of_le\n    (by\n      rintro y âŸ¨âŸ¨xâ‚, rflâŸ©, âŸ¨xâ‚‚, _âŸ©âŸ©\n      cc)\n    (by rintro (x | y) - <;> [left, right] <;> exact mem_range_self _)\n#align is_compl_range_inl_range_inr is_compl_range_inl_range_inr\n\n",
 "inter_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem inter_preimage_subset (s : set Î±) (t : set Î²) (f : Î± â†’ Î²) :\n    s âˆ© Â«expr â»Â¹' Â» f t âŠ† Â«expr â»Â¹' Â» f (Â«expr '' Â» f s âˆ© t) := fun x h => âŸ¨mem_image_of_mem _ h.left, h.rightâŸ©\n#align inter_preimage_subset inter_preimage_subset\n\n",
 "insert_none_range_some":
 "@[simp]\ntheorem insert_none_range_some (Î± : Type _) : insert none (range (some : Î± â†’ option Î±)) = univ :=\n  (isCompl_range_some_none Î±).symm.sup_eq_top\n#align insert_none_range_some insert_none_range_some\n\n",
 "insert_image_compl_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem insert_image_compl_eq_range (f : Î± â†’ Î²) (x : Î±) : insert (f x) (Â«expr '' Â» f (Â«expr á¶œÂ» {x})) = range f :=\n  by\n  ext y; rw [mem_range, mem_insert_iff, mem_image]\n  constructor\n  Â· rintro (h | âŸ¨x', hx', hâŸ©)\n    Â· exact âŸ¨x, h.symmâŸ©\n    Â· exact âŸ¨x', hâŸ©\n  Â· rintro âŸ¨x', hâŸ©\n    by_cases hx : x' = x\n    Â· left\n      rw [â† h, hx]\n    Â· right\n      refine' âŸ¨_, _, hâŸ©\n      rw [mem_compl_singleton_iff]\n      exact hx\n#align insert_image_compl_eq_range insert_image_compl_eq_range\n\n",
 "injective_iff":
 "theorem injective_iff {Î± Î²} {f : option Î± â†’ Î²} : injective f â†” injective (f âˆ˜ some) âˆ§ f none âˆ‰ range (f âˆ˜ some) :=\n  by\n  simp only [mem_range, not_exists, (Â· âˆ˜ Â·)]\n  refine' âŸ¨fun hf => âŸ¨hf.comp (option.some_injective _), fun x => hf.ne <| option.some_ne_none _âŸ©, _âŸ©\n  rintro âŸ¨h_some, h_noneâŸ© (_ | a) (_ | b) hab\n  exacts[rfl, (h_none _ hab.symm).elim, (h_none _ hab).elim, congr_arg some (h_some hab)]\n#align injective_iff injective_iff\n\n",
 "image_univ_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_univ_of_surjective {Î¹ : Type _} {f : Î¹ â†’ Î²} (H : surjective f) : Â«expr '' Â» f univ = univ :=\n  eq_univ_of_forall <| by simpa [image]\n#align image_univ_of_surjective image_univ_of_surjective\n\n",
 "image_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem image_univ {f : Î± â†’ Î²} : Â«expr '' Â» f univ = range f :=\n  by\n  ext\n  simp [image, range]\n#align image_univ image_univ\n\n",
 "image_union_image_compl_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem image_union_image_compl_eq_range (f : Î± â†’ Î²) : Â«expr '' Â» f s âˆª Â«expr '' Â» f (Â«expr á¶œÂ» s) = range f := by\n  rw [â† image_union, â† image_univ, â† union_compl_self]\n#align image_union_image_compl_eq_range image_union_image_compl_eq_range\n\n",
 "image_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_union (f : Î± â†’ Î²) (s t : set Î±) : Â«expr '' Â» f (s âˆª t) = Â«expr '' Â» f s âˆª Â«expr '' Â» f t :=\n  ext fun x =>\n    âŸ¨by rintro âŸ¨a, h | h, rflâŸ© <;> [left, right] <;> exact âŸ¨_, h, rflâŸ©, by\n      rintro (âŸ¨a, h, rflâŸ© | âŸ¨a, h, rflâŸ©) <;> refine' âŸ¨_, _, rflâŸ© <;> [left, right] <;> exact hâŸ©\n#align image_union image_union\n\n",
 "image_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ† Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ† Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_symm_diff (hf : injective f) (s t : set Î±) :\n    Â«expr '' Â» f (Â«expr âˆ† Â» s t) = Â«expr âˆ† Â» (Â«expr '' Â» f s) (Â«expr '' Â» f t) := by\n  simp_rw [Set.symmDiff_def, image_union, image_diff hf]\n#align image_symm_diff image_symm_diff\n\n",
 "image_swap_eq_preimage_swap":
 "theorem image_swap_eq_preimage_swap : image (@prod.swap Î± Î²) = preimage prod.swap :=\n  image_eq_preimage_of_inverse Prod.swap_leftInverse Prod.swap_rightInverse\n#align image_swap_eq_preimage_swap image_swap_eq_preimage_swap\n\n",
 "image_surjective":
 "@[simp]\ntheorem image_surjective : surjective (image f) â†” surjective f :=\n  by\n  refine' âŸ¨fun h y => _, surjective.image_surjectiveâŸ©\n  cases' h {y} with s hs\n  have := mem_singleton y; rw [â† hs] at this; rcases this with âŸ¨x, h1x, h2xâŸ©\n  exact âŸ¨x, h2xâŸ©\n#align image_surjective image_surjective\n\n",
 "image_subset_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_subset_range (f : Î± â†’ Î²) (s) : Â«expr '' Â» f s âŠ† range f := by\n  rw [â† image_univ] <;> exact image_subset _ (subset_univ _)\n#align image_subset_range image_subset_range\n\n",
 "image_subset_preimage_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_subset_preimage_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} (I : left_inverse g f) (s : set Î±) :\n    Â«expr '' Â» f s âŠ† Â«expr â»Â¹' Â» g s := fun b âŸ¨a, h, eâŸ© => e â–¸ ((I a).symm â–¸ h : g (f a) âˆˆ s)\n#align image_subset_preimage_of_inverse image_subset_preimage_of_inverse\n\n",
 "image_subset_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_subset_image_iff {f : Î± â†’ Î²} (hf : injective f) : Â«expr '' Â» f s âŠ† Â«expr '' Â» f t â†” s âŠ† t :=\n  by\n  refine' iff.symm <| iff.intro (image_subset f) fun h => _\n  rw [â† preimage_image_eq s hf, â† preimage_image_eq t hf]\n  exact preimage_mono h\n#align image_subset_image_iff image_subset_image_iff\n\n",
 "image_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/-- image and preimage are a Galois connection -/\n@[simp]\ntheorem image_subset_iff {s : set Î±} {t : set Î²} {f : Î± â†’ Î²} : Â«expr '' Â» f s âŠ† t â†” s âŠ† Â«expr â»Â¹' Â» f t :=\n  ball_image_iff\n#align image_subset_iff image_subset_iff\n\n",
 "image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- Image is monotone with respect to `âŠ†`. See `set.monotone_image` for the statement in\nterms of `â‰¤`. -/\ntheorem image_subset {a b : set Î±} (f : Î± â†’ Î²) (h : a âŠ† b) : Â«expr '' Â» f a âŠ† Â«expr '' Â» f b :=\n  by\n  simp only [subset_def, mem_image]\n  exact fun x => fun âŸ¨w, h1, h2âŸ© => âŸ¨w, h h1, h2âŸ©\n#align image_subset image_subset\n\n",
 "image_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem image_singleton {f : Î± â†’ Î²} {a : Î±} : Â«expr '' Â» f {a} = {f a} :=\n  by\n  ext\n  simp [image, eq_comm]\n#align image_singleton image_singleton\n\n",
 "image_preimage_val":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_val (s t : set Î±) : Â«expr '' Â» (subtype.val : s â†’ Î±) (Â«expr â»Â¹' Â» subtype.val t) = t âˆ© s :=\n  image_preimage_coe s t\n#align image_preimage_val image_preimage_val\n\n",
 "image_preimage_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_subset (f : Î± â†’ Î²) (s : set Î²) : Â«expr '' Â» f (Â«expr â»Â¹' Â» f s) âŠ† s :=\n  image_subset_iff.2 Subset.rfl\n#align image_preimage_subset image_preimage_subset\n\n",
 "image_preimage_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_preimage_inter (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) :\n    Â«expr '' Â» f (Â«expr â»Â¹' Â» f t âˆ© s) = t âˆ© Â«expr '' Â» f s := by simp only [inter_comm, image_inter_preimage]\n#align image_preimage_inter image_preimage_inter\n\n",
 "image_preimage_inl_union_image_preimage_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_inl_union_image_preimage_inr (s : set (Sum Î± Î²)) :\n    Â«expr '' Â» sum.inl (Â«expr â»Â¹' Â» sum.inl s) âˆª Â«expr '' Â» sum.inr (Â«expr â»Â¹' Â» sum.inr s) = s := by\n  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, â† inter_distrib_left, range_inl_union_range_inr,\n    inter_univ]\n#align image_preimage_inl_union_image_preimage_inr image_preimage_inl_union_image_preimage_inr\n\n",
 "image_preimage_eq_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_eq_of_subset {f : Î± â†’ Î²} {s : set Î²} (hs : s âŠ† range f) : Â«expr '' Â» f (Â«expr â»Â¹' Â» f s) = s :=\n  by rw [image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]\n#align image_preimage_eq_of_subset image_preimage_eq_of_subset\n\n",
 "image_preimage_eq_inter_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_eq_inter_range {f : Î± â†’ Î²} {t : set Î²} : Â«expr '' Â» f (Â«expr â»Â¹' Â» f t) = t âˆ© range f :=\n  ext fun x =>\n    âŸ¨fun âŸ¨x, hx, HEqâŸ© => HEq â–¸ âŸ¨hx, mem_range_self _âŸ©, fun âŸ¨hx, âŸ¨y, h_eqâŸ©âŸ© =>\n      h_eq â–¸ mem_image_of_mem f <| show y âˆˆ Â«expr â»Â¹' Â» f t by simp [preimage, h_eq, hx]âŸ©\n#align image_preimage_eq_inter_range image_preimage_eq_inter_range\n\n",
 "image_preimage_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_eq_iff {f : Î± â†’ Î²} {s : set Î²} : Â«expr '' Â» f (Â«expr â»Â¹' Â» f s) = s â†” s âŠ† range f :=\n  âŸ¨by\n    intro h\n    rw [â† h]\n    apply image_subset_range, image_preimage_eq_of_subsetâŸ©\n#align image_preimage_eq_iff image_preimage_eq_iff\n\n",
 "image_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_preimage_eq {f : Î± â†’ Î²} (s : set Î²) (h : surjective f) : Â«expr '' Â» f (Â«expr â»Â¹' Â» f s) = s :=\n  Subset.antisymm (image_preimage_subset f s) fun x hx =>\n    let âŸ¨y, eâŸ© := h x\n    âŸ¨y, (e.symm â–¸ hx : f y âˆˆ s), eâŸ©\n#align image_preimage_eq image_preimage_eq\n\n",
 "image_preimage_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem image_preimage_coe (s t : set Î±) : Â«expr '' Â» (coe : s â†’ Î±) (Â«expr â»Â¹' Â» coe t) = t âˆ© s :=\n  image_preimage_eq_inter_range.trans <| congr_arg _ range_coe\n#align image_preimage_coe image_preimage_coe\n\n",
 "image_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem surjective.image_preimage (hf : surjective f) (s : set Î²) : Â«expr '' Â» f (Â«expr â»Â¹' Â» f s) = s :=\n  image_preimage_eq s hf\n#align surjective.image_preimage surjective.image_preimage\n\n",
 "image_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- If the only elements outside `s` are those left fixed by `Ïƒ`, then mapping by `Ïƒ` has no effect.\n-/\ntheorem image_perm {s : set Î±} {Ïƒ : equiv.perm Î±} (hs : { a : Î± | Ïƒ a â‰  a } âŠ† s) : Â«expr '' Â» Ïƒ s = s :=\n  by\n  ext i\n  obtain hi | hi := eq_or_ne (Ïƒ i) i\n  Â· refine' âŸ¨_, fun h => âŸ¨i, h, hiâŸ©âŸ©\n    rintro âŸ¨j, hj, hâŸ©\n    rwa [Ïƒ.injective (hi.trans h.symm)]\n  Â· refine' iff_of_true âŸ¨Ïƒ.symm i, hs fun h => hi _, Ïƒ.apply_symm_apply _âŸ© (hs hi)\n    convert congr_arg Ïƒ h <;> exact (Ïƒ.apply_symm_apply _).symm\n#align image_perm image_perm\n\n",
 "image_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_pair (f : Î± â†’ Î²) (a b : Î±) : Â«expr '' Â» f {a, b} = {f a, f b} := by\n  simp only [image_insert_eq, image_singleton]\n#align image_pair image_pair\n\n",
 "image_inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_inter_subset (f : Î± â†’ Î²) (s t : set Î±) : Â«expr '' Â» f (s âˆ© t) âŠ† Â«expr '' Â» f s âˆ© Â«expr '' Â» f t :=\n  subset_inter (image_subset _ <| inter_subset_left _ _) (image_subset _ <| inter_subset_right _ _)\n#align image_inter_subset image_inter_subset\n\n",
 "image_inter_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_inter_preimage (f : Î± â†’ Î²) (s : set Î±) (t : set Î²) :\n    Â«expr '' Â» f (s âˆ© Â«expr â»Â¹' Â» f t) = Â«expr '' Â» f s âˆ© t :=\n  by\n  apply subset.antisymm\n  Â·\n    calc\n      Â«expr '' Â» f (s âˆ© Â«expr â»Â¹' Â» f t) âŠ† Â«expr '' Â» f s âˆ© Â«expr '' Â» f (Â«expr â»Â¹' Â» f t) := image_inter_subset _ _ _\n      _ âŠ† Â«expr '' Â» f s âˆ© t := inter_subset_inter_right _ (image_preimage_subset f t)\n      \n  Â· rintro _ âŸ¨âŸ¨x, h', rflâŸ©, hâŸ©\n    exact âŸ¨x, âŸ¨h', hâŸ©, rflâŸ©\n#align image_inter_preimage image_inter_preimage\n\n",
 "image_inter_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_inter_on {f : Î± â†’ Î²} {s t : set Î±} (h : âˆ€ x âˆˆ t, âˆ€ y âˆˆ s, f x = f y â†’ x = y) :\n    Â«expr '' Â» f (s âˆ© t) = Â«expr '' Â» f s âˆ© Â«expr '' Â» f t :=\n  (image_inter_subset _ _ _).antisymm fun b âŸ¨âŸ¨aâ‚, haâ‚, hâ‚âŸ©, âŸ¨aâ‚‚, haâ‚‚, hâ‚‚âŸ©âŸ© =>\n    have : aâ‚‚ = aâ‚ := h _ haâ‚‚ _ haâ‚ (by simp [*])\n    âŸ¨aâ‚, âŸ¨haâ‚, this â–¸ haâ‚‚âŸ©, hâ‚âŸ©\n#align image_inter_on image_inter_on\n\n",
 "image_inter_nonempty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem image_inter_nonempty_iff {f : Î± â†’ Î²} {s : set Î±} {t : set Î²} :\n    (Â«expr '' Â» f s âˆ© t).nonempty â†” (s âˆ© Â«expr â»Â¹' Â» f t).nonempty := by rw [â† image_inter_preimage, nonempty_image_iff]\n#align image_inter_nonempty_iff image_inter_nonempty_iff\n\n",
 "image_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_inter {f : Î± â†’ Î²} {s t : set Î±} (H : injective f) :\n    Â«expr '' Â» f (s âˆ© t) = Â«expr '' Â» f s âˆ© Â«expr '' Â» f t :=\n  image_inter_on fun x _ y _ h => H h\n#align image_inter image_inter\n\n",
 "image_insert_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_insert_eq {f : Î± â†’ Î²} {a : Î±} {s : set Î±} : Â«expr '' Â» f (insert a s) = insert (f a) (Â«expr '' Â» f s) :=\n  by\n  ext\n  simp [and_or_left, exists_or, eq_comm, or_comm', and_comm']\n#align image_insert_eq image_insert_eq\n\n",
 "image_injective":
 "@[simp]\ntheorem image_injective : injective (image f) â†” injective f :=\n  by\n  refine' âŸ¨fun h x x' hx => _, injective.image_injectiveâŸ©\n  rw [â† singleton_eq_singleton_iff]; apply h\n  rw [image_singleton, image_singleton, hx]\n#align image_injective image_injective\n\n",
 "image_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem left_inverse.image_image {g : Î² â†’ Î±} (h : left_inverse g f) (s : set Î±) : Â«expr '' Â» g (Â«expr '' Â» f s) = s :=\n  by rw [â† image_comp, h.comp_eq_id, image_id]\n#align left_inverse.image_image left_inverse.image_image\n\n",
 "image_id'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- A variant of `image_id` -/\n@[simp]\ntheorem image_id' (s : set Î±) : Â«expr '' Â» (fun x => x) s = s :=\n  by\n  ext\n  simp\n#align image_id' image_id'\n\n",
 "image_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_id (s : set Î±) : Â«expr '' Â» id s = s := by simp\n#align image_id image_id\n\n",
 "image_factorization_eq":
 "theorem image_factorization_eq {f : Î± â†’ Î²} {s : set Î±} : subtype.val âˆ˜ imageFactorization f s = f âˆ˜ subtype.val :=\n  funext fun p => rfl\n#align image_factorization_eq image_factorization_eq\n\n",
 "image_eta":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_eta (f : Î± â†’ Î²) : Â«expr '' Â» f s = Â«expr '' Â» (fun x => f x) s :=\n  rfl\n#align image_eta image_eta\n\n",
 "image_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_eq_range (f : Î± â†’ Î²) (s : set Î±) : Â«expr '' Â» f s = range fun x : s => f x :=\n  by\n  ext\n  constructor\n  rintro âŸ¨x, h1, h2âŸ©\n  exact âŸ¨âŸ¨x, h1âŸ©, h2âŸ©\n  rintro âŸ¨âŸ¨x, h1âŸ©, h2âŸ©\n  exact âŸ¨x, h1, h2âŸ©\n#align image_eq_range image_eq_range\n\n",
 "image_eq_preimage_of_inverse":
 "theorem image_eq_preimage_of_inverse {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hâ‚ : left_inverse g f) (hâ‚‚ : right_inverse g f) :\n    image f = preimage g :=\n  funext fun s => Subset.antisymm (image_subset_preimage_of_inverse hâ‚ s) (preimage_subset_image_of_inverse hâ‚‚ s)\n#align image_eq_preimage_of_inverse image_eq_preimage_of_inverse\n\n",
 "image_eq_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_eq_image {f : Î± â†’ Î²} (hf : injective f) : Â«expr '' Â» f s = Â«expr '' Â» f t â†” s = t :=\n  iff.symm <| iff.intro (fun eq => eq â–¸ rfl) fun eq => by rw [â† preimage_image_eq s hf, â† preimage_image_eq t hf, eq]\n#align image_eq_image image_eq_image\n\n",
 "image_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem image_eq_empty {Î± Î²} {f : Î± â†’ Î²} {s : set Î±} : Â«expr '' Â» f s = âˆ… â†” s = âˆ… :=\n  by\n  simp only [eq_empty_iff_forall_not_mem]\n  exact âŸ¨fun H a ha => H _ âŸ¨_, ha, rflâŸ©, fun H b âŸ¨_, ha, _âŸ© => H _ haâŸ©\n#align image_eq_empty image_eq_empty\n\n",
 "image_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem image_empty (f : Î± â†’ Î²) : Â«expr '' Â» f âˆ… = âˆ… := by\n  ext\n  simp\n#align image_empty image_empty\n\n",
 "image_diff_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_diff_preimage {f : Î± â†’ Î²} {s : set Î±} {t : set Î²} :\n    Â«expr '' Â» f (s \\ Â«expr â»Â¹' Â» f t) = Â«expr '' Â» f s \\ t := by\n  simp_rw [diff_eq, â† preimage_compl, image_inter_preimage]\n#align image_diff_preimage image_diff_preimage\n\n",
 "image_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_diff {f : Î± â†’ Î²} (hf : injective f) (s t : set Î±) :\n    Â«expr '' Â» f (s \\ t) = Â«expr '' Â» f s \\ Â«expr '' Â» f t :=\n  Subset.antisymm (Subset.trans (image_inter_subset _ _ _) <| inter_subset_inter_right _ <| image_compl_subset hf)\n    (subset_image_diff f s t)\n#align image_diff image_diff\n\n",
 "image_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem nonempty.image_const {s : set Î±} (hs : s.nonempty) (a : Î²) : Â«expr '' Â» (fun _ => a) s = {a} :=\n  ext fun x =>\n    âŸ¨fun âŸ¨y, _, hâŸ© => h â–¸ mem_singleton _, fun h => (eq_of_mem_singleton h).symm â–¸ hs.imp fun y hy => âŸ¨hy, rflâŸ©âŸ©\n#align nonempty.image_const nonempty.image_const\n\n",
 "image_congr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- A common special case of `image_congr` -/\ntheorem image_congr' {f g : Î± â†’ Î²} {s : set Î±} (h : âˆ€ x : Î±, f x = g x) : Â«expr '' Â» f s = Â«expr '' Â» g s :=\n  image_congr fun x _ => h x\n#align image_congr' image_congr'\n\n",
 "image_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[congr]\ntheorem image_congr {f g : Î± â†’ Î²} {s : set Î±} (h : âˆ€ a âˆˆ s, f a = g a) : Â«expr '' Â» f s = Â«expr '' Â» g s := by\n  safe [ext_iff, iff_def]\n#align image_congr image_congr\n\n",
 "image_compl_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_compl_subset {f : Î± â†’ Î²} {s : set Î±} (H : injective f) :\n    Â«expr '' Â» f (Â«expr á¶œÂ» s) âŠ† Â«expr á¶œÂ» (Â«expr '' Â» f s) :=\n  disjoint.subset_compl_left <| by simp [disjoint_iff_inf_le, â† image_inter H]\n#align image_compl_subset image_compl_subset\n\n",
 "image_compl_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem image_compl_preimage {f : Î± â†’ Î²} {s : set Î²} : Â«expr '' Â» f (Â«expr á¶œÂ» (Â«expr â»Â¹' Â» f s)) = range f \\ s := by\n  rw [compl_eq_univ_diff, image_diff_preimage, image_univ]\n#align image_compl_preimage image_compl_preimage\n\n",
 "image_compl_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_compl_eq {f : Î± â†’ Î²} {s : set Î±} (H : bijective f) :\n    Â«expr '' Â» f (Â«expr á¶œÂ» s) = Â«expr á¶œÂ» (Â«expr '' Â» f s) :=\n  Subset.antisymm (image_compl_subset H.1) (subset_image_compl H.2)\n#align image_compl_eq image_compl_eq\n\n",
 "image_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem image_comp (f : Î² â†’ Î³) (g : Î± â†’ Î²) (a : set Î±) : Â«expr '' Â» (f âˆ˜ g) a = Â«expr '' Â» f (Â«expr '' Â» g a) :=\n  Subset.antisymm (ball_image_of_ball fun a ha => mem_image_of_mem _ <| mem_image_of_mem _ ha)\n    (ball_image_of_ball <| ball_image_of_ball fun a ha => mem_image_of_mem _ ha)\n#align image_comp image_comp\n\n",
 "image_comm":
 "theorem image_comm {Î²'} {f : Î² â†’ Î³} {g : Î± â†’ Î²} {f' : Î± â†’ Î²'} {g' : Î²' â†’ Î³} (h_comm : âˆ€ a, f (g a) = g' (f' a)) :\n    (s.image g).image f = (s.image f').image g' := by simp_rw [image_image, h_comm]\n#align image_comm image_comm\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/-- The image of a nontrivial set under an injective map is nontrivial. -/\ntheorem nontrivial.image (hs : s.nontrivial) {f : Î± â†’ Î²} (hf : function.injective f) : (Â«expr '' Â» f s).nontrivial :=\n  let âŸ¨x, hx, y, hy, hxyâŸ© := hs\n  âŸ¨f x, mem_image_of_mem f hx, f y, mem_image_of_mem f hy, hf.ne hxyâŸ©\n#align nontrivial.image nontrivial.image\n\n",
 "forall_subtype_range_iff":
 "theorem forall_subtype_range_iff {p : range f â†’ Prop} : (âˆ€ a : range f, p a) â†” âˆ€ i, p âŸ¨f i, mem_range_self _âŸ© :=\n  âŸ¨fun H i => H _, fun H âŸ¨y, i, hiâŸ© => by\n    subst hi\n    apply HâŸ©\n#align forall_subtype_range_iff forall_subtype_range_iff\n\n",
 "forall_range_iff":
 "theorem forall_range_iff {p : Î± â†’ Prop} : (âˆ€ a âˆˆ range f, p a) â†” âˆ€ i, p (f i) := by simp\n#align forall_range_iff forall_range_iff\n\n",
 "exists_unique_of_mem_range":
 "theorem injective.exists_unique_of_mem_range (hf : injective f) {b : Î²} (hb : b âˆˆ range f) : âˆƒ! a, f a = b :=\n  hf.mem_range_iff_exists_unique.mp hb\n#align injective.exists_unique_of_mem_range injective.exists_unique_of_mem_range\n\n",
 "exists_subtype_range_iff":
 "theorem exists_subtype_range_iff {p : range f â†’ Prop} : (âˆƒ a : range f, p a) â†” âˆƒ i, p âŸ¨f i, mem_range_self _âŸ© :=\n  âŸ¨fun âŸ¨âŸ¨a, i, hiâŸ©, haâŸ© => by\n    subst a\n    exact âŸ¨i, haâŸ©, fun âŸ¨i, hiâŸ© => âŸ¨_, hiâŸ©âŸ©\n#align exists_subtype_range_iff exists_subtype_range_iff\n\n",
 "exists_subset_range_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (s Â«expr âŠ† Â» range[set.range] f) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem exists_subset_range_iff {f : Î± â†’ Î²} {p : set Î² â†’ Prop} :\n    (âˆƒ (s : _)(_ : s âŠ† range f), p s) â†” âˆƒ s, p (Â«expr '' Â» f s) := by\n  simp only [exists_prop, exists_subset_range_and_iff]\n#align exists_subset_range_iff exists_subset_range_iff\n\n",
 "exists_subset_range_and_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n@[simp]\ntheorem exists_subset_range_and_iff {f : Î± â†’ Î²} {p : set Î² â†’ Prop} :\n    (âˆƒ s, s âŠ† range f âˆ§ p s) â†” âˆƒ s, p (Â«expr '' Â» f s) :=\n  âŸ¨fun âŸ¨s, hsf, hpsâŸ© => âŸ¨Â«expr â»Â¹' Â» f s, (image_preimage_eq_of_subset hsf).symm â–¸ hpsâŸ©, fun âŸ¨s, hsâŸ© =>\n    âŸ¨Â«expr '' Â» f s, image_subset_range _ _, hsâŸ©âŸ©\n#align exists_subset_range_and_iff exists_subset_range_and_iff\n\n",
 "exists_set_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem exists_set_subtype {t : set Î±} (p : set Î± â†’ Prop) :\n    (âˆƒ s : set t, p (Â«expr '' Â» coe s)) â†” âˆƒ s : set Î±, s âŠ† t âˆ§ p s :=\n  by\n  constructor\n  Â· rintro âŸ¨s, hsâŸ©\n    refine' âŸ¨Â«expr '' Â» coe s, _, hsâŸ©\n    convert image_subset_range _ _\n    rw [range_coe]\n  rintro âŸ¨s, hsâ‚, hsâ‚‚âŸ©; refine' âŸ¨Â«expr â»Â¹' Â» coe s, _âŸ©\n  rw [image_preimage_eq_of_subset]; exact hsâ‚‚; rw [range_coe]; exact hsâ‚\n#align exists_set_subtype exists_set_subtype\n\n",
 "exists_range_iff'":
 "theorem exists_range_iff' {p : Î± â†’ Prop} : (âˆƒ a, a âˆˆ range f âˆ§ p a) â†” âˆƒ i, p (f i) := by\n  simpa only [exists_prop] using exists_range_iff\n#align exists_range_iff' exists_range_iff'\n\n",
 "exists_range_iff":
 "theorem exists_range_iff {p : Î± â†’ Prop} : (âˆƒ a âˆˆ range f, p a) â†” âˆƒ i, p (f i) := by simp\n#align exists_range_iff exists_range_iff\n\n",
 "exists_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem exists_image_iff (f : Î± â†’ Î²) (x : set Î±) (P : Î² â†’ Prop) : (âˆƒ a : Â«expr '' Â» f x, P a) â†” âˆƒ a : x, P (f a) :=\n  âŸ¨fun âŸ¨a, hâŸ© => âŸ¨âŸ¨_, a.prop.some_spec.1âŸ©, a.prop.some_spec.2.symm â–¸ hâŸ©, fun âŸ¨a, hâŸ© => âŸ¨âŸ¨_, _, a.prop, rflâŸ©, hâŸ©âŸ©\n#align exists_image_iff exists_image_iff\n\n",
 "eq_preimage_subtype_val_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem eq_preimage_subtype_val_iff {p : Î± â†’ Prop} {s : set (subtype p)} {t : set Î±} :\n    s = Â«expr â»Â¹' Â» subtype.val t â†” âˆ€ (x) (h : p x), (âŸ¨x, hâŸ© : subtype p) âˆˆ s â†” x âˆˆ t :=\n  âŸ¨fun s_eq x h => by\n    rw [s_eq]\n    simp, fun h => ext fun âŸ¨x, hxâŸ© => by simp [h]âŸ©\n#align eq_preimage_subtype_val_iff eq_preimage_subtype_val_iff\n\n",
 "eq_preimage_iff_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem eq_preimage_iff_image_eq {f : Î± â†’ Î²} (hf : bijective f) {s t} : s = Â«expr â»Â¹' Â» f t â†” Â«expr '' Â» f s = t := by\n  rw [â† image_eq_image hf.1, hf.2.image_preimage]\n#align eq_preimage_iff_image_eq eq_preimage_iff_image_eq\n\n",
 "elim_range":
 "@[simp]\ntheorem sum.elim_range (f : Î± â†’ Î³) (g : Î² â†’ Î³) : range (sum.elim f g) = range f âˆª range g :=\n  Sum.range_eq _\n#align sum.elim_range sum.elim_range\n\n",
 "disjoint_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\ntheorem disjoint_preimage_iff (hf : surjective f) {s t : set Î²} :\n    Disjoint (Â«expr â»Â¹' Â» f s) (Â«expr â»Â¹' Â» f t) â†” Disjoint s t :=\n  âŸ¨Disjoint.of_preimage hf, Disjoint.preimage _âŸ©\n#align disjoint_preimage_iff disjoint_preimage_iff\n\n",
 "disjoint_image_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem disjoint_image_of_injective {f : Î± â†’ Î²} (hf : injective f) {s t : set Î±} (hd : Disjoint s t) :\n    Disjoint (Â«expr '' Â» f s) (Â«expr '' Â» f t) :=\n  disjoint_image_image fun x hx y hy => hf.ne fun H => Set.disjoint_iff.1 hd âŸ¨hx, H.symm â–¸ hyâŸ©\n#align disjoint_image_of_injective disjoint_image_of_injective\n\n",
 "disjoint_image_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem disjoint_image_image {f : Î² â†’ Î±} {g : Î³ â†’ Î±} {s : set Î²} {t : set Î³} (h : âˆ€ b âˆˆ s, âˆ€ c âˆˆ t, f b â‰  g c) :\n    Disjoint (Â«expr '' Â» f s) (Â«expr '' Â» g t) :=\n  disjoint_iff_inf_le.mpr <| by rintro a âŸ¨âŸ¨b, hb, eqâŸ©, c, hc, rflâŸ© <;> exact h b hb c hc eq\n#align disjoint_image_image disjoint_image_image\n\n",
 "disjoint_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem disjoint_image_iff (hf : injective f) : Disjoint (Â«expr '' Â» f s) (Â«expr '' Â» f t) â†” Disjoint s t :=\n  âŸ¨Disjoint.of_image, disjoint_image_of_injective hfâŸ©\n#align disjoint_image_iff disjoint_image_iff\n\n",
 "compl_range_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem compl_range_some (Î± : Type _) : Â«expr á¶œÂ» (range (some : Î± â†’ option Î±)) = {none} :=\n  (isCompl_range_some_none Î±).compl_eq\n#align compl_range_some compl_range_some\n\n",
 "compl_range_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem compl_range_inr : Â«expr á¶œÂ» (range (sum.inr : Î² â†’ Sum Î± Î²)) = range (sum.inl : Î± â†’ Sum Î± Î²) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr.symm\n#align compl_range_inr compl_range_inr\n\n",
 "compl_range_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n@[simp]\ntheorem compl_range_inl : Â«expr á¶œÂ» (range (sum.inl : Î± â†’ Sum Î± Î²)) = range (sum.inr : Î² â†’ Sum Î± Î²) :=\n  IsCompl.compl_eq isCompl_range_inl_range_inr\n#align compl_range_inl compl_range_inl\n\n",
 "compl_image_set_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem compl_image_set_of {p : set Î± â†’ Prop} : Â«expr '' Â» compl { s | p s } = { s | p (Â«expr á¶œÂ» s) } :=\n  congr_fun compl_image p\n#align compl_image_set_of compl_image_set_of\n\n",
 "compl_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem injective.compl_image_eq (hf : injective f) (s : set Î±) :\n    Â«expr á¶œÂ» (Â«expr '' Â» f s) = Â«expr '' Â» f (Â«expr á¶œÂ» s) âˆª Â«expr á¶œÂ» (range f) :=\n  by\n  ext y\n  rcases em (y âˆˆ range f) with (âŸ¨x, rflâŸ© | hx)\n  Â· simp [hf.eq_iff]\n  Â· rw [mem_range, not_exists] at hx\n    simp [hx]\n#align injective.compl_image_eq injective.compl_image_eq\n\n",
 "compl_image":
 "theorem compl_image : image (compl : set Î± â†’ set Î±) = preimage compl :=\n  image_eq_preimage_of_inverse compl_compl compl_compl\n#align compl_image compl_image\n\n",
 "compl_compl_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem compl_compl_image [BooleanAlgebra Î±] (S : set Î±) : Â«expr '' Â» compl (Â«expr '' Â» compl S) = S := by\n  rw [â† image_comp, compl_comp_compl, image_id]\n#align compl_compl_image compl_compl_image\n\n",
 "comp_range_splitting":
 "@[simp]\ntheorem comp_range_splitting (f : Î± â†’ Î²) : f âˆ˜ rangeSplitting f = coe :=\n  by\n  ext\n  simp only [Function.comp_apply]\n  apply apply_range_splitting\n#align comp_range_splitting comp_range_splitting\n\n",
 "coe_preimage_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n@[simp]\ntheorem coe_preimage_self (s : set Î±) : Â«expr â»Â¹' Â» (coe : s â†’ Î±) s = univ := by\n  rw [â† preimage_range (coe : s â†’ Î±), range_coe]\n#align coe_preimage_self coe_preimage_self\n\n",
 "coe_image_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem coe_image_univ (s : set Î±) : Â«expr '' Â» (coe : s â†’ Î±) Set.univ = s :=\n  image_univ.trans range_coe\n#align coe_image_univ coe_image_univ\n\n",
 "coe_image_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem coe_image_subset (s : set Î±) (t : set s) : Â«expr '' Â» coe t âŠ† s := fun x âŸ¨y, yt, yvaleqâŸ© => by\n  rw [â† yvaleq] <;> exact y.property\n#align coe_image_subset coe_image_subset\n\n",
 "coe_image_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ†¥ Â» -/\n@[simp]\ntheorem coe_image_of_subset {s t : set Î±} (h : t âŠ† s) : Â«expr '' Â» coe { x : Â«exprâ†¥ Â» s | â†‘x âˆˆ t } = t :=\n  by\n  ext x\n  rw [Set.mem_image]\n  exact âŸ¨fun âŸ¨x', hx', hxâŸ© => hx â–¸ hx', fun hx => âŸ¨âŸ¨x, h hxâŸ©, hx, rflâŸ©âŸ©\n#align coe_image_of_subset coe_image_of_subset\n\n",
 "coe_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem coe_image {p : Î± â†’ Prop} {s : set (subtype p)} :\n    Â«expr '' Â» coe s = { x | âˆƒ h : p x, (âŸ¨x, hâŸ© : subtype p) âˆˆ s } :=\n  Set.ext fun a => âŸ¨fun âŸ¨âŸ¨a', ha'âŸ©, in_s, h_eqâŸ© => h_eq â–¸ âŸ¨ha', in_sâŸ©, fun âŸ¨ha, in_sâŸ© => âŸ¨âŸ¨a, haâŸ©, in_s, rflâŸ©âŸ©\n#align coe_image coe_image\n\n",
 "coe_comp_range_factorization":
 "@[simp]\ntheorem coe_comp_range_factorization (f : Î¹ â†’ Î²) : coe âˆ˜ rangeFactorization f = f :=\n  rfl\n#align coe_comp_range_factorization coe_comp_range_factorization\n\n",
 "bex_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem bex_image_iff {f : Î± â†’ Î²} {s : set Î±} {p : Î² â†’ Prop} : (âˆƒ y âˆˆ Â«expr '' Â» f s, p y) â†” âˆƒ x âˆˆ s, p (f x) := by simp\n#align bex_image_iff bex_image_iff\n\n",
 "ball_image_of_ball":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem ball_image_of_ball {f : Î± â†’ Î²} {s : set Î±} {p : Î² â†’ Prop} (h : âˆ€ x âˆˆ s, p (f x)) : âˆ€ y âˆˆ Â«expr '' Â» f s, p y :=\n  ball_image_iff.2 h\n#align ball_image_of_ball ball_image_of_ball\n\n",
 "ball_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr '' Â» -/\ntheorem ball_image_iff {f : Î± â†’ Î²} {s : set Î±} {p : Î² â†’ Prop} : (âˆ€ y âˆˆ Â«expr '' Â» f s, p y) â†” âˆ€ x âˆˆ s, p (f x) := by\n  simp\n#align ball_image_iff ball_image_iff\n\n",
 "apply_range_splitting":
 "-- This can not be a `@[simp]` lemma because the head of the left hand side is a variable.\ntheorem apply_range_splitting (f : Î± â†’ Î²) (x : range f) : f (rangeSplitting f x) = x :=\n  x.2.some_spec\n#align apply_range_splitting apply_range_splitting\n\n"}