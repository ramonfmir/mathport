{"enumerate_mem":
 "theorem enumerate_mem (h_sel : ∀ s a, sel s = some a → a ∈ s) : ∀ {s n a}, enumerate s n = some a → a ∈ s\n  | s, 0, a => h_sel s a\n  | s, n + 1, a => by\n    cases h : sel s\n    case none => simp [enumerate_eq_none_of_sel, h]\n    case some a' =>\n      simp [enumerate, h]\n      exact fun h' : enumerate _ (s \\ {a'}) n = some a =>\n        have : a ∈ s \\ {a'} := enumerate_mem h'\n        this.left\n#align enumerate_mem enumerate_mem\n\n",
 "enumerate_inj":
 "theorem enumerate_inj {n₁ n₂ : ℕ} {a : α} {s : Set α} (h_sel : ∀ s a, sel s = some a → a ∈ s)\n    (h₁ : enumerate s n₁ = some a) (h₂ : enumerate s n₂ = some a) : n₁ = n₂ :=\n  by\n  wlog hn : n₁ ≤ n₂\n  · cases' le_total n₁ n₂ with H H <;> [skip, symm] <;> apply_assumption <;> assumption\n  · rcases nat.le.dest hn with ⟨m, rfl⟩\n    clear hn\n    induction n₁ generalizing s\n    case zero =>\n      cases m\n      case zero => rfl\n      case succ m =>\n        have : enumerate sel (s \\ {a}) m = some a := by simp_all [enumerate]\n        have : a ∈ s \\ {a} := enumerate_mem _ h_sel this\n        · simpa\n    case succ => cases h : sel s <;> simp_all [enumerate, nat.add_succ, add_comm] <;> tauto\n#align enumerate_inj enumerate_inj\n\n",
 "enumerate_eq_none_of_sel":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem enumerate_eq_none_of_sel {s : Set α} (h : sel s = none) : ∀ {n}, enumerate s n = none\n  | 0 => by simp [h, enumerate] <;> rfl\n  | n + 1 => by simp [h, enumerate] <;> rfl\n#align enumerate_eq_none_of_sel enumerate_eq_none_of_sel\n\n",
 "enumerate_eq_none":
 "theorem enumerate_eq_none : ∀ {s n₁ n₂}, enumerate s n₁ = none → n₁ ≤ n₂ → enumerate s n₂ = none\n  | s, 0, m => fun h _ => enumerate_eq_none_of_sel h\n  | s, n + 1, m => fun h hm => by\n    cases hs : sel s\n    · exact enumerate_eq_none_of_sel sel hs\n    · cases m\n      case zero =>\n        have : n + 1 = 0 := nat.eq_zero_of_le_zero hm\n        contradiction\n      case succ m' =>\n        simp [hs, enumerate] at h⊢\n        have hm : n ≤ m' := nat.le_of_succ_le_succ hm\n        exact enumerate_eq_none h hm\n#align enumerate_eq_none enumerate_eq_none\n\n"}