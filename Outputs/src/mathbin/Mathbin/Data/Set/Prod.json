{"update_preimage_univ_pi":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (j «expr ≠ » i) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem update_preimage_univ_pi [DecidableEq ι] {f : ∀ i, α i} (hf : ∀ (j) (_ : j ≠ i), f j ∈ t j) :\n    «expr ⁻¹' » (update f i) (pi univ t) = t i :=\n  update_preimage_pi (mem_univ i) fun j _ => hf j\n#align update_preimage_univ_pi update_preimage_univ_pi\n\n",
 "update_preimage_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem update_preimage_pi [DecidableEq ι] {f : ∀ i, α i} (hi : i ∈ s) (hf : ∀ j ∈ s, j ≠ i → f j ∈ t j) :\n    «expr ⁻¹' » (update f i) (s.pi t) = t i := by\n  ext x\n  refine' ⟨fun h => _, fun hx j hj => _⟩\n  · convert h i hi\n    simp\n  · obtain rfl | h := eq_or_ne j i\n    · simpa\n    · rw [update_noteq h]\n      exact hf j hj h\n#align update_preimage_pi update_preimage_pi\n\n",
 "univ_prod_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem univ_prod_univ : set.prod (@univ α) (@univ β) = univ :=\n  by\n  ext\n  exact true_and_iff _\n#align univ_prod_univ univ_prod_univ\n\n",
 "univ_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem univ_prod {t : Set β} : set.prod (univ : Set α) t = «expr ⁻¹' » Prod.snd t := by simp [prod_eq]\n#align univ_prod univ_prod\n\n",
 "univ_pi_update_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem univ_pi_update_univ [DecidableEq ι] (i : ι) (s : Set (α i)) :\n    pi univ (update (fun j : ι => (univ : Set (α j))) i s) = «expr ⁻¹' » (eval i) s := by\n  rw [univ_pi_update i (fun j => (univ : Set (α j))) s fun j t => t, pi_univ, inter_univ, preimage]\n#align univ_pi_update_univ univ_pi_update_univ\n\n",
 "univ_pi_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem univ_pi_update [DecidableEq ι] {β : ∀ i, Type _} (i : ι) (f : ∀ j, α j) (a : α i) (t : ∀ j, α j → Set (β j)) :\n    (pi univ fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ pi («expr ᶜ» {i}) fun j => t j (f j) := by\n  rw [compl_eq_univ_diff, ← pi_update_of_mem (mem_univ _)]\n#align univ_pi_update univ_pi_update\n\n",
 "univ_pi_subset_univ_pi_iff":
 "theorem univ_pi_subset_univ_pi_iff : pi univ t₁ ⊆ pi univ t₂ ↔ (∀ i, t₁ i ⊆ t₂ i) ∨ ∃ i, t₁ i = ∅ := by\n  simp [pi_subset_pi_iff]\n#align univ_pi_subset_univ_pi_iff univ_pi_subset_univ_pi_iff\n\n",
 "univ_pi_singleton":
 "theorem univ_pi_singleton (f : ∀ i, α i) : (pi univ fun i => {f i}) = ({f} : Set (∀ i, α i)) :=\n  ext fun g => by simp [funext_iff]\n#align univ_pi_singleton univ_pi_singleton\n\n",
 "univ_pi_nonempty_iff":
 "theorem univ_pi_nonempty_iff : (pi univ t).nonempty ↔ ∀ i, (t i).nonempty := by simp [classical.skolem, Set.Nonempty]\n#align univ_pi_nonempty_iff univ_pi_nonempty_iff\n\n",
 "univ_pi_ite":
 "theorem univ_pi_ite (s : Set ι) [DecidablePred (· ∈ s)] (t : ∀ i, Set (α i)) :\n    (pi univ fun i => if i ∈ s then t i else univ) = s.pi t :=\n  by\n  ext\n  simp_rw [mem_univ_pi]\n  refine' forall_congr' fun i => _\n  split_ifs <;> simp [h]\n#align univ_pi_ite univ_pi_ite\n\n",
 "univ_pi_eq_empty_iff":
 "@[simp]\ntheorem univ_pi_eq_empty_iff : pi univ t = ∅ ↔ ∃ i, t i = ∅ := by\n  simp [← not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]\n#align univ_pi_eq_empty_iff univ_pi_eq_empty_iff\n\n",
 "univ_pi_eq_empty":
 "theorem univ_pi_eq_empty (ht : t i = ∅) : pi univ t = ∅ :=\n  pi_eq_empty (mem_univ i) ht\n#align univ_pi_eq_empty univ_pi_eq_empty\n\n",
 "univ_pi_empty":
 "@[simp]\ntheorem univ_pi_empty [h : Nonempty ι] : pi univ (fun i => ∅ : ∀ i, Set (α i)) = ∅ :=\n  univ_pi_eq_empty_iff.2 <| h.elim fun x => ⟨x, rfl⟩\n#align univ_pi_empty univ_pi_empty\n\n",
 "union_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem union_prod : set.prod (s₁ ∪ s₂) t = set.prod s₁ t ∪ set.prod s₂ t :=\n  by\n  ext ⟨x, y⟩\n  simp [or_and_right]\n#align union_prod union_prod\n\n",
 "union_pi":
 "theorem union_pi : (s₁ ∪ s₂).pi t = s₁.pi t ∩ s₂.pi t := by simp [pi, or_imp, forall_and, set_of_and]\n#align union_pi union_pi\n\n",
 "subset_pi_eval_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subset_pi_eval_image (s : Set ι) (u : Set (∀ i, α i)) : u ⊆ pi s fun i => «expr '' » (eval i) u :=\n  fun f hf i hi => ⟨f, hf, rfl⟩\n#align subset_pi_eval_image subset_pi_eval_image\n\n",
 "subset_eval_image_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem subset_eval_image_pi (ht : (s.pi t).nonempty) (i : ι) : t i ⊆ «expr '' » (eval i) (s.pi t) := by\n  classical\n    obtain ⟨f, hf⟩ := ht\n    refine' fun y hy => ⟨update f i y, fun j hj => _, update_same _ _ _⟩\n    obtain rfl | hji := eq_or_ne j i <;> simp [*, hf _ hj]\n#align subset_eval_image_pi subset_eval_image_pi\n\n",
 "snd_image_prod_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem snd_image_prod_subset (s : Set α) (t : Set β) : «expr '' » Prod.snd (set.prod s t) ⊆ t :=\n  image_subset_iff.2 <| prod_subset_preimage_snd s t\n#align snd_image_prod_subset snd_image_prod_subset\n\n",
 "snd_image_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem snd_image_prod {s : Set α} (hs : s.nonempty) (t : Set β) : «expr '' » Prod.snd (set.prod s t) = t :=\n  (snd_image_prod_subset _ _).antisymm fun y y_in =>\n    let ⟨x, x_in⟩ := hs\n    ⟨(x, y), ⟨x_in, y_in⟩, rfl⟩\n#align snd_image_prod snd_image_prod\n\n",
 "snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem nonempty.snd : (set.prod s t).nonempty → t.nonempty := fun ⟨x, hx⟩ => ⟨x.2, hx.2⟩\n#align nonempty.snd nonempty.snd\n\n",
 "singleton_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem singleton_prod_singleton : set.prod ({a} : Set α) ({b} : Set β) = {(a, b)} := by simp\n#align singleton_prod_singleton singleton_prod_singleton\n\n",
 "singleton_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem singleton_prod : set.prod ({a} : Set α) t = «expr '' » (prod.mk a) t :=\n  by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n#align singleton_prod singleton_prod\n\n",
 "singleton_pi'":
 "theorem singleton_pi' (i : ι) (t : ∀ i, Set (α i)) : pi {i} t = { x | x i ∈ t i } :=\n  singleton_pi i t\n#align singleton_pi' singleton_pi'\n\n",
 "singleton_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem singleton_pi (i : ι) (t : ∀ i, Set (α i)) : pi {i} t = «expr ⁻¹' » (eval i) (t i) :=\n  by\n  ext\n  simp [pi]\n#align singleton_pi singleton_pi\n\n",
 "set_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n#print AntitoneOn.set_prod /-\ntheorem AntitoneOn.set_prod (hf : AntitoneOn f s) (hg : AntitoneOn g s) :\n    AntitoneOn (fun x => set.prod (f x) (g x)) s := fun a ha b hb h => prod_mono (hf ha hb h) (hg ha hb h)\n#align antitone_on.set_prod AntitoneOn.set_prod\n-/\n\n",
 "range_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem range_prod_map {m₁ : α → γ} {m₂ : β → δ} : range (prod.map m₁ m₂) = set.prod (range m₁) (range m₂) :=\n  prod_range_range_eq.symm\n#align range_prod_map range_prod_map\n\n",
 "range_pair_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem range_pair_subset (f : α → β) (g : α → γ) : (range fun x => (f x, g x)) ⊆ set.prod (range f) (range g) :=\n  by\n  have : (fun x => (f x, g x)) = prod.map f g ∘ fun x => (x, x) := funext fun x => rfl\n  rw [this, ← range_prod_map]\n  apply range_comp_subset_range\n#align range_pair_subset range_pair_subset\n\n",
 "range_diag":
 "@[simp]\ntheorem range_diag : (range fun x => (x, x)) = diagonal α :=\n  by\n  ext ⟨x, y⟩\n  simp [diagonal, eq_comm]\n#align range_diag range_diag\n\n",
 "range_dcomp":
 "@[simp]\ntheorem range_dcomp (f : ∀ i, α i → β i) :\n    (range fun g : ∀ i, α i => fun i => f i (g i)) = pi univ fun i => range (f i) :=\n  by\n  apply subset.antisymm _ fun x hx => _\n  · rintro _ ⟨x, rfl⟩ i -\n    exact ⟨x i, rfl⟩\n  · choose y hy using hx\n    exact ⟨fun i => y i trivial, funext fun i => hy i trivial⟩\n#align range_dcomp range_dcomp\n\n",
 "prod_univ_range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_univ_range_eq {m₂ : β → δ} : set.prod (univ : Set α) (range m₂) = range fun p : α × β => (p.1, m₂ p.2) :=\n  ext <| by simp [range]\n#align prod_univ_range_eq prod_univ_range_eq\n\n",
 "prod_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_univ {s : Set α} : set.prod s (univ : Set β) = «expr ⁻¹' » Prod.fst s := by simp [prod_eq]\n#align prod_univ prod_univ\n\n",
 "prod_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_union : set.prod s (t₁ ∪ t₂) = set.prod s t₁ ∪ set.prod s t₂ :=\n  by\n  ext ⟨x, y⟩\n  simp [and_or_left]\n#align prod_union prod_union\n\n",
 "prod_subset_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/-- A product set is included in a product set if and only factors are included, or a factor of the\nfirst set is empty. -/\ntheorem prod_subset_prod_iff : set.prod s t ⊆ set.prod s₁ t₁ ↔ s ⊆ s₁ ∧ t ⊆ t₁ ∨ s = ∅ ∨ t = ∅ :=\n  by\n  cases' (set.prod s t).eq_empty_or_nonempty with h h\n  · simp [h, prod_eq_empty_iff.1 h]\n  have st : s.nonempty ∧ t.nonempty := by rwa [prod_nonempty_iff] at h\n  refine' ⟨fun H => or.inl ⟨_, _⟩, _⟩\n  · have := image_subset (Prod.fst : α × β → α) H\n    rwa [fst_image_prod _ st.2, fst_image_prod _ (h.mono H).snd] at this\n  · have := image_subset (Prod.snd : α × β → β) H\n    rwa [snd_image_prod st.1, snd_image_prod (h.mono H).fst] at this\n  · intro H\n    simp only [st.1.ne_empty, st.2.ne_empty, or_false_iff] at H\n    exact prod_mono H.1 H.2\n#align prod_subset_prod_iff prod_subset_prod_iff\n\n",
 "prod_subset_preimage_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_subset_preimage_snd (s : Set α) (t : Set β) : set.prod s t ⊆ «expr ⁻¹' » Prod.snd t :=\n  inter_subset_right _ _\n#align prod_subset_preimage_snd prod_subset_preimage_snd\n\n",
 "prod_subset_preimage_fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_subset_preimage_fst (s : Set α) (t : Set β) : set.prod s t ⊆ «expr ⁻¹' » Prod.fst s :=\n  inter_subset_left _ _\n#align prod_subset_preimage_fst prod_subset_preimage_fst\n\n",
 "prod_subset_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_subset_iff {P : Set (α × β)} : set.prod s t ⊆ P ↔ ∀ x ∈ s, ∀ y ∈ t, (x, y) ∈ P :=\n  ⟨fun h _ hx _ hy => h (mk_mem_prod hx hy), fun h ⟨_, _⟩ hp => h _ hp.1 _ hp.2⟩\n#align prod_subset_iff prod_subset_iff\n\n",
 "prod_subset_compl_diagonal_iff_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem prod_subset_compl_diagonal_iff_disjoint : set.prod s t ⊆ «expr ᶜ» (diagonal α) ↔ Disjoint s t :=\n  prod_subset_iff.trans disjoint_iff_forall_ne.symm\n#align prod_subset_compl_diagonal_iff_disjoint prod_subset_compl_diagonal_iff_disjoint\n\n",
 "prod_sub_preimage_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem prod_sub_preimage_iff {W : Set γ} {f : α × β → γ} :\n    set.prod s t ⊆ «expr ⁻¹' » f W ↔ ∀ a b, a ∈ s → b ∈ t → f (a, b) ∈ W := by simp [subset_def]\n#align prod_sub_preimage_iff prod_sub_preimage_iff\n\n",
 "prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem prod_singleton : set.prod s ({b} : Set β) = «expr '' » (fun a => (a, b)) s :=\n  by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n#align prod_singleton prod_singleton\n\n",
 "prod_self_subset_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_self_subset_prod_self : set.prod s₁ s₁ ⊆ set.prod s₂ s₂ ↔ s₁ ⊆ s₂ :=\n  ⟨fun h x hx => (h (mk_mem_prod hx hx)).1, fun h x hx => ⟨h hx.1, h hx.2⟩⟩\n#align prod_self_subset_prod_self prod_self_subset_prod_self\n\n",
 "prod_self_ssubset_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem prod_self_ssubset_prod_self : «expr ⊂ » (set.prod s₁ s₁) (set.prod s₂ s₂) ↔ «expr ⊂ » s₁ s₂ :=\n  and_congr prod_self_subset_prod_self <| not_congr prod_self_subset_prod_self\n#align prod_self_ssubset_prod_self prod_self_ssubset_prod_self\n\n",
 "prod_sdiff_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_sdiff_diagonal : set.prod s s \\ diagonal α = s.off_diag :=\n  ext fun _ => and_assoc\n#align prod_sdiff_diagonal prod_sdiff_diagonal\n\n",
 "prod_range_univ_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_range_univ_eq {m₁ : α → γ} : set.prod (range m₁) (univ : Set β) = range fun p : α × β => (m₁ p.1, p.2) :=\n  ext <| by simp [range]\n#align prod_range_univ_eq prod_range_univ_eq\n\n",
 "prod_range_range_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_range_range_eq {m₁ : α → γ} {m₂ : β → δ} :\n    set.prod (range m₁) (range m₂) = range fun p : α × β => (m₁ p.1, m₂ p.2) :=\n  ext <| by simp [range]\n#align prod_range_range_eq prod_range_range_eq\n\n",
 "prod_preimage_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_preimage_right {g : δ → β} :\n    set.prod s («expr ⁻¹' » g t) = «expr ⁻¹' » (fun p : α × δ => (p.1, g p.2)) (set.prod s t) :=\n  rfl\n#align prod_preimage_right prod_preimage_right\n\n",
 "prod_preimage_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_preimage_left {f : γ → α} :\n    set.prod («expr ⁻¹' » f s) t = «expr ⁻¹' » (fun p : γ × β => (f p.1, p.2)) (set.prod s t) :=\n  rfl\n#align prod_preimage_left prod_preimage_left\n\n",
 "prod_preimage_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_preimage_eq {f : γ → α} {g : δ → β} :\n    set.prod («expr ⁻¹' » f s) («expr ⁻¹' » g t) = «expr ⁻¹' » (fun p : γ × δ => (f p.1, g p.2)) (set.prod s t) :=\n  rfl\n#align prod_preimage_eq prod_preimage_eq\n\n",
 "prod_nonempty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_nonempty_iff : (set.prod s t).nonempty ↔ s.nonempty ∧ t.nonempty :=\n  ⟨fun h => ⟨h.fst, h.snd⟩, fun h => h.1.prod h.2⟩\n#align prod_nonempty_iff prod_nonempty_iff\n\n",
 "prod_mono_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_mono_right (ht : t₁ ⊆ t₂) : set.prod s t₁ ⊆ set.prod s t₂ :=\n  prod_mono Subset.rfl ht\n#align prod_mono_right prod_mono_right\n\n",
 "prod_mono_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_mono_left (hs : s₁ ⊆ s₂) : set.prod s₁ t ⊆ set.prod s₂ t :=\n  prod_mono hs Subset.rfl\n#align prod_mono_left prod_mono_left\n\n",
 "prod_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) : set.prod s₁ t₁ ⊆ set.prod s₂ t₂ := fun x ⟨h₁, h₂⟩ => ⟨hs h₁, ht h₂⟩\n#align prod_mono prod_mono\n\n",
 "prod_mk_mem_set_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_mk_mem_set_prod_eq : ((a, b) ∈ set.prod s t) = (a ∈ s ∧ b ∈ t) :=\n  rfl\n#align prod_mk_mem_set_prod_eq prod_mk_mem_set_prod_eq\n\n",
 "prod_inter_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_inter_prod : set.prod s₁ t₁ ∩ set.prod s₂ t₂ = set.prod (s₁ ∩ s₂) (t₁ ∩ t₂) :=\n  by\n  ext ⟨x, y⟩\n  simp [and_assoc', and_left_comm]\n#align prod_inter_prod prod_inter_prod\n\n",
 "prod_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_inter : set.prod s (t₁ ∩ t₂) = set.prod s t₁ ∩ set.prod s t₂ :=\n  by\n  ext ⟨x, y⟩\n  simp only [← and_and_left, mem_inter_iff, mem_prod]\n#align prod_inter prod_inter\n\n",
 "prod_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_insert : set.prod s (insert b t) = «expr '' » (fun a => (a, b)) s ∪ set.prod s t :=\n  by\n  ext ⟨x, y⟩\n  simp (config := { contextual := true }) [image, iff_def, or_imp, Imp.swap]\n#align prod_insert prod_insert\n\n",
 "prod_image_image_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_image_image_eq {m₁ : α → γ} {m₂ : β → δ} :\n    set.prod («expr '' » m₁ s) («expr '' » m₂ t) = «expr '' » (fun p : α × β => (m₁ p.1, m₂ p.2)) (set.prod s t) :=\n  ext <| by simp [-exists_and_right, exists_and_distrib_right.symm, and_left_comm, and_assoc, and_comm]\n#align prod_image_image_eq prod_image_image_eq\n\n",
 "prod_eq_prod_iff_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_eq_prod_iff_of_nonempty (h : (set.prod s t).nonempty) : set.prod s t = set.prod s₁ t₁ ↔ s = s₁ ∧ t = t₁ :=\n  by\n  constructor\n  · intro heq\n    have h₁ : (set.prod s₁ t₁ : Set _).nonempty := by rwa [← HEq]\n    rw [prod_nonempty_iff] at h h₁\n    rw [← fst_image_prod s h.2, ← fst_image_prod s₁ h₁.2, HEq, eq_self_iff_true, true_and_iff, ← snd_image_prod h.1 t, ←\n      snd_image_prod h₁.1 t₁, HEq]\n  · rintro ⟨rfl, rfl⟩\n    rfl\n#align prod_eq_prod_iff_of_nonempty prod_eq_prod_iff_of_nonempty\n\n",
 "prod_eq_prod_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_eq_prod_iff : set.prod s t = set.prod s₁ t₁ ↔ s = s₁ ∧ t = t₁ ∨ (s = ∅ ∨ t = ∅) ∧ (s₁ = ∅ ∨ t₁ = ∅) :=\n  by\n  symm\n  cases' eq_empty_or_nonempty (set.prod s t) with h h\n  · simp_rw [h, @eq_comm _ ∅, prod_eq_empty_iff, prod_eq_empty_iff.mp h, true_and_iff, or_iff_right_iff_imp]\n    rintro ⟨rfl, rfl⟩\n    exact prod_eq_empty_iff.mp h\n  rw [prod_eq_prod_iff_of_nonempty h]\n  rw [nonempty_iff_ne_empty, ne.def, prod_eq_empty_iff] at h\n  simp_rw [h, false_and_iff, or_false_iff]\n#align prod_eq_prod_iff prod_eq_prod_iff\n\n",
 "prod_eq_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_eq_iff_eq (ht : t.nonempty) : set.prod s t = set.prod s₁ t ↔ s = s₁ :=\n  by\n  simp_rw [prod_eq_prod_iff, ht.ne_empty, eq_self_iff_true, and_true_iff, or_iff_left_iff_imp, or_false_iff]\n  rintro ⟨rfl, rfl⟩\n  rfl\n#align prod_eq_iff_eq prod_eq_iff_eq\n\n",
 "prod_eq_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_eq_empty_iff : set.prod s t = ∅ ↔ s = ∅ ∨ t = ∅ := by\n  simp only [not_nonempty_iff_eq_empty.symm, prod_nonempty_iff, not_and_or]\n#align prod_eq_empty_iff prod_eq_empty_iff\n\n",
 "prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-\nCopyright (c) 2017 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Johannes Hölzl, Patrick Massot\n-/\n-- This notation binds more strongly than (pre)images, unions and intersections.\ntheorem prod_eq (s : Set α) (t : Set β) : set.prod s t = «expr ⁻¹' » Prod.fst s ∩ «expr ⁻¹' » Prod.snd t :=\n  rfl\n#align prod_eq prod_eq\n\n",
 "prod_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem prod_empty : set.prod s (∅ : Set β) = ∅ := by\n  ext\n  exact and_false_iff _\n#align prod_empty prod_empty\n\n",
 "prod_diff_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem prod_diff_prod : set.prod s t \\ set.prod s₁ t₁ = set.prod s (t \\ t₁) ∪ set.prod (s \\ s₁) t :=\n  by\n  ext x\n  by_cases h₁ : x.1 ∈ s₁ <;> by_cases h₂ : x.2 ∈ t₁ <;> simp [*]\n#align prod_diff_prod prod_diff_prod\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem nonempty.prod : s.nonempty → t.nonempty → (set.prod s t).nonempty := fun ⟨x, hx⟩ ⟨y, hy⟩ => ⟨(x, y), ⟨hx, hy⟩⟩\n#align nonempty.prod nonempty.prod\n\n",
 "preimage_swap_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem preimage_swap_prod (s : Set α) (t : Set β) : «expr ⁻¹' » Prod.swap (set.prod s t) = set.prod t s :=\n  by\n  ext ⟨x, y⟩\n  simp [and_comm']\n#align preimage_swap_prod preimage_swap_prod\n\n",
 "preimage_prod_map_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_prod_map_prod (f : α → β) (g : γ → δ) (s : Set β) (t : Set δ) :\n    «expr ⁻¹' » (prod.map f g) (set.prod s t) = set.prod («expr ⁻¹' » f s) («expr ⁻¹' » g t) :=\n  rfl\n#align preimage_prod_map_prod preimage_prod_map_prod\n\n",
 "preimage_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_pi (s : Set ι) (t : ∀ i, Set (β i)) (f : ∀ i, α i → β i) :\n    «expr ⁻¹' » (fun (g : ∀ i, α i) i => f _ (g i)) (s.pi t) = s.pi fun i => «expr ⁻¹' » (f i) (t i) :=\n  rfl\n#align preimage_pi preimage_pi\n\n",
 "preimage_coe_coe_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem preimage_coe_coe_diagonal (s : Set α) : «expr ⁻¹' » (prod.map coe coe) (diagonal α) = diagonal s :=\n  by\n  ext ⟨⟨x, hx⟩, ⟨y, hy⟩⟩\n  simp [Set.diagonal]\n#align preimage_coe_coe_diagonal preimage_coe_coe_diagonal\n\n",
 "pi_update_of_not_mem":
 "theorem pi_update_of_not_mem [DecidableEq ι] (hi : i ∉ s) (f : ∀ j, α j) (a : α i) (t : ∀ j, α j → Set (β j)) :\n    (s.pi fun j => t j (update f i a j)) = s.pi fun j => t j (f j) :=\n  pi_congr rfl fun j hj => by\n    rw [update_noteq]\n    exact fun h => hi (h ▸ hj)\n#align pi_update_of_not_mem pi_update_of_not_mem\n\n",
 "pi_update_of_mem":
 "theorem pi_update_of_mem [DecidableEq ι] (hi : i ∈ s) (f : ∀ j, α j) (a : α i) (t : ∀ j, α j → Set (β j)) :\n    (s.pi fun j => t j (update f i a j)) = { x | x i ∈ t i a } ∩ (s \\ {i}).pi fun j => t j (f j) :=\n  calc\n    (s.pi fun j => t j (update f i a j)) = ({i} ∪ s \\ {i}).pi fun j => t j (update f i a j) := by\n      rw [union_diff_self, union_eq_self_of_subset_left (singleton_subset_iff.2 hi)]\n    _ = { x | x i ∈ t i a } ∩ (s \\ {i}).pi fun j => t j (f j) :=\n      by\n      rw [union_pi, singleton_pi', update_same, pi_update_of_not_mem]\n      simp\n    \n#align pi_update_of_mem pi_update_of_mem\n\n",
 "pi_univ":
 "@[simp]\ntheorem pi_univ (s : Set ι) : (pi s fun i => (univ : Set (α i))) = univ :=\n  eq_univ_of_forall fun f i hi => mem_univ _\n#align pi_univ pi_univ\n\n",
 "pi_subset_pi_iff":
 "theorem pi_subset_pi_iff : pi s t₁ ⊆ pi s t₂ ↔ (∀ i ∈ s, t₁ i ⊆ t₂ i) ∨ pi s t₁ = ∅ :=\n  by\n  refine' ⟨fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm ▸ empty_subset _⟩\n  rw [← ne.def, ← nonempty_iff_ne_empty]\n  intro hne i hi\n  simpa only [eval_image_pi hi hne, eval_image_pi hi (hne.mono h)] using image_subset (fun f : ∀ i, α i => f i) h\n#align pi_subset_pi_iff pi_subset_pi_iff\n\n",
 "pi_nonempty_iff":
 "theorem pi_nonempty_iff : (s.pi t).nonempty ↔ ∀ i, ∃ x, i ∈ s → x ∈ t i := by simp [classical.skolem, Set.Nonempty]\n#align pi_nonempty_iff pi_nonempty_iff\n\n",
 "pi_mono":
 "theorem pi_mono (h : ∀ i ∈ s, t₁ i ⊆ t₂ i) : pi s t₁ ⊆ pi s t₂ := fun x hx i hi => h i hi <| hx i hi\n#align pi_mono pi_mono\n\n",
 "pi_inter_distrib":
 "theorem pi_inter_distrib : (s.pi fun i => t i ∩ t₁ i) = s.pi t ∩ s.pi t₁ :=\n  ext fun x => by simp only [forall_and, mem_pi, mem_inter_iff]\n#align pi_inter_distrib pi_inter_distrib\n\n",
 "pi_inter_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem pi_inter_compl (s : Set ι) : pi s t ∩ pi («expr ᶜ» s) t = pi univ t := by rw [← union_pi, union_compl_self]\n#align pi_inter_compl pi_inter_compl\n\n",
 "pi_if":
 "theorem pi_if {p : ι → Prop} [h : DecidablePred p] (s : Set ι) (t₁ t₂ : ∀ i, Set (α i)) :\n    (pi s fun i => if p i then t₁ i else t₂ i) = pi ({ i ∈ s | p i }) t₁ ∩ pi ({ i ∈ s | ¬p i }) t₂ :=\n  by\n  ext f\n  refine' ⟨fun h => _, _⟩\n  ·\n    constructor <;>\n      · rintro i ⟨his, hpi⟩\n        simpa [*] using h i\n  · rintro ⟨ht₁, ht₂⟩ i his\n    by_cases p i <;> simp_all\n#align pi_if pi_if\n\n",
 "pi_eq_empty_iff":
 "theorem pi_eq_empty_iff : s.pi t = ∅ ↔ ∃ i, IsEmpty (α i) ∨ i ∈ s ∧ t i = ∅ :=\n  by\n  rw [← not_nonempty_iff_eq_empty, pi_nonempty_iff]\n  push_neg\n  refine' exists_congr fun i => _\n  cases isEmpty_or_nonempty (α i) <;> simp [*, forall_and, eq_empty_iff_forall_not_mem]\n#align pi_eq_empty_iff pi_eq_empty_iff\n\n",
 "pi_eq_empty":
 "theorem pi_eq_empty (hs : i ∈ s) (ht : t i = ∅) : s.pi t = ∅ :=\n  by\n  ext f\n  simp only [mem_empty_iff_false, not_forall, iff_false_iff, mem_pi, not_imp]\n  exact ⟨i, hs, by simp [ht]⟩\n#align pi_eq_empty pi_eq_empty\n\n",
 "pi_congr":
 "#print pi_congr /-\ntheorem pi_congr (h : s₁ = s₂) (h' : ∀ i ∈ s₁, t₁ i = t₂ i) : s₁.pi t₁ = s₂.pi t₂ :=\n  h ▸ ext fun x => forall₂_congr fun i hi => h' i hi ▸ iff.rfl\n#align pi_congr pi_congr\n-/\n\n",
 "off_diag_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem off_diag_univ : (univ : Set α).off_diag = «expr ᶜ» (diagonal α) :=\n  ext <| by simp\n#align off_diag_univ off_diag_univ\n\n",
 "off_diag_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem off_diag_union (h : Disjoint s t) : (s ∪ t).off_diag = s.off_diag ∪ t.off_diag ∪ set.prod s t ∪ set.prod t s :=\n  by\n  rw [off_diag_eq_sep_prod, union_prod, prod_union, prod_union, union_comm _ (set.prod t t), union_assoc,\n    union_left_comm (set.prod s t), ← union_assoc, sep_union, sep_union, ← off_diag_eq_sep_prod, ← off_diag_eq_sep_prod,\n    sep_eq_self_iff_mem_true.2, ← union_assoc]\n  simp only [mem_union, mem_prod, ne.def, Prod.forall]\n  rintro i j (⟨hi, hj⟩ | ⟨hi, hj⟩) rfl <;> exact h.le_bot ⟨‹_›, ‹_›⟩\n#align off_diag_union off_diag_union\n\n",
 "off_diag_subset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem off_diag_subset_prod : s.off_diag ⊆ set.prod s s := fun x hx => ⟨hx.1, hx.2.1⟩\n#align off_diag_subset_prod off_diag_subset_prod\n\n",
 "off_diag_singleton":
 "@[simp]\ntheorem off_diag_singleton (a : α) : ({a} : Set α).off_diag = ∅ := by simp\n#align off_diag_singleton off_diag_singleton\n\n",
 "off_diag_nonempty":
 "@[simp]\ntheorem off_diag_nonempty : s.off_diag.nonempty ↔ s.nontrivial := by simp [off_diag, Set.Nonempty, Set.Nontrivial]\n#align off_diag_nonempty off_diag_nonempty\n\n",
 "off_diag_mono":
 "theorem off_diag_mono : Monotone (offDiag : Set α → Set (α × α)) := fun s t h x =>\n  and.imp (@h _) <| And.imp_left <| @h _\n#align off_diag_mono off_diag_mono\n\n",
 "off_diag_inter":
 "theorem off_diag_inter : (s ∩ t).off_diag = s.off_diag ∩ t.off_diag :=\n  ext fun x => by\n    simp only [mem_off_diag, mem_inter_iff]\n    tauto\n#align off_diag_inter off_diag_inter\n\n",
 "off_diag_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem off_diag_insert (ha : a ∉ s) : (insert a s).off_diag = s.off_diag ∪ set.prod {a} s ∪ set.prod s {a} :=\n  by\n  rw [insert_eq, union_comm, off_diag_union, off_diag_singleton, union_empty, union_right_comm]\n  rw [disjoint_left]\n  rintro b hb (rfl : b = a)\n  exact ha hb\n#align off_diag_insert off_diag_insert\n\n",
 "off_diag_eq_sep_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem off_diag_eq_sep_prod : s.off_diag = { x ∈ set.prod s s | x.1 ≠ x.2 } :=\n  ext fun _ => and_assoc.symm\n#align off_diag_eq_sep_prod off_diag_eq_sep_prod\n\n",
 "off_diag_eq_empty":
 "@[simp]\ntheorem off_diag_eq_empty : s.off_diag = ∅ ↔ s.subsingleton := by\n  rw [← not_nonempty_iff_eq_empty, ← not_nontrivial_iff, off_diag_nonempty.not]\n#align off_diag_eq_empty off_diag_eq_empty\n\n",
 "off_diag_empty":
 "@[simp]\ntheorem off_diag_empty : (∅ : Set α).off_diag = ∅ := by simp\n#align off_diag_empty off_diag_empty\n\n",
 "mk_preimage_prod_right_fn_eq_if":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mk_preimage_prod_right_fn_eq_if [DecidablePred (· ∈ s)] (g : δ → β) :\n    «expr ⁻¹' » (fun b => (a, g b)) (set.prod s t) = if a ∈ s then «expr ⁻¹' » g t else ∅ := by\n  rw [← mk_preimage_prod_right_eq_if, prod_preimage_right, preimage_preimage]\n#align mk_preimage_prod_right_fn_eq_if mk_preimage_prod_right_fn_eq_if\n\n",
 "mk_preimage_prod_right_eq_if":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem mk_preimage_prod_right_eq_if [DecidablePred (· ∈ s)] :\n    «expr ⁻¹' » (prod.mk a) (set.prod s t) = if a ∈ s then t else ∅ := by split_ifs <;> simp [h]\n#align mk_preimage_prod_right_eq_if mk_preimage_prod_right_eq_if\n\n",
 "mk_preimage_prod_right_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem mk_preimage_prod_right_eq_empty (ha : a ∉ s) : «expr ⁻¹' » (prod.mk a) (set.prod s t) = ∅ :=\n  by\n  ext b\n  simp [ha]\n#align mk_preimage_prod_right_eq_empty mk_preimage_prod_right_eq_empty\n\n",
 "mk_preimage_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem mk_preimage_prod_right (ha : a ∈ s) : «expr ⁻¹' » (prod.mk a) (set.prod s t) = t :=\n  by\n  ext b\n  simp [ha]\n#align mk_preimage_prod_right mk_preimage_prod_right\n\n",
 "mk_preimage_prod_left_fn_eq_if":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mk_preimage_prod_left_fn_eq_if [DecidablePred (· ∈ t)] (f : γ → α) :\n    «expr ⁻¹' » (fun a => (f a, b)) (set.prod s t) = if b ∈ t then «expr ⁻¹' » f s else ∅ := by\n  rw [← mk_preimage_prod_left_eq_if, prod_preimage_left, preimage_preimage]\n#align mk_preimage_prod_left_fn_eq_if mk_preimage_prod_left_fn_eq_if\n\n",
 "mk_preimage_prod_left_eq_if":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem mk_preimage_prod_left_eq_if [DecidablePred (· ∈ t)] :\n    «expr ⁻¹' » (fun a => (a, b)) (set.prod s t) = if b ∈ t then s else ∅ := by split_ifs <;> simp [h]\n#align mk_preimage_prod_left_eq_if mk_preimage_prod_left_eq_if\n\n",
 "mk_preimage_prod_left_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem mk_preimage_prod_left_eq_empty (hb : b ∉ t) : «expr ⁻¹' » (fun a => (a, b)) (set.prod s t) = ∅ :=\n  by\n  ext a\n  simp [hb]\n#align mk_preimage_prod_left_eq_empty mk_preimage_prod_left_eq_empty\n\n",
 "mk_preimage_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem mk_preimage_prod_left (hb : b ∈ t) : «expr ⁻¹' » (fun a => (a, b)) (set.prod s t) = s :=\n  by\n  ext a\n  simp [hb]\n#align mk_preimage_prod_left mk_preimage_prod_left\n\n",
 "mk_preimage_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem mk_preimage_prod (f : γ → α) (g : γ → β) :\n    «expr ⁻¹' » (fun x => (f x, g x)) (set.prod s t) = «expr ⁻¹' » f s ∩ «expr ⁻¹' » g t :=\n  rfl\n#align mk_preimage_prod mk_preimage_prod\n\n",
 "mk_mem_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem mk_mem_prod (ha : a ∈ s) (hb : b ∈ t) : (a, b) ∈ set.prod s t :=\n  ⟨ha, hb⟩\n#align mk_mem_prod mk_mem_prod\n\n",
 "mem_univ_pi":
 "@[simp]\ntheorem mem_univ_pi {f : ∀ i, α i} : f ∈ pi univ t ↔ ∀ i, f i ∈ t i := by simp\n#align mem_univ_pi mem_univ_pi\n\n",
 "mem_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem mem_prod_eq {p : α × β} : (p ∈ set.prod s t) = (p.1 ∈ s ∧ p.2 ∈ t) :=\n  rfl\n#align mem_prod_eq mem_prod_eq\n\n",
 "mem_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem mem_prod {p : α × β} : p ∈ set.prod s t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  iff.rfl\n#align mem_prod mem_prod\n\n",
 "mem_pi":
 "@[simp]\ntheorem mem_pi {f : ∀ i, α i} : f ∈ s.pi t ↔ ∀ i ∈ s, f i ∈ t i :=\n  iff.rfl\n#align mem_pi mem_pi\n\n",
 "mem_off_diag":
 "@[simp]\ntheorem mem_off_diag : x ∈ s.off_diag ↔ x.1 ∈ s ∧ x.2 ∈ s ∧ x.1 ≠ x.2 :=\n  iff.rfl\n#align mem_off_diag mem_off_diag\n\n",
 "mem_diagonal_iff":
 "@[simp]\ntheorem mem_diagonal_iff {x : α × α} : x ∈ diagonal α ↔ x.1 = x.2 :=\n  iff.rfl\n#align mem_diagonal_iff mem_diagonal_iff\n\n",
 "mem_diagonal":
 "theorem mem_diagonal (x : α) : (x, x) ∈ diagonal α := by simp [diagonal]\n#align mem_diagonal mem_diagonal\n\n",
 "inter_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem inter_prod : set.prod (s₁ ∩ s₂) t = set.prod s₁ t ∩ set.prod s₂ t :=\n  by\n  ext ⟨x, y⟩\n  simp only [← and_and_right, mem_inter_iff, mem_prod]\n#align inter_prod inter_prod\n\n",
 "insert_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem insert_prod : set.prod (insert a s) t = «expr '' » (prod.mk a) t ∪ set.prod s t :=\n  by\n  ext ⟨x, y⟩\n  simp (config := { contextual := true }) [image, iff_def, or_imp, Imp.swap]\n#align insert_prod insert_prod\n\n",
 "insert_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem insert_pi (i : ι) (s : Set ι) (t : ∀ i, Set (α i)) : pi (insert i s) t = «expr ⁻¹' » (eval i) (t i) ∩ pi s t :=\n  by\n  ext\n  simp [pi, or_imp, forall_and]\n#align insert_pi insert_pi\n\n",
 "image_swap_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem image_swap_prod (s : Set α) (t : Set β) : «expr '' » Prod.swap (set.prod s t) = set.prod t s := by\n  rw [image_swap_eq_preimage_swap, preimage_swap_prod]\n#align image_swap_prod image_swap_prod\n\n",
 "image_prod_mk_subset_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem image_prod_mk_subset_prod_right (ha : a ∈ s) : «expr '' » (prod.mk a) t ⊆ set.prod s t :=\n  by\n  rintro _ ⟨b, hb, rfl⟩\n  exact ⟨ha, hb⟩\n#align image_prod_mk_subset_prod_right image_prod_mk_subset_prod_right\n\n",
 "image_prod_mk_subset_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem image_prod_mk_subset_prod_left (hb : b ∈ t) : «expr '' » (fun a => (a, b)) s ⊆ set.prod s t :=\n  by\n  rintro _ ⟨a, ha, rfl⟩\n  exact ⟨ha, hb⟩\n#align image_prod_mk_subset_prod_left image_prod_mk_subset_prod_left\n\n",
 "image_prod_mk_subset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem image_prod_mk_subset_prod {f : α → β} {g : α → γ} {s : Set α} :\n    «expr '' » (fun x => (f x, g x)) s ⊆ set.prod («expr '' » f s) («expr '' » g s) :=\n  by\n  rintro _ ⟨x, hx, rfl⟩\n  exact mk_mem_prod (mem_image_of_mem f hx) (mem_image_of_mem g hx)\n#align image_prod_mk_subset_prod image_prod_mk_subset_prod\n\n",
 "fst_image_prod_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem fst_image_prod_subset (s : Set α) (t : Set β) : «expr '' » Prod.fst (set.prod s t) ⊆ s :=\n  image_subset_iff.2 <| prod_subset_preimage_fst s t\n#align fst_image_prod_subset fst_image_prod_subset\n\n",
 "fst_image_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem fst_image_prod (s : Set β) {t : Set α} (ht : t.nonempty) : «expr '' » Prod.fst (set.prod s t) = s :=\n  (fst_image_prod_subset _ _).antisymm fun y hy =>\n    let ⟨x, hx⟩ := ht\n    ⟨(y, x), ⟨hy, hx⟩, rfl⟩\n#align fst_image_prod fst_image_prod\n\n",
 "fst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem nonempty.fst : (set.prod s t).nonempty → s.nonempty := fun ⟨x, hx⟩ => ⟨x.1, hx.1⟩\n#align nonempty.fst nonempty.fst\n\n",
 "forall_prod_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem forall_prod_set {p : α × β → Prop} : (∀ x ∈ set.prod s t, p x) ↔ ∀ x ∈ s, ∀ y ∈ t, p (x, y) :=\n  prod_subset_iff\n#align forall_prod_set forall_prod_set\n\n",
 "exists_prod_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem exists_prod_set {p : α × β → Prop} : (∃ x ∈ set.prod s t, p x) ↔ ∃ x ∈ s, ∃ y ∈ t, p (x, y) := by\n  simp [and_assoc']\n#align exists_prod_set exists_prod_set\n\n",
 "eval_preimage'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem eval_preimage' [DecidableEq ι] {s : Set (α i)} : «expr ⁻¹' » (eval i) s = pi {i} (update (fun i => univ) i s) :=\n  by\n  ext\n  simp\n#align eval_preimage' eval_preimage'\n\n",
 "eval_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem eval_preimage [DecidableEq ι] {s : Set (α i)} : «expr ⁻¹' » (eval i) s = pi univ (update (fun i => univ) i s) :=\n  by\n  ext x\n  simp [@forall_update_iff _ (fun i => Set (α i)) _ _ _ _ fun i' y => x i' ∈ y]\n#align eval_preimage eval_preimage\n\n",
 "eval_image_univ_pi_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem eval_image_univ_pi_subset : «expr '' » (eval i) (pi univ t) ⊆ t i :=\n  eval_image_pi_subset (mem_univ i)\n#align eval_image_univ_pi_subset eval_image_univ_pi_subset\n\n",
 "eval_image_univ_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem eval_image_univ_pi (ht : (pi univ t).nonempty) : «expr '' » (fun f : ∀ i, α i => f i) (pi univ t) = t i :=\n  eval_image_pi (mem_univ i) ht\n#align eval_image_univ_pi eval_image_univ_pi\n\n",
 "eval_image_pi_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem eval_image_pi_subset (hs : i ∈ s) : «expr '' » (eval i) (s.pi t) ⊆ t i :=\n  image_subset_iff.2 fun f hf => hf i hs\n#align eval_image_pi_subset eval_image_pi_subset\n\n",
 "eval_image_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem eval_image_pi (hs : i ∈ s) (ht : (s.pi t).nonempty) : «expr '' » (eval i) (s.pi t) = t i :=\n  (eval_image_pi_subset hs).antisymm (subset_eval_image_pi ht i)\n#align eval_image_pi eval_image_pi\n\n",
 "empty_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem empty_prod : set.prod (∅ : Set α) t = ∅ := by\n  ext\n  exact false_and_iff _\n#align empty_prod empty_prod\n\n",
 "empty_pi":
 "@[simp]\ntheorem empty_pi (s : ∀ i, Set (α i)) : pi ∅ s = univ := by\n  ext\n  simp [pi]\n#align empty_pi empty_pi\n\n",
 "disjoint_univ_pi":
 "@[simp]\ntheorem disjoint_univ_pi : Disjoint (pi univ t₁) (pi univ t₂) ↔ ∃ i, Disjoint (t₁ i) (t₂ i) := by\n  simp only [disjoint_iff_inter_eq_empty, ← pi_inter_distrib, univ_pi_eq_empty_iff]\n#align disjoint_univ_pi disjoint_univ_pi\n\n",
 "disjoint_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem disjoint_prod : Disjoint (set.prod s₁ t₁) (set.prod s₂ t₂) ↔ Disjoint s₁ s₂ ∨ Disjoint t₁ t₂ := by\n  simp_rw [disjoint_left, mem_prod, not_and_or, Prod.forall, and_imp, ← @forall_or_right α, ← @forall_or_left β, ←\n    @forall_or_right (_ ∈ s₁), ← @forall_or_left (_ ∈ t₁)]\n#align disjoint_prod disjoint_prod\n\n",
 "disjoint_diagonal_off_diag":
 "@[simp]\ntheorem disjoint_diagonal_off_diag : Disjoint (diagonal α) s.off_diag :=\n  disjoint_left.mpr fun x hd ho => ho.2.2 hd\n#align disjoint_diagonal_off_diag disjoint_diagonal_off_diag\n\n",
 "diagonal_subset_iff":
 "theorem diagonal_subset_iff {s} : diagonal α ⊆ s ↔ ∀ x, (x, x) ∈ s := by rw [← range_diag, range_subset_iff]\n#align diagonal_subset_iff diagonal_subset_iff\n\n",
 "diagonal_nonempty":
 "theorem diagonal_nonempty [Nonempty α] : (diagonal α).nonempty :=\n  Nonempty.elim ‹_› fun x => ⟨_, mem_diagonal x⟩\n#align diagonal_nonempty diagonal_nonempty\n\n",
 "diag_preimage_prod_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem diag_preimage_prod_self (s : Set α) : «expr ⁻¹' » (fun x => (x, x)) (set.prod s s) = s :=\n  inter_self s\n#align diag_preimage_prod_self diag_preimage_prod_self\n\n",
 "diag_preimage_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem diag_preimage_prod (s t : Set α) : «expr ⁻¹' » (fun x => (x, x)) (set.prod s t) = s ∩ t :=\n  rfl\n#align diag_preimage_prod diag_preimage_prod\n\n",
 "diag_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem diag_image (s : Set α) : «expr '' » (fun x => (x, x)) s = diagonal α ∩ set.prod s s :=\n  by\n  ext x; constructor\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨rfl, hx, hx⟩\n  · obtain ⟨x, y⟩ := x\n    rintro ⟨rfl : x = y, h2x⟩\n    exact mem_image_of_mem _ h2x.1\n#align diag_image diag_image\n\n"}