{"univ_finite_iff_nonempty_fintype":
 "theorem univ_finite_iff_nonempty_fintype : (univ : set α).finite ↔ nonempty (fintype α) :=\n  ⟨fun h => ⟨fintype_of_finite_univ h⟩, fun ⟨_i⟩ => finite_univ⟩\n#align univ_finite_iff_nonempty_fintype univ_finite_iff_nonempty_fintype\n\n",
 "union_finset_finite_of_range_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of finsets is finite. -/\ntheorem union_finset_finite_of_range_finite (f : α → Finset β) (h : (range f).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (f a : set β)).finite :=\n  by\n  rw [← bUnion_range]\n  exact h.bUnion fun y hy => y.finite_to_set\n#align union_finset_finite_of_range_finite union_finset_finite_of_range_finite\n\n",
 "union":
 "theorem finite.union {s t : set α} (hs : s.finite) (ht : t.finite) : (s ∪ t).finite :=\n  by\n  cases hs\n  cases ht\n  apply to_finite\n#align finite.union finite.union\n\n",
 "to_subtype":
 "/-- Projection of `set.finite` to its `finite` instance.\nThis is intended to be used with dot notation.\nSee also `set.finite.fintype` and `set.finite.nonempty_fintype`. -/\nprotected theorem finite.to_subtype {s : set α} (h : s.finite) : Finite s :=\n  finite_coe_iff.mpr h\n#align finite.to_subtype finite.to_subtype\n\n",
 "to_finset_univ":
 "-- Note: Not `simp` because `set.finite.to_finset_set_of` already proves it\n@[simp]\nprotected theorem to_finset_univ [fintype α] (h : (Set.univ : set α).finite) : h.to_finset = finset.univ :=\n  by\n  ext\n  simp\n#align to_finset_univ to_finset_univ\n\n",
 "to_finset_union":
 "protected theorem to_finset_union [decidable_eq α] (hs : s.finite) (ht : t.finite) (h : (s ∪ t).finite) :\n    h.to_finset = hs.to_finset ∪ ht.to_finset := by\n  ext\n  simp\n#align to_finset_union to_finset_union\n\n",
 "to_finset_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\nprotected theorem to_finset_symm_diff [decidable_eq α] (hs : s.finite) (ht : t.finite) (h : («expr ∆ » s t).finite) :\n    h.to_finset = «expr ∆ » hs.to_finset ht.to_finset := by\n  ext\n  simp [mem_symm_diff, Finset.mem_symmDiff]\n#align to_finset_symm_diff to_finset_symm_diff\n\n",
 "to_finset_subset_to_finset":
 "@[mono]\nprotected theorem to_finset_subset_to_finset : hs.to_finset ⊆ ht.to_finset ↔ s ⊆ t := by\n  simp only [← Finset.coe_subset, finite.coe_to_finset]\n#align to_finset_subset_to_finset to_finset_subset_to_finset\n\n",
 "to_finset_subset":
 "@[simp]\ntheorem to_finset_subset {t : Finset α} : hs.to_finset ⊆ t ↔ s ⊆ t := by rw [← Finset.coe_subset, finite.coe_to_finset]\n#align to_finset_subset to_finset_subset\n\n",
 "to_finset_ssubset_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[mono]\nprotected theorem to_finset_ssubset_to_finset : «expr ⊂ » hs.to_finset ht.to_finset ↔ «expr ⊂ » s t := by\n  simp only [← Finset.coe_ssubset, finite.coe_to_finset]\n#align to_finset_ssubset_to_finset to_finset_ssubset_to_finset\n\n",
 "to_finset_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem to_finset_ssubset {t : Finset α} : «expr ⊂ » hs.to_finset t ↔ «expr ⊂ » s t := by\n  rw [← Finset.coe_ssubset, finite.coe_to_finset]\n#align to_finset_ssubset to_finset_ssubset\n\n",
 "to_finset_singleton":
 "@[simp]\ntheorem finite.to_finset_singleton {a : α} (ha : ({a} : set α).finite := finite_singleton _) : ha.to_finset = {a} :=\n  Finset.ext <| by simp\n#align finite.to_finset_singleton finite.to_finset_singleton\n\n",
 "to_finset_set_of":
 "@[simp]\nprotected theorem to_finset_set_of [fintype α] (p : α → Prop) [decidable_pred p] (h : { x | p x }.finite) :\n    h.to_finset = finset.univ.filter p := by\n  ext\n  simp\n#align to_finset_set_of to_finset_set_of\n\n",
 "to_finset_range":
 "@[simp]\nprotected theorem to_finset_range [decidable_eq α] [fintype β] (f : β → α) (h : (range f).finite) :\n    h.to_finset = finset.univ.image f := by\n  ext\n  simp\n#align to_finset_range to_finset_range\n\n",
 "to_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem finite.to_finset_prod {s : set α} {t : set β} (hs : s.finite) (ht : t.finite) :\n    finset.product hs.to_finset ht.to_finset = (hs.prod ht).to_finset :=\n  Finset.ext <| by simp\n#align finite.to_finset_prod finite.to_finset_prod\n\n",
 "to_finset_off_diag":
 "theorem finite.to_finset_off_diag {s : set α} [decidable_eq α] (hs : s.finite) :\n    hs.off_diag.to_finset = hs.to_finset.off_diag :=\n  Finset.ext <| by simp\n#align finite.to_finset_off_diag finite.to_finset_off_diag\n\n",
 "to_finset_nonempty":
 "@[simp]\nprotected theorem to_finset_nonempty (h : s.finite) : h.to_finset.nonempty ↔ s.nonempty := by\n  rw [← Finset.coe_nonempty, finite.coe_to_finset]\n#align to_finset_nonempty to_finset_nonempty\n\n",
 "to_finset_inter":
 "protected theorem to_finset_inter [decidable_eq α] (hs : s.finite) (ht : t.finite) (h : (s ∩ t).finite) :\n    h.to_finset = hs.to_finset ∩ ht.to_finset := by\n  ext\n  simp\n#align to_finset_inter to_finset_inter\n\n",
 "to_finset_insert'":
 "theorem finite.to_finset_insert' [decidable_eq α] {a : α} {s : set α} (hs : s.finite) :\n    (hs.insert a).to_finset = insert a hs.to_finset :=\n  finite.to_finset_insert _\n#align finite.to_finset_insert' finite.to_finset_insert'\n\n",
 "to_finset_insert":
 "@[simp]\ntheorem finite.to_finset_insert [decidable_eq α] {s : set α} {a : α} (hs : (insert a s).finite) :\n    hs.to_finset = insert a (hs.subset <| subset_insert _ _).to_finset :=\n  Finset.ext <| by simp\n#align finite.to_finset_insert finite.to_finset_insert\n\n",
 "to_finset_inj":
 "@[simp]\nprotected theorem to_finset_inj : hs.to_finset = ht.to_finset ↔ s = t :=\n  @to_finset_inj _ _ _ hs.fintype ht.fintype\n#align to_finset_inj to_finset_inj\n\n",
 "to_finset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprotected theorem to_finset_image [decidable_eq β] (f : α → β) (hs : s.finite) (h : («expr '' » f s).finite) :\n    h.to_finset = hs.to_finset.image f := by\n  ext\n  simp\n#align to_finset_image to_finset_image\n\n",
 "to_finset_eq_univ":
 "@[simp]\nprotected theorem to_finset_eq_univ [fintype α] {h : s.finite} : h.to_finset = finset.univ ↔ s = univ :=\n  @to_finset_eq_univ _ _ _ h.fintype\n#align to_finset_eq_univ to_finset_eq_univ\n\n",
 "to_finset_eq_empty":
 "@[simp]\nprotected theorem to_finset_eq_empty {h : s.finite} : h.to_finset = ∅ ↔ s = ∅ :=\n  @to_finset_eq_empty _ _ h.fintype\n#align to_finset_eq_empty to_finset_eq_empty\n\n",
 "to_finset_empty":
 "@[simp]\nprotected theorem to_finset_empty (h : (∅ : set α).finite) : h.to_finset = ∅ :=\n  by\n  ext\n  simp\n#align to_finset_empty to_finset_empty\n\n",
 "to_finset_diff":
 "protected theorem to_finset_diff [decidable_eq α] (hs : s.finite) (ht : t.finite) (h : (s \\ t).finite) :\n    h.to_finset = hs.to_finset \\ ht.to_finset := by\n  ext\n  simp\n#align to_finset_diff to_finset_diff\n\n",
 "to_finset_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\nprotected theorem to_finset_compl [decidable_eq α] [fintype α] (hs : s.finite) (h : («expr ᶜ» s).finite) :\n    h.to_finset = «expr ᶜ» hs.to_finset := by\n  ext\n  simp\n#align to_finset_compl to_finset_compl\n\n",
 "to_finite":
 "/-- Constructor for `set.finite` using a `finite` instance. -/\ntheorem to_finite (s : set α) [Finite s] : s.finite :=\n  finite_coe_iff.mp ‹_›\n#align to_finite to_finite\n\n",
 "supr_infi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem _root_.supr_infi_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Frame α] {f : ι → ι' → α} (hf : ∀ i, monotone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  by simpa only [infᵢ_univ] using finite_univ.supr_binfi_of_monotone fun i hi => hf i\n#align supr_infi_of_monotone supr_infi_of_monotone\n\n",
 "supr_infi_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem _root_.supr_infi_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Frame α] {f : ι → ι' → α} (hf : ∀ i, antitone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  @supr_infi_of_monotone ι («expr ᵒᵈ» ι') α _ _ _ _ _ _ fun i => (hf i).dual_left\n#align supr_infi_of_antitone supr_infi_of_antitone\n\n",
 "supr_binfi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem finite.supr_binfi_of_monotone {ι ι' α : Type _} [preorder ι'] [nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Frame α] {s : set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, monotone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  by\n  revert hf\n  refine' hs.induction_on _ _\n  · intro hf\n    simp [supᵢ_const]\n  · intro a s has hs ihs hf\n    rw [ball_insert_iff] at hf\n    simp only [infᵢ_insert, ← ihs hf.2]\n    exact supᵢ_inf_of_monotone hf.1 fun j₁ j₂ hj => infᵢ₂_mono fun i hi => hf.2 i hi hj\n#align finite.supr_binfi_of_monotone finite.supr_binfi_of_monotone\n\n",
 "supr_binfi_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem finite.supr_binfi_of_antitone {ι ι' α : Type _} [preorder ι'] [nonempty ι'] [IsDirected ι' (swap (· ≤ ·))]\n    [Order.Frame α] {s : set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, antitone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  @finite.supr_binfi_of_monotone ι («expr ᵒᵈ» ι') α _ _ _ _ _ hs _ fun i hi => (hf i hi).dual_left\n#align finite.supr_binfi_of_antitone finite.supr_binfi_of_antitone\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem finite.sup {s t : set α} : s.finite → t.finite → («expr ⊔ » s t).finite :=\n  finite.union\n#align finite.sup finite.sup\n\n",
 "subset_to_finset":
 "@[simp]\ntheorem subset_to_finset {s : Finset α} : s ⊆ ht.to_finset ↔ ↑s ⊆ t := by rw [← Finset.coe_subset, finite.coe_to_finset]\n#align subset_to_finset subset_to_finset\n\n",
 "subset":
 "theorem finite.subset {s : set α} (hs : s.finite) {t : set α} (ht : t ⊆ s) : t.finite :=\n  by\n  cases hs\n  haveI := finite.set.subset _ ht\n  apply to_finite\n#align finite.subset finite.subset\n\n",
 "ssubset_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem ssubset_to_finset {s : Finset α} : «expr ⊂ » s ht.to_finset ↔ «expr ⊂ » (↑s) t := by\n  rw [← Finset.coe_ssubset, finite.coe_to_finset]\n#align ssubset_to_finset ssubset_to_finset\n\n",
 "seq_of_forall_finite_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `P` is some relation between terms of `γ` and sets in `γ`,\nsuch that every finite set `t : set γ` has some `c : γ` related to it,\nthen there is a recursively defined sequence `u` in `γ`\nso `u n` is related to the image of `{0, 1, ..., n-1}` under `u`.\n\n(We use this later to show sequentially compact sets\nare totally bounded.)\n-/\ntheorem seq_of_forall_finite_exists {γ : Type _} {P : γ → set γ → Prop} (h : ∀ t : set γ, t.finite → ∃ c, P c t) :\n    ∃ u : ℕ → γ, ∀ n, P (u n) («expr '' » u (Iio n)) :=\n  ⟨fun n =>\n    @Nat.strongRecOn' (fun _ => γ) n fun n ih =>\n      Classical.choose <| h (range fun m : Iio n => ih m.1 m.2) (finite_range _),\n    fun n => by\n    classical\n      refine' Nat.strongRecOn' n fun n ih => _\n      rw [Nat.strongRecOn'_beta]\n      convert Classical.choose_spec (h _ _)\n      ext x\n      constructor\n      · rintro ⟨m, hmn, rfl⟩\n        exact ⟨⟨m, hmn⟩, rfl⟩\n      · rintro ⟨⟨m, hmn⟩, rfl⟩\n        exact ⟨m, hmn, rfl⟩⟩\n#align seq_of_forall_finite_exists seq_of_forall_finite_exists\n\n",
 "seq'":
 "theorem finite.seq' {α β : Type u} {f : set (α → β)} {s : set α} (hf : f.finite) (hs : s.finite) : (f <*> s).finite :=\n  hf.seq hs\n#align finite.seq' finite.seq'\n\n",
 "seq":
 "theorem finite.seq {f : set (α → β)} {s : set α} (hf : f.finite) (hs : s.finite) : (f.seq s).finite := by\n  classical\n    cases hf\n    cases hs\n    apply to_finite\n#align finite.seq finite.seq\n\n",
 "sep":
 "theorem finite.sep {s : set α} (hs : s.finite) (p : α → Prop) : { a ∈ s | p a }.finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.sep finite.sep\n\n",
 "sUnion":
 "theorem finite.sUnion {s : set (set α)} (hs : s.finite) (H : ∀ t ∈ s, set.finite t) : (⋃₀ s).finite :=\n  by\n  cases hs\n  haveI := fun i : s => (H i i.2).to_subtype\n  apply to_finite\n#align finite.sUnion finite.sUnion\n\n",
 "sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem finite.sInter {α : Type _} {s : set (set α)} {t : set α} (ht : t ∈ s) (hf : t.finite) : («expr⋂₀ » s).finite :=\n  hf.subset (interₛ_subset_of_mem ht)\n#align finite.sInter finite.sInter\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem finite.prod {s : set α} {t : set β} (hs : s.finite) (ht : t.finite) :\n    (finset.product s t : set (α × β)).finite := by\n  cases hs\n  cases ht\n  apply to_finite\n#align finite.prod finite.prod\n\n",
 "preimage_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite.preimage_embedding {s : set β} (f : «expr ↪ » α β) (h : s.finite) : («expr ⁻¹' » f s).finite :=\n  h.preimage fun _ _ _ _ h' => f.injective h'\n#align finite.preimage_embedding finite.preimage_embedding\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite.preimage {s : set β} {f : α → β} (I : Set.InjOn f («expr ⁻¹' » f s)) (h : s.finite) :\n    («expr ⁻¹' » f s).finite :=\n  (h.subset (image_preimage_subset f s)).of_finite_image I\n#align finite.preimage finite.preimage\n\n",
 "pi":
 "/-- Finite product of finite sets is finite -/\ntheorem finite.pi {δ : Type _} [Finite δ] {κ : δ → Type _} {t : ∀ d, set (κ d)} (ht : ∀ d, (t d).finite) :\n    (pi univ t).finite := by\n  cases nonempty_fintype δ\n  lift t to ∀ d, Finset (κ d) using ht\n  classical\n    rw [← fintype.coe_pi_finset]\n    apply finset.finite_to_set\n#align finite.pi finite.pi\n\n",
 "off_diag":
 "theorem finite.off_diag {s : set α} (hs : s.finite) : s.off_diag.finite := by\n  classical\n    cases hs\n    apply set.to_finite\n#align finite.off_diag finite.off_diag\n\n",
 "of_subsingleton":
 "@[nontriviality]\ntheorem finite.of_subsingleton [subsingleton α] (s : set α) : s.finite :=\n  s.to_finite\n#align finite.of_subsingleton finite.of_subsingleton\n\n",
 "of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite.of_preimage {f : α → β} {s : set β} (h : («expr ⁻¹' » f s).finite) (hf : surjective f) : s.finite :=\n  hf.image_preimage s ▸ h.image _\n#align finite.of_preimage finite.of_preimage\n\n",
 "of_finset":
 "/-- Construct a `finite` instance for a `set` from a `finset` with the same elements. -/\nprotected theorem finite.of_finset {p : set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) : p.finite :=\n  ⟨fintype.of_finset s H⟩\n#align finite.of_finset finite.of_finset\n\n",
 "of_finite_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite.of_finite_image {s : set α} {f : α → β} (h : («expr '' » f s).finite) (hi : Set.InjOn f s) : s.finite :=\n  by\n  cases h\n  exact\n    ⟨fintype.of_injective (fun a => (⟨f a.1, mem_image_of_mem f a.2⟩ : «expr '' » f s)) fun a b eq =>\n        subtype.eq <| hi a.2 b.2 <| subtype.ext_iff_val.1 eq⟩\n#align finite.of_finite_image finite.of_finite_image\n\n",
 "of_diff":
 "theorem finite.of_diff {s t : set α} (hd : (s \\ t).finite) (ht : t.finite) : s.finite :=\n  (hd.union ht).subset <| subset_diff_union _ _\n#align finite.of_diff finite.of_diff\n\n",
 "not_inj_on_infinite_finite_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem not_inj_on_infinite_finite_image {f : α → β} {s : set α} (h_inf : s.infinite)\n    (h_fin : («expr '' » f s).finite) : ¬InjOn f s :=\n  by\n  haveI : Finite («expr '' » f s) := finite_coe_iff.mpr h_fin\n  haveI : Infinite s := infinite_coe_iff.mpr h_inf\n  have := not_injective_infinite_finite ((«expr '' » f s).cod_restrict (s.restrict f) fun x => ⟨x, x.property, rfl⟩)\n  contrapose! this\n  rwa [injective_cod_restrict, ← inj_on_iff_injective]\n#align not_inj_on_infinite_finite_image not_inj_on_infinite_finite_image\n\n",
 "not_infinite":
 "@[simp]\ntheorem not_infinite {s : set α} : ¬s.infinite ↔ s.finite :=\n  not_not\n#align not_infinite not_infinite\n\n",
 "nonempty":
 "theorem infinite.nonempty {s : set α} (h : s.infinite) : s.nonempty :=\n  let a := infinite.nat_embedding s h 37\n  ⟨a.1, a.2⟩\n#align infinite.nonempty infinite.nonempty\n\n",
 "mono":
 "protected theorem infinite.mono {s t : set α} (h : s ⊆ t) : s.infinite → t.infinite :=\n  mt fun ht => ht.subset h\n#align infinite.mono infinite.mono\n\n",
 "mem_to_finset":
 "@[simp]\nprotected theorem mem_to_finset (h : s.finite) : a ∈ h.to_finset ↔ a ∈ s :=\n  @mem_to_finset _ _ h.fintype _\n#align mem_to_finset mem_to_finset\n\n",
 "map":
 "theorem finite.map {α β} {s : set α} : ∀ f : α → β, s.finite → (f <$> s).finite :=\n  finite.image\n#align finite.map finite.map\n\n",
 "inter_of_right":
 "theorem finite.inter_of_right {s : set α} (hs : s.finite) (t : set α) : (t ∩ s).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.inter_of_right finite.inter_of_right\n\n",
 "inter_of_left":
 "theorem finite.inter_of_left {s : set α} (hs : s.finite) (t : set α) : (s ∩ t).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.inter_of_left finite.inter_of_left\n\n",
 "insert":
 "@[simp]\ntheorem finite.insert (a : α) {s : set α} (hs : s.finite) : (insert a s).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.insert finite.insert\n\n",
 "infinite_univ_iff":
 "theorem infinite_univ_iff : (@univ α).infinite ↔ Infinite α := by\n  rw [set.infinite, finite_univ_iff, not_finite_iff_infinite]\n#align infinite_univ_iff infinite_univ_iff\n\n",
 "infinite_univ":
 "theorem infinite_univ [h : Infinite α] : (@univ α).infinite :=\n  infinite_univ_iff.2 h\n#align infinite_univ infinite_univ\n\n",
 "infinite_union":
 "@[simp]\ntheorem infinite_union {s t : set α} : (s ∪ t).infinite ↔ s.infinite ∨ t.infinite := by\n  simp only [set.infinite, finite_union, not_and_or]\n#align infinite_union infinite_union\n\n",
 "infinite_range_of_injective":
 "theorem infinite_range_of_injective [Infinite α] {f : α → β} (hi : injective f) : (range f).infinite :=\n  by\n  rw [← image_univ, infinite_image_iff (inj_on_of_injective hi _)]\n  exact infinite_univ\n#align infinite_range_of_injective infinite_range_of_injective\n\n",
 "infinite_of_not_bdd_below":
 "theorem infinite_of_not_bdd_below : ¬BddBelow s → s.infinite :=\n  by\n  contrapose!\n  rw [not_infinite]\n  apply finite.bdd_below\n#align infinite_of_not_bdd_below infinite_of_not_bdd_below\n\n",
 "infinite_of_not_bdd_above":
 "theorem infinite_of_not_bdd_above : ¬BddAbove s → s.infinite :=\n  mt finite.bdd_above\n#align infinite_of_not_bdd_above infinite_of_not_bdd_above\n\n",
 "infinite_of_injective_forall_mem":
 "theorem infinite_of_injective_forall_mem [Infinite α] {s : set β} {f : α → β} (hi : injective f)\n    (hf : ∀ x : α, f x ∈ s) : s.infinite := by\n  rw [← range_subset_iff] at hf\n  exact (infinite_range_of_injective hi).mono hf\n#align infinite_of_injective_forall_mem infinite_of_injective_forall_mem\n\n",
 "infinite_of_inj_on_maps_to":
 "theorem infinite_of_inj_on_maps_to {s : set α} {t : set β} {f : α → β} (hi : InjOn f s) (hm : MapsTo f s t)\n    (hs : s.infinite) : t.infinite :=\n  ((infinite_image_iff hi).2 hs).mono (mapsTo'.mp hm)\n#align infinite_of_inj_on_maps_to infinite_of_inj_on_maps_to\n\n",
 "infinite_of_infinite_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem infinite_of_infinite_image (f : α → β) {s : set α} (hs : («expr '' » f s).infinite) : s.infinite :=\n  mt (finite.image f) hs\n#align infinite_of_infinite_image infinite_of_infinite_image\n\n",
 "infinite_of_finite_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem infinite_of_finite_compl [Infinite α] {s : set α} (hs : («expr ᶜ» s).finite) : s.infinite := fun h =>\n  set.infinite_univ (by simpa using hs.union h)\n#align infinite_of_finite_compl infinite_of_finite_compl\n\n",
 "infinite_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem infinite_image_iff {s : set α} {f : α → β} (hi : InjOn f s) : («expr '' » f s).infinite ↔ s.infinite :=\n  not_congr <| finite_image_iff hi\n#align infinite_image_iff infinite_image_iff\n\n",
 "infinite_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem finite.infinite_compl [Infinite α] {s : set α} (hs : s.finite) : («expr ᶜ» s).infinite := fun h =>\n  set.infinite_univ (by simpa using hs.union h)\n#align finite.infinite_compl finite.infinite_compl\n\n",
 "infinite_coe_iff":
 "theorem infinite_coe_iff {s : set α} : Infinite s ↔ s.infinite :=\n  not_finite_iff_infinite.symm.trans finite_coe_iff.not\n#align infinite_coe_iff infinite_coe_iff\n\n",
 "infi_supr_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem _root_.infi_supr_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Coframe α] {f : ι → ι' → α} (hf : ∀ i, monotone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  supr_infi_of_antitone fun i => (hf i).dual_right\n#align infi_supr_of_monotone infi_supr_of_monotone\n\n",
 "infi_supr_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem _root_.infi_supr_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Coframe α] {f : ι → ι' → α} (hf : ∀ i, antitone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  supr_infi_of_monotone fun i => (hf i).dual_right\n#align infi_supr_of_antitone infi_supr_of_antitone\n\n",
 "infi_bsupr_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem finite.infi_bsupr_of_monotone {ι ι' α : Type _} [preorder ι'] [nonempty ι'] [IsDirected ι' (swap (· ≤ ·))]\n    [Order.Coframe α] {s : set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, monotone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  hs.supr_binfi_of_antitone fun i hi => (hf i hi).dual_right\n#align finite.infi_bsupr_of_monotone finite.infi_bsupr_of_monotone\n\n",
 "infi_bsupr_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem finite.infi_bsupr_of_antitone {ι ι' α : Type _} [preorder ι'] [nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Coframe α] {s : set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, antitone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  hs.supr_binfi_of_monotone fun i hi => (hf i hi).dual_right\n#align finite.infi_bsupr_of_antitone finite.infi_bsupr_of_antitone\n\n",
 "inf_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem finite.inf_of_right {s : set α} (h : s.finite) (t : set α) : («expr ⊓ » t s).finite :=\n  h.inter_of_right t\n#align finite.inf_of_right finite.inf_of_right\n\n",
 "inf_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem finite.inf_of_left {s : set α} (h : s.finite) (t : set α) : («expr ⊓ » s t).finite :=\n  h.inter_of_left t\n#align finite.inf_of_left finite.inf_of_left\n\n",
 "induction_on'":
 "/-- Analogous to `finset.induction_on'`. -/\n@[elab_as_elim]\ntheorem finite.induction_on' {C : set α → Prop} {S : set α} (h : S.finite) (H0 : C ∅)\n    (H1 : ∀ {a s}, a ∈ S → s ⊆ S → a ∉ s → C s → C (insert a s)) : C S :=\n  by\n  refine' @set.finite.induction_on α (fun s => s ⊆ S → C s) S h (fun _ => H0) _ subset.rfl\n  intro a s has hsf hCs haS\n  rw [insert_subset] at haS\n  exact H1 haS.1 haS.2 has (hCs haS.2)\n#align finite.induction_on' finite.induction_on'\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem finite.induction_on {C : set α → Prop} {s : set α} (h : s.finite) (H0 : C ∅)\n    (H1 : ∀ {a s}, a ∉ s → set.finite s → C s → C (insert a s)) : C s :=\n  by\n  lift s to Finset α using h\n  induction' s using Finset.cons_induction_on with a s ha hs\n  · rwa [Finset.coe_empty]\n  · rw [Finset.coe_cons]\n    exact @H1 a s ha (set.to_finite _) hs\n#align finite.induction_on finite.induction_on\n\n",
 "image2":
 "theorem finite.image2 (f : α → β → γ) {s : set α} {t : set β} (hs : s.finite) (ht : t.finite) : (image2 f s t).finite :=\n  by\n  cases hs\n  cases ht\n  apply to_finite\n#align finite.image2 finite.image2\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite.image {s : set α} (f : α → β) (hs : s.finite) : («expr '' » f s).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.image finite.image\n\n",
 "forall_finite_image_eval_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem forall_finite_image_eval_iff {δ : Type _} [Finite δ] {κ : δ → Type _} {s : set (∀ d, κ d)} :\n    (∀ d, («expr '' » (eval d) s).finite) ↔ s.finite :=\n  ⟨fun h => (finite.pi h).subset <| subset_pi_eval_image _ _, fun h d => h.image _⟩\n#align forall_finite_image_eval_iff forall_finite_image_eval_iff\n\n",
 "finite_univ_iff":
 "theorem finite_univ_iff : (@univ α).finite ↔ Finite α :=\n  finite_coe_iff.symm.trans (Equiv.Set.univ α).finite_iff\n#align finite_univ_iff finite_univ_iff\n\n",
 "finite_univ":
 "theorem finite_univ [Finite α] : (@univ α).finite :=\n  set.to_finite _\n#align finite_univ finite_univ\n\n",
 "finite_union":
 "@[simp]\ntheorem finite_union {s t : set α} : (s ∪ t).finite ↔ s.finite ∧ t.finite :=\n  ⟨fun h => ⟨h.subset (subset_union_left _ _), h.subset (subset_union_right _ _)⟩, fun ⟨hs, ht⟩ => hs.union ht⟩\n#align finite_union finite_union\n\n",
 "finite_to_set_to_finset":
 "@[simp]\ntheorem finite_to_set_to_finset [decidable_eq α] (s : Multiset α) : s.finite_to_set.to_finset = s.to_finset :=\n  by\n  ext x\n  simp\n#align finite_to_set_to_finset finite_to_set_to_finset\n\n",
 "finite_to_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n@[simp]\ntheorem list.finite_to_set (l : list α) : { x | x ∈ l }.finite :=\n  (show Multiset α from «expr⟦ ⟧» l).finite_to_set\n#align list.finite_to_set list.finite_to_set\n\n",
 "finite_subsets":
 "/-- There are finitely many subsets of a given finite set -/\ntheorem finite.finite_subsets {α : Type u} {a : set α} (h : a.finite) : { b | b ⊆ a }.finite :=\n  ⟨fintype.of_finset ((finset.powerset h.to_finset).map Finset.coeEmb.1) fun s => by\n      simpa [← @exists_finite_iff_finset α fun t => t ⊆ a ∧ t = s, finite.subset_to_finset, ← and_assoc] using h.subset⟩\n#align finite.finite_subsets finite.finite_subsets\n\n",
 "finite_subset_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_subset_Union {s : set α} (hs : s.finite) {ι} {t : ι → set α}\n    (h : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) :\n    ∃ I : set ι,\n      I.finite ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i) :=\n  by\n  cases hs\n  choose f hf using show ∀ x : s, ∃ i, x.1 ∈ t i by simpa [subset_def] using h\n  refine' ⟨range f, finite_range f, fun x hx => _⟩\n  rw [bUnion_range, mem_Union]\n  exact ⟨⟨x, hx⟩, hf _⟩\n#align finite_subset_Union finite_subset_Union\n\n",
 "finite_singleton":
 "@[simp]\ntheorem finite_singleton (a : α) : ({a} : set α).finite :=\n  to_finite _\n#align finite_singleton finite_singleton\n\n",
 "finite_range_ite":
 "theorem finite_range_ite {p : α → Prop} [decidable_pred p] {f g : α → β} (hf : (range f).finite)\n    (hg : (range g).finite) : (range fun x => if p x then f x else g x).finite :=\n  (hf.union hg).subset range_ite_subset\n#align finite_range_ite finite_range_ite\n\n",
 "finite_range_find_greatest":
 "theorem finite_range_find_greatest {P : α → ℕ → Prop} [∀ x, decidable_pred (P x)] {b : ℕ} :\n    (range fun x => Nat.findGreatest (P x) b).finite :=\n  (finite_le_nat b).subset <| range_subset_iff.2 fun x => Nat.findGreatest_le _\n#align finite_range_find_greatest finite_range_find_greatest\n\n",
 "finite_range_const":
 "theorem finite_range_const {c : β} : (range fun x : α => c).finite :=\n  (finite_singleton c).subset range_const_subset\n#align finite_range_const finite_range_const\n\n",
 "finite_range":
 "theorem finite_range (f : ι → α) [Finite ι] : (range f).finite :=\n  to_finite _\n#align finite_range finite_range\n\n",
 "finite_pure":
 "theorem finite_pure (a : α) : (pure a : set α).finite :=\n  to_finite _\n#align finite_pure finite_pure\n\n",
 "finite_preimage_inl_and_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite_preimage_inl_and_inr {s : set (Sum α β)} :\n    («expr ⁻¹' » sum.inl s).finite ∧ («expr ⁻¹' » sum.inr s).finite ↔ s.finite :=\n  ⟨fun h => image_preimage_inl_union_image_preimage_inr s ▸ (h.1.image _).union (h.2.image _), fun h =>\n    ⟨h.preimage (sum.inl_injective.inj_on _), h.preimage (sum.inr_injective.inj_on _)⟩⟩\n#align finite_preimage_inl_and_inr finite_preimage_inl_and_inr\n\n",
 "finite_or_infinite":
 "#print finite_or_infinite /-\n/-- See also `finite_or_infinite`, `fintype_or_infinite`. -/\nprotected theorem finite_or_infinite (s : set α) : s.finite ∨ s.infinite :=\n  em _\n#align finite_or_infinite finite_or_infinite\n-/\n\n",
 "finite_option":
 "theorem finite_option {s : set (option α)} : s.finite ↔ { x : α | some x ∈ s }.finite :=\n  ⟨fun h => h.preimage_embedding Embedding.some, fun h =>\n    ((h.image some).insert none).subset fun x =>\n      option.cases_on x (fun _ => or.inl rfl) fun x hx => or.inr <| mem_image_of_mem _ hx⟩\n#align finite_option finite_option\n\n",
 "finite_of_forall_between_eq_endpoints":
 "/-- If a set `s` does not contain any elements between any pair of elements `x, z ∈ s` with `x ≤ z`\n(i.e if given `x, y, z ∈ s` such that `x ≤ y ≤ z`, then `y` is either `x` or `z`), then `s` is\nfinite.\n-/\ntheorem set.finite_of_forall_between_eq_endpoints {α : Type _} [linear_order α] (s : set α)\n    (h : ∀ x ∈ s, ∀ y ∈ s, ∀ z ∈ s, x ≤ y → y ≤ z → x = y ∨ y = z) : set.finite s :=\n  by\n  by_contra hinf\n  change s.infinite at hinf\n  rcases hinf.exists_subset_card_eq 3 with ⟨t, hts, ht⟩\n  let f := t.order_iso_of_fin ht\n  let x := f 0\n  let y := f 1\n  let z := f 2\n  have := h x (hts x.2) y (hts y.2) z (hts z.2) (f.monotone <| by decide) (f.monotone <| by decide)\n  have key₁ : (0 : fin 3) ≠ 1 := by decide\n  have key₂ : (1 : fin 3) ≠ 2 := by decide\n  cases this\n  · dsimp only [x, y] at this\n    exact key₁ (f.injective <| subtype.coe_injective this)\n  · dsimp only [y, z] at this\n    exact key₂ (f.injective <| subtype.coe_injective this)\n#align set.finite_of_forall_between_eq_endpoints set.finite_of_forall_between_eq_endpoints\n\n",
 "finite_of_finite_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite_of_finite_preimage {f : α → β} {s : set β} (h : («expr ⁻¹' » f s).finite) (hs : s ⊆ range f) :\n    s.finite := by\n  rw [← image_preimage_eq_of_subset hs]\n  exact finite.image f h\n#align finite_of_finite_preimage finite_of_finite_preimage\n\n",
 "finite_of_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem finite.finite_of_compl {s : set α} (hs : s.finite) (hsc : («expr ᶜ» s).finite) : Finite α :=\n  by\n  rw [← finite_univ_iff, ← union_compl_self s]\n  exact hs.union hsc\n#align finite.finite_of_compl finite.finite_of_compl\n\n",
 "finite_mem_finset":
 "theorem finite_mem_finset (s : Finset α) : { a | a ∈ s }.finite :=\n  to_finite _\n#align finite_mem_finset finite_mem_finset\n\n",
 "finite_lt_nat":
 "theorem finite_lt_nat (n : ℕ) : set.finite { i | i < n } :=\n  to_finite _\n#align finite_lt_nat finite_lt_nat\n\n",
 "finite_le_nat":
 "theorem finite_le_nat (n : ℕ) : set.finite { i | i ≤ n } :=\n  to_finite _\n#align finite_le_nat finite_le_nat\n\n",
 "finite_is_top":
 "theorem finite_is_top (α : Type _) [partial_order α] : { x : α | is_top x }.finite :=\n  (subsingleton_isTop α).finite\n#align finite_is_top finite_is_top\n\n",
 "finite_is_bot":
 "theorem finite_is_bot (α : Type _) [partial_order α] : { x : α | is_bot x }.finite :=\n  (subsingleton_isBot α).finite\n#align finite_is_bot finite_is_bot\n\n",
 "finite_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite_image_iff {s : set α} {f : α → β} (hi : InjOn f s) : («expr '' » f s).finite ↔ s.finite :=\n  ⟨fun h => h.of_finite_image hi, finite.image _⟩\n#align finite_image_iff finite_image_iff\n\n",
 "finite_image_fst_and_snd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite_image_fst_and_snd_iff {s : set (α × β)} :\n    («expr '' » prod.fst s).finite ∧ («expr '' » prod.snd s).finite ↔ s.finite :=\n  ⟨fun h => (h.1.prod h.2).subset fun x h => ⟨mem_image_of_mem _ h, mem_image_of_mem _ h⟩, fun h =>\n    ⟨h.image _, h.image _⟩⟩\n#align finite_image_fst_and_snd_iff finite_image_fst_and_snd_iff\n\n",
 "finite_empty":
 "@[simp]\ntheorem finite_empty : (∅ : set α).finite :=\n  to_finite _\n#align finite_empty finite_empty\n\n",
 "finite_def":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Kyle Miller\n-/\n-- The `protected` attribute does not take effect within the same namespace block.\ntheorem finite_def {s : set α} : s.finite ↔ nonempty (fintype s) :=\n  ⟨fun ⟨h⟩ => ⟨h⟩, fun ⟨h⟩ => ⟨h⟩⟩\n#align finite_def finite_def\n\n",
 "finite_coe_iff":
 "theorem finite_coe_iff {s : set α} : Finite s ↔ s.finite := by rw [finite_iff_nonempty_fintype, finite_def]\n#align finite_coe_iff finite_coe_iff\n\n",
 "finite_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_bUnion {ι : Type _} (s : set ι) [Finite s] (t : ι → set α) (H : ∀ i ∈ s, Finite (t i)) :\n    Finite («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x)) :=\n  by\n  rw [bUnion_eq_Union]\n  haveI : ∀ i : s, Finite (t i) := fun i => H i i.property\n  infer_instance\n#align finite_bUnion finite_bUnion\n\n",
 "finite_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_Union [Finite ι] {f : ι → set α} (H : ∀ i, (f i).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)).finite :=\n  by\n  haveI := fun i => (H i).fintype\n  apply to_finite\n#align finite_Union finite_Union\n\n",
 "finite":
 "theorem subsingleton.finite {s : set α} (h : s.subsingleton) : s.finite :=\n  h.induction_on finite_empty finite_singleton\n#align subsingleton.finite subsingleton.finite\n\n",
 "fin_param":
 "theorem finite.fin_param {s : set α} (h : s.finite) : ∃ (n : ℕ)(f : fin n → α), injective f ∧ range f = s :=\n  let ⟨n, f, hf⟩ := h.fin_embedding\n  ⟨n, f, f.injective, hf⟩\n#align finite.fin_param finite.fin_param\n\n",
 "fin_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem finite.fin_embedding {s : set α} (h : s.finite) : ∃ (n : ℕ)(f : «expr ↪ » (fin n) α), range f = s :=\n  ⟨_, (fintype.equiv_fin (h.to_finset : set α)).symm.as_embedding, by simp⟩\n#align finite.fin_embedding finite.fin_embedding\n\n",
 "exists_upper_bound_image":
 "theorem exists_upper_bound_image [hα : nonempty α] [linear_order β] (s : set α) (f : α → β) (h : s.finite) :\n    ∃ a : α, ∀ b ∈ s, f b ≤ f a := by\n  by_cases hs : Set.Nonempty s\n  ·\n    exact\n      let ⟨x₀, H, hx₀⟩ := set.exists_max_image s f h hs\n      ⟨x₀, fun x hx => hx₀ x hx⟩\n  · exact nonempty.elim hα fun a => ⟨a, fun x hx => absurd (Set.nonempty_of_mem hx) hs⟩\n#align exists_upper_bound_image exists_upper_bound_image\n\n",
 "exists_subset_card_eq":
 "theorem infinite.exists_subset_card_eq {s : set α} (hs : s.infinite) (n : ℕ) : ∃ t : Finset α, ↑t ⊆ s ∧ t.card = n :=\n  ⟨((Finset.range n).map (hs.nat_embedding _)).map (Embedding.subtype _), by simp⟩\n#align infinite.exists_subset_card_eq infinite.exists_subset_card_eq\n\n",
 "exists_not_mem_finset":
 "theorem infinite.exists_not_mem_finset {s : set α} (hs : s.infinite) (f : Finset α) : ∃ a ∈ s, a ∉ f :=\n  let ⟨a, has, haf⟩ := (hs.diff (to_finite f)).nonempty\n  ⟨a, has, fun h => haf <| Finset.mem_coe.1 h⟩\n#align infinite.exists_not_mem_finset infinite.exists_not_mem_finset\n\n",
 "exists_ne_map_eq_of_maps_to":
 "theorem infinite.exists_ne_map_eq_of_maps_to {s : set α} {t : set β} {f : α → β} (hs : s.infinite) (hf : MapsTo f s t)\n    (ht : t.finite) : ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ f x = f y :=\n  by\n  contrapose! ht\n  exact infinite_of_inj_on_maps_to (fun x hx y hy => not_imp_not.1 (ht x hx y hy)) hf hs\n#align infinite.exists_ne_map_eq_of_maps_to infinite.exists_ne_map_eq_of_maps_to\n\n",
 "exists_nat_lt":
 "theorem infinite.exists_nat_lt {s : set ℕ} (hs : s.infinite) (n : ℕ) : ∃ m ∈ s, n < m :=\n  let ⟨m, hm⟩ := (hs.diff <| set.finite_le_nat n).nonempty\n  ⟨m, by simpa using hm⟩\n#align infinite.exists_nat_lt infinite.exists_nat_lt\n\n",
 "exists_min_image":
 "theorem exists_min_image [linear_order β] (s : set α) (f : α → β) (h1 : s.finite) :\n    s.nonempty → ∃ a ∈ s, ∀ b ∈ s, f a ≤ f b\n  | ⟨x, hx⟩ => by\n    simpa only [exists_prop, finite.mem_to_finset] using h1.to_finset.exists_min_image f ⟨x, h1.mem_to_finset.2 hx⟩\n#align exists_min_image exists_min_image\n\n",
 "exists_maximal_wrt":
 "theorem finite.exists_maximal_wrt [partial_order β] (f : α → β) (s : set α) (h : set.finite s) :\n    s.nonempty → ∃ a ∈ s, ∀ a' ∈ s, f a ≤ f a' → f a = f a' :=\n  by\n  refine' h.induction_on _ _\n  · exact fun h => absurd h not_nonempty_empty\n  intro a s his _ ih _\n  cases' s.eq_empty_or_nonempty with h h\n  · use a\n    simp [h]\n  rcases ih h with ⟨b, hb, ih⟩\n  by_cases f b ≤ f a\n  · refine' ⟨a, Set.mem_insert _ _, fun c hc hac => le_antisymm hac _⟩\n    rcases Set.mem_insert_iff.1 hc with (rfl | hcs)\n    · rfl\n    · rwa [← ih c hcs (le_trans h hac)]\n  · refine' ⟨b, Set.mem_insert_of_mem _ hb, fun c hc hbc => _⟩\n    rcases Set.mem_insert_iff.1 hc with (rfl | hcs)\n    · exact (h hbc).elim\n    · exact ih c hcs hbc\n#align finite.exists_maximal_wrt finite.exists_maximal_wrt\n\n",
 "exists_max_image":
 "theorem exists_max_image [linear_order β] (s : set α) (f : α → β) (h1 : s.finite) :\n    s.nonempty → ∃ a ∈ s, ∀ b ∈ s, f b ≤ f a\n  | ⟨x, hx⟩ => by\n    simpa only [exists_prop, finite.mem_to_finset] using h1.to_finset.exists_max_image f ⟨x, h1.mem_to_finset.2 hx⟩\n#align exists_max_image exists_max_image\n\n",
 "exists_lt_map_eq_of_maps_to":
 "theorem infinite.exists_lt_map_eq_of_maps_to [linear_order α] {s : set α} {t : set β} {f : α → β} (hs : s.infinite)\n    (hf : MapsTo f s t) (ht : t.finite) : ∃ x ∈ s, ∃ y ∈ s, x < y ∧ f x = f y :=\n  let ⟨x, hx, y, hy, hxy, hf⟩ := hs.exists_ne_map_eq_of_maps_to hf ht\n  hxy.lt_or_lt.elim (fun hxy => ⟨x, hx, y, hy, hxy, hf⟩) fun hyx => ⟨y, hy, x, hx, hyx, hf.symm⟩\n#align infinite.exists_lt_map_eq_of_maps_to infinite.exists_lt_map_eq_of_maps_to\n\n",
 "exists_lt_map_eq_of_forall_mem":
 "theorem finite.exists_lt_map_eq_of_forall_mem [linear_order α] [Infinite α] {t : set β} {f : α → β} (hf : ∀ a, f a ∈ t)\n    (ht : t.finite) : ∃ a b, a < b ∧ f a = f b :=\n  by\n  rw [← maps_univ_to] at hf\n  obtain ⟨a, -, b, -, h⟩ := (@infinite_univ α _).exists_lt_map_eq_of_maps_to hf ht\n  exact ⟨a, b, h⟩\n#align finite.exists_lt_map_eq_of_forall_mem finite.exists_lt_map_eq_of_forall_mem\n\n",
 "exists_lower_bound_image":
 "theorem exists_lower_bound_image [hα : nonempty α] [linear_order β] (s : set α) (f : α → β) (h : s.finite) :\n    ∃ a : α, ∀ b ∈ s, f a ≤ f b := by\n  by_cases hs : Set.Nonempty s\n  ·\n    exact\n      let ⟨x₀, H, hx₀⟩ := set.exists_min_image s f h hs\n      ⟨x₀, fun x hx => hx₀ x hx⟩\n  · exact nonempty.elim hα fun a => ⟨a, fun x hx => absurd (Set.nonempty_of_mem hx) hs⟩\n#align exists_lower_bound_image exists_lower_bound_image\n\n",
 "exists_finset_coe":
 "theorem finite.exists_finset_coe {s : set α} (h : s.finite) : ∃ s' : Finset α, ↑s' = s :=\n  by\n  cases h\n  exact ⟨s.to_finset, s.coe_to_finset⟩\n#align finite.exists_finset_coe finite.exists_finset_coe\n\n",
 "exists_finset":
 "theorem finite.exists_finset {s : set α} (h : s.finite) : ∃ s' : Finset α, ∀ a : α, a ∈ s' ↔ a ∈ s :=\n  by\n  cases h\n  exact ⟨s.to_finset, fun _ => mem_to_finset⟩\n#align finite.exists_finset finite.exists_finset\n\n",
 "exists_finite_iff_finset":
 "theorem exists_finite_iff_finset {p : set α → Prop} : (∃ s : set α, s.finite ∧ p s) ↔ ∃ s : Finset α, p ↑s :=\n  ⟨fun ⟨s, hs, hps⟩ => ⟨hs.to_finset, hs.coe_to_finset.symm ▸ hps⟩, fun ⟨s, hs⟩ => ⟨s, s.finite_to_set, hs⟩⟩\n#align exists_finite_iff_finset exists_finite_iff_finset\n\n",
 "eq_of_subset_of_card_le":
 "theorem eq_of_subset_of_card_le {s t : set α} [fintype s] [fintype t] (hsub : s ⊆ t)\n    (hcard : fintype.card t ≤ fintype.card s) : s = t :=\n  (eq_or_ssubset_of_subset hsub).elim id fun h => absurd hcard <| not_le_of_lt <| card_lt_card h\n#align eq_of_subset_of_card_le eq_of_subset_of_card_le\n\n",
 "eq_finite_Union_of_finite_subset_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem eq_finite_Union_of_finite_subset_Union {ι} {s : ι → set α} {t : set α} (tfin : t.finite)\n    (h : t ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :\n    ∃ I : set ι,\n      I.finite ∧\n        ∃ σ : { i | i ∈ I } → set α,\n          (∀ i, (σ i).finite) ∧\n            (∀ i, σ i ⊆ s i) ∧\n              t =\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (σ i) :=\n  let ⟨I, Ifin, hI⟩ := finite_subset_Union tfin h\n  ⟨I, Ifin, fun x => s x ∩ t, fun i => tfin.subset (inter_subset_right _ _), fun i => inter_subset_left _ _,\n    by\n    ext x\n    rw [mem_Union]\n    constructor\n    · intro x_in\n      rcases mem_Union.mp (hI x_in) with ⟨i, _, ⟨hi, rfl⟩, H⟩\n      use i, hi, H, x_in\n    · rintro ⟨i, hi, H⟩\n      exact H⟩\n#align eq_finite_Union_of_finite_subset_Union eq_finite_Union_of_finite_subset_Union\n\n",
 "empty_card'":
 "@[simp]\ntheorem empty_card' {h : fintype.{u} (∅ : set α)} : @fintype.card (∅ : set α) h = 0 :=\n  eq.trans (by congr ) empty_card\n#align empty_card' empty_card'\n\n",
 "empty_card":
 "theorem empty_card : fintype.card (∅ : set α) = 0 :=\n  rfl\n#align empty_card empty_card\n\n",
 "disjoint_to_finset":
 "@[simp]\ntheorem disjoint_to_finset {hs : s.finite} {ht : t.finite} : Disjoint hs.to_finset ht.to_finset ↔ Disjoint s t :=\n  @disjoint_to_finset _ _ _ hs.fintype ht.fintype\n#align disjoint_to_finset disjoint_to_finset\n\n",
 "dinduction_on":
 "@[elab_as_elim]\ntheorem finite.dinduction_on {C : ∀ s : set α, s.finite → Prop} {s : set α} (h : s.finite) (H0 : C ∅ finite_empty)\n    (H1 : ∀ {a s}, a ∉ s → ∀ h : set.finite s, C s h → C (insert a s) (h.insert a)) : C s h :=\n  have : ∀ h : s.finite, C s h := finite.induction_on h (fun h => H0) fun a s has hs ih h => H1 has hs (ih _)\n  this h\n#align finite.dinduction_on finite.dinduction_on\n\n",
 "diff":
 "theorem infinite.diff {s t : set α} (hs : s.infinite) (ht : t.finite) : (s \\ t).infinite := fun h => hs <| h.of_diff ht\n#align infinite.diff infinite.diff\n\n",
 "dependent_image":
 "theorem finite.dependent_image {s : set α} (hs : s.finite) (F : ∀ i ∈ s, β) :\n    { y : β | ∃ (x : _)(hx : x ∈ s), y = F x hx }.finite :=\n  by\n  cases hs\n  simpa [range, eq_comm] using finite_range fun x : s => F x x.2\n#align finite.dependent_image finite.dependent_image\n\n",
 "coe_to_finset":
 "@[simp]\nprotected theorem coe_to_finset (h : s.finite) : (h.to_finset : set α) = s :=\n  @coe_to_finset _ _ h.fintype\n#align coe_to_finset coe_to_finset\n\n",
 "coe_sort_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- Note that this is an equality of types not holding definitionally. Use wisely. -/\ntheorem coe_sort_to_finset (h : s.finite) : «expr↥ » h.to_finset = «expr↥ » s := by\n  rw [← Finset.coe_sort_coe _, h.coe_to_finset]\n#align coe_sort_to_finset coe_sort_to_finset\n\n",
 "card_to_finset":
 "theorem finite.card_to_finset {s : set α} [fintype s] (h : s.finite) : h.to_finset.card = fintype.card s :=\n  by\n  rw [← finset.card_attach, finset.attach_eq_univ, ← fintype.card]\n  refine' fintype.card_congr (Equiv.setCongr _)\n  ext x\n  show x ∈ h.to_finset ↔ x ∈ s\n  simp\n#align finite.card_to_finset finite.card_to_finset\n\n",
 "card_singleton":
 "@[simp]\ntheorem card_singleton (a : α) : fintype.card ({a} : set α) = 1 :=\n  fintype.card_of_subsingleton _\n#align card_singleton card_singleton\n\n",
 "card_range_of_injective":
 "theorem card_range_of_injective [fintype α] {f : α → β} (hf : injective f) [fintype (range f)] :\n    fintype.card (range f) = fintype.card α :=\n  eq.symm <| fintype.card_congr <| Equiv.ofInjective f hf\n#align card_range_of_injective card_range_of_injective\n\n",
 "card_ne_eq":
 "theorem card_ne_eq [fintype α] (a : α) [fintype { x : α | x ≠ a }] :\n    fintype.card { x : α | x ≠ a } = fintype.card α - 1 :=\n  by\n  haveI := classical.dec_eq α\n  rw [← to_finset_card, to_finset_set_of, Finset.filter_ne', finset.card_erase_of_mem (finset.mem_univ _),\n    finset.card_univ]\n#align card_ne_eq card_ne_eq\n\n",
 "card_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem card_lt_card {s t : set α} [fintype s] [fintype t] (h : «expr ⊂ » s t) : fintype.card s < fintype.card t :=\n  fintype.card_lt_of_injective_not_surjective (Set.inclusion h.1) (Set.inclusion_injective h.1) fun hst =>\n    (ssubset_iff_subset_ne.1 h).2 (eq_of_inclusion_surjective hst)\n#align card_lt_card card_lt_card\n\n",
 "card_le_of_subset":
 "theorem card_le_of_subset {s t : set α} [fintype s] [fintype t] (hsub : s ⊆ t) : fintype.card s ≤ fintype.card t :=\n  fintype.card_le_of_injective (Set.inclusion hsub) (Set.inclusion_injective hsub)\n#align card_le_of_subset card_le_of_subset\n\n",
 "card_insert":
 "@[simp]\ntheorem card_insert {a : α} (s : set α) [fintype s] (h : a ∉ s) {d : fintype.{u} (insert a s : set α)} :\n    @fintype.card _ d = fintype.card s + 1 := by rw [← card_fintype_insert_of_not_mem s h] <;> congr\n#align card_insert card_insert\n\n",
 "card_image_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem card_image_of_injective (s : set α) [fintype s] {f : α → β} [fintype («expr '' » f s)]\n    (H : function.injective f) : fintype.card («expr '' » f s) = fintype.card s :=\n  card_image_of_inj_on fun _ _ _ _ h => H h\n#align card_image_of_injective card_image_of_injective\n\n",
 "card_image_of_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem card_image_of_inj_on {s : set α} [fintype s] {f : α → β} [fintype («expr '' » f s)]\n    (H : ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) : fintype.card («expr '' » f s) = fintype.card s :=\n  haveI := classical.prop_decidable\n  calc\n    fintype.card («expr '' » f s) = (s.to_finset.image f).card := fintype.card_of_finset' _ (by simp)\n    _ = s.to_finset.card :=\n      finset.card_image_of_inj_on fun x hx y hy hxy => H x (mem_to_finset.1 hx) y (mem_to_finset.1 hy) hxy\n    _ = fintype.card s := (fintype.card_of_finset' _ fun a => mem_to_finset).symm\n    \n#align card_image_of_inj_on card_image_of_inj_on\n\n",
 "card_fintype_insert_of_not_mem":
 "theorem card_fintype_insert_of_not_mem {a : α} (s : set α) [fintype s] (h : a ∉ s) :\n    @fintype.card _ (fintype_insert_of_not_mem s h) = fintype.card s + 1 := by\n  rw [fintype_insert_of_not_mem, fintype.card_of_finset] <;> simp [finset.card, to_finset] <;> rfl\n#align card_fintype_insert_of_not_mem card_fintype_insert_of_not_mem\n\n",
 "bind":
 "theorem finite.bind {α β} {s : set α} {f : α → set β} (h : s.finite) (hf : ∀ a ∈ s, (f a).finite) : (s >>= f).finite :=\n  h.bUnion hf\n#align finite.bind finite.bind\n\n",
 "bdd_below_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of sets which are all bounded below is still bounded below.-/\ntheorem finite.bdd_below_bUnion {I : set β} {S : β → set α} (H : I.finite) :\n    BddBelow («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i)) ↔\n      ∀ i ∈ I, BddBelow (S i) :=\n  @finite.bdd_above_bUnion («expr ᵒᵈ» α) _ _ _ _ _ H\n#align finite.bdd_below_bUnion finite.bdd_below_bUnion\n\n",
 "bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A finite set is bounded below.-/\nprotected theorem finite.bdd_below (hs : s.finite) : BddBelow s :=\n  @finite.bdd_above («expr ᵒᵈ» α) _ _ _ hs\n#align finite.bdd_below finite.bdd_below\n\n",
 "bdd_above_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of sets which are all bounded above is still bounded above.-/\ntheorem finite.bdd_above_bUnion {I : set β} {S : β → set α} (H : I.finite) :\n    BddAbove («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i)) ↔\n      ∀ i ∈ I, BddAbove (S i) :=\n  finite.induction_on H (by simp only [bUnion_empty, bddAbove_empty, ball_empty_iff]) fun a s ha _ hs => by\n    simp only [bUnion_insert, ball_insert_iff, bddAbove_union, hs]\n#align finite.bdd_above_bUnion finite.bdd_above_bUnion\n\n",
 "bdd_above":
 "/-- A finite set is bounded above.-/\nprotected theorem finite.bdd_above (hs : s.finite) : BddAbove s :=\n  finite.induction_on hs bddAbove_empty fun a s _ _ h => h.insert a\n#align finite.bdd_above finite.bdd_above\n\n",
 "bUnion'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Dependent version of `finite.bUnion`. -/\ntheorem finite.bUnion' {ι} {s : set ι} (hs : s.finite) {t : ∀ i ∈ s, set α} (ht : ∀ i ∈ s, (t i ‹_›).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (t i ‹_›)).finite :=\n  by\n  cases hs\n  rw [bUnion_eq_Union]\n  apply finite_Union fun i : s => ht i.1 i.2\n#align finite.bUnion' finite.bUnion'\n\n",
 "bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite.bUnion {ι} {s : set ι} (hs : s.finite) {t : ι → set α} (ht : ∀ i ∈ s, (t i).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)).finite := by\n  classical\n    cases hs\n    haveI := fintype_bUnion s t fun i hi => (ht i hi).fintype\n    apply to_finite\n#align finite.bUnion finite.bUnion\n\n",
 "Union_univ_pi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_univ_pi_of_monotone {ι ι' : Type _} [linear_order ι'] [nonempty ι'] [Finite ι] {α : ι → Type _}\n    {s : ∀ i, ι' → set (α i)} (hs : ∀ i, monotone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (pi univ fun i => s i j) =\n      pi univ fun i =>\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j) :=\n  Union_pi_of_monotone finite_univ fun i _ => hs i\n#align Union_univ_pi_of_monotone Union_univ_pi_of_monotone\n\n",
 "Union_pi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_pi_of_monotone {ι ι' : Type _} [linear_order ι'] [nonempty ι'] {α : ι → Type _} {I : set ι}\n    {s : ∀ i, ι' → set (α i)} (hI : I.finite) (hs : ∀ i ∈ I, monotone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (I.pi fun i => s i j) =\n      I.pi fun i =>\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j) :=\n  by\n  simp only [pi_def, bInter_eq_Inter, preimage_Union]\n  haveI := hI.fintype\n  exact Union_Inter_of_monotone fun i j₁ j₂ h => preimage_mono <| hs i i.2 h\n#align Union_pi_of_monotone Union_pi_of_monotone\n\n",
 "Union_Inter_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- An increasing union distributes over finite intersection. -/\ntheorem Union_Inter_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (· ≤ ·)] [nonempty ι']\n    {s : ι → ι' → set α} (hs : ∀ i, monotone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) :=\n  supr_infi_of_monotone hs\n#align Union_Inter_of_monotone Union_Inter_of_monotone\n\n",
 "Union_Inter_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A decreasing union distributes over finite intersection. -/\ntheorem Union_Inter_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (swap (· ≤ ·))] [nonempty ι']\n    {s : ι → ι' → set α} (hs : ∀ i, antitone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) :=\n  supr_infi_of_antitone hs\n#align Union_Inter_of_antitone Union_Inter_of_antitone\n\n",
 "Inter_Union_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- An increasing intersection distributes over finite union. -/\ntheorem Inter_Union_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (swap (· ≤ ·))] [nonempty ι']\n    {s : ι → ι' → set α} (hs : ∀ i, monotone (s i)) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) :=\n  infi_supr_of_monotone hs\n#align Inter_Union_of_monotone Inter_Union_of_monotone\n\n",
 "Inter_Union_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- A decreasing intersection distributes over finite union. -/\ntheorem Inter_Union_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (· ≤ ·)] [nonempty ι']\n    {s : ι → ι' → set α} (hs : ∀ i, antitone (s i)) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) :=\n  infi_supr_of_antitone hs\n#align Inter_Union_of_antitone Inter_Union_of_antitone\n\n",
 "BddBelow":
 "#print BddBelow /-\n/-- A finset is bounded below. -/\nprotected theorem BddBelow [SemilatticeInf α] [nonempty α] (s : Finset α) : BddBelow (↑s : set α) :=\n  s.finite_to_set.bdd_below\n#align bdd_below BddBelow\n-/\n\n",
 "BddAbove":
 "#print BddAbove /-\n/-- A finset is bounded above. -/\nprotected theorem BddAbove [SemilatticeSup α] [nonempty α] (s : Finset α) : BddAbove (↑s : set α) :=\n  s.finite_to_set.bdd_above\n#align bdd_above BddAbove\n-/\n\n"}