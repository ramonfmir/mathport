{"univ_finite_iff_nonempty_fintype":
 "theorem univ_finite_iff_nonempty_fintype : (univ : Set α).finite ↔ Nonempty (Fintype α) :=\n  ⟨fun h => ⟨fintypeOfFiniteUniv h⟩, fun ⟨_i⟩ => finite_univ⟩\n#align univ_finite_iff_nonempty_fintype univ_finite_iff_nonempty_fintype\n\n",
 "union_finset_finite_of_range_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of finsets is finite. -/\ntheorem union_finset_finite_of_range_finite (f : α → Finset β) (h : (range f).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (f a : Set β)).finite :=\n  by\n  rw [← bUnion_range]\n  exact h.bUnion fun y hy => y.finite_to_set\n#align union_finset_finite_of_range_finite union_finset_finite_of_range_finite\n\n",
 "union":
 "theorem finite.union {s t : Set α} (hs : s.finite) (ht : t.finite) : (s ∪ t).finite :=\n  by\n  cases hs\n  cases ht\n  apply to_finite\n#align finite.union finite.union\n\n",
 "to_subtype":
 "/-- Projection of `set.finite` to its `finite` instance.\nThis is intended to be used with dot notation.\nSee also `set.finite.fintype` and `set.finite.nonempty_fintype`. -/\nprotected theorem finite.to_subtype {s : Set α} (h : s.finite) : Finite s :=\n  finite_coe_iff.mpr h\n#align finite.to_subtype finite.to_subtype\n\n",
 "to_finset_univ":
 "@[simp]\nprotected theorem to_finset_univ [Fintype α] (h : (Set.univ : Set α).finite) : h.to_finset = Finset.univ :=\n  by\n  ext\n  simp\n#align to_finset_univ to_finset_univ\n\n",
 "to_finset_union":
 "protected theorem to_finset_union [DecidableEq α] (hs : s.finite) (ht : t.finite) (h : (s ∪ t).finite) :\n    h.to_finset = hs.to_finset ∪ ht.to_finset := by\n  ext\n  simp\n#align to_finset_union to_finset_union\n\n",
 "to_finset_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∆ » -/\nprotected theorem to_finset_symm_diff [DecidableEq α] (hs : s.finite) (ht : t.finite) (h : («expr ∆ » s t).finite) :\n    h.to_finset = «expr ∆ » hs.to_finset ht.to_finset := by\n  ext\n  simp [mem_symm_diff, Finset.mem_symmDiff]\n#align to_finset_symm_diff to_finset_symm_diff\n\n",
 "to_finset_subset_to_finset":
 "@[mono]\nprotected theorem to_finset_subset_to_finset : hs.to_finset ⊆ ht.to_finset ↔ s ⊆ t := by\n  simp only [← Finset.coe_subset, finite.coe_to_finset]\n#align to_finset_subset_to_finset to_finset_subset_to_finset\n\n",
 "to_finset_subset":
 "@[simp]\ntheorem to_finset_subset {t : Finset α} : hs.to_finset ⊆ t ↔ s ⊆ t := by rw [← Finset.coe_subset, finite.coe_to_finset]\n#align to_finset_subset to_finset_subset\n\n",
 "to_finset_ssubset_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[mono]\nprotected theorem to_finset_ssubset_to_finset : «expr ⊂ » hs.to_finset ht.to_finset ↔ «expr ⊂ » s t := by\n  simp only [← Finset.coe_ssubset, finite.coe_to_finset]\n#align to_finset_ssubset_to_finset to_finset_ssubset_to_finset\n\n",
 "to_finset_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem to_finset_ssubset {t : Finset α} : «expr ⊂ » hs.to_finset t ↔ «expr ⊂ » s t := by\n  rw [← Finset.coe_ssubset, finite.coe_to_finset]\n#align to_finset_ssubset to_finset_ssubset\n\n",
 "to_finset_singleton":
 "@[simp]\ntheorem finite.to_finset_singleton {a : α} (ha : ({a} : Set α).finite := finite_singleton _) : ha.to_finset = {a} :=\n  Finset.ext <| by simp\n#align finite.to_finset_singleton finite.to_finset_singleton\n\n",
 "to_finset_set_of":
 "@[simp]\nprotected theorem to_finset_set_of [Fintype α] (p : α → Prop) [DecidablePred p] (h : { x | p x }.finite) :\n    h.to_finset = Finset.univ.filter p := by\n  ext\n  simp\n#align to_finset_set_of to_finset_set_of\n\n",
 "to_finset_range":
 "@[simp]\nprotected theorem to_finset_range [DecidableEq α] [Fintype β] (f : β → α) (h : (range f).finite) :\n    h.to_finset = Finset.univ.image f := by\n  ext\n  simp\n#align to_finset_range to_finset_range\n\n",
 "to_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem finite.to_finset_prod {s : Set α} {t : Set β} (hs : s.finite) (ht : t.finite) :\n    finset.product hs.to_finset ht.to_finset = (hs.prod ht).to_finset :=\n  Finset.ext <| by simp\n#align finite.to_finset_prod finite.to_finset_prod\n\n",
 "to_finset_off_diag":
 "theorem finite.to_finset_off_diag {s : Set α} [DecidableEq α] (hs : s.finite) :\n    hs.off_diag.to_finset = hs.to_finset.off_diag :=\n  Finset.ext <| by simp\n#align finite.to_finset_off_diag finite.to_finset_off_diag\n\n",
 "to_finset_nonempty":
 "@[simp]\nprotected theorem to_finset_nonempty (h : s.finite) : h.to_finset.nonempty ↔ s.nonempty := by\n  rw [← Finset.coe_nonempty, finite.coe_to_finset]\n#align to_finset_nonempty to_finset_nonempty\n\n",
 "to_finset_inter":
 "protected theorem to_finset_inter [DecidableEq α] (hs : s.finite) (ht : t.finite) (h : (s ∩ t).finite) :\n    h.to_finset = hs.to_finset ∩ ht.to_finset := by\n  ext\n  simp\n#align to_finset_inter to_finset_inter\n\n",
 "to_finset_insert'":
 "theorem finite.to_finset_insert' [DecidableEq α] {a : α} {s : Set α} (hs : s.finite) :\n    (hs.insert a).to_finset = insert a hs.to_finset :=\n  Finite.toFinset_insert _\n#align finite.to_finset_insert' finite.to_finset_insert'\n\n",
 "to_finset_insert":
 "@[simp]\ntheorem finite.to_finset_insert [DecidableEq α] {s : Set α} {a : α} (hs : (insert a s).finite) :\n    hs.to_finset = insert a (hs.subset <| subset_insert _ _).to_finset :=\n  Finset.ext <| by simp\n#align finite.to_finset_insert finite.to_finset_insert\n\n",
 "to_finset_inj":
 "@[simp]\nprotected theorem to_finset_inj : hs.to_finset = ht.to_finset ↔ s = t :=\n  @toFinset_inj _ _ _ hs.fintype ht.fintype\n#align to_finset_inj to_finset_inj\n\n",
 "to_finset_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\nprotected theorem to_finset_image [DecidableEq β] (f : α → β) (hs : s.finite) (h : («expr '' » f s).finite) :\n    h.to_finset = hs.to_finset.image f := by\n  ext\n  simp\n#align to_finset_image to_finset_image\n\n",
 "to_finset_eq_univ":
 "@[simp]\nprotected theorem to_finset_eq_univ [Fintype α] {h : s.finite} : h.to_finset = Finset.univ ↔ s = univ :=\n  @toFinset_eq_univ _ _ _ h.fintype\n#align to_finset_eq_univ to_finset_eq_univ\n\n",
 "to_finset_eq_empty":
 "@[simp]\nprotected theorem to_finset_eq_empty {h : s.finite} : h.to_finset = ∅ ↔ s = ∅ :=\n  @toFinset_eq_empty _ _ h.fintype\n#align to_finset_eq_empty to_finset_eq_empty\n\n",
 "to_finset_empty":
 "@[simp]\nprotected theorem to_finset_empty (h : (∅ : Set α).finite) : h.to_finset = ∅ :=\n  by\n  ext\n  simp\n#align to_finset_empty to_finset_empty\n\n",
 "to_finset_diff":
 "protected theorem to_finset_diff [DecidableEq α] (hs : s.finite) (ht : t.finite) (h : (s \\ t).finite) :\n    h.to_finset = hs.to_finset \\ ht.to_finset := by\n  ext\n  simp\n#align to_finset_diff to_finset_diff\n\n",
 "to_finset_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\nprotected theorem to_finset_compl [DecidableEq α] [Fintype α] (hs : s.finite) (h : («expr ᶜ» s).finite) :\n    h.to_finset = «expr ᶜ» hs.to_finset := by\n  ext\n  simp\n#align to_finset_compl to_finset_compl\n\n",
 "to_finite":
 "/-- Constructor for `set.finite` using a `finite` instance. -/\ntheorem to_finite (s : Set α) [Finite s] : s.finite :=\n  finite_coe_iff.mp ‹_›\n#align to_finite to_finite\n\n",
 "supr_infi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print Set.supᵢ_infᵢ_of_monotone /-\ntheorem Set.supᵢ_infᵢ_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [Nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Frame α] {f : ι → ι' → α} (hf : ∀ i, Monotone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  by simpa only [infᵢ_univ] using finite_univ.supr_binfi_of_monotone fun i hi => hf i\n#align supr_infi_of_monotone Set.supᵢ_infᵢ_of_monotone\n-/\n\n",
 "supr_infi_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print Set.supᵢ_infᵢ_of_antitone /-\ntheorem Set.supᵢ_infᵢ_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [Nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Frame α] {f : ι → ι' → α} (hf : ∀ i, Antitone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  @Set.supᵢ_infᵢ_of_monotone ι («expr ᵒᵈ» ι') α _ _ _ _ _ _ fun i => (hf i).dual_left\n#align supr_infi_of_antitone Set.supᵢ_infᵢ_of_antitone\n-/\n\n",
 "supr_binfi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem finite.supr_binfi_of_monotone {ι ι' α : Type _} [preorder ι'] [Nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Frame α] {s : Set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, Monotone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  by\n  revert hf\n  refine' hs.induction_on _ _\n  · intro hf\n    simp [supᵢ_const]\n  · intro a s has hs ihs hf\n    rw [ball_insert_iff] at hf\n    simp only [infᵢ_insert, ← ihs hf.2]\n    exact supᵢ_inf_of_monotone hf.1 fun j₁ j₂ hj => infᵢ₂_mono fun i hi => hf.2 i hi hj\n#align finite.supr_binfi_of_monotone finite.supr_binfi_of_monotone\n\n",
 "supr_binfi_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem finite.supr_binfi_of_antitone {ι ι' α : Type _} [preorder ι'] [Nonempty ι'] [IsDirected ι' (swap (· ≤ ·))]\n    [Order.Frame α] {s : Set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, Antitone (f i)) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) :=\n  @Finite.supᵢ_binfᵢ_of_monotone ι («expr ᵒᵈ» ι') α _ _ _ _ _ hs _ fun i hi => (hf i hi).dual_left\n#align finite.supr_binfi_of_antitone finite.supr_binfi_of_antitone\n\n",
 "sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem finite.sup {s t : Set α} : s.finite → t.finite → («expr ⊔ » s t).finite :=\n  Finite.union\n#align finite.sup finite.sup\n\n",
 "subset_to_finset":
 "@[simp]\ntheorem subset_to_finset {s : Finset α} : s ⊆ ht.to_finset ↔ ↑s ⊆ t := by rw [← Finset.coe_subset, finite.coe_to_finset]\n#align subset_to_finset subset_to_finset\n\n",
 "subset":
 "theorem finite.subset {s : Set α} (hs : s.finite) {t : Set α} (ht : t ⊆ s) : t.finite :=\n  by\n  cases hs\n  haveI := Finite.Set.subset _ ht\n  apply to_finite\n#align finite.subset finite.subset\n\n",
 "ssubset_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n@[simp]\ntheorem ssubset_to_finset {s : Finset α} : «expr ⊂ » s ht.to_finset ↔ «expr ⊂ » (↑s) t := by\n  rw [← Finset.coe_ssubset, finite.coe_to_finset]\n#align ssubset_to_finset ssubset_to_finset\n\n",
 "seq_of_forall_finite_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If `P` is some relation between terms of `γ` and sets in `γ`,\nsuch that every finite set `t : set γ` has some `c : γ` related to it,\nthen there is a recursively defined sequence `u` in `γ`\nso `u n` is related to the image of `{0, 1, ..., n-1}` under `u`.\n\n(We use this later to show sequentially compact sets\nare totally bounded.)\n-/\ntheorem seq_of_forall_finite_exists {γ : Type _} {P : γ → Set γ → Prop} (h : ∀ t : Set γ, t.finite → ∃ c, P c t) :\n    ∃ u : ℕ → γ, ∀ n, P (u n) («expr '' » u (Iio n)) :=\n  ⟨fun n =>\n    @Nat.strongRecOn' (fun _ => γ) n fun n ih =>\n      Classical.choose <| h (range fun m : Iio n => ih m.1 m.2) (finite_range _),\n    fun n => by\n    classical\n      refine' Nat.strongRecOn' n fun n ih => _\n      rw [Nat.strongRecOn'_beta]\n      convert Classical.choose_spec (h _ _)\n      ext x\n      constructor\n      · rintro ⟨m, hmn, rfl⟩\n        exact ⟨⟨m, hmn⟩, rfl⟩\n      · rintro ⟨⟨m, hmn⟩, rfl⟩\n        exact ⟨m, hmn, rfl⟩⟩\n#align seq_of_forall_finite_exists seq_of_forall_finite_exists\n\n",
 "seq'":
 "theorem finite.seq' {α β : Type u} {f : Set (α → β)} {s : Set α} (hf : f.finite) (hs : s.finite) : (f <*> s).finite :=\n  hf.seq hs\n#align finite.seq' finite.seq'\n\n",
 "seq":
 "theorem finite.seq {f : Set (α → β)} {s : Set α} (hf : f.finite) (hs : s.finite) : (f.seq s).finite := by\n  classical\n    cases hf\n    cases hs\n    apply to_finite\n#align finite.seq finite.seq\n\n",
 "sep":
 "theorem finite.sep {s : Set α} (hs : s.finite) (p : α → Prop) : { a ∈ s | p a }.finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.sep finite.sep\n\n",
 "sUnion":
 "theorem finite.sUnion {s : Set (Set α)} (hs : s.finite) (H : ∀ t ∈ s, Set.Finite t) : (⋃₀ s).finite :=\n  by\n  cases hs\n  haveI := fun i : s => (H i i.2).to_subtype\n  apply to_finite\n#align finite.sUnion finite.sUnion\n\n",
 "sInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem finite.sInter {α : Type _} {s : Set (Set α)} {t : Set α} (ht : t ∈ s) (hf : t.finite) : («expr⋂₀ » s).finite :=\n  hf.subset (interₛ_subset_of_mem ht)\n#align finite.sInter finite.sInter\n\n",
 "prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\nprotected theorem infinite.prod_right (ht : t.infinite) (hs : s.nonempty) : (finset.product s t).infinite := fun h =>\n  ht <| h.of_prod_right hs\n#align infinite.prod_right infinite.prod_right\n\n",
 "prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\nprotected theorem infinite.prod_left (hs : s.infinite) (ht : t.nonempty) : (finset.product s t).infinite := fun h =>\n  hs <| h.of_prod_left ht\n#align infinite.prod_left infinite.prod_left\n\n",
 "prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\nprotected theorem finite.prod (hs : s.finite) (ht : t.finite) : (finset.product s t : Set (α × β)).finite :=\n  by\n  cases hs\n  cases ht\n  apply to_finite\n#align finite.prod finite.prod\n\n",
 "preimage_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite.preimage_embedding {s : Set β} (f : «expr ↪ » α β) (h : s.finite) : («expr ⁻¹' » f s).finite :=\n  h.preimage fun _ _ _ _ h' => f.injective h'\n#align finite.preimage_embedding finite.preimage_embedding\n\n",
 "preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite.preimage {s : Set β} {f : α → β} (I : Set.InjOn f («expr ⁻¹' » f s)) (h : s.finite) :\n    («expr ⁻¹' » f s).finite :=\n  (h.subset (image_preimage_subset f s)).of_finite_image I\n#align finite.preimage finite.preimage\n\n",
 "pi":
 "/-- Finite product of finite sets is finite -/\ntheorem finite.pi {δ : Type _} [Finite δ] {κ : δ → Type _} {t : ∀ d, Set (κ d)} (ht : ∀ d, (t d).finite) :\n    (pi univ t).finite := by\n  cases nonempty_fintype δ\n  lift t to ∀ d, Finset (κ d) using ht\n  classical\n    rw [← Fintype.coe_piFinset]\n    apply Finset.finite_toSet\n#align finite.pi finite.pi\n\n",
 "off_diag":
 "protected theorem finite.off_diag (hs : s.finite) : s.off_diag.finite := by\n  classical\n    cases hs\n    apply Set.toFinite\n#align finite.off_diag finite.off_diag\n\n",
 "of_subsingleton":
 "#print Finite.of_subsingleton /-\n@[nontriviality]\ntheorem Finite.of_subsingleton [subsingleton α] (s : Set α) : s.finite :=\n  s.to_finite\n#align finite.of_subsingleton Finite.of_subsingleton\n-/\n\n",
 "of_prod_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem finite.of_prod_right (h : (finset.product s t : Set (α × β)).finite) : s.nonempty → t.finite := fun ⟨a, ha⟩ =>\n  (h.image Prod.snd).subset fun b hb => ⟨(a, b), ⟨ha, hb⟩, rfl⟩\n#align finite.of_prod_right finite.of_prod_right\n\n",
 "of_prod_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem finite.of_prod_left (h : (finset.product s t : Set (α × β)).finite) : t.nonempty → s.finite := fun ⟨b, hb⟩ =>\n  (h.image Prod.fst).subset fun a ha => ⟨(a, b), ⟨ha, hb⟩, rfl⟩\n#align finite.of_prod_left finite.of_prod_left\n\n",
 "of_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite.of_preimage {f : α → β} {s : Set β} (h : («expr ⁻¹' » f s).finite) (hf : surjective f) : s.finite :=\n  hf.image_preimage s ▸ h.image _\n#align finite.of_preimage finite.of_preimage\n\n",
 "of_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem infinite.of_image (f : α → β) {s : Set α} (hs : («expr '' » f s).infinite) : s.infinite :=\n  mt (Finite.image f) hs\n#align infinite.of_image infinite.of_image\n\n",
 "of_forall_not_lt_lt":
 "#print Finite.of_forall_not_lt_lt /-\n/-- If a linear order does not contain any triple of elements `x < y < z`, then this type\nis finite. -/\ntheorem Finite.of_forall_not_lt_lt (h : ∀ ⦃x y z : α⦄, x < y → y < z → False) : Finite α :=\n  by\n  nontriviality α\n  rcases exists_pair_ne α with ⟨x, y, hne⟩\n  refine' @Finite.of_fintype α ⟨{x, y}, fun z => _⟩\n  simpa [hne] using eq_or_eq_or_eq_of_forall_not_lt_lt h z x y\n#align finite.of_forall_not_lt_lt Finite.of_forall_not_lt_lt\n-/\n\n",
 "of_finset":
 "/-- Construct a `finite` instance for a `set` from a `finset` with the same elements. -/\nprotected theorem finite.of_finset {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) : p.finite :=\n  ⟨Fintype.ofFinset s H⟩\n#align finite.of_finset finite.of_finset\n\n",
 "of_finite_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite.of_finite_image {s : Set α} {f : α → β} (h : («expr '' » f s).finite) (hi : Set.InjOn f s) : s.finite :=\n  by\n  cases h\n  exact\n    ⟨Fintype.ofInjective (fun a => (⟨f a.1, mem_image_of_mem f a.2⟩ : «expr '' » f s)) fun a b eq =>\n        Subtype.eq <| hi a.2 b.2 <| Subtype.ext_iff_val.1 Eq⟩\n#align finite.of_finite_image finite.of_finite_image\n\n",
 "of_diff":
 "theorem finite.of_diff {s t : Set α} (hd : (s \\ t).finite) (ht : t.finite) : s.finite :=\n  (hd.union ht).subset <| subset_diff_union _ _\n#align finite.of_diff finite.of_diff\n\n",
 "not_inj_on_infinite_finite_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem not_inj_on_infinite_finite_image {f : α → β} {s : Set α} (h_inf : s.infinite)\n    (h_fin : («expr '' » f s).finite) : ¬InjOn f s :=\n  by\n  haveI : Finite («expr '' » f s) := finite_coe_iff.mpr h_fin\n  haveI : Infinite s := infinite_coe_iff.mpr h_inf\n  have := not_injective_infinite_finite ((«expr '' » f s).cod_restrict (s.restrict f) fun x => ⟨x, x.property, rfl⟩)\n  contrapose! this\n  rwa [injective_cod_restrict, ← inj_on_iff_injective]\n#align not_inj_on_infinite_finite_image not_inj_on_infinite_finite_image\n\n",
 "not_infinite":
 "@[simp]\ntheorem not_infinite {s : Set α} : ¬s.infinite ↔ s.finite :=\n  Classical.not_not\n#align not_infinite not_infinite\n\n",
 "nonempty":
 "#print Infinite.nonempty /-\nprotected theorem Infinite.nonempty {s : Set α} (h : s.infinite) : s.nonempty :=\n  nonempty_iff_ne_empty.2 <| by\n    rintro rfl\n    exact h finite_empty\n#align infinite.nonempty Infinite.nonempty\n-/\n\n",
 "mono":
 "protected theorem infinite.mono {s t : Set α} (h : s ⊆ t) : s.infinite → t.infinite :=\n  mt fun ht => ht.subset h\n#align infinite.mono infinite.mono\n\n",
 "mem_to_finset":
 "@[simp]\nprotected theorem mem_to_finset (h : s.finite) : a ∈ h.to_finset ↔ a ∈ s :=\n  @mem_toFinset _ _ h.fintype _\n#align mem_to_finset mem_to_finset\n\n",
 "map":
 "theorem finite.map {α β} {s : Set α} : ∀ f : α → β, s.finite → (f <$> s).finite :=\n  Finite.image\n#align finite.map finite.map\n\n",
 "inter_of_right":
 "theorem finite.inter_of_right {s : Set α} (hs : s.finite) (t : Set α) : (t ∩ s).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.inter_of_right finite.inter_of_right\n\n",
 "inter_of_left":
 "theorem finite.inter_of_left {s : Set α} (hs : s.finite) (t : Set α) : (s ∩ t).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.inter_of_left finite.inter_of_left\n\n",
 "insert":
 "@[simp]\ntheorem finite.insert (a : α) {s : Set α} (hs : s.finite) : (insert a s).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.insert finite.insert\n\n",
 "infinite_univ_iff":
 "theorem infinite_univ_iff : (@univ α).infinite ↔ Infinite α := by\n  rw [Set.Infinite, finite_univ_iff, not_finite_iff_infinite]\n#align infinite_univ_iff infinite_univ_iff\n\n",
 "infinite_univ":
 "theorem infinite_univ [h : Infinite α] : (@univ α).infinite :=\n  infinite_univ_iff.2 h\n#align infinite_univ infinite_univ\n\n",
 "infinite_union":
 "@[simp]\ntheorem infinite_union {s t : Set α} : (s ∪ t).infinite ↔ s.infinite ∨ t.infinite := by\n  simp only [Set.Infinite, finite_union, not_and_or]\n#align infinite_union infinite_union\n\n",
 "infinite_range_of_injective":
 "theorem infinite_range_of_injective [Infinite α] {f : α → β} (hi : injective f) : (range f).infinite :=\n  by\n  rw [← image_univ, infinite_image_iff (inj_on_of_injective hi _)]\n  exact infinite_univ\n#align infinite_range_of_injective infinite_range_of_injective\n\n",
 "infinite_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n#print infinite_prod /-\nprotected theorem infinite_prod : (finset.product s t).infinite ↔ s.infinite ∧ t.nonempty ∨ t.infinite ∧ s.nonempty :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · simp_rw [Set.Infinite, and_comm' ¬_, ← not_imp]\n    by_contra'\n    exact h ((this.1 h.nonempty.snd).prod <| this.2 h.nonempty.fst)\n  · rintro (h | h)\n    · exact h.1.prod_left h.2\n    · exact h.1.prod_right h.2\n#align infinite_prod infinite_prod\n-/\n\n",
 "infinite_or_finite":
 "protected theorem infinite_or_finite (s : Set α) : s.infinite ∨ s.finite :=\n  em' _\n#align infinite_or_finite infinite_or_finite\n\n",
 "infinite_of_not_bdd_below":
 "theorem infinite_of_not_bdd_below : ¬BddBelow s → s.infinite :=\n  by\n  contrapose!\n  rw [not_infinite]\n  apply finite.bdd_below\n#align infinite_of_not_bdd_below infinite_of_not_bdd_below\n\n",
 "infinite_of_not_bdd_above":
 "theorem infinite_of_not_bdd_above : ¬BddAbove s → s.infinite :=\n  mt Finite.bddAbove\n#align infinite_of_not_bdd_above infinite_of_not_bdd_above\n\n",
 "infinite_of_injective_forall_mem":
 "theorem infinite_of_injective_forall_mem [Infinite α] {s : Set β} {f : α → β} (hi : injective f)\n    (hf : ∀ x : α, f x ∈ s) : s.infinite := by\n  rw [← range_subset_iff] at hf\n  exact (infinite_range_of_injective hi).mono hf\n#align infinite_of_injective_forall_mem infinite_of_injective_forall_mem\n\n",
 "infinite_of_inj_on_maps_to":
 "theorem infinite_of_inj_on_maps_to {s : Set α} {t : Set β} {f : α → β} (hi : InjOn f s) (hm : MapsTo f s t)\n    (hs : s.infinite) : t.infinite :=\n  ((infinite_image_iff hi).2 hs).mono (mapsTo'.mp hm)\n#align infinite_of_inj_on_maps_to infinite_of_inj_on_maps_to\n\n",
 "infinite_of_forall_exists_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem infinite_of_forall_exists_lt (h : ∀ a, ∃ b ∈ s, b < a) : s.infinite :=\n  @infinite_of_forall_exists_gt («expr ᵒᵈ» α) _ _ _ h\n#align infinite_of_forall_exists_lt infinite_of_forall_exists_lt\n\n",
 "infinite_of_forall_exists_gt":
 "theorem infinite_of_forall_exists_gt (h : ∀ a, ∃ b ∈ s, a < b) : s.infinite :=\n  by\n  inhabit α\n  set f : ℕ → α := fun n => nat.rec_on n (h default).some fun n a => (h a).some\n  have hf : ∀ n, f n ∈ s := by rintro (_ | _) <;> exact (h _).some_spec.some\n  refine' infinite_of_injective_forall_mem (strictMono_nat_of_lt_succ fun n => _).injective hf\n  exact (h _).some_spec.some_spec\n#align infinite_of_forall_exists_gt infinite_of_forall_exists_gt\n\n",
 "infinite_of_finite_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem infinite_of_finite_compl [Infinite α] {s : Set α} (hs : («expr ᶜ» s).finite) : s.infinite := fun h =>\n  Set.infinite_univ (by simpa using hs.union h)\n#align infinite_of_finite_compl infinite_of_finite_compl\n\n",
 "infinite_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem infinite_image_iff {s : Set α} {f : α → β} (hi : InjOn f s) : («expr '' » f s).infinite ↔ s.infinite :=\n  not_congr <| finite_image_iff hi\n#align infinite_image_iff infinite_image_iff\n\n",
 "infinite_image2":
 "theorem infinite_image2 (hfs : ∀ b ∈ t, InjOn (fun a => f a b) s) (hft : ∀ a ∈ s, InjOn (f a) t) :\n    (image2 f s t).infinite ↔ s.infinite ∧ t.nonempty ∨ t.infinite ∧ s.nonempty :=\n  by\n  refine' ⟨fun h => Set.infinite_prod.1 _, _⟩\n  · rw [← image_uncurry_prod] at h\n    exact h.of_image _\n  · rintro (⟨hs, b, hb⟩ | ⟨ht, a, ha⟩)\n    · exact hs.image2_left hb (hfs _ hb)\n    · exact ht.image2_right ha (hft _ ha)\n#align infinite_image2 infinite_image2\n\n",
 "infinite_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem finite.infinite_compl [Infinite α] {s : Set α} (hs : s.finite) : («expr ᶜ» s).infinite := fun h =>\n  Set.infinite_univ (by simpa using hs.union h)\n#align finite.infinite_compl finite.infinite_compl\n\n",
 "infinite_coe_iff":
 "theorem infinite_coe_iff {s : Set α} : Infinite s ↔ s.infinite :=\n  not_finite_iff_infinite.symm.trans finite_coe_iff.not\n#align infinite_coe_iff infinite_coe_iff\n\n",
 "infi_supr_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print Set.infᵢ_supᵢ_of_monotone /-\ntheorem Set.infᵢ_supᵢ_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [Nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Coframe α] {f : ι → ι' → α} (hf : ∀ i, Monotone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  Set.supᵢ_infᵢ_of_antitone fun i => (hf i).dual_right\n#align infi_supr_of_monotone Set.infᵢ_supᵢ_of_monotone\n-/\n\n",
 "infi_supr_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n#print Set.infᵢ_supᵢ_of_antitone /-\ntheorem Set.infᵢ_supᵢ_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [Nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Coframe α] {f : ι → ι' → α} (hf : ∀ i, Antitone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  Set.supᵢ_infᵢ_of_monotone fun i => (hf i).dual_right\n#align infi_supr_of_antitone Set.infᵢ_supᵢ_of_antitone\n-/\n\n",
 "infi_bsupr_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem finite.infi_bsupr_of_monotone {ι ι' α : Type _} [preorder ι'] [Nonempty ι'] [IsDirected ι' (swap (· ≤ ·))]\n    [Order.Coframe α] {s : Set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, Monotone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  hs.supr_binfi_of_antitone fun i hi => (hf i hi).dual_right\n#align finite.infi_bsupr_of_monotone finite.infi_bsupr_of_monotone\n\n",
 "infi_bsupr_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem finite.infi_bsupr_of_antitone {ι ι' α : Type _} [preorder ι'] [Nonempty ι'] [IsDirected ι' (· ≤ ·)]\n    [Order.Coframe α] {s : Set ι} (hs : s.finite) {f : ι → ι' → α} (hf : ∀ i ∈ s, Antitone (f i)) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i j)) :=\n  hs.supr_binfi_of_monotone fun i hi => (hf i hi).dual_right\n#align finite.infi_bsupr_of_antitone finite.infi_bsupr_of_antitone\n\n",
 "inf_of_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem finite.inf_of_right {s : Set α} (h : s.finite) (t : Set α) : («expr ⊓ » t s).finite :=\n  h.inter_of_right t\n#align finite.inf_of_right finite.inf_of_right\n\n",
 "inf_of_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem finite.inf_of_left {s : Set α} (h : s.finite) (t : Set α) : («expr ⊓ » s t).finite :=\n  h.inter_of_left t\n#align finite.inf_of_left finite.inf_of_left\n\n",
 "induction_on'":
 "/-- Analogous to `finset.induction_on'`. -/\n@[elab_as_elim]\ntheorem finite.induction_on' {C : Set α → Prop} {S : Set α} (h : S.finite) (H0 : C ∅)\n    (H1 : ∀ {a s}, a ∈ S → s ⊆ S → a ∉ s → C s → C (insert a s)) : C S :=\n  by\n  refine' @Set.Finite.induction_on α (fun s => s ⊆ S → C s) S h (fun _ => H0) _ subset.rfl\n  intro a s has hsf hCs haS\n  rw [insert_subset] at haS\n  exact H1 haS.1 haS.2 has (hCs haS.2)\n#align finite.induction_on' finite.induction_on'\n\n",
 "induction_on":
 "@[elab_as_elim]\ntheorem finite.induction_on {C : Set α → Prop} {s : Set α} (h : s.finite) (H0 : C ∅)\n    (H1 : ∀ {a s}, a ∉ s → Set.Finite s → C s → C (insert a s)) : C s :=\n  by\n  lift s to Finset α using h\n  induction' s using Finset.cons_induction_on with a s ha hs\n  · rwa [Finset.coe_empty]\n  · rw [Finset.coe_cons]\n    exact @H1 a s ha (Set.toFinite _) hs\n#align finite.induction_on finite.induction_on\n\n",
 "image2_right":
 "protected theorem infinite.image2_right (ht : t.infinite) (ha : a ∈ s) (hf : InjOn (f a) t) : (image2 f s t).infinite :=\n  (ht.image hf).mono <| image_subset_image2_right ha\n#align infinite.image2_right infinite.image2_right\n\n",
 "image2_left":
 "protected theorem infinite.image2_left (hs : s.infinite) (hb : b ∈ t) (hf : InjOn (fun a => f a b) s) :\n    (image2 f s t).infinite :=\n  (hs.image hf).mono <| image_subset_image2_left hb\n#align infinite.image2_left infinite.image2_left\n\n",
 "image2":
 "protected theorem finite.image2 (f : α → β → γ) (hs : s.finite) (ht : t.finite) : (image2 f s t).finite :=\n  by\n  cases hs\n  cases ht\n  apply to_finite\n#align finite.image2 finite.image2\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite.image {s : Set α} (f : α → β) (hs : s.finite) : («expr '' » f s).finite :=\n  by\n  cases hs\n  apply to_finite\n#align finite.image finite.image\n\n",
 "forall_finite_image_eval_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem forall_finite_image_eval_iff {δ : Type _} [Finite δ] {κ : δ → Type _} {s : Set (∀ d, κ d)} :\n    (∀ d, («expr '' » (eval d) s).finite) ↔ s.finite :=\n  ⟨fun h => (Finite.pi h).subset <| subset_pi_eval_image _ _, fun h d => h.image _⟩\n#align forall_finite_image_eval_iff forall_finite_image_eval_iff\n\n",
 "finite_univ_iff":
 "theorem finite_univ_iff : (@univ α).finite ↔ Finite α :=\n  finite_coe_iff.symm.trans (Equiv.Set.univ α).finite_iff\n#align finite_univ_iff finite_univ_iff\n\n",
 "finite_univ":
 "theorem finite_univ [Finite α] : (@univ α).finite :=\n  Set.toFinite _\n#align finite_univ finite_univ\n\n",
 "finite_union":
 "@[simp]\ntheorem finite_union {s t : Set α} : (s ∪ t).finite ↔ s.finite ∧ t.finite :=\n  ⟨fun h => ⟨h.subset (subset_union_left _ _), h.subset (subset_union_right _ _)⟩, fun ⟨hs, ht⟩ => hs.union ht⟩\n#align finite_union finite_union\n\n",
 "finite_to_set_to_finset":
 "@[simp]\ntheorem finite_to_set_to_finset [DecidableEq α] (s : Multiset α) : s.finite_to_set.to_finset = s.to_finset :=\n  by\n  ext x\n  simp\n#align finite_to_set_to_finset finite_to_set_to_finset\n\n",
 "finite_to_set":
 "@[simp]\ntheorem finite_to_set (s : Multiset α) : { x | x ∈ s }.finite := by\n  classical simpa only [← Multiset.mem_toFinset] using s.to_finset.finite_to_set\n#align finite_to_set finite_to_set\n\n",
 "finite_toSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n#print List.finite_toSet /-\n@[simp]\ntheorem List.finite_toSet (l : List α) : { x | x ∈ l }.finite :=\n  (show Multiset α from «expr⟦ ⟧» l).finite_to_set\n#align list.finite_to_set List.finite_toSet\n-/\n\n",
 "finite_subsets":
 "/-- There are finitely many subsets of a given finite set -/\ntheorem finite.finite_subsets {α : Type u} {a : Set α} (h : a.finite) : { b | b ⊆ a }.finite :=\n  ⟨Fintype.ofFinset ((Finset.powerset h.to_finset).map Finset.coeEmb.1) fun s => by\n      simpa [← @exists_finite_iff_finset α fun t => t ⊆ a ∧ t = s, finite.subset_to_finset, ← and_assoc] using h.subset⟩\n#align finite.finite_subsets finite.finite_subsets\n\n",
 "finite_subset_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_subset_Union {s : Set α} (hs : s.finite) {ι} {t : ι → Set α}\n    (h : s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)) :\n    ∃ I : Set ι,\n      I.finite ∧\n        s ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i) :=\n  by\n  cases hs\n  choose f hf using show ∀ x : s, ∃ i, x.1 ∈ t i by simpa [subset_def] using h\n  refine' ⟨range f, finite_range f, fun x hx => _⟩\n  rw [bUnion_range, mem_Union]\n  exact ⟨⟨x, hx⟩, hf _⟩\n#align finite_subset_Union finite_subset_Union\n\n",
 "finite_singleton":
 "@[simp]\ntheorem finite_singleton (a : α) : ({a} : Set α).finite :=\n  toFinite _\n#align finite_singleton finite_singleton\n\n",
 "finite_range_ite":
 "theorem finite_range_ite {p : α → Prop} [DecidablePred p] {f g : α → β} (hf : (range f).finite)\n    (hg : (range g).finite) : (range fun x => if p x then f x else g x).finite :=\n  (hf.union hg).subset range_ite_subset\n#align finite_range_ite finite_range_ite\n\n",
 "finite_range_find_greatest":
 "theorem finite_range_find_greatest {P : α → ℕ → Prop} [∀ x, DecidablePred (P x)] {b : ℕ} :\n    (range fun x => Nat.findGreatest (P x) b).finite :=\n  (finite_le_nat b).subset <| range_subset_iff.2 fun x => Nat.findGreatest_le _\n#align finite_range_find_greatest finite_range_find_greatest\n\n",
 "finite_range_const":
 "theorem finite_range_const {c : β} : (range fun x : α => c).finite :=\n  (finite_singleton c).subset range_const_subset\n#align finite_range_const finite_range_const\n\n",
 "finite_range":
 "theorem finite_range (f : ι → α) [Finite ι] : (range f).finite :=\n  toFinite _\n#align finite_range finite_range\n\n",
 "finite_pure":
 "theorem finite_pure (a : α) : (pure a : Set α).finite :=\n  toFinite _\n#align finite_pure finite_pure\n\n",
 "finite_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem finite_prod : (finset.product s t).finite ↔ (s.finite ∨ t = ∅) ∧ (t.finite ∨ s = ∅) := by\n  simp only [← not_infinite, Set.infinite_prod, not_or, not_and_or, not_nonempty_iff_eq_empty]\n#align finite_prod finite_prod\n\n",
 "finite_preimage_inl_and_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite_preimage_inl_and_inr {s : Set (Sum α β)} :\n    («expr ⁻¹' » Sum.inl s).finite ∧ («expr ⁻¹' » Sum.inr s).finite ↔ s.finite :=\n  ⟨fun h => image_preimage_inl_union_image_preimage_inr s ▸ (h.1.image _).union (h.2.image _), fun h =>\n    ⟨h.preimage (Sum.inl_injective.inj_on _), h.preimage (Sum.inr_injective.inj_on _)⟩⟩\n#align finite_preimage_inl_and_inr finite_preimage_inl_and_inr\n\n",
 "finite_or_infinite":
 "#print finite_or_infinite /-\n/-- See also `finite_or_infinite`, `fintype_or_infinite`. -/\nprotected theorem finite_or_infinite (s : Set α) : s.finite ∨ s.infinite :=\n  em _\n#align finite_or_infinite finite_or_infinite\n-/\n\n",
 "finite_option":
 "theorem finite_option {s : Set (Option α)} : s.finite ↔ { x : α | some x ∈ s }.finite :=\n  ⟨fun h => h.preimage_embedding Embedding.some, fun h =>\n    ((h.image some).insert none).subset fun x =>\n      option.cases_on x (fun _ => or.inl rfl) fun x hx => or.inr <| mem_image_of_mem _ hx⟩\n#align finite_option finite_option\n\n",
 "finite_of_forall_not_lt_lt":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y z «expr ∈ » s) -/\n#print Set.finite_of_forall_not_lt_lt /-\n/-- If a set `s` does not contain any triple of elements `x < y < z`, then `s` is finite. -/\ntheorem Set.finite_of_forall_not_lt_lt {s : Set α}\n    (h : ∀ (x) (_ : x ∈ s) (y) (_ : y ∈ s) (z) (_ : z ∈ s), x < y → y < z → False) : Set.Finite s :=\n  @Set.toFinite _ s <| Finite.of_forall_not_lt_lt <| by simpa only [SetCoe.forall'] using h\n#align set.finite_of_forall_not_lt_lt Set.finite_of_forall_not_lt_lt\n-/\n\n",
 "finite_of_finite_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem finite_of_finite_preimage {f : α → β} {s : Set β} (h : («expr ⁻¹' » f s).finite) (hs : s ⊆ range f) :\n    s.finite := by\n  rw [← image_preimage_eq_of_subset hs]\n  exact finite.image f h\n#align finite_of_finite_preimage finite_of_finite_preimage\n\n",
 "finite_of_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem finite.finite_of_compl {s : Set α} (hs : s.finite) (hsc : («expr ᶜ» s).finite) : Finite α :=\n  by\n  rw [← finite_univ_iff, ← union_compl_self s]\n  exact hs.union hsc\n#align finite.finite_of_compl finite.finite_of_compl\n\n",
 "finite_mem_finset":
 "theorem finite_mem_finset (s : Finset α) : { a | a ∈ s }.finite :=\n  toFinite _\n#align finite_mem_finset finite_mem_finset\n\n",
 "finite_lt_nat":
 "theorem finite_lt_nat (n : ℕ) : Set.Finite { i | i < n } :=\n  toFinite _\n#align finite_lt_nat finite_lt_nat\n\n",
 "finite_le_nat":
 "theorem finite_le_nat (n : ℕ) : Set.Finite { i | i ≤ n } :=\n  toFinite _\n#align finite_le_nat finite_le_nat\n\n",
 "finite_is_top":
 "theorem finite_is_top (α : Type _) [partial_order α] : { x : α | IsTop x }.finite :=\n  (subsingleton_isTop α).finite\n#align finite_is_top finite_is_top\n\n",
 "finite_is_bot":
 "theorem finite_is_bot (α : Type _) [partial_order α] : { x : α | IsBot x }.finite :=\n  (subsingleton_isBot α).finite\n#align finite_is_bot finite_is_bot\n\n",
 "finite_image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite_image_iff {s : Set α} {f : α → β} (hi : InjOn f s) : («expr '' » f s).finite ↔ s.finite :=\n  ⟨fun h => h.of_finite_image hi, Finite.image _⟩\n#align finite_image_iff finite_image_iff\n\n",
 "finite_image_fst_and_snd_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem finite_image_fst_and_snd_iff {s : Set (α × β)} :\n    («expr '' » Prod.fst s).finite ∧ («expr '' » Prod.snd s).finite ↔ s.finite :=\n  ⟨fun h => (h.1.prod h.2).subset fun x h => ⟨mem_image_of_mem _ h, mem_image_of_mem _ h⟩, fun h =>\n    ⟨h.image _, h.image _⟩⟩\n#align finite_image_fst_and_snd_iff finite_image_fst_and_snd_iff\n\n",
 "finite_empty":
 "@[simp]\ntheorem finite_empty : (∅ : Set α).finite :=\n  toFinite _\n#align finite_empty finite_empty\n\n",
 "finite_diff_unionᵢ_Ioo'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Set.finite_diff_unionᵢ_Ioo' /-\ntheorem Set.finite_diff_unionᵢ_Ioo' (s : Set α) :\n    (s \\\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (Ioo x.1 x.2)).finite :=\n  by simpa only [Union, supᵢ_prod, supᵢ_subtype] using s.finite_diff_Union_Ioo\n#align set.finite_diff_Union_Ioo' Set.finite_diff_unionᵢ_Ioo'\n-/\n\n",
 "finite_diff_unionᵢ_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print Set.finite_diff_unionᵢ_Ioo /-\ntheorem Set.finite_diff_unionᵢ_Ioo (s : Set α) :\n    (s \\\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (Ioo x y)).finite :=\n  Set.finite_of_forall_not_lt_lt fun x hx y hy z hz hxy hyz =>\n    hy.2 <| mem_unionᵢ₂_of_mem hx.1 <| mem_unionᵢ₂_of_mem hz.1 ⟨hxy, hyz⟩\n#align set.finite_diff_Union_Ioo Set.finite_diff_unionᵢ_Ioo\n-/\n\n",
 "finite_def":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Kyle Miller\n-/\n-- The `protected` attribute does not take effect within the same namespace block.\ntheorem finite_def {s : Set α} : s.finite ↔ Nonempty (Fintype s) :=\n  ⟨fun ⟨h⟩ => ⟨h⟩, fun ⟨h⟩ => ⟨h⟩⟩\n#align finite_def finite_def\n\n",
 "finite_coe_iff":
 "theorem finite_coe_iff {s : Set α} : Finite s ↔ s.finite := by rw [finite_iff_nonempty_fintype, finite_def]\n#align finite_coe_iff finite_coe_iff\n\n",
 "finite_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_bUnion {ι : Type _} (s : Set ι) [Finite s] (t : ι → Set α) (H : ∀ i ∈ s, Finite (t i)) :\n    Finite («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t x)) :=\n  by\n  rw [bUnion_eq_Union]\n  haveI : ∀ i : s, Finite (t i) := fun i => H i i.property\n  infer_instance\n#align finite_bUnion finite_bUnion\n\n",
 "finite_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite_Union [Finite ι] {f : ι → Set α} (H : ∀ i, (f i).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i)).finite :=\n  by\n  haveI := fun i => (H i).fintype\n  apply to_finite\n#align finite_Union finite_Union\n\n",
 "finite":
 "theorem subsingleton.finite {s : Set α} (h : s.subsingleton) : s.finite :=\n  h.induction_on finite_empty finite_singleton\n#align subsingleton.finite subsingleton.finite\n\n",
 "fin_param":
 "theorem finite.fin_param {s : Set α} (h : s.finite) : ∃ (n : ℕ)(f : Fin n → α), injective f ∧ range f = s :=\n  let ⟨n, f, hf⟩ := h.fin_embedding\n  ⟨n, f, f.injective, hf⟩\n#align finite.fin_param finite.fin_param\n\n",
 "fin_embedding":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem finite.fin_embedding {s : Set α} (h : s.finite) : ∃ (n : ℕ)(f : «expr ↪ » (Fin n) α), range f = s :=\n  ⟨_, (Fintype.equivFin (h.to_finset : Set α)).symm.as_embedding, by simp⟩\n#align finite.fin_embedding finite.fin_embedding\n\n",
 "exists_upper_bound_image":
 "theorem exists_upper_bound_image [hα : Nonempty α] [linear_order β] (s : Set α) (f : α → β) (h : s.finite) :\n    ∃ a : α, ∀ b ∈ s, f b ≤ f a := by\n  by_cases hs : Set.Nonempty s\n  ·\n    exact\n      let ⟨x₀, H, hx₀⟩ := Set.exists_max_image s f h hs\n      ⟨x₀, fun x hx => hx₀ x hx⟩\n  · exact Nonempty.elim hα fun a => ⟨a, fun x hx => absurd (Set.nonempty_of_mem hx) hs⟩\n#align exists_upper_bound_image exists_upper_bound_image\n\n",
 "exists_subset_card_eq":
 "#print Infinite.exists_subset_card_eq /-\ntheorem Infinite.exists_subset_card_eq {s : Set α} (hs : s.infinite) (n : ℕ) : ∃ t : Finset α, ↑t ⊆ s ∧ t.card = n :=\n  ⟨((Finset.range n).map (hs.nat_embedding _)).map (Embedding.subtype _), by simp⟩\n#align infinite.exists_subset_card_eq Infinite.exists_subset_card_eq\n-/\n\n",
 "exists_not_mem_finset":
 "#print Infinite.exists_not_mem_finset /-\ntheorem Infinite.exists_not_mem_finset {s : Set α} (hs : s.infinite) (f : Finset α) : ∃ a ∈ s, a ∉ f :=\n  let ⟨a, has, haf⟩ := (hs.diff (toFinite f)).nonempty\n  ⟨a, has, fun h => haf <| Finset.mem_coe.1 h⟩\n#align infinite.exists_not_mem_finset Infinite.exists_not_mem_finset\n-/\n\n",
 "exists_ne_map_eq_of_maps_to":
 "theorem infinite.exists_ne_map_eq_of_maps_to {s : Set α} {t : Set β} {f : α → β} (hs : s.infinite) (hf : MapsTo f s t)\n    (ht : t.finite) : ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ f x = f y :=\n  by\n  contrapose! ht\n  exact infinite_of_inj_on_maps_to (fun x hx y hy => not_imp_not.1 (ht x hx y hy)) hf hs\n#align infinite.exists_ne_map_eq_of_maps_to infinite.exists_ne_map_eq_of_maps_to\n\n",
 "exists_min_image":
 "theorem exists_min_image [linear_order β] (s : Set α) (f : α → β) (h1 : s.finite) :\n    s.nonempty → ∃ a ∈ s, ∀ b ∈ s, f a ≤ f b\n  | ⟨x, hx⟩ => by\n    simpa only [exists_prop, finite.mem_to_finset] using h1.to_finset.exists_min_image f ⟨x, h1.mem_to_finset.2 hx⟩\n#align exists_min_image exists_min_image\n\n",
 "exists_maximal_wrt":
 "theorem finite.exists_maximal_wrt [partial_order β] (f : α → β) (s : Set α) (h : Set.Finite s) :\n    s.nonempty → ∃ a ∈ s, ∀ a' ∈ s, f a ≤ f a' → f a = f a' :=\n  by\n  refine' h.induction_on _ _\n  · exact fun h => absurd h not_nonempty_empty\n  intro a s his _ ih _\n  cases' s.eq_empty_or_nonempty with h h\n  · use a\n    simp [h]\n  rcases ih h with ⟨b, hb, ih⟩\n  by_cases f b ≤ f a\n  · refine' ⟨a, Set.mem_insert _ _, fun c hc hac => le_antisymm hac _⟩\n    rcases Set.mem_insert_iff.1 hc with (rfl | hcs)\n    · rfl\n    · rwa [← ih c hcs (le_trans h hac)]\n  · refine' ⟨b, Set.mem_insert_of_mem _ hb, fun c hc hbc => _⟩\n    rcases Set.mem_insert_iff.1 hc with (rfl | hcs)\n    · exact (h hbc).elim\n    · exact ih c hcs hbc\n#align finite.exists_maximal_wrt finite.exists_maximal_wrt\n\n",
 "exists_max_image":
 "theorem exists_max_image [linear_order β] (s : Set α) (f : α → β) (h1 : s.finite) :\n    s.nonempty → ∃ a ∈ s, ∀ b ∈ s, f b ≤ f a\n  | ⟨x, hx⟩ => by\n    simpa only [exists_prop, finite.mem_to_finset] using h1.to_finset.exists_max_image f ⟨x, h1.mem_to_finset.2 hx⟩\n#align exists_max_image exists_max_image\n\n",
 "exists_lt_map_eq_of_maps_to":
 "theorem infinite.exists_lt_map_eq_of_maps_to [linear_order α] {s : Set α} {t : Set β} {f : α → β} (hs : s.infinite)\n    (hf : MapsTo f s t) (ht : t.finite) : ∃ x ∈ s, ∃ y ∈ s, x < y ∧ f x = f y :=\n  let ⟨x, hx, y, hy, hxy, hf⟩ := hs.exists_ne_map_eq_of_maps_to hf ht\n  hxy.lt_or_lt.elim (fun hxy => ⟨x, hx, y, hy, hxy, hf⟩) fun hyx => ⟨y, hy, x, hx, hyx, hf.symm⟩\n#align infinite.exists_lt_map_eq_of_maps_to infinite.exists_lt_map_eq_of_maps_to\n\n",
 "exists_lt_map_eq_of_forall_mem":
 "theorem finite.exists_lt_map_eq_of_forall_mem [linear_order α] [Infinite α] {t : Set β} {f : α → β} (hf : ∀ a, f a ∈ t)\n    (ht : t.finite) : ∃ a b, a < b ∧ f a = f b :=\n  by\n  rw [← maps_univ_to] at hf\n  obtain ⟨a, -, b, -, h⟩ := (@infinite_univ α _).exists_lt_map_eq_of_maps_to hf ht\n  exact ⟨a, b, h⟩\n#align finite.exists_lt_map_eq_of_forall_mem finite.exists_lt_map_eq_of_forall_mem\n\n",
 "exists_lower_bound_image":
 "theorem exists_lower_bound_image [hα : Nonempty α] [linear_order β] (s : Set α) (f : α → β) (h : s.finite) :\n    ∃ a : α, ∀ b ∈ s, f a ≤ f b := by\n  by_cases hs : Set.Nonempty s\n  ·\n    exact\n      let ⟨x₀, H, hx₀⟩ := Set.exists_min_image s f h hs\n      ⟨x₀, fun x hx => hx₀ x hx⟩\n  · exact Nonempty.elim hα fun a => ⟨a, fun x hx => absurd (Set.nonempty_of_mem hx) hs⟩\n#align exists_lower_bound_image exists_lower_bound_image\n\n",
 "exists_finset_coe":
 "theorem finite.exists_finset_coe {s : Set α} (h : s.finite) : ∃ s' : Finset α, ↑s' = s :=\n  by\n  cases h\n  exact ⟨s.to_finset, s.coe_to_finset⟩\n#align finite.exists_finset_coe finite.exists_finset_coe\n\n",
 "exists_finset":
 "theorem finite.exists_finset {s : Set α} (h : s.finite) : ∃ s' : Finset α, ∀ a : α, a ∈ s' ↔ a ∈ s :=\n  by\n  cases h\n  exact ⟨s.to_finset, fun _ => mem_to_finset⟩\n#align finite.exists_finset finite.exists_finset\n\n",
 "exists_finite_iff_finset":
 "theorem exists_finite_iff_finset {p : Set α → Prop} : (∃ s : Set α, s.finite ∧ p s) ↔ ∃ s : Finset α, p ↑s :=\n  ⟨fun ⟨s, hs, hps⟩ => ⟨hs.to_finset, hs.coe_to_finset.symm ▸ hps⟩, fun ⟨s, hs⟩ => ⟨s, s.finite_to_set, hs⟩⟩\n#align exists_finite_iff_finset exists_finite_iff_finset\n\n",
 "eq_of_subset_of_card_le":
 "theorem eq_of_subset_of_card_le {s t : Set α} [Fintype s] [Fintype t] (hsub : s ⊆ t)\n    (hcard : Fintype.card t ≤ Fintype.card s) : s = t :=\n  (eq_or_ssubset_of_subset hsub).elim id fun h => absurd hcard <| not_le_of_lt <| card_lt_card h\n#align eq_of_subset_of_card_le eq_of_subset_of_card_le\n\n",
 "eq_finite_Union_of_finite_subset_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem eq_finite_Union_of_finite_subset_Union {ι} {s : ι → Set α} {t : Set α} (tfin : t.finite)\n    (h : t ⊆ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) :\n    ∃ I : Set ι,\n      I.finite ∧\n        ∃ σ : { i | i ∈ I } → Set α,\n          (∀ i, (σ i).finite) ∧\n            (∀ i, σ i ⊆ s i) ∧\n              t =\n                «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (σ i) :=\n  let ⟨I, Ifin, hI⟩ := finite_subset_unionᵢ tfin h\n  ⟨I, Ifin, fun x => s x ∩ t, fun i => tfin.subset (inter_subset_right _ _), fun i => inter_subset_left _ _,\n    by\n    ext x\n    rw [mem_Union]\n    constructor\n    · intro x_in\n      rcases mem_Union.mp (hI x_in) with ⟨i, _, ⟨hi, rfl⟩, H⟩\n      use i, hi, H, x_in\n    · rintro ⟨i, hi, H⟩\n      exact H⟩\n#align eq_finite_Union_of_finite_subset_Union eq_finite_Union_of_finite_subset_Union\n\n",
 "empty_card'":
 "@[simp]\ntheorem empty_card' {h : Fintype.{u} (∅ : Set α)} : @Fintype.card (∅ : Set α) h = 0 :=\n  Eq.trans (by congr ) empty_card\n#align empty_card' empty_card'\n\n",
 "empty_card":
 "theorem empty_card : Fintype.card (∅ : Set α) = 0 :=\n  rfl\n#align empty_card empty_card\n\n",
 "disjoint_to_finset":
 "@[simp]\ntheorem disjoint_to_finset {hs : s.finite} {ht : t.finite} : Disjoint hs.to_finset ht.to_finset ↔ Disjoint s t :=\n  @disjoint_toFinset _ _ _ hs.fintype ht.fintype\n#align disjoint_to_finset disjoint_to_finset\n\n",
 "dinduction_on":
 "@[elab_as_elim]\ntheorem finite.dinduction_on {C : ∀ s : Set α, s.finite → Prop} {s : Set α} (h : s.finite) (H0 : C ∅ finite_empty)\n    (H1 : ∀ {a s}, a ∉ s → ∀ h : Set.Finite s, C s h → C (insert a s) (h.insert a)) : C s h :=\n  have : ∀ h : s.finite, C s h := Finite.induction_on h (fun h => H0) fun a s has hs ih h => H1 has hs (ih _)\n  this h\n#align finite.dinduction_on finite.dinduction_on\n\n",
 "diff":
 "theorem infinite.diff {s t : Set α} (hs : s.infinite) (ht : t.finite) : (s \\ t).infinite := fun h => hs <| h.of_diff ht\n#align infinite.diff infinite.diff\n\n",
 "dependent_image":
 "theorem finite.dependent_image {s : Set α} (hs : s.finite) (F : ∀ i ∈ s, β) :\n    { y : β | ∃ (x : _)(hx : x ∈ s), y = F x hx }.finite :=\n  by\n  cases hs\n  simpa [range, eq_comm] using finite_range fun x : s => F x x.2\n#align finite.dependent_image finite.dependent_image\n\n",
 "coe_to_finset":
 "@[simp]\nprotected theorem coe_to_finset (h : s.finite) : (h.to_finset : Set α) = s :=\n  @coe_toFinset _ _ h.fintype\n#align coe_to_finset coe_to_finset\n\n",
 "coe_sort_to_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- Note that this is an equality of types not holding definitionally. Use wisely. -/\ntheorem coe_sort_to_finset (h : s.finite) : «expr↥ » h.to_finset = «expr↥ » s := by\n  rw [← Finset.coe_sort_coe _, h.coe_to_finset]\n#align coe_sort_to_finset coe_sort_to_finset\n\n",
 "card_to_finset":
 "theorem finite.card_to_finset {s : Set α} [Fintype s] (h : s.finite) : h.to_finset.card = Fintype.card s :=\n  by\n  rw [← Finset.card_attach, Finset.attach_eq_univ, ← Fintype.card]\n  refine' Fintype.card_congr (Equiv.setCongr _)\n  ext x\n  show x ∈ h.to_finset ↔ x ∈ s\n  simp\n#align finite.card_to_finset finite.card_to_finset\n\n",
 "card_singleton":
 "@[simp]\ntheorem card_singleton (a : α) : Fintype.card ({a} : Set α) = 1 :=\n  Fintype.card_ofSubsingleton _\n#align card_singleton card_singleton\n\n",
 "card_range_of_injective":
 "theorem card_range_of_injective [Fintype α] {f : α → β} (hf : injective f) [Fintype (range f)] :\n    Fintype.card (range f) = Fintype.card α :=\n  Eq.symm <| Fintype.card_congr <| Equiv.ofInjective f hf\n#align card_range_of_injective card_range_of_injective\n\n",
 "card_ne_eq":
 "theorem card_ne_eq [Fintype α] (a : α) [Fintype { x : α | x ≠ a }] :\n    Fintype.card { x : α | x ≠ a } = Fintype.card α - 1 :=\n  by\n  haveI := Classical.decEq α\n  rw [← to_finset_card, to_finset_set_of, Finset.filter_ne', Finset.card_erase_of_mem (Finset.mem_univ _),\n    Finset.card_univ]\n#align card_ne_eq card_ne_eq\n\n",
 "card_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem card_lt_card {s t : Set α} [Fintype s] [Fintype t] (h : «expr ⊂ » s t) : Fintype.card s < Fintype.card t :=\n  Fintype.card_lt_of_injective_not_surjective (Set.inclusion h.1) (Set.inclusion_injective h.1) fun hst =>\n    (ssubset_iff_subset_ne.1 h).2 (eq_of_inclusion_surjective hst)\n#align card_lt_card card_lt_card\n\n",
 "card_le_of_subset":
 "theorem card_le_of_subset {s t : Set α} [Fintype s] [Fintype t] (hsub : s ⊆ t) : Fintype.card s ≤ Fintype.card t :=\n  Fintype.card_le_of_injective (Set.inclusion hsub) (Set.inclusion_injective hsub)\n#align card_le_of_subset card_le_of_subset\n\n",
 "card_insert":
 "@[simp]\ntheorem card_insert {a : α} (s : Set α) [Fintype s] (h : a ∉ s) {d : Fintype.{u} (insert a s : Set α)} :\n    @Fintype.card _ d = Fintype.card s + 1 := by rw [← card_fintype_insert_of_not_mem s h] <;> congr\n#align card_insert card_insert\n\n",
 "card_image_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem card_image_of_injective (s : Set α) [Fintype s] {f : α → β} [Fintype («expr '' » f s)]\n    (H : function.injective f) : Fintype.card («expr '' » f s) = Fintype.card s :=\n  card_image_of_inj_on fun _ _ _ _ h => H h\n#align card_image_of_injective card_image_of_injective\n\n",
 "card_image_of_inj_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem card_image_of_inj_on {s : Set α} [Fintype s] {f : α → β} [Fintype («expr '' » f s)]\n    (H : ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) : Fintype.card («expr '' » f s) = Fintype.card s :=\n  haveI := classical.prop_decidable\n  calc\n    Fintype.card («expr '' » f s) = (s.to_finset.image f).card := Fintype.card_of_finset' _ (by simp)\n    _ = s.to_finset.card :=\n      (Finset.card_image_of_injOn fun x hx y hy hxy => H x (mem_to_finset.1 hx) y (mem_to_finset.1 hy) hxy)\n    _ = Fintype.card s := (Fintype.card_of_finset' _ fun a => mem_to_finset).symm\n    \n#align card_image_of_inj_on card_image_of_inj_on\n\n",
 "card_fintype_insert_of_not_mem":
 "theorem card_fintype_insert_of_not_mem {a : α} (s : Set α) [Fintype s] (h : a ∉ s) :\n    @Fintype.card _ (fintypeInsertOfNotMem s h) = Fintype.card s + 1 := by\n  rw [fintype_insert_of_not_mem, Fintype.card_ofFinset] <;> simp [Finset.card, to_finset] <;> rfl\n#align card_fintype_insert_of_not_mem card_fintype_insert_of_not_mem\n\n",
 "bind":
 "theorem finite.bind {α β} {s : Set α} {f : α → Set β} (h : s.finite) (hf : ∀ a ∈ s, (f a).finite) : (s >>= f).finite :=\n  h.bUnion hf\n#align finite.bind finite.bind\n\n",
 "bdd_below_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of sets which are all bounded below is still bounded below.-/\ntheorem finite.bdd_below_bUnion {I : Set β} {S : β → Set α} (H : I.finite) :\n    BddBelow («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i)) ↔\n      ∀ i ∈ I, BddBelow (S i) :=\n  @Finite.bddAbove_bunionᵢ («expr ᵒᵈ» α) _ _ _ _ _ H\n#align finite.bdd_below_bUnion finite.bdd_below_bUnion\n\n",
 "bdd_below":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/-- A finite set is bounded below.-/\nprotected theorem finite.bdd_below (hs : s.finite) : BddBelow s :=\n  @Finite.bddAbove («expr ᵒᵈ» α) _ _ _ hs\n#align finite.bdd_below finite.bdd_below\n\n",
 "bdd_above_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A finite union of sets which are all bounded above is still bounded above.-/\ntheorem finite.bdd_above_bUnion {I : Set β} {S : β → Set α} (H : I.finite) :\n    BddAbove («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i)) ↔\n      ∀ i ∈ I, BddAbove (S i) :=\n  Finite.induction_on H (by simp only [bUnion_empty, bddAbove_empty, ball_empty_iff]) fun a s ha _ hs => by\n    simp only [bUnion_insert, ball_insert_iff, bddAbove_union, hs]\n#align finite.bdd_above_bUnion finite.bdd_above_bUnion\n\n",
 "bdd_above":
 "/-- A finite set is bounded above.-/\nprotected theorem finite.bdd_above (hs : s.finite) : BddAbove s :=\n  Finite.induction_on hs bddAbove_empty fun a s _ _ h => h.insert a\n#align finite.bdd_above finite.bdd_above\n\n",
 "bUnion'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- Dependent version of `finite.bUnion`. -/\ntheorem finite.bUnion' {ι} {s : Set ι} (hs : s.finite) {t : ∀ i ∈ s, Set α} (ht : ∀ i ∈ s, (t i ‹_›).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (t i ‹_›)).finite :=\n  by\n  cases hs\n  rw [bUnion_eq_Union]\n  apply finite_Union fun i : s => ht i.1 i.2\n#align finite.bUnion' finite.bUnion'\n\n",
 "bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem finite.bUnion {ι} {s : Set ι} (hs : s.finite) {t : ι → Set α} (ht : ∀ i ∈ s, (t i).finite) :\n    («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t i)).finite := by\n  classical\n    cases hs\n    haveI := fintype_bUnion s t fun i hi => (ht i hi).fintype\n    apply to_finite\n#align finite.bUnion finite.bUnion\n\n",
 "Union_univ_pi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_univ_pi_of_monotone {ι ι' : Type _} [linear_order ι'] [Nonempty ι'] [Finite ι] {α : ι → Type _}\n    {s : ∀ i, ι' → Set (α i)} (hs : ∀ i, Monotone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (pi univ fun i => s i j) =\n      pi univ fun i =>\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j) :=\n  unionᵢ_pi_of_monotone finite_univ fun i _ => hs i\n#align Union_univ_pi_of_monotone Union_univ_pi_of_monotone\n\n",
 "Union_pi_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem Union_pi_of_monotone {ι ι' : Type _} [linear_order ι'] [Nonempty ι'] {α : ι → Type _} {I : Set ι}\n    {s : ∀ i, ι' → Set (α i)} (hI : I.finite) (hs : ∀ i ∈ I, Monotone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (I.pi fun i => s i j) =\n      I.pi fun i =>\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j) :=\n  by\n  simp only [pi_def, bInter_eq_Inter, preimage_Union]\n  haveI := hI.fintype\n  exact Union_Inter_of_monotone fun i j₁ j₂ h => preimage_mono <| hs i i.2 h\n#align Union_pi_of_monotone Union_pi_of_monotone\n\n",
 "Union_Inter_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- An increasing union distributes over finite intersection. -/\ntheorem Union_Inter_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (· ≤ ·)] [Nonempty ι']\n    {s : ι → ι' → Set α} (hs : ∀ i, Monotone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) :=\n  Set.supᵢ_infᵢ_of_monotone hs\n#align Union_Inter_of_monotone Union_Inter_of_monotone\n\n",
 "Union_Inter_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- A decreasing union distributes over finite intersection. -/\ntheorem Union_Inter_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (swap (· ≤ ·))] [Nonempty ι']\n    {s : ι → ι' → Set α} (hs : ∀ i, Antitone (s i)) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) :=\n  Set.supᵢ_infᵢ_of_antitone hs\n#align Union_Inter_of_antitone Union_Inter_of_antitone\n\n",
 "Inter_Union_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- An increasing intersection distributes over finite union. -/\ntheorem Inter_Union_of_monotone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (swap (· ≤ ·))] [Nonempty ι']\n    {s : ι → ι' → Set α} (hs : ∀ i, Monotone (s i)) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) :=\n  Set.infᵢ_supᵢ_of_monotone hs\n#align Inter_Union_of_monotone Inter_Union_of_monotone\n\n",
 "Inter_Union_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/-- A decreasing intersection distributes over finite union. -/\ntheorem Inter_Union_of_antitone {ι ι' α : Type _} [Finite ι] [preorder ι'] [IsDirected ι' (· ≤ ·)] [Nonempty ι']\n    {s : ι → ι' → Set α} (hs : ∀ i, Antitone (s i)) :\n    «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i j)) :=\n  Set.infᵢ_supᵢ_of_antitone hs\n#align Inter_Union_of_antitone Inter_Union_of_antitone\n\n",
 "BddBelow":
 "#print BddBelow /-\n/-- A finset is bounded below. -/\nprotected theorem BddBelow [SemilatticeInf α] [Nonempty α] (s : Finset α) : BddBelow (↑s : Set α) :=\n  s.finite_to_set.bdd_below\n#align bdd_below BddBelow\n-/\n\n",
 "BddAbove":
 "#print BddAbove /-\n/-- A finset is bounded above. -/\nprotected theorem BddAbove [SemilatticeSup α] [Nonempty α] (s : Finset α) : BddAbove (↑s : Set α) :=\n  s.finite_to_set.bdd_above\n#align bdd_above BddAbove\n-/\n\n"}