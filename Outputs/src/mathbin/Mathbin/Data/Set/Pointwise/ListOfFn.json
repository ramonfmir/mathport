{"mem_prod_list_of_fn":
 "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[to_additive]\ntheorem mem_prod_list_of_fn {a : α} {s : fin n → set α} :\n    a ∈ (List.ofFn s).prod ↔ ∃ f : ∀ i : fin n, s i, (List.ofFn fun i => (f i : α)).prod = a :=\n  by\n  induction' n with n ih generalizing a\n  · simp_rw [list.of_fn_zero, List.prod_nil, fin.exists_fin_zero_pi, eq_comm, Set.mem_one]\n  ·\n    simp_rw [list.of_fn_succ, List.prod_cons, fin.exists_fin_succ_pi, fin.cons_zero, fin.cons_succ, mem_mul, @ih,\n      exists_and_left, exists_exists_eq_and, SetCoe.exists, subtype.coe_mk, exists_prop]\n#align mem_prod_list_of_fn mem_prod_list_of_fn\n\n",
 "mem_pow":
 "@[to_additive]\ntheorem mem_pow {a : α} {n : ℕ} : a ∈ s ^ n ↔ ∃ f : fin n → s, (List.ofFn fun i => (f i : α)).prod = a := by\n  rw [← mem_prod_list_of_fn, list.of_fn_const, List.prod_replicate]\n#align mem_pow mem_pow\n\n",
 "mem_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[to_additive]\ntheorem mem_list_prod {l : list (set α)} {a : α} :\n    a ∈ l.prod ↔\n      ∃ l' : list (Σs : set α, «expr↥ » s), List.prod (l'.map fun x => (sigma.snd x : α)) = a ∧ l'.map sigma.fst = l :=\n  by\n  induction' l using list.of_fn_rec with n f\n  simp_rw [list.exists_iff_exists_tuple, list.map_of_fn, list.of_fn_inj', and_left_comm, exists_and_left,\n    exists_eq_left, heq_iff_eq, function.comp, mem_prod_list_of_fn]\n  constructor\n  · rintro ⟨fi, rfl⟩\n    exact ⟨fun i => ⟨_, fi i⟩, rfl, rfl⟩\n  · rintro ⟨fi, rfl, rfl⟩\n    exact ⟨fun i => _, rfl⟩\n#align mem_list_prod mem_list_prod\n\n"}