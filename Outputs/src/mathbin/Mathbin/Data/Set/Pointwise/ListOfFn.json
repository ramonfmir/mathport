{"mem_prod_list_of_fn":
 "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[to_additive]\ntheorem mem_prod_list_of_fn {a : α} {s : Fin n → Set α} :\n    a ∈ (List.ofFn s).prod ↔ ∃ f : ∀ i : Fin n, s i, (List.ofFn fun i => (f i : α)).prod = a :=\n  by\n  induction' n with n ih generalizing a\n  · simp_rw [List.ofFn_zero, List.prod_nil, Fin.exists_fin_zero_pi, eq_comm, Set.mem_one]\n  ·\n    simp_rw [List.ofFn_succ, List.prod_cons, Fin.exists_fin_succ_pi, Fin.cons_zero, Fin.cons_succ, mem_mul, @ih,\n      exists_and_left, exists_exists_eq_and, SetCoe.exists, Subtype.coe_mk, exists_prop]\n#align mem_prod_list_of_fn mem_prod_list_of_fn\n\n",
 "mem_pow":
 "@[to_additive]\ntheorem mem_pow {a : α} {n : ℕ} : a ∈ s ^ n ↔ ∃ f : Fin n → s, (List.ofFn fun i => (f i : α)).prod = a := by\n  rw [← mem_prod_list_of_fn, List.ofFn_const, List.prod_replicate]\n#align mem_pow mem_pow\n\n",
 "mem_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[to_additive]\ntheorem mem_list_prod {l : List (Set α)} {a : α} :\n    a ∈ l.prod ↔\n      ∃ l' : List (Σs : Set α, «expr↥ » s), List.prod (l'.map fun x => (Sigma.snd x : α)) = a ∧ l'.map Sigma.fst = l :=\n  by\n  induction' l using List.ofFnRec with n f\n  simp_rw [List.exists_iff_exists_tuple, List.map_ofFn, List.ofFn_inj', and_left_comm, exists_and_left, exists_eq_left,\n    heq_iff_eq, Function.comp, mem_prod_list_of_fn]\n  constructor\n  · rintro ⟨fi, rfl⟩\n    exact ⟨fun i => ⟨_, fi i⟩, rfl, rfl⟩\n  · rintro ⟨fi, rfl, rfl⟩\n    exact ⟨fun i => _, rfl⟩\n#align mem_list_prod mem_list_prod\n\n"}