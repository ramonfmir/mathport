{"vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem finite.vsub (hs : s.finite) (ht : t.finite) : set.finite («expr -ᵥ » s t) :=\n  hs.image2 _ ht\n#align finite.vsub finite.vsub\n\n",
 "smul_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem finite.smul_set : s.finite → («expr • » a s).finite :=\n  finite.image _\n#align finite.smul_set finite.smul_set\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem finite.smul : s.finite → t.finite → («expr • » s t).finite :=\n  finite.image2 _\n#align finite.smul finite.smul\n\n",
 "mul":
 "@[to_additive]\ntheorem finite.mul : s.finite → t.finite → (s * t).finite :=\n  finite.image2 _\n#align finite.mul finite.mul\n\n",
 "inv":
 "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Floris van Doorn\n-/\n@[to_additive]\ntheorem finite.inv (hs : s.finite) : s⁻¹.finite :=\n  hs.preimage <| inv_injective.inj_on _\n#align finite.inv finite.inv\n\n",
 "card_pow_eq_card_pow_card_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[to_additive]\ntheorem card_pow_eq_card_pow_card_univ [∀ k : ℕ, decidable_pred (· ∈ S ^ k)] :\n    ∀ k, fintype.card G ≤ k → fintype.card («expr↥ » (S ^ k)) = fintype.card («expr↥ » (S ^ fintype.card G)) :=\n  by\n  have hG : 0 < fintype.card G := fintype.card_pos_iff.mpr ⟨1⟩\n  by_cases hS : S = ∅\n  · refine' fun k hk => fintype.card_congr _\n    rw [hS, empty_pow (ne_of_gt (lt_of_lt_of_le hG hk)), empty_pow (ne_of_gt hG)]\n  obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty.2 hS\n  classical!\n  have key : ∀ (a) (s t : set G), (∀ b : G, b ∈ s → a * b ∈ t) → fintype.card s ≤ fintype.card t :=\n    by\n    refine' fun a s t h => fintype.card_le_of_injective (fun ⟨b, hb⟩ => ⟨a * b, h b hb⟩) _\n    rintro ⟨b, hb⟩ ⟨c, hc⟩ hbc\n    exact subtype.ext (mul_left_cancel (subtype.ext_iff.mp hbc))\n  have mono : monotone (fun n => fintype.card («expr↥ » (S ^ n)) : ℕ → ℕ) :=\n    monotone_nat_of_le_succ fun n => key a _ _ fun b hb => Set.mul_mem_mul ha hb\n  convert\n    card_pow_eq_card_pow_card_univ_aux mono (fun n => set_fintype_card_le_univ (S ^ n)) fun n h =>\n      le_antisymm (mono (n + 1).le_succ) (key a⁻¹ _ _ _)\n  · simp only [[anonymous], fintype.card_of_finset]\n  replace h : {a} * S ^ n = S ^ (n + 1)\n  · refine' set.eq_of_subset_of_card_le _ (le_trans (ge_of_eq h) _)\n    · exact mul_subset_mul (set.singleton_subset_iff.mpr ha) Set.Subset.rfl\n    · convert key a (S ^ n) ({a} * S ^ n) fun b hb => Set.mul_mem_mul (Set.mem_singleton a) hb\n  rw [pow_succ', ← h, mul_assoc, ← pow_succ', h]\n  rintro _ ⟨b, c, hb, hc, rfl⟩\n  rwa [set.mem_singleton_iff.mp hb, inv_mul_cancel_left]\n#align card_pow_eq_card_pow_card_univ card_pow_eq_card_pow_card_univ\n\n"}