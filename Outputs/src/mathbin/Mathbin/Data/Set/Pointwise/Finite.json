{"vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\ntheorem finite.vsub (hs : s.finite) (ht : t.finite) : Set.Finite («expr -ᵥ » s t) :=\n  hs.image2 _ ht\n#align finite.vsub finite.vsub\n\n",
 "smul_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem finite.smul_set : s.finite → («expr • » a s).finite :=\n  Finite.image _\n#align finite.smul_set finite.smul_set\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem finite.smul : s.finite → t.finite → («expr • » s t).finite :=\n  Finite.image2 _\n#align finite.smul finite.smul\n\n",
 "of_smul_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[to_additive]\ntheorem infinite.of_smul_set : («expr • » a s).infinite → s.infinite :=\n  Infinite.of_image _\n#align infinite.of_smul_set infinite.of_smul_set\n\n",
 "mul":
 "@[to_additive]\ntheorem finite.mul : s.finite → t.finite → (s * t).finite :=\n  Finite.image2 _\n#align finite.mul finite.mul\n\n",
 "inv":
 "@[to_additive]\ntheorem finite.inv (hs : s.finite) : s⁻¹.finite :=\n  hs.preimage <| inv_injective.inj_on _\n#align finite.inv finite.inv\n\n",
 "infinite_smul_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem infinite_smul_set : («expr • » a s).infinite ↔ s.infinite :=\n  infinite_image_iff <| (MulAction.injective _).inj_on _\n#align infinite_smul_set infinite_smul_set\n\n",
 "infinite_mul":
 "@[to_additive]\ntheorem infinite_mul : (s * t).infinite ↔ s.infinite ∧ t.nonempty ∨ t.infinite ∧ s.nonempty :=\n  infinite_image2 (fun _ _ => (mul_left_injective _).inj_on _) fun _ _ => (mul_right_injective _).inj_on _\n#align infinite_mul infinite_mul\n\n",
 "finite_smul_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp, to_additive]\ntheorem finite_smul_set : («expr • » a s).finite ↔ s.finite :=\n  finite_image_iff <| (MulAction.injective _).inj_on _\n#align finite_smul_set finite_smul_set\n\n",
 "finite_one":
 "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Floris van Doorn\n-/\n@[simp, to_additive]\ntheorem finite_one : (1 : Set α).finite :=\n  finite_singleton _\n#align finite_one finite_one\n\n",
 "card_pow_eq_card_pow_card_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n@[to_additive]\ntheorem card_pow_eq_card_pow_card_univ [∀ k : ℕ, DecidablePred (· ∈ S ^ k)] :\n    ∀ k, Fintype.card G ≤ k → Fintype.card («expr↥ » (S ^ k)) = Fintype.card («expr↥ » (S ^ Fintype.card G)) :=\n  by\n  have hG : 0 < Fintype.card G := fintype.card_pos_iff.mpr ⟨1⟩\n  by_cases hS : S = ∅\n  · refine' fun k hk => Fintype.card_congr _\n    rw [hS, empty_pow (ne_of_gt (lt_of_lt_of_le hG hk)), empty_pow (ne_of_gt hG)]\n  obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty.2 hS\n  classical!\n  have key : ∀ (a) (s t : Set G), (∀ b : G, b ∈ s → a * b ∈ t) → Fintype.card s ≤ Fintype.card t :=\n    by\n    refine' fun a s t h => Fintype.card_le_of_injective (fun ⟨b, hb⟩ => ⟨a * b, h b hb⟩) _\n    rintro ⟨b, hb⟩ ⟨c, hc⟩ hbc\n    exact Subtype.ext (mul_left_cancel (subtype.ext_iff.mp hbc))\n  have mono : Monotone (fun n => Fintype.card («expr↥ » (S ^ n)) : ℕ → ℕ) :=\n    monotone_nat_of_le_succ fun n => key a _ _ fun b hb => Set.mul_mem_mul ha hb\n  convert card_pow_eq_card_pow_card_univ_aux mono (fun n => set_fintype_card_le_univ (S ^ n)) fun n h =>\n      le_antisymm (mono (n + 1).le_succ) (key a⁻¹ _ _ _)\n  · simp only [[anonymous], Fintype.card_ofFinset]\n  replace h : {a} * S ^ n = S ^ (n + 1)\n  · refine' Set.eq_of_subset_of_card_le _ (le_trans (ge_of_eq h) _)\n    · exact mul_subset_mul (set.singleton_subset_iff.mpr ha) Set.Subset.rfl\n    · convert key a (S ^ n) ({a} * S ^ n) fun b hb => Set.mul_mem_mul (Set.mem_singleton a) hb\n  rw [pow_succ', ← h, mul_assoc, ← pow_succ', h]\n  rintro _ ⟨b, c, hb, hc, rfl⟩\n  rwa [set.mem_singleton_iff.mp hb, inv_mul_cancel_left]\n#align card_pow_eq_card_pow_card_univ card_pow_eq_card_pow_card_univ\n\n"}