{"multiset_prod_subset_multiset_prod":
 "/-- An n-ary version of `set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `set.add_subset_add`. \"]\ntheorem multiset_prod_subset_multiset_prod (t : Multiset ι) (f₁ f₂ : ι → Set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    (t.map f₁).prod ⊆ (t.map f₂).prod :=\n  by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.coe_map, Multiset.coe_prod]\n  exact list_prod_subset_list_prod _ _ _ hf\n#align multiset_prod_subset_multiset_prod multiset_prod_subset_multiset_prod\n\n",
 "multiset_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem multiset_prod_singleton {M : Type _} [CommMonoid M] (s : Multiset M) :\n    (s.map fun i => ({i} : Set M)).prod = {s.prod} :=\n  (map_multiset_prod (singletonMonoidHom : «expr →* » M (Set M)) _).symm\n#align multiset_prod_singleton multiset_prod_singleton\n\n",
 "multiset_prod_mem_multiset_prod":
 "/-- An n-ary version of `set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `set.add_mem_add`. \"]\ntheorem multiset_prod_mem_multiset_prod (t : Multiset ι) (f : ι → Set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    (t.map g).prod ∈ (t.map f).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.coe_map, Multiset.coe_prod]\n  exact list_prod_mem_list_prod _ _ _ hg\n#align multiset_prod_mem_multiset_prod multiset_prod_mem_multiset_prod\n\n",
 "mem_fintype_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- A version of `set.mem_finset_prod` with a simpler RHS for products over a fintype. -/\n@[to_additive \" A version of `set.mem_finset_sum` with a simpler RHS for sums over a fintype. \"]\ntheorem mem_fintype_prod [Fintype ι] (f : ι → Set α) (a : α) :\n    a ∈\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (f i) ↔\n      ∃ (g : ι → α)(hg : ∀ i, g i ∈ f i),\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (g i) =\n          a :=\n  by\n  rw [mem_finset_prod]\n  simp\n#align mem_fintype_prod mem_fintype_prod\n\n",
 "mem_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The n-ary version of `set.mem_mul`. -/\n@[to_additive \" The n-ary version of `set.mem_add`. \"]\ntheorem mem_finset_prod (t : Finset ι) (f : ι → Set α) (a : α) :\n    a ∈ finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) ↔\n      ∃ (g : ι → α)(hg : ∀ {i}, i ∈ t → g i ∈ f i),\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g i) = a :=\n  by\n  classical\n    induction' t using Finset.induction_on with i is hi ih generalizing a\n    · simp_rw [Finset.prod_empty, Set.mem_one]\n      exact ⟨fun h => ⟨fun i => a, fun i => false.elim, h.symm⟩, fun ⟨f, _, hf⟩ => hf.symm⟩\n    rw [Finset.prod_insert hi, Set.mem_mul]\n    simp_rw [Finset.prod_insert hi]\n    simp_rw [ih]\n    constructor\n    · rintro ⟨x, y, hx, ⟨g, hg, rfl⟩, rfl⟩\n      refine' ⟨Function.update g i x, fun j hj => _, _⟩\n      obtain rfl | hj := finset.mem_insert.mp hj\n      · rw [Function.update_same]\n        exact hx\n      · rw [update_noteq (ne_of_mem_of_not_mem hj hi)]\n        exact hg hj\n      rw [Finset.prod_update_of_not_mem hi, Function.update_same]\n    · rintro ⟨g, hg, rfl⟩\n      exact ⟨g i, is.prod g, hg (is.mem_insert_self _), ⟨g, fun i hi => hg (Finset.mem_insert_of_mem hi), rfl⟩, rfl⟩\n#align mem_finset_prod mem_finset_prod\n\n",
 "list_prod_subset_list_prod":
 "/-- An n-ary version of `set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `set.add_subset_add`. \"]\ntheorem list_prod_subset_list_prod (t : List ι) (f₁ f₂ : ι → Set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    (t.map f₁).prod ⊆ (t.map f₂).prod := by\n  induction' t with h tl ih\n  · rfl\n  · simp_rw [list.map_cons, List.prod_cons]\n    exact mul_subset_mul (hf h <| list.mem_cons_self _ _) (ih fun i hi => hf i <| list.mem_cons_of_mem _ hi)\n#align list_prod_subset_list_prod list_prod_subset_list_prod\n\n",
 "list_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem list_prod_singleton {M : Type _} [CommMonoid M] (s : List M) : (s.map fun i => ({i} : Set M)).prod = {s.prod} :=\n  (map_list_prod (singletonMonoidHom : «expr →* » M (Set M)) _).symm\n#align list_prod_singleton list_prod_singleton\n\n",
 "list_prod_mem_list_prod":
 "/-- An n-ary version of `set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `set.add_mem_add`. \"]\ntheorem list_prod_mem_list_prod (t : List ι) (f : ι → Set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    (t.map g).prod ∈ (t.map f).prod := by\n  induction' t with h tl ih\n  · simp_rw [List.map_nil, List.prod_nil, Set.mem_one]\n  · simp_rw [list.map_cons, List.prod_cons]\n    exact mul_mem_mul (hg h <| list.mem_cons_self _ _) (ih fun i hi => hg i <| list.mem_cons_of_mem _ hi)\n#align list_prod_mem_list_prod list_prod_mem_list_prod\n\n",
 "image_multiset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem image_multiset_prod (f : F) :\n    ∀ m : Multiset (Set α), «expr '' » (f : α → β) m.prod = (m.map fun s => «expr '' » f s).prod :=\n  quotient.ind <| by simpa only [Multiset.quot_mk_to_coe, Multiset.coe_prod, Multiset.coe_map] using image_list_prod f\n#align image_multiset_prod image_multiset_prod\n\n",
 "image_list_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[to_additive]\ntheorem image_list_prod (f : F) :\n    ∀ l : List (Set α), «expr '' » (f : α → β) l.prod = (l.map fun s => «expr '' » f s).prod\n  | [] => image_one.trans <| congr_arg singleton (map_one f)\n  | a :: as => by rw [list.map_cons, List.prod_cons, List.prod_cons, image_mul, image_list_prod]\n#align image_list_prod image_list_prod\n\n",
 "image_fintype_prod_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- A special case of `set.image_finset_prod_pi` for `finset.univ`. -/\n@[to_additive \"A special case of `set.image_finset_sum_pi` for `finset.univ`. \"]\ntheorem image_fintype_prod_pi [Fintype ι] (S : ι → Set α) :\n    «expr '' »\n        (fun f : ι → α =>\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (f i))\n        (univ.pi S) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (S i) :=\n  by simpa only [Finset.coe_univ] using image_finset_prod_pi Finset.univ S\n#align image_fintype_prod_pi image_fintype_prod_pi\n\n",
 "image_finset_prod_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The n-ary version of `set.image_mul_prod`. -/\n@[to_additive \"The n-ary version of `set.add_image_prod`. \"]\ntheorem image_finset_prod_pi (l : Finset ι) (S : ι → Set α) :\n    «expr '' »\n        (fun f : ι → α =>\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" l (f i))\n        ((l : Set ι).pi S) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" l (S i) :=\n  by\n  ext\n  simp_rw [mem_finset_prod, mem_image, mem_pi, exists_prop, Finset.mem_coe]\n#align image_finset_prod_pi image_finset_prod_pi\n\n",
 "image_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[to_additive]\ntheorem image_finset_prod (f : F) (m : Finset ι) (s : ι → Set α) :\n    «expr '' » (f : α → β)\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m (s i)) =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" m\n        («expr '' » f (s i)) :=\n  (image_multiset_prod f _).trans <| congr_arg Multiset.prod <| Multiset.map_map _ _ _\n#align image_finset_prod image_finset_prod\n\n",
 "finset_prod_subset_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An n-ary version of `set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `set.add_subset_add`. \"]\ntheorem finset_prod_subset_finset_prod (t : Finset ι) (f₁ f₂ : ι → Set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f₁ i) ⊆\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f₂ i) :=\n  multiset_prod_subset_multiset_prod _ _ _ hf\n#align finset_prod_subset_finset_prod finset_prod_subset_finset_prod\n\n",
 "finset_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem finset_prod_singleton {M ι : Type _} [CommMonoid M] (s : Finset ι) (I : ι → M) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ({I i} : Set M) =\n      {finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (I i)} :=\n  (map_prod (singletonMonoidHom : «expr →* » M (Set M)) _ _).symm\n#align finset_prod_singleton finset_prod_singleton\n\n",
 "finset_prod_mem_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An n-ary version of `set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `set.add_mem_add`. \"]\ntheorem finset_prod_mem_finset_prod (t : Finset ι) (f : ι → Set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g i) ∈\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) :=\n  multiset_prod_mem_multiset_prod _ _ _ hg\n#align finset_prod_mem_finset_prod finset_prod_mem_finset_prod\n\n"}