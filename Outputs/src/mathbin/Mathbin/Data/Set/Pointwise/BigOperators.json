{"multiset_prod_subset_multiset_prod":
 "/-- An n-ary version of `set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `set.add_subset_add`. \"]\ntheorem multiset_prod_subset_multiset_prod (t : Multiset ι) (f₁ f₂ : ι → set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    (t.map f₁).prod ⊆ (t.map f₂).prod :=\n  by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.coe_map, Multiset.coe_prod]\n  exact list_prod_subset_list_prod _ _ _ hf\n#align multiset_prod_subset_multiset_prod multiset_prod_subset_multiset_prod\n\n",
 "multiset_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem multiset_prod_singleton {M : Type _} [comm_monoid M] (s : Multiset M) :\n    (s.map fun i => ({i} : set M)).prod = {s.prod} :=\n  (map_multiset_prod (singletonMonoidHom : «expr →* » M (set M)) _).symm\n#align multiset_prod_singleton multiset_prod_singleton\n\n",
 "multiset_prod_mem_multiset_prod":
 "/-- An n-ary version of `set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `set.add_mem_add`. \"]\ntheorem multiset_prod_mem_multiset_prod (t : Multiset ι) (f : ι → set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    (t.map g).prod ∈ (t.map f).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.coe_map, Multiset.coe_prod]\n  exact list_prod_mem_list_prod _ _ _ hg\n#align multiset_prod_mem_multiset_prod multiset_prod_mem_multiset_prod\n\n",
 "mem_fintype_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- A version of `set.mem_finset_prod` with a simpler RHS for products over a fintype. -/\n@[to_additive \" A version of `set.mem_finset_sum` with a simpler RHS for sums over a fintype. \"]\ntheorem mem_fintype_prod [fintype ι] (f : ι → set α) (a : α) :\n    a ∈\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (f i) ↔\n      ∃ (g : ι → α)(hg : ∀ i, g i ∈ f i),\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (g i) =\n          a :=\n  by\n  rw [mem_finset_prod]\n  simp\n#align mem_fintype_prod mem_fintype_prod\n\n",
 "mem_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n/-- The n-ary version of `set.mem_mul`. -/\n@[to_additive \" The n-ary version of `set.mem_add`. \"]\ntheorem mem_finset_prod (t : Finset ι) (f : ι → set α) (a : α) :\n    a ∈ finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) ↔\n      ∃ (g : ι → α)(hg : ∀ {i}, i ∈ t → g i ∈ f i),\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g i) = a :=\n  by\n  classical\n    induction' t using Finset.induction_on with i is hi ih generalizing a\n    · simp_rw [finset.prod_empty, Set.mem_one]\n      exact ⟨fun h => ⟨fun i => a, fun i => false.elim, h.symm⟩, fun ⟨f, _, hf⟩ => hf.symm⟩\n    rw [finset.prod_insert hi, Set.mem_mul]\n    simp_rw [finset.prod_insert hi]\n    simp_rw [ih]\n    constructor\n    · rintro ⟨x, y, hx, ⟨g, hg, rfl⟩, rfl⟩\n      refine' ⟨function.update g i x, fun j hj => _, _⟩\n      obtain rfl | hj := finset.mem_insert.mp hj\n      · rw [function.update_same]\n        exact hx\n      · rw [update_noteq (ne_of_mem_of_not_mem hj hi)]\n        exact hg hj\n      rw [finset.prod_update_of_not_mem hi, function.update_same]\n    · rintro ⟨g, hg, rfl⟩\n      exact ⟨g i, is.prod g, hg (is.mem_insert_self _), ⟨g, fun i hi => hg (Finset.mem_insert_of_mem hi), rfl⟩, rfl⟩\n#align mem_finset_prod mem_finset_prod\n\n",
 "list_prod_subset_list_prod":
 "/-- An n-ary version of `set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `set.add_subset_add`. \"]\ntheorem list_prod_subset_list_prod (t : list ι) (f₁ f₂ : ι → set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    (t.map f₁).prod ⊆ (t.map f₂).prod := by\n  induction' t with h tl ih\n  · rfl\n  · simp_rw [list.map_cons, List.prod_cons]\n    exact mul_subset_mul (hf h <| list.mem_cons_self _ _) (ih fun i hi => hf i <| list.mem_cons_of_mem _ hi)\n#align list_prod_subset_list_prod list_prod_subset_list_prod\n\n",
 "list_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[to_additive]\ntheorem list_prod_singleton {M : Type _} [comm_monoid M] (s : list M) :\n    (s.map fun i => ({i} : set M)).prod = {s.prod} :=\n  (map_list_prod (singletonMonoidHom : «expr →* » M (set M)) _).symm\n#align list_prod_singleton list_prod_singleton\n\n",
 "list_prod_mem_list_prod":
 "/-- An n-ary version of `set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `set.add_mem_add`. \"]\ntheorem list_prod_mem_list_prod (t : list ι) (f : ι → set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    (t.map g).prod ∈ (t.map f).prod := by\n  induction' t with h tl ih\n  · simp_rw [List.map_nil, List.prod_nil, Set.mem_one]\n  · simp_rw [list.map_cons, List.prod_cons]\n    exact mul_mem_mul (hg h <| list.mem_cons_self _ _) (ih fun i hi => hg i <| list.mem_cons_of_mem _ hi)\n#align list_prod_mem_list_prod list_prod_mem_list_prod\n\n",
 "finset_prod_subset_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An n-ary version of `set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `set.add_subset_add`. \"]\ntheorem finset_prod_subset_finset_prod (t : Finset ι) (f₁ f₂ : ι → set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f₁ i) ⊆\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f₂ i) :=\n  multiset_prod_subset_multiset_prod _ _ _ hf\n#align finset_prod_subset_finset_prod finset_prod_subset_finset_prod\n\n",
 "finset_prod_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem finset_prod_singleton {M ι : Type _} [comm_monoid M] (s : Finset ι) (I : ι → M) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        ({I i} : set M) =\n      {finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (I i)} :=\n  (map_prod (singletonMonoidHom : «expr →* » M (set M)) _ _).symm\n#align finset_prod_singleton finset_prod_singleton\n\n",
 "finset_prod_mem_finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- An n-ary version of `set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `set.add_mem_add`. \"]\ntheorem finset_prod_mem_finset_prod (t : Finset ι) (f : ι → set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (g i) ∈\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) :=\n  multiset_prod_mem_multiset_prod _ _ _ hg\n#align finset_prod_mem_finset_prod finset_prod_mem_finset_prod\n\n"}