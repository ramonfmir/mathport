{"lift_cover_of_mem":
 "theorem lift_cover_of_mem {i : ι} {x : α} (hx : (x : α) ∈ S i) : liftCover S f hf hS x = f i ⟨x, hx⟩ :=\n  unionᵢLift_of_mem ⟨x, trivial⟩ hx\n#align lift_cover_of_mem lift_cover_of_mem\n\n",
 "lift_cover_coe":
 "@[simp]\ntheorem lift_cover_coe {i : ι} (x : S i) : liftCover S f hf hS x = f i x :=\n  unionᵢLift_mk x _\n#align lift_cover_coe lift_cover_coe\n\n",
 "Union_lift_unary":
 "/-- `Union_lift_unary` is useful for proving that `Union_lift` is a homomorphism\n  of algebraic structures when defined on the Union of algebraic subobjects.\n  For example, it could be used to prove that the lift of a collection\n  of linear_maps on a union of submodules preserves scalar multiplication. -/\ntheorem Union_lift_unary (u : T → T) (ui : ∀ i, S i → S i)\n    (hui :\n      ∀ (i) (x : S i),\n        u (Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_unionᵢ S i) x) =\n          Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_unionᵢ S i) (ui i x))\n    (uβ : β → β) (h : ∀ (i) (x : S i), f i (ui i x) = uβ (f i x)) (x : T) :\n    unionᵢLift S f hf T (le_of_eq hT') (u x) = uβ (unionᵢLift S f hf T (le_of_eq hT') x) :=\n  by\n  subst hT'\n  cases' Set.mem_unionᵢ.1 x.prop with i hi\n  rw [Union_lift_of_mem x hi, ← h i]\n  have : x = Set.inclusion (Set.subset_unionᵢ S i) ⟨x, hi⟩ :=\n    by\n    cases x\n    rfl\n  have hx' : (Set.inclusion (Set.subset_unionᵢ S i) (ui i ⟨x, hi⟩) : α) ∈ S i := (ui i ⟨x, hi⟩).prop\n  conv_lhs => rw [this, hui, Union_lift_inclusion]\n#align Union_lift_unary Union_lift_unary\n\n",
 "Union_lift_of_mem":
 "theorem Union_lift_of_mem (x : T) {i : ι} (hx : (x : α) ∈ S i) : unionᵢLift S f hf T hT x = f i ⟨x, hx⟩ := by\n  cases' x with x hx <;> exact hf _ _ _ _ _\n#align Union_lift_of_mem Union_lift_of_mem\n\n",
 "Union_lift_mk":
 "/-\nCopyright (c) 2021 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/- The unused argument `hf` is left in the definition so that the `simp` lemmas\n`Union_lift_inclusion` will work without the user having to provide `hf` explicitly to\nsimplify terms involving `Union_lift`. -/\n@[simp]\ntheorem Union_lift_mk {i : ι} (x : S i) (hx : (x : α) ∈ T) : unionᵢLift S f hf T hT ⟨x, hx⟩ = f i x :=\n  by\n  let j := classical.indefinite_description _ (mem_unionᵢ.1 (hT hx))\n  cases' x with x hx <;> exact hf j i x j.2 _\n#align Union_lift_mk Union_lift_mk\n\n",
 "Union_lift_inclusion":
 "@[simp]\ntheorem Union_lift_inclusion {i : ι} (x : S i) (h : S i ⊆ T) : unionᵢLift S f hf T hT (Set.inclusion h x) = f i x :=\n  unionᵢLift_mk x _\n#align Union_lift_inclusion Union_lift_inclusion\n\n",
 "Union_lift_const":
 "/-- `Union_lift_const` is useful for proving that `Union_lift` is a homomorphism\n  of algebraic structures when defined on the Union of algebraic subobjects.\n  For example, it could be used to prove that the lift of a collection\n  of group homomorphisms on a union of subgroups preserves `1`. -/\ntheorem Union_lift_const (c : T) (ci : ∀ i, S i) (hci : ∀ i, (ci i : α) = c) (cβ : β) (h : ∀ i, f i (ci i) = cβ) :\n    unionᵢLift S f hf T hT c = cβ := by\n  let ⟨i, hi⟩ := Set.mem_unionᵢ.1 (hT c.prop)\n  have : ci i = ⟨c, hi⟩ := Subtype.ext (hci i)\n  rw [Union_lift_of_mem _ hi, ← this, h]\n#align Union_lift_const Union_lift_const\n\n",
 "Union_lift_binary":
 "/-- `Union_lift_binary` is useful for proving that `Union_lift` is a homomorphism\n  of algebraic structures when defined on the Union of algebraic subobjects.\n  For example, it could be used to prove that the lift of a collection\n  of group homomorphisms on a union of subgroups preserves `*`. -/\ntheorem Union_lift_binary (dir : Directed (· ≤ ·) S) (op : T → T → T) (opi : ∀ i, S i → S i → S i)\n    (hopi :\n      ∀ i x y,\n        Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_unionᵢ S i) (opi i x y) =\n          op (Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_unionᵢ S i) x)\n            (Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_unionᵢ S i) y))\n    (opβ : β → β → β) (h : ∀ (i) (x y : S i), f i (opi i x y) = opβ (f i x) (f i y)) (x y : T) :\n    unionᵢLift S f hf T (le_of_eq hT') (op x y) =\n      opβ (unionᵢLift S f hf T (le_of_eq hT') x) (unionᵢLift S f hf T (le_of_eq hT') y) :=\n  by\n  subst hT'\n  cases' Set.mem_unionᵢ.1 x.prop with i hi\n  cases' Set.mem_unionᵢ.1 y.prop with j hj\n  rcases dir i j with ⟨k, hik, hjk⟩\n  rw [Union_lift_of_mem x (hik hi), Union_lift_of_mem y (hjk hj), ← h k]\n  have hx : x = Set.inclusion (Set.subset_unionᵢ S k) ⟨x, hik hi⟩ :=\n    by\n    cases x\n    rfl\n  have hy : y = Set.inclusion (Set.subset_unionᵢ S k) ⟨y, hjk hj⟩ :=\n    by\n    cases y\n    rfl\n  have hxy : (Set.inclusion (Set.subset_unionᵢ S k) (opi k ⟨x, hik hi⟩ ⟨y, hjk hj⟩) : α) ∈ S k :=\n    (opi k ⟨x, hik hi⟩ ⟨y, hjk hj⟩).prop\n  conv_lhs => rw [hx, hy, ← hopi, Union_lift_of_mem _ hxy]\n  simp only [coe_inclusion, Subtype.coe_eta]\n#align Union_lift_binary Union_lift_binary\n\n"}