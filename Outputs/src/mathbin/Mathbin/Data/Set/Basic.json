{"univ_unique":
 "theorem univ_unique [unique Œ±] : @Set.univ Œ± = {default} :=\n  Set.ext fun x => iff_of_true trivial <| subsingleton.elim x default\n#align univ_unique univ_unique\n\n",
 "univ_union":
 "@[simp]\ntheorem univ_union {s : set Œ±} : univ ‚à™ s = univ :=\n  top_sup_eq\n#align univ_union univ_union\n\n",
 "univ_subset_iff":
 "theorem univ_subset_iff {s : set Œ±} : univ ‚äÜ s ‚Üî s = univ :=\n  @top_le_iff _ _ _ s\n#align univ_subset_iff univ_subset_iff\n\n",
 "univ_nonempty":
 "@[simp]\ntheorem univ_nonempty : ‚àÄ [h : nonempty Œ±], (univ : set Œ±).nonempty\n  | ‚ü®x‚ü© => ‚ü®x, trivial‚ü©\n#align univ_nonempty univ_nonempty\n\n",
 "univ_inter":
 "@[simp]\ntheorem univ_inter (a : set Œ±) : univ ‚à© a = a :=\n  top_inf_eq\n#align univ_inter univ_inter\n\n",
 "univ_eq_true_false":
 "theorem univ_eq_true_false : univ = ({true, false} : set Prop) :=\n  eq.symm <| eq_univ_of_forall <| classical.cases (by simp) (by simp)\n#align univ_eq_true_false univ_eq_true_false\n\n",
 "univ_eq_empty_iff":
 "@[simp]\ntheorem univ_eq_empty_iff : (univ : set Œ±) = ‚àÖ ‚Üî is_empty Œ± :=\n  eq_empty_iff_forall_not_mem.trans ‚ü®fun H => ‚ü®fun x => H x trivial‚ü©, fun H x _ => @is_empty.false Œ± H x‚ü©\n#align univ_eq_empty_iff univ_eq_empty_iff\n\n",
 "univ_disjoint":
 "@[simp]\ntheorem univ_disjoint : Disjoint univ s ‚Üî s = ‚àÖ :=\n  top_disjoint\n#align univ_disjoint univ_disjoint\n\n",
 "union_univ":
 "@[simp]\ntheorem union_univ {s : set Œ±} : s ‚à™ univ = univ :=\n  sup_top_eq\n#align union_univ union_univ\n\n",
 "union_union_union_comm":
 "theorem union_union_union_comm (s t u v : set Œ±) : s ‚à™ t ‚à™ (u ‚à™ v) = s ‚à™ u ‚à™ (t ‚à™ v) :=\n  sup_sup_sup_comm _ _ _ _\n#align union_union_union_comm union_union_union_comm\n\n",
 "union_union_distrib_right":
 "theorem union_union_distrib_right (s t u : set Œ±) : s ‚à™ t ‚à™ u = s ‚à™ u ‚à™ (t ‚à™ u) :=\n  sup_sup_distrib_right _ _ _\n#align union_union_distrib_right union_union_distrib_right\n\n",
 "union_union_distrib_left":
 "theorem union_union_distrib_left (s t u : set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=\n  sup_sup_distrib_left _ _ _\n#align union_union_distrib_left union_union_distrib_left\n\n",
 "union_subset_union_right":
 "theorem union_subset_union_right (s) {t‚ÇÅ t‚ÇÇ : set Œ±} (h : t‚ÇÅ ‚äÜ t‚ÇÇ) : s ‚à™ t‚ÇÅ ‚äÜ s ‚à™ t‚ÇÇ :=\n  union_subset_union Subset.rfl h\n#align union_subset_union_right union_subset_union_right\n\n",
 "union_subset_union_left":
 "theorem union_subset_union_left {s‚ÇÅ s‚ÇÇ : set Œ±} (t) (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : s‚ÇÅ ‚à™ t ‚äÜ s‚ÇÇ ‚à™ t :=\n  union_subset_union h Subset.rfl\n#align union_subset_union_left union_subset_union_left\n\n",
 "union_subset_union":
 "theorem union_subset_union {s‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : set Œ±} (h‚ÇÅ : s‚ÇÅ ‚äÜ s‚ÇÇ) (h‚ÇÇ : t‚ÇÅ ‚äÜ t‚ÇÇ) : s‚ÇÅ ‚à™ t‚ÇÅ ‚äÜ s‚ÇÇ ‚à™ t‚ÇÇ := fun x =>\n  Or.imp (@h‚ÇÅ _) (@h‚ÇÇ _)\n#align union_subset_union union_subset_union\n\n",
 "union_subset_iff":
 "@[simp]\ntheorem union_subset_iff {s t u : set Œ±} : s ‚à™ t ‚äÜ u ‚Üî s ‚äÜ u ‚àß t ‚äÜ u :=\n  (forall_congr' fun x => or_imp).trans forall_and\n#align union_subset_iff union_subset_iff\n\n",
 "union_subset":
 "theorem union_subset {s t r : set Œ±} (sr : s ‚äÜ r) (tr : t ‚äÜ r) : s ‚à™ t ‚äÜ r := fun x => or.rec (@sr _) (@tr _)\n#align union_subset union_subset\n\n",
 "union_singleton":
 "@[simp]\ntheorem union_singleton : s ‚à™ {a} = insert a s :=\n  union_comm _ _\n#align union_singleton union_singleton\n\n",
 "union_self":
 "@[simp]\ntheorem union_self (a : set Œ±) : a ‚à™ a = a :=\n  ext fun x => or_self_iff _\n#align union_self union_self\n\n",
 "union_right_comm":
 "theorem union_right_comm (s‚ÇÅ s‚ÇÇ s‚ÇÉ : set Œ±) : s‚ÇÅ ‚à™ s‚ÇÇ ‚à™ s‚ÇÉ = s‚ÇÅ ‚à™ s‚ÇÉ ‚à™ s‚ÇÇ :=\n  ext fun x => or_right_comm\n#align union_right_comm union_right_comm\n\n",
 "union_right":
 "theorem union_right (ht : Disjoint s t) (hu : Disjoint s u) : Disjoint s (t ‚à™ u) :=\n  ht.sup_right hu\n#align union_right union_right\n\n",
 "union_nonempty":
 "@[simp]\ntheorem union_nonempty : (s ‚à™ t).nonempty ‚Üî s.nonempty ‚à® t.nonempty :=\n  exists_or\n#align union_nonempty union_nonempty\n\n",
 "union_left_comm":
 "theorem union_left_comm (s‚ÇÅ s‚ÇÇ s‚ÇÉ : set Œ±) : s‚ÇÅ ‚à™ (s‚ÇÇ ‚à™ s‚ÇÉ) = s‚ÇÇ ‚à™ (s‚ÇÅ ‚à™ s‚ÇÉ) :=\n  ext fun x => or_left_comm\n#align union_left_comm union_left_comm\n\n",
 "union_left":
 "theorem union_left (hs : Disjoint s u) (ht : Disjoint t u) : Disjoint (s ‚à™ t) u :=\n  hs.sup_left ht\n#align union_left union_left\n\n",
 "union_inter_distrib_right":
 "theorem union_inter_distrib_right {s t u : set Œ±} : (s ‚à™ t) ‚à© u = s ‚à© u ‚à™ t ‚à© u :=\n  inf_sup_right\n#align union_inter_distrib_right union_inter_distrib_right\n\n",
 "union_inter_distrib_left":
 "theorem union_inter_distrib_left {s t u : set Œ±} : s ‚à™ t ‚à© u = (s ‚à™ t) ‚à© (s ‚à™ u) :=\n  sup_inf_left\n#align union_inter_distrib_left union_inter_distrib_left\n\n",
 "union_inter_cancel_right":
 "theorem union_inter_cancel_right {s t : set Œ±} : (s ‚à™ t) ‚à© t = t :=\n  inter_eq_self_of_subset_right <| subset_union_right _ _\n#align union_inter_cancel_right union_inter_cancel_right\n\n",
 "union_inter_cancel_left":
 "theorem union_inter_cancel_left {s t : set Œ±} : (s ‚à™ t) ‚à© s = s :=\n  inter_eq_self_of_subset_right <| subset_union_left _ _\n#align union_inter_cancel_left union_inter_cancel_left\n\n",
 "union_insert":
 "@[simp]\ntheorem union_insert : s ‚à™ insert a t = insert a (s ‚à™ t) :=\n  ext fun x => or_left_comm\n#align union_insert union_insert\n\n",
 "union_eq_union_iff_right":
 "theorem union_eq_union_iff_right : s ‚à™ u = t ‚à™ u ‚Üî s ‚äÜ t ‚à™ u ‚àß t ‚äÜ s ‚à™ u :=\n  sup_eq_sup_iff_right\n#align union_eq_union_iff_right union_eq_union_iff_right\n\n",
 "union_eq_union_iff_left":
 "theorem union_eq_union_iff_left : s ‚à™ t = s ‚à™ u ‚Üî t ‚äÜ s ‚à™ u ‚àß u ‚äÜ s ‚à™ t :=\n  sup_eq_sup_iff_left\n#align union_eq_union_iff_left union_eq_union_iff_left\n\n",
 "union_eq_self_of_subset_right":
 "theorem union_eq_self_of_subset_right {s t : set Œ±} (h : t ‚äÜ s) : s ‚à™ t = s :=\n  union_eq_left_iff_subset.mpr h\n#align union_eq_self_of_subset_right union_eq_self_of_subset_right\n\n",
 "union_eq_self_of_subset_left":
 "theorem union_eq_self_of_subset_left {s t : set Œ±} (h : s ‚äÜ t) : s ‚à™ t = t :=\n  union_eq_right_iff_subset.mpr h\n#align union_eq_self_of_subset_left union_eq_self_of_subset_left\n\n",
 "union_eq_right_iff_subset":
 "@[simp]\ntheorem union_eq_right_iff_subset {s t : set Œ±} : s ‚à™ t = t ‚Üî s ‚äÜ t :=\n  sup_eq_right\n#align union_eq_right_iff_subset union_eq_right_iff_subset\n\n",
 "union_eq_left_iff_subset":
 "@[simp]\ntheorem union_eq_left_iff_subset {s t : set Œ±} : s ‚à™ t = s ‚Üî t ‚äÜ s :=\n  sup_eq_left\n#align union_eq_left_iff_subset union_eq_left_iff_subset\n\n",
 "union_eq_diff_union_diff_union_inter":
 "theorem union_eq_diff_union_diff_union_inter (s t : set Œ±) : s ‚à™ t = s \\ t ‚à™ t \\ s ‚à™ s ‚à© t :=\n  sup_eq_sdiff_sup_sdiff_sup_inf\n#align union_eq_diff_union_diff_union_inter union_eq_diff_union_diff_union_inter\n\n",
 "union_eq_compl_compl_inter_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem union_eq_compl_compl_inter_compl (s t : set Œ±) : s ‚à™ t = ¬´expr ·∂ú¬ª (¬´expr ·∂ú¬ª s ‚à© ¬´expr ·∂ú¬ª t) :=\n  ext fun x => or_iff_not_and_not\n#align union_eq_compl_compl_inter_compl union_eq_compl_compl_inter_compl\n\n",
 "union_empty_iff":
 "@[simp]\ntheorem union_empty_iff {s t : set Œ±} : s ‚à™ t = ‚àÖ ‚Üî s = ‚àÖ ‚àß t = ‚àÖ := by\n  simp only [‚Üê subset_empty_iff] <;> exact union_subset_iff\n#align union_empty_iff union_empty_iff\n\n",
 "union_empty":
 "@[simp]\ntheorem union_empty (a : set Œ±) : a ‚à™ ‚àÖ = a :=\n  ext fun x => or_false_iff _\n#align union_empty union_empty\n\n",
 "union_distrib_right":
 "theorem union_distrib_right (s t u : set Œ±) : s ‚à© t ‚à™ u = (s ‚à™ u) ‚à© (t ‚à™ u) :=\n  sup_inf_right\n#align union_distrib_right union_distrib_right\n\n",
 "union_distrib_left":
 "theorem union_distrib_left (s t u : set Œ±) : s ‚à™ t ‚à© u = (s ‚à™ t) ‚à© (s ‚à™ u) :=\n  sup_inf_left\n#align union_distrib_left union_distrib_left\n\n",
 "union_diff_self":
 "@[simp]\ntheorem union_diff_self {s t : set Œ±} : s ‚à™ t \\ s = s ‚à™ t :=\n  sup_sdiff_self _ _\n#align union_diff_self union_diff_self\n\n",
 "union_diff_right":
 "@[simp]\ntheorem union_diff_right {s t : set Œ±} : (s ‚à™ t) \\ t = s \\ t :=\n  sup_sdiff_right_self\n#align union_diff_right union_diff_right\n\n",
 "union_diff_left":
 "@[simp]\ntheorem union_diff_left {s t : set Œ±} : (s ‚à™ t) \\ s = t \\ s :=\n  sup_sdiff_left_self\n#align union_diff_left union_diff_left\n\n",
 "union_diff_distrib":
 "theorem union_diff_distrib {s t u : set Œ±} : (s ‚à™ t) \\ u = s \\ u ‚à™ t \\ u :=\n  sup_sdiff\n#align union_diff_distrib union_diff_distrib\n\n",
 "union_diff_cancel_right":
 "theorem union_diff_cancel_right {s t : set Œ±} (h : s ‚à© t ‚äÜ ‚àÖ) : (s ‚à™ t) \\ t = s :=\n  Disjoint.sup_sdiff_cancel_right <| disjoint_iff_inf_le.2 h\n#align union_diff_cancel_right union_diff_cancel_right\n\n",
 "union_diff_cancel_left":
 "theorem union_diff_cancel_left {s t : set Œ±} (h : s ‚à© t ‚äÜ ‚àÖ) : (s ‚à™ t) \\ s = t :=\n  Disjoint.sup_sdiff_cancel_left <| disjoint_iff_inf_le.2 h\n#align union_diff_cancel_left union_diff_cancel_left\n\n",
 "union_diff_cancel'":
 "theorem union_diff_cancel' {s t u : set Œ±} (h‚ÇÅ : s ‚äÜ t) (h‚ÇÇ : t ‚äÜ u) : t ‚à™ u \\ s = u :=\n  sup_sdiff_cancel' h‚ÇÅ h‚ÇÇ\n#align union_diff_cancel' union_diff_cancel'\n\n",
 "union_diff_cancel":
 "theorem union_diff_cancel {s t : set Œ±} (h : s ‚äÜ t) : s ‚à™ t \\ s = t :=\n  sup_sdiff_cancel_right h\n#align union_diff_cancel union_diff_cancel\n\n",
 "union_def":
 "theorem union_def {s‚ÇÅ s‚ÇÇ : set Œ±} : s‚ÇÅ ‚à™ s‚ÇÇ = { a | a ‚àà s‚ÇÅ ‚à® a ‚àà s‚ÇÇ } :=\n  rfl\n#align union_def union_def\n\n",
 "union_congr_right":
 "theorem union_congr_right (hs : s ‚äÜ t ‚à™ u) (ht : t ‚äÜ s ‚à™ u) : s ‚à™ u = t ‚à™ u :=\n  sup_congr_right hs ht\n#align union_congr_right union_congr_right\n\n",
 "union_congr_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äî ¬ª -/\ntheorem union_congr_left (ht : t ‚äÜ s ‚à™ u) (hu : u ‚äÜ s ‚à™ t) : s ‚à™ t = ¬´expr ‚äî ¬ª s u :=\n  sup_congr_left ht hu\n#align union_congr_left union_congr_left\n\n",
 "union_compl_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem union_compl_self (s : set Œ±) : s ‚à™ ¬´expr ·∂ú¬ª s = univ :=\n  eq_univ_iff_forall.2 fun x => em _\n#align union_compl_self union_compl_self\n\n",
 "union_comm":
 "theorem union_comm (a b : set Œ±) : a ‚à™ b = b ‚à™ a :=\n  ext fun x => or_comm\n#align union_comm union_comm\n\n",
 "union_assoc":
 "theorem union_assoc (a b c : set Œ±) : a ‚à™ b ‚à™ c = a ‚à™ (b ‚à™ c) :=\n  ext fun x => or_assoc\n#align union_assoc union_assoc\n\n",
 "union":
 "#print AntitoneOn.union /-\ntheorem AntitoneOn.union [preorder Œ≤] {f g : Œ≤ ‚Üí set Œ±} {s : set Œ≤} (hf : antitone_on f s) (hg : antitone_on g s) :\n    antitone_on (fun x => f x ‚à™ g x) s :=\n  hf.sup hg\n#align antitone_on.union AntitoneOn.union\n-/\n\n",
 "trans":
 "@[trans]\ntheorem subset.trans {a b c : set Œ±} (ab : a ‚äÜ b) (bc : b ‚äÜ c) : a ‚äÜ c := fun x h => bc <| ab h\n#align subset.trans subset.trans\n\n",
 "top_eq_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä§¬ª -/\n/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\n@[simp]\ntheorem top_eq_univ : (¬´expr‚ä§¬ª : set Œ±) = univ :=\n  rfl\n#align top_eq_univ top_eq_univ\n\n",
 "to_type":
 "theorem nonempty.to_type : s.nonempty ‚Üí nonempty Œ± := fun ‚ü®x, hx‚ü© => ‚ü®x‚ü©\n#align nonempty.to_type nonempty.to_type\n\n",
 "to_subtype":
 "theorem nonempty.to_subtype : s.nonempty ‚Üí nonempty s :=\n  nonempty_subtype.2\n#align nonempty.to_subtype nonempty.to_subtype\n\n",
 "symm_diff_subset_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\ntheorem symm_diff_subset_union : ¬´expr ‚àÜ ¬ª s t ‚äÜ s ‚à™ t :=\n  @symmDiff_le_sup (set Œ±) _ _ _\n#align symm_diff_subset_union symm_diff_subset_union\n\n",
 "symm_diff_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n@[simp]\ntheorem symm_diff_nonempty : (¬´expr ‚àÜ ¬ª s t).nonempty ‚Üî s ‚â† t :=\n  nonempty_iff_ne_empty.trans symmDiff_eq_empty.not\n#align symm_diff_nonempty symm_diff_nonempty\n\n",
 "symm_diff_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n@[simp]\ntheorem symm_diff_eq_empty : ¬´expr ‚àÜ ¬ª s t = ‚àÖ ‚Üî s = t :=\n  symmDiff_eq_bot\n#align symm_diff_eq_empty symm_diff_eq_empty\n\n",
 "symmDiff_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n#print symmDiff_def /-\nprotected theorem symmDiff_def (s t : set Œ±) : ¬´expr ‚àÜ ¬ª s t = s \\ t ‚à™ t \\ s :=\n  rfl\n#align symm_diff_def symmDiff_def\n-/\n\n",
 "sup_eq_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `¬´expr ‚äî ¬ª -/\n@[simp]\ntheorem sup_eq_union : ((¬´expr ‚äî ¬ª ¬∑ ¬∑) : set Œ± ‚Üí set Œ± ‚Üí set Œ±) = (¬∑ ‚à™ ¬∑) :=\n  rfl\n#align sup_eq_union sup_eq_union\n\n",
 "subsingleton_univ_iff":
 "@[simp]\ntheorem subsingleton_univ_iff : (univ : set Œ±).subsingleton ‚Üî subsingleton Œ± :=\n  ‚ü®subsingleton_of_univ_subsingleton, fun h => @subsingleton_univ _ h‚ü©\n#align subsingleton_univ_iff subsingleton_univ_iff\n\n",
 "subsingleton_univ":
 "theorem subsingleton_univ [subsingleton Œ±] : (univ : set Œ±).subsingleton := fun x hx y hy => subsingleton.elim x y\n#align subsingleton_univ subsingleton_univ\n\n",
 "subsingleton_singleton":
 "@[simp]\ntheorem subsingleton_singleton {a} : ({a} : set Œ±).subsingleton := fun x hx y hy =>\n  (eq_of_mem_singleton hx).symm ‚ñ∏ (eq_of_mem_singleton hy).symm ‚ñ∏ rfl\n#align subsingleton_singleton subsingleton_singleton\n\n",
 "subsingleton_or_nontrivial":
 "#print subsingleton_or_nontrivial /-\nprotected theorem subsingleton_or_nontrivial (s : set Œ±) : s.subsingleton ‚à® s.nontrivial := by\n  simp [or_iff_not_imp_right]\n#align subsingleton_or_nontrivial subsingleton_or_nontrivial\n-/\n\n",
 "subsingleton_of_univ_subsingleton":
 "theorem subsingleton_of_univ_subsingleton (h : (univ : set Œ±).subsingleton) : subsingleton Œ± :=\n  ‚ü®fun a b => h (mem_univ a) (mem_univ b)‚ü©\n#align subsingleton_of_univ_subsingleton subsingleton_of_univ_subsingleton\n\n",
 "subsingleton_of_subsingleton":
 "theorem subsingleton_of_subsingleton [subsingleton Œ±] {s : set Œ±} : Set.Subsingleton s :=\n  subsingleton_univ.anti (subset_univ s)\n#align subsingleton_of_subsingleton subsingleton_of_subsingleton\n\n",
 "subsingleton_of_subset_singleton":
 "theorem subsingleton_of_subset_singleton (h : s ‚äÜ {a}) : s.subsingleton :=\n  subsingleton_singleton.anti h\n#align subsingleton_of_subset_singleton subsingleton_of_subset_singleton\n\n",
 "subsingleton_of_forall_eq":
 "#print subsingleton_of_forall_eq /-\ntheorem subsingleton_of_forall_eq (a : Œ±) (h : ‚àÄ b ‚àà s, b = a) : s.subsingleton := fun b hb c hc =>\n  (h _ hb).trans (h _ hc).symm\n#align subsingleton_of_forall_eq subsingleton_of_forall_eq\n-/\n\n",
 "subsingleton_is_top":
 "theorem subsingleton_is_top (Œ± : Type _) [partial_order Œ±] : Set.Subsingleton { x : Œ± | is_top x } := fun x hx y hy =>\n  hx.is_max.eq_of_le (hy x)\n#align subsingleton_is_top subsingleton_is_top\n\n",
 "subsingleton_is_bot":
 "theorem subsingleton_is_bot (Œ± : Type _) [partial_order Œ±] : Set.Subsingleton { x : Œ± | is_bot x } := fun x hx y hy =>\n  hx.is_min.eq_of_ge (hy x)\n#align subsingleton_is_bot subsingleton_is_bot\n\n",
 "subsingleton_iff_singleton":
 "theorem subsingleton_iff_singleton {x} (hx : x ‚àà s) : s.subsingleton ‚Üî s = {x} :=\n  ‚ü®fun h => h.eq_singleton_of_mem hx, fun h => h.symm ‚ñ∏ subsingleton_singleton‚ü©\n#align subsingleton_iff_singleton subsingleton_iff_singleton\n\n",
 "subsingleton_empty":
 "@[simp]\ntheorem subsingleton_empty : (‚àÖ : set Œ±).subsingleton := fun x => false.elim\n#align subsingleton_empty subsingleton_empty\n\n",
 "subsingleton_coe":
 "/-- `s`, coerced to a type, is a subsingleton type if and only if `s` is a subsingleton set. -/\n@[simp, norm_cast]\ntheorem subsingleton_coe (s : set Œ±) : subsingleton s ‚Üî s.subsingleton :=\n  by\n  constructor\n  ¬∑ refine' fun h => fun a ha b hb => _\n    exact SetCoe.ext_iff.2 (@subsingleton.elim s h ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©)\n  ¬∑ exact fun h => subsingleton.intro fun a b => SetCoe.ext (h a.property b.property)\n#align subsingleton_coe subsingleton_coe\n\n",
 "subset_univ":
 "@[simp]\ntheorem subset_univ (s : set Œ±) : s ‚äÜ univ := fun x H => trivial\n#align subset_univ subset_univ\n\n",
 "subset_union_right":
 "@[simp]\ntheorem subset_union_right (s t : set Œ±) : t ‚äÜ s ‚à™ t := fun x => or.inr\n#align subset_union_right subset_union_right\n\n",
 "subset_union_of_subset_right":
 "theorem subset_union_of_subset_right {s u : set Œ±} (h : s ‚äÜ u) (t : set Œ±) : s ‚äÜ t ‚à™ u :=\n  Subset.trans h (subset_union_right t u)\n#align subset_union_of_subset_right subset_union_of_subset_right\n\n",
 "subset_union_of_subset_left":
 "theorem subset_union_of_subset_left {s t : set Œ±} (h : s ‚äÜ t) (u : set Œ±) : s ‚äÜ t ‚à™ u :=\n  Subset.trans h (subset_union_left t u)\n#align subset_union_of_subset_left subset_union_of_subset_left\n\n",
 "subset_union_left":
 "@[simp]\ntheorem subset_union_left (s t : set Œ±) : s ‚äÜ s ‚à™ t := fun x => or.inl\n#align subset_union_left subset_union_left\n\n",
 "subset_union_compl_iff_inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem subset_union_compl_iff_inter_subset {s t u : set Œ±} : s ‚äÜ t ‚à™ ¬´expr ·∂ú¬ª u ‚Üî s ‚à© u ‚äÜ t :=\n  (@isCompl_compl _ u _).le_sup_right_iff_inf_left_le\n#align subset_union_compl_iff_inter_subset subset_union_compl_iff_inter_subset\n\n",
 "subset_symm_diff_union_symm_diff_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\ntheorem subset_symm_diff_union_symm_diff_right (h : Disjoint t u) : s ‚äÜ ¬´expr ‚àÜ ¬ª s t ‚à™ ¬´expr ‚àÜ ¬ª s u :=\n  h.le_symm_diff_sup_symm_diff_right\n#align subset_symm_diff_union_symm_diff_right subset_symm_diff_union_symm_diff_right\n\n",
 "subset_symm_diff_union_symm_diff_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\ntheorem subset_symm_diff_union_symm_diff_left (h : Disjoint s t) : u ‚äÜ ¬´expr ‚àÜ ¬ª s u ‚à™ ¬´expr ‚àÜ ¬ª t u :=\n  h.le_symm_diff_sup_symm_diff_left\n#align subset_symm_diff_union_symm_diff_left subset_symm_diff_union_symm_diff_left\n\n",
 "subset_singleton_iff_eq":
 "theorem subset_singleton_iff_eq {s : set Œ±} {x : Œ±} : s ‚äÜ {x} ‚Üî s = ‚àÖ ‚à® s = {x} :=\n  by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  use ‚ü®fun _ => or.inl rfl, fun _ => empty_subset _‚ü©\n  simp [eq_singleton_iff_nonempty_unique_mem, hs, hs.ne_empty]\n#align subset_singleton_iff_eq subset_singleton_iff_eq\n\n",
 "subset_singleton_iff":
 "theorem nonempty.subset_singleton_iff (h : s.nonempty) : s ‚äÜ {a} ‚Üî s = {a} :=\n  subset_singleton_iff_eq.trans <| or_iff_right h.ne_empty\n#align nonempty.subset_singleton_iff nonempty.subset_singleton_iff\n\n",
 "subset_right_of_subset_union":
 "theorem subset_right_of_subset_union (h : s ‚äÜ t ‚à™ u) (hab : Disjoint s t) : s ‚äÜ u :=\n  hab.left_le_of_le_sup_left h\n#align subset_right_of_subset_union subset_right_of_subset_union\n\n",
 "subset_of_mem_powerset":
 "theorem subset_of_mem_powerset {x s : set Œ±} (h : x ‚àà ùí´ s) : x ‚äÜ s :=\n  h\n#align subset_of_mem_powerset subset_of_mem_powerset\n\n",
 "subset_left_of_subset_union":
 "theorem subset_left_of_subset_union (h : s ‚äÜ t ‚à™ u) (hac : Disjoint s u) : s ‚äÜ t :=\n  hac.left_le_of_le_sup_right h\n#align subset_left_of_subset_union subset_left_of_subset_union\n\n",
 "subset_ite":
 "theorem subset_ite {t s s' u : set Œ±} : u ‚äÜ t.ite s s' ‚Üî u ‚à© t ‚äÜ s ‚àß u \\ t ‚äÜ s' :=\n  by\n  simp only [subset_def, ‚Üê forall_and]\n  refine' forall_congr' fun x => _\n  by_cases hx : x ‚àà t <;> simp [*, Set.ite]\n#align subset_ite subset_ite\n\n",
 "subset_inter_iff":
 "@[simp]\ntheorem subset_inter_iff {s t r : set Œ±} : r ‚äÜ s ‚à© t ‚Üî r ‚äÜ s ‚àß r ‚äÜ t :=\n  (forall_congr' fun x => imp_and).trans forall_and\n#align subset_inter_iff subset_inter_iff\n\n",
 "subset_inter":
 "theorem subset_inter {s t r : set Œ±} (rs : r ‚äÜ s) (rt : r ‚äÜ t) : r ‚äÜ s ‚à© t := fun x h => ‚ü®rs h, rt h‚ü©\n#align subset_inter subset_inter\n\n",
 "subset_insert_diff_singleton":
 "theorem subset_insert_diff_singleton (x : Œ±) (s : set Œ±) : s ‚äÜ insert x (s \\ {x}) := by rw [‚Üê diff_singleton_subset_iff]\n#align subset_insert_diff_singleton subset_insert_diff_singleton\n\n",
 "subset_insert":
 "@[simp]\ntheorem subset_insert (x : Œ±) (s : set Œ±) : s ‚äÜ insert x s := fun y => or.inr\n#align subset_insert subset_insert\n\n",
 "subset_eq_empty":
 "theorem subset_eq_empty {s t : set Œ±} (h : t ‚äÜ s) (e : s = ‚àÖ) : t = ‚àÖ :=\n  subset_empty_iff.1 <| e ‚ñ∏ h\n#align subset_eq_empty subset_eq_empty\n\n",
 "subset_empty_iff":
 "theorem subset_empty_iff {s : set Œ±} : s ‚äÜ ‚àÖ ‚Üî s = ‚àÖ :=\n  (Subset.antisymm_iff.trans <| and_iff_left (empty_subset _)).symm\n#align subset_empty_iff subset_empty_iff\n\n",
 "subset_diff_union":
 "theorem subset_diff_union (s t : set Œ±) : s ‚äÜ s \\ t ‚à™ t :=\n  show s ‚â§ s \\ t ‚à™ t from le_sdiff_sup\n#align subset_diff_union subset_diff_union\n\n",
 "subset_diff_singleton":
 "theorem subset_diff_singleton {x : Œ±} {s t : set Œ±} (h : s ‚äÜ t) (hx : x ‚àâ s) : s ‚äÜ t \\ {x} :=\n  subset_inter h <| subset_compl_comm.1 <| singleton_subset_iff.2 hx\n#align subset_diff_singleton subset_diff_singleton\n\n",
 "subset_diff":
 "theorem subset_diff : s ‚äÜ t \\ u ‚Üî s ‚äÜ t ‚àß Disjoint s u :=\n  le_iff_subset.symm.trans le_sdiff\n#align subset_diff subset_diff\n\n",
 "subset_def":
 "-- TODO(Jeremy): write a tactic to unfold specific instances of generic notation?\ntheorem subset_def : (s ‚äÜ t) = ‚àÄ x, x ‚àà s ‚Üí x ‚àà t :=\n  rfl\n#align subset_def subset_def\n\n",
 "subset_compl_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem subset_compl_singleton_iff {a : Œ±} {s : set Œ±} : s ‚äÜ ¬´expr ·∂ú¬ª {a} ‚Üî a ‚àâ s :=\n  subset_compl_comm.trans singleton_subset_iff\n#align subset_compl_singleton_iff subset_compl_singleton_iff\n\n",
 "subset_compl_iff_disjoint_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem subset_compl_iff_disjoint_right : s ‚äÜ ¬´expr ·∂ú¬ª t ‚Üî Disjoint s t :=\n  @le_compl_iff_disjoint_right (set Œ±) _ _ _\n#align subset_compl_iff_disjoint_right subset_compl_iff_disjoint_right\n\n",
 "subset_compl_iff_disjoint_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem subset_compl_iff_disjoint_left : s ‚äÜ ¬´expr ·∂ú¬ª t ‚Üî Disjoint t s :=\n  @le_compl_iff_disjoint_left (set Œ±) _ _ _\n#align subset_compl_iff_disjoint_left subset_compl_iff_disjoint_left\n\n",
 "subset_compl_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem subset_compl_comm : s ‚äÜ ¬´expr ·∂ú¬ª t ‚Üî t ‚äÜ ¬´expr ·∂ú¬ª s :=\n  @le_compl_iff_le_compl _ _ _ t\n#align subset_compl_comm subset_compl_comm\n\n",
 "subset":
 "#print Eq.subset /-\n/-- Duplicate of `eq.subset'`, which currently has elaboration problems. -/\ntheorem Eq.subset {Œ±} {s t : set Œ±} : s = t ‚Üí s ‚äÜ t :=\n  Eq.subset'\n#align eq.subset Eq.subset\n-/\n\n",
 "strict_mono_on_singleton":
 "@[simp]\ntheorem strict_mono_on_singleton : strict_mono_on f {a} :=\n  subsingleton_singleton.strict_mono_on f\n#align strict_mono_on_singleton strict_mono_on_singleton\n\n",
 "strict_mono_on_iff_strict_mono":
 "theorem strict_mono_on_iff_strict_mono : strict_mono_on f s ‚Üî strict_mono fun a : s => f a := by\n  simp [strict_mono, strict_mono_on]\n#align strict_mono_on_iff_strict_mono strict_mono_on_iff_strict_mono\n\n",
 "strict_mono_on":
 "protected theorem subsingleton.strict_mono_on (h : s.subsingleton) : strict_mono_on f s := fun a ha b hb hlt =>\n  (hlt.ne (h ha hb)).elim\n#align subsingleton.strict_mono_on subsingleton.strict_mono_on\n\n",
 "strict_anti_on_singleton":
 "@[simp]\ntheorem strict_anti_on_singleton : strict_anti_on f {a} :=\n  subsingleton_singleton.strict_anti_on f\n#align strict_anti_on_singleton strict_anti_on_singleton\n\n",
 "strict_anti_on_iff_strict_anti":
 "theorem strict_anti_on_iff_strict_anti : strict_anti_on f s ‚Üî strict_anti fun a : s => f a := by\n  simp [strict_anti, strict_anti_on]\n#align strict_anti_on_iff_strict_anti strict_anti_on_iff_strict_anti\n\n",
 "strict_anti_on":
 "protected theorem subsingleton.strict_anti_on (h : s.subsingleton) : strict_anti_on f s := fun a ha b hb hlt =>\n  (hlt.ne (h ha hb)).elim\n#align subsingleton.strict_anti_on subsingleton.strict_anti_on\n\n",
 "ssubset_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem ssubset_univ_iff : ¬´expr ‚äÇ ¬ª s univ ‚Üî s ‚â† univ :=\n  lt_top_iff_ne_top\n#align ssubset_univ_iff ssubset_univ_iff\n\n",
 "ssubset_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem ssubset_singleton_iff {s : set Œ±} {x : Œ±} : ¬´expr ‚äÇ ¬ª s {x} ‚Üî s = ‚àÖ :=\n  by\n  rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_right, and_not_self_iff, or_false_iff,\n    and_iff_left_iff_imp]\n  exact fun h => ne_of_eq_of_ne h (singleton_ne_empty _).symm\n#align ssubset_singleton_iff ssubset_singleton_iff\n\n",
 "ssubset_of_subset_of_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n#print ssubset_of_subset_of_ssubset /-\nprotected theorem ssubset_of_subset_of_ssubset {s‚ÇÅ s‚ÇÇ s‚ÇÉ : set Œ±} (hs‚ÇÅs‚ÇÇ : s‚ÇÅ ‚äÜ s‚ÇÇ) (hs‚ÇÇs‚ÇÉ : ¬´expr ‚äÇ ¬ª s‚ÇÇ s‚ÇÉ) :\n    ¬´expr ‚äÇ ¬ª s‚ÇÅ s‚ÇÉ :=\n  ‚ü®Subset.trans hs‚ÇÅs‚ÇÇ hs‚ÇÇs‚ÇÉ.1, fun hs‚ÇÉs‚ÇÅ => hs‚ÇÇs‚ÇÉ.2 (Subset.trans hs‚ÇÉs‚ÇÅ hs‚ÇÅs‚ÇÇ)‚ü©\n#align ssubset_of_subset_of_ssubset ssubset_of_subset_of_ssubset\n-/\n\n",
 "ssubset_of_ssubset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n#print ssubset_of_ssubset_of_subset /-\nprotected theorem ssubset_of_ssubset_of_subset {s‚ÇÅ s‚ÇÇ s‚ÇÉ : set Œ±} (hs‚ÇÅs‚ÇÇ : ¬´expr ‚äÇ ¬ª s‚ÇÅ s‚ÇÇ) (hs‚ÇÇs‚ÇÉ : s‚ÇÇ ‚äÜ s‚ÇÉ) :\n    ¬´expr ‚äÇ ¬ª s‚ÇÅ s‚ÇÉ :=\n  ‚ü®Subset.trans hs‚ÇÅs‚ÇÇ.1 hs‚ÇÇs‚ÇÉ, fun hs‚ÇÉs‚ÇÅ => hs‚ÇÅs‚ÇÇ.2 (Subset.trans hs‚ÇÇs‚ÇÉ hs‚ÇÉs‚ÇÅ)‚ü©\n#align ssubset_of_ssubset_of_subset ssubset_of_ssubset_of_subset\n-/\n\n",
 "ssubset_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem ssubset_insert {s : set Œ±} {a : Œ±} (h : a ‚àâ s) : ¬´expr ‚äÇ ¬ª s (insert a s) :=\n  ssubset_iff_insert.2 ‚ü®a, h, Subset.rfl‚ü©\n#align ssubset_insert ssubset_insert\n\n",
 "ssubset_iff_subset_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n#print ssubset_iff_subset_ne /-\nprotected theorem ssubset_iff_subset_ne {s t : set Œ±} : ¬´expr ‚äÇ ¬ª s t ‚Üî s ‚äÜ t ‚àß s ‚â† t :=\n  @lt_iff_le_and_ne (set Œ±) _ s t\n#align ssubset_iff_subset_ne ssubset_iff_subset_ne\n-/\n\n",
 "ssubset_iff_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem ssubset_iff_of_subset {s t : set Œ±} (h : s ‚äÜ t) : ¬´expr ‚äÇ ¬ª s t ‚Üî ‚àÉ x ‚àà t, x ‚àâ s :=\n  ‚ü®exists_of_ssubset, fun ‚ü®x, hxt, hxs‚ü© => ‚ü®h, fun h => hxs <| h hxt‚ü©‚ü©\n#align ssubset_iff_of_subset ssubset_iff_of_subset\n\n",
 "ssubset_iff_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a ¬´expr ‚àâ ¬ª s) -/\ntheorem ssubset_iff_insert {s t : set Œ±} : ¬´expr ‚äÇ ¬ª s t ‚Üî ‚àÉ (a : _)(_ : a ‚àâ s), insert a s ‚äÜ t :=\n  by\n  simp only [insert_subset, exists_and_right, ssubset_def, not_subset]\n  simp only [exists_prop, and_comm']\n#align ssubset_iff_insert ssubset_iff_insert\n\n",
 "ssubset_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem ssubset_def : ¬´expr ‚äÇ ¬ª s t = (s ‚äÜ t ‚àß ¬¨t ‚äÜ s) :=\n  rfl\n#align ssubset_def ssubset_def\n\n",
 "some_snd_mem":
 "protected theorem nontrivial.some_snd_mem (hs : s.nontrivial) : hs.some.snd ‚àà s :=\n  hs.some_spec.some_spec.some_spec.some\n#align nontrivial.some_snd_mem nontrivial.some_snd_mem\n\n",
 "some_mem":
 "protected theorem nonempty.some_mem (h : s.nonempty) : h.some ‚àà s :=\n  Classical.choose_spec h\n#align nonempty.some_mem nonempty.some_mem\n\n",
 "some_fst_ne_some_snd":
 "protected theorem nontrivial.some_fst_ne_some_snd (hs : s.nontrivial) : hs.some.fst ‚â† hs.some.snd :=\n  hs.some_spec.some_spec.some_spec.some_spec\n#align nontrivial.some_fst_ne_some_snd nontrivial.some_fst_ne_some_snd\n\n",
 "some_fst_mem":
 "protected theorem nontrivial.some_fst_mem (hs : s.nontrivial) : hs.some.fst ‚àà s :=\n  hs.some_spec.some\n#align nontrivial.some_fst_mem nontrivial.some_fst_mem\n\n",
 "singleton_union":
 "@[simp]\ntheorem singleton_union : {a} ‚à™ s = insert a s :=\n  rfl\n#align singleton_union singleton_union\n\n",
 "singleton_subset_iff":
 "@[simp]\ntheorem singleton_subset_iff {a : Œ±} {s : set Œ±} : {a} ‚äÜ s ‚Üî a ‚àà s :=\n  forall_eq\n#align singleton_subset_iff singleton_subset_iff\n\n",
 "singleton_nonempty":
 "@[simp]\ntheorem singleton_nonempty (a : Œ±) : ({a} : set Œ±).nonempty :=\n  ‚ü®a, rfl‚ü©\n#align singleton_nonempty singleton_nonempty\n\n",
 "singleton_ne_empty":
 "@[simp]\ntheorem singleton_ne_empty (a : Œ±) : ({a} : set Œ±) ‚â† ‚àÖ :=\n  (singleton_nonempty _).ne_empty\n#align singleton_ne_empty singleton_ne_empty\n\n",
 "singleton_inter_nonempty":
 "@[simp]\ntheorem singleton_inter_nonempty : ({a} ‚à© s).nonempty ‚Üî a ‚àà s := by\n  simp only [Set.Nonempty, mem_inter_iff, mem_singleton_iff, exists_eq_left]\n#align singleton_inter_nonempty singleton_inter_nonempty\n\n",
 "singleton_inter_eq_empty":
 "@[simp]\ntheorem singleton_inter_eq_empty : {a} ‚à© s = ‚àÖ ‚Üî a ‚àâ s :=\n  not_nonempty_iff_eq_empty.symm.trans singleton_inter_nonempty.not\n#align singleton_inter_eq_empty singleton_inter_eq_empty\n\n",
 "singleton_injective":
 "theorem singleton_injective : injective (singleton : Œ± ‚Üí set Œ±) := fun _ _ => singleton_eq_singleton_iff.mp\n#align singleton_injective singleton_injective\n\n",
 "singleton_eq_singleton_iff":
 "@[simp]\ntheorem singleton_eq_singleton_iff {x y : Œ±} : {x} = ({y} : set Œ±) ‚Üî x = y :=\n  ext_iff.trans eq_iff_eq_cancel_left\n#align singleton_eq_singleton_iff singleton_eq_singleton_iff\n\n",
 "singleton_def":
 "theorem singleton_def (a : Œ±) : ({a} : set Œ±) = insert a ‚àÖ :=\n  (insert_emptyc_eq _).symm\n#align singleton_def singleton_def\n\n",
 "set_of_true":
 "@[simp]\ntheorem set_of_true : { x : Œ± | true } = univ :=\n  rfl\n#align set_of_true set_of_true\n\n",
 "set_of_subset_set_of":
 "@[simp]\ntheorem set_of_subset_set_of {p q : Œ± ‚Üí Prop} : { a | p a } ‚äÜ { a | q a } ‚Üî ‚àÄ a, p a ‚Üí q a :=\n  iff.rfl\n#align set_of_subset_set_of set_of_subset_set_of\n\n",
 "set_of_set":
 "theorem set_of_set {s : set Œ±} : set_of s = s :=\n  rfl\n#align set_of_set set_of_set\n\n",
 "set_of_or":
 "theorem set_of_or {p q : Œ± ‚Üí Prop} : { a | p a ‚à® q a } = { a | p a } ‚à™ { a | q a } :=\n  rfl\n#align set_of_or set_of_or\n\n",
 "set_of_mem_eq":
 "@[simp]\ntheorem set_of_mem_eq {s : set Œ±} : { x | x ‚àà s } = s :=\n  rfl\n#align set_of_mem_eq set_of_mem_eq\n\n",
 "set_of_false":
 "@[simp]\ntheorem set_of_false : { a : Œ± | false } = ‚àÖ :=\n  rfl\n#align set_of_false set_of_false\n\n",
 "set_of_eq_eq_singleton'":
 "@[simp]\ntheorem set_of_eq_eq_singleton' {a : Œ±} : { x | a = x } = {a} :=\n  ext fun x => eq_comm\n#align set_of_eq_eq_singleton' set_of_eq_eq_singleton'\n\n",
 "set_of_eq_eq_singleton":
 "@[simp]\ntheorem set_of_eq_eq_singleton {a : Œ±} : { n | n = a } = {a} :=\n  rfl\n#align set_of_eq_eq_singleton set_of_eq_eq_singleton\n\n",
 "set_of_bijective":
 "theorem set_of_bijective : bijective (set_of : (Œ± ‚Üí Prop) ‚Üí set Œ±) :=\n  bijective_id\n#align set_of_bijective set_of_bijective\n\n",
 "set_of_app_iff":
 "theorem set_of_app_iff {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=\n  iff.rfl\n#align set_of_app_iff set_of_app_iff\n\n",
 "set_of_and":
 "theorem set_of_and {p q : Œ± ‚Üí Prop} : { a | p a ‚àß q a } = { a | p a } ‚à© { a | q a } :=\n  rfl\n#align set_of_and set_of_and\n\n",
 "set_compr_eq_eq_singleton":
 "theorem set_compr_eq_eq_singleton {a : Œ±} : { b | b = a } = {a} :=\n  rfl\n#align set_compr_eq_eq_singleton set_compr_eq_eq_singleton\n\n",
 "set_coe_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n#print set_coe_cast /-\n@[simp]\ntheorem set_coe_cast : ‚àÄ {s t : set Œ±} (H' : s = t) (H : ¬´expr‚Ü• ¬ª s = ¬´expr‚Ü• ¬ª t) (x : s), cast H x = ‚ü®x.1, H' ‚ñ∏ x.2‚ü©\n  | s, _, rfl, _, ‚ü®x, h‚ü© => rfl\n#align set_coe_cast set_coe_cast\n-/\n\n",
 "set_cases":
 "@[elab_as_elim]\ntheorem set_cases {p : set Œ± ‚Üí Prop} (h0 : p ‚àÖ) (h1 : p univ) (s) : p s :=\n  s.eq_empty_or_nonempty.elim (fun h => h.symm ‚ñ∏ h0) fun h => (eq_univ_of_nonempty h).symm ‚ñ∏ h1\n#align set_cases set_cases\n\n",
 "sep_univ":
 "@[simp]\ntheorem sep_univ : { x ‚àà (univ : set Œ±) | p x } = { x | p x } :=\n  univ_inter p\n#align sep_univ sep_univ\n\n",
 "sep_union":
 "@[simp]\ntheorem sep_union : { x ‚àà s ‚à™ t | p x } = { x ‚àà s | p x } ‚à™ { x ‚àà t | p x } :=\n  union_inter_distrib_right\n#align sep_union sep_union\n\n",
 "sep_true":
 "@[simp]\ntheorem sep_true : { x ‚àà s | true } = s :=\n  inter_univ s\n#align sep_true sep_true\n\n",
 "sep_subset":
 "@[simp]\ntheorem sep_subset (s : set Œ±) (p : Œ± ‚Üí Prop) : { x ‚àà s | p x } ‚äÜ s := fun x => And.left\n#align sep_subset sep_subset\n\n",
 "sep_set_of":
 "@[simp]\ntheorem sep_set_of : { x ‚àà { y | p y } | q x } = { x | p x ‚àß q x } :=\n  rfl\n#align sep_set_of sep_set_of\n\n",
 "sep_or":
 "@[simp]\ntheorem sep_or : { x ‚àà s | p x ‚à® q x } = { x ‚àà s | p x } ‚à™ { x ‚àà s | q x } :=\n  inter_union_distrib_left\n#align sep_or sep_or\n\n",
 "sep_mem_eq":
 "@[simp]\ntheorem sep_mem_eq : { x ‚àà s | x ‚àà t } = s ‚à© t :=\n  rfl\n#align sep_mem_eq sep_mem_eq\n\n",
 "sep_inter":
 "@[simp]\ntheorem sep_inter : { x ‚àà s ‚à© t | p x } = { x ‚àà s | p x } ‚à© { x ‚àà t | p x } :=\n  inter_inter_distrib_right s t p\n#align sep_inter sep_inter\n\n",
 "sep_false":
 "@[simp]\ntheorem sep_false : { x ‚àà s | false } = ‚àÖ :=\n  inter_empty s\n#align sep_false sep_false\n\n",
 "sep_ext_iff":
 "theorem sep_ext_iff : { x ‚àà s | p x } = { x ‚àà s | q x } ‚Üî ‚àÄ x ‚àà s, p x ‚Üî q x := by\n  simp_rw [ext_iff, mem_sep_iff, and_congr_right_iff]\n#align sep_ext_iff sep_ext_iff\n\n",
 "sep_eq_self_iff_mem_true":
 "@[simp]\ntheorem sep_eq_self_iff_mem_true : { x ‚àà s | p x } = s ‚Üî ‚àÄ x ‚àà s, p x := by\n  simp_rw [ext_iff, mem_sep_iff, and_iff_left_iff_imp]\n#align sep_eq_self_iff_mem_true sep_eq_self_iff_mem_true\n\n",
 "sep_eq_of_subset":
 "theorem sep_eq_of_subset (h : s ‚äÜ t) : { x ‚àà t | x ‚àà s } = s :=\n  inter_eq_self_of_subset_right h\n#align sep_eq_of_subset sep_eq_of_subset\n\n",
 "sep_eq_empty_iff_mem_false":
 "@[simp]\ntheorem sep_eq_empty_iff_mem_false : { x ‚àà s | p x } = ‚àÖ ‚Üî ‚àÄ x ‚àà s, ¬¨p x := by\n  simp_rw [ext_iff, mem_sep_iff, mem_empty_iff_false, iff_false_iff, not_and]\n#align sep_eq_empty_iff_mem_false sep_eq_empty_iff_mem_false\n\n",
 "sep_empty":
 "@[simp]\ntheorem sep_empty (p : Œ± ‚Üí Prop) : { x ‚àà (‚àÖ : set Œ±) | p x } = ‚àÖ :=\n  empty_inter p\n#align sep_empty sep_empty\n\n",
 "sep_and":
 "@[simp]\ntheorem sep_and : { x ‚àà s | p x ‚àß q x } = { x ‚àà s | p x } ‚à© { x ‚àà s | q x } :=\n  inter_inter_distrib_left s p q\n#align sep_and sep_and\n\n",
 "right":
 "theorem nonempty.right (h : (s ‚à© t).nonempty) : t.nonempty :=\n  h.imp fun _ => And.right\n#align nonempty.right nonempty.right\n\n",
 "rfl":
 "theorem subset.rfl {s : set Œ±} : s ‚äÜ s :=\n  Subset.refl s\n#align subset.rfl subset.rfl\n\n",
 "refl":
 "@[refl]\ntheorem subset.refl (a : set Œ±) : a ‚äÜ a := fun x => id\n#align subset.refl subset.refl\n\n",
 "powerset_univ":
 "@[simp]\ntheorem powerset_univ : ùí´(univ : set Œ±) = univ :=\n  eq_univ_of_forall subset_univ\n#align powerset_univ powerset_univ\n\n",
 "powerset_nonempty":
 "@[simp]\ntheorem powerset_nonempty : (ùí´ s).nonempty :=\n  ‚ü®‚àÖ, empty_subset s‚ü©\n#align powerset_nonempty powerset_nonempty\n\n",
 "powerset_mono":
 "@[simp]\ntheorem powerset_mono : ùí´ s ‚äÜ ùí´ t ‚Üî s ‚äÜ t :=\n  ‚ü®fun h => h (Subset.refl s), fun h u hu => Subset.trans hu h‚ü©\n#align powerset_mono powerset_mono\n\n",
 "powerset_inter":
 "theorem powerset_inter (s t : set Œ±) : ùí´(s ‚à© t) = ùí´ s ‚à© ùí´ t :=\n  ext fun u => subset_inter_iff\n#align powerset_inter powerset_inter\n\n",
 "powerset_empty":
 "@[simp]\ntheorem powerset_empty : ùí´(‚àÖ : set Œ±) = {‚àÖ} :=\n  ext fun s => subset_empty_iff\n#align powerset_empty powerset_empty\n\n",
 "pair_subset":
 "theorem nontrivial.pair_subset (hs : s.nontrivial) : ‚àÉ (x y : _)(hab : x ‚â† y), {x, y} ‚äÜ s :=\n  let ‚ü®x, hx, y, hy, hxy‚ü© := hs\n  ‚ü®x, y, hxy, insert_subset.2 ‚ü®hx, singleton_subset_iff.2 hy‚ü©‚ü©\n#align nontrivial.pair_subset nontrivial.pair_subset\n\n",
 "pair_eq_singleton":
 "@[simp]\ntheorem pair_eq_singleton (a : Œ±) : ({a, a} : set Œ±) = {a} :=\n  union_self _\n#align pair_eq_singleton pair_eq_singleton\n\n",
 "pair_eq_pair_iff":
 "theorem pair_eq_pair_iff {x y z w : Œ±} : ({x, y} : set Œ±) = {z, w} ‚Üî x = z ‚àß y = w ‚à® x = w ‚àß y = z :=\n  by\n  simp only [Set.Subset.antisymm_iff, Set.insert_subset, Set.mem_insert_iff, Set.mem_singleton_iff,\n    Set.singleton_subset_iff]\n  constructor\n  ¬∑ tauto\n  ¬∑ rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©) <;> simp\n#align pair_eq_pair_iff pair_eq_pair_iff\n\n",
 "pair_comm":
 "theorem pair_comm (a b : Œ±) : ({a, b} : set Œ±) = {b, a} :=\n  union_comm _ _\n#align pair_comm pair_comm\n\n",
 "out":
 "#print Membership.Mem.out /-\n/-- If `h : a ‚àà {x | p x}` then `h.out : p x`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`. -/\ntheorem Membership.Mem.out {p : Œ± ‚Üí Prop} {a : Œ±} (h : a ‚àà { x | p x }) : p a :=\n  h\n#align has_mem.mem.out Membership.Mem.out\n-/\n\n",
 "of_diff":
 "theorem nonempty.of_diff (h : (s \\ t).nonempty) : s.nonempty :=\n  h.imp fun _ => And.left\n#align nonempty.of_diff nonempty.of_diff\n\n",
 "not_subsingleton_iff":
 "@[simp]\ntheorem not_subsingleton_iff : ¬¨s.subsingleton ‚Üî s.nontrivial := by\n  simp_rw [Set.Subsingleton, Set.Nontrivial, not_forall]\n#align not_subsingleton_iff not_subsingleton_iff\n\n",
 "not_subset_singleton":
 "theorem nontrivial.not_subset_singleton {x} (hs : s.nontrivial) : ¬¨s ‚äÜ {x} :=\n  (not_congr subset_singleton_iff_eq).2 (not_or_of_not hs.ne_empty hs.ne_singleton)\n#align nontrivial.not_subset_singleton nontrivial.not_subset_singleton\n\n",
 "not_subset_iff_exists_mem_not_mem":
 "theorem not_subset_iff_exists_mem_not_mem {Œ± : Type _} {s t : set Œ±} : ¬¨s ‚äÜ t ‚Üî ‚àÉ x, x ‚àà s ‚àß x ‚àâ t := by\n  simp [subset_def]\n#align not_subset_iff_exists_mem_not_mem not_subset_iff_exists_mem_not_mem\n\n",
 "not_subset_empty":
 "theorem nontrivial.not_subset_empty (hs : s.nontrivial) : ¬¨s ‚äÜ ‚àÖ :=\n  hs.nonempty.not_subset_empty\n#align nontrivial.not_subset_empty nontrivial.not_subset_empty\n\n",
 "not_subset":
 "theorem not_subset : ¬¨s ‚äÜ t ‚Üî ‚àÉ a ‚àà s, a ‚àâ t := by simp only [subset_def, not_forall]\n#align not_subset not_subset\n\n",
 "not_not_mem":
 "@[simp]\ntheorem not_not_mem : ¬¨a ‚àâ s ‚Üî a ‚àà s :=\n  not_not\n#align not_not_mem not_not_mem\n\n",
 "not_nontrivial_singleton":
 "@[simp]\ntheorem not_nontrivial_singleton {x} : ¬¨({x} : set Œ±).nontrivial := fun H =>\n  by\n  rw [nontrivial_iff_exists_ne (mem_singleton x)] at H\n  exact\n    let ‚ü®y, hy, hya‚ü© := H\n    hya (mem_singleton_iff.1 hy)\n#align not_nontrivial_singleton not_nontrivial_singleton\n\n",
 "not_nontrivial_iff":
 "@[simp]\ntheorem not_nontrivial_iff : ¬¨s.nontrivial ‚Üî s.subsingleton :=\n  iff.not_left not_subsingleton_iff.symm\n#align not_nontrivial_iff not_nontrivial_iff\n\n",
 "not_nontrivial_empty":
 "@[simp]\ntheorem not_nontrivial_empty : ¬¨(‚àÖ : set Œ±).nontrivial := fun h => h.ne_empty rfl\n#align not_nontrivial_empty not_nontrivial_empty\n\n",
 "not_nonempty_iff_eq_empty":
 "/-- See also `set.nonempty_iff_ne_empty`. -/\ntheorem not_nonempty_iff_eq_empty {s : set Œ±} : ¬¨s.nonempty ‚Üî s = ‚àÖ := by\n  simp only [Set.Nonempty, eq_empty_iff_forall_not_mem, not_exists]\n#align not_nonempty_iff_eq_empty not_nonempty_iff_eq_empty\n\n",
 "not_nonempty_empty":
 "#print not_nonempty_empty /-\n@[simp]\ntheorem not_nonempty_empty : ¬¨(‚àÖ : set Œ±).nonempty := fun ‚ü®x, hx‚ü© => hx\n#align not_nonempty_empty not_nonempty_empty\n-/\n\n",
 "not_monotone_on_not_antitone_on_iff_exists_lt_lt":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a b c ¬´expr ‚àà ¬ª s) -/\n/-- A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. -/\ntheorem not_monotone_on_not_antitone_on_iff_exists_lt_lt :\n    ¬¨monotone_on f s ‚àß ¬¨antitone_on f s ‚Üî\n      ‚àÉ (a : _)(_ : a ‚àà s)(b : _)(_ : b ‚àà s)(c : _)(_ : c ‚àà s),\n        a < b ‚àß b < c ‚àß (f a < f b ‚àß f c < f b ‚à® f b < f a ‚àß f b < f c) :=\n  by\n  simp [monotone_on_iff_monotone, antitone_on_iff_antitone, and_assoc', exists_and_left,\n    not_monotone_not_antitone_iff_exists_lt_lt, @and_left_comm (_ ‚àà s)]\n#align not_monotone_on_not_antitone_on_iff_exists_lt_lt not_monotone_on_not_antitone_on_iff_exists_lt_lt\n\n",
 "not_monotone_on_not_antitone_on_iff_exists_le_le":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a b c ¬´expr ‚àà ¬ª s) -/\n/-- A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. -/\ntheorem not_monotone_on_not_antitone_on_iff_exists_le_le :\n    ¬¨monotone_on f s ‚àß ¬¨antitone_on f s ‚Üî\n      ‚àÉ (a : _)(_ : a ‚àà s)(b : _)(_ : b ‚àà s)(c : _)(_ : c ‚àà s),\n        a ‚â§ b ‚àß b ‚â§ c ‚àß (f a < f b ‚àß f c < f b ‚à® f b < f a ‚àß f b < f c) :=\n  by\n  simp [monotone_on_iff_monotone, antitone_on_iff_antitone, and_assoc', exists_and_left,\n    not_monotone_not_antitone_iff_exists_le_le, @and_left_comm (_ ‚àà s)]\n#align not_monotone_on_not_antitone_on_iff_exists_le_le not_monotone_on_not_antitone_on_iff_exists_le_le\n\n",
 "not_mem_subset":
 "theorem not_mem_subset (h : s ‚äÜ t) : a ‚àâ t ‚Üí a ‚àâ s :=\n  mt <| mem_of_subset_of_mem h\n#align not_mem_subset not_mem_subset\n\n",
 "not_mem_of_mem_diff":
 "theorem not_mem_of_mem_diff {s t : set Œ±} {x : Œ±} (h : x ‚àà s \\ t) : x ‚àâ t :=\n  h.right\n#align not_mem_of_mem_diff not_mem_of_mem_diff\n\n",
 "not_mem_of_mem_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem not_mem_of_mem_compl {s : set Œ±} {x : Œ±} (h : x ‚àà ¬´expr ·∂ú¬ª s) : x ‚àâ s :=\n  h\n#align not_mem_of_mem_compl not_mem_of_mem_compl\n\n",
 "not_mem_empty":
 "theorem not_mem_empty (x : Œ±) : ¬¨x ‚àà (‚àÖ : set Œ±) :=\n  id\n#align not_mem_empty not_mem_empty\n\n",
 "not_mem_diff_of_mem":
 "theorem not_mem_diff_of_mem {s t : set Œ±} {x : Œ±} (hx : x ‚àà t) : x ‚àâ s \\ t := fun h => h.2 hx\n#align not_mem_diff_of_mem not_mem_diff_of_mem\n\n",
 "not_mem_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem not_mem_compl_iff {x : Œ±} : x ‚àâ ¬´expr ·∂ú¬ª s ‚Üî x ‚àà s :=\n  not_not\n#align not_mem_compl_iff not_mem_compl_iff\n\n",
 "not_disjoint_iff_nonempty_inter":
 "theorem not_disjoint_iff_nonempty_inter : ¬¨Disjoint s t ‚Üî (s ‚à© t).nonempty :=\n  not_disjoint_iff\n#align not_disjoint_iff_nonempty_inter not_disjoint_iff_nonempty_inter\n\n",
 "not_disjoint_iff":
 "theorem not_disjoint_iff : ¬¨Disjoint s t ‚Üî ‚àÉ x, x ‚àà s ‚àß x ‚àà t :=\n  Set.disjoint_iff.not.trans <| not_forall.trans <| exists_congr fun x => not_not\n#align not_disjoint_iff not_disjoint_iff\n\n",
 "nontrivial_univ_iff":
 "@[simp]\ntheorem nontrivial_univ_iff : (univ : set Œ±).nontrivial ‚Üî nontrivial Œ± :=\n  ‚ü®nontrivial_of_univ_nontrivial, fun h => @nontrivial_univ _ h‚ü©\n#align nontrivial_univ_iff nontrivial_univ_iff\n\n",
 "nontrivial_univ":
 "theorem nontrivial_univ [nontrivial Œ±] : (univ : set Œ±).nontrivial :=\n  let ‚ü®x, y, hxy‚ü© := exists_pair_ne Œ±\n  ‚ü®x, mem_univ _, y, mem_univ _, hxy‚ü©\n#align nontrivial_univ nontrivial_univ\n\n",
 "nontrivial_pair":
 "theorem nontrivial_pair {x y} (hxy : x ‚â† y) : ({x, y} : set Œ±).nontrivial :=\n  ‚ü®x, mem_insert _ _, y, mem_insert_of_mem _ (mem_singleton _), hxy‚ü©\n#align nontrivial_pair nontrivial_pair\n\n",
 "nontrivial_of_univ_nontrivial":
 "theorem nontrivial_of_univ_nontrivial (h : (univ : set Œ±).nontrivial) : nontrivial Œ± :=\n  let ‚ü®x, _, y, _, hxy‚ü© := h\n  ‚ü®‚ü®x, y, hxy‚ü©‚ü©\n#align nontrivial_of_univ_nontrivial nontrivial_of_univ_nontrivial\n\n",
 "nontrivial_of_pair_subset":
 "theorem nontrivial_of_pair_subset {x y} (hxy : x ‚â† y) (h : {x, y} ‚äÜ s) : s.nontrivial :=\n  (nontrivial_pair hxy).mono h\n#align nontrivial_of_pair_subset nontrivial_of_pair_subset\n\n",
 "nontrivial_of_nontrivial_coe":
 "/-- A type with a set `s` whose `coe_sort` is a nontrivial type is nontrivial.\nFor the corresponding result for `subtype`, see `subtype.nontrivial_iff_exists_ne`. -/\ntheorem nontrivial_of_nontrivial_coe (hs : nontrivial s) : nontrivial Œ± :=\n  nontrivial_of_nontrivial <| nontrivial_coe_sort.1 hs\n#align nontrivial_of_nontrivial_coe nontrivial_of_nontrivial_coe\n\n",
 "nontrivial_of_nontrivial":
 "theorem nontrivial_of_nontrivial (hs : s.nontrivial) : nontrivial Œ± :=\n  let ‚ü®x, _, y, _, hxy‚ü© := hs\n  ‚ü®‚ü®x, y, hxy‚ü©‚ü©\n#align nontrivial_of_nontrivial nontrivial_of_nontrivial\n\n",
 "nontrivial_of_mem_mem_ne":
 "theorem nontrivial_of_mem_mem_ne {x y} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y) : s.nontrivial :=\n  ‚ü®x, hx, y, hy, hxy‚ü©\n#align nontrivial_of_mem_mem_ne nontrivial_of_mem_mem_ne\n\n",
 "nontrivial_of_lt":
 "#print nontrivial_of_lt /-\ntheorem nontrivial_of_lt [preorder Œ±] {x y} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x < y) : s.nontrivial :=\n  ‚ü®x, hx, y, hy, ne_of_lt hxy‚ü©\n#align nontrivial_of_lt nontrivial_of_lt\n-/\n\n",
 "nontrivial_of_exists_ne":
 "theorem nontrivial_of_exists_ne {x} (hx : x ‚àà s) (h : ‚àÉ y ‚àà s, y ‚â† x) : s.nontrivial :=\n  let ‚ü®y, hy, hyx‚ü© := h\n  ‚ü®y, hy, x, hx, hyx‚ü©\n#align nontrivial_of_exists_ne nontrivial_of_exists_ne\n\n",
 "nontrivial_of_exists_lt":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª s) -/\ntheorem nontrivial_of_exists_lt [preorder Œ±] (H : ‚àÉ (x : _)(_ : x ‚àà s)(y : _)(_ : y ‚àà s), x < y) : s.nontrivial :=\n  let ‚ü®x, hx, y, hy, hxy‚ü© := H\n  nontrivial_of_lt hx hy hxy\n#align nontrivial_of_exists_lt nontrivial_of_exists_lt\n\n",
 "nontrivial_mono":
 "theorem nontrivial_mono {Œ± : Type _} {s t : set Œ±} (hst : s ‚äÜ t) (hs : nontrivial s) : nontrivial t :=\n  nontrivial.coe_sort <| (nontrivial_coe_sort.1 hs).mono hst\n#align nontrivial_mono nontrivial_mono\n\n",
 "nontrivial_iff_pair_subset":
 "theorem nontrivial_iff_pair_subset : s.nontrivial ‚Üî ‚àÉ (x y : _)(hxy : x ‚â† y), {x, y} ‚äÜ s :=\n  ‚ü®Nontrivial.pair_subset, fun H =>\n    let ‚ü®x, y, hxy, h‚ü© := H\n    nontrivial_of_pair_subset hxy h‚ü©\n#align nontrivial_iff_pair_subset nontrivial_iff_pair_subset\n\n",
 "nontrivial_iff_ne_singleton":
 "theorem nontrivial_iff_ne_singleton (ha : a ‚àà s) : s.nontrivial ‚Üî s ‚â† {a} :=\n  ‚ü®Nontrivial.ne_singleton, (eq_singleton_or_nontrivial ha).resolve_left‚ü©\n#align nontrivial_iff_ne_singleton nontrivial_iff_ne_singleton\n\n",
 "nontrivial_iff_exists_ne":
 "#print nontrivial_iff_exists_ne /-\ntheorem nontrivial_iff_exists_ne {x} (hx : x ‚àà s) : s.nontrivial ‚Üî ‚àÉ y ‚àà s, y ‚â† x :=\n  ‚ü®fun H => H.exists_ne _, nontrivial_of_exists_ne hx‚ü©\n#align nontrivial_iff_exists_ne nontrivial_iff_exists_ne\n-/\n\n",
 "nontrivial_iff_exists_lt":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª s) -/\ntheorem nontrivial_iff_exists_lt [linear_order Œ±] : s.nontrivial ‚Üî ‚àÉ (x : _)(_ : x ‚àà s)(y : _)(_ : y ‚àà s), x < y :=\n  ‚ü®Nontrivial.exists_lt, nontrivial_of_exists_lt‚ü©\n#align nontrivial_iff_exists_lt nontrivial_iff_exists_lt\n\n",
 "nontrivial_coe_sort":
 "/-- `s`, coerced to a type, is a nontrivial type if and only if `s` is a nontrivial set. -/\n@[simp, norm_cast]\ntheorem nontrivial_coe_sort {s : set Œ±} : nontrivial s ‚Üî s.nontrivial := by\n  simp_rw [‚Üê nontrivial_univ_iff, Set.Nontrivial, mem_univ, exists_true_left, SetCoe.exists, subtype.mk_eq_mk]\n#align nontrivial_coe_sort nontrivial_coe_sort\n\n",
 "nonempty_of_ssubset'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem nonempty_of_ssubset' (ht : ¬´expr ‚äÇ ¬ª s t) : t.nonempty :=\n  (nonempty_of_ssubset ht).of_diff\n#align nonempty_of_ssubset' nonempty_of_ssubset'\n\n",
 "nonempty_of_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem nonempty_of_ssubset (ht : ¬´expr ‚äÇ ¬ª s t) : (t \\ s).nonempty :=\n  nonempty_of_not_subset ht.2\n#align nonempty_of_ssubset nonempty_of_ssubset\n\n",
 "nonempty_of_not_subset":
 "theorem nonempty_of_not_subset (h : ¬¨s ‚äÜ t) : (s \\ t).nonempty :=\n  let ‚ü®x, xs, xt‚ü© := not_subset.1 h\n  ‚ü®x, xs, xt‚ü©\n#align nonempty_of_not_subset nonempty_of_not_subset\n\n",
 "nonempty_of_nonempty_subtype":
 "theorem nonempty_of_nonempty_subtype [nonempty s] : s.nonempty :=\n  nonempty_subtype.mp ‚Äπ_‚Ä∫\n#align nonempty_of_nonempty_subtype nonempty_of_nonempty_subtype\n\n",
 "nonempty_of_mem":
 "theorem nonempty_of_mem {x} (h : x ‚àà s) : s.nonempty :=\n  ‚ü®x, h‚ü©\n#align nonempty_of_mem nonempty_of_mem\n\n",
 "nonempty_iff_univ_nonempty":
 "theorem nonempty_iff_univ_nonempty : nonempty Œ± ‚Üî (univ : set Œ±).nonempty :=\n  ‚ü®fun ‚ü®x‚ü© => ‚ü®x, trivial‚ü©, fun ‚ü®x, _‚ü© => ‚ü®x‚ü©‚ü©\n#align nonempty_iff_univ_nonempty nonempty_iff_univ_nonempty\n\n",
 "nonempty_iff_ne_empty":
 "/-- See also `set.not_nonempty_iff_eq_empty`. -/\ntheorem nonempty_iff_ne_empty : s.nonempty ‚Üî s ‚â† ‚àÖ :=\n  not_nonempty_iff_eq_empty.not_right\n#align nonempty_iff_ne_empty nonempty_iff_ne_empty\n\n",
 "nonempty_diff":
 "theorem nonempty_diff {s t : set Œ±} : (s \\ t).nonempty ‚Üî ¬¨s ‚äÜ t :=\n  inter_compl_nonempty_iff\n#align nonempty_diff nonempty_diff\n\n",
 "nonempty_def":
 "theorem nonempty_def : s.nonempty ‚Üî ‚àÉ x, x ‚àà s :=\n  iff.rfl\n#align nonempty_def nonempty_def\n\n",
 "nonempty_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem nonempty_compl : (¬´expr ·∂ú¬ª s).nonempty ‚Üî s ‚â† univ :=\n  (ne_univ_iff_exists_not_mem s).symm\n#align nonempty_compl nonempty_compl\n\n",
 "nonempty_coe_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n@[simp]\ntheorem nonempty_coe_sort {s : set Œ±} : nonempty (¬´expr‚Ü• ¬ª s) ‚Üî s.nonempty :=\n  nonempty_subtype\n#align nonempty_coe_sort nonempty_coe_sort\n\n",
 "nonempty_apply_iff":
 "theorem injective.nonempty_apply_iff {f : set Œ± ‚Üí set Œ≤} (hf : injective f) (h2 : f ‚àÖ = ‚àÖ) {s : set Œ±} :\n    (f s).nonempty ‚Üî s.nonempty := by rw [nonempty_iff_ne_empty, ‚Üê h2, nonempty_iff_ne_empty, hf.ne_iff]\n#align injective.nonempty_apply_iff injective.nonempty_apply_iff\n\n",
 "nonempty":
 "protected theorem nontrivial.nonempty (hs : s.nontrivial) : s.nonempty :=\n  let ‚ü®x, hx, _‚ü© := hs\n  ‚ü®x, hx‚ü©\n#align nontrivial.nonempty nontrivial.nonempty\n\n",
 "nmem_singleton_empty":
 "theorem nmem_singleton_empty {s : set Œ±} : s ‚àâ ({‚àÖ} : set (set Œ±)) ‚Üî s.nonempty :=\n  nonempty_iff_ne_empty.symm\n#align nmem_singleton_empty nmem_singleton_empty\n\n",
 "nmem_set_of_iff":
 "theorem nmem_set_of_iff {a : Œ±} {p : Œ± ‚Üí Prop} : a ‚àâ { x | p x } ‚Üî ¬¨p a :=\n  iff.rfl\n#align nmem_set_of_iff nmem_set_of_iff\n\n",
 "ne_univ_iff_exists_not_mem":
 "theorem ne_univ_iff_exists_not_mem {Œ± : Type _} (s : set Œ±) : s ‚â† univ ‚Üî ‚àÉ a, a ‚àâ s := by\n  rw [‚Üê not_forall, ‚Üê eq_univ_iff_forall]\n#align ne_univ_iff_exists_not_mem ne_univ_iff_exists_not_mem\n\n",
 "ne_singleton":
 "theorem nontrivial.ne_singleton {x} (hs : s.nontrivial) : s ‚â† {x} := fun H =>\n  by\n  rw [H] at hs\n  exact not_nontrivial_singleton hs\n#align nontrivial.ne_singleton nontrivial.ne_singleton\n\n",
 "ne_of_mem":
 "#print Disjoint.ne_of_mem /-\ntheorem Disjoint.ne_of_mem (h : Disjoint s t) {x y} (hx : x ‚àà s) (hy : y ‚àà t) : x ‚â† y :=\n  disjoint_iff_forall_ne.mp h x hx y hy\n#align disjoint.ne_of_mem Disjoint.ne_of_mem\n-/\n\n",
 "ne_insert_of_not_mem":
 "theorem ne_insert_of_not_mem {s : set Œ±} (t : set Œ±) {a : Œ±} : a ‚àâ s ‚Üí s ‚â† insert a t :=\n  mt fun e => e.symm ‚ñ∏ mem_insert _ _\n#align ne_insert_of_not_mem ne_insert_of_not_mem\n\n",
 "ne_empty":
 "protected theorem nontrivial.ne_empty (hs : s.nontrivial) : s ‚â† ‚àÖ :=\n  hs.nonempty.ne_empty\n#align nontrivial.ne_empty nontrivial.ne_empty\n\n",
 "monotone_set_of":
 "theorem monotone_set_of [preorder Œ±] {p : Œ± ‚Üí Œ≤ ‚Üí Prop} (hp : ‚àÄ b, monotone fun a => p a b) :\n    monotone fun a => { b | p a b } := fun a a' h b => hp b h\n#align monotone_set_of monotone_set_of\n\n",
 "monotone_powerset":
 "theorem monotone_powerset : monotone (powerset : set Œ± ‚Üí set (set Œ±)) := fun s t => powerset_mono.2\n#align monotone_powerset monotone_powerset\n\n",
 "monotone_on_singleton":
 "@[simp]\ntheorem monotone_on_singleton : monotone_on f {a} :=\n  subsingleton_singleton.monotone_on f\n#align monotone_on_singleton monotone_on_singleton\n\n",
 "monotone_on_iff_monotone":
 "theorem monotone_on_iff_monotone : monotone_on f s ‚Üî monotone fun a : s => f a := by simp [monotone, monotone_on]\n#align monotone_on_iff_monotone monotone_on_iff_monotone\n\n",
 "monotone_on":
 "protected theorem subsingleton.monotone_on (h : s.subsingleton) : monotone_on f s := fun a ha b hb _ =>\n  (congr_arg _ (h ha hb)).le\n#align subsingleton.monotone_on subsingleton.monotone_on\n\n",
 "mono":
 "theorem nontrivial.mono (hs : s.nontrivial) (hst : s ‚äÜ t) : t.nontrivial :=\n  let ‚ü®x, hx, y, hy, hxy‚ü© := hs\n  ‚ü®x, hst hx, y, hst hy, hxy‚ü©\n#align nontrivial.mono nontrivial.mono\n\n",
 "mem_univ":
 "@[simp]\ntheorem mem_univ (x : Œ±) : x ‚àà @univ Œ± :=\n  trivial\n#align mem_univ mem_univ\n\n",
 "mem_union_right":
 "theorem mem_union_right {x : Œ±} {b : set Œ±} (a : set Œ±) : x ‚àà b ‚Üí x ‚àà a ‚à™ b :=\n  or.inr\n#align mem_union_right mem_union_right\n\n",
 "mem_union_left":
 "theorem mem_union_left {x : Œ±} {a : set Œ±} (b : set Œ±) : x ‚àà a ‚Üí x ‚àà a ‚à™ b :=\n  or.inl\n#align mem_union_left mem_union_left\n\n",
 "mem_union":
 "@[simp]\ntheorem mem_union (x : Œ±) (a b : set Œ±) : x ‚àà a ‚à™ b ‚Üî x ‚àà a ‚à® x ‚àà b :=\n  iff.rfl\n#align mem_union mem_union\n\n",
 "mem_symm_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\ntheorem mem_symm_diff : a ‚àà ¬´expr ‚àÜ ¬ª s t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=\n  iff.rfl\n#align mem_symm_diff mem_symm_diff\n\n",
 "mem_singleton_of_eq":
 "theorem mem_singleton_of_eq {x y : Œ±} (H : x = y) : x ‚àà ({y} : set Œ±) :=\n  H\n#align mem_singleton_of_eq mem_singleton_of_eq\n\n",
 "mem_singleton_iff":
 "@[simp]\ntheorem mem_singleton_iff {a b : Œ±} : a ‚àà ({b} : set Œ±) ‚Üî a = b :=\n  iff.rfl\n#align mem_singleton_iff mem_singleton_iff\n\n",
 "mem_singleton":
 "-- TODO: again, annotation needed\n@[simp]\ntheorem mem_singleton (a : Œ±) : a ‚àà ({a} : set Œ±) :=\n  @rfl _ _\n#align mem_singleton mem_singleton\n\n",
 "mem_set_of":
 "theorem mem_set_of {a : Œ±} {p : Œ± ‚Üí Prop} : a ‚àà { x | p x } ‚Üî p a :=\n  iff.rfl\n#align mem_set_of mem_set_of\n\n",
 "mem_sep_iff":
 "@[simp]\ntheorem mem_sep_iff : x ‚àà { x ‚àà s | p x } ‚Üî x ‚àà s ‚àß p x :=\n  iff.rfl\n#align mem_sep_iff mem_sep_iff\n\n",
 "mem_sep":
 "theorem mem_sep (xs : x ‚àà s) (px : p x) : x ‚àà { x ‚àà s | p x } :=\n  ‚ü®xs, px‚ü©\n#align mem_sep mem_sep\n\n",
 "mem_powerset_iff":
 "@[simp]\ntheorem mem_powerset_iff (x s : set Œ±) : x ‚àà ùí´ s ‚Üî x ‚äÜ s :=\n  iff.rfl\n#align mem_powerset_iff mem_powerset_iff\n\n",
 "mem_powerset":
 "theorem mem_powerset {x s : set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=\n  h\n#align mem_powerset mem_powerset\n\n",
 "mem_or_mem_of_mem_union":
 "theorem mem_or_mem_of_mem_union {x : Œ±} {a b : set Œ±} (H : x ‚àà a ‚à™ b) : x ‚àà a ‚à® x ‚àà b :=\n  H\n#align mem_or_mem_of_mem_union mem_or_mem_of_mem_union\n\n",
 "mem_of_subset_of_mem":
 "theorem mem_of_subset_of_mem {s‚ÇÅ s‚ÇÇ : set Œ±} {a : Œ±} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : a ‚àà s‚ÇÅ ‚Üí a ‚àà s‚ÇÇ :=\n  @h _\n#align mem_of_subset_of_mem mem_of_subset_of_mem\n\n",
 "mem_of_mem_of_subset":
 "@[trans]\ntheorem mem_of_mem_of_subset {x : Œ±} {s t : set Œ±} (hx : x ‚àà s) (h : s ‚äÜ t) : x ‚àà t :=\n  h hx\n#align mem_of_mem_of_subset mem_of_mem_of_subset\n\n",
 "mem_of_mem_inter_right":
 "theorem mem_of_mem_inter_right {x : Œ±} {a b : set Œ±} (h : x ‚àà a ‚à© b) : x ‚àà b :=\n  h.right\n#align mem_of_mem_inter_right mem_of_mem_inter_right\n\n",
 "mem_of_mem_inter_left":
 "theorem mem_of_mem_inter_left {x : Œ±} {a b : set Œ±} (h : x ‚àà a ‚à© b) : x ‚àà a :=\n  h.left\n#align mem_of_mem_inter_left mem_of_mem_inter_left\n\n",
 "mem_of_mem_insert_of_ne":
 "theorem mem_of_mem_insert_of_ne : b ‚àà insert a s ‚Üí b ‚â† a ‚Üí b ‚àà s :=\n  or.resolve_left\n#align mem_of_mem_insert_of_ne mem_of_mem_insert_of_ne\n\n",
 "mem_of_mem_diff":
 "theorem mem_of_mem_diff {s t : set Œ±} {x : Œ±} (h : x ‚àà s \\ t) : x ‚àà s :=\n  h.left\n#align mem_of_mem_diff mem_of_mem_diff\n\n",
 "mem_of_eq_of_mem":
 "@[trans]\ntheorem mem_of_eq_of_mem {x y : Œ±} {s : set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=\n  hx.symm ‚ñ∏ h\n#align mem_of_eq_of_mem mem_of_eq_of_mem\n\n",
 "mem_ite_univ_right":
 "@[simp]\ntheorem mem_ite_univ_right (p : Prop) [decidable p] (t : set Œ±) (x : Œ±) : x ‚àà ite p t Set.univ ‚Üî p ‚Üí x ‚àà t :=\n  mem_dite_univ_right p (fun _ => t) x\n#align mem_ite_univ_right mem_ite_univ_right\n\n",
 "mem_ite_univ_left":
 "@[simp]\ntheorem mem_ite_univ_left (p : Prop) [decidable p] (t : set Œ±) (x : Œ±) : x ‚àà ite p Set.univ t ‚Üî ¬¨p ‚Üí x ‚àà t :=\n  mem_dite_univ_left p (fun _ => t) x\n#align mem_ite_univ_left mem_ite_univ_left\n\n",
 "mem_ite_empty_right":
 "@[simp]\ntheorem mem_ite_empty_right (p : Prop) [decidable p] (t : set Œ±) (x : Œ±) : x ‚àà ite p t ‚àÖ ‚Üî p ‚àß x ‚àà t := by\n  split_ifs <;> simp [h]\n#align mem_ite_empty_right mem_ite_empty_right\n\n",
 "mem_ite_empty_left":
 "@[simp]\ntheorem mem_ite_empty_left (p : Prop) [decidable p] (t : set Œ±) (x : Œ±) : x ‚àà ite p ‚àÖ t ‚Üî ¬¨p ‚àß x ‚àà t := by\n  split_ifs <;> simp [h]\n#align mem_ite_empty_left mem_ite_empty_left\n\n",
 "mem_inter_iff":
 "@[simp]\ntheorem mem_inter_iff (x : Œ±) (a b : set Œ±) : x ‚àà a ‚à© b ‚Üî x ‚àà a ‚àß x ‚àà b :=\n  iff.rfl\n#align mem_inter_iff mem_inter_iff\n\n",
 "mem_inter":
 "theorem mem_inter {x : Œ±} {a b : set Œ±} (ha : x ‚àà a) (hb : x ‚àà b) : x ‚àà a ‚à© b :=\n  ‚ü®ha, hb‚ü©\n#align mem_inter mem_inter\n\n",
 "mem_insert_of_mem":
 "theorem mem_insert_of_mem {x : Œ±} {s : set Œ±} (y : Œ±) : x ‚àà s ‚Üí x ‚àà insert y s :=\n  or.inr\n#align mem_insert_of_mem mem_insert_of_mem\n\n",
 "mem_insert_iff":
 "@[simp]\ntheorem mem_insert_iff {x a : Œ±} {s : set Œ±} : x ‚àà insert a s ‚Üî x = a ‚à® x ‚àà s :=\n  iff.rfl\n#align mem_insert_iff mem_insert_iff\n\n",
 "mem_insert":
 "theorem mem_insert (x : Œ±) (s : set Œ±) : x ‚àà insert x s :=\n  or.inl rfl\n#align mem_insert mem_insert\n\n",
 "mem_iff_nonempty":
 "theorem mem_iff_nonempty {Œ± : Type _} [subsingleton Œ±] {s : set Œ±} {x : Œ±} : x ‚àà s ‚Üî s.nonempty :=\n  ‚ü®fun hx => ‚ü®x, hx‚ü©, fun ‚ü®y, hy‚ü© => subsingleton.elim y x ‚ñ∏ hy‚ü©\n#align mem_iff_nonempty mem_iff_nonempty\n\n",
 "mem_empty_iff_false":
 "@[simp]\ntheorem mem_empty_iff_false (x : Œ±) : x ‚àà (‚àÖ : set Œ±) ‚Üî false :=\n  iff.rfl\n#align mem_empty_iff_false mem_empty_iff_false\n\n",
 "mem_dite_univ_right":
 "theorem mem_dite_univ_right (p : Prop) [decidable p] (t : p ‚Üí set Œ±) (x : Œ±) :\n    (x ‚àà if h : p then t h else univ) ‚Üî ‚àÄ h : p, x ‚àà t h := by split_ifs <;> simp [h]\n#align mem_dite_univ_right mem_dite_univ_right\n\n",
 "mem_dite_univ_left":
 "theorem mem_dite_univ_left (p : Prop) [decidable p] (t : ¬¨p ‚Üí set Œ±) (x : Œ±) :\n    (x ‚àà if h : p then univ else t h) ‚Üî ‚àÄ h : ¬¨p, x ‚àà t h := by split_ifs <;> simp [h]\n#align mem_dite_univ_left mem_dite_univ_left\n\n",
 "mem_dite_empty_right":
 "theorem mem_dite_empty_right (p : Prop) [decidable p] (t : p ‚Üí set Œ±) (x : Œ±) :\n    (x ‚àà if h : p then t h else ‚àÖ) ‚Üî ‚àÉ h : p, x ‚àà t h := by split_ifs <;> simp [h]\n#align mem_dite_empty_right mem_dite_empty_right\n\n",
 "mem_dite_empty_left":
 "theorem mem_dite_empty_left (p : Prop) [decidable p] (t : ¬¨p ‚Üí set Œ±) (x : Œ±) :\n    (x ‚àà if h : p then ‚àÖ else t h) ‚Üî ‚àÉ h : ¬¨p, x ‚àà t h := by split_ifs <;> simp [h]\n#align mem_dite_empty_left mem_dite_empty_left\n\n",
 "mem_diff_singleton_empty":
 "theorem mem_diff_singleton_empty {t : set (set Œ±)} : s ‚àà t \\ {‚àÖ} ‚Üî s ‚àà t ‚àß s.nonempty :=\n  mem_diff_singleton.trans <| and_congr_right' nonempty_iff_ne_empty.symm\n#align mem_diff_singleton_empty mem_diff_singleton_empty\n\n",
 "mem_diff_singleton":
 "theorem mem_diff_singleton {x y : Œ±} {s : set Œ±} : x ‚àà s \\ {y} ‚Üî x ‚àà s ‚àß x ‚â† y :=\n  iff.rfl\n#align mem_diff_singleton mem_diff_singleton\n\n",
 "mem_diff_of_mem":
 "theorem mem_diff_of_mem {s t : set Œ±} {x : Œ±} (h1 : x ‚àà s) (h2 : x ‚àâ t) : x ‚àà s \\ t :=\n  ‚ü®h1, h2‚ü©\n#align mem_diff_of_mem mem_diff_of_mem\n\n",
 "mem_diff":
 "@[simp]\ntheorem mem_diff {s t : set Œ±} (x : Œ±) : x ‚àà s \\ t ‚Üî x ‚àà s ‚àß x ‚àâ t :=\n  iff.rfl\n#align mem_diff mem_diff\n\n",
 "mem_def":
 "theorem mem_def {a : Œ±} {s : set Œ±} : a ‚àà s ‚Üî s a :=\n  iff.rfl\n#align mem_def mem_def\n\n",
 "mem_compl_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem mem_compl_singleton_iff {a x : Œ±} : x ‚àà ¬´expr ·∂ú¬ª ({a} : set Œ±) ‚Üî x ‚â† a :=\n  iff.rfl\n#align mem_compl_singleton_iff mem_compl_singleton_iff\n\n",
 "mem_compl_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem mem_compl_iff (s : set Œ±) (x : Œ±) : x ‚àà ¬´expr ·∂ú¬ª s ‚Üî x ‚àâ s :=\n  iff.rfl\n#align mem_compl_iff mem_compl_iff\n\n",
 "mem_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem mem_compl {s : set Œ±} {x : Œ±} (h : x ‚àâ s) : x ‚àà ¬´expr ·∂ú¬ª s :=\n  h\n#align mem_compl mem_compl\n\n",
 "mem":
 "#print Subtype.mem /-\n/-- See also `subtype.prop` -/\ntheorem Subtype.mem {Œ± : Type _} {s : set Œ±} (p : s) : (p : Œ±) ‚àà s :=\n  p.prop\n#align subtype.mem Subtype.mem\n-/\n\n",
 "lt_iff_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem lt_iff_ssubset : s < t ‚Üî ¬´expr ‚äÇ ¬ª s t :=\n  iff.rfl\n#align lt_iff_ssubset lt_iff_ssubset\n\n",
 "lt_eq_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `¬´expr ‚äÇ ¬ª -/\n@[simp]\ntheorem lt_eq_ssubset : ((¬∑ < ¬∑) : set Œ± ‚Üí set Œ± ‚Üí Prop) = (¬´expr ‚äÇ ¬ª ¬∑ ¬∑) :=\n  rfl\n#align lt_eq_ssubset lt_eq_ssubset\n\n",
 "left":
 "theorem nonempty.left (h : (s ‚à© t).nonempty) : s.nonempty :=\n  h.imp fun _ => And.left\n#align nonempty.left nonempty.left\n\n",
 "le_iff_subset":
 "theorem le_iff_subset : s ‚â§ t ‚Üî s ‚äÜ t :=\n  iff.rfl\n#align le_iff_subset le_iff_subset\n\n",
 "le_eq_subset":
 "@[simp]\ntheorem le_eq_subset : ((¬∑ ‚â§ ¬∑) : set Œ± ‚Üí set Œ± ‚Üí Prop) = (¬∑ ‚äÜ ¬∑) :=\n  rfl\n#align le_eq_subset le_eq_subset\n\n",
 "ite_univ":
 "@[simp]\ntheorem ite_univ (s s' : set Œ±) : Set.ite univ s s' = s := by simp [Set.ite]\n#align ite_univ ite_univ\n\n",
 "ite_subset_union":
 "theorem ite_subset_union (t s s' : set Œ±) : t.ite s s' ‚äÜ s ‚à™ s' :=\n  union_subset_union (inter_subset_left _ _) (diff_subset _ _)\n#align ite_subset_union ite_subset_union\n\n",
 "ite_same":
 "@[simp]\ntheorem ite_same (t s : set Œ±) : t.ite s s = s :=\n  inter_union_diff _ _\n#align ite_same ite_same\n\n",
 "ite_right":
 "@[simp]\ntheorem ite_right (s t : set Œ±) : s.ite t s = t ‚à© s := by simp [Set.ite]\n#align ite_right ite_right\n\n",
 "ite_mono":
 "theorem ite_mono (t : set Œ±) {s‚ÇÅ s‚ÇÅ' s‚ÇÇ s‚ÇÇ' : set Œ±} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (h' : s‚ÇÅ' ‚äÜ s‚ÇÇ') : t.ite s‚ÇÅ s‚ÇÅ' ‚äÜ t.ite s‚ÇÇ s‚ÇÇ' :=\n  union_subset_union (inter_subset_inter_left _ h) (inter_subset_inter_left _ h')\n#align ite_mono ite_mono\n\n",
 "ite_left":
 "@[simp]\ntheorem ite_left (s t : set Œ±) : s.ite s t = s ‚à™ t := by simp [Set.ite]\n#align ite_left ite_left\n\n",
 "ite_inter_self":
 "@[simp]\ntheorem ite_inter_self (t s s' : set Œ±) : t.ite s s' ‚à© t = s ‚à© t := by\n  rw [Set.ite, union_inter_distrib_right, diff_inter_self, inter_assoc, inter_self, union_empty]\n#align ite_inter_self ite_inter_self\n\n",
 "ite_inter_of_inter_eq":
 "theorem ite_inter_of_inter_eq (t : set Œ±) {s‚ÇÅ s‚ÇÇ s : set Œ±} (h : s‚ÇÅ ‚à© s = s‚ÇÇ ‚à© s) : t.ite s‚ÇÅ s‚ÇÇ ‚à© s = s‚ÇÅ ‚à© s := by\n  rw [‚Üê ite_inter, ‚Üê h, ite_same]\n#align ite_inter_of_inter_eq ite_inter_of_inter_eq\n\n",
 "ite_inter_inter":
 "theorem ite_inter_inter (t s‚ÇÅ s‚ÇÇ s‚ÇÅ' s‚ÇÇ' : set Œ±) : t.ite (s‚ÇÅ ‚à© s‚ÇÇ) (s‚ÇÅ' ‚à© s‚ÇÇ') = t.ite s‚ÇÅ s‚ÇÅ' ‚à© t.ite s‚ÇÇ s‚ÇÇ' :=\n  by\n  ext x\n  simp only [Set.ite, Set.mem_inter_iff, Set.mem_diff, Set.mem_union]\n  itauto\n#align ite_inter_inter ite_inter_inter\n\n",
 "ite_inter_compl_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem ite_inter_compl_self (t s s' : set Œ±) : t.ite s s' ‚à© ¬´expr ·∂ú¬ª t = s' ‚à© ¬´expr ·∂ú¬ª t := by\n  rw [‚Üê ite_compl, ite_inter_self]\n#align ite_inter_compl_self ite_inter_compl_self\n\n",
 "ite_inter":
 "theorem ite_inter (t s‚ÇÅ s‚ÇÇ s : set Œ±) : t.ite (s‚ÇÅ ‚à© s) (s‚ÇÇ ‚à© s) = t.ite s‚ÇÅ s‚ÇÇ ‚à© s := by rw [ite_inter_inter, ite_same]\n#align ite_inter ite_inter\n\n",
 "ite_empty_right":
 "@[simp]\ntheorem ite_empty_right (t s : set Œ±) : t.ite s ‚àÖ = s ‚à© t := by simp [Set.ite]\n#align ite_empty_right ite_empty_right\n\n",
 "ite_empty_left":
 "@[simp]\ntheorem ite_empty_left (t s : set Œ±) : t.ite ‚àÖ s = s \\ t := by simp [Set.ite]\n#align ite_empty_left ite_empty_left\n\n",
 "ite_empty":
 "@[simp]\ntheorem ite_empty (s s' : set Œ±) : Set.ite ‚àÖ s s' = s' := by simp [Set.ite]\n#align ite_empty ite_empty\n\n",
 "ite_diff_self":
 "@[simp]\ntheorem ite_diff_self (t s s' : set Œ±) : t.ite s s' \\ t = s' \\ t :=\n  ite_inter_compl_self t s s'\n#align ite_diff_self ite_diff_self\n\n",
 "ite_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem ite_compl (t s s' : set Œ±) : (¬´expr ·∂ú¬ª t).ite s s' = t.ite s' s := by\n  rw [Set.ite, Set.ite, diff_compl, union_comm, diff_eq]\n#align ite_compl ite_compl\n\n",
 "is_empty_coe_sort":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n@[simp]\ntheorem is_empty_coe_sort {s : set Œ±} : is_empty (¬´expr‚Ü• ¬ª s) ‚Üî s = ‚àÖ :=\n  not_iff_not.1 <| by simpa using nonempty_iff_ne_empty\n#align is_empty_coe_sort is_empty_coe_sort\n\n",
 "inter_univ":
 "@[simp]\ntheorem inter_univ (a : set Œ±) : a ‚à© univ = a :=\n  inf_top_eq\n#align inter_univ inter_univ\n\n",
 "inter_union_distrib_right":
 "theorem inter_union_distrib_right {s t u : set Œ±} : s ‚à© t ‚à™ u = (s ‚à™ u) ‚à© (t ‚à™ u) :=\n  sup_inf_right\n#align inter_union_distrib_right inter_union_distrib_right\n\n",
 "inter_union_distrib_left":
 "theorem inter_union_distrib_left {s t u : set Œ±} : s ‚à© (t ‚à™ u) = s ‚à© t ‚à™ s ‚à© u :=\n  inf_sup_left\n#align inter_union_distrib_left inter_union_distrib_left\n\n",
 "inter_union_diff":
 "@[simp]\ntheorem inter_union_diff (s t : set Œ±) : s ‚à© t ‚à™ s \\ t = s :=\n  sup_inf_sdiff s t\n#align inter_union_diff inter_union_diff\n\n",
 "inter_union_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem inter_union_compl (s t : set Œ±) : s ‚à© t ‚à™ s ‚à© ¬´expr ·∂ú¬ª t = s :=\n  inter_union_diff _ _\n#align inter_union_compl inter_union_compl\n\n",
 "inter_symm_diff_distrib_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\ntheorem inter_symm_diff_distrib_right (s t u : set Œ±) : ¬´expr ‚àÜ ¬ª s t ‚à© u = ¬´expr ‚àÜ ¬ª (s ‚à© u) (t ‚à© u) :=\n  inf_symmDiff_distrib_right _ _ _\n#align inter_symm_diff_distrib_right inter_symm_diff_distrib_right\n\n",
 "inter_symm_diff_distrib_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚àÜ ¬ª -/\ntheorem inter_symm_diff_distrib_left (s t u : set Œ±) : s ‚à© ¬´expr ‚àÜ ¬ª t u = ¬´expr ‚àÜ ¬ª (s ‚à© t) (s ‚à© u) :=\n  inf_symmDiff_distrib_left _ _ _\n#align inter_symm_diff_distrib_left inter_symm_diff_distrib_left\n\n",
 "inter_subset_right":
 "@[simp]\ntheorem inter_subset_right (s t : set Œ±) : s ‚à© t ‚äÜ t := fun x => And.right\n#align inter_subset_right inter_subset_right\n\n",
 "inter_subset_left":
 "@[simp]\ntheorem inter_subset_left (s t : set Œ±) : s ‚à© t ‚äÜ s := fun x => And.left\n#align inter_subset_left inter_subset_left\n\n",
 "inter_subset_ite":
 "theorem inter_subset_ite (t s s' : set Œ±) : s ‚à© s' ‚äÜ t.ite s s' :=\n  ite_same t (s ‚à© s') ‚ñ∏ ite_mono _ (inter_subset_left _ _) (inter_subset_right _ _)\n#align inter_subset_ite inter_subset_ite\n\n",
 "inter_subset_inter_right":
 "theorem inter_subset_inter_right {s t : set Œ±} (u : set Œ±) (H : s ‚äÜ t) : u ‚à© s ‚äÜ u ‚à© t :=\n  inter_subset_inter Subset.rfl H\n#align inter_subset_inter_right inter_subset_inter_right\n\n",
 "inter_subset_inter_left":
 "theorem inter_subset_inter_left {s t : set Œ±} (u : set Œ±) (H : s ‚äÜ t) : s ‚à© u ‚äÜ t ‚à© u :=\n  inter_subset_inter H Subset.rfl\n#align inter_subset_inter_left inter_subset_inter_left\n\n",
 "inter_subset_inter":
 "theorem inter_subset_inter {s‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : set Œ±} (h‚ÇÅ : s‚ÇÅ ‚äÜ t‚ÇÅ) (h‚ÇÇ : s‚ÇÇ ‚äÜ t‚ÇÇ) : s‚ÇÅ ‚à© s‚ÇÇ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ := fun x =>\n  and.imp (@h‚ÇÅ _) (@h‚ÇÇ _)\n#align inter_subset_inter inter_subset_inter\n\n",
 "inter_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem inter_subset (a b c : set Œ±) : a ‚à© b ‚äÜ c ‚Üî a ‚äÜ ¬´expr ·∂ú¬ª b ‚à™ c :=\n  forall_congr' fun x => and_imp.trans <| imp_congr_right fun _ => imp_iff_not_or\n#align inter_subset inter_subset\n\n",
 "inter_singleton_nonempty":
 "@[simp]\ntheorem inter_singleton_nonempty : (s ‚à© {a}).nonempty ‚Üî a ‚àà s := by rw [inter_comm, singleton_inter_nonempty]\n#align inter_singleton_nonempty inter_singleton_nonempty\n\n",
 "inter_singleton_eq_empty":
 "@[simp]\ntheorem inter_singleton_eq_empty : s ‚à© {a} = ‚àÖ ‚Üî a ‚àâ s := by rw [inter_comm, singleton_inter_eq_empty]\n#align inter_singleton_eq_empty inter_singleton_eq_empty\n\n",
 "inter_self":
 "@[simp]\ntheorem inter_self (a : set Œ±) : a ‚à© a = a :=\n  ext fun x => and_self_iff _\n#align inter_self inter_self\n\n",
 "inter_right_comm":
 "theorem inter_right_comm (s‚ÇÅ s‚ÇÇ s‚ÇÉ : set Œ±) : s‚ÇÅ ‚à© s‚ÇÇ ‚à© s‚ÇÉ = s‚ÇÅ ‚à© s‚ÇÉ ‚à© s‚ÇÇ :=\n  ext fun x => and_right_comm\n#align inter_right_comm inter_right_comm\n\n",
 "inter_right'":
 "theorem inter_right' (u : set Œ±) (h : Disjoint s t) : Disjoint s (u ‚à© t) :=\n  h.inf_right' _\n#align inter_right' inter_right'\n\n",
 "inter_right":
 "theorem inter_right (u : set Œ±) (h : Disjoint s t) : Disjoint s (t ‚à© u) :=\n  h.inf_right _\n#align inter_right inter_right\n\n",
 "inter_nonempty_iff_exists_right":
 "theorem inter_nonempty_iff_exists_right : (s ‚à© t).nonempty ‚Üî ‚àÉ x ‚àà t, x ‚àà s := by\n  simp_rw [inter_nonempty, exists_prop, and_comm']\n#align inter_nonempty_iff_exists_right inter_nonempty_iff_exists_right\n\n",
 "inter_nonempty_iff_exists_left":
 "theorem inter_nonempty_iff_exists_left : (s ‚à© t).nonempty ‚Üî ‚àÉ x ‚àà s, x ‚àà t := by simp_rw [inter_nonempty, exists_prop]\n#align inter_nonempty_iff_exists_left inter_nonempty_iff_exists_left\n\n",
 "inter_nonempty":
 "theorem inter_nonempty : (s ‚à© t).nonempty ‚Üî ‚àÉ x, x ‚àà s ‚àß x ‚àà t :=\n  iff.rfl\n#align inter_nonempty inter_nonempty\n\n",
 "inter_left_comm":
 "theorem inter_left_comm (s‚ÇÅ s‚ÇÇ s‚ÇÉ : set Œ±) : s‚ÇÅ ‚à© (s‚ÇÇ ‚à© s‚ÇÉ) = s‚ÇÇ ‚à© (s‚ÇÅ ‚à© s‚ÇÉ) :=\n  ext fun x => and_left_comm\n#align inter_left_comm inter_left_comm\n\n",
 "inter_left'":
 "theorem inter_left' (u : set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=\n  h.inf_left' _\n#align inter_left' inter_left'\n\n",
 "inter_left":
 "theorem inter_left (u : set Œ±) (h : Disjoint s t) : Disjoint (s ‚à© u) t :=\n  h.inf_left u\n#align inter_left inter_left\n\n",
 "inter_inter_inter_comm":
 "theorem inter_inter_inter_comm (s t u v : set Œ±) : s ‚à© t ‚à© (u ‚à© v) = s ‚à© u ‚à© (t ‚à© v) :=\n  inf_inf_inf_comm _ _ _ _\n#align inter_inter_inter_comm inter_inter_inter_comm\n\n",
 "inter_inter_distrib_right":
 "theorem inter_inter_distrib_right (s t u : set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=\n  inf_inf_distrib_right _ _ _\n#align inter_inter_distrib_right inter_inter_distrib_right\n\n",
 "inter_inter_distrib_left":
 "theorem inter_inter_distrib_left (s t u : set Œ±) : s ‚à© (t ‚à© u) = s ‚à© t ‚à© (s ‚à© u) :=\n  inf_inf_distrib_left _ _ _\n#align inter_inter_distrib_left inter_inter_distrib_left\n\n",
 "inter_insert_of_not_mem":
 "theorem inter_insert_of_not_mem (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=\n  ext fun x => and_congr_right fun hx => or_iff_right <| ne_of_mem_of_not_mem hx h\n#align inter_insert_of_not_mem inter_insert_of_not_mem\n\n",
 "inter_insert_of_mem":
 "theorem inter_insert_of_mem (h : a ‚àà s) : s ‚à© insert a t = insert a (s ‚à© t) := by\n  rw [insert_inter_distrib, insert_eq_of_mem h]\n#align inter_insert_of_mem inter_insert_of_mem\n\n",
 "inter_eq_self_of_subset_right":
 "theorem inter_eq_self_of_subset_right {s t : set Œ±} : t ‚äÜ s ‚Üí s ‚à© t = t :=\n  inter_eq_right_iff_subset.mpr\n#align inter_eq_self_of_subset_right inter_eq_self_of_subset_right\n\n",
 "inter_eq_self_of_subset_left":
 "theorem inter_eq_self_of_subset_left {s t : set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=\n  inter_eq_left_iff_subset.mpr\n#align inter_eq_self_of_subset_left inter_eq_self_of_subset_left\n\n",
 "inter_eq_right_iff_subset":
 "@[simp]\ntheorem inter_eq_right_iff_subset {s t : set Œ±} : s ‚à© t = t ‚Üî t ‚äÜ s :=\n  inf_eq_right\n#align inter_eq_right_iff_subset inter_eq_right_iff_subset\n\n",
 "inter_eq_left_iff_subset":
 "@[simp]\ntheorem inter_eq_left_iff_subset {s t : set Œ±} : s ‚à© t = s ‚Üî s ‚äÜ t :=\n  inf_eq_left\n#align inter_eq_left_iff_subset inter_eq_left_iff_subset\n\n",
 "inter_eq_inter_iff_right":
 "theorem inter_eq_inter_iff_right : s ‚à© u = t ‚à© u ‚Üî t ‚à© u ‚äÜ s ‚àß s ‚à© u ‚äÜ t :=\n  inf_eq_inf_iff_right\n#align inter_eq_inter_iff_right inter_eq_inter_iff_right\n\n",
 "inter_eq_inter_iff_left":
 "theorem inter_eq_inter_iff_left : s ‚à© t = s ‚à© u ‚Üî s ‚à© u ‚äÜ t ‚àß s ‚à© t ‚äÜ u :=\n  inf_eq_inf_iff_left\n#align inter_eq_inter_iff_left inter_eq_inter_iff_left\n\n",
 "inter_eq_compl_compl_union_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem inter_eq_compl_compl_union_compl (s t : set Œ±) : s ‚à© t = ¬´expr ·∂ú¬ª (¬´expr ·∂ú¬ª s ‚à™ ¬´expr ·∂ú¬ª t) :=\n  ext fun x => and_iff_not_or_not\n#align inter_eq_compl_compl_union_compl inter_eq_compl_compl_union_compl\n\n",
 "inter_eq":
 "#print Disjoint.inter_eq /-\ntheorem Disjoint.inter_eq : Disjoint s t ‚Üí s ‚à© t = ‚àÖ :=\n  Disjoint.eq_bot\n#align disjoint.inter_eq Disjoint.inter_eq\n-/\n\n",
 "inter_empty":
 "@[simp]\ntheorem inter_empty (a : set Œ±) : a ‚à© ‚àÖ = ‚àÖ :=\n  ext fun x => and_false_iff _\n#align inter_empty inter_empty\n\n",
 "inter_distrib_right":
 "theorem inter_distrib_right (s t u : set Œ±) : (s ‚à™ t) ‚à© u = s ‚à© u ‚à™ t ‚à© u :=\n  inf_sup_right\n#align inter_distrib_right inter_distrib_right\n\n",
 "inter_distrib_left":
 "theorem inter_distrib_left (s t u : set Œ±) : s ‚à© (t ‚à™ u) = s ‚à© t ‚à™ s ‚à© u :=\n  inf_sup_left\n#align inter_distrib_left inter_distrib_left\n\n",
 "inter_diff_self":
 "@[simp]\ntheorem inter_diff_self (a b : set Œ±) : a ‚à© (b \\ a) = ‚àÖ :=\n  inf_sdiff_self_right\n#align inter_diff_self inter_diff_self\n\n",
 "inter_diff_assoc":
 "theorem inter_diff_assoc (a b c : set Œ±) : (a ‚à© b) \\ c = a ‚à© (b \\ c) :=\n  inf_sdiff_assoc\n#align inter_diff_assoc inter_diff_assoc\n\n",
 "inter_def":
 "theorem inter_def {s‚ÇÅ s‚ÇÇ : set Œ±} : s‚ÇÅ ‚à© s‚ÇÇ = { a | a ‚àà s‚ÇÅ ‚àß a ‚àà s‚ÇÇ } :=\n  rfl\n#align inter_def inter_def\n\n",
 "inter_congr_right":
 "theorem inter_congr_right (hs : t ‚à© u ‚äÜ s) (ht : s ‚à© u ‚äÜ t) : s ‚à© u = t ‚à© u :=\n  inf_congr_right hs ht\n#align inter_congr_right inter_congr_right\n\n",
 "inter_congr_left":
 "theorem inter_congr_left (ht : s ‚à© u ‚äÜ t) (hu : s ‚à© t ‚äÜ u) : s ‚à© t = s ‚à© u :=\n  inf_congr_left ht hu\n#align inter_congr_left inter_congr_left\n\n",
 "inter_compl_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem inter_compl_self (s : set Œ±) : s ‚à© ¬´expr ·∂ú¬ª s = ‚àÖ :=\n  inf_compl_eq_bot\n#align inter_compl_self inter_compl_self\n\n",
 "inter_compl_nonempty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem inter_compl_nonempty_iff {s t : set Œ±} : (s ‚à© ¬´expr ·∂ú¬ª t).nonempty ‚Üî ¬¨s ‚äÜ t :=\n  (not_subset.trans <| exists_congr fun x => by simp [mem_compl]).symm\n#align inter_compl_nonempty_iff inter_compl_nonempty_iff\n\n",
 "inter_comm":
 "theorem inter_comm (a b : set Œ±) : a ‚à© b = b ‚à© a :=\n  ext fun x => and_comm\n#align inter_comm inter_comm\n\n",
 "inter_assoc":
 "theorem inter_assoc (a b c : set Œ±) : a ‚à© b ‚à© c = a ‚à© (b ‚à© c) :=\n  ext fun x => and_assoc\n#align inter_assoc inter_assoc\n\n",
 "inter":
 "#print AntitoneOn.inter /-\ntheorem AntitoneOn.inter [preorder Œ≤] {f g : Œ≤ ‚Üí set Œ±} {s : set Œ≤} (hf : antitone_on f s) (hg : antitone_on g s) :\n    antitone_on (fun x => f x ‚à© g x) s :=\n  hf.inf hg\n#align antitone_on.inter AntitoneOn.inter\n-/\n\n",
 "insert_union_distrib":
 "theorem insert_union_distrib (a : Œ±) (s t : set Œ±) : insert a (s ‚à™ t) = insert a s ‚à™ insert a t :=\n  ext fun _ => or_or_distrib_left _ _ _\n#align insert_union_distrib insert_union_distrib\n\n",
 "insert_union":
 "theorem insert_union : insert a s ‚à™ t = insert a (s ‚à™ t) :=\n  ext fun x => or_assoc\n#align insert_union insert_union\n\n",
 "insert_subset_insert_iff":
 "theorem insert_subset_insert_iff (ha : a ‚àâ s) : insert a s ‚äÜ insert a t ‚Üî s ‚äÜ t :=\n  by\n  refine' ‚ü®fun h x hx => _, insert_subset_insert‚ü©\n  rcases h (subset_insert _ _ hx) with (rfl | hxt)\n  exacts[(ha hx).elim, hxt]\n#align insert_subset_insert_iff insert_subset_insert_iff\n\n",
 "insert_subset_insert":
 "theorem insert_subset_insert (h : s ‚äÜ t) : insert a s ‚äÜ insert a t := fun x => or.imp_right (@h _)\n#align insert_subset_insert insert_subset_insert\n\n",
 "insert_subset":
 "theorem insert_subset : insert a s ‚äÜ t ‚Üî a ‚àà t ‚àß s ‚äÜ t := by\n  simp only [subset_def, or_imp, forall_and, forall_eq, mem_insert_iff]\n#align insert_subset insert_subset\n\n",
 "insert_nonempty":
 "@[simp]\ntheorem insert_nonempty (a : Œ±) (s : set Œ±) : (insert a s).nonempty :=\n  ‚ü®a, mem_insert a s‚ü©\n#align insert_nonempty insert_nonempty\n\n",
 "insert_ne_self":
 "theorem insert_ne_self : insert a s ‚â† s ‚Üî a ‚àâ s :=\n  insert_eq_self.not\n#align insert_ne_self insert_ne_self\n\n",
 "insert_inter_of_not_mem":
 "theorem insert_inter_of_not_mem (h : a ‚àâ t) : insert a s ‚à© t = s ‚à© t :=\n  ext fun x => and_congr_left fun hx => or_iff_right <| ne_of_mem_of_not_mem hx h\n#align insert_inter_of_not_mem insert_inter_of_not_mem\n\n",
 "insert_inter_of_mem":
 "theorem insert_inter_of_mem (h : a ‚àà t) : insert a s ‚à© t = insert a (s ‚à© t) := by\n  rw [insert_inter_distrib, insert_eq_of_mem h]\n#align insert_inter_of_mem insert_inter_of_mem\n\n",
 "insert_inter_distrib":
 "theorem insert_inter_distrib (a : Œ±) (s t : set Œ±) : insert a (s ‚à© t) = insert a s ‚à© insert a t :=\n  ext fun y => or_and_left\n#align insert_inter_distrib insert_inter_distrib\n\n",
 "insert_inj":
 "theorem insert_inj (ha : a ‚àâ s) : insert a s = insert b s ‚Üî a = b :=\n  ‚ü®fun h => eq_of_not_mem_of_mem_insert (h.subst <| mem_insert a s) ha, congr_arg _‚ü©\n#align insert_inj insert_inj\n\n",
 "insert_idem":
 "@[simp]\ntheorem insert_idem (a : Œ±) (s : set Œ±) : insert a (insert a s) = insert a s :=\n  insert_eq_of_mem <| mem_insert _ _\n#align insert_idem insert_idem\n\n",
 "insert_eq_self":
 "@[simp]\ntheorem insert_eq_self : insert a s = s ‚Üî a ‚àà s :=\n  ‚ü®fun h => h ‚ñ∏ mem_insert _ _, insert_eq_of_mem‚ü©\n#align insert_eq_self insert_eq_self\n\n",
 "insert_eq_of_mem":
 "@[simp]\ntheorem insert_eq_of_mem {a : Œ±} {s : set Œ±} (h : a ‚àà s) : insert a s = s :=\n  ext fun x => or_iff_right_of_imp fun e => e.symm ‚ñ∏ h\n#align insert_eq_of_mem insert_eq_of_mem\n\n",
 "insert_eq":
 "theorem insert_eq (x : Œ±) (s : set Œ±) : insert x s = ({x} : set Œ±) ‚à™ s :=\n  rfl\n#align insert_eq insert_eq\n\n",
 "insert_diff_singleton":
 "@[simp]\ntheorem insert_diff_singleton {a : Œ±} {s : set Œ±} : insert a (s \\ {a}) = insert a s := by\n  simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]\n#align insert_diff_singleton insert_diff_singleton\n\n",
 "insert_diff_self_of_not_mem":
 "theorem insert_diff_self_of_not_mem {a : Œ±} {s : set Œ±} (h : a ‚àâ s) : insert a s \\ {a} = s :=\n  by\n  ext\n  simp [and_iff_left_of_imp fun hx : x ‚àà s => show x ‚â† a from fun hxa => h <| hxa ‚ñ∏ hx]\n#align insert_diff_self_of_not_mem insert_diff_self_of_not_mem\n\n",
 "insert_diff_of_not_mem":
 "theorem insert_diff_of_not_mem (s) (h : a ‚àâ t) : insert a s \\ t = insert a (s \\ t) := by\n  classical\n    ext x\n    by_cases h' : x ‚àà t\n    ¬∑ have : x ‚â† a := by\n        intro H\n        rw [H] at h'\n        exact h h'\n      simp [h, h', this]\n    ¬∑ simp [h, h']\n#align insert_diff_of_not_mem insert_diff_of_not_mem\n\n",
 "insert_diff_of_mem":
 "@[simp]\ntheorem insert_diff_of_mem (s) (h : a ‚àà t) : insert a s \\ t = s \\ t :=\n  by\n  ext\n  constructor <;> simp (config := { contextual := true }) [or_imp, h]\n#align insert_diff_of_mem insert_diff_of_mem\n\n",
 "insert_diff_eq_singleton":
 "@[simp]\ntheorem insert_diff_eq_singleton {a : Œ±} {s : set Œ±} (h : a ‚àâ s) : insert a s \\ s = {a} :=\n  by\n  ext\n  rw [Set.mem_diff, Set.mem_insert_iff, Set.mem_singleton_iff, or_and_right, and_not_self_iff, or_false_iff,\n    and_iff_left_iff_imp]\n  rintro rfl\n  exact h\n#align insert_diff_eq_singleton insert_diff_eq_singleton\n\n",
 "insert_def":
 "theorem insert_def (x : Œ±) (s : set Œ±) : insert x s = { y | y = x ‚à® y ‚àà s } :=\n  rfl\n#align insert_def insert_def\n\n",
 "insert_comm":
 "theorem insert_comm (a b : Œ±) (s : set Œ±) : insert a (insert b s) = insert b (insert a s) :=\n  ext fun x => or_left_comm\n#align insert_comm insert_comm\n\n",
 "inr":
 "theorem nonempty.inr (ht : t.nonempty) : (s ‚à™ t).nonempty :=\n  ht.imp fun _ => or.inr\n#align nonempty.inr nonempty.inr\n\n",
 "inl":
 "theorem nonempty.inl (hs : s.nonempty) : (s ‚à™ t).nonempty :=\n  hs.imp fun _ => or.inl\n#align nonempty.inl nonempty.inl\n\n",
 "inf_eq_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `¬´expr ‚äì ¬ª -/\n@[simp]\ntheorem inf_eq_inter : ((¬´expr ‚äì ¬ª ¬∑ ¬∑) : set Œ± ‚Üí set Œ± ‚Üí set Œ±) = (¬∑ ‚à© ¬∑) :=\n  rfl\n#align inf_eq_inter inf_eq_inter\n\n",
 "induction_on":
 "theorem subsingleton.induction_on {p : set Œ± ‚Üí Prop} (hs : s.subsingleton) (he : p ‚àÖ) (h‚ÇÅ : ‚àÄ x, p {x}) : p s :=\n  by\n  rcases hs.eq_empty_or_singleton with (rfl | ‚ü®x, rfl‚ü©)\n  exacts[he, h‚ÇÅ _]\n#align subsingleton.induction_on subsingleton.induction_on\n\n",
 "inclusion_self":
 "@[simp]\ntheorem inclusion_self (x : s) : inclusion Subset.rfl x = x :=\n  by\n  cases x\n  rfl\n#align inclusion_self inclusion_self\n\n",
 "inclusion_right":
 "theorem inclusion_right (h : s ‚äÜ t) (x : t) (m : (x : Œ±) ‚àà s) : inclusion h ‚ü®x, m‚ü© = x :=\n  by\n  cases x\n  rfl\n#align inclusion_right inclusion_right\n\n",
 "inclusion_mk":
 "@[simp]\ntheorem inclusion_mk {h : s ‚äÜ t} (a : Œ±) (ha : a ‚àà s) : inclusion h ‚ü®a, ha‚ü© = ‚ü®a, h ha‚ü© :=\n  rfl\n#align inclusion_mk inclusion_mk\n\n",
 "inclusion_injective":
 "theorem inclusion_injective (h : s ‚äÜ t) : injective (inclusion h)\n  | ‚ü®_, _‚ü©, ‚ü®_, _‚ü© => subtype.ext_iff_val.2 ‚àò subtype.ext_iff_val.1\n#align inclusion_injective inclusion_injective\n\n",
 "inclusion_inclusion":
 "@[simp]\ntheorem inclusion_inclusion (hst : s ‚äÜ t) (htu : t ‚äÜ u) (x : s) :\n    inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x :=\n  by\n  cases x\n  rfl\n#align inclusion_inclusion inclusion_inclusion\n\n",
 "inclusion_eq_id":
 "theorem inclusion_eq_id (h : s ‚äÜ s) : inclusion h = id :=\n  funext inclusion_self\n#align inclusion_eq_id inclusion_eq_id\n\n",
 "inclusion_comp_inclusion":
 "@[simp]\ntheorem inclusion_comp_inclusion {Œ±} {s t u : set Œ±} (hst : s ‚äÜ t) (htu : t ‚äÜ u) :\n    inclusion htu ‚àò inclusion hst = inclusion (hst.trans htu) :=\n  funext (inclusion_inclusion hst htu)\n#align inclusion_comp_inclusion inclusion_comp_inclusion\n\n",
 "forall_of_forall_insert":
 "-- useful in proofs by induction\ntheorem forall_of_forall_insert {P : Œ± ‚Üí Prop} {a : Œ±} {s : set Œ±} (H : ‚àÄ x, x ‚àà insert a s ‚Üí P x) (x) (h : x ‚àà s) :\n    P x :=\n  H _ (or.inr h)\n#align forall_of_forall_insert forall_of_forall_insert\n\n",
 "forall_insert_of_forall":
 "theorem forall_insert_of_forall {P : Œ± ‚Üí Prop} {a : Œ±} {s : set Œ±} (H : ‚àÄ x, x ‚àà s ‚Üí P x) (ha : P a) (x)\n    (h : x ‚àà insert a s) : P x :=\n  h.elim (fun e => e.symm ‚ñ∏ ha) (H _)\n#align forall_insert_of_forall forall_insert_of_forall\n\n",
 "forall_in_swap":
 "theorem forall_in_swap {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ a ‚àà s, ‚àÄ (b), p a b) ‚Üî ‚àÄ (b), ‚àÄ a ‚àà s, p a b := by tauto\n#align forall_in_swap forall_in_swap\n\n",
 "forall'":
 "#print SetCoe.forall' /-\ntheorem SetCoe.forall' {s : set Œ±} {p : ‚àÄ x, x ‚àà s ‚Üí Prop} : (‚àÄ (x) (h : x ‚àà s), p x h) ‚Üî ‚àÄ x : s, p x x.2 :=\n  (@SetCoe.forall _ _ fun x => p x.1 x.2).symm\n#align set_coe.forall' SetCoe.forall'\n-/\n\n",
 "forall":
 "#print SetCoe.forall /-\n@[simp]\ntheorem SetCoe.forall {s : set Œ±} {p : s ‚Üí Prop} : (‚àÄ x : s, p x) ‚Üî ‚àÄ (x) (h : x ‚àà s), p ‚ü®x, h‚ü© :=\n  subtype.forall\n#align set_coe.forall SetCoe.forall\n-/\n\n",
 "ext_iff":
 "theorem ext_iff {s t : set Œ±} : s = t ‚Üî ‚àÄ x, x ‚àà s ‚Üî x ‚àà t :=\n  ‚ü®fun h x => by rw [h], ext‚ü©\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext {a b : set Œ±} (h : ‚àÄ x, x ‚àà a ‚Üî x ‚àà b) : a = b :=\n  funext fun x => propext (h x)\n#align ext ext\n\n",
 "exists_of_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem exists_of_ssubset {s t : set Œ±} (h : ¬´expr ‚äÇ ¬ª s t) : ‚àÉ x ‚àà t, x ‚àâ s :=\n  not_subset.1 h.2\n#align exists_of_ssubset exists_of_ssubset\n\n",
 "exists_ne":
 "theorem nontrivial.exists_ne (hs : s.nontrivial) (z) : ‚àÉ x ‚àà s, x ‚â† z :=\n  by\n  by_contra H; push_neg  at H\n  rcases hs with ‚ü®x, hx, y, hy, hxy‚ü©\n  rw [H x hx, H y hy] at hxy\n  exact hxy rfl\n#align nontrivial.exists_ne nontrivial.exists_ne\n\n",
 "exists_mem_of_nonempty":
 "theorem exists_mem_of_nonempty (Œ±) : ‚àÄ [nonempty Œ±], ‚àÉ x : Œ±, x ‚àà (univ : set Œ±)\n  | ‚ü®x‚ü© => ‚ü®x, trivial‚ü©\n#align exists_mem_of_nonempty exists_mem_of_nonempty\n\n",
 "exists_lt":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª s) -/\ntheorem nontrivial.exists_lt [linear_order Œ±] (hs : s.nontrivial) : ‚àÉ (x : _)(_ : x ‚àà s)(y : _)(_ : y ‚àà s), x < y :=\n  let ‚ü®x, hx, y, hy, hxy‚ü© := hs\n  or.elim (lt_or_gt_of_ne hxy) (fun H => ‚ü®x, hx, y, hy, H‚ü©) fun H => ‚ü®y, hy, x, hx, H‚ü©\n#align nontrivial.exists_lt nontrivial.exists_lt\n\n",
 "exists_eq_singleton_or_nontrivial":
 "theorem nonempty.exists_eq_singleton_or_nontrivial : s.nonempty ‚Üí (‚àÉ a, s = {a}) ‚à® s.nontrivial := fun ‚ü®a, ha‚ü© =>\n  (eq_singleton_or_nontrivial ha).imp_left <| exists.intro a\n#align nonempty.exists_eq_singleton_or_nontrivial nonempty.exists_eq_singleton_or_nontrivial\n\n",
 "exists_eq_singleton_iff_nonempty_subsingleton":
 "theorem exists_eq_singleton_iff_nonempty_subsingleton : (‚àÉ a : Œ±, s = {a}) ‚Üî s.nonempty ‚àß s.subsingleton :=\n  by\n  refine' ‚ü®_, fun h => _‚ü©\n  ¬∑ rintro ‚ü®a, rfl‚ü©\n    exact ‚ü®singleton_nonempty a, subsingleton_singleton‚ü©\n  ¬∑ exact h.2.eq_empty_or_singleton.resolve_left h.1.ne_empty\n#align exists_eq_singleton_iff_nonempty_subsingleton exists_eq_singleton_iff_nonempty_subsingleton\n\n",
 "exists'":
 "#print SetCoe.exists' /-\ntheorem SetCoe.exists' {s : set Œ±} {p : ‚àÄ x, x ‚àà s ‚Üí Prop} : (‚àÉ (x : _)(h : x ‚àà s), p x h) ‚Üî ‚àÉ x : s, p x x.2 :=\n  (@SetCoe.exists _ _ fun x => p x.1 x.2).symm\n#align set_coe.exists' SetCoe.exists'\n-/\n\n",
 "exists":
 "#print SetCoe.exists /-\n@[simp]\ntheorem SetCoe.exists {s : set Œ±} {p : s ‚Üí Prop} : (‚àÉ x : s, p x) ‚Üî ‚àÉ (x : _)(h : x ‚àà s), p ‚ü®x, h‚ü© :=\n  subtype.exists\n#align set_coe.exists SetCoe.exists\n-/\n\n",
 "eq_univ_of_subset":
 "theorem eq_univ_of_subset {s t : set Œ±} (h : s ‚äÜ t) (hs : s = univ) : t = univ :=\n  eq_univ_of_univ_subset <| hs ‚ñ∏ h\n#align eq_univ_of_subset eq_univ_of_subset\n\n",
 "eq_univ_of_nonempty":
 "theorem eq_univ_of_nonempty {s : set Œ±} : s.nonempty ‚Üí s = univ := fun ‚ü®x, hx‚ü© =>\n  eq_univ_of_forall fun y => subsingleton.elim x y ‚ñ∏ hx\n#align eq_univ_of_nonempty eq_univ_of_nonempty\n\n",
 "eq_univ_of_forall":
 "theorem eq_univ_of_forall {s : set Œ±} : (‚àÄ x, x ‚àà s) ‚Üí s = univ :=\n  eq_univ_iff_forall.2\n#align eq_univ_of_forall eq_univ_of_forall\n\n",
 "eq_univ_iff_forall":
 "theorem eq_univ_iff_forall {s : set Œ±} : s = univ ‚Üî ‚àÄ x, x ‚àà s :=\n  univ_subset_iff.symm.trans <| forall_congr' fun x => imp_iff_right trivial\n#align eq_univ_iff_forall eq_univ_iff_forall\n\n",
 "eq_univ":
 "theorem nonempty.eq_univ [subsingleton Œ±] : s.nonempty ‚Üí s = univ :=\n  by\n  rintro ‚ü®x, hx‚ü©\n  refine' eq_univ_of_forall fun y => by rwa [subsingleton.elim y x]\n#align nonempty.eq_univ nonempty.eq_univ\n\n",
 "eq_singleton_or_nontrivial":
 "theorem eq_singleton_or_nontrivial (ha : a ‚àà s) : s = {a} ‚à® s.nontrivial :=\n  by\n  rw [‚Üê subsingleton_iff_singleton ha]\n  exact s.subsingleton_or_nontrivial\n#align eq_singleton_or_nontrivial eq_singleton_or_nontrivial\n\n",
 "eq_singleton_of_mem":
 "theorem subsingleton.eq_singleton_of_mem (hs : s.subsingleton) {x : Œ±} (hx : x ‚àà s) : s = {x} :=\n  ext fun y => ‚ü®fun hy => hs hx hy ‚ñ∏ mem_singleton _, fun hy => (eq_of_mem_singleton hy).symm ‚ñ∏ hx‚ü©\n#align subsingleton.eq_singleton_of_mem subsingleton.eq_singleton_of_mem\n\n",
 "eq_singleton_iff_unique_mem":
 "theorem eq_singleton_iff_unique_mem : s = {a} ‚Üî a ‚àà s ‚àß ‚àÄ x ‚àà s, x = a :=\n  Subset.antisymm_iff.trans <| and_comm.trans <| and_congr_left' singleton_subset_iff\n#align eq_singleton_iff_unique_mem eq_singleton_iff_unique_mem\n\n",
 "eq_singleton_iff_nonempty_unique_mem":
 "theorem eq_singleton_iff_nonempty_unique_mem : s = {a} ‚Üî s.nonempty ‚àß ‚àÄ x ‚àà s, x = a :=\n  eq_singleton_iff_unique_mem.trans <| and_congr_left fun H => ‚ü®fun h' => ‚ü®_, h'‚ü©, fun ‚ü®x, h‚ü© => H x h ‚ñ∏ h‚ü©\n#align eq_singleton_iff_nonempty_unique_mem eq_singleton_iff_nonempty_unique_mem\n\n",
 "eq_or_ssubset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n#print eq_or_ssubset_of_subset /-\nprotected theorem eq_or_ssubset_of_subset (h : s ‚äÜ t) : s = t ‚à® ¬´expr ‚äÇ ¬ª s t :=\n  eq_or_lt_of_le h\n#align eq_or_ssubset_of_subset eq_or_ssubset_of_subset\n-/\n\n",
 "eq_or_mem_of_mem_insert":
 "theorem eq_or_mem_of_mem_insert {x a : Œ±} {s : set Œ±} : x ‚àà insert a s ‚Üí x = a ‚à® x ‚àà s :=\n  id\n#align eq_or_mem_of_mem_insert eq_or_mem_of_mem_insert\n\n",
 "eq_of_subset_of_subset":
 "-- an alternative name\ntheorem eq_of_subset_of_subset {a b : set Œ±} : a ‚äÜ b ‚Üí b ‚äÜ a ‚Üí a = b :=\n  subset.antisymm\n#align eq_of_subset_of_subset eq_of_subset_of_subset\n\n",
 "eq_of_not_mem_of_mem_insert":
 "theorem eq_of_not_mem_of_mem_insert : b ‚àà insert a s ‚Üí b ‚àâ s ‚Üí b = a :=\n  or.resolve_right\n#align eq_of_not_mem_of_mem_insert eq_of_not_mem_of_mem_insert\n\n",
 "eq_of_mem_singleton":
 "theorem eq_of_mem_singleton {x y : Œ±} (h : x ‚àà ({y} : set Œ±)) : x = y :=\n  h\n#align eq_of_mem_singleton eq_of_mem_singleton\n\n",
 "eq_of_inclusion_surjective":
 "theorem eq_of_inclusion_surjective {s t : set Œ±} {h : s ‚äÜ t} (h_surj : function.surjective (inclusion h)) : s = t :=\n  by\n  refine' Set.Subset.antisymm h fun x hx => _\n  obtain ‚ü®y, hy‚ü© := h_surj ‚ü®x, hx‚ü©\n  exact mem_of_eq_of_mem (congr_arg coe hy).symm y.prop\n#align eq_of_inclusion_surjective eq_of_inclusion_surjective\n\n",
 "eq_empty_or_singleton":
 "theorem subsingleton.eq_empty_or_singleton (hs : s.subsingleton) : s = ‚àÖ ‚à® ‚àÉ x, s = {x} :=\n  s.eq_empty_or_nonempty.elim or.inl fun ‚ü®x, hx‚ü© => or.inr ‚ü®x, hs.eq_singleton_of_mem hx‚ü©\n#align subsingleton.eq_empty_or_singleton subsingleton.eq_empty_or_singleton\n\n",
 "eq_empty_or_nonempty":
 "theorem eq_empty_or_nonempty (s : set Œ±) : s = ‚àÖ ‚à® s.nonempty :=\n  or_iff_not_imp_left.2 nonempty_iff_ne_empty.2\n#align eq_empty_or_nonempty eq_empty_or_nonempty\n\n",
 "eq_empty_of_subset_empty":
 "theorem eq_empty_of_subset_empty {s : set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=\n  subset_empty_iff.1\n#align eq_empty_of_subset_empty eq_empty_of_subset_empty\n\n",
 "eq_empty_of_ssubset_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\ntheorem eq_empty_of_ssubset_singleton {s : set Œ±} {x : Œ±} (hs : ¬´expr ‚äÇ ¬ª s {x}) : s = ‚àÖ :=\n  ssubset_singleton_iff.1 hs\n#align eq_empty_of_ssubset_singleton eq_empty_of_ssubset_singleton\n\n",
 "eq_empty_of_is_empty":
 "theorem eq_empty_of_is_empty [is_empty Œ±] (s : set Œ±) : s = ‚àÖ :=\n  eq_empty_of_subset_empty fun x hx => is_empty_elim x\n#align eq_empty_of_is_empty eq_empty_of_is_empty\n\n",
 "eq_empty_of_forall_not_mem":
 "theorem eq_empty_of_forall_not_mem (h : ‚àÄ x, x ‚àâ s) : s = ‚àÖ :=\n  subset_empty_iff.1 h\n#align eq_empty_of_forall_not_mem eq_empty_of_forall_not_mem\n\n",
 "eq_empty_iff_forall_not_mem":
 "theorem eq_empty_iff_forall_not_mem {s : set Œ±} : s = ‚àÖ ‚Üî ‚àÄ x, x ‚àâ s :=\n  subset_empty_iff.symm\n#align eq_empty_iff_forall_not_mem eq_empty_iff_forall_not_mem\n\n",
 "empty_union":
 "@[simp]\ntheorem empty_union (a : set Œ±) : ‚àÖ ‚à™ a = a :=\n  ext fun x => false_or_iff _\n#align empty_union empty_union\n\n",
 "empty_subset":
 "@[simp]\ntheorem empty_subset (s : set Œ±) : ‚àÖ ‚äÜ s :=\n  fun.\n#align empty_subset empty_subset\n\n",
 "empty_ssubset_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n@[simp]\ntheorem empty_ssubset_singleton : ¬´expr ‚äÇ ¬ª (‚àÖ : set Œ±) {a} :=\n  (singleton_nonempty _).empty_ssubset\n#align empty_ssubset_singleton empty_ssubset_singleton\n\n",
 "empty_ssubset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ‚äÇ ¬ª -/\n@[simp]\ntheorem empty_ssubset : ¬´expr ‚äÇ ¬ª ‚àÖ s ‚Üî s.nonempty :=\n  (@bot_lt_iff_ne_bot (set Œ±) _ _ _).trans nonempty_iff_ne_empty.symm\n#align empty_ssubset empty_ssubset\n\n",
 "empty_ne_univ":
 "theorem empty_ne_univ [nonempty Œ±] : (‚àÖ : set Œ±) ‚â† univ := fun e =>\n  not_isEmpty_of_nonempty Œ± <| univ_eq_empty_iff.1 e.symm\n#align empty_ne_univ empty_ne_univ\n\n",
 "empty_inter":
 "@[simp]\ntheorem empty_inter (a : set Œ±) : ‚àÖ ‚à© a = ‚àÖ :=\n  ext fun x => false_and_iff _\n#align empty_inter empty_inter\n\n",
 "empty_disjoint":
 "@[simp]\ntheorem empty_disjoint (s : set Œ±) : Disjoint ‚àÖ s :=\n  disjoint_bot_left\n#align empty_disjoint empty_disjoint\n\n",
 "empty_diff":
 "@[simp]\ntheorem empty_diff (s : set Œ±) : (‚àÖ \\ s : set Œ±) = ‚àÖ :=\n  bot_sdiff\n#align empty_diff empty_diff\n\n",
 "empty_def":
 "theorem empty_def : (‚àÖ : set Œ±) = { x | false } :=\n  rfl\n#align empty_def empty_def\n\n",
 "elim":
 "theorem mem_union.elim {x : Œ±} {a b : set Œ±} {P : Prop} (H‚ÇÅ : x ‚àà a ‚à™ b) (H‚ÇÇ : x ‚àà a ‚Üí P) (H‚ÇÉ : x ‚àà b ‚Üí P) : P :=\n  or.elim H‚ÇÅ H‚ÇÇ H‚ÇÉ\n#align mem_union.elim mem_union.elim\n\n",
 "disjoint_univ":
 "@[simp]\ntheorem disjoint_univ : Disjoint s univ ‚Üî s = ‚àÖ :=\n  disjoint_top\n#align disjoint_univ disjoint_univ\n\n",
 "disjoint_union_right":
 "@[simp]\ntheorem disjoint_union_right : Disjoint s (t ‚à™ u) ‚Üî Disjoint s t ‚àß Disjoint s u :=\n  disjoint_sup_right\n#align disjoint_union_right disjoint_union_right\n\n",
 "disjoint_union_left":
 "@[simp]\ntheorem disjoint_union_left : Disjoint (s ‚à™ t) u ‚Üî Disjoint s u ‚àß Disjoint t u :=\n  disjoint_sup_left\n#align disjoint_union_left disjoint_union_left\n\n",
 "disjoint_singleton_right":
 "@[simp]\ntheorem disjoint_singleton_right : Disjoint s {a} ‚Üî a ‚àâ s :=\n  disjoint_comm.trans disjoint_singleton_left\n#align disjoint_singleton_right disjoint_singleton_right\n\n",
 "disjoint_singleton_left":
 "@[simp]\ntheorem disjoint_singleton_left : Disjoint {a} s ‚Üî a ‚àâ s := by simp [Set.disjoint_iff, subset_def] <;> exact iff.rfl\n#align disjoint_singleton_left disjoint_singleton_left\n\n",
 "disjoint_singleton":
 "@[simp]\ntheorem disjoint_singleton : Disjoint ({a} : set Œ±) {b} ‚Üî a ‚â† b := by rw [disjoint_singleton_left, mem_singleton_iff]\n#align disjoint_singleton disjoint_singleton\n\n",
 "disjoint_sdiff_right":
 "theorem disjoint_sdiff_right : Disjoint s (t \\ s) :=\n  disjoint_sdiff_self_right\n#align disjoint_sdiff_right disjoint_sdiff_right\n\n",
 "disjoint_sdiff_left":
 "theorem disjoint_sdiff_left : Disjoint (t \\ s) s :=\n  disjoint_sdiff_self_left\n#align disjoint_sdiff_left disjoint_sdiff_left\n\n",
 "disjoint_right":
 "theorem disjoint_right : Disjoint s t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà t ‚Üí a ‚àâ s := by rw [disjoint_comm, disjoint_left]\n#align disjoint_right disjoint_right\n\n",
 "disjoint_or_nonempty_inter":
 "theorem disjoint_or_nonempty_inter (s t : set Œ±) : Disjoint s t ‚à® (s ‚à© t).nonempty :=\n  (em _).imp_right not_disjoint_iff_nonempty_inter.mp\n#align disjoint_or_nonempty_inter disjoint_or_nonempty_inter\n\n",
 "disjoint_of_subset_right":
 "theorem disjoint_of_subset_right (ht : t‚ÇÅ ‚äÜ t‚ÇÇ) (h : Disjoint s t‚ÇÇ) : Disjoint s t‚ÇÅ :=\n  h.mono_right ht\n#align disjoint_of_subset_right disjoint_of_subset_right\n\n",
 "disjoint_of_subset_left":
 "theorem disjoint_of_subset_left (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (h : Disjoint s‚ÇÇ t) : Disjoint s‚ÇÅ t :=\n  h.mono_left hs\n#align disjoint_of_subset_left disjoint_of_subset_left\n\n",
 "disjoint_of_subset":
 "theorem disjoint_of_subset (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (ht : t‚ÇÅ ‚äÜ t‚ÇÇ) (h : Disjoint s‚ÇÇ t‚ÇÇ) : Disjoint s‚ÇÅ t‚ÇÅ :=\n  h.mono hs ht\n#align disjoint_of_subset disjoint_of_subset\n\n",
 "disjoint_left":
 "theorem disjoint_left : Disjoint s t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí a ‚àâ t :=\n  disjoint_iff_inf_le.trans <| forall_congr' fun _ => not_and\n#align disjoint_left disjoint_left\n\n",
 "disjoint_iff_inter_eq_empty":
 "theorem disjoint_iff_inter_eq_empty : Disjoint s t ‚Üî s ‚à© t = ‚àÖ :=\n  disjoint_iff\n#align disjoint_iff_inter_eq_empty disjoint_iff_inter_eq_empty\n\n",
 "disjoint_iff_forall_ne":
 "theorem disjoint_iff_forall_ne : Disjoint s t ‚Üî ‚àÄ x ‚àà s, ‚àÄ y ‚àà t, x ‚â† y := by\n  simp only [ne.def, disjoint_left, @imp_not_comm _ (_ = _), forall_eq']\n#align disjoint_iff_forall_ne disjoint_iff_forall_ne\n\n",
 "disjoint_iff":
 "#print disjoint_iff /-\nprotected theorem disjoint_iff : Disjoint s t ‚Üî s ‚à© t ‚äÜ ‚àÖ :=\n  disjoint_iff_inf_le\n#align disjoint_iff disjoint_iff\n-/\n\n",
 "disjoint_empty":
 "@[simp]\ntheorem disjoint_empty (s : set Œ±) : Disjoint s ‚àÖ :=\n  disjoint_bot_right\n#align disjoint_empty disjoint_empty\n\n",
 "disjoint_compl_right_iff_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem disjoint_compl_right_iff_subset : Disjoint s (¬´expr ·∂ú¬ª t) ‚Üî s ‚äÜ t :=\n  disjoint_compl_right_iff\n#align disjoint_compl_right_iff_subset disjoint_compl_right_iff_subset\n\n",
 "disjoint_compl_left_iff_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem disjoint_compl_left_iff_subset : Disjoint (¬´expr ·∂ú¬ª s) t ‚Üî t ‚äÜ s :=\n  disjoint_compl_left_iff\n#align disjoint_compl_left_iff_subset disjoint_compl_left_iff_subset\n\n",
 "diff_univ":
 "@[simp]\ntheorem diff_univ (s : set Œ±) : s \\ univ = ‚àÖ :=\n  diff_eq_empty.2 (subset_univ s)\n#align diff_univ diff_univ\n\n",
 "diff_union_self":
 "@[simp]\ntheorem diff_union_self {s t : set Œ±} : s \\ t ‚à™ t = s ‚à™ t :=\n  sdiff_sup_self _ _\n#align diff_union_self diff_union_self\n\n",
 "diff_union_of_subset":
 "theorem diff_union_of_subset {s t : set Œ±} (h : t ‚äÜ s) : s \\ t ‚à™ t = s :=\n  Subset.antisymm (union_subset (diff_subset _ _) h) (subset_diff_union _ _)\n#align diff_union_of_subset diff_union_of_subset\n\n",
 "diff_union_inter":
 "@[simp]\ntheorem diff_union_inter (s t : set Œ±) : s \\ t ‚à™ s ‚à© t = s :=\n  by\n  rw [union_comm]\n  exact sup_inf_sdiff _ _\n#align diff_union_inter diff_union_inter\n\n",
 "diff_subset_iff":
 "theorem diff_subset_iff {s t u : set Œ±} : s \\ t ‚äÜ u ‚Üî s ‚äÜ t ‚à™ u :=\n  show s \\ t ‚â§ u ‚Üî s ‚â§ t ‚à™ u from sdiff_le_iff\n#align diff_subset_iff diff_subset_iff\n\n",
 "diff_subset_diff_right":
 "theorem diff_subset_diff_right {s t u : set Œ±} (h : t ‚äÜ u) : s \\ u ‚äÜ s \\ t :=\n  sdiff_le_sdiff_left ‚Äπt ‚â§ u‚Ä∫\n#align diff_subset_diff_right diff_subset_diff_right\n\n",
 "diff_subset_diff_left":
 "theorem diff_subset_diff_left {s‚ÇÅ s‚ÇÇ t : set Œ±} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : s‚ÇÅ \\ t ‚äÜ s‚ÇÇ \\ t :=\n  sdiff_le_sdiff_right ‚Äπs‚ÇÅ ‚â§ s‚ÇÇ‚Ä∫\n#align diff_subset_diff_left diff_subset_diff_left\n\n",
 "diff_subset_diff":
 "theorem diff_subset_diff {s‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : set Œ±} : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí t‚ÇÇ ‚äÜ t‚ÇÅ ‚Üí s‚ÇÅ \\ t‚ÇÅ ‚äÜ s‚ÇÇ \\ t‚ÇÇ :=\n  show s‚ÇÅ ‚â§ s‚ÇÇ ‚Üí t‚ÇÇ ‚â§ t‚ÇÅ ‚Üí s‚ÇÅ \\ t‚ÇÅ ‚â§ s‚ÇÇ \\ t‚ÇÇ from sdiff_le_sdiff\n#align diff_subset_diff diff_subset_diff\n\n",
 "diff_subset_comm":
 "theorem diff_subset_comm {s t u : set Œ±} : s \\ t ‚äÜ u ‚Üî s \\ u ‚äÜ t :=\n  show s \\ t ‚â§ u ‚Üî s \\ u ‚â§ t from sdiff_le_comm\n#align diff_subset_comm diff_subset_comm\n\n",
 "diff_subset":
 "theorem diff_subset (s t : set Œ±) : s \\ t ‚äÜ s :=\n  show s \\ t ‚â§ s from sdiff_le\n#align diff_subset diff_subset\n\n",
 "diff_singleton_subset_iff":
 "@[simp]\ntheorem diff_singleton_subset_iff {x : Œ±} {s t : set Œ±} : s \\ {x} ‚äÜ t ‚Üî s ‚äÜ insert x t :=\n  by\n  rw [‚Üê union_singleton, union_comm]\n  apply diff_subset_iff\n#align diff_singleton_subset_iff diff_singleton_subset_iff\n\n",
 "diff_singleton_eq_self":
 "@[simp]\ntheorem diff_singleton_eq_self {a : Œ±} {s : set Œ±} (h : a ‚àâ s) : s \\ {a} = s :=\n  sdiff_eq_self_iff_disjoint.2 <| by simp [h]\n#align diff_singleton_eq_self diff_singleton_eq_self\n\n",
 "diff_self_inter":
 "@[simp]\ntheorem diff_self_inter {s t : set Œ±} : s \\ (s ‚à© t) = s \\ t :=\n  sdiff_inf_self_left _ _\n#align diff_self_inter diff_self_inter\n\n",
 "diff_self":
 "@[simp]\ntheorem diff_self {s : set Œ±} : s \\ s = ‚àÖ :=\n  sdiff_self\n#align diff_self diff_self\n\n",
 "diff_inter_self_eq_diff":
 "@[simp]\ntheorem diff_inter_self_eq_diff {s t : set Œ±} : s \\ (t ‚à© s) = s \\ t :=\n  sdiff_inf_self_right _ _\n#align diff_inter_self_eq_diff diff_inter_self_eq_diff\n\n",
 "diff_inter_self":
 "@[simp]\ntheorem diff_inter_self {a b : set Œ±} : b \\ a ‚à© a = ‚àÖ :=\n  inf_sdiff_self_left\n#align diff_inter_self diff_inter_self\n\n",
 "diff_inter_diff":
 "theorem diff_inter_diff {s t u : set Œ±} : s \\ t ‚à© (s \\ u) = s \\ (t ‚à™ u) :=\n  sdiff_sup.symm\n#align diff_inter_diff diff_inter_diff\n\n",
 "diff_inter":
 "theorem diff_inter {s t u : set Œ±} : s \\ (t ‚à© u) = s \\ t ‚à™ s \\ u :=\n  sdiff_inf\n#align diff_inter diff_inter\n\n",
 "diff_eq_empty":
 "theorem diff_eq_empty {s t : set Œ±} : s \\ t = ‚àÖ ‚Üî s ‚äÜ t :=\n  sdiff_eq_bot_iff\n#align diff_eq_empty diff_eq_empty\n\n",
 "diff_eq_compl_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem diff_eq_compl_inter {s t : set Œ±} : s \\ t = ¬´expr ·∂ú¬ª t ‚à© s := by rw [diff_eq, inter_comm]\n#align diff_eq_compl_inter diff_eq_compl_inter\n\n",
 "diff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem diff_eq (s t : set Œ±) : s \\ t = s ‚à© ¬´expr ·∂ú¬ª t :=\n  rfl\n#align diff_eq diff_eq\n\n",
 "diff_empty":
 "@[simp]\ntheorem diff_empty {s : set Œ±} : s \\ ‚àÖ = s :=\n  sdiff_bot\n#align diff_empty diff_empty\n\n",
 "diff_diff_right_self":
 "theorem diff_diff_right_self (s t : set Œ±) : s \\ (s \\ t) = s ‚à© t :=\n  sdiff_sdiff_right_self\n#align diff_diff_right_self diff_diff_right_self\n\n",
 "diff_diff_right":
 "theorem diff_diff_right {s t u : set Œ±} : s \\ (t \\ u) = s \\ t ‚à™ s ‚à© u :=\n  sdiff_sdiff_right'\n#align diff_diff_right diff_diff_right\n\n",
 "diff_diff_comm":
 "-- the following statement contains parentheses to help the reader\ntheorem diff_diff_comm {s t u : set Œ±} : (s \\ t) \\ u = (s \\ u) \\ t :=\n  sdiff_sdiff_comm\n#align diff_diff_comm diff_diff_comm\n\n",
 "diff_diff_cancel_left":
 "theorem diff_diff_cancel_left {s t : set Œ±} (h : s ‚äÜ t) : t \\ (t \\ s) = s :=\n  sdiff_sdiff_eq_self h\n#align diff_diff_cancel_left diff_diff_cancel_left\n\n",
 "diff_diff":
 "theorem diff_diff {u : set Œ±} : (s \\ t) \\ u = s \\ (t ‚à™ u) :=\n  sdiff_sdiff_left\n#align diff_diff diff_diff\n\n",
 "diff_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem diff_compl : s \\ ¬´expr ·∂ú¬ª t = s ‚à© t :=\n  sdiff_compl\n#align diff_compl diff_compl\n\n",
 "default_coe_singleton":
 "-- while `simp` is capable of proving this, it is not capable of turning the LHS into the RHS.\n@[simp]\ntheorem default_coe_singleton (x : Œ±) : (default : ({x} : set Œ±)) = ‚ü®x, rfl‚ü© :=\n  rfl\n#align default_coe_singleton default_coe_singleton\n\n",
 "compl_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_univ_iff {s : set Œ±} : ¬´expr ·∂ú¬ª s = univ ‚Üî s = ‚àÖ :=\n  compl_eq_top\n#align compl_univ_iff compl_univ_iff\n\n",
 "compl_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_univ : ¬´expr ·∂ú¬ª (univ : set Œ±) = ‚àÖ :=\n  compl_top\n#align compl_univ compl_univ\n\n",
 "compl_union_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_union_self (s : set Œ±) : ¬´expr ·∂ú¬ª s ‚à™ s = univ := by rw [union_comm, union_compl_self]\n#align compl_union_self compl_union_self\n\n",
 "compl_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_union (s t : set Œ±) : ¬´expr ·∂ú¬ª (s ‚à™ t) = ¬´expr ·∂ú¬ª s ‚à© ¬´expr ·∂ú¬ª t :=\n  compl_sup\n#align compl_union compl_union\n\n",
 "compl_subset_iff_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_subset_iff_union {s t : set Œ±} : ¬´expr ·∂ú¬ª s ‚äÜ t ‚Üî s ‚à™ t = univ :=\n  iff.symm <| eq_univ_iff_forall.trans <| forall_congr' fun a => or_iff_not_imp_left\n#align compl_subset_iff_union compl_subset_iff_union\n\n",
 "compl_subset_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_subset_compl : ¬´expr ·∂ú¬ª s ‚äÜ ¬´expr ·∂ú¬ª t ‚Üî t ‚äÜ s :=\n  @compl_le_compl_iff_le (set Œ±) _ _ _\n#align compl_subset_compl compl_subset_compl\n\n",
 "compl_subset_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_subset_comm : ¬´expr ·∂ú¬ª s ‚äÜ t ‚Üî ¬´expr ·∂ú¬ª t ‚äÜ s :=\n  @compl_le_iff_compl_le _ s _ _\n#align compl_subset_comm compl_subset_comm\n\n",
 "compl_singleton_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_singleton_eq (a : Œ±) : ¬´expr ·∂ú¬ª ({a} : set Œ±) = { x | x ‚â† a } :=\n  rfl\n#align compl_singleton_eq compl_singleton_eq\n\n",
 "compl_set_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_set_of {Œ±} (p : Œ± ‚Üí Prop) : ¬´expr ·∂ú¬ª { a | p a } = { a | ¬¨p a } :=\n  rfl\n#align compl_set_of compl_set_of\n\n",
 "compl_ne_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_ne_univ : ¬´expr ·∂ú¬ª s ‚â† univ ‚Üî s.nonempty :=\n  compl_univ_iff.not.trans nonempty_iff_ne_empty.symm\n#align compl_ne_univ compl_ne_univ\n\n",
 "compl_ne_eq_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_ne_eq_singleton (a : Œ±) : ¬´expr ·∂ú¬ª ({ x | x ‚â† a } : set Œ±) = {a} :=\n  compl_compl _\n#align compl_ne_eq_singleton compl_ne_eq_singleton\n\n",
 "compl_inter_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_inter_self (s : set Œ±) : ¬´expr ·∂ú¬ª s ‚à© s = ‚àÖ :=\n  compl_inf_eq_bot\n#align compl_inter_self compl_inter_self\n\n",
 "compl_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_inter (s t : set Œ±) : ¬´expr ·∂ú¬ª (s ‚à© t) = ¬´expr ·∂ú¬ª s ‚à™ ¬´expr ·∂ú¬ª t :=\n  compl_inf\n#align compl_inter compl_inter\n\n",
 "compl_eq_univ_diff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_eq_univ_diff (s : set Œ±) : ¬´expr ·∂ú¬ª s = univ \\ s :=\n  top_sdiff.symm\n#align compl_eq_univ_diff compl_eq_univ_diff\n\n",
 "compl_empty_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_empty_iff {s : set Œ±} : ¬´expr ·∂ú¬ª s = ‚àÖ ‚Üî s = univ :=\n  compl_eq_bot\n#align compl_empty_iff compl_empty_iff\n\n",
 "compl_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\n@[simp]\ntheorem compl_empty : ¬´expr ·∂ú¬ª (‚àÖ : set Œ±) = univ :=\n  compl_bot\n#align compl_empty compl_empty\n\n",
 "compl_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr ·∂ú¬ª -/\ntheorem compl_def (s : set Œ±) : ¬´expr ·∂ú¬ª s = { x | x ‚àâ s } :=\n  rfl\n#align compl_def compl_def\n\n",
 "coe_sort":
 "theorem subsingleton.coe_sort {s : set Œ±} : s.subsingleton ‚Üí subsingleton s :=\n  s.subsingleton_coe.2\n#align subsingleton.coe_sort subsingleton.coe_sort\n\n",
 "coe_setOf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n#print Set.coe_setOf /-\n@[simp]\ntheorem Set.coe_setOf (p : Œ± ‚Üí Prop) : ¬´expr‚Ü• ¬ª { x | p x } = { x // p x } :=\n  rfl\n#align set.coe_set_of Set.coe_setOf\n-/\n\n",
 "coe_inclusion":
 "@[simp]\ntheorem coe_inclusion (h : s ‚äÜ t) (x : s) : (inclusion h x : Œ±) = (x : Œ±) :=\n  rfl\n#align coe_inclusion coe_inclusion\n\n",
 "coe_eq_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Ü• ¬ª -/\n#print Set.coe_eq_subtype /-\ntheorem Set.coe_eq_subtype (s : set Œ±) : ¬´expr‚Ü• ¬ª s = { x // x ‚àà s } :=\n  rfl\n#align set.coe_eq_subtype Set.coe_eq_subtype\n-/\n\n",
 "bot_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ä•¬ª -/\n@[simp]\ntheorem bot_eq_empty : (¬´expr‚ä•¬ª : set Œ±) = ‚àÖ :=\n  rfl\n#align bot_eq_empty bot_eq_empty\n\n",
 "bex_insert_iff":
 "theorem bex_insert_iff {P : Œ± ‚Üí Prop} {a : Œ±} {s : set Œ±} : (‚àÉ x ‚àà insert a s, P x) ‚Üî P a ‚à® ‚àÉ x ‚àà s, P x :=\n  bex_or_left.trans <| or_congr_left bex_eq_left\n#align bex_insert_iff bex_insert_iff\n\n",
 "ball_insert_iff":
 "theorem ball_insert_iff {P : Œ± ‚Üí Prop} {a : Œ±} {s : set Œ±} : (‚àÄ x ‚àà insert a s, P x) ‚Üî P a ‚àß ‚àÄ x ‚àà s, P x :=\n  ball_or_left.trans <| and_congr_left' forall_eq\n#align ball_insert_iff ball_insert_iff\n\n",
 "ball_empty_iff":
 "theorem ball_empty_iff {p : Œ± ‚Üí Prop} : (‚àÄ x ‚àà (‚àÖ : set Œ±), p x) ‚Üî true :=\n  iff_true_intro fun x => false.elim\n#align ball_empty_iff ball_empty_iff\n\n",
 "antitone_set_of":
 "theorem antitone_set_of [preorder Œ±] {p : Œ± ‚Üí Œ≤ ‚Üí Prop} (hp : ‚àÄ b, antitone fun a => p a b) :\n    antitone fun a => { b | p a b } := fun a a' h b => hp b h\n#align antitone_set_of antitone_set_of\n\n",
 "antitone_on_singleton":
 "@[simp]\ntheorem antitone_on_singleton : antitone_on f {a} :=\n  subsingleton_singleton.antitone_on f\n#align antitone_on_singleton antitone_on_singleton\n\n",
 "antitone_on_iff_antitone":
 "theorem antitone_on_iff_antitone : antitone_on f s ‚Üî antitone fun a : s => f a := by simp [antitone, antitone_on]\n#align antitone_on_iff_antitone antitone_on_iff_antitone\n\n",
 "antitone_on":
 "protected theorem subsingleton.antitone_on (h : s.subsingleton) : antitone_on f s := fun a ha b hb _ =>\n  (congr_arg _ (h hb ha)).le\n#align subsingleton.antitone_on subsingleton.antitone_on\n\n",
 "antitone_bforall":
 "/-- Quantifying over a set is antitone in the set -/\ntheorem antitone_bforall {P : Œ± ‚Üí Prop} : antitone fun s : set Œ± => ‚àÄ x ‚àà s, P x := fun s t hst h x hx => h x <| hst hx\n#align antitone_bforall antitone_bforall\n\n",
 "antisymm_iff":
 "theorem subset.antisymm_iff {a b : set Œ±} : a = b ‚Üî a ‚äÜ b ‚àß b ‚äÜ a :=\n  ‚ü®fun e => ‚ü®e.subset, e.symm.subset‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => Subset.antisymm h‚ÇÅ h‚ÇÇ‚ü©\n#align subset.antisymm_iff subset.antisymm_iff\n\n",
 "antisymm":
 "theorem subset.antisymm {a b : set Œ±} (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : b ‚äÜ a) : a = b :=\n  Set.ext fun x => ‚ü®@h‚ÇÅ _, @h‚ÇÇ _‚ü©\n#align subset.antisymm subset.antisymm\n\n",
 "anti":
 "theorem subsingleton.anti (ht : t.subsingleton) (hst : s ‚äÜ t) : s.subsingleton := fun x hx y hy => ht (hst hx) (hst hy)\n#align subsingleton.anti subsingleton.anti\n\n"}