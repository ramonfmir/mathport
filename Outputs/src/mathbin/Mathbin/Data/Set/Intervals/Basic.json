{"right_mem_Ioo":
 "@[simp]\ntheorem right_mem_Ioo : b ∈ Ioo a b ↔ false := by simp [lt_irrefl]\n#align right_mem_Ioo right_mem_Ioo\n\n",
 "right_mem_Ioc":
 "@[simp]\ntheorem right_mem_Ioc : b ∈ Ioc a b ↔ a < b := by simp [le_refl]\n#align right_mem_Ioc right_mem_Ioc\n\n",
 "right_mem_Iic":
 "theorem right_mem_Iic : a ∈ Iic a := by simp\n#align right_mem_Iic right_mem_Iic\n\n",
 "right_mem_Ico":
 "@[simp]\ntheorem right_mem_Ico : b ∈ Ico a b ↔ false := by simp [lt_irrefl]\n#align right_mem_Ico right_mem_Ico\n\n",
 "right_mem_Icc":
 "@[simp]\ntheorem right_mem_Icc : b ∈ Icc a b ↔ a ≤ b := by simp [le_refl]\n#align right_mem_Icc right_mem_Icc\n\n",
 "not_mem_Ioo_of_le":
 "theorem not_mem_Ioo_of_le (ha : c ≤ a) : c ∉ Ioo a b :=\n  not_mem_subset Ioo_subset_Ioi_self <| not_mem_Ioi.mpr ha\n#align not_mem_Ioo_of_le not_mem_Ioo_of_le\n\n",
 "not_mem_Ioo_of_ge":
 "theorem not_mem_Ioo_of_ge (hb : b ≤ c) : c ∉ Ioo a b :=\n  not_mem_subset Ioo_subset_Iio_self <| not_mem_Iio.mpr hb\n#align not_mem_Ioo_of_ge not_mem_Ioo_of_ge\n\n",
 "not_mem_Ioi_self":
 "@[simp]\ntheorem not_mem_Ioi_self : a ∉ Ioi a :=\n  lt_irrefl _\n#align not_mem_Ioi_self not_mem_Ioi_self\n\n",
 "not_mem_Ioi":
 "theorem not_mem_Ioi : c ∉ Ioi a ↔ c ≤ a :=\n  not_lt\n#align not_mem_Ioi not_mem_Ioi\n\n",
 "not_mem_Ioc_of_le":
 "theorem not_mem_Ioc_of_le (ha : c ≤ a) : c ∉ Ioc a b :=\n  not_mem_subset Ioc_subset_Ioi_self <| not_mem_Ioi.mpr ha\n#align not_mem_Ioc_of_le not_mem_Ioc_of_le\n\n",
 "not_mem_Ioc_of_gt":
 "theorem not_mem_Ioc_of_gt (hb : b < c) : c ∉ Ioc a b :=\n  not_mem_subset Ioc_subset_Iic_self <| not_mem_Iic.mpr hb\n#align not_mem_Ioc_of_gt not_mem_Ioc_of_gt\n\n",
 "not_mem_Iio_self":
 "@[simp]\ntheorem not_mem_Iio_self : b ∉ Iio b :=\n  lt_irrefl _\n#align not_mem_Iio_self not_mem_Iio_self\n\n",
 "not_mem_Iio":
 "theorem not_mem_Iio : c ∉ Iio b ↔ b ≤ c :=\n  not_lt\n#align not_mem_Iio not_mem_Iio\n\n",
 "not_mem_Iic":
 "theorem not_mem_Iic : c ∉ Iic b ↔ b < c :=\n  not_le\n#align not_mem_Iic not_mem_Iic\n\n",
 "not_mem_Ico_of_lt":
 "theorem not_mem_Ico_of_lt (ha : c < a) : c ∉ Ico a b :=\n  not_mem_subset Ico_subset_Ici_self <| not_mem_Ici.mpr ha\n#align not_mem_Ico_of_lt not_mem_Ico_of_lt\n\n",
 "not_mem_Ico_of_ge":
 "theorem not_mem_Ico_of_ge (hb : b ≤ c) : c ∉ Ico a b :=\n  not_mem_subset Ico_subset_Iio_self <| not_mem_Iio.mpr hb\n#align not_mem_Ico_of_ge not_mem_Ico_of_ge\n\n",
 "not_mem_Ici":
 "theorem not_mem_Ici : c ∉ Ici a ↔ c < a :=\n  not_le\n#align not_mem_Ici not_mem_Ici\n\n",
 "not_mem_Icc_of_lt":
 "theorem not_mem_Icc_of_lt (ha : c < a) : c ∉ Icc a b :=\n  not_mem_subset Icc_subset_Ici_self <| not_mem_Ici.mpr ha\n#align not_mem_Icc_of_lt not_mem_Icc_of_lt\n\n",
 "not_mem_Icc_of_gt":
 "theorem not_mem_Icc_of_gt (hb : b < c) : c ∉ Icc a b :=\n  not_mem_subset Icc_subset_Iic_self <| not_mem_Iic.mpr hb\n#align not_mem_Icc_of_gt not_mem_Icc_of_gt\n\n",
 "nonempty_Ioo_subtype":
 "theorem nonempty_Ioo_subtype [DenselyOrdered α] (h : a < b) : nonempty (Ioo a b) :=\n  Nonempty.to_subtype (nonempty_Ioo.mpr h)\n#align nonempty_Ioo_subtype nonempty_Ioo_subtype\n\n",
 "nonempty_Ioo":
 "@[simp]\ntheorem nonempty_Ioo [DenselyOrdered α] : (Ioo a b).nonempty ↔ a < b :=\n  ⟨fun ⟨x, ha, hb⟩ => ha.trans hb, exists_between⟩\n#align nonempty_Ioo nonempty_Ioo\n\n",
 "nonempty_Ioi":
 "@[simp]\ntheorem nonempty_Ioi [NoMaxOrder α] : (Ioi a).nonempty :=\n  exists_gt a\n#align nonempty_Ioi nonempty_Ioi\n\n",
 "nonempty_Ioc_subtype":
 "theorem nonempty_Ioc_subtype (h : a < b) : nonempty (Ioc a b) :=\n  Nonempty.to_subtype (nonempty_Ioc.mpr h)\n#align nonempty_Ioc_subtype nonempty_Ioc_subtype\n\n",
 "nonempty_Ioc":
 "@[simp]\ntheorem nonempty_Ioc : (Ioc a b).nonempty ↔ a < b :=\n  ⟨fun ⟨x, hx⟩ => hx.1.trans_le hx.2, fun h => ⟨b, right_mem_Ioc.2 h⟩⟩\n#align nonempty_Ioc nonempty_Ioc\n\n",
 "nonempty_Iio":
 "@[simp]\ntheorem nonempty_Iio [NoMinOrder α] : (Iio a).nonempty :=\n  exists_lt a\n#align nonempty_Iio nonempty_Iio\n\n",
 "nonempty_Iic":
 "@[simp]\ntheorem nonempty_Iic : (Iic a).nonempty :=\n  ⟨a, right_mem_Iic⟩\n#align nonempty_Iic nonempty_Iic\n\n",
 "nonempty_Ico_subtype":
 "theorem nonempty_Ico_subtype (h : a < b) : nonempty (Ico a b) :=\n  Nonempty.to_subtype (nonempty_Ico.mpr h)\n#align nonempty_Ico_subtype nonempty_Ico_subtype\n\n",
 "nonempty_Ico":
 "@[simp]\ntheorem nonempty_Ico : (Ico a b).nonempty ↔ a < b :=\n  ⟨fun ⟨x, hx⟩ => hx.1.trans_lt hx.2, fun h => ⟨a, left_mem_Ico.2 h⟩⟩\n#align nonempty_Ico nonempty_Ico\n\n",
 "nonempty_Ici":
 "@[simp]\ntheorem nonempty_Ici : (Ici a).nonempty :=\n  ⟨a, left_mem_Ici⟩\n#align nonempty_Ici nonempty_Ici\n\n",
 "nonempty_Icc_subtype":
 "theorem nonempty_Icc_subtype (h : a ≤ b) : nonempty (Icc a b) :=\n  Nonempty.to_subtype (nonempty_Icc.mpr h)\n#align nonempty_Icc_subtype nonempty_Icc_subtype\n\n",
 "nonempty_Icc":
 "@[simp]\ntheorem nonempty_Icc : (Icc a b).nonempty ↔ a ≤ b :=\n  ⟨fun ⟨x, hx⟩ => hx.1.trans hx.2, fun h => ⟨a, left_mem_Icc.2 h⟩⟩\n#align nonempty_Icc nonempty_Icc\n\n",
 "mem_Ioo":
 "@[simp]\ntheorem mem_Ioo : x ∈ Ioo a b ↔ a < x ∧ x < b :=\n  iff.rfl\n#align mem_Ioo mem_Ioo\n\n",
 "mem_Ioi":
 "@[simp]\ntheorem mem_Ioi : x ∈ Ioi a ↔ a < x :=\n  iff.rfl\n#align mem_Ioi mem_Ioi\n\n",
 "mem_Ioc_of_Ioo":
 "theorem mem_Ioc_of_Ioo (h : x ∈ Ioo a b) : x ∈ Ioc a b :=\n  Ioo_subset_Ioc_self h\n#align mem_Ioc_of_Ioo mem_Ioc_of_Ioo\n\n",
 "mem_Ioc":
 "@[simp]\ntheorem mem_Ioc : x ∈ Ioc a b ↔ a < x ∧ x ≤ b :=\n  iff.rfl\n#align mem_Ioc mem_Ioc\n\n",
 "mem_Iio":
 "@[simp]\ntheorem mem_Iio : x ∈ Iio b ↔ x < b :=\n  iff.rfl\n#align mem_Iio mem_Iio\n\n",
 "mem_Iic_of_Iio":
 "theorem mem_Iic_of_Iio (h : x ∈ Iio a) : x ∈ Iic a :=\n  Iio_subset_Iic_self h\n#align mem_Iic_of_Iio mem_Iic_of_Iio\n\n",
 "mem_Iic_Iio_of_subset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem mem_Iic_Iio_of_subset_of_subset {s : set α} (ho : Iio a ⊆ s) (hc : s ⊆ Iic a) :\n    s ∈ ({Iic a, Iio a} : set (set α)) :=\n  @mem_Ici_Ioi_of_subset_of_subset («expr ᵒᵈ» α) _ a s ho hc\n#align mem_Iic_Iio_of_subset_of_subset mem_Iic_Iio_of_subset_of_subset\n\n",
 "mem_Iic":
 "@[simp]\ntheorem mem_Iic : x ∈ Iic b ↔ x ≤ b :=\n  iff.rfl\n#align mem_Iic mem_Iic\n\n",
 "mem_Ico_of_Ioo":
 "theorem mem_Ico_of_Ioo (h : x ∈ Ioo a b) : x ∈ Ico a b :=\n  Ioo_subset_Ico_self h\n#align mem_Ico_of_Ioo mem_Ico_of_Ioo\n\n",
 "mem_Ico":
 "@[simp]\ntheorem mem_Ico : x ∈ Ico a b ↔ a ≤ x ∧ x < b :=\n  iff.rfl\n#align mem_Ico mem_Ico\n\n",
 "mem_Ici_of_Ioi":
 "theorem mem_Ici_of_Ioi (h : x ∈ Ioi a) : x ∈ Ici a :=\n  Ioi_subset_Ici_self h\n#align mem_Ici_of_Ioi mem_Ici_of_Ioi\n\n",
 "mem_Ici_Ioi_of_subset_of_subset":
 "theorem mem_Ici_Ioi_of_subset_of_subset {s : set α} (ho : Ioi a ⊆ s) (hc : s ⊆ Ici a) :\n    s ∈ ({Ici a, Ioi a} : set (set α)) :=\n  by_cases (fun h : a ∈ s => or.inl <| Subset.antisymm hc <| by rw [← Ioi_union_left, union_subset_iff] <;> simp [*])\n    fun h => or.inr <| Subset.antisymm (fun x hx => lt_of_le_of_ne (hc hx) fun heq => h <| HEq.symm ▸ hx) ho\n#align mem_Ici_Ioi_of_subset_of_subset mem_Ici_Ioi_of_subset_of_subset\n\n",
 "mem_Ici":
 "@[simp]\ntheorem mem_Ici : x ∈ Ici a ↔ a ≤ x :=\n  iff.rfl\n#align mem_Ici mem_Ici\n\n",
 "mem_Icc_of_Ioo":
 "theorem mem_Icc_of_Ioo (h : x ∈ Ioo a b) : x ∈ Icc a b :=\n  Ioo_subset_Icc_self h\n#align mem_Icc_of_Ioo mem_Icc_of_Ioo\n\n",
 "mem_Icc_of_Ioc":
 "theorem mem_Icc_of_Ioc (h : x ∈ Ioc a b) : x ∈ Icc a b :=\n  Ioc_subset_Icc_self h\n#align mem_Icc_of_Ioc mem_Icc_of_Ioc\n\n",
 "mem_Icc_of_Ico":
 "theorem mem_Icc_of_Ico (h : x ∈ Ico a b) : x ∈ Icc a b :=\n  Ico_subset_Icc_self h\n#align mem_Icc_of_Ico mem_Icc_of_Ico\n\n",
 "mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr subset_diff_singleton, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error -/\ntheorem mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset {s : set α} (ho : Ioo a b ⊆ s) (hc : s ⊆ Icc a b) :\n    s ∈ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : set (set α)) := by\n  classical\n    by_cases ha : a ∈ s <;> by_cases hb : b ∈ s\n    · refine' or.inl (subset.antisymm hc _)\n      rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ← Icc_diff_right, diff_singleton_subset_iff,\n        insert_eq_of_mem hb] at ho\n    · refine' or.inr <| or.inl <| subset.antisymm _ _\n      · rw [← Icc_diff_right]\n        exact subset_diff_singleton hc hb\n      · rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho\n    · refine' or.inr <| or.inr <| or.inl <| subset.antisymm _ _\n      · rw [← Icc_diff_left]\n        exact subset_diff_singleton hc ha\n      · rwa [← Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    · refine' or.inr <| or.inr <| or.inr <| subset.antisymm _ ho\n      rw [← Ico_diff_left, ← Icc_diff_right]\n      trace\n        \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\\\"[\\\", expr subset_diff_singleton, \\\"]\\\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error\"\n#align mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset\n\n",
 "mem_Icc":
 "@[simp]\ntheorem mem_Icc : x ∈ Icc a b ↔ a ≤ x ∧ x ≤ b :=\n  iff.rfl\n#align mem_Icc mem_Icc\n\n",
 "left_mem_Ioo":
 "@[simp]\ntheorem left_mem_Ioo : a ∈ Ioo a b ↔ false := by simp [lt_irrefl]\n#align left_mem_Ioo left_mem_Ioo\n\n",
 "left_mem_Ioc":
 "@[simp]\ntheorem left_mem_Ioc : a ∈ Ioc a b ↔ false := by simp [lt_irrefl]\n#align left_mem_Ioc left_mem_Ioc\n\n",
 "left_mem_Ico":
 "@[simp]\ntheorem left_mem_Ico : a ∈ Ico a b ↔ a < b := by simp [le_refl]\n#align left_mem_Ico left_mem_Ico\n\n",
 "left_mem_Ici":
 "theorem left_mem_Ici : a ∈ Ici a := by simp\n#align left_mem_Ici left_mem_Ici\n\n",
 "left_mem_Icc":
 "@[simp]\ntheorem left_mem_Icc : a ∈ Icc a b ↔ a ≤ b := by simp [le_refl]\n#align left_mem_Icc left_mem_Icc\n\n",
 "eq_right_or_mem_Ioo_of_mem_Ioc":
 "theorem eq_right_or_mem_Ioo_of_mem_Ioc {x : α} (hmem : x ∈ Ioc a b) : x = b ∨ x ∈ Ioo a b :=\n  hmem.2.eq_or_lt.imp_right <| and.intro hmem.1\n#align eq_right_or_mem_Ioo_of_mem_Ioc eq_right_or_mem_Ioo_of_mem_Ioc\n\n",
 "eq_left_or_mem_Ioo_of_mem_Ico":
 "theorem eq_left_or_mem_Ioo_of_mem_Ico {x : α} (hmem : x ∈ Ico a b) : x = a ∨ x ∈ Ioo a b :=\n  hmem.1.eq_or_gt.imp_right fun h => ⟨h, hmem.2⟩\n#align eq_left_or_mem_Ioo_of_mem_Ico eq_left_or_mem_Ioo_of_mem_Ico\n\n",
 "eq_endpoints_or_mem_Ioo_of_mem_Icc":
 "theorem eq_endpoints_or_mem_Ioo_of_mem_Icc {x : α} (hmem : x ∈ Icc a b) : x = a ∨ x = b ∨ x ∈ Ioo a b :=\n  hmem.1.eq_or_gt.imp_right fun h => eq_right_or_mem_Ioo_of_mem_Ioc ⟨h, hmem.2⟩\n#align eq_endpoints_or_mem_Ioo_of_mem_Icc eq_endpoints_or_mem_Ioo_of_mem_Icc\n\n",
 "dual_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Ioo : Ioo (toDual a) (toDual b) = «expr ⁻¹' » of_dual (Ioo b a) :=\n  Set.ext fun x => and_comm' _ _\n#align dual_Ioo dual_Ioo\n\n",
 "dual_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Ioi : Ioi (toDual a) = «expr ⁻¹' » of_dual (Iio a) :=\n  rfl\n#align dual_Ioi dual_Ioi\n\n",
 "dual_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Ioc : Ioc (toDual a) (toDual b) = «expr ⁻¹' » of_dual (Ico b a) :=\n  Set.ext fun x => and_comm' _ _\n#align dual_Ioc dual_Ioc\n\n",
 "dual_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Iio : Iio (toDual a) = «expr ⁻¹' » of_dual (Ioi a) :=\n  rfl\n#align dual_Iio dual_Iio\n\n",
 "dual_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Iic : Iic (toDual a) = «expr ⁻¹' » of_dual (Ici a) :=\n  rfl\n#align dual_Iic dual_Iic\n\n",
 "dual_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Ico : Ico (toDual a) (toDual b) = «expr ⁻¹' » of_dual (Ioc b a) :=\n  Set.ext fun x => and_comm' _ _\n#align dual_Ico dual_Ico\n\n",
 "dual_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Ici : Ici (toDual a) = «expr ⁻¹' » of_dual (Iic a) :=\n  rfl\n#align dual_Ici dual_Ici\n\n",
 "dual_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem dual_Icc : Icc (toDual a) (toDual b) = «expr ⁻¹' » of_dual (Icc b a) :=\n  Set.ext fun x => and_comm' _ _\n#align dual_Icc dual_Icc\n\n",
 "compl_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_Ioi : «expr ᶜ» (Ioi a) = Iic a :=\n  ext fun _ => not_lt\n#align compl_Ioi compl_Ioi\n\n",
 "compl_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_Iio : «expr ᶜ» (Iio a) = Ici a :=\n  ext fun _ => not_lt\n#align compl_Iio compl_Iio\n\n",
 "compl_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_Iic : «expr ᶜ» (Iic a) = Ioi a :=\n  ext fun _ => not_le\n#align compl_Iic compl_Iic\n\n",
 "compl_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem compl_Ici : «expr ᶜ» (Ici a) = Iio a :=\n  ext fun _ => not_le\n#align compl_Ici compl_Ici\n\n",
 "Ioo_union_right":
 "theorem Ioo_union_right (hab : a < b) : Ioo a b ∪ {b} = Ioc a b := by\n  simpa only [dual_Ioo, dual_Ico] using Ioo_union_left hab.dual\n#align Ioo_union_right Ioo_union_right\n\n",
 "Ioo_union_left":
 "theorem Ioo_union_left (hab : a < b) : Ioo a b ∪ {a} = Ico a b := by\n  rw [← Ico_diff_left, diff_union_self, union_eq_self_of_subset_right (singleton_subset_iff.2 <| left_mem_Ico.2 hab)]\n#align Ioo_union_left Ioo_union_left\n\n",
 "Ioo_union_Ioo'":
 "theorem Ioo_union_Ioo' (h₁ : c < b) (h₂ : a < d) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Ioo, min_lt_iff, lt_max_iff]\n  by_cases hc : c < x <;> by_cases hd : x < d\n  · tauto\n  · have hax : a < x := h₂.trans_le (le_of_not_lt hd)\n    tauto\n  · have hxb : x < b := (le_of_not_lt hc).trans_lt h₁\n    tauto\n  · tauto\n#align Ioo_union_Ioo' Ioo_union_Ioo'\n\n",
 "Ioo_union_Ioo":
 "theorem Ioo_union_Ioo (h₁ : min a b < max c d) (h₂ : min c d < max a b) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d) :=\n  by\n  cases' le_total a b with hab hab <;> cases' le_total c d with hcd hcd <;>\n    simp only [min_eq_left, min_eq_right, max_eq_left, max_eq_right, hab, hcd] at h₁ h₂\n  · exact Ioo_union_Ioo' h₂ h₁\n  all_goals\n    simp [*, min_eq_left_of_lt, min_eq_right_of_lt, max_eq_left_of_lt, max_eq_right_of_lt, le_of_lt h₂, le_of_lt h₁]\n#align Ioo_union_Ioo Ioo_union_Ioo\n\n",
 "Ioo_union_Ioi'":
 "theorem Ioo_union_Ioi' (h₁ : c < b) : Ioo a b ∪ Ioi c = Ioi (min a c) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Ioo, mem_Ioi, min_lt_iff]\n  by_cases hc : c < x\n  · tauto\n  · have hxb : x < b := (le_of_not_gt hc).trans_lt h₁\n    tauto\n#align Ioo_union_Ioi' Ioo_union_Ioi'\n\n",
 "Ioo_union_Ioi":
 "theorem Ioo_union_Ioi (h : c < max a b) : Ioo a b ∪ Ioi c = Ioi (min a c) :=\n  by\n  cases' le_total a b with hab hab <;> simp [hab] at h\n  · exact Ioo_union_Ioi' h\n  · rw [min_comm]\n    simp [*, min_eq_left_of_lt]\n#align Ioo_union_Ioi Ioo_union_Ioi\n\n",
 "Ioo_union_Ico_eq_Ioo":
 "@[simp]\ntheorem Ioo_union_Ico_eq_Ioo (h₁ : a < b) (h₂ : b ≤ c) : Ioo a b ∪ Ico b c = Ioo a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_le h₂⟩) fun hx => ⟨h₁.trans_le hx.1, hx.2⟩)\n    Ioo_subset_Ioo_union_Ico\n#align Ioo_union_Ico_eq_Ioo Ioo_union_Ico_eq_Ioo\n\n",
 "Ioo_union_Ici_eq_Ioi":
 "@[simp]\ntheorem Ioo_union_Ici_eq_Ioi (h : a < b) : Ioo a b ∪ Ici b = Ioi a :=\n  Subset.antisymm (fun x hx => hx.elim And.left h.trans_le) Ioi_subset_Ioo_union_Ici\n#align Ioo_union_Ici_eq_Ioi Ioo_union_Ici_eq_Ioi\n\n",
 "Ioo_union_Icc_eq_Ioc":
 "@[simp]\ntheorem Ioo_union_Icc_eq_Ioc (h₁ : a < b) (h₂ : b ≤ c) : Ioo a b ∪ Icc b c = Ioc a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.le.trans h₂⟩) fun hx => ⟨h₁.trans_le hx.1, hx.2⟩)\n    Ioc_subset_Ioo_union_Icc\n#align Ioo_union_Icc_eq_Ioc Ioo_union_Icc_eq_Ioc\n\n",
 "Ioo_subset_Ioo_union_Ico":
 "theorem Ioo_subset_Ioo_union_Ico : Ioo a c ⊆ Ioo a b ∪ Ico b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Ioo_subset_Ioo_union_Ico Ioo_subset_Ioo_union_Ico\n\n",
 "Ioo_subset_Ioo_right":
 "theorem Ioo_subset_Ioo_right (h : b₁ ≤ b₂) : Ioo a b₁ ⊆ Ioo a b₂ :=\n  Ioo_subset_Ioo le_rfl h\n#align Ioo_subset_Ioo_right Ioo_subset_Ioo_right\n\n",
 "Ioo_subset_Ioo_left":
 "theorem Ioo_subset_Ioo_left (h : a₁ ≤ a₂) : Ioo a₂ b ⊆ Ioo a₁ b :=\n  Ioo_subset_Ioo h le_rfl\n#align Ioo_subset_Ioo_left Ioo_subset_Ioo_left\n\n",
 "Ioo_subset_Ioo_iff":
 "theorem Ioo_subset_Ioo_iff [DenselyOrdered α] (h₁ : a₁ < b₁) : Ioo a₁ b₁ ⊆ Ioo a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h => by\n    rcases exists_between h₁ with ⟨x, xa, xb⟩\n    constructor <;> refine' le_of_not_lt fun h' => _\n    · have ab := (h ⟨xa, xb⟩).1.trans xb\n      exact lt_irrefl _ (h ⟨h', ab⟩).1\n    · have ab := xa.trans (h ⟨xa, xb⟩).2\n      exact lt_irrefl _ (h ⟨ab, h'⟩).2, fun ⟨h₁, h₂⟩ => Ioo_subset_Ioo h₁ h₂⟩\n#align Ioo_subset_Ioo_iff Ioo_subset_Ioo_iff\n\n",
 "Ioo_subset_Ioo":
 "theorem Ioo_subset_Ioo (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Ioo a₁ b₁ ⊆ Ioo a₂ b₂ := fun x ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans_lt hx₁, hx₂.trans_le h₂⟩\n#align Ioo_subset_Ioo Ioo_subset_Ioo\n\n",
 "Ioo_subset_Ioi_self":
 "theorem Ioo_subset_Ioi_self : Ioo a b ⊆ Ioi a := fun x => And.left\n#align Ioo_subset_Ioi_self Ioo_subset_Ioi_self\n\n",
 "Ioo_subset_Ioc_union_Ioo":
 "theorem Ioo_subset_Ioc_union_Ioo : Ioo a c ⊆ Ioc a b ∪ Ioo b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Ioo_subset_Ioc_union_Ioo Ioo_subset_Ioc_union_Ioo\n\n",
 "Ioo_subset_Ioc_union_Ico":
 "theorem Ioo_subset_Ioc_union_Ico : Ioo a c ⊆ Ioc a b ∪ Ico b c :=\n  Subset.trans Ioo_subset_Ioc_union_Ioo (union_subset_union_right _ Ioo_subset_Ico_self)\n#align Ioo_subset_Ioc_union_Ico Ioo_subset_Ioc_union_Ico\n\n",
 "Ioo_subset_Ioc_self":
 "theorem Ioo_subset_Ioc_self : Ioo a b ⊆ Ioc a b := fun x => and.imp_right le_of_lt\n#align Ioo_subset_Ioc_self Ioo_subset_Ioc_self\n\n",
 "Ioo_subset_Iio_self":
 "theorem Ioo_subset_Iio_self : Ioo a b ⊆ Iio b := fun x => And.right\n#align Ioo_subset_Iio_self Ioo_subset_Iio_self\n\n",
 "Ioo_subset_Ico_self":
 "theorem Ioo_subset_Ico_self : Ioo a b ⊆ Ico a b := fun x => and.imp_left le_of_lt\n#align Ioo_subset_Ico_self Ioo_subset_Ico_self\n\n",
 "Ioo_subset_Icc_self":
 "theorem Ioo_subset_Icc_self : Ioo a b ⊆ Icc a b :=\n  Subset.trans Ioo_subset_Ico_self Ico_subset_Icc_self\n#align Ioo_subset_Icc_self Ioo_subset_Icc_self\n\n",
 "Ioo_self":
 "@[simp]\ntheorem Ioo_self (a : α) : Ioo a a = ∅ :=\n  Ioo_eq_empty <| lt_irrefl _\n#align Ioo_self Ioo_self\n\n",
 "Ioo_inter_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem Ioo_inter_Ioo : Ioo a₁ b₁ ∩ Ioo a₂ b₂ = Ioo («expr ⊔ » a₁ a₂) («expr ⊓ » b₁ b₂) := by\n  simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm] <;> ac_rfl\n#align Ioo_inter_Ioo Ioo_inter_Ioo\n\n",
 "Ioo_inter_Ioc_of_right_lt":
 "theorem Ioo_inter_Ioc_of_right_lt (h : b₂ < b₁) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (max a₁ a₂) b₂ := by\n  rw [inter_comm, Ioc_inter_Ioo_of_left_lt h, max_comm]\n#align Ioo_inter_Ioc_of_right_lt Ioo_inter_Ioc_of_right_lt\n\n",
 "Ioo_inter_Ioc_of_left_le":
 "theorem Ioo_inter_Ioc_of_left_le (h : b₁ ≤ b₂) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioo (max a₁ a₂) b₁ := by\n  rw [inter_comm, Ioc_inter_Ioo_of_right_le h, max_comm]\n#align Ioo_inter_Ioc_of_left_le Ioo_inter_Ioc_of_left_le\n\n",
 "Ioo_insert_right":
 "@[simp]\ntheorem Ioo_insert_right (h : a < b) : insert b (Ioo a b) = Ioc a b := by rw [insert_eq, union_comm, Ioo_union_right h]\n#align Ioo_insert_right Ioo_insert_right\n\n",
 "Ioo_insert_left":
 "@[simp]\ntheorem Ioo_insert_left (h : a < b) : insert a (Ioo a b) = Ico a b := by rw [insert_eq, union_comm, Ioo_union_left h]\n#align Ioo_insert_left Ioo_insert_left\n\n",
 "Ioo_eq_empty_of_le":
 "@[simp]\ntheorem Ioo_eq_empty_of_le (h : b ≤ a) : Ioo a b = ∅ :=\n  Ioo_eq_empty h.not_lt\n#align Ioo_eq_empty_of_le Ioo_eq_empty_of_le\n\n",
 "Ioo_eq_empty_iff":
 "theorem Ioo_eq_empty_iff [DenselyOrdered α] : Ioo a b = ∅ ↔ ¬a < b := by\n  rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioo]\n#align Ioo_eq_empty_iff Ioo_eq_empty_iff\n\n",
 "Ioo_eq_empty":
 "@[simp]\ntheorem Ioo_eq_empty (h : ¬a < b) : Ioo a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun x ⟨ha, hb⟩ => h (ha.trans hb)\n#align Ioo_eq_empty Ioo_eq_empty\n\n",
 "Ioo_def":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Patrick Massot, Yury Kudryashov, Rémy Degenne\n-/\ntheorem Ioo_def (a b : α) : { x | a < x ∧ x < b } = Ioo a b :=\n  rfl\n#align Ioo_def Ioo_def\n\n",
 "Ioi_union_left":
 "@[simp]\ntheorem Ioi_union_left : Ioi a ∪ {a} = Ici a :=\n  ext fun x => by simp [eq_comm, le_iff_eq_or_lt]\n#align Ioi_union_left Ioi_union_left\n\n",
 "Ioi_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Ioi_top : Ioi («expr⊤» : α) = ∅ :=\n  isMax_top.Ioi_eq\n#align Ioi_top Ioi_top\n\n",
 "Ioi_subset_Ioo_union_Ici":
 "theorem Ioi_subset_Ioo_union_Ici : Ioi a ⊆ Ioo a b ∪ Ici b := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => or.inl ⟨hx, hxb⟩) fun hxb => or.inr hxb\n#align Ioi_subset_Ioo_union_Ici Ioi_subset_Ioo_union_Ici\n\n",
 "Ioi_subset_Ioi_iff":
 "@[simp]\ntheorem Ioi_subset_Ioi_iff : Ioi b ⊆ Ioi a ↔ a ≤ b :=\n  by\n  refine' ⟨fun h => _, fun h => Ioi_subset_Ioi h⟩\n  by_contra ba\n  exact lt_irrefl _ (h (not_le.mp ba))\n#align Ioi_subset_Ioi_iff Ioi_subset_Ioi_iff\n\n",
 "Ioi_subset_Ioi":
 "/-- If `a ≤ b`, then `(b, +∞) ⊆ (a, +∞)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Ioi_subset_Ioi_iff`. -/\ntheorem Ioi_subset_Ioi (h : a ≤ b) : Ioi b ⊆ Ioi a := fun x hx => h.trans_lt hx\n#align Ioi_subset_Ioi Ioi_subset_Ioi\n\n",
 "Ioi_subset_Ioc_union_Ioi":
 "theorem Ioi_subset_Ioc_union_Ioi : Ioi a ⊆ Ioc a b ∪ Ioi b := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => or.inl ⟨hx, hxb⟩) fun hxb => or.inr hxb\n#align Ioi_subset_Ioc_union_Ioi Ioi_subset_Ioc_union_Ioi\n\n",
 "Ioi_subset_Ioc_union_Ici":
 "theorem Ioi_subset_Ioc_union_Ici : Ioi a ⊆ Ioc a b ∪ Ici b :=\n  Subset.trans Ioi_subset_Ioo_union_Ici (union_subset_union_left _ Ioo_subset_Ioc_self)\n#align Ioi_subset_Ioc_union_Ici Ioi_subset_Ioc_union_Ici\n\n",
 "Ioi_subset_Ici_self":
 "theorem Ioi_subset_Ici_self : Ioi a ⊆ Ici a := fun x hx => le_of_lt hx\n#align Ioi_subset_Ici_self Ioi_subset_Ici_self\n\n",
 "Ioi_subset_Ici_iff":
 "@[simp]\ntheorem Ioi_subset_Ici_iff [DenselyOrdered α] : Ioi b ⊆ Ici a ↔ a ≤ b :=\n  by\n  refine' ⟨fun h => _, fun h => Ioi_subset_Ici h⟩\n  by_contra ba\n  obtain ⟨c, bc, ca⟩ : ∃ c, b < c ∧ c < a := exists_between (not_le.mp ba)\n  exact lt_irrefl _ (ca.trans_le (h bc))\n#align Ioi_subset_Ici_iff Ioi_subset_Ici_iff\n\n",
 "Ioi_subset_Ici":
 "/-- If `a ≤ b`, then `(b, +∞) ⊆ [a, +∞)`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Ioi_subset_Ici_iff`. -/\ntheorem Ioi_subset_Ici (h : a ≤ b) : Ioi b ⊆ Ici a :=\n  Subset.trans (Ioi_subset_Ioi h) Ioi_subset_Ici_self\n#align Ioi_subset_Ici Ioi_subset_Ici\n\n",
 "Ioi_ssubset_Ici_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem Ioi_ssubset_Ici_self : «expr ⊂ » (Ioi a) (Ici a) :=\n  ⟨Ioi_subset_Ici_self, fun h => lt_irrefl a (h le_rfl)⟩\n#align Ioi_ssubset_Ici_self Ioi_ssubset_Ici_self\n\n",
 "Ioi_inter_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem Ioi_inter_Ioi : Ioi a ∩ Ioi b = Ioi («expr ⊔ » a b) :=\n  ext fun _ => sup_lt_iff.symm\n#align Ioi_inter_Ioi Ioi_inter_Ioi\n\n",
 "Ioi_inter_Iio":
 "theorem Ioi_inter_Iio : Ioi a ∩ Iio b = Ioo a b :=\n  rfl\n#align Ioi_inter_Iio Ioi_inter_Iio\n\n",
 "Ioi_inter_Iic":
 "theorem Ioi_inter_Iic : Ioi a ∩ Iic b = Ioc a b :=\n  rfl\n#align Ioi_inter_Iic Ioi_inter_Iic\n\n",
 "Ioi_insert":
 "@[simp]\ntheorem Ioi_insert : insert a (Ioi a) = Ici a :=\n  ext fun _ => (or_congr_left eq_comm).trans le_iff_eq_or_lt.symm\n#align Ioi_insert Ioi_insert\n\n",
 "Ioi_injective":
 "theorem Ioi_injective : injective (Ioi : α → set α) := fun a b => eq_of_forall_gt_iff ∘ Set.ext_iff.1\n#align Ioi_injective Ioi_injective\n\n",
 "Ioi_inj":
 "theorem Ioi_inj : Ioi a = Ioi b ↔ a = b :=\n  Ioi_injective.eq_iff\n#align Ioi_inj Ioi_inj\n\n",
 "Ioi_eq":
 "#print IsMax.Ioi_eq /-\ntheorem IsMax.Ioi_eq (h : is_max a) : Ioi a = ∅ :=\n  eq_empty_of_subset_empty fun b => h.not_lt\n#align is_max.Ioi_eq IsMax.Ioi_eq\n-/\n\n",
 "Ioi_diff_Ioi":
 "@[simp]\ntheorem Ioi_diff_Ioi : Ioi a \\ Ioi b = Ioc a b := by rw [diff_eq, compl_Ioi, Ioi_inter_Iic]\n#align Ioi_diff_Ioi Ioi_diff_Ioi\n\n",
 "Ioi_diff_Ici":
 "@[simp]\ntheorem Ioi_diff_Ici : Ioi a \\ Ici b = Ioo a b := by rw [diff_eq, compl_Ici, Ioi_inter_Iio]\n#align Ioi_diff_Ici Ioi_diff_Ici\n\n",
 "Ioi_def":
 "theorem Ioi_def (a : α) : { x | a < x } = Ioi a :=\n  rfl\n#align Ioi_def Ioi_def\n\n",
 "Ioc_union_left":
 "theorem Ioc_union_left (hab : a ≤ b) : Ioc a b ∪ {a} = Icc a b := by\n  rw [← Icc_diff_left, diff_union_self, union_eq_self_of_subset_right (singleton_subset_iff.2 <| left_mem_Icc.2 hab)]\n#align Ioc_union_left Ioc_union_left\n\n",
 "Ioc_union_Ioo_eq_Ioo":
 "@[simp]\ntheorem Ioc_union_Ioo_eq_Ioo (h₁ : a ≤ b) (h₂ : b < c) : Ioc a b ∪ Ioo b c = Ioo a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_lt h₂⟩) fun hx => ⟨h₁.trans_lt hx.1, hx.2⟩)\n    Ioo_subset_Ioc_union_Ioo\n#align Ioc_union_Ioo_eq_Ioo Ioc_union_Ioo_eq_Ioo\n\n",
 "Ioc_union_Ioi_eq_Ioi":
 "@[simp]\ntheorem Ioc_union_Ioi_eq_Ioi (h : a ≤ b) : Ioc a b ∪ Ioi b = Ioi a :=\n  Subset.antisymm (fun x hx => hx.elim And.left h.trans_lt) Ioi_subset_Ioc_union_Ioi\n#align Ioc_union_Ioi_eq_Ioi Ioc_union_Ioi_eq_Ioi\n\n",
 "Ioc_union_Ioi'":
 "theorem Ioc_union_Ioi' (h₁ : c ≤ b) : Ioc a b ∪ Ioi c = Ioi (min a c) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Ioc, mem_Ioi, min_lt_iff]\n  by_cases hc : c < x\n  · tauto\n  · have hxb : x ≤ b := (le_of_not_gt hc).trans h₁\n    tauto\n#align Ioc_union_Ioi' Ioc_union_Ioi'\n\n",
 "Ioc_union_Ioi":
 "theorem Ioc_union_Ioi (h : c ≤ max a b) : Ioc a b ∪ Ioi c = Ioi (min a c) :=\n  by\n  cases' le_total a b with hab hab <;> simp [hab] at h\n  · exact Ioc_union_Ioi' h\n  · simp [*]\n#align Ioc_union_Ioi Ioc_union_Ioi\n\n",
 "Ioc_union_Ioc_union_Ioc_cycle":
 "@[simp]\ntheorem Ioc_union_Ioc_union_Ioc_cycle : Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc (min a (min b c)) (max a (max b c)) :=\n  by\n  rw [Ioc_union_Ioc, Ioc_union_Ioc]\n  ac_rfl\n  all_goals\n    solve_by_elim (config := { max_depth := 5 }) [min_le_of_left_le, min_le_of_right_le, le_max_of_le_left,\n      le_max_of_le_right, le_refl]\n#align Ioc_union_Ioc_union_Ioc_cycle Ioc_union_Ioc_union_Ioc_cycle\n\n",
 "Ioc_union_Ioc_symm":
 "@[simp]\ntheorem Ioc_union_Ioc_symm : Ioc a b ∪ Ioc b a = Ioc (min a b) (max a b) :=\n  by\n  rw [max_comm]\n  apply Ioc_union_Ioc <;> rw [max_comm] <;> exact min_le_max\n#align Ioc_union_Ioc_symm Ioc_union_Ioc_symm\n\n",
 "Ioc_union_Ioc_right":
 "@[simp]\ntheorem Ioc_union_Ioc_right : Ioc a b ∪ Ioc a c = Ioc a (max b c) := by\n  rw [Ioc_union_Ioc, min_self] <;> exact (min_le_left _ _).trans (le_max_left _ _)\n#align Ioc_union_Ioc_right Ioc_union_Ioc_right\n\n",
 "Ioc_union_Ioc_left":
 "@[simp]\ntheorem Ioc_union_Ioc_left : Ioc a c ∪ Ioc b c = Ioc (min a b) c := by\n  rw [Ioc_union_Ioc, max_self] <;> exact (min_le_right _ _).trans (le_max_right _ _)\n#align Ioc_union_Ioc_left Ioc_union_Ioc_left\n\n",
 "Ioc_union_Ioc_eq_Ioc":
 "@[simp]\ntheorem Ioc_union_Ioc_eq_Ioc (h₁ : a ≤ b) (h₂ : b ≤ c) : Ioc a b ∪ Ioc b c = Ioc a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans_lt hx.1, hx.2⟩)\n    Ioc_subset_Ioc_union_Ioc\n#align Ioc_union_Ioc_eq_Ioc Ioc_union_Ioc_eq_Ioc\n\n",
 "Ioc_union_Ioc'":
 "theorem Ioc_union_Ioc' (h₁ : c ≤ b) (h₂ : a ≤ d) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Ioc, min_lt_iff, le_max_iff]\n  by_cases hc : c < x <;> by_cases hd : x ≤ d\n  · tauto\n  · have hax : a < x := h₂.trans_lt (lt_of_not_ge hd)\n    tauto\n  · have hxb : x ≤ b := (le_of_not_gt hc).trans h₁\n    tauto\n  · tauto\n#align Ioc_union_Ioc' Ioc_union_Ioc'\n\n",
 "Ioc_union_Ioc":
 "theorem Ioc_union_Ioc (h₁ : min a b ≤ max c d) (h₂ : min c d ≤ max a b) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d) :=\n  by\n  cases' le_total a b with hab hab <;> cases' le_total c d with hcd hcd <;> simp [hab, hcd] at h₁ h₂\n  · exact Ioc_union_Ioc' h₂ h₁\n  all_goals simp [*]\n#align Ioc_union_Ioc Ioc_union_Ioc\n\n",
 "Ioc_union_Ico_eq_Ioo":
 "@[simp]\ntheorem Ioc_union_Ico_eq_Ioo (h₁ : a < b) (h₂ : b < c) : Ioc a b ∪ Ico b c = Ioo a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx' => ⟨hx'.1, hx'.2.trans_lt h₂⟩) fun hx' => ⟨h₁.trans_le hx'.1, hx'.2⟩)\n    Ioo_subset_Ioc_union_Ico\n#align Ioc_union_Ico_eq_Ioo Ioc_union_Ico_eq_Ioo\n\n",
 "Ioc_union_Ici_eq_Ioi":
 "@[simp]\ntheorem Ioc_union_Ici_eq_Ioi (h : a < b) : Ioc a b ∪ Ici b = Ioi a :=\n  Subset.antisymm (fun x hx => hx.elim And.left h.trans_le) Ioi_subset_Ioc_union_Ici\n#align Ioc_union_Ici_eq_Ioi Ioc_union_Ici_eq_Ioi\n\n",
 "Ioc_union_Icc_eq_Ioc":
 "@[simp]\ntheorem Ioc_union_Icc_eq_Ioc (h₁ : a < b) (h₂ : b ≤ c) : Ioc a b ∪ Icc b c = Ioc a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans_le hx.1, hx.2⟩)\n    Ioc_subset_Ioc_union_Icc\n#align Ioc_union_Icc_eq_Ioc Ioc_union_Icc_eq_Ioc\n\n",
 "Ioc_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Ioc_top : Ioc a («expr⊤») = Ioi a := by simp [← Ioi_inter_Iic]\n#align Ioc_top Ioc_top\n\n",
 "Ioc_subset_Ioo_union_Icc":
 "theorem Ioc_subset_Ioo_union_Icc : Ioc a c ⊆ Ioo a b ∪ Icc b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Ioc_subset_Ioo_union_Icc Ioc_subset_Ioo_union_Icc\n\n",
 "Ioc_subset_Ioo_right":
 "theorem Ioc_subset_Ioo_right (h : b₁ < b₂) : Ioc a b₁ ⊆ Ioo a b₂ := fun x => and.imp_right fun h' => h'.trans_lt h\n#align Ioc_subset_Ioo_right Ioc_subset_Ioo_right\n\n",
 "Ioc_subset_Ioi_self":
 "theorem Ioc_subset_Ioi_self : Ioc a b ⊆ Ioi a := fun x => And.left\n#align Ioc_subset_Ioi_self Ioc_subset_Ioi_self\n\n",
 "Ioc_subset_Ioc_union_Ioc":
 "theorem Ioc_subset_Ioc_union_Ioc : Ioc a c ⊆ Ioc a b ∪ Ioc b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Ioc_subset_Ioc_union_Ioc Ioc_subset_Ioc_union_Ioc\n\n",
 "Ioc_subset_Ioc_union_Icc":
 "theorem Ioc_subset_Ioc_union_Icc : Ioc a c ⊆ Ioc a b ∪ Icc b c :=\n  Subset.trans Ioc_subset_Ioc_union_Ioc (union_subset_union_right _ Ioc_subset_Icc_self)\n#align Ioc_subset_Ioc_union_Icc Ioc_subset_Ioc_union_Icc\n\n",
 "Ioc_subset_Ioc_right":
 "theorem Ioc_subset_Ioc_right (h : b₁ ≤ b₂) : Ioc a b₁ ⊆ Ioc a b₂ :=\n  Ioc_subset_Ioc le_rfl h\n#align Ioc_subset_Ioc_right Ioc_subset_Ioc_right\n\n",
 "Ioc_subset_Ioc_left":
 "theorem Ioc_subset_Ioc_left (h : a₁ ≤ a₂) : Ioc a₂ b ⊆ Ioc a₁ b :=\n  Ioc_subset_Ioc h le_rfl\n#align Ioc_subset_Ioc_left Ioc_subset_Ioc_left\n\n",
 "Ioc_subset_Ioc_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem Ioc_subset_Ioc_iff (h₁ : a₁ < b₁) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ b₁ ≤ b₂ ∧ a₂ ≤ a₁ := by\n  convert @Ico_subset_Ico_iff («expr ᵒᵈ» α) _ b₁ b₂ a₁ a₂ h₁ <;> exact (@dual_Ico α _ _ _).symm\n#align Ioc_subset_Ioc_iff Ioc_subset_Ioc_iff\n\n",
 "Ioc_subset_Ioc":
 "theorem Ioc_subset_Ioc (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ := fun x ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans_lt hx₁, hx₂.trans h₂⟩\n#align Ioc_subset_Ioc Ioc_subset_Ioc\n\n",
 "Ioc_subset_Iic_self":
 "theorem Ioc_subset_Iic_self : Ioc a b ⊆ Iic b := fun x => And.right\n#align Ioc_subset_Iic_self Ioc_subset_Iic_self\n\n",
 "Ioc_subset_Icc_self":
 "theorem Ioc_subset_Icc_self : Ioc a b ⊆ Icc a b := fun x => and.imp_left le_of_lt\n#align Ioc_subset_Icc_self Ioc_subset_Icc_self\n\n",
 "Ioc_self":
 "@[simp]\ntheorem Ioc_self (a : α) : Ioc a a = ∅ :=\n  Ioc_eq_empty <| lt_irrefl _\n#align Ioc_self Ioc_self\n\n",
 "Ioc_inter_Ioo_of_right_le":
 "theorem Ioc_inter_Ioo_of_right_le (h : b₂ ≤ b₁) : Ioc a₁ b₁ ∩ Ioo a₂ b₂ = Ioo (max a₁ a₂) b₂ :=\n  ext fun x => by simp [and_assoc', @and_left_comm (x ≤ _), and_iff_right_iff_imp.2 fun h' => (le_of_lt h').trans h]\n#align Ioc_inter_Ioo_of_right_le Ioc_inter_Ioo_of_right_le\n\n",
 "Ioc_inter_Ioo_of_left_lt":
 "theorem Ioc_inter_Ioo_of_left_lt (h : b₁ < b₂) : Ioc a₁ b₁ ∩ Ioo a₂ b₂ = Ioc (max a₁ a₂) b₁ :=\n  ext fun x => by simp [and_assoc', @and_left_comm (x ≤ _), and_iff_left_iff_imp.2 fun h' => lt_of_le_of_lt h' h]\n#align Ioc_inter_Ioo_of_left_lt Ioc_inter_Ioo_of_left_lt\n\n",
 "Ioc_inter_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem Ioc_inter_Ioi : Ioc a b ∩ Ioi c = Ioc («expr ⊔ » a c) b := by\n  rw [← Ioi_inter_Iic, inter_assoc, inter_comm, inter_assoc, Ioi_inter_Ioi, inter_comm, Ioi_inter_Iic, sup_comm]\n#align Ioc_inter_Ioi Ioc_inter_Ioi\n\n",
 "Ioc_inter_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem Ioc_inter_Ioc : Ioc a₁ b₁ ∩ Ioc a₂ b₂ = Ioc («expr ⊔ » a₁ a₂) («expr ⊓ » b₁ b₂) := by\n  simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm] <;> ac_rfl\n#align Ioc_inter_Ioc Ioc_inter_Ioc\n\n",
 "Ioc_inter_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem Ioc_inter_Iic (a b c : α) : Ioc a b ∩ Iic c = Ioc a («expr ⊓ » b c) := by\n  rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_assoc, Iic_inter_Iic]\n#align Ioc_inter_Iic Ioc_inter_Iic\n\n",
 "Ioc_insert_left":
 "@[simp]\ntheorem Ioc_insert_left (h : a ≤ b) : insert a (Ioc a b) = Icc a b := by rw [insert_eq, union_comm, Ioc_union_left h]\n#align Ioc_insert_left Ioc_insert_left\n\n",
 "Ioc_eq_empty_of_le":
 "@[simp]\ntheorem Ioc_eq_empty_of_le (h : b ≤ a) : Ioc a b = ∅ :=\n  Ioc_eq_empty h.not_lt\n#align Ioc_eq_empty_of_le Ioc_eq_empty_of_le\n\n",
 "Ioc_eq_empty_iff":
 "theorem Ioc_eq_empty_iff : Ioc a b = ∅ ↔ ¬a < b := by rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioc]\n#align Ioc_eq_empty_iff Ioc_eq_empty_iff\n\n",
 "Ioc_eq_empty":
 "@[simp]\ntheorem Ioc_eq_empty (h : ¬a < b) : Ioc a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun x ⟨ha, hb⟩ => h (ha.trans_le hb)\n#align Ioc_eq_empty Ioc_eq_empty\n\n",
 "Ioc_diff_right":
 "@[simp]\ntheorem Ioc_diff_right : Ioc a b \\ {b} = Ioo a b :=\n  ext fun x => by simp [and_assoc', ← lt_iff_le_and_ne]\n#align Ioc_diff_right Ioc_diff_right\n\n",
 "Ioc_diff_Ioo_same":
 "@[simp]\ntheorem Ioc_diff_Ioo_same (h : a < b) : Ioc a b \\ Ioo a b = {b} := by\n  rw [← Ioc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Ioc.2 h)]\n#align Ioc_diff_Ioo_same Ioc_diff_Ioo_same\n\n",
 "Ioc_diff_Ioi":
 "@[simp]\ntheorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=\n  ext <| by simp (config := { contextual := true }) [iff_def]\n#align Ioc_diff_Ioi Ioc_diff_Ioi\n\n",
 "Ioc_diff_Iic":
 "@[simp]\ntheorem Ioc_diff_Iic : Ioc a b \\ Iic c = Ioc (max a c) b := by rw [diff_eq, compl_Iic, Ioc_inter_Ioi, sup_eq_max]\n#align Ioc_diff_Iic Ioc_diff_Iic\n\n",
 "Ioc_def":
 "theorem Ioc_def (a b : α) : { x | a < x ∧ x ≤ b } = Ioc a b :=\n  rfl\n#align Ioc_def Ioc_def\n\n",
 "Iio_union_right":
 "@[simp]\ntheorem Iio_union_right : Iio a ∪ {a} = Iic a :=\n  ext fun x => le_iff_lt_or_eq.symm\n#align Iio_union_right Iio_union_right\n\n",
 "Iio_union_Ioo'":
 "theorem Iio_union_Ioo' (h₁ : c < b) : Iio b ∪ Ioo c d = Iio (max b d) :=\n  by\n  ext x\n  cases' lt_or_le x b with hba hba\n  · simp [hba, h₁]\n  · simp only [mem_Iio, mem_union, mem_Ioo, lt_max_iff]\n    refine' or_congr iff.rfl ⟨And.right, _⟩\n    exact fun h₂ => ⟨h₁.trans_le hba, h₂⟩\n#align Iio_union_Ioo' Iio_union_Ioo'\n\n",
 "Iio_union_Ioo":
 "theorem Iio_union_Ioo (h : min c d < b) : Iio b ∪ Ioo c d = Iio (max b d) :=\n  by\n  cases' le_total c d with hcd hcd <;> simp [hcd] at h\n  · exact Iio_union_Ioo' h\n  · rw [max_comm]\n    simp [*, max_eq_right_of_lt h]\n#align Iio_union_Ioo Iio_union_Ioo\n\n",
 "Iio_union_Ioi_of_lt":
 "theorem Iio_union_Ioi_of_lt (h : a < b) : Iio b ∪ Ioi a = univ :=\n  eq_univ_of_forall fun x => (h.lt_or_lt x).symm\n#align Iio_union_Ioi_of_lt Iio_union_Ioi_of_lt\n\n",
 "Iio_union_Ioi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem Iio_union_Ioi : Iio a ∪ Ioi a = «expr ᶜ» {a} :=\n  ext fun x => lt_or_lt_iff_ne\n#align Iio_union_Ioi Iio_union_Ioi\n\n",
 "Iio_union_Ico_eq_Iio":
 "@[simp]\ntheorem Iio_union_Ico_eq_Iio (h : a ≤ b) : Iio a ∪ Ico a b = Iio b :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx' => lt_of_lt_of_le hx' h) And.right) Iio_subset_Iio_union_Ico\n#align Iio_union_Ico_eq_Iio Iio_union_Ico_eq_Iio\n\n",
 "Iio_union_Ico'":
 "theorem Iio_union_Ico' (h₁ : c ≤ b) : Iio b ∪ Ico c d = Iio (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Iio, mem_Ico, lt_max_iff]\n  by_cases hc : c ≤ x\n  · tauto\n  · have hxb : x < b := (lt_of_not_ge hc).trans_le h₁\n    tauto\n#align Iio_union_Ico' Iio_union_Ico'\n\n",
 "Iio_union_Ico":
 "theorem Iio_union_Ico (h : min c d ≤ b) : Iio b ∪ Ico c d = Iio (max b d) :=\n  by\n  cases' le_total c d with hcd hcd <;> simp [hcd] at h\n  · exact Iio_union_Ico' h\n  · simp [*]\n#align Iio_union_Ico Iio_union_Ico\n\n",
 "Iio_union_Ici_of_le":
 "theorem Iio_union_Ici_of_le (h : a ≤ b) : Iio b ∪ Ici a = univ :=\n  eq_univ_of_forall fun x => (h.le_or_lt x).symm\n#align Iio_union_Ici_of_le Iio_union_Ici_of_le\n\n",
 "Iio_union_Ici":
 "@[simp]\ntheorem Iio_union_Ici : Iio a ∪ Ici a = univ :=\n  Iio_union_Ici_of_le le_rfl\n#align Iio_union_Ici Iio_union_Ici\n\n",
 "Iio_union_Icc_eq_Iic":
 "@[simp]\ntheorem Iio_union_Icc_eq_Iic (h : a ≤ b) : Iio a ∪ Icc a b = Iic b :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => (le_of_lt hx).trans h) And.right) Iic_subset_Iio_union_Icc\n#align Iio_union_Icc_eq_Iic Iio_union_Icc_eq_Iic\n\n",
 "Iio_subset_Iio_union_Ico":
 "theorem Iio_subset_Iio_union_Ico : Iio b ⊆ Iio a ∪ Ico a b := fun x hx =>\n  (lt_or_le x a).elim (fun hxa => or.inl hxa) fun hxa => or.inr ⟨hxa, hx⟩\n#align Iio_subset_Iio_union_Ico Iio_subset_Iio_union_Ico\n\n",
 "Iio_subset_Iio_iff":
 "@[simp]\ntheorem Iio_subset_Iio_iff : Iio a ⊆ Iio b ↔ a ≤ b :=\n  by\n  refine' ⟨fun h => _, fun h => Iio_subset_Iio h⟩\n  by_contra ab\n  exact lt_irrefl _ (h (not_le.mp ab))\n#align Iio_subset_Iio_iff Iio_subset_Iio_iff\n\n",
 "Iio_subset_Iio":
 "/-- If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Iio_subset_Iio_iff`. -/\ntheorem Iio_subset_Iio (h : a ≤ b) : Iio a ⊆ Iio b := fun x hx => lt_of_lt_of_le hx h\n#align Iio_subset_Iio Iio_subset_Iio\n\n",
 "Iio_subset_Iic_union_Ioo":
 "theorem Iio_subset_Iic_union_Ioo : Iio b ⊆ Iic a ∪ Ioo a b := fun x hx =>\n  (le_or_lt x a).elim (fun hxa => or.inl hxa) fun hxa => or.inr ⟨hxa, hx⟩\n#align Iio_subset_Iic_union_Ioo Iio_subset_Iic_union_Ioo\n\n",
 "Iio_subset_Iic_union_Ico":
 "theorem Iio_subset_Iic_union_Ico : Iio b ⊆ Iic a ∪ Ico a b :=\n  Subset.trans Iio_subset_Iic_union_Ioo (union_subset_union_right _ Ioo_subset_Ico_self)\n#align Iio_subset_Iic_union_Ico Iio_subset_Iic_union_Ico\n\n",
 "Iio_subset_Iic_self":
 "theorem Iio_subset_Iic_self : Iio a ⊆ Iic a := fun x hx => le_of_lt hx\n#align Iio_subset_Iic_self Iio_subset_Iic_self\n\n",
 "Iio_subset_Iic_iff":
 "@[simp]\ntheorem Iio_subset_Iic_iff [DenselyOrdered α] : Iio a ⊆ Iic b ↔ a ≤ b := by\n  rw [← diff_eq_empty, Iio_diff_Iic, Ioo_eq_empty_iff, not_lt]\n#align Iio_subset_Iic_iff Iio_subset_Iic_iff\n\n",
 "Iio_subset_Iic":
 "/-- If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b]`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Iio_subset_Iic_iff`. -/\ntheorem Iio_subset_Iic (h : a ≤ b) : Iio a ⊆ Iic b :=\n  Subset.trans (Iio_subset_Iio h) Iio_subset_Iic_self\n#align Iio_subset_Iic Iio_subset_Iic\n\n",
 "Iio_ssubset_Iic_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem Iio_ssubset_Iic_self : «expr ⊂ » (Iio a) (Iic a) :=\n  @Ioi_ssubset_Ici_self («expr ᵒᵈ» α) _ _\n#align Iio_ssubset_Iic_self Iio_ssubset_Iic_self\n\n",
 "Iio_inter_Ioi":
 "theorem Iio_inter_Ioi : Iio a ∩ Ioi b = Ioo b a :=\n  inter_comm _ _\n#align Iio_inter_Ioi Iio_inter_Ioi\n\n",
 "Iio_inter_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem Iio_inter_Iio : Iio a ∩ Iio b = Iio («expr ⊓ » a b) :=\n  ext fun _ => lt_inf_iff.symm\n#align Iio_inter_Iio Iio_inter_Iio\n\n",
 "Iio_inter_Ici":
 "theorem Iio_inter_Ici : Iio a ∩ Ici b = Ico b a :=\n  inter_comm _ _\n#align Iio_inter_Ici Iio_inter_Ici\n\n",
 "Iio_insert":
 "@[simp]\ntheorem Iio_insert : insert a (Iio a) = Iic a :=\n  ext fun _ => le_iff_eq_or_lt.symm\n#align Iio_insert Iio_insert\n\n",
 "Iio_injective":
 "theorem Iio_injective : injective (Iio : α → set α) := fun a b => eq_of_forall_lt_iff ∘ Set.ext_iff.1\n#align Iio_injective Iio_injective\n\n",
 "Iio_inj":
 "theorem Iio_inj : Iio a = Iio b ↔ a = b :=\n  Iio_injective.eq_iff\n#align Iio_inj Iio_inj\n\n",
 "Iio_eq":
 "#print IsMin.Iio_eq /-\ntheorem IsMin.Iio_eq (h : is_min a) : Iio a = ∅ :=\n  eq_empty_of_subset_empty fun b => h.not_lt\n#align is_min.Iio_eq IsMin.Iio_eq\n-/\n\n",
 "Iio_diff_Iio":
 "@[simp]\ntheorem Iio_diff_Iio : Iio b \\ Iio a = Ico a b := by rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iio]\n#align Iio_diff_Iio Iio_diff_Iio\n\n",
 "Iio_diff_Iic":
 "@[simp]\ntheorem Iio_diff_Iic : Iio b \\ Iic a = Ioo a b := by rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iio]\n#align Iio_diff_Iic Iio_diff_Iic\n\n",
 "Iio_def":
 "theorem Iio_def (a : α) : { x | x < a } = Iio a :=\n  rfl\n#align Iio_def Iio_def\n\n",
 "Iio_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Iio_bot : Iio («expr⊥» : α) = ∅ :=\n  isMin_bot.Iio_eq\n#align Iio_bot Iio_bot\n\n",
 "Iic_union_Ioo_eq_Iio":
 "@[simp]\ntheorem Iic_union_Ioo_eq_Iio (h : a < b) : Iic a ∪ Ioo a b = Iio b :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx' => lt_of_le_of_lt hx' h) And.right) Iio_subset_Iic_union_Ioo\n#align Iic_union_Ioo_eq_Iio Iic_union_Ioo_eq_Iio\n\n",
 "Iic_union_Ioi_of_le":
 "theorem Iic_union_Ioi_of_le (h : a ≤ b) : Iic b ∪ Ioi a = univ :=\n  eq_univ_of_forall fun x => (h.lt_or_le x).symm\n#align Iic_union_Ioi_of_le Iic_union_Ioi_of_le\n\n",
 "Iic_union_Ioi":
 "@[simp]\ntheorem Iic_union_Ioi : Iic a ∪ Ioi a = univ :=\n  Iic_union_Ioi_of_le le_rfl\n#align Iic_union_Ioi Iic_union_Ioi\n\n",
 "Iic_union_Ioc_eq_Iic":
 "@[simp]\ntheorem Iic_union_Ioc_eq_Iic (h : a ≤ b) : Iic a ∪ Ioc a b = Iic b :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx' => le_trans hx' h) And.right) Iic_subset_Iic_union_Ioc\n#align Iic_union_Ioc_eq_Iic Iic_union_Ioc_eq_Iic\n\n",
 "Iic_union_Ioc'":
 "theorem Iic_union_Ioc' (h₁ : c < b) : Iic b ∪ Ioc c d = Iic (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Iic, mem_Ioc, le_max_iff]\n  by_cases hc : c < x\n  · tauto\n  · have hxb : x ≤ b := (le_of_not_gt hc).trans h₁.le\n    tauto\n#align Iic_union_Ioc' Iic_union_Ioc'\n\n",
 "Iic_union_Ioc":
 "theorem Iic_union_Ioc (h : min c d < b) : Iic b ∪ Ioc c d = Iic (max b d) :=\n  by\n  cases' le_total c d with hcd hcd <;> simp [hcd] at h\n  · exact Iic_union_Ioc' h\n  · rw [max_comm]\n    simp [*, max_eq_right_of_lt h]\n#align Iic_union_Ioc Iic_union_Ioc\n\n",
 "Iic_union_Ico_eq_Iio":
 "@[simp]\ntheorem Iic_union_Ico_eq_Iio (h : a < b) : Iic a ∪ Ico a b = Iio b :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx' => lt_of_le_of_lt hx' h) And.right) Iio_subset_Iic_union_Ico\n#align Iic_union_Ico_eq_Iio Iic_union_Ico_eq_Iio\n\n",
 "Iic_union_Ici_of_le":
 "theorem Iic_union_Ici_of_le (h : a ≤ b) : Iic b ∪ Ici a = univ :=\n  eq_univ_of_forall fun x => (h.le_or_le x).symm\n#align Iic_union_Ici_of_le Iic_union_Ici_of_le\n\n",
 "Iic_union_Ici":
 "@[simp]\ntheorem Iic_union_Ici : Iic a ∪ Ici a = univ :=\n  Iic_union_Ici_of_le le_rfl\n#align Iic_union_Ici Iic_union_Ici\n\n",
 "Iic_union_Icc_eq_Iic":
 "@[simp]\ntheorem Iic_union_Icc_eq_Iic (h : a ≤ b) : Iic a ∪ Icc a b = Iic b :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx' => le_trans hx' h) And.right) Iic_subset_Iic_union_Icc\n#align Iic_union_Icc_eq_Iic Iic_union_Icc_eq_Iic\n\n",
 "Iic_union_Icc'":
 "theorem Iic_union_Icc' (h₁ : c ≤ b) : Iic b ∪ Icc c d = Iic (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Iic, mem_Icc, le_max_iff]\n  by_cases hc : c ≤ x\n  · tauto\n  · have hxb : x ≤ b := (le_of_not_ge hc).trans h₁\n    tauto\n#align Iic_union_Icc' Iic_union_Icc'\n\n",
 "Iic_union_Icc":
 "theorem Iic_union_Icc (h : min c d ≤ b) : Iic b ∪ Icc c d = Iic (max b d) :=\n  by\n  cases' le_or_lt c d with hcd hcd <;> simp [hcd] at h\n  · exact Iic_union_Icc' h\n  · cases h\n    · have hdb : d ≤ b := hcd.le.trans h\n      simp [*]\n    · simp [*]\n#align Iic_union_Icc Iic_union_Icc\n\n",
 "Iic_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Iic_top : Iic («expr⊤» : α) = univ :=\n  isTop_top.Iic_eq\n#align Iic_top Iic_top\n\n",
 "Iic_subset_Iio_union_Icc":
 "theorem Iic_subset_Iio_union_Icc : Iic b ⊆ Iio a ∪ Icc a b := fun x hx =>\n  (lt_or_le x a).elim (fun hxa => or.inl hxa) fun hxa => or.inr ⟨hxa, hx⟩\n#align Iic_subset_Iio_union_Icc Iic_subset_Iio_union_Icc\n\n",
 "Iic_subset_Iio":
 "theorem Iic_subset_Iio : Iic a ⊆ Iio b ↔ a < b :=\n  ⟨fun h => h right_mem_Iic, fun h x hx => lt_of_le_of_lt hx h⟩\n#align Iic_subset_Iio Iic_subset_Iio\n\n",
 "Iic_subset_Iic_union_Ioc":
 "theorem Iic_subset_Iic_union_Ioc : Iic b ⊆ Iic a ∪ Ioc a b := fun x hx =>\n  (le_or_lt x a).elim (fun hxa => or.inl hxa) fun hxa => or.inr ⟨hxa, hx⟩\n#align Iic_subset_Iic_union_Ioc Iic_subset_Iic_union_Ioc\n\n",
 "Iic_subset_Iic_union_Icc":
 "theorem Iic_subset_Iic_union_Icc : Iic b ⊆ Iic a ∪ Icc a b :=\n  Subset.trans Iic_subset_Iic_union_Ioc (union_subset_union_right _ Ioc_subset_Icc_self)\n#align Iic_subset_Iic_union_Icc Iic_subset_Iic_union_Icc\n\n",
 "Iic_subset_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem Iic_subset_Iic : Iic a ⊆ Iic b ↔ a ≤ b :=\n  @Ici_subset_Ici («expr ᵒᵈ» α) _ _ _\n#align Iic_subset_Iic Iic_subset_Iic\n\n",
 "Iic_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem Iic_prod_eq (a : α × β) : Iic a = set.prod (Iic a.1) (Iic a.2) :=\n  rfl\n#align Iic_prod_eq Iic_prod_eq\n\n",
 "Iic_prod_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem Iic_prod_Iic (a : α) (b : β) : set.prod (Iic a) (Iic b) = Iic (a, b) :=\n  rfl\n#align Iic_prod_Iic Iic_prod_Iic\n\n",
 "Iic_inter_Ioi":
 "theorem Iic_inter_Ioi : Iic a ∩ Ioi b = Ioc b a :=\n  inter_comm _ _\n#align Iic_inter_Ioi Iic_inter_Ioi\n\n",
 "Iic_inter_Ioc_of_le":
 "theorem Iic_inter_Ioc_of_le (h : a ≤ c) : Iic a ∩ Ioc b c = Ioc b a :=\n  ext fun x => ⟨fun H => ⟨H.2.1, H.1⟩, fun H => ⟨H.2, H.1, H.2.trans h⟩⟩\n#align Iic_inter_Ioc_of_le Iic_inter_Ioc_of_le\n\n",
 "Iic_inter_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem Iic_inter_Iic {a b : α} : Iic a ∩ Iic b = Iic («expr ⊓ » a b) :=\n  by\n  ext x\n  simp [Iic]\n#align Iic_inter_Iic Iic_inter_Iic\n\n",
 "Iic_inter_Ici":
 "theorem Iic_inter_Ici : Iic a ∩ Ici b = Icc b a :=\n  inter_comm _ _\n#align Iic_inter_Ici Iic_inter_Ici\n\n",
 "Iic_injective":
 "theorem Iic_injective : injective (Iic : α → set α) := fun a b => eq_of_forall_le_iff ∘ Set.ext_iff.1\n#align Iic_injective Iic_injective\n\n",
 "Iic_inj":
 "theorem Iic_inj : Iic a = Iic b ↔ a = b :=\n  Iic_injective.eq_iff\n#align Iic_inj Iic_inj\n\n",
 "Iic_eq":
 "#print IsMin.Iic_eq /-\ntheorem IsMin.Iic_eq (h : is_min a) : Iic a = {a} :=\n  h.to_dual.Ici_eq\n#align is_min.Iic_eq IsMin.Iic_eq\n-/\n\n",
 "Iic_diff_right":
 "@[simp]\ntheorem Iic_diff_right : Iic a \\ {a} = Iio a :=\n  ext fun x => by simp [lt_iff_le_and_ne]\n#align Iic_diff_right Iic_diff_right\n\n",
 "Iic_diff_Iio_same":
 "@[simp]\ntheorem Iic_diff_Iio_same : Iic a \\ Iio a = {a} := by\n  rw [← Iic_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 right_mem_Iic)]\n#align Iic_diff_Iio_same Iic_diff_Iio_same\n\n",
 "Iic_diff_Iio":
 "@[simp]\ntheorem Iic_diff_Iio : Iic b \\ Iio a = Icc a b := by rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iic]\n#align Iic_diff_Iio Iic_diff_Iio\n\n",
 "Iic_diff_Iic":
 "@[simp]\ntheorem Iic_diff_Iic : Iic b \\ Iic a = Ioc a b := by rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iic]\n#align Iic_diff_Iic Iic_diff_Iic\n\n",
 "Iic_def":
 "theorem Iic_def (b : α) : { x | x ≤ b } = Iic b :=\n  rfl\n#align Iic_def Iic_def\n\n",
 "Iic_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Iic_bot [partial_order α] [OrderBot α] : Iic («expr⊥» : α) = {«expr⊥»} :=\n  isMin_bot.Iic_eq\n#align Iic_bot Iic_bot\n\n",
 "Ico_union_right":
 "theorem Ico_union_right (hab : a ≤ b) : Ico a b ∪ {b} = Icc a b := by\n  simpa only [dual_Ioc, dual_Icc] using Ioc_union_left hab.dual\n#align Ico_union_right Ico_union_right\n\n",
 "Ico_union_Ico_eq_Ico":
 "@[simp]\ntheorem Ico_union_Ico_eq_Ico (h₁ : a ≤ b) (h₂ : b ≤ c) : Ico a b ∪ Ico b c = Ico a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_le h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Ico_subset_Ico_union_Ico\n#align Ico_union_Ico_eq_Ico Ico_union_Ico_eq_Ico\n\n",
 "Ico_union_Ico'":
 "theorem Ico_union_Ico' (h₁ : c ≤ b) (h₂ : a ≤ d) : Ico a b ∪ Ico c d = Ico (min a c) (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Ico, min_le_iff, lt_max_iff]\n  by_cases hc : c ≤ x <;> by_cases hd : x < d\n  · tauto\n  · have hax : a ≤ x := h₂.trans (le_of_not_gt hd)\n    tauto\n  · have hxb : x < b := (lt_of_not_ge hc).trans_le h₁\n    tauto\n  · tauto\n#align Ico_union_Ico' Ico_union_Ico'\n\n",
 "Ico_union_Ico":
 "theorem Ico_union_Ico (h₁ : min a b ≤ max c d) (h₂ : min c d ≤ max a b) : Ico a b ∪ Ico c d = Ico (min a c) (max b d) :=\n  by\n  cases' le_total a b with hab hab <;> cases' le_total c d with hcd hcd <;> simp [hab, hcd] at h₁ h₂\n  · exact Ico_union_Ico' h₂ h₁\n  all_goals simp [*]\n#align Ico_union_Ico Ico_union_Ico\n\n",
 "Ico_union_Ici_eq_Ici":
 "@[simp]\ntheorem Ico_union_Ici_eq_Ici (h : a ≤ b) : Ico a b ∪ Ici b = Ici a :=\n  Subset.antisymm (fun x hx => hx.elim And.left h.trans) Ici_subset_Ico_union_Ici\n#align Ico_union_Ici_eq_Ici Ico_union_Ici_eq_Ici\n\n",
 "Ico_union_Ici'":
 "theorem Ico_union_Ici' (h₁ : c ≤ b) : Ico a b ∪ Ici c = Ici (min a c) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Ico, mem_Ici, min_le_iff]\n  by_cases hc : c ≤ x\n  · tauto\n  · have hxb : x < b := (lt_of_not_ge hc).trans_le h₁\n    tauto\n#align Ico_union_Ici' Ico_union_Ici'\n\n",
 "Ico_union_Ici":
 "theorem Ico_union_Ici (h : c ≤ max a b) : Ico a b ∪ Ici c = Ici (min a c) :=\n  by\n  cases' le_total a b with hab hab <;> simp [hab] at h\n  · exact Ico_union_Ici' h\n  · simp [*]\n#align Ico_union_Ici Ico_union_Ici\n\n",
 "Ico_union_Icc_eq_Icc":
 "@[simp]\ntheorem Ico_union_Icc_eq_Icc (h₁ : a ≤ b) (h₂ : b ≤ c) : Ico a b ∪ Icc b c = Icc a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.le.trans h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Icc_subset_Ico_union_Icc\n#align Ico_union_Icc_eq_Icc Ico_union_Icc_eq_Icc\n\n",
 "Ico_subset_Ioo_left":
 "theorem Ico_subset_Ioo_left (h₁ : a₁ < a₂) : Ico a₂ b ⊆ Ioo a₁ b := fun x => and.imp_left h₁.trans_le\n#align Ico_subset_Ioo_left Ico_subset_Ioo_left\n\n",
 "Ico_subset_Iio_self":
 "theorem Ico_subset_Iio_self : Ico a b ⊆ Iio b := fun x => And.right\n#align Ico_subset_Iio_self Ico_subset_Iio_self\n\n",
 "Ico_subset_Ico_union_Ico":
 "theorem Ico_subset_Ico_union_Ico : Ico a c ⊆ Ico a b ∪ Ico b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Ico_subset_Ico_union_Ico Ico_subset_Ico_union_Ico\n\n",
 "Ico_subset_Ico_right":
 "theorem Ico_subset_Ico_right (h : b₁ ≤ b₂) : Ico a b₁ ⊆ Ico a b₂ :=\n  Ico_subset_Ico le_rfl h\n#align Ico_subset_Ico_right Ico_subset_Ico_right\n\n",
 "Ico_subset_Ico_left":
 "theorem Ico_subset_Ico_left (h : a₁ ≤ a₂) : Ico a₂ b ⊆ Ico a₁ b :=\n  Ico_subset_Ico h le_rfl\n#align Ico_subset_Ico_left Ico_subset_Ico_left\n\n",
 "Ico_subset_Ico_iff":
 "theorem Ico_subset_Ico_iff (h₁ : a₁ < b₁) : Ico a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h =>\n    have : a₂ ≤ a₁ ∧ a₁ < b₂ := h ⟨le_rfl, h₁⟩\n    ⟨this.1, le_of_not_lt fun h' => lt_irrefl b₂ (h ⟨this.2.le, h'⟩).2⟩,\n    fun ⟨h₁, h₂⟩ => Ico_subset_Ico h₁ h₂⟩\n#align Ico_subset_Ico_iff Ico_subset_Ico_iff\n\n",
 "Ico_subset_Ico":
 "theorem Ico_subset_Ico (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Ico a₁ b₁ ⊆ Ico a₂ b₂ := fun x ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans hx₁, hx₂.trans_le h₂⟩\n#align Ico_subset_Ico Ico_subset_Ico\n\n",
 "Ico_subset_Ici_self":
 "theorem Ico_subset_Ici_self : Ico a b ⊆ Ici a := fun x => And.left\n#align Ico_subset_Ici_self Ico_subset_Ici_self\n\n",
 "Ico_subset_Icc_union_Ioo":
 "theorem Ico_subset_Icc_union_Ioo : Ico a c ⊆ Icc a b ∪ Ioo b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Ico_subset_Icc_union_Ioo Ico_subset_Icc_union_Ioo\n\n",
 "Ico_subset_Icc_union_Ico":
 "theorem Ico_subset_Icc_union_Ico : Ico a c ⊆ Icc a b ∪ Ico b c :=\n  Subset.trans Ico_subset_Icc_union_Ioo (union_subset_union_right _ Ioo_subset_Ico_self)\n#align Ico_subset_Icc_union_Ico Ico_subset_Icc_union_Ico\n\n",
 "Ico_subset_Icc_self":
 "theorem Ico_subset_Icc_self : Ico a b ⊆ Icc a b := fun x => and.imp_right le_of_lt\n#align Ico_subset_Icc_self Ico_subset_Icc_self\n\n",
 "Ico_self":
 "@[simp]\ntheorem Ico_self (a : α) : Ico a a = ∅ :=\n  Ico_eq_empty <| lt_irrefl _\n#align Ico_self Ico_self\n\n",
 "Ico_inter_Iio":
 "@[simp]\ntheorem Ico_inter_Iio : Ico a b ∩ Iio c = Ico a (min b c) :=\n  ext <| by simp (config := { contextual := true }) [iff_def]\n#align Ico_inter_Iio Ico_inter_Iio\n\n",
 "Ico_inter_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem Ico_inter_Ico : Ico a₁ b₁ ∩ Ico a₂ b₂ = Ico («expr ⊔ » a₁ a₂) («expr ⊓ » b₁ b₂) := by\n  simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm] <;> ac_rfl\n#align Ico_inter_Ico Ico_inter_Ico\n\n",
 "Ico_inter_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem Ico_inter_Ici (a b c : α) : Ico a b ∩ Ici c = Ico («expr ⊔ » a c) b := by\n  rw [← Ici_inter_Iio, ← Ici_inter_Iio, ← Ici_inter_Ici, inter_right_comm]\n#align Ico_inter_Ici Ico_inter_Ici\n\n",
 "Ico_insert_right":
 "@[simp]\ntheorem Ico_insert_right (h : a ≤ b) : insert b (Ico a b) = Icc a b := by rw [insert_eq, union_comm, Ico_union_right h]\n#align Ico_insert_right Ico_insert_right\n\n",
 "Ico_eq_empty_of_le":
 "@[simp]\ntheorem Ico_eq_empty_of_le (h : b ≤ a) : Ico a b = ∅ :=\n  Ico_eq_empty h.not_lt\n#align Ico_eq_empty_of_le Ico_eq_empty_of_le\n\n",
 "Ico_eq_empty_iff":
 "theorem Ico_eq_empty_iff : Ico a b = ∅ ↔ ¬a < b := by rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ico]\n#align Ico_eq_empty_iff Ico_eq_empty_iff\n\n",
 "Ico_eq_empty":
 "@[simp]\ntheorem Ico_eq_empty (h : ¬a < b) : Ico a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun x ⟨ha, hb⟩ => h (ha.trans_lt hb)\n#align Ico_eq_empty Ico_eq_empty\n\n",
 "Ico_eq_Ico_iff":
 "theorem Ico_eq_Ico_iff (h : a₁ < b₁ ∨ a₂ < b₂) : Ico a₁ b₁ = Ico a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂ :=\n  ⟨fun e => by\n    simp [subset.antisymm_iff] at e; simp [le_antisymm_iff]\n    cases h <;> simp [Ico_subset_Ico_iff h] at e <;> [rcases e with ⟨⟨h₁, h₂⟩, e'⟩, rcases e with ⟨e', ⟨h₁, h₂⟩⟩] <;>\n        have := (Ico_subset_Ico_iff <| h₁.trans_lt <| h.trans_le h₂).1 e' <;>\n      tauto,\n    fun ⟨h₁, h₂⟩ => by rw [h₁, h₂]⟩\n#align Ico_eq_Ico_iff Ico_eq_Ico_iff\n\n",
 "Ico_diff_left":
 "@[simp]\ntheorem Ico_diff_left : Ico a b \\ {a} = Ioo a b :=\n  ext fun x => by simp [and_right_comm, ← lt_iff_le_and_ne, eq_comm]\n#align Ico_diff_left Ico_diff_left\n\n",
 "Ico_diff_Ioo_same":
 "@[simp]\ntheorem Ico_diff_Ioo_same (h : a < b) : Ico a b \\ Ioo a b = {a} := by\n  rw [← Ico_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Ico.2 h)]\n#align Ico_diff_Ioo_same Ico_diff_Ioo_same\n\n",
 "Ico_diff_Iio":
 "@[simp]\ntheorem Ico_diff_Iio : Ico a b \\ Iio c = Ico (max a c) b := by rw [diff_eq, compl_Iio, Ico_inter_Ici, sup_eq_max]\n#align Ico_diff_Iio Ico_diff_Iio\n\n",
 "Ico_def":
 "theorem Ico_def (a b : α) : { x | a ≤ x ∧ x < b } = Ico a b :=\n  rfl\n#align Ico_def Ico_def\n\n",
 "Ico_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Ico_bot : Ico («expr⊥») a = Iio a := by simp [← Ici_inter_Iio]\n#align Ico_bot Ico_bot\n\n",
 "Ici_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Ici_top [partial_order α] [OrderTop α] : Ici («expr⊤» : α) = {«expr⊤»} :=\n  isMax_top.Ici_eq\n#align Ici_top Ici_top\n\n",
 "Ici_subset_Ioi":
 "theorem Ici_subset_Ioi : Ici a ⊆ Ioi b ↔ b < a :=\n  ⟨fun h => h left_mem_Ici, fun h x hx => h.trans_le hx⟩\n#align Ici_subset_Ioi Ici_subset_Ioi\n\n",
 "Ici_subset_Ico_union_Ici":
 "theorem Ici_subset_Ico_union_Ici : Ici a ⊆ Ico a b ∪ Ici b := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => or.inl ⟨hx, hxb⟩) fun hxb => or.inr hxb\n#align Ici_subset_Ico_union_Ici Ici_subset_Ico_union_Ici\n\n",
 "Ici_subset_Ici":
 "theorem Ici_subset_Ici : Ici a ⊆ Ici b ↔ b ≤ a :=\n  ⟨fun h => h <| left_mem_Ici, fun h x hx => h.trans hx⟩\n#align Ici_subset_Ici Ici_subset_Ici\n\n",
 "Ici_subset_Icc_union_Ioi":
 "theorem Ici_subset_Icc_union_Ioi : Ici a ⊆ Icc a b ∪ Ioi b := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => or.inl ⟨hx, hxb⟩) fun hxb => or.inr hxb\n#align Ici_subset_Icc_union_Ioi Ici_subset_Icc_union_Ioi\n\n",
 "Ici_subset_Icc_union_Ici":
 "theorem Ici_subset_Icc_union_Ici : Ici a ⊆ Icc a b ∪ Ici b :=\n  Subset.trans Ici_subset_Ico_union_Ici (union_subset_union_left _ Ico_subset_Icc_self)\n#align Ici_subset_Icc_union_Ici Ici_subset_Icc_union_Ici\n\n",
 "Ici_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem Ici_prod_eq (a : α × β) : Ici a = set.prod (Ici a.1) (Ici a.2) :=\n  rfl\n#align Ici_prod_eq Ici_prod_eq\n\n",
 "Ici_prod_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem Ici_prod_Ici (a : α) (b : β) : set.prod (Ici a) (Ici b) = Ici (a, b) :=\n  rfl\n#align Ici_prod_Ici Ici_prod_Ici\n\n",
 "Ici_inter_Iio":
 "theorem Ici_inter_Iio : Ici a ∩ Iio b = Ico a b :=\n  rfl\n#align Ici_inter_Iio Ici_inter_Iio\n\n",
 "Ici_inter_Iic":
 "theorem Ici_inter_Iic : Ici a ∩ Iic b = Icc a b :=\n  rfl\n#align Ici_inter_Iic Ici_inter_Iic\n\n",
 "Ici_inter_Ici":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem Ici_inter_Ici {a b : α} : Ici a ∩ Ici b = Ici («expr ⊔ » a b) :=\n  by\n  ext x\n  simp [Ici]\n#align Ici_inter_Ici Ici_inter_Ici\n\n",
 "Ici_injective":
 "theorem Ici_injective : injective (Ici : α → set α) := fun a b => eq_of_forall_ge_iff ∘ Set.ext_iff.1\n#align Ici_injective Ici_injective\n\n",
 "Ici_inj":
 "theorem Ici_inj : Ici a = Ici b ↔ a = b :=\n  Ici_injective.eq_iff\n#align Ici_inj Ici_inj\n\n",
 "Ici_eq":
 "#print IsMax.Ici_eq /-\ntheorem IsMax.Ici_eq (h : is_max a) : Ici a = {a} :=\n  eq_singleton_iff_unique_mem.2 ⟨left_mem_Ici, fun b => h.eq_of_ge⟩\n#align is_max.Ici_eq IsMax.Ici_eq\n-/\n\n",
 "Ici_diff_left":
 "@[simp]\ntheorem Ici_diff_left : Ici a \\ {a} = Ioi a :=\n  ext fun x => by simp [lt_iff_le_and_ne, eq_comm]\n#align Ici_diff_left Ici_diff_left\n\n",
 "Ici_diff_Ioi_same":
 "@[simp]\ntheorem Ici_diff_Ioi_same : Ici a \\ Ioi a = {a} := by\n  rw [← Ici_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 left_mem_Ici)]\n#align Ici_diff_Ioi_same Ici_diff_Ioi_same\n\n",
 "Ici_diff_Ioi":
 "@[simp]\ntheorem Ici_diff_Ioi : Ici a \\ Ioi b = Icc a b := by rw [diff_eq, compl_Ioi, Ici_inter_Iic]\n#align Ici_diff_Ioi Ici_diff_Ioi\n\n",
 "Ici_diff_Ici":
 "@[simp]\ntheorem Ici_diff_Ici : Ici a \\ Ici b = Ico a b := by rw [diff_eq, compl_Ici, Ici_inter_Iio]\n#align Ici_diff_Ici Ici_diff_Ici\n\n",
 "Ici_def":
 "theorem Ici_def (a : α) : { x | a ≤ x } = Ici a :=\n  rfl\n#align Ici_def Ici_def\n\n",
 "Ici_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Ici_bot : Ici («expr⊥» : α) = univ :=\n  isBot_bot.Ici_eq\n#align Ici_bot Ici_bot\n\n",
 "Icc_union_Ioo_eq_Ico":
 "@[simp]\ntheorem Icc_union_Ioo_eq_Ico (h₁ : a ≤ b) (h₂ : b < c) : Icc a b ∪ Ioo b c = Ico a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_lt h₂⟩) fun hx => ⟨h₁.trans hx.1.le, hx.2⟩)\n    Ico_subset_Icc_union_Ioo\n#align Icc_union_Ioo_eq_Ico Icc_union_Ioo_eq_Ico\n\n",
 "Icc_union_Ioi_eq_Ici":
 "@[simp]\ntheorem Icc_union_Ioi_eq_Ici (h : a ≤ b) : Icc a b ∪ Ioi b = Ici a :=\n  Subset.antisymm (fun x hx => hx.elim And.left fun hx' => h.trans <| le_of_lt hx') Ici_subset_Icc_union_Ioi\n#align Icc_union_Ioi_eq_Ici Icc_union_Ioi_eq_Ici\n\n",
 "Icc_union_Ioc_eq_Icc":
 "@[simp]\ntheorem Icc_union_Ioc_eq_Icc (h₁ : a ≤ b) (h₂ : b ≤ c) : Icc a b ∪ Ioc b c = Icc a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans hx.1.le, hx.2⟩)\n    Icc_subset_Icc_union_Ioc\n#align Icc_union_Ioc_eq_Icc Icc_union_Ioc_eq_Icc\n\n",
 "Icc_union_Ico_eq_Ico":
 "@[simp]\ntheorem Icc_union_Ico_eq_Ico (h₁ : a ≤ b) (h₂ : b < c) : Icc a b ∪ Ico b c = Ico a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_lt h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Ico_subset_Icc_union_Ico\n#align Icc_union_Ico_eq_Ico Icc_union_Ico_eq_Ico\n\n",
 "Icc_union_Ici_eq_Ici":
 "@[simp]\ntheorem Icc_union_Ici_eq_Ici (h : a ≤ b) : Icc a b ∪ Ici b = Ici a :=\n  Subset.antisymm (fun x hx => hx.elim And.left h.trans) Ici_subset_Icc_union_Ici\n#align Icc_union_Ici_eq_Ici Icc_union_Ici_eq_Ici\n\n",
 "Icc_union_Ici'":
 "theorem Icc_union_Ici' (h₁ : c ≤ b) : Icc a b ∪ Ici c = Ici (min a c) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Icc, mem_Ici, min_le_iff]\n  by_cases hc : c ≤ x\n  · tauto\n  · have hxb : x ≤ b := (le_of_not_ge hc).trans h₁\n    tauto\n#align Icc_union_Ici' Icc_union_Ici'\n\n",
 "Icc_union_Ici":
 "theorem Icc_union_Ici (h : c ≤ max a b) : Icc a b ∪ Ici c = Ici (min a c) :=\n  by\n  cases' le_or_lt a b with hab hab <;> simp [hab] at h\n  · exact Icc_union_Ici' h\n  · cases h\n    · simp [*]\n    · have hca : c ≤ a := h.trans hab.le\n      simp [*]\n#align Icc_union_Ici Icc_union_Ici\n\n",
 "Icc_union_Icc_eq_Icc":
 "@[simp]\ntheorem Icc_union_Icc_eq_Icc (h₁ : a ≤ b) (h₂ : b ≤ c) : Icc a b ∪ Icc b c = Icc a c :=\n  Subset.antisymm (fun x hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Icc_subset_Icc_union_Icc\n#align Icc_union_Icc_eq_Icc Icc_union_Icc_eq_Icc\n\n",
 "Icc_union_Icc'":
 "theorem Icc_union_Icc' (h₁ : c ≤ b) (h₂ : a ≤ d) : Icc a b ∪ Icc c d = Icc (min a c) (max b d) :=\n  by\n  ext1 x\n  simp_rw [mem_union, mem_Icc, min_le_iff, le_max_iff]\n  by_cases hc : c ≤ x <;> by_cases hd : x ≤ d\n  · tauto\n  · have hax : a ≤ x := h₂.trans (le_of_not_ge hd)\n    tauto\n  · have hxb : x ≤ b := (le_of_not_ge hc).trans h₁\n    tauto\n  · tauto\n#align Icc_union_Icc' Icc_union_Icc'\n\n",
 "Icc_union_Icc":
 "/-- We cannot replace `<` by `≤` in the hypotheses.\nOtherwise for `b < a = d < c` the l.h.s. is `∅` and the r.h.s. is `{a}`.\n-/\ntheorem Icc_union_Icc (h₁ : min a b < max c d) (h₂ : min c d < max a b) : Icc a b ∪ Icc c d = Icc (min a c) (max b d) :=\n  by\n  cases' le_or_lt a b with hab hab <;> cases' le_or_lt c d with hcd hcd <;>\n    simp only [min_eq_left, min_eq_right, max_eq_left, max_eq_right, min_eq_left_of_lt, min_eq_right_of_lt,\n      max_eq_left_of_lt, max_eq_right_of_lt, hab, hcd] at h₁ h₂\n  · exact Icc_union_Icc' h₂.le h₁.le\n  all_goals simp [*, min_eq_left_of_lt, max_eq_left_of_lt, min_eq_right_of_lt, max_eq_right_of_lt]\n#align Icc_union_Icc Icc_union_Icc\n\n",
 "Icc_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem Icc_top : Icc a («expr⊤») = Ici a := by simp [← Ici_inter_Iic]\n#align Icc_top Icc_top\n\n",
 "Icc_subset_Ioo_iff":
 "theorem Icc_subset_Ioo_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioo a₂ b₂ ↔ a₂ < a₁ ∧ b₁ < b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ x ⟨hx, hx'⟩ => ⟨h.trans_le hx, hx'.trans_lt h'⟩⟩\n#align Icc_subset_Ioo_iff Icc_subset_Ioo_iff\n\n",
 "Icc_subset_Ioo":
 "theorem Icc_subset_Ioo (ha : a₂ < a₁) (hb : b₁ < b₂) : Icc a₁ b₁ ⊆ Ioo a₂ b₂ := fun x hx =>\n  ⟨ha.trans_le hx.1, hx.2.trans_lt hb⟩\n#align Icc_subset_Ioo Icc_subset_Ioo\n\n",
 "Icc_subset_Ioi_iff":
 "theorem Icc_subset_Ioi_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioi a₂ ↔ a₂ < a₁ :=\n  ⟨fun h => h ⟨le_rfl, h₁⟩, fun h x ⟨hx, hx'⟩ => h.trans_le hx⟩\n#align Icc_subset_Ioi_iff Icc_subset_Ioi_iff\n\n",
 "Icc_subset_Ioc_iff":
 "theorem Icc_subset_Ioc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ a₂ < a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ x ⟨hx, hx'⟩ => ⟨h.trans_le hx, hx'.trans h'⟩⟩\n#align Icc_subset_Ioc_iff Icc_subset_Ioc_iff\n\n",
 "Icc_subset_Iio_iff":
 "theorem Icc_subset_Iio_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Iio b₂ ↔ b₁ < b₂ :=\n  ⟨fun h => h ⟨h₁, le_rfl⟩, fun h x ⟨hx, hx'⟩ => hx'.trans_lt h⟩\n#align Icc_subset_Iio_iff Icc_subset_Iio_iff\n\n",
 "Icc_subset_Iic_self":
 "theorem Icc_subset_Iic_self : Icc a b ⊆ Iic b := fun x => And.right\n#align Icc_subset_Iic_self Icc_subset_Iic_self\n\n",
 "Icc_subset_Iic_iff":
 "theorem Icc_subset_Iic_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Iic b₂ ↔ b₁ ≤ b₂ :=\n  ⟨fun h => h ⟨h₁, le_rfl⟩, fun h x ⟨hx, hx'⟩ => hx'.trans h⟩\n#align Icc_subset_Iic_iff Icc_subset_Iic_iff\n\n",
 "Icc_subset_Ico_union_Icc":
 "theorem Icc_subset_Ico_union_Icc : Icc a c ⊆ Ico a b ∪ Icc b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Icc_subset_Ico_union_Icc Icc_subset_Ico_union_Icc\n\n",
 "Icc_subset_Ico_right":
 "theorem Icc_subset_Ico_right (h₁ : b₁ < b₂) : Icc a b₁ ⊆ Ico a b₂ := fun x => and.imp_right fun h₂ => h₂.trans_lt h₁\n#align Icc_subset_Ico_right Icc_subset_Ico_right\n\n",
 "Icc_subset_Ico_iff":
 "theorem Icc_subset_Ico_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ < b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ x ⟨hx, hx'⟩ => ⟨h.trans hx, hx'.trans_lt h'⟩⟩\n#align Icc_subset_Ico_iff Icc_subset_Ico_iff\n\n",
 "Icc_subset_Ici_self":
 "theorem Icc_subset_Ici_self : Icc a b ⊆ Ici a := fun x => And.left\n#align Icc_subset_Ici_self Icc_subset_Ici_self\n\n",
 "Icc_subset_Ici_iff":
 "theorem Icc_subset_Ici_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ici a₂ ↔ a₂ ≤ a₁ :=\n  ⟨fun h => h ⟨le_rfl, h₁⟩, fun h x ⟨hx, hx'⟩ => h.trans hx⟩\n#align Icc_subset_Ici_iff Icc_subset_Ici_iff\n\n",
 "Icc_subset_Icc_union_Ioc":
 "theorem Icc_subset_Icc_union_Ioc : Icc a c ⊆ Icc a b ∪ Ioc b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => or.inl ⟨hx.1, hxb⟩) fun hxb => or.inr ⟨hxb, hx.2⟩\n#align Icc_subset_Icc_union_Ioc Icc_subset_Icc_union_Ioc\n\n",
 "Icc_subset_Icc_union_Icc":
 "theorem Icc_subset_Icc_union_Icc : Icc a c ⊆ Icc a b ∪ Icc b c :=\n  Subset.trans Icc_subset_Icc_union_Ioc (union_subset_union_right _ Ioc_subset_Icc_self)\n#align Icc_subset_Icc_union_Icc Icc_subset_Icc_union_Icc\n\n",
 "Icc_subset_Icc_right":
 "theorem Icc_subset_Icc_right (h : b₁ ≤ b₂) : Icc a b₁ ⊆ Icc a b₂ :=\n  Icc_subset_Icc le_rfl h\n#align Icc_subset_Icc_right Icc_subset_Icc_right\n\n",
 "Icc_subset_Icc_left":
 "theorem Icc_subset_Icc_left (h : a₁ ≤ a₂) : Icc a₂ b ⊆ Icc a₁ b :=\n  Icc_subset_Icc h le_rfl\n#align Icc_subset_Icc_left Icc_subset_Icc_left\n\n",
 "Icc_subset_Icc_iff":
 "theorem Icc_subset_Icc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Icc a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ x ⟨hx, hx'⟩ => ⟨h.trans hx, hx'.trans h'⟩⟩\n#align Icc_subset_Icc_iff Icc_subset_Icc_iff\n\n",
 "Icc_subset_Icc":
 "theorem Icc_subset_Icc (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Icc a₁ b₁ ⊆ Icc a₂ b₂ := fun x ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans hx₁, le_trans hx₂ h₂⟩\n#align Icc_subset_Icc Icc_subset_Icc\n\n",
 "Icc_ssubset_Icc_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem Icc_ssubset_Icc_right (hI : a₂ ≤ b₂) (ha : a₂ ≤ a₁) (hb : b₁ < b₂) : «expr ⊂ » (Icc a₁ b₁) (Icc a₂ b₂) :=\n  (ssubset_iff_of_subset (Icc_subset_Icc ha (le_of_lt hb))).mpr\n    ⟨b₂, right_mem_Icc.mpr hI, fun f => lt_irrefl b₁ (hb.trans_le f.2)⟩\n#align Icc_ssubset_Icc_right Icc_ssubset_Icc_right\n\n",
 "Icc_ssubset_Icc_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\ntheorem Icc_ssubset_Icc_left (hI : a₂ ≤ b₂) (ha : a₂ < a₁) (hb : b₁ ≤ b₂) : «expr ⊂ » (Icc a₁ b₁) (Icc a₂ b₂) :=\n  (ssubset_iff_of_subset (Icc_subset_Icc (le_of_lt ha) hb)).mpr\n    ⟨a₂, left_mem_Icc.mpr hI, not_and.mpr fun f g => lt_irrefl a₂ (ha.trans_le f)⟩\n#align Icc_ssubset_Icc_left Icc_ssubset_Icc_left\n\n",
 "Icc_self":
 "@[simp]\ntheorem Icc_self (a : α) : Icc a a = {a} :=\n  Set.ext <| by simp [Icc, le_antisymm_iff, and_comm']\n#align Icc_self Icc_self\n\n",
 "Icc_prod_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\ntheorem Icc_prod_eq (a b : α × β) : Icc a b = set.prod (Icc a.1 b.1) (Icc a.2 b.2) := by simp\n#align Icc_prod_eq Icc_prod_eq\n\n",
 "Icc_prod_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.prod -/\n@[simp]\ntheorem Icc_prod_Icc (a₁ a₂ : α) (b₁ b₂ : β) : set.prod (Icc a₁ a₂) (Icc b₁ b₂) = Icc (a₁, b₁) (a₂, b₂) :=\n  by\n  ext ⟨x, y⟩\n  simp [and_assoc, and_comm', and_left_comm]\n#align Icc_prod_Icc Icc_prod_Icc\n\n",
 "Icc_inter_Icc_eq_singleton":
 "@[simp]\ntheorem Icc_inter_Icc_eq_singleton (hab : a ≤ b) (hbc : b ≤ c) : Icc a b ∩ Icc b c = {b} := by\n  rw [Icc_inter_Icc, sup_of_le_right hab, inf_of_le_left hbc, Icc_self]\n#align Icc_inter_Icc_eq_singleton Icc_inter_Icc_eq_singleton\n\n",
 "Icc_inter_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem Icc_inter_Icc : Icc a₁ b₁ ∩ Icc a₂ b₂ = Icc («expr ⊔ » a₁ a₂) («expr ⊓ » b₁ b₂) := by\n  simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm] <;> ac_rfl\n#align Icc_inter_Icc Icc_inter_Icc\n\n",
 "Icc_eq_singleton_iff":
 "@[simp]\ntheorem Icc_eq_singleton_iff : Icc a b = {c} ↔ a = c ∧ b = c :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · have hab : a ≤ b := nonempty_Icc.1 (h.symm.subst <| singleton_nonempty c)\n    exact ⟨eq_of_mem_singleton <| h.subst <| left_mem_Icc.2 hab, eq_of_mem_singleton <| h.subst <| right_mem_Icc.2 hab⟩\n  · rintro ⟨rfl, rfl⟩\n    exact Icc_self _\n#align Icc_eq_singleton_iff Icc_eq_singleton_iff\n\n",
 "Icc_eq_empty_of_lt":
 "@[simp]\ntheorem Icc_eq_empty_of_lt (h : b < a) : Icc a b = ∅ :=\n  Icc_eq_empty h.not_le\n#align Icc_eq_empty_of_lt Icc_eq_empty_of_lt\n\n",
 "Icc_eq_empty_iff":
 "theorem Icc_eq_empty_iff : Icc a b = ∅ ↔ ¬a ≤ b := by rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Icc]\n#align Icc_eq_empty_iff Icc_eq_empty_iff\n\n",
 "Icc_eq_empty":
 "@[simp]\ntheorem Icc_eq_empty (h : ¬a ≤ b) : Icc a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun x ⟨ha, hb⟩ => h (ha.trans hb)\n#align Icc_eq_empty Icc_eq_empty\n\n",
 "Icc_diff_right":
 "@[simp]\ntheorem Icc_diff_right : Icc a b \\ {b} = Ico a b :=\n  ext fun x => by simp [lt_iff_le_and_ne, and_assoc']\n#align Icc_diff_right Icc_diff_right\n\n",
 "Icc_diff_left":
 "@[simp]\ntheorem Icc_diff_left : Icc a b \\ {a} = Ioc a b :=\n  ext fun x => by simp [lt_iff_le_and_ne, eq_comm, and_right_comm]\n#align Icc_diff_left Icc_diff_left\n\n",
 "Icc_diff_both":
 "@[simp]\ntheorem Icc_diff_both : Icc a b \\ {a, b} = Ioo a b := by rw [insert_eq, ← diff_diff, Icc_diff_left, Ioc_diff_right]\n#align Icc_diff_both Icc_diff_both\n\n",
 "Icc_diff_Ioo_same":
 "@[simp]\ntheorem Icc_diff_Ioo_same (h : a ≤ b) : Icc a b \\ Ioo a b = {a, b} :=\n  by\n  rw [← Icc_diff_both, diff_diff_cancel_left]\n  simp [insert_subset, h]\n#align Icc_diff_Ioo_same Icc_diff_Ioo_same\n\n",
 "Icc_diff_Ioc_same":
 "@[simp]\ntheorem Icc_diff_Ioc_same (h : a ≤ b) : Icc a b \\ Ioc a b = {a} := by\n  rw [← Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Icc.2 h)]\n#align Icc_diff_Ioc_same Icc_diff_Ioc_same\n\n",
 "Icc_diff_Ico_same":
 "@[simp]\ntheorem Icc_diff_Ico_same (h : a ≤ b) : Icc a b \\ Ico a b = {b} := by\n  rw [← Icc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Icc.2 h)]\n#align Icc_diff_Ico_same Icc_diff_Ico_same\n\n",
 "Icc_def":
 "theorem Icc_def (a b : α) : { x | a ≤ x ∧ x ≤ b } = Icc a b :=\n  rfl\n#align Icc_def Icc_def\n\n",
 "Icc_bot_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem Icc_bot_top [partial_order α] [BoundedOrder α] : Icc («expr⊥» : α) («expr⊤») = univ := by simp\n#align Icc_bot_top Icc_bot_top\n\n",
 "Icc_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem Icc_bot : Icc («expr⊥») a = Iic a := by simp [← Ici_inter_Iic]\n#align Icc_bot Icc_bot\n\n"}