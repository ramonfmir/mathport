{"piecewise_mem_Icc'":
 "theorem piecewise_mem_Icc' {s : set ι} [∀ j, decidable (j ∈ s)] {f₁ f₂ g₁ g₂ : ∀ i, α i} (h₁ : f₁ ∈ Icc g₁ g₂)\n    (h₂ : f₂ ∈ Icc g₁ g₂) : s.piecewise f₁ f₂ ∈ Icc g₁ g₂ :=\n  piecewise_mem_Icc (fun i hi => ⟨h₁.1 _, h₁.2 _⟩) fun i hi => ⟨h₂.1 _, h₂.2 _⟩\n#align piecewise_mem_Icc' piecewise_mem_Icc'\n\n",
 "piecewise_mem_Icc":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i «expr ∉ » s) -/\ntheorem piecewise_mem_Icc {s : set ι} [∀ j, decidable (j ∈ s)] {f₁ f₂ g₁ g₂ : ∀ i, α i}\n    (h₁ : ∀ i ∈ s, f₁ i ∈ Icc (g₁ i) (g₂ i)) (h₂ : ∀ (i) (_ : i ∉ s), f₂ i ∈ Icc (g₁ i) (g₂ i)) :\n    s.piecewise f₁ f₂ ∈ Icc g₁ g₂ :=\n  ⟨le_piecewise (fun i hi => (h₁ i hi).1) fun i hi => (h₂ i hi).1,\n    piecewise_le (fun i hi => (h₁ i hi).2) fun i hi => (h₂ i hi).2⟩\n#align piecewise_mem_Icc piecewise_mem_Icc\n\n",
 "pi_univ_Ioo_subset":
 "theorem pi_univ_Ioo_subset : (pi univ fun i => Ioo (x i) (y i)) ⊆ Ioo x y := fun x hx =>\n  ⟨pi_univ_Ioi_subset _ fun i hi => (hx i hi).1, pi_univ_Iio_subset _ fun i hi => (hx i hi).2⟩\n#align pi_univ_Ioo_subset pi_univ_Ioo_subset\n\n",
 "pi_univ_Ioi_subset":
 "theorem pi_univ_Ioi_subset : (pi univ fun i => Ioi (x i)) ⊆ Ioi x := fun z hz =>\n  ⟨fun i => le_of_lt <| hz i trivial, fun h => nonempty.elim ‹nonempty ι› fun i => (h i).not_lt (hz i trivial)⟩\n#align pi_univ_Ioi_subset pi_univ_Ioi_subset\n\n",
 "pi_univ_Ioc_update_union":
 "theorem pi_univ_Ioc_update_union (x y : ∀ i, α i) (i₀ : ι) (m : α i₀) (hm : m ∈ Icc (x i₀) (y i₀)) :\n    ((pi univ fun i => Ioc (x i) (update y i₀ m i)) ∪ pi univ fun i => Ioc (update x i₀ m i) (y i)) =\n      pi univ fun i => Ioc (x i) (y i) :=\n  by\n  simp_rw [pi_univ_Ioc_update_left hm.1, pi_univ_Ioc_update_right hm.2, ← union_inter_distrib_right, ← set_of_or,\n    le_or_lt, set_of_true, univ_inter]\n#align pi_univ_Ioc_update_union pi_univ_Ioc_update_union\n\n",
 "pi_univ_Ioc_update_right":
 "theorem pi_univ_Ioc_update_right {x y : ∀ i, α i} {i₀ : ι} {m : α i₀} (hm : m ≤ y i₀) :\n    (pi univ fun i => Ioc (x i) (update y i₀ m i)) = { z | z i₀ ≤ m } ∩ pi univ fun i => Ioc (x i) (y i) :=\n  by\n  have : Ioc (x i₀) m = Iic m ∩ Ioc (x i₀) (y i₀) := by\n    rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_left_comm, inter_eq_self_of_subset_left (Iic_subset_Iic.2 hm)]\n  simp_rw [univ_pi_update i₀ y m fun i z => Ioc (x i) z, ← pi_inter_compl ({i₀} : set ι), singleton_pi', ← inter_assoc,\n    this]\n  rfl\n#align pi_univ_Ioc_update_right pi_univ_Ioc_update_right\n\n",
 "pi_univ_Ioc_update_left":
 "theorem pi_univ_Ioc_update_left {x y : ∀ i, α i} {i₀ : ι} {m : α i₀} (hm : x i₀ ≤ m) :\n    (pi univ fun i => Ioc (update x i₀ m i) (y i)) = { z | m < z i₀ } ∩ pi univ fun i => Ioc (x i) (y i) :=\n  by\n  have : Ioc m (y i₀) = Ioi m ∩ Ioc (x i₀) (y i₀) := by\n    rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, ← inter_assoc, inter_eq_self_of_subset_left (Ioi_subset_Ioi hm)]\n  simp_rw [univ_pi_update i₀ _ _ fun i z => Ioc z (y i), ← pi_inter_compl ({i₀} : set ι), singleton_pi', ← inter_assoc,\n    this]\n  rfl\n#align pi_univ_Ioc_update_left pi_univ_Ioc_update_left\n\n",
 "pi_univ_Ioc_subset":
 "theorem pi_univ_Ioc_subset : (pi univ fun i => Ioc (x i) (y i)) ⊆ Ioc x y := fun x hx =>\n  ⟨pi_univ_Ioi_subset _ fun i hi => (hx i hi).1, fun i => (hx i trivial).2⟩\n#align pi_univ_Ioc_subset pi_univ_Ioc_subset\n\n",
 "pi_univ_Iio_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\ntheorem pi_univ_Iio_subset : (pi univ fun i => Iio (x i)) ⊆ Iio x :=\n  @pi_univ_Ioi_subset ι (fun i => «expr ᵒᵈ» (α i)) _ x _\n#align pi_univ_Iio_subset pi_univ_Iio_subset\n\n",
 "pi_univ_Iic":
 "@[simp]\ntheorem pi_univ_Iic : (pi univ fun i => Iic (x i)) = Iic x :=\n  ext fun y => by simp [Pi.le_def]\n#align pi_univ_Iic pi_univ_Iic\n\n",
 "pi_univ_Ico_subset":
 "theorem pi_univ_Ico_subset : (pi univ fun i => Ico (x i) (y i)) ⊆ Ico x y := fun x hx =>\n  ⟨fun i => (hx i trivial).1, pi_univ_Iio_subset _ fun i hi => (hx i hi).2⟩\n#align pi_univ_Ico_subset pi_univ_Ico_subset\n\n",
 "pi_univ_Ici":
 "/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\n@[simp]\ntheorem pi_univ_Ici : (pi univ fun i => Ici (x i)) = Ici x :=\n  ext fun y => by simp [Pi.le_def]\n#align pi_univ_Ici pi_univ_Ici\n\n",
 "pi_univ_Icc":
 "@[simp]\ntheorem pi_univ_Icc : (pi univ fun i => Icc (x i) (y i)) = Icc x y :=\n  ext fun y => by simp [Pi.le_def, forall_and]\n#align pi_univ_Icc pi_univ_Icc\n\n",
 "disjoint_pi_univ_Ioc_update_left_right":
 "theorem disjoint_pi_univ_Ioc_update_left_right {x y : ∀ i, α i} {i₀ : ι} {m : α i₀} :\n    Disjoint (pi univ fun i => Ioc (x i) (update y i₀ m i)) (pi univ fun i => Ioc (update x i₀ m i) (y i)) :=\n  by\n  rw [disjoint_left]\n  rintro z h₁ h₂\n  refine' (h₁ i₀ (mem_univ _)).2.not_lt _\n  simpa only [function.update_same] using (h₂ i₀ (mem_univ _)).1\n#align disjoint_pi_univ_Ioc_update_left_right disjoint_pi_univ_Ioc_update_left_right\n\n",
 "Icc_diff_pi_univ_Ioo_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `x`, `y`, `x'`, and `y'` are functions `Π i : ι, α i`, then\nthe set difference between the box `[x, y]` and the product of the open intervals `(x' i, y' i)`\nis covered by the union of the following boxes: for each `i : ι`, we take\n`[x, update y i (x' i)]` and `[update x i (y' i), y]`.\n\nE.g., if `x' = x` and `y' = y`, then this lemma states that the difference between a closed box\n`[x, y]` and the corresponding open box `{z | ∀ i, x i < z i < y i}` is covered by the union\nof the faces of `[x, y]`. -/\ntheorem Icc_diff_pi_univ_Ioo_subset (x y x' y' : ∀ i, α i) :\n    (Icc x y \\ pi univ fun i => Ioo (x' i) (y' i)) ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (Icc x (update y i (x' i))) ∪\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (Icc (update x i (y' i)) y) :=\n  by\n  rintro a ⟨⟨hxa, hay⟩, ha'⟩\n  simpa [le_update_iff, update_le_iff, hxa, hay, hxa _, hay _, ← exists_or, not_and_or] using ha'\n#align Icc_diff_pi_univ_Ioo_subset Icc_diff_pi_univ_Ioo_subset\n\n",
 "Icc_diff_pi_univ_Ioc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- If `x`, `y`, `z` are functions `Π i : ι, α i`, then\nthe set difference between the box `[x, z]` and the product of the intervals `(y i, z i]`\nis covered by the union of the boxes `[x, update z i (y i)]`.\n\nE.g., if `x = y`, then this lemma states that the difference between a closed box\n`[x, y]` and the product of half-open intervals `{z | ∀ i, x i < z i ≤ y i}` is covered by the union\nof the faces of `[x, y]` adjacent to `x`. -/\ntheorem Icc_diff_pi_univ_Ioc_subset (x y z : ∀ i, α i) :\n    (Icc x z \\ pi univ fun i => Ioc (y i) (z i)) ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (Icc x (update z i (y i))) :=\n  by\n  rintro a ⟨⟨hax, haz⟩, hay⟩\n  simpa [not_and_or, hax, le_update_iff, haz _] using hay\n#align Icc_diff_pi_univ_Ioc_subset Icc_diff_pi_univ_Ioc_subset\n\n"}