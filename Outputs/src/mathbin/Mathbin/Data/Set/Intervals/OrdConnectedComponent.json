{"subset_ord_connected_component":
 "theorem subset_ord_connected_component {t} [h : OrdConnected s] (hs : x ∈ s) (ht : s ⊆ t) :\n    s ⊆ ordConnectedComponent t x := fun y hy => (h.uIcc_subset hs hy).trans ht\n#align subset_ord_connected_component subset_ord_connected_component\n\n",
 "self_mem_ord_connected_component":
 "@[simp]\ntheorem self_mem_ord_connected_component : x ∈ ordConnectedComponent s x ↔ x ∈ s := by\n  rw [mem_ord_connected_component, uIcc_self, singleton_subset_iff]\n#align self_mem_ord_connected_component self_mem_ord_connected_component\n\n",
 "ord_separating_set_comm":
 "theorem ord_separating_set_comm (s t : set α) : ordSeparatingSet s t = ordSeparatingSet t s :=\n  inter_comm _ _\n#align ord_separating_set_comm ord_separating_set_comm\n\n",
 "ord_connected_section_subset":
 "theorem ord_connected_section_subset : ordConnectedSection s ⊆ s :=\n  range_subset_iff.2 fun x => ord_connected_component_subset <| Nonempty.some_mem _\n#align ord_connected_section_subset ord_connected_section_subset\n\n",
 "ord_connected_proj_mem_ord_connected_component":
 "theorem ord_connected_proj_mem_ord_connected_component (s : set α) (x : s) :\n    ordConnectedProj s x ∈ ordConnectedComponent s x :=\n  Nonempty.some_mem _\n#align ord_connected_proj_mem_ord_connected_component ord_connected_proj_mem_ord_connected_component\n\n",
 "ord_connected_proj_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n@[simp]\ntheorem ord_connected_proj_eq {x y : s} : ordConnectedProj s x = ordConnectedProj s y ↔ set.uIcc (x : α) y ⊆ s :=\n  by\n  constructor <;> intro h\n  · rw [← mem_ord_connected_component, ← ord_connected_component_ord_connected_proj, h,\n      ord_connected_component_ord_connected_proj, self_mem_ord_connected_component]\n    exact y.2\n  · simp only [ord_connected_proj]\n    congr 1\n    exact ord_connected_component_eq h\n#align ord_connected_proj_eq ord_connected_proj_eq\n\n",
 "ord_connected_component_univ":
 "@[simp]\ntheorem ord_connected_component_univ : ordConnectedComponent univ x = univ := by simp [ord_connected_component]\n#align ord_connected_component_univ ord_connected_component_univ\n\n",
 "ord_connected_component_subset":
 "theorem ord_connected_component_subset : ordConnectedComponent s x ⊆ s := fun y hy => hy right_mem_uIcc\n#align ord_connected_component_subset ord_connected_component_subset\n\n",
 "ord_connected_component_ord_connected_proj":
 "@[simp]\ntheorem ord_connected_component_ord_connected_proj (s : set α) (x : s) :\n    ordConnectedComponent s (ordConnectedProj s x) = ordConnectedComponent s x :=\n  ord_connected_component_eq <| mem_ordConnectedComponent_ordConnectedProj _ _\n#align ord_connected_component_ord_connected_proj ord_connected_component_ord_connected_proj\n\n",
 "ord_connected_component_inter":
 "theorem ord_connected_component_inter (s t : set α) (x : α) :\n    ordConnectedComponent (s ∩ t) x = ordConnectedComponent s x ∩ ordConnectedComponent t x := by\n  simp [ord_connected_component, set_of_and]\n#align ord_connected_component_inter ord_connected_component_inter\n\n",
 "ord_connected_component_eq_empty":
 "@[simp]\ntheorem ord_connected_component_eq_empty : ordConnectedComponent s x = ∅ ↔ x ∉ s := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_ord_connected_component]\n#align ord_connected_component_eq_empty ord_connected_component_eq_empty\n\n",
 "ord_connected_component_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem ord_connected_component_eq (h : set.uIcc x y ⊆ s) : ordConnectedComponent s x = ordConnectedComponent s y :=\n  ext fun z => ⟨mem_ordConnectedComponent_trans (mem_ordConnectedComponent_comm.2 h), mem_ordConnectedComponent_trans h⟩\n#align ord_connected_component_eq ord_connected_component_eq\n\n",
 "ord_connected_component_empty":
 "@[simp]\ntheorem ord_connected_component_empty : ordConnectedComponent ∅ x = ∅ :=\n  ordConnectedComponent_eq_empty.2 (not_mem_empty x)\n#align ord_connected_component_empty ord_connected_component_empty\n\n",
 "nonempty_ord_connected_component":
 "@[simp]\ntheorem nonempty_ord_connected_component : (ordConnectedComponent s x).nonempty ↔ x ∈ s :=\n  ⟨fun ⟨y, hy⟩ => hy <| left_mem_uIcc, fun h => ⟨x, self_mem_ordConnectedComponent.2 h⟩⟩\n#align nonempty_ord_connected_component nonempty_ord_connected_component\n\n",
 "mem_ord_connected_component_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem mem_ord_connected_component_trans (hxy : y ∈ ordConnectedComponent s x) (hyz : z ∈ ordConnectedComponent s y) :\n    z ∈ ordConnectedComponent s x :=\n  calc\n    set.uIcc x z ⊆ set.uIcc x y ∪ set.uIcc y z := uIcc_subset_uIcc_union_uIcc\n    _ ⊆ s := union_subset hxy hyz\n    \n#align mem_ord_connected_component_trans mem_ord_connected_component_trans\n\n",
 "mem_ord_connected_component_ord_connected_proj":
 "theorem mem_ord_connected_component_ord_connected_proj (s : set α) (x : s) :\n    ↑x ∈ ordConnectedComponent s (ordConnectedProj s x) :=\n  mem_ordConnectedComponent_comm.2 <| ordConnectedProj_mem_ordConnectedComponent s x\n#align mem_ord_connected_component_ord_connected_proj mem_ord_connected_component_ord_connected_proj\n\n",
 "mem_ord_connected_component_comm":
 "theorem mem_ord_connected_component_comm : y ∈ ordConnectedComponent s x ↔ x ∈ ordConnectedComponent s y := by\n  rw [mem_ord_connected_component, mem_ord_connected_component, uIcc_comm]\n#align mem_ord_connected_component_comm mem_ord_connected_component_comm\n\n",
 "mem_ord_connected_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem mem_ord_connected_component : y ∈ ordConnectedComponent s x ↔ set.uIcc x y ⊆ s :=\n  iff.rfl\n#align mem_ord_connected_component mem_ord_connected_component\n\n",
 "eq_of_mem_ord_connected_section_of_uIcc_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem eq_of_mem_ord_connected_section_of_uIcc_subset (hx : x ∈ ordConnectedSection s) (hy : y ∈ ordConnectedSection s)\n    (h : set.uIcc x y ⊆ s) : x = y := by\n  rcases hx with ⟨x, rfl⟩; rcases hy with ⟨y, rfl⟩\n  exact\n    ord_connected_proj_eq.2\n      (mem_ord_connected_component_trans\n        (mem_ord_connected_component_trans (ord_connected_proj_mem_ord_connected_component _ _) h)\n        (mem_ord_connected_component_ord_connected_proj _ _))\n#align eq_of_mem_ord_connected_section_of_uIcc_subset eq_of_mem_ord_connected_section_of_uIcc_subset\n\n",
 "dual_ord_separating_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem dual_ord_separating_set :\n    ordSeparatingSet («expr ⁻¹' » of_dual s) («expr ⁻¹' » of_dual t) = «expr ⁻¹' » of_dual (ordSeparatingSet s t) := by\n  simp only [ord_separating_set, mem_preimage, ← to_dual.surjective.Union_comp, of_dual_to_dual,\n    dual_ord_connected_component, ← preimage_compl, preimage_inter, preimage_Union]\n#align dual_ord_separating_set dual_ord_separating_set\n\n",
 "dual_ord_connected_section":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem dual_ord_connected_section (s : set α) :\n    ordConnectedSection («expr ⁻¹' » of_dual s) = «expr ⁻¹' » of_dual (ordConnectedSection s) :=\n  by\n  simp only [ord_connected_section, ord_connected_proj]\n  congr 1 with x; simp only; congr 1\n  exact dual_ord_connected_component\n#align dual_ord_connected_section dual_ord_connected_section\n\n",
 "dual_ord_connected_component":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem dual_ord_connected_component :\n    ordConnectedComponent («expr ⁻¹' » of_dual s) (toDual x) = «expr ⁻¹' » of_dual (ordConnectedComponent s x) :=\n  ext <|\n    toDual.surjective.forall.2 fun x => by\n      rw [mem_ord_connected_component, dual_uIcc]\n      rfl\n#align dual_ord_connected_component dual_ord_connected_component\n\n",
 "disjoint_right_ord_separating_set":
 "theorem disjoint_right_ord_separating_set : Disjoint t (ordSeparatingSet s t) :=\n  ordSeparatingSet_comm t s ▸ disjoint_left_ord_separating_set\n#align disjoint_right_ord_separating_set disjoint_right_ord_separating_set\n\n",
 "disjoint_ord_t5_nhd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `set.uIcc -/\ntheorem disjoint_ord_t5_nhd : Disjoint (ordT5Nhd s t) (ordT5Nhd t s) :=\n  by\n  rw [disjoint_iff_inf_le]\n  rintro x ⟨hx₁, hx₂⟩\n  rcases mem_Union₂.1 hx₁ with ⟨a, has, ha⟩\n  clear hx₁\n  rcases mem_Union₂.1 hx₂ with ⟨b, hbt, hb⟩\n  clear hx₂\n  rw [mem_ord_connected_component, subset_inter_iff] at ha hb\n  wlog (discharger := tactic.skip) hab : a ≤ b := le_total a b using a b s t, b a t s\n  rotate_left\n  exact fun h₁ h₂ h₃ h₄ => this h₂ h₁ h₄ h₃\n  cases' ha with ha ha'\n  cases' hb with hb hb'\n  have hsub : set.uIcc a b ⊆ «expr ᶜ» (ord_separating_set s t).ord_connected_section :=\n    by\n    rw [ord_separating_set_comm, uIcc_comm] at hb'\n    calc\n      set.uIcc a b ⊆ set.uIcc a x ∪ set.uIcc x b := uIcc_subset_uIcc_union_uIcc\n      _ ⊆ «expr ᶜ» (ord_separating_set s t).ord_connected_section := union_subset ha' hb'\n      \n  clear ha' hb'\n  cases' le_total x a with hxa hax\n  · exact hb (Icc_subset_uIcc' ⟨hxa, hab⟩) has\n  cases' le_total b x with hbx hxb\n  · exact ha (Icc_subset_uIcc ⟨hab, hbx⟩) hbt\n  have : x ∈ ord_separating_set s t := ⟨mem_Union₂.2 ⟨a, has, ha⟩, mem_Union₂.2 ⟨b, hbt, hb⟩⟩\n  lift x to ord_separating_set s t using this\n  suffices : ord_connected_component (ord_separating_set s t) x ⊆ set.uIcc a b\n  exact hsub (this <| ord_connected_proj_mem_ord_connected_component _ _) (mem_range_self _)\n  rintro y (hy : set.uIcc (↑x) y ⊆ ord_separating_set s t)\n  rw [uIcc_of_le hab, mem_Icc, ← not_lt, ← not_lt]\n  exact\n    ⟨fun hya => disjoint_left.1 disjoint_left_ord_separating_set has (hy <| Icc_subset_uIcc' ⟨hya.le, hax⟩), fun hyb =>\n      disjoint_left.1 disjoint_right_ord_separating_set hbt (hy <| Icc_subset_uIcc ⟨hxb, hyb.le⟩)⟩\n#align disjoint_ord_t5_nhd disjoint_ord_t5_nhd\n\n",
 "disjoint_left_ord_separating_set":
 "theorem disjoint_left_ord_separating_set : Disjoint s (ordSeparatingSet s t) :=\n  Disjoint.inter_right' _ <|\n    disjoint_unionᵢ₂_right.2 fun x hx => disjoint_compl_right.mono_right <| ord_connected_component_subset\n#align disjoint_left_ord_separating_set disjoint_left_ord_separating_set\n\n"}