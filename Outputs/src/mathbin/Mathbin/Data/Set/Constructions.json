{"finite_inter_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂₀ » -/\ntheorem finite_inter_mem (cond : FiniteInter S) (F : Finset (set α)) : ↑F ⊆ S → «expr⋂₀ » (↑F : set (set α)) ∈ S := by\n  classical\n    refine' Finset.induction_on F (fun _ => _) _\n    · simp [cond.univ_mem]\n    · intro a s h1 h2 h3\n      suffices a ∩ «expr⋂₀ » ↑s ∈ S by simpa\n      exact cond.inter_mem (h3 (Finset.mem_insert_self a s)) (h2 fun x hx => h3 <| Finset.mem_insert_of_mem hx)\n#align finite_inter_mem finite_inter_mem\n\n",
 "finite_inter_closure_insert":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (P «expr ∈ » finite_inter_closure[has_finite_inter.finite_inter_closure] (insert[has_insert.insert] A S)) -/\ntheorem finite_inter_closure_insert {A : set α} (cond : FiniteInter S) (P) (_ : P ∈ finiteInterClosure (insert A S)) :\n    P ∈ S ∨ ∃ Q ∈ S, P = A ∩ Q := by\n  induction' H with S h T1 T2 _ _ h1 h2\n  · cases h\n    · exact or.inr ⟨Set.univ, cond.univ_mem, by simpa⟩\n    · exact or.inl h\n  · exact or.inl cond.univ_mem\n  · rcases h1 with (h | ⟨Q, hQ, rfl⟩) <;> rcases h2 with (i | ⟨R, hR, rfl⟩)\n    · exact or.inl (cond.inter_mem h i)\n    · exact or.inr ⟨T1 ∩ R, cond.inter_mem h hR, by simp only [← Set.inter_assoc, Set.inter_comm _ A]⟩\n    · exact or.inr ⟨Q ∩ T2, cond.inter_mem hQ i, by simp only [Set.inter_assoc]⟩\n    ·\n      exact\n        or.inr\n          ⟨Q ∩ R, cond.inter_mem hQ hR, by\n            ext x\n            constructor <;> simp (config := { contextual := true })⟩\n#align finite_inter_closure_insert finite_inter_closure_insert\n\n",
 "finite_inter_closure_has_finite_inter":
 "/-\nCopyright (c) 2020 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\ntheorem finite_inter_closure_has_finite_inter : FiniteInter (finiteInterClosure S) :=\n  { univ_mem := finite_inter_closure.univ\n    inter_mem := fun _ h _ => finite_inter_closure.inter h }\n#align finite_inter_closure_has_finite_inter finite_inter_closure_has_finite_inter\n\n"}