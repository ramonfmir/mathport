{"zip_with_ne_locus_eq_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem zip_with_ne_locus_eq_right [∀ a, decidable_eq (M a)] [∀ a, decidable_eq (P a)] {F : ∀ a, M a → N a → P a}\n    (F0 : ∀ a, F a 0 0 = 0)\n    (f₁ f₂ : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M a))\n    (g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a))\n    (hF : ∀ a g, function.injective fun f => F a f g) :\n    (zip_with F F0 f₁ g).ne_locus (zip_with F F0 f₂ g) = f₁.ne_locus f₂ :=\n  by\n  ext\n  simpa only [mem_ne_locus] using (hF a _).ne_iff\n#align zip_with_ne_locus_eq_right zip_with_ne_locus_eq_right\n\n",
 "zip_with_ne_locus_eq_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem zip_with_ne_locus_eq_left [∀ a, decidable_eq (N a)] [∀ a, decidable_eq (P a)] {F : ∀ a, M a → N a → P a}\n    (F0 : ∀ a, F a 0 0 = 0)\n    (f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M a))\n    (g₁ g₂ : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a))\n    (hF : ∀ a f, function.injective fun g => F a f g) :\n    (zip_with F F0 f g₁).ne_locus (zip_with F F0 f g₂) = g₁.ne_locus g₂ :=\n  by\n  ext\n  simpa only [mem_ne_locus] using (hF a _).ne_iff\n#align zip_with_ne_locus_eq_left zip_with_ne_locus_eq_left\n\n",
 "subset_map_range_ne_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem subset_map_range_ne_locus [∀ a, decidable_eq (N a)] [∀ a, decidable_eq (M a)]\n    (f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a))\n    {F : ∀ a, N a → M a} (F0 : ∀ a, F a 0 = 0) : (f.map_range F F0).ne_locus (g.map_range F F0) ⊆ f.ne_locus g :=\n  fun a => by simpa only [mem_ne_locus, map_range_apply, not_imp_not] using congr_arg (F a)\n#align subset_map_range_ne_locus subset_map_range_ne_locus\n\n",
 "not_mem_ne_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem not_mem_ne_locus\n    {f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a)}\n    {a : α} : a ∉ f.ne_locus g ↔ f a = g a :=\n  mem_ne_locus.not.trans not_ne_iff\n#align not_mem_ne_locus not_mem_ne_locus\n\n",
 "nonempty_ne_locus_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem nonempty_ne_locus_iff\n    {f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a)} :\n    (f.ne_locus g).nonempty ↔ f ≠ g :=\n  Finset.nonempty_iff_ne_empty.trans ne_locus_eq_empty.not\n#align nonempty_ne_locus_iff nonempty_ne_locus_iff\n\n",
 "ne_locus_zero_right":
 "@[simp]\ntheorem ne_locus_zero_right : f.ne_locus 0 = f.support := by\n  ext\n  rw [mem_ne_locus, mem_support_iff, coe_zero, pi.zero_apply]\n#align ne_locus_zero_right ne_locus_zero_right\n\n",
 "ne_locus_zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem ne_locus_zero_left :\n    (0 :\n            «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\"\n              (N a)).ne_locus\n        f =\n      f.support :=\n  (ne_locus_comm _ _).trans (ne_locus_zero_right _)\n#align ne_locus_zero_left ne_locus_zero_left\n\n",
 "ne_locus_sub_right":
 "@[simp]\ntheorem ne_locus_sub_right : ne_locus (f₁ - g) (f₂ - g) = ne_locus f₁ f₂ := by\n  simpa only [sub_eq_add_neg] using @ne_locus_add_right α N _ _ _ _ _ _\n#align ne_locus_sub_right ne_locus_sub_right\n\n",
 "ne_locus_sub_left":
 "@[simp]\ntheorem ne_locus_sub_left : ne_locus (f - g₁) (f - g₂) = ne_locus g₁ g₂ := by\n  simp only [sub_eq_add_neg, @ne_locus_add_left α N _ _ _, ne_locus_neg_neg]\n#align ne_locus_sub_left ne_locus_sub_left\n\n",
 "ne_locus_self_sub_right":
 "@[simp]\ntheorem ne_locus_self_sub_right : ne_locus f (f - g) = g.support := by\n  rw [sub_eq_add_neg, ne_locus_self_add_right, support_neg]\n#align ne_locus_self_sub_right ne_locus_self_sub_right\n\n",
 "ne_locus_self_sub_left":
 "@[simp]\ntheorem ne_locus_self_sub_left : ne_locus (f - g) f = g.support := by rw [ne_locus_comm, ne_locus_self_sub_right]\n#align ne_locus_self_sub_left ne_locus_self_sub_left\n\n",
 "ne_locus_self_add_right":
 "@[simp]\ntheorem ne_locus_self_add_right : ne_locus f (f + g) = g.support := by\n  rw [← ne_locus_zero_left, ← @ne_locus_add_left α N _ _ _ f 0 g, add_zero]\n#align ne_locus_self_add_right ne_locus_self_add_right\n\n",
 "ne_locus_self_add_left":
 "@[simp]\ntheorem ne_locus_self_add_left : ne_locus (f + g) f = g.support := by rw [ne_locus_comm, ne_locus_self_add_right]\n#align ne_locus_self_add_left ne_locus_self_add_left\n\n",
 "ne_locus_neg_neg":
 "@[simp]\ntheorem ne_locus_neg_neg : ne_locus (-f) (-g) = f.ne_locus g :=\n  map_range_ne_locus_eq _ _ (fun a => neg_zero) fun a => neg_injective\n#align ne_locus_neg_neg ne_locus_neg_neg\n\n",
 "ne_locus_neg":
 "theorem ne_locus_neg : ne_locus (-f) g = f.ne_locus (-g) := by rw [← ne_locus_neg_neg, neg_neg]\n#align ne_locus_neg ne_locus_neg\n\n",
 "ne_locus_eq_support_sub":
 "theorem ne_locus_eq_support_sub : f.ne_locus g = (f - g).support := by\n  rw [← @ne_locus_add_right α N _ _ _ _ _ (-g), add_right_neg, ne_locus_zero_right, sub_eq_add_neg]\n#align ne_locus_eq_support_sub ne_locus_eq_support_sub\n\n",
 "ne_locus_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem ne_locus_eq_empty\n    {f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a)} :\n    f.ne_locus g = ∅ ↔ f = g :=\n  ⟨fun h => ext fun a => not_not.mp (mem_ne_locus.not.mp (Finset.eq_empty_iff_forall_not_mem.mp h a)), fun h =>\n    h ▸ by simp only [ne_locus, ne.def, eq_self_iff_true, not_true, Finset.filter_false]⟩\n#align ne_locus_eq_empty ne_locus_eq_empty\n\n",
 "ne_locus_comm":
 "theorem ne_locus_comm : f.ne_locus g = g.ne_locus f := by simp_rw [ne_locus, Finset.union_comm, ne_comm]\n#align ne_locus_comm ne_locus_comm\n\n",
 "ne_locus_add_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem ne_locus_add_right [∀ a, add_right_cancel_monoid (N a)]\n    (f g h : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a)) :\n    (f + h).ne_locus (g + h) = f.ne_locus g :=\n  zip_with_ne_locus_eq_right _ _ _ _ fun a => add_left_injective\n#align ne_locus_add_right ne_locus_add_right\n\n",
 "ne_locus_add_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem ne_locus_add_left [∀ a, add_left_cancel_monoid (N a)]\n    (f g h : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a)) :\n    (f + g).ne_locus (f + h) = g.ne_locus h :=\n  zip_with_ne_locus_eq_left _ _ _ _ fun a => add_right_injective\n#align ne_locus_add_left ne_locus_add_left\n\n",
 "mem_ne_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/-\nCopyright (c) 2022 Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa, Junyan Xu\n-/\n@[simp]\ntheorem mem_ne_locus\n    {f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a)}\n    {a : α} : a ∈ f.ne_locus g ↔ f a ≠ g a := by\n  simpa only [ne_locus, Finset.mem_filter, Finset.mem_union, mem_support_iff, and_iff_right_iff_imp] using ne.ne_or_ne _\n#align mem_ne_locus mem_ne_locus\n\n",
 "map_range_ne_locus_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem map_range_ne_locus_eq [∀ a, decidable_eq (N a)] [∀ a, decidable_eq (M a)]\n    (f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (N a))\n    {F : ∀ a, N a → M a} (F0 : ∀ a, F a 0 = 0) (hF : ∀ a, function.injective (F a)) :\n    (f.map_range F F0).ne_locus (g.map_range F F0) = f.ne_locus g :=\n  by\n  ext\n  simpa only [mem_ne_locus] using (hF a).ne_iff\n#align map_range_ne_locus_eq map_range_ne_locus_eq\n\n",
 "coe_ne_locus":
 "@[simp]\ntheorem coe_ne_locus : ↑(f.ne_locus g) = { x | f x ≠ g x } :=\n  Set.ext fun x => mem_ne_locus\n#align coe_ne_locus coe_ne_locus\n\n"}