{"support_range_Icc_subset":
 "theorem support_range_Icc_subset [decidable_eq ι] [∀ i, decidable_eq (α i)] :\n    (f.range_Icc g).support ⊆ f.support ∪ g.support :=\n  by\n  refine' fun x hx => _\n  by_contra\n  refine' not_mem_support_iff.2 _ hx\n  rw [range_Icc_apply, not_mem_support_iff.1 (not_mem_mono (subset_union_left _ _) h),\n    not_mem_support_iff.1 (not_mem_mono (subset_union_right _ _) h)]\n  exact Icc_self _\n#align support_range_Icc_subset support_range_Icc_subset\n\n",
 "range_Icc_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem range_Icc_apply\n    (f g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (α i))\n    (i : ι) : f.range_Icc g i = Icc (f i) (g i) :=\n  rfl\n#align range_Icc_apply range_Icc_apply\n\n",
 "mem_singleton_apply_iff":
 "theorem mem_singleton_apply_iff : a ∈ f.singleton i ↔ a = f i :=\n  mem_singleton\n#align mem_singleton_apply_iff mem_singleton_apply_iff\n\n",
 "mem_range_Icc_apply_iff":
 "theorem mem_range_Icc_apply_iff : a ∈ f.range_Icc g i ↔ f i ≤ a ∧ a ≤ g i :=\n  mem_Icc\n#align mem_range_Icc_apply_iff mem_range_Icc_apply_iff\n\n",
 "mem_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem mem_pi\n    {f :\n      «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (Finset (α i))}\n    {g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (α i)} :\n    g ∈ f.pi ↔ ∀ i, g i ∈ f i :=\n  mem_dfinsupp_iff_of_support_subset <| Subset.refl _\n#align mem_pi mem_pi\n\n",
 "mem_dfinsupp_iff_of_support_subset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/-- When `t` is supported on `s`, `f ∈ s.dfinsupp t` precisely means that `f` is pointwise in `t`.\n-/\n@[simp]\ntheorem mem_dfinsupp_iff_of_support_subset\n    {t :\n      «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (Finset (α i))}\n    (ht : t.support ⊆ s) : f ∈ s.dfinsupp t ↔ ∀ i, f i ∈ t i :=\n  by\n  refine'\n    mem_dfinsupp_iff.trans\n      (forall_and_distrib.symm.trans <|\n        forall_congr' fun i =>\n          ⟨fun h => _, fun h => ⟨fun hi => ht <| mem_support_iff.2 fun H => mem_support_iff.1 hi _, fun _ => h⟩⟩)\n  · by_cases hi : i ∈ s\n    · exact h.2 hi\n    · rw [not_mem_support_iff.1 (mt h.1 hi), not_mem_support_iff.1 (not_mem_mono ht hi)]\n      exact zero_mem_zero\n  · rwa [H, mem_zero] at h\n#align mem_dfinsupp_iff_of_support_subset mem_dfinsupp_iff_of_support_subset\n\n",
 "mem_dfinsupp_iff":
 "theorem mem_dfinsupp_iff : f ∈ s.dfinsupp t ↔ f.support ⊆ s ∧ ∀ i ∈ s, f i ∈ t i :=\n  by\n  refine' mem_map.trans ⟨_, _⟩\n  · rintro ⟨f, hf, rfl⟩\n    refine' ⟨support_mk_subset, fun i hi => _⟩\n    convert mem_pi.1 hf i hi\n    exact mk_of_mem hi\n  · refine' fun h => ⟨fun i _ => f i, mem_pi.2 h.2, _⟩\n    ext i\n    dsimp\n    exact ite_eq_left_iff.2 fun hi => (not_mem_support_iff.1 fun H => hi <| h.1 H).symm\n#align mem_dfinsupp_iff mem_dfinsupp_iff\n\n",
 "card_pi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem card_pi\n    (f :\n      «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\"\n        (Finset (α i))) :\n    f.pi.card = f.prod fun i => (f i).card := by\n  rw [pi, card_dfinsupp]\n  exact finset.prod_congr rfl fun i _ => by simp only [pi.nat_apply, nat.cast_id]\n#align card_pi card_pi\n\n",
 "card_dfinsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-\nCopyright (c) 2021 Yaël Dillies. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yaël Dillies\n-/\n@[simp]\ntheorem card_dfinsupp (s : Finset ι) (t : ∀ i, Finset (α i)) :\n    (s.dfinsupp t).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (t i).card :=\n  (card_map _).trans <| card_pi _ _\n#align card_dfinsupp card_dfinsupp\n\n",
 "card_Ioo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem card_Ioo :\n    (Ioo f g).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (f.support ∪ g.support) (Icc (f i) (g i)).card -\n        2 :=\n  by rw [card_Ioo_eq_card_Icc_sub_two, card_Icc]\n#align card_Ioo card_Ioo\n\n",
 "card_Ioc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem card_Ioc :\n    (Ioc f g).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (f.support ∪ g.support) (Icc (f i) (g i)).card -\n        1 :=\n  by rw [card_Ioc_eq_card_Icc_sub_one, card_Icc]\n#align card_Ioc card_Ioc\n\n",
 "card_Iio":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem card_Iio :\n    (Iio f).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" f.support\n          (Iic (f i)).card -\n        1 :=\n  by rw [card_Iio_eq_card_Iic_sub_one, card_Iic]\n#align card_Iio card_Iio\n\n",
 "card_Iic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem card_Iic :\n    (Iic f).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" f.support\n        (Iic (f i)).card :=\n  by simp_rw [Iic_eq_Icc, card_Icc, dfinsupp.bot_eq_zero, support_zero, empty_union, zero_apply, bot_eq_zero]\n#align card_Iic card_Iic\n\n",
 "card_Ico":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem card_Ico :\n    (Ico f g).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (f.support ∪ g.support) (Icc (f i) (g i)).card -\n        1 :=\n  by rw [card_Ico_eq_card_Icc_sub_one, card_Icc]\n#align card_Ico card_Ico\n\n",
 "card_Icc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem card_Icc :\n    (Icc f g).card =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (f.support ∪ g.support) (Icc (f i) (g i)).card :=\n  card_dfinsupp _ _\n#align card_Icc card_Icc\n\n",
 "Icc_eq":
 "theorem Icc_eq : Icc f g = (f.support ∪ g.support).dfinsupp (f.range_Icc g) :=\n  rfl\n#align Icc_eq Icc_eq\n\n"}