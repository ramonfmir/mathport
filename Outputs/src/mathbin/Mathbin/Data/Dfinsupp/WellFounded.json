{"well_founded_of_finite":
 "theorem dfinsupp.lex.well_founded_of_finite [is_strict_total_order ι r] [Finite ι] [∀ i, Zero (α i)]\n    (hs : ∀ i, well_founded (s i)) : well_founded (dfinsupp.lex r s) :=\n  have := fintype.of_finite ι\n  inv_image.wf equiv_fun_on_fintype (pi.lex.well_founded r hs)\n#align dfinsupp.lex.well_founded_of_finite dfinsupp.lex.well_founded_of_finite\n\n",
 "well_founded_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\nprotected theorem dfinsupp.well_founded_lt [∀ i, Zero (α i)] [∀ i, preorder (α i)] [∀ i, well_founded_lt (α i)]\n    (hbot : ∀ ⦃i⦄ ⦃a : α i⦄, ¬a < 0) :\n    well_founded_lt\n      («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (α i)) :=\n  ⟨by\n    letI : ∀ i, Zero (Antisymmetrization (α i) (· ≤ ·)) := fun i => ⟨toAntisymmetrization (· ≤ ·) 0⟩\n    let f := map_range (fun i => @toAntisymmetrization (α i) (· ≤ ·) _) fun i => rfl\n    refine' subrelation.wf (fun x y h => _) (inv_image.wf f <| lex.well_founded' _ (fun i => _) _)\n    · exact well_ordering_rel.swap; · exact fun i => (· < ·)\n    · haveI := is_strict_order.swap (@well_ordering_rel ι)\n      obtain ⟨i, he, hl⟩ := lex_lt_of_lt_of_preorder well_ordering_rel.swap h\n      exact ⟨i, fun j hj => quot.sound (he j hj), hl⟩\n    · rintro i ⟨a⟩\n      apply hbot\n    exacts[is_well_founded.wf, is_trichotomous.swap _, is_well_founded.wf]⟩\n#align dfinsupp.well_founded_lt dfinsupp.well_founded_lt\n\n",
 "well_founded'":
 "theorem lex.well_founded' [is_trichotomous ι r] (hr : well_founded r.swap) : well_founded (dfinsupp.lex r s) :=\n  lex.well_founded hbot hs <|\n    subrelation.wf (fun i j h => ((@is_trichotomous.trichotomous ι r _ i j).resolve_left h.1).resolve_left h.2) hr\n#align lex.well_founded' lex.well_founded'\n\n",
 "well_founded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem pi.lex.well_founded [is_strict_total_order ι r] [Finite ι] (hs : ∀ i, well_founded (s i)) :\n    well_founded (Pi.Lex r s) := by\n  obtain h | ⟨⟨x⟩⟩ := isEmpty_or_nonempty (∀ i, α i)\n  · convert empty_wf\n    ext1 x\n    exact (h.1 x).elim\n  letI : ∀ i, Zero (α i) := fun i => ⟨(hs i).min («expr⊤») ⟨x i, trivial⟩⟩\n  haveI := is_trans.swap r; haveI := is_irrefl.swap r; haveI := fintype.of_finite ι\n  refine' inv_image.wf equiv_fun_on_fintype.symm (lex.well_founded' (fun i a => _) hs _)\n  exacts[(hs i).not_lt_min («expr⊤») _ trivial, finite.well_founded_of_trans_of_irrefl r.swap]\n#align pi.lex.well_founded pi.lex.well_founded\n\n",
 "lex_fibration":
 "/-\nCopyright (c) 2022 Junyan Xu. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Junyan Xu\n-/\n/-- This key lemma says that if a finitely supported dependent function `x₀` is obtained by merging\n  two such functions `x₁` and `x₂`, and if we evolve `x₀` down the `dfinsupp.lex` relation one\n  step and get `x`, we can always evolve one of `x₁` and `x₂` down the `dfinsupp.lex` relation\n  one step while keeping the other unchanged, and merge them back (possibly in a different way)\n  to get back `x`. In other words, the two parts evolve essentially independently under\n  `dfinsupp.lex`. This is used to show that a function `x` is accessible if\n  `dfinsupp.single i (x i)` is accessible for each `i` in the (finite) support of `x`\n  (`dfinsupp.lex.acc_of_single`). -/\ntheorem lex_fibration [∀ (i) (s : set ι), decidable (i ∈ s)] :\n    fibration (inv_image (GameAdd (dfinsupp.lex r s) (dfinsupp.lex r s)) snd) (dfinsupp.lex r s) fun x =>\n      piecewise x.2.1 x.2.2 x.1 :=\n  by\n  rintro ⟨p, x₁, x₂⟩ x ⟨i, hr, hs⟩\n  simp_rw [piecewise_apply] at hs hr\n  split_ifs  at hs\n  classical\n    on_goal 1 => refine' ⟨⟨{ j | r j i → j ∈ p }, piecewise x₁ x { j | r j i }, x₂⟩, game_add.fst ⟨i, _⟩, _⟩\n    on_goal 3 => refine' ⟨⟨{ j | r j i ∧ j ∈ p }, x₁, piecewise x₂ x { j | r j i }⟩, game_add.snd ⟨i, _⟩, _⟩\n    pick_goal 3\n    iterate 2 \n      simp_rw [piecewise_apply]\n      refine' ⟨fun j h => if_pos h, _⟩\n      convert hs\n      refine' ite_eq_right_iff.2 fun h' => (hr i h').symm ▸ _\n      first |rw [if_neg h]|rw [if_pos h]\n    all_goals ext j; simp_rw [piecewise_apply]; split_ifs with h₁ h₂\n    · rw [hr j h₂, if_pos (h₁ h₂)]\n    · rfl\n    · rw [Set.mem_setOf, not_imp] at h₁\n      rw [hr j h₁.1, if_neg h₁.2]\n    · rw [hr j h₁.1, if_pos h₁.2]\n    · rw [hr j h₂, if_neg fun h' => h₁ ⟨h₂, h'⟩]\n    · rfl\n#align lex_fibration lex_fibration\n\n",
 "acc_zero":
 "theorem lex.acc_zero : acc (dfinsupp.lex r s) 0 :=\n  acc.intro 0 fun x ⟨_, _, h⟩ => (hbot h).elim\n#align lex.acc_zero lex.acc_zero\n\n",
 "acc_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem lex.acc_single [decidable_eq ι] {i : ι} (hi : acc («expr ⊓ » («expr ᶜ» r) (· ≠ ·)) i) :\n    ∀ a, acc (dfinsupp.lex r s) (single i a) :=\n  by\n  induction' hi with i hi ih\n  refine' fun a => (hs i).induction a fun a ha => _\n  refine' acc.intro _ fun x => _\n  rintro ⟨k, hr, hs⟩\n  classical\n    rw [single_apply] at hs\n    split_ifs  at hs with hik\n    swap\n    · exact (hbot hs).elim\n    subst hik\n    refine' lex.acc_of_single hbot x fun j hj => _\n    obtain rfl | hij := eq_or_ne i j\n    · exact ha _ hs\n    by_cases r j i\n    · rw [hr j h, single_eq_of_ne hij, single_zero]\n      exact lex.acc_zero hbot\n    · exact ih _ ⟨h, hij.symm⟩ _\n#align lex.acc_single lex.acc_single\n\n",
 "acc_of_single_erase":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem lex.acc_of_single_erase [decidable_eq ι]\n    {x : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (α i)}\n    (i : ι) (hs : acc (dfinsupp.lex r s) <| single i (x i)) (hu : acc (dfinsupp.lex r s) <| x.erase i) :\n    acc (dfinsupp.lex r s) x := by\n  classical\n    convert ← @acc.of_fibration _ _ _ _ _ (lex_fibration r s) ⟨{i}, _⟩ (InvImage.accessible snd <| hs.prod_game_add hu)\n    convert piecewise_single_erase x i\n#align lex.acc_of_single_erase lex.acc_of_single_erase\n\n",
 "acc_of_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem lex.acc_of_single [decidable_eq ι] [∀ (i) (x : α i), decidable (x ≠ 0)]\n    (x : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (α i)) :\n    (∀ i ∈ x.support, acc (dfinsupp.lex r s) <| single i (x i)) → acc (dfinsupp.lex r s) x :=\n  by\n  generalize ht : x.support = t; revert x\n  classical\n    induction' t using Finset.induction with b t hb ih\n    · intro x ht\n      rw [support_eq_empty.1 ht]\n      exact fun _ => lex.acc_zero hbot\n    refine' fun x ht h => lex.acc_of_single_erase b (h b <| t.mem_insert_self b) _\n    refine' ih _ (by rw [support_erase, ht, Finset.erase_insert hb]) fun a ha => _\n    rw [erase_ne (ha.ne_of_not_mem hb)]\n    exact h a (Finset.mem_insert_of_mem ha)\n#align lex.acc_of_single lex.acc_of_single\n\n",
 "acc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem lex.acc [decidable_eq ι] [∀ (i) (x : α i), decidable (x ≠ 0)]\n    (x : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (α i))\n    (h : ∀ i ∈ x.support, acc («expr ⊓ » («expr ᶜ» r) (· ≠ ·)) i) : acc (dfinsupp.lex r s) x :=\n  lex.acc_of_single hbot x fun i hi => lex.acc_single hbot hs (h i hi) _\n#align lex.acc lex.acc\n\n"}