{"mem_of_mem_exact":
 "theorem mem_of_mem_exact {lt} [is_irrefl α lt] {x t} : mem_exact x t → mem lt x t :=\n  by\n  induction t <;> simp [mem_exact, mem, false_imp_iff] <;> intro h\n  all_goals\n    cases_type*or.1; simp [t_ih_lchild h]; simp [h, irrefl_of lt t_val]\n    simp [t_ih_rchild h]\n#align mem_of_mem_exact mem_of_mem_exact\n\n",
 "induction":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\n@[elab_without_expected_type]\ntheorem find.induction {p : rbnode α → Prop} (lt) [DecidableRel lt] (t x) (h₁ : p leaf)\n    (h₂ : ∀ (l y r) (h : cmpUsing lt x y = ordering.lt) (ih : p l), p (red_node l y r))\n    (h₃ : ∀ (l y r) (h : cmpUsing lt x y = ordering.eq), p (red_node l y r))\n    (h₄ : ∀ (l y r) (h : cmpUsing lt x y = ordering.gt) (ih : p r), p (red_node l y r))\n    (h₅ : ∀ (l y r) (h : cmpUsing lt x y = ordering.lt) (ih : p l), p (black_node l y r))\n    (h₆ : ∀ (l y r) (h : cmpUsing lt x y = ordering.eq), p (black_node l y r))\n    (h₇ : ∀ (l y r) (h : cmpUsing lt x y = ordering.gt) (ih : p r), p (black_node l y r)) : p t :=\n  by\n  induction t\n  case leaf => assumption\n  case red_node l y r =>\n    cases h : cmpUsing lt x y\n    case lt => apply h₂; assumption; assumption\n    case eq => apply h₃; assumption\n    case gt => apply h₄; assumption; assumption\n  case black_node l y r =>\n    cases h : cmpUsing lt x y\n    case lt => apply h₅; assumption; assumption\n    case eq => apply h₆; assumption\n    case gt => apply h₇; assumption; assumption\n#align find.induction find.induction\n\n",
 "find_eq_find_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_eq_find_of_eqv {lt a b} [DecidableRel lt] [is_strict_weak_order α lt] {t : rbnode α} :\n    ∀ {lo hi} (hs : is_searchable lt t lo hi) (heqv : «expr ≈[ ] » a lt b), find lt t a = find lt t b :=\n  by\n  apply find.induction lt t a <;> intros <;> simp_all [mem, find, strict_weak_order.equiv, true_imp_iff]\n  iterate 2\n    \n    · have : lt b y := lt_of_incomp_of_lt heqv.swap h\n      simp [cmpUsing, find, *]\n      cases hs\n      apply ih hs_hs₁\n    · have := incomp_trans_of lt heqv.swap h\n      simp [cmpUsing, find, *]\n    · have := lt_of_lt_of_incomp h heqv\n      have := not_lt_of_lt this\n      simp [cmpUsing, find, *]\n      cases hs\n      apply ih hs_hs₂\n#align find_eq_find_of_eqv find_eq_find_of_eqv\n\n",
 "find_correct_exact":
 "theorem find_correct_exact {t : rbnode α} {lt x} [DecidableRel lt] [is_strict_weak_order α lt] :\n    ∀ {lo hi} (hs : is_searchable lt t lo hi), mem_exact x t ↔ find lt t x = some x :=\n  by\n  apply find.induction lt t x <;> intros <;> simp only [mem_exact, find, *]\n  iterate 2\n    \n    · cases hs\n      apply iff.intro\n      · intro hm\n        cases_type*or.1\n        · exact Iff.mp (ih hs_hs₁) hm\n        · simp at h\n          subst x\n          exact absurd h (irrefl y)\n        · have hyx : lift lt (some y) (some x) := (range hs_hs₂ (mem_of_mem_exact hm)).1\n          simp [lift] at hyx\n          have hxy : lt x y := by\n            simp [cmpUsing] at h\n            assumption\n          exact absurd (trans_of lt hxy hyx) (irrefl_of lt x)\n      · intro hc\n        left\n        exact Iff.mpr (ih hs_hs₁) hc\n    · simp at h\n      cases hs\n      apply iff.intro\n      · intro hm\n        cases_type*or.1\n        · have hxy : lift lt (some x) (some y) := (range hs_hs₁ (mem_of_mem_exact hm)).2\n          simp [lift] at hxy\n          exact absurd hxy h.1\n        · subst hm\n        · have hyx : lift lt (some y) (some x) := (range hs_hs₂ (mem_of_mem_exact hm)).1\n          simp [lift] at hyx\n          exact absurd hyx h.2\n      · intro hm\n        simp [*]\n    · cases hs\n      apply iff.intro\n      · intro hm\n        cases_type*or.1\n        · have hxy : lift lt (some x) (some y) := (range hs_hs₁ (mem_of_mem_exact hm)).2\n          simp [lift] at hxy\n          have hyx : lt y x := by\n            simp [cmpUsing] at h\n            exact h.2\n          exact absurd (trans_of lt hxy hyx) (irrefl_of lt x)\n        · simp at h\n          subst x\n          exact absurd h (irrefl y)\n        · exact Iff.mp (ih hs_hs₂) hm\n      · intro hc\n        right\n        right\n        exact Iff.mpr (ih hs_hs₂) hc\n#align find_correct_exact find_correct_exact\n\n",
 "find_correct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_correct {t : rbnode α} {lt x} [DecidableRel lt] [is_strict_weak_order α lt] :\n    ∀ {lo hi} (hs : is_searchable lt t lo hi), mem lt x t ↔ ∃ y, find lt t x = some y ∧ «expr ≈[ ] » x lt y :=\n  by\n  apply find.induction lt t x <;> intros <;> simp only [mem, find, *]\n  · simp\n  iterate 2\n    \n    -- red and black cases are identical\n    · cases hs\n      apply iff.intro\n      · intro hm\n        cases_type*or.1\n        · exact Iff.mp (ih hs_hs₁) hm\n        · simp at h\n          cases hm\n          contradiction\n        · have hyx : lift lt (some y) (some x) := (range hs_hs₂ hm).1\n          simp [lift] at hyx\n          have hxy : lt x y := by\n            simp [cmpUsing] at h\n            assumption\n          exact absurd (trans_of lt hxy hyx) (irrefl_of lt x)\n      · intro hc\n        left\n        exact Iff.mpr (ih hs_hs₁) hc\n    · simp at h\n      simp [h, strict_weak_order.equiv]\n    · cases hs\n      apply iff.intro\n      · intro hm\n        cases_type*or.1\n        · have hxy : lift lt (some x) (some y) := (range hs_hs₁ hm).2\n          simp [lift] at hxy\n          have hyx : lt y x := by\n            simp [cmpUsing] at h\n            exact h.2\n          exact absurd (trans_of lt hxy hyx) (irrefl_of lt x)\n        · simp at h\n          cases hm\n          contradiction\n        · exact Iff.mp (ih hs_hs₂) hm\n      · intro hc\n        right\n        right\n        exact Iff.mpr (ih hs_hs₂) hc\n#align find_correct find_correct\n\n",
 "eqv_of_find_some":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem eqv_of_find_some {t : rbnode α} {lt x y} [DecidableRel lt] :\n    ∀ {lo hi} (hs : is_searchable lt t lo hi) (he : find lt t x = some y), «expr ≈[ ] » x lt y :=\n  by\n  apply find.induction lt t x <;> intros <;> simp_all only [mem, find]\n  iterate 2\n    \n    · cases hs\n      exact ih hs_hs₁ rfl\n    · subst y\n      simp at h\n      exact h\n    · cases hs\n      exact ih hs_hs₂ rfl\n#align eqv_of_find_some eqv_of_find_some\n\n"}