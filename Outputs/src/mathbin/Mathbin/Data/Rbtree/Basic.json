{"upper_le":
 "private theorem upper_le : ∀ c n, upper c n ≤ 2 * n + 1\n  | red, n => le_refl _\n  | black, n => by apply le_succ\n#align upper_le upper_le\n\n",
 "range":
 "theorem range [is_strict_weak_order α lt] {t : rbnode α} {x} :\n    ∀ {lo hi}, is_searchable lt t lo hi → mem lt x t → lift lt lo (some x) ∧ lift lt (some x) hi := by\n  classical\n    induction t\n    case leaf => simp [mem]\n    all_goals\n      -- red_node and black_node are identical\n      intro lo hi h₁ h₂\n      cases h₁\n      simp only [mem] at h₂\n      have val_hi : lift lt (some t_val) hi := by\n        apply lo_lt_hi\n        assumption\n      have lo_val : lift lt lo (some t_val) := by\n        apply lo_lt_hi\n        assumption\n      cases_type*or.1\n      · have h₃ : lift lt lo (some x) ∧ lift lt (some x) (some t_val) :=\n          by\n          apply t_ih_lchild\n          assumption\n          assumption\n        cases' h₃ with lo_x x_val\n        constructor\n        show lift lt lo (some x)\n        · assumption\n        show lift lt (some x) hi\n        · cases' hi with hi <;> simp [lift] at *\n          apply trans_of lt x_val val_hi\n      · cases h₂\n        cases' lo with lo <;> cases' hi with hi <;> simp [lift] at *\n        · apply lt_of_incomp_of_lt _ val_hi\n          simp [*]\n        · apply lt_of_lt_of_incomp lo_val\n          simp [*]\n        constructor\n        · apply lt_of_lt_of_incomp lo_val\n          simp [*]\n        · apply lt_of_incomp_of_lt _ val_hi\n          simp [*]\n      · have h₃ : lift lt (some t_val) (some x) ∧ lift lt (some x) hi :=\n          by\n          apply t_ih_rchild\n          assumption\n          assumption\n        cases' h₃ with val_x x_hi\n        cases' lo with lo <;> cases' hi with hi <;> simp [lift] at *\n        · assumption\n        · apply trans_of lt lo_val val_x\n        constructor\n        · apply trans_of lt lo_val val_x\n        · assumption\n#align range range\n\n",
 "lt_of_mem_right":
 "theorem lt_of_mem_right [is_strict_weak_order α lt] {y : α} {t l r : rbnode α} :\n    ∀ {lo hi}, is_searchable lt t lo hi → is_node_of t l y r → ∀ {z}, mem lt z r → lt y z :=\n  by\n  intro _ _ hs hn z hm; cases hn <;> cases hs\n  all_goals exact (range hs_hs₂ hm).1\n#align lt_of_mem_right lt_of_mem_right\n\n",
 "lt_of_mem_left_right":
 "theorem lt_of_mem_left_right [is_strict_weak_order α lt] {y : α} {t l r : rbnode α} :\n    ∀ {lo hi}, is_searchable lt t lo hi → is_node_of t l y r → ∀ {x z}, mem lt x l → mem lt z r → lt x z :=\n  by\n  intro _ _ hs hn x z hm₁ hm₂; cases hn <;> cases hs\n  all_goals\n    have h₁ := range hs_hs₁ hm₁\n    have h₂ := range hs_hs₂ hm₂\n    exact trans_of lt h₁.2 h₂.1\n#align lt_of_mem_left_right lt_of_mem_left_right\n\n",
 "lt_of_mem_left":
 "theorem lt_of_mem_left [is_strict_weak_order α lt] {y : α} {t l r : rbnode α} :\n    ∀ {lo hi}, is_searchable lt t lo hi → is_node_of t l y r → ∀ {x}, mem lt x l → lt x y :=\n  by\n  intro _ _ hs hn x hm; cases hn <;> cases hs\n  all_goals exact (range hs_hs₁ hm).2\n#align lt_of_mem_left lt_of_mem_left\n\n",
 "lo_lt_hi":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\ntheorem lo_lt_hi {t : rbnode α} {lt} [is_trans α lt] : ∀ {lo hi}, is_searchable lt t lo hi → lift lt lo hi :=\n  by\n  induction t <;> intro lo hi hs\n  case leaf => cases hs; assumption\n  all_goals\n    cases hs\n    have h₁ := t_ih_lchild hs_hs₁\n    have h₂ := t_ih_rchild hs_hs₂\n    cases lo <;> cases hi <;> simp [lift] at *\n    apply trans_of lt h₁ h₂\n#align lo_lt_hi lo_lt_hi\n\n",
 "is_searchable_some_low_of_is_searchable_of_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_some_low_of_is_searchable_of_lt {t} [is_trans α lt] :\n    ∀ {lo hi lo'} (hlt : lt lo' lo) (hs : is_searchable lt t (some lo) hi), is_searchable lt t (some lo') hi :=\n  by\n  induction t <;> intros <;>\n    run_tac\n      is_searchable_tactic\n  · cases hi <;> simp_all [lift]\n    apply trans_of lt hlt\n    assumption\n  all_goals apply t_ih_lchild hlt hs_hs₁\n#align is_searchable_some_low_of_is_searchable_of_lt is_searchable_some_low_of_is_searchable_of_lt\n\n",
 "is_searchable_some_high_of_is_searchable_of_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_some_high_of_is_searchable_of_lt {t} [is_trans α lt] :\n    ∀ {lo hi hi'} (hlt : lt hi hi') (hs : is_searchable lt t lo (some hi)), is_searchable lt t lo (some hi') :=\n  by\n  induction t <;> intros <;>\n    run_tac\n      is_searchable_tactic\n  · cases lo <;> simp_all [lift]\n    apply trans_of lt\n    assumption\n    assumption\n  all_goals apply t_ih_rchild hlt hs_hs₂\n#align is_searchable_some_high_of_is_searchable_of_lt is_searchable_some_high_of_is_searchable_of_lt\n\n",
 "is_searchable_of_is_searchable_of_incomp":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_of_is_searchable_of_incomp [is_strict_weak_order α lt] {t} :\n    ∀ {lo hi hi'} (hc : ¬lt hi' hi ∧ ¬lt hi hi') (hs : is_searchable lt t lo (some hi)),\n      is_searchable lt t lo (some hi') :=\n  by\n  classical\n    induction t <;> intros <;>\n      run_tac\n        is_searchable_tactic\n    · cases lo <;> simp_all [lift]\n      apply lt_of_lt_of_incomp\n      assumption\n      exact ⟨hc.2, hc.1⟩\n    all_goals apply t_ih_rchild hc hs_hs₂\n#align is_searchable_of_is_searchable_of_incomp is_searchable_of_is_searchable_of_incomp\n\n",
 "is_searchable_of_incomp_of_is_searchable":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_of_incomp_of_is_searchable [is_strict_weak_order α lt] {t} :\n    ∀ {lo lo' hi} (hc : ¬lt lo' lo ∧ ¬lt lo lo') (hs : is_searchable lt t (some lo) hi),\n      is_searchable lt t (some lo') hi :=\n  by\n  classical\n    induction t <;> intros <;>\n      run_tac\n        is_searchable_tactic\n    · cases hi <;> simp_all [lift]\n      apply lt_of_incomp_of_lt\n      assumption\n      assumption\n    all_goals apply t_ih_lchild hc hs_hs₁\n#align is_searchable_of_incomp_of_is_searchable is_searchable_of_incomp_of_is_searchable\n\n",
 "is_searchable_none_low_of_is_searchable_some_low":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_none_low_of_is_searchable_some_low {t} :\n    ∀ {y hi} (hlt : is_searchable lt t (some y) hi), is_searchable lt t none hi :=\n  by\n  induction t <;> intros <;>\n    run_tac\n      is_searchable_tactic\n  · simp [lift]\n  all_goals apply t_ih_lchild hlt_hs₁\n#align is_searchable_none_low_of_is_searchable_some_low is_searchable_none_low_of_is_searchable_some_low\n\n",
 "is_searchable_none_high_of_is_searchable_some_high":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_none_high_of_is_searchable_some_high {t} :\n    ∀ {lo y} (hlt : is_searchable lt t lo (some y)), is_searchable lt t lo none :=\n  by\n  induction t <;> intros <;>\n    run_tac\n      is_searchable_tactic\n  · cases lo <;> simp [lift]\n  all_goals apply t_ih_rchild hlt_hs₂\n#align is_searchable_none_high_of_is_searchable_some_high is_searchable_none_high_of_is_searchable_some_high\n\n",
 "depth_min":
 "theorem depth_min : ∀ {c n} {t : rbnode α}, is_red_black t c n → n ≤ depth min t :=\n  by\n  intro c n' t h\n  induction h\n  case leaf_rb => exact le_refl _\n  case red_rb =>\n    simp [depth]\n    have : min (depth min h_l) (depth min h_r) ≥ h_n := by apply le_min <;> assumption\n    apply le_succ_of_le\n    assumption\n  case black_rb =>\n    simp [depth]\n    apply succ_le_succ\n    apply le_min <;> assumption\n#align depth_min depth_min\n\n",
 "depth_max'":
 "theorem depth_max' : ∀ {c n} {t : rbnode α}, is_red_black t c n → depth max t ≤ upper c n :=\n  by\n  intro c n' t h\n  induction h\n  case leaf_rb => simp [max, depth, upper, nat.mul_zero]\n  case red_rb =>\n    suffices succ (max (depth max h_l) (depth max h_r)) ≤ 2 * h_n + 1 by simp_all [depth, upper]\n    apply succ_le_succ\n    apply max_le <;> assumption\n  case black_rb =>\n    have : depth max h_l ≤ 2 * h_n + 1 := le_trans h_ih_rb_l (upper_le _ _)\n    have : depth max h_r ≤ 2 * h_n + 1 := le_trans h_ih_rb_r (upper_le _ _)\n    suffices new : max (depth max h_l) (depth max h_r) + 1 ≤ 2 * h_n + 2 * 1\n    · simp_all [depth, upper, succ_eq_add_one, nat.left_distrib]\n    apply succ_le_succ\n    apply max_le <;> assumption\n#align depth_max' depth_max'\n\n",
 "depth_max":
 "theorem depth_max {c n} {t : rbnode α} (h : is_red_black t c n) : depth max t ≤ 2 * n + 1 :=\n  le_trans (depth_max' h) (upper_le _ _)\n#align depth_max depth_max\n\n",
 "Balanced":
 "#print Balanced /-\ntheorem Balanced {c n} {t : rbnode α} (h : is_red_black t c n) : depth max t ≤ 2 * depth min t + 1 :=\n  by\n  have : 2 * depth min t + 1 ≥ 2 * n + 1 := by\n    apply succ_le_succ\n    apply nat.mul_le_mul_left\n    apply depth_min h\n  apply le_trans\n  apply depth_max h\n  apply this\n#align balanced Balanced\n-/\n\n"}