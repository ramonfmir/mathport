{"min_is_minimal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem min_is_minimal {a : α} {t : rbnode α} :\n    ∀ {lo hi}, is_searchable lt t lo hi → t.min = some a → ∀ {b}, mem lt b t → «expr ≈[ ] » a lt b ∨ lt a b := by\n  classical\n    induction t\n    · simp [strict_weak_order.equiv]\n      intro _ _ hs hmin b\n      contradiction\n    all_goals\n      cases t_lchild <;> intro lo hi hs hmin b hmem\n      · simp [rbnode.min] at hmin\n        subst t_val\n        simp [mem] at hmem\n        cases' hmem with heqv hmem\n        · left\n          exact heqv.swap\n        · have := lt_of_mem_right hs (by constructor) hmem\n          right\n          assumption\n      all_goals\n        have hs' := hs\n        cases hs; simp [rbnode.min] at hmin\n        rw [mem] at hmem; cases_type*or.1\n        · exact t_ih_lchild hs_hs₁ hmin hmem\n        · have hmm := mem_of_min_eq lt hmin\n          have a_lt_val := lt_of_mem_left hs' (by constructor) hmm\n          have a_lt_b := lt_of_lt_of_incomp a_lt_val hmem.swap\n          right\n          assumption\n        · have hmm := mem_of_min_eq lt hmin\n          have a_lt_b := lt_of_mem_left_right hs' (by constructor) hmm hmem\n          right\n          assumption\n#align min_is_minimal min_is_minimal\n\n",
 "mem_of_min_eq":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\ntheorem mem_of_min_eq (lt : α → α → Prop) [is_irrefl α lt] {a : α} {t : rbnode α} : t.min = some a → mem lt a t :=\n  by\n  induction t\n  · intros\n    contradiction\n  all_goals\n    cases t_lchild <;> simp [rbnode.min] <;> intro h\n    · subst t_val\n      simp [mem, irrefl_of lt a]\n    all_goals rw [mem]; simp [t_ih_lchild h]\n#align mem_of_min_eq mem_of_min_eq\n\n",
 "mem_of_max_eq":
 "theorem mem_of_max_eq (lt : α → α → Prop) [is_irrefl α lt] {a : α} {t : rbnode α} : t.max = some a → mem lt a t :=\n  by\n  induction t\n  · intros\n    contradiction\n  all_goals\n    cases t_rchild <;> simp [rbnode.max] <;> intro h\n    · subst t_val\n      simp [mem, irrefl_of lt a]\n    all_goals rw [mem]; simp [t_ih_rchild h]\n#align mem_of_max_eq mem_of_max_eq\n\n",
 "max_is_maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem max_is_maximal {a : α} {t : rbnode α} :\n    ∀ {lo hi}, is_searchable lt t lo hi → t.max = some a → ∀ {b}, mem lt b t → «expr ≈[ ] » a lt b ∨ lt b a := by\n  classical\n    induction t\n    · simp [strict_weak_order.equiv]\n      intro _ _ hs hmax b\n      contradiction\n    all_goals\n      cases t_rchild <;> intro lo hi hs hmax b hmem\n      · simp [rbnode.max] at hmax\n        subst t_val\n        simp [mem] at hmem\n        cases' hmem with hmem heqv\n        · have := lt_of_mem_left hs (by constructor) hmem\n          right\n          assumption\n        · left\n          exact heqv.swap\n      all_goals\n        have hs' := hs\n        cases hs; simp [rbnode.max] at hmax\n        rw [mem] at hmem; cases_type*or.1\n        · have hmm := mem_of_max_eq lt hmax\n          have a_lt_b := lt_of_mem_left_right hs' (by constructor) hmem hmm\n          right\n          assumption\n        · have hmm := mem_of_max_eq lt hmax\n          have val_lt_a := lt_of_mem_right hs' (by constructor) hmm\n          have a_lt_b := lt_of_incomp_of_lt hmem val_lt_a\n          right\n          assumption\n        · exact t_ih_rchild hs_hs₂ hmax hmem\n#align max_is_maximal max_is_maximal\n\n",
 "eq_leaf_of_min_eq_none":
 "theorem eq_leaf_of_min_eq_none {t : rbnode α} : t.min = none → t = leaf :=\n  by\n  induction t\n  · intros\n    rfl\n  all_goals\n    cases t_lchild <;> simp [rbnode.min, false_imp_iff] <;> intro h\n    all_goals have := t_ih_lchild h; contradiction\n#align eq_leaf_of_min_eq_none eq_leaf_of_min_eq_none\n\n",
 "eq_leaf_of_max_eq_none":
 "theorem eq_leaf_of_max_eq_none {t : rbnode α} : t.max = none → t = leaf :=\n  by\n  induction t\n  · intros\n    rfl\n  all_goals\n    cases t_rchild <;> simp [rbnode.max, false_imp_iff] <;> intro h\n    all_goals have := t_ih_rchild h; contradiction\n#align eq_leaf_of_max_eq_none eq_leaf_of_max_eq_none\n\n"}