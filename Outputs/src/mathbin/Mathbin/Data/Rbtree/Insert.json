{"weak_trichotomous":
 "theorem weak_trichotomous (x y) {p : Prop} (is_lt : ∀ h : lt x y, p) (is_eqv : ∀ h : ¬lt x y ∧ ¬lt y x, p)\n    (is_gt : ∀ h : lt y x, p) : p := by\n  by_cases lt x y\n  · apply is_lt\n    assumption\n  by_cases lt y x\n  · apply is_gt\n    assumption\n  · apply is_eqv\n    constructor <;> assumption\n#align weak_trichotomous weak_trichotomous\n\n",
 "of_mem_balance2_node":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem of_mem_balance2_node {x s v t} : mem x (balance2_node s v t) → mem x s ∨ ¬lt x v ∧ ¬lt v x ∨ mem x t :=\n  by\n  cases s <;> simp\n  · intros\n    simp [*]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp_all <;> cases_type*or.1 <;> simp [*]\n#align of_mem_balance2_node of_mem_balance2_node\n\n",
 "of_mem_balance1_node":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem of_mem_balance1_node {x s v t} : mem x (balance1_node s v t) → mem x s ∨ ¬lt x v ∧ ¬lt v x ∨ mem x t :=\n  by\n  cases s <;> simp\n  · intros\n    simp [*]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp_all <;> cases_type*or.1 <;> simp [*]\n#align of_mem_balance1_node of_mem_balance1_node\n\n",
 "of_get_color_ne_red":
 "theorem of_get_color_ne_red {t : rbnode α} {c n} : get_color t ≠ red → is_red_black t c n → c = black := by intro h₁ h₂;\n  cases h₂ <;> simp only [get_color] at h₁ <;> contradiction\n#align of_get_color_ne_red of_get_color_ne_red\n\n",
 "of_get_color_eq_red":
 "theorem of_get_color_eq_red {t : rbnode α} {c n} : get_color t = red → is_red_black t c n → c = red := by intro h₁ h₂;\n  cases h₂ <;> simp only [get_color] at h₁ <;> contradiction\n#align of_get_color_eq_red of_get_color_eq_red\n\n",
 "mem_of_mem_mk_insert_result":
 "theorem mem_of_mem_mk_insert_result {a t c} : mem lt a (mk_insert_result c t) → mem lt a t := by\n  cases t <;> cases c <;> simp [mk_insert_result, mem] <;> intros <;> assumption\n#align mem_of_mem_mk_insert_result mem_of_mem_mk_insert_result\n\n",
 "mem_mk_insert_result":
 "theorem mem_mk_insert_result {a t} (c) : mem lt a t → mem lt a (mk_insert_result c t) := by\n  intros <;> cases c <;> cases t <;> simp_all [mk_insert_result, mem]\n#align mem_mk_insert_result mem_mk_insert_result\n\n",
 "mem_insert_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_insert_of_mem [decidable_rel lt] [is_strict_weak_order α lt] {t x} (z) : mem x t → mem x (t.insert lt z) :=\n  by intros <;> apply mem_mk_insert_result <;> apply mem_ins_of_mem <;> assumption\n#align mem_insert_of_mem mem_insert_of_mem\n\n",
 "mem_insert_of_incomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_insert_of_incomp [decidable_rel lt] (t : rbnode α) {x y : α} :\n    ∀ h : ¬lt x y ∧ ¬lt y x, mem x (t.insert lt y) := by\n  intros <;> unfold insert <;> apply mem_mk_insert_result <;> apply mem_ins_of_incomp <;> assumption\n#align mem_insert_of_incomp mem_insert_of_incomp\n\n",
 "mem_ins_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_ins_of_mem [decidable_rel lt] [is_strict_weak_order α lt] {t : rbnode α} (z : α) :\n    ∀ {x} (h : mem x t), mem x (t.ins lt z) :=\n  by\n  apply ins.induction lt t z <;> intros <;> simp_all [ins] <;> try contradiction <;> cases_type*or.1\n  any_goals intros ; simp [h]; done\n  any_goals intros ; simp [ih h]; done\n  · have := incomp_trans_of lt h ⟨hc.2, hc.1⟩\n    simp [this]\n  · apply mem_balance1_node_of_mem_left\n    apply ih h\n  · apply mem_balance1_node_of_incomp\n    cases h\n    all_goals simp [*, ins_ne_leaf lt a z]\n  · apply mem_balance1_node_of_mem_right\n    assumption\n  · have := incomp_trans_of lt hc ⟨h.2, h.1⟩\n    simp [this]\n  · apply mem_balance2_node_of_mem_right\n    assumption\n  · have := ins_ne_leaf lt a z\n    apply mem_balance2_node_of_incomp\n    cases h\n    simp [*]\n    apply ins_ne_leaf\n  · apply mem_balance2_node_of_mem_left\n    apply ih h\n#align mem_ins_of_mem mem_ins_of_mem\n\n",
 "mem_ins_of_incomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_ins_of_incomp [decidable_rel lt] (t : rbnode α) {x y : α} : ∀ h : ¬lt x y ∧ ¬lt y x, mem x (t.ins lt y) :=\n  by\n  apply ins.induction lt t y <;> intros <;> simp [ins, *]\n  · have := ih h\n    apply mem_balance1_node_of_mem_left\n    assumption\n  · have := ih h\n    apply mem_balance2_node_of_mem_left\n    assumption\n#align mem_ins_of_incomp mem_ins_of_incomp\n\n",
 "mem_exact_balance2_node_of_mem_exact":
 "theorem mem_exact_balance2_node_of_mem_exact {x s} (v) (t : rbnode α) :\n    mem_exact x s → mem_exact x (balance2_node s v t) :=\n  by\n  cases s <;> simp [false_imp_iff]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp_all <;> cases_type*or.1 <;> simp [*]\n#align mem_exact_balance2_node_of_mem_exact mem_exact_balance2_node_of_mem_exact\n\n",
 "mem_exact_balance1_node_of_mem_exact":
 "theorem mem_exact_balance1_node_of_mem_exact {x s} (v) (t : rbnode α) :\n    mem_exact x s → mem_exact x (balance1_node s v t) :=\n  by\n  cases s <;> simp [false_imp_iff]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp_all <;> cases_type*or.1 <;> simp [*]\n#align mem_exact_balance1_node_of_mem_exact mem_exact_balance1_node_of_mem_exact\n\n",
 "mem_balance2_node_of_mem_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_balance2_node_of_mem_right {x t} (v) (s : rbnode α) : mem x t → mem x (balance2_node s v t) :=\n  by\n  intros ; cases s <;> simp [*]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]\n#align mem_balance2_node_of_mem_right mem_balance2_node_of_mem_right\n\n",
 "mem_balance2_node_of_mem_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_balance2_node_of_mem_left {x s} (v) (t : rbnode α) : mem x s → mem x (balance2_node s v t) :=\n  by\n  cases s <;> simp [false_imp_iff]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp at * <;> cases_type*or.1 <;> simp [*]\n#align mem_balance2_node_of_mem_left mem_balance2_node_of_mem_left\n\n",
 "mem_balance2_node_of_incomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_balance2_node_of_incomp {x v} (s t) : ¬lt v x ∧ ¬lt x v → s ≠ leaf → mem x (balance2_node s v t) :=\n  by\n  intros ; cases s <;> simp\n  · contradiction\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]\n#align mem_balance2_node_of_incomp mem_balance2_node_of_incomp\n\n",
 "mem_balance1_node_of_mem_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_balance1_node_of_mem_right {x t} (v) (s : rbnode α) : mem x t → mem x (balance1_node s v t) :=\n  by\n  intros ; cases s <;> simp [*]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]\n#align mem_balance1_node_of_mem_right mem_balance1_node_of_mem_right\n\n",
 "mem_balance1_node_of_mem_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_balance1_node_of_mem_left {x s} (v) (t : rbnode α) : mem x s → mem x (balance1_node s v t) :=\n  by\n  cases s <;> simp [false_imp_iff]\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp at * <;> cases_type*or.1 <;> simp [*]\n#align mem_balance1_node_of_mem_left mem_balance1_node_of_mem_left\n\n",
 "mem_balance1_node_of_incomp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem mem_balance1_node_of_incomp {x v} (s t) : ¬lt x v ∧ ¬lt v x → s ≠ leaf → mem x (balance1_node s v t) :=\n  by\n  intros ; cases s <;> simp\n  · contradiction\n  all_goals apply balance.cases s_lchild s_val s_rchild <;> intros <;> simp [*]\n#align mem_balance1_node_of_incomp mem_balance1_node_of_incomp\n\n",
 "ite_eq_of_not_lt":
 "-- Auxiliary lemma\ntheorem ite_eq_of_not_lt [decidable_rel lt] [is_strict_order α lt] {a b} {β : Type v} (t s : β) (h : lt b a) :\n    (if lt a b then t else s) = s := by have := not_lt_of_lt h; simp [*]\n#align ite_eq_of_not_lt ite_eq_of_not_lt\n\n",
 "is_searchable_mk_insert_result":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_mk_insert_result {c t} :\n    is_searchable lt t none none → is_searchable lt (mk_insert_result c t) none none := by\n  classical\n    cases c <;> cases t <;> simp [mk_insert_result]\n    · intro h\n      run_tac\n        is_searchable_tactic\n#align is_searchable_mk_insert_result is_searchable_mk_insert_result\n\n",
 "is_searchable_insert":
 "theorem is_searchable_insert [decidable_rel lt] {t x} [is_strict_weak_order α lt] :\n    is_searchable lt t none none → is_searchable lt (insert lt t x) none none := by intro h; simp [insert];\n  apply is_searchable_mk_insert_result; apply is_searchable_ins <;> · first |assumption|simp\n#align is_searchable_insert is_searchable_insert\n\n",
 "is_searchable_ins":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_ins [decidable_rel lt] {t x} [is_strict_weak_order α lt] :\n    ∀ {lo hi} (h : is_searchable lt t lo hi),\n      lift lt lo (some x) → lift lt (some x) hi → is_searchable lt (ins lt t x) lo hi :=\n  by\n  apply ins.induction lt t x <;> intros <;> simp_all! (config := { eta := false }) <;>\n    run_tac\n      is_searchable_tactic\n  · apply ih h_hs₁\n    assumption\n    simp [*]\n  · apply is_searchable_of_is_searchable_of_incomp hc\n    assumption\n  · apply is_searchable_of_incomp_of_is_searchable hc\n    assumption\n  · apply ih h_hs₂\n    cases hi <;> simp [*]\n    assumption\n  · apply is_searchable_balance1_node\n    apply ih h_hs₁\n    assumption\n    simp [*]\n    assumption\n  · apply ih h_hs₁\n    assumption\n    simp [*]\n  · apply is_searchable_of_is_searchable_of_incomp hc\n    assumption\n  · apply is_searchable_of_incomp_of_is_searchable hc\n    assumption\n  · apply is_searchable_balance2_node\n    assumption\n    apply ih h_hs₂\n    simp [*]\n    assumption\n  · apply ih h_hs₂\n    assumption\n    simp [*]\n#align is_searchable_ins is_searchable_ins\n\n",
 "is_searchable_balance2_node":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_balance2_node {t} [is_trans α lt] :\n    ∀ {y s lo hi},\n      is_searchable lt s lo (some y) → is_searchable lt t (some y) hi → is_searchable lt (balance2_node t y s) lo hi :=\n  by\n  induction t <;> simp! <;> intros <;>\n    run_tac\n      is_searchable_tactic\n  · cases hi\n    · apply is_searchable_none_high_of_is_searchable_some_high\n      assumption\n    · simp at *\n      apply is_searchable_some_high_of_is_searchable_of_lt\n      assumption'\n  all_goals apply is_searchable_balance2; assumption'\n#align is_searchable_balance2_node is_searchable_balance2_node\n\n",
 "is_searchable_balance2":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_balance2 {l y r v t lo hi} :\n    is_searchable lt t lo (some v) →\n      is_searchable lt l (some v) (some y) →\n        is_searchable lt r (some y) hi → is_searchable lt (balance2 l y r v t) lo hi :=\n  by\n  apply balance.cases l y r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n#align is_searchable_balance2 is_searchable_balance2\n\n",
 "is_searchable_balance1_node":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_balance1_node {t} [is_trans α lt] :\n    ∀ {y s lo hi},\n      is_searchable lt t lo (some y) → is_searchable lt s (some y) hi → is_searchable lt (balance1_node t y s) lo hi :=\n  by\n  cases t <;> simp! <;> intros <;>\n    run_tac\n      is_searchable_tactic\n  · cases lo\n    · apply is_searchable_none_low_of_is_searchable_some_low\n      assumption\n    · simp at *\n      apply is_searchable_some_low_of_is_searchable_of_lt <;> assumption\n  all_goals apply is_searchable_balance1 <;> assumption\n#align is_searchable_balance1_node is_searchable_balance1_node\n\n",
 "is_searchable_balance1":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem is_searchable_balance1 {l y r v t lo hi} :\n    is_searchable lt l lo (some y) →\n      is_searchable lt r (some y) (some v) →\n        is_searchable lt t (some v) hi → is_searchable lt (balance1 l y r v t) lo hi :=\n  by\n  apply balance.cases l y r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n#align is_searchable_balance1 is_searchable_balance1\n\n",
 "insert_rb":
 "theorem insert_rb {t : rbnode α} (x) {c n} (h : is_red_black t c n) : insert_rb_result (insert lt t x) c n :=\n  by\n  simp [insert]\n  have hi := ins_rb lt x h\n  generalize he : ins lt t x = r\n  simp [he] at hi\n  cases h <;> simp [get_color, ins_rb_result, insert_rb_result, mk_insert_result] at *\n  assumption'\n  · cases hi\n    simp [mk_insert_result]\n    constructor <;> assumption\n#align insert_rb insert_rb\n\n",
 "insert_ne_leaf":
 "theorem insert_ne_leaf [decidable_rel lt] (t : rbnode α) (x : α) : insert lt t x ≠ leaf :=\n  by\n  simp [insert]\n  cases he : ins lt t x <;> cases get_color t <;> simp [mk_insert_result]\n  · have := ins_ne_leaf lt t x\n    contradiction\n  · exact absurd he (ins_ne_leaf _ _ _)\n#align insert_ne_leaf insert_ne_leaf\n\n",
 "insert_is_red_black":
 "theorem insert_is_red_black {t : rbnode α} {c n} (x) : is_red_black t c n → ∃ c n, is_red_black (insert lt t x) c n :=\n  by\n  intro h\n  have := insert_rb lt x h\n  cases c <;> simp [insert_rb_result] at this\n  · constructor\n    constructor\n    assumption\n  · cases this\n    constructor\n    constructor\n    assumption\n#align insert_is_red_black insert_is_red_black\n\n",
 "ins_rb":
 "theorem ins_rb {t : rbnode α} (x) : ∀ {c n} (h : is_red_black t c n), ins_rb_result (ins lt t x) c n :=\n  by\n  apply ins.induction lt t x <;> intros <;> cases h <;> simp [ins, *, ins_rb_result]\n  · repeat' constructor\n  · specialize ih h_rb_l\n    cases ih\n    constructor <;> assumption\n  · constructor <;> assumption\n  · specialize ih h_rb_r\n    cases ih\n    constructor <;> assumption\n  · specialize ih h_rb_l\n    cases of_get_color_eq_red hr h_rb_l\n    apply balance1_node_rb <;> assumption\n  · specialize ih h_rb_l\n    cases of_get_color_ne_red hnr h_rb_l\n    cases ih\n    constructor\n    constructor <;> assumption\n  · constructor\n    constructor <;> assumption\n  · specialize ih h_rb_r\n    cases of_get_color_eq_red hr h_rb_r\n    apply balance2_node_rb <;> assumption\n  · specialize ih h_rb_r\n    cases of_get_color_ne_red hnr h_rb_r\n    cases ih\n    constructor\n    constructor <;> assumption\n#align ins_rb ins_rb\n\n",
 "ins_ne_leaf":
 "theorem ins_ne_leaf [decidable_rel lt] (t : rbnode α) (x : α) : t.ins lt x ≠ leaf :=\n  by\n  apply ins.induction lt t x\n  any_goals intros ; simp [ins, *]\n  · intros\n    apply balance1_node_ne_leaf\n    assumption\n  · intros\n    apply balance2_node_ne_leaf\n    assumption\n#align ins_ne_leaf ins_ne_leaf\n\n",
 "induction":
 "@[elab_as_elim]\ntheorem ins.induction [decidable_rel lt] {p : rbnode α → Prop} (t x) (is_leaf : p leaf)\n    (is_red_lt : ∀ (a y b) (hc : cmpUsing lt x y = ordering.lt) (ih : p a), p (red_node a y b))\n    (is_red_eq : ∀ (a y b) (hc : cmpUsing lt x y = ordering.eq), p (red_node a y b))\n    (is_red_gt : ∀ (a y b) (hc : cmpUsing lt x y = ordering.gt) (ih : p b), p (red_node a y b))\n    (is_black_lt_red :\n      ∀ (a y b) (hc : cmpUsing lt x y = ordering.lt) (hr : get_color a = red) (ih : p a), p (black_node a y b))\n    (is_black_lt_not_red :\n      ∀ (a y b) (hc : cmpUsing lt x y = ordering.lt) (hnr : get_color a ≠ red) (ih : p a), p (black_node a y b))\n    (is_black_eq : ∀ (a y b) (hc : cmpUsing lt x y = ordering.eq), p (black_node a y b))\n    (is_black_gt_red :\n      ∀ (a y b) (hc : cmpUsing lt x y = ordering.gt) (hr : get_color b = red) (ih : p b), p (black_node a y b))\n    (is_black_gt_not_red :\n      ∀ (a y b) (hc : cmpUsing lt x y = ordering.gt) (hnr : get_color b ≠ red) (ih : p b), p (black_node a y b)) :\n    p t := by\n  induction t\n  case leaf => apply is_leaf\n  case red_node a y b =>\n    cases h : cmpUsing lt x y\n    case lt => apply is_red_lt <;> assumption\n    case eq => apply is_red_eq <;> assumption\n    case gt => apply is_red_gt <;> assumption\n  case black_node a y b =>\n    cases h : cmpUsing lt x y\n    case lt =>\n      by_cases get_color a = red\n      · apply is_black_lt_red <;> assumption\n      · apply is_black_lt_not_red <;> assumption\n    case eq => apply is_black_eq <;> assumption\n    case gt =>\n      by_cases get_color b = red\n      · apply is_black_gt_red <;> assumption\n      · apply is_black_gt_not_red <;> assumption\n#align ins.induction ins.induction\n\n",
 "find_red_of_lt":
 "theorem find_red_of_lt [decidable_rel lt] {l y r x} (h : lt x y) : find lt (red_node l y r) x = find lt l x := by\n  simp [find, cmpUsing, *]\n#align find_red_of_lt find_red_of_lt\n\n",
 "find_red_of_incomp":
 "theorem find_red_of_incomp [decidable_rel lt] {l y r x} (h : ¬lt x y ∧ ¬lt y x) : find lt (red_node l y r) x = some y :=\n  by simp [find, cmpUsing, *]\n#align find_red_of_incomp find_red_of_incomp\n\n",
 "find_red_of_gt":
 "theorem find_red_of_gt [decidable_rel lt] [is_strict_order α lt] {l y r x} (h : lt y x) :\n    find lt (red_node l y r) x = find lt r x := by have := not_lt_of_lt h; simp [find, cmpUsing, *]\n#align find_red_of_gt find_red_of_gt\n\n",
 "find_mk_insert_result":
 "theorem find_mk_insert_result [decidable_rel lt] (c : color) (t : rbnode α) (x : α) :\n    find lt (mk_insert_result c t) x = find lt t x :=\n  by\n  cases t <;> cases c <;> simp [mk_insert_result]\n  · simp [find]\n    cases cmpUsing lt x t_val <;> simp [find]\n#align find_mk_insert_result find_mk_insert_result\n\n",
 "find_insert_of_not_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_insert_of_not_eqv [decidable_rel lt] [is_strict_weak_order α lt] {x y : α} {t : rbnode α}\n    (hn : ¬«expr ≈[ ] » x lt y) : is_searchable lt t none none → find lt (insert lt t x) y = find lt t y :=\n  by\n  intro hs\n  simp [insert, find_mk_insert_result]\n  have he : lt x y ∨ lt y x :=\n    by\n    simp [strict_weak_order.equiv, decidable.not_and_iff_or_not, decidable.not_not_iff] at hn\n    assumption\n  apply find_ins_of_disj lt he hs <;> simp\n#align find_insert_of_not_eqv find_insert_of_not_eqv\n\n",
 "find_insert_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_insert_of_eqv [decidable_rel lt] [is_strict_weak_order α lt] {x y : α} {t : rbnode α}\n    (he : «expr ≈[ ] » x lt y) : is_searchable lt t none none → find lt (insert lt t x) y = some x :=\n  by\n  intro hs\n  simp [insert, find_mk_insert_result]\n  apply find_ins_of_eqv lt he hs <;> simp\n#align find_insert_of_eqv find_insert_of_eqv\n\n",
 "find_insert_of_disj":
 "theorem find_insert_of_disj [decidable_rel lt] [is_strict_weak_order α lt] {x y : α} {t : rbnode α}\n    (hd : lt x y ∨ lt y x) : is_searchable lt t none none → find lt (insert lt t x) y = find lt t y :=\n  by\n  intro hs\n  simp [insert, find_mk_insert_result]\n  apply find_ins_of_disj lt hd hs <;> simp\n#align find_insert_of_disj find_insert_of_disj\n\n",
 "find_ins_of_eqv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_ins_of_eqv [decidable_rel lt] [is_strict_weak_order α lt] {x y : α} {t : rbnode α}\n    (he : «expr ≈[ ] » x lt y) :\n    ∀ {lo hi} (hs : is_searchable lt t lo hi) (hlt₁ : lift lt lo (some x)) (hlt₂ : lift lt (some x) hi),\n      find lt (ins lt t x) y = some x :=\n  by\n  simp [strict_weak_order.equiv] at he\n  apply ins.induction lt t x <;> intros\n  ·\n    run_tac\n      simp_fi\n  all_goals simp at hc; cases hs\n  · have := lt_of_incomp_of_lt he.swap hc\n    have := ih hs_hs₁ hlt₁ hc\n    run_tac\n      simp_fi\n  ·\n    run_tac\n      simp_fi\n  · have := lt_of_lt_of_incomp hc he\n    have := ih hs_hs₂ hc hlt₂\n    run_tac\n      simp_fi\n  · run_tac\n      simp_fi\n    have := is_searchable_ins lt hs_hs₁ hlt₁ hc\n    apply find_balance1_node lt this hs_hs₂ (ih hs_hs₁ hlt₁ hc) he.symm\n  · have := lt_of_incomp_of_lt he.swap hc\n    have := ih hs_hs₁ hlt₁ hc\n    run_tac\n      simp_fi\n  ·\n    run_tac\n      simp_fi\n  · run_tac\n      simp_fi\n    have := is_searchable_ins lt hs_hs₂ hc hlt₂\n    apply find_balance2_node lt hs_hs₁ this (ih hs_hs₂ hc hlt₂) he.symm\n  · have := lt_of_lt_of_incomp hc he\n    have := ih hs_hs₂ hc hlt₂\n    run_tac\n      simp_fi\n#align find_ins_of_eqv find_ins_of_eqv\n\n",
 "find_ins_of_disj":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic _private.3968712505.simp_fi -/\ntheorem find_ins_of_disj {x y : α} {t : rbnode α} (hn : lt x y ∨ lt y x) :\n    ∀ {lo hi} (hs : is_searchable lt t lo hi) (hlt₁ : lift lt lo (some x)) (hlt₂ : lift lt (some x) hi),\n      find lt (ins lt t x) y = find lt t y :=\n  by\n  apply ins.induction lt t x <;> intros\n  · cases hn\n    all_goals simp [find, ins, cmpUsing, *]\n  all_goals simp at hc; cases hs\n  · have := ih hs_hs₁ hlt₁ hc\n    run_tac\n      simp_fi\n  · cases hn\n    · have := lt_of_incomp_of_lt hc.symm hn\n      run_tac\n        simp_fi\n    · have := lt_of_lt_of_incomp hn hc\n      run_tac\n        simp_fi\n  · have := ih hs_hs₂ hc hlt₂\n    run_tac\n      simp_fi\n  · have ih := ih hs_hs₁ hlt₁ hc\n    cases hn\n    · cases hc' : cmpUsing lt y y_1 <;> simp at hc'\n      · have hsi := is_searchable_ins lt hs_hs₁ hlt₁ (trans_of lt hn hc')\n        have := find_balance1_node_lt lt hc' hsi hs_hs₂\n        run_tac\n          simp_fi\n      · have hlt := lt_of_lt_of_incomp hn hc'\n        have hsi := is_searchable_ins lt hs_hs₁ hlt₁ hlt\n        have := find_balance1_node_eqv lt hc' hsi hs_hs₂\n        run_tac\n          simp_fi\n      · have hsi := is_searchable_ins lt hs_hs₁ hlt₁ hc\n        have := find_balance1_node_gt lt hc' hsi hs_hs₂\n        simp [*]\n        run_tac\n          simp_fi\n    · have hlt := trans hn hc\n      have hsi := is_searchable_ins lt hs_hs₁ hlt₁ hc\n      have := find_balance1_node_lt lt hlt hsi hs_hs₂\n      run_tac\n        simp_fi\n  · have := ih hs_hs₁ hlt₁ hc\n    run_tac\n      simp_fi\n  · cases hn\n    · have := lt_of_incomp_of_lt hc.swap hn\n      run_tac\n        simp_fi\n    · have := lt_of_lt_of_incomp hn hc\n      run_tac\n        simp_fi\n  · have ih := ih hs_hs₂ hc hlt₂\n    cases hn\n    · have hlt := trans hc hn\n      run_tac\n        simp_fi\n      have hsi := is_searchable_ins lt hs_hs₂ hc hlt₂\n      have := find_balance2_node_gt lt hlt hsi hs_hs₁\n      run_tac\n        simp_fi\n    · run_tac\n        simp_fi\n      cases hc' : cmpUsing lt y y_1 <;> simp at hc'\n      · have hsi := is_searchable_ins lt hs_hs₂ hc hlt₂\n        have := find_balance2_node_lt lt hc' hsi hs_hs₁\n        run_tac\n          simp_fi\n      · have hlt := lt_of_incomp_of_lt hc'.swap hn\n        have hsi := is_searchable_ins lt hs_hs₂ hlt hlt₂\n        have := find_balance2_node_eqv lt hc' hsi hs_hs₁\n        run_tac\n          simp_fi\n      · have hsi := is_searchable_ins lt hs_hs₂ hc hlt₂\n        have := find_balance2_node_gt lt hc' hsi hs_hs₁\n        run_tac\n          simp_fi\n  · have ih := ih hs_hs₂ hc hlt₂\n    run_tac\n      simp_fi\n#align find_ins_of_disj find_ins_of_disj\n\n",
 "find_black_eq_find_red":
 "theorem find_black_eq_find_red [decidable_rel lt] {l y r x} :\n    find lt (black_node l y r) x = find lt (red_node l y r) x := by simp [find];\n  all_goals cases cmpUsing lt x y <;> simp [find]\n#align find_black_eq_find_red find_black_eq_find_red\n\n",
 "find_balance2_node_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic ins_ne_leaf_tac -/\ntheorem find_balance2_node_lt {s t x y lo hi} (h : lt x y) (ht : is_searchable lt t (some y) hi)\n    (hs : is_searchable lt s lo (some y))\n    (hne : t ≠ leaf := by\n      run_tac\n        ins_ne_leaf_tac) :\n    find lt (balance2_node t y s) x = find lt s x :=\n  by\n  cases t <;> simp [balance2_node]\n  all_goals intros ;\n    run_tac\n      is_searchable_tactic;\n    apply find_balance2_lt; assumption'\n#align find_balance2_node_lt find_balance2_node_lt\n\n",
 "find_balance2_node_gt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic ins_ne_leaf_tac -/\ntheorem find_balance2_node_gt {s t x y lo hi} (h : lt y x) (ht : is_searchable lt t (some y) hi)\n    (hs : is_searchable lt s lo (some y))\n    (hne : t ≠ leaf := by\n      run_tac\n        ins_ne_leaf_tac) :\n    find lt (balance2_node t y s) x = find lt t x :=\n  by\n  cases t <;> simp [balance2_node]\n  · contradiction\n  all_goals intros ;\n    run_tac\n      is_searchable_tactic;\n    apply find_balance2_gt; assumption'\n#align find_balance2_node_gt find_balance2_node_gt\n\n",
 "find_balance2_node_eqv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic ins_ne_leaf_tac -/\ntheorem find_balance2_node_eqv {t s x y lo hi} (h : ¬lt x y ∧ ¬lt y x) (ht : is_searchable lt t (some y) hi)\n    (hs : is_searchable lt s lo (some y))\n    (hne : t ≠ leaf := by\n      run_tac\n        ins_ne_leaf_tac) :\n    find lt (balance2_node t y s) x = some y :=\n  by\n  cases t <;> simp [balance2_node]\n  · contradiction\n  all_goals intros ;\n    run_tac\n      is_searchable_tactic;\n    apply find_balance2_eqv; assumption'\n#align find_balance2_node_eqv find_balance2_node_eqv\n\n",
 "find_balance2_node":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_balance2_node [decidable_rel lt] [is_strict_weak_order α lt] {x y z s t} [is_trans α lt] :\n    ∀ {lo hi},\n      is_searchable lt s lo (some z) →\n        is_searchable lt t (some z) hi →\n          find lt t y = some x → «expr ≈[ ] » y lt x → find lt (balance2_node t z s) y = some x :=\n  by\n  intro _ _ hs₁ hs₂ heq heqv\n  have hs := is_searchable_balance2_node lt hs₁ hs₂\n  have := eq.trans (find_eq_find_of_eqv hs₂ heqv.symm) HEq\n  have := Iff.mpr (find_correct_exact hs₂) this\n  have := mem_exact_balance2_node_of_mem_exact z s this\n  have := Iff.mp (find_correct_exact hs) this\n  exact eq.trans (find_eq_find_of_eqv hs heqv) this\n#align find_balance2_node find_balance2_node\n\n",
 "find_balance2_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem find_balance2_lt {l v r t x y lo hi} (h : lt x y) (hl : is_searchable lt l (some y) (some v))\n    (hr : is_searchable lt r (some v) hi) (ht : is_searchable lt t lo (some y)) :\n    find lt (balance2 l v r y t) x = find lt t x :=\n  by\n  revert hl hr ht;\n  apply balance.cases l v r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n  · have := trans h (lo_lt_hi hl_hs₁)\n    simp [*]\n  · have := trans h (lo_lt_hi hl)\n    simp [*]\n#align find_balance2_lt find_balance2_lt\n\n",
 "find_balance2_gt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem find_balance2_gt {l v r t x y lo hi} (h : lt y x) (hl : is_searchable lt l (some y) (some v))\n    (hr : is_searchable lt r (some v) hi) (ht : is_searchable lt t lo (some y)) :\n    find lt (balance2 l v r y t) x = find lt (red_node l v r) x :=\n  by\n  revert hl hr ht;\n  apply balance.cases l v r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n  · apply weak_trichotomous lt x_1 x <;> intro h' <;> simp [*]\n    · apply weak_trichotomous lt y_1 x <;> intros <;> simp [*]\n    · have : lt x _ := lt_of_incomp_of_lt h'.swap (lo_lt_hi hl_hs₂)\n      simp [*]\n    · have := trans h' (lo_lt_hi hl_hs₂)\n      simp [*]\n  · apply weak_trichotomous lt y_1 x <;> intros <;> simp [*]\n#align find_balance2_gt find_balance2_gt\n\n",
 "find_balance2_eqv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem find_balance2_eqv {l v r t x y lo hi} (h : ¬lt x y ∧ ¬lt y x) (hl : is_searchable lt l (some y) (some v))\n    (hr : is_searchable lt r (some v) hi) (ht : is_searchable lt t lo (some y)) :\n    find lt (balance2 l v r y t) x = some y := by\n  revert hl hr ht;\n  apply balance.cases l v r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n  · have := lt_of_incomp_of_lt h (lo_lt_hi hl_hs₁)\n    simp [*]\n  · have := lt_of_incomp_of_lt h (lo_lt_hi hl)\n    simp [*]\n#align find_balance2_eqv find_balance2_eqv\n\n",
 "find_balance1_node_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic ins_ne_leaf_tac -/\ntheorem find_balance1_node_lt {t s x y lo hi} (hlt : lt y x) (ht : is_searchable lt t lo (some x))\n    (hs : is_searchable lt s (some x) hi)\n    (hne : t ≠ leaf := by\n      run_tac\n        ins_ne_leaf_tac) :\n    find lt (balance1_node t x s) y = find lt t y :=\n  by\n  cases t <;> simp [balance1_node]\n  · contradiction\n  all_goals intros ;\n    run_tac\n      is_searchable_tactic;\n    apply find_balance1_lt; assumption'\n#align find_balance1_node_lt find_balance1_node_lt\n\n",
 "find_balance1_node_gt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic ins_ne_leaf_tac -/\ntheorem find_balance1_node_gt {t s x y lo hi} (h : lt x y) (ht : is_searchable lt t lo (some x))\n    (hs : is_searchable lt s (some x) hi)\n    (hne : t ≠ leaf := by\n      run_tac\n        ins_ne_leaf_tac) :\n    find lt (balance1_node t x s) y = find lt s y :=\n  by\n  cases t <;> simp [balance1_node]\n  all_goals intros ;\n    run_tac\n      is_searchable_tactic;\n    apply find_balance1_gt; assumption'\n#align find_balance1_node_gt find_balance1_node_gt\n\n",
 "find_balance1_node_eqv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\n/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic ins_ne_leaf_tac -/\ntheorem find_balance1_node_eqv {t s x y lo hi} (h : ¬lt x y ∧ ¬lt y x) (ht : is_searchable lt t lo (some y))\n    (hs : is_searchable lt s (some y) hi)\n    (hne : t ≠ leaf := by\n      run_tac\n        ins_ne_leaf_tac) :\n    find lt (balance1_node t y s) x = some y :=\n  by\n  cases t <;> simp [balance1_node]\n  · contradiction\n  all_goals intros ;\n    run_tac\n      is_searchable_tactic;\n    apply find_balance1_eqv; assumption'\n#align find_balance1_node_eqv find_balance1_node_eqv\n\n",
 "find_balance1_node":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\ntheorem find_balance1_node [decidable_rel lt] [is_strict_weak_order α lt] {x y z t s} :\n    ∀ {lo hi},\n      is_searchable lt t lo (some z) →\n        is_searchable lt s (some z) hi →\n          find lt t y = some x → «expr ≈[ ] » y lt x → find lt (balance1_node t z s) y = some x :=\n  by\n  intro _ _ hs₁ hs₂ heq heqv\n  have hs := is_searchable_balance1_node lt hs₁ hs₂\n  have := eq.trans (find_eq_find_of_eqv hs₁ heqv.symm) HEq\n  have := Iff.mpr (find_correct_exact hs₁) this\n  have := mem_exact_balance1_node_of_mem_exact z s this\n  have := Iff.mp (find_correct_exact hs) this\n  exact eq.trans (find_eq_find_of_eqv hs heqv) this\n#align find_balance1_node find_balance1_node\n\n",
 "find_balance1_lt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem find_balance1_lt {l r t v x y lo hi} (h : lt x y) (hl : is_searchable lt l lo (some v))\n    (hr : is_searchable lt r (some v) (some y)) (ht : is_searchable lt t (some y) hi) :\n    find lt (balance1 l v r y t) x = find lt (red_node l v r) x :=\n  by\n  revert hl hr ht;\n  apply balance.cases l v r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n  · apply weak_trichotomous lt y_1 x <;> intros <;> simp [*]\n  · apply weak_trichotomous lt x_1 x <;> intro h'\n    · have := trans_of lt (lo_lt_hi hr_hs₁) h'\n      simp [*]\n    · have : lt y_1 x := lt_of_lt_of_incomp (lo_lt_hi hr_hs₁) h'\n      simp [*]\n    · apply weak_trichotomous lt y_1 x <;> intros <;> simp [*]\n#align find_balance1_lt find_balance1_lt\n\n",
 "find_balance1_gt":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem find_balance1_gt {l r t v x y lo hi} (h : lt y x) (hl : is_searchable lt l lo (some v))\n    (hr : is_searchable lt r (some v) (some y)) (ht : is_searchable lt t (some y) hi) :\n    find lt (balance1 l v r y t) x = find lt t x :=\n  by\n  revert hl hr ht;\n  apply balance.cases l v r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n  · have := trans_of lt (lo_lt_hi hr) h\n    simp [*]\n  · have := trans_of lt (lo_lt_hi hr_hs₂) h\n    simp [*]\n#align find_balance1_gt find_balance1_gt\n\n",
 "find_balance1_eqv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic rbnode.is_searchable_tactic -/\ntheorem find_balance1_eqv {l r t v x y lo hi} (h : ¬lt x y ∧ ¬lt y x) (hl : is_searchable lt l lo (some v))\n    (hr : is_searchable lt r (some v) (some y)) (ht : is_searchable lt t (some y) hi) :\n    find lt (balance1 l v r y t) x = some y := by\n  revert hl hr ht;\n  apply balance.cases l v r <;> intros <;> simp [*] <;>\n    run_tac\n      is_searchable_tactic\n  · have : lt y_1 x := lt_of_lt_of_incomp (lo_lt_hi hr) h.swap\n    simp [*]\n  · have : lt x_1 x := lt_of_lt_of_incomp (lo_lt_hi hr_hs₂) h.swap\n    simp [*]\n#align find_balance1_eqv find_balance1_eqv\n\n",
 "equiv_or_mem_of_mem_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem equiv_or_mem_of_mem_insert [decidable_rel lt] {t : rbnode α} {x z} :\n    ∀ h : mem x (t.insert lt z), «expr ≈[ ] » x lt z ∨ mem x t := by simp [insert]; intros ;\n  apply equiv_or_mem_of_mem_ins; exact mem_of_mem_mk_insert_result lt h\n#align equiv_or_mem_of_mem_insert equiv_or_mem_of_mem_insert\n\n",
 "equiv_or_mem_of_mem_ins":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≈[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mem -/\ntheorem equiv_or_mem_of_mem_ins [decidable_rel lt] {t : rbnode α} {x z} :\n    ∀ h : mem x (t.ins lt z), «expr ≈[ ] » x lt z ∨ mem x t :=\n  by\n  apply ins.induction lt t z <;> intros <;> simp_all [ins, strict_weak_order.equiv] <;> cases_type*or.1\n  any_goals intros ; simp [h]\n  any_goals intros ; have ih := ih h; cases ih <;> simp [*]; done\n  · have h' := of_mem_balance1_node lt h\n    cases_type*or.1\n    have := ih h'\n    cases_type*or.1\n    all_goals simp [h, *]\n  · have h' := of_mem_balance2_node lt h\n    cases_type*or.1\n    have := ih h'\n    cases_type*or.1\n    all_goals simp [h, *]\n#align equiv_or_mem_of_mem_ins equiv_or_mem_of_mem_ins\n\n",
 "cases":
 "-- We can use the same induction principle for balance1 and balance2\ntheorem balance.cases {p : rbnode α → α → rbnode α → Prop} (l y r) (red_left : ∀ l x r₁ y r₂, p (red_node l x r₁) y r₂)\n    (red_right : ∀ l₁ y l₂ x r, get_color l₁ ≠ red → p l₁ y (red_node l₂ x r))\n    (other : ∀ l y r, get_color l ≠ red → get_color r ≠ red → p l y r) : p l y r :=\n  by\n  cases l <;> cases r\n  any_goals apply red_left\n  any_goals apply red_right <;> simp [get_color] <;> contradiction <;> done\n  any_goals apply other <;> simp [get_color] <;> contradiction <;> done\n#align balance.cases balance.cases\n\n",
 "balance2_rb":
 "theorem balance2_rb {l r t : rbnode α} {y v : α} {c_l c_r c_t n} :\n    is_red_black l c_l n →\n      is_red_black r c_r n → is_red_black t c_t n → ∃ c, is_red_black (balance2 l y r v t) c (succ n) :=\n  by intro h₁ h₂ _ <;> cases h₁ <;> cases h₂ <;> repeat' first |assumption|constructor\n#align balance2_rb balance2_rb\n\n",
 "balance2_node_rb":
 "theorem balance2_node_rb {t s : rbnode α} {y : α} {c n} :\n    is_bad_red_black t n → is_red_black s c n → ∃ c, is_red_black (balance2_node t y s) c (succ n) := by\n  intro h _ <;> cases h <;> simp [balance2_node] <;> apply balance2_rb <;> assumption'\n#align balance2_node_rb balance2_node_rb\n\n",
 "balance2_node_ne_leaf":
 "theorem balance2_node_ne_leaf {s : rbnode α} (a : α) (t : rbnode α) : s ≠ leaf → balance2_node s a t ≠ leaf :=\n  by\n  intro h; cases s\n  · contradiction\n  all_goals simp [balance2_node]; apply balance2_ne_leaf\n#align balance2_node_ne_leaf balance2_node_ne_leaf\n\n",
 "balance2_ne_leaf":
 "theorem balance2_ne_leaf (l : rbnode α) (x r v t) : balance2 l x r v t ≠ leaf := by\n  apply balance.cases l x r <;> intros <;> simp [*] <;> contradiction\n#align balance2_ne_leaf balance2_ne_leaf\n\n",
 "balance2_eq₃":
 "@[simp]\ntheorem balance2_eq₃ (l : rbnode α) (y r v t) :\n    get_color l ≠ red → get_color r ≠ red → balance2 l y r v t = black_node t v (red_node l y r) := by\n  cases l <;> cases r <;> simp [get_color, balance2, false_imp_iff]\n#align balance2_eq₃ balance2_eq₃\n\n",
 "balance2_eq₂":
 "@[simp]\ntheorem balance2_eq₂ (l₁ : rbnode α) (y l₂ x₂ r₂ v t) :\n    get_color l₁ ≠ red → balance2 l₁ y (red_node l₂ x₂ r₂) v t = red_node (black_node t v l₁) y (black_node l₂ x₂ r₂) :=\n  by cases l₁ <;> simp [get_color, balance2, false_imp_iff]\n#align balance2_eq₂ balance2_eq₂\n\n",
 "balance2_eq₁":
 "@[simp]\ntheorem balance2_eq₁ (l : rbnode α) (x₁ r₁ y r₂ v t) :\n    balance2 (red_node l x₁ r₁) y r₂ v t = red_node (black_node t v l) x₁ (black_node r₁ y r₂) := by cases r₂ <;> rfl\n#align balance2_eq₁ balance2_eq₁\n\n",
 "balance1_rb":
 "theorem balance1_rb {l r t : rbnode α} {y v : α} {c_l c_r c_t n} :\n    is_red_black l c_l n →\n      is_red_black r c_r n → is_red_black t c_t n → ∃ c, is_red_black (balance1 l y r v t) c (succ n) :=\n  by intro h₁ h₂ _ <;> cases h₁ <;> cases h₂ <;> repeat' first |assumption|constructor\n#align balance1_rb balance1_rb\n\n",
 "balance1_node_rb":
 "theorem balance1_node_rb {t s : rbnode α} {y : α} {c n} :\n    is_bad_red_black t n → is_red_black s c n → ∃ c, is_red_black (balance1_node t y s) c (succ n) := by\n  intro h _ <;> cases h <;> simp [balance1_node] <;> apply balance1_rb <;> assumption'\n#align balance1_node_rb balance1_node_rb\n\n",
 "balance1_node_ne_leaf":
 "theorem balance1_node_ne_leaf {s : rbnode α} (a : α) (t : rbnode α) : s ≠ leaf → balance1_node s a t ≠ leaf :=\n  by\n  intro h; cases s\n  · contradiction\n  all_goals simp [balance1_node]; apply balance1_ne_leaf\n#align balance1_node_ne_leaf balance1_node_ne_leaf\n\n",
 "balance1_ne_leaf":
 "theorem balance1_ne_leaf (l : rbnode α) (x r v t) : balance1 l x r v t ≠ leaf := by\n  apply balance.cases l x r <;> intros <;> simp [*] <;> contradiction\n#align balance1_ne_leaf balance1_ne_leaf\n\n",
 "balance1_eq₃":
 "@[simp]\ntheorem balance1_eq₃ (l : rbnode α) (y r v t) :\n    get_color l ≠ red → get_color r ≠ red → balance1 l y r v t = black_node (red_node l y r) v t := by\n  cases l <;> cases r <;> simp [get_color, balance1, false_imp_iff]\n#align balance1_eq₃ balance1_eq₃\n\n",
 "balance1_eq₂":
 "@[simp]\ntheorem balance1_eq₂ (l₁ : rbnode α) (y l₂ x r v t) :\n    get_color l₁ ≠ red → balance1 l₁ y (red_node l₂ x r) v t = red_node (black_node l₁ y l₂) x (black_node r v t) := by\n  cases l₁ <;> simp [get_color, balance1, false_imp_iff]\n#align balance1_eq₂ balance1_eq₂\n\n",
 "balance1_eq₁":
 "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\n@[simp]\ntheorem balance1_eq₁ (l : rbnode α) (x r₁ y r₂ v t) :\n    balance1 (red_node l x r₁) y r₂ v t = red_node (black_node l x r₁) y (black_node r₂ v t) := by cases r₂ <;> rfl\n#align balance1_eq₁ balance1_eq₁\n\n"}