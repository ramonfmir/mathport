{"linear_yoneda_obj_resolution_d_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-\nCopyright (c) 2023 Amelia Livingston. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Amelia Livingston\n-/\ntheorem linear_yoneda_obj_resolution_d_apply {A : Rep k G} (i j : ℕ) (x : «expr ⟶ » ((resolution k G).X i) A) :\n    (linear_yoneda_obj_resolution A).d i j x = «expr ≫ » ((resolution k G).d j i) x :=\n  rfl\n#align linear_yoneda_obj_resolution_d_apply linear_yoneda_obj_resolution_d_apply\n\n",
 "d_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- The theorem that our isomorphism `Fun(Gⁿ, A) ≅ Hom(k[Gⁿ⁺¹], A)` (where the righthand side is\nmorphisms in `Rep k G`) commutes with the differentials in the complex of inhomogeneous cochains\nand the homogeneous `linear_yoneda_obj_resolution`. -/\ntheorem d_eq :\n    d n A =\n      «expr ≫ » (diagonal_hom_equiv n A).to_Module_iso.inv\n        («expr ≫ » ((linear_yoneda_obj_resolution A).d n (n + 1)) (diagonal_hom_equiv (n + 1) A).to_Module_iso.hom) :=\n  by\n  ext (f g)\n  simp only [ModuleCat.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, linear_equiv.to_Module_iso_inv,\n    linear_yoneda_obj_resolution_d_apply, linear_equiv.to_Module_iso_hom, diagonal_hom_equiv_apply, Action.comp_hom,\n    resolution.d_eq k G n, resolution.d_of (Fin.partialProd g), LinearMap.map_sum, ←\n    Finsupp.smul_single_one _ ((-1 : k) ^ _), map_smul, d_apply]\n  simp only [@Fin.sum_univ_succ _ _ (n + 1), Fin.val_zero, pow_zero, one_smul, Fin.succAbove_zero,\n    diagonal_hom_equiv_symm_apply f (Fin.partialProd g ∘ @fin.succ (n + 1)), Function.comp_apply, Fin.partialProd_succ,\n    Fin.castSucc_zero, Fin.partialProd_zero, one_mul]\n  congr 1\n  · congr\n    ext\n    have := Fin.partialProd_right_inv (1 : G) g (Fin.castSucc x)\n    simp only [mul_inv_rev, Fin.coe_eq_castSucc, one_smul, Fin.castSucc_fin_succ] at *\n    rw [mul_assoc, ← mul_assoc _ _ (g x.succ), this, inv_mul_cancel_left]\n  · exact Finset.sum_congr rfl fun j hj => by rw [diagonal_hom_equiv_symm_partial_prod_succ, Fin.val_succ]\n#align d_eq d_eq\n\n"}