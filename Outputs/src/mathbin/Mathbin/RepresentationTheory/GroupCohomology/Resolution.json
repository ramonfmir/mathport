{"ε_to_single₀_comp_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem ε_to_single₀_comp_eq :\n    «expr ≫ » (((forget₂ _ (ModuleCat.{u} k)).map_homological_complex _).map (ε_to_single₀ k G))\n        ((ChainComplex.single₀MapHomologicalComplex _).hom.app _) =\n      (forget₂_to_Module_homotopy_equiv k G).hom :=\n  by\n  refine' ChainComplex.to_single₀_ext _ _ _\n  dsimp\n  rw [category.comp_id]\n  exact (forget₂_to_Module_homotopy_equiv_f_0_eq k G).symm\n#align ε_to_single₀_comp_eq ε_to_single₀_comp_eq\n\n",
 "quasi_iso_of_forget₂_ε_to_single₀":
 "theorem quasi_iso_of_forget₂_ε_to_single₀ :\n    quasi_iso (((forget₂ _ (ModuleCat.{u} k)).map_homological_complex _).map (ε_to_single₀ k G)) :=\n  by\n  have h : quasi_iso (forget₂_to_Module_homotopy_equiv k G).hom := homotopy_equiv.to_quasi_iso _\n  rw [← ε_to_single₀_comp_eq k G] at h\n  haveI := h\n  exact quasi_iso_of_comp_right _ ((ChainComplex.single₀MapHomologicalComplex _).hom.app _)\n#align quasi_iso_of_forget₂_ε_to_single₀ quasi_iso_of_forget₂_ε_to_single₀\n\n",
 "of_mul_action_free":
 "theorem of_mul_action_free : Module.Free (MonoidAlgebra k G) (of_mul_action k G (Fin (n + 1) → G)).as_module :=\n  Module.Free.of_basis (of_mul_action_basis k G n)\n#align of_mul_action_free of_mul_action_free\n\n",
 "forget₂_to_Module_homotopy_equiv_f_0_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤_ » -/\n/-- The homotopy equivalence of complexes of `k`-modules between the standard resolution of `k` as\na trivial `G`-representation, and the complex which is `k` at 0 and 0 everywhere else, acts as\n`∑ nᵢgᵢ ↦ ∑ nᵢ : k[G¹] → k` at 0. -/\ntheorem forget₂_to_Module_homotopy_equiv_f_0_eq :\n    (forget₂_to_Module_homotopy_equiv k G).1.f 0 = (forget₂ (Rep k G) _).map (ε k G) :=\n  by\n  show («expr ≫ » (homotopy_equiv.hom _) («expr ≫ » (homotopy_equiv.hom _) (homotopy_equiv.hom _))).f 0 = _\n  simp only [HomologicalComplex.comp_f]\n  convert category.id_comp _\n  · dsimp only [HomotopyEquiv.ofIso, comp_forget_augmented_iso, map_alternating_face_map_complex]\n    simp only [iso.symm_hom, eq_to_iso.inv, HomologicalComplex.eqToHom_f, eq_to_hom_refl]\n  trans (Finsupp.total _ _ _ fun f => (1 : k)).comp ((Module.free k).map (terminal.from _))\n  · dsimp\n    rw [@Finsupp.lmapDomain_total (Fin 1 → G) k k _ _ _ («expr⊤_ » (Type u)) k _ _ (fun i => (1 : k)) (fun i => (1 : k))\n        (terminal.from ((classifying_space_universal_cover G).obj (Opposite.op (SimplexCategory.mk 0))).V) LinearMap.id\n        fun i => rfl,\n      LinearMap.id_comp]\n    rfl\n  · congr\n    · ext\n      dsimp [HomotopyEquiv.ofIso]\n      rw [Finsupp.total_single, one_smul, @Unique.eq_default _ types.terminal_iso.to_equiv.unique a,\n        Finsupp.single_eq_same]\n    · exact @subsingleton.elim _ (@unique.subsingleton _ (limits.unique_to_terminal _)) _ _\n#align forget₂_to_Module_homotopy_equiv_f_0_eq forget₂_to_Module_homotopy_equiv_f_0_eq\n\n",
 "diagonal_succ_inv_single_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprGⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem diagonal_succ_inv_single_single (g : G) (f : «exprGⁿ») (a b : k) :\n    (diagonal_succ k G n).inv.hom («expr ⊗ₜ » (Finsupp.single g a) (Finsupp.single f b)) =\n      single («expr • » g (partialProd f)) (a * b) :=\n  by\n  dsimp only [diagonal_succ]\n  simp only [iso.trans_inv, iso.symm_inv, iso.refl_inv, tensor_iso_inv, Action.tensor_hom, Action.comp_hom,\n    ModuleCat.comp_def, LinearMap.comp_apply, as_iso_hom, functor.map_iso_inv, Module.monoidal_category.hom_apply,\n    linearization_trivial_iso_inv_hom_apply, linearization_μ_hom, Action.id_hom ((linearization k G).obj _),\n    Action_diagonal_succ_inv_apply, ModuleCat.id_apply, LinearEquiv.coe_toLinearMap,\n    finsuppTensorFinsupp'_single_tmul_single k (Action.left_regular G).V,\n    linearization_map_hom_single (Action_diagonal_succ G n).inv (g, f) (a * b)]\n#align diagonal_succ_inv_single_single diagonal_succ_inv_single_single\n\n",
 "diagonal_succ_inv_single_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprGⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem diagonal_succ_inv_single_right (g : «expr →₀ » G k) (f : «exprGⁿ») (r : k) :\n    (diagonal_succ k G n).inv.hom («expr ⊗ₜ » g (Finsupp.single f r)) =\n      Finsupp.lift _ k G (fun a => single («expr • » a (partialProd f)) r) g :=\n  by\n  refine' g.induction _ _\n  · simp only [TensorProduct.zero_tmul, map_zero]\n  · intro a b x ha hb hx\n    simp only [lift_apply, smul_single', map_add, hx, diagonal_succ_inv_single_single, TensorProduct.add_tmul,\n      Finsupp.sum_single_index, MulZeroClass.zero_mul, single_zero]\n#align diagonal_succ_inv_single_right diagonal_succ_inv_single_right\n\n",
 "diagonal_succ_inv_single_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprGⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprGⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprGⁿ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem diagonal_succ_inv_single_left (g : G) (f : «expr →₀ » («exprGⁿ») k) (r : k) :\n    (diagonal_succ k G n).inv.hom («expr ⊗ₜ » (Finsupp.single g r) f) =\n      Finsupp.lift («expr →₀ » («exprGⁿ⁺¹») k) k («exprGⁿ») (fun f => single («expr • » g (partialProd f)) r) f :=\n  by\n  refine' f.induction _ _\n  · simp only [TensorProduct.tmul_zero, map_zero]\n  · intro a b x ha hb hx\n    simp only [lift_apply, smul_single', mul_one, TensorProduct.tmul_add, map_add, diagonal_succ_inv_single_single, hx,\n      Finsupp.sum_single_index, mul_comm b, MulZeroClass.zero_mul, single_zero]\n#align diagonal_succ_inv_single_left diagonal_succ_inv_single_left\n\n",
 "diagonal_succ_hom_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprGⁿ⁺¹» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\ntheorem diagonal_succ_hom_single (f : «exprGⁿ⁺¹») (a : k) :\n    (diagonal_succ k G n).hom.hom (single f a) = «expr ⊗ₜ » (single (f 0) 1) (single (fun i => (f i)⁻¹ * f i.succ) a) :=\n  by\n  dsimp only [diagonal_succ]\n  simpa only [iso.trans_hom, iso.symm_hom, Action.comp_hom, ModuleCat.comp_def, LinearMap.comp_apply,\n    functor.map_iso_hom, linearization_map_hom_single (Action_diagonal_succ G n).hom f a, as_iso_inv,\n    linearization_μ_inv_hom, Action_diagonal_succ_hom_apply, finsuppTensorFinsupp', LinearEquiv.trans_symm, lcongr_symm,\n    LinearEquiv.trans_apply, lcongr_single, TensorProduct.lid_symm_apply, finsuppTensorFinsupp_symm_single,\n    LinearEquiv.coe_toLinearMap]\n#align diagonal_succ_hom_single diagonal_succ_hom_single\n\n",
 "diagonal_hom_equiv_symm_partial_prod_succ":
 "/-- Auxiliary lemma for defining group cohomology, used to show that the isomorphism\n`diagonal_hom_equiv` commutes with the differentials in two complexes which compute\ngroup cohomology. -/\ntheorem diagonal_hom_equiv_symm_partial_prod_succ (f : (Fin n → G) → A) (g : Fin (n + 1) → G) (a : Fin (n + 1)) :\n    ((diagonal_hom_equiv n A).symm f).hom (Finsupp.single (Fin.partialProd g ∘ a.succ.succ_above) 1) =\n      f (Fin.contractNth a (· * ·) g) :=\n  by\n  simp only [diagonal_hom_equiv_symm_apply, Function.comp_apply, Fin.succ_succAbove_zero, Fin.partialProd_zero, map_one,\n    Fin.coe_eq_castSucc, Fin.succ_succAbove_succ, LinearMap.one_apply, Fin.partialProd_succ]\n  congr\n  ext\n  rw [← Fin.partialProd_succ, Fin.inv_partialProd_mul_eq_contractNth]\n#align diagonal_hom_equiv_symm_partial_prod_succ diagonal_hom_equiv_symm_partial_prod_succ\n\n",
 "diagonal_hom_equiv_symm_apply":
 "/-- Given a `k`-linear `G`-representation `A`, `diagonal_hom_equiv` is a `k`-linear isomorphism of\nthe set of representation morphisms `Hom(k[Gⁿ⁺¹], A)` with `Fun(Gⁿ, A)`. This lemma says that the\ninverse map sends a function `f : Gⁿ → A` to the representation morphism sending\n`(g₀, ... gₙ) ↦ ρ(g₀)(f(g₀⁻¹g₁, g₁⁻¹g₂, ..., gₙ₋₁⁻¹gₙ))`, where `ρ` is the representation attached\nto `A`. -/\ntheorem diagonal_hom_equiv_symm_apply (f : (Fin n → G) → A) (x : Fin (n + 1) → G) :\n    ((diagonal_hom_equiv n A).symm f).hom (Finsupp.single x 1) = A.ρ (x 0) (f fun i : Fin n => (x ↑i)⁻¹ * x i.succ) :=\n  by\n  unfold diagonal_hom_equiv\n  simp only [LinearEquiv.trans_symm, LinearEquiv.symm_symm, LinearEquiv.trans_apply,\n    Rep.left_regular_hom_equiv_symm_apply, linear.hom_congr_symm_apply, Action.comp_hom, iso.refl_inv, category.comp_id,\n    Rep.monoidal_closed.linear_hom_equiv_comm_symm_hom, iso.trans_hom, ModuleCat.comp_def, LinearMap.comp_apply,\n    representation.Rep_of_tprod_iso_apply, diagonal_succ_hom_single x (1 : k), TensorProduct.uncurry_apply,\n    Rep.left_regular_hom_hom, Finsupp.lift_apply, Rep.ihom_obj_ρ, representation.lin_hom_apply,\n    Finsupp.sum_single_index, zero_smul, one_smul, Rep.of_ρ, Rep.Action_ρ_eq_ρ, Rep.trivial_def (x 0)⁻¹,\n    Finsupp.llift_apply A k k]\n#align diagonal_hom_equiv_symm_apply diagonal_hom_equiv_symm_apply\n\n",
 "diagonal_hom_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Given a `k`-linear `G`-representation `A`, `diagonal_hom_equiv` is a `k`-linear isomorphism of\nthe set of representation morphisms `Hom(k[Gⁿ⁺¹], A)` with `Fun(Gⁿ, A)`. This lemma says that this\nsends a morphism of representations `f : k[Gⁿ⁺¹] ⟶ A` to the function\n`(g₁, ..., gₙ) ↦ f(1, g₁, g₁g₂, ..., g₁g₂...gₙ).` -/\ntheorem diagonal_hom_equiv_apply (f : «expr ⟶ » (Rep.of_mul_action k G (Fin (n + 1) → G)) A) (x : Fin n → G) :\n    diagonal_hom_equiv n A f x = f.hom (Finsupp.single (Fin.partialProd x) 1) :=\n  by\n  unfold diagonal_hom_equiv\n  simpa only [LinearEquiv.trans_apply, Rep.left_regular_hom_equiv_apply, monoidal_closed.linear_hom_equiv_comm_hom,\n    Finsupp.llift_symm_apply, TensorProduct.curry_apply, linear.hom_congr_apply, iso.refl_hom, iso.trans_inv,\n    Action.comp_hom, ModuleCat.comp_def, LinearMap.comp_apply, representation.Rep_of_tprod_iso_inv_apply,\n    diagonal_succ_inv_single_single (1 : G) x, one_smul, one_mul]\n#align diagonal_hom_equiv_apply diagonal_hom_equiv_apply\n\n",
 "d_of":
 "@[simp]\ntheorem d_of {G : Type u} {n : ℕ} (c : Fin (n + 1) → G) :\n    d k G n (Finsupp.single c 1) =\n      Finset.univ.sum fun p : Fin (n + 1) => Finsupp.single (c ∘ p.succ_above) ((-1 : k) ^ (p : ℕ)) :=\n  by simp [d]\n#align d_of d_of\n\n",
 "d_eq":
 "/-- Simpler expression for the differential in the standard resolution of `k` as a\n`G`-representation. It sends `(g₀, ..., gₙ₊₁) ↦ ∑ (-1)ⁱ • (g₀, ..., ĝᵢ, ..., gₙ₊₁)`. -/\ntheorem d_eq (n : ℕ) : ((group_cohomology.resolution k G).d (n + 1) n).hom = d k G (n + 1) :=\n  by\n  ext (x y)\n  dsimp [group_cohomology.resolution]\n  simpa [← @intCast_smul k, simplicial_object.δ]\n#align d_eq d_eq\n\n",
 "d_comp_ε":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\ntheorem d_comp_ε : «expr ≫ » ((group_cohomology.resolution k G).d 1 0) (ε k G) = 0 :=\n  by\n  ext1\n  refine' LinearMap.ext fun x => _\n  have : «expr ≫ » ((forget₂_to_Module k G).d 1 0) ((forget₂ (Rep k G) (ModuleCat.{u} k)).map (ε k G)) = 0 := by\n    rw [← forget₂_to_Module_homotopy_equiv_f_0_eq, ← (forget₂_to_Module_homotopy_equiv k G).1.2 1 0 rfl] <;>\n      exact comp_zero\n  exact LinearMap.ext_iff.1 this _\n#align d_comp_ε d_comp_ε\n\n",
 "X_projective":
 "theorem X_projective (G : Type u) [Group G] (n : ℕ) : Projective ((group_cohomology.resolution k G).X n) :=\n  Rep.equivalence_Module_monoid_algebra.to_adjunction.projective_of_map_projective _ <|\n    @Module.projective_of_free.{u} _ _\n      (ModuleCat.of (MonoidAlgebra k G) (representation.of_mul_action k G (Fin (n + 1) → G)).as_module) _\n      (of_mul_action_basis k G n)\n#align X_projective X_projective\n\n",
 "Action_diagonal_succ_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem Action_diagonal_succ_inv_apply {G : Type u} [Group G] {n : ℕ} (g : G) (f : Fin n → G) :\n    (Action_diagonal_succ G n).inv.hom (g, f) = («expr • » g (Fin.partialProd f) : Fin (n + 1) → G) :=\n  by\n  revert g\n  induction' n with n hn\n  · intro g\n    ext\n    simpa only [subsingleton.elim x 0, Pi.smul_apply, Fin.partialProd_zero, smul_eq_mul, mul_one]\n  · intro g\n    ext\n    dsimp only [Action_diagonal_succ]\n    simp only [iso.trans_inv, comp_hom, hn, diagonal_succ_inv_hom, types_comp_apply, tensor_iso_inv, iso.refl_inv,\n      tensor_hom, id_hom, tensor_apply, types_id_apply, left_regular_tensor_iso_inv_hom, tensor_rho,\n      left_regular_ρ_apply, Pi.smul_apply, smul_eq_mul]\n    refine' Fin.cases _ _ x\n    · simp only [Fin.cons_zero, Fin.partialProd_zero, mul_one]\n    · intro i\n      simpa only [Fin.cons_succ, Pi.smul_apply, smul_eq_mul, Fin.partialProd_succ', mul_assoc]\n#align Action_diagonal_succ_inv_apply Action_diagonal_succ_inv_apply\n\n",
 "Action_diagonal_succ_hom_apply":
 "/-\nCopyright (c) 2022 Amelia Livingston. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Amelia Livingston\n-/\ntheorem Action_diagonal_succ_hom_apply {G : Type u} [Group G] {n : ℕ} (f : Fin (n + 1) → G) :\n    (Action_diagonal_succ G n).hom.hom f = (f 0, fun i => (f i)⁻¹ * f i.succ) :=\n  by\n  induction' n with n hn\n  · exact Prod.ext rfl (funext fun x => Fin.elim0 x)\n  · ext\n    · rfl\n    · dsimp only [Action_diagonal_succ]\n      simp only [iso.trans_hom, comp_hom, types_comp_apply, diagonal_succ_hom_hom, left_regular_tensor_iso_hom_hom,\n        tensor_iso_hom, mk_iso_hom_hom, Equiv.toIso_hom, tensor_hom, Equiv.piFinSuccAboveEquiv_symm_apply, tensor_apply,\n        types_id_apply, tensor_rho, MonoidHom.one_apply, End.one_def, hn fun j : Fin (n + 1) => f j.succ,\n        Fin.coe_eq_castSucc, Fin.insertNth_zero']\n      refine' Fin.cases (Fin.cons_zero _ _) (fun i => _) x\n      · simp only [Fin.cons_succ, mul_left_inj, inv_inj, Fin.castSucc_fin_succ]\n#align Action_diagonal_succ_hom_apply Action_diagonal_succ_hom_apply\n\n"}