{"forget₂_ρ":
 "theorem forget₂_ρ (V : fdRep k G) : ((forget₂ (fdRep k G) (Rep k G)).obj V).ρ = V.ρ :=\n  by\n  ext (g v)\n  rfl\n#align forget₂_ρ forget₂_ρ\n\n",
 "finrank_hom_simple_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n-- Verify that the monoidal structure is available.\n-- We need to provide this instance explicitely as otherwise `finrank_hom_simple_simple` gives a\n-- deterministic timeout.\n-- Verify that Schur's lemma applies out of the box.\ntheorem finrank_hom_simple_simple [is_alg_closed k] (V W : fdRep k G) [simple V] [simple W] :\n    finrank k («expr ⟶ » V W) = if nonempty («expr ≅ » V W) then 1 else 0 :=\n  category_theory.finrank_hom_simple_simple k V W\n#align finrank_hom_simple_simple finrank_hom_simple_simple\n\n",
 "dual_tensor_iso_lin_hom_hom_hom":
 "-- Verify that the right rigid structure is available when the monoid is a group.\n-- The variables in this section are slightly weird, living half in `representation` and half in\n-- `fdRep`. When we have a better API for general monoidal closed and rigid categories and these\n-- structures on `fdRep`, we should remove the dependancy of statements about `fdRep` on\n-- `representation.lin_hom` and `representation.dual`. The isomorphism `dual_tensor_iso_lin_hom`\n-- below should then just be obtained from general results about rigid categories.\n@[simp]\ntheorem dual_tensor_iso_lin_hom_hom_hom : (dual_tensor_iso_lin_hom ρV W).hom.hom = dual_tensor_hom k V W :=\n  rfl\n#align dual_tensor_iso_lin_hom_hom_hom dual_tensor_iso_lin_hom_hom_hom\n\n",
 "conj_ρ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≅ » -/\n/-\nCopyright (c) 2022 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem iso.conj_ρ {V W : fdRep k G} (i : «expr ≅ » V W) (g : G) : W.ρ g = (fdRep.iso_to_linear_equiv i).conj (V.ρ g) :=\n  by\n  rw [fdRep.iso_to_linear_equiv, ← fgModule.iso.conj_eq_conj, iso.conj_apply]\n  rw [iso.eq_inv_comp ((Action.forget (fgModule k) (Mon.of G)).map_iso i)]\n  exact (i.hom.comm g).symm\n#align iso.conj_ρ iso.conj_ρ\n\n"}