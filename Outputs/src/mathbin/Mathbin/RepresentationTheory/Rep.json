{"unit_iso_comm":
 "theorem unit_iso_comm (V : Rep k G) (g : G) (x : V) :\n    unit_iso_add_equiv ((V.ρ g).to_fun x) =\n      ((of_Module_monoid_algebra.obj (to_Module_monoid_algebra.obj V)).ρ g).to_fun (unit_iso_add_equiv x) :=\n  by\n  dsimp [unit_iso_add_equiv, of_Module_monoid_algebra, to_Module_monoid_algebra]\n  simp only [AddEquiv.apply_eq_iff_eq, AddEquiv.apply_symm_apply, representation.as_module_equiv_symm_map_rho,\n    representation.of_module_as_module_act]\n#align unit_iso_comm unit_iso_comm\n\n",
 "trivial_def":
 "theorem trivial_def {V : Type u} [AddCommGroup V] [Module k V] (g : G) (v : V) : (trivial k G V).ρ g v = v :=\n  rfl\n#align trivial_def trivial_def\n\n",
 "to_Module_monoid_algebra_map_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Verify that the symmetric monoidal structure is available.\n/-- Auxilliary lemma for `to_Module_monoid_algebra`. -/\ntheorem to_Module_monoid_algebra_map_aux {k G : Type _} [CommRing k] [Monoid G] (V W : Type _) [AddCommGroup V]\n    [AddCommGroup W] [Module k V] [Module k W] (ρ : «expr →* » G («expr →ₗ[ ] » V k V))\n    (σ : «expr →* » G («expr →ₗ[ ] » W k W)) (f : «expr →ₗ[ ] » V k W) (w : ∀ g : G, f.comp (ρ g) = (σ g).comp f)\n    (r : MonoidAlgebra k G) (x : V) :\n    f ((((MonoidAlgebra.lift k G («expr →ₗ[ ] » V k V)) ρ) r) x) =\n      (((MonoidAlgebra.lift k G («expr →ₗ[ ] » W k W)) σ) r) (f x) :=\n  by\n  apply MonoidAlgebra.induction_on r\n  · intro g\n    simp only [one_smul, MonoidAlgebra.lift_single, MonoidAlgebra.of_apply]\n    exact LinearMap.congr_fun (w g) x\n  · intro g h gw hw\n    simp only [map_add, add_left_inj, LinearMap.add_apply, hw, gw]\n  · intro r g w\n    simp only [AlgHom.map_smul, w, RingHom.id_apply, LinearMap.smul_apply, LinearMap.map_smulₛₗ]\n#align to_Module_monoid_algebra_map_aux to_Module_monoid_algebra_map_aux\n\n",
 "of_ρ_apply":
 "/-- Allows us to apply lemmas about the underlying `ρ`, which would take an element `g : G` rather\nthan `g : Mon.of G` as an argument. -/\ntheorem of_ρ_apply {V : Type u} [AddCommGroup V] [Module k V] (ρ : representation k G V) (g : MonCat.of G) :\n    (Rep.of ρ).ρ g = ρ (g : G) :=\n  rfl\n#align of_ρ_apply of_ρ_apply\n\n",
 "of_ρ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_ρ {V : Type u} [AddCommGroup V] [Module k V] (ρ : «expr →* » G («expr →ₗ[ ] » V k V)) : (of ρ).ρ = ρ :=\n  rfl\n#align of_ρ of_ρ\n\n",
 "of_Module_monoid_algebra_obj_ρ":
 "theorem of_Module_monoid_algebra_obj_ρ (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (of_Module_monoid_algebra.obj M).ρ = representation.of_module k G M :=\n  rfl\n#align of_Module_monoid_algebra_obj_ρ of_Module_monoid_algebra_obj_ρ\n\n",
 "of_Module_monoid_algebra_obj_coe":
 "theorem of_Module_monoid_algebra_obj_coe (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (of_Module_monoid_algebra.obj M : Type u) = RestrictScalars k (MonoidAlgebra k G) M :=\n  rfl\n#align of_Module_monoid_algebra_obj_coe of_Module_monoid_algebra_obj_coe\n\n",
 "monoidal_closed_uncurry_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/-- Given a `k`-linear `G`-representation `A`, the adjunction `A ⊗ - ⊣ iHom(A, -)` defines a\nbijection `Hom(A ⊗ B, C) ≃ Hom(B, iHom(A, C))` for all `B, C`. Given `f : B ⟶ iHom(A, C)`, this\nlemma describes the `k`-linear map underlying `f`'s image under the bijection. It is given by\nflipping the arguments of the `k`-linear map underlying `f`, giving a map `A →ₗ[k] B →ₗ[k] C`, then\nuncurrying. -/\n@[simp]\ntheorem monoidal_closed_uncurry_hom (f : «expr ⟶ » B ((ihom A).obj C)) :\n    (MonoidalClosed.uncurry f).hom = TensorProduct.uncurry _ _ _ _ f.hom.flip :=\n  by\n  simp only [monoidal_closed.of_equiv_uncurry_def, comp_inv_iso_inv_app, monoidal_functor.comm_tensor_left_inv_app,\n    comp_hom, functor_category_monoidal_equivalence.inverse_map, functor_category_equivalence.inverse_map_hom,\n    functor_category_monoidal_equivalence.μ_iso_inv_app]\n  ext\n  rfl\n#align monoidal_closed_uncurry_hom monoidal_closed_uncurry_hom\n\n",
 "monoidal_closed_curry_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_iso -/\n/-- Given a `k`-linear `G`-representation `A`, the adjunction `A ⊗ - ⊣ iHom(A, -)` defines a\nbijection `Hom(A ⊗ B, C) ≃ Hom(B, iHom(A, C))` for all `B, C`. Given `f : A ⊗ B ⟶ C`, this lemma\ndescribes the `k`-linear map underlying `f`'s image under the bijection. It is given by currying the\n`k`-linear map underlying `f`, giving a map `A →ₗ[k] B →ₗ[k] C`, then flipping the arguments. -/\n@[simp]\ntheorem monoidal_closed_curry_hom (f : «expr ⟶ » (tensor_iso A B) C) :\n    (MonoidalClosed.curry f).hom = (TensorProduct.curry f.hom).flip :=\n  by\n  rw [monoidal_closed.curry_eq, comp_hom, ihom_coev_app_hom]\n  rfl\n#align monoidal_closed_curry_hom monoidal_closed_curry_hom\n\n",
 "linearization_μ_inv_hom":
 "@[simp]\ntheorem linearization_μ_inv_hom (X Y : Action (Type u) (MonCat.of G)) :\n    (inv ((linearization k G).μ X Y)).hom = (finsuppTensorFinsupp' k X.V Y.V).symm.to_linear_map :=\n  by\n  simp_rw [← Action.forget_map, functor.map_inv, Action.forget_map, linearization_μ_hom]\n  apply is_iso.inv_eq_of_hom_inv_id _\n  exact LinearMap.ext fun x => LinearEquiv.symm_apply_apply _ _\n#align linearization_μ_inv_hom linearization_μ_inv_hom\n\n",
 "linearization_μ_hom":
 "@[simp]\ntheorem linearization_μ_hom (X Y : Action (Type u) (MonCat.of G)) :\n    ((linearization k G).μ X Y).hom = (finsuppTensorFinsupp' k X.V Y.V).to_linear_map :=\n  rfl\n#align linearization_μ_hom linearization_μ_hom\n\n",
 "linearization_ε_inv_hom_apply":
 "@[simp]\ntheorem linearization_ε_inv_hom_apply (r : k) : (inv (linearization k G).ε).hom (Finsupp.single PUnit.unit r) = r :=\n  by\n  simp_rw [← Action.forget_map, functor.map_inv, Action.forget_map]\n  rw [← Finsupp.lsingle_apply PUnit.unit r]\n  apply is_iso.hom_inv_id_apply _ _\n#align linearization_ε_inv_hom_apply linearization_ε_inv_hom_apply\n\n",
 "linearization_ε_hom":
 "@[simp]\ntheorem linearization_ε_hom : (linearization k G).ε.hom = Finsupp.lsingle PUnit.unit :=\n  rfl\n#align linearization_ε_hom linearization_ε_hom\n\n",
 "linearization_of":
 "@[simp]\ntheorem linearization_of (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V) :\n    ((linearization k G).obj X).ρ g (Finsupp.single x (1 : k)) = Finsupp.single (X.ρ g x) (1 : k) := by\n  rw [linearization_obj_ρ, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single]\n#align linearization_of linearization_of\n\n",
 "linearization_obj_ρ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem linearization_obj_ρ (X : Action (Type u) (MonCat.of G)) (g : G) (x : «expr →₀ » X.V k) :\n    ((linearization k G).obj X).ρ g x = Finsupp.lmapDomain k k (X.ρ g) x :=\n  rfl\n#align linearization_obj_ρ linearization_obj_ρ\n\n",
 "linearization_map_hom_single":
 "theorem linearization_map_hom_single (x : X.V) (r : k) :\n    ((linearization k G).map f).hom (Finsupp.single x r) = Finsupp.single (f.hom x) r := by\n  rw [linearization_map_hom, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single]\n#align linearization_map_hom_single linearization_map_hom_single\n\n",
 "linearization_map_hom":
 "@[simp]\ntheorem linearization_map_hom : ((linearization k G).map f).hom = Finsupp.lmapDomain k k f.hom :=\n  rfl\n#align linearization_map_hom linearization_map_hom\n\n",
 "linear_hom_equiv_symm_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ihom -/\ntheorem monoidal_closed.linear_hom_equiv_symm_hom (f : «expr ⟶ » B (ihom A (Rep k G) C)) :\n    ((monoidal_closed.linear_hom_equiv A B C).symm f).hom = TensorProduct.uncurry k A B C f.hom.flip :=\n  monoidal_closed_uncurry_hom _\n#align monoidal_closed.linear_hom_equiv_symm_hom monoidal_closed.linear_hom_equiv_symm_hom\n\n",
 "linear_hom_equiv_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_iso -/\ntheorem monoidal_closed.linear_hom_equiv_hom (f : «expr ⟶ » (tensor_iso A B) C) :\n    (monoidal_closed.linear_hom_equiv A B C f).hom = (TensorProduct.curry f.hom).flip :=\n  monoidal_closed_curry_hom _\n#align monoidal_closed.linear_hom_equiv_hom monoidal_closed.linear_hom_equiv_hom\n\n",
 "linear_hom_equiv_comm_symm_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ihom -/\ntheorem monoidal_closed.linear_hom_equiv_comm_symm_hom (f : «expr ⟶ » A (ihom B (Rep k G) C)) :\n    ((monoidal_closed.linear_hom_equiv_comm A B C).symm f).hom = TensorProduct.uncurry k A B C f.hom :=\n  by\n  dsimp only [monoidal_closed.linear_hom_equiv_comm]\n  refine' tensor_product.algebra_tensor_module.curry_injective (LinearMap.ext fun x => LinearMap.ext fun y => _)\n  simp only [LinearEquiv.trans_symm, LinearEquiv.trans_apply, linear.hom_congr_symm_apply, iso.refl_inv,\n    LinearMap.coe_comp, Function.comp_apply, category.comp_id, Action.comp_hom,\n    monoidal_closed.linear_hom_equiv_symm_hom, tensor_product.algebra_tensor_module.curry_apply,\n    LinearMap.coe_restrictScalars, LinearMap.toFun_eq_coe, LinearMap.flip_apply, TensorProduct.curry_apply,\n    ModuleCat.coe_comp, Function.comp_apply, monoidal_category.braiding_hom_apply, TensorProduct.uncurry_apply]\n#align monoidal_closed.linear_hom_equiv_comm_symm_hom monoidal_closed.linear_hom_equiv_comm_symm_hom\n\n",
 "linear_hom_equiv_comm_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_iso -/\ntheorem monoidal_closed.linear_hom_equiv_comm_hom (f : «expr ⟶ » (tensor_iso A B) C) :\n    (monoidal_closed.linear_hom_equiv_comm A B C f).hom = TensorProduct.curry f.hom :=\n  by\n  dsimp only [monoidal_closed.linear_hom_equiv_comm]\n  refine' LinearMap.ext fun x => LinearMap.ext fun y => _\n  simp only [LinearEquiv.trans_apply, monoidal_closed.linear_hom_equiv_hom, linear.hom_congr_apply, iso.refl_hom,\n    iso.symm_hom, LinearMap.toFun_eq_coe, LinearMap.coe_comp, Function.comp_apply, linear.left_comp_apply,\n    linear.right_comp_apply, category.comp_id, Action.comp_hom, LinearMap.flip_apply, TensorProduct.curry_apply,\n    ModuleCat.coe_comp, Function.comp_apply, monoidal_category.braiding_inv_apply]\n#align monoidal_closed.linear_hom_equiv_comm_hom monoidal_closed.linear_hom_equiv_comm_hom\n\n",
 "left_regular_hom_equiv_symm_single":
 "theorem left_regular_hom_equiv_symm_single {A : Rep k G} (x : A) (g : G) :\n    ((left_regular_hom_equiv A).symm x).hom (Finsupp.single g 1) = A.ρ g x := by\n  simp only [left_regular_hom_equiv_symm_apply, left_regular_hom_hom, Finsupp.lift_apply, Finsupp.sum_single_index,\n    zero_smul, one_smul]\n#align left_regular_hom_equiv_symm_single left_regular_hom_equiv_symm_single\n\n",
 "left_regular_hom_apply":
 "theorem left_regular_hom_apply {A : Rep k G} (x : A) : (left_regular_hom A x).hom (Finsupp.single 1 1) = x := by\n  simpa only [left_regular_hom_hom, Finsupp.lift_apply, Finsupp.sum_single_index, one_smul, A.ρ.map_one, zero_smul]\n#align left_regular_hom_apply left_regular_hom_apply\n\n",
 "ihom_obj_ρ_def":
 "/-- Explicit description of the 'internal Hom' `iHom(A, B)` of two representations `A, B`:\nthis is `F⁻¹(iHom(F(A), F(B)))`, where `F` is an equivalence\n`Rep k G ≌ (single_obj G ⥤ Module k)`. Just used to prove `Rep.ihom_obj_ρ`. -/\ntheorem ihom_obj_ρ_def :\n    ((ihom A).obj B).ρ =\n      (functor_category_equivalence.inverse.obj\n          ((functor_category_equivalence.functor.obj A).closed_ihom.obj\n            (functor_category_equivalence.functor.obj B))).ρ :=\n  rfl\n#align ihom_obj_ρ_def ihom_obj_ρ_def\n\n",
 "ihom_obj_ρ":
 "/-- Given `k`-linear `G`-representations `(A, ρ₁), (B, ρ₂)`, the 'internal Hom' is the\nrepresentation on `Homₖ(A, B)` sending `g : G` and `f : A →ₗ[k] B` to `(ρ₂ g) ∘ₗ f ∘ₗ (ρ₁ g⁻¹)`. -/\n@[simp]\ntheorem ihom_obj_ρ : ((ihom A).obj B).ρ = A.ρ.lin_hom B.ρ :=\n  by\n  refine' MonoidHom.ext fun g => _\n  simpa only [ihom_obj_ρ_def, functor_category_equivalence.inverse_obj_ρ_apply, functor.closed_ihom_obj_map, ←\n    functor.map_inv, single_obj.inv_as_inv]\n#align ihom_obj_ρ ihom_obj_ρ\n\n",
 "ihom_map_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟶ » -/\n@[simp]\ntheorem ihom_map_hom {B C : Rep k G} (f : «expr ⟶ » B C) : ((ihom A).map f).hom = LinearMap.llcomp k A B C f.hom :=\n  rfl\n#align ihom_map_hom ihom_map_hom\n\n",
 "ihom_ev_app_hom":
 "/-- Describes the counit in the adjunction `A ⊗ - ⊣ iHom(A, -)`; given another `k`-linear\n`G`-representation `B,` the `k`-linear map underlying the resulting morphism `A ⊗ iHom(A, B) ⟶ B`\nis given by uncurrying the map `A →ₗ[k] (A →ₗ[k] B) →ₗ[k] B` defined by flipping the arguments in\nthe identity map on `Homₖ(A, B).` -/\n@[simp]\ntheorem ihom_ev_app_hom : Action.hom.hom ((ihom.ev A).app B) = TensorProduct.uncurry _ _ _ _ LinearMap.id.flip :=\n  monoidal_closed_uncurry_hom _\n#align ihom_ev_app_hom ihom_ev_app_hom\n\n",
 "ihom_coev_app_hom":
 "/-- Describes the unit in the adjunction `A ⊗ - ⊣ iHom(A, -)`; given another `k`-linear\n`G`-representation `B,` the `k`-linear map underlying the resulting map `B ⟶ iHom(A, A ⊗ B)` is\ngiven by flipping the arguments in the natural `k`-bilinear map `A →ₗ[k] B →ₗ[k] A ⊗ B`. -/\n@[simp]\ntheorem ihom_coev_app_hom : Action.hom.hom ((ihom.coev A).app B) = (TensorProduct.mk _ _ _).flip :=\n  by\n  refine' LinearMap.ext fun x => LinearMap.ext fun y => _\n  simpa only [ihom_coev_app_def, functor.map_comp, comp_hom, functor_category_equivalence.inverse_map_hom,\n    functor.closed_ihom_map_app, functor_category_monoidal_equivalence.μ_app]\n#align ihom_coev_app_hom ihom_coev_app_hom\n\n",
 "ihom_coev_app_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≫ » -/\n/-- Unfolds the unit in the adjunction `A ⊗ - ⊣ iHom(A, -)`; just used to prove\n`Rep.ihom_coev_app_hom`. -/\ntheorem ihom_coev_app_def :\n    (ihom.coev A).app B =\n      «expr ≫ » (functor_category_equivalence.unit_iso.hom.app B)\n        (functor_category_equivalence.inverse.map\n          («expr ≫ » ((functor_category_equivalence.functor.obj A).closed_unit.app _)\n            ((functor_category_equivalence.functor.obj A).closed_ihom.map\n              ((functor_category_monoidal_equivalence (ModuleCat.{u} k) (MonCat.of G)).μ A B)))) :=\n  rfl\n#align ihom_coev_app_def ihom_coev_app_def\n\n",
 "coe_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem coe_of {V : Type u} [AddCommGroup V] [Module k V] (ρ : «expr →* » G («expr →ₗ[ ] » V k V)) :\n    (of ρ : Type u) = V :=\n  rfl\n#align coe_of coe_of\n\n",
 "braiding_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprβ_ -/\n@[simp]\ntheorem monoidal_category.braiding_inv_apply {A B : Rep k G} (x : A) (y : B) :\n    Action.hom.hom ((exprβ_) A B).inv (TensorProduct.tmul k y x) = TensorProduct.tmul k x y :=\n  rfl\n#align monoidal_category.braiding_inv_apply monoidal_category.braiding_inv_apply\n\n",
 "braiding_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprβ_ -/\n-- Verify that limits are calculated correctly.\n@[simp]\ntheorem monoidal_category.braiding_hom_apply {A B : Rep k G} (x : A) (y : B) :\n    Action.hom.hom ((exprβ_) A B).hom (TensorProduct.tmul k x y) = TensorProduct.tmul k y x :=\n  rfl\n#align monoidal_category.braiding_hom_apply monoidal_category.braiding_hom_apply\n\n",
 "Rep_of_tprod_iso_inv_apply":
 "theorem Rep_of_tprod_iso_inv_apply (x : TensorProduct k V W) : (Rep_of_tprod_iso ρ τ).inv.hom x = x :=\n  rfl\n#align Rep_of_tprod_iso_inv_apply Rep_of_tprod_iso_inv_apply\n\n",
 "Rep_of_tprod_iso_apply":
 "theorem Rep_of_tprod_iso_apply (x : TensorProduct k V W) : (Rep_of_tprod_iso ρ τ).hom.hom x = x :=\n  rfl\n#align Rep_of_tprod_iso_apply Rep_of_tprod_iso_apply\n\n",
 "Action_ρ_eq_ρ":
 "@[simp]\ntheorem Action_ρ_eq_ρ {A : Rep k G} : Action.ρ A = A.ρ :=\n  rfl\n#align Action_ρ_eq_ρ Action_ρ_eq_ρ\n\n"}