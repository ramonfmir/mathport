{"trivial_def":
 "/-\nCopyright (c) 2022 Antoine Labelle. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Antoine Labelle\n-/\n@[simp]\ntheorem trivial_def (g : G) (v : V) : trivial k g v = v :=\n  rfl\n#align trivial_def trivial_def\n\n",
 "tprod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ » -/\n@[simp]\ntheorem tprod_apply (g : G) : («expr ⊗ » ρV ρW) g = TensorProduct.map (ρV g) (ρW g) :=\n  rfl\n#align tprod_apply tprod_apply\n\n",
 "smul_tprod_one_as_module":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_tprod_one_as_module (r : MonoidAlgebra k G) (x : V) (y : W) :\n    («expr • » r («expr ⊗ₜ » x y) : (ρV.tprod 1).as_module) = «expr ⊗ₜ » («expr • » r x : ρV.as_module) y :=\n  by\n  show as_algebra_hom _ _ _ = «expr ⊗ₜ » (as_algebra_hom _ _ _) _\n  simp only [as_algebra_hom_def, MonoidAlgebra.lift_apply, tprod_apply, MonoidHom.one_apply,\n    LinearMap.finsupp_sum_apply, LinearMap.smul_apply, TensorProduct.map_tmul, LinearMap.one_apply]\n  simp only [Finsupp.sum, TensorProduct.sum_tmul]\n  rfl\n#align smul_tprod_one_as_module smul_tprod_one_as_module\n\n",
 "smul_one_tprod_as_module":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_one_tprod_as_module (r : MonoidAlgebra k G) (x : V) (y : W) :\n    («expr • » r («expr ⊗ₜ » x y) : ((1 : representation k G V).tprod ρW).as_module) =\n      «expr ⊗ₜ » x («expr • » r y : ρW.as_module) :=\n  by\n  show as_algebra_hom _ _ _ = «expr ⊗ₜ » _ (as_algebra_hom _ _ _)\n  simp only [as_algebra_hom_def, MonoidAlgebra.lift_apply, tprod_apply, MonoidHom.one_apply,\n    LinearMap.finsupp_sum_apply, LinearMap.smul_apply, TensorProduct.map_tmul, LinearMap.one_apply]\n  simp only [Finsupp.sum, TensorProduct.tmul_sum, TensorProduct.tmul_smul]\n#align smul_one_tprod_as_module smul_one_tprod_as_module\n\n",
 "smul_of_module_as_module":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_of_module_as_module (r : MonoidAlgebra k G) (m : (of_module k G M).as_module) :\n    (RestrictScalars.addEquiv _ _ _) ((of_module k G M).as_module_equiv («expr • » r m)) =\n      «expr • » r ((RestrictScalars.addEquiv _ _ _) ((of_module k G M).as_module_equiv m)) :=\n  by\n  dsimp\n  simp only [AddEquiv.apply_symm_apply, of_module_as_algebra_hom_apply_apply]\n#align smul_of_module_as_module smul_of_module_as_module\n\n",
 "of_mul_action_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem of_mul_action_single (g : G) (x : H) (r : k) :\n    of_mul_action k G H g (Finsupp.single x r) = Finsupp.single («expr • » g x) r :=\n  Finsupp.mapDomain_single\n#align of_mul_action_single of_mul_action_single\n\n",
 "of_mul_action_self_smul_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem of_mul_action_self_smul_eq_mul (x : MonoidAlgebra k G) (y : (of_mul_action k G G).as_module) :\n    «expr • » x y = (x * y : MonoidAlgebra k G) :=\n  x.induction_on (fun g => by show as_algebra_hom _ _ _ = _ <;> ext <;> simp)\n    (fun x y hx hy => by simp only [hx, hy, add_mul, add_smul]) fun r x hx => by\n    show as_algebra_hom _ _ _ = _ <;> simpa [← hx]\n#align of_mul_action_self_smul_eq_mul of_mul_action_self_smul_eq_mul\n\n",
 "of_mul_action_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\ntheorem of_mul_action_def (g : G) : of_mul_action k G H g = Finsupp.lmapDomain k k ((«expr • » · ·) g) :=\n  rfl\n#align of_mul_action_def of_mul_action_def\n\n",
 "of_mul_action_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem of_mul_action_apply {H : Type _} [MulAction G H] (g : G) (f : «expr →₀ » H k) (h : H) :\n    of_mul_action k G H g f h = f («expr • » g⁻¹ h) :=\n  by\n  conv_lhs => rw [← smul_inv_smul g h]\n  let h' := «expr • » g⁻¹ h\n  change of_mul_action k G H g f («expr • » g h') = f h'\n  have hg : function.injective ((«expr • » · ·) g : H → H) :=\n    by\n    intro h₁ h₂\n    simp\n  simp only [of_mul_action_def, Finsupp.lmapDomain_apply, Finsupp.mapDomain_apply, hg]\n#align of_mul_action_apply of_mul_action_apply\n\n",
 "of_module_as_module_act":
 "@[simp]\ntheorem of_module_as_module_act (g : G) (x : RestrictScalars k (MonoidAlgebra k G) ρ.as_module) :\n    of_module k G ρ.as_module g x =\n      (RestrictScalars.addEquiv _ _ _).symm\n        (ρ.as_module_equiv.symm (ρ g (ρ.as_module_equiv (RestrictScalars.addEquiv _ _ _ x)))) :=\n  by\n  apply_fun RestrictScalars.addEquiv _ _ ρ.as_module using (RestrictScalars.addEquiv _ _ _).injective\n  dsimp [of_module, RestrictScalars.lsmul_apply_apply]\n  simp\n#align of_module_as_module_act of_module_as_module_act\n\n",
 "of_module_as_algebra_hom_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem of_module_as_algebra_hom_apply_apply (r : MonoidAlgebra k G) (m : RestrictScalars k (MonoidAlgebra k G) M) :\n    ((of_module k G M).as_algebra_hom r) m =\n      (RestrictScalars.addEquiv _ _ _).symm («expr • » r (RestrictScalars.addEquiv _ _ _ m)) :=\n  by\n  apply MonoidAlgebra.induction_on r\n  · intro g\n    simp only [one_smul, MonoidAlgebra.lift_symm_apply, MonoidAlgebra.of_apply, representation.as_algebra_hom_single,\n      representation.of_module, AddEquiv.apply_eq_iff_eq, RestrictScalars.lsmul_apply_apply]\n  · intro f g fw gw\n    simp only [fw, gw, map_add, add_smul, LinearMap.add_apply]\n  · intro r f w\n    simp only [w, AlgHom.map_smul, LinearMap.smul_apply, RestrictScalars.addEquiv_symm_map_smul_smul]\n#align of_module_as_algebra_hom_apply_apply of_module_as_algebra_hom_apply_apply\n\n",
 "lin_hom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n@[simp]\ntheorem lin_hom_apply (g : G) (f : «expr →ₗ[ ] » V k W) :\n    (lin_hom ρV ρW) g f = «expr ∘ₗ » (ρW g) («expr ∘ₗ » f (ρV g⁻¹)) :=\n  rfl\n#align lin_hom_apply lin_hom_apply\n\n",
 "dual_tensor_hom_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- Given $k$-modules $V, W$, there is a homomorphism $φ : V^* ⊗ W → Hom_k(V, W)$\n(implemented by `linear_algebra.contraction.dual_tensor_hom`).\nGiven representations of $G$ on $V$ and $W$,there are representations of $G$ on  $V^* ⊗ W$ and on\n$Hom_k(V, W)$.\nThis lemma says that $φ$ is $G$-linear.\n-/\ntheorem dual_tensor_hom_comm (g : G) :\n    «expr ∘ₗ » (dual_tensor_hom k V W) (TensorProduct.map (ρV.dual g) (ρW g)) =\n      «expr ∘ₗ » ((lin_hom ρV ρW) g) (dual_tensor_hom k V W) :=\n  by ext; simp [module.dual.transpose_apply]\n#align dual_tensor_hom_comm dual_tensor_hom_comm\n\n",
 "dual_apply":
 "@[simp]\ntheorem dual_apply (g : G) : (dual ρV) g = module.dual.transpose (ρV g⁻¹) :=\n  rfl\n#align dual_apply dual_apply\n\n",
 "as_module_equiv_symm_map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem as_module_equiv_symm_map_smul (r : k) (x : V) :\n    ρ.as_module_equiv.symm («expr • » r x) =\n      «expr • » (algebraMap k (MonoidAlgebra k G) r) (ρ.as_module_equiv.symm x) :=\n  by\n  apply_fun ρ.as_module_equiv\n  simp\n#align as_module_equiv_symm_map_smul as_module_equiv_symm_map_smul\n\n",
 "as_module_equiv_symm_map_rho":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem as_module_equiv_symm_map_rho (g : G) (x : V) :\n    ρ.as_module_equiv.symm (ρ g x) = «expr • » (MonoidAlgebra.of k G g) (ρ.as_module_equiv.symm x) :=\n  by\n  apply_fun ρ.as_module_equiv\n  simp\n#align as_module_equiv_symm_map_rho as_module_equiv_symm_map_rho\n\n",
 "as_module_equiv_map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem as_module_equiv_map_smul (r : MonoidAlgebra k G) (x : ρ.as_module) :\n    ρ.as_module_equiv («expr • » r x) = ρ.as_algebra_hom r (ρ.as_module_equiv x) :=\n  rfl\n#align as_module_equiv_map_smul as_module_equiv_map_smul\n\n",
 "as_group_hom_apply":
 "theorem as_group_hom_apply (g : G) : ↑(as_group_hom ρ g) = ρ g := by simp only [as_group_hom, MonoidHom.coe_toHomUnits]\n#align as_group_hom_apply as_group_hom_apply\n\n",
 "as_algebra_hom_single_one":
 "theorem as_algebra_hom_single_one (g : G) : as_algebra_hom ρ (Finsupp.single g 1) = ρ g := by simp\n#align as_algebra_hom_single_one as_algebra_hom_single_one\n\n",
 "as_algebra_hom_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem as_algebra_hom_single (g : G) (r : k) : as_algebra_hom ρ (Finsupp.single g r) = «expr • » r (ρ g) := by\n  simp only [as_algebra_hom_def, MonoidAlgebra.lift_single]\n#align as_algebra_hom_single as_algebra_hom_single\n\n",
 "as_algebra_hom_of":
 "theorem as_algebra_hom_of (g : G) : as_algebra_hom ρ (of k G g) = ρ g := by\n  simp only [MonoidAlgebra.of_apply, as_algebra_hom_single, one_smul]\n#align as_algebra_hom_of as_algebra_hom_of\n\n",
 "as_algebra_hom_def":
 "theorem as_algebra_hom_def : as_algebra_hom ρ = (lift k G _) ρ :=\n  rfl\n#align as_algebra_hom_def as_algebra_hom_def\n\n"}