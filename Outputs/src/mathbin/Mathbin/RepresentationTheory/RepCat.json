{"unit_iso_comm":
 "theorem unit_iso_comm (V : Rep k G) (g : G) (x : V) :\n    unit_iso_add_equiv ((V.ρ g).to_fun x) =\n      ((of_Module_monoid_algebra.obj (to_Module_monoid_algebra.obj V)).ρ g).to_fun (unit_iso_add_equiv x) :=\n  by\n  dsimp [unit_iso_add_equiv, of_Module_monoid_algebra, to_Module_monoid_algebra]\n  simp only [AddEquiv.apply_eq_iff_eq, AddEquiv.apply_symm_apply, representation.as_module_equiv_symm_map_rho,\n    representation.of_module_as_module_act]\n#align unit_iso_comm unit_iso_comm\n\n",
 "to_Module_monoid_algebra_map_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Verify that the symmetric monoidal structure is available.\n/-- Auxilliary lemma for `to_Module_monoid_algebra`. -/\ntheorem to_Module_monoid_algebra_map_aux {k G : Type _} [CommRing k] [monoid G] (V W : Type _) [add_comm_group V]\n    [add_comm_group W] [Module k V] [Module k W] (ρ : «expr →* » G («expr →ₗ[ ] » V k V))\n    (σ : «expr →* » G («expr →ₗ[ ] » W k W)) (f : «expr →ₗ[ ] » V k W) (w : ∀ g : G, f.comp (ρ g) = (σ g).comp f)\n    (r : monoid_algebra k G) (x : V) :\n    f ((((monoid_algebra.lift k G («expr →ₗ[ ] » V k V)) ρ) r) x) =\n      (((monoid_algebra.lift k G («expr →ₗ[ ] » W k W)) σ) r) (f x) :=\n  by\n  apply monoid_algebra.induction_on r\n  · intro g\n    simp only [one_smul, monoid_algebra.lift_single, monoid_algebra.of_apply]\n    exact linear_map.congr_fun (w g) x\n  · intro g h gw hw\n    simp only [map_add, add_left_inj, linear_map.add_apply, hw, gw]\n  · intro r g w\n    simp only [alg_hom.map_smul, w, RingHom.id_apply, linear_map.smul_apply, linear_map.map_smulₛₗ]\n#align to_Module_monoid_algebra_map_aux to_Module_monoid_algebra_map_aux\n\n",
 "of_ρ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_ρ {V : Type u} [add_comm_group V] [Module k V] (ρ : «expr →* » G («expr →ₗ[ ] » V k V)) : (of ρ).ρ = ρ :=\n  rfl\n#align of_ρ of_ρ\n\n",
 "of_Module_monoid_algebra_obj_ρ":
 "theorem of_Module_monoid_algebra_obj_ρ (M : Module.{u} (monoid_algebra k G)) :\n    (of_Module_monoid_algebra.obj M).ρ = representation.of_module k G M :=\n  rfl\n#align of_Module_monoid_algebra_obj_ρ of_Module_monoid_algebra_obj_ρ\n\n",
 "of_Module_monoid_algebra_obj_coe":
 "theorem of_Module_monoid_algebra_obj_coe (M : Module.{u} (monoid_algebra k G)) :\n    (of_Module_monoid_algebra.obj M : Type u) = restrict_scalars k (monoid_algebra k G) M :=\n  rfl\n#align of_Module_monoid_algebra_obj_coe of_Module_monoid_algebra_obj_coe\n\n",
 "linearization_of":
 "@[simp]\ntheorem linearization_of (X : Action (Type u) (Mon.of G)) (g : G) (x : X.V) :\n    ((linearization k G).1.1.obj X).ρ g (finsupp.single x (1 : k)) = finsupp.single (X.ρ g x) (1 : k) := by\n  rw [linearization_obj_ρ, finsupp.lmap_domain_apply, finsupp.map_domain_single]\n#align linearization_of linearization_of\n\n",
 "linearization_obj_ρ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n-- Verify that limits are calculated correctly.\n@[simp]\ntheorem linearization_obj_ρ (X : Action (Type u) (Mon.of G)) (g : G) (x : «expr →₀ » X.V k) :\n    ((linearization k G).1.1.obj X).ρ g x = finsupp.lmap_domain k k (X.ρ g) x :=\n  rfl\n#align linearization_obj_ρ linearization_obj_ρ\n\n",
 "linearization_map_hom_of":
 "theorem linearization_map_hom_of (x : X.V) :\n    ((linearization k G).1.1.map f).hom (finsupp.single x (1 : k)) = finsupp.single (f.hom x) (1 : k) := by\n  rw [linearization_map_hom, finsupp.lmap_domain_apply, finsupp.map_domain_single]\n#align linearization_map_hom_of linearization_map_hom_of\n\n",
 "linearization_map_hom":
 "@[simp]\ntheorem linearization_map_hom : ((linearization k G).1.1.map f).hom = finsupp.lmap_domain k k f.hom :=\n  rfl\n#align linearization_map_hom linearization_map_hom\n\n",
 "coe_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\n@[simp]\ntheorem coe_of {V : Type u} [add_comm_group V] [Module k V] (ρ : «expr →* » G («expr →ₗ[ ] » V k V)) :\n    (of ρ : Type u) = V :=\n  rfl\n#align coe_of coe_of\n\n"}