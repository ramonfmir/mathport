{"add_add_one_ne":
 "/-\nCopyright (c) 2020 Jannis Limperg. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jannis Limperg\n-/\n-- TODO This is an improved version of `injection_with` from core\n-- (init/meta/injection_tactic). Remove when the improvements have landed in\n-- core.\n-- C.inj_arrow, for a given constructor C of datatype D, has type\n--\n--     ∀ (A₁ ... Aₙ) (x₁ ... xₘ) (y₁ ... yₘ), C x₁ ... xₘ = C y₁ ... yₘ\n--       → ∀ ⦃P : Sort u⦄, (x₁ = y₁ → ... → yₖ = yₖ → P) → P\n--\n-- where the Aᵢ are parameters of D and the xᵢ/yᵢ are arguments of C.\n-- Note that if xᵢ/yᵢ are propositions, no equation is generated, so the\n-- number of equations is not necessarily the constructor arity.\n-- First, we find out how many equations we need to intro later.\n-- Now we generate the actual proof of the target.\n-- The following filters out 'next' hypotheses of type `true`. The\n-- `inj_arrow` lemmas introduce these for nullary constructors.\n-- The following construction deals with a corner case involing\n-- mutual/nested inductive types. For these, Lean does not generate\n-- no-confusion principles. However, the regular inductive data type which a\n-- mutual/nested inductive type is compiled to does have a no-confusion\n-- principle which we can (usually? always?) use. To find it, we normalise\n-- the constructor with `unfold_ginductive = tt`.\ntheorem add_add_one_ne (n m : ℕ) : n + (m + 1) ≠ n :=\n  by\n  apply ne_of_gt\n  apply nat.lt_add_of_pos_right\n  apply nat.pos_of_ne_zero\n  contradiction\n#align add_add_one_ne add_add_one_ne\n\n"}