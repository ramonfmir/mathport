{"cseval_pow":
 "theorem cseval_pow {α} [CommSemiring α] (t : Tree α) {x : horner_expr} (cs : x.is_cs) :\n    ∀ n : Num, (pow x n).is_cs ∧ cseval t (pow x n) = cseval t x ^ (n : ℕ)\n  | 0 => ⟨⟨1, rfl⟩, (pow_zero _).symm⟩\n  | Num.pos p => by\n    simp [pow]; induction' p with p ep p ep\n    · simp [*]\n    · simp [pow_bit1]\n      cases' cseval_mul t ep.1 ep.1 with cs₀ h₀\n      cases' cseval_mul t cs₀ cs with cs₁ h₁\n      simp [*]\n    · simp [pow_bit0]\n      cases' cseval_mul t ep.1 ep.1 with cs₀ h₀\n      simp [*]\n#align cseval_pow cseval_pow\n\n",
 "cseval_of_csexpr":
 "/-- For any given tree `t` of atoms and any reflected expression `r`,\nthe Horner form of `r` is a valid csring expression, and under `t`,\nthe Horner form evaluates to the same thing as `r`. -/\ntheorem cseval_of_csexpr {α} [CommSemiring α] (t : Tree α) :\n    ∀ r : csring_expr, (of_csexpr r).is_cs ∧ cseval t (of_csexpr r) = r.eval t\n  | csring_expr.atom n => cseval_atom _ _\n  | csring_expr.const n => ⟨⟨n, rfl⟩, by cases n <;> rfl⟩\n  | csring_expr.add x y =>\n    let ⟨cs₁, h₁⟩ := cseval_of_csexpr x\n    let ⟨cs₂, h₂⟩ := cseval_of_csexpr y\n    let ⟨cs, h⟩ := cseval_add t cs₁ cs₂\n    ⟨cs, by simp! [h, *]⟩\n  | csring_expr.mul x y =>\n    let ⟨cs₁, h₁⟩ := cseval_of_csexpr x\n    let ⟨cs₂, h₂⟩ := cseval_of_csexpr y\n    let ⟨cs, h⟩ := cseval_mul t cs₁ cs₂\n    ⟨cs, by simp! [h, *]⟩\n  | csring_expr.pow x n =>\n    let ⟨cs, h⟩ := cseval_of_csexpr x\n    let ⟨cs, h⟩ := cseval_pow t cs n\n    ⟨cs, by simp! [h, *]⟩\n#align cseval_of_csexpr cseval_of_csexpr\n\n",
 "cseval_mul_const":
 "theorem cseval_mul_const {α} [CommSemiring α] (t : Tree α) (k : Num) {e : horner_expr} (cs : e.is_cs) :\n    (mul_const k.to_znum e).is_cs ∧ cseval t (mul_const k.to_znum e) = cseval t e * k :=\n  by\n  simp [mul_const]\n  split_ifs with h h\n  · cases (Num.toZNum_inj.1 h : k = 0)\n    exact ⟨⟨0, rfl⟩, (MulZeroClass.mul_zero _).symm⟩\n  · cases (Num.toZNum_inj.1 h : k = 1)\n    exact ⟨cs, (mul_one _).symm⟩\n  induction' e with n a x n b A B <;> simp [*]\n  · rcases cs with ⟨n, rfl⟩\n    suffices\n    refine' ⟨⟨n * k, this⟩, _⟩\n    swap\n    · cases n <;> cases k <;> rfl\n    rw [show _ from this]\n    simp!\n  · cases cs\n    simp! [*]\n    symm\n    apply tactic.ring.horner_mul_const <;> rfl\n#align cseval_mul_const cseval_mul_const\n\n",
 "cseval_mul":
 "theorem cseval_mul {α} [CommSemiring α] (t : Tree α) {e₁ e₂ : horner_expr} (cs₁ : e₁.is_cs) (cs₂ : e₂.is_cs) :\n    (mul e₁ e₂).is_cs ∧ cseval t (mul e₁ e₂) = cseval t e₁ * cseval t e₂ :=\n  by\n  induction' e₁ with n₁ a₁ x₁ n₁ b₁ A₁ B₁ generalizing e₂ <;> simp!\n  · rcases cs₁ with ⟨n₁, rfl⟩\n    simpa [mul_comm] using cseval_mul_const t n₁ cs₂\n  induction' e₂ with n₂ a₂ x₂ n₂ b₂ A₂ B₂\n  · rcases cs₂ with ⟨n₂, rfl⟩\n    simpa! using cseval_mul_const t n₂ cs₁\n  cases' cs₁ with csa₁ csb₁; cases' id cs₂ with csa₂ csb₂\n  simp! ; have C := PosNum.cmp_to_nat x₁ x₂\n  cases' A₂ csa₂ with csA₂ hA₂\n  cases PosNum.cmp x₁ x₂ <;> simp!\n  · simp [A₁ csa₁ cs₂, B₁ csb₁ cs₂]\n    symm\n    apply tactic.ring.horner_mul_const <;> rfl\n  · cases' cseval_horner' t _ x₁ n₂ 0 csA₂ ⟨0, rfl⟩ with csh₁ h₁\n    cases C\n    split_ifs\n    · subst b₂\n      refine' ⟨csh₁, h₁.trans (Eq.symm _)⟩\n      apply tactic.ring.horner_mul_horner_zero <;> try rfl\n      simp! [hA₂]\n    · cases' A₁ csa₁ csb₂ with csA₁ hA₁\n      cases' cseval_add t csh₁ _ with csh₂ h₂\n      · refine' ⟨csh₂, h₂.trans (Eq.symm _)⟩\n        apply tactic.ring.horner_mul_horner <;> try rfl\n        simp! [*]\n      exact ⟨csA₁, (B₁ csb₁ csb₂).1⟩\n  · simp [A₂ csa₂, B₂ csb₂]\n    rw [mul_comm, eq_comm]\n    apply tactic.ring.horner_const_mul\n    · apply mul_comm\n    · rfl\n#align cseval_mul cseval_mul\n\n",
 "cseval_horner'":
 "theorem cseval_horner' {α} [CommSemiring α] (t : Tree α) (a x n b) (h₁ : is_cs a) (h₂ : is_cs b) :\n    (horner' a x n b).is_cs ∧\n      cseval t (horner' a x n b) = tactic.ring.horner (cseval t a) (t.get_or_zero x) n (cseval t b) :=\n  by\n  cases' a with n₁ a₁ x₁ n₁ b₁ <;> simp [horner'] <;> split_ifs\n  · simp! [*, tactic.ring.horner]\n  · exact ⟨⟨h₁, h₂⟩, rfl⟩\n  · refine' ⟨⟨h₁.1, h₂⟩, Eq.symm _⟩\n    simp! [*]\n    apply tactic.ring.horner_horner\n    simp\n  · exact ⟨⟨h₁, h₂⟩, rfl⟩\n#align cseval_horner' cseval_horner'\n\n",
 "cseval_atom":
 "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\n/- (atom n) is an opaque element of the csring. For example,\na local variable in the context. n indexes into a storage\nof such atoms - a `tree α`. -/\n/- (const n) is technically the csring's one, added n times.\nOr the zero if n is 0. -/\n/- (const n) is a constant n in the csring, similarly to the same\nconstructor in `csring_expr`. This one, however, can be negative. -/\n/- (horner a x n b) is a*xⁿ + b, where x is the x-th atom\nin the atom tree. -/\n/-begin\n  induction e₁ with n₁ a₁ x₁ n₁ b₁ A₁ B₁ generalizing e₂,\n  { exact add_const n₁ e₂ },\n  exact match e₂ with e₂ := begin\n    induction e₂ with n₂ a₂ x₂ n₂ b₂ A₂ B₂ generalizing n₁ b₁;\n    let e₁ := horner a₁ x₁ n₁ b₁,\n    { exact add_const n₂ e₁ },\n    let e₂ := horner a₂ x₂ n₂ b₂,\n    exact match pos_num.cmp x₁ x₂ with\n    | ordering.lt := horner a₁ x₁ n₁ (B₁ e₂)\n    | ordering.gt := horner a₂ x₂ n₂ (B₂ n₁ b₁)\n    | ordering.eq :=\n      match num.sub' n₁ n₂ with\n      | znum.zero := horner' (A₁ a₂) x₁ n₁ (B₁ b₂)\n      | (znum.pos k) := horner (A₂ k 0) x₁ n₂ (B₁ b₂)\n      | (znum.neg k) := horner (A₁ (horner a₂ x₁ k 0)) x₁ n₁ (B₁ b₂)\n      end\n    end\n  end end\nend-/\n/-begin\n  induction e₁ with n₁ a₁ x₁ n₁ b₁ A₁ B₁ generalizing e₂,\n  { exact mul_const n₁ e₂ },\n  induction e₂ with n₂ a₂ x₂ n₂ b₂ A₂ B₂;\n  let e₁ := horner a₁ x₁ n₁ b₁,\n  { exact mul_const n₂ e₁ },\n  let e₂ := horner a₂ x₂ n₂ b₂,\n  cases pos_num.cmp x₁ x₂,\n  { exact horner (A₁ e₂) x₁ n₁ (B₁ e₂) },\n  { let haa := horner' A₂ x₁ n₂ 0,\n    exact if b₂ = 0 then haa else\n      haa.add (horner (A₁ b₂) x₁ n₁ (B₁ b₂)) },\n  { exact horner A₂ x₂ n₂ B₂ }\nend-/\ntheorem cseval_atom {α} [CommSemiring α] (t : Tree α) (n : PosNum) :\n    (atom n).is_cs ∧ cseval t (atom n) = t.get_or_zero n :=\n  ⟨⟨⟨1, rfl⟩, ⟨0, rfl⟩⟩, (tactic.ring.horner_atom _).symm⟩\n#align cseval_atom cseval_atom\n\n",
 "cseval_add_const":
 "theorem cseval_add_const {α} [CommSemiring α] (t : Tree α) (k : Num) {e : horner_expr} (cs : e.is_cs) :\n    (add_const k.to_znum e).is_cs ∧ cseval t (add_const k.to_znum e) = k + cseval t e :=\n  by\n  simp [add_const]\n  cases k <;> simp! [*]\n  simp [show ZNum.pos k ≠ 0 by decide]\n  induction' e with n a x n b A B <;> simp [*]\n  · rcases cs with ⟨n, rfl⟩\n    refine' ⟨⟨n + Num.pos k, by simp [add_comm] <;> rfl⟩, _⟩\n    cases n <;> simp!\n  · rcases B cs.2 with ⟨csb, h⟩\n    simp! [*, cs.1]\n    rw [← tactic.ring.horner_add_const, add_comm]\n    rw [add_comm]\n#align cseval_add_const cseval_add_const\n\n",
 "cseval_add":
 "theorem cseval_add {α} [CommSemiring α] (t : Tree α) {e₁ e₂ : horner_expr} (cs₁ : e₁.is_cs) (cs₂ : e₂.is_cs) :\n    (add e₁ e₂).is_cs ∧ cseval t (add e₁ e₂) = cseval t e₁ + cseval t e₂ :=\n  by\n  induction' e₁ with n₁ a₁ x₁ n₁ b₁ A₁ B₁ generalizing e₂ <;> simp!\n  · rcases cs₁ with ⟨n₁, rfl⟩\n    simpa using cseval_add_const t n₁ cs₂\n  induction' e₂ with n₂ a₂ x₂ n₂ b₂ A₂ B₂ generalizing n₁ b₁\n  · rcases cs₂ with ⟨n₂, rfl⟩\n    simp! [cseval_add_const t n₂ cs₁, add_comm]\n  cases' cs₁ with csa₁ csb₁; cases' id cs₂ with csa₂ csb₂\n  simp! ; have C := PosNum.cmp_to_nat x₁ x₂\n  cases PosNum.cmp x₁ x₂ <;> simp!\n  · rcases B₁ csb₁ cs₂ with ⟨csh, h⟩\n    refine' ⟨⟨csa₁, csh⟩, Eq.symm _⟩\n    apply tactic.ring.horner_add_const\n    exact h.symm\n  · cases C\n    have B0 :\n      is_cs 0 → ∀ {e₂ : horner_expr}, is_cs e₂ → is_cs (add 0 e₂) ∧ cseval t (add 0 e₂) = cseval t 0 + cseval t e₂ :=\n      fun _ e₂ c => ⟨c, (zero_add _).symm⟩\n    cases' e : Num.sub' n₁ n₂ with k k <;> simp!\n    · have : n₁ = n₂ := by\n        have := congr_arg (coe : ZNum → ℤ) e\n        simp at this\n        have := sub_eq_zero.1 this\n        rw [← Num.to_nat_to_int, ← Num.to_nat_to_int] at this\n        exact Num.to_nat_inj.1 (Int.ofNat.inj this)\n      subst n₂\n      rcases cseval_horner' _ _ _ _ _ _ _ with ⟨csh, h⟩\n      · refine' ⟨csh, h.trans (Eq.symm _)⟩\n        simp [*]\n        apply tactic.ring.horner_add_horner_eq <;> try rfl\n      all_goals simp! [*]\n    · simp [B₁ csb₁ csb₂, add_comm]\n      rcases A₂ csa₂ _ _ B0 ⟨csa₁, 0, rfl⟩ with ⟨csh, h⟩\n      refine' ⟨csh, Eq.symm _⟩\n      rw [show id = add 0 from rfl, h]\n      apply tactic.ring.horner_add_horner_gt\n      · change (_ + k : ℕ) = _\n        rw [← Int.coe_nat_inj', Int.ofNat_add, eq_comm, ← sub_eq_iff_eq_add']\n        simpa using congr_arg (coe : ZNum → ℤ) e\n      · rfl\n      · apply add_comm\n    · have : (horner a₂ x₁ (Num.pos k) 0).is_cs := ⟨csa₂, 0, rfl⟩\n      simp [B₁ csb₁ csb₂, A₁ csa₁ this]\n      symm\n      apply tactic.ring.horner_add_horner_lt\n      · change (_ + k : ℕ) = _\n        rw [← Int.coe_nat_inj', Int.ofNat_add, eq_comm, ← sub_eq_iff_eq_add', ← neg_inj, neg_sub]\n        simpa using congr_arg (coe : ZNum → ℤ) e\n      all_goals rfl\n  · rcases B₂ csb₂ _ _ B₁ ⟨csa₁, csb₁⟩ with ⟨csh, h⟩\n    refine' ⟨⟨csa₂, csh⟩, Eq.symm _⟩\n    apply tactic.ring.const_add_horner\n    simp [h]\n#align cseval_add cseval_add\n\n",
 "correctness":
 "/-- The main proof-by-reflection theorem. Given reflected csring expressions\n`r₁` and `r₂` plus a storage `t` of atoms, if both expressions go to the\nsame Horner normal form, then the original non-reflected expressions are\nequal. `H` follows from kernel reduction and is therefore `rfl`. -/\ntheorem correctness {α} [CommSemiring α] (t : Tree α) (r₁ r₂ : csring_expr)\n    (H : horner_expr.of_csexpr r₁ = horner_expr.of_csexpr r₂) : r₁.eval t = r₂.eval t := by\n  repeat' rw [← (horner_expr.cseval_of_csexpr t _).2] <;> rw [H]\n#align correctness correctness\n\n"}