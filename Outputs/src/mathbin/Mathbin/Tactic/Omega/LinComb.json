{"unsat_of_unsat_lin_comb":
 "theorem unsat_of_unsat_lin_comb (ns : List Nat) (ts : List term) : unsat_lin_comb ns ts → clause.unsat ([], ts) :=\n  by\n  intro h1 h2; cases' h2 with v h2\n  have h3 := lin_comb_holds ns h2.right\n  cases' h1 with hl hr\n  cases' lin_comb ns ts with b as\n  unfold term.val at h3\n  rw [coeffs.val_eq_zero hr, add_zero, ← not_lt] at h3\n  apply h3 hl\n#align unsat_of_unsat_lin_comb unsat_of_unsat_lin_comb\n\n",
 "unsat_lin_comb_of":
 "theorem unsat_lin_comb_of (ns : List Nat) (ts : List term) :\n    (lin_comb ns ts).fst < 0 → (∀ x ∈ (lin_comb ns ts).snd, x = (0 : int)) → unsat_lin_comb ns ts :=\n  by\n  intro h1 h2\n  exact ⟨h1, h2⟩\n#align unsat_lin_comb_of unsat_lin_comb_of\n\n",
 "lin_comb_holds":
 "/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nLinear combination of constraints.\n-/\ntheorem lin_comb_holds {v : Nat → int} : ∀ {ts} (ns), (∀ t ∈ ts, 0 ≤ term.val v t) → 0 ≤ (lin_comb ns ts).val v\n  | [], [], h => by simp only [add_zero, term.val, lin_comb, coeffs.val_nil]\n  | [], _ :: _, h => by simp only [add_zero, term.val, lin_comb, coeffs.val_nil]\n  | _ :: _, [], h => by simp only [add_zero, term.val, lin_comb, coeffs.val_nil]\n  | t :: ts, n :: ns, h =>\n    by\n    have : 0 ≤ ↑n * term.val v t + term.val v (lin_comb ns ts) :=\n      by\n      apply add_nonneg\n      · apply mul_nonneg\n        apply Int.coe_nat_nonneg\n        apply h _ (or.inl rfl)\n      · apply lin_comb_holds\n        apply List.forall_mem_of_forall_mem_cons h\n    simpa only [lin_comb, term.val_mul, term.val_add]\n#align lin_comb_holds lin_comb_holds\n\n"}