{"val_sub":
 "@[simp]\ntheorem val_sub {is js : List int} : val v (sub is js) = val v is - val v js :=\n  by\n  unfold val\n  rw [val_between_sub]\n  apply fun_mono_2 <;> apply val_between_eq_of_le <;> rw [zero_add, length_sub]\n  apply le_max_left\n  apply le_max_right\n#align val_sub val_sub\n\n",
 "val_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.func.set -/\n@[simp]\ntheorem val_set {m : Nat} {a : int} : val v (list.func.set [] m a) = a * v m :=\n  by\n  apply val_between_set (zero_le _)\n  rw [length_set, zero_add]\n  exact lt_max_of_lt_right (lt_add_one _)\n#align val_set val_set\n\n",
 "val_nil":
 "@[simp]\ntheorem val_nil : val v [] = 0 :=\n  rfl\n#align val_nil val_nil\n\n",
 "val_neg":
 "@[simp]\ntheorem val_neg {as : List int} : val v (neg as) = -val v as := by simpa only [val, length_neg] using val_between_neg\n#align val_neg val_neg\n\n",
 "val_map_div":
 "@[simp]\ntheorem val_map_div {as : List int} {i : int} :\n    (∀ x ∈ as, i ∣ x) → val v (list.map (fun x => x / i) as) = val v as / i :=\n  by\n  intro h1\n  simpa only [val, list.length_map] using val_between_map_div h1\n#align val_map_div val_map_div\n\n",
 "val_except_update_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.func.set -/\ntheorem val_except_update_set {n : Nat} {as : List int} {i j : int} :\n    val_except n (omega.update v n i) (list.func.set as n j) = val_except n v as := by\n  apply val_except_eq_val_except update_eq_of_ne (get_set_eq_of_ne _)\n#align val_except_update_set val_except_update_set\n\n",
 "val_except_eq_val_except":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ≠ » k) -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ≠ » k) -/\ntheorem val_except_eq_val_except {k : Nat} {is js : List int} {v w : Nat → int} :\n    (∀ (x) (_ : x ≠ k), v x = w x) → (∀ (x) (_ : x ≠ k), get x is = get x js) → val_except k v is = val_except k w js :=\n  by\n  intro h1 h2; unfold val_except\n  apply fun_mono_2\n  ·\n    apply val_between_eq_val_between <;> intro x h3 h4 <;> [· apply h1, · apply h2] <;> apply ne_of_lt <;>\n        rw [zero_add] at h4 <;>\n      apply h4\n  · repeat' rw [← val_between_eq_of_le (max is.length js.length - (k + 1))]\n    ·\n      apply val_between_eq_val_between <;> intro x h3 h4 <;> [· apply h1, · apply h2] <;> apply ne.symm <;>\n            apply ne_of_lt <;>\n          rw [Nat.lt_iff_add_one_le] <;>\n        exact h3\n    · refine' le_trans (le_max_right _ _) le_add_tsub\n    · refine' le_trans (le_max_left _ _) le_add_tsub\n#align val_except_eq_val_except val_except_eq_val_except\n\n",
 "val_except_add_eq":
 "theorem val_except_add_eq (n : Nat) {as : List int} : val_except n v as + get n as * v n = val v as :=\n  by\n  unfold val_except\n  unfold val\n  cases' le_total (n + 1) as.length with h1 h1\n  · have h4 := @val_between_add_val_between v as 0 (n + 1) (as.length - (n + 1))\n    have h5 : n + 1 + (as.length - (n + 1)) = as.length := by rw [add_comm, tsub_add_cancel_of_le h1]\n    rw [h5] at h4\n    apply Eq.trans _ h4\n    simp only [val_between, zero_add]\n    ring\n  have h2 : list.length as - (n + 1) = 0 := tsub_eq_zero_iff_le.mpr h1\n  have h3 : val_between v as 0 (list.length as) = val_between v as 0 (n + 1) := by\n    simpa only [val] using @val_eq_of_le v as (n + 1) h1\n  simp only [add_zero, val_between, zero_add, h2, h3]\n#align val_except_add_eq val_except_add_eq\n\n",
 "val_eq_zero":
 "theorem val_eq_zero {is : List int} : (∀ x : int, x ∈ is → x = 0) → val v is = 0 := by apply val_between_eq_zero\n#align val_eq_zero val_eq_zero\n\n",
 "val_eq_of_le":
 "theorem val_eq_of_le {as : List int} {k : Nat} : as.length ≤ k → val v as = val_between v as 0 k :=\n  by\n  intro h1; unfold val\n  rw [val_between_eq_of_le k _]; rfl\n  rw [zero_add]; exact h1\n#align val_eq_of_le val_eq_of_le\n\n",
 "val_between_sub":
 "theorem val_between_sub {is js : List int} {l : Nat} :\n    ∀ m, val_between v (sub is js) l m = val_between v is l m - val_between v js l m\n  | 0 => rfl\n  | m + 1 => by\n    simp only [val_between, val_between_sub m, List.Func.get, get_sub]\n    ring\n#align val_between_sub val_between_sub\n\n",
 "val_between_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.func.set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.func.set -/\ntheorem val_between_set {a : int} {l n : Nat} :\n    ∀ {m}, l ≤ n → n < l + m → val_between v (list.func.set [] n a) l m = a * v n\n  | 0, h1, h2 => by exfalso; apply lt_irrefl l (lt_of_le_of_lt h1 h2)\n  | m + 1, h1, h2 => by\n    rw [← add_assoc, Nat.lt_succ_iff, le_iff_eq_or_lt] at h2\n    cases h2 <;> unfold val_between\n    · have h3 : val_between v (list.func.set [] (l + m) a) l m = 0 :=\n        by\n        apply @Eq.trans _ _ (val_between v [] l m)\n        · apply val_between_eq_val_between\n          · intros\n            rfl\n          · intro x h4 h5\n            rw [get_nil, get_set_eq_of_ne, get_nil]\n            apply ne_of_lt h5\n        apply val_between_nil\n      rw [h2]\n      simp only [h3, zero_add, List.Func.get_set]\n    · have h3 : l + m ≠ n := by apply ne_of_gt h2\n      rw [@val_between_set m h1 h2, get_set_eq_of_ne _ _ h3]\n      simp only [h3, get_nil, add_zero, MulZeroClass.zero_mul, Int.default_eq_zero]\n#align val_between_set val_between_set\n\n",
 "val_between_nil":
 "/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nNon-constant terms of linear constraints are represented\nby storing their coefficients in integer lists.\n-/\n@[simp]\ntheorem val_between_nil {l : Nat} : ∀ m, val_between v [] l m = 0\n  | 0 => by simp only [val_between]\n  | m + 1 => by\n    simp only [val_between_nil m, omega.coeffs.val_between, get_nil, zero_add, MulZeroClass.zero_mul,\n      Int.default_eq_zero]\n#align val_between_nil val_between_nil\n\n",
 "val_between_neg":
 "theorem val_between_neg {as : List int} {l : Nat} : ∀ {o}, val_between v (neg as) l o = -val_between v as l o\n  | 0 => rfl\n  | o + 1 => by\n    unfold val_between\n    rw [neg_add, neg_mul_eq_neg_mul]\n    apply fun_mono_2\n    apply val_between_neg\n    apply fun_mono_2 _ rfl\n    apply get_neg\n#align val_between_neg val_between_neg\n\n",
 "val_between_map_mul":
 "@[simp]\ntheorem val_between_map_mul {i : int} {as : List int} {l : Nat} :\n    ∀ {m}, val_between v (list.map ((· * ·) i) as) l m = i * val_between v as l m\n  | 0 => by simp only [val_between, MulZeroClass.mul_zero, list.map]\n  | m + 1 => by\n    unfold val_between\n    rw [@val_between_map_mul m, mul_add]\n    apply fun_mono_2 rfl\n    by_cases h1 : l + m < as.length\n    · rw [get_map h1, mul_assoc]\n    rw [not_lt] at h1\n    rw [get_eq_default_of_le, get_eq_default_of_le] <;> try simp <;> apply h1\n#align val_between_map_mul val_between_map_mul\n\n",
 "val_between_map_div":
 "@[simp]\ntheorem val_between_map_div {as : List int} {i : int} {l : Nat} (h1 : ∀ x ∈ as, i ∣ x) :\n    ∀ {m}, val_between v (list.map (fun x => x / i) as) l m = val_between v as l m / i\n  | 0 => by simp only [Int.zero_div, val_between, list.map]\n  | m + 1 => by\n    unfold val_between\n    rw [@val_between_map_div m, Int.add_ediv_of_dvd_right]\n    apply fun_mono_2 rfl\n    ·\n      apply\n        calc\n          get (l + m) (list.map (fun x : ℤ => x / i) as) * v (l + m) = get (l + m) as / i * v (l + m) :=\n            by\n            apply fun_mono_2 _ rfl\n            rw [get_map']\n            apply Int.zero_div\n          _ = get (l + m) as * v (l + m) / i :=\n            by\n            repeat' rw [mul_comm _ (v (l + m))]\n            rw [Int.mul_ediv_assoc]\n            apply forall_val_dvd_of_forall_mem_dvd h1\n          \n    apply dvd_mul_of_dvd_left\n    apply forall_val_dvd_of_forall_mem_dvd h1\n#align val_between_map_div val_between_map_div\n\n",
 "val_between_eq_zero":
 "theorem val_between_eq_zero {is : List int} {l : Nat} : ∀ {m}, (∀ x : int, x ∈ is → x = 0) → val_between v is l m = 0\n  | 0, h1 => rfl\n  | m + 1, h1 => by\n    have h2 := @forall_val_of_forall_mem _ _ is (fun x => x = 0) rfl h1\n    simpa only [val_between, h2 (l + m), MulZeroClass.zero_mul, add_zero] using @val_between_eq_zero m h1\n#align val_between_eq_zero val_between_eq_zero\n\n",
 "val_between_eq_val_between":
 "theorem val_between_eq_val_between {v w : Nat → int} {as bs : List int} {l : Nat} :\n    ∀ {m},\n      (∀ x, l ≤ x → x < l + m → v x = w x) →\n        (∀ x, l ≤ x → x < l + m → get x as = get x bs) → val_between v as l m = val_between w bs l m\n  | 0, h1, h2 => rfl\n  | m + 1, h1, h2 => by\n    unfold val_between\n    have h3 : l + m < l + (m + 1) := by\n      rw [← add_assoc]\n      apply lt_add_one\n    apply fun_mono_2\n    apply val_between_eq_val_between <;> intro x h4 h5\n    · apply h1 _ h4 (lt_trans h5 h3)\n    · apply h2 _ h4 (lt_trans h5 h3)\n    rw [h1 _ _ h3, h2 _ _ h3] <;> apply nat.le_add_right\n#align val_between_eq_val_between val_between_eq_val_between\n\n",
 "val_between_eq_of_le":
 "theorem val_between_eq_of_le {as : List int} {l : Nat} :\n    ∀ m, as.length ≤ l + m → val_between v as l m = val_between v as l (as.length - l)\n  | 0, h1 => by\n    rw [add_zero] at h1\n    rw [tsub_eq_zero_iff_le.mpr h1]\n  | m + 1, h1 => by\n    rw [le_iff_eq_or_lt] at h1\n    cases h1\n    · rw [h1, add_comm l, add_tsub_cancel_right]\n    have h2 : list.length as ≤ l + m := by\n      rw [← Nat.lt_succ_iff]\n      apply h1\n    simpa [get_eq_default_of_le _ h2, MulZeroClass.zero_mul, add_zero, val_between] using val_between_eq_of_le _ h2\n#align val_between_eq_of_le val_between_eq_of_le\n\n",
 "val_between_add_val_between":
 "theorem val_between_add_val_between {as : List int} {l m : Nat} :\n    ∀ {n}, val_between v as l m + val_between v as (l + m) n = val_between v as l (m + n)\n  | 0 => by simp only [val_between, add_zero]\n  | n + 1 => by\n    rw [← add_assoc]\n    unfold val_between\n    rw [add_assoc]\n    rw [← @val_between_add_val_between n]\n    ring\n#align val_between_add_val_between val_between_add_val_between\n\n",
 "val_between_add":
 "theorem val_between_add {is js : List int} {l : Nat} :\n    ∀ m, val_between v (add is js) l m = val_between v is l m + val_between v js l m\n  | 0 => rfl\n  | m + 1 => by\n    simp only [val_between, val_between_add m, List.Func.get, get_add]\n    ring\n#align val_between_add val_between_add\n\n",
 "val_add":
 "@[simp]\ntheorem val_add {is js : List int} : val v (add is js) = val v is + val v js :=\n  by\n  unfold val\n  rw [val_between_add]; apply fun_mono_2 <;> apply val_between_eq_of_le <;> rw [zero_add, length_add]\n  apply le_max_left; apply le_max_right\n#align val_add val_add\n\n",
 "forall_val_dvd_of_forall_mem_dvd":
 "theorem forall_val_dvd_of_forall_mem_dvd {i : int} {as : List int} : (∀ x ∈ as, i ∣ x) → ∀ n, i ∣ get n as\n  | h1, n => by\n    apply forall_val_of_forall_mem _ h1\n    apply dvd_zero\n#align forall_val_dvd_of_forall_mem_dvd forall_val_dvd_of_forall_mem_dvd\n\n",
 "dvd_val_between":
 "theorem dvd_val_between {i} {as : List int} {l : Nat} : ∀ {m}, (∀ x ∈ as, i ∣ x) → i ∣ val_between v as l m\n  | 0, h1 => dvd_zero _\n  | m + 1, h1 => by\n    unfold val_between\n    apply dvd_add\n    apply dvd_val_between h1\n    apply dvd_mul_of_dvd_left\n    by_cases h2 : get (l + m) as = 0\n    · rw [h2]\n      apply dvd_zero\n    apply h1; apply mem_get_of_ne_zero h2\n#align dvd_val_between dvd_val_between\n\n",
 "dvd_val":
 "theorem dvd_val {as : List int} {i : int} : (∀ x ∈ as, i ∣ x) → i ∣ val v as := by apply dvd_val_between\n#align dvd_val dvd_val\n\n"}