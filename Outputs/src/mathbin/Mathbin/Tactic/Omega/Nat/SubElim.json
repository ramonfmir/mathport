{"val_sub_subst":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.cst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.var -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.add -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.sub -/\n/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nSubtraction elimination for linear natural number arithmetic.\nWorks by repeatedly rewriting goals of the preform `P[t-s]` into\n`P[x] ∧ (t = s + x ∨ (t ≤ s ∧ x = 0))`, where `x` is fresh.\n-/\ntheorem val_sub_subst {k : Nat} {x y : preterm} {v : Nat → Nat} :\n    ∀ {t : preterm}, t.fresh_index ≤ k → (sub_subst x y k t).val (update k (x.val v - y.val v) v) = t.val v\n  | preterm.cst m, h1 => rfl\n  | preterm.var m n, h1 => by\n    have h2 : n ≠ k := ne_of_lt h1\n    simp only [sub_subst, preterm.val]\n    rw [update_eq_of_ne _ h2]\n  | preterm.add t s, h1 => by\n    simp only [sub_subst, val_add]; apply fun_mono_2 <;> apply val_sub_subst (le_trans _ h1)\n    apply le_max_left; apply le_max_right\n  | preterm.sub t s, h1 => by\n    simp only [sub_subst, val_sub]\n    by_cases h2 : t = x ∧ s = y\n    · rw [if_pos h2]\n      simp only [val_var, one_mul]\n      rw [update_eq, h2.left, h2.right]\n    · rw [if_neg h2]\n      simp only [val_sub, sub_subst]\n      apply fun_mono_2 <;> apply val_sub_subst (le_trans _ h1)\n      apply le_max_left\n      apply le_max_right\n#align val_sub_subst val_sub_subst\n\n",
 "unsat_of_unsat_sub_elim":
 "theorem unsat_of_unsat_sub_elim (t s : preterm) (p : preform) : (sub_elim t s p).unsat → p.unsat :=\n  mt sat_sub_elim\n#align unsat_of_unsat_sub_elim unsat_of_unsat_sub_elim\n\n",
 "sub_subst_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.eq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.not -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.or -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.and -/\ntheorem sub_subst_equiv {k : Nat} {x y : preterm} {v : Nat → Nat} :\n    ∀ p : preform, p.fresh_index ≤ k → ((preform.sub_subst x y k p).holds (update k (x.val v - y.val v) v) ↔ p.holds v)\n  | preform.eq t s, h1 => by\n    simp only [preform.holds, preform.sub_subst]\n    apply pred_mono_2 <;> apply preterm.val_sub_subst (le_trans _ h1)\n    apply le_max_left; apply le_max_right\n  | preform.le t s, h1 => by\n    simp only [preform.holds, preform.sub_subst]\n    apply pred_mono_2 <;> apply preterm.val_sub_subst (le_trans _ h1)\n    apply le_max_left; apply le_max_right\n  | preform.not p, h1 => by\n    apply not_congr\n    apply sub_subst_equiv p h1\n  | preform.or p q, h1 => by\n    simp only [preform.holds, preform.sub_subst]\n    apply pred_mono_2 <;> apply propext <;> apply sub_subst_equiv _ (le_trans _ h1)\n    apply le_max_left; apply le_max_right\n  | preform.and p q, h1 => by\n    simp only [preform.holds, preform.sub_subst]\n    apply pred_mono_2 <;> apply propext <;> apply sub_subst_equiv _ (le_trans _ h1)\n    apply le_max_left; apply le_max_right\n#align sub_subst_equiv sub_subst_equiv\n\n",
 "sat_sub_elim":
 "theorem sat_sub_elim {t s : preterm} {p : preform} : p.sat → (sub_elim t s p).sat :=\n  by\n  intro h1; simp only [sub_elim, sub_elim_core]\n  cases' h1 with v h1\n  refine' ⟨update (sub_fresh_index t s p) (t.val v - s.val v) v, _⟩\n  constructor\n  · apply (sub_subst_equiv p _).elim_right h1\n    apply le_max_left\n  · apply holds_is_diff\n    rw [update_eq]\n    apply fun_mono_2 <;> apply preterm.val_constant <;> intro x h2 <;> rw [update_eq_of_ne _ (ne.symm (ne_of_gt _))] <;>\n        apply lt_of_lt_of_le h2 <;>\n      apply le_trans _ (le_max_right _ _)\n    apply le_max_left\n    apply le_max_right\n#align sat_sub_elim sat_sub_elim\n\n",
 "holds_is_diff":
 "theorem holds_is_diff {t s : preterm} {k : Nat} {v : Nat → Nat} : v k = t.val v - s.val v → (is_diff t s k).holds v :=\n  by\n  intro h1\n  simp only [preform.holds, is_diff, if_pos (Eq.refl 1), preterm.val_add, preterm.val_var, preterm.val_const]\n  cases' le_total (t.val v) (s.val v) with h2 h2\n  · right\n    refine' ⟨h2, _⟩\n    rw [h1, one_mul, tsub_eq_zero_iff_le]\n    exact h2\n  · left\n    rw [h1, one_mul, add_comm, tsub_add_cancel_of_le h2]\n#align holds_is_diff holds_is_diff\n\n"}