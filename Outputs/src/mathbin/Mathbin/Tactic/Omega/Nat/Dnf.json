{"unsat_of_unsat_dnf":
 "theorem unsat_of_unsat_dnf (p : preform) : p.neg_free → p.sub_free → clauses.unsat (dnf p) → p.unsat :=\n  by\n  intro hnf hsf h1 h2; apply h1\n  apply exists_clause_sat hnf hsf h2\n#align unsat_of_unsat_dnf unsat_of_unsat_dnf\n\n",
 "holds_nonneg_consts_core":
 "-- get notation for list.func.set\ntheorem holds_nonneg_consts_core {v : nat → int} (h1 : ∀ x, 0 ≤ v x) :\n    ∀ m bs, ∀ t ∈ nonneg_consts_core m bs, 0 ≤ term.val v t\n  | _, [] => fun _ h2 => by cases h2\n  | k, ff :: bs => holds_nonneg_consts_core (k + 1) bs\n  | k, tt :: bs => by\n    simp only [nonneg_consts_core]\n    rw [List.forall_mem_cons]\n    constructor\n    · simp only [term.val, one_mul, zero_add, coeffs.val_set]\n      apply h1\n    · apply holds_nonneg_consts_core (k + 1) bs\n#align holds_nonneg_consts_core holds_nonneg_consts_core\n\n",
 "holds_nonneg_consts":
 "theorem holds_nonneg_consts {v : nat → int} {bs : list bool} : (∀ x, 0 ≤ v x) → ∀ t ∈ nonneg_consts bs, 0 ≤ term.val v t\n  | h1 => by apply holds_nonneg_consts_core h1\n#align holds_nonneg_consts holds_nonneg_consts\n\n",
 "exists_clause_sat":
 "theorem exists_clause_sat {p : preform} : p.neg_free → p.sub_free → p.sat → ∃ c ∈ dnf p, clause.sat c :=\n  by\n  intro h1 h2 h3; cases' h3 with v h3\n  rcases exists_clause_holds h1 h2 h3 with ⟨c, h4, h5⟩\n  refine' ⟨c, h4, _, h5⟩\n#align exists_clause_sat exists_clause_sat\n\n",
 "exists_clause_holds_core":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\n/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\ntheorem exists_clause_holds_core {v : nat → nat} :\n    ∀ {p : preform}, p.neg_free → p.sub_free → p.holds v → ∃ c ∈ dnf_core p, clause.holds (fun x => ↑(v x)) c :=\n  by\n  run_tac\n    preform.induce sorry\n  · apply List.exists_mem_cons_of\n    constructor\n    rw [List.forall_mem_singleton]\n    cases' h0 with ht hs\n    simp only [val_canonize ht, val_canonize hs, term.val_sub, preform.holds, sub_eq_add_neg] at *\n    rw [h2, add_neg_self]\n    apply List.forall_mem_nil\n  · apply List.exists_mem_cons_of\n    constructor\n    apply List.forall_mem_nil\n    rw [List.forall_mem_singleton]\n    simp only [val_canonize h0.left, val_canonize h0.right, term.val_sub, preform.holds, sub_eq_add_neg] at *\n    rw [← sub_eq_add_neg, le_sub_comm, sub_zero, Int.ofNat_le]\n    assumption\n  · cases h1\n  ·\n    cases' h2 with h2 h2 <;> [· cases' ihp h1.left h0.left h2 with c h3,\n              · cases' ihq h1.right h0.right h2 with c h3] <;>\n            cases' h3 with h3 h4 <;>\n          refine' ⟨c, list.mem_append.elim_right _, h4⟩ <;>\n        [left, right] <;>\n      assumption\n  · rcases ihp h1.left h0.left h2.left with ⟨cp, hp1, hp2⟩\n    rcases ihq h1.right h0.right h2.right with ⟨cq, hq1, hq2⟩\n    refine' ⟨clause.append cp cq, ⟨_, clause.holds_append hp2 hq2⟩⟩\n    simp only [dnf_core, List.mem_map']\n    refine' ⟨(cp, cq), ⟨_, rfl⟩⟩\n    rw [List.mem_product]\n    constructor <;> assumption\n#align exists_clause_holds_core exists_clause_holds_core\n\n",
 "exists_clause_holds":
 "theorem exists_clause_holds {v : nat → nat} {p : preform} :\n    p.neg_free → p.sub_free → p.holds v → ∃ c ∈ dnf p, clause.holds (fun x => ↑(v x)) c :=\n  by\n  intro h1 h2 h3\n  rcases exists_clause_holds_core h1 h2 h3 with ⟨c, h4, h5⟩\n  exists nonnegate c\n  have h6 : nonnegate c ∈ dnf p := by\n    simp only [dnf]\n    rw [List.mem_map']\n    refine' ⟨c, h4, rfl⟩\n  refine' ⟨h6, _⟩\n  cases' c with eqs les\n  simp only [nonnegate, clause.holds]\n  constructor\n  apply h5.left\n  rw [List.forall_mem_append]\n  apply and.intro (holds_nonneg_consts _) h5.right\n  intro x\n  apply int.coe_nat_nonneg\n#align exists_clause_holds exists_clause_holds\n\n"}