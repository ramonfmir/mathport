{"push_neg_equiv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.not -/\n/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nNegation elimination.\n-/\ntheorem push_neg_equiv : ∀ {p : preform}, preform.equiv (push_neg p) (preform.not p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · simp only [not_not, preform.holds, push_neg]\n  · simp only [preform.holds, push_neg, not_or, ihp v, ihq v]\n  · simp only [preform.holds, push_neg, not_and_or, ihp v, ihq v]\n#align push_neg_equiv push_neg_equiv\n\n",
 "nnf_equiv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\ntheorem nnf_equiv : ∀ {p : preform}, preform.equiv (nnf p) p :=\n  by\n  run_tac\n    preform.induce sorry\n  · rw [push_neg_equiv]\n    apply not_congr\n    apply ih\n  · apply pred_mono_2' (ihp v) (ihq v)\n  · apply pred_mono_2' (ihp v) (ihq v)\n#align nnf_equiv nnf_equiv\n\n",
 "neg_free_neg_elim_core":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\ntheorem neg_free_neg_elim_core : ∀ p, is_nnf p → (neg_elim_core p).neg_free :=\n  by\n  run_tac\n    preform.induce sorry\n  · cases p <;> try cases h1 <;> try trivial\n    constructor <;> trivial\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n#align neg_free_neg_elim_core neg_free_neg_elim_core\n\n",
 "neg_free_neg_elim":
 "theorem neg_free_neg_elim {p : preform} : (neg_elim p).neg_free :=\n  neg_free_neg_elim_core _ (is_nnf_nnf _)\n#align neg_free_neg_elim neg_free_neg_elim\n\n",
 "le_and_le_iff_eq":
 "theorem le_and_le_iff_eq {α : Type} [partial_order α] {a b : α} : a ≤ b ∧ b ≤ a ↔ a = b :=\n  by\n  constructor <;> intro h1\n  · cases h1\n    apply le_antisymm <;> assumption\n  · constructor <;> apply le_of_eq <;> rw [h1]\n#align le_and_le_iff_eq le_and_le_iff_eq\n\n",
 "is_nnf_push_neg":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\ntheorem is_nnf_push_neg : ∀ p : preform, is_nnf p → is_nnf (push_neg p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · cases p <;> try cases h1 <;> trivial\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n#align is_nnf_push_neg is_nnf_push_neg\n\n",
 "is_nnf_nnf":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\ntheorem is_nnf_nnf : ∀ p : preform, is_nnf (nnf p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · apply is_nnf_push_neg _ ih\n  · constructor <;> assumption\n  · constructor <;> assumption\n#align is_nnf_nnf is_nnf_nnf\n\n",
 "implies_neg_elim_core":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic omega.nat.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:333:4: warning: unsupported (TODO): `[tacs] -/\ntheorem implies_neg_elim_core : ∀ {p : preform}, preform.implies p (neg_elim_core p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · cases' p with t s t s <;> try apply h\n    · apply Or.symm\n      simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_or, not_le] using h\n    simpa only [preform.holds, not_le, int.add_one_le_iff] using h\n  · simp only [neg_elim_core]\n    cases h <;>\n        [·\n          left\n          apply ihp,\n        · right\n          apply ihq] <;>\n      assumption\n  apply and.imp (ihp _) (ihq _) h\n#align implies_neg_elim_core implies_neg_elim_core\n\n",
 "implies_neg_elim":
 "theorem implies_neg_elim {p : preform} : preform.implies p (neg_elim p) :=\n  by\n  intro v h1; apply implies_neg_elim_core\n  apply (nnf_equiv v).elim_right h1\n#align implies_neg_elim implies_neg_elim\n\n"}