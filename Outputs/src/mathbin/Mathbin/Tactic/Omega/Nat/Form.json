{"valid_of_unsat_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.not -/\ntheorem valid_of_unsat_not {p : preform} : (preform.not p).unsat → p.valid :=\n  by\n  simp only [preform.sat, preform.unsat, preform.valid, preform.holds]\n  rw [not_exists_not]; intro h; assumption\n#align valid_of_unsat_not valid_of_unsat_not\n\n",
 "univ_close_of_valid":
 "theorem univ_close_of_valid {p : preform} : ∀ {m : nat} {v : nat → nat}, p.valid → univ_close p v m\n  | 0, v, h1 => h1 _\n  | m + 1, v, h1 => fun i => univ_close_of_valid h1\n#align univ_close_of_valid univ_close_of_valid\n\n",
 "sat_or":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.or -/\ntheorem sat_or {p q : preform} : sat (preform.or p q) ↔ sat p ∨ sat q :=\n  by\n  constructor <;> intro h1\n  · cases' h1 with v h1\n    cases' h1 with h1 h1 <;> [left, right] <;> refine' ⟨v, _⟩ <;> assumption\n  · cases' h1 with h1 h1 <;> cases' h1 with v h1 <;> refine' ⟨v, _⟩ <;> [left, right] <;> assumption\n#align sat_or sat_or\n\n",
 "sat_of_implies_of_sat":
 "theorem sat_of_implies_of_sat {p q : preform} : implies p q → sat p → sat q := by intro h1 h2; apply Exists.imp h1 h2\n#align sat_of_implies_of_sat sat_of_implies_of_sat\n\n",
 "holds_constant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.eq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.le -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.not -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.or -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.and -/\n/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nLinear natural number arithmetic preformulas in pre-normalized preform.\n-/\ntheorem holds_constant {v w : nat → nat} : ∀ p : preform, (∀ x < p.fresh_index, v x = w x) → (p.holds v ↔ p.holds w)\n  | preform.eq t s, h1 => by\n    simp only [holds]\n    apply pred_mono_2 <;> apply preterm.val_constant <;> intro x h2 <;> apply h1 _ (lt_of_lt_of_le h2 _)\n    apply le_max_left; apply le_max_right\n  | preform.le t s, h1 => by\n    simp only [holds]\n    apply pred_mono_2 <;> apply preterm.val_constant <;> intro x h2 <;> apply h1 _ (lt_of_lt_of_le h2 _)\n    apply le_max_left; apply le_max_right\n  | preform.not p, h1 => by\n    apply not_congr\n    apply holds_constant p h1\n  | preform.or p q, h1 => by\n    simp only [holds]\n    apply pred_mono_2' <;> apply holds_constant <;> intro x h2 <;> apply h1 _ (lt_of_lt_of_le h2 _)\n    apply le_max_left; apply le_max_right\n  | preform.and p q, h1 => by\n    simp only [holds]\n    apply pred_mono_2' <;> apply holds_constant <;> intro x h2 <;> apply h1 _ (lt_of_lt_of_le h2 _)\n    apply le_max_left; apply le_max_right\n#align holds_constant holds_constant\n\n"}