{"val_var":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.var -/\n@[simp]\ntheorem val_var {v : nat → nat} {m n : nat} : (preterm.var m n).val v = m * v n :=\n  by\n  simp only [val]; by_cases h1 : m = 1\n  rw [if_pos h1, h1, one_mul]\n  rw [if_neg h1, mul_comm]\n#align val_var val_var\n\n",
 "val_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.sub -/\n@[simp]\ntheorem val_sub {v : nat → nat} {t s : preterm} : (preterm.sub t s).val v = t.val v - s.val v :=\n  rfl\n#align val_sub val_sub\n\n",
 "val_constant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.cst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.var -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.add -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.sub -/\n/-- If variable assignments `v` and `w` agree on all variables that occur\nin term `t`, the value of `t` under `v` and `w` are identical. -/\ntheorem val_constant (v w : nat → nat) : ∀ t : preterm, (∀ x < t.fresh_index, v x = w x) → t.val v = t.val w\n  | preterm.cst n, h1 => rfl\n  | preterm.var m n, h1 => by\n    simp only [val_var]\n    apply congr_arg fun y => m * y\n    apply h1 _ (lt_add_one _)\n  | preterm.add t s, h1 => by\n    simp only [val_add]\n    have ht := val_constant t fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_left _ _))\n    have hs := val_constant s fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_right _ _))\n    rw [ht, hs]\n  | preterm.sub t s, h1 => by\n    simp only [val_sub]\n    have ht := val_constant t fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_left _ _))\n    have hs := val_constant s fun x hx => h1 _ (lt_of_lt_of_le hx (le_max_right _ _))\n    rw [ht, hs]\n#align val_constant val_constant\n\n",
 "val_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.cst -/\n/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nLinear natural number arithmetic terms in pre-normalized form.\n-/\n@[simp]\ntheorem val_const {v : nat → nat} {m : nat} : (preterm.cst m).val v = m :=\n  rfl\n#align val_const val_const\n\n",
 "val_canonize":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.cst -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.var -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.add -/\n-- get notation for list.func.set\n@[simp]\ntheorem val_canonize {v : nat → nat} : ∀ {t : preterm}, t.sub_free → ((canonize t).val fun x => ↑(v x)) = t.val v\n  | preterm.cst i, h1 => by simp only [canonize, preterm.val_const, term.val, coeffs.val_nil, add_zero]\n  | preterm.var i n, h1 => by simp only [preterm.val_var, coeffs.val_set, term.val, zero_add, Int.ofNat_mul, canonize]\n  | preterm.add t s, h1 => by\n    simp only [val_canonize h1.left, val_canonize h1.right, Int.ofNat_add, canonize, term.val_add, preterm.val_add]\n#align val_canonize val_canonize\n\n",
 "val_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preterm.add -/\n@[simp]\ntheorem val_add {v : nat → nat} {t s : preterm} : (preterm.add t s).val v = t.val v + s.val v :=\n  rfl\n#align val_add val_add\n\n"}