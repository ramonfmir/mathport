{"unsat_of_unsat_eq_elim":
 "/-- If the result of equality elimination is unsatisfiable, the original clause is unsatisfiable. -/\ntheorem unsat_of_unsat_eq_elim (ee : list ee) (c : clause) : (eq_elim ee c).unsat → c.unsat :=\n  by\n  intro h1 h2\n  apply h1\n  apply sat_eq_elim h2\n#align unsat_of_unsat_eq_elim unsat_of_unsat_eq_elim\n\n",
 "symmod_eq":
 "theorem symmod_eq {i j : int} : symmod i j = i - j * symdiv i j := by rw [mul_symdiv_eq, sub_sub_cancel]\n#align symmod_eq symmod_eq\n\n",
 "symmod_add_one_self":
 "/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\n/-\nCorrectness lemmas for equality elimination.\nSee 5.5 of <http://www.decision-procedures.org/> for details.\n-/\ntheorem symmod_add_one_self {i : int} : 0 < i → symmod i (i + 1) = -1 :=\n  by\n  intro h1\n  unfold symmod\n  rw [Int.emod_eq_of_lt (le_of_lt h1) (lt_add_one _), if_neg]\n  simp only [add_comm, add_neg_cancel_left, neg_add_rev, sub_eq_add_neg]\n  have h2 : 2 * i = (1 + 1) * i := rfl\n  simpa only [h2, add_mul, one_mul, add_lt_add_iff_left, not_lt] using h1\n#align symmod_add_one_self symmod_add_one_self\n\n",
 "subst_correct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `list.func.set -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n-- Requires : t1.coeffs[m] = 1\ntheorem subst_correct {v : nat → int} {b : int} {as : list int} {t : term} {n : nat} :\n    0 < get n as →\n      0 = term.val v (b, as) → term.val v t = term.val (omega.update v n (sgm v b as n)) (subst n (rhs n b as) t) :=\n  by\n  intro h1 h2\n  simp only [subst, term.val, term.val_add, term.val_mul]\n  rw [← rhs_correct _ h1 h2]\n  cases' t with b' as'\n  simp only [term.val]\n  have h3 : coeffs.val (omega.update v n (sgm v b as n)) (list.func.set as' n 0) = coeffs.val_except n v as' := by\n    rw [← coeffs.val_except_add_eq n, get_set, zero_mul, add_zero, coeffs.val_except_update_set]\n  rw [h3, ← coeffs.val_except_add_eq n]\n  ring\n#align subst_correct subst_correct\n\n",
 "sat_eq_elim":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic tactic.rotate -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\ntheorem sat_eq_elim : ∀ {es : list ee} {c : clause}, c.sat → (eq_elim es c).sat\n  | [], ([], les), h => h\n  | e :: _, ([], les), h => by cases e <;> simp only [eq_elim] <;> apply sat_empty\n  | [], (_ :: _, les), h => sat_empty\n  | ee.drop :: es, (eq :: eqs, les), h1 => by\n    apply @sat_eq_elim es _ _\n    rcases h1 with ⟨v, h1, h2⟩\n    refine' ⟨v, List.forall_mem_of_forall_mem_cons h1, h2⟩\n  | ee.neg :: es, (eq :: eqs, les), h1 => by\n    simp only [eq_elim]; apply sat_eq_elim\n    cases' h1 with v h1\n    exists v\n    cases' h1 with hl hr\n    apply and.intro _ hr\n    rw [List.forall_mem_cons] at *\n    apply and.intro _ hl.right\n    rw [term.val_neg]\n    rw [← hl.left]\n    rfl\n  | ee.nondiv i :: es, ((b, as) :: eqs, les), h1 => by\n    unfold eq_elim\n    by_cases h2 : ¬i ∣ b ∧ ∀ x : ℤ, x ∈ as → i ∣ x\n    · exfalso\n      cases' h1 with v h1\n      have h3 : 0 = b + coeffs.val v as := h1.left _ (or.inl rfl)\n      have h4 : i ∣ coeffs.val v as := coeffs.dvd_val h2.right\n      have h5 : i ∣ b + coeffs.val v as := by\n        rw [← h3]\n        apply dvd_zero\n      rw [← dvd_add_iff_left h4] at h5\n      apply h2.left h5\n    rw [if_neg h2]; apply sat_empty\n  | ee.factor i :: es, ((b, as) :: eqs, les), h1 =>\n    by\n    simp only [eq_elim]\n    by_cases h2 : i ∣ b ∧ ∀ x ∈ as, i ∣ x\n    · rw [if_pos h2]\n      apply sat_eq_elim\n      cases' h1 with v h1\n      exists v\n      cases' h1 with h3 h4\n      apply and.intro _ h4\n      rw [List.forall_mem_cons] at *\n      cases' h3 with h5 h6\n      apply and.intro _ h6\n      rw [term.val_div h2.left h2.right, ← h5, int.zero_div]\n    · rw [if_neg h2]\n      apply sat_empty\n  | ee.reduce n :: es, ((b, as) :: eqs, les), h1 =>\n    by\n    simp only [eq_elim]\n    by_cases h2 : 0 < get n as\n    run_tac\n      tactic.rotate 1\n    · rw [if_neg h2]\n      apply sat_empty\n    rw [if_pos h2]\n    apply sat_eq_elim\n    cases' h1 with v h1\n    exists omega.update v n (sgm v b as n)\n    cases' h1 with h1 h3\n    rw [List.forall_mem_cons] at h1\n    cases' h1 with h4 h5\n    constructor\n    · rw [List.forall_mem_cons]\n      constructor\n      · apply coeffs_reduce_correct h2 h4\n      · intro x h6\n        rw [List.mem_map'] at h6\n        cases' h6 with t h6\n        cases' h6 with h6 h7\n        rw [← h7, ← subst_correct h2 h4]\n        apply h5 _ h6\n    · intro x h6\n      rw [List.mem_map'] at h6\n      cases' h6 with t h6\n      cases' h6 with h6 h7\n      rw [← h7, ← subst_correct h2 h4]\n      apply h3 _ h6\n  | ee.cancel m :: es, (eq :: eqs, les), h1 => by\n    unfold eq_elim\n    apply sat_eq_elim\n    cases' h1 with v h1\n    exists v\n    cases' h1 with h1 h2\n    rw [List.forall_mem_cons] at h1; cases' h1 with h1 h3\n    constructor <;> intro t h4 <;> rw [List.mem_map'] at h4 <;> rcases h4 with ⟨s, h4, h5⟩ <;> rw [← h5] <;>\n        simp only [term.val_add, term.val_mul, cancel] <;>\n      rw [← h1, mul_zero, zero_add]\n    · apply h3 _ h4\n    · apply h2 _ h4\n#align sat_eq_elim sat_eq_elim\n\n",
 "sat_empty":
 "theorem sat_empty : clause.sat ([], []) :=\n  ⟨fun _ => 0, ⟨by decide, by decide⟩⟩\n#align sat_empty sat_empty\n\n",
 "rhs_correct_aux":
 "theorem rhs_correct_aux {v : nat → int} {m : int} {as : list int} :\n    ∀ {k}, ∃ d, m * d + coeffs.val_between v (as.map fun x : ℤ => symmod x m) 0 k = coeffs.val_between v as 0 k\n  | 0 => by\n    exists (0 : int)\n    simp only [add_zero, mul_zero, coeffs.val_between]\n  | k + 1 => by\n    simp only [zero_add, coeffs.val_between, list.map]\n    cases' @rhs_correct_aux k with d h1; rw [← h1]\n    by_cases hk : k < as.length\n    · rw [get_map hk, symmod_eq, sub_mul]\n      exists d + symdiv (get k as) m * v k\n      ring\n    · rw [not_lt] at hk\n      repeat' rw [get_eq_default_of_le]\n      exists d\n      rw [add_assoc]\n      exact hk\n      simp only [hk, list.length_map]\n#align rhs_correct_aux rhs_correct_aux\n\n",
 "rhs_correct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\ntheorem rhs_correct {v : nat → int} {b : int} {as : list int} (n : nat) :\n    0 < get n as → 0 = term.val v (b, as) → v n = term.val (omega.update v n (sgm v b as n)) (rhs n b as) :=\n  by\n  intro h0 h1\n  let a_n := get n as\n  let m := a_n + 1\n  have h3 : m ≠ 0 := by\n    apply ne_of_gt\n    apply lt_trans h0\n    simp [a_n, m]\n  have h2 : m * sgm v b as n = symmod b m + coeffs.val v (as.map fun x => symmod x m) :=\n    by\n    simp only [sgm, mul_comm m]\n    rw [Int.ediv_mul_cancel]\n    have h4 :\n      ∃ c, m * c + (symmod b (get n as + 1) + coeffs.val v (as.map fun x : ℤ => symmod x m)) = term.val v (b, as) :=\n      by\n      have h5 : ∃ d, m * d + coeffs.val v (as.map fun x => symmod x m) = coeffs.val v as :=\n        by\n        simp only [coeffs.val, list.length_map]\n        apply rhs_correct_aux\n      cases' h5 with d h5\n      rw [symmod_eq]\n      exists symdiv b m + d\n      unfold term.val\n      rw [← h5]\n      simp only [term.val, mul_add, add_mul, m, a_n]\n      ring\n    cases' h4 with c h4\n    rw [dvd_add_iff_right (dvd_mul_right m c), h4, ← h1]\n    apply dvd_zero\n  apply\n    calc\n      v n = -(m * sgm v b as n) + symmod b m + coeffs.val_except n v (as.map fun x => symmod x m) :=\n        by\n        rw [h2, ← coeffs.val_except_add_eq n]\n        have hn : n < as.length := by\n          by_contra hc\n          rw [not_lt] at hc\n          rw [get_eq_default_of_le n hc] at h0\n          cases h0\n        rw [get_map hn]\n        simp only [a_n, m]\n        rw [add_comm, symmod_add_one_self h0]\n        ring\n      _ = term.val (omega.update v n (sgm v b as n)) (rhs n b as) :=\n        by\n        unfold rhs; unfold term.val\n        rw [← coeffs.val_except_add_eq n, get_set, update_eq]\n        have h2 : ∀ a b c : int, a + b + c = b + (c + a) := by\n          intros\n          ring\n        rw [h2 (-_)]\n        apply fun_mono_2 rfl\n        apply fun_mono_2\n        · rw [coeffs.val_except_update_set]\n        · simp only [m, a_n]\n          ring\n      \n#align rhs_correct rhs_correct\n\n",
 "mul_symdiv_eq":
 "theorem mul_symdiv_eq {i j : int} : j * symdiv i j = i - symmod i j :=\n  by\n  unfold symdiv; unfold symmod\n  by_cases h1 : 2 * (i % j) < j\n  · repeat' rw [if_pos h1]\n    rw [Int.mod_def, sub_sub_cancel]\n  · repeat' rw [if_neg h1]\n    rw [Int.mod_def, sub_sub, sub_sub_cancel, mul_add, mul_one]\n#align mul_symdiv_eq mul_symdiv_eq\n\n",
 "coeffs_reduce_correct":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `omega.update -/\ntheorem coeffs_reduce_correct {v : nat → int} {b : int} {as : list int} {n : nat} :\n    0 < get n as → 0 = term.val v (b, as) → 0 = term.val (omega.update v n (sgm v b as n)) (coeffs_reduce n b as) :=\n  by\n  intro h1 h2\n  let a_n := get n as\n  let m := a_n + 1\n  have h3 : m ≠ 0 := by\n    apply ne_of_gt\n    apply lt_trans h1\n    simp only [m, lt_add_iff_pos_right]\n  have h4 : 0 = term.val (omega.update v n (sgm v b as n)) (coeffs_reduce n b as) * m :=\n    calc\n      0 = term.val v (b, as) := h2\n      _ = b + coeffs.val_except n v as + a_n * (rhs n b as).val (omega.update v n (sgm v b as n)) :=\n        by\n        unfold term.val\n        rw [← coeffs.val_except_add_eq n, rhs_correct n h1 h2]\n        simp only [a_n, add_assoc]\n      _ =\n          -(m * a_n * sgm v b as n) + (b + a_n * symmod b m) +\n            (coeffs.val_except n v as + a_n * coeffs.val_except n v (as.map fun x => symmod x m)) :=\n        by\n        simp only [term.val, rhs, mul_add, m, a_n, add_assoc, add_right_inj, add_comm, add_left_comm]\n        rw [← coeffs.val_except_add_eq n, get_set, update_eq, mul_add]\n        apply fun_mono_2\n        · rw [coeffs.val_except_eq_val_except update_eq_of_ne (get_set_eq_of_ne _)]\n        ring\n      _ =\n          -(m * a_n * sgm v b as n) + (b + a_n * symmod b m) +\n            coeffs.val_except n v (as.map fun a_i => a_i + a_n * symmod a_i m) :=\n        by\n        apply fun_mono_2 rfl\n        simp only [coeffs.val_except, mul_add]\n        repeat' rw [← coeffs.val_between_map_mul]\n        rw [add_add_add_comm]\n        have h5 :\n          add as (list.map (has_mul.mul a_n) (list.map (fun x : ℤ => symmod x (get n as + 1)) as)) =\n            list.map (fun a_i : ℤ => a_i + a_n * symmod a_i m) as :=\n          by\n          rw [list.map_map, ← map_add_map]\n          apply fun_mono_2\n          · have h5 : (fun x : int => x) = id := by\n              rw [function.funext_iff]\n              intro x\n              rfl\n            rw [h5, list.map_id]\n          · apply fun_mono_2 _ rfl\n            rw [function.funext_iff]\n            intro x\n            simp only [m]\n        simp only [list.length_map]\n        repeat' rw [← coeffs.val_between_add, h5]\n      _ = -(m * a_n * sgm v b as n) + m * sym_sym m b + coeffs.val_except n v (as.map fun a_i => m * sym_sym m a_i) :=\n        by\n        repeat' rw [add_assoc]\n        apply fun_mono_2\n        rfl\n        rw [← add_assoc]\n        have h4 : ∀ x : ℤ, x + a_n * symmod x m = m * sym_sym m x :=\n          by\n          intro x\n          have h5 : a_n = m - 1 := by\n            simp only [m]\n            rw [add_sub_cancel]\n          rw [h5, sub_mul, one_mul, add_sub, add_comm, add_sub_assoc, ← mul_symdiv_eq]\n          simp only [sym_sym, mul_add, add_comm]\n        apply fun_mono_2 (h4 _)\n        apply coeffs.val_except_eq_val_except <;> intro x h5\n        rfl\n        apply congr_arg\n        apply fun_mono_2 _ rfl\n        rw [function.funext_iff]\n        apply h4\n      _ = (-(a_n * sgm v b as n) + sym_sym m b + coeffs.val_except n v (as.map (sym_sym m))) * m :=\n        by\n        simp only [add_mul _ _ m]\n        apply fun_mono_2; ring\n        simp only [coeffs.val_except, add_mul _ _ m]\n        apply fun_mono_2\n        · rw [mul_comm _ m, ← coeffs.val_between_map_mul, list.map_map]\n        simp only [list.length_map, mul_comm _ m]\n        rw [← coeffs.val_between_map_mul, list.map_map]\n      _ = (sym_sym m b + (coeffs.val_except n v (as.map (sym_sym m)) + -a_n * sgm v b as n)) * m := by ring\n      _ = term.val (omega.update v n (sgm v b as n)) (coeffs_reduce n b as) * m :=\n        by\n        simp only [coeffs_reduce, term.val, m, a_n]\n        rw [← coeffs.val_except_add_eq n, coeffs.val_except_update_set, get_set, update_eq]\n      \n  rw [← Int.mul_ediv_cancel (term.val _ _) h3, ← h4, int.zero_div]\n#align coeffs_reduce_correct coeffs_reduce_correct\n\n"}