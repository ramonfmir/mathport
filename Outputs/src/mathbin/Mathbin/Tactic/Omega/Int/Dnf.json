{"unsat_of_clauses_unsat":
 "theorem unsat_of_clauses_unsat {p : preform} : clauses.unsat (dnf p) → p.unsat :=\n  by\n  intro h1 h2; apply h1\n  apply clauses_sat_dnf_core\n  apply neg_free_neg_elim _ (is_nnf_nnf _)\n  apply preform.sat_of_implies_of_sat implies_neg_elim\n  have hrw := exists_congr (@nnf_equiv p)\n  apply hrw.elim_right h2\n#align unsat_of_clauses_unsat unsat_of_clauses_unsat\n\n",
 "push_neg_equiv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `preform.not -/\n/-\nCopyright (c) 2019 Seul Baek. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Seul Baek\n-/\ntheorem push_neg_equiv : ∀ {p : preform}, preform.equiv (push_neg p) (preform.not p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · simp only [Classical.not_not, push_neg, preform.holds]\n  · simp only [preform.holds, push_neg, not_or, ihp v, ihq v]\n  · simp only [preform.holds, push_neg, not_and_or, ihp v, ihq v]\n#align push_neg_equiv push_neg_equiv\n\n",
 "nnf_equiv":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\ntheorem nnf_equiv : ∀ {p : preform}, preform.equiv (nnf p) p :=\n  by\n  run_tac\n    preform.induce sorry\n  · rw [push_neg_equiv]\n    apply not_congr\n    apply ih\n  · apply pred_mono_2' (ihp v) (ihq v)\n  · apply pred_mono_2' (ihp v) (ihq v)\n#align nnf_equiv nnf_equiv\n\n",
 "neg_free_neg_elim":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\ntheorem neg_free_neg_elim : ∀ p : preform, is_nnf p → neg_free (neg_elim p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · cases p <;> try cases h1 <;> try trivial\n    constructor <;> trivial\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n#align neg_free_neg_elim neg_free_neg_elim\n\n",
 "le_and_le_iff_eq":
 "theorem le_and_le_iff_eq {α : Type} [partial_order α] {a b : α} : a ≤ b ∧ b ≤ a ↔ a = b :=\n  by\n  constructor <;> intro h1\n  · cases h1\n    apply le_antisymm <;> assumption\n  · constructor <;> apply le_of_eq <;> rw [h1]\n#align le_and_le_iff_eq le_and_le_iff_eq\n\n",
 "is_nnf_push_neg":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\ntheorem is_nnf_push_neg : ∀ p : preform, is_nnf p → is_nnf (push_neg p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · cases p <;> try cases h1 <;> trivial\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n  · cases h1\n    constructor <;> [· apply ihp, · apply ihq] <;> assumption\n#align is_nnf_push_neg is_nnf_push_neg\n\n",
 "is_nnf_nnf":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\ntheorem is_nnf_nnf : ∀ p : preform, is_nnf (nnf p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · apply is_nnf_push_neg _ ih\n  · constructor <;> assumption\n  · constructor <;> assumption\n#align is_nnf_nnf is_nnf_nnf\n\n",
 "implies_neg_elim":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\ntheorem implies_neg_elim : ∀ {p : preform}, preform.implies p (neg_elim p) :=\n  by\n  run_tac\n    preform.induce sorry\n  · cases' p with t s t s <;> try apply h\n    · simp only [le_and_le_iff_eq.symm, not_and_or, not_le, preterm.val, preform.holds] at h\n      simp only [Int.add_one_le_iff, preterm.add_one, preterm.val, preform.holds, neg_elim]\n      rw [or_comm']\n      assumption\n    · simp only [not_le, Int.add_one_le_iff, preterm.add_one, not_le, preterm.val, preform.holds, neg_elim] at *\n      assumption\n  · simp only [neg_elim]\n    cases h <;>\n        [·\n          left\n          apply ihp,\n        · right\n          apply ihq] <;>\n      assumption\n  · apply and.imp (ihp _) (ihq _) h\n#align implies_neg_elim implies_neg_elim\n\n",
 "exists_clause_holds":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:69:18: unsupported non-interactive tactic omega.int.preform.induce -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:330:4: warning: unsupported (TODO): `[tacs] -/\ntheorem exists_clause_holds {v : Nat → int} :\n    ∀ {p : preform}, neg_free p → p.holds v → ∃ c ∈ dnf_core p, clause.holds v c :=\n  by\n  run_tac\n    preform.induce sorry\n  · apply List.exists_mem_cons_of\n    constructor\n    · simp only [preterm.val, preform.holds] at h2\n      rw [List.forall_mem_singleton]\n      simp only [h2, omega.int.val_canonize, omega.term.val_sub, sub_self]\n    · apply List.forall_mem_nil\n  · apply List.exists_mem_cons_of\n    constructor\n    · apply List.forall_mem_nil\n    · simp only [preterm.val, preform.holds] at h2\n      rw [List.forall_mem_singleton]\n      simp only [val_canonize, preterm.val, term.val_sub]\n      rw [le_sub_comm, sub_zero]\n      assumption\n  · cases h1\n  ·\n    cases' h2 with h2 h2 <;> [· cases' ihp h1.left h2 with c h3, · cases' ihq h1.right h2 with c h3] <;>\n            cases' h3 with h3 h4 <;>\n          refine' ⟨c, list.mem_append.elim_right _, h4⟩ <;>\n        [left, right] <;>\n      assumption\n  · rcases ihp h1.left h2.left with ⟨cp, hp1, hp2⟩\n    rcases ihq h1.right h2.right with ⟨cq, hq1, hq2⟩\n    refine' ⟨clause.append cp cq, ⟨_, clause.holds_append hp2 hq2⟩⟩\n    simp only [dnf_core, List.mem_map]\n    refine' ⟨(cp, cq), ⟨_, rfl⟩⟩\n    rw [List.mem_product]\n    constructor <;> assumption\n#align exists_clause_holds exists_clause_holds\n\n",
 "clauses_sat_dnf_core":
 "theorem clauses_sat_dnf_core {p : preform} : neg_free p → p.sat → clauses.sat (dnf_core p) :=\n  by\n  intro h1 h2; cases' h2 with v h2\n  rcases exists_clause_holds h1 h2 with ⟨c, h3, h4⟩\n  refine' ⟨c, h3, v, h4⟩\n#align clauses_sat_dnf_core clauses_sat_dnf_core\n\n"}