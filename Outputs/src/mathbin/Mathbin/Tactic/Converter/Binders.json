{"forall_elim_eq_right":
 "theorem forall_elim_eq_right.{u, v} {α : Sort u} (a : α) (p : ∀ a' : α, a = a' → Prop) :\n    (∀ (a' : α) (h : a = a'), p a' h) ↔ p a rfl :=\n  ⟨fun h => h a rfl, fun h a' h_eq =>\n    match a', h_eq with\n    | _, rfl => h⟩\n#align forall_elim_eq_right forall_elim_eq_right\n\n",
 "forall_elim_eq_left":
 "theorem forall_elim_eq_left.{u, v} {α : Sort u} (a : α) (p : ∀ a' : α, a' = a → Prop) :\n    (∀ (a' : α) (h : a' = a), p a' h) ↔ p a rfl :=\n  ⟨fun h => h a rfl, fun h a' h_eq =>\n    match a', h_eq with\n    | _, rfl => h⟩\n#align forall_elim_eq_left forall_elim_eq_left\n\n",
 "forall_comm":
 "theorem forall_comm.{u, v} {α : Sort u} {β : Sort v} (p : α → β → Prop) : (∀ a b, p a b) ↔ ∀ b a, p a b :=\n  ⟨fun h b a => h a b, fun h b a => h a b⟩\n#align forall_comm forall_comm\n\n",
 "exists_elim_eq_right":
 "theorem exists_elim_eq_right.{u, v} {α : Sort u} (a : α) (p : ∀ a' : α, a = a' → Prop) :\n    (∃ (a' : α)(h : a = a'), p a' h) ↔ p a rfl :=\n  ⟨fun ⟨a', ⟨h, p_h⟩⟩ =>\n    match a', h, p_h with\n    | _, rfl, h => h,\n    fun h => ⟨a, rfl, h⟩⟩\n#align exists_elim_eq_right exists_elim_eq_right\n\n",
 "exists_elim_eq_left":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n\nBinder elimination\n-/\n-- congr should forward data! \n-- is maybe overly restricted for `heq`\n/- Binder elimination:\n\nWe assume a binder `B : p → Π (α : Sort u), (α → t) → t`, where `t` is a type depending on `p`.\nExamples:\n  ∃: there is no `p` and `t` is `Prop`.\n  ⨅, ⨆: here p is `β` and `[complete_lattice β]`, `p` is `β`\n\nProblem: ∀x, _ should be a binder, but is not a constant!\n\nProvide a mechanism to rewrite:\n\n  B (x : α) ..x.. (h : x = t), p x  =  B ..x/t.., p t\n\nHere ..x.. are binders, maybe also some constants which provide commutativity rules with `B`.\n\n-/\n-- returns the bound type and body\n-- optionally adapt `eq` to `iff`\n-- apply commutativity rule\n-- apply congruence rule\n-- (B (x : β) (h : x = t), s x) = s t\ntheorem exists_elim_eq_left.{u, v} {α : Sort u} (a : α) (p : ∀ a' : α, a' = a → Prop) :\n    (∃ (a' : α)(h : a' = a), p a' h) ↔ p a rfl :=\n  ⟨fun ⟨a', ⟨h, p_h⟩⟩ =>\n    match a', h, p_h with\n    | _, rfl, h => h,\n    fun h => ⟨a, rfl, h⟩⟩\n#align exists_elim_eq_left exists_elim_eq_left\n\n"}