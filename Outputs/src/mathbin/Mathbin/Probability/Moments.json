{"moment_zero":
 "/-\nCopyright (c) 2022 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne\n-/\n@[simp]\ntheorem moment_zero (hp : p ≠ 0) : moment 0 p μ = 0 := by\n  simp only [moment, hp, zero_pow', ne.def, not_false_iff, Pi.zero_apply, integral_const, Algebra.id.smul_eq_mul,\n    MulZeroClass.mul_zero]\n#align moment_zero moment_zero\n\n",
 "mgf_zero_measure":
 "@[simp]\ntheorem mgf_zero_measure : mgf X (0 : measure Ω) t = 0 := by simp only [mgf, integral_zero_measure]\n#align mgf_zero_measure mgf_zero_measure\n\n",
 "mgf_zero_fun":
 "@[simp]\ntheorem mgf_zero_fun : mgf 0 μ t = (μ Set.univ).to_real := by\n  simp only [mgf, Pi.zero_apply, MulZeroClass.mul_zero, exp_zero, integral_const, Algebra.id.smul_eq_mul, mul_one]\n#align mgf_zero_fun mgf_zero_fun\n\n",
 "mgf_zero'":
 "@[simp]\ntheorem mgf_zero' : mgf X μ 0 = (μ Set.univ).to_real := by\n  simp only [mgf, MulZeroClass.zero_mul, exp_zero, integral_const, Algebra.id.smul_eq_mul, mul_one]\n#align mgf_zero' mgf_zero'\n\n",
 "mgf_zero":
 "@[simp]\ntheorem mgf_zero [ProbabilityMeasure μ] : mgf X μ 0 = 1 := by simp only [mgf_zero', measure_univ, ENNReal.one_toReal]\n#align mgf_zero mgf_zero\n\n",
 "mgf_undef":
 "theorem mgf_undef (hX : ¬integrable (fun ω => exp (t * X ω)) μ) : mgf X μ t = 0 := by simp only [mgf, integral_undef hX]\n#align mgf_undef mgf_undef\n\n",
 "mgf_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem Indep_fun.mgf_sum [ProbabilityMeasure μ] {X : ι → Ω → exprℝ} (h_indep : Indep_fun (fun i => inferInstance) X μ)\n    (h_meas : ∀ i, Measurable (X i)) (s : Finset ι) :\n    mgf (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (X i)) μ t =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (mgf (X i) μ t) :=\n  by\n  classical\n    induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int\n    · simp only [sum_empty, mgf_zero_fun, measure_univ, ENNReal.one_toReal, prod_empty]\n    · have h_int' : ∀ i : ι, ae_strongly_measurable (fun ω : Ω => exp (t * X i ω)) μ := fun i =>\n        ((h_meas i).const_mul t).exp.ae_strongly_measurable\n      rw [sum_insert hi_notin_s,\n        indep_fun.mgf_add (h_indep.indep_fun_finset_sum_of_not_mem h_meas hi_notin_s).symm (h_int' i)\n          (ae_strongly_measurable_exp_mul_sum fun i hi => h_int' i),\n        h_rec, prod_insert hi_notin_s]\n#align Indep_fun.mgf_sum Indep_fun.mgf_sum\n\n",
 "mgf_pos'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\ntheorem mgf_pos' (hμ : μ ≠ 0) (h_int_X : integrable (fun ω => exp (t * X ω)) μ) : 0 < mgf X μ t :=\n  by\n  simp_rw [mgf]\n  have :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (exp (t * X x))\n        μ =\n      «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" Set.univ\n        (exp (t * X x)) μ :=\n    by simp only [measure.restrict_univ]\n  rw [this, set_integral_pos_iff_support_of_nonneg_ae _ _]\n  · have h_eq_univ : (Function.support fun x : Ω => exp (t * X x)) = Set.univ :=\n      by\n      ext1 x\n      simp only [Function.mem_support, Set.mem_univ, iff_true_iff]\n      exact (exp_pos _).ne'\n    rw [h_eq_univ, Set.inter_univ _]\n    refine' Ne.bot_lt _\n    simp only [hμ, ENNReal.bot_eq_zero, ne.def, measure.measure_univ_eq_zero, not_false_iff]\n  · refine' eventually_of_forall fun x => _\n    rw [Pi.zero_apply]\n    exact (exp_pos _).le\n  · rwa [integrable_on_univ]\n#align mgf_pos' mgf_pos'\n\n",
 "mgf_pos":
 "theorem mgf_pos [ProbabilityMeasure μ] (h_int_X : integrable (fun ω => exp (t * X ω)) μ) : 0 < mgf X μ t :=\n  mgf_pos' (ProbabilityMeasure.ne_zero μ) h_int_X\n#align mgf_pos mgf_pos\n\n",
 "mgf_nonneg":
 "theorem mgf_nonneg : 0 ≤ mgf X μ t := by\n  refine' integral_nonneg _\n  intro ω\n  simp only [Pi.zero_apply]\n  exact (exp_pos _).le\n#align mgf_nonneg mgf_nonneg\n\n",
 "mgf_neg":
 "theorem mgf_neg : mgf (-X) μ t = mgf X μ (-t) := by simp_rw [mgf, Pi.neg_apply, mul_neg, neg_mul]\n#align mgf_neg mgf_neg\n\n",
 "mgf_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem mgf_const' (c : exprℝ) : mgf (fun _ => c) μ t = (μ Set.univ).to_real * exp (t * c) := by\n  simp only [mgf, integral_const, Algebra.id.smul_eq_mul]\n#align mgf_const' mgf_const'\n\n",
 "mgf_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem mgf_const (c : exprℝ) [ProbabilityMeasure μ] : mgf (fun _ => c) μ t = exp (t * c) := by\n  simp only [mgf_const', measure_univ, ENNReal.one_toReal, one_mul]\n#align mgf_const mgf_const\n\n",
 "mgf_add'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem indep_fun.mgf_add' {X Y : Ω → exprℝ} (h_indep : indep_fun X Y μ) (hX : ae_strongly_measurable X μ)\n    (hY : ae_strongly_measurable Y μ) : mgf (X + Y) μ t = mgf X μ t * mgf Y μ t :=\n  by\n  have A : Continuous fun x : exprℝ => exp (t * x) := by continuity\n  have h'X : ae_strongly_measurable (fun ω => exp (t * X ω)) μ :=\n    A.ae_strongly_measurable.comp_ae_measurable hX.ae_measurable\n  have h'Y : ae_strongly_measurable (fun ω => exp (t * Y ω)) μ :=\n    A.ae_strongly_measurable.comp_ae_measurable hY.ae_measurable\n  exact h_indep.mgf_add h'X h'Y\n#align indep_fun.mgf_add' indep_fun.mgf_add'\n\n",
 "mgf_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem indep_fun.mgf_add {X Y : Ω → exprℝ} (h_indep : indep_fun X Y μ)\n    (hX : ae_strongly_measurable (fun ω => exp (t * X ω)) μ) (hY : ae_strongly_measurable (fun ω => exp (t * Y ω)) μ) :\n    mgf (X + Y) μ t = mgf X μ t * mgf Y μ t :=\n  by\n  simp_rw [mgf, Pi.add_apply, mul_add, exp_add]\n  exact (h_indep.exp_mul t t).integral_mul hX hY\n#align indep_fun.mgf_add indep_fun.mgf_add\n\n",
 "measure_le_le_exp_mul_mgf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Chernoff bound** on the lower tail of a real random variable. -/\ntheorem measure_le_le_exp_mul_mgf [FiniteMeasure μ] (ε : exprℝ) (ht : t ≤ 0)\n    (h_int : integrable (fun ω => exp (t * X ω)) μ) : (μ { ω | X ω ≤ ε }).to_real ≤ exp (-t * ε) * mgf X μ t :=\n  by\n  rw [← neg_neg t, ← mgf_neg, neg_neg, ← neg_mul_neg (-t)]\n  refine' Eq.trans_le _ (measure_ge_le_exp_mul_mgf (-ε) (neg_nonneg.mpr ht) _)\n  · congr with ω\n    simp only [Pi.neg_apply, neg_le_neg_iff]\n  · simp_rw [Pi.neg_apply, neg_mul_neg]\n    exact h_int\n#align measure_le_le_exp_mul_mgf measure_le_le_exp_mul_mgf\n\n",
 "measure_le_le_exp_cgf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Chernoff bound** on the lower tail of a real random variable. -/\ntheorem measure_le_le_exp_cgf [FiniteMeasure μ] (ε : exprℝ) (ht : t ≤ 0)\n    (h_int : integrable (fun ω => exp (t * X ω)) μ) : (μ { ω | X ω ≤ ε }).to_real ≤ exp (-t * ε + cgf X μ t) :=\n  by\n  refine' (measure_le_le_exp_mul_mgf ε ht h_int).trans _\n  rw [exp_add]\n  exact mul_le_mul le_rfl (le_exp_log _) mgf_nonneg (exp_pos _).le\n#align measure_le_le_exp_cgf measure_le_le_exp_cgf\n\n",
 "measure_ge_le_exp_mul_mgf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Chernoff bound** on the upper tail of a real random variable. -/\ntheorem measure_ge_le_exp_mul_mgf [FiniteMeasure μ] (ε : exprℝ) (ht : 0 ≤ t)\n    (h_int : integrable (fun ω => exp (t * X ω)) μ) : (μ { ω | ε ≤ X ω }).to_real ≤ exp (-t * ε) * mgf X μ t :=\n  by\n  cases' ht.eq_or_lt with ht_zero_eq ht_pos\n  · rw [ht_zero_eq.symm]\n    simp only [neg_zero, MulZeroClass.zero_mul, exp_zero, mgf_zero', one_mul]\n    rw [ENNReal.toReal_le_toReal (measure_ne_top μ _) (measure_ne_top μ _)]\n    exact measure_mono (Set.subset_univ _)\n  calc\n    (μ { ω | ε ≤ X ω }).to_real = (μ { ω | exp (t * ε) ≤ exp (t * X ω) }).to_real :=\n      by\n      congr with ω\n      simp only [exp_le_exp, eq_iff_iff]\n      exact ⟨fun h => mul_le_mul_of_nonneg_left h ht_pos.le, fun h => le_of_mul_le_mul_left h ht_pos⟩\n    _ ≤ (exp (t * ε))⁻¹ * condexp.probability μ fun ω => exp (t * X ω) :=\n      by\n      have :\n        exp (t * ε) * (μ { ω | exp (t * ε) ≤ exp (t * X ω) }).to_real ≤ condexp.probability μ fun ω => exp (t * X ω) :=\n        mul_meas_ge_le_integral_of_nonneg (fun x => (exp_pos _).le) h_int _\n      rwa [mul_comm (exp (t * ε))⁻¹, ← div_eq_mul_inv, le_div_iff' (exp_pos _)]\n    _ = exp (-t * ε) * mgf X μ t := by\n      rw [neg_mul, exp_neg]\n      rfl\n    \n#align measure_ge_le_exp_mul_mgf measure_ge_le_exp_mul_mgf\n\n",
 "measure_ge_le_exp_cgf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Chernoff bound** on the upper tail of a real random variable. -/\ntheorem measure_ge_le_exp_cgf [FiniteMeasure μ] (ε : exprℝ) (ht : 0 ≤ t)\n    (h_int : integrable (fun ω => exp (t * X ω)) μ) : (μ { ω | ε ≤ X ω }).to_real ≤ exp (-t * ε + cgf X μ t) :=\n  by\n  refine' (measure_ge_le_exp_mul_mgf ε ht h_int).trans _\n  rw [exp_add]\n  exact mul_le_mul le_rfl (le_exp_log _) mgf_nonneg (exp_pos _).le\n#align measure_ge_le_exp_cgf measure_ge_le_exp_cgf\n\n",
 "integrable_exp_mul_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem Indep_fun.integrable_exp_mul_sum [ProbabilityMeasure μ] {X : ι → Ω → exprℝ}\n    (h_indep : Indep_fun (fun i => inferInstance) X μ) (h_meas : ∀ i, Measurable (X i)) {s : Finset ι}\n    (h_int : ∀ i ∈ s, integrable (fun ω => exp (t * X i ω)) μ) :\n    integrable\n      (fun ω =>\n        exp\n          (t *\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (X i))\n              ω))\n      μ :=\n  by\n  classical\n    induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int\n    · simp only [Pi.zero_apply, sum_apply, sum_empty, MulZeroClass.mul_zero, exp_zero]\n      exact integrable_const _\n    · have : ∀ i : ι, i ∈ s → integrable (fun ω : Ω => exp (t * X i ω)) μ := fun i hi => h_int i (mem_insert_of_mem hi)\n      specialize h_rec this\n      rw [sum_insert hi_notin_s]\n      refine' indep_fun.integrable_exp_mul_add _ (h_int i (mem_insert_self _ _)) h_rec\n      exact (h_indep.indep_fun_finset_sum_of_not_mem h_meas hi_notin_s).symm\n#align Indep_fun.integrable_exp_mul_sum Indep_fun.integrable_exp_mul_sum\n\n",
 "integrable_exp_mul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem indep_fun.integrable_exp_mul_add {X Y : Ω → exprℝ} (h_indep : indep_fun X Y μ)\n    (h_int_X : integrable (fun ω => exp (t * X ω)) μ) (h_int_Y : integrable (fun ω => exp (t * Y ω)) μ) :\n    integrable (fun ω => exp (t * (X + Y) ω)) μ :=\n  by\n  simp_rw [Pi.add_apply, mul_add, exp_add]\n  exact (h_indep.exp_mul t t).integrable_mul h_int_X h_int_Y\n#align indep_fun.integrable_exp_mul_add indep_fun.integrable_exp_mul_add\n\n",
 "exp_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- This is a trivial application of `indep_fun.comp` but it will come up frequently. -/\ntheorem indep_fun.exp_mul {X Y : Ω → exprℝ} (h_indep : indep_fun X Y μ) (s t : exprℝ) :\n    indep_fun (fun ω => exp (s * X ω)) (fun ω => exp (t * Y ω)) μ :=\n  by\n  have h_meas : ∀ t, Measurable fun x => exp (t * x) := fun t => (measurable_id'.const_mul t).exp\n  change indep_fun ((fun x => exp (s * x)) ∘ X) ((fun x => exp (t * x)) ∘ Y) μ\n  exact indep_fun.comp h_indep (h_meas s) (h_meas t)\n#align indep_fun.exp_mul indep_fun.exp_mul\n\n",
 "cgf_zero_measure":
 "@[simp]\ntheorem cgf_zero_measure : cgf X (0 : measure Ω) t = 0 := by simp only [cgf, log_zero, mgf_zero_measure]\n#align cgf_zero_measure cgf_zero_measure\n\n",
 "cgf_zero_fun":
 "@[simp]\ntheorem cgf_zero_fun : cgf 0 μ t = log (μ Set.univ).to_real := by simp only [cgf, mgf_zero_fun]\n#align cgf_zero_fun cgf_zero_fun\n\n",
 "cgf_zero'":
 "@[simp]\ntheorem cgf_zero' : cgf X μ 0 = log (μ Set.univ).to_real := by simp only [cgf, mgf_zero']\n#align cgf_zero' cgf_zero'\n\n",
 "cgf_zero":
 "@[simp]\ntheorem cgf_zero [ProbabilityMeasure μ] : cgf X μ 0 = 0 := by\n  simp only [cgf_zero', measure_univ, ENNReal.one_toReal, log_one]\n#align cgf_zero cgf_zero\n\n",
 "cgf_undef":
 "theorem cgf_undef (hX : ¬integrable (fun ω => exp (t * X ω)) μ) : cgf X μ t = 0 := by\n  simp only [cgf, mgf_undef hX, log_zero]\n#align cgf_undef cgf_undef\n\n",
 "cgf_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem Indep_fun.cgf_sum [ProbabilityMeasure μ] {X : ι → Ω → exprℝ} (h_indep : Indep_fun (fun i => inferInstance) X μ)\n    (h_meas : ∀ i, Measurable (X i)) {s : Finset ι} (h_int : ∀ i ∈ s, integrable (fun ω => exp (t * X i ω)) μ) :\n    cgf (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (X i)) μ t =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (cgf (X i) μ t) :=\n  by\n  simp_rw [cgf]\n  rw [← log_prod _ _ fun j hj => _]\n  · rw [h_indep.mgf_sum h_meas]\n  · exact (mgf_pos (h_int j hj)).ne'\n#align Indep_fun.cgf_sum Indep_fun.cgf_sum\n\n",
 "cgf_neg":
 "theorem cgf_neg : cgf (-X) μ t = cgf X μ (-t) := by simp_rw [cgf, mgf_neg]\n#align cgf_neg cgf_neg\n\n",
 "cgf_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem cgf_const' [FiniteMeasure μ] (hμ : μ ≠ 0) (c : exprℝ) :\n    cgf (fun _ => c) μ t = log (μ Set.univ).to_real + t * c :=\n  by\n  simp only [cgf, mgf_const']\n  rw [log_mul _ (exp_pos _).ne']\n  · rw [log_exp _]\n  · rw [ne.def, ENNReal.toReal_eq_zero_iff, measure.measure_univ_eq_zero]\n    simp only [hμ, measure_ne_top μ Set.univ, or_self_iff, not_false_iff]\n#align cgf_const' cgf_const'\n\n",
 "cgf_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n@[simp]\ntheorem cgf_const [ProbabilityMeasure μ] (c : exprℝ) : cgf (fun _ => c) μ t = t * c := by\n  simp only [cgf, mgf_const, log_exp]\n#align cgf_const cgf_const\n\n",
 "cgf_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem indep_fun.cgf_add {X Y : Ω → exprℝ} (h_indep : indep_fun X Y μ)\n    (h_int_X : integrable (fun ω => exp (t * X ω)) μ) (h_int_Y : integrable (fun ω => exp (t * Y ω)) μ) :\n    cgf (X + Y) μ t = cgf X μ t + cgf Y μ t := by\n  by_cases hμ : μ = 0\n  · simp [hμ]\n  simp only [cgf, h_indep.mgf_add h_int_X.ae_strongly_measurable h_int_Y.ae_strongly_measurable]\n  exact log_mul (mgf_pos' hμ h_int_X).ne' (mgf_pos' hμ h_int_Y).ne'\n#align indep_fun.cgf_add indep_fun.cgf_add\n\n",
 "central_moment_zero":
 "@[simp]\ntheorem central_moment_zero (hp : p ≠ 0) : central_moment 0 p μ = 0 := by\n  simp only [central_moment, hp, Pi.zero_apply, integral_const, Algebra.id.smul_eq_mul, MulZeroClass.mul_zero, zero_sub,\n    Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow', ne.def, not_false_iff]\n#align central_moment_zero central_moment_zero\n\n",
 "central_moment_two_eq_variance":
 "theorem central_moment_two_eq_variance [FiniteMeasure μ] (hX : mem_ℒp X 2 μ) : central_moment X 2 μ = variance X μ :=\n  by\n  rw [hX.variance_eq]\n  rfl\n#align central_moment_two_eq_variance central_moment_two_eq_variance\n\n",
 "central_moment_one'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\ntheorem central_moment_one' [FiniteMeasure μ] (h_int : integrable X μ) :\n    central_moment X 1 μ = (1 - (μ Set.univ).to_real) * condexp.probability μ X :=\n  by\n  simp only [central_moment, Pi.sub_apply, pow_one]\n  rw [integral_sub h_int (integrable_const _)]\n  simp only [sub_mul, integral_const, Algebra.id.smul_eq_mul, one_mul]\n#align central_moment_one' central_moment_one'\n\n",
 "central_moment_one":
 "@[simp]\ntheorem central_moment_one [ProbabilityMeasure μ] : central_moment X 1 μ = 0 :=\n  by\n  by_cases h_int : integrable X μ\n  · rw [central_moment_one' h_int]\n    simp only [measure_univ, ENNReal.one_toReal, sub_self, MulZeroClass.zero_mul]\n  · simp only [central_moment, Pi.sub_apply, pow_one]\n    have : ¬integrable (fun x => X x - integral μ X) μ :=\n      by\n      refine' fun h_sub => h_int _\n      have h_add : X = (fun x => X x - integral μ X) + fun x => integral μ X :=\n        by\n        ext1 x\n        simp\n      rw [h_add]\n      exact h_sub.add (integrable_const _)\n    rw [integral_undef this]\n#align central_moment_one central_moment_one\n\n",
 "ae_strongly_measurable_exp_mul_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem ae_strongly_measurable_exp_mul_sum {X : ι → Ω → exprℝ} {s : Finset ι}\n    (h_int : ∀ i ∈ s, ae_strongly_measurable (fun ω => exp (t * X i ω)) μ) :\n    ae_strongly_measurable\n      (fun ω =>\n        exp\n          (t *\n            (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (X i))\n              ω))\n      μ :=\n  by\n  classical\n    induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int\n    · simp only [Pi.zero_apply, sum_apply, sum_empty, MulZeroClass.mul_zero, exp_zero]\n      exact ae_strongly_measurable_const\n    · have : ∀ i : ι, i ∈ s → ae_strongly_measurable (fun ω : Ω => exp (t * X i ω)) μ := fun i hi =>\n        h_int i (mem_insert_of_mem hi)\n      specialize h_rec this\n      rw [sum_insert hi_notin_s]\n      apply ae_strongly_measurable_exp_mul_add (h_int i (mem_insert_self _ _)) h_rec\n#align ae_strongly_measurable_exp_mul_sum ae_strongly_measurable_exp_mul_sum\n\n",
 "ae_strongly_measurable_exp_mul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem ae_strongly_measurable_exp_mul_add {X Y : Ω → exprℝ}\n    (h_int_X : ae_strongly_measurable (fun ω => exp (t * X ω)) μ)\n    (h_int_Y : ae_strongly_measurable (fun ω => exp (t * Y ω)) μ) :\n    ae_strongly_measurable (fun ω => exp (t * (X + Y) ω)) μ :=\n  by\n  simp_rw [Pi.add_apply, mul_add, exp_add]\n  exact ae_strongly_measurable.mul h_int_X h_int_Y\n#align ae_strongly_measurable_exp_mul_add ae_strongly_measurable_exp_mul_add\n\n"}