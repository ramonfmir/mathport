{"union_iff":
 "@[simp]\ntheorem indep_sets.union_iff [measurable_space Ω] {s₁ s₂ s' : set (set Ω)} {μ : measure Ω} :\n    indep_sets (s₁ ∪ s₂) s' μ ↔ indep_sets s₁ s' μ ∧ indep_sets s₂ s' μ :=\n  ⟨fun h =>\n    ⟨indep_sets_of_indep_sets_of_le_left h (Set.subset_union_left s₁ s₂),\n      indep_sets_of_indep_sets_of_le_left h (Set.subset_union_right s₁ s₂)⟩,\n    fun h => indep_sets.union h.left h.right⟩\n#align indep_sets.union_iff indep_sets.union_iff\n\n",
 "union":
 "theorem indep_sets.union [measurable_space Ω] {s₁ s₂ s' : set (set Ω)} {μ : measure Ω} (h₁ : indep_sets s₁ s' μ)\n    (h₂ : indep_sets s₂ s' μ) : indep_sets (s₁ ∪ s₂) s' μ :=\n  by\n  intro t1 t2 ht1 ht2\n  cases' (Set.mem_union _ _ _).mp ht1 with ht1₁ ht1₂\n  · exact h₁ t1 t2 ht1₁ ht2\n  · exact h₂ t1 t2 ht1₂ ht2\n#align indep_sets.union indep_sets.union\n\n",
 "symm":
 "@[symm]\ntheorem indep_fun.symm {mβ : measurable_space β} {f g : Ω → β} (hfg : indep_fun f g μ) : indep_fun g f μ :=\n  hfg.symm\n#align indep_fun.symm indep_fun.symm\n\n",
 "pi_Union_Inter_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem Indep_sets.pi_Union_Inter_of_not_mem {π : ι → set (set Ω)} {a : ι} {S : Finset ι} (hp_ind : Indep_sets π μ)\n    (haS : a ∉ S) : indep_sets (pi_Union_Inter π S) (π a) μ :=\n  by\n  rintro t1 t2 ⟨s, hs_mem, ft1, hft1_mem, ht1_eq⟩ ht2_mem_pia\n  rw [Finset.coe_subset] at hs_mem\n  classical\n    let f n := ite (n = a) t2 (ite (n ∈ s) (ft1 n) Set.univ)\n    have h_f_mem : ∀ n ∈ insert a s, f n ∈ π n := by\n      intro n hn_mem_insert\n      simp_rw [f]\n      cases' finset.mem_insert.mp hn_mem_insert with hn_mem hn_mem\n      · simp [hn_mem, ht2_mem_pia]\n      · have hn_ne_a : n ≠ a := by\n          rintro rfl\n          exact haS (hs_mem hn_mem)\n        simp [hn_ne_a, hn_mem, hft1_mem n hn_mem]\n    have h_f_mem_pi : ∀ n ∈ s, f n ∈ π n := fun x hxS => h_f_mem x (by simp [hxS])\n    have h_t1 :\n      t1 = «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f n) :=\n      by\n      suffices h_forall : ∀ n ∈ s, f n = ft1 n\n      · rw [ht1_eq]\n        congr with (n x)\n        congr with (hns y)\n        simp only [(h_forall n hns).symm]\n      intro n hnS\n      have hn_ne_a : n ≠ a := by\n        rintro rfl\n        exact haS (hs_mem hnS)\n      simp_rw [f, if_pos hnS, if_neg hn_ne_a]\n    have h_μ_t1 :\n      μ t1 =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (μ (f n)) :=\n      by rw [h_t1, ← hp_ind s h_f_mem_pi]\n    have h_t2 : t2 = f a := by\n      simp_rw [f]\n      simp\n    have h_μ_inter :\n      μ (t1 ∩ t2) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (insert a s)\n          (μ (f n)) :=\n      by\n      have h_t1_inter_t2 :\n        t1 ∩ t2 =\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f n) :=\n        by rw [h_t1, h_t2, finset.set_bInter_insert, Set.inter_comm]\n      rw [h_t1_inter_t2, ← hp_ind (insert a s) h_f_mem]\n    have has : a ∉ s := fun has_mem => haS (hs_mem Membership)\n    rw [h_μ_inter, finset.prod_insert has, h_t2, mul_comm, h_μ_t1]\n#align Indep_sets.pi_Union_Inter_of_not_mem Indep_sets.pi_Union_Inter_of_not_mem\n\n",
 "mul":
 "@[to_additive]\ntheorem Indep_fun.mul [is_probability_measure μ] {ι : Type _} {β : Type _} {m : measurable_space β} [Mul β]\n    [has_measurable_mul₂ β] {f : ι → Ω → β} (hf_Indep : Indep_fun (fun _ => m) f μ) (hf_meas : ∀ i, measurable (f i))\n    (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) : indep_fun (f i * f j) (f k) μ :=\n  by\n  have : indep_fun (fun ω => (f i ω, f j ω)) (f k) μ := hf_Indep.indep_fun_prod hf_meas i j k hik hjk\n  change indep_fun ((fun p : β × β => p.fst * p.snd) ∘ fun ω => (f i ω, f j ω)) (id ∘ f k) μ\n  exact indep_fun.comp this (measurable_fst.mul measurable_snd) measurable_id\n#align Indep_fun.mul Indep_fun.mul\n\n",
 "measure_zero_or_one_of_measurable_set_limsup_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- **Kolmogorov's 0-1 law** : any event in the tail σ-algebra of an independent sequence of\nsub-σ-algebras has probability 0 or 1.\nThe tail σ-algebra `limsup s at_top` is the same as `⋂ n, ⋃ i ≥ n, s i`. -/\ntheorem measure_zero_or_one_of_measurable_set_limsup_at_top (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) {t : set Ω}\n    (ht_tail : (measurable_set_of (limsup s at_top)) t) : μ t = 0 ∨ μ t = 1 :=\n  measure_eq_zero_or_one_of_indep_set_self\n    ((indep_limsup_at_top_self h_le h_indep).indep_set_of_measurable_set ht_tail ht_tail)\n#align measure_zero_or_one_of_measurable_set_limsup_at_top measure_zero_or_one_of_measurable_set_limsup_at_top\n\n",
 "measure_zero_or_one_of_measurable_set_limsup_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- **Kolmogorov's 0-1 law** : any event in the tail σ-algebra of an independent sequence of\nsub-σ-algebras has probability 0 or 1. -/\ntheorem measure_zero_or_one_of_measurable_set_limsup_at_bot (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) {t : set Ω}\n    (ht_tail : (measurable_set_of (limsup s at_bot)) t) : μ t = 0 ∨ μ t = 1 :=\n  measure_eq_zero_or_one_of_indep_set_self\n    ((indep_limsup_at_bot_self h_le h_indep).indep_set_of_measurable_set ht_tail ht_tail)\n#align measure_zero_or_one_of_measurable_set_limsup_at_bot measure_zero_or_one_of_measurable_set_limsup_at_bot\n\n",
 "measure_zero_or_one_of_measurable_set_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measure_zero_or_one_of_measurable_set_limsup (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ)\n    (hf : ∀ t, p t → «expr ᶜ» t ∈ f) (hns : Directed (· ≤ ·) ns) (hnsp : ∀ a, p (ns a)) (hns_univ : ∀ n, ∃ a, n ∈ ns a)\n    {t : set Ω} (ht_tail : (measurable_set_of (limsup s f)) t) : μ t = 0 ∨ μ t = 1 :=\n  measure_eq_zero_or_one_of_indep_set_self\n    ((indep_limsup_self h_le h_indep hf hns hnsp hns_univ).indep_set_of_measurable_set ht_tail ht_tail)\n#align measure_zero_or_one_of_measurable_set_limsup measure_zero_or_one_of_measurable_set_limsup\n\n",
 "measure_eq_zero_or_one_or_top_of_indep_set_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem measure_eq_zero_or_one_or_top_of_indep_set_self {t : set Ω} (h_indep : indep_set t t μ) :\n    μ t = 0 ∨ μ t = 1 ∨ μ t = ennreal.top :=\n  by\n  specialize\n    h_indep t t (measurable_set_generate_from (Set.mem_singleton t))\n      (measurable_set_generate_from (Set.mem_singleton t))\n  by_cases h0 : μ t = 0\n  · exact or.inl h0\n  by_cases h_top : μ t = ennreal.top\n  · exact or.inr (or.inr h_top)\n  rw [← one_mul (μ (t ∩ t)), Set.inter_self, ennreal.mul_eq_mul_right h0 h_top] at h_indep\n  exact or.inr (or.inl h_indep.symm)\n#align measure_eq_zero_or_one_or_top_of_indep_set_self measure_eq_zero_or_one_or_top_of_indep_set_self\n\n",
 "measure_eq_zero_or_one_of_indep_set_self":
 "theorem measure_eq_zero_or_one_of_indep_set_self [is_finite_measure μ] {t : set Ω} (h_indep : indep_set t t μ) :\n    μ t = 0 ∨ μ t = 1 :=\n  by\n  have h_0_1_top := measure_eq_zero_or_one_or_top_of_indep_set_self h_indep\n  simpa [measure_ne_top μ] using h_0_1_top\n#align measure_eq_zero_or_one_of_indep_set_self measure_eq_zero_or_one_of_indep_set_self\n\n",
 "inter":
 "theorem indep_sets.inter [measurable_space Ω] {s₁ s' : set (set Ω)} (s₂ : set (set Ω)) {μ : measure Ω}\n    (h₁ : indep_sets s₁ s' μ) : indep_sets (s₁ ∩ s₂) s' μ := fun t1 t2 ht1 ht2 =>\n  h₁ t1 t2 ((Set.mem_inter_iff _ _ _).mp ht1).left ht2\n#align indep_sets.inter indep_sets.inter\n\n",
 "indep_supr_of_monotone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_supr_of_monotone [SemilatticeSup ι] {Ω} {m : ι → measurable_space Ω} {m' m0 : measurable_space Ω}\n    {μ : measure Ω} [is_probability_measure μ] (h_indep : ∀ i, indep (m i) m' μ) (h_le : ∀ i, m i ≤ m0)\n    (h_le' : m' ≤ m0) (hm : monotone m) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) m'\n      μ :=\n  indep_supr_of_directed_le h_indep h_le h_le' (Monotone.directed_le hm)\n#align indep_supr_of_monotone indep_supr_of_monotone\n\n",
 "indep_supr_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_supr_of_disjoint [is_probability_measure μ] {m : ι → measurable_space Ω} (h_le : ∀ i, m i ≤ m0)\n    (h_indep : Indep m μ) {S T : set ι} (hST : Disjoint S T) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i))\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) μ :=\n  by\n  refine'\n    indep_sets.indep (supᵢ₂_le fun i _ => h_le i) (supᵢ₂_le fun i _ => h_le i) _ _\n      (generate_from_pi_Union_Inter_measurable_set m S).symm (generate_from_pi_Union_Inter_measurable_set m T).symm _\n  · exact is_pi_system_pi_Union_Inter _ (fun n => @is_pi_system_measurable_set Ω (m n)) _\n  · exact is_pi_system_pi_Union_Inter _ (fun n => @is_pi_system_measurable_set Ω (m n)) _\n  · classical exact indep_sets_pi_Union_Inter_of_disjoint h_indep hST\n#align indep_supr_of_disjoint indep_supr_of_disjoint\n\n",
 "indep_supr_of_directed_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_supr_of_directed_le {Ω} {m : ι → measurable_space Ω} {m' m0 : measurable_space Ω} {μ : measure Ω}\n    [is_probability_measure μ] (h_indep : ∀ i, indep (m i) m' μ) (h_le : ∀ i, m i ≤ m0) (h_le' : m' ≤ m0)\n    (hm : Directed (· ≤ ·) m) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) m'\n      μ :=\n  by\n  let p : ι → set (set Ω) := fun n => { t | (measurable_set_of (m n)) t }\n  have hp : ∀ n, is_pi_system (p n) := fun n => @is_pi_system_measurable_set Ω (m n)\n  have h_gen_n : ∀ n, m n = generate_from (p n) := fun n => (@generate_from_measurable_set Ω (m n)).symm\n  have hp_supr_pi :\n    is_pi_system\n      («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (p n)) :=\n    is_pi_system_Union_of_directed_le p hp hm\n  let p' := { t : set Ω | (measurable_set_of m') t }\n  have hp'_pi : is_pi_system p' := @is_pi_system_measurable_set Ω m'\n  have h_gen' : m' = generate_from p' := (@generate_from_measurable_set Ω m').symm\n  -- the π-systems defined are independent\n  have h_pi_system_indep :\n    indep_sets («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (p n))\n      p' μ :=\n    by\n    refine' indep_sets.Union _\n    simp_rw [h_gen_n, h_gen'] at h_indep\n    exact fun n => (h_indep n).indep_sets\n  -- now go from π-systems to σ-algebras\n  refine' indep_sets.indep (supᵢ_le h_le) h_le' hp_supr_pi hp'_pi _ h_gen' h_pi_system_indep\n  exact (generate_from_Union_measurable_set _).symm\n#align indep_supr_of_directed_le indep_supr_of_directed_le\n\n",
 "indep_supr_of_antitone":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_supr_of_antitone [SemilatticeInf ι] {Ω} {m : ι → measurable_space Ω} {m' m0 : measurable_space Ω}\n    {μ : measure Ω} [is_probability_measure μ] (h_indep : ∀ i, indep (m i) m' μ) (h_le : ∀ i, m i ≤ m0)\n    (h_le' : m' ≤ m0) (hm : antitone m) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (m i)) m'\n      μ :=\n  indep_supr_of_directed_le h_indep h_le h_le' (directed_of_inf hm)\n#align indep_supr_of_antitone indep_supr_of_antitone\n\n",
 "indep_supr_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_supr_limsup (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) (hf : ∀ t, p t → «expr ᶜ» t ∈ f)\n    (hns : Directed (· ≤ ·) ns) (hnsp : ∀ a, p (ns a)) (hns_univ : ∀ n, ∃ a, n ∈ ns a) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n))\n      (limsup s f) μ :=\n  by\n  suffices\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n)\n    by\n    rw [← this]\n    exact indep_supr_directed_limsup h_le h_indep hf hns hnsp\n  rw [supᵢ_comm]\n  refine' supᵢ_congr fun n => _\n  have :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n) :=\n    by rw [supᵢ_exists]\n  haveI : nonempty (∃ i : α, n ∈ ns i) := ⟨hns_univ n⟩\n  rw [this, supᵢ_const]\n#align indep_supr_limsup indep_supr_limsup\n\n",
 "indep_supr_directed_limsup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_supr_directed_limsup (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) (hf : ∀ t, p t → «expr ᶜ» t ∈ f)\n    (hns : Directed (· ≤ ·) ns) (hnsp : ∀ a, p (ns a)) :\n    indep\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n)))\n      (limsup s f) μ :=\n  by\n  refine' indep_supr_of_directed_le _ _ _ _\n  · exact fun a => indep_bsupr_limsup h_le h_indep hf (hnsp a)\n  · exact fun a => supᵢ₂_le fun n hn => h_le n\n  · exact limsup_le_supr.trans (supᵢ_le h_le)\n  · intro a b\n    obtain ⟨c, hc⟩ := hns a b\n    refine' ⟨c, _, _⟩ <;> refine' supᵢ_mono fun n => supᵢ_mono' fun hn => ⟨_, le_rfl⟩\n    · exact hc.1 hn\n    · exact hc.2 hn\n#align indep_supr_directed_limsup indep_supr_directed_limsup\n\n",
 "indep_sets_singleton_iff":
 "theorem indep_sets_singleton_iff [measurable_space Ω] {s t : set Ω} {μ : measure Ω} :\n    indep_sets {s} {t} μ ↔ μ (s ∩ t) = μ s * μ t :=\n  ⟨fun h => h s t rfl rfl, fun h s1 t1 hs1 ht1 => by rwa [set.mem_singleton_iff.mp hs1, set.mem_singleton_iff.mp ht1]⟩\n#align indep_sets_singleton_iff indep_sets_singleton_iff\n\n",
 "indep_sets_pi_Union_Inter_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem indep_sets_pi_Union_Inter_of_disjoint [is_probability_measure μ] {s : ι → set (set Ω)} {S T : set ι}\n    (h_indep : Indep_sets s μ) (hST : Disjoint S T) : indep_sets (pi_Union_Inter s S) (pi_Union_Inter s T) μ :=\n  by\n  rintro t1 t2 ⟨p1, hp1, f1, ht1_m, ht1_eq⟩ ⟨p2, hp2, f2, ht2_m, ht2_eq⟩\n  classical\n    let g i := ite (i ∈ p1) (f1 i) Set.univ ∩ ite (i ∈ p2) (f2 i) Set.univ\n    have h_P_inter :\n      μ (t1 ∩ t2) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (p1 ∪ p2)\n          (μ (g n)) :=\n      by\n      have hgm : ∀ i ∈ p1 ∪ p2, g i ∈ s i := by\n        intro i hi_mem_union\n        rw [Finset.mem_union] at hi_mem_union\n        cases' hi_mem_union with hi1 hi2\n        · have hi2 : i ∉ p2 := fun hip2 => set.disjoint_left.mp hST (hp1 hi1) (hp2 hip2)\n          simp_rw [g, if_pos hi1, if_neg hi2, Set.inter_univ]\n          exact ht1_m i hi1\n        · have hi1 : i ∉ p1 := fun hip1 => set.disjoint_right.mp hST (hp2 hi2) (hp1 hip1)\n          simp_rw [g, if_neg hi1, if_pos hi2, Set.univ_inter]\n          exact ht2_m i hi2\n      have h_p1_inter_p2 :\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f1 x) ∩\n            «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f2 x) =\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            (ite (i ∈ p1) (f1 i) Set.univ ∩ ite (i ∈ p2) (f2 i) Set.univ) :=\n        by\n        ext1 x\n        simp only [Set.mem_ite_univ_right, Set.mem_inter_iff, Set.mem_interᵢ, Finset.mem_union]\n        exact\n          ⟨fun h i _ => ⟨h.1 i, h.2 i⟩, fun h =>\n            ⟨fun i hi => (h i (or.inl hi)).1 hi, fun i hi => (h i (or.inr hi)).2 hi⟩⟩\n      rw [ht1_eq, ht2_eq, h_p1_inter_p2, ← h_indep _ hgm]\n    have h_μg : ∀ n, μ (g n) = ite (n ∈ p1) (μ (f1 n)) 1 * ite (n ∈ p2) (μ (f2 n)) 1 :=\n      by\n      intro n\n      simp_rw [g]\n      split_ifs\n      · exact absurd rfl (set.disjoint_iff_forall_ne.mp hST _ (hp1 h) _ (hp2 h_1))\n      all_goals simp only [measure_univ, one_mul, mul_one, Set.inter_univ, Set.univ_inter]\n    simp_rw [h_P_inter, h_μg, finset.prod_mul_distrib, finset.prod_ite_mem (p1 ∪ p2) p1 fun x => μ (f1 x),\n      Finset.union_inter_cancel_left, finset.prod_ite_mem (p1 ∪ p2) p2 fun x => μ (f2 x),\n      Finset.union_inter_cancel_right, ht1_eq, ← h_indep p1 ht1_m, ht2_eq, ← h_indep p2 ht2_m]\n#align indep_sets_pi_Union_Inter_of_disjoint indep_sets_pi_Union_Inter_of_disjoint\n\n",
 "indep_sets_of_indep_sets_of_le_right":
 "theorem indep_sets_of_indep_sets_of_le_right {s₁ s₂ s₃ : set (set Ω)} [measurable_space Ω] {μ : measure Ω}\n    (h_indep : indep_sets s₁ s₂ μ) (h32 : s₃ ⊆ s₂) : indep_sets s₁ s₃ μ := fun t1 t2 ht1 ht2 =>\n  h_indep t1 t2 ht1 (Set.mem_of_subset_of_mem h32 ht2)\n#align indep_sets_of_indep_sets_of_le_right indep_sets_of_indep_sets_of_le_right\n\n",
 "indep_sets_of_indep_sets_of_le_left":
 "theorem indep_sets_of_indep_sets_of_le_left {s₁ s₂ s₃ : set (set Ω)} [measurable_space Ω] {μ : measure Ω}\n    (h_indep : indep_sets s₁ s₂ μ) (h31 : s₃ ⊆ s₁) : indep_sets s₃ s₂ μ := fun t1 t2 ht1 ht2 =>\n  h_indep t1 t2 (Set.mem_of_subset_of_mem h31 ht1) ht2\n#align indep_sets_of_indep_sets_of_le_left indep_sets_of_indep_sets_of_le_left\n\n",
 "indep_sets":
 "theorem indep.indep_sets [measurable_space Ω] {μ : measure Ω} {s1 s2 : set (set Ω)}\n    (h_indep : indep (generate_from s1) (generate_from s2) μ) : indep_sets s1 s2 μ := fun t1 t2 ht1 ht2 =>\n  h_indep t1 t2 (measurable_set_generate_from ht1) (measurable_set_generate_from ht2)\n#align indep.indep_sets indep.indep_sets\n\n",
 "indep_set_of_mem":
 "theorem indep_sets.indep_set_of_mem {m0 : measurable_space Ω} (hs : s ∈ S) (ht : t ∈ T) (hs_meas : measurable_set s)\n    (ht_meas : measurable_set t) (μ : measure Ω := by exact measure_theory.measure_space.volume)\n    [is_probability_measure μ] (h_indep : indep_sets S T μ) : indep_set s t μ :=\n  (indep_set_iff_measure_inter_eq_mul hs_meas ht_meas μ).mpr (h_indep s t hs ht)\n#align indep_sets.indep_set_of_mem indep_sets.indep_set_of_mem\n\n",
 "indep_set_of_measurable_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem indep.indep_set_of_measurable_set {m₁ m₂ m0 : measurable_space Ω} {μ : measure Ω} (h_indep : indep m₁ m₂ μ)\n    {s t : set Ω} (hs : (measurable_set_of m₁) s) (ht : (measurable_set_of m₂) t) : indep_set s t μ :=\n  by\n  refine' fun s' t' hs' ht' => h_indep s' t' _ _\n  · refine' generate_from_induction (fun u => (measurable_set_of m₁) u) {s} _ _ _ _ hs'\n    · simp only [hs, Set.mem_singleton_iff, Set.mem_setOf_eq, forall_eq]\n    · exact @measurable_set.empty _ m₁\n    · exact fun u hu => hu.compl\n    · exact fun f hf => measurable_set.Union hf\n  · refine' generate_from_induction (fun u => (measurable_set_of m₂) u) {t} _ _ _ _ ht'\n    · simp only [ht, Set.mem_singleton_iff, Set.mem_setOf_eq, forall_eq]\n    · exact @measurable_set.empty _ m₂\n    · exact fun u hu => hu.compl\n    · exact fun f hf => measurable_set.Union hf\n#align indep.indep_set_of_measurable_set indep.indep_set_of_measurable_set\n\n",
 "indep_set_iff_measure_inter_eq_mul":
 "theorem indep_set_iff_measure_inter_eq_mul {m0 : measurable_space Ω} (hs_meas : measurable_set s)\n    (ht_meas : measurable_set t) (μ : measure Ω := by exact measure_theory.measure_space.volume)\n    [is_probability_measure μ] : indep_set s t μ ↔ μ (s ∩ t) = μ s * μ t :=\n  (indep_set_iff_indep_sets_singleton hs_meas ht_meas μ).trans indep_sets_singleton_iff\n#align indep_set_iff_measure_inter_eq_mul indep_set_iff_measure_inter_eq_mul\n\n",
 "indep_set_iff_indep_sets_singleton":
 "theorem indep_set_iff_indep_sets_singleton {m0 : measurable_space Ω} (hs_meas : measurable_set s)\n    (ht_meas : measurable_set t) (μ : measure Ω := by exact measure_theory.measure_space.volume)\n    [is_probability_measure μ] : indep_set s t μ ↔ indep_sets {s} {t} μ :=\n  ⟨indep.indep_sets, fun h =>\n    indep_sets.indep (generate_from_le fun u hu => by rwa [set.mem_singleton_iff.mp hu])\n      (generate_from_le fun u hu => by rwa [set.mem_singleton_iff.mp hu]) (is_pi_system.singleton s)\n      (is_pi_system.singleton t) rfl rfl h⟩\n#align indep_set_iff_indep_sets_singleton indep_set_iff_indep_sets_singleton\n\n",
 "indep_set_empty_right":
 "theorem indep_set_empty_right {m : measurable_space Ω} {μ : measure Ω} [is_probability_measure μ] (s : set Ω) :\n    indep_set s ∅ μ := by\n  simp only [indep_set, generate_from_singleton_empty]\n  exact indep_bot_right _\n#align indep_set_empty_right indep_set_empty_right\n\n",
 "indep_set_empty_left":
 "theorem indep_set_empty_left {m : measurable_space Ω} {μ : measure Ω} [is_probability_measure μ] (s : set Ω) :\n    indep_set ∅ s μ :=\n  (indep_set_empty_right s).symm\n#align indep_set_empty_left indep_set_empty_left\n\n",
 "indep_of_indep_of_le_right":
 "theorem indep_of_indep_of_le_right {m₁ m₂ m₃ : measurable_space Ω} [measurable_space Ω] {μ : measure Ω}\n    (h_indep : indep m₁ m₂ μ) (h32 : m₃ ≤ m₂) : indep m₁ m₃ μ := fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)\n#align indep_of_indep_of_le_right indep_of_indep_of_le_right\n\n",
 "indep_of_indep_of_le_left":
 "theorem indep_of_indep_of_le_left {m₁ m₂ m₃ : measurable_space Ω} [measurable_space Ω] {μ : measure Ω}\n    (h_indep : indep m₁ m₂ μ) (h31 : m₃ ≤ m₁) : indep m₃ m₂ μ := fun t1 t2 ht1 ht2 => h_indep t1 t2 (h31 _ ht1) ht2\n#align indep_of_indep_of_le_left indep_of_indep_of_le_left\n\n",
 "indep_limsup_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem indep_limsup_self (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) (hf : ∀ t, p t → «expr ᶜ» t ∈ f)\n    (hns : Directed (· ≤ ·) ns) (hnsp : ∀ a, p (ns a)) (hns_univ : ∀ n, ∃ a, n ∈ ns a) :\n    indep (limsup s f) (limsup s f) μ :=\n  indep_of_indep_of_le_left (indep_supr_limsup h_le h_indep hf hns hnsp hns_univ) limsup_le_supr\n#align indep_limsup_self indep_limsup_self\n\n",
 "indep_limsup_at_top_self":
 "theorem indep_limsup_at_top_self (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) :\n    indep (limsup s at_top) (limsup s at_top) μ :=\n  by\n  let ns : ι → set ι := Set.Iic\n  have hnsp : ∀ i, BddAbove (ns i) := fun i => bddAbove_Iic\n  refine' indep_limsup_self h_le h_indep _ _ hnsp _\n  · simp only [mem_at_top_sets, ge_iff_le, Set.mem_compl_iff, BddAbove, upperBounds, Set.Nonempty]\n    rintro t ⟨a, ha⟩\n    obtain ⟨b, hb⟩ : ∃ b, a < b := exists_gt a\n    refine' ⟨b, fun c hc hct => _⟩\n    suffices : ∀ i ∈ t, i < c\n    exact lt_irrefl c (this c hct)\n    exact fun i hi => (ha hi).trans_lt (hb.trans_le hc)\n  · exact Monotone.directed_le fun i j hij k hki => le_trans hki hij\n  · exact fun n => ⟨n, le_rfl⟩\n#align indep_limsup_at_top_self indep_limsup_at_top_self\n\n",
 "indep_limsup_at_bot_self":
 "theorem indep_limsup_at_bot_self (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) :\n    indep (limsup s at_bot) (limsup s at_bot) μ :=\n  by\n  let ns : ι → set ι := Set.Ici\n  have hnsp : ∀ i, BddBelow (ns i) := fun i => bddBelow_Ici\n  refine' indep_limsup_self h_le h_indep _ _ hnsp _\n  · simp only [mem_at_bot_sets, ge_iff_le, Set.mem_compl_iff, BddBelow, lowerBounds, Set.Nonempty]\n    rintro t ⟨a, ha⟩\n    obtain ⟨b, hb⟩ : ∃ b, b < a := exists_lt a\n    refine' ⟨b, fun c hc hct => _⟩\n    suffices : ∀ i ∈ t, c < i\n    exact lt_irrefl c (this c hct)\n    exact fun i hi => hc.trans_lt (hb.trans_le (ha hi))\n  · exact directed_of_inf fun i j hij k hki => hij.trans hki\n  · exact fun n => ⟨n, le_rfl⟩\n#align indep_limsup_at_bot_self indep_limsup_at_bot_self\n\n",
 "indep_iff_forall_indep_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem indep_iff_forall_indep_set (m₁ m₂ : measurable_space Ω) {m0 : measurable_space Ω} (μ : measure Ω) :\n    indep m₁ m₂ μ ↔ ∀ s t, (measurable_set_of m₁) s → (measurable_set_of m₂) t → indep_set s t μ :=\n  ⟨fun h => fun s t hs ht => h.indep_set_of_measurable_set hs ht, fun h s t hs ht =>\n    h s t hs ht s t (measurable_set_generate_from (Set.mem_singleton s))\n      (measurable_set_generate_from (Set.mem_singleton t))⟩\n#align indep_iff_forall_indep_set indep_iff_forall_indep_set\n\n",
 "indep_generate_from_of_disjoint":
 "theorem Indep_set.indep_generate_from_of_disjoint [is_probability_measure μ] {s : ι → set Ω}\n    (hsm : ∀ n, measurable_set (s n)) (hs : Indep_set s μ) (S T : set ι) (hST : Disjoint S T) :\n    indep (generate_from { t | ∃ n ∈ S, s n = t }) (generate_from { t | ∃ k ∈ T, s k = t }) μ :=\n  by\n  rw [← generate_from_pi_Union_Inter_singleton_left, ← generate_from_pi_Union_Inter_singleton_left]\n  refine'\n    indep_sets.indep' (fun t ht => generate_from_pi_Union_Inter_le _ _ _ _ (measurable_set_generate_from ht))\n      (fun t ht => generate_from_pi_Union_Inter_le _ _ _ _ (measurable_set_generate_from ht)) _ _ _\n  · exact fun k => generate_from_le fun t ht => (Set.mem_singleton_iff.1 ht).symm ▸ hsm k\n  · exact fun k => generate_from_le fun t ht => (Set.mem_singleton_iff.1 ht).symm ▸ hsm k\n  · exact is_pi_system_pi_Union_Inter _ (fun k => is_pi_system.singleton _) _\n  · exact is_pi_system_pi_Union_Inter _ (fun k => is_pi_system.singleton _) _\n  · classical exact indep_sets_pi_Union_Inter_of_disjoint (Indep.Indep_sets (fun n => rfl) hs) hST\n#align Indep_set.indep_generate_from_of_disjoint Indep_set.indep_generate_from_of_disjoint\n\n",
 "indep_generate_from_lt":
 "theorem Indep_set.indep_generate_from_lt [preorder ι] [is_probability_measure μ] {s : ι → set Ω}\n    (hsm : ∀ n, measurable_set (s n)) (hs : Indep_set s μ) (i : ι) :\n    indep (generate_from {s i}) (generate_from { t | ∃ j < i, s j = t }) μ :=\n  by\n  convert hs.indep_generate_from_of_disjoint hsm {i} { j | j < i } (set.disjoint_singleton_left.mpr (lt_irrefl _))\n  simp only [Set.mem_singleton_iff, exists_prop, exists_eq_left, Set.setOf_eq_eq_singleton']\n#align Indep_set.indep_generate_from_lt Indep_set.indep_generate_from_lt\n\n",
 "indep_generate_from_le_nat":
 "theorem Indep_set.indep_generate_from_le_nat [is_probability_measure μ] {s : ℕ → set Ω}\n    (hsm : ∀ n, measurable_set (s n)) (hs : Indep_set s μ) (n : ℕ) :\n    indep (generate_from {s (n + 1)}) (generate_from { t | ∃ k ≤ n, s k = t }) μ :=\n  hs.indep_generate_from_le hsm _ n.lt_succ_self\n#align Indep_set.indep_generate_from_le_nat Indep_set.indep_generate_from_le_nat\n\n",
 "indep_generate_from_le":
 "theorem Indep_set.indep_generate_from_le [linear_order ι] [is_probability_measure μ] {s : ι → set Ω}\n    (hsm : ∀ n, measurable_set (s n)) (hs : Indep_set s μ) (i : ι) {k : ι} (hk : i < k) :\n    indep (generate_from {s k}) (generate_from { t | ∃ j ≤ i, s j = t }) μ :=\n  by\n  convert hs.indep_generate_from_of_disjoint hsm {k} { j | j ≤ i } (set.disjoint_singleton_left.mpr hk.not_le)\n  simp only [Set.mem_singleton_iff, exists_prop, exists_eq_left, Set.setOf_eq_eq_singleton']\n#align Indep_set.indep_generate_from_le Indep_set.indep_generate_from_le\n\n",
 "indep_fun_prod_range_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem Indep_fun.indep_fun_prod_range_succ [is_probability_measure μ] {β : Type _} {m : measurable_space β}\n    [comm_monoid β] [has_measurable_mul₂ β] {f : ℕ → Ω → β} (hf_Indep : Indep_fun (fun _ => m) f μ)\n    (hf_meas : ∀ i, measurable (f i)) (n : ℕ) :\n    indep_fun\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n        (Finset.range n) (f j))\n      (f n) μ :=\n  hf_Indep.indep_fun_finset_prod_of_not_mem hf_meas Finset.not_mem_range_self\n#align Indep_fun.indep_fun_prod_range_succ Indep_fun.indep_fun_prod_range_succ\n\n",
 "indep_fun_prod":
 "theorem Indep_fun.indep_fun_prod [is_probability_measure μ] {ι : Type _} {β : ι → Type _}\n    {m : ∀ i, measurable_space (β i)} {f : ∀ i, Ω → β i} (hf_Indep : Indep_fun m f μ) (hf_meas : ∀ i, measurable (f i))\n    (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) : indep_fun (fun a => (f i a, f j a)) (f k) μ := by\n  classical\n    have h_right :\n      f k =\n        (fun p : ∀ j : ({k} : Finset ι), β j => p ⟨k, Finset.mem_singleton_self k⟩) ∘ fun a (j : ({k} : Finset ι)) =>\n          f j a :=\n      rfl\n    have h_meas_right : measurable fun p : ∀ j : ({k} : Finset ι), β j => p ⟨k, Finset.mem_singleton_self k⟩ :=\n      measurable_pi_apply ⟨k, Finset.mem_singleton_self k⟩\n    let s : Finset ι := {i, j}\n    have h_left :\n      (fun ω => (f i ω, f j ω)) =\n        (fun p : ∀ l : s, β l =>\n            (p ⟨i, Finset.mem_insert_self i _⟩, p ⟨j, Finset.mem_insert_of_mem (Finset.mem_singleton_self _)⟩)) ∘\n          fun a (j : s) => f j a :=\n      by\n      ext1 a\n      simp only [prod.mk.inj_iff]\n      constructor <;> rfl\n    have h_meas_left :\n      measurable fun p : ∀ l : s, β l =>\n        (p ⟨i, Finset.mem_insert_self i _⟩, p ⟨j, Finset.mem_insert_of_mem (Finset.mem_singleton_self _)⟩) :=\n      measurable.prod (measurable_pi_apply ⟨i, Finset.mem_insert_self i {j}⟩)\n        (measurable_pi_apply ⟨j, Finset.mem_insert_of_mem (Finset.mem_singleton_self j)⟩)\n    rw [h_left, h_right]\n    refine' (hf_Indep.indep_fun_finset s {k} _ hf_meas).comp h_meas_left h_meas_right\n    rw [Finset.disjoint_singleton_right]\n    simp only [Finset.mem_insert, Finset.mem_singleton, not_or]\n    exact ⟨hik.symm, hjk.symm⟩\n#align Indep_fun.indep_fun_prod Indep_fun.indep_fun_prod\n\n",
 "indep_fun_iff_measure_inter_preimage_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem indep_fun_iff_measure_inter_preimage_eq_mul {mβ : measurable_space β} {mβ' : measurable_space β'} :\n    indep_fun f g μ ↔\n      ∀ s t,\n        measurable_set s →\n          measurable_set t → μ («expr ⁻¹' » f s ∩ «expr ⁻¹' » g t) = μ («expr ⁻¹' » f s) * μ («expr ⁻¹' » g t) :=\n  by\n  constructor <;> intro h\n  · refine' fun s t hs ht => h («expr ⁻¹' » f s) («expr ⁻¹' » g t) ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  · rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n    exact h s t hs ht\n#align indep_fun_iff_measure_inter_preimage_eq_mul indep_fun_iff_measure_inter_preimage_eq_mul\n\n",
 "indep_fun_iff_indep_set_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem indep_fun_iff_indep_set_preimage {mβ : measurable_space β} {mβ' : measurable_space β'}\n    [is_probability_measure μ] (hf : measurable f) (hg : measurable g) :\n    indep_fun f g μ ↔ ∀ s t, measurable_set s → measurable_set t → indep_set («expr ⁻¹' » f s) («expr ⁻¹' » g t) μ :=\n  by\n  refine' indep_fun_iff_measure_inter_preimage_eq_mul.trans _\n  constructor <;> intro h s t hs ht <;> specialize h s t hs ht\n  · rwa [indep_set_iff_measure_inter_eq_mul (hf hs) (hg ht) μ]\n  · rwa [← indep_set_iff_measure_inter_eq_mul (hf hs) (hg ht) μ]\n#align indep_fun_iff_indep_set_preimage indep_fun_iff_indep_set_preimage\n\n",
 "indep_fun_finset_prod_of_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\ntheorem Indep_fun.indep_fun_finset_prod_of_not_mem [is_probability_measure μ] {ι : Type _} {β : Type _}\n    {m : measurable_space β} [comm_monoid β] [has_measurable_mul₂ β] {f : ι → Ω → β}\n    (hf_Indep : Indep_fun (fun _ => m) f μ) (hf_meas : ∀ i, measurable (f i)) {s : Finset ι} {i : ι} (hi : i ∉ s) :\n    indep_fun\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f j)) (f i)\n      μ :=\n  by\n  classical\n    have h_right :\n      f i =\n        (fun p : ∀ j : ({i} : Finset ι), β => p ⟨i, Finset.mem_singleton_self i⟩) ∘ fun a (j : ({i} : Finset ι)) =>\n          f j a :=\n      rfl\n    have h_meas_right : measurable fun p : ∀ j : ({i} : Finset ι), β => p ⟨i, Finset.mem_singleton_self i⟩ :=\n      measurable_pi_apply ⟨i, Finset.mem_singleton_self i⟩\n    have h_left :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (f j) =\n        (fun p : ∀ j : s, β =>\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (p j)) ∘\n          fun a (j : s) => f j a :=\n      by\n      ext1 a\n      simp only [Function.comp_apply]\n      have :\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (f (↑j) a) =\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (f ↑j))\n            a :=\n        by rw [finset.prod_apply]\n      rw [this, finset.prod_coe_sort]\n    have h_meas_left :\n      measurable fun p : ∀ j : s, β =>\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (p j) :=\n      finset.univ.measurable_prod fun (j : «expr↥ » s) (H : j ∈ finset.univ) => measurable_pi_apply j\n    rw [h_left, h_right]\n    exact\n      (hf_Indep.indep_fun_finset s {i} (finset.disjoint_singleton_left.mpr hi).symm hf_meas).comp h_meas_left\n        h_meas_right\n#align Indep_fun.indep_fun_finset_prod_of_not_mem Indep_fun.indep_fun_finset_prod_of_not_mem\n\n",
 "indep_fun_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- If `f` is a family of mutually independent random variables (`Indep_fun m f μ`) and `S, T` are\ntwo disjoint finite index sets, then the tuple formed by `f i` for `i ∈ S` is independent of the\ntuple `(f i)_i` for `i ∈ T`. -/\ntheorem Indep_fun.indep_fun_finset [is_probability_measure μ] {ι : Type _} {β : ι → Type _}\n    {m : ∀ i, measurable_space (β i)} {f : ∀ i, Ω → β i} (S T : Finset ι) (hST : Disjoint S T)\n    (hf_Indep : Indep_fun m f μ) (hf_meas : ∀ i, measurable (f i)) :\n    indep_fun (fun a (i : S) => f i a) (fun a (i : T) => f i a) μ :=\n  by\n  -- We introduce π-systems, build from the π-system of boxes which generates `measurable_space.pi`.\n  let πSβ :=\n    «expr '' » (Set.pi (Set.univ : set S))\n      (Set.pi (Set.univ : set S) fun i => { s : set (β i) | (measurable_set_of (m i)) s })\n  let πS := { s : set Ω | ∃ t ∈ πSβ, «expr ⁻¹' » (fun a (i : S) => f i a) t = s }\n  have hπS_pi : is_pi_system πS := is_pi_system_pi.comap fun a i => f i a\n  have hπS_gen : (measurable_space.pi.comap fun a (i : S) => f i a) = generate_from πS :=\n    by\n    rw [generate_from_pi.symm, comap_generate_from]\n    · congr with s\n      simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop]\n    · infer_instance\n  let πTβ :=\n    «expr '' » (Set.pi (Set.univ : set T))\n      (Set.pi (Set.univ : set T) fun i => { s : set (β i) | (measurable_set_of (m i)) s })\n  let πT := { s : set Ω | ∃ t ∈ πTβ, «expr ⁻¹' » (fun a (i : T) => f i a) t = s }\n  have hπT_pi : is_pi_system πT := is_pi_system_pi.comap fun a i => f i a\n  have hπT_gen : (measurable_space.pi.comap fun a (i : T) => f i a) = generate_from πT :=\n    by\n    rw [generate_from_pi.symm, comap_generate_from]\n    · congr with s\n      simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop]\n    · infer_instance\n  -- To prove independence, we prove independence of the generating π-systems.\n  refine'\n    indep_sets.indep (measurable.comap_le (measurable_pi_iff.mpr fun i => hf_meas i))\n      (measurable.comap_le (measurable_pi_iff.mpr fun i => hf_meas i)) hπS_pi hπT_pi hπS_gen hπT_gen _\n  rintro _ _ ⟨s, ⟨sets_s, hs1, hs2⟩, rfl⟩ ⟨t, ⟨sets_t, ht1, ht2⟩, rfl⟩\n  simp only [Set.mem_univ_pi, Set.mem_setOf_eq] at hs1 ht1\n  rw [← hs2, ← ht2]\n  classical\n    let sets_s' : ∀ i : ι, set (β i) := fun i => dite (i ∈ S) (fun hi => sets_s ⟨i, hi⟩) fun _ => Set.univ\n    have h_sets_s'_eq : ∀ {i} (hi : i ∈ S), sets_s' i = sets_s ⟨i, hi⟩ :=\n      by\n      intro i hi\n      simp_rw [sets_s', dif_pos hi]\n    have h_sets_s'_univ : ∀ {i} (hi : i ∈ T), sets_s' i = Set.univ :=\n      by\n      intro i hi\n      simp_rw [sets_s', dif_neg (finset.disjoint_right.mp hST hi)]\n    let sets_t' : ∀ i : ι, set (β i) := fun i => dite (i ∈ T) (fun hi => sets_t ⟨i, hi⟩) fun _ => Set.univ\n    have h_sets_t'_univ : ∀ {i} (hi : i ∈ S), sets_t' i = Set.univ :=\n      by\n      intro i hi\n      simp_rw [sets_t', dif_neg (finset.disjoint_left.mp hST hi)]\n    have h_meas_s' : ∀ i ∈ S, measurable_set (sets_s' i) :=\n      by\n      intro i hi\n      rw [h_sets_s'_eq hi]\n      exact hs1 _\n    have h_meas_t' : ∀ i ∈ T, measurable_set (sets_t' i) :=\n      by\n      intro i hi\n      simp_rw [sets_t', dif_pos hi]\n      exact ht1 _\n    have h_eq_inter_S :\n      «expr ⁻¹' » (fun (ω : Ω) (i : «expr↥ » S) => f (↑i) ω) (Set.pi Set.univ sets_s) =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ⁻¹' » (f i) (sets_s' i)) :=\n      by\n      ext1 x\n      simp only [Set.mem_preimage, Set.mem_univ_pi, Set.mem_interᵢ]\n      constructor <;> intro h\n      · intro i hi\n        rw [h_sets_s'_eq hi]\n        exact h ⟨i, hi⟩\n      · rintro ⟨i, hi⟩\n        specialize h i hi\n        rw [h_sets_s'_eq hi] at h\n        exact h\n    have h_eq_inter_T :\n      «expr ⁻¹' » (fun (ω : Ω) (i : «expr↥ » T) => f (↑i) ω) (Set.pi Set.univ sets_t) =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ⁻¹' » (f i) (sets_t' i)) :=\n      by\n      ext1 x\n      simp only [Set.mem_preimage, Set.mem_univ_pi, Set.mem_interᵢ]\n      constructor <;> intro h\n      · intro i hi\n        simp_rw [sets_t', dif_pos hi]\n        exact h ⟨i, hi⟩\n      · rintro ⟨i, hi⟩\n        specialize h i hi\n        simp_rw [sets_t', dif_pos hi] at h\n        exact h\n    rw [Indep_fun_iff_measure_inter_preimage_eq_mul] at hf_Indep\n    rw [h_eq_inter_S, h_eq_inter_T, hf_Indep S h_meas_s', hf_Indep T h_meas_t']\n    have h_Inter_inter :\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            («expr ⁻¹' » (f i) (sets_s' i)) ∩\n          «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            («expr ⁻¹' » (f i) (sets_t' i)) =\n        «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n          («expr ⁻¹' » (f i) (sets_s' i ∩ sets_t' i)) :=\n      by\n      ext1 x\n      simp only [Set.mem_inter_iff, Set.mem_interᵢ, Set.mem_preimage, Finset.mem_union]\n      constructor <;> intro h\n      · intro i hi\n        cases hi\n        · rw [h_sets_t'_univ hi]\n          exact ⟨h.1 i hi, Set.mem_univ _⟩\n        · rw [h_sets_s'_univ hi]\n          exact ⟨Set.mem_univ _, h.2 i hi⟩\n      · exact ⟨fun i hi => (h i (or.inl hi)).1, fun i hi => (h i (or.inr hi)).2⟩\n    rw [h_Inter_inter, hf_Indep (S ∪ T)]\n    swap\n    · intro i hi_mem\n      rw [Finset.mem_union] at hi_mem\n      cases hi_mem\n      · rw [h_sets_t'_univ hi_mem, Set.inter_univ]\n        exact h_meas_s' i hi_mem\n      · rw [h_sets_s'_univ hi_mem, Set.univ_inter]\n        exact h_meas_t' i hi_mem\n    rw [finset.prod_union hST]\n    congr 1\n    · refine' finset.prod_congr rfl fun i hi => _\n      rw [h_sets_t'_univ hi, Set.inter_univ]\n    · refine' finset.prod_congr rfl fun i hi => _\n      rw [h_sets_s'_univ hi, Set.univ_inter]\n#align Indep_fun.indep_fun_finset Indep_fun.indep_fun_finset\n\n",
 "indep_fun":
 "theorem Indep_fun.indep_fun {m₀ : measurable_space Ω} {μ : measure Ω} {β : ι → Type _} {m : ∀ x, measurable_space (β x)}\n    {f : ∀ i, Ω → β i} (hf_Indep : Indep_fun m f μ) {i j : ι} (hij : i ≠ j) : indep_fun (f i) (f j) μ :=\n  hf_Indep.indep hij\n#align Indep_fun.indep_fun Indep_fun.indep_fun\n\n",
 "indep_bsupr_limsup":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:72:18: unsupported non-interactive tactic filter.is_bounded_default -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_bsupr_limsup (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) (hf : ∀ t, p t → «expr ᶜ» t ∈ f) {t : set ι}\n    (ht : p t) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n))\n      (limsup s f) μ :=\n  by\n  refine' indep_of_indep_of_le_right (indep_bsupr_compl h_le h_indep t) _\n  refine'\n    Limsup_le_of_le\n      (by\n        run_tac\n          is_bounded_default)\n      _\n  simp only [Set.mem_compl_iff, eventually_map]\n  exact eventually_of_mem (hf t ht) le_supᵢ₂\n#align indep_bsupr_limsup indep_bsupr_limsup\n\n",
 "indep_bsupr_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem indep_bsupr_compl (h_le : ∀ n, s n ≤ m0) (h_indep : Indep s μ) (t : set ι) :\n    indep («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n))\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (s n)) μ :=\n  indep_supr_of_disjoint h_le h_indep disjoint_compl_right\n#align indep_bsupr_compl indep_bsupr_compl\n\n",
 "indep_bot_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem indep_bot_right (m' : measurable_space Ω) {m : measurable_space Ω} {μ : measure Ω} [is_probability_measure μ] :\n    indep m' («expr⊥») μ := by\n  intro s t hs ht\n  rw [Set.mem_setOf_eq, measurable_space.measurable_set_bot_iff] at ht\n  cases ht\n  · rw [ht, Set.inter_empty, measure_empty, mul_zero]\n  · rw [ht, Set.inter_univ, measure_univ, mul_one]\n#align indep_bot_right indep_bot_right\n\n",
 "indep_bot_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem indep_bot_left (m' : measurable_space Ω) {m : measurable_space Ω} {μ : measure Ω} [is_probability_measure μ] :\n    indep («expr⊥») m' μ :=\n  (indep_bot_right m').symm\n#align indep_bot_left indep_bot_left\n\n",
 "indep_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprivate theorem indep_sets.indep_aux {m2 : measurable_space Ω} {m : measurable_space Ω} {μ : measure Ω}\n    [is_probability_measure μ] {p1 p2 : set (set Ω)} (h2 : m2 ≤ m) (hp2 : is_pi_system p2)\n    (hpm2 : m2 = generate_from p2) (hyp : indep_sets p1 p2 μ) {t1 t2 : set Ω} (ht1 : t1 ∈ p1)\n    (ht2m : (measurable_set_of m2) t2) : μ (t1 ∩ t2) = μ t1 * μ t2 :=\n  by\n  let μ_inter := μ.restrict t1\n  let ν := «expr • » (μ t1) μ\n  have h_univ : μ_inter Set.univ = ν Set.univ := by\n    rw [measure.restrict_apply_univ, measure.smul_apply, smul_eq_mul, measure_univ, mul_one]\n  haveI : is_finite_measure μ_inter := @restrict.is_finite_measure Ω _ t1 μ ⟨measure_lt_top μ t1⟩\n  rw [Set.inter_comm, ← measure.restrict_apply (h2 t2 ht2m)]\n  refine' ext_on_measurable_space_of_generate_finite m p2 (fun t ht => _) h2 hpm2 hp2 h_univ ht2m\n  have ht2 : (measurable_set_of m) t := by\n    refine' h2 _ _\n    rw [hpm2]\n    exact measurable_set_generate_from ht\n  rw [measure.restrict_apply ht2, measure.smul_apply, Set.inter_comm]\n  exact hyp t1 t ht1 ht\n#align indep_sets.indep_aux indep_sets.indep_aux\n\n",
 "indep'":
 "theorem indep_sets.indep' {m : measurable_space Ω} {μ : measure Ω} [is_probability_measure μ] {p1 p2 : set (set Ω)}\n    (hp1m : ∀ s ∈ p1, measurable_set s) (hp2m : ∀ s ∈ p2, measurable_set s) (hp1 : is_pi_system p1)\n    (hp2 : is_pi_system p2) (hyp : indep_sets p1 p2 μ) : indep (generate_from p1) (generate_from p2) μ :=\n  hyp.indep (generate_from_le hp1m) (generate_from_le hp2m) hp1 hp2 rfl rfl\n#align indep_sets.indep' indep_sets.indep'\n\n",
 "indep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem indep_sets.indep {m1 m2 : measurable_space Ω} {m : measurable_space Ω} {μ : measure Ω}\n    [is_probability_measure μ] {p1 p2 : set (set Ω)} (h1 : m1 ≤ m) (h2 : m2 ≤ m) (hp1 : is_pi_system p1)\n    (hp2 : is_pi_system p2) (hpm1 : m1 = generate_from p1) (hpm2 : m2 = generate_from p2) (hyp : indep_sets p1 p2 μ) :\n    indep m1 m2 μ := by\n  intro t1 t2 ht1 ht2\n  let μ_inter := μ.restrict t2\n  let ν := «expr • » (μ t2) μ\n  have h_univ : μ_inter Set.univ = ν Set.univ := by\n    rw [measure.restrict_apply_univ, measure.smul_apply, smul_eq_mul, measure_univ, mul_one]\n  haveI : is_finite_measure μ_inter := @restrict.is_finite_measure Ω _ t2 μ ⟨measure_lt_top μ t2⟩\n  rw [mul_comm, ← measure.restrict_apply (h1 t1 ht1)]\n  refine' ext_on_measurable_space_of_generate_finite m p1 (fun t ht => _) h1 hpm1 hp1 h_univ ht1\n  have ht1 : (measurable_set_of m) t := by\n    refine' h1 _ _\n    rw [hpm1]\n    exact measurable_set_generate_from ht\n  rw [measure.restrict_apply ht1, measure.smul_apply, smul_eq_mul, mul_comm]\n  exact indep_sets.indep_aux h2 hp2 hpm2 hyp ht ht2\n#align indep_sets.indep indep_sets.indep\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem indep_fun.comp {mβ : measurable_space β} {mβ' : measurable_space β'} {mγ : measurable_space γ}\n    {mγ' : measurable_space γ'} {φ : β → γ} {ψ : β' → γ'} (hfg : indep_fun f g μ) (hφ : measurable φ)\n    (hψ : measurable ψ) : indep_fun (φ ∘ f) (ψ ∘ g) μ :=\n  by\n  rintro _ _ ⟨A, hA, rfl⟩ ⟨B, hB, rfl⟩\n  apply hfg\n  · exact ⟨«expr ⁻¹' » φ A, hφ hA, set.preimage_comp.symm⟩\n  · exact ⟨«expr ⁻¹' » ψ B, hψ hB, set.preimage_comp.symm⟩\n#align indep_fun.comp indep_fun.comp\n\n",
 "bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem indep_sets.bUnion [measurable_space Ω] {s : ι → set (set Ω)} {s' : set (set Ω)} {μ : measure Ω} {u : set ι}\n    (hyp : ∀ n ∈ u, indep_sets (s n) s' μ) :\n    indep_sets («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n))\n      s' μ :=\n  by\n  intro t1 t2 ht1 ht2\n  simp_rw [Set.mem_unionᵢ] at ht1\n  rcases ht1 with ⟨n, hpn, ht1⟩\n  exact hyp n hpn t1 t2 ht1 ht2\n#align indep_sets.bUnion indep_sets.bUnion\n\n",
 "bInter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem indep_sets.bInter [measurable_space Ω] {s : ι → set (set Ω)} {s' : set (set Ω)} {μ : measure Ω} {u : set ι}\n    (h : ∃ n ∈ u, indep_sets (s n) s' μ) :\n    indep_sets («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s n))\n      s' μ :=\n  by\n  intro t1 t2 ht1 ht2\n  rcases h with ⟨n, hn, h⟩\n  exact h t1 t2 (Set.binterᵢ_subset_of_mem hn ht1) ht2\n#align indep_sets.bInter indep_sets.bInter\n\n",
 "ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem indep_fun.ae_eq {mβ : measurable_space β} {f g f' g' : Ω → β} (hfg : indep_fun f g μ)\n    (hf : «expr =ᵐ[ ] » f μ f') (hg : «expr =ᵐ[ ] » g μ g') : indep_fun f' g' μ :=\n  by\n  rintro _ _ ⟨A, hA, rfl⟩ ⟨B, hB, rfl⟩\n  have h1 : «expr =ᵐ[ ] » («expr ⁻¹' » f A) μ («expr ⁻¹' » f' A) := hf.fun_comp A\n  have h2 : «expr =ᵐ[ ] » («expr ⁻¹' » g B) μ («expr ⁻¹' » g' B) := hg.fun_comp B\n  rw [← measure_congr h1, ← measure_congr h2, ← measure_congr (h1.inter h2)]\n  exact hfg _ _ ⟨_, hA, rfl⟩ ⟨_, hB, rfl⟩\n#align indep_fun.ae_eq indep_fun.ae_eq\n\n",
 "Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem indep_sets.Union [measurable_space Ω] {s : ι → set (set Ω)} {s' : set (set Ω)} {μ : measure Ω}\n    (hyp : ∀ n, indep_sets (s n) s' μ) :\n    indep_sets («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s n))\n      s' μ :=\n  by\n  intro t1 t2 ht1 ht2\n  rw [Set.mem_unionᵢ] at ht1\n  cases' ht1 with n ht1\n  exact hyp n t1 t2 ht1 ht2\n#align indep_sets.Union indep_sets.Union\n\n",
 "Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\ntheorem indep_sets.Inter [measurable_space Ω] {s : ι → set (set Ω)} {s' : set (set Ω)} {μ : measure Ω}\n    (h : ∃ n, indep_sets (s n) s' μ) :\n    indep_sets («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s n))\n      s' μ :=\n  by\n  intro t1 t2 ht1 ht2\n  cases' h with n h\n  exact h t1 t2 (set.mem_Inter.mp ht1 n) ht2\n#align indep_sets.Inter indep_sets.Inter\n\n",
 "Indep_sets":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem Indep.Indep_sets [measurable_space Ω] {μ : measure Ω} {m : ι → measurable_space Ω} {s : ι → set (set Ω)}\n    (hms : ∀ n, m n = generate_from (s n)) (h_indep : Indep m μ) : Indep_sets s μ := fun S f hfs =>\n  h_indep S fun x hxS => ((hms x).symm ▸ measurable_set_generate_from (hfs x hxS) : (measurable_set_of (m x)) (f x))\n#align Indep.Indep_sets Indep.Indep_sets\n\n",
 "Indep_fun_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem Indep_set.Indep_fun_indicator [Zero β] [One β] {m : measurable_space β} {s : ι → set Ω} (hs : Indep_set s μ) :\n    Indep_fun (fun n => m) (fun n => (s n).indicator fun ω => 1) μ := by\n  classical\n    rw [Indep_fun_iff_measure_inter_preimage_eq_mul]\n    rintro S π hπ\n    simp_rw [set.indicator_const_preimage_eq_union]\n    refine' @hs S (fun i => ite (1 ∈ π i) (s i) ∅ ∪ ite ((0 : β) ∈ π i) («expr ᶜ» (s i)) ∅) fun i hi => _\n    have hsi : (measurable_set_of (generate_from {s i})) (s i) := measurable_set_generate_from (Set.mem_singleton _)\n    refine'\n      measurable_set.union (measurable_set.ite' (fun _ => hsi) fun _ => _)\n        (measurable_set.ite' (fun _ => hsi.compl) fun _ => _)\n    · exact @measurable_set.empty _ (generate_from {s i})\n    · exact @measurable_set.empty _ (generate_from {s i})\n#align Indep_set.Indep_fun_indicator Indep_set.Indep_fun_indicator\n\n",
 "Indep_fun_iff_measure_inter_preimage_eq_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem Indep_fun_iff_measure_inter_preimage_eq_mul {ι : Type _} {β : ι → Type _} (m : ∀ x, measurable_space (β x))\n    (f : ∀ i, Ω → β i) :\n    Indep_fun m f μ ↔\n      ∀ (S : Finset ι) {sets : ∀ i : ι, set (β i)} (H : ∀ i, i ∈ S → (measurable_set_of (m i)) (sets i)),\n        μ\n            («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n              («expr ⁻¹' » (f i) (sets i))) =\n          finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S\n            (μ («expr ⁻¹' » (f i) (sets i))) :=\n  by\n  refine' ⟨fun h S sets h_meas => h _ fun i hi_mem => ⟨sets i, h_meas i hi_mem, rfl⟩, _⟩\n  intro h S setsΩ h_meas\n  classical\n    let setsβ : ∀ i : ι, set (β i) := fun i => dite (i ∈ S) (fun hi_mem => (h_meas i hi_mem).some) fun _ => Set.univ\n    have h_measβ : ∀ i ∈ S, (measurable_set_of (m i)) (setsβ i) :=\n      by\n      intro i hi_mem\n      simp_rw [setsβ, dif_pos hi_mem]\n      exact (h_meas i hi_mem).some_spec.1\n    have h_preim : ∀ i ∈ S, setsΩ i = «expr ⁻¹' » (f i) (setsβ i) :=\n      by\n      intro i hi_mem\n      simp_rw [setsβ, dif_pos hi_mem]\n      exact (h_meas i hi_mem).some_spec.2.symm\n    have h_left_eq :\n      μ («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (setsΩ i)) =\n        μ\n          («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\"\n            («expr ⁻¹' » (f i) (setsβ i))) :=\n      by\n      congr with (i x)\n      simp only [Set.mem_interᵢ]\n      constructor <;> intro h hi_mem <;> specialize h hi_mem\n      · rwa [h_preim i hi_mem] at h\n      · rwa [h_preim i hi_mem]\n    have h_right_eq :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S\n          (μ (setsΩ i)) =\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" S\n          (μ («expr ⁻¹' » (f i) (setsβ i))) :=\n      by\n      refine' finset.prod_congr rfl fun i hi_mem => _\n      rw [h_preim i hi_mem]\n    rw [h_left_eq, h_right_eq]\n    exact h S h_measβ\n#align Indep_fun_iff_measure_inter_preimage_eq_mul Indep_fun_iff_measure_inter_preimage_eq_mul\n\n",
 "Indep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- The measurable space structures generated by independent pi-systems are independent. -/\ntheorem Indep_sets.Indep [is_probability_measure μ] (m : ι → measurable_space Ω) (h_le : ∀ i, m i ≤ m0)\n    (π : ι → set (set Ω)) (h_pi : ∀ n, is_pi_system (π n)) (h_generate : ∀ i, m i = generate_from (π i))\n    (h_ind : Indep_sets π μ) : Indep m μ := by\n  classical\n    refine' Finset.induction _ _\n    · simp only [measure_univ, imp_true_iff, Set.interᵢ_false, Set.interᵢ_univ, finset.prod_empty, eq_self_iff_true]\n    intro a S ha_notin_S h_rec f hf_m\n    have hf_m_S : ∀ x ∈ S, (measurable_set_of (m x)) (f x) := fun x hx => hf_m x (by simp [hx])\n    rw [finset.set_bInter_insert, finset.prod_insert ha_notin_S, ← h_rec hf_m_S]\n    let p := pi_Union_Inter π S\n    set m_p := generate_from p with hS_eq_generate\n    have h_indep : indep m_p (m a) μ :=\n      by\n      have hp : is_pi_system p := is_pi_system_pi_Union_Inter π h_pi S\n      have h_le' : ∀ i, generate_from (π i) ≤ m0 := fun i => (h_generate i).symm.trans_le (h_le i)\n      have hm_p : m_p ≤ m0 := generate_from_pi_Union_Inter_le π h_le' S\n      exact\n        indep_sets.indep hm_p (h_le a) hp (h_pi a) hS_eq_generate (h_generate a)\n          (h_ind.pi_Union_Inter_of_not_mem ha_notin_S)\n    refine'\n      h_indep.symm (f a)\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (f n))\n        (hf_m a (Finset.mem_insert_self a S)) _\n    have h_le_p : ∀ i ∈ S, m i ≤ m_p := by\n      intro n hn\n      rw [hS_eq_generate, h_generate n]\n      exact le_generate_from_pi_Union_Inter S hn\n    have h_S_f : ∀ i ∈ S, (measurable_set_of m_p) (f i) := fun i hi => (h_le_p i hi) (f i) (hf_m_S i hi)\n    exact S.measurable_set_bInter h_S_f\n#align Indep_sets.Indep Indep_sets.Indep\n\n"}