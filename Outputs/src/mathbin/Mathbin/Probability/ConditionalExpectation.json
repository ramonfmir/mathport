{"condexp_indep_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n/-- If `m₁, m₂` are independent σ-algebras and `f` is `m₁`-measurable, then `𝔼[f | m₂] = 𝔼[f]`\nalmost everywhere. -/\ntheorem condexp_indep_eq (hle₁ : m₁ ≤ m) (hle₂ : m₂ ≤ m) [sigma_finite (μ.trim hle₂)]\n    (hf : (strongly_measurable_of m₁) f) (hindp : indep m₁ m₂ μ) :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ f m₂) μ fun x => condexp.probability μ f :=\n  by\n  by_cases hfint : integrable f μ\n  swap;\n  · rw [condexp_undef hfint, integral_undef hfint]\n    rfl\n  have hfint₁ := hfint.trim hle₁ hf\n  refine'\n    (ae_eq_condexp_of_forall_set_integral_eq hle₂ hfint (fun s _ hs => integrable_on_const.2 (or.inr hs))\n        (fun s hms hs => _) strongly_measurable_const.ae_strongly_measurable').symm\n  rw [set_integral_const]\n  rw [← mem_ℒp_one_iff_integrable] at hfint\n  refine' hfint.induction_strongly_measurable hle₁ ennreal.one_ne_top _ _ _ _ _ _\n  · intro c t hmt ht\n    rw [integral_indicator (hle₁ _ hmt), set_integral_const, smul_smul, ← ennreal.to_real_mul, mul_comm, ←\n      hindp _ _ hmt hms, set_integral_indicator (hle₁ _ hmt), set_integral_const, Set.inter_comm]\n  · intro u v hdisj huint hvint hu hv hu_eq hv_eq\n    rw [mem_ℒp_one_iff_integrable] at huint hvint\n    rw [integral_add' huint hvint, smul_add, hu_eq, hv_eq, integral_add' huint.integrable_on hvint.integrable_on]\n  · have heq₁ :\n      (fun f : Lp_meas E (exprℝ) m₁ 1 μ =>\n          «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x) μ) =\n        (fun f : Lp E 1 μ =>\n            «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f x)\n              μ) ∘\n          submodule.subtypeL _ :=\n      by\n      refine' funext fun f => integral_congr_ae _\n      simp_rw [submodule.coe_subtypeL', submodule.coe_subtype, ← coe_fn_coe_base]\n    have heq₂ :\n      (fun f : Lp_meas E (exprℝ) m₁ 1 μ =>\n          «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n            (f x) μ) =\n        (fun f : Lp E 1 μ =>\n            «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n              (f x) μ) ∘\n          submodule.subtypeL _ :=\n      by\n      refine' funext fun f => integral_congr_ae (ae_restrict_of_ae _)\n      simp_rw [submodule.coe_subtypeL', submodule.coe_subtype, ← coe_fn_coe_base]\n      exact eventually_of_forall fun _ => rfl\n    refine' is_closed_eq (continuous.const_smul _ _) _\n    · rw [heq₁]\n      exact continuous_integral.comp (continuous_linear_map.continuous _)\n    · rw [heq₂]\n      exact (continuous_set_integral _).comp (continuous_linear_map.continuous _)\n  · intro u v huv huint hueq\n    rwa [← integral_congr_ae huv, ←\n      (set_integral_congr_ae (hle₂ _ hms) _ :\n        «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n            (u x) μ =\n          «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n            (v x) μ)]\n    filter_upwards [huv] with x hx _ using hx\n  · exact ⟨f, hf, eventually_eq.rfl⟩\n#align condexp_indep_eq condexp_indep_eq\n\n"}