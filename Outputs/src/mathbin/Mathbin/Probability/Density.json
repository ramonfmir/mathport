{"to_quasi_measure_preserving":
 "/-- A random variable that `has_pdf` is quasi-measure preserving. -/\ntheorem to_quasi_measure_preserving {X : Ω → E} [has_pdf X ℙ μ] : QuasiMeasurePreserving X ℙ μ :=\n  { measurable := has_pdf.measurable X ℙ μ\n    absolutely_continuous := map_absolutely_continuous }\n#align to_quasi_measure_preserving to_quasi_measure_preserving\n\n",
 "quasi_measure_preserving_has_pdf'":
 "theorem quasi_measure_preserving_has_pdf' [FiniteMeasure ℙ] [SigmaFinite ν] {X : Ω → E} [has_pdf X ℙ μ] {g : E → F}\n    (hg : QuasiMeasurePreserving g μ ν) : has_pdf (g ∘ X) ℙ ν :=\n  quasi_measure_preserving_has_pdf hg inferInstance\n#align quasi_measure_preserving_has_pdf' quasi_measure_preserving_has_pdf'\n\n",
 "quasi_measure_preserving_has_pdf":
 "/-- A random variable that `has_pdf` transformed under a `quasi_measure_preserving`\nmap also `has_pdf` if `(map g (map X ℙ)).have_lebesgue_decomposition μ`.\n\n`quasi_measure_preserving_has_pdf'` is more useful in the case we are working with a\nprobability measure and a real-valued random variable. -/\ntheorem quasi_measure_preserving_has_pdf {X : Ω → E} [has_pdf X ℙ μ] {g : E → F} (hg : QuasiMeasurePreserving g μ ν)\n    (hmap : (map g (map X ℙ)).have_lebesgue_decomposition ν) : has_pdf (g ∘ X) ℙ ν :=\n  by\n  rw [has_pdf_iff, ← map_map hg.measurable (has_pdf.measurable X ℙ μ)]\n  refine' ⟨hg.measurable.comp (has_pdf.measurable X ℙ μ), hmap, _⟩\n  rw [map_eq_with_density_pdf X ℙ μ]\n  refine' absolutely_continuous.mk fun s hsm hs => _\n  rw [map_apply hg.measurable hsm, with_density_apply _ (hg.measurable hsm)]\n  have := hg.absolutely_continuous hs\n  rw [map_apply hg.measurable hsm] at this\n  exact set_lintegral_measure_zero _ _ this\n#align quasi_measure_preserving_has_pdf quasi_measure_preserving_has_pdf\n\n",
 "pdf_undef":
 "theorem pdf_undef {m : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E} {X : Ω → E} (h : ¬has_pdf X ℙ μ) :\n    pdf X ℙ μ = 0 := by simp only [pdf, dif_neg h]\n#align pdf_undef pdf_undef\n\n",
 "pdf_to_real_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\ntheorem pdf_to_real_ae_eq {m : MeasurableSpace Ω} {X : Ω → E} {ℙ : Measure Ω} {μ : Measure E} {s : Set E}\n    (hX : is_uniform X s ℙ μ) :\n    «expr =ᵐ[ ] » (fun x => (pdf X ℙ μ x).to_real) μ fun x =>\n      (s.indicator («expr • » (μ s)⁻¹ (1 : E → ennreal)) x).to_real :=\n  Filter.EventuallyEq.fun_comp hX ENNReal.toReal\n#align pdf_to_real_ae_eq pdf_to_real_ae_eq\n\n",
 "pdf_eq_zero_of_not_measurable":
 "theorem pdf_eq_zero_of_not_measurable {m : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E} {X : Ω → E}\n    (hX : ¬Measurable X) : pdf X ℙ μ = 0 :=\n  pdf_undef fun hpdf => hX hpdf.pdf'.1\n#align pdf_eq_zero_of_not_measurable pdf_eq_zero_of_not_measurable\n\n",
 "of_real_to_real_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem of_real_to_real_ae_eq [FiniteMeasure ℙ] {X : Ω → E} :\n    «expr =ᵐ[ ] » (fun x => ENNReal.ofReal (pdf X ℙ μ x).to_real) μ (pdf X ℙ μ) :=\n  of_real_to_real_ae_eq ae_lt_top\n#align of_real_to_real_ae_eq of_real_to_real_ae_eq\n\n",
 "mul_pdf_integrable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem mul_pdf_integrable [FiniteMeasure ℙ] (hcs : IsCompact s) (huX : is_uniform X s ℙ) :\n    integrable fun x : exprℝ => x * (pdf X ℙ volume x).to_real :=\n  by\n  by_cases hsupp : volume s = ennreal.top\n  · have : «expr =ᵐ[ ] » (pdf X ℙ) volume 0 := by\n      refine' ae_eq_trans huX _\n      simp [hsupp]\n    refine' integrable.congr (integrable_zero _ _ _) _\n    rw [(by simp : (fun x => 0 : exprℝ → exprℝ) = fun x => x * (0 : ennreal).to_real)]\n    refine' Filter.EventuallyEq.mul (ae_eq_refl _) (Filter.EventuallyEq.fun_comp this.symm ENNReal.toReal)\n  refine' ⟨ae_strongly_measurable_id.mul (measurable_pdf X ℙ).ae_measurable.ennreal_to_real.ae_strongly_measurable, _⟩\n  refine' has_finite_integral_mul huX _\n  set ind := «expr • » (volume s)⁻¹ (1 : exprℝ → ennreal) with hind\n  have : ∀ x, ↑(«expr‖ ‖₊» x) * s.indicator ind x = s.indicator (fun x => «expr‖ ‖₊» x * ind x) x := fun x =>\n    (s.indicator_mul_right (fun x => ↑(«expr‖ ‖₊» x)) ind).symm\n  simp only [this, lintegral_indicator _ hms, hind, mul_one, Algebra.id.smul_eq_mul, Pi.one_apply, Pi.smul_apply]\n  rw [lintegral_mul_const _ measurable_nnnorm.coe_nnreal_ennreal]\n  ·\n    refine'\n      (ENNReal.mul_lt_top (set_lintegral_lt_top_of_is_compact hsupp hcs continuous_nnnorm).ne\n          (ENNReal.inv_lt_top.2 (pos_iff_ne_zero.mpr hns)).ne).ne\n  · infer_instance\n#align mul_pdf_integrable mul_pdf_integrable\n\n",
 "measure_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem measure_preimage {m : MeasurableSpace Ω} {X : Ω → E} {ℙ : Measure Ω} {μ : Measure E} {s : Set E} (hns : μ s ≠ 0)\n    (hnt : μ s ≠ ennreal.top) (hms : MeasurableSet s) (hu : is_uniform X s ℙ μ) {A : Set E} (hA : MeasurableSet A) :\n    ℙ («expr ⁻¹' » X A) = μ (s ∩ A) / μ s := by\n  haveI := hu.has_pdf hns hnt\n  rw [← measure.map_apply (has_pdf.measurable X ℙ μ) hA, map_eq_set_lintegral_pdf X ℙ μ hA,\n    lintegral_congr_ae hu.restrict]\n  simp only [hms, hA, lintegral_indicator, Pi.smul_apply, Pi.one_apply, Algebra.id.smul_eq_mul, mul_one,\n    lintegral_const, restrict_apply', Set.univ_inter]\n  rw [ENNReal.div_eq_inv_mul]\n#align measure_preimage measure_preimage\n\n",
 "measurable_pdf":
 "@[measurability]\ntheorem measurable_pdf {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by exact measure_theory.measure_space.volume) : Measurable (pdf X ℙ μ) :=\n  by\n  by_cases hX : has_pdf X ℙ μ\n  · rw [pdf, dif_pos hX]\n    exact (Classical.choose_spec hX.pdf'.2).1\n  · rw [pdf, dif_neg hX]\n    exact measurable_zero\n#align measurable_pdf measurable_pdf\n\n",
 "measurable_of_pdf_ne_zero":
 "theorem measurable_of_pdf_ne_zero {m : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E} (X : Ω → E)\n    (h : pdf X ℙ μ ≠ 0) : Measurable X := by\n  by_contra hX\n  exact h (pdf_eq_zero_of_not_measurable hX)\n#align measurable_of_pdf_ne_zero measurable_of_pdf_ne_zero\n\n",
 "measurable":
 "/-\nCopyright (c) 2021 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n@[measurability]\ntheorem has_pdf.measurable {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by exact measure_theory.measure_space.volume) [hX : has_pdf X ℙ μ] : Measurable X :=\n  hX.pdf'.1\n#align has_pdf.measurable has_pdf.measurable\n\n",
 "map_eq_with_density_pdf":
 "theorem map_eq_with_density_pdf {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by exact measure_theory.measure_space.volume) [hX : has_pdf X ℙ μ] :\n    Measure.map X ℙ = μ.with_density (pdf X ℙ μ) :=\n  by\n  rw [pdf, dif_pos hX]\n  exact (Classical.choose_spec hX.pdf'.2).2\n#align map_eq_with_density_pdf map_eq_with_density_pdf\n\n",
 "map_eq_set_lintegral_pdf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ » -/\ntheorem map_eq_set_lintegral_pdf {m : MeasurableSpace Ω} (X : Ω → E) (ℙ : Measure Ω)\n    (μ : Measure E := by exact measure_theory.measure_space.volume) [hX : has_pdf X ℙ μ] {s : Set E}\n    (hs : MeasurableSet s) :\n    Measure.map X ℙ s =\n      «expr∫⁻ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ in , ∂ »\" s\n        (pdf X ℙ μ x) μ :=\n  by rw [← with_density_apply _ hs, map_eq_with_density_pdf X ℙ μ]\n#align map_eq_set_lintegral_pdf map_eq_set_lintegral_pdf\n\n",
 "map_absolutely_continuous":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem map_absolutely_continuous {X : Ω → E} [has_pdf X ℙ μ] : measure.absolutely_continuous (map X ℙ) μ :=\n  by\n  rw [map_eq_with_density_pdf X ℙ μ]\n  exact with_density_absolutely_continuous _ _\n#align map_absolutely_continuous map_absolutely_continuous\n\n",
 "lintegral_eq_measure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ » -/\ntheorem lintegral_eq_measure_univ {X : Ω → E} [has_pdf X ℙ μ] :\n    «expr∫⁻ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , ∂ »\" (pdf X ℙ μ x)\n        μ =\n      ℙ Set.univ :=\n  by\n  rw [← set_lintegral_univ, ← map_eq_set_lintegral_pdf X ℙ μ MeasurableSet.univ,\n    measure.map_apply (has_pdf.measurable X ℙ μ) MeasurableSet.univ, Set.preimage_univ]\n#align lintegral_eq_measure_univ lintegral_eq_measure_univ\n\n",
 "is_probability_measure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem is_probability_measure {m : MeasurableSpace Ω} {X : Ω → E} {ℙ : Measure Ω} {μ : Measure E} {s : Set E}\n    (hns : μ s ≠ 0) (hnt : μ s ≠ ennreal.top) (hms : MeasurableSet s) (hu : is_uniform X s ℙ μ) :\n    ProbabilityMeasure ℙ :=\n  ⟨by\n    have : «expr ⁻¹' » X Set.univ = Set.univ := by simp only [Set.preimage_univ]\n    rw [← this, hu.measure_preimage hns hnt hms MeasurableSet.univ, Set.inter_univ, ENNReal.div_self hns hnt]⟩\n#align is_probability_measure is_probability_measure\n\n",
 "integral_mul_eq_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- If `X` is a real-valued random variable that has pdf `f`, then the expectation of `X` equals\n`∫ x, x * f x ∂λ` where `λ` is the Lebesgue measure. -/\ntheorem integral_mul_eq_integral [has_pdf X ℙ] :\n    «expr∫ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , »\"\n        (x * (pdf X ℙ volume x).to_real) =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (X x) ℙ :=\n  integral_fun_mul_eq_integral measurable_id\n#align integral_mul_eq_integral integral_mul_eq_integral\n\n",
 "integral_fun_mul_eq_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/-- **The Law of the Unconscious Statistician**: Given a random variable `X` and a measurable\nfunction `f`, `f ∘ X` is a random variable with expectation `∫ x, f x * pdf X ∂μ`\nwhere `μ` is a measure on the codomain of `X`. -/\ntheorem integral_fun_mul_eq_integral [FiniteMeasure ℙ] {X : Ω → E} [has_pdf X ℙ μ] {f : E → exprℝ} (hf : Measurable f) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n        (f x * (pdf X ℙ μ x).to_real) μ =\n      «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f (X x)) ℙ :=\n  by\n  by_cases hpdf : integrable (fun x => f x * (pdf X ℙ μ x).to_real) μ\n  · rw [← integral_map (has_pdf.measurable X ℙ μ).ae_measurable hf.ae_strongly_measurable,\n      map_eq_with_density_pdf X ℙ μ, integral_eq_lintegral_pos_part_sub_lintegral_neg_part hpdf,\n      integral_eq_lintegral_pos_part_sub_lintegral_neg_part,\n      lintegral_with_density_eq_lintegral_mul _ (measurable_pdf X ℙ μ) hf.neg.ennreal_of_real,\n      lintegral_with_density_eq_lintegral_mul _ (measurable_pdf X ℙ μ) hf.ennreal_of_real]\n    · congr 2\n      · have :\n          ∀ x,\n            ENNReal.ofReal (f x * (pdf X ℙ μ x).to_real) =\n              ENNReal.ofReal (pdf X ℙ μ x).to_real * ENNReal.ofReal (f x) :=\n          by\n          intro x\n          rw [mul_comm, ENNReal.ofReal_mul ENNReal.toReal_nonneg]\n        simp_rw [this]\n        exact lintegral_congr_ae (Filter.EventuallyEq.mul of_real_to_real_ae_eq (ae_eq_refl _))\n      · have :\n          ∀ x,\n            ENNReal.ofReal (-(f x * (pdf X ℙ μ x).to_real)) =\n              ENNReal.ofReal (pdf X ℙ μ x).to_real * ENNReal.ofReal (-f x) :=\n          by\n          intro x\n          rw [neg_mul_eq_neg_mul, mul_comm, ENNReal.ofReal_mul ENNReal.toReal_nonneg]\n        simp_rw [this]\n        exact lintegral_congr_ae (Filter.EventuallyEq.mul of_real_to_real_ae_eq (ae_eq_refl _))\n    · refine' ⟨hf.ae_strongly_measurable, _⟩\n      rw [has_finite_integral,\n        lintegral_with_density_eq_lintegral_mul _ (measurable_pdf _ _ _) hf.nnnorm.coe_nnreal_ennreal]\n      have :\n        «expr =ᵐ[ ] » (fun x => (pdf X ℙ μ * fun x => ↑(«expr‖ ‖₊» (f x))) x) μ fun x =>\n          «expr‖ ‖₊» (f x * (pdf X ℙ μ x).to_real) :=\n        by\n        simp_rw [← smul_eq_mul, nnnorm_smul, ENNReal.coe_mul]\n        rw [smul_eq_mul, mul_comm]\n        refine' Filter.EventuallyEq.mul (ae_eq_refl _) (ae_eq_trans of_real_to_real_ae_eq.symm _)\n        convert ae_eq_refl _\n        ext1 x\n        exact Real.ennnorm_eq_ofReal ENNReal.toReal_nonneg\n      rw [lintegral_congr_ae this]\n      exact hpdf.2\n  · rw [integral_undef hpdf, integral_undef]\n    rwa [← integrable_iff_integrable_mul_pdf hf] at hpdf\n    all_goals infer_instance\n#align integral_fun_mul_eq_integral integral_fun_mul_eq_integral\n\n",
 "integral_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , » -/\n/-- A real uniform random variable `X` with support `s` has expectation\n`(λ s)⁻¹ * ∫ x in s, x ∂λ` where `λ` is the Lebesgue measure. -/\ntheorem integral_eq (hnt : volume s ≠ ennreal.top) (huX : is_uniform X s ℙ) :\n    «expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (X x) ℙ =\n      (volume s)⁻¹.to_real *\n        «expr∫ in , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , »\" s x :=\n  by\n  haveI := has_pdf hns hnt huX\n  haveI := huX.is_probability_measure hns hnt hms\n  rw [← integral_mul_eq_integral]\n  rw [integral_congr_ae (Filter.EventuallyEq.mul (ae_eq_refl _) (pdf_to_real_ae_eq huX))]\n  have :\n    ∀ x,\n      x * (s.indicator («expr • » (volume s)⁻¹ (1 : exprℝ → ennreal)) x).to_real =\n        x * s.indicator («expr • » (volume s)⁻¹.to_real (1 : exprℝ → exprℝ)) x :=\n    by\n    refine' fun x => congr_arg ((· * ·) x) _\n    by_cases hx : x ∈ s\n    · simp [Set.indicator_of_mem hx]\n    · simp [Set.indicator_of_not_mem hx]\n  simp_rw [this, ← s.indicator_mul_right fun x => x, integral_indicator hms]\n  change\n    «expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\" s\n        (x * «expr • » (volume s)⁻¹.to_real 1) volume =\n      _\n  rw [integral_mul_right, mul_comm, Algebra.id.smul_eq_mul, mul_one]\n#align integral_eq integral_eq\n\n",
 "integrable_iff_integrable_mul_pdf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem integrable_iff_integrable_mul_pdf [FiniteMeasure ℙ] {X : Ω → E} [has_pdf X ℙ μ] {f : E → exprℝ}\n    (hf : Measurable f) : integrable (fun x => f (X x)) ℙ ↔ integrable (fun x => f x * (pdf X ℙ μ x).to_real) μ :=\n  by\n  rw [← integrable_map_measure hf.ae_strongly_measurable (has_pdf.measurable X ℙ μ).ae_measurable,\n    map_eq_with_density_pdf X ℙ μ, integrable_with_density_iff (measurable_pdf _ _ _) ae_lt_top]\n  infer_instance\n#align integrable_iff_integrable_mul_pdf integrable_iff_integrable_mul_pdf\n\n",
 "have_lebesgue_decomposition_of_has_pdf":
 "theorem have_lebesgue_decomposition_of_has_pdf {X : Ω → E} [hX' : has_pdf X ℙ μ] :\n    (map X ℙ).have_lebesgue_decomposition μ :=\n  ⟨⟨⟨0, pdf X ℙ μ⟩, by\n      simp only [zero_add, measurable_pdf X ℙ μ, true_and_iff, mutually_singular.zero_left,\n        map_eq_with_density_pdf X ℙ μ]⟩⟩\n#align have_lebesgue_decomposition_of_has_pdf have_lebesgue_decomposition_of_has_pdf\n\n",
 "has_pdf_of_pdf_ne_zero":
 "theorem has_pdf_of_pdf_ne_zero {m : MeasurableSpace Ω} {ℙ : Measure Ω} {μ : Measure E} {X : Ω → E} (h : pdf X ℙ μ ≠ 0) :\n    has_pdf X ℙ μ := by\n  by_contra hpdf\n  rw [pdf, dif_neg hpdf] at h\n  exact hpdf (false.rec (has_pdf X ℙ μ) (h rfl))\n#align has_pdf_of_pdf_ne_zero has_pdf_of_pdf_ne_zero\n\n",
 "has_pdf_iff_of_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\n/-- A real-valued random variable `X` `has_pdf X ℙ λ` (where `λ` is the Lebesgue measure) if and\nonly if the push-forward measure of `ℙ` along `X` is absolutely continuous with respect to `λ`. -/\ntheorem real.has_pdf_iff_of_measurable (hX : Measurable X) :\n    has_pdf X ℙ ↔ measure.absolutely_continuous (map X ℙ) volume :=\n  by\n  rw [has_pdf_iff_of_measurable hX, and_iff_right_iff_imp]\n  exact fun h => inferInstance\n#align real.has_pdf_iff_of_measurable real.has_pdf_iff_of_measurable\n\n",
 "has_pdf_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure.absolutely_continuous -/\ntheorem real.has_pdf_iff : has_pdf X ℙ ↔ Measurable X ∧ measure.absolutely_continuous (map X ℙ) volume :=\n  by\n  by_cases hX : Measurable X\n  · rw [real.has_pdf_iff_of_measurable hX, iff_and_self]\n    exact fun h => hX\n    infer_instance\n  · exact ⟨fun h => false.elim (hX h.pdf'.1), fun h => false.elim (hX h.1)⟩\n#align real.has_pdf_iff real.has_pdf_iff\n\n",
 "has_pdf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem has_pdf {m : MeasurableSpace Ω} {X : Ω → E} {ℙ : Measure Ω} {μ : Measure E} {s : Set E} (hns : μ s ≠ 0)\n    (hnt : μ s ≠ ennreal.top) (hu : is_uniform X s ℙ μ) : has_pdf X ℙ μ :=\n  has_pdf_of_pdf_ne_zero\n    (by\n      intro hpdf\n      rw [is_uniform, hpdf] at hu\n      suffices μ (s ∩ Function.support («expr • » (μ s)⁻¹ 1)) = 0\n        by\n        have heq : Function.support («expr • » (μ s)⁻¹ (1 : E → ennreal)) = Set.univ :=\n          by\n          ext x\n          rw [Function.mem_support]\n          simp [hnt]\n        rw [HEq, Set.inter_univ] at this\n        exact hns this\n      exact MeasureTheory.Set.indicator_ae_eq_zero hu.symm)\n#align has_pdf has_pdf\n\n",
 "has_finite_integral_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫⁻ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr‖ ‖₊» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem has_finite_integral_mul {f : exprℝ → exprℝ} {g : exprℝ → ennreal} (hg : «expr =ᵐ[ ] » (pdf X ℙ) volume g)\n    (hgi :\n      «expr∫⁻ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫⁻ , »\"\n          («expr‖ ‖₊» (f x) * g x) ≠\n        ennreal.top) :\n    has_finite_integral fun x => f x * (pdf X ℙ volume x).to_real :=\n  by\n  rw [has_finite_integral]\n  have :\n    «expr =ᵐ[ ] » (fun x => ↑(«expr‖ ‖₊» (f x)) * g x) volume fun x => «expr‖ ‖₊» (f x * (pdf X ℙ volume x).to_real) :=\n    by\n    refine'\n      ae_eq_trans\n        (Filter.EventuallyEq.mul (ae_eq_refl fun x => «expr‖ ‖₊» (f x))\n          (ae_eq_trans hg.symm of_real_to_real_ae_eq.symm))\n        _\n    simp_rw [← smul_eq_mul, nnnorm_smul, ENNReal.coe_mul, smul_eq_mul]\n    refine' Filter.EventuallyEq.mul (ae_eq_refl _) _\n    convert ae_eq_refl _\n    ext1 x\n    exact Real.ennnorm_eq_ofReal ENNReal.toReal_nonneg\n  rwa [lt_top_iff_ne_top, ← lintegral_congr_ae this]\n#align has_finite_integral_mul has_finite_integral_mul\n\n",
 "ae_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem ae_lt_top [FiniteMeasure ℙ] {μ : Measure E} {X : Ω → E} :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (pdf X ℙ μ x < ennreal.top) :=\n  by\n  by_cases hpdf : has_pdf X ℙ μ\n  · haveI := hpdf\n    refine' ae_lt_top (measurable_pdf X ℙ μ) _\n    rw [lintegral_eq_measure_univ]\n    exact (measure_lt_top _ _).ne\n  · rw [pdf, dif_neg hpdf]\n    exact Filter.eventually_of_forall fun x => WithTop.zero_lt_top\n#align ae_lt_top ae_lt_top\n\n"}