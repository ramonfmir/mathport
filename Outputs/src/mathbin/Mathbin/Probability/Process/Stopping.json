{"strongly_measurable_stopped_value_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\ntheorem strongly_measurable_stopped_value_of_le (h : prog_measurable f u) (hτ : is_stopping_time f τ) {n : ι}\n    (hτ_le : ∀ ω, τ ω ≤ n) : (strongly_measurable_of (f n)) (stopped_value u τ) :=\n  by\n  have : stopped_value u τ = (fun p : Set.Iic n × Ω => u (↑p.fst) p.snd) ∘ fun ω => (⟨τ ω, hτ_le ω⟩, ω) :=\n    by\n    ext1 ω\n    simp only [stopped_value, Function.comp_apply, Subtype.coe_mk]\n  rw [this]\n  refine' strongly_measurable.comp_measurable (h n) _\n  exact (hτ.measurable_of_le hτ_le).subtype_mk.prod_mk measurable_id\n#align strongly_measurable_stopped_value_of_le strongly_measurable_stopped_value_of_le\n\n",
 "strongly_measurable_stopped_process_of_discrete":
 "theorem adapted.strongly_measurable_stopped_process_of_discrete [DiscreteTopology ι] (hu : adapted f u)\n    (hτ : is_stopping_time f τ) (n : ι) : strongly_measurable (stopped_process u τ n) :=\n  hu.prog_measurable_of_discrete.strongly_measurable_stopped_process hτ n\n#align adapted.strongly_measurable_stopped_process_of_discrete adapted.strongly_measurable_stopped_process_of_discrete\n\n",
 "strongly_measurable_stopped_process":
 "theorem adapted.strongly_measurable_stopped_process [metrizable_space ι] (hu : adapted f u)\n    (hu_cont : ∀ ω, Continuous fun i => u i ω) (hτ : is_stopping_time f τ) (n : ι) :\n    strongly_measurable (stopped_process u τ n) :=\n  (hu.prog_measurable_of_continuous hu_cont).strongly_measurable_stopped_process hτ n\n#align adapted.strongly_measurable_stopped_process adapted.strongly_measurable_stopped_process\n\n",
 "stopped_value_sub_eq_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_sub_eq_sum' [AddCommGroup β] (hle : τ ≤ π) {N : ℕ} (hbdd : ∀ ω, π ω ≤ N) :\n    stopped_value u π - stopped_value u τ = fun ω =>\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (N + 1)) (Set.indicator { ω | τ ω ≤ i ∧ i < π ω } (u (i + 1) - u i)))\n        ω :=\n  by\n  rw [stopped_value_sub_eq_sum hle]\n  ext ω\n  simp only [Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  refine' Finset.sum_congr _ fun _ _ => rfl\n  ext i\n  simp only [Finset.mem_filter, Set.mem_setOf_eq, Finset.mem_range, Finset.mem_Ico]\n  exact ⟨fun h => ⟨lt_trans h.2 (Nat.lt_succ_iff.2 <| hbdd _), h⟩, fun h => h.2⟩\n#align stopped_value_sub_eq_sum' stopped_value_sub_eq_sum'\n\n",
 "stopped_value_sub_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_sub_eq_sum [AddCommGroup β] (hle : τ ≤ π) :\n    stopped_value u π - stopped_value u τ = fun ω =>\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.Ico (τ ω) (π ω)) (u (i + 1) - u i))\n        ω :=\n  by\n  ext ω\n  rw [Finset.sum_Ico_eq_sub _ (hle ω), Finset.sum_range_sub, Finset.sum_range_sub]\n  simp [stopped_value]\n#align stopped_value_sub_eq_sum stopped_value_sub_eq_sum\n\n",
 "stopped_value_stopped_process":
 "theorem stopped_value_stopped_process {u : ι → Ω → β} {τ σ : Ω → ι} :\n    stopped_value (stopped_process u τ) σ = stopped_value u fun ω => min (σ ω) (τ ω) :=\n  rfl\n#align stopped_value_stopped_process stopped_value_stopped_process\n\n",
 "stopped_value_piecewise_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem stopped_value_piecewise_const' {ι' : Type _} {i j : ι'} {f : ι' → Ω → exprℝ} :\n    stopped_value f (s.piecewise (fun _ => i) fun _ => j) = s.indicator (f i) + («expr ᶜ» s).indicator (f j) :=\n  by\n  ext ω\n  rw [stopped_value]\n  by_cases hx : ω ∈ s <;> simp [hx]\n#align stopped_value_piecewise_const' stopped_value_piecewise_const'\n\n",
 "stopped_value_piecewise_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem stopped_value_piecewise_const {ι' : Type _} {i j : ι'} {f : ι' → Ω → exprℝ} :\n    stopped_value f (s.piecewise (fun _ => i) fun _ => j) = s.piecewise (f i) (f j) :=\n  by\n  ext ω\n  rw [stopped_value]\n  by_cases hx : ω ∈ s <;> simp [hx]\n#align stopped_value_piecewise_const stopped_value_piecewise_const\n\n",
 "stopped_value_eq_of_mem_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_eq_of_mem_finset [AddCommMonoid E] {s : Finset ι} (hbdd : ∀ ω, τ ω ∈ s) :\n    stopped_value u τ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (Set.indicator { ω | τ ω = i } (u i)) :=\n  by\n  ext y\n  rw [stopped_value, Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  suffices Finset.filter (fun i => y ∈ { ω : Ω | τ ω = i }) s = ({τ y} : Finset ι) by rw [this, Finset.sum_singleton]\n  ext1 ω\n  simp only [Set.mem_setOf_eq, Finset.mem_filter, Finset.mem_singleton]\n  constructor <;> intro h\n  · exact h.2.symm\n  · refine' ⟨_, h.symm⟩\n    rw [h]\n    exact hbdd y\n#align stopped_value_eq_of_mem_finset stopped_value_eq_of_mem_finset\n\n",
 "stopped_value_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_eq' [preorder ι] [LocallyFiniteOrderBot ι] [AddCommMonoid E] {N : ι} (hbdd : ∀ ω, τ ω ≤ N) :\n    stopped_value u τ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Iic N)\n        (Set.indicator { ω | τ ω = i } (u i)) :=\n  stopped_value_eq_of_mem_finset fun ω => Finset.mem_Iic.mpr (hbdd ω)\n#align stopped_value_eq' stopped_value_eq'\n\n",
 "stopped_value_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_eq {N : ℕ} (hbdd : ∀ ω, τ ω ≤ N) :\n    stopped_value u τ = fun x =>\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (N + 1)) (Set.indicator { ω | τ ω = i } (u i)))\n        x :=\n  stopped_value_eq_of_mem_finset fun ω => Finset.mem_range_succ_iff.mpr (hbdd ω)\n#align stopped_value_eq stopped_value_eq\n\n",
 "stopped_value_const":
 "theorem stopped_value_const (u : ι → Ω → β) (i : ι) : (stopped_value u fun ω => i) = u i :=\n  rfl\n#align stopped_value_const stopped_value_const\n\n",
 "stopped_process_of_discrete":
 "/-- If the indexing order has the discrete topology, then the stopped process of an adapted process\nis adapted. -/\ntheorem adapted.stopped_process_of_discrete [DiscreteTopology ι] (hu : adapted f u) (hτ : is_stopping_time f τ) :\n    adapted f (stopped_process u τ) :=\n  (hu.prog_measurable_of_discrete.stopped_process hτ).adapted\n#align adapted.stopped_process_of_discrete adapted.stopped_process_of_discrete\n\n",
 "stopped_process_eq_stopped_value":
 "theorem stopped_process_eq_stopped_value {u : ι → Ω → β} {τ : Ω → ι} :\n    stopped_process u τ = fun i => stopped_value u fun ω => min i (τ ω) :=\n  rfl\n#align stopped_process_eq_stopped_value stopped_process_eq_stopped_value\n\n",
 "stopped_process_eq_of_mem_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq_of_mem_finset [linear_order ι] [AddCommMonoid E] {s : Finset ι} (n : ι)\n    (hbdd : ∀ ω, τ ω < n → τ ω ∈ s) :\n    stopped_process u τ n =\n      Set.indicator { a | n ≤ τ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (s.filter (· < n)) (Set.indicator { ω | τ ω = i } (u i)) :=\n  by\n  ext ω\n  rw [Pi.add_apply, Finset.sum_apply]\n  cases le_or_lt n (τ ω)\n  · rw [stopped_process_eq_of_le h, Set.indicator_of_mem, Finset.sum_eq_zero, add_zero]\n    · intro m hm\n      refine' Set.indicator_of_not_mem _ _\n      rw [Finset.mem_filter] at hm\n      exact (hm.2.trans_le h).ne'\n    · exact h\n  · rw [stopped_process_eq_of_ge (le_of_lt h), Finset.sum_eq_single_of_mem (τ ω)]\n    · rw [Set.indicator_of_not_mem, zero_add, Set.indicator_of_mem]\n      · exact rfl\n      -- refl does not work\n      · exact not_le.2 h\n    · rw [Finset.mem_filter]\n      exact ⟨hbdd ω h, h⟩\n    · intro b hb hneq\n      rw [Set.indicator_of_not_mem]\n      exact hneq.symm\n#align stopped_process_eq_of_mem_finset stopped_process_eq_of_mem_finset\n\n",
 "stopped_process_eq_of_le":
 "theorem stopped_process_eq_of_le {u : ι → Ω → β} {τ : Ω → ι} {i : ι} {ω : Ω} (h : i ≤ τ ω) :\n    stopped_process u τ i ω = u i ω := by simp [stopped_process, min_eq_left h]\n#align stopped_process_eq_of_le stopped_process_eq_of_le\n\n",
 "stopped_process_eq_of_ge":
 "theorem stopped_process_eq_of_ge {u : ι → Ω → β} {τ : Ω → ι} {i : ι} {ω : Ω} (h : τ ω ≤ i) :\n    stopped_process u τ i ω = u (τ ω) ω := by simp [stopped_process, min_eq_right h]\n#align stopped_process_eq_of_ge stopped_process_eq_of_ge\n\n",
 "stopped_process_eq''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq'' [linear_order ι] [LocallyFiniteOrderBot ι] [AddCommMonoid E] (n : ι) :\n    stopped_process u τ n =\n      Set.indicator { a | n ≤ τ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Iio n)\n          (Set.indicator { ω | τ ω = i } (u i)) :=\n  by\n  have h_mem : ∀ ω, τ ω < n → τ ω ∈ Finset.Iio n := fun ω h => finset.mem_Iio.mpr h\n  rw [stopped_process_eq_of_mem_finset n h_mem]\n  swap; · infer_instance\n  congr with i\n  simp only [Finset.Iio_filter_lt, min_eq_right]\n#align stopped_process_eq'' stopped_process_eq''\n\n",
 "stopped_process_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq' (n : ℕ) :\n    stopped_process u τ n =\n      Set.indicator { a | n + 1 ≤ τ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1)) (Set.indicator { a | τ a = i } (u i)) :=\n  by\n  have : { a | n ≤ τ a }.indicator (u n) = { a | n + 1 ≤ τ a }.indicator (u n) + { a | τ a = n }.indicator (u n) :=\n    by\n    ext x\n    rw [add_comm, Pi.add_apply, ← Set.indicator_union_of_not_mem_inter]\n    · simp_rw [@eq_comm _ _ n, @le_iff_eq_or_lt _ _ n, Nat.succ_le_iff]\n      rfl\n    · rintro ⟨h₁, h₂⟩\n      exact (Nat.succ_le_iff.1 h₂).ne h₁.symm\n  rw [stopped_process_eq, this, Finset.sum_range_succ_comm, ← add_assoc]\n#align stopped_process_eq' stopped_process_eq'\n\n",
 "stopped_process_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq (n : ℕ) :\n    stopped_process u τ n =\n      Set.indicator { a | n ≤ τ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (Set.indicator { ω | τ ω = i } (u i)) :=\n  by\n  rw [stopped_process_eq'' n]\n  swap; · infer_instance\n  congr with i\n  rw [Finset.mem_Iio, Finset.mem_range]\n#align stopped_process_eq stopped_process_eq\n\n",
 "stopped_process":
 "/-- The stopped process of an adapted process with continuous paths is adapted. -/\ntheorem adapted.stopped_process [metrizable_space ι] (hu : adapted f u) (hu_cont : ∀ ω, Continuous fun i => u i ω)\n    (hτ : is_stopping_time f τ) : adapted f (stopped_process u τ) :=\n  ((hu.prog_measurable_of_continuous hu_cont).stopped_process hτ).adapted\n#align adapted.stopped_process adapted.stopped_process\n\n",
 "prog_measurable_min_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem prog_measurable_min_stopping_time [metrizable_space ι] (hτ : is_stopping_time f τ) :\n    prog_measurable f fun i ω => min i (τ ω) := by\n  intro i\n  let m_prod : MeasurableSpace (Set.Iic i × Ω) := MeasurableSpace.prod _ (f i)\n  let m_set : ∀ t : Set (Set.Iic i × Ω), MeasurableSpace t := fun _ =>\n    @Subtype.instMeasurableSpace (Set.Iic i × Ω) _ m_prod\n  let s := { p : Set.Iic i × Ω | τ p.2 ≤ i }\n  have hs : (measurable_set_of m_prod) s := @measurable_snd (Set.Iic i) Ω _ (f i) _ (hτ i)\n  have h_meas_fst : ∀ t : Set (Set.Iic i × Ω), (measurable_of (m_set t)) fun x : t => ((x : Set.Iic i × Ω).fst : ι) :=\n    fun t => (@measurable_subtype_coe (Set.Iic i × Ω) m_prod _).fst.subtype_coe\n  apply measurable.strongly_measurable\n  refine' measurable_of_restrict_of_restrict_compl hs _ _\n  · refine' @measurable.min _ _ _ _ _ (m_set s) _ _ _ _ _ (h_meas_fst s) _\n    refine' @measurable_of_Iic ι s _ _ _ (m_set s) _ _ _ _ fun j => _\n    have h_set_eq :\n      «expr ⁻¹' » (fun x : s => τ (x : Set.Iic i × Ω).snd) (Set.Iic j) =\n        «expr ⁻¹' » (fun x : s => (x : Set.Iic i × Ω).snd) { ω | τ ω ≤ min i j } :=\n      by\n      ext1 ω\n      simp only [Set.mem_preimage, Set.mem_Iic, iff_and_self, le_min_iff, Set.mem_setOf_eq]\n      exact fun _ => ω.prop\n    rw [h_set_eq]\n    suffices h_meas : @Measurable _ _ (m_set s) (f i) fun x : s => (x : Set.Iic i × Ω).snd\n    exact h_meas (f.mono (min_le_left _ _) _ (hτ.measurable_set_le (min i j)))\n    exact measurable_snd.comp (@measurable_subtype_coe _ m_prod _)\n  · suffices h_min_eq_left :\n      (fun x : «expr ᶜ» s => min (↑(x : Set.Iic i × Ω).fst) (τ (x : Set.Iic i × Ω).snd)) = fun x : «expr ᶜ» s =>\n        ↑(x : Set.Iic i × Ω).fst\n    · rw [Set.restrict, h_min_eq_left]\n      exact h_meas_fst _\n    ext1 ω\n    rw [min_eq_left]\n    have hx_fst_le : ↑(ω : Set.Iic i × Ω).fst ≤ i := (ω : Set.Iic i × Ω).fst.prop\n    refine' hx_fst_le.trans (le_of_lt _)\n    convert ω.prop\n    simp only [not_le, Set.mem_compl_iff, Set.mem_setOf_eq]\n#align prog_measurable_min_stopping_time prog_measurable_min_stopping_time\n\n",
 "piecewise_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- Given stopping times `τ` and `η` which are bounded below, `set.piecewise s τ η` is also\na stopping time with respect to the same filtration. -/\ntheorem is_stopping_time.piecewise_of_le (hτ_st : is_stopping_time 𝒢 τ) (hη_st : is_stopping_time 𝒢 η)\n    (hτ : ∀ ω, i ≤ τ ω) (hη : ∀ ω, i ≤ η ω) (hs : (measurable_set_of (𝒢 i)) s) : is_stopping_time 𝒢 (s.piecewise τ η) :=\n  by\n  intro n\n  have : { ω | s.piecewise τ η ω ≤ n } = s ∩ { ω | τ ω ≤ n } ∪ «expr ᶜ» s ∩ { ω | η ω ≤ n } :=\n    by\n    ext1 ω\n    simp only [Set.piecewise, Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    by_cases hx : ω ∈ s <;> simp [hx]\n  rw [this]\n  by_cases hin : i ≤ n\n  · have hs_n : (measurable_set_of (𝒢 n)) s := 𝒢.mono hin _ hs\n    exact (hs_n.inter (hτ_st n)).union (hs_n.compl.inter (hη_st n))\n  · have hτn : ∀ ω, ¬τ ω ≤ n := fun ω hτn => hin ((hτ ω).trans hτn)\n    have hηn : ∀ ω, ¬η ω ≤ n := fun ω hηn => hin ((hη ω).trans hηn)\n    simp [hτn, hηn]\n#align is_stopping_time.piecewise_of_le is_stopping_time.piecewise_of_le\n\n",
 "min_const":
 "protected theorem min_const [linear_order ι] {f : filtration ι m} {τ : Ω → ι} (hτ : is_stopping_time f τ) (i : ι) :\n    is_stopping_time f fun ω => min (τ ω) i :=\n  hτ.min (is_stopping_time_const f i)\n#align min_const min_const\n\n",
 "min":
 "protected theorem min [linear_order ι] {f : filtration ι m} {τ π : Ω → ι} (hτ : is_stopping_time f τ)\n    (hπ : is_stopping_time f π) : is_stopping_time f fun ω => min (τ ω) (π ω) :=\n  by\n  intro i\n  simp_rw [min_le_iff, Set.setOf_or]\n  exact (hτ i).union (hπ i)\n#align min min\n\n",
 "mem_ℒp_stopped_value_of_mem_finset":
 "theorem mem_ℒp_stopped_value_of_mem_finset (hτ : is_stopping_time ℱ τ) (hu : ∀ n, mem_ℒp (u n) p μ) {s : Finset ι}\n    (hbdd : ∀ ω, τ ω ∈ s) : mem_ℒp (stopped_value u τ) p μ :=\n  by\n  rw [stopped_value_eq_of_mem_finset hbdd]\n  swap; infer_instance\n  refine' mem_ℒp_finset_sum' _ fun i hi => mem_ℒp.indicator _ (hu i)\n  refine' ℱ.le i { a : Ω | τ a = i } (hτ.measurable_set_eq_of_countable_range _ i)\n  refine' ((Finset.finite_toSet s).subset fun ω hω => _).countable\n  obtain ⟨y, rfl⟩ := hω\n  exact hbdd y\n#align mem_ℒp_stopped_value_of_mem_finset mem_ℒp_stopped_value_of_mem_finset\n\n",
 "mem_ℒp_stopped_value":
 "theorem mem_ℒp_stopped_value [LocallyFiniteOrderBot ι] (hτ : is_stopping_time ℱ τ) (hu : ∀ n, mem_ℒp (u n) p μ) {N : ι}\n    (hbdd : ∀ ω, τ ω ≤ N) : mem_ℒp (stopped_value u τ) p μ :=\n  mem_ℒp_stopped_value_of_mem_finset hτ hu fun ω => Finset.mem_Iic.mpr (hbdd ω)\n#align mem_ℒp_stopped_value mem_ℒp_stopped_value\n\n",
 "mem_ℒp_stopped_process_of_mem_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_ℒp_stopped_process_of_mem_finset (hτ : is_stopping_time ℱ τ) (hu : ∀ n, mem_ℒp (u n) p μ) (n : ι)\n    {s : Finset ι} (hbdd : ∀ ω, τ ω < n → τ ω ∈ s) : mem_ℒp (stopped_process u τ n) p μ :=\n  by\n  rw [stopped_process_eq_of_mem_finset n hbdd]\n  swap; · infer_instance\n  refine' mem_ℒp.add _ _\n  · exact mem_ℒp.indicator (ℱ.le n { a : Ω | n ≤ τ a } (hτ.measurable_set_ge n)) (hu n)\n  · suffices\n      mem_ℒp\n        (fun ω =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (s.filter (· < n)) ({ a : Ω | τ a = i }.indicator (u i) ω))\n        p μ\n      by\n      convert this\n      ext1 ω\n      simp only [Finset.sum_apply]\n    refine' mem_ℒp_finset_sum _ fun i hi => mem_ℒp.indicator _ (hu i)\n    exact ℱ.le i { a : Ω | τ a = i } (hτ.measurable_set_eq i)\n#align mem_ℒp_stopped_process_of_mem_finset mem_ℒp_stopped_process_of_mem_finset\n\n",
 "mem_ℒp_stopped_process":
 "theorem mem_ℒp_stopped_process [LocallyFiniteOrderBot ι] (hτ : is_stopping_time ℱ τ) (hu : ∀ n, mem_ℒp (u n) p μ)\n    (n : ι) : mem_ℒp (stopped_process u τ n) p μ :=\n  mem_ℒp_stopped_process_of_mem_finset hτ hu n fun ω h => Finset.mem_Iio.mpr h\n#align mem_ℒp_stopped_process mem_ℒp_stopped_process\n\n",
 "measurable_stopped_value":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\ntheorem measurable_stopped_value [metrizable_space β] [MeasurableSpace β] [borel_space β]\n    (hf_prog : prog_measurable f u) (hτ : is_stopping_time f τ) :\n    (measurable_of hτ.measurable_space) (stopped_value u τ) :=\n  by\n  have h_str_meas : ∀ i, (strongly_measurable_of (f i)) (stopped_value u fun ω => min (τ ω) i) := fun i =>\n    strongly_measurable_stopped_value_of_le hf_prog (hτ.min_const i) fun _ => min_le_right _ _\n  intro t ht i\n  suffices\n    «expr ⁻¹' » (stopped_value u τ) t ∩ { ω : Ω | τ ω ≤ i } =\n      «expr ⁻¹' » (stopped_value u fun ω => min (τ ω) i) t ∩ { ω : Ω | τ ω ≤ i }\n    by\n    rw [this]\n    exact ((h_str_meas i).measurable ht).inter (hτ.measurable_set_le i)\n  ext1 ω\n  simp only [stopped_value, Set.mem_inter_iff, Set.mem_preimage, Set.mem_setOf_eq, and_congr_left_iff]\n  intro h\n  rw [min_eq_left h]\n#align measurable_stopped_value measurable_stopped_value\n\n",
 "measurable_space_mono":
 "theorem measurable_space_mono (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) (hle : τ ≤ π) :\n    hτ.measurable_space ≤ hπ.measurable_space := by\n  intro s hs i\n  rw [(_ : s ∩ { ω | π ω ≤ i } = s ∩ { ω | τ ω ≤ i } ∩ { ω | π ω ≤ i })]\n  · exact (hs i).inter (hπ i)\n  · ext\n    simp only [Set.mem_inter_iff, iff_self_and, and_congr_left_iff, Set.mem_setOf_eq]\n    intro hle' _\n    exact le_trans (hle _) hle'\n#align measurable_space_mono measurable_space_mono\n\n",
 "measurable_space_min_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem measurable_space_min_const (hτ : is_stopping_time f τ) {i : ι} :\n    (hτ.min_const i).measurable_space = «expr ⊓ » hτ.measurable_space (f i) := by\n  rw [hτ.measurable_space_min (is_stopping_time_const _ i), measurable_space_const]\n#align measurable_space_min_const measurable_space_min_const\n\n",
 "measurable_space_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem measurable_space_min (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) :\n    (hτ.min hπ).measurable_space = «expr ⊓ » hτ.measurable_space hπ.measurable_space :=\n  by\n  refine' le_antisymm _ _\n  ·\n    exact\n      le_inf (measurable_space_mono _ hτ fun _ => min_le_left _ _)\n        (measurable_space_mono _ hπ fun _ => min_le_right _ _)\n  · intro s\n    change\n      (measurable_set_of hτ.measurable_space) s ∧ (measurable_set_of hπ.measurable_space) s →\n        (measurable_set_of (hτ.min hπ).measurable_space) s\n    simp_rw [is_stopping_time.measurable_set]\n    have : ∀ i, { ω | min (τ ω) (π ω) ≤ i } = { ω | τ ω ≤ i } ∪ { ω | π ω ≤ i } :=\n      by\n      intro i\n      ext1 ω\n      simp\n    simp_rw [this, Set.inter_union_distrib_left]\n    exact fun h i => (h.left i).union (h.right i)\n#align measurable_space_min measurable_space_min\n\n",
 "measurable_space_le_of_le_const":
 "theorem measurable_space_le_of_le_const (hτ : is_stopping_time f τ) {i : ι} (hτ_le : ∀ ω, τ ω ≤ i) :\n    hτ.measurable_space ≤ f i :=\n  (measurable_space_mono hτ _ hτ_le).trans (measurable_space_const _ _).le\n#align measurable_space_le_of_le_const measurable_space_le_of_le_const\n\n",
 "measurable_space_le_of_le":
 "theorem measurable_space_le_of_le (hτ : is_stopping_time f τ) {n : ι} (hτ_le : ∀ ω, τ ω ≤ n) :\n    hτ.measurable_space ≤ m :=\n  (hτ.measurable_space_le_of_le_const hτ_le).trans (f.le n)\n#align measurable_space_le_of_le measurable_space_le_of_le\n\n",
 "measurable_space_le_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\nprotected theorem measurable_space_le_of_countable_range (hτ : is_stopping_time f τ)\n    (h_countable : (Set.range τ).countable) : hτ.measurable_space ≤ m :=\n  by\n  intro s hs\n  change ∀ i, (measurable_set_of (f i)) (s ∩ { ω | τ ω ≤ i }) at hs\n  rw [(_ :\n      s =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (s ∩ { ω | τ ω ≤ i }))]\n  · exact MeasurableSet.bunionᵢ h_countable fun i _ => f.le i _ (hs i)\n  · ext ω\n    constructor <;> rw [Set.mem_unionᵢ]\n    · exact fun hx => ⟨τ ω, by simpa using hx⟩\n    · rintro ⟨i, hx⟩\n      simp only [Set.mem_range, Set.unionᵢ_exists, Set.mem_unionᵢ, Set.mem_inter_iff, Set.mem_setOf_eq, exists_prop,\n        exists_and_right] at hx\n      exact hx.1.2\n#align measurable_space_le_of_countable_range measurable_space_le_of_countable_range\n\n",
 "measurable_space_le_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem measurable_space_le_of_countable [Countable ι] (hτ : is_stopping_time f τ) : hτ.measurable_space ≤ m :=\n  by\n  intro s hs\n  change ∀ i, (measurable_set_of (f i)) (s ∩ { ω | τ ω ≤ i }) at hs\n  rw [(_ :\n      s =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (s ∩ { ω | τ ω ≤ i }))]\n  · exact MeasurableSet.unionᵢ fun i => f.le i _ (hs i)\n  · ext ω\n    constructor <;> rw [Set.mem_unionᵢ]\n    · exact fun hx => ⟨τ ω, hx, le_rfl⟩\n    · rintro ⟨_, hx, _⟩\n      exact hx\n#align measurable_space_le_of_countable measurable_space_le_of_countable\n\n",
 "measurable_space_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem measurable_space_le' [IsCountablyGenerated (atTop : Filter ι)] [(atTop : Filter ι).ne_bot]\n    (hτ : is_stopping_time f τ) : hτ.measurable_space ≤ m :=\n  by\n  intro s hs\n  change ∀ i, (measurable_set_of (f i)) (s ∩ { ω | τ ω ≤ i }) at hs\n  obtain ⟨seq : ℕ → ι, h_seq_tendsto⟩ := at_top.exists_seq_tendsto\n  rw [(_ :\n      s =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (s ∩ { ω | τ ω ≤ seq n }))]\n  · exact MeasurableSet.unionᵢ fun i => f.le (seq i) _ (hs (seq i))\n  · ext ω\n    constructor <;> rw [Set.mem_unionᵢ]\n    · intro hx\n      suffices : ∃ i, τ ω ≤ seq i\n      exact ⟨this.some, hx, this.some_spec⟩\n      rw [tendsto_at_top] at h_seq_tendsto\n      exact (h_seq_tendsto (τ ω)).exists\n    · rintro ⟨_, hx, _⟩\n      exact hx\n  all_goals infer_instance\n#align measurable_space_le' measurable_space_le'\n\n",
 "measurable_space_le":
 "theorem measurable_space_le {ι} [SemilatticeSup ι] {f : filtration ι m} {τ : Ω → ι}\n    [IsCountablyGenerated (atTop : Filter ι)] (hτ : is_stopping_time f τ) : hτ.measurable_space ≤ m :=\n  by\n  cases isEmpty_or_nonempty ι\n  · haveI : IsEmpty Ω := ⟨fun ω => is_empty.false (τ ω)⟩\n    intro s hsτ\n    suffices hs : s = ∅\n    · rw [hs]\n      exact MeasurableSet.empty\n    haveI : Unique (Set Ω) := Set.uniqueEmpty\n    rw [Unique.eq_default s, Unique.eq_default ∅]\n  exact measurable_space_le' hτ\n#align measurable_space_le measurable_space_le\n\n",
 "measurable_space_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n@[simp]\ntheorem measurable_space_const (f : filtration ι m) (i : ι) : (is_stopping_time_const f i).measurable_space = f i :=\n  by\n  ext1 s\n  change (measurable_set_of (is_stopping_time_const f i).measurable_space) s ↔ (measurable_set_of (f i)) s\n  rw [is_stopping_time.measurable_set]\n  constructor <;> intro h\n  · specialize h i\n    simpa only [le_refl, Set.setOf_true, Set.inter_univ] using h\n  · intro j\n    by_cases hij : i ≤ j\n    · simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    · simp only [hij, Set.setOf_false, Set.inter_empty, MeasurableSet.empty]\n#align measurable_space_const measurable_space_const\n\n",
 "measurable_set_stopping_time_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_stopping_time_le [TopologicalSpace ι] [SecondCountableTopology ι] [OrderTopology ι]\n    [MeasurableSpace ι] [borel_space ι] (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) :\n    (measurable_set_of hπ.measurable_space) { ω | τ ω ≤ π ω } :=\n  by\n  suffices (measurable_set_of (hτ.min hπ).measurable_space) { ω : Ω | τ ω ≤ π ω }\n    by\n    rw [measurable_set_min_iff hτ hπ] at this\n    exact this.2\n  rw [← Set.univ_inter { ω : Ω | τ ω ≤ π ω }, ← hτ.measurable_set_inter_le_iff hπ, Set.univ_inter]\n  exact measurable_set_le_stopping_time hτ hπ\n#align measurable_set_stopping_time_le measurable_set_stopping_time_le\n\n",
 "measurable_set_min_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_min_iff (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) (s : Set Ω) :\n    (measurable_set_of (hτ.min hπ).measurable_space) s ↔\n      (measurable_set_of hτ.measurable_space) s ∧ (measurable_set_of hπ.measurable_space) s :=\n  by\n  rw [measurable_space_min]\n  rfl\n#align measurable_set_min_iff measurable_set_min_iff\n\n",
 "measurable_set_min_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_min_const_iff (hτ : is_stopping_time f τ) (s : Set Ω) {i : ι} :\n    (measurable_set_of (hτ.min_const i).measurable_space) s ↔\n      (measurable_set_of hτ.measurable_space) s ∧ (measurable_set_of (f i)) s :=\n  by rw [measurable_space_min_const, MeasurableSpace.measurableSet_inf]\n#align measurable_set_min_const_iff measurable_set_min_const_iff\n\n",
 "measurable_set_lt_of_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_lt_of_pred [PredOrder ι] (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | τ ω < i } :=\n  by\n  by_cases hi_min : IsMin i\n  · suffices { ω : Ω | τ ω < i } = ∅ by\n      rw [this]\n      exact @MeasurableSet.empty _ (f i)\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    rw [isMin_iff_forall_not_lt] at hi_min\n    exact hi_min (τ ω)\n  have : { ω : Ω | τ ω < i } = «expr ⁻¹' » τ (Set.Iio i) := rfl\n  rw [this, ← Iic_pred_of_not_is_min hi_min]\n  exact f.mono (pred_le i) _ (hτ.measurable_set_le <| pred i)\n#align is_stopping_time.measurable_set_lt_of_pred is_stopping_time.measurable_set_lt_of_pred\n\n",
 "measurable_set_lt_of_is_lub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- Auxiliary lemma for `is_stopping_time.measurable_set_lt`. -/\ntheorem is_stopping_time.measurable_set_lt_of_is_lub (hτ : is_stopping_time f τ) (i : ι) (h_lub : IsLUB (Set.Iio i) i) :\n    (measurable_set_of (f i)) { ω | τ ω < i } :=\n  by\n  by_cases hi_min : IsMin i\n  · suffices { ω | τ ω < i } = ∅ by\n      rw [this]\n      exact @MeasurableSet.empty _ (f i)\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    exact is_min_iff_forall_not_lt.mp hi_min (τ ω)\n  obtain ⟨seq, -, -, h_tendsto, h_bound⟩ :\n    ∃ seq : ℕ → ι, Monotone seq ∧ (∀ j, seq j ≤ i) ∧ tendsto seq at_top ((nhds) i) ∧ ∀ j, seq j < i\n  exact h_lub.exists_seq_monotone_tendsto (not_is_min_iff.mp hi_min)\n  have h_Ioi_eq_Union :\n    Set.Iio i =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        { k | k ≤ seq j } :=\n    by\n    ext1 k\n    simp only [Set.mem_Iio, Set.mem_unionᵢ, Set.mem_setOf_eq]\n    refine' ⟨fun hk_lt_i => _, fun h_exists_k_le_seq => _⟩\n    · rw [tendsto_at_top'] at h_tendsto\n      have h_nhds : Set.Ici k ∈ (nhds) i := mem_nhds_iff.mpr ⟨Set.Ioi k, Set.Ioi_subset_Ici le_rfl, isOpen_Ioi, hk_lt_i⟩\n      obtain ⟨a, ha⟩ : ∃ a : ℕ, ∀ b : ℕ, b ≥ a → k ≤ seq b := h_tendsto (Set.Ici k) h_nhds\n      exact ⟨a, ha a le_rfl⟩\n    · obtain ⟨j, hk_seq_j⟩ := h_exists_k_le_seq\n      exact hk_seq_j.trans_lt (h_bound j)\n  have h_lt_eq_preimage : { ω | τ ω < i } = «expr ⁻¹' » τ (Set.Iio i) :=\n    by\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_Iio]\n  rw [h_lt_eq_preimage, h_Ioi_eq_Union]\n  simp only [Set.preimage_unionᵢ, Set.preimage_setOf_eq]\n  exact MeasurableSet.unionᵢ fun n => f.mono (h_bound n).le _ (hτ.measurable_set_le (seq n))\n#align is_stopping_time.measurable_set_lt_of_is_lub is_stopping_time.measurable_set_lt_of_is_lub\n\n",
 "measurable_set_lt_of_countable_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable_range' (hτ : is_stopping_time f τ)\n    (h_countable : (Set.range τ).countable) (i : ι) : (measurable_set_of hτ.measurable_space) { ω | τ ω < i } :=\n  by\n  have : { ω | τ ω < i } = { ω | τ ω ≤ i } \\ { ω | τ ω = i } :=\n    by\n    ext1 ω\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hτ.measurable_set_le' i).diff (hτ.measurable_set_eq_of_countable_range' h_countable i)\n#align measurable_set_lt_of_countable_range' measurable_set_lt_of_countable_range'\n\n",
 "measurable_set_lt_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable_range (hτ : is_stopping_time f τ)\n    (h_countable : (Set.range τ).countable) (i : ι) : (measurable_set_of (f i)) { ω | τ ω < i } :=\n  by\n  have : { ω | τ ω < i } = { ω | τ ω ≤ i } \\ { ω | τ ω = i } :=\n    by\n    ext1 ω\n    simp [lt_iff_le_and_ne]\n  rw [this]\n  exact (hτ.measurable_set_le i).diff (hτ.measurable_set_eq_of_countable_range h_countable i)\n#align measurable_set_lt_of_countable_range measurable_set_lt_of_countable_range\n\n",
 "measurable_set_lt_of_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable' [Countable ι] (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of hτ.measurable_space) { ω | τ ω < i } :=\n  hτ.measurable_set_lt_of_countable_range' (Set.to_countable _) i\n#align measurable_set_lt_of_countable' measurable_set_lt_of_countable'\n\n",
 "measurable_set_lt_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable [Countable ι] (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | τ ω < i } :=\n  hτ.measurable_set_lt_of_countable_range (Set.to_countable _) i\n#align measurable_set_lt_of_countable measurable_set_lt_of_countable\n\n",
 "measurable_set_lt_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_lt_le (hτ : is_stopping_time f τ) {i j : ι} (hle : i ≤ j) :\n    (measurable_set_of (f j)) { ω | τ ω < i } :=\n  f.mono hle _ <| hτ.measurable_set_lt i\n#align is_stopping_time.measurable_set_lt_le is_stopping_time.measurable_set_lt_le\n\n",
 "measurable_set_lt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt' [TopologicalSpace ι] [OrderTopology ι] [FirstCountableTopology ι]\n    (hτ : is_stopping_time f τ) (i : ι) : (measurable_set_of hτ.measurable_space) { ω | τ ω < i } :=\n  by\n  have : { ω | τ ω < i } = { ω | τ ω ≤ i } \\ { ω | τ ω = i } :=\n    by\n    ext1 ω\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hτ.measurable_set_le' i).diff (hτ.measurable_set_eq' i)\n#align measurable_set_lt' measurable_set_lt'\n\n",
 "measurable_set_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_lt (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | τ ω < i } :=\n  by\n  obtain ⟨i', hi'_lub⟩ : ∃ i', IsLUB (Set.Iio i) i'; exact exists_lub_Iio i\n  cases' lub_Iio_eq_self_or_Iio_eq_Iic i hi'_lub with hi'_eq_i h_Iio_eq_Iic\n  · rw [← hi'_eq_i] at hi'_lub⊢\n    exact hτ.measurable_set_lt_of_is_lub i' hi'_lub\n  · have h_lt_eq_preimage : { ω : Ω | τ ω < i } = «expr ⁻¹' » τ (Set.Iio i) := rfl\n    rw [h_lt_eq_preimage, h_Iio_eq_Iic]\n    exact f.mono (lub_Iio_le i hi'_lub) _ (hτ.measurable_set_le i')\n#align is_stopping_time.measurable_set_lt is_stopping_time.measurable_set_lt\n\n",
 "measurable_set_le_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_le_stopping_time [TopologicalSpace ι] [SecondCountableTopology ι] [OrderTopology ι]\n    [MeasurableSpace ι] [borel_space ι] (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) :\n    (measurable_set_of hτ.measurable_space) { ω | τ ω ≤ π ω } :=\n  by\n  rw [hτ.measurable_set]\n  intro j\n  have : { ω | τ ω ≤ π ω } ∩ { ω | τ ω ≤ j } = { ω | min (τ ω) j ≤ min (π ω) j } ∩ { ω | τ ω ≤ j } :=\n    by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, min_le_iff, le_min_iff, le_refl, and_true_iff, and_congr_left_iff]\n    intro h\n    simp only [h, or_self_iff, and_true_iff]\n    by_cases hj : j ≤ π ω\n    · simp only [hj, h.trans hj, or_self_iff]\n    · simp only [hj, or_false_iff]\n  rw [this]\n  refine' MeasurableSet.inter _ (hτ.measurable_set_le j)\n  apply measurable_set_le\n  · exact (hτ.min_const j).measurable_of_le fun _ => min_le_right _ _\n  · exact (hπ.min_const j).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_le_stopping_time measurable_set_le_stopping_time\n\n",
 "measurable_set_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_le' (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of hτ.measurable_space) { ω | τ ω ≤ i } :=\n  by\n  intro j\n  have : { ω : Ω | τ ω ≤ i } ∩ { ω : Ω | τ ω ≤ j } = { ω : Ω | τ ω ≤ min i j } :=\n    by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff]\n  rw [this]\n  exact f.mono (min_le_right i j) _ (hτ _)\n#align measurable_set_le' measurable_set_le'\n\n",
 "measurable_set_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem is_stopping_time.measurable_set_le (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | τ ω ≤ i } :=\n  hτ i\n#align is_stopping_time.measurable_set_le is_stopping_time.measurable_set_le\n\n",
 "measurable_set_inter_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_le_iff [TopologicalSpace ι] [SecondCountableTopology ι] [OrderTopology ι]\n    [MeasurableSpace ι] [borel_space ι] (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) (s : Set Ω) :\n    (measurable_set_of hτ.measurable_space) (s ∩ { ω | τ ω ≤ π ω }) ↔\n      (measurable_set_of (hτ.min hπ).measurable_space) (s ∩ { ω | τ ω ≤ π ω }) :=\n  by\n  constructor <;> intro h\n  · have : s ∩ { ω | τ ω ≤ π ω } = s ∩ { ω | τ ω ≤ π ω } ∩ { ω | τ ω ≤ π ω } := by rw [Set.inter_assoc, Set.inter_self]\n    rw [this]\n    exact measurable_set_inter_le _ _ _ h\n  · rw [measurable_set_min_iff] at h\n    exact h.1\n#align measurable_set_inter_le_iff measurable_set_inter_le_iff\n\n",
 "measurable_set_inter_le_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_le_const_iff (hτ : is_stopping_time f τ) (s : Set Ω) (i : ι) :\n    (measurable_set_of hτ.measurable_space) (s ∩ { ω | τ ω ≤ i }) ↔\n      (measurable_set_of (hτ.min_const i).measurable_space) (s ∩ { ω | τ ω ≤ i }) :=\n  by\n  rw [is_stopping_time.measurable_set_min_iff hτ (is_stopping_time_const _ i), is_stopping_time.measurable_space_const,\n    is_stopping_time.measurable_set]\n  refine' ⟨fun h => ⟨h, _⟩, fun h j => h.1 j⟩\n  specialize h i\n  rwa [Set.inter_assoc, Set.inter_self] at h\n#align measurable_set_inter_le_const_iff measurable_set_inter_le_const_iff\n\n",
 "measurable_set_inter_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_le [TopologicalSpace ι] [SecondCountableTopology ι] [OrderTopology ι] [MeasurableSpace ι]\n    [borel_space ι] (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) (s : Set Ω)\n    (hs : (measurable_set_of hτ.measurable_space) s) :\n    (measurable_set_of (hτ.min hπ).measurable_space) (s ∩ { ω | τ ω ≤ π ω }) :=\n  by\n  simp_rw [is_stopping_time.measurable_set] at hs⊢\n  intro i\n  have :\n    s ∩ { ω | τ ω ≤ π ω } ∩ { ω | min (τ ω) (π ω) ≤ i } =\n      s ∩ { ω | τ ω ≤ i } ∩ { ω | min (τ ω) (π ω) ≤ i } ∩ { ω | min (τ ω) i ≤ min (min (τ ω) (π ω)) i } :=\n    by\n    ext1 ω\n    simp only [min_le_iff, Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff, le_refl, true_and_iff, and_true_iff,\n      true_or_iff, or_true_iff]\n    by_cases hτi : τ ω ≤ i\n    · simp only [hτi, true_or_iff, and_true_iff, and_congr_right_iff]\n      intro hx\n      constructor <;> intro h\n      · exact or.inl h\n      · cases h\n        · exact h\n        · exact hτi.trans h\n    simp only [hτi, false_or_iff, and_false_iff, false_and_iff, iff_false_iff, not_and, not_le, and_imp]\n    refine' fun hx hτ_le_π => lt_of_lt_of_le _ hτ_le_π\n    rw [← not_le]\n    exact hτi\n  rw [this]\n  refine' ((hs i).inter ((hτ.min hπ) i)).inter _\n  apply measurable_set_le\n  · exact (hτ.min_const i).measurable_of_le fun _ => min_le_right _ _\n  · exact ((hτ.min hπ).min_const i).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_inter_le measurable_set_inter_le\n\n",
 "measurable_set_inter_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_eq_iff (hτ : is_stopping_time f τ) (s : Set Ω) (i : ι) :\n    (measurable_set_of hτ.measurable_space) (s ∩ { ω | τ ω = i }) ↔ (measurable_set_of (f i)) (s ∩ { ω | τ ω = i }) :=\n  by\n  have : ∀ j, { ω : Ω | τ ω = i } ∩ { ω : Ω | τ ω ≤ j } = { ω : Ω | τ ω = i } ∩ { ω | i ≤ j } :=\n    by\n    intro j\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    intro hxi\n    rw [hxi]\n  constructor <;> intro h\n  · specialize h i\n    simpa only [Set.inter_assoc, this, le_refl, Set.setOf_true, Set.inter_univ] using h\n  · intro j\n    rw [Set.inter_assoc, this]\n    by_cases hij : i ≤ j\n    · simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    · simp [hij]\n#align measurable_set_inter_eq_iff measurable_set_inter_eq_iff\n\n",
 "measurable_set_gt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_gt' (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of hτ.measurable_space) { ω | i < τ ω } :=\n  by\n  have : { ω : Ω | i < τ ω } = «expr ᶜ» { ω : Ω | τ ω ≤ i } :=\n    by\n    ext1 ω\n    simp\n  rw [this]\n  exact (hτ.measurable_set_le' i).compl\n#align measurable_set_gt' measurable_set_gt'\n\n",
 "measurable_set_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_gt (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | i < τ ω } :=\n  by\n  have : { ω | i < τ ω } = «expr ᶜ» { ω | τ ω ≤ i } := by\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_le]\n  rw [this]\n  exact (hτ.measurable_set_le i).compl\n#align is_stopping_time.measurable_set_gt is_stopping_time.measurable_set_gt\n\n",
 "measurable_set_ge_of_countable_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable_range' (hτ : is_stopping_time f τ)\n    (h_countable : (Set.range τ).countable) (i : ι) : (measurable_set_of hτ.measurable_space) { ω | i ≤ τ ω } :=\n  by\n  have : { ω | i ≤ τ ω } = { ω | τ ω = i } ∪ { ω | i < τ ω } :=\n    by\n    ext1 ω\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm']\n  rw [this]\n  exact (hτ.measurable_set_eq_of_countable_range' h_countable i).union (hτ.measurable_set_gt' i)\n#align measurable_set_ge_of_countable_range' measurable_set_ge_of_countable_range'\n\n",
 "measurable_set_ge_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable_range {ι} [linear_order ι] {τ : Ω → ι} {f : filtration ι m}\n    (hτ : is_stopping_time f τ) (h_countable : (Set.range τ).countable) (i : ι) :\n    (measurable_set_of (f i)) { ω | i ≤ τ ω } :=\n  by\n  have : { ω | i ≤ τ ω } = «expr ᶜ» { ω | τ ω < i } := by\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hτ.measurable_set_lt_of_countable_range h_countable i).compl\n#align measurable_set_ge_of_countable_range measurable_set_ge_of_countable_range\n\n",
 "measurable_set_ge_of_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable' [Countable ι] (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of hτ.measurable_space) { ω | i ≤ τ ω } :=\n  hτ.measurable_set_ge_of_countable_range' (Set.to_countable _) i\n#align measurable_set_ge_of_countable' measurable_set_ge_of_countable'\n\n",
 "measurable_set_ge_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable {ι} [linear_order ι] {τ : Ω → ι} {f : filtration ι m} [Countable ι]\n    (hτ : is_stopping_time f τ) (i : ι) : (measurable_set_of (f i)) { ω | i ≤ τ ω } :=\n  hτ.measurable_set_ge_of_countable_range (Set.to_countable _) i\n#align measurable_set_ge_of_countable measurable_set_ge_of_countable\n\n",
 "measurable_set_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge' [TopologicalSpace ι] [OrderTopology ι] [FirstCountableTopology ι]\n    (hτ : is_stopping_time f τ) (i : ι) : (measurable_set_of hτ.measurable_space) { ω | i ≤ τ ω } :=\n  by\n  have : { ω | i ≤ τ ω } = { ω | τ ω = i } ∪ { ω | i < τ ω } :=\n    by\n    ext1 ω\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm']\n  rw [this]\n  exact (hτ.measurable_set_eq' i).union (hτ.measurable_set_gt' i)\n#align measurable_set_ge' measurable_set_ge'\n\n",
 "measurable_set_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_ge (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | i ≤ τ ω } :=\n  by\n  have : { ω | i ≤ τ ω } = «expr ᶜ» { ω | τ ω < i } := by\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hτ.measurable_set_lt i).compl\n#align is_stopping_time.measurable_set_ge is_stopping_time.measurable_set_ge\n\n",
 "measurable_set_eq_stopping_time_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_eq_stopping_time_of_countable [Countable ι] [TopologicalSpace ι] [MeasurableSpace ι]\n    [borel_space ι] [OrderTopology ι] [MeasurableSingletonClass ι] [SecondCountableTopology ι]\n    (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) :\n    (measurable_set_of hτ.measurable_space) { ω | τ ω = π ω } :=\n  by\n  rw [hτ.measurable_set]\n  intro j\n  have : { ω | τ ω = π ω } ∩ { ω | τ ω ≤ j } = { ω | min (τ ω) j = min (π ω) j } ∩ { ω | τ ω ≤ j } ∩ { ω | π ω ≤ j } :=\n    by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine' ⟨fun h => ⟨⟨_, h.2⟩, _⟩, fun h => ⟨_, h.1.2⟩⟩\n    · rw [h.1]\n    · rw [← h.1]\n      exact h.2\n    · cases' h with h' hπ_le\n      cases' h' with h_eq hτ_le\n      rwa [min_eq_left hτ_le, min_eq_left hπ_le] at h_eq\n  rw [this]\n  refine' MeasurableSet.inter (MeasurableSet.inter _ (hτ.measurable_set_le j)) (hπ.measurable_set_le j)\n  apply measurableSet_eq_fun_of_countable\n  · exact (hτ.min_const j).measurable_of_le fun _ => min_le_right _ _\n  · exact (hπ.min_const j).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_eq_stopping_time_of_countable measurable_set_eq_stopping_time_of_countable\n\n",
 "measurable_set_eq_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_eq_stopping_time [AddGroup ι] [TopologicalSpace ι] [MeasurableSpace ι] [borel_space ι]\n    [OrderTopology ι] [MeasurableSingletonClass ι] [SecondCountableTopology ι] [MeasurableSub₂ ι]\n    (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) :\n    (measurable_set_of hτ.measurable_space) { ω | τ ω = π ω } :=\n  by\n  rw [hτ.measurable_set]\n  intro j\n  have : { ω | τ ω = π ω } ∩ { ω | τ ω ≤ j } = { ω | min (τ ω) j = min (π ω) j } ∩ { ω | τ ω ≤ j } ∩ { ω | π ω ≤ j } :=\n    by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine' ⟨fun h => ⟨⟨_, h.2⟩, _⟩, fun h => ⟨_, h.1.2⟩⟩\n    · rw [h.1]\n    · rw [← h.1]\n      exact h.2\n    · cases' h with h' hσ_le\n      cases' h' with h_eq hτ_le\n      rwa [min_eq_left hτ_le, min_eq_left hσ_le] at h_eq\n  rw [this]\n  refine' MeasurableSet.inter (MeasurableSet.inter _ (hτ.measurable_set_le j)) (hπ.measurable_set_le j)\n  apply measurableSet_eq_fun\n  · exact (hτ.min_const j).measurable_of_le fun _ => min_le_right _ _\n  · exact (hπ.min_const j).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_eq_stopping_time measurable_set_eq_stopping_time\n\n",
 "measurable_set_eq_of_countable_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable_range' (hτ : is_stopping_time f τ)\n    (h_countable : (Set.range τ).countable) (i : ι) : (measurable_set_of hτ.measurable_space) { ω | τ ω = i } :=\n  by\n  rw [← Set.univ_inter { ω | τ ω = i }, measurable_set_inter_eq_iff, Set.univ_inter]\n  exact hτ.measurable_set_eq_of_countable_range h_countable i\n#align measurable_set_eq_of_countable_range' measurable_set_eq_of_countable_range'\n\n",
 "measurable_set_eq_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable_range (hτ : is_stopping_time f τ)\n    (h_countable : (Set.range τ).countable) (i : ι) : (measurable_set_of (f i)) { ω | τ ω = i } :=\n  by\n  have :\n    { ω | τ ω = i } =\n      { ω | τ ω ≤ i } \\\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          { ω | τ ω ≤ j } :=\n    by\n    ext1 a\n    simp only [Set.mem_setOf_eq, Set.mem_range, Set.unionᵢ_exists, Set.unionᵢ_unionᵢ_eq', Set.mem_diff, Set.mem_unionᵢ,\n      exists_prop, not_exists, not_and, not_le]\n    constructor <;> intro h\n    · simp only [h, lt_iff_le_not_le, le_refl, and_imp, imp_self, imp_true_iff, and_self_iff]\n    · have h_lt_or_eq : τ a < i ∨ τ a = i := lt_or_eq_of_le h.1\n      rcases h_lt_or_eq with (h_lt | rfl)\n      · exfalso\n        exact h.2 a h_lt (le_refl (τ a))\n      · rfl\n  rw [this]\n  refine' (hτ.measurable_set_le i).diff _\n  refine' MeasurableSet.bunionᵢ h_countable fun j hj => _\n  by_cases hji : j < i\n  · simp only [hji, Set.unionᵢ_true]\n    exact f.mono hji.le _ (hτ.measurable_set_le j)\n  · simp only [hji, Set.unionᵢ_false]\n    exact @MeasurableSet.empty _ (f i)\n#align measurable_set_eq_of_countable_range measurable_set_eq_of_countable_range\n\n",
 "measurable_set_eq_of_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable' [Countable ι] (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of hτ.measurable_space) { ω | τ ω = i } :=\n  hτ.measurable_set_eq_of_countable_range' (Set.to_countable _) i\n#align measurable_set_eq_of_countable' measurable_set_eq_of_countable'\n\n",
 "measurable_set_eq_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable [Countable ι] (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | τ ω = i } :=\n  hτ.measurable_set_eq_of_countable_range (Set.to_countable _) i\n#align measurable_set_eq_of_countable measurable_set_eq_of_countable\n\n",
 "measurable_set_eq_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_eq_le (hτ : is_stopping_time f τ) {i j : ι} (hle : i ≤ j) :\n    (measurable_set_of (f j)) { ω | τ ω = i } :=\n  f.mono hle _ <| hτ.measurable_set_eq i\n#align is_stopping_time.measurable_set_eq_le is_stopping_time.measurable_set_eq_le\n\n",
 "measurable_set_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq' [TopologicalSpace ι] [OrderTopology ι] [FirstCountableTopology ι]\n    (hτ : is_stopping_time f τ) (i : ι) : (measurable_set_of hτ.measurable_space) { ω | τ ω = i } :=\n  by\n  rw [← Set.univ_inter { ω | τ ω = i }, measurable_set_inter_eq_iff, Set.univ_inter]\n  exact hτ.measurable_set_eq i\n#align measurable_set_eq' measurable_set_eq'\n\n",
 "measurable_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_eq (hτ : is_stopping_time f τ) (i : ι) :\n    (measurable_set_of (f i)) { ω | τ ω = i } :=\n  by\n  have : { ω | τ ω = i } = { ω | τ ω ≤ i } ∩ { ω | τ ω ≥ i } :=\n    by\n    ext1 ω\n    simp only [Set.mem_setOf_eq, ge_iff_le, Set.mem_inter_iff, le_antisymm_iff]\n  rw [this]\n  exact (hτ.measurable_set_le i).inter (hτ.measurable_set_ge i)\n#align is_stopping_time.measurable_set_eq is_stopping_time.measurable_set_eq\n\n",
 "measurable_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\nprotected theorem measurable_of_le [TopologicalSpace ι] [MeasurableSpace ι] [borel_space ι] [OrderTopology ι]\n    [SecondCountableTopology ι] (hτ : is_stopping_time f τ) {i : ι} (hτ_le : ∀ ω, τ ω ≤ i) : (measurable_of (f i)) τ :=\n  hτ.measurable.mono (measurable_space_le_of_le_const _ hτ_le) le_rfl\n#align measurable_of_le measurable_of_le\n\n",
 "max_const":
 "protected theorem max_const [linear_order ι] {f : filtration ι m} {τ : Ω → ι} (hτ : is_stopping_time f τ) (i : ι) :\n    is_stopping_time f fun ω => max (τ ω) i :=\n  hτ.max (is_stopping_time_const f i)\n#align max_const max_const\n\n",
 "max":
 "protected theorem max [linear_order ι] {f : filtration ι m} {τ π : Ω → ι} (hτ : is_stopping_time f τ)\n    (hπ : is_stopping_time f π) : is_stopping_time f fun ω => max (τ ω) (π ω) :=\n  by\n  intro i\n  simp_rw [max_le_iff, Set.setOf_and]\n  exact (hτ i).inter (hπ i)\n#align max max\n\n",
 "le_measurable_space_of_const_le":
 "theorem le_measurable_space_of_const_le (hτ : is_stopping_time f τ) {i : ι} (hτ_le : ∀ ω, i ≤ τ ω) :\n    f i ≤ hτ.measurable_space :=\n  (measurable_space_const _ _).symm.le.trans (measurable_space_mono _ hτ hτ_le)\n#align le_measurable_space_of_const_le le_measurable_space_of_const_le\n\n",
 "is_stopping_time_piecewise_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time_piecewise_const (hij : i ≤ j) (hs : (measurable_set_of (𝒢 i)) s) :\n    is_stopping_time 𝒢 (s.piecewise (fun _ => i) fun _ => j) :=\n  (is_stopping_time_const 𝒢 i).piecewise_of_le (is_stopping_time_const 𝒢 j) (fun x => le_rfl) (fun _ => hij) hs\n#align is_stopping_time_piecewise_const is_stopping_time_piecewise_const\n\n",
 "is_stopping_time_of_measurable_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time_of_measurable_set_eq [preorder ι] [Countable ι] {f : filtration ι m} {τ : Ω → ι}\n    (hτ : ∀ i, (measurable_set_of (f i)) { ω | τ ω = i }) : is_stopping_time f τ :=\n  by\n  intro i\n  rw [show\n      { ω | τ ω ≤ i } =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" { ω | τ ω = k }\n      by\n      ext\n      simp]\n  refine' MeasurableSet.bunionᵢ (Set.to_countable _) fun k hk => _\n  exact f.mono hk _ (hτ k)\n#align is_stopping_time_of_measurable_set_eq is_stopping_time_of_measurable_set_eq\n\n",
 "is_stopping_time_const":
 "/-\nCopyright (c) 2021 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying, Rémy Degenne\n-/\ntheorem is_stopping_time_const [preorder ι] (f : filtration ι m) (i : ι) : is_stopping_time f fun ω => i := fun j => by\n  simp only [MeasurableSet.const]\n#align is_stopping_time_const is_stopping_time_const\n\n",
 "integrable_stopped_value_of_mem_finset":
 "theorem integrable_stopped_value_of_mem_finset (hτ : is_stopping_time ℱ τ) (hu : ∀ n, integrable (u n) μ) {s : Finset ι}\n    (hbdd : ∀ ω, τ ω ∈ s) : integrable (stopped_value u τ) μ :=\n  by\n  simp_rw [← mem_ℒp_one_iff_integrable] at hu⊢\n  exact mem_ℒp_stopped_value_of_mem_finset hτ hu hbdd\n#align integrable_stopped_value_of_mem_finset integrable_stopped_value_of_mem_finset\n\n",
 "integrable_stopped_value":
 "theorem integrable_stopped_value [LocallyFiniteOrderBot ι] (hτ : is_stopping_time ℱ τ) (hu : ∀ n, integrable (u n) μ)\n    {N : ι} (hbdd : ∀ ω, τ ω ≤ N) : integrable (stopped_value u τ) μ :=\n  integrable_stopped_value_of_mem_finset hτ hu fun ω => Finset.mem_Iic.mpr (hbdd ω)\n#align integrable_stopped_value integrable_stopped_value\n\n",
 "integrable_stopped_process_of_mem_finset":
 "theorem integrable_stopped_process_of_mem_finset (hτ : is_stopping_time ℱ τ) (hu : ∀ n, integrable (u n) μ) (n : ι)\n    {s : Finset ι} (hbdd : ∀ ω, τ ω < n → τ ω ∈ s) : integrable (stopped_process u τ n) μ :=\n  by\n  simp_rw [← mem_ℒp_one_iff_integrable] at hu⊢\n  exact mem_ℒp_stopped_process_of_mem_finset hτ hu n hbdd\n#align integrable_stopped_process_of_mem_finset integrable_stopped_process_of_mem_finset\n\n",
 "integrable_stopped_process":
 "theorem integrable_stopped_process [LocallyFiniteOrderBot ι] (hτ : is_stopping_time ℱ τ) (hu : ∀ n, integrable (u n) μ)\n    (n : ι) : integrable (stopped_process u τ n) μ :=\n  integrable_stopped_process_of_mem_finset hτ hu n fun ω h => Finset.mem_Iio.mpr h\n#align integrable_stopped_process integrable_stopped_process\n\n",
 "add_const_nat":
 "theorem add_const_nat {f : filtration ℕ m} {τ : Ω → ℕ} (hτ : is_stopping_time f τ) {i : ℕ} :\n    is_stopping_time f fun ω => τ ω + i :=\n  by\n  refine' is_stopping_time_of_measurable_set_eq fun j => _\n  by_cases hij : i ≤ j\n  · simp_rw [eq_comm, ← nat.sub_eq_iff_eq_add hij, eq_comm]\n    exact f.mono (j.sub_le i) _ (hτ.measurable_set_eq (j - i))\n  · rw [not_le] at hij\n    convert MeasurableSet.empty\n    ext ω\n    simp only [Set.mem_empty_iff_false, iff_false_iff]\n    rintro (hx : τ ω + i = j)\n    linarith\n#align add_const_nat add_const_nat\n\n",
 "add_const":
 "theorem add_const [AddGroup ι] [preorder ι] [CovariantClass ι ι (function.swap (· + ·)) (· ≤ ·)]\n    [CovariantClass ι ι (· + ·) (· ≤ ·)] {f : filtration ι m} {τ : Ω → ι} (hτ : is_stopping_time f τ) {i : ι}\n    (hi : 0 ≤ i) : is_stopping_time f fun ω => τ ω + i :=\n  by\n  intro j\n  simp_rw [← le_sub_iff_add_le]\n  exact f.mono (sub_le_self j hi) _ (hτ (j - i))\n#align add_const add_const\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n-- generalize to certain countable type?\ntheorem add {f : filtration ℕ m} {τ π : Ω → ℕ} (hτ : is_stopping_time f τ) (hπ : is_stopping_time f π) :\n    is_stopping_time f (τ + π) := by\n  intro i\n  rw [(_ :\n      { ω | (τ + π) ω ≤ i } =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          ({ ω | π ω = k } ∩ { ω | τ ω + k ≤ i }))]\n  ·\n    exact\n      MeasurableSet.unionᵢ fun k =>\n        MeasurableSet.unionᵢ fun hk => (hπ.measurable_set_eq_le hk).inter (hτ.add_const_nat i)\n  ext ω\n  simp only [Pi.add_apply, Set.mem_setOf_eq, Set.mem_unionᵢ, Set.mem_inter_iff, exists_prop]\n  refine' ⟨fun h => ⟨π ω, by linarith, rfl, h⟩, _⟩\n  rintro ⟨j, hj, rfl, h⟩\n  assumption\n#align add add\n\n",
 "adapted_stopped_process":
 "theorem prog_measurable.adapted_stopped_process [metrizable_space ι] (h : prog_measurable f u)\n    (hτ : is_stopping_time f τ) : adapted f (stopped_process u τ) :=\n  (h.stopped_process hτ).adapted\n#align prog_measurable.adapted_stopped_process prog_measurable.adapted_stopped_process\n\n",
 "MeasurableSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n#print MeasurableSet /-\nprotected theorem MeasurableSet (hτ : is_stopping_time f τ) (s : Set Ω) :\n    (measurable_set_of hτ.measurable_space) s ↔ ∀ i : ι, (measurable_set_of (f i)) (s ∩ { ω | τ ω ≤ i }) :=\n  iff.rfl\n#align measurable_set MeasurableSet\n-/\n\n",
 "Measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n#print Measurable /-\nprotected theorem Measurable [TopologicalSpace ι] [MeasurableSpace ι] [borel_space ι] [OrderTopology ι]\n    [SecondCountableTopology ι] (hτ : is_stopping_time f τ) : (measurable_of hτ.measurable_space) τ :=\n  @measurable_of_Iic ι Ω _ _ _ hτ.measurable_space _ _ _ _ fun i => hτ.measurable_set_le' i\n#align measurable Measurable\n-/\n\n"}