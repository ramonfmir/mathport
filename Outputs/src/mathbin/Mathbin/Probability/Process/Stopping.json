{"strongly_measurable_stopped_value_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\ntheorem strongly_measurable_stopped_value_of_le (h : prog_measurable f u) (hÏ„ : is_stopping_time f Ï„) {n : Î¹}\n    (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ n) : (strongly_measurable_of (f n)) (stopped_value u Ï„) :=\n  by\n  have : stopped_value u Ï„ = (fun p : Set.Iic n Ã— Î© => u (â†‘p.fst) p.snd) âˆ˜ fun Ï‰ => (âŸ¨Ï„ Ï‰, hÏ„_le Ï‰âŸ©, Ï‰) :=\n    by\n    ext1 Ï‰\n    simp only [stopped_value, Function.comp_apply, Subtype.coe_mk]\n  rw [this]\n  refine' strongly_measurable.comp_measurable (h n) _\n  exact (hÏ„.measurable_of_le hÏ„_le).subtype_mk.prod_mk measurable_id\n#align strongly_measurable_stopped_value_of_le strongly_measurable_stopped_value_of_le\n\n",
 "strongly_measurable_stopped_process_of_discrete":
 "theorem adapted.strongly_measurable_stopped_process_of_discrete [DiscreteTopology Î¹] (hu : adapted f u)\n    (hÏ„ : is_stopping_time f Ï„) (n : Î¹) : strongly_measurable (stopped_process u Ï„ n) :=\n  hu.prog_measurable_of_discrete.strongly_measurable_stopped_process hÏ„ n\n#align adapted.strongly_measurable_stopped_process_of_discrete adapted.strongly_measurable_stopped_process_of_discrete\n\n",
 "strongly_measurable_stopped_process":
 "theorem adapted.strongly_measurable_stopped_process [metrizable_space Î¹] (hu : adapted f u)\n    (hu_cont : âˆ€ Ï‰, Continuous fun i => u i Ï‰) (hÏ„ : is_stopping_time f Ï„) (n : Î¹) :\n    strongly_measurable (stopped_process u Ï„ n) :=\n  (hu.prog_measurable_of_continuous hu_cont).strongly_measurable_stopped_process hÏ„ n\n#align adapted.strongly_measurable_stopped_process adapted.strongly_measurable_stopped_process\n\n",
 "stopped_value_sub_eq_sum'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_sub_eq_sum' [AddCommGroup Î²] (hle : Ï„ â‰¤ Ï€) {N : â„•} (hbdd : âˆ€ Ï‰, Ï€ Ï‰ â‰¤ N) :\n    stopped_value u Ï€ - stopped_value u Ï„ = fun Ï‰ =>\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (N + 1)) (Set.indicator { Ï‰ | Ï„ Ï‰ â‰¤ i âˆ§ i < Ï€ Ï‰ } (u (i + 1) - u i)))\n        Ï‰ :=\n  by\n  rw [stopped_value_sub_eq_sum hle]\n  ext Ï‰\n  simp only [Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  refine' Finset.sum_congr _ fun _ _ => rfl\n  ext i\n  simp only [Finset.mem_filter, Set.mem_setOf_eq, Finset.mem_range, Finset.mem_Ico]\n  exact âŸ¨fun h => âŸ¨lt_trans h.2 (Nat.lt_succ_iff.2 <| hbdd _), hâŸ©, fun h => h.2âŸ©\n#align stopped_value_sub_eq_sum' stopped_value_sub_eq_sum'\n\n",
 "stopped_value_sub_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_sub_eq_sum [AddCommGroup Î²] (hle : Ï„ â‰¤ Ï€) :\n    stopped_value u Ï€ - stopped_value u Ï„ = fun Ï‰ =>\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.Ico (Ï„ Ï‰) (Ï€ Ï‰)) (u (i + 1) - u i))\n        Ï‰ :=\n  by\n  ext Ï‰\n  rw [Finset.sum_Ico_eq_sub _ (hle Ï‰), Finset.sum_range_sub, Finset.sum_range_sub]\n  simp [stopped_value]\n#align stopped_value_sub_eq_sum stopped_value_sub_eq_sum\n\n",
 "stopped_value_stopped_process":
 "theorem stopped_value_stopped_process {u : Î¹ â†’ Î© â†’ Î²} {Ï„ Ïƒ : Î© â†’ Î¹} :\n    stopped_value (stopped_process u Ï„) Ïƒ = stopped_value u fun Ï‰ => min (Ïƒ Ï‰) (Ï„ Ï‰) :=\n  rfl\n#align stopped_value_stopped_process stopped_value_stopped_process\n\n",
 "stopped_value_piecewise_const'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem stopped_value_piecewise_const' {Î¹' : Type _} {i j : Î¹'} {f : Î¹' â†’ Î© â†’ exprâ„} :\n    stopped_value f (s.piecewise (fun _ => i) fun _ => j) = s.indicator (f i) + (Â«expr á¶œÂ» s).indicator (f j) :=\n  by\n  ext Ï‰\n  rw [stopped_value]\n  by_cases hx : Ï‰ âˆˆ s <;> simp [hx]\n#align stopped_value_piecewise_const' stopped_value_piecewise_const'\n\n",
 "stopped_value_piecewise_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem stopped_value_piecewise_const {Î¹' : Type _} {i j : Î¹'} {f : Î¹' â†’ Î© â†’ exprâ„} :\n    stopped_value f (s.piecewise (fun _ => i) fun _ => j) = s.piecewise (f i) (f j) :=\n  by\n  ext Ï‰\n  rw [stopped_value]\n  by_cases hx : Ï‰ âˆˆ s <;> simp [hx]\n#align stopped_value_piecewise_const stopped_value_piecewise_const\n\n",
 "stopped_value_eq_of_mem_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_eq_of_mem_finset [AddCommMonoid E] {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ âˆˆ s) :\n    stopped_value u Ï„ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (Set.indicator { Ï‰ | Ï„ Ï‰ = i } (u i)) :=\n  by\n  ext y\n  rw [stopped_value, Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  suffices Finset.filter (fun i => y âˆˆ { Ï‰ : Î© | Ï„ Ï‰ = i }) s = ({Ï„ y} : Finset Î¹) by rw [this, Finset.sum_singleton]\n  ext1 Ï‰\n  simp only [Set.mem_setOf_eq, Finset.mem_filter, Finset.mem_singleton]\n  constructor <;> intro h\n  Â· exact h.2.symm\n  Â· refine' âŸ¨_, h.symmâŸ©\n    rw [h]\n    exact hbdd y\n#align stopped_value_eq_of_mem_finset stopped_value_eq_of_mem_finset\n\n",
 "stopped_value_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_eq' [preorder Î¹] [LocallyFiniteOrderBot Î¹] [AddCommMonoid E] {N : Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) :\n    stopped_value u Ï„ =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Iic N)\n        (Set.indicator { Ï‰ | Ï„ Ï‰ = i } (u i)) :=\n  stopped_value_eq_of_mem_finset fun Ï‰ => Finset.mem_Iic.mpr (hbdd Ï‰)\n#align stopped_value_eq' stopped_value_eq'\n\n",
 "stopped_value_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_value_eq {N : â„•} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) :\n    stopped_value u Ï„ = fun x =>\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (N + 1)) (Set.indicator { Ï‰ | Ï„ Ï‰ = i } (u i)))\n        x :=\n  stopped_value_eq_of_mem_finset fun Ï‰ => Finset.mem_range_succ_iff.mpr (hbdd Ï‰)\n#align stopped_value_eq stopped_value_eq\n\n",
 "stopped_value_const":
 "theorem stopped_value_const (u : Î¹ â†’ Î© â†’ Î²) (i : Î¹) : (stopped_value u fun Ï‰ => i) = u i :=\n  rfl\n#align stopped_value_const stopped_value_const\n\n",
 "stopped_process_of_discrete":
 "/-- If the indexing order has the discrete topology, then the stopped process of an adapted process\nis adapted. -/\ntheorem adapted.stopped_process_of_discrete [DiscreteTopology Î¹] (hu : adapted f u) (hÏ„ : is_stopping_time f Ï„) :\n    adapted f (stopped_process u Ï„) :=\n  (hu.prog_measurable_of_discrete.stopped_process hÏ„).adapted\n#align adapted.stopped_process_of_discrete adapted.stopped_process_of_discrete\n\n",
 "stopped_process_eq_stopped_value":
 "theorem stopped_process_eq_stopped_value {u : Î¹ â†’ Î© â†’ Î²} {Ï„ : Î© â†’ Î¹} :\n    stopped_process u Ï„ = fun i => stopped_value u fun Ï‰ => min i (Ï„ Ï‰) :=\n  rfl\n#align stopped_process_eq_stopped_value stopped_process_eq_stopped_value\n\n",
 "stopped_process_eq_of_mem_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq_of_mem_finset [linear_order Î¹] [AddCommMonoid E] {s : Finset Î¹} (n : Î¹)\n    (hbdd : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ s) :\n    stopped_process u Ï„ n =\n      Set.indicator { a | n â‰¤ Ï„ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (s.filter (Â· < n)) (Set.indicator { Ï‰ | Ï„ Ï‰ = i } (u i)) :=\n  by\n  ext Ï‰\n  rw [Pi.add_apply, Finset.sum_apply]\n  cases le_or_lt n (Ï„ Ï‰)\n  Â· rw [stopped_process_eq_of_le h, Set.indicator_of_mem, Finset.sum_eq_zero, add_zero]\n    Â· intro m hm\n      refine' Set.indicator_of_not_mem _ _\n      rw [Finset.mem_filter] at hm\n      exact (hm.2.trans_le h).ne'\n    Â· exact h\n  Â· rw [stopped_process_eq_of_ge (le_of_lt h), Finset.sum_eq_single_of_mem (Ï„ Ï‰)]\n    Â· rw [Set.indicator_of_not_mem, zero_add, Set.indicator_of_mem]\n      Â· exact rfl\n      -- refl does not work\n      Â· exact not_le.2 h\n    Â· rw [Finset.mem_filter]\n      exact âŸ¨hbdd Ï‰ h, hâŸ©\n    Â· intro b hb hneq\n      rw [Set.indicator_of_not_mem]\n      exact hneq.symm\n#align stopped_process_eq_of_mem_finset stopped_process_eq_of_mem_finset\n\n",
 "stopped_process_eq_of_le":
 "theorem stopped_process_eq_of_le {u : Î¹ â†’ Î© â†’ Î²} {Ï„ : Î© â†’ Î¹} {i : Î¹} {Ï‰ : Î©} (h : i â‰¤ Ï„ Ï‰) :\n    stopped_process u Ï„ i Ï‰ = u i Ï‰ := by simp [stopped_process, min_eq_left h]\n#align stopped_process_eq_of_le stopped_process_eq_of_le\n\n",
 "stopped_process_eq_of_ge":
 "theorem stopped_process_eq_of_ge {u : Î¹ â†’ Î© â†’ Î²} {Ï„ : Î© â†’ Î¹} {i : Î¹} {Ï‰ : Î©} (h : Ï„ Ï‰ â‰¤ i) :\n    stopped_process u Ï„ i Ï‰ = u (Ï„ Ï‰) Ï‰ := by simp [stopped_process, min_eq_right h]\n#align stopped_process_eq_of_ge stopped_process_eq_of_ge\n\n",
 "stopped_process_eq''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq'' [linear_order Î¹] [LocallyFiniteOrderBot Î¹] [AddCommMonoid E] (n : Î¹) :\n    stopped_process u Ï„ n =\n      Set.indicator { a | n â‰¤ Ï„ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.Iio n)\n          (Set.indicator { Ï‰ | Ï„ Ï‰ = i } (u i)) :=\n  by\n  have h_mem : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ Finset.Iio n := fun Ï‰ h => finset.mem_Iio.mpr h\n  rw [stopped_process_eq_of_mem_finset n h_mem]\n  swap; Â· infer_instance\n  congr with i\n  simp only [Finset.Iio_filter_lt, min_eq_right]\n#align stopped_process_eq'' stopped_process_eq''\n\n",
 "stopped_process_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq' (n : â„•) :\n    stopped_process u Ï„ n =\n      Set.indicator { a | n + 1 â‰¤ Ï„ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (Finset.range (n + 1)) (Set.indicator { a | Ï„ a = i } (u i)) :=\n  by\n  have : { a | n â‰¤ Ï„ a }.indicator (u n) = { a | n + 1 â‰¤ Ï„ a }.indicator (u n) + { a | Ï„ a = n }.indicator (u n) :=\n    by\n    ext x\n    rw [add_comm, Pi.add_apply, â† Set.indicator_union_of_not_mem_inter]\n    Â· simp_rw [@eq_comm _ _ n, @le_iff_eq_or_lt _ _ n, Nat.succ_le_iff]\n      rfl\n    Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n      exact (Nat.succ_le_iff.1 hâ‚‚).ne hâ‚.symm\n  rw [stopped_process_eq, this, Finset.sum_range_succ_comm, â† add_assoc]\n#align stopped_process_eq' stopped_process_eq'\n\n",
 "stopped_process_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem stopped_process_eq (n : â„•) :\n    stopped_process u Ï„ n =\n      Set.indicator { a | n â‰¤ Ï„ a } (u n) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (Set.indicator { Ï‰ | Ï„ Ï‰ = i } (u i)) :=\n  by\n  rw [stopped_process_eq'' n]\n  swap; Â· infer_instance\n  congr with i\n  rw [Finset.mem_Iio, Finset.mem_range]\n#align stopped_process_eq stopped_process_eq\n\n",
 "stopped_process":
 "/-- The stopped process of an adapted process with continuous paths is adapted. -/\ntheorem adapted.stopped_process [metrizable_space Î¹] (hu : adapted f u) (hu_cont : âˆ€ Ï‰, Continuous fun i => u i Ï‰)\n    (hÏ„ : is_stopping_time f Ï„) : adapted f (stopped_process u Ï„) :=\n  ((hu.prog_measurable_of_continuous hu_cont).stopped_process hÏ„).adapted\n#align adapted.stopped_process adapted.stopped_process\n\n",
 "prog_measurable_min_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\ntheorem prog_measurable_min_stopping_time [metrizable_space Î¹] (hÏ„ : is_stopping_time f Ï„) :\n    prog_measurable f fun i Ï‰ => min i (Ï„ Ï‰) := by\n  intro i\n  let m_prod : MeasurableSpace (Set.Iic i Ã— Î©) := MeasurableSpace.prod _ (f i)\n  let m_set : âˆ€ t : Set (Set.Iic i Ã— Î©), MeasurableSpace t := fun _ =>\n    @Subtype.instMeasurableSpace (Set.Iic i Ã— Î©) _ m_prod\n  let s := { p : Set.Iic i Ã— Î© | Ï„ p.2 â‰¤ i }\n  have hs : (measurable_set_of m_prod) s := @measurable_snd (Set.Iic i) Î© _ (f i) _ (hÏ„ i)\n  have h_meas_fst : âˆ€ t : Set (Set.Iic i Ã— Î©), (measurable_of (m_set t)) fun x : t => ((x : Set.Iic i Ã— Î©).fst : Î¹) :=\n    fun t => (@measurable_subtype_coe (Set.Iic i Ã— Î©) m_prod _).fst.subtype_coe\n  apply measurable.strongly_measurable\n  refine' measurable_of_restrict_of_restrict_compl hs _ _\n  Â· refine' @measurable.min _ _ _ _ _ (m_set s) _ _ _ _ _ (h_meas_fst s) _\n    refine' @measurable_of_Iic Î¹ s _ _ _ (m_set s) _ _ _ _ fun j => _\n    have h_set_eq :\n      Â«expr â»Â¹' Â» (fun x : s => Ï„ (x : Set.Iic i Ã— Î©).snd) (Set.Iic j) =\n        Â«expr â»Â¹' Â» (fun x : s => (x : Set.Iic i Ã— Î©).snd) { Ï‰ | Ï„ Ï‰ â‰¤ min i j } :=\n      by\n      ext1 Ï‰\n      simp only [Set.mem_preimage, Set.mem_Iic, iff_and_self, le_min_iff, Set.mem_setOf_eq]\n      exact fun _ => Ï‰.prop\n    rw [h_set_eq]\n    suffices h_meas : @Measurable _ _ (m_set s) (f i) fun x : s => (x : Set.Iic i Ã— Î©).snd\n    exact h_meas (f.mono (min_le_left _ _) _ (hÏ„.measurable_set_le (min i j)))\n    exact measurable_snd.comp (@measurable_subtype_coe _ m_prod _)\n  Â· suffices h_min_eq_left :\n      (fun x : Â«expr á¶œÂ» s => min (â†‘(x : Set.Iic i Ã— Î©).fst) (Ï„ (x : Set.Iic i Ã— Î©).snd)) = fun x : Â«expr á¶œÂ» s =>\n        â†‘(x : Set.Iic i Ã— Î©).fst\n    Â· rw [Set.restrict, h_min_eq_left]\n      exact h_meas_fst _\n    ext1 Ï‰\n    rw [min_eq_left]\n    have hx_fst_le : â†‘(Ï‰ : Set.Iic i Ã— Î©).fst â‰¤ i := (Ï‰ : Set.Iic i Ã— Î©).fst.prop\n    refine' hx_fst_le.trans (le_of_lt _)\n    convert Ï‰.prop\n    simp only [not_le, Set.mem_compl_iff, Set.mem_setOf_eq]\n#align prog_measurable_min_stopping_time prog_measurable_min_stopping_time\n\n",
 "piecewise_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- Given stopping times `Ï„` and `Î·` which are bounded below, `set.piecewise s Ï„ Î·` is also\na stopping time with respect to the same filtration. -/\ntheorem is_stopping_time.piecewise_of_le (hÏ„_st : is_stopping_time ğ’¢ Ï„) (hÎ·_st : is_stopping_time ğ’¢ Î·)\n    (hÏ„ : âˆ€ Ï‰, i â‰¤ Ï„ Ï‰) (hÎ· : âˆ€ Ï‰, i â‰¤ Î· Ï‰) (hs : (measurable_set_of (ğ’¢ i)) s) : is_stopping_time ğ’¢ (s.piecewise Ï„ Î·) :=\n  by\n  intro n\n  have : { Ï‰ | s.piecewise Ï„ Î· Ï‰ â‰¤ n } = s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ n } âˆª Â«expr á¶œÂ» s âˆ© { Ï‰ | Î· Ï‰ â‰¤ n } :=\n    by\n    ext1 Ï‰\n    simp only [Set.piecewise, Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    by_cases hx : Ï‰ âˆˆ s <;> simp [hx]\n  rw [this]\n  by_cases hin : i â‰¤ n\n  Â· have hs_n : (measurable_set_of (ğ’¢ n)) s := ğ’¢.mono hin _ hs\n    exact (hs_n.inter (hÏ„_st n)).union (hs_n.compl.inter (hÎ·_st n))\n  Â· have hÏ„n : âˆ€ Ï‰, Â¬Ï„ Ï‰ â‰¤ n := fun Ï‰ hÏ„n => hin ((hÏ„ Ï‰).trans hÏ„n)\n    have hÎ·n : âˆ€ Ï‰, Â¬Î· Ï‰ â‰¤ n := fun Ï‰ hÎ·n => hin ((hÎ· Ï‰).trans hÎ·n)\n    simp [hÏ„n, hÎ·n]\n#align is_stopping_time.piecewise_of_le is_stopping_time.piecewise_of_le\n\n",
 "min_const":
 "protected theorem min_const [linear_order Î¹] {f : filtration Î¹ m} {Ï„ : Î© â†’ Î¹} (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    is_stopping_time f fun Ï‰ => min (Ï„ Ï‰) i :=\n  hÏ„.min (is_stopping_time_const f i)\n#align min_const min_const\n\n",
 "min":
 "protected theorem min [linear_order Î¹] {f : filtration Î¹ m} {Ï„ Ï€ : Î© â†’ Î¹} (hÏ„ : is_stopping_time f Ï„)\n    (hÏ€ : is_stopping_time f Ï€) : is_stopping_time f fun Ï‰ => min (Ï„ Ï‰) (Ï€ Ï‰) :=\n  by\n  intro i\n  simp_rw [min_le_iff, Set.setOf_or]\n  exact (hÏ„ i).union (hÏ€ i)\n#align min min\n\n",
 "mem_â„’p_stopped_value_of_mem_finset":
 "theorem mem_â„’p_stopped_value_of_mem_finset (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, mem_â„’p (u n) p Î¼) {s : Finset Î¹}\n    (hbdd : âˆ€ Ï‰, Ï„ Ï‰ âˆˆ s) : mem_â„’p (stopped_value u Ï„) p Î¼ :=\n  by\n  rw [stopped_value_eq_of_mem_finset hbdd]\n  swap; infer_instance\n  refine' mem_â„’p_finset_sum' _ fun i hi => mem_â„’p.indicator _ (hu i)\n  refine' â„±.le i { a : Î© | Ï„ a = i } (hÏ„.measurable_set_eq_of_countable_range _ i)\n  refine' ((Finset.finite_toSet s).subset fun Ï‰ hÏ‰ => _).countable\n  obtain âŸ¨y, rflâŸ© := hÏ‰\n  exact hbdd y\n#align mem_â„’p_stopped_value_of_mem_finset mem_â„’p_stopped_value_of_mem_finset\n\n",
 "mem_â„’p_stopped_value":
 "theorem mem_â„’p_stopped_value [LocallyFiniteOrderBot Î¹] (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, mem_â„’p (u n) p Î¼) {N : Î¹}\n    (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) : mem_â„’p (stopped_value u Ï„) p Î¼ :=\n  mem_â„’p_stopped_value_of_mem_finset hÏ„ hu fun Ï‰ => Finset.mem_Iic.mpr (hbdd Ï‰)\n#align mem_â„’p_stopped_value mem_â„’p_stopped_value\n\n",
 "mem_â„’p_stopped_process_of_mem_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_â„’p_stopped_process_of_mem_finset (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, mem_â„’p (u n) p Î¼) (n : Î¹)\n    {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ s) : mem_â„’p (stopped_process u Ï„ n) p Î¼ :=\n  by\n  rw [stopped_process_eq_of_mem_finset n hbdd]\n  swap; Â· infer_instance\n  refine' mem_â„’p.add _ _\n  Â· exact mem_â„’p.indicator (â„±.le n { a : Î© | n â‰¤ Ï„ a } (hÏ„.measurable_set_ge n)) (hu n)\n  Â· suffices\n      mem_â„’p\n        (fun Ï‰ =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (s.filter (Â· < n)) ({ a : Î© | Ï„ a = i }.indicator (u i) Ï‰))\n        p Î¼\n      by\n      convert this\n      ext1 Ï‰\n      simp only [Finset.sum_apply]\n    refine' mem_â„’p_finset_sum _ fun i hi => mem_â„’p.indicator _ (hu i)\n    exact â„±.le i { a : Î© | Ï„ a = i } (hÏ„.measurable_set_eq i)\n#align mem_â„’p_stopped_process_of_mem_finset mem_â„’p_stopped_process_of_mem_finset\n\n",
 "mem_â„’p_stopped_process":
 "theorem mem_â„’p_stopped_process [LocallyFiniteOrderBot Î¹] (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, mem_â„’p (u n) p Î¼)\n    (n : Î¹) : mem_â„’p (stopped_process u Ï„ n) p Î¼ :=\n  mem_â„’p_stopped_process_of_mem_finset hÏ„ hu n fun Ï‰ h => Finset.mem_Iio.mpr h\n#align mem_â„’p_stopped_process mem_â„’p_stopped_process\n\n",
 "measurable_stopped_value":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\ntheorem measurable_stopped_value [metrizable_space Î²] [MeasurableSpace Î²] [borel_space Î²]\n    (hf_prog : prog_measurable f u) (hÏ„ : is_stopping_time f Ï„) :\n    (measurable_of hÏ„.measurable_space) (stopped_value u Ï„) :=\n  by\n  have h_str_meas : âˆ€ i, (strongly_measurable_of (f i)) (stopped_value u fun Ï‰ => min (Ï„ Ï‰) i) := fun i =>\n    strongly_measurable_stopped_value_of_le hf_prog (hÏ„.min_const i) fun _ => min_le_right _ _\n  intro t ht i\n  suffices\n    Â«expr â»Â¹' Â» (stopped_value u Ï„) t âˆ© { Ï‰ : Î© | Ï„ Ï‰ â‰¤ i } =\n      Â«expr â»Â¹' Â» (stopped_value u fun Ï‰ => min (Ï„ Ï‰) i) t âˆ© { Ï‰ : Î© | Ï„ Ï‰ â‰¤ i }\n    by\n    rw [this]\n    exact ((h_str_meas i).measurable ht).inter (hÏ„.measurable_set_le i)\n  ext1 Ï‰\n  simp only [stopped_value, Set.mem_inter_iff, Set.mem_preimage, Set.mem_setOf_eq, and_congr_left_iff]\n  intro h\n  rw [min_eq_left h]\n#align measurable_stopped_value measurable_stopped_value\n\n",
 "measurable_space_mono":
 "theorem measurable_space_mono (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) (hle : Ï„ â‰¤ Ï€) :\n    hÏ„.measurable_space â‰¤ hÏ€.measurable_space := by\n  intro s hs i\n  rw [(_ : s âˆ© { Ï‰ | Ï€ Ï‰ â‰¤ i } = s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i } âˆ© { Ï‰ | Ï€ Ï‰ â‰¤ i })]\n  Â· exact (hs i).inter (hÏ€ i)\n  Â· ext\n    simp only [Set.mem_inter_iff, iff_self_and, and_congr_left_iff, Set.mem_setOf_eq]\n    intro hle' _\n    exact le_trans (hle _) hle'\n#align measurable_space_mono measurable_space_mono\n\n",
 "measurable_space_min_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem measurable_space_min_const (hÏ„ : is_stopping_time f Ï„) {i : Î¹} :\n    (hÏ„.min_const i).measurable_space = Â«expr âŠ“ Â» hÏ„.measurable_space (f i) := by\n  rw [hÏ„.measurable_space_min (is_stopping_time_const _ i), measurable_space_const]\n#align measurable_space_min_const measurable_space_min_const\n\n",
 "measurable_space_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âŠ“ Â» -/\ntheorem measurable_space_min (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) :\n    (hÏ„.min hÏ€).measurable_space = Â«expr âŠ“ Â» hÏ„.measurable_space hÏ€.measurable_space :=\n  by\n  refine' le_antisymm _ _\n  Â·\n    exact\n      le_inf (measurable_space_mono _ hÏ„ fun _ => min_le_left _ _)\n        (measurable_space_mono _ hÏ€ fun _ => min_le_right _ _)\n  Â· intro s\n    change\n      (measurable_set_of hÏ„.measurable_space) s âˆ§ (measurable_set_of hÏ€.measurable_space) s â†’\n        (measurable_set_of (hÏ„.min hÏ€).measurable_space) s\n    simp_rw [is_stopping_time.measurable_set]\n    have : âˆ€ i, { Ï‰ | min (Ï„ Ï‰) (Ï€ Ï‰) â‰¤ i } = { Ï‰ | Ï„ Ï‰ â‰¤ i } âˆª { Ï‰ | Ï€ Ï‰ â‰¤ i } :=\n      by\n      intro i\n      ext1 Ï‰\n      simp\n    simp_rw [this, Set.inter_union_distrib_left]\n    exact fun h i => (h.left i).union (h.right i)\n#align measurable_space_min measurable_space_min\n\n",
 "measurable_space_le_of_le_const":
 "theorem measurable_space_le_of_le_const (hÏ„ : is_stopping_time f Ï„) {i : Î¹} (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ i) :\n    hÏ„.measurable_space â‰¤ f i :=\n  (measurable_space_mono hÏ„ _ hÏ„_le).trans (measurable_space_const _ _).le\n#align measurable_space_le_of_le_const measurable_space_le_of_le_const\n\n",
 "measurable_space_le_of_le":
 "theorem measurable_space_le_of_le (hÏ„ : is_stopping_time f Ï„) {n : Î¹} (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ n) :\n    hÏ„.measurable_space â‰¤ m :=\n  (hÏ„.measurable_space_le_of_le_const hÏ„_le).trans (f.le n)\n#align measurable_space_le_of_le measurable_space_le_of_le\n\n",
 "measurable_space_le_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\nprotected theorem measurable_space_le_of_countable_range (hÏ„ : is_stopping_time f Ï„)\n    (h_countable : (Set.range Ï„).countable) : hÏ„.measurable_space â‰¤ m :=\n  by\n  intro s hs\n  change âˆ€ i, (measurable_set_of (f i)) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }) at hs\n  rw [(_ :\n      s =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }))]\n  Â· exact MeasurableSet.bunionáµ¢ h_countable fun i _ => f.le i _ (hs i)\n  Â· ext Ï‰\n    constructor <;> rw [Set.mem_unionáµ¢]\n    Â· exact fun hx => âŸ¨Ï„ Ï‰, by simpa using hxâŸ©\n    Â· rintro âŸ¨i, hxâŸ©\n      simp only [Set.mem_range, Set.unionáµ¢_exists, Set.mem_unionáµ¢, Set.mem_inter_iff, Set.mem_setOf_eq, exists_prop,\n        exists_and_right] at hx\n      exact hx.1.2\n#align measurable_space_le_of_countable_range measurable_space_le_of_countable_range\n\n",
 "measurable_space_le_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem measurable_space_le_of_countable [Countable Î¹] (hÏ„ : is_stopping_time f Ï„) : hÏ„.measurable_space â‰¤ m :=\n  by\n  intro s hs\n  change âˆ€ i, (measurable_set_of (f i)) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }) at hs\n  rw [(_ :\n      s =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }))]\n  Â· exact MeasurableSet.unionáµ¢ fun i => f.le i _ (hs i)\n  Â· ext Ï‰\n    constructor <;> rw [Set.mem_unionáµ¢]\n    Â· exact fun hx => âŸ¨Ï„ Ï‰, hx, le_rflâŸ©\n    Â· rintro âŸ¨_, hx, _âŸ©\n      exact hx\n#align measurable_space_le_of_countable measurable_space_le_of_countable\n\n",
 "measurable_space_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\ntheorem measurable_space_le' [IsCountablyGenerated (atTop : Filter Î¹)] [(atTop : Filter Î¹).ne_bot]\n    (hÏ„ : is_stopping_time f Ï„) : hÏ„.measurable_space â‰¤ m :=\n  by\n  intro s hs\n  change âˆ€ i, (measurable_set_of (f i)) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }) at hs\n  obtain âŸ¨seq : â„• â†’ Î¹, h_seq_tendstoâŸ© := at_top.exists_seq_tendsto\n  rw [(_ :\n      s =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ seq n }))]\n  Â· exact MeasurableSet.unionáµ¢ fun i => f.le (seq i) _ (hs (seq i))\n  Â· ext Ï‰\n    constructor <;> rw [Set.mem_unionáµ¢]\n    Â· intro hx\n      suffices : âˆƒ i, Ï„ Ï‰ â‰¤ seq i\n      exact âŸ¨this.some, hx, this.some_specâŸ©\n      rw [tendsto_at_top] at h_seq_tendsto\n      exact (h_seq_tendsto (Ï„ Ï‰)).exists\n    Â· rintro âŸ¨_, hx, _âŸ©\n      exact hx\n  all_goals infer_instance\n#align measurable_space_le' measurable_space_le'\n\n",
 "measurable_space_le":
 "theorem measurable_space_le {Î¹} [SemilatticeSup Î¹] {f : filtration Î¹ m} {Ï„ : Î© â†’ Î¹}\n    [IsCountablyGenerated (atTop : Filter Î¹)] (hÏ„ : is_stopping_time f Ï„) : hÏ„.measurable_space â‰¤ m :=\n  by\n  cases isEmpty_or_nonempty Î¹\n  Â· haveI : IsEmpty Î© := âŸ¨fun Ï‰ => is_empty.false (Ï„ Ï‰)âŸ©\n    intro s hsÏ„\n    suffices hs : s = âˆ…\n    Â· rw [hs]\n      exact MeasurableSet.empty\n    haveI : Unique (Set Î©) := Set.uniqueEmpty\n    rw [Unique.eq_default s, Unique.eq_default âˆ…]\n  exact measurable_space_le' hÏ„\n#align measurable_space_le measurable_space_le\n\n",
 "measurable_space_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n@[simp]\ntheorem measurable_space_const (f : filtration Î¹ m) (i : Î¹) : (is_stopping_time_const f i).measurable_space = f i :=\n  by\n  ext1 s\n  change (measurable_set_of (is_stopping_time_const f i).measurable_space) s â†” (measurable_set_of (f i)) s\n  rw [is_stopping_time.measurable_set]\n  constructor <;> intro h\n  Â· specialize h i\n    simpa only [le_refl, Set.setOf_true, Set.inter_univ] using h\n  Â· intro j\n    by_cases hij : i â‰¤ j\n    Â· simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    Â· simp only [hij, Set.setOf_false, Set.inter_empty, MeasurableSet.empty]\n#align measurable_space_const measurable_space_const\n\n",
 "measurable_set_stopping_time_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_stopping_time_le [TopologicalSpace Î¹] [SecondCountableTopology Î¹] [OrderTopology Î¹]\n    [MeasurableSpace Î¹] [borel_space Î¹] (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) :\n    (measurable_set_of hÏ€.measurable_space) { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } :=\n  by\n  suffices (measurable_set_of (hÏ„.min hÏ€).measurable_space) { Ï‰ : Î© | Ï„ Ï‰ â‰¤ Ï€ Ï‰ }\n    by\n    rw [measurable_set_min_iff hÏ„ hÏ€] at this\n    exact this.2\n  rw [â† Set.univ_inter { Ï‰ : Î© | Ï„ Ï‰ â‰¤ Ï€ Ï‰ }, â† hÏ„.measurable_set_inter_le_iff hÏ€, Set.univ_inter]\n  exact measurable_set_le_stopping_time hÏ„ hÏ€\n#align measurable_set_stopping_time_le measurable_set_stopping_time_le\n\n",
 "measurable_set_min_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_min_iff (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) (s : Set Î©) :\n    (measurable_set_of (hÏ„.min hÏ€).measurable_space) s â†”\n      (measurable_set_of hÏ„.measurable_space) s âˆ§ (measurable_set_of hÏ€.measurable_space) s :=\n  by\n  rw [measurable_space_min]\n  rfl\n#align measurable_set_min_iff measurable_set_min_iff\n\n",
 "measurable_set_min_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_min_const_iff (hÏ„ : is_stopping_time f Ï„) (s : Set Î©) {i : Î¹} :\n    (measurable_set_of (hÏ„.min_const i).measurable_space) s â†”\n      (measurable_set_of hÏ„.measurable_space) s âˆ§ (measurable_set_of (f i)) s :=\n  by rw [measurable_space_min_const, MeasurableSpace.measurableSet_inf]\n#align measurable_set_min_const_iff measurable_set_min_const_iff\n\n",
 "measurable_set_lt_of_pred":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_lt_of_pred [PredOrder Î¹] (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ < i } :=\n  by\n  by_cases hi_min : IsMin i\n  Â· suffices { Ï‰ : Î© | Ï„ Ï‰ < i } = âˆ… by\n      rw [this]\n      exact @MeasurableSet.empty _ (f i)\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    rw [isMin_iff_forall_not_lt] at hi_min\n    exact hi_min (Ï„ Ï‰)\n  have : { Ï‰ : Î© | Ï„ Ï‰ < i } = Â«expr â»Â¹' Â» Ï„ (Set.Iio i) := rfl\n  rw [this, â† Iic_pred_of_not_is_min hi_min]\n  exact f.mono (pred_le i) _ (hÏ„.measurable_set_le <| pred i)\n#align is_stopping_time.measurable_set_lt_of_pred is_stopping_time.measurable_set_lt_of_pred\n\n",
 "measurable_set_lt_of_is_lub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/-- Auxiliary lemma for `is_stopping_time.measurable_set_lt`. -/\ntheorem is_stopping_time.measurable_set_lt_of_is_lub (hÏ„ : is_stopping_time f Ï„) (i : Î¹) (h_lub : IsLUB (Set.Iio i) i) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ < i } :=\n  by\n  by_cases hi_min : IsMin i\n  Â· suffices { Ï‰ | Ï„ Ï‰ < i } = âˆ… by\n      rw [this]\n      exact @MeasurableSet.empty _ (f i)\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    exact is_min_iff_forall_not_lt.mp hi_min (Ï„ Ï‰)\n  obtain âŸ¨seq, -, -, h_tendsto, h_boundâŸ© :\n    âˆƒ seq : â„• â†’ Î¹, Monotone seq âˆ§ (âˆ€ j, seq j â‰¤ i) âˆ§ tendsto seq at_top ((nhds) i) âˆ§ âˆ€ j, seq j < i\n  exact h_lub.exists_seq_monotone_tendsto (not_is_min_iff.mp hi_min)\n  have h_Ioi_eq_Union :\n    Set.Iio i =\n      Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n        { k | k â‰¤ seq j } :=\n    by\n    ext1 k\n    simp only [Set.mem_Iio, Set.mem_unionáµ¢, Set.mem_setOf_eq]\n    refine' âŸ¨fun hk_lt_i => _, fun h_exists_k_le_seq => _âŸ©\n    Â· rw [tendsto_at_top'] at h_tendsto\n      have h_nhds : Set.Ici k âˆˆ (nhds) i := mem_nhds_iff.mpr âŸ¨Set.Ioi k, Set.Ioi_subset_Ici le_rfl, isOpen_Ioi, hk_lt_iâŸ©\n      obtain âŸ¨a, haâŸ© : âˆƒ a : â„•, âˆ€ b : â„•, b â‰¥ a â†’ k â‰¤ seq b := h_tendsto (Set.Ici k) h_nhds\n      exact âŸ¨a, ha a le_rflâŸ©\n    Â· obtain âŸ¨j, hk_seq_jâŸ© := h_exists_k_le_seq\n      exact hk_seq_j.trans_lt (h_bound j)\n  have h_lt_eq_preimage : { Ï‰ | Ï„ Ï‰ < i } = Â«expr â»Â¹' Â» Ï„ (Set.Iio i) :=\n    by\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_Iio]\n  rw [h_lt_eq_preimage, h_Ioi_eq_Union]\n  simp only [Set.preimage_unionáµ¢, Set.preimage_setOf_eq]\n  exact MeasurableSet.unionáµ¢ fun n => f.mono (h_bound n).le _ (hÏ„.measurable_set_le (seq n))\n#align is_stopping_time.measurable_set_lt_of_is_lub is_stopping_time.measurable_set_lt_of_is_lub\n\n",
 "measurable_set_lt_of_countable_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable_range' (hÏ„ : is_stopping_time f Ï„)\n    (h_countable : (Set.range Ï„).countable) (i : Î¹) : (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ < i } :=\n  by\n  have : { Ï‰ | Ï„ Ï‰ < i } = { Ï‰ | Ï„ Ï‰ â‰¤ i } \\ { Ï‰ | Ï„ Ï‰ = i } :=\n    by\n    ext1 Ï‰\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hÏ„.measurable_set_le' i).diff (hÏ„.measurable_set_eq_of_countable_range' h_countable i)\n#align measurable_set_lt_of_countable_range' measurable_set_lt_of_countable_range'\n\n",
 "measurable_set_lt_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable_range (hÏ„ : is_stopping_time f Ï„)\n    (h_countable : (Set.range Ï„).countable) (i : Î¹) : (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ < i } :=\n  by\n  have : { Ï‰ | Ï„ Ï‰ < i } = { Ï‰ | Ï„ Ï‰ â‰¤ i } \\ { Ï‰ | Ï„ Ï‰ = i } :=\n    by\n    ext1 Ï‰\n    simp [lt_iff_le_and_ne]\n  rw [this]\n  exact (hÏ„.measurable_set_le i).diff (hÏ„.measurable_set_eq_of_countable_range h_countable i)\n#align measurable_set_lt_of_countable_range measurable_set_lt_of_countable_range\n\n",
 "measurable_set_lt_of_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable' [Countable Î¹] (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ < i } :=\n  hÏ„.measurable_set_lt_of_countable_range' (Set.to_countable _) i\n#align measurable_set_lt_of_countable' measurable_set_lt_of_countable'\n\n",
 "measurable_set_lt_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt_of_countable [Countable Î¹] (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ < i } :=\n  hÏ„.measurable_set_lt_of_countable_range (Set.to_countable _) i\n#align measurable_set_lt_of_countable measurable_set_lt_of_countable\n\n",
 "measurable_set_lt_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_lt_le (hÏ„ : is_stopping_time f Ï„) {i j : Î¹} (hle : i â‰¤ j) :\n    (measurable_set_of (f j)) { Ï‰ | Ï„ Ï‰ < i } :=\n  f.mono hle _ <| hÏ„.measurable_set_lt i\n#align is_stopping_time.measurable_set_lt_le is_stopping_time.measurable_set_lt_le\n\n",
 "measurable_set_lt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_lt' [TopologicalSpace Î¹] [OrderTopology Î¹] [FirstCountableTopology Î¹]\n    (hÏ„ : is_stopping_time f Ï„) (i : Î¹) : (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ < i } :=\n  by\n  have : { Ï‰ | Ï„ Ï‰ < i } = { Ï‰ | Ï„ Ï‰ â‰¤ i } \\ { Ï‰ | Ï„ Ï‰ = i } :=\n    by\n    ext1 Ï‰\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hÏ„.measurable_set_le' i).diff (hÏ„.measurable_set_eq' i)\n#align measurable_set_lt' measurable_set_lt'\n\n",
 "measurable_set_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â»Â¹' Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_lt (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ < i } :=\n  by\n  obtain âŸ¨i', hi'_lubâŸ© : âˆƒ i', IsLUB (Set.Iio i) i'; exact exists_lub_Iio i\n  cases' lub_Iio_eq_self_or_Iio_eq_Iic i hi'_lub with hi'_eq_i h_Iio_eq_Iic\n  Â· rw [â† hi'_eq_i] at hi'_lubâŠ¢\n    exact hÏ„.measurable_set_lt_of_is_lub i' hi'_lub\n  Â· have h_lt_eq_preimage : { Ï‰ : Î© | Ï„ Ï‰ < i } = Â«expr â»Â¹' Â» Ï„ (Set.Iio i) := rfl\n    rw [h_lt_eq_preimage, h_Iio_eq_Iic]\n    exact f.mono (lub_Iio_le i hi'_lub) _ (hÏ„.measurable_set_le i')\n#align is_stopping_time.measurable_set_lt is_stopping_time.measurable_set_lt\n\n",
 "measurable_set_le_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_le_stopping_time [TopologicalSpace Î¹] [SecondCountableTopology Î¹] [OrderTopology Î¹]\n    [MeasurableSpace Î¹] [borel_space Î¹] (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } :=\n  by\n  rw [hÏ„.measurable_set]\n  intro j\n  have : { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ j } = { Ï‰ | min (Ï„ Ï‰) j â‰¤ min (Ï€ Ï‰) j } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ j } :=\n    by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, min_le_iff, le_min_iff, le_refl, and_true_iff, and_congr_left_iff]\n    intro h\n    simp only [h, or_self_iff, and_true_iff]\n    by_cases hj : j â‰¤ Ï€ Ï‰\n    Â· simp only [hj, h.trans hj, or_self_iff]\n    Â· simp only [hj, or_false_iff]\n  rw [this]\n  refine' MeasurableSet.inter _ (hÏ„.measurable_set_le j)\n  apply measurable_set_le\n  Â· exact (hÏ„.min_const j).measurable_of_le fun _ => min_le_right _ _\n  Â· exact (hÏ€.min_const j).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_le_stopping_time measurable_set_le_stopping_time\n\n",
 "measurable_set_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_le' (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ â‰¤ i } :=\n  by\n  intro j\n  have : { Ï‰ : Î© | Ï„ Ï‰ â‰¤ i } âˆ© { Ï‰ : Î© | Ï„ Ï‰ â‰¤ j } = { Ï‰ : Î© | Ï„ Ï‰ â‰¤ min i j } :=\n    by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff]\n  rw [this]\n  exact f.mono (min_le_right i j) _ (hÏ„ _)\n#align measurable_set_le' measurable_set_le'\n\n",
 "measurable_set_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem is_stopping_time.measurable_set_le (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ â‰¤ i } :=\n  hÏ„ i\n#align is_stopping_time.measurable_set_le is_stopping_time.measurable_set_le\n\n",
 "measurable_set_inter_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_le_iff [TopologicalSpace Î¹] [SecondCountableTopology Î¹] [OrderTopology Î¹]\n    [MeasurableSpace Î¹] [borel_space Î¹] (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) (s : Set Î©) :\n    (measurable_set_of hÏ„.measurable_space) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ }) â†”\n      (measurable_set_of (hÏ„.min hÏ€).measurable_space) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ }) :=\n  by\n  constructor <;> intro h\n  Â· have : s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } = s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } := by rw [Set.inter_assoc, Set.inter_self]\n    rw [this]\n    exact measurable_set_inter_le _ _ _ h\n  Â· rw [measurable_set_min_iff] at h\n    exact h.1\n#align measurable_set_inter_le_iff measurable_set_inter_le_iff\n\n",
 "measurable_set_inter_le_const_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_le_const_iff (hÏ„ : is_stopping_time f Ï„) (s : Set Î©) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }) â†”\n      (measurable_set_of (hÏ„.min_const i).measurable_space) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }) :=\n  by\n  rw [is_stopping_time.measurable_set_min_iff hÏ„ (is_stopping_time_const _ i), is_stopping_time.measurable_space_const,\n    is_stopping_time.measurable_set]\n  refine' âŸ¨fun h => âŸ¨h, _âŸ©, fun h j => h.1 jâŸ©\n  specialize h i\n  rwa [Set.inter_assoc, Set.inter_self] at h\n#align measurable_set_inter_le_const_iff measurable_set_inter_le_const_iff\n\n",
 "measurable_set_inter_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_le [TopologicalSpace Î¹] [SecondCountableTopology Î¹] [OrderTopology Î¹] [MeasurableSpace Î¹]\n    [borel_space Î¹] (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) (s : Set Î©)\n    (hs : (measurable_set_of hÏ„.measurable_space) s) :\n    (measurable_set_of (hÏ„.min hÏ€).measurable_space) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ }) :=\n  by\n  simp_rw [is_stopping_time.measurable_set] at hsâŠ¢\n  intro i\n  have :\n    s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰ } âˆ© { Ï‰ | min (Ï„ Ï‰) (Ï€ Ï‰) â‰¤ i } =\n      s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i } âˆ© { Ï‰ | min (Ï„ Ï‰) (Ï€ Ï‰) â‰¤ i } âˆ© { Ï‰ | min (Ï„ Ï‰) i â‰¤ min (min (Ï„ Ï‰) (Ï€ Ï‰)) i } :=\n    by\n    ext1 Ï‰\n    simp only [min_le_iff, Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff, le_refl, true_and_iff, and_true_iff,\n      true_or_iff, or_true_iff]\n    by_cases hÏ„i : Ï„ Ï‰ â‰¤ i\n    Â· simp only [hÏ„i, true_or_iff, and_true_iff, and_congr_right_iff]\n      intro hx\n      constructor <;> intro h\n      Â· exact or.inl h\n      Â· cases h\n        Â· exact h\n        Â· exact hÏ„i.trans h\n    simp only [hÏ„i, false_or_iff, and_false_iff, false_and_iff, iff_false_iff, not_and, not_le, and_imp]\n    refine' fun hx hÏ„_le_Ï€ => lt_of_lt_of_le _ hÏ„_le_Ï€\n    rw [â† not_le]\n    exact hÏ„i\n  rw [this]\n  refine' ((hs i).inter ((hÏ„.min hÏ€) i)).inter _\n  apply measurable_set_le\n  Â· exact (hÏ„.min_const i).measurable_of_le fun _ => min_le_right _ _\n  Â· exact ((hÏ„.min hÏ€).min_const i).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_inter_le measurable_set_inter_le\n\n",
 "measurable_set_inter_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_inter_eq_iff (hÏ„ : is_stopping_time f Ï„) (s : Set Î©) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) (s âˆ© { Ï‰ | Ï„ Ï‰ = i }) â†” (measurable_set_of (f i)) (s âˆ© { Ï‰ | Ï„ Ï‰ = i }) :=\n  by\n  have : âˆ€ j, { Ï‰ : Î© | Ï„ Ï‰ = i } âˆ© { Ï‰ : Î© | Ï„ Ï‰ â‰¤ j } = { Ï‰ : Î© | Ï„ Ï‰ = i } âˆ© { Ï‰ | i â‰¤ j } :=\n    by\n    intro j\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    intro hxi\n    rw [hxi]\n  constructor <;> intro h\n  Â· specialize h i\n    simpa only [Set.inter_assoc, this, le_refl, Set.setOf_true, Set.inter_univ] using h\n  Â· intro j\n    rw [Set.inter_assoc, this]\n    by_cases hij : i â‰¤ j\n    Â· simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    Â· simp [hij]\n#align measurable_set_inter_eq_iff measurable_set_inter_eq_iff\n\n",
 "measurable_set_gt'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_gt' (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | i < Ï„ Ï‰ } :=\n  by\n  have : { Ï‰ : Î© | i < Ï„ Ï‰ } = Â«expr á¶œÂ» { Ï‰ : Î© | Ï„ Ï‰ â‰¤ i } :=\n    by\n    ext1 Ï‰\n    simp\n  rw [this]\n  exact (hÏ„.measurable_set_le' i).compl\n#align measurable_set_gt' measurable_set_gt'\n\n",
 "measurable_set_gt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_gt (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | i < Ï„ Ï‰ } :=\n  by\n  have : { Ï‰ | i < Ï„ Ï‰ } = Â«expr á¶œÂ» { Ï‰ | Ï„ Ï‰ â‰¤ i } := by\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_le]\n  rw [this]\n  exact (hÏ„.measurable_set_le i).compl\n#align is_stopping_time.measurable_set_gt is_stopping_time.measurable_set_gt\n\n",
 "measurable_set_ge_of_countable_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable_range' (hÏ„ : is_stopping_time f Ï„)\n    (h_countable : (Set.range Ï„).countable) (i : Î¹) : (measurable_set_of hÏ„.measurable_space) { Ï‰ | i â‰¤ Ï„ Ï‰ } :=\n  by\n  have : { Ï‰ | i â‰¤ Ï„ Ï‰ } = { Ï‰ | Ï„ Ï‰ = i } âˆª { Ï‰ | i < Ï„ Ï‰ } :=\n    by\n    ext1 Ï‰\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm']\n  rw [this]\n  exact (hÏ„.measurable_set_eq_of_countable_range' h_countable i).union (hÏ„.measurable_set_gt' i)\n#align measurable_set_ge_of_countable_range' measurable_set_ge_of_countable_range'\n\n",
 "measurable_set_ge_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable_range {Î¹} [linear_order Î¹] {Ï„ : Î© â†’ Î¹} {f : filtration Î¹ m}\n    (hÏ„ : is_stopping_time f Ï„) (h_countable : (Set.range Ï„).countable) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | i â‰¤ Ï„ Ï‰ } :=\n  by\n  have : { Ï‰ | i â‰¤ Ï„ Ï‰ } = Â«expr á¶œÂ» { Ï‰ | Ï„ Ï‰ < i } := by\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hÏ„.measurable_set_lt_of_countable_range h_countable i).compl\n#align measurable_set_ge_of_countable_range measurable_set_ge_of_countable_range\n\n",
 "measurable_set_ge_of_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable' [Countable Î¹] (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | i â‰¤ Ï„ Ï‰ } :=\n  hÏ„.measurable_set_ge_of_countable_range' (Set.to_countable _) i\n#align measurable_set_ge_of_countable' measurable_set_ge_of_countable'\n\n",
 "measurable_set_ge_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge_of_countable {Î¹} [linear_order Î¹] {Ï„ : Î© â†’ Î¹} {f : filtration Î¹ m} [Countable Î¹]\n    (hÏ„ : is_stopping_time f Ï„) (i : Î¹) : (measurable_set_of (f i)) { Ï‰ | i â‰¤ Ï„ Ï‰ } :=\n  hÏ„.measurable_set_ge_of_countable_range (Set.to_countable _) i\n#align measurable_set_ge_of_countable measurable_set_ge_of_countable\n\n",
 "measurable_set_ge'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_ge' [TopologicalSpace Î¹] [OrderTopology Î¹] [FirstCountableTopology Î¹]\n    (hÏ„ : is_stopping_time f Ï„) (i : Î¹) : (measurable_set_of hÏ„.measurable_space) { Ï‰ | i â‰¤ Ï„ Ï‰ } :=\n  by\n  have : { Ï‰ | i â‰¤ Ï„ Ï‰ } = { Ï‰ | Ï„ Ï‰ = i } âˆª { Ï‰ | i < Ï„ Ï‰ } :=\n    by\n    ext1 Ï‰\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm']\n  rw [this]\n  exact (hÏ„.measurable_set_eq' i).union (hÏ„.measurable_set_gt' i)\n#align measurable_set_ge' measurable_set_ge'\n\n",
 "measurable_set_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr á¶œÂ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_ge (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | i â‰¤ Ï„ Ï‰ } :=\n  by\n  have : { Ï‰ | i â‰¤ Ï„ Ï‰ } = Â«expr á¶œÂ» { Ï‰ | Ï„ Ï‰ < i } := by\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hÏ„.measurable_set_lt i).compl\n#align is_stopping_time.measurable_set_ge is_stopping_time.measurable_set_ge\n\n",
 "measurable_set_eq_stopping_time_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_eq_stopping_time_of_countable [Countable Î¹] [TopologicalSpace Î¹] [MeasurableSpace Î¹]\n    [borel_space Î¹] [OrderTopology Î¹] [MeasurableSingletonClass Î¹] [SecondCountableTopology Î¹]\n    (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ = Ï€ Ï‰ } :=\n  by\n  rw [hÏ„.measurable_set]\n  intro j\n  have : { Ï‰ | Ï„ Ï‰ = Ï€ Ï‰ } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ j } = { Ï‰ | min (Ï„ Ï‰) j = min (Ï€ Ï‰) j } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ j } âˆ© { Ï‰ | Ï€ Ï‰ â‰¤ j } :=\n    by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine' âŸ¨fun h => âŸ¨âŸ¨_, h.2âŸ©, _âŸ©, fun h => âŸ¨_, h.1.2âŸ©âŸ©\n    Â· rw [h.1]\n    Â· rw [â† h.1]\n      exact h.2\n    Â· cases' h with h' hÏ€_le\n      cases' h' with h_eq hÏ„_le\n      rwa [min_eq_left hÏ„_le, min_eq_left hÏ€_le] at h_eq\n  rw [this]\n  refine' MeasurableSet.inter (MeasurableSet.inter _ (hÏ„.measurable_set_le j)) (hÏ€.measurable_set_le j)\n  apply measurableSet_eq_fun_of_countable\n  Â· exact (hÏ„.min_const j).measurable_of_le fun _ => min_le_right _ _\n  Â· exact (hÏ€.min_const j).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_eq_stopping_time_of_countable measurable_set_eq_stopping_time_of_countable\n\n",
 "measurable_set_eq_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem measurable_set_eq_stopping_time [AddGroup Î¹] [TopologicalSpace Î¹] [MeasurableSpace Î¹] [borel_space Î¹]\n    [OrderTopology Î¹] [MeasurableSingletonClass Î¹] [SecondCountableTopology Î¹] [MeasurableSubâ‚‚ Î¹]\n    (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ = Ï€ Ï‰ } :=\n  by\n  rw [hÏ„.measurable_set]\n  intro j\n  have : { Ï‰ | Ï„ Ï‰ = Ï€ Ï‰ } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ j } = { Ï‰ | min (Ï„ Ï‰) j = min (Ï€ Ï‰) j } âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ j } âˆ© { Ï‰ | Ï€ Ï‰ â‰¤ j } :=\n    by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine' âŸ¨fun h => âŸ¨âŸ¨_, h.2âŸ©, _âŸ©, fun h => âŸ¨_, h.1.2âŸ©âŸ©\n    Â· rw [h.1]\n    Â· rw [â† h.1]\n      exact h.2\n    Â· cases' h with h' hÏƒ_le\n      cases' h' with h_eq hÏ„_le\n      rwa [min_eq_left hÏ„_le, min_eq_left hÏƒ_le] at h_eq\n  rw [this]\n  refine' MeasurableSet.inter (MeasurableSet.inter _ (hÏ„.measurable_set_le j)) (hÏ€.measurable_set_le j)\n  apply measurableSet_eq_fun\n  Â· exact (hÏ„.min_const j).measurable_of_le fun _ => min_le_right _ _\n  Â· exact (hÏ€.min_const j).measurable_of_le fun _ => min_le_right _ _\n#align measurable_set_eq_stopping_time measurable_set_eq_stopping_time\n\n",
 "measurable_set_eq_of_countable_range'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable_range' (hÏ„ : is_stopping_time f Ï„)\n    (h_countable : (Set.range Ï„).countable) (i : Î¹) : (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ = i } :=\n  by\n  rw [â† Set.univ_inter { Ï‰ | Ï„ Ï‰ = i }, measurable_set_inter_eq_iff, Set.univ_inter]\n  exact hÏ„.measurable_set_eq_of_countable_range h_countable i\n#align measurable_set_eq_of_countable_range' measurable_set_eq_of_countable_range'\n\n",
 "measurable_set_eq_of_countable_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable_range (hÏ„ : is_stopping_time f Ï„)\n    (h_countable : (Set.range Ï„).countable) (i : Î¹) : (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ = i } :=\n  by\n  have :\n    { Ï‰ | Ï„ Ï‰ = i } =\n      { Ï‰ | Ï„ Ï‰ â‰¤ i } \\\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          { Ï‰ | Ï„ Ï‰ â‰¤ j } :=\n    by\n    ext1 a\n    simp only [Set.mem_setOf_eq, Set.mem_range, Set.unionáµ¢_exists, Set.unionáµ¢_unionáµ¢_eq', Set.mem_diff, Set.mem_unionáµ¢,\n      exists_prop, not_exists, not_and, not_le]\n    constructor <;> intro h\n    Â· simp only [h, lt_iff_le_not_le, le_refl, and_imp, imp_self, imp_true_iff, and_self_iff]\n    Â· have h_lt_or_eq : Ï„ a < i âˆ¨ Ï„ a = i := lt_or_eq_of_le h.1\n      rcases h_lt_or_eq with (h_lt | rfl)\n      Â· exfalso\n        exact h.2 a h_lt (le_refl (Ï„ a))\n      Â· rfl\n  rw [this]\n  refine' (hÏ„.measurable_set_le i).diff _\n  refine' MeasurableSet.bunionáµ¢ h_countable fun j hj => _\n  by_cases hji : j < i\n  Â· simp only [hji, Set.unionáµ¢_true]\n    exact f.mono hji.le _ (hÏ„.measurable_set_le j)\n  Â· simp only [hji, Set.unionáµ¢_false]\n    exact @MeasurableSet.empty _ (f i)\n#align measurable_set_eq_of_countable_range measurable_set_eq_of_countable_range\n\n",
 "measurable_set_eq_of_countable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable' [Countable Î¹] (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ = i } :=\n  hÏ„.measurable_set_eq_of_countable_range' (Set.to_countable _) i\n#align measurable_set_eq_of_countable' measurable_set_eq_of_countable'\n\n",
 "measurable_set_eq_of_countable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq_of_countable [Countable Î¹] (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ = i } :=\n  hÏ„.measurable_set_eq_of_countable_range (Set.to_countable _) i\n#align measurable_set_eq_of_countable measurable_set_eq_of_countable\n\n",
 "measurable_set_eq_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_eq_le (hÏ„ : is_stopping_time f Ï„) {i j : Î¹} (hle : i â‰¤ j) :\n    (measurable_set_of (f j)) { Ï‰ | Ï„ Ï‰ = i } :=\n  f.mono hle _ <| hÏ„.measurable_set_eq i\n#align is_stopping_time.measurable_set_eq_le is_stopping_time.measurable_set_eq_le\n\n",
 "measurable_set_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\nprotected theorem measurable_set_eq' [TopologicalSpace Î¹] [OrderTopology Î¹] [FirstCountableTopology Î¹]\n    (hÏ„ : is_stopping_time f Ï„) (i : Î¹) : (measurable_set_of hÏ„.measurable_space) { Ï‰ | Ï„ Ï‰ = i } :=\n  by\n  rw [â† Set.univ_inter { Ï‰ | Ï„ Ï‰ = i }, measurable_set_inter_eq_iff, Set.univ_inter]\n  exact hÏ„.measurable_set_eq i\n#align measurable_set_eq' measurable_set_eq'\n\n",
 "measurable_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time.measurable_set_eq (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ = i } :=\n  by\n  have : { Ï‰ | Ï„ Ï‰ = i } = { Ï‰ | Ï„ Ï‰ â‰¤ i } âˆ© { Ï‰ | Ï„ Ï‰ â‰¥ i } :=\n    by\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, ge_iff_le, Set.mem_inter_iff, le_antisymm_iff]\n  rw [this]\n  exact (hÏ„.measurable_set_le i).inter (hÏ„.measurable_set_ge i)\n#align is_stopping_time.measurable_set_eq is_stopping_time.measurable_set_eq\n\n",
 "measurable_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\nprotected theorem measurable_of_le [TopologicalSpace Î¹] [MeasurableSpace Î¹] [borel_space Î¹] [OrderTopology Î¹]\n    [SecondCountableTopology Î¹] (hÏ„ : is_stopping_time f Ï„) {i : Î¹} (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ i) : (measurable_of (f i)) Ï„ :=\n  hÏ„.measurable.mono (measurable_space_le_of_le_const _ hÏ„_le) le_rfl\n#align measurable_of_le measurable_of_le\n\n",
 "max_const":
 "protected theorem max_const [linear_order Î¹] {f : filtration Î¹ m} {Ï„ : Î© â†’ Î¹} (hÏ„ : is_stopping_time f Ï„) (i : Î¹) :\n    is_stopping_time f fun Ï‰ => max (Ï„ Ï‰) i :=\n  hÏ„.max (is_stopping_time_const f i)\n#align max_const max_const\n\n",
 "max":
 "protected theorem max [linear_order Î¹] {f : filtration Î¹ m} {Ï„ Ï€ : Î© â†’ Î¹} (hÏ„ : is_stopping_time f Ï„)\n    (hÏ€ : is_stopping_time f Ï€) : is_stopping_time f fun Ï‰ => max (Ï„ Ï‰) (Ï€ Ï‰) :=\n  by\n  intro i\n  simp_rw [max_le_iff, Set.setOf_and]\n  exact (hÏ„ i).inter (hÏ€ i)\n#align max max\n\n",
 "le_measurable_space_of_const_le":
 "theorem le_measurable_space_of_const_le (hÏ„ : is_stopping_time f Ï„) {i : Î¹} (hÏ„_le : âˆ€ Ï‰, i â‰¤ Ï„ Ï‰) :\n    f i â‰¤ hÏ„.measurable_space :=\n  (measurable_space_const _ _).symm.le.trans (measurable_space_mono _ hÏ„ hÏ„_le)\n#align le_measurable_space_of_const_le le_measurable_space_of_const_le\n\n",
 "is_stopping_time_piecewise_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time_piecewise_const (hij : i â‰¤ j) (hs : (measurable_set_of (ğ’¢ i)) s) :\n    is_stopping_time ğ’¢ (s.piecewise (fun _ => i) fun _ => j) :=\n  (is_stopping_time_const ğ’¢ i).piecewise_of_le (is_stopping_time_const ğ’¢ j) (fun x => le_rfl) (fun _ => hij) hs\n#align is_stopping_time_piecewise_const is_stopping_time_piecewise_const\n\n",
 "is_stopping_time_of_measurable_set_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem is_stopping_time_of_measurable_set_eq [preorder Î¹] [Countable Î¹] {f : filtration Î¹ m} {Ï„ : Î© â†’ Î¹}\n    (hÏ„ : âˆ€ i, (measurable_set_of (f i)) { Ï‰ | Ï„ Ï‰ = i }) : is_stopping_time f Ï„ :=\n  by\n  intro i\n  rw [show\n      { Ï‰ | Ï„ Ï‰ â‰¤ i } =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\" { Ï‰ | Ï„ Ï‰ = k }\n      by\n      ext\n      simp]\n  refine' MeasurableSet.bunionáµ¢ (Set.to_countable _) fun k hk => _\n  exact f.mono hk _ (hÏ„ k)\n#align is_stopping_time_of_measurable_set_eq is_stopping_time_of_measurable_set_eq\n\n",
 "is_stopping_time_const":
 "/-\nCopyright (c) 2021 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying, RÃ©my Degenne\n-/\ntheorem is_stopping_time_const [preorder Î¹] (f : filtration Î¹ m) (i : Î¹) : is_stopping_time f fun Ï‰ => i := fun j => by\n  simp only [MeasurableSet.const]\n#align is_stopping_time_const is_stopping_time_const\n\n",
 "integrable_stopped_value_of_mem_finset":
 "theorem integrable_stopped_value_of_mem_finset (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, integrable (u n) Î¼) {s : Finset Î¹}\n    (hbdd : âˆ€ Ï‰, Ï„ Ï‰ âˆˆ s) : integrable (stopped_value u Ï„) Î¼ :=\n  by\n  simp_rw [â† mem_â„’p_one_iff_integrable] at huâŠ¢\n  exact mem_â„’p_stopped_value_of_mem_finset hÏ„ hu hbdd\n#align integrable_stopped_value_of_mem_finset integrable_stopped_value_of_mem_finset\n\n",
 "integrable_stopped_value":
 "theorem integrable_stopped_value [LocallyFiniteOrderBot Î¹] (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, integrable (u n) Î¼)\n    {N : Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) : integrable (stopped_value u Ï„) Î¼ :=\n  integrable_stopped_value_of_mem_finset hÏ„ hu fun Ï‰ => Finset.mem_Iic.mpr (hbdd Ï‰)\n#align integrable_stopped_value integrable_stopped_value\n\n",
 "integrable_stopped_process_of_mem_finset":
 "theorem integrable_stopped_process_of_mem_finset (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, integrable (u n) Î¼) (n : Î¹)\n    {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ s) : integrable (stopped_process u Ï„ n) Î¼ :=\n  by\n  simp_rw [â† mem_â„’p_one_iff_integrable] at huâŠ¢\n  exact mem_â„’p_stopped_process_of_mem_finset hÏ„ hu n hbdd\n#align integrable_stopped_process_of_mem_finset integrable_stopped_process_of_mem_finset\n\n",
 "integrable_stopped_process":
 "theorem integrable_stopped_process [LocallyFiniteOrderBot Î¹] (hÏ„ : is_stopping_time â„± Ï„) (hu : âˆ€ n, integrable (u n) Î¼)\n    (n : Î¹) : integrable (stopped_process u Ï„ n) Î¼ :=\n  integrable_stopped_process_of_mem_finset hÏ„ hu n fun Ï‰ h => Finset.mem_Iio.mpr h\n#align integrable_stopped_process integrable_stopped_process\n\n",
 "add_const_nat":
 "theorem add_const_nat {f : filtration â„• m} {Ï„ : Î© â†’ â„•} (hÏ„ : is_stopping_time f Ï„) {i : â„•} :\n    is_stopping_time f fun Ï‰ => Ï„ Ï‰ + i :=\n  by\n  refine' is_stopping_time_of_measurable_set_eq fun j => _\n  by_cases hij : i â‰¤ j\n  Â· simp_rw [eq_comm, â† nat.sub_eq_iff_eq_add hij, eq_comm]\n    exact f.mono (j.sub_le i) _ (hÏ„.measurable_set_eq (j - i))\n  Â· rw [not_le] at hij\n    convert MeasurableSet.empty\n    ext Ï‰\n    simp only [Set.mem_empty_iff_false, iff_false_iff]\n    rintro (hx : Ï„ Ï‰ + i = j)\n    linarith\n#align add_const_nat add_const_nat\n\n",
 "add_const":
 "theorem add_const [AddGroup Î¹] [preorder Î¹] [CovariantClass Î¹ Î¹ (function.swap (Â· + Â·)) (Â· â‰¤ Â·)]\n    [CovariantClass Î¹ Î¹ (Â· + Â·) (Â· â‰¤ Â·)] {f : filtration Î¹ m} {Ï„ : Î© â†’ Î¹} (hÏ„ : is_stopping_time f Ï„) {i : Î¹}\n    (hi : 0 â‰¤ i) : is_stopping_time f fun Ï‰ => Ï„ Ï‰ + i :=\n  by\n  intro j\n  simp_rw [â† le_sub_iff_add_le]\n  exact f.mono (sub_le_self j hi) _ (hÏ„ (j - i))\n#align add_const add_const\n\n",
 "add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‹ƒ , Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â» -/\n-- generalize to certain countable type?\ntheorem add {f : filtration â„• m} {Ï„ Ï€ : Î© â†’ â„•} (hÏ„ : is_stopping_time f Ï„) (hÏ€ : is_stopping_time f Ï€) :\n    is_stopping_time f (Ï„ + Ï€) := by\n  intro i\n  rw [(_ :\n      { Ï‰ | (Ï„ + Ï€) Ï‰ â‰¤ i } =\n        Â«exprâ‹ƒ , Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâ‹ƒ , Â»\"\n          ({ Ï‰ | Ï€ Ï‰ = k } âˆ© { Ï‰ | Ï„ Ï‰ + k â‰¤ i }))]\n  Â·\n    exact\n      MeasurableSet.unionáµ¢ fun k =>\n        MeasurableSet.unionáµ¢ fun hk => (hÏ€.measurable_set_eq_le hk).inter (hÏ„.add_const_nat i)\n  ext Ï‰\n  simp only [Pi.add_apply, Set.mem_setOf_eq, Set.mem_unionáµ¢, Set.mem_inter_iff, exists_prop]\n  refine' âŸ¨fun h => âŸ¨Ï€ Ï‰, by linarith, rfl, hâŸ©, _âŸ©\n  rintro âŸ¨j, hj, rfl, hâŸ©\n  assumption\n#align add add\n\n",
 "adapted_stopped_process":
 "theorem prog_measurable.adapted_stopped_process [metrizable_space Î¹] (h : prog_measurable f u)\n    (hÏ„ : is_stopping_time f Ï„) : adapted f (stopped_process u Ï„) :=\n  (h.stopped_process hÏ„).adapted\n#align prog_measurable.adapted_stopped_process prog_measurable.adapted_stopped_process\n\n",
 "MeasurableSet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n#print MeasurableSet /-\nprotected theorem MeasurableSet (hÏ„ : is_stopping_time f Ï„) (s : Set Î©) :\n    (measurable_set_of hÏ„.measurable_space) s â†” âˆ€ i : Î¹, (measurable_set_of (f i)) (s âˆ© { Ï‰ | Ï„ Ï‰ â‰¤ i }) :=\n  iff.rfl\n#align measurable_set MeasurableSet\n-/\n\n",
 "Measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_of -/\n#print Measurable /-\nprotected theorem Measurable [TopologicalSpace Î¹] [MeasurableSpace Î¹] [borel_space Î¹] [OrderTopology Î¹]\n    [SecondCountableTopology Î¹] (hÏ„ : is_stopping_time f Ï„) : (measurable_of hÏ„.measurable_space) Ï„ :=\n  @measurable_of_Iic Î¹ Î© _ _ _ hÏ„.measurable_space _ _ _ _ fun i => hÏ„.measurable_set_le' i\n#align measurable Measurable\n-/\n\n"}