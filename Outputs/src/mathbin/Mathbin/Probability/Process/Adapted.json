{"strongly_measurable_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\ntheorem strongly_measurable_le {i j : ι} (hf : adapted f u) (hij : i ≤ j) : (strongly_measurable_of (f j)) (u i) :=\n  (hf i).mono (f.mono hij)\n#align strongly_measurable_le strongly_measurable_le\n\n",
 "strongly_measurable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n@[protected]\ntheorem strongly_measurable {i : ι} (hf : adapted f u) : (strongly_measurable_of m) (u i) :=\n  (hf i).mono (f.le i)\n#align strongly_measurable strongly_measurable\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[protected]\ntheorem smul [SMul (exprℝ) β] [ContinuousSMul (exprℝ) β] (c : exprℝ) (hu : adapted f u) : adapted f («expr • » c u) :=\n  fun i => (hu i).const_smul c\n#align smul smul\n\n",
 "prog_measurable_of_tendsto'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem prog_measurable_of_tendsto' {γ} [MeasurableSpace ι] [pseudo_metrizable_space β] (fltr : Filter γ) [fltr.ne_bot]\n    [fltr.is_countably_generated] {U : γ → ι → Ω → β} (h : ∀ l, prog_measurable f (U l))\n    (h_tendsto : Tendsto U fltr ((nhds) u)) : prog_measurable f u :=\n  by\n  intro i\n  apply\n    @strongly_measurable_of_tendsto (Set.Iic i × Ω) β γ (MeasurableSpace.prod _ (f i)) _ _ fltr _ _ _ _ fun l => h l i\n  rw [tendsto_pi_nhds] at h_tendsto⊢\n  intro x\n  specialize h_tendsto x.fst\n  rw [tendsto_nhds] at h_tendsto⊢\n  exact fun s hs h_mem => h_tendsto { g | g x.snd ∈ s } (hs.preimage (continuous_apply x.snd)) h_mem\n#align prog_measurable_of_tendsto' prog_measurable_of_tendsto'\n\n",
 "prog_measurable_of_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem prog_measurable_of_tendsto [MeasurableSpace ι] [pseudo_metrizable_space β] {U : ℕ → ι → Ω → β}\n    (h : ∀ l, prog_measurable f (U l)) (h_tendsto : Tendsto U atTop ((nhds) u)) : prog_measurable f u :=\n  prog_measurable_of_tendsto' atTop h h_tendsto\n#align prog_measurable_of_tendsto prog_measurable_of_tendsto\n\n",
 "prog_measurable_of_discrete":
 "/-- For filtrations indexed by a discrete order, `adapted` and `prog_measurable` are equivalent.\nThis lemma provides `adapted f u → prog_measurable f u`.\nSee `prog_measurable.adapted` for the reverse direction, which is true more generally. -/\ntheorem adapted.prog_measurable_of_discrete [TopologicalSpace ι] [DiscreteTopology ι] [SecondCountableTopology ι]\n    [MeasurableSpace ι] [opens_measurable_space ι] [pseudo_metrizable_space β] (h : adapted f u) :\n    prog_measurable f u :=\n  h.prog_measurable_of_continuous fun _ => continuous_of_discreteTopology\n#align adapted.prog_measurable_of_discrete adapted.prog_measurable_of_discrete\n\n",
 "prog_measurable_of_continuous":
 "/-- A continuous and adapted process is progressively measurable. -/\ntheorem adapted.prog_measurable_of_continuous [TopologicalSpace ι] [metrizable_space ι] [SecondCountableTopology ι]\n    [MeasurableSpace ι] [opens_measurable_space ι] [pseudo_metrizable_space β] (h : adapted f u)\n    (hu_cont : ∀ ω, Continuous fun i => u i ω) : prog_measurable f u := fun i =>\n  @strongly_measurable_uncurry_of_continuous_of_strongly_measurable _ _ (Set.Iic i) _ _ _ _ _ _ _ (f i) _\n    (fun ω => (hu_cont ω).comp continuous_induced_dom) fun j => (h j).mono (f.mono j.prop)\n#align adapted.prog_measurable_of_continuous adapted.prog_measurable_of_continuous\n\n",
 "prog_measurable_const":
 "theorem prog_measurable_const [MeasurableSpace ι] (f : filtration ι m) (b : β) :\n    prog_measurable f (fun _ _ => b : ι → Ω → β) := fun i =>\n  @strongly_measurable_const _ _ (Subtype.instMeasurableSpace.prod (f i)) _ _\n#align prog_measurable_const prog_measurable_const\n\n",
 "mul":
 "@[to_additive]\nprotected theorem mul [Mul β] [ContinuousMul β] (hu : prog_measurable f u) (hv : prog_measurable f v) :\n    prog_measurable f fun i ω => u i ω * v i ω := fun i => (hu i).mul (hv i)\n#align mul mul\n\n",
 "inv":
 "@[to_additive]\nprotected theorem inv [Group β] [TopologicalGroup β] (hu : prog_measurable f u) :\n    prog_measurable f fun i ω => (u i ω)⁻¹ := fun i => (hu i).inv\n#align inv inv\n\n",
 "finset_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\nprotected theorem finset_prod' {γ} [CommMonoid β] [ContinuousMul β] {U : γ → ι → Ω → β} {s : Finset γ}\n    (h : ∀ c ∈ s, prog_measurable f (U c)) :\n    prog_measurable f\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (U c)) :=\n  Finset.prod_induction U (prog_measurable f) (fun _ _ => prog_measurable.mul) (prog_measurable_const _ 1) h\n#align finset_prod' finset_prod'\n\n",
 "finset_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[to_additive]\nprotected theorem finset_prod {γ} [CommMonoid β] [ContinuousMul β] {U : γ → ι → Ω → β} {s : Finset γ}\n    (h : ∀ c ∈ s, prog_measurable f (U c)) :\n    prog_measurable f fun i a =>\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (U c i a) :=\n  by\n  convert prog_measurable.finset_prod' h\n  ext (i a)\n  simp only [Finset.prod_apply]\n#align finset_prod finset_prod\n\n",
 "div":
 "@[to_additive]\nprotected theorem div [Group β] [TopologicalGroup β] (hu : prog_measurable f u) (hv : prog_measurable f v) :\n    prog_measurable f fun i ω => u i ω / v i ω := fun i => (hu i).div (hv i)\n#align div div\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\nprotected theorem comp {t : ι → Ω → ι} [TopologicalSpace ι] [borel_space ι] [metrizable_space ι]\n    (h : prog_measurable f u) (ht : prog_measurable f t) (ht_le : ∀ i ω, t i ω ≤ i) :\n    prog_measurable f fun i ω => u (t i ω) ω := by\n  intro i\n  have :\n    (fun p : «expr↥ » (Set.Iic i) × Ω => u (t (p.fst : ι) p.snd) p.snd) =\n      (fun p : «expr↥ » (Set.Iic i) × Ω => u (p.fst : ι) p.snd) ∘ fun p : «expr↥ » (Set.Iic i) × Ω =>\n        (⟨t (p.fst : ι) p.snd, set.mem_Iic.mpr ((ht_le _ _).trans p.fst.prop)⟩, p.snd) :=\n    rfl\n  rw [this]\n  exact (h i).comp_measurable ((ht i).measurable.subtype_mk.prod_mk measurable_snd)\n#align comp comp\n\n",
 "adapted_zero":
 "theorem adapted_zero [Zero β] (f : filtration ι m) : adapted f (0 : ι → Ω → β) := fun i =>\n  @strongly_measurable_zero Ω β (f i) _ _\n#align adapted_zero adapted_zero\n\n",
 "adapted_natural":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\ntheorem filtration.adapted_natural [metrizable_space β] [mβ : MeasurableSpace β] [borel_space β] {u : ι → Ω → β}\n    (hum : ∀ i, (strongly_measurable_of m) (u i)) : adapted (filtration.natural u hum) u :=\n  by\n  intro i\n  refine' strongly_measurable.mono _ (le_supᵢ₂_of_le i (le_refl i) le_rfl)\n  rw [strongly_measurable_iff_measurable_separable]\n  exact ⟨measurable_iff_comap_le.2 le_rfl, (hum i).is_separable_range⟩\n#align filtration.adapted_natural filtration.adapted_natural\n\n",
 "adapted_const":
 "theorem adapted_const (f : filtration ι m) (x : β) : adapted f fun _ _ => x := fun i => strongly_measurable_const\n#align adapted_const adapted_const\n\n",
 "adapted":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `strongly_measurable_of -/\n-- this dot notation will make more sense once we have a more general definition for predictable\ntheorem predictable.adapted {f : filtration ℕ m} {u : ℕ → Ω → β} (hu : adapted f fun n => u (n + 1))\n    (hu0 : (strongly_measurable_of (f 0)) (u 0)) : adapted f u := fun n =>\n  match n with\n  | 0 => hu0\n  | n + 1 => (hu n).mono (f.mono n.le_succ)\n#align predictable.adapted predictable.adapted\n\n"}