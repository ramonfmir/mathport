{"stopped_value_hitting_mem":
 "theorem stopped_value_hitting_mem [ConditionallyCompleteLinearOrder ι] [is_well_order ι (· < ·)] {u : ι → Ω → β}\n    {s : set β} {n m : ι} {ω : Ω} (h : ∃ j ∈ Set.Icc n m, u j ω ∈ s) : stopped_value u (hitting u s n m) ω ∈ s :=\n  by\n  simp only [stopped_value, hitting, if_pos h]\n  obtain ⟨j, hj₁, hj₂⟩ := h\n  have : Inf (Set.Icc n m ∩ { i | u i ω ∈ s }) ∈ Set.Icc n m ∩ { i | u i ω ∈ s } :=\n    cinfₛ_mem (Set.nonempty_of_mem ⟨hj₁, hj₂⟩)\n  exact this.2\n#align stopped_value_hitting_mem stopped_value_hitting_mem\n\n",
 "not_mem_of_lt_hitting":
 "theorem not_mem_of_lt_hitting {m k : ι} (hk₁ : k < hitting u s n m ω) (hk₂ : n ≤ k) : u k ω ∉ s := by\n  classical\n    intro h\n    have hexists : ∃ j ∈ Set.Icc n m, u j ω ∈ s\n    refine' ⟨k, ⟨hk₂, le_trans hk₁.le <| hitting_le _⟩, h⟩\n    refine' not_le.2 hk₁ _\n    simp_rw [hitting, if_pos hexists]\n    exact cinfₛ_le bdd_below_Icc.inter_of_left ⟨⟨hk₂, le_trans hk₁.le <| hitting_le _⟩, h⟩\n#align not_mem_of_lt_hitting not_mem_of_lt_hitting\n\n",
 "le_hitting_of_exists":
 "theorem le_hitting_of_exists {m : ι} (h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s) : n ≤ hitting u s n m ω :=\n  by\n  refine' le_hitting _ ω\n  by_contra\n  rw [Set.Icc_eq_empty_of_lt (not_le.mp h)] at h_exists\n  simpa using h_exists\n#align le_hitting_of_exists le_hitting_of_exists\n\n",
 "le_hitting":
 "theorem le_hitting {m : ι} (hnm : n ≤ m) (ω : Ω) : n ≤ hitting u s n m ω :=\n  by\n  simp only [hitting]\n  split_ifs\n  · refine' le_cinfₛ _ fun b hb => _\n    · obtain ⟨k, hk_Icc, hk_s⟩ := h\n      exact ⟨k, hk_Icc, hk_s⟩\n    · rw [Set.mem_inter_iff] at hb\n      exact hb.1.1\n  · exact hnm\n#align le_hitting le_hitting\n\n",
 "is_stopping_time_hitting_is_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/-- The hitting time of a discrete process with the starting time indexed by a stopping time\nis a stopping time. -/\ntheorem is_stopping_time_hitting_is_stopping_time [ConditionallyCompleteLinearOrder ι] [is_well_order ι (· < ·)]\n    [countable ι] [topological_space ι] [order_topology ι] [first_countable_topology ι] [topological_space β]\n    [pseudo_metrizable_space β] [measurable_space β] [borel_space β] {f : filtration ι m} {u : ι → Ω → β} {τ : Ω → ι}\n    (hτ : is_stopping_time f τ) {N : ι} (hτbdd : ∀ x, τ x ≤ N) {s : set β} (hs : measurable_set s) (hf : adapted f u) :\n    is_stopping_time f fun x => hitting u s (τ x) N x :=\n  by\n  intro n\n  have h₁ :\n    { x | hitting u s (τ x) N x ≤ n } =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          ({ x | τ x = i } ∩ { x | hitting u s i N x ≤ n }) ∪\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          ({ x | τ x = i } ∩ { x | hitting u s i N x ≤ n }) :=\n    by\n    ext x\n    simp [← exists_or, ← or_and_right, le_or_lt]\n  have h₂ :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ({ x | τ x = i } ∩ { x | hitting u s i N x ≤ n }) =\n      ∅ :=\n    by\n    ext x\n    simp only [gt_iff_lt, Set.mem_unionᵢ, Set.mem_inter_iff, Set.mem_setOf_eq, exists_prop, Set.mem_empty_iff_false,\n      iff_false_iff, not_exists, not_and, not_le]\n    rintro m hm rfl\n    exact lt_of_lt_of_le hm (le_hitting (hτbdd _) _)\n  rw [h₁, h₂, Set.union_empty]\n  exact\n    measurable_set.Union fun i =>\n      measurable_set.Union fun hi => (f.mono hi _ (hτ.measurable_set_eq i)).inter (hitting_is_stopping_time hf hs n)\n#align is_stopping_time_hitting_is_stopping_time is_stopping_time_hitting_is_stopping_time\n\n",
 "hitting_of_lt":
 "/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying, Rémy Degenne\n-/\n/-- This lemma is strictly weaker than `hitting_of_le`. -/\ntheorem hitting_of_lt {m : ι} (h : m < n) : hitting u s n m ω = m :=\n  by\n  simp_rw [hitting]\n  have h_not : ¬∃ (j : ι)(H : j ∈ Set.Icc n m), u j ω ∈ s :=\n    by\n    push_neg\n    intro j\n    rw [Set.Icc_eq_empty_of_lt h]\n    simp only [Set.mem_empty_iff_false, is_empty.forall_iff]\n  simp only [h_not, if_false]\n#align hitting_of_lt hitting_of_lt\n\n",
 "hitting_of_le":
 "theorem hitting_of_le {m : ι} (hmn : m ≤ n) : hitting u s n m ω = m :=\n  by\n  obtain rfl | h := le_iff_eq_or_lt.1 hmn\n  · simp only [hitting, Set.Icc_self, ite_eq_right_iff, Set.mem_Icc, exists_prop, forall_exists_index, and_imp]\n    intro i hi₁ hi₂ hi\n    rw [Set.inter_eq_left_iff_subset.2, cinfₛ_singleton]\n    exact Set.singleton_subset_iff.2 (le_antisymm hi₂ hi₁ ▸ hi)\n  · exact hitting_of_lt h\n#align hitting_of_le hitting_of_le\n\n",
 "hitting_mono":
 "theorem hitting_mono {m₁ m₂ : ι} (hm : m₁ ≤ m₂) : hitting u s n m₁ ω ≤ hitting u s n m₂ ω :=\n  by\n  by_cases h : ∃ j ∈ Set.Icc n m₁, u j ω ∈ s\n  · exact (hitting_eq_hitting_of_exists hm h).le\n  · simp_rw [hitting, if_neg h]\n    split_ifs with h'\n    · obtain ⟨j, hj₁, hj₂⟩ := h'\n      refine' le_cinfₛ ⟨j, hj₁, hj₂⟩ _\n      by_contra hneg\n      push_neg  at hneg\n      obtain ⟨i, hi₁, hi₂⟩ := hneg\n      exact h ⟨i, ⟨hi₁.1.1, hi₂.le⟩, hi₁.2⟩\n    · exact hm\n#align hitting_mono hitting_mono\n\n",
 "hitting_mem_set_of_hitting_lt":
 "theorem hitting_mem_set_of_hitting_lt [is_well_order ι (· < ·)] {m : ι} (hl : hitting u s n m ω < m) :\n    u (hitting u s n m ω) ω ∈ s := by\n  by_cases h : ∃ j ∈ Set.Icc n m, u j ω ∈ s\n  · exact hitting_mem_set h\n  · simp_rw [hitting, if_neg h] at hl\n    exact false.elim (hl.ne rfl)\n#align hitting_mem_set_of_hitting_lt hitting_mem_set_of_hitting_lt\n\n",
 "hitting_mem_set":
 "theorem hitting_mem_set [is_well_order ι (· < ·)] {m : ι} (h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s) :\n    u (hitting u s n m ω) ω ∈ s := by\n  simp_rw [hitting, if_pos h_exists]\n  have h_nonempty : (Set.Icc n m ∩ { i : ι | u i ω ∈ s }).nonempty :=\n    by\n    obtain ⟨k, hk₁, hk₂⟩ := h_exists\n    exact ⟨k, Set.mem_inter hk₁ hk₂⟩\n  have h_mem := cinfₛ_mem h_nonempty\n  rw [Set.mem_inter_iff] at h_mem\n  exact h_mem.2\n#align hitting_mem_set hitting_mem_set\n\n",
 "hitting_mem_Icc":
 "theorem hitting_mem_Icc {m : ι} (hnm : n ≤ m) (ω : Ω) : hitting u s n m ω ∈ Set.Icc n m :=\n  ⟨le_hitting hnm ω, hitting_le ω⟩\n#align hitting_mem_Icc hitting_mem_Icc\n\n",
 "hitting_lt_iff":
 "theorem hitting_lt_iff [is_well_order ι (· < ·)] {m : ι} (i : ι) (hi : i ≤ m) :\n    hitting u s n m ω < i ↔ ∃ j ∈ Set.Ico n i, u j ω ∈ s :=\n  by\n  constructor <;> intro h'\n  · have h : ∃ j ∈ Set.Icc n m, u j ω ∈ s := by\n      by_contra\n      simp_rw [hitting, if_neg h, ← not_le] at h'\n      exact h' hi\n    exact ⟨hitting u s n m ω, ⟨le_hitting_of_exists h, h'⟩, hitting_mem_set h⟩\n  · obtain ⟨k, hk₁, hk₂⟩ := h'\n    refine' lt_of_le_of_lt _ hk₁.2\n    exact hitting_le_of_mem hk₁.1 (hk₁.2.le.trans hi) hk₂\n#align hitting_lt_iff hitting_lt_iff\n\n",
 "hitting_le_of_mem":
 "theorem hitting_le_of_mem {m : ι} (hin : n ≤ i) (him : i ≤ m) (his : u i ω ∈ s) : hitting u s n m ω ≤ i :=\n  by\n  have h_exists : ∃ k ∈ Set.Icc n m, u k ω ∈ s := ⟨i, ⟨hin, him⟩, his⟩\n  simp_rw [hitting, if_pos h_exists]\n  exact cinfₛ_le (BddBelow.inter_of_left bddBelow_Icc) (Set.mem_inter ⟨hin, him⟩ his)\n#align hitting_le_of_mem hitting_le_of_mem\n\n",
 "hitting_le_iff_of_lt":
 "theorem hitting_le_iff_of_lt [is_well_order ι (· < ·)] {m : ι} (i : ι) (hi : i < m) :\n    hitting u s n m ω ≤ i ↔ ∃ j ∈ Set.Icc n i, u j ω ∈ s :=\n  by\n  by_cases h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s\n  · rw [hitting_le_iff_of_exists h_exists]\n  · simp_rw [hitting, if_neg h_exists]\n    push_neg  at h_exists\n    simp only [not_le.mpr hi, Set.mem_Icc, false_iff_iff, not_exists, and_imp]\n    exact fun k hkn hki => h_exists k ⟨hkn, hki.trans hi.le⟩\n#align hitting_le_iff_of_lt hitting_le_iff_of_lt\n\n",
 "hitting_le_iff_of_exists":
 "theorem hitting_le_iff_of_exists [is_well_order ι (· < ·)] {m : ι} (h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s) :\n    hitting u s n m ω ≤ i ↔ ∃ j ∈ Set.Icc n i, u j ω ∈ s :=\n  by\n  constructor <;> intro h'\n  · exact ⟨hitting u s n m ω, ⟨le_hitting_of_exists h_exists, h'⟩, hitting_mem_set h_exists⟩\n  · have h'' : ∃ k ∈ Set.Icc n (min m i), u k ω ∈ s :=\n      by\n      obtain ⟨k₁, hk₁_mem, hk₁_s⟩ := h_exists\n      obtain ⟨k₂, hk₂_mem, hk₂_s⟩ := h'\n      refine' ⟨min k₁ k₂, ⟨le_min hk₁_mem.1 hk₂_mem.1, min_le_min hk₁_mem.2 hk₂_mem.2⟩, _⟩\n      exact min_rec' (fun j => u j ω ∈ s) hk₁_s hk₂_s\n    obtain ⟨k, hk₁, hk₂⟩ := h''\n    refine' le_trans _ (hk₁.2.trans (min_le_right _ _))\n    exact hitting_le_of_mem hk₁.1 (hk₁.2.trans (min_le_left _ _)) hk₂\n#align hitting_le_iff_of_exists hitting_le_iff_of_exists\n\n",
 "hitting_le":
 "theorem hitting_le {m : ι} (ω : Ω) : hitting u s n m ω ≤ m :=\n  by\n  cases' le_or_lt n m with h_le h_lt\n  · simp only [hitting]\n    split_ifs\n    · obtain ⟨j, hj₁, hj₂⟩ := h\n      exact (cinfₛ_le (BddBelow.inter_of_left bddBelow_Icc) (Set.mem_inter hj₁ hj₂)).trans hj₁.2\n    · exact le_rfl\n  · rw [hitting_of_lt h_lt]\n#align hitting_le hitting_le\n\n",
 "hitting_is_stopping_time":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/-- A discrete hitting time is a stopping time. -/\ntheorem hitting_is_stopping_time [ConditionallyCompleteLinearOrder ι] [is_well_order ι (· < ·)] [countable ι]\n    [topological_space β] [pseudo_metrizable_space β] [measurable_space β] [borel_space β] {f : filtration ι m}\n    {u : ι → Ω → β} {s : set β} {n n' : ι} (hu : adapted f u) (hs : measurable_set s) :\n    is_stopping_time f (hitting u s n n') := by\n  intro i\n  cases' le_or_lt n' i with hi hi\n  · have h_le : ∀ ω, hitting u s n n' ω ≤ i := fun x => (hitting_le x).trans hi\n    simp [h_le]\n  · have h_set_eq_Union :\n      { ω | hitting u s n n' ω ≤ i } =\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr ⁻¹' » (u j) s) :=\n      by\n      ext x\n      rw [Set.mem_setOf_eq, hitting_le_iff_of_lt _ hi]\n      simp only [Set.mem_Icc, exists_prop, Set.mem_unionᵢ, Set.mem_preimage]\n    rw [h_set_eq_Union]\n    exact measurable_set.Union fun j => measurable_set.Union fun hj => f.mono hj.2 _ ((hu j).measurable hs)\n#align hitting_is_stopping_time hitting_is_stopping_time\n\n",
 "hitting_eq_hitting_of_exists":
 "theorem hitting_eq_hitting_of_exists {m₁ m₂ : ι} (h : m₁ ≤ m₂) (h' : ∃ j ∈ Set.Icc n m₁, u j ω ∈ s) :\n    hitting u s n m₁ ω = hitting u s n m₂ ω :=\n  by\n  simp only [hitting, if_pos h']\n  obtain ⟨j, hj₁, hj₂⟩ := h'\n  rw [if_pos]\n  · refine'\n      le_antisymm _\n        (cinfₛ_le_cinfₛ bdd_below_Icc.inter_of_left ⟨j, hj₁, hj₂⟩\n          (Set.inter_subset_inter_left _ (Set.Icc_subset_Icc_right h)))\n    refine' le_cinfₛ ⟨j, Set.Icc_subset_Icc_right h hj₁, hj₂⟩ fun i hi => _\n    by_cases hi' : i ≤ m₁\n    · exact cinfₛ_le bdd_below_Icc.inter_of_left ⟨⟨hi.1.1, hi'⟩, hi.2⟩\n    ·\n      exact\n        ((cinfₛ_le bdd_below_Icc.inter_of_left ⟨hj₁, hj₂⟩).trans (hj₁.2.trans le_rfl)).trans (le_of_lt (not_le.1 hi'))\n  exact ⟨j, ⟨hj₁.1, hj₁.2.trans h⟩, hj₂⟩\n#align hitting_eq_hitting_of_exists hitting_eq_hitting_of_exists\n\n",
 "hitting_eq_end_iff":
 "theorem hitting_eq_end_iff {m : ι} :\n    hitting u s n m ω = m ↔ (∃ j ∈ Set.Icc n m, u j ω ∈ s) → infₛ (Set.Icc n m ∩ { i : ι | u i ω ∈ s }) = m := by\n  rw [hitting, ite_eq_right_iff]\n#align hitting_eq_end_iff hitting_eq_end_iff\n\n",
 "hitting_eq_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem hitting_eq_Inf (ω : Ω) : hitting u s («expr⊥») («expr⊤») ω = infₛ { i : ι | u i ω ∈ s } :=\n  by\n  simp only [hitting, Set.mem_Icc, bot_le, le_top, and_self_iff, exists_true_left, Set.Icc_bot, Set.Iic_top,\n    Set.univ_inter, ite_eq_left_iff, not_exists]\n  intro h_nmem_s\n  symm\n  rw [infₛ_eq_top]\n  exact fun i hi_mem_s => absurd hi_mem_s (h_nmem_s i)\n#align hitting_eq_Inf hitting_eq_Inf\n\n",
 "hitting_bot_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem hitting_bot_le_iff {i n : ι} {ω : Ω} (hx : ∃ j, j ≤ n ∧ u j ω ∈ s) :\n    hitting u s («expr⊥») n ω ≤ i ↔ ∃ j ≤ i, u j ω ∈ s :=\n  by\n  cases' lt_or_le i n with hi hi\n  · rw [hitting_le_iff_of_lt _ hi]\n    simp\n  · simp only [(hitting_le ω).trans hi, true_iff_iff]\n    obtain ⟨j, hj₁, hj₂⟩ := hx\n    exact ⟨j, hj₁.trans hi, hj₂⟩\n#align hitting_bot_le_iff hitting_bot_le_iff\n\n"}