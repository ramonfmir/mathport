{"tsum_coe_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem tsum_coe_ne_top (p : Pmf α) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (p a) ≠\n      ennreal.top :=\n  p.tsum_coe.symm ▸ ENNReal.one_ne_top\n#align tsum_coe_ne_top tsum_coe_ne_top\n\n",
 "tsum_coe_indicator_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem tsum_coe_indicator_ne_top (p : Pmf α) (s : Set α) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (s.indicator p a) ≠\n      ennreal.top :=\n  ne_of_lt\n    (lt_of_le_of_lt (tsum_le_tsum (fun a => Set.indicator_apply_le fun _ => le_rfl) ENNReal.summable ENNReal.summable)\n      (lt_of_le_of_ne le_top p.tsum_coe_ne_top))\n#align tsum_coe_indicator_ne_top tsum_coe_indicator_ne_top\n\n",
 "tsum_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n@[simp]\ntheorem tsum_coe (p : Pmf α) :\n    «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (p a) = 1 :=\n  p.has_sum_coe_one.tsum_eq\n#align tsum_coe tsum_coe\n\n",
 "to_pmf_to_measure":
 "@[simp]\ntheorem to_pmf_to_measure : μ.to_pmf.to_measure = μ :=\n  Measure.ext fun s hs => by simpa only [μ.to_pmf.to_measure_apply s hs, ← μ.tsum_indicator_apply_singleton s hs]\n#align to_pmf_to_measure to_pmf_to_measure\n\n",
 "to_pmf_eq_iff_to_measure_eq":
 "theorem to_pmf_eq_iff_to_measure_eq (μ : measure α) [ProbabilityMeasure μ] : μ.to_pmf = p ↔ μ = p.to_measure := by\n  rw [← to_measure_inj, measure.to_pmf_to_measure]\n#align to_pmf_eq_iff_to_measure_eq to_pmf_eq_iff_to_measure_eq\n\n",
 "to_pmf_apply":
 "theorem to_pmf_apply (x : α) : μ.to_pmf x = μ {x} :=\n  rfl\n#align to_pmf_apply to_pmf_apply\n\n",
 "to_outer_measure_mono":
 "/-- Slightly stronger than `outer_measure.mono` having an intersection with `p.support` -/\ntheorem to_outer_measure_mono {s t : Set α} (h : s ∩ p.support ⊆ t) : p.to_outer_measure s ≤ p.to_outer_measure t :=\n  le_trans (le_of_eq (toOuterMeasure_apply_inter_support p s).symm) (p.to_outer_measure.mono h)\n#align to_outer_measure_mono to_outer_measure_mono\n\n",
 "to_outer_measure_injective":
 "theorem to_outer_measure_injective : (toOuterMeasure : Pmf α → OuterMeasure α).injective := fun p q h =>\n  Pmf.ext fun x =>\n    (p.to_outer_measure_apply_singleton x).symm.trans\n      ((congr_fun (congr_arg _ h) _).trans <| q.to_outer_measure_apply_singleton x)\n#align to_outer_measure_injective to_outer_measure_injective\n\n",
 "to_outer_measure_inj":
 "@[simp]\ntheorem to_outer_measure_inj {p q : Pmf α} : p.to_outer_measure = q.to_outer_measure ↔ p = q :=\n  toOuterMeasure_injective.eq_iff\n#align to_outer_measure_inj to_outer_measure_inj\n\n",
 "to_outer_measure_caratheodory":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem to_outer_measure_caratheodory : p.to_outer_measure.caratheodory = «expr⊤» :=\n  by\n  refine' eq_top_iff.2 <| le_trans (le_infₛ fun x hx => _) (le_sum_caratheodory _)\n  exact\n    let ⟨y, hy⟩ := hx\n    ((le_of_eq (dirac_caratheodory y).symm).trans (le_smul_caratheodory _ _)).trans (le_of_eq hy)\n#align to_outer_measure_caratheodory to_outer_measure_caratheodory\n\n",
 "to_outer_measure_apply_singleton":
 "theorem to_outer_measure_apply_singleton (a : α) : p.to_outer_measure {a} = p a :=\n  by\n  refine' (p.to_outer_measure_apply {a}).trans ((tsum_eq_single a fun b hb => _).trans _)\n  · exact ite_eq_right_iff.2 fun hb' => false.elim <| hb hb'\n  · exact ite_eq_left_iff.2 fun ha' => false.elim <| ha' rfl\n#align to_outer_measure_apply_singleton to_outer_measure_apply_singleton\n\n",
 "to_outer_measure_apply_le_to_measure_apply":
 "theorem to_outer_measure_apply_le_to_measure_apply : p.to_outer_measure s ≤ p.to_measure s :=\n  le_toMeasure_apply p.to_outer_measure _ s\n#align to_outer_measure_apply_le_to_measure_apply to_outer_measure_apply_le_to_measure_apply\n\n",
 "to_outer_measure_apply_inter_support":
 "@[simp]\ntheorem to_outer_measure_apply_inter_support : p.to_outer_measure (s ∩ p.support) = p.to_outer_measure s := by\n  simp only [to_outer_measure_apply, Pmf.support, Set.indicator_inter_support]\n#align to_outer_measure_apply_inter_support to_outer_measure_apply_inter_support\n\n",
 "to_outer_measure_apply_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem to_outer_measure_apply_fintype [Fintype α] :\n    p.to_outer_measure s =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (s.indicator p x) :=\n  (p.to_outer_measure_apply s).trans (tsum_eq_sum fun x h => absurd (Finset.mem_univ x) h)\n#align to_outer_measure_apply_fintype to_outer_measure_apply_fintype\n\n",
 "to_outer_measure_apply_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem to_outer_measure_apply_finset (s : Finset α) :\n    p.to_outer_measure s =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (p x) :=\n  by\n  refine' (to_outer_measure_apply p s).trans ((@tsum_eq_sum _ _ _ _ _ _ s _).trans _)\n  · exact fun x hx => Set.indicator_of_not_mem hx _\n  · exact Finset.sum_congr rfl fun x hx => Set.indicator_of_mem hx _\n#align to_outer_measure_apply_finset to_outer_measure_apply_finset\n\n",
 "to_outer_measure_apply_eq_zero_iff":
 "theorem to_outer_measure_apply_eq_zero_iff : p.to_outer_measure s = 0 ↔ Disjoint p.support s :=\n  by\n  rw [to_outer_measure_apply, ENNReal.tsum_eq_zero]\n  exact function.funext_iff.symm.trans Set.indicator_eq_zero'\n#align to_outer_measure_apply_eq_zero_iff to_outer_measure_apply_eq_zero_iff\n\n",
 "to_outer_measure_apply_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\ntheorem to_outer_measure_apply_eq_one_iff : p.to_outer_measure s = 1 ↔ p.support ⊆ s :=\n  by\n  refine' (p.to_outer_measure_apply s).symm ▸ ⟨fun h a hap => _, fun h => _⟩\n  · refine' by_contra fun hs => ne_of_lt _ (h.trans p.tsum_coe.symm)\n    have hs' : s.indicator p a = 0 := Set.indicator_apply_eq_zero.2 fun hs' => false.elim <| hs hs'\n    have hsa : s.indicator p a < p a := hs'.symm ▸ (p.apply_pos_iff a).2 hap\n    exact ENNReal.tsum_lt_tsum (p.tsum_coe_indicator_ne_top s) (fun x => Set.indicator_apply_le fun _ => le_rfl) hsa\n  · suffices : ∀ (x) (_ : x ∉ s), p x = 0\n    exact trans (tsum_congr fun a => (Set.indicator_apply s p a).trans (ite_eq_left_iff.2 <| symm ∘ this a)) p.tsum_coe\n    exact fun a ha => (p.apply_eq_zero_iff a).2 <| Set.not_mem_subset h ha\n#align to_outer_measure_apply_eq_one_iff to_outer_measure_apply_eq_one_iff\n\n",
 "to_outer_measure_apply_eq_of_inter_support_eq":
 "theorem to_outer_measure_apply_eq_of_inter_support_eq {s t : Set α} (h : s ∩ p.support = t ∩ p.support) :\n    p.to_outer_measure s = p.to_outer_measure t :=\n  le_antisymm (p.to_outer_measure_mono (h.symm ▸ Set.inter_subset_left t p.support))\n    (p.to_outer_measure_mono (h ▸ Set.inter_subset_left s p.support))\n#align to_outer_measure_apply_eq_of_inter_support_eq to_outer_measure_apply_eq_of_inter_support_eq\n\n",
 "to_outer_measure_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem to_outer_measure_apply :\n    p.to_outer_measure s =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (s.indicator p x) :=\n  tsum_congr fun x => smul_dirac_apply (p x) x s\n#align to_outer_measure_apply to_outer_measure_apply\n\n",
 "to_measure_to_pmf":
 "@[simp]\ntheorem to_measure_to_pmf : p.to_measure.to_pmf = p :=\n  Pmf.ext fun x => by rw [← p.to_measure_apply_singleton x (measurable_set_singleton x), p.to_measure.to_pmf_apply]\n#align to_measure_to_pmf to_measure_to_pmf\n\n",
 "to_measure_mono":
 "theorem to_measure_mono {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (h : s ∩ p.support ⊆ t) :\n    p.to_measure s ≤ p.to_measure t := by\n  simpa only [p.to_measure_apply_eq_to_outer_measure_apply, hs, ht] using to_outer_measure_mono p h\n#align to_measure_mono to_measure_mono\n\n",
 "to_measure_injective":
 "theorem to_measure_injective : (toMeasure : Pmf α → measure α).injective := fun p q h =>\n  Pmf.ext fun x =>\n    (p.to_measure_apply_singleton x <| measurable_set_singleton x).symm.trans\n      ((congr_fun (congr_arg _ h) _).trans <| q.to_measure_apply_singleton x <| measurable_set_singleton x)\n#align to_measure_injective to_measure_injective\n\n",
 "to_measure_inj":
 "@[simp]\ntheorem to_measure_inj {p q : Pmf α} : p.to_measure = q.to_measure ↔ p = q :=\n  toMeasure_injective.eq_iff\n#align to_measure_inj to_measure_inj\n\n",
 "to_measure_eq_iff_eq_to_pmf":
 "theorem to_measure_eq_iff_eq_to_pmf (μ : measure α) [ProbabilityMeasure μ] : p.to_measure = μ ↔ p = μ.to_pmf := by\n  rw [← to_measure_inj, measure.to_pmf_to_measure]\n#align to_measure_eq_iff_eq_to_pmf to_measure_eq_iff_eq_to_pmf\n\n",
 "to_measure_apply_singleton":
 "theorem to_measure_apply_singleton (a : α) (h : MeasurableSet ({a} : Set α)) : p.to_measure {a} = p a := by\n  simp [to_measure_apply_eq_to_outer_measure_apply _ _ h, to_outer_measure_apply_singleton]\n#align to_measure_apply_singleton to_measure_apply_singleton\n\n",
 "to_measure_apply_of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem to_measure_apply_of_finite (hs : s.finite) :\n    p.to_measure s =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (s.indicator p x) :=\n  (p.to_measure_apply_eq_to_outer_measure_apply s hs.measurable_set).trans (p.to_outer_measure_apply s)\n#align to_measure_apply_of_finite to_measure_apply_of_finite\n\n",
 "to_measure_apply_inter_support":
 "@[simp]\ntheorem to_measure_apply_inter_support (hs : MeasurableSet s) (hp : MeasurableSet p.support) :\n    p.to_measure (s ∩ p.support) = p.to_measure s := by\n  simp [p.to_measure_apply_eq_to_outer_measure_apply s hs, p.to_measure_apply_eq_to_outer_measure_apply _ (hs.inter hp)]\n#align to_measure_apply_inter_support to_measure_apply_inter_support\n\n",
 "to_measure_apply_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem to_measure_apply_fintype [Fintype α] :\n    p.to_measure s =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (s.indicator p x) :=\n  (p.to_measure_apply_eq_to_outer_measure_apply s s.to_finite.measurable_set).trans (p.to_outer_measure_apply_fintype s)\n#align to_measure_apply_fintype to_measure_apply_fintype\n\n",
 "to_measure_apply_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem to_measure_apply_finset (s : Finset α) :\n    p.to_measure s =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (p x) :=\n  (p.to_measure_apply_eq_to_outer_measure_apply s s.measurable_set).trans (p.to_outer_measure_apply_finset s)\n#align to_measure_apply_finset to_measure_apply_finset\n\n",
 "to_measure_apply_eq_zero_iff":
 "theorem to_measure_apply_eq_zero_iff (hs : MeasurableSet s) : p.to_measure s = 0 ↔ Disjoint p.support s := by\n  rw [to_measure_apply_eq_to_outer_measure_apply p s hs, to_outer_measure_apply_eq_zero_iff]\n#align to_measure_apply_eq_zero_iff to_measure_apply_eq_zero_iff\n\n",
 "to_measure_apply_eq_to_outer_measure_apply":
 "theorem to_measure_apply_eq_to_outer_measure_apply (hs : MeasurableSet s) : p.to_measure s = p.to_outer_measure s :=\n  toMeasure_apply p.to_outer_measure _ hs\n#align to_measure_apply_eq_to_outer_measure_apply to_measure_apply_eq_to_outer_measure_apply\n\n",
 "to_measure_apply_eq_one_iff":
 "theorem to_measure_apply_eq_one_iff (hs : MeasurableSet s) : p.to_measure s = 1 ↔ p.support ⊆ s :=\n  (p.to_measure_apply_eq_to_outer_measure_apply s hs : p.to_measure s = p.to_outer_measure s).symm ▸\n    p.to_outer_measure_apply_eq_one_iff s\n#align to_measure_apply_eq_one_iff to_measure_apply_eq_one_iff\n\n",
 "to_measure_apply_eq_of_inter_support_eq":
 "theorem to_measure_apply_eq_of_inter_support_eq {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : s ∩ p.support = t ∩ p.support) : p.to_measure s = p.to_measure t := by\n  simpa only [p.to_measure_apply_eq_to_outer_measure_apply, hs, ht] using\n    to_outer_measure_apply_eq_of_inter_support_eq p h\n#align to_measure_apply_eq_of_inter_support_eq to_measure_apply_eq_of_inter_support_eq\n\n",
 "to_measure_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem to_measure_apply (hs : MeasurableSet s) :\n    p.to_measure s =\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (s.indicator p x) :=\n  (p.to_measure_apply_eq_to_outer_measure_apply s hs).trans (p.to_outer_measure_apply s)\n#align to_measure_apply to_measure_apply\n\n",
 "support_nonempty":
 "@[simp]\ntheorem support_nonempty (p : Pmf α) : p.support.nonempty :=\n  Function.support_nonempty_iff.2 p.coe_ne_zero\n#align support_nonempty support_nonempty\n\n",
 "mem_support_iff":
 "@[simp]\ntheorem mem_support_iff (p : Pmf α) (a : α) : a ∈ p.support ↔ p a ≠ 0 :=\n  iff.rfl\n#align mem_support_iff mem_support_iff\n\n",
 "has_sum_coe_one":
 "theorem has_sum_coe_one (p : Pmf α) : HasSum p 1 :=\n  p.2\n#align has_sum_coe_one has_sum_coe_one\n\n",
 "ext_iff":
 "theorem ext_iff {p q : Pmf α} : p = q ↔ ∀ x, p x = q x :=\n  FunLike.ext_iff\n#align ext_iff ext_iff\n\n",
 "ext":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Devon Tuma\n-/\n@[ext]\nprotected theorem ext {p q : Pmf α} (h : ∀ x, p x = q x) : p = q :=\n  FunLike.ext p q h\n#align ext ext\n\n",
 "coe_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_ne_zero (p : Pmf α) : «expr⇑ » p ≠ 0 := fun hp =>\n  zero_ne_one ((tsum_zero.symm.trans (tsum_congr fun x => symm (congr_fun hp x))).trans p.tsum_coe)\n#align coe_ne_zero coe_ne_zero\n\n",
 "coe_le_one":
 "theorem coe_le_one (p : Pmf α) (a : α) : p a ≤ 1 :=\n  hasSum_le\n    (by\n      intro b\n      split_ifs <;> simp only [h, zero_le', le_rfl])\n    (hasSum_ite_eq a (p a)) (hasSum_coe_one p)\n#align coe_le_one coe_le_one\n\n",
 "apply_pos_iff":
 "theorem apply_pos_iff (p : Pmf α) (a : α) : 0 < p a ↔ a ∈ p.support :=\n  pos_iff_ne_zero.trans (p.mem_support_iff a).symm\n#align apply_pos_iff apply_pos_iff\n\n",
 "apply_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem apply_ne_top (p : Pmf α) (a : α) : p a ≠ ennreal.top :=\n  ne_of_lt (lt_of_le_of_lt (p.coe_le_one a) ENNReal.one_lt_top)\n#align apply_ne_top apply_ne_top\n\n",
 "apply_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `ennreal.top -/\ntheorem apply_lt_top (p : Pmf α) (a : α) : p a < ennreal.top :=\n  lt_of_le_of_ne le_top (p.apply_ne_top a)\n#align apply_lt_top apply_lt_top\n\n",
 "apply_eq_zero_iff":
 "theorem apply_eq_zero_iff (p : Pmf α) (a : α) : p a = 0 ↔ a ∉ p.support := by rw [mem_support_iff, Classical.not_not]\n#align apply_eq_zero_iff apply_eq_zero_iff\n\n",
 "apply_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∑' , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , » -/\ntheorem apply_eq_one_iff (p : Pmf α) (a : α) : p a = 1 ↔ p.support = {a} :=\n  by\n  refine'\n    ⟨fun h =>\n      Set.Subset.antisymm (fun a' ha' => by_contra fun ha => _) fun a' ha' =>\n        ha'.symm ▸ (p.mem_support_iff a).2 fun ha => zero_ne_one <| ha.symm.trans h,\n      fun h => trans (symm <| tsum_eq_single a fun a' ha' => (p.apply_eq_zero_iff a').2 (h.symm ▸ ha')) p.tsum_coe⟩\n  suffices : 1 < «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (p a)\n  exact ne_of_lt this p.tsum_coe.symm\n  have :\n    0 <\n      «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n        (ite (b = a) 0 (p b)) :=\n    lt_of_le_of_ne' zero_le'\n      ((tsum_ne_zero_iff ENNReal.summable).2 ⟨a', ite_ne_left_iff.2 ⟨ha, ne.symm <| (p.mem_support_iff a').2 ha'⟩⟩)\n  calc\n    1 = 1 + 0 := (add_zero 1).symm\n    _ <\n        p a +\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (ite (b = a) 0 (p b)) :=\n      (ENNReal.add_lt_add_of_le_of_lt ENNReal.one_ne_top (le_of_eq h.symm) this)\n    _ =\n        ite (a = a) (p a) 0 +\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (ite (b = a) 0 (p b)) :=\n      by rw [eq_self_iff_true, if_true]\n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (ite (b = a) (p b) 0) +\n          «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n            (ite (b = a) 0 (p b)) :=\n      by\n      congr\n      exact symm (tsum_eq_single a fun b hb => if_neg hb)\n    _ =\n        «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\"\n          (ite (b = a) (p b) 0 + ite (b = a) 0 (p b)) :=\n      ennreal.tsum_add.symm\n    _ = «expr∑' , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∑' , »\" (p b) :=\n      tsum_congr fun b => by split_ifs <;> simp only [zero_add, add_zero, le_rfl]\n    \n#align apply_eq_one_iff apply_eq_one_iff\n\n"}