{"pred_true_of_cond_count_eq_one":
 "theorem pred_true_of_cond_count_eq_one (h : cond_count s t = 1) : s ⊆ t :=\n  by\n  have hsf :=\n    finite_of_cond_count_ne_zero\n      (by\n        rw [h]\n        exact one_ne_zero)\n  rw [cond_count, cond_apply _ hsf.measurable_set, mul_comm] at h\n  replace h := ennreal.eq_inv_of_mul_eq_one_left h\n  rw [inv_inv, measure.count_apply_finite _ hsf, measure.count_apply_finite _ (hsf.inter_of_left _), Nat.cast_inj] at h\n  suffices s ∩ t = s by exact this ▸ fun x hx => hx.2\n  rw [← @set.finite.to_finset_inj _ _ _ (hsf.inter_of_left _) hsf]\n  exact finset.eq_of_subset_of_card_le (set.finite.to_finset_mono <| s.inter_subset_left t) h.ge\n#align pred_true_of_cond_count_eq_one pred_true_of_cond_count_eq_one\n\n",
 "finite_of_cond_count_ne_zero":
 "theorem finite_of_cond_count_ne_zero {s t : set Ω} (h : cond_count s t ≠ 0) : s.finite :=\n  by\n  by_contra hs'\n  simpa [cond_count, cond, measure.count_apply_infinite hs'] using h\n#align finite_of_cond_count_ne_zero finite_of_cond_count_ne_zero\n\n",
 "cond_count_univ":
 "theorem cond_count_univ [fintype Ω] {s : set Ω} : cond_count Set.univ s = measure.count s / fintype.card Ω :=\n  by\n  rw [cond_count, cond_apply _ measurable_set.univ, ← ennreal.div_eq_inv_mul, Set.univ_inter]\n  congr\n  rw [← finset.coe_univ, measure.count_apply, finset.univ.tsum_subtype' fun _ => (1 : ennreal)]\n  · simp [finset.card_univ]\n  · exact (@finset.coe_univ Ω _).symm ▸ measurable_set.univ\n#align cond_count_univ cond_count_univ\n\n",
 "cond_count_union":
 "theorem cond_count_union (hs : s.finite) (htu : Disjoint t u) :\n    cond_count s (t ∪ u) = cond_count s t + cond_count s u :=\n  by\n  rw [cond_count, cond_apply _ hs.measurable_set, cond_apply _ hs.measurable_set, cond_apply _ hs.measurable_set,\n    Set.inter_union_distrib_left, measure_union, mul_add]\n  exacts[htu.mono inf_le_right inf_le_right, (hs.inter_of_left _).measurable_set]\n#align cond_count_union cond_count_union\n\n",
 "cond_count_singleton":
 "theorem cond_count_singleton (ω : Ω) (t : set Ω) [decidable (ω ∈ t)] : cond_count {ω} t = if ω ∈ t then 1 else 0 :=\n  by\n  rw [cond_count, cond_apply _ (measurable_set_singleton ω), measure.count_singleton, inv_one, one_mul]\n  split_ifs\n  · rw [(by simpa : ({ω} : set Ω) ∩ t = {ω}), measure.count_singleton]\n  · rw [(by simpa : ({ω} : set Ω) ∩ t = ∅), measure.count_empty]\n#align cond_count_singleton cond_count_singleton\n\n",
 "cond_count_self":
 "theorem cond_count_self (hs : s.finite) (hs' : s.nonempty) : cond_count s s = 1 :=\n  by\n  rw [cond_count, cond_apply _ hs.measurable_set, Set.inter_self, ennreal.inv_mul_cancel]\n  · exact fun h => hs'.ne_empty <| measure.empty_of_count_eq_zero h\n  · exact (measure.count_apply_lt_top.2 hs).ne\n#align cond_count_self cond_count_self\n\n",
 "cond_count_of_univ":
 "theorem cond_count_of_univ (hs : s.finite) (hs' : s.nonempty) : cond_count s Set.univ = 1 :=\n  cond_count_eq_one_of hs hs' s.subset_univ\n#align cond_count_of_univ cond_count_of_univ\n\n",
 "cond_count_is_probability_measure":
 "theorem cond_count_is_probability_measure {s : set Ω} (hs : s.finite) (hs' : s.nonempty) :\n    is_probability_measure (cond_count s) :=\n  {\n    measure_univ :=\n      by\n      rw [cond_count, cond_apply _ hs.measurable_set, Set.inter_univ, ennreal.inv_mul_cancel]\n      · exact fun h => hs'.ne_empty <| measure.empty_of_count_eq_zero h\n      · exact (measure.count_apply_lt_top.2 hs).ne }\n#align cond_count_is_probability_measure cond_count_is_probability_measure\n\n",
 "cond_count_inter_self":
 "theorem cond_count_inter_self (hs : s.finite) : cond_count s (s ∩ t) = cond_count s t := by\n  rw [cond_count, cond_inter_self _ hs.measurable_set]\n#align cond_count_inter_self cond_count_inter_self\n\n",
 "cond_count_inter'":
 "theorem cond_count_inter' (hs : s.finite) : cond_count s (t ∩ u) = cond_count (s ∩ u) t * cond_count s u :=\n  by\n  rw [← Set.inter_comm]\n  exact cond_count_inter hs\n#align cond_count_inter' cond_count_inter'\n\n",
 "cond_count_inter":
 "theorem cond_count_inter (hs : s.finite) : cond_count s (t ∩ u) = cond_count (s ∩ t) u * cond_count s t :=\n  by\n  by_cases hst : s ∩ t = ∅\n  ·\n    rw [hst, cond_count_empty_meas, measure.coe_zero, pi.zero_apply, zero_mul, cond_count_eq_zero_iff hs, ←\n      Set.inter_assoc, hst, Set.empty_inter]\n  rw [cond_count, cond_count, cond_apply _ hs.measurable_set, cond_apply _ hs.measurable_set,\n    cond_apply _ (hs.inter_of_left _).measurable_set, mul_comm _ (measure.count (s ∩ t)), ← mul_assoc,\n    mul_comm _ (measure.count (s ∩ t)), ← mul_assoc, ennreal.mul_inv_cancel, one_mul, mul_comm, Set.inter_assoc]\n  · rwa [← measure.count_eq_zero_iff] at hst\n  · exact (measure.count_apply_lt_top.2 <| hs.inter_of_left _).ne\n#align cond_count_inter cond_count_inter\n\n",
 "cond_count_eq_zero_iff":
 "theorem cond_count_eq_zero_iff (hs : s.finite) : cond_count s t = 0 ↔ s ∩ t = ∅ := by\n  simp [cond_count, cond_apply _ hs.measurable_set, measure.count_apply_eq_top, set.not_infinite.2 hs,\n    measure.count_apply_finite _ (hs.inter_of_left _)]\n#align cond_count_eq_zero_iff cond_count_eq_zero_iff\n\n",
 "cond_count_eq_one_of":
 "theorem cond_count_eq_one_of (hs : s.finite) (hs' : s.nonempty) (ht : s ⊆ t) : cond_count s t = 1 :=\n  by\n  haveI := cond_count_is_probability_measure hs hs'\n  refine' eq_of_le_of_not_lt prob_le_one _\n  rw [not_lt, ← cond_count_self hs hs']\n  exact measure_mono ht\n#align cond_count_eq_one_of cond_count_eq_one_of\n\n",
 "cond_count_empty_meas":
 "/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying, Bhavik Mehta\n-/\n@[simp]\ntheorem cond_count_empty_meas : (cond_count ∅ : measure Ω) = 0 := by simp [cond_count]\n#align cond_count_empty_meas cond_count_empty_meas\n\n",
 "cond_count_empty":
 "theorem cond_count_empty {s : set Ω} : cond_count s ∅ = 0 := by simp\n#align cond_count_empty cond_count_empty\n\n",
 "cond_count_disjoint_union":
 "theorem cond_count_disjoint_union (hs : s.finite) (ht : t.finite) (hst : Disjoint s t) :\n    cond_count s u * cond_count (s ∪ t) s + cond_count t u * cond_count (s ∪ t) t = cond_count (s ∪ t) u :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | hs') <;> rcases t.eq_empty_or_nonempty with (rfl | ht')\n  · simp\n  · simp [cond_count_self ht ht']\n  · simp [cond_count_self hs hs']\n  rw [cond_count, cond_count, cond_count, cond_apply _ hs.measurable_set, cond_apply _ ht.measurable_set,\n    cond_apply _ (hs.union ht).measurable_set, cond_apply _ (hs.union ht).measurable_set,\n    cond_apply _ (hs.union ht).measurable_set]\n  conv_lhs =>\n    rw [Set.union_inter_cancel_left, Set.union_inter_cancel_right, mul_comm (measure.count (s ∪ t))⁻¹,\n      mul_comm (measure.count (s ∪ t))⁻¹, ← mul_assoc, ← mul_assoc, mul_comm _ (measure.count s),\n      mul_comm _ (measure.count t), ← mul_assoc, ← mul_assoc]\n  rw [ennreal.mul_inv_cancel, ennreal.mul_inv_cancel, one_mul, one_mul, ← add_mul, ← measure_union,\n    Set.union_inter_distrib_right, mul_comm]\n  exacts[hst.mono inf_le_left inf_le_left, (ht.inter_of_left _).measurable_set, measure.count_ne_zero ht',\n    (measure.count_apply_lt_top.2 ht).ne, measure.count_ne_zero hs', (measure.count_apply_lt_top.2 hs).ne]\n#align cond_count_disjoint_union cond_count_disjoint_union\n\n",
 "cond_count_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\ntheorem cond_count_compl (t : set Ω) (hs : s.finite) (hs' : s.nonempty) :\n    cond_count s t + cond_count s («expr ᶜ» t) = 1 := by\n  rw [← cond_count_union hs disjoint_compl_right, Set.union_compl_self,\n    (cond_count_is_probability_measure hs hs').measure_univ]\n#align cond_count_compl cond_count_compl\n\n",
 "cond_count_add_compl_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n/-- A version of the law of total probability for counting probabilites. -/\ntheorem cond_count_add_compl_eq (u t : set Ω) (hs : s.finite) :\n    cond_count (s ∩ u) t * cond_count s u + cond_count (s ∩ «expr ᶜ» u) t * cond_count s («expr ᶜ» u) =\n      cond_count s t :=\n  by\n  conv_rhs =>\n    rw [(by simp : s = s ∩ u ∪ s ∩ «expr ᶜ» u), ←\n      cond_count_disjoint_union (hs.inter_of_left _) (hs.inter_of_left _)\n        (disjoint_compl_right.mono inf_le_right inf_le_right)]\n  simp [cond_count_inter_self hs]\n#align cond_count_add_compl_eq cond_count_add_compl_eq\n\n"}