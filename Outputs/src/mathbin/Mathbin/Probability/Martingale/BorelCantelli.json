{"tendsto_sum_indicator_at_top_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem tendsto_sum_indicator_at_top_iff' [is_finite_measure μ] {s : ℕ → set Ω}\n    (hs : ∀ n, (measurable_set_of (ℱ n)) (s n)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (tendsto\n          (fun n =>\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range n) ((s (k + 1)).indicator (1 : Ω → exprℝ) ω))\n          at_top at_top ↔\n        tendsto\n          (fun n =>\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range n) ((measure_theory.condexp μ ((s (k + 1)).indicator (1 : Ω → exprℝ)) (ℱ k)) ω))\n          at_top at_top) :=\n  by\n  have :=\n    tendsto_sum_indicator_at_top_iff (eventually_of_forall fun ω n => _) (adapted_process hs) (integrable_process μ hs)\n      (eventually_of_forall <| process_difference_le s)\n  swap\n  · rw [process, process, ← sub_nonneg, finset.sum_apply, finset.sum_apply, finset.sum_range_succ_sub_sum]\n    exact set.indicator_nonneg (fun _ _ => zero_le_one) _\n  simp_rw [process, predictable_part_process_ae_eq] at this\n  simpa using this\n#align tendsto_sum_indicator_at_top_iff' tendsto_sum_indicator_at_top_iff'\n\n",
 "tendsto_sum_indicator_at_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/-- An a.e. monotone adapted process `f` with uniformly bounded differences converges to `+∞` if\nand only if its predictable part also converges to `+∞`. -/\ntheorem tendsto_sum_indicator_at_top_iff [is_finite_measure μ]\n    (hfmono :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ n, f n ω ≤ f (n + 1) ω))\n    (hf : adapted ℱ f) (hint : ∀ n, integrable (f n) μ)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ n, |f (n + 1) ω - f n ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (tendsto (fun n => f n ω) at_top at_top ↔ tendsto (fun n => predictable_part f ℱ μ n ω) at_top at_top) :=\n  by\n  have h₁ := (martingale_martingale_part hf hint).ae_not_tendsto_at_top_at_top (martingale_part_bdd_difference ℱ hbdd)\n  have h₂ := (martingale_martingale_part hf hint).ae_not_tendsto_at_top_at_bot (martingale_part_bdd_difference ℱ hbdd)\n  have h₃ :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ n, 0 ≤ (measure_theory.condexp μ (f (n + 1) - f n) (ℱ n)) ω) :=\n    by\n    refine' ae_all_iff.2 fun n => condexp_nonneg _\n    filter_upwards [ae_all_iff.1 hfmono n] with ω hω using sub_nonneg.2 hω\n  filter_upwards [h₁, h₂, h₃, hfmono] with ω hω₁ hω₂ hω₃ hω₄\n  constructor <;> intro ht\n  · refine' tendsto_at_top_at_top_of_monotone' _ _\n    · intro n m hnm\n      simp only [predictable_part, finset.sum_apply]\n      refine' finset.sum_mono_set_of_nonneg hω₃ (Finset.range_mono hnm)\n    rintro ⟨b, hbdd⟩\n    rw [← tendsto_neg_at_bot_iff] at ht\n    simp only [martingale_part, sub_eq_add_neg] at hω₁\n    exact hω₁ (tendsto_at_top_add_right_of_le _ (-b) (tendsto_neg_at_bot_iff.1 ht) fun n => neg_le_neg (hbdd ⟨n, rfl⟩))\n  · refine' tendsto_at_top_at_top_of_monotone' (monotone_nat_of_le_succ hω₄) _\n    rintro ⟨b, hbdd⟩\n    exact hω₂ ((tendsto_at_bot_add_left_of_ge _ b fun n => hbdd ⟨n, rfl⟩) <| tendsto_neg_at_bot_iff.2 ht)\n#align tendsto_sum_indicator_at_top_iff tendsto_sum_indicator_at_top_iff\n\n",
 "stopped_value_stopped_value_least_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem stopped_value_stopped_value_least_ge (f : ℕ → Ω → exprℝ) (π : Ω → ℕ) (r : exprℝ) {n : ℕ} (hπn : ∀ ω, π ω ≤ n) :\n    stopped_value (fun i => stopped_value f (least_ge f r i)) π =\n      stopped_value (stopped_process f (least_ge f r n)) π :=\n  by\n  ext1 ω\n  simp_rw [stopped_process, stopped_value]\n  rw [least_ge_eq_min _ _ _ hπn]\n#align stopped_value_stopped_value_least_ge stopped_value_stopped_value_least_ge\n\n",
 "stopped_value_least_ge_snorm_le'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem submartingale.stopped_value_least_ge_snorm_le' [is_finite_measure μ] (hf : submartingale f ℱ μ) (hr : 0 ≤ r)\n    (hf0 : f 0 = 0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R))\n    (i : ℕ) :\n    snorm (stopped_value f (least_ge f r i)) 1 μ ≤ ennreal.to_nnreal (2 * μ Set.univ * ennreal.of_real (r + R)) :=\n  by\n  refine' (hf.stopped_value_least_ge_snorm_le hr hf0 hbdd i).trans _\n  simp [ennreal.coe_to_nnreal (measure_ne_top μ _), ennreal.coe_to_nnreal]\n#align submartingale.stopped_value_least_ge_snorm_le' submartingale.stopped_value_least_ge_snorm_le'\n\n",
 "stopped_value_least_ge_snorm_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem submartingale.stopped_value_least_ge_snorm_le [is_finite_measure μ] (hf : submartingale f ℱ μ) (hr : 0 ≤ r)\n    (hf0 : f 0 = 0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R))\n    (i : ℕ) : snorm (stopped_value f (least_ge f r i)) 1 μ ≤ 2 * μ Set.univ * ennreal.of_real (r + R) :=\n  by\n  refine'\n    snorm_one_le_of_le' ((hf.stopped_value_least_ge r).integrable _) _ (norm_stopped_value_least_ge_le hr hf0 hbdd i)\n  rw [← integral_univ]\n  refine' le_trans _ ((hf.stopped_value_least_ge r).set_integral_le (zero_le _) measurable_set.univ)\n  simp_rw [stopped_value, least_ge, hitting_of_le le_rfl, hf0, integral_zero']\n#align submartingale.stopped_value_least_ge_snorm_le submartingale.stopped_value_least_ge_snorm_le\n\n",
 "stopped_value_least_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem submartingale.stopped_value_least_ge [is_finite_measure μ] (hf : submartingale f ℱ μ) (r : exprℝ) :\n    submartingale (fun i => stopped_value f (least_ge f r i)) ℱ μ :=\n  by\n  rw [submartingale_iff_expected_stopped_value_mono]\n  · intro σ π hσ hπ hσ_le_π hπ_bdd\n    obtain ⟨n, hπ_le_n⟩ := hπ_bdd\n    simp_rw [stopped_value_stopped_value_least_ge f σ r fun i => (hσ_le_π i).trans (hπ_le_n i)]\n    simp_rw [stopped_value_stopped_value_least_ge f π r hπ_le_n]\n    refine' hf.expected_stopped_value_mono _ _ _ fun ω => (min_le_left _ _).trans (hπ_le_n ω)\n    · exact hσ.min (hf.adapted.is_stopping_time_least_ge _ _)\n    · exact hπ.min (hf.adapted.is_stopping_time_least_ge _ _)\n    · exact fun ω => min_le_min (hσ_le_π ω) le_rfl\n  ·\n    exact fun i =>\n      strongly_measurable_stopped_value_of_le hf.adapted.prog_measurable_of_discrete\n        (hf.adapted.is_stopping_time_least_ge _ _) least_ge_le\n  · exact fun i => integrable_stopped_value _ (hf.adapted.is_stopping_time_least_ge _ _) hf.integrable least_ge_le\n#align submartingale.stopped_value_least_ge submartingale.stopped_value_least_ge\n\n",
 "process_zero":
 "theorem process_zero : process s 0 = 0 := by rw [process, Finset.range_zero, finset.sum_empty]\n#align process_zero process_zero\n\n",
 "process_difference_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\ntheorem process_difference_le (s : ℕ → set Ω) (ω : Ω) (n : ℕ) : |process s (n + 1) ω - process s n ω| ≤ (1 : nnreal) :=\n  by\n  rw [nonneg.coe_one, process, process, finset.sum_apply, finset.sum_apply, finset.sum_range_succ_sub_sum, ←\n    real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n  refine' set.indicator_le' (fun _ _ => _) (fun _ _ => zero_le_one) _\n  rw [pi.one_apply, norm_one]\n#align process_difference_le process_difference_le\n\n",
 "predictable_part_process_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem predictable_part_process_ae_eq (ℱ : filtration ℕ m0) (μ : measure Ω) (s : ℕ → set Ω) (n : ℕ) :\n    predictable_part (process s) ℱ μ n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        (measure_theory.condexp μ ((s (k + 1)).indicator (1 : Ω → exprℝ)) (ℱ k)) :=\n  by\n  have := martingale_part_process_ae_eq ℱ μ s n\n  simp_rw [martingale_part, process, finset.sum_sub_distrib] at this\n  exact sub_right_injective this\n#align predictable_part_process_ae_eq predictable_part_process_ae_eq\n\n",
 "norm_stopped_value_least_ge_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem norm_stopped_value_least_ge_le (hr : 0 ≤ r) (hf0 : f 0 = 0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R))\n    (i : ℕ) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (stopped_value f (least_ge f r i) ω ≤ r + R) :=\n  by\n  filter_upwards [hbdd] with ω hbddω\n  change f (least_ge f r i ω) ω ≤ r + R\n  by_cases heq : least_ge f r i ω = 0\n  · rw [HEq, hf0, pi.zero_apply]\n    exact add_nonneg hr R.coe_nonneg\n  · obtain ⟨k, hk⟩ := nat.exists_eq_succ_of_ne_zero HEq\n    rw [hk, add_comm, ← sub_le_iff_le_add]\n    have := not_mem_of_lt_hitting (hk.symm ▸ k.lt_succ_self : k < least_ge f r i ω) (zero_le _)\n    simp only [Set.mem_union, Set.mem_Iic, Set.mem_Ici, not_or, not_le] at this\n    exact (sub_lt_sub_left this _).le.trans ((le_abs_self _).trans (hbddω _))\n#align norm_stopped_value_least_ge_le norm_stopped_value_least_ge_le\n\n",
 "martingale_part_process_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\ntheorem martingale_part_process_ae_eq (ℱ : filtration ℕ m0) (μ : measure Ω) (s : ℕ → set Ω) (n : ℕ) :\n    martingale_part (process s) ℱ μ n =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n        ((s (k + 1)).indicator 1 - measure_theory.condexp μ ((s (k + 1)).indicator 1) (ℱ k)) :=\n  by\n  simp only [martingale_part_eq_sum, process_zero, zero_add]\n  refine' finset.sum_congr rfl fun k hk => _\n  simp only [process, finset.sum_range_succ_sub_sum]\n#align martingale_part_process_ae_eq martingale_part_process_ae_eq\n\n",
 "least_ge_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n-- The following four lemmas shows `least_ge` behaves like a stopped process. Ideally we should\n-- define `least_ge` as a stopping time and take its stopped process. However, we can't do that\n-- with our current definition since a stopping time takes only finite indicies. An upcomming\n-- refactor should hopefully make it possible to have stopping times taking infinity as a value\ntheorem least_ge_mono {n m : ℕ} (hnm : n ≤ m) (r : exprℝ) (ω : Ω) : least_ge f r n ω ≤ least_ge f r m ω :=\n  hitting_mono hnm\n#align least_ge_mono least_ge_mono\n\n",
 "least_ge_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem least_ge_le {i : ℕ} {r : exprℝ} (ω : Ω) : least_ge f r i ω ≤ i :=\n  hitting_le ω\n#align least_ge_le least_ge_le\n\n",
 "least_ge_eq_min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem least_ge_eq_min (π : Ω → ℕ) (r : exprℝ) (ω : Ω) {n : ℕ} (hπn : ∀ ω, π ω ≤ n) :\n    least_ge f r (π ω) ω = min (π ω) (least_ge f r n ω) := by\n  classical\n    refine' le_antisymm (le_min (least_ge_le _) (least_ge_mono (hπn ω) r ω)) _\n    by_cases hle : π ω ≤ least_ge f r n ω\n    · rw [min_eq_left hle, least_ge]\n      by_cases h : ∃ j ∈ Set.Icc 0 (π ω), f j ω ∈ Set.Ici r\n      · refine' hle.trans (eq.le _)\n        rw [least_ge, ← hitting_eq_hitting_of_exists (hπn ω) h]\n      · simp only [hitting, if_neg h]\n    · rw [min_eq_right (not_le.1 hle).le, least_ge, least_ge, ← hitting_eq_hitting_of_exists (hπn ω) _]\n      rw [not_le, least_ge, hitting_lt_iff _ (hπn ω)] at hle\n      exact\n        let ⟨j, hj₁, hj₂⟩ := hle\n        ⟨j, ⟨hj₁.1, hj₁.2.le⟩, hj₂⟩\n#align least_ge_eq_min least_ge_eq_min\n\n",
 "is_stopping_time_least_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n-- TODO: `least_ge` should be defined taking values in `with_top ℕ` once the `stopped_process`\n-- refactor is complete\ntheorem adapted.is_stopping_time_least_ge (r : exprℝ) (n : ℕ) (hf : adapted ℱ f) :\n    is_stopping_time ℱ (least_ge f r n) :=\n  hitting_is_stopping_time hf measurable_set_Ici\n#align adapted.is_stopping_time_least_ge adapted.is_stopping_time_least_ge\n\n",
 "integrable_process":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem integrable_process (μ : measure Ω) [is_finite_measure μ] (hs : ∀ n, (measurable_set_of (ℱ n)) (s n)) (n : ℕ) :\n    integrable (process s n) μ :=\n  integrable_finset_sum' _ fun k hk => integrable_on.integrable_indicator (integrable_const 1) <| ℱ.le _ _ <| hs _\n#align integrable_process integrable_process\n\n",
 "exists_tendsto_of_abs_bdd_above_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- This lemma is superceded by `submartingale.bdd_above_iff_exists_tendsto`. -/\ntheorem submartingale.exists_tendsto_of_abs_bdd_above_aux [is_finite_measure μ] (hf : submartingale f ℱ μ)\n    (hf0 : f 0 = 0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (BddAbove (Set.range fun n => f n ω) → ∃ c, tendsto (fun n => f n ω) at_top ((nhds) c)) :=\n  by\n  have ht :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ i : ℕ, ∃ c, tendsto (fun n => stopped_value f (least_ge f i n) ω) at_top ((nhds) c)) :=\n    by\n    rw [ae_all_iff]\n    exact fun i =>\n      submartingale.exists_ae_tendsto_of_bdd (hf.stopped_value_least_ge i)\n        (hf.stopped_value_least_ge_snorm_le' i.cast_nonneg hf0 hbdd)\n  filter_upwards [ht] with ω hω hωb\n  rw [BddAbove] at hωb\n  obtain ⟨i, hi⟩ := exists_nat_gt hωb.some\n  have hib : ∀ n, f n ω < i := by\n    intro n\n    exact lt_of_le_of_lt ((mem_upperBounds.1 hωb.some_mem) _ ⟨n, rfl⟩) hi\n  have heq : ∀ n, stopped_value f (least_ge f i n) ω = f n ω :=\n    by\n    intro n\n    rw [least_ge, hitting, stopped_value]\n    simp only\n    rw [if_neg]\n    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]\n    push_neg\n    exact fun j _ => hib j\n  simp only [← HEq, hω i]\n#align submartingale.exists_tendsto_of_abs_bdd_above_aux submartingale.exists_tendsto_of_abs_bdd_above_aux\n\n",
 "bdd_above_range_iff_bdd_below_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem martingale.bdd_above_range_iff_bdd_below_range [is_finite_measure μ] (hf : martingale f ℱ μ)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (BddAbove (Set.range fun n => f n ω) ↔ BddBelow (Set.range fun n => f n ω)) :=\n  by\n  have hbdd' :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ i, |(-f) (i + 1) ω - (-f) i ω| ≤ R) :=\n    by\n    filter_upwards [hbdd] with ω hω i\n    erw [← abs_neg, neg_sub, sub_neg_eq_add, neg_add_eq_sub]\n    exact hω i\n  have hup := hf.submartingale.bdd_above_iff_exists_tendsto hbdd\n  have hdown := hf.neg.submartingale.bdd_above_iff_exists_tendsto hbdd'\n  filter_upwards [hup, hdown] with ω hω₁ hω₂\n  have : (∃ c, tendsto (fun n => f n ω) at_top ((nhds) c)) ↔ ∃ c, tendsto (fun n => (-f) n ω) at_top ((nhds) c) :=\n    by\n    constructor <;> rintro ⟨c, hc⟩\n    · exact ⟨-c, hc.neg⟩\n    · refine' ⟨-c, _⟩\n      convert hc.neg\n      simp only [neg_neg, pi.neg_apply]\n  rw [hω₁, this, ← hω₂]\n  constructor <;> rintro ⟨c, hc⟩ <;> refine' ⟨-c, fun ω hω => _⟩\n  · rw [mem_upperBounds] at hc\n    refine' neg_le.2 (hc _ _)\n    simpa only [pi.neg_apply, Set.mem_range, neg_inj]\n  · rw [mem_lowerBounds] at hc\n    simp_rw [Set.mem_range, pi.neg_apply, neg_eq_iff_neg_eq, eq_comm] at hω\n    refine' le_neg.1 (hc _ _)\n    simpa only [Set.mem_range]\n#align martingale.bdd_above_range_iff_bdd_below_range martingale.bdd_above_range_iff_bdd_below_range\n\n",
 "bdd_above_iff_exists_tendsto_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\ntheorem submartingale.bdd_above_iff_exists_tendsto_aux [is_finite_measure μ] (hf : submartingale f ℱ μ) (hf0 : f 0 = 0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (BddAbove (Set.range fun n => f n ω) ↔ ∃ c, tendsto (fun n => f n ω) at_top ((nhds) c)) :=\n  by\n  filter_upwards [hf.exists_tendsto_of_abs_bdd_above_aux hf0\n      hbdd] with ω hω using⟨hω, fun ⟨c, hc⟩ => hc.bdd_above_range⟩\n#align submartingale.bdd_above_iff_exists_tendsto_aux submartingale.bdd_above_iff_exists_tendsto_aux\n\n",
 "bdd_above_iff_exists_tendsto":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nhds -/\n/-- One sided martingale bound: If `f` is a submartingale which has uniformly bounded differences,\nthen for almost every `ω`, `f n ω` is bounded above (in `n`) if and only if it converges. -/\ntheorem submartingale.bdd_above_iff_exists_tendsto [is_finite_measure μ] (hf : submartingale f ℱ μ)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (BddAbove (Set.range fun n => f n ω) ↔ ∃ c, tendsto (fun n => f n ω) at_top ((nhds) c)) :=\n  by\n  set g : ℕ → Ω → exprℝ := fun n ω => f n ω - f 0 ω with hgdef\n  have hg : submartingale g ℱ μ := hf.sub_martingale (martingale_const_fun _ _ (hf.adapted 0) (hf.integrable 0))\n  have hg0 : g 0 = 0 := by\n    ext ω\n    simp only [hgdef, sub_self, pi.zero_apply]\n  have hgbdd :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ i : ℕ, |g (i + 1) ω - g i ω| ≤ ↑R) :=\n    by simpa only [sub_sub_sub_cancel_right]\n  filter_upwards [hg.bdd_above_iff_exists_tendsto_aux hg0 hgbdd] with ω hω\n  convert hω using 1 <;> rw [eq_iff_iff]\n  · simp only [hgdef]\n    refine' ⟨fun h => _, fun h => _⟩ <;> obtain ⟨b, hb⟩ := h <;> refine' ⟨b + |f 0 ω|, fun y hy => _⟩ <;>\n      obtain ⟨n, rfl⟩ := hy\n    · simp_rw [sub_eq_add_neg]\n      exact add_le_add (hb ⟨n, rfl⟩) (neg_le_abs_self _)\n    · exact sub_le_iff_le_add.1 (le_trans (sub_le_sub_left (le_abs_self _) _) (hb ⟨n, rfl⟩))\n  · simp only [hgdef]\n    refine' ⟨fun h => _, fun h => _⟩ <;> obtain ⟨c, hc⟩ := h\n    · exact ⟨c - f 0 ω, hc.sub_const _⟩\n    · refine' ⟨c + f 0 ω, _⟩\n      have := hc.add_const (f 0 ω)\n      simpa only [sub_add_cancel]\n#align submartingale.bdd_above_iff_exists_tendsto submartingale.bdd_above_iff_exists_tendsto\n\n",
 "ae_not_tendsto_at_top_at_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem martingale.ae_not_tendsto_at_top_at_top [is_finite_measure μ] (hf : martingale f ℱ μ)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      ¬tendsto (fun n => f n ω) at_top at_top :=\n  by\n  filter_upwards [hf.bdd_above_range_iff_bdd_below_range\n      hbdd] with ω hω htop using unbounded_of_tendsto_at_top htop\n      (hω.2 <| bdd_below_range_of_tendsto_at_top_at_top htop)\n#align martingale.ae_not_tendsto_at_top_at_top martingale.ae_not_tendsto_at_top_at_top\n\n",
 "ae_not_tendsto_at_top_at_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem martingale.ae_not_tendsto_at_top_at_bot [is_finite_measure μ] (hf : martingale f ℱ μ)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      ¬tendsto (fun n => f n ω) at_top at_bot :=\n  by\n  filter_upwards [hf.bdd_above_range_iff_bdd_below_range\n      hbdd] with ω hω htop using unbounded_of_tendsto_at_bot htop\n      (hω.1 <| bdd_above_range_of_tendsto_at_top_at_bot htop)\n#align martingale.ae_not_tendsto_at_top_at_bot martingale.ae_not_tendsto_at_top_at_bot\n\n",
 "ae_mem_limsup_at_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Lévy's generalization of the Borel-Cantelli lemma**: given a sequence of sets `s` and a\nfiltration `ℱ` such that for all `n`, `s n` is `ℱ n`-measurable, `at_top.limsup s` is almost\neverywhere equal to the set for which `∑ k, ℙ(s (k + 1) | ℱ k) = ∞`. -/\ntheorem ae_mem_limsup_at_top_iff (μ : measure Ω) [is_finite_measure μ] {s : ℕ → set Ω}\n    (hs : ∀ n, (measurable_set_of (ℱ n)) (s n)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (ω ∈ limsup s at_top ↔\n        tendsto\n          (fun n =>\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range n) ((measure_theory.condexp μ ((s (k + 1)).indicator (1 : Ω → exprℝ)) (ℱ k)) ω))\n          at_top at_top) :=\n  (limsup_eq_tendsto_sum_indicator_at_top (exprℝ) s).symm ▸ tendsto_sum_indicator_at_top_iff' hs\n#align ae_mem_limsup_at_top_iff ae_mem_limsup_at_top_iff\n\n",
 "adapted_process":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\ntheorem adapted_process (hs : ∀ n, (measurable_set_of (ℱ n)) (s n)) : adapted ℱ (process s) := fun n =>\n  finset.strongly_measurable_sum' _ fun k hk =>\n    strongly_measurable_one.indicator <| ℱ.mono (Finset.mem_range.1 hk) _ <| hs _\n#align adapted_process adapted_process\n\n"}