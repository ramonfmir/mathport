{"predictable_part_zero":
 "/-\nCopyright (c) 2022 Rémy Degenne. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Rémy Degenne\n-/\n@[simp]\ntheorem predictable_part_zero : predictable_part f ℱ μ 0 = 0 := by\n  simp_rw [predictable_part, Finset.range_zero, finset.sum_empty]\n#align predictable_part_zero predictable_part_zero\n\n",
 "predictable_part_bdd_difference":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem predictable_part_bdd_difference {R : nnreal} {f : ℕ → Ω → exprℝ} (ℱ : filtration ℕ m0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ i, |predictable_part f ℱ μ (i + 1) ω - predictable_part f ℱ μ i ω| ≤ R) :=\n  by\n  simp_rw [predictable_part, finset.sum_apply, finset.sum_range_succ_sub_sum]\n  exact ae_all_iff.2 fun i => ae_bdd_condexp_of_ae_bdd <| ae_all_iff.1 hbdd i\n#align predictable_part_bdd_difference predictable_part_bdd_difference\n\n",
 "predictable_part_add_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\ntheorem predictable_part_add_ae_eq [sigma_finite_filtration μ ℱ] {f g : ℕ → Ω → E} (hf : martingale f ℱ μ)\n    (hg : adapted ℱ fun n => g (n + 1)) (hg0 : g 0 = 0) (hgint : ∀ n, integrable (g n) μ) (n : ℕ) :\n    «expr =ᵐ[ ] » (predictable_part (f + g) ℱ μ n) μ (g n) :=\n  by\n  filter_upwards [martingale_part_add_ae_eq hf hg hg0 hgint n] with ω hω\n  rw [← add_right_inj (f n ω)]\n  conv_rhs => rw [← pi.add_apply, ← pi.add_apply, ← martingale_part_add_predictable_part ℱ μ (f + g)]\n  rw [pi.add_apply, pi.add_apply, hω]\n#align predictable_part_add_ae_eq predictable_part_add_ae_eq\n\n",
 "martingale_part_eq_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\ntheorem martingale_part_eq_sum :\n    martingale_part f ℱ μ = fun n =>\n      f 0 +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range n)\n          (f (i + 1) - f i - measure_theory.condexp μ (f (i + 1) - f i) (ℱ i)) :=\n  by\n  rw [martingale_part, predictable_part]\n  ext1 n\n  rw [finset.eq_sum_range_sub f n, ← add_sub, ← finset.sum_sub_distrib]\n#align martingale_part_eq_sum martingale_part_eq_sum\n\n",
 "martingale_part_bdd_difference":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∀ᵐ ∂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , » -/\ntheorem martingale_part_bdd_difference {R : nnreal} {f : ℕ → Ω → exprℝ} (ℱ : filtration ℕ m0)\n    (hbdd :\n      «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n        (∀ i, |f (i + 1) ω - f i ω| ≤ R)) :\n    «expr∀ᵐ ∂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∀ᵐ ∂ , »\" μ\n      (∀ i, |martingale_part f ℱ μ (i + 1) ω - martingale_part f ℱ μ i ω| ≤ ↑(2 * R)) :=\n  by\n  filter_upwards [hbdd, predictable_part_bdd_difference ℱ hbdd] with ω hω₁ hω₂ i\n  simp only [two_mul, martingale_part, pi.sub_apply]\n  have :\n    |f (i + 1) ω - predictable_part f ℱ μ (i + 1) ω - (f i ω - predictable_part f ℱ μ i ω)| =\n      |f (i + 1) ω - f i ω - (predictable_part f ℱ μ (i + 1) ω - predictable_part f ℱ μ i ω)| :=\n    by ring_nf\n  -- `ring` suggests `ring_nf` despite proving the goal\n  rw [this]\n  exact (abs_sub _ _).trans (add_le_add (hω₁ i) (hω₂ i))\n#align martingale_part_bdd_difference martingale_part_bdd_difference\n\n",
 "martingale_part_add_predictable_part":
 "theorem martingale_part_add_predictable_part (ℱ : filtration ℕ m0) (μ : measure Ω) (f : ℕ → Ω → E) :\n    martingale_part f ℱ μ + predictable_part f ℱ μ = f :=\n  sub_add_cancel _ _\n#align martingale_part_add_predictable_part martingale_part_add_predictable_part\n\n",
 "martingale_part_add_ae_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n-- The following two lemmas demonstrate the essential uniqueness of the decomposition\ntheorem martingale_part_add_ae_eq [sigma_finite_filtration μ ℱ] {f g : ℕ → Ω → E} (hf : martingale f ℱ μ)\n    (hg : adapted ℱ fun n => g (n + 1)) (hg0 : g 0 = 0) (hgint : ∀ n, integrable (g n) μ) (n : ℕ) :\n    «expr =ᵐ[ ] » (martingale_part (f + g) ℱ μ n) μ (f n) :=\n  by\n  set h := f - martingale_part (f + g) ℱ μ with hhdef\n  have hh : h = predictable_part (f + g) ℱ μ - g := by\n    rw [hhdef, sub_eq_sub_iff_add_eq_add, add_comm (predictable_part (f + g) ℱ μ), martingale_part_add_predictable_part]\n  have hhpred : adapted ℱ fun n => h (n + 1) := by\n    rw [hh]\n    exact adapted_predictable_part.sub hg\n  have hhmgle : martingale h ℱ μ :=\n    hf.sub\n      (martingale_martingale_part (hf.adapted.add <| predictable.adapted hg <| hg0.symm ▸ strongly_measurable_zero)\n        fun n => (hf.integrable n).add <| hgint n)\n  refine' (eventually_eq_iff_sub.2 _).symm\n  filter_upwards [hhmgle.eq_zero_of_predictable hhpred n] with ω hω\n  rw [hhdef, pi.sub_apply] at hω\n  rw [hω, pi.sub_apply, martingale_part]\n  simp [hg0]\n#align martingale_part_add_ae_eq martingale_part_add_ae_eq\n\n",
 "martingale_martingale_part":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr =ᵐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measure_theory.condexp -/\ntheorem martingale_martingale_part (hf : adapted ℱ f) (hf_int : ∀ n, integrable (f n) μ) [sigma_finite_filtration μ ℱ] :\n    martingale (martingale_part f ℱ μ) ℱ μ :=\n  by\n  refine' ⟨adapted_martingale_part hf, fun i j hij => _⟩\n  -- ⊢ μ[martingale_part f ℱ μ j | ℱ i] =ᵐ[μ] martingale_part f ℱ μ i\n  have h_eq_sum :\n    «expr =ᵐ[ ] » (measure_theory.condexp μ (martingale_part f ℱ μ j) (ℱ i)) μ\n      (f 0 +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range j)\n          (measure_theory.condexp μ (f (k + 1) - f k) (ℱ i) -\n            measure_theory.condexp μ (measure_theory.condexp μ (f (k + 1) - f k) (ℱ k)) (ℱ i))) :=\n    by\n    rw [martingale_part_eq_sum]\n    refine' (condexp_add (hf_int 0) _).trans _\n    · exact integrable_finset_sum' _ fun i hij => ((hf_int _).sub (hf_int _)).sub integrable_condexp\n    refine' (eventually_eq.add eventually_eq.rfl (condexp_finset_sum fun i hij => _)).trans _\n    · exact ((hf_int _).sub (hf_int _)).sub integrable_condexp\n    refine' eventually_eq.add _ _\n    · rw [condexp_of_strongly_measurable (ℱ.le _) _ (hf_int 0)]\n      · infer_instance\n      · exact (hf 0).mono (ℱ.mono (zero_le i))\n    · exact eventually_eq_sum fun k hkj => condexp_sub ((hf_int _).sub (hf_int _)) integrable_condexp\n  refine' h_eq_sum.trans _\n  have h_ge :\n    ∀ k,\n      i ≤ k →\n        «expr =ᵐ[ ] »\n          (measure_theory.condexp μ (f (k + 1) - f k) (ℱ i) -\n            measure_theory.condexp μ (measure_theory.condexp μ (f (k + 1) - f k) (ℱ k)) (ℱ i))\n          μ 0 :=\n    by\n    intro k hk\n    have :\n      «expr =ᵐ[ ] » (measure_theory.condexp μ (measure_theory.condexp μ (f (k + 1) - f k) (ℱ k)) (ℱ i)) μ\n        (measure_theory.condexp μ (f (k + 1) - f k) (ℱ i)) :=\n      condexp_condexp_of_le (ℱ.mono hk) (ℱ.le k)\n    filter_upwards [this] with x hx\n    rw [pi.sub_apply, pi.zero_apply, hx, sub_self]\n  have h_lt :\n    ∀ k,\n      k < i →\n        «expr =ᵐ[ ] »\n          (measure_theory.condexp μ (f (k + 1) - f k) (ℱ i) -\n            measure_theory.condexp μ (measure_theory.condexp μ (f (k + 1) - f k) (ℱ k)) (ℱ i))\n          μ (f (k + 1) - f k - measure_theory.condexp μ (f (k + 1) - f k) (ℱ k)) :=\n    by\n    refine' fun k hk => eventually_eq.sub _ _\n    · rw [condexp_of_strongly_measurable]\n      · exact ((hf (k + 1)).mono (ℱ.mono (nat.succ_le_of_lt hk))).sub ((hf k).mono (ℱ.mono hk.le))\n      · exact (hf_int _).sub (hf_int _)\n    · rw [condexp_of_strongly_measurable]\n      · exact strongly_measurable_condexp.mono (ℱ.mono hk.le)\n      · exact integrable_condexp\n  rw [martingale_part_eq_sum]\n  refine' eventually_eq.add eventually_eq.rfl _\n  rw [← finset.sum_range_add_sum_Ico _ hij, ←\n    add_zero\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (Finset.range i)\n        (f (i + 1) - f i - measure_theory.condexp μ (f (i + 1) - f i) (ℱ i)))]\n  refine' (eventually_eq_sum fun k hk => h_lt k (finset.mem_range.mp hk)).add _\n  refine' (eventually_eq_sum fun k hk => h_ge k (finset.mem_Ico.mp hk).1).trans _\n  simp only [finset.sum_const_zero, pi.zero_apply]\n  rfl\n#align martingale_martingale_part martingale_martingale_part\n\n",
 "integrable_martingale_part":
 "theorem integrable_martingale_part (hf_int : ∀ n, integrable (f n) μ) (n : ℕ) :\n    integrable (martingale_part f ℱ μ n) μ := by\n  rw [martingale_part_eq_sum]\n  exact (hf_int 0).add (integrable_finset_sum' _ fun i hi => ((hf_int _).sub (hf_int _)).sub integrable_condexp)\n#align integrable_martingale_part integrable_martingale_part\n\n",
 "adapted_predictable_part'":
 "theorem adapted_predictable_part' : adapted ℱ fun n => predictable_part f ℱ μ n := fun n =>\n  finset.strongly_measurable_sum' _ fun i hin => strongly_measurable_condexp.mono (ℱ.mono (Finset.mem_range_le hin))\n#align adapted_predictable_part' adapted_predictable_part'\n\n",
 "adapted_predictable_part":
 "theorem adapted_predictable_part : adapted ℱ fun n => predictable_part f ℱ μ (n + 1) := fun n =>\n  finset.strongly_measurable_sum' _ fun i hin =>\n    strongly_measurable_condexp.mono (ℱ.mono (Finset.mem_range_succ_iff.mp hin))\n#align adapted_predictable_part adapted_predictable_part\n\n",
 "adapted_martingale_part":
 "theorem adapted_martingale_part (hf : adapted ℱ f) : adapted ℱ (martingale_part f ℱ μ) :=\n  adapted.sub hf adapted_predictable_part'\n#align adapted_martingale_part adapted_martingale_part\n\n"}