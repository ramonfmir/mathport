{"submartingale_of_expected_stopped_value_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-- The converse direction of the optional stopping theorem, i.e. an adapted integrable process `f`\nis a submartingale if for all bounded stopping times `Ï„` and `Ï€` such that `Ï„ â‰¤ Ï€`, the\nstopped value of `f` at `Ï„` has expectation smaller than its stopped value at `Ï€`. -/\ntheorem submartingale_of_expected_stopped_value_mono [FiniteMeasure Î¼] (hadp : adapted ğ’¢ f)\n    (hint : âˆ€ i, integrable (f i) Î¼)\n    (hf :\n      âˆ€ Ï„ Ï€ : Î© â†’ â„•,\n        is_stopping_time ğ’¢ Ï„ â†’\n          is_stopping_time ğ’¢ Ï€ â†’\n            Ï„ â‰¤ Ï€ â†’\n              (âˆƒ N, âˆ€ Ï‰, Ï€ Ï‰ â‰¤ N) â†’\n                condexp.probability Î¼ (stopped_value f Ï„) â‰¤ condexp.probability Î¼ (stopped_value f Ï€)) :\n    submartingale f ğ’¢ Î¼ :=\n  by\n  refine' submartingale_of_set_integral_le hadp hint fun i j hij s hs => _\n  classical\n    specialize\n      hf (s.piecewise (fun _ => i) fun _ => j) _ (is_stopping_time_piecewise_const hij hs) (is_stopping_time_const ğ’¢ j)\n        (fun x => (ite_le_sup _ _ _).trans (max_eq_right hij).le) âŸ¨j, fun x => le_rflâŸ©\n    rwa [stopped_value_const, stopped_value_piecewise_const,\n      integral_piecewise (ğ’¢.le _ _ hs) (hint _).integrable_on (hint _).integrable_on, â†\n      integral_add_compl (ğ’¢.le _ _ hs) (hint j), add_le_add_iff_right] at hf\n#align submartingale_of_expected_stopped_value_mono submartingale_of_expected_stopped_value_mono\n\n",
 "submartingale_iff_expected_stopped_value_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-- **The optional stopping theorem** (fair game theorem): an adapted integrable process `f`\nis a submartingale if and only if for all bounded stopping times `Ï„` and `Ï€` such that `Ï„ â‰¤ Ï€`, the\nstopped value of `f` at `Ï„` has expectation smaller than its stopped value at `Ï€`. -/\ntheorem submartingale_iff_expected_stopped_value_mono [FiniteMeasure Î¼] (hadp : adapted ğ’¢ f)\n    (hint : âˆ€ i, integrable (f i) Î¼) :\n    submartingale f ğ’¢ Î¼ â†”\n      âˆ€ Ï„ Ï€ : Î© â†’ â„•,\n        is_stopping_time ğ’¢ Ï„ â†’\n          is_stopping_time ğ’¢ Ï€ â†’\n            Ï„ â‰¤ Ï€ â†’\n              (âˆƒ N, âˆ€ x, Ï€ x â‰¤ N) â†’\n                condexp.probability Î¼ (stopped_value f Ï„) â‰¤ condexp.probability Î¼ (stopped_value f Ï€) :=\n  âŸ¨fun hf _ _ hÏ„ hÏ€ hle âŸ¨N, hNâŸ© => hf.expected_stopped_value_mono hÏ„ hÏ€ hle hN,\n    submartingale_of_expected_stopped_value_mono hadp hintâŸ©\n#align submartingale_iff_expected_stopped_value_mono submartingale_iff_expected_stopped_value_mono\n\n",
 "stopped_process":
 "/-- The stopped process of a submartingale with respect to a stopping time is a submartingale. -/\n@[protected]\ntheorem submartingale.stopped_process [FiniteMeasure Î¼] (h : submartingale f ğ’¢ Î¼) (hÏ„ : is_stopping_time ğ’¢ Ï„) :\n    submartingale (stopped_process f Ï„) ğ’¢ Î¼ :=\n  by\n  rw [submartingale_iff_expected_stopped_value_mono]\n  Â· intro Ïƒ Ï€ hÏƒ hÏ€ hÏƒ_le_Ï€ hÏ€_bdd\n    simp_rw [stopped_value_stopped_process]\n    obtain âŸ¨n, hÏ€_le_nâŸ© := hÏ€_bdd\n    exact\n      h.expected_stopped_value_mono (hÏƒ.min hÏ„) (hÏ€.min hÏ„) (fun Ï‰ => min_le_min (hÏƒ_le_Ï€ Ï‰) le_rfl) fun Ï‰ =>\n        (min_le_left _ _).trans (hÏ€_le_n Ï‰)\n  Â· exact adapted.stopped_process_of_discrete h.adapted hÏ„\n  Â· exact fun i => h.integrable_stopped_value ((is_stopping_time_const _ i).min hÏ„) fun Ï‰ => min_le_left _ _\n#align submartingale.stopped_process submartingale.stopped_process\n\n",
 "smul_le_stopped_value_hitting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\ntheorem smul_le_stopped_value_hitting [FiniteMeasure Î¼] (hsub : submartingale f ğ’¢ Î¼) {Îµ : nnreal} (n : â„•) :\n    Â«expr â€¢ Â» Îµ (Î¼ { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ }) â‰¤\n      ENNReal.ofReal\n        (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n          { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ }\n          (stopped_value f (hitting f { y : exprâ„ | â†‘Îµ â‰¤ y } 0 n) Ï‰) Î¼) :=\n  by\n  have hn : Set.Icc 0 n = { k | k â‰¤ n } := by\n    ext x\n    simp\n  have :\n    âˆ€ Ï‰,\n      ((Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) â†’\n        (Îµ : exprâ„) â‰¤ stopped_value f (hitting f { y : exprâ„ | â†‘Îµ â‰¤ y } 0 n) Ï‰ :=\n    by\n    intro x hx\n    simp_rw [le_sup'_iff, mem_range, Nat.lt_succ_iff] at hx\n    refine' stopped_value_hitting_mem _\n    simp only [Set.mem_setOf_eq, exists_prop, hn]\n    exact\n      let âŸ¨j, hjâ‚, hjâ‚‚âŸ© := hx\n      âŸ¨j, hjâ‚, hjâ‚‚âŸ©\n  have h :=\n    set_integral_ge_of_const_le\n      (measurable_set_le measurable_const\n        (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (ğ’¢.le n)))\n      (measure_ne_top _ _) this\n      (integrable.integrable_on\n        (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le))\n  rw [ENNReal.le_ofReal_iff_toReal_le, ENNReal.toReal_smul]\n  Â· exact h\n  Â· exact ENNReal.mul_ne_top (by simp) (measure_ne_top _ _)\n  Â· exact le_trans (mul_nonneg Îµ.coe_nonneg ENNReal.toReal_nonneg) h\n#align smul_le_stopped_value_hitting smul_le_stopped_value_hitting\n\n",
 "maximal_ineq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„ -/\n/-- **Doob's maximal inequality**: Given a non-negative submartingale `f`, for all `Îµ : â„â‰¥0`,\nwe have `Îµ â€¢ Î¼ {Îµ â‰¤ f* n} â‰¤ âˆ« Ï‰ in {Îµ â‰¤ f* n}, f n` where `f* n Ï‰ = max_{k â‰¤ n}, f k Ï‰`.\n\nIn some literature, the Doob's maximal inequality refers to what we call Doob's Lp inequality\n(which is a corollary of this lemma and will be proved in an upcomming PR). -/\ntheorem maximal_ineq [FiniteMeasure Î¼] (hsub : submartingale f ğ’¢ Î¼) (hnonneg : 0 â‰¤ f) {Îµ : nnreal} (n : â„•) :\n    Â«expr â€¢ Â» Îµ (Î¼ { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ }) â‰¤\n      ENNReal.ofReal\n        (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n          { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ } (f n Ï‰) Î¼) :=\n  by\n  suffices\n    Â«expr â€¢ Â» Îµ (Î¼ { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ }) +\n        ENNReal.ofReal\n          (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n            { Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < Îµ } (f n Ï‰) Î¼) â‰¤\n      ENNReal.ofReal (condexp.probability Î¼ (f n))\n    by\n    have hadd :\n      ENNReal.ofReal\n          (Â«exprâˆ« , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â»\" (f n Ï‰)\n            Î¼) =\n        ENNReal.ofReal\n            (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n              { Ï‰ | â†‘Îµ â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ } (f n Ï‰) Î¼) +\n          ENNReal.ofReal\n            (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n              { Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < â†‘Îµ } (f n Ï‰) Î¼) :=\n      by\n      rw [â† ENNReal.ofReal_add, â† integral_union]\n      Â· conv_lhs => rw [â† integral_univ]\n        convert rfl\n        ext Ï‰\n        change (Îµ : exprâ„) â‰¤ _ âˆ¨ _ < (Îµ : exprâ„) â†” _\n        simp only [le_or_lt, true_iff_iff]\n      Â· rw [disjoint_iff_inf_le]\n        rintro Ï‰ âŸ¨hÏ‰â‚ : _ â‰¤ _, hÏ‰â‚‚ : _ < _âŸ©\n        exact (not_le.2 hÏ‰â‚‚) hÏ‰â‚\n      Â·\n        exact\n          measurable_set_lt\n            (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (ğ’¢.le n))\n            measurable_const\n      exacts[(hsub.integrable _).integrable_on, (hsub.integrable _).integrable_on, integral_nonneg (hnonneg _),\n        integral_nonneg (hnonneg _)]\n    rwa [hadd, ENNReal.add_le_add_iff_right ENNReal.ofReal_ne_top] at this\n  calc\n    Â«expr â€¢ Â» Îµ (Î¼ { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ }) +\n          ENNReal.ofReal\n            (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n              { Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < Îµ } (f n Ï‰) Î¼) â‰¤\n        ENNReal.ofReal\n            (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n              { Ï‰ | (Îµ : exprâ„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰ }\n              (stopped_value f (hitting f { y : exprâ„ | â†‘Îµ â‰¤ y } 0 n) Ï‰) Î¼) +\n          ENNReal.ofReal\n            (Â«exprâˆ« in , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« in , âˆ‚ Â»\"\n              { Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < Îµ }\n              (stopped_value f (hitting f { y : exprâ„ | â†‘Îµ â‰¤ y } 0 n) Ï‰) Î¼) :=\n      by\n      refine'\n        add_le_add (smul_le_stopped_value_hitting hsub _)\n          (ENNReal.ofReal_le_ofReal\n            (set_integral_mono_on (hsub.integrable n).integrable_on\n              (integrable.integrable_on\n                (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le))\n              (measurable_set_lt\n                (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (ğ’¢.le n))\n                measurable_const)\n              _))\n      intro Ï‰ hÏ‰\n      rw [Set.mem_setOf_eq] at hÏ‰\n      have : hitting f { y : exprâ„ | â†‘Îµ â‰¤ y } 0 n Ï‰ = n :=\n        by\n        simp only [hitting, Set.mem_setOf_eq, exists_prop, Pi.coe_nat, Nat.cast_id, ite_eq_right_iff,\n          forall_exists_index, and_imp]\n        intro m hm hÎµm\n        exact false.elim ((not_le.2 hÏ‰) ((le_sup'_iff _).2 âŸ¨m, mem_range.2 (nat.lt_succ_of_le hm.2), hÎµmâŸ©))\n      simp_rw [stopped_value, this]\n    _ =\n        ENNReal.ofReal\n          (Â«exprâˆ« , âˆ‚ Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«exprâˆ« , âˆ‚ Â»\"\n            (stopped_value f (hitting f { y : exprâ„ | â†‘Îµ â‰¤ y } 0 n) Ï‰) Î¼) :=\n      by\n      rw [â† ENNReal.ofReal_add, â† integral_union]\n      Â· conv_rhs => rw [â† integral_univ]\n        convert rfl\n        ext Ï‰\n        change _ â†” (Îµ : exprâ„) â‰¤ _ âˆ¨ _ < (Îµ : exprâ„)\n        simp only [le_or_lt, iff_true_iff]\n      Â· rw [disjoint_iff_inf_le]\n        rintro Ï‰ âŸ¨hÏ‰â‚ : _ â‰¤ _, hÏ‰â‚‚ : _ < _âŸ©\n        exact (not_le.2 hÏ‰â‚‚) hÏ‰â‚\n      Â·\n        exact\n          measurable_set_lt\n            (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (ğ’¢.le n))\n            measurable_const\n      Â·\n        exact\n          integrable.integrable_on\n            (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le)\n      Â·\n        exact\n          integrable.integrable_on\n            (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le)\n      exacts[integral_nonneg fun x => hnonneg _ _, integral_nonneg fun x => hnonneg _ _]\n    _ â‰¤ ENNReal.ofReal (condexp.probability Î¼ (f n)) :=\n      by\n      refine' ENNReal.ofReal_le_ofReal _\n      rw [â† stopped_value_const f n]\n      exact\n        hsub.expected_stopped_value_mono (hitting_is_stopping_time hsub.adapted measurable_set_Ici)\n          (is_stopping_time_const _ _) (fun Ï‰ => hitting_le Ï‰) (fun Ï‰ => le_rfl : âˆ€ Ï‰, n â‰¤ n)\n    \n#align maximal_ineq maximal_ineq\n\n",
 "expected_stopped_value_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n-- We may generalize the below lemma to functions taking value in a `normed_lattice_add_comm_group`.\n-- Similarly, generalize `(super/)submartingale.set_integral_le`.\n/-- Given a submartingale `f` and bounded stopping times `Ï„` and `Ï€` such that `Ï„ â‰¤ Ï€`, the\nexpectation of `stopped_value f Ï„` is less than or equal to the expectation of `stopped_value f Ï€`.\nThis is the forward direction of the optional stopping theorem. -/\ntheorem submartingale.expected_stopped_value_mono [sigma_finite_filtration Î¼ ğ’¢] (hf : submartingale f ğ’¢ Î¼)\n    (hÏ„ : is_stopping_time ğ’¢ Ï„) (hÏ€ : is_stopping_time ğ’¢ Ï€) (hle : Ï„ â‰¤ Ï€) {N : â„•} (hbdd : âˆ€ Ï‰, Ï€ Ï‰ â‰¤ N) :\n    condexp.probability Î¼ (stopped_value f Ï„) â‰¤ condexp.probability Î¼ (stopped_value f Ï€) :=\n  by\n  rw [â† sub_nonneg, â† integral_sub', stopped_value_sub_eq_sum' hle hbdd]\n  Â· simp only [Finset.sum_apply]\n    have : âˆ€ i, (measurable_set_of (ğ’¢ i)) { Ï‰ : Î© | Ï„ Ï‰ â‰¤ i âˆ§ i < Ï€ Ï‰ } :=\n      by\n      intro i\n      refine' (hÏ„ i).inter _\n      convert(hÏ€ i).compl\n      ext x\n      simpa\n    rw [integral_finset_sum]\n    Â· refine' Finset.sum_nonneg fun i hi => _\n      rw [integral_indicator (ğ’¢.le _ _ (this _)), integral_sub', sub_nonneg]\n      Â· exact hf.set_integral_le (nat.le_succ i) (this _)\n      Â· exact (hf.integrable _).integrable_on\n      Â· exact (hf.integrable _).integrable_on\n    intro i hi\n    exact integrable.indicator (integrable.sub (hf.integrable _) (hf.integrable _)) (ğ’¢.le _ _ (this _))\n  Â· exact hf.integrable_stopped_value hÏ€ hbdd\n  Â· exact hf.integrable_stopped_value hÏ„ fun Ï‰ => le_trans (hle Ï‰) (hbdd Ï‰)\n#align submartingale.expected_stopped_value_mono submartingale.expected_stopped_value_mono\n\n"}