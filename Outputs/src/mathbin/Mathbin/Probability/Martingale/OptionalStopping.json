{"submartingale_of_expected_stopped_value_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-- The converse direction of the optional stopping theorem, i.e. an adapted integrable process `f`\nis a submartingale if for all bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nstopped value of `f` at `τ` has expectation smaller than its stopped value at `π`. -/\ntheorem submartingale_of_expected_stopped_value_mono [FiniteMeasure μ] (hadp : adapted 𝒢 f)\n    (hint : ∀ i, integrable (f i) μ)\n    (hf :\n      ∀ τ π : Ω → ℕ,\n        is_stopping_time 𝒢 τ →\n          is_stopping_time 𝒢 π →\n            τ ≤ π →\n              (∃ N, ∀ ω, π ω ≤ N) →\n                condexp.probability μ (stopped_value f τ) ≤ condexp.probability μ (stopped_value f π)) :\n    submartingale f 𝒢 μ :=\n  by\n  refine' submartingale_of_set_integral_le hadp hint fun i j hij s hs => _\n  classical\n    specialize\n      hf (s.piecewise (fun _ => i) fun _ => j) _ (is_stopping_time_piecewise_const hij hs) (is_stopping_time_const 𝒢 j)\n        (fun x => (ite_le_sup _ _ _).trans (max_eq_right hij).le) ⟨j, fun x => le_rfl⟩\n    rwa [stopped_value_const, stopped_value_piecewise_const,\n      integral_piecewise (𝒢.le _ _ hs) (hint _).integrable_on (hint _).integrable_on, ←\n      integral_add_compl (𝒢.le _ _ hs) (hint j), add_le_add_iff_right] at hf\n#align submartingale_of_expected_stopped_value_mono submartingale_of_expected_stopped_value_mono\n\n",
 "submartingale_iff_expected_stopped_value_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-- **The optional stopping theorem** (fair game theorem): an adapted integrable process `f`\nis a submartingale if and only if for all bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nstopped value of `f` at `τ` has expectation smaller than its stopped value at `π`. -/\ntheorem submartingale_iff_expected_stopped_value_mono [FiniteMeasure μ] (hadp : adapted 𝒢 f)\n    (hint : ∀ i, integrable (f i) μ) :\n    submartingale f 𝒢 μ ↔\n      ∀ τ π : Ω → ℕ,\n        is_stopping_time 𝒢 τ →\n          is_stopping_time 𝒢 π →\n            τ ≤ π →\n              (∃ N, ∀ x, π x ≤ N) →\n                condexp.probability μ (stopped_value f τ) ≤ condexp.probability μ (stopped_value f π) :=\n  ⟨fun hf _ _ hτ hπ hle ⟨N, hN⟩ => hf.expected_stopped_value_mono hτ hπ hle hN,\n    submartingale_of_expected_stopped_value_mono hadp hint⟩\n#align submartingale_iff_expected_stopped_value_mono submartingale_iff_expected_stopped_value_mono\n\n",
 "stopped_process":
 "/-- The stopped process of a submartingale with respect to a stopping time is a submartingale. -/\n@[protected]\ntheorem submartingale.stopped_process [FiniteMeasure μ] (h : submartingale f 𝒢 μ) (hτ : is_stopping_time 𝒢 τ) :\n    submartingale (stopped_process f τ) 𝒢 μ :=\n  by\n  rw [submartingale_iff_expected_stopped_value_mono]\n  · intro σ π hσ hπ hσ_le_π hπ_bdd\n    simp_rw [stopped_value_stopped_process]\n    obtain ⟨n, hπ_le_n⟩ := hπ_bdd\n    exact\n      h.expected_stopped_value_mono (hσ.min hτ) (hπ.min hτ) (fun ω => min_le_min (hσ_le_π ω) le_rfl) fun ω =>\n        (min_le_left _ _).trans (hπ_le_n ω)\n  · exact adapted.stopped_process_of_discrete h.adapted hτ\n  · exact fun i => h.integrable_stopped_value ((is_stopping_time_const _ i).min hτ) fun ω => min_le_left _ _\n#align submartingale.stopped_process submartingale.stopped_process\n\n",
 "smul_le_stopped_value_hitting":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\ntheorem smul_le_stopped_value_hitting [FiniteMeasure μ] (hsub : submartingale f 𝒢 μ) {ε : nnreal} (n : ℕ) :\n    «expr • » ε (μ { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω }) ≤\n      ENNReal.ofReal\n        («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n          { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω }\n          (stopped_value f (hitting f { y : exprℝ | ↑ε ≤ y } 0 n) ω) μ) :=\n  by\n  have hn : Set.Icc 0 n = { k | k ≤ n } := by\n    ext x\n    simp\n  have :\n    ∀ ω,\n      ((ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω) →\n        (ε : exprℝ) ≤ stopped_value f (hitting f { y : exprℝ | ↑ε ≤ y } 0 n) ω :=\n    by\n    intro x hx\n    simp_rw [le_sup'_iff, mem_range, Nat.lt_succ_iff] at hx\n    refine' stopped_value_hitting_mem _\n    simp only [Set.mem_setOf_eq, exists_prop, hn]\n    exact\n      let ⟨j, hj₁, hj₂⟩ := hx\n      ⟨j, hj₁, hj₂⟩\n  have h :=\n    set_integral_ge_of_const_le\n      (measurable_set_le measurable_const\n        (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (𝒢.le n)))\n      (measure_ne_top _ _) this\n      (integrable.integrable_on\n        (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le))\n  rw [ENNReal.le_ofReal_iff_toReal_le, ENNReal.toReal_smul]\n  · exact h\n  · exact ENNReal.mul_ne_top (by simp) (measure_ne_top _ _)\n  · exact le_trans (mul_nonneg ε.coe_nonneg ENNReal.toReal_nonneg) h\n#align smul_le_stopped_value_hitting smul_le_stopped_value_hitting\n\n",
 "maximal_ineq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nnreal -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- **Doob's maximal inequality**: Given a non-negative submartingale `f`, for all `ε : ℝ≥0`,\nwe have `ε • μ {ε ≤ f* n} ≤ ∫ ω in {ε ≤ f* n}, f n` where `f* n ω = max_{k ≤ n}, f k ω`.\n\nIn some literature, the Doob's maximal inequality refers to what we call Doob's Lp inequality\n(which is a corollary of this lemma and will be proved in an upcomming PR). -/\ntheorem maximal_ineq [FiniteMeasure μ] (hsub : submartingale f 𝒢 μ) (hnonneg : 0 ≤ f) {ε : nnreal} (n : ℕ) :\n    «expr • » ε (μ { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω }) ≤\n      ENNReal.ofReal\n        («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n          { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω } (f n ω) μ) :=\n  by\n  suffices\n    «expr • » ε (μ { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω }) +\n        ENNReal.ofReal\n          («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n            { ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ε } (f n ω) μ) ≤\n      ENNReal.ofReal (condexp.probability μ (f n))\n    by\n    have hadd :\n      ENNReal.ofReal\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\" (f n ω)\n            μ) =\n        ENNReal.ofReal\n            («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n              { ω | ↑ε ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω } (f n ω) μ) +\n          ENNReal.ofReal\n            («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n              { ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ↑ε } (f n ω) μ) :=\n      by\n      rw [← ENNReal.ofReal_add, ← integral_union]\n      · conv_lhs => rw [← integral_univ]\n        convert rfl\n        ext ω\n        change (ε : exprℝ) ≤ _ ∨ _ < (ε : exprℝ) ↔ _\n        simp only [le_or_lt, true_iff_iff]\n      · rw [disjoint_iff_inf_le]\n        rintro ω ⟨hω₁ : _ ≤ _, hω₂ : _ < _⟩\n        exact (not_le.2 hω₂) hω₁\n      ·\n        exact\n          measurable_set_lt\n            (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (𝒢.le n))\n            measurable_const\n      exacts[(hsub.integrable _).integrable_on, (hsub.integrable _).integrable_on, integral_nonneg (hnonneg _),\n        integral_nonneg (hnonneg _)]\n    rwa [hadd, ENNReal.add_le_add_iff_right ENNReal.ofReal_ne_top] at this\n  calc\n    «expr • » ε (μ { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω }) +\n          ENNReal.ofReal\n            («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n              { ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ε } (f n ω) μ) ≤\n        ENNReal.ofReal\n            («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n              { ω | (ε : exprℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω }\n              (stopped_value f (hitting f { y : exprℝ | ↑ε ≤ y } 0 n) ω) μ) +\n          ENNReal.ofReal\n            («expr∫ in , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ in , ∂ »\"\n              { ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ε }\n              (stopped_value f (hitting f { y : exprℝ | ↑ε ≤ y } 0 n) ω) μ) :=\n      by\n      refine'\n        add_le_add (smul_le_stopped_value_hitting hsub _)\n          (ENNReal.ofReal_le_ofReal\n            (set_integral_mono_on (hsub.integrable n).integrable_on\n              (integrable.integrable_on\n                (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le))\n              (measurable_set_lt\n                (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (𝒢.le n))\n                measurable_const)\n              _))\n      intro ω hω\n      rw [Set.mem_setOf_eq] at hω\n      have : hitting f { y : exprℝ | ↑ε ≤ y } 0 n ω = n :=\n        by\n        simp only [hitting, Set.mem_setOf_eq, exists_prop, Pi.coe_nat, Nat.cast_id, ite_eq_right_iff,\n          forall_exists_index, and_imp]\n        intro m hm hεm\n        exact false.elim ((not_le.2 hω) ((le_sup'_iff _).2 ⟨m, mem_range.2 (nat.lt_succ_of_le hm.2), hεm⟩))\n      simp_rw [stopped_value, this]\n    _ =\n        ENNReal.ofReal\n          («expr∫ , ∂ » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr∫ , ∂ »\"\n            (stopped_value f (hitting f { y : exprℝ | ↑ε ≤ y } 0 n) ω) μ) :=\n      by\n      rw [← ENNReal.ofReal_add, ← integral_union]\n      · conv_rhs => rw [← integral_univ]\n        convert rfl\n        ext ω\n        change _ ↔ (ε : exprℝ) ≤ _ ∨ _ < (ε : exprℝ)\n        simp only [le_or_lt, iff_true_iff]\n      · rw [disjoint_iff_inf_le]\n        rintro ω ⟨hω₁ : _ ≤ _, hω₂ : _ < _⟩\n        exact (not_le.2 hω₂) hω₁\n      ·\n        exact\n          measurable_set_lt\n            (Finset.measurable_range_sup'' fun n _ => (hsub.strongly_measurable n).measurable.le (𝒢.le n))\n            measurable_const\n      ·\n        exact\n          integrable.integrable_on\n            (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le)\n      ·\n        exact\n          integrable.integrable_on\n            (hsub.integrable_stopped_value (hitting_is_stopping_time hsub.adapted measurable_set_Ici) hitting_le)\n      exacts[integral_nonneg fun x => hnonneg _ _, integral_nonneg fun x => hnonneg _ _]\n    _ ≤ ENNReal.ofReal (condexp.probability μ (f n)) :=\n      by\n      refine' ENNReal.ofReal_le_ofReal _\n      rw [← stopped_value_const f n]\n      exact\n        hsub.expected_stopped_value_mono (hitting_is_stopping_time hsub.adapted measurable_set_Ici)\n          (is_stopping_time_const _ _) (fun ω => hitting_le ω) (fun ω => le_rfl : ∀ ω, n ≤ n)\n    \n#align maximal_ineq maximal_ineq\n\n",
 "expected_stopped_value_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `measurable_set_of -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `condexp.probability -/\n/-\nCopyright (c) 2022 Kexing Ying. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kexing Ying\n-/\n-- We may generalize the below lemma to functions taking value in a `normed_lattice_add_comm_group`.\n-- Similarly, generalize `(super/)submartingale.set_integral_le`.\n/-- Given a submartingale `f` and bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nexpectation of `stopped_value f τ` is less than or equal to the expectation of `stopped_value f π`.\nThis is the forward direction of the optional stopping theorem. -/\ntheorem submartingale.expected_stopped_value_mono [sigma_finite_filtration μ 𝒢] (hf : submartingale f 𝒢 μ)\n    (hτ : is_stopping_time 𝒢 τ) (hπ : is_stopping_time 𝒢 π) (hle : τ ≤ π) {N : ℕ} (hbdd : ∀ ω, π ω ≤ N) :\n    condexp.probability μ (stopped_value f τ) ≤ condexp.probability μ (stopped_value f π) :=\n  by\n  rw [← sub_nonneg, ← integral_sub', stopped_value_sub_eq_sum' hle hbdd]\n  · simp only [Finset.sum_apply]\n    have : ∀ i, (measurable_set_of (𝒢 i)) { ω : Ω | τ ω ≤ i ∧ i < π ω } :=\n      by\n      intro i\n      refine' (hτ i).inter _\n      convert(hπ i).compl\n      ext x\n      simpa\n    rw [integral_finset_sum]\n    · refine' Finset.sum_nonneg fun i hi => _\n      rw [integral_indicator (𝒢.le _ _ (this _)), integral_sub', sub_nonneg]\n      · exact hf.set_integral_le (nat.le_succ i) (this _)\n      · exact (hf.integrable _).integrable_on\n      · exact (hf.integrable _).integrable_on\n    intro i hi\n    exact integrable.indicator (integrable.sub (hf.integrable _) (hf.integrable _)) (𝒢.le _ _ (this _))\n  · exact hf.integrable_stopped_value hπ hbdd\n  · exact hf.integrable_stopped_value hτ fun ω => le_trans (hle ω) (hbdd ω)\n#align submartingale.expected_stopped_value_mono submartingale.expected_stopped_value_mono\n\n"}