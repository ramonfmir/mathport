{"snd_f_fold_f_fold":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\nprivate theorem snd_f_fold_f_fold (m₁ m₂ m₃ : M) (x : A × S f) :\n    ((f_fold f m₁ (f_fold f m₂ x)).snd : «expr →ₗ[ ] » M R A) m₃ = f.bilin m₃ m₁ * (x.snd : «expr →ₗ[ ] » M R A) m₂ :=\n  rfl\n#align snd_f_fold_f_fold snd_f_fold_f_fold\n\n",
 "lift_ι":
 "@[simp]\ntheorem even.lift_ι (f : even_hom Q A) (m₁ m₂ : M) : even.lift Q f ((even.ι Q).bilin m₁ m₂) = f.bilin m₁ m₂ :=\n  even.lift.aux_ι _ _ _\n#align even.lift_ι even.lift_ι\n\n",
 "fst_f_fold_f_fold":
 "/- We could write this `snd` term in a point-free style as follows, but it wouldn't help as we\n  don't have any prod or subtype combinators to deal with n-linear maps of this degree.\n  ```lean\n  (linear_map.lcomp R _ (algebra.lmul R A).to_linear_map.flip).comp $\n    (linear_map.llcomp R M A A).flip.comp f.flip : M →ₗ[R] A →ₗ[R] M →ₗ[R] A)\n  ```\n  -/\n@[simp]\nprivate theorem fst_f_fold_f_fold (m₁ m₂ : M) (x : A × S f) :\n    (f_fold f m₁ (f_fold f m₂ x)).fst = f.bilin m₁ m₂ * x.fst :=\n  rfl\n#align fst_f_fold_f_fold fst_f_fold_f_fold\n\n",
 "f_fold_f_fold":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem f_fold_f_fold (m : M) (x : A × S f) : f_fold f m (f_fold f m x) = «expr • » (Q m) x :=\n  by\n  obtain ⟨a, ⟨g, hg⟩⟩ := x\n  ext : 2\n  · change f.bilin m m * a = «expr • » (Q m) a\n    rw [Algebra.smul_def, f.contract]\n  · ext m₁\n    change f.bilin _ _ * g m = «expr • » (Q m) (g m₁)\n    apply Submodule.span_induction' _ _ _ _ hg\n    · rintro _ ⟨b, m₃, rfl⟩\n      change f.bilin _ _ * (f.bilin _ _ * b) = «expr • » (Q m) (f.bilin _ _ * b)\n      rw [← smul_mul_assoc, ← mul_assoc, f.contract_mid]\n    · change f.bilin m₁ m * 0 = «expr • » (Q m) 0\n      rw [MulZeroClass.mul_zero, smul_zero]\n    · rintro x hx y hy ihx ihy\n      rw [LinearMap.add_apply, LinearMap.add_apply, mul_add, smul_add, ihx, ihy]\n    · rintro x hx c ihx\n      rw [LinearMap.smul_apply, LinearMap.smul_apply, mul_smul_comm, ihx, smul_comm]\n#align f_fold_f_fold f_fold_f_fold\n\n",
 "even_to_submodule":
 "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n-- put this after `Q` since we want to talk about morphisms from `clifford_algebra Q` to `A` and\n-- that order is more natural\n@[simp]\ntheorem even_to_submodule : (even Q).to_submodule = even_odd Q 0 :=\n  rfl\n#align even_to_submodule even_to_submodule\n\n",
 "aux_ι":
 "@[simp]\ntheorem aux_ι (m₁ m₂ : M) : aux f ((even.ι Q).bilin m₁ m₂) = f.bilin m₁ m₂ :=\n  (congr_arg Prod.fst (foldr_mul _ _ _ _ _ _)).trans\n    (by\n      rw [foldr_ι, foldr_ι]\n      exact mul_one _)\n#align aux_ι aux_ι\n\n",
 "aux_one":
 "@[simp]\ntheorem aux_one : aux f 1 = 1 :=\n  congr_arg Prod.fst (foldr_one _ _ _ _)\n#align aux_one aux_one\n\n",
 "aux_mul":
 "@[simp]\ntheorem aux_mul (x y : even Q) : aux f (x * y) = aux f x * aux f y :=\n  by\n  cases x\n  cases y\n  refine' (congr_arg Prod.fst (foldr_mul _ _ _ _ _ _)).trans _\n  dsimp only\n  refine' even_induction Q _ _ _ _ x_property\n  · intro r\n    rw [foldr_algebra_map, aux_algebra_map]\n    exact Algebra.smul_def r _\n  · intro x y hx hy ihx ihy\n    rw [LinearMap.map_add, Prod.fst_add, ihx, ihy, ← add_mul, ← LinearMap.map_add]\n    rfl\n  · rintro m₁ m₂ x (hx : x ∈ Even Q) ih\n    rw [aux_apply, foldr_mul, foldr_mul, foldr_ι, foldr_ι, fst_f_fold_f_fold, ih, ← mul_assoc, Subtype.coe_mk,\n      foldr_mul, foldr_mul, foldr_ι, foldr_ι, fst_f_fold_f_fold]\n    rfl\n#align aux_mul aux_mul\n\n",
 "aux_algebra_map":
 "@[simp]\ntheorem aux_algebra_map (r) (hr) : aux f ⟨algebraMap R _ r, hr⟩ = algebraMap R _ r :=\n  (congr_arg Prod.fst (foldr_algebra_map _ _ _ _ _)).trans (Algebra.algebraMap_eq_smul_one r).symm\n#align aux_algebra_map aux_algebra_map\n\n",
 "alg_hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- Two algebra morphisms from the even subalgebra are equal if they agree on pairs of generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem even.alg_hom_ext ⦃f g : «expr →ₐ[ ] » (even Q) R A⦄ (h : (even.ι Q).compr₂ f = (even.ι Q).compr₂ g) : f = g :=\n  by\n  rw [even_hom.ext_iff] at h\n  ext ⟨x, hx⟩\n  refine' even_induction _ _ _ _ _ hx\n  · intro r\n    exact (f.commutes r).trans (g.commutes r).symm\n  · intro x y hx hy ihx ihy\n    have := congr_arg₂ (· + ·) ihx ihy\n    exact (f.map_add _ _).trans (this.trans <| (g.map_add _ _).symm)\n  · intro m₁ m₂ x hx ih\n    have := congr_arg₂ (· * ·) (LinearMap.congr_fun (LinearMap.congr_fun h m₁) m₂) ih\n    exact (f.map_mul _ _).trans (this.trans <| (g.map_mul _ _).symm)\n#align even.alg_hom_ext even.alg_hom_ext\n\n"}