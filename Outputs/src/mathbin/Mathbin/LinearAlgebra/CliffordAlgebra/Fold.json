{"right_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem right_induction {P : clifford_algebra Q → Prop} (hr : ∀ r : R, P (algebra_map _ _ r))\n    (h_add : ∀ x y, P x → P y → P (x + y)) (h_ι_mul : ∀ m x, P x → P (x * ι Q m)) : ∀ x, P x :=\n  by\n  /- It would be neat if we could prove this via `foldr` like how we prove\n    `clifford_algebra.induction`, but going via the grading seems easier. -/\n  intro x\n  have : x ∈ «expr⊤» := submodule.mem_top\n  rw [← supr_ι_range_eq_top] at this\n  apply submodule.supr_induction _ this (fun i x hx => _) _ h_add\n  · refine' submodule.pow_induction_on_right _ hr h_add (fun x px m => _) hx\n    rintro ⟨m, rfl⟩\n    exact h_ι_mul _ _ px\n  · simpa only [map_zero] using hr 0\n#align right_induction right_induction\n\n",
 "left_induction":
 "theorem left_induction {P : clifford_algebra Q → Prop} (hr : ∀ r : R, P (algebra_map _ _ r))\n    (h_add : ∀ x y, P x → P y → P (x + y)) (h_mul_ι : ∀ x m, P x → P (ι Q m * x)) : ∀ x, P x :=\n  by\n  refine' reverse_involutive.surjective.forall.2 _\n  intro x\n  induction' x using clifford_algebra.right_induction with r x y hx hy m x hx\n  · simpa only [reverse.commutes] using hr r\n  · simpa only [map_add] using h_add _ _ hx hy\n  · simpa only [reverse.map_mul, reverse_ι] using h_mul_ι _ _ hx\n#align left_induction left_induction\n\n",
 "foldr_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp]\ntheorem foldr_ι (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (m : M) : foldr Q f hf n (ι Q m) = f m n :=\n  linear_map.congr_fun (lift_ι_apply _ _ _) n\n#align foldr_ι foldr_ι\n\n",
 "foldr_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldr_reverse (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (x : clifford_algebra Q) :\n    foldr Q f hf n (reverse x) = foldl Q f hf n x :=\n  rfl\n#align foldr_reverse foldr_reverse\n\n",
 "foldr_prod_map_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- This lemma demonstrates the origin of the `foldr` name. -/\ntheorem foldr_prod_map_ι (l : list M) (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) :\n    foldr Q f hf n (l.map <| ι Q).prod = list.foldr (fun m n => f m n) n l :=\n  by\n  induction' l with hd tl ih\n  · rw [List.map_nil, List.prod_nil, List.foldr_nil, foldr_one]\n  · rw [list.map_cons, List.prod_cons, List.foldr_cons, foldr_mul, foldr_ι, ih]\n#align foldr_prod_map_ι foldr_prod_map_ι\n\n",
 "foldr_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldr_one (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) : foldr Q f hf n 1 = n :=\n  linear_map.congr_fun (alg_hom.map_one _) n\n#align foldr_one foldr_one\n\n",
 "foldr_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldr_mul (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (a b : clifford_algebra Q) :\n    foldr Q f hf n (a * b) = foldr Q f hf (foldr Q f hf n b) a :=\n  linear_map.congr_fun (alg_hom.map_mul _ _ _) n\n#align foldr_mul foldr_mul\n\n",
 "foldr_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem foldr_algebra_map (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (r : R) :\n    foldr Q f hf n (algebra_map R _ r) = «expr • » r n :=\n  linear_map.congr_fun (alg_hom.commutes _ r) n\n#align foldr_algebra_map foldr_algebra_map\n\n",
 "foldr'_ι_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem foldr'_ι_mul (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » (clifford_algebra Q × N) R N))\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = «expr • » (Q m) fx) (n m) (x) :\n    foldr' Q f hf n (ι Q m * x) = f m (x, foldr' Q f hf n x) :=\n  by\n  dsimp [foldr']\n  rw [foldr_mul, foldr_ι, foldr'_aux_apply_apply]\n  refine' congr_arg (f m) (prod.mk.eta.symm.trans _)\n  congr 1\n  induction' x using clifford_algebra.left_induction with r x y hx hy m x hx\n  · simp_rw [foldr_algebra_map, Prod.smul_mk, algebra.algebra_map_eq_smul_one]\n  · rw [map_add, Prod.fst_add, hx, hy]\n  · rw [foldr_mul, foldr_ι, foldr'_aux_apply_apply, hx]\n#align foldr'_ι_mul foldr'_ι_mul\n\n",
 "foldr'_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem foldr'_ι (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » (clifford_algebra Q × N) R N))\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = «expr • » (Q m) fx) (n m) : foldr' Q f hf n (ι Q m) = f m (1, n) :=\n  congr_arg prod.snd (foldr_ι _ _ _ _ _)\n#align foldr'_ι foldr'_ι\n\n",
 "foldr'_aux_foldr'_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem foldr'_aux_foldr'_aux (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » (clifford_algebra Q × N) R N))\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = «expr • » (Q m) fx) (v : M) (x_fx) :\n    foldr'_aux Q f v (foldr'_aux Q f v x_fx) = «expr • » (Q v) x_fx :=\n  by\n  cases' x_fx with x fx\n  simp only [foldr'_aux_apply_apply]\n  rw [← mul_assoc, ι_sq_scalar, ← algebra.smul_def, hf, Prod.smul_mk]\n#align foldr'_aux_foldr'_aux foldr'_aux_foldr'_aux\n\n",
 "foldr'_aux_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem foldr'_aux_apply_apply (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » (clifford_algebra Q × N) R N)) (m : M) (x_fx) :\n    foldr'_aux Q f m x_fx = (ι Q m * x_fx.1, f m x_fx) :=\n  rfl\n#align foldr'_aux_apply_apply foldr'_aux_apply_apply\n\n",
 "foldr'_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem foldr'_algebra_map (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » (clifford_algebra Q × N) R N))\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = «expr • » (Q m) fx) (n r) :\n    foldr' Q f hf n (algebra_map R _ r) = «expr • » r n :=\n  congr_arg prod.snd (foldr_algebra_map _ _ _ _ _)\n#align foldr'_algebra_map foldr'_algebra_map\n\n",
 "foldl_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldl_ι (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (m : M) : foldl Q f hf n (ι Q m) = f m n :=\n  by rw [← foldr_reverse, reverse_ι, foldr_ι]\n#align foldl_ι foldl_ι\n\n",
 "foldl_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldl_reverse (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (x : clifford_algebra Q) :\n    foldl Q f hf n (reverse x) = foldr Q f hf n x :=\n  fun_like.congr_arg (foldr Q f hf n) <| reverse_reverse _\n#align foldl_reverse foldl_reverse\n\n",
 "foldl_prod_map_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- This lemma demonstrates the origin of the `foldl` name. -/\ntheorem foldl_prod_map_ι (l : list M) (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) :\n    foldl Q f hf n (l.map <| ι Q).prod = list.foldl (fun m n => f n m) n l := by\n  rw [← foldr_reverse, reverse_prod_map_ι, ← List.map_reverse, foldr_prod_map_ι, List.foldr_reverse]\n#align foldl_prod_map_ι foldl_prod_map_ι\n\n",
 "foldl_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldl_one (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) : foldl Q f hf n 1 = n := by\n  rw [← foldr_reverse, reverse.map_one, foldr_one]\n#align foldl_one foldl_one\n\n",
 "foldl_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem foldl_mul (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (a b : clifford_algebra Q) :\n    foldl Q f hf n (a * b) = foldl Q f hf (foldl Q f hf n a) b := by\n  rw [← foldr_reverse, ← foldr_reverse, ← foldr_reverse, reverse.map_mul, foldr_mul]\n#align foldl_mul foldl_mul\n\n",
 "foldl_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem foldl_algebra_map (f : «expr →ₗ[ ] » M R («expr →ₗ[ ] » N R N)) (hf) (n : N) (r : R) :\n    foldl Q f hf n (algebra_map R _ r) = «expr • » r n := by rw [← foldr_reverse, reverse.commutes, foldr_algebra_map]\n#align foldl_algebra_map foldl_algebra_map\n\n"}