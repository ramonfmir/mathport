{"ι_sq_scalar":
 "theorem graded_algebra.ι_sq_scalar (m : M) : graded_algebra.ι Q m * graded_algebra.ι Q m = algebraMap R _ (Q m) :=\n  by\n  rw [graded_algebra.ι_apply Q, direct_sum.of_mul_of, direct_sum.algebra_map_apply]\n  refine' direct_sum.of_eq_of_graded_monoid_eq (Sigma.subtype_ext rfl <| ι_sq_scalar _ _)\n#align graded_algebra.ι_sq_scalar graded_algebra.ι_sq_scalar\n\n",
 "ι_mul_ι_mem_even_odd_zero":
 "theorem ι_mul_ι_mem_even_odd_zero (m₁ m₂ : M) : ι Q m₁ * ι Q m₂ ∈ even_odd Q 0 :=\n  Submodule.mem_supᵢ_of_mem ⟨2, rfl⟩\n    (by\n      rw [Subtype.coe_mk, pow_two]\n      exact Submodule.mul_mem_mul (LinearMap.mem_range_self (ι Q) m₁) (LinearMap.mem_range_self (ι Q) m₂))\n#align ι_mul_ι_mem_even_odd_zero ι_mul_ι_mem_even_odd_zero\n\n",
 "ι_mem_even_odd_one":
 "theorem ι_mem_even_odd_one (m : M) : ι Q m ∈ even_odd Q 1 :=\n  range_ι_le_even_odd_one Q <| LinearMap.mem_range_self _ m\n#align ι_mem_even_odd_one ι_mem_even_odd_one\n\n",
 "ι_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem graded_algebra.ι_apply (m : M) :\n    graded_algebra.ι Q m = DirectSum.of (fun i => «expr↥ » (even_odd Q i)) 1 ⟨ι Q m, ι_mem_even_odd_one Q m⟩ :=\n  rfl\n#align graded_algebra.ι_apply graded_algebra.ι_apply\n\n",
 "supr_ι_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- while not necessary, the `by apply` makes this elaborate faster\n-- the proof from here onward is mostly similar to the `tensor_algebra` case, with some extra\n-- handling for the `supr` in `even_odd`.\ntheorem supr_ι_range_eq_top :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((ι Q).range ^ i) =\n      «expr⊤» :=\n  by\n  rw [← (direct_sum.decomposition.is_internal (even_odd Q)).submodule_supr_eq_top, eq_comm]\n  calc\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((ι Q).range ^ ↑j) =\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          ((ι Q).range ^ (i.2 : ℕ)) :=\n      by rw [supᵢ_sigma]\n    _ =\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          ((ι Q).range ^ i) :=\n      Function.Surjective.supᵢ_congr (fun i => i.2) (fun i => ⟨⟨_, i, rfl⟩, rfl⟩) fun _ => rfl\n    \n#align supr_ι_range_eq_top supr_ι_range_eq_top\n\n",
 "range_ι_le_even_odd_one":
 "theorem range_ι_le_even_odd_one : (ι Q).range ≤ even_odd Q 1 :=\n  by\n  refine' le_trans _ (le_supᵢ _ ⟨1, Nat.cast_one⟩)\n  exact (pow_one _).ge\n#align range_ι_le_even_odd_one range_ι_le_even_odd_one\n\n",
 "one_le_even_odd_zero":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\ntheorem one_le_even_odd_zero : 1 ≤ even_odd Q 0 :=\n  by\n  refine' le_trans _ (le_supᵢ _ ⟨0, Nat.cast_zero⟩)\n  exact (pow_zero _).ge\n#align one_le_even_odd_zero one_le_even_odd_zero\n\n",
 "odd_induction":
 "/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\n@[elab_as_elim]\ntheorem odd_induction {P : ∀ x, x ∈ even_odd Q 1 → Prop} (hι : ∀ v, P (ι Q v) (ι_mem_even_odd_one _ _))\n    (hadd : ∀ {x y hx hy}, P x hx → P y hy → P (x + y) (Submodule.add_mem _ hx hy))\n    (hιι_mul :\n      ∀ (m₁ m₂) {x hx},\n        P x hx →\n          P (ι Q m₁ * ι Q m₂ * x)\n            (zero_add (1 : ZMod 2) ▸ SetLike.mul_mem_graded (ι_mul_ι_mem_even_odd_zero Q m₁ m₂) hx))\n    (x : clifford_algebra Q) (hx : x ∈ even_odd Q 1) : P x hx :=\n  by\n  refine' even_odd_induction Q 1 (fun ιv => _) (@hadd) hιι_mul x hx\n  simp_rw [ZMod.val_one, pow_one]\n  rintro ⟨v, rfl⟩\n  exact hι v\n#align odd_induction odd_induction\n\n",
 "lift_ι_eq":
 "theorem graded_algebra.lift_ι_eq (i' : ZMod 2) (x' : even_odd Q i') :\n    lift Q ⟨by apply graded_algebra.ι Q, graded_algebra.ι_sq_scalar Q⟩ x' =\n      DirectSum.of (fun i => even_odd Q i) i' x' :=\n  by\n  cases' x' with x' hx'\n  dsimp only [Subtype.coe_mk, DirectSum.lof_eq_of]\n  refine' Submodule.supᵢ_induction' _ (fun i x hx => _) _ (fun x y hx hy ihx ihy => _) hx'\n  · obtain ⟨i, rfl⟩ := i\n    dsimp only [Subtype.coe_mk] at hx\n    refine' Submodule.pow_induction_on_left' _ (fun r => _) (fun x y i hx hy ihx ihy => _) (fun m hm i x hx ih => _) hx\n    · rw [AlgHom.commutes, direct_sum.algebra_map_apply]\n      rfl\n    · rw [AlgHom.map_add, ihx, ihy, ← map_add]\n      rfl\n    · obtain ⟨_, rfl⟩ := hm\n      rw [AlgHom.map_mul, ih, lift_ι_apply, graded_algebra.ι_apply Q, direct_sum.of_mul_of]\n      refine' direct_sum.of_eq_of_graded_monoid_eq (Sigma.subtype_ext _ _) <;>\n        dsimp only [GradedMonoid.mk, Subtype.coe_mk]\n      · rw [nat.succ_eq_add_one, add_comm, Nat.cast_add, Nat.cast_one]\n      rfl\n  · rw [AlgHom.map_zero]\n    apply Eq.symm\n    apply dfinsupp.single_eq_zero.mpr\n    rfl\n  · rw [AlgHom.map_add, ihx, ihy, ← map_add]\n    rfl\n#align graded_algebra.lift_ι_eq graded_algebra.lift_ι_eq\n\n",
 "even_odd_mul_le":
 "theorem even_odd_mul_le (i j : ZMod 2) : even_odd Q i * even_odd Q j ≤ even_odd Q (i + j) :=\n  by\n  simp_rw [even_odd, Submodule.supᵢ_eq_span, Submodule.span_mul_span]\n  apply Submodule.span_mono\n  intro z hz\n  obtain ⟨x, y, hx, hy, rfl⟩ := hz\n  obtain ⟨xi, hx'⟩ := set.mem_Union.mp hx\n  obtain ⟨yi, hy'⟩ := set.mem_Union.mp hy\n  refine' set.mem_Union.mpr ⟨⟨xi + yi, by simp only [Nat.cast_add, xi.prop, yi.prop]⟩, _⟩\n  simp only [Subtype.coe_mk, Nat.cast_add, pow_add]\n  exact Submodule.mul_mem_mul hx' hy'\n#align even_odd_mul_le even_odd_mul_le\n\n",
 "even_odd_is_compl":
 "theorem even_odd_is_compl : IsCompl (even_odd Q 0) (even_odd Q 1) :=\n  (direct_sum.decomposition.is_internal (even_odd Q)).is_compl zero_ne_one <|\n    by\n    have : (Finset.univ : Finset (ZMod 2)) = {0, 1} := rfl\n    simpa using congr_arg (coe : Finset (ZMod 2) → Set (ZMod 2)) this\n#align even_odd_is_compl even_odd_is_compl\n\n",
 "even_odd_induction":
 "/-- To show a property is true on the even or odd part, it suffices to show it is true on the\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\nof vectors. -/\n@[elab_as_elim]\ntheorem even_odd_induction (n : ZMod 2) {P : ∀ x, x ∈ even_odd Q n → Prop}\n    (hr : ∀ (v) (h : v ∈ (ι Q).range ^ n.val), P v (Submodule.mem_supᵢ_of_mem ⟨n.val, n.nat_cast_zmod_val⟩ h))\n    (hadd : ∀ {x y hx hy}, P x hx → P y hy → P (x + y) (Submodule.add_mem _ hx hy))\n    (hιι_mul :\n      ∀ (m₁ m₂) {x hx},\n        P x hx → P (ι Q m₁ * ι Q m₂ * x) (zero_add n ▸ SetLike.mul_mem_graded (ι_mul_ι_mem_even_odd_zero Q m₁ m₂) hx))\n    (x : clifford_algebra Q) (hx : x ∈ even_odd Q n) : P x hx :=\n  by\n  apply Submodule.supᵢ_induction' _ _ (hr 0 (Submodule.zero_mem _)) @hadd\n  refine' subtype.rec _\n  simp_rw [Subtype.coe_mk, ZMod.nat_coe_zmod_eq_iff, add_comm n.val]\n  rintro n' ⟨k, rfl⟩ xv\n  simp_rw [pow_add, pow_mul]\n  refine' Submodule.mul_induction_on' _ _\n  · intro a ha b hb\n    refine' Submodule.pow_induction_on_left' ((ι Q).range ^ 2) _ _ _ ha\n    · intro r\n      simp_rw [← Algebra.smul_def]\n      exact hr _ (Submodule.smul_mem _ _ hb)\n    · intro x y n hx hy\n      simp_rw [add_mul]\n      apply hadd\n    · intro x hx n y hy ihy\n      revert hx\n      simp_rw [pow_two]\n      refine' Submodule.mul_induction_on' _ _\n      · simp_rw [LinearMap.mem_range]\n        rintro _ ⟨m₁, rfl⟩ _ ⟨m₂, rfl⟩\n        simp_rw [mul_assoc _ y b]\n        refine' hιι_mul _ _ ihy\n      · intro x hx y hy ihx ihy\n        simp_rw [add_mul]\n        apply hadd ihx ihy\n  · intro x y hx hy\n    apply hadd\n#align even_odd_induction even_odd_induction\n\n",
 "even_induction":
 "/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\n@[elab_as_elim]\ntheorem even_induction {P : ∀ x, x ∈ even_odd Q 0 → Prop}\n    (hr : ∀ r : R, P (algebraMap _ _ r) (set_like.algebra_map_mem_graded _ _))\n    (hadd : ∀ {x y hx hy}, P x hx → P y hy → P (x + y) (Submodule.add_mem _ hx hy))\n    (hιι_mul :\n      ∀ (m₁ m₂) {x hx},\n        P x hx → P (ι Q m₁ * ι Q m₂ * x) (zero_add 0 ▸ SetLike.mul_mem_graded (ι_mul_ι_mem_even_odd_zero Q m₁ m₂) hx))\n    (x : clifford_algebra Q) (hx : x ∈ even_odd Q 0) : P x hx :=\n  by\n  refine' even_odd_induction Q 0 (fun rx => _) (@hadd) hιι_mul x hx\n  simp_rw [ZMod.val_zero, pow_zero]\n  rintro ⟨r, rfl⟩\n  exact hr r\n#align even_induction even_induction\n\n"}