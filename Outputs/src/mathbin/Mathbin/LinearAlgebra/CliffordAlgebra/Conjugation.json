{"ι_range_map_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ι_range_map_reverse :\n    (ι Q).range.map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) = (ι Q).range :=\n  by\n  rw [reverse, Submodule.map_comp, ι_range_map_lift, LinearMap.range_comp, ← Submodule.map_comp]\n  exact Submodule.map_id _\n#align ι_range_map_reverse ι_range_map_reverse\n\n",
 "ι_range_map_involute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem ι_range_map_involute :\n    (ι Q).range.map (involute : «expr →ₐ[ ] » (clifford_algebra Q) R (clifford_algebra Q)).to_linear_map =\n      (ι Q).range :=\n  (ι_range_map_lift _ _).trans (LinearMap.range_neg _)\n#align ι_range_map_involute ι_range_map_involute\n\n",
 "ι_range_comap_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ι_range_comap_reverse :\n    (ι Q).range.comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) = (ι Q).range := by\n  rw [← submodule_map_reverse_eq_comap, ι_range_map_reverse]\n#align ι_range_comap_reverse ι_range_comap_reverse\n\n",
 "ι_range_comap_involute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem ι_range_comap_involute :\n    (ι Q).range.comap (involute : «expr →ₐ[ ] » (clifford_algebra Q) R (clifford_algebra Q)).to_linear_map =\n      (ι Q).range :=\n  by rw [← submodule_map_involute_eq_comap, ι_range_map_involute]\n#align ι_range_comap_involute ι_range_comap_involute\n\n",
 "submodule_map_reverse_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem submodule_map_reverse_eq_comap (p : Submodule R (clifford_algebra Q)) :\n    p.map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) =\n      p.comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) :=\n  Submodule.map_equiv_eq_comap_symm (reverse_equiv : «expr ≃ₗ[ ] » _ R _) _\n#align submodule_map_reverse_eq_comap submodule_map_reverse_eq_comap\n\n",
 "submodule_map_pow_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Like `submodule.map_pow` -/\ntheorem submodule_map_pow_reverse (p : Submodule R (clifford_algebra Q)) (n : ℕ) :\n    (p ^ n).map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) =\n      p.map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) ^ n :=\n  by simp_rw [reverse, Submodule.map_comp, linear_equiv.to_linear_map_eq_coe, Submodule.map_pow, Submodule.map_unop_pow]\n#align submodule_map_pow_reverse submodule_map_pow_reverse\n\n",
 "submodule_map_mul_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Like `submodule.map_mul`, but with the multiplication reversed. -/\ntheorem submodule_map_mul_reverse (p q : Submodule R (clifford_algebra Q)) :\n    (p * q).map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) =\n      q.map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) *\n        p.map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) :=\n  by simp_rw [reverse, Submodule.map_comp, linear_equiv.to_linear_map_eq_coe, Submodule.map_mul, Submodule.map_unop_mul]\n#align submodule_map_mul_reverse submodule_map_mul_reverse\n\n",
 "submodule_map_involute_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem submodule_map_involute_eq_comap (p : Submodule R (clifford_algebra Q)) :\n    p.map (involute : «expr →ₐ[ ] » (clifford_algebra Q) R (clifford_algebra Q)).to_linear_map =\n      p.comap (involute : «expr →ₐ[ ] » (clifford_algebra Q) R (clifford_algebra Q)).to_linear_map :=\n  Submodule.map_equiv_eq_comap_symm involute_equiv.to_linear_equiv _\n#align submodule_map_involute_eq_comap submodule_map_involute_eq_comap\n\n",
 "submodule_comap_pow_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem submodule_comap_pow_reverse (p : Submodule R (clifford_algebra Q)) (n : ℕ) :\n    (p ^ n).comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) =\n      p.comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) ^ n :=\n  by simp_rw [← submodule_map_reverse_eq_comap, submodule_map_pow_reverse]\n#align submodule_comap_pow_reverse submodule_comap_pow_reverse\n\n",
 "submodule_comap_mul_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem submodule_comap_mul_reverse (p q : Submodule R (clifford_algebra Q)) :\n    (p * q).comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) =\n      q.comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) *\n        p.comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) :=\n  by simp_rw [← submodule_map_reverse_eq_comap, submodule_map_mul_reverse]\n#align submodule_comap_mul_reverse submodule_comap_mul_reverse\n\n",
 "reverse_ι":
 "@[simp]\ntheorem reverse_ι (m : M) : reverse (ι Q m) = ι Q m := by simp [reverse]\n#align reverse_ι reverse_ι\n\n",
 "reverse_reverse":
 "@[simp]\ntheorem reverse_reverse : ∀ a : clifford_algebra Q, reverse (reverse a) = a :=\n  reverse_involutive\n#align reverse_reverse reverse_reverse\n\n",
 "reverse_prod_map_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/-- Taking the reverse of the product a list of $n$ vectors lifted via `ι` is equivalent to\ntaking the product of the reverse of that list. -/\ntheorem reverse_prod_map_ι : ∀ l : List M, reverse (l.map <| ι Q).prod = (l.map <| ι Q).reverse.prod\n  | [] => by simp\n  | sym.cons' x xs => by simp [reverse_prod_map_ι xs]\n#align reverse_prod_map_ι reverse_prod_map_ι\n\n",
 "reverse_mem_even_odd_iff":
 "@[simp]\ntheorem reverse_mem_even_odd_iff {x : clifford_algebra Q} {n : ZMod 2} : reverse x ∈ even_odd Q n ↔ x ∈ even_odd Q n :=\n  SetLike.ext_iff.mp (even_odd_comap_reverse Q n) x\n#align reverse_mem_even_odd_iff reverse_mem_even_odd_iff\n\n",
 "reverse_involutive":
 "@[simp]\ntheorem reverse_involutive : Function.Involutive (reverse : _ → clifford_algebra Q) :=\n  LinearMap.congr_fun reverse_comp_reverse\n#align reverse_involutive reverse_involutive\n\n",
 "reverse_involute_commute":
 "/-- `clifford_algebra.reverse` and `clifford_algebra.inverse` commute. Note that the composition\nis sometimes referred to as the \"clifford conjugate\". -/\ntheorem reverse_involute_commute : Function.Commute (reverse : _ → clifford_algebra Q) involute :=\n  LinearMap.congr_fun reverse_comp_involute\n#align reverse_involute_commute reverse_involute_commute\n\n",
 "reverse_involute":
 "theorem reverse_involute : ∀ a : clifford_algebra Q, reverse (involute a) = involute (reverse a) :=\n  reverse_involute_commute\n#align reverse_involute reverse_involute\n\n",
 "reverse_comp_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem reverse_comp_reverse : reverse.comp reverse = (LinearMap.id : «expr →ₗ[ ] » _ R (clifford_algebra Q)) :=\n  by\n  ext m\n  simp only [LinearMap.id_apply, LinearMap.comp_apply]\n  induction m using clifford_algebra.induction\n  -- simp can close these goals, but is slow\n  case h_grade0 => rw [reverse.commutes, reverse.commutes]\n  case h_grade1 => rw [reverse_ι, reverse_ι]\n  case h_mul a b ha hb => rw [reverse.map_mul, reverse.map_mul, ha, hb]\n  case h_add a b ha hb => rw [reverse.map_add, reverse.map_add, ha, hb]\n#align reverse_comp_reverse reverse_comp_reverse\n\n",
 "reverse_comp_involute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem reverse_comp_involute :\n    reverse.comp involute.to_linear_map =\n      (involute.to_linear_map.comp reverse : «expr →ₗ[ ] » _ R (clifford_algebra Q)) :=\n  by\n  ext\n  simp only [LinearMap.comp_apply, AlgHom.toLinearMap_apply]\n  induction x using clifford_algebra.induction\n  case h_grade0 => simp\n  case h_grade1 => simp\n  case h_mul a b ha hb => simp only [ha, hb, reverse.map_mul, AlgHom.map_mul]\n  case h_add a b ha hb => simp only [ha, hb, reverse.map_add, AlgHom.map_add]\n#align reverse_comp_involute reverse_comp_involute\n\n",
 "map_one":
 "@[simp]\ntheorem reverse.map_one : reverse (1 : clifford_algebra Q) = 1 := by convert reverse.commutes (1 : R) <;> simp\n#align reverse.map_one reverse.map_one\n\n",
 "map_mul":
 "@[simp]\ntheorem reverse.map_mul (a b : clifford_algebra Q) : reverse (a * b) = reverse b * reverse a := by simp [reverse]\n#align reverse.map_mul reverse.map_mul\n\n",
 "involute_ι":
 "/-\nCopyright (c) 2020 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n@[simp]\ntheorem involute_ι (m : M) : involute (ι Q m) = -ι Q m :=\n  lift_ι_apply _ _ m\n#align involute_ι involute_ι\n\n",
 "involute_prod_map_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Taking the involute of the product a list of $n$ vectors lifted via `ι` is equivalent to\npremultiplying by ${-1}^n$. -/\ntheorem involute_prod_map_ι :\n    ∀ l : List M, involute (l.map <| ι Q).prod = «expr • » ((-1 : R) ^ l.length) (l.map <| ι Q).prod\n  | [] => by simp\n  | sym.cons' x xs => by simp [pow_add, involute_prod_map_ι xs]\n#align involute_prod_map_ι involute_prod_map_ι\n\n",
 "involute_mem_even_odd_iff":
 "@[simp]\ntheorem involute_mem_even_odd_iff {x : clifford_algebra Q} {n : ZMod 2} :\n    involute x ∈ even_odd Q n ↔ x ∈ even_odd Q n :=\n  SetLike.ext_iff.mp (even_odd_comap_involute Q n) x\n#align involute_mem_even_odd_iff involute_mem_even_odd_iff\n\n",
 "involute_involutive":
 "theorem involute_involutive : Function.Involutive (involute : _ → clifford_algebra Q) :=\n  AlgHom.congr_fun involute_comp_involute\n#align involute_involutive involute_involutive\n\n",
 "involute_involute":
 "@[simp]\ntheorem involute_involute : ∀ a : clifford_algebra Q, involute (involute a) = a :=\n  involute_involutive\n#align involute_involute involute_involute\n\n",
 "involute_eq_of_mem_odd":
 "theorem involute_eq_of_mem_odd {x : clifford_algebra Q} (h : x ∈ even_odd Q 1) : involute x = -x :=\n  by\n  refine' odd_induction Q involute_ι _ _ x h\n  · rintro x y hx hy ihx ihy\n    rw [map_add, ihx, ihy, neg_add]\n  · intro m₁ m₂ x hx ihx\n    rw [map_mul, map_mul, involute_ι, involute_ι, ihx, neg_mul_neg, mul_neg]\n#align involute_eq_of_mem_odd involute_eq_of_mem_odd\n\n",
 "involute_eq_of_mem_even":
 "theorem involute_eq_of_mem_even {x : clifford_algebra Q} (h : x ∈ even_odd Q 0) : involute x = x :=\n  by\n  refine' even_induction Q (AlgHom.commutes _) _ _ x h\n  · rintro x y hx hy ihx ihy\n    rw [map_add, ihx, ihy]\n  · intro m₁ m₂ x hx ihx\n    rw [map_mul, map_mul, involute_ι, involute_ι, ihx, neg_mul_neg]\n#align involute_eq_of_mem_even involute_eq_of_mem_even\n\n",
 "involute_comp_involute":
 "@[simp]\ntheorem involute_comp_involute : involute.comp involute = AlgHom.id R (clifford_algebra Q) :=\n  by\n  ext\n  simp\n#align involute_comp_involute involute_comp_involute\n\n",
 "even_odd_map_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem even_odd_map_reverse (n : ZMod 2) :\n    (even_odd Q n).map (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) = even_odd Q n := by\n  simp_rw [even_odd, Submodule.map_supᵢ, submodule_map_pow_reverse, ι_range_map_reverse]\n#align even_odd_map_reverse even_odd_map_reverse\n\n",
 "even_odd_map_involute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem even_odd_map_involute (n : ZMod 2) :\n    (even_odd Q n).map (involute : «expr →ₐ[ ] » (clifford_algebra Q) R (clifford_algebra Q)).to_linear_map =\n      even_odd Q n :=\n  by simp_rw [even_odd, Submodule.map_supᵢ, Submodule.map_pow, ι_range_map_involute]\n#align even_odd_map_involute even_odd_map_involute\n\n",
 "even_odd_comap_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem even_odd_comap_reverse (n : ZMod 2) :\n    (even_odd Q n).comap (reverse : «expr →ₗ[ ] » (clifford_algebra Q) R (clifford_algebra Q)) = even_odd Q n := by\n  rw [← submodule_map_reverse_eq_comap, even_odd_map_reverse]\n#align even_odd_comap_reverse even_odd_comap_reverse\n\n",
 "even_odd_comap_involute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem even_odd_comap_involute (n : ZMod 2) :\n    (even_odd Q n).comap (involute : «expr →ₐ[ ] » (clifford_algebra Q) R (clifford_algebra Q)).to_linear_map =\n      even_odd Q n :=\n  by rw [← submodule_map_involute_eq_comap, even_odd_map_involute]\n#align even_odd_comap_involute even_odd_comap_involute\n\n",
 "commutes":
 "@[simp]\ntheorem reverse.commutes (r : R) : reverse (algebraMap R (clifford_algebra Q) r) = algebraMap R _ r := by simp [reverse]\n#align reverse.commutes reverse.commutes\n\n"}