{"ι_sq_scalar":
 "/-\nCopyright (c) 2020 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser, Utensil Song\n-/\n/-- As well as being linear, `ι Q` squares to the quadratic form -/\n@[simp]\ntheorem ι_sq_scalar (m : M) : ι Q m * ι Q m = algebraMap R _ (Q m) :=\n  by\n  erw [← AlgHom.map_mul, RingQuot.mkAlgHom_rel R (rel.of m), AlgHom.commutes]\n  rfl\n#align ι_sq_scalar ι_sq_scalar\n\n",
 "ι_range_map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ι_range_map_map (f : «expr →ₗ[ ] » M₁ R M₂) (hf : ∀ m, Q₂ (f m) = Q₁ m) :\n    (ι Q₁).range.map (map Q₁ Q₂ f hf).to_linear_map = f.range.map (ι Q₂) :=\n  (ι_range_map_lift _ _).trans (LinearMap.range_comp _ _)\n#align ι_range_map_map ι_range_map_map\n\n",
 "ι_range_map_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ι_range_map_lift (f : «expr →ₗ[ ] » M R A) (cond : ∀ m, f m * f m = algebraMap _ _ (Q m)) :\n    (ι Q).range.map (lift Q ⟨f, cond⟩).to_linear_map = f.range := by rw [← LinearMap.range_comp, ι_comp_lift]\n#align ι_range_map_lift ι_range_map_lift\n\n",
 "ι_mul_ι_mul_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- $aba$ is a vector. -/\ntheorem ι_mul_ι_mul_ι (a b : M) :\n    ι Q a * ι Q b * ι Q a = ι Q («expr • » (quadratic_form.polar Q a b) a - «expr • » (Q a) b) := by\n  rw [ι_mul_comm, sub_mul, mul_assoc, ι_sq_scalar, ← Algebra.smul_def, ← Algebra.commutes, ← Algebra.smul_def, ←\n    map_smul, ← map_smul, ← map_sub]\n#align ι_mul_ι_mul_ι ι_mul_ι_mul_ι\n\n",
 "ι_mul_ι_mul_inv_of_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/-- $aba^{-1}$ is a vector. -/\ntheorem ι_mul_ι_mul_inv_of_ι (a b : M) [Invertible (ι Q a)] [Invertible (Q a)] :\n    ι Q a * ι Q b * («expr⅟») (ι Q a) = ι Q («expr • » ((«expr⅟») (Q a) * quadratic_form.polar Q a b) a - b) := by\n  rw [inv_of_ι, map_smul, mul_smul_comm, ι_mul_ι_mul_ι, ← map_smul, smul_sub, smul_smul, smul_smul, invOf_mul_self,\n    one_smul]\n#align ι_mul_ι_mul_inv_of_ι ι_mul_ι_mul_inv_of_ι\n\n",
 "ι_mul_ι_add_swap":
 "/-- The symmetric product of vectors is a scalar -/\ntheorem ι_mul_ι_add_swap (a b : M) : ι Q a * ι Q b + ι Q b * ι Q a = algebraMap R _ (quadratic_form.polar Q a b) :=\n  calc\n    ι Q a * ι Q b + ι Q b * ι Q a = ι Q (a + b) * ι Q (a + b) - ι Q a * ι Q a - ι Q b * ι Q b :=\n      by\n      rw [(ι Q).map_add, mul_add, add_mul, add_mul]\n      abel\n    _ = algebraMap R _ (Q (a + b)) - algebraMap R _ (Q a) - algebraMap R _ (Q b) := by\n      rw [ι_sq_scalar, ι_sq_scalar, ι_sq_scalar]\n    _ = algebraMap R _ (Q (a + b) - Q a - Q b) := by rw [← RingHom.map_sub, ← RingHom.map_sub]\n    _ = algebraMap R _ (quadratic_form.polar Q a b) := rfl\n    \n#align ι_mul_ι_add_swap ι_mul_ι_add_swap\n\n",
 "ι_mul_comm":
 "theorem ι_mul_comm (a b : M) : ι Q a * ι Q b = algebraMap R _ (quadratic_form.polar Q a b) - ι Q b * ι Q a :=\n  eq_sub_of_add_eq (ι_mul_ι_add_swap a b)\n#align ι_mul_comm ι_mul_comm\n\n",
 "ι_comp_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ι_comp_lift (f : «expr →ₗ[ ] » M R A) (cond : ∀ m, f m * f m = algebraMap _ _ (Q m)) :\n    (lift Q ⟨f, cond⟩).to_linear_map.comp (ι Q) = f :=\n  Subtype.mk_eq_mk.mp <| (lift Q).symm_apply_apply ⟨f, cond⟩\n#align ι_comp_lift ι_comp_lift\n\n",
 "to_clifford_ι":
 "@[simp]\ntheorem to_clifford_ι (m : M) : (tensor_algebra.ι R m).to_clifford = clifford_algebra.ι Q m := by simp [to_clifford]\n#align to_clifford_ι to_clifford_ι\n\n",
 "map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_id : (map Q₁ Q₁ (LinearMap.id : «expr →ₗ[ ] » M₁ R M₁) fun m => rfl) = AlgHom.id R (clifford_algebra Q₁) :=\n  by\n  ext m\n  exact map_apply_ι _ _ _ _ m\n#align map_id map_id\n\n",
 "map_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_comp_ι (f : «expr →ₗ[ ] » M₁ R M₂) (hf) : (map Q₁ Q₂ f hf).to_linear_map.comp (ι Q₁) = (ι Q₂).comp f :=\n  ι_comp_lift _ _\n#align map_comp_ι map_comp_ι\n\n",
 "map_comp_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_comp_map (f : «expr →ₗ[ ] » M₂ R M₃) (hf) (g : «expr →ₗ[ ] » M₁ R M₂) (hg) :\n    (map Q₂ Q₃ f hf).comp (map Q₁ Q₂ g hg) = map Q₁ Q₃ (f.comp g) fun m => (hf _).trans <| hg m :=\n  by\n  ext m\n  dsimp only [LinearMap.comp_apply, AlgHom.comp_apply, AlgHom.toLinearMap_apply, AlgHom.id_apply]\n  rw [map_apply_ι, map_apply_ι, map_apply_ι, LinearMap.comp_apply]\n#align map_comp_map map_comp_map\n\n",
 "map_apply_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_apply_ι (f : «expr →ₗ[ ] » M₁ R M₂) (hf) (m : M₁) : map Q₁ Q₂ f hf (ι Q₁ m) = ι Q₂ (f m) :=\n  lift_ι_apply _ _ m\n#align map_apply_ι map_apply_ι\n\n",
 "lift_ι_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lift_ι_apply (f : «expr →ₗ[ ] » M R A) (cond : ∀ m, f m * f m = algebraMap _ _ (Q m)) (x) :\n    lift Q ⟨f, cond⟩ (ι Q x) = f x :=\n  (LinearMap.ext_iff.mp <| ι_comp_lift f cond) x\n#align lift_ι_apply lift_ι_apply\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem lift_unique (f : «expr →ₗ[ ] » M R A) (cond : ∀ m : M, f m * f m = algebraMap _ _ (Q m))\n    (g : «expr →ₐ[ ] » (clifford_algebra Q) R A) : g.to_linear_map.comp (ι Q) = f ↔ g = lift Q ⟨f, cond⟩ :=\n  by\n  convert(lift Q).symm_apply_eq\n  rw [lift_symm_apply]\n  simp only\n#align lift_unique lift_unique\n\n",
 "lift_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem lift_comp_ι (g : «expr →ₐ[ ] » (clifford_algebra Q) R A) :\n    lift Q ⟨g.to_linear_map.comp (ι Q), comp_ι_sq_scalar _⟩ = g :=\n  by\n  convert(lift Q).apply_symm_apply g\n  rw [lift_symm_apply]\n  rfl\n#align lift_comp_ι lift_comp_ι\n\n",
 "is_unit_ι_of_is_unit":
 "theorem is_unit_ι_of_is_unit {m : M} (h : IsUnit (Q m)) : IsUnit (ι Q m) :=\n  by\n  cases h.nonempty_invertible\n  letI := invertible_ι_of_invertible Q m\n  exact isUnit_of_invertible (ι Q m)\n#align is_unit_ι_of_is_unit is_unit_ι_of_is_unit\n\n",
 "inv_of_ι_mul_ι_mul_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/-- $a^{-1}ba$ is a vector. -/\ntheorem inv_of_ι_mul_ι_mul_ι (a b : M) [Invertible (ι Q a)] [Invertible (Q a)] :\n    («expr⅟») (ι Q a) * ι Q b * ι Q a = ι Q («expr • » ((«expr⅟») (Q a) * quadratic_form.polar Q a b) a - b) := by\n  rw [inv_of_ι, map_smul, smul_mul_assoc, smul_mul_assoc, ι_mul_ι_mul_ι, ← map_smul, smul_sub, smul_smul, smul_smul,\n    invOf_mul_self, one_smul]\n#align inv_of_ι_mul_ι_mul_ι inv_of_ι_mul_ι_mul_ι\n\n",
 "inv_of_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/-- For a vector with invertible quadratic form, $v^{-1} = \\frac{v}{Q(v)}$ -/\ntheorem inv_of_ι (m : M) [Invertible (Q m)] [Invertible (ι Q m)] :\n    («expr⅟») (ι Q m) = ι Q («expr • » ((«expr⅟») (Q m)) m) :=\n  by\n  letI := invertible_ι_of_invertible Q m\n  convert(rfl : («expr⅟») (ι Q m) = _)\n#align inv_of_ι inv_of_ι\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- This proof closely follows `tensor_algebra.induction`\n/-- If `C` holds for the `algebra_map` of `r : R` into `clifford_algebra Q`, the `ι` of `x : M`,\nand is preserved under addition and muliplication, then it holds for all of `clifford_algebra Q`.\n\nSee also the stronger `clifford_algebra.left_induction` and `clifford_algebra.right_induction`.\n-/\n@[elab_as_elim]\ntheorem induction {C : clifford_algebra Q → Prop} (h_grade0 : ∀ r, C (algebraMap R (clifford_algebra Q) r))\n    (h_grade1 : ∀ x, C (ι Q x)) (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))\n    (a : clifford_algebra Q) : C a :=\n  by\n  -- the arguments are enough to construct a subalgebra, and a mapping into it from M\n  let s : Subalgebra R (clifford_algebra Q) :=\n    { carrier := C\n      mul_mem' := h_mul\n      add_mem' := h_add\n      algebra_map_mem' := h_grade0 }\n  let of : { f : «expr →ₗ[ ] » M R s // ∀ m, f m * f m = algebraMap _ _ (Q m) } :=\n    ⟨(ι Q).cod_restrict s.to_submodule h_grade1, fun m => Subtype.eq <| ι_sq_scalar Q m⟩\n  -- the mapping through the subalgebra is the identity\n  have of_id : AlgHom.id R (clifford_algebra Q) = s.val.comp (lift Q of) :=\n    by\n    ext\n    simp [of]\n  -- finding a proof is finding an element of the subalgebra\n  convert Subtype.prop (lift Q of a)\n  exact AlgHom.congr_fun of_id a\n#align induction induction\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {A : Type _} [Semiring A] [Algebra R A] {f g : «expr →ₐ[ ] » (clifford_algebra Q) R A} :\n    f.to_linear_map.comp (ι Q) = g.to_linear_map.comp (ι Q) → f = g :=\n  by\n  intro h\n  apply (lift Q).symm.injective\n  rw [lift_symm_apply, lift_symm_apply]\n  simp only [h]\n#align hom_ext hom_ext\n\n",
 "equiv_of_isometry_trans":
 "@[simp]\ntheorem equiv_of_isometry_trans (e₁₂ : Q₁.isometry Q₂) (e₂₃ : Q₂.isometry Q₃) :\n    (equiv_of_isometry e₁₂).trans (equiv_of_isometry e₂₃) = equiv_of_isometry (e₁₂.trans e₂₃) :=\n  by\n  ext x\n  exact AlgHom.congr_fun (map_comp_map Q₁ Q₂ Q₃ _ _ _ _) x\n#align equiv_of_isometry_trans equiv_of_isometry_trans\n\n",
 "equiv_of_isometry_symm":
 "@[simp]\ntheorem equiv_of_isometry_symm (e : Q₁.isometry Q₂) : (equiv_of_isometry e).symm = equiv_of_isometry e.symm :=\n  rfl\n#align equiv_of_isometry_symm equiv_of_isometry_symm\n\n",
 "equiv_of_isometry_refl":
 "@[simp]\ntheorem equiv_of_isometry_refl : (equiv_of_isometry <| quadratic_form.isometry.refl Q₁) = AlgEquiv.refl :=\n  by\n  ext x\n  exact AlgHom.congr_fun (map_id Q₁) x\n#align equiv_of_isometry_refl equiv_of_isometry_refl\n\n",
 "comp_ι_sq_scalar":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem comp_ι_sq_scalar (g : «expr →ₐ[ ] » (clifford_algebra Q) R A) (m : M) :\n    g (ι Q m) * g (ι Q m) = algebraMap _ _ (Q m) := by rw [← AlgHom.map_mul, ι_sq_scalar, AlgHom.commutes]\n#align comp_ι_sq_scalar comp_ι_sq_scalar\n\n"}