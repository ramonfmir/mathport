{"ι_eq_v_add_smul_e0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ι_eq_v_add_smul_e0 (m : M) (r : R) : ι (Q' Q) (m, r) = v Q m + «expr • » r (e0 Q) := by\n  rw [e0, v, linear_map.comp_apply, linear_map.inl_apply, ← linear_map.map_smul, Prod.smul_mk, smul_zero, smul_eq_mul,\n    mul_one, ← linear_map.map_add, Prod.mk_add_mk, zero_add, add_zero]\n#align ι_eq_v_add_smul_e0 ι_eq_v_add_smul_e0\n\n",
 "v_sq_scalar":
 "theorem v_sq_scalar (m : M) : v Q m * v Q m = algebra_map _ _ (Q m) :=\n  (ι_sq_scalar _ _).trans <| by simp\n#align v_sq_scalar v_sq_scalar\n\n",
 "to_even_ι":
 "@[simp]\ntheorem to_even_ι (m : M) : (to_even Q (ι Q m) : clifford_algebra (Q' Q)) = e0 Q * v Q m :=\n  by\n  rw [to_even, clifford_algebra.lift_ι_apply, linear_map.cod_restrict_apply]\n  rfl\n#align to_even_ι to_even_ι\n\n",
 "to_even_comp_of_even":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem to_even_comp_of_even : (to_even Q).comp (of_even Q) = alg_hom.id R _ :=\n  even.alg_hom_ext (Q' Q) <|\n    even_hom.ext _ _ <|\n      linear_map.ext fun m₁ =>\n        linear_map.ext fun m₂ =>\n          subtype.ext <|\n            let ⟨m₁, r₁⟩ := m₁\n            let ⟨m₂, r₂⟩ := m₂\n            calc\n              ↑(to_even Q (of_even Q ((even.ι (Q' Q)).bilin (m₁, r₁) (m₂, r₂)))) =\n                  (e0 Q * v Q m₁ + algebra_map R _ r₁) * (e0 Q * v Q m₂ - algebra_map R _ r₂) :=\n                by\n                rw [of_even_ι, alg_hom.map_mul, alg_hom.map_add, alg_hom.map_sub, alg_hom.commutes, alg_hom.commutes,\n                  subalgebra.coe_mul, subalgebra.coe_add, subalgebra.coe_sub, to_even_ι, to_even_ι,\n                  subalgebra.coe_algebra_map, subalgebra.coe_algebra_map]\n              _ =\n                  e0 Q * v Q m₁ * (e0 Q * v Q m₂) + «expr • » r₁ (e0 Q) * v Q m₂ - «expr • » r₂ (e0 Q) * v Q m₁ -\n                    algebra_map R _ (r₁ * r₂) :=\n                by\n                rw [mul_sub, add_mul, add_mul, ← algebra.commutes, ← algebra.smul_def, ← map_mul, ← algebra.smul_def,\n                  sub_add_eq_sub_sub, smul_mul_assoc, smul_mul_assoc]\n              _ =\n                  v Q m₁ * v Q m₂ + «expr • » r₁ (e0 Q) * v Q m₂ + v Q m₁ * «expr • » r₂ (e0 Q) +\n                    «expr • » r₁ (e0 Q) * «expr • » r₂ (e0 Q) :=\n                by\n                have h1 : e0 Q * v Q m₁ * (e0 Q * v Q m₂) = v Q m₁ * v Q m₂ := by rw [← mul_assoc, e0_mul_v_mul_e0]\n                have h2 : -(«expr • » r₂ (e0 Q) * v Q m₁) = v Q m₁ * «expr • » r₂ (e0 Q) := by\n                  rw [mul_smul_comm, smul_mul_assoc, ← smul_neg, neg_e0_mul_v]\n                have h3 : -algebra_map R _ (r₁ * r₂) = «expr • » r₁ (e0 Q) * «expr • » r₂ (e0 Q) := by\n                  rw [algebra.algebra_map_eq_smul_one, smul_mul_smul, e0_mul_e0, smul_neg]\n                rw [sub_eq_add_neg, sub_eq_add_neg, h1, h2, h3]\n              _ = ι _ (m₁, r₁) * ι _ (m₂, r₂) := by\n                rw [ι_eq_v_add_smul_e0, ι_eq_v_add_smul_e0, mul_add, add_mul, add_mul, add_assoc]\n              \n#align to_even_comp_of_even to_even_comp_of_even\n\n",
 "reverse_v":
 "@[simp]\ntheorem reverse_v (m : M) : reverse (v Q m) = v Q m :=\n  reverse_ι _\n#align reverse_v reverse_v\n\n",
 "reverse_e0":
 "@[simp]\ntheorem reverse_e0 : reverse (e0 Q) = e0 Q :=\n  reverse_ι _\n#align reverse_e0 reverse_e0\n\n",
 "of_even_ι":
 "/-\n  Recall that we need:\n   * `f ⟨0,1⟩ ⟨x,0⟩ = ι x`\n   * `f ⟨x,0⟩ ⟨0,1⟩ = -ι x`\n   * `f ⟨x,0⟩ ⟨y,0⟩ = ι x * ι y`\n   * `f ⟨0,1⟩ ⟨0,1⟩ = -1`\n  -/\ntheorem of_even_ι (x y : M × R) :\n    of_even Q ((even.ι _).bilin x y) = (ι Q x.1 + algebra_map R _ x.2) * (ι Q y.1 - algebra_map R _ y.2) :=\n  even.lift_ι _ _ _ _\n#align of_even_ι of_even_ι\n\n",
 "of_even_comp_to_even":
 "theorem of_even_comp_to_even : (of_even Q).comp (to_even Q) = alg_hom.id R _ :=\n  clifford_algebra.hom_ext <|\n    linear_map.ext fun m =>\n      calc\n        of_even Q (to_even Q (ι Q m)) = of_even Q ⟨_, (to_even Q (ι Q m)).prop⟩ := by rw [subtype.coe_eta]\n        _ = (ι Q 0 + algebra_map R _ 1) * (ι Q m - algebra_map R _ 0) :=\n          by\n          simp_rw [to_even_ι]\n          exact of_even_ι Q _ _\n        _ = ι Q m := by rw [map_one, map_zero, map_zero, sub_zero, zero_add, one_mul]\n        \n#align of_even_comp_to_even of_even_comp_to_even\n\n",
 "neg_v_mul_e0":
 "theorem neg_v_mul_e0 (m : M) : -(v Q m * e0 Q) = e0 Q * v Q m :=\n  by\n  rw [neg_eq_iff_neg_eq]\n  exact neg_e0_mul_v _ m\n#align neg_v_mul_e0 neg_v_mul_e0\n\n",
 "neg_e0_mul_v":
 "theorem neg_e0_mul_v (m : M) : -(e0 Q * v Q m) = v Q m * e0 Q :=\n  by\n  refine' neg_eq_of_add_eq_zero_right ((ι_mul_ι_add_swap _ _).trans _)\n  dsimp [quadratic_form.polar]\n  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, quadratic_form.map_zero, add_sub_cancel, sub_self,\n    map_zero, zero_sub]\n#align neg_e0_mul_v neg_e0_mul_v\n\n",
 "involute_v":
 "@[simp]\ntheorem involute_v (m : M) : involute (v Q m) = -v Q m :=\n  involute_ι _\n#align involute_v involute_v\n\n",
 "involute_e0":
 "@[simp]\ntheorem involute_e0 : involute (e0 Q) = -e0 Q :=\n  involute_ι _\n#align involute_e0 involute_e0\n\n",
 "even_to_neg_ι":
 "@[simp]\ntheorem even_to_neg_ι (Q' : quadratic_form R M) (h : Q' = -Q) (m₁ m₂ : M) :\n    even_to_neg Q Q' h ((even.ι Q).bilin m₁ m₂) = -(even.ι Q').bilin m₁ m₂ :=\n  even.lift_ι _ _ m₁ m₂\n#align even_to_neg_ι even_to_neg_ι\n\n",
 "even_to_neg_comp_even_to_neg":
 "theorem even_to_neg_comp_even_to_neg (Q' : quadratic_form R M) (h : Q' = -Q) (h' : Q = -Q') :\n    (even_to_neg Q' Q h').comp (even_to_neg Q Q' h) = alg_hom.id R _ :=\n  by\n  ext (m₁ m₂) : 4\n  dsimp only [even_hom.compr₂_bilin, linear_map.compr₂_apply, alg_hom.to_linear_map_apply, alg_hom.comp_apply,\n    alg_hom.id_apply]\n  rw [even_to_neg_ι, map_neg, even_to_neg_ι, neg_neg]\n#align even_to_neg_comp_even_to_neg even_to_neg_comp_even_to_neg\n\n",
 "e0_mul_v_mul_e0":
 "@[simp]\ntheorem e0_mul_v_mul_e0 (m : M) : e0 Q * v Q m * e0 Q = v Q m := by\n  rw [← neg_v_mul_e0, ← neg_mul, mul_assoc, e0_mul_e0, mul_neg_one, neg_neg]\n#align e0_mul_v_mul_e0 e0_mul_v_mul_e0\n\n",
 "e0_mul_e0":
 "theorem e0_mul_e0 : e0 Q * e0 Q = -1 :=\n  (ι_sq_scalar _ _).trans <| by simp\n#align e0_mul_e0 e0_mul_e0\n\n",
 "coe_to_even_reverse_involute":
 "/-- The representation of the clifford conjugate (i.e. the reverse of the involute) in the even\nsubalgebra is just the reverse of the representation. -/\ntheorem coe_to_even_reverse_involute (x : clifford_algebra Q) :\n    ↑(to_even Q (reverse (involute x))) = reverse (to_even Q x : clifford_algebra (Q' Q)) :=\n  by\n  induction x using clifford_algebra.induction\n  case h_grade0 r => simp only [alg_hom.commutes, subalgebra.coe_algebra_map, reverse.commutes]\n  case h_grade1 m =>\n    simp only [involute_ι, subalgebra.coe_neg, to_even_ι, reverse.map_mul, reverse_v, reverse_e0, reverse_ι,\n      neg_e0_mul_v, map_neg]\n  case h_mul x y hx hy => simp only [map_mul, subalgebra.coe_mul, reverse.map_mul, hx, hy]\n  case h_add x y hx hy => simp only [map_add, subalgebra.coe_add, hx, hy]\n#align coe_to_even_reverse_involute coe_to_even_reverse_involute\n\n",
 "Q'_apply":
 "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\ntheorem Q'_apply (m : M × R) : Q' Q m = Q m.1 - m.2 * m.2 :=\n  (sub_eq_add_neg _ _).symm\n#align Q'_apply Q'_apply\n\n"}