{"submodule_mk''":
 "@[simp]\ntheorem submodule_mk'' (H : _root_.submodule K V) (h : finrank K H = 1) : (mk'' H h).submodule = H :=\n  by\n  suffices (equiv_submodule K V) (mk'' H h) = ⟨H, h⟩ by exact congr_arg coe this\n  dsimp [mk'']\n  simp\n#align submodule_mk'' submodule_mk''\n\n",
 "submodule_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n@[simp]\ntheorem submodule_mk (v : V) (hv : v ≠ 0) : (mk K v hv).submodule = «expr ∙ » K v :=\n  rfl\n#align submodule_mk submodule_mk\n\n",
 "submodule_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\ntheorem submodule_injective : function.injective (projectivization.submodule : (exprℙ) K V → submodule K V) :=\n  by\n  intro u v h; replace h := le_of_eq h\n  simp only [submodule_eq] at h\n  rw [submodule.le_span_singleton_iff] at h\n  rw [← mk_rep v, ← mk_rep u]\n  apply quotient.sound'\n  obtain ⟨a, ha⟩ := h u.rep (submodule.mem_span_singleton_self _)\n  have : a ≠ 0 := fun c => u.rep_nonzero (by simpa [c] using ha.symm)\n  use Units.mk0 a this, ha\n#align submodule_injective submodule_injective\n\n",
 "submodule_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem submodule_eq (v : (exprℙ) K V) : v.submodule = «expr ∙ » K v.rep :=\n  by\n  conv_lhs => rw [← v.mk_rep]\n  rfl\n#align submodule_eq submodule_eq\n\n",
 "rep_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\ntheorem rep_nonzero (v : (exprℙ) K V) : v.rep ≠ 0 :=\n  v.out'.2\n#align rep_nonzero rep_nonzero\n\n",
 "mk_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\n@[simp]\ntheorem mk_rep (v : (exprℙ) K V) : mk K v.rep v.rep_nonzero = v :=\n  by\n  dsimp [mk, projectivization.rep]\n  simp\n#align mk_rep mk_rep\n\n",
 "mk_eq_mk_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem mk_eq_mk_iff' (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) : mk K v hv = mk K w hw ↔ ∃ a : K, «expr • » a w = v :=\n  by\n  rw [mk_eq_mk_iff K v w hv hw]\n  constructor\n  · rintro ⟨a, ha⟩\n    exact ⟨a, ha⟩\n  · rintro ⟨a, ha⟩\n    refine' ⟨Units.mk0 a fun c => hv.symm _, ha⟩\n    rwa [c, zero_smul] at ha\n#align mk_eq_mk_iff' mk_eq_mk_iff'\n\n",
 "mk_eq_mk_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk_eq_mk_iff (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) :\n    mk K v hv = mk K w hw ↔ ∃ a : «expr ˣ» K, «expr • » a w = v :=\n  quotient.eq'\n#align mk_eq_mk_iff mk_eq_mk_iff\n\n",
 "mk'_eq_mk":
 "/-\nCopyright (c) 2022 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\n@[simp]\ntheorem mk'_eq_mk (v : { v : V // v ≠ 0 }) : mk' K v = mk K v v.2 :=\n  by\n  dsimp [mk, mk']\n  congr 1\n  simp\n#align mk'_eq_mk mk'_eq_mk\n\n",
 "mk''_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\n@[simp]\ntheorem mk''_submodule (v : (exprℙ) K V) : mk'' v.submodule v.finrank_submodule = v :=\n  show (equiv_submodule K V).symm (equiv_submodule K V _) = _ by simp\n#align mk''_submodule mk''_submodule\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- Mapping with respect to a semilinear map over an isomorphism of fields yields\nan injective map on projective spaces. -/\ntheorem map_injective {σ : «expr →+* » K L} {τ : «expr →+* » L K} [RingHomInvPair σ τ] (f : «expr →ₛₗ[ ] » V σ W)\n    (hf : function.injective f) : function.injective (map f hf) :=\n  by\n  intro u v h\n  rw [← u.mk_rep, ← v.mk_rep] at *\n  apply quotient.sound'\n  dsimp [map, mk] at h\n  simp only [quotient.eq'] at h\n  obtain ⟨a, ha⟩ := h\n  use Units.map τ.to_monoid_hom a\n  dsimp at ha⊢\n  have : (a : L) = σ (τ a) := by rw [RingHomInvPair.comp_apply_eq₂]\n  change «expr • » (a : L) (f v.rep) = f u.rep at ha\n  rw [this, ← f.map_smulₛₗ] at ha\n  exact hf ha\n#align map_injective map_injective\n\n",
 "map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_id : map (linear_map.id : «expr →ₗ[ ] » V K V) (linear_equiv.refl K V).injective = id :=\n  by\n  ext v\n  induction v using projectivization.ind\n  rfl\n#align map_id map_id\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem map_comp {F U : Type _} [Field F] [add_comm_group U] [Module F U] {σ : «expr →+* » K L} {τ : «expr →+* » L F}\n    {γ : «expr →+* » K F} [RingHomCompTriple σ τ γ] (f : «expr →ₛₗ[ ] » V σ W) (hf : function.injective f)\n    (g : «expr →ₛₗ[ ] » W τ U) (hg : function.injective g) : map (g.comp f) (hg.comp hf) = map g hg ∘ map f hf :=\n  by\n  ext v\n  induction v using projectivization.ind\n  rfl\n#align map_comp map_comp\n\n",
 "ind":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\n/-- An induction principle for `projectivization`.\nUse as `induction v using projectivization.ind`. -/\n@[elab_as_elim]\ntheorem ind {P : (exprℙ) K V → Prop} (h : ∀ (v : V) (h : v ≠ 0), P (mk K v h)) : ∀ p, P p :=\n  quotient.ind' <| subtype.rec <| h\n#align ind ind\n\n",
 "finrank_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\ntheorem finrank_submodule (v : (exprℙ) K V) : finrank K v.submodule = 1 :=\n  by\n  rw [submodule_eq]\n  exact finrank_span_singleton v.rep_nonzero\n#align finrank_submodule finrank_submodule\n\n",
 "exists_smul_eq_mk_rep":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_smul_eq_mk_rep (v : V) (hv : v ≠ 0) : ∃ a : «expr ˣ» K, «expr • » a v = (mk K v hv).rep :=\n  show (projectivization_setoid K V).rel _ _ from quotient.mk_out' ⟨v, hv⟩\n#align exists_smul_eq_mk_rep exists_smul_eq_mk_rep\n\n"}