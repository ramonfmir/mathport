{"independent_pair_iff_neq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Two points in a projective space are independent if and only if the points are not equal. -/\n@[simp]\ntheorem independent_pair_iff_neq (u v : (exprℙ) K V) :\n    independent («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") ↔\n      u ≠ v :=\n  by rw [independent_iff_not_dependent, dependent_pair_iff_eq u v]\n#align independent_pair_iff_neq independent_pair_iff_neq\n\n",
 "independent_iff_not_dependent":
 "/-- Independence is the negation of dependence. -/\ntheorem independent_iff_not_dependent : independent f ↔ ¬dependent f := by rw [dependent_iff_not_independent, not_not]\n#align independent_iff_not_dependent independent_iff_not_dependent\n\n",
 "independent_iff_complete_lattice_independent":
 "/-- A family of points in projective space is independent if and only if the family of\nsubmodules which the points determine is independent in the lattice-theoretic sense. -/\ntheorem independent_iff_complete_lattice_independent :\n    independent f ↔ complete_lattice.independent fun i => (f i).submodule :=\n  by\n  refine' ⟨_, fun h => _⟩\n  · rintro ⟨f, hf, hi⟩\n    simpa [submodule_mk, complete_lattice.independent_iff_linear_independent_of_ne_zero hf]\n  · rw [independent_iff]\n    refine' h.linear_independent (projectivization.submodule ∘ f) (fun i => _) fun i => _\n    · simpa only [Function.comp_apply, submodule_eq] using submodule.mem_span_singleton_self _\n    · exact rep_nonzero (f i)\n#align independent_iff_complete_lattice_independent independent_iff_complete_lattice_independent\n\n",
 "independent_iff":
 "/-\nCopyright (c) 2022 Michael Blyth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Blyth\n-/\n/-- A family of points in a projective space is independent if and only if the representative\nvectors determined by the family are linearly independent. -/\ntheorem independent_iff : independent f ↔ linear_independent K (projectivization.rep ∘ f) :=\n  by\n  refine' ⟨_, fun h => _⟩\n  · rintro ⟨ff, hff, hh⟩\n    choose a ha using fun i : ι => exists_smul_eq_mk_rep K (ff i) (hff i)\n    convert hh.units_smul a\n    ext i\n    exact (ha i).symm\n  · convert independent.mk _ _ h\n    · ext\n      simp only [mk_rep]\n    · intro i\n      apply rep_nonzero\n#align independent_iff independent_iff\n\n",
 "dependent_pair_iff_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℙ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Two points in a projective space are dependent if and only if they are equal. -/\n@[simp]\ntheorem dependent_pair_iff_eq (u v : (exprℙ) K V) :\n    dependent («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") ↔\n      u = v :=\n  by\n  simp_rw [dependent_iff_not_independent, independent_iff, linear_independent_fin2, Function.comp_apply,\n    matrix.cons_val_one, matrix.head_cons, ne.def, matrix.cons_val_zero, not_and, not_forall, not_not, ←\n    mk_eq_mk_iff' K _ _ (rep_nonzero u) (rep_nonzero v), mk_rep, imp_iff_right_iff]\n  exact or.inl (rep_nonzero v)\n#align dependent_pair_iff_eq dependent_pair_iff_eq\n\n",
 "dependent_iff_not_independent":
 "/-- Dependence is the negation of independence. -/\ntheorem dependent_iff_not_independent : dependent f ↔ ¬independent f := by rw [dependent_iff, independent_iff]\n#align dependent_iff_not_independent dependent_iff_not_independent\n\n",
 "dependent_iff":
 "/-- A family of points in a projective space is dependent if and only if their\nrepresentatives are linearly dependent. -/\ntheorem dependent_iff : dependent f ↔ ¬linear_independent K (projectivization.rep ∘ f) :=\n  by\n  refine' ⟨_, fun h => _⟩\n  · rintro ⟨ff, hff, hh1⟩\n    contrapose! hh1\n    choose a ha using fun i : ι => exists_smul_eq_mk_rep K (ff i) (hff i)\n    convert hh1.units_smul a⁻¹\n    ext i\n    simp only [← ha, inv_smul_smul, Pi.smul_apply', pi.inv_apply, Function.comp_apply]\n  · convert dependent.mk _ _ h\n    · ext i\n      simp only [mk_rep]\n    · exact fun i => rep_nonzero (f i)\n#align dependent_iff dependent_iff\n\n"}