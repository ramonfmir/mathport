{"range_lt_top_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- If the determinant of a map vanishes, then the map is not onto. -/\ntheorem range_lt_top_of_det_eq_zero {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] {f : Â«expr â†’â‚—[ ] Â» M ğ•œ M} (hf : f.det = 0) :\n    f.range < Â«exprâŠ¤Â» :=\n  by\n  have : finite_dimensional ğ•œ M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [lt_top_iff_ne_top, not_not, â† is_unit_iff_range_eq_top] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align range_lt_top_of_det_eq_zero range_lt_top_of_det_eq_zero\n\n",
 "map_basis_ne_zero_iff":
 "theorem alternating_map.map_basis_ne_zero_iff {Î¹ : Type _} [decidable_eq Î¹] [Finite Î¹] (e : basis Î¹ R M)\n    (f : alternating_map R M R Î¹) : f e â‰  0 â†” f â‰  0 :=\n  not_congr <| f.map_basis_eq_zero_iff e\n#align alternating_map.map_basis_ne_zero_iff alternating_map.map_basis_ne_zero_iff\n\n",
 "map_basis_eq_zero_iff":
 "@[simp]\ntheorem alternating_map.map_basis_eq_zero_iff {Î¹ : Type _} [decidable_eq Î¹] [Finite Î¹] (e : basis Î¹ R M)\n    (f : alternating_map R M R Î¹) : f e = 0 â†” f = 0 :=\n  âŸ¨fun h => by\n    cases nonempty_fintype Î¹\n    simpa [h] using f.eq_smul_basis_det e, fun h => h.symm â–¸ alternating_map.zero_apply _âŸ©\n#align alternating_map.map_basis_eq_zero_iff alternating_map.map_basis_eq_zero_iff\n\n",
 "is_unit_det'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Specialization of `linear_equiv.is_unit_det` -/\ntheorem linear_equiv.is_unit_det' {A : Type _} [CommRing A] [Module A M] (f : Â«expr â‰ƒâ‚—[ ] Â» M A M) :\n    is_unit (linear_map.det (f : Â«expr â†’â‚—[ ] Â» M A M)) :=\n  isUnit_of_mul_eq_one _ _ f.det_mul_det_symm\n#align linear_equiv.is_unit_det' linear_equiv.is_unit_det'\n\n",
 "is_unit_det":
 "theorem basis.is_unit_det (e' : basis Î¹ R M) : is_unit (e.det e') :=\n  (is_basis_iff_det e).mp âŸ¨e'.linear_independent, e'.span_eqâŸ©\n#align basis.is_unit_det basis.is_unit_det\n\n",
 "is_basis_iff_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\ntheorem is_basis_iff_det {v : Î¹ â†’ M} : linear_independent R v âˆ§ span R (Set.range v) = Â«exprâŠ¤Â» â†” is_unit (e.det v) :=\n  by\n  constructor\n  Â· rintro âŸ¨hli, hspanâŸ©\n    set v' := basis.mk hli hspan.ge with v'_eq\n    rw [e.det_apply]\n    convert linear_equiv.is_unit_det (linear_equiv.refl _ _) v' e using 2\n    ext (i j)\n    simp\n  Â· intro h\n    rw [basis.det_apply, basis.to_matrix_eq_to_matrix_constr] at h\n    set v' := basis.map e (linear_equiv.of_is_unit_det h) with v'_def\n    have : Â«exprâ‡‘ Â» v' = v := by\n      ext i\n      rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis]\n    rw [â† this]\n    exact âŸ¨v'.linear_independent, v'.span_eqâŸ©\n#align is_basis_iff_det is_basis_iff_det\n\n",
 "finite_dimensional_of_det_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem finite_dimensional_of_det_ne_one {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M)\n    (hf : f.det â‰  1) : finite_dimensional ğ•œ M :=\n  by\n  by_cases H : âˆƒ s : Finset M, nonempty (basis s ğ•œ M)\n  Â· rcases H with âŸ¨s, âŸ¨hsâŸ©âŸ©\n    exact finite_dimensional.of_fintype_basis hs\n  Â·\n    classical\n      simp [linear_map.coe_det, H] at hf\n      exact hf.elim\n#align finite_dimensional_of_det_ne_one finite_dimensional_of_det_ne_one\n\n",
 "eq_smul_basis_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Any alternating map to `R` where `Î¹` has the cardinality of a basis equals the determinant\nmap with respect to that basis, multiplied by the value of that alternating map on that basis. -/\ntheorem alternating_map.eq_smul_basis_det (f : alternating_map R M R Î¹) : f = Â«expr â€¢ Â» (f e) e.det :=\n  by\n  refine' basis.ext_alternating e fun i h => _\n  let Ïƒ : equiv.perm Î¹ := Equiv.ofBijective i (finite.injective_iff_bijective.1 h)\n  change f (e âˆ˜ Ïƒ) = (Â«expr â€¢ Â» (f e) e.det) (e âˆ˜ Ïƒ)\n  simp [alternating_map.map_perm, basis.det_self]\n#align alternating_map.eq_smul_basis_det alternating_map.eq_smul_basis_det\n\n",
 "det_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_zero' {Î¹ : Type _} [Finite Î¹] [nonempty Î¹] (b : basis Î¹ A M) :\n    linear_map.det (0 : Â«expr â†’â‚—[ ] Â» M A M) = 0 :=\n  by\n  haveI := classical.dec_eq Î¹\n  cases nonempty_fintype Î¹\n  rwa [â† det_to_matrix b, linear_equiv.map_zero, det_zero]\n#align det_zero' det_zero'\n\n",
 "det_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`,\nand `0` otherwise. We give a formula that also works in infinite dimension, where we define\nthe determinant to be `1`. -/\n@[simp]\ntheorem det_zero {ğ•œ : Type _} [Field ğ•œ] {M : Type _} [add_comm_group M] [Module ğ•œ M] :\n    linear_map.det (0 : Â«expr â†’â‚—[ ] Â» M ğ•œ M) = (0 : ğ•œ) ^ finite_dimensional.finrank ğ•œ M := by\n  simp only [â† zero_smul ğ•œ (1 : Â«expr â†’â‚—[ ] Â» M ğ•œ M), det_smul, mul_one, MonoidHom.map_one]\n#align det_zero det_zero\n\n",
 "det_units_smul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- The determinant of a basis constructed by `units_smul` is the product of the given units. -/\n@[simp]\ntheorem basis.det_units_smul_self (w : Î¹ â†’ Â«expr Ë£Â» R) :\n    e.det (e.units_smul w) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  by simp [basis.det_apply]\n#align basis.det_units_smul_self basis.det_units_smul_self\n\n",
 "det_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- If a basis is multiplied columnwise by scalars `w : Î¹ â†’ RË£`, then the determinant with respect\nto this basis is multiplied by the product of the inverse of these scalars. -/\ntheorem basis.det_units_smul (e : basis Î¹ R M) (w : Î¹ â†’ Â«expr Ë£Â» R) :\n    (e.units_smul w).det =\n      Â«expr â€¢ Â»\n        (â†‘(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))â»Â¹ :\n          R)\n        e.det :=\n  by\n  ext f\n  change\n    (matrix.det fun i j => (e.units_smul w).repr (f j) i) =\n      Â«expr â€¢ Â»\n        (â†‘(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))â»Â¹ :\n          R)\n        (matrix.det fun i j => e.repr (f j) i)\n  simp only [e.repr_units_smul]\n  convert matrix.det_mul_column (fun i => (â†‘(w i)â»Â¹ : R)) fun i j => e.repr (f j) i\n  simp [â† finset.prod_inv_distrib]\n#align basis.det_units_smul basis.det_units_smul\n\n",
 "det_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem det_trans (f g : Â«expr â‰ƒâ‚—[ ] Â» M R M) : (f.trans g).det = g.det * f.det :=\n  map_mul _ g f\n#align det_trans det_trans\n\n",
 "det_to_matrix_eq_det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- The determinant of `linear_map.to_matrix` does not depend on the choice of basis. -/\ntheorem det_to_matrix_eq_det_to_matrix [decidable_eq Îº] (b : basis Î¹ A M) (c : basis Îº A M) (f : Â«expr â†’â‚—[ ] Â» M A M) :\n    det (linear_map.to_matrix b b f) = det (linear_map.to_matrix c c f) := by\n  rw [â† linear_map_to_matrix_mul_basis_to_matrix c b c, â† basis_to_matrix_mul_linear_map_to_matrix b c b,\n      matrix.det_conj_of_mul_eq_one] <;>\n    rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]\n#align det_to_matrix_eq_det_to_matrix det_to_matrix_eq_det_to_matrix\n\n",
 "det_to_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_to_matrix' {Î¹ : Type _} [fintype Î¹] [decidable_eq Î¹] (f : Â«expr â†’â‚—[ ] Â» (Î¹ â†’ A) A (Î¹ â†’ A)) :\n    det f.to_matrix' = f.det := by simp [â† to_matrix_eq_to_matrix']\n#align det_to_matrix' det_to_matrix'\n\n",
 "det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_to_matrix (b : basis Î¹ A M) (f : Â«expr â†’â‚—[ ] Â» M A M) : matrix.det (to_matrix b b f) = f.det :=\n  by\n  haveI := classical.dec_eq M\n  rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b]\n#align det_to_matrix det_to_matrix\n\n",
 "det_to_lin'":
 "@[simp]\ntheorem det_to_lin' (f : matrix Î¹ Î¹ R) : linear_map.det f.to_lin' = f.det := by\n  simp only [â† to_lin_eq_to_lin', det_to_lin]\n#align det_to_lin' det_to_lin'\n\n",
 "det_to_lin":
 "@[simp]\ntheorem det_to_lin (b : basis Î¹ R M) (f : matrix Î¹ Î¹ R) : linear_map.det (matrix.to_lin b b f) = f.det := by\n  rw [â† linear_map.det_to_matrix b, linear_map.to_matrix_to_lin]\n#align det_to_lin det_to_lin\n\n",
 "det_symm_mul_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem linear_equiv.det_symm_mul_det {A : Type _} [CommRing A] [Module A M] (f : Â«expr â‰ƒâ‚—[ ] Â» M A M) :\n    (f.symm : Â«expr â†’â‚—[ ] Â» M A M).det * (f : Â«expr â†’â‚—[ ] Â» M A M).det = 1 := by simp [â† linear_map.det_comp]\n#align linear_equiv.det_symm_mul_det linear_equiv.det_symm_mul_det\n\n",
 "det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem det_symm (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) : f.symm.det = f.detâ»Â¹ :=\n  map_inv _ f\n#align det_symm det_symm\n\n",
 "det_smul_mk_coord_eq_det_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- If we fix a background basis `e`, then for any other basis `v`, we can characterise the\ncoordinates provided by `v` in terms of determinants relative to `e`. -/\ntheorem basis.det_smul_mk_coord_eq_det_update {v : Î¹ â†’ M} (hli : linear_independent R v)\n    (hsp : Â«exprâŠ¤Â» â‰¤ span R (range v)) (i : Î¹) :\n    Â«expr â€¢ Â» (e.det v) ((basis.mk hli hsp).coord i) = e.det.to_multilinear_map.to_linear_map v i :=\n  by\n  apply (basis.mk hli hsp).ext\n  intro k\n  rcases eq_or_ne k i with (rfl | hik) <;>\n    simp only [algebra.id.smul_eq_mul, basis.coe_mk, linear_map.smul_apply, linear_map.coe_mk,\n      multilinear_map.to_linear_map_apply]\n  Â· rw [basis.mk_coord_apply_eq, mul_one, update_eq_self]\n    congr\n  Â· rw [basis.mk_coord_apply_ne hik, mul_zero, eq_comm]\n    exact e.det.map_eq_zero_of_eq _ (by simp [hik, function.update_apply]) hik\n#align basis.det_smul_mk_coord_eq_det_update basis.det_smul_mk_coord_eq_det_update\n\n",
 "det_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Multiplying a map by a scalar `c` multiplies its determinant by `c ^ dim M`. -/\n@[simp]\ntheorem det_smul {ğ•œ : Type _} [Field ğ•œ] {M : Type _} [add_comm_group M] [Module ğ•œ M] (c : ğ•œ) (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M) :\n    linear_map.det (Â«expr â€¢ Â» c f) = c ^ finite_dimensional.finrank ğ•œ M * linear_map.det f :=\n  by\n  by_cases H : âˆƒ s : Finset M, nonempty (basis s ğ•œ M)\n  Â· have : finite_dimensional ğ•œ M := by\n      rcases H with âŸ¨s, âŸ¨hsâŸ©âŸ©\n      exact finite_dimensional.of_fintype_basis hs\n    simp only [â† det_to_matrix (finite_dimensional.fin_basis ğ•œ M), linear_equiv.map_smul, fintype.card_fin, det_smul]\n  Â·\n    classical\n      have : finite_dimensional.finrank ğ•œ M = 0 := finrank_eq_zero_of_not_exists_basis H\n      simp [coe_det, H, this]\n#align det_smul det_smul\n\n",
 "det_self":
 "theorem basis.det_self : e.det e = 1 := by simp [e.det_apply]\n#align basis.det_self basis.det_self\n\n",
 "det_reindex_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\ntheorem basis.det_reindex_symm {Î¹' : Type _} [fintype Î¹'] [decidable_eq Î¹'] (b : basis Î¹ R M) (v : Î¹ â†’ M)\n    (e : Â«expr â‰ƒ Â» Î¹' Î¹) : (b.reindex e.symm).det (v âˆ˜ e) = b.det v := by\n  rw [basis.det_reindex, function.comp.assoc, e.self_comp_symm, function.comp.right_id]\n#align basis.det_reindex_symm basis.det_reindex_symm\n\n",
 "det_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\ntheorem basis.det_reindex {Î¹' : Type _} [fintype Î¹'] [decidable_eq Î¹'] (b : basis Î¹ R M) (v : Î¹' â†’ M)\n    (e : Â«expr â‰ƒ Â» Î¹ Î¹') : (b.reindex e).det v = b.det (v âˆ˜ e) := by\n  rw [basis.det_apply, basis.to_matrix_reindex', det_reindex_alg_equiv, basis.det_apply]\n#align basis.det_reindex basis.det_reindex\n\n",
 "det_refl":
 "@[simp]\ntheorem det_refl : (linear_equiv.refl R M).det = 1 :=\n  Units.ext <| linear_map.det_id\n#align det_refl det_refl\n\n",
 "det_ne_zero":
 "/-- `basis.det` is not the zero map. -/\ntheorem basis.det_ne_zero [nontrivial R] : e.det â‰  0 := fun h => by simpa [h] using e.det_self\n#align basis.det_ne_zero basis.det_ne_zero\n\n",
 "det_mul_det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem linear_equiv.det_mul_det_symm {A : Type _} [CommRing A] [Module A M] (f : Â«expr â‰ƒâ‚—[ ] Â» M A M) :\n    (f : Â«expr â†’â‚—[ ] Â» M A M).det * (f.symm : Â«expr â†’â‚—[ ] Â» M A M).det = 1 := by simp [â† linear_map.det_comp]\n#align linear_equiv.det_mul_det_symm linear_equiv.det_mul_det_symm\n\n",
 "det_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\ntheorem basis.det_map' (b : basis Î¹ R M) (f : Â«expr â‰ƒâ‚—[ ] Â» M R M') : (b.map f).det = b.det.comp_linear_map f.symm :=\n  alternating_map.ext <| b.det_map f\n#align basis.det_map' basis.det_map'\n\n",
 "det_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem basis.det_map (b : basis Î¹ R M) (f : Â«expr â‰ƒâ‚—[ ] Â» M R M') (v : Î¹ â†’ M') :\n    (b.map f).det v = b.det (f.symm âˆ˜ v) := by rw [basis.det_apply, basis.to_matrix_map, basis.det_apply]\n#align basis.det_map basis.det_map\n\n",
 "det_is_unit_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- The determinant of a basis constructed by `is_unit_smul` is the product of the given units. -/\n@[simp]\ntheorem basis.det_is_unit_smul {w : Î¹ â†’ R} (hw : âˆ€ i, is_unit (w i)) :\n    e.det (e.is_unit_smul hw) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  e.det_units_smul_self _\n#align basis.det_is_unit_smul basis.det_is_unit_smul\n\n",
 "det_is_empty":
 "@[simp]\ntheorem basis.det_is_empty [is_empty Î¹] : e.det = alternating_map.const_of_is_empty R M 1 :=\n  by\n  ext v\n  exact matrix.det_is_empty\n#align basis.det_is_empty basis.det_is_empty\n\n",
 "det_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_id : (linear_map.id : Â«expr â†’â‚—[ ] Â» M A M).det = 1 :=\n  linear_map.det.map_one\n#align det_id det_id\n\n",
 "det_eq_one_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_eq_one_of_subsingleton [subsingleton M] (f : Â«expr â†’â‚—[ ] Â» M R M) : (f : Â«expr â†’â‚—[ ] Â» M R M).det = 1 :=\n  by\n  have b : basis (fin 0) R M := basis.empty M\n  rw [â† f.det_to_matrix b]\n  exact matrix.det_is_empty\n#align det_eq_one_of_subsingleton det_eq_one_of_subsingleton\n\n",
 "det_eq_one_of_finrank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_eq_one_of_finrank_eq_zero {ğ•œ : Type _} [Field ğ•œ] {M : Type _} [add_comm_group M] [Module ğ•œ M]\n    (h : finite_dimensional.finrank ğ•œ M = 0) (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M) : (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M).det = 1 := by\n  classical\n    refine' @linear_map.det_cases M _ ğ•œ _ _ _ (fun t => t = 1) f _ rfl\n    intro s b\n    have : is_empty s := by\n      rw [â† fintype.card_eq_zero_iff]\n      exact (finite_dimensional.finrank_eq_card_basis b).symm.trans h\n    exact matrix.det_is_empty\n#align det_eq_one_of_finrank_eq_zero det_eq_one_of_finrank_eq_zero\n\n",
 "det_eq_det_to_matrix_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n-- Auxiliary lemma, the `simp` normal form goes in the other direction\n-- (using `linear_map.det_to_matrix`)\ntheorem det_eq_det_to_matrix_of_finset [decidable_eq M] {s : Finset M} (b : basis s A M) (f : Â«expr â†’â‚—[ ] Â» M A M) :\n    f.det = matrix.det (linear_map.to_matrix b b f) :=\n  by\n  have : âˆƒ s : Finset M, nonempty (basis s A M) := âŸ¨s, âŸ¨bâŸ©âŸ©\n  rw [linear_map.coe_det, dif_pos, det_aux_def' _ b] <;> assumption\n#align det_eq_det_to_matrix_of_finset det_eq_det_to_matrix_of_finset\n\n",
 "det_conj_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If `M'` is a two-sided inverse for `M` (indexed differently), `det (M â¬ N â¬ M') = det N`.\n\nSee `matrix.det_conj` and `matrix.det_conj'` for the case when `M' = Mâ»Â¹` or vice versa. -/\ntheorem det_conj_of_mul_eq_one [decidable_eq m] [decidable_eq n] {M : matrix m n A} {M' : matrix n m A}\n    {N : matrix n n A} (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) :\n    det (matrix.mul (matrix.mul M N) M') = det N := by\n  rw [â† det_comm' hM'M hMM', â† matrix.mul_assoc, hM'M, matrix.one_mul]\n#align det_conj_of_mul_eq_one det_conj_of_mul_eq_one\n\n",
 "det_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/-- Conjugating a linear equiv by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) (e : Â«expr â‰ƒâ‚—[ ] Â» M R M') : ((e.symm.trans f).trans e).det = f.det := by\n  rw [â† Units.eq_iff, coe_det, coe_det, â† comp_coe, â† comp_coe, linear_map.det_conj]\n#align det_conj det_conj\n\n",
 "det_comp_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem basis.det_comp_basis [Module A M'] (b : basis Î¹ A M) (b' : basis Î¹ A M') (f : Â«expr â†’â‚—[ ] Â» M A M') :\n    b'.det (f âˆ˜ b) = linear_map.det (Â«expr âˆ˜â‚— Â» f (b'.equiv b (equiv.refl Î¹) : Â«expr â†’â‚—[ ] Â» M' A M)) :=\n  by\n  rw [basis.det_apply, â† linear_map.det_to_matrix b', linear_map.to_matrix_comp _ b, matrix.det_mul,\n    linear_map.to_matrix_basis_equiv, matrix.det_one, mul_one]\n  congr 1; ext (i j)\n  rw [basis.to_matrix_apply, linear_map.to_matrix_apply]\n#align basis.det_comp_basis basis.det_comp_basis\n\n",
 "det_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem basis.det_comp (e : basis Î¹ A M) (f : Â«expr â†’â‚—[ ] Â» M A M) (v : Î¹ â†’ M) : e.det (f âˆ˜ v) = f.det * e.det v := by\n  rw [basis.det_apply, basis.det_apply, â† f.det_to_matrix e, â† matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f âˆ˜ v),\n    e.to_matrix_eq_to_matrix_constr v, â† to_matrix_comp, e.constr_comp]\n#align basis.det_comp basis.det_comp\n\n",
 "det_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If there exists a two-sided inverse `M'` for `M` (indexed differently),\nthen `det (N â¬ M) = det (M â¬ N)`. -/\ntheorem det_comm' [decidable_eq m] [decidable_eq n] {M : matrix n m A} {N : matrix m n A} {M' : matrix m n A}\n    (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) : det (matrix.mul M N) = det (matrix.mul N M) :=\n  by\n  nontriviality A\n  -- Although `m` and `n` are different a priori, we will show they have the same cardinality.\n  -- This turns the problem into one for square matrices, which is easy.\n  let e := index_equiv_of_inv hMM' hM'M\n  rw [â† det_submatrix_equiv_self e, â† submatrix_mul_equiv _ _ _ (equiv.refl n) _, det_comm, submatrix_mul_equiv,\n    equiv.coe_refl, submatrix_id_id]\n#align det_comm' det_comm'\n\n",
 "det_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-\nCopyright (c) 2019 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\ntheorem det_comm [decidable_eq n] (M N : matrix n n A) : det (matrix.mul M N) = det (matrix.mul N M) := by\n  rw [det_mul, det_mul, mul_comm]\n#align det_comm det_comm\n\n",
 "det_coe_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- The determinant of `f.symm` is the inverse of that of `f` when `f` is a linear equiv. -/\ntheorem linear_equiv.det_coe_symm {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] (f : Â«expr â‰ƒâ‚—[ ] Â» M ğ•œ M) :\n    (f.symm : Â«expr â†’â‚—[ ] Â» M ğ•œ M).det = (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M).detâ»Â¹ := by\n  field_simp [IsUnit.ne_zero f.is_unit_det']\n#align linear_equiv.det_coe_symm linear_equiv.det_coe_symm\n\n",
 "det_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- To show `P f.det` it suffices to consider `P (to_matrix _ _ f).det` and `P 1`. -/\n@[elab_as_elim]\ntheorem det_cases [decidable_eq M] {P : A â†’ Prop} (f : Â«expr â†’â‚—[ ] Â» M A M)\n    (hb : âˆ€ (s : Finset M) (b : basis s A M), P (to_matrix b b f).det) (h1 : P 1) : P f.det :=\n  by\n  unfold linear_map.det\n  split_ifs with h\n  Â· convert hb _ h.some_spec.some\n    apply det_aux_def'\n  Â· exact h1\n#align det_cases det_cases\n\n",
 "det_aux_id":
 "@[simp]\ntheorem det_aux_id (b : trunc <| basis Î¹ A M) : linear_map.det_aux b linear_map.id = 1 :=\n  (linear_map.det_aux b).map_one\n#align det_aux_id det_aux_id\n\n",
 "det_aux_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_aux_def' {Î¹' : Type _} [fintype Î¹'] [decidable_eq Î¹'] (tb : trunc <| basis Î¹ A M) (b' : basis Î¹' A M)\n    (f : Â«expr â†’â‚—[ ] Â» M A M) : linear_map.det_aux tb f = matrix.det (linear_map.to_matrix b' b' f) :=\n  by\n  apply trunc.induction_on tb\n  intro b\n  rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']\n#align det_aux_def' det_aux_def'\n\n",
 "det_aux_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Unfold lemma for `det_aux`.\n\nSee also `det_aux_def'` which allows you to vary the basis.\n-/\ntheorem det_aux_def (b : basis Î¹ A M) (f : Â«expr â†’â‚—[ ] Â» M A M) :\n    linear_map.det_aux (trunc.mk b) f = matrix.det (linear_map.to_matrix b b f) :=\n  by\n  rw [det_aux]\n  rfl\n#align det_aux_def det_aux_def\n\n",
 "det_aux_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_aux_comp (b : trunc <| basis Î¹ A M) (f g : Â«expr â†’â‚—[ ] Â» M A M) :\n    linear_map.det_aux b (f.comp g) = linear_map.det_aux b f * linear_map.det_aux b g :=\n  (linear_map.det_aux b).map_mul f g\n#align det_aux_comp det_aux_comp\n\n",
 "det_apply":
 "theorem basis.det_apply (v : Î¹ â†’ M) : e.det v = det (e.to_matrix v) :=\n  rfl\n#align basis.det_apply basis.det_apply\n\n",
 "coe_of_is_unit_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem linear_equiv.coe_of_is_unit_det {f : Â«expr â†’â‚—[ ] Â» M R M'} {v : basis Î¹ R M} {v' : basis Î¹ R M'}\n    (h : is_unit (linear_map.to_matrix v v' f).det) : (linear_equiv.of_is_unit_det h : Â«expr â†’â‚—[ ] Â» M R M') = f :=\n  by\n  ext x\n  rfl\n#align linear_equiv.coe_of_is_unit_det linear_equiv.coe_of_is_unit_det\n\n",
 "coe_inv_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_inv_det (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) : â†‘f.detâ»Â¹ = linear_map.det (f.symm : Â«expr â†’â‚—[ ] Â» M R M) :=\n  rfl\n#align coe_inv_det coe_inv_det\n\n",
 "coe_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_det (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) : â†‘f.det = linear_map.det (f : Â«expr â†’â‚—[ ] Â» M R M) :=\n  rfl\n#align coe_det coe_det\n\n",
 "bot_lt_ker_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/-- If the determinant of a map vanishes, then the map is not injective. -/\ntheorem bot_lt_ker_of_det_eq_zero {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] {f : Â«expr â†’â‚—[ ] Â» M ğ•œ M} (hf : f.det = 0) :\n    Â«exprâŠ¥Â» < f.ker :=\n  by\n  have : finite_dimensional ğ•œ M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [bot_lt_iff_ne_bot, not_not, â† is_unit_iff_ker_eq_bot] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align bot_lt_ker_of_det_eq_zero bot_lt_ker_of_det_eq_zero\n\n",
 "basis_fun_det":
 "@[simp]\ntheorem pi.basis_fun_det : (pi.basis_fun R Î¹).det = matrix.det_row_alternating :=\n  by\n  ext M\n  rw [basis.det_apply, basis.coe_pi_basis_fun.to_matrix_eq_transpose, det_transpose]\n#align pi.basis_fun_det pi.basis_fun_det\n\n",
 "associated_det_of_eq_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem linear_map.associated_det_of_eq_comp (e : Â«expr â‰ƒâ‚—[ ] Â» M R M) (f f' : Â«expr â†’â‚—[ ] Â» M R M)\n    (h : âˆ€ x, f x = f' (e x)) : Associated f.det f'.det :=\n  by\n  suffices Associated (Â«expr âˆ˜â‚— Â» f' â†‘e).det f'.det\n    by\n    convert this using 2\n    ext x\n    exact h x\n  rw [â† mul_one f'.det, linear_map.det_comp]\n  exact Associated.mul_left _ (associated_one_iff_is_unit.mpr e.is_unit_det')\n#align linear_map.associated_det_of_eq_comp linear_map.associated_det_of_eq_comp\n\n",
 "associated_det_comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\ntheorem linear_map.associated_det_comp_equiv {N : Type _} [add_comm_group N] [Module R N] (f : Â«expr â†’â‚—[ ] Â» N R M)\n    (e e' : Â«expr â‰ƒâ‚—[ ] Â» M R N) : Associated (Â«expr âˆ˜â‚— Â» f â†‘e).det (Â«expr âˆ˜â‚— Â» f â†‘e').det :=\n  by\n  refine' linear_map.associated_det_of_eq_comp (e.trans e'.symm) _ _ _\n  intro x\n  simp only [linear_map.comp_apply, linear_equiv.coe_coe, linear_equiv.trans_apply, linear_equiv.apply_symm_apply]\n#align linear_map.associated_det_comp_equiv linear_map.associated_det_comp_equiv\n\n"}