{"range_lt_top_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/-- If the determinant of a map vanishes, then the map is not onto. -/\ntheorem range_lt_top_of_det_eq_zero {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] {f : Â«expr â†’â‚—[ ] Â» M ğ•œ M} (hf : f.det = 0) :\n    f.range < Â«exprâŠ¤Â» :=\n  by\n  have : FiniteDimensional ğ•œ M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [lt_top_iff_ne_top, Classical.not_not, â† is_unit_iff_range_eq_top] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align range_lt_top_of_det_eq_zero range_lt_top_of_det_eq_zero\n\n",
 "map_basis_ne_zero_iff":
 "#print AlternatingMap.map_basis_ne_zero_iff /-\ntheorem AlternatingMap.map_basis_ne_zero_iff {Î¹ : Type _} [Finite Î¹] (e : Basis Î¹ R M) (f : AlternatingMap R M R Î¹) :\n    f e â‰  0 â†” f â‰  0 :=\n  not_congr <| f.map_basis_eq_zero_iff e\n#align alternating_map.map_basis_ne_zero_iff AlternatingMap.map_basis_ne_zero_iff\n-/\n\n",
 "map_basis_eq_zero_iff":
 "#print AlternatingMap.map_basis_eq_zero_iff /-\n@[simp]\ntheorem AlternatingMap.map_basis_eq_zero_iff {Î¹ : Type _} [Finite Î¹] (e : Basis Î¹ R M) (f : AlternatingMap R M R Î¹) :\n    f e = 0 â†” f = 0 :=\n  âŸ¨fun h => by\n    cases nonempty_fintype Î¹\n    letI := Classical.decEq Î¹\n    simpa [h] using f.eq_smul_basis_det e, fun h => h.symm â–¸ AlternatingMap.zero_apply _âŸ©\n#align alternating_map.map_basis_eq_zero_iff AlternatingMap.map_basis_eq_zero_iff\n-/\n\n",
 "is_unit_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- If a linear map is invertible, so is its determinant. -/\ntheorem is_unit_det {A : Type _} [CommRing A] [Module A M] (f : Â«expr â†’â‚—[ ] Â» M A M) (hf : IsUnit f) : IsUnit f.det :=\n  by\n  obtain âŸ¨g, hgâŸ© : âˆƒ g, f.comp g = 1 := hf.exists_right_inv\n  have : LinearMap.det f * LinearMap.det g = 1 := by simp only [â† LinearMap.det_comp, hg, MonoidHom.map_one]\n  exact isUnit_of_mul_eq_one _ _ this\n#align is_unit_det is_unit_det\n\n",
 "is_basis_iff_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâ‡‘ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n#print is_basis_iff_det /-\ntheorem is_basis_iff_det {v : Î¹ â†’ M} : LinearIndependent R v âˆ§ span R (Set.range v) = Â«exprâŠ¤Â» â†” IsUnit (e.det v) :=\n  by\n  constructor\n  Â· rintro âŸ¨hli, hspanâŸ©\n    set v' := Basis.mk hli hspan.ge with v'_eq\n    rw [e.det_apply]\n    convert LinearEquiv.isUnit_det (LinearEquiv.refl _ _) v' e using 2\n    ext (i j)\n    simp\n  Â· intro h\n    rw [Basis.det_apply, Basis.toMatrix_eq_toMatrix_constr] at h\n    set v' := Basis.map e (LinearEquiv.ofIsUnitDet h) with v'_def\n    have : Â«exprâ‡‘ Â» v' = v := by\n      ext i\n      rw [v'_def, Basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis]\n    rw [â† this]\n    exact âŸ¨v'.linear_independent, v'.span_eqâŸ©\n#align is_basis_iff_det is_basis_iff_det\n-/\n\n",
 "isUnit_det'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print LinearEquiv.isUnit_det' /-\n/-- Specialization of `linear_equiv.is_unit_det` -/\ntheorem LinearEquiv.isUnit_det' {A : Type _} [CommRing A] [Module A M] (f : Â«expr â‰ƒâ‚—[ ] Â» M A M) :\n    IsUnit (LinearMap.det (f : Â«expr â†’â‚—[ ] Â» M A M)) :=\n  isUnit_of_mul_eq_one _ _ f.det_mul_det_symm\n#align linear_equiv.is_unit_det' LinearEquiv.isUnit_det'\n-/\n\n",
 "isUnit_det":
 "#print Basis.isUnit_det /-\ntheorem Basis.isUnit_det (e' : Basis Î¹ R M) : IsUnit (e.det e') :=\n  (is_basis_iff_det e).mp âŸ¨e'.linear_independent, e'.span_eqâŸ©\n#align basis.is_unit_det Basis.isUnit_det\n-/\n\n",
 "finite_dimensional_of_det_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem finite_dimensional_of_det_ne_one {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M)\n    (hf : f.det â‰  1) : FiniteDimensional ğ•œ M :=\n  by\n  by_cases H : âˆƒ s : Finset M, Nonempty (Basis s ğ•œ M)\n  Â· rcases H with âŸ¨s, âŸ¨hsâŸ©âŸ©\n    exact FiniteDimensional.of_fintype_basis hs\n  Â·\n    classical\n      simp [LinearMap.coe_det, H] at hf\n      exact hf.elim\n#align finite_dimensional_of_det_ne_one finite_dimensional_of_det_ne_one\n\n",
 "eq_smul_basis_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print AlternatingMap.eq_smul_basis_det /-\n/-- Any alternating map to `R` where `Î¹` has the cardinality of a basis equals the determinant\nmap with respect to that basis, multiplied by the value of that alternating map on that basis. -/\ntheorem AlternatingMap.eq_smul_basis_det (f : AlternatingMap R M R Î¹) : f = Â«expr â€¢ Â» (f e) e.det :=\n  by\n  refine' Basis.ext_alternating e fun i h => _\n  let Ïƒ : Equiv.Perm Î¹ := Equiv.ofBijective i (Finite.injective_iff_bijective.1 h)\n  change f (e âˆ˜ Ïƒ) = (Â«expr â€¢ Â» (f e) e.det) (e âˆ˜ Ïƒ)\n  simp [AlternatingMap.map_perm, Basis.det_self]\n#align alternating_map.eq_smul_basis_det AlternatingMap.eq_smul_basis_det\n-/\n\n",
 "det_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_zero' {Î¹ : Type _} [Finite Î¹] [Nonempty Î¹] (b : Basis Î¹ A M) :\n    LinearMap.det (0 : Â«expr â†’â‚—[ ] Â» M A M) = 0 :=\n  by\n  haveI := Classical.decEq Î¹\n  cases nonempty_fintype Î¹\n  rwa [â† det_to_matrix b, LinearEquiv.map_zero, det_zero]\n#align det_zero' det_zero'\n\n",
 "det_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`,\nand `0` otherwise. We give a formula that also works in infinite dimension, where we define\nthe determinant to be `1`. -/\n@[simp]\ntheorem det_zero {ğ•œ : Type _} [Field ğ•œ] {M : Type _} [AddCommGroup M] [Module ğ•œ M] :\n    LinearMap.det (0 : Â«expr â†’â‚—[ ] Â» M ğ•œ M) = (0 : ğ•œ) ^ FiniteDimensional.finrank ğ•œ M := by\n  simp only [â† zero_smul ğ•œ (1 : Â«expr â†’â‚—[ ] Â» M ğ•œ M), det_smul, mul_one, MonoidHom.map_one]\n#align det_zero det_zero\n\n",
 "det_unitsSMul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Basis.det_unitsSMul_self /-\n/-- The determinant of a basis constructed by `units_smul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_unitsSMul_self (w : Î¹ â†’ Â«expr Ë£Â» R) :\n    e.det (e.units_smul w) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  by simp [Basis.det_apply]\n#align basis.det_units_smul_self Basis.det_unitsSMul_self\n-/\n\n",
 "det_unitsSMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Basis.det_unitsSMul /-\n/-- If a basis is multiplied columnwise by scalars `w : Î¹ â†’ RË£`, then the determinant with respect\nto this basis is multiplied by the product of the inverse of these scalars. -/\ntheorem Basis.det_unitsSMul (e : Basis Î¹ R M) (w : Î¹ â†’ Â«expr Ë£Â» R) :\n    (e.units_smul w).det =\n      Â«expr â€¢ Â»\n        (â†‘(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))â»Â¹ :\n          R)\n        e.det :=\n  by\n  ext f\n  change\n    (Matrix.det fun i j => (e.units_smul w).repr (f j) i) =\n      Â«expr â€¢ Â»\n        (â†‘(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))â»Â¹ :\n          R)\n        (Matrix.det fun i j => e.repr (f j) i)\n  simp only [e.repr_units_smul]\n  convert Matrix.det_mul_column (fun i => (â†‘(w i)â»Â¹ : R)) fun i j => e.repr (f j) i\n  simp [â† Finset.prod_inv_distrib]\n#align basis.det_units_smul Basis.det_unitsSMul\n-/\n\n",
 "det_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem det_trans (f g : Â«expr â‰ƒâ‚—[ ] Â» M R M) : (f.trans g).det = g.det * f.det :=\n  map_mul _ g f\n#align det_trans det_trans\n\n",
 "det_to_matrix_eq_det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- The determinant of `linear_map.to_matrix` does not depend on the choice of basis. -/\ntheorem det_to_matrix_eq_det_to_matrix [DecidableEq Îº] (b : Basis Î¹ A M) (c : Basis Îº A M) (f : Â«expr â†’â‚—[ ] Â» M A M) :\n    det (LinearMap.toMatrix b b f) = det (LinearMap.toMatrix c c f) := by\n  rw [â† linearMap_toMatrix_mul_basis_toMatrix c b c, â† basis_toMatrix_mul_linearMap_toMatrix b c b,\n      Matrix.det_conj_of_mul_eq_one] <;>\n    rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]\n#align det_to_matrix_eq_det_to_matrix det_to_matrix_eq_det_to_matrix\n\n",
 "det_to_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_to_matrix' {Î¹ : Type _} [Fintype Î¹] [DecidableEq Î¹] (f : Â«expr â†’â‚—[ ] Â» (Î¹ â†’ A) A (Î¹ â†’ A)) :\n    det f.to_matrix' = f.det := by simp [â† to_matrix_eq_to_matrix']\n#align det_to_matrix' det_to_matrix'\n\n",
 "det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_to_matrix (b : Basis Î¹ A M) (f : Â«expr â†’â‚—[ ] Â» M A M) : Matrix.det (toMatrix b b f) = f.det :=\n  by\n  haveI := Classical.decEq M\n  rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b]\n#align det_to_matrix det_to_matrix\n\n",
 "det_to_lin'":
 "@[simp]\ntheorem det_to_lin' (f : Matrix Î¹ Î¹ R) : LinearMap.det f.to_lin' = f.det := by\n  simp only [â† to_lin_eq_to_lin', det_to_lin]\n#align det_to_lin' det_to_lin'\n\n",
 "det_to_lin":
 "@[simp]\ntheorem det_to_lin (b : Basis Î¹ R M) (f : Matrix Î¹ Î¹ R) : LinearMap.det (Matrix.toLin b b f) = f.det := by\n  rw [â† LinearMap.det_toMatrix b, LinearMap.toMatrix_toLin]\n#align det_to_lin det_to_lin\n\n",
 "det_symm_mul_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print LinearEquiv.det_symm_mul_det /-\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_symm_mul_det {A : Type _} [CommRing A] [Module A M] (f : Â«expr â‰ƒâ‚—[ ] Â» M A M) :\n    (f.symm : Â«expr â†’â‚—[ ] Â» M A M).det * (f : Â«expr â†’â‚—[ ] Â» M A M).det = 1 := by simp [â† LinearMap.det_comp]\n#align linear_equiv.det_symm_mul_det LinearEquiv.det_symm_mul_det\n-/\n\n",
 "det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n@[simp]\ntheorem det_symm (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) : f.symm.det = f.detâ»Â¹ :=\n  map_inv _ f\n#align det_symm det_symm\n\n",
 "det_smul_mk_coord_eq_det_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¤Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n#print Basis.det_smul_mk_coord_eq_det_update /-\n/-- If we fix a background basis `e`, then for any other basis `v`, we can characterise the\ncoordinates provided by `v` in terms of determinants relative to `e`. -/\ntheorem Basis.det_smul_mk_coord_eq_det_update {v : Î¹ â†’ M} (hli : LinearIndependent R v)\n    (hsp : Â«exprâŠ¤Â» â‰¤ span R (range v)) (i : Î¹) :\n    Â«expr â€¢ Â» (e.det v) ((Basis.mk hli hsp).coord i) = e.det.to_multilinear_map.to_linear_map v i :=\n  by\n  apply (Basis.mk hli hsp).ext\n  intro k\n  rcases eq_or_ne k i with (rfl | hik) <;>\n    simp only [Algebra.id.smul_eq_mul, Basis.coe_mk, LinearMap.smul_apply, LinearMap.coe_mk,\n      multilinear_map.to_linear_map_apply]\n  Â· rw [Basis.mk_coord_apply_eq, mul_one, update_eq_self]\n    congr\n  Â· rw [Basis.mk_coord_apply_ne hik, MulZeroClass.mul_zero, eq_comm]\n    exact e.det.map_eq_zero_of_eq _ (by simp [hik, Function.update_apply]) hik\n#align basis.det_smul_mk_coord_eq_det_update Basis.det_smul_mk_coord_eq_det_update\n-/\n\n",
 "det_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â€¢ Â» -/\n/-- Multiplying a map by a scalar `c` multiplies its determinant by `c ^ dim M`. -/\n@[simp]\ntheorem det_smul {ğ•œ : Type _} [Field ğ•œ] {M : Type _} [AddCommGroup M] [Module ğ•œ M] (c : ğ•œ) (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M) :\n    LinearMap.det (Â«expr â€¢ Â» c f) = c ^ FiniteDimensional.finrank ğ•œ M * LinearMap.det f :=\n  by\n  by_cases H : âˆƒ s : Finset M, Nonempty (Basis s ğ•œ M)\n  Â· have : FiniteDimensional ğ•œ M := by\n      rcases H with âŸ¨s, âŸ¨hsâŸ©âŸ©\n      exact FiniteDimensional.of_fintype_basis hs\n    simp only [â† det_to_matrix (FiniteDimensional.finBasis ğ•œ M), LinearEquiv.map_smul, Fintype.card_fin, det_smul]\n  Â·\n    classical\n      have : FiniteDimensional.finrank ğ•œ M = 0 := finrank_eq_zero_of_not_exists_basis H\n      simp [coe_det, H, this]\n#align det_smul det_smul\n\n",
 "det_self":
 "#print Basis.det_self /-\ntheorem Basis.det_self : e.det e = 1 := by simp [e.det_apply]\n#align basis.det_self Basis.det_self\n-/\n\n",
 "det_reindex_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\n#print Basis.det_reindex_symm /-\ntheorem Basis.det_reindex_symm {Î¹' : Type _} [Fintype Î¹'] [DecidableEq Î¹'] (b : Basis Î¹ R M) (v : Î¹ â†’ M)\n    (e : Â«expr â‰ƒ Â» Î¹' Î¹) : (b.reindex e.symm).det (v âˆ˜ e) = b.det v := by\n  rw [Basis.det_reindex, function.comp.assoc, e.self_comp_symm, function.comp.right_id]\n#align basis.det_reindex_symm Basis.det_reindex_symm\n-/\n\n",
 "det_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ Â» -/\n#print Basis.det_reindex /-\ntheorem Basis.det_reindex {Î¹' : Type _} [Fintype Î¹'] [DecidableEq Î¹'] (b : Basis Î¹ R M) (v : Î¹' â†’ M)\n    (e : Â«expr â‰ƒ Â» Î¹ Î¹') : (b.reindex e).det v = b.det (v âˆ˜ e) := by\n  rw [Basis.det_apply, Basis.toMatrix_reindex', det_reindex_alg_equiv, Basis.det_apply]\n#align basis.det_reindex Basis.det_reindex\n-/\n\n",
 "det_refl":
 "@[simp]\ntheorem det_refl : (LinearEquiv.refl R M).det = 1 :=\n  Units.ext <| LinearMap.det_id\n#align det_refl det_refl\n\n",
 "det_ne_zero":
 "#print Basis.det_ne_zero /-\n/-- `basis.det` is not the zero map. -/\ntheorem Basis.det_ne_zero [Nontrivial R] : e.det â‰  0 := fun h => by simpa [h] using e.det_self\n#align basis.det_ne_zero Basis.det_ne_zero\n-/\n\n",
 "det_mul_det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print LinearEquiv.det_mul_det_symm /-\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_mul_det_symm {A : Type _} [CommRing A] [Module A M] (f : Â«expr â‰ƒâ‚—[ ] Â» M A M) :\n    (f : Â«expr â†’â‚—[ ] Â» M A M).det * (f.symm : Â«expr â†’â‚—[ ] Â» M A M).det = 1 := by simp [â† LinearMap.det_comp]\n#align linear_equiv.det_mul_det_symm LinearEquiv.det_mul_det_symm\n-/\n\n",
 "det_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n#print Basis.det_map' /-\ntheorem Basis.det_map' (b : Basis Î¹ R M) (f : Â«expr â‰ƒâ‚—[ ] Â» M R M') : (b.map f).det = b.det.comp_linear_map f.symm :=\n  AlternatingMap.ext <| b.det_map f\n#align basis.det_map' Basis.det_map'\n-/\n\n",
 "det_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n#print Basis.det_map /-\n@[simp]\ntheorem Basis.det_map (b : Basis Î¹ R M) (f : Â«expr â‰ƒâ‚—[ ] Â» M R M') (v : Î¹ â†’ M') :\n    (b.map f).det v = b.det (f.symm âˆ˜ v) := by rw [Basis.det_apply, Basis.toMatrix_map, Basis.det_apply]\n#align basis.det_map Basis.det_map\n-/\n\n",
 "det_isUnitSMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Basis.det_isUnitSMul /-\n/-- The determinant of a basis constructed by `is_unit_smul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_isUnitSMul {w : Î¹ â†’ R} (hw : âˆ€ i, IsUnit (w i)) :\n    e.det (e.is_unit_smul hw) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  e.det_units_smul_self _\n#align basis.det_is_unit_smul Basis.det_isUnitSMul\n-/\n\n",
 "det_isEmpty":
 "#print Basis.det_isEmpty /-\n@[simp]\ntheorem Basis.det_isEmpty [IsEmpty Î¹] : e.det = AlternatingMap.constOfIsEmpty R M 1 :=\n  by\n  ext v\n  exact Matrix.det_isEmpty\n#align basis.det_is_empty Basis.det_isEmpty\n-/\n\n",
 "det_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_id : (LinearMap.id : Â«expr â†’â‚—[ ] Â» M A M).det = 1 :=\n  LinearMap.det.map_one\n#align det_id det_id\n\n",
 "det_eq_one_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_eq_one_of_subsingleton [subsingleton M] (f : Â«expr â†’â‚—[ ] Â» M R M) : (f : Â«expr â†’â‚—[ ] Â» M R M).det = 1 :=\n  by\n  have b : Basis (Fin 0) R M := Basis.empty M\n  rw [â† f.det_to_matrix b]\n  exact Matrix.det_isEmpty\n#align det_eq_one_of_subsingleton det_eq_one_of_subsingleton\n\n",
 "det_eq_one_of_finrank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_eq_one_of_finrank_eq_zero {ğ•œ : Type _} [Field ğ•œ] {M : Type _} [AddCommGroup M] [Module ğ•œ M]\n    (h : FiniteDimensional.finrank ğ•œ M = 0) (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M) : (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M).det = 1 := by\n  classical\n    refine' @LinearMap.det_cases M _ ğ•œ _ _ _ (fun t => t = 1) f _ rfl\n    intro s b\n    have : IsEmpty s := by\n      rw [â† Fintype.card_eq_zero_iff]\n      exact (FiniteDimensional.finrank_eq_card_basis b).symm.trans h\n    exact Matrix.det_isEmpty\n#align det_eq_one_of_finrank_eq_zero det_eq_one_of_finrank_eq_zero\n\n",
 "det_eq_det_to_matrix_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n-- Auxiliary lemma, the `simp` normal form goes in the other direction\n-- (using `linear_map.det_to_matrix`)\ntheorem det_eq_det_to_matrix_of_finset [DecidableEq M] {s : Finset M} (b : Basis s A M) (f : Â«expr â†’â‚—[ ] Â» M A M) :\n    f.det = Matrix.det (LinearMap.toMatrix b b f) :=\n  by\n  have : âˆƒ s : Finset M, Nonempty (Basis s A M) := âŸ¨s, âŸ¨bâŸ©âŸ©\n  rw [LinearMap.coe_det, dif_pos, det_aux_def' _ b] <;> assumption\n#align det_eq_det_to_matrix_of_finset det_eq_det_to_matrix_of_finset\n\n",
 "det_conj_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If `M'` is a two-sided inverse for `M` (indexed differently), `det (M â¬ N â¬ M') = det N`.\n\nSee `matrix.det_conj` and `matrix.det_conj'` for the case when `M' = Mâ»Â¹` or vice versa. -/\ntheorem det_conj_of_mul_eq_one [DecidableEq m] [DecidableEq n] {M : Matrix m n A} {M' : Matrix n m A} {N : Matrix n n A}\n    (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) : det (matrix.mul (matrix.mul M N) M') = det N := by\n  rw [â† det_comm' hM'M hMM', â† Matrix.mul_assoc, hM'M, Matrix.one_mul]\n#align det_conj_of_mul_eq_one det_conj_of_mul_eq_one\n\n",
 "det_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/-- Conjugating a linear equiv by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) (e : Â«expr â‰ƒâ‚—[ ] Â» M R M') : ((e.symm.trans f).trans e).det = f.det := by\n  rw [â† Units.eq_iff, coe_det, coe_det, â† comp_coe, â† comp_coe, LinearMap.det_conj]\n#align det_conj det_conj\n\n",
 "det_comp_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print Basis.det_comp_basis /-\n@[simp]\ntheorem Basis.det_comp_basis [Module A M'] (b : Basis Î¹ A M) (b' : Basis Î¹ A M') (f : Â«expr â†’â‚—[ ] Â» M A M') :\n    b'.det (f âˆ˜ b) = LinearMap.det (Â«expr âˆ˜â‚— Â» f (b'.equiv b (Equiv.refl Î¹) : Â«expr â†’â‚—[ ] Â» M' A M)) :=\n  by\n  rw [Basis.det_apply, â† LinearMap.det_toMatrix b', LinearMap.toMatrix_comp _ b, Matrix.det_mul,\n    LinearMap.toMatrix_basis_equiv, Matrix.det_one, mul_one]\n  congr 1; ext (i j)\n  rw [Basis.toMatrix_apply, LinearMap.toMatrix_apply]\n#align basis.det_comp_basis Basis.det_comp_basis\n-/\n\n",
 "det_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print Basis.det_comp /-\n@[simp]\ntheorem Basis.det_comp (e : Basis Î¹ A M) (f : Â«expr â†’â‚—[ ] Â» M A M) (v : Î¹ â†’ M) : e.det (f âˆ˜ v) = f.det * e.det v := by\n  rw [Basis.det_apply, Basis.det_apply, â† f.det_to_matrix e, â† Matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f âˆ˜ v),\n    e.to_matrix_eq_to_matrix_constr v, â† to_matrix_comp, e.constr_comp]\n#align basis.det_comp Basis.det_comp\n-/\n\n",
 "det_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If there exists a two-sided inverse `M'` for `M` (indexed differently),\nthen `det (N â¬ M) = det (M â¬ N)`. -/\ntheorem det_comm' [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N : Matrix m n A} {M' : Matrix m n A}\n    (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) : det (matrix.mul M N) = det (matrix.mul N M) :=\n  by\n  nontriviality A\n  -- Although `m` and `n` are different a priori, we will show they have the same cardinality.\n  -- This turns the problem into one for square matrices, which is easy.\n  let e := index_equiv_of_inv hMM' hM'M\n  rw [â† det_submatrix_equiv_self e, â† submatrix_mul_equiv _ _ _ (Equiv.refl n) _, det_comm, submatrix_mul_equiv,\n    Equiv.coe_refl, submatrix_id_id]\n#align det_comm' det_comm'\n\n",
 "det_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-\nCopyright (c) 2019 Johannes HÃ¶lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes HÃ¶lzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\ntheorem det_comm [DecidableEq n] (M N : Matrix n n A) : det (matrix.mul M N) = det (matrix.mul N M) := by\n  rw [det_mul, det_mul, mul_comm]\n#align det_comm det_comm\n\n",
 "det_coe_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print LinearEquiv.det_coe_symm /-\n/-- The determinant of `f.symm` is the inverse of that of `f` when `f` is a linear equiv. -/\ntheorem LinearEquiv.det_coe_symm {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] (f : Â«expr â‰ƒâ‚—[ ] Â» M ğ•œ M) :\n    (f.symm : Â«expr â†’â‚—[ ] Â» M ğ•œ M).det = (f : Â«expr â†’â‚—[ ] Â» M ğ•œ M).detâ»Â¹ := by\n  field_simp [IsUnit.ne_zero f.is_unit_det']\n#align linear_equiv.det_coe_symm LinearEquiv.det_coe_symm\n-/\n\n",
 "det_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- To show `P f.det` it suffices to consider `P (to_matrix _ _ f).det` and `P 1`. -/\n@[elab_as_elim]\ntheorem det_cases [DecidableEq M] {P : A â†’ Prop} (f : Â«expr â†’â‚—[ ] Â» M A M)\n    (hb : âˆ€ (s : Finset M) (b : Basis s A M), P (toMatrix b b f).det) (h1 : P 1) : P f.det :=\n  by\n  unfold LinearMap.det\n  split_ifs with h\n  Â· convert hb _ h.some_spec.some\n    apply det_aux_def'\n  Â· exact h1\n#align det_cases det_cases\n\n",
 "det_aux_id":
 "@[simp]\ntheorem det_aux_id (b : Trunc <| Basis Î¹ A M) : LinearMap.detAux b LinearMap.id = 1 :=\n  (LinearMap.detAux b).map_one\n#align det_aux_id det_aux_id\n\n",
 "det_aux_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\ntheorem det_aux_def' {Î¹' : Type _} [Fintype Î¹'] [DecidableEq Î¹'] (tb : Trunc <| Basis Î¹ A M) (b' : Basis Î¹' A M)\n    (f : Â«expr â†’â‚—[ ] Â» M A M) : LinearMap.detAux tb f = Matrix.det (LinearMap.toMatrix b' b' f) :=\n  by\n  apply Trunc.induction_on tb\n  intro b\n  rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']\n#align det_aux_def' det_aux_def'\n\n",
 "det_aux_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/-- Unfold lemma for `det_aux`.\n\nSee also `det_aux_def'` which allows you to vary the basis.\n-/\ntheorem det_aux_def (b : Basis Î¹ A M) (f : Â«expr â†’â‚—[ ] Â» M A M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f) :=\n  by\n  rw [det_aux]\n  rfl\n#align det_aux_def det_aux_def\n\n",
 "det_aux_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem det_aux_comp (b : Trunc <| Basis Î¹ A M) (f g : Â«expr â†’â‚—[ ] Â» M A M) :\n    LinearMap.detAux b (f.comp g) = LinearMap.detAux b f * LinearMap.detAux b g :=\n  (LinearMap.detAux b).map_mul f g\n#align det_aux_comp det_aux_comp\n\n",
 "det_apply":
 "#print Basis.det_apply /-\ntheorem Basis.det_apply (v : Î¹ â†’ M) : e.det v = det (e.to_matrix v) :=\n  rfl\n#align basis.det_apply Basis.det_apply\n-/\n\n",
 "coe_ofIsUnitDet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print LinearEquiv.coe_ofIsUnitDet /-\n@[simp]\ntheorem LinearEquiv.coe_ofIsUnitDet {f : Â«expr â†’â‚—[ ] Â» M R M'} {v : Basis Î¹ R M} {v' : Basis Î¹ R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : (LinearEquiv.ofIsUnitDet h : Â«expr â†’â‚—[ ] Â» M R M') = f :=\n  by\n  ext x\n  rfl\n#align linear_equiv.coe_of_is_unit_det LinearEquiv.coe_ofIsUnitDet\n-/\n\n",
 "coe_inv_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_inv_det (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) : â†‘f.detâ»Â¹ = LinearMap.det (f.symm : Â«expr â†’â‚—[ ] Â» M R M) :=\n  rfl\n#align coe_inv_det coe_inv_det\n\n",
 "coe_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n@[simp]\ntheorem coe_det (f : Â«expr â‰ƒâ‚—[ ] Â» M R M) : â†‘f.det = LinearMap.det (f : Â«expr â†’â‚—[ ] Â» M R M) :=\n  rfl\n#align coe_det coe_det\n\n",
 "bot_lt_ker_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«exprâŠ¥Â» -/\n/-- If the determinant of a map vanishes, then the map is not injective. -/\ntheorem bot_lt_ker_of_det_eq_zero {ğ•œ : Type _} [Field ğ•œ] [Module ğ•œ M] {f : Â«expr â†’â‚—[ ] Â» M ğ•œ M} (hf : f.det = 0) :\n    Â«exprâŠ¥Â» < f.ker :=\n  by\n  have : FiniteDimensional ğ•œ M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [bot_lt_iff_ne_bot, Classical.not_not, â† is_unit_iff_ker_eq_bot] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align bot_lt_ker_of_det_eq_zero bot_lt_ker_of_det_eq_zero\n\n",
 "basisFun_det":
 "#print Pi.basisFun_det /-\n@[simp]\ntheorem Pi.basisFun_det : (Pi.basisFun R Î¹).det = Matrix.detRowAlternating :=\n  by\n  ext M\n  rw [Basis.det_apply, Basis.coePiBasisFun.toMatrix_eq_transpose, det_transpose]\n#align pi.basis_fun_det Pi.basisFun_det\n-/\n\n",
 "associated_det_of_eq_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n#print LinearMap.associated_det_of_eq_comp /-\ntheorem LinearMap.associated_det_of_eq_comp (e : Â«expr â‰ƒâ‚—[ ] Â» M R M) (f f' : Â«expr â†’â‚—[ ] Â» M R M)\n    (h : âˆ€ x, f x = f' (e x)) : Associated f.det f'.det :=\n  by\n  suffices Associated (Â«expr âˆ˜â‚— Â» f' â†‘e).det f'.det\n    by\n    convert this using 2\n    ext x\n    exact h x\n  rw [â† mul_one f'.det, LinearMap.det_comp]\n  exact Associated.mul_left _ (associated_one_iff_is_unit.mpr e.is_unit_det')\n#align linear_map.associated_det_of_eq_comp LinearMap.associated_det_of_eq_comp\n-/\n\n",
 "associated_det_comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’â‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒâ‚—[ ] Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr âˆ˜â‚— Â» -/\n#print LinearMap.associated_det_comp_equiv /-\ntheorem LinearMap.associated_det_comp_equiv {N : Type _} [AddCommGroup N] [Module R N] (f : Â«expr â†’â‚—[ ] Â» N R M)\n    (e e' : Â«expr â‰ƒâ‚—[ ] Â» M R N) : Associated (Â«expr âˆ˜â‚— Â» f â†‘e).det (Â«expr âˆ˜â‚— Â» f â†‘e').det :=\n  by\n  refine' LinearMap.associated_det_of_eq_comp (e.trans e'.symm) _ _ _\n  intro x\n  simp only [LinearMap.comp_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply, LinearEquiv.apply_symm_apply]\n#align linear_map.associated_det_comp_equiv LinearMap.associated_det_comp_equiv\n-/\n\n"}