{"range_lt_top_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the determinant of a map vanishes, then the map is not onto. -/\ntheorem range_lt_top_of_det_eq_zero {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] {f : «expr →ₗ[ ] » M 𝕜 M} (hf : f.det = 0) :\n    f.range < «expr⊤» :=\n  by\n  have : FiniteDimensional 𝕜 M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [lt_top_iff_ne_top, Classical.not_not, ← is_unit_iff_range_eq_top] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align range_lt_top_of_det_eq_zero range_lt_top_of_det_eq_zero\n\n",
 "map_basis_ne_zero_iff":
 "#print AlternatingMap.map_basis_ne_zero_iff /-\ntheorem AlternatingMap.map_basis_ne_zero_iff {ι : Type _} [Finite ι] (e : Basis ι R M) (f : AlternatingMap R M R ι) :\n    f e ≠ 0 ↔ f ≠ 0 :=\n  not_congr <| f.map_basis_eq_zero_iff e\n#align alternating_map.map_basis_ne_zero_iff AlternatingMap.map_basis_ne_zero_iff\n-/\n\n",
 "map_basis_eq_zero_iff":
 "#print AlternatingMap.map_basis_eq_zero_iff /-\n@[simp]\ntheorem AlternatingMap.map_basis_eq_zero_iff {ι : Type _} [Finite ι] (e : Basis ι R M) (f : AlternatingMap R M R ι) :\n    f e = 0 ↔ f = 0 :=\n  ⟨fun h => by\n    cases nonempty_fintype ι\n    letI := Classical.decEq ι\n    simpa [h] using f.eq_smul_basis_det e, fun h => h.symm ▸ AlternatingMap.zero_apply _⟩\n#align alternating_map.map_basis_eq_zero_iff AlternatingMap.map_basis_eq_zero_iff\n-/\n\n",
 "is_unit_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If a linear map is invertible, so is its determinant. -/\ntheorem is_unit_det {A : Type _} [CommRing A] [Module A M] (f : «expr →ₗ[ ] » M A M) (hf : IsUnit f) : IsUnit f.det :=\n  by\n  obtain ⟨g, hg⟩ : ∃ g, f.comp g = 1 := hf.exists_right_inv\n  have : LinearMap.det f * LinearMap.det g = 1 := by simp only [← LinearMap.det_comp, hg, MonoidHom.map_one]\n  exact isUnit_of_mul_eq_one _ _ this\n#align is_unit_det is_unit_det\n\n",
 "is_basis_iff_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print is_basis_iff_det /-\ntheorem is_basis_iff_det {v : ι → M} : LinearIndependent R v ∧ span R (Set.range v) = «expr⊤» ↔ IsUnit (e.det v) :=\n  by\n  constructor\n  · rintro ⟨hli, hspan⟩\n    set v' := Basis.mk hli hspan.ge with v'_eq\n    rw [e.det_apply]\n    convert LinearEquiv.isUnit_det (LinearEquiv.refl _ _) v' e using 2\n    ext (i j)\n    simp\n  · intro h\n    rw [Basis.det_apply, Basis.toMatrix_eq_toMatrix_constr] at h\n    set v' := Basis.map e (LinearEquiv.ofIsUnitDet h) with v'_def\n    have : «expr⇑ » v' = v := by\n      ext i\n      rw [v'_def, Basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis]\n    rw [← this]\n    exact ⟨v'.linear_independent, v'.span_eq⟩\n#align is_basis_iff_det is_basis_iff_det\n-/\n\n",
 "isUnit_det'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearEquiv.isUnit_det' /-\n/-- Specialization of `linear_equiv.is_unit_det` -/\ntheorem LinearEquiv.isUnit_det' {A : Type _} [CommRing A] [Module A M] (f : «expr ≃ₗ[ ] » M A M) :\n    IsUnit (LinearMap.det (f : «expr →ₗ[ ] » M A M)) :=\n  isUnit_of_mul_eq_one _ _ f.det_mul_det_symm\n#align linear_equiv.is_unit_det' LinearEquiv.isUnit_det'\n-/\n\n",
 "isUnit_det":
 "#print Basis.isUnit_det /-\ntheorem Basis.isUnit_det (e' : Basis ι R M) : IsUnit (e.det e') :=\n  (is_basis_iff_det e).mp ⟨e'.linear_independent, e'.span_eq⟩\n#align basis.is_unit_det Basis.isUnit_det\n-/\n\n",
 "finite_dimensional_of_det_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem finite_dimensional_of_det_ne_one {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] (f : «expr →ₗ[ ] » M 𝕜 M)\n    (hf : f.det ≠ 1) : FiniteDimensional 𝕜 M :=\n  by\n  by_cases H : ∃ s : Finset M, Nonempty (Basis s 𝕜 M)\n  · rcases H with ⟨s, ⟨hs⟩⟩\n    exact FiniteDimensional.of_fintype_basis hs\n  ·\n    classical\n      simp [LinearMap.coe_det, H] at hf\n      exact hf.elim\n#align finite_dimensional_of_det_ne_one finite_dimensional_of_det_ne_one\n\n",
 "eq_smul_basis_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print AlternatingMap.eq_smul_basis_det /-\n/-- Any alternating map to `R` where `ι` has the cardinality of a basis equals the determinant\nmap with respect to that basis, multiplied by the value of that alternating map on that basis. -/\ntheorem AlternatingMap.eq_smul_basis_det (f : AlternatingMap R M R ι) : f = «expr • » (f e) e.det :=\n  by\n  refine' Basis.ext_alternating e fun i h => _\n  let σ : Equiv.Perm ι := Equiv.ofBijective i (Finite.injective_iff_bijective.1 h)\n  change f (e ∘ σ) = («expr • » (f e) e.det) (e ∘ σ)\n  simp [AlternatingMap.map_perm, Basis.det_self]\n#align alternating_map.eq_smul_basis_det AlternatingMap.eq_smul_basis_det\n-/\n\n",
 "det_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_zero' {ι : Type _} [Finite ι] [Nonempty ι] (b : Basis ι A M) :\n    LinearMap.det (0 : «expr →ₗ[ ] » M A M) = 0 :=\n  by\n  haveI := Classical.decEq ι\n  cases nonempty_fintype ι\n  rwa [← det_to_matrix b, LinearEquiv.map_zero, det_zero]\n#align det_zero' det_zero'\n\n",
 "det_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`,\nand `0` otherwise. We give a formula that also works in infinite dimension, where we define\nthe determinant to be `1`. -/\n@[simp]\ntheorem det_zero {𝕜 : Type _} [Field 𝕜] {M : Type _} [AddCommGroup M] [Module 𝕜 M] :\n    LinearMap.det (0 : «expr →ₗ[ ] » M 𝕜 M) = (0 : 𝕜) ^ FiniteDimensional.finrank 𝕜 M := by\n  simp only [← zero_smul 𝕜 (1 : «expr →ₗ[ ] » M 𝕜 M), det_smul, mul_one, MonoidHom.map_one]\n#align det_zero det_zero\n\n",
 "det_unitsSMul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Basis.det_unitsSMul_self /-\n/-- The determinant of a basis constructed by `units_smul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_unitsSMul_self (w : ι → «expr ˣ» R) :\n    e.det (e.units_smul w) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  by simp [Basis.det_apply]\n#align basis.det_units_smul_self Basis.det_unitsSMul_self\n-/\n\n",
 "det_unitsSMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Basis.det_unitsSMul /-\n/-- If a basis is multiplied columnwise by scalars `w : ι → Rˣ`, then the determinant with respect\nto this basis is multiplied by the product of the inverse of these scalars. -/\ntheorem Basis.det_unitsSMul (e : Basis ι R M) (w : ι → «expr ˣ» R) :\n    (e.units_smul w).det =\n      «expr • »\n        (↑(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))⁻¹ :\n          R)\n        e.det :=\n  by\n  ext f\n  change\n    (Matrix.det fun i j => (e.units_smul w).repr (f j) i) =\n      «expr • »\n        (↑(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))⁻¹ :\n          R)\n        (Matrix.det fun i j => e.repr (f j) i)\n  simp only [e.repr_units_smul]\n  convert Matrix.det_mul_column (fun i => (↑(w i)⁻¹ : R)) fun i j => e.repr (f j) i\n  simp [← Finset.prod_inv_distrib]\n#align basis.det_units_smul Basis.det_unitsSMul\n-/\n\n",
 "det_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem det_trans (f g : «expr ≃ₗ[ ] » M R M) : (f.trans g).det = g.det * f.det :=\n  map_mul _ g f\n#align det_trans det_trans\n\n",
 "det_to_matrix_eq_det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The determinant of `linear_map.to_matrix` does not depend on the choice of basis. -/\ntheorem det_to_matrix_eq_det_to_matrix [DecidableEq κ] (b : Basis ι A M) (c : Basis κ A M) (f : «expr →ₗ[ ] » M A M) :\n    det (LinearMap.toMatrix b b f) = det (LinearMap.toMatrix c c f) := by\n  rw [← linearMap_toMatrix_mul_basis_toMatrix c b c, ← basis_toMatrix_mul_linearMap_toMatrix b c b,\n      Matrix.det_conj_of_mul_eq_one] <;>\n    rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]\n#align det_to_matrix_eq_det_to_matrix det_to_matrix_eq_det_to_matrix\n\n",
 "det_to_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_to_matrix' {ι : Type _} [Fintype ι] [DecidableEq ι] (f : «expr →ₗ[ ] » (ι → A) A (ι → A)) :\n    det f.to_matrix' = f.det := by simp [← to_matrix_eq_to_matrix']\n#align det_to_matrix' det_to_matrix'\n\n",
 "det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_to_matrix (b : Basis ι A M) (f : «expr →ₗ[ ] » M A M) : Matrix.det (toMatrix b b f) = f.det :=\n  by\n  haveI := Classical.decEq M\n  rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b]\n#align det_to_matrix det_to_matrix\n\n",
 "det_to_lin'":
 "@[simp]\ntheorem det_to_lin' (f : Matrix ι ι R) : LinearMap.det f.to_lin' = f.det := by\n  simp only [← to_lin_eq_to_lin', det_to_lin]\n#align det_to_lin' det_to_lin'\n\n",
 "det_to_lin":
 "@[simp]\ntheorem det_to_lin (b : Basis ι R M) (f : Matrix ι ι R) : LinearMap.det (Matrix.toLin b b f) = f.det := by\n  rw [← LinearMap.det_toMatrix b, LinearMap.toMatrix_toLin]\n#align det_to_lin det_to_lin\n\n",
 "det_symm_mul_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearEquiv.det_symm_mul_det /-\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_symm_mul_det {A : Type _} [CommRing A] [Module A M] (f : «expr ≃ₗ[ ] » M A M) :\n    (f.symm : «expr →ₗ[ ] » M A M).det * (f : «expr →ₗ[ ] » M A M).det = 1 := by simp [← LinearMap.det_comp]\n#align linear_equiv.det_symm_mul_det LinearEquiv.det_symm_mul_det\n-/\n\n",
 "det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem det_symm (f : «expr ≃ₗ[ ] » M R M) : f.symm.det = f.det⁻¹ :=\n  map_inv _ f\n#align det_symm det_symm\n\n",
 "det_smul_mk_coord_eq_det_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.det_smul_mk_coord_eq_det_update /-\n/-- If we fix a background basis `e`, then for any other basis `v`, we can characterise the\ncoordinates provided by `v` in terms of determinants relative to `e`. -/\ntheorem Basis.det_smul_mk_coord_eq_det_update {v : ι → M} (hli : LinearIndependent R v)\n    (hsp : «expr⊤» ≤ span R (range v)) (i : ι) :\n    «expr • » (e.det v) ((Basis.mk hli hsp).coord i) = e.det.to_multilinear_map.to_linear_map v i :=\n  by\n  apply (Basis.mk hli hsp).ext\n  intro k\n  rcases eq_or_ne k i with (rfl | hik) <;>\n    simp only [Algebra.id.smul_eq_mul, Basis.coe_mk, LinearMap.smul_apply, LinearMap.coe_mk,\n      multilinear_map.to_linear_map_apply]\n  · rw [Basis.mk_coord_apply_eq, mul_one, update_eq_self]\n    congr\n  · rw [Basis.mk_coord_apply_ne hik, MulZeroClass.mul_zero, eq_comm]\n    exact e.det.map_eq_zero_of_eq _ (by simp [hik, Function.update_apply]) hik\n#align basis.det_smul_mk_coord_eq_det_update Basis.det_smul_mk_coord_eq_det_update\n-/\n\n",
 "det_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Multiplying a map by a scalar `c` multiplies its determinant by `c ^ dim M`. -/\n@[simp]\ntheorem det_smul {𝕜 : Type _} [Field 𝕜] {M : Type _} [AddCommGroup M] [Module 𝕜 M] (c : 𝕜) (f : «expr →ₗ[ ] » M 𝕜 M) :\n    LinearMap.det («expr • » c f) = c ^ FiniteDimensional.finrank 𝕜 M * LinearMap.det f :=\n  by\n  by_cases H : ∃ s : Finset M, Nonempty (Basis s 𝕜 M)\n  · have : FiniteDimensional 𝕜 M := by\n      rcases H with ⟨s, ⟨hs⟩⟩\n      exact FiniteDimensional.of_fintype_basis hs\n    simp only [← det_to_matrix (FiniteDimensional.finBasis 𝕜 M), LinearEquiv.map_smul, Fintype.card_fin, det_smul]\n  ·\n    classical\n      have : FiniteDimensional.finrank 𝕜 M = 0 := finrank_eq_zero_of_not_exists_basis H\n      simp [coe_det, H, this]\n#align det_smul det_smul\n\n",
 "det_self":
 "#print Basis.det_self /-\ntheorem Basis.det_self : e.det e = 1 := by simp [e.det_apply]\n#align basis.det_self Basis.det_self\n-/\n\n",
 "det_reindex_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Basis.det_reindex_symm /-\ntheorem Basis.det_reindex_symm {ι' : Type _} [Fintype ι'] [DecidableEq ι'] (b : Basis ι R M) (v : ι → M)\n    (e : «expr ≃ » ι' ι) : (b.reindex e.symm).det (v ∘ e) = b.det v := by\n  rw [Basis.det_reindex, function.comp.assoc, e.self_comp_symm, function.comp.right_id]\n#align basis.det_reindex_symm Basis.det_reindex_symm\n-/\n\n",
 "det_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Basis.det_reindex /-\ntheorem Basis.det_reindex {ι' : Type _} [Fintype ι'] [DecidableEq ι'] (b : Basis ι R M) (v : ι' → M)\n    (e : «expr ≃ » ι ι') : (b.reindex e).det v = b.det (v ∘ e) := by\n  rw [Basis.det_apply, Basis.toMatrix_reindex', det_reindex_alg_equiv, Basis.det_apply]\n#align basis.det_reindex Basis.det_reindex\n-/\n\n",
 "det_refl":
 "@[simp]\ntheorem det_refl : (LinearEquiv.refl R M).det = 1 :=\n  Units.ext <| LinearMap.det_id\n#align det_refl det_refl\n\n",
 "det_ne_zero":
 "#print Basis.det_ne_zero /-\n/-- `basis.det` is not the zero map. -/\ntheorem Basis.det_ne_zero [Nontrivial R] : e.det ≠ 0 := fun h => by simpa [h] using e.det_self\n#align basis.det_ne_zero Basis.det_ne_zero\n-/\n\n",
 "det_mul_det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearEquiv.det_mul_det_symm /-\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_mul_det_symm {A : Type _} [CommRing A] [Module A M] (f : «expr ≃ₗ[ ] » M A M) :\n    (f : «expr →ₗ[ ] » M A M).det * (f.symm : «expr →ₗ[ ] » M A M).det = 1 := by simp [← LinearMap.det_comp]\n#align linear_equiv.det_mul_det_symm LinearEquiv.det_mul_det_symm\n-/\n\n",
 "det_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Basis.det_map' /-\ntheorem Basis.det_map' (b : Basis ι R M) (f : «expr ≃ₗ[ ] » M R M') : (b.map f).det = b.det.comp_linear_map f.symm :=\n  AlternatingMap.ext <| b.det_map f\n#align basis.det_map' Basis.det_map'\n-/\n\n",
 "det_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Basis.det_map /-\n@[simp]\ntheorem Basis.det_map (b : Basis ι R M) (f : «expr ≃ₗ[ ] » M R M') (v : ι → M') :\n    (b.map f).det v = b.det (f.symm ∘ v) := by rw [Basis.det_apply, Basis.toMatrix_map, Basis.det_apply]\n#align basis.det_map Basis.det_map\n-/\n\n",
 "det_isUnitSMul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n#print Basis.det_isUnitSMul /-\n/-- The determinant of a basis constructed by `is_unit_smul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_isUnitSMul {w : ι → R} (hw : ∀ i, IsUnit (w i)) :\n    e.det (e.is_unit_smul hw) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  e.det_units_smul_self _\n#align basis.det_is_unit_smul Basis.det_isUnitSMul\n-/\n\n",
 "det_isEmpty":
 "#print Basis.det_isEmpty /-\n@[simp]\ntheorem Basis.det_isEmpty [IsEmpty ι] : e.det = AlternatingMap.constOfIsEmpty R M 1 :=\n  by\n  ext v\n  exact Matrix.det_isEmpty\n#align basis.det_is_empty Basis.det_isEmpty\n-/\n\n",
 "det_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_id : (LinearMap.id : «expr →ₗ[ ] » M A M).det = 1 :=\n  LinearMap.det.map_one\n#align det_id det_id\n\n",
 "det_eq_one_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_eq_one_of_subsingleton [subsingleton M] (f : «expr →ₗ[ ] » M R M) : (f : «expr →ₗ[ ] » M R M).det = 1 :=\n  by\n  have b : Basis (Fin 0) R M := Basis.empty M\n  rw [← f.det_to_matrix b]\n  exact Matrix.det_isEmpty\n#align det_eq_one_of_subsingleton det_eq_one_of_subsingleton\n\n",
 "det_eq_one_of_finrank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_eq_one_of_finrank_eq_zero {𝕜 : Type _} [Field 𝕜] {M : Type _} [AddCommGroup M] [Module 𝕜 M]\n    (h : FiniteDimensional.finrank 𝕜 M = 0) (f : «expr →ₗ[ ] » M 𝕜 M) : (f : «expr →ₗ[ ] » M 𝕜 M).det = 1 := by\n  classical\n    refine' @LinearMap.det_cases M _ 𝕜 _ _ _ (fun t => t = 1) f _ rfl\n    intro s b\n    have : IsEmpty s := by\n      rw [← Fintype.card_eq_zero_iff]\n      exact (FiniteDimensional.finrank_eq_card_basis b).symm.trans h\n    exact Matrix.det_isEmpty\n#align det_eq_one_of_finrank_eq_zero det_eq_one_of_finrank_eq_zero\n\n",
 "det_eq_det_to_matrix_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Auxiliary lemma, the `simp` normal form goes in the other direction\n-- (using `linear_map.det_to_matrix`)\ntheorem det_eq_det_to_matrix_of_finset [DecidableEq M] {s : Finset M} (b : Basis s A M) (f : «expr →ₗ[ ] » M A M) :\n    f.det = Matrix.det (LinearMap.toMatrix b b f) :=\n  by\n  have : ∃ s : Finset M, Nonempty (Basis s A M) := ⟨s, ⟨b⟩⟩\n  rw [LinearMap.coe_det, dif_pos, det_aux_def' _ b] <;> assumption\n#align det_eq_det_to_matrix_of_finset det_eq_det_to_matrix_of_finset\n\n",
 "det_conj_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If `M'` is a two-sided inverse for `M` (indexed differently), `det (M ⬝ N ⬝ M') = det N`.\n\nSee `matrix.det_conj` and `matrix.det_conj'` for the case when `M' = M⁻¹` or vice versa. -/\ntheorem det_conj_of_mul_eq_one [DecidableEq m] [DecidableEq n] {M : Matrix m n A} {M' : Matrix n m A} {N : Matrix n n A}\n    (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) : det (matrix.mul (matrix.mul M N) M') = det N := by\n  rw [← det_comm' hM'M hMM', ← Matrix.mul_assoc, hM'M, Matrix.one_mul]\n#align det_conj_of_mul_eq_one det_conj_of_mul_eq_one\n\n",
 "det_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Conjugating a linear equiv by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj (f : «expr ≃ₗ[ ] » M R M) (e : «expr ≃ₗ[ ] » M R M') : ((e.symm.trans f).trans e).det = f.det := by\n  rw [← Units.eq_iff, coe_det, coe_det, ← comp_coe, ← comp_coe, LinearMap.det_conj]\n#align det_conj det_conj\n\n",
 "det_comp_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Basis.det_comp_basis /-\n@[simp]\ntheorem Basis.det_comp_basis [Module A M'] (b : Basis ι A M) (b' : Basis ι A M') (f : «expr →ₗ[ ] » M A M') :\n    b'.det (f ∘ b) = LinearMap.det («expr ∘ₗ » f (b'.equiv b (Equiv.refl ι) : «expr →ₗ[ ] » M' A M)) :=\n  by\n  rw [Basis.det_apply, ← LinearMap.det_toMatrix b', LinearMap.toMatrix_comp _ b, Matrix.det_mul,\n    LinearMap.toMatrix_basis_equiv, Matrix.det_one, mul_one]\n  congr 1; ext (i j)\n  rw [Basis.toMatrix_apply, LinearMap.toMatrix_apply]\n#align basis.det_comp_basis Basis.det_comp_basis\n-/\n\n",
 "det_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Basis.det_comp /-\n@[simp]\ntheorem Basis.det_comp (e : Basis ι A M) (f : «expr →ₗ[ ] » M A M) (v : ι → M) : e.det (f ∘ v) = f.det * e.det v := by\n  rw [Basis.det_apply, Basis.det_apply, ← f.det_to_matrix e, ← Matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f ∘ v),\n    e.to_matrix_eq_to_matrix_constr v, ← to_matrix_comp, e.constr_comp]\n#align basis.det_comp Basis.det_comp\n-/\n\n",
 "det_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If there exists a two-sided inverse `M'` for `M` (indexed differently),\nthen `det (N ⬝ M) = det (M ⬝ N)`. -/\ntheorem det_comm' [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N : Matrix m n A} {M' : Matrix m n A}\n    (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) : det (matrix.mul M N) = det (matrix.mul N M) :=\n  by\n  nontriviality A\n  -- Although `m` and `n` are different a priori, we will show they have the same cardinality.\n  -- This turns the problem into one for square matrices, which is easy.\n  let e := index_equiv_of_inv hMM' hM'M\n  rw [← det_submatrix_equiv_self e, ← submatrix_mul_equiv _ _ _ (Equiv.refl n) _, det_comm, submatrix_mul_equiv,\n    Equiv.coe_refl, submatrix_id_id]\n#align det_comm' det_comm'\n\n",
 "det_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\ntheorem det_comm [DecidableEq n] (M N : Matrix n n A) : det (matrix.mul M N) = det (matrix.mul N M) := by\n  rw [det_mul, det_mul, mul_comm]\n#align det_comm det_comm\n\n",
 "det_coe_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearEquiv.det_coe_symm /-\n/-- The determinant of `f.symm` is the inverse of that of `f` when `f` is a linear equiv. -/\ntheorem LinearEquiv.det_coe_symm {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] (f : «expr ≃ₗ[ ] » M 𝕜 M) :\n    (f.symm : «expr →ₗ[ ] » M 𝕜 M).det = (f : «expr →ₗ[ ] » M 𝕜 M).det⁻¹ := by\n  field_simp [IsUnit.ne_zero f.is_unit_det']\n#align linear_equiv.det_coe_symm LinearEquiv.det_coe_symm\n-/\n\n",
 "det_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- To show `P f.det` it suffices to consider `P (to_matrix _ _ f).det` and `P 1`. -/\n@[elab_as_elim]\ntheorem det_cases [DecidableEq M] {P : A → Prop} (f : «expr →ₗ[ ] » M A M)\n    (hb : ∀ (s : Finset M) (b : Basis s A M), P (toMatrix b b f).det) (h1 : P 1) : P f.det :=\n  by\n  unfold LinearMap.det\n  split_ifs with h\n  · convert hb _ h.some_spec.some\n    apply det_aux_def'\n  · exact h1\n#align det_cases det_cases\n\n",
 "det_aux_id":
 "@[simp]\ntheorem det_aux_id (b : Trunc <| Basis ι A M) : LinearMap.detAux b LinearMap.id = 1 :=\n  (LinearMap.detAux b).map_one\n#align det_aux_id det_aux_id\n\n",
 "det_aux_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_aux_def' {ι' : Type _} [Fintype ι'] [DecidableEq ι'] (tb : Trunc <| Basis ι A M) (b' : Basis ι' A M)\n    (f : «expr →ₗ[ ] » M A M) : LinearMap.detAux tb f = Matrix.det (LinearMap.toMatrix b' b' f) :=\n  by\n  apply Trunc.induction_on tb\n  intro b\n  rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']\n#align det_aux_def' det_aux_def'\n\n",
 "det_aux_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Unfold lemma for `det_aux`.\n\nSee also `det_aux_def'` which allows you to vary the basis.\n-/\ntheorem det_aux_def (b : Basis ι A M) (f : «expr →ₗ[ ] » M A M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f) :=\n  by\n  rw [det_aux]\n  rfl\n#align det_aux_def det_aux_def\n\n",
 "det_aux_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_aux_comp (b : Trunc <| Basis ι A M) (f g : «expr →ₗ[ ] » M A M) :\n    LinearMap.detAux b (f.comp g) = LinearMap.detAux b f * LinearMap.detAux b g :=\n  (LinearMap.detAux b).map_mul f g\n#align det_aux_comp det_aux_comp\n\n",
 "det_apply":
 "#print Basis.det_apply /-\ntheorem Basis.det_apply (v : ι → M) : e.det v = det (e.to_matrix v) :=\n  rfl\n#align basis.det_apply Basis.det_apply\n-/\n\n",
 "coe_ofIsUnitDet":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearEquiv.coe_ofIsUnitDet /-\n@[simp]\ntheorem LinearEquiv.coe_ofIsUnitDet {f : «expr →ₗ[ ] » M R M'} {v : Basis ι R M} {v' : Basis ι R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : (LinearEquiv.ofIsUnitDet h : «expr →ₗ[ ] » M R M') = f :=\n  by\n  ext x\n  rfl\n#align linear_equiv.coe_of_is_unit_det LinearEquiv.coe_ofIsUnitDet\n-/\n\n",
 "coe_inv_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_inv_det (f : «expr ≃ₗ[ ] » M R M) : ↑f.det⁻¹ = LinearMap.det (f.symm : «expr →ₗ[ ] » M R M) :=\n  rfl\n#align coe_inv_det coe_inv_det\n\n",
 "coe_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_det (f : «expr ≃ₗ[ ] » M R M) : ↑f.det = LinearMap.det (f : «expr →ₗ[ ] » M R M) :=\n  rfl\n#align coe_det coe_det\n\n",
 "bot_lt_ker_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If the determinant of a map vanishes, then the map is not injective. -/\ntheorem bot_lt_ker_of_det_eq_zero {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] {f : «expr →ₗ[ ] » M 𝕜 M} (hf : f.det = 0) :\n    «expr⊥» < f.ker :=\n  by\n  have : FiniteDimensional 𝕜 M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [bot_lt_iff_ne_bot, Classical.not_not, ← is_unit_iff_ker_eq_bot] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align bot_lt_ker_of_det_eq_zero bot_lt_ker_of_det_eq_zero\n\n",
 "basisFun_det":
 "#print Pi.basisFun_det /-\n@[simp]\ntheorem Pi.basisFun_det : (Pi.basisFun R ι).det = Matrix.detRowAlternating :=\n  by\n  ext M\n  rw [Basis.det_apply, Basis.coePiBasisFun.toMatrix_eq_transpose, det_transpose]\n#align pi.basis_fun_det Pi.basisFun_det\n-/\n\n",
 "associated_det_of_eq_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.associated_det_of_eq_comp /-\ntheorem LinearMap.associated_det_of_eq_comp (e : «expr ≃ₗ[ ] » M R M) (f f' : «expr →ₗ[ ] » M R M)\n    (h : ∀ x, f x = f' (e x)) : Associated f.det f'.det :=\n  by\n  suffices Associated («expr ∘ₗ » f' ↑e).det f'.det\n    by\n    convert this using 2\n    ext x\n    exact h x\n  rw [← mul_one f'.det, LinearMap.det_comp]\n  exact Associated.mul_left _ (associated_one_iff_is_unit.mpr e.is_unit_det')\n#align linear_map.associated_det_of_eq_comp LinearMap.associated_det_of_eq_comp\n-/\n\n",
 "associated_det_comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n#print LinearMap.associated_det_comp_equiv /-\ntheorem LinearMap.associated_det_comp_equiv {N : Type _} [AddCommGroup N] [Module R N] (f : «expr →ₗ[ ] » N R M)\n    (e e' : «expr ≃ₗ[ ] » M R N) : Associated («expr ∘ₗ » f ↑e).det («expr ∘ₗ » f ↑e').det :=\n  by\n  refine' LinearMap.associated_det_of_eq_comp (e.trans e'.symm) _ _ _\n  intro x\n  simp only [LinearMap.comp_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply, LinearEquiv.apply_symm_apply]\n#align linear_map.associated_det_comp_equiv LinearMap.associated_det_comp_equiv\n-/\n\n"}