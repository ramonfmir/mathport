{"range_lt_top_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the determinant of a map vanishes, then the map is not onto. -/\ntheorem range_lt_top_of_det_eq_zero {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] {f : «expr →ₗ[ ] » M 𝕜 M} (hf : f.det = 0) :\n    f.range < «expr⊤» :=\n  by\n  have : finite_dimensional 𝕜 M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [lt_top_iff_ne_top, not_not, ← is_unit_iff_range_eq_top] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align range_lt_top_of_det_eq_zero range_lt_top_of_det_eq_zero\n\n",
 "map_basis_ne_zero_iff":
 "theorem alternating_map.map_basis_ne_zero_iff {ι : Type _} [decidable_eq ι] [Finite ι] (e : basis ι R M)\n    (f : alternating_map R M R ι) : f e ≠ 0 ↔ f ≠ 0 :=\n  not_congr <| f.map_basis_eq_zero_iff e\n#align alternating_map.map_basis_ne_zero_iff alternating_map.map_basis_ne_zero_iff\n\n",
 "map_basis_eq_zero_iff":
 "@[simp]\ntheorem alternating_map.map_basis_eq_zero_iff {ι : Type _} [decidable_eq ι] [Finite ι] (e : basis ι R M)\n    (f : alternating_map R M R ι) : f e = 0 ↔ f = 0 :=\n  ⟨fun h => by\n    cases nonempty_fintype ι\n    simpa [h] using f.eq_smul_basis_det e, fun h => h.symm ▸ alternating_map.zero_apply _⟩\n#align alternating_map.map_basis_eq_zero_iff alternating_map.map_basis_eq_zero_iff\n\n",
 "is_unit_det'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Specialization of `linear_equiv.is_unit_det` -/\ntheorem linear_equiv.is_unit_det' {A : Type _} [CommRing A] [Module A M] (f : «expr ≃ₗ[ ] » M A M) :\n    is_unit (linear_map.det (f : «expr →ₗ[ ] » M A M)) :=\n  isUnit_of_mul_eq_one _ _ f.det_mul_det_symm\n#align linear_equiv.is_unit_det' linear_equiv.is_unit_det'\n\n",
 "is_unit_det":
 "theorem basis.is_unit_det (e' : basis ι R M) : is_unit (e.det e') :=\n  (is_basis_iff_det e).mp ⟨e'.linear_independent, e'.span_eq⟩\n#align basis.is_unit_det basis.is_unit_det\n\n",
 "is_basis_iff_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_basis_iff_det {v : ι → M} : linear_independent R v ∧ span R (Set.range v) = «expr⊤» ↔ is_unit (e.det v) :=\n  by\n  constructor\n  · rintro ⟨hli, hspan⟩\n    set v' := basis.mk hli hspan.ge with v'_eq\n    rw [e.det_apply]\n    convert linear_equiv.is_unit_det (linear_equiv.refl _ _) v' e using 2\n    ext (i j)\n    simp\n  · intro h\n    rw [basis.det_apply, basis.to_matrix_eq_to_matrix_constr] at h\n    set v' := basis.map e (linear_equiv.of_is_unit_det h) with v'_def\n    have : «expr⇑ » v' = v := by\n      ext i\n      rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis]\n    rw [← this]\n    exact ⟨v'.linear_independent, v'.span_eq⟩\n#align is_basis_iff_det is_basis_iff_det\n\n",
 "finite_dimensional_of_det_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem finite_dimensional_of_det_ne_one {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] (f : «expr →ₗ[ ] » M 𝕜 M)\n    (hf : f.det ≠ 1) : finite_dimensional 𝕜 M :=\n  by\n  by_cases H : ∃ s : Finset M, nonempty (basis s 𝕜 M)\n  · rcases H with ⟨s, ⟨hs⟩⟩\n    exact finite_dimensional.of_fintype_basis hs\n  ·\n    classical\n      simp [linear_map.coe_det, H] at hf\n      exact hf.elim\n#align finite_dimensional_of_det_ne_one finite_dimensional_of_det_ne_one\n\n",
 "eq_smul_basis_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any alternating map to `R` where `ι` has the cardinality of a basis equals the determinant\nmap with respect to that basis, multiplied by the value of that alternating map on that basis. -/\ntheorem alternating_map.eq_smul_basis_det (f : alternating_map R M R ι) : f = «expr • » (f e) e.det :=\n  by\n  refine' basis.ext_alternating e fun i h => _\n  let σ : equiv.perm ι := Equiv.ofBijective i (finite.injective_iff_bijective.1 h)\n  change f (e ∘ σ) = («expr • » (f e) e.det) (e ∘ σ)\n  simp [alternating_map.map_perm, basis.det_self]\n#align alternating_map.eq_smul_basis_det alternating_map.eq_smul_basis_det\n\n",
 "det_zero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_zero' {ι : Type _} [Finite ι] [nonempty ι] (b : basis ι A M) :\n    linear_map.det (0 : «expr →ₗ[ ] » M A M) = 0 :=\n  by\n  haveI := classical.dec_eq ι\n  cases nonempty_fintype ι\n  rwa [← det_to_matrix b, linear_equiv.map_zero, det_zero]\n#align det_zero' det_zero'\n\n",
 "det_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`,\nand `0` otherwise. We give a formula that also works in infinite dimension, where we define\nthe determinant to be `1`. -/\n@[simp]\ntheorem det_zero {𝕜 : Type _} [Field 𝕜] {M : Type _} [add_comm_group M] [Module 𝕜 M] :\n    linear_map.det (0 : «expr →ₗ[ ] » M 𝕜 M) = (0 : 𝕜) ^ finite_dimensional.finrank 𝕜 M := by\n  simp only [← zero_smul 𝕜 (1 : «expr →ₗ[ ] » M 𝕜 M), det_smul, mul_one, MonoidHom.map_one]\n#align det_zero det_zero\n\n",
 "det_units_smul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- The determinant of a basis constructed by `units_smul` is the product of the given units. -/\n@[simp]\ntheorem basis.det_units_smul_self (w : ι → «expr ˣ» R) :\n    e.det (e.units_smul w) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  by simp [basis.det_apply]\n#align basis.det_units_smul_self basis.det_units_smul_self\n\n",
 "det_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- If a basis is multiplied columnwise by scalars `w : ι → Rˣ`, then the determinant with respect\nto this basis is multiplied by the product of the inverse of these scalars. -/\ntheorem basis.det_units_smul (e : basis ι R M) (w : ι → «expr ˣ» R) :\n    (e.units_smul w).det =\n      «expr • »\n        (↑(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))⁻¹ :\n          R)\n        e.det :=\n  by\n  ext f\n  change\n    (matrix.det fun i j => (e.units_smul w).repr (f j) i) =\n      «expr • »\n        (↑(finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (w i))⁻¹ :\n          R)\n        (matrix.det fun i j => e.repr (f j) i)\n  simp only [e.repr_units_smul]\n  convert matrix.det_mul_column (fun i => (↑(w i)⁻¹ : R)) fun i j => e.repr (f j) i\n  simp [← finset.prod_inv_distrib]\n#align basis.det_units_smul basis.det_units_smul\n\n",
 "det_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem det_trans (f g : «expr ≃ₗ[ ] » M R M) : (f.trans g).det = g.det * f.det :=\n  map_mul _ g f\n#align det_trans det_trans\n\n",
 "det_to_matrix_eq_det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The determinant of `linear_map.to_matrix` does not depend on the choice of basis. -/\ntheorem det_to_matrix_eq_det_to_matrix [decidable_eq κ] (b : basis ι A M) (c : basis κ A M) (f : «expr →ₗ[ ] » M A M) :\n    det (linear_map.to_matrix b b f) = det (linear_map.to_matrix c c f) := by\n  rw [← linear_map_to_matrix_mul_basis_to_matrix c b c, ← basis_to_matrix_mul_linear_map_to_matrix b c b,\n      matrix.det_conj_of_mul_eq_one] <;>\n    rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]\n#align det_to_matrix_eq_det_to_matrix det_to_matrix_eq_det_to_matrix\n\n",
 "det_to_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_to_matrix' {ι : Type _} [fintype ι] [decidable_eq ι] (f : «expr →ₗ[ ] » (ι → A) A (ι → A)) :\n    det f.to_matrix' = f.det := by simp [← to_matrix_eq_to_matrix']\n#align det_to_matrix' det_to_matrix'\n\n",
 "det_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_to_matrix (b : basis ι A M) (f : «expr →ₗ[ ] » M A M) : matrix.det (to_matrix b b f) = f.det :=\n  by\n  haveI := classical.dec_eq M\n  rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b]\n#align det_to_matrix det_to_matrix\n\n",
 "det_to_lin'":
 "@[simp]\ntheorem det_to_lin' (f : matrix ι ι R) : linear_map.det f.to_lin' = f.det := by\n  simp only [← to_lin_eq_to_lin', det_to_lin]\n#align det_to_lin' det_to_lin'\n\n",
 "det_to_lin":
 "@[simp]\ntheorem det_to_lin (b : basis ι R M) (f : matrix ι ι R) : linear_map.det (matrix.to_lin b b f) = f.det := by\n  rw [← linear_map.det_to_matrix b, linear_map.to_matrix_to_lin]\n#align det_to_lin det_to_lin\n\n",
 "det_symm_mul_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem linear_equiv.det_symm_mul_det {A : Type _} [CommRing A] [Module A M] (f : «expr ≃ₗ[ ] » M A M) :\n    (f.symm : «expr →ₗ[ ] » M A M).det * (f : «expr →ₗ[ ] » M A M).det = 1 := by simp [← linear_map.det_comp]\n#align linear_equiv.det_symm_mul_det linear_equiv.det_symm_mul_det\n\n",
 "det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem det_symm (f : «expr ≃ₗ[ ] » M R M) : f.symm.det = f.det⁻¹ :=\n  map_inv _ f\n#align det_symm det_symm\n\n",
 "det_smul_mk_coord_eq_det_update":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If we fix a background basis `e`, then for any other basis `v`, we can characterise the\ncoordinates provided by `v` in terms of determinants relative to `e`. -/\ntheorem basis.det_smul_mk_coord_eq_det_update {v : ι → M} (hli : linear_independent R v)\n    (hsp : «expr⊤» ≤ span R (range v)) (i : ι) :\n    «expr • » (e.det v) ((basis.mk hli hsp).coord i) = e.det.to_multilinear_map.to_linear_map v i :=\n  by\n  apply (basis.mk hli hsp).ext\n  intro k\n  rcases eq_or_ne k i with (rfl | hik) <;>\n    simp only [algebra.id.smul_eq_mul, basis.coe_mk, linear_map.smul_apply, linear_map.coe_mk,\n      multilinear_map.to_linear_map_apply]\n  · rw [basis.mk_coord_apply_eq, mul_one, update_eq_self]\n    congr\n  · rw [basis.mk_coord_apply_ne hik, mul_zero, eq_comm]\n    exact e.det.map_eq_zero_of_eq _ (by simp [hik, function.update_apply]) hik\n#align basis.det_smul_mk_coord_eq_det_update basis.det_smul_mk_coord_eq_det_update\n\n",
 "det_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Multiplying a map by a scalar `c` multiplies its determinant by `c ^ dim M`. -/\n@[simp]\ntheorem det_smul {𝕜 : Type _} [Field 𝕜] {M : Type _} [add_comm_group M] [Module 𝕜 M] (c : 𝕜) (f : «expr →ₗ[ ] » M 𝕜 M) :\n    linear_map.det («expr • » c f) = c ^ finite_dimensional.finrank 𝕜 M * linear_map.det f :=\n  by\n  by_cases H : ∃ s : Finset M, nonempty (basis s 𝕜 M)\n  · have : finite_dimensional 𝕜 M := by\n      rcases H with ⟨s, ⟨hs⟩⟩\n      exact finite_dimensional.of_fintype_basis hs\n    simp only [← det_to_matrix (finite_dimensional.fin_basis 𝕜 M), linear_equiv.map_smul, fintype.card_fin, det_smul]\n  ·\n    classical\n      have : finite_dimensional.finrank 𝕜 M = 0 := finrank_eq_zero_of_not_exists_basis H\n      simp [coe_det, H, this]\n#align det_smul det_smul\n\n",
 "det_self":
 "theorem basis.det_self : e.det e = 1 := by simp [e.det_apply]\n#align basis.det_self basis.det_self\n\n",
 "det_reindex_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem basis.det_reindex_symm {ι' : Type _} [fintype ι'] [decidable_eq ι'] (b : basis ι R M) (v : ι → M)\n    (e : «expr ≃ » ι' ι) : (b.reindex e.symm).det (v ∘ e) = b.det v := by\n  rw [basis.det_reindex, function.comp.assoc, e.self_comp_symm, function.comp.right_id]\n#align basis.det_reindex_symm basis.det_reindex_symm\n\n",
 "det_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem basis.det_reindex {ι' : Type _} [fintype ι'] [decidable_eq ι'] (b : basis ι R M) (v : ι' → M)\n    (e : «expr ≃ » ι ι') : (b.reindex e).det v = b.det (v ∘ e) := by\n  rw [basis.det_apply, basis.to_matrix_reindex', det_reindex_alg_equiv, basis.det_apply]\n#align basis.det_reindex basis.det_reindex\n\n",
 "det_refl":
 "@[simp]\ntheorem det_refl : (linear_equiv.refl R M).det = 1 :=\n  Units.ext <| linear_map.det_id\n#align det_refl det_refl\n\n",
 "det_ne_zero":
 "/-- `basis.det` is not the zero map. -/\ntheorem basis.det_ne_zero [nontrivial R] : e.det ≠ 0 := fun h => by simpa [h] using e.det_self\n#align basis.det_ne_zero basis.det_ne_zero\n\n",
 "det_mul_det_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The determinants of a `linear_equiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem linear_equiv.det_mul_det_symm {A : Type _} [CommRing A] [Module A M] (f : «expr ≃ₗ[ ] » M A M) :\n    (f : «expr →ₗ[ ] » M A M).det * (f.symm : «expr →ₗ[ ] » M A M).det = 1 := by simp [← linear_map.det_comp]\n#align linear_equiv.det_mul_det_symm linear_equiv.det_mul_det_symm\n\n",
 "det_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem basis.det_map' (b : basis ι R M) (f : «expr ≃ₗ[ ] » M R M') : (b.map f).det = b.det.comp_linear_map f.symm :=\n  alternating_map.ext <| b.det_map f\n#align basis.det_map' basis.det_map'\n\n",
 "det_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem basis.det_map (b : basis ι R M) (f : «expr ≃ₗ[ ] » M R M') (v : ι → M') :\n    (b.map f).det v = b.det (f.symm ∘ v) := by rw [basis.det_apply, basis.to_matrix_map, basis.det_apply]\n#align basis.det_map basis.det_map\n\n",
 "det_is_unit_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- The determinant of a basis constructed by `is_unit_smul` is the product of the given units. -/\n@[simp]\ntheorem basis.det_is_unit_smul {w : ι → R} (hw : ∀ i, is_unit (w i)) :\n    e.det (e.is_unit_smul hw) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (w i) :=\n  e.det_units_smul_self _\n#align basis.det_is_unit_smul basis.det_is_unit_smul\n\n",
 "det_is_empty":
 "@[simp]\ntheorem basis.det_is_empty [is_empty ι] : e.det = alternating_map.const_of_is_empty R M 1 :=\n  by\n  ext v\n  exact matrix.det_is_empty\n#align basis.det_is_empty basis.det_is_empty\n\n",
 "det_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_id : (linear_map.id : «expr →ₗ[ ] » M A M).det = 1 :=\n  linear_map.det.map_one\n#align det_id det_id\n\n",
 "det_eq_one_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_eq_one_of_subsingleton [subsingleton M] (f : «expr →ₗ[ ] » M R M) : (f : «expr →ₗ[ ] » M R M).det = 1 :=\n  by\n  have b : basis (fin 0) R M := basis.empty M\n  rw [← f.det_to_matrix b]\n  exact matrix.det_is_empty\n#align det_eq_one_of_subsingleton det_eq_one_of_subsingleton\n\n",
 "det_eq_one_of_finrank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_eq_one_of_finrank_eq_zero {𝕜 : Type _} [Field 𝕜] {M : Type _} [add_comm_group M] [Module 𝕜 M]\n    (h : finite_dimensional.finrank 𝕜 M = 0) (f : «expr →ₗ[ ] » M 𝕜 M) : (f : «expr →ₗ[ ] » M 𝕜 M).det = 1 := by\n  classical\n    refine' @linear_map.det_cases M _ 𝕜 _ _ _ (fun t => t = 1) f _ rfl\n    intro s b\n    have : is_empty s := by\n      rw [← fintype.card_eq_zero_iff]\n      exact (finite_dimensional.finrank_eq_card_basis b).symm.trans h\n    exact matrix.det_is_empty\n#align det_eq_one_of_finrank_eq_zero det_eq_one_of_finrank_eq_zero\n\n",
 "det_eq_det_to_matrix_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Auxiliary lemma, the `simp` normal form goes in the other direction\n-- (using `linear_map.det_to_matrix`)\ntheorem det_eq_det_to_matrix_of_finset [decidable_eq M] {s : Finset M} (b : basis s A M) (f : «expr →ₗ[ ] » M A M) :\n    f.det = matrix.det (linear_map.to_matrix b b f) :=\n  by\n  have : ∃ s : Finset M, nonempty (basis s A M) := ⟨s, ⟨b⟩⟩\n  rw [linear_map.coe_det, dif_pos, det_aux_def' _ b] <;> assumption\n#align det_eq_det_to_matrix_of_finset det_eq_det_to_matrix_of_finset\n\n",
 "det_conj_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If `M'` is a two-sided inverse for `M` (indexed differently), `det (M ⬝ N ⬝ M') = det N`.\n\nSee `matrix.det_conj` and `matrix.det_conj'` for the case when `M' = M⁻¹` or vice versa. -/\ntheorem det_conj_of_mul_eq_one [decidable_eq m] [decidable_eq n] {M : matrix m n A} {M' : matrix n m A}\n    {N : matrix n n A} (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) :\n    det (matrix.mul (matrix.mul M N) M') = det N := by\n  rw [← det_comm' hM'M hMM', ← matrix.mul_assoc, hM'M, matrix.one_mul]\n#align det_conj_of_mul_eq_one det_conj_of_mul_eq_one\n\n",
 "det_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Conjugating a linear equiv by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj (f : «expr ≃ₗ[ ] » M R M) (e : «expr ≃ₗ[ ] » M R M') : ((e.symm.trans f).trans e).det = f.det := by\n  rw [← Units.eq_iff, coe_det, coe_det, ← comp_coe, ← comp_coe, linear_map.det_conj]\n#align det_conj det_conj\n\n",
 "det_comp_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem basis.det_comp_basis [Module A M'] (b : basis ι A M) (b' : basis ι A M') (f : «expr →ₗ[ ] » M A M') :\n    b'.det (f ∘ b) = linear_map.det («expr ∘ₗ » f (b'.equiv b (equiv.refl ι) : «expr →ₗ[ ] » M' A M)) :=\n  by\n  rw [basis.det_apply, ← linear_map.det_to_matrix b', linear_map.to_matrix_comp _ b, matrix.det_mul,\n    linear_map.to_matrix_basis_equiv, matrix.det_one, mul_one]\n  congr 1; ext (i j)\n  rw [basis.to_matrix_apply, linear_map.to_matrix_apply]\n#align basis.det_comp_basis basis.det_comp_basis\n\n",
 "det_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem basis.det_comp (e : basis ι A M) (f : «expr →ₗ[ ] » M A M) (v : ι → M) : e.det (f ∘ v) = f.det * e.det v := by\n  rw [basis.det_apply, basis.det_apply, ← f.det_to_matrix e, ← matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f ∘ v),\n    e.to_matrix_eq_to_matrix_constr v, ← to_matrix_comp, e.constr_comp]\n#align basis.det_comp basis.det_comp\n\n",
 "det_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If there exists a two-sided inverse `M'` for `M` (indexed differently),\nthen `det (N ⬝ M) = det (M ⬝ N)`. -/\ntheorem det_comm' [decidable_eq m] [decidable_eq n] {M : matrix n m A} {N : matrix m n A} {M' : matrix m n A}\n    (hMM' : matrix.mul M M' = 1) (hM'M : matrix.mul M' M = 1) : det (matrix.mul M N) = det (matrix.mul N M) :=\n  by\n  nontriviality A\n  -- Although `m` and `n` are different a priori, we will show they have the same cardinality.\n  -- This turns the problem into one for square matrices, which is easy.\n  let e := index_equiv_of_inv hMM' hM'M\n  rw [← det_submatrix_equiv_self e, ← submatrix_mul_equiv _ _ _ (equiv.refl n) _, det_comm, submatrix_mul_equiv,\n    equiv.coe_refl, submatrix_id_id]\n#align det_comm' det_comm'\n\n",
 "det_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\ntheorem det_comm [decidable_eq n] (M N : matrix n n A) : det (matrix.mul M N) = det (matrix.mul N M) := by\n  rw [det_mul, det_mul, mul_comm]\n#align det_comm det_comm\n\n",
 "det_coe_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The determinant of `f.symm` is the inverse of that of `f` when `f` is a linear equiv. -/\ntheorem linear_equiv.det_coe_symm {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] (f : «expr ≃ₗ[ ] » M 𝕜 M) :\n    (f.symm : «expr →ₗ[ ] » M 𝕜 M).det = (f : «expr →ₗ[ ] » M 𝕜 M).det⁻¹ := by\n  field_simp [IsUnit.ne_zero f.is_unit_det']\n#align linear_equiv.det_coe_symm linear_equiv.det_coe_symm\n\n",
 "det_cases":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- To show `P f.det` it suffices to consider `P (to_matrix _ _ f).det` and `P 1`. -/\n@[elab_as_elim]\ntheorem det_cases [decidable_eq M] {P : A → Prop} (f : «expr →ₗ[ ] » M A M)\n    (hb : ∀ (s : Finset M) (b : basis s A M), P (to_matrix b b f).det) (h1 : P 1) : P f.det :=\n  by\n  unfold linear_map.det\n  split_ifs with h\n  · convert hb _ h.some_spec.some\n    apply det_aux_def'\n  · exact h1\n#align det_cases det_cases\n\n",
 "det_aux_id":
 "@[simp]\ntheorem det_aux_id (b : trunc <| basis ι A M) : linear_map.det_aux b linear_map.id = 1 :=\n  (linear_map.det_aux b).map_one\n#align det_aux_id det_aux_id\n\n",
 "det_aux_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem det_aux_def' {ι' : Type _} [fintype ι'] [decidable_eq ι'] (tb : trunc <| basis ι A M) (b' : basis ι' A M)\n    (f : «expr →ₗ[ ] » M A M) : linear_map.det_aux tb f = matrix.det (linear_map.to_matrix b' b' f) :=\n  by\n  apply trunc.induction_on tb\n  intro b\n  rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']\n#align det_aux_def' det_aux_def'\n\n",
 "det_aux_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Unfold lemma for `det_aux`.\n\nSee also `det_aux_def'` which allows you to vary the basis.\n-/\ntheorem det_aux_def (b : basis ι A M) (f : «expr →ₗ[ ] » M A M) :\n    linear_map.det_aux (trunc.mk b) f = matrix.det (linear_map.to_matrix b b f) :=\n  by\n  rw [det_aux]\n  rfl\n#align det_aux_def det_aux_def\n\n",
 "det_aux_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem det_aux_comp (b : trunc <| basis ι A M) (f g : «expr →ₗ[ ] » M A M) :\n    linear_map.det_aux b (f.comp g) = linear_map.det_aux b f * linear_map.det_aux b g :=\n  (linear_map.det_aux b).map_mul f g\n#align det_aux_comp det_aux_comp\n\n",
 "det_apply":
 "theorem basis.det_apply (v : ι → M) : e.det v = det (e.to_matrix v) :=\n  rfl\n#align basis.det_apply basis.det_apply\n\n",
 "coe_of_is_unit_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv.coe_of_is_unit_det {f : «expr →ₗ[ ] » M R M'} {v : basis ι R M} {v' : basis ι R M'}\n    (h : is_unit (linear_map.to_matrix v v' f).det) : (linear_equiv.of_is_unit_det h : «expr →ₗ[ ] » M R M') = f :=\n  by\n  ext x\n  rfl\n#align linear_equiv.coe_of_is_unit_det linear_equiv.coe_of_is_unit_det\n\n",
 "coe_inv_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_inv_det (f : «expr ≃ₗ[ ] » M R M) : ↑f.det⁻¹ = linear_map.det (f.symm : «expr →ₗ[ ] » M R M) :=\n  rfl\n#align coe_inv_det coe_inv_det\n\n",
 "coe_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_det (f : «expr ≃ₗ[ ] » M R M) : ↑f.det = linear_map.det (f : «expr →ₗ[ ] » M R M) :=\n  rfl\n#align coe_det coe_det\n\n",
 "bot_lt_ker_of_det_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If the determinant of a map vanishes, then the map is not injective. -/\ntheorem bot_lt_ker_of_det_eq_zero {𝕜 : Type _} [Field 𝕜] [Module 𝕜 M] {f : «expr →ₗ[ ] » M 𝕜 M} (hf : f.det = 0) :\n    «expr⊥» < f.ker :=\n  by\n  have : finite_dimensional 𝕜 M := by simp [f.finite_dimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [bot_lt_iff_ne_bot, not_not, ← is_unit_iff_ker_eq_bot] at hf\n  exact isUnit_iff_ne_zero.1 (f.is_unit_det hf)\n#align bot_lt_ker_of_det_eq_zero bot_lt_ker_of_det_eq_zero\n\n",
 "basis_fun_det":
 "@[simp]\ntheorem pi.basis_fun_det : (pi.basis_fun R ι).det = matrix.det_row_alternating :=\n  by\n  ext M\n  rw [basis.det_apply, basis.coe_pi_basis_fun.to_matrix_eq_transpose, det_transpose]\n#align pi.basis_fun_det pi.basis_fun_det\n\n",
 "associated_det_of_eq_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.associated_det_of_eq_comp (e : «expr ≃ₗ[ ] » M R M) (f f' : «expr →ₗ[ ] » M R M)\n    (h : ∀ x, f x = f' (e x)) : Associated f.det f'.det :=\n  by\n  suffices Associated («expr ∘ₗ » f' ↑e).det f'.det\n    by\n    convert this using 2\n    ext x\n    exact h x\n  rw [← mul_one f'.det, linear_map.det_comp]\n  exact Associated.mul_left _ (associated_one_iff_is_unit.mpr e.is_unit_det')\n#align linear_map.associated_det_of_eq_comp linear_map.associated_det_of_eq_comp\n\n",
 "associated_det_comp_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem linear_map.associated_det_comp_equiv {N : Type _} [add_comm_group N] [Module R N] (f : «expr →ₗ[ ] » N R M)\n    (e e' : «expr ≃ₗ[ ] » M R N) : Associated («expr ∘ₗ » f ↑e).det («expr ∘ₗ » f ↑e').det :=\n  by\n  refine' linear_map.associated_det_of_eq_comp (e.trans e'.symm) _ _ _\n  intro x\n  simp only [linear_map.comp_apply, linear_equiv.coe_coe, linear_equiv.trans_apply, linear_equiv.apply_symm_apply]\n#align linear_map.associated_det_comp_equiv linear_map.associated_det_comp_equiv\n\n"}