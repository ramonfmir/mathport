{"ι_range_disjoint_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The generators of the tensor algebra are disjoint from its scalars. -/\ntheorem ι_range_disjoint_one :\n    Disjoint (LinearMap.range (ι R : «expr →ₗ[ ] » M R (tensor_algebra R M))) (1 : Submodule R (tensor_algebra R M)) :=\n  by\n  rw [Submodule.disjoint_def]\n  rintro _ ⟨x, hx⟩ ⟨r, rfl : algebraMap _ _ _ = _⟩\n  rw [ι_eq_algebra_map_iff x] at hx\n  rw [hx.2, RingHom.map_zero]\n#align ι_range_disjoint_one ι_range_disjoint_one\n\n",
 "ι_ne_one":
 "@[simp]\ntheorem ι_ne_one [Nontrivial R] (x : M) : ι R x ≠ 1 :=\n  by\n  rw [← (algebraMap R (tensor_algebra R M)).map_one, ne.def, ι_eq_algebra_map_iff]\n  exact one_ne_zero ∘ And.right\n#align ι_ne_one ι_ne_one\n\n",
 "ι_left_inverse":
 "theorem ι_left_inverse : function.left_inverse ι_inv (ι R : M → tensor_algebra R M) := fun x => by simp [ι_inv]\n#align ι_left_inverse ι_left_inverse\n\n",
 "ι_inj":
 "@[simp]\ntheorem ι_inj (x y : M) : ι R x = ι R y ↔ x = y :=\n  ι_left_inverse.injective.eq_iff\n#align ι_inj ι_inj\n\n",
 "ι_eq_zero_iff":
 "@[simp]\ntheorem ι_eq_zero_iff (x : M) : ι R x = 0 ↔ x = 0 := by rw [← ι_inj R x 0, LinearMap.map_zero]\n#align ι_eq_zero_iff ι_eq_zero_iff\n\n",
 "ι_eq_algebra_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem ι_eq_algebra_map_iff (x : M) (r : R) : ι R x = algebraMap R _ r ↔ x = 0 ∧ r = 0 :=\n  by\n  refine' ⟨fun h => _, _⟩\n  · letI : Module («expr ᵐᵒᵖ» R) M := Module.compHom _ ((RingHom.id R).from_opposite mul_comm)\n    haveI : IsCentralScalar R M := ⟨fun r m => rfl⟩\n    have hf0 : to_triv_sq_zero_ext (ι R x) = (0, x) := lift_ι_apply _ _\n    rw [h, AlgHom.commutes] at hf0\n    have : r = 0 ∧ 0 = x := Prod.ext_iff.1 hf0\n    exact this.symm.imp_left Eq.symm\n  · rintro ⟨rfl, rfl⟩\n    rw [LinearMap.map_zero, RingHom.map_zero]\n#align ι_eq_algebra_map_iff ι_eq_algebra_map_iff\n\n",
 "ι_comp_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem ι_comp_lift {A : Type _} [Semiring A] [Algebra R A] (f : «expr →ₗ[ ] » M R A) :\n    (lift R f).to_linear_map.comp (ι R) = f :=\n  by\n  convert(lift R).symm_apply_apply f\n  simp only [lift, Equiv.coe_fn_symm_mk]\n#align ι_comp_lift ι_comp_lift\n\n",
 "tprod_apply":
 "@[simp]\ntheorem tprod_apply {n : ℕ} (x : Fin n → M) : tprod R M n x = (List.ofFn fun i => ι R (x i)).prod :=\n  rfl\n#align tprod_apply tprod_apply\n\n",
 "to_triv_sq_zero_ext_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵐᵒᵖ» -/\n@[simp]\ntheorem to_triv_sq_zero_ext_ι (x : M) [Module («expr ᵐᵒᵖ» R) M] [IsCentralScalar R M] :\n    to_triv_sq_zero_ext (ι R x) = TrivSqZeroExt.inr x :=\n  lift_ι_apply _ _\n#align to_triv_sq_zero_ext_ι to_triv_sq_zero_ext_ι\n\n",
 "to_tensor_ι":
 "@[simp]\ntheorem to_tensor_ι (m : M) : (FreeAlgebra.ι R m).to_tensor = tensor_algebra.ι R m := by simp [to_tensor]\n#align to_tensor_ι to_tensor_ι\n\n",
 "ring_quot_mk_alg_hom_free_algebra_ι_eq_ι":
 "/-\nCopyright (c) 2020 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\n-- force `ι` to be linear\ntheorem ring_quot_mk_alg_hom_free_algebra_ι_eq_ι (m : M) : RingQuot.mkAlgHom R (rel R M) (FreeAlgebra.ι R m) = ι R m :=\n  by\n  rw [ι]\n  rfl\n#align ring_quot_mk_alg_hom_free_algebra_ι_eq_ι ring_quot_mk_alg_hom_free_algebra_ι_eq_ι\n\n",
 "lift_ι_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lift_ι_apply {A : Type _} [Semiring A] [Algebra R A] (f : «expr →ₗ[ ] » M R A) (x) : lift R f (ι R x) = f x :=\n  by\n  conv_rhs => rw [← ι_comp_lift f]\n  rfl\n#align lift_ι_apply lift_ι_apply\n\n",
 "lift_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem lift_unique {A : Type _} [Semiring A] [Algebra R A] (f : «expr →ₗ[ ] » M R A)\n    (g : «expr →ₐ[ ] » (tensor_algebra R M) R A) : g.to_linear_map.comp (ι R) = f ↔ g = lift R f :=\n  by\n  rw [← (lift R).symm_apply_eq]\n  simp only [lift, Equiv.coe_fn_symm_mk]\n#align lift_unique lift_unique\n\n",
 "lift_comp_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n-- Marking `tensor_algebra` irreducible makes `ring` instances inaccessible on quotients.\n-- https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebra.2Esemiring_to_ring.20breaks.20semimodule.20typeclass.20lookup/near/212580241\n-- For now, we avoid this by not marking it irreducible.\n@[simp]\ntheorem lift_comp_ι {A : Type _} [Semiring A] [Algebra R A] (g : «expr →ₐ[ ] » (tensor_algebra R M) R A) :\n    lift R (g.to_linear_map.comp (ι R)) = g := by\n  rw [← lift_symm_apply]\n  exact (lift R).apply_symm_apply g\n#align lift_comp_ι lift_comp_ι\n\n",
 "induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- This proof closely follows `free_algebra.induction`\n/-- If `C` holds for the `algebra_map` of `r : R` into `tensor_algebra R M`, the `ι` of `x : M`,\nand is preserved under addition and muliplication, then it holds for all of `tensor_algebra R M`.\n-/\n@[elab_as_elim]\ntheorem induction {C : tensor_algebra R M → Prop} (h_grade0 : ∀ r, C (algebraMap R (tensor_algebra R M) r))\n    (h_grade1 : ∀ x, C (ι R x)) (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))\n    (a : tensor_algebra R M) : C a :=\n  by\n  -- the arguments are enough to construct a subalgebra, and a mapping into it from M\n  let s : Subalgebra R (tensor_algebra R M) :=\n    { carrier := C\n      mul_mem' := h_mul\n      add_mem' := h_add\n      algebra_map_mem' := h_grade0 }\n  let of : «expr →ₗ[ ] » M R s := (ι R).cod_restrict s.to_submodule h_grade1\n  -- the mapping through the subalgebra is the identity\n  have of_id : AlgHom.id R (tensor_algebra R M) = s.val.comp (lift R of) :=\n    by\n    ext\n    simp [of]\n  -- finding a proof is finding an element of the subalgebra\n  convert Subtype.prop (lift R of a)\n  exact AlgHom.congr_fun of_id a\n#align induction induction\n\n",
 "hom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext {A : Type _} [Semiring A] [Algebra R A] {f g : «expr →ₐ[ ] » (tensor_algebra R M) R A}\n    (w : f.to_linear_map.comp (ι R) = g.to_linear_map.comp (ι R)) : f = g :=\n  by\n  rw [← lift_symm_apply, ← lift_symm_apply] at w\n  exact (lift R).symm.injective w\n#align hom_ext hom_ext\n\n",
 "algebra_map_left_inverse":
 "theorem algebra_map_left_inverse : function.left_inverse algebra_map_inv (algebraMap R <| tensor_algebra R M) :=\n  fun x => by simp [algebra_map_inv]\n#align algebra_map_left_inverse algebra_map_left_inverse\n\n",
 "algebra_map_inj":
 "@[simp]\ntheorem algebra_map_inj (x y : R) : algebraMap R (tensor_algebra R M) x = algebraMap R (tensor_algebra R M) y ↔ x = y :=\n  (algebra_map_left_inverse M).injective.eq_iff\n#align algebra_map_inj algebra_map_inj\n\n",
 "algebra_map_eq_zero_iff":
 "@[simp]\ntheorem algebra_map_eq_zero_iff (x : R) : algebraMap R (tensor_algebra R M) x = 0 ↔ x = 0 :=\n  map_eq_zero_iff (algebraMap _ _) (algebra_map_left_inverse _).injective\n#align algebra_map_eq_zero_iff algebra_map_eq_zero_iff\n\n",
 "algebra_map_eq_one_iff":
 "@[simp]\ntheorem algebra_map_eq_one_iff (x : R) : algebraMap R (tensor_algebra R M) x = 1 ↔ x = 1 :=\n  map_eq_one_iff (algebraMap _ _) (algebra_map_left_inverse _).injective\n#align algebra_map_eq_one_iff algebra_map_eq_one_iff\n\n"}