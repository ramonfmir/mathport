{"to_span_singleton_zero":
 "@[simp]\ntheorem to_span_singleton_zero : toSpanSingleton R M 0 = 0 :=\n  by\n  ext\n  simp\n#align to_span_singleton_zero to_span_singleton_zero\n\n",
 "to_span_singleton_one":
 "@[simp]\ntheorem to_span_singleton_one (x : M) : toSpanSingleton R M x 1 = x :=\n  one_smul _ _\n#align to_span_singleton_one to_span_singleton_one\n\n",
 "to_span_nonzero_singleton_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem to_span_nonzero_singleton_one (x : V) (h : x ≠ 0) :\n    LinearEquiv.toSpanNonzeroSingleton K V x h 1 = (⟨x, Submodule.mem_span_singleton_self x⟩ : «expr ∙ » K x) :=\n  by\n  apply set_like.coe_eq_coe.mp\n  have : ↑(to_span_nonzero_singleton K V x h 1) = to_span_singleton K V x 1 := rfl\n  rw [this, to_span_singleton_one, Submodule.coe_mk]\n#align to_span_nonzero_singleton_one to_span_nonzero_singleton_one\n\n",
 "supr_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supr_to_add_submonoid {ι : Sort _} (p : ι → Submodule R M) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (p i)).to_add_submonoid =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (p i).to_add_submonoid :=\n  by\n  refine' le_antisymm (fun x => _) (supᵢ_le fun i => to_add_submonoid_mono <| le_supᵢ _ i)\n  simp_rw [supr_eq_span, AddSubmonoid.supᵢ_eq_closure, mem_to_add_submonoid, coe_to_add_submonoid]\n  intro hx\n  refine' Submodule.span_induction hx (fun x hx => _) _ (fun x y hx hy => _) fun r x hx => _\n  · exact AddSubmonoid.subset_closure hx\n  · exact AddSubmonoid.zero_mem _\n  · exact AddSubmonoid.add_mem _ hx hy\n  · apply AddSubmonoid.closure_induction hx\n    · rintro x ⟨_, ⟨i, rfl⟩, hix : x ∈ p i⟩\n      apply AddSubmonoid.subset_closure (set.mem_Union.mpr ⟨i, _⟩)\n      exact smul_mem _ r hix\n    · rw [smul_zero]\n      exact AddSubmonoid.zero_mem _\n    · intro x y hx hy\n      rw [smul_add]\n      exact AddSubmonoid.add_mem _ hx hy\n#align supr_to_add_submonoid supr_to_add_submonoid\n\n",
 "supr_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem supr_span {ι : Sort _} (p : ι → Set M) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (span R (p i)) =\n      span R («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (p i)) :=\n  le_antisymm (supᵢ_le fun i => span_mono <| subset_unionᵢ _ i) <|\n    span_le.mpr <| unionᵢ_subset fun i m hm => mem_supᵢ_of_mem i <| subset_span hm\n#align supr_span supr_span\n\n",
 "supr_induction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A dependent version of `submodule.supr_induction`. -/\n@[elab_as_elim]\ntheorem supr_induction' {ι : Sort _} (p : ι → Submodule R M)\n    {C :\n      ∀ x,\n        x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) →\n          Prop}\n    (hp : ∀ (i), ∀ x ∈ p i, C x (mem_supᵢ_of_mem i ‹_›)) (h0 : C 0 (zero_mem _))\n    (hadd : ∀ x y hx hy, C x hx → C y hy → C (x + y) (add_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i)) :\n    C x hx :=\n  by\n  refine'\n    exists.elim _\n      fun\n        (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i))\n        (hc : C x hx) =>\n      hc\n  refine' supr_induction p hx (fun i x hx => _) _ fun x y => _\n  · exact ⟨_, hp _ _ hx⟩\n  · exact ⟨_, h0⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    refine' ⟨_, hadd _ _ _ _ Cx Cy⟩\n#align supr_induction' supr_induction'\n\n",
 "supr_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- An induction principle for elements of `⨆ i, p i`.\nIf `C` holds for `0` and all elements of `p i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `p`. -/\n@[elab_as_elim]\ntheorem supr_induction {ι : Sort _} (p : ι → Submodule R M) {C : M → Prop} {x : M}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i))\n    (hp : ∀ (i), ∀ x ∈ p i, C x) (h0 : C 0) (hadd : ∀ x y, C x → C y → C (x + y)) : C x :=\n  by\n  rw [← mem_to_add_submonoid, supr_to_add_submonoid] at hx\n  exact AddSubmonoid.supᵢ_induction _ hx hp h0 hadd\n#align supr_induction supr_induction\n\n",
 "supr_eq_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem supr_eq_span {ι : Sort _} (p : ι → Submodule R M) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) =\n      span R («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(p i)) :=\n  by simp_rw [← supr_span, span_eq]\n#align supr_eq_span supr_eq_span\n\n",
 "sup_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_to_add_submonoid : («expr ⊔ » p p').to_add_submonoid = «expr ⊔ » p.to_add_submonoid p'.to_add_submonoid :=\n  by\n  ext x\n  rw [mem_to_add_submonoid, mem_sup, AddSubmonoid.mem_sup]\n  rfl\n#align sup_to_add_submonoid sup_to_add_submonoid\n\n",
 "sup_to_add_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_to_add_subgroup {R M : Type _} [Ring R] [AddCommGroup M] [Module R M] (p p' : Submodule R M) :\n    («expr ⊔ » p p').to_add_subgroup = «expr ⊔ » p.to_add_subgroup p'.to_add_subgroup :=\n  by\n  ext x\n  rw [mem_to_add_subgroup, mem_sup, AddSubgroup.mem_sup]\n  rfl\n#align sup_to_add_subgroup sup_to_add_subgroup\n\n",
 "sup_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_span : «expr ⊔ » p (span R s) = span R (p ∪ s) := by rw [Submodule.span_union, p.span_eq]\n#align sup_span sup_span\n\n",
 "subset_span_trans":
 "theorem subset_span_trans {U V W : Set M} (hUV : U ⊆ Submodule.span R V) (hVW : V ⊆ Submodule.span R W) :\n    U ⊆ Submodule.span R W :=\n  (Submodule.gi R M).gc.le_u_l_trans hUV hVW\n#align subset_span_trans subset_span_trans\n\n",
 "subset_span":
 "theorem subset_span : s ⊆ span R s := fun x h => mem_span.2 fun p hp => hp h\n#align subset_span subset_span\n\n",
 "submodule_eq_Sup_le_nonzero_spans":
 "/-- A submodule is equal to the supremum of the spans of the submodule's nonzero elements. -/\ntheorem submodule_eq_Sup_le_nonzero_spans (p : Submodule R M) :\n    p = supₛ { T : Submodule R M | ∃ (m : M)(hm : m ∈ p)(hz : m ≠ 0), T = span R {m} } :=\n  by\n  let S := { T : Submodule R M | ∃ (m : M)(hm : m ∈ p)(hz : m ≠ 0), T = span R {m} }\n  apply le_antisymm\n  · intro m hm\n    by_cases h : m = 0\n    · rw [h]\n      simp\n    · exact @le_supₛ _ _ S _ ⟨m, ⟨hm, ⟨h, rfl⟩⟩⟩ m (mem_span_singleton_self m)\n  · rw [supₛ_le_iff]\n    rintro S ⟨_, ⟨_, ⟨_, rfl⟩⟩⟩\n    rwa [span_singleton_le_iff_mem]\n#align submodule_eq_Sup_le_nonzero_spans submodule_eq_Sup_le_nonzero_spans\n\n",
 "span_zero_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem span_zero_singleton : «expr ∙ » R (0 : M) = «expr⊥» :=\n  by\n  ext\n  simp [mem_span_singleton, eq_comm]\n#align span_zero_singleton span_zero_singleton\n\n",
 "span_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem span_zero : span R (0 : Set M) = «expr⊥» := by rw [← singleton_zero, span_singleton_eq_bot]\n#align span_zero span_zero\n\n",
 "span_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem span_univ : span R (univ : Set M) = «expr⊤» :=\n  eq_top_iff.2 <| SetLike.le_def.2 <| subset_span\n#align span_univ span_univ\n\n",
 "span_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem span_union (s t : Set M) : span R (s ∪ t) = «expr ⊔ » (span R s) (span R t) :=\n  (Submodule.gi R M).gc.l_sup\n#align span_union span_union\n\n",
 "span_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem span_sup : «expr ⊔ » (span R s) p = span R (s ∪ p) := by rw [Submodule.span_union, p.span_eq]\n#align span_sup span_sup\n\n",
 "span_subset_span":
 "/-- A version of `submodule.span_le_restrict_scalars` with coercions. -/\n@[simp]\ntheorem span_subset_span [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    ↑(span R s) ⊆ (span S s : Set M) :=\n  span_le_restrictScalars R S s\n#align span_subset_span span_subset_span\n\n",
 "span_span_of_tower":
 "/-- Taking the span by a large ring of the span by the small ring is the same as taking the span\nby just the large ring. -/\ntheorem span_span_of_tower [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    span S (span R s : Set M) = span S s :=\n  le_antisymm (span_le.2 <| span_subset_span R S s) (span_mono subset_span)\n#align span_span_of_tower span_span_of_tower\n\n",
 "span_span_coe_preimage":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem span_span_coe_preimage : span R («expr ⁻¹' » (coe : span R s → M) s) = «expr⊤» :=\n  eq_top_iff.2 fun x =>\n    subtype.rec_on x fun x hx _ =>\n      by\n      refine' span_induction' (fun x hx => _) _ (fun x y _ _ => _) (fun r x _ => _) hx\n      · exact subset_span hx\n      · exact zero_mem _\n      · exact add_mem\n      · exact smul_mem _ _\n#align span_span_coe_preimage span_span_coe_preimage\n\n",
 "span_span":
 "theorem span_span : span R (span R s : Set M) = span R s :=\n  span_eq _\n#align span_span span_span\n\n",
 "span_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_smul_le (s : Set M) (r : R) : span R («expr • » r s) ≤ span R s :=\n  by\n  rw [span_le]\n  rintro _ ⟨x, hx, rfl⟩\n  exact smul_mem (span R s) r (subset_span hx)\n#align span_smul_le span_smul_le\n\n",
 "span_smul_eq_of_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- See `submodule.span_smul_eq` (in `ring_theory.ideal.operations`) for\n`span R (r • s) = r • span R s` that holds for arbitrary `r` in a `comm_semiring`. -/\ntheorem span_smul_eq_of_is_unit (s : Set M) (r : R) (hr : IsUnit r) : span R («expr • » r s) = span R s :=\n  by\n  apply le_antisymm\n  · apply span_smul_le\n  · convert span_smul_le («expr • » r s) ((hr.unit⁻¹ : _) : R)\n    rw [smul_smul]\n    erw [hr.unit.inv_val]\n    rw [one_smul]\n#align span_smul_eq_of_is_unit span_smul_eq_of_is_unit\n\n",
 "span_singleton_sup_ker_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem span_singleton_sup_ker_eq_top (f : «expr →ₗ[ ] » V K K) {x : V} (hx : f x ≠ 0) :\n    «expr ⊔ » («expr ∙ » K x) f.ker = «expr⊤» :=\n  eq_top_iff.2 fun y hy =>\n    Submodule.mem_sup.2\n      ⟨«expr • » (f y * (f x)⁻¹) x, Submodule.mem_span_singleton.2 ⟨f y * (f x)⁻¹, rfl⟩,\n        ⟨y - «expr • » (f y * (f x)⁻¹) x, by\n          rw [LinearMap.mem_ker, f.map_sub, f.map_smul, smul_eq_mul, mul_assoc, inv_mul_cancel hx, mul_one, sub_self],\n          by simp only [add_sub_cancel'_right]⟩⟩\n#align span_singleton_sup_ker_eq_top span_singleton_sup_ker_eq_top\n\n",
 "span_singleton_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem span_singleton_smul_le {S} [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M] (r : S) (x : M) :\n    «expr ∙ » R («expr • » r x) ≤ «expr ∙ » R x :=\n  by\n  rw [span_le, Set.singleton_subset_iff, SetLike.mem_coe]\n  exact smul_of_tower_mem _ _ (mem_span_singleton_self _)\n#align span_singleton_smul_le span_singleton_smul_le\n\n",
 "span_singleton_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem span_singleton_smul_eq {r : R} (hr : IsUnit r) (x : M) : «expr ∙ » R («expr • » r x) = «expr ∙ » R x :=\n  by\n  lift r to «expr ˣ» R using hr\n  rw [← Units.smul_def]\n  exact span_singleton_group_smul_eq R r x\n#align span_singleton_smul_eq span_singleton_smul_eq\n\n",
 "span_singleton_le_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n@[simp]\ntheorem span_singleton_le_iff_mem (m : M) (p : Submodule R M) : «expr ∙ » R m ≤ p ↔ m ∈ p := by\n  rw [span_le, singleton_subset_iff, SetLike.mem_coe]\n#align span_singleton_le_iff_mem span_singleton_le_iff_mem\n\n",
 "span_singleton_group_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M] (g : G) (x : M) :\n    «expr ∙ » R («expr • » g x) = «expr ∙ » R x :=\n  by\n  refine' le_antisymm (span_singleton_smul_le R g x) _\n  convert span_singleton_smul_le R g⁻¹ («expr • » g x)\n  exact (inv_smul_smul g x).symm\n#align span_singleton_group_smul_eq span_singleton_group_smul_eq\n\n",
 "span_singleton_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_singleton_eq_top_iff (x : M) : «expr ∙ » R x = «expr⊤» ↔ ∀ v, ∃ r : R, «expr • » r x = v :=\n  by\n  rw [eq_top_iff, le_span_singleton_iff]\n  tauto\n#align span_singleton_eq_top_iff span_singleton_eq_top_iff\n\n",
 "span_singleton_eq_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem span_singleton_eq_span_singleton {R M : Type _} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    {x y : M} : «expr ∙ » R x = «expr ∙ » R y ↔ ∃ z : «expr ˣ» R, «expr • » z x = y :=\n  by\n  by_cases hx : x = 0\n  · rw [hx, span_zero_singleton, eq_comm, span_singleton_eq_bot]\n    exact ⟨fun hy => ⟨1, by rw [hy, smul_zero]⟩, fun ⟨_, hz⟩ => by rw [← hz, smul_zero]⟩\n  by_cases hy : y = 0\n  · rw [hy, span_zero_singleton, span_singleton_eq_bot]\n    exact ⟨fun hx => ⟨1, by rw [hx, smul_zero]⟩, fun ⟨z, hz⟩ => (smul_eq_zero_iff_eq z).mp hz⟩\n  constructor\n  · intro hxy\n    cases'\n      mem_span_singleton.mp\n        (by\n          rw [hxy]\n          apply mem_span_singleton_self) with\n      v hv\n    cases'\n      mem_span_singleton.mp\n        (by\n          rw [← hxy]\n          apply mem_span_singleton_self) with\n      i hi\n    have vi : v * i = 1 := by\n      rw [← one_smul R y, ← hi, smul_smul] at hv\n      exact smul_left_injective R hy hv\n    have iv : i * v = 1 := by\n      rw [← one_smul R x, ← hv, smul_smul] at hi\n      exact smul_left_injective R hx hi\n    exact ⟨⟨v, i, vi, iv⟩, hv⟩\n  · rintro ⟨v, rfl⟩\n    rw [span_singleton_group_smul_eq]\n#align span_singleton_eq_span_singleton span_singleton_eq_span_singleton\n\n",
 "span_singleton_eq_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- The range of `to_span_singleton x` is the span of `x`.-/\ntheorem span_singleton_eq_range (x : M) : «expr ∙ » R x = (toSpanSingleton R M x).range :=\n  Submodule.ext fun y => by\n    refine' iff.trans _ linear_map.mem_range.symm\n    exact mem_span_singleton\n#align span_singleton_eq_range span_singleton_eq_range\n\n",
 "span_singleton_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem span_singleton_eq_bot : «expr ∙ » R x = «expr⊥» ↔ x = 0 :=\n  span_eq_bot.trans <| by simp\n#align span_singleton_eq_bot span_singleton_eq_bot\n\n",
 "span_range_eq_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem span_range_eq_supr {ι : Type _} {v : ι → M} :\n    span R (range v) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ∙ » R (v i)) :=\n  by rw [span_eq_supr_of_singleton_spans, supᵢ_range]\n#align span_range_eq_supr span_range_eq_supr\n\n",
 "span_prod_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem span_prod_le (s : Set M) (t : Set M') : span R (finset.product s t) ≤ prod (span R s) (span R t) :=\n  span_le.2 <| Set.prod_mono subset_span subset_span\n#align span_prod_le span_prod_le\n\n",
 "span_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n-- See also `span_preimage_eq` below.\ntheorem span_preimage_le (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (s : Set M₂) : span R («expr ⁻¹' » f s) ≤ (span R₂ s).comap f :=\n  by\n  rw [span_le, comap_coe]\n  exact preimage_mono subset_span\n#align span_preimage_le span_preimage_le\n\n",
 "span_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem span_neg (s : Set M) : span R (-s) = span R s :=\n  calc\n    span R (-s) = span R («expr '' » (-LinearMap.id : «expr →ₗ[ ] » M R M) s) := by simp\n    _ = map (-LinearMap.id) (span R s) := ((-LinearMap.id).map_span _).symm\n    _ = span R s := by simp\n    \n#align span_neg span_neg\n\n",
 "span_nat_eq_add_submonoid_closure":
 "theorem span_nat_eq_add_submonoid_closure (s : Set M) : (span ℕ s).to_add_submonoid = AddSubmonoid.closure s :=\n  by\n  refine' Eq.symm (AddSubmonoid.closure_eq_of_le subset_span _)\n  apply add_submonoid.to_nat_submodule.symm.to_galois_connection.l_le _\n  rw [span_le]\n  exact AddSubmonoid.subset_closure\n#align span_nat_eq_add_submonoid_closure span_nat_eq_add_submonoid_closure\n\n",
 "span_nat_eq":
 "@[simp]\ntheorem span_nat_eq (s : AddSubmonoid M) : (span ℕ (s : Set M)).to_add_submonoid = s := by\n  rw [span_nat_eq_add_submonoid_closure, s.closure_eq]\n#align span_nat_eq span_nat_eq\n\n",
 "span_monotone":
 "theorem span_monotone : Monotone (span R : Set M → Submodule R M) := fun _ _ => span_mono\n#align span_monotone span_monotone\n\n",
 "span_mono":
 "theorem span_mono (h : s ⊆ t) : span R s ≤ span R t :=\n  span_le.2 <| Subset.trans h subset_span\n#align span_mono span_mono\n\n",
 "span_le_restrict_scalars":
 "/-- If `R` is \"smaller\" ring than `S` then the span by `R` is smaller than the span by `S`. -/\ntheorem span_le_restrict_scalars [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    span R s ≤ (span S s).restrict_scalars R :=\n  Submodule.span_le.2 Submodule.subset_span\n#align span_le_restrict_scalars span_le_restrict_scalars\n\n",
 "span_le":
 "theorem span_le {p} : span R s ≤ p ↔ s ⊆ p :=\n  ⟨Subset.trans subset_span, fun ss x h => mem_span.1 h _ ss⟩\n#align span_le span_le\n\n",
 "span_int_eq_add_subgroup_closure":
 "theorem span_int_eq_add_subgroup_closure {M : Type _} [AddCommGroup M] (s : Set M) :\n    (span ℤ s).to_add_subgroup = AddSubgroup.closure s :=\n  Eq.symm <|\n    AddSubgroup.closure_eq_of_le _ subset_span fun x hx =>\n      span_induction hx (fun x hx => AddSubgroup.subset_closure hx) (AddSubgroup.zero_mem _)\n        (fun _ _ => AddSubgroup.add_mem _) fun _ _ _ => AddSubgroup.zsmul_mem _ ‹_› _\n#align span_int_eq_add_subgroup_closure span_int_eq_add_subgroup_closure\n\n",
 "span_int_eq":
 "@[simp]\ntheorem span_int_eq {M : Type _} [AddCommGroup M] (s : AddSubgroup M) : (span ℤ (s : Set M)).to_add_subgroup = s := by\n  rw [span_int_eq_add_subgroup_closure, s.closure_eq]\n#align span_int_eq span_int_eq\n\n",
 "span_insert_zero":
 "@[simp]\ntheorem span_insert_zero : span R (insert (0 : M) s) = span R s :=\n  by\n  refine' le_antisymm _ (Submodule.span_mono (Set.subset_insert 0 s))\n  rw [span_le, Set.insert_subset]\n  exact ⟨by simp only [SetLike.mem_coe, Submodule.zero_mem], Submodule.subset_span⟩\n#align span_insert_zero span_insert_zero\n\n",
 "span_insert_eq_span":
 "theorem span_insert_eq_span (h : x ∈ span R s) : span R (insert x s) = span R s :=\n  span_eq_of_le _ (Set.insert_subset.mpr ⟨h, subset_span⟩) (span_mono <| subset_insert _ _)\n#align span_insert_eq_span span_insert_eq_span\n\n",
 "span_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem span_insert (x) (s : Set M) : span R (insert x s) = «expr ⊔ » (span R ({x} : Set M)) (span R s) := by\n  rw [insert_eq, span_union]\n#align span_insert span_insert\n\n",
 "span_induction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A dependent version of `submodule.span_induction`. -/\ntheorem span_induction' {p : ∀ x, x ∈ span R s → Prop} (Hs : ∀ (x) (h : x ∈ s), p x (subset_span h))\n    (H0 : p 0 (Submodule.zero_mem _)) (H1 : ∀ x hx y hy, p x hx → p y hy → p (x + y) (Submodule.add_mem _ ‹_› ‹_›))\n    (H2 : ∀ (a : R) (x hx), p x hx → p («expr • » a x) (Submodule.smul_mem _ _ ‹_›)) {x} (hx : x ∈ span R s) : p x hx :=\n  by\n  refine' exists.elim _ fun (hx : x ∈ span R s) (hc : p x hx) => hc\n  refine'\n    span_induction hx (fun m hm => ⟨subset_span hm, Hs m hm⟩) ⟨zero_mem _, H0⟩\n      (fun x y hx hy => exists.elim hx fun hx' hx => exists.elim hy fun hy' hy => ⟨add_mem hx' hy', H1 _ _ _ _ hx hy⟩)\n      fun r x hx => exists.elim hx fun hx' hx => ⟨smul_mem _ _ hx', H2 r _ _ hx⟩\n#align span_induction' span_induction'\n\n",
 "span_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An induction principle for span membership. If `p` holds for 0 and all elements of `s`, and is\npreserved under addition and scalar multiplication, then `p` holds for all elements of the span of\n`s`. -/\n@[elab_as_elim]\ntheorem span_induction {p : M → Prop} (h : x ∈ span R s) (Hs : ∀ x ∈ s, p x) (H0 : p 0)\n    (H1 : ∀ x y, p x → p y → p (x + y)) (H2 : ∀ (a : R) (x), p x → p («expr • » a x)) : p x :=\n  (@span_le _ _ _ _ _ _ ⟨p, H1, H0, H2⟩).2 Hs h\n#align span_induction span_induction\n\n",
 "span_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem span_image [RingHomSurjective σ₁₂] (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) :\n    span R₂ («expr '' » f s) = map f (span R s) :=\n  (map_span f s).symm\n#align span_image span_image\n\n",
 "span_eq_supr_of_singleton_spans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- Note that the character `∙` U+2219 used below is different from the scalar multiplication\ncharacter `•` U+2022 and the matrix multiplication character `⬝` U+2B1D. -/\ntheorem span_eq_supr_of_singleton_spans (s : Set M) :\n    span R s =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" («expr ∙ » R x) :=\n  by simp only [← span_Union, Set.bunionᵢ_of_singleton s]\n#align span_eq_supr_of_singleton_spans span_eq_supr_of_singleton_spans\n\n",
 "span_eq_span":
 "theorem span_eq_span (hs : s ⊆ span R t) (ht : t ⊆ span R s) : span R s = span R t :=\n  le_antisymm (span_le.2 hs) (span_le.2 ht)\n#align span_eq_span span_eq_span\n\n",
 "span_eq_of_le":
 "theorem span_eq_of_le (h₁ : s ⊆ p) (h₂ : p ≤ span R s) : span R s = p :=\n  le_antisymm (span_le.2 h₁) h₂\n#align span_eq_of_le span_eq_of_le\n\n",
 "span_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem span_eq_bot : span R (s : Set M) = «expr⊥» ↔ ∀ x ∈ s, (x : M) = 0 :=\n  eq_bot_iff.trans\n    ⟨fun H x h => (mem_bot R).1 <| H <| subset_span h, fun H => span_le.2 fun x h => (mem_bot R).2 <| H x h⟩\n#align span_eq_bot span_eq_bot\n\n",
 "span_eq":
 "theorem span_eq : span R (p : Set M) = p :=\n  span_eq_of_le _ (Subset.refl _) subset_span\n#align span_eq span_eq\n\n",
 "span_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem span_empty : span R (∅ : Set M) = «expr⊥» :=\n  (Submodule.gi R M).gc.l_bot\n#align span_empty span_empty\n\n",
 "span_coe_eq_restrict_scalars":
 "/-- A version of `submodule.span_eq` for when the span is by a smaller ring. -/\n@[simp]\ntheorem span_coe_eq_restrict_scalars [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] :\n    span S (p : Set M) = p.restrict_scalars S :=\n  span_eq (p.restrict_scalars S)\n#align span_coe_eq_restrict_scalars span_coe_eq_restrict_scalars\n\n",
 "span_closure":
 "@[simp]\ntheorem span_closure {s : Set M} : span R (AddSubmonoid.closure s : Set M) = span R s :=\n  le_antisymm (span_le.mpr closure_subset_span) (span_mono AddSubmonoid.subset_closure)\n#align span_closure span_closure\n\n",
 "span_attach_bUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem span_attach_bUnion [DecidableEq M] {α : Type _} (s : Finset α) (f : s → Finset M) :\n    span R (s.attach.bUnion f : Set M) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (span R (f x)) :=\n  by simpa [span_Union]\n#align span_attach_bUnion span_attach_bUnion\n\n",
 "span_Union₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem span_Union₂ {ι} {κ : ι → Sort _} (s : ∀ i, κ i → Set M) :\n    span R («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i j)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (span R (s i j)) :=\n  (Submodule.gi R M).gc.l_supr₂\n#align span_Union₂ span_Union₂\n\n",
 "span_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem span_Union {ι} (s : ι → Set M) :\n    span R («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (span R (s i)) :=\n  (Submodule.gi R M).gc.l_supr\n#align span_Union span_Union\n\n",
 "singleton_span_is_compact_element":
 "theorem singleton_span_is_compact_element (x : M) : CompleteLattice.IsCompactElement (span R {x} : Submodule R M) :=\n  by\n  rw [CompleteLattice.isCompactElement_iff_le_of_directed_supₛ_le]\n  intro d hemp hdir hsup\n  have : x ∈ Sup d := (set_like.le_def.mp hsup) (mem_span_singleton_self x)\n  obtain ⟨y, ⟨hyd, hxy⟩⟩ := (mem_Sup_of_directed hemp hdir).mp this\n  exact ⟨y, ⟨hyd, by simpa only [span_le, singleton_subset_iff] ⟩⟩\n#align singleton_span_is_compact_element singleton_span_is_compact_element\n\n",
 "prod_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem prod_top : (prod («expr⊤») («expr⊤») : Submodule R (M × M')) = «expr⊤» := by ext <;> simp\n#align prod_top prod_top\n\n",
 "prod_sup_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem prod_sup_prod : «expr ⊔ » (prod p q₁) (prod p' q₁') = prod («expr ⊔ » p p') («expr ⊔ » q₁ q₁') :=\n  by\n  refine' le_antisymm (sup_le (prod_mono le_sup_left le_sup_left) (prod_mono le_sup_right le_sup_right)) _\n  simp [SetLike.le_def]; intro xx yy hxx hyy\n  rcases mem_sup.1 hxx with ⟨x, hx, x', hx', rfl⟩\n  rcases mem_sup.1 hyy with ⟨y, hy, y', hy', rfl⟩\n  refine' mem_sup.2 ⟨(x, y), ⟨hx, hy⟩, (x', y'), ⟨hx', hy'⟩, rfl⟩\n#align prod_sup_prod prod_sup_prod\n\n",
 "prod_mono":
 "theorem prod_mono {p p' : Submodule R M} {q q' : Submodule R M'} : p ≤ p' → q ≤ q' → prod p q ≤ prod p' q' :=\n  prod_mono\n#align prod_mono prod_mono\n\n",
 "prod_inf_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem prod_inf_prod : «expr ⊓ » (prod p q₁) (prod p' q₁') = prod («expr ⊓ » p p') («expr ⊓ » q₁ q₁') :=\n  SetLike.coe_injective Set.prod_inter_prod\n#align prod_inf_prod prod_inf_prod\n\n",
 "prod_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n@[simp]\ntheorem prod_coe : (prod p q₁ : Set (M × M')) = finset.product p q₁ :=\n  rfl\n#align prod_coe prod_coe\n\n",
 "prod_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem prod_bot : (prod («expr⊥») («expr⊥») : Submodule R (M × M')) = «expr⊥» := by\n  ext ⟨x, y⟩ <;> simp [Prod.zero_eq_mk]\n#align prod_bot prod_bot\n\n",
 "not_mem_span_of_apply_not_mem_span_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- `f` is an explicit argument so we can `apply` this theorem and obtain `h` as a new goal. -/\ntheorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective σ₁₂] (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) {x : M}\n    {s : Set M} (h : f x ∉ Submodule.span R₂ («expr '' » f s)) : x ∉ Submodule.span R s :=\n  h.imp (apply_mem_span_image_of_mem_span f)\n#align not_mem_span_of_apply_not_mem_span_image not_mem_span_of_apply_not_mem_span_image\n\n",
 "nontrivial_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem nontrivial_span_singleton {x : M} (h : x ≠ 0) : Nontrivial («expr ∙ » R x) :=\n  ⟨by\n    use 0, x, Submodule.mem_span_singleton_self x\n    intro H\n    rw [eq_comm, Submodule.mk_eq_zero] at H\n    exact h H⟩\n#align nontrivial_span_singleton nontrivial_span_singleton\n\n",
 "mem_supr_of_directed":
 "@[simp]\ntheorem mem_supr_of_directed {ι} [Nonempty ι] (S : ι → Submodule R M) (H : Directed (· ≤ ·) S) {x} :\n    x ∈ supᵢ S ↔ ∃ i, x ∈ S i :=\n  by\n  rw [← SetLike.mem_coe, coe_supr_of_directed S H, mem_Union]\n  rfl\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_supr_of_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem mem_supr_of_chain (a : «expr →o » ℕ (Submodule R M)) (m : M) :\n    m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (a k) ↔\n      ∃ k, m ∈ a k :=\n  mem_supᵢ_of_directed a a.monotone.directed_le\n#align mem_supr_of_chain mem_supr_of_chain\n\n",
 "mem_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem mem_supr {ι : Sort _} (p : ι → Submodule R M) {m : M} :\n    m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) ↔\n      ∀ N, (∀ i, p i ≤ N) → m ∈ N :=\n  by\n  rw [← span_singleton_le_iff_mem, le_supᵢ_iff]\n  simp only [span_singleton_le_iff_mem]\n#align mem_supr mem_supr\n\n",
 "mem_sup'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mem_sup' : x ∈ «expr ⊔ » p p' ↔ ∃ (y : p)(z : p'), (y : M) + z = x :=\n  mem_sup.trans <| by simp only [SetLike.exists, coe_mk]\n#align mem_sup' mem_sup'\n\n",
 "mem_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem mem_sup : x ∈ «expr ⊔ » p p' ↔ ∃ y ∈ p, ∃ z ∈ p', y + z = x :=\n  ⟨fun h => by\n    rw [← span_eq p, ← span_eq p', ← span_union] at h\n    apply span_induction h\n    · rintro y (h | h)\n      · exact ⟨y, h, 0, by simp, by simp⟩\n      · exact ⟨0, by simp, y, h, by simp⟩\n    · exact ⟨0, by simp, 0, by simp⟩\n    · rintro _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩\n      exact ⟨_, add_mem hy₁ hy₂, _, add_mem hz₁ hz₂, by simp [add_assoc] <;> cc⟩\n    · rintro a _ ⟨y, hy, z, hz, rfl⟩\n      exact ⟨_, smul_mem _ a hy, _, smul_mem _ a hz, by simp [smul_add]⟩, by\n    rintro ⟨y, hy, z, hz, rfl⟩ <;>\n      exact add_mem ((le_sup_left : p ≤ «expr ⊔ » p p') hy) ((le_sup_right : p' ≤ «expr ⊔ » p p') hz)⟩\n#align mem_sup mem_sup\n\n",
 "mem_span_singleton_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem mem_span_singleton_trans {x y z : M} (hxy : x ∈ «expr ∙ » R y) (hyz : y ∈ «expr ∙ » R z) : x ∈ «expr ∙ » R z :=\n  by\n  rw [← SetLike.mem_coe, ← singleton_subset_iff] at *\n  exact Submodule.subset_span_trans hxy hyz\n#align mem_span_singleton_trans mem_span_singleton_trans\n\n",
 "mem_span_singleton_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem mem_span_singleton_self (x : M) : x ∈ «expr ∙ » R x :=\n  subset_span rfl\n#align mem_span_singleton_self mem_span_singleton_self\n\n",
 "mem_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_singleton {y : M} : x ∈ «expr ∙ » R y ↔ ∃ a : R, «expr • » a y = x :=\n  ⟨fun h => by\n    apply span_induction h\n    · rintro y (rfl | ⟨⟨⟩⟩)\n      exact ⟨1, by simp⟩\n    · exact ⟨0, by simp⟩\n    · rintro _ _ ⟨a, rfl⟩ ⟨b, rfl⟩\n      exact ⟨a + b, by simp [add_smul]⟩\n    · rintro a _ ⟨b, rfl⟩\n      exact ⟨a * b, by simp [smul_smul]⟩, by rintro ⟨a, y, rfl⟩ <;> exact smul_mem _ _ (subset_span <| by simp)⟩\n#align mem_span_singleton mem_span_singleton\n\n",
 "mem_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_pair {x y z : M} : z ∈ span R ({x, y} : Set M) ↔ ∃ a b : R, «expr • » a x + «expr • » b y = z := by\n  simp_rw [mem_span_insert, mem_span_singleton, exists_prop, exists_exists_eq_and, eq_comm]\n#align mem_span_pair mem_span_pair\n\n",
 "mem_span_insert'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_insert' {x y} {s : Set M} : x ∈ span R (insert y s) ↔ ∃ a : R, x + «expr • » a y ∈ span R s :=\n  by\n  rw [mem_span_insert]; constructor\n  · rintro ⟨a, z, hz, rfl⟩\n    exact ⟨-a, by simp [hz, add_assoc]⟩\n  · rintro ⟨a, h⟩\n    exact ⟨-a, _, h, by simp [add_comm, add_left_comm]⟩\n#align mem_span_insert' mem_span_insert'\n\n",
 "mem_span_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_insert {y} : x ∈ span R (insert y s) ↔ ∃ a : R, ∃ z ∈ span R s, x = «expr • » a y + z :=\n  by\n  simp only [← union_singleton, span_union, mem_sup, mem_span_singleton, exists_prop, exists_exists_eq_and]\n  rw [exists_comm]\n  simp only [eq_comm, add_comm, exists_and_left]\n#align mem_span_insert mem_span_insert\n\n",
 "mem_span_finite_of_mem_span":
 "/-- For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. -/\ntheorem mem_span_finite_of_mem_span {S : Set M} {x : M} (hx : x ∈ span R S) :\n    ∃ T : Finset M, ↑T ⊆ S ∧ x ∈ span R (T : Set M) :=\n  by\n  refine' span_induction hx (fun x hx => _) _ _ _\n  · refine' ⟨{x}, _, _⟩\n    · rwa [Finset.coe_singleton, Set.singleton_subset_iff]\n    · rw [Finset.coe_singleton]\n      exact Submodule.mem_span_singleton_self x\n  · use ∅\n    simp\n  · rintro x y ⟨X, hX, hxX⟩ ⟨Y, hY, hyY⟩\n    refine' ⟨X ∪ Y, _, _⟩\n    · rw [Finset.coe_union]\n      exact Set.union_subset hX hY\n    rw [Finset.coe_union, span_union, mem_sup]\n    exact ⟨x, hxX, y, hyY, rfl⟩\n  · rintro a x ⟨T, hT, h2⟩\n    exact ⟨T, hT, smul_mem _ _ h2⟩\n#align mem_span_finite_of_mem_span mem_span_finite_of_mem_span\n\n",
 "mem_span":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov, Frédéric Dupuis,\n  Heather Macbeth\n-/\ntheorem mem_span : x ∈ span R s ↔ ∀ p : Submodule R M, s ⊆ p → x ∈ p :=\n  mem_interᵢ₂\n#align mem_span mem_span\n\n",
 "mem_prod":
 "@[simp]\ntheorem mem_prod {p : Submodule R M} {q : Submodule R M'} {x : M × M'} : x ∈ prod p q ↔ x.1 ∈ p ∧ x.2 ∈ q :=\n  Set.mem_prod\n#align mem_prod mem_prod\n\n",
 "mem_Sup_of_directed":
 "theorem mem_Sup_of_directed {s : Set (Submodule R M)} {z} (hs : s.nonempty) (hdir : DirectedOn (· ≤ ·) s) :\n    z ∈ supₛ s ↔ ∃ y ∈ s, z ∈ y := by\n  haveI : Nonempty s := hs.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed _ hdir.directed_coe, SetCoe.exists, Subtype.coe_mk]\n#align mem_Sup_of_directed mem_Sup_of_directed\n\n",
 "map_subtype_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n@[simp]\ntheorem map_subtype_span_singleton {p : Submodule R M} (x : p) : map p.subtype («expr ∙ » R x) = «expr ∙ » R (x : M) :=\n  by simp [← span_image]\n#align map_subtype_span_singleton map_subtype_span_singleton\n\n",
 "map_span_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem map_span_le [RingHomSurjective σ₁₂] (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (s : Set M) (N : Submodule R₂ M₂) :\n    map f (span R s) ≤ N ↔ ∀ m ∈ s, f m ∈ N :=\n  by\n  rw [f.map_span, span_le, Set.image_subset_iff]\n  exact iff.rfl\n#align map_span_le map_span_le\n\n",
 "map_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_span [RingHomSurjective σ₁₂] (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (s : Set M) :\n    (span R s).map f = span R₂ («expr '' » f s) :=\n  Eq.symm <|\n    span_eq_of_le _ (Set.image_subset f subset_span) <|\n      map_le_iff_le_comap.2 <| span_le.2 fun x hx => subset_span ⟨x, hx, rfl⟩\n#align map_span map_span\n\n",
 "map_le_map_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem map_le_map_iff' {f : F} (hf : ker f = «expr⊥») {p p'} : map f p ≤ map f p' ↔ p ≤ p' := by\n  rw [LinearMap.map_le_map_iff, hf, sup_bot_eq]\n#align map_le_map_iff' map_le_map_iff'\n\n",
 "map_le_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\nprotected theorem map_le_map_iff (f : F) {p p'} : map f p ≤ map f p' ↔ p ≤ «expr ⊔ » p' (ker f) := by\n  rw [map_le_iff_le_comap, Submodule.comap_map_eq]\n#align map_le_map_iff map_le_map_iff\n\n",
 "map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem map_injective {f : F} (hf : ker f = «expr⊥») : injective (map f) := fun p p' h =>\n  le_antisymm ((map_le_map_iff' hf).1 (le_of_eq h)) ((map_le_map_iff' hf).1 (ge_of_eq h))\n#align map_injective map_injective\n\n",
 "map_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print map_eq_top_iff /-\ntheorem map_eq_top_iff {f : F} (hf : range f = «expr⊤») {p : Submodule R M} :\n    p.map f = «expr⊤» ↔ «expr ⊔ » p (LinearMap.ker f) = «expr⊤» := by\n  simp_rw [← top_le_iff, ← hf, range_eq_map, LinearMap.map_le_map_iff]\n#align map_eq_top_iff map_eq_top_iff\n-/\n\n",
 "lt_sup_iff_not_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem lt_sup_iff_not_mem {I : Submodule R M} {a : M} : I < «expr ⊔ » I («expr ∙ » R a) ↔ a ∉ I :=\n  by\n  constructor\n  · intro h\n    by_contra akey\n    have h1 : «expr ⊔ » I («expr ∙ » R a) ≤ I := by\n      simp only [sup_le_iff]\n      constructor\n      · exact le_refl I\n      · exact (span_singleton_le_iff_mem a I).mpr akey\n    have h2 := gt_of_ge_of_gt h1 h\n    exact lt_irrefl I h2\n  · intro h\n    apply set_like.lt_iff_le_and_exists.mpr\n    constructor\n    simp only [le_sup_left]\n    use a\n    constructor\n    swap\n    · assumption\n    · have : «expr ∙ » R a ≤ «expr ⊔ » I («expr ∙ » R a) := le_sup_right\n      exact this (mem_span_singleton_self a)\n#align lt_sup_iff_not_mem lt_sup_iff_not_mem\n\n",
 "le_span_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem le_span_singleton_iff {s : Submodule R M} {v₀ : M} :\n    s ≤ «expr ∙ » R v₀ ↔ ∀ v ∈ s, ∃ r : R, «expr • » r v₀ = v := by simp_rw [SetLike.le_def, mem_span_singleton]\n#align le_span_singleton_iff le_span_singleton_iff\n\n",
 "ker_to_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_to_span_singleton {x : V} (h : x ≠ 0) : (toSpanSingleton K V x).ker = «expr⊥» :=\n  by\n  ext c; constructor\n  · intro hc\n    rw [Submodule.mem_bot]\n    rw [mem_ker] at hc\n    by_contra hc'\n    have : x = 0\n    calc\n      x = «expr • » c⁻¹ («expr • » c x) := by rw [← mul_smul, inv_mul_cancel hc', one_smul]\n      _ = «expr • » c⁻¹ ((to_span_singleton K V x) c) := rfl\n      _ = 0 := by rw [hc, smul_zero]\n      \n    tauto\n  · rw [mem_ker, Submodule.mem_bot]\n    intro h\n    rw [h]\n    simp\n#align ker_to_span_singleton ker_to_span_singleton\n\n",
 "finset_span_is_compact_element":
 "/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem finset_span_is_compact_element (S : Finset M) : CompleteLattice.IsCompactElement (span R S : Submodule R M) :=\n  by\n  rw [span_eq_supr_of_singleton_spans]\n  simp only [Finset.mem_coe]\n  rw [← Finset.sup_eq_supᵢ]\n  exact CompleteLattice.finset_sup_compact_of_compact S fun x _ => singleton_span_is_compact_element x\n#align finset_span_is_compact_element finset_span_is_compact_element\n\n",
 "finite_span_is_compact_element":
 "/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem finite_span_is_compact_element (S : Set M) (h : S.finite) :\n    CompleteLattice.IsCompactElement (span R S : Submodule R M) :=\n  Finite.coe_toFinset h ▸ finset_span_isCompactElement h.to_finset\n#align finite_span_is_compact_element finite_span_is_compact_element\n\n",
 "ext_on_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the range of `v : ι → M` generates the whole module and linear maps `f`, `g` are equal at\neach `v i`, then they are equal. -/\ntheorem ext_on_range {ι : Type _} {v : ι → M} {f g : «expr →ₛₗ[ ] » M σ₁₂ M₂} (hv : span R (Set.range v) = «expr⊤»)\n    (h : ∀ i, f (v i) = g (v i)) : f = g :=\n  ext_on hv (Set.forall_range_iff.2 h)\n#align ext_on_range ext_on_range\n\n",
 "ext_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `s` generates the whole module and linear maps `f`, `g` are equal on `s`, then they are\nequal. -/\ntheorem ext_on {s : Set M} {f g : «expr →ₛₗ[ ] » M σ₁₂ M₂} (hv : span R s = «expr⊤») (h : Set.EqOn f g s) : f = g :=\n  LinearMap.ext fun x => eqOn_span h (eq_top_iff'.1 hv _)\n#align ext_on ext_on\n\n",
 "eq_on_span'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- If two linear maps are equal on a set `s`, then they are equal on `submodule.span s`.\n\nThis version uses `set.eq_on`, and the hidden argument will expand to `h : x ∈ (span R s : set M)`.\nSee `linear_map.eq_on_span` for a version that takes `h : x ∈ span R s` as an argument. -/\ntheorem eq_on_span' {s : Set M} {f g : «expr →ₛₗ[ ] » M σ₁₂ M₂} (H : Set.EqOn f g s) :\n    Set.EqOn f g (span R s : Set M) :=\n  eqOn_span H\n#align eq_on_span' eq_on_span'\n\n",
 "eq_on_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- If two linear maps are equal on a set `s`, then they are equal on `submodule.span s`.\n\nSee also `linear_map.eq_on_span'` for a version using `set.eq_on`. -/\ntheorem eq_on_span {s : Set M} {f g : «expr →ₛₗ[ ] » M σ₁₂ M₂} (H : Set.EqOn f g s) ⦃x⦄ (h : x ∈ span R s) :\n    f x = g x := by apply span_induction h H <;> simp (config := { contextual := true })\n#align eq_on_span eq_on_span\n\n",
 "disjoint_span_singleton'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem disjoint_span_singleton' {K E : Type _} [DivisionRing K] [AddCommGroup E] [Module K E] {p : Submodule K E}\n    {x : E} (x0 : x ≠ 0) : Disjoint p («expr ∙ » K x) ↔ x ∉ p :=\n  disjoint_span_singleton.trans ⟨fun h₁ h₂ => x0 (h₁ h₂), fun h₁ h₂ => (h₁ h₂).elim⟩\n#align disjoint_span_singleton' disjoint_span_singleton'\n\n",
 "disjoint_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem disjoint_span_singleton {K E : Type _} [DivisionRing K] [AddCommGroup E] [Module K E] {s : Submodule K E}\n    {x : E} : Disjoint s («expr ∙ » K x) ↔ x ∈ s → x = 0 :=\n  by\n  refine' disjoint_def.trans ⟨fun H hx => H x hx <| subset_span <| mem_singleton x, _⟩\n  intro H y hy hyx\n  obtain ⟨c, rfl⟩ := mem_span_singleton.1 hyx\n  by_cases hc : c = 0\n  · rw [hc, zero_smul]\n  · rw [s.smul_mem_iff hc] at hy\n    rw [H hy, smul_zero]\n#align disjoint_span_singleton disjoint_span_singleton\n\n",
 "coord_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem coord_self (x : V) (h : x ≠ 0) :\n    (coord K V x h) (⟨x, Submodule.mem_span_singleton_self x⟩ : «expr ∙ » K x) = 1 := by\n  rw [← to_span_nonzero_singleton_one K V x h, LinearEquiv.symm_apply_apply]\n#align coord_self coord_self\n\n",
 "comap_map_eq_self":
 "theorem comap_map_eq_self {f : F} {p : Submodule R M} (h : LinearMap.ker f ≤ p) : comap f (map f p) = p := by\n  rw [Submodule.comap_map_eq, sup_of_le_left h]\n#align comap_map_eq_self comap_map_eq_self\n\n",
 "comap_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem comap_map_eq (f : F) (p : Submodule R M) : comap f (map f p) = «expr ⊔ » p (LinearMap.ker f) :=\n  by\n  refine' le_antisymm _ (sup_le (le_comap_map _ _) (comap_mono bot_le))\n  rintro x ⟨y, hy, e⟩\n  exact mem_sup.2 ⟨y, hy, x - y, by simpa using sub_eq_zero.2 e.symm, by simp⟩\n#align comap_map_eq comap_map_eq\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[simp]\ntheorem coe_supr_of_directed {ι} [hι : Nonempty ι] (S : ι → Submodule R M) (H : Directed (· ≤ ·) S) :\n    ((supᵢ S : Submodule R M) : Set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S i) :=\n  by\n  refine' subset.antisymm _ (Union_subset <| le_supᵢ S)\n  suffices\n    (span R\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (S i : Set M)) :\n        Set M) ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i)\n    by simpa only [span_Union, span_eq] using this\n  refine' fun x hx => span_induction hx (fun _ => id) _ _ _ <;> simp only [mem_Union, exists_imp]\n  · exact hι.elim fun i => ⟨i, (S i).zero_mem⟩\n  · intro x y i hi j hj\n    rcases H i j with ⟨k, ik, jk⟩\n    exact ⟨k, add_mem (ik hi) (jk hj)⟩\n  · exact fun a x i hi => ⟨i, smul_mem _ a hi⟩\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_supr_of_chain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n@[norm_cast, simp]\ntheorem coe_supr_of_chain (a : «expr →o » ℕ (Submodule R M)) :\n    (↑(«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (a k)) : Set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (a k : Set M) :=\n  coe_supᵢ_of_directed a a.monotone.directed_le\n#align coe_supr_of_chain coe_supr_of_chain\n\n",
 "coe_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem coe_sup : ↑(«expr ⊔ » p p') = (p + p' : Set M) := by\n  ext\n  rw [SetLike.mem_coe, mem_sup, Set.mem_add]\n  simp\n#align coe_sup coe_sup\n\n",
 "coe_scott_continuous":
 "/-- We can regard `coe_supr_of_chain` as the statement that `coe : (submodule R M) → set M` is\nScott continuous for the ω-complete partial order induced by the complete lattice structures. -/\ntheorem coe_scott_continuous : OmegaCompletePartialOrder.Continuous' (coe : Submodule R M → Set M) :=\n  ⟨SetLike.coe_mono, coe_supᵢ_of_chain⟩\n#align coe_scott_continuous coe_scott_continuous\n\n",
 "closure_subset_span":
 "theorem closure_subset_span {s : Set M} : (AddSubmonoid.closure s : Set M) ⊆ span R s :=\n  (@AddSubmonoid.closure_le _ _ _ (span R s).to_add_submonoid).mpr subset_span\n#align closure_subset_span closure_subset_span\n\n",
 "closure_le_to_add_submonoid_span":
 "theorem closure_le_to_add_submonoid_span {s : Set M} : AddSubmonoid.closure s ≤ (span R s).to_add_submonoid :=\n  closure_subset_span\n#align closure_le_to_add_submonoid_span closure_le_to_add_submonoid_span\n\n",
 "apply_mem_span_image_of_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem apply_mem_span_image_of_mem_span [RingHomSurjective σ₁₂] (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) {x : M} {s : Set M}\n    (h : x ∈ Submodule.span R s) : f x ∈ Submodule.span R₂ («expr '' » f s) :=\n  by\n  rw [Submodule.span_image]\n  exact Submodule.mem_map_of_mem h\n#align apply_mem_span_image_of_mem_span apply_mem_span_image_of_mem_span\n\n"}