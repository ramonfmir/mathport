{"strong_rank_condition_iff_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- A ring satisfies the strong rank condition if and only if, for all `n : ℕ`, any linear map\n`(fin (n + 1) → R) →ₗ[R] (fin n → R)` is not injective. -/\ntheorem strong_rank_condition_iff_succ :\n    strong_rank_condition R ↔ ∀ (n : ℕ) (f : «expr →ₗ[ ] » (fin (n + 1) → R) R (fin n → R)), ¬function.injective f :=\n  by\n  refine' ⟨fun h n => fun f hf => _, fun h => ⟨fun n m f hf => _⟩⟩\n  · letI : strong_rank_condition R := h\n    exact nat.not_succ_le_self n (le_of_fin_injective R f hf)\n  · by_contra H\n    exact\n      h m (f.comp (function.extend_by_zero.linear_map R (Fin.castLe (not_le.1 H))))\n        (hf.comp (function.extend_injective (RelEmbedding.injective _) 0))\n#align strong_rank_condition_iff_succ strong_rank_condition_iff_succ\n\n",
 "nontrivial_of_invariant_basis_number":
 "theorem nontrivial_of_invariant_basis_number : nontrivial R :=\n  by\n  by_contra h\n  refine' zero_ne_one (eq_of_fin_equiv R _)\n  haveI := not_nontrivial_iff_subsingleton.1 h\n  haveI : subsingleton (fin 1 → R) := ⟨fun a b => funext fun x => subsingleton.elim _ _⟩\n  refine' { .. } <;>\n    first\n      |·\n        intros\n        exact 0|tidy\n#align nontrivial_of_invariant_basis_number nontrivial_of_invariant_basis_number\n\n",
 "le_of_fin_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem le_of_fin_surjective [rank_condition R] {n m : ℕ} (f : «expr →ₗ[ ] » (fin n → R) R (fin m → R)) :\n    surjective f → m ≤ n :=\n  rank_condition.le_of_fin_surjective f\n#align le_of_fin_surjective le_of_fin_surjective\n\n",
 "le_of_fin_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\ntheorem le_of_fin_injective [strong_rank_condition R] {n m : ℕ} (f : «expr →ₗ[ ] » (fin n → R) R (fin m → R)) :\n    injective f → n ≤ m :=\n  strong_rank_condition.le_of_fin_injective f\n#align le_of_fin_injective le_of_fin_injective\n\n",
 "eq_of_fin_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem eq_of_fin_equiv {n m : ℕ} : «expr ≃ₗ[ ] » (fin n → R) R (fin m → R) → n = m :=\n  invariant_basis_number.eq_of_fin_equiv\n#align eq_of_fin_equiv eq_of_fin_equiv\n\n",
 "card_le_of_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem card_le_of_surjective' [rank_condition R] {α β : Type _} [fintype α] [fintype β]\n    (f : «expr →ₗ[ ] » («expr →₀ » α R) R («expr →₀ » β R)) (i : surjective f) : fintype.card β ≤ fintype.card α :=\n  by\n  let P := finsupp.linear_equiv_fun_on_finite R R β\n  let Q := (finsupp.linear_equiv_fun_on_finite R R α).symm\n  exact\n    card_le_of_surjective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.surjective.comp i).comp Q.surjective)\n#align card_le_of_surjective' card_le_of_surjective'\n\n",
 "card_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem card_le_of_surjective [rank_condition R] {α β : Type _} [fintype α] [fintype β]\n    (f : «expr →ₗ[ ] » (α → R) R (β → R)) (i : surjective f) : fintype.card β ≤ fintype.card α :=\n  by\n  let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin α)\n  let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin β)\n  exact\n    le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map)\n      (((linear_equiv.symm Q).surjective.comp i).comp (linear_equiv.surjective P))\n#align card_le_of_surjective card_le_of_surjective\n\n",
 "card_le_of_injective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem card_le_of_injective' [strong_rank_condition R] {α β : Type _} [fintype α] [fintype β]\n    (f : «expr →ₗ[ ] » («expr →₀ » α R) R («expr →₀ » β R)) (i : injective f) : fintype.card α ≤ fintype.card β :=\n  by\n  let P := finsupp.linear_equiv_fun_on_finite R R β\n  let Q := (finsupp.linear_equiv_fun_on_finite R R α).symm\n  exact card_le_of_injective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.injective.comp i).comp Q.injective)\n#align card_le_of_injective' card_le_of_injective'\n\n",
 "card_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem card_le_of_injective [strong_rank_condition R] {α β : Type _} [fintype α] [fintype β]\n    (f : «expr →ₗ[ ] » (α → R) R (β → R)) (i : injective f) : fintype.card α ≤ fintype.card β :=\n  by\n  let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin α)\n  let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin β)\n  exact\n    le_of_fin_injective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map)\n      (((linear_equiv.symm Q).injective.comp i).comp (linear_equiv.injective P))\n#align card_le_of_injective card_le_of_injective\n\n",
 "card_eq_of_lequiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem card_eq_of_lequiv {α β : Type _} [fintype α] [fintype β] (f : «expr ≃ₗ[ ] » (α → R) R (β → R)) :\n    fintype.card α = fintype.card β :=\n  eq_of_fin_equiv R\n    («expr ≪≫ₗ » ((linear_equiv.fun_congr_left R R (fintype.equiv_fin α)).trans f)\n      (linear_equiv.fun_congr_left R R (fintype.equiv_fin β)).symm)\n#align card_eq_of_lequiv card_eq_of_lequiv\n\n"}