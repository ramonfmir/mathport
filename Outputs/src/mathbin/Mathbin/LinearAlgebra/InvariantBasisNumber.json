{"strongRankCondition_iff_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print strongRankCondition_iff_succ /-\n/-- A ring satisfies the strong rank condition if and only if, for all `n : ℕ`, any linear map\n`(fin (n + 1) → R) →ₗ[R] (fin n → R)` is not injective. -/\ntheorem strongRankCondition_iff_succ :\n    StrongRankCondition R ↔ ∀ (n : ℕ) (f : «expr →ₗ[ ] » (Fin (n + 1) → R) R (Fin n → R)), ¬function.injective f :=\n  by\n  refine' ⟨fun h n => fun f hf => _, fun h => ⟨fun n m f hf => _⟩⟩\n  · letI : StrongRankCondition R := h\n    exact nat.not_succ_le_self n (le_of_fin_injective R f hf)\n  · by_contra H\n    exact\n      h m (f.comp (Function.ExtendByZero.linearMap R (Fin.castLE (not_le.1 H))))\n        (hf.comp (Function.extend_injective (RelEmbedding.injective _) 0))\n#align strong_rank_condition_iff_succ strongRankCondition_iff_succ\n-/\n\n",
 "nontrivial_of_invariantBasisNumber":
 "#print nontrivial_of_invariantBasisNumber /-\ntheorem nontrivial_of_invariantBasisNumber : Nontrivial R :=\n  by\n  by_contra h\n  refine' zero_ne_one (eq_of_fin_equiv R _)\n  haveI := not_nontrivial_iff_subsingleton.1 h\n  haveI : subsingleton (Fin 1 → R) := ⟨fun a b => funext fun x => subsingleton.elim _ _⟩\n  refine' { .. } <;>\n    first\n      |·\n        intros\n        exact 0|tidy\n#align nontrivial_of_invariant_basis_number nontrivial_of_invariantBasisNumber\n-/\n\n",
 "le_of_fin_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print le_of_fin_surjective /-\ntheorem le_of_fin_surjective [RankCondition R] {n m : ℕ} (f : «expr →ₗ[ ] » (Fin n → R) R (Fin m → R)) :\n    surjective f → m ≤ n :=\n  rank_condition.le_of_fin_surjective f\n#align le_of_fin_surjective le_of_fin_surjective\n-/\n\n",
 "le_of_fin_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print le_of_fin_injective /-\n/-\nCopyright (c) 2020 Markus Himmel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Markus Himmel, Scott Morrison\n-/\ntheorem le_of_fin_injective [StrongRankCondition R] {n m : ℕ} (f : «expr →ₗ[ ] » (Fin n → R) R (Fin m → R)) :\n    injective f → n ≤ m :=\n  strong_rank_condition.le_of_fin_injective f\n#align le_of_fin_injective le_of_fin_injective\n-/\n\n",
 "eq_of_fin_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print eq_of_fin_equiv /-\ntheorem eq_of_fin_equiv {n m : ℕ} : «expr ≃ₗ[ ] » (Fin n → R) R (Fin m → R) → n = m :=\n  invariant_basis_number.eq_of_fin_equiv\n#align eq_of_fin_equiv eq_of_fin_equiv\n-/\n\n",
 "card_le_of_surjective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print card_le_of_surjective' /-\ntheorem card_le_of_surjective' [RankCondition R] {α β : Type _} [Fintype α] [Fintype β]\n    (f : «expr →ₗ[ ] » («expr →₀ » α R) R («expr →₀ » β R)) (i : surjective f) : Fintype.card β ≤ Fintype.card α :=\n  by\n  let P := Finsupp.linearEquivFunOnFinite R R β\n  let Q := (Finsupp.linearEquivFunOnFinite R R α).symm\n  exact\n    card_le_of_surjective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.surjective.comp i).comp Q.surjective)\n#align card_le_of_surjective' card_le_of_surjective'\n-/\n\n",
 "card_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print card_le_of_surjective /-\ntheorem card_le_of_surjective [RankCondition R] {α β : Type _} [Fintype α] [Fintype β]\n    (f : «expr →ₗ[ ] » (α → R) R (β → R)) (i : surjective f) : Fintype.card β ≤ Fintype.card α :=\n  by\n  let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin α)\n  let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin β)\n  exact\n    le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map)\n      (((LinearEquiv.symm Q).surjective.comp i).comp (LinearEquiv.surjective P))\n#align card_le_of_surjective card_le_of_surjective\n-/\n\n",
 "card_le_of_injective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print card_le_of_injective' /-\ntheorem card_le_of_injective' [StrongRankCondition R] {α β : Type _} [Fintype α] [Fintype β]\n    (f : «expr →ₗ[ ] » («expr →₀ » α R) R («expr →₀ » β R)) (i : injective f) : Fintype.card α ≤ Fintype.card β :=\n  by\n  let P := Finsupp.linearEquivFunOnFinite R R β\n  let Q := (Finsupp.linearEquivFunOnFinite R R α).symm\n  exact card_le_of_injective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.injective.comp i).comp Q.injective)\n#align card_le_of_injective' card_le_of_injective'\n-/\n\n",
 "card_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print card_le_of_injective /-\ntheorem card_le_of_injective [StrongRankCondition R] {α β : Type _} [Fintype α] [Fintype β]\n    (f : «expr →ₗ[ ] » (α → R) R (β → R)) (i : injective f) : Fintype.card α ≤ Fintype.card β :=\n  by\n  let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin α)\n  let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin β)\n  exact\n    le_of_fin_injective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map)\n      (((LinearEquiv.symm Q).injective.comp i).comp (LinearEquiv.injective P))\n#align card_le_of_injective card_le_of_injective\n-/\n\n",
 "card_eq_of_linearEquiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print card_eq_of_linearEquiv /-\ntheorem card_eq_of_linearEquiv {α β : Type _} [Fintype α] [Fintype β] (f : «expr ≃ₗ[ ] » (α → R) R (β → R)) :\n    Fintype.card α = Fintype.card β :=\n  eq_of_fin_equiv R\n    («expr ≪≫ₗ » ((LinearEquiv.funCongrLeft R R (Fintype.equivFin α)).trans f)\n      (LinearEquiv.funCongrLeft R R (Fintype.equivFin β)).symm)\n#align card_eq_of_lequiv card_eq_of_linearEquiv\n-/\n\n"}