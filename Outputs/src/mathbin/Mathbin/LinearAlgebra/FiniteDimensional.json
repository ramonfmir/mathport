{"surjective_of_nonzero_of_finrank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- We use the `linear_map.compatible_smul` typeclass here, to encompass two situations:\n-- * `A = K`\n-- * `[field K] [algebra K A] [is_scalar_tower K A V] [is_scalar_tower K A W]`\ntheorem surjective_of_nonzero_of_finrank_eq_one {W A : Type _} [Semiring A] [Module A V] [add_comm_group W] [Module K W]\n    [Module A W] [linear_map.compatible_smul V W K A] (h : finrank K W = 1) {f : «expr →ₗ[ ] » V A W} (w : f ≠ 0) :\n    surjective f := by\n  change surjective (f.restrict_scalars K)\n  obtain ⟨v, n⟩ := fun_like.ne_iff.mp w\n  intro z\n  obtain ⟨c, rfl⟩ := (finrank_eq_one_iff_of_nonzero' (f v) n).mp h z\n  exact ⟨«expr • » c v, by simp⟩\n#align surjective_of_nonzero_of_finrank_eq_one surjective_of_nonzero_of_finrank_eq_one\n\n",
 "surjective_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- TODO: generalize to the case where one of `p` and `q` is finite-dimensional.\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem surjective_of_injective [finite_dimensional K V] {f : «expr →ₗ[ ] » V K V} (hinj : injective f) :\n    surjective f := by\n  have h := dim_eq_of_injective _ hinj\n  rw [← finrank_eq_dim, ← finrank_eq_dim, nat_cast_inj] at h\n  exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)\n#align surjective_of_injective surjective_of_injective\n\n",
 "subtype_ne_bot_le_finrank_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem _root_.complete_lattice.independent.subtype_ne_bot_le_finrank_aux [finite_dimensional K V] {ι : Type w}\n    {p : ι → submodule K V} (hp : complete_lattice.independent p) :\n    cardinal.mk { i // p i ≠ «expr⊥» } ≤ (finrank K V : cardinal.{w}) :=\n  by\n  suffices cardinal.lift.{v} (cardinal.mk { i // p i ≠ «expr⊥» }) ≤ cardinal.lift.{v} (finrank K V : cardinal.{w}) by\n    rwa [cardinal.lift_le] at this\n  calc\n    cardinal.lift.{v} (cardinal.mk { i // p i ≠ «expr⊥» }) ≤ cardinal.lift.{w} (module.rank K V) :=\n      hp.subtype_ne_bot_le_rank\n    _ = cardinal.lift.{w} (finrank K V : cardinal.{v}) := by rw [finrank_eq_dim]\n    _ = cardinal.lift.{v} (finrank K V : cardinal.{w}) := by simp\n    \n#align\n  complete_lattice.independent.subtype_ne_bot_le_finrank_aux complete_lattice.independent.subtype_ne_bot_le_finrank_aux\n\n",
 "subtype_ne_bot_le_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `p` is an independent family of subspaces of a finite-dimensional space `V`, then the\nnumber of nontrivial subspaces in the family `p` is bounded above by the dimension of `V`.\n\nNote that the `fintype` hypothesis required here can be provided by\n`complete_lattice.independent.fintype_ne_bot_of_finite_dimensional`. -/\ntheorem _root_.complete_lattice.independent.subtype_ne_bot_le_finrank [finite_dimensional K V] {ι : Type w}\n    {p : ι → submodule K V} (hp : complete_lattice.independent p) [fintype { i // p i ≠ «expr⊥» }] :\n    fintype.card { i // p i ≠ «expr⊥» } ≤ finrank K V := by simpa using hp.subtype_ne_bot_le_finrank_aux\n#align complete_lattice.independent.subtype_ne_bot_le_finrank complete_lattice.independent.subtype_ne_bot_le_finrank\n\n",
 "span_of_finite":
 "/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem span_of_finite {A : set V} (hA : set.finite A) : finite_dimensional K (submodule.span K A) :=\n  iff_fg.1 <| is_noetherian_span_of_finite K hA\n#align span_of_finite span_of_finite\n\n",
 "span_eq_top_of_linear_independent_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem span_eq_top_of_linear_independent_of_card_eq_finrank {ι : Type _} [hι : nonempty ι] [fintype ι] {b : ι → V}\n    (lin_ind : linear_independent K b) (card_eq : fintype.card ι = finrank K V) : span K (Set.range b) = «expr⊤» :=\n  by\n  by_cases fin : finite_dimensional K V\n  · haveI := fin\n    by_contra ne_top\n    have lt_top : span K (Set.range b) < «expr⊤» := lt_of_le_of_ne le_top ne_top\n    exact ne_of_lt (submodule.finrank_lt lt_top) (trans (finrank_span_eq_card lin_ind) card_eq)\n  · exfalso\n    apply ne_of_lt (fintype.card_pos_iff.mpr hι)\n    symm\n    replace fin := (not_iff_not.2 is_noetherian.iff_fg).2 fin\n    calc\n      fintype.card ι = finrank K V := card_eq\n      _ = 0 := dif_neg (mt is_noetherian.iff_dim_lt_aleph_0.mpr fin)\n      \n#align span_eq_top_of_linear_independent_of_card_eq_finrank span_eq_top_of_linear_independent_of_card_eq_finrank\n\n",
 "repr_eq_zero_iff":
 "@[simp]\ntheorem basis_unique.repr_eq_zero_iff {ι : Type _} [unique ι] {h : finrank K V = 1} {v : V} {i : ι} :\n    (basis_unique ι h).repr v i = 0 ↔ v = 0 :=\n  ⟨fun hv => (basis_unique ι h).repr.map_eq_zero_iff.mp (finsupp.ext fun j => subsingleton.elim i j ▸ hv), fun hv => by\n    rw [hv, linear_equiv.map_zero, finsupp.zero_apply]⟩\n#align basis_unique.repr_eq_zero_iff basis_unique.repr_eq_zero_iff\n\n",
 "range_basis_singleton":
 "@[simp]\ntheorem range_basis_singleton (ι : Type _) [unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0) :\n    Set.range (basis_singleton ι h v hv) = {v} := by rw [Set.range_unique, basis_singleton_apply]\n#align range_basis_singleton range_basis_singleton\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If the domain of a surjective linear map is finite dimensional, the codomain must be as well. -/\ntheorem of_surjective (f : «expr →ₗ[ ] » V K V₂) (w : function.surjective f) [finite_dimensional K V] :\n    finite_dimensional K V₂ :=\n  module.finite.of_surjective f w\n#align of_surjective of_surjective\n\n",
 "of_injective_endo_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_injective_endo_right_inv (f : «expr →ₗ[ ] » V K V) (h_inj : injective f) :\n    f * (of_injective_endo f h_inj).symm = 1 :=\n  linear_map.ext <| (of_injective_endo f h_inj).apply_symm_apply\n#align of_injective_endo_right_inv of_injective_endo_right_inv\n\n",
 "of_injective_endo_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_injective_endo_left_inv (f : «expr →ₗ[ ] » V K V) (h_inj : injective f) :\n    ((of_injective_endo f h_inj).symm : «expr →ₗ[ ] » V K V) * f = 1 :=\n  linear_map.ext <| (of_injective_endo f h_inj).symm_apply_apply\n#align of_injective_endo_left_inv of_injective_endo_left_inv\n\n",
 "of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- If the codomain of an injective linear map is finite dimensional, the domain must be as well. -/\ntheorem of_injective (f : «expr →ₗ[ ] » V K V₂) (w : function.injective f) [finite_dimensional K V₂] :\n    finite_dimensional K V :=\n  have : is_noetherian K V₂ := is_noetherian.iff_fg.mpr ‹_›\n  module.finite.of_injective f w\n#align of_injective of_injective\n\n",
 "of_fintype_basis":
 "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem of_fintype_basis {ι : Type w} [Finite ι] (h : basis ι K V) : finite_dimensional K V :=\n  by\n  cases nonempty_fintype ι\n  exact\n    ⟨⟨finset.univ.image h, by\n        convert h.span_eq\n        simp⟩⟩\n#align of_fintype_basis of_fintype_basis\n\n",
 "of_finite_basis":
 "/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem of_finite_basis {ι : Type w} {s : set ι} (h : basis s K V) (hs : set.finite s) : finite_dimensional K V :=\n  haveI := hs.fintype\n  of_fintype_basis h\n#align of_finite_basis of_finite_basis\n\n",
 "not_linear_independent_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem not_linear_independent_of_infinite {ι : Type w} [inf : Infinite ι] [finite_dimensional K V] (v : ι → V) :\n    ¬linear_independent K v := by\n  intro h_lin_indep\n  have : ¬cardinal.aleph_0 ≤ cardinal.mk ι := not_le.mpr (lt_aleph_0_of_linear_independent h_lin_indep)\n  have : cardinal.aleph_0 ≤ cardinal.mk ι := infinite_iff.mp inf\n  contradiction\n#align not_linear_independent_of_infinite not_linear_independent_of_infinite\n\n",
 "nonempty_linear_equiv_of_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two finite-dimensional vector spaces are isomorphic if they have the same (finite) dimension.\n-/\ntheorem nonempty_linear_equiv_of_finrank_eq [finite_dimensional K V] [finite_dimensional K V₂]\n    (cond : finrank K V = finrank K V₂) : nonempty («expr ≃ₗ[ ] » V K V₂) :=\n  nonempty_linear_equiv_of_lift_dim_eq <| by simp only [← finrank_eq_dim, cond, lift_nat_cast]\n#align nonempty_linear_equiv_of_finrank_eq nonempty_linear_equiv_of_finrank_eq\n\n",
 "nonempty_linear_equiv_iff_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two finite-dimensional vector spaces are isomorphic if and only if they have the same (finite)\ndimension.\n-/\ntheorem nonempty_linear_equiv_iff_finrank_eq [finite_dimensional K V] [finite_dimensional K V₂] :\n    nonempty («expr ≃ₗ[ ] » V K V₂) ↔ finrank K V = finrank K V₂ :=\n  ⟨fun ⟨h⟩ => h.finrank_eq, fun h => nonempty_linear_equiv_of_finrank_eq h⟩\n#align nonempty_linear_equiv_iff_finrank_eq nonempty_linear_equiv_iff_finrank_eq\n\n",
 "mul_eq_one_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem mul_eq_one_of_mul_eq_one [finite_dimensional K V] {f g : «expr →ₗ[ ] » V K V} (hfg : f * g = 1) : g * f = 1 :=\n  by\n  have ginj : injective g :=\n    has_left_inverse.injective ⟨f, fun x => show (f * g) x = (1 : «expr →ₗ[ ] » V K V) x by rw [hfg] <;> rfl⟩\n  let ⟨i, hi⟩ := g.exists_right_inverse_of_surjective (range_eq_top.2 (injective_iff_surjective.1 ginj))\n  have : f * (g * i) = f * 1 := congr_arg _ hi\n  rw [← mul_assoc, hfg, one_mul, mul_one] at this <;> rwa [← this]\n#align mul_eq_one_of_mul_eq_one mul_eq_one_of_mul_eq_one\n\n",
 "mul_eq_one_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem mul_eq_one_comm [finite_dimensional K V] {f g : «expr →ₗ[ ] » V K V} : f * g = 1 ↔ g * f = 1 :=\n  ⟨mul_eq_one_of_mul_eq_one, mul_eq_one_of_mul_eq_one⟩\n#align mul_eq_one_comm mul_eq_one_comm\n\n",
 "lt_aleph_0_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem lt_aleph_0_of_linear_independent {ι : Type w} [finite_dimensional K V] {v : ι → V}\n    (h : linear_independent K v) : cardinal.mk ι < cardinal.aleph_0 :=\n  by\n  apply cardinal.lift_lt.1\n  apply lt_of_le_of_lt\n  apply cardinal_lift_le_dim_of_linear_independent h\n  rw [← finrank_eq_dim, cardinal.lift_aleph_0, cardinal.lift_nat_cast]\n  apply cardinal.nat_lt_aleph_0\n#align lt_aleph_0_of_linear_independent lt_aleph_0_of_linear_independent\n\n",
 "linear_equiv_of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv_of_injective_apply [finite_dimensional K V] [finite_dimensional K V₂] {f : «expr →ₗ[ ] » V K V₂}\n    (hf : injective f) (hdim : finrank K V = finrank K V₂) (x : V) : f.linear_equiv_of_injective hf hdim x = f x :=\n  rfl\n#align linear_equiv_of_injective_apply linear_equiv_of_injective_apply\n\n",
 "ker_pow_le_ker_pow_finrank":
 "theorem ker_pow_le_ker_pow_finrank [finite_dimensional K V] (f : End K V) (m : ℕ) :\n    (f ^ m).ker ≤ (f ^ finrank K V).ker :=\n  by\n  by_cases h_cases : m < finrank K V\n  · rw [← add_tsub_cancel_of_le (nat.le_of_lt h_cases), add_comm, pow_add]\n    apply linear_map.ker_le_ker_comp\n  · rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)]\n    exact le_rfl\n#align ker_pow_le_ker_pow_finrank ker_pow_le_ker_pow_finrank\n\n",
 "ker_pow_eq_ker_pow_finrank_of_le":
 "theorem ker_pow_eq_ker_pow_finrank_of_le [finite_dimensional K V] {f : End K V} {m : ℕ} (hm : finrank K V ≤ m) :\n    (f ^ m).ker = (f ^ finrank K V).ker :=\n  by\n  obtain ⟨k, h_k_le, hk⟩ : ∃ k, k ≤ finrank K V ∧ linear_map.ker (f ^ k) = linear_map.ker (f ^ k.succ) :=\n    exists_ker_pow_eq_ker_pow_succ f\n  calc\n    (f ^ m).ker = (f ^ (k + (m - k))).ker := by rw [add_tsub_cancel_of_le (h_k_le.trans hm)]\n    _ = (f ^ k).ker := by rw [ker_pow_constant hk _]\n    _ = (f ^ (k + (finrank K V - k))).ker := ker_pow_constant hk (finrank K V - k)\n    _ = (f ^ finrank K V).ker := by rw [add_tsub_cancel_of_le h_k_le]\n    \n#align ker_pow_eq_ker_pow_finrank_of_le ker_pow_eq_ker_pow_finrank_of_le\n\n",
 "ker_pow_constant":
 "theorem ker_pow_constant {f : End K V} {k : ℕ} (h : (f ^ k).ker = (f ^ k.succ).ker) :\n    ∀ m, (f ^ k).ker = (f ^ (k + m)).ker\n  | 0 => by simp\n  | m + 1 => by\n    apply le_antisymm\n    · rw [add_comm, pow_add]\n      apply linear_map.ker_le_ker_comp\n    · rw [ker_pow_constant m, add_comm m 1, ← add_assoc, pow_add, pow_add f k m]\n      change linear_map.ker ((f ^ (k + 1)).comp (f ^ m)) ≤ linear_map.ker ((f ^ k).comp (f ^ m))\n      rw [linear_map.ker_comp, linear_map.ker_comp, h, nat.add_one]\n      exact le_rfl\n#align ker_pow_constant ker_pow_constant\n\n",
 "ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank [finite_dimensional K V] [finite_dimensional K V₂]\n    (H : finrank K V = finrank K V₂) {f : «expr →ₗ[ ] » V K V₂} : f.ker = «expr⊥» ↔ f.range = «expr⊤» := by\n  rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]\n#align ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank\n\n",
 "ker_eq_bot_iff_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ker_eq_bot_iff_range_eq_top [finite_dimensional K V] {f : «expr →ₗ[ ] » V K V} :\n    f.ker = «expr⊥» ↔ f.range = «expr⊤» := by rw [range_eq_top, ker_eq_bot, injective_iff_surjective]\n#align ker_eq_bot_iff_range_eq_top ker_eq_bot_iff_range_eq_top\n\n",
 "is_unit_iff_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_unit_iff_range_eq_top [finite_dimensional K V] (f : «expr →ₗ[ ] » V K V) : is_unit f ↔ f.range = «expr⊤» :=\n  by rw [is_unit_iff_ker_eq_bot, ker_eq_bot_iff_range_eq_top]\n#align is_unit_iff_range_eq_top is_unit_iff_range_eq_top\n\n",
 "is_unit_iff_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_unit_iff_ker_eq_bot [finite_dimensional K V] (f : «expr →ₗ[ ] » V K V) : is_unit f ↔ f.ker = «expr⊥» :=\n  by\n  constructor\n  · rintro ⟨u, rfl⟩\n    exact linear_map.ker_eq_bot_of_inverse u.inv_mul\n  · intro h_inj\n    rw [ker_eq_bot] at h_inj\n    exact\n      ⟨⟨f, (linear_equiv.of_injective_endo f h_inj).symm.to_linear_map,\n          linear_equiv.of_injective_endo_right_inv f h_inj, linear_equiv.of_injective_endo_left_inv f h_inj⟩,\n        rfl⟩\n#align is_unit_iff_ker_eq_bot is_unit_iff_ker_eq_bot\n\n",
 "is_simple_order_of_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra.is_simple_order_of_finrank (hr : finrank F E = 2) : IsSimpleOrder (subalgebra F E) :=\n  let i := nontrivial_of_finrank_pos (zero_lt_two.trans_eq hr.symm)\n  { to_nontrivial :=\n      ⟨⟨«expr⊥», «expr⊤», fun h => by cases hr.symm.trans (subalgebra.bot_eq_top_iff_finrank_eq_one.1 h)⟩⟩\n    eq_bot_or_eq_top := by\n      intro S\n      haveI : finite_dimensional F E := finite_dimensional_of_finrank_eq_succ hr\n      haveI : finite_dimensional F S := finite_dimensional.finite_dimensional_submodule S.to_submodule\n      have : finrank F S ≤ 2 := hr ▸ S.to_submodule.finrank_le\n      have : 0 < finrank F S := finrank_pos_iff.mpr infer_instance\n      interval_cases finrank F S\n      · left\n        exact subalgebra.eq_bot_of_finrank_one h\n      · right\n        rw [← hr] at h\n        rw [← algebra.to_submodule_eq_top]\n        exact submodule.eq_top_of_finrank_eq h }\n#align subalgebra.is_simple_order_of_finrank subalgebra.is_simple_order_of_finrank\n\n",
 "is_simple_module_of_finrank_eq_one":
 "/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/\ntheorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A] [IsScalarTower K A V]\n    (h : finrank K V = 1) : IsSimpleOrder (submodule A V) :=\n  by\n  haveI := nontrivial_of_finrank_eq_succ h\n  refine' ⟨fun S => or_iff_not_imp_left.2 fun hn => _⟩\n  rw [← restrict_scalars_inj K] at hn⊢\n  haveI := finite_dimensional_of_finrank_eq_succ h\n  refine' eq_top_of_finrank_eq ((submodule.finrank_le _).antisymm _)\n  simpa only [h, finrank_bot] using submodule.finrank_strict_mono (Ne.bot_lt hn)\n#align is_simple_module_of_finrank_eq_one is_simple_module_of_finrank_eq_one\n\n",
 "injective_iff_surjective_of_finrank_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem injective_iff_surjective_of_finrank_eq_finrank [finite_dimensional K V] [finite_dimensional K V₂]\n    (H : finrank K V = finrank K V₂) {f : «expr →ₗ[ ] » V K V₂} : function.injective f ↔ function.surjective f :=\n  by\n  have := finrank_range_add_finrank_ker f\n  rw [← ker_eq_bot, ← range_eq_top]; refine' ⟨fun h => _, fun h => _⟩\n  · rw [h, finrank_bot, add_zero, H] at this\n    exact eq_top_of_finrank_eq this\n  · rw [h, finrank_top, H] at this\n    exact finrank_eq_zero.1 (add_right_injective _ this)\n#align injective_iff_surjective_of_finrank_eq_finrank injective_iff_surjective_of_finrank_eq_finrank\n\n",
 "injective_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem injective_iff_surjective [finite_dimensional K V] {f : «expr →ₗ[ ] » V K V} : injective f ↔ surjective f :=\n  ⟨surjective_of_injective, fun hsurj =>\n    let ⟨g, hg⟩ := f.exists_right_inverse_of_surjective (range_eq_top.2 hsurj)\n    have : function.right_inverse g f := linear_map.ext_iff.1 hg\n    (leftInverse_of_surjective_of_rightInverse (surjective_of_injective this.injective) this).injective⟩\n#align injective_iff_surjective injective_iff_surjective\n\n",
 "fintype_card_le_finrank_of_linear_independent":
 "theorem fintype_card_le_finrank_of_linear_independent [finite_dimensional K V] {ι : Type _} [fintype ι] {b : ι → V}\n    (h : linear_independent K b) : fintype.card ι ≤ finrank K V := by\n  simpa using cardinal_mk_le_finrank_of_linear_independent h\n#align fintype_card_le_finrank_of_linear_independent fintype_card_le_finrank_of_linear_independent\n\n",
 "finset_card_le_finrank_of_linear_independent":
 "theorem finset_card_le_finrank_of_linear_independent [finite_dimensional K V] {b : Finset V}\n    (h : linear_independent K (fun x => x : b → V)) : b.card ≤ finrank K V :=\n  by\n  rw [← fintype.card_coe]\n  exact fintype_card_le_finrank_of_linear_independent h\n#align finset_card_le_finrank_of_linear_independent finset_card_le_finrank_of_linear_independent\n\n",
 "finrank_zero_iff_forall_zero":
 "theorem finrank_zero_iff_forall_zero [finite_dimensional K V] : finrank K V = 0 ↔ ∀ x : V, x = 0 :=\n  finrank_zero_iff.trans (subsingleton_iff_forall_eq 0)\n#align finrank_zero_iff_forall_zero finrank_zero_iff_forall_zero\n\n",
 "finrank_zero_iff":
 "/-- A finite dimensional space has zero `finrank` iff it is a subsingleton.\nThis is the `finrank` version of `dim_zero_iff`. -/\ntheorem finrank_zero_iff [finite_dimensional K V] : finrank K V = 0 ↔ subsingleton V :=\n  iff.trans\n    (by\n      rw [← finrank_eq_dim]\n      norm_cast)\n    (@dim_zero_iff K V _ _ _ _ _)\n#align finrank_zero_iff finrank_zero_iff\n\n",
 "finrank_strict_mono":
 "theorem finrank_strict_mono [finite_dimensional K V] : strict_mono fun s : submodule K V => finrank K s := fun s t =>\n  finrank_lt_finrank_of_lt\n#align finrank_strict_mono finrank_strict_mono\n\n",
 "finrank_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem finrank_span_singleton {v : V} (hv : v ≠ 0) : finrank K («expr ∙ » K v) = 1 :=\n  by\n  apply le_antisymm\n  · exact finrank_span_le_card ({v} : set V)\n  · rw [Nat.succ_le_iff, finrank_pos_iff]\n    use ⟨v, mem_span_singleton_self v⟩, 0\n    simp [hv]\n#align finrank_span_singleton finrank_span_singleton\n\n",
 "finrank_range_add_finrank_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- rank-nullity theorem : the dimensions of the kernel and the range of a linear map add up to\nthe dimension of the source space. -/\ntheorem finrank_range_add_finrank_ker [finite_dimensional K V] (f : «expr →ₗ[ ] » V K V₂) :\n    finrank K f.range + finrank K f.ker = finrank K V :=\n  by\n  rw [← f.quot_ker_equiv_range.finrank_eq]\n  exact submodule.finrank_quotient_add_finrank _\n#align finrank_range_add_finrank_ker finrank_range_add_finrank_ker\n\n",
 "finrank_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- The dimension of a quotient is bounded by the dimension of the ambient space. -/\ntheorem finrank_quotient_le [finite_dimensional K V] (s : submodule K V) : finrank K («expr ⧸ » V s) ≤ finrank K V := by\n  simpa only [cardinal.nat_cast_le, ← finrank_eq_dim] using (mkq s).dim_le_of_surjective (surjective_quot_mk _)\n#align finrank_quotient_le finrank_quotient_le\n\n",
 "finrank_quotient_add_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem finrank_quotient_add_finrank [finite_dimensional K V] (s : submodule K V) :\n    finrank K («expr ⧸ » V s) + finrank K s = finrank K V :=\n  by\n  have := dim_quotient_add_dim s\n  rw [← finrank_eq_dim, ← finrank_eq_dim, ← finrank_eq_dim] at this\n  exact_mod_cast this\n#align finrank_quotient_add_finrank finrank_quotient_add_finrank\n\n",
 "finrank_pos_iff_exists_ne_zero":
 "/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem finrank_pos_iff_exists_ne_zero [finite_dimensional K V] : 0 < finrank K V ↔ ∃ x : V, x ≠ 0 :=\n  iff.trans\n    (by\n      rw [← finrank_eq_dim]\n      norm_cast)\n    (@dim_pos_iff_exists_ne_zero K V _ _ _ _ _)\n#align finrank_pos_iff_exists_ne_zero finrank_pos_iff_exists_ne_zero\n\n",
 "finrank_pos_iff":
 "/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/\ntheorem finrank_pos_iff [finite_dimensional K V] : 0 < finrank K V ↔ nontrivial V :=\n  iff.trans\n    (by\n      rw [← finrank_eq_dim]\n      norm_cast)\n    (@dim_pos_iff_nontrivial K V _ _ _ _ _)\n#align finrank_pos_iff finrank_pos_iff\n\n",
 "finrank_pos":
 "/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem finrank_pos [finite_dimensional K V] [h : nontrivial V] : 0 < finrank K V :=\n  finrank_pos_iff.mpr h\n#align finrank_pos finrank_pos\n\n",
 "finrank_of_infinite_dimensional":
 "theorem finrank_of_infinite_dimensional (h : ¬finite_dimensional K V) : finrank K V = 0 :=\n  dif_neg <| mt is_noetherian.iff_dim_lt_aleph_0.2 <| (not_iff_not.2 iff_fg).2 h\n#align finrank_of_infinite_dimensional finrank_of_infinite_dimensional\n\n",
 "finrank_mono":
 "theorem set.finrank_mono [finite_dimensional K V] {s t : set V} (h : s ⊆ t) : s.finrank K ≤ t.finrank K :=\n  finrank_mono (span_mono h)\n#align set.finrank_mono set.finrank_mono\n\n",
 "finrank_map_subtype_eq":
 "@[simp]\ntheorem finrank_map_subtype_eq (p : submodule K V) (q : submodule K p) :\n    finite_dimensional.finrank K (q.map p.subtype) = finite_dimensional.finrank K q :=\n  (submodule.equiv_subtype_map p q).symm.finrank_eq\n#align finrank_map_subtype_eq finrank_map_subtype_eq\n\n",
 "finrank_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Pushforwards of finite-dimensional submodules have a smaller finrank. -/\ntheorem finrank_map_le (f : «expr →ₗ[ ] » V K V₂) (p : submodule K V) [finite_dimensional K p] :\n    finrank K (p.map f) ≤ finrank K p := by\n  simpa [← finrank_eq_dim, -module.free.finrank_eq_rank] using lift_dim_map_le f p\n#align finrank_map_le finrank_map_le\n\n",
 "finrank_lt_finrank_of_lt":
 "theorem finrank_lt_finrank_of_lt {s t : submodule K V} [finite_dimensional K t] (hst : s < t) :\n    finrank K s < finrank K t :=\n  (comap_subtype_equiv_of_le hst.le).finrank_eq.symm.trans_lt <|\n    finrank_lt (le_top.lt_of_ne <| hst.not_le ∘ comap_subtype_eq_top.1)\n#align finrank_lt_finrank_of_lt finrank_lt_finrank_of_lt\n\n",
 "finrank_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The dimension of a strict submodule is strictly bounded by the dimension of the ambient\nspace. -/\ntheorem finrank_lt [finite_dimensional K V] {s : submodule K V} (h : s < «expr⊤») : finrank K s < finrank K V :=\n  by\n  rw [← s.finrank_quotient_add_finrank, add_comm]\n  exact Nat.lt_add_of_zero_lt_left _ _ (finrank_pos_iff.mpr (quotient.nontrivial_of_lt_top _ h))\n#align finrank_lt finrank_lt\n\n",
 "finrank_le_one_iff_top_is_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem module.finrank_le_one_iff_top_is_principal [finite_dimensional K V] :\n    finrank K V ≤ 1 ↔ («expr⊤» : submodule K V).is_principal := by\n  rw [← module.rank_le_one_iff_top_is_principal, ← finrank_eq_dim, ← cardinal.nat_cast_le, Nat.cast_one]\n#align module.finrank_le_one_iff_top_is_principal module.finrank_le_one_iff_top_is_principal\n\n",
 "finrank_le_one_iff_is_principal":
 "theorem submodule.finrank_le_one_iff_is_principal (W : submodule K V) [finite_dimensional K W] :\n    finrank K W ≤ 1 ↔ W.is_principal := by\n  rw [← W.rank_le_one_iff_is_principal, ← finrank_eq_dim, ← cardinal.nat_cast_le, Nat.cast_one]\n#align submodule.finrank_le_one_iff_is_principal submodule.finrank_le_one_iff_is_principal\n\n",
 "finrank_le_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- Not sure why this aren't found automatically.\n/-- A finite dimensional module has dimension at most 1 iff\nthere is some `v : V` so every vector is a multiple of `v`.\n-/\ntheorem finrank_le_one_iff [finite_dimensional K V] : finrank K V ≤ 1 ↔ ∃ v : V, ∀ w : V, ∃ c : K, «expr • » c v = w :=\n  by\n  fconstructor\n  · intro h\n    by_cases h' : finrank K V = 0\n    · use 0\n      intro w\n      use 0\n      haveI := finrank_zero_iff.mp h'\n      apply subsingleton.elim\n    · replace h' := zero_lt_iff.mpr h'\n      have : finrank K V = 1 := by linarith\n      obtain ⟨v, -, p⟩ := finrank_eq_one_iff'.mp this\n      use ⟨v, p⟩\n  · rintro ⟨v, p⟩\n    exact finrank_le_one v p\n#align finrank_le_one_iff finrank_le_one_iff\n\n",
 "finrank_le_finrank_of_le":
 "theorem finrank_le_finrank_of_le {s t : submodule K V} [finite_dimensional K t] (hst : s ≤ t) :\n    finrank K s ≤ finrank K t :=\n  calc\n    finrank K s = finrank K (comap t.subtype s) := (comap_subtype_equiv_of_le hst).finrank_eq.symm\n    _ ≤ finrank K t := finrank_le _\n    \n#align finrank_le_finrank_of_le finrank_le_finrank_of_le\n\n",
 "finrank_le_finrank_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem finrank_le_finrank_of_injective [finite_dimensional K V] [finite_dimensional K V₂] {f : «expr →ₗ[ ] » V K V₂}\n    (hf : function.injective f) : finrank K V ≤ finrank K V₂ :=\n  calc\n    finrank K V = finrank K f.range + finrank K f.ker := (finrank_range_add_finrank_ker f).symm\n    _ = finrank K f.range := by rw [ker_eq_bot.2 hf, finrank_bot, add_zero]\n    _ ≤ finrank K V₂ := submodule.finrank_le _\n    \n#align finrank_le_finrank_of_injective finrank_le_finrank_of_injective\n\n",
 "finrank_le":
 "/-- The dimension of a submodule is bounded by the dimension of the ambient space. -/\ntheorem finrank_le [finite_dimensional K V] (s : submodule K V) : finrank K s ≤ finrank K V := by\n  simpa only [cardinal.nat_cast_le, ← finrank_eq_dim] using s.subtype.dim_le_of_injective (injective_subtype s)\n#align finrank_le finrank_le\n\n",
 "finrank_eq_zero_of_dim_eq_zero":
 "theorem finrank_eq_zero_of_dim_eq_zero [finite_dimensional K V] (h : module.rank K V = 0) : finrank K V = 0 :=\n  by\n  convert finrank_eq_dim K V\n  rw [h]; norm_cast\n#align finrank_eq_zero_of_dim_eq_zero finrank_eq_zero_of_dim_eq_zero\n\n",
 "finrank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem finrank_eq_zero {S : submodule K V} [finite_dimensional K S] : finrank K S = 0 ↔ S = «expr⊥» := by\n  rw [← dim_eq_zero, ← finrank_eq_dim, ← @Nat.cast_zero cardinal, cardinal.nat_cast_inj]\n#align finrank_eq_zero finrank_eq_zero\n\n",
 "finrank_eq_one_iff_of_nonzero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A module with a nonzero vector `v` has dimension 1 iff every vector is a multiple of `v`.\n-/\ntheorem finrank_eq_one_iff_of_nonzero' (v : V) (nz : v ≠ 0) : finrank K V = 1 ↔ ∀ w : V, ∃ c : K, «expr • » c v = w :=\n  by\n  rw [finrank_eq_one_iff_of_nonzero v nz]\n  apply span_singleton_eq_top_iff\n#align finrank_eq_one_iff_of_nonzero' finrank_eq_one_iff_of_nonzero'\n\n",
 "finrank_eq_one_iff_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\n-/\ntheorem finrank_eq_one_iff_of_nonzero (v : V) (nz : v ≠ 0) : finrank K V = 1 ↔ span K ({v} : set V) = «expr⊤» :=\n  ⟨fun h => by simpa using (basis_singleton PUnit h v nz).span_eq, fun s =>\n    finrank_eq_card_basis\n      (basis.mk (linear_independent_singleton nz)\n        (by\n          convert s\n          simp))⟩\n#align finrank_eq_one_iff_of_nonzero finrank_eq_one_iff_of_nonzero\n\n",
 "finrank_eq_one_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A module has dimension 1 iff there is some nonzero `v : V` so every vector is a multiple of `v`.\n-/\ntheorem finrank_eq_one_iff' : finrank K V = 1 ↔ ∃ (v : V)(n : v ≠ 0), ∀ w : V, ∃ c : K, «expr • » c v = w :=\n  by\n  convert finrank_eq_one_iff PUnit\n  simp only [exists_prop, eq_iff_iff, ne.def]\n  convert (basis.basis_singleton_iff PUnit).symm\n  funext v\n  simp\n  infer_instance; infer_instance\n#align finrank_eq_one_iff' finrank_eq_one_iff'\n\n",
 "finrank_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem subalgebra.finrank_eq_one_iff [nontrivial E] {S : subalgebra F E} : finrank F S = 1 ↔ S = «expr⊥» :=\n  ⟨subalgebra.eq_bot_of_finrank_one, fun h => h.symm ▸ subalgebra.finrank_bot⟩\n#align subalgebra.finrank_eq_one_iff subalgebra.finrank_eq_one_iff\n\n",
 "finrank_eq_dim":
 "/-- In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its\n`finrank`. -/\ntheorem finrank_eq_dim [finite_dimensional K V] : (finrank K V : cardinal.{v}) = module.rank K V :=\n  by\n  letI : is_noetherian K V := iff_fg.2 infer_instance\n  rw [finrank, cast_to_nat_of_lt_aleph_0 (dim_lt_aleph_0 K V)]\n#align finrank_eq_dim finrank_eq_dim\n\n",
 "finrank_eq_card_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If a vector space is finite-dimensional, then the cardinality of any basis is equal to its\n`finrank`. -/\ntheorem finrank_eq_card_basis' [finite_dimensional K V] {ι : Type w} (h : basis ι K V) :\n    (finrank K V : cardinal.{w}) = cardinal.mk ι :=\n  by\n  haveI : is_noetherian K V := iff_fg.2 infer_instance\n  haveI : fintype ι := fintype_basis_index h\n  rw [cardinal.mk_fintype, finrank_eq_card_basis h]\n#align finrank_eq_card_basis' finrank_eq_card_basis'\n\n",
 "finrank_add_eq_of_is_compl":
 "theorem finrank_add_eq_of_is_compl [finite_dimensional K V] {U W : submodule K V} (h : IsCompl U W) :\n    finrank K U + finrank K W = finrank K V :=\n  by\n  rw [← dim_sup_add_dim_inf_eq, h.codisjoint.eq_top, h.disjoint.eq_bot, finrank_bot, add_zero]\n  exact finrank_top\n#align finrank_add_eq_of_is_compl finrank_add_eq_of_is_compl\n\n",
 "finite_of_finite":
 "theorem finite_of_finite [Finite K] [finite_dimensional K V] : Finite V :=\n  by\n  cases nonempty_fintype K\n  haveI := fintype_of_fintype K V\n  infer_instance\n#align finite_of_finite finite_of_finite\n\n",
 "finite_dimensional_to_submodule":
 "/-- A `subalgebra` is `finite_dimensional` iff it is finite_dimensional as a submodule. -/\ntheorem subalgebra.finite_dimensional_to_submodule {S : subalgebra F E} :\n    finite_dimensional F S.to_submodule ↔ finite_dimensional F S :=\n  iff.rfl\n#align subalgebra.finite_dimensional_to_submodule subalgebra.finite_dimensional_to_submodule\n\n",
 "finite_dimensional_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem finite_dimensional_of_surjective [finite_dimensional K V] (f : «expr →ₗ[ ] » V K V₂) (hf : f.range = «expr⊤») :\n    finite_dimensional K V₂ :=\n  module.finite.of_surjective f <| range_eq_top.1 hf\n#align finite_dimensional_of_surjective finite_dimensional_of_surjective\n\n",
 "finite_dimensional_of_le":
 "/-- A submodule contained in a finite-dimensional submodule is\nfinite-dimensional. -/\ntheorem finite_dimensional_of_le {S₁ S₂ : submodule K V} [finite_dimensional K S₂] (h : S₁ ≤ S₂) :\n    finite_dimensional K S₁ :=\n  haveI : is_noetherian K S₂ := iff_fg.2 infer_instance\n  iff_fg.1 (is_noetherian.iff_dim_lt_aleph_0.2 (lt_of_le_of_lt (dim_le_of_submodule _ _ h) (dim_lt_aleph_0 K S₂)))\n#align finite_dimensional_of_le finite_dimensional_of_le\n\n",
 "finite_dimensional_of_finrank_eq_succ":
 "theorem finite_dimensional_of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) : finite_dimensional K V :=\n  finite_dimensional_of_finrank <| by rw [hn] <;> exact n.succ_pos\n#align finite_dimensional_of_finrank_eq_succ finite_dimensional_of_finrank_eq_succ\n\n",
 "finite_dimensional_of_finrank":
 "theorem finite_dimensional_of_finrank (h : 0 < finrank K V) : finite_dimensional K V :=\n  by\n  contrapose h\n  simp [finrank_of_infinite_dimensional h]\n#align finite_dimensional_of_finrank finite_dimensional_of_finrank\n\n",
 "finite_dimensional_of_dim_eq_zero":
 "-- TODO: generalize to free modules over general rings.\ntheorem finite_dimensional_of_dim_eq_zero (h : module.rank K V = 0) : finite_dimensional K V :=\n  finite_dimensional_of_dim_eq_nat <| h.trans Nat.cast_zero.symm\n#align finite_dimensional_of_dim_eq_zero finite_dimensional_of_dim_eq_zero\n\n",
 "finite_dimensional_of_dim_eq_one":
 "theorem finite_dimensional_of_dim_eq_one (h : module.rank K V = 1) : finite_dimensional K V :=\n  finite_dimensional_of_dim_eq_nat <| h.trans Nat.cast_one.symm\n#align finite_dimensional_of_dim_eq_one finite_dimensional_of_dim_eq_one\n\n",
 "finite_dimensional_of_dim_eq_nat":
 "theorem finite_dimensional_of_dim_eq_nat {n : ℕ} (h : module.rank K V = n) : finite_dimensional K V :=\n  by\n  rw [finite_dimensional, ← is_noetherian.iff_fg, is_noetherian.iff_dim_lt_aleph_0, h]\n  exact nat_lt_aleph_0 n\n#align finite_dimensional_of_dim_eq_nat finite_dimensional_of_dim_eq_nat\n\n",
 "finite_dimensional_iff_of_rank_eq_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem finite_dimensional_iff_of_rank_eq_nsmul {W} [add_comm_group W] [Module K W] {n : ℕ} (hn : n ≠ 0)\n    (hVW : module.rank K V = «expr • » n (module.rank K W)) : finite_dimensional K V ↔ finite_dimensional K W := by\n  simp only [finite_dimensional, ← is_noetherian.iff_fg, is_noetherian.iff_dim_lt_aleph_0, hVW,\n    cardinal.nsmul_lt_aleph_0_iff_of_ne_zero hn]\n#align finite_dimensional_iff_of_rank_eq_nsmul finite_dimensional_iff_of_rank_eq_nsmul\n\n",
 "finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Finite dimensionality is preserved under linear equivalence. -/\nprotected theorem finite_dimensional (f : «expr ≃ₗ[ ] » V K V₂) [finite_dimensional K V] : finite_dimensional K V₂ :=\n  module.finite.equiv f\n#align finite_dimensional finite_dimensional\n\n",
 "finite":
 "theorem _root_.linear_independent.finite [finite_dimensional K V] {b : set V}\n    (h : linear_independent K fun x : b => (x : V)) : b.finite :=\n  cardinal.lt_aleph_0_iff_set_finite.mp (finite_dimensional.lt_aleph_0_of_linear_independent h)\n#align linear_independent.finite linear_independent.finite\n\n",
 "fg_iff_finite_dimensional":
 "/-- A submodule is finitely generated if and only if it is finite-dimensional -/\ntheorem fg_iff_finite_dimensional (s : submodule K V) : s.fg ↔ finite_dimensional K s :=\n  ⟨fun h => module.finite_def.2 <| (fg_top s).2 h, fun h => (fg_top s).1 <| module.finite_def.1 h⟩\n#align fg_iff_finite_dimensional fg_iff_finite_dimensional\n\n",
 "fact_finite_dimensional_of_finrank_eq_succ":
 "/-- We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare\nthis as a local instance where needed. -/\ntheorem fact_finite_dimensional_of_finrank_eq_succ (n : ℕ) [fact (finrank K V = n + 1)] : finite_dimensional K V :=\n  finite_dimensional_of_finrank <| by convert nat.succ_pos n <;> apply fact.out\n#align fact_finite_dimensional_of_finrank_eq_succ fact_finite_dimensional_of_finrank_eq_succ\n\n",
 "exists_relation_sum_zero_pos_coefficient_of_dim_succ_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A slight strengthening of `exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card`\navailable when working over an ordered field:\nwe can ensure a positive coefficient, not just a nonzero coefficient.\n-/\ntheorem exists_relation_sum_zero_pos_coefficient_of_dim_succ_lt_card [finite_dimensional L W] {t : Finset W}\n    (h : finrank L W + 1 < t.card) :\n    ∃ f : W → L,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e) e) =\n          0 ∧\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f e) = 0 ∧\n          ∃ x ∈ t, 0 < f x :=\n  by\n  obtain ⟨f, sum, total, nonzero⟩ := exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card h\n  exact ⟨f, sum, total, exists_pos_of_sum_zero_of_exists_nonzero f total nonzero⟩\n#align\n  exists_relation_sum_zero_pos_coefficient_of_dim_succ_lt_card exists_relation_sum_zero_pos_coefficient_of_dim_succ_lt_card\n\n",
 "exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If a finset has cardinality larger than `finrank + 1`,\nthen there is a nontrivial linear relation amongst its elements,\nsuch that the coefficients of the relation sum to zero.\n-/\ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card [finite_dimensional K V] {t : Finset V}\n    (h : finrank K V + 1 < t.card) :\n    ∃ f : V → K,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e) e) =\n          0 ∧\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f e) = 0 ∧\n          ∃ x ∈ t, f x ≠ 0 :=\n  by\n  -- Pick an element x₀ ∈ t,\n  have card_pos : 0 < t.card := lt_trans (nat.succ_pos _) h\n  obtain ⟨x₀, m⟩ := (finset.card_pos.1 card_pos).bex\n  -- and apply the previous lemma to the {xᵢ - x₀}\n  let shift : «expr ↪ » V V := ⟨fun x => x - x₀, sub_left_injective⟩\n  let t' := (t.erase x₀).map shift\n  have h' : finrank K V < t'.card :=\n    by\n    simp only [t', card_map, finset.card_erase_of_mem m]\n    exact nat.lt_pred_iff.mpr h\n  -- to obtain a function `g`.\n  obtain ⟨g, gsum, x₁, x₁_mem, nz⟩ := exists_nontrivial_relation_of_dim_lt_card h'\n  -- Then obtain `f` by translating back by `x₀`,\n  -- and setting the value of `f` at `x₀` to ensure `∑ e in t, f e = 0`.\n  let f : V → K := fun z =>\n    if z = x₀ then\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase x₀)\n          (g (z - x₀))\n    else g (z - x₀)\n  refine' ⟨f, _, _, _⟩\n  -- After this, it's a matter of verifiying the properties,\n  -- based on the corresponding properties for `g`.\n  · show\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n          («expr • » (f e) e) =\n        0\n    -- We prove this by splitting off the `x₀` term of the sum,\n    -- which is itself a sum over `t.erase x₀`,\n    -- combining the two sums, and\n    -- observing that after reindexing we have exactly\n    -- ∑ (x : V) in t', g x • x = 0.\n    simp only [f]\n    conv_lhs =>\n      apply_congr\n      skip\n      rw [ite_smul]\n    rw [finset.sum_ite]\n    conv =>\n      congr\n      congr\n      apply_congr\n      simp [filter_eq', m]\n    conv =>\n      congr\n      congr\n      skip\n      apply_congr\n      simp [filter_ne']\n    rw [sum_singleton, neg_smul, add_comm, ← sub_eq_add_neg, sum_smul, ← sum_sub_distrib]\n    simp only [← smul_sub]\n    -- At the end we have to reindex the sum, so we use `change` to\n    -- express the summand using `shift`.\n    change\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase x₀)\n          ((fun e => «expr • » (g e) e) (shift x)) =\n        0\n    rw [← sum_map _ shift]\n    exact gsum\n  · show finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f e) = 0\n    -- Again we split off the `x₀` term,\n    -- observing that it exactly cancels the other terms.\n    rw [← insert_erase m, sum_insert (not_mem_erase x₀ t)]\n    dsimp [f]\n    rw [if_pos rfl]\n    conv_lhs =>\n      congr\n      skip\n      apply_congr\n      skip\n      rw [if_neg (show x ≠ x₀ from (mem_erase.mp H).1)]\n    exact neg_add_self _\n  · show ∃ (x : V)(H : x ∈ t), f x ≠ 0\n    -- We can use x₁ + x₀.\n    refine' ⟨x₁ + x₀, _, _⟩\n    · rw [Finset.mem_map] at x₁_mem\n      rcases x₁_mem with ⟨x₁, x₁_mem, rfl⟩\n      rw [mem_erase] at x₁_mem\n      simp only [x₁_mem, sub_add_cancel, Function.Embedding.coeFn_mk]\n    · dsimp only [f]\n      rwa [if_neg, add_sub_cancel]\n      rw [add_left_eq_self]\n      rintro rfl\n      simpa only [sub_eq_zero, exists_prop, Finset.mem_map, embedding.coe_fn_mk, eq_self_iff_true, mem_erase, not_true,\n        exists_eq_right, ne.def, false_and_iff] using x₁_mem\n#align exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card\n\n",
 "exists_nontrivial_relation_of_dim_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a finset has cardinality larger than the dimension of the space,\nthen there is a nontrivial linear relation amongst its elements.\n-/\ntheorem exists_nontrivial_relation_of_dim_lt_card [finite_dimensional K V] {t : Finset V} (h : finrank K V < t.card) :\n    ∃ f : V → K,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e) e) =\n          0 ∧\n        ∃ x ∈ t, f x ≠ 0 :=\n  by\n  have := mt finset_card_le_finrank_of_linear_independent (by simpa using h)\n  rw [not_linear_independent_iff] at this\n  obtain ⟨s, g, sum, z, zm, nonzero⟩ := this\n  -- Now we have to extend `g` to all of `t`, then to all of `V`.\n  let f : V → K := fun x => if h : x ∈ t then if (⟨x, h⟩ : t) ∈ s then g ⟨x, h⟩ else 0 else 0\n  -- and finally clean up the mess caused by the extension.\n  refine' ⟨f, _, _⟩\n  · dsimp [f]\n    rw [← sum]\n    fapply sum_bij_ne_zero fun v hvt _ => (⟨v, hvt⟩ : { v // v ∈ t })\n    · intro v hvt H\n      dsimp\n      rw [dif_pos hvt] at H\n      contrapose! H\n      rw [if_neg H, zero_smul]\n    · intro _ _ _ _ _ _\n      exact subtype.mk.inj\n    · intro b hbs hb\n      use b\n      simpa only [hbs, exists_prop, dif_pos, Finset.mk_coe, and_true_iff, if_true, Finset.coe_mem, eq_self_iff_true,\n        exists_prop_of_true, ne.def] using hb\n    · intro a h₁\n      dsimp\n      rw [dif_pos h₁]\n      intro h₂\n      rw [if_pos]\n      contrapose! h₂\n      rw [if_neg h₂, zero_smul]\n  · refine' ⟨z, z.2, _⟩\n    dsimp only [f]\n    erw [dif_pos z.2, if_pos] <;> rwa [subtype.coe_eta]\n#align exists_nontrivial_relation_of_dim_lt_card exists_nontrivial_relation_of_dim_lt_card\n\n",
 "exists_ker_pow_eq_ker_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem exists_ker_pow_eq_ker_pow_succ [finite_dimensional K V] (f : End K V) :\n    ∃ k : ℕ, k ≤ finrank K V ∧ (f ^ k).ker = (f ^ k.succ).ker := by\n  classical\n    by_contra h_contra\n    simp_rw [not_exists, not_and] at h_contra\n    have h_le_ker_pow : ∀ n : ℕ, n ≤ (finrank K V).succ → n ≤ finrank K (f ^ n).ker :=\n      by\n      intro n hn\n      induction' n with n ih\n      · exact zero_le (finrank _ _)\n      · have h_ker_lt_ker : (f ^ n).ker < (f ^ n.succ).ker :=\n          by\n          refine' lt_of_le_of_ne _ (h_contra n (nat.le_of_succ_le_succ hn))\n          rw [pow_succ]\n          apply linear_map.ker_le_ker_comp\n        have h_finrank_lt_finrank : finrank K (f ^ n).ker < finrank K (f ^ n.succ).ker := by\n          apply submodule.finrank_lt_finrank_of_lt h_ker_lt_ker\n        calc\n          n.succ ≤ (finrank K («expr↥ » (linear_map.ker (f ^ n)))).succ := nat.succ_le_succ (ih (nat.le_of_succ_le hn))\n          _ ≤ finrank K («expr↥ » (linear_map.ker (f ^ n.succ))) := nat.succ_le_of_lt h_finrank_lt_finrank\n          \n    have h_le_finrank_V : ∀ n, finrank K (f ^ n).ker ≤ finrank K V := fun n => submodule.finrank_le _\n    have h_any_n_lt : ∀ n, n ≤ (finrank K V).succ → n ≤ finrank K V := fun n hn =>\n      (h_le_ker_pow n hn).trans (h_le_finrank_V n)\n    show false\n    exact nat.not_succ_le_self _ (h_any_n_lt (finrank K V).succ (finrank K V).succ.le_refl)\n#align exists_ker_pow_eq_ker_pow_succ exists_ker_pow_eq_ker_pow_succ\n\n",
 "eq_top_of_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_of_finrank_eq [finite_dimensional K V] {S : submodule K V} (h : finrank K S = finrank K V) :\n    S = «expr⊤» :=\n  finite_dimensional.eq_of_le_of_finrank_eq le_top (by simp [h, finrank_top])\n#align eq_top_of_finrank_eq eq_top_of_finrank_eq\n\n",
 "eq_top_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_of_disjoint [finite_dimensional K V] (s t : submodule K V)\n    (hdim : finrank K s + finrank K t = finrank K V) (hdisjoint : Disjoint s t) : «expr ⊔ » s t = «expr⊤» :=\n  by\n  have h_finrank_inf : finrank K («expr↥ » («expr ⊓ » s t)) = 0 :=\n    by\n    rw [disjoint_iff_inf_le, le_bot_iff] at hdisjoint\n    rw [hdisjoint, finrank_bot]\n  apply eq_top_of_finrank_eq\n  rw [← hdim]\n  convert s.dim_sup_add_dim_inf_eq t\n  rw [h_finrank_inf]\n  rfl\n#align eq_top_of_disjoint eq_top_of_disjoint\n\n",
 "eq_of_le_of_finrank_le":
 "theorem eq_of_le_of_finrank_le {S₁ S₂ : submodule K V} [finite_dimensional K S₂] (hle : S₁ ≤ S₂)\n    (hd : finrank K S₂ ≤ finrank K S₁) : S₁ = S₂ :=\n  by\n  rw [← linear_equiv.finrank_eq (submodule.comap_subtype_equiv_of_le hle)] at hd\n  exact\n    le_antisymm hle\n      (submodule.comap_subtype_eq_top.1\n        (eq_top_of_finrank_eq (le_antisymm (comap (submodule.subtype S₂) S₁).finrank_le hd)))\n#align eq_of_le_of_finrank_le eq_of_le_of_finrank_le\n\n",
 "eq_of_le_of_finrank_eq":
 "/-- If a submodule is less than or equal to a finite-dimensional\nsubmodule with the same dimension, they are equal. -/\ntheorem eq_of_le_of_finrank_eq {S₁ S₂ : submodule K V} [finite_dimensional K S₂] (hle : S₁ ≤ S₂)\n    (hd : finrank K S₁ = finrank K S₂) : S₁ = S₂ :=\n  eq_of_le_of_finrank_le hle hd.ge\n#align eq_of_le_of_finrank_eq eq_of_le_of_finrank_eq\n\n",
 "eq_bot_of_finrank_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem subalgebra.eq_bot_of_finrank_one {S : subalgebra F E} (h : finrank F S = 1) : S = «expr⊥» :=\n  subalgebra.eq_bot_of_dim_le_one <|\n    by\n    haveI := finite_dimensional_of_finrank_eq_succ h\n    rw [← finrank_eq_dim, h, Nat.cast_one]\n#align subalgebra.eq_bot_of_finrank_one subalgebra.eq_bot_of_finrank_one\n\n",
 "eq_bot_of_dim_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem subalgebra.eq_bot_of_dim_le_one {S : subalgebra F E} (h : module.rank F S ≤ 1) : S = «expr⊥» :=\n  by\n  nontriviality E\n  obtain ⟨m, hm, he⟩ := cardinal.exists_nat_eq_of_le_nat (h.trans_eq nat.cast_one.symm)\n  haveI := finite_dimensional_of_dim_eq_nat he\n  rw [← not_bot_lt_iff, ← subalgebra.to_submodule.lt_iff_lt]\n  haveI := S.to_submodule_equiv.symm.finite_dimensional\n  refine' fun hl => (submodule.finrank_lt_finrank_of_lt hl).not_le (nat_cast_le.1 _)\n  iterate 2 rw [subalgebra.finrank_to_submodule, finrank_eq_dim]\n  exact h.trans_eq subalgebra.dim_bot.symm\n#align subalgebra.eq_bot_of_dim_le_one subalgebra.eq_bot_of_dim_le_one\n\n",
 "dim_sup_add_dim_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- The sum of the dimensions of s + t and s ∩ t is the sum of the dimensions of s and t -/\ntheorem dim_sup_add_dim_inf_eq (s t : submodule K V) [finite_dimensional K s] [finite_dimensional K t] :\n    finrank K («expr↥ » («expr ⊔ » s t)) + finrank K («expr↥ » («expr ⊓ » s t)) =\n      finrank K («expr↥ » s) + finrank K («expr↥ » t) :=\n  by\n  have key :\n    module.rank K («expr↥ » («expr ⊔ » s t)) + module.rank K («expr↥ » («expr ⊓ » s t)) =\n      module.rank K s + module.rank K t :=\n    dim_sup_add_dim_inf_eq s t\n  repeat' rw [← finrank_eq_dim] at key\n  norm_cast  at key\n  exact key\n#align dim_sup_add_dim_inf_eq dim_sup_add_dim_inf_eq\n\n",
 "dim_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem dim_eq_zero {S : submodule K V} : module.rank K S = 0 ↔ S = «expr⊥» :=\n  ⟨fun h =>\n    (submodule.eq_bot_iff _).2 fun x hx =>\n      congr_arg subtype.val <|\n        ((submodule.eq_bot_iff _).1 <| eq.symm <| bot_eq_top_of_dim_eq_zero h) ⟨x, hx⟩ submodule.mem_top,\n    fun h => by rw [h, dim_bot]⟩\n#align dim_eq_zero dim_eq_zero\n\n",
 "dim_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem subalgebra.dim_eq_one_iff [nontrivial E] {S : subalgebra F E} : module.rank F S = 1 ↔ S = «expr⊥» :=\n  ⟨fun h => subalgebra.eq_bot_of_dim_le_one h.le, fun h => h.symm ▸ subalgebra.dim_bot⟩\n#align subalgebra.dim_eq_one_iff subalgebra.dim_eq_one_iff\n\n",
 "dim_add_le_dim_add_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem dim_add_le_dim_add_dim (s t : submodule K V) [finite_dimensional K s] [finite_dimensional K t] :\n    finrank K («expr ⊔ » s t : submodule K V) ≤ finrank K s + finrank K t :=\n  by\n  rw [← dim_sup_add_dim_inf_eq]\n  exact self_le_add_right _ _\n#align dim_add_le_dim_add_dim dim_add_le_dim_add_dim\n\n",
 "comp_eq_id_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem comp_eq_id_comm [finite_dimensional K V] {f g : «expr →ₗ[ ] » V K V} : f.comp g = id ↔ g.comp f = id :=\n  mul_eq_one_comm\n#align comp_eq_id_comm comp_eq_id_comm\n\n",
 "coe_set_basis_of_linear_independent_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_set_basis_of_linear_independent_of_card_eq_finrank {s : set V} [nonempty s] [fintype s]\n    (lin_ind : linear_independent K (coe : s → V)) (card_eq : s.to_finset.card = finrank K V) :\n    «expr⇑ » (set_basis_of_linear_independent_of_card_eq_finrank lin_ind card_eq) = coe :=\n  basis.coe_mk _ _\n#align coe_set_basis_of_linear_independent_of_card_eq_finrank coe_set_basis_of_linear_independent_of_card_eq_finrank\n\n",
 "coe_of_injective_endo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_of_injective_endo (f : «expr →ₗ[ ] » V K V) (h_inj : injective f) :\n    «expr⇑ » (of_injective_endo f h_inj) = f :=\n  rfl\n#align coe_of_injective_endo coe_of_injective_endo\n\n",
 "coe_finset_basis_of_linear_independent_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_finset_basis_of_linear_independent_of_card_eq_finrank {s : Finset V} (hs : s.nonempty)\n    (lin_ind : linear_independent K (coe : s → V)) (card_eq : s.card = finrank K V) :\n    «expr⇑ » (finset_basis_of_linear_independent_of_card_eq_finrank hs lin_ind card_eq) = coe :=\n  basis.coe_mk _ _\n#align\n  coe_finset_basis_of_linear_independent_of_card_eq_finrank coe_finset_basis_of_linear_independent_of_card_eq_finrank\n\n",
 "coe_basis_of_linear_independent_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_basis_of_linear_independent_of_card_eq_finrank {ι : Type _} [nonempty ι] [fintype ι] {b : ι → V}\n    (lin_ind : linear_independent K b) (card_eq : fintype.card ι = finrank K V) :\n    «expr⇑ » (basis_of_linear_independent_of_card_eq_finrank lin_ind card_eq) = b :=\n  basis.coe_mk _ _\n#align coe_basis_of_linear_independent_of_card_eq_finrank coe_basis_of_linear_independent_of_card_eq_finrank\n\n",
 "cardinal_mk_le_finrank_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_mk_le_finrank_of_linear_independent [finite_dimensional K V] {ι : Type w} {b : ι → V}\n    (h : linear_independent K b) : cardinal.mk ι ≤ finrank K V :=\n  by\n  rw [← lift_le.{_, max v w}]\n  simpa [← finrank_eq_dim, -module.free.finrank_eq_rank] using\n    cardinal_lift_le_dim_of_linear_independent.{_, _, _, max v w} h\n#align cardinal_mk_le_finrank_of_linear_independent cardinal_mk_le_finrank_of_linear_independent\n\n",
 "cardinal_mk_eq_cardinal_mk_field_pow_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_mk_eq_cardinal_mk_field_pow_dim (K V : Type u) [DivisionRing K] [add_comm_group V] [Module K V]\n    [finite_dimensional K V] : cardinal.mk V = cardinal.mk K ^ module.rank K V :=\n  by\n  let s := basis.of_vector_space_index K V\n  let hs := basis.of_vector_space K V\n  calc\n    cardinal.mk V = cardinal.mk («expr →₀ » s K) := quotient.sound ⟨hs.repr.to_equiv⟩\n    _ = cardinal.mk (s → K) := quotient.sound ⟨finsupp.equiv_fun_on_finite⟩\n    _ = _ := by rw [← cardinal.lift_inj.1 hs.mk_eq_dim, cardinal.power_def]\n    \n#align cardinal_mk_eq_cardinal_mk_field_pow_dim cardinal_mk_eq_cardinal_mk_field_pow_dim\n\n",
 "cardinal_lt_aleph_0_of_finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem cardinal_lt_aleph_0_of_finite_dimensional (K V : Type u) [DivisionRing K] [add_comm_group V] [Module K V]\n    [Finite K] [finite_dimensional K V] : cardinal.mk V < cardinal.aleph_0 :=\n  by\n  letI : is_noetherian K V := is_noetherian.iff_fg.2 infer_instance\n  rw [cardinal_mk_eq_cardinal_mk_field_pow_dim K V]\n  exact cardinal.power_lt_aleph_0 (cardinal.lt_aleph_0_of_finite K) (is_noetherian.dim_lt_aleph_0 K V)\n#align cardinal_lt_aleph_0_of_finite_dimensional cardinal_lt_aleph_0_of_finite_dimensional\n\n",
 "bot_eq_top_of_dim_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem bot_eq_top_of_dim_eq_zero (h : module.rank K V = 0) : («expr⊥» : submodule K V) = «expr⊤» :=\n  by\n  haveI := finite_dimensional_of_dim_eq_zero h\n  apply eq_top_of_finrank_eq\n  rw [finrank_bot, finrank_eq_zero_of_dim_eq_zero h]\n#align bot_eq_top_of_dim_eq_zero bot_eq_top_of_dim_eq_zero\n\n",
 "bot_eq_top_iff_finrank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra.bot_eq_top_iff_finrank_eq_one [nontrivial E] :\n    («expr⊥» : subalgebra F E) = «expr⊤» ↔ finrank F E = 1 := by\n  rw [← finrank_top, ← subalgebra_top_finrank_eq_submodule_top_finrank, subalgebra.finrank_eq_one_iff, eq_comm]\n#align subalgebra.bot_eq_top_iff_finrank_eq_one subalgebra.bot_eq_top_iff_finrank_eq_one\n\n",
 "bot_eq_top_iff_dim_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra.bot_eq_top_iff_dim_eq_one [nontrivial E] :\n    («expr⊥» : subalgebra F E) = «expr⊤» ↔ module.rank F E = 1 := by\n  rw [← dim_top, ← subalgebra_top_dim_eq_submodule_top_dim, subalgebra.dim_eq_one_iff, eq_comm]\n#align subalgebra.bot_eq_top_iff_dim_eq_one subalgebra.bot_eq_top_iff_dim_eq_one\n\n",
 "basis_singleton_apply":
 "@[simp]\ntheorem basis_singleton_apply (ι : Type _) [unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0) (i : ι) :\n    basis_singleton ι h v hv i = v := by\n  cases unique.uniq ‹unique ι› i\n  simp [basis_singleton]\n#align basis_singleton_apply basis_singleton_apply\n\n"}