{"surjective_of_nonzero_of_finrank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print surjective_of_nonzero_of_finrank_eq_one /-\n-- We use the `linear_map.compatible_smul` typeclass here, to encompass two situations:\n-- * `A = K`\n-- * `[field K] [algebra K A] [is_scalar_tower K A V] [is_scalar_tower K A W]`\ntheorem surjective_of_nonzero_of_finrank_eq_one {W A : Type _} [Semiring A] [Module A V] [AddCommGroup W] [Module K W]\n    [Module A W] [LinearMap.CompatibleSMul V W K A] (h : finrank K W = 1) {f : «expr →ₗ[ ] » V A W} (w : f ≠ 0) :\n    surjective f := by\n  change surjective (f.restrict_scalars K)\n  obtain ⟨v, n⟩ := fun_like.ne_iff.mp w\n  intro z\n  obtain ⟨c, rfl⟩ := (finrank_eq_one_iff_of_nonzero' (f v) n).mp h z\n  exact ⟨«expr • » c v, by simp⟩\n#align surjective_of_nonzero_of_finrank_eq_one surjective_of_nonzero_of_finrank_eq_one\n-/\n\n",
 "surjective_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- TODO: generalize to the case where one of `p` and `q` is finite-dimensional.\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem surjective_of_injective [FiniteDimensional K V] {f : «expr →ₗ[ ] » V K V} (hinj : injective f) : surjective f :=\n  by\n  have h := rank_eq_of_injective _ hinj\n  rw [← finrank_eq_rank, ← finrank_eq_rank, nat_cast_inj] at h\n  exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)\n#align surjective_of_injective surjective_of_injective\n\n",
 "subtype_ne_bot_le_finrank_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux /-\ntheorem CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux [FiniteDimensional K V] {ι : Type w}\n    {p : ι → Submodule K V} (hp : CompleteLattice.Independent p) :\n    cardinal.mk { i // p i ≠ «expr⊥» } ≤ (finrank K V : Cardinal.{w}) :=\n  by\n  suffices Cardinal.lift.{v} (cardinal.mk { i // p i ≠ «expr⊥» }) ≤ Cardinal.lift.{v} (finrank K V : Cardinal.{w}) by\n    rwa [Cardinal.lift_le] at this\n  calc\n    Cardinal.lift.{v} (cardinal.mk { i // p i ≠ «expr⊥» }) ≤ Cardinal.lift.{w} (Module.rank K V) :=\n      hp.subtype_ne_bot_le_rank\n    _ = Cardinal.lift.{w} (finrank K V : Cardinal.{v}) := by rw [finrank_eq_rank]\n    _ = Cardinal.lift.{v} (finrank K V : Cardinal.{w}) := by simp\n    \n#align complete_lattice.independent.subtype_ne_bot_le_finrank_aux CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux\n-/\n\n",
 "subtype_ne_bot_le_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print CompleteLattice.Independent.subtype_ne_bot_le_finrank /-\n/-- If `p` is an independent family of subspaces of a finite-dimensional space `V`, then the\nnumber of nontrivial subspaces in the family `p` is bounded above by the dimension of `V`.\n\nNote that the `fintype` hypothesis required here can be provided by\n`complete_lattice.independent.fintype_ne_bot_of_finite_dimensional`. -/\ntheorem CompleteLattice.Independent.subtype_ne_bot_le_finrank [FiniteDimensional K V] {ι : Type w}\n    {p : ι → Submodule K V} (hp : CompleteLattice.Independent p) [Fintype { i // p i ≠ «expr⊥» }] :\n    Fintype.card { i // p i ≠ «expr⊥» } ≤ finrank K V := by simpa using hp.subtype_ne_bot_le_finrank_aux\n#align complete_lattice.independent.subtype_ne_bot_le_finrank CompleteLattice.Independent.subtype_ne_bot_le_finrank\n-/\n\n",
 "span_of_finite":
 "/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem span_of_finite {A : Set V} (hA : Set.Finite A) : FiniteDimensional K (Submodule.span K A) :=\n  iff_fg.1 <| isNoetherian_span_of_finite K hA\n#align span_of_finite span_of_finite\n\n",
 "span_eq_top_of_linearIndependent_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print span_eq_top_of_linearIndependent_of_card_eq_finrank /-\ntheorem span_eq_top_of_linearIndependent_of_card_eq_finrank {ι : Type _} [hι : Nonempty ι] [Fintype ι] {b : ι → V}\n    (lin_ind : LinearIndependent K b) (card_eq : Fintype.card ι = finrank K V) : span K (Set.range b) = «expr⊤» :=\n  by\n  by_cases fin : FiniteDimensional K V\n  · haveI := Fin\n    by_contra ne_top\n    have lt_top : span K (Set.range b) < «expr⊤» := lt_of_le_of_ne le_top ne_top\n    exact ne_of_lt (Submodule.finrank_lt lt_top) (trans (finrank_span_eq_card lin_ind) card_eq)\n  · exfalso\n    apply ne_of_lt (fintype.card_pos_iff.mpr hι)\n    symm\n    replace fin := (not_iff_not.2 IsNoetherian.iff_fg).2 Fin\n    calc\n      Fintype.card ι = finrank K V := card_eq\n      _ = 0 := dif_neg (mt is_noetherian.iff_rank_lt_aleph_0.mpr Fin)\n      \n#align span_eq_top_of_linear_independent_of_card_eq_finrank span_eq_top_of_linearIndependent_of_card_eq_finrank\n-/\n\n",
 "repr_eq_zero_iff":
 "@[simp]\ntheorem basis_unique.repr_eq_zero_iff {ι : Type _} [Unique ι] {h : finrank K V = 1} {v : V} {i : ι} :\n    (basisUnique ι h).repr v i = 0 ↔ v = 0 :=\n  ⟨fun hv => (basisUnique ι h).repr.map_eq_zero_iff.mp (Finsupp.ext fun j => subsingleton.elim i j ▸ hv), fun hv => by\n    rw [hv, LinearEquiv.map_zero, Finsupp.zero_apply]⟩\n#align basis_unique.repr_eq_zero_iff basis_unique.repr_eq_zero_iff\n\n",
 "rank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print rank_eq_zero /-\n@[simp]\ntheorem rank_eq_zero {S : Submodule K V} : Module.rank K S = 0 ↔ S = «expr⊥» :=\n  ⟨fun h =>\n    (Submodule.eq_bot_iff _).2 fun x hx =>\n      congr_arg Subtype.val <|\n        ((Submodule.eq_bot_iff _).1 <| Eq.symm <| bot_eq_top_of_rank_eq_zero h) ⟨x, hx⟩ Submodule.mem_top,\n    fun h => by rw [h, rank_bot]⟩\n#align rank_eq_zero rank_eq_zero\n-/\n\n",
 "rank_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.rank_eq_one_iff /-\n@[simp]\ntheorem Subalgebra.rank_eq_one_iff [Nontrivial E] {S : Subalgebra F E} : Module.rank F S = 1 ↔ S = «expr⊥» :=\n  ⟨fun h => Subalgebra.eq_bot_of_rank_le_one h.le, fun h => h.symm ▸ Subalgebra.rank_bot⟩\n#align subalgebra.rank_eq_one_iff Subalgebra.rank_eq_one_iff\n-/\n\n",
 "range_basis_singleton":
 "@[simp]\ntheorem range_basis_singleton (ι : Type _) [Unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0) :\n    Set.range (basisSingleton ι h v hv) = {v} := by rw [Set.range_unique, basis_singleton_apply]\n#align range_basis_singleton range_basis_singleton\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If the domain of a surjective linear map is finite dimensional, the codomain must be as well. -/\ntheorem of_surjective (f : «expr →ₗ[ ] » V K V₂) (w : function.surjective f) [FiniteDimensional K V] :\n    FiniteDimensional K V₂ :=\n  Module.Finite.of_surjective f w\n#align of_surjective of_surjective\n\n",
 "of_injective_endo_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_injective_endo_right_inv (f : «expr →ₗ[ ] » V K V) (h_inj : injective f) :\n    f * (ofInjectiveEndo f h_inj).symm = 1 :=\n  LinearMap.ext <| (ofInjectiveEndo f h_inj).apply_symm_apply\n#align of_injective_endo_right_inv of_injective_endo_right_inv\n\n",
 "of_injective_endo_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_injective_endo_left_inv (f : «expr →ₗ[ ] » V K V) (h_inj : injective f) :\n    ((ofInjectiveEndo f h_inj).symm : «expr →ₗ[ ] » V K V) * f = 1 :=\n  LinearMap.ext <| (ofInjectiveEndo f h_inj).symm_apply_apply\n#align of_injective_endo_left_inv of_injective_endo_left_inv\n\n",
 "of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- If the codomain of an injective linear map is finite dimensional, the domain must be as well. -/\ntheorem of_injective (f : «expr →ₗ[ ] » V K V₂) (w : function.injective f) [FiniteDimensional K V₂] :\n    FiniteDimensional K V :=\n  have : IsNoetherian K V₂ := IsNoetherian.iff_fg.mpr ‹_›\n  Module.Finite.of_injective f w\n#align of_injective of_injective\n\n",
 "of_fintype_basis":
 "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem of_fintype_basis {ι : Type w} [Finite ι] (h : Basis ι K V) : FiniteDimensional K V :=\n  by\n  cases nonempty_fintype ι\n  exact\n    ⟨⟨finset.univ.image h, by\n        convert h.span_eq\n        simp⟩⟩\n#align of_fintype_basis of_fintype_basis\n\n",
 "of_finite_basis":
 "/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem of_finite_basis {ι : Type w} {s : Set ι} (h : Basis s K V) (hs : Set.Finite s) : FiniteDimensional K V :=\n  haveI := hs.fintype\n  of_fintype_basis h\n#align of_finite_basis of_finite_basis\n\n",
 "not_linear_independent_of_infinite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem not_linear_independent_of_infinite {ι : Type w} [inf : Infinite ι] [FiniteDimensional K V] (v : ι → V) :\n    ¬LinearIndependent K v := by\n  intro h_lin_indep\n  have : ¬cardinal.aleph_0 ≤ cardinal.mk ι := not_le.mpr (lt_aleph_0_of_linear_independent h_lin_indep)\n  have : cardinal.aleph_0 ≤ cardinal.mk ι := infinite_iff.mp inf\n  contradiction\n#align not_linear_independent_of_infinite not_linear_independent_of_infinite\n\n",
 "mul_eq_one_of_mul_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem mul_eq_one_of_mul_eq_one [FiniteDimensional K V] {f g : «expr →ₗ[ ] » V K V} (hfg : f * g = 1) : g * f = 1 :=\n  by\n  have ginj : injective g :=\n    has_left_inverse.injective ⟨f, fun x => show (f * g) x = (1 : «expr →ₗ[ ] » V K V) x by rw [hfg] <;> rfl⟩\n  let ⟨i, hi⟩ := g.exists_right_inverse_of_surjective (range_eq_top.2 (injective_iff_surjective.1 ginj))\n  have : f * (g * i) = f * 1 := congr_arg _ hi\n  rw [← mul_assoc, hfg, one_mul, mul_one] at this <;> rwa [← this]\n#align mul_eq_one_of_mul_eq_one mul_eq_one_of_mul_eq_one\n\n",
 "mul_eq_one_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem mul_eq_one_comm [FiniteDimensional K V] {f g : «expr →ₗ[ ] » V K V} : f * g = 1 ↔ g * f = 1 :=\n  ⟨mul_eq_one_of_mul_eq_one, mul_eq_one_of_mul_eq_one⟩\n#align mul_eq_one_comm mul_eq_one_comm\n\n",
 "lt_aleph_0_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem lt_aleph_0_of_linear_independent {ι : Type w} [FiniteDimensional K V] {v : ι → V} (h : LinearIndependent K v) :\n    cardinal.mk ι < cardinal.aleph_0 := by\n  apply Cardinal.lift_lt.1\n  apply lt_of_le_of_lt\n  apply cardinal_lift_le_rank_of_linearIndependent h\n  rw [← finrank_eq_rank, Cardinal.lift_aleph0, Cardinal.lift_natCast]\n  apply Cardinal.nat_lt_aleph0\n#align lt_aleph_0_of_linear_independent lt_aleph_0_of_linear_independent\n\n",
 "linear_equiv_of_injective_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv_of_injective_apply [FiniteDimensional K V] [FiniteDimensional K V₂] {f : «expr →ₗ[ ] » V K V₂}\n    (hf : injective f) (hdim : finrank K V = finrank K V₂) (x : V) : f.linear_equiv_of_injective hf hdim x = f x :=\n  rfl\n#align linear_equiv_of_injective_apply linear_equiv_of_injective_apply\n\n",
 "ker_pow_le_ker_pow_finrank":
 "theorem ker_pow_le_ker_pow_finrank [FiniteDimensional K V] (f : End K V) (m : ℕ) :\n    (f ^ m).ker ≤ (f ^ finrank K V).ker :=\n  by\n  by_cases h_cases : m < finrank K V\n  · rw [← add_tsub_cancel_of_le (nat.le_of_lt h_cases), add_comm, pow_add]\n    apply LinearMap.ker_le_ker_comp\n  · rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)]\n    exact le_rfl\n#align ker_pow_le_ker_pow_finrank ker_pow_le_ker_pow_finrank\n\n",
 "ker_pow_eq_ker_pow_finrank_of_le":
 "theorem ker_pow_eq_ker_pow_finrank_of_le [FiniteDimensional K V] {f : End K V} {m : ℕ} (hm : finrank K V ≤ m) :\n    (f ^ m).ker = (f ^ finrank K V).ker :=\n  by\n  obtain ⟨k, h_k_le, hk⟩ : ∃ k, k ≤ finrank K V ∧ LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ) :=\n    exists_ker_pow_eq_ker_pow_succ f\n  calc\n    (f ^ m).ker = (f ^ (k + (m - k))).ker := by rw [add_tsub_cancel_of_le (h_k_le.trans hm)]\n    _ = (f ^ k).ker := by rw [ker_pow_constant hk _]\n    _ = (f ^ (k + (finrank K V - k))).ker := (ker_pow_constant hk (finrank K V - k))\n    _ = (f ^ finrank K V).ker := by rw [add_tsub_cancel_of_le h_k_le]\n    \n#align ker_pow_eq_ker_pow_finrank_of_le ker_pow_eq_ker_pow_finrank_of_le\n\n",
 "ker_pow_constant":
 "theorem ker_pow_constant {f : End K V} {k : ℕ} (h : (f ^ k).ker = (f ^ k.succ).ker) :\n    ∀ m, (f ^ k).ker = (f ^ (k + m)).ker\n  | 0 => by simp\n  | m + 1 => by\n    apply le_antisymm\n    · rw [add_comm, pow_add]\n      apply LinearMap.ker_le_ker_comp\n    · rw [ker_pow_constant m, add_comm m 1, ← add_assoc, pow_add, pow_add f k m]\n      change LinearMap.ker ((f ^ (k + 1)).comp (f ^ m)) ≤ LinearMap.ker ((f ^ k).comp (f ^ m))\n      rw [LinearMap.ker_comp, LinearMap.ker_comp, h, nat.add_one]\n      exact le_rfl\n#align ker_pow_constant ker_pow_constant\n\n",
 "ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank [FiniteDimensional K V] [FiniteDimensional K V₂]\n    (H : finrank K V = finrank K V₂) {f : «expr →ₗ[ ] » V K V₂} : f.ker = «expr⊥» ↔ f.range = «expr⊤» := by\n  rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]\n#align ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank\n\n",
 "ker_eq_bot_iff_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ker_eq_bot_iff_range_eq_top [FiniteDimensional K V] {f : «expr →ₗ[ ] » V K V} :\n    f.ker = «expr⊥» ↔ f.range = «expr⊤» := by rw [range_eq_top, ker_eq_bot, injective_iff_surjective]\n#align ker_eq_bot_iff_range_eq_top ker_eq_bot_iff_range_eq_top\n\n",
 "is_unit_iff_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_unit_iff_range_eq_top [FiniteDimensional K V] (f : «expr →ₗ[ ] » V K V) : IsUnit f ↔ f.range = «expr⊤» := by\n  rw [is_unit_iff_ker_eq_bot, ker_eq_bot_iff_range_eq_top]\n#align is_unit_iff_range_eq_top is_unit_iff_range_eq_top\n\n",
 "is_unit_iff_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem is_unit_iff_ker_eq_bot [FiniteDimensional K V] (f : «expr →ₗ[ ] » V K V) : IsUnit f ↔ f.ker = «expr⊥» :=\n  by\n  constructor\n  · rintro ⟨u, rfl⟩\n    exact LinearMap.ker_eq_bot_of_inverse u.inv_mul\n  · intro h_inj\n    rw [ker_eq_bot] at h_inj\n    exact\n      ⟨⟨f, (LinearEquiv.ofInjectiveEndo f h_inj).symm.to_linear_map, LinearEquiv.ofInjectiveEndo_right_inv f h_inj,\n          LinearEquiv.ofInjectiveEndo_left_inv f h_inj⟩,\n        rfl⟩\n#align is_unit_iff_ker_eq_bot is_unit_iff_ker_eq_bot\n\n",
 "is_simple_module_of_finrank_eq_one":
 "#print is_simple_module_of_finrank_eq_one /-\n/-- Any `K`-algebra module that is 1-dimensional over `K` is simple. -/\ntheorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A] [IsScalarTower K A V]\n    (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) :=\n  by\n  haveI := nontrivial_of_finrank_eq_succ h\n  refine' ⟨fun S => or_iff_not_imp_left.2 fun hn => _⟩\n  rw [← restrict_scalars_inj K] at hn⊢\n  haveI := finite_dimensional_of_finrank_eq_succ h\n  refine' eq_top_of_finrank_eq ((Submodule.finrank_le _).antisymm _)\n  simpa only [h, finrank_bot] using Submodule.finrank_strictMono (Ne.bot_lt hn)\n#align is_simple_module_of_finrank_eq_one is_simple_module_of_finrank_eq_one\n-/\n\n",
 "isSimpleOrder_of_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Subalgebra.isSimpleOrder_of_finrank /-\ntheorem Subalgebra.isSimpleOrder_of_finrank (hr : finrank F E = 2) : IsSimpleOrder (Subalgebra F E) :=\n  let i := nontrivial_of_finrank_pos (zero_lt_two.trans_eq hr.symm)\n  { to_nontrivial :=\n      ⟨⟨«expr⊥», «expr⊤», fun h => by cases hr.symm.trans (Subalgebra.bot_eq_top_iff_finrank_eq_one.1 h)⟩⟩\n    eq_bot_or_eq_top := by\n      intro S\n      haveI : FiniteDimensional F E := finite_dimensional_of_finrank_eq_succ hr\n      haveI : FiniteDimensional F S := FiniteDimensional.finiteDimensional_submodule S.to_submodule\n      have : finrank F S ≤ 2 := hr ▸ S.to_submodule.finrank_le\n      have : 0 < finrank F S := finrank_pos_iff.mpr inferInstance\n      interval_cases\n      · left\n        exact Subalgebra.eq_bot_of_finrank_one h\n      · right\n        rw [← hr] at h\n        rw [← Algebra.toSubmodule_eq_top]\n        exact Submodule.eq_top_of_finrank_eq h }\n#align subalgebra.is_simple_order_of_finrank Subalgebra.isSimpleOrder_of_finrank\n-/\n\n",
 "injective_iff_surjective_of_finrank_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem injective_iff_surjective_of_finrank_eq_finrank [FiniteDimensional K V] [FiniteDimensional K V₂]\n    (H : finrank K V = finrank K V₂) {f : «expr →ₗ[ ] » V K V₂} : function.injective f ↔ function.surjective f :=\n  by\n  have := finrank_range_add_finrank_ker f\n  rw [← ker_eq_bot, ← range_eq_top]; refine' ⟨fun h => _, fun h => _⟩\n  · rw [h, finrank_bot, add_zero, H] at this\n    exact eq_top_of_finrank_eq this\n  · rw [h, finrank_top, H] at this\n    exact finrank_eq_zero.1 (add_right_injective _ this)\n#align injective_iff_surjective_of_finrank_eq_finrank injective_iff_surjective_of_finrank_eq_finrank\n\n",
 "injective_iff_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem injective_iff_surjective [FiniteDimensional K V] {f : «expr →ₗ[ ] » V K V} : injective f ↔ surjective f :=\n  ⟨surjective_of_injective, fun hsurj =>\n    let ⟨g, hg⟩ := f.exists_right_inverse_of_surjective (range_eq_top.2 hsurj)\n    have : function.right_inverse g f := LinearMap.ext_iff.1 hg\n    (leftInverse_of_surjective_of_rightInverse (surjective_of_injective this.injective) this).injective⟩\n#align injective_iff_surjective injective_iff_surjective\n\n",
 "fintype_card_le_finrank_of_linear_independent":
 "theorem fintype_card_le_finrank_of_linear_independent [FiniteDimensional K V] {ι : Type _} [Fintype ι] {b : ι → V}\n    (h : LinearIndependent K b) : Fintype.card ι ≤ finrank K V := by\n  simpa using cardinal_mk_le_finrank_of_linear_independent h\n#align fintype_card_le_finrank_of_linear_independent fintype_card_le_finrank_of_linear_independent\n\n",
 "finset_card_le_finrank_of_linear_independent":
 "theorem finset_card_le_finrank_of_linear_independent [FiniteDimensional K V] {b : Finset V}\n    (h : LinearIndependent K (fun x => x : b → V)) : b.card ≤ finrank K V :=\n  by\n  rw [← Fintype.card_coe]\n  exact fintype_card_le_finrank_of_linear_independent h\n#align finset_card_le_finrank_of_linear_independent finset_card_le_finrank_of_linear_independent\n\n",
 "finrank_zero_iff_forall_zero":
 "#print finrank_zero_iff_forall_zero /-\ntheorem finrank_zero_iff_forall_zero [FiniteDimensional K V] : finrank K V = 0 ↔ ∀ x : V, x = 0 :=\n  finrank_zero_iff.trans (subsingleton_iff_forall_eq 0)\n#align finrank_zero_iff_forall_zero finrank_zero_iff_forall_zero\n-/\n\n",
 "finrank_zero_iff":
 "/-- A finite dimensional space has zero `finrank` iff it is a subsingleton.\nThis is the `finrank` version of `rank_zero_iff`. -/\ntheorem finrank_zero_iff [FiniteDimensional K V] : finrank K V = 0 ↔ subsingleton V :=\n  iff.trans\n    (by\n      rw [← finrank_eq_rank]\n      norm_cast)\n    (@rank_zero_iff K V _ _ _ _ _)\n#align finrank_zero_iff finrank_zero_iff\n\n",
 "finrank_sup_add_finrank_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- The sum of the dimensions of s + t and s ∩ t is the sum of the dimensions of s and t -/\ntheorem finrank_sup_add_finrank_inf_eq (s t : Submodule K V) [FiniteDimensional K s] [FiniteDimensional K t] :\n    finrank K («expr↥ » («expr ⊔ » s t)) + finrank K («expr↥ » («expr ⊓ » s t)) =\n      finrank K («expr↥ » s) + finrank K («expr↥ » t) :=\n  by\n  have key :\n    Module.rank K («expr↥ » («expr ⊔ » s t)) + Module.rank K («expr↥ » («expr ⊓ » s t)) =\n      Module.rank K s + Module.rank K t :=\n    rank_sup_add_rank_inf_eq s t\n  repeat' rw [← finrank_eq_rank] at key\n  norm_cast  at key\n  exact key\n#align finrank_sup_add_finrank_inf_eq finrank_sup_add_finrank_inf_eq\n\n",
 "finrank_strict_mono":
 "theorem finrank_strict_mono [FiniteDimensional K V] : StrictMono fun s : Submodule K V => finrank K s := fun s t =>\n  finrank_lt_finrank_of_lt\n#align finrank_strict_mono finrank_strict_mono\n\n",
 "finrank_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print finrank_span_singleton /-\ntheorem finrank_span_singleton {v : V} (hv : v ≠ 0) : finrank K («expr ∙ » K v) = 1 :=\n  by\n  apply le_antisymm\n  · exact finrank_span_le_card ({v} : Set V)\n  · rw [Nat.succ_le_iff, finrank_pos_iff]\n    use ⟨v, mem_span_singleton_self v⟩, 0\n    simp [hv]\n#align finrank_span_singleton finrank_span_singleton\n-/\n\n",
 "finrank_range_add_finrank_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- rank-nullity theorem : the dimensions of the kernel and the range of a linear map add up to\nthe dimension of the source space. -/\ntheorem finrank_range_add_finrank_ker [FiniteDimensional K V] (f : «expr →ₗ[ ] » V K V₂) :\n    finrank K f.range + finrank K f.ker = finrank K V :=\n  by\n  rw [← f.quot_ker_equiv_range.finrank_eq]\n  exact Submodule.finrank_quotient_add_finrank _\n#align finrank_range_add_finrank_ker finrank_range_add_finrank_ker\n\n",
 "finrank_quotient_add_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem finrank_quotient_add_finrank [FiniteDimensional K V] (s : Submodule K V) :\n    finrank K («expr ⧸ » V s) + finrank K s = finrank K V :=\n  by\n  have := rank_quotient_add_rank s\n  rw [← finrank_eq_rank, ← finrank_eq_rank, ← finrank_eq_rank] at this\n  exact_mod_cast this\n#align finrank_quotient_add_finrank finrank_quotient_add_finrank\n\n",
 "finrank_pos_iff_exists_ne_zero":
 "/-- A finite dimensional space has positive `finrank` iff it has a nonzero element. -/\ntheorem finrank_pos_iff_exists_ne_zero [FiniteDimensional K V] : 0 < finrank K V ↔ ∃ x : V, x ≠ 0 :=\n  iff.trans\n    (by\n      rw [← finrank_eq_rank]\n      norm_cast)\n    (@rank_pos_iff_exists_ne_zero K V _ _ _ _ _)\n#align finrank_pos_iff_exists_ne_zero finrank_pos_iff_exists_ne_zero\n\n",
 "finrank_pos_iff":
 "/-- A finite dimensional space has positive `finrank` iff it is nontrivial. -/\ntheorem finrank_pos_iff [FiniteDimensional K V] : 0 < finrank K V ↔ Nontrivial V :=\n  iff.trans\n    (by\n      rw [← finrank_eq_rank]\n      norm_cast)\n    (@rank_pos_iff_nontrivial K V _ _ _ _ _)\n#align finrank_pos_iff finrank_pos_iff\n\n",
 "finrank_pos":
 "/-- A nontrivial finite dimensional space has positive `finrank`. -/\ntheorem finrank_pos [FiniteDimensional K V] [h : Nontrivial V] : 0 < finrank K V :=\n  finrank_pos_iff.mpr h\n#align finrank_pos finrank_pos\n\n",
 "finrank_of_infinite_dimensional":
 "theorem finrank_of_infinite_dimensional (h : ¬FiniteDimensional K V) : finrank K V = 0 :=\n  dif_neg <| mt IsNoetherian.iff_rank_lt_aleph0.2 <| (not_iff_not.2 iff_fg).2 h\n#align finrank_of_infinite_dimensional finrank_of_infinite_dimensional\n\n",
 "finrank_mono":
 "#print Set.finrank_mono /-\ntheorem Set.finrank_mono [FiniteDimensional K V] {s t : Set V} (h : s ⊆ t) : s.finrank K ≤ t.finrank K :=\n  finrank_mono (span_mono h)\n#align set.finrank_mono Set.finrank_mono\n-/\n\n",
 "finrank_lt_finrank_of_lt":
 "theorem finrank_lt_finrank_of_lt {s t : Submodule K V} [FiniteDimensional K t] (hst : s < t) :\n    finrank K s < finrank K t :=\n  (comapSubtypeEquivOfLe hst.le).finrank_eq.symm.trans_lt <|\n    finrank_lt (le_top.lt_of_ne <| hst.not_le ∘ comap_subtype_eq_top.1)\n#align finrank_lt_finrank_of_lt finrank_lt_finrank_of_lt\n\n",
 "finrank_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The dimension of a strict submodule is strictly bounded by the dimension of the ambient\nspace. -/\ntheorem finrank_lt [FiniteDimensional K V] {s : Submodule K V} (h : s < «expr⊤») : finrank K s < finrank K V :=\n  by\n  rw [← s.finrank_quotient_add_finrank, add_comm]\n  exact Nat.lt_add_of_zero_lt_left _ _ (finrank_pos_iff.mpr (quotient.nontrivial_of_lt_top _ h))\n#align finrank_lt finrank_lt\n\n",
 "finrank_le_one_iff_top_isPrincipal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Module.finrank_le_one_iff_top_isPrincipal /-\ntheorem Module.finrank_le_one_iff_top_isPrincipal [FiniteDimensional K V] :\n    finrank K V ≤ 1 ↔ («expr⊤» : Submodule K V).is_principal := by\n  rw [← Module.rank_le_one_iff_top_isPrincipal, ← finrank_eq_rank, ← Cardinal.natCast_le, Nat.cast_one]\n#align module.finrank_le_one_iff_top_is_principal Module.finrank_le_one_iff_top_isPrincipal\n-/\n\n",
 "finrank_le_one_iff_isPrincipal":
 "#print Submodule.finrank_le_one_iff_isPrincipal /-\ntheorem Submodule.finrank_le_one_iff_isPrincipal (W : Submodule K V) [FiniteDimensional K W] :\n    finrank K W ≤ 1 ↔ W.is_principal := by\n  rw [← W.rank_le_one_iff_is_principal, ← finrank_eq_rank, ← Cardinal.natCast_le, Nat.cast_one]\n#align submodule.finrank_le_one_iff_is_principal Submodule.finrank_le_one_iff_isPrincipal\n-/\n\n",
 "finrank_le_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print finrank_le_one_iff /-\n-- Not sure why this aren't found automatically.\n/-- A finite dimensional module has dimension at most 1 iff\nthere is some `v : V` so every vector is a multiple of `v`.\n-/\ntheorem finrank_le_one_iff [FiniteDimensional K V] : finrank K V ≤ 1 ↔ ∃ v : V, ∀ w : V, ∃ c : K, «expr • » c v = w :=\n  by\n  fconstructor\n  · intro h\n    by_cases h' : finrank K V = 0\n    · use 0\n      intro w\n      use 0\n      haveI := finrank_zero_iff.mp h'\n      apply subsingleton.elim\n    · replace h' := zero_lt_iff.mpr h'\n      have : finrank K V = 1 := by linarith\n      obtain ⟨v, -, p⟩ := finrank_eq_one_iff'.mp this\n      use ⟨v, p⟩\n  · rintro ⟨v, p⟩\n    exact finrank_le_one v p\n#align finrank_le_one_iff finrank_le_one_iff\n-/\n\n",
 "finrank_eq_zero_of_rank_eq_zero":
 "#print finrank_eq_zero_of_rank_eq_zero /-\ntheorem finrank_eq_zero_of_rank_eq_zero [FiniteDimensional K V] (h : Module.rank K V = 0) : finrank K V = 0 :=\n  by\n  convert finrank_eq_rank K V\n  rw [h]; norm_cast\n#align finrank_eq_zero_of_rank_eq_zero finrank_eq_zero_of_rank_eq_zero\n-/\n\n",
 "finrank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print finrank_eq_zero /-\n@[simp]\ntheorem finrank_eq_zero {S : Submodule K V} [FiniteDimensional K S] : finrank K S = 0 ↔ S = «expr⊥» := by\n  rw [← rank_eq_zero, ← finrank_eq_rank, ← @Nat.cast_zero Cardinal, Cardinal.natCast_inj]\n#align finrank_eq_zero finrank_eq_zero\n-/\n\n",
 "finrank_eq_rank'":
 "/-- In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its\n`finrank`. This is a copy of `finrank_eq_rank _ _` which creates easier typeclass searches. -/\ntheorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=\n  finrank_eq_rank _ _\n#align finrank_eq_rank' finrank_eq_rank'\n\n",
 "finrank_eq_one_iff_of_nonzero'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print finrank_eq_one_iff_of_nonzero' /-\n/-- A module with a nonzero vector `v` has dimension 1 iff every vector is a multiple of `v`.\n-/\ntheorem finrank_eq_one_iff_of_nonzero' (v : V) (nz : v ≠ 0) : finrank K V = 1 ↔ ∀ w : V, ∃ c : K, «expr • » c v = w :=\n  by\n  rw [finrank_eq_one_iff_of_nonzero v nz]\n  apply span_singleton_eq_top_iff\n#align finrank_eq_one_iff_of_nonzero' finrank_eq_one_iff_of_nonzero'\n-/\n\n",
 "finrank_eq_one_iff_of_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print finrank_eq_one_iff_of_nonzero /-\n/-- A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\n-/\ntheorem finrank_eq_one_iff_of_nonzero (v : V) (nz : v ≠ 0) : finrank K V = 1 ↔ span K ({v} : Set V) = «expr⊤» :=\n  ⟨fun h => by simpa using (basis_singleton PUnit h v nz).span_eq, fun s =>\n    finrank_eq_card_basis\n      (Basis.mk (linearIndependent_singleton nz)\n        (by\n          convert s\n          simp))⟩\n#align finrank_eq_one_iff_of_nonzero finrank_eq_one_iff_of_nonzero\n-/\n\n",
 "finrank_eq_one_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print finrank_eq_one_iff' /-\n/-- A module has dimension 1 iff there is some nonzero `v : V` so every vector is a multiple of `v`.\n-/\ntheorem finrank_eq_one_iff' : finrank K V = 1 ↔ ∃ (v : V)(n : v ≠ 0), ∀ w : V, ∃ c : K, «expr • » c v = w :=\n  by\n  convert finrank_eq_one_iff PUnit\n  simp only [exists_prop, eq_iff_iff, ne.def]\n  convert(Basis.basis_singleton_iff PUnit).symm\n  funext v\n  simp\n  infer_instance; infer_instance\n#align finrank_eq_one_iff' finrank_eq_one_iff'\n-/\n\n",
 "finrank_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.finrank_eq_one_iff /-\n@[simp]\ntheorem Subalgebra.finrank_eq_one_iff [Nontrivial E] {S : Subalgebra F E} : finrank F S = 1 ↔ S = «expr⊥» :=\n  ⟨Subalgebra.eq_bot_of_finrank_one, fun h => h.symm ▸ Subalgebra.finrank_bot⟩\n#align subalgebra.finrank_eq_one_iff Subalgebra.finrank_eq_one_iff\n-/\n\n",
 "finrank_eq_card_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If a vector space is finite-dimensional, then the cardinality of any basis is equal to its\n`finrank`. -/\ntheorem finrank_eq_card_basis' [FiniteDimensional K V] {ι : Type w} (h : Basis ι K V) :\n    (finrank K V : Cardinal.{w}) = cardinal.mk ι :=\n  by\n  haveI : IsNoetherian K V := iff_fg.2 inferInstance\n  haveI : Fintype ι := fintype_basis_index h\n  rw [Cardinal.mk_fintype, finrank_eq_card_basis h]\n#align finrank_eq_card_basis' finrank_eq_card_basis'\n\n",
 "finrank_add_le_finrank_add_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem finrank_add_le_finrank_add_finrank (s t : Submodule K V) [FiniteDimensional K s] [FiniteDimensional K t] :\n    finrank K («expr ⊔ » s t : Submodule K V) ≤ finrank K s + finrank K t :=\n  by\n  rw [← finrank_sup_add_finrank_inf_eq]\n  exact self_le_add_right _ _\n#align finrank_add_le_finrank_add_finrank finrank_add_le_finrank_add_finrank\n\n",
 "finrank_add_eq_of_is_compl":
 "theorem finrank_add_eq_of_is_compl [FiniteDimensional K V] {U W : Submodule K V} (h : IsCompl U W) :\n    finrank K U + finrank K W = finrank K V :=\n  by\n  rw [← finrank_sup_add_finrank_inf_eq, h.codisjoint.eq_top, h.disjoint.eq_bot, finrank_bot, add_zero]\n  exact finrank_top _ _\n#align finrank_add_eq_of_is_compl finrank_add_eq_of_is_compl\n\n",
 "finite_of_finite":
 "theorem finite_of_finite [Finite K] [FiniteDimensional K V] : Finite V :=\n  by\n  cases nonempty_fintype K\n  haveI := fintype_of_fintype K V\n  infer_instance\n#align finite_of_finite finite_of_finite\n\n",
 "finite_dimensional_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem finite_dimensional_of_surjective [FiniteDimensional K V] (f : «expr →ₗ[ ] » V K V₂) (hf : f.range = «expr⊤») :\n    FiniteDimensional K V₂ :=\n  Module.Finite.of_surjective f <| range_eq_top.1 hf\n#align finite_dimensional_of_surjective finite_dimensional_of_surjective\n\n",
 "finite_dimensional_of_le":
 "/-- A submodule contained in a finite-dimensional submodule is\nfinite-dimensional. -/\ntheorem finite_dimensional_of_le {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (h : S₁ ≤ S₂) :\n    FiniteDimensional K S₁ :=\n  haveI : IsNoetherian K S₂ := iff_fg.2 inferInstance\n  iff_fg.1\n    (IsNoetherian.iff_rank_lt_aleph0.2\n      (lt_of_le_of_lt (rank_le_of_submodule _ _ h) (FiniteDimensional.rank_lt_aleph0 K S₂)))\n#align finite_dimensional_of_le finite_dimensional_of_le\n\n",
 "finite_dimensional_of_finrank_eq_succ":
 "theorem finite_dimensional_of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) : FiniteDimensional K V :=\n  finiteDimensional_of_finrank <| by rw [hn] <;> exact n.succ_pos\n#align finite_dimensional_of_finrank_eq_succ finite_dimensional_of_finrank_eq_succ\n\n",
 "finite_dimensional_of_finrank":
 "theorem finite_dimensional_of_finrank (h : 0 < finrank K V) : FiniteDimensional K V :=\n  by\n  contrapose h\n  simp [finrank_of_infinite_dimensional h]\n#align finite_dimensional_of_finrank finite_dimensional_of_finrank\n\n",
 "finite_dimensional_iff_of_rank_eq_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem finite_dimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : ℕ} (hn : n ≠ 0)\n    (hVW : Module.rank K V = «expr • » n (Module.rank K W)) : FiniteDimensional K V ↔ FiniteDimensional K W := by\n  simp only [FiniteDimensional, ← IsNoetherian.iff_fg, IsNoetherian.iff_rank_lt_aleph0, hVW,\n    Cardinal.nsmul_lt_aleph0_iff_of_ne_zero hn]\n#align finite_dimensional_iff_of_rank_eq_nsmul finite_dimensional_iff_of_rank_eq_nsmul\n\n",
 "finiteDimensional_toSubmodule":
 "#print Subalgebra.finiteDimensional_toSubmodule /-\n/-- A `subalgebra` is `finite_dimensional` iff it is finite_dimensional as a submodule. -/\ntheorem Subalgebra.finiteDimensional_toSubmodule {S : Subalgebra F E} :\n    FiniteDimensional F S.to_submodule ↔ FiniteDimensional F S :=\n  iff.rfl\n#align subalgebra.finite_dimensional_to_submodule Subalgebra.finiteDimensional_toSubmodule\n-/\n\n",
 "finiteDimensional_of_rank_eq_zero":
 "#print finiteDimensional_of_rank_eq_zero /-\n-- TODO: generalize to free modules over general rings.\ntheorem finiteDimensional_of_rank_eq_zero (h : Module.rank K V = 0) : FiniteDimensional K V :=\n  finiteDimensional_of_rank_eq_nat <| h.trans Nat.cast_zero.symm\n#align finite_dimensional_of_rank_eq_zero finiteDimensional_of_rank_eq_zero\n-/\n\n",
 "finiteDimensional_of_rank_eq_one":
 "#print finiteDimensional_of_rank_eq_one /-\ntheorem finiteDimensional_of_rank_eq_one (h : Module.rank K V = 1) : FiniteDimensional K V :=\n  finiteDimensional_of_rank_eq_nat <| h.trans Nat.cast_one.symm\n#align finite_dimensional_of_rank_eq_one finiteDimensional_of_rank_eq_one\n-/\n\n",
 "finiteDimensional_of_rank_eq_nat":
 "#print finiteDimensional_of_rank_eq_nat /-\ntheorem finiteDimensional_of_rank_eq_nat {n : ℕ} (h : Module.rank K V = n) : FiniteDimensional K V :=\n  by\n  rw [FiniteDimensional, ← IsNoetherian.iff_fg, IsNoetherian.iff_rank_lt_aleph0, h]\n  exact nat_lt_aleph_0 n\n#align finite_dimensional_of_rank_eq_nat finiteDimensional_of_rank_eq_nat\n-/\n\n",
 "finite":
 "#print LinearIndependent.finite /-\ntheorem LinearIndependent.finite [FiniteDimensional K V] {b : Set V} (h : LinearIndependent K fun x : b => (x : V)) :\n    b.finite :=\n  Cardinal.lt_aleph0_iff_set_finite.mp (FiniteDimensional.lt_aleph0_of_linearIndependent h)\n#align linear_independent.finite LinearIndependent.finite\n-/\n\n",
 "fg_iff_finite_dimensional":
 "/-- A submodule is finitely generated if and only if it is finite-dimensional -/\ntheorem fg_iff_finite_dimensional (s : Submodule K V) : s.fg ↔ FiniteDimensional K s :=\n  ⟨fun h => Module.finite_def.2 <| (fg_top s).2 h, fun h => (fg_top s).1 <| Module.finite_def.1 h⟩\n#align fg_iff_finite_dimensional fg_iff_finite_dimensional\n\n",
 "fact_finite_dimensional_of_finrank_eq_succ":
 "/-- We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare\nthis as a local instance where needed. -/\ntheorem fact_finite_dimensional_of_finrank_eq_succ (n : ℕ) [Fact (finrank K V = n + 1)] : FiniteDimensional K V :=\n  finiteDimensional_of_finrank <| by convert nat.succ_pos n <;> apply fact.out\n#align fact_finite_dimensional_of_finrank_eq_succ fact_finite_dimensional_of_finrank_eq_succ\n\n",
 "exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- A slight strengthening of `exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card`\navailable when working over an ordered field:\nwe can ensure a positive coefficient, not just a nonzero coefficient.\n-/\ntheorem exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card [FiniteDimensional L W] {t : Finset W}\n    (h : finrank L W + 1 < t.card) :\n    ∃ f : W → L,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e) e) =\n          0 ∧\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f e) = 0 ∧\n          ∃ x ∈ t, 0 < f x :=\n  by\n  obtain ⟨f, sum, total, nonzero⟩ := exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card h\n  exact ⟨f, Sum, total, exists_pos_of_sum_zero_of_exists_nonzero f total nonzero⟩\n#align exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card\n\n",
 "exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If a finset has cardinality larger than `finrank + 1`,\nthen there is a nontrivial linear relation amongst its elements,\nsuch that the coefficients of the relation sum to zero.\n-/\ntheorem exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card [FiniteDimensional K V] {t : Finset V}\n    (h : finrank K V + 1 < t.card) :\n    ∃ f : V → K,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e) e) =\n          0 ∧\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f e) = 0 ∧\n          ∃ x ∈ t, f x ≠ 0 :=\n  by\n  -- Pick an element x₀ ∈ t,\n  have card_pos : 0 < t.card := lt_trans (nat.succ_pos _) h\n  obtain ⟨x₀, m⟩ := (Finset.card_pos.1 card_pos).bex\n  -- and apply the previous lemma to the {xᵢ - x₀}\n  let shift : «expr ↪ » V V := ⟨fun x => x - x₀, sub_left_injective⟩\n  let t' := (t.erase x₀).map shift\n  have h' : finrank K V < t'.card :=\n    by\n    simp only [t', card_map, Finset.card_erase_of_mem m]\n    exact nat.lt_pred_iff.mpr h\n  -- to obtain a function `g`.\n  obtain ⟨g, gsum, x₁, x₁_mem, nz⟩ := exists_nontrivial_relation_of_rank_lt_card h'\n  -- Then obtain `f` by translating back by `x₀`,\n  -- and setting the value of `f` at `x₀` to ensure `∑ e in t, f e = 0`.\n  let f : V → K := fun z =>\n    if z = x₀ then\n      -finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase x₀)\n          (g (z - x₀))\n    else g (z - x₀)\n  refine' ⟨f, _, _, _⟩\n  -- After this, it's a matter of verifiying the properties,\n  -- based on the corresponding properties for `g`.\n  · show\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n          («expr • » (f e) e) =\n        0\n    -- We prove this by splitting off the `x₀` term of the sum,\n    -- which is itself a sum over `t.erase x₀`,\n    -- combining the two sums, and\n    -- observing that after reindexing we have exactly\n    -- ∑ (x : V) in t', g x • x = 0.\n    simp only [f]\n    conv_lhs =>\n      apply_congr\n      skip\n      rw [ite_smul]\n    rw [Finset.sum_ite]\n    conv =>\n      congr\n      congr\n      apply_congr\n      simp [filter_eq', m]\n    conv =>\n      congr\n      congr\n      skip\n      apply_congr\n      simp [filter_ne']\n    rw [sum_singleton, neg_smul, add_comm, ← sub_eq_add_neg, sum_smul, ← sum_sub_distrib]\n    simp only [← smul_sub]\n    -- At the end we have to reindex the sum, so we use `change` to\n    -- express the summand using `shift`.\n    change\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (t.erase x₀)\n          ((fun e => «expr • » (g e) e) (shift x)) =\n        0\n    rw [← sum_map _ shift]\n    exact gsum\n  · show finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f e) = 0\n    -- Again we split off the `x₀` term,\n    -- observing that it exactly cancels the other terms.\n    rw [← insert_erase m, sum_insert (not_mem_erase x₀ t)]\n    dsimp [f]\n    rw [if_pos rfl]\n    conv_lhs =>\n      congr\n      skip\n      apply_congr\n      skip\n      rw [if_neg (show x ≠ x₀ from (mem_erase.mp H).1)]\n    exact neg_add_self _\n  · show ∃ (x : V)(H : x ∈ t), f x ≠ 0\n    -- We can use x₁ + x₀.\n    refine' ⟨x₁ + x₀, _, _⟩\n    · rw [Finset.mem_map] at x₁_mem\n      rcases x₁_mem with ⟨x₁, x₁_mem, rfl⟩\n      rw [mem_erase] at x₁_mem\n      simp only [x₁_mem, sub_add_cancel, Function.Embedding.coeFn_mk]\n    · dsimp only [f]\n      rwa [if_neg, add_sub_cancel]\n      rw [add_left_eq_self]\n      rintro rfl\n      simpa only [sub_eq_zero, exists_prop, Finset.mem_map, embedding.coe_fn_mk, eq_self_iff_true, mem_erase, not_true,\n        exists_eq_right, ne.def, false_and_iff] using x₁_mem\n#align exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card\n\n",
 "exists_nontrivial_relation_of_rank_lt_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a finset has cardinality larger than the dimension of the space,\nthen there is a nontrivial linear relation amongst its elements.\n-/\ntheorem exists_nontrivial_relation_of_rank_lt_card [FiniteDimensional K V] {t : Finset V} (h : finrank K V < t.card) :\n    ∃ f : V → K,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n            («expr • » (f e) e) =\n          0 ∧\n        ∃ x ∈ t, f x ≠ 0 :=\n  by\n  have := mt finset_card_le_finrank_of_linear_independent (by simpa using h)\n  rw [not_linearIndependent_iff] at this\n  obtain ⟨s, g, sum, z, zm, nonzero⟩ := this\n  -- Now we have to extend `g` to all of `t`, then to all of `V`.\n  let f : V → K := fun x => if h : x ∈ t then if (⟨x, h⟩ : t) ∈ s then g ⟨x, h⟩ else 0 else 0\n  -- and finally clean up the mess caused by the extension.\n  refine' ⟨f, _, _⟩\n  · dsimp [f]\n    rw [← Sum]\n    fapply sum_bij_ne_zero fun v hvt _ => (⟨v, hvt⟩ : { v // v ∈ t })\n    · intro v hvt H\n      dsimp\n      rw [dif_pos hvt] at H\n      contrapose! H\n      rw [if_neg H, zero_smul]\n    · intro _ _ _ _ _ _\n      exact subtype.mk.inj\n    · intro b hbs hb\n      use b\n      simpa only [hbs, exists_prop, dif_pos, Finset.mk_coe, and_true_iff, if_true, Finset.coe_mem, eq_self_iff_true,\n        exists_prop_of_true, ne.def] using hb\n    · intro a h₁\n      dsimp\n      rw [dif_pos h₁]\n      intro h₂\n      rw [if_pos]\n      contrapose! h₂\n      rw [if_neg h₂, zero_smul]\n  · refine' ⟨z, z.2, _⟩\n    dsimp only [f]\n    erw [dif_pos z.2, if_pos] <;> rwa [Subtype.coe_eta]\n#align exists_nontrivial_relation_of_rank_lt_card exists_nontrivial_relation_of_rank_lt_card\n\n",
 "exists_ker_pow_eq_ker_pow_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem exists_ker_pow_eq_ker_pow_succ [FiniteDimensional K V] (f : End K V) :\n    ∃ k : ℕ, k ≤ finrank K V ∧ (f ^ k).ker = (f ^ k.succ).ker := by\n  classical\n    by_contra h_contra\n    simp_rw [not_exists, not_and] at h_contra\n    have h_le_ker_pow : ∀ n : ℕ, n ≤ (finrank K V).succ → n ≤ finrank K (f ^ n).ker :=\n      by\n      intro n hn\n      induction' n with n ih\n      · exact zero_le (finrank _ _)\n      · have h_ker_lt_ker : (f ^ n).ker < (f ^ n.succ).ker :=\n          by\n          refine' lt_of_le_of_ne _ (h_contra n (nat.le_of_succ_le_succ hn))\n          rw [pow_succ]\n          apply LinearMap.ker_le_ker_comp\n        have h_finrank_lt_finrank : finrank K (f ^ n).ker < finrank K (f ^ n.succ).ker := by\n          apply Submodule.finrank_lt_finrank_of_lt h_ker_lt_ker\n        calc\n          n.succ ≤ (finrank K («expr↥ » (LinearMap.ker (f ^ n)))).succ := nat.succ_le_succ (ih (nat.le_of_succ_le hn))\n          _ ≤ finrank K («expr↥ » (LinearMap.ker (f ^ n.succ))) := nat.succ_le_of_lt h_finrank_lt_finrank\n          \n    have h_le_finrank_V : ∀ n, finrank K (f ^ n).ker ≤ finrank K V := fun n => Submodule.finrank_le _\n    have h_any_n_lt : ∀ n, n ≤ (finrank K V).succ → n ≤ finrank K V := fun n hn =>\n      (h_le_ker_pow n hn).trans (h_le_finrank_V n)\n    show False\n    exact nat.not_succ_le_self _ (h_any_n_lt (finrank K V).succ (finrank K V).succ.le_refl)\n#align exists_ker_pow_eq_ker_pow_succ exists_ker_pow_eq_ker_pow_succ\n\n",
 "eq_top_of_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V} (h : finrank K S = finrank K V) :\n    S = «expr⊤» :=\n  FiniteDimensional.eq_of_le_of_finrank_eq le_top (by simp [h, finrank_top])\n#align eq_top_of_finrank_eq eq_top_of_finrank_eq\n\n",
 "eq_top_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_top_of_disjoint [FiniteDimensional K V] (s t : Submodule K V)\n    (hdim : finrank K s + finrank K t = finrank K V) (hdisjoint : Disjoint s t) : «expr ⊔ » s t = «expr⊤» :=\n  by\n  have h_finrank_inf : finrank K («expr↥ » («expr ⊓ » s t)) = 0 :=\n    by\n    rw [disjoint_iff_inf_le, le_bot_iff] at hdisjoint\n    rw [hdisjoint, finrank_bot]\n  apply eq_top_of_finrank_eq\n  rw [← hdim]\n  convert s.finrank_sup_add_finrank_inf_eq t\n  rw [h_finrank_inf]\n  rfl\n#align eq_top_of_disjoint eq_top_of_disjoint\n\n",
 "eq_of_le_of_finrank_le":
 "theorem eq_of_le_of_finrank_le {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (hle : S₁ ≤ S₂)\n    (hd : finrank K S₂ ≤ finrank K S₁) : S₁ = S₂ :=\n  by\n  rw [← LinearEquiv.finrank_eq (Submodule.comapSubtypeEquivOfLe hle)] at hd\n  exact\n    le_antisymm hle\n      (Submodule.comap_subtype_eq_top.1\n        (eq_top_of_finrank_eq (le_antisymm (comap (Submodule.subtype S₂) S₁).finrank_le hd)))\n#align eq_of_le_of_finrank_le eq_of_le_of_finrank_le\n\n",
 "eq_of_le_of_finrank_eq":
 "/-- If a submodule is less than or equal to a finite-dimensional\nsubmodule with the same dimension, they are equal. -/\ntheorem eq_of_le_of_finrank_eq {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (hle : S₁ ≤ S₂)\n    (hd : finrank K S₁ = finrank K S₂) : S₁ = S₂ :=\n  eq_of_le_of_finrank_le hle hd.ge\n#align eq_of_le_of_finrank_eq eq_of_le_of_finrank_eq\n\n",
 "eq_bot_of_rank_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.eq_bot_of_rank_le_one /-\ntheorem Subalgebra.eq_bot_of_rank_le_one {S : Subalgebra F E} (h : Module.rank F S ≤ 1) : S = «expr⊥» :=\n  by\n  nontriviality E\n  obtain ⟨m, hm, he⟩ := Cardinal.exists_nat_eq_of_le_nat (h.trans_eq nat.cast_one.symm)\n  haveI := finiteDimensional_of_rank_eq_nat he\n  rw [← not_bot_lt_iff, ← subalgebra.to_submodule.lt_iff_lt]\n  haveI := S.to_submodule_equiv.symm.finite_dimensional\n  refine' fun hl => (Submodule.finrank_lt_finrank_of_lt hl).not_le (nat_cast_le.1 _)\n  iterate 2 rw [Subalgebra.finrank_toSubmodule, finrank_eq_rank]\n  exact h.trans_eq subalgebra.rank_bot.symm\n#align subalgebra.eq_bot_of_rank_le_one Subalgebra.eq_bot_of_rank_le_one\n-/\n\n",
 "eq_bot_of_finrank_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.eq_bot_of_finrank_one /-\ntheorem Subalgebra.eq_bot_of_finrank_one {S : Subalgebra F E} (h : finrank F S = 1) : S = «expr⊥» :=\n  Subalgebra.eq_bot_of_rank_le_one <|\n    by\n    haveI := finite_dimensional_of_finrank_eq_succ h\n    rw [← finrank_eq_rank, h, Nat.cast_one]\n#align subalgebra.eq_bot_of_finrank_one Subalgebra.eq_bot_of_finrank_one\n-/\n\n",
 "comp_eq_id_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem comp_eq_id_comm [FiniteDimensional K V] {f g : «expr →ₗ[ ] » V K V} : f.comp g = id ↔ g.comp f = id :=\n  mul_eq_one_comm\n#align comp_eq_id_comm comp_eq_id_comm\n\n",
 "coe_setBasisOfLinearIndependentOfCardEqFinrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print coe_setBasisOfLinearIndependentOfCardEqFinrank /-\n@[simp]\ntheorem coe_setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]\n    (lin_ind : LinearIndependent K (coe : s → V)) (card_eq : s.to_finset.card = finrank K V) :\n    «expr⇑ » (setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = coe :=\n  Basis.coe_mk _ _\n#align coe_set_basis_of_linear_independent_of_card_eq_finrank coe_setBasisOfLinearIndependentOfCardEqFinrank\n-/\n\n",
 "coe_of_injective_endo":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_of_injective_endo (f : «expr →ₗ[ ] » V K V) (h_inj : injective f) :\n    «expr⇑ » (ofInjectiveEndo f h_inj) = f :=\n  rfl\n#align coe_of_injective_endo coe_of_injective_endo\n\n",
 "coe_finsetBasisOfLinearIndependentOfCardEqFinrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print coe_finsetBasisOfLinearIndependentOfCardEqFinrank /-\n@[simp]\ntheorem coe_finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.nonempty)\n    (lin_ind : LinearIndependent K (coe : s → V)) (card_eq : s.card = finrank K V) :\n    «expr⇑ » (finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq) = coe :=\n  Basis.coe_mk _ _\n#align coe_finset_basis_of_linear_independent_of_card_eq_finrank coe_finsetBasisOfLinearIndependentOfCardEqFinrank\n-/\n\n",
 "coe_basisOfLinearIndependentOfCardEqFinrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print coe_basisOfLinearIndependentOfCardEqFinrank /-\n@[simp]\ntheorem coe_basisOfLinearIndependentOfCardEqFinrank {ι : Type _} [Nonempty ι] [Fintype ι] {b : ι → V}\n    (lin_ind : LinearIndependent K b) (card_eq : Fintype.card ι = finrank K V) :\n    «expr⇑ » (basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = b :=\n  Basis.coe_mk _ _\n#align coe_basis_of_linear_independent_of_card_eq_finrank coe_basisOfLinearIndependentOfCardEqFinrank\n-/\n\n",
 "cardinal_mk_le_finrank_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_mk_le_finrank_of_linear_independent [FiniteDimensional K V] {ι : Type w} {b : ι → V}\n    (h : LinearIndependent K b) : cardinal.mk ι ≤ finrank K V :=\n  by\n  rw [← lift_le.{_, max v w}]\n  simpa [← finrank_eq_rank', -finrank_eq_rank] using cardinal_lift_le_rank_of_linearIndependent.{_, _, _, max v w} h\n#align cardinal_mk_le_finrank_of_linear_independent cardinal_mk_le_finrank_of_linear_independent\n\n",
 "cardinal_mk_eq_cardinal_mk_field_pow_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print cardinal_mk_eq_cardinal_mk_field_pow_rank /-\ntheorem cardinal_mk_eq_cardinal_mk_field_pow_rank (K V : Type u) [DivisionRing K] [AddCommGroup V] [Module K V]\n    [FiniteDimensional K V] : cardinal.mk V = cardinal.mk K ^ Module.rank K V :=\n  by\n  let s := Basis.ofVectorSpaceIndex K V\n  let hs := Basis.ofVectorSpace K V\n  calc\n    cardinal.mk V = cardinal.mk («expr →₀ » s K) := quotient.sound ⟨hs.repr.to_equiv⟩\n    _ = cardinal.mk (s → K) := (quotient.sound ⟨Finsupp.equivFunOnFinite⟩)\n    _ = _ := by rw [← Cardinal.lift_inj.1 hs.mk_eq_rank, Cardinal.power_def]\n    \n#align cardinal_mk_eq_cardinal_mk_field_pow_rank cardinal_mk_eq_cardinal_mk_field_pow_rank\n-/\n\n",
 "cardinal_lt_aleph0_of_finiteDimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print cardinal_lt_aleph0_of_finiteDimensional /-\ntheorem cardinal_lt_aleph0_of_finiteDimensional (K V : Type u) [DivisionRing K] [AddCommGroup V] [Module K V] [Finite K]\n    [FiniteDimensional K V] : cardinal.mk V < cardinal.aleph_0 :=\n  by\n  letI : IsNoetherian K V := IsNoetherian.iff_fg.2 inferInstance\n  rw [cardinal_mk_eq_cardinal_mk_field_pow_rank K V]\n  exact Cardinal.power_lt_aleph0 (Cardinal.lt_aleph0_of_finite K) (IsNoetherian.rank_lt_aleph0 K V)\n#align cardinal_lt_aleph_0_of_finite_dimensional cardinal_lt_aleph0_of_finiteDimensional\n-/\n\n",
 "bot_eq_top_of_rank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print bot_eq_top_of_rank_eq_zero /-\ntheorem bot_eq_top_of_rank_eq_zero (h : Module.rank K V = 0) : («expr⊥» : Submodule K V) = «expr⊤» :=\n  by\n  haveI := finiteDimensional_of_rank_eq_zero h\n  apply eq_top_of_finrank_eq\n  rw [finrank_bot, finrank_eq_zero_of_rank_eq_zero h]\n#align bot_eq_top_of_rank_eq_zero bot_eq_top_of_rank_eq_zero\n-/\n\n",
 "bot_eq_top_iff_rank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Subalgebra.bot_eq_top_iff_rank_eq_one /-\ntheorem Subalgebra.bot_eq_top_iff_rank_eq_one [Nontrivial E] :\n    («expr⊥» : Subalgebra F E) = «expr⊤» ↔ Module.rank F E = 1 := by\n  rw [← rank_top, ← subalgebra_top_rank_eq_submodule_top_rank, Subalgebra.rank_eq_one_iff, eq_comm]\n#align subalgebra.bot_eq_top_iff_rank_eq_one Subalgebra.bot_eq_top_iff_rank_eq_one\n-/\n\n",
 "bot_eq_top_iff_finrank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Subalgebra.bot_eq_top_iff_finrank_eq_one /-\ntheorem Subalgebra.bot_eq_top_iff_finrank_eq_one [Nontrivial E] :\n    («expr⊥» : Subalgebra F E) = «expr⊤» ↔ finrank F E = 1 := by\n  rw [← finrank_top, ← subalgebra_top_finrank_eq_submodule_top_finrank, Subalgebra.finrank_eq_one_iff, eq_comm]\n#align subalgebra.bot_eq_top_iff_finrank_eq_one Subalgebra.bot_eq_top_iff_finrank_eq_one\n-/\n\n",
 "basis_singleton_apply":
 "@[simp]\ntheorem basis_singleton_apply (ι : Type _) [Unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0) (i : ι) :\n    basisSingleton ι h v hv i = v := by\n  cases unique.uniq ‹Unique ι› i\n  simp [basis_singleton]\n#align basis_singleton_apply basis_singleton_apply\n\n",
 "FiniteDimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print FiniteDimensional /-\n/-- Finite dimensionality is preserved under linear equivalence. -/\nprotected theorem FiniteDimensional (f : «expr ≃ₗ[ ] » V K V₂) [FiniteDimensional K V] : FiniteDimensional K V₂ :=\n  Module.Finite.equiv f\n#align finite_dimensional FiniteDimensional\n-/\n\n"}