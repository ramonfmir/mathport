{"upper_two_block_triangular":
 "theorem upper_two_block_triangular [preorder α] (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) {a b : α}\n    (hab : a < b) : BlockTriangular (fromBlocks A B 0 D) (Sum.elim (fun i => a) fun j => b) := by\n  rintro (c | c) (d | d) hcd <;> first |simpa [hab.not_lt] using hcd|simp\n#align upper_two_block_triangular upper_two_block_triangular\n\n",
 "two_block_triangular_det'":
 "theorem two_block_triangular_det' (M : Matrix m m R) (p : m → Prop) [DecidablePred p]\n    (h : ∀ i, p i → ∀ j, ¬p j → M i j = 0) :\n    M.det = (toSquareBlockProp M p).det * (toSquareBlockProp M fun i => ¬p i).det :=\n  by\n  rw [M.two_block_triangular_det fun i => ¬p i, mul_comm]\n  simp_rw [Classical.not_not]\n  congr 1\n  exact equiv_block_det _ fun _ => not_not.symm\n  simpa only [Classical.not_not] using h\n#align two_block_triangular_det' two_block_triangular_det'\n\n",
 "two_block_triangular_det":
 "theorem two_block_triangular_det (M : Matrix m m R) (p : m → Prop) [DecidablePred p]\n    (h : ∀ i, ¬p i → ∀ j, p j → M i j = 0) :\n    M.det = (toSquareBlockProp M p).det * (toSquareBlockProp M fun i => ¬p i).det :=\n  by\n  rw [det_to_block M p]\n  convert det_from_blocks_zero₂₁ (to_block M p p) (to_block M p fun j => ¬p j)\n      (to_block M (fun j => ¬p j) fun j => ¬p j)\n  ext\n  exact h (↑i) i.2 (↑j) j.2\n#align two_block_triangular_det two_block_triangular_det\n\n",
 "transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\nprotected theorem block_triangular.transpose :\n    M.block_triangular b → (matrix.transpose M).block_triangular (toDual ∘ b) :=\n  swap\n#align block_triangular.transpose block_triangular.transpose\n\n",
 "to_block_inverse_mul_to_block_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem block_triangular.to_block_inverse_mul_to_block_eq_one [linear_order α] [Invertible M] (hM : BlockTriangular M b)\n    (k : α) :\n    matrix.mul (M⁻¹.to_block (fun i => b i < k) fun i => b i < k) (M.to_block (fun i => b i < k) fun i => b i < k) =\n      1 :=\n  by\n  let p i := b i < k\n  have h_sum :\n    matrix.mul (M⁻¹.to_block p p) (M.to_block p p) +\n        matrix.mul (M⁻¹.to_block p fun i => ¬p i) (M.to_block (fun i => ¬p i) p) =\n      1 :=\n    by rw [← to_block_mul_eq_add, inv_mul_of_invertible M, to_block_one_self]\n  have h_zero : M.to_block (fun i => ¬p i) p = 0 := by\n    ext (i j)\n    simpa using hM (lt_of_lt_of_le j.2 (le_of_not_lt i.2))\n  simpa [h_zero] using h_sum\n#align block_triangular.to_block_inverse_mul_to_block_eq_one block_triangular.to_block_inverse_mul_to_block_eq_one\n\n",
 "to_block_inverse_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- A lower-left subblock of the inverse of a block-triangular matrix is zero. This is a first step\ntowards `block_triangular.inv_to_block` below. -/\ntheorem to_block_inverse_eq_zero [linear_order α] [Invertible M] (hM : BlockTriangular M b) (k : α) :\n    (M⁻¹.to_block (fun i => k ≤ b i) fun i => b i < k) = 0 :=\n  by\n  let p i := b i < k\n  let q i := ¬b i < k\n  have h_sum : matrix.mul (M⁻¹.to_block q p) (M.to_block p p) + matrix.mul (M⁻¹.to_block q q) (M.to_block q p) = 0 :=\n    by\n    rw [← to_block_mul_eq_add, inv_mul_of_invertible M, to_block_one_disjoint]\n    rw [disjoint_iff_inf_le]\n    exact fun i h => h.1 h.2\n  have h_zero : M.to_block q p = 0 := by\n    ext (i j)\n    simpa using hM (lt_of_lt_of_le j.2 <| le_of_not_lt i.2)\n  have h_mul_eq_zero : matrix.mul (M⁻¹.to_block q p) (M.to_block p p) = 0 := by simpa [h_zero] using h_sum\n  haveI : Invertible (M.to_block p p) := hM.invertible_to_block k\n  have : (fun i => k ≤ b i) = q := by\n    ext\n    exact not_lt.symm\n  rw [this, ← Matrix.zero_mul (M.to_block p p)⁻¹, ← h_mul_eq_zero, mul_inv_cancel_right_of_invertible]\n#align to_block_inverse_eq_zero to_block_inverse_eq_zero\n\n",
 "submatrix":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\n@[simp]\nprotected theorem block_triangular.submatrix {f : n → m} (h : M.block_triangular b) :\n    (M.submatrix f f).block_triangular (b ∘ f) := fun i j hij => h hij\n#align block_triangular.submatrix block_triangular.submatrix\n\n",
 "sub":
 "theorem block_triangular.sub (hM : BlockTriangular M b) (hN : BlockTriangular N b) : BlockTriangular (M - N) b :=\n  fun i j h => by simp_rw [Pi.sub_apply, hM h, hN h, sub_zero]\n#align block_triangular.sub block_triangular.sub\n\n",
 "neg":
 "protected theorem block_triangular.neg (hM : BlockTriangular M b) : BlockTriangular (-M) b := fun i j h =>\n  neg_eq_zero.2 <| hM h\n#align block_triangular.neg block_triangular.neg\n\n",
 "mul":
 "theorem block_triangular.mul [Fintype m] {M N : Matrix m m R} (hM : BlockTriangular M b) (hN : BlockTriangular N b) :\n    BlockTriangular (M * N) b := by\n  intro i j hij\n  apply Finset.sum_eq_zero\n  intro k hk\n  by_cases hki : b k < b i\n  · simp_rw [hM hki, MulZeroClass.zero_mul]\n  · simp_rw [hN (lt_of_lt_of_le hij (le_of_not_lt hki)), MulZeroClass.mul_zero]\n#align block_triangular.mul block_triangular.mul\n\n",
 "inv_to_block":
 "/-- The inverse of an upper-left subblock of a block-triangular matrix `M` is the upper-left\nsubblock of `M⁻¹`. -/\ntheorem block_triangular.inv_to_block [linear_order α] [Invertible M] (hM : BlockTriangular M b) (k : α) :\n    (M.to_block (fun i => b i < k) fun i => b i < k)⁻¹ = M⁻¹.to_block (fun i => b i < k) fun i => b i < k :=\n  inv_eq_left_inv <| hM.to_block_inverse_mul_to_block_eq_one k\n#align block_triangular.inv_to_block block_triangular.inv_to_block\n\n",
 "equiv_block_det":
 "theorem equiv_block_det (M : Matrix m m R) {p q : m → Prop} [DecidablePred p] [DecidablePred q] (e : ∀ x, q x ↔ p x) :\n    (toSquareBlockProp M p).det = (toSquareBlockProp M q).det := by\n  convert Matrix.det_reindex_self (Equiv.subtypeEquivRight e) (to_square_block_prop M q)\n#align equiv_block_det equiv_block_det\n\n",
 "det_to_square_block_id":
 "@[simp]\ntheorem det_to_square_block_id (M : Matrix m m R) (i : m) : (M.to_square_block id i).det = M i i :=\n  letI : Unique { a // id a = i } := ⟨⟨⟨i, rfl⟩⟩, fun j => Subtype.ext j.property⟩\n  (det_unique _).trans rfl\n#align det_to_square_block_id det_to_square_block_id\n\n",
 "det_to_block":
 "theorem det_to_block (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :\n    M.det =\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|\n          toBlock M (fun j => ¬p j) fun j => ¬p j).det :=\n  by\n  rw [← Matrix.det_reindex_self (Equiv.sumCompl p).symm M]\n  rw [det_apply', det_apply']\n  congr ; ext σ; congr ; ext\n  generalize hy : σ x = y\n  cases x <;> cases y <;>\n    simp only [Matrix.reindex_apply, to_block_apply, Equiv.symm_symm, Equiv.sumCompl_apply_inr,\n      Equiv.sumCompl_apply_inl, from_blocks_apply₁₁, from_blocks_apply₁₂, from_blocks_apply₂₁, from_blocks_apply₂₂,\n      Matrix.submatrix_apply]\n#align det_to_block det_to_block\n\n",
 "det_of_upper_triangular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem det_of_upper_triangular [linear_order m] (h : M.block_triangular id) :\n    M.det =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (M i i) :=\n  by\n  haveI : DecidableEq R := Classical.decEq _\n  simp_rw [h.det, image_id, det_to_square_block_id]\n#align det_of_upper_triangular det_of_upper_triangular\n\n",
 "det_of_lower_triangular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem det_of_lower_triangular [linear_order m] (M : Matrix m m R) (h : M.block_triangular toDual) :\n    M.det =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (M i i) :=\n  by\n  rw [← det_transpose]\n  exact det_of_upper_triangular h.transpose\n#align det_of_lower_triangular det_of_lower_triangular\n\n",
 "det_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem block_triangular.det_fintype [DecidableEq α] [Fintype α] [linear_order α] (h : BlockTriangular M b) :\n    M.det =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (M.to_square_block b k).det :=\n  by\n  refine' h.det.trans (prod_subset (subset_univ _) fun a _ ha => _)\n  have : IsEmpty { i // b i = a } := ⟨fun i => ha <| mem_image.2 ⟨i, mem_univ _, i.2⟩⟩\n  exact det_is_empty\n#align block_triangular.det_fintype block_triangular.det_fintype\n\n",
 "det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\nprotected theorem block_triangular.det [DecidableEq α] [linear_order α] (hM : BlockTriangular M b) :\n    M.det =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (univ.image b)\n        (M.to_square_block b a).det :=\n  by\n  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m\n  subst hs\n  cases isEmpty_or_nonempty m\n  · simp\n  let k := (univ.image b).max' (univ_nonempty.image _)\n  rw [two_block_triangular_det' M fun i => b i = k]\n  · have : univ.image b = insert k ((univ.image b).erase k) :=\n      by\n      rw [insert_erase]\n      apply max'_mem\n    rw [this, prod_insert (not_mem_erase _ _)]\n    refine' congr_arg _ _\n    let b' := fun i : { a // b a ≠ k } => b ↑i\n    have h' : block_triangular (M.to_square_block_prop fun i => b i ≠ k) b' := hM.submatrix\n    have hb' : image b' univ = (image b univ).erase k := by convert image_subtype_ne_univ_eq_image_erase k b\n    rw [ih _ (erase_ssubset <| max'_mem _ _) h' hb']\n    refine' Finset.prod_congr rfl fun l hl => _\n    let he : «expr ≃ » { a // b' a = l } { a // b a = l } :=\n      haveI hc : ∀ i, b i = l → b i ≠ k := fun i hi => ne_of_eq_of_ne hi (ne_of_mem_erase hl)\n      Equiv.subtypeSubtypeEquivSubtype hc\n    simp only [to_square_block_def]\n    rw [← Matrix.det_reindex_self he.symm fun i j : { a // b a = l } => M ↑i ↑j]\n    rfl\n  · intro i hi j hj\n    apply hM\n    rw [hi]\n    apply lt_of_le_of_ne _ hj\n    exact Finset.le_max' (univ.image b) _ (mem_image_of_mem _ (mem_univ _))\n#align block_triangular.det block_triangular.det\n\n",
 "block_triangular_zero":
 "@[simp]\ntheorem block_triangular_zero : BlockTriangular (0 : Matrix m m R) b := fun i j h => rfl\n#align block_triangular_zero block_triangular_zero\n\n",
 "block_triangular_transpose_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᵒᵈ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\nprotected theorem block_triangular_transpose_iff {b : m → «expr ᵒᵈ» α} :\n    (matrix.transpose M).block_triangular b ↔ M.block_triangular (ofDual ∘ b) :=\n  forall_swap\n#align block_triangular_transpose_iff block_triangular_transpose_iff\n\n",
 "block_triangular_reindex_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem block_triangular_reindex_iff {b : n → α} {e : «expr ≃ » m n} :\n    (reindex e e M).block_triangular b ↔ M.block_triangular (b ∘ e) :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · convert h.submatrix\n    simp only [reindex_apply, submatrix_submatrix, submatrix_id_id, Equiv.symm_comp_self]\n  · convert h.submatrix\n    simp only [comp.assoc b e e.symm, Equiv.self_comp_symm, comp.right_id]\n#align block_triangular_reindex_iff block_triangular_reindex_iff\n\n",
 "block_triangular_inv_of_block_triangular":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/-- The inverse of a block-triangular matrix is block-triangular. -/\ntheorem block_triangular_inv_of_block_triangular [linear_order α] [Invertible M] (hM : BlockTriangular M b) :\n    BlockTriangular M⁻¹ b :=\n  by\n  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m\n  subst hs\n  intro i j hij\n  haveI : Inhabited m := ⟨i⟩\n  let k := (univ.image b).max' (univ_nonempty.image _)\n  let b' := fun i : { a // b a < k } => b ↑i\n  let A := M.to_block (fun i => b i < k) fun j => b j < k\n  obtain hbi | hi : b i = k ∨ _ := (le_max' _ (b i) <| mem_image_of_mem _ <| mem_univ _).eq_or_lt\n  · have : M⁻¹.to_block (fun i => k ≤ b i) (fun i => b i < k) ⟨i, hbi.ge⟩ ⟨j, hbi ▸ hij⟩ = 0 := by\n      simp only [to_block_inverse_eq_zero hM k, Pi.zero_apply]\n    simp [this.symm]\n  haveI : Invertible A := hM.invertible_to_block _\n  have hA : A.block_triangular b' := hM.submatrix\n  have hb' : «expr ⊂ » (image b' univ) (image b univ) :=\n    by\n    convert image_subtype_univ_ssubset_image_univ k b _ (fun a => a < k) (lt_irrefl _)\n    convert max'_mem _ _\n  have hij' : b' ⟨j, hij.trans hi⟩ < b' ⟨i, hi⟩ := by simp_rw [b', Subtype.coe_mk, hij]\n  simp [hM.inv_to_block k, (ih (image b' univ) hb' hA rfl hij').symm]\n#align block_triangular_inv_of_block_triangular block_triangular_inv_of_block_triangular\n\n",
 "block_triangular_diagonal":
 "theorem block_triangular_diagonal [DecidableEq m] (d : m → R) : BlockTriangular (diagonal d) b := fun i j h =>\n  diagonal_apply_ne' d fun h' => ne_of_lt h (congr_arg _ h')\n#align block_triangular_diagonal block_triangular_diagonal\n\n",
 "block_triangular_block_diagonal'":
 "theorem block_triangular_block_diagonal' [DecidableEq α] (d : ∀ i : α, Matrix (m' i) (m' i) R) :\n    BlockTriangular (blockDiagonal' d) Sigma.fst :=\n  by\n  rintro ⟨i, i'⟩ ⟨j, j'⟩ h\n  apply block_diagonal'_apply_ne d i' j' fun h' => ne_of_lt h h'.symm\n#align block_triangular_block_diagonal' block_triangular_block_diagonal'\n\n",
 "block_triangular_block_diagonal":
 "theorem block_triangular_block_diagonal [DecidableEq α] (d : α → Matrix m m R) :\n    BlockTriangular (blockDiagonal d) Prod.snd :=\n  by\n  rintro ⟨i, i'⟩ ⟨j, j'⟩ h\n  rw [block_diagonal'_eq_block_diagonal, block_triangular_block_diagonal']\n  exact h\n#align block_triangular_block_diagonal block_triangular_block_diagonal\n\n",
 "add":
 "theorem block_triangular.add (hM : BlockTriangular M b) (hN : BlockTriangular N b) : BlockTriangular (M + N) b :=\n  fun i j h => by simp_rw [Pi.add_apply, hM h, hN h, zero_add]\n#align block_triangular.add block_triangular.add\n\n"}