{"vec_mul_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\n@[simp]\ntheorem matrix.vec_mul_std_basis (M : matrix m n R) (i j) : M.vec_mul (std_basis R (fun _ => R) i 1) j = M i j :=\n  by\n  have :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((if i = i' then 1 else 0) * M i' j) =\n      M i j :=\n    by simp_rw [boole_mul, finset.sum_ite_eq, finset.mem_univ, if_true]\n  convert this\n  ext\n  split_ifs with h <;> simp only [std_basis_apply]\n  · rw [h, function.update_same]\n  · rw [function.update_noteq (ne.symm h), pi.zero_apply]\n#align matrix.vec_mul_std_basis matrix.vec_mul_std_basis\n\n",
 "to_matrix_transpose_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem linear_map.to_matrix_transpose_apply' (f : «expr →ₗ[ ] » M₁ R M₂) (j : n) :\n    (matrix.transpose (linear_map.to_matrix v₁ v₂ f)) j = v₂.repr (f (v₁ j)) :=\n  linear_map.to_matrix_transpose_apply v₁ v₂ f j\n#align linear_map.to_matrix_transpose_apply' linear_map.to_matrix_transpose_apply'\n\n",
 "to_matrix_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem linear_map.to_matrix_transpose_apply (f : «expr →ₗ[ ] » M₁ R M₂) (j : n) :\n    (matrix.transpose (linear_map.to_matrix v₁ v₂ f)) j = v₂.repr (f (v₁ j)) :=\n  funext fun i => f.to_matrix_apply _ _ i j\n#align linear_map.to_matrix_transpose_apply linear_map.to_matrix_transpose_apply\n\n",
 "to_matrix_to_lin":
 "@[simp]\ntheorem linear_map.to_matrix_to_lin (M : matrix m n R) : linear_map.to_matrix v₁ v₂ (matrix.to_lin v₁ v₂ M) = M := by\n  rw [← matrix.to_lin_symm, linear_equiv.symm_apply_apply]\n#align linear_map.to_matrix_to_lin linear_map.to_matrix_to_lin\n\n",
 "to_matrix_symm":
 "@[simp]\ntheorem linear_map.to_matrix_symm : (linear_map.to_matrix v₁ v₂).symm = matrix.to_lin v₁ v₂ :=\n  rfl\n#align linear_map.to_matrix_symm linear_map.to_matrix_symm\n\n",
 "to_matrix_reindex_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_reindex_range [decidable_eq M₁] [decidable_eq M₂] (f : «expr →ₗ[ ] » M₁ R M₂) (k : m)\n    (i : n) :\n    linear_map.to_matrix v₁.reindex_range v₂.reindex_range f ⟨v₂ k, mem_range_self k⟩ ⟨v₁ i, mem_range_self i⟩ =\n      linear_map.to_matrix v₁ v₂ f k i :=\n  by simp_rw [linear_map.to_matrix_apply, basis.reindex_range_self, basis.reindex_range_repr]\n#align linear_map.to_matrix_reindex_range linear_map.to_matrix_reindex_range\n\n",
 "to_matrix_one":
 "theorem linear_map.to_matrix_one : linear_map.to_matrix v₁ v₁ 1 = 1 :=\n  linear_map.to_matrix_id v₁\n#align linear_map.to_matrix_one linear_map.to_matrix_one\n\n",
 "to_matrix_mul_vec_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_mul_vec_repr (f : «expr →ₗ[ ] » M₁ R M₂) (x : M₁) :\n    (linear_map.to_matrix v₁ v₂ f).mul_vec (v₁.repr x) = v₂.repr (f x) :=\n  by\n  ext i\n  rw [← matrix.to_lin'_apply, linear_map.to_matrix, linear_equiv.trans_apply, matrix.to_lin'_to_matrix',\n    linear_equiv.arrow_congr_apply, v₂.equiv_fun_apply]\n  congr\n  exact v₁.equiv_fun.symm_apply_apply x\n#align linear_map.to_matrix_mul_vec_repr linear_map.to_matrix_mul_vec_repr\n\n",
 "to_matrix_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix_mul (f g : «expr →ₗ[ ] » M₁ R M₁) :\n    linear_map.to_matrix v₁ v₁ (f * g) = matrix.mul (linear_map.to_matrix v₁ v₁ f) (linear_map.to_matrix v₁ v₁ g) := by\n  rw [show @has_mul.mul («expr →ₗ[ ] » M₁ R M₁) _ = linear_map.comp from rfl, linear_map.to_matrix_comp v₁ v₁ v₁ f g]\n#align linear_map.to_matrix_mul linear_map.to_matrix_mul\n\n",
 "to_matrix_lsmul":
 "@[simp]\ntheorem to_matrix_lsmul (x : R) : linear_map.to_matrix b b (algebra.lsmul R S x) = matrix.diagonal fun _ => x :=\n  to_matrix_distrib_mul_action_to_linear_map b x\n#align to_matrix_lsmul to_matrix_lsmul\n\n",
 "to_matrix_lmul_eq":
 "@[simp]\ntheorem to_matrix_lmul_eq (x : S) : linear_map.to_matrix b b (linear_map.mul_left R x) = left_mul_matrix b x :=\n  rfl\n#align to_matrix_lmul_eq to_matrix_lmul_eq\n\n",
 "to_matrix_lmul'":
 "theorem to_matrix_lmul' (x : S) (i j) : linear_map.to_matrix b b (lmul R S x) i j = b.repr (x * b j) i := by\n  simp only [linear_map.to_matrix_apply', coe_lmul_eq_mul, linear_map.mul_apply']\n#align to_matrix_lmul' to_matrix_lmul'\n\n",
 "to_matrix_id":
 "/-- This will be a special case of `linear_map.to_matrix_id_eq_basis_to_matrix`. -/\ntheorem linear_map.to_matrix_id : linear_map.to_matrix v₁ v₁ id = 1 :=\n  by\n  ext (i j)\n  simp [linear_map.to_matrix_apply, matrix.one_apply, finsupp.single_apply, eq_comm]\n#align linear_map.to_matrix_id linear_map.to_matrix_id\n\n",
 "to_matrix_eq_to_matrix'":
 "/-- `linear_map.to_matrix'` is a particular case of `linear_map.to_matrix`, for the standard basis\n`pi.basis_fun R n`. -/\ntheorem linear_map.to_matrix_eq_to_matrix' :\n    linear_map.to_matrix (pi.basis_fun R n) (pi.basis_fun R n) = linear_map.to_matrix' :=\n  rfl\n#align linear_map.to_matrix_eq_to_matrix' linear_map.to_matrix_eq_to_matrix'\n\n",
 "to_matrix_distrib_mul_action_to_linear_map":
 "@[simp]\ntheorem to_matrix_distrib_mul_action_to_linear_map (x : R) :\n    linear_map.to_matrix v₁ v₁ (distrib_mul_action.to_linear_map R M₁ x) = matrix.diagonal fun _ => x :=\n  by\n  ext\n  rw [linear_map.to_matrix_apply, distrib_mul_action.to_linear_map_apply, linear_equiv.map_smul, basis.repr_self,\n    finsupp.smul_single_one, finsupp.single_eq_pi_single, matrix.diagonal, Pi.single_apply]\n#align to_matrix_distrib_mul_action_to_linear_map to_matrix_distrib_mul_action_to_linear_map\n\n",
 "to_matrix_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix_comp [fintype l] [decidable_eq m] (f : «expr →ₗ[ ] » M₂ R M₃) (g : «expr →ₗ[ ] » M₁ R M₂) :\n    linear_map.to_matrix v₁ v₃ (f.comp g) = matrix.mul (linear_map.to_matrix v₂ v₃ f) (linear_map.to_matrix v₁ v₂ g) :=\n  by\n  simp_rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_equiv.arrow_congr_comp _ v₂.equiv_fun,\n    linear_map.to_matrix'_comp]\n#align linear_map.to_matrix_comp linear_map.to_matrix_comp\n\n",
 "to_matrix_basis_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix_basis_equiv [fintype l] [decidable_eq l] (b : basis l R M₁) (b' : basis l R M₂) :\n    linear_map.to_matrix b' b (b'.equiv b (equiv.refl l) : «expr →ₗ[ ] » M₂ R M₁) = 1 :=\n  by\n  ext (i j)\n  simp [linear_map.to_matrix_apply, matrix.one_apply, finsupp.single_apply, eq_comm]\n#align linear_map.to_matrix_basis_equiv linear_map.to_matrix_basis_equiv\n\n",
 "to_matrix_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_apply' (f : «expr →ₗ[ ] » M₁ R M₂) (i : m) (j : n) :\n    linear_map.to_matrix v₁ v₂ f i j = v₂.repr (f (v₁ j)) i :=\n  linear_map.to_matrix_apply v₁ v₂ f i j\n#align linear_map.to_matrix_apply' linear_map.to_matrix_apply'\n\n",
 "to_matrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_apply (f : «expr →ₗ[ ] » M₁ R M₂) (i : m) (j : n) :\n    linear_map.to_matrix v₁ v₂ f i j = v₂.repr (f (v₁ j)) i :=\n  by\n  rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_map.to_matrix'_apply, linear_equiv.arrow_congr_apply,\n    basis.equiv_fun_symm_apply, finset.sum_eq_single j, if_pos rfl, one_smul, basis.equiv_fun_apply]\n  · intro j' _ hj'\n    rw [if_neg hj', zero_smul]\n  · intro hj\n    have := finset.mem_univ j\n    contradiction\n#align linear_map.to_matrix_apply linear_map.to_matrix_apply\n\n",
 "to_matrix_algebra_map":
 "@[simp]\ntheorem linear_map.to_matrix_algebra_map (x : R) :\n    linear_map.to_matrix v₁ v₁ (algebra_map R (module.End R M₁) x) = scalar n x := by\n  simp [module.algebra_map_End_eq_smul_id, linear_map.to_matrix_id]\n#align linear_map.to_matrix_algebra_map linear_map.to_matrix_algebra_map\n\n",
 "to_matrix_alg_equiv_transpose_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem linear_map.to_matrix_alg_equiv_transpose_apply' (f : «expr →ₗ[ ] » M₁ R M₁) (j : n) :\n    (matrix.transpose (linear_map.to_matrix_alg_equiv v₁ f)) j = v₁.repr (f (v₁ j)) :=\n  linear_map.to_matrix_alg_equiv_transpose_apply v₁ f j\n#align linear_map.to_matrix_alg_equiv_transpose_apply' linear_map.to_matrix_alg_equiv_transpose_apply'\n\n",
 "to_matrix_alg_equiv_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem linear_map.to_matrix_alg_equiv_transpose_apply (f : «expr →ₗ[ ] » M₁ R M₁) (j : n) :\n    (matrix.transpose (linear_map.to_matrix_alg_equiv v₁ f)) j = v₁.repr (f (v₁ j)) :=\n  funext fun i => f.to_matrix_apply _ _ i j\n#align linear_map.to_matrix_alg_equiv_transpose_apply linear_map.to_matrix_alg_equiv_transpose_apply\n\n",
 "to_matrix_alg_equiv_to_lin_alg_equiv":
 "@[simp]\ntheorem linear_map.to_matrix_alg_equiv_to_lin_alg_equiv (M : matrix n n R) :\n    linear_map.to_matrix_alg_equiv v₁ (matrix.to_lin_alg_equiv v₁ M) = M := by\n  rw [← matrix.to_lin_alg_equiv_symm, alg_equiv.symm_apply_apply]\n#align linear_map.to_matrix_alg_equiv_to_lin_alg_equiv linear_map.to_matrix_alg_equiv_to_lin_alg_equiv\n\n",
 "to_matrix_alg_equiv_symm":
 "@[simp]\ntheorem linear_map.to_matrix_alg_equiv_symm : (linear_map.to_matrix_alg_equiv v₁).symm = matrix.to_lin_alg_equiv v₁ :=\n  rfl\n#align linear_map.to_matrix_alg_equiv_symm linear_map.to_matrix_alg_equiv_symm\n\n",
 "to_matrix_alg_equiv_reindex_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_alg_equiv_reindex_range [decidable_eq M₁] (f : «expr →ₗ[ ] » M₁ R M₁) (k i : n) :\n    linear_map.to_matrix_alg_equiv v₁.reindex_range f ⟨v₁ k, mem_range_self k⟩ ⟨v₁ i, mem_range_self i⟩ =\n      linear_map.to_matrix_alg_equiv v₁ f k i :=\n  by simp_rw [linear_map.to_matrix_alg_equiv_apply, basis.reindex_range_self, basis.reindex_range_repr]\n#align linear_map.to_matrix_alg_equiv_reindex_range linear_map.to_matrix_alg_equiv_reindex_range\n\n",
 "to_matrix_alg_equiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix_alg_equiv_mul (f g : «expr →ₗ[ ] » M₁ R M₁) :\n    linear_map.to_matrix_alg_equiv v₁ (f * g) =\n      matrix.mul (linear_map.to_matrix_alg_equiv v₁ f) (linear_map.to_matrix_alg_equiv v₁ g) :=\n  by\n  rw [show @has_mul.mul («expr →ₗ[ ] » M₁ R M₁) _ = linear_map.comp from rfl,\n    linear_map.to_matrix_alg_equiv_comp v₁ f g]\n#align linear_map.to_matrix_alg_equiv_mul linear_map.to_matrix_alg_equiv_mul\n\n",
 "to_matrix_alg_equiv_id":
 "theorem linear_map.to_matrix_alg_equiv_id : linear_map.to_matrix_alg_equiv v₁ id = 1 := by\n  simp_rw [linear_map.to_matrix_alg_equiv, alg_equiv.of_linear_equiv_apply, linear_map.to_matrix_id]\n#align linear_map.to_matrix_alg_equiv_id linear_map.to_matrix_alg_equiv_id\n\n",
 "to_matrix_alg_equiv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix_alg_equiv_comp (f g : «expr →ₗ[ ] » M₁ R M₁) :\n    linear_map.to_matrix_alg_equiv v₁ (f.comp g) =\n      matrix.mul (linear_map.to_matrix_alg_equiv v₁ f) (linear_map.to_matrix_alg_equiv v₁ g) :=\n  by simp [linear_map.to_matrix_alg_equiv, linear_map.to_matrix_comp v₁ v₁ v₁ f g]\n#align linear_map.to_matrix_alg_equiv_comp linear_map.to_matrix_alg_equiv_comp\n\n",
 "to_matrix_alg_equiv_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_alg_equiv_apply' (f : «expr →ₗ[ ] » M₁ R M₁) (i j : n) :\n    linear_map.to_matrix_alg_equiv v₁ f i j = v₁.repr (f (v₁ j)) i :=\n  linear_map.to_matrix_alg_equiv_apply v₁ f i j\n#align linear_map.to_matrix_alg_equiv_apply' linear_map.to_matrix_alg_equiv_apply'\n\n",
 "to_matrix_alg_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.to_matrix_alg_equiv_apply (f : «expr →ₗ[ ] » M₁ R M₁) (i j : n) :\n    linear_map.to_matrix_alg_equiv v₁ f i j = v₁.repr (f (v₁ j)) i := by\n  simp [linear_map.to_matrix_alg_equiv, linear_map.to_matrix_apply]\n#align linear_map.to_matrix_alg_equiv_apply linear_map.to_matrix_alg_equiv_apply\n\n",
 "to_matrix_alg_equiv'_to_lin_alg_equiv'":
 "@[simp]\ntheorem linear_map.to_matrix_alg_equiv'_to_lin_alg_equiv' (M : matrix n n R) :\n    linear_map.to_matrix_alg_equiv' (matrix.to_lin_alg_equiv' M) = M :=\n  linear_map.to_matrix_alg_equiv'.apply_symm_apply M\n#align linear_map.to_matrix_alg_equiv'_to_lin_alg_equiv' linear_map.to_matrix_alg_equiv'_to_lin_alg_equiv'\n\n",
 "to_matrix_alg_equiv'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix_alg_equiv'_symm :\n    (linear_map.to_matrix_alg_equiv'.symm : «expr ≃ₐ[ ] » (matrix n n R) R _) = matrix.to_lin_alg_equiv' :=\n  rfl\n#align linear_map.to_matrix_alg_equiv'_symm linear_map.to_matrix_alg_equiv'_symm\n\n",
 "to_matrix_alg_equiv'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix_alg_equiv'_mul (f g : «expr →ₗ[ ] » (n → R) R (n → R)) :\n    (f * g).to_matrix_alg_equiv' = matrix.mul f.to_matrix_alg_equiv' g.to_matrix_alg_equiv' :=\n  linear_map.to_matrix_alg_equiv'_comp f g\n#align linear_map.to_matrix_alg_equiv'_mul linear_map.to_matrix_alg_equiv'_mul\n\n",
 "to_matrix_alg_equiv'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix_alg_equiv'_id :\n    linear_map.to_matrix_alg_equiv' (linear_map.id : «expr →ₗ[ ] » (n → R) R (n → R)) = 1 :=\n  linear_map.to_matrix'_id\n#align linear_map.to_matrix_alg_equiv'_id linear_map.to_matrix_alg_equiv'_id\n\n",
 "to_matrix_alg_equiv'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix_alg_equiv'_comp (f g : «expr →ₗ[ ] » (n → R) R (n → R)) :\n    (f.comp g).to_matrix_alg_equiv' = matrix.mul f.to_matrix_alg_equiv' g.to_matrix_alg_equiv' :=\n  linear_map.to_matrix'_comp _ _\n#align linear_map.to_matrix_alg_equiv'_comp linear_map.to_matrix_alg_equiv'_comp\n\n",
 "to_matrix_alg_equiv'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix_alg_equiv'_apply (f : «expr →ₗ[ ] » (n → R) R (n → R)) (i j) :\n    linear_map.to_matrix_alg_equiv' f i j = f (fun j' => if j' = j then 1 else 0) i := by\n  simp [linear_map.to_matrix_alg_equiv']\n#align linear_map.to_matrix_alg_equiv'_apply linear_map.to_matrix_alg_equiv'_apply\n\n",
 "to_matrix'_to_lin'":
 "@[simp]\ntheorem linear_map.to_matrix'_to_lin' (M : matrix m n R) : linear_map.to_matrix' (matrix.to_lin' M) = M :=\n  linear_map.to_matrix'.apply_symm_apply M\n#align linear_map.to_matrix'_to_lin' linear_map.to_matrix'_to_lin'\n\n",
 "to_matrix'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix'_symm : (linear_map.to_matrix'.symm : «expr ≃ₗ[ ] » (matrix m n R) R _) = matrix.to_lin' :=\n  rfl\n#align linear_map.to_matrix'_symm linear_map.to_matrix'_symm\n\n",
 "to_matrix'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix'_mul [fintype m] [decidable_eq m] (f g : «expr →ₗ[ ] » (m → R) R (m → R)) :\n    (f * g).to_matrix' = matrix.mul f.to_matrix' g.to_matrix' :=\n  linear_map.to_matrix'_comp f g\n#align linear_map.to_matrix'_mul linear_map.to_matrix'_mul\n\n",
 "to_matrix'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix'_id : linear_map.to_matrix' (linear_map.id : «expr →ₗ[ ] » (n → R) R (n → R)) = 1 :=\n  by\n  ext\n  rw [matrix.one_apply, linear_map.to_matrix'_apply, id_apply]\n#align linear_map.to_matrix'_id linear_map.to_matrix'_id\n\n",
 "to_matrix'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem linear_map.to_matrix'_comp [fintype l] [decidable_eq l] (f : «expr →ₗ[ ] » (n → R) R (m → R))\n    (g : «expr →ₗ[ ] » (l → R) R (n → R)) : (f.comp g).to_matrix' = matrix.mul f.to_matrix' g.to_matrix' :=\n  by\n  suffices f.comp g = (matrix.mul f.to_matrix' g.to_matrix').to_lin' by rw [this, linear_map.to_matrix'_to_lin']\n  rw [matrix.to_lin'_mul, matrix.to_lin'_to_matrix', matrix.to_lin'_to_matrix']\n#align linear_map.to_matrix'_comp linear_map.to_matrix'_comp\n\n",
 "to_matrix'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_matrix'_apply (f : «expr →ₗ[ ] » (n → R) R (m → R)) (i j) :\n    linear_map.to_matrix' f i j = f (fun j' => if j' = j then 1 else 0) i :=\n  by\n  simp only [linear_map.to_matrix', linear_equiv.coe_mk, of_apply]\n  congr\n  ext j'\n  split_ifs with h\n  · rw [h, std_basis_same]\n  apply std_basis_ne _ _ _ _ h\n#align linear_map.to_matrix'_apply linear_map.to_matrix'_apply\n\n",
 "to_matrix'_algebra_map":
 "@[simp]\ntheorem linear_map.to_matrix'_algebra_map (x : R) :\n    linear_map.to_matrix' (algebra_map R (module.End R (n → R)) x) = scalar n x := by\n  simp [module.algebra_map_End_eq_smul_id]\n#align linear_map.to_matrix'_algebra_map linear_map.to_matrix'_algebra_map\n\n",
 "to_linear_map_right'_one":
 "@[simp]\ntheorem matrix.to_linear_map_right'_one : matrix.to_linear_map_right' (1 : matrix m m R) = id :=\n  by\n  ext\n  simp [linear_map.one_apply, std_basis_apply]\n#align matrix.to_linear_map_right'_one matrix.to_linear_map_right'_one\n\n",
 "to_linear_map_right'_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem matrix.to_linear_map_right'_mul_apply [fintype l] [decidable_eq l] (M : matrix l m R) (N : matrix m n R) (x) :\n    matrix.to_linear_map_right' (matrix.mul M N) x = matrix.to_linear_map_right' N (matrix.to_linear_map_right' M x) :=\n  (vec_mul_vec_mul _ M N).symm\n#align matrix.to_linear_map_right'_mul_apply matrix.to_linear_map_right'_mul_apply\n\n",
 "to_linear_map_right'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem matrix.to_linear_map_right'_mul [fintype l] [decidable_eq l] (M : matrix l m R) (N : matrix m n R) :\n    matrix.to_linear_map_right' (matrix.mul M N) =\n      (matrix.to_linear_map_right' N).comp (matrix.to_linear_map_right' M) :=\n  linear_map.ext fun x => (vec_mul_vec_mul _ M N).symm\n#align matrix.to_linear_map_right'_mul matrix.to_linear_map_right'_mul\n\n",
 "to_linear_map_right'_apply":
 "@[simp]\ntheorem matrix.to_linear_map_right'_apply (M : matrix m n R) (v : m → R) :\n    matrix.to_linear_map_right' M v = M.vec_mul v :=\n  rfl\n#align matrix.to_linear_map_right'_apply matrix.to_linear_map_right'_apply\n\n",
 "to_lin_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_lin_to_matrix (f : «expr →ₗ[ ] » M₁ R M₂) : matrix.to_lin v₁ v₂ (linear_map.to_matrix v₁ v₂ f) = f :=\n  by rw [← matrix.to_lin_symm, linear_equiv.apply_symm_apply]\n#align matrix.to_lin_to_matrix matrix.to_lin_to_matrix\n\n",
 "to_lin_symm":
 "@[simp]\ntheorem matrix.to_lin_symm : (matrix.to_lin v₁ v₂).symm = linear_map.to_matrix v₁ v₂ :=\n  rfl\n#align matrix.to_lin_symm matrix.to_lin_symm\n\n",
 "to_lin_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem matrix.to_lin_self (M : matrix m n R) (i : n) :\n    matrix.to_lin v₁ v₂ M (v₁ i) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M j i) (v₂ j)) :=\n  by\n  rw [matrix.to_lin_apply, finset.sum_congr rfl fun j hj => _]\n  rw [basis.repr_self, matrix.mul_vec, dot_product, finset.sum_eq_single i, finsupp.single_eq_same, mul_one]\n  · intro i' _ i'_ne\n    rw [finsupp.single_eq_of_ne i'_ne.symm, mul_zero]\n  · intros\n    have := finset.mem_univ i\n    contradiction\n#align matrix.to_lin_self matrix.to_lin_self\n\n",
 "to_lin_one":
 "@[simp]\ntheorem matrix.to_lin_one : matrix.to_lin v₁ v₁ 1 = id := by rw [← linear_map.to_matrix_id v₁, matrix.to_lin_to_matrix]\n#align matrix.to_lin_one matrix.to_lin_one\n\n",
 "to_lin_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Shortcut lemma for `matrix.to_lin_mul` and `linear_map.comp_apply`. -/\ntheorem matrix.to_lin_mul_apply [fintype l] [decidable_eq m] (A : matrix l m R) (B : matrix m n R) (x) :\n    matrix.to_lin v₁ v₃ (matrix.mul A B) x = (matrix.to_lin v₂ v₃ A) (matrix.to_lin v₁ v₂ B x) := by\n  rw [matrix.to_lin_mul v₁ v₂, linear_map.comp_apply]\n#align matrix.to_lin_mul_apply matrix.to_lin_mul_apply\n\n",
 "to_lin_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem matrix.to_lin_mul [fintype l] [decidable_eq m] (A : matrix l m R) (B : matrix m n R) :\n    matrix.to_lin v₁ v₃ (matrix.mul A B) = (matrix.to_lin v₂ v₃ A).comp (matrix.to_lin v₁ v₂ B) :=\n  by\n  apply (linear_map.to_matrix v₁ v₃).injective\n  haveI : decidable_eq l := fun _ _ => classical.prop_decidable _\n  rw [linear_map.to_matrix_comp v₁ v₂ v₃]\n  repeat' rw [linear_map.to_matrix_to_lin]\n#align matrix.to_lin_mul matrix.to_lin_mul\n\n",
 "to_lin_fin_two_prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr!![ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\n@[simp]\ntheorem matrix.to_lin_fin_two_prod_apply (a b c d : R) (x : R × R) :\n    matrix.to_lin (basis.fin_two_prod R) (basis.fin_two_prod R)\n        («expr!![ » \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\") x =\n      (a * x.fst + b * x.snd, c * x.fst + d * x.snd) :=\n  by simp [matrix.to_lin_apply, matrix.mul_vec, matrix.dot_product]\n#align matrix.to_lin_fin_two_prod_apply matrix.to_lin_fin_two_prod_apply\n\n",
 "to_lin_fin_two_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr!![ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem matrix.to_lin_fin_two_prod (a b c d : R) :\n    matrix.to_lin (basis.fin_two_prod R) (basis.fin_two_prod R)\n        («expr!![ » \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\") =\n      («expr • » a (linear_map.fst R R R) + «expr • » b (linear_map.snd R R R)).prod\n        («expr • » c (linear_map.fst R R R) + «expr • » d (linear_map.snd R R R)) :=\n  linear_map.ext <| matrix.to_lin_fin_two_prod_apply _ _ _ _\n#align matrix.to_lin_fin_two_prod matrix.to_lin_fin_two_prod\n\n",
 "to_lin_eq_to_lin'":
 "/-- `matrix.to_lin'` is a particular case of `matrix.to_lin`, for the standard basis\n`pi.basis_fun R n`. -/\ntheorem matrix.to_lin_eq_to_lin' : matrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin' :=\n  rfl\n#align matrix.to_lin_eq_to_lin' matrix.to_lin_eq_to_lin'\n\n",
 "to_lin_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem matrix.to_lin_apply (M : matrix m n R) (v : M₁) :\n    matrix.to_lin v₁ v₂ M v =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M.mul_vec (v₁.repr v) j) (v₂ j)) :=\n  show v₂.equiv_fun.symm (matrix.to_lin' M (v₁.repr v)) = _ by rw [matrix.to_lin'_apply, v₂.equiv_fun_symm_apply]\n#align matrix.to_lin_apply matrix.to_lin_apply\n\n",
 "to_lin_alg_equiv_to_matrix_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_lin_alg_equiv_to_matrix_alg_equiv (f : «expr →ₗ[ ] » M₁ R M₁) :\n    matrix.to_lin_alg_equiv v₁ (linear_map.to_matrix_alg_equiv v₁ f) = f := by\n  rw [← matrix.to_lin_alg_equiv_symm, alg_equiv.apply_symm_apply]\n#align matrix.to_lin_alg_equiv_to_matrix_alg_equiv matrix.to_lin_alg_equiv_to_matrix_alg_equiv\n\n",
 "to_lin_alg_equiv_symm":
 "@[simp]\ntheorem matrix.to_lin_alg_equiv_symm : (matrix.to_lin_alg_equiv v₁).symm = linear_map.to_matrix_alg_equiv v₁ :=\n  rfl\n#align matrix.to_lin_alg_equiv_symm matrix.to_lin_alg_equiv_symm\n\n",
 "to_lin_alg_equiv_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem matrix.to_lin_alg_equiv_self (M : matrix n n R) (i : n) :\n    matrix.to_lin_alg_equiv v₁ M (v₁ i) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M j i) (v₁ j)) :=\n  matrix.to_lin_self _ _ _ _\n#align matrix.to_lin_alg_equiv_self matrix.to_lin_alg_equiv_self\n\n",
 "to_lin_alg_equiv_one":
 "@[simp]\ntheorem matrix.to_lin_alg_equiv_one : matrix.to_lin_alg_equiv v₁ 1 = id := by\n  rw [← linear_map.to_matrix_alg_equiv_id v₁, matrix.to_lin_alg_equiv_to_matrix_alg_equiv]\n#align matrix.to_lin_alg_equiv_one matrix.to_lin_alg_equiv_one\n\n",
 "to_lin_alg_equiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem matrix.to_lin_alg_equiv_mul (A B : matrix n n R) :\n    matrix.to_lin_alg_equiv v₁ (matrix.mul A B) = (matrix.to_lin_alg_equiv v₁ A).comp (matrix.to_lin_alg_equiv v₁ B) :=\n  by convert matrix.to_lin_mul v₁ v₁ v₁ A B\n#align matrix.to_lin_alg_equiv_mul matrix.to_lin_alg_equiv_mul\n\n",
 "to_lin_alg_equiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem matrix.to_lin_alg_equiv_apply (M : matrix n n R) (v : M₁) :\n    matrix.to_lin_alg_equiv v₁ M v =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M.mul_vec (v₁.repr v) j) (v₁ j)) :=\n  show v₁.equiv_fun.symm (matrix.to_lin_alg_equiv' M (v₁.repr v)) = _ by\n    rw [matrix.to_lin_alg_equiv'_apply, v₁.equiv_fun_symm_apply]\n#align matrix.to_lin_alg_equiv_apply matrix.to_lin_alg_equiv_apply\n\n",
 "to_lin_alg_equiv'_to_matrix_alg_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_lin_alg_equiv'_to_matrix_alg_equiv' (f : «expr →ₗ[ ] » (n → R) R (n → R)) :\n    matrix.to_lin_alg_equiv' (linear_map.to_matrix_alg_equiv' f) = f :=\n  matrix.to_lin_alg_equiv'.apply_symm_apply f\n#align matrix.to_lin_alg_equiv'_to_matrix_alg_equiv' matrix.to_lin_alg_equiv'_to_matrix_alg_equiv'\n\n",
 "to_lin_alg_equiv'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_lin_alg_equiv'_symm :\n    (matrix.to_lin_alg_equiv'.symm : «expr ≃ₐ[ ] » («expr →ₗ[ ] » (n → R) R (n → R)) R _) =\n      linear_map.to_matrix_alg_equiv' :=\n  rfl\n#align matrix.to_lin_alg_equiv'_symm matrix.to_lin_alg_equiv'_symm\n\n",
 "to_lin_alg_equiv'_one":
 "@[simp]\ntheorem matrix.to_lin_alg_equiv'_one : matrix.to_lin_alg_equiv' (1 : matrix n n R) = id :=\n  matrix.to_lin'_one\n#align matrix.to_lin_alg_equiv'_one matrix.to_lin_alg_equiv'_one\n\n",
 "to_lin_alg_equiv'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem matrix.to_lin_alg_equiv'_mul (M N : matrix n n R) :\n    matrix.to_lin_alg_equiv' (matrix.mul M N) = (matrix.to_lin_alg_equiv' M).comp (matrix.to_lin_alg_equiv' N) :=\n  matrix.to_lin'_mul _ _\n#align matrix.to_lin_alg_equiv'_mul matrix.to_lin_alg_equiv'_mul\n\n",
 "to_lin_alg_equiv'_apply":
 "@[simp]\ntheorem matrix.to_lin_alg_equiv'_apply (M : matrix n n R) (v : n → R) : matrix.to_lin_alg_equiv' M v = M.mul_vec v :=\n  rfl\n#align matrix.to_lin_alg_equiv'_apply matrix.to_lin_alg_equiv'_apply\n\n",
 "to_lin'_to_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_lin'_to_matrix' (f : «expr →ₗ[ ] » (n → R) R (m → R)) :\n    matrix.to_lin' (linear_map.to_matrix' f) = f :=\n  matrix.to_lin'.apply_symm_apply f\n#align matrix.to_lin'_to_matrix' matrix.to_lin'_to_matrix'\n\n",
 "to_lin'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_lin'_symm :\n    (matrix.to_lin'.symm : «expr ≃ₗ[ ] » («expr →ₗ[ ] » (n → R) R (m → R)) R _) = linear_map.to_matrix' :=\n  rfl\n#align matrix.to_lin'_symm matrix.to_lin'_symm\n\n",
 "to_lin'_one":
 "@[simp]\ntheorem matrix.to_lin'_one : matrix.to_lin' (1 : matrix n n R) = id :=\n  by\n  ext\n  simp [linear_map.one_apply, std_basis_apply]\n#align matrix.to_lin'_one matrix.to_lin'_one\n\n",
 "to_lin'_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Shortcut lemma for `matrix.to_lin'_mul` and `linear_map.comp_apply` -/\ntheorem matrix.to_lin'_mul_apply [fintype m] [decidable_eq m] (M : matrix l m R) (N : matrix m n R) (x) :\n    matrix.to_lin' (matrix.mul M N) x = matrix.to_lin' M (matrix.to_lin' N x) := by\n  rw [matrix.to_lin'_mul, linear_map.comp_apply]\n#align matrix.to_lin'_mul_apply matrix.to_lin'_mul_apply\n\n",
 "to_lin'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem matrix.to_lin'_mul [fintype m] [decidable_eq m] (M : matrix l m R) (N : matrix m n R) :\n    matrix.to_lin' (matrix.mul M N) = (matrix.to_lin' M).comp (matrix.to_lin' N) :=\n  linear_map.ext fun x => (mul_vec_mul_vec _ _ _).symm\n#align matrix.to_lin'_mul matrix.to_lin'_mul\n\n",
 "to_lin'_apply":
 "@[simp]\ntheorem matrix.to_lin'_apply (M : matrix m n R) (v : n → R) : matrix.to_lin' M v = M.mul_vec v :=\n  rfl\n#align matrix.to_lin'_apply matrix.to_lin'_apply\n\n",
 "smul_left_mul_matrix_algebra_map_ne":
 "theorem smul_left_mul_matrix_algebra_map_ne (x : S) (i j) {k k'} (h : k ≠ k') :\n    left_mul_matrix (b.smul c) (algebra_map _ _ x) (i, k) (j, k') = 0 := by\n  rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_ne _ _ _ h]\n#align smul_left_mul_matrix_algebra_map_ne smul_left_mul_matrix_algebra_map_ne\n\n",
 "smul_left_mul_matrix_algebra_map_eq":
 "theorem smul_left_mul_matrix_algebra_map_eq (x : S) (i j k) :\n    left_mul_matrix (b.smul c) (algebra_map _ _ x) (i, k) (j, k) = left_mul_matrix b x i j := by\n  rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_eq]\n#align smul_left_mul_matrix_algebra_map_eq smul_left_mul_matrix_algebra_map_eq\n\n",
 "smul_left_mul_matrix_algebra_map":
 "theorem smul_left_mul_matrix_algebra_map (x : S) :\n    left_mul_matrix (b.smul c) (algebra_map _ _ x) = block_diagonal fun k => left_mul_matrix b x :=\n  by\n  ext (⟨i, k⟩⟨j, k'⟩)\n  rw [smul_left_mul_matrix, alg_hom.commutes, block_diagonal_apply, algebra_map_matrix_apply]\n  split_ifs with h <;> simp [h]\n#align smul_left_mul_matrix_algebra_map smul_left_mul_matrix_algebra_map\n\n",
 "smul_left_mul_matrix":
 "theorem smul_left_mul_matrix (x) (ik jk) :\n    left_mul_matrix (b.smul c) x ik jk = left_mul_matrix b (left_mul_matrix c x ik.2 jk.2) ik.1 jk.1 := by\n  simp only [left_mul_matrix_apply, linear_map.to_matrix_apply, mul_comm, basis.smul_apply, basis.smul_repr,\n    finsupp.smul_apply, id.smul_eq_mul, linear_equiv.map_smul, mul_smul_comm, coe_lmul_eq_mul, linear_map.mul_apply']\n#align smul_left_mul_matrix smul_left_mul_matrix\n\n",
 "rank_vec_mul_vec":
 "theorem matrix.rank_vec_mul_vec {K m n : Type u} [Field K] [fintype n] [decidable_eq n] (w : m → K) (v : n → K) :\n    rank (vec_mul_vec w v).to_lin' ≤ 1 :=\n  by\n  rw [vec_mul_vec_eq, matrix.to_lin'_mul]\n  refine' le_trans (rank_comp_le1 _ _) _\n  refine' (rank_le_domain _).trans_eq _\n  rw [dim_fun', fintype.card_unit, Nat.cast_one]\n#align matrix.rank_vec_mul_vec matrix.rank_vec_mul_vec\n\n",
 "range_to_lin'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem matrix.range_to_lin' (M : matrix m n R) : M.to_lin'.range = span R (range (matrix.transpose M)) := by\n  simp_rw [range_eq_map, ← supr_range_std_basis, map_supr, range_eq_map, ← ideal.span_singleton_one, ideal.span,\n    submodule.map_span, image_image, image_singleton, matrix.to_lin'_apply, M.mul_vec_std_basis_apply, supr_span,\n    range_eq_Union]\n#align matrix.range_to_lin' matrix.range_to_lin'\n\n",
 "mul_vec_std_basis_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem matrix.mul_vec_std_basis_apply (M : matrix m n R) (j) :\n    M.mul_vec (std_basis R (fun _ => R) j 1) = (matrix.transpose M) j :=\n  funext fun i => matrix.mul_vec_std_basis M i j\n#align matrix.mul_vec_std_basis_apply matrix.mul_vec_std_basis_apply\n\n",
 "mul_vec_std_basis":
 "theorem matrix.mul_vec_std_basis (M : matrix m n R) (i j) : M.mul_vec (std_basis R (fun _ => R) j 1) i = M i j :=\n  (congr_fun (matrix.mul_vec_single _ _ (1 : R)) i).trans <| mul_one _\n#align matrix.mul_vec_std_basis matrix.mul_vec_std_basis\n\n",
 "left_mul_matrix_mul_vec_repr":
 "theorem left_mul_matrix_mul_vec_repr (x y : S) : (left_mul_matrix b x).mul_vec (b.repr y) = b.repr (x * y) :=\n  (linear_map.mul_left R x).to_matrix_mul_vec_repr b b y\n#align left_mul_matrix_mul_vec_repr left_mul_matrix_mul_vec_repr\n\n",
 "left_mul_matrix_injective":
 "theorem left_mul_matrix_injective : function.injective (left_mul_matrix b) := fun x x' h =>\n  calc\n    x = algebra.lmul R S x 1 := (mul_one x).symm\n    _ = algebra.lmul R S x' 1 := by rw [(linear_map.to_matrix b b).injective h]\n    _ = x' := mul_one x'\n    \n#align left_mul_matrix_injective left_mul_matrix_injective\n\n",
 "left_mul_matrix_eq_repr_mul":
 "theorem left_mul_matrix_eq_repr_mul (x : S) (i j) : left_mul_matrix b x i j = b.repr (x * b j) i :=\n  by-- This is defeq to just `to_matrix_lmul' b x i j`,\n  -- but the unfolding goes a lot faster with this explicit `rw`.\n  rw [left_mul_matrix_apply, to_matrix_lmul' b x i j]\n#align left_mul_matrix_eq_repr_mul left_mul_matrix_eq_repr_mul\n\n",
 "left_mul_matrix_apply":
 "theorem left_mul_matrix_apply (x : S) : left_mul_matrix b x = linear_map.to_matrix b b (lmul R S x) :=\n  rfl\n#align left_mul_matrix_apply left_mul_matrix_apply\n\n",
 "ker_to_lin'_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem matrix.ker_to_lin'_eq_bot_iff {M : matrix n n R} : M.to_lin'.ker = «expr⊥» ↔ ∀ v, M.mul_vec v = 0 → v = 0 := by\n  simp only [submodule.eq_bot_iff, linear_map.mem_ker, matrix.to_lin'_apply]\n#align matrix.ker_to_lin'_eq_bot_iff matrix.ker_to_lin'_eq_bot_iff\n\n",
 "finrank_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The dimension of the space of linear transformations is the product of the dimensions of the\ndomain and codomain.\n-/\n@[simp]\ntheorem finrank_linear_map :\n    finite_dimensional.finrank K («expr →ₗ[ ] » V K W) =\n      finite_dimensional.finrank K V * finite_dimensional.finrank K W :=\n  by\n  let hbV := basis.of_vector_space K V\n  let hbW := basis.of_vector_space K W\n  rw [linear_equiv.finrank_eq (linear_map.to_matrix hbV hbW), matrix.finrank_matrix,\n    finite_dimensional.finrank_eq_card_basis hbV, finite_dimensional.finrank_eq_card_basis hbW, mul_comm]\n#align finrank_linear_map finrank_linear_map\n\n"}