{"vecMul_stdBasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n#print Matrix.vecMul_stdBasis /-\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\n@[simp]\ntheorem Matrix.vecMul_stdBasis (M : Matrix m n R) (i j) : M.vec_mul (stdBasis R (fun _ => R) i 1) j = M i j :=\n  by\n  have :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((if i = i' then 1 else 0) * M i' j) =\n      M i j :=\n    by simp_rw [boole_mul, Finset.sum_ite_eq, Finset.mem_univ, if_true]\n  convert this\n  ext\n  split_ifs with h <;> simp only [std_basis_apply]\n  · rw [h, Function.update_same]\n  · rw [Function.update_noteq (ne.symm h), Pi.zero_apply]\n#align matrix.vec_mul_std_basis Matrix.vecMul_stdBasis\n-/\n\n",
 "to_matrix_lsmul":
 "@[simp]\ntheorem to_matrix_lsmul (x : R) : LinearMap.toMatrix b b (Algebra.lsmul R S x) = Matrix.diagonal fun _ => x :=\n  toMatrix_distrib_mul_action_toLinearMap b x\n#align to_matrix_lsmul to_matrix_lsmul\n\n",
 "to_matrix_lmul_eq":
 "@[simp]\ntheorem to_matrix_lmul_eq (x : S) : LinearMap.toMatrix b b (LinearMap.mulLeft R x) = leftMulMatrix b x :=\n  rfl\n#align to_matrix_lmul_eq to_matrix_lmul_eq\n\n",
 "to_matrix_lmul'":
 "theorem to_matrix_lmul' (x : S) (i j) : LinearMap.toMatrix b b (lmul R S x) i j = b.repr (x * b j) i := by\n  simp only [LinearMap.toMatrix_apply', coe_lmul_eq_mul, LinearMap.mul_apply']\n#align to_matrix_lmul' to_matrix_lmul'\n\n",
 "toMatrix_transpose_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print LinearMap.toMatrix_transpose_apply' /-\ntheorem LinearMap.toMatrix_transpose_apply' (f : «expr →ₗ[ ] » M₁ R M₂) (j : n) :\n    (matrix.transpose (LinearMap.toMatrix v₁ v₂ f)) j = v₂.repr (f (v₁ j)) :=\n  LinearMap.toMatrix_transpose_apply v₁ v₂ f j\n#align linear_map.to_matrix_transpose_apply' LinearMap.toMatrix_transpose_apply'\n-/\n\n",
 "toMatrix_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print LinearMap.toMatrix_transpose_apply /-\ntheorem LinearMap.toMatrix_transpose_apply (f : «expr →ₗ[ ] » M₁ R M₂) (j : n) :\n    (matrix.transpose (LinearMap.toMatrix v₁ v₂ f)) j = v₂.repr (f (v₁ j)) :=\n  funext fun i => f.to_matrix_apply _ _ i j\n#align linear_map.to_matrix_transpose_apply LinearMap.toMatrix_transpose_apply\n-/\n\n",
 "toMatrix_toLin":
 "#print LinearMap.toMatrix_toLin /-\n@[simp]\ntheorem LinearMap.toMatrix_toLin (M : Matrix m n R) : LinearMap.toMatrix v₁ v₂ (Matrix.toLin v₁ v₂ M) = M := by\n  rw [← Matrix.toLin_symm, LinearEquiv.symm_apply_apply]\n#align linear_map.to_matrix_to_lin LinearMap.toMatrix_toLin\n-/\n\n",
 "toMatrix_symm":
 "#print LinearMap.toMatrix_symm /-\n@[simp]\ntheorem LinearMap.toMatrix_symm : (LinearMap.toMatrix v₁ v₂).symm = Matrix.toLin v₁ v₂ :=\n  rfl\n#align linear_map.to_matrix_symm LinearMap.toMatrix_symm\n-/\n\n",
 "toMatrix_reindexRange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix_reindexRange /-\ntheorem LinearMap.toMatrix_reindexRange [DecidableEq M₁] [DecidableEq M₂] (f : «expr →ₗ[ ] » M₁ R M₂) (k : m) (i : n) :\n    LinearMap.toMatrix v₁.reindex_range v₂.reindex_range f ⟨v₂ k, mem_range_self k⟩ ⟨v₁ i, mem_range_self i⟩ =\n      LinearMap.toMatrix v₁ v₂ f k i :=\n  by simp_rw [LinearMap.toMatrix_apply, Basis.reindexRange_self, Basis.reindexRange_repr]\n#align linear_map.to_matrix_reindex_range LinearMap.toMatrix_reindexRange\n-/\n\n",
 "toMatrix_one":
 "#print LinearMap.toMatrix_one /-\ntheorem LinearMap.toMatrix_one : LinearMap.toMatrix v₁ v₁ 1 = 1 :=\n  LinearMap.toMatrix_id v₁\n#align linear_map.to_matrix_one LinearMap.toMatrix_one\n-/\n\n",
 "toMatrix_mulVec_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix_mulVec_repr /-\ntheorem LinearMap.toMatrix_mulVec_repr (f : «expr →ₗ[ ] » M₁ R M₂) (x : M₁) :\n    (LinearMap.toMatrix v₁ v₂ f).mul_vec (v₁.repr x) = v₂.repr (f x) :=\n  by\n  ext i\n  rw [← Matrix.toLin'_apply, LinearMap.toMatrix, LinearEquiv.trans_apply, Matrix.toLin'_toMatrix',\n    LinearEquiv.arrowCongr_apply, v₂.equiv_fun_apply]\n  congr\n  exact v₁.equiv_fun.symm_apply_apply x\n#align linear_map.to_matrix_mul_vec_repr LinearMap.toMatrix_mulVec_repr\n-/\n\n",
 "toMatrix_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrix_mul /-\ntheorem LinearMap.toMatrix_mul (f g : «expr →ₗ[ ] » M₁ R M₁) :\n    LinearMap.toMatrix v₁ v₁ (f * g) = matrix.mul (LinearMap.toMatrix v₁ v₁ f) (LinearMap.toMatrix v₁ v₁ g) := by\n  rw [show @has_mul.mul («expr →ₗ[ ] » M₁ R M₁) _ = LinearMap.comp from rfl, LinearMap.toMatrix_comp v₁ v₁ v₁ f g]\n#align linear_map.to_matrix_mul LinearMap.toMatrix_mul\n-/\n\n",
 "toMatrix_id":
 "#print LinearMap.toMatrix_id /-\n/-- This will be a special case of `linear_map.to_matrix_id_eq_basis_to_matrix`. -/\ntheorem LinearMap.toMatrix_id : LinearMap.toMatrix v₁ v₁ id = 1 :=\n  by\n  ext (i j)\n  simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n#align linear_map.to_matrix_id LinearMap.toMatrix_id\n-/\n\n",
 "toMatrix_eq_toMatrix'":
 "#print LinearMap.toMatrix_eq_toMatrix' /-\n/-- `linear_map.to_matrix'` is a particular case of `linear_map.to_matrix`, for the standard basis\n`pi.basis_fun R n`. -/\ntheorem LinearMap.toMatrix_eq_toMatrix' :\n    LinearMap.toMatrix (Pi.basisFun R n) (Pi.basisFun R n) = LinearMap.toMatrix' :=\n  rfl\n#align linear_map.to_matrix_eq_to_matrix' LinearMap.toMatrix_eq_toMatrix'\n-/\n\n",
 "toMatrix_distrib_mul_action_toLinearMap":
 "#print toMatrix_distrib_mul_action_toLinearMap /-\n@[simp]\ntheorem toMatrix_distrib_mul_action_toLinearMap (x : R) :\n    LinearMap.toMatrix v₁ v₁ (DistribMulAction.toLinearMap R M₁ x) = Matrix.diagonal fun _ => x :=\n  by\n  ext\n  rw [LinearMap.toMatrix_apply, DistribMulAction.toLinearMap_apply, LinearEquiv.map_smul, Basis.repr_self,\n    Finsupp.smul_single_one, Finsupp.single_eq_pi_single, Matrix.diagonal_apply, Pi.single_apply]\n#align to_matrix_distrib_mul_action_to_linear_map toMatrix_distrib_mul_action_toLinearMap\n-/\n\n",
 "toMatrix_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrix_comp /-\ntheorem LinearMap.toMatrix_comp [Fintype l] [DecidableEq m] (f : «expr →ₗ[ ] » M₂ R M₃) (g : «expr →ₗ[ ] » M₁ R M₂) :\n    LinearMap.toMatrix v₁ v₃ (f.comp g) = matrix.mul (LinearMap.toMatrix v₂ v₃ f) (LinearMap.toMatrix v₁ v₂ g) := by\n  simp_rw [LinearMap.toMatrix, LinearEquiv.trans_apply, LinearEquiv.arrowCongr_comp _ v₂.equiv_fun,\n    LinearMap.toMatrix'_comp]\n#align linear_map.to_matrix_comp LinearMap.toMatrix_comp\n-/\n\n",
 "toMatrix_basis_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix_basis_equiv /-\n@[simp]\ntheorem LinearMap.toMatrix_basis_equiv [Fintype l] [DecidableEq l] (b : Basis l R M₁) (b' : Basis l R M₂) :\n    LinearMap.toMatrix b' b (b'.equiv b (Equiv.refl l) : «expr →ₗ[ ] » M₂ R M₁) = 1 :=\n  by\n  ext (i j)\n  simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n#align linear_map.to_matrix_basis_equiv LinearMap.toMatrix_basis_equiv\n-/\n\n",
 "toMatrix_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix_apply' /-\ntheorem LinearMap.toMatrix_apply' (f : «expr →ₗ[ ] » M₁ R M₂) (i : m) (j : n) :\n    LinearMap.toMatrix v₁ v₂ f i j = v₂.repr (f (v₁ j)) i :=\n  LinearMap.toMatrix_apply v₁ v₂ f i j\n#align linear_map.to_matrix_apply' LinearMap.toMatrix_apply'\n-/\n\n",
 "toMatrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix_apply /-\ntheorem LinearMap.toMatrix_apply (f : «expr →ₗ[ ] » M₁ R M₂) (i : m) (j : n) :\n    LinearMap.toMatrix v₁ v₂ f i j = v₂.repr (f (v₁ j)) i :=\n  by\n  rw [LinearMap.toMatrix, LinearEquiv.trans_apply, LinearMap.toMatrix'_apply, LinearEquiv.arrowCongr_apply,\n    Basis.equivFun_symm_apply, Finset.sum_eq_single j, if_pos rfl, one_smul, Basis.equivFun_apply]\n  · intro j' _ hj'\n    rw [if_neg hj', zero_smul]\n  · intro hj\n    have := Finset.mem_univ j\n    contradiction\n#align linear_map.to_matrix_apply LinearMap.toMatrix_apply\n-/\n\n",
 "toMatrix_algebraMap":
 "#print LinearMap.toMatrix_algebraMap /-\n@[simp]\ntheorem LinearMap.toMatrix_algebraMap (x : R) :\n    LinearMap.toMatrix v₁ v₁ (algebraMap R (Module.End R M₁) x) = scalar n x := by\n  simp [Module.algebraMap_end_eq_smul_id, LinearMap.toMatrix_id]\n#align linear_map.to_matrix_algebra_map LinearMap.toMatrix_algebraMap\n-/\n\n",
 "toMatrixAlgEquiv_transpose_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print LinearMap.toMatrixAlgEquiv_transpose_apply' /-\ntheorem LinearMap.toMatrixAlgEquiv_transpose_apply' (f : «expr →ₗ[ ] » M₁ R M₁) (j : n) :\n    (matrix.transpose (LinearMap.toMatrixAlgEquiv v₁ f)) j = v₁.repr (f (v₁ j)) :=\n  LinearMap.toMatrixAlgEquiv_transpose_apply v₁ f j\n#align linear_map.to_matrix_alg_equiv_transpose_apply' LinearMap.toMatrixAlgEquiv_transpose_apply'\n-/\n\n",
 "toMatrixAlgEquiv_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print LinearMap.toMatrixAlgEquiv_transpose_apply /-\ntheorem LinearMap.toMatrixAlgEquiv_transpose_apply (f : «expr →ₗ[ ] » M₁ R M₁) (j : n) :\n    (matrix.transpose (LinearMap.toMatrixAlgEquiv v₁ f)) j = v₁.repr (f (v₁ j)) :=\n  funext fun i => f.to_matrix_apply _ _ i j\n#align linear_map.to_matrix_alg_equiv_transpose_apply LinearMap.toMatrixAlgEquiv_transpose_apply\n-/\n\n",
 "toMatrixAlgEquiv_toLinAlgEquiv":
 "#print LinearMap.toMatrixAlgEquiv_toLinAlgEquiv /-\n@[simp]\ntheorem LinearMap.toMatrixAlgEquiv_toLinAlgEquiv (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv v₁ (Matrix.toLinAlgEquiv v₁ M) = M := by\n  rw [← Matrix.toLinAlgEquiv_symm, AlgEquiv.symm_apply_apply]\n#align linear_map.to_matrix_alg_equiv_to_lin_alg_equiv LinearMap.toMatrixAlgEquiv_toLinAlgEquiv\n-/\n\n",
 "toMatrixAlgEquiv_symm":
 "#print LinearMap.toMatrixAlgEquiv_symm /-\n@[simp]\ntheorem LinearMap.toMatrixAlgEquiv_symm : (LinearMap.toMatrixAlgEquiv v₁).symm = Matrix.toLinAlgEquiv v₁ :=\n  rfl\n#align linear_map.to_matrix_alg_equiv_symm LinearMap.toMatrixAlgEquiv_symm\n-/\n\n",
 "toMatrixAlgEquiv_reindexRange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrixAlgEquiv_reindexRange /-\ntheorem LinearMap.toMatrixAlgEquiv_reindexRange [DecidableEq M₁] (f : «expr →ₗ[ ] » M₁ R M₁) (k i : n) :\n    LinearMap.toMatrixAlgEquiv v₁.reindex_range f ⟨v₁ k, mem_range_self k⟩ ⟨v₁ i, mem_range_self i⟩ =\n      LinearMap.toMatrixAlgEquiv v₁ f k i :=\n  by simp_rw [LinearMap.toMatrixAlgEquiv_apply, Basis.reindexRange_self, Basis.reindexRange_repr]\n#align linear_map.to_matrix_alg_equiv_reindex_range LinearMap.toMatrixAlgEquiv_reindexRange\n-/\n\n",
 "toMatrixAlgEquiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrixAlgEquiv_mul /-\ntheorem LinearMap.toMatrixAlgEquiv_mul (f g : «expr →ₗ[ ] » M₁ R M₁) :\n    LinearMap.toMatrixAlgEquiv v₁ (f * g) =\n      matrix.mul (LinearMap.toMatrixAlgEquiv v₁ f) (LinearMap.toMatrixAlgEquiv v₁ g) :=\n  by rw [show @has_mul.mul («expr →ₗ[ ] » M₁ R M₁) _ = LinearMap.comp from rfl, LinearMap.toMatrixAlgEquiv_comp v₁ f g]\n#align linear_map.to_matrix_alg_equiv_mul LinearMap.toMatrixAlgEquiv_mul\n-/\n\n",
 "toMatrixAlgEquiv_id":
 "#print LinearMap.toMatrixAlgEquiv_id /-\ntheorem LinearMap.toMatrixAlgEquiv_id : LinearMap.toMatrixAlgEquiv v₁ id = 1 := by\n  simp_rw [LinearMap.toMatrixAlgEquiv, alg_equiv.of_linear_equiv_apply, LinearMap.toMatrix_id]\n#align linear_map.to_matrix_alg_equiv_id LinearMap.toMatrixAlgEquiv_id\n-/\n\n",
 "toMatrixAlgEquiv_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrixAlgEquiv_comp /-\ntheorem LinearMap.toMatrixAlgEquiv_comp (f g : «expr →ₗ[ ] » M₁ R M₁) :\n    LinearMap.toMatrixAlgEquiv v₁ (f.comp g) =\n      matrix.mul (LinearMap.toMatrixAlgEquiv v₁ f) (LinearMap.toMatrixAlgEquiv v₁ g) :=\n  by simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_comp v₁ v₁ v₁ f g]\n#align linear_map.to_matrix_alg_equiv_comp LinearMap.toMatrixAlgEquiv_comp\n-/\n\n",
 "toMatrixAlgEquiv_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrixAlgEquiv_apply' /-\ntheorem LinearMap.toMatrixAlgEquiv_apply' (f : «expr →ₗ[ ] » M₁ R M₁) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v₁ f i j = v₁.repr (f (v₁ j)) i :=\n  LinearMap.toMatrixAlgEquiv_apply v₁ f i j\n#align linear_map.to_matrix_alg_equiv_apply' LinearMap.toMatrixAlgEquiv_apply'\n-/\n\n",
 "toMatrixAlgEquiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrixAlgEquiv_apply /-\ntheorem LinearMap.toMatrixAlgEquiv_apply (f : «expr →ₗ[ ] » M₁ R M₁) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v₁ f i j = v₁.repr (f (v₁ j)) i := by\n  simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_apply]\n#align linear_map.to_matrix_alg_equiv_apply LinearMap.toMatrixAlgEquiv_apply\n-/\n\n",
 "toMatrixAlgEquiv'_toLinAlgEquiv'":
 "#print LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv' /-\n@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv' (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv' (Matrix.toLinAlgEquiv' M) = M :=\n  LinearMap.toMatrixAlgEquiv'.apply_symm_apply M\n#align linear_map.to_matrix_alg_equiv'_to_lin_alg_equiv' LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv'\n-/\n\n",
 "toMatrixAlgEquiv'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n#print LinearMap.toMatrixAlgEquiv'_symm /-\n@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_symm :\n    (LinearMap.toMatrixAlgEquiv'.symm : «expr ≃ₐ[ ] » (Matrix n n R) R _) = Matrix.toLinAlgEquiv' :=\n  rfl\n#align linear_map.to_matrix_alg_equiv'_symm LinearMap.toMatrixAlgEquiv'_symm\n-/\n\n",
 "toMatrixAlgEquiv'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrixAlgEquiv'_mul /-\ntheorem LinearMap.toMatrixAlgEquiv'_mul (f g : «expr →ₗ[ ] » (n → R) R (n → R)) :\n    (f * g).to_matrix_alg_equiv' = matrix.mul f.to_matrix_alg_equiv' g.to_matrix_alg_equiv' :=\n  LinearMap.toMatrixAlgEquiv'_comp f g\n#align linear_map.to_matrix_alg_equiv'_mul LinearMap.toMatrixAlgEquiv'_mul\n-/\n\n",
 "toMatrixAlgEquiv'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrixAlgEquiv'_id /-\n@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_id :\n    LinearMap.toMatrixAlgEquiv' (LinearMap.id : «expr →ₗ[ ] » (n → R) R (n → R)) = 1 :=\n  LinearMap.toMatrix'_id\n#align linear_map.to_matrix_alg_equiv'_id LinearMap.toMatrixAlgEquiv'_id\n-/\n\n",
 "toMatrixAlgEquiv'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrixAlgEquiv'_comp /-\ntheorem LinearMap.toMatrixAlgEquiv'_comp (f g : «expr →ₗ[ ] » (n → R) R (n → R)) :\n    (f.comp g).to_matrix_alg_equiv' = matrix.mul f.to_matrix_alg_equiv' g.to_matrix_alg_equiv' :=\n  LinearMap.toMatrix'_comp _ _\n#align linear_map.to_matrix_alg_equiv'_comp LinearMap.toMatrixAlgEquiv'_comp\n-/\n\n",
 "toMatrixAlgEquiv'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrixAlgEquiv'_apply /-\n@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_apply (f : «expr →ₗ[ ] » (n → R) R (n → R)) (i j) :\n    LinearMap.toMatrixAlgEquiv' f i j = f (fun j' => if j' = j then 1 else 0) i := by simp [LinearMap.toMatrixAlgEquiv']\n#align linear_map.to_matrix_alg_equiv'_apply LinearMap.toMatrixAlgEquiv'_apply\n-/\n\n",
 "toMatrix'_toLin'":
 "#print LinearMap.toMatrix'_toLin' /-\n@[simp]\ntheorem LinearMap.toMatrix'_toLin' (M : Matrix m n R) : LinearMap.toMatrix' (Matrix.toLin' M) = M :=\n  LinearMap.toMatrix'.apply_symm_apply M\n#align linear_map.to_matrix'_to_lin' LinearMap.toMatrix'_toLin'\n-/\n\n",
 "toMatrix'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print LinearMap.toMatrix'_symm /-\n@[simp]\ntheorem LinearMap.toMatrix'_symm : (LinearMap.toMatrix'.symm : «expr ≃ₗ[ ] » (Matrix m n R) R _) = Matrix.toLin' :=\n  rfl\n#align linear_map.to_matrix'_symm LinearMap.toMatrix'_symm\n-/\n\n",
 "toMatrix'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrix'_mul /-\ntheorem LinearMap.toMatrix'_mul [Fintype m] [DecidableEq m] (f g : «expr →ₗ[ ] » (m → R) R (m → R)) :\n    (f * g).to_matrix' = matrix.mul f.to_matrix' g.to_matrix' :=\n  LinearMap.toMatrix'_comp f g\n#align linear_map.to_matrix'_mul LinearMap.toMatrix'_mul\n-/\n\n",
 "toMatrix'_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix'_id /-\n@[simp]\ntheorem LinearMap.toMatrix'_id : LinearMap.toMatrix' (LinearMap.id : «expr →ₗ[ ] » (n → R) R (n → R)) = 1 :=\n  by\n  ext\n  rw [Matrix.one_apply, LinearMap.toMatrix'_apply, id_apply]\n#align linear_map.to_matrix'_id LinearMap.toMatrix'_id\n-/\n\n",
 "toMatrix'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print LinearMap.toMatrix'_comp /-\ntheorem LinearMap.toMatrix'_comp [Fintype l] [DecidableEq l] (f : «expr →ₗ[ ] » (n → R) R (m → R))\n    (g : «expr →ₗ[ ] » (l → R) R (n → R)) : (f.comp g).to_matrix' = matrix.mul f.to_matrix' g.to_matrix' :=\n  by\n  suffices f.comp g = (matrix.mul f.to_matrix' g.to_matrix').to_lin' by rw [this, LinearMap.toMatrix'_toLin']\n  rw [Matrix.toLin'_mul, Matrix.toLin'_toMatrix', Matrix.toLin'_toMatrix']\n#align linear_map.to_matrix'_comp LinearMap.toMatrix'_comp\n-/\n\n",
 "toMatrix'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.toMatrix'_apply /-\n@[simp]\ntheorem LinearMap.toMatrix'_apply (f : «expr →ₗ[ ] » (n → R) R (m → R)) (i j) :\n    LinearMap.toMatrix' f i j = f (fun j' => if j' = j then 1 else 0) i :=\n  by\n  simp only [LinearMap.toMatrix', LinearEquiv.coe_mk, of_apply]\n  congr\n  ext j'\n  split_ifs with h\n  · rw [h, std_basis_same]\n  apply std_basis_ne _ _ _ _ h\n#align linear_map.to_matrix'_apply LinearMap.toMatrix'_apply\n-/\n\n",
 "toMatrix'_algebraMap":
 "#print LinearMap.toMatrix'_algebraMap /-\n@[simp]\ntheorem LinearMap.toMatrix'_algebraMap (x : R) :\n    LinearMap.toMatrix' (algebraMap R (Module.End R (n → R)) x) = scalar n x := by\n  simp [Module.algebraMap_end_eq_smul_id]\n#align linear_map.to_matrix'_algebra_map LinearMap.toMatrix'_algebraMap\n-/\n\n",
 "toLinearMapRight'_one":
 "#print Matrix.toLinearMapRight'_one /-\n@[simp]\ntheorem Matrix.toLinearMapRight'_one : Matrix.toLinearMapRight' (1 : Matrix m m R) = id :=\n  by\n  ext\n  simp [LinearMap.one_apply, std_basis_apply]\n#align matrix.to_linear_map_right'_one Matrix.toLinearMapRight'_one\n-/\n\n",
 "toLinearMapRight'_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLinearMapRight'_mul_apply /-\ntheorem Matrix.toLinearMapRight'_mul_apply [Fintype l] [DecidableEq l] (M : Matrix l m R) (N : Matrix m n R) (x) :\n    Matrix.toLinearMapRight' (matrix.mul M N) x = Matrix.toLinearMapRight' N (Matrix.toLinearMapRight' M x) :=\n  (vecMul_vecMul _ M N).symm\n#align matrix.to_linear_map_right'_mul_apply Matrix.toLinearMapRight'_mul_apply\n-/\n\n",
 "toLinearMapRight'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLinearMapRight'_mul /-\n@[simp]\ntheorem Matrix.toLinearMapRight'_mul [Fintype l] [DecidableEq l] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.toLinearMapRight' (matrix.mul M N) = (Matrix.toLinearMapRight' N).comp (Matrix.toLinearMapRight' M) :=\n  LinearMap.ext fun x => (vecMul_vecMul _ M N).symm\n#align matrix.to_linear_map_right'_mul Matrix.toLinearMapRight'_mul\n-/\n\n",
 "toLinearMapRight'_apply":
 "#print Matrix.toLinearMapRight'_apply /-\n@[simp]\ntheorem Matrix.toLinearMapRight'_apply (M : Matrix m n R) (v : m → R) : Matrix.toLinearMapRight' M v = M.vec_mul v :=\n  rfl\n#align matrix.to_linear_map_right'_apply Matrix.toLinearMapRight'_apply\n-/\n\n",
 "toLin_toMatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Matrix.toLin_toMatrix /-\n@[simp]\ntheorem Matrix.toLin_toMatrix (f : «expr →ₗ[ ] » M₁ R M₂) : Matrix.toLin v₁ v₂ (LinearMap.toMatrix v₁ v₂ f) = f := by\n  rw [← Matrix.toLin_symm, LinearEquiv.apply_symm_apply]\n#align matrix.to_lin_to_matrix Matrix.toLin_toMatrix\n-/\n\n",
 "toLin_symm":
 "#print Matrix.toLin_symm /-\n@[simp]\ntheorem Matrix.toLin_symm : (Matrix.toLin v₁ v₂).symm = LinearMap.toMatrix v₁ v₂ :=\n  rfl\n#align matrix.to_lin_symm Matrix.toLin_symm\n-/\n\n",
 "toLin_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Matrix.toLin_self /-\n@[simp]\ntheorem Matrix.toLin_self (M : Matrix m n R) (i : n) :\n    Matrix.toLin v₁ v₂ M (v₁ i) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M j i) (v₂ j)) :=\n  by\n  rw [Matrix.toLin_apply, Finset.sum_congr rfl fun j hj => _]\n  rw [Basis.repr_self, Matrix.mulVec, dot_product, Finset.sum_eq_single i, Finsupp.single_eq_same, mul_one]\n  · intro i' _ i'_ne\n    rw [Finsupp.single_eq_of_ne i'_ne.symm, MulZeroClass.mul_zero]\n  · intros\n    have := Finset.mem_univ i\n    contradiction\n#align matrix.to_lin_self Matrix.toLin_self\n-/\n\n",
 "toLin_one":
 "#print Matrix.toLin_one /-\n@[simp]\ntheorem Matrix.toLin_one : Matrix.toLin v₁ v₁ 1 = id := by rw [← LinearMap.toMatrix_id v₁, Matrix.toLin_toMatrix]\n#align matrix.to_lin_one Matrix.toLin_one\n-/\n\n",
 "toLin_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLin_mul_apply /-\n/-- Shortcut lemma for `matrix.to_lin_mul` and `linear_map.comp_apply`. -/\ntheorem Matrix.toLin_mul_apply [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) (x) :\n    Matrix.toLin v₁ v₃ (matrix.mul A B) x = (Matrix.toLin v₂ v₃ A) (Matrix.toLin v₁ v₂ B x) := by\n  rw [Matrix.toLin_mul v₁ v₂, LinearMap.comp_apply]\n#align matrix.to_lin_mul_apply Matrix.toLin_mul_apply\n-/\n\n",
 "toLin_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLin_mul /-\ntheorem Matrix.toLin_mul [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) :\n    Matrix.toLin v₁ v₃ (matrix.mul A B) = (Matrix.toLin v₂ v₃ A).comp (Matrix.toLin v₁ v₂ B) :=\n  by\n  apply (LinearMap.toMatrix v₁ v₃).injective\n  haveI : DecidableEq l := fun _ _ => classical.prop_decidable _\n  rw [LinearMap.toMatrix_comp v₁ v₂ v₃]\n  repeat' rw [LinearMap.toMatrix_toLin]\n#align matrix.to_lin_mul Matrix.toLin_mul\n-/\n\n",
 "toLin_finTwoProd_apply":
 "#print Matrix.toLin_finTwoProd_apply /-\n@[simp]\ntheorem Matrix.toLin_finTwoProd_apply (a b c d : R) (x : R × R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] x =\n      (a * x.fst + b * x.snd, c * x.fst + d * x.snd) :=\n  by simp [Matrix.toLin_apply, Matrix.mulVec, Matrix.dotProduct]\n#align matrix.to_lin_fin_two_prod_apply Matrix.toLin_finTwoProd_apply\n-/\n\n",
 "toLin_finTwoProd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Matrix.toLin_finTwoProd /-\ntheorem Matrix.toLin_finTwoProd (a b c d : R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] =\n      («expr • » a (LinearMap.fst R R R) + «expr • » b (LinearMap.snd R R R)).prod\n        («expr • » c (LinearMap.fst R R R) + «expr • » d (LinearMap.snd R R R)) :=\n  LinearMap.ext <| Matrix.toLin_finTwoProd_apply _ _ _ _\n#align matrix.to_lin_fin_two_prod Matrix.toLin_finTwoProd\n-/\n\n",
 "toLin_eq_toLin'":
 "#print Matrix.toLin_eq_toLin' /-\n/-- `matrix.to_lin'` is a particular case of `matrix.to_lin`, for the standard basis\n`pi.basis_fun R n`. -/\ntheorem Matrix.toLin_eq_toLin' : Matrix.toLin (Pi.basisFun R n) (Pi.basisFun R m) = Matrix.toLin' :=\n  rfl\n#align matrix.to_lin_eq_to_lin' Matrix.toLin_eq_toLin'\n-/\n\n",
 "toLin_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Matrix.toLin_apply /-\ntheorem Matrix.toLin_apply (M : Matrix m n R) (v : M₁) :\n    Matrix.toLin v₁ v₂ M v =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M.mul_vec (v₁.repr v) j) (v₂ j)) :=\n  show v₂.equiv_fun.symm (Matrix.toLin' M (v₁.repr v)) = _ by rw [Matrix.toLin'_apply, v₂.equiv_fun_symm_apply]\n#align matrix.to_lin_apply Matrix.toLin_apply\n-/\n\n",
 "toLinAlgEquiv_toMatrixAlgEquiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Matrix.toLinAlgEquiv_toMatrixAlgEquiv /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv_toMatrixAlgEquiv (f : «expr →ₗ[ ] » M₁ R M₁) :\n    Matrix.toLinAlgEquiv v₁ (LinearMap.toMatrixAlgEquiv v₁ f) = f := by\n  rw [← Matrix.toLinAlgEquiv_symm, AlgEquiv.apply_symm_apply]\n#align matrix.to_lin_alg_equiv_to_matrix_alg_equiv Matrix.toLinAlgEquiv_toMatrixAlgEquiv\n-/\n\n",
 "toLinAlgEquiv_symm":
 "#print Matrix.toLinAlgEquiv_symm /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv_symm : (Matrix.toLinAlgEquiv v₁).symm = LinearMap.toMatrixAlgEquiv v₁ :=\n  rfl\n#align matrix.to_lin_alg_equiv_symm Matrix.toLinAlgEquiv_symm\n-/\n\n",
 "toLinAlgEquiv_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Matrix.toLinAlgEquiv_self /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv_self (M : Matrix n n R) (i : n) :\n    Matrix.toLinAlgEquiv v₁ M (v₁ i) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M j i) (v₁ j)) :=\n  Matrix.toLin_self _ _ _ _\n#align matrix.to_lin_alg_equiv_self Matrix.toLinAlgEquiv_self\n-/\n\n",
 "toLinAlgEquiv_one":
 "#print Matrix.toLinAlgEquiv_one /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv_one : Matrix.toLinAlgEquiv v₁ 1 = id := by\n  rw [← LinearMap.toMatrixAlgEquiv_id v₁, Matrix.toLinAlgEquiv_toMatrixAlgEquiv]\n#align matrix.to_lin_alg_equiv_one Matrix.toLinAlgEquiv_one\n-/\n\n",
 "toLinAlgEquiv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLinAlgEquiv_mul /-\ntheorem Matrix.toLinAlgEquiv_mul (A B : Matrix n n R) :\n    Matrix.toLinAlgEquiv v₁ (matrix.mul A B) = (Matrix.toLinAlgEquiv v₁ A).comp (Matrix.toLinAlgEquiv v₁ B) := by\n  convert Matrix.toLin_mul v₁ v₁ v₁ A B\n#align matrix.to_lin_alg_equiv_mul Matrix.toLinAlgEquiv_mul\n-/\n\n",
 "toLinAlgEquiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Matrix.toLinAlgEquiv_apply /-\ntheorem Matrix.toLinAlgEquiv_apply (M : Matrix n n R) (v : M₁) :\n    Matrix.toLinAlgEquiv v₁ M v =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (M.mul_vec (v₁.repr v) j) (v₁ j)) :=\n  show v₁.equiv_fun.symm (Matrix.toLinAlgEquiv' M (v₁.repr v)) = _ by\n    rw [Matrix.toLinAlgEquiv'_apply, v₁.equiv_fun_symm_apply]\n#align matrix.to_lin_alg_equiv_apply Matrix.toLinAlgEquiv_apply\n-/\n\n",
 "toLinAlgEquiv'_toMatrixAlgEquiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Matrix.toLinAlgEquiv'_toMatrixAlgEquiv' /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv'_toMatrixAlgEquiv' (f : «expr →ₗ[ ] » (n → R) R (n → R)) :\n    Matrix.toLinAlgEquiv' (LinearMap.toMatrixAlgEquiv' f) = f :=\n  Matrix.toLinAlgEquiv'.apply_symm_apply f\n#align matrix.to_lin_alg_equiv'_to_matrix_alg_equiv' Matrix.toLinAlgEquiv'_toMatrixAlgEquiv'\n-/\n\n",
 "toLinAlgEquiv'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Matrix.toLinAlgEquiv'_symm /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv'_symm :\n    (Matrix.toLinAlgEquiv'.symm : «expr ≃ₐ[ ] » («expr →ₗ[ ] » (n → R) R (n → R)) R _) = LinearMap.toMatrixAlgEquiv' :=\n  rfl\n#align matrix.to_lin_alg_equiv'_symm Matrix.toLinAlgEquiv'_symm\n-/\n\n",
 "toLinAlgEquiv'_one":
 "#print Matrix.toLinAlgEquiv'_one /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv'_one : Matrix.toLinAlgEquiv' (1 : Matrix n n R) = id :=\n  Matrix.toLin'_one\n#align matrix.to_lin_alg_equiv'_one Matrix.toLinAlgEquiv'_one\n-/\n\n",
 "toLinAlgEquiv'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLinAlgEquiv'_mul /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv'_mul (M N : Matrix n n R) :\n    Matrix.toLinAlgEquiv' (matrix.mul M N) = (Matrix.toLinAlgEquiv' M).comp (Matrix.toLinAlgEquiv' N) :=\n  Matrix.toLin'_mul _ _\n#align matrix.to_lin_alg_equiv'_mul Matrix.toLinAlgEquiv'_mul\n-/\n\n",
 "toLinAlgEquiv'_apply":
 "#print Matrix.toLinAlgEquiv'_apply /-\n@[simp]\ntheorem Matrix.toLinAlgEquiv'_apply (M : Matrix n n R) (v : n → R) : Matrix.toLinAlgEquiv' M v = M.mul_vec v :=\n  rfl\n#align matrix.to_lin_alg_equiv'_apply Matrix.toLinAlgEquiv'_apply\n-/\n\n",
 "toLin'_toMatrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Matrix.toLin'_toMatrix' /-\n@[simp]\ntheorem Matrix.toLin'_toMatrix' (f : «expr →ₗ[ ] » (n → R) R (m → R)) : Matrix.toLin' (LinearMap.toMatrix' f) = f :=\n  Matrix.toLin'.apply_symm_apply f\n#align matrix.to_lin'_to_matrix' Matrix.toLin'_toMatrix'\n-/\n\n",
 "toLin'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Matrix.toLin'_symm /-\n@[simp]\ntheorem Matrix.toLin'_symm :\n    (Matrix.toLin'.symm : «expr ≃ₗ[ ] » («expr →ₗ[ ] » (n → R) R (m → R)) R _) = LinearMap.toMatrix' :=\n  rfl\n#align matrix.to_lin'_symm Matrix.toLin'_symm\n-/\n\n",
 "toLin'_submatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n#print Matrix.toLin'_submatrix /-\n@[simp]\ntheorem Matrix.toLin'_submatrix [Fintype l] [DecidableEq l] (f₁ : m → k) (e₂ : «expr ≃ » n l) (M : Matrix k l R) :\n    (M.submatrix f₁ e₂).to_lin' = «expr ∘ₗ » (funLeft R R f₁) («expr ∘ₗ » M.to_lin' (funLeft _ _ e₂.symm)) :=\n  Matrix.mulVecLin_submatrix _ _ _\n#align matrix.to_lin'_submatrix Matrix.toLin'_submatrix\n-/\n\n",
 "toLin'_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n#print Matrix.toLin'_reindex /-\n/-- A variant of `matrix.to_lin'_submatrix` that keeps around `linear_equiv`s. -/\ntheorem Matrix.toLin'_reindex [Fintype l] [DecidableEq l] (e₁ : «expr ≃ » k m) (e₂ : «expr ≃ » l n) (M : Matrix k l R) :\n    (reindex e₁ e₂ M).to_lin' =\n      «expr ∘ₗ » (↑(LinearEquiv.funCongrLeft R R e₁.symm)) («expr ∘ₗ » M.to_lin' ↑(LinearEquiv.funCongrLeft R R e₂)) :=\n  Matrix.mulVecLin_reindex _ _ _\n#align matrix.to_lin'_reindex Matrix.toLin'_reindex\n-/\n\n",
 "toLin'_one":
 "#print Matrix.toLin'_one /-\n@[simp]\ntheorem Matrix.toLin'_one : Matrix.toLin' (1 : Matrix n n R) = id :=\n  Matrix.mulVecLin_one\n#align matrix.to_lin'_one Matrix.toLin'_one\n-/\n\n",
 "toLin'_mul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLin'_mul_apply /-\n/-- Shortcut lemma for `matrix.to_lin'_mul` and `linear_map.comp_apply` -/\ntheorem Matrix.toLin'_mul_apply [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R) (x) :\n    Matrix.toLin' (matrix.mul M N) x = Matrix.toLin' M (Matrix.toLin' N x) := by\n  rw [Matrix.toLin'_mul, LinearMap.comp_apply]\n#align matrix.to_lin'_mul_apply Matrix.toLin'_mul_apply\n-/\n\n",
 "toLin'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.toLin'_mul /-\n@[simp]\ntheorem Matrix.toLin'_mul [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.toLin' (matrix.mul M N) = (Matrix.toLin' M).comp (Matrix.toLin' N) :=\n  Matrix.mulVecLin_mul _ _\n#align matrix.to_lin'_mul Matrix.toLin'_mul\n-/\n\n",
 "toLin'_apply'":
 "#print Matrix.toLin'_apply' /-\ntheorem Matrix.toLin'_apply' (M : Matrix m n R) : Matrix.toLin' M = M.mul_vec_lin :=\n  rfl\n#align matrix.to_lin'_apply' Matrix.toLin'_apply'\n-/\n\n",
 "toLin'_apply":
 "#print Matrix.toLin'_apply /-\n@[simp]\ntheorem Matrix.toLin'_apply (M : Matrix m n R) (v : n → R) : Matrix.toLin' M v = M.mul_vec v :=\n  rfl\n#align matrix.to_lin'_apply Matrix.toLin'_apply\n-/\n\n",
 "smul_left_mul_matrix_algebra_map_ne":
 "theorem smul_left_mul_matrix_algebra_map_ne (x : S) (i j) {k k'} (h : k ≠ k') :\n    leftMulMatrix (b.smul c) (algebraMap _ _ x) (i, k) (j, k') = 0 := by\n  rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_ne _ _ _ h]\n#align smul_left_mul_matrix_algebra_map_ne smul_left_mul_matrix_algebra_map_ne\n\n",
 "smul_left_mul_matrix_algebra_map_eq":
 "theorem smul_left_mul_matrix_algebra_map_eq (x : S) (i j k) :\n    leftMulMatrix (b.smul c) (algebraMap _ _ x) (i, k) (j, k) = leftMulMatrix b x i j := by\n  rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_eq]\n#align smul_left_mul_matrix_algebra_map_eq smul_left_mul_matrix_algebra_map_eq\n\n",
 "smul_left_mul_matrix_algebra_map":
 "theorem smul_left_mul_matrix_algebra_map (x : S) :\n    leftMulMatrix (b.smul c) (algebraMap _ _ x) = blockDiagonal fun k => leftMulMatrix b x :=\n  by\n  ext (⟨i, k⟩⟨j, k'⟩)\n  rw [smul_left_mul_matrix, AlgHom.commutes, block_diagonal_apply, algebra_map_matrix_apply]\n  split_ifs with h <;> simp [h]\n#align smul_left_mul_matrix_algebra_map smul_left_mul_matrix_algebra_map\n\n",
 "smul_left_mul_matrix":
 "theorem smul_left_mul_matrix (x) (ik jk) :\n    leftMulMatrix (b.smul c) x ik jk = leftMulMatrix b (leftMulMatrix c x ik.2 jk.2) ik.1 jk.1 := by\n  simp only [left_mul_matrix_apply, LinearMap.toMatrix_apply, mul_comm, Basis.smul_apply, Basis.smul_repr,\n    Finsupp.smul_apply, id.smul_eq_mul, LinearEquiv.map_smul, mul_smul_comm, coe_lmul_eq_mul, LinearMap.mul_apply']\n#align smul_left_mul_matrix smul_left_mul_matrix\n\n",
 "range_toLin'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print Matrix.range_toLin' /-\ntheorem Matrix.range_toLin' (M : Matrix m n R) : M.to_lin'.range = span R (range (matrix.transpose M)) :=\n  Matrix.range_mulVecLin _\n#align matrix.range_to_lin' Matrix.range_toLin'\n-/\n\n",
 "range_mulVecLin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print Matrix.range_mulVecLin /-\ntheorem Matrix.range_mulVecLin (M : Matrix m n R) : M.mul_vec_lin.range = span R (range (matrix.transpose M)) :=\n  by\n  letI := Classical.decEq n\n  simp_rw [range_eq_map, ← supr_range_std_basis, Submodule.map_supᵢ, range_eq_map, ← Ideal.span_singleton_one,\n    Ideal.span, Submodule.map_span, image_image, image_singleton, Matrix.mulVecLin_apply, M.mul_vec_std_basis_apply,\n    supr_span, range_eq_Union]\n#align matrix.range_mul_vec_lin Matrix.range_mulVecLin\n-/\n\n",
 "mulVec_stdBasis_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print Matrix.mulVec_stdBasis_apply /-\n@[simp]\ntheorem Matrix.mulVec_stdBasis_apply [DecidableEq n] (M : Matrix m n R) (j) :\n    M.mul_vec (stdBasis R (fun _ => R) j 1) = (matrix.transpose M) j :=\n  funext fun i => Matrix.mulVec_stdBasis M i j\n#align matrix.mul_vec_std_basis_apply Matrix.mulVec_stdBasis_apply\n-/\n\n",
 "mulVec_stdBasis":
 "#print Matrix.mulVec_stdBasis /-\ntheorem Matrix.mulVec_stdBasis [DecidableEq n] (M : Matrix m n R) (i j) :\n    M.mul_vec (stdBasis R (fun _ => R) j 1) i = M i j :=\n  (congr_fun (Matrix.mulVec_single _ _ (1 : R)) i).trans <| mul_one _\n#align matrix.mul_vec_std_basis Matrix.mulVec_stdBasis\n-/\n\n",
 "mulVecLin_zero":
 "#print Matrix.mulVecLin_zero /-\n@[simp]\ntheorem Matrix.mulVecLin_zero [Fintype n] : Matrix.mulVecLin (0 : Matrix m n R) = 0 :=\n  LinearMap.ext zero_mulVec\n#align matrix.mul_vec_lin_zero Matrix.mulVecLin_zero\n-/\n\n",
 "mulVecLin_submatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n#print Matrix.mulVecLin_submatrix /-\ntheorem Matrix.mulVecLin_submatrix [Fintype n] [Fintype l] (f₁ : m → k) (e₂ : «expr ≃ » n l) (M : Matrix k l R) :\n    (M.submatrix f₁ e₂).mul_vec_lin = «expr ∘ₗ » (funLeft R R f₁) («expr ∘ₗ » M.mul_vec_lin (funLeft _ _ e₂.symm)) :=\n  LinearMap.ext fun x => submatrix_mulVec_equiv _ _ _ _\n#align matrix.mul_vec_lin_submatrix Matrix.mulVecLin_submatrix\n-/\n\n",
 "mulVecLin_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n#print Matrix.mulVecLin_reindex /-\n/-- A variant of `matrix.mul_vec_lin_submatrix` that keeps around `linear_equiv`s. -/\ntheorem Matrix.mulVecLin_reindex [Fintype n] [Fintype l] (e₁ : «expr ≃ » k m) (e₂ : «expr ≃ » l n) (M : Matrix k l R) :\n    (reindex e₁ e₂ M).mul_vec_lin =\n      «expr ∘ₗ » (↑(LinearEquiv.funCongrLeft R R e₁.symm))\n        («expr ∘ₗ » M.mul_vec_lin ↑(LinearEquiv.funCongrLeft R R e₂)) :=\n  Matrix.mulVecLin_submatrix _ _ _\n#align matrix.mul_vec_lin_reindex Matrix.mulVecLin_reindex\n-/\n\n",
 "mulVecLin_one":
 "#print Matrix.mulVecLin_one /-\n@[simp]\ntheorem Matrix.mulVecLin_one [DecidableEq n] : Matrix.mulVecLin (1 : Matrix n n R) = id :=\n  by\n  ext\n  simp [LinearMap.one_apply, std_basis_apply]\n#align matrix.mul_vec_lin_one Matrix.mulVecLin_one\n-/\n\n",
 "mulVecLin_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Matrix.mulVecLin_mul /-\n@[simp]\ntheorem Matrix.mulVecLin_mul [Fintype m] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.mulVecLin (matrix.mul M N) = (Matrix.mulVecLin M).comp (Matrix.mulVecLin N) :=\n  LinearMap.ext fun x => (mulVec_mulVec _ _ _).symm\n#align matrix.mul_vec_lin_mul Matrix.mulVecLin_mul\n-/\n\n",
 "mulVecLin_apply":
 "#print Matrix.mulVecLin_apply /-\n@[simp]\ntheorem Matrix.mulVecLin_apply [Fintype n] (M : Matrix m n R) (v : n → R) : M.mul_vec_lin v = M.mul_vec v :=\n  rfl\n#align matrix.mul_vec_lin_apply Matrix.mulVecLin_apply\n-/\n\n",
 "mulVecLin_add":
 "#print Matrix.mulVecLin_add /-\n@[simp]\ntheorem Matrix.mulVecLin_add [Fintype n] (M N : Matrix m n R) : (M + N).mul_vec_lin = M.mul_vec_lin + N.mul_vec_lin :=\n  LinearMap.ext fun _ => add_mulVec _ _ _\n#align matrix.mul_vec_lin_add Matrix.mulVecLin_add\n-/\n\n",
 "left_mul_matrix_mul_vec_repr":
 "theorem left_mul_matrix_mul_vec_repr (x y : S) : (leftMulMatrix b x).mul_vec (b.repr y) = b.repr (x * y) :=\n  (LinearMap.mulLeft R x).to_matrix_mul_vec_repr b b y\n#align left_mul_matrix_mul_vec_repr left_mul_matrix_mul_vec_repr\n\n",
 "left_mul_matrix_injective":
 "theorem left_mul_matrix_injective : function.injective (leftMulMatrix b) := fun x x' h =>\n  calc\n    x = Algebra.lmul R S x 1 := (mul_one x).symm\n    _ = Algebra.lmul R S x' 1 := by rw [(LinearMap.toMatrix b b).injective h]\n    _ = x' := mul_one x'\n    \n#align left_mul_matrix_injective left_mul_matrix_injective\n\n",
 "left_mul_matrix_eq_repr_mul":
 "theorem left_mul_matrix_eq_repr_mul (x : S) (i j) : leftMulMatrix b x i j = b.repr (x * b j) i :=\n  by-- This is defeq to just `to_matrix_lmul' b x i j`,\n  -- but the unfolding goes a lot faster with this explicit `rw`.\n  rw [left_mul_matrix_apply, to_matrix_lmul' b x i j]\n#align left_mul_matrix_eq_repr_mul left_mul_matrix_eq_repr_mul\n\n",
 "left_mul_matrix_apply":
 "theorem left_mul_matrix_apply (x : S) : leftMulMatrix b x = LinearMap.toMatrix b b (lmul R S x) :=\n  rfl\n#align left_mul_matrix_apply left_mul_matrix_apply\n\n",
 "ker_toLin'_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Matrix.ker_toLin'_eq_bot_iff /-\ntheorem Matrix.ker_toLin'_eq_bot_iff {M : Matrix n n R} : M.to_lin'.ker = «expr⊥» ↔ ∀ v, M.mul_vec v = 0 → v = 0 :=\n  Matrix.ker_mulVecLin_eq_bot_iff\n#align matrix.ker_to_lin'_eq_bot_iff Matrix.ker_toLin'_eq_bot_iff\n-/\n\n",
 "ker_mulVecLin_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Matrix.ker_mulVecLin_eq_bot_iff /-\ntheorem Matrix.ker_mulVecLin_eq_bot_iff {M : Matrix n n R} :\n    M.mul_vec_lin.ker = «expr⊥» ↔ ∀ v, M.mul_vec v = 0 → v = 0 := by\n  simp only [Submodule.eq_bot_iff, LinearMap.mem_ker, Matrix.mulVecLin_apply]\n#align matrix.ker_mul_vec_lin_eq_bot_iff Matrix.ker_mulVecLin_eq_bot_iff\n-/\n\n"}