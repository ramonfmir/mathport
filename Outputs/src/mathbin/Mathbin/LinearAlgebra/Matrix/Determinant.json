{"map_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem _root_.alg_equiv.map_det [algebra R S] {T : Type z} [CommRing T] [algebra R T] (f : «expr ≃ₐ[ ] » S R T)\n    (M : matrix n n S) : f M.det = matrix.det (f.map_matrix M) :=\n  f.to_alg_hom.map_det _\n#align alg_equiv.map_det alg_equiv.map_det\n\n",
 "det_zero_of_row_eq":
 "/-- If a matrix has a repeated row, the determinant will be zero. -/\ntheorem det_zero_of_row_eq (i_ne_j : i ≠ j) (hij : M i = M j) : M.det = 0 :=\n  (det_row_alternating : alternating_map R (n → R) R n).map_eq_zero_of_eq M hij i_ne_j\n#align det_zero_of_row_eq det_zero_of_row_eq\n\n",
 "det_zero_of_column_eq":
 "/-- If a matrix has a repeated column, the determinant will be zero. -/\ntheorem det_zero_of_column_eq (i_ne_j : i ≠ j) (hij : ∀ k, M k i = M k j) : M.det = 0 :=\n  by\n  rw [← det_transpose, det_zero_of_row_eq i_ne_j]\n  exact funext hij\n#align det_zero_of_column_eq det_zero_of_column_eq\n\n",
 "det_zero":
 "@[simp]\ntheorem det_zero (h : nonempty n) : det (0 : matrix n n R) = 0 :=\n  (det_row_alternating : alternating_map R (n → R) R n).map_zero\n#align det_zero det_zero\n\n",
 "det_update_row_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_update_row_smul' (M : matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (update_row («expr • » s M) j u) = s ^ (fintype.card n - 1) * det (update_row M j u) :=\n  multilinear_map.map_update_smul _ M j s u\n#align det_update_row_smul' det_update_row_smul'\n\n",
 "det_update_row_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_update_row_smul (M : matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (update_row M j <| «expr • » s u) = s * det (update_row M j u) :=\n  (det_row_alternating : alternating_map R (n → R) R n).map_smul M j s u\n#align det_update_row_smul det_update_row_smul\n\n",
 "det_update_row_add_smul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_update_row_add_smul_self (A : matrix n n R) {i j : n} (hij : i ≠ j) (c : R) :\n    det (update_row A i (A i + «expr • » c (A j))) = det A := by\n  simp [det_update_row_add, det_update_row_smul,\n    det_zero_of_row_eq hij (update_row_self.trans (update_row_ne hij.symm).symm)]\n#align det_update_row_add_smul_self det_update_row_add_smul_self\n\n",
 "det_update_row_add_self":
 "theorem det_update_row_add_self (A : matrix n n R) {i j : n} (hij : i ≠ j) : det (update_row A i (A i + A j)) = det A :=\n  by simp [det_update_row_add, det_zero_of_row_eq hij (update_row_self.trans (update_row_ne hij.symm).symm)]\n#align det_update_row_add_self det_update_row_add_self\n\n",
 "det_update_row_add":
 "theorem det_update_row_add (M : matrix n n R) (j : n) (u v : n → R) :\n    det (update_row M j <| u + v) = det (update_row M j u) + det (update_row M j v) :=\n  (det_row_alternating : alternating_map R (n → R) R n).map_add M j u v\n#align det_update_row_add det_update_row_add\n\n",
 "det_update_column_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_update_column_smul' (M : matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (update_column («expr • » s M) j u) = s ^ (fintype.card n - 1) * det (update_column M j u) :=\n  by\n  rw [← det_transpose, ← update_row_transpose, transpose_smul, det_update_row_smul']\n  simp [update_row_transpose, det_transpose]\n#align det_update_column_smul' det_update_column_smul'\n\n",
 "det_update_column_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_update_column_smul (M : matrix n n R) (j : n) (s : R) (u : n → R) :\n    det (update_column M j <| «expr • » s u) = s * det (update_column M j u) :=\n  by\n  rw [← det_transpose, ← update_row_transpose, det_update_row_smul]\n  simp [update_row_transpose, det_transpose]\n#align det_update_column_smul det_update_column_smul\n\n",
 "det_update_column_add_smul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_update_column_add_smul_self (A : matrix n n R) {i j : n} (hij : i ≠ j) (c : R) :\n    det (update_column A i fun k => A k i + «expr • » c (A k j)) = det A :=\n  by\n  rw [← det_transpose, ← update_row_transpose, ← det_transpose A]\n  exact det_update_row_add_smul_self (matrix.transpose A) hij c\n#align det_update_column_add_smul_self det_update_column_add_smul_self\n\n",
 "det_update_column_add_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem det_update_column_add_self (A : matrix n n R) {i j : n} (hij : i ≠ j) :\n    det (update_column A i fun k => A k i + A k j) = det A :=\n  by\n  rw [← det_transpose, ← update_row_transpose, ← det_transpose A]\n  exact det_update_row_add_self (matrix.transpose A) hij\n#align det_update_column_add_self det_update_column_add_self\n\n",
 "det_update_column_add":
 "theorem det_update_column_add (M : matrix n n R) (j : n) (u v : n → R) :\n    det (update_column M j <| u + v) = det (update_column M j u) + det (update_column M j v) :=\n  by\n  rw [← det_transpose, ← update_row_transpose, det_update_row_add]\n  simp [update_row_transpose, det_transpose]\n#align det_update_column_add det_update_column_add\n\n",
 "det_units_conj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_units_conj' (M : «expr ˣ» (matrix m m R)) (N : matrix m m R) :\n    det (matrix.mul (matrix.mul (↑M⁻¹) N) ↑M : matrix m m R) = det N :=\n  det_units_conj M⁻¹ N\n#align det_units_conj' det_units_conj'\n\n",
 "det_units_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_units_conj (M : «expr ˣ» (matrix m m R)) (N : matrix m m R) :\n    det (matrix.mul (matrix.mul (↑M) N) ↑M⁻¹ : matrix m m R) = det N := by\n  rw [det_mul_right_comm, ← mul_eq_mul, ← mul_eq_mul, Units.mul_inv, one_mul]\n#align det_units_conj det_units_conj\n\n",
 "det_unique":
 "/-- If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `unique` implies `decidable_eq` and `fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem det_unique {n : Type _} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) :\n    det A = A default default := by simp [det_apply, univ_unique]\n#align det_unique det_unique\n\n",
 "det_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/-- Transposing a matrix preserves the determinant. -/\n@[simp]\ntheorem det_transpose (M : matrix n n R) : (matrix.transpose M).det = M.det :=\n  by\n  rw [det_apply', det_apply']\n  refine' fintype.sum_bijective _ inv_involutive.bijective _ _ _\n  intro σ\n  rw [sign_inv]\n  congr 1\n  apply fintype.prod_equiv σ\n  intros\n  simp\n#align det_transpose det_transpose\n\n",
 "det_succ_row_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along row 0. -/\ntheorem det_succ_row_zero {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) :\n    det A =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((-1) ^ (j : ℕ) * A 0 j * det (A.submatrix fin.succ j.succ_above)) :=\n  by\n  rw [← det_transpose A, det_succ_column_zero]\n  refine' finset.sum_congr rfl fun i _ => _\n  rw [← det_transpose]\n  simp only [transpose_apply, transpose_submatrix, transpose_transpose]\n#align det_succ_row_zero det_succ_row_zero\n\n",
 "det_succ_row":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along row `i`. -/\ntheorem det_succ_row {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) (i : fin n.succ) :\n    det A =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((-1) ^ (i + j : ℕ) * A i j * det (A.submatrix i.succ_above j.succ_above)) :=\n  by\n  simp_rw [pow_add, mul_assoc, ← mul_sum]\n  have : det A = (-1 : R) ^ (i : ℕ) * i.cycle_range⁻¹.sign * det A := by\n    calc\n      det A = ↑((-1 : «expr ˣ» ℤ) ^ (i : ℕ) * (-1 : «expr ˣ» ℤ) ^ (i : ℕ) : «expr ˣ» ℤ) * det A := by simp\n      _ = (-1 : R) ^ (i : ℕ) * i.cycle_range⁻¹.sign * det A := by simp [-Int.units_mul_self]\n      \n  rw [this, mul_assoc]\n  congr\n  rw [← det_permute, det_succ_row_zero]\n  refine' finset.sum_congr rfl fun j _ => _\n  rw [mul_assoc, matrix.submatrix, matrix.submatrix]\n  congr\n  · rw [Equiv.Perm.inv_def, fin.cycle_range_symm_zero]\n  · ext (i' j')\n    rw [Equiv.Perm.inv_def, fin.cycle_range_symm_succ]\n#align det_succ_row det_succ_row\n\n",
 "det_succ_column_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column 0. -/\ntheorem det_succ_column_zero {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) :\n    det A =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((-1) ^ (i : ℕ) * A i 0 * det (A.submatrix i.succ_above fin.succ)) :=\n  by\n  rw [matrix.det_apply, finset.univ_perm_fin_succ, ← finset.univ_product_univ]\n  simp only [finset.sum_map, Equiv.toEmbedding_apply, finset.sum_product, matrix.submatrix]\n  refine' finset.sum_congr rfl fun i _ => Fin.cases _ (fun i => _) i\n  ·\n    simp only [fin.prod_univ_succ, matrix.det_apply, finset.mul_sum, equiv.perm.decompose_fin_symm_apply_zero,\n      Fin.val_zero, one_mul, equiv.perm.decompose_fin.symm_sign, Equiv.swap_self, if_true, id.def, eq_self_iff_true,\n      equiv.perm.decompose_fin_symm_apply_succ, Fin.succAbove_zero, equiv.coe_refl, pow_zero, mul_smul_comm, of_apply]\n  -- `univ_perm_fin_succ` gives a different embedding of `perm (fin n)` into\n  -- `perm (fin n.succ)` than the determinant of the submatrix we want,\n  -- permute `A` so that we get the correct one.\n  have : (-1 : R) ^ (i : ℕ) = i.cycle_range.sign := by simp [fin.sign_cycle_range]\n  rw [Fin.val_succ, pow_succ, this, mul_assoc, mul_assoc, mul_left_comm ↑(equiv.perm.sign _), ← det_permute,\n    matrix.det_apply, finset.mul_sum, finset.mul_sum]\n  -- now we just need to move the corresponding parts to the same place\n  refine' finset.sum_congr rfl fun σ _ => _\n  rw [equiv.perm.decompose_fin.symm_sign, if_neg (Fin.succ_ne_zero i)]\n  calc\n    «expr • » (-1 * σ.sign : ℤ)\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (A (equiv.perm.decompose_fin.symm (fin.succ i, σ) i') i')) =\n        «expr • » (-1 * σ.sign : ℤ)\n          (A (fin.succ i) 0 *\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (A ((fin.succ i).succ_above (fin.cycle_range i (σ i'))) i'.succ)) :=\n      by\n      simp only [fin.prod_univ_succ, fin.succ_above_cycle_range, equiv.perm.decompose_fin_symm_apply_zero,\n        equiv.perm.decompose_fin_symm_apply_succ]\n    _ =\n        -1 *\n          (A (fin.succ i) 0 *\n            «expr • » (σ.sign : ℤ)\n              (finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (A ((fin.succ i).succ_above (fin.cycle_range i (σ i'))) i'.succ))) :=\n      by\n      simp only [mul_assoc, mul_comm, _root_.neg_mul, one_mul, zsmul_eq_mul, neg_inj, neg_smul,\n        fin.succ_above_cycle_range]\n    \n#align det_succ_column_zero det_succ_column_zero\n\n",
 "det_succ_column":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Laplacian expansion of the determinant of an `n+1 × n+1` matrix along column `j`. -/\ntheorem det_succ_column {n : ℕ} (A : matrix (fin n.succ) (fin n.succ) R) (j : fin n.succ) :\n    det A =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((-1) ^ (i + j : ℕ) * A i j * det (A.submatrix i.succ_above j.succ_above)) :=\n  by\n  rw [← det_transpose, det_succ_row _ j]\n  refine' finset.sum_congr rfl fun i _ => _\n  rw [add_comm, ← det_transpose, transpose_apply, transpose_submatrix, transpose_transpose]\n#align det_succ_column det_succ_column\n\n",
 "det_submatrix_equiv_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- Permuting rows and columns with the same equivalence has no effect. -/\n@[simp]\ntheorem det_submatrix_equiv_self (e : «expr ≃ » n m) (A : matrix m m R) : det (A.submatrix e e) = det A :=\n  by\n  rw [det_apply', det_apply']\n  apply fintype.sum_equiv (equiv.perm_congr e)\n  intro σ\n  rw [equiv.perm.sign_perm_congr e σ]\n  congr 1\n  apply fintype.prod_equiv e\n  intro i\n  rw [Equiv.permCongr_apply, equiv.symm_apply_apply, submatrix_apply]\n#align det_submatrix_equiv_self det_submatrix_equiv_self\n\n",
 "det_smul_of_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem det_smul_of_tower {α} [monoid α] [DistribMulAction α R] [IsScalarTower α R R] [SMulCommClass α R R] (c : α)\n    (A : matrix n n R) : det («expr • » c A) = «expr • » (c ^ fintype.card n) (det A) := by\n  rw [← smul_one_smul R c A, det_smul, smul_pow, one_pow, smul_mul_assoc, one_mul]\n#align det_smul_of_tower det_smul_of_tower\n\n",
 "det_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_smul (A : matrix n n R) (c : R) : det («expr • » c A) = c ^ fintype.card n * det A :=\n  calc\n    det («expr • » c A) = det (matrix.mul (diagonal fun _ => c) A) := by rw [smul_eq_diagonal_mul]\n    _ = det (diagonal fun _ => c) * det A := det_mul _ _\n    _ = c ^ fintype.card n * det A := by simp [card_univ]\n    \n#align det_smul det_smul\n\n",
 "det_reindex_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`matrix.reindex_apply` unfolds `reindex` first.\n-/\ntheorem det_reindex_self (e : «expr ≃ » m n) (A : matrix m m R) : det (reindex e e A) = det A :=\n  det_submatrix_equiv_self e.symm A\n#align det_reindex_self det_reindex_self\n\n",
 "det_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n@[simp]\ntheorem det_pow (M : matrix m m R) (n : ℕ) : det (M ^ n) = det M ^ n :=\n  (det_monoid_hom : «expr →* » (matrix m m R) R).map_pow M n\n#align det_pow det_pow\n\n",
 "det_permute":
 "/-- Permuting the columns changes the sign of the determinant. -/\ntheorem det_permute (σ : perm n) (M : matrix n n R) : (matrix.det fun i => M (σ i)) = σ.sign * M.det :=\n  ((det_row_alternating : alternating_map R (n → R) R n).map_perm M σ).trans (by simp [Units.smul_def])\n#align det_permute det_permute\n\n",
 "det_permutation":
 "/-- The determinant of a permutation matrix equals its sign. -/\n@[simp]\ntheorem det_permutation (σ : perm n) : matrix.det (σ.to_pequiv.to_matrix : matrix n n R) = σ.sign := by\n  rw [← matrix.mul_one (σ.to_pequiv.to_matrix : matrix n n R), pequiv.to_pequiv_mul_matrix, det_permute, det_one,\n    mul_one]\n#align det_permutation det_permutation\n\n",
 "det_one":
 "@[simp]\ntheorem det_one : det (1 : matrix n n R) = 1 := by rw [← diagonal_one] <;> simp [-diagonal_one]\n#align det_one det_one\n\n",
 "det_neg_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A variant of `matrix.det_neg` with scalar multiplication by `units ℤ` instead of multiplication\nby `R`. -/\ntheorem det_neg_eq_smul (A : matrix n n R) : det (-A) = «expr • » ((-1 : Units ℤ) ^ fintype.card n) (det A) := by\n  rw [← det_smul_of_tower, Units.neg_smul, one_smul]\n#align det_neg_eq_smul det_neg_eq_smul\n\n",
 "det_neg":
 "theorem det_neg (A : matrix n n R) : det (-A) = (-1) ^ fintype.card n * det A := by rw [← det_smul, neg_one_smul]\n#align det_neg det_neg\n\n",
 "det_mul_row":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_row (v : n → R) (A : matrix n n R) :\n    det (of fun i j => v j * A i j) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (v i) *\n        det A :=\n  calc\n    det (of fun i j => v j * A i j) = det (matrix.mul A (diagonal v)) :=\n      congr_arg det <| by\n        ext\n        simp [mul_comm]\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (v i) *\n          det A :=\n      by rw [det_mul, det_diagonal, mul_comm]\n    \n#align det_mul_row det_mul_row\n\n",
 "det_mul_right_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- On square matrices, `mul_right_comm` applies under `det`. -/\ntheorem det_mul_right_comm (M N P : matrix m m R) :\n    det (matrix.mul (matrix.mul M N) P) = det (matrix.mul (matrix.mul M P) N) := by\n  rw [matrix.mul_assoc, matrix.mul_assoc, det_mul, det_mul_comm N P, ← det_mul]\n#align det_mul_right_comm det_mul_right_comm\n\n",
 "det_mul_left_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- On square matrices, `mul_left_comm` applies under `det`. -/\ntheorem det_mul_left_comm (M N P : matrix m m R) :\n    det (matrix.mul M (matrix.mul N P)) = det (matrix.mul N (matrix.mul M P)) := by\n  rw [← matrix.mul_assoc, ← matrix.mul_assoc, det_mul, det_mul_comm M N, ← det_mul]\n#align det_mul_left_comm det_mul_left_comm\n\n",
 "det_mul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- On square matrices, `mul_comm` applies under `det`. -/\ntheorem det_mul_comm (M N : matrix m m R) : det (matrix.mul M N) = det (matrix.mul N M) := by\n  rw [det_mul, det_mul, mul_comm]\n#align det_mul_comm det_mul_comm\n\n",
 "det_mul_column":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. -/\ntheorem det_mul_column (v : n → R) (A : matrix n n R) :\n    det (of fun i j => v i * A i j) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (v i) *\n        det A :=\n  multilinear_map.map_smul_univ _ v A\n#align det_mul_column det_mul_column\n\n",
 "det_mul_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem det_mul_aux {M N : matrix n n R} {p : n → n} (H : ¬bijective p) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («exprε » σ *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (M (σ x) (p x) * N (p x) x)) =\n      0 :=\n  by\n  obtain ⟨i, j, hpij, hij⟩ : ∃ i j, p i = p j ∧ i ≠ j :=\n    by\n    rw [← finite.injective_iff_bijective, injective] at H\n    push_neg  at H\n    exact H\n  exact\n    sum_involution (fun σ _ => σ * swap i j)\n      (fun σ _ =>\n        by\n        have :\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (M (σ x) (p x)) =\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n              (M ((σ * swap i j) x) (p x)) :=\n          fintype.prod_equiv (swap i j) _ _ (by simp [apply_swap_eq_self hpij])\n        simp [this, sign_swap hij, prod_mul_distrib])\n      (fun σ _ _ => (not_congr mul_swap_eq_iff).mpr hij) (fun _ _ => mem_univ _) fun σ _ => mul_swap_involutive i j σ\n#align det_mul_aux det_mul_aux\n\n",
 "det_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem det_mul (M N : matrix n n R) : det (matrix.mul M N) = det M * det N :=\n  calc\n    det (matrix.mul M N) =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («exprε » σ *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M (σ i) (p i) * N (p i) i))) :=\n      by simp only [det_apply', mul_apply, prod_univ_sum, mul_sum, fintype.pi_finset_univ] <;> rw [finset.sum_comm]\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          ((@univ (n → n) _).filter bijective)\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («exprε » σ *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M (σ i) (p i) * N (p i) i))) :=\n      eq.symm <|\n        sum_subset (filter_subset _ _) fun f _ hbij =>\n          det_mul_aux <| by simpa only [true_and_iff, mem_filter, mem_univ] using hbij\n    _ =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («exprε » σ *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M (σ i) (τ i) * N (τ i) i))) :=\n      sum_bij (fun p h => Equiv.ofBijective p (mem_filter.1 h).2) (fun _ _ => mem_univ _) (fun _ _ => rfl)\n        (fun _ _ _ _ h => by injection h) fun b _ => ⟨b, mem_filter.2 ⟨mem_univ _, b.bijective⟩, coe_fn_injective rfl⟩\n    _ =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                  (N (σ i) i) *\n                «exprε » τ *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M (τ j) (σ j)))) :=\n      by simp only [mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]\n    _ =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                  (N (σ i) i) *\n                («exprε » σ * «exprε » τ) *\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M (τ i) i))) :=\n      sum_congr rfl fun σ _ =>\n        fintype.sum_equiv (Equiv.mulRight σ⁻¹) _ _ fun τ =>\n          by\n          have :\n            finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M (τ j) (σ j)) =\n              finset.prod_univ\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n                (M ((τ * σ⁻¹) j) j) :=\n            by\n            rw [← (σ⁻¹ : «expr ≃ » _ _).prod_comp]\n            simp only [Equiv.Perm.coe_mul, apply_inv_self]\n          have h : «exprε » σ * «exprε » (τ * σ⁻¹) = «exprε » τ :=\n            calc\n              «exprε » σ * «exprε » (τ * σ⁻¹) = «exprε » (τ * σ⁻¹ * σ) :=\n                by\n                rw [mul_comm, sign_mul (τ * σ⁻¹)]\n                simp only [Int.cast_mul, Units.val_mul]\n              _ = «exprε » τ := by simp only [inv_mul_cancel_right]\n              \n          simp_rw [Equiv.coe_mulRight, h]\n          simp only [this]\n    _ = det M * det N := by simp only [det_apply', finset.mul_sum, mul_comm, mul_left_comm]\n    \n#align det_mul det_mul\n\n",
 "det_is_empty":
 "theorem det_is_empty [is_empty n] {A : matrix n n R} : det A = 1 := by simp [det_apply]\n#align det_is_empty det_is_empty\n\n",
 "det_from_blocks_zero₂₁":
 "/-- The determinant of a 2×2 block matrix with the lower-left block equal to zero is the product of\nthe determinants of the diagonal blocks. For the generalization to any number of blocks, see\n`matrix.det_of_upper_triangular`. -/\n@[simp]\ntheorem det_from_blocks_zero₂₁ (A : matrix m m R) (B : matrix m n R) (D : matrix n n R) :\n    (matrix.from_blocks A B 0 D).det = A.det * D.det := by\n  classical\n    simp_rw [det_apply']\n    convert (sum_subset (subset_univ ((sum_congr_hom m n).range : set (perm (Sum m n))).to_finset) _).symm\n    rw [sum_mul_sum]\n    simp_rw [univ_product_univ]\n    rw [(sum_bij (fun (σ : perm m × perm n) _ => Equiv.sumCongr σ.fst σ.snd) _ _ _ _).symm]\n    · intro σ₁₂ h\n      simp only\n      erw [set.mem_to_finset, monoid_hom.mem_range]\n      use σ₁₂\n      simp only [sum_congr_hom_apply]\n    · simp only [forall_prop_of_true, prod.forall, mem_univ]\n      intro σ₁ σ₂\n      rw [fintype.prod_sum_type]\n      simp_rw [equiv.sum_congr_apply, sum.map_inr, sum.map_inl, from_blocks_apply₁₁, from_blocks_apply₂₂]\n      rw [mul_mul_mul_comm]\n      congr\n      rw [sign_sum_congr, Units.val_mul, Int.cast_mul]\n    · intro σ₁ σ₂ h₁ h₂\n      dsimp only\n      intro h\n      have h2 : ∀ x, perm.sum_congr σ₁.fst σ₁.snd x = perm.sum_congr σ₂.fst σ₂.snd x :=\n        by\n        intro x\n        exact congr_fun (congr_arg to_fun h) x\n      simp only [sum.map_inr, sum.map_inl, perm.sum_congr_apply, sum.forall] at h2\n      ext\n      · exact h2.left x\n      · exact h2.right x\n    · intro σ hσ\n      erw [set.mem_to_finset, monoid_hom.mem_range] at hσ\n      obtain ⟨σ₁₂, hσ₁₂⟩ := hσ\n      use σ₁₂\n      rw [← hσ₁₂]\n      simp\n    · intro σ hσ hσn\n      have h1 : ¬∀ x, ∃ y, sum.inl y = σ (sum.inl x) := by\n        by_contra\n        rw [set.mem_to_finset] at hσn\n        apply absurd (mem_sum_congr_hom_range_of_perm_maps_to_inl _) hσn\n        rintro x ⟨a, ha⟩\n        rw [← ha]\n        exact h a\n      obtain ⟨a, ha⟩ := not_forall.mp h1\n      cases' hx : σ (sum.inl a) with a2 b\n      · have hn := (not_exists.mp ha) a2\n        exact absurd hx.symm hn\n      · rw [finset.prod_eq_zero (finset.mem_univ (sum.inl a)), mul_zero]\n        rw [hx, from_blocks_apply₂₁]\n        rfl\n#align det_from_blocks_zero₂₁ det_from_blocks_zero₂₁\n\n",
 "det_from_blocks_zero₁₂":
 "/-- The determinant of a 2×2 block matrix with the upper-right block equal to zero is the product of\nthe determinants of the diagonal blocks. For the generalization to any number of blocks, see\n`matrix.det_of_lower_triangular`. -/\n@[simp]\ntheorem det_from_blocks_zero₁₂ (A : matrix m m R) (C : matrix n m R) (D : matrix n n R) :\n    (matrix.from_blocks A 0 C D).det = A.det * D.det := by\n  rw [← det_transpose, from_blocks_transpose, transpose_zero, det_from_blocks_zero₂₁, det_transpose, det_transpose]\n#align det_from_blocks_zero₁₂ det_from_blocks_zero₁₂\n\n",
 "det_fin_zero":
 "/-- Determinant of 0x0 matrix -/\n@[simp]\ntheorem det_fin_zero {A : matrix (fin 0) (fin 0) R} : det A = 1 :=\n  det_is_empty\n#align det_fin_zero det_fin_zero\n\n",
 "det_fin_two_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr!![ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\n@[simp]\ntheorem det_fin_two_of (a b c d : R) :\n    matrix.det\n        («expr!![ » \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\") =\n      a * d - b * c :=\n  det_fin_two _\n#align det_fin_two_of det_fin_two_of\n\n",
 "det_fin_two":
 "/-- Determinant of 2x2 matrix -/\ntheorem det_fin_two (A : matrix (fin 2) (fin 2) R) : det A = A 0 0 * A 1 1 - A 0 1 * A 1 0 :=\n  by\n  simp [matrix.det_succ_row_zero, fin.sum_univ_succ]\n  ring\n#align det_fin_two det_fin_two\n\n",
 "det_fin_three":
 "/-- Determinant of 3x3 matrix -/\ntheorem det_fin_three (A : matrix (fin 3) (fin 3) R) :\n    det A =\n      A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 +\n          A 0 2 * A 1 0 * A 2 1 -\n        A 0 2 * A 1 1 * A 2 0 :=\n  by\n  simp [matrix.det_succ_row_zero, fin.sum_univ_succ]\n  ring\n#align det_fin_three det_fin_three\n\n",
 "det_fin_one_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr!![ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation -/\ntheorem det_fin_one_of (a : R) :\n    det («expr!![ » \"./././Mathport/Syntax/Translate/Expr.lean:390:14: unsupported user notation matrix.notation\") =\n      a :=\n  det_fin_one _\n#align det_fin_one_of det_fin_one_of\n\n",
 "det_fin_one":
 "/-- Determinant of 1x1 matrix -/\ntheorem det_fin_one (A : matrix (fin 1) (fin 1) R) : det A = A 0 0 :=\n  det_unique A\n#align det_fin_one det_fin_one\n\n",
 "det_eq_zero_of_row_eq_zero":
 "theorem det_eq_zero_of_row_eq_zero {A : matrix n n R} (i : n) (h : ∀ j, A i j = 0) : det A = 0 :=\n  (det_row_alternating : alternating_map R (n → R) R n).map_coord_zero i (funext h)\n#align det_eq_zero_of_row_eq_zero det_eq_zero_of_row_eq_zero\n\n",
 "det_eq_zero_of_column_eq_zero":
 "theorem det_eq_zero_of_column_eq_zero {A : matrix n n R} (j : n) (h : ∀ i, A i j = 0) : det A = 0 :=\n  by\n  rw [← det_transpose]\n  exact det_eq_zero_of_row_eq_zero j h\n#align det_eq_zero_of_column_eq_zero det_eq_zero_of_column_eq_zero\n\n",
 "det_eq_one_of_card_eq_zero":
 "theorem det_eq_one_of_card_eq_zero {A : matrix n n R} (h : fintype.card n = 0) : det A = 1 :=\n  haveI : is_empty n := fintype.card_eq_zero_iff.mp h\n  det_is_empty\n#align det_eq_one_of_card_eq_zero det_eq_one_of_card_eq_zero\n\n",
 "det_eq_of_forall_row_eq_smul_add_pred_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_eq_of_forall_row_eq_smul_add_pred_aux {n : ℕ} (k : fin (n + 1)) :\n    ∀ (c : fin n → R) (hc : ∀ i : fin n, k < i.succ → c i = 0) {M N : matrix (fin n.succ) (fin n.succ) R}\n      (h0 : ∀ j, M 0 j = N 0 j) (hsucc : ∀ (i : fin n) (j), M i.succ j = N i.succ j + c i * M i.cast_succ j),\n      det M = det N :=\n  by\n  refine' Fin.induction _ (fun k ih => _) k <;> intro c hc M N h0 hsucc\n  · congr\n    ext (i j)\n    refine' Fin.cases (h0 j) (fun i => _) i\n    rw [hsucc, hc i (Fin.succ_pos _), zero_mul, add_zero]\n  set M' := update_row M k.succ (N k.succ) with hM'\n  have hM : M = update_row M' k.succ (M' k.succ + «expr • » (c k) (M k.cast_succ)) :=\n    by\n    ext (i j)\n    by_cases hi : i = k.succ\n    · simp [hi, hM', hsucc, update_row_self]\n    rw [update_row_ne hi, hM', update_row_ne hi]\n  have k_ne_succ : k.cast_succ ≠ k.succ := (Fin.castSucc_lt_succ k).ne\n  have M_k : M k.cast_succ = M' k.cast_succ := (update_row_ne k_ne_succ).symm\n  rw [hM, M_k, det_update_row_add_smul_self M' k_ne_succ.symm, ih (function.update c k 0)]\n  · intro i hi\n    rw [Fin.lt_iff_val_lt_val, Fin.coe_castSucc, Fin.val_succ, Nat.lt_succ_iff] at hi\n    rw [function.update_apply]\n    split_ifs with hik\n    · rfl\n    exact hc _ (fin.succ_lt_succ_iff.mpr (lt_of_le_of_ne hi (ne.symm hik)))\n  · rwa [hM', update_row_ne (Fin.succ_ne_zero _).symm]\n  intro i j\n  rw [function.update_apply]\n  split_ifs with hik\n  · rw [zero_mul, add_zero, hM', hik, update_row_self]\n  rw [hM', update_row_ne ((Fin.succ_injective _).ne hik), hsucc]\n  by_cases hik2 : k < i\n  · simp [hc i (fin.succ_lt_succ_iff.mpr hik2)]\n  rw [update_row_ne]\n  apply ne_of_lt\n  rwa [Fin.lt_iff_val_lt_val, Fin.coe_castSucc, Fin.val_succ, Nat.lt_succ_iff, ← not_lt]\n#align det_eq_of_forall_row_eq_smul_add_pred_aux det_eq_of_forall_row_eq_smul_add_pred_aux\n\n",
 "det_eq_of_forall_row_eq_smul_add_pred":
 "/-- If you add multiples of previous rows to the next row, the determinant doesn't change. -/\ntheorem det_eq_of_forall_row_eq_smul_add_pred {n : ℕ} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n → R)\n    (A_zero : ∀ j, A 0 j = B 0 j) (A_succ : ∀ (i : fin n) (j), A i.succ j = B i.succ j + c i * A i.cast_succ j) :\n    det A = det B :=\n  det_eq_of_forall_row_eq_smul_add_pred_aux (Fin.last _) c (fun i hi => absurd hi (not_lt_of_ge (Fin.le_last _))) A_zero\n    A_succ\n#align det_eq_of_forall_row_eq_smul_add_pred det_eq_of_forall_row_eq_smul_add_pred\n\n",
 "det_eq_of_forall_row_eq_smul_add_const_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : matrix n n R} {s : Finset n} :\n    ∀ (c : n → R) (hs : ∀ i, i ∉ s → c i = 0) (k : n) (hk : k ∉ s) (A_eq : ∀ i j, A i j = B i j + c i * B k j),\n      det A = det B :=\n  by\n  revert B\n  refine' s.induction_on _ _\n  · intro A c hs k hk A_eq\n    have : ∀ i, c i = 0 := by\n      intro i\n      specialize hs i\n      contrapose! hs\n      simp [hs]\n    congr\n    ext (i j)\n    rw [A_eq, this, zero_mul, add_zero]\n  · intro i s hi ih B c hs k hk A_eq\n    have hAi : A i = B i + «expr • » (c i) (B k) := funext (A_eq i)\n    rw [@ih (update_row B i (A i)) (function.update c i 0), hAi, det_update_row_add_smul_self]\n    · exact mt (fun h => show k ∈ insert i s from h ▸ Finset.mem_insert_self _ _) hk\n    · intro i' hi'\n      rw [function.update_apply]\n      split_ifs with hi'i\n      · rfl\n      · exact hs i' fun h => hi' ((finset.mem_insert.mp h).resolve_left hi'i)\n    · exact fun h => hk (Finset.mem_insert_of_mem h)\n    · intro i' j'\n      rw [update_row_apply, function.update_apply]\n      split_ifs with hi'i\n      · simp [hi'i]\n      rw [A_eq, update_row_ne fun h : k = i => hk <| h ▸ Finset.mem_insert_self k s]\n#align det_eq_of_forall_row_eq_smul_add_const_aux det_eq_of_forall_row_eq_smul_add_const_aux\n\n",
 "det_eq_of_forall_row_eq_smul_add_const":
 "/-- If you add multiples of row `B k` to other rows, the determinant doesn't change. -/\ntheorem det_eq_of_forall_row_eq_smul_add_const {A B : matrix n n R} (c : n → R) (k : n) (hk : c k = 0)\n    (A_eq : ∀ i j, A i j = B i j + c i * B k j) : det A = det B :=\n  det_eq_of_forall_row_eq_smul_add_const_aux c\n    (fun i =>\n      not_imp_comm.mp fun hi =>\n        Finset.mem_erase.mpr ⟨mt (fun h : i = k => show c i = 0 from h.symm ▸ hk) hi, finset.mem_univ i⟩)\n    k (Finset.not_mem_erase k finset.univ) A_eq\n#align det_eq_of_forall_row_eq_smul_add_const det_eq_of_forall_row_eq_smul_add_const\n\n",
 "det_eq_of_forall_col_eq_smul_add_pred":
 "/-- If you add multiples of previous columns to the next columns, the determinant doesn't change. -/\ntheorem det_eq_of_forall_col_eq_smul_add_pred {n : ℕ} {A B : matrix (fin (n + 1)) (fin (n + 1)) R} (c : fin n → R)\n    (A_zero : ∀ i, A i 0 = B i 0) (A_succ : ∀ (i) (j : fin n), A i j.succ = B i j.succ + c j * A i j.cast_succ) :\n    det A = det B := by\n  rw [← det_transpose A, ← det_transpose B]\n  exact det_eq_of_forall_row_eq_smul_add_pred c A_zero fun i j => A_succ j i\n#align det_eq_of_forall_col_eq_smul_add_pred det_eq_of_forall_col_eq_smul_add_pred\n\n",
 "det_eq_of_eq_mul_det_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_eq_of_eq_mul_det_one {A B : matrix n n R} (C : matrix n n R) (hC : det C = 1) (hA : A = matrix.mul B C) :\n    det A = det B :=\n  calc\n    det A = det (matrix.mul B C) := congr_arg _ hA\n    _ = det B * det C := det_mul _ _\n    _ = det B := by rw [hC, mul_one]\n    \n#align det_eq_of_eq_mul_det_one det_eq_of_eq_mul_det_one\n\n",
 "det_eq_of_eq_det_one_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_eq_of_eq_det_one_mul {A B : matrix n n R} (C : matrix n n R) (hC : det C = 1) (hA : A = matrix.mul C B) :\n    det A = det B :=\n  calc\n    det A = det (matrix.mul C B) := congr_arg _ hA\n    _ = det C * det B := det_mul _ _\n    _ = det B := by rw [hC, one_mul]\n    \n#align det_eq_of_eq_det_one_mul det_eq_of_eq_det_one_mul\n\n",
 "det_eq_elem_of_subsingleton":
 "theorem det_eq_elem_of_subsingleton [subsingleton n] (A : matrix n n R) (k : n) : det A = A k k :=\n  by\n  convert det_unique _\n  exact unique_of_subsingleton k\n#align det_eq_elem_of_subsingleton det_eq_elem_of_subsingleton\n\n",
 "det_eq_elem_of_card_eq_one":
 "theorem det_eq_elem_of_card_eq_one {A : matrix n n R} (h : fintype.card n = 1) (k : n) : det A = A k k :=\n  haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le\n  det_eq_elem_of_subsingleton _ _\n#align det_eq_elem_of_card_eq_one det_eq_elem_of_card_eq_one\n\n",
 "det_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem det_diagonal {d : n → R} :\n    det (diagonal d) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (d i) :=\n  by\n  rw [det_apply']\n  refine' (finset.sum_eq_single 1 _ _).trans _\n  · intro σ h1 h2\n    cases' not_forall.1 (mt equiv.ext h2) with x h3\n    convert mul_zero _\n    apply finset.prod_eq_zero\n    · change x ∈ _\n      simp\n    exact if_neg h3\n  · simp\n  · simp\n#align det_diagonal det_diagonal\n\n",
 "det_conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n@[simp]\ntheorem det_conj_transpose [StarRing R] (M : matrix m m R) : det (matrix.conj_transpose M) = star (det M) :=\n  ((starRingEnd R).map_det _).symm.trans <| congr_arg star M.det_transpose\n#align det_conj_transpose det_conj_transpose\n\n",
 "det_block_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem det_block_diagonal {o : Type _} [fintype o] [decidable_eq o] (M : o → matrix n n R) :\n    (block_diagonal M).det =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (M k).det :=\n  by\n  -- Rewrite the determinants as a sum over permutations.\n  simp_rw [det_apply']\n  -- The right hand side is a product of sums, rewrite it as a sum of products.\n  rw [finset.prod_sum]\n  simp_rw [finset.mem_univ, finset.prod_attach_univ, finset.univ_pi_univ]\n  -- We claim that the only permutations contributing to the sum are those that\n  -- preserve their second component.\n  let preserving_snd : Finset (equiv.perm (n × o)) := finset.univ.filter fun σ => ∀ x, (σ x).snd = x.snd\n  have mem_preserving_snd : ∀ {σ : equiv.perm (n × o)}, σ ∈ preserving_snd ↔ ∀ x, (σ x).snd = x.snd := fun σ =>\n    finset.mem_filter.trans ⟨fun h => h.2, fun h => ⟨finset.mem_univ _, h⟩⟩\n  rw [← finset.sum_subset (finset.subset_univ preserving_snd) _]\n  -- And that these are in bijection with `o → equiv.perm m`.\n  rw [(finset.sum_bij\n        (fun (σ : ∀ k : o, k ∈ finset.univ → equiv.perm n) _ => prod_congr_left fun k => σ k (finset.mem_univ k)) _ _ _\n        _).symm]\n  · intro σ _\n    rw [mem_preserving_snd]\n    rintro ⟨k, x⟩\n    simp only [prod_congr_left_apply]\n  · intro σ _\n    rw [finset.prod_mul_distrib, ← finset.univ_product_univ, finset.prod_product_right]\n    simp only [sign_prod_congr_left, units.coe_prod, int.cast_prod, block_diagonal_apply_eq, prod_congr_left_apply]\n  · intro σ σ' _ _ eq\n    ext (x hx k)\n    simp only at eq\n    have :\n      ∀ k x,\n        prod_congr_left (fun k => σ k (finset.mem_univ _)) (k, x) =\n          prod_congr_left (fun k => σ' k (finset.mem_univ _)) (k, x) :=\n      fun k x => by rw [eq]\n    simp only [prod_congr_left_apply, prod.mk.inj_iff] at this\n    exact (this k x).1\n  · intro σ hσ\n    rw [mem_preserving_snd] at hσ\n    have hσ' : ∀ x, (σ⁻¹ x).snd = x.snd := by\n      intro x\n      conv_rhs => rw [← perm.apply_inv_self σ x, hσ]\n    have mk_apply_eq : ∀ k x, ((σ (x, k)).fst, k) = σ (x, k) :=\n      by\n      intro k x\n      ext\n      · simp only\n      · simp only [hσ]\n    have mk_inv_apply_eq : ∀ k x, ((σ⁻¹ (x, k)).fst, k) = σ⁻¹ (x, k) :=\n      by\n      intro k x\n      conv_lhs => rw [← perm.apply_inv_self σ (x, k)]\n      ext\n      · simp only [apply_inv_self]\n      · simp only [hσ']\n    refine' ⟨fun k _ => ⟨fun x => (σ (x, k)).fst, fun x => (σ⁻¹ (x, k)).fst, _, _⟩, _, _⟩\n    · intro x\n      simp only [mk_apply_eq, inv_apply_self]\n    · intro x\n      simp only [mk_inv_apply_eq, apply_inv_self]\n    · apply finset.mem_univ\n    · ext ⟨k, x⟩\n      · simp only [coe_fn_mk, prod_congr_left_apply]\n      · simp only [prod_congr_left_apply, hσ]\n  · intro σ _ hσ\n    rw [mem_preserving_snd] at hσ\n    obtain ⟨⟨k, x⟩, hkx⟩ := not_forall.mp hσ\n    rw [finset.prod_eq_zero (finset.mem_univ (k, x)), mul_zero]\n    rw [← @prod.mk.eta _ _ (σ (k, x)), block_diagonal_apply_ne]\n    exact hkx\n#align det_block_diagonal det_block_diagonal\n\n",
 "det_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprε » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n-- This is what the old definition was. We use it to avoid having to change the old proofs below\ntheorem det_apply' (M : matrix n n R) :\n    M.det =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («exprε » σ *\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (M (σ i) i)) :=\n  by simp [det_apply, Units.smul_def]\n#align det_apply' det_apply'\n\n",
 "det_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Chris Hughes, Tim Baanen\n-/\ntheorem det_apply (M : matrix n n R) :\n    M.det =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » σ.sign\n          (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (M (σ i) i))) :=\n  multilinear_map.alternatization_apply _ M\n#align det_apply det_apply\n\n",
 "coe_det_monoid_hom":
 "@[simp]\ntheorem coe_det_monoid_hom : (det_monoid_hom : matrix n n R → R) = det :=\n  rfl\n#align coe_det_monoid_hom coe_det_monoid_hom\n\n",
 "coe_det_is_empty":
 "@[simp]\ntheorem coe_det_is_empty [is_empty n] : (det : matrix n n R → R) = function.const _ 1 :=\n  by\n  ext\n  exact det_is_empty\n#align coe_det_is_empty coe_det_is_empty\n\n"}