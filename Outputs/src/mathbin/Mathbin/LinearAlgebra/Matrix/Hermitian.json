{"transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem is_hermitian.transpose {A : Matrix n n α} (h : A.is_hermitian) : (matrix.transpose A).is_hermitian :=\n  by\n  rw [is_hermitian, conj_transpose, transpose_map]\n  congr\n  exact h\n#align is_hermitian.transpose is_hermitian.transpose\n\n",
 "submatrix":
 "@[simp]\ntheorem is_hermitian.submatrix {A : Matrix n n α} (h : A.is_hermitian) (f : m → n) : (A.submatrix f f).is_hermitian :=\n  (conjTranspose_submatrix _ _ _).trans (h.symm ▸ rfl)\n#align is_hermitian.submatrix is_hermitian.submatrix\n\n",
 "sub":
 "@[simp]\ntheorem is_hermitian.sub {A B : Matrix n n α} (hA : A.is_hermitian) (hB : B.is_hermitian) : (A - B).is_hermitian :=\n  IsSelfAdjoint.sub hA hB\n#align is_hermitian.sub is_hermitian.sub\n\n",
 "neg":
 "@[simp]\ntheorem is_hermitian.neg {A : Matrix n n α} (h : A.is_hermitian) : (-A).is_hermitian :=\n  IsSelfAdjoint.neg h\n#align is_hermitian.neg is_hermitian.neg\n\n",
 "map":
 "@[simp]\ntheorem is_hermitian.map {A : Matrix n n α} (h : A.is_hermitian) (f : α → β) (hf : Function.Semiconj f star star) :\n    (A.map f).is_hermitian :=\n  (conjTranspose_map f hf).symm.trans <| h.eq.symm ▸ rfl\n#align is_hermitian.map is_hermitian.map\n\n",
 "is_self_adjoint":
 "protected theorem is_hermitian.is_self_adjoint {A : Matrix n n α} (h : A.is_hermitian) : IsSelfAdjoint A :=\n  h\n#align is_hermitian.is_self_adjoint is_hermitian.is_self_adjoint\n\n",
 "is_hermitian_zero":
 "@[simp]\ntheorem is_hermitian_zero : (0 : Matrix n n α).is_hermitian :=\n  isSelfAdjoint_zero _\n#align is_hermitian_zero is_hermitian_zero\n\n",
 "is_hermitian_transpose_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- Note this is more general than `is_self_adjoint.star_mul_self` as `B` can be rectangular. -/\ntheorem is_hermitian_transpose_mul_self [Fintype m] (A : Matrix m n α) :\n    (matrix.mul (matrix.conj_transpose A) A).is_hermitian := by\n  rw [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose]\n#align is_hermitian_transpose_mul_self is_hermitian_transpose_mul_self\n\n",
 "is_hermitian_transpose_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem is_hermitian_transpose_iff (A : Matrix n n α) : (matrix.transpose A).is_hermitian ↔ A.is_hermitian :=\n  ⟨by\n    intro h\n    rw [← transpose_transpose A]\n    exact is_hermitian.transpose h, is_hermitian.transpose⟩\n#align is_hermitian_transpose_iff is_hermitian_transpose_iff\n\n",
 "is_hermitian_transpose_add_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_transpose_add_self (A : Matrix n n α) : (matrix.conj_transpose A + A).is_hermitian :=\n  isSelfAdjoint_star_add_self A\n#align is_hermitian_transpose_add_self is_hermitian_transpose_add_self\n\n",
 "is_hermitian_submatrix_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem is_hermitian_submatrix_equiv {A : Matrix n n α} (e : «expr ≃ » m n) :\n    (A.submatrix e e).is_hermitian ↔ A.is_hermitian :=\n  ⟨fun h => by simpa using h.submatrix e.symm, fun h => h.submatrix _⟩\n#align is_hermitian_submatrix_equiv is_hermitian_submatrix_equiv\n\n",
 "is_hermitian_one":
 "/-- Note this is more general for matrices than `is_self_adjoint_one` as it does not\nrequire `fintype n`, which is necessary for `monoid (matrix n n R)`. -/\n@[simp]\ntheorem is_hermitian_one [DecidableEq n] : (1 : Matrix n n α).is_hermitian :=\n  conjTranspose_one\n#align is_hermitian_one is_hermitian_one\n\n",
 "is_hermitian_mul_mul_conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- Note this is more general than `is_self_adjoint.conjugate` as `B` can be rectangular. -/\ntheorem is_hermitian_mul_mul_conj_transpose [Fintype m] {A : Matrix m m α} (B : Matrix n m α) (hA : A.is_hermitian) :\n    (matrix.mul (matrix.mul B A) (matrix.conj_transpose B)).is_hermitian := by\n  simp only [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose, hA.eq, Matrix.mul_assoc]\n#align is_hermitian_mul_mul_conj_transpose is_hermitian_mul_mul_conj_transpose\n\n",
 "is_hermitian_mul_conj_transpose_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- Note this is more general than `is_self_adjoint.mul_star_self` as `B` can be rectangular. -/\ntheorem is_hermitian_mul_conj_transpose_self [Fintype n] (A : Matrix m n α) :\n    (matrix.mul A (matrix.conj_transpose A)).is_hermitian := by\n  rw [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose]\n#align is_hermitian_mul_conj_transpose_self is_hermitian_mul_conj_transpose_self\n\n",
 "is_hermitian_inv":
 "@[simp]\ntheorem is_hermitian_inv [Fintype m] [DecidableEq m] (A : Matrix m m α) [Invertible A] :\n    A⁻¹.is_hermitian ↔ A.is_hermitian :=\n  ⟨fun h => by\n    rw [← inv_inv_of_invertible A]\n    exact is_hermitian.inv h, is_hermitian.inv⟩\n#align is_hermitian_inv is_hermitian_inv\n\n",
 "is_hermitian_iff_is_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- A matrix is hermitian iff the corresponding linear map is self adjoint. -/\ntheorem is_hermitian_iff_is_symmetric [Fintype n] [DecidableEq n] {A : Matrix n n α} :\n    is_hermitian A ↔ A.to_euclidean_lin.is_symmetric :=\n  by\n  rw [linear_map.is_symmetric, (pi_Lp.equiv 2 fun _ : n => α).symm.surjective.forall₂]\n  simp only [to_euclidean_lin_pi_Lp_equiv_symm, euclidean_space.inner_pi_Lp_equiv_symm, to_lin'_apply, star_mul_vec,\n    dot_product_mul_vec]\n  constructor\n  · rintro (h : matrix.conj_transpose A = A) x y\n    rw [h]\n  · intro h\n    ext (i j)\n    simpa only [(Pi.single_star i 1).symm, ← star_mul_vec, mul_one, dot_product_single, single_vec_mul, star_one,\n      one_mul] using\n      h (@Pi.single _ _ _ (fun i => add_zero_class.to_has_zero α) i 1)\n        (@Pi.single _ _ _ (fun i => add_zero_class.to_has_zero α) j 1)\n#align is_hermitian_iff_is_symmetric is_hermitian_iff_is_symmetric\n\n",
 "is_hermitian_from_blocks_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- This is the `iff` version of `matrix.is_hermitian.from_blocks`. -/\ntheorem is_hermitian_from_blocks_iff {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} :\n    (A.from_blocks B C D).is_hermitian ↔\n      A.is_hermitian ∧ matrix.conj_transpose B = C ∧ matrix.conj_transpose C = B ∧ D.is_hermitian :=\n  ⟨fun h => ⟨congr_arg toBlocks₁₁ h, congr_arg toBlocks₂₁ h, congr_arg toBlocks₁₂ h, congr_arg toBlocks₂₂ h⟩,\n    fun ⟨hA, hBC, hCB, hD⟩ => is_hermitian.from_blocks hA hBC hD⟩\n#align is_hermitian_from_blocks_iff is_hermitian_from_blocks_iff\n\n",
 "is_hermitian_diagonal_of_self_adjoint":
 "/-- A diagonal matrix is hermitian if the entries are self-adjoint -/\ntheorem is_hermitian_diagonal_of_self_adjoint [DecidableEq n] (v : n → α) (h : IsSelfAdjoint v) :\n    (diagonal v).is_hermitian :=\n  (-- TODO: add a `pi.has_trivial_star` instance and remove the `funext`\n        diagonal_conjTranspose\n        v).trans <|\n    congr_arg _ h\n#align is_hermitian_diagonal_of_self_adjoint is_hermitian_diagonal_of_self_adjoint\n\n",
 "is_hermitian_diagonal":
 "/-- A diagonal matrix is hermitian if the entries have the trivial `star` operation\n(such as on the reals). -/\n@[simp]\ntheorem is_hermitian_diagonal [TrivialStar α] [DecidableEq n] (v : n → α) : (diagonal v).is_hermitian :=\n  is_hermitian_diagonal_of_self_adjoint _ (IsSelfAdjoint.all _)\n#align is_hermitian_diagonal is_hermitian_diagonal\n\n",
 "is_hermitian_conj_transpose_mul_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- Note this is more general than `is_self_adjoint.conjugate'` as `B` can be rectangular. -/\ntheorem is_hermitian_conj_transpose_mul_mul [Fintype m] {A : Matrix m m α} (B : Matrix m n α) (hA : A.is_hermitian) :\n    (matrix.mul (matrix.mul (matrix.conj_transpose B) A) B).is_hermitian := by\n  simp only [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose, hA.eq, Matrix.mul_assoc]\n#align is_hermitian_conj_transpose_mul_mul is_hermitian_conj_transpose_mul_mul\n\n",
 "is_hermitian_conj_transpose_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n@[simp]\ntheorem is_hermitian_conj_transpose_iff (A : Matrix n n α) : (matrix.conj_transpose A).is_hermitian ↔ A.is_hermitian :=\n  IsSelfAdjoint.star_iff\n#align is_hermitian_conj_transpose_iff is_hermitian_conj_transpose_iff\n\n",
 "is_hermitian_add_transpose_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_add_transpose_self (A : Matrix n n α) : (A + matrix.conj_transpose A).is_hermitian :=\n  isSelfAdjoint_add_star_self A\n#align is_hermitian_add_transpose_self is_hermitian_add_transpose_self\n\n",
 "inv":
 "theorem is_hermitian.inv [Fintype m] [DecidableEq m] {A : Matrix m m α} (hA : A.is_hermitian) : A⁻¹.is_hermitian := by\n  simp [is_hermitian, conj_transpose_nonsing_inv, hA.eq]\n#align is_hermitian.inv is_hermitian.inv\n\n",
 "from_blocks":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- A block matrix `A.from_blocks B C D` is hermitian,\n    if `A` and `D` are hermitian and `Bᴴ = C`. -/\ntheorem is_hermitian.from_blocks {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α}\n    (hA : A.is_hermitian) (hBC : matrix.conj_transpose B = C) (hD : D.is_hermitian) :\n    (A.from_blocks B C D).is_hermitian :=\n  by\n  have hCB : matrix.conj_transpose C = B := by rw [← hBC, conj_transpose_conj_transpose]\n  unfold matrix.is_hermitian\n  rw [from_blocks_conj_transpose]\n  congr <;> assumption\n#align is_hermitian.from_blocks is_hermitian.from_blocks\n\n",
 "ext_iff":
 "theorem is_hermitian.ext_iff {A : Matrix n n α} : A.is_hermitian ↔ ∀ i j, star (A j i) = A i j :=\n  ⟨is_hermitian.apply, is_hermitian.ext⟩\n#align is_hermitian.ext_iff is_hermitian.ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem is_hermitian.ext {A : Matrix n n α} : (∀ i j, star (A j i) = A i j) → A.is_hermitian :=\n  by\n  intro h\n  ext (i j)\n  exact h i j\n#align is_hermitian.ext is_hermitian.ext\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-\nCopyright (c) 2022 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp\n-/\ntheorem is_hermitian.eq {A : Matrix n n α} (h : A.is_hermitian) : matrix.conj_transpose A = A :=\n  h\n#align is_hermitian.eq is_hermitian.eq\n\n",
 "conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian.conj_transpose {A : Matrix n n α} (h : A.is_hermitian) : (matrix.conj_transpose A).is_hermitian :=\n  h.transpose.map _ fun _ => rfl\n#align is_hermitian.conj_transpose is_hermitian.conj_transpose\n\n",
 "coe_re_diag":
 "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem is_hermitian.coe_re_diag {A : Matrix n n α} (h : A.is_hermitian) : (fun i => (re (A.diag i) : α)) = A.diag :=\n  funext h.coe_re_apply_self\n#align is_hermitian.coe_re_diag is_hermitian.coe_re_diag\n\n",
 "coe_re_apply_self":
 "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem is_hermitian.coe_re_apply_self {A : Matrix n n α} (h : A.is_hermitian) (i : n) : (re (A i i) : α) = A i i := by\n  rw [← conj_eq_iff_re, ← star_def, ← conj_transpose_apply, h.eq]\n#align is_hermitian.coe_re_apply_self is_hermitian.coe_re_apply_self\n\n",
 "apply":
 "theorem is_hermitian.apply {A : Matrix n n α} (h : A.is_hermitian) (i j : n) : star (A j i) = A i j :=\n  congr_fun (congr_fun h _) _\n#align is_hermitian.apply is_hermitian.apply\n\n",
 "adjugate":
 "theorem is_hermitian.adjugate [Fintype m] [DecidableEq m] {A : Matrix m m α} (hA : A.is_hermitian) :\n    A.adjugate.is_hermitian := by simp [is_hermitian, adjugate_conj_transpose, hA.eq]\n#align is_hermitian.adjugate is_hermitian.adjugate\n\n",
 "add":
 "@[simp]\ntheorem is_hermitian.add {A B : Matrix n n α} (hA : A.is_hermitian) (hB : B.is_hermitian) : (A + B).is_hermitian :=\n  IsSelfAdjoint.add hA hB\n#align is_hermitian.add is_hermitian.add\n\n"}