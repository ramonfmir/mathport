{"transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem is_hermitian.transpose {A : matrix n n α} (h : A.is_hermitian) : (matrix.transpose A).is_hermitian :=\n  by\n  rw [is_hermitian, conj_transpose, transpose_map]\n  congr\n  exact h\n#align is_hermitian.transpose is_hermitian.transpose\n\n",
 "submatrix":
 "@[simp]\ntheorem is_hermitian.submatrix {A : matrix n n α} (h : A.is_hermitian) (f : m → n) : (A.submatrix f f).is_hermitian :=\n  (conj_transpose_submatrix _ _ _).trans (h.symm ▸ rfl)\n#align is_hermitian.submatrix is_hermitian.submatrix\n\n",
 "sub":
 "@[simp]\ntheorem is_hermitian.sub {A B : matrix n n α} (hA : A.is_hermitian) (hB : B.is_hermitian) : (A - B).is_hermitian :=\n  (conj_transpose_sub _ _).trans (hA.symm ▸ hB.symm ▸ rfl)\n#align is_hermitian.sub is_hermitian.sub\n\n",
 "neg":
 "@[simp]\ntheorem is_hermitian.neg {A : matrix n n α} (h : A.is_hermitian) : (-A).is_hermitian :=\n  (conj_transpose_neg _).trans (congr_arg _ h)\n#align is_hermitian.neg is_hermitian.neg\n\n",
 "map":
 "@[simp]\ntheorem is_hermitian.map {A : matrix n n α} (h : A.is_hermitian) (f : α → β) (hf : function.semiconj f star star) :\n    (A.map f).is_hermitian :=\n  (conj_transpose_map f hf).symm.trans <| h.eq.symm ▸ rfl\n#align is_hermitian.map is_hermitian.map\n\n",
 "is_hermitian_zero":
 "@[simp]\ntheorem is_hermitian_zero : (0 : matrix n n α).is_hermitian :=\n  conj_transpose_zero\n#align is_hermitian_zero is_hermitian_zero\n\n",
 "is_hermitian_transpose_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_transpose_mul_self [fintype n] (A : matrix n n α) :\n    (matrix.mul (matrix.conj_transpose A) A).is_hermitian := by\n  rw [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose]\n#align is_hermitian_transpose_mul_self is_hermitian_transpose_mul_self\n\n",
 "is_hermitian_transpose_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem is_hermitian_transpose_iff (A : matrix n n α) : (matrix.transpose A).is_hermitian ↔ A.is_hermitian :=\n  ⟨by\n    intro h\n    rw [← transpose_transpose A]\n    exact is_hermitian.transpose h, is_hermitian.transpose⟩\n#align is_hermitian_transpose_iff is_hermitian_transpose_iff\n\n",
 "is_hermitian_transpose_add_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_transpose_add_self (A : matrix n n α) : (matrix.conj_transpose A + A).is_hermitian := by\n  simp [is_hermitian, add_comm]\n#align is_hermitian_transpose_add_self is_hermitian_transpose_add_self\n\n",
 "is_hermitian_submatrix_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem is_hermitian_submatrix_equiv {A : matrix n n α} (e : «expr ≃ » m n) :\n    (A.submatrix e e).is_hermitian ↔ A.is_hermitian :=\n  ⟨fun h => by simpa using h.submatrix e.symm, fun h => h.submatrix _⟩\n#align is_hermitian_submatrix_equiv is_hermitian_submatrix_equiv\n\n",
 "is_hermitian_one":
 "@[simp]\ntheorem is_hermitian_one [decidable_eq n] : (1 : matrix n n α).is_hermitian :=\n  conj_transpose_one\n#align is_hermitian_one is_hermitian_one\n\n",
 "is_hermitian_mul_mul_conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_mul_mul_conj_transpose [fintype m] {A : matrix m m α} (B : matrix n m α) (hA : A.is_hermitian) :\n    (matrix.mul (matrix.mul B A) (matrix.conj_transpose B)).is_hermitian := by\n  simp only [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose, hA.eq, matrix.mul_assoc]\n#align is_hermitian_mul_mul_conj_transpose is_hermitian_mul_mul_conj_transpose\n\n",
 "is_hermitian_mul_conj_transpose_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_mul_conj_transpose_self [fintype n] (A : matrix n n α) :\n    (matrix.mul A (matrix.conj_transpose A)).is_hermitian := by\n  rw [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose]\n#align is_hermitian_mul_conj_transpose_self is_hermitian_mul_conj_transpose_self\n\n",
 "is_hermitian_inv":
 "@[simp]\ntheorem is_hermitian_inv [fintype m] [decidable_eq m] (A : matrix m m α) [Invertible A] :\n    A⁻¹.is_hermitian ↔ A.is_hermitian :=\n  ⟨fun h => by\n    rw [← inv_inv_of_invertible A]\n    exact is_hermitian.inv h, is_hermitian.inv⟩\n#align is_hermitian_inv is_hermitian_inv\n\n",
 "is_hermitian_iff_is_symmetric":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- A matrix is hermitian iff the corresponding linear map is self adjoint. -/\ntheorem is_hermitian_iff_is_symmetric [fintype n] [decidable_eq n] {A : matrix n n α} :\n    is_hermitian A ↔\n      linear_map.is_symmetric\n        ((pi_Lp.linear_equiv 2 α fun _ : n => α).symm.conj A.to_lin' : module.End α (pi_Lp 2 _)) :=\n  by\n  rw [linear_map.is_symmetric, (pi_Lp.equiv 2 fun _ : n => α).symm.surjective.forall₂]\n  simp only [linear_equiv.conj_apply, linear_map.comp_apply, linear_equiv.coe_coe, pi_Lp.linear_equiv_apply,\n    pi_Lp.linear_equiv_symm_apply, linear_equiv.symm_symm]\n  simp_rw [euclidean_space.inner_eq_star_dot_product, equiv.apply_symm_apply, to_lin'_apply, star_mul_vec,\n    dot_product_mul_vec]\n  constructor\n  · rintro (h : matrix.conj_transpose A = A) x y\n    rw [h]\n  · intro h\n    ext (i j)\n    simpa only [(Pi.single_star i 1).symm, ← star_mul_vec, mul_one, dot_product_single, single_vec_mul, star_one,\n      one_mul] using\n      h (@Pi.single _ _ _ (fun i => add_zero_class.to_has_zero α) i 1)\n        (@Pi.single _ _ _ (fun i => add_zero_class.to_has_zero α) j 1)\n#align is_hermitian_iff_is_symmetric is_hermitian_iff_is_symmetric\n\n",
 "is_hermitian_from_blocks_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- This is the `iff` version of `matrix.is_hermitian.from_blocks`. -/\ntheorem is_hermitian_from_blocks_iff {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α} :\n    (A.from_blocks B C D).is_hermitian ↔\n      A.is_hermitian ∧ matrix.conj_transpose B = C ∧ matrix.conj_transpose C = B ∧ D.is_hermitian :=\n  ⟨fun h => ⟨congr_arg to_blocks₁₁ h, congr_arg to_blocks₂₁ h, congr_arg to_blocks₁₂ h, congr_arg to_blocks₂₂ h⟩,\n    fun ⟨hA, hBC, hCB, hD⟩ => is_hermitian.from_blocks hA hBC hD⟩\n#align is_hermitian_from_blocks_iff is_hermitian_from_blocks_iff\n\n",
 "is_hermitian_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/-- The real diagonal matrix `diagonal v` is hermitian. -/\n@[simp]\ntheorem is_hermitian_diagonal [decidable_eq n] (v : n → exprℝ) : (diagonal v).is_hermitian :=\n  diagonal_conj_transpose _\n#align is_hermitian_diagonal is_hermitian_diagonal\n\n",
 "is_hermitian_conj_transpose_mul_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_conj_transpose_mul_mul [fintype m] {A : matrix m m α} (B : matrix m n α) (hA : A.is_hermitian) :\n    (matrix.mul (matrix.mul (matrix.conj_transpose B) A) B).is_hermitian := by\n  simp only [is_hermitian, conj_transpose_mul, conj_transpose_conj_transpose, hA.eq, matrix.mul_assoc]\n#align is_hermitian_conj_transpose_mul_mul is_hermitian_conj_transpose_mul_mul\n\n",
 "is_hermitian_conj_transpose_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n@[simp]\ntheorem is_hermitian_conj_transpose_iff (A : matrix n n α) : (matrix.conj_transpose A).is_hermitian ↔ A.is_hermitian :=\n  ⟨by\n    intro h\n    rw [← conj_transpose_conj_transpose A]\n    exact is_hermitian.conj_transpose h, is_hermitian.conj_transpose⟩\n#align is_hermitian_conj_transpose_iff is_hermitian_conj_transpose_iff\n\n",
 "is_hermitian_add_transpose_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian_add_transpose_self (A : matrix n n α) : (A + matrix.conj_transpose A).is_hermitian := by\n  simp [is_hermitian, add_comm]\n#align is_hermitian_add_transpose_self is_hermitian_add_transpose_self\n\n",
 "inv":
 "theorem is_hermitian.inv [fintype m] [decidable_eq m] {A : matrix m m α} (hA : A.is_hermitian) : A⁻¹.is_hermitian := by\n  simp [is_hermitian, conj_transpose_nonsing_inv, hA.eq]\n#align is_hermitian.inv is_hermitian.inv\n\n",
 "from_blocks":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- A block matrix `A.from_blocks B C D` is hermitian,\n    if `A` and `D` are hermitian and `Bᴴ = C`. -/\ntheorem is_hermitian.from_blocks {A : matrix m m α} {B : matrix m n α} {C : matrix n m α} {D : matrix n n α}\n    (hA : A.is_hermitian) (hBC : matrix.conj_transpose B = C) (hD : D.is_hermitian) :\n    (A.from_blocks B C D).is_hermitian :=\n  by\n  have hCB : matrix.conj_transpose C = B := by\n    rw [← hBC]\n    simp\n  unfold matrix.is_hermitian\n  rw [from_blocks_conj_transpose]\n  congr <;> assumption\n#align is_hermitian.from_blocks is_hermitian.from_blocks\n\n",
 "ext_iff":
 "theorem is_hermitian.ext_iff {A : matrix n n α} : A.is_hermitian ↔ ∀ i j, star (A j i) = A i j :=\n  ⟨is_hermitian.apply, is_hermitian.ext⟩\n#align is_hermitian.ext_iff is_hermitian.ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem is_hermitian.ext {A : matrix n n α} : (∀ i j, star (A j i) = A i j) → A.is_hermitian :=\n  by\n  intro h\n  ext (i j)\n  exact h i j\n#align is_hermitian.ext is_hermitian.ext\n\n",
 "eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-\nCopyright (c) 2022 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp\n-/\ntheorem is_hermitian.eq {A : matrix n n α} (h : A.is_hermitian) : matrix.conj_transpose A = A :=\n  h\n#align is_hermitian.eq is_hermitian.eq\n\n",
 "conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem is_hermitian.conj_transpose {A : matrix n n α} (h : A.is_hermitian) : (matrix.conj_transpose A).is_hermitian :=\n  h.transpose.map _ fun _ => rfl\n#align is_hermitian.conj_transpose is_hermitian.conj_transpose\n\n",
 "coe_re_diag":
 "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem is_hermitian.coe_re_diag {A : matrix n n α} (h : A.is_hermitian) : (fun i => (re (A.diag i) : α)) = A.diag :=\n  funext h.coe_re_apply_self\n#align is_hermitian.coe_re_diag is_hermitian.coe_re_diag\n\n",
 "coe_re_apply_self":
 "/-- The diagonal elements of a complex hermitian matrix are real. -/\ntheorem is_hermitian.coe_re_apply_self {A : matrix n n α} (h : A.is_hermitian) (i : n) : (re (A i i) : α) = A i i := by\n  rw [← eq_conj_iff_re, ← star_def, ← conj_transpose_apply, h.eq]\n#align is_hermitian.coe_re_apply_self is_hermitian.coe_re_apply_self\n\n",
 "apply":
 "theorem is_hermitian.apply {A : matrix n n α} (h : A.is_hermitian) (i j : n) : star (A j i) = A i j :=\n  by\n  unfold is_hermitian at h\n  rw [← h, conj_transpose_apply, star_star, h]\n#align is_hermitian.apply is_hermitian.apply\n\n",
 "adjugate":
 "theorem is_hermitian.adjugate [fintype m] [decidable_eq m] {A : matrix m m α} (hA : A.is_hermitian) :\n    A.adjugate.is_hermitian := by simp [is_hermitian, adjugate_conj_transpose, hA.eq]\n#align is_hermitian.adjugate is_hermitian.adjugate\n\n",
 "add":
 "@[simp]\ntheorem is_hermitian.add {A B : matrix n n α} (hA : A.is_hermitian) (hB : B.is_hermitian) : (A + B).is_hermitian :=\n  (conj_transpose_add _ _).trans (hA.symm ▸ hB.symm ▸ rfl)\n#align is_hermitian.add is_hermitian.add\n\n"}