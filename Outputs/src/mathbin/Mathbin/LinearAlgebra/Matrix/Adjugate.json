{"sum_cramer_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Use linearity of `cramer` and vector evaluation to take `cramer A _ i` out of a summation. -/\ntheorem sum_cramer_apply {β} (s : Finset β) (f : n → β → α) (i : n) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (cramer A (fun j => f j x) i) =\n      cramer A\n        (fun j : n =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f j x))\n        i :=\n  calc\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (cramer A (fun j => f j x) i) =\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n            (cramer A fun j => f j x))\n          i :=\n      (Finset.sum_apply i s _).symm\n    _ =\n        cramer A\n          (fun j : n =>\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f j x))\n          i :=\n      by\n      rw [sum_cramer, cramer_apply]\n      congr with j\n      apply Finset.sum_apply\n    \n#align sum_cramer_apply sum_cramer_apply\n\n",
 "sum_cramer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Use linearity of `cramer` to take it out of a summation. -/\ntheorem sum_cramer {β} (s : Finset β) (f : β → n → α) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (cramer A (f x)) =\n      cramer A\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f x)) :=\n  (LinearMap.map_sum (cramer A)).symm\n#align sum_cramer sum_cramer\n\n",
 "mul_vec_cramer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A stronger form of **Cramer's rule** that allows us to solve some instances of `A ⬝ x = b` even\nif the determinant is not a unit. A sufficient (but still not necessary) condition is that `A.det`\ndivides `b`. -/\n@[simp]\ntheorem mul_vec_cramer (A : Matrix n n α) (b : n → α) : A.mul_vec (cramer A b) = «expr • » A.det b := by\n  rw [cramer_eq_adjugate_mul_vec, mul_vec_mul_vec, mul_adjugate, smul_mul_vec_assoc, one_mul_vec]\n#align mul_vec_cramer mul_vec_cramer\n\n",
 "mul_adjugate_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem mul_adjugate_apply (A : Matrix n n α) (i j k) :\n    A i k * adjugate A k j = cramer (matrix.transpose A) (Pi.single k (A i k)) j := by\n  erw [← smul_eq_mul, ← Pi.smul_apply, ← LinearMap.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]\n#align mul_adjugate_apply mul_adjugate_apply\n\n",
 "mul_adjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mul_adjugate (A : Matrix n n α) : matrix.mul A (adjugate A) = «expr • » A.det 1 :=\n  by\n  ext (i j)\n  rw [mul_apply, Pi.smul_apply, Pi.smul_apply, one_apply, smul_eq_mul, mul_boole]\n  simp [mul_adjugate_apply, sum_cramer_apply, cramer_transpose_row_self, Pi.single_apply, eq_comm]\n#align mul_adjugate mul_adjugate\n\n",
 "map_adjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print AlgHom.map_adjugate /-\ntheorem AlgHom.map_adjugate {R A B : Type _} [CommSemiring R] [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]\n    (f : «expr →ₐ[ ] » A R B) (M : Matrix n n A) : f.map_matrix M.adjugate = Matrix.adjugate (f.map_matrix M) :=\n  f.to_ring_hom.map_adjugate _\n#align alg_hom.map_adjugate AlgHom.map_adjugate\n-/\n\n",
 "is_regular_of_is_left_regular_det":
 "theorem is_regular_of_is_left_regular_det {A : Matrix n n α} (hA : IsLeftRegular A.det) : IsRegular A :=\n  by\n  constructor\n  · intro B C h\n    refine' hA.matrix _\n    rw [← Matrix.one_mul B, ← Matrix.one_mul C, ← Matrix.smul_mul, ← Matrix.smul_mul, ← adjugate_mul, Matrix.mul_assoc,\n      Matrix.mul_assoc, ← mul_eq_mul A, h, mul_eq_mul]\n  · intro B C h\n    simp only [mul_eq_mul] at h\n    refine' hA.matrix _\n    rw [← Matrix.mul_one B, ← Matrix.mul_one C, ← Matrix.mul_smul, ← Matrix.mul_smul, ← mul_adjugate, ←\n      Matrix.mul_assoc, ← Matrix.mul_assoc, h]\n#align is_regular_of_is_left_regular_det is_regular_of_is_left_regular_det\n\n",
 "det_smul_adjugate_adjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem det_smul_adjugate_adjugate (A : Matrix n n α) :\n    «expr • » (det A) (adjugate (adjugate A)) = «expr • » (det A ^ (Fintype.card n - 1)) A :=\n  by\n  have :\n    matrix.mul A (matrix.mul A.adjugate A.adjugate.adjugate) =\n      matrix.mul A («expr • » (A.det ^ (Fintype.card n - 1)) 1) :=\n    by rw [← adjugate_mul_distrib, adjugate_mul, adjugate_smul, adjugate_one]\n  rwa [← Matrix.mul_assoc, mul_adjugate, Matrix.mul_smul, Matrix.mul_one, Matrix.smul_mul, Matrix.one_mul] at this\n#align det_smul_adjugate_adjugate det_smul_adjugate_adjugate\n\n",
 "det_adjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_adjugate (A : Matrix n n α) : (adjugate A).det = A.det ^ (Fintype.card n - 1) :=\n  by\n  -- get rid of the `- 1`\n  cases' (Fintype.card n).eq_zero_or_pos with h_card h_card\n  · haveI : IsEmpty n := fintype.card_eq_zero_iff.mp h_card\n    rw [h_card, nat.zero_sub, pow_zero, adjugate_subsingleton, det_one]\n  replace h_card := tsub_add_cancel_of_le h_card.nat_succ_le\n  -- express `A` as an evaluation of a polynomial in n^2 variables, and solve in the polynomial ring\n  -- where `A'.det` is non-zero.\n  let A' := mv_polynomial_X n n ℤ\n  suffices A'.adjugate.det = A'.det ^ (Fintype.card n - 1) by\n    rw [← mv_polynomial_X_map_matrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_det, ← AlgHom.map_det, ←\n      AlgHom.map_pow, this]\n  apply mul_left_cancel₀ (show A'.det ≠ 0 from det_mv_polynomial_X_ne_zero n ℤ)\n  calc\n    A'.det * A'.adjugate.det = (matrix.mul A' (adjugate A')).det := (det_mul _ _).symm\n    _ = A'.det ^ Fintype.card n := by rw [mul_adjugate, det_smul, det_one, mul_one]\n    _ = A'.det * A'.det ^ (Fintype.card n - 1) := by rw [← pow_succ, h_card]\n    \n#align det_adjugate det_adjugate\n\n",
 "cramer_zero":
 "theorem cramer_zero [Nontrivial n] : cramer (0 : Matrix n n α) = 0 :=\n  by\n  ext (i j)\n  obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j\n  apply det_eq_zero_of_column_eq_zero j'\n  intro j''\n  simp [update_column_ne hj']\n#align cramer_zero cramer_zero\n\n",
 "cramer_transpose_row_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem cramer_transpose_row_self (i : n) : (matrix.transpose A).cramer (A i) = Pi.single i A.det :=\n  by\n  ext j\n  rw [cramer_apply, Pi.single_apply]\n  split_ifs with h\n  · -- i = j: this entry should be `A.det`\n    subst h\n    simp only [update_column_transpose, det_transpose, update_row_eq_self]\n  · -- i ≠ j: this entry should be 0\n    rw [update_column_transpose, det_transpose]\n    apply det_zero_of_row_eq h\n    rw [update_row_self, update_row_ne (ne.symm h)]\n#align cramer_transpose_row_self cramer_transpose_row_self\n\n",
 "cramer_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem cramer_transpose_apply (i : n) : cramer (matrix.transpose A) b i = (A.update_row i b).det := by\n  rw [cramer_apply, update_column_transpose, det_transpose]\n#align cramer_transpose_apply cramer_transpose_apply\n\n",
 "cramer_subsingleton_apply":
 "@[simp]\ntheorem cramer_subsingleton_apply [subsingleton n] (A : Matrix n n α) (b : n → α) (i : n) : cramer A b i = b i := by\n  rw [cramer_apply, det_eq_elem_of_subsingleton _ i, update_column_self]\n#align cramer_subsingleton_apply cramer_subsingleton_apply\n\n",
 "cramer_submatrix_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem cramer_submatrix_equiv (A : Matrix m m α) (e : «expr ≃ » n m) (b : n → α) :\n    cramer (A.submatrix e e) b = cramer A (b ∘ e.symm) ∘ e :=\n  by\n  ext i\n  simp_rw [Function.comp_apply, cramer_apply, update_column_submatrix_equiv, det_submatrix_equiv_self e]\n#align cramer_submatrix_equiv cramer_submatrix_equiv\n\n",
 "cramer_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem cramer_smul (r : α) (A : Matrix n n α) :\n    cramer («expr • » r A) = «expr • » (r ^ (Fintype.card n - 1)) (cramer A) :=\n  LinearMap.ext fun b => funext fun _ => det_updateColumn_smul' _ _ _ _\n#align cramer_smul cramer_smul\n\n",
 "cramer_row_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem cramer_row_self (i : n) (h : ∀ j, b j = A j i) : A.cramer b = Pi.single i A.det :=\n  by\n  rw [← transpose_transpose A, det_transpose]\n  convert cramer_transpose_row_self (matrix.transpose A) i\n  exact funext h\n#align cramer_row_self cramer_row_self\n\n",
 "cramer_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem cramer_reindex (e : «expr ≃ » m n) (A : Matrix m m α) (b : n → α) :\n    cramer (reindex e e A) b = cramer A (b ∘ e) ∘ e.symm :=\n  cramer_submatrix_equiv _ _ _\n#align cramer_reindex cramer_reindex\n\n",
 "cramer_one":
 "@[simp]\ntheorem cramer_one : cramer (1 : Matrix n n α) = 1 := by\n  ext (i j)\n  convert congr_fun (cramer_row_self (1 : Matrix n n α) (Pi.single i 1) i _) j\n  · simp\n  · intro j\n    rw [Matrix.one_eq_pi_single, Pi.single_comm]\n#align cramer_one cramer_one\n\n",
 "cramer_map_is_linear":
 "/-\nCopyright (c) 2019 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem cramer_map_is_linear (i : n) : IsLinearMap α fun b => cramerMap A b i :=\n  { map_add := det_updateColumn_add _ _\n    map_smul := det_updateColumn_smul _ _ }\n#align cramer_map_is_linear cramer_map_is_linear\n\n",
 "cramer_is_linear":
 "theorem cramer_is_linear : IsLinearMap α (cramerMap A) :=\n  by\n  constructor <;> intros <;> ext i\n  · apply (cramer_map_is_linear A i).1\n  · apply (cramer_map_is_linear A i).2\n#align cramer_is_linear cramer_is_linear\n\n",
 "cramer_eq_adjugate_mul_vec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Since the map `b ↦ cramer A b` is linear in `b`, it must be multiplication by some matrix. This\nmatrix is `A.adjugate`. -/\ntheorem cramer_eq_adjugate_mul_vec (A : Matrix n n α) (b : n → α) : cramer A b = A.adjugate.mul_vec b :=\n  by\n  nth_rw 2 [← A.transpose_transpose]\n  rw [← adjugate_transpose, adjugate_def]\n  have :\n    b =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b i) (Pi.single i 1)) :=\n    by\n    refine' (pi_eq_sum_univ b).trans _\n    congr with j\n    simp [Pi.single_apply, eq_comm]\n  nth_rw 1 [this]\n  ext k\n  simp [mul_vec, dot_product, mul_comm]\n#align cramer_eq_adjugate_mul_vec cramer_eq_adjugate_mul_vec\n\n",
 "cramer_apply":
 "theorem cramer_apply (i : n) : cramer A b i = (A.update_column i b).det :=\n  rfl\n#align cramer_apply cramer_apply\n\n",
 "adjugate_zero":
 "@[simp]\ntheorem adjugate_zero [Nontrivial n] : adjugate (0 : Matrix n n α) = 0 :=\n  by\n  ext (i j)\n  obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j\n  apply det_eq_zero_of_column_eq_zero j'\n  intro j''\n  simp [update_column_ne hj']\n#align adjugate_zero adjugate_zero\n\n",
 "adjugate_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem adjugate_transpose (A : Matrix n n α) : matrix.transpose (adjugate A) = adjugate (matrix.transpose A) :=\n  by\n  ext (i j)\n  rw [transpose_apply, adjugate_apply, adjugate_apply, update_row_transpose, det_transpose]\n  rw [det_apply', det_apply']\n  apply Finset.sum_congr rfl\n  intro σ _\n  congr 1\n  by_cases i = σ j\n  · -- Everything except `(i , j)` (= `(σ j , j)`) is given by A, and the rest is a single `1`.\n      congr <;> ext j'\n    subst h\n    have : σ j' = σ j ↔ j' = j := σ.injective.eq_iff\n    rw [update_row_apply, update_column_apply]\n    simp_rw [this]\n    rw [← dite_eq_ite, ← dite_eq_ite]\n    congr 1 with rfl\n    rw [Pi.single_eq_same, Pi.single_eq_same]\n  · -- Otherwise, we need to show that there is a `0` somewhere in the product.\n    have :\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (update_column A j (Pi.single i 1) (σ j') j') =\n        0 :=\n      by\n      apply prod_eq_zero (mem_univ j)\n      rw [update_column_self, Pi.single_eq_of_ne' h]\n    rw [this]\n    apply prod_eq_zero (mem_univ (σ⁻¹ i))\n    erw [apply_symm_apply σ i, update_row_self]\n    apply Pi.single_eq_of_ne\n    intro h'\n    exact h ((symm_apply_eq σ).mp h')\n#align adjugate_transpose adjugate_transpose\n\n",
 "adjugate_subsingleton":
 "theorem adjugate_subsingleton [subsingleton n] (A : Matrix n n α) : adjugate A = 1 :=\n  by\n  ext (i j)\n  simp [subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i]\n#align adjugate_subsingleton adjugate_subsingleton\n\n",
 "adjugate_submatrix_equiv_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem adjugate_submatrix_equiv_self (e : «expr ≃ » n m) (A : Matrix m m α) :\n    adjugate (A.submatrix e e) = (adjugate A).submatrix e e :=\n  by\n  ext (i j)\n  rw [adjugate_apply, submatrix_apply, adjugate_apply, ← det_submatrix_equiv_self e, update_row_submatrix_equiv]\n  congr\n  exact Function.update_comp_equiv _ e.symm _ _\n#align adjugate_submatrix_equiv_self adjugate_submatrix_equiv_self\n\n",
 "adjugate_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem adjugate_smul (r : α) (A : Matrix n n α) :\n    adjugate («expr • » r A) = «expr • » (r ^ (Fintype.card n - 1)) (adjugate A) :=\n  by\n  rw [adjugate, adjugate, transpose_smul, cramer_smul]\n  rfl\n#align adjugate_smul adjugate_smul\n\n",
 "adjugate_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem adjugate_reindex (e : «expr ≃ » m n) (A : Matrix m m α) : adjugate (reindex e e A) = reindex e e (adjugate A) :=\n  adjugate_submatrix_equiv_self _ _\n#align adjugate_reindex adjugate_reindex\n\n",
 "adjugate_pow":
 "@[simp]\ntheorem adjugate_pow (A : Matrix n n α) (k : ℕ) : adjugate (A ^ k) = adjugate A ^ k :=\n  by\n  induction' k with k IH\n  · simp\n  · rw [pow_succ', mul_eq_mul, adjugate_mul_distrib, IH, ← mul_eq_mul, pow_succ]\n#align adjugate_pow adjugate_pow\n\n",
 "adjugate_one":
 "@[simp]\ntheorem adjugate_one : adjugate (1 : Matrix n n α) = 1 := by\n  ext\n  simp [adjugate_def, Matrix.one_apply, Pi.single_apply, eq_comm]\n#align adjugate_one adjugate_one\n\n",
 "adjugate_mul_distrib_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem adjugate_mul_distrib_aux (A B : Matrix n n α) (hA : IsLeftRegular A.det) (hB : IsLeftRegular B.det) :\n    adjugate (matrix.mul A B) = matrix.mul (adjugate B) (adjugate A) :=\n  by\n  have hAB : IsLeftRegular (matrix.mul A B).det := by\n    rw [det_mul]\n    exact hA.mul hB\n  refine' (is_regular_of_is_left_regular_det hAB).left _\n  rw [mul_eq_mul, mul_adjugate, mul_eq_mul, Matrix.mul_assoc, ← Matrix.mul_assoc B, mul_adjugate, smul_mul,\n    Matrix.one_mul, mul_smul, mul_adjugate, smul_smul, mul_comm, ← det_mul]\n#align adjugate_mul_distrib_aux adjugate_mul_distrib_aux\n\n",
 "adjugate_mul_distrib":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Proof follows from \"The trace Cayley-Hamilton theorem\" by Darij Grinberg, Section 5.3\n-/\ntheorem adjugate_mul_distrib (A B : Matrix n n α) : adjugate (matrix.mul A B) = matrix.mul (adjugate B) (adjugate A) :=\n  by\n  let g : Matrix n n α → Matrix n n (polynomial α) := fun M =>\n    M.map Polynomial.C + «expr • » (Polynomial.X : polynomial α) 1\n  let f' : «expr →+* » (Matrix n n (polynomial α)) (Matrix n n α) := (Polynomial.evalRingHom 0).map_matrix\n  have f'_inv : ∀ M, f' (g M) = M := by\n    intro\n    ext\n    simp [f', g]\n  have f'_adj : ∀ M : Matrix n n α, f' (adjugate (g M)) = adjugate M :=\n    by\n    intro\n    rw [RingHom.map_adjugate, f'_inv]\n  have f'_g_mul : ∀ M N : Matrix n n α, f' (matrix.mul (g M) (g N)) = matrix.mul M N :=\n    by\n    intros\n    rw [← mul_eq_mul, RingHom.map_mul, f'_inv, f'_inv, mul_eq_mul]\n  have hu : ∀ M : Matrix n n α, IsRegular (g M).det := by\n    intro M\n    refine' Polynomial.Monic.isRegular _\n    simp only [g, Polynomial.Monic.def, ← Polynomial.leadingCoeff_det_X_one_add_C M, add_comm]\n  rw [← f'_adj, ← f'_adj, ← f'_adj, ← mul_eq_mul (f' (adjugate (g B))), ← f'.map_mul, mul_eq_mul, ←\n    adjugate_mul_distrib_aux _ _ (hu A).left (hu B).left, RingHom.map_adjugate, RingHom.map_adjugate, f'_inv, f'_g_mul]\n#align adjugate_mul_distrib adjugate_mul_distrib\n\n",
 "adjugate_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem adjugate_mul (A : Matrix n n α) : matrix.mul (adjugate A) A = «expr • » A.det 1 :=\n  calc\n    matrix.mul (adjugate A) A = matrix.transpose (matrix.mul (matrix.transpose A) (adjugate (matrix.transpose A))) := by\n      rw [← adjugate_transpose, ← transpose_mul, transpose_transpose]\n    _ = «expr • » A.det 1 := by rw [mul_adjugate (matrix.transpose A), det_transpose, transpose_smul, transpose_one]\n    \n#align adjugate_mul adjugate_mul\n\n",
 "adjugate_fin_zero":
 "@[simp]\ntheorem adjugate_fin_zero (A : Matrix (Fin 0) (Fin 0) α) : adjugate A = 0 :=\n  subsingleton.elim _ _\n#align adjugate_fin_zero adjugate_fin_zero\n\n",
 "adjugate_fin_two_of":
 "@[simp]\ntheorem adjugate_fin_two_of (a b c d : α) : adjugate !![a, b; c, d] = !![d, -b; -c, a] :=\n  adjugate_fin_two _\n#align adjugate_fin_two_of adjugate_fin_two_of\n\n",
 "adjugate_fin_two":
 "theorem adjugate_fin_two (A : Matrix (Fin 2) (Fin 2) α) : adjugate A = !![A 1 1, -A 0 1; -A 1 0, A 0 0] :=\n  by\n  ext (i j)\n  rw [adjugate_apply, det_fin_two]\n  fin_cases i <;> fin_cases j <;>\n    simp only [one_mul, Fin.one_eq_zero_iff, Pi.single_eq_same, MulZeroClass.mul_zero, sub_zero, Pi.single_eq_of_ne,\n      ne.def, not_false_iff, update_row_self, update_row_ne, cons_val_zero, of_apply, Nat.succ_succ_ne_one,\n      Pi.single_eq_of_ne, update_row_self, Pi.single_eq_of_ne, ne.def, Fin.zero_eq_one_iff, Nat.succ_succ_ne_one,\n      not_false_iff, update_row_ne, Fin.one_eq_zero_iff, MulZeroClass.zero_mul, Pi.single_eq_same, one_mul, zero_sub,\n      of_apply, cons_val', cons_val_fin_one, cons_val_one, head_fin_const, neg_inj, eq_self_iff_true, cons_val_zero,\n      head_cons, mul_one]\n#align adjugate_fin_two adjugate_fin_two\n\n",
 "adjugate_fin_one":
 "@[simp]\ntheorem adjugate_fin_one (A : Matrix (Fin 1) (Fin 1) α) : adjugate A = 1 :=\n  adjugate_subsingleton A\n#align adjugate_fin_one adjugate_fin_one\n\n",
 "adjugate_eq_one_of_card_eq_one":
 "theorem adjugate_eq_one_of_card_eq_one {A : Matrix n n α} (h : Fintype.card n = 1) : adjugate A = 1 :=\n  haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le\n  adjugate_subsingleton _\n#align adjugate_eq_one_of_card_eq_one adjugate_eq_one_of_card_eq_one\n\n",
 "adjugate_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n@[simp]\ntheorem adjugate_diagonal (v : n → α) :\n    adjugate (diagonal v) =\n      diagonal fun i =>\n        finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (Finset.univ.erase i) (v j) :=\n  by\n  ext\n  simp only [adjugate_def, cramer_apply, diagonal_transpose, of_apply]\n  obtain rfl | hij := eq_or_ne i j\n  ·\n    rw [diagonal_apply_eq, diagonal_update_column_single, det_diagonal, prod_update_of_mem (Finset.mem_univ _),\n      sdiff_singleton_eq_erase, one_mul]\n  · rw [diagonal_apply_ne _ hij]\n    refine' det_eq_zero_of_row_eq_zero j fun k => _\n    obtain rfl | hjk := eq_or_ne k j\n    · rw [update_column_self, Pi.single_eq_of_ne' hij]\n    · rw [update_column_ne hjk, diagonal_apply_ne' _ hjk]\n#align adjugate_diagonal adjugate_diagonal\n\n",
 "adjugate_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem adjugate_def (A : Matrix n n α) : adjugate A = of fun i => cramer (matrix.transpose A) (Pi.single i 1) :=\n  rfl\n#align adjugate_def adjugate_def\n\n",
 "adjugate_conj_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem adjugate_conj_transpose [StarRing α] (A : Matrix n n α) :\n    matrix.conj_transpose A.adjugate = adjugate (matrix.conj_transpose A) :=\n  by\n  dsimp only [conj_transpose]\n  have : (matrix.transpose A).adjugate.map star = adjugate ((matrix.transpose A).map star) :=\n    (starRingEnd α).map_adjugate (matrix.transpose A)\n  rw [A.adjugate_transpose, this]\n#align adjugate_conj_transpose adjugate_conj_transpose\n\n",
 "adjugate_apply":
 "theorem adjugate_apply (A : Matrix n n α) (i j : n) : adjugate A i j = (A.update_row j (Pi.single i 1)).det := by\n  rw [adjugate_def, of_apply, cramer_apply, update_column_transpose, det_transpose]\n#align adjugate_apply adjugate_apply\n\n",
 "adjugate_adjugate'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A weaker version of `matrix.adjugate_adjugate` that uses `nontrivial`. -/\ntheorem adjugate_adjugate' (A : Matrix n n α) [Nontrivial n] :\n    adjugate (adjugate A) = «expr • » (det A ^ (Fintype.card n - 2)) A :=\n  adjugate_adjugate _ <| Fintype.one_lt_card.ne'\n#align adjugate_adjugate' adjugate_adjugate'\n\n",
 "adjugate_adjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Note that this is not true for `fintype.card n = 1` since `1 - 2 = 0` and not `-1`. -/\ntheorem adjugate_adjugate (A : Matrix n n α) (h : Fintype.card n ≠ 1) :\n    adjugate (adjugate A) = «expr • » (det A ^ (Fintype.card n - 2)) A :=\n  by\n  -- get rid of the `- 2`\n  cases' h_card : Fintype.card n with n'\n  · haveI : IsEmpty n := fintype.card_eq_zero_iff.mp h_card\n    apply subsingleton.elim\n  cases n'\n  · exact (h h_card).elim\n  rw [← h_card]\n  -- express `A` as an evaluation of a polynomial in n^2 variables, and solve in the polynomial ring\n  -- where `A'.det` is non-zero.\n  let A' := mv_polynomial_X n n ℤ\n  suffices adjugate (adjugate A') = «expr • » (det A' ^ (Fintype.card n - 2)) A' by\n    rw [← mv_polynomial_X_map_matrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_adjugate, this, ← AlgHom.map_det, ←\n      AlgHom.map_pow, alg_hom.map_matrix_apply, alg_hom.map_matrix_apply, Matrix.map_smul' _ _ _ (_root_.map_mul _)]\n  have h_card' : Fintype.card n - 2 + 1 = Fintype.card n - 1 := by simp [h_card]\n  have is_reg : IsSMulRegular (MvPolynomial (n × n) ℤ) (det A') := fun x y =>\n    mul_left_cancel₀ (det_mv_polynomial_X_ne_zero n ℤ)\n  apply is_reg.matrix\n  rw [smul_smul, ← pow_succ, h_card', det_smul_adjugate_adjugate]\n#align adjugate_adjugate adjugate_adjugate\n\n"}