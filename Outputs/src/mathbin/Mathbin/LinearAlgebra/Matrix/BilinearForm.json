{"to_matrix_to_bilin":
 "@[simp]\ntheorem bilin_form.to_matrix_to_bilin (M : matrix n n R₂) : bilin_form.to_matrix b (matrix.to_bilin b M) = M :=\n  (bilin_form.to_matrix b).apply_symm_apply M\n#align bilin_form.to_matrix_to_bilin bilin_form.to_matrix_to_bilin\n\n",
 "to_matrix_symm":
 "@[simp]\ntheorem bilin_form.to_matrix_symm : (bilin_form.to_matrix b).symm = matrix.to_bilin b :=\n  rfl\n#align bilin_form.to_matrix_symm bilin_form.to_matrix_symm\n\n",
 "to_matrix_mul_basis_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem bilin_form.to_matrix_mul_basis_to_matrix (c : basis o R₂ M₂) (B : bilin_form R₂ M₂) :\n    matrix.mul (matrix.mul (matrix.transpose (b.to_matrix c)) (bilin_form.to_matrix b B)) (b.to_matrix c) =\n      bilin_form.to_matrix c B :=\n  by rw [← linear_map.to_matrix_id_eq_basis_to_matrix, ← bilin_form.to_matrix_comp, bilin_form.comp_id_id]\n#align bilin_form.to_matrix_mul_basis_to_matrix bilin_form.to_matrix_mul_basis_to_matrix\n\n",
 "to_matrix_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem bilin_form.to_matrix_mul (B : bilin_form R₂ M₂) (M : matrix n n R₂) :\n    matrix.mul (bilin_form.to_matrix b B) M = bilin_form.to_matrix b (B.comp_right (to_lin b b M)) := by\n  rw [B.to_matrix_comp_right b, to_matrix_to_lin]\n#align bilin_form.to_matrix_mul bilin_form.to_matrix_mul\n\n",
 "to_matrix_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem bilin_form.to_matrix_comp_right (B : bilin_form R₂ M₂) (f : «expr →ₗ[ ] » M₂ R₂ M₂) :\n    bilin_form.to_matrix b (B.comp_right f) = matrix.mul (bilin_form.to_matrix b B) (to_matrix b b f) := by\n  simp only [bilin_form.comp_right, bilin_form.to_matrix_comp b b, to_matrix_id, transpose_one, matrix.one_mul]\n#align bilin_form.to_matrix_comp_right bilin_form.to_matrix_comp_right\n\n",
 "to_matrix_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem bilin_form.to_matrix_comp_left (B : bilin_form R₂ M₂) (f : «expr →ₗ[ ] » M₂ R₂ M₂) :\n    bilin_form.to_matrix b (B.comp_left f) =\n      matrix.mul (matrix.transpose (to_matrix b b f)) (bilin_form.to_matrix b B) :=\n  by simp only [comp_left, bilin_form.to_matrix_comp b b, to_matrix_id, matrix.mul_one]\n#align bilin_form.to_matrix_comp_left bilin_form.to_matrix_comp_left\n\n",
 "to_matrix_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n-- Cannot be a `simp` lemma because `b` must be inferred.\ntheorem bilin_form.to_matrix_comp (B : bilin_form R₂ M₂) (l r : «expr →ₗ[ ] » M₂' R₂ M₂) :\n    bilin_form.to_matrix c (B.comp l r) =\n      matrix.mul (matrix.mul (matrix.transpose (to_matrix c b l)) (bilin_form.to_matrix b B)) (to_matrix c b r) :=\n  by\n  ext (i j)\n  simp only [bilin_form.to_matrix_apply, bilin_form.comp_apply, transpose_apply, matrix.mul_apply,\n    linear_map.to_matrix', linear_equiv.coe_mk, sum_mul]\n  rw [sum_comm]\n  conv_lhs => rw [← bilin_form.sum_repr_mul_repr_mul b]\n  rw [finsupp.sum_fintype]\n  · apply sum_congr rfl\n    rintro i' -\n    rw [finsupp.sum_fintype]\n    · apply sum_congr rfl\n      rintro j' -\n      simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm]\n    · intros\n      simp only [zero_smul, smul_zero]\n  · intros\n    simp only [zero_smul, finsupp.sum_zero]\n#align bilin_form.to_matrix_comp bilin_form.to_matrix_comp\n\n",
 "to_matrix_basis_fun":
 "theorem bilin_form.to_matrix_basis_fun : bilin_form.to_matrix (pi.basis_fun R₂ n) = bilin_form.to_matrix' :=\n  by\n  ext B\n  rw [bilin_form.to_matrix_apply, bilin_form.to_matrix'_apply, pi.basis_fun_apply, pi.basis_fun_apply]\n#align bilin_form.to_matrix_basis_fun bilin_form.to_matrix_basis_fun\n\n",
 "to_matrix_aux_std_basis":
 "@[simp]\ntheorem bilin_form.to_matrix_aux_std_basis (B : bilin_form R₂ (n → R₂)) :\n    bilin_form.to_matrix_aux (fun j => std_basis R₂ (fun _ => R₂) j 1) B = bilin_form.to_matrix' B :=\n  rfl\n#align bilin_form.to_matrix_aux_std_basis bilin_form.to_matrix_aux_std_basis\n\n",
 "to_matrix_aux_eq":
 "-- Not a `simp` lemma since `bilin_form.to_matrix` needs an extra argument\ntheorem bilinear_form.to_matrix_aux_eq (B : bilin_form R₂ M₂) :\n    bilin_form.to_matrix_aux b B = bilin_form.to_matrix b B :=\n  ext fun i j => by rw [bilin_form.to_matrix_apply, bilin_form.to_matrix_aux_apply]\n#align bilinear_form.to_matrix_aux_eq bilinear_form.to_matrix_aux_eq\n\n",
 "to_matrix_aux_apply":
 "@[simp]\ntheorem bilin_form.to_matrix_aux_apply (B : bilin_form R₂ M₂) (b : n → M₂) (i j : n) :\n    bilin_form.to_matrix_aux b B i j = B (b i) (b j) :=\n  rfl\n#align bilin_form.to_matrix_aux_apply bilin_form.to_matrix_aux_apply\n\n",
 "to_matrix_apply":
 "@[simp]\ntheorem bilin_form.to_matrix_apply (B : bilin_form R₂ M₂) (i j : n) : bilin_form.to_matrix b B i j = B (b i) (b j) := by\n  rw [bilin_form.to_matrix, linear_equiv.trans_apply, bilin_form.to_matrix'_apply, congr_apply,\n    b.equiv_fun_symm_std_basis, b.equiv_fun_symm_std_basis]\n#align bilin_form.to_matrix_apply bilin_form.to_matrix_apply\n\n",
 "to_matrix'_to_bilin'":
 "@[simp]\ntheorem bilin_form.to_matrix'_to_bilin' (M : matrix n n R₂) : bilin_form.to_matrix' (matrix.to_bilin' M) = M :=\n  bilin_form.to_matrix'.apply_symm_apply M\n#align bilin_form.to_matrix'_to_bilin' bilin_form.to_matrix'_to_bilin'\n\n",
 "to_matrix'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem bilin_form.to_matrix'_symm :\n    (bilin_form.to_matrix'.symm : «expr ≃ₗ[ ] » (matrix n n R₂) R₂ _) = matrix.to_bilin' :=\n  rfl\n#align bilin_form.to_matrix'_symm bilin_form.to_matrix'_symm\n\n",
 "to_matrix'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem bilin_form.to_matrix'_mul (B : bilin_form R₂ (n → R₂)) (M : matrix n n R₂) :\n    matrix.mul B.to_matrix' M = (B.comp_right M.to_lin').to_matrix' := by\n  simp only [B.to_matrix'_comp_right, to_matrix'_to_lin']\n#align bilin_form.to_matrix'_mul bilin_form.to_matrix'_mul\n\n",
 "to_matrix'_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem bilin_form.to_matrix'_comp_right (B : bilin_form R₂ (n → R₂)) (f : «expr →ₗ[ ] » (n → R₂) R₂ (n → R₂)) :\n    (B.comp_right f).to_matrix' = matrix.mul B.to_matrix' f.to_matrix' := by\n  simp only [bilin_form.comp_right, bilin_form.to_matrix'_comp, to_matrix'_id, transpose_one, matrix.one_mul]\n#align bilin_form.to_matrix'_comp_right bilin_form.to_matrix'_comp_right\n\n",
 "to_matrix'_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem bilin_form.to_matrix'_comp_left (B : bilin_form R₂ (n → R₂)) (f : «expr →ₗ[ ] » (n → R₂) R₂ (n → R₂)) :\n    (B.comp_left f).to_matrix' = matrix.mul (matrix.transpose f.to_matrix') B.to_matrix' := by\n  simp only [bilin_form.comp_left, bilin_form.to_matrix'_comp, to_matrix'_id, matrix.mul_one]\n#align bilin_form.to_matrix'_comp_left bilin_form.to_matrix'_comp_left\n\n",
 "to_matrix'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n@[simp]\ntheorem bilin_form.to_matrix'_comp (B : bilin_form R₂ (n → R₂)) (l r : «expr →ₗ[ ] » (o → R₂) R₂ (n → R₂)) :\n    (B.comp l r).to_matrix' = matrix.mul (matrix.mul (matrix.transpose l.to_matrix') B.to_matrix') r.to_matrix' :=\n  by\n  ext (i j)\n  simp only [bilin_form.to_matrix'_apply, bilin_form.comp_apply, transpose_apply, matrix.mul_apply,\n    linear_map.to_matrix', linear_equiv.coe_mk, sum_mul]\n  rw [sum_comm]\n  conv_lhs => rw [← bilin_form.sum_repr_mul_repr_mul (pi.basis_fun R₂ n) (l _) (r _)]\n  rw [finsupp.sum_fintype]\n  · apply sum_congr rfl\n    rintro i' -\n    rw [finsupp.sum_fintype]\n    · apply sum_congr rfl\n      rintro j' -\n      simp only [smul_eq_mul, pi.basis_fun_repr, mul_assoc, mul_comm, mul_left_comm, pi.basis_fun_apply, of_apply]\n    · intros\n      simp only [zero_smul, smul_zero]\n  · intros\n    simp only [zero_smul, finsupp.sum_zero]\n#align bilin_form.to_matrix'_comp bilin_form.to_matrix'_comp\n\n",
 "to_matrix'_apply":
 "@[simp]\ntheorem bilin_form.to_matrix'_apply (B : bilin_form R₂ (n → R₂)) (i j : n) :\n    bilin_form.to_matrix' B i j = B (std_basis R₂ (fun _ => R₂) i 1) (std_basis R₂ (fun _ => R₂) j 1) :=\n  rfl\n#align bilin_form.to_matrix'_apply bilin_form.to_matrix'_apply\n\n",
 "to_matrix'":
 "theorem nondegenerate.to_matrix' {B : bilin_form R₃ (ι → R₃)} (h : B.nondegenerate) : B.to_matrix'.nondegenerate :=\n  nondegenerate_to_matrix'_iff.mpr h\n#align nondegenerate.to_matrix' nondegenerate.to_matrix'\n\n",
 "to_matrix":
 "theorem nondegenerate.to_matrix {B : bilin_form R₃ M₃} (h : B.nondegenerate) (b : basis ι R₃ M₃) :\n    (to_matrix b B).nondegenerate :=\n  (nondegenerate_to_matrix_iff b).mpr h\n#align nondegenerate.to_matrix nondegenerate.to_matrix\n\n",
 "to_bilin_to_matrix":
 "@[simp]\ntheorem matrix.to_bilin_to_matrix (B : bilin_form R₂ M₂) : matrix.to_bilin b (bilin_form.to_matrix b B) = B :=\n  (matrix.to_bilin b).apply_symm_apply B\n#align matrix.to_bilin_to_matrix matrix.to_bilin_to_matrix\n\n",
 "to_bilin_symm":
 "@[simp]\ntheorem matrix.to_bilin_symm : (matrix.to_bilin b).symm = bilin_form.to_matrix b :=\n  (bilin_form.to_matrix b).symm_symm\n#align matrix.to_bilin_symm matrix.to_bilin_symm\n\n",
 "to_bilin_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem matrix.to_bilin_comp (M : matrix n n R₂) (P Q : matrix n o R₂) :\n    (matrix.to_bilin b M).comp (to_lin c b P) (to_lin c b Q) =\n      matrix.to_bilin c (matrix.mul (matrix.mul (matrix.transpose P) M) Q) :=\n  (bilin_form.to_matrix c).injective\n    (by simp only [bilin_form.to_matrix_comp b c, bilin_form.to_matrix_to_bilin, to_matrix_to_lin])\n#align matrix.to_bilin_comp matrix.to_bilin_comp\n\n",
 "to_bilin_basis_fun":
 "theorem matrix.to_bilin_basis_fun : matrix.to_bilin (pi.basis_fun R₂ n) = matrix.to_bilin' :=\n  by\n  ext M\n  simp only [matrix.to_bilin_apply, matrix.to_bilin'_apply, pi.basis_fun_repr]\n#align matrix.to_bilin_basis_fun matrix.to_bilin_basis_fun\n\n",
 "to_bilin_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem matrix.to_bilin_apply (M : matrix n n R₂) (x y : M₂) :\n    matrix.to_bilin b M x y =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.repr x i * M i j * b.repr y j) :=\n  by\n  rw [matrix.to_bilin, bilin_form.to_matrix, linear_equiv.symm_trans_apply, ← matrix.to_bilin']\n  simp only [congr_symm, congr_apply, linear_equiv.symm_symm, matrix.to_bilin'_apply, basis.equiv_fun_apply]\n#align matrix.to_bilin_apply matrix.to_bilin_apply\n\n",
 "to_bilin'_to_matrix'":
 "@[simp]\ntheorem matrix.to_bilin'_to_matrix' (B : bilin_form R₂ (n → R₂)) : matrix.to_bilin' (bilin_form.to_matrix' B) = B :=\n  matrix.to_bilin'.apply_symm_apply B\n#align matrix.to_bilin'_to_matrix' matrix.to_bilin'_to_matrix'\n\n",
 "to_bilin'_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem matrix.to_bilin'_symm : (matrix.to_bilin'.symm : «expr ≃ₗ[ ] » _ R₂ (matrix n n R₂)) = bilin_form.to_matrix' :=\n  bilin_form.to_matrix'.symm_symm\n#align matrix.to_bilin'_symm matrix.to_bilin'_symm\n\n",
 "to_bilin'_std_basis":
 "@[simp]\ntheorem matrix.to_bilin'_std_basis (M : matrix n n R₂) (i j : n) :\n    matrix.to_bilin' M (std_basis R₂ (fun _ => R₂) i 1) (std_basis R₂ (fun _ => R₂) j 1) = M i j :=\n  matrix.to_bilin'_aux_std_basis M i j\n#align matrix.to_bilin'_std_basis matrix.to_bilin'_std_basis\n\n",
 "to_bilin'_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem matrix.to_bilin'_comp (M : matrix n n R₂) (P Q : matrix n o R₂) :\n    M.to_bilin'.comp P.to_lin' Q.to_lin' = (matrix.mul (matrix.mul (matrix.transpose P) M) Q).to_bilin' :=\n  bilin_form.to_matrix'.injective\n    (by simp only [bilin_form.to_matrix'_comp, bilin_form.to_matrix'_to_bilin', to_matrix'_to_lin'])\n#align matrix.to_bilin'_comp matrix.to_bilin'_comp\n\n",
 "to_bilin'_aux_to_matrix_aux":
 "theorem to_bilin'_aux_to_matrix_aux [decidable_eq n] (B₂ : bilin_form R₂ (n → R₂)) :\n    matrix.to_bilin'_aux (bilin_form.to_matrix_aux (fun j => std_basis R₂ (fun _ => R₂) j 1) B₂) = B₂ :=\n  by\n  refine' ext_basis (pi.basis_fun R₂ n) fun i j => _\n  rw [pi.basis_fun_apply, pi.basis_fun_apply, matrix.to_bilin'_aux_std_basis, bilin_form.to_matrix_aux_apply]\n#align to_bilin'_aux_to_matrix_aux to_bilin'_aux_to_matrix_aux\n\n",
 "to_bilin'_aux_std_basis":
 "/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen, Kexing Ying\n-/\ntheorem matrix.to_bilin'_aux_std_basis [fintype n] [decidable_eq n] (M : matrix n n R₂) (i j : n) :\n    M.to_bilin'_aux (std_basis R₂ (fun _ => R₂) i 1) (std_basis R₂ (fun _ => R₂) j 1) = M i j :=\n  by\n  rw [matrix.to_bilin'_aux, coe_fn_mk, sum_eq_single i, sum_eq_single j]\n  · simp only [std_basis_same, std_basis_same, one_mul, mul_one]\n  · rintro j' - hj'\n    apply mul_eq_zero_of_right\n    exact std_basis_ne R₂ (fun _ => R₂) _ _ hj' 1\n  · intros\n    have := finset.mem_univ j\n    contradiction\n  · rintro i' - hi'\n    refine' finset.sum_eq_zero fun j _ => _\n    apply mul_eq_zero_of_left\n    apply mul_eq_zero_of_left\n    exact std_basis_ne R₂ (fun _ => R₂) _ _ hi' 1\n  · intros\n    have := finset.mem_univ i\n    contradiction\n#align matrix.to_bilin'_aux_std_basis matrix.to_bilin'_aux_std_basis\n\n",
 "to_bilin'_aux_eq":
 "@[simp]\ntheorem matrix.to_bilin'_aux_eq (M : matrix n n R₂) : matrix.to_bilin'_aux M = matrix.to_bilin' M :=\n  rfl\n#align matrix.to_bilin'_aux_eq matrix.to_bilin'_aux_eq\n\n",
 "to_bilin'_apply'":
 "theorem matrix.to_bilin'_apply' (M : matrix n n R₂) (v w : n → R₂) :\n    matrix.to_bilin' M v w = matrix.dot_product v (M.mul_vec w) :=\n  by\n  simp_rw [matrix.to_bilin'_apply, matrix.dot_product, matrix.mul_vec, matrix.dot_product]\n  refine' finset.sum_congr rfl fun _ _ => _\n  rw [finset.mul_sum]\n  refine' finset.sum_congr rfl fun _ _ => _\n  rw [← mul_assoc]\n#align matrix.to_bilin'_apply' matrix.to_bilin'_apply'\n\n",
 "to_bilin'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem matrix.to_bilin'_apply (M : matrix n n R₂) (x y : n → R₂) :\n    matrix.to_bilin' M x y =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (x i * M i j * y j) :=\n  rfl\n#align matrix.to_bilin'_apply matrix.to_bilin'_apply\n\n",
 "to_bilin'":
 "-- Lemmas transferring nondegeneracy between a matrix and its associated bilinear form\ntheorem _root_.matrix.nondegenerate.to_bilin' {M : matrix ι ι R₃} (h : M.nondegenerate) : M.to_bilin'.nondegenerate :=\n  fun x hx => h.eq_zero_of_ortho fun y => by simpa only [to_bilin'_apply'] using hx y\n#align matrix.nondegenerate.to_bilin' matrix.nondegenerate.to_bilin'\n\n",
 "to_bilin":
 "theorem _root_.matrix.nondegenerate.to_bilin {M : matrix ι ι R₃} (h : M.nondegenerate) (b : basis ι R₃ M₃) :\n    (to_bilin b M).nondegenerate :=\n  (matrix.nondegenerate_to_bilin'_iff_nondegenerate_to_bilin b).mp h.to_bilin'\n#align matrix.nondegenerate.to_bilin matrix.nondegenerate.to_bilin\n\n",
 "nondegenerate_to_matrix_iff":
 "@[simp]\ntheorem nondegenerate_to_matrix_iff {B : bilin_form R₃ M₃} (b : basis ι R₃ M₃) :\n    (to_matrix b B).nondegenerate ↔ B.nondegenerate :=\n  (matrix.nondegenerate_to_bilin_iff b).symm.trans <| (matrix.to_bilin_to_matrix b B).symm ▸ iff.rfl\n#align nondegenerate_to_matrix_iff nondegenerate_to_matrix_iff\n\n",
 "nondegenerate_to_matrix'_iff":
 "-- Lemmas transferring nondegeneracy between a bilinear form and its associated matrix\n@[simp]\ntheorem nondegenerate_to_matrix'_iff {B : bilin_form R₃ (ι → R₃)} : B.to_matrix'.nondegenerate ↔ B.nondegenerate :=\n  matrix.nondegenerate_to_bilin'_iff.symm.trans <| (matrix.to_bilin'_to_matrix' B).symm ▸ iff.rfl\n#align nondegenerate_to_matrix'_iff nondegenerate_to_matrix'_iff\n\n",
 "nondegenerate_to_bilin_iff":
 "@[simp]\ntheorem _root_.matrix.nondegenerate_to_bilin_iff {M : matrix ι ι R₃} (b : basis ι R₃ M₃) :\n    (to_bilin b M).nondegenerate ↔ M.nondegenerate := by\n  rw [← matrix.nondegenerate_to_bilin'_iff_nondegenerate_to_bilin, matrix.nondegenerate_to_bilin'_iff]\n#align matrix.nondegenerate_to_bilin_iff matrix.nondegenerate_to_bilin_iff\n\n",
 "nondegenerate_to_bilin'_of_det_ne_zero'":
 "theorem nondegenerate_to_bilin'_of_det_ne_zero' (M : matrix ι ι A) (h : M.det ≠ 0) : M.to_bilin'.nondegenerate :=\n  nondegenerate_to_bilin'_iff_det_ne_zero.mpr h\n#align nondegenerate_to_bilin'_of_det_ne_zero' nondegenerate_to_bilin'_of_det_ne_zero'\n\n",
 "nondegenerate_to_bilin'_iff_nondegenerate_to_bilin":
 "theorem _root_.matrix.nondegenerate_to_bilin'_iff_nondegenerate_to_bilin {M : matrix ι ι R₂} (b : basis ι R₂ M₂) :\n    M.to_bilin'.nondegenerate ↔ (matrix.to_bilin b M).nondegenerate :=\n  (nondegenerate_congr_iff b.equiv_fun.symm).symm\n#align\n  matrix.nondegenerate_to_bilin'_iff_nondegenerate_to_bilin matrix.nondegenerate_to_bilin'_iff_nondegenerate_to_bilin\n\n",
 "nondegenerate_to_bilin'_iff_det_ne_zero":
 "-- Some shorthands for combining the above with `matrix.nondegenerate_of_det_ne_zero`\ntheorem nondegenerate_to_bilin'_iff_det_ne_zero {M : matrix ι ι A} : M.to_bilin'.nondegenerate ↔ M.det ≠ 0 := by\n  rw [matrix.nondegenerate_to_bilin'_iff, matrix.nondegenerate_iff_det_ne_zero]\n#align nondegenerate_to_bilin'_iff_det_ne_zero nondegenerate_to_bilin'_iff_det_ne_zero\n\n",
 "nondegenerate_to_bilin'_iff":
 "@[simp]\ntheorem _root_.matrix.nondegenerate_to_bilin'_iff {M : matrix ι ι R₃} : M.to_bilin'.nondegenerate ↔ M.nondegenerate :=\n  ⟨fun h v hv => h v fun w => (M.to_bilin'_apply' _ _).trans <| hv w, matrix.nondegenerate.to_bilin'⟩\n#align matrix.nondegenerate_to_bilin'_iff matrix.nondegenerate_to_bilin'_iff\n\n",
 "nondegenerate_of_det_ne_zero":
 "theorem nondegenerate_of_det_ne_zero (b : basis ι A M₃) (h : (to_matrix b B₃).det ≠ 0) : B₃.nondegenerate :=\n  (nondegenerate_iff_det_ne_zero b).mpr h\n#align nondegenerate_of_det_ne_zero nondegenerate_of_det_ne_zero\n\n",
 "nondegenerate_iff_det_ne_zero":
 "theorem nondegenerate_iff_det_ne_zero {B : bilin_form A M₃} (b : basis ι A M₃) :\n    B.nondegenerate ↔ (to_matrix b B).det ≠ 0 := by\n  rw [← matrix.nondegenerate_iff_det_ne_zero, nondegenerate_to_matrix_iff]\n#align nondegenerate_iff_det_ne_zero nondegenerate_iff_det_ne_zero\n\n",
 "mul_to_matrix_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem bilin_form.mul_to_matrix_mul (B : bilin_form R₂ M₂) (M : matrix o n R₂) (N : matrix n o R₂) :\n    matrix.mul (matrix.mul M (bilin_form.to_matrix b B)) N =\n      bilin_form.to_matrix c (B.comp (to_lin c b (matrix.transpose M)) (to_lin c b N)) :=\n  by simp only [B.to_matrix_comp b c, to_matrix_to_lin, transpose_transpose]\n#align bilin_form.mul_to_matrix_mul bilin_form.mul_to_matrix_mul\n\n",
 "mul_to_matrix'_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem bilin_form.mul_to_matrix'_mul (B : bilin_form R₂ (n → R₂)) (M : matrix o n R₂) (N : matrix n o R₂) :\n    matrix.mul (matrix.mul M B.to_matrix') N = (B.comp (matrix.transpose M).to_lin' N.to_lin').to_matrix' := by\n  simp only [B.to_matrix'_comp, transpose_transpose, to_matrix'_to_lin']\n#align bilin_form.mul_to_matrix'_mul bilin_form.mul_to_matrix'_mul\n\n",
 "mul_to_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem bilin_form.mul_to_matrix' (B : bilin_form R₂ (n → R₂)) (M : matrix n n R₂) :\n    matrix.mul M B.to_matrix' = (B.comp_left (matrix.transpose M).to_lin').to_matrix' := by\n  simp only [B.to_matrix'_comp_left, transpose_transpose, to_matrix'_to_lin']\n#align bilin_form.mul_to_matrix' bilin_form.mul_to_matrix'\n\n",
 "mul_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem bilin_form.mul_to_matrix (B : bilin_form R₂ M₂) (M : matrix n n R₂) :\n    matrix.mul M (bilin_form.to_matrix b B) = bilin_form.to_matrix b (B.comp_left (to_lin b b (matrix.transpose M))) :=\n  by rw [B.to_matrix_comp_left b, to_matrix_to_lin, transpose_transpose]\n#align bilin_form.mul_to_matrix bilin_form.mul_to_matrix\n\n",
 "mem_skew_adjoint_matrices_submodule'":
 "theorem mem_skew_adjoint_matrices_submodule' : A ∈ skew_adjoint_matrices_submodule J ↔ J.is_skew_adjoint A := by\n  simp only [mem_skew_adjoint_matrices_submodule]\n#align mem_skew_adjoint_matrices_submodule' mem_skew_adjoint_matrices_submodule'\n\n",
 "mem_self_adjoint_matrices_submodule'":
 "theorem mem_self_adjoint_matrices_submodule' : A ∈ self_adjoint_matrices_submodule J ↔ J.is_self_adjoint A := by\n  simp only [mem_self_adjoint_matrices_submodule]\n#align mem_self_adjoint_matrices_submodule' mem_self_adjoint_matrices_submodule'\n\n",
 "mem_pair_self_adjoint_matrices_submodule'":
 "theorem mem_pair_self_adjoint_matrices_submodule' :\n    A ∈ pair_self_adjoint_matrices_submodule J J₃ ↔ matrix.is_adjoint_pair J J₃ A A := by\n  simp only [mem_pair_self_adjoint_matrices_submodule]\n#align mem_pair_self_adjoint_matrices_submodule' mem_pair_self_adjoint_matrices_submodule'\n\n",
 "is_adjoint_pair_to_bilin'":
 "@[simp]\ntheorem is_adjoint_pair_to_bilin' [decidable_eq n] :\n    bilin_form.is_adjoint_pair (matrix.to_bilin' J) (matrix.to_bilin' J₃) (matrix.to_lin' A) (matrix.to_lin' A') ↔\n      matrix.is_adjoint_pair J J₃ A A' :=\n  by\n  rw [bilin_form.is_adjoint_pair_iff_comp_left_eq_comp_right]\n  have h : ∀ B B' : bilin_form R₃ (n → R₃), B = B' ↔ bilin_form.to_matrix' B = bilin_form.to_matrix' B' :=\n    by\n    intro B B'\n    constructor <;> intro h\n    · rw [h]\n    · exact bilin_form.to_matrix'.injective h\n  rw [h, bilin_form.to_matrix'_comp_left, bilin_form.to_matrix'_comp_right, linear_map.to_matrix'_to_lin',\n    linear_map.to_matrix'_to_lin', bilin_form.to_matrix'_to_bilin', bilin_form.to_matrix'_to_bilin']\n  rfl\n#align is_adjoint_pair_to_bilin' is_adjoint_pair_to_bilin'\n\n",
 "is_adjoint_pair_to_bilin":
 "@[simp]\ntheorem is_adjoint_pair_to_bilin [decidable_eq n] :\n    bilin_form.is_adjoint_pair (matrix.to_bilin b J) (matrix.to_bilin b J₃) (matrix.to_lin b b A)\n        (matrix.to_lin b b A') ↔\n      matrix.is_adjoint_pair J J₃ A A' :=\n  by\n  rw [bilin_form.is_adjoint_pair_iff_comp_left_eq_comp_right]\n  have h : ∀ B B' : bilin_form R₃ M₃, B = B' ↔ bilin_form.to_matrix b B = bilin_form.to_matrix b B' :=\n    by\n    intro B B'\n    constructor <;> intro h\n    · rw [h]\n    · exact (bilin_form.to_matrix b).injective h\n  rw [h, bilin_form.to_matrix_comp_left, bilin_form.to_matrix_comp_right, linear_map.to_matrix_to_lin,\n    linear_map.to_matrix_to_lin, bilin_form.to_matrix_to_bilin, bilin_form.to_matrix_to_bilin]\n  rfl\n#align is_adjoint_pair_to_bilin is_adjoint_pair_to_bilin\n\n",
 "is_adjoint_pair_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem matrix.is_adjoint_pair_equiv' [decidable_eq n] (P : matrix n n R₃) (h : is_unit P) :\n    (matrix.mul (matrix.mul (matrix.transpose P) J) P).is_adjoint_pair\n        (matrix.mul (matrix.mul (matrix.transpose P) J) P) A A' ↔\n      J.is_adjoint_pair J (matrix.mul (matrix.mul P A) P⁻¹) (matrix.mul (matrix.mul P A') P⁻¹) :=\n  by\n  have h' : is_unit P.det := P.is_unit_iff_is_unit_det.mp h\n  let u := P.nonsing_inv_unit h'\n  let v := (matrix.transpose P).nonsing_inv_unit (P.is_unit_det_transpose h')\n  let x := matrix.transpose A * matrix.transpose P * J\n  let y := J * P * A'\n  suffices x * ↑u = ↑v * y ↔ ↑v⁻¹ * x = y * ↑u⁻¹\n    by\n    dsimp only [matrix.is_adjoint_pair]\n    repeat' rw [matrix.transpose_mul]\n    simp only [← matrix.mul_eq_mul, ← mul_assoc, P.transpose_nonsing_inv]\n    conv_lhs =>\n      rhs\n      rw [mul_assoc, mul_assoc]\n      congr\n      skip\n      rw [← mul_assoc]\n    conv_rhs =>\n      rw [mul_assoc, mul_assoc]\n      conv =>\n        lhs\n        congr\n        skip\n        rw [← mul_assoc]\n    exact this\n  rw [units.eq_mul_inv_iff_mul_eq]\n  conv_rhs => rw [mul_assoc]\n  rw [v.inv_mul_eq_iff_eq_mul]\n#align matrix.is_adjoint_pair_equiv' matrix.is_adjoint_pair_equiv'\n\n"}