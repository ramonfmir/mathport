{"lower_inv_triangular":
 "theorem LDL.lower_inv_triangular {i j : n} (hij : i < j) : LDL.lower_inv hS i j = 0 := by\n  rw [‚Üê\n    @gram_schmidt_triangular ùïú (n ‚Üí ùïú) _ (inner_product_space.of_matrix hS.transpose) n _ _ _ i j hij\n      (pi.basis_fun ùïú n),\n    pi.basis_fun_repr, LDL.lower_inv]\n#align LDL.lower_inv_triangular LDL.lower_inv_triangular\n\n",
 "lower_inv_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚ü™ , ‚ü´¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem LDL.lower_inv_orthogonal {i j : n} (h‚ÇÄ : i ‚â† j) :\n    ¬´expr‚ü™ , ‚ü´¬ª (LDL.lower_inv hS i) ((matrix.transpose S).mul_vec (LDL.lower_inv hS j)) = 0 :=\n  show\n    @inner ùïú (n ‚Üí ùïú) (inner_product_space.of_matrix hS.transpose).to_has_inner (LDL.lower_inv hS i)\n        (LDL.lower_inv hS j) =\n      0\n    by apply gram_schmidt_orthogonal _ _ h‚ÇÄ\n#align LDL.lower_inv_orthogonal LDL.lower_inv_orthogonal\n\n",
 "lower_inv_eq_gram_schmidt_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/-\nCopyright (c) 2022 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp\n-/\ntheorem LDL.lower_inv_eq_gram_schmidt_basis :\n    LDL.lower_inv hS =\n      matrix.transpose\n        ((pi.basis_fun ùïú n).to_matrix\n          (@gram_schmidt_basis ùïú (n ‚Üí ùïú) _ (inner_product_space.of_matrix hS.transpose) n _ _ _ (pi.basis_fun ùïú n))) :=\n  by\n  ext (i j)\n  rw [LDL.lower_inv, basis.coe_pi_basis_fun.to_matrix_eq_transpose, coe_gram_schmidt_basis]\n  rfl\n#align LDL.lower_inv_eq_gram_schmidt_basis LDL.lower_inv_eq_gram_schmidt_basis\n\n",
 "lower_conj_diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- **LDL decomposition**: any positive definite matrix `S` can be\ndecomposed as `S = LDL·¥¥` where `L` is a lower-triangular matrix and `D` is a diagonal matrix.  -/\ntheorem LDL.lower_conj_diag :\n    matrix.mul (matrix.mul (LDL.lower hS) (LDL.diag hS)) (matrix.conj_transpose (LDL.lower hS)) = S :=\n  by\n  rw [LDL.lower, conj_transpose_nonsing_inv, matrix.mul_assoc,\n    matrix.inv_mul_eq_iff_eq_mul_of_invertible (LDL.lower_inv hS), matrix.mul_inv_eq_iff_eq_mul_of_invertible]\n  exact LDL.diag_eq_lower_inv_conj hS\n#align LDL.lower_conj_diag LDL.lower_conj_diag\n\n",
 "diag_eq_lower_inv_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/-- Inverse statement of **LDL decomposition**: we can conjugate a positive definite matrix\nby some lower triangular matrix and get a diagonal matrix. -/\ntheorem LDL.diag_eq_lower_inv_conj :\n    LDL.diag hS = matrix.mul (matrix.mul (LDL.lower_inv hS) S) (matrix.conj_transpose (LDL.lower_inv hS)) :=\n  by\n  ext (i j)\n  by_cases hij : i = j\n  ¬∑\n    simpa only [hij, LDL.diag, diagonal_apply_eq, LDL.diag_entries, matrix.mul_assoc, inner, Pi.star_apply,\n      is_R_or_C.star_def, starRingEnd_self_apply]\n  ¬∑ simp only [LDL.diag, hij, diagonal_apply_ne, ne.def, not_false_iff, mul_mul_apply]\n    rw [conj_transpose, transpose_map, transpose_transpose, dot_product_mul_vec,\n      (LDL.lower_inv_orthogonal hS fun h : j = i => hij h.symm).symm, ‚Üê inner_conj_sym, mul_vec_transpose,\n      euclidean_space.inner_eq_star_dot_product, ‚Üê is_R_or_C.star_def, ‚Üê star_dot_product_star, dot_product_comm,\n      star_star]\n    rfl\n#align LDL.diag_eq_lower_inv_conj LDL.diag_eq_lower_inv_conj\n\n"}