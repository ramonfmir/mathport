{"update_row_eq_transvection":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A transvection matrix is obtained from the identity by adding `c` times the `j`-th row to\nthe `i`-th row. -/\ntheorem update_row_eq_transvection [Finite n] (c : R) :\n    update_row (1 : matrix n n R) i ((1 : matrix n n R) i + «expr • » c ((1 : matrix n n R) j)) = transvection i j c :=\n  by\n  cases nonempty_fintype n\n  ext (a b)\n  by_cases ha : i = a; by_cases hb : j = b\n  ·\n    simp only [update_row, transvection, ha, hb, function.update_same, std_basis_matrix.apply_same, pi.add_apply,\n      one_apply_eq, pi.smul_apply, mul_one, algebra.id.smul_eq_mul]\n  ·\n    simp only [update_row, transvection, ha, hb, std_basis_matrix.apply_of_ne, function.update_same, pi.add_apply,\n      ne.def, not_false_iff, pi.smul_apply, and_false_iff, one_apply_ne, algebra.id.smul_eq_mul, mul_zero]\n  ·\n    simp only [update_row, transvection, ha, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul,\n      function.update_noteq, ne.def, not_false_iff, dmatrix.add_apply, pi.smul_apply, mul_zero, false_and_iff]\n#align update_row_eq_transvection update_row_eq_transvection\n\n",
 "transvection_zero":
 "/-\nCopyright (c) 2021 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem transvection_zero : transvection i j (0 : R) = 1 := by simp [transvection]\n#align transvection_zero transvection_zero\n\n",
 "transvection_mul_transvection_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem transvection_mul_transvection_same (h : i ≠ j) (c d : R) :\n    matrix.mul (transvection i j c) (transvection i j d) = transvection i j (c + d) := by\n  simp [transvection, matrix.add_mul, matrix.mul_add, h, h.symm, add_smul, add_assoc, std_basis_matrix_add]\n#align transvection_mul_transvection_same transvection_mul_transvection_same\n\n",
 "transvection_mul_apply_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem transvection_mul_apply_same (b : n) (c : R) (M : matrix n n R) :\n    (matrix.mul (transvection i j c) M) i b = M i b + c * M j b := by simp [transvection, matrix.add_mul]\n#align transvection_mul_apply_same transvection_mul_apply_same\n\n",
 "transvection_mul_apply_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem transvection_mul_apply_of_ne (a b : n) (ha : a ≠ i) (c : R) (M : matrix n n R) :\n    (matrix.mul (transvection i j c) M) a b = M a b := by simp [transvection, matrix.add_mul, ha]\n#align transvection_mul_apply_of_ne transvection_mul_apply_of_ne\n\n",
 "to_matrix_sum_inl":
 "theorem to_matrix_sum_inl (t : transvection_struct n R) : (t.sum_inl p).to_matrix = from_blocks t.to_matrix 0 0 1 :=\n  by\n  cases t\n  ext (a b)\n  cases a <;> cases b\n  · by_cases h : a = b <;> simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]\n  · simp [transvection_struct.sum_inl, transvection]\n  · simp [transvection_struct.sum_inl, transvection]\n  · by_cases h : a = b <;> simp [transvection_struct.sum_inl, transvection, h]\n#align to_matrix_sum_inl to_matrix_sum_inl\n\n",
 "to_matrix_reindex_equiv_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem to_matrix_reindex_equiv_prod (e : «expr ≃ » n p) (L : list (transvection_struct n R)) :\n    (L.map (to_matrix ∘ reindex_equiv e)).prod = reindex_alg_equiv R e (L.map to_matrix).prod :=\n  by\n  induction' L with t L IH\n  · simp\n  · simp only [to_matrix_reindex_equiv, IH, Function.comp_apply, List.prod_cons, mul_eq_mul, reindex_alg_equiv_apply,\n      list.map]\n    exact (reindex_alg_equiv_mul _ _ _ _).symm\n#align to_matrix_reindex_equiv_prod to_matrix_reindex_equiv_prod\n\n",
 "to_matrix_reindex_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem to_matrix_reindex_equiv (e : «expr ≃ » n p) (t : transvection_struct n R) :\n    (t.reindex_equiv e).to_matrix = reindex_alg_equiv R e t.to_matrix :=\n  by\n  cases t\n  ext (a b)\n  simp only [reindex_equiv, transvection, mul_boole, algebra.id.smul_eq_mul, to_matrix_mk, submatrix_apply,\n    reindex_apply, dmatrix.add_apply, pi.smul_apply, reindex_alg_equiv_apply]\n  by_cases ha : e t_i = a <;> by_cases hb : e t_j = b <;> by_cases hab : a = b <;>\n    simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]\n#align to_matrix_reindex_equiv to_matrix_reindex_equiv\n\n",
 "to_matrix_mk":
 "@[simp]\ntheorem to_matrix_mk (i j : n) (hij : i ≠ j) (c : R) :\n    transvection_struct.to_matrix ⟨i, j, hij, c⟩ = transvection i j c :=\n  rfl\n#align to_matrix_mk to_matrix_mk\n\n",
 "sum_inl_to_matrix_prod_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem sum_inl_to_matrix_prod_mul [fintype n] [fintype p] (M : matrix n n R) (L : list (transvection_struct n R))\n    (N : matrix p p R) :\n    matrix.mul (L.map (to_matrix ∘ sum_inl p)).prod (from_blocks M 0 0 N) =\n      from_blocks (matrix.mul (L.map to_matrix).prod M) 0 0 N :=\n  by\n  induction' L with t L IH\n  · simp\n  · simp [matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply]\n#align sum_inl_to_matrix_prod_mul sum_inl_to_matrix_prod_mul\n\n",
 "reverse_inv_prod_mul_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem reverse_inv_prod_mul_prod (L : list (transvection_struct n R)) :\n    matrix.mul (L.reverse.map (to_matrix ∘ transvection_struct.inv)).prod (L.map to_matrix).prod = 1 :=\n  by\n  induction' L with t L IH\n  · simp\n  · suffices\n      matrix.mul\n          (matrix.mul (L.reverse.map (to_matrix ∘ transvection_struct.inv)).prod\n            (matrix.mul t.inv.to_matrix t.to_matrix))\n          (L.map to_matrix).prod =\n        1\n      by simpa [matrix.mul_assoc]\n    simpa [inv_mul] using IH\n#align reverse_inv_prod_mul_prod reverse_inv_prod_mul_prod\n\n",
 "reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Reduction to diagonal form by elementary operations is invariant under reindexing. -/\ntheorem reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : matrix p p 𝕜) (e : «expr ≃ » p n)\n    (H :\n      ∃ (L L' : list (transvection_struct n 𝕜))(D : n → 𝕜),\n        matrix.mul (matrix.mul (L.map to_matrix).prod (matrix.reindex_alg_equiv 𝕜 e M)) (L'.map to_matrix).prod =\n          diagonal D) :\n    ∃ (L L' : list (transvection_struct p 𝕜))(D : p → 𝕜),\n      matrix.mul (matrix.mul (L.map to_matrix).prod M) (L'.map to_matrix).prod = diagonal D :=\n  by\n  rcases H with ⟨L₀, L₀', D₀, h₀⟩\n  refine' ⟨L₀.map (reindex_equiv e.symm), L₀'.map (reindex_equiv e.symm), D₀ ∘ e, _⟩\n  have : M = reindex_alg_equiv 𝕜 e.symm (reindex_alg_equiv 𝕜 e M) := by\n    simp only [equiv.symm_symm, submatrix_submatrix, reindex_apply, submatrix_id_id, equiv.symm_comp_self,\n      reindex_alg_equiv_apply]\n  rw [this]\n  simp only [to_matrix_reindex_equiv_prod, list.map_map, reindex_alg_equiv_apply]\n  simp only [← reindex_alg_equiv_apply, ← reindex_alg_equiv_mul, h₀]\n  simp only [equiv.symm_symm, reindex_apply, submatrix_diagonal_equiv, reindex_alg_equiv_apply]\n#align\n  reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal\n\n",
 "prod_mul_reverse_inv_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem prod_mul_reverse_inv_prod (L : list (transvection_struct n R)) :\n    matrix.mul (L.map to_matrix).prod (L.reverse.map (to_matrix ∘ transvection_struct.inv)).prod = 1 :=\n  by\n  induction' L with t L IH\n  · simp\n  · suffices\n      matrix.mul\n          (matrix.mul t.to_matrix\n            (matrix.mul (L.map to_matrix).prod (L.reverse.map (to_matrix ∘ transvection_struct.inv)).prod))\n          t.inv.to_matrix =\n        1\n      by simpa [matrix.mul_assoc]\n    simp_rw [IH, matrix.mul_one, t.mul_inv]\n#align prod_mul_reverse_inv_prod prod_mul_reverse_inv_prod\n\n",
 "mul_transvection_apply_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_transvection_apply_same (a : n) (c : R) (M : matrix n n R) :\n    (matrix.mul M (transvection i j c)) a j = M a j + c * M a i := by simp [transvection, matrix.mul_add, mul_comm]\n#align mul_transvection_apply_same mul_transvection_apply_same\n\n",
 "mul_transvection_apply_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_transvection_apply_of_ne (a b : n) (hb : b ≠ j) (c : R) (M : matrix n n R) :\n    (matrix.mul M (transvection i j c)) a b = M a b := by simp [transvection, matrix.mul_add, hb]\n#align mul_transvection_apply_of_ne mul_transvection_apply_of_ne\n\n",
 "mul_sum_inl_to_matrix_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_sum_inl_to_matrix_prod [fintype n] [fintype p] (M : matrix n n R) (L : list (transvection_struct n R))\n    (N : matrix p p R) :\n    matrix.mul (from_blocks M 0 0 N) (L.map (to_matrix ∘ sum_inl p)).prod =\n      from_blocks (matrix.mul M (L.map to_matrix).prod) 0 0 N :=\n  by\n  induction' L with t L IH generalizing M N\n  · simp\n  · simp [IH, to_matrix_sum_inl, from_blocks_multiply]\n#align mul_sum_inl_to_matrix_prod mul_sum_inl_to_matrix_prod\n\n",
 "mul_list_transvec_row_last_row":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices in `list_transvec_row M` kills all the coefficients in the\nlast row but the last one. -/\ntheorem mul_list_transvec_row_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : fin r) :\n    (matrix.mul M (list_transvec_row M).prod) (inr unit) (inl i) = 0 :=\n  by\n  suffices H :\n    ∀ k : ℕ,\n      k ≤ r →\n        (matrix.mul M ((list_transvec_row M).take k).prod) (inr star) (inl i) =\n          if k ≤ i then M (inr star) (inl i) else 0\n  · have A : (list_transvec_row M).length = r := by simp [list_transvec_row]\n    rw [← List.take_length (list_transvec_row M), A]\n    have : ¬r ≤ i := by simp\n    simpa only [this, ite_eq_right_iff] using H r le_rfl\n  intro k hk\n  induction' k with n IH\n  · simp only [if_true, matrix.mul_one, List.take_zero, zero_le', List.prod_nil]\n  · have hnr : n < r := hk\n    let n' : fin r := ⟨n, hnr⟩\n    have A :\n      (list_transvec_row M).nth n =\n        ↑(transvection (inr Unit.unit) (inl n') (-M (inr Unit.unit) (inl n') / M (inr Unit.unit) (inr Unit.unit))) :=\n      by\n      simp only [list_transvec_row, List.ofFnNthVal, hnr, dif_pos, list.nth_of_fn]\n      rfl\n    simp only [List.take_succ, A, ← matrix.mul_assoc, List.prod_append, matrix.mul_one, matrix.mul_eq_mul,\n      List.prod_cons, List.prod_nil, option.to_list_some]\n    by_cases h : n' = i\n    · have hni : n = i := by\n        cases i\n        simp only [Fin.mk_eq_mk] at h\n        simp only [h, coe_mk]\n      have : ¬n.succ ≤ i := by simp only [← hni, n.lt_succ_self, not_le]\n      simp only [h, mul_transvection_apply_same, list.take, if_false, mul_list_transvec_row_last_col_take _ _ hnr.le,\n        hni.le, this, if_true, IH hnr.le]\n      field_simp [hM]\n    · have hni : n ≠ i := by\n        rintro rfl\n        cases i\n        simpa using h\n      simp only [IH hnr.le, ne.def, mul_transvection_apply_of_ne, not_false_iff, ne.symm h]\n      rcases le_or_lt (n + 1) i with (hi | hi)\n      · simp [hi, n.le_succ.trans hi, if_true]\n      · rw [if_neg, if_neg]\n        · simpa only [not_le] using hi\n        · simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi\n#align mul_list_transvec_row_last_row mul_list_transvec_row_last_row\n\n",
 "mul_list_transvec_row_last_col_take":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by some of the matrices in `list_transvec_row M` does not change the last column. -/\ntheorem mul_list_transvec_row_last_col_take (i : Sum (fin r) unit) {k : ℕ} (hk : k ≤ r) :\n    (matrix.mul M ((list_transvec_row M).take k).prod) i (inr unit) = M i (inr unit) :=\n  by\n  induction' k with k IH\n  · simp only [matrix.mul_one, List.take_zero, List.prod_nil]\n  · have hkr : k < r := hk\n    let k' : fin r := ⟨k, hkr⟩\n    have :\n      (list_transvec_row M).nth k =\n        ↑(transvection (inr Unit.unit) (inl k') (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) :=\n      by\n      simp only [list_transvec_row, List.ofFnNthVal, hkr, dif_pos, list.nth_of_fn]\n      rfl\n    simp only [List.take_succ, ← matrix.mul_assoc, this, List.prod_append, matrix.mul_one, matrix.mul_eq_mul,\n      List.prod_cons, List.prod_nil, option.to_list_some]\n    rw [mul_transvection_apply_of_ne, IH hkr.le]\n    simp only [ne.def, not_false_iff]\n#align mul_list_transvec_row_last_col_take mul_list_transvec_row_last_col_take\n\n",
 "mul_list_transvec_row_last_col":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices in `list_transvec_row M` does not change the last column. -/\ntheorem mul_list_transvec_row_last_col (i : Sum (fin r) unit) :\n    (matrix.mul M (list_transvec_row M).prod) i (inr unit) = M i (inr unit) :=\n  by\n  have A : (list_transvec_row M).length = r := by simp [list_transvec_row]\n  rw [← List.take_length (list_transvec_row M), A]\n  simpa using mul_list_transvec_row_last_col_take M i le_rfl\n#align mul_list_transvec_row_last_col mul_list_transvec_row_last_col\n\n",
 "mul_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print mul_inv /-\ntheorem mul_inv (t : transvection_struct n R) : matrix.mul t.to_matrix t.inv.to_matrix = 1 :=\n  by\n  rcases t with ⟨⟩\n  simp [to_matrix, transvection_mul_transvection_same, t_hij]\n#align mul_inv mul_inv\n-/\n\n",
 "list_transvec_col_mul_mul_list_transvec_row_last_row":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices either in `list_transvec_col M` and `list_transvec_row M` kills\nall the coefficients in the last column but the last one. -/\ntheorem list_transvec_col_mul_mul_list_transvec_row_last_row (hM : M (inr unit) (inr unit) ≠ 0) (i : fin r) :\n    (matrix.mul (matrix.mul (list_transvec_col M).prod M) (list_transvec_row M).prod) (inl i) (inr unit) = 0 :=\n  by\n  have : list_transvec_col M = list_transvec_col (matrix.mul M (list_transvec_row M).prod) := by\n    simp [list_transvec_col, mul_list_transvec_row_last_col]\n  rw [this, matrix.mul_assoc]\n  apply list_transvec_col_mul_last_col\n  simpa [mul_list_transvec_row_last_col] using hM\n#align list_transvec_col_mul_mul_list_transvec_row_last_row list_transvec_col_mul_mul_list_transvec_row_last_row\n\n",
 "list_transvec_col_mul_mul_list_transvec_row_last_col":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices either in `list_transvec_col M` and `list_transvec_row M` kills\nall the coefficients in the last row but the last one. -/\ntheorem list_transvec_col_mul_mul_list_transvec_row_last_col (hM : M (inr unit) (inr unit) ≠ 0) (i : fin r) :\n    (matrix.mul (matrix.mul (list_transvec_col M).prod M) (list_transvec_row M).prod) (inr unit) (inl i) = 0 :=\n  by\n  have : list_transvec_row M = list_transvec_row (matrix.mul (list_transvec_col M).prod M) := by\n    simp [list_transvec_row, list_transvec_col_mul_last_row]\n  rw [this]\n  apply mul_list_transvec_row_last_row\n  simpa [list_transvec_col_mul_last_row] using hM\n#align list_transvec_col_mul_mul_list_transvec_row_last_col list_transvec_col_mul_mul_list_transvec_row_last_col\n\n",
 "list_transvec_col_mul_last_row_drop":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by some of the matrices in `list_transvec_col M` does not change the last row. -/\ntheorem list_transvec_col_mul_last_row_drop (i : Sum (fin r) unit) {k : ℕ} (hk : k ≤ r) :\n    (matrix.mul ((list_transvec_col M).drop k).prod M) (inr unit) i = M (inr unit) i :=\n  by\n  apply Nat.decreasingInduction' _ hk\n  · simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, List.drop_eq_nil_of_le, List.prod_nil]\n  · intro n hn hk IH\n    have hn' : n < (list_transvec_col M).length := by simpa [list_transvec_col] using hn\n    rw [← List.cons_nthLe_drop_succ hn']\n    simpa [list_transvec_col, matrix.mul_assoc]\n#align list_transvec_col_mul_last_row_drop list_transvec_col_mul_last_row_drop\n\n",
 "list_transvec_col_mul_last_row":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices in `list_transvec_col M` does not change the last row. -/\ntheorem list_transvec_col_mul_last_row (i : Sum (fin r) unit) :\n    (matrix.mul (list_transvec_col M).prod M) (inr unit) i = M (inr unit) i := by\n  simpa using list_transvec_col_mul_last_row_drop M i (zero_le _)\n#align list_transvec_col_mul_last_row list_transvec_col_mul_last_row\n\n",
 "list_transvec_col_mul_last_col":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices in `list_transvec_col M` kills all the coefficients in the\nlast column but the last one. -/\ntheorem list_transvec_col_mul_last_col (hM : M (inr unit) (inr unit) ≠ 0) (i : fin r) :\n    (matrix.mul (list_transvec_col M).prod M) (inl i) (inr unit) = 0 :=\n  by\n  suffices H :\n    ∀ k : ℕ,\n      k ≤ r →\n        (matrix.mul ((list_transvec_col M).drop k).prod M) (inl i) (inr star) =\n          if k ≤ i then 0 else M (inl i) (inr star)\n  · simpa only [if_true, list.drop.equations._eqn_1] using H 0 (zero_le _)\n  intro k hk\n  apply Nat.decreasingInduction' _ hk\n  · simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, List.drop_eq_nil_of_le, List.prod_nil]\n    rw [if_neg]\n    simpa only [not_le] using i.2\n  · intro n hn hk IH\n    have hn' : n < (list_transvec_col M).length := by simpa [list_transvec_col] using hn\n    let n' : fin r := ⟨n, hn⟩\n    rw [← List.cons_nthLe_drop_succ hn']\n    have A :\n      (list_transvec_col M).nth_le n hn' =\n        transvection (inl n') (inr star) (-M (inl n') (inr star) / M (inr star) (inr star)) :=\n      by simp [list_transvec_col]\n    simp only [matrix.mul_assoc, A, matrix.mul_eq_mul, List.prod_cons]\n    by_cases h : n' = i\n    · have hni : n = i := by\n        cases i\n        simp only [Fin.mk_eq_mk] at h\n        simp [h]\n      rw [h, transvection_mul_apply_same, IH, list_transvec_col_mul_last_row_drop _ _ hn, ← hni]\n      field_simp [hM]\n    · have hni : n ≠ i := by\n        rintro rfl\n        cases i\n        simpa using h\n      simp only [transvection_mul_apply_of_ne, ne.def, not_false_iff, ne.symm h]\n      rw [IH]\n      rcases le_or_lt (n + 1) i with (hi | hi)\n      · simp only [hi, n.le_succ.trans hi, if_true]\n      · rw [if_neg, if_neg]\n        · simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi\n        · simpa only [not_le] using hi\n#align list_transvec_col_mul_last_col list_transvec_col_mul_last_col\n\n",
 "is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Multiplying by all the matrices either in `list_transvec_col M` and `list_transvec_row M` turns\nthe matrix in block-diagonal form. -/\ntheorem is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row (hM : M (inr unit) (inr unit) ≠ 0) :\n    is_two_block_diagonal (matrix.mul (matrix.mul (list_transvec_col M).prod M) (list_transvec_row M).prod) :=\n  by\n  constructor\n  · ext (i j)\n    have : j = star := by simp only [eq_iff_true_of_subsingleton]\n    simp [to_blocks₁₂, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM]\n  · ext (i j)\n    have : i = star := by simp only [eq_iff_true_of_subsingleton]\n    simp [to_blocks₂₁, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM]\n#align\n  is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row\n\n",
 "inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem inv_mul (t : transvection_struct n R) : matrix.mul t.inv.to_matrix t.to_matrix = 1 :=\n  by\n  rcases t with ⟨⟩\n  simp [to_matrix, transvection_mul_transvection_same, t_hij]\n#align inv_mul inv_mul\n\n",
 "exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Inductive step for the reduction: if one knows that any size `r` matrix can be reduced to\ndiagonal form by elementary operations, then one deduces it for matrices over `fin r ⊕ unit`. -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction\n    (IH :\n      ∀ M : matrix (fin r) (fin r) 𝕜,\n        ∃ (L₀ L₀' : list (transvection_struct (fin r) 𝕜))(D₀ : fin r → 𝕜),\n          matrix.mul (matrix.mul (L₀.map to_matrix).prod M) (L₀'.map to_matrix).prod = diagonal D₀)\n    (M : matrix (Sum (fin r) unit) (Sum (fin r) unit) 𝕜) :\n    ∃ (L L' : list (transvection_struct (Sum (fin r) unit) 𝕜))(D : Sum (fin r) unit → 𝕜),\n      matrix.mul (matrix.mul (L.map to_matrix).prod M) (L'.map to_matrix).prod = diagonal D :=\n  by\n  rcases exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec M with ⟨L₁, L₁', hM⟩\n  let M' := matrix.mul (matrix.mul (L₁.map to_matrix).prod M) (L₁'.map to_matrix).prod\n  let M'' := to_blocks₁₁ M'\n  rcases IH M'' with ⟨L₀, L₀', D₀, h₀⟩\n  set c := M' (inr star) (inr star) with hc\n  refine' ⟨L₀.map (sum_inl unit) ++ L₁, L₁' ++ L₀'.map (sum_inl unit), sum.elim D₀ fun _ => M' (inr star) (inr star), _⟩\n  suffices\n    matrix.mul (matrix.mul (L₀.map (to_matrix ∘ sum_inl unit)).prod M') (L₀'.map (to_matrix ∘ sum_inl unit)).prod =\n      diagonal (sum.elim D₀ fun _ => c)\n    by simpa [M', matrix.mul_assoc, c]\n  have : M' = from_blocks M'' 0 0 (diagonal fun _ => c) :=\n    by\n    rw [← from_blocks_to_blocks M']\n    congr\n    · exact hM.1\n    · exact hM.2\n    · ext (⟨⟩⟨⟩)\n      rw [hc, to_blocks₂₂, of_apply]\n      rfl\n  rw [this]\n  simp [h₀]\n#align\n  exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction\n\n",
 "exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Any matrix can be reduced to diagonal form by elementary operations. Formulated here on `Type 0`\nbecause we will make an induction using `fin r`.\nSee `exists_list_transvec_mul_mul_list_transvec_eq_diagonal` for the general version (which follows\nfrom this one and reindexing). -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux (n : Type) [fintype n] [decidable_eq n]\n    (M : matrix n n 𝕜) :\n    ∃ (L L' : list (transvection_struct n 𝕜))(D : n → 𝕜),\n      matrix.mul (matrix.mul (L.map to_matrix).prod M) (L'.map to_matrix).prod = diagonal D :=\n  by\n  induction' hn : fintype.card n with r IH generalizing n M\n  · refine' ⟨list.nil, list.nil, fun _ => 1, _⟩\n    ext (i j)\n    rw [fintype.card_eq_zero_iff] at hn\n    exact hn.elim' i\n  · have e : «expr ≃ » n (Sum (fin r) unit) :=\n      by\n      refine' fintype.equiv_of_card_eq _\n      rw [hn]\n      convert (@fintype.card_sum (fin r) unit _ _).symm\n      simp\n    apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e\n    apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction fun N => IH (fin r) N (by simp)\n#align\n  exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux\n\n",
 "exists_list_transvec_mul_mul_list_transvec_eq_diagonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Any matrix can be reduced to diagonal form by elementary operations. -/\ntheorem exists_list_transvec_mul_mul_list_transvec_eq_diagonal (M : matrix n n 𝕜) :\n    ∃ (L L' : list (transvection_struct n 𝕜))(D : n → 𝕜),\n      matrix.mul (matrix.mul (L.map to_matrix).prod M) (L'.map to_matrix).prod = diagonal D :=\n  by\n  have e : «expr ≃ » n (fin (fintype.card n)) := fintype.equiv_of_card_eq (by simp)\n  apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e\n  apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux\n#align exists_list_transvec_mul_mul_list_transvec_eq_diagonal exists_list_transvec_mul_mul_list_transvec_eq_diagonal\n\n",
 "exists_list_transvec_mul_diagonal_mul_list_transvec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Any matrix can be written as the product of transvections, a diagonal matrix, and\ntransvections.-/\ntheorem exists_list_transvec_mul_diagonal_mul_list_transvec (M : matrix n n 𝕜) :\n    ∃ (L L' : list (transvection_struct n 𝕜))(D : n → 𝕜),\n      M = matrix.mul (matrix.mul (L.map to_matrix).prod (diagonal D)) (L'.map to_matrix).prod :=\n  by\n  rcases exists_list_transvec_mul_mul_list_transvec_eq_diagonal M with ⟨L, L', D, h⟩\n  refine' ⟨L.reverse.map transvection_struct.inv, L'.reverse.map transvection_struct.inv, D, _⟩\n  suffices\n    M =\n      matrix.mul\n        (matrix.mul (matrix.mul (L.reverse.map (to_matrix ∘ transvection_struct.inv)).prod (L.map to_matrix).prod) M)\n        (matrix.mul (L'.map to_matrix).prod (L'.reverse.map (to_matrix ∘ transvection_struct.inv)).prod)\n    by simpa [← h, matrix.mul_assoc]\n  rw [reverse_inv_prod_mul_prod, prod_mul_reverse_inv_prod, matrix.one_mul, matrix.mul_one]\n#align exists_list_transvec_mul_diagonal_mul_list_transvec exists_list_transvec_mul_diagonal_mul_list_transvec\n\n",
 "exists_is_two_block_diagonal_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- There exist two lists of `transvection_struct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal, when the last coefficient is nonzero. -/\ntheorem exists_is_two_block_diagonal_of_ne_zero (hM : M (inr unit) (inr unit) ≠ 0) :\n    ∃ L L' : list (transvection_struct (Sum (fin r) unit) 𝕜),\n      is_two_block_diagonal (matrix.mul (matrix.mul (L.map to_matrix).prod M) (L'.map to_matrix).prod) :=\n  by\n  let L : list (transvection_struct (Sum (fin r) unit) 𝕜) :=\n    List.ofFn fun i : fin r => ⟨inl i, inr star, by simp, -M (inl i) (inr star) / M (inr star) (inr star)⟩\n  let L' : list (transvection_struct (Sum (fin r) unit) 𝕜) :=\n    List.ofFn fun i : fin r => ⟨inr star, inl i, by simp, -M (inr star) (inl i) / M (inr star) (inr star)⟩\n  refine' ⟨L, L', _⟩\n  have A : L.map to_matrix = list_transvec_col M := by simp [L, list_transvec_col, (· ∘ ·)]\n  have B : L'.map to_matrix = list_transvec_row M := by simp [L, list_transvec_row, (· ∘ ·)]\n  rw [A, B]\n  exact is_two_block_diagonal_list_transvec_col_mul_mul_list_transvec_row M hM\n#align exists_is_two_block_diagonal_of_ne_zero exists_is_two_block_diagonal_of_ne_zero\n\n",
 "exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- There exist two lists of `transvection_struct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal. -/\ntheorem exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec\n    (M : matrix (Sum (fin r) unit) (Sum (fin r) unit) 𝕜) :\n    ∃ L L' : list (transvection_struct (Sum (fin r) unit) 𝕜),\n      is_two_block_diagonal (matrix.mul (matrix.mul (L.map to_matrix).prod M) (L'.map to_matrix).prod) :=\n  by\n  by_cases H : is_two_block_diagonal M\n  · refine' ⟨list.nil, list.nil, by simpa using H⟩\n  -- we have already proved this when the last coefficient is nonzero\n  by_cases hM : M (inr star) (inr star) ≠ 0\n  · exact exists_is_two_block_diagonal_of_ne_zero M hM\n  -- when the last coefficient is zero but there is a nonzero coefficient on the last row or the\n  -- last column, we will first put this nonzero coefficient in last position, and then argue as\n  -- above.\n  push_neg  at hM\n  simp [not_and_or, is_two_block_diagonal, to_blocks₁₂, to_blocks₂₁, ← matrix.ext_iff] at H\n  have : ∃ i : fin r, M (inl i) (inr star) ≠ 0 ∨ M (inr star) (inl i) ≠ 0 :=\n    by\n    cases H\n    · contrapose! H\n      rintro i ⟨⟩\n      exact (H i).1\n    · contrapose! H\n      rintro ⟨⟩ j\n      exact (H j).2\n  rcases this with ⟨i, h | h⟩\n  · let M' := matrix.mul (transvection (inr Unit.unit) (inl i) 1) M\n    have hM' : M' (inr star) (inr star) ≠ 0 := by simpa [M', hM]\n    rcases exists_is_two_block_diagonal_of_ne_zero M' hM' with ⟨L, L', hLL'⟩\n    rw [matrix.mul_assoc] at hLL'\n    refine' ⟨L ++ [⟨inr star, inl i, by simp, 1⟩], L', _⟩\n    simp only [list.map_append, List.prod_append, matrix.mul_one, to_matrix_mk, List.prod_cons, List.prod_nil,\n      mul_eq_mul, list.map, matrix.mul_assoc (L.map to_matrix).prod]\n    exact hLL'\n  · let M' := matrix.mul M (transvection (inl i) (inr star) 1)\n    have hM' : M' (inr star) (inr star) ≠ 0 := by simpa [M', hM]\n    rcases exists_is_two_block_diagonal_of_ne_zero M' hM' with ⟨L, L', hLL'⟩\n    refine' ⟨L, sym.cons' ⟨inl i, inr star, by simp, 1⟩ L', _⟩\n    simp only [← matrix.mul_assoc, to_matrix_mk, List.prod_cons, mul_eq_mul, list.map]\n    rw [matrix.mul_assoc (L.map to_matrix).prod]\n    exact hLL'\n#align\n  exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec exists_is_two_block_diagonal_list_transvec_mul_mul_list_transvec\n\n",
 "diagonal_transvection_induction_of_det_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Induction principle for invertible matrices based on transvections: if a property is true for\nall invertible diagonal matrices, all transvections, and is stable under product of invertible\nmatrices, then it is true for all invertible matrices. This is the useful way to say that\ninvertible matrices are generated by invertible diagonal matrices and transvections. -/\ntheorem diagonal_transvection_induction_of_det_ne_zero (P : matrix n n 𝕜 → Prop) (M : matrix n n 𝕜) (hMdet : det M ≠ 0)\n    (hdiag : ∀ D : n → 𝕜, det (diagonal D) ≠ 0 → P (diagonal D))\n    (htransvec : ∀ t : transvection_struct n 𝕜, P t.to_matrix)\n    (hmul : ∀ A B, det A ≠ 0 → det B ≠ 0 → P A → P B → P (matrix.mul A B)) : P M :=\n  by\n  let Q : matrix n n 𝕜 → Prop := fun N => det N ≠ 0 ∧ P N\n  have : Q M := by\n    apply diagonal_transvection_induction Q M\n    · intro D hD\n      have detD : det (diagonal D) ≠ 0 := by\n        rw [hD]\n        exact hMdet\n      exact ⟨detD, hdiag _ detD⟩\n    · intro t\n      exact ⟨by simp, htransvec t⟩\n    · intro A B QA QB\n      exact ⟨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2⟩\n  exact this.2\n#align diagonal_transvection_induction_of_det_ne_zero diagonal_transvection_induction_of_det_ne_zero\n\n",
 "diagonal_transvection_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Induction principle for matrices based on transvections: if a property is true for all diagonal\nmatrices, all transvections, and is stable under product, then it is true for all matrices. This is\nthe useful way to say that matrices are generated by diagonal matrices and transvections.\n\nWe state a slightly more general version: to prove a property for a matrix `M`, it suffices to\nassume that the diagonal matrices we consider have the same determinant as `M`. This is useful to\nobtain similar principles for `SLₙ` or `GLₙ`. -/\ntheorem diagonal_transvection_induction (P : matrix n n 𝕜 → Prop) (M : matrix n n 𝕜)\n    (hdiag : ∀ D : n → 𝕜, det (diagonal D) = det M → P (diagonal D))\n    (htransvec : ∀ t : transvection_struct n 𝕜, P t.to_matrix) (hmul : ∀ A B, P A → P B → P (matrix.mul A B)) : P M :=\n  by\n  rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with ⟨L, L', D, h⟩\n  have PD : P (diagonal D) := hdiag D (by simp [h])\n  suffices H :\n    ∀ (L₁ L₂ : list (transvection_struct n 𝕜)) (E : matrix n n 𝕜),\n      P E → P (matrix.mul (matrix.mul (L₁.map to_matrix).prod E) (L₂.map to_matrix).prod)\n  · rw [h]\n    apply H L L'\n    exact PD\n  intro L₁ L₂ E PE\n  induction' L₁ with t L₁ IH\n  · simp only [matrix.one_mul, List.prod_nil, list.map]\n    induction' L₂ with t L₂ IH generalizing E\n    · simpa\n    · simp only [← matrix.mul_assoc, List.prod_cons, mul_eq_mul, list.map]\n      apply IH\n      exact hmul _ _ PE (htransvec _)\n  · simp only [matrix.mul_assoc, List.prod_cons, mul_eq_mul, list.map] at IH⊢\n    exact hmul _ _ (htransvec _) IH\n#align diagonal_transvection_induction diagonal_transvection_induction\n\n",
 "det_transvection_of_ne":
 "@[simp]\ntheorem det_transvection_of_ne (h : i ≠ j) (c : R) : det (transvection i j c) = 1 := by\n  rw [← update_row_eq_transvection i j, det_update_row_add_smul_self _ h, det_one]\n#align det_transvection_of_ne det_transvection_of_ne\n\n",
 "det_to_matrix_prod":
 "@[simp]\ntheorem det_to_matrix_prod [fintype n] (L : list (transvection_struct n 𝕜)) : det (L.map to_matrix).prod = 1 :=\n  by\n  induction' L with t L IH\n  · simp\n  · simp [IH]\n#align det_to_matrix_prod det_to_matrix_prod\n\n",
 "det":
 "@[simp]\nprotected theorem det [fintype n] (t : transvection_struct n R) : det t.to_matrix = 1 :=\n  det_transvection_of_ne _ _ t.hij _\n#align det det\n\n"}