{"mv_polynomial_X_map_matrix_eval":
 "/-- A variant of `matrix.mv_polynomial_X_map_eval₂` with a bundled `ring_hom` on the LHS. -/\ntheorem mv_polynomial_X_map_matrix_eval [fintype m] [decidable_eq m] [CommSemiring R] (A : matrix m m R) :\n    (mv_polynomial.eval fun p : m × m => A p.1 p.2).map_matrix (mv_polynomial_X m m R) = A :=\n  mv_polynomial_X_map_eval₂ _ A\n#align mv_polynomial_X_map_matrix_eval mv_polynomial_X_map_matrix_eval\n\n",
 "mv_polynomial_X_map_matrix_aeval":
 "/-- A variant of `matrix.mv_polynomial_X_map_eval₂` with a bundled `alg_hom` on the LHS. -/\ntheorem mv_polynomial_X_map_matrix_aeval [fintype m] [decidable_eq m] [CommSemiring R] [CommSemiring S] [algebra R S]\n    (A : matrix m m S) : (mv_polynomial.aeval fun p : m × m => A p.1 p.2).map_matrix (mv_polynomial_X m m R) = A :=\n  mv_polynomial_X_map_eval₂ _ A\n#align mv_polynomial_X_map_matrix_aeval mv_polynomial_X_map_matrix_aeval\n\n",
 "mv_polynomial_X_map_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n/-- Any matrix `A` can be expressed as the evaluation of `matrix.mv_polynomial_X`.\n\nThis is of particular use when `mv_polynomial (m × n) R` is an integral domain but `S` is\nnot, as if the `mv_polynomial.eval₂` can be pulled to the outside of a goal, it can be solved in\nunder cancellative assumptions. -/\ntheorem mv_polynomial_X_map_eval₂ [CommSemiring R] [CommSemiring S] (f : «expr →+* » R S) (A : matrix m n S) :\n    (mv_polynomial_X m n R).map (mv_polynomial.eval₂ f fun p : m × n => A p.1 p.2) = A :=\n  ext fun i j => mv_polynomial.eval₂_X _ (fun p : m × n => A p.1 p.2) (i, j)\n#align mv_polynomial_X_map_eval₂ mv_polynomial_X_map_eval₂\n\n",
 "det_mv_polynomial_X_ne_zero":
 "/-- In a nontrivial ring, `matrix.mv_polynomial_X m m R` has non-zero determinant. -/\ntheorem det_mv_polynomial_X_ne_zero [decidable_eq m] [fintype m] [CommRing R] [nontrivial R] :\n    det (mv_polynomial_X m m R) ≠ 0 := by\n  intro h_det\n  have := congr_arg matrix.det (mv_polynomial_X_map_matrix_eval (1 : matrix m m R))\n  rw [det_one, ← ring_hom.map_det, h_det, RingHom.map_zero] at this\n  exact zero_ne_one this\n#align det_mv_polynomial_X_ne_zero det_mv_polynomial_X_ne_zero\n\n"}