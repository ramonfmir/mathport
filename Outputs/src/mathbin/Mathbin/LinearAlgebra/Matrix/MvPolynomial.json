{"mv_polynomial_X_map_matrix_eval":
 "/-- A variant of `matrix.mv_polynomial_X_map_eval₂` with a bundled `ring_hom` on the LHS. -/\ntheorem mv_polynomial_X_map_matrix_eval [Fintype m] [DecidableEq m] [CommSemiring R] (A : Matrix m m R) :\n    (MvPolynomial.eval fun p : m × m => A p.1 p.2).map_matrix (mvPolynomialX m m R) = A :=\n  mvPolynomialX_map_eval₂ _ A\n#align mv_polynomial_X_map_matrix_eval mv_polynomial_X_map_matrix_eval\n\n",
 "mv_polynomial_X_map_matrix_aeval":
 "/-- A variant of `matrix.mv_polynomial_X_map_eval₂` with a bundled `alg_hom` on the LHS. -/\ntheorem mv_polynomial_X_map_matrix_aeval [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S] [Algebra R S]\n    (A : Matrix m m S) : (MvPolynomial.aeval fun p : m × m => A p.1 p.2).map_matrix (mvPolynomialX m m R) = A :=\n  mvPolynomialX_map_eval₂ _ A\n#align mv_polynomial_X_map_matrix_aeval mv_polynomial_X_map_matrix_aeval\n\n",
 "mv_polynomial_X_map_eval₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- Any matrix `A` can be expressed as the evaluation of `matrix.mv_polynomial_X`.\n\nThis is of particular use when `mv_polynomial (m × n) R` is an integral domain but `S` is\nnot, as if the `mv_polynomial.eval₂` can be pulled to the outside of a goal, it can be solved in\nunder cancellative assumptions. -/\ntheorem mv_polynomial_X_map_eval₂ [CommSemiring R] [CommSemiring S] (f : «expr →+* » R S) (A : Matrix m n S) :\n    (mvPolynomialX m n R).map (MvPolynomial.eval₂ f fun p : m × n => A p.1 p.2) = A :=\n  ext fun i j => MvPolynomial.eval₂_X _ (fun p : m × n => A p.1 p.2) (i, j)\n#align mv_polynomial_X_map_eval₂ mv_polynomial_X_map_eval₂\n\n",
 "mv_polynomial_X_apply":
 "/-\nCopyright (c) 2021 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n-- TODO: set as an equation lemma for `mv_polynomial_X`, see mathlib4#3024\n@[simp]\ntheorem mv_polynomial_X_apply [CommSemiring R] (i j) : mvPolynomialX m n R i j = MvPolynomial.X (i, j) :=\n  rfl\n#align mv_polynomial_X_apply mv_polynomial_X_apply\n\n",
 "det_mv_polynomial_X_ne_zero":
 "/-- In a nontrivial ring, `matrix.mv_polynomial_X m m R` has non-zero determinant. -/\ntheorem det_mv_polynomial_X_ne_zero [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] :\n    det (mvPolynomialX m m R) ≠ 0 := by\n  intro h_det\n  have := congr_arg Matrix.det (mv_polynomial_X_map_matrix_eval (1 : Matrix m m R))\n  rw [det_one, ← RingHom.map_det, h_det, RingHom.map_zero] at this\n  exact zero_ne_one this\n#align det_mv_polynomial_X_ne_zero det_mv_polynomial_X_ne_zero\n\n"}