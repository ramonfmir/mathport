{"to_linear_equiv'_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n@[simp]\ntheorem to_linear_equiv'_symm_apply (P : Matrix n n R) (h : Invertible P) :\n    (↑(P.to_linear_equiv' h).symm : Module.End R (n → R)) = ((«expr⅟») P).to_lin' :=\n  rfl\n#align to_linear_equiv'_symm_apply to_linear_equiv'_symm_apply\n\n",
 "to_linear_equiv'_apply":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\n@[simp]\ntheorem to_linear_equiv'_apply (P : Matrix n n R) (h : Invertible P) :\n    (↑(P.to_linear_equiv' h) : Module.End R (n → R)) = P.to_lin' :=\n  rfl\n#align to_linear_equiv'_apply to_linear_equiv'_apply\n\n",
 "range_to_lin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_to_lin_eq_top [DecidableEq n] (A : Matrix n n R) (hA : IsUnit A.det) : (toLin b b A).range = «expr⊤» :=\n  range_eq_top.mpr (to_linear_equiv b A hA).surjective\n#align range_to_lin_eq_top range_to_lin_eq_top\n\n",
 "nondegenerate_iff_det_ne_zero":
 "theorem nondegenerate_iff_det_ne_zero {A : Type _} [DecidableEq n] [CommRing A] [IsDomain A] {M : Matrix n n A} :\n    Nondegenerate M ↔ M.det ≠ 0 :=\n  by\n  refine' iff.trans _ (not_iff_not.mpr exists_vec_mul_eq_zero_iff)\n  simp only [not_exists]\n  constructor\n  · intro hM v hv hMv\n    obtain ⟨w, hwMv⟩ := hM.exists_not_ortho_of_ne_zero hv\n    simpa only [dot_product_mul_vec, hMv, zero_dot_product] using hwMv\n  · intro h v hv\n    refine' not_imp_not.mp (h v) (funext fun i => _)\n    simpa only [dot_product_mul_vec, dot_product_single, mul_one] using hv (Pi.single i 1)\n#align nondegenerate_iff_det_ne_zero nondegenerate_iff_det_ne_zero\n\n",
 "ker_to_lin_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_to_lin_eq_bot [DecidableEq n] (A : Matrix n n R) (hA : IsUnit A.det) : (toLin b b A).ker = «expr⊥» :=\n  ker_eq_bot.mpr (to_linear_equiv b A hA).injective\n#align ker_to_lin_eq_bot ker_to_lin_eq_bot\n\n",
 "exists_vec_mul_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (v «expr ≠ » 0) -/\ntheorem exists_vec_mul_eq_zero_iff {A : Type _} [DecidableEq n] [CommRing A] [IsDomain A] {M : Matrix n n A} :\n    (∃ (v : _)(_ : v ≠ 0), M.vec_mul v = 0) ↔ M.det = 0 := by\n  simpa only [← M.det_transpose, ← mul_vec_transpose] using exists_mul_vec_eq_zero_iff\n#align exists_vec_mul_eq_zero_iff exists_vec_mul_eq_zero_iff\n\n",
 "exists_mul_vec_eq_zero_iff_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (v «expr ≠ » 0) -/\n/-- This holds for all integral domains (see `matrix.exists_mul_vec_eq_zero_iff`),\nnot just fields, but it's easier to prove it for the field of fractions first. -/\ntheorem exists_mul_vec_eq_zero_iff_aux {K : Type _} [DecidableEq n] [Field K] {M : Matrix n n K} :\n    (∃ (v : _)(_ : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0 :=\n  by\n  constructor\n  · rintro ⟨v, hv, mul_eq⟩\n    contrapose! hv\n    exact eq_zero_of_mul_vec_eq_zero hv mul_eq\n  · contrapose!\n    intro h\n    have : function.injective M.to_lin' := by\n      simpa only [← LinearMap.ker_eq_bot, ker_to_lin'_eq_bot_iff, not_imp_not] using h\n    have :\n      matrix.mul M\n          (LinearMap.toMatrix' ((LinearEquiv.ofInjectiveEndo M.to_lin' this).symm : «expr →ₗ[ ] » (n → K) K (n → K))) =\n        1 :=\n      by\n      refine' matrix.to_lin'.injective (LinearMap.ext fun v => _)\n      rw [Matrix.toLin'_mul, Matrix.toLin'_one, Matrix.toLin'_toMatrix', LinearMap.comp_apply]\n      exact (LinearEquiv.ofInjectiveEndo M.to_lin' this).apply_symm_apply v\n    exact Matrix.det_ne_zero_of_right_inverse this\n#align exists_mul_vec_eq_zero_iff_aux exists_mul_vec_eq_zero_iff_aux\n\n",
 "exists_mul_vec_eq_zero_iff'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (v «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (v «expr ≠ » 0) -/\ntheorem exists_mul_vec_eq_zero_iff' {A : Type _} (K : Type _) [DecidableEq n] [CommRing A] [Nontrivial A] [Field K]\n    [Algebra A K] [IsFractionRing A K] {M : Matrix n n A} : (∃ (v : _)(_ : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0 :=\n  by\n  have : (∃ (v : _)(_ : v ≠ 0), mul_vec ((algebraMap A K).map_matrix M) v = 0) ↔ _ := exists_mul_vec_eq_zero_iff_aux\n  rw [← RingHom.map_det, IsFractionRing.to_map_eq_zero_iff] at this\n  refine' iff.trans _ this; constructor <;> rintro ⟨v, hv, mul_eq⟩\n  · refine' ⟨fun i => algebraMap _ _ (v i), mt (fun h => funext fun i => _) hv, _⟩\n    · exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i)\n    · ext i\n      refine' (RingHom.map_mulVec _ _ _ i).symm.trans _\n      rw [mul_eq, Pi.zero_apply, RingHom.map_zero, Pi.zero_apply]\n  · letI := Classical.decEq K\n    obtain ⟨⟨b, hb⟩, ba_eq⟩ :=\n      IsLocalization.exist_integer_multiples_of_finset (nonZeroDivisors A) (finset.univ.image v)\n    choose f hf using ba_eq\n    refine' ⟨fun i => f _ (finset.mem_image.mpr ⟨i, Finset.mem_univ i, rfl⟩), mt (fun h => funext fun i => _) hv, _⟩\n    · have := congr_arg (algebraMap A K) (congr_fun h i)\n      rw [hf, Subtype.coe_mk, Pi.zero_apply, RingHom.map_zero, Algebra.smul_def, mul_eq_zero,\n        IsFractionRing.to_map_eq_zero_iff] at this\n      exact this.resolve_left (nonZeroDivisors.ne_zero hb)\n    · ext i\n      refine' IsFractionRing.injective A K _\n      calc\n        algebraMap A K (M.mul_vec (fun i : n => f (v i) _) i) =\n            ((algebraMap A K).map_matrix M).mul_vec («expr • » (algebraMap _ K b) v) i :=\n          _\n        _ = 0 := _\n        _ = algebraMap A K 0 := (RingHom.map_zero _).symm\n        \n      ·\n        simp_rw [RingHom.map_mulVec, mul_vec, dot_product, Function.comp_apply, hf, Subtype.coe_mk,\n          ring_hom.map_matrix_apply, Pi.smul_apply, smul_eq_mul, Algebra.smul_def]\n      · rw [mul_vec_smul, mul_eq, Pi.smul_apply, Pi.zero_apply, smul_zero]\n#align exists_mul_vec_eq_zero_iff' exists_mul_vec_eq_zero_iff'\n\n",
 "exists_mul_vec_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (v «expr ≠ » 0) -/\ntheorem exists_mul_vec_eq_zero_iff {A : Type _} [DecidableEq n] [CommRing A] [IsDomain A] {M : Matrix n n A} :\n    (∃ (v : _)(_ : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0 :=\n  exists_mul_vec_eq_zero_iff' (FractionRing A)\n#align exists_mul_vec_eq_zero_iff exists_mul_vec_eq_zero_iff\n\n"}