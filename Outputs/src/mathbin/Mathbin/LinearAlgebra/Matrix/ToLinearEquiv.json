{"to_linear_equiv'_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n@[simp]\ntheorem to_linear_equiv'_symm_apply (P : matrix n n R) (h : Invertible P) :\n    (↑(P.to_linear_equiv' h).symm : module.End R (n → R)) = P⁻¹.to_lin' :=\n  show ((«expr⅟») P).to_lin' = _ from congr_arg _ P.inv_of_eq_nonsing_inv\n#align to_linear_equiv'_symm_apply to_linear_equiv'_symm_apply\n\n",
 "to_linear_equiv'_apply":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\n@[simp]\ntheorem to_linear_equiv'_apply (P : matrix n n R) (h : Invertible P) :\n    (↑(P.to_linear_equiv' h) : module.End R (n → R)) = P.to_lin' :=\n  rfl\n#align to_linear_equiv'_apply to_linear_equiv'_apply\n\n",
 "range_to_lin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_to_lin_eq_top [decidable_eq n] (A : matrix n n R) (hA : is_unit A.det) : (to_lin b b A).range = «expr⊤» :=\n  range_eq_top.mpr (to_linear_equiv b A hA).surjective\n#align range_to_lin_eq_top range_to_lin_eq_top\n\n",
 "nondegenerate_iff_det_ne_zero":
 "theorem nondegenerate_iff_det_ne_zero {A : Type _} [decidable_eq n] [CommRing A] [IsDomain A] {M : matrix n n A} :\n    nondegenerate M ↔ M.det ≠ 0 :=\n  by\n  refine' iff.trans _ (not_iff_not.mpr exists_vec_mul_eq_zero_iff)\n  simp only [not_exists]\n  constructor\n  · intro hM v hv hMv\n    obtain ⟨w, hwMv⟩ := hM.exists_not_ortho_of_ne_zero hv\n    simpa only [dot_product_mul_vec, hMv, zero_dot_product] using hwMv\n  · intro h v hv\n    refine' not_imp_not.mp (h v) (funext fun i => _)\n    simpa only [dot_product_mul_vec, dot_product_single, mul_one] using hv (Pi.single i 1)\n#align nondegenerate_iff_det_ne_zero nondegenerate_iff_det_ne_zero\n\n",
 "ker_to_lin_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_to_lin_eq_bot [decidable_eq n] (A : matrix n n R) (hA : is_unit A.det) : (to_lin b b A).ker = «expr⊥» :=\n  ker_eq_bot.mpr (to_linear_equiv b A hA).injective\n#align ker_to_lin_eq_bot ker_to_lin_eq_bot\n\n",
 "exists_vec_mul_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (v «expr ≠ » 0) -/\ntheorem exists_vec_mul_eq_zero_iff {A : Type _} [decidable_eq n] [CommRing A] [IsDomain A] {M : matrix n n A} :\n    (∃ (v : _)(_ : v ≠ 0), M.vec_mul v = 0) ↔ M.det = 0 := by\n  simpa only [← M.det_transpose, ← mul_vec_transpose] using exists_mul_vec_eq_zero_iff\n#align exists_vec_mul_eq_zero_iff exists_vec_mul_eq_zero_iff\n\n",
 "exists_mul_vec_eq_zero_iff_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (v «expr ≠ » 0) -/\n/-- This holds for all integral domains (see `matrix.exists_mul_vec_eq_zero_iff`),\nnot just fields, but it's easier to prove it for the field of fractions first. -/\ntheorem exists_mul_vec_eq_zero_iff_aux {K : Type _} [decidable_eq n] [Field K] {M : matrix n n K} :\n    (∃ (v : _)(_ : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0 :=\n  by\n  constructor\n  · rintro ⟨v, hv, mul_eq⟩\n    contrapose! hv\n    exact eq_zero_of_mul_vec_eq_zero hv mul_eq\n  · contrapose!\n    intro h\n    have : function.injective M.to_lin' := by\n      simpa only [← linear_map.ker_eq_bot, ker_to_lin'_eq_bot_iff, not_imp_not] using h\n    have :\n      matrix.mul M\n          (linear_map.to_matrix'\n            ((linear_equiv.of_injective_endo M.to_lin' this).symm : «expr →ₗ[ ] » (n → K) K (n → K))) =\n        1 :=\n      by\n      refine' matrix.to_lin'.injective (linear_map.ext fun v => _)\n      rw [matrix.to_lin'_mul, matrix.to_lin'_one, matrix.to_lin'_to_matrix', linear_map.comp_apply]\n      exact (linear_equiv.of_injective_endo M.to_lin' this).apply_symm_apply v\n    exact matrix.det_ne_zero_of_right_inverse this\n#align exists_mul_vec_eq_zero_iff_aux exists_mul_vec_eq_zero_iff_aux\n\n",
 "exists_mul_vec_eq_zero_iff'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (v «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (v «expr ≠ » 0) -/\ntheorem exists_mul_vec_eq_zero_iff' {A : Type _} (K : Type _) [decidable_eq n] [CommRing A] [nontrivial A] [Field K]\n    [algebra A K] [is_fraction_ring A K] {M : matrix n n A} : (∃ (v : _)(_ : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0 :=\n  by\n  have : (∃ (v : _)(_ : v ≠ 0), mul_vec ((algebra_map A K).map_matrix M) v = 0) ↔ _ := exists_mul_vec_eq_zero_iff_aux\n  rw [← ring_hom.map_det, is_fraction_ring.to_map_eq_zero_iff] at this\n  refine' iff.trans _ this; constructor <;> rintro ⟨v, hv, mul_eq⟩\n  · refine' ⟨fun i => algebra_map _ _ (v i), mt (fun h => funext fun i => _) hv, _⟩\n    · exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i)\n    · ext i\n      refine' (ring_hom.map_mul_vec _ _ _ i).symm.trans _\n      rw [mul_eq, pi.zero_apply, RingHom.map_zero, pi.zero_apply]\n  · letI := classical.dec_eq K\n    obtain ⟨⟨b, hb⟩, ba_eq⟩ :=\n      is_localization.exist_integer_multiples_of_finset (non_zero_divisors A) (finset.univ.image v)\n    choose f hf using ba_eq\n    refine' ⟨fun i => f _ (finset.mem_image.mpr ⟨i, finset.mem_univ i, rfl⟩), mt (fun h => funext fun i => _) hv, _⟩\n    · have := congr_arg (algebra_map A K) (congr_fun h i)\n      rw [hf, subtype.coe_mk, pi.zero_apply, RingHom.map_zero, algebra.smul_def, mul_eq_zero,\n        is_fraction_ring.to_map_eq_zero_iff] at this\n      exact this.resolve_left (non_zero_divisors.ne_zero hb)\n    · ext i\n      refine' is_fraction_ring.injective A K _\n      calc\n        algebra_map A K (M.mul_vec (fun i : n => f (v i) _) i) =\n            ((algebra_map A K).map_matrix M).mul_vec («expr • » (algebra_map _ K b) v) i :=\n          _\n        _ = 0 := _\n        _ = algebra_map A K 0 := (RingHom.map_zero _).symm\n        \n      ·\n        simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, Function.comp_apply, hf, subtype.coe_mk,\n          ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def]\n      · rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero]\n#align exists_mul_vec_eq_zero_iff' exists_mul_vec_eq_zero_iff'\n\n",
 "exists_mul_vec_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (v «expr ≠ » 0) -/\ntheorem exists_mul_vec_eq_zero_iff {A : Type _} [decidable_eq n] [CommRing A] [IsDomain A] {M : matrix n n A} :\n    (∃ (v : _)(_ : v ≠ 0), M.mul_vec v = 0) ↔ M.det = 0 :=\n  exists_mul_vec_eq_zero_iff' (fraction_ring A)\n#align exists_mul_vec_eq_zero_iff exists_mul_vec_eq_zero_iff\n\n"}