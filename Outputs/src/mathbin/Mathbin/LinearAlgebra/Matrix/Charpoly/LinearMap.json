{"zero":
 "theorem matrix.represents.zero : (0 : Matrix ι ι R).represents b 0 := by delta matrix.represents;\n  rw [map_zero, map_zero]\n#align matrix.represents.zero matrix.represents.zero\n\n",
 "to_End_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem matrix.is_representation.to_End_surjective : function.surjective (matrix.is_representation.to_End R b hb) :=\n  by\n  intro f\n  obtain ⟨M, e, -⟩ := matrix.is_representation.to_End_exists_mem_ideal R b hb f («expr⊤») _\n  exact ⟨M, e⟩\n  simp\n#align matrix.is_representation.to_End_surjective matrix.is_representation.to_End_surjective\n\n",
 "to_End_represents":
 "theorem matrix.is_representation.to_End_represents (A : matrix.is_representation R b) :\n    (A : Matrix ι ι R).represents b (matrix.is_representation.to_End R b hb A) :=\n  A.2.some_spec\n#align matrix.is_representation.to_End_represents matrix.is_representation.to_End_represents\n\n",
 "to_End_exists_mem_ideal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem matrix.is_representation.to_End_exists_mem_ideal (f : Module.End R M) (I : Ideal R)\n    (hI : f.range ≤ «expr • » I («expr⊤»)) : ∃ M, matrix.is_representation.to_End R b hb M = f ∧ ∀ i j, M.1 i j ∈ I :=\n  by\n  have : ∀ x, f x ∈ (Ideal.finsuppTotal ι M I b).range :=\n    by\n    rw [Ideal.range_finsuppTotal, hb]\n    exact fun x => hI (f.mem_range_self x)\n  choose bM' hbM'\n  let A : Matrix ι ι R := fun i j => bM' (b j) i\n  have : A.represents b f := by\n    rw [matrix.represents_iff']\n    dsimp [A]\n    intro j\n    specialize hbM' (b j)\n    rwa [Ideal.finsuppTotal_apply_eq_of_fintype] at hbM'\n  exact\n    ⟨⟨A, f, this⟩, matrix.is_representation.eq_to_End_of_represents R b hb ⟨A, f, this⟩ this, fun i j =>\n      (bM' (b j) i).prop⟩\n#align matrix.is_representation.to_End_exists_mem_ideal matrix.is_representation.to_End_exists_mem_ideal\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem matrix.represents.smul {A : Matrix ι ι R} {f : Module.End R M} (h : A.represents b f) (r : R) :\n    («expr • » r A).represents b («expr • » r f) := by delta matrix.represents at h⊢; rw [map_smul, map_smul, h]\n#align matrix.represents.smul matrix.represents.smul\n\n",
 "represents_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem matrix.represents_iff' {A : Matrix ι ι R} {f : Module.End R M} :\n    A.represents b f ↔\n      ∀ j,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (A i j) (b i)) =\n          f (b j) :=\n  by\n  constructor\n  · intro h i\n    have := LinearMap.congr_fun h (Pi.single i 1)\n    rwa [pi_to_module.from_End_apply_single_one, pi_to_module.from_matrix_apply_single_one] at this\n  · intro h\n    ext\n    simp_rw [LinearMap.comp_apply, LinearMap.coe_single, pi_to_module.from_End_apply_single_one,\n      pi_to_module.from_matrix_apply_single_one]\n    apply h\n#align matrix.represents_iff' matrix.represents_iff'\n\n",
 "represents_iff":
 "theorem matrix.represents_iff {A : Matrix ι ι R} {f : Module.End R M} :\n    A.represents b f ↔ ∀ x, Fintype.total R R b (A.mul_vec x) = f (Fintype.total R R b x) :=\n  ⟨fun e x => e.congr_fun x, fun H => LinearMap.ext fun x => H x⟩\n#align matrix.represents_iff matrix.represents_iff\n\n",
 "one":
 "theorem matrix.represents.one : (1 : Matrix ι ι R).represents b 1 :=\n  by\n  delta matrix.represents pi_to_module.from_matrix\n  rw [LinearMap.comp_apply, AlgEquiv.toLinearMap_apply, map_one]\n  ext\n  rfl\n#align matrix.represents.one matrix.represents.one\n\n",
 "mul":
 "theorem matrix.represents.mul {A A' : Matrix ι ι R} {f f' : Module.End R M} (h : A.represents b f)\n    (h' : matrix.represents b A' f') : (A * A').represents b (f * f') :=\n  by\n  delta matrix.represents pi_to_module.from_matrix\n  rw [LinearMap.comp_apply, AlgEquiv.toLinearMap_apply, map_mul]\n  ext\n  dsimp [pi_to_module.from_End]\n  rw [← h'.congr_fun, ← h.congr_fun]\n  rfl\n#align matrix.represents.mul matrix.represents.mul\n\n",
 "from_matrix_apply_single_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pi_to_module.from_matrix_apply_single_one [DecidableEq ι] (A : Matrix ι ι R) (j : ι) :\n    pi_to_module.from_matrix R b A (Pi.single j 1) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (A i j) (b i)) :=\n  by\n  rw [pi_to_module.from_matrix_apply, Fintype.total_apply, Matrix.mulVec_single]\n  simp_rw [mul_one]\n#align pi_to_module.from_matrix_apply_single_one pi_to_module.from_matrix_apply_single_one\n\n",
 "from_matrix_apply":
 "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem pi_to_module.from_matrix_apply [DecidableEq ι] (A : Matrix ι ι R) (w : ι → R) :\n    pi_to_module.from_matrix R b A w = Fintype.total R R b (A.mul_vec w) :=\n  rfl\n#align pi_to_module.from_matrix_apply pi_to_module.from_matrix_apply\n\n",
 "from_End_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem pi_to_module.from_End_injective (hb : Submodule.span R (Set.range b) = «expr⊤») :\n    function.injective (pi_to_module.from_End R b) := by\n  intro x y e\n  ext m\n  obtain ⟨m, rfl⟩ : m ∈ (Fintype.total R R b).range :=\n    by\n    rw [(Fintype.range_total R b).trans hb]\n    trivial\n  exact (LinearMap.congr_fun e m : _)\n#align pi_to_module.from_End_injective pi_to_module.from_End_injective\n\n",
 "from_End_apply_single_one":
 "theorem pi_to_module.from_End_apply_single_one [DecidableEq ι] (f : Module.End R M) (i : ι) :\n    pi_to_module.from_End R b f (Pi.single i 1) = f (b i) :=\n  by\n  rw [pi_to_module.from_End_apply]\n  congr\n  convert Fintype.total_apply_single R b i 1\n  rw [one_smul]\n#align pi_to_module.from_End_apply_single_one pi_to_module.from_End_apply_single_one\n\n",
 "from_End_apply":
 "theorem pi_to_module.from_End_apply (f : Module.End R M) (w : ι → R) :\n    pi_to_module.from_End R b f w = f (Fintype.total R R b w) :=\n  rfl\n#align pi_to_module.from_End_apply pi_to_module.from_End_apply\n\n",
 "exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The **Cayley-Hamilton Theorem** for f.g. modules over arbitrary rings states that for each\n`R`-endomorphism `φ` of an `R`-module `M` such that `φ(M) ≤ I • M` for some ideal `I`, there\nexists some `n` and some `aᵢ ∈ Iⁱ` such that `φⁿ + a₁ φⁿ⁻¹ + ⋯ + aₙ = 0`.\n\nThis is the version found in Eisenbud 4.3, which is slightly weaker than Matsumura 2.1\n(this lacks the constraint on `n`), and is slightly stronger than Atiyah-Macdonald 2.4.\n-/\ntheorem linear_map.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul [Module.Finite R M]\n    (f : Module.End R M) (I : Ideal R) (hI : f.range ≤ «expr • » I («expr⊤»)) :\n    ∃ p : polynomial R, p.monic ∧ (∀ k, p.coeff k ∈ I ^ (p.nat_degree - k)) ∧ Polynomial.aeval f p = 0 := by\n  classical\n    cases subsingleton_or_nontrivial R\n    · exact ⟨0, Polynomial.monic_of_subsingleton _, by simp⟩\n    obtain ⟨s : Finset M, hs : Submodule.span R (s : Set M) = «expr⊤»⟩ := module.finite.out\n    obtain ⟨A, rfl, h⟩ :=\n      matrix.is_representation.to_End_exists_mem_ideal R (coe : s → M)\n        (by rw [Subtype.range_coe_subtype, Finset.setOf_mem, hs]) f I hI\n    refine' ⟨A.1.charpoly, A.1.charpoly_monic, _, _⟩\n    · rw [A.1.charpoly_nat_degree_eq_dim]\n      exact coeff_charpoly_mem_ideal_pow h\n    · rw [Polynomial.aeval_algHom_apply, ← map_zero (matrix.is_representation.to_End R coe _)]\n      congr 1\n      ext1\n      rw [Polynomial.aeval_subalgebra_coe, subtype.val_eq_coe, matrix.aeval_self_charpoly, Subalgebra.coe_zero]\n    · infer_instance\n#align linear_map.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul linear_map.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul\n\n",
 "exists_monic_and_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem linear_map.exists_monic_and_aeval_eq_zero [Module.Finite R M] (f : Module.End R M) :\n    ∃ p : polynomial R, p.monic ∧ Polynomial.aeval f p = 0 :=\n  (linear_map.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul R f («expr⊤») (by simp)).imp fun p h =>\n    h.imp_right And.right\n#align linear_map.exists_monic_and_aeval_eq_zero linear_map.exists_monic_and_aeval_eq_zero\n\n",
 "eq_to_End_of_represents":
 "theorem matrix.is_representation.eq_to_End_of_represents (A : matrix.is_representation R b) {f : Module.End R M}\n    (h : (A : Matrix ι ι R).represents b f) : matrix.is_representation.to_End R b hb A = f :=\n  A.2.some_spec.eq hb h\n#align matrix.is_representation.eq_to_End_of_represents matrix.is_representation.eq_to_End_of_represents\n\n",
 "eq":
 "theorem matrix.represents.eq {A : Matrix ι ι R} {f f' : Module.End R M} (h : A.represents b f)\n    (h' : A.represents b f') : f = f' :=\n  pi_to_module.from_End_injective R b hb (h.symm.trans h')\n#align matrix.represents.eq matrix.represents.eq\n\n",
 "congr_fun":
 "theorem matrix.represents.congr_fun {A : Matrix ι ι R} {f : Module.End R M} (h : A.represents b f) (x) :\n    Fintype.total R R b (A.mul_vec x) = f (Fintype.total R R b x) :=\n  LinearMap.congr_fun h x\n#align matrix.represents.congr_fun matrix.represents.congr_fun\n\n",
 "add":
 "theorem matrix.represents.add {A A' : Matrix ι ι R} {f f' : Module.End R M} (h : A.represents b f)\n    (h' : matrix.represents b A' f') : (A + A').represents b (f + f') := by delta matrix.represents at h h'⊢;\n  rw [map_add, map_add, h, h']\n#align matrix.represents.add matrix.represents.add\n\n"}