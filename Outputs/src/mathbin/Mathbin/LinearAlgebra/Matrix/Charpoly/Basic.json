{"mat_poly_equiv_charmatrix":
 "theorem mat_poly_equiv_charmatrix (M : Matrix n n R) : mat_poly_equiv (charmatrix M) = X - C M :=\n  by\n  ext (k i j)\n  simp only [mat_poly_equiv_coeff_apply, coeff_sub, Pi.sub_apply]\n  by_cases h : i = j\n  · subst h\n    rw [charmatrix_apply_eq, coeff_sub]\n    simp only [coeff_X, coeff_C]\n    split_ifs <;> simp\n  · rw [charmatrix_apply_ne _ _ _ h, coeff_X, coeff_neg, coeff_C, coeff_C]\n    split_ifs <;> simp [h]\n#align mat_poly_equiv_charmatrix mat_poly_equiv_charmatrix\n\n",
 "charpoly_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem matrix.charpoly_reindex {m : Type v} [DecidableEq m] [Fintype m] (e : «expr ≃ » n m) (M : Matrix n n R) :\n    (reindex e e M).charpoly = M.charpoly := by\n  unfold matrix.charpoly\n  rw [charmatrix_reindex, Matrix.det_reindex_self]\n#align matrix.charpoly_reindex matrix.charpoly_reindex\n\n",
 "charmatrix_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem charmatrix_reindex {m : Type v} [DecidableEq m] [Fintype m] (e : «expr ≃ » n m) (M : Matrix n n R) :\n    charmatrix (reindex e e M) = reindex e e (charmatrix M) :=\n  by\n  ext (i j x)\n  by_cases h : i = j\n  all_goals simp [h]\n#align charmatrix_reindex charmatrix_reindex\n\n",
 "charmatrix_apply_ne":
 "@[simp]\ntheorem charmatrix_apply_ne (M : Matrix n n R) (i j : n) (h : i ≠ j) : charmatrix M i j = -C (M i j) := by\n  simp only [charmatrix, Pi.sub_apply, scalar_apply_ne _ _ _ h, zero_sub, ring_hom.map_matrix_apply, map_apply,\n    DMatrix.sub_apply]\n#align charmatrix_apply_ne charmatrix_apply_ne\n\n",
 "charmatrix_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem charmatrix_apply_eq (M : Matrix n n R) (i : n) : charmatrix M i i = (X : polynomial R) - C (M i i) := by\n  simp only [charmatrix, sub_left_inj, Pi.sub_apply, scalar_apply_eq, ring_hom.map_matrix_apply, map_apply,\n    DMatrix.sub_apply]\n#align charmatrix_apply_eq charmatrix_apply_eq\n\n",
 "charmatrix_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\ntheorem charmatrix_apply (M : Matrix n n R) (i j : n) :\n    charmatrix M i j = X * (1 : Matrix n n (polynomial R)) i j - C (M i j) :=\n  rfl\n#align charmatrix_apply charmatrix_apply\n\n",
 "aeval_self_charpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- This proof follows http://drorbn.net/AcademicPensieve/2015-12/CayleyHamilton.pdf\n/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,\napplied to the matrix itself, is zero.\n\nThis holds over any commutative ring.\n\nSee `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.\n-/\ntheorem matrix.aeval_self_charpoly (M : Matrix n n R) : aeval M M.charpoly = 0 :=\n  by\n  -- We begin with the fact $χ_M(t) I = adjugate (t I - M) * (t I - M)$,\n  -- as an identity in `matrix n n R[X]`.\n  have h : «expr • » M.charpoly (1 : Matrix n n (polynomial R)) = adjugate (charmatrix M) * charmatrix M :=\n    (adjugate_mul _).symm\n  -- Using the algebra isomorphism `matrix n n R[X] ≃ₐ[R] polynomial (matrix n n R)`,\n  -- we have the same identity in `polynomial (matrix n n R)`.\n  apply_fun mat_poly_equiv  at h\n  simp only [mat_poly_equiv.map_mul, mat_poly_equiv_charmatrix] at h\n  -- Because the coefficient ring `matrix n n R` is non-commutative,\n  -- evaluation at `M` is not multiplicative.\n  -- However, any polynomial which is a product of the form $N * (t I - M)$\n  -- is sent to zero, because the evaluation function puts the polynomial variable\n  -- to the right of any coefficients, so everything telescopes.\n  apply_fun fun p => p.eval M  at h\n  rw [eval_mul_X_sub_C] at h\n  -- Now $χ_M (t) I$, when thought of as a polynomial of matrices\n  -- and evaluated at some `N` is exactly $χ_M (N)$.\n  rw [mat_poly_equiv_smul_one, eval_map] at h\n  -- Thus we have $χ_M(M) = 0$, which is the desired result.\n  exact h\n#align matrix.aeval_self_charpoly matrix.aeval_self_charpoly\n\n"}