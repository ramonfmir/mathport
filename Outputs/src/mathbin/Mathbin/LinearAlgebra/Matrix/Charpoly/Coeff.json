{"trace_eq_neg_charpoly_coeff":
 "theorem trace_eq_neg_charpoly_coeff [Nonempty n] (M : Matrix n n R) :\n    trace M = -M.charpoly.coeff (Fintype.card n - 1) :=\n  by\n  rw [charpoly_coeff_eq_prod_coeff_of_le]; swap; rfl\n  rw [Fintype.card, prod_X_sub_C_coeff_card_pred univ (fun i : n => M i i) Fintype.card_pos, neg_neg, trace]\n  rfl\n#align trace_eq_neg_charpoly_coeff trace_eq_neg_charpoly_coeff\n\n",
 "pow_eq_aeval_mod_charpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/-- Any matrix power can be computed as the sum of matrix powers less than `fintype.card n`.\n\nTODO: add the statement for negative powers phrased with `zpow`. -/\ntheorem pow_eq_aeval_mod_charpoly (M : Matrix n n R) (k : ℕ) : M ^ k = aeval M («expr %ₘ » (X ^ k) M.charpoly) := by\n  rw [← aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]\n#align pow_eq_aeval_mod_charpoly pow_eq_aeval_mod_charpoly\n\n",
 "mat_poly_equiv_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- I feel like this should use polynomial.alg_hom_eval₂_algebra_map\ntheorem mat_poly_equiv_eval (M : Matrix n n (polynomial R)) (r : R) (i j : n) :\n    (mat_poly_equiv M).eval ((scalar n) r) i j = (M i j).eval r :=\n  by\n  unfold Polynomial.eval; unfold eval₂\n  trans Polynomial.sum (mat_poly_equiv M) fun (e : ℕ) (a : Matrix n n R) => (a * (scalar n) r ^ e) i j\n  · unfold Polynomial.sum\n    rw [sum_apply]\n    dsimp\n    rfl\n  · simp_rw [← RingHom.map_pow, ← (scalar.commute _ _).eq]\n    simp only [coe_scalar, Matrix.one_mul, RingHom.id_apply, Pi.smul_apply, smul_eq_mul, mul_eq_mul,\n      Algebra.smul_mul_assoc]\n    have h : ∀ x : ℕ, (fun (e : ℕ) (a : R) => r ^ e * a) x 0 = 0 := by simp\n    simp only [Polynomial.sum, mat_poly_equiv_coeff_apply, mul_comm]\n    apply (Finset.sum_subset (support_subset_support_mat_poly_equiv _ _ _) _).symm\n    intro n hn h'n\n    rw [not_mem_support_iff] at h'n\n    simp only [h'n, MulZeroClass.zero_mul]\n#align mat_poly_equiv_eval mat_poly_equiv_eval\n\n",
 "mat_poly_equiv_eq_X_pow_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mat_poly_equiv_eq_X_pow_sub_C {K : Type _} (k : ℕ) [Field K] (M : Matrix n n K) :\n    mat_poly_equiv ((expand K k : «expr →+* » (polynomial K) (polynomial K)).map_matrix (charmatrix (M ^ k))) =\n      X ^ k - C (M ^ k) :=\n  by\n  ext m\n  rw [coeff_sub, coeff_C, mat_poly_equiv_coeff_apply, ring_hom.map_matrix_apply, Matrix.map_apply, AlgHom.coe_toRingHom,\n    DMatrix.sub_apply, coeff_X_pow]\n  by_cases hij : i = j\n  · rw [hij, charmatrix_apply_eq, AlgHom.map_sub, expand_C, expand_X, coeff_sub, coeff_X_pow, coeff_C]\n    split_ifs with mp m0 <;> simp only [Matrix.one_apply_eq, DMatrix.zero_apply]\n  · rw [charmatrix_apply_ne _ _ _ hij, AlgHom.map_neg, expand_C, coeff_neg, coeff_C]\n    split_ifs with m0 mp <;>\n      simp only [hij, zero_sub, DMatrix.zero_apply, sub_zero, neg_zero, Matrix.one_apply_ne, ne.def, not_false_iff]\n#align mat_poly_equiv_eq_X_pow_sub_C mat_poly_equiv_eq_X_pow_sub_C\n\n",
 "eval_det":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eval_det (M : Matrix n n (polynomial R)) (r : R) :\n    Polynomial.eval r M.det = (Polynomial.eval (scalar n r) (mat_poly_equiv M)).det :=\n  by\n  rw [Polynomial.eval, ← coe_eval₂_ring_hom, RingHom.map_det]\n  apply congr_arg det; ext; symm; convert mat_poly_equiv_eval _ _ _ _\n#align eval_det eval_det\n\n",
 "det_of_card_zero":
 "theorem det_of_card_zero (h : Fintype.card n = 0) (M : Matrix n n R) : M.det = 1 :=\n  by\n  rw [Fintype.card_eq_zero_iff] at h\n  suffices M = 1 by simp [this]\n  ext i\n  exact h.elim i\n#align det_of_card_zero det_of_card_zero\n\n",
 "det_eq_sign_charpoly_coeff":
 "theorem det_eq_sign_charpoly_coeff (M : Matrix n n R) : M.det = (-1) ^ Fintype.card n * M.charpoly.coeff 0 :=\n  by\n  rw [coeff_zero_eq_eval_zero, charpoly, eval_det, mat_poly_equiv_charmatrix, ← det_smul]\n  simp\n#align det_eq_sign_charpoly_coeff det_eq_sign_charpoly_coeff\n\n",
 "coeff_charpoly_mem_ideal_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem coeff_charpoly_mem_ideal_pow {I : Ideal R} (h : ∀ i j, M i j ∈ I) (k : ℕ) :\n    M.charpoly.coeff k ∈ I ^ (Fintype.card n - k) :=\n  by\n  delta charpoly\n  rw [Matrix.det_apply, finset_sum_coeff]\n  apply sum_mem\n  rintro c -\n  rw [coeff_smul, Submodule.smul_mem_iff']\n  have :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" 1 =\n      Fintype.card n :=\n    by rw [Finset.sum_const, card_univ, smul_eq_mul, mul_one]\n  rw [← this]\n  apply coeff_prod_mem_ideal_pow_tsub\n  rintro i - (_ | k)\n  · rw [tsub_zero, pow_one, charmatrix_apply, coeff_sub, coeff_X_mul_zero, coeff_C_zero, zero_sub, neg_mem_iff]\n    exact h (c i) i\n  · rw [Nat.succ_eq_one_add, tsub_self_add, pow_zero, Ideal.one_eq_top]\n    exact Submodule.mem_top\n#align coeff_charpoly_mem_ideal_pow coeff_charpoly_mem_ideal_pow\n\n",
 "charpoly_sub_diagonal_degree_lt":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem charpoly_sub_diagonal_degree_lt :\n    (M.charpoly -\n          finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (X - C (M i i))).degree <\n      ↑(Fintype.card n - 1) :=\n  by\n  rw [charpoly, det_apply', ← insert_erase (mem_univ (Equiv.refl n)), sum_insert (not_mem_erase (Equiv.refl n) univ),\n    add_comm]\n  simp only [charmatrix_apply_eq, one_mul, Equiv.Perm.sign_refl, id.def, Int.cast_one, Units.val_one, add_sub_cancel,\n    Equiv.coe_refl]\n  rw [← mem_degree_lt]; apply Submodule.sum_mem (degree_lt R (Fintype.card n - 1))\n  intro c hc; rw [← C_eq_int_cast, C_mul']\n  apply Submodule.smul_mem (degree_lt R (Fintype.card n - 1)) ↑↑(Equiv.Perm.sign c)\n  rw [mem_degree_lt]; apply lt_of_le_of_lt degree_le_nat_degree _; rw [WithBot.coe_lt_coe]\n  apply lt_of_le_of_lt _ (Equiv.Perm.fixed_point_card_lt_of_ne_one (ne_of_mem_erase hc))\n  apply le_trans (Polynomial.natDegree_prod_le univ fun i : n => charmatrix M (c i) i) _\n  rw [card_eq_sum_ones]; rw [sum_filter]; apply sum_le_sum\n  intros ; apply charmatrix_apply_nat_degree_le\n#align charpoly_sub_diagonal_degree_lt charpoly_sub_diagonal_degree_lt\n\n",
 "charpoly_nat_degree_eq_dim":
 "theorem charpoly_nat_degree_eq_dim [Nontrivial R] (M : Matrix n n R) : M.charpoly.nat_degree = Fintype.card n :=\n  natDegree_eq_of_degree_eq_some (charpoly_degree_eq_dim M)\n#align charpoly_nat_degree_eq_dim charpoly_nat_degree_eq_dim\n\n",
 "charpoly_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem charpoly_monic (M : Matrix n n R) : M.charpoly.monic :=\n  by\n  nontriviality\n  by_cases Fintype.card n = 0\n  · rw [charpoly, det_of_card_zero h]\n    apply monic_one\n  have mon :\n    (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (X - C (M i i))).monic :=\n    by\n    apply monic_prod_of_monic univ fun i : n => X - C (M i i)\n    simp [monic_X_sub_C]\n  rw [←\n    sub_add_cancel\n      (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (X - C (M i i)))\n      M.charpoly] at\n    mon\n  rw [monic] at *\n  rw [leading_coeff_add_of_degree_lt] at mon\n  rw [← mon]\n  rw [charpoly_degree_eq_dim]\n  rw [← neg_sub]\n  rw [degree_neg]\n  apply lt_trans (charpoly_sub_diagonal_degree_lt M)\n  rw [WithBot.coe_lt_coe]\n  rw [← Nat.pred_eq_sub_one]\n  apply nat.pred_lt\n  apply h\n#align charpoly_monic charpoly_monic\n\n",
 "charpoly_degree_eq_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem charpoly_degree_eq_dim [Nontrivial R] (M : Matrix n n R) : M.charpoly.degree = Fintype.card n :=\n  by\n  by_cases Fintype.card n = 0\n  · rw [h]\n    unfold charpoly\n    rw [det_of_card_zero]\n    · simp\n    · assumption\n  rw [←\n    sub_add_cancel M.charpoly\n      (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (X - C (M i i)))]\n  have h1 :\n    (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (X - C (M i i))).degree =\n      Fintype.card n :=\n    by\n    rw [degree_eq_iff_nat_degree_eq_of_pos]\n    swap\n    apply nat.pos_of_ne_zero h\n    rw [nat_degree_prod']\n    simp_rw [nat_degree_X_sub_C]\n    unfold Fintype.card\n    simp\n    simp_rw [(monic_X_sub_C _).leading_coeff]\n    simp\n  rw [degree_add_eq_right_of_degree_lt]\n  exact h1\n  rw [h1]\n  apply lt_trans (charpoly_sub_diagonal_degree_lt M)\n  rw [WithBot.coe_lt_coe]\n  rw [← Nat.pred_eq_sub_one]\n  apply nat.pred_lt\n  apply h\n#align charpoly_degree_eq_dim charpoly_degree_eq_dim\n\n",
 "charpoly_coeff_eq_prod_coeff_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem charpoly_coeff_eq_prod_coeff_of_le {k : ℕ} (h : Fintype.card n - 1 ≤ k) :\n    M.charpoly.coeff k =\n      (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (X - C (M i i))).coeff\n        k :=\n  by\n  apply eq_of_sub_eq_zero; rw [← coeff_sub]; apply Polynomial.coeff_eq_zero_of_degree_lt\n  apply lt_of_lt_of_le (charpoly_sub_diagonal_degree_lt M) _; rw [WithBot.coe_le_coe]; apply h\n#align charpoly_coeff_eq_prod_coeff_of_le charpoly_coeff_eq_prod_coeff_of_le\n\n",
 "charmatrix_apply_nat_degree_le":
 "theorem charmatrix_apply_nat_degree_le (i j : n) : (charmatrix M i j).nat_degree ≤ ite (i = j) 1 0 := by\n  split_ifs <;> simp [h, nat_degree_X_sub_C_le]\n#align charmatrix_apply_nat_degree_le charmatrix_apply_nat_degree_le\n\n",
 "charmatrix_apply_nat_degree":
 "/-\nCopyright (c) 2020 Aaron Anderson, Jalex Stark. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson, Jalex Stark\n-/\ntheorem charmatrix_apply_nat_degree [Nontrivial R] (i j : n) : (charmatrix M i j).nat_degree = ite (i = j) 1 0 := by\n  by_cases i = j <;> simp [h, ← degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]\n#align charmatrix_apply_nat_degree charmatrix_apply_nat_degree\n\n",
 "aeval_eq_aeval_mod_charpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/-- Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p`\nis equivalent to a polynomial with degree less than the dimension of the matrix. -/\ntheorem aeval_eq_aeval_mod_charpoly (M : Matrix n n R) (p : polynomial R) :\n    aeval M p = aeval M («expr %ₘ » p M.charpoly) :=\n  (aeval_modByMonic_eq_self_of_root M.charpoly_monic M.aeval_self_charpoly).symm\n#align aeval_eq_aeval_mod_charpoly aeval_eq_aeval_mod_charpoly\n\n"}