{"to_matrix_update":
 "theorem to_matrix_update [decidable_eq ι'] (x : M) :\n    e.to_matrix (function.update v j x) = matrix.update_column (e.to_matrix v) j (e.repr x) :=\n  by\n  ext (i' k)\n  rw [basis.to_matrix, matrix.update_column_apply, e.to_matrix_apply]\n  split_ifs\n  · rw [h, update_same j x v]\n  · rw [update_noteq h]\n#align to_matrix_update to_matrix_update\n\n",
 "to_matrix_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- The basis constructed by `units_smul` has vectors given by a diagonal matrix. -/\n@[simp]\ntheorem to_matrix_units_smul [decidable_eq ι] (e : basis ι R₂ M₂) (w : ι → «expr ˣ» R₂) :\n    e.to_matrix (e.units_smul w) = diagonal (coe ∘ w) :=\n  by\n  ext (i j)\n  by_cases h : i = j\n  · simp [h, to_matrix_apply, units_smul_apply, Units.smul_def]\n  · simp [h, to_matrix_apply, units_smul_apply, Units.smul_def, ne.symm h]\n#align to_matrix_units_smul to_matrix_units_smul\n\n",
 "to_matrix_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem to_matrix_transpose_apply : (matrix.transpose (e.to_matrix v)) j = e.repr (v j) :=\n  funext fun _ => rfl\n#align to_matrix_transpose_apply to_matrix_transpose_apply\n\n",
 "to_matrix_self":
 "@[simp]\ntheorem to_matrix_self [decidable_eq ι] : e.to_matrix e = 1 :=\n  by\n  rw [basis.to_matrix]\n  ext (i j)\n  simp [basis.equiv_fun, matrix.one_apply, finsupp.single_apply, eq_comm]\n#align to_matrix_self to_matrix_self\n\n",
 "to_matrix_reindex'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- See also `basis.to_matrix_reindex` which gives the `simp` normal form of this result. -/\ntheorem basis.to_matrix_reindex' [decidable_eq ι] [decidable_eq ι'] (b : basis ι R M) (v : ι' → M)\n    (e : «expr ≃ » ι ι') : (b.reindex e).to_matrix v = matrix.reindex_alg_equiv _ e (b.to_matrix (v ∘ e)) :=\n  by\n  ext\n  simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.reindex_alg_equiv_apply, matrix.reindex_apply,\n    matrix.submatrix_apply, Function.comp_apply, e.apply_symm_apply]\n#align basis.to_matrix_reindex' basis.to_matrix_reindex'\n\n",
 "to_matrix_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem basis.to_matrix_reindex (b : basis ι R M) (v : ι' → M) (e : «expr ≃ » ι ι') :\n    (b.reindex e).to_matrix v = (b.to_matrix v).submatrix e.symm id :=\n  by\n  ext\n  simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.submatrix_apply, id.def]\n#align basis.to_matrix_reindex basis.to_matrix_reindex\n\n",
 "to_matrix_mul_to_matrix_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- `b.to_matrix b'` and `b'.to_matrix b` are inverses. -/\ntheorem basis.to_matrix_mul_to_matrix_flip [decidable_eq ι] [fintype ι'] :\n    matrix.mul (b.to_matrix b') (b'.to_matrix b) = 1 := by rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]\n#align basis.to_matrix_mul_to_matrix_flip basis.to_matrix_mul_to_matrix_flip\n\n",
 "to_matrix_mul_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- A generalization of `basis.to_matrix_self`, in the opposite direction. -/\n@[simp]\ntheorem basis.to_matrix_mul_to_matrix {ι'' : Type _} [fintype ι'] (b'' : ι'' → M) :\n    matrix.mul (b.to_matrix b') (b'.to_matrix b'') = b.to_matrix b'' :=\n  by\n  have := classical.dec_eq ι\n  have := classical.dec_eq ι'\n  haveI := classical.dec_eq ι''\n  ext (i j)\n  simp only [matrix.mul_apply, basis.to_matrix_apply, basis.sum_repr_mul_repr]\n#align basis.to_matrix_mul_to_matrix basis.to_matrix_mul_to_matrix\n\n",
 "to_matrix_map_vec_mul":
 "theorem to_matrix_map_vec_mul {S : Type _} [Ring S] [algebra R S] [fintype ι] (b : basis ι R S) (v : ι' → S) :\n    ((b.to_matrix v).map <| algebra_map R S).vec_mul b = v :=\n  by\n  ext i\n  simp_rw [vec_mul, dot_product, matrix.map_apply, ← algebra.commutes, ← algebra.smul_def, sum_to_matrix_smul_self]\n#align to_matrix_map_vec_mul to_matrix_map_vec_mul\n\n",
 "to_matrix_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem basis.to_matrix_map (b : basis ι R M) (f : «expr ≃ₗ[ ] » M R N) (v : ι → N) :\n    (b.map f).to_matrix v = b.to_matrix (f.symm ∘ v) := by\n  ext\n  simp only [basis.to_matrix_apply, basis.map, linear_equiv.trans_apply]\n#align basis.to_matrix_map basis.to_matrix_map\n\n",
 "to_matrix_is_unit_smul":
 "/-- The basis constructed by `is_unit_smul` has vectors given by a diagonal matrix. -/\n@[simp]\ntheorem to_matrix_is_unit_smul [decidable_eq ι] (e : basis ι R₂ M₂) {w : ι → R₂} (hw : ∀ i, is_unit (w i)) :\n    e.to_matrix (e.is_unit_smul hw) = diagonal w :=\n  e.to_matrix_units_smul _\n#align to_matrix_is_unit_smul to_matrix_is_unit_smul\n\n",
 "to_matrix_id_eq_basis_to_matrix":
 "/-- A generalization of `linear_map.to_matrix_id`. -/\n@[simp]\ntheorem linear_map.to_matrix_id_eq_basis_to_matrix [decidable_eq ι] : linear_map.to_matrix b b' id = b'.to_matrix b :=\n  by\n  haveI := classical.dec_eq ι'\n  rw [← @basis_to_matrix_mul_linear_map_to_matrix _ _ ι, to_matrix_id, matrix.mul_one]\n#align linear_map.to_matrix_id_eq_basis_to_matrix linear_map.to_matrix_id_eq_basis_to_matrix\n\n",
 "to_matrix_eq_transpose":
 "-- TODO (maybe) Adjust the definition of `basis.to_matrix` to eliminate the transpose.\ntheorem coe_pi_basis_fun.to_matrix_eq_transpose [fintype ι] :\n    ((pi.basis_fun R ι).to_matrix : matrix ι ι R → matrix ι ι R) = matrix.transpose :=\n  by\n  ext (M i j)\n  rfl\n#align coe_pi_basis_fun.to_matrix_eq_transpose coe_pi_basis_fun.to_matrix_eq_transpose\n\n",
 "to_matrix_eq_to_matrix_constr":
 "theorem to_matrix_eq_to_matrix_constr [fintype ι] [decidable_eq ι] (v : ι → M) :\n    e.to_matrix v = linear_map.to_matrix e e (e.constr ℕ v) :=\n  by\n  ext\n  rw [basis.to_matrix_apply, linear_map.to_matrix_apply, basis.constr_basis]\n#align to_matrix_eq_to_matrix_constr to_matrix_eq_to_matrix_constr\n\n",
 "to_matrix_apply":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\ntheorem to_matrix_apply : e.to_matrix v i j = e.repr (v j) i :=\n  rfl\n#align to_matrix_apply to_matrix_apply\n\n",
 "to_lin_to_matrix":
 "@[simp]\ntheorem to_lin_to_matrix [fintype ι] [fintype ι'] [decidable_eq ι'] (v : basis ι' R M) :\n    matrix.to_lin v e (e.to_matrix v) = id :=\n  v.ext fun i => by rw [to_lin_self, id_apply, e.sum_to_matrix_smul_self]\n#align to_lin_to_matrix to_lin_to_matrix\n\n",
 "sum_to_matrix_smul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem sum_to_matrix_smul_self [fintype ι] :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (e.to_matrix v i j) (e i)) =\n      v j :=\n  by simp_rw [e.to_matrix_apply, e.sum_repr]\n#align sum_to_matrix_smul_self sum_to_matrix_smul_self\n\n",
 "mul_basis_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem mul_basis_to_matrix [decidable_eq ι] [decidable_eq ι'] (b₁ : basis ι R M) (b₂ : basis ι' R M) (b₃ : basis κ R N)\n    (A : matrix κ ι R) : matrix.mul A (b₁.to_matrix b₂) = linear_map.to_matrix b₂ b₃ (to_lin b₁ b₃ A) :=\n  by\n  have := linear_map_to_matrix_mul_basis_to_matrix b₂ b₁ b₃ (matrix.to_lin b₁ b₃ A)\n  rwa [linear_map.to_matrix_to_lin] at this\n#align mul_basis_to_matrix mul_basis_to_matrix\n\n",
 "linear_map_to_matrix_mul_basis_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem linear_map_to_matrix_mul_basis_to_matrix [decidable_eq ι] [decidable_eq ι'] :\n    matrix.mul (linear_map.to_matrix b' c' f) (b'.to_matrix b) = linear_map.to_matrix b c' f :=\n  (matrix.to_lin b c').injective\n    (by rw [to_lin_to_matrix, to_lin_mul b b' c', to_lin_to_matrix, b'.to_lin_to_matrix, comp_id])\n#align linear_map_to_matrix_mul_basis_to_matrix linear_map_to_matrix_mul_basis_to_matrix\n\n",
 "basis_to_matrix_mul_linear_map_to_matrix_mul_basis_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem basis_to_matrix_mul_linear_map_to_matrix_mul_basis_to_matrix [decidable_eq ι] [decidable_eq ι'] :\n    matrix.mul (matrix.mul (c.to_matrix c') (linear_map.to_matrix b' c' f)) (b'.to_matrix b) =\n      linear_map.to_matrix b c f :=\n  by rw [basis_to_matrix_mul_linear_map_to_matrix, linear_map_to_matrix_mul_basis_to_matrix]\n#align\n  basis_to_matrix_mul_linear_map_to_matrix_mul_basis_to_matrix basis_to_matrix_mul_linear_map_to_matrix_mul_basis_to_matrix\n\n",
 "basis_to_matrix_mul_linear_map_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem basis_to_matrix_mul_linear_map_to_matrix [decidable_eq ι'] :\n    matrix.mul (c.to_matrix c') (linear_map.to_matrix b' c' f) = linear_map.to_matrix b' c f :=\n  (matrix.to_lin b' c).injective\n    (by\n      haveI := classical.dec_eq κ' <;>\n        rw [to_lin_to_matrix, to_lin_mul b' c' c, to_lin_to_matrix, c.to_lin_to_matrix, id_comp])\n#align basis_to_matrix_mul_linear_map_to_matrix basis_to_matrix_mul_linear_map_to_matrix\n\n",
 "basis_to_matrix_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem basis_to_matrix_mul [decidable_eq κ] (b₁ : basis ι R M) (b₂ : basis ι' R M) (b₃ : basis κ R N)\n    (A : matrix ι' κ R) : matrix.mul (b₁.to_matrix b₂) A = linear_map.to_matrix b₃ b₁ (to_lin b₃ b₂ A) :=\n  by\n  have := basis_to_matrix_mul_linear_map_to_matrix b₃ b₁ b₂ (matrix.to_lin b₃ b₂ A)\n  rwa [linear_map.to_matrix_to_lin] at this\n#align basis_to_matrix_mul basis_to_matrix_mul\n\n",
 "basis_to_matrix_basis_fun_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem basis_to_matrix_basis_fun_mul (b : basis ι R (ι → R)) (A : matrix ι ι R) :\n    matrix.mul (b.to_matrix (pi.basis_fun R ι)) A = of fun i j => b.repr ((matrix.transpose A) j) i := by\n  classical\n    simp only [basis_to_matrix_mul _ _ (pi.basis_fun R ι), matrix.to_lin_eq_to_lin']\n    ext (i j)\n    rw [linear_map.to_matrix_apply, matrix.to_lin'_apply, pi.basis_fun_apply, matrix.mul_vec_std_basis_apply,\n      matrix.of_apply]\n#align basis_to_matrix_basis_fun_mul basis_to_matrix_basis_fun_mul\n\n"}