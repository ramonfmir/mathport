{"to_matrix_update":
 "theorem to_matrix_update [DecidableEq ι'] (x : M) :\n    e.to_matrix (Function.update v j x) = Matrix.updateColumn (e.to_matrix v) j (e.repr x) :=\n  by\n  ext (i' k)\n  rw [Basis.toMatrix, Matrix.updateColumn_apply, e.to_matrix_apply]\n  split_ifs\n  · rw [h, update_same j x v]\n  · rw [update_noteq h]\n#align to_matrix_update to_matrix_update\n\n",
 "to_matrix_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- The basis constructed by `units_smul` has vectors given by a diagonal matrix. -/\n@[simp]\ntheorem to_matrix_units_smul [DecidableEq ι] (e : Basis ι R₂ M₂) (w : ι → «expr ˣ» R₂) :\n    e.to_matrix (e.units_smul w) = diagonal (coe ∘ w) :=\n  by\n  ext (i j)\n  by_cases h : i = j\n  · simp [h, to_matrix_apply, units_smul_apply, Units.smul_def]\n  · simp [h, to_matrix_apply, units_smul_apply, Units.smul_def, ne.symm h]\n#align to_matrix_units_smul to_matrix_units_smul\n\n",
 "to_matrix_transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem to_matrix_transpose_apply : (matrix.transpose (e.to_matrix v)) j = e.repr (v j) :=\n  funext fun _ => rfl\n#align to_matrix_transpose_apply to_matrix_transpose_apply\n\n",
 "to_matrix_self":
 "@[simp]\ntheorem to_matrix_self [DecidableEq ι] : e.to_matrix e = 1 :=\n  by\n  rw [Basis.toMatrix]\n  ext (i j)\n  simp [Basis.equivFun, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n#align to_matrix_self to_matrix_self\n\n",
 "to_matrix_map_vec_mul":
 "theorem to_matrix_map_vec_mul {S : Type _} [Ring S] [Algebra R S] [Fintype ι] (b : Basis ι R S) (v : ι' → S) :\n    ((b.to_matrix v).map <| algebraMap R S).vec_mul b = v :=\n  by\n  ext i\n  simp_rw [vec_mul, dot_product, Matrix.map_apply, ← Algebra.commutes, ← Algebra.smul_def, sum_to_matrix_smul_self]\n#align to_matrix_map_vec_mul to_matrix_map_vec_mul\n\n",
 "to_matrix_is_unit_smul":
 "/-- The basis constructed by `is_unit_smul` has vectors given by a diagonal matrix. -/\n@[simp]\ntheorem to_matrix_is_unit_smul [DecidableEq ι] (e : Basis ι R₂ M₂) {w : ι → R₂} (hw : ∀ i, IsUnit (w i)) :\n    e.to_matrix (e.is_unit_smul hw) = diagonal w :=\n  e.to_matrix_units_smul _\n#align to_matrix_is_unit_smul to_matrix_is_unit_smul\n\n",
 "to_matrix_eq_transpose":
 "-- TODO (maybe) Adjust the definition of `basis.to_matrix` to eliminate the transpose.\ntheorem coe_pi_basis_fun.to_matrix_eq_transpose [Fintype ι] :\n    ((Pi.basisFun R ι).to_matrix : Matrix ι ι R → Matrix ι ι R) = Matrix.transpose :=\n  by\n  ext (M i j)\n  rfl\n#align coe_pi_basis_fun.to_matrix_eq_transpose coe_pi_basis_fun.to_matrix_eq_transpose\n\n",
 "to_matrix_eq_to_matrix_constr":
 "theorem to_matrix_eq_to_matrix_constr [Fintype ι] [DecidableEq ι] (v : ι → M) :\n    e.to_matrix v = LinearMap.toMatrix e e (e.constr ℕ v) :=\n  by\n  ext\n  rw [Basis.toMatrix_apply, LinearMap.toMatrix_apply, Basis.constr_basis]\n#align to_matrix_eq_to_matrix_constr to_matrix_eq_to_matrix_constr\n\n",
 "to_matrix_apply":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen\n-/\ntheorem to_matrix_apply : e.to_matrix v i j = e.repr (v j) i :=\n  rfl\n#align to_matrix_apply to_matrix_apply\n\n",
 "to_lin_to_matrix":
 "@[simp]\ntheorem to_lin_to_matrix [Fintype ι] [Fintype ι'] [DecidableEq ι'] (v : Basis ι' R M) :\n    Matrix.toLin v e (e.to_matrix v) = id :=\n  v.ext fun i => by rw [to_lin_self, id_apply, e.sum_to_matrix_smul_self]\n#align to_lin_to_matrix to_lin_to_matrix\n\n",
 "toMatrix_reindex'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Basis.toMatrix_reindex' /-\n/-- See also `basis.to_matrix_reindex` which gives the `simp` normal form of this result. -/\ntheorem Basis.toMatrix_reindex' [DecidableEq ι] [DecidableEq ι'] (b : Basis ι R M) (v : ι' → M) (e : «expr ≃ » ι ι') :\n    (b.reindex e).to_matrix v = Matrix.reindexAlgEquiv _ e (b.to_matrix (v ∘ e)) :=\n  by\n  ext\n  simp only [Basis.toMatrix_apply, Basis.repr_reindex, Matrix.reindexAlgEquiv_apply, Matrix.reindex_apply,\n    Matrix.submatrix_apply, Function.comp_apply, e.apply_symm_apply, Finsupp.mapDomain_equiv_apply]\n#align basis.to_matrix_reindex' Basis.toMatrix_reindex'\n-/\n\n",
 "toMatrix_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print Basis.toMatrix_reindex /-\n@[simp]\ntheorem Basis.toMatrix_reindex (b : Basis ι R M) (v : ι' → M) (e : «expr ≃ » ι ι') :\n    (b.reindex e).to_matrix v = (b.to_matrix v).submatrix e.symm id :=\n  by\n  ext\n  simp only [Basis.toMatrix_apply, Basis.repr_reindex, Matrix.submatrix_apply, id.def, Finsupp.mapDomain_equiv_apply]\n#align basis.to_matrix_reindex Basis.toMatrix_reindex\n-/\n\n",
 "toMatrix_mul_toMatrix_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Basis.toMatrix_mul_toMatrix_flip /-\n/-- `b.to_matrix b'` and `b'.to_matrix b` are inverses. -/\ntheorem Basis.toMatrix_mul_toMatrix_flip [DecidableEq ι] [Fintype ι'] :\n    matrix.mul (b.to_matrix b') (b'.to_matrix b) = 1 := by rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]\n#align basis.to_matrix_mul_to_matrix_flip Basis.toMatrix_mul_toMatrix_flip\n-/\n\n",
 "toMatrix_mul_toMatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print Basis.toMatrix_mul_toMatrix /-\n/-- A generalization of `basis.to_matrix_self`, in the opposite direction. -/\n@[simp]\ntheorem Basis.toMatrix_mul_toMatrix {ι'' : Type _} [Fintype ι'] (b'' : ι'' → M) :\n    matrix.mul (b.to_matrix b') (b'.to_matrix b'') = b.to_matrix b'' :=\n  by\n  have := Classical.decEq ι\n  have := Classical.decEq ι'\n  haveI := Classical.decEq ι''\n  ext (i j)\n  simp only [Matrix.mul_apply, Basis.toMatrix_apply, Basis.sum_repr_mul_repr]\n#align basis.to_matrix_mul_to_matrix Basis.toMatrix_mul_toMatrix\n-/\n\n",
 "toMatrix_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Basis.toMatrix_map /-\n@[simp]\ntheorem Basis.toMatrix_map (b : Basis ι R M) (f : «expr ≃ₗ[ ] » M R N) (v : ι → N) :\n    (b.map f).to_matrix v = b.to_matrix (f.symm ∘ v) := by\n  ext\n  simp only [Basis.toMatrix_apply, Basis.map, LinearEquiv.trans_apply]\n#align basis.to_matrix_map Basis.toMatrix_map\n-/\n\n",
 "toMatrix_id_eq_basis_toMatrix":
 "#print LinearMap.toMatrix_id_eq_basis_toMatrix /-\n/-- A generalization of `linear_map.to_matrix_id`. -/\n@[simp]\ntheorem LinearMap.toMatrix_id_eq_basis_toMatrix [DecidableEq ι] : LinearMap.toMatrix b b' id = b'.to_matrix b :=\n  by\n  haveI := Classical.decEq ι'\n  rw [← @basis_toMatrix_mul_linearMap_toMatrix _ _ ι, to_matrix_id, Matrix.mul_one]\n#align linear_map.to_matrix_id_eq_basis_to_matrix LinearMap.toMatrix_id_eq_basis_toMatrix\n-/\n\n",
 "sum_to_matrix_smul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem sum_to_matrix_smul_self [Fintype ι] :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (e.to_matrix v i j) (e i)) =\n      v j :=\n  by simp_rw [e.to_matrix_apply, e.sum_repr]\n#align sum_to_matrix_smul_self sum_to_matrix_smul_self\n\n",
 "mul_basis_toMatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print mul_basis_toMatrix /-\ntheorem mul_basis_toMatrix [DecidableEq ι] [DecidableEq ι'] (b₁ : Basis ι R M) (b₂ : Basis ι' R M) (b₃ : Basis κ R N)\n    (A : Matrix κ ι R) : matrix.mul A (b₁.to_matrix b₂) = LinearMap.toMatrix b₂ b₃ (toLin b₁ b₃ A) :=\n  by\n  have := linearMap_toMatrix_mul_basis_toMatrix b₂ b₁ b₃ (Matrix.toLin b₁ b₃ A)\n  rwa [LinearMap.toMatrix_toLin] at this\n#align mul_basis_to_matrix mul_basis_toMatrix\n-/\n\n",
 "linearMap_toMatrix_mul_basis_toMatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print linearMap_toMatrix_mul_basis_toMatrix /-\n@[simp]\ntheorem linearMap_toMatrix_mul_basis_toMatrix [DecidableEq ι] [DecidableEq ι'] :\n    matrix.mul (LinearMap.toMatrix b' c' f) (b'.to_matrix b) = LinearMap.toMatrix b c' f :=\n  (Matrix.toLin b c').injective\n    (by rw [to_lin_to_matrix, to_lin_mul b b' c', to_lin_to_matrix, b'.to_lin_to_matrix, comp_id])\n#align linear_map_to_matrix_mul_basis_to_matrix linearMap_toMatrix_mul_basis_toMatrix\n-/\n\n",
 "basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix /-\ntheorem basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix [DecidableEq ι] [DecidableEq ι'] :\n    matrix.mul (matrix.mul (c.to_matrix c') (LinearMap.toMatrix b' c' f)) (b'.to_matrix b) = LinearMap.toMatrix b c f :=\n  by rw [basis_toMatrix_mul_linearMap_toMatrix, linearMap_toMatrix_mul_basis_toMatrix]\n#align basis_to_matrix_mul_linear_map_to_matrix_mul_basis_to_matrix basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix\n-/\n\n",
 "basis_toMatrix_mul_linearMap_toMatrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print basis_toMatrix_mul_linearMap_toMatrix /-\n@[simp]\ntheorem basis_toMatrix_mul_linearMap_toMatrix [DecidableEq ι'] :\n    matrix.mul (c.to_matrix c') (LinearMap.toMatrix b' c' f) = LinearMap.toMatrix b' c f :=\n  (Matrix.toLin b' c).injective\n    (by\n      haveI := Classical.decEq κ' <;>\n        rw [to_lin_to_matrix, to_lin_mul b' c' c, to_lin_to_matrix, c.to_lin_to_matrix, id_comp])\n#align basis_to_matrix_mul_linear_map_to_matrix basis_toMatrix_mul_linearMap_toMatrix\n-/\n\n",
 "basis_toMatrix_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print basis_toMatrix_mul /-\ntheorem basis_toMatrix_mul [DecidableEq κ] (b₁ : Basis ι R M) (b₂ : Basis ι' R M) (b₃ : Basis κ R N)\n    (A : Matrix ι' κ R) : matrix.mul (b₁.to_matrix b₂) A = LinearMap.toMatrix b₃ b₁ (toLin b₃ b₂ A) :=\n  by\n  have := basis_toMatrix_mul_linearMap_toMatrix b₃ b₁ b₂ (Matrix.toLin b₃ b₂ A)\n  rwa [LinearMap.toMatrix_toLin] at this\n#align basis_to_matrix_mul basis_toMatrix_mul\n-/\n\n",
 "basis_toMatrix_basisFun_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n#print basis_toMatrix_basisFun_mul /-\ntheorem basis_toMatrix_basisFun_mul (b : Basis ι R (ι → R)) (A : Matrix ι ι R) :\n    matrix.mul (b.to_matrix (Pi.basisFun R ι)) A = of fun i j => b.repr ((matrix.transpose A) j) i := by\n  classical\n    simp only [basis_toMatrix_mul _ _ (Pi.basisFun R ι), Matrix.toLin_eq_toLin']\n    ext (i j)\n    rw [LinearMap.toMatrix_apply, Matrix.toLin'_apply, Pi.basisFun_apply, Matrix.mulVec_stdBasis_apply, Matrix.of_apply]\n#align basis_to_matrix_basis_fun_mul basis_toMatrix_basisFun_mul\n-/\n\n"}