{"unit_of_det_invertible_eq_nonsing_inv_unit":
 "-- `is_unit.invertible` lifts the proposition `is_unit A` to a constructive inverse of `A`.\ntheorem unit_of_det_invertible_eq_nonsing_inv_unit [Invertible A.det] :\n    unitOfDetInvertible A = nonsingInvUnit A (isUnit_of_invertible _) :=\n  by\n  ext\n  rfl\n#align unit_of_det_invertible_eq_nonsing_inv_unit unit_of_det_invertible_eq_nonsing_inv_unit\n\n",
 "transpose_nonsing_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem transpose_nonsing_inv : matrix.transpose A⁻¹ = (matrix.transpose A)⁻¹ := by\n  rw [inv_def, inv_def, transpose_smul, det_transpose, adjugate_transpose]\n#align transpose_nonsing_inv transpose_nonsing_inv\n\n",
 "right_inv_eq_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- The right inverse of matrix A is unique when existing. -/\ntheorem right_inv_eq_right_inv (h : matrix.mul A B = 1) (g : matrix.mul A C = 1) : B = C := by\n  rw [← inv_eq_right_inv h, ← inv_eq_right_inv g]\n#align right_inv_eq_right_inv right_inv_eq_right_inv\n\n",
 "right_inv_eq_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- The right inverse of matrix A equals the left inverse of A when they exist. -/\ntheorem right_inv_eq_left_inv (h : matrix.mul A B = 1) (g : matrix.mul C A = 1) : B = C := by\n  rw [← inv_eq_right_inv h, ← inv_eq_left_inv g]\n#align right_inv_eq_left_inv right_inv_eq_left_inv\n\n",
 "nonsing_inv_nonsing_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem nonsing_inv_nonsing_inv (h : IsUnit A.det) : A⁻¹⁻¹ = A :=\n  calc\n    A⁻¹⁻¹ = matrix.mul 1 A⁻¹⁻¹ := by rw [Matrix.one_mul]\n    _ = matrix.mul (matrix.mul A A⁻¹) A⁻¹⁻¹ := by rw [A.mul_nonsing_inv h]\n    _ = A := by rw [Matrix.mul_assoc, A⁻¹.mul_nonsing_inv (A.is_unit_nonsing_inv_det h), Matrix.mul_one]\n    \n#align nonsing_inv_nonsing_inv nonsing_inv_nonsing_inv\n\n",
 "nonsing_inv_mul_cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem nonsing_inv_mul_cancel_right (B : Matrix m n α) (h : IsUnit A.det) : matrix.mul (matrix.mul B A⁻¹) A = B := by\n  simp [Matrix.mul_assoc, nonsing_inv_mul A h]\n#align nonsing_inv_mul_cancel_right nonsing_inv_mul_cancel_right\n\n",
 "nonsing_inv_mul_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem nonsing_inv_mul_cancel_left (B : Matrix n m α) (h : IsUnit A.det) : matrix.mul A⁻¹ (matrix.mul A B) = B := by\n  simp [← Matrix.mul_assoc, nonsing_inv_mul A h]\n#align nonsing_inv_mul_cancel_left nonsing_inv_mul_cancel_left\n\n",
 "nonsing_inv_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- The `nonsing_inv` of `A` is a left inverse. -/\n@[simp]\ntheorem nonsing_inv_mul (h : IsUnit A.det) : matrix.mul A⁻¹ A = 1 :=\n  by\n  cases (A.is_unit_iff_is_unit_det.mpr h).nonempty_invertible\n  rw [← inv_of_eq_nonsing_inv, Matrix.invOf_mul_self]\n#align nonsing_inv_mul nonsing_inv_mul\n\n",
 "nonsing_inv_eq_ring_inverse":
 "/-- The nonsingular inverse is the same as the general `ring.inverse`. -/\ntheorem nonsing_inv_eq_ring_inverse : A⁻¹ = Ring.inverse A :=\n  by\n  by_cases h_det : IsUnit A.det\n  · cases (A.is_unit_iff_is_unit_det.mpr h_det).nonempty_invertible\n    rw [← inv_of_eq_nonsing_inv, Ring.inverse_invertible]\n  · have h := mt A.is_unit_iff_is_unit_det.mp h_det\n    rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_is_unit A h_det]\n#align nonsing_inv_eq_ring_inverse nonsing_inv_eq_ring_inverse\n\n",
 "nonsing_inv_cancel_or_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem nonsing_inv_cancel_or_zero : matrix.mul A⁻¹ A = 1 ∧ matrix.mul A A⁻¹ = 1 ∨ A⁻¹ = 0 :=\n  by\n  by_cases h : IsUnit A.det\n  · exact or.inl ⟨nonsing_inv_mul _ h, mul_nonsing_inv _ h⟩\n  · exact or.inr (nonsing_inv_apply_not_is_unit _ h)\n#align nonsing_inv_cancel_or_zero nonsing_inv_cancel_or_zero\n\n",
 "nonsing_inv_apply_not_is_unit":
 "theorem nonsing_inv_apply_not_is_unit (h : ¬IsUnit A.det) : A⁻¹ = 0 := by\n  rw [inv_def, Ring.inverse_non_unit _ h, zero_smul]\n#align nonsing_inv_apply_not_is_unit nonsing_inv_apply_not_is_unit\n\n",
 "nonsing_inv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem nonsing_inv_apply (h : IsUnit A.det) : A⁻¹ = «expr • » (↑h.unit⁻¹ : α) A.adjugate := by\n  rw [inv_def, ← Ring.inverse_unit h.unit, IsUnit.unit_spec]\n#align nonsing_inv_apply nonsing_inv_apply\n\n",
 "mul_nonsing_inv_cancel_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_nonsing_inv_cancel_right (B : Matrix m n α) (h : IsUnit A.det) : matrix.mul (matrix.mul B A) A⁻¹ = B := by\n  simp [Matrix.mul_assoc, mul_nonsing_inv A h]\n#align mul_nonsing_inv_cancel_right mul_nonsing_inv_cancel_right\n\n",
 "mul_nonsing_inv_cancel_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_nonsing_inv_cancel_left (B : Matrix n m α) (h : IsUnit A.det) : matrix.mul A (matrix.mul A⁻¹ B) = B := by\n  simp [← Matrix.mul_assoc, mul_nonsing_inv A h]\n#align mul_nonsing_inv_cancel_left mul_nonsing_inv_cancel_left\n\n",
 "mul_nonsing_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- The `nonsing_inv` of `A` is a right inverse. -/\n@[simp]\ntheorem mul_nonsing_inv (h : IsUnit A.det) : matrix.mul A A⁻¹ = 1 :=\n  by\n  cases (A.is_unit_iff_is_unit_det.mpr h).nonempty_invertible\n  rw [← inv_of_eq_nonsing_inv, Matrix.mul_invOf_self]\n#align mul_nonsing_inv mul_nonsing_inv\n\n",
 "mul_mul_invOf_self_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print mul_mul_invOf_self_cancel /-\n/-- A copy of `mul_mul_inv_of_self_cancel` using `⬝` not `*`. -/\nprotected theorem mul_mul_invOf_self_cancel (A : Matrix m n α) (B : Matrix n n α) [Invertible B] :\n    matrix.mul (matrix.mul A B) ((«expr⅟») B) = A := by rw [Matrix.mul_assoc, Matrix.mul_invOf_self, Matrix.mul_one]\n#align mul_mul_inv_of_self_cancel mul_mul_invOf_self_cancel\n-/\n\n",
 "mul_inv_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print mul_inv_rev /-\ntheorem mul_inv_rev (A B : Matrix n n α) : (matrix.mul A B)⁻¹ = matrix.mul B⁻¹ A⁻¹ :=\n  by\n  simp only [inv_def]\n  rw [Matrix.smul_mul, Matrix.mul_smul, smul_smul, det_mul, adjugate_mul_distrib, Ring.mul_inverse_rev]\n#align mul_inv_rev mul_inv_rev\n-/\n\n",
 "mul_inv_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_inv_of_invertible [Invertible A] : matrix.mul A A⁻¹ = 1 :=\n  mul_nonsing_inv A (isUnit_det_of_invertible A)\n#align mul_inv_of_invertible mul_inv_of_invertible\n\n",
 "mul_inv_eq_iff_eq_mul_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem mul_inv_eq_iff_eq_mul_of_invertible (A B C : Matrix n n α) [Invertible A] :\n    matrix.mul B A⁻¹ = C ↔ B = matrix.mul C A :=\n  ⟨fun h => by rw [← h, inv_mul_cancel_right_of_invertible], fun h => by rw [h, mul_inv_cancel_right_of_invertible]⟩\n#align mul_inv_eq_iff_eq_mul_of_invertible mul_inv_eq_iff_eq_mul_of_invertible\n\n",
 "mul_inv_cancel_right_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_inv_cancel_right_of_invertible (B : Matrix m n α) [Invertible A] : matrix.mul (matrix.mul B A) A⁻¹ = B :=\n  mul_nonsing_inv_cancel_right A B (isUnit_det_of_invertible A)\n#align mul_inv_cancel_right_of_invertible mul_inv_cancel_right_of_invertible\n\n",
 "mul_inv_cancel_left_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem mul_inv_cancel_left_of_invertible (B : Matrix n m α) [Invertible A] : matrix.mul A (matrix.mul A⁻¹ B) = B :=\n  mul_nonsing_inv_cancel_left A B (isUnit_det_of_invertible A)\n#align mul_inv_cancel_left_of_invertible mul_inv_cancel_left_of_invertible\n\n",
 "mul_invOf_self_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print mul_invOf_self_assoc /-\n/-- A copy of `mul_inv_of_self_assoc` using `⬝` not `*`. -/\nprotected theorem mul_invOf_self_assoc (A : Matrix n n α) (B : Matrix n m α) [Invertible A] :\n    matrix.mul A (matrix.mul ((«expr⅟») A) B) = B := by rw [← Matrix.mul_assoc, Matrix.mul_invOf_self, Matrix.one_mul]\n#align mul_inv_of_self_assoc mul_invOf_self_assoc\n-/\n\n",
 "mul_invOf_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print mul_invOf_self /-\n/-- A copy of `mul_inv_of_self` using `⬝` not `*`. -/\nprotected theorem mul_invOf_self (A : Matrix n n α) [Invertible A] : matrix.mul A ((«expr⅟») A) = 1 :=\n  mul_invOf_self A\n#align mul_inv_of_self mul_invOf_self\n-/\n\n",
 "mul_invOf_mul_self_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print mul_invOf_mul_self_cancel /-\n/-- A copy of `mul_inv_of_mul_self_cancel` using `⬝` not `*`. -/\nprotected theorem mul_invOf_mul_self_cancel (A : Matrix m n α) (B : Matrix n n α) [Invertible B] :\n    matrix.mul (matrix.mul A ((«expr⅟») B)) B = A := by rw [Matrix.mul_assoc, Matrix.invOf_mul_self, Matrix.mul_one]\n#align mul_inv_of_mul_self_cancel mul_invOf_mul_self_cancel\n-/\n\n",
 "mul_eq_one_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem mul_eq_one_comm : matrix.mul A B = 1 ↔ matrix.mul B A = 1 :=\n  suffices ∀ A B, matrix.mul A B = 1 → matrix.mul B A = 1 from ⟨this A B, this B A⟩\n  fun A B h => by\n  letI : Invertible B.det := det_invertible_of_left_inverse _ _ h\n  letI : Invertible B := invertible_of_det_invertible B\n  calc\n    matrix.mul B A = matrix.mul (matrix.mul B A) (matrix.mul B ((«expr⅟») B)) := by\n      rw [Matrix.mul_invOf_self, Matrix.mul_one]\n    _ = matrix.mul B (matrix.mul (matrix.mul A B) ((«expr⅟») B)) := by simp only [Matrix.mul_assoc]\n    _ = matrix.mul B ((«expr⅟») B) := by rw [h, Matrix.one_mul]\n    _ = 1 := Matrix.mul_invOf_self B\n    \n#align mul_eq_one_comm mul_eq_one_comm\n\n",
 "list_prod_inv_reverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `sym.cons' -/\n/-- A version of `list.prod_inv_reverse` for `matrix.has_inv`. -/\ntheorem list_prod_inv_reverse : ∀ l : List (Matrix n n α), l.prod⁻¹ = (l.reverse.map has_inv.inv).prod\n  | [] => by rw [List.reverse_nil, List.map_nil, List.prod_nil, inv_one]\n  | sym.cons' A Xs => by\n    rw [List.reverse_cons', List.map_concat, List.prod_concat, List.prod_cons, Matrix.mul_eq_mul, Matrix.mul_eq_mul,\n      mul_inv_rev, list_prod_inv_reverse]\n#align list_prod_inv_reverse list_prod_inv_reverse\n\n",
 "left_inv_eq_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- The left inverse of matrix A is unique when existing. -/\ntheorem left_inv_eq_left_inv (h : matrix.mul B A = 1) (g : matrix.mul C A = 1) : B = C := by\n  rw [← inv_eq_left_inv h, ← inv_eq_left_inv g]\n#align left_inv_eq_left_inv left_inv_eq_left_inv\n\n",
 "is_unit_submatrix_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- When lowered to a prop, `matrix.invertible_of_submatrix_equiv_invertible` forms an `iff`. -/\n@[simp]\ntheorem is_unit_submatrix_equiv {A : Matrix m m α} (e₁ e₂ : «expr ≃ » n m) : IsUnit (A.submatrix e₁ e₂) ↔ IsUnit A := by\n  simp only [← nonempty_invertible_iff_isUnit, (submatrix_equiv_invertible_equiv_invertible A _ _).nonempty_congr]\n#align is_unit_submatrix_equiv is_unit_submatrix_equiv\n\n",
 "is_unit_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem is_unit_of_right_inverse (h : matrix.mul A B = 1) : IsUnit A :=\n  ⟨⟨A, B, h, mul_eq_one_comm.mp h⟩, rfl⟩\n#align is_unit_of_right_inverse is_unit_of_right_inverse\n\n",
 "is_unit_of_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem is_unit_of_left_inverse (h : matrix.mul B A = 1) : IsUnit A :=\n  ⟨⟨A, B, mul_eq_one_comm.mp h, h⟩, rfl⟩\n#align is_unit_of_left_inverse is_unit_of_left_inverse\n\n",
 "is_unit_nonsing_inv_det_iff":
 "theorem is_unit_nonsing_inv_det_iff {A : Matrix n n α} : IsUnit A⁻¹.det ↔ IsUnit A.det := by\n  rw [Matrix.det_nonsing_inv, isUnit_ring_inverse]\n#align is_unit_nonsing_inv_det_iff is_unit_nonsing_inv_det_iff\n\n",
 "is_unit_nonsing_inv_det":
 "theorem is_unit_nonsing_inv_det (h : IsUnit A.det) : IsUnit A⁻¹.det :=\n  isUnit_of_mul_eq_one _ _ (A.det_nonsing_inv_mul_det h)\n#align is_unit_nonsing_inv_det is_unit_nonsing_inv_det\n\n",
 "is_unit_iff_is_unit_det":
 "/-- When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`. -/\ntheorem is_unit_iff_is_unit_det : IsUnit A ↔ IsUnit A.det := by\n  simp only [← nonempty_invertible_iff_isUnit, (invertible_equiv_det_invertible A).nonempty_congr]\n#align is_unit_iff_is_unit_det is_unit_iff_is_unit_det\n\n",
 "is_unit_diagonal":
 "/-- When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`. -/\n@[simp]\ntheorem is_unit_diagonal {v : n → α} : IsUnit (diagonal v) ↔ IsUnit v := by\n  simp only [← nonempty_invertible_iff_isUnit, (diagonal_invertible_equiv_invertible v).nonempty_congr]\n#align is_unit_diagonal is_unit_diagonal\n\n",
 "is_unit_det_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\ntheorem is_unit_det_transpose (h : IsUnit A.det) : IsUnit (matrix.transpose A).det :=\n  by\n  rw [det_transpose]\n  exact h\n#align is_unit_det_transpose is_unit_det_transpose\n\n",
 "is_unit_det_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem is_unit_det_of_right_inverse (h : matrix.mul A B = 1) : IsUnit A.det :=\n  @isUnit_of_invertible _ _ _ (detInvertibleOfRightInverse _ _ h)\n#align is_unit_det_of_right_inverse is_unit_det_of_right_inverse\n\n",
 "is_unit_det_of_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem is_unit_det_of_left_inverse (h : matrix.mul B A = 1) : IsUnit A.det :=\n  @isUnit_of_invertible _ _ _ (detInvertibleOfLeftInverse _ _ h)\n#align is_unit_det_of_left_inverse is_unit_det_of_left_inverse\n\n",
 "is_unit_det_of_invertible":
 "theorem is_unit_det_of_invertible [Invertible A] : IsUnit A.det :=\n  @isUnit_of_invertible _ _ _ (detInvertibleOfInvertible A)\n#align is_unit_det_of_invertible is_unit_det_of_invertible\n\n",
 "inv_zero":
 "@[simp]\ntheorem inv_zero : (0 : Matrix n n α)⁻¹ = 0 :=\n  by\n  cases' subsingleton_or_nontrivial α with ht ht\n  · simp\n  cases' (Fintype.card n).zero_le.eq_or_lt with hc hc\n  · rw [eq_comm, Fintype.card_eq_zero_iff] at hc\n    haveI := hc\n    ext i\n    exact (is_empty.false i).elim\n  · have hn : Nonempty n := fintype.card_pos_iff.mp hc\n    refine' nonsing_inv_apply_not_is_unit _ _\n    simp [hn]\n#align inv_zero inv_zero\n\n",
 "inv_submatrix_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem inv_submatrix_equiv (A : Matrix m m α) (e₁ e₂ : «expr ≃ » n m) : (A.submatrix e₁ e₂)⁻¹ = A⁻¹.submatrix e₂ e₁ :=\n  by\n  by_cases h : IsUnit A\n  · cases h.nonempty_invertible\n    letI := submatrix_equiv_invertible A e₁ e₂\n    rw [← inv_of_eq_nonsing_inv, ← inv_of_eq_nonsing_inv, inv_of_submatrix_equiv_eq]\n  · have := (is_unit_submatrix_equiv e₁ e₂).not.mpr h\n    simp_rw [nonsing_inv_eq_ring_inverse, Ring.inverse_non_unit _ h, Ring.inverse_non_unit _ this, submatrix_zero,\n      Pi.zero_apply]\n#align inv_submatrix_equiv inv_submatrix_equiv\n\n",
 "inv_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem inv_smul' (k : «expr ˣ» α) (h : IsUnit A.det) : («expr • » k A)⁻¹ = «expr • » k⁻¹ A⁻¹ :=\n  inv_eq_left_inv (by simp [h, smul_smul])\n#align inv_smul' inv_smul'\n\n",
 "inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem inv_smul (k : α) [Invertible k] (h : IsUnit A.det) : («expr • » k A)⁻¹ = «expr • » ((«expr⅟») k) A⁻¹ :=\n  inv_eq_left_inv (by simp [h, smul_smul])\n#align inv_smul inv_smul\n\n",
 "inv_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem inv_reindex (e₁ e₂ : «expr ≃ » n m) (A : Matrix n n α) : (reindex e₁ e₂ A)⁻¹ = reindex e₂ e₁ A⁻¹ :=\n  inv_submatrix_equiv A e₁.symm e₂.symm\n#align inv_reindex inv_reindex\n\n",
 "inv_of_submatrix_equiv_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem inv_of_submatrix_equiv_eq (A : Matrix m m α) (e₁ e₂ : «expr ≃ » n m) [Invertible A]\n    [Invertible (A.submatrix e₁ e₂)] : («expr⅟») (A.submatrix e₁ e₂) = ((«expr⅟») A).submatrix e₂ e₁ :=\n  by\n  letI := submatrix_equiv_invertible A e₁ e₂\n  haveI := Invertible.subsingleton (A.submatrix e₁ e₂)\n  convert(rfl : («expr⅟») (A.submatrix e₁ e₂) = _)\n#align inv_of_submatrix_equiv_eq inv_of_submatrix_equiv_eq\n\n",
 "inv_of_eq_nonsing_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/-- The nonsingular inverse is the same as `inv_of` when `A` is invertible. -/\n@[simp]\ntheorem inv_of_eq_nonsing_inv [Invertible A] : («expr⅟») A = A⁻¹ :=\n  by\n  letI := det_invertible_of_invertible A\n  rw [inv_def, Ring.inverse_invertible, inv_of_eq]\n#align inv_of_eq_nonsing_inv inv_of_eq_nonsing_inv\n\n",
 "inv_of_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem inv_of_eq [Invertible A.det] [Invertible A] : («expr⅟») A = «expr • » ((«expr⅟») A.det) A.adjugate :=\n  by\n  letI := invertible_of_det_invertible A\n  convert(rfl : («expr⅟») A = _)\n#align inv_of_eq inv_of_eq\n\n",
 "inv_of_diagonal_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem inv_of_diagonal_eq {α} [Semiring α] (v : n → α) [Invertible v] [Invertible (diagonal v)] :\n    («expr⅟») (diagonal v) = diagonal ((«expr⅟») v) :=\n  by\n  letI := diagonal_invertible v\n  haveI := Invertible.subsingleton (diagonal v)\n  convert(rfl : («expr⅟») (diagonal v) = _)\n#align inv_of_diagonal_eq inv_of_diagonal_eq\n\n",
 "inv_mul_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem inv_mul_of_invertible [Invertible A] : matrix.mul A⁻¹ A = 1 :=\n  nonsing_inv_mul A (isUnit_det_of_invertible A)\n#align inv_mul_of_invertible inv_mul_of_invertible\n\n",
 "inv_mul_eq_iff_eq_mul_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem inv_mul_eq_iff_eq_mul_of_invertible (A B C : Matrix n n α) [Invertible A] :\n    matrix.mul A⁻¹ B = C ↔ B = matrix.mul A C :=\n  ⟨fun h => by rw [← h, mul_inv_cancel_left_of_invertible], fun h => by rw [h, inv_mul_cancel_left_of_invertible]⟩\n#align inv_mul_eq_iff_eq_mul_of_invertible inv_mul_eq_iff_eq_mul_of_invertible\n\n",
 "inv_mul_cancel_right_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem inv_mul_cancel_right_of_invertible (B : Matrix m n α) [Invertible A] : matrix.mul (matrix.mul B A⁻¹) A = B :=\n  nonsing_inv_mul_cancel_right A B (isUnit_det_of_invertible A)\n#align inv_mul_cancel_right_of_invertible inv_mul_cancel_right_of_invertible\n\n",
 "inv_mul_cancel_left_of_invertible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n@[simp]\ntheorem inv_mul_cancel_left_of_invertible (B : Matrix n m α) [Invertible A] : matrix.mul A⁻¹ (matrix.mul A B) = B :=\n  nonsing_inv_mul_cancel_left A B (isUnit_det_of_invertible A)\n#align inv_mul_cancel_left_of_invertible inv_mul_cancel_left_of_invertible\n\n",
 "inv_inv_of_invertible":
 "@[simp]\ntheorem inv_inv_of_invertible [Invertible A] : A⁻¹⁻¹ = A := by simp only [← inv_of_eq_nonsing_inv, invOf_invOf]\n#align inv_inv_of_invertible inv_inv_of_invertible\n\n",
 "inv_inv_inv":
 "@[simp]\ntheorem inv_inv_inv (A : Matrix n n α) : A⁻¹⁻¹⁻¹ = A⁻¹ :=\n  by\n  by_cases h : IsUnit A.det\n  · rw [nonsing_inv_nonsing_inv _ h]\n  · simp [nonsing_inv_apply_not_is_unit _ h]\n#align inv_inv_inv inv_inv_inv\n\n",
 "inv_inj":
 "#print inv_inj /-\ntheorem inv_inj (h : A⁻¹ = B⁻¹) (h' : IsUnit A.det) : A = B :=\n  by\n  refine' left_inv_eq_left_inv (mul_nonsing_inv _ h') _\n  rw [h]\n  refine' mul_nonsing_inv _ _\n  rwa [← is_unit_nonsing_inv_det_iff, ← h, is_unit_nonsing_inv_det_iff]\n#align inv_inj inv_inj\n-/\n\n",
 "inv_eq_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If matrix A is right invertible, then its inverse equals its right inverse. -/\ntheorem inv_eq_right_inv (h : matrix.mul A B = 1) : A⁻¹ = B :=\n  inv_eq_left_inv (mul_eq_one_comm.2 h)\n#align inv_eq_right_inv inv_eq_right_inv\n\n",
 "inv_eq_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- If matrix A is left invertible, then its inverse equals its left inverse. -/\ntheorem inv_eq_left_inv (h : matrix.mul B A = 1) : A⁻¹ = B :=\n  letI := invertible_of_left_inverse _ _ h\n  inv_of_eq_nonsing_inv A ▸ invOf_eq_left_inv h\n#align inv_eq_left_inv inv_eq_left_inv\n\n",
 "inv_diagonal":
 "theorem inv_diagonal (v : n → α) : (diagonal v)⁻¹ = diagonal (Ring.inverse v) :=\n  by\n  rw [nonsing_inv_eq_ring_inverse]\n  by_cases h : IsUnit v\n  · have := is_unit_diagonal.mpr h\n    cases this.nonempty_invertible\n    cases h.nonempty_invertible\n    rw [Ring.inverse_invertible, Ring.inverse_invertible, inv_of_diagonal_eq]\n  · have := is_unit_diagonal.not.mpr h\n    rw [Ring.inverse_non_unit _ h, Pi.zero_def, diagonal_zero, Ring.inverse_non_unit _ this]\n#align inv_diagonal inv_diagonal\n\n",
 "inv_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem inv_def (A : Matrix n n α) : A⁻¹ = «expr • » (Ring.inverse A.det) A.adjugate :=\n  rfl\n#align inv_def inv_def\n\n",
 "inv_adjugate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem inv_adjugate (A : Matrix n n α) (h : IsUnit A.det) : (adjugate A)⁻¹ = «expr • » h.unit⁻¹ A :=\n  by\n  refine' inv_eq_left_inv _\n  rw [smul_mul, mul_adjugate, Units.smul_def, smul_smul, h.coe_inv_mul, one_smul]\n#align inv_adjugate inv_adjugate\n\n",
 "invOf_mul_self_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n#print invOf_mul_self_assoc /-\n/-- A copy of `inv_of_mul_self_assoc` using `⬝` not `*`. -/\nprotected theorem invOf_mul_self_assoc (A : Matrix n n α) (B : Matrix n m α) [Invertible A] :\n    matrix.mul ((«expr⅟») A) (matrix.mul A B) = B := by rw [← Matrix.mul_assoc, Matrix.invOf_mul_self, Matrix.one_mul]\n#align inv_of_mul_self_assoc invOf_mul_self_assoc\n-/\n\n",
 "invOf_mul_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n#print invOf_mul_self /-\n/-\nCopyright (c) 2019 Tim Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Tim Baanen, Lu-Ming Zhang\n-/\n/-- A copy of `inv_of_mul_self` using `⬝` not `*`. -/\nprotected theorem invOf_mul_self (A : Matrix n n α) [Invertible A] : matrix.mul ((«expr⅟») A) A = 1 :=\n  invOf_mul_self A\n#align inv_of_mul_self invOf_mul_self\n-/\n\n",
 "det_smul_inv_vec_mul_eq_cramer_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/-- One form of **Cramer's rule**. See `matrix.mul_vec_cramer` for a stronger form. -/\n@[simp]\ntheorem det_smul_inv_vec_mul_eq_cramer_transpose (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) :\n    «expr • » A.det (A⁻¹.vec_mul b) = cramer (matrix.transpose A) b := by\n  rw [← A⁻¹.transpose_transpose, vec_mul_transpose, transpose_nonsing_inv, ← det_transpose,\n    (matrix.transpose A).det_smul_inv_mul_vec_eq_cramer _ (is_unit_det_transpose A h)]\n#align det_smul_inv_vec_mul_eq_cramer_transpose det_smul_inv_vec_mul_eq_cramer_transpose\n\n",
 "det_smul_inv_mul_vec_eq_cramer":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- One form of **Cramer's rule**. See `matrix.mul_vec_cramer` for a stronger form. -/\n@[simp]\ntheorem det_smul_inv_mul_vec_eq_cramer (A : Matrix n n α) (b : n → α) (h : IsUnit A.det) :\n    «expr • » A.det (A⁻¹.mul_vec b) = cramer A b := by\n  rw [cramer_eq_adjugate_mul_vec, A.nonsing_inv_apply h, ← smul_mul_vec_assoc, smul_smul, h.mul_coe_inv, one_smul]\n#align det_smul_inv_mul_vec_eq_cramer det_smul_inv_mul_vec_eq_cramer\n\n",
 "det_nonsing_inv_mul_det":
 "theorem det_nonsing_inv_mul_det (h : IsUnit A.det) : A⁻¹.det * A.det = 1 := by\n  rw [← det_mul, A.nonsing_inv_mul h, det_one]\n#align det_nonsing_inv_mul_det det_nonsing_inv_mul_det\n\n",
 "det_nonsing_inv":
 "@[simp]\ntheorem det_nonsing_inv : A⁻¹.det = Ring.inverse A.det :=\n  by\n  by_cases h : IsUnit A.det\n  · cases h.nonempty_invertible\n    letI := invertible_of_det_invertible A\n    rw [Ring.inverse_invertible, ← inv_of_eq_nonsing_inv, det_inv_of]\n  cases isEmpty_or_nonempty n\n  · rw [det_is_empty, det_is_empty, Ring.inverse_one]\n  · rw [Ring.inverse_non_unit _ h, nonsing_inv_apply_not_is_unit _ h, det_zero ‹_›]\n#align det_nonsing_inv det_nonsing_inv\n\n",
 "det_ne_zero_of_right_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_ne_zero_of_right_inverse [Nontrivial α] (h : matrix.mul A B = 1) : A.det ≠ 0 :=\n  (isUnit_det_of_right_inverse h).ne_zero\n#align det_ne_zero_of_right_inverse det_ne_zero_of_right_inverse\n\n",
 "det_ne_zero_of_left_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem det_ne_zero_of_left_inverse [Nontrivial α] (h : matrix.mul B A = 1) : A.det ≠ 0 :=\n  (isUnit_det_of_left_inverse h).ne_zero\n#align det_ne_zero_of_left_inverse det_ne_zero_of_left_inverse\n\n",
 "det_inv_of":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⅟» -/\ntheorem det_inv_of [Invertible A] [Invertible A.det] : ((«expr⅟») A).det = («expr⅟») A.det :=\n  by\n  letI := det_invertible_of_invertible A\n  convert(rfl : _ = («expr⅟») A.det)\n#align det_inv_of det_inv_of\n\n",
 "det_conj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- A variant of `matrix.det_units_conj'`. -/\ntheorem det_conj' {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) :\n    det (matrix.mul (matrix.mul M⁻¹ N) M) = det N := by rw [← h.unit_spec, ← coe_units_inv, det_units_conj']\n#align det_conj' det_conj'\n\n",
 "det_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- A variant of `matrix.det_units_conj`. -/\ntheorem det_conj {M : Matrix m m α} (h : IsUnit M) (N : Matrix m m α) : det (matrix.mul (matrix.mul M N) M⁻¹) = det N :=\n  by rw [← h.unit_spec, ← coe_units_inv, det_units_conj]\n#align det_conj det_conj\n\n",
 "conj_transpose_nonsing_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.conj_transpose -/\ntheorem conj_transpose_nonsing_inv [StarRing α] : matrix.conj_transpose A⁻¹ = (matrix.conj_transpose A)⁻¹ := by\n  rw [inv_def, inv_def, conj_transpose_smul, det_conj_transpose, adjugate_conj_transpose, Ring.inverse_star]\n#align conj_transpose_nonsing_inv conj_transpose_nonsing_inv\n\n",
 "coe_units_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- Coercing the result of `units.has_inv` is the same as coercing first and applying the\nnonsingular inverse. -/\n@[simp, norm_cast]\ntheorem coe_units_inv (A : «expr ˣ» (Matrix n n α)) : ↑A⁻¹ = (A⁻¹ : Matrix n n α) :=\n  by\n  letI := A.invertible\n  rw [← inv_of_eq_nonsing_inv, invOf_units]\n#align coe_units_inv coe_units_inv\n\n"}