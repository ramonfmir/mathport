{"span_singleton_ann_ideal_generator":
 "/-- `ann_ideal_generator 𝕜 a` is indeed a generator. -/\n@[simp]\ntheorem span_singleton_ann_ideal_generator (a : A) : ideal.span {ann_ideal_generator 𝕜 a} = ann_ideal 𝕜 a :=\n  by\n  by_cases h : ann_ideal_generator 𝕜 a = 0\n  · rw [h, ann_ideal_generator_eq_zero_iff.mp h, set.singleton_zero, ideal.span_zero]\n  · rw [ann_ideal_generator, ideal.span_singleton_mul_right_unit, ideal.span_singleton_generator]\n    apply polynomial.is_unit_C.mpr\n    apply IsUnit.mk0\n    apply inv_eq_zero.not.mpr\n    apply polynomial.leading_coeff_eq_zero.not.mpr\n    apply (mul_ne_zero_iff.mp h).1\n#align span_singleton_ann_ideal_generator span_singleton_ann_ideal_generator\n\n",
 "monic_generator_eq_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If a monic generates the annihilating ideal, it must match our choice\n of the annihilating ideal generator. -/\ntheorem monic_generator_eq_minpoly (a : A) (p : polynomial 𝕜) (p_monic : p.monic)\n    (p_gen : ideal.span {p} = ann_ideal 𝕜 a) : ann_ideal_generator 𝕜 a = p :=\n  by\n  by_cases h : p = 0\n  · rwa [h, ann_ideal_generator_eq_zero_iff, ← p_gen, ideal.span_singleton_eq_bot.mpr]\n  · rw [← span_singleton_ann_ideal_generator, ideal.span_singleton_eq_span_singleton] at p_gen\n    rw [eq_comm]\n    apply eq_of_monic_of_associated p_monic _ p_gen\n    · apply monic_ann_ideal_generator _ _ ((Associated.ne_zero_iff p_gen).mp h)\n#align monic_generator_eq_minpoly monic_generator_eq_minpoly\n\n",
 "monic_ann_ideal_generator":
 "/-- The generator we chose for the annihilating ideal is monic when the ideal is non-zero. -/\ntheorem monic_ann_ideal_generator (a : A) (hg : ann_ideal_generator 𝕜 a ≠ 0) : monic (ann_ideal_generator 𝕜 a) :=\n  monic_mul_leading_coeff_inv (mul_ne_zero_iff.mp hg).1\n#align monic_ann_ideal_generator monic_ann_ideal_generator\n\n",
 "mem_iff_eq_smul_ann_ideal_generator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_iff_eq_smul_ann_ideal_generator {p : polynomial 𝕜} (a : A) :\n    p ∈ ann_ideal 𝕜 a ↔ ∃ s : polynomial 𝕜, p = «expr • » s (ann_ideal_generator 𝕜 a) := by\n  simp_rw [@eq_comm _ p, ← mem_span_singleton, ← span_singleton_ann_ideal_generator 𝕜 a, ideal.span]\n#align mem_iff_eq_smul_ann_ideal_generator mem_iff_eq_smul_ann_ideal_generator\n\n",
 "mem_iff_ann_ideal_generator_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mem_iff_ann_ideal_generator_dvd {p : polynomial 𝕜} {a : A} : p ∈ ann_ideal 𝕜 a ↔ ann_ideal_generator 𝕜 a ∣ p :=\n  by rw [← ideal.mem_span_singleton, span_singleton_ann_ideal_generator]\n#align mem_iff_ann_ideal_generator_dvd mem_iff_ann_ideal_generator_dvd\n\n",
 "mem_ann_ideal_iff_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2022 Justin Thomas. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Justin Thomas\n-/\n/-- It is useful to refer to ideal membership sometimes\n and the annihilation condition other times. -/\ntheorem mem_ann_ideal_iff_aeval_eq_zero {a : A} {p : polynomial R} : p ∈ ann_ideal R a ↔ aeval a p = 0 :=\n  iff.rfl\n#align mem_ann_ideal_iff_aeval_eq_zero mem_ann_ideal_iff_aeval_eq_zero\n\n",
 "degree_ann_ideal_generator_le_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The generator of the annihilating ideal has minimal degree among\n the non-zero members of the annihilating ideal -/\ntheorem degree_ann_ideal_generator_le_of_mem (a : A) (p : polynomial 𝕜) (hp : p ∈ ann_ideal 𝕜 a) (hpn0 : p ≠ 0) :\n    degree (ann_ideal_generator 𝕜 a) ≤ degree p :=\n  degree_le_of_dvd (mem_iff_ann_ideal_generator_dvd.1 hp) hpn0\n#align degree_ann_ideal_generator_le_of_mem degree_ann_ideal_generator_le_of_mem\n\n",
 "ann_ideal_generator_mem":
 "/-- The annihilating ideal generator is a member of the annihilating ideal. -/\ntheorem ann_ideal_generator_mem (a : A) : ann_ideal_generator 𝕜 a ∈ ann_ideal 𝕜 a :=\n  ideal.mul_mem_right _ _ (submodule.is_principal.generator_mem _)\n#align ann_ideal_generator_mem ann_ideal_generator_mem\n\n",
 "ann_ideal_generator_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ann_ideal_generator_eq_zero_iff {a : A} : ann_ideal_generator 𝕜 a = 0 ↔ ann_ideal 𝕜 a = «expr⊥» := by\n  simp only [ann_ideal_generator, mul_eq_zero, is_principal.eq_bot_iff_generator_eq_zero, polynomial.C_eq_zero,\n    inv_eq_zero, polynomial.leading_coeff_eq_zero, or_self_iff]\n#align ann_ideal_generator_eq_zero_iff ann_ideal_generator_eq_zero_iff\n\n",
 "ann_ideal_generator_eq_minpoly":
 "/-- The generator of the annihilating ideal is the minimal polynomial. -/\ntheorem ann_ideal_generator_eq_minpoly (a : A) : ann_ideal_generator 𝕜 a = minpoly 𝕜 a :=\n  by\n  by_cases h : ann_ideal_generator 𝕜 a = 0\n  · rw [h, minpoly.eq_zero]\n    rintro ⟨p, p_monic, hp : aeval a p = 0⟩\n    refine' p_monic.ne_zero (ideal.mem_bot.mp _)\n    simpa only [ann_ideal_generator_eq_zero_iff.mp h] using mem_ann_ideal_iff_aeval_eq_zero.mpr hp\n  ·\n    exact\n      minpoly.unique _ _ (monic_ann_ideal_generator _ _ h) (ann_ideal_generator_aeval_eq_zero _ _) fun q q_monic hq =>\n        degree_ann_ideal_generator_le_of_mem a q (mem_ann_ideal_iff_aeval_eq_zero.mpr hq) q_monic.ne_zero\n#align ann_ideal_generator_eq_minpoly ann_ideal_generator_eq_minpoly\n\n",
 "ann_ideal_generator_aeval_eq_zero":
 "theorem ann_ideal_generator_aeval_eq_zero (a : A) : aeval a (ann_ideal_generator 𝕜 a) = 0 :=\n  mem_ann_ideal_iff_aeval_eq_zero.mp (ann_ideal_generator_mem 𝕜 a)\n#align ann_ideal_generator_aeval_eq_zero ann_ideal_generator_aeval_eq_zero\n\n"}