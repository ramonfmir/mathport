{"range_eq_of_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_of_proj {f : «expr →ₗ[ ] » E R p} (hf : ∀ x : p, f x = x) : range f = «expr⊤» :=\n  range_eq_top.2 fun x => ⟨x, hf x⟩\n#align range_eq_of_proj range_eq_of_proj\n\n",
 "quotient_equiv_of_is_compl_symm_apply":
 "@[simp]\ntheorem quotient_equiv_of_is_compl_symm_apply (h : IsCompl p q) (x : q) :\n    (quotient_equiv_of_is_compl p q h).symm x = quotient.mk x :=\n  rfl\n#align quotient_equiv_of_is_compl_symm_apply quotient_equiv_of_is_compl_symm_apply\n\n",
 "quotient_equiv_of_is_compl_apply_mk_coe":
 "@[simp]\ntheorem quotient_equiv_of_is_compl_apply_mk_coe (h : IsCompl p q) (x : q) :\n    quotient_equiv_of_is_compl p q h (quotient.mk x) = x :=\n  (quotient_equiv_of_is_compl p q h).apply_symm_apply x\n#align quotient_equiv_of_is_compl_apply_mk_coe quotient_equiv_of_is_compl_apply_mk_coe\n\n",
 "prod_equiv_of_is_compl_symm_apply_snd_eq_zero":
 "@[simp]\ntheorem prod_equiv_of_is_compl_symm_apply_snd_eq_zero (h : IsCompl p q) {x : E} :\n    ((prod_equiv_of_is_compl p q h).symm x).2 = 0 ↔ x ∈ p :=\n  by\n  conv_rhs => rw [← (prod_equiv_of_is_compl p q h).apply_symm_apply x]\n  rw [coe_prod_equiv_of_is_compl', submodule.add_mem_iff_right _ (submodule.coe_mem _),\n    mem_left_iff_eq_zero_of_disjoint h.disjoint]\n#align prod_equiv_of_is_compl_symm_apply_snd_eq_zero prod_equiv_of_is_compl_symm_apply_snd_eq_zero\n\n",
 "prod_equiv_of_is_compl_symm_apply_right":
 "@[simp]\ntheorem prod_equiv_of_is_compl_symm_apply_right (h : IsCompl p q) (x : q) :\n    (prod_equiv_of_is_compl p q h).symm x = (0, x) :=\n  (prod_equiv_of_is_compl p q h).symm_apply_eq.2 <| by simp\n#align prod_equiv_of_is_compl_symm_apply_right prod_equiv_of_is_compl_symm_apply_right\n\n",
 "prod_equiv_of_is_compl_symm_apply_left":
 "@[simp]\ntheorem prod_equiv_of_is_compl_symm_apply_left (h : IsCompl p q) (x : p) :\n    (prod_equiv_of_is_compl p q h).symm x = (x, 0) :=\n  (prod_equiv_of_is_compl p q h).symm_apply_eq.2 <| by simp\n#align prod_equiv_of_is_compl_symm_apply_left prod_equiv_of_is_compl_symm_apply_left\n\n",
 "prod_equiv_of_is_compl_symm_apply_fst_eq_zero":
 "@[simp]\ntheorem prod_equiv_of_is_compl_symm_apply_fst_eq_zero (h : IsCompl p q) {x : E} :\n    ((prod_equiv_of_is_compl p q h).symm x).1 = 0 ↔ x ∈ q :=\n  by\n  conv_rhs => rw [← (prod_equiv_of_is_compl p q h).apply_symm_apply x]\n  rw [coe_prod_equiv_of_is_compl', submodule.add_mem_iff_left _ (submodule.coe_mem _),\n    mem_right_iff_eq_zero_of_disjoint h.disjoint]\n#align prod_equiv_of_is_compl_symm_apply_fst_eq_zero prod_equiv_of_is_compl_symm_apply_fst_eq_zero\n\n",
 "prod_comm_trans_prod_equiv_of_is_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n@[simp]\ntheorem prod_comm_trans_prod_equiv_of_is_compl (h : IsCompl p q) :\n    «expr ≪≫ₗ » (linear_equiv.prod_comm R q p) (prod_equiv_of_is_compl p q h) = prod_equiv_of_is_compl q p h.symm :=\n  linear_equiv.ext fun _ => add_comm _ _\n#align prod_comm_trans_prod_equiv_of_is_compl prod_comm_trans_prod_equiv_of_is_compl\n\n",
 "of_is_compl_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_is_compl_zero (h : IsCompl p q) : (of_is_compl h 0 0 : «expr →ₗ[ ] » E R F) = 0 :=\n  of_is_compl_eq _ (fun _ => rfl) fun _ => rfl\n#align of_is_compl_zero of_is_compl_zero\n\n",
 "of_is_compl_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem of_is_compl_smul {R : Type _} [CommRing R] {E : Type _} [add_comm_group E] [Module R E] {F : Type _}\n    [add_comm_group F] [Module R F] {p q : submodule R E} (h : IsCompl p q) {φ : «expr →ₗ[ ] » p R F}\n    {ψ : «expr →ₗ[ ] » q R F} (c : R) :\n    of_is_compl h («expr • » c φ) («expr • » c ψ) = «expr • » c (of_is_compl h φ ψ) :=\n  of_is_compl_eq _ (by simp) (by simp)\n#align of_is_compl_smul of_is_compl_smul\n\n",
 "of_is_compl_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_is_compl_right_apply (h : IsCompl p q) {φ : «expr →ₗ[ ] » p R F} {ψ : «expr →ₗ[ ] » q R F} (v : q) :\n    of_is_compl h φ ψ (v : E) = ψ v := by simp [of_is_compl]\n#align of_is_compl_right_apply of_is_compl_right_apply\n\n",
 "of_is_compl_prod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_is_compl_prod_apply {p q : submodule R₁ E} (h : IsCompl p q)\n    (φ : «expr →ₗ[ ] » p R₁ F × «expr →ₗ[ ] » q R₁ F) : of_is_compl_prod h φ = of_is_compl h φ.1 φ.2 :=\n  rfl\n#align of_is_compl_prod_apply of_is_compl_prod_apply\n\n",
 "of_is_compl_left_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_is_compl_left_apply (h : IsCompl p q) {φ : «expr →ₗ[ ] » p R F} {ψ : «expr →ₗ[ ] » q R F} (u : p) :\n    of_is_compl h φ ψ (u : E) = φ u := by simp [of_is_compl]\n#align of_is_compl_left_apply of_is_compl_left_apply\n\n",
 "of_is_compl_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem of_is_compl_eq' (h : IsCompl p q) {φ : «expr →ₗ[ ] » p R F} {ψ : «expr →ₗ[ ] » q R F} {χ : «expr →ₗ[ ] » E R F}\n    (hφ : φ = χ.comp p.subtype) (hψ : ψ = χ.comp q.subtype) : of_is_compl h φ ψ = χ :=\n  of_is_compl_eq h (fun _ => hφ.symm ▸ rfl) fun _ => hψ.symm ▸ rfl\n#align of_is_compl_eq' of_is_compl_eq'\n\n",
 "of_is_compl_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem of_is_compl_eq (h : IsCompl p q) {φ : «expr →ₗ[ ] » p R F} {ψ : «expr →ₗ[ ] » q R F} {χ : «expr →ₗ[ ] » E R F}\n    (hφ : ∀ u, φ u = χ u) (hψ : ∀ u, ψ u = χ u) : of_is_compl h φ ψ = χ :=\n  by\n  ext x\n  obtain ⟨_, _, rfl, _⟩ := exists_unique_add_of_is_compl h x\n  simp [of_is_compl, hφ, hψ]\n#align of_is_compl_eq of_is_compl_eq\n\n",
 "of_is_compl_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem of_is_compl_add (h : IsCompl p q) {φ₁ φ₂ : «expr →ₗ[ ] » p R F} {ψ₁ ψ₂ : «expr →ₗ[ ] » q R F} :\n    of_is_compl h (φ₁ + φ₂) (ψ₁ + ψ₂) = of_is_compl h φ₁ ψ₁ + of_is_compl h φ₂ ψ₂ :=\n  of_is_compl_eq _ (by simp) (by simp)\n#align of_is_compl_add of_is_compl_add\n\n",
 "mk_quotient_equiv_of_is_compl_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem mk_quotient_equiv_of_is_compl_apply (h : IsCompl p q) (x : «expr ⧸ » E p) :\n    (quotient.mk (quotient_equiv_of_is_compl p q h x) : «expr ⧸ » E p) = x :=\n  (quotient_equiv_of_is_compl p q h).symm_apply_apply x\n#align mk_quotient_equiv_of_is_compl_apply mk_quotient_equiv_of_is_compl_apply\n\n",
 "linear_proj_of_is_compl_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem linear_proj_of_is_compl_range (h : IsCompl p q) : (linear_proj_of_is_compl p q h).range = «expr⊤» :=\n  range_eq_of_proj (linear_proj_of_is_compl_apply_left h)\n#align linear_proj_of_is_compl_range linear_proj_of_is_compl_range\n\n",
 "linear_proj_of_is_compl_of_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_proj_of_is_compl_of_proj (f : «expr →ₗ[ ] » E R p) (hf : ∀ x : p, f x = x) :\n    p.linear_proj_of_is_compl f.ker (is_compl_of_proj hf) = f :=\n  by\n  ext x\n  have : x ∈ «expr ⊔ » p f.ker := by simp only [(is_compl_of_proj hf).sup_eq_top, mem_top]\n  rcases mem_sup'.1 this with ⟨x, y, rfl⟩\n  simp [hf]\n#align linear_proj_of_is_compl_of_proj linear_proj_of_is_compl_of_proj\n\n",
 "linear_proj_of_is_compl_ker":
 "@[simp]\ntheorem linear_proj_of_is_compl_ker (h : IsCompl p q) : (linear_proj_of_is_compl p q h).ker = q :=\n  ext fun x => mem_ker.trans (linear_proj_of_is_compl_apply_eq_zero_iff h)\n#align linear_proj_of_is_compl_ker linear_proj_of_is_compl_ker\n\n",
 "linear_proj_of_is_compl_idempotent":
 "theorem linear_proj_of_is_compl_idempotent (h : IsCompl p q) (x : E) :\n    linear_proj_of_is_compl p q h (linear_proj_of_is_compl p q h x) = linear_proj_of_is_compl p q h x :=\n  linear_proj_of_is_compl_apply_left h _\n#align linear_proj_of_is_compl_idempotent linear_proj_of_is_compl_idempotent\n\n",
 "linear_proj_of_is_compl_comp_subtype":
 "theorem linear_proj_of_is_compl_comp_subtype (h : IsCompl p q) : (linear_proj_of_is_compl p q h).comp p.subtype = id :=\n  linear_map.ext <| linear_proj_of_is_compl_apply_left h\n#align linear_proj_of_is_compl_comp_subtype linear_proj_of_is_compl_comp_subtype\n\n",
 "linear_proj_of_is_compl_apply_right'":
 "theorem linear_proj_of_is_compl_apply_right' (h : IsCompl p q) (x : E) (hx : x ∈ q) :\n    linear_proj_of_is_compl p q h x = 0 :=\n  (linear_proj_of_is_compl_apply_eq_zero_iff h).2 hx\n#align linear_proj_of_is_compl_apply_right' linear_proj_of_is_compl_apply_right'\n\n",
 "linear_proj_of_is_compl_apply_right":
 "@[simp]\ntheorem linear_proj_of_is_compl_apply_right (h : IsCompl p q) (x : q) : linear_proj_of_is_compl p q h x = 0 :=\n  linear_proj_of_is_compl_apply_right' h x x.2\n#align linear_proj_of_is_compl_apply_right linear_proj_of_is_compl_apply_right\n\n",
 "linear_proj_of_is_compl_apply_left":
 "@[simp]\ntheorem linear_proj_of_is_compl_apply_left (h : IsCompl p q) (x : p) : linear_proj_of_is_compl p q h x = x := by\n  simp [linear_proj_of_is_compl]\n#align linear_proj_of_is_compl_apply_left linear_proj_of_is_compl_apply_left\n\n",
 "linear_proj_of_is_compl_apply_eq_zero_iff":
 "@[simp]\ntheorem linear_proj_of_is_compl_apply_eq_zero_iff (h : IsCompl p q) {x : E} :\n    linear_proj_of_is_compl p q h x = 0 ↔ x ∈ q := by simp [linear_proj_of_is_compl]\n#align linear_proj_of_is_compl_apply_eq_zero_iff linear_proj_of_is_compl_apply_eq_zero_iff\n\n",
 "linear_proj_add_linear_proj_of_is_compl_eq_self":
 "theorem linear_proj_add_linear_proj_of_is_compl_eq_self (hpq : IsCompl p q) (x : E) :\n    (p.linear_proj_of_is_compl q hpq x + q.linear_proj_of_is_compl p hpq.symm x : E) = x :=\n  by\n  dsimp only [linear_proj_of_is_compl]\n  rw [← prod_comm_trans_prod_equiv_of_is_compl _ _ hpq]\n  exact (prod_equiv_of_is_compl _ _ hpq).apply_symm_apply x\n#align linear_proj_add_linear_proj_of_is_compl_eq_self linear_proj_add_linear_proj_of_is_compl_eq_self\n\n",
 "ker_id_sub_eq_of_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2020 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\ntheorem ker_id_sub_eq_of_proj {f : «expr →ₗ[ ] » E R p} (hf : ∀ x : p, f x = x) : ker (id - p.subtype.comp f) = p :=\n  by\n  ext x\n  simp only [comp_apply, mem_ker, subtype_apply, sub_apply, id_apply, sub_eq_zero]\n  exact ⟨fun h => h.symm ▸ submodule.coe_mem _, fun hx => by erw [hf ⟨x, hx⟩, subtype.coe_mk]⟩\n#align ker_id_sub_eq_of_proj ker_id_sub_eq_of_proj\n\n",
 "is_proj_iff_idempotent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem is_proj_iff_idempotent (f : «expr →ₗ[ ] » M S M) : (∃ p : submodule S M, is_proj p f) ↔ «expr ∘ₗ » f f = f :=\n  by\n  constructor\n  · intro h\n    obtain ⟨p, hp⟩ := h\n    ext\n    rw [comp_apply]\n    exact hp.map_id (f x) (hp.map_mem x)\n  · intro h\n    use f.range\n    constructor\n    · intro x\n      exact mem_range_self f x\n    · intro x hx\n      obtain ⟨y, hy⟩ := mem_range.1 hx\n      rw [← hy, ← comp_apply, h]\n#align is_proj_iff_idempotent is_proj_iff_idempotent\n\n",
 "is_compl_of_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_compl_of_proj {f : «expr →ₗ[ ] » E R p} (hf : ∀ x : p, f x = x) : IsCompl p f.ker :=\n  by\n  constructor\n  · rw [disjoint_iff_inf_le]\n    rintro x ⟨hpx, hfx⟩\n    erw [SetLike.mem_coe, mem_ker, hf ⟨x, hpx⟩, mk_eq_zero] at hfx\n    simp only [hfx, SetLike.mem_coe, zero_mem]\n  · rw [codisjoint_iff_le_sup]\n    intro x hx\n    rw [mem_sup']\n    refine' ⟨f x, ⟨x - f x, _⟩, add_sub_cancel'_right _ _⟩\n    rw [mem_ker, linear_map.map_sub, hf, sub_self]\n#align is_compl_of_proj is_compl_of_proj\n\n",
 "exists_unique_add_of_is_compl_prod":
 "theorem exists_unique_add_of_is_compl_prod (hc : IsCompl p q) (x : E) : ∃! u : p × q, (u.fst : E) + u.snd = x :=\n  (prod_equiv_of_is_compl _ _ hc).to_equiv.bijective.exists_unique _\n#align exists_unique_add_of_is_compl_prod exists_unique_add_of_is_compl_prod\n\n",
 "exists_unique_add_of_is_compl":
 "theorem exists_unique_add_of_is_compl (hc : IsCompl p q) (x : E) :\n    ∃ (u : p)(v : q), (u : E) + v = x ∧ ∀ (r : p) (s : q), (r : E) + s = x → r = u ∧ s = v :=\n  let ⟨u, hu₁, hu₂⟩ := exists_unique_add_of_is_compl_prod hc x\n  ⟨u.1, u.2, hu₁, fun r s hrs => prod.eq_iff_fst_eq_snd_eq.1 (hu₂ ⟨r, s⟩ hrs)⟩\n#align exists_unique_add_of_is_compl exists_unique_add_of_is_compl\n\n",
 "equiv_prod_of_surjective_of_is_compl_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem equiv_prod_of_surjective_of_is_compl_apply {f : «expr →ₗ[ ] » E R F} {g : «expr →ₗ[ ] » E R G}\n    (hf : f.range = «expr⊤») (hg : g.range = «expr⊤») (hfg : IsCompl f.ker g.ker) (x : E) :\n    equiv_prod_of_surjective_of_is_compl f g hf hg hfg x = (f x, g x) :=\n  rfl\n#align equiv_prod_of_surjective_of_is_compl_apply equiv_prod_of_surjective_of_is_compl_apply\n\n",
 "eq_conj_prod_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem eq_conj_prod_map' {f : «expr →ₗ[ ] » E R E} (h : is_proj p f) :\n    f =\n      «expr ∘ₗ » (p.prod_equiv_of_is_compl f.ker h.is_compl).to_linear_map\n        («expr ∘ₗ » (prod_map id 0) (p.prod_equiv_of_is_compl f.ker h.is_compl).symm.to_linear_map) :=\n  by\n  refine' (linear_map.cancel_right (p.prod_equiv_of_is_compl f.ker h.is_compl).surjective).1 _\n  ext\n  ·\n    simp only [coe_comp, linear_equiv.coe_to_linear_map, coe_inl, Function.comp_apply, linear_equiv.of_top_apply,\n      linear_equiv.of_injective_apply, coprod_apply, submodule.coe_subtype, coe_zero, add_zero,\n      prod_equiv_of_is_compl_symm_apply_left, prod_map_apply, id_coe, id.def, zero_apply, coe_prod_equiv_of_is_compl',\n      h.map_id x x.2]\n  ·\n    simp only [coe_comp, linear_equiv.coe_to_linear_map, coe_inr, Function.comp_apply, linear_equiv.of_top_apply,\n      linear_equiv.of_injective_apply, coprod_apply, submodule.coe_subtype, coe_zero, zero_add, map_coe_ker,\n      prod_equiv_of_is_compl_symm_apply_right, prod_map_apply, id_coe, id.def, zero_apply, coe_prod_equiv_of_is_compl']\n#align eq_conj_prod_map' eq_conj_prod_map'\n\n",
 "eq_conj_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_proj.eq_conj_prod_map {f : «expr →ₗ[ ] » E R E} (h : is_proj p f) :\n    f = (p.prod_equiv_of_is_compl f.ker h.is_compl).conj (prod_map id 0) :=\n  by\n  rw [linear_equiv.conj_apply]\n  exact h.eq_conj_prod_map'\n#align is_proj.eq_conj_prod_map is_proj.eq_conj_prod_map\n\n",
 "coe_prod_equiv_of_is_compl'":
 "@[simp]\ntheorem coe_prod_equiv_of_is_compl' (h : IsCompl p q) (x : p × q) : prod_equiv_of_is_compl p q h x = x.1 + x.2 :=\n  rfl\n#align coe_prod_equiv_of_is_compl' coe_prod_equiv_of_is_compl'\n\n",
 "coe_prod_equiv_of_is_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_prod_equiv_of_is_compl (h : IsCompl p q) :\n    (prod_equiv_of_is_compl p q h : «expr →ₗ[ ] » (p × q) R E) = p.subtype.coprod q.subtype :=\n  rfl\n#align coe_prod_equiv_of_is_compl coe_prod_equiv_of_is_compl\n\n",
 "coe_is_compl_equiv_proj_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_is_compl_equiv_proj_symm_apply (f : { f : «expr →ₗ[ ] » E R p // ∀ x : p, f x = x }) :\n    (p.is_compl_equiv_proj.symm f : submodule R E) = (f : «expr →ₗ[ ] » E R p).ker :=\n  rfl\n#align coe_is_compl_equiv_proj_symm_apply coe_is_compl_equiv_proj_symm_apply\n\n",
 "coe_is_compl_equiv_proj_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_is_compl_equiv_proj_apply (q : { q // IsCompl p q }) :\n    (p.is_compl_equiv_proj q : «expr →ₗ[ ] » E R p) = linear_proj_of_is_compl p q q.2 :=\n  rfl\n#align coe_is_compl_equiv_proj_apply coe_is_compl_equiv_proj_apply\n\n",
 "coe_equiv_prod_of_surjective_of_is_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem coe_equiv_prod_of_surjective_of_is_compl {f : «expr →ₗ[ ] » E R F} {g : «expr →ₗ[ ] » E R G}\n    (hf : f.range = «expr⊤») (hg : g.range = «expr⊤») (hfg : IsCompl f.ker g.ker) :\n    (equiv_prod_of_surjective_of_is_compl f g hf hg hfg : «expr →ₗ[ ] » E R (F × G)) = f.prod g :=\n  rfl\n#align coe_equiv_prod_of_surjective_of_is_compl coe_equiv_prod_of_surjective_of_is_compl\n\n",
 "cod_restrict_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem cod_restrict_ker {f : «expr →ₗ[ ] » M S M} (h : is_proj m f) : h.cod_restrict.ker = f.ker :=\n  f.ker_cod_restrict m _\n#align cod_restrict_ker cod_restrict_ker\n\n",
 "cod_restrict_apply_cod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem cod_restrict_apply_cod {f : «expr →ₗ[ ] » M S M} (h : is_proj m f) (x : m) : h.cod_restrict x = x :=\n  by\n  ext\n  rw [cod_restrict_apply]\n  exact h.map_id x x.2\n#align cod_restrict_apply_cod cod_restrict_apply_cod\n\n",
 "cod_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem cod_restrict_apply {f : «expr →ₗ[ ] » M S M} (h : is_proj m f) (x : M) : ↑(h.cod_restrict x) = f x :=\n  f.cod_restrict_apply m x\n#align cod_restrict_apply cod_restrict_apply\n\n",
 "IsCompl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print IsCompl /-\ntheorem IsCompl {f : «expr →ₗ[ ] » E R E} (h : is_proj p f) : IsCompl p f.ker :=\n  by\n  rw [← cod_restrict_ker]\n  exact is_compl_of_proj h.cod_restrict_apply_cod\n#align is_compl IsCompl\n-/\n\n"}