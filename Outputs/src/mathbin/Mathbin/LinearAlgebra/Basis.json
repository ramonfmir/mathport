{"units_smul_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem units_smul_span_eq_top {v : ι → M} (hv : Submodule.span R (Set.range v) = «expr⊤») {w : ι → «expr ˣ» R} :\n    Submodule.span R (Set.range («expr • » w v)) = «expr⊤» :=\n  groupSmul_span_eq_top hv\n#align units_smul_span_eq_top units_smul_span_eq_top\n\n",
 "units_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem units_smul_apply {v : Basis ι R M} {w : ι → «expr ˣ» R} (i : ι) : v.units_smul w i = «expr • » (w i) (v i) :=\n  mk_apply (v.linear_independent.units_smul w) (units_smul_span_eq_top v.span_eq).ge i\n#align units_smul_apply units_smul_apply\n\n",
 "total_repr":
 "@[simp]\ntheorem total_repr : Finsupp.total _ _ _ b (b.repr x) = x :=\n  by\n  rw [← b.coe_repr_symm]\n  exact b.repr.symm_apply_apply x\n#align total_repr total_repr\n\n",
 "sum_repr_mul_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_repr_mul_repr {ι'} [Fintype ι'] (b' : Basis ι' R M) (x : M) (i : ι) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.repr (b' j) i * b'.repr x j) =\n      b.repr x i :=\n  by\n  conv_rhs => rw [← b'.sum_repr x]\n  simp_rw [LinearEquiv.map_sum, LinearEquiv.map_smul, Finset.sum_apply']\n  refine' Finset.sum_congr rfl fun j _ => _\n  rw [Finsupp.smul_apply, smul_eq_mul, mul_comm]\n#align sum_repr_mul_repr sum_repr_mul_repr\n\n",
 "sum_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.sum_repr /-\ntheorem Basis.sum_repr (u : M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.repr u i) (b i)) =\n      u :=\n  b.sum_equiv_fun u\n#align basis.sum_repr Basis.sum_repr\n-/\n\n",
 "sum_equivFun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.sum_equivFun /-\ntheorem Basis.sum_equivFun (u : M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.equiv_fun u i) (b i)) =\n      u :=\n  by\n  conv_rhs => rw [← b.total_repr u]\n  simp [Finsupp.total_apply, Finsupp.sum_fintype, b.equiv_fun_apply]\n#align basis.sum_equiv_fun Basis.sum_equivFun\n-/\n\n",
 "sum_coords_self_apply":
 "@[simp]\ntheorem sum_coords_self_apply : b.sum_coords (b i) = 1 := by\n  simp only [Basis.sumCoords, LinearMap.id_coe, LinearEquiv.coe_coe, id.def, Basis.repr_self, Function.comp_apply,\n    Finsupp.coe_lsum, LinearMap.coe_comp, Finsupp.sum_single_index]\n#align sum_coords_self_apply sum_coords_self_apply\n\n",
 "sum_coords_reindex":
 "@[simp]\ntheorem sum_coords_reindex : (b.reindex e).sum_coords = b.sum_coords :=\n  by\n  ext x\n  simp only [coe_sum_coords, repr_reindex]\n  exact Finsupp.sum_mapDomain_index (fun _ => rfl) fun _ _ _ => rfl\n#align sum_coords_reindex sum_coords_reindex\n\n",
 "subset_extend":
 "theorem subset_extend {s : Set V} (hs : LinearIndependent K (coe : s → V)) : s ⊆ hs.extend (Set.subset_univ _) :=\n  hs.subset_extend _\n#align subset_extend subset_extend\n\n",
 "span_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\nprotected theorem span_eq : span R (range b) = «expr⊤» :=\n  eq_top_iff.mpr fun x _ => b.mem_span x\n#align span_eq span_eq\n\n",
 "span_apply":
 "protected theorem span_apply (i : ι) : (Basis.span hli i : M) = v i :=\n  congr_arg (coe : span R (range v) → M) <| Basis.mk_apply (linearIndependent_span hli) _ i\n#align span_apply span_apply\n\n",
 "smul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_zero /-\nprotected theorem smul_eq_zero [NoZeroDivisors R] (b : Basis ι R M) {c : R} {x : M} :\n    «expr • » c x = 0 ↔ c = 0 ∨ x = 0 :=\n  @smul_eq_zero _ _ _ _ _ b.no_zero_smul_divisors _ _\n#align smul_eq_zero smul_eq_zero\n-/\n\n",
 "singleton_repr":
 "@[simp]\ntheorem singleton_repr (ι R : Type _) [Unique ι] [Semiring R] (x i) : (Basis.singleton ι R).repr x i = x := by\n  simp [Basis.singleton, Unique.eq_default i]\n#align singleton_repr singleton_repr\n\n",
 "singleton_apply":
 "@[simp]\ntheorem singleton_apply (ι R : Type _) [Unique ι] [Semiring R] (i) : Basis.singleton ι R i = 1 :=\n  apply_eq_iff.mpr (by simp [Basis.singleton])\n#align singleton_apply singleton_apply\n\n",
 "restrictScalars_repr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Basis.restrictScalars_repr_apply /-\n@[simp]\ntheorem Basis.restrictScalars_repr_apply (m : span R (Set.range b)) (i : ι) :\n    algebraMap R S ((b.restrict_scalars R).repr m i) = b.repr m i :=\n  by\n  suffices\n    «expr ∘ₗ » (Finsupp.mapRange.linearMap (Algebra.linearMap R S)) (b.restrict_scalars R).repr.to_linear_map =\n      ((b.repr : «expr →ₗ[ ] » M S («expr →₀ » ι S)).restrict_scalars R).dom_restrict _\n    by exact Finsupp.congr_fun (LinearMap.congr_fun this m) i\n  refine' Basis.ext (b.restrict_scalars R) fun _ => _\n  simp only [LinearMap.coe_comp, LinearEquiv.coe_toLinearMap, Function.comp_apply, map_one, Basis.repr_self,\n    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply, LinearMap.domRestrict_apply,\n    LinearEquiv.coe_coe, Basis.restrictScalars_apply, LinearMap.coe_restrictScalars]\n#align basis.restrict_scalars_repr_apply Basis.restrictScalars_repr_apply\n-/\n\n",
 "restrictScalars_apply":
 "#print Basis.restrictScalars_apply /-\n@[simp]\ntheorem Basis.restrictScalars_apply (i : ι) : (b.restrict_scalars R i : M) = b i := by\n  simp only [Basis.restrictScalars, Basis.span_apply]\n#align basis.restrict_scalars_apply Basis.restrictScalars_apply\n-/\n\n",
 "repr_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem repr_units_smul (e : Basis ι R₂ M) (w : ι → «expr ˣ» R₂) (v : M) (i : ι) :\n    (e.units_smul w).repr v i = «expr • » (w i)⁻¹ (e.repr v i) :=\n  congr_arg (fun f : «expr →ₗ[ ] » M R₂ R₂ => f v) (e.coord_units_smul w i)\n#align repr_units_smul repr_units_smul\n\n",
 "repr_total":
 "@[simp]\ntheorem repr_total (v) : b.repr (Finsupp.total _ _ _ b v) = v :=\n  by\n  rw [← b.coe_repr_symm]\n  exact b.repr.apply_symm_apply v\n#align repr_total repr_total\n\n",
 "repr_symm_single_one":
 "theorem repr_symm_single_one : b.repr.symm (Finsupp.single i 1) = b i :=\n  rfl\n#align repr_symm_single_one repr_symm_single_one\n\n",
 "repr_symm_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem repr_symm_single : b.repr.symm (Finsupp.single i c) = «expr • » c (b i) :=\n  calc\n    b.repr.symm (Finsupp.single i c) = b.repr.symm («expr • » c (Finsupp.single i 1)) := by\n      rw [Finsupp.smul_single', mul_one]\n    _ = «expr • » c (b i) := by rw [LinearEquiv.map_smul, repr_symm_single_one]\n    \n#align repr_symm_single repr_symm_single\n\n",
 "repr_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem repr_symm_apply (v) : b.repr.symm v = Finsupp.total ι M R b v :=\n  calc\n    b.repr.symm v = b.repr.symm (v.sum Finsupp.single) := by simp\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" v.support\n          (b.repr.symm (Finsupp.single i (v i))) :=\n      by rw [Finsupp.sum, LinearEquiv.map_sum]\n    _ = Finsupp.total ι M R b v := by simp [repr_symm_single, Finsupp.total_apply, Finsupp.sum]\n    \n#align repr_symm_apply repr_symm_apply\n\n",
 "repr_support_subset_of_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem repr_support_subset_of_mem_span {ι : Type _} (b : Basis ι R M) (s : Set ι) {m : M}\n    (hm : m ∈ span R («expr '' » b s)) : ↑(b.repr m).support ⊆ s :=\n  by\n  rcases(Finsupp.mem_span_image_iff_total _).1 hm with ⟨l, hl, hlm⟩\n  rwa [← hlm, repr_total, ← Finsupp.mem_supported R l]\n#align repr_support_subset_of_mem_span repr_support_subset_of_mem_span\n\n",
 "repr_sum_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.repr_sum_self /-\ntheorem Basis.repr_sum_self (c : ι → R) :\n    «expr⇑ »\n        (b.repr\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (b i)))) =\n      c :=\n  by\n  ext j\n  simp only [map_sum, LinearEquiv.map_smul, repr_self, Finsupp.smul_single, smul_eq_mul, mul_one, Finset.sum_apply']\n  rw [Finset.sum_eq_single j, Finsupp.single_eq_same]\n  · rintro i - hi\n    exact Finsupp.single_eq_of_ne hi\n  · intros\n    have := Finset.mem_univ j\n    contradiction\n#align basis.repr_sum_self Basis.repr_sum_self\n-/\n\n",
 "repr_self_apply":
 "theorem repr_self_apply (j) [Decidable (i = j)] : b.repr (b i) j = if i = j then 1 else 0 := by\n  rw [repr_self, Finsupp.single_apply]\n#align repr_self_apply repr_self_apply\n\n",
 "repr_self":
 "@[simp]\ntheorem repr_self : b.repr (b i) = Finsupp.single i 1 :=\n  LinearEquiv.apply_symm_apply _ _\n#align repr_self repr_self\n\n",
 "repr_reindex_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem repr_reindex_apply (i' : ι') : (b.reindex e).repr x i' = b.repr x (e.symm i') :=\n  show (Finsupp.domLCongr e : «expr ≃ₗ[ ] » _ R _) (b.repr x) i' = _ by simp\n#align repr_reindex_apply repr_reindex_apply\n\n",
 "repr_reindex":
 "@[simp]\ntheorem repr_reindex : (b.reindex e).repr x = (b.repr x).map_domain e :=\n  FunLike.ext _ _ <| by simp [repr_reindex_apply]\n#align repr_reindex repr_reindex\n\n",
 "repr_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem repr_range : (b.repr : «expr →ₗ[ ] » M R («expr →₀ » ι R)).range = Finsupp.supported R R univ := by\n  rw [LinearEquiv.range, Finsupp.supported_univ]\n#align repr_range repr_range\n\n",
 "repr_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Alexander Bentkamp\n-/\ntheorem repr_injective : injective (repr : Basis ι R M → «expr ≃ₗ[ ] » M R («expr →₀ » ι R)) := fun f g h => by\n  cases f <;> cases g <;> congr\n#align repr_injective repr_injective\n\n",
 "repr_eq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem repr_eq_iff' {b : Basis ι R M} {f : «expr ≃ₗ[ ] » M R («expr →₀ » ι R)} :\n    b.repr = f ↔ ∀ i, f (b i) = Finsupp.single i 1 :=\n  ⟨fun h i => h ▸ b.repr_self i, fun h => b.ext' fun i => (b.repr_self i).trans (h i).symm⟩\n#align repr_eq_iff' repr_eq_iff'\n\n",
 "repr_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem repr_eq_iff {b : Basis ι R M} {f : «expr →ₗ[ ] » M R («expr →₀ » ι R)} :\n    ↑b.repr = f ↔ ∀ i, f (b i) = Finsupp.single i 1 :=\n  ⟨fun h i => h ▸ b.repr_self i, fun h => b.ext fun i => (b.repr_self i).trans (h i).symm⟩\n#align repr_eq_iff repr_eq_iff\n\n",
 "repr_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An unbundled version of `repr_eq_iff` -/\ntheorem repr_apply_eq (f : M → ι → R) (hadd : ∀ x y, f (x + y) = f x + f y)\n    (hsmul : ∀ (c : R) (x : M), f («expr • » c x) = «expr • » c (f x)) (f_eq : ∀ i, f (b i) = Finsupp.single i 1)\n    (x : M) (i : ι) : b.repr x i = f x i :=\n  by\n  let f_i : «expr →ₗ[ ] » M R R :=\n    { to_fun := fun x => f x i\n      map_add' := fun _ _ => by rw [hadd, Pi.add_apply]\n      map_smul' := fun _ _ => by simp [hsmul, Pi.smul_apply] }\n  have : «expr ∘ₗ » (Finsupp.lapply i) ↑b.repr = f_i :=\n    by\n    refine' b.ext fun j => _\n    show b.repr (b j) i = f (b j) i\n    rw [b.repr_self, f_eq]\n  calc\n    b.repr x i = f_i x := by\n      rw [← this]\n      rfl\n    _ = f x i := rfl\n    \n#align repr_apply_eq repr_apply_eq\n\n",
 "reindex_refl":
 "@[simp]\ntheorem reindex_refl : b.reindex (Equiv.refl ι) = b :=\n  eq_of_apply_eq fun i => by simp\n#align reindex_refl reindex_refl\n\n",
 "reindex_range_self":
 "theorem reindex_range_self (i : ι) (h := Set.mem_range_self i) : b.reindex_range ⟨b i, h⟩ = b i :=\n  by\n  by_cases htr : Nontrivial R\n  · letI := htr\n    simp [htr, reindex_range, reindex_apply, Equiv.apply_ofInjective_symm b.injective, Subtype.coe_mk]\n  · letI : subsingleton R := not_nontrivial_iff_subsingleton.mp htr\n    letI := Module.subsingleton R M\n    simp [reindex_range]\n#align reindex_range_self reindex_range_self\n\n",
 "reindex_range_repr_self":
 "theorem reindex_range_repr_self (i : ι) : b.reindex_range.repr (b i) = Finsupp.single ⟨b i, mem_range_self i⟩ 1 :=\n  calc\n    b.reindex_range.repr (b i) = b.reindex_range.repr (b.reindex_range ⟨b i, mem_range_self i⟩) :=\n      congr_arg _ (b.reindex_range_self _ _).symm\n    _ = Finsupp.single ⟨b i, mem_range_self i⟩ 1 := b.reindex_range.repr_self _\n    \n#align reindex_range_repr_self reindex_range_repr_self\n\n",
 "reindex_range_repr'":
 "theorem reindex_range_repr' (x : M) {bi : M} {i : ι} (h : b i = bi) :\n    b.reindex_range.repr x ⟨bi, ⟨i, h⟩⟩ = b.repr x i :=\n  by\n  nontriviality\n  subst h\n  refine' (b.repr_apply_eq (fun x i => b.reindex_range.repr x ⟨b i, _⟩) _ _ _ x i).symm\n  · intro x y\n    ext i\n    simp only [Pi.add_apply, LinearEquiv.map_add, Finsupp.coe_add]\n  · intro c x\n    ext i\n    simp only [Pi.smul_apply, LinearEquiv.map_smul, Finsupp.coe_smul]\n  · intro i\n    ext j\n    simp only [reindex_range_repr_self]\n    refine' @Finsupp.single_apply_left _ _ _ _ (fun i => (⟨b i, _⟩ : Set.range b)) _ _ _ _\n    exact fun i j h => b.injective (subtype.mk.inj h)\n#align reindex_range_repr' reindex_range_repr'\n\n",
 "reindex_range_repr":
 "@[simp]\ntheorem reindex_range_repr (x : M) (i : ι) (h := Set.mem_range_self i) : b.reindex_range.repr x ⟨b i, h⟩ = b.repr x i :=\n  b.reindex_range_repr' _ rfl\n#align reindex_range_repr reindex_range_repr\n\n",
 "reindex_range_apply":
 "@[simp]\ntheorem reindex_range_apply (x : range b) : b.reindex_range x = x :=\n  by\n  rcases x with ⟨bi, ⟨i, rfl⟩⟩\n  exact b.reindex_range_self i\n#align reindex_range_apply reindex_range_apply\n\n",
 "reindex_finset_range_self":
 "theorem reindex_finset_range_self (i : ι) (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindex_finset_range ⟨b i, h⟩ = b i :=\n  by\n  rw [reindex_finset_range, reindex_apply, reindex_range_apply]\n  rfl\n#align reindex_finset_range_self reindex_finset_range_self\n\n",
 "reindex_finset_range_repr_self":
 "theorem reindex_finset_range_repr_self (i : ι) :\n    b.reindex_finset_range.repr (b i) = Finsupp.single ⟨b i, Finset.mem_image_of_mem b (Finset.mem_univ i)⟩ 1 :=\n  by\n  ext ⟨bi, hbi⟩\n  rw [reindex_finset_range, repr_reindex, Finsupp.mapDomain_equiv_apply, reindex_range_repr_self]\n  convert Finsupp.single_apply_left ((Equiv.refl M).subtype_equiv _).symm.injective _ _ _\n  rfl\n#align reindex_finset_range_repr_self reindex_finset_range_repr_self\n\n",
 "reindex_finset_range_repr":
 "@[simp]\ntheorem reindex_finset_range_repr (x : M) (i : ι) (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindex_finset_range.repr x ⟨b i, h⟩ = b.repr x i := by simp [reindex_finset_range]\n#align reindex_finset_range_repr reindex_finset_range_repr\n\n",
 "reindex_finset_range_apply":
 "@[simp]\ntheorem reindex_finset_range_apply (x : Finset.univ.image b) : b.reindex_finset_range x = x :=\n  by\n  rcases x with ⟨bi, hbi⟩\n  rcases finset.mem_image.mp hbi with ⟨i, -, rfl⟩\n  exact b.reindex_finset_range_self i\n#align reindex_finset_range_apply reindex_finset_range_apply\n\n",
 "reindex_apply":
 "theorem reindex_apply (i' : ι') : b.reindex e i' = b (e.symm i') :=\n  show (b.repr.trans (Finsupp.domLCongr e)).symm (Finsupp.single i' 1) = b.repr.symm (Finsupp.single (e.symm i') 1) by\n    rw [LinearEquiv.symm_trans_apply, Finsupp.domLCongr_symm, Finsupp.domLCongr_single]\n#align reindex_apply reindex_apply\n\n",
 "range_reindex":
 "/-- `simp` can prove this as `basis.coe_reindex` + `equiv_like.range_comp` -/\ntheorem range_reindex : Set.range (b.reindex e) = Set.range b := by rw [coe_reindex, EquivLike.range_comp]\n#align range_reindex range_reindex\n\n",
 "range_of_vector_space":
 "theorem range_of_vector_space : range (ofVectorSpace K V) = ofVectorSpaceIndex K V :=\n  range_extend _\n#align range_of_vector_space range_of_vector_space\n\n",
 "range_extend":
 "theorem range_extend (hs : LinearIndependent K (coe : s → V)) : range (Basis.extend hs) = hs.extend (subset_univ _) :=\n  by rw [coe_extend, Subtype.range_coe_subtype, set_of_mem_eq]\n#align range_extend range_extend\n\n",
 "quotient_prod_linearEquiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print quotient_prod_linearEquiv /-\ntheorem quotient_prod_linearEquiv (p : Submodule K V) : Nonempty («expr ≃ₗ[ ] » («expr ⧸ » V p × p) K V) :=\n  let ⟨q, hq⟩ := p.exists_is_compl\n  nonempty.intro <| ((quotientEquivOfIsCompl p q hq).prod (LinearEquiv.refl _ _)).trans (prodEquivOfIsCompl q p hq.symm)\n#align quotient_prod_linear_equiv quotient_prod_linearEquiv\n-/\n\n",
 "prod_repr_inr":
 "@[simp]\ntheorem prod_repr_inr (x) (i) : (b.prod b').repr x (Sum.inr i) = b'.repr x.2 i :=\n  rfl\n#align prod_repr_inr prod_repr_inr\n\n",
 "prod_repr_inl":
 "@[simp]\ntheorem prod_repr_inl (x) (i) : (b.prod b').repr x (Sum.inl i) = b.repr x.1 i :=\n  rfl\n#align prod_repr_inl prod_repr_inl\n\n",
 "prod_apply_inr_snd":
 "theorem prod_apply_inr_snd (i) : (b.prod b' (Sum.inr i)).2 = b' i :=\n  b'.repr.injective <| by\n    ext i\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b'.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      Finsupp.snd_sumFinsuppLEquivProdFinsupp]\n    apply Finsupp.single_apply_left Sum.inr_injective\n#align prod_apply_inr_snd prod_apply_inr_snd\n\n",
 "prod_apply_inr_fst":
 "theorem prod_apply_inr_fst (i) : (b.prod b' (Sum.inr i)).1 = 0 :=\n  b.repr.injective <| by\n    ext i\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      Finsupp.fst_sumFinsuppLEquivProdFinsupp, LinearEquiv.map_zero, Finsupp.zero_apply]\n    apply Finsupp.single_eq_of_ne Sum.inr_ne_inl\n#align prod_apply_inr_fst prod_apply_inr_fst\n\n",
 "prod_apply_inl_snd":
 "theorem prod_apply_inl_snd (i) : (b.prod b' (Sum.inl i)).2 = 0 :=\n  b'.repr.injective <| by\n    ext j\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b'.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      Finsupp.snd_sumFinsuppLEquivProdFinsupp, LinearEquiv.map_zero, Finsupp.zero_apply]\n    apply Finsupp.single_eq_of_ne Sum.inl_ne_inr\n#align prod_apply_inl_snd prod_apply_inl_snd\n\n",
 "prod_apply_inl_fst":
 "theorem prod_apply_inl_fst (i) : (b.prod b' (Sum.inl i)).1 = b i :=\n  b.repr.injective <| by\n    ext j\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      Finsupp.fst_sumFinsuppLEquivProdFinsupp]\n    apply Finsupp.single_apply_left Sum.inl_injective\n#align prod_apply_inl_fst prod_apply_inl_fst\n\n",
 "prod_apply":
 "@[simp]\ntheorem prod_apply (i) : b.prod b' i = Sum.elim (LinearMap.inl R M M' ∘ b) (LinearMap.inr R M M' ∘ b') i := by\n  ext <;> cases i <;>\n    simp only [prod_apply_inl_fst, Sum.elim_inl, LinearMap.inl_apply, prod_apply_inr_fst, Sum.elim_inr,\n      LinearMap.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]\n#align prod_apply prod_apply\n\n",
 "of_vector_space_apply_self":
 "theorem of_vector_space_apply_self (x : ofVectorSpaceIndex K V) : ofVectorSpace K V x = x :=\n  Basis.mk_apply _ _ _\n#align of_vector_space_apply_self of_vector_space_apply_self\n\n",
 "ofEquivFun_repr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Basis.ofEquivFun_repr_apply /-\n@[simp]\ntheorem Basis.ofEquivFun_repr_apply (e : «expr ≃ₗ[ ] » M R (ι → R)) (x : M) (i : ι) :\n    (Basis.ofEquivFun e).repr x i = e x i :=\n  rfl\n#align basis.of_equiv_fun_repr_apply Basis.ofEquivFun_repr_apply\n-/\n\n",
 "ofEquivFun_equivFun":
 "#print Basis.ofEquivFun_equivFun /-\n@[simp]\ntheorem Basis.ofEquivFun_equivFun (v : Basis ι R M) : Basis.ofEquivFun v.equiv_fun = v := by\n  classical\n    ext j\n    simp only [Basis.equivFun_symm_apply, Basis.coe_ofEquivFun]\n    simp_rw [Function.update_apply, ite_smul]\n    simp only [Finset.mem_univ, if_true, Pi.zero_apply, one_smul, Finset.sum_ite_eq', zero_smul]\n#align basis.of_equiv_fun_equiv_fun Basis.ofEquivFun_equivFun\n-/\n\n",
 "nonzero_span_atom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print nonzero_span_atom /-\n/-- For a module over a division ring, the span of a nonzero element is an atom of the\nlattice of submodules. -/\ntheorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : Submodule K V) :=\n  by\n  constructor\n  · rw [Submodule.ne_bot_iff]\n    exact ⟨v, ⟨mem_span_singleton_self v, hv⟩⟩\n  · intro T hT\n    by_contra\n    apply hT.2\n    change span K {v} ≤ T\n    simp_rw [span_singleton_le_iff_mem, ← ne.def, Submodule.ne_bot_iff] at *\n    rcases h with ⟨s, ⟨hs, hz⟩⟩\n    cases' mem_span_singleton.1 (hT.1 hs) with a ha\n    have h : a ≠ 0 := by\n      intro h\n      rw [h, zero_smul] at ha\n      exact hz ha.symm\n    apply_fun fun x => «expr • » a⁻¹ x  at ha\n    simp_rw [← mul_smul, inv_mul_cancel h, one_smul, ha] at *\n    exact smul_mem T _ hs\n#align nonzero_span_atom nonzero_span_atom\n-/\n\n",
 "mk_repr":
 "@[simp]\ntheorem mk_repr : (Basis.mk hli hsp).repr x = hli.repr ⟨x, hsp Submodule.mem_top⟩ :=\n  rfl\n#align mk_repr mk_repr\n\n",
 "mk_coord_apply_ne":
 "/-- Given a basis, the `i`th element of the dual basis evaluates to 0 on the `j`th element of the\nbasis if `j ≠ i`. -/\ntheorem mk_coord_apply_ne {i j : ι} (h : j ≠ i) : (Basis.mk hli hsp).coord i (v j) = 0 :=\n  show hli.repr ⟨v j, Submodule.subset_span (mem_range_self j)⟩ i = 0 by simp [hli.repr_eq_single j, h]\n#align mk_coord_apply_ne mk_coord_apply_ne\n\n",
 "mk_coord_apply_eq":
 "/-- Given a basis, the `i`th element of the dual basis evaluates to 1 on the `i`th element of the\nbasis. -/\ntheorem mk_coord_apply_eq (i : ι) : (Basis.mk hli hsp).coord i (v i) = 1 :=\n  show hli.repr ⟨v i, Submodule.subset_span (mem_range_self i)⟩ i = 1 by simp [hli.repr_eq_single i]\n#align mk_coord_apply_eq mk_coord_apply_eq\n\n",
 "mk_coord_apply":
 "/-- Given a basis, the `i`th element of the dual basis evaluates to the Kronecker delta on the\n`j`th element of the basis. -/\ntheorem mk_coord_apply [DecidableEq ι] {i j : ι} : (Basis.mk hli hsp).coord i (v j) = if j = i then 1 else 0 :=\n  by\n  cases eq_or_ne j i\n  · simp only [h, if_true, eq_self_iff_true, mk_coord_apply_eq i]\n  · simp only [h, if_false, mk_coord_apply_ne h]\n#align mk_coord_apply mk_coord_apply\n\n",
 "mk_apply":
 "theorem mk_apply (i : ι) : Basis.mk hli hsp i = v i :=\n  show Finsupp.total _ _ _ v _ = v i by simp\n#align mk_apply mk_apply\n\n",
 "mem_submodule_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.mem_submodule_iff' /-\n/-- If the submodule `P` has a finite basis,\n`x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem Basis.mem_submodule_iff' {P : Submodule R M} (b : Basis ι R P) {x : M} :\n    x ∈ P ↔\n      ∃ c : ι → R,\n        x =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (b i)) :=\n  b.mem_submodule_iff.trans <|\n    Finsupp.equivFunOnFinite.exists_congr_left.trans <| exists_congr fun c => by simp [Finsupp.sum_fintype]\n#align basis.mem_submodule_iff' Basis.mem_submodule_iff'\n-/\n\n",
 "mem_submodule_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If the submodule `P` has a basis, `x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem mem_submodule_iff {P : Submodule R M} (b : Basis ι R P) {x : M} :\n    x ∈ P ↔ ∃ c : «expr →₀ » ι R, x = Finsupp.sum c fun i x => «expr • » x (b i) :=\n  by\n  conv_lhs =>\n    rw [← P.range_subtype, ← Submodule.map_top, ← b.span_eq, Submodule.map_span, ← Set.range_comp, ←\n      Finsupp.range_total]\n  simpa only [@eq_comm _ x]\n#align mem_submodule_iff mem_submodule_iff\n\n",
 "mem_span_repr_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_span_repr_support {ι : Type _} (b : Basis ι R M) (m : M) : m ∈ span R («expr '' » b (b.repr m).support) :=\n  (Finsupp.mem_span_image_iff_total _).2 ⟨b.repr m, by simp [Finsupp.mem_supported_support]⟩\n#align mem_span_repr_support mem_span_repr_support\n\n",
 "mem_span_iff_repr_mem":
 "#print Basis.mem_span_iff_repr_mem /-\n/-- Let `b` be a `S`-basis of `M`. Then `m : M` lies in the `R`-module spanned by `b` iff all the\ncoordinates of `m` on the basis `b` are in `R` (see `basis.mem_span` for the case `R = S`). -/\ntheorem Basis.mem_span_iff_repr_mem (m : M) : m ∈ span R (Set.range b) ↔ ∀ i, b.repr m i ∈ Set.range (algebraMap R S) :=\n  by\n  refine' ⟨fun hm i => ⟨(b.restrict_scalars R).repr ⟨m, hm⟩ i, b.restrict_scalars_repr_apply R ⟨m, hm⟩ i⟩, fun h => _⟩\n  rw [← b.total_repr m, Finsupp.total_apply S _]\n  refine' sum_mem fun i _ => _\n  obtain ⟨_, h⟩ := h i\n  simp_rw [← h, algebraMap_smul]\n  exact smul_mem _ _ (subset_span (Set.mem_range_self i))\n#align basis.mem_span_iff_repr_mem Basis.mem_span_iff_repr_mem\n-/\n\n",
 "mem_span":
 "protected theorem mem_span (x : M) : x ∈ span R (range b) :=\n  by\n  rw [← b.total_repr x, Finsupp.total_apply, Finsupp.sum]\n  exact Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ (Submodule.subset_span ⟨i, rfl⟩)\n#align mem_span mem_span\n\n",
 "maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any basis is a maximal linear independent set.\n-/\ntheorem maximal [Nontrivial R] (b : Basis ι R M) : b.linear_independent.maximal := fun w hi h =>\n  by\n  -- If `range w` is strictly bigger than `range b`,\n  apply le_antisymm h\n  -- then choose some `x ∈ range w \\ range b`,\n  intro x p\n  by_contra q\n  -- and write it in terms of the basis.\n  have e := b.total_repr x\n  -- This then expresses `x` as a linear combination\n  -- of elements of `w` which are in the range of `b`,\n  let u : «expr ↪ » ι w :=\n    ⟨fun i => ⟨b i, h ⟨i, rfl⟩⟩, fun i i' r => b.injective (by simpa only [Subtype.mk_eq_mk] using r)⟩\n  have r : ∀ i, b i = u i := fun i => rfl\n  simp_rw [Finsupp.total_apply, r] at e\n  change\n    ((b.repr x).sum fun (i : ι) (a : R) => (fun (x : w) (r : R) => «expr • » r (x : M)) (u i) a) = ((⟨x, p⟩ : w) : M) at\n    e\n  rw [← Finsupp.sum_embDomain, ← Finsupp.total_apply] at e\n  -- Now we can contradict the linear independence of `hi`\n  refine' hi.total_ne_of_not_mem_support _ _ e\n  simp only [Finset.mem_map, Finsupp.support_embDomain]\n  rintro ⟨j, -, W⟩\n  simp only [embedding.coe_fn_mk, Subtype.mk_eq_mk, ← r] at W\n  apply q ⟨j, W⟩\n#align maximal maximal\n\n",
 "map_equivFun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Basis.map_equivFun /-\n@[simp]\ntheorem Basis.map_equivFun (f : «expr ≃ₗ[ ] » M R M') : (b.map f).equiv_fun = f.symm.trans b.equiv_fun :=\n  rfl\n#align basis.map_equiv_fun Basis.map_equivFun\n-/\n\n",
 "map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem map_equiv (b : Basis ι R M) (b' : Basis ι' R M') (e : «expr ≃ » ι ι') :\n    b.map (b.equiv b' e) = b'.reindex e.symm := by\n  ext i\n  simp\n#align map_equiv map_equiv\n\n",
 "map_coeffs_apply":
 "theorem map_coeffs_apply (i : ι) : b.map_coeffs f h i = b i :=\n  apply_eq_iff.mpr <| by simp [f.to_add_equiv_eq_coe]\n#align map_coeffs_apply map_coeffs_apply\n\n",
 "map_apply":
 "@[simp]\ntheorem map_apply (i) : b.map f i = f (b i) :=\n  rfl\n#align map_apply map_apply\n\n",
 "linear_independent":
 "theorem of_vector_space_index.linear_independent : LinearIndependent K (coe : ofVectorSpaceIndex K V → V) :=\n  by\n  convert(of_vector_space K V).linear_independent\n  ext x\n  rw [of_vector_space_apply_self]\n#align of_vector_space_index.linear_independent of_vector_space_index.linear_independent\n\n",
 "is_unit_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_unit_smul_apply {v : Basis ι R M} {w : ι → R} (hw : ∀ i, IsUnit (w i)) (i : ι) :\n    v.is_unit_smul hw i = «expr • » (w i) (v i) :=\n  unitsSMul_apply i\n#align is_unit_smul_apply is_unit_smul_apply\n\n",
 "injective":
 "protected theorem injective [Nontrivial R] : injective b :=\n  b.repr.symm.injective.comp fun _ _ => (Finsupp.single_left_inj (one_ne_zero : (1 : R) ≠ 0)).mp\n#align injective injective\n\n",
 "index_nonempty":
 "theorem index_nonempty (b : Basis ι R M) [Nontrivial M] : Nonempty ι :=\n  by\n  obtain ⟨x, y, ne⟩ : ∃ x y : M, x ≠ y := nontrivial.exists_pair_ne\n  obtain ⟨i, _⟩ := not_forall.mp (mt b.ext_elem_iff.2 ne)\n  exact ⟨i⟩\n#align index_nonempty index_nonempty\n\n",
 "group_smul_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem group_smul_span_eq_top {G : Type _} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] {v : ι → M} (hv : Submodule.span R (Set.range v) = «expr⊤») {w : ι → G} :\n    Submodule.span R (Set.range («expr • » w v)) = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro j hj\n  rw [← hv] at hj\n  rw [Submodule.mem_span] at hj⊢\n  refine' fun p hp => hj p fun u hu => _\n  obtain ⟨i, rfl⟩ := hu\n  have : «expr • » («expr • » (w i)⁻¹ 1 : R) («expr • » (w i) (v i)) ∈ p :=\n    p.smul_mem («expr • » (w i)⁻¹ 1 : R) (hp ⟨i, rfl⟩)\n  rwa [smul_one_smul, inv_smul_smul] at this\n#align group_smul_span_eq_top group_smul_span_eq_top\n\n",
 "group_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem group_smul_apply {G : Type _} [Group G] [DistribMulAction G R] [DistribMulAction G M] [IsScalarTower G R M]\n    [SMulCommClass G R M] {v : Basis ι R M} {w : ι → G} (i : ι) : v.group_smul w i = («expr • » w v : ι → M) i :=\n  mk_apply (v.linear_independent.group_smul w) (groupSmul_span_eq_top v.span_eq).ge i\n#align group_smul_apply group_smul_apply\n\n",
 "forall_coord_eq_zero_iff":
 "theorem forall_coord_eq_zero_iff {x : M} : (∀ i, b.coord i x = 0) ↔ x = 0 :=\n  iff.trans (by simp only [b.coord_apply, Finsupp.ext_iff, Finsupp.zero_apply]) b.repr.map_eq_zero_iff\n#align forall_coord_eq_zero_iff forall_coord_eq_zero_iff\n\n",
 "fin_two_prod_zero":
 "@[simp]\ntheorem fin_two_prod_zero (R : Type _) [Semiring R] : Basis.finTwoProd R 0 = (1, 0) := by simp [Basis.finTwoProd]\n#align fin_two_prod_zero fin_two_prod_zero\n\n",
 "fin_two_prod_one":
 "@[simp]\ntheorem fin_two_prod_one (R : Type _) [Semiring R] : Basis.finTwoProd R 1 = (0, 1) := by simp [Basis.finTwoProd]\n#align fin_two_prod_one fin_two_prod_one\n\n",
 "extend_apply_self":
 "theorem extend_apply_self (hs : LinearIndependent K (coe : s → V)) (x : hs.extend _) : Basis.extend hs x = x :=\n  Basis.mk_apply _ _ _\n#align extend_apply_self extend_apply_self\n\n",
 "ext_elem_iff":
 "/-- Two elements are equal iff their coordinates are equal. -/\ntheorem ext_elem_iff {x y : M} : x = y ↔ ∀ i, b.repr x i = b.repr y i := by\n  simp only [← Finsupp.ext_iff, EmbeddingLike.apply_eq_iff_eq]\n#align ext_elem_iff ext_elem_iff\n\n",
 "ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/-- Two linear equivs are equal if they are equal on basis vectors. -/\ntheorem ext' {f₁ f₂ : «expr ≃ₛₗ[ ] » M σ M₁} (h : ∀ i, f₁ (b i) = f₂ (b i)) : f₁ = f₂ :=\n  by\n  ext x\n  rw [← b.total_repr x, Finsupp.total_apply, Finsupp.sum]\n  simp only [LinearEquiv.map_sum, LinearEquiv.map_smulₛₗ, h]\n#align ext' ext'\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- Two linear maps are equal if they are equal on basis vectors. -/\ntheorem ext {f₁ f₂ : «expr →ₛₗ[ ] » M σ M₁} (h : ∀ i, f₁ (b i) = f₂ (b i)) : f₁ = f₂ :=\n  by\n  ext x\n  rw [← b.total_repr x, Finsupp.total_apply, Finsupp.sum]\n  simp only [LinearMap.map_sum, LinearMap.map_smulₛₗ, h]\n#align ext ext\n\n",
 "exists_rightInverse_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.exists_rightInverse_of_surjective /-\ntheorem LinearMap.exists_rightInverse_of_surjective (f : «expr →ₗ[ ] » V K V') (hf_surj : f.range = «expr⊤») :\n    ∃ g : «expr →ₗ[ ] » V' K V, f.comp g = LinearMap.id :=\n  by\n  let C := Basis.ofVectorSpaceIndex K V'\n  let hC := Basis.ofVectorSpace K V'\n  haveI : Inhabited V := ⟨0⟩\n  use hC.constr ℕ (C.restrict (inv_fun f))\n  refine' hC.ext fun c => _\n  rw [LinearMap.comp_apply, hC.constr_basis]\n  simp [right_inverse_inv_fun (LinearMap.range_eq_top.1 hf_surj) c]\n#align linear_map.exists_right_inverse_of_surjective LinearMap.exists_rightInverse_of_surjective\n-/\n\n",
 "exists_leftInverse_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.exists_leftInverse_of_injective /-\ntheorem LinearMap.exists_leftInverse_of_injective (f : «expr →ₗ[ ] » V K V') (hf_inj : f.ker = «expr⊥») :\n    ∃ g : «expr →ₗ[ ] » V' K V, g.comp f = LinearMap.id :=\n  by\n  let B := Basis.ofVectorSpaceIndex K V\n  let hB := Basis.ofVectorSpace K V\n  have hB₀ : _ := hB.linear_independent.to_subtype_range\n  have : LinearIndependent K (fun x => x : «expr '' » f B → V') :=\n    by\n    have h₁ : LinearIndependent K fun x : «expr↥ » («expr '' » («expr⇑ » f) (range (Basis.ofVectorSpace _ _))) => ↑x :=\n      @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ f hB₀ (show Disjoint _ _ by simp [hf_inj])\n    rwa [Basis.range_ofVectorSpace K V] at h₁\n  let C := this.extend (subset_univ _)\n  have BC := this.subset_extend (subset_univ _)\n  let hC := Basis.extend this\n  haveI : Inhabited V := ⟨0⟩\n  refine' ⟨hC.constr ℕ (C.restrict (inv_fun f)), hB.ext fun b => _⟩\n  rw [image_subset_iff] at BC\n  have fb_eq : f b = hC ⟨f b, BC b.2⟩ := by\n    change f b = Basis.extend this _\n    rw [Basis.extend_apply_self, Subtype.coe_mk]\n  dsimp [hB]\n  rw [Basis.ofVectorSpace_apply_self, fb_eq, hC.constr_basis]\n  exact left_inverse_inv_fun (LinearMap.ker_eq_bot.1 hf_inj) _\n#align linear_map.exists_left_inverse_of_injective LinearMap.exists_leftInverse_of_injective\n-/\n\n",
 "exists_le_ker_of_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (f «expr ≠ » (0 : «expr →ₗ[ ] »(V, K, K))) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Submodule.exists_le_ker_of_lt_top /-\n/-- If `p < ⊤` is a subspace of a vector space `V`, then there exists a nonzero linear map\n`f : V →ₗ[K] K` such that `p ≤ ker f`. -/\ntheorem Submodule.exists_le_ker_of_lt_top (p : Submodule K V) (hp : p < «expr⊤») :\n    ∃ (f : _)(_ : f ≠ (0 : «expr →ₗ[ ] » V K K)), p ≤ ker f :=\n  by\n  rcases SetLike.exists_of_lt hp with ⟨v, -, hpv⟩; clear hp\n  rcases(LinearPMap.supSpanSingleton ⟨p, 0⟩ v (1 : K) hpv).to_fun.exists_extend with ⟨f, hf⟩\n  refine' ⟨f, _, _⟩\n  · rintro rfl\n    rw [LinearMap.zero_comp] at hf\n    have := LinearPMap.supSpanSingleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv 0 p.zero_mem 1\n    simpa using (LinearMap.congr_fun hf _).trans this\n  · refine' fun x hx => mem_ker.2 _\n    have := LinearPMap.supSpanSingleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv x hx 0\n    simpa using (LinearMap.congr_fun hf _).trans this\n#align submodule.exists_le_ker_of_lt_top Submodule.exists_le_ker_of_lt_top\n-/\n\n",
 "exists_isCompl":
 "#print Submodule.exists_isCompl /-\ntheorem Submodule.exists_isCompl (p : Submodule K V) : ∃ q : Submodule K V, IsCompl p q :=\n  let ⟨f, hf⟩ := p.subtype.exists_left_inverse_of_injective p.ker_subtype\n  ⟨f.ker, LinearMap.isCompl_of_proj <| LinearMap.ext_iff.1 hf⟩\n#align submodule.exists_is_compl Submodule.exists_isCompl\n-/\n\n",
 "exists_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.exists_extend /-\n/-- Any linear map `f : p →ₗ[K] V'` defined on a subspace `p` can be extended to the whole\nspace. -/\ntheorem LinearMap.exists_extend {p : Submodule K V} (f : «expr →ₗ[ ] » p K V') :\n    ∃ g : «expr →ₗ[ ] » V K V', g.comp p.subtype = f :=\n  let ⟨g, hg⟩ := p.subtype.exists_left_inverse_of_injective p.ker_subtype\n  ⟨f.comp g, by rw [LinearMap.comp_assoc, hg, f.comp_id]⟩\n#align linear_map.exists_extend LinearMap.exists_extend\n-/\n\n",
 "exists_basis":
 "theorem exists_basis : ∃ s : Set V, Nonempty (Basis s K V) :=\n  ⟨ofVectorSpaceIndex K V, ⟨ofVectorSpace K V⟩⟩\n#align exists_basis exists_basis\n\n",
 "equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem equiv_trans {ι'' : Type _} (b'' : Basis ι'' R M'') (e : «expr ≃ » ι ι') (e' : «expr ≃ » ι' ι'') :\n    (b.equiv b' e).trans (b'.equiv b'' e') = b.equiv b'' (e.trans e') :=\n  b.ext' fun i => by simp\n#align equiv_trans equiv_trans\n\n",
 "equiv_symm":
 "@[simp]\ntheorem equiv_symm : (b.equiv b' e).symm = b'.equiv b e.symm :=\n  b'.ext' fun i => (b.equiv b' e).injective (by simp)\n#align equiv_symm equiv_symm\n\n",
 "equiv_refl":
 "@[simp]\ntheorem equiv_refl : b.equiv b (Equiv.refl ι) = LinearEquiv.refl R M :=\n  b.ext' fun i => by simp\n#align equiv_refl equiv_refl\n\n",
 "equiv_apply":
 "@[simp]\ntheorem equiv_apply : b.equiv b' e (b i) = b' (e i) := by simp [Basis.equiv]\n#align equiv_apply equiv_apply\n\n",
 "equivFun_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.equivFun_symm_apply /-\n/-- Given a basis `v` indexed by `ι`, the canonical linear equivalence between `ι → R` and `M` maps\na function `x : ι → R` to the linear combination `∑_i x i • v i`. -/\n@[simp]\ntheorem Basis.equivFun_symm_apply (x : ι → R) :\n    b.equiv_fun.symm x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (x i) (b i)) :=\n  by simp [Basis.equivFun, Finsupp.total_apply, Finsupp.sum_fintype]\n#align basis.equiv_fun_symm_apply Basis.equivFun_symm_apply\n-/\n\n",
 "equivFun_self":
 "#print Basis.equivFun_self /-\n@[simp]\ntheorem Basis.equivFun_self [DecidableEq ι] (i j : ι) : b.equiv_fun (b i) j = if i = j then 1 else 0 := by\n  rw [b.equiv_fun_apply, b.repr_self_apply]\n#align basis.equiv_fun_self Basis.equivFun_self\n-/\n\n",
 "equivFun_apply":
 "#print Basis.equivFun_apply /-\n@[simp]\ntheorem Basis.equivFun_apply (u : M) : b.equiv_fun u = b.repr u :=\n  rfl\n#align basis.equiv_fun_apply Basis.equivFun_apply\n-/\n\n",
 "equiv'_symm_apply":
 "@[simp]\ntheorem equiv'_symm_apply (f : M → M') (g : M' → M) (hf hg hgf hfg) (i : ι') :\n    (b.equiv' b' f g hf hg hgf hfg).symm (b' i) = g (b' i) :=\n  b'.constr_basis R _ _\n#align equiv'_symm_apply equiv'_symm_apply\n\n",
 "equiv'_apply":
 "@[simp]\ntheorem equiv'_apply (f : M → M') (g : M' → M) (hf hg hgf hfg) (i : ι) :\n    b.equiv' b' f g hf hg hgf hfg (b i) = f (b i) :=\n  b.constr_basis R _ _\n#align equiv'_apply equiv'_apply\n\n",
 "eq_of_repr_eq_repr":
 "/-- Two bases are equal if they assign the same coordinates. -/\ntheorem eq_of_repr_eq_repr {b₁ b₂ : Basis ι R M} (h : ∀ x i, b₁.repr x i = b₂.repr x i) : b₁ = b₂ :=\n  repr_injective <| by\n    ext\n    apply h\n#align eq_of_repr_eq_repr eq_of_repr_eq_repr\n\n",
 "eq_of_apply_eq":
 "/-- Two bases are equal if their basis vectors are the same. -/\n@[ext]\ntheorem eq_of_apply_eq {b₁ b₂ : Basis ι R M} : (∀ i, b₁ i = b₂ i) → b₁ = b₂ :=\n  FunLike.ext _ _\n#align eq_of_apply_eq eq_of_apply_eq\n\n",
 "eq_bot_of_rank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Basis.eq_bot_of_rank_eq_zero /-\ntheorem Basis.eq_bot_of_rank_eq_zero [NoZeroDivisors R] (b : Basis ι R M) (N : Submodule R M)\n    (rank_eq : ∀ {m : ℕ} (v : Fin m → N), LinearIndependent R (coe ∘ v : Fin m → M) → m = 0) : N = «expr⊥» :=\n  by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  contrapose! rank_eq with x_ne\n  refine' ⟨1, fun _ => ⟨x, hx⟩, _, one_ne_zero⟩\n  rw [Fintype.linearIndependent_iff]\n  rintro g sum_eq i\n  cases i\n  simp only [Function.const_apply, Fin.default_eq_zero, Submodule.coe_mk, Finset.univ_unique, Function.comp_const,\n    Finset.sum_singleton] at sum_eq\n  convert(b.smul_eq_zero.mp sum_eq).resolve_right x_ne\n#align eq_bot_of_rank_eq_zero Basis.eq_bot_of_rank_eq_zero\n-/\n\n",
 "dvd_coord_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem dvd_coord_smul (i : ι) (m : M) (r : R) : r ∣ b.coord i («expr • » r m) :=\n  ⟨b.coord i m, by simp⟩\n#align dvd_coord_smul dvd_coord_smul\n\n",
 "coord_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coord_units_smul (e : Basis ι R₂ M) (w : ι → «expr ˣ» R₂) (i : ι) :\n    (e.units_smul w).coord i = «expr • » (w i)⁻¹ (e.coord i) := by\n  classical\n    apply e.ext\n    intro j\n    trans ((e.units_smul w).coord i) («expr • » (w j)⁻¹ ((e.units_smul w) j))\n    · congr\n      simp [Basis.unitsSMul, ← mul_smul]\n    simp only [basis.coord_apply, LinearMap.smul_apply, Basis.repr_self, Units.smul_def, smul_hom_class.map_smul,\n      Finsupp.single_apply]\n    split_ifs with h h\n    · simp [h]\n    · simp\n#align coord_units_smul coord_units_smul\n\n",
 "coord_repr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coord_repr_symm (b : Basis ι R M) (i : ι) (f : «expr →₀ » ι R) : b.coord i (b.repr.symm f) = f i := by\n  simp only [repr_symm_apply, coord_apply, repr_total]\n#align coord_repr_symm coord_repr_symm\n\n",
 "coord_equivFun_symm":
 "#print Basis.coord_equivFun_symm /-\ntheorem Basis.coord_equivFun_symm (i : ι) (f : ι → R) : b.coord i (b.equiv_fun.symm f) = f i :=\n  b.coord_repr_symm i (Finsupp.equivFunOnFinite.symm f)\n#align basis.coord_equiv_fun_symm Basis.coord_equivFun_symm\n-/\n\n",
 "constr_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem constr_self (f : «expr →ₗ[ ] » M R M') : (b.constr S fun i => f (b i)) = f :=\n  b.constr_eq S fun x => rfl\n#align constr_self constr_self\n\n",
 "constr_range":
 "theorem constr_range [Nonempty ι] {f : ι → M'} : (b.constr S f).range = span R (range f) := by\n  rw [b.constr_def S f, LinearMap.range_comp, LinearMap.range_comp, LinearEquiv.range, ← Finsupp.supported_univ,\n    Finsupp.lmapDomain_supported, ← Set.image_univ, ← Finsupp.span_image_eq_map_total, Set.image_id]\n#align constr_range constr_range\n\n",
 "constr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem constr_eq {g : ι → M'} {f : «expr →ₗ[ ] » M R M'} (h : ∀ i, g i = f (b i)) : b.constr S g = f :=\n  b.ext fun i => (b.constr_basis S g i).trans (h i)\n#align constr_eq constr_eq\n\n",
 "constr_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem constr_def (f : ι → M') :\n    b.constr S f = «expr ∘ₗ » (Finsupp.total M' M' R id) («expr ∘ₗ » (Finsupp.lmapDomain R R f) ↑b.repr) :=\n  rfl\n#align constr_def constr_def\n\n",
 "constr_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem constr_comp (f : «expr →ₗ[ ] » M' R M') (v : ι → M') : b.constr S (f ∘ v) = f.comp (b.constr S v) :=\n  b.ext fun i => by simp only [Basis.constr_basis, LinearMap.comp_apply]\n#align constr_comp constr_comp\n\n",
 "constr_basis":
 "@[simp]\ntheorem constr_basis (f : ι → M') (i : ι) : (b.constr S f : M → M') (b i) = f i := by\n  simp [Basis.constr_apply, b.repr_self]\n#align constr_basis constr_basis\n\n",
 "constr_apply_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Basis.constr_apply_fintype /-\n@[simp]\ntheorem Basis.constr_apply_fintype (f : ι → M') (x : M) :\n    (b.constr S f : M → M') x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.equiv_fun x i) (f i)) :=\n  by simp [b.constr_apply, b.equiv_fun_apply, Finsupp.sum_fintype]\n#align basis.constr_apply_fintype Basis.constr_apply_fintype\n-/\n\n",
 "constr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem constr_apply (f : ι → M') (x : M) : b.constr S f x = (b.repr x).sum fun b a => «expr • » a (f b) :=\n  by\n  simp only [constr_def, LinearMap.comp_apply, Finsupp.lmapDomain_apply, Finsupp.total_apply]\n  rw [Finsupp.sum_mapDomain_index] <;> simp [add_smul]\n#align constr_apply constr_apply\n\n",
 "coe_sum_coords_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem coe_sum_coords_of_fintype [Fintype ι] :\n    (b.sum_coords : M → R) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.coord i) :=\n  by\n  ext m\n  simp only [sum_coords, Finsupp.sum_fintype, LinearMap.id_coe, LinearEquiv.coe_coe, coord_apply, id.def,\n    Fintype.sum_apply, imp_true_iff, eq_self_iff_true, Finsupp.coe_lsum, LinearMap.coe_comp]\n#align coe_sum_coords_of_fintype coe_sum_coords_of_fintype\n\n",
 "coe_sum_coords_eq_finsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\ntheorem coe_sum_coords_eq_finsum :\n    (b.sum_coords : M → R) = fun m =>\n      finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" (b.coord i m) :=\n  by\n  ext m\n  simp only [Basis.sumCoords, Basis.coord, Finsupp.lapply_apply, LinearMap.id_coe, LinearEquiv.coe_coe,\n    Function.comp_apply, Finsupp.coe_lsum, LinearMap.coe_comp, finsum_eq_sum _ (b.repr m).finite_support, Finsupp.sum,\n    Finset.finite_toSet_toFinset, id.def, Finsupp.fun_support_eq]\n#align coe_sum_coords_eq_finsum coe_sum_coords_eq_finsum\n\n",
 "coe_sum_coords":
 "@[simp]\ntheorem coe_sum_coords : (b.sum_coords : M → R) = fun m => (b.repr m).sum fun i => id :=\n  rfl\n#align coe_sum_coords coe_sum_coords\n\n",
 "coe_repr_symm":
 "@[simp]\ntheorem coe_repr_symm : ↑b.repr.symm = Finsupp.total ι M R b :=\n  LinearMap.ext fun v => b.repr_symm_apply v\n#align coe_repr_symm coe_repr_symm\n\n",
 "coe_reindex":
 "@[simp]\ntheorem coe_reindex : (b.reindex e : ι' → M) = b ∘ e.symm :=\n  funext (b.reindex_apply e)\n#align coe_reindex coe_reindex\n\n",
 "coe_of_vector_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_of_vector_space : «expr⇑ » (ofVectorSpace K V) = coe :=\n  funext fun x => ofVectorSpace_apply_self K V x\n#align coe_of_vector_space coe_of_vector_space\n\n",
 "coe_of_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_of_repr (e : «expr ≃ₗ[ ] » M R («expr →₀ » ι R)) :\n    «expr⇑ » (ofRepr e) = fun i => e.symm (Finsupp.single i 1) :=\n  rfl\n#align coe_of_repr coe_of_repr\n\n",
 "coe_ofEquivFun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Basis.coe_ofEquivFun /-\n@[simp]\ntheorem Basis.coe_ofEquivFun [DecidableEq ι] (e : «expr ≃ₗ[ ] » M R (ι → R)) :\n    (Basis.ofEquivFun e : ι → M) = fun i => e.symm (Function.update 0 i 1) :=\n  funext fun i =>\n    e.injective <| funext fun j => by simp [Basis.ofEquivFun, ← Finsupp.single_eq_pi_single, Finsupp.single_eq_update]\n#align basis.coe_of_equiv_fun Basis.coe_ofEquivFun\n-/\n\n",
 "coe_mk_fin_cons_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_mk_fin_cons_of_le {n : ℕ} {N O : Submodule R M} (y : M) (yO : y ∈ O) (b : Basis (Fin n) R N) (hNO : N ≤ O)\n    (hli : ∀ (c : R), ∀ x ∈ N, «expr • » c y + x = 0 → c = 0) (hsp : ∀ z ∈ O, ∃ c : R, z + «expr • » c y ∈ N) :\n    (mkFinConsOfLe y yO b hNO hli hsp : Fin (n + 1) → O) = Fin.cons ⟨y, yO⟩ (Submodule.ofLe hNO ∘ b) :=\n  coe_mkFinCons _ _ _ _\n#align coe_mk_fin_cons_of_le coe_mk_fin_cons_of_le\n\n",
 "coe_mk_fin_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_mk_fin_cons {n : ℕ} {N : Submodule R M} (y : M) (b : Basis (Fin n) R N)\n    (hli : ∀ (c : R), ∀ x ∈ N, «expr • » c y + x = 0 → c = 0) (hsp : ∀ z : M, ∃ c : R, z + «expr • » c y ∈ N) :\n    (mkFinCons y b hli hsp : Fin (n + 1) → M) = Fin.cons y (coe ∘ b) :=\n  coe_mk _ _\n#align coe_mk_fin_cons coe_mk_fin_cons\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk : «expr⇑ » (Basis.mk hli hsp) = v :=\n  funext (mk_apply _ _)\n#align coe_mk coe_mk\n\n",
 "coe_map_coeffs":
 "@[simp]\ntheorem coe_map_coeffs : (b.map_coeffs f h : ι → M) = b :=\n  funext <| b.map_coeffs_apply f h\n#align coe_map_coeffs coe_map_coeffs\n\n",
 "coe_fin_two_prod_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem coe_fin_two_prod_repr {R : Type _} [Semiring R] (x : R × R) :\n    «expr⇑ » ((Basis.finTwoProd R).repr x) =\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\" :=\n  rfl\n#align coe_fin_two_prod_repr coe_fin_two_prod_repr\n\n",
 "coe_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_extend (hs : LinearIndependent K (coe : s → V)) : «expr⇑ » (Basis.extend hs) = coe :=\n  funext (extend_apply_self hs)\n#align coe_extend coe_extend\n\n",
 "card_fintype":
 "#print VectorSpace.card_fintype /-\ntheorem VectorSpace.card_fintype [Fintype K] [Fintype V] : ∃ n : ℕ, card V = card K ^ n := by\n  classical exact ⟨card (Basis.ofVectorSpaceIndex K V), Module.card_fintype (Basis.ofVectorSpace K V)⟩\n#align vector_space.card_fintype VectorSpace.card_fintype\n-/\n\n",
 "basis_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem basis_singleton_iff {R M : Type _} [Ring R] [Nontrivial R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] (ι : Type _) [Unique ι] :\n    Nonempty (Basis ι R M) ↔ ∃ (x : _)(_ : x ≠ 0), ∀ y : M, ∃ r : R, «expr • » r x = y :=\n  by\n  fconstructor\n  · rintro ⟨b⟩\n    refine' ⟨b default, b.linear_independent.ne_zero _, _⟩\n    simpa [span_singleton_eq_top_iff, Set.range_unique] using b.span_eq\n  · rintro ⟨x, nz, w⟩\n    refine'\n      ⟨of_repr <|\n          LinearEquiv.symm\n            { to_fun := fun f => «expr • » (f default) x\n              inv_fun := fun y => Finsupp.single default (w y).some\n              left_inv := fun f => Finsupp.unique_ext _\n              right_inv := fun y => _\n              map_add' := fun y z => _\n              map_smul' := fun c y => _ }⟩\n    · rw [Finsupp.add_apply, add_smul]\n    · rw [Finsupp.smul_apply, smul_assoc]\n      simp\n    · refine' smul_left_injective _ nz _\n      simp only [Finsupp.single_eq_same]\n      exact (w («expr • » (f default) x)).some_spec\n    · simp only [Finsupp.single_eq_same]\n      exact (w y).some_spec\n#align basis_singleton_iff basis_singleton_iff\n\n",
 "atom_iff_nonzero_span":
 "#print atom_iff_nonzero_span /-\n/-- The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. -/\ntheorem atom_iff_nonzero_span (W : Submodule K V) : IsAtom W ↔ ∃ (v : V)(hv : v ≠ 0), W = span K {v} :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · cases' h with hbot h\n    rcases(Submodule.ne_bot_iff W).1 hbot with ⟨v, ⟨hW, hv⟩⟩\n    refine' ⟨v, ⟨hv, _⟩⟩\n    by_contra heq\n    specialize h (span K {v})\n    rw [span_singleton_eq_bot, lt_iff_le_and_ne] at h\n    exact hv (h ⟨(span_singleton_le_iff_mem v W).2 hW, ne.symm HEq⟩)\n  · rcases h with ⟨v, ⟨hv, rfl⟩⟩\n    exact nonzero_span_atom v hv\n#align atom_iff_nonzero_span atom_iff_nonzero_span\n-/\n\n",
 "apply_eq_iff":
 "theorem apply_eq_iff {b : Basis ι R M} {x : M} {i : ι} : b i = x ↔ b.repr x = Finsupp.single i 1 :=\n  ⟨fun h => h ▸ b.repr_self i, fun h => b.repr.injective ((b.repr_self i).trans h.symm)⟩\n#align apply_eq_iff apply_eq_iff\n\n",
 "NoZeroSMulDivisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print NoZeroSMulDivisors /-\n-- Can't be an instance because the basis can't be inferred.\nprotected theorem NoZeroSMulDivisors [NoZeroDivisors R] (b : Basis ι R M) : NoZeroSMulDivisors R M :=\n  ⟨fun c x hcx =>\n    or_iff_not_imp_right.mpr fun hx =>\n      by\n      rw [← b.total_repr x, ← LinearMap.map_smul] at hcx\n      have := linear_independent_iff.mp b.linear_independent («expr • » c (b.repr x)) hcx\n      rw [smul_eq_zero] at this\n      exact this.resolve_right fun hr => hx (b.repr.map_eq_zero_iff.mp hr)⟩\n#align no_zero_smul_divisors NoZeroSMulDivisors\n-/\n\n",
 "NeZero":
 "#print NeZero /-\nprotected theorem NeZero [Nontrivial R] (i) : b i ≠ 0 :=\n  b.linear_independent.ne_zero i\n#align ne_zero NeZero\n-/\n\n",
 "LinearIndependent":
 "#print LinearIndependent /-\nprotected theorem LinearIndependent : LinearIndependent R b :=\n  linearIndependent_iff.mpr fun l hl =>\n    calc\n      l = b.repr (Finsupp.total _ _ _ b l) := (b.repr_total l).symm\n      _ = 0 := by rw [hl, LinearEquiv.map_zero]\n      \n#align linear_independent LinearIndependent\n-/\n\n"}