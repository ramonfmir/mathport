{"units_smul_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem units_smul_span_eq_top {v : ι → M} (hv : submodule.span R (Set.range v) = «expr⊤») {w : ι → «expr ˣ» R} :\n    submodule.span R (Set.range («expr • » w v)) = «expr⊤» :=\n  group_smul_span_eq_top hv\n#align units_smul_span_eq_top units_smul_span_eq_top\n\n",
 "units_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem units_smul_apply {v : basis ι R M} {w : ι → «expr ˣ» R} (i : ι) : v.units_smul w i = «expr • » (w i) (v i) :=\n  mk_apply (v.linear_independent.units_smul w) (units_smul_span_eq_top v.span_eq).ge i\n#align units_smul_apply units_smul_apply\n\n",
 "total_repr":
 "@[simp]\ntheorem total_repr : finsupp.total _ _ _ b (b.repr x) = x :=\n  by\n  rw [← b.coe_repr_symm]\n  exact b.repr.symm_apply_apply x\n#align total_repr total_repr\n\n",
 "sum_repr_mul_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem sum_repr_mul_repr {ι'} [fintype ι'] (b' : basis ι' R M) (x : M) (i : ι) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.repr (b' j) i * b'.repr x j) =\n      b.repr x i :=\n  by\n  conv_rhs => rw [← b'.sum_repr x]\n  simp_rw [linear_equiv.map_sum, linear_equiv.map_smul, finset.sum_apply']\n  refine' finset.sum_congr rfl fun j _ => _\n  rw [finsupp.smul_apply, smul_eq_mul, mul_comm]\n#align sum_repr_mul_repr sum_repr_mul_repr\n\n",
 "sum_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem basis.sum_repr (u : M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.repr u i) (b i)) =\n      u :=\n  b.sum_equiv_fun u\n#align basis.sum_repr basis.sum_repr\n\n",
 "sum_equiv_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem basis.sum_equiv_fun (u : M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.equiv_fun u i) (b i)) =\n      u :=\n  by\n  conv_rhs => rw [← b.total_repr u]\n  simp [finsupp.total_apply, finsupp.sum_fintype, b.equiv_fun_apply]\n#align basis.sum_equiv_fun basis.sum_equiv_fun\n\n",
 "sum_coords_self_apply":
 "@[simp]\ntheorem sum_coords_self_apply : b.sum_coords (b i) = 1 := by\n  simp only [basis.sum_coords, linear_map.id_coe, linear_equiv.coe_coe, id.def, basis.repr_self, Function.comp_apply,\n    finsupp.coe_lsum, linear_map.coe_comp, finsupp.sum_single_index]\n#align sum_coords_self_apply sum_coords_self_apply\n\n",
 "subset_extend":
 "theorem subset_extend {s : set V} (hs : linear_independent K (coe : s → V)) : s ⊆ hs.extend (Set.subset_univ _) :=\n  hs.subset_extend _\n#align subset_extend subset_extend\n\n",
 "span_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\nprotected theorem span_eq : span R (range b) = «expr⊤» :=\n  eq_top_iff.mpr fun x _ => b.mem_span x\n#align span_eq span_eq\n\n",
 "span_apply":
 "protected theorem span_apply (i : ι) : (basis.span hli i : M) = v i :=\n  congr_arg (coe : span R (range v) → M) <| basis.mk_apply (linear_independent_span hli) _ i\n#align span_apply span_apply\n\n",
 "smul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_eq_zero /-\nprotected theorem smul_eq_zero [no_zero_divisors R] (b : basis ι R M) {c : R} {x : M} :\n    «expr • » c x = 0 ↔ c = 0 ∨ x = 0 :=\n  @smul_eq_zero _ _ _ _ _ b.no_zero_smul_divisors _ _\n#align smul_eq_zero smul_eq_zero\n-/\n\n",
 "singleton_repr":
 "@[simp]\ntheorem singleton_repr (ι R : Type _) [unique ι] [Semiring R] (x i) : (basis.singleton ι R).repr x i = x := by\n  simp [basis.singleton, unique.eq_default i]\n#align singleton_repr singleton_repr\n\n",
 "singleton_apply":
 "@[simp]\ntheorem singleton_apply (ι R : Type _) [unique ι] [Semiring R] (i) : basis.singleton ι R i = 1 :=\n  apply_eq_iff.mpr (by simp [basis.singleton])\n#align singleton_apply singleton_apply\n\n",
 "repr_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem repr_units_smul (e : basis ι R₂ M) (w : ι → «expr ˣ» R₂) (v : M) (i : ι) :\n    (e.units_smul w).repr v i = «expr • » (w i)⁻¹ (e.repr v i) :=\n  congr_arg (fun f : «expr →ₗ[ ] » M R₂ R₂ => f v) (e.coord_units_smul w i)\n#align repr_units_smul repr_units_smul\n\n",
 "repr_total":
 "@[simp]\ntheorem repr_total (v) : b.repr (finsupp.total _ _ _ b v) = v :=\n  by\n  rw [← b.coe_repr_symm]\n  exact b.repr.apply_symm_apply v\n#align repr_total repr_total\n\n",
 "repr_symm_single_one":
 "theorem repr_symm_single_one : b.repr.symm (finsupp.single i 1) = b i :=\n  rfl\n#align repr_symm_single_one repr_symm_single_one\n\n",
 "repr_symm_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem repr_symm_single : b.repr.symm (finsupp.single i c) = «expr • » c (b i) :=\n  calc\n    b.repr.symm (finsupp.single i c) = b.repr.symm («expr • » c (finsupp.single i 1)) := by\n      rw [finsupp.smul_single', mul_one]\n    _ = «expr • » c (b i) := by rw [linear_equiv.map_smul, repr_symm_single_one]\n    \n#align repr_symm_single repr_symm_single\n\n",
 "repr_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem repr_symm_apply (v) : b.repr.symm v = finsupp.total ι M R b v :=\n  calc\n    b.repr.symm v = b.repr.symm (v.sum finsupp.single) := by simp\n    _ =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" v.support\n          (b.repr.symm (finsupp.single i (v i))) :=\n      by rw [finsupp.sum, linear_equiv.map_sum]\n    _ = finsupp.total ι M R b v := by simp [repr_symm_single, finsupp.total_apply, finsupp.sum]\n    \n#align repr_symm_apply repr_symm_apply\n\n",
 "repr_support_subset_of_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem repr_support_subset_of_mem_span {ι : Type _} (b : basis ι R M) (s : set ι) {m : M}\n    (hm : m ∈ span R («expr '' » b s)) : ↑(b.repr m).support ⊆ s :=\n  by\n  rcases(finsupp.mem_span_image_iff_total _).1 hm with ⟨l, hl, hlm⟩\n  rwa [← hlm, repr_total, ← finsupp.mem_supported R l]\n#align repr_support_subset_of_mem_span repr_support_subset_of_mem_span\n\n",
 "repr_sum_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem basis.repr_sum_self (c : ι → R) :\n    «expr⇑ »\n        (b.repr\n          (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (b i)))) =\n      c :=\n  by\n  ext j\n  simp only [map_sum, linear_equiv.map_smul, repr_self, finsupp.smul_single, smul_eq_mul, mul_one, finset.sum_apply']\n  rw [finset.sum_eq_single j, finsupp.single_eq_same]\n  · rintro i - hi\n    exact finsupp.single_eq_of_ne hi\n  · intros\n    have := finset.mem_univ j\n    contradiction\n#align basis.repr_sum_self basis.repr_sum_self\n\n",
 "repr_self_apply":
 "theorem repr_self_apply (j) [decidable (i = j)] : b.repr (b i) j = if i = j then 1 else 0 := by\n  rw [repr_self, finsupp.single_apply]\n#align repr_self_apply repr_self_apply\n\n",
 "repr_self":
 "@[simp]\ntheorem repr_self : b.repr (b i) = finsupp.single i 1 :=\n  linear_equiv.apply_symm_apply _ _\n#align repr_self repr_self\n\n",
 "repr_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem repr_range : (b.repr : «expr →ₗ[ ] » M R («expr →₀ » ι R)).range = finsupp.supported R R univ := by\n  rw [linear_equiv.range, finsupp.supported_univ]\n#align repr_range repr_range\n\n",
 "repr_eq_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem repr_eq_iff' {b : basis ι R M} {f : «expr ≃ₗ[ ] » M R («expr →₀ » ι R)} :\n    b.repr = f ↔ ∀ i, f (b i) = finsupp.single i 1 :=\n  ⟨fun h i => h ▸ b.repr_self i, fun h => b.ext' fun i => (b.repr_self i).trans (h i).symm⟩\n#align repr_eq_iff' repr_eq_iff'\n\n",
 "repr_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem repr_eq_iff {b : basis ι R M} {f : «expr →ₗ[ ] » M R («expr →₀ » ι R)} :\n    ↑b.repr = f ↔ ∀ i, f (b i) = finsupp.single i 1 :=\n  ⟨fun h i => h ▸ b.repr_self i, fun h => b.ext fun i => (b.repr_self i).trans (h i).symm⟩\n#align repr_eq_iff repr_eq_iff\n\n",
 "repr_apply_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An unbundled version of `repr_eq_iff` -/\ntheorem repr_apply_eq (f : M → ι → R) (hadd : ∀ x y, f (x + y) = f x + f y)\n    (hsmul : ∀ (c : R) (x : M), f («expr • » c x) = «expr • » c (f x)) (f_eq : ∀ i, f (b i) = finsupp.single i 1)\n    (x : M) (i : ι) : b.repr x i = f x i :=\n  by\n  let f_i : «expr →ₗ[ ] » M R R :=\n    { to_fun := fun x => f x i\n      map_add' := fun _ _ => by rw [hadd, pi.add_apply]\n      map_smul' := fun _ _ => by simp [hsmul, pi.smul_apply] }\n  have : «expr ∘ₗ » (finsupp.lapply i) ↑b.repr = f_i :=\n    by\n    refine' b.ext fun j => _\n    show b.repr (b j) i = f (b j) i\n    rw [b.repr_self, f_eq]\n  calc\n    b.repr x i = f_i x := by\n      rw [← this]\n      rfl\n    _ = f x i := rfl\n    \n#align repr_apply_eq repr_apply_eq\n\n",
 "reindex_repr":
 "@[simp]\ntheorem reindex_repr (i' : ι') : (b.reindex e).repr x i' = b.repr x (e.symm i') := by rw [coe_reindex_repr]\n#align reindex_repr reindex_repr\n\n",
 "reindex_refl":
 "@[simp]\ntheorem reindex_refl : b.reindex (equiv.refl ι) = b :=\n  eq_of_apply_eq fun i => by simp\n#align reindex_refl reindex_refl\n\n",
 "reindex_range_self":
 "theorem reindex_range_self (i : ι) (h := Set.mem_range_self i) : b.reindex_range ⟨b i, h⟩ = b i :=\n  by\n  by_cases htr : nontrivial R\n  · letI := htr\n    simp [htr, reindex_range, reindex_apply, Equiv.apply_ofInjective_symm b.injective, subtype.coe_mk]\n  · letI : subsingleton R := not_nontrivial_iff_subsingleton.mp htr\n    letI := Module.subsingleton R M\n    simp [reindex_range]\n#align reindex_range_self reindex_range_self\n\n",
 "reindex_range_repr_self":
 "theorem reindex_range_repr_self (i : ι) : b.reindex_range.repr (b i) = finsupp.single ⟨b i, mem_range_self i⟩ 1 :=\n  calc\n    b.reindex_range.repr (b i) = b.reindex_range.repr (b.reindex_range ⟨b i, mem_range_self i⟩) :=\n      congr_arg _ (b.reindex_range_self _ _).symm\n    _ = finsupp.single ⟨b i, mem_range_self i⟩ 1 := b.reindex_range.repr_self _\n    \n#align reindex_range_repr_self reindex_range_repr_self\n\n",
 "reindex_range_repr'":
 "theorem reindex_range_repr' (x : M) {bi : M} {i : ι} (h : b i = bi) :\n    b.reindex_range.repr x ⟨bi, ⟨i, h⟩⟩ = b.repr x i :=\n  by\n  nontriviality\n  subst h\n  refine' (b.repr_apply_eq (fun x i => b.reindex_range.repr x ⟨b i, _⟩) _ _ _ x i).symm\n  · intro x y\n    ext i\n    simp only [pi.add_apply, linear_equiv.map_add, finsupp.coe_add]\n  · intro c x\n    ext i\n    simp only [pi.smul_apply, linear_equiv.map_smul, finsupp.coe_smul]\n  · intro i\n    ext j\n    simp only [reindex_range_repr_self]\n    refine' @finsupp.single_apply_left _ _ _ _ (fun i => (⟨b i, _⟩ : Set.range b)) _ _ _ _\n    exact fun i j h => b.injective (subtype.mk.inj h)\n#align reindex_range_repr' reindex_range_repr'\n\n",
 "reindex_range_repr":
 "@[simp]\ntheorem reindex_range_repr (x : M) (i : ι) (h := Set.mem_range_self i) : b.reindex_range.repr x ⟨b i, h⟩ = b.repr x i :=\n  b.reindex_range_repr' _ rfl\n#align reindex_range_repr reindex_range_repr\n\n",
 "reindex_range_apply":
 "@[simp]\ntheorem reindex_range_apply (x : range b) : b.reindex_range x = x :=\n  by\n  rcases x with ⟨bi, ⟨i, rfl⟩⟩\n  exact b.reindex_range_self i\n#align reindex_range_apply reindex_range_apply\n\n",
 "reindex_finset_range_self":
 "theorem reindex_finset_range_self (i : ι) (h := Finset.mem_image_of_mem b (finset.mem_univ i)) :\n    b.reindex_finset_range ⟨b i, h⟩ = b i :=\n  by\n  rw [reindex_finset_range, reindex_apply, reindex_range_apply]\n  rfl\n#align reindex_finset_range_self reindex_finset_range_self\n\n",
 "reindex_finset_range_repr_self":
 "theorem reindex_finset_range_repr_self (i : ι) :\n    b.reindex_finset_range.repr (b i) = finsupp.single ⟨b i, Finset.mem_image_of_mem b (finset.mem_univ i)⟩ 1 :=\n  by\n  ext ⟨bi, hbi⟩\n  rw [reindex_finset_range, reindex_repr, reindex_range_repr_self]\n  convert finsupp.single_apply_left ((equiv.refl M).subtype_equiv _).symm.injective _ _ _\n  rfl\n#align reindex_finset_range_repr_self reindex_finset_range_repr_self\n\n",
 "reindex_finset_range_repr":
 "@[simp]\ntheorem reindex_finset_range_repr (x : M) (i : ι) (h := Finset.mem_image_of_mem b (finset.mem_univ i)) :\n    b.reindex_finset_range.repr x ⟨b i, h⟩ = b.repr x i := by simp [reindex_finset_range]\n#align reindex_finset_range_repr reindex_finset_range_repr\n\n",
 "reindex_finset_range_apply":
 "@[simp]\ntheorem reindex_finset_range_apply (x : finset.univ.image b) : b.reindex_finset_range x = x :=\n  by\n  rcases x with ⟨bi, hbi⟩\n  rcases finset.mem_image.mp hbi with ⟨i, -, rfl⟩\n  exact b.reindex_finset_range_self i\n#align reindex_finset_range_apply reindex_finset_range_apply\n\n",
 "reindex_apply":
 "theorem reindex_apply (i' : ι') : b.reindex e i' = b (e.symm i') :=\n  show (b.repr.trans (finsupp.dom_lcongr e)).symm (finsupp.single i' 1) = b.repr.symm (finsupp.single (e.symm i') 1) by\n    rw [linear_equiv.symm_trans_apply, finsupp.dom_lcongr_symm, finsupp.dom_lcongr_single]\n#align reindex_apply reindex_apply\n\n",
 "range_reindex'":
 "/-- `simp` normal form version of `range_reindex` -/\n@[simp]\ntheorem range_reindex' : Set.range (b ∘ e.symm) = Set.range b := by rw [range_comp, Equiv.range_eq_univ, Set.image_univ]\n#align range_reindex' range_reindex'\n\n",
 "range_reindex":
 "theorem range_reindex : Set.range (b.reindex e) = Set.range b := by rw [coe_reindex, range_reindex']\n#align range_reindex range_reindex\n\n",
 "range_of_vector_space":
 "theorem range_of_vector_space : range (of_vector_space K V) = of_vector_space_index K V :=\n  range_extend _\n#align range_of_vector_space range_of_vector_space\n\n",
 "range_extend":
 "theorem range_extend (hs : linear_independent K (coe : s → V)) : range (basis.extend hs) = hs.extend (subset_univ _) :=\n  by rw [coe_extend, Subtype.range_coe_subtype, set_of_mem_eq]\n#align range_extend range_extend\n\n",
 "quotient_prod_linear_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem quotient_prod_linear_equiv (p : submodule K V) : nonempty («expr ≃ₗ[ ] » («expr ⧸ » V p × p) K V) :=\n  let ⟨q, hq⟩ := p.exists_is_compl\n  nonempty.intro <|\n    ((quotient_equiv_of_is_compl p q hq).prod (linear_equiv.refl _ _)).trans (prod_equiv_of_is_compl q p hq.symm)\n#align quotient_prod_linear_equiv quotient_prod_linear_equiv\n\n",
 "prod_repr_inr":
 "@[simp]\ntheorem prod_repr_inr (x) (i) : (b.prod b').repr x (sum.inr i) = b'.repr x.2 i :=\n  rfl\n#align prod_repr_inr prod_repr_inr\n\n",
 "prod_repr_inl":
 "@[simp]\ntheorem prod_repr_inl (x) (i) : (b.prod b').repr x (sum.inl i) = b.repr x.1 i :=\n  rfl\n#align prod_repr_inl prod_repr_inl\n\n",
 "prod_apply_inr_snd":
 "theorem prod_apply_inr_snd (i) : (b.prod b' (sum.inr i)).2 = b' i :=\n  b'.repr.injective <| by\n    ext i\n    simp only [basis.prod, basis.coe_of_repr, linear_equiv.symm_trans_apply, linear_equiv.prod_symm,\n      linear_equiv.prod_apply, b'.repr.apply_symm_apply, linear_equiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      finsupp.snd_sum_finsupp_lequiv_prod_finsupp]\n    apply finsupp.single_apply_left sum.inr_injective\n#align prod_apply_inr_snd prod_apply_inr_snd\n\n",
 "prod_apply_inr_fst":
 "theorem prod_apply_inr_fst (i) : (b.prod b' (sum.inr i)).1 = 0 :=\n  b.repr.injective <| by\n    ext i\n    simp only [basis.prod, basis.coe_of_repr, linear_equiv.symm_trans_apply, linear_equiv.prod_symm,\n      linear_equiv.prod_apply, b.repr.apply_symm_apply, linear_equiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      finsupp.fst_sum_finsupp_lequiv_prod_finsupp, linear_equiv.map_zero, finsupp.zero_apply]\n    apply finsupp.single_eq_of_ne sum.inr_ne_inl\n#align prod_apply_inr_fst prod_apply_inr_fst\n\n",
 "prod_apply_inl_snd":
 "theorem prod_apply_inl_snd (i) : (b.prod b' (sum.inl i)).2 = 0 :=\n  b'.repr.injective <| by\n    ext j\n    simp only [basis.prod, basis.coe_of_repr, linear_equiv.symm_trans_apply, linear_equiv.prod_symm,\n      linear_equiv.prod_apply, b'.repr.apply_symm_apply, linear_equiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      finsupp.snd_sum_finsupp_lequiv_prod_finsupp, linear_equiv.map_zero, finsupp.zero_apply]\n    apply finsupp.single_eq_of_ne sum.inl_ne_inr\n#align prod_apply_inl_snd prod_apply_inl_snd\n\n",
 "prod_apply_inl_fst":
 "theorem prod_apply_inl_fst (i) : (b.prod b' (sum.inl i)).1 = b i :=\n  b.repr.injective <| by\n    ext j\n    simp only [basis.prod, basis.coe_of_repr, linear_equiv.symm_trans_apply, linear_equiv.prod_symm,\n      linear_equiv.prod_apply, b.repr.apply_symm_apply, linear_equiv.symm_symm, repr_self, Equiv.toFun_as_coe,\n      finsupp.fst_sum_finsupp_lequiv_prod_finsupp]\n    apply finsupp.single_apply_left sum.inl_injective\n#align prod_apply_inl_fst prod_apply_inl_fst\n\n",
 "prod_apply":
 "@[simp]\ntheorem prod_apply (i) : b.prod b' i = sum.elim (linear_map.inl R M M' ∘ b) (linear_map.inr R M M' ∘ b') i := by\n  ext <;> cases i <;>\n    simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr,\n      linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]\n#align prod_apply prod_apply\n\n",
 "of_vector_space_apply_self":
 "theorem of_vector_space_apply_self (x : of_vector_space_index K V) : of_vector_space K V x = x :=\n  basis.mk_apply _ _ _\n#align of_vector_space_apply_self of_vector_space_apply_self\n\n",
 "of_equiv_fun_repr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem basis.of_equiv_fun_repr_apply (e : «expr ≃ₗ[ ] » M R (ι → R)) (x : M) (i : ι) :\n    (basis.of_equiv_fun e).repr x i = e x i :=\n  rfl\n#align basis.of_equiv_fun_repr_apply basis.of_equiv_fun_repr_apply\n\n",
 "of_equiv_fun_equiv_fun":
 "@[simp]\ntheorem basis.of_equiv_fun_equiv_fun (v : basis ι R M) : basis.of_equiv_fun v.equiv_fun = v :=\n  by\n  ext j\n  simp only [basis.equiv_fun_symm_apply, basis.coe_of_equiv_fun]\n  simp_rw [function.update_apply, ite_smul]\n  simp only [finset.mem_univ, if_true, pi.zero_apply, one_smul, finset.sum_ite_eq', zero_smul]\n#align basis.of_equiv_fun_equiv_fun basis.of_equiv_fun_equiv_fun\n\n",
 "nonzero_span_atom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- For a module over a division ring, the span of a nonzero element is an atom of the\nlattice of submodules. -/\ntheorem nonzero_span_atom (v : V) (hv : v ≠ 0) : IsAtom (span K {v} : submodule K V) :=\n  by\n  constructor\n  · rw [submodule.ne_bot_iff]\n    exact ⟨v, ⟨mem_span_singleton_self v, hv⟩⟩\n  · intro T hT\n    by_contra\n    apply hT.2\n    change span K {v} ≤ T\n    simp_rw [span_singleton_le_iff_mem, ← ne.def, submodule.ne_bot_iff] at *\n    rcases h with ⟨s, ⟨hs, hz⟩⟩\n    cases' mem_span_singleton.1 (hT.1 hs) with a ha\n    have h : a ≠ 0 := by\n      intro h\n      rw [h, zero_smul] at ha\n      exact hz ha.symm\n    apply_fun fun x => «expr • » a⁻¹ x  at ha\n    simp_rw [← mul_smul, inv_mul_cancel h, one_smul, ha] at *\n    exact smul_mem T _ hs\n#align nonzero_span_atom nonzero_span_atom\n\n",
 "ne_zero":
 "protected theorem ne_zero [nontrivial R] (i) : b i ≠ 0 :=\n  b.linear_independent.ne_zero i\n#align ne_zero ne_zero\n\n",
 "mk_repr":
 "@[simp]\ntheorem mk_repr : (basis.mk hli hsp).repr x = hli.repr ⟨x, hsp submodule.mem_top⟩ :=\n  rfl\n#align mk_repr mk_repr\n\n",
 "mk_coord_apply_ne":
 "/-- Given a basis, the `i`th element of the dual basis evaluates to 0 on the `j`th element of the\nbasis if `j ≠ i`. -/\ntheorem mk_coord_apply_ne {i j : ι} (h : j ≠ i) : (basis.mk hli hsp).coord i (v j) = 0 :=\n  show hli.repr ⟨v j, submodule.subset_span (mem_range_self j)⟩ i = 0 by simp [hli.repr_eq_single j, h]\n#align mk_coord_apply_ne mk_coord_apply_ne\n\n",
 "mk_coord_apply_eq":
 "/-- Given a basis, the `i`th element of the dual basis evaluates to 1 on the `i`th element of the\nbasis. -/\ntheorem mk_coord_apply_eq (i : ι) : (basis.mk hli hsp).coord i (v i) = 1 :=\n  show hli.repr ⟨v i, submodule.subset_span (mem_range_self i)⟩ i = 1 by simp [hli.repr_eq_single i]\n#align mk_coord_apply_eq mk_coord_apply_eq\n\n",
 "mk_coord_apply":
 "/-- Given a basis, the `i`th element of the dual basis evaluates to the Kronecker delta on the\n`j`th element of the basis. -/\ntheorem mk_coord_apply {i j : ι} : (basis.mk hli hsp).coord i (v j) = if j = i then 1 else 0 :=\n  by\n  cases eq_or_ne j i\n  · simp only [h, if_true, eq_self_iff_true, mk_coord_apply_eq i]\n  · simp only [h, if_false, mk_coord_apply_ne h]\n#align mk_coord_apply mk_coord_apply\n\n",
 "mk_apply":
 "theorem mk_apply (i : ι) : basis.mk hli hsp i = v i :=\n  show finsupp.total _ _ _ v _ = v i by simp\n#align mk_apply mk_apply\n\n",
 "mem_submodule_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If the submodule `P` has a finite basis,\n`x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem basis.mem_submodule_iff' {P : submodule R M} (b : basis ι R P) {x : M} :\n    x ∈ P ↔\n      ∃ c : ι → R,\n        x =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (b i)) :=\n  b.mem_submodule_iff.trans <|\n    finsupp.equiv_fun_on_finite.exists_congr_left.trans <| exists_congr fun c => by simp [finsupp.sum_fintype]\n#align basis.mem_submodule_iff' basis.mem_submodule_iff'\n\n",
 "mem_submodule_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If the submodule `P` has a basis, `x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem mem_submodule_iff {P : submodule R M} (b : basis ι R P) {x : M} :\n    x ∈ P ↔ ∃ c : «expr →₀ » ι R, x = finsupp.sum c fun i x => «expr • » x (b i) :=\n  by\n  conv_lhs =>\n    rw [← P.range_subtype, ← submodule.map_top, ← b.span_eq, submodule.map_span, ← Set.range_comp, ←\n      finsupp.range_total]\n  simpa only [@eq_comm _ x]\n#align mem_submodule_iff mem_submodule_iff\n\n",
 "mem_span_repr_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_span_repr_support {ι : Type _} (b : basis ι R M) (m : M) : m ∈ span R («expr '' » b (b.repr m).support) :=\n  (finsupp.mem_span_image_iff_total _).2 ⟨b.repr m, by simp [finsupp.mem_supported_support]⟩\n#align mem_span_repr_support mem_span_repr_support\n\n",
 "mem_span":
 "protected theorem mem_span (x : M) : x ∈ span R (range b) :=\n  by\n  rw [← b.total_repr x, finsupp.total_apply, finsupp.sum]\n  exact submodule.sum_mem _ fun i hi => submodule.smul_mem _ _ (submodule.subset_span ⟨i, rfl⟩)\n#align mem_span mem_span\n\n",
 "maximal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Any basis is a maximal linear independent set.\n-/\ntheorem maximal [nontrivial R] (b : basis ι R M) : b.linear_independent.maximal := fun w hi h =>\n  by\n  -- If `range w` is strictly bigger than `range b`,\n  apply le_antisymm h\n  -- then choose some `x ∈ range w \\ range b`,\n  intro x p\n  by_contra q\n  -- and write it in terms of the basis.\n  have e := b.total_repr x\n  -- This then expresses `x` as a linear combination\n  -- of elements of `w` which are in the range of `b`,\n  let u : «expr ↪ » ι w :=\n    ⟨fun i => ⟨b i, h ⟨i, rfl⟩⟩, fun i i' r => b.injective (by simpa only [subtype.mk_eq_mk] using r)⟩\n  have r : ∀ i, b i = u i := fun i => rfl\n  simp_rw [finsupp.total_apply, r] at e\n  change\n    ((b.repr x).sum fun (i : ι) (a : R) => (fun (x : w) (r : R) => «expr • » r (x : M)) (u i) a) = ((⟨x, p⟩ : w) : M) at\n    e\n  rw [← finsupp.sum_emb_domain, ← finsupp.total_apply] at e\n  -- Now we can contradict the linear independence of `hi`\n  refine' hi.total_ne_of_not_mem_support _ _ e\n  simp only [Finset.mem_map, finsupp.support_emb_domain]\n  rintro ⟨j, -, W⟩\n  simp only [embedding.coe_fn_mk, subtype.mk_eq_mk, ← r] at W\n  apply q ⟨j, W⟩\n#align maximal maximal\n\n",
 "map_equiv_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem basis.map_equiv_fun (f : «expr ≃ₗ[ ] » M R M') : (b.map f).equiv_fun = f.symm.trans b.equiv_fun :=\n  rfl\n#align basis.map_equiv_fun basis.map_equiv_fun\n\n",
 "map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem map_equiv (b : basis ι R M) (b' : basis ι' R M') (e : «expr ≃ » ι ι') :\n    b.map (b.equiv b' e) = b'.reindex e.symm := by\n  ext i\n  simp\n#align map_equiv map_equiv\n\n",
 "map_coeffs_apply":
 "theorem map_coeffs_apply (i : ι) : b.map_coeffs f h i = b i :=\n  apply_eq_iff.mpr <| by simp [f.to_add_equiv_eq_coe]\n#align map_coeffs_apply map_coeffs_apply\n\n",
 "map_apply":
 "@[simp]\ntheorem map_apply (i) : b.map f i = f (b i) :=\n  rfl\n#align map_apply map_apply\n\n",
 "linear_independent":
 "theorem of_vector_space_index.linear_independent : linear_independent K (coe : of_vector_space_index K V → V) :=\n  by\n  convert (of_vector_space K V).linear_independent\n  ext x\n  rw [of_vector_space_apply_self]\n#align of_vector_space_index.linear_independent of_vector_space_index.linear_independent\n\n",
 "is_unit_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_unit_smul_apply {v : basis ι R M} {w : ι → R} (hw : ∀ i, is_unit (w i)) (i : ι) :\n    v.is_unit_smul hw i = «expr • » (w i) (v i) :=\n  units_smul_apply i\n#align is_unit_smul_apply is_unit_smul_apply\n\n",
 "injective":
 "protected theorem injective [nontrivial R] : injective b :=\n  b.repr.symm.injective.comp fun _ _ => (finsupp.single_left_inj (one_ne_zero : (1 : R) ≠ 0)).mp\n#align injective injective\n\n",
 "index_nonempty":
 "theorem index_nonempty (b : basis ι R M) [nontrivial M] : nonempty ι :=\n  by\n  obtain ⟨x, y, ne⟩ : ∃ x y : M, x ≠ y := nontrivial.exists_pair_ne\n  obtain ⟨i, _⟩ := not_forall.mp (mt b.ext_elem_iff.2 ne)\n  exact ⟨i⟩\n#align index_nonempty index_nonempty\n\n",
 "group_smul_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem group_smul_span_eq_top {G : Type _} [group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] {v : ι → M} (hv : submodule.span R (Set.range v) = «expr⊤») {w : ι → G} :\n    submodule.span R (Set.range («expr • » w v)) = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro j hj\n  rw [← hv] at hj\n  rw [submodule.mem_span] at hj⊢\n  refine' fun p hp => hj p fun u hu => _\n  obtain ⟨i, rfl⟩ := hu\n  have : «expr • » («expr • » (w i)⁻¹ 1 : R) («expr • » (w i) (v i)) ∈ p :=\n    p.smul_mem («expr • » (w i)⁻¹ 1 : R) (hp ⟨i, rfl⟩)\n  rwa [smul_one_smul, inv_smul_smul] at this\n#align group_smul_span_eq_top group_smul_span_eq_top\n\n",
 "group_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem group_smul_apply {G : Type _} [group G] [DistribMulAction G R] [DistribMulAction G M] [IsScalarTower G R M]\n    [SMulCommClass G R M] {v : basis ι R M} {w : ι → G} (i : ι) : v.group_smul w i = («expr • » w v : ι → M) i :=\n  mk_apply (v.linear_independent.group_smul w) (group_smul_span_eq_top v.span_eq).ge i\n#align group_smul_apply group_smul_apply\n\n",
 "forall_coord_eq_zero_iff":
 "theorem forall_coord_eq_zero_iff {x : M} : (∀ i, b.coord i x = 0) ↔ x = 0 :=\n  iff.trans (by simp only [b.coord_apply, finsupp.ext_iff, finsupp.zero_apply]) b.repr.map_eq_zero_iff\n#align forall_coord_eq_zero_iff forall_coord_eq_zero_iff\n\n",
 "fin_two_prod_zero":
 "@[simp]\ntheorem fin_two_prod_zero (R : Type _) [Semiring R] : basis.fin_two_prod R 0 = (1, 0) := by simp [basis.fin_two_prod]\n#align fin_two_prod_zero fin_two_prod_zero\n\n",
 "fin_two_prod_one":
 "@[simp]\ntheorem fin_two_prod_one (R : Type _) [Semiring R] : basis.fin_two_prod R 1 = (0, 1) := by simp [basis.fin_two_prod]\n#align fin_two_prod_one fin_two_prod_one\n\n",
 "extend_apply_self":
 "theorem extend_apply_self (hs : linear_independent K (coe : s → V)) (x : hs.extend _) : basis.extend hs x = x :=\n  basis.mk_apply _ _ _\n#align extend_apply_self extend_apply_self\n\n",
 "ext_elem_iff":
 "/-- Two elements are equal iff their coordinates are equal. -/\ntheorem ext_elem_iff {x y : M} : x = y ↔ ∀ i, b.repr x i = b.repr y i := by\n  simp only [← finsupp.ext_iff, embedding_like.apply_eq_iff_eq]\n#align ext_elem_iff ext_elem_iff\n\n",
 "ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/-- Two linear equivs are equal if they are equal on basis vectors. -/\ntheorem ext' {f₁ f₂ : «expr ≃ₛₗ[ ] » M σ M₁} (h : ∀ i, f₁ (b i) = f₂ (b i)) : f₁ = f₂ :=\n  by\n  ext x\n  rw [← b.total_repr x, finsupp.total_apply, finsupp.sum]\n  simp only [linear_equiv.map_sum, linear_equiv.map_smulₛₗ, h]\n#align ext' ext'\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- Two linear maps are equal if they are equal on basis vectors. -/\ntheorem ext {f₁ f₂ : «expr →ₛₗ[ ] » M σ M₁} (h : ∀ i, f₁ (b i) = f₂ (b i)) : f₁ = f₂ :=\n  by\n  ext x\n  rw [← b.total_repr x, finsupp.total_apply, finsupp.sum]\n  simp only [linear_map.map_sum, linear_map.map_smulₛₗ, h]\n#align ext ext\n\n",
 "exists_right_inverse_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.exists_right_inverse_of_surjective (f : «expr →ₗ[ ] » V K V') (hf_surj : f.range = «expr⊤») :\n    ∃ g : «expr →ₗ[ ] » V' K V, f.comp g = linear_map.id :=\n  by\n  let C := basis.of_vector_space_index K V'\n  let hC := basis.of_vector_space K V'\n  haveI : inhabited V := ⟨0⟩\n  use hC.constr ℕ (C.restrict (inv_fun f))\n  refine' hC.ext fun c => _\n  rw [linear_map.comp_apply, hC.constr_basis]\n  simp [right_inverse_inv_fun (linear_map.range_eq_top.1 hf_surj) c]\n#align linear_map.exists_right_inverse_of_surjective linear_map.exists_right_inverse_of_surjective\n\n",
 "exists_left_inverse_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.exists_left_inverse_of_injective (f : «expr →ₗ[ ] » V K V') (hf_inj : f.ker = «expr⊥») :\n    ∃ g : «expr →ₗ[ ] » V' K V, g.comp f = linear_map.id :=\n  by\n  let B := basis.of_vector_space_index K V\n  let hB := basis.of_vector_space K V\n  have hB₀ : _ := hB.linear_independent.to_subtype_range\n  have : linear_independent K (fun x => x : «expr '' » f B → V') :=\n    by\n    have h₁ :\n      linear_independent K fun x : «expr↥ » («expr '' » («expr⇑ » f) (range (basis.of_vector_space _ _))) => ↑x :=\n      @linear_independent.image_subtype _ _ _ _ _ _ _ _ _ f hB₀ (show Disjoint _ _ by simp [hf_inj])\n    rwa [basis.range_of_vector_space K V] at h₁\n  let C := this.extend (subset_univ _)\n  have BC := this.subset_extend (subset_univ _)\n  let hC := basis.extend this\n  haveI : inhabited V := ⟨0⟩\n  refine' ⟨hC.constr ℕ (C.restrict (inv_fun f)), hB.ext fun b => _⟩\n  rw [image_subset_iff] at BC\n  have fb_eq : f b = hC ⟨f b, BC b.2⟩ := by\n    change f b = basis.extend this _\n    rw [basis.extend_apply_self, subtype.coe_mk]\n  dsimp [hB]\n  rw [basis.of_vector_space_apply_self, fb_eq, hC.constr_basis]\n  exact left_inverse_inv_fun (linear_map.ker_eq_bot.1 hf_inj) _\n#align linear_map.exists_left_inverse_of_injective linear_map.exists_left_inverse_of_injective\n\n",
 "exists_le_ker_of_lt_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (f «expr ≠ » (0 : «expr →ₗ[ ] »(V, K, K))) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If `p < ⊤` is a subspace of a vector space `V`, then there exists a nonzero linear map\n`f : V →ₗ[K] K` such that `p ≤ ker f`. -/\ntheorem submodule.exists_le_ker_of_lt_top (p : submodule K V) (hp : p < «expr⊤») :\n    ∃ (f : _)(_ : f ≠ (0 : «expr →ₗ[ ] » V K K)), p ≤ ker f :=\n  by\n  rcases SetLike.exists_of_lt hp with ⟨v, -, hpv⟩; clear hp\n  rcases(linear_pmap.sup_span_singleton ⟨p, 0⟩ v (1 : K) hpv).to_fun.exists_extend with ⟨f, hf⟩\n  refine' ⟨f, _, _⟩\n  · rintro rfl\n    rw [linear_map.zero_comp] at hf\n    have := linear_pmap.sup_span_singleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv 0 p.zero_mem 1\n    simpa using (linear_map.congr_fun hf _).trans this\n  · refine' fun x hx => mem_ker.2 _\n    have := linear_pmap.sup_span_singleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv x hx 0\n    simpa using (linear_map.congr_fun hf _).trans this\n#align submodule.exists_le_ker_of_lt_top submodule.exists_le_ker_of_lt_top\n\n",
 "exists_is_compl":
 "theorem submodule.exists_is_compl (p : submodule K V) : ∃ q : submodule K V, IsCompl p q :=\n  let ⟨f, hf⟩ := p.subtype.exists_left_inverse_of_injective p.ker_subtype\n  ⟨f.ker, linear_map.is_compl_of_proj <| linear_map.ext_iff.1 hf⟩\n#align submodule.exists_is_compl submodule.exists_is_compl\n\n",
 "exists_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Any linear map `f : p →ₗ[K] V'` defined on a subspace `p` can be extended to the whole\nspace. -/\ntheorem linear_map.exists_extend {p : submodule K V} (f : «expr →ₗ[ ] » p K V') :\n    ∃ g : «expr →ₗ[ ] » V K V', g.comp p.subtype = f :=\n  let ⟨g, hg⟩ := p.subtype.exists_left_inverse_of_injective p.ker_subtype\n  ⟨f.comp g, by rw [linear_map.comp_assoc, hg, f.comp_id]⟩\n#align linear_map.exists_extend linear_map.exists_extend\n\n",
 "exists_basis":
 "theorem exists_basis : ∃ s : set V, nonempty (basis s K V) :=\n  ⟨of_vector_space_index K V, ⟨of_vector_space K V⟩⟩\n#align exists_basis exists_basis\n\n",
 "equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem equiv_trans {ι'' : Type _} (b'' : basis ι'' R M'') (e : «expr ≃ » ι ι') (e' : «expr ≃ » ι' ι'') :\n    (b.equiv b' e).trans (b'.equiv b'' e') = b.equiv b'' (e.trans e') :=\n  b.ext' fun i => by simp\n#align equiv_trans equiv_trans\n\n",
 "equiv_symm":
 "@[simp]\ntheorem equiv_symm : (b.equiv b' e).symm = b'.equiv b e.symm :=\n  b'.ext' fun i => (b.equiv b' e).injective (by simp)\n#align equiv_symm equiv_symm\n\n",
 "equiv_refl":
 "@[simp]\ntheorem equiv_refl : b.equiv b (equiv.refl ι) = linear_equiv.refl R M :=\n  b.ext' fun i => by simp\n#align equiv_refl equiv_refl\n\n",
 "equiv_fun_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Given a basis `v` indexed by `ι`, the canonical linear equivalence between `ι → R` and `M` maps\na function `x : ι → R` to the linear combination `∑_i x i • v i`. -/\n@[simp]\ntheorem basis.equiv_fun_symm_apply (x : ι → R) :\n    b.equiv_fun.symm x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (x i) (b i)) :=\n  by simp [basis.equiv_fun, finsupp.total_apply, finsupp.sum_fintype]\n#align basis.equiv_fun_symm_apply basis.equiv_fun_symm_apply\n\n",
 "equiv_fun_self":
 "@[simp]\ntheorem basis.equiv_fun_self (i j : ι) : b.equiv_fun (b i) j = if i = j then 1 else 0 := by\n  rw [b.equiv_fun_apply, b.repr_self_apply]\n#align basis.equiv_fun_self basis.equiv_fun_self\n\n",
 "equiv_fun_apply":
 "@[simp]\ntheorem basis.equiv_fun_apply (u : M) : b.equiv_fun u = b.repr u :=\n  rfl\n#align basis.equiv_fun_apply basis.equiv_fun_apply\n\n",
 "equiv_apply":
 "@[simp]\ntheorem equiv_apply : b.equiv b' e (b i) = b' (e i) := by simp [basis.equiv]\n#align equiv_apply equiv_apply\n\n",
 "equiv'_symm_apply":
 "@[simp]\ntheorem equiv'_symm_apply (f : M → M') (g : M' → M) (hf hg hgf hfg) (i : ι') :\n    (b.equiv' b' f g hf hg hgf hfg).symm (b' i) = g (b' i) :=\n  b'.constr_basis R _ _\n#align equiv'_symm_apply equiv'_symm_apply\n\n",
 "equiv'_apply":
 "@[simp]\ntheorem equiv'_apply (f : M → M') (g : M' → M) (hf hg hgf hfg) (i : ι) :\n    b.equiv' b' f g hf hg hgf hfg (b i) = f (b i) :=\n  b.constr_basis R _ _\n#align equiv'_apply equiv'_apply\n\n",
 "eq_of_repr_eq_repr":
 "/-- Two bases are equal if they assign the same coordinates. -/\ntheorem eq_of_repr_eq_repr {b₁ b₂ : basis ι R M} (h : ∀ x i, b₁.repr x i = b₂.repr x i) : b₁ = b₂ :=\n  by\n  have : b₁.repr = b₂.repr := by\n    ext\n    apply h\n  cases b₁\n  cases b₂\n  simpa\n#align eq_of_repr_eq_repr eq_of_repr_eq_repr\n\n",
 "eq_of_apply_eq":
 "/-- Two bases are equal if their basis vectors are the same. -/\n@[ext]\ntheorem eq_of_apply_eq {b₁ b₂ : basis ι R M} (h : ∀ i, b₁ i = b₂ i) : b₁ = b₂ :=\n  suffices b₁.repr = b₂.repr by\n    cases b₁\n    cases b₂\n    simpa\n  repr_eq_iff'.mpr fun i => by rw [h, b₂.repr_self]\n#align eq_of_apply_eq eq_of_apply_eq\n\n",
 "eq_bot_of_rank_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem _root_.eq_bot_of_rank_eq_zero [no_zero_divisors R] (b : basis ι R M) (N : submodule R M)\n    (rank_eq : ∀ {m : ℕ} (v : fin m → N), linear_independent R (coe ∘ v : fin m → M) → m = 0) : N = «expr⊥» :=\n  by\n  rw [submodule.eq_bot_iff]\n  intro x hx\n  contrapose! rank_eq with x_ne\n  refine' ⟨1, fun _ => ⟨x, hx⟩, _, one_ne_zero⟩\n  rw [fintype.linear_independent_iff]\n  rintro g sum_eq i\n  cases i\n  simp only [function.const_apply, fin.default_eq_zero, submodule.coe_mk, finset.univ_unique, function.comp_const,\n    finset.sum_singleton] at sum_eq\n  convert (b.smul_eq_zero.mp sum_eq).resolve_right x_ne\n#align eq_bot_of_rank_eq_zero eq_bot_of_rank_eq_zero\n\n",
 "dvd_coord_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem dvd_coord_smul (i : ι) (m : M) (r : R) : r ∣ b.coord i («expr • » r m) :=\n  ⟨b.coord i m, by simp⟩\n#align dvd_coord_smul dvd_coord_smul\n\n",
 "coord_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coord_units_smul (e : basis ι R₂ M) (w : ι → «expr ˣ» R₂) (i : ι) :\n    (e.units_smul w).coord i = «expr • » (w i)⁻¹ (e.coord i) :=\n  by\n  apply e.ext\n  intro j\n  trans ((e.units_smul w).coord i) («expr • » (w j)⁻¹ ((e.units_smul w) j))\n  · congr\n    simp [basis.units_smul, ← mul_smul]\n  simp only [basis.coord_apply, linear_map.smul_apply, basis.repr_self, Units.smul_def, smul_hom_class.map_smul,\n    finsupp.single_apply]\n  split_ifs with h h\n  · simp [h]\n  · simp\n#align coord_units_smul coord_units_smul\n\n",
 "coord_repr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem coord_repr_symm (b : basis ι R M) (i : ι) (f : «expr →₀ » ι R) : b.coord i (b.repr.symm f) = f i := by\n  simp only [repr_symm_apply, coord_apply, repr_total]\n#align coord_repr_symm coord_repr_symm\n\n",
 "coord_equiv_fun_symm":
 "theorem basis.coord_equiv_fun_symm (i : ι) (f : ι → R) : b.coord i (b.equiv_fun.symm f) = f i :=\n  b.coord_repr_symm i (finsupp.equiv_fun_on_finite.symm f)\n#align basis.coord_equiv_fun_symm basis.coord_equiv_fun_symm\n\n",
 "constr_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem constr_self (f : «expr →ₗ[ ] » M R M') : (b.constr S fun i => f (b i)) = f :=\n  b.constr_eq S fun x => rfl\n#align constr_self constr_self\n\n",
 "constr_range":
 "theorem constr_range [nonempty ι] {f : ι → M'} : (b.constr S f).range = span R (range f) := by\n  rw [b.constr_def S f, linear_map.range_comp, linear_map.range_comp, linear_equiv.range, ← finsupp.supported_univ,\n    finsupp.lmap_domain_supported, ← Set.image_univ, ← finsupp.span_image_eq_map_total, Set.image_id]\n#align constr_range constr_range\n\n",
 "constr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem constr_eq {g : ι → M'} {f : «expr →ₗ[ ] » M R M'} (h : ∀ i, g i = f (b i)) : b.constr S g = f :=\n  b.ext fun i => (b.constr_basis S g i).trans (h i)\n#align constr_eq constr_eq\n\n",
 "constr_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem constr_def (f : ι → M') :\n    b.constr S f = «expr ∘ₗ » (finsupp.total M' M' R id) («expr ∘ₗ » (finsupp.lmap_domain R R f) ↑b.repr) :=\n  rfl\n#align constr_def constr_def\n\n",
 "constr_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem constr_comp (f : «expr →ₗ[ ] » M' R M') (v : ι → M') : b.constr S (f ∘ v) = f.comp (b.constr S v) :=\n  b.ext fun i => by simp only [basis.constr_basis, linear_map.comp_apply]\n#align constr_comp constr_comp\n\n",
 "constr_basis":
 "@[simp]\ntheorem constr_basis (f : ι → M') (i : ι) : (b.constr S f : M → M') (b i) = f i := by\n  simp [basis.constr_apply, b.repr_self]\n#align constr_basis constr_basis\n\n",
 "constr_apply_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem basis.constr_apply_fintype (f : ι → M') (x : M) :\n    (b.constr S f : M → M') x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.equiv_fun x i) (f i)) :=\n  by simp [b.constr_apply, b.equiv_fun_apply, finsupp.sum_fintype]\n#align basis.constr_apply_fintype basis.constr_apply_fintype\n\n",
 "constr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem constr_apply (f : ι → M') (x : M) : b.constr S f x = (b.repr x).sum fun b a => «expr • » a (f b) :=\n  by\n  simp only [constr_def, linear_map.comp_apply, finsupp.lmap_domain_apply, finsupp.total_apply]\n  rw [finsupp.sum_map_domain_index] <;> simp [add_smul]\n#align constr_apply constr_apply\n\n",
 "coe_sum_coords_of_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem coe_sum_coords_of_fintype [fintype ι] :\n    (b.sum_coords : M → R) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.coord i) :=\n  by\n  ext m\n  simp only [sum_coords, finsupp.sum_fintype, linear_map.id_coe, linear_equiv.coe_coe, coord_apply, id.def,\n    fintype.sum_apply, imp_true_iff, eq_self_iff_true, finsupp.coe_lsum, linear_map.coe_comp]\n#align coe_sum_coords_of_fintype coe_sum_coords_of_fintype\n\n",
 "coe_sum_coords_eq_finsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finsum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum -/\ntheorem coe_sum_coords_eq_finsum :\n    (b.sum_coords : M → R) = fun m =>\n      finsum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finsum\" (b.coord i m) :=\n  by\n  ext m\n  simp only [basis.sum_coords, basis.coord, finsupp.lapply_apply, linear_map.id_coe, linear_equiv.coe_coe,\n    Function.comp_apply, finsupp.coe_lsum, linear_map.coe_comp, finsum_eq_sum _ (b.repr m).finite_support, finsupp.sum,\n    finset.finite_to_set_to_finset, id.def, finsupp.fun_support_eq]\n#align coe_sum_coords_eq_finsum coe_sum_coords_eq_finsum\n\n",
 "coe_sum_coords":
 "@[simp]\ntheorem coe_sum_coords : (b.sum_coords : M → R) = fun m => (b.repr m).sum fun i => id :=\n  rfl\n#align coe_sum_coords coe_sum_coords\n\n",
 "coe_repr_symm":
 "@[simp]\ntheorem coe_repr_symm : ↑b.repr.symm = finsupp.total ι M R b :=\n  linear_map.ext fun v => b.repr_symm_apply v\n#align coe_repr_symm coe_repr_symm\n\n",
 "coe_reindex_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem coe_reindex_repr : ((b.reindex e).repr x : ι' → R) = b.repr x ∘ e.symm :=\n  funext fun i' => show (finsupp.dom_lcongr e : «expr ≃ₗ[ ] » _ R _) (b.repr x) i' = _ by simp\n#align coe_reindex_repr coe_reindex_repr\n\n",
 "coe_reindex":
 "@[simp]\ntheorem coe_reindex : (b.reindex e : ι' → M) = b ∘ e.symm :=\n  funext (b.reindex_apply e)\n#align coe_reindex coe_reindex\n\n",
 "coe_of_vector_space":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_of_vector_space : «expr⇑ » (of_vector_space K V) = coe :=\n  funext fun x => of_vector_space_apply_self K V x\n#align coe_of_vector_space coe_of_vector_space\n\n",
 "coe_of_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Alexander Bentkamp\n-/\n@[simp]\ntheorem coe_of_repr (e : «expr ≃ₗ[ ] » M R («expr →₀ » ι R)) :\n    «expr⇑ » (of_repr e) = fun i => e.symm (finsupp.single i 1) :=\n  rfl\n#align coe_of_repr coe_of_repr\n\n",
 "coe_of_equiv_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem basis.coe_of_equiv_fun (e : «expr ≃ₗ[ ] » M R (ι → R)) :\n    (basis.of_equiv_fun e : ι → M) = fun i => e.symm (function.update 0 i 1) :=\n  funext fun i =>\n    e.injective <| funext fun j => by simp [basis.of_equiv_fun, ← finsupp.single_eq_pi_single, finsupp.single_eq_update]\n#align basis.coe_of_equiv_fun basis.coe_of_equiv_fun\n\n",
 "coe_mk_fin_cons_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_mk_fin_cons_of_le {n : ℕ} {N O : submodule R M} (y : M) (yO : y ∈ O) (b : basis (fin n) R N) (hNO : N ≤ O)\n    (hli : ∀ (c : R), ∀ x ∈ N, «expr • » c y + x = 0 → c = 0) (hsp : ∀ z ∈ O, ∃ c : R, z + «expr • » c y ∈ N) :\n    (mk_fin_cons_of_le y yO b hNO hli hsp : fin (n + 1) → O) = fin.cons ⟨y, yO⟩ (submodule.of_le hNO ∘ b) :=\n  coe_mk_fin_cons _ _ _ _\n#align coe_mk_fin_cons_of_le coe_mk_fin_cons_of_le\n\n",
 "coe_mk_fin_cons":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_mk_fin_cons {n : ℕ} {N : submodule R M} (y : M) (b : basis (fin n) R N)\n    (hli : ∀ (c : R), ∀ x ∈ N, «expr • » c y + x = 0 → c = 0) (hsp : ∀ z : M, ∃ c : R, z + «expr • » c y ∈ N) :\n    (mk_fin_cons y b hli hsp : fin (n + 1) → M) = fin.cons y (coe ∘ b) :=\n  coe_mk _ _\n#align coe_mk_fin_cons coe_mk_fin_cons\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk : «expr⇑ » (basis.mk hli hsp) = v :=\n  funext (mk_apply _ _)\n#align coe_mk coe_mk\n\n",
 "coe_map_coeffs":
 "@[simp]\ntheorem coe_map_coeffs : (b.map_coeffs f h : ι → M) = b :=\n  funext <| b.map_coeffs_apply f h\n#align coe_map_coeffs coe_map_coeffs\n\n",
 "coe_fin_two_prod_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n@[simp]\ntheorem coe_fin_two_prod_repr {R : Type _} [Semiring R] (x : R × R) :\n    «expr⇑ » ((basis.fin_two_prod R).repr x) =\n      «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\" :=\n  rfl\n#align coe_fin_two_prod_repr coe_fin_two_prod_repr\n\n",
 "coe_extend":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_extend (hs : linear_independent K (coe : s → V)) : «expr⇑ » (basis.extend hs) = coe :=\n  funext (extend_apply_self hs)\n#align coe_extend coe_extend\n\n",
 "card_fintype":
 "theorem vector_space.card_fintype [fintype K] [fintype V] : ∃ n : ℕ, card V = card K ^ n :=\n  ⟨card (basis.of_vector_space_index K V), module.card_fintype (basis.of_vector_space K V)⟩\n#align vector_space.card_fintype vector_space.card_fintype\n\n",
 "basis_singleton_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ≠ » 0) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem basis_singleton_iff {R M : Type _} [Ring R] [nontrivial R] [add_comm_group M] [Module R M]\n    [NoZeroSMulDivisors R M] (ι : Type _) [unique ι] :\n    nonempty (basis ι R M) ↔ ∃ (x : _)(_ : x ≠ 0), ∀ y : M, ∃ r : R, «expr • » r x = y :=\n  by\n  fconstructor\n  · rintro ⟨b⟩\n    refine' ⟨b default, b.linear_independent.ne_zero _, _⟩\n    simpa [span_singleton_eq_top_iff, Set.range_unique] using b.span_eq\n  · rintro ⟨x, nz, w⟩\n    refine'\n      ⟨of_repr <|\n          linear_equiv.symm\n            { to_fun := fun f => «expr • » (f default) x\n              inv_fun := fun y => finsupp.single default (w y).some\n              left_inv := fun f => finsupp.unique_ext _\n              right_inv := fun y => _\n              map_add' := fun y z => _\n              map_smul' := fun c y => _ }⟩\n    · rw [finsupp.add_apply, add_smul]\n    · rw [finsupp.smul_apply, smul_assoc]\n      simp\n    · refine' smul_left_injective _ nz _\n      simp only [finsupp.single_eq_same]\n      exact (w («expr • » (f default) x)).some_spec\n    · simp only [finsupp.single_eq_same]\n      exact (w y).some_spec\n#align basis_singleton_iff basis_singleton_iff\n\n",
 "atom_iff_nonzero_span":
 "/-- The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. -/\ntheorem atom_iff_nonzero_span (W : submodule K V) : IsAtom W ↔ ∃ (v : V)(hv : v ≠ 0), W = span K {v} :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · cases' h with hbot h\n    rcases(submodule.ne_bot_iff W).1 hbot with ⟨v, ⟨hW, hv⟩⟩\n    refine' ⟨v, ⟨hv, _⟩⟩\n    by_contra heq\n    specialize h (span K {v})\n    rw [span_singleton_eq_bot, lt_iff_le_and_ne] at h\n    exact hv (h ⟨(span_singleton_le_iff_mem v W).2 hW, ne.symm HEq⟩)\n  · rcases h with ⟨v, ⟨hv, rfl⟩⟩\n    exact nonzero_span_atom v hv\n#align atom_iff_nonzero_span atom_iff_nonzero_span\n\n",
 "apply_eq_iff":
 "theorem apply_eq_iff {b : basis ι R M} {x : M} {i : ι} : b i = x ↔ b.repr x = finsupp.single i 1 :=\n  ⟨fun h => h ▸ b.repr_self i, fun h => b.repr.injective ((b.repr_self i).trans h.symm)⟩\n#align apply_eq_iff apply_eq_iff\n\n",
 "NoZeroSMulDivisors":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print NoZeroSMulDivisors /-\n-- Can't be an instance because the basis can't be inferred.\nprotected theorem NoZeroSMulDivisors [no_zero_divisors R] (b : basis ι R M) : NoZeroSMulDivisors R M :=\n  ⟨fun c x hcx =>\n    or_iff_not_imp_right.mpr fun hx =>\n      by\n      rw [← b.total_repr x, ← linear_map.map_smul] at hcx\n      have := linear_independent_iff.mp b.linear_independent («expr • » c (b.repr x)) hcx\n      rw [smul_eq_zero] at this\n      exact this.resolve_right fun hr => hx (b.repr.map_eq_zero_iff.mp hr)⟩\n#align no_zero_smul_divisors NoZeroSMulDivisors\n-/\n\n"}