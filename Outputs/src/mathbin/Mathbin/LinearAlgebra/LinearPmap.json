{"val_from_graph_mem":
 "theorem val_from_graph_mem {g : submodule R (E × F)} (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0)\n    {a : E} (ha : a ∈ g.map (linear_map.fst R E F)) : (a, val_from_graph hg ha) ∈ g :=\n  (ExistsUnique.exists (exists_unique_from_graph hg ha)).some_spec\n#align val_from_graph_mem val_from_graph_mem\n\n",
 "vadd_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem vadd_domain (f : «expr →ₗ[ ] » E R F) (g : «expr →ₗ.[ ] » E R F) : («expr +ᵥ » f g).domain = g.domain :=\n  rfl\n#align vadd_domain vadd_domain\n\n",
 "vadd_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\ntheorem vadd_apply (f : «expr →ₗ[ ] » E R F) (g : «expr →ₗ.[ ] » E R F) (x : («expr +ᵥ » f g).domain) :\n    («expr +ᵥ » f g) x = f x + g x :=\n  rfl\n#align vadd_apply vadd_apply\n\n",
 "to_pmap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem to_pmap_apply (f : «expr →ₗ[ ] » E R F) (p : submodule R E) (x : p) : f.to_pmap p x = f x :=\n  rfl\n#align to_pmap_apply to_pmap_apply\n\n",
 "to_linear_pmap_graph_eq":
 "@[simp]\ntheorem to_linear_pmap_graph_eq (g : submodule R (E × F))\n    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) : (g.to_linear_pmap hg).graph = g :=\n  by\n  ext\n  constructor <;> intro hx\n  · rw [linear_pmap.mem_graph_iff] at hx\n    rcases hx with ⟨y, hx1, hx2⟩\n    convert g.mem_graph_to_linear_pmap hg y\n    rw [subtype.val_eq_coe]\n    exact Prod.ext hx1.symm hx2.symm\n  rw [linear_pmap.mem_graph_iff]\n  cases x\n  have hx_fst : x_fst ∈ g.map (linear_map.fst R E F) :=\n    by\n    simp only [mem_map, linear_map.fst_apply, prod.exists, exists_and_right, exists_eq_right]\n    exact ⟨x_snd, hx⟩\n  refine' ⟨⟨x_fst, hx_fst⟩, subtype.coe_mk x_fst hx_fst, _⟩\n  exact (exists_unique_from_graph hg hx_fst).unique (val_from_graph_mem hg hx_fst) hx\n#align to_linear_pmap_graph_eq to_linear_pmap_graph_eq\n\n",
 "to_fun_eq_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-\nCopyright (c) 2020 Yury Kudryashov All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov, Moritz Doll\n-/\n@[simp]\ntheorem to_fun_eq_coe (f : «expr →ₗ.[ ] » E R F) (x : f.domain) : f.to_fun x = f x :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "supₛ_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print supₛ_le /-\nprotected theorem supₛ_le {c : set («expr →ₗ.[ ] » E R F)} (hc : DirectedOn (· ≤ ·) c) {g : «expr →ₗ.[ ] » E R F}\n    (hg : ∀ f ∈ c, f ≤ g) : linear_pmap.Sup c hc ≤ g :=\n  le_of_eq_locus_ge <|\n    supₛ_le fun _ ⟨f, hf, eq⟩ =>\n      eq ▸\n        have : f ≤ «expr ⊓ » (linear_pmap.Sup c hc) g := le_inf (linear_pmap.le_Sup _ hf) (hg f hf)\n        this.1\n#align Sup_le supₛ_le\n-/\n\n",
 "supₛ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print supₛ_apply /-\nprotected theorem supₛ_apply {c : set («expr →ₗ.[ ] » E R F)} (hc : DirectedOn (· ≤ ·) c) {l : «expr →ₗ.[ ] » E R F}\n    (hl : l ∈ c) (x : l.domain) : (linear_pmap.Sup c hc) ⟨x, (linear_pmap.le_Sup hc hl).1 x.2⟩ = l x :=\n  by\n  symm\n  apply (Classical.choose_spec (Sup_aux c hc) hl).2\n  rfl\n#align Sup_apply supₛ_apply\n-/\n\n",
 "sup_span_singleton_apply_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem sup_span_singleton_apply_mk (f : «expr →ₗ.[ ] » E K F) (x : E) (y : F) (hx : x ∉ f.domain) (x' : E)\n    (hx' : x' ∈ f.domain) (c : K) :\n    f.sup_span_singleton x y hx ⟨x' + «expr • » c x, mem_sup.2 ⟨x', hx', _, mem_span_singleton.2 ⟨c, rfl⟩, rfl⟩⟩ =\n      f ⟨x', hx'⟩ + «expr • » c y :=\n  by\n  erw [sup_apply _ ⟨x', hx'⟩ ⟨«expr • » c x, _⟩, mk_span_singleton'_apply]\n  rfl\n  exact mem_span_singleton.2 ⟨c, rfl⟩\n#align sup_span_singleton_apply_mk sup_span_singleton_apply_mk\n\n",
 "sup_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print sup_le /-\nprotected theorem sup_le {f g h : «expr →ₗ.[ ] » E R F} (H : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y)\n    (fh : f ≤ h) (gh : g ≤ h) : f.sup g H ≤ h :=\n  have Hf : f ≤ «expr ⊓ » (f.sup g H) h := le_inf (f.left_le_sup g H) fh\n  have Hg : g ≤ «expr ⊓ » (f.sup g H) h := le_inf (f.right_le_sup g H) gh\n  le_of_eq_locus_ge <| sup_le Hf.1 Hg.1\n#align sup_le sup_le\n-/\n\n",
 "sup_h_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- Hypothesis for `linear_pmap.sup` holds, if `f.domain` is disjoint with `g.domain`. -/\ntheorem sup_h_of_disjoint (f g : «expr →ₗ.[ ] » E R F) (h : Disjoint f.domain g.domain) (x : f.domain) (y : g.domain)\n    (hxy : (x : E) = y) : f x = g y := by\n  rw [disjoint_def] at h\n  have hy : y = 0 := subtype.eq (h y (hxy ▸ x.2) y.2)\n  have hx : x = 0 := subtype.eq (hxy.trans <| congr_arg _ hy)\n  simp [*]\n#align sup_h_of_disjoint sup_h_of_disjoint\n\n",
 "sup_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\nprivate theorem sup_aux (f g : «expr →ₗ.[ ] » E R F) (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) :\n    ∃ fg : «expr →ₗ[ ] » («expr↥ » («expr ⊔ » f.domain g.domain)) R F,\n      ∀ (x : f.domain) (y : g.domain) (z), (x : E) + y = ↑z → fg z = f x + g y :=\n  by\n  choose x hx y hy hxy using fun z : «expr ⊔ » f.domain g.domain => mem_sup.1 z.prop\n  set fg := fun z => f ⟨x z, hx z⟩ + g ⟨y z, hy z⟩\n  have fg_eq :\n    ∀ (x' : f.domain) (y' : g.domain) (z' : «expr ⊔ » f.domain g.domain) (H : (x' : E) + y' = z'),\n      fg z' = f x' + g y' :=\n    by\n    intro x' y' z' H\n    dsimp [fg]\n    rw [add_comm, ← sub_eq_sub_iff_add_eq_add, eq_comm, ← map_sub, ← map_sub]\n    apply h\n    simp only [← eq_sub_iff_add_eq] at hxy\n    simp only [add_subgroup_class.coe_sub, coe_mk, coe_mk, hxy, ← sub_add, ← sub_sub, sub_self, zero_sub, ← H]\n    apply neg_add_eq_sub\n  refine' ⟨{ to_fun := fg.. }, fg_eq⟩\n  · rintro ⟨z₁, hz₁⟩ ⟨z₂, hz₂⟩\n    rw [← add_assoc, add_right_comm (f _), ← map_add, add_assoc, ← map_add]\n    apply fg_eq\n    simp only [coe_add, coe_mk, ← add_assoc]\n    rw [add_right_comm (x _), hxy, add_assoc, hxy, coe_mk, coe_mk]\n  · intro c z\n    rw [smul_add, ← map_smul, ← map_smul]\n    apply fg_eq\n    simp only [coe_smul, coe_mk, ← smul_add, hxy, RingHom.id_apply]\n#align sup_aux sup_aux\n\n",
 "sup_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem sup_apply {f g : «expr →ₗ.[ ] » E R F} (H : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) (x y z)\n    (hz : (↑x : E) + ↑y = ↑z) : f.sup g H z = f x + g y :=\n  Classical.choose_spec (sup_aux f g H) x y z hz\n#align sup_apply sup_apply\n\n",
 "snd_apply":
 "@[simp]\ntheorem snd_apply (p : submodule R E) (p' : submodule R F) (x : p.prod p') : linear_pmap.snd p p' x = (x : E × F).2 :=\n  rfl\n#align snd_apply snd_apply\n\n",
 "smul_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The graph of `z • f` as a pushforward. -/\ntheorem smul_graph (f : «expr →ₗ.[ ] » E R F) (z : M) :\n    («expr • » z f).graph =\n      f.graph.map\n        ((linear_map.id : «expr →ₗ[ ] » E R E).prod_map («expr • » z (linear_map.id : «expr →ₗ[ ] » F R F))) :=\n  by\n  ext x; cases x\n  constructor <;> intro h\n  · rw [mem_graph_iff] at h\n    rcases h with ⟨y, hy, h⟩\n    rw [linear_pmap.smul_apply] at h\n    rw [submodule.mem_map]\n    simp only [mem_graph_iff, linear_map.prod_map_apply, linear_map.id_coe, id.def, linear_map.smul_apply,\n      prod.mk.inj_iff, prod.exists, exists_exists_and_eq_and]\n    use x_fst, y\n    simp [hy, h]\n  rw [submodule.mem_map] at h\n  rcases h with ⟨x', hx', h⟩\n  cases x'\n  simp only [linear_map.prod_map_apply, linear_map.id_coe, id.def, linear_map.smul_apply, prod.mk.inj_iff] at h\n  rw [mem_graph_iff] at hx'⊢\n  rcases hx' with ⟨y, hy, hx'⟩\n  use y\n  rw [← h.1, ← h.2]\n  simp [hy, hx']\n#align smul_graph smul_graph\n\n",
 "smul_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_domain (a : M) (f : «expr →ₗ.[ ] » E R F) : («expr • » a f).domain = f.domain :=\n  rfl\n#align smul_domain smul_domain\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_apply (a : M) (f : «expr →ₗ.[ ] » E R F) (x : («expr • » a f).domain) :\n    («expr • » a f) x = «expr • » a (f x) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "right_le_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\nprotected theorem right_le_sup (f g : «expr →ₗ.[ ] » E R F)\n    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : g ≤ f.sup g h :=\n  by\n  refine' ⟨le_sup_right, fun z₁ z₂ hz => _⟩\n  rw [← zero_add (g _), ← f.map_zero]\n  refine' (sup_apply h _ _ _ _).symm\n  simpa\n#align right_le_sup right_le_sup\n\n",
 "neg_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The graph of `-f` as a pushforward. -/\ntheorem neg_graph (f : «expr →ₗ.[ ] » E R F) :\n    (-f).graph =\n      f.graph.map ((linear_map.id : «expr →ₗ[ ] » E R E).prod_map (-(linear_map.id : «expr →ₗ[ ] » F R F))) :=\n  by\n  ext; cases x\n  constructor <;> intro h\n  · rw [mem_graph_iff] at h\n    rcases h with ⟨y, hy, h⟩\n    rw [linear_pmap.neg_apply] at h\n    rw [submodule.mem_map]\n    simp only [mem_graph_iff, linear_map.prod_map_apply, linear_map.id_coe, id.def, linear_map.neg_apply,\n      prod.mk.inj_iff, prod.exists, exists_exists_and_eq_and]\n    use x_fst, y\n    simp [hy, h]\n  rw [submodule.mem_map] at h\n  rcases h with ⟨x', hx', h⟩\n  cases x'\n  simp only [linear_map.prod_map_apply, linear_map.id_coe, id.def, linear_map.neg_apply, prod.mk.inj_iff] at h\n  rw [mem_graph_iff] at hx'⊢\n  rcases hx' with ⟨y, hy, hx'⟩\n  use y\n  rw [← h.1, ← h.2]\n  simp [hy, hx']\n#align neg_graph neg_graph\n\n",
 "neg_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n@[simp]\ntheorem neg_apply (f : «expr →ₗ.[ ] » E R F) (x) : (-f) x = -f x :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mk_span_singleton_apply":
 "theorem mk_span_singleton_apply (K : Type _) {E F : Type _} [DivisionRing K] [add_comm_group E] [Module K E]\n    [add_comm_group F] [Module K F] {x : E} (hx : x ≠ 0) (y : F) :\n    mk_span_singleton x y hx ⟨x, (submodule.mem_span_singleton_self x : x ∈ submodule.span K {x})⟩ = y :=\n  linear_pmap.mk_span_singleton'_apply_self _ _ _ _\n#align mk_span_singleton_apply mk_span_singleton_apply\n\n",
 "mk_span_singleton'_apply_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk_span_singleton'_apply_self (x : E) (y : F) (H : ∀ c : R, «expr • » c x = 0 → «expr • » c y = 0) (h) :\n    mk_span_singleton' x y H ⟨x, h⟩ = y := by convert mk_span_singleton'_apply x y H 1 _ <;> rwa [one_smul]\n#align mk_span_singleton'_apply_self mk_span_singleton'_apply_self\n\n",
 "mk_span_singleton'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mk_span_singleton'_apply (x : E) (y : F) (H : ∀ c : R, «expr • » c x = 0 → «expr • » c y = 0) (c : R) (h) :\n    mk_span_singleton' x y H ⟨«expr • » c x, h⟩ = «expr • » c y :=\n  by\n  dsimp [mk_span_singleton']\n  rw [← sub_eq_zero, ← sub_smul]\n  apply H\n  simp only [sub_smul, one_smul, sub_eq_zero]\n  apply Classical.choose_spec (mem_span_singleton.1 h)\n#align mk_span_singleton'_apply mk_span_singleton'_apply\n\n",
 "mk_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem mk_apply (p : submodule R E) (f : «expr →ₗ[ ] » p R F) (x : p) : mk p f x = f x :=\n  rfl\n#align mk_apply mk_apply\n\n",
 "mem_range_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_range_iff {f : «expr →ₗ.[ ] » E R F} {y : F} : y ∈ Set.range f ↔ ∃ x : E, (x, y) ∈ f.graph :=\n  by\n  constructor <;> intro h\n  · rw [Set.mem_range] at h\n    rcases h with ⟨⟨x, hx⟩, h⟩\n    use x\n    rw [← h]\n    exact f.mem_graph ⟨x, hx⟩\n  cases' h with x h\n  rw [mem_graph_iff] at h\n  cases' h with x h\n  rw [Set.mem_range]\n  use x\n  simp only at h\n  rw [h.2]\n#align mem_range_iff mem_range_iff\n\n",
 "mem_graph_to_linear_pmap":
 "theorem mem_graph_to_linear_pmap (g : submodule R (E × F))\n    (hg : ∀ (x : E × F) (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) (x : g.map (linear_map.fst R E F)) :\n    (x.val, g.to_linear_pmap hg x) ∈ g :=\n  val_from_graph_mem hg x.2\n#align mem_graph_to_linear_pmap mem_graph_to_linear_pmap\n\n",
 "mem_graph_snd_inj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_graph_snd_inj' (f : «expr →ₗ.[ ] » E R F) {x y : E × F} (hx : x ∈ f.graph) (hy : y ∈ f.graph)\n    (hxy : x.1 = y.1) : x.2 = y.2 := by\n  cases x\n  cases y\n  exact f.mem_graph_snd_inj hx hy hxy\n#align mem_graph_snd_inj' mem_graph_snd_inj'\n\n",
 "mem_graph_snd_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_graph_snd_inj (f : «expr →ₗ.[ ] » E R F) {x y : E} {x' y' : F} (hx : (x, x') ∈ f.graph)\n    (hy : (y, y') ∈ f.graph) (hxy : x = y) : x' = y' :=\n  by\n  rw [mem_graph_iff] at hx hy\n  rcases hx with ⟨x'', hx1, hx2⟩\n  rcases hy with ⟨y'', hy1, hy2⟩\n  simp only at hx1 hx2 hy1 hy2\n  rw [← hx1, ← hy1, SetLike.coe_eq_coe] at hxy\n  rw [← hx2, ← hy2, hxy]\n#align mem_graph_snd_inj mem_graph_snd_inj\n\n",
 "mem_graph_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_graph_iff' (f : «expr →ₗ.[ ] » E R F) {x : E × F} : x ∈ f.graph ↔ ∃ y : f.domain, (↑y, f y) = x := by\n  simp [graph]\n#align mem_graph_iff' mem_graph_iff'\n\n",
 "mem_graph_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n@[simp]\ntheorem mem_graph_iff (f : «expr →ₗ.[ ] » E R F) {x : E × F} :\n    x ∈ f.graph ↔ ∃ y : f.domain, (↑y : E) = x.1 ∧ f y = x.2 :=\n  by\n  cases x\n  simp_rw [mem_graph_iff', prod.mk.inj_iff]\n#align mem_graph_iff mem_graph_iff\n\n",
 "mem_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- The tuple `(x, f x)` is contained in the graph of `f`. -/\ntheorem mem_graph (f : «expr →ₗ.[ ] » E R F) (x : domain f) : ((x : E), f x) ∈ f.graph := by simp\n#align mem_graph mem_graph\n\n",
 "mem_domain_of_mem_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_domain_of_mem_graph {f : «expr →ₗ.[ ] » E R F} {x : E} {y : F} (h : (x, y) ∈ f.graph) : x ∈ f.domain :=\n  by\n  rw [mem_domain_iff]\n  exact ⟨y, h⟩\n#align mem_domain_of_mem_graph mem_domain_of_mem_graph\n\n",
 "mem_domain_iff_of_eq_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_domain_iff_of_eq_graph {f g : «expr →ₗ.[ ] » E R F} (h : f.graph = g.graph) {x : E} :\n    x ∈ f.domain ↔ x ∈ g.domain := by simp_rw [mem_domain_iff, h]\n#align mem_domain_iff_of_eq_graph mem_domain_iff_of_eq_graph\n\n",
 "mem_domain_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem mem_domain_iff {f : «expr →ₗ.[ ] » E R F} {x : E} : x ∈ f.domain ↔ ∃ y : F, (x, y) ∈ f.graph :=\n  by\n  constructor <;> intro h\n  · use f ⟨x, h⟩\n    exact f.mem_graph ⟨x, h⟩\n  cases' h with y h\n  rw [mem_graph_iff] at h\n  cases' h with x' h\n  simp only at h\n  rw [← h.1]\n  simp\n#align mem_domain_iff mem_domain_iff\n\n",
 "map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print map_zero /-\n@[simp]\ntheorem map_zero (f : «expr →ₗ.[ ] » E R F) : f 0 = 0 :=\n  f.to_fun.map_zero\n#align map_zero map_zero\n-/\n\n",
 "map_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print map_sub /-\ntheorem map_sub (f : «expr →ₗ.[ ] » E R F) (x y : f.domain) : f (x - y) = f x - f y :=\n  f.to_fun.map_sub x y\n#align map_sub map_sub\n-/\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_smul (f : «expr →ₗ.[ ] » E R F) (c : R) (x : f.domain) : f («expr • » c x) = «expr • » c (f x) :=\n  f.to_fun.map_smul c x\n#align map_smul map_smul\n\n",
 "map_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print map_neg /-\ntheorem map_neg (f : «expr →ₗ.[ ] » E R F) (x : f.domain) : f (-x) = -f x :=\n  f.to_fun.map_neg x\n#align map_neg map_neg\n-/\n\n",
 "map_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print map_add /-\ntheorem map_add (f : «expr →ₗ.[ ] » E R F) (x y : f.domain) : f (x + y) = f x + f y :=\n  f.to_fun.map_add x y\n#align map_add map_add\n-/\n\n",
 "left_le_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\nprotected theorem left_le_sup (f g : «expr →ₗ.[ ] » E R F)\n    (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) : f ≤ f.sup g h :=\n  by\n  refine' ⟨le_sup_left, fun z₁ z₂ hz => _⟩\n  rw [← add_zero (f _), ← g.map_zero]\n  refine' (sup_apply h _ _ _ _).symm\n  simpa\n#align left_le_sup left_le_sup\n\n",
 "le_supₛ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n#print le_supₛ /-\nprotected theorem le_supₛ {c : set («expr →ₗ.[ ] » E R F)} (hc : DirectedOn (· ≤ ·) c) {f : «expr →ₗ.[ ] » E R F}\n    (hf : f ∈ c) : f ≤ linear_pmap.Sup c hc :=\n  Classical.choose_spec (Sup_aux c hc) hf\n#align le_Sup le_supₛ\n-/\n\n",
 "le_of_le_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem le_of_le_graph {f g : «expr →ₗ.[ ] » E R F} (h : f.graph ≤ g.graph) : f ≤ g :=\n  by\n  constructor\n  · intro x hx\n    rw [mem_domain_iff] at hx⊢\n    cases' hx with y hx\n    use y\n    exact h hx\n  rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n  rw [image_iff]\n  refine' h _\n  simp only [submodule.coe_mk] at hxy\n  rw [hxy] at hx\n  rw [← image_iff hx]\n  simp [hxy]\n#align le_of_le_graph le_of_le_graph\n\n",
 "le_of_eq_locus_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem le_of_eq_locus_ge {f g : «expr →ₗ.[ ] » E R F} (H : f.domain ≤ f.eq_locus g) : f ≤ g :=\n  suffices f ≤ «expr ⊓ » f g from le_trans this inf_le_right\n  ⟨H, fun x y hxy => ((inf_le_left : «expr ⊓ » f g ≤ f).2 hxy.symm).symm⟩\n#align le_of_eq_locus_ge le_of_eq_locus_ge\n\n",
 "le_graph_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem le_graph_of_le {f g : «expr →ₗ.[ ] » E R F} (h : f ≤ g) : f.graph ≤ g.graph :=\n  by\n  intro x hx\n  rw [mem_graph_iff] at hx⊢\n  cases' hx with y hx\n  use y\n  · exact h.1 y.2\n  simp only [hx, submodule.coe_mk, eq_self_iff_true, true_and_iff]\n  convert hx.2\n  refine' (h.2 _).symm\n  simp only [hx.1, submodule.coe_mk]\n#align le_graph_of_le le_graph_of_le\n\n",
 "le_graph_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem le_graph_iff {f g : «expr →ₗ.[ ] » E R F} : f.graph ≤ g.graph ↔ f ≤ g :=\n  ⟨le_of_le_graph, le_graph_of_le⟩\n#align le_graph_iff le_graph_iff\n\n",
 "image_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem image_iff {f : «expr →ₗ.[ ] » E R F} {x : E} {y : F} (hx : x ∈ f.domain) : y = f ⟨x, hx⟩ ↔ (x, y) ∈ f.graph :=\n  by\n  rw [mem_graph_iff]\n  constructor <;> intro h\n  · use ⟨x, hx⟩\n    simp [h]\n  rcases h with ⟨⟨x', hx'⟩, ⟨h1, h2⟩⟩\n  simp only [submodule.coe_mk] at h1 h2\n  simp only [← h2, h1]\n#align image_iff image_iff\n\n",
 "graph_fst_eq_zero_snd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/-- The property that `f 0 = 0` in terms of the graph. -/\ntheorem graph_fst_eq_zero_snd (f : «expr →ₗ.[ ] » E R F) {x : E} {x' : F} (h : (x, x') ∈ f.graph) (hx : x = 0) :\n    x' = 0 :=\n  f.mem_graph_snd_inj h f.graph.zero_mem hx\n#align graph_fst_eq_zero_snd graph_fst_eq_zero_snd\n\n",
 "fst_apply":
 "@[simp]\ntheorem fst_apply (p : submodule R E) (p' : submodule R F) (x : p.prod p') : linear_pmap.fst p p' x = (x : E × F).1 :=\n  rfl\n#align fst_apply fst_apply\n\n",
 "ext_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem ext_iff {f g : «expr →ₗ.[ ] » E R F} :\n    f = g ↔ ∃ domain_eq : f.domain = g.domain, ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (h : (x : E) = y), f x = g y :=\n  ⟨fun EQ =>\n    EQ ▸\n      ⟨rfl, fun x y h => by\n        congr\n        exact_mod_cast h⟩,\n    fun ⟨deq, feq⟩ => ext deq feq⟩\n#align ext_iff ext_iff\n\n",
 "ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem ext' {s : submodule R E} {f g : «expr →ₗ[ ] » s R F} (h : f = g) : mk s f = mk s g :=\n  h ▸ rfl\n#align ext' ext'\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n@[ext]\ntheorem ext {f g : «expr →ₗ.[ ] » E R F} (h : f.domain = g.domain)\n    (h' : ∀ ⦃x : f.domain⦄ ⦃y : g.domain⦄ (h : (x : E) = y), f x = g y) : f = g :=\n  by\n  rcases f with ⟨f_dom, f⟩\n  rcases g with ⟨g_dom, g⟩\n  obtain rfl : f_dom = g_dom := h\n  obtain rfl : f = g := linear_map.ext fun x => h' rfl\n  rfl\n#align ext ext\n\n",
 "exists_unique_from_graph":
 "theorem exists_unique_from_graph {g : submodule R (E × F)}\n    (hg : ∀ {x : E × F} (hx : x ∈ g) (hx' : x.fst = 0), x.snd = 0) {a : E} (ha : a ∈ g.map (linear_map.fst R E F)) :\n    ∃! b : F, (a, b) ∈ g := by\n  refine' exists_unique_of_exists_of_unique _ _\n  · convert ha\n    simp\n  intro y₁ y₂ hy₁ hy₂\n  have hy : ((0 : E), y₁ - y₂) ∈ g := by\n    convert g.sub_mem hy₁ hy₂\n    exact (sub_self _).symm\n  exact sub_eq_zero.mp (hg hy (by simp))\n#align exists_unique_from_graph exists_unique_from_graph\n\n",
 "exists_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem exists_of_le {T S : «expr →ₗ.[ ] » E R F} (h : T ≤ S) (x : T.domain) :\n    ∃ y : S.domain, (x : E) = y ∧ T x = S y :=\n  ⟨⟨x.1, h.1 x.2⟩, ⟨rfl, h.2 rfl⟩⟩\n#align exists_of_le exists_of_le\n\n",
 "eq_of_le_of_domain_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem eq_of_le_of_domain_eq {f g : «expr →ₗ.[ ] » E R F} (hle : f ≤ g) (heq : f.domain = g.domain) : f = g :=\n  ext HEq hle.2\n#align eq_of_le_of_domain_eq eq_of_le_of_domain_eq\n\n",
 "eq_of_eq_graph":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem eq_of_eq_graph {f g : «expr →ₗ.[ ] » E R F} (h : f.graph = g.graph) : f = g :=\n  by\n  ext\n  exact mem_domain_iff_of_eq_graph h\n  exact (le_of_le_graph h.le).2\n#align eq_of_eq_graph eq_of_eq_graph\n\n",
 "domain_sup_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n@[simp]\ntheorem domain_sup_span_singleton (f : «expr →ₗ.[ ] » E K F) (x : E) (y : F) (hx : x ∉ f.domain) :\n    (f.sup_span_singleton x y hx).domain = «expr ⊔ » f.domain («expr ∙ » K x) :=\n  rfl\n#align domain_sup_span_singleton domain_sup_span_singleton\n\n",
 "domain_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem domain_sup (f g : «expr →ₗ.[ ] » E R F) (h : ∀ (x : f.domain) (y : g.domain), (x : E) = y → f x = g y) :\n    (f.sup g h).domain = «expr ⊔ » f.domain g.domain :=\n  rfl\n#align domain_sup domain_sup\n\n",
 "domain_mono":
 "theorem domain_mono : strict_mono (@domain R _ E _ _ F _ _) := fun f g hlt =>\n  lt_of_le_of_ne hlt.1.1 fun heq => ne_of_lt hlt <| eq_of_le_of_domain_eq (le_of_lt hlt) HEq\n#align domain_mono domain_mono\n\n",
 "domain_mk_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n@[simp]\ntheorem domain_mk_span_singleton (x : E) (y : F) (H : ∀ c : R, «expr • » c x = 0 → «expr • » c y = 0) :\n    (mk_span_singleton' x y H).domain = «expr ∙ » R x :=\n  rfl\n#align domain_mk_span_singleton domain_mk_span_singleton\n\n",
 "dom_restrict_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem dom_restrict_le {f : «expr →ₗ.[ ] » E R F} {S : submodule R E} : f.dom_restrict S ≤ f :=\n  ⟨by simp, fun x y hxy => dom_restrict_apply hxy⟩\n#align dom_restrict_le dom_restrict_le\n\n",
 "dom_restrict_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem dom_restrict_domain (f : «expr →ₗ.[ ] » E R F) {S : submodule R E} :\n    (f.dom_restrict S).domain = «expr ⊓ » S f.domain :=\n  rfl\n#align dom_restrict_domain dom_restrict_domain\n\n",
 "dom_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem dom_restrict_apply {f : «expr →ₗ.[ ] » E R F} {S : submodule R E} ⦃x : «expr ⊓ » S f.domain⦄ ⦃y : f.domain⦄\n    (h : (x : E) = y) : f.dom_restrict S x = f y :=\n  by\n  have : submodule.of_le (by simp) x = y := by\n    ext\n    simp [h]\n  rw [← this]\n  exact linear_pmap.mk_apply _ _ _\n#align dom_restrict_apply dom_restrict_apply\n\n",
 "coprod_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n@[simp]\ntheorem coprod_apply (f : «expr →ₗ.[ ] » E R G) (g : «expr →ₗ.[ ] » F R G) (x) :\n    f.coprod g x = f ⟨(x : E × F).1, x.2.1⟩ + g ⟨(x : E × F).2, x.2.2⟩ :=\n  rfl\n#align coprod_apply coprod_apply\n\n",
 "comp_pmap_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n@[simp]\ntheorem comp_pmap_apply (g : «expr →ₗ[ ] » F R G) (f : «expr →ₗ.[ ] » E R F) (x) : g.comp_pmap f x = g (f x) :=\n  rfl\n#align comp_pmap_apply comp_pmap_apply\n\n",
 "coe_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp]\ntheorem coe_vadd (f : «expr →ₗ[ ] » E R F) (g : «expr →ₗ.[ ] » E R F) :\n    «expr⇑ » («expr +ᵥ » f g) = f.comp g.domain.subtype + g :=\n  rfl\n#align coe_vadd coe_vadd\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul (a : M) (f : «expr →ₗ.[ ] » E R F) : «expr⇑ » («expr • » a f) = «expr • » a f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "apply_comp_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\ntheorem apply_comp_of_le {T S : «expr →ₗ.[ ] » E R F} (h : T ≤ S) (x : T.domain) : T x = S (submodule.of_le h.1 x) :=\n  h.2 rfl\n#align apply_comp_of_le apply_comp_of_le\n\n",
 "Sup_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ.[ ] » -/\nprivate theorem Sup_aux (c : set («expr →ₗ.[ ] » E R F)) (hc : DirectedOn (· ≤ ·) c) :\n    ∃ f : «expr →ₗ[ ] » («expr↥ » (supₛ («expr '' » domain c))) R F, (⟨_, f⟩ : «expr →ₗ.[ ] » E R F) ∈ upperBounds c :=\n  by\n  cases' c.eq_empty_or_nonempty with ceq cne\n  · subst c\n    simp\n  have hdir : DirectedOn (· ≤ ·) («expr '' » domain c) := directedOn_image.2 (hc.mono domain_mono.monotone)\n  have P : ∀ x : Sup («expr '' » domain c), { p : c // (x : E) ∈ p.val.domain } :=\n    by\n    rintro x\n    apply classical.indefinite_description\n    have := (mem_Sup_of_directed (cne.image _) hdir).1 x.2\n    rwa [bex_image_iff, SetCoe.exists'] at this\n  set f : Sup («expr '' » domain c) → F := fun x => (P x).val.val ⟨x, (P x).property⟩\n  have f_eq : ∀ (p : c) (x : Sup («expr '' » domain c)) (y : p.1.1) (hxy : (x : E) = y), f x = p.1 y :=\n    by\n    intro p x y hxy\n    rcases hc (P x).1.1 (P x).1.2 p.1 p.2 with ⟨q, hqc, hxq, hpq⟩\n    refine' (hxq.2 _).trans (hpq.2 _).symm\n    exacts[of_le hpq.1 y, hxy, rfl]\n  refine' ⟨{ to_fun := f.. }, _⟩\n  · intro x y\n    rcases hc (P x).1.1 (P x).1.2 (P y).1.1 (P y).1.2 with ⟨p, hpc, hpx, hpy⟩\n    set x' := of_le hpx.1 ⟨x, (P x).2⟩\n    set y' := of_le hpy.1 ⟨y, (P y).2⟩\n    rw [f_eq ⟨p, hpc⟩ x x' rfl, f_eq ⟨p, hpc⟩ y y' rfl, f_eq ⟨p, hpc⟩ (x + y) (x' + y') rfl, map_add]\n  · intro c x\n    simp [f_eq (P x).1 («expr • » c x) («expr • » c ⟨x, (P x).2⟩) rfl, ← map_smul]\n  · intro p hpc\n    refine' ⟨le_supₛ <| mem_image_of_mem domain hpc, fun x y hxy => eq.symm _⟩\n    exact f_eq ⟨p, hpc⟩ _ _ hxy.symm\n#align Sup_aux Sup_aux\n\n"}