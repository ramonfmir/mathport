{"prod":
 "theorem pos_def.prod {R} [OrderedRing R] [Module R M₁] [Module R M₂] {Q₁ : quadratic_form R M₁}\n    {Q₂ : quadratic_form R M₂} (h₁ : Q₁.pos_def) (h₂ : Q₂.pos_def) : (Q₁.prod Q₂).pos_def :=\n  pos_def_prod_iff.mpr ⟨h₁, h₂⟩\n#align pos_def.prod pos_def.prod\n\n",
 "pos_def_prod_iff":
 "theorem pos_def_prod_iff {R} [OrderedRing R] [Module R M₁] [Module R M₂] {Q₁ : quadratic_form R M₁}\n    {Q₂ : quadratic_form R M₂} : (Q₁.prod Q₂).pos_def ↔ Q₁.pos_def ∧ Q₂.pos_def :=\n  by\n  simp_rw [pos_def_iff_nonneg, nonneg_prod_iff]\n  constructor\n  · rintro ⟨⟨hle₁, hle₂⟩, ha⟩\n    obtain ⟨ha₁, ha₂⟩ := anisotropic_of_prod ha\n    refine' ⟨⟨hle₁, ha₁⟩, ⟨hle₂, ha₂⟩⟩\n  · rintro ⟨⟨hle₁, ha₁⟩, ⟨hle₂, ha₂⟩⟩\n    refine' ⟨⟨hle₁, hle₂⟩, _⟩\n    rintro ⟨x₁, x₂⟩ (hx : Q₁ x₁ + Q₂ x₂ = 0)\n    rw [add_eq_zero_iff' (hle₁ x₁) (hle₂ x₂), ha₁.eq_zero_iff, ha₂.eq_zero_iff] at hx\n    rwa [Prod.mk_eq_zero]\n#align pos_def_prod_iff pos_def_prod_iff\n\n",
 "pos_def_pi_iff":
 "theorem pos_def_pi_iff [Fintype ι] {R} [OrderedRing R] [∀ i, Module R (Mᵢ i)] {Q : ∀ i, quadratic_form R (Mᵢ i)} :\n    (pi Q).pos_def ↔ ∀ i, (Q i).pos_def :=\n  by\n  simp_rw [pos_def_iff_nonneg, nonneg_pi_iff]\n  constructor\n  · rintro ⟨hle, ha⟩\n    intro i\n    exact ⟨hle i, anisotropic_of_pi ha i⟩\n  · intro h\n    refine' ⟨fun i => (h i).1, fun x hx => funext fun i => (h i).2 _ _⟩\n    rw [pi_apply, Finset.sum_eq_zero_iff_of_nonneg fun j hj => _] at hx\n    · exact hx _ (Finset.mem_univ _)\n    exact (h j).1 _\n#align pos_def_pi_iff pos_def_pi_iff\n\n",
 "pi_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem pi_apply [Fintype ι] (Q : ∀ i, quadratic_form R (Mᵢ i)) (x : ∀ i, Mᵢ i) :\n    pi Q x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (Q i (x i)) :=\n  sum_apply _ _ _\n#align pi_apply pi_apply\n\n",
 "pi":
 "theorem equivalent.pi [Fintype ι] {Q : ∀ i, quadratic_form R (Mᵢ i)} {Q' : ∀ i, quadratic_form R (Nᵢ i)}\n    (e : ∀ i, (Q i).equivalent (Q' i)) : (pi Q).equivalent (pi Q') :=\n  ⟨isometry.pi fun i => Classical.choice (e i)⟩\n#align equivalent.pi equivalent.pi\n\n",
 "nonneg_prod_iff":
 "theorem nonneg_prod_iff {R} [OrderedRing R] [Module R M₁] [Module R M₂] {Q₁ : quadratic_form R M₁}\n    {Q₂ : quadratic_form R M₂} : (∀ x, 0 ≤ (Q₁.prod Q₂) x) ↔ (∀ x, 0 ≤ Q₁ x) ∧ ∀ x, 0 ≤ Q₂ x :=\n  by\n  simp_rw [Prod.forall, prod_apply]\n  constructor\n  · intro h\n    constructor\n    · intro x\n      simpa only [add_zero, map_zero] using h x 0\n    · intro x\n      simpa only [zero_add, map_zero] using h 0 x\n  · rintro ⟨h₁, h₂⟩ x₁ x₂\n    exact add_nonneg (h₁ x₁) (h₂ x₂)\n#align nonneg_prod_iff nonneg_prod_iff\n\n",
 "nonneg_pi_iff":
 "theorem nonneg_pi_iff [Fintype ι] {R} [OrderedRing R] [∀ i, Module R (Mᵢ i)] {Q : ∀ i, quadratic_form R (Mᵢ i)} :\n    (∀ x, 0 ≤ pi Q x) ↔ ∀ i x, 0 ≤ Q i x :=\n  by\n  simp_rw [pi, sum_apply, comp_apply, LinearMap.proj_apply]\n  dsimp only\n  constructor\n  -- TODO: does this generalize to a useful lemma independent of `quadratic_form`?\n  · intro h i x\n    classical\n      convert h (Pi.single i x) using 1\n      rw [Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hji => _, Pi.single_eq_same]\n      rw [Pi.single_eq_of_ne hji, map_zero]\n  · rintro h x\n    exact Finset.sum_nonneg fun i hi => h i (x i)\n#align nonneg_pi_iff nonneg_pi_iff\n\n",
 "anisotropic_of_prod":
 "/-- If a product is anisotropic then its components must be. The converse is not true. -/\ntheorem anisotropic_of_prod {R} [OrderedRing R] [Module R M₁] [Module R M₂] {Q₁ : quadratic_form R M₁}\n    {Q₂ : quadratic_form R M₂} (h : (Q₁.prod Q₂).anisotropic) : Q₁.anisotropic ∧ Q₂.anisotropic :=\n  by\n  simp_rw [anisotropic, prod_apply, Prod.forall, Prod.mk_eq_zero] at h\n  constructor\n  · intro x hx\n    refine' (h x 0 _).1\n    rw [hx, zero_add, map_zero]\n  · intro x hx\n    refine' (h 0 x _).2\n    rw [hx, add_zero, map_zero]\n#align anisotropic_of_prod anisotropic_of_prod\n\n",
 "anisotropic_of_pi":
 "/-- If a family is anisotropic then its components must be. The converse is not true. -/\ntheorem anisotropic_of_pi [Fintype ι] {R} [OrderedRing R] [∀ i, Module R (Mᵢ i)] {Q : ∀ i, quadratic_form R (Mᵢ i)}\n    (h : (pi Q).anisotropic) : ∀ i, (Q i).anisotropic :=\n  by\n  simp_rw [anisotropic, pi_apply, Function.funext_iff, Pi.zero_apply] at h\n  intro i x hx\n  classical\n    have := h (Pi.single i x) _ i\n    · rw [Pi.single_eq_same] at this\n      exact this\n    apply Finset.sum_eq_zero\n    intro j _\n    by_cases hji : j = i\n    · subst hji\n      rw [Pi.single_eq_same, hx]\n    · rw [Pi.single_eq_of_ne hji, map_zero]\n#align anisotropic_of_pi anisotropic_of_pi\n\n"}