{"sub":
 "theorem is_adjoint_pair.sub (h : IsAdjointPair B B' f g) (h' : IsAdjointPair B B' f' g') :\n    IsAdjointPair B B' (f - f') (g - g') := fun x _ => by\n  rw [f.sub_apply, g.sub_apply, B'.map_sub₂, (B x).map_sub, h, h']\n#align is_adjoint_pair.sub is_adjoint_pair.sub\n\n",
 "span_singleton_sup_orthogonal_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n-- todo: Generalize this to sesquilinear maps\ntheorem span_singleton_sup_orthogonal_eq_top {B : «expr →ₗ[ ] » V K («expr →ₗ[ ] » V K K)} {x : V}\n    (hx : ¬B.is_ortho x x) : «expr ⊔ » («expr ∙ » K x) (Submodule.orthogonalBilin («expr ∙ » K x) B) = «expr⊤» :=\n  by\n  rw [orthogonal_span_singleton_eq_to_lin_ker]\n  exact (B x).span_singleton_sup_ker_eq_top hx\n#align span_singleton_sup_orthogonal_eq_top span_singleton_sup_orthogonal_eq_top\n\n",
 "span_singleton_inf_orthogonal_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- ↓ This lemma only applies in fields as we require `a * b = 0 → a = 0 ∨ b = 0`\ntheorem span_singleton_inf_orthogonal_eq_bot (B : «expr →ₛₗ[ ] » V₁ J₁ («expr →ₛₗ[ ] » V₁ J₁' K)) (x : V₁)\n    (hx : ¬B.is_ortho x x) : «expr ⊓ » («expr ∙ » K₁ x) (Submodule.orthogonalBilin («expr ∙ » K₁ x) B) = «expr⊥» :=\n  by\n  rw [← Finset.coe_singleton]\n  refine' eq_bot_iff.2 fun y h => _\n  rcases mem_span_finset.1 h.1 with ⟨μ, rfl⟩\n  have := h.2 x _\n  · rw [Finset.sum_singleton] at this⊢\n    suffices hμzero : μ x = 0\n    · rw [hμzero, zero_smul, Submodule.mem_bot]\n    change B x («expr • » (μ x) x) = 0 at this\n    rw [map_smulₛₗ, smul_eq_mul] at this\n    exact\n      or.elim (zero_eq_mul.mp this.symm)\n        (fun y => by\n          simp at y\n          exact y)\n        fun hfalse => false.elim <| hx hfalse\n  · rw [Submodule.mem_span] <;> exact fun _ hp => hp <| Finset.mem_singleton_self _\n#align span_singleton_inf_orthogonal_eq_bot span_singleton_inf_orthogonal_eq_bot\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_adjoint_pair.smul (c : R) (h : IsAdjointPair B B' f g) :\n    IsAdjointPair B B' («expr • » c f) («expr • » c g) := fun _ _ => by\n  simp only [smul_apply, map_smul, smul_eq_mul, h _ _]\n#align is_adjoint_pair.smul is_adjoint_pair.smul\n\n",
 "separating_right_iff_not_is_ortho_basis_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Given an orthogonal basis with respect to a bilinear form, the bilinear form is right-separating\nif the basis has no elements which are self-orthogonal. -/\ntheorem is_Ortho.separating_right_iff_not_is_ortho_basis_self [NoZeroDivisors R]\n    {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} (v : Basis n R M) (hO : B.is_Ortho v)\n    (h : ∀ i, ¬B.is_ortho (v i) (v i)) : B.separating_right :=\n  by\n  rw [is_Ortho_flip] at hO\n  rw [← flip_separating_left]\n  refine' is_Ortho.separating_left_of_not_is_ortho_basis_self v hO fun i => _\n  rw [is_ortho_flip]\n  exact h i\n#align is_Ortho.separating_right_iff_not_is_ortho_basis_self is_Ortho.separating_right_iff_not_is_ortho_basis_self\n\n",
 "separating_right_iff_linear_flip_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem separating_right_iff_linear_flip_nontrivial {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.separating_right ↔ ∀ y : M₂, B.flip y = 0 → y = 0 := by\n  rw [← flip_separating_left, separating_left_iff_linear_nontrivial]\n#align separating_right_iff_linear_flip_nontrivial separating_right_iff_linear_flip_nontrivial\n\n",
 "separating_right_iff_flip_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A bilinear form is right-separating if and only if its flip has a trivial kernel. -/\ntheorem separating_right_iff_flip_ker_eq_bot {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.separating_right ↔ B.flip.ker = «expr⊥» := by rw [← flip_separating_left, separating_left_iff_ker_eq_bot]\n#align separating_right_iff_flip_ker_eq_bot separating_right_iff_flip_ker_eq_bot\n\n",
 "separating_left_of_not_is_ortho_basis_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Given an orthogonal basis with respect to a bilinear form, the bilinear form is left-separating\nif the basis has no elements which are self-orthogonal. -/\ntheorem is_Ortho.separating_left_of_not_is_ortho_basis_self [NoZeroDivisors R]\n    {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} (v : Basis n R M) (hO : B.is_Ortho v)\n    (h : ∀ i, ¬B.is_ortho (v i) (v i)) : B.separating_left :=\n  by\n  intro m hB\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [LinearEquiv.map_eq_zero_iff]\n  ext i\n  rw [Finsupp.zero_apply]\n  specialize hB (v i)\n  simp_rw [Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum, map_sum₂, map_smulₛₗ₂, smul_eq_mul] at hB\n  rw [Finset.sum_eq_single i] at hB\n  · exact eq_zero_of_ne_zero_of_mul_right_eq_zero (h i) hB\n  · intro j hj hij\n    convert MulZeroClass.mul_zero _ using 2\n    exact hO hij\n  · intro hi\n    convert MulZeroClass.zero_mul _ using 2\n    exact finsupp.not_mem_support_iff.mp hi\n#align is_Ortho.separating_left_of_not_is_ortho_basis_self is_Ortho.separating_left_of_not_is_ortho_basis_self\n\n",
 "separating_left_iff_linear_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem separating_left_iff_linear_nontrivial {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.separating_left ↔ ∀ x : M₁, B x = 0 → x = 0 :=\n  by\n  constructor <;> intro h x hB\n  · let h' := h x\n    simp only [hB, zero_apply, eq_self_iff_true, forall_const] at h'\n    exact h'\n  have h' : B x = 0 := by\n    ext\n    rw [zero_apply]\n    exact hB _\n  exact h x h'\n#align separating_left_iff_linear_nontrivial separating_left_iff_linear_nontrivial\n\n",
 "separating_left_iff_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A bilinear form is left-separating if and only if it has a trivial kernel. -/\ntheorem separating_left_iff_ker_eq_bot {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.separating_left ↔ B.ker = «expr⊥» :=\n  iff.trans separatingLeft_iff_linear_nontrivial LinearMap.ker_eq_bot'.symm\n#align separating_left_iff_ker_eq_bot separating_left_iff_ker_eq_bot\n\n",
 "separating_left_congr_iff":
 "@[simp]\ntheorem separating_left_congr_iff :\n    (e₁.arrow_congr (e₂.arrow_congr (LinearEquiv.refl R R)) B).separating_left ↔ B.separating_left :=\n  ⟨fun h => by\n    convert h.congr e₁.symm e₂.symm\n    ext (x y)\n    simp, SeparatingLeft.congr e₁ e₂⟩\n#align separating_left_congr_iff separating_left_congr_iff\n\n",
 "self_eq_zero":
 "theorem self_eq_zero (x) : B x x = 0 :=\n  H x\n#align self_eq_zero self_eq_zero\n\n",
 "orthogonal_span_singleton_eq_to_lin_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n-- ↓ This lemma only applies in fields since we use the `mul_eq_zero`\ntheorem orthogonal_span_singleton_eq_to_lin_ker {B : «expr →ₗ[ ] » V K («expr →ₛₗ[ ] » V J K)} (x : V) :\n    Submodule.orthogonalBilin («expr ∙ » K x) B = (B x).ker :=\n  by\n  ext y\n  simp_rw [Submodule.mem_orthogonalBilin_iff, LinearMap.mem_ker, Submodule.mem_span_singleton]\n  constructor\n  · exact fun h => h x ⟨1, one_smul _ _⟩\n  · rintro h _ ⟨z, rfl⟩\n    rw [is_ortho, map_smulₛₗ₂, smul_eq_zero]\n    exact Or.intro_right _ h\n#align orthogonal_span_singleton_eq_to_lin_ker orthogonal_span_singleton_eq_to_lin_ker\n\n",
 "orthogonal_bilin_le":
 "theorem orthogonal_bilin_le (h : N ≤ L) : L.orthogonal_bilin B ≤ N.orthogonal_bilin B := fun _ hn l hl => hn l (h hl)\n#align orthogonal_bilin_le orthogonal_bilin_le\n\n",
 "ortho_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- todo: this also holds for [comm_ring R] [is_domain R] when J₂ is invertible\ntheorem ortho_smul_right {B : «expr →ₛₗ[ ] » V₁ I₁ («expr →ₛₗ[ ] » V₂ I₂ K)} {x y} {a : K₂} {ha : a ≠ 0} :\n    IsOrtho B x y ↔ IsOrtho B x («expr • » a y) :=\n  by\n  dsimp only [is_ortho]\n  constructor <;> intro H\n  · rw [map_smulₛₗ, H, smul_zero]\n  · rw [map_smulₛₗ, smul_eq_zero] at H\n    cases H\n    · simp at H\n      exfalso\n      exact ha H\n    · exact H\n#align ortho_smul_right ortho_smul_right\n\n",
 "ortho_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- todo: this also holds for [comm_ring R] [is_domain R] when J₁ is invertible\ntheorem ortho_smul_left {B : «expr →ₛₗ[ ] » V₁ I₁ («expr →ₛₗ[ ] » V₂ I₂ K)} {x y} {a : K₁} (ha : a ≠ 0) :\n    IsOrtho B x y ↔ IsOrtho B («expr • » a x) y :=\n  by\n  dsimp only [is_ortho]\n  constructor <;> intro H\n  · rw [map_smulₛₗ₂, H, smul_zero]\n  · rw [map_smulₛₗ₂, smul_eq_zero] at H\n    cases H\n    · rw [map_eq_zero I₁] at H\n      trivial\n    · exact H\n#align ortho_smul_left ortho_smul_left\n\n",
 "ortho_comm":
 "theorem ortho_comm {x y} : IsOrtho B x y ↔ IsOrtho B y x :=\n  H.is_refl.ortho_comm\n#align ortho_comm ortho_comm\n\n",
 "not_separating_left_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem not_separating_left_zero [Nontrivial M₁] :\n    ¬(0 : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)).separating_left :=\n  let ⟨m, hm⟩ := exists_ne (0 : M₁)\n  fun h => hm (h m fun n => rfl)\n#align not_separating_left_zero not_separating_left_zero\n\n",
 "not_is_ortho_basis_self_of_separating_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- An orthogonal basis with respect to a right-separating bilinear form has no self-orthogonal\nelements. -/\ntheorem is_Ortho.not_is_ortho_basis_self_of_separating_right [Nontrivial R]\n    {B : «expr →ₛₗ[ ] » M I («expr →ₛₗ[ ] » M I' R)} {v : Basis n R M} (h : B.is_Ortho v) (hB : B.separating_right)\n    (i : n) : ¬B.is_ortho (v i) (v i) := by\n  rw [is_Ortho_flip] at h\n  rw [is_ortho_flip]\n  exact h.not_is_ortho_basis_self_of_separating_left (flip_separating_left.mpr hB) i\n#align is_Ortho.not_is_ortho_basis_self_of_separating_right is_Ortho.not_is_ortho_basis_self_of_separating_right\n\n",
 "not_is_ortho_basis_self_of_separating_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- An orthogonal basis with respect to a left-separating bilinear form has no self-orthogonal\nelements. -/\ntheorem is_Ortho.not_is_ortho_basis_self_of_separating_left [Nontrivial R]\n    {B : «expr →ₛₗ[ ] » M I («expr →ₛₗ[ ] » M I' R)} {v : Basis n R M} (h : B.is_Ortho v) (hB : B.separating_left)\n    (i : n) : ¬B.is_ortho (v i) (v i) := by\n  intro ho\n  refine' v.ne_zero i (hB (v i) fun m => _)\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum, map_sum]\n  apply Finset.sum_eq_zero\n  rintro j -\n  rw [map_smulₛₗ]\n  convert MulZeroClass.mul_zero _ using 2\n  obtain rfl | hij := eq_or_ne i j\n  · exact ho\n  · exact h hij\n#align is_Ortho.not_is_ortho_basis_self_of_separating_left is_Ortho.not_is_ortho_basis_self_of_separating_left\n\n",
 "nondegenerate_restrict_of_disjoint_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The restriction of a reflexive bilinear form `B` onto a submodule `W` is\nnondegenerate if `W` has trivial intersection with its orthogonal complement,\nthat is `disjoint W (W.orthogonal_bilin B)`. -/\ntheorem nondegenerate_restrict_of_disjoint_orthogonal {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} (hB : B.is_refl)\n    {W : Submodule R M} (hW : Disjoint W (W.orthogonal_bilin B)) : (B.dom_restrict₁₂ W W).nondegenerate :=\n  by\n  refine' (hB.dom_restrict_refl W).nondegenerate_of_separating_left _\n  rintro ⟨x, hx⟩ b₁\n  rw [Submodule.mk_eq_zero, ← Submodule.mem_bot R]\n  refine' hW.le_bot ⟨hx, fun y hy => _⟩\n  specialize b₁ ⟨y, hy⟩\n  simp_rw [dom_restrict₁₂_apply, Submodule.coe_mk] at b₁\n  rw [hB.ortho_comm]\n  exact b₁\n#align nondegenerate_restrict_of_disjoint_orthogonal nondegenerate_restrict_of_disjoint_orthogonal\n\n",
 "nondegenerate_of_separating_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_refl.nondegenerate_of_separating_right {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} (hB : B.is_refl)\n    (hB' : B.separating_right) : B.nondegenerate :=\n  by\n  refine' ⟨_, hB'⟩\n  rw [separating_left_iff_ker_eq_bot, hB.ker_eq_bot_iff_ker_flip_eq_bot.mpr]\n  rwa [← separating_right_iff_flip_ker_eq_bot]\n#align is_refl.nondegenerate_of_separating_right is_refl.nondegenerate_of_separating_right\n\n",
 "nondegenerate_of_separating_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_refl.nondegenerate_of_separating_left {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} (hB : B.is_refl)\n    (hB' : B.separating_left) : B.nondegenerate := by\n  refine' ⟨hB', _⟩\n  rw [separating_right_iff_flip_ker_eq_bot, hB.ker_eq_bot_iff_ker_flip_eq_bot.mp]\n  rwa [← separating_left_iff_ker_eq_bot]\n#align is_refl.nondegenerate_of_separating_left is_refl.nondegenerate_of_separating_left\n\n",
 "nondegenerate_of_not_is_ortho_basis_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Given an orthogonal basis with respect to a bilinear form, the bilinear form is nondegenerate\nif the basis has no elements which are self-orthogonal. -/\ntheorem is_Ortho.nondegenerate_of_not_is_ortho_basis_self [NoZeroDivisors R]\n    {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} (v : Basis n R M) (hO : B.is_Ortho v)\n    (h : ∀ i, ¬B.is_ortho (v i) (v i)) : B.nondegenerate :=\n  ⟨IsOrthoᵢ.separatingLeft_of_not_isOrtho_basis_self v hO h, IsOrthoᵢ.separatingRight_iff_not_isOrtho_basis_self v hO h⟩\n#align is_Ortho.nondegenerate_of_not_is_ortho_basis_self is_Ortho.nondegenerate_of_not_is_ortho_basis_self\n\n",
 "neg":
 "theorem neg (x y) : -B x y = B y x :=\n  by\n  have H1 : B (y + x) (y + x) = 0 := self_eq_zero H (y + x)\n  simp [map_add, self_eq_zero H] at H1\n  rw [add_eq_zero_iff_neg_eq] at H1\n  exact H1\n#align neg neg\n\n",
 "ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem separating_left.ne_zero [Nontrivial M₁] {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)}\n    (h : B.separating_left) : B ≠ 0 := fun h0 => not_separatingLeft_zero M₁ M₂ I₁ I₂ <| h0 ▸ h\n#align separating_left.ne_zero separating_left.ne_zero\n\n",
 "mul":
 "theorem is_adjoint_pair.mul {f g f' g' : Module.End R M} (h : IsAdjointPair B B f g) (h' : IsAdjointPair B B f' g') :\n    IsAdjointPair B B (f * f') (g' * g) :=\n  h'.comp h\n#align is_adjoint_pair.mul is_adjoint_pair.mul\n\n",
 "mem_skew_adjoint_submodule":
 "@[simp]\ntheorem mem_skew_adjoint_submodule (f : Module.End R M) : f ∈ B.skew_adjoint_submodule ↔ B.is_skew_adjoint f :=\n  by\n  rw [is_skew_adjoint_iff_neg_self_adjoint]\n  exact iff.rfl\n#align mem_skew_adjoint_submodule mem_skew_adjoint_submodule\n\n",
 "mem_self_adjoint_submodule":
 "@[simp]\ntheorem mem_self_adjoint_submodule (f : Module.End R M) : f ∈ B.self_adjoint_submodule ↔ B.is_self_adjoint f :=\n  iff.rfl\n#align mem_self_adjoint_submodule mem_self_adjoint_submodule\n\n",
 "mem_orthogonal_bilin_iff":
 "@[simp]\ntheorem mem_orthogonal_bilin_iff {m : M₁} : m ∈ N.orthogonal_bilin B ↔ ∀ n ∈ N, B.is_ortho n m :=\n  iff.rfl\n#align mem_orthogonal_bilin_iff mem_orthogonal_bilin_iff\n\n",
 "mem_is_pair_self_adjoint_submodule":
 "@[simp]\ntheorem mem_is_pair_self_adjoint_submodule (f : Module.End R M) :\n    f ∈ isPairSelfAdjointSubmodule B F ↔ IsPairSelfAdjoint B F f :=\n  iff.rfl\n#align mem_is_pair_self_adjoint_submodule mem_is_pair_self_adjoint_submodule\n\n",
 "linear_independent_of_is_Ortho":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-- A set of orthogonal vectors `v` with respect to some sesquilinear form `B` is linearly\n  independent if for all `i`, `B (v i) (v i) ≠ 0`. -/\ntheorem linear_independent_of_is_Ortho {B : «expr →ₛₗ[ ] » V₁ I₁ («expr →ₛₗ[ ] » V₁ I₁' K)} {v : n → V₁}\n    (hv₁ : B.is_Ortho v) (hv₂ : ∀ i, ¬B.is_ortho (v i) (v i)) : LinearIndependent K₁ v := by\n  classical\n    rw [linearIndependent_iff']\n    intro s w hs i hi\n    have : B (s.sum fun i : n => «expr • » (w i) (v i)) (v i) = 0 := by rw [hs, map_zero, zero_apply]\n    have hsum : (s.sum fun j : n => I₁ (w j) * B (v j) (v i)) = I₁ (w i) * B (v i) (v i) :=\n      by\n      apply Finset.sum_eq_single_of_mem i hi\n      intro j hj hij\n      rw [is_Ortho_def.1 hv₁ _ _ hij, MulZeroClass.mul_zero]\n    simp_rw [B.map_sum₂, map_smulₛₗ₂, smul_eq_mul, hsum] at this\n    apply (map_eq_zero I₁).mp\n    exact eq_zero_of_ne_zero_of_mul_right_eq_zero (hv₂ i) this\n#align linear_independent_of_is_Ortho linear_independent_of_is_Ortho\n\n",
 "le_orthogonal_bilin_orthogonal_bilin":
 "theorem le_orthogonal_bilin_orthogonal_bilin (b : B.is_refl) : N ≤ (N.orthogonal_bilin B).orthogonal_bilin B :=\n  fun n hn m hm => b _ _ (hm n hn)\n#align le_orthogonal_bilin_orthogonal_bilin le_orthogonal_bilin_orthogonal_bilin\n\n",
 "ker_flip_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_flip_eq_bot (H : B.is_refl) (h : B.ker = «expr⊥») : B.flip.ker = «expr⊥» :=\n  by\n  refine' ker_eq_bot'.mpr fun _ hx => ker_eq_bot'.mp h _ _\n  ext\n  exact H _ _ (LinearMap.congr_fun hx _)\n#align ker_flip_eq_bot ker_flip_eq_bot\n\n",
 "ker_eq_bot_iff_ker_flip_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot_iff_ker_flip_eq_bot (H : B.is_refl) : B.ker = «expr⊥» ↔ B.flip.ker = «expr⊥» :=\n  by\n  refine' ⟨ker_flip_eq_bot H, fun h => _⟩\n  exact (congr_arg _ B.flip_flip.symm).trans (ker_flip_eq_bot (flip_is_refl_iff.mpr H) h)\n#align ker_eq_bot_iff_ker_flip_eq_bot ker_eq_bot_iff_ker_flip_eq_bot\n\n",
 "is_symm_iff_eq_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_symm_iff_eq_flip {B : «expr →ₗ[ ] » M R («expr →ₗ[ ] » M R R)} : B.is_symm ↔ B = B.flip :=\n  by\n  constructor <;> intro h\n  · ext\n    rw [← h, flip_apply, RingHom.id_apply]\n  intro x y\n  conv_lhs => rw [h]\n  rw [flip_apply, RingHom.id_apply]\n#align is_symm_iff_eq_flip is_symm_iff_eq_flip\n\n",
 "is_skew_adjoint_iff_neg_self_adjoint":
 "theorem is_skew_adjoint_iff_neg_self_adjoint (f : Module.End R M) : B.is_skew_adjoint f ↔ IsAdjointPair (-B) B f f :=\n  show (∀ x y, B (f x) y = B x ((-f) y)) ↔ ∀ x y, B (f x) y = (-B) x (f y) by simp\n#align is_skew_adjoint_iff_neg_self_adjoint is_skew_adjoint_iff_neg_self_adjoint\n\n",
 "is_refl":
 "theorem is_refl : B.is_refl := by\n  intro x y h\n  rw [← neg H, h, neg_zero]\n#align is_refl is_refl\n\n",
 "is_pair_self_adjoint_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem is_pair_self_adjoint_equiv (e : «expr ≃ₗ[ ] » M₁ R M) (f : Module.End R M) :\n    IsPairSelfAdjoint B F f ↔ IsPairSelfAdjoint (B.compl₁₂ ↑e ↑e) (F.compl₁₂ ↑e ↑e) (e.symm.conj f) :=\n  by\n  have hₗ :\n    (F.compl₁₂ (↑e : «expr →ₗ[ ] » M₁ R M) (↑e : «expr →ₗ[ ] » M₁ R M)).comp (e.symm.conj f) =\n      (F.comp f).compl₁₂ (↑e : «expr →ₗ[ ] » M₁ R M) (↑e : «expr →ₗ[ ] » M₁ R M) :=\n    by\n    ext\n    simp only [LinearEquiv.symm_conj_apply, coe_comp, LinearEquiv.coe_coe, compl₁₂_apply, LinearEquiv.apply_symm_apply]\n  have hᵣ :\n    (B.compl₁₂ (↑e : «expr →ₗ[ ] » M₁ R M) (↑e : «expr →ₗ[ ] » M₁ R M)).compl₂ (e.symm.conj f) =\n      (B.compl₂ f).compl₁₂ (↑e : «expr →ₗ[ ] » M₁ R M) (↑e : «expr →ₗ[ ] » M₁ R M) :=\n    by\n    ext\n    simp only [LinearEquiv.symm_conj_apply, compl₂_apply, coe_comp, LinearEquiv.coe_coe, compl₁₂_apply,\n      LinearEquiv.apply_symm_apply]\n  have he : function.surjective («expr⇑ » (↑e : «expr →ₗ[ ] » M₁ R M) : M₁ → M) := e.surjective\n  simp_rw [is_pair_self_adjoint, is_adjoint_pair_iff_comp_eq_compl₂, hₗ, hᵣ, compl₁₂_inj he he]\n#align is_pair_self_adjoint_equiv is_pair_self_adjoint_equiv\n\n",
 "is_ortho_zero_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem is_ortho_zero_right (B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)) (x) : IsOrtho B x (0 : M₂) :=\n  map_zero (B x)\n#align is_ortho_zero_right is_ortho_zero_right\n\n",
 "is_ortho_zero_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem is_ortho_zero_left (B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)) (x) : IsOrtho B (0 : M₁) x :=\n  by\n  dsimp only [is_ortho]\n  rw [map_zero B, zero_apply]\n#align is_ortho_zero_left is_ortho_zero_left\n\n",
 "is_ortho_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem is_ortho_flip {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₁ I₁' R)} {x y} :\n    B.is_ortho x y ↔ B.flip.is_ortho y x := by simp_rw [is_ortho_def, flip_apply]\n#align is_ortho_flip is_ortho_flip\n\n",
 "is_ortho_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/-\nCopyright (c) 2018 Andreas Swerdlow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andreas Swerdlow\n-/\n-- the `ₗ` subscript variables are for special cases about linear (as opposed to semilinear) maps\ntheorem is_ortho_def {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} {x y} : B.is_ortho x y ↔ B x y = 0 :=\n  iff.rfl\n#align is_ortho_def is_ortho_def\n\n",
 "is_compl_span_singleton_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n-- todo: Generalize this to sesquilinear maps\n/-- Given a bilinear form `B` and some `x` such that `B x x ≠ 0`, the span of the singleton of `x`\n  is complement to its orthogonal complement. -/\ntheorem is_compl_span_singleton_orthogonal {B : «expr →ₗ[ ] » V K («expr →ₗ[ ] » V K K)} {x : V}\n    (hx : ¬B.is_ortho x x) : IsCompl («expr ∙ » K x) (Submodule.orthogonalBilin («expr ∙ » K x) B) :=\n  { disjoint := disjoint_iff.2 <| span_singleton_inf_orthogonal_eq_bot B x hx\n    codisjoint := codisjoint_iff.2 <| span_singleton_sup_orthogonal_eq_top hx }\n#align is_compl_span_singleton_orthogonal is_compl_span_singleton_orthogonal\n\n",
 "is_alt_iff_eq_neg_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem is_alt_iff_eq_neg_flip [NoZeroDivisors R] [CharZero R] {B : «expr →ₛₗ[ ] » M₁ I («expr →ₛₗ[ ] » M₁ I R)} :\n    B.is_alt ↔ B = -B.flip := by\n  constructor <;> intro h\n  · ext\n    simp_rw [neg_apply, flip_apply]\n    exact (h.neg _ _).symm\n  intro x\n  let h' := congr_fun₂ h x x\n  simp only [neg_apply, flip_apply, ← add_eq_zero_iff_eq_neg] at h'\n  exact add_self_eq_zero.mp h'\n#align is_alt_iff_eq_neg_flip is_alt_iff_eq_neg_flip\n\n",
 "is_adjoint_pair_zero":
 "theorem is_adjoint_pair_zero : IsAdjointPair B B' 0 0 := fun _ _ => by simp only [zero_apply, map_zero]\n#align is_adjoint_pair_zero is_adjoint_pair_zero\n\n",
 "is_adjoint_pair_iff_comp_eq_compl₂":
 "theorem is_adjoint_pair_iff_comp_eq_compl₂ : IsAdjointPair B B' f g ↔ B'.comp f = B.compl₂ g :=\n  by\n  constructor <;> intro h\n  · ext (x y)\n    rw [comp_apply, compl₂_apply]\n    exact h x y\n  · intro _ _\n    rw [← compl₂_apply, ← comp_apply, h]\n#align is_adjoint_pair_iff_comp_eq_compl₂ is_adjoint_pair_iff_comp_eq_compl₂\n\n",
 "is_adjoint_pair_id":
 "theorem is_adjoint_pair_id : IsAdjointPair B B 1 1 := fun x y => rfl\n#align is_adjoint_pair_id is_adjoint_pair_id\n\n",
 "is_Ortho_flip":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem is_Ortho_flip (B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₁ I₁' R)) {v : n → M₁} :\n    B.is_Ortho v ↔ B.flip.is_Ortho v := by\n  simp_rw [is_Ortho_def]\n  constructor <;> intro h i j hij\n  · rw [flip_apply]\n    exact h j i (ne.symm hij)\n  simp_rw [flip_apply] at h\n  exact h j i (ne.symm hij)\n#align is_Ortho_flip is_Ortho_flip\n\n",
 "is_Ortho_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem is_Ortho_def {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₁ I₁' R)} {v : n → M₁} :\n    B.is_Ortho v ↔ ∀ i j : n, i ≠ j → B (v i) (v j) = 0 :=\n  iff.rfl\n#align is_Ortho_def is_Ortho_def\n\n",
 "flip_separating_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem flip_separating_right {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.flip.separating_right ↔ B.separating_left :=\n  ⟨fun hB x hy => hB x hy, fun hB x hy => hB x hy⟩\n#align flip_separating_right flip_separating_right\n\n",
 "flip_separating_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem flip_separating_left {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.flip.separating_left ↔ SeparatingRight B := by rw [← flip_separating_right, flip_flip]\n#align flip_separating_left flip_separating_left\n\n",
 "flip_nondegenerate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem flip_nondegenerate {B : «expr →ₛₗ[ ] » M₁ I₁ («expr →ₛₗ[ ] » M₂ I₂ R)} :\n    B.flip.nondegenerate ↔ B.nondegenerate :=\n  iff.trans and_comm (and_congr flip_separatingRight flip_separatingLeft)\n#align flip_nondegenerate flip_nondegenerate\n\n",
 "flip_is_refl_iff":
 "@[simp]\ntheorem flip_is_refl_iff : B.flip.is_refl ↔ B.is_refl :=\n  ⟨fun h x y H => h y x ((B.flip_apply _ _).trans H), fun h x y => h y x⟩\n#align flip_is_refl_iff flip_is_refl_iff\n\n",
 "eq_zero":
 "theorem eq_zero : ∀ {x y}, B x y = 0 → B y x = 0 := fun x y => H x y\n#align eq_zero eq_zero\n\n",
 "dom_restrict_symm":
 "theorem dom_restrict_symm (H : B.is_symm) (p : Submodule R M) : (B.dom_restrict₁₂ p p).is_symm := fun _ _ =>\n  by\n  simp_rw [dom_restrict₁₂_apply]\n  exact H _ _\n#align dom_restrict_symm dom_restrict_symm\n\n",
 "dom_restrict_refl":
 "theorem dom_restrict_refl (H : B.is_refl) (p : Submodule R₁ M₁) : (B.dom_restrict₁₂ p p).is_refl := fun _ _ =>\n  by\n  simp_rw [dom_restrict₁₂_apply]\n  exact H _ _\n#align dom_restrict_refl dom_restrict_refl\n\n",
 "congr":
 "theorem separating_left.congr (h : B.separating_left) :\n    (e₁.arrow_congr (e₂.arrow_congr (LinearEquiv.refl R R)) B).separating_left :=\n  by\n  intro x hx\n  rw [← e₁.symm.map_eq_zero_iff]\n  refine' h (e₁.symm x) fun y => _\n  specialize hx (e₂ y)\n  simp only [LinearEquiv.arrowCongr_apply, LinearEquiv.symm_apply_apply, LinearEquiv.map_eq_zero_iff] at hx\n  exact hx\n#align separating_left.congr separating_left.congr\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_adjoint_pair.comp {f' : «expr →ₗ[ ] » M₁ R M₂} {g' : «expr →ₗ[ ] » M₂ R M₁} (h : IsAdjointPair B B' f g)\n    (h' : IsAdjointPair B' B'' f' g') : IsAdjointPair B B'' (f'.comp f) (g.comp g') := fun _ _ => by\n  rw [LinearMap.comp_apply, LinearMap.comp_apply, h', h]\n#align is_adjoint_pair.comp is_adjoint_pair.comp\n\n",
 "add":
 "theorem is_adjoint_pair.add (h : IsAdjointPair B B' f g) (h' : IsAdjointPair B B' f' g') :\n    IsAdjointPair B B' (f + f') (g + g') := fun x _ => by\n  rw [f.add_apply, g.add_apply, B'.map_add₂, (B x).map_add, h, h']\n#align is_adjoint_pair.add is_adjoint_pair.add\n\n",
 "Eq":
 "#print Eq /-\nprotected theorem Eq (H : B.is_symm) (x y) : I (B x y) = B y x :=\n  H x y\n#align eq Eq\n-/\n\n"}