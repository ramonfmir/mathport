{"lift_alternating_ι_multi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lift_alternating_ι_multi :\n    lift_alternating (ι_multi R) = (linear_map.id : «expr →ₗ[ ] » (exterior_algebra R M) R (exterior_algebra R M)) :=\n  by\n  ext v\n  dsimp\n  induction' v using clifford_algebra.left_induction with r x y hx hy x m hx\n  · rw [lift_alternating_algebra_map, ι_multi_zero_apply, algebra.algebra_map_eq_smul_one]\n  · rw [map_add, hx, hy]\n  ·\n    simp_rw [lift_alternating_ι_mul, ι_multi_succ_curry_left, lift_alternating_comp, linear_map.comp_apply,\n      linear_map.mul_left_apply, hx]\n#align lift_alternating_ι_multi lift_alternating_ι_multi\n\n",
 "lift_alternating_ι_mul":
 "theorem lift_alternating_ι_mul (f : ∀ i, alternating_map R M N (fin i)) (m : M) (x : exterior_algebra R M) :\n    lift_alternating f (ι R m * x) = lift_alternating (fun i => (f i.succ).curry_left m) x :=\n  by\n  dsimp [lift_alternating]\n  rw [foldl_mul, foldl_ι]\n  rfl\n#align lift_alternating_ι_mul lift_alternating_ι_mul\n\n",
 "lift_alternating_ι":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\n-- This instance can't be found where it's needed if we don't remind lean that it exists.\n-- when applied twice with the same `m`, this recursive step produces 0\n@[simp]\ntheorem lift_alternating_ι (f : ∀ i, alternating_map R M N (fin i)) (m : M) :\n    lift_alternating f (ι R m) =\n      f 1 («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  dsimp [lift_alternating]\n  rw [foldl_ι, linear_map.mk₂_apply, alternating_map.curry_left_apply_apply]\n  congr\n#align lift_alternating_ι lift_alternating_ι\n\n",
 "lift_alternating_one":
 "@[simp]\ntheorem lift_alternating_one (f : ∀ i, alternating_map R M N (fin i)) :\n    lift_alternating f (1 : exterior_algebra R M) = f 0 0 :=\n  by\n  dsimp [lift_alternating]\n  rw [foldl_one]\n#align lift_alternating_one lift_alternating_one\n\n",
 "lift_alternating_comp_ι_multi":
 "@[simp]\ntheorem lift_alternating_comp_ι_multi {n : ℕ} (f : ∀ i, alternating_map R M N (fin i)) :\n    (lift_alternating f).comp_alternating_map (ι_multi R n) = f n :=\n  alternating_map.ext <| lift_alternating_apply_ι_multi f\n#align lift_alternating_comp_ι_multi lift_alternating_comp_ι_multi\n\n",
 "lift_alternating_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n@[simp]\ntheorem lift_alternating_comp (g : «expr →ₗ[ ] » N R N') (f : ∀ i, alternating_map R M N (fin i)) :\n    (lift_alternating fun i => g.comp_alternating_map (f i)) = «expr ∘ₗ » g (lift_alternating f) :=\n  by\n  ext v\n  rw [linear_map.comp_apply]\n  induction' v using clifford_algebra.left_induction with r x y hx hy x m hx generalizing f\n  · rw [lift_alternating_algebra_map, lift_alternating_algebra_map, map_smul, linear_map.comp_alternating_map_apply]\n  · rw [map_add, map_add, map_add, hx, hy]\n  · rw [lift_alternating_ι_mul, lift_alternating_ι_mul, ← hx]\n    simp_rw [alternating_map.curry_left_comp_alternating_map]\n#align lift_alternating_comp lift_alternating_comp\n\n",
 "lift_alternating_apply_ι_multi":
 "@[simp]\ntheorem lift_alternating_apply_ι_multi {n : ℕ} (f : ∀ i, alternating_map R M N (fin i)) (v : fin n → M) :\n    lift_alternating f (ι_multi R n v) = f n v := by\n  rw [ι_multi_apply]\n  induction' n with n ih generalizing f v\n  · rw [list.of_fn_zero, List.prod_nil, lift_alternating_one, subsingleton.elim 0 v]\n  · rw [list.of_fn_succ, List.prod_cons, lift_alternating_ι_mul, ih, alternating_map.curry_left_apply_apply]\n    congr\n    exact matrix.cons_head_tail _\n#align lift_alternating_apply_ι_multi lift_alternating_apply_ι_multi\n\n",
 "lift_alternating_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem lift_alternating_algebra_map (f : ∀ i, alternating_map R M N (fin i)) (r : R) :\n    lift_alternating f (algebra_map _ (exterior_algebra R M) r) = «expr • » r (f 0 0) := by\n  rw [algebra.algebra_map_eq_smul_one, map_smul, lift_alternating_one]\n#align lift_alternating_algebra_map lift_alternating_algebra_map\n\n",
 "lhom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- To show that two linear maps from the exterior algebra agree, it suffices to show they agree on\nthe exterior powers.\n\nSee note [partially-applied ext lemmas] -/\n@[ext]\ntheorem lhom_ext ⦃f g : «expr →ₗ[ ] » (exterior_algebra R M) R N⦄\n    (h : ∀ i, f.comp_alternating_map (ι_multi R i) = g.comp_alternating_map (ι_multi R i)) : f = g :=\n  lift_alternating_equiv.symm.injective <| funext h\n#align lhom_ext lhom_ext\n\n"}