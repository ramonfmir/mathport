{"some_basis_orientation":
 "/-- `some_basis` gives a basis with the required orientation. -/\n@[simp]\ntheorem some_basis_orientation [nonempty ι] (x : orientation R M ι) (h : fintype.card ι = finrank R M) :\n    (x.some_basis h).orientation = x :=\n  basis.orientation_adjust_to_orientation _ _\n#align some_basis_orientation some_basis_orientation\n\n",
 "orientation_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- The orientation given by a basis derived using `units_smul`, in terms of the product of those\nunits. -/\ntheorem orientation_units_smul [nontrivial R] (e : basis ι R M) (w : ι → Units R) :\n    (e.units_smul w).orientation =\n      «expr • »\n        (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (w i))⁻¹\n        e.orientation :=\n  by\n  rw [basis.orientation, basis.orientation, smul_ray_of_ne_zero, ray_eq_iff, e.det.eq_smul_basis_det (e.units_smul w),\n    det_units_smul_self, Units.smul_def, smul_smul]\n  norm_cast\n  simp\n#align orientation_units_smul orientation_units_smul\n\n",
 "orientation_neg_single":
 "/-- Negating a single basis vector (represented using `units_smul`) negates the corresponding\norientation. -/\n@[simp]\ntheorem orientation_neg_single [nontrivial R] (e : basis ι R M) (i : ι) :\n    (e.units_smul (function.update 1 i (-1))).orientation = -e.orientation :=\n  by\n  rw [orientation_units_smul, finset.prod_update_of_mem (finset.mem_univ _)]\n  simp\n#align orientation_neg_single orientation_neg_single\n\n",
 "orientation_ne_iff_eq_neg":
 "/-- Given a basis, an orientation equals the negation of that given by that basis if and only\nif it does not equal that given by that basis. -/\ntheorem orientation_ne_iff_eq_neg (e : basis ι R M) (x : orientation R M ι) : x ≠ e.orientation ↔ x = -e.orientation :=\n  ⟨fun h => (e.orientation_eq_or_eq_neg x).resolve_left h, fun h =>\n    h.symm ▸ (module.ray.ne_neg_self e.orientation).symm⟩\n#align orientation_ne_iff_eq_neg orientation_ne_iff_eq_neg\n\n",
 "orientation_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem orientation_map [nontrivial R] (e : basis ι R M) (f : «expr ≃ₗ[ ] » M R N) :\n    (e.map f).orientation = orientation.map ι f e.orientation := by\n  simp_rw [basis.orientation, orientation.map_apply, basis.det_map']\n#align orientation_map orientation_map\n\n",
 "orientation_is_empty":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ray_of_ne_zero _ _ _]] -/\n@[simp]\ntheorem orientation_is_empty [nontrivial R] [is_empty ι] (b : basis ι R M) : b.orientation = positive_orientation :=\n  by\n  trace\n    \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14: unsupported tactic `congrm #[[expr ray_of_ne_zero _ _ _]]\"\n  convert b.det_is_empty\n#align orientation_is_empty orientation_is_empty\n\n",
 "orientation_eq_or_eq_neg":
 "/-- Given a basis, any orientation equals the orientation given by that basis or its negation. -/\ntheorem orientation_eq_or_eq_neg (e : basis ι R M) (x : orientation R M ι) : x = e.orientation ∨ x = -e.orientation :=\n  by\n  induction' x using module.ray.ind with x hx\n  rw [← x.map_basis_ne_zero_iff e] at hx\n  rwa [basis.orientation, ray_eq_iff, neg_ray_of_ne_zero, ray_eq_iff, x.eq_smul_basis_det e,\n    same_ray_neg_smul_left_iff_of_ne e.det_ne_zero hx, same_ray_smul_left_iff_of_ne e.det_ne_zero hx, lt_or_lt_iff_ne,\n    ne_comm]\n#align orientation_eq_or_eq_neg orientation_eq_or_eq_neg\n\n",
 "orientation_eq_iff_det_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The orientations given by two bases are equal if and only if the determinant of one basis\nwith respect to the other is positive. -/\ntheorem orientation_eq_iff_det_pos (e₁ e₂ : basis ι R M) : e₁.orientation = e₂.orientation ↔ 0 < e₁.det e₂ :=\n  calc\n    e₁.orientation = e₂.orientation ↔ same_ray R e₁.det e₂.det := ray_eq_iff _ _\n    _ ↔ same_ray R («expr • » (e₁.det e₂) e₂.det) e₂.det := by rw [← e₁.det.eq_smul_basis_det e₂]\n    _ ↔ 0 < e₁.det e₂ := same_ray_smul_left_iff_of_ne e₂.det_ne_zero (e₁.is_unit_det e₂).ne_zero\n    \n#align orientation_eq_iff_det_pos orientation_eq_iff_det_pos\n\n",
 "orientation_comp_linear_equiv_eq_neg_iff_det_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing a basis with a linear equiv gives the negation of that orientation if and only if\nthe determinant is negative. -/\ntheorem orientation_comp_linear_equiv_eq_neg_iff_det_neg (e : basis ι R M) (f : «expr ≃ₗ[ ] » M R M) :\n    (e.map f).orientation = -e.orientation ↔ (f : «expr →ₗ[ ] » M R M).det < 0 := by\n  rw [orientation_map, e.map_orientation_eq_det_inv_smul, units_inv_smul, units_smul_eq_neg_iff, linear_equiv.coe_det]\n#align orientation_comp_linear_equiv_eq_neg_iff_det_neg orientation_comp_linear_equiv_eq_neg_iff_det_neg\n\n",
 "orientation_comp_linear_equiv_eq_iff_det_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing a basis with a linear equiv gives the same orientation if and only if the\ndeterminant is positive. -/\ntheorem orientation_comp_linear_equiv_eq_iff_det_pos (e : basis ι R M) (f : «expr ≃ₗ[ ] » M R M) :\n    (e.map f).orientation = e.orientation ↔ 0 < (f : «expr →ₗ[ ] » M R M).det := by\n  rw [orientation_map, e.map_orientation_eq_det_inv_smul, units_inv_smul, units_smul_eq_self_iff, linear_equiv.coe_det]\n#align orientation_comp_linear_equiv_eq_iff_det_pos orientation_comp_linear_equiv_eq_iff_det_pos\n\n",
 "orientation_adjust_to_orientation":
 "/-- `adjust_to_orientation` gives a basis with the required orientation. -/\n@[simp]\ntheorem orientation_adjust_to_orientation [nontrivial R] [nonempty ι] (e : basis ι R M) (x : orientation R M ι) :\n    (e.adjust_to_orientation x).orientation = x :=\n  by\n  rw [adjust_to_orientation]\n  split_ifs with h\n  · exact h\n  · rw [orientation_neg_single, eq_comm, ← orientation_ne_iff_eq_neg, ne_comm]\n    exact h\n#align orientation_adjust_to_orientation orientation_adjust_to_orientation\n\n",
 "ne_iff_eq_neg":
 "/-- If the index type has cardinality equal to the finite dimension, an orientation equals the\nnegation of another orientation if and only if they are not equal. -/\ntheorem ne_iff_eq_neg (x₁ x₂ : orientation R M ι) (h : fintype.card ι = finrank R M) : x₁ ≠ x₂ ↔ x₁ = -x₂ :=\n  ⟨fun hn => (eq_or_eq_neg x₁ x₂ h).resolve_left hn, fun he => he.symm ▸ (module.ray.ne_neg_self x₂).symm⟩\n#align ne_iff_eq_neg ne_iff_eq_neg\n\n",
 "map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem orientation.map_symm (e : «expr ≃ₗ[ ] » M R N) : (orientation.map ι e).symm = orientation.map ι e.symm :=\n  rfl\n#align orientation.map_symm orientation.map_symm\n\n",
 "map_refl":
 "@[simp]\ntheorem orientation.map_refl : (orientation.map ι <| linear_equiv.refl R M) = equiv.refl _ := by\n  rw [orientation.map, alternating_map.dom_lcongr_refl, module.ray.map_refl]\n#align orientation.map_refl orientation.map_refl\n\n",
 "map_positive_orientation_of_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem orientation.map_positive_orientation_of_is_empty [nontrivial R] [is_empty ι] (f : «expr ≃ₗ[ ] » M R N) :\n    orientation.map ι f positive_orientation = positive_orientation :=\n  rfl\n#align orientation.map_positive_orientation_of_is_empty orientation.map_positive_orientation_of_is_empty\n\n",
 "map_orientation_eq_det_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The value of `orientation.map` when the index type has the cardinality of a basis, in terms\nof `f.det`. -/\ntheorem map_orientation_eq_det_inv_smul [Finite ι] (e : basis ι R M) (x : orientation R M ι) (f : «expr ≃ₗ[ ] » M R M) :\n    orientation.map ι f x = «expr • » f.det⁻¹ x :=\n  by\n  cases nonempty_fintype ι\n  induction' x using module.ray.ind with g hg\n  rw [orientation.map_apply, smul_ray_of_ne_zero, ray_eq_iff, Units.smul_def,\n    (g.comp_linear_map ↑f.symm).eq_smul_basis_det e, g.eq_smul_basis_det e, alternating_map.comp_linear_map_apply,\n    alternating_map.smul_apply, basis.det_comp, basis.det_self, mul_one, smul_eq_mul, mul_comm, mul_smul,\n    linear_equiv.coe_inv_det]\n#align map_orientation_eq_det_inv_smul map_orientation_eq_det_inv_smul\n\n",
 "map_of_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem orientation.map_of_is_empty [is_empty ι] (x : orientation R M ι) (f : «expr ≃ₗ[ ] » M R M) :\n    orientation.map ι f x = x := by\n  induction' x using module.ray.ind with g hg\n  rw [orientation.map_apply]\n  congr\n  ext i\n  rw [alternating_map.comp_linear_map_apply]\n  congr\n#align orientation.map_of_is_empty orientation.map_of_is_empty\n\n",
 "map_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\nprotected theorem orientation.map_neg {ι : Type _} [decidable_eq ι] (f : «expr ≃ₗ[ ] » M R N) (x : orientation R M ι) :\n    orientation.map ι f (-x) = -orientation.map ι f x :=\n  module.ray.map_neg _ x\n#align orientation.map_neg orientation.map_neg\n\n",
 "map_eq_neg_iff_det_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If the index type has cardinality equal to the finite dimension, composing an alternating\nmap with the same linear equiv on each argument gives the negation of that orientation if and\nonly if the determinant is negative. -/\ntheorem map_eq_neg_iff_det_neg (x : orientation R M ι) (f : «expr ≃ₗ[ ] » M R M) (h : fintype.card ι = finrank R M) :\n    orientation.map ι f x = -x ↔ (f : «expr →ₗ[ ] » M R M).det < 0 :=\n  by\n  cases isEmpty_or_nonempty ι\n  · have H : finrank R M = 0 := by\n      refine' h.symm.trans _\n      convert fintype.card_of_is_empty\n      infer_instance\n    simp [linear_map.det_eq_one_of_finrank_eq_zero H, module.ray.ne_neg_self x]\n  have H : 0 < finrank R M := by\n    rw [← h]\n    exact fintype.card_pos\n  haveI : finite_dimensional R M := finite_dimensional_of_finrank H\n  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_neg_iff, linear_equiv.coe_det]\n#align map_eq_neg_iff_det_neg map_eq_neg_iff_det_neg\n\n",
 "map_eq_iff_det_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If the index type has cardinality equal to the finite dimension, composing an alternating\nmap with the same linear equiv on each argument gives the same orientation if and only if the\ndeterminant is positive. -/\ntheorem map_eq_iff_det_pos (x : orientation R M ι) (f : «expr ≃ₗ[ ] » M R M) (h : fintype.card ι = finrank R M) :\n    orientation.map ι f x = x ↔ 0 < (f : «expr →ₗ[ ] » M R M).det :=\n  by\n  cases isEmpty_or_nonempty ι\n  · have H : finrank R M = 0 := by\n      refine' h.symm.trans _\n      convert fintype.card_of_is_empty\n      infer_instance\n    simp [linear_map.det_eq_one_of_finrank_eq_zero H]\n  have H : 0 < finrank R M := by\n    rw [← h]\n    exact fintype.card_pos\n  haveI : finite_dimensional R M := finite_dimensional_of_finrank H\n  rw [map_eq_det_inv_smul _ _ h, units_inv_smul, units_smul_eq_self_iff, linear_equiv.coe_det]\n#align map_eq_iff_det_pos map_eq_iff_det_pos\n\n",
 "map_eq_det_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The value of `orientation.map` when the index type has cardinality equal to the finite\ndimension, in terms of `f.det`. -/\ntheorem map_eq_det_inv_smul (x : orientation R M ι) (f : «expr ≃ₗ[ ] » M R M) (h : fintype.card ι = finrank R M) :\n    orientation.map ι f x = «expr • » f.det⁻¹ x :=\n  haveI e := (fin_basis R M).reindex (fintype.equiv_fin_of_card_eq h).symm\n  e.map_orientation_eq_det_inv_smul x f\n#align map_eq_det_inv_smul map_eq_det_inv_smul\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-\nCopyright (c) 2021 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n@[simp]\ntheorem orientation.map_apply (e : «expr ≃ₗ[ ] » M R N) (v : alternating_map R M R ι) (hv : v ≠ 0) :\n    orientation.map ι e (ray_of_ne_zero _ v hv) =\n      ray_of_ne_zero _ (v.comp_linear_map e.symm) (mt (v.comp_linear_equiv_eq_zero_iff e.symm).mp hv) :=\n  rfl\n#align orientation.map_apply orientation.map_apply\n\n",
 "eq_or_eq_neg_of_is_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- A module `M` over a linearly ordered commutative ring has precisely two \"orientations\" with\nrespect to an empty index type. (Note that these are only orientations of `M` of in the conventional\nmathematical sense if `M` is zero-dimensional.) -/\ntheorem eq_or_eq_neg_of_is_empty [nontrivial R] [is_empty ι] (o : orientation R M ι) :\n    o = positive_orientation ∨ o = -positive_orientation :=\n  by\n  induction' o using module.ray.ind with x hx\n  dsimp [positive_orientation]\n  simp only [ray_eq_iff, same_ray_neg_swap]\n  rw [same_ray_or_same_ray_neg_iff_not_linear_independent]\n  intro h\n  let a : R := alternating_map.const_linear_equiv_of_is_empty.symm x\n  have H :\n    linear_independent R\n      («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n    by\n    convert h.map' (↑alternating_map.const_linear_equiv_of_is_empty.symm) (linear_equiv.ker _)\n    ext i\n    fin_cases i <;> simp [a]\n  rw [linear_independent_iff'] at H\n  simpa using\n    H finset.univ («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\")\n      (by simp [fin.sum_univ_succ]) 0 (by simp)\n#align eq_or_eq_neg_of_is_empty eq_or_eq_neg_of_is_empty\n\n",
 "eq_or_eq_neg":
 "/-- If the index type has cardinality equal to the finite dimension, any two orientations are\nequal or negations. -/\ntheorem eq_or_eq_neg (x₁ x₂ : orientation R M ι) (h : fintype.card ι = finrank R M) : x₁ = x₂ ∨ x₁ = -x₂ :=\n  by\n  have e := (fin_basis R M).reindex (fintype.equiv_fin_of_card_eq h).symm\n  rcases e.orientation_eq_or_eq_neg x₁ with (h₁ | h₁) <;> rcases e.orientation_eq_or_eq_neg x₂ with (h₂ | h₂) <;>\n    simp [h₁, h₂]\n#align eq_or_eq_neg eq_or_eq_neg\n\n",
 "det_adjust_to_orientation":
 "theorem det_adjust_to_orientation [nontrivial R] [nonempty ι] (e : basis ι R M) (x : orientation R M ι) :\n    (e.adjust_to_orientation x).det = e.det ∨ (e.adjust_to_orientation x).det = -e.det :=\n  by\n  dsimp [basis.adjust_to_orientation]\n  split_ifs\n  · left\n    rfl\n  · right\n    simp [e.det_units_smul, ← units.coe_prod, finset.prod_update_of_mem]\n#align det_adjust_to_orientation det_adjust_to_orientation\n\n",
 "adjust_to_orientation_apply_eq_or_eq_neg":
 "/-- Every basis vector from `adjust_to_orientation` is either that from the original basis or its\nnegation. -/\ntheorem adjust_to_orientation_apply_eq_or_eq_neg [nontrivial R] [nonempty ι] (e : basis ι R M) (x : orientation R M ι)\n    (i : ι) : e.adjust_to_orientation x i = e i ∨ e.adjust_to_orientation x i = -e i :=\n  by\n  rw [adjust_to_orientation]\n  split_ifs with h\n  · simp\n  · by_cases hi : i = classical.arbitrary ι <;> simp [units_smul_apply, hi]\n#align adjust_to_orientation_apply_eq_or_eq_neg adjust_to_orientation_apply_eq_or_eq_neg\n\n",
 "abs_det_adjust_to_orientation":
 "@[simp]\ntheorem abs_det_adjust_to_orientation [nontrivial R] [nonempty ι] (e : basis ι R M) (x : orientation R M ι)\n    (v : ι → M) : |(e.adjust_to_orientation x).det v| = |e.det v| := by\n  cases' e.det_adjust_to_orientation x with h h <;> simp [h]\n#align abs_det_adjust_to_orientation abs_det_adjust_to_orientation\n\n"}