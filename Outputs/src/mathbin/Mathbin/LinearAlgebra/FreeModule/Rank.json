{"rank_tensor_product'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/-- If `M` and `N` lie in the same universe, the rank of `M ⊗[R] N` is\n  `(module.rank R M) * (module.rank R N)`. -/\ntheorem rank_tensor_product' (N : Type v) [add_comm_group N] [Module R N] [module.free R N] :\n    module.rank R (tensor_product M R N) = module.rank R M * module.rank R N := by simp\n#align rank_tensor_product' rank_tensor_product'\n\n",
 "rank_tensor_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/-- The rank of `M ⊗[R] N` is `(module.rank R M).lift * (module.rank R N).lift`. -/\n@[simp]\ntheorem rank_tensor_product :\n    module.rank R (tensor_product M R N) = lift.{w, v} (module.rank R M) * lift.{v, w} (module.rank R N) :=\n  by\n  let ιM := choose_basis_index R M\n  let ιN := choose_basis_index R N\n  have h₁ := linear_equiv.lift_dim_eq (tensor_product.congr (repr R M) (repr R N))\n  let b : basis (ιM × ιN) R («expr →₀ » _ R) := finsupp.basis_single_one\n  rw [linear_equiv.dim_eq (finsupp_tensor_finsupp' R ιM ιN), ← b.mk_eq_dim, mk_prod] at h₁\n  rw [lift_inj.1 h₁, rank_eq_card_choose_basis_index R M, rank_eq_card_choose_basis_index R N]\n#align rank_tensor_product rank_tensor_product\n\n",
 "rank_prod'":
 "/-- If `M` and `N` lie in the same universe, the rank of `M × N` is\n  `(module.rank R M) + (module.rank R N)`. -/\ntheorem rank_prod' (N : Type v) [add_comm_group N] [Module R N] [module.free R N] :\n    module.rank R (M × N) = module.rank R M + module.rank R N := by simp\n#align rank_prod' rank_prod'\n\n",
 "rank_prod":
 "/-- The rank of `M × N` is `(module.rank R M).lift + (module.rank R N).lift`. -/\n@[simp]\ntheorem rank_prod : module.rank R (M × N) = lift.{w, v} (module.rank R M) + lift.{v, w} (module.rank R N) := by\n  simpa [rank_eq_card_choose_basis_index R M, rank_eq_card_choose_basis_index R N, lift_umax, lift_umax'] using\n    ((choose_basis R M).prod (choose_basis R N)).mk_eq_dim.symm\n#align rank_prod rank_prod\n\n",
 "rank_pi_finite":
 "/-- The rank of a finite product is the sum of the ranks. -/\n@[simp]\ntheorem rank_pi_finite {ι : Type v} [Finite ι] {M : ι → Type w} [∀ i : ι, add_comm_group (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, module.free R (M i)] :\n    module.rank R (∀ i, M i) = cardinal.sum fun i => module.rank R (M i) :=\n  by\n  cases nonempty_fintype ι\n  rw [← (direct_sum.linear_equiv_fun_on_fintype _ _ M).dim_eq, rank_direct_sum]\n#align rank_pi_finite rank_pi_finite\n\n",
 "rank_matrix''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If `m` and `n` are `fintype` that lie in the same universe as `R`, the rank of `m × n` matrices\n  is `# m * # n`. -/\n@[simp]\ntheorem rank_matrix'' (m n : Type u) [Finite m] [Finite n] :\n    module.rank R (matrix m n R) = cardinal.mk m * cardinal.mk n := by simp\n#align rank_matrix'' rank_matrix''\n\n",
 "rank_matrix'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If `m` and `n` are `fintype` that lie in the same universe, the rank of `m × n` matrices is\n  `(# n * # m).lift`. -/\n@[simp]\ntheorem rank_matrix' (m n : Type v) [Finite m] [Finite n] :\n    module.rank R (matrix m n R) = (cardinal.mk m * cardinal.mk n).lift := by rw [rank_matrix, lift_mul, lift_umax]\n#align rank_matrix' rank_matrix'\n\n",
 "rank_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If `m` and `n` are `fintype`, the rank of `m × n` matrices is `(# m).lift * (# n).lift`. -/\n@[simp]\ntheorem rank_matrix (m : Type v) (n : Type w) [Finite m] [Finite n] :\n    module.rank R (matrix m n R) = lift.{max v w u, v} (cardinal.mk m) * lift.{max v w u, w} (cardinal.mk n) :=\n  by\n  cases nonempty_fintype m\n  cases nonempty_fintype n\n  have h := (matrix.std_basis R m n).mk_eq_dim\n  rw [← lift_lift.{max v w u, max v w}, lift_inj] at h\n  simpa using h.symm\n#align rank_matrix rank_matrix\n\n",
 "rank_finsupp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If `R` and `ι` lie in the same universe, the rank of `(ι →₀ R)` is `# ι`. -/\ntheorem rank_finsupp' {ι : Type u} : module.rank R («expr →₀ » ι R) = cardinal.mk ι := by simp\n#align rank_finsupp' rank_finsupp'\n\n",
 "rank_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The rank of `(ι →₀ R)` is `(# ι).lift`. -/\n@[simp]\ntheorem rank_finsupp {ι : Type v} : module.rank R («expr →₀ » ι R) = (cardinal.mk ι).lift := by\n  simpa [lift_id', lift_umax] using (basis.of_repr (linear_equiv.refl _ («expr →₀ » ι R))).mk_eq_dim.symm\n#align rank_finsupp rank_finsupp\n\n",
 "rank_eq_card_choose_basis_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-\nCopyright (c) 2021 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`. -/\ntheorem rank_eq_card_choose_basis_index : module.rank R M = cardinal.mk (choose_basis_index R M) :=\n  (choose_basis R M).mk_eq_dim''.symm\n#align rank_eq_card_choose_basis_index rank_eq_card_choose_basis_index\n\n",
 "rank_direct_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/-- The rank of the direct sum is the sum of the ranks. -/\n@[simp]\ntheorem rank_direct_sum {ι : Type v} (M : ι → Type w) [∀ i : ι, add_comm_group (M i)] [∀ i : ι, Module R (M i)]\n    [∀ i : ι, module.free R (M i)] :\n    module.rank R\n        (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) =\n      cardinal.sum fun i => module.rank R (M i) :=\n  by\n  let B i := choose_basis R (M i)\n  let b :\n    basis _ R (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) :=\n    dfinsupp.basis fun i => B i\n  simp [← b.mk_eq_dim'', fun i => (B i).mk_eq_dim'']\n#align rank_direct_sum rank_direct_sum\n\n"}