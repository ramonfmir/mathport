{"rank_vecMulVec":
 "#print Matrix.rank_vecMulVec /-\ntheorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [StrongRankCondition K] [Fintype n] [DecidableEq n]\n    (w : m → K) (v : n → K) : (Matrix.vecMulVec w v).to_lin'.rank ≤ 1 :=\n  by\n  rw [Matrix.vecMulVec_eq, Matrix.toLin'_mul]\n  refine' le_trans (LinearMap.rank_comp_le_left _ _) _\n  refine' (LinearMap.rank_le_domain _).trans_eq _\n  rw [rank_fun', Fintype.card_unit, Nat.cast_one]\n#align matrix.rank_vec_mul_vec Matrix.rank_vecMulVec\n-/\n\n",
 "finrank_linearMap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print FiniteDimensional.finrank_linearMap /-\n/-\nCopyright (c) 2021 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- The finrank of `M →ₗ[R] N` is `(finrank R M) * (finrank R N)`. -/\ntheorem FiniteDimensional.finrank_linearMap : finrank R («expr →ₗ[ ] » M R N) = finrank R M * finrank R N := by\n  classical\n    letI := nontrivial_of_invariantBasisNumber R\n    have h := LinearMap.toMatrix (choose_basis R M) (choose_basis R N)\n    simp_rw [h.finrank_eq, FiniteDimensional.finrank_matrix, FiniteDimensional.finrank_eq_card_chooseBasisIndex,\n      mul_comm]\n#align finite_dimensional.finrank_linear_map FiniteDimensional.finrank_linearMap\n-/\n\n"}