{"rank_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- The rank of a finite module is finite. -/\ntheorem rank_lt_aleph_0 : Module.rank R M < cardinal.aleph_0 :=\n  by\n  dsimp only [Module.rank]\n  letI := nontrivial_of_invariantBasisNumber R\n  obtain ⟨S, hS⟩ := module.finite_def.mp ‹_›\n  refine' (csupᵢ_le' fun i => _).trans_lt (nat_lt_aleph_0 S.card)\n  exact linearIndependent_le_span_finset _ i.prop S hS\n#align rank_lt_aleph_0 rank_lt_aleph_0\n\n",
 "nonempty_linear_equiv_of_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two finite and free modules are isomorphic if they have the same (finite) rank. -/\ntheorem nonempty_linear_equiv_of_finrank_eq (cond : finrank R M = finrank R N) : Nonempty («expr ≃ₗ[ ] » M R N) :=\n  nonempty_linearEquiv_of_lift_rank_eq <| by simp only [← finrank_eq_rank, cond, lift_nat_cast]\n#align nonempty_linear_equiv_of_finrank_eq nonempty_linear_equiv_of_finrank_eq\n\n",
 "nonempty_linear_equiv_iff_finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two finite and free modules are isomorphic if and only if they have the same (finite) rank. -/\ntheorem nonempty_linear_equiv_iff_finrank_eq : Nonempty («expr ≃ₗ[ ] » M R N) ↔ finrank R M = finrank R N :=\n  ⟨fun ⟨h⟩ => h.finrank_eq, fun h => nonempty_linearEquiv_of_finrank_eq h⟩\n#align nonempty_linear_equiv_iff_finrank_eq nonempty_linear_equiv_iff_finrank_eq\n\n",
 "finrank_tensor_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/-- The finrank of `M ⊗[R] N` is `(finrank R M) * (finrank R N)`. -/\n@[simp]\ntheorem finrank_tensor_product (M : Type v) (N : Type w) [AddCommGroup M] [Module R M] [Module.Free R M]\n    [AddCommGroup N] [Module R N] [Module.Free R N] : finrank R (tensor_product M R N) = finrank R M * finrank R N := by\n  simp [finrank]\n#align finrank_tensor_product finrank_tensor_product\n\n",
 "finrank_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.finrank_range_le /-\ntheorem LinearMap.finrank_range_le [Module.Finite R M] (f : «expr →ₗ[ ] » M R N) : finrank R f.range ≤ finrank R M :=\n  finrank_le_finrank_of_rank_le_rank (lift_rank_range_le f) (rank_lt_aleph0 _ _)\n#align linear_map.finrank_range_le LinearMap.finrank_range_le\n-/\n\n",
 "finrank_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print Submodule.finrank_quotient_le /-\n/-- The dimension of a quotient is bounded by the dimension of the ambient space. -/\ntheorem Submodule.finrank_quotient_le [Module.Finite R M] (s : Submodule R M) :\n    finrank R («expr ⧸ » M s) ≤ finrank R M := by\n  simpa only [Cardinal.toNat_lift] using\n    to_nat_le_of_le_of_lt_aleph_0 (rank_lt_aleph_0 _ _) ((Submodule.mkQ s).rank_le_of_surjective (surjective_quot_mk _))\n#align submodule.finrank_quotient_le Submodule.finrank_quotient_le\n-/\n\n",
 "finrank_prod":
 "/-- The finrank of `M × N` is `(finrank R M) + (finrank R N)`. -/\n@[simp]\ntheorem finrank_prod : finrank R (M × N) = finrank R M + finrank R N := by\n  simp [finrank, rank_lt_aleph_0 R M, rank_lt_aleph_0 R N]\n#align finrank_prod finrank_prod\n\n",
 "finrank_pi_fintype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n--TODO: this should follow from `linear_equiv.finrank_eq`, that is over a field.\n/-- The finrank of a finite product is the sum of the finranks. -/\ntheorem finrank_pi_fintype {ι : Type v} [Fintype ι] {M : ι → Type w} [∀ i : ι, AddCommGroup (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] [∀ i : ι, Module.Finite R (M i)] :\n    finrank R (∀ i, M i) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (finrank R (M i)) :=\n  by\n  letI := nontrivial_of_invariantBasisNumber R\n  simp only [finrank, fun i => rank_eq_card_choose_basis_index R (M i), rank_pi, ← mk_sigma, mk_to_nat_eq_card,\n    card_sigma]\n#align finrank_pi_fintype finrank_pi_fintype\n\n",
 "finrank_pi":
 "/-- The finrank of `(ι → R)` is `fintype.card ι`. -/\ntheorem finrank_pi {ι : Type v} [Fintype ι] : finrank R (ι → R) = card ι := by simp [finrank]\n#align finrank_pi finrank_pi\n\n",
 "finrank_matrix":
 "/-- If `m` and `n` are `fintype`, the finrank of `m × n` matrices is\n  `(fintype.card m) * (fintype.card n)`. -/\ntheorem finrank_matrix (m n : Type _) [Fintype m] [Fintype n] : finrank R (Matrix m n R) = card m * card n := by\n  simp [finrank]\n#align finrank_matrix finrank_matrix\n\n",
 "finrank_map_subtype_eq":
 "/-\nCopyright (c) 2021 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n--TODO: many results from `linear_algebra/finite_dimensional` should be moved here.\n@[simp]\ntheorem submodule.finrank_map_subtype_eq (p : Submodule R M) (q : Submodule R p) :\n    finrank R (q.map p.subtype) = finrank R q :=\n  (Submodule.equivSubtypeMap p q).symm.finrank_eq\n#align submodule.finrank_map_subtype_eq submodule.finrank_map_subtype_eq\n\n",
 "finrank_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print Submodule.finrank_map_le /-\n/-- Pushforwards of finite submodules have a smaller finrank. -/\ntheorem Submodule.finrank_map_le (f : «expr →ₗ[ ] » M R N) (p : Submodule R M) [Module.Finite R p] :\n    finrank R (p.map f) ≤ finrank R p :=\n  finrank_le_finrank_of_rank_le_rank (lift_rank_map_le _ _) (rank_lt_aleph0 _ _)\n#align submodule.finrank_map_le Submodule.finrank_map_le\n-/\n\n",
 "finrank_le_finrank_of_le":
 "#print Submodule.finrank_le_finrank_of_le /-\ntheorem Submodule.finrank_le_finrank_of_le {s t : Submodule R M} [Module.Finite R t] (hst : s ≤ t) :\n    finrank R s ≤ finrank R t :=\n  calc\n    finrank R s = finrank R (s.comap t.subtype) := (Submodule.comapSubtypeEquivOfLe hst).finrank_eq.symm\n    _ ≤ finrank R t := Submodule.finrank_le _\n    \n#align submodule.finrank_le_finrank_of_le Submodule.finrank_le_finrank_of_le\n-/\n\n",
 "finrank_le_finrank_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.finrank_le_finrank_of_injective /-\ntheorem LinearMap.finrank_le_finrank_of_injective [Module.Finite R N] {f : «expr →ₗ[ ] » M R N}\n    (hf : function.injective f) : finrank R M ≤ finrank R N :=\n  finrank_le_finrank_of_rank_le_rank (LinearMap.lift_rank_le_of_injective _ hf) (rank_lt_aleph0 _ _)\n#align linear_map.finrank_le_finrank_of_injective LinearMap.finrank_le_finrank_of_injective\n-/\n\n",
 "finrank_le":
 "#print Submodule.finrank_le /-\n/-- The dimension of a submodule is bounded by the dimension of the ambient space. -/\ntheorem Submodule.finrank_le [Module.Finite R M] (s : Submodule R M) : finrank R s ≤ finrank R M := by\n  simpa only [Cardinal.toNat_lift] using to_nat_le_of_le_of_lt_aleph_0 (rank_lt_aleph_0 _ _) (rank_submodule_le s)\n#align submodule.finrank_le Submodule.finrank_le\n-/\n\n",
 "finrank_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- The finrank of `(ι →₀ R)` is `fintype.card ι`. -/\n@[simp]\ntheorem finrank_finsupp {ι : Type v} [Fintype ι] : finrank R («expr →₀ » ι R) = card ι := by\n  rw [finrank, rank_finsupp_self, ← mk_to_nat_eq_card, to_nat_lift]\n#align finrank_finsupp finrank_finsupp\n\n",
 "finrank_eq_rank":
 "/-- If `M` is finite, `finrank M = rank M`. -/\n@[simp]\ntheorem finrank_eq_rank : ↑(finrank R M) = Module.rank R M := by\n  rw [finrank, cast_to_nat_of_lt_aleph_0 (rank_lt_aleph_0 R M)]\n#align finrank_eq_rank finrank_eq_rank\n\n",
 "finrank_eq_card_choose_basis_index":
 "/-- The finrank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`. -/\ntheorem finrank_eq_card_choose_basis_index :\n    finrank R M =\n      @card (ChooseBasisIndex R M) (@ChooseBasisIndex.fintype R M _ _ _ _ (nontrivial_of_invariantBasisNumber R) _) :=\n  by\n  letI := nontrivial_of_invariantBasisNumber R\n  simp [finrank, rank_eq_card_choose_basis_index]\n#align finrank_eq_card_choose_basis_index finrank_eq_card_choose_basis_index\n\n",
 "finrank_direct_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The finrank of the direct sum is the sum of the finranks. -/\n@[simp]\ntheorem finrank_direct_sum {ι : Type v} [Fintype ι] (M : ι → Type w) [∀ i : ι, AddCommGroup (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] [∀ i : ι, Module.Finite R (M i)] :\n    finrank R (direct_sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `direct_sum\" (M i)) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (finrank R (M i)) :=\n  by\n  letI := nontrivial_of_invariantBasisNumber R\n  simp only [finrank, fun i => rank_eq_card_choose_basis_index R (M i), rank_directSum, ← mk_sigma, mk_to_nat_eq_card,\n    card_sigma]\n#align finrank_direct_sum finrank_direct_sum\n\n"}