{"smithCoeffs_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Ideal.smithCoeffs_ne_zero /-\n@[simp]\ntheorem Ideal.smithCoeffs_ne_zero (b : Basis ι R S) (I : Ideal S) (hI : I ≠ «expr⊥») (i) :\n    Ideal.smithCoeffs b I hI i ≠ 0 := by\n  intro hi\n  apply Basis.ne_zero (Ideal.selfBasis b I hI) i\n  refine' Subtype.coe_injective _\n  simp [hi]\n#align ideal.smith_coeffs_ne_zero Ideal.smithCoeffs_ne_zero\n-/\n\n",
 "selfBasis_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Ideal.selfBasis_def /-\n/-- If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix.\n-/\n@[simp]\ntheorem Ideal.selfBasis_def (b : Basis ι R S) (I : Ideal S) (hI : I ≠ «expr⊥») :\n    ∀ i, (Ideal.selfBasis b I hI i : S) = «expr • » (Ideal.smithCoeffs b I hI i) (Ideal.ringBasis b I hI i) :=\n  (Ideal.exists_smith_normal_form b I hI).some_spec.some_spec.some_spec\n#align ideal.self_basis_def Ideal.selfBasis_def\n-/\n\n",
 "restrict_scalars_algebras":
 "#print LinearIndependent.restrict_scalars_algebras /-\n/-- A set of linearly independent vectors in a module `M` over a semiring `S` is also linearly\nindependent over a subring `R` of `K`. -/\ntheorem LinearIndependent.restrict_scalars_algebras {R S M ι : Type _} [CommSemiring R] [Semiring S] [AddCommMonoid M]\n    [Algebra R S] [Module R M] [Module S M] [IsScalarTower R S M] (hinj : function.injective (algebraMap R S))\n    {v : ι → M} (li : LinearIndependent S v) : LinearIndependent R v :=\n  LinearIndependent.restrict_scalars (by rwa [Algebra.algebraMap_eq_smul_one'] at hinj) li\n#align linear_independent.restrict_scalars_algebras LinearIndependent.restrict_scalars_algebras\n-/\n\n",
 "nonempty_basis_of_pid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Submodule.nonempty_basis_of_pid /-\n/-- A submodule of a free `R`-module of finite rank is also a free `R`-module of finite rank,\nif `R` is a principal ideal domain.\n\nThis is a `lemma` to make the induction a bit easier. To actually access the basis,\nsee `submodule.basis_of_pid`.\n\nSee also the stronger version `submodule.smith_normal_form`.\n-/\ntheorem Submodule.nonempty_basis_of_pid {ι : Type _} [Finite ι] (b : Basis ι R M) (N : Submodule R M) :\n    ∃ n : ℕ, Nonempty (Basis (Fin n) R N) := by\n  haveI := Classical.decEq M\n  cases nonempty_fintype ι\n  refine' N.induction_on_rank b _ _\n  intro N ih\n  let b' := (b.reindex (Fintype.equivFin ι)).map (LinearEquiv.ofTop _ rfl).symm\n  by_cases N_bot : N = «expr⊥»\n  · subst N_bot\n    exact ⟨0, ⟨Basis.empty _⟩⟩\n  obtain ⟨y, -, a, hay, M', -, N', N'_le_N, -, -, ay_ortho, h'⟩ :=\n    Submodule.basis_of_pid_aux («expr⊤») N b' N_bot le_top\n  obtain ⟨n', ⟨bN'⟩⟩ := ih N' N'_le_N _ hay ay_ortho\n  obtain ⟨bN, hbN⟩ := h' n' bN'\n  exact ⟨n' + 1, ⟨bN⟩⟩\n#align submodule.nonempty_basis_of_pid Submodule.nonempty_basis_of_pid\n-/\n\n",
 "generator_maximal_submoduleImage_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print generator_maximal_submoduleImage_dvd /-\ntheorem generator_maximal_submoduleImage_dvd {N O : Submodule R M} (hNO : N ≤ O) {ϕ : «expr →ₗ[ ] » O R R}\n    (hϕ : ∀ ψ : «expr →ₗ[ ] » O R R, ¬ϕ.submodule_image N < ψ.submodule_image N) [(ϕ.submodule_image N).is_principal]\n    (y : M) (yN : y ∈ N) (ϕy_eq : ϕ ⟨y, hNO yN⟩ = generator (ϕ.submodule_image N)) (ψ : «expr →ₗ[ ] » O R R) :\n    generator (ϕ.submodule_image N) ∣ ψ ⟨y, hNO yN⟩ :=\n  by\n  let a : R := generator (ϕ.submodule_image N)\n  let d : R := is_principal.generator (Submodule.span R {a, ψ ⟨y, hNO yN⟩})\n  have d_dvd_left : d ∣ a := (mem_iff_generator_dvd _).mp (subset_span (mem_insert _ _))\n  have d_dvd_right : d ∣ ψ ⟨y, hNO yN⟩ :=\n    (mem_iff_generator_dvd _).mp (subset_span (mem_insert_of_mem _ (mem_singleton _)))\n  refine' dvd_trans _ d_dvd_right\n  rw [dvd_generator_iff, Ideal.span, ← span_singleton_generator (Submodule.span R {a, ψ ⟨y, hNO yN⟩})]\n  obtain ⟨r₁, r₂, d_eq⟩ : ∃ r₁ r₂ : R, d = r₁ * a + r₂ * ψ ⟨y, hNO yN⟩ :=\n    by\n    obtain ⟨r₁, r₂', hr₂', hr₁⟩ := mem_span_insert.mp (is_principal.generator_mem (Submodule.span R {a, ψ ⟨y, hNO yN⟩}))\n    obtain ⟨r₂, rfl⟩ := mem_span_singleton.mp hr₂'\n    exact ⟨r₁, r₂, hr₁⟩\n  let ψ' : «expr →ₗ[ ] » O R R := «expr • » r₁ ϕ + «expr • » r₂ ψ\n  have : span R {d} ≤ ψ'.submodule_image N :=\n    by\n    rw [span_le, singleton_subset_iff, SetLike.mem_coe, LinearMap.mem_submoduleImage_of_le hNO]\n    refine' ⟨y, yN, _⟩\n    change r₁ * ϕ ⟨y, hNO yN⟩ + r₂ * ψ ⟨y, hNO yN⟩ = d\n    rw [d_eq, ϕy_eq]\n  refine' le_antisymm (this.trans (le_of_eq _)) (ideal.span_singleton_le_span_singleton.mpr d_dvd_left)\n  rw [span_singleton_generator]\n  apply (le_trans _ this).eq_of_not_gt (hϕ ψ')\n  rw [← span_singleton_generator (ϕ.submodule_image N)]\n  exact ideal.span_singleton_le_span_singleton.mpr d_dvd_left\n  · exact subset_span (mem_insert _ _)\n#align generator_maximal_submodule_image_dvd generator_maximal_submoduleImage_dvd\n-/\n\n",
 "free_of_finite_type_torsion_free'":
 "#print Module.free_of_finite_type_torsion_free' /-\ntheorem Module.free_of_finite_type_torsion_free' [Module.Finite R M] [NoZeroSMulDivisors R M] : Module.Free R M :=\n  by\n  obtain ⟨n, b⟩ : Σn, Basis (Fin n) R M := Module.basisOfFiniteTypeTorsionFree'\n  exact Module.Free.of_basis b\n#align module.free_of_finite_type_torsion_free' Module.free_of_finite_type_torsion_free'\n-/\n\n",
 "free_of_finite_type_torsion_free":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Module.free_of_finite_type_torsion_free /-\n-- We define `N` as the submodule spanned by a maximal linear independent subfamily of `s`\n-- same as `span R (s '' I)` but more convenient\n-- `s` restricted to `I`\n-- `s` restricted to `I` is a basis of `N`\n-- Our first goal is to build `A ≠ 0` such that `A • M ⊆ N`\n-- `M ≃ A • M` because `M` is torsion free and `A ≠ 0`\n-- as announced, `A • M ⊆ N`\n-- Since a submodule of a free `R`-module is free, we get that `A • M` is free\n-- hence `M` is free.\ntheorem Module.free_of_finite_type_torsion_free [Finite ι] {s : ι → M} (hs : span R (range s) = «expr⊤»)\n    [NoZeroSMulDivisors R M] : Module.Free R M :=\n  by\n  cases nonempty_fintype ι\n  obtain ⟨n, b⟩ : Σn, Basis (Fin n) R M := Module.basisOfFiniteTypeTorsionFree hs\n  exact Module.Free.of_basis b\n#align module.free_of_finite_type_torsion_free Module.free_of_finite_type_torsion_free\n-/\n\n",
 "exists_smith_normal_form_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Submodule.exists_smith_normal_form_of_le /-\n/-- If `M` is finite free over a PID `R`, then any submodule `N` is free\nand we can find a basis for `M` and `N` such that the inclusion map is a diagonal matrix\nin Smith normal form.\n\nSee `submodule.smith_normal_form_of_le` for a version of this theorem that returns\na `basis.smith_normal_form`.\n\nThis is a strengthening of `submodule.basis_of_pid_of_le`.\n-/\ntheorem Submodule.exists_smith_normal_form_of_le [Finite ι] (b : Basis ι R M) (N O : Submodule R M) (N_le_O : N ≤ O) :\n    ∃ (n o : ℕ)(hno : n ≤ o)(bO : Basis (Fin o) R O)(bN : Basis (Fin n) R N)(a : Fin n → R),\n      ∀ i, (bN i : M) = «expr • » (a i) (bO (Fin.castLE hno i)) :=\n  by\n  cases nonempty_fintype ι\n  revert N\n  refine' induction_on_rank b _ _ O\n  intro M ih N N_le_M\n  obtain ⟨m, b'M⟩ := M.basis_of_pid b\n  by_cases N_bot : N = «expr⊥»\n  · subst N_bot\n    exact ⟨0, m, nat.zero_le _, b'M, Basis.empty _, finZeroElim, finZeroElim⟩\n  obtain ⟨y, hy, a, hay, M', M'_le_M, N', N'_le_N, N'_le_M', y_ortho, ay_ortho, h⟩ :=\n    Submodule.basis_of_pid_aux M N b'M N_bot N_le_M\n  obtain ⟨n', m', hn'm', bM', bN', as', has'⟩ := ih M' M'_le_M y hy y_ortho N' N'_le_M'\n  obtain ⟨bN, h'⟩ := h n' bN'\n  obtain ⟨hmn, bM, h''⟩ := h' m' hn'm' bM'\n  obtain ⟨as, has⟩ := h'' as' has'\n  exact ⟨_, _, hmn, bM, bN, as, has⟩\n#align submodule.exists_smith_normal_form_of_le Submodule.exists_smith_normal_form_of_le\n-/\n\n",
 "exists_smith_normal_form":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Ideal.exists_smith_normal_form /-\n/-- If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix.\n\nSee also `ideal.smith_normal_form` for a version of this theorem that returns\na `basis.smith_normal_form`.\n\nThe definitions `ideal.ring_basis`, `ideal.self_basis`, `ideal.smith_coeffs` are (noncomputable)\nchoices of values for this existential quantifier.\n-/\ntheorem Ideal.exists_smith_normal_form (b : Basis ι R S) (I : Ideal S) (hI : I ≠ «expr⊥») :\n    ∃ (b' : Basis ι R S)(a : ι → R)(ab' : Basis ι R I), ∀ i, (ab' i : S) = «expr • » (a i) (b' i) := by\n  cases nonempty_fintype ι <;>\n    exact\n      let ⟨bS, bI, f, a, snf⟩ := I.smith_normal_form b hI\n      let e : «expr ≃ » (Fin (Fintype.card ι)) ι :=\n        Equiv.ofBijective f ((Fintype.bijective_iff_injective_and_card f).mpr ⟨f.injective, Fintype.card_fin _⟩)\n      have fe : ∀ i, f (e.symm i) = i := e.apply_symm_apply\n      ⟨bS, a ∘ e.symm, (bI.reindex e).map ((restrict_scalars_equiv _ _ _ _).restrict_scalars R), fun i => by\n        simp only [snf, fe, Basis.map_apply, LinearEquiv.restrictScalars_apply, submodule.restrict_scalars_equiv_apply,\n          Basis.coe_reindex]⟩\n#align ideal.exists_smith_normal_form Ideal.exists_smith_normal_form\n-/\n\n",
 "eq_bot_of_generator_maximal_submoduleImage_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print eq_bot_of_generator_maximal_submoduleImage_eq_zero /-\ntheorem eq_bot_of_generator_maximal_submoduleImage_eq_zero {N O : Submodule R M} (b : Basis ι R O) (hNO : N ≤ O)\n    {ϕ : «expr →ₗ[ ] » O R R} (hϕ : ∀ ψ : «expr →ₗ[ ] » O R R, ¬ϕ.submodule_image N < ψ.submodule_image N)\n    [(ϕ.submodule_image N).is_principal] (hgen : generator (ϕ.submodule_image N) = 0) : N = «expr⊥» :=\n  by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  refine' congr_arg coe (show (⟨x, hNO hx⟩ : O) = 0 from b.ext_elem fun i => _)\n  rw [(eq_bot_iff_generator_eq_zero _).mpr hgen] at hϕ\n  rw [LinearEquiv.map_zero, Finsupp.zero_apply]\n  refine' (Submodule.eq_bot_iff _).mp (not_bot_lt_iff.1 <| hϕ («expr ∘ₗ » (Finsupp.lapply i) ↑b.repr)) _ _\n  exact (LinearMap.mem_submoduleImage_of_le hNO).mpr ⟨x, hx, rfl⟩\n#align eq_bot_of_generator_maximal_submodule_image_eq_zero eq_bot_of_generator_maximal_submoduleImage_eq_zero\n-/\n\n",
 "eq_bot_of_generator_maximal_map_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print eq_bot_of_generator_maximal_map_eq_zero /-\n/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\ntheorem eq_bot_of_generator_maximal_map_eq_zero (b : Basis ι R M) {N : Submodule R M} {ϕ : «expr →ₗ[ ] » M R R}\n    (hϕ : ∀ ψ : «expr →ₗ[ ] » M R R, ¬N.map ϕ < N.map ψ) [(N.map ϕ).is_principal]\n    (hgen : generator (N.map ϕ) = (0 : R)) : N = «expr⊥» :=\n  by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  refine' b.ext_elem fun i => _\n  rw [(eq_bot_iff_generator_eq_zero _).mpr hgen] at hϕ\n  rw [LinearEquiv.map_zero, Finsupp.zero_apply]\n  exact (Submodule.eq_bot_iff _).mp (not_bot_lt_iff.1 <| hϕ («expr ∘ₗ » (Finsupp.lapply i) ↑b.repr)) _ ⟨x, hx, rfl⟩\n#align eq_bot_of_generator_maximal_map_eq_zero eq_bot_of_generator_maximal_map_eq_zero\n-/\n\n",
 "dvd_generator_iff":
 "#print dvd_generator_iff /-\ntheorem dvd_generator_iff {I : Ideal R} [I.is_principal] {x : R} (hx : x ∈ I) : x ∣ generator I ↔ I = Ideal.span {x} :=\n  by\n  conv_rhs => rw [← span_singleton_generator I]\n  erw [Ideal.span_singleton_eq_span_singleton, ← dvd_dvd_iff_associated, ← mem_iff_generator_dvd]\n  exact ⟨fun h => ⟨hx, h⟩, fun h => h.2⟩\n#align dvd_generator_iff dvd_generator_iff\n-/\n\n",
 "basis_of_pid_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Submodule.basis_of_pid_aux /-\n/-- The induction hypothesis of `submodule.basis_of_pid` and `submodule.smith_normal_form`.\n\nBasically, it says: let `N ≤ M` be a pair of submodules, then we can find a pair of\nsubmodules `N' ≤ M'` of strictly smaller rank, whose basis we can extend to get a basis\nof `N` and `M`. Moreover, if the basis for `M'` is up to scalars a basis for `N'`,\nthen the basis we find for `M` is up to scalars a basis for `N`.\n\nFor `basis_of_pid` we only need the first half and can fix `M = ⊤`,\nfor `smith_normal_form` we need the full statement,\nbut must also feed in a basis for `M` using `basis_of_pid` to keep the induction going.\n-/\ntheorem Submodule.basis_of_pid_aux [Finite ι] {O : Type _} [AddCommGroup O] [Module R O] (M N : Submodule R O)\n    (b'M : Basis ι R M) (N_bot : N ≠ «expr⊥») (N_le_M : N ≤ M) :\n    ∃ y ∈ M,\n      ∃ (a : R)(hay : «expr • » a y ∈ N),\n        ∃ M' ≤ M,\n          ∃ N' ≤ N,\n            ∃ (N'_le_M' : N' ≤ M')(y_ortho_M' : ∀ (c : R) (z : O), z ∈ M' → «expr • » c y + z = 0 → c = 0)(ay_ortho_N' :\n              ∀ (c : R) (z : O), z ∈ N' → «expr • » c («expr • » a y) + z = 0 → c = 0),\n              ∀ (n') (bN' : Basis (Fin n') R N'),\n                ∃ bN : Basis (Fin (n' + 1)) R N,\n                  ∀ (m') (hn'm' : n' ≤ m') (bM' : Basis (Fin m') R M'),\n                    ∃ (hnm : n' + 1 ≤ m' + 1)(bM : Basis (Fin (m' + 1)) R M),\n                      ∀ (as : Fin n' → R)\n                        (h : ∀ i : Fin n', (bN' i : O) = «expr • » (as i) (bM' (Fin.castLE hn'm' i) : O)),\n                        ∃ as' : Fin (n' + 1) → R,\n                          ∀ i : Fin (n' + 1), (bN i : O) = «expr • » (as' i) (bM (Fin.castLE hnm i) : O) :=\n  by\n  -- Let `ϕ` be a maximal projection of `M` onto `R`, in the sense that there is\n  -- no `ψ` whose image of `N` is larger than `ϕ`'s image of `N`.\n  have : ∃ ϕ : «expr →ₗ[ ] » M R R, ∀ ψ : «expr →ₗ[ ] » M R R, ¬ϕ.submodule_image N < ψ.submodule_image N :=\n    by\n    obtain ⟨P, P_eq, P_max⟩ :=\n      set_has_maximal_iff_noetherian.mpr (inferInstance : IsNoetherian R R) _\n        (show (Set.range fun ψ : «expr →ₗ[ ] » M R R => ψ.submodule_image N).nonempty from\n          ⟨_, set.mem_range.mpr ⟨0, rfl⟩⟩)\n    obtain ⟨ϕ, rfl⟩ := set.mem_range.mp P_eq\n    exact ⟨ϕ, fun ψ hψ => P_max _ ⟨_, rfl⟩ hψ⟩\n  let ϕ := this.some\n  have ϕ_max := this.some_spec\n  -- Since `ϕ(N)` is a `R`-submodule of the PID `R`,\n  -- it is principal and generated by some `a`.\n  let a := generator (ϕ.submodule_image N)\n  have a_mem : a ∈ ϕ.submodule_image N := generator_mem _\n  -- If `a` is zero, then the submodule is trivial. So let's assume `a ≠ 0`, `N ≠ ⊥`.\n  by_cases a_zero : a = 0\n  · have := eq_bot_of_generator_maximal_submoduleImage_eq_zero b'M N_le_M ϕ_max a_zero\n    contradiction\n  -- We claim that `ϕ⁻¹ a = y` can be taken as basis element of `N`.\n  obtain ⟨y, yN, ϕy_eq⟩ := (LinearMap.mem_submoduleImage_of_le N_le_M).mp a_mem\n  have ϕy_ne_zero : ϕ ⟨y, N_le_M yN⟩ ≠ 0 := fun h => a_zero (ϕy_eq.symm.trans h)\n  -- Write `y` as `a • y'` for some `y'`.\n  have hdvd : ∀ i, a ∣ b'M.coord i ⟨y, N_le_M yN⟩ := fun i =>\n    generator_maximal_submoduleImage_dvd N_le_M ϕ_max y yN ϕy_eq (b'M.coord i)\n  choose c hc using hdvd\n  cases nonempty_fintype ι\n  let y' : O :=\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n      («expr • » (c i) (b'M i))\n  have y'M : y' ∈ M := M.sum_mem fun i _ => M.smul_mem (c i) (b'M i).2\n  have mk_y' :\n    (⟨y', y'M⟩ : M) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (c i) (b'M i)) :=\n    Subtype.ext\n      (show y' = M.subtype _ by\n        simp only [LinearMap.map_sum, LinearMap.map_smul]\n        rfl)\n  have a_smul_y' : «expr • » a y' = y :=\n    by\n    refine' congr_arg coe (show («expr • » a ⟨y', y'M⟩ : M) = ⟨y, N_le_M yN⟩ from _)\n    rw [← b'M.sum_repr ⟨y, N_le_M yN⟩, mk_y', Finset.smul_sum]\n    refine' Finset.sum_congr rfl fun i _ => _\n    rw [← mul_smul, ← hc]\n    rfl\n  -- We found an `y` and an `a`!\n  refine' ⟨y', y'M, a, a_smul_y'.symm ▸ yN, _⟩\n  have ϕy'_eq : ϕ ⟨y', y'M⟩ = 1 :=\n    mul_left_cancel₀ a_zero\n      (calc\n        «expr • » a (ϕ ⟨y', y'M⟩) = ϕ ⟨«expr • » a y', _⟩ := (ϕ.map_smul a ⟨y', y'M⟩).symm\n        _ = ϕ ⟨y, N_le_M yN⟩ := by simp only [a_smul_y']\n        _ = a := ϕy_eq\n        _ = a * 1 := (mul_one a).symm\n        )\n  have ϕy'_ne_zero : ϕ ⟨y', y'M⟩ ≠ 0 := by simpa only [ϕy'_eq] using one_ne_zero\n  -- `M' := ker (ϕ : M → R)` is smaller than `M` and `N' := ker (ϕ : N → R)` is smaller than `N`.\n  let M' : Submodule R O := ϕ.ker.map M.subtype\n  let N' : Submodule R O := (ϕ.comp (of_le N_le_M)).ker.map N.subtype\n  have M'_le_M : M' ≤ M := M.map_subtype_le ϕ.ker\n  have N'_le_M' : N' ≤ M' := by\n    intro x hx\n    simp only [mem_map, LinearMap.mem_ker] at hx⊢\n    obtain ⟨⟨x, xN⟩, hx, rfl⟩ := hx\n    exact ⟨⟨x, N_le_M xN⟩, hx, rfl⟩\n  have N'_le_N : N' ≤ N := N.map_subtype_le (ϕ.comp (of_le N_le_M)).ker\n  -- So fill in those results as well.\n  refine' ⟨M', M'_le_M, N', N'_le_N, N'_le_M', _⟩\n  -- Note that `y'` is orthogonal to `M'`.\n  have y'_ortho_M' : ∀ (c : R), ∀ z ∈ M', «expr • » c y' + z = 0 → c = 0 :=\n    by\n    intro c x xM' hc\n    obtain ⟨⟨x, xM⟩, hx', rfl⟩ := submodule.mem_map.mp xM'\n    rw [LinearMap.mem_ker] at hx'\n    have hc' : («expr • » c ⟨y', y'M⟩ + ⟨x, xM⟩ : M) = 0 := Subtype.coe_injective hc\n    simpa only [LinearMap.map_add, LinearMap.map_zero, LinearMap.map_smul, smul_eq_mul, add_zero, mul_eq_zero,\n      ϕy'_ne_zero, hx', or_false_iff] using congr_arg ϕ hc'\n  -- And `a • y'` is orthogonal to `N'`.\n  have ay'_ortho_N' : ∀ (c : R), ∀ z ∈ N', «expr • » c («expr • » a y') + z = 0 → c = 0 :=\n    by\n    intro c z zN' hc\n    refine' (mul_eq_zero.mp (y'_ortho_M' (a * c) z (N'_le_M' zN') _)).resolve_left a_zero\n    rw [mul_comm, mul_smul, hc]\n  -- So we can extend a basis for `N'` with `y`\n  refine' ⟨y'_ortho_M', ay'_ortho_N', fun n' bN' => ⟨_, _⟩⟩\n  · refine' Basis.mkFinConsOfLe y yN bN' N'_le_N _ _\n    · intro c z zN' hc\n      refine' ay'_ortho_N' c z zN' _\n      rwa [← a_smul_y'] at hc\n    · intro z zN\n      obtain ⟨b, hb⟩ : _ ∣ ϕ ⟨z, N_le_M zN⟩ := generator_submodule_image_dvd_of_mem N_le_M ϕ zN\n      refine' ⟨-b, submodule.mem_map.mpr ⟨⟨_, N.sub_mem zN (N.smul_mem b yN)⟩, _, _⟩⟩\n      · refine' linear_map.mem_ker.mpr (show ϕ (⟨z, N_le_M zN⟩ - «expr • » b ⟨y, N_le_M yN⟩) = 0 from _)\n        rw [LinearMap.map_sub, LinearMap.map_smul, hb, ϕy_eq, smul_eq_mul, mul_comm, sub_self]\n      · simp only [sub_eq_add_neg, neg_smul]\n        rfl\n  -- And extend a basis for `M'` with `y'`\n  intro m' hn'm' bM'\n  refine' ⟨nat.succ_le_succ hn'm', _, _⟩\n  · refine' Basis.mkFinConsOfLe y' y'M bM' M'_le_M y'_ortho_M' _\n    intro z zM\n    refine' ⟨-ϕ ⟨z, zM⟩, ⟨⟨z, zM⟩ - «expr • » (ϕ ⟨z, zM⟩) ⟨y', y'M⟩, linear_map.mem_ker.mpr _, _⟩⟩\n    · rw [LinearMap.map_sub, LinearMap.map_smul, ϕy'_eq, smul_eq_mul, mul_one, sub_self]\n    · rw [LinearMap.map_sub, LinearMap.map_smul, sub_eq_add_neg, neg_smul]\n      rfl\n  -- It remains to show the extended bases are compatible with each other.\n  intro as h\n  refine' ⟨Fin.cons a as, _⟩\n  intro i\n  rw [Basis.coe_mkFinConsOfLe, Basis.coe_mkFinConsOfLe]\n  refine' Fin.cases _ (fun i => _) i\n  · simp only [Fin.cons_zero, Fin.castLE_zero]\n    exact a_smul_y'.symm\n  · rw [Fin.castLE_succ]\n    simp only [Fin.cons_succ, coe_of_le, h i]\n#align submodule.basis_of_pid_aux Submodule.basis_of_pid_aux\n-/\n\n",
 "basisOfPid_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Submodule.basisOfPid_bot /-\ntheorem Submodule.basisOfPid_bot {ι : Type _} [Finite ι] (b : Basis ι R M) :\n    Submodule.basisOfPid b («expr⊥») = ⟨0, Basis.empty _⟩ :=\n  by\n  obtain ⟨n, b'⟩ := Submodule.basisOfPid b («expr⊥»)\n  let e : «expr ≃ » (Fin n) (Fin 0) := b'.index_equiv (Basis.empty _ : Basis (Fin 0) R («expr⊥» : Submodule R M))\n  obtain rfl : n = 0 := by simpa using fintype.card_eq.mpr ⟨e⟩\n  exact sigma.eq rfl (Basis.eq_of_apply_eq <| finZeroElim)\n#align submodule.basis_of_pid_bot Submodule.basisOfPid_bot\n-/\n\n"}