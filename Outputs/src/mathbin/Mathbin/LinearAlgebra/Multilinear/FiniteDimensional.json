{"free_and_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n-- the induction requires us to show both at once\nprivate theorem free_and_finite : module.free R (multilinear_map R M₁ M₂) ∧ module.finite R (multilinear_map R M₁ M₂) :=\n  by\n  -- the `fin n` case is sufficient\n  suffices\n    ∀ (n) (N : fin n → Type _) [∀ i, add_comm_group (N i)],\n      ∀ [∀ i, Module R (N i)],\n        ∀ [∀ i, module.finite R (N i)] [∀ i, module.free R (N i)],\n          module.free R (multilinear_map R N M₂) ∧ module.finite R (multilinear_map R N M₂)\n    by\n    cases nonempty_fintype ι\n    cases this _ (M₁ ∘ (fintype.equiv_fin ι).symm)\n    have e := dom_dom_congr_linear_equiv' R M₁ M₂ (fintype.equiv_fin ι)\n    exact ⟨module.free.of_equiv e.symm, module.finite.equiv e.symm⟩\n  intro n N _ _ _ _\n  induction' n with n ih\n  ·\n    exact\n      ⟨module.free.of_equiv (const_linear_equiv_of_is_empty R N M₂),\n        module.finite.equiv (const_linear_equiv_of_is_empty R N M₂)⟩\n  · suffices\n      module.free R («expr →ₗ[ ] » (N 0) R (multilinear_map R (fun i : fin n => N i.succ) M₂)) ∧\n        module.finite R («expr →ₗ[ ] » (N 0) R (multilinear_map R (fun i : fin n => N i.succ) M₂))\n      by\n      cases this\n      exact\n        ⟨module.free.of_equiv (multilinear_curry_left_equiv R N M₂),\n          module.finite.equiv (multilinear_curry_left_equiv R N M₂)⟩\n    cases ih fun i => N i.succ\n    exact ⟨module.free.linear_map _ _ _, module.finite.linear_map _ _⟩\n#align free_and_finite free_and_finite\n\n"}