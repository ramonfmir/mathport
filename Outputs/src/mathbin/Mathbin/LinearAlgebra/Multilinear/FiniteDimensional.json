{"free_and_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2022 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n-- the induction requires us to show both at once\nprivate theorem free_and_finite : Module.Free R (MultilinearMap R M₁ M₂) ∧ Module.Finite R (MultilinearMap R M₁ M₂) :=\n  by\n  -- the `fin n` case is sufficient\n  suffices\n    ∀ (n) (N : Fin n → Type _) [∀ i, AddCommGroup (N i)],\n      ∀ [∀ i, Module R (N i)],\n        ∀ [∀ i, Module.Finite R (N i)] [∀ i, Module.Free R (N i)],\n          Module.Free R (MultilinearMap R N M₂) ∧ Module.Finite R (MultilinearMap R N M₂)\n    by\n    cases nonempty_fintype ι\n    cases this _ (M₁ ∘ (Fintype.equivFin ι).symm)\n    have e := dom_dom_congr_linear_equiv' R M₁ M₂ (Fintype.equivFin ι)\n    exact ⟨Module.Free.of_equiv e.symm, Module.Finite.equiv e.symm⟩\n  intro n N _ _ _ _\n  induction' n with n ih\n  ·\n    exact\n      ⟨Module.Free.of_equiv (const_linear_equiv_of_is_empty R N M₂),\n        Module.Finite.equiv (const_linear_equiv_of_is_empty R N M₂)⟩\n  · suffices\n      Module.Free R («expr →ₗ[ ] » (N 0) R (MultilinearMap R (fun i : Fin n => N i.succ) M₂)) ∧\n        Module.Finite R («expr →ₗ[ ] » (N 0) R (MultilinearMap R (fun i : Fin n => N i.succ) M₂))\n      by\n      cases this\n      exact\n        ⟨Module.Free.of_equiv (multilinearCurryLeftEquiv R N M₂),\n          Module.Finite.equiv (multilinearCurryLeftEquiv R N M₂)⟩\n    cases ih fun i => N i.succ\n    exact ⟨Module.Free.linearMap _ _ _, Module.Finite.linearMap _ _⟩\n#align free_and_finite free_and_finite\n\n"}