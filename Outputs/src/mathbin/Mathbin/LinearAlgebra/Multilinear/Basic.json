{"zero_comp_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing the zero multilinear map with a linear map in each argument. -/\n@[simp]\ntheorem zero_comp_linear_map (f : ∀ i, «expr →ₗ[ ] » (M₁ i) R (M₁' i)) :\n    (0 : MultilinearMap R M₁' M₂).comp_linear_map f = 0 :=\n  ext fun _ => rfl\n#align zero_comp_linear_map zero_comp_linear_map\n\n",
 "zero_apply":
 "@[simp]\ntheorem zero_apply (m : ∀ i, M₁ i) : (0 : MultilinearMap R M₁ M₂) m = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "uncurry_sum_aux_apply":
 "@[simp]\ntheorem uncurry_sum_aux_apply (f : MultilinearMap R (fun x : ι => M') (MultilinearMap R (fun x : ι' => M') M₂))\n    (u : Sum ι ι' → M') : f.uncurry_sum u = f (u ∘ Sum.inl) (u ∘ Sum.inr) :=\n  rfl\n#align uncurry_sum_aux_apply uncurry_sum_aux_apply\n\n",
 "uncurry_curryRight":
 "#print MultilinearMap.uncurry_curryRight /-\n@[simp]\ntheorem MultilinearMap.uncurry_curryRight (f : MultilinearMap R M M₂) : f.curry_right.uncurry_right = f :=\n  by\n  ext m\n  simp\n#align multilinear_map.uncurry_curry_right MultilinearMap.uncurry_curryRight\n-/\n\n",
 "uncurry_curryLeft":
 "#print MultilinearMap.uncurry_curryLeft /-\n@[simp]\ntheorem MultilinearMap.uncurry_curryLeft (f : MultilinearMap R M M₂) : f.curry_left.uncurry_left = f :=\n  by\n  ext m\n  simp\n#align multilinear_map.uncurry_curry_left MultilinearMap.uncurry_curryLeft\n-/\n\n",
 "uncurryRight_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print MultilinearMap.uncurryRight_apply /-\n@[simp]\ntheorem MultilinearMap.uncurryRight_apply\n    (f : MultilinearMap R (fun i : Fin n => M i.cast_succ) («expr →ₗ[ ] » (M (last n)) R M₂)) (m : ∀ i, M i) :\n    f.uncurry_right m = f (init m) (m (last n)) :=\n  rfl\n#align multilinear_map.uncurry_right_apply MultilinearMap.uncurryRight_apply\n-/\n\n",
 "uncurryLeft_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.uncurryLeft_apply /-\n@[simp]\ntheorem LinearMap.uncurryLeft_apply (f : «expr →ₗ[ ] » (M 0) R (MultilinearMap R (fun i : Fin n => M i.succ) M₂))\n    (m : ∀ i, M i) : f.uncurry_left m = f (m 0) (tail m) :=\n  rfl\n#align linear_map.uncurry_left_apply LinearMap.uncurryLeft_apply\n-/\n\n",
 "to_fun_eq_coe":
 "/-\nCopyright (c) 2020 Sébastien Gouëzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sébastien Gouëzel\n-/\n@[simp]\ntheorem to_fun_eq_coe : f.to_fun = f :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem sum_apply {α : Type _} (f : α → MultilinearMap R M₁ M₂) (m : ∀ i, M₁ i) :\n    ∀ {s : Finset α},\n      (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f a)) m =\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f a m) :=\n  by\n  classical\n    apply Finset.induction\n    · rw [Finset.sum_empty]\n      simp\n    · intro a s has H\n      rw [Finset.sum_insert has]\n      simp [H, has]\n#align sum_apply sum_apply\n\n",
 "subtype_comp_multilinear_map_cod_restrict":
 "/-- The multilinear version of `linear_map.subtype_comp_cod_restrict` -/\n@[simp]\ntheorem subtype_comp_multilinear_map_cod_restrict (f : MultilinearMap R M₁ M₂) (p : Submodule R M₂) (h) :\n    p.subtype.comp_multilinear_map (f.cod_restrict p h) = f :=\n  MultilinearMap.ext fun v => rfl\n#align subtype_comp_multilinear_map_cod_restrict subtype_comp_multilinear_map_cod_restrict\n\n",
 "sub_apply":
 "@[simp]\ntheorem sub_apply (m : ∀ i, M₁ i) : (f - g) m = f m - g m :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "snoc_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- In the specific case of multilinear maps on spaces indexed by `fin (n+1)`, where one can build\nan element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the multiplicativity\nof a multilinear map along the first variable. -/\ntheorem snoc_smul (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.cast_succ) (c : R) (x : M (last n)) :\n    f (snoc m («expr • » c x)) = «expr • » c (f (snoc m x)) := by\n  rw [← update_snoc_last x m («expr • » c x), f.map_smul, update_snoc_last]\n#align snoc_smul snoc_smul\n\n",
 "snoc_add":
 "/-- In the specific case of multilinear maps on spaces indexed by `fin (n+1)`, where one can build\nan element of `Π(i : fin (n+1)), M i` using `snoc`, one can express directly the additivity of a\nmultilinear map along the first variable. -/\ntheorem snoc_add (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.cast_succ) (x y : M (last n)) :\n    f (snoc m (x + y)) = f (snoc m x) + f (snoc m y) := by\n  rw [← update_snoc_last x m (x + y), f.map_add, update_snoc_last, update_snoc_last]\n#align snoc_add snoc_add\n\n",
 "smul_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_right_apply (f : MultilinearMap R M₁ R) (z : M₂) (m : ∀ i, M₁ i) : f.smul_right z m = «expr • » (f m) z :=\n  rfl\n#align smul_right_apply smul_right_apply\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply (f : MultilinearMap A M₁ M₂) (c : R') (m : ∀ i, M₁ i) : («expr • » c f) m = «expr • » c (f m) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "neg_apply":
 "@[simp]\ntheorem neg_apply (m : ∀ i, M₁ i) : (-f) m = -f m :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "mk_pi_ring_zero":
 "theorem mk_pi_ring_zero [Fintype ι] : MultilinearMap.mkPiRing R ι (0 : M₂) = 0 := by\n  ext <;> rw [mk_pi_ring_apply, smul_zero, MultilinearMap.zero_apply]\n#align mk_pi_ring_zero mk_pi_ring_zero\n\n",
 "mk_pi_ring_eq_zero_iff":
 "theorem mk_pi_ring_eq_zero_iff [Fintype ι] (z : M₂) : MultilinearMap.mkPiRing R ι z = 0 ↔ z = 0 := by\n  rw [← mk_pi_ring_zero, mk_pi_ring_eq_iff]\n#align mk_pi_ring_eq_zero_iff mk_pi_ring_eq_zero_iff\n\n",
 "mk_pi_ring_eq_iff":
 "theorem mk_pi_ring_eq_iff [Fintype ι] {z₁ z₂ : M₂} :\n    MultilinearMap.mkPiRing R ι z₁ = MultilinearMap.mkPiRing R ι z₂ ↔ z₁ = z₂ :=\n  by\n  simp_rw [MultilinearMap.ext_iff, mk_pi_ring_apply]\n  constructor <;> intro h\n  · simpa using h fun _ => 1\n  · intro x\n    simp [h]\n#align mk_pi_ring_eq_iff mk_pi_ring_eq_iff\n\n",
 "mk_pi_ring_apply_one_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mk_pi_ring_apply_one_eq_self [Fintype ι] (f : MultilinearMap R (fun i : ι => R) M₂) :\n    MultilinearMap.mkPiRing R ι (f fun i => 1) = f := by\n  ext m\n  have : m = fun i => «expr • » (m i) 1 := by\n    ext j\n    simp\n  conv_rhs => rw [this, f.map_smul_univ]\n  rfl\n#align mk_pi_ring_apply_one_eq_self mk_pi_ring_apply_one_eq_self\n\n",
 "mk_pi_ring_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem mk_pi_ring_apply [Fintype ι] (z : M₂) (m : ι → R) :\n    (MultilinearMap.mkPiRing R ι z : (ι → R) → M₂) m =\n      «expr • »\n        (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (m i))\n        z :=\n  rfl\n#align mk_pi_ring_apply mk_pi_ring_apply\n\n",
 "mk_pi_algebra_fin_apply_const":
 "theorem mk_pi_algebra_fin_apply_const (a : A) : (MultilinearMap.mkPiAlgebraFin R n A fun _ => a) = a ^ n := by simp\n#align mk_pi_algebra_fin_apply_const mk_pi_algebra_fin_apply_const\n\n",
 "mk_pi_algebra_fin_apply":
 "@[simp]\ntheorem mk_pi_algebra_fin_apply (m : Fin n → A) : MultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).prod :=\n  rfl\n#align mk_pi_algebra_fin_apply mk_pi_algebra_fin_apply\n\n",
 "mk_pi_algebra_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n@[simp]\ntheorem mk_pi_algebra_apply (m : ι → A) :\n    MultilinearMap.mkPiAlgebra R ι A m =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (m i) :=\n  rfl\n#align mk_pi_algebra_apply mk_pi_algebra_apply\n\n",
 "mk_coe":
 "@[simp]\ntheorem mk_coe (f : MultilinearMap R M₁ M₂) (h₁ h₂) : (⟨f, h₁, h₂⟩ : MultilinearMap R M₁ M₂) = f :=\n  by\n  ext\n  rfl\n#align mk_coe mk_coe\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 :=\n  by\n  obtain ⟨i, _⟩ : ∃ i : ι, i ∈ Set.univ := Set.exists_mem_of_nonempty ι\n  exact map_coord_zero f i rfl\n#align map_zero map_zero\n-/\n\n",
 "map_update_zero":
 "@[simp]\ntheorem map_update_zero [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) : f (update m i 0) = 0 :=\n  f.map_coord_zero i (update_same i 0 m)\n#align map_update_zero map_update_zero\n\n",
 "map_update_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem map_update_sum {α : Type _} [DecidableEq ι] (t : Finset α) (i : ι) (g : α → M₁ i) (m : ∀ i, M₁ i) :\n    f\n        (update m i\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (g a))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n        (f (update m i (g a))) :=\n  by\n  classical\n    induction' t using Finset.induction with a t has ih h\n    · simp\n    · simp [Finset.sum_insert has, ih]\n#align map_update_sum map_update_sum\n\n",
 "map_update_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_update_smul [DecidableEq ι] [Fintype ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :\n    f (update («expr • » c m) i x) = «expr • » (c ^ (Fintype.card ι - 1)) (f (update m i x)) :=\n  by\n  have :\n    f ((finset.univ.erase i).piecewise («expr • » c (update m i x)) (update m i x)) =\n      «expr • »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          (finset.univ.erase i) c)\n        (f (update m i x)) :=\n    map_piecewise_smul f _ _ _\n  simpa [← Function.update_smul c m] using this\n#align map_update_smul map_update_smul\n\n",
 "map_sum_finset_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `f` is multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. Here, we give an auxiliary statement tailored for an inductive proof. Use instead\n`map_sum_finset`. -/\ntheorem map_sum_finset_aux [DecidableEq ι] [Fintype ι] {n : ℕ}\n    (h :\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (A i).card =\n        n) :\n    (f fun i =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (piFinset A)\n        (f fun i => g i (r i)) :=\n  by\n  letI := fun i => Classical.decEq (α i)\n  induction' n using nat.strong_induction_on with n IH generalizing A\n  -- If one of the sets is empty, then all the sums are zero\n  by_cases Ai_empty : ∃ i, A i = ∅\n  · rcases Ai_empty with ⟨i, hi⟩\n    have :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j) =\n        0 :=\n      by rw [hi, Finset.sum_empty]\n    rw [f.map_coord_zero i this]\n    have : pi_finset A = ∅ := by\n      apply Finset.eq_empty_of_forall_not_mem fun r hr => _\n      have : r i ∈ A i := mem_pi_finset.mp hr i\n      rwa [hi] at this\n    rw [this, Finset.sum_empty]\n  push_neg  at Ai_empty\n  -- Otherwise, if all sets are at most singletons, then they are exactly singletons and the result\n  -- is again straightforward\n  by_cases Ai_singleton : ∀ i, (A i).card ≤ 1\n  · have Ai_card : ∀ i, (A i).card = 1 := by\n      intro i\n      have pos : Finset.card (A i) ≠ 0 := by simp [Finset.card_eq_zero, Ai_empty i]\n      have : Finset.card (A i) ≤ 1 := Ai_singleton i\n      exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos))\n    have :\n      ∀ r : ∀ i, α i,\n        r ∈ pi_finset A →\n          (f fun i => g i (r i)) =\n            f fun i =>\n              finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i)\n                (g i j) :=\n      by\n      intro r hr\n      unfold_coes\n      congr with i\n      have : ∀ j ∈ A i, g i j = g i (r i) := by\n        intro j hj\n        congr\n        apply Finset.card_le_one_iff.1 (Ai_singleton i) hj\n        exact mem_pi_finset.mp hr i\n      simp only [Finset.sum_congr rfl this, Finset.mem_univ, Finset.sum_const, Ai_card i, one_nsmul]\n    simp only [sum_congr rfl this, Ai_card, card_pi_finset, prod_const_one, one_nsmul, Finset.sum_const]\n  -- Remains the interesting case where one of the `A i`, say `A i₀`, has cardinality at least 2.\n  -- We will split into two parts `B i₀` and `C i₀` of smaller cardinality, let `B i = C i = A i`\n  -- for `i ≠ i₀`, apply the inductive assumption to `B` and `C`, and add up the corresponding\n  -- parts to get the sum for `A`.\n  push_neg  at Ai_singleton\n  obtain ⟨i₀, hi₀⟩ : ∃ i, 1 < (A i).card := Ai_singleton\n  obtain ⟨j₁, j₂, hj₁, hj₂, j₁_ne_j₂⟩ : ∃ j₁ j₂, j₁ ∈ A i₀ ∧ j₂ ∈ A i₀ ∧ j₁ ≠ j₂ := Finset.one_lt_card_iff.1 hi₀\n  let B := Function.update A i₀ (A i₀ \\ {j₂})\n  let C := Function.update A i₀ {j₂}\n  have B_subset_A : ∀ i, B i ⊆ A i := by\n    intro i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [B, sdiff_subset, update_same]\n    · simp only [hi, B, update_noteq, ne.def, not_false_iff, Finset.Subset.refl]\n  have C_subset_A : ∀ i, C i ⊆ A i := by\n    intro i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [C, hj₂, Finset.singleton_subset_iff, update_same]\n    · simp only [hi, C, update_noteq, ne.def, not_false_iff, Finset.Subset.refl]\n  -- split the sum at `i₀` as the sum over `B i₀` plus the sum over `C i₀`, to use additivity.\n  have A_eq_BC :\n    (fun i =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j)) =\n      Function.update\n        (fun i =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j))\n        i₀\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (B i₀)\n            (g i₀ j) +\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (C i₀)\n            (g i₀ j)) :=\n    by\n    ext i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [Function.update_same]\n      have : A i₀ = B i₀ ∪ C i₀ :=\n        by\n        simp only [B, C, Function.update_same, Finset.sdiff_union_self_eq_union]\n        symm\n        simp only [hj₂, Finset.singleton_subset_iff, Finset.union_eq_left_iff_subset]\n      rw [this]\n      apply Finset.sum_union\n      apply Finset.disjoint_right.2 fun j hj => _\n      have : j = j₂ := by\n        dsimp [C] at hj\n        simpa using hj\n      rw [this]\n      dsimp [B]\n      simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, Finset.mem_singleton, update_same, and_false_iff]\n    · simp [hi]\n  have Beq :\n    Function.update\n        (fun i =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j))\n        i₀\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (B i₀)\n          (g i₀ j)) =\n      fun i =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (B i) (g i j) :=\n    by\n    ext i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [update_same]\n    · simp only [hi, B, update_noteq, ne.def, not_false_iff]\n  have Ceq :\n    Function.update\n        (fun i =>\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j))\n        i₀\n        (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (C i₀)\n          (g i₀ j)) =\n      fun i =>\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (C i) (g i j) :=\n    by\n    ext i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [update_same]\n    · simp only [hi, C, update_noteq, ne.def, not_false_iff]\n  -- Express the inductive assumption for `B`\n  have Brec :\n    (f fun i =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (B i) (g i j)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (pi_finset B)\n        (f fun i => g i (r i)) :=\n    by\n    have :\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (Finset.card (B i)) <\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (Finset.card (A i)) :=\n      by\n      refine' Finset.sum_lt_sum (fun i hi => Finset.card_le_of_subset (B_subset_A i)) ⟨i₀, Finset.mem_univ _, _⟩\n      have : {j₂} ⊆ A i₀ := by simp [hj₂]\n      simp only [B, Finset.card_sdiff this, Function.update_same, Finset.card_singleton]\n      exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi₀))\n    rw [h] at this\n    exact IH _ this B rfl\n  -- Express the inductive assumption for `C`\n  have Crec :\n    (f fun i =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (C i) (g i j)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (pi_finset C)\n        (f fun i => g i (r i)) :=\n    by\n    have :\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (Finset.card (C i)) <\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (Finset.card (A i)) :=\n      Finset.sum_lt_sum (fun i hi => Finset.card_le_of_subset (C_subset_A i)) ⟨i₀, Finset.mem_univ _, by simp [C, hi₀]⟩\n    rw [h] at this\n    exact IH _ this C rfl\n  have D : Disjoint (pi_finset B) (pi_finset C) :=\n    haveI : Disjoint (B i₀) (C i₀) := by simp [B, C]\n    pi_finset_disjoint_of_disjoint B C this\n  have pi_BC : pi_finset A = pi_finset B ∪ pi_finset C :=\n    by\n    apply Finset.Subset.antisymm\n    · intro r hr\n      by_cases hri₀ : r i₀ = j₂\n      · apply Finset.mem_union_right\n        apply mem_pi_finset.2 fun i => _\n        by_cases hi : i = i₀\n        · have : r i₀ ∈ C i₀ := by simp [C, hri₀]\n          convert this\n        · simp [C, hi, mem_pi_finset.1 hr i]\n      · apply Finset.mem_union_left\n        apply mem_pi_finset.2 fun i => _\n        by_cases hi : i = i₀\n        · have : r i₀ ∈ B i₀ := by simp [B, hri₀, mem_pi_finset.1 hr i₀]\n          convert this\n        · simp [B, hi, mem_pi_finset.1 hr i]\n    ·\n      exact\n        Finset.union_subset (pi_finset_subset _ _ fun i => B_subset_A i) (pi_finset_subset _ _ fun i => C_subset_A i)\n  rw [A_eq_BC]\n  simp only [MultilinearMap.map_add, Beq, Ceq, Brec, Crec, pi_BC]\n  rw [← Finset.sum_union D]\n#align map_sum_finset_aux map_sum_finset_aux\n\n",
 "map_sum_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If `f` is multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. -/\ntheorem map_sum_finset [DecidableEq ι] [Fintype ι] :\n    (f fun i =>\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (A i) (g i j)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (piFinset A)\n        (f fun i => g i (r i)) :=\n  f.map_sum_finset_aux _ _ rfl\n#align map_sum_finset map_sum_finset\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n#print map_sum /-\n/-- If `f` is multilinear, then `f (Σ_{j₁} g₁ j₁, ..., Σ_{jₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. -/\ntheorem map_sum [DecidableEq ι] [Fintype ι] [∀ i, Fintype (α i)] :\n    (f fun i =>\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          (g i j)) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (f fun i => g i (r i)) :=\n  f.map_sum_finset g fun i => Finset.univ\n#align map_sum map_sum\n-/\n\n",
 "map_sub":
 "#print map_sub /-\n@[simp]\ntheorem map_sub [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y) := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, MultilinearMap.map_add, map_neg]\n#align map_sub map_sub\n-/\n\n",
 "map_smul_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/-- Multiplicativity of a multilinear map along all coordinates at the same time,\nwriting `f (λi, c i • m i)` as `(∏ i, c i) • f m`. -/\ntheorem map_smul_univ [Fintype ι] (c : ι → R) (m : ∀ i, M₁ i) :\n    (f fun i => «expr • » (c i) (m i)) =\n      «expr • »\n        (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (c i))\n        (f m) :=\n  by classical simpa using map_piecewise_smul f c m Finset.univ\n#align map_smul_univ map_smul_univ\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\nprotected theorem map_smul [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :\n    f (update m i («expr • » c x)) = «expr • » c (f (update m i x)) :=\n  f.map_smul' m i c x\n#align map_smul map_smul\n\n",
 "map_piecewise_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- If one multiplies by `c i` the coordinates in a finset `s`, then the image under a multilinear\nmap is multiplied by `∏ i in s, c i`. This is mainly an auxiliary statement to prove the result when\n`s = univ`, given in `map_smul_univ`, although it can be useful in its own right as it does not\nrequire the index set `ι` to be finite. -/\ntheorem map_piecewise_smul [DecidableEq ι] (c : ι → R) (m : ∀ i, M₁ i) (s : Finset ι) :\n    f (s.piecewise (fun i => «expr • » (c i) (m i)) m) =\n      «expr • »\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (c i))\n        (f m) :=\n  by\n  refine' s.induction_on (by simp) _\n  intro j s j_not_mem_s Hrec\n  have A :\n    Function.update (s.piecewise (fun i => «expr • » (c i) (m i)) m) j (m j) =\n      s.piecewise (fun i => «expr • » (c i) (m i)) m :=\n    by\n    ext i\n    by_cases h : i = j\n    · rw [h]\n      simp [j_not_mem_s]\n    · simp [h]\n  rw [s.piecewise_insert, f.map_smul, A, Hrec]\n  simp [j_not_mem_s, mul_smul]\n#align map_piecewise_smul map_piecewise_smul\n\n",
 "map_piecewise_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- If one adds to a vector `m'` another vector `m`, but only for coordinates in a finset `t`, then\nthe image under a multilinear map `f` is the sum of `f (s.piecewise m m')` along all subsets `s` of\n`t`. This is mainly an auxiliary statement to prove the result when `t = univ`, given in\n`map_add_univ`, although it can be useful in its own right as it does not require the index set `ι`\nto be finite.-/\ntheorem map_piecewise_add [DecidableEq ι] (m m' : ∀ i, M₁ i) (t : Finset ι) :\n    f (t.piecewise (m + m') m') =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t.powerset\n        (f (s.piecewise m m')) :=\n  by\n  revert m'\n  refine' Finset.induction_on t (by simp) _\n  intro i t hit Hrec m'\n  have A : (insert i t).piecewise (m + m') m' = update (t.piecewise (m + m') m') i (m i + m' i) :=\n    t.piecewise_insert _ _ _\n  have B : update (t.piecewise (m + m') m') i (m' i) = t.piecewise (m + m') m' :=\n    by\n    ext j\n    by_cases h : j = i\n    · rw [h]\n      simp [hit]\n    · simp [h]\n  let m'' := update m' i (m i)\n  have C : update (t.piecewise (m + m') m') i (m i) = t.piecewise (m + m'') m'' :=\n    by\n    ext j\n    by_cases h : j = i\n    · rw [h]\n      simp [m'', hit]\n    · by_cases h' : j ∈ t <;> simp [h, hit, m'', h']\n  rw [A, f.map_add, B, C, Finset.sum_powerset_insert hit, Hrec, Hrec, add_comm]\n  congr 1\n  apply Finset.sum_congr rfl fun s hs => _\n  have : (insert i s).piecewise m m' = s.piecewise m m'' :=\n    by\n    ext j\n    by_cases h : j = i\n    · rw [h]\n      simp [m'', Finset.not_mem_of_mem_powerset_of_not_mem hs hit]\n    · by_cases h' : j ∈ s <;> simp [h, m'', h']\n  rw [this]\n#align map_piecewise_add map_piecewise_add\n\n",
 "map_nonempty":
 "/-- The map is always nonempty. This lemma is needed to apply `sub_mul_action.zero_mem`. -/\ntheorem map_nonempty [Nonempty ι] (f : MultilinearMap R M₁ M₂) (p : ∀ i, Submodule R (M₁ i)) :\n    (map f p : Set M₂).nonempty :=\n  ⟨f 0, 0, fun i => (p i).zero_mem, rfl⟩\n#align map_nonempty map_nonempty\n\n",
 "map_neg":
 "#print map_neg /-\n@[simp]\ntheorem map_neg [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x : M₁ i) : f (update m i (-x)) = -f (update m i x) :=\n  eq_neg_of_add_eq_zero_left <| by rw [← MultilinearMap.map_add, add_left_neg, f.map_coord_zero i (update_same i 0 m)]\n#align map_neg map_neg\n-/\n\n",
 "map_coord_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_coord_zero {m : ∀ i, M₁ i} (i : ι) (h : m i = 0) : f m = 0 := by\n  classical\n    have : «expr • » (0 : R) (0 : M₁ i) = 0 := by simp\n    rw [← update_eq_self i m, h, ← this, f.map_smul, zero_smul]\n#align map_coord_zero map_coord_zero\n\n",
 "map_add_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- Additivity of a multilinear map along all coordinates at the same time,\nwriting `f (m + m')` as the sum  of `f (s.piecewise m m')` over all sets `s`. -/\ntheorem map_add_univ [DecidableEq ι] [Fintype ι] (m m' : ∀ i, M₁ i) :\n    f (m + m') =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (f (s.piecewise m m')) :=\n  by simpa using f.map_piecewise_add m m' Finset.univ\n#align map_add_univ map_add_univ\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\nprotected theorem map_add [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y) :=\n  f.map_add' m i x y\n#align map_add map_add\n-/\n\n",
 "ext_iff":
 "theorem ext_iff {f g : MultilinearMap R M₁ M₂} : f = g ↔ ∀ x, f x = g x :=\n  ⟨fun h x => h ▸ rfl, fun h => ext h⟩\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext {f f' : MultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=\n  coe_injective (funext H)\n#align ext ext\n\n",
 "dom_dom_congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem dom_dom_congr_trans (σ₁ : «expr ≃ » ι₁ ι₂) (σ₂ : «expr ≃ » ι₂ ι₃) (m : MultilinearMap R (fun i : ι₁ => M₂) M₃) :\n    m.dom_dom_congr (σ₁.trans σ₂) = (m.dom_dom_congr σ₁).dom_dom_congr σ₂ :=\n  rfl\n#align dom_dom_congr_trans dom_dom_congr_trans\n\n",
 "dom_dom_congr_mul":
 "theorem dom_dom_congr_mul (σ₁ : Equiv.Perm ι₁) (σ₂ : Equiv.Perm ι₁) (m : MultilinearMap R (fun i : ι₁ => M₂) M₃) :\n    m.dom_dom_congr (σ₂ * σ₁) = (m.dom_dom_congr σ₁).dom_dom_congr σ₂ :=\n  rfl\n#align dom_dom_congr_mul dom_dom_congr_mul\n\n",
 "dom_dom_congr_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- The results of applying `dom_dom_congr` to two maps are equal if\nand only if those maps are. -/\n@[simp]\ntheorem dom_dom_congr_eq_iff (σ : «expr ≃ » ι₁ ι₂) (f g : MultilinearMap R (fun i : ι₁ => M₂) M₃) :\n    f.dom_dom_congr σ = g.dom_dom_congr σ ↔ f = g :=\n  (domDomCongrEquiv σ : «expr ≃+ » _ (MultilinearMap R (fun i => M₂) M₃)).apply_eq_iff_eq\n#align dom_dom_congr_eq_iff dom_dom_congr_eq_iff\n\n",
 "curry_uncurryRight":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print MultilinearMap.curry_uncurryRight /-\n@[simp]\ntheorem MultilinearMap.curry_uncurryRight\n    (f : MultilinearMap R (fun i : Fin n => M i.cast_succ) («expr →ₗ[ ] » (M (last n)) R M₂)) :\n    f.uncurry_right.curry_right = f := by\n  ext (m x)\n  simp only [snoc_last, MultilinearMap.curryRight_apply, MultilinearMap.uncurryRight_apply]\n  rw [init_snoc]\n#align multilinear_map.curry_uncurry_right MultilinearMap.curry_uncurryRight\n-/\n\n",
 "curry_uncurryLeft":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.curry_uncurryLeft /-\n@[simp]\ntheorem LinearMap.curry_uncurryLeft (f : «expr →ₗ[ ] » (M 0) R (MultilinearMap R (fun i : Fin n => M i.succ) M₂)) :\n    f.uncurry_left.curry_left = f := by\n  ext (m x)\n  simp only [tail_cons, LinearMap.uncurryLeft_apply, MultilinearMap.curryLeft_apply]\n  rw [cons_zero]\n#align linear_map.curry_uncurry_left LinearMap.curry_uncurryLeft\n-/\n\n",
 "curry_sum_apply":
 "@[simp]\ntheorem curry_sum_apply (f : MultilinearMap R (fun x : Sum ι ι' => M') M₂) (u : ι → M') (v : ι' → M') :\n    f.curry_sum u v = f (Sum.elim u v) :=\n  rfl\n#align curry_sum_apply curry_sum_apply\n\n",
 "curry_fin_finset_symm_apply_piecewise_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem curry_fin_finset_symm_apply_piecewise_const {k l n : ℕ} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : («expr ᶜ» s).card = l)\n    (f : MultilinearMap R (fun x : Fin k => M') (MultilinearMap R (fun x : Fin l => M') M₂)) (x y : M') :\n    (curryFinFinset R M₂ M' hk hl).symm f (s.piecewise (fun _ => x) fun _ => y) = f (fun _ => x) fun _ => y :=\n  by\n  rw [curry_fin_finset_symm_apply]; congr\n  · ext i\n    rw [finSumEquivOfFinset_inl, Finset.piecewise_eq_of_mem]\n    apply Finset.orderEmbOfFin_mem\n  · ext i\n    rw [finSumEquivOfFinset_inr, Finset.piecewise_eq_of_not_mem]\n    exact Finset.mem_compl.1 (Finset.orderEmbOfFin_mem _ _ _)\n#align curry_fin_finset_symm_apply_piecewise_const curry_fin_finset_symm_apply_piecewise_const\n\n",
 "curry_fin_finset_symm_apply_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem curry_fin_finset_symm_apply_const {k l n : ℕ} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : («expr ᶜ» s).card = l)\n    (f : MultilinearMap R (fun x : Fin k => M') (MultilinearMap R (fun x : Fin l => M') M₂)) (x : M') :\n    ((curryFinFinset R M₂ M' hk hl).symm f fun _ => x) = f (fun _ => x) fun _ => x :=\n  rfl\n#align curry_fin_finset_symm_apply_const curry_fin_finset_symm_apply_const\n\n",
 "curry_fin_finset_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem curry_fin_finset_symm_apply {k l n : ℕ} {s : Finset (Fin n)} (hk : s.card = k) (hl : («expr ᶜ» s).card = l)\n    (f : MultilinearMap R (fun x : Fin k => M') (MultilinearMap R (fun x : Fin l => M') M₂)) (m : Fin n → M') :\n    (curryFinFinset R M₂ M' hk hl).symm f m =\n      f (fun i => m <| finSumEquivOfFinset hk hl (Sum.inl i)) fun i => m <| finSumEquivOfFinset hk hl (Sum.inr i) :=\n  rfl\n#align curry_fin_finset_symm_apply curry_fin_finset_symm_apply\n\n",
 "curry_fin_finset_apply_const":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem curry_fin_finset_apply_const {k l n : ℕ} {s : Finset (Fin n)} (hk : s.card = k) (hl : («expr ᶜ» s).card = l)\n    (f : MultilinearMap R (fun x : Fin n => M') M₂) (x y : M') :\n    (curryFinFinset R M₂ M' hk hl f (fun _ => x) fun _ => y) = f (s.piecewise (fun _ => x) fun _ => y) :=\n  by\n  refine' (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _\n  -- `rw` fails\n  rw [LinearEquiv.symm_apply_apply]\n#align curry_fin_finset_apply_const curry_fin_finset_apply_const\n\n",
 "curry_fin_finset_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ᶜ» -/\n@[simp]\ntheorem curry_fin_finset_apply {k l n : ℕ} {s : Finset (Fin n)} (hk : s.card = k) (hl : («expr ᶜ» s).card = l)\n    (f : MultilinearMap R (fun x : Fin n => M') M₂) (mk : Fin k → M') (ml : Fin l → M') :\n    curryFinFinset R M₂ M' hk hl f mk ml = f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i) :=\n  rfl\n#align curry_fin_finset_apply curry_fin_finset_apply\n\n",
 "curryRight_apply":
 "#print MultilinearMap.curryRight_apply /-\n@[simp]\ntheorem MultilinearMap.curryRight_apply (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.cast_succ) (x : M (last n)) :\n    f.curry_right m x = f (snoc m x) :=\n  rfl\n#align multilinear_map.curry_right_apply MultilinearMap.curryRight_apply\n-/\n\n",
 "curryLeft_apply":
 "#print MultilinearMap.curryLeft_apply /-\n@[simp]\ntheorem MultilinearMap.curryLeft_apply (f : MultilinearMap R M M₂) (x : M 0) (m : ∀ i : Fin n, M i.succ) :\n    f.curry_left x m = f (cons x m) :=\n  rfl\n#align multilinear_map.curry_left_apply MultilinearMap.curryLeft_apply\n-/\n\n",
 "cons_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- In the specific case of multilinear maps on spaces indexed by `fin (n+1)`, where one can build\nan element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the multiplicativity\nof a multilinear map along the first variable. -/\ntheorem cons_smul (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (c : R) (x : M 0) :\n    f (cons («expr • » c x) m) = «expr • » c (f (cons x m)) := by\n  rw [← update_cons_zero x m («expr • » c x), f.map_smul, update_cons_zero]\n#align cons_smul cons_smul\n\n",
 "cons_add":
 "/-- In the specific case of multilinear maps on spaces indexed by `fin (n+1)`, where one can build\nan element of `Π(i : fin (n+1)), M i` using `cons`, one can express directly the additivity of a\nmultilinear map along the first variable. -/\ntheorem cons_add (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (x y : M 0) :\n    f (cons (x + y) m) = f (cons x m) + f (cons y m) := by\n  rw [← update_cons_zero x m (x + y), f.map_add, update_cons_zero, update_cons_zero]\n#align cons_add cons_add\n\n",
 "congr_fun":
 "#print congr_fun /-\ntheorem congr_fun {f g : MultilinearMap R M₁ M₂} (h : f = g) (x : ∀ i, M₁ i) : f x = g x :=\n  congr_arg (fun h : MultilinearMap R M₁ M₂ => h x) h\n#align congr_fun congr_fun\n-/\n\n",
 "congr_arg":
 "#print congr_arg /-\ntheorem congr_arg (f : MultilinearMap R M₁ M₂) {x y : ∀ i, M₁ i} (h : x = y) : f x = f y :=\n  congr_arg (fun x : ∀ i, M₁ i => f x) h\n#align congr_arg congr_arg\n-/\n\n",
 "comp_multilinear_map_dom_dom_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_multilinear_map_dom_dom_congr (σ : «expr ≃ » ι₁ ι₂) (g : «expr →ₗ[ ] » M₂ R M₃)\n    (f : MultilinearMap R (fun i : ι₁ => M') M₂) :\n    (g.comp_multilinear_map f).dom_dom_congr σ = g.comp_multilinear_map (f.dom_dom_congr σ) :=\n  by\n  ext\n  simp\n#align comp_multilinear_map_dom_dom_congr comp_multilinear_map_dom_dom_congr\n\n",
 "comp_multilinear_map_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The multilinear version of `linear_map.comp_cod_restrict` -/\n@[simp]\ntheorem comp_multilinear_map_cod_restrict (g : «expr →ₗ[ ] » M₂ R M₃) (f : MultilinearMap R M₁ M₂) (p : Submodule R M₃)\n    (h) : (g.cod_restrict p h).comp_multilinear_map f = (g.comp_multilinear_map f).cod_restrict p fun v => h (f v) :=\n  MultilinearMap.ext fun v => rfl\n#align comp_multilinear_map_cod_restrict comp_multilinear_map_cod_restrict\n\n",
 "comp_multilinear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_multilinear_map_apply (g : «expr →ₗ[ ] » M₂ R M₃) (f : MultilinearMap R M₁ M₂) (m : ∀ i, M₁ i) :\n    g.comp_multilinear_map f m = g (f m) :=\n  rfl\n#align comp_multilinear_map_apply comp_multilinear_map_apply\n\n",
 "comp_linear_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing with a family of surjective linear maps is injective. -/\ntheorem comp_linear_map_injective (f : ∀ i, «expr →ₗ[ ] » (M₁ i) R (M₁' i)) (hf : ∀ i, surjective (f i)) :\n    injective fun g : MultilinearMap R M₁' M₂ => g.comp_linear_map f := fun g₁ g₂ h =>\n  ext fun x => by simpa [fun i => surj_inv_eq (hf i)] using ext_iff.mp h fun i => surj_inv (hf i) (x i)\n#align comp_linear_map_injective comp_linear_map_injective\n\n",
 "comp_linear_map_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem comp_linear_map_inj (f : ∀ i, «expr →ₗ[ ] » (M₁ i) R (M₁' i)) (hf : ∀ i, surjective (f i))\n    (g₁ g₂ : MultilinearMap R M₁' M₂) : g₁.comp_linear_map f = g₂.comp_linear_map f ↔ g₁ = g₂ :=\n  (compLinearMap_injective _ hf).eq_iff\n#align comp_linear_map_inj comp_linear_map_inj\n\n",
 "comp_linear_map_id":
 "/-- Composing a multilinear map with the identity linear map in each argument. -/\n@[simp]\ntheorem comp_linear_map_id (g : MultilinearMap R M₁' M₂) : (g.comp_linear_map fun i => LinearMap.id) = g :=\n  ext fun _ => rfl\n#align comp_linear_map_id comp_linear_map_id\n\n",
 "comp_linear_map_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- Composing a multilinear map twice with a linear map in each argument is\nthe same as composing with their composition. -/\ntheorem comp_linear_map_assoc (g : MultilinearMap R M₁'' M₂) (f₁ : ∀ i, «expr →ₗ[ ] » (M₁' i) R (M₁'' i))\n    (f₂ : ∀ i, «expr →ₗ[ ] » (M₁ i) R (M₁' i)) :\n    (g.comp_linear_map f₁).comp_linear_map f₂ = g.comp_linear_map fun i => «expr ∘ₗ » (f₁ i) (f₂ i) :=\n  rfl\n#align comp_linear_map_assoc comp_linear_map_assoc\n\n",
 "comp_linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_linear_map_apply (g : MultilinearMap R M₁' M₂) (f : ∀ i, «expr →ₗ[ ] » (M₁ i) R (M₁' i)) (m : ∀ i, M₁ i) :\n    g.comp_linear_map f m = g fun i => f i (m i) :=\n  rfl\n#align comp_linear_map_apply comp_linear_map_apply\n\n",
 "comp_linear_equiv_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing a multilinear map with a linear equiv on each argument gives the zero map\nif and only if the multilinear map is the zero map. -/\n@[simp]\ntheorem comp_linear_equiv_eq_zero_iff (g : MultilinearMap R M₁' M₂) (f : ∀ i, «expr ≃ₗ[ ] » (M₁ i) R (M₁' i)) :\n    (g.comp_linear_map fun i => (f i : «expr →ₗ[ ] » (M₁ i) R (M₁' i))) = 0 ↔ g = 0 :=\n  by\n  set f' := fun i => (f i : «expr →ₗ[ ] » (M₁ i) R (M₁' i))\n  rw [← zero_comp_linear_map f', comp_linear_map_inj f' fun i => (f i).surjective]\n#align comp_linear_equiv_eq_zero_iff comp_linear_equiv_eq_zero_iff\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem coe_smul (c : R') (f : MultilinearMap A M₁ M₂) : «expr⇑ » («expr • » c f) = «expr • » c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_restrict_scalars (f : MultilinearMap A M₁ M₂) : «expr⇑ » (f.restrict_scalars R) = f :=\n  rfl\n#align coe_restrict_scalars coe_restrict_scalars\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk (f : (∀ i, M₁ i) → M₂) (h₁ h₂) : «expr⇑ » (⟨f, h₁, h₂⟩ : MultilinearMap R M₁ M₂) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_injective":
 "theorem coe_injective : injective (coe_fn : MultilinearMap R M₁ M₂ → (∀ i, M₁ i) → M₂) :=\n  by\n  intro f g h\n  cases f\n  cases g\n  cases h\n  rfl\n#align coe_injective coe_injective\n\n",
 "coe_inj":
 "@[simp, norm_cast]\ntheorem coe_inj {f g : MultilinearMap R M₁ M₂} : (f : (∀ i, M₁ i) → M₂) = g ↔ f = g :=\n  coe_injective.eq_iff\n#align coe_inj coe_inj\n\n",
 "coe_curry_sum_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_curry_sum_equiv : «expr⇑ » (currySumEquiv R ι M₂ M' ι') = currySum :=\n  rfl\n#align coe_curry_sum_equiv coe_curry_sum_equiv\n\n",
 "coe_curr_sum_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_curr_sum_equiv_symm : «expr⇑ » (currySumEquiv R ι M₂ M' ι').symm = uncurrySum :=\n  rfl\n#align coe_curr_sum_equiv_symm coe_curr_sum_equiv_symm\n\n",
 "coe_comp_multilinear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_comp_multilinear_map (g : «expr →ₗ[ ] » M₂ R M₃) (f : MultilinearMap R M₁ M₂) :\n    «expr⇑ » (g.comp_multilinear_map f) = g ∘ f :=\n  rfl\n#align coe_comp_multilinear_map coe_comp_multilinear_map\n\n",
 "add_apply":
 "@[simp]\ntheorem add_apply (m : ∀ i, M₁ i) : (f + f') m = f m + f' m :=\n  rfl\n#align add_apply add_apply\n\n"}