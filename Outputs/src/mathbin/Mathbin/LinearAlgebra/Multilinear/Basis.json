{"ext_multilinear_fin":
 "#print Basis.ext_multilinear_fin /-\n/-\nCopyright (c) 2021 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n/-- Two multilinear maps indexed by `fin n` are equal if they are equal when all arguments are\nbasis vectors. -/\ntheorem Basis.ext_multilinear_fin {f g : MultilinearMap R M M₂} {ι₁ : Fin n → Type _} (e : ∀ i, Basis (ι₁ i) R (M i))\n    (h : ∀ v : ∀ i, ι₁ i, (f fun i => e i (v i)) = g fun i => e i (v i)) : f = g :=\n  by\n  induction' n with m hm\n  · ext x\n    convert h finZeroElim\n  · apply function.left_inverse.injective uncurry_curry_left\n    refine' Basis.ext (e 0) _\n    intro i\n    apply hm (Fin.tail e)\n    intro j\n    convert h (Fin.cons i j)\n    iterate 2 \n      rw [curry_left_apply]\n      congr 1 with x\n      refine' Fin.cases rfl (fun x => _) x\n      dsimp [Fin.tail]\n      rw [Fin.cons_succ, Fin.cons_succ]\n#align basis.ext_multilinear_fin Basis.ext_multilinear_fin\n-/\n\n",
 "ext_multilinear":
 "#print Basis.ext_multilinear /-\n/-- Two multilinear maps indexed by a `fintype` are equal if they are equal when all arguments\nare basis vectors. Unlike `basis.ext_multilinear_fin`, this only uses a single basis; a\ndependently-typed version would still be true, but the proof would need a dependently-typed\nversion of `dom_dom_congr`. -/\ntheorem Basis.ext_multilinear [Finite ι] {f g : MultilinearMap R (fun i : ι => M₂) M₃} {ι₁ : Type _} (e : Basis ι₁ R M₂)\n    (h : ∀ v : ι → ι₁, (f fun i => e (v i)) = g fun i => e (v i)) : f = g :=\n  by\n  cases nonempty_fintype ι\n  exact (dom_dom_congr_eq_iff (Fintype.equivFin ι) f g).mp (Basis.ext_multilinear_fin (fun i => e) fun i => h (i ∘ _))\n#align basis.ext_multilinear Basis.ext_multilinear\n-/\n\n"}