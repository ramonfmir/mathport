{"zero_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n-- Even though these are implied by `subsingleton.elim` via the `unique` instance below, they're\n-- nice to have as `rfl`-lemmas for `dsimp`.\n@[simp]\ntheorem zero_symm : (0 : «expr ≃ₛₗ[ ] » M σ₁₂ M₂).symm = 0 :=\n  rfl\n#align zero_symm zero_symm\n\n",
 "zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\ntheorem zero_apply (x : M) : (0 : «expr ≃ₛₗ[ ] » M σ₁₂ M₂) x = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "symm_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem symm_neg : (neg R : «expr ≃ₗ[ ] » M R M).symm = neg R :=\n  rfl\n#align symm_neg symm_neg\n\n",
 "symm_conj_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem symm_conj_apply (e : «expr ≃ₗ[ ] » M R M₂) (f : Module.End R M₂) :\n    e.symm.conj f = ((↑e.symm : «expr →ₗ[ ] » M₂ R M).comp f).comp (e : «expr →ₗ[ ] » M R M₂) :=\n  rfl\n#align symm_conj_apply symm_conj_apply\n\n",
 "surjective_of_iterate_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem surjective_of_iterate_surjective {n : ℕ} (hn : n ≠ 0) (h : surjective («expr⇑ » (f' ^ n))) : surjective f' :=\n  by\n  rw [← nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr hn), nat.succ_eq_add_one, add_comm, pow_add] at h\n  exact surjective.of_comp h\n#align surjective_of_iterate_surjective surjective_of_iterate_surjective\n\n",
 "sum_smul_index_linear_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem sum_smul_index_linear_map' {α : Type _} {R : Type _} {M : Type _} {M₂ : Type _} [Semiring R] [AddCommMonoid M]\n    [Module R M] [AddCommMonoid M₂] [Module R M₂] {v : «expr →₀ » α M} {c : R} {h : α → «expr →ₗ[ ] » M R M₂} :\n    ((«expr • » c v).sum fun a => h a) = «expr • » c (v.sum fun a => h a) :=\n  by\n  rw [Finsupp.sum_smul_index', Finsupp.smul_sum]\n  · simp only [map_smul]\n  · intro i\n    exact (h i).map_zero\n#align sum_smul_index_linear_map' sum_smul_index_linear_map'\n\n",
 "sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_apply (t : Finset ι) (f : ι → «expr →ₛₗ[ ] » M σ₁₂ M₂) (b : M) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d)) b =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f d b) :=\n  AddMonoidHom.map_sum ((AddMonoidHom.eval b).comp toAddMonoidHom') f _\n#align sum_apply sum_apply\n\n",
 "subtype_comp_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem subtype_comp_restrict {f : «expr →ₗ[ ] » M R M₁} {p : Submodule R M} {q : Submodule R M₁}\n    (hf : ∀ x ∈ p, f x ∈ q) : q.subtype.comp (f.restrict hf) = f.dom_restrict p :=\n  rfl\n#align subtype_comp_restrict subtype_comp_restrict\n\n",
 "subtype_comp_of_le":
 "theorem subtype_comp_of_le (p q : Submodule R M) (h : p ≤ q) : q.subtype.comp (ofLe h) = p.subtype :=\n  by\n  ext ⟨b, hb⟩\n  rfl\n#align subtype_comp_of_le subtype_comp_of_le\n\n",
 "subtype_comp_cod_restrict":
 "@[simp]\ntheorem subtype_comp_cod_restrict (p : Submodule R₂ M₂) (h : ∀ b, f b ∈ p) : p.subtype.comp (codRestrict p f h) = f :=\n  ext fun b => rfl\n#align subtype_comp_cod_restrict subtype_comp_cod_restrict\n\n",
 "subsingleton_iff":
 "#print subsingleton_iff /-\n@[simp]\ntheorem subsingleton_iff : subsingleton (Submodule R M) ↔ subsingleton M :=\n  have h : subsingleton (Submodule R M) ↔ subsingleton (AddSubmonoid M) :=\n    by\n    rw [← subsingleton_iff_bot_eq_top, ← subsingleton_iff_bot_eq_top]\n    convert to_add_submonoid_eq.symm <;> rfl\n  h.trans AddSubmonoid.subsingleton_iff\n#align subsingleton_iff subsingleton_iff\n-/\n\n",
 "submodule_pow_eq_zero_of_pow_eq_zero":
 "theorem submodule_pow_eq_zero_of_pow_eq_zero {N : Submodule R M} {g : Module.End R N} {G : Module.End R M}\n    (h : G.comp N.subtype = N.subtype.comp g) {k : ℕ} (hG : G ^ k = 0) : g ^ k = 0 :=\n  by\n  ext m\n  have hg : N.subtype.comp (g ^ k) m = 0 := by rw [← commute_pow_left_of_commute h, hG, zero_comp, zero_apply]\n  simp only [Submodule.subtype_apply, comp_app, Submodule.coe_eq_zero, coe_comp] at hg\n  rw [hg, LinearMap.zero_apply]\n#align submodule_pow_eq_zero_of_pow_eq_zero submodule_pow_eq_zero_of_pow_eq_zero\n\n",
 "submodule_map_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem submodule_map_symm_apply (p : Submodule R M) (x : (p.map (e : «expr →ₛₗ[ ] » M σ₁₂ M₂) : Submodule R₂ M₂)) :\n    ↑((e.submodule_map p).symm x) = e.symm x :=\n  rfl\n#align submodule_map_symm_apply submodule_map_symm_apply\n\n",
 "submodule_map_apply":
 "@[simp]\ntheorem submodule_map_apply (p : Submodule R M) (x : p) : ↑(e.submodule_map p x) = e x :=\n  rfl\n#align submodule_map_apply submodule_map_apply\n\n",
 "submodule_image_apply_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem submodule_image_apply_of_le {M' : Type _} [AddCommGroup M'] [Module R M'] {O : Submodule R M}\n    (ϕ : «expr →ₗ[ ] » O R M') (N : Submodule R M) (hNO : N ≤ O) :\n    ϕ.submodule_image N = (ϕ.comp (Submodule.ofLe hNO)).range := by\n  rw [submodule_image, range_comp, Submodule.range_ofLe]\n#align submodule_image_apply_of_le submodule_image_apply_of_le\n\n",
 "sub_mem_ker_iff":
 "theorem sub_mem_ker_iff {x y} : x - y ∈ ker f ↔ f x = f y := by rw [mem_ker, map_sub, sub_eq_zero]\n#align sub_mem_ker_iff sub_mem_ker_iff\n\n",
 "smul_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mario Carneiro, Kevin Buzzard, Yury Kudryashov, Frédéric Dupuis,\n  Heather Macbeth\n-/\ntheorem smul_sum {α : Type _} {β : Type _} {R : Type _} {M : Type _} [Zero β] [AddCommMonoid M] [DistribSMul R M]\n    {v : «expr →₀ » α β} {c : R} {h : α → β → M} : «expr • » c (v.sum h) = v.sum fun a b => «expr • » c (h a b) :=\n  Finset.smul_sum\n#align smul_sum smul_sum\n\n",
 "smul_rightₗ_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_rightₗ_apply (f : «expr →ₗ[ ] » M₂ R R) (x : M) (c : M₂) :\n    (smulRightₗ : «expr →ₗ[ ] » («expr →ₗ[ ] » M₂ R R) R («expr →ₗ[ ] » M R («expr →ₗ[ ] » M₂ R M))) f x c =\n      «expr • » (f c) x :=\n  rfl\n#align smul_rightₗ_apply smul_rightₗ_apply\n\n",
 "smul_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem smul_right_apply (f : «expr →ₗ[ ] » M₁ R S) (x : M) (c : M₁) : smulRight f x c = «expr • » (f c) x :=\n  rfl\n#align smul_right_apply smul_right_apply\n\n",
 "restrict_eq_dom_restrict_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem restrict_eq_dom_restrict_cod_restrict {f : «expr →ₗ[ ] » M R M₁} {p : Submodule R M} {q : Submodule R M₁}\n    (hf : ∀ x, f x ∈ q) : (f.restrict fun x _ => hf x) = (f.cod_restrict q hf).dom_restrict p :=\n  rfl\n#align restrict_eq_dom_restrict_cod_restrict restrict_eq_dom_restrict_cod_restrict\n\n",
 "restrict_eq_cod_restrict_dom_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem restrict_eq_cod_restrict_dom_restrict {f : «expr →ₗ[ ] » M R M₁} {p : Submodule R M} {q : Submodule R M₁}\n    (hf : ∀ x ∈ p, f x ∈ q) : f.restrict hf = (f.dom_restrict p).cod_restrict q fun x => hf x.1 x.2 :=\n  rfl\n#align restrict_eq_cod_restrict_dom_restrict restrict_eq_cod_restrict_dom_restrict\n\n",
 "restrict_coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem restrict_coe_apply (f : «expr →ₗ[ ] » M R M₁) {p : Submodule R M} {q : Submodule R M₁} (hf : ∀ x ∈ p, f x ∈ q)\n    (x : p) : ↑(f.restrict hf x) = f x :=\n  rfl\n#align restrict_coe_apply restrict_coe_apply\n\n",
 "restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem restrict_apply {f : «expr →ₗ[ ] » M R M₁} {p : Submodule R M} {q : Submodule R M₁} (hf : ∀ x ∈ p, f x ∈ q)\n    (x : p) : f.restrict hf x = ⟨f x, hf x.1 x.2⟩ :=\n  rfl\n#align restrict_apply restrict_apply\n\n",
 "range_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem range_zero [RingHomSurjective τ₁₂] : range (0 : «expr →ₛₗ[ ] » M τ₁₂ M₂) = «expr⊥» := by\n  simpa only [range_eq_map] using Submodule.map_zero _\n#align range_zero range_zero\n\n",
 "range_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_to_add_submonoid [RingHomSurjective τ₁₂] (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) :\n    f.range.to_add_submonoid = f.to_add_monoid_hom.mrange :=\n  rfl\n#align range_to_add_submonoid range_to_add_submonoid\n\n",
 "range_to_add_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_to_add_subgroup [RingHomSurjective τ₁₂] (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) :\n    f.range.to_add_subgroup = f.to_add_monoid_hom.range :=\n  rfl\n#align range_to_add_subgroup range_to_add_subgroup\n\n",
 "range_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_subtype : p.subtype.range = p := by simpa using map_comap_subtype p («expr⊤»)\n#align range_subtype range_subtype\n\n",
 "range_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem range_smul' (f : «expr →ₗ[ ] » V K V₂) (a : K) :\n    range («expr • » a f) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (range f) :=\n  by simpa only [range_eq_map] using Submodule.map_smul' f _ a\n#align range_smul' range_smul'\n\n",
 "range_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem range_smul (f : «expr →ₗ[ ] » V K V₂) (a : K) (h : a ≠ 0) : range («expr • » a f) = range f := by\n  simpa only [range_eq_map] using Submodule.map_smul f _ a h\n#align range_smul range_smul\n\n",
 "range_rangeRestrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print LinearMap.range_rangeRestrict /-\n@[simp]\ntheorem LinearMap.range_rangeRestrict [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R M₂]\n    (f : «expr →ₗ[ ] » M R M₂) : f.range_restrict.range = «expr⊤» := by simp [f.range_cod_restrict _]\n#align linear_map.range_range_restrict LinearMap.range_rangeRestrict\n-/\n\n",
 "range_of_le":
 "theorem range_of_le (p q : Submodule R M) (h : p ≤ q) : (ofLe h).range = comap q.subtype p := by\n  rw [← map_top, of_le, LinearMap.map_codRestrict, map_top, range_subtype]\n#align range_of_le range_of_le\n\n",
 "range_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem range_neg {R : Type _} {R₂ : Type _} {M : Type _} {M₂ : Type _} [Semiring R] [Ring R₂] [AddCommMonoid M]\n    [AddCommGroup M₂] [Module R M] [Module R₂ M₂] {τ₁₂ : «expr →+* » R R₂} [RingHomSurjective τ₁₂]\n    (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) : (-f).range = f.range :=\n  by\n  change ((-LinearMap.id : «expr →ₗ[ ] » M₂ R₂ M₂).comp f).range = _\n  rw [range_comp, Submodule.map_neg, Submodule.map_id]\n#align range_neg range_neg\n\n",
 "range_map_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_map_nonempty (N : Submodule R M) :\n    (Set.range (fun ϕ => Submodule.map ϕ N : «expr →ₛₗ[ ] » M σ₁₂ M₂ → Submodule R₂ M₂)).nonempty :=\n  ⟨_, Set.mem_range.mpr ⟨0, rfl⟩⟩\n#align range_map_nonempty range_map_nonempty\n\n",
 "range_le_ker_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_le_ker_iff {f : «expr →ₛₗ[ ] » M τ₁₂ M₂} {g : «expr →ₛₗ[ ] » M₂ τ₂₃ M₃} :\n    range f ≤ ker g ↔ (g.comp f : «expr →ₛₗ[ ] » M τ₁₃ M₃) = 0 :=\n  ⟨fun h => ker_eq_top.1 <| eq_top_iff'.2 fun x => h <| ⟨_, rfl⟩, fun h x hx =>\n    mem_ker.2 <| exists.elim hx fun y hy => by rw [← hy, ← comp_apply, h, zero_apply]⟩\n#align range_le_ker_iff range_le_ker_iff\n\n",
 "range_le_iff_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_le_iff_comap [RingHomSurjective τ₁₂] {f : F} {p : Submodule R₂ M₂} : range f ≤ p ↔ comap f p = «expr⊤» :=\n  by rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]\n#align range_le_iff_comap range_le_iff_comap\n\n",
 "range_le_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem range_le_bot_iff (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) : range f ≤ «expr⊥» ↔ f = 0 := by\n  rw [range_le_iff_comap] <;> exact ker_eq_top\n#align range_le_bot_iff range_le_bot_iff\n\n",
 "range_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem range_id : range (LinearMap.id : «expr →ₗ[ ] » M R M) = «expr⊤» :=\n  SetLike.coe_injective Set.range_id\n#align range_id range_id\n\n",
 "range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_top [RingHomSurjective τ₁₂] {f : F} : range f = «expr⊤» ↔ surjective f := by\n  rw [SetLike.ext'_iff, range_coe, top_coe, Set.range_iff_surjective]\n#align range_eq_top range_eq_top\n\n",
 "range_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_eq_map [RingHomSurjective τ₁₂] (f : F) : range f = map f («expr⊤») :=\n  by\n  ext\n  simp\n#align range_eq_map range_eq_map\n\n",
 "range_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem range_eq_bot {f : «expr →ₛₗ[ ] » M τ₁₂ M₂} : range f = «expr⊥» ↔ f = 0 := by rw [← range_le_bot_iff, le_bot_iff]\n#align range_eq_bot range_eq_bot\n\n",
 "range_comp_of_range_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_comp_of_range_eq_top [RingHomSurjective τ₁₂] [RingHomSurjective τ₂₃] [RingHomSurjective τ₁₃]\n    {f : «expr →ₛₗ[ ] » M τ₁₂ M₂} (g : «expr →ₛₗ[ ] » M₂ τ₂₃ M₃) (hf : range f = «expr⊤») :\n    range (g.comp f : «expr →ₛₗ[ ] » M τ₁₃ M₃) = range g := by rw [range_comp, hf, Submodule.map_top]\n#align range_comp_of_range_eq_top range_comp_of_range_eq_top\n\n",
 "range_comp_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_comp_le_range [RingHomSurjective τ₂₃] [RingHomSurjective τ₁₃] (f : «expr →ₛₗ[ ] » M τ₁₂ M₂)\n    (g : «expr →ₛₗ[ ] » M₂ τ₂₃ M₃) : range (g.comp f : «expr →ₛₗ[ ] » M τ₁₃ M₃) ≤ range g :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n#align range_comp_le_range range_comp_le_range\n\n",
 "range_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem range_comp [RingHomSurjective σ₁₂] [RingHomSurjective σ₂₃] [RingHomSurjective σ₁₃] :\n    (h.comp (e : «expr →ₛₗ[ ] » M σ₁₂ M₂) : «expr →ₛₗ[ ] » M σ₁₃ M₃).range = h.range :=\n  LinearMap.range_comp_of_range_eq_top _ e.range\n#align range_comp range_comp\n\n",
 "range_coe":
 "theorem range_coe [RingHomSurjective τ₁₂] (f : F) : (range f : Set M₂) = Set.range f :=\n  rfl\n#align range_coe range_coe\n\n",
 "range_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem range_cod_restrict {τ₂₁ : «expr →+* » R₂ R} [RingHomSurjective τ₂₁] (p : Submodule R M)\n    (f : «expr →ₛₗ[ ] » M₂ τ₂₁ M) (hf) : range (codRestrict p f hf) = comap p.subtype f.range := by\n  simpa only [range_eq_map] using map_cod_restrict _ _ _ _\n#align range_cod_restrict range_cod_restrict\n\n",
 "range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print LinearEquivClass.range /-\n@[simp]\nprotected theorem LinearEquivClass.range [Module R M] [Module R₂ M₂] {F : Type _} [SemilinearEquivClass F σ₁₂ M M₂]\n    (e : F) : LinearMap.range e = «expr⊤» :=\n  LinearMap.range_eq_top.2 (EquivLike.surjective e)\n#align linear_equiv_class.range LinearEquivClass.range\n-/\n\n",
 "pow_restrict":
 "theorem pow_restrict {p : Submodule R M} (n : ℕ) (h : ∀ x ∈ p, f' x ∈ p) (h' := pow_apply_mem_of_forall_mem n h) :\n    f'.restrict h ^ n = (f' ^ n).restrict h' :=\n  by\n  induction' n with n ih <;> ext\n  · simp [restrict_apply]\n  · simp [restrict_apply, LinearMap.iterate_succ, -LinearMap.pow_apply, ih]\n#align pow_restrict pow_restrict\n\n",
 "pow_map_zero_of_le":
 "theorem pow_map_zero_of_le {f : Module.End R M} {m : M} {k l : ℕ} (hk : k ≤ l) (hm : (f ^ k) m = 0) : (f ^ l) m = 0 :=\n  by rw [← tsub_add_cancel_of_le hk, pow_add, mul_apply, hm, map_zero]\n#align pow_map_zero_of_le pow_map_zero_of_le\n\n",
 "pow_apply_mem_of_forall_mem":
 "theorem pow_apply_mem_of_forall_mem {p : Submodule R M} (n : ℕ) (h : ∀ x ∈ p, f' x ∈ p) (x : M) (hx : x ∈ p) :\n    (f' ^ n) x ∈ p := by\n  induction' n with n ih generalizing x; · simpa\n  simpa only [iterate_succ, coe_comp, Function.comp_apply, restrict_apply] using ih _ (h _ hx)\n#align pow_apply_mem_of_forall_mem pow_apply_mem_of_forall_mem\n\n",
 "pow_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\n@[simp]\ntheorem pow_apply (f : «expr →ₗ[ ] » M R M) (n : ℕ) (m : M) : (f ^ n) m = («expr ^[ ]» f n) m :=\n  by\n  induction' n with n ih\n  · rfl\n  · simp only [Function.comp_apply, Function.iterate_succ, LinearMap.mul_apply, pow_succ, ih]\n    exact (Function.Commute.iterate_self _ _ m).symm\n#align pow_apply pow_apply\n\n",
 "pi_eq_sum_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print pi_eq_sum_univ /-\n/-- decomposing `x : ι → R` as a sum along the canonical basis -/\ntheorem pi_eq_sum_univ {ι : Type _} [Fintype ι] [DecidableEq ι] {R : Type _} [Semiring R] (x : ι → R) :\n    x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (x i) fun j => if i = j then 1 else 0) :=\n  by\n  ext\n  simp\n#align pi_eq_sum_univ pi_eq_sum_univ\n-/\n\n",
 "pi_apply_eq_sum_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A linear map `f` applied to `x : ι → R` can be computed using the image under `f` of elements\nof the canonical basis. -/\ntheorem pi_apply_eq_sum_univ [Fintype ι] [DecidableEq ι] (f : «expr →ₗ[ ] » (ι → R) R M) (x : ι → R) :\n    f x =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (x i) (f fun j => if i = j then 1 else 0)) :=\n  by\n  conv_lhs => rw [pi_eq_sum_univ x, f.map_sum]\n  apply Finset.sum_congr rfl fun l hl => _\n  rw [map_smul]\n#align pi_apply_eq_sum_univ pi_apply_eq_sum_univ\n\n",
 "order_iso_map_comap_symm_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\ntheorem order_iso_map_comap_symm_apply' (e : «expr ≃ₛₗ[ ] » M τ₁₂ M₂) (p : Submodule R₂ M₂) :\n    (orderIsoMapComap e).symm p = map e.symm p :=\n  p.comap_equiv_eq_map_symm _\n#align order_iso_map_comap_symm_apply' order_iso_map_comap_symm_apply'\n\n",
 "order_iso_map_comap_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\ntheorem order_iso_map_comap_apply' (e : «expr ≃ₛₗ[ ] » M τ₁₂ M₂) (p : Submodule R M) :\n    orderIsoMapComap e p = comap e.symm p :=\n  p.map_equiv_eq_comap_symm _\n#align order_iso_map_comap_apply' order_iso_map_comap_apply'\n\n",
 "of_top_symm_apply":
 "theorem of_top_symm_apply {h} (x : M) : (ofTop p h).symm x = ⟨x, h.symm ▸ trivial⟩ :=\n  rfl\n#align of_top_symm_apply of_top_symm_apply\n\n",
 "of_top_apply":
 "@[simp]\ntheorem of_top_apply {h} (x : p) : ofTop p h x = x :=\n  rfl\n#align of_top_apply of_top_apply\n\n",
 "of_submodules_symm_apply":
 "@[simp]\ntheorem of_submodules_symm_apply {p : Submodule R M} {q : Submodule R₂ M₂} (h : p.map ↑e = q) (x : q) :\n    ↑((e.of_submodules p q h).symm x) = e.symm x :=\n  rfl\n#align of_submodules_symm_apply of_submodules_symm_apply\n\n",
 "of_submodules_apply":
 "@[simp]\ntheorem of_submodules_apply {p : Submodule R M} {q : Submodule R₂ M₂} (h : p.map ↑e = q) (x : p) :\n    ↑(e.of_submodules p q h x) = e x :=\n  rfl\n#align of_submodules_apply of_submodules_apply\n\n",
 "of_submodule'_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\ntheorem of_submodule'_to_linear_map [Module R M] [Module R₂ M₂] (f : «expr ≃ₛₗ[ ] » M σ₁₂ M₂) (U : Submodule R₂ M₂) :\n    (f.of_submodule' U).to_linear_map = (f.to_linear_map.dom_restrict _).cod_restrict _ Subtype.prop :=\n  by\n  ext\n  rfl\n#align of_submodule'_to_linear_map of_submodule'_to_linear_map\n\n",
 "of_submodule'_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n@[simp]\ntheorem of_submodule'_symm_apply [Module R M] [Module R₂ M₂] (f : «expr ≃ₛₗ[ ] » M σ₁₂ M₂) (U : Submodule R₂ M₂)\n    (x : U) : ((f.of_submodule' U).symm x : M) = f.symm (x : M₂) :=\n  rfl\n#align of_submodule'_symm_apply of_submodule'_symm_apply\n\n",
 "of_submodule'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem of_submodule'_apply [Module R M] [Module R₂ M₂] (f : «expr ≃ₛₗ[ ] » M σ₁₂ M₂) (U : Submodule R₂ M₂)\n    (x : U.comap (f : «expr →ₛₗ[ ] » M σ₁₂ M₂)) : (f.of_submodule' U x : M₂) = f (x : M) :=\n  rfl\n#align of_submodule'_apply of_submodule'_apply\n\n",
 "of_linear_symm_apply":
 "@[simp]\ntheorem of_linear_symm_apply {h₁ h₂} (x : M₂) : (ofLinear f g h₁ h₂).symm x = g x :=\n  rfl\n#align of_linear_symm_apply of_linear_symm_apply\n\n",
 "of_linear_apply":
 "@[simp]\ntheorem of_linear_apply {h₁ h₂} (x : M) : ofLinear f g h₁ h₂ x = f x :=\n  rfl\n#align of_linear_apply of_linear_apply\n\n",
 "of_left_inverse_symm_apply":
 "@[simp]\ntheorem of_left_inverse_symm_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] (h : function.left_inverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x :=\n  rfl\n#align of_left_inverse_symm_apply of_left_inverse_symm_apply\n\n",
 "of_left_inverse_apply":
 "@[simp]\ntheorem of_left_inverse_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] (h : function.left_inverse g f)\n    (x : M) : ↑(ofLeftInverse h x) = f x :=\n  rfl\n#align of_left_inverse_apply of_left_inverse_apply\n\n",
 "of_le_injective":
 "theorem of_le_injective (h : p ≤ p') : function.injective (ofLe h) := fun x y h =>\n  Subtype.val_injective (subtype.mk.inj h)\n#align of_le_injective of_le_injective\n\n",
 "of_le_apply":
 "theorem of_le_apply (h : p ≤ p') (x : p) : ofLe h x = ⟨x, h x.2⟩ :=\n  rfl\n#align of_le_apply of_le_apply\n\n",
 "of_injective_apply":
 "@[simp]\ntheorem of_injective_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {h : injective f} (x : M) :\n    ↑(ofInjective f h x) = f x :=\n  rfl\n#align of_injective_apply of_injective_apply\n\n",
 "of_eq_symm":
 "@[simp]\ntheorem of_eq_symm (h : p = q) : (ofEq p q h).symm = ofEq q p h.symm :=\n  rfl\n#align of_eq_symm of_eq_symm\n\n",
 "of_eq_rfl":
 "@[simp]\ntheorem of_eq_rfl : ofEq p p rfl = LinearEquiv.refl R p := by ext <;> rfl\n#align of_eq_rfl of_eq_rfl\n\n",
 "of_bijective_apply":
 "@[simp]\ntheorem of_bijective_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {hf} (x : M) : ofBijective f hf x = f x :=\n  rfl\n#align of_bijective_apply of_bijective_apply\n\n",
 "nontrivial_iff":
 "#print nontrivial_iff /-\n@[simp]\ntheorem nontrivial_iff : Nontrivial (Submodule R M) ↔ Nontrivial M :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans <| subsingleton_iff R).trans not_nontrivial_iff_subsingleton.symm)\n#align nontrivial_iff nontrivial_iff\n-/\n\n",
 "neg_coe":
 "-- See `neg_coe_set`\ntheorem neg_coe : -(p : Set M) = p :=\n  Set.ext fun x => p.neg_mem_iff\n#align neg_coe neg_coe\n\n",
 "neg_apply":
 "theorem neg_apply (x : M) : neg R x = -x := by simp\n#align neg_apply neg_apply\n\n",
 "mem_submodule_image_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem mem_submodule_image_of_le {M' : Type _} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {ϕ : «expr →ₗ[ ] » O R M'} {N : Submodule R M} (hNO : N ≤ O) {x : M'} :\n    x ∈ ϕ.submodule_image N ↔ ∃ (y : _)(yN : y ∈ N), ϕ ⟨y, hNO yN⟩ = x :=\n  by\n  refine' mem_submodule_image.trans ⟨_, _⟩\n  · rintro ⟨y, yO, yN, h⟩\n    exact ⟨y, yN, h⟩\n  · rintro ⟨y, yN, h⟩\n    exact ⟨y, hNO yN, yN, h⟩\n#align mem_submodule_image_of_le mem_submodule_image_of_le\n\n",
 "mem_submodule_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem mem_submodule_image {M' : Type _} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {ϕ : «expr →ₗ[ ] » O R M'} {N : Submodule R M} {x : M'} :\n    x ∈ ϕ.submodule_image N ↔ ∃ (y : _)(yO : y ∈ O)(yN : y ∈ N), ϕ ⟨y, yO⟩ = x :=\n  by\n  refine' submodule.mem_map.trans ⟨_, _⟩ <;> simp_rw [Submodule.mem_comap]\n  · rintro ⟨⟨y, yO⟩, yN : y ∈ N, h⟩\n    exact ⟨y, yO, yN, h⟩\n  · rintro ⟨y, yO, yN, h⟩\n    exact ⟨⟨y, yO⟩, yN, h⟩\n#align mem_submodule_image mem_submodule_image\n\n",
 "mem_right_iff_eq_zero_of_disjoint":
 "theorem mem_right_iff_eq_zero_of_disjoint {p p' : Submodule R M} (h : Disjoint p p') {x : p} : (x : M) ∈ p' ↔ x = 0 :=\n  ⟨fun hx => coe_eq_zero.1 <| disjoint_def.1 h x x.2 hx, fun h => h.symm ▸ p'.zero_mem⟩\n#align mem_right_iff_eq_zero_of_disjoint mem_right_iff_eq_zero_of_disjoint\n\n",
 "mem_range_self":
 "theorem mem_range_self [RingHomSurjective τ₁₂] (f : F) (x : M) : f x ∈ range f :=\n  ⟨x, rfl⟩\n#align mem_range_self mem_range_self\n\n",
 "mem_range":
 "@[simp]\ntheorem mem_range [RingHomSurjective τ₁₂] {f : F} {x} : x ∈ range f ↔ ∃ y, f y = x :=\n  iff.rfl\n#align mem_range mem_range\n\n",
 "mem_map_of_mem":
 "theorem mem_map_of_mem {f : F} {p : Submodule R M} {r} (h : r ∈ p) : f r ∈ map f p :=\n  Set.mem_image_of_mem _ h\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem mem_map_equiv {e : «expr ≃ₛₗ[ ] » M τ₁₂ M₂} {x : M₂} : x ∈ p.map (e : «expr →ₛₗ[ ] » M τ₁₂ M₂) ↔ e.symm x ∈ p :=\n  by\n  rw [Submodule.mem_map]; constructor\n  · rintro ⟨y, hy, hx⟩\n    simp [← hx, hy]\n  · intro hx\n    refine' ⟨e.symm x, hx, by simp⟩\n#align mem_map_equiv mem_map_equiv\n\n",
 "mem_map":
 "@[simp]\ntheorem mem_map {f : F} {p : Submodule R M} {x : M₂} : x ∈ map f p ↔ ∃ y, y ∈ p ∧ f y = x :=\n  iff.rfl\n#align mem_map mem_map\n\n",
 "mem_left_iff_eq_zero_of_disjoint":
 "theorem mem_left_iff_eq_zero_of_disjoint {p p' : Submodule R M} (h : Disjoint p p') {x : p'} : (x : M) ∈ p ↔ x = 0 :=\n  ⟨fun hx => coe_eq_zero.1 <| disjoint_def.1 h x hx x.2, fun h => h.symm ▸ p.zero_mem⟩\n#align mem_left_iff_eq_zero_of_disjoint mem_left_iff_eq_zero_of_disjoint\n\n",
 "mem_ker":
 "@[simp]\ntheorem mem_ker {f : F} {y} : y ∈ ker f ↔ f y = 0 :=\n  mem_bot R₂\n#align mem_ker mem_ker\n\n",
 "mem_eq_locus":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem mem_eq_locus {x : M} {f g : «expr →ₛₗ[ ] » M τ₁₂ M₂} : x ∈ f.eq_locus g ↔ f x = g x :=\n  iff.rfl\n#align mem_eq_locus mem_eq_locus\n\n",
 "mem_comap":
 "@[simp]\ntheorem mem_comap {f : F} {p : Submodule R₂ M₂} : x ∈ comap f p ↔ f x ∈ p :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print map_zero /-\n@[simp]\ntheorem map_zero : map (0 : «expr →ₛₗ[ ] » M σ₁₂ M₂) p = «expr⊥» :=\n  have : ∃ x : M, x ∈ p := ⟨0, p.zero_mem⟩\n  ext <| by simp [this, eq_comm]\n#align map_zero map_zero\n-/\n\n",
 "map_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem map_top [RingHomSurjective τ₁₂] (f : F) : map f («expr⊤») = range f :=\n  (range_eq_map f).symm\n#align map_top map_top\n\n",
 "map_to_add_submonoid'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem map_to_add_submonoid' (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (p : Submodule R M) :\n    (p.map f).to_add_submonoid = p.to_add_submonoid.map f :=\n  SetLike.coe_injective rfl\n#align map_to_add_submonoid' map_to_add_submonoid'\n\n",
 "map_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem map_to_add_submonoid (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (p : Submodule R M) :\n    (p.map f).to_add_submonoid = p.to_add_submonoid.map (f : «expr →+ » M M₂) :=\n  SetLike.coe_injective rfl\n#align map_to_add_submonoid map_to_add_submonoid\n\n",
 "map_symm_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\ntheorem map_symm_eq_iff (e : «expr ≃ₛₗ[ ] » M τ₁₂ M₂) {K : Submodule R₂ M₂} : K.map e.symm = p ↔ p.map e = K :=\n  by\n  constructor <;> rintro rfl\n  ·\n    calc\n      map e (map e.symm K) = comap e.symm (map e.symm K) := map_equiv_eq_comap_symm _ _\n      _ = K := comap_map_eq_of_injective e.symm.injective _\n      \n  ·\n    calc\n      map e.symm (map e p) = comap e (map e p) := (comap_equiv_eq_map_symm _ _).symm\n      _ = p := comap_map_eq_of_injective e.injective _\n      \n#align map_symm_eq_iff map_symm_eq_iff\n\n",
 "map_surjective_of_surjective":
 "theorem map_surjective_of_surjective : function.surjective (map f) :=\n  (giMapComap hf).l_surjective\n#align map_surjective_of_surjective map_surjective_of_surjective\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\n@[simp]\ntheorem map_supᵢ {ι : Sort _} (f : F) (p : ι → Submodule R M) :\n    map f («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (map f (p i)) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_supr_comap_of_sujective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_supr_comap_of_sujective {ι : Sort _} (S : ι → Submodule R₂ M₂) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((S i).comap f)).map\n        f =\n      supᵢ S :=\n  (giMapComap hf).l_supr_u _\n#align map_supr_comap_of_sujective map_supr_comap_of_sujective\n\n",
 "map_sup_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup_comap_of_surjective (p q : Submodule R₂ M₂) :\n    («expr ⊔ » (p.comap f) (q.comap f)).map f = «expr ⊔ » p q :=\n  (giMapComap hf).l_sup_u _ _\n#align map_sup_comap_of_surjective map_sup_comap_of_surjective\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem map_sup (f : F) : map f («expr ⊔ » p p') = «expr ⊔ » (map f p) (map f p') :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n#align map_sup map_sup\n\n",
 "map_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n#print map_sum /-\n@[simp]\ntheorem map_sum {s : Finset ι} (u : ι → M) :\n    e (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (u i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (e (u i)) :=\n  e.to_linear_map.map_sum\n#align map_sum map_sum\n-/\n\n",
 "map_subtype_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Under the canonical linear map from a submodule `p` to the ambient space `M`, the image of the\nmaximal submodule of `p` is just `p `. -/\n@[simp]\ntheorem map_subtype_top : map p.subtype («expr⊤» : Submodule R p) = p := by simp\n#align map_subtype_top map_subtype_top\n\n",
 "map_subtype_range_of_le":
 "@[simp]\ntheorem map_subtype_range_of_le {p p' : Submodule R M} (h : p ≤ p') : map p'.subtype (ofLe h).range = p := by\n  simp [range_of_le, map_comap_eq, h]\n#align map_subtype_range_of_le map_subtype_range_of_le\n\n",
 "map_subtype_le":
 "theorem map_subtype_le (p' : Submodule R p) : map p.subtype p' ≤ p := by\n  simpa using (map_le_range : map p.subtype p' ≤ p.subtype.range)\n#align map_subtype_le map_subtype_le\n\n",
 "map_subtype_embedding_eq":
 "@[simp]\ntheorem map_subtype_embedding_eq (p' : Submodule R p) : MapSubtype.orderEmbedding p p' = map p.subtype p' :=\n  rfl\n#align map_subtype_embedding_eq map_subtype_embedding_eq\n\n",
 "map_sub":
 "#print map_sub /-\n@[simp]\ntheorem map_sub (a b : M) : e (a - b) = e a - e b :=\n  e.to_linear_map.map_sub a b\n#align map_sub map_sub\n-/\n\n",
 "map_strict_mono_of_injective":
 "theorem map_strict_mono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strict_mono_l\n#align map_strict_mono_of_injective map_strict_mono_of_injective\n\n",
 "map_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_smul' (f : «expr →ₗ[ ] » V K V₂) (p : Submodule K V) (a : K) :\n    p.map («expr • » a f) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p.map f) :=\n  by classical by_cases a = 0 <;> simp [h, map_smul]\n#align map_smul' map_smul'\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_smul (f : «expr →ₗ[ ] » V K V₂) (p : Submodule K V) (a : K) (h : a ≠ 0) : p.map («expr • » a f) = p.map f :=\n  le_antisymm (by rw [map_le_iff_le_comap, comap_smul f _ a h, ← map_le_iff_le_comap]; exact le_rfl)\n    (by rw [map_le_iff_le_comap, ← comap_smul f _ a h, ← map_le_iff_le_comap]; exact le_rfl)\n#align map_smul map_smul\n\n",
 "map_neg":
 "#print map_neg /-\n@[simp]\ntheorem map_neg (a : M) : e (-a) = -e a :=\n  e.to_linear_map.map_neg a\n#align map_neg map_neg\n-/\n\n",
 "map_mono":
 "theorem map_mono {f : F} {p p' : Submodule R M} : p ≤ p' → map f p ≤ map f p' :=\n  image_subset _\n#align map_mono map_mono\n\n",
 "map_le_range":
 "theorem map_le_range [RingHomSurjective τ₁₂] {f : F} {p : Submodule R M} : map f p ≤ range f :=\n  SetLike.coe_mono (Set.image_subset_range f p)\n#align map_le_range map_le_range\n\n",
 "map_le_map_iff_of_injective":
 "theorem map_le_map_iff_of_injective (p q : Submodule R M) : p.map f ≤ q.map f ↔ p ≤ q :=\n  (gciMapComap hf).l_le_l_iff\n#align map_le_map_iff_of_injective map_le_map_iff_of_injective\n\n",
 "map_le_iff_le_comap":
 "theorem map_le_iff_le_comap {f : F} {p : Submodule R M} {q : Submodule R₂ M₂} : map f p ≤ q ↔ p ≤ comap f q :=\n  image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_injective_of_injective":
 "theorem map_injective_of_injective : function.injective (map f) :=\n  (gciMapComap hf).l_injective\n#align map_injective_of_injective map_injective_of_injective\n\n",
 "map_infi_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem map_infi_comap_of_surjective {ι : Sort _} (S : ι → Submodule R₂ M₂) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((S i).comap f)).map\n        f =\n      infᵢ S :=\n  (giMapComap hf).l_infi_u _\n#align map_infi_comap_of_surjective map_infi_comap_of_surjective\n\n",
 "map_inf_eq_map_inf_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n--TODO(Mario): is there a way to prove this from order properties?\ntheorem map_inf_eq_map_inf_comap [RingHomSurjective σ₁₂] {f : F} {p : Submodule R M} {p' : Submodule R₂ M₂} :\n    «expr ⊓ » (map f p) p' = map f («expr ⊓ » p (comap f p')) :=\n  le_antisymm (by rintro _ ⟨⟨x, h₁, rfl⟩, h₂⟩ <;> exact ⟨_, ⟨h₁, h₂⟩, rfl⟩)\n    (le_inf (map_mono inf_le_left) (map_le_iff_le_comap.2 inf_le_right))\n#align map_inf_eq_map_inf_comap map_inf_eq_map_inf_comap\n\n",
 "map_inf_comap_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_inf_comap_of_surjective (p q : Submodule R₂ M₂) :\n    («expr ⊓ » (p.comap f) (q.comap f)).map f = «expr ⊓ » p q :=\n  (giMapComap hf).l_inf_u _ _\n#align map_inf_comap_of_surjective map_inf_comap_of_surjective\n\n",
 "map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_id : map (LinearMap.id : «expr →ₗ[ ] » M R M) p = p :=\n  Submodule.ext fun a => by simp\n#align map_id map_id\n\n",
 "map_finsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print map_finsupp_sum /-\n@[simp]\ntheorem map_finsupp_sum (f : «expr ≃ₛₗ[ ] » M τ₁₂ M₂) {t : «expr →₀ » ι γ} {g : ι → γ → M} :\n    f (t.sum g) = t.sum fun i d => f (g i d) :=\n  f.map_sum _\n#align map_finsupp_sum map_finsupp_sum\n-/\n\n",
 "map_equiv_eq_comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem map_equiv_eq_comap_symm (e : «expr ≃ₛₗ[ ] » M τ₁₂ M₂) (K : Submodule R M) :\n    K.map (e : «expr →ₛₗ[ ] » M τ₁₂ M₂) = K.comap (e.symm : «expr →ₛₗ[ ] » M₂ τ₂₁ M) :=\n  Submodule.ext fun _ => by rw [mem_map_equiv, mem_comap, LinearEquiv.coe_coe]\n#align map_equiv_eq_comap_symm map_equiv_eq_comap_symm\n\n",
 "map_eq_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem map_eq_comap {p : Submodule R M} :\n    (p.map (e : «expr →ₛₗ[ ] » M σ₁₂ M₂) : Submodule R₂ M₂) = p.comap (e.symm : «expr →ₛₗ[ ] » M₂ σ₂₁ M) :=\n  SetLike.coe_injective <| by simp [e.image_eq_preimage]\n#align map_eq_comap map_eq_comap\n\n",
 "map_dfinsupp_sum_add_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n@[simp]\ntheorem map_dfinsupp_sum_add_hom [∀ i, AddZeroClass (γ i)] (f : «expr ≃ₛₗ[ ] » M τ₁₂ M₂)\n    (t : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (γ i))\n    (g : ∀ i, «expr →+ » (γ i) M) :\n    f (sumAddHom g t) = sumAddHom (fun i => f.to_add_equiv.to_add_monoid_hom.comp (g i)) t :=\n  f.to_add_equiv.map_dfinsupp_sum_add_hom _ _\n#align map_dfinsupp_sum_add_hom map_dfinsupp_sum_add_hom\n\n",
 "map_dfinsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem map_dfinsupp_sum [∀ i, Zero (γ i)] [∀ (i) (x : γ i), Decidable (x ≠ 0)] (f : «expr ≃ₛₗ[ ] » M τ₁₂ M₂)\n    (t : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (γ i))\n    (g : ∀ i, γ i → M) : f (t.sum g) = t.sum fun i d => f (g i d) :=\n  f.map_sum _\n#align map_dfinsupp_sum map_dfinsupp_sum\n\n",
 "map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem map_comp [RingHomSurjective σ₂₃] [RingHomSurjective σ₁₃] (f : «expr →ₛₗ[ ] » M σ₁₂ M₂)\n    (g : «expr →ₛₗ[ ] » M₂ σ₂₃ M₃) (p : Submodule R M) : map (g.comp f : «expr →ₛₗ[ ] » M σ₁₃ M₃) p = map g (map f p) :=\n  SetLike.coe_injective <| by simp only [← image_comp, map_coe, LinearMap.coe_comp, comp_app]\n#align map_comp map_comp\n\n",
 "map_comap_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem map_comap_subtype : map p.subtype (comap p.subtype p') = «expr ⊓ » p p' :=\n  ext fun x => ⟨by rintro ⟨⟨_, h₁⟩, h₂, rfl⟩ <;> exact ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨⟨_, h₁⟩, h₂, rfl⟩⟩\n#align map_comap_subtype map_comap_subtype\n\n",
 "map_comap_le":
 "theorem map_comap_le [RingHomSurjective σ₁₂] (f : F) (q : Submodule R₂ M₂) : map f (comap f q) ≤ q :=\n  (gc_map_comap f).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_comap_eq_self":
 "#print Submodule.map_comap_eq_self /-\ntheorem Submodule.map_comap_eq_self [RingHomSurjective τ₁₂] {f : F} {q : Submodule R₂ M₂} (h : q ≤ range f) :\n    map f (comap f q) = q := by rwa [Submodule.map_comap_eq, inf_eq_right]\n#align submodule.map_comap_eq_self Submodule.map_comap_eq_self\n-/\n\n",
 "map_comap_eq_of_surjective":
 "theorem map_comap_eq_of_surjective (p : Submodule R₂ M₂) : (p.comap f).map f = p :=\n  (giMapComap hf).l_u_eq _\n#align map_comap_eq_of_surjective map_comap_eq_of_surjective\n\n",
 "map_comap_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print Submodule.map_comap_eq /-\ntheorem Submodule.map_comap_eq [RingHomSurjective τ₁₂] (f : F) (q : Submodule R₂ M₂) :\n    map f (comap f q) = «expr ⊓ » (range f) q :=\n  le_antisymm (le_inf map_le_range (map_comap_le _ _)) <| by rintro _ ⟨⟨x, _, rfl⟩, hx⟩ <;> exact ⟨x, hx, rfl⟩\n#align submodule.map_comap_eq Submodule.map_comap_eq\n-/\n\n",
 "map_coe_ker":
 "@[simp]\ntheorem map_coe_ker (f : F) (x : ker f) : f x = 0 :=\n  mem_ker.1 x.2\n#align map_coe_ker map_coe_ker\n\n",
 "map_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem map_coe (f : F) (p : Submodule R M) : (map f p : Set M₂) = «expr '' » f p :=\n  rfl\n#align map_coe map_coe\n\n",
 "map_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem map_cod_restrict [RingHomSurjective σ₂₁] (p : Submodule R M) (f : «expr →ₛₗ[ ] » M₂ σ₂₁ M) (h p') :\n    Submodule.map (codRestrict p f h) p' = comap p.subtype (p'.map f) :=\n  Submodule.ext fun ⟨x, hx⟩ => by simp [Subtype.ext_iff_val]\n#align map_cod_restrict map_cod_restrict\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : F) : map f («expr⊥») = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "map_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_add_le (f g : «expr →ₛₗ[ ] » M σ₁₂ M₂) : map (f + g) p ≤ «expr ⊔ » (map f p) (map g p) :=\n  by\n  rintro x ⟨m, hm, rfl⟩\n  exact add_mem_sup (mem_map_of_mem hm) (mem_map_of_mem hm)\n#align map_add_le map_add_le\n\n",
 "linear_equiv_fun_on_finite_symm_single":
 "@[simp]\ntheorem linear_equiv_fun_on_finite_symm_single [DecidableEq α] (x : α) (m : M) :\n    (linearEquivFunOnFinite R M α).symm (Pi.single x m) = single x m :=\n  equivFunOnFinite_symm_single x m\n#align linear_equiv_fun_on_finite_symm_single linear_equiv_fun_on_finite_symm_single\n\n",
 "linear_equiv_fun_on_finite_symm_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem linear_equiv_fun_on_finite_symm_coe (f : «expr →₀ » α M) : (linearEquivFunOnFinite R M α).symm f = f :=\n  (linearEquivFunOnFinite R M α).symm_apply_apply f\n#align linear_equiv_fun_on_finite_symm_coe linear_equiv_fun_on_finite_symm_coe\n\n",
 "linear_equiv_fun_on_finite_single":
 "@[simp]\ntheorem linear_equiv_fun_on_finite_single [DecidableEq α] (x : α) (m : M) :\n    (linearEquivFunOnFinite R M α) (single x m) = Pi.single x m :=\n  equivFunOnFinite_single x m\n#align linear_equiv_fun_on_finite_single linear_equiv_fun_on_finite_single\n\n",
 "le_ker_iff_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem le_ker_iff_map [RingHomSurjective τ₁₂] {f : F} {p : Submodule R M} : p ≤ ker f ↔ map f p = «expr⊥» := by\n  rw [ker, eq_bot_iff, map_le_iff_le_comap]\n#align le_ker_iff_map le_ker_iff_map\n\n",
 "le_comap_pow_of_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem le_comap_pow_of_le_comap (p : Submodule R M) {f : «expr →ₗ[ ] » M R M} (h : p ≤ p.comap f) (k : ℕ) :\n    p ≤ p.comap (f ^ k) := by\n  induction' k with k ih\n  · simp [LinearMap.one_eq_id]\n  · simp [LinearMap.iterate_succ, comap_comp, h.trans (comap_mono ih)]\n#align le_comap_pow_of_le_comap le_comap_pow_of_le_comap\n\n",
 "le_comap_map":
 "theorem le_comap_map [RingHomSurjective σ₁₂] (f : F) (p : Submodule R M) : p ≤ comap f (map f p) :=\n  (gc_map_comap f).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "ker_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem ker_zero : ker (0 : «expr →ₛₗ[ ] » M τ₁₂ M₂) = «expr⊤» :=\n  eq_top_iff'.2 fun x => by simp\n#align ker_zero ker_zero\n\n",
 "ker_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem ker_to_add_submonoid (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) : f.ker.to_add_submonoid = f.to_add_monoid_hom.mker :=\n  rfl\n#align ker_to_add_submonoid ker_to_add_submonoid\n\n",
 "ker_to_add_subgroup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem ker_to_add_subgroup (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) : f.ker.to_add_subgroup = f.to_add_monoid_hom.ker :=\n  rfl\n#align ker_to_add_subgroup ker_to_add_subgroup\n\n",
 "ker_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_subtype : p.subtype.ker = «expr⊥» :=\n  ker_eq_bot_of_injective fun x y => Subtype.ext_val\n#align ker_subtype ker_subtype\n\n",
 "ker_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem ker_smul' (f : «expr →ₗ[ ] » V K V₂) (a : K) :\n    ker («expr • » a f) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (ker f) :=\n  Submodule.comap_smul' f _ a\n#align ker_smul' ker_smul'\n\n",
 "ker_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ker_smul (f : «expr →ₗ[ ] » V K V₂) (a : K) (h : a ≠ 0) : ker («expr • » a f) = ker f :=\n  Submodule.comap_smul f _ a h\n#align ker_smul ker_smul\n\n",
 "ker_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem ker_restrict [AddCommMonoid M₁] [Module R M₁] {p : Submodule R M} {q : Submodule R M₁}\n    {f : «expr →ₗ[ ] » M R M₁} (hf : ∀ x : M, x ∈ p → f x ∈ q) : ker (f.restrict hf) = (f.dom_restrict p).ker := by\n  rw [restrict_eq_cod_restrict_dom_restrict, ker_cod_restrict]\n#align ker_restrict ker_restrict\n\n",
 "ker_rangeRestrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.ker_rangeRestrict /-\n@[simp]\ntheorem LinearMap.ker_rangeRestrict [Semiring R] [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module R M₂]\n    (f : «expr →ₗ[ ] » M R M₂) : f.range_restrict.ker = f.ker :=\n  LinearMap.ker_codRestrict _ _ _\n#align linear_map.ker_range_restrict LinearMap.ker_rangeRestrict\n-/\n\n",
 "ker_of_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_of_le (p p' : Submodule R M) (h : p ≤ p') : (ofLe h).ker = «expr⊥» := by\n  rw [of_le, ker_cod_restrict, ker_subtype]\n#align ker_of_le ker_of_le\n\n",
 "ker_le_ker_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem ker_le_ker_comp (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) (g : «expr →ₛₗ[ ] » M₂ τ₂₃ M₃) :\n    ker f ≤ ker (g.comp f : «expr →ₛₗ[ ] » M τ₁₃ M₃) := by rw [ker_comp] <;> exact comap_mono bot_le\n#align ker_le_ker_comp ker_le_ker_comp\n\n",
 "ker_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem ker_le_iff [RingHomSurjective τ₁₂] {p : Submodule R M} : ker f ≤ p ↔ ∃ y ∈ range f, «expr ⁻¹' » f {y} ⊆ p :=\n  by\n  constructor\n  · intro h\n    use 0\n    rw [← SetLike.mem_coe, range_coe]\n    exact ⟨⟨0, map_zero f⟩, h⟩\n  · rintro ⟨y, h₁, h₂⟩\n    rw [SetLike.le_def]\n    intro z hz\n    simp only [mem_ker, SetLike.mem_coe] at hz\n    rw [← SetLike.mem_coe, range_coe, Set.mem_range] at h₁\n    obtain ⟨x, hx⟩ := h₁\n    have hx' : x ∈ p := h₂ hx\n    have hxz : z + x ∈ p := by\n      apply h₂\n      simp [hx, hz]\n    suffices z + x - x ∈ p by simpa only [this, add_sub_cancel]\n    exact p.sub_mem hxz hx'\n#align ker_le_iff ker_le_iff\n\n",
 "ker_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_id : ker (LinearMap.id : «expr →ₗ[ ] » M R M) = «expr⊥» :=\n  rfl\n#align ker_id ker_id\n\n",
 "ker_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem ker_eq_top {f : «expr →ₛₗ[ ] » M τ₁₂ M₂} : ker f = «expr⊤» ↔ f = 0 :=\n  ⟨fun h => ext fun x => mem_ker.1 <| h.symm ▸ trivial, fun h => h.symm ▸ ker_zero⟩\n#align ker_eq_top ker_eq_top\n\n",
 "ker_eq_bot_of_inverse":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot_of_inverse {τ₂₁ : «expr →+* » R₂ R} [RingHomInvPair τ₁₂ τ₂₁] {f : «expr →ₛₗ[ ] » M τ₁₂ M₂}\n    {g : «expr →ₛₗ[ ] » M₂ τ₂₁ M} (h : (g.comp f : «expr →ₗ[ ] » M R M) = id) : ker f = «expr⊥» :=\n  ker_eq_bot'.2 fun m hm => by rw [← id_apply m, ← h, comp_apply, hm, g.map_zero]\n#align ker_eq_bot_of_inverse ker_eq_bot_of_inverse\n\n",
 "ker_eq_bot_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot_of_injective {f : F} (hf : injective f) : ker f = «expr⊥» :=\n  by\n  have : Disjoint («expr⊤») (ker f) := by\n    rw [disjoint_ker, ← map_zero f]\n    exact fun x hx H => hf H\n  simpa [disjoint_iff_inf_le]\n#align ker_eq_bot_of_injective ker_eq_bot_of_injective\n\n",
 "ker_eq_bot_of_cancel":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A monomorphism is injective. -/\ntheorem ker_eq_bot_of_cancel {f : «expr →ₛₗ[ ] » M τ₁₂ M₂}\n    (h : ∀ u v : «expr →ₗ[ ] » f.ker R M, f.comp u = f.comp v → u = v) : f.ker = «expr⊥» :=\n  by\n  have h₁ : f.comp (0 : «expr →ₗ[ ] » f.ker R M) = 0 := comp_zero _\n  rw [← Submodule.range_subtype f.ker, ← h 0 f.ker.subtype (Eq.trans h₁ (comp_ker_subtype f).symm)]\n  exact range_zero\n#align ker_eq_bot_of_cancel ker_eq_bot_of_cancel\n\n",
 "ker_eq_bot'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot' {f : F} : ker f = «expr⊥» ↔ ∀ m, f m = 0 → m = 0 := by\n  simpa [disjoint_iff_inf_le] using @disjoint_ker _ _ _ _ _ _ _ _ _ _ _ _ _ f («expr⊤»)\n#align ker_eq_bot' ker_eq_bot'\n\n",
 "ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_eq_bot {f : «expr →ₛₗ[ ] » M τ₁₂ M₂} : ker f = «expr⊥» ↔ injective f :=\n  LinearMapClass.ker_eq_bot _\n#align ker_eq_bot ker_eq_bot\n\n",
 "ker_comp_of_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem ker_comp_of_ker_eq_bot (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) {g : «expr →ₛₗ[ ] » M₂ τ₂₃ M₃} (hg : ker g = «expr⊥») :\n    ker (g.comp f : «expr →ₛₗ[ ] » M τ₁₃ M₃) = ker f := by rw [ker_comp, hg, Submodule.comap_bot]\n#align ker_comp_of_ker_eq_bot ker_comp_of_ker_eq_bot\n\n",
 "ker_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem ker_comp (l : «expr →ₛₗ[ ] » M σ₁₂ M₂) :\n    (((e'' : «expr →ₛₗ[ ] » M₂ σ₂₃ M₃).comp l : «expr →ₛₗ[ ] » M σ₁₃ M₃) : «expr →ₛₗ[ ] » M σ₁₃ M₃).ker = l.ker :=\n  LinearMap.ker_comp_of_ker_eq_bot _ e''.ker\n#align ker_comp ker_comp\n\n",
 "ker_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem ker_cod_restrict {τ₂₁ : «expr →+* » R₂ R} (p : Submodule R M) (f : «expr →ₛₗ[ ] » M₂ τ₂₁ M) (hf) :\n    ker (codRestrict p f hf) = ker f := by rw [ker, comap_cod_restrict, Submodule.map_bot] <;> rfl\n#align ker_cod_restrict ker_cod_restrict\n\n",
 "ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\nprotected theorem ker : (e : «expr →ₛₗ[ ] » M σ₁₂ M₂).ker = «expr⊥» :=\n  LinearMap.ker_eq_bot_of_injective e.to_equiv.injective\n#align ker ker\n\n",
 "iterate_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem iterate_surjective (h : surjective f') : ∀ n : ℕ, surjective («expr⇑ » (f' ^ n))\n  | 0 => surjective_id\n  | n + 1 => by\n    rw [iterate_succ]\n    exact surjective.comp (iterate_surjective n) h\n#align iterate_surjective iterate_surjective\n\n",
 "iterate_succ":
 "theorem iterate_succ (n : ℕ) : f' ^ (n + 1) = comp (f' ^ n) f' := by rw [pow_succ', mul_eq_comp]\n#align iterate_succ iterate_succ\n\n",
 "iterate_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem iterate_injective (h : injective f') : ∀ n : ℕ, injective («expr⇑ » (f' ^ n))\n  | 0 => injective_id\n  | n + 1 => by\n    rw [iterate_succ]\n    exact injective.comp (iterate_injective n) h\n#align iterate_injective iterate_injective\n\n",
 "iterate_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem iterate_bijective (h : bijective f') : ∀ n : ℕ, bijective («expr⇑ » (f' ^ n))\n  | 0 => bijective_id\n  | n + 1 => by\n    rw [iterate_succ]\n    exact bijective.comp (iterate_bijective n) h\n#align iterate_bijective iterate_bijective\n\n",
 "is_linear_map_sub":
 "theorem is_linear_map_sub {R M : Type _} [Semiring R] [AddCommGroup M] [Module R M] :\n    IsLinearMap R fun x : M × M => x.1 - x.2 := by\n  apply is_linear_map.mk\n  · intro x y\n    simp [add_comm, add_left_comm, sub_eq_add_neg]\n  · intro x y\n    simp [smul_sub]\n#align is_linear_map_sub is_linear_map_sub\n\n",
 "is_linear_map_add":
 "theorem is_linear_map_add [Semiring R] [AddCommMonoid M] [Module R M] : IsLinearMap R fun x : M × M => x.1 + x.2 :=\n  by\n  apply is_linear_map.mk\n  · intro x y\n    simp only [Prod.fst_add, Prod.snd_add]\n    cc\n  · intro x y\n    simp [smul_add]\n#align is_linear_map_add is_linear_map_add\n\n",
 "injective_of_iterate_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem injective_of_iterate_injective {n : ℕ} (hn : n ≠ 0) (h : injective («expr⇑ » (f' ^ n))) : injective f' :=\n  by\n  rw [← nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr hn), iterate_succ, coe_comp] at h\n  exact injective.of_comp h\n#align injective_of_iterate_injective injective_of_iterate_injective\n\n",
 "inj_on_of_disjoint_ker":
 "theorem inj_on_of_disjoint_ker {p : Submodule R M} {s : Set M} (h : s ⊆ p) (hd : Disjoint p (ker f)) : Set.InjOn f s :=\n  fun x hx y hy => disjoint_ker'.1 hd _ (h hx) _ (h hy)\n#align inj_on_of_disjoint_ker inj_on_of_disjoint_ker\n\n",
 "infi_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n#print LinearMap.infᵢ_invariant /-\n/-- The infimum of a family of invariant submodule of an endomorphism is also an invariant\nsubmodule. -/\ntheorem LinearMap.infᵢ_invariant {σ : «expr →+* » R R} [RingHomSurjective σ] {ι : Sort _} (f : «expr →ₛₗ[ ] » M σ M)\n    {p : ι → Submodule R M} (hf : ∀ i, ∀ v ∈ p i, f v ∈ p i) : ∀ v ∈ infᵢ p, f v ∈ infᵢ p :=\n  by\n  have : ∀ i, (p i).map f ≤ p i := by\n    rintro i - ⟨v, hv, rfl⟩\n    exact hf i v hv\n  suffices (infᵢ p).map f ≤ infᵢ p by exact fun v hv => this ⟨v, hv, rfl⟩\n  exact le_infᵢ fun i => (Submodule.map_mono (infᵢ_le p i)).trans (this i)\n#align linear_map.infi_invariant LinearMap.infᵢ_invariant\n-/\n\n",
 "inf_comap_le_comap_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_comap_le_comap_add (f₁ f₂ : «expr →ₛₗ[ ] » M τ₁₂ M₂) :\n    «expr ⊓ » (comap f₁ q) (comap f₂ q) ≤ comap (f₁ + f₂) q :=\n  by\n  rw [SetLike.le_def]\n  intro m h\n  change f₁ m + f₂ m ∈ q\n  change f₁ m ∈ q ∧ f₂ m ∈ q at h\n  apply q.add_mem h.1 h.2\n#align inf_comap_le_comap_add inf_comap_le_comap_add\n\n",
 "id_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem id_pow (n : ℕ) : (id : «expr →ₗ[ ] » M R M) ^ n = id :=\n  one_pow n\n#align id_pow id_pow\n\n",
 "gc_map_comap":
 "theorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f)\n  | p, q => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "fun_left_surjective_of_injective":
 "theorem fun_left_surjective_of_injective (f : m → n) (hf : injective f) : surjective (funLeft R M f) := by\n  classical\n    intro g\n    refine' ⟨fun x => if h : ∃ y, f y = x then g h.some else 0, _⟩\n    · ext\n      dsimp only [fun_left_apply]\n      split_ifs with w\n      · congr\n        exact hf w.some_spec\n      · simpa only [not_true, exists_apply_eq_apply] using w\n#align fun_left_surjective_of_injective fun_left_surjective_of_injective\n\n",
 "fun_left_injective_of_surjective":
 "theorem fun_left_injective_of_surjective (f : m → n) (hf : surjective f) : injective (funLeft R M f) :=\n  by\n  obtain ⟨g, hg⟩ := hf.has_right_inverse\n  suffices left_inverse (fun_left R M g) (fun_left R M f) by exact this.injective\n  intro x\n  rw [← LinearMap.comp_apply, ← fun_left_comp, hg.id, fun_left_id]\n#align fun_left_injective_of_surjective fun_left_injective_of_surjective\n\n",
 "fun_left_id":
 "@[simp]\ntheorem fun_left_id (g : n → M) : funLeft R M id g = g :=\n  rfl\n#align fun_left_id fun_left_id\n\n",
 "fun_left_comp":
 "theorem fun_left_comp (f₁ : n → p) (f₂ : m → n) : funLeft R M (f₁ ∘ f₂) = (funLeft R M f₂).comp (funLeft R M f₁) :=\n  rfl\n#align fun_left_comp fun_left_comp\n\n",
 "fun_left_apply":
 "@[simp]\ntheorem fun_left_apply (f : m → n) (g : n → M) (i : m) : funLeft R M f g i = g (f i) :=\n  rfl\n#align fun_left_apply fun_left_apply\n\n",
 "fun_congr_left_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem fun_congr_left_symm (e : «expr ≃ » m n) : (funCongrLeft R M e).symm = funCongrLeft R M e.symm :=\n  rfl\n#align fun_congr_left_symm fun_congr_left_symm\n\n",
 "fun_congr_left_id":
 "@[simp]\ntheorem fun_congr_left_id : funCongrLeft R M (Equiv.refl n) = LinearEquiv.refl R (n → M) :=\n  rfl\n#align fun_congr_left_id fun_congr_left_id\n\n",
 "fun_congr_left_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem fun_congr_left_comp (e₁ : «expr ≃ » m n) (e₂ : «expr ≃ » n p) :\n    funCongrLeft R M (Equiv.trans e₁ e₂) = LinearEquiv.trans (funCongrLeft R M e₂) (funCongrLeft R M e₁) :=\n  rfl\n#align fun_congr_left_comp fun_congr_left_comp\n\n",
 "fun_congr_left_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem fun_congr_left_apply (e : «expr ≃ » m n) (x : n → M) : funCongrLeft R M e x = funLeft R M e x :=\n  rfl\n#align fun_congr_left_apply fun_congr_left_apply\n\n",
 "finsupp_unique_symm_apply":
 "@[simp]\ntheorem linear_equiv.finsupp_unique_symm_apply {α : Type _} [Unique α] (m : M) :\n    (LinearEquiv.finsuppUnique R M α).symm m = Finsupp.single default m := by ext <;> simp [linear_equiv.finsupp_unique]\n#align linear_equiv.finsupp_unique_symm_apply linear_equiv.finsupp_unique_symm_apply\n\n",
 "finsupp_unique_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem linear_equiv.finsupp_unique_apply (α : Type _) [Unique α] (f : «expr →₀ » α M) :\n    LinearEquiv.finsuppUnique R M α f = f default :=\n  rfl\n#align linear_equiv.finsupp_unique_apply linear_equiv.finsupp_unique_apply\n\n",
 "finsupp_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem finsupp_sum_apply (t : «expr →₀ » ι γ) (g : ι → γ → «expr →ₛₗ[ ] » M σ₁₂ M₂) (b : M) :\n    (t.sum g) b = t.sum fun i d => g i d b :=\n  sum_apply _ _ _\n#align finsupp_sum_apply finsupp_sum_apply\n\n",
 "equiv_subtype_map_symm_apply":
 "@[simp]\ntheorem equiv_subtype_map_symm_apply {p : Submodule R M} {q : Submodule R p} (x : q.map p.subtype) :\n    ((p.equiv_subtype_map q).symm x : M) = x := by\n  cases x\n  rfl\n#align equiv_subtype_map_symm_apply equiv_subtype_map_symm_apply\n\n",
 "equiv_subtype_map_apply":
 "@[simp]\ntheorem equiv_subtype_map_apply {p : Submodule R M} {q : Submodule R p} (x : q) :\n    (p.equiv_subtype_map q x : M) = p.subtype.dom_restrict q x :=\n  rfl\n#align equiv_subtype_map_apply equiv_subtype_map_apply\n\n",
 "eq_zero_of_bot_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_zero_of_bot_submodule : ∀ b : («expr⊥» : Submodule R M), b = 0\n  | ⟨b', hb⟩ => Subtype.eq <| show b' = 0 from (mem_bot R).1 hb\n#align eq_zero_of_bot_submodule eq_zero_of_bot_submodule\n\n",
 "eq_locus_to_add_submonoid":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem eq_locus_to_add_submonoid (f g : «expr →ₛₗ[ ] » M τ₁₂ M₂) :\n    (f.eq_locus g).to_add_submonoid = (f : «expr →+ » M M₂).eq_mlocus g :=\n  rfl\n#align eq_locus_to_add_submonoid eq_locus_to_add_submonoid\n\n",
 "eq_locus_same":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem eq_locus_same (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) : f.eq_locus f = «expr⊤» :=\n  SetLike.ext fun _ => eq_self_iff_true _\n#align eq_locus_same eq_locus_same\n\n",
 "eq_locus_eq_ker_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem eq_locus_eq_ker_sub (f g : «expr →ₛₗ[ ] » M τ₁₂ M₂) : f.eq_locus g = (f - g).ker :=\n  SetLike.ext fun v => sub_eq_zero.symm\n#align eq_locus_eq_ker_sub eq_locus_eq_ker_sub\n\n",
 "eq_bot_of_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_bot_of_equiv [Module R₂ M₂] (e : «expr ≃ₛₗ[ ] » p σ₁₂ («expr⊥» : Submodule R₂ M₂)) : p = «expr⊥» :=\n  by\n  refine' bot_unique (SetLike.le_def.2 fun b hb => (Submodule.mem_bot R).2 _)\n  rw [← p.mk_eq_zero hb, ← e.map_eq_zero_iff]\n  apply Submodule.eq_zero_of_bot_submodule\n#align eq_bot_of_equiv eq_bot_of_equiv\n\n",
 "dom_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem dom_restrict_apply (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (p : Submodule R M) (x : p) : f.dom_restrict p x = f x :=\n  rfl\n#align dom_restrict_apply dom_restrict_apply\n\n",
 "dom_restrict'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem dom_restrict'_apply (f : «expr →ₗ[ ] » M R M₂) (p : Submodule R M) (x : p) : domRestrict' p f x = f x :=\n  rfl\n#align dom_restrict'_apply dom_restrict'_apply\n\n",
 "disjoint_ker'":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x y «expr ∈ » p) -/\ntheorem disjoint_ker' {p : Submodule R M} : Disjoint p (ker f) ↔ ∀ (x) (_ : x ∈ p) (y) (_ : y ∈ p), f x = f y → x = y :=\n  disjoint_ker.trans\n    ⟨fun H x hx y hy h => eq_of_sub_eq_zero <| H _ (sub_mem hx hy) (by simp [h]), fun H x h₁ h₂ =>\n      H x h₁ 0 (zero_mem _) (by simpa using h₂)⟩\n#align disjoint_ker' disjoint_ker'\n\n",
 "disjoint_ker":
 "theorem disjoint_ker {f : F} {p : Submodule R M} : Disjoint p (ker f) ↔ ∀ x ∈ p, f x = 0 → x = 0 := by\n  simp [disjoint_def]\n#align disjoint_ker disjoint_ker\n\n",
 "disjoint_iff_comap_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem disjoint_iff_comap_eq_bot {p q : Submodule R M} : Disjoint p q ↔ comap p.subtype q = «expr⊥» := by\n  rw [← (map_injective_of_injective (show injective p.subtype from Subtype.coe_injective)).eq_iff, map_comap_subtype,\n    map_bot, disjoint_iff]\n#align disjoint_iff_comap_eq_bot disjoint_iff_comap_eq_bot\n\n",
 "dfinsupp_sum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem dfinsupp_sum_apply\n    (t : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (γ i))\n    (g : ∀ i, γ i → «expr →ₛₗ[ ] » M σ₁₂ M₂) (b : M) : (t.sum g) b = t.sum fun i d => g i d b :=\n  sum_apply _ _ _\n#align dfinsupp_sum_apply dfinsupp_sum_apply\n\n",
 "conj_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem conj_trans (e₁ : «expr ≃ₗ[ ] » M R M₂) (e₂ : «expr ≃ₗ[ ] » M₂ R M₃) :\n    e₁.conj.trans e₂.conj = (e₁.trans e₂).conj := by\n  ext (f x)\n  rfl\n#align conj_trans conj_trans\n\n",
 "conj_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem conj_id (e : «expr ≃ₗ[ ] » M R M₂) : e.conj LinearMap.id = LinearMap.id :=\n  by\n  ext\n  simp [conj_apply]\n#align conj_id conj_id\n\n",
 "conj_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem conj_comp (e : «expr ≃ₗ[ ] » M R M₂) (f g : Module.End R M) : e.conj (g.comp f) = (e.conj g).comp (e.conj f) :=\n  arrowCongr_comp e e e f g\n#align conj_comp conj_comp\n\n",
 "conj_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem conj_apply_apply (e : «expr ≃ₗ[ ] » M R M₂) (f : Module.End R M) (x : M₂) : e.conj f x = e (f (e.symm x)) :=\n  rfl\n#align conj_apply_apply conj_apply_apply\n\n",
 "conj_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem conj_apply (e : «expr ≃ₗ[ ] » M R M₂) (f : Module.End R M) :\n    e.conj f = ((↑e : «expr →ₗ[ ] » M R M₂).comp f).comp (e.symm : «expr →ₗ[ ] » M₂ R M) :=\n  rfl\n#align conj_apply conj_apply\n\n",
 "comp_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_right_apply (f : «expr →ₗ[ ] » M₂ R M₃) (g : «expr →ₗ[ ] » M R M₂) : compRight f g = f.comp g :=\n  rfl\n#align comp_right_apply comp_right_apply\n\n",
 "comp_ker_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem comp_ker_subtype (f : «expr →ₛₗ[ ] » M τ₁₂ M₂) : f.comp f.ker.subtype = 0 :=\n  LinearMap.ext fun x =>\n    suffices f x = 0 by simp [this]\n    mem_ker.1 x.2\n#align comp_ker_subtype comp_ker_subtype\n\n",
 "comp_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem comp_cod_restrict (p : Submodule R₃ M₃) (h : ∀ b, g b ∈ p) :\n    ((codRestrict p g h).comp f : «expr →ₛₗ[ ] » M σ₁₃ p) = codRestrict p (g.comp f) fun b => h _ :=\n  ext fun b => rfl\n#align comp_cod_restrict comp_cod_restrict\n\n",
 "comp_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem comp_assoc (h : «expr →ₛₗ[ ] » M₃ σ₃₄ M₄) :\n    ((h.comp g : «expr →ₛₗ[ ] » M₂ σ₂₄ M₄).comp f : «expr →ₛₗ[ ] » M σ₁₄ M₄) =\n      h.comp (g.comp f : «expr →ₛₗ[ ] » M σ₁₃ M₃) :=\n  rfl\n#align comp_assoc comp_assoc\n\n",
 "commute_pow_left_of_commute":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem commute_pow_left_of_commute {f : «expr →ₛₗ[ ] » M σ₁₂ M₂} {g : Module.End R M} {g₂ : Module.End R₂ M₂}\n    (h : g₂.comp f = f.comp g) (k : ℕ) : (g₂ ^ k).comp f = f.comp (g ^ k) :=\n  by\n  induction' k with k ih\n  · simpa only [pow_zero]\n  ·\n    rw [pow_succ, pow_succ, LinearMap.mul_eq_comp, LinearMap.comp_assoc, ih, ← LinearMap.comp_assoc, h,\n      LinearMap.comp_assoc, LinearMap.mul_eq_comp]\n#align commute_pow_left_of_commute commute_pow_left_of_commute\n\n",
 "comap_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_zero : comap (0 : «expr →ₛₗ[ ] » M σ₁₂ M₂) q = «expr⊤» :=\n  ext <| by simp\n#align comap_zero comap_zero\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : F) : comap f («expr⊤») = «expr⊤» :=\n  rfl\n#align comap_top comap_top\n\n",
 "comap_surjective_of_injective":
 "theorem comap_surjective_of_injective : function.surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n#align comap_surjective_of_injective comap_surjective_of_injective\n\n",
 "comap_supr_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem comap_supr_map_of_injective {ι : Sort _} (S : ι → Submodule R M) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            ((S i).map f)).comap\n        f =\n      supᵢ S :=\n  (gciMapComap hf).u_supr_l _\n#align comap_supr_map_of_injective comap_supr_map_of_injective\n\n",
 "comap_sup_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem comap_sup_map_of_injective (p q : Submodule R M) : («expr ⊔ » (p.map f) (q.map f)).comap f = «expr ⊔ » p q :=\n  (gciMapComap hf).u_sup_l _ _\n#align comap_sup_map_of_injective comap_sup_map_of_injective\n\n",
 "comap_subtype_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_subtype_self : comap p.subtype p = «expr⊤» :=\n  comap_subtype_eq_top.2 le_rfl\n#align comap_subtype_self comap_subtype_self\n\n",
 "comap_subtype_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_subtype_eq_top {p p' : Submodule R M} : comap p.subtype p' = «expr⊤» ↔ p ≤ p' :=\n  eq_top_iff.trans <| map_le_iff_le_comap.symm.trans <| by rw [map_subtype_top]\n#align comap_subtype_eq_top comap_subtype_eq_top\n\n",
 "comap_strict_mono_of_surjective":
 "theorem comap_strict_mono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strict_mono_u\n#align comap_strict_mono_of_surjective comap_strict_mono_of_surjective\n\n",
 "comap_smul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_smul' (f : «expr →ₗ[ ] » V K V₂) (p : Submodule K V₂) (a : K) :\n    p.comap («expr • » a f) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (p.comap f) :=\n  by classical by_cases a = 0 <;> simp [h, comap_smul]\n#align comap_smul' comap_smul'\n\n",
 "comap_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem comap_smul (f : «expr →ₗ[ ] » V K V₂) (p : Submodule K V₂) (a : K) (h : a ≠ 0) :\n    p.comap («expr • » a f) = p.comap f := by\n  ext b <;> simp only [Submodule.mem_comap, p.smul_mem_iff h, LinearMap.smul_apply]\n#align comap_smul comap_smul\n\n",
 "comap_mono":
 "theorem comap_mono {f : F} {q q' : Submodule R₂ M₂} : q ≤ q' → comap f q ≤ comap f q' :=\n  preimage_mono\n#align comap_mono comap_mono\n\n",
 "comap_map_eq_of_injective":
 "theorem comap_map_eq_of_injective (p : Submodule R M) : (p.map f).comap f = p :=\n  (gciMapComap hf).u_l_eq _\n#align comap_map_eq_of_injective comap_map_eq_of_injective\n\n",
 "comap_le_comap_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem comap_le_comap_smul (fₗ : «expr →ₗ[ ] » N R N₂) (c : R) : comap fₗ qₗ ≤ comap («expr • » c fₗ) qₗ :=\n  by\n  rw [SetLike.le_def]\n  intro m h\n  change «expr • » c (fₗ m) ∈ qₗ\n  change fₗ m ∈ qₗ at h\n  apply qₗ.smul_mem _ h\n#align comap_le_comap_smul comap_le_comap_smul\n\n",
 "comap_le_comap_iff_of_surjective":
 "theorem comap_le_comap_iff_of_surjective (p q : Submodule R₂ M₂) : p.comap f ≤ q.comap f ↔ p ≤ q :=\n  (giMapComap hf).u_le_u_iff\n#align comap_le_comap_iff_of_surjective comap_le_comap_iff_of_surjective\n\n",
 "comap_le_comap_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comap_le_comap_iff {f : F} (hf : range f = «expr⊤») {p p'} : comap f p ≤ comap f p' ↔ p ≤ p' :=\n  ⟨fun H x hx => by rcases range_eq_top.1 hf x with ⟨y, hy, rfl⟩ <;> exact H hx, comap_mono⟩\n#align comap_le_comap_iff comap_le_comap_iff\n\n",
 "comap_injective_of_surjective":
 "theorem comap_injective_of_surjective : function.injective (comap f) :=\n  (giMapComap hf).u_injective\n#align comap_injective_of_surjective comap_injective_of_surjective\n\n",
 "comap_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem comap_injective {f : F} (hf : range f = «expr⊤») : injective (comap f) := fun p p' h =>\n  le_antisymm ((comap_le_comap_iff hf).1 (le_of_eq h)) ((comap_le_comap_iff hf).1 (ge_of_eq h))\n#align comap_injective comap_injective\n\n",
 "comap_infi_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi_map_of_injective {ι : Sort _} (S : ι → Submodule R M) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            ((S i).map f)).comap\n        f =\n      infᵢ S :=\n  (gciMapComap hf).u_infi_l _\n#align comap_infi_map_of_injective comap_infi_map_of_injective\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem comap_infi [RingHomSurjective σ₁₂] {ι : Sort _} (f : F) (p : ι → Submodule R₂ M₂) :\n    comap f («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (p i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (comap f (p i)) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf_map_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf_map_of_injective (p q : Submodule R M) : («expr ⊓ » (p.map f) (q.map f)).comap f = «expr ⊓ » p q :=\n  (gciMapComap hf).u_inf_l _ _\n#align comap_inf_map_of_injective comap_inf_map_of_injective\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem comap_inf (f : F) : comap f («expr ⊓ » q q') = «expr ⊓ » (comap f q) (comap f q') :=\n  rfl\n#align comap_inf comap_inf\n\n",
 "comap_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comap_id : comap (LinearMap.id : «expr →ₗ[ ] » M R M) p = p :=\n  SetLike.coe_injective rfl\n#align comap_id comap_id\n\n",
 "comap_equiv_eq_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem comap_equiv_eq_map_symm (e : «expr ≃ₛₗ[ ] » M τ₁₂ M₂) (K : Submodule R₂ M₂) :\n    K.comap (e : «expr →ₛₗ[ ] » M τ₁₂ M₂) = K.map (e.symm : «expr →ₛₗ[ ] » M₂ τ₂₁ M) :=\n  (map_equiv_eq_comap_symm e.symm K).symm\n#align comap_equiv_eq_map_symm comap_equiv_eq_map_symm\n\n",
 "comap_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem comap_comp (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) (g : «expr →ₛₗ[ ] » M₂ σ₂₃ M₃) (p : Submodule R₃ M₃) :\n    comap (g.comp f : «expr →ₛₗ[ ] » M σ₁₃ M₃) p = comap f (comap g p) :=\n  rfl\n#align comap_comp comap_comp\n\n",
 "comap_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem comap_coe (f : F) (p : Submodule R₂ M₂) : (comap f p : Set M) = «expr ⁻¹' » f p :=\n  rfl\n#align comap_coe comap_coe\n\n",
 "comap_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\ntheorem comap_cod_restrict (p : Submodule R M) (f : «expr →ₛₗ[ ] » M₂ σ₂₁ M) (hf p') :\n    Submodule.comap (codRestrict p f hf) p' = Submodule.comap f (map p.subtype p') :=\n  Submodule.ext fun x => ⟨fun h => ⟨⟨_, hf x⟩, h, rfl⟩, by rintro ⟨⟨_, _⟩, h, ⟨⟩⟩ <;> exact h⟩\n#align comap_cod_restrict comap_cod_restrict\n\n",
 "comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem comap_bot (f : F) : comap f («expr⊥») = ker f :=\n  rfl\n#align comap_bot comap_bot\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₛₗ[ ] » -/\n@[simp]\ntheorem coe_zero : «expr⇑ » (0 : «expr ≃ₛₗ[ ] » M σ₁₂ M₂) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul_right (f : «expr →ₗ[ ] » M₁ R S) (x : M) : (smulRight f x : M₁ → M) = fun c => «expr • » (f c) x :=\n  rfl\n#align coe_smul_right coe_smul_right\n\n",
 "coe_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem coe_pow (f : «expr →ₗ[ ] » M R M) (n : ℕ) : «expr⇑ » (f ^ n) = «expr ^[ ]» f n :=\n  by\n  ext m\n  apply pow_apply\n#align coe_pow coe_pow\n\n",
 "coe_of_top_symm_apply":
 "@[simp]\ntheorem coe_of_top_symm_apply {h} (x : M) : ((ofTop p h).symm x : M) = x :=\n  rfl\n#align coe_of_top_symm_apply coe_of_top_symm_apply\n\n",
 "coe_of_le":
 "@[simp]\ntheorem coe_of_le (h : p ≤ p') (x : p) : (ofLe h x : M) = x :=\n  rfl\n#align coe_of_le coe_of_le\n\n",
 "coe_of_eq_apply":
 "@[simp]\ntheorem coe_of_eq_apply (h : p = q) (x : p) : (ofEq p q h x : M) = x :=\n  rfl\n#align coe_of_eq_apply coe_of_eq_apply\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem coe_neg : «expr⇑ » (neg R : «expr ≃ₗ[ ] » M R M) = -id :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_fn_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp, norm_cast]\ntheorem coe_fn_sum {ι : Type _} (t : Finset ι) (f : ι → «expr →ₛₗ[ ] » M σ₁₂ M₂) :\n    «expr⇑ » (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n        (f i : M → M₂) :=\n  AddMonoidHom.map_sum ⟨@to_fun R R₂ _ _ σ₁₂ M M₂ _ _ _ _, rfl, fun x y => rfl⟩ _ _\n#align coe_fn_sum coe_fn_sum\n\n",
 "coe_finsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_finsupp_sum (t : «expr →₀ » ι γ) (g : ι → γ → «expr →ₛₗ[ ] » M σ₁₂ M₂) :\n    «expr⇑ » (t.sum g) = t.sum fun i d => g i d :=\n  coeFn_sum _ _\n#align coe_finsupp_sum coe_finsupp_sum\n\n",
 "coe_equiv_map_of_injective_apply":
 "@[simp]\ntheorem coe_equiv_map_of_injective_apply (f : F) (i : injective f) (p : Submodule R M) (x : p) :\n    (equivMapOfInjective f i p x : M₂) = f x :=\n  rfl\n#align coe_equiv_map_of_injective_apply coe_equiv_map_of_injective_apply\n\n",
 "coe_dfinsupp_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_dfinsupp_sum\n    (t : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (γ i))\n    (g : ∀ i, γ i → «expr →ₛₗ[ ] » M σ₁₂ M₂) : «expr⇑ » (t.sum g) = t.sum fun i d => g i d :=\n  coeFn_sum _ _\n#align coe_dfinsupp_sum coe_dfinsupp_sum\n\n",
 "coe_curry_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_curry_symm : «expr⇑ » (LinearEquiv.curry R V V₂).symm = uncurry :=\n  rfl\n#align coe_curry_symm coe_curry_symm\n\n",
 "coe_curry":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_curry : «expr⇑ » (LinearEquiv.curry R V V₂) = curry :=\n  rfl\n#align coe_curry coe_curry\n\n",
 "cod_restrict_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₛₗ[ ] » -/\n@[simp]\ntheorem cod_restrict_apply (p : Submodule R₂ M₂) (f : «expr →ₛₗ[ ] » M σ₁₂ M₂) {h} (x : M) :\n    (codRestrict p f h x : M₂) = f x :=\n  rfl\n#align cod_restrict_apply cod_restrict_apply\n\n",
 "arrow_congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem arrow_congr_trans {M₁ M₂ M₃ N₁ N₂ N₃ : Sort _} [AddCommMonoid M₁] [Module R M₁] [AddCommMonoid M₂] [Module R M₂]\n    [AddCommMonoid M₃] [Module R M₃] [AddCommMonoid N₁] [Module R N₁] [AddCommMonoid N₂] [Module R N₂]\n    [AddCommMonoid N₃] [Module R N₃] (e₁ : «expr ≃ₗ[ ] » M₁ R M₂) (e₂ : «expr ≃ₗ[ ] » N₁ R N₂)\n    (e₃ : «expr ≃ₗ[ ] » M₂ R M₃) (e₄ : «expr ≃ₗ[ ] » N₂ R N₃) :\n    (arrowCongr e₁ e₂).trans (arrowCongr e₃ e₄) = arrowCongr (e₁.trans e₃) (e₂.trans e₄) :=\n  rfl\n#align arrow_congr_trans arrow_congr_trans\n\n",
 "arrow_congr_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem arrow_congr_symm_apply {R M₁ M₂ M₂₁ M₂₂ : Sort _} [CommSemiring R] [AddCommMonoid M₁] [AddCommMonoid M₂]\n    [AddCommMonoid M₂₁] [AddCommMonoid M₂₂] [Module R M₁] [Module R M₂] [Module R M₂₁] [Module R M₂₂]\n    (e₁ : «expr ≃ₗ[ ] » M₁ R M₂) (e₂ : «expr ≃ₗ[ ] » M₂₁ R M₂₂) (f : «expr →ₗ[ ] » M₂ R M₂₂) (x : M₁) :\n    (arrowCongr e₁ e₂).symm f x = e₂.symm (f (e₁ x)) :=\n  rfl\n#align arrow_congr_symm_apply arrow_congr_symm_apply\n\n",
 "arrow_congr_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem arrow_congr_comp {N N₂ N₃ : Sort _} [AddCommMonoid N] [AddCommMonoid N₂] [AddCommMonoid N₃] [Module R N]\n    [Module R N₂] [Module R N₃] (e₁ : «expr ≃ₗ[ ] » M R N) (e₂ : «expr ≃ₗ[ ] » M₂ R N₂) (e₃ : «expr ≃ₗ[ ] » M₃ R N₃)\n    (f : «expr →ₗ[ ] » M R M₂) (g : «expr →ₗ[ ] » M₂ R M₃) :\n    arrowCongr e₁ e₃ (g.comp f) = (arrowCongr e₂ e₃ g).comp (arrowCongr e₁ e₂ f) :=\n  by\n  ext\n  simp only [symm_apply_apply, arrow_congr_apply, LinearMap.comp_apply]\n#align arrow_congr_comp arrow_congr_comp\n\n",
 "arrow_congr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem arrow_congr_apply {R M₁ M₂ M₂₁ M₂₂ : Sort _} [CommSemiring R] [AddCommMonoid M₁] [AddCommMonoid M₂]\n    [AddCommMonoid M₂₁] [AddCommMonoid M₂₂] [Module R M₁] [Module R M₂] [Module R M₂₁] [Module R M₂₂]\n    (e₁ : «expr ≃ₗ[ ] » M₁ R M₂) (e₂ : «expr ≃ₗ[ ] » M₂₁ R M₂₂) (f : «expr →ₗ[ ] » M₁ R M₂₁) (x : M₂) :\n    arrowCongr e₁ e₂ f x = e₂ (f (e₁.symm x)) :=\n  rfl\n#align arrow_congr_apply arrow_congr_apply\n\n",
 "apply_coe_mem_map":
 "theorem apply_coe_mem_map (f : F) {p : Submodule R M} (r : p) : f r ∈ map f p :=\n  mem_map_of_mem r.prop\n#align apply_coe_mem_map apply_coe_mem_map\n\n"}