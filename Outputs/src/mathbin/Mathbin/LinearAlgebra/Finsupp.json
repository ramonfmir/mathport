{"total_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_zero_apply (x : «expr →₀ » α R) : (finsupp.total α M R 0) x = 0 := by simp [finsupp.total_apply]\n#align total_zero_apply total_zero_apply\n\n",
 "total_zero":
 "@[simp]\ntheorem total_zero : finsupp.total α M R 0 = 0 :=\n  linear_map.ext (total_zero_apply R)\n#align total_zero total_zero\n\n",
 "total_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_unique [unique α] (l : «expr →₀ » α R) (v) :\n    finsupp.total α M R v l = «expr • » (l default) (v default) := by rw [← total_single, ← unique_single l]\n#align total_unique total_unique\n\n",
 "total_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_total {α β : Type _} (A : α → M) (B : β → «expr →₀ » α R) (f : «expr →₀ » β R) :\n    finsupp.total α M R A (finsupp.total β («expr →₀ » α R) R B f) =\n      finsupp.total β M R (fun b => finsupp.total α M R A (B b)) f :=\n  by\n  simp only [total_apply]\n  apply induction_linear f\n  · simp only [sum_zero_index]\n  · intro f₁ f₂ h₁ h₂\n    simp [sum_add_index, h₁, h₂, add_smul]\n  · simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]\n#align total_total total_total\n\n",
 "total_surjective":
 "theorem total_surjective (h : function.surjective v) : function.surjective (finsupp.total α M R v) :=\n  by\n  intro x\n  obtain ⟨y, hy⟩ := h x\n  exact ⟨finsupp.single y 1, by simp [hy]⟩\n#align total_surjective total_surjective\n\n",
 "total_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem total_single (c : R) (a : α) : finsupp.total α M R v (single a c) = «expr • » c (v a) := by\n  simp [total_apply, sum_single_index]\n#align total_single total_single\n\n",
 "total_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem total_range (h : function.surjective v) : (finsupp.total α M R v).range = «expr⊤» :=\n  range_eq_top.2 <| total_surjective R h\n#align total_range total_range\n\n",
 "total_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_option (v : option α → M) (f : «expr →₀ » (option α) R) :\n    finsupp.total (option α) M R v f = «expr • » (f none) (v none) + finsupp.total α M R (v ∘ option.some) f.some := by\n  rw [total_apply, sum_option_index_smul, total_apply]\n#align total_option total_option\n\n",
 "total_on_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem total_on_range (s : set α) : (finsupp.total_on α M R v s).range = «expr⊤» :=\n  by\n  rw [finsupp.total_on, linear_map.range_eq_map, linear_map.map_cod_restrict, ← linear_map.range_le_iff_comap,\n    range_subtype, map_top, linear_map.range_comp, range_subtype]\n  exact (span_image_eq_map_total _ _).le\n#align total_on_range total_on_range\n\n",
 "total_on_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_on_finset {s : Finset α} {f : α → R} (g : α → M) (hf : ∀ a, f a ≠ 0 → a ∈ s) :\n    finsupp.total α M R g (finsupp.on_finset s f hf) = finset.sum s fun x : α => «expr • » (f x) (g x) :=\n  by\n  simp only [finsupp.total_apply, finsupp.sum, finsupp.on_finset_apply, finsupp.support_on_finset]\n  rw [finset.sum_filter_of_ne]\n  intro x hx h\n  contrapose! h\n  simp [h]\n#align total_on_finset total_on_finset\n\n",
 "total_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_map_domain (f : α → α') (l : «expr →₀ » α R) :\n    (finsupp.total α' M' R v') (map_domain f l) = (finsupp.total α M' R (v' ∘ f)) l :=\n  linear_map.congr_fun (total_comp_lmap_domain _ _) l\n#align total_map_domain total_map_domain\n\n",
 "total_id_surjective":
 "/-- Any module is a quotient of a free module. This is stated as surjectivity of\n`finsupp.total M M R id : (M →₀ R) →ₗ[R] M`. -/\ntheorem total_id_surjective (M) [add_comm_monoid M] [Module R M] : function.surjective (finsupp.total M M R id) :=\n  total_surjective R function.surjective_id\n#align total_id_surjective total_id_surjective\n\n",
 "total_fin_zero":
 "@[simp]\ntheorem total_fin_zero (f : fin 0 → M) : finsupp.total (fin 0) M R f = 0 :=\n  by\n  ext i\n  apply finZeroElim i\n#align total_fin_zero total_fin_zero\n\n",
 "total_equiv_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_equiv_map_domain (f : «expr ≃ » α α') (l : «expr →₀ » α R) :\n    (finsupp.total α' M' R v') (equiv_map_domain f l) = (finsupp.total α M' R (v' ∘ f)) l := by\n  rw [equiv_map_domain_eq_map_domain, total_map_domain]\n#align total_equiv_map_domain total_equiv_map_domain\n\n",
 "total_eq_fintype_total_apply":
 "theorem finsupp.total_eq_fintype_total_apply (x : α → R) :\n    finsupp.total α M R v ((finsupp.linear_equiv_fun_on_finite R R α).symm x) = fintype.total R S v x :=\n  by\n  apply finset.sum_subset\n  · exact finset.subset_univ _\n  · intro x _ hx\n    rw [finsupp.not_mem_support_iff.mp hx]\n    exact zero_smul _ _\n#align finsupp.total_eq_fintype_total_apply finsupp.total_eq_fintype_total_apply\n\n",
 "total_eq_fintype_total":
 "theorem finsupp.total_eq_fintype_total :\n    (finsupp.total α M R v).comp (finsupp.linear_equiv_fun_on_finite R R α).symm.to_linear_map = fintype.total R S v :=\n  linear_map.ext <| finsupp.total_eq_fintype_total_apply R S v\n#align finsupp.total_eq_fintype_total finsupp.total_eq_fintype_total\n\n",
 "total_emb_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_emb_domain (f : «expr ↪ » α α') (l : «expr →₀ » α R) :\n    (finsupp.total α' M' R v') (emb_domain f l) = (finsupp.total α M' R (v' ∘ f)) l := by\n  simp [total_apply, finsupp.sum, support_emb_domain, emb_domain_apply]\n#align total_emb_domain total_emb_domain\n\n",
 "total_comp_lmap_domain":
 "theorem total_comp_lmap_domain (f : α → α') :\n    (finsupp.total α' M' R v').comp (finsupp.lmap_domain R R f) = finsupp.total α M' R (v' ∘ f) :=\n  by\n  ext\n  simp\n#align total_comp_lmap_domain total_comp_lmap_domain\n\n",
 "total_comp":
 "theorem total_comp (f : α' → α) : finsupp.total α' M R (v ∘ f) = (finsupp.total α M R v).comp (lmap_domain R R f) :=\n  by\n  ext\n  simp [total_apply]\n#align total_comp total_comp\n\n",
 "total_comap_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_comap_domain (f : α → α') (l : «expr →₀ » α' R) (hf : Set.InjOn f («expr ⁻¹' » f ↑l.support)) :\n    finsupp.total α M R v (finsupp.comap_domain f l hf) =\n      (l.support.preimage f hf).sum fun i => «expr • » (l (f i)) (v i) :=\n  by rw [finsupp.total_apply] <;> rfl\n#align total_comap_domain total_comap_domain\n\n",
 "total_apply_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem fintype.total_apply_single (i : α) (r : R) : fintype.total R S v (Pi.single i r) = «expr • » r (v i) :=\n  by\n  simp_rw [fintype.total_apply, Pi.single_apply, ite_smul, zero_smul]\n  rw [finset.sum_ite_eq', if_pos (finset.mem_univ _)]\n#align fintype.total_apply_single fintype.total_apply_single\n\n",
 "total_apply_of_mem_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_apply_of_mem_supported {l : «expr →₀ » α R} {s : Finset α} (hs : l ∈ supported R R (↑s : set α)) :\n    finsupp.total α M R v l = s.sum fun i => «expr • » (l i) (v i) :=\n  finset.sum_subset hs fun x _ hxg => show «expr • » (l x) (v x) = 0 by rw [not_mem_support_iff.1 hxg, zero_smul]\n#align total_apply_of_mem_supported total_apply_of_mem_supported\n\n",
 "total_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fintype.total_apply (f) :\n    fintype.total R S v f =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f i) (v i)) :=\n  rfl\n#align fintype.total_apply fintype.total_apply\n\n",
 "top_le_span_range_iff_forall_exists_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A family `v : α → V` is generating `V` iff every element `(x : V)`\ncan be written as sum `∑ cᵢ • vᵢ = x`.\n-/\ntheorem top_le_span_range_iff_forall_exists_fun :\n    «expr⊤» ≤ span R (range v) ↔\n      ∀ x,\n        ∃ c : α → R,\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (c i) (v i)) =\n            x :=\n  by\n  simp_rw [← mem_span_range_iff_exists_fun]\n  exact ⟨fun h x => h trivial, fun h x _ => h x⟩\n#align top_le_span_range_iff_forall_exists_fun top_le_span_range_iff_forall_exists_fun\n\n",
 "supr_lsingle_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem supr_lsingle_range :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range =\n      «expr⊤» :=\n  by\n  refine' eq_top_iff.2 <| SetLike.le_def.2 fun f _ => _\n  rw [← sum_single f]\n  exact sum_mem fun a ha => submodule.mem_supr_of_mem a ⟨_, rfl⟩\n#align supr_lsingle_range supr_lsingle_range\n\n",
 "supported_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem supported_univ : supported M R (Set.univ : set α) = «expr⊤» :=\n  eq_top_iff.2 fun l _ => Set.subset_univ _\n#align supported_univ supported_univ\n\n",
 "supported_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem supported_union (s t : set α) : supported M R (s ∪ t) = «expr ⊔ » (supported M R s) (supported M R t) := by\n  erw [Set.union_eq_unionᵢ, supported_Union, supᵢ_bool_eq] <;> rfl\n#align supported_union supported_union\n\n",
 "supported_mono":
 "theorem supported_mono {s t : set α} (st : s ⊆ t) : supported M R s ≤ supported M R t := fun l h =>\n  Set.Subset.trans h st\n#align supported_mono supported_mono\n\n",
 "supported_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem supported_inter (s t : set α) : supported M R (s ∩ t) = «expr ⊓ » (supported M R s) (supported M R t) := by\n  rw [Set.inter_eq_interᵢ, supported_Inter, infᵢ_bool_eq] <;> rfl\n#align supported_inter supported_inter\n\n",
 "supported_eq_span_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supported_eq_span_single (s : set α) : supported R R s = span R («expr '' » (fun i => single i 1) s) :=\n  by\n  refine' (span_eq_of_le _ _ (SetLike.le_def.2 fun l hl => _)).symm\n  · rintro _ ⟨_, hp, rfl⟩\n    exact single_mem_supported R 1 hp\n  · rw [← l.sum_single]\n    refine' sum_mem fun i il => _\n    convert @smul_mem R («expr →₀ » α R) _ _ _ _ (single i 1) (l i) _\n    · simp\n    apply subset_span\n    apply Set.mem_image_of_mem _ (hl il)\n#align supported_eq_span_single supported_eq_span_single\n\n",
 "supported_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem supported_empty : supported M R (∅ : set α) = «expr⊥» :=\n  eq_bot_iff.2 fun l h => (submodule.mem_bot R).2 <| by ext <;> simp_all [mem_supported']\n#align supported_empty supported_empty\n\n",
 "supported_comap_lmap_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem supported_comap_lmap_domain (f : α → α') (s : set α') :\n    supported M R («expr ⁻¹' » f s) ≤ (supported M R s).comap (lmap_domain M R f) :=\n  fun l (hl : ↑l.support ⊆ «expr ⁻¹' » f s) =>\n  show ↑(map_domain f l).support ⊆ s\n    by\n    rw [← Set.image_subset_iff, ← Finset.coe_image] at hl\n    exact Set.Subset.trans map_domain_support hl\n#align supported_comap_lmap_domain supported_comap_lmap_domain\n\n",
 "supported_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supported_Union {δ : Type _} (s : δ → set α) :\n    supported M R\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (supported M R (s i)) :=\n  by\n  refine' le_antisymm _ (supᵢ_le fun i => supported_mono <| Set.subset_unionᵢ _ _)\n  haveI :=\n    classical.dec_pred fun x =>\n      x ∈ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)\n  suffices\n    ((submodule.subtype _).comp\n          (restrict_dom M R\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (s i)))).range ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (supported M R (s i))\n    by rwa [linear_map.range_comp, range_restrict_dom, map_top, range_subtype] at this\n  rw [range_le_iff_comap, eq_top_iff]\n  rintro l ⟨⟩\n  apply finsupp.induction l\n  · exact zero_mem _\n  refine' fun x a l hl a0 => add_mem _\n  by_cases ∃ i, x ∈ s i <;> simp [h]\n  · cases' h with i hi\n    exact le_supᵢ (fun i => supported M R (s i)) i (single_mem_supported R _ hi)\n#align supported_Union supported_Union\n\n",
 "supported_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem supported_Inter {ι : Type _} (s : ι → set α) :\n    supported M R\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (supported M R (s i)) :=\n  submodule.ext fun x => by simp [mem_supported, subset_Inter_iff]\n#align supported_Inter supported_Inter\n\n",
 "sum_finsupp_lequiv_prod_finsupp_symm_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_lequiv_prod_finsupp_symm_inr {α β : Type _} (fg : «expr →₀ » α M × «expr →₀ » β M) (y : β) :\n    ((sum_finsupp_lequiv_prod_finsupp R).symm fg) (sum.inr y) = fg.2 y :=\n  rfl\n#align sum_finsupp_lequiv_prod_finsupp_symm_inr sum_finsupp_lequiv_prod_finsupp_symm_inr\n\n",
 "sum_finsupp_lequiv_prod_finsupp_symm_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_lequiv_prod_finsupp_symm_inl {α β : Type _} (fg : «expr →₀ » α M × «expr →₀ » β M) (x : α) :\n    ((sum_finsupp_lequiv_prod_finsupp R).symm fg) (sum.inl x) = fg.1 x :=\n  rfl\n#align sum_finsupp_lequiv_prod_finsupp_symm_inl sum_finsupp_lequiv_prod_finsupp_symm_inl\n\n",
 "splitting_of_fun_on_fintype_surjective_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- See also `linear_map.splitting_of_finsupp_surjective`\ntheorem splitting_of_fun_on_fintype_surjective_splits [fintype α] (f : «expr →ₗ[ ] » M R (α → R)) (s : surjective f) :\n    f.comp (splitting_of_fun_on_fintype_surjective f s) = linear_map.id :=\n  by\n  ext (x y)\n  dsimp [splitting_of_fun_on_fintype_surjective]\n  rw [linear_equiv_fun_on_finite_symm_single, finsupp.sum_single_index, one_smul, (s (finsupp.single x 1)).some_spec,\n    finsupp.single_eq_pi_single]\n  rw [zero_smul]\n#align splitting_of_fun_on_fintype_surjective_splits splitting_of_fun_on_fintype_surjective_splits\n\n",
 "splitting_of_fun_on_fintype_surjective_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem splitting_of_fun_on_fintype_surjective_injective [fintype α] (f : «expr →ₗ[ ] » M R (α → R))\n    (s : surjective f) : injective (splitting_of_fun_on_fintype_surjective f s) :=\n  (left_inverse_splitting_of_fun_on_fintype_surjective f s).injective\n#align splitting_of_fun_on_fintype_surjective_injective splitting_of_fun_on_fintype_surjective_injective\n\n",
 "splitting_of_finsupp_surjective_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n-- See also `linear_map.splitting_of_fun_on_fintype_surjective`\ntheorem splitting_of_finsupp_surjective_splits (f : «expr →ₗ[ ] » M R («expr →₀ » α R)) (s : surjective f) :\n    f.comp (splitting_of_finsupp_surjective f s) = linear_map.id :=\n  by\n  ext (x y)\n  dsimp [splitting_of_finsupp_surjective]\n  congr\n  rw [sum_single_index, one_smul]\n  · exact (s (finsupp.single x 1)).some_spec\n  · rw [zero_smul]\n#align splitting_of_finsupp_surjective_splits splitting_of_finsupp_surjective_splits\n\n",
 "splitting_of_finsupp_surjective_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem splitting_of_finsupp_surjective_injective (f : «expr →ₗ[ ] » M R («expr →₀ » α R)) (s : surjective f) :\n    injective (splitting_of_finsupp_surjective f s) :=\n  (left_inverse_splitting_of_finsupp_surjective f s).injective\n#align splitting_of_finsupp_surjective_injective splitting_of_finsupp_surjective_injective\n\n",
 "span_single_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem span_single_image (s : set M) (a : α) :\n    submodule.span R («expr '' » (single a) s) =\n      (submodule.span R s).map (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)) :=\n  by rw [← span_image] <;> rfl\n#align span_single_image span_single_image\n\n",
 "span_image_eq_map_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem span_image_eq_map_total (s : set α) :\n    span R («expr '' » v s) = submodule.map (finsupp.total α M R v) (supported R R s) :=\n  by\n  apply span_eq_of_le\n  · intro x hx\n    rw [Set.mem_image] at hx\n    apply exists.elim hx\n    intro i hi\n    exact ⟨_, finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]⟩\n  · refine' map_le_iff_le_comap.2 fun z hz => _\n    have : ∀ i, «expr • » (z i) (v i) ∈ span R («expr '' » v s) :=\n      by\n      intro c\n      haveI := classical.dec_pred fun x => x ∈ s\n      by_cases c ∈ s\n      · exact smul_mem _ _ (subset_span (Set.mem_image_of_mem _ h))\n      · simp [(finsupp.mem_supported' R _).1 hz _ h]\n    refine' sum_mem _\n    simp [this]\n#align span_image_eq_map_total span_image_eq_map_total\n\n",
 "span_eq_range_total":
 "/-- A version of `finsupp.range_total` which is useful for going in the other direction -/\ntheorem span_eq_range_total (s : set M) : span R s = (finsupp.total s M R coe).range := by\n  rw [range_total, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n#align span_eq_range_total span_eq_range_total\n\n",
 "snd_sum_finsupp_lequiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem snd_sum_finsupp_lequiv_prod_finsupp {α β : Type _} (f : «expr →₀ » (Sum α β) M) (y : β) :\n    (sum_finsupp_lequiv_prod_finsupp R f).2 y = f (sum.inr y) :=\n  rfl\n#align snd_sum_finsupp_lequiv_prod_finsupp snd_sum_finsupp_lequiv_prod_finsupp\n\n",
 "single_mem_supported":
 "theorem single_mem_supported {s : set α} {a : α} (b : M) (h : a ∈ s) : single a b ∈ supported M R s :=\n  Set.Subset.trans support_single_subset (Finset.singleton_subset_set_iff.2 h)\n#align single_mem_supported single_mem_supported\n\n",
 "sigma_finsupp_lequiv_pi_finsupp_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sigma_finsupp_lequiv_pi_finsupp_symm_apply {M : Type _} {ιs : η → Type _} [add_comm_monoid M] [Module R M]\n    (f : ∀ j, «expr →₀ » (ιs j) M) (ji) : (finsupp.sigma_finsupp_lequiv_pi_finsupp R).symm f ji = f ji.1 ji.2 :=\n  rfl\n#align sigma_finsupp_lequiv_pi_finsupp_symm_apply sigma_finsupp_lequiv_pi_finsupp_symm_apply\n\n",
 "sigma_finsupp_lequiv_pi_finsupp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sigma_finsupp_lequiv_pi_finsupp_apply {M : Type _} {ιs : η → Type _} [add_comm_monoid M] [Module R M]\n    (f : «expr →₀ » (Σj, ιs j) M) (j i) : sigma_finsupp_lequiv_pi_finsupp R f j i = f ⟨j, i⟩ :=\n  rfl\n#align sigma_finsupp_lequiv_pi_finsupp_apply sigma_finsupp_lequiv_pi_finsupp_apply\n\n",
 "restrict_dom_comp_subtype":
 "theorem restrict_dom_comp_subtype (s : set α) : (restrict_dom M R s).comp (submodule.subtype _) = linear_map.id :=\n  by\n  ext (l a)\n  by_cases a ∈ s <;> simp [h]\n  exact ((mem_supported' R l.1).1 l.2 a h).symm\n#align restrict_dom_comp_subtype restrict_dom_comp_subtype\n\n",
 "restrict_dom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem restrict_dom_apply (s : set α) (l : «expr →₀ » α M) :\n    ((restrict_dom M R s : «expr →ₗ[ ] » («expr →₀ » α M) R (supported M R s)) l : «expr →₀ » α M) =\n      finsupp.filter (· ∈ s) l :=\n  rfl\n#align restrict_dom_apply restrict_dom_apply\n\n",
 "range_total":
 "@[simp]\ntheorem fintype.range_total : (fintype.total R S v).range = submodule.span R (Set.range v) := by\n  rw [← finsupp.total_eq_fintype_total, linear_map.range_comp, linear_equiv.to_linear_map_eq_coe, linear_equiv.range,\n    submodule.map_top, finsupp.range_total]\n#align fintype.range_total fintype.range_total\n\n",
 "range_restrict_dom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_restrict_dom (s : set α) : (restrict_dom M R s).range = «expr⊤» :=\n  range_eq_top.2 <| function.right_inverse.surjective <| linear_map.congr_fun (restrict_dom_comp_subtype s)\n#align range_restrict_dom range_restrict_dom\n\n",
 "mem_supr_iff_exists_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- `submodule.exists_finset_of_mem_supr` as an `iff` -/\ntheorem submodule.mem_supr_iff_exists_finset {ι : Sort _} {p : ι → submodule R M} {m : M} :\n    m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) ↔\n      ∃ s : Finset ι,\n        m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) :=\n  ⟨submodule.exists_finset_of_mem_supr p, fun ⟨_, hs⟩ => supᵢ_mono (fun i => (supᵢ_const_le : _ ≤ p i)) hs⟩\n#align submodule.mem_supr_iff_exists_finset submodule.mem_supr_iff_exists_finset\n\n",
 "mem_supported_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_supported_support (p : «expr →₀ » α M) : p ∈ finsupp.supported M R (p.support : set α) := by\n  rw [finsupp.mem_supported]\n#align mem_supported_support mem_supported_support\n\n",
 "mem_supported'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (x «expr ∉ » s) -/\ntheorem mem_supported' {s : set α} (p : «expr →₀ » α M) : p ∈ supported M R s ↔ ∀ (x) (_ : x ∉ s), p x = 0 := by\n  haveI := classical.dec_pred fun x : α => x ∈ s <;> simp [mem_supported, Set.subset_def, not_imp_comm]\n#align mem_supported' mem_supported'\n\n",
 "mem_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_supported {s : set α} (p : «expr →₀ » α M) : p ∈ supported M R s ↔ ↑p.support ⊆ s :=\n  iff.rfl\n#align mem_supported mem_supported\n\n",
 "mem_span_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An element `m ∈ M` is contained in the `R`-submodule spanned by a set `s ⊆ M`, if and only if\n`m` can be written as a finite `R`-linear combination of elements of `s`.\nThe implementation uses `finsupp.sum`. -/\ntheorem mem_span_set {m : M} {s : set M} :\n    m ∈ submodule.span R s ↔ ∃ c : «expr →₀ » M R, (c.support : set M) ⊆ s ∧ (c.sum fun mi r => «expr • » r mi) = m :=\n  by\n  conv_lhs => rw [← Set.image_id s]\n  simp_rw [← exists_prop]\n  exact finsupp.mem_span_image_iff_total R\n#align mem_span_set mem_span_set\n\n",
 "mem_span_range_iff_exists_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- An element `x` lies in the span of `v` iff it can be written as sum `∑ cᵢ • vᵢ = x`.\n-/\ntheorem mem_span_range_iff_exists_fun :\n    x ∈ span R (range v) ↔\n      ∃ c : α → R,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (v i)) =\n          x :=\n  by\n  simp only [finsupp.mem_span_range_iff_exists_finsupp, finsupp.equiv_fun_on_finite.surjective.exists,\n    finsupp.equiv_fun_on_finite_apply]\n  exact exists_congr fun c => eq.congr_left <| finsupp.sum_fintype _ _ fun i => zero_smul _ _\n#align mem_span_range_iff_exists_fun mem_span_range_iff_exists_fun\n\n",
 "mem_span_range_iff_exists_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_range_iff_exists_finsupp {v : α → M} {x : M} :\n    x ∈ span R (range v) ↔ ∃ c : «expr →₀ » α R, (c.sum fun i a => «expr • » a (v i)) = x := by\n  simp only [← finsupp.range_total, linear_map.mem_range, finsupp.total_apply]\n#align mem_span_range_iff_exists_finsupp mem_span_range_iff_exists_finsupp\n\n",
 "mem_span_image_iff_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_span_image_iff_total {s : set α} {x : M} :\n    x ∈ span R («expr '' » v s) ↔ ∃ l ∈ supported R R s, finsupp.total α M R v l = x :=\n  by\n  rw [span_image_eq_map_total]\n  simp\n#align mem_span_image_iff_total mem_span_image_iff_total\n\n",
 "mem_span_iff_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_span_iff_total (s : set M) (x : M) : x ∈ span R s ↔ ∃ l : «expr →₀ » s R, finsupp.total s M R coe l = x :=\n  (SetLike.ext_iff.1 <| span_eq_range_total _ _) x\n#align mem_span_iff_total mem_span_iff_total\n\n",
 "mem_span_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_finset {s : Finset M} {x : M} :\n    x ∈ span R (↑s : set M) ↔\n      ∃ f : M → R,\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n            («expr • » (f i) i) =\n          x :=\n  ⟨fun hx =>\n    let ⟨v, hvs, hvx⟩ :=\n      (finsupp.mem_span_image_iff_total _).1 (show x ∈ span R («expr '' » id (↑s : set M)) by rwa [Set.image_id])\n    ⟨v, hvx ▸ (finsupp.total_apply_of_mem_supported _ hvs).symm⟩,\n    fun ⟨f, hf⟩ => hf ▸ sum_mem fun i hi => smul_mem _ _ <| subset_span hi⟩\n#align mem_span_finset mem_span_finset\n\n",
 "map_finsupp_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem linear_map.map_finsupp_total (f : «expr →ₗ[ ] » M R N) {ι : Type _} {g : ι → M} (l : «expr →₀ » ι R) :\n    f (finsupp.total ι M R g l) = finsupp.total ι N R (f ∘ g) l := by\n  simp only [finsupp.total_apply, finsupp.total_apply, finsupp.sum, f.map_sum, f.map_smul]\n#align linear_map.map_finsupp_total linear_map.map_finsupp_total\n\n",
 "lsum_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsum_symm_apply (f : «expr →ₗ[ ] » («expr →₀ » α M) R N) (x : α) : (lsum S).symm f x = f.comp (lsingle x) :=\n  rfl\n#align lsum_symm_apply lsum_symm_apply\n\n",
 "lsum_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lsum_single (f : α → «expr →ₗ[ ] » M R N) (i : α) (m : M) : finsupp.lsum S f (finsupp.single i m) = f i m :=\n  finsupp.sum_single_index (f i).map_zero\n#align lsum_single lsum_single\n\n",
 "lsum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsum_apply (f : α → «expr →ₗ[ ] » M R N) (l : «expr →₀ » α M) : finsupp.lsum S f l = l.sum fun b => f b :=\n  rfl\n#align lsum_apply lsum_apply\n\n",
 "lsubtype_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsubtype_domain_apply (f : «expr →₀ » α M) :\n    (lsubtype_domain s : «expr →ₗ[ ] » («expr →₀ » α M) R («expr →₀ » s M)) f = subtype_domain (fun x => x ∈ s) f :=\n  rfl\n#align lsubtype_domain_apply lsubtype_domain_apply\n\n",
 "lsingle_range_le_ker_lapply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsingle_range_le_ker_lapply (s t : set α) (h : Disjoint s t) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (lapply a : «expr →ₗ[ ] » («expr →₀ » α M) R M)) :=\n  by\n  refine' supᵢ_le fun a₁ => supᵢ_le fun h₁ => range_le_iff_comap.2 _\n  simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_infi, mem_infi]\n  intro b hb a₂ h₂\n  have : a₁ ≠ a₂ := fun eq => h.le_bot ⟨h₁, eq.symm ▸ h₂⟩\n  exact single_eq_of_ne this\n#align lsingle_range_le_ker_lapply lsingle_range_le_ker_lapply\n\n",
 "lsingle_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lsingle_apply (a : α) (b : M) : (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)) b = single a b :=\n  rfl\n#align lsingle_apply lsingle_apply\n\n",
 "lmap_domain_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lmap_domain_total (f : α → α') (g : «expr →ₗ[ ] » M R M') (h : ∀ i, g (v i) = v' (f i)) :\n    (finsupp.total α' M' R v').comp (lmap_domain R R f) = g.comp (finsupp.total α M R v) := by\n  ext l <;> simp [total_apply, finsupp.sum_map_domain_index, add_smul, h]\n#align lmap_domain_total lmap_domain_total\n\n",
 "lmap_domain_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem lmap_domain_supported [nonempty α] (f : α → α') (s : set α) :\n    (supported M R s).map (lmap_domain M R f) = supported M R («expr '' » f s) :=\n  by\n  inhabit α\n  refine'\n    le_antisymm\n      (map_le_iff_le_comap.2 <|\n        le_trans (supported_mono <| Set.subset_preimage_image _ _) (supported_comap_lmap_domain _ _ _ _))\n      _\n  intro l hl\n  refine'\n    ⟨(lmap_domain M R (Function.invFunOn f s) : «expr →ₗ[ ] » («expr →₀ » α' M) R («expr →₀ » α M)) l, fun x hx => _, _⟩\n  · rcases Finset.mem_image.1 (map_domain_support hx) with ⟨c, hc, rfl⟩\n    exact Function.invFunOn_mem (by simpa using hl hc)\n  · rw [← linear_map.comp_apply, ← lmap_domain_comp]\n    refine' (map_domain_congr fun c hc => _).trans map_domain_id\n    exact Function.invFunOn_eq (by simpa using hl hc)\n#align lmap_domain_supported lmap_domain_supported\n\n",
 "lmap_domain_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lmap_domain_id : (lmap_domain M R id : «expr →ₗ[ ] » («expr →₀ » α M) R («expr →₀ » α M)) = linear_map.id :=\n  linear_map.ext fun l => map_domain_id\n#align lmap_domain_id lmap_domain_id\n\n",
 "lmap_domain_disjoint_ker":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (a b «expr ∈ » s) -/\ntheorem lmap_domain_disjoint_ker (f : α → α') {s : set α} (H : ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), f a = f b → a = b) :\n    Disjoint (supported M R s) (lmap_domain M R f).ker :=\n  by\n  rw [disjoint_iff_inf_le]\n  rintro l ⟨h₁, h₂⟩\n  rw [SetLike.mem_coe, mem_ker, lmap_domain_apply, map_domain] at h₂\n  simp; ext x\n  haveI := classical.dec_pred fun x => x ∈ s\n  by_cases xs : x ∈ s\n  · have : finsupp.sum l (fun a => finsupp.single (f a)) (f x) = 0 :=\n      by\n      rw [h₂]\n      rfl\n    rw [finsupp.sum_apply, finsupp.sum, finset.sum_eq_single x] at this\n    · simpa [finsupp.single_apply]\n    · intro y hy xy\n      simp [mt (H _ (h₁ hy) _ xs) xy]\n    · simp (config := { contextual := true })\n  · by_contra h\n    exact xs (h₁ <| finsupp.mem_support_iff.2 h)\n#align lmap_domain_disjoint_ker lmap_domain_disjoint_ker\n\n",
 "lmap_domain_comp":
 "theorem lmap_domain_comp (f : α → α') (g : α' → α'') :\n    lmap_domain M R (g ∘ f) = (lmap_domain M R g).comp (lmap_domain M R f) :=\n  linear_map.ext fun l => map_domain_comp\n#align lmap_domain_comp lmap_domain_comp\n\n",
 "lmap_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lmap_domain_apply (f : α → α') (l : «expr →₀ » α M) :\n    (lmap_domain M R f : «expr →ₗ[ ] » («expr →₀ » α M) R («expr →₀ » α' M)) l = map_domain f l :=\n  rfl\n#align lmap_domain_apply lmap_domain_apply\n\n",
 "linear_map_to_add_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_map_to_add_monoid_hom (f : «expr →ₗ[ ] » M R N) :\n    (map_range.linear_map f).to_add_monoid_hom =\n      (map_range.add_monoid_hom f.to_add_monoid_hom : «expr →+ » («expr →₀ » α M) _) :=\n  AddMonoidHom.ext fun _ => rfl\n#align map_range.linear_map_to_add_monoid_hom map_range.linear_map_to_add_monoid_hom\n\n",
 "linear_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_map_id :\n    map_range.linear_map linear_map.id = (linear_map.id : «expr →ₗ[ ] » («expr →₀ » α M) R _) :=\n  linear_map.ext map_range_id\n#align map_range.linear_map_id map_range.linear_map_id\n\n",
 "linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.linear_map_comp (f : «expr →ₗ[ ] » N R P) (f₂ : «expr →ₗ[ ] » M R N) :\n    (map_range.linear_map (f.comp f₂) : «expr →ₗ[ ] » («expr →₀ » α _) R _) =\n      (map_range.linear_map f).comp (map_range.linear_map f₂) :=\n  linear_map.ext <| map_range_comp _ _ _ _ _\n#align map_range.linear_map_comp map_range.linear_map_comp\n\n",
 "linear_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.linear_equiv_trans (f : «expr ≃ₗ[ ] » M R N) (f₂ : «expr ≃ₗ[ ] » N R P) :\n    (map_range.linear_equiv (f.trans f₂) : «expr ≃ₗ[ ] » («expr →₀ » α _) R _) =\n      (map_range.linear_equiv f).trans (map_range.linear_equiv f₂) :=\n  linear_equiv.ext <| map_range_comp _ _ _ _ _\n#align map_range.linear_equiv_trans map_range.linear_equiv_trans\n\n",
 "linear_equiv_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_to_linear_map (f : «expr ≃ₗ[ ] » M R N) :\n    (map_range.linear_equiv f).to_linear_map =\n      (map_range.linear_map f.to_linear_map : «expr →ₗ[ ] » («expr →₀ » α M) R _) :=\n  linear_map.ext fun _ => rfl\n#align map_range.linear_equiv_to_linear_map map_range.linear_equiv_to_linear_map\n\n",
 "linear_equiv_to_add_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_to_add_equiv (f : «expr ≃ₗ[ ] » M R N) :\n    (map_range.linear_equiv f).to_add_equiv = (map_range.add_equiv f.to_add_equiv : «expr ≃+ » («expr →₀ » α M) _) :=\n  AddEquiv.ext fun _ => rfl\n#align map_range.linear_equiv_to_add_equiv map_range.linear_equiv_to_add_equiv\n\n",
 "linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_symm (f : «expr ≃ₗ[ ] » M R N) :\n    ((map_range.linear_equiv f).symm : «expr ≃ₗ[ ] » («expr →₀ » α _) R _) = map_range.linear_equiv f.symm :=\n  linear_equiv.ext fun x => rfl\n#align map_range.linear_equiv_symm map_range.linear_equiv_symm\n\n",
 "linear_equiv_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_refl :\n    map_range.linear_equiv (linear_equiv.refl R M) = linear_equiv.refl R («expr →₀ » α M) :=\n  linear_equiv.ext map_range_id\n#align map_range.linear_equiv_refl map_range.linear_equiv_refl\n\n",
 "lift_symm_apply":
 "@[simp]\ntheorem lift_symm_apply (f) (x) : ((lift M R X).symm f) x = f (single x 1) :=\n  rfl\n#align lift_symm_apply lift_symm_apply\n\n",
 "lift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem lift_apply (f) (g) : ((lift M R X) f) g = g.sum fun x r => «expr • » r (f x) :=\n  rfl\n#align lift_apply lift_apply\n\n",
 "lhom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Two `R`-linear maps from `finsupp X M` which agree on each `single x y` agree everywhere.\n\nWe formulate this fact using equality of linear maps `φ.comp (lsingle a)` and `ψ.comp (lsingle a)`\nso that the `ext` tactic can apply a type-specific extensionality lemma to prove equality of these\nmaps. E.g., if `M = R`, then it suffices to verify `φ (single a 1) = ψ (single a 1)`. -/\n@[ext]\ntheorem lhom_ext' ⦃φ ψ : «expr →ₗ[ ] » («expr →₀ » α M) R N⦄ (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) :\n    φ = ψ :=\n  lhom_ext fun a => linear_map.congr_fun (h a)\n#align lhom_ext' lhom_ext'\n\n",
 "lhom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n/-- Two `R`-linear maps from `finsupp X M` which agree on each `single x y` agree everywhere. -/\ntheorem lhom_ext ⦃φ ψ : «expr →ₗ[ ] » («expr →₀ » α M) R N⦄ (h : ∀ a b, φ (single a b) = ψ (single a b)) : φ = ψ :=\n  linear_map.to_add_monoid_hom_injective <| add_hom_ext h\n#align lhom_ext lhom_ext\n\n",
 "left_inverse_splitting_of_fun_on_fintype_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem left_inverse_splitting_of_fun_on_fintype_surjective [fintype α] (f : «expr →ₗ[ ] » M R (α → R))\n    (s : surjective f) : left_inverse f (splitting_of_fun_on_fintype_surjective f s) := fun g =>\n  linear_map.congr_fun (splitting_of_fun_on_fintype_surjective_splits f s) g\n#align left_inverse_splitting_of_fun_on_fintype_surjective left_inverse_splitting_of_fun_on_fintype_surjective\n\n",
 "left_inverse_splitting_of_finsupp_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem left_inverse_splitting_of_finsupp_surjective (f : «expr →ₗ[ ] » M R («expr →₀ » α R)) (s : surjective f) :\n    left_inverse f (splitting_of_finsupp_surjective f s) := fun g =>\n  linear_map.congr_fun (splitting_of_finsupp_surjective_splits f s) g\n#align left_inverse_splitting_of_finsupp_surjective left_inverse_splitting_of_finsupp_surjective\n\n",
 "lcongr_symm_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem lcongr_symm_single {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) (k : κ) (n : N) :\n    (lcongr e₁ e₂).symm (finsupp.single k n) = finsupp.single (e₁.symm k) (e₂.symm n) :=\n  by\n  apply_fun lcongr e₁ e₂ using (lcongr e₁ e₂).injective\n  simp\n#align lcongr_symm_single lcongr_symm_single\n\n",
 "lcongr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem lcongr_symm {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) :\n    (lcongr e₁ e₂).symm = lcongr e₁.symm e₂.symm := by\n  ext\n  rfl\n#align lcongr_symm lcongr_symm\n\n",
 "lcongr_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem lcongr_single {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) (i : ι) (m : M) :\n    lcongr e₁ e₂ (finsupp.single i m) = finsupp.single (e₁ i) (e₂ m) := by simp [lcongr]\n#align lcongr_single lcongr_single\n\n",
 "lcongr_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lcongr_apply_apply {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) (f : «expr →₀ » ι M) (k : κ) :\n    lcongr e₁ e₂ f k = e₂ (f (e₁.symm k)) :=\n  rfl\n#align lcongr_apply_apply lcongr_apply_apply\n\n",
 "lapply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lapply_apply (a : α) (f : «expr →₀ » α M) : (lapply a : «expr →ₗ[ ] » («expr →₀ » α M) R M) f = f a :=\n  rfl\n#align lapply_apply lapply_apply\n\n",
 "ker_lsingle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_lsingle (a : α) : (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).ker = «expr⊥» :=\n  ker_eq_bot_of_injective (single_injective a)\n#align ker_lsingle ker_lsingle\n\n",
 "infi_ker_lapply_le_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem infi_ker_lapply_le_bot :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (lapply a : «expr →ₗ[ ] » («expr →₀ » α M) R M)) ≤\n      «expr⊥» :=\n  by\n  simp only [SetLike.le_def, mem_infi, mem_ker, mem_bot, lapply_apply]\n  exact fun a h => finsupp.ext h\n#align infi_ker_lapply_le_bot infi_ker_lapply_le_bot\n\n",
 "fst_sum_finsupp_lequiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem fst_sum_finsupp_lequiv_prod_finsupp {α β : Type _} (f : «expr →₀ » (Sum α β) M) (x : α) :\n    (sum_finsupp_lequiv_prod_finsupp R f).1 x = f (sum.inl x) :=\n  rfl\n#align fst_sum_finsupp_lequiv_prod_finsupp fst_sum_finsupp_lequiv_prod_finsupp\n\n",
 "finsupp_total_repr":
 "@[simp]\ntheorem span.finsupp_total_repr {w : set M} (x : span R w) : finsupp.total w M R coe (span.repr R w x) = x :=\n  by\n  rw [span.repr]\n  exact ((finsupp.mem_span_iff_total _ _ _).mp x.2).some_spec\n#align span.finsupp_total_repr span.finsupp_total_repr\n\n",
 "finsupp_sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\nprotected theorem submodule.finsupp_sum_mem {ι β : Type _} [Zero β] (S : submodule R M) (f : «expr →₀ » ι β)\n    (g : ι → β → M) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) : f.sum g ∈ S :=\n  add_submonoid_class.finsupp_sum_mem S f g h\n#align submodule.finsupp_sum_mem submodule.finsupp_sum_mem\n\n",
 "finsupp_prod_lequiv_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem finsupp_prod_lequiv_symm_apply {α β R M : Type _} [Semiring R] [add_comm_monoid M] [Module R M]\n    (f : «expr →₀ » α («expr →₀ » β M)) (xy) : (finsupp_prod_lequiv R).symm f xy = f xy.1 xy.2 := by\n  conv_rhs => rw [← (finsupp_prod_lequiv R).apply_symm_apply f, finsupp_prod_lequiv_apply, prod.mk.eta]\n#align finsupp_prod_lequiv_symm_apply finsupp_prod_lequiv_symm_apply\n\n",
 "finsupp_prod_lequiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem finsupp_prod_lequiv_apply {α β R M : Type _} [Semiring R] [add_comm_monoid M] [Module R M]\n    (f : «expr →₀ » (α × β) M) (x y) : finsupp_prod_lequiv R f x y = f (x, y) := by\n  rw [finsupp_prod_lequiv, linear_equiv.coe_mk, finsupp_prod_equiv, finsupp.curry_apply]\n#align finsupp_prod_lequiv_apply finsupp_prod_lequiv_apply\n\n",
 "exists_finset_of_mem_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem submodule.exists_finset_of_mem_supr {ι : Sort _} (p : ι → submodule R M) {m : M}\n    (hm : m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i)) :\n    ∃ s : Finset ι,\n      m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) :=\n  by\n  have :=\n    complete_lattice.is_compact_element.exists_finset_of_le_supr (submodule R M)\n      (submodule.singleton_span_is_compact_element m) p\n  simp only [submodule.span_singleton_le_iff_mem] at this\n  exact this hm\n#align submodule.exists_finset_of_mem_supr submodule.exists_finset_of_mem_supr\n\n",
 "dom_lcongr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem dom_lcongr_trans {α₁ α₂ α₃ : Type _} (f : «expr ≃ » α₁ α₂) (f₂ : «expr ≃ » α₂ α₃) :\n    (finsupp.dom_lcongr f).trans (finsupp.dom_lcongr f₂) =\n      (finsupp.dom_lcongr (f.trans f₂) : «expr ≃ₗ[ ] » («expr →₀ » _ M) R _) :=\n  linear_equiv.ext fun _ => (equiv_map_domain_trans _ _ _).symm\n#align dom_lcongr_trans dom_lcongr_trans\n\n",
 "dom_lcongr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_lcongr_symm {α₁ α₂ : Type _} (f : «expr ≃ » α₁ α₂) :\n    ((finsupp.dom_lcongr f).symm : «expr ≃ₗ[ ] » («expr →₀ » _ M) R _) = finsupp.dom_lcongr f.symm :=\n  linear_equiv.ext fun x => rfl\n#align dom_lcongr_symm dom_lcongr_symm\n\n",
 "dom_lcongr_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem dom_lcongr_single {α₁ : Type _} {α₂ : Type _} (e : «expr ≃ » α₁ α₂) (i : α₁) (m : M) :\n    (finsupp.dom_lcongr e : «expr ≃ₗ[ ] » _ R _) (finsupp.single i m) = finsupp.single (e i) m := by\n  simp [finsupp.dom_lcongr, finsupp.dom_congr, equiv_map_domain_single]\n#align dom_lcongr_single dom_lcongr_single\n\n",
 "dom_lcongr_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_lcongr_refl : finsupp.dom_lcongr (equiv.refl α) = linear_equiv.refl R («expr →₀ » α M) :=\n  linear_equiv.ext fun _ => equiv_map_domain_refl _\n#align dom_lcongr_refl dom_lcongr_refl\n\n",
 "dom_lcongr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem dom_lcongr_apply {α₁ : Type _} {α₂ : Type _} (e : «expr ≃ » α₁ α₂) (v : «expr →₀ » α₁ M) :\n    (finsupp.dom_lcongr e : «expr ≃ₗ[ ] » _ R _) v = finsupp.dom_congr e v :=\n  rfl\n#align dom_lcongr_apply dom_lcongr_apply\n\n",
 "disjoint_supported_supported_iff":
 "theorem disjoint_supported_supported_iff [nontrivial M] {s t : set α} :\n    Disjoint (supported M R s) (supported M R t) ↔ Disjoint s t :=\n  by\n  refine' ⟨fun h => set.disjoint_left.mpr fun x hx1 hx2 => _, disjoint_supported_supported⟩\n  rcases exists_ne (0 : M) with ⟨y, hy⟩\n  have := h.le_bot ⟨single_mem_supported R y hx1, single_mem_supported R y hx2⟩\n  rw [mem_bot, single_eq_zero] at this\n  exact hy this\n#align disjoint_supported_supported_iff disjoint_supported_supported_iff\n\n",
 "disjoint_supported_supported":
 "theorem disjoint_supported_supported {s t : set α} (h : Disjoint s t) : Disjoint (supported M R s) (supported M R t) :=\n  disjoint_iff.2 <| by rw [← supported_inter, disjoint_iff_inter_eq_empty.1 h, supported_empty]\n#align disjoint_supported_supported disjoint_supported_supported\n\n",
 "disjoint_lsingle_lsingle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem disjoint_lsingle_lsingle (s t : set α) (hs : Disjoint s t) :\n    Disjoint\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range) :=\n  by\n  refine'\n    (Disjoint.mono (lsingle_range_le_ker_lapply _ _ <| disjoint_compl_right)\n        (lsingle_range_le_ker_lapply _ _ <| disjoint_compl_right))\n      _\n  rw [disjoint_iff_inf_le]\n  refine' le_trans (le_infᵢ fun i => _) infi_ker_lapply_le_bot\n  classical\n    by_cases his : i ∈ s\n    · by_cases hit : i ∈ t\n      · exact (hs.le_bot ⟨his, hit⟩).elim\n      exact inf_le_of_right_le (infᵢ_le_of_le i <| infᵢ_le _ hit)\n    exact inf_le_of_left_le (infᵢ_le_of_le i <| infᵢ_le _ his)\n#align disjoint_lsingle_lsingle disjoint_lsingle_lsingle\n\n",
 "coe_lsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coe_lsum (f : α → «expr →ₗ[ ] » M R N) : (lsum S f : «expr →₀ » α M → N) = fun d => d.sum fun i => f i :=\n  rfl\n#align coe_lsum coe_lsum\n\n",
 "apply_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem apply_total (f : «expr →ₗ[ ] » M R M') (v) (l : «expr →₀ » α R) :\n    f (finsupp.total α M R v l) = finsupp.total α M' R (f ∘ v) l := by\n  apply finsupp.induction_linear l <;> simp (config := { contextual := true })\n#align apply_total apply_total\n\n"}