{"total_zero_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_zero_apply (x : «expr →₀ » α R) : (Finsupp.total α M R 0) x = 0 := by simp [Finsupp.total_apply]\n#align total_zero_apply total_zero_apply\n\n",
 "total_zero":
 "@[simp]\ntheorem total_zero : Finsupp.total α M R 0 = 0 :=\n  LinearMap.ext (total_zero_apply R)\n#align total_zero total_zero\n\n",
 "total_unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_unique [Unique α] (l : «expr →₀ » α R) (v) :\n    Finsupp.total α M R v l = «expr • » (l default) (v default) := by rw [← total_single, ← unique_single l]\n#align total_unique total_unique\n\n",
 "total_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_total {α β : Type _} (A : α → M) (B : β → «expr →₀ » α R) (f : «expr →₀ » β R) :\n    Finsupp.total α M R A (Finsupp.total β («expr →₀ » α R) R B f) =\n      Finsupp.total β M R (fun b => Finsupp.total α M R A (B b)) f :=\n  by\n  simp only [total_apply]\n  apply induction_linear f\n  · simp only [sum_zero_index]\n  · intro f₁ f₂ h₁ h₂\n    simp [sum_add_index, h₁, h₂, add_smul]\n  · simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]\n#align total_total total_total\n\n",
 "total_surjective":
 "theorem total_surjective (h : function.surjective v) : function.surjective (Finsupp.total α M R v) :=\n  by\n  intro x\n  obtain ⟨y, hy⟩ := h x\n  exact ⟨Finsupp.single y 1, by simp [hy]⟩\n#align total_surjective total_surjective\n\n",
 "total_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem total_single (c : R) (a : α) : Finsupp.total α M R v (single a c) = «expr • » c (v a) := by\n  simp [total_apply, sum_single_index]\n#align total_single total_single\n\n",
 "total_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem total_range (h : function.surjective v) : (Finsupp.total α M R v).range = «expr⊤» :=\n  range_eq_top.2 <| total_surjective R h\n#align total_range total_range\n\n",
 "total_option":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_option (v : Option α → M) (f : «expr →₀ » (Option α) R) :\n    Finsupp.total (Option α) M R v f = «expr • » (f none) (v none) + Finsupp.total α M R (v ∘ option.some) f.some := by\n  rw [total_apply, sum_option_index_smul, total_apply]\n#align total_option total_option\n\n",
 "total_on_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem total_on_range (s : Set α) : (Finsupp.totalOn α M R v s).range = «expr⊤» :=\n  by\n  rw [Finsupp.totalOn, LinearMap.range_eq_map, LinearMap.map_codRestrict, ← LinearMap.range_le_iff_comap, range_subtype,\n    Submodule.map_top, LinearMap.range_comp, range_subtype]\n  exact (span_image_eq_map_total _ _).le\n#align total_on_range total_on_range\n\n",
 "total_on_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_on_finset {s : Finset α} {f : α → R} (g : α → M) (hf : ∀ a, f a ≠ 0 → a ∈ s) :\n    Finsupp.total α M R g (Finsupp.onFinset s f hf) = Finset.sum s fun x : α => «expr • » (f x) (g x) :=\n  by\n  simp only [Finsupp.total_apply, Finsupp.sum, Finsupp.onFinset_apply, Finsupp.support_onFinset]\n  rw [Finset.sum_filter_of_ne]\n  intro x hx h\n  contrapose! h\n  simp [h]\n#align total_on_finset total_on_finset\n\n",
 "total_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_map_domain (f : α → α') (l : «expr →₀ » α R) :\n    (Finsupp.total α' M' R v') (mapDomain f l) = (Finsupp.total α M' R (v' ∘ f)) l :=\n  LinearMap.congr_fun (total_comp_lmapDomain _ _) l\n#align total_map_domain total_map_domain\n\n",
 "total_id_surjective":
 "/-- Any module is a quotient of a free module. This is stated as surjectivity of\n`finsupp.total M M R id : (M →₀ R) →ₗ[R] M`. -/\ntheorem total_id_surjective (M) [AddCommMonoid M] [Module R M] : function.surjective (Finsupp.total M M R id) :=\n  total_surjective R function.surjective_id\n#align total_id_surjective total_id_surjective\n\n",
 "total_fin_zero":
 "@[simp]\ntheorem total_fin_zero (f : Fin 0 → M) : Finsupp.total (Fin 0) M R f = 0 :=\n  by\n  ext i\n  apply finZeroElim i\n#align total_fin_zero total_fin_zero\n\n",
 "total_equiv_map_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_equiv_map_domain (f : «expr ≃ » α α') (l : «expr →₀ » α R) :\n    (Finsupp.total α' M' R v') (equivMapDomain f l) = (Finsupp.total α M' R (v' ∘ f)) l := by\n  rw [equiv_map_domain_eq_map_domain, total_map_domain]\n#align total_equiv_map_domain total_equiv_map_domain\n\n",
 "total_eq_fintype_total_apply":
 "#print Finsupp.total_eq_fintype_total_apply /-\ntheorem Finsupp.total_eq_fintype_total_apply (x : α → R) :\n    Finsupp.total α M R v ((Finsupp.linearEquivFunOnFinite R R α).symm x) = Fintype.total R S v x :=\n  by\n  apply Finset.sum_subset\n  · exact Finset.subset_univ _\n  · intro x _ hx\n    rw [finsupp.not_mem_support_iff.mp hx]\n    exact zero_smul _ _\n#align finsupp.total_eq_fintype_total_apply Finsupp.total_eq_fintype_total_apply\n-/\n\n",
 "total_eq_fintype_total":
 "#print Finsupp.total_eq_fintype_total /-\ntheorem Finsupp.total_eq_fintype_total :\n    (Finsupp.total α M R v).comp (Finsupp.linearEquivFunOnFinite R R α).symm.to_linear_map = Fintype.total R S v :=\n  LinearMap.ext <| Finsupp.total_eq_fintype_total_apply R S v\n#align finsupp.total_eq_fintype_total Finsupp.total_eq_fintype_total\n-/\n\n",
 "total_emb_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem total_emb_domain (f : «expr ↪ » α α') (l : «expr →₀ » α R) :\n    (Finsupp.total α' M' R v') (embDomain f l) = (Finsupp.total α M' R (v' ∘ f)) l := by\n  simp [total_apply, Finsupp.sum, support_emb_domain, emb_domain_apply]\n#align total_emb_domain total_emb_domain\n\n",
 "total_comp_lmap_domain":
 "theorem total_comp_lmap_domain (f : α → α') :\n    (Finsupp.total α' M' R v').comp (Finsupp.lmapDomain R R f) = Finsupp.total α M' R (v' ∘ f) :=\n  by\n  ext\n  simp\n#align total_comp_lmap_domain total_comp_lmap_domain\n\n",
 "total_comp":
 "theorem total_comp (f : α' → α) : Finsupp.total α' M R (v ∘ f) = (Finsupp.total α M R v).comp (lmapDomain R R f) :=\n  by\n  ext\n  simp [total_apply]\n#align total_comp total_comp\n\n",
 "total_comap_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_comap_domain (f : α → α') (l : «expr →₀ » α' R) (hf : Set.InjOn f («expr ⁻¹' » f ↑l.support)) :\n    Finsupp.total α M R v (Finsupp.comapDomain f l hf) =\n      (l.support.preimage f hf).sum fun i => «expr • » (l (f i)) (v i) :=\n  by rw [Finsupp.total_apply] <;> rfl\n#align total_comap_domain total_comap_domain\n\n",
 "total_apply_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Fintype.total_apply_single /-\n@[simp]\ntheorem Fintype.total_apply_single (i : α) (r : R) : Fintype.total R S v (Pi.single i r) = «expr • » r (v i) :=\n  by\n  simp_rw [Fintype.total_apply, Pi.single_apply, ite_smul, zero_smul]\n  rw [Finset.sum_ite_eq', if_pos (Finset.mem_univ _)]\n#align fintype.total_apply_single Fintype.total_apply_single\n-/\n\n",
 "total_apply_of_mem_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem total_apply_of_mem_supported {l : «expr →₀ » α R} {s : Finset α} (hs : l ∈ supported R R (↑s : Set α)) :\n    Finsupp.total α M R v l = s.sum fun i => «expr • » (l i) (v i) :=\n  Finset.sum_subset hs fun x _ hxg => show «expr • » (l x) (v x) = 0 by rw [not_mem_support_iff.1 hxg, zero_smul]\n#align total_apply_of_mem_supported total_apply_of_mem_supported\n\n",
 "total_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Fintype.total_apply /-\ntheorem Fintype.total_apply (f) :\n    Fintype.total R S v f =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f i) (v i)) :=\n  rfl\n#align fintype.total_apply Fintype.total_apply\n-/\n\n",
 "top_le_span_range_iff_forall_exists_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print top_le_span_range_iff_forall_exists_fun /-\n/-- A family `v : α → V` is generating `V` iff every element `(x : V)`\ncan be written as sum `∑ cᵢ • vᵢ = x`.\n-/\ntheorem top_le_span_range_iff_forall_exists_fun :\n    «expr⊤» ≤ span R (range v) ↔\n      ∀ x,\n        ∃ c : α → R,\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (c i) (v i)) =\n            x :=\n  by\n  simp_rw [← mem_span_range_iff_exists_fun]\n  exact ⟨fun h x => h trivial, fun h x _ => h x⟩\n#align top_le_span_range_iff_forall_exists_fun top_le_span_range_iff_forall_exists_fun\n-/\n\n",
 "supr_lsingle_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem supr_lsingle_range :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range =\n      «expr⊤» :=\n  by\n  refine' eq_top_iff.2 <| SetLike.le_def.2 fun f _ => _\n  rw [← sum_single f]\n  exact sum_mem fun a ha => Submodule.mem_supᵢ_of_mem a ⟨_, rfl⟩\n#align supr_lsingle_range supr_lsingle_range\n\n",
 "supported_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem supported_univ : supported M R (Set.univ : Set α) = «expr⊤» :=\n  eq_top_iff.2 fun l _ => Set.subset_univ _\n#align supported_univ supported_univ\n\n",
 "supported_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem supported_union (s t : Set α) : supported M R (s ∪ t) = «expr ⊔ » (supported M R s) (supported M R t) := by\n  erw [Set.union_eq_unionᵢ, supported_Union, supᵢ_bool_eq] <;> rfl\n#align supported_union supported_union\n\n",
 "supported_mono":
 "theorem supported_mono {s t : Set α} (st : s ⊆ t) : supported M R s ≤ supported M R t := fun l h =>\n  Set.Subset.trans h st\n#align supported_mono supported_mono\n\n",
 "supported_inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem supported_inter (s t : Set α) : supported M R (s ∩ t) = «expr ⊓ » (supported M R s) (supported M R t) := by\n  rw [Set.inter_eq_interᵢ, supported_Inter, infᵢ_bool_eq] <;> rfl\n#align supported_inter supported_inter\n\n",
 "supported_eq_span_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem supported_eq_span_single (s : Set α) : supported R R s = span R («expr '' » (fun i => single i 1) s) :=\n  by\n  refine' (span_eq_of_le _ _ (SetLike.le_def.2 fun l hl => _)).symm\n  · rintro _ ⟨_, hp, rfl⟩\n    exact single_mem_supported R 1 hp\n  · rw [← l.sum_single]\n    refine' sum_mem fun i il => _\n    convert@smul_mem R («expr →₀ » α R) _ _ _ _ (single i 1) (l i) _\n    · simp\n    apply subset_span\n    apply Set.mem_image_of_mem _ (hl il)\n#align supported_eq_span_single supported_eq_span_single\n\n",
 "supported_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem supported_empty : supported M R (∅ : Set α) = «expr⊥» :=\n  eq_bot_iff.2 fun l h => (Submodule.mem_bot R).2 <| by ext <;> simp_all [mem_supported']\n#align supported_empty supported_empty\n\n",
 "supported_comap_lmap_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem supported_comap_lmap_domain (f : α → α') (s : Set α') :\n    supported M R («expr ⁻¹' » f s) ≤ (supported M R s).comap (lmapDomain M R f) :=\n  fun l (hl : ↑l.support ⊆ «expr ⁻¹' » f s) =>\n  show ↑(mapDomain f l).support ⊆ s\n    by\n    rw [← Set.image_subset_iff, ← Finset.coe_image] at hl\n    exact Set.Subset.trans map_domain_support hl\n#align supported_comap_lmap_domain supported_comap_lmap_domain\n\n",
 "supported_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem supported_Union {δ : Type _} (s : δ → Set α) :\n    supported M R\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (supported M R (s i)) :=\n  by\n  refine' le_antisymm _ (supᵢ_le fun i => supported_mono <| Set.subset_unionᵢ _ _)\n  haveI :=\n    Classical.decPred fun x =>\n      x ∈ «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)\n  suffices\n    ((Submodule.subtype _).comp\n          (restrict_dom M R\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n              (s i)))).range ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (supported M R (s i))\n    by rwa [LinearMap.range_comp, range_restrict_dom, Submodule.map_top, range_subtype] at this\n  rw [range_le_iff_comap, eq_top_iff]\n  rintro l ⟨⟩\n  apply Finsupp.induction l\n  · exact zero_mem _\n  refine' fun x a l hl a0 => add_mem _\n  by_cases ∃ i, x ∈ s i <;> simp [h]\n  · cases' h with i hi\n    exact le_supᵢ (fun i => supported M R (s i)) i (single_mem_supported R _ hi)\n#align supported_Union supported_Union\n\n",
 "supported_Inter":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem supported_Inter {ι : Type _} (s : ι → Set α) :\n    supported M R\n        («expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (s i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (supported M R (s i)) :=\n  Submodule.ext fun x => by simp [mem_supported, subset_Inter_iff]\n#align supported_Inter supported_Inter\n\n",
 "sum_finsupp_lequiv_prod_finsupp_symm_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_lequiv_prod_finsupp_symm_inr {α β : Type _} (fg : «expr →₀ » α M × «expr →₀ » β M) (y : β) :\n    ((sumFinsuppLEquivProdFinsupp R).symm fg) (Sum.inr y) = fg.2 y :=\n  rfl\n#align sum_finsupp_lequiv_prod_finsupp_symm_inr sum_finsupp_lequiv_prod_finsupp_symm_inr\n\n",
 "sum_finsupp_lequiv_prod_finsupp_symm_inl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem sum_finsupp_lequiv_prod_finsupp_symm_inl {α β : Type _} (fg : «expr →₀ » α M × «expr →₀ » β M) (x : α) :\n    ((sumFinsuppLEquivProdFinsupp R).symm fg) (Sum.inl x) = fg.1 x :=\n  rfl\n#align sum_finsupp_lequiv_prod_finsupp_symm_inl sum_finsupp_lequiv_prod_finsupp_symm_inl\n\n",
 "splitting_of_fun_on_fintype_surjective_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- See also `linear_map.splitting_of_finsupp_surjective`\ntheorem splitting_of_fun_on_fintype_surjective_splits [Fintype α] (f : «expr →ₗ[ ] » M R (α → R)) (s : surjective f) :\n    f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id :=\n  by\n  ext (x y)\n  dsimp [splitting_of_fun_on_fintype_surjective]\n  rw [linear_equiv_fun_on_finite_symm_single, Finsupp.sum_single_index, one_smul, (s (Finsupp.single x 1)).some_spec,\n    Finsupp.single_eq_pi_single]\n  rw [zero_smul]\n#align splitting_of_fun_on_fintype_surjective_splits splitting_of_fun_on_fintype_surjective_splits\n\n",
 "splitting_of_fun_on_fintype_surjective_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem splitting_of_fun_on_fintype_surjective_injective [Fintype α] (f : «expr →ₗ[ ] » M R (α → R))\n    (s : surjective f) : injective (splittingOfFunOnFintypeSurjective f s) :=\n  (leftInverse_splittingOfFunOnFintypeSurjective f s).injective\n#align splitting_of_fun_on_fintype_surjective_injective splitting_of_fun_on_fintype_surjective_injective\n\n",
 "splitting_of_finsupp_surjective_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n-- See also `linear_map.splitting_of_fun_on_fintype_surjective`\ntheorem splitting_of_finsupp_surjective_splits (f : «expr →ₗ[ ] » M R («expr →₀ » α R)) (s : surjective f) :\n    f.comp (splittingOfFinsuppSurjective f s) = LinearMap.id :=\n  by\n  ext (x y)\n  dsimp [splitting_of_finsupp_surjective]\n  congr\n  rw [sum_single_index, one_smul]\n  · exact (s (Finsupp.single x 1)).some_spec\n  · rw [zero_smul]\n#align splitting_of_finsupp_surjective_splits splitting_of_finsupp_surjective_splits\n\n",
 "splitting_of_finsupp_surjective_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem splitting_of_finsupp_surjective_injective (f : «expr →ₗ[ ] » M R («expr →₀ » α R)) (s : surjective f) :\n    injective (splittingOfFinsuppSurjective f s) :=\n  (leftInverse_splittingOfFinsuppSurjective f s).injective\n#align splitting_of_finsupp_surjective_injective splitting_of_finsupp_surjective_injective\n\n",
 "span_single_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem span_single_image (s : Set M) (a : α) :\n    Submodule.span R («expr '' » (single a) s) =\n      (Submodule.span R s).map (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)) :=\n  by rw [← span_image] <;> rfl\n#align span_single_image span_single_image\n\n",
 "span_image_eq_map_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem span_image_eq_map_total (s : Set α) :\n    span R («expr '' » v s) = Submodule.map (Finsupp.total α M R v) (supported R R s) :=\n  by\n  apply span_eq_of_le\n  · intro x hx\n    rw [Set.mem_image] at hx\n    apply exists.elim hx\n    intro i hi\n    exact ⟨_, Finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]⟩\n  · refine' map_le_iff_le_comap.2 fun z hz => _\n    have : ∀ i, «expr • » (z i) (v i) ∈ span R («expr '' » v s) :=\n      by\n      intro c\n      haveI := Classical.decPred fun x => x ∈ s\n      by_cases c ∈ s\n      · exact smul_mem _ _ (subset_span (Set.mem_image_of_mem _ h))\n      · simp [(Finsupp.mem_supported' R _).1 hz _ h]\n    refine' sum_mem _\n    simp [this]\n#align span_image_eq_map_total span_image_eq_map_total\n\n",
 "span_eq_range_total":
 "/-- A version of `finsupp.range_total` which is useful for going in the other direction -/\ntheorem span_eq_range_total (s : Set M) : span R s = (Finsupp.total s M R coe).range := by\n  rw [range_total, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n#align span_eq_range_total span_eq_range_total\n\n",
 "snd_sum_finsupp_lequiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem snd_sum_finsupp_lequiv_prod_finsupp {α β : Type _} (f : «expr →₀ » (Sum α β) M) (y : β) :\n    (sumFinsuppLEquivProdFinsupp R f).2 y = f (Sum.inr y) :=\n  rfl\n#align snd_sum_finsupp_lequiv_prod_finsupp snd_sum_finsupp_lequiv_prod_finsupp\n\n",
 "single_mem_supported":
 "theorem single_mem_supported {s : Set α} {a : α} (b : M) (h : a ∈ s) : single a b ∈ supported M R s :=\n  Set.Subset.trans support_single_subset (Finset.singleton_subset_set_iff.2 h)\n#align single_mem_supported single_mem_supported\n\n",
 "sigma_finsupp_lequiv_pi_finsupp_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sigma_finsupp_lequiv_pi_finsupp_symm_apply {M : Type _} {ιs : η → Type _} [AddCommMonoid M] [Module R M]\n    (f : ∀ j, «expr →₀ » (ιs j) M) (ji) : (Finsupp.sigmaFinsuppLEquivPiFinsupp R).symm f ji = f ji.1 ji.2 :=\n  rfl\n#align sigma_finsupp_lequiv_pi_finsupp_symm_apply sigma_finsupp_lequiv_pi_finsupp_symm_apply\n\n",
 "sigma_finsupp_lequiv_pi_finsupp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem sigma_finsupp_lequiv_pi_finsupp_apply {M : Type _} {ιs : η → Type _} [AddCommMonoid M] [Module R M]\n    (f : «expr →₀ » (Σj, ιs j) M) (j i) : sigmaFinsuppLEquivPiFinsupp R f j i = f ⟨j, i⟩ :=\n  rfl\n#align sigma_finsupp_lequiv_pi_finsupp_apply sigma_finsupp_lequiv_pi_finsupp_apply\n\n",
 "restrict_dom_comp_subtype":
 "theorem restrict_dom_comp_subtype (s : Set α) : (restrictDom M R s).comp (Submodule.subtype _) = LinearMap.id :=\n  by\n  ext (l a)\n  by_cases a ∈ s <;> simp [h]\n  exact ((mem_supported' R l.1).1 l.2 a h).symm\n#align restrict_dom_comp_subtype restrict_dom_comp_subtype\n\n",
 "restrict_dom_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem restrict_dom_apply (s : Set α) (l : «expr →₀ » α M) :\n    ((restrictDom M R s : «expr →ₗ[ ] » («expr →₀ » α M) R (supported M R s)) l : «expr →₀ » α M) =\n      Finsupp.filter (· ∈ s) l :=\n  rfl\n#align restrict_dom_apply restrict_dom_apply\n\n",
 "range_total":
 "#print Fintype.range_total /-\n@[simp]\ntheorem Fintype.range_total : (Fintype.total R S v).range = Submodule.span R (Set.range v) := by\n  rw [← Finsupp.total_eq_fintype_total, LinearMap.range_comp, linear_equiv.to_linear_map_eq_coe, LinearEquiv.range,\n    Submodule.map_top, Finsupp.range_total]\n#align fintype.range_total Fintype.range_total\n-/\n\n",
 "range_restrict_dom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_restrict_dom (s : Set α) : (restrictDom M R s).range = «expr⊤» :=\n  range_eq_top.2 <| function.right_inverse.surjective <| LinearMap.congr_fun (restrictDom_comp_subtype s)\n#align range_restrict_dom range_restrict_dom\n\n",
 "mem_supᵢ_iff_exists_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print Submodule.mem_supᵢ_iff_exists_finset /-\n/-- `submodule.exists_finset_of_mem_supr` as an `iff` -/\ntheorem Submodule.mem_supᵢ_iff_exists_finset {ι : Sort _} {p : ι → Submodule R M} {m : M} :\n    m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) ↔\n      ∃ s : Finset ι,\n        m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) :=\n  ⟨Submodule.exists_finset_of_mem_supᵢ p, fun ⟨_, hs⟩ => supᵢ_mono (fun i => (supᵢ_const_le : _ ≤ p i)) hs⟩\n#align submodule.mem_supr_iff_exists_finset Submodule.mem_supᵢ_iff_exists_finset\n-/\n\n",
 "mem_supported_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_supported_support (p : «expr →₀ » α M) : p ∈ Finsupp.supported M R (p.support : Set α) := by\n  rw [Finsupp.mem_supported]\n#align mem_supported_support mem_supported_support\n\n",
 "mem_supported'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (x «expr ∉ » s) -/\ntheorem mem_supported' {s : Set α} (p : «expr →₀ » α M) : p ∈ supported M R s ↔ ∀ (x) (_ : x ∉ s), p x = 0 := by\n  haveI := Classical.decPred fun x : α => x ∈ s <;> simp [mem_supported, Set.subset_def, not_imp_comm]\n#align mem_supported' mem_supported'\n\n",
 "mem_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_supported {s : Set α} (p : «expr →₀ » α M) : p ∈ supported M R s ↔ ↑p.support ⊆ s :=\n  iff.rfl\n#align mem_supported mem_supported\n\n",
 "mem_span_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mem_span_set /-\n/-- An element `m ∈ M` is contained in the `R`-submodule spanned by a set `s ⊆ M`, if and only if\n`m` can be written as a finite `R`-linear combination of elements of `s`.\nThe implementation uses `finsupp.sum`. -/\ntheorem mem_span_set {m : M} {s : Set M} :\n    m ∈ Submodule.span R s ↔ ∃ c : «expr →₀ » M R, (c.support : Set M) ⊆ s ∧ (c.sum fun mi r => «expr • » r mi) = m :=\n  by\n  conv_lhs => rw [← Set.image_id s]\n  simp_rw [← exists_prop]\n  exact Finsupp.mem_span_image_iff_total R\n#align mem_span_set mem_span_set\n-/\n\n",
 "mem_span_range_iff_exists_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mem_span_range_iff_exists_fun /-\n/-- An element `x` lies in the span of `v` iff it can be written as sum `∑ cᵢ • vᵢ = x`.\n-/\ntheorem mem_span_range_iff_exists_fun :\n    x ∈ span R (range v) ↔\n      ∃ c : α → R,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (c i) (v i)) =\n          x :=\n  by\n  simp only [Finsupp.mem_span_range_iff_exists_finsupp, finsupp.equiv_fun_on_finite.surjective.exists,\n    finsupp.equiv_fun_on_finite_apply]\n  exact exists_congr fun c => Eq.congr_left <| Finsupp.sum_fintype _ _ fun i => zero_smul _ _\n#align mem_span_range_iff_exists_fun mem_span_range_iff_exists_fun\n-/\n\n",
 "mem_span_range_iff_exists_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_span_range_iff_exists_finsupp {v : α → M} {x : M} :\n    x ∈ span R (range v) ↔ ∃ c : «expr →₀ » α R, (c.sum fun i a => «expr • » a (v i)) = x := by\n  simp only [← Finsupp.range_total, LinearMap.mem_range, Finsupp.total_apply]\n#align mem_span_range_iff_exists_finsupp mem_span_range_iff_exists_finsupp\n\n",
 "mem_span_image_iff_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem mem_span_image_iff_total {s : Set α} {x : M} :\n    x ∈ span R («expr '' » v s) ↔ ∃ l ∈ supported R R s, Finsupp.total α M R v l = x :=\n  by\n  rw [span_image_eq_map_total]\n  simp\n#align mem_span_image_iff_total mem_span_image_iff_total\n\n",
 "mem_span_iff_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem mem_span_iff_total (s : Set M) (x : M) : x ∈ span R s ↔ ∃ l : «expr →₀ » s R, Finsupp.total s M R coe l = x :=\n  (SetLike.ext_iff.1 <| span_eq_range_total _ _) x\n#align mem_span_iff_total mem_span_iff_total\n\n",
 "mem_span_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mem_span_finset /-\ntheorem mem_span_finset {s : Finset M} {x : M} :\n    x ∈ span R (↑s : Set M) ↔\n      ∃ f : M → R,\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n            («expr • » (f i) i) =\n          x :=\n  ⟨fun hx =>\n    let ⟨v, hvs, hvx⟩ :=\n      (Finsupp.mem_span_image_iff_total _).1 (show x ∈ span R («expr '' » id (↑s : Set M)) by rwa [Set.image_id])\n    ⟨v, hvx ▸ (Finsupp.total_apply_of_mem_supported _ hvs).symm⟩,\n    fun ⟨f, hf⟩ => hf ▸ sum_mem fun i hi => smul_mem _ _ <| subset_span hi⟩\n#align mem_span_finset mem_span_finset\n-/\n\n",
 "map_finsupp_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print LinearMap.map_finsupp_total /-\ntheorem LinearMap.map_finsupp_total (f : «expr →ₗ[ ] » M R N) {ι : Type _} {g : ι → M} (l : «expr →₀ » ι R) :\n    f (Finsupp.total ι M R g l) = Finsupp.total ι N R (f ∘ g) l := by\n  simp only [Finsupp.total_apply, Finsupp.total_apply, Finsupp.sum, f.map_sum, f.map_smul]\n#align linear_map.map_finsupp_total LinearMap.map_finsupp_total\n-/\n\n",
 "lsum_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsum_symm_apply (f : «expr →ₗ[ ] » («expr →₀ » α M) R N) (x : α) : (lsum S).symm f x = f.comp (lsingle x) :=\n  rfl\n#align lsum_symm_apply lsum_symm_apply\n\n",
 "lsum_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lsum_single (f : α → «expr →ₗ[ ] » M R N) (i : α) (m : M) : Finsupp.lsum S f (Finsupp.single i m) = f i m :=\n  Finsupp.sum_single_index (f i).map_zero\n#align lsum_single lsum_single\n\n",
 "lsum_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsum_apply (f : α → «expr →ₗ[ ] » M R N) (l : «expr →₀ » α M) : Finsupp.lsum S f l = l.sum fun b => f b :=\n  rfl\n#align lsum_apply lsum_apply\n\n",
 "lsubtype_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsubtype_domain_apply (f : «expr →₀ » α M) :\n    (lsubtypeDomain s : «expr →ₗ[ ] » («expr →₀ » α M) R («expr →₀ » s M)) f = subtypeDomain (fun x => x ∈ s) f :=\n  rfl\n#align lsubtype_domain_apply lsubtype_domain_apply\n\n",
 "lsingle_range_le_ker_lapply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lsingle_range_le_ker_lapply (s t : Set α) (h : Disjoint s t) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (lapply a : «expr →ₗ[ ] » («expr →₀ » α M) R M)) :=\n  by\n  refine' supᵢ_le fun a₁ => supᵢ_le fun h₁ => range_le_iff_comap.2 _\n  simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_infi, mem_infi]\n  intro b hb a₂ h₂\n  have : a₁ ≠ a₂ := fun eq => h.le_bot ⟨h₁, Eq.symm ▸ h₂⟩\n  exact single_eq_of_ne this\n#align lsingle_range_le_ker_lapply lsingle_range_le_ker_lapply\n\n",
 "lsingle_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lsingle_apply (a : α) (b : M) : (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)) b = single a b :=\n  rfl\n#align lsingle_apply lsingle_apply\n\n",
 "lmap_domain_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lmap_domain_total (f : α → α') (g : «expr →ₗ[ ] » M R M') (h : ∀ i, g (v i) = v' (f i)) :\n    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by\n  ext l <;> simp [total_apply, Finsupp.sum_mapDomain_index, add_smul, h]\n#align lmap_domain_total lmap_domain_total\n\n",
 "lmap_domain_supported":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem lmap_domain_supported [Nonempty α] (f : α → α') (s : Set α) :\n    (supported M R s).map (lmapDomain M R f) = supported M R («expr '' » f s) :=\n  by\n  inhabit α\n  refine'\n    le_antisymm\n      (map_le_iff_le_comap.2 <|\n        le_trans (supported_mono <| Set.subset_preimage_image _ _) (supported_comap_lmap_domain _ _ _ _))\n      _\n  intro l hl\n  refine'\n    ⟨(lmap_domain M R (Function.invFunOn f s) : «expr →ₗ[ ] » («expr →₀ » α' M) R («expr →₀ » α M)) l, fun x hx => _, _⟩\n  · rcases Finset.mem_image.1 (map_domain_support hx) with ⟨c, hc, rfl⟩\n    exact Function.invFunOn_mem (by simpa using hl hc)\n  · rw [← LinearMap.comp_apply, ← lmap_domain_comp]\n    refine' (map_domain_congr fun c hc => _).trans map_domain_id\n    exact Function.invFunOn_eq (by simpa using hl hc)\n#align lmap_domain_supported lmap_domain_supported\n\n",
 "lmap_domain_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lmap_domain_id : (lmapDomain M R id : «expr →ₗ[ ] » («expr →₀ » α M) R («expr →₀ » α M)) = LinearMap.id :=\n  LinearMap.ext fun l => mapDomain_id\n#align lmap_domain_id lmap_domain_id\n\n",
 "lmap_domain_disjoint_ker":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (a b «expr ∈ » s) -/\ntheorem lmap_domain_disjoint_ker (f : α → α') {s : Set α} (H : ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), f a = f b → a = b) :\n    Disjoint (supported M R s) (lmapDomain M R f).ker :=\n  by\n  rw [disjoint_iff_inf_le]\n  rintro l ⟨h₁, h₂⟩\n  rw [SetLike.mem_coe, mem_ker, lmap_domain_apply, map_domain] at h₂\n  simp; ext x\n  haveI := Classical.decPred fun x => x ∈ s\n  by_cases xs : x ∈ s\n  · have : Finsupp.sum l (fun a => Finsupp.single (f a)) (f x) = 0 :=\n      by\n      rw [h₂]\n      rfl\n    rw [Finsupp.sum_apply, Finsupp.sum, Finset.sum_eq_single x] at this\n    · simpa [Finsupp.single_apply]\n    · intro y hy xy\n      simp [mt (H _ (h₁ hy) _ xs) xy]\n    · simp (config := { contextual := true })\n  · by_contra h\n    exact xs (h₁ <| Finsupp.mem_support_iff.2 h)\n#align lmap_domain_disjoint_ker lmap_domain_disjoint_ker\n\n",
 "lmap_domain_comp":
 "theorem lmap_domain_comp (f : α → α') (g : α' → α'') :\n    lmapDomain M R (g ∘ f) = (lmapDomain M R g).comp (lmapDomain M R f) :=\n  LinearMap.ext fun l => mapDomain_comp\n#align lmap_domain_comp lmap_domain_comp\n\n",
 "lmap_domain_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lmap_domain_apply (f : α → α') (l : «expr →₀ » α M) :\n    (lmapDomain M R f : «expr →ₗ[ ] » («expr →₀ » α M) R («expr →₀ » α' M)) l = mapDomain f l :=\n  rfl\n#align lmap_domain_apply lmap_domain_apply\n\n",
 "llift_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem llift_symm_apply (f : «expr →ₗ[ ] » («expr →₀ » X R) R M) (x : X) : (llift M R S X).symm f x = f (single x 1) :=\n  rfl\n#align llift_symm_apply llift_symm_apply\n\n",
 "llift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem llift_apply (f : X → M) (x : «expr →₀ » X R) : llift M R S X f x = lift M R X f x :=\n  rfl\n#align llift_apply llift_apply\n\n",
 "linear_map_to_add_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_map_to_add_monoid_hom (f : «expr →ₗ[ ] » M R N) :\n    (mapRange.linearMap f).to_add_monoid_hom =\n      (mapRange.addMonoidHom f.to_add_monoid_hom : «expr →+ » («expr →₀ » α M) _) :=\n  AddMonoidHom.ext fun _ => rfl\n#align map_range.linear_map_to_add_monoid_hom map_range.linear_map_to_add_monoid_hom\n\n",
 "linear_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_map_id :\n    mapRange.linearMap LinearMap.id = (LinearMap.id : «expr →ₗ[ ] » («expr →₀ » α M) R _) :=\n  LinearMap.ext mapRange_id\n#align map_range.linear_map_id map_range.linear_map_id\n\n",
 "linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.linear_map_comp (f : «expr →ₗ[ ] » N R P) (f₂ : «expr →ₗ[ ] » M R N) :\n    (mapRange.linearMap (f.comp f₂) : «expr →ₗ[ ] » («expr →₀ » α _) R _) =\n      (mapRange.linearMap f).comp (mapRange.linearMap f₂) :=\n  LinearMap.ext <| mapRange_comp _ _ _ _ _\n#align map_range.linear_map_comp map_range.linear_map_comp\n\n",
 "linear_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem map_range.linear_equiv_trans (f : «expr ≃ₗ[ ] » M R N) (f₂ : «expr ≃ₗ[ ] » N R P) :\n    (mapRange.linearEquiv (f.trans f₂) : «expr ≃ₗ[ ] » («expr →₀ » α _) R _) =\n      (mapRange.linearEquiv f).trans (mapRange.linearEquiv f₂) :=\n  LinearEquiv.ext <| mapRange_comp _ _ _ _ _\n#align map_range.linear_equiv_trans map_range.linear_equiv_trans\n\n",
 "linear_equiv_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_to_linear_map (f : «expr ≃ₗ[ ] » M R N) :\n    (mapRange.linearEquiv f).to_linear_map =\n      (mapRange.linearMap f.to_linear_map : «expr →ₗ[ ] » («expr →₀ » α M) R _) :=\n  LinearMap.ext fun _ => rfl\n#align map_range.linear_equiv_to_linear_map map_range.linear_equiv_to_linear_map\n\n",
 "linear_equiv_to_add_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_to_add_equiv (f : «expr ≃ₗ[ ] » M R N) :\n    (mapRange.linearEquiv f).to_add_equiv = (mapRange.addEquiv f.to_add_equiv : «expr ≃+ » («expr →₀ » α M) _) :=\n  AddEquiv.ext fun _ => rfl\n#align map_range.linear_equiv_to_add_equiv map_range.linear_equiv_to_add_equiv\n\n",
 "linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_symm (f : «expr ≃ₗ[ ] » M R N) :\n    ((mapRange.linearEquiv f).symm : «expr ≃ₗ[ ] » («expr →₀ » α _) R _) = mapRange.linearEquiv f.symm :=\n  LinearEquiv.ext fun x => rfl\n#align map_range.linear_equiv_symm map_range.linear_equiv_symm\n\n",
 "linear_equiv_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem map_range.linear_equiv_refl :\n    mapRange.linearEquiv (LinearEquiv.refl R M) = LinearEquiv.refl R («expr →₀ » α M) :=\n  LinearEquiv.ext mapRange_id\n#align map_range.linear_equiv_refl map_range.linear_equiv_refl\n\n",
 "lift_symm_apply":
 "@[simp]\ntheorem lift_symm_apply (f) (x) : ((lift M R X).symm f) x = f (single x 1) :=\n  rfl\n#align lift_symm_apply lift_symm_apply\n\n",
 "lift_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem lift_apply (f) (g) : ((lift M R X) f) g = g.sum fun x r => «expr • » r (f x) :=\n  rfl\n#align lift_apply lift_apply\n\n",
 "lhom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Two `R`-linear maps from `finsupp X M` which agree on each `single x y` agree everywhere.\n\nWe formulate this fact using equality of linear maps `φ.comp (lsingle a)` and `ψ.comp (lsingle a)`\nso that the `ext` tactic can apply a type-specific extensionality lemma to prove equality of these\nmaps. E.g., if `M = R`, then it suffices to verify `φ (single a 1) = ψ (single a 1)`. -/\n@[ext]\ntheorem lhom_ext' ⦃φ ψ : «expr →ₗ[ ] » («expr →₀ » α M) R N⦄ (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) :\n    φ = ψ :=\n  lhom_ext fun a => LinearMap.congr_fun (h a)\n#align lhom_ext' lhom_ext'\n\n",
 "lhom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\n/-- Two `R`-linear maps from `finsupp X M` which agree on each `single x y` agree everywhere. -/\ntheorem lhom_ext ⦃φ ψ : «expr →ₗ[ ] » («expr →₀ » α M) R N⦄ (h : ∀ a b, φ (single a b) = ψ (single a b)) : φ = ψ :=\n  LinearMap.toAddMonoidHom_injective <| addHom_ext h\n#align lhom_ext lhom_ext\n\n",
 "left_inverse_splitting_of_fun_on_fintype_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem left_inverse_splitting_of_fun_on_fintype_surjective [Fintype α] (f : «expr →ₗ[ ] » M R (α → R))\n    (s : surjective f) : left_inverse f (splittingOfFunOnFintypeSurjective f s) := fun g =>\n  LinearMap.congr_fun (splittingOfFunOnFintypeSurjective_splits f s) g\n#align left_inverse_splitting_of_fun_on_fintype_surjective left_inverse_splitting_of_fun_on_fintype_surjective\n\n",
 "left_inverse_splitting_of_finsupp_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem left_inverse_splitting_of_finsupp_surjective (f : «expr →ₗ[ ] » M R («expr →₀ » α R)) (s : surjective f) :\n    left_inverse f (splittingOfFinsuppSurjective f s) := fun g =>\n  LinearMap.congr_fun (splittingOfFinsuppSurjective_splits f s) g\n#align left_inverse_splitting_of_finsupp_surjective left_inverse_splitting_of_finsupp_surjective\n\n",
 "lcongr_symm_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem lcongr_symm_single {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) (k : κ) (n : N) :\n    (lcongr e₁ e₂).symm (Finsupp.single k n) = Finsupp.single (e₁.symm k) (e₂.symm n) :=\n  by\n  apply_fun lcongr e₁ e₂ using (lcongr e₁ e₂).injective\n  simp\n#align lcongr_symm_single lcongr_symm_single\n\n",
 "lcongr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem lcongr_symm {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) :\n    (lcongr e₁ e₂).symm = lcongr e₁.symm e₂.symm := by\n  ext\n  rfl\n#align lcongr_symm lcongr_symm\n\n",
 "lcongr_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem lcongr_single {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) (i : ι) (m : M) :\n    lcongr e₁ e₂ (Finsupp.single i m) = Finsupp.single (e₁ i) (e₂ m) := by simp [lcongr]\n#align lcongr_single lcongr_single\n\n",
 "lcongr_apply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lcongr_apply_apply {ι κ : Sort _} (e₁ : «expr ≃ » ι κ) (e₂ : «expr ≃ₗ[ ] » M R N) (f : «expr →₀ » ι M) (k : κ) :\n    lcongr e₁ e₂ f k = e₂ (f (e₁.symm k)) :=\n  rfl\n#align lcongr_apply_apply lcongr_apply_apply\n\n",
 "lapply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem lapply_apply (a : α) (f : «expr →₀ » α M) : (lapply a : «expr →ₗ[ ] » («expr →₀ » α M) R M) f = f a :=\n  rfl\n#align lapply_apply lapply_apply\n\n",
 "ker_lsingle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem ker_lsingle (a : α) : (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).ker = «expr⊥» :=\n  ker_eq_bot_of_injective (single_injective a)\n#align ker_lsingle ker_lsingle\n\n",
 "infi_ker_lapply_le_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem infi_ker_lapply_le_bot :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (lapply a : «expr →ₗ[ ] » («expr →₀ » α M) R M)) ≤\n      «expr⊥» :=\n  by\n  simp only [SetLike.le_def, mem_infi, mem_ker, mem_bot, lapply_apply]\n  exact fun a h => Finsupp.ext h\n#align infi_ker_lapply_le_bot infi_ker_lapply_le_bot\n\n",
 "fst_sum_finsupp_lequiv_prod_finsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem fst_sum_finsupp_lequiv_prod_finsupp {α β : Type _} (f : «expr →₀ » (Sum α β) M) (x : α) :\n    (sumFinsuppLEquivProdFinsupp R f).1 x = f (Sum.inl x) :=\n  rfl\n#align fst_sum_finsupp_lequiv_prod_finsupp fst_sum_finsupp_lequiv_prod_finsupp\n\n",
 "finsupp_total_repr":
 "#print Span.finsupp_total_repr /-\n@[simp]\ntheorem Span.finsupp_total_repr {w : Set M} (x : span R w) : Finsupp.total w M R coe (Span.repr R w x) = x :=\n  by\n  rw [Span.repr]\n  exact ((Finsupp.mem_span_iff_total _ _ _).mp x.2).some_spec\n#align span.finsupp_total_repr Span.finsupp_total_repr\n-/\n\n",
 "finsupp_sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print Submodule.finsupp_sum_mem /-\nprotected theorem Submodule.finsupp_sum_mem {ι β : Type _} [Zero β] (S : Submodule R M) (f : «expr →₀ » ι β)\n    (g : ι → β → M) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) : f.sum g ∈ S :=\n  AddSubmonoidClass.finsupp_sum_mem S f g h\n#align submodule.finsupp_sum_mem Submodule.finsupp_sum_mem\n-/\n\n",
 "finsupp_prod_lequiv_symm_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem finsupp_prod_lequiv_symm_apply {α β R M : Type _} [Semiring R] [AddCommMonoid M] [Module R M]\n    (f : «expr →₀ » α («expr →₀ » β M)) (xy) : (finsuppProdLEquiv R).symm f xy = f xy.1 xy.2 := by\n  conv_rhs => rw [← (finsupp_prod_lequiv R).apply_symm_apply f, finsupp_prod_lequiv_apply, prod.mk.eta]\n#align finsupp_prod_lequiv_symm_apply finsupp_prod_lequiv_symm_apply\n\n",
 "finsupp_prod_lequiv_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem finsupp_prod_lequiv_apply {α β R M : Type _} [Semiring R] [AddCommMonoid M] [Module R M]\n    (f : «expr →₀ » (α × β) M) (x y) : finsuppProdLEquiv R f x y = f (x, y) := by\n  rw [finsupp_prod_lequiv, LinearEquiv.coe_mk, finsupp_prod_equiv, Finsupp.curry_apply]\n#align finsupp_prod_lequiv_apply finsupp_prod_lequiv_apply\n\n",
 "exists_finset_of_mem_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print Submodule.exists_finset_of_mem_supᵢ /-\ntheorem Submodule.exists_finset_of_mem_supᵢ {ι : Sort _} (p : ι → Submodule R M) {m : M}\n    (hm : m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i)) :\n    ∃ s : Finset ι,\n      m ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) :=\n  by\n  have :=\n    CompleteLattice.IsCompactElement.exists_finset_of_le_supᵢ (Submodule R M)\n      (Submodule.singleton_span_isCompactElement m) p\n  simp only [Submodule.span_singleton_le_iff_mem] at this\n  exact this hm\n#align submodule.exists_finset_of_mem_supr Submodule.exists_finset_of_mem_supᵢ\n-/\n\n",
 "dom_lcongr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem dom_lcongr_trans {α₁ α₂ α₃ : Type _} (f : «expr ≃ » α₁ α₂) (f₂ : «expr ≃ » α₂ α₃) :\n    (Finsupp.domLCongr f).trans (Finsupp.domLCongr f₂) =\n      (Finsupp.domLCongr (f.trans f₂) : «expr ≃ₗ[ ] » («expr →₀ » _ M) R _) :=\n  LinearEquiv.ext fun _ => (equivMapDomain_trans _ _ _).symm\n#align dom_lcongr_trans dom_lcongr_trans\n\n",
 "dom_lcongr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_lcongr_symm {α₁ α₂ : Type _} (f : «expr ≃ » α₁ α₂) :\n    ((Finsupp.domLCongr f).symm : «expr ≃ₗ[ ] » («expr →₀ » _ M) R _) = Finsupp.domLCongr f.symm :=\n  LinearEquiv.ext fun x => rfl\n#align dom_lcongr_symm dom_lcongr_symm\n\n",
 "dom_lcongr_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem dom_lcongr_single {α₁ : Type _} {α₂ : Type _} (e : «expr ≃ » α₁ α₂) (i : α₁) (m : M) :\n    (Finsupp.domLCongr e : «expr ≃ₗ[ ] » _ R _) (Finsupp.single i m) = Finsupp.single (e i) m := by\n  simp [Finsupp.domLCongr, Finsupp.domCongr, equiv_map_domain_single]\n#align dom_lcongr_single dom_lcongr_single\n\n",
 "dom_lcongr_refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem dom_lcongr_refl : Finsupp.domLCongr (Equiv.refl α) = LinearEquiv.refl R («expr →₀ » α M) :=\n  LinearEquiv.ext fun _ => equivMapDomain_refl _\n#align dom_lcongr_refl dom_lcongr_refl\n\n",
 "dom_lcongr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem dom_lcongr_apply {α₁ : Type _} {α₂ : Type _} (e : «expr ≃ » α₁ α₂) (v : «expr →₀ » α₁ M) :\n    (Finsupp.domLCongr e : «expr ≃ₗ[ ] » _ R _) v = Finsupp.domCongr e v :=\n  rfl\n#align dom_lcongr_apply dom_lcongr_apply\n\n",
 "disjoint_supported_supported_iff":
 "theorem disjoint_supported_supported_iff [Nontrivial M] {s t : Set α} :\n    Disjoint (supported M R s) (supported M R t) ↔ Disjoint s t :=\n  by\n  refine' ⟨fun h => set.disjoint_left.mpr fun x hx1 hx2 => _, disjoint_supported_supported⟩\n  rcases exists_ne (0 : M) with ⟨y, hy⟩\n  have := h.le_bot ⟨single_mem_supported R y hx1, single_mem_supported R y hx2⟩\n  rw [mem_bot, single_eq_zero] at this\n  exact hy this\n#align disjoint_supported_supported_iff disjoint_supported_supported_iff\n\n",
 "disjoint_supported_supported":
 "theorem disjoint_supported_supported {s t : Set α} (h : Disjoint s t) : Disjoint (supported M R s) (supported M R t) :=\n  disjoint_iff.2 <| by rw [← supported_inter, disjoint_iff_inter_eq_empty.1 h, supported_empty]\n#align disjoint_supported_supported disjoint_supported_supported\n\n",
 "disjoint_lsingle_lsingle":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem disjoint_lsingle_lsingle (s t : Set α) (hs : Disjoint s t) :\n    Disjoint\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range)\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (lsingle a : «expr →ₗ[ ] » M R («expr →₀ » α M)).range) :=\n  by\n  refine'\n    (Disjoint.mono (lsingle_range_le_ker_lapply _ _ <| disjoint_compl_right)\n        (lsingle_range_le_ker_lapply _ _ <| disjoint_compl_right))\n      _\n  rw [disjoint_iff_inf_le]\n  refine' le_trans (le_infᵢ fun i => _) infi_ker_lapply_le_bot\n  classical\n    by_cases his : i ∈ s\n    · by_cases hit : i ∈ t\n      · exact (hs.le_bot ⟨his, hit⟩).elim\n      exact inf_le_of_right_le (infᵢ_le_of_le i <| infᵢ_le _ hit)\n    exact inf_le_of_left_le (infᵢ_le_of_le i <| infᵢ_le _ his)\n#align disjoint_lsingle_lsingle disjoint_lsingle_lsingle\n\n",
 "coe_lsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coe_lsum (f : α → «expr →ₗ[ ] » M R N) : (lsum S f : «expr →₀ » α M → N) = fun d => d.sum fun i => f i :=\n  rfl\n#align coe_lsum coe_lsum\n\n",
 "apply_total":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem apply_total (f : «expr →ₗ[ ] » M R M') (v) (l : «expr →₀ » α R) :\n    f (Finsupp.total α M R v l) = Finsupp.total α M' R (f ∘ v) l := by\n  apply Finsupp.induction_linear l <;> simp (config := { contextual := true })\n#align apply_total apply_total\n\n"}