{"sum_single_ite":
 "#print Finset.sum_single_ite /-\ntheorem Finset.sum_single_ite (a : R) (i : n) :\n    (Finset.univ.sum fun x : n => Finsupp.single x (ite (i = x) a 0)) = Finsupp.single i a :=\n  by\n  rw [Finset.sum_congr_set {i} (fun x : n => Finsupp.single x (ite (i = x) a 0)) fun _ => Finsupp.single i a]\n  · simp\n  · intro x hx\n    rw [Set.mem_singleton_iff] at hx\n    simp [hx]\n  intro x hx\n  have hx' : ¬i = x := by\n    refine' ne_comm.mp _\n    rwa [mem_singleton_iff] at hx\n  simp [hx']\n#align finset.sum_single_ite Finset.sum_single_ite\n-/\n\n",
 "linear_independent_single":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem linear_independent_single {φ : ι → Type _} {f : ∀ ι, φ ι → M} (hf : ∀ i, LinearIndependent R (f i)) :\n    LinearIndependent R fun ix : Σi, φ i => single ix.1 (f ix.1 ix.2) :=\n  by\n  apply @linearIndependent_unionᵢ_finite R _ _ _ _ ι φ fun i x => single i (f i x)\n  · intro i\n    have h_disjoint : Disjoint (span R (range (f i))) (ker (lsingle i)) :=\n      by\n      rw [ker_lsingle]\n      exact disjoint_bot_right\n    apply (hf i).map h_disjoint\n  · intro i t ht hit\n    refine' (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono _ _\n    · rw [span_le]\n      simp only [supᵢ_singleton]\n      rw [range_coe]\n      apply range_comp_subset_range\n    · refine' supᵢ₂_mono fun i hi => _\n      rw [span_le, range_coe]\n      apply range_comp_subset_range\n#align linear_independent_single linear_independent_single\n\n",
 "equiv_fun_symm_std_basis":
 "@[simp]\ntheorem equiv_fun_symm_std_basis (b : Basis n R M) (i : n) :\n    b.equiv_fun.symm (LinearMap.stdBasis R (fun _ => R) i 1) = b i :=\n  by\n  have := EquivLike.injective b.repr\n  apply_fun b.repr\n  simp only [equiv_fun_symm_apply, std_basis_apply', LinearEquiv.map_sum, LinearEquiv.map_smulₛₗ, RingHom.id_apply,\n    repr_self, Finsupp.smul_single', boole_mul]\n  exact Finset.sum_single_ite 1 i\n#align equiv_fun_symm_std_basis equiv_fun_symm_std_basis\n\n",
 "coe_basis_single_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coe_basis_single_one : (Finsupp.basisSingleOne : ι → «expr →₀ » ι R) = fun i => Finsupp.single i 1 :=\n  funext fun i => Basis.apply_eq_iff.mpr rfl\n#align coe_basis_single_one coe_basis_single_one\n\n",
 "coe_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_basis {φ : ι → Type _} (b : ∀ i, Basis (φ i) R M) :\n    «expr⇑ » (Finsupp.basis b) = fun ix : Σi, φ i => single ix.1 (b ix.1 ix.2) :=\n  funext fun ⟨i, x⟩ =>\n    Basis.apply_eq_iff.mpr <| by\n      ext ⟨j, y⟩\n      by_cases h : i = j\n      · cases h\n        simp only [basis_repr, single_eq_same, Basis.repr_self, Finsupp.single_apply_left sigma_mk_injective]\n      simp only [basis_repr, single_apply, h, false_and_iff, if_false, LinearEquiv.map_zero, zero_apply]\n#align coe_basis coe_basis\n\n",
 "basis_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem basis_repr {φ : ι → Type _} (b : ∀ i, Basis (φ i) R M) (g : «expr →₀ » ι M) (ix) :\n    (Finsupp.basis b).repr g ix = (b ix.1).repr (g ix.1) ix.2 :=\n  rfl\n#align basis_repr basis_repr\n\n"}