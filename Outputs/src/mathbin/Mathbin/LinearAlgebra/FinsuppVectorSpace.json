{"sum_single_ite":
 "theorem _root_.finset.sum_single_ite (a : R) (i : n) :\n    (finset.univ.sum fun x : n => finsupp.single x (ite (i = x) a 0)) = finsupp.single i a :=\n  by\n  rw [finset.sum_congr_set {i} (fun x : n => finsupp.single x (ite (i = x) a 0)) fun _ => finsupp.single i a]\n  · simp\n  · intro x hx\n    rw [Set.mem_singleton_iff] at hx\n    simp [hx]\n  intro x hx\n  have hx' : ¬i = x := by\n    refine' ne_comm.mp _\n    rwa [mem_singleton_iff] at hx\n  simp [hx']\n#align finset.sum_single_ite finset.sum_single_ite\n\n",
 "linear_independent_single":
 "/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem linear_independent_single {φ : ι → Type _} {f : ∀ ι, φ ι → M} (hf : ∀ i, linear_independent R (f i)) :\n    linear_independent R fun ix : Σi, φ i => single ix.1 (f ix.1 ix.2) :=\n  by\n  apply @linear_independent_Union_finite R _ _ _ _ ι φ fun i x => single i (f i x)\n  · intro i\n    have h_disjoint : Disjoint (span R (range (f i))) (ker (lsingle i)) :=\n      by\n      rw [ker_lsingle]\n      exact disjoint_bot_right\n    apply (hf i).map h_disjoint\n  · intro i t ht hit\n    refine' (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono _ _\n    · rw [span_le]\n      simp only [supᵢ_singleton]\n      rw [range_coe]\n      apply range_comp_subset_range\n    · refine' supᵢ₂_mono fun i hi => _\n      rw [span_le, range_coe]\n      apply range_comp_subset_range\n#align linear_independent_single linear_independent_single\n\n",
 "equiv_of_dim_eq_lift_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem equiv_of_dim_eq_lift_dim (h : cardinal.lift.{w} (module.rank K V) = cardinal.lift.{v} (module.rank K V')) :\n    nonempty («expr ≃ₗ[ ] » V K V') := by\n  haveI := classical.dec_eq V\n  haveI := classical.dec_eq V'\n  let m := basis.of_vector_space K V\n  let m' := basis.of_vector_space K V'\n  rw [← cardinal.lift_inj.1 m.mk_eq_dim, ← cardinal.lift_inj.1 m'.mk_eq_dim] at h\n  rcases quotient.exact h with ⟨e⟩\n  let e := (equiv.ulift.symm.trans e).trans equiv.ulift\n  exact ⟨«expr ≪≫ₗ » («expr ≪≫ₗ » m.repr (finsupp.dom_lcongr e)) m'.repr.symm⟩\n#align equiv_of_dim_eq_lift_dim equiv_of_dim_eq_lift_dim\n\n",
 "equiv_fun_symm_std_basis":
 "@[simp]\ntheorem equiv_fun_symm_std_basis (b : basis n R M) (i : n) :\n    b.equiv_fun.symm (linear_map.std_basis R (fun _ => R) i 1) = b i :=\n  by\n  have := equiv_like.injective b.repr\n  apply_fun b.repr\n  simp only [equiv_fun_symm_apply, std_basis_apply', linear_equiv.map_sum, linear_equiv.map_smulₛₗ, RingHom.id_apply,\n    repr_self, finsupp.smul_single', boole_mul]\n  exact finset.sum_single_ite 1 i\n#align equiv_fun_symm_std_basis equiv_fun_symm_std_basis\n\n",
 "dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem dim_eq : module.rank K («expr →₀ » ι V) = cardinal.mk ι * module.rank K V :=\n  by\n  let bs := basis.of_vector_space K V\n  rw [← bs.mk_eq_dim'', ← (finsupp.basis fun a : ι => bs).mk_eq_dim'', cardinal.mk_sigma, cardinal.sum_const']\n#align dim_eq dim_eq\n\n",
 "coe_basis_single_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coe_basis_single_one : (finsupp.basis_single_one : ι → «expr →₀ » ι R) = fun i => finsupp.single i 1 :=\n  funext fun i => basis.apply_eq_iff.mpr rfl\n#align coe_basis_single_one coe_basis_single_one\n\n",
 "coe_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_basis {φ : ι → Type _} (b : ∀ i, basis (φ i) R M) :\n    «expr⇑ » (finsupp.basis b) = fun ix : Σi, φ i => single ix.1 (b ix.1 ix.2) :=\n  funext fun ⟨i, x⟩ =>\n    basis.apply_eq_iff.mpr <| by\n      ext ⟨j, y⟩\n      by_cases h : i = j\n      · cases h\n        simp only [basis_repr, single_eq_same, basis.repr_self, finsupp.single_apply_left sigma_mk_injective]\n      simp only [basis_repr, single_apply, h, false_and_iff, if_false, linear_equiv.map_zero, zero_apply]\n#align coe_basis coe_basis\n\n",
 "basis_repr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem basis_repr {φ : ι → Type _} (b : ∀ i, basis (φ i) R M) (g : «expr →₀ » ι M) (ix) :\n    (finsupp.basis b).repr g ix = (b ix.1).repr (g ix.1) ix.2 :=\n  rfl\n#align basis_repr basis_repr\n\n"}