{"trace_transpose'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem trace_transpose' (f : «expr →ₗ[ ] » M R M) : trace R _ (module.dual.transpose f) = trace R M f := by\n  rw [← comp_apply, trace_transpose]\n#align trace_transpose' trace_transpose'\n\n",
 "trace_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n@[simp]\ntheorem trace_transpose : «expr ∘ₗ » (trace R (module.dual R M)) module.dual.transpose = trace R M :=\n  by\n  let e := dual_tensor_hom_equiv R M M\n  have h : function.surjective e.to_linear_map := e.surjective\n  refine' (cancel_right h).1 _\n  ext (f m); simp [e]\n#align trace_transpose trace_transpose\n\n",
 "trace_tensor_product'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\ntheorem trace_tensor_product' (f : «expr →ₗ[ ] » M R M) (g : «expr →ₗ[ ] » N R N) :\n    trace R (tensor_product.infer M N) (map f g) = trace R M f * trace R N g :=\n  by\n  have h := ext_iff.1 (ext_iff.1 (trace_tensor_product R M N) f) g\n  simp only [compr₂_apply, map_bilinear_apply, compl₁₂_apply, lsmul_apply, Algebra.id.smul_eq_mul] at h\n  exact h\n#align trace_tensor_product' trace_tensor_product'\n\n",
 "trace_tensor_product":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem trace_tensor_product :\n    compr₂ (mapBilinear R M N M N) (trace R (tensor_product.infer M N)) =\n      compl₁₂ (lsmul R R : «expr →ₗ[ ] » R R («expr →ₗ[ ] » R R R)) (trace R M) (trace R N) :=\n  by\n  apply\n    (compl₁₂_inj (show surjective (dual_tensor_hom R M M) from (dual_tensor_hom_equiv R M M).surjective)\n        (show surjective (dual_tensor_hom R N N) from (dual_tensor_hom_equiv R N N).surjective)).1\n  ext (f m g n)\n  simp only [algebra_tensor_module.curry_apply, to_fun_eq_coe, TensorProduct.curry_apply, coe_restrict_scalars_eq_coe,\n    compl₁₂_apply, compr₂_apply, map_bilinear_apply, trace_eq_contract_apply, contract_left_apply, lsmul_apply,\n    Algebra.id.smul_eq_mul, map_dual_tensor_hom, dual_distrib_apply]\n#align trace_tensor_product trace_tensor_product\n\n",
 "trace_prod_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem trace_prod_map' (f : «expr →ₗ[ ] » M R M) (g : «expr →ₗ[ ] » N R N) :\n    trace R (M × N) (prodMap f g) = trace R M f + trace R N g :=\n  by\n  have h := ext_iff.1 (trace_prod_map R M N) (f, g)\n  simp only [coe_comp, Function.comp_apply, prod_map_apply, coprod_apply, id_coe, id.def, prod_map_linear_apply] at h\n  exact h\n#align trace_prod_map' trace_prod_map'\n\n",
 "trace_prod_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem trace_prod_map :\n    «expr ∘ₗ » (trace R (M × N)) (prodMapLinear R M N M N R) =\n      «expr ∘ₗ » (coprod id id : «expr →ₗ[ ] » (R × R) R R) (prodMap (trace R M) (trace R N)) :=\n  by\n  let e := (dual_tensor_hom_equiv R M M).prod (dual_tensor_hom_equiv R N N)\n  have h : function.surjective e.to_linear_map := e.surjective\n  refine' (cancel_right h).1 _\n  ext\n  ·\n    simp only [dual_tensor_hom_equiv, tensor_product.algebra_tensor_module.curry_apply, to_fun_eq_coe,\n      TensorProduct.curry_apply, coe_restrict_scalars_eq_coe, coe_comp, LinearEquiv.coe_toLinearMap, coe_inl,\n      Function.comp_apply, LinearEquiv.prod_apply, dual_tensor_hom_equiv_of_basis_apply, map_zero, prod_map_apply,\n      coprod_apply, id_coe, id.def, add_zero, prod_map_linear_apply, dual_tensor_hom_prod_map_zero,\n      trace_eq_contract_apply, contract_left_apply, fst_apply]\n  ·\n    simp only [dual_tensor_hom_equiv, tensor_product.algebra_tensor_module.curry_apply, to_fun_eq_coe,\n      TensorProduct.curry_apply, coe_restrict_scalars_eq_coe, coe_comp, LinearEquiv.coe_toLinearMap, coe_inr,\n      Function.comp_apply, LinearEquiv.prod_apply, dual_tensor_hom_equiv_of_basis_apply, map_zero, prod_map_apply,\n      coprod_apply, id_coe, id.def, zero_add, prod_map_linear_apply, zero_prod_map_dual_tensor_hom,\n      trace_eq_contract_apply, contract_left_apply, snd_apply]\n#align trace_prod_map trace_prod_map\n\n",
 "trace_one":
 "/-- The trace of the identity endomorphism is the dimension of the free module -/\n@[simp]\ntheorem trace_one : trace R M 1 = (finrank R M : R) :=\n  by\n  have b := Module.Free.chooseBasis R M\n  rw [trace_eq_matrix_trace R b, to_matrix_one, finrank_eq_card_choose_basis_index]\n  simp\n#align trace_one trace_one\n\n",
 "trace_mul_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem trace_mul_comm (f g : «expr →ₗ[ ] » M R M) : trace R M (f * g) = trace R M (g * f) :=\n  if H : ∃ s : Finset M, Nonempty (Basis s R M) then\n    by\n    let ⟨s, ⟨b⟩⟩ := H\n    simp_rw [trace_eq_matrix_trace R b, LinearMap.toMatrix_mul]\n    apply Matrix.trace_mul_comm\n  else by rw [trace, dif_neg H, LinearMap.zero_apply, LinearMap.zero_apply]\n#align trace_mul_comm trace_mul_comm\n\n",
 "trace_id":
 "/-- The trace of the identity endomorphism is the dimension of the free module -/\n@[simp]\ntheorem trace_id : trace R M id = (finrank R M : R) := by rw [← one_eq_id, trace_one]\n#align trace_id trace_id\n\n",
 "trace_eq_matrix_trace_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Auxiliary lemma for `trace_eq_matrix_trace`. -/\ntheorem trace_eq_matrix_trace_of_finset {s : Finset M} (b : Basis s R M) (f : «expr →ₗ[ ] » M R M) :\n    trace R M f = Matrix.trace (LinearMap.toMatrix b b f) :=\n  by\n  have : ∃ s : Finset M, Nonempty (Basis s R M) := ⟨s, ⟨b⟩⟩\n  rw [trace, dif_pos this, ← trace_aux_def]\n  congr 1\n  apply trace_aux_eq\n#align trace_eq_matrix_trace_of_finset trace_eq_matrix_trace_of_finset\n\n",
 "trace_eq_matrix_trace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem trace_eq_matrix_trace (f : «expr →ₗ[ ] » M R M) : trace R M f = Matrix.trace (LinearMap.toMatrix b b f) := by\n  rw [trace_eq_matrix_trace_of_finset R b.reindex_finset_range, ← trace_aux_def, ← trace_aux_def, trace_aux_eq R b]\n#align trace_eq_matrix_trace trace_eq_matrix_trace\n\n",
 "trace_eq_contract_of_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- The trace of a linear map correspond to the contraction pairing under the isomorphism\n `End(M) ≃ M* ⊗ M`-/\ntheorem trace_eq_contract_of_basis' [Fintype ι] [DecidableEq ι] (b : Basis ι R M) :\n    linear_map.trace R M = «expr ∘ₗ » (contract_left R M) (dual_tensor_hom_equiv_of_basis b).symm.to_linear_map := by\n  simp [LinearEquiv.eq_comp_toLinearMap_symm, trace_eq_contract_of_basis b]\n#align trace_eq_contract_of_basis' trace_eq_contract_of_basis'\n\n",
 "trace_eq_contract_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- The trace of a linear map correspond to the contraction pairing under the isomorphism\n `End(M) ≃ M* ⊗ M`-/\ntheorem trace_eq_contract_of_basis [Finite ι] (b : Basis ι R M) :\n    «expr ∘ₗ » (linear_map.trace R M) (dual_tensor_hom R M M) = contract_left R M := by\n  classical\n    cases nonempty_fintype ι\n    apply Basis.ext (Basis.tensorProduct (basis.dual_basis b) b)\n    rintro ⟨i, j⟩\n    simp only [Function.comp_apply, Basis.tensorProduct_apply, basis.coe_dual_basis, coe_comp]\n    rw [trace_eq_matrix_trace R b, to_matrix_dual_tensor_hom]\n    by_cases hij : i = j\n    · rw [hij]\n      simp\n    rw [Matrix.StdBasisMatrix.trace_zero j i (1 : R) hij]\n    simp [Finsupp.single_eq_pi_single, hij]\n#align trace_eq_contract_of_basis trace_eq_contract_of_basis\n\n",
 "trace_eq_contract_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n@[simp]\ntheorem trace_eq_contract_apply (x : tensor_product (module.dual R M) R M) :\n    (linear_map.trace R M) ((dual_tensor_hom R M M) x) = contract_left R M x := by rw [← comp_apply, trace_eq_contract]\n#align trace_eq_contract_apply trace_eq_contract_apply\n\n",
 "trace_eq_contract'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- When `M` is finite free, the trace of a linear map correspond to the contraction pairing under\nthe isomorphism `End(M) ≃ M* ⊗ M`-/\ntheorem trace_eq_contract' :\n    linear_map.trace R M = «expr ∘ₗ » (contract_left R M) (dual_tensor_hom_equiv R M M).symm.to_linear_map :=\n  trace_eq_contract_of_basis' (Module.Free.chooseBasis R M)\n#align trace_eq_contract' trace_eq_contract'\n\n",
 "trace_eq_contract":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- When `M` is finite free, the trace of a linear map correspond to the contraction pairing under\nthe isomorphism `End(M) ≃ M* ⊗ M`-/\n@[simp]\ntheorem trace_eq_contract : «expr ∘ₗ » (linear_map.trace R M) (dual_tensor_hom R M M) = contract_left R M :=\n  trace_eq_contract_of_basis (Module.Free.chooseBasis R M)\n#align trace_eq_contract trace_eq_contract\n\n",
 "trace_conj'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem trace_conj' (f : «expr →ₗ[ ] » M R M) (e : «expr ≃ₗ[ ] » M R N) : trace R N (e.conj f) = trace R M f := by\n  rw [e.conj_apply, trace_comp_comm', ← comp_assoc, LinearEquiv.comp_coe, LinearEquiv.self_trans_symm,\n    LinearEquiv.refl_toLinearMap, id_comp]\n#align trace_conj' trace_conj'\n\n",
 "trace_conj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The trace of an endomorphism is invariant under conjugation -/\n@[simp]\ntheorem trace_conj (g : «expr →ₗ[ ] » M R M) (f : «expr ˣ» («expr →ₗ[ ] » M R M)) :\n    trace R M (↑f * g * ↑f⁻¹) = trace R M g := by\n  rw [trace_mul_comm]\n  simp\n#align trace_conj trace_conj\n\n",
 "trace_comp_comm'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\ntheorem trace_comp_comm' (f : «expr →ₗ[ ] » M R N) (g : «expr →ₗ[ ] » N R M) :\n    trace R M («expr ∘ₗ » g f) = trace R N («expr ∘ₗ » f g) :=\n  by\n  have h := ext_iff.1 (ext_iff.1 (trace_comp_comm R M N) g) f\n  simp only [llcomp_apply', compr₂_apply, flip_apply] at h\n  exact h\n#align trace_comp_comm' trace_comp_comm'\n\n",
 "trace_comp_comm":
 "theorem trace_comp_comm : compr₂ (llcomp R M N M) (trace R M) = compr₂ (llcomp R N M N).flip (trace R N) :=\n  by\n  apply\n    (compl₁₂_inj (show surjective (dual_tensor_hom R N M) from (dual_tensor_hom_equiv R N M).surjective)\n        (show surjective (dual_tensor_hom R M N) from (dual_tensor_hom_equiv R M N).surjective)).1\n  ext (g m f n)\n  simp only [tensor_product.algebra_tensor_module.curry_apply, to_fun_eq_coe, LinearEquiv.coe_toLinearMap,\n    TensorProduct.curry_apply, coe_restrict_scalars_eq_coe, compl₁₂_apply, compr₂_apply, flip_apply, llcomp_apply',\n    comp_dual_tensor_hom, map_smul, trace_eq_contract_apply, contract_left_apply, smul_eq_mul, mul_comm]\n#align trace_comp_comm trace_comp_comm\n\n",
 "trace_aux_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem trace_aux_eq : trace_aux R b = trace_aux R c :=\n  LinearMap.ext fun f =>\n    calc\n      Matrix.trace (LinearMap.toMatrix b b f) =\n          Matrix.trace (LinearMap.toMatrix b b ((LinearMap.id.comp f).comp LinearMap.id)) :=\n        by rw [LinearMap.id_comp, LinearMap.comp_id]\n      _ =\n          Matrix.trace\n            (matrix.mul (matrix.mul (LinearMap.toMatrix c b LinearMap.id) (LinearMap.toMatrix c c f))\n              (LinearMap.toMatrix b c LinearMap.id)) :=\n        by rw [LinearMap.toMatrix_comp _ c, LinearMap.toMatrix_comp _ c]\n      _ =\n          Matrix.trace\n            (matrix.mul (matrix.mul (LinearMap.toMatrix c c f) (LinearMap.toMatrix b c LinearMap.id))\n              (LinearMap.toMatrix c b LinearMap.id)) :=\n        by rw [Matrix.mul_assoc, Matrix.trace_mul_comm]\n      _ = Matrix.trace (LinearMap.toMatrix c c ((f.comp LinearMap.id).comp LinearMap.id)) := by\n        rw [LinearMap.toMatrix_comp _ b, LinearMap.toMatrix_comp _ c]\n      _ = Matrix.trace (LinearMap.toMatrix c c f) := by rw [LinearMap.comp_id, LinearMap.comp_id]\n      \n#align trace_aux_eq trace_aux_eq\n\n",
 "trace_aux_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2019 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Patrick Massot, Casper Putz, Anne Baanen, Antoine Labelle\n-/\n-- Can't be `simp` because it would cause a loop.\ntheorem trace_aux_def (b : Basis ι R M) (f : «expr →ₗ[ ] » M R M) :\n    trace_aux R b f = Matrix.trace (LinearMap.toMatrix b b f) :=\n  rfl\n#align trace_aux_def trace_aux_def\n\n",
 "trace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_proj.trace {p : Submodule R M} {f : «expr →ₗ[ ] » M R M} (h : IsProj p f) [Module.Free R p]\n    [Module.Finite R p] [Module.Free R f.ker] [Module.Finite R f.ker] : trace R M f = (finrank R p : R) := by\n  rw [h.eq_conj_prod_map, trace_conj', trace_prod_map', trace_id, map_zero, add_zero]\n#align is_proj.trace is_proj.trace\n\n"}