{"transpose_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem transpose_comp (u : «expr →ₗ[ ] » M' R M'') (v : «expr →ₗ[ ] » M R M') :\n    transpose (u.comp v) = (transpose v).comp (transpose u) :=\n  rfl\n#align transpose_comp transpose_comp\n\n",
 "transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem transpose_apply (u : «expr →ₗ[ ] » M R M') (l : dual R M') : transpose u l = l.comp u :=\n  rfl\n#align transpose_apply transpose_apply\n\n",
 "total_dual_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_dual_basis (f : «expr →₀ » ι R) (i : ι) : Finsupp.total ι (dual R M) R b.dual_basis f (b i) = f i :=\n  by\n  cases nonempty_fintype ι\n  rw [Finsupp.total_apply, Finsupp.sum_fintype, LinearMap.sum_apply]\n  ·\n    simp_rw [LinearMap.smul_apply, smul_eq_mul, dual_basis_apply_self, mul_boole, Finset.sum_ite_eq,\n      if_pos (Finset.mem_univ i)]\n  · intro\n    rw [zero_smul]\n#align total_dual_basis total_dual_basis\n\n",
 "total_coord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- `simp` normal form version of `total_dual_basis` -/\n@[simp]\ntheorem total_coord [CommRing R] [AddCommGroup M] [Module R M] [Finite ι] (b : Basis ι R M) (f : «expr →₀ » ι R)\n    (i : ι) : Finsupp.total ι (dual R M) R b.coord f (b i) = f i :=\n  by\n  haveI := Classical.decEq ι\n  rw [← coe_dual_basis, total_dual_basis]\n#align total_coord total_coord\n\n",
 "topDualPairing_apply":
 "#print topDualPairing_apply /-\n@[simp]\ntheorem topDualPairing_apply {W : Submodule R M} (φ : module.dual R M) (x : W) :\n    W.dual_pairing (Quotient.mk φ) x = φ x :=\n  rfl\n#align dual_pairing_apply topDualPairing_apply\n-/\n\n",
 "to_dual_total_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem to_dual_total_right (f : «expr →₀ » ι R) (i : ι) : b.to_dual (b i) (Finsupp.total ι M R b f) = f i :=\n  by\n  rw [Finsupp.total_apply, Finsupp.sum, LinearMap.map_sum]\n  simp_rw [LinearMap.map_smul, to_dual_apply, smul_eq_mul, mul_boole, Finset.sum_ite_eq]\n  split_ifs with h\n  · rfl\n  · rw [finsupp.not_mem_support_iff.mp h]\n#align to_dual_total_right to_dual_total_right\n\n",
 "to_dual_total_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem to_dual_total_left (f : «expr →₀ » ι R) (i : ι) : b.to_dual (Finsupp.total ι M R b f) (b i) = f i :=\n  by\n  rw [Finsupp.total_apply, Finsupp.sum, LinearMap.map_sum, LinearMap.sum_apply]\n  simp_rw [LinearMap.map_smul, LinearMap.smul_apply, to_dual_apply, smul_eq_mul, mul_boole, Finset.sum_ite_eq']\n  split_ifs with h\n  · rfl\n  · rw [finsupp.not_mem_support_iff.mp h]\n#align to_dual_total_left to_dual_total_left\n\n",
 "to_dual_to_dual":
 "@[simp]\ntheorem to_dual_to_dual : b.dual_basis.to_dual.comp b.to_dual = dual.eval R M :=\n  by\n  refine' b.ext fun i => b.dual_basis.ext fun j => _\n  rw [LinearMap.comp_apply, to_dual_apply_left, coe_to_dual_self, ← coe_dual_basis, dual.eval_apply, Basis.repr_self,\n    Finsupp.single_apply, dual_basis_apply_self]\n#align to_dual_to_dual to_dual_to_dual\n\n",
 "to_dual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_dual_range [Finite ι] : b.to_dual.range = «expr⊤» :=\n  by\n  cases nonempty_fintype ι\n  refine' eq_top_iff'.2 fun f => _\n  rw [LinearMap.mem_range]\n  let lin_comb : «expr →₀ » ι R := finsupp.equiv_fun_on_finite.symm fun i => f.to_fun (b i)\n  refine' ⟨Finsupp.total ι M R b lin_comb, b.ext fun i => _⟩\n  rw [b.to_dual_eq_repr _ i, repr_total b]\n  rfl\n#align to_dual_range to_dual_range\n\n",
 "to_dual_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem to_dual_ker : b.to_dual.ker = «expr⊥» :=\n  ker_eq_bot'.mpr b.to_dual_inj\n#align to_dual_ker to_dual_ker\n\n",
 "to_dual_inj":
 "theorem to_dual_inj (m : M) (a : b.to_dual m = 0) : m = 0 :=\n  by\n  rw [← mem_bot R, ← b.repr.ker, mem_ker, LinearEquiv.coe_coe]\n  apply Finsupp.ext\n  intro b\n  rw [← to_dual_eq_repr, a]\n  rfl\n#align to_dual_inj to_dual_inj\n\n",
 "to_dual_flip_apply":
 "theorem to_dual_flip_apply (m₁ m₂ : M) : b.to_dual_flip m₁ m₂ = b.to_dual m₂ m₁ :=\n  rfl\n#align to_dual_flip_apply to_dual_flip_apply\n\n",
 "to_dual_eq_repr":
 "theorem to_dual_eq_repr (m : M) (i : ι) : b.to_dual m (b i) = b.repr m i :=\n  b.to_dual_apply_left m i\n#align to_dual_eq_repr to_dual_eq_repr\n\n",
 "to_dual_eq_equiv_fun":
 "theorem to_dual_eq_equiv_fun [Fintype ι] (m : M) (i : ι) : b.to_dual m (b i) = b.equiv_fun m i := by\n  rw [b.equiv_fun_apply, to_dual_eq_repr]\n#align to_dual_eq_equiv_fun to_dual_eq_equiv_fun\n\n",
 "to_dual_apply_right":
 "theorem to_dual_apply_right (i : ι) (m : M) : b.to_dual (b i) m = b.repr m i := by\n  rw [← b.to_dual_total_right, b.total_repr]\n#align to_dual_apply_right to_dual_apply_right\n\n",
 "to_dual_apply_left":
 "theorem to_dual_apply_left (m : M) (i : ι) : b.to_dual m (b i) = b.repr m i := by\n  rw [← b.to_dual_total_left, b.total_repr]\n#align to_dual_apply_left to_dual_apply_left\n\n",
 "to_dual_apply":
 "theorem to_dual_apply (i j : ι) : b.to_dual (b i) (b j) = if i = j then 1 else 0 :=\n  by\n  erw [constr_basis b, constr_basis b]\n  ac_rfl\n#align to_dual_apply to_dual_apply\n\n",
 "supr_dual_annihilator_le_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/-- See also `subspace.dual_annihilator_infi_eq` for vector subspaces when `ι` is finite. -/\ntheorem supr_dual_annihilator_le_infi {ι : Type _} (U : ι → Submodule R M) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (U i).dual_annihilator ≤\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (U i)).dual_annihilator :=\n  by\n  rw [le_dual_annihilator_iff_le_dual_coannihilator, dual_coannihilator_supr_eq]\n  apply infᵢ_mono\n  exact fun i : ι => le_dual_annihilator_dual_coannihilator (U i)\n#align supr_dual_annihilator_le_infi supr_dual_annihilator_le_infi\n\n",
 "sup_dual_annihilator_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- See also `subspace.dual_annihilator_inf_eq` for vector subspaces. -/\ntheorem sup_dual_annihilator_le_inf (U V : Submodule R M) :\n    «expr ⊔ » U.dual_annihilator V.dual_annihilator ≤ («expr ⊓ » U V).dual_annihilator :=\n  by\n  rw [le_dual_annihilator_iff_le_dual_coannihilator, dual_coannihilator_sup_eq]\n  apply inf_le_inf <;> exact le_dual_annihilator_dual_coannihilator _\n#align sup_dual_annihilator_le_inf sup_dual_annihilator_le_inf\n\n",
 "sum_dual_apply_smul_coord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem sum_dual_apply_smul_coord (f : module.dual R M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f (b x)) (b.coord x)) =\n      f :=\n  by\n  ext m\n  simp_rw [LinearMap.sum_apply, LinearMap.smul_apply, smul_eq_mul, mul_comm (f _), ← smul_eq_mul, ← f.map_smul, ←\n    f.map_sum, basis.coord_apply, Basis.sum_repr]\n#align sum_dual_apply_smul_coord sum_dual_apply_smul_coord\n\n",
 "range_dual_map_mkq_eq":
 "/-- That $\\operatorname{im}(q^* : (V/W)^* \\to V^*) = \\operatorname{ann}(W)$. -/\ntheorem range_dual_map_mkq_eq (W : Submodule R M) : W.mkq.dual_map.range = W.dual_annihilator :=\n  by\n  ext φ\n  rw [LinearMap.mem_range]\n  constructor\n  · rintro ⟨ψ, rfl⟩\n    have := LinearMap.mem_range_self W.mkq.dual_map ψ\n    simpa only [ker_mkq] using linear_map.range_dual_map_le_dual_annihilator_ker W.mkq this\n  · intro hφ\n    exists W.dual_copairing ⟨φ, hφ⟩\n    ext\n    rfl\n#align range_dual_map_mkq_eq range_dual_map_mkq_eq\n\n",
 "range_dual_map_le_dual_annihilator_ker":
 "theorem range_dual_map_le_dual_annihilator_ker : f.dual_map.range ≤ f.ker.dual_annihilator :=\n  by\n  rintro _ ⟨ψ, rfl⟩\n  simp_rw [submodule.mem_dual_annihilator, mem_ker]\n  rintro x hx\n  rw [dual_map_apply, hx, map_zero]\n#align range_dual_map_le_dual_annihilator_ker range_dual_map_le_dual_annihilator_ker\n\n",
 "range_dual_map_eq_dual_annihilator_ker_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem range_dual_map_eq_dual_annihilator_ker_of_surjective (f : «expr →ₗ[ ] » M R M') (hf : function.surjective f) :\n    f.dual_map.range = f.ker.dual_annihilator :=\n  by\n  rw [← f.ker.range_dual_map_mkq_eq]\n  let f' := LinearMap.quotKerEquivOfSurjective f hf\n  trans LinearMap.range (f.dual_map.comp f'.symm.dual_map.to_linear_map)\n  · rw [LinearMap.range_comp_of_range_eq_top]\n    apply LinearEquiv.range\n  · apply congr_arg\n    ext (φ x)\n    simp only [LinearMap.coe_comp, LinearEquiv.coe_toLinearMap, linear_map.dual_map_apply, linear_equiv.dual_map_apply,\n      mkq_apply, f', LinearMap.quotKerEquivOfSurjective, LinearEquiv.trans_symm, LinearEquiv.trans_apply,\n      LinearEquiv.ofTop_symm_apply, LinearMap.quotKerEquivRange_symm_apply_image, mkq_apply]\n#align range_dual_map_eq_dual_annihilator_ker_of_surjective range_dual_map_eq_dual_annihilator_ker_of_surjective\n\n",
 "range_dual_map_eq_dual_annihilator_ker_of_subtype_range_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Note, this can be specialized to the case where `R` is an injective `R`-module, or when\n-- `f.coker` is a projective `R`-module.\ntheorem range_dual_map_eq_dual_annihilator_ker_of_subtype_range_surjective (f : «expr →ₗ[ ] » M R M')\n    (hf : function.surjective f.range.subtype.dual_map) : f.dual_map.range = f.ker.dual_annihilator :=\n  by\n  have rr_surj : function.surjective f.range_restrict := by rw [← LinearMap.range_eq_top, LinearMap.range_rangeRestrict]\n  have := range_dual_map_eq_dual_annihilator_ker_of_surjective f.range_restrict rr_surj\n  convert this using 1\n  · change ((Submodule.subtype f.range).comp f.range_restrict).dual_map.range = _\n    rw [← linear_map.dual_map_comp_dual_map, LinearMap.range_comp_of_range_eq_top]\n    rwa [LinearMap.range_eq_top]\n  · apply congr_arg\n    exact (LinearMap.ker_rangeRestrict f).symm\n#align range_dual_map_eq_dual_annihilator_ker_of_subtype_range_surjective range_dual_map_eq_dual_annihilator_ker_of_subtype_range_surjective\n\n",
 "range_dual_map_eq_dual_annihilator_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem range_dual_map_eq_dual_annihilator_ker (f : «expr →ₗ[ ] » V₁ K V₂) :\n    f.dual_map.range = f.ker.dual_annihilator :=\n  range_dual_map_eq_dual_annihilator_ker_of_subtype_range_surjective f <|\n    dual_map_surjective_of_injective (range f).injective_subtype\n#align range_dual_map_eq_dual_annihilator_ker range_dual_map_eq_dual_annihilator_ker\n\n",
 "quot_annihilator_equiv_apply":
 "@[simp]\ntheorem quot_annihilator_equiv_apply (W : Subspace K V) (φ : module.dual K V) :\n    W.quot_annihilator_equiv (Submodule.Quotient.mk φ) = W.dual_restrict φ :=\n  by\n  ext\n  rfl\n#align quot_annihilator_equiv_apply quot_annihilator_equiv_apply\n\n",
 "mem_of_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- `convert` to get rid of a `decidable_eq` mismatch\ntheorem mem_of_mem_span {H : Set ι} {x : M} (hmem : x ∈ Submodule.span R («expr '' » e H)) :\n    ∀ i : ι, ε i x ≠ 0 → i ∈ H := by\n  intro i hi\n  rcases(Finsupp.mem_span_image_iff_total _).mp hmem with ⟨l, supp_l, rfl⟩\n  apply not_imp_comm.mp ((Finsupp.mem_supported' _ _).mp supp_l i)\n  rwa [← lc_def, h.dual_lc] at hi\n#align mem_of_mem_span mem_of_mem_span\n\n",
 "mem_dual_coannihilator":
 "theorem mem_dual_coannihilator {Φ : Submodule R (module.dual R M)} (x : M) :\n    x ∈ Φ.dual_coannihilator ↔ ∀ φ ∈ Φ, (φ x : R) = 0 := by\n  simp_rw [dual_coannihilator, mem_comap, mem_dual_annihilator, module.dual.eval_apply]\n#align mem_dual_coannihilator mem_dual_coannihilator\n\n",
 "mem_dual_annihilator":
 "@[simp]\ntheorem mem_dual_annihilator (φ : module.dual R M) : φ ∈ W.dual_annihilator ↔ ∀ w ∈ W, φ w = 0 :=\n  by\n  refine' linear_map.mem_ker.trans _\n  simp_rw [LinearMap.ext_iff, dual_restrict_apply]\n  exact ⟨fun h w hw => h ⟨w, hw⟩, fun h w => h w.1 w.2⟩\n#align mem_dual_annihilator mem_dual_annihilator\n\n",
 "map_eval_injective":
 "theorem map_eval_injective : (Submodule.map (eval K V)).injective :=\n  by\n  apply Submodule.map_injective_of_injective\n  rw [← LinearMap.ker_eq_bot]\n  apply eval_ker K V\n#align map_eval_injective map_eval_injective\n\n",
 "map_eval_equiv_symm_apply":
 "@[simp]\ntheorem map_eval_equiv_symm_apply [FiniteDimensional K V] (W'' : Subspace K (dual K (dual K V))) :\n    (map_eval_equiv K V).symm W'' = W''.comap (eval K V) :=\n  rfl\n#align map_eval_equiv_symm_apply map_eval_equiv_symm_apply\n\n",
 "map_eval_equiv_apply":
 "@[simp]\ntheorem map_eval_equiv_apply [FiniteDimensional K V] (W : Subspace K V) : map_eval_equiv K V W = W.map (eval K V) :=\n  rfl\n#align map_eval_equiv_apply map_eval_equiv_apply\n\n",
 "le_dual_coannihilator_dual_annihilator":
 "theorem le_dual_coannihilator_dual_annihilator (U : Submodule R (module.dual R M)) :\n    U ≤ U.dual_coannihilator.dual_annihilator :=\n  (dual_annihilator_gc R M).l_u_le U\n#align le_dual_coannihilator_dual_annihilator le_dual_coannihilator_dual_annihilator\n\n",
 "le_dual_annihilator_iff_le_dual_coannihilator":
 "theorem le_dual_annihilator_iff_le_dual_coannihilator {U : Submodule R (module.dual R M)} {V : Submodule R M} :\n    U ≤ V.dual_annihilator ↔ V ≤ U.dual_coannihilator :=\n  (dual_annihilator_gc R M).le_iff_le\n#align le_dual_annihilator_iff_le_dual_coannihilator le_dual_annihilator_iff_le_dual_coannihilator\n\n",
 "le_dual_annihilator_dual_coannihilator":
 "theorem le_dual_annihilator_dual_coannihilator (U : Submodule R M) : U ≤ U.dual_annihilator.dual_coannihilator :=\n  (dual_annihilator_gc R M).le_u_l U\n#align le_dual_annihilator_dual_coannihilator le_dual_annihilator_dual_coannihilator\n\n",
 "lc_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lc_def (e : ι → M) (l : «expr →₀ » ι R) : lc e l = Finsupp.total _ _ _ e l :=\n  rfl\n#align lc_def lc_def\n\n",
 "lc_coeffs":
 "/-- For any m : M n, \\sum_{p ∈ Q n} (ε p m) • e p = m -/\n@[simp]\ntheorem lc_coeffs (m : M) : dual_bases.lc e (h.coeffs m) = m :=\n  by\n  refine' eq_of_sub_eq_zero (h.total _)\n  intro i\n  simp [-sub_eq_add_neg, LinearMap.map_sub, h.dual_lc, sub_eq_zero]\n#align lc_coeffs lc_coeffs\n\n",
 "ker_dual_map_eq_dual_annihilator_range":
 "theorem ker_dual_map_eq_dual_annihilator_range : f.dual_map.ker = f.range.dual_annihilator :=\n  by\n  ext φ; constructor <;> intro hφ\n  · rw [mem_ker] at hφ\n    rw [submodule.mem_dual_annihilator]\n    rintro y ⟨x, rfl⟩\n    rw [← dual_map_apply, hφ, zero_apply]\n  · ext x\n    rw [dual_map_apply]\n    rw [submodule.mem_dual_annihilator] at hφ\n    exact hφ (f x) ⟨x, rfl⟩\n#align ker_dual_map_eq_dual_annihilator_range ker_dual_map_eq_dual_annihilator_range\n\n",
 "is_compl_dual_annihilator":
 "/-- For vector spaces, dual annihilators carry direct sum decompositions\nto direct sum decompositions. -/\ntheorem is_compl_dual_annihilator {W W' : Subspace K V₁} (h : IsCompl W W') :\n    IsCompl W.dual_annihilator W'.dual_annihilator :=\n  by\n  rw [isCompl_iff, disjoint_iff, codisjoint_iff] at h⊢\n  rw [← dual_annihilator_inf_eq, ← dual_annihilator_sup_eq, h.1, h.2, dual_annihilator_top, dual_annihilator_bot]\n  exact ⟨rfl, rfl⟩\n#align is_compl_dual_annihilator is_compl_dual_annihilator\n\n",
 "forall_mem_dual_annihilator_apply_eq_zero_iff":
 "-- exact elaborates slowly\ntheorem forall_mem_dual_annihilator_apply_eq_zero_iff (W : Subspace K V) (v : V) :\n    (∀ φ : module.dual K V, φ ∈ W.dual_annihilator → φ v = 0) ↔ v ∈ W := by\n  rw [← set_like.ext_iff.mp dual_annihilator_dual_coannihilator_eq v, mem_dual_coannihilator]\n#align forall_mem_dual_annihilator_apply_eq_zero_iff forall_mem_dual_annihilator_apply_eq_zero_iff\n\n",
 "forall_dual_apply_eq_zero_iff":
 "theorem forall_dual_apply_eq_zero_iff (v : V) : (∀ φ : module.dual K V, φ v = 0) ↔ v = 0 :=\n  by\n  rw [← eval_apply_eq_zero_iff K v, LinearMap.ext_iff]\n  rfl\n#align forall_dual_apply_eq_zero_iff forall_dual_apply_eq_zero_iff\n\n",
 "finrank_range_dual_map_eq_finrank_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- TODO(kmill) remove finite_dimensional if possible\n-- see https://github.com/leanprover-community/mathlib/pull/17521#discussion_r1083242551\n@[simp]\ntheorem finrank_range_dual_map_eq_finrank_range (f : «expr →ₗ[ ] » V₁ K V₂) :\n    finrank K f.dual_map.range = finrank K f.range :=\n  by\n  have := Submodule.finrank_quotient_add_finrank f.range\n  rw [(subspace.quot_equiv_annihilator f.range).finrank_eq, ← ker_dual_map_eq_dual_annihilator_range] at this\n  conv_rhs at this => rw [← subspace.dual_finrank_eq]\n  refine' add_left_injective (finrank K f.dual_map.ker) _\n  change _ + _ = _ + _\n  rw [finrank_range_add_finrank_ker f.dual_map, add_comm, this]\n#align finrank_range_dual_map_eq_finrank_range finrank_range_dual_map_eq_finrank_range\n\n",
 "finrank_dual_coannihilator_eq":
 "@[simp]\ntheorem finrank_dual_coannihilator_eq {Φ : Subspace K (module.dual K V)} :\n    finrank K Φ.dual_coannihilator = finrank K Φ.dual_annihilator :=\n  by\n  rw [submodule.dual_coannihilator, ← module.eval_equiv_to_linear_map]\n  exact LinearEquiv.finrank_eq (LinearEquiv.ofSubmodule' _ _)\n#align finrank_dual_coannihilator_eq finrank_dual_coannihilator_eq\n\n",
 "finrank_add_finrank_dual_coannihilator_eq":
 "theorem finrank_add_finrank_dual_coannihilator_eq (W : Subspace K (module.dual K V)) :\n    finrank K W + finrank K W.dual_coannihilator = finrank K V := by\n  rw [finrank_dual_coannihilator_eq, W.quot_equiv_annihilator.finrank_eq.symm, add_comm,\n    Submodule.finrank_quotient_add_finrank, subspace.dual_finrank_eq]\n#align finrank_add_finrank_dual_coannihilator_eq finrank_add_finrank_dual_coannihilator_eq\n\n",
 "eval_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eval_range {ι : Type _} [Finite ι] (b : Basis ι R M) : (eval R M).range = «expr⊤» := by\n  classical\n    cases nonempty_fintype ι\n    rw [← b.to_dual_to_dual, range_comp, b.to_dual_range, Submodule.map_top, to_dual_range _]\n    infer_instance\n#align eval_range eval_range\n\n",
 "eval_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eval_ker : (eval K V).ker = «expr⊥» := by classical exact (Basis.ofVectorSpace K V).eval_ker\n#align eval_ker eval_ker\n\n",
 "eval_equiv_to_linear_map":
 "-- 60x faster elaboration than using `ker_eq_bot.mp eval_ker` directly:\n@[simp]\ntheorem eval_equiv_to_linear_map [FiniteDimensional K V] : (eval_equiv K V).to_linear_map = dual.eval K V :=\n  rfl\n#align eval_equiv_to_linear_map eval_equiv_to_linear_map\n\n",
 "eval_apply_injective":
 "theorem eval_apply_injective : function.injective (eval K V) :=\n  (injective_iff_map_eq_zero' (eval K V)).mpr (eval_apply_eq_zero_iff K)\n#align eval_apply_injective eval_apply_injective\n\n",
 "eval_apply_eq_zero_iff":
 "-- elaborates faster than `exact`\ntheorem eval_apply_eq_zero_iff (v : V) : (eval K V) v = 0 ↔ v = 0 := by\n  simpa only using set_like.ext_iff.mp (eval_ker K V) v\n#align eval_apply_eq_zero_iff eval_apply_eq_zero_iff\n\n",
 "eval_apply":
 "@[simp]\ntheorem eval_apply (v : M) (a : dual R M) : eval R M v a = a v :=\n  rfl\n#align eval_apply eval_apply\n\n",
 "erange_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem erange_coe [FiniteDimensional K V] : (eval K V).range = «expr⊤» :=\n  letI : IsNoetherian K V := IsNoetherian.iff_fg.2 inferInstance\n  (Basis.ofVectorSpace K V).eval_range\n#align erange_coe erange_coe\n\n",
 "dual_restrict_surjective":
 "theorem dual_restrict_surjective : function.surjective W.dual_restrict :=\n  W.dual_lift_right_inverse.surjective\n#align dual_restrict_surjective dual_restrict_surjective\n\n",
 "dual_restrict_left_inverse":
 "theorem dual_restrict_left_inverse (W : Subspace K V) : function.left_inverse W.dual_restrict W.dual_lift := fun x =>\n  show W.dual_restrict.comp W.dual_lift x = x\n    by\n    rw [dual_restrict_comp_dual_lift]\n    rfl\n#align dual_restrict_left_inverse dual_restrict_left_inverse\n\n",
 "dual_restrict_ker_eq_dual_annihilator":
 "/-- That $\\operatorname{ker}(\\iota^* : V^* \\to W^*) = \\operatorname{ann}(W)$.\nThis is the definition of the dual annihilator of the submodule $W$. -/\ntheorem dual_restrict_ker_eq_dual_annihilator (W : Submodule R M) : W.dual_restrict.ker = W.dual_annihilator :=\n  rfl\n#align dual_restrict_ker_eq_dual_annihilator dual_restrict_ker_eq_dual_annihilator\n\n",
 "dual_restrict_def":
 "theorem dual_restrict_def (W : Submodule R M) : W.dual_restrict = W.subtype.dual_map :=\n  rfl\n#align dual_restrict_def dual_restrict_def\n\n",
 "dual_restrict_comp_dual_lift":
 "@[simp]\ntheorem dual_restrict_comp_dual_lift (W : Subspace K V) : W.dual_restrict.comp W.dual_lift = 1 :=\n  by\n  ext (φ x)\n  simp\n#align dual_restrict_comp_dual_lift dual_restrict_comp_dual_lift\n\n",
 "dual_restrict_apply":
 "@[simp]\ntheorem dual_restrict_apply (W : Submodule R M) (φ : module.dual R M) (x : W) : W.dual_restrict φ x = φ (x : M) :=\n  rfl\n#align dual_restrict_apply dual_restrict_apply\n\n",
 "dual_rank_eq":
 "-- TODO(jmc): generalize to rings, once `module.rank` is generalized\ntheorem dual_rank_eq [FiniteDimensional K V] : Cardinal.lift (Module.rank K V) = Module.rank K (dual K V) :=\n  (Basis.ofVectorSpace K V).dual_rank_eq\n#align dual_rank_eq dual_rank_eq\n\n",
 "dual_quot_equiv_dual_annihilator_symm_apply_mk":
 "@[simp]\ntheorem dual_quot_equiv_dual_annihilator_symm_apply_mk (W : Submodule R M) (φ : W.dual_annihilator) (x : M) :\n    (dual_quot_equiv_dual_annihilator W).symm φ (Quotient.mk x) = φ x :=\n  rfl\n#align dual_quot_equiv_dual_annihilator_symm_apply_mk dual_quot_equiv_dual_annihilator_symm_apply_mk\n\n",
 "dual_quot_equiv_dual_annihilator_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n@[simp]\ntheorem dual_quot_equiv_dual_annihilator_apply (W : Submodule R M) (φ : module.dual R («expr ⧸ » M W)) (x : M) :\n    dual_quot_equiv_dual_annihilator W φ x = φ (Quotient.mk x) :=\n  rfl\n#align dual_quot_equiv_dual_annihilator_apply dual_quot_equiv_dual_annihilator_apply\n\n",
 "dual_prod_dual_equiv_dual_apply":
 "@[simp]\ntheorem dual_prod_dual_equiv_dual_apply (φ : module.dual R M) (ψ : module.dual R M') :\n    dual_prod_dual_equiv_dual R M M' (φ, ψ) = φ.coprod ψ :=\n  rfl\n#align dual_prod_dual_equiv_dual_apply dual_prod_dual_equiv_dual_apply\n\n",
 "dual_pairing_nondegenerate":
 "theorem dual_pairing_nondegenerate (W : Subspace K V₁) : W.dual_pairing.nondegenerate :=\n  by\n  constructor\n  · rw [LinearMap.separatingLeft_iff_ker_eq_bot, dual_pairing_eq]\n    apply LinearEquiv.ker\n  · intro x h\n    rw [← forall_dual_apply_eq_zero_iff K x]\n    intro φ\n    simpa only [submodule.dual_pairing_apply, dual_lift_of_subtype] using h (Submodule.Quotient.mk (W.dual_lift φ))\n#align dual_pairing_nondegenerate dual_pairing_nondegenerate\n\n",
 "dual_pairing_eq":
 "theorem dual_pairing_eq (W : Subspace K V₁) : W.dual_pairing = W.quot_annihilator_equiv.to_linear_map :=\n  by\n  ext\n  rfl\n#align dual_pairing_eq dual_pairing_eq\n\n",
 "dual_map_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem linear_equiv.dual_map_trans {M₃ : Type _} [AddCommGroup M₃] [Module R M₃] (f : «expr ≃ₗ[ ] » M₁ R M₂)\n    (g : «expr ≃ₗ[ ] » M₂ R M₃) : g.dual_map.trans f.dual_map = (f.trans g).dual_map :=\n  rfl\n#align linear_equiv.dual_map_trans linear_equiv.dual_map_trans\n\n",
 "dual_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv.dual_map_symm {f : «expr ≃ₗ[ ] » M₁ R M₂} :\n    (linear_equiv.dual_map f).symm = linear_equiv.dual_map f.symm :=\n  rfl\n#align linear_equiv.dual_map_symm linear_equiv.dual_map_symm\n\n",
 "dual_map_surjective_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem dual_map_surjective_of_injective {f : «expr →ₗ[ ] » V₁ K V₂} (hf : function.injective f) :\n    function.surjective f.dual_map := by\n  intro φ\n  let f' := LinearEquiv.ofInjective f hf\n  use subspace.dual_lift (range f) (f'.symm.dual_map φ)\n  ext x\n  rw [linear_map.dual_map_apply, subspace.dual_lift_of_mem (mem_range_self f x), linear_equiv.dual_map_apply]\n  congr 1\n  exact LinearEquiv.symm_apply_apply f' x\n#align dual_map_surjective_of_injective dual_map_surjective_of_injective\n\n",
 "dual_map_surjective_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- For vector spaces, `f.dual_map` is surjective if and only if `f` is injective -/\n@[simp]\ntheorem dual_map_surjective_iff {f : «expr →ₗ[ ] » V₁ K V₂} : function.surjective f.dual_map ↔ function.injective f :=\n  by\n  rw [← LinearMap.range_eq_top, range_dual_map_eq_dual_annihilator_ker, ← submodule.dual_annihilator_bot,\n    subspace.dual_annihilator_inj, LinearMap.ker_eq_bot]\n#align dual_map_surjective_iff dual_map_surjective_iff\n\n",
 "dual_map_refl":
 "@[simp]\ntheorem linear_equiv.dual_map_refl : (LinearEquiv.refl R M₁).dual_map = LinearEquiv.refl R (dual R M₁) :=\n  by\n  ext\n  rfl\n#align linear_equiv.dual_map_refl linear_equiv.dual_map_refl\n\n",
 "dual_map_injective_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If a linear map is surjective, then its dual is injective. -/\ntheorem linear_map.dual_map_injective_of_surjective {f : «expr →ₗ[ ] » M₁ R M₂} (hf : function.surjective f) :\n    function.injective f.dual_map := by\n  intro φ ψ h\n  ext x\n  obtain ⟨y, rfl⟩ := hf x\n  exact congr_arg (fun g : module.dual R M₁ => g y) h\n#align linear_map.dual_map_injective_of_surjective linear_map.dual_map_injective_of_surjective\n\n",
 "dual_map_injective_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- `f.dual_map` is injective if and only if `f` is surjective -/\n@[simp]\ntheorem dual_map_injective_iff {f : «expr →ₗ[ ] » V₁ K V₂} : function.injective f.dual_map ↔ function.surjective f :=\n  by\n  refine' ⟨_, fun h => dual_map_injective_of_surjective h⟩\n  rw [← range_eq_top, ← ker_eq_bot]\n  intro h\n  apply FiniteDimensional.eq_top_of_finrank_eq\n  rw [← finrank_eq_zero] at h\n  rw [← add_zero (FiniteDimensional.finrank K f.range), ← h, ← linear_map.finrank_range_dual_map_eq_finrank_range,\n    LinearMap.finrank_range_add_finrank_ker, subspace.dual_finrank_eq]\n#align dual_map_injective_iff dual_map_injective_iff\n\n",
 "dual_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.dual_map_id : (LinearMap.id : «expr →ₗ[ ] » M₁ R M₁).dual_map = LinearMap.id :=\n  by\n  ext\n  rfl\n#align linear_map.dual_map_id linear_map.dual_map_id\n\n",
 "dual_map_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.dual_map_def (f : «expr →ₗ[ ] » M₁ R M₂) : f.dual_map = module.dual.transpose f :=\n  rfl\n#align linear_map.dual_map_def linear_map.dual_map_def\n\n",
 "dual_map_comp_dual_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.dual_map_comp_dual_map {M₃ : Type _} [AddCommGroup M₃] [Module R M₃] (f : «expr →ₗ[ ] » M₁ R M₂)\n    (g : «expr →ₗ[ ] » M₂ R M₃) : f.dual_map.comp g.dual_map = (g.comp f).dual_map :=\n  rfl\n#align linear_map.dual_map_comp_dual_map linear_map.dual_map_comp_dual_map\n\n",
 "dual_map_bijective_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- `f.dual_map` is bijective if and only if `f` is -/\n@[simp]\ntheorem dual_map_bijective_iff {f : «expr →ₗ[ ] » V₁ K V₂} : function.bijective f.dual_map ↔ function.bijective f := by\n  simp_rw [function.bijective, dual_map_surjective_iff, dual_map_injective_iff, and_comm]\n#align dual_map_bijective_iff dual_map_bijective_iff\n\n",
 "dual_map_apply'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.dual_map_apply' (f : «expr →ₗ[ ] » M₁ R M₂) (g : dual R M₂) : f.dual_map g = g.comp f :=\n  rfl\n#align linear_map.dual_map_apply' linear_map.dual_map_apply'\n\n",
 "dual_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv.dual_map_apply (f : «expr ≃ₗ[ ] » M₁ R M₂) (g : dual R M₂) (x : M₁) : f.dual_map g x = g (f x) :=\n  rfl\n#align linear_equiv.dual_map_apply linear_equiv.dual_map_apply\n\n",
 "dual_lift_right_inverse":
 "theorem dual_lift_right_inverse (W : Subspace K V) : function.right_inverse W.dual_lift W.dual_restrict :=\n  W.dual_restrict_left_inverse\n#align dual_lift_right_inverse dual_lift_right_inverse\n\n",
 "dual_lift_of_subtype":
 "@[simp]\ntheorem dual_lift_of_subtype {φ : module.dual K W} (w : W) : W.dual_lift φ (w : V) = φ w :=\n  by\n  erw [of_is_compl_left_apply _ w]\n  rfl\n#align dual_lift_of_subtype dual_lift_of_subtype\n\n",
 "dual_lift_of_mem":
 "theorem dual_lift_of_mem {φ : module.dual K W} {w : V} (hw : w ∈ W) : W.dual_lift φ w = φ ⟨w, hw⟩ := by\n  convert dual_lift_of_subtype ⟨w, hw⟩\n#align dual_lift_of_mem dual_lift_of_mem\n\n",
 "dual_lift_injective":
 "theorem dual_lift_injective : function.injective W.dual_lift :=\n  W.dual_restrict_left_inverse.injective\n#align dual_lift_injective dual_lift_injective\n\n",
 "dual_lc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem dual_lc (l : «expr →₀ » ι R) (i : ι) : ε i (dual_bases.lc e l) = l i :=\n  by\n  erw [LinearMap.map_sum]\n  simp only [h.eval, map_smul, smul_eq_mul]\n  rw [Finset.sum_eq_single i]\n  · simp\n  · intro q q_in q_ne\n    simp [q_ne.symm]\n  · intro p_not_in\n    simp [Finsupp.not_mem_support_iff.1 p_not_in]\n#align dual_lc dual_lc\n\n",
 "dual_finrank_eq":
 "-- TODO(kmill): https://github.com/leanprover-community/mathlib/pull/17521#discussion_r1083241963\n@[simp]\ntheorem dual_finrank_eq : finrank K (module.dual K V) = finrank K V :=\n  LinearEquiv.finrank_eq (Basis.ofVectorSpace K V).to_dual_equiv.symm\n#align dual_finrank_eq dual_finrank_eq\n\n",
 "dual_equiv_dual_def":
 "theorem dual_equiv_dual_def (W : Subspace K V) : W.dual_equiv_dual.to_linear_map = W.dual_lift.range_restrict :=\n  rfl\n#align dual_equiv_dual_def dual_equiv_dual_def\n\n",
 "dual_equiv_dual_apply":
 "@[simp]\ntheorem dual_equiv_dual_apply (φ : module.dual K W) : W.dual_equiv_dual φ = ⟨W.dual_lift φ, mem_range.2 ⟨φ, rfl⟩⟩ :=\n  rfl\n#align dual_equiv_dual_apply dual_equiv_dual_apply\n\n",
 "dual_distrib_inv_of_basis_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n@[simp]\ntheorem dual_distrib_inv_of_basis_apply (b : Basis ι R M) (c : Basis κ R N) (f : dual R (tensor_product M R N)) :\n    dual_distrib_inv_of_basis b c f =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f («expr ⊗ₜ » (b i) (c j))) («expr ⊗ₜ » (b.dual_basis i) (c.dual_basis j))) :=\n  by simp [dual_distrib_inv_of_basis]\n#align dual_distrib_inv_of_basis_apply dual_distrib_inv_of_basis_apply\n\n",
 "dual_distrib_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n@[simp]\ntheorem dual_distrib_apply (f : dual R M) (g : dual R N) (m : M) (n : N) :\n    dual_distrib R M N («expr ⊗ₜ » f g) («expr ⊗ₜ » m n) = f m * g n :=\n  rfl\n#align dual_distrib_apply dual_distrib_apply\n\n",
 "dual_copairing_nondegenerate":
 "theorem dual_copairing_nondegenerate (W : Subspace K V₁) : W.dual_copairing.nondegenerate :=\n  by\n  constructor\n  · rw [LinearMap.separatingLeft_iff_ker_eq_bot, dual_copairing_eq]\n    apply LinearEquiv.ker\n  · rintro ⟨x⟩\n    simp only [quotient.quot_mk_eq_mk, dual_copairing_apply, quotient.mk_eq_zero]\n    rw [← forall_mem_dual_annihilator_apply_eq_zero_iff, SetLike.forall]\n    exact id\n#align dual_copairing_nondegenerate dual_copairing_nondegenerate\n\n",
 "dual_copairing_eq":
 "theorem dual_copairing_eq (W : Submodule R M) :\n    W.dual_copairing = (dual_quot_equiv_dual_annihilator W).symm.to_linear_map :=\n  rfl\n#align dual_copairing_eq dual_copairing_eq\n\n",
 "dual_copairing_apply":
 "@[simp]\ntheorem dual_copairing_apply {W : Submodule R M} (φ : W.dual_annihilator) (x : M) :\n    W.dual_copairing φ (Quotient.mk x) = φ x :=\n  rfl\n#align dual_copairing_apply dual_copairing_apply\n\n",
 "dual_coannihilator_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- We work in vector spaces because `exists_is_compl` only hold for vector spaces\n@[simp]\ntheorem dual_coannihilator_top (W : Subspace K V) :\n    («expr⊤» : Subspace K (module.dual K W)).dual_coannihilator = «expr⊥» := by\n  rw [dual_coannihilator, dual_annihilator_top, comap_bot, module.eval_ker]\n#align dual_coannihilator_top dual_coannihilator_top\n\n",
 "dual_coannihilator_supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem dual_coannihilator_supr_eq {ι : Type _} (U : ι → Submodule R (module.dual R M)) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (U i)).dual_coannihilator =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (U i).dual_coannihilator :=\n  (dual_annihilator_gc R M).u_infi\n#align dual_coannihilator_supr_eq dual_coannihilator_supr_eq\n\n",
 "dual_coannihilator_sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem dual_coannihilator_sup_eq (U V : Submodule R (module.dual R M)) :\n    («expr ⊔ » U V).dual_coannihilator = «expr ⊓ » U.dual_coannihilator V.dual_coannihilator :=\n  (dual_annihilator_gc R M).u_inf\n#align dual_coannihilator_sup_eq dual_coannihilator_sup_eq\n\n",
 "dual_coannihilator_dual_annihilator_dual_coannihilator":
 "theorem dual_coannihilator_dual_annihilator_dual_coannihilator (U : Submodule R (module.dual R M)) :\n    U.dual_coannihilator.dual_annihilator.dual_coannihilator = U.dual_coannihilator :=\n  (dual_annihilator_gc R M).u_l_u_eq_u U\n#align dual_coannihilator_dual_annihilator_dual_coannihilator dual_coannihilator_dual_annihilator_dual_coannihilator\n\n",
 "dual_coannihilator_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem dual_coannihilator_bot : («expr⊥» : Submodule R (module.dual R M)).dual_coannihilator = «expr⊤» :=\n  (dual_annihilator_gc R M).u_top\n#align dual_coannihilator_bot dual_coannihilator_bot\n\n",
 "dual_coannihilator_anti":
 "@[mono]\ntheorem dual_coannihilator_anti {U V : Submodule R (module.dual R M)} (hUV : U ≤ V) :\n    V.dual_coannihilator ≤ U.dual_coannihilator :=\n  (dual_annihilator_gc R M).monotone_u hUV\n#align dual_coannihilator_anti dual_coannihilator_anti\n\n",
 "dual_basis_repr":
 "theorem dual_basis_repr (l : dual R M) (i : ι) : b.dual_basis.repr l i = l (b i) := by\n  rw [← total_dual_basis b, Basis.total_repr b.dual_basis l]\n#align dual_basis_repr dual_basis_repr\n\n",
 "dual_basis_equiv_fun":
 "theorem dual_basis_equiv_fun [Fintype ι] (l : dual R M) (i : ι) : b.dual_basis.equiv_fun l i = l (b i) := by\n  rw [Basis.equivFun_apply, dual_basis_repr]\n#align dual_basis_equiv_fun dual_basis_equiv_fun\n\n",
 "dual_basis_apply_self":
 "-- We use `j = i` to match `basis.repr_self`\ntheorem dual_basis_apply_self (i j : ι) : b.dual_basis i (b j) = if j = i then 1 else 0 :=\n  by\n  convert b.to_dual_apply i j using 2\n  rw [@eq_comm _ j i]\n#align dual_basis_apply_self dual_basis_apply_self\n\n",
 "dual_basis_apply":
 "theorem dual_basis_apply (i : ι) (m : M) : b.dual_basis i m = b.repr m i :=\n  b.to_dual_apply_right i m\n#align dual_basis_apply dual_basis_apply\n\n",
 "dual_annihilator_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem dual_annihilator_top : («expr⊤» : Submodule R M).dual_annihilator = «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  intro v\n  simp_rw [mem_dual_annihilator, mem_bot, mem_top, forall_true_left]\n  exact fun h => LinearMap.ext h\n#align dual_annihilator_top dual_annihilator_top\n\n",
 "dual_annihilator_supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem dual_annihilator_supr_eq {ι : Type _} (U : ι → Submodule R M) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (U i)).dual_annihilator =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (U i).dual_annihilator :=\n  (dual_annihilator_gc R M).l_supr\n#align dual_annihilator_supr_eq dual_annihilator_supr_eq\n\n",
 "dual_annihilator_sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem dual_annihilator_sup_eq (U V : Submodule R M) :\n    («expr ⊔ » U V).dual_annihilator = «expr ⊓ » U.dual_annihilator V.dual_annihilator :=\n  (dual_annihilator_gc R M).l_sup\n#align dual_annihilator_sup_eq dual_annihilator_sup_eq\n\n",
 "dual_annihilator_le_dual_annihilator_iff":
 "theorem dual_annihilator_le_dual_annihilator_iff {W W' : Subspace K V} :\n    W.dual_annihilator ≤ W'.dual_annihilator ↔ W' ≤ W :=\n  (dual_annihilator_gci K V).l_le_l_iff\n#align dual_annihilator_le_dual_annihilator_iff dual_annihilator_le_dual_annihilator_iff\n\n",
 "dual_annihilator_inj":
 "theorem dual_annihilator_inj {W W' : Subspace K V} : W.dual_annihilator = W'.dual_annihilator ↔ W = W' :=\n  by\n  constructor\n  · apply (dual_annihilator_gci K V).l_injective\n  · rintro rfl\n    rfl\n#align dual_annihilator_inj dual_annihilator_inj\n\n",
 "dual_annihilator_infi_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n-- This is also true if `V₁` is finite dimensional since one can restrict `ι` to some subtype\n-- for which the infi and supr are the same.\n--\n-- The obstruction to the `dual_annihilator_inf_eq` argument carrying through is that we need\n-- for `module.dual R (Π (i : ι), V ⧸ W i) ≃ₗ[K] Π (i : ι), module.dual R (V ⧸ W i)`, which is not\n-- true for infinite `ι`. One would need to add additional hypothesis on `W` (for example, it might\n-- be true when the family is inf-closed).\ntheorem dual_annihilator_infi_eq {ι : Type _} [Finite ι] (W : ι → Subspace K V₁) :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (W i)).dual_annihilator =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (W i).dual_annihilator :=\n  by\n  revert ι\n  refine' Finite.induction_empty_option _ _ _\n  · intro α β h hyp W\n    rw [← h.infi_comp, hyp (W ∘ h), ← h.supr_comp]\n  · intro W\n    rw [supᵢ_of_empty', infᵢ_of_empty', infₛ_empty, supₛ_empty, dual_annihilator_top]\n  · intro α _ h W\n    rw [infᵢ_option, supᵢ_option, dual_annihilator_inf_eq, h]\n#align dual_annihilator_infi_eq dual_annihilator_infi_eq\n\n",
 "dual_annihilator_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n-- Argument from https://math.stackexchange.com/a/2423263/172988\ntheorem dual_annihilator_inf_eq (W W' : Subspace K V₁) :\n    («expr ⊓ » W W').dual_annihilator = «expr ⊔ » W.dual_annihilator W'.dual_annihilator :=\n  by\n  refine' le_antisymm _ (sup_dual_annihilator_le_inf W W')\n  let F : «expr →ₗ[ ] » V₁ K («expr ⧸ » V₁ W × «expr ⧸ » V₁ W') := (Submodule.mkQ W).prod (Submodule.mkQ W')\n  have : F.ker = «expr ⊓ » W W' := by simp only [LinearMap.ker_prod, ker_mkq]\n  rw [← this, ← linear_map.range_dual_map_eq_dual_annihilator_ker]\n  intro φ\n  rw [LinearMap.mem_range]\n  rintro ⟨x, rfl⟩\n  rw [Submodule.mem_sup]\n  obtain ⟨⟨a, b⟩, rfl⟩ := (dual_prod_dual_equiv_dual K («expr ⧸ » V₁ W) («expr ⧸ » V₁ W')).surjective x\n  obtain ⟨a', rfl⟩ := (dual_quot_equiv_dual_annihilator W).symm.surjective a\n  obtain ⟨b', rfl⟩ := (dual_quot_equiv_dual_annihilator W').symm.surjective b\n  use a', a'.property, b', b'.property\n  rfl\n#align dual_annihilator_inf_eq dual_annihilator_inf_eq\n\n",
 "dual_annihilator_gc":
 "theorem dual_annihilator_gc (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M] :\n    GaloisConnection (OrderDual.toDual ∘ (dual_annihilator : Submodule R M → Submodule R (module.dual R M)))\n      (dual_coannihilator ∘ OrderDual.ofDual) :=\n  by\n  intro a b\n  induction b using OrderDual.rec\n  simp only [Function.comp_apply, OrderDual.toDual_le_toDual, OrderDual.ofDual_toDual]\n  constructor <;>\n    · intro h x hx\n      simp only [mem_dual_annihilator, mem_dual_coannihilator]\n      intro y hy\n      have := h hy\n      simp only [mem_dual_annihilator, mem_dual_coannihilator] at this\n      exact this x hx\n#align dual_annihilator_gc dual_annihilator_gc\n\n",
 "dual_annihilator_dual_coannihilator_eq":
 "theorem dual_annihilator_dual_coannihilator_eq {W : Subspace K V} : W.dual_annihilator.dual_coannihilator = W :=\n  by\n  refine' le_antisymm _ (le_dual_annihilator_dual_coannihilator _)\n  intro v\n  simp only [mem_dual_annihilator, mem_dual_coannihilator]\n  contrapose!\n  intro hv\n  obtain ⟨W', hW⟩ := Submodule.exists_isCompl W\n  obtain ⟨⟨w, w'⟩, rfl, -⟩ := exists_unique_add_of_is_compl_prod hW v\n  have hw'n : (w' : V) ∉ W := by\n    contrapose! hv\n    exact Submodule.add_mem W w.2 hv\n  have hw'nz : w' ≠ 0 := by\n    rintro rfl\n    exact hw'n (Submodule.zero_mem W)\n  rw [ne.def, ← module.forall_dual_apply_eq_zero_iff K w'] at hw'nz\n  push_neg  at hw'nz\n  obtain ⟨φ, hφ⟩ := hw'nz\n  exists ((LinearMap.ofIsComplProd hW).comp (LinearMap.inr _ _ _)) φ\n  simp only [coe_comp, coe_inr, Function.comp_apply, of_is_compl_prod_apply, map_add, of_is_compl_left_apply,\n    zero_apply, of_is_compl_right_apply, zero_add, ne.def]\n  refine' ⟨_, hφ⟩\n  intro v hv\n  apply LinearMap.ofIsCompl_left_apply hW ⟨v, hv⟩\n#align dual_annihilator_dual_coannihilator_eq dual_annihilator_dual_coannihilator_eq\n\n",
 "dual_annihilator_dual_coannihilator_dual_annihilator":
 "theorem dual_annihilator_dual_coannihilator_dual_annihilator (U : Submodule R M) :\n    U.dual_annihilator.dual_coannihilator.dual_annihilator = U.dual_annihilator :=\n  (dual_annihilator_gc R M).l_u_l_eq_l U\n#align dual_annihilator_dual_coannihilator_dual_annihilator dual_annihilator_dual_coannihilator_dual_annihilator\n\n",
 "dual_annihilator_dual_annihilator_eq":
 "theorem dual_annihilator_dual_annihilator_eq (W : Subspace K V) :\n    W.dual_annihilator.dual_annihilator = module.map_eval_equiv K V W :=\n  by\n  have : _ = W := subspace.dual_annihilator_dual_coannihilator_eq\n  rw [dual_coannihilator, ← module.map_eval_equiv_symm_apply] at this\n  rwa [← OrderIso.symm_apply_eq]\n#align dual_annihilator_dual_annihilator_eq dual_annihilator_dual_annihilator_eq\n\n",
 "dual_annihilator_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem dual_annihilator_bot : («expr⊥» : Submodule R M).dual_annihilator = «expr⊤» :=\n  (dual_annihilator_gc R M).l_bot\n#align dual_annihilator_bot dual_annihilator_bot\n\n",
 "dual_annihilator_anti":
 "@[mono]\ntheorem dual_annihilator_anti {U V : Submodule R M} (hUV : U ≤ V) : V.dual_annihilator ≤ U.dual_annihilator :=\n  (dual_annihilator_gc R M).monotone_l hUV\n#align dual_annihilator_anti dual_annihilator_anti\n\n",
 "comap_eval_surjective":
 "-- elaborates faster than `exact`\ntheorem comap_eval_surjective : (Submodule.comap (eval K V)).surjective :=\n  by\n  apply Submodule.comap_surjective_of_injective\n  rw [← LinearMap.ker_eq_bot]\n  apply eval_ker K V\n#align comap_eval_surjective comap_eval_surjective\n\n",
 "coeffs_lc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeffs_lc (l : «expr →₀ » ι R) : h.coeffs (dual_bases.lc e l) = l :=\n  by\n  ext i\n  rw [h.coeffs_apply, h.dual_lc]\n#align coeffs_lc coeffs_lc\n\n",
 "coeffs_apply":
 "-- TODO: In Lean 4 we can remove this and use `by { intros; exact Set.toFinite _ }` as a default\n-- argument.\n@[simp]\ntheorem coeffs_apply [DecidableEq ι] (h : dual_bases e ε) (m : M) (i : ι) : h.coeffs m i = ε i m :=\n  rfl\n#align coeffs_apply coeffs_apply\n\n",
 "coe_to_dual_self":
 "theorem coe_to_dual_self (i : ι) : b.to_dual (b i) = b.coord i :=\n  by\n  ext\n  apply to_dual_apply_right\n#align coe_to_dual_self coe_to_dual_self\n\n",
 "coe_dual_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_dual_basis [Fintype ι] : «expr⇑ » h.basis.dual_basis = ε :=\n  funext fun i =>\n    h.basis.ext fun j => by rw [h.basis.dual_basis_apply_self, h.coe_basis, h.eval, if_congr eq_comm rfl rfl]\n#align coe_dual_basis coe_dual_basis\n\n",
 "coe_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_basis : «expr⇑ » h.basis = e := by\n  ext i\n  rw [Basis.apply_eq_iff]\n  ext j\n  rw [h.basis_repr_apply, coeffs_apply, h.eval, Finsupp.single_apply]\n  convert if_congr eq_comm rfl rfl\n#align coe_basis coe_basis\n\n"}