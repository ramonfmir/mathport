{"transpose_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem transpose_comp (u : «expr →ₗ[ ] » M' R M'') (v : «expr →ₗ[ ] » M R M') :\n    transpose (u.comp v) = (transpose v).comp (transpose u) :=\n  rfl\n#align transpose_comp transpose_comp\n\n",
 "transpose_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem transpose_apply (u : «expr →ₗ[ ] » M R M') (l : dual R M') : transpose u l = l.comp u :=\n  rfl\n#align transpose_apply transpose_apply\n\n",
 "total_dual_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem total_dual_basis (f : «expr →₀ » ι R) (i : ι) : finsupp.total ι (dual R M) R b.dual_basis f (b i) = f i :=\n  by\n  cases nonempty_fintype ι\n  rw [finsupp.total_apply, finsupp.sum_fintype, linear_map.sum_apply]\n  ·\n    simp_rw [linear_map.smul_apply, smul_eq_mul, dual_basis_apply_self, mul_boole, finset.sum_ite_eq,\n      if_pos (finset.mem_univ i)]\n  · intro\n    rw [zero_smul]\n#align total_dual_basis total_dual_basis\n\n",
 "total_coord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- `simp` normal form version of `total_dual_basis` -/\n@[simp]\ntheorem total_coord [CommRing R] [add_comm_group M] [Module R M] [Finite ι] (b : basis ι R M) (f : «expr →₀ » ι R)\n    (i : ι) : finsupp.total ι (dual R M) R b.coord f (b i) = f i :=\n  by\n  haveI := classical.dec_eq ι\n  rw [← coe_dual_basis, total_dual_basis]\n#align total_coord total_coord\n\n",
 "to_dual_total_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem to_dual_total_right (f : «expr →₀ » ι R) (i : ι) : b.to_dual (b i) (finsupp.total ι M R b f) = f i :=\n  by\n  rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum]\n  simp_rw [linear_map.map_smul, to_dual_apply, smul_eq_mul, mul_boole, finset.sum_ite_eq]\n  split_ifs with h\n  · rfl\n  · rw [finsupp.not_mem_support_iff.mp h]\n#align to_dual_total_right to_dual_total_right\n\n",
 "to_dual_total_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem to_dual_total_left (f : «expr →₀ » ι R) (i : ι) : b.to_dual (finsupp.total ι M R b f) (b i) = f i :=\n  by\n  rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum, linear_map.sum_apply]\n  simp_rw [linear_map.map_smul, linear_map.smul_apply, to_dual_apply, smul_eq_mul, mul_boole, finset.sum_ite_eq']\n  split_ifs with h\n  · rfl\n  · rw [finsupp.not_mem_support_iff.mp h]\n#align to_dual_total_left to_dual_total_left\n\n",
 "to_dual_to_dual":
 "@[simp]\ntheorem to_dual_to_dual : b.dual_basis.to_dual.comp b.to_dual = dual.eval R M :=\n  by\n  refine' b.ext fun i => b.dual_basis.ext fun j => _\n  rw [linear_map.comp_apply, to_dual_apply_left, coe_to_dual_self, ← coe_dual_basis, dual.eval_apply, basis.repr_self,\n    finsupp.single_apply, dual_basis_apply_self]\n#align to_dual_to_dual to_dual_to_dual\n\n",
 "to_dual_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_dual_range [Finite ι] : b.to_dual.range = «expr⊤» :=\n  by\n  cases nonempty_fintype ι\n  refine' eq_top_iff'.2 fun f => _\n  rw [linear_map.mem_range]\n  let lin_comb : «expr →₀ » ι R := finsupp.equiv_fun_on_finite.symm fun i => f.to_fun (b i)\n  refine' ⟨finsupp.total ι M R b lin_comb, b.ext fun i => _⟩\n  rw [b.to_dual_eq_repr _ i, repr_total b]\n  rfl\n#align to_dual_range to_dual_range\n\n",
 "to_dual_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem to_dual_ker : b.to_dual.ker = «expr⊥» :=\n  ker_eq_bot'.mpr b.to_dual_inj\n#align to_dual_ker to_dual_ker\n\n",
 "to_dual_inj":
 "theorem to_dual_inj (m : M) (a : b.to_dual m = 0) : m = 0 :=\n  by\n  rw [← mem_bot R, ← b.repr.ker, mem_ker, linear_equiv.coe_coe]\n  apply finsupp.ext\n  intro b\n  rw [← to_dual_eq_repr, a]\n  rfl\n#align to_dual_inj to_dual_inj\n\n",
 "to_dual_flip_apply":
 "theorem to_dual_flip_apply (m₁ m₂ : M) : b.to_dual_flip m₁ m₂ = b.to_dual m₂ m₁ :=\n  rfl\n#align to_dual_flip_apply to_dual_flip_apply\n\n",
 "to_dual_eq_repr":
 "theorem to_dual_eq_repr (m : M) (i : ι) : b.to_dual m (b i) = b.repr m i :=\n  b.to_dual_apply_left m i\n#align to_dual_eq_repr to_dual_eq_repr\n\n",
 "to_dual_eq_equiv_fun":
 "theorem to_dual_eq_equiv_fun [fintype ι] (m : M) (i : ι) : b.to_dual m (b i) = b.equiv_fun m i := by\n  rw [b.equiv_fun_apply, to_dual_eq_repr]\n#align to_dual_eq_equiv_fun to_dual_eq_equiv_fun\n\n",
 "to_dual_apply_right":
 "theorem to_dual_apply_right (i : ι) (m : M) : b.to_dual (b i) m = b.repr m i := by\n  rw [← b.to_dual_total_right, b.total_repr]\n#align to_dual_apply_right to_dual_apply_right\n\n",
 "to_dual_apply_left":
 "theorem to_dual_apply_left (m : M) (i : ι) : b.to_dual m (b i) = b.repr m i := by\n  rw [← b.to_dual_total_left, b.total_repr]\n#align to_dual_apply_left to_dual_apply_left\n\n",
 "to_dual_apply":
 "theorem to_dual_apply (i j : ι) : b.to_dual (b i) (b j) = if i = j then 1 else 0 :=\n  by\n  erw [constr_basis b, constr_basis b]\n  ac_rfl\n#align to_dual_apply to_dual_apply\n\n",
 "supr_dual_annihilator_le_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n-- TODO: when `M` is finite-dimensional this is an equality\ntheorem supr_dual_annihilator_le_infi {ι : Type _} (U : ι → submodule R M) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (U i).dual_annihilator ≤\n      («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          (U i)).dual_annihilator :=\n  by\n  classical\n    intro φ\n    simp_rw [mem_dual_annihilator, submodule.mem_supr_iff_exists_dfinsupp', mem_infi]\n    rintro ⟨f, rfl⟩ x hx\n    rw [linear_map.dfinsupp_sum_apply]\n    trans f.sum fun (i : ι) (d : (U i).dual_annihilator) => (0 : R)\n    · congr\n      ext (i⟨d, hd⟩)\n      rw [mem_dual_annihilator] at hd\n      exact hd x (hx _)\n    · exact @dfinsupp.sum_zero ι _ (fun i => (U i).dual_annihilator) _ _ _ _ f\n#align supr_dual_annihilator_le_infi supr_dual_annihilator_le_infi\n\n",
 "sup_dual_annihilator_le_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n-- TODO: when `M` is finite-dimensional this is an equality\ntheorem sup_dual_annihilator_le_inf (U V : submodule R M) :\n    «expr ⊔ » U.dual_annihilator V.dual_annihilator ≤ («expr ⊓ » U V).dual_annihilator :=\n  by\n  intro φ\n  simp_rw [mem_sup, mem_dual_annihilator, mem_inf]\n  rintro ⟨ψ, hψ, ψ', hψ', rfl⟩ v ⟨hU, hV⟩\n  rw [linear_map.add_apply, hψ _ hU, hψ' _ hV, zero_add]\n#align sup_dual_annihilator_le_inf sup_dual_annihilator_le_inf\n\n",
 "sum_dual_apply_smul_coord":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem sum_dual_apply_smul_coord (f : module.dual R M) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f (b x)) (b.coord x)) =\n      f :=\n  by\n  ext m\n  simp_rw [linear_map.sum_apply, linear_map.smul_apply, smul_eq_mul, mul_comm (f _), ← smul_eq_mul, ← f.map_smul, ←\n    f.map_sum, basis.coord_apply, basis.sum_repr]\n#align sum_dual_apply_smul_coord sum_dual_apply_smul_coord\n\n",
 "range_dual_map_le_dual_annihilator_ker":
 "theorem range_dual_map_le_dual_annihilator_ker : f.dual_map.range ≤ f.ker.dual_annihilator :=\n  by\n  rintro _ ⟨ψ, rfl⟩\n  simp_rw [submodule.mem_dual_annihilator, mem_ker]\n  rintro x hx\n  rw [dual_map_apply, hx, map_zero]\n#align range_dual_map_le_dual_annihilator_ker range_dual_map_le_dual_annihilator_ker\n\n",
 "range_dual_map_eq_dual_annihilator_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem range_dual_map_eq_dual_annihilator_ker [finite_dimensional K V₁] (f : «expr →ₗ[ ] » V₁ K V₂) :\n    f.dual_map.range = f.ker.dual_annihilator :=\n  by\n  refine' eq_of_le_of_finrank_eq f.range_dual_map_le_dual_annihilator_ker _\n  have := submodule.finrank_quotient_add_finrank f.ker\n  rw [(subspace.quot_equiv_annihilator f.ker).finrank_eq] at this\n  refine' add_left_injective (finrank K f.ker) _\n  simp_rw [this, finrank_range_dual_map_eq_finrank_range]\n  exact finrank_range_add_finrank_ker f\n#align range_dual_map_eq_dual_annihilator_ker range_dual_map_eq_dual_annihilator_ker\n\n",
 "mem_of_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- `convert` to get rid of a `decidable_eq` mismatch\ntheorem mem_of_mem_span {H : set ι} {x : M} (hmem : x ∈ submodule.span R («expr '' » e H)) :\n    ∀ i : ι, ε i x ≠ 0 → i ∈ H := by\n  intro i hi\n  rcases(finsupp.mem_span_image_iff_total _).mp hmem with ⟨l, supp_l, rfl⟩\n  apply not_imp_comm.mp ((finsupp.mem_supported' _ _).mp supp_l i)\n  rwa [← lc_def, h.dual_lc] at hi\n#align mem_of_mem_span mem_of_mem_span\n\n",
 "mem_dual_annihilator_comap":
 "theorem mem_dual_annihilator_comap {Φ : submodule R (module.dual R M)} (x : M) :\n    x ∈ Φ.dual_annihilator_comap ↔ ∀ φ ∈ Φ, (φ x : R) = 0 := by\n  simp_rw [dual_annihilator_comap, mem_comap, mem_dual_annihilator, module.dual.eval_apply]\n#align mem_dual_annihilator_comap mem_dual_annihilator_comap\n\n",
 "mem_dual_annihilator":
 "@[simp]\ntheorem mem_dual_annihilator (φ : module.dual R M) : φ ∈ W.dual_annihilator ↔ ∀ w ∈ W, φ w = 0 :=\n  by\n  refine' linear_map.mem_ker.trans _\n  simp_rw [linear_map.ext_iff, dual_restrict_apply]\n  exact ⟨fun h w hw => h ⟨w, hw⟩, fun h w => h w.1 w.2⟩\n#align mem_dual_annihilator mem_dual_annihilator\n\n",
 "le_dual_annihilator_dual_annihilator_comap":
 "theorem le_dual_annihilator_dual_annihilator_comap {U : submodule R M} :\n    U ≤ U.dual_annihilator.dual_annihilator_comap := by\n  intro v\n  simp_rw [mem_dual_annihilator_comap, mem_dual_annihilator]\n  intro hv φ h\n  exact h _ hv\n#align le_dual_annihilator_dual_annihilator_comap le_dual_annihilator_dual_annihilator_comap\n\n",
 "le_dual_annihilator_comap_dual_annihilator":
 "theorem le_dual_annihilator_comap_dual_annihilator {U : submodule R (module.dual R M)} :\n    U ≤ U.dual_annihilator_comap.dual_annihilator := by\n  intro v\n  simp_rw [mem_dual_annihilator, mem_dual_annihilator_comap]\n  intro hv φ h\n  exact h _ hv\n#align le_dual_annihilator_comap_dual_annihilator le_dual_annihilator_comap_dual_annihilator\n\n",
 "lc_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem lc_def (e : ι → M) (l : «expr →₀ » ι R) : lc e l = finsupp.total _ _ _ e l :=\n  rfl\n#align lc_def lc_def\n\n",
 "lc_coeffs":
 "/-- For any m : M n, \\sum_{p ∈ Q n} (ε p m) • e p = m -/\n@[simp]\ntheorem lc_coeffs (m : M) : dual_bases.lc e (h.coeffs m) = m :=\n  by\n  refine' eq_of_sub_eq_zero (h.total _)\n  intro i\n  simp [-sub_eq_add_neg, linear_map.map_sub, h.dual_lc, sub_eq_zero]\n#align lc_coeffs lc_coeffs\n\n",
 "ker_dual_map_eq_dual_annihilator_range":
 "theorem ker_dual_map_eq_dual_annihilator_range : f.dual_map.ker = f.range.dual_annihilator :=\n  by\n  ext φ; constructor <;> intro hφ\n  · rw [mem_ker] at hφ\n    rw [submodule.mem_dual_annihilator]\n    rintro y ⟨x, rfl⟩\n    rw [← dual_map_apply, hφ, zero_apply]\n  · ext x\n    rw [dual_map_apply]\n    rw [submodule.mem_dual_annihilator] at hφ\n    exact hφ (f x) ⟨x, rfl⟩\n#align ker_dual_map_eq_dual_annihilator_range ker_dual_map_eq_dual_annihilator_range\n\n",
 "forall_dual_apply_eq_zero_iff":
 "theorem forall_dual_apply_eq_zero_iff (v : V) : (∀ φ : module.dual K V, φ v = 0) ↔ v = 0 :=\n  by\n  rw [← eval_apply_eq_zero_iff K v, linear_map.ext_iff]\n  rfl\n#align forall_dual_apply_eq_zero_iff forall_dual_apply_eq_zero_iff\n\n",
 "finrank_range_dual_map_eq_finrank_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem finrank_range_dual_map_eq_finrank_range (f : «expr →ₗ[ ] » V₁ K V₂) :\n    finrank K f.dual_map.range = finrank K f.range :=\n  by\n  have := submodule.finrank_quotient_add_finrank f.range\n  rw [(subspace.quot_equiv_annihilator f.range).finrank_eq, ← ker_dual_map_eq_dual_annihilator_range] at this\n  conv_rhs at this => rw [← subspace.dual_finrank_eq]\n  refine' add_left_injective (finrank K f.dual_map.ker) _\n  change _ + _ = _ + _\n  rw [finrank_range_add_finrank_ker f.dual_map, add_comm, this]\n#align finrank_range_dual_map_eq_finrank_range finrank_range_dual_map_eq_finrank_range\n\n",
 "finrank_dual_annihilator_comap_eq":
 "@[simp]\ntheorem finrank_dual_annihilator_comap_eq {Φ : subspace K (module.dual K V)} :\n    finrank K Φ.dual_annihilator_comap = finrank K Φ.dual_annihilator :=\n  by\n  rw [submodule.dual_annihilator_comap, ← module.eval_equiv_to_linear_map]\n  exact linear_equiv.finrank_eq (linear_equiv.of_submodule' _ _)\n#align finrank_dual_annihilator_comap_eq finrank_dual_annihilator_comap_eq\n\n",
 "finrank_add_finrank_dual_annihilator_comap_eq":
 "theorem finrank_add_finrank_dual_annihilator_comap_eq (W : subspace K (module.dual K V)) :\n    finrank K W + finrank K W.dual_annihilator_comap = finrank K V := by\n  rw [finrank_dual_annihilator_comap_eq, W.quot_equiv_annihilator.finrank_eq.symm, add_comm,\n    submodule.finrank_quotient_add_finrank, subspace.dual_finrank_eq]\n#align finrank_add_finrank_dual_annihilator_comap_eq finrank_add_finrank_dual_annihilator_comap_eq\n\n",
 "eval_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eval_range {ι : Type _} [Finite ι] (b : basis ι R M) : (eval R M).range = «expr⊤» := by\n  classical\n    cases nonempty_fintype ι\n    rw [← b.to_dual_to_dual, range_comp, b.to_dual_range, map_top, to_dual_range _]\n    infer_instance\n#align eval_range eval_range\n\n",
 "eval_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eval_ker : (eval K V).ker = «expr⊥» := by classical exact (basis.of_vector_space K V).eval_ker\n#align eval_ker eval_ker\n\n",
 "eval_equiv_to_linear_map":
 "@[simp]\ntheorem eval_equiv_to_linear_map [finite_dimensional K V] : (eval_equiv K V).to_linear_map = dual.eval K V :=\n  rfl\n#align eval_equiv_to_linear_map eval_equiv_to_linear_map\n\n",
 "eval_apply_injective":
 "theorem eval_apply_injective : function.injective (eval K V) :=\n  (injective_iff_map_eq_zero' (eval K V)).mpr (eval_apply_eq_zero_iff K)\n#align eval_apply_injective eval_apply_injective\n\n",
 "eval_apply_eq_zero_iff":
 "theorem eval_apply_eq_zero_iff (v : V) : (eval K V) v = 0 ↔ v = 0 := by\n  simpa only using set_like.ext_iff.mp (eval_ker : (eval K V).ker = _) v\n#align eval_apply_eq_zero_iff eval_apply_eq_zero_iff\n\n",
 "eval_apply":
 "@[simp]\ntheorem eval_apply (v : M) (a : dual R M) : eval R M v a = a v :=\n  by\n  dsimp only [eval]\n  rw [linear_map.flip_apply, linear_map.id_apply]\n#align eval_apply eval_apply\n\n",
 "erange_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem erange_coe [finite_dimensional K V] : (eval K V).range = «expr⊤» :=\n  letI : is_noetherian K V := is_noetherian.iff_fg.2 infer_instance\n  (basis.of_vector_space K V).eval_range\n#align erange_coe erange_coe\n\n",
 "dual_restrict_surjective":
 "theorem dual_restrict_surjective : function.surjective W.dual_restrict :=\n  W.dual_lift_right_inverse.surjective\n#align dual_restrict_surjective dual_restrict_surjective\n\n",
 "dual_restrict_left_inverse":
 "theorem dual_restrict_left_inverse (W : subspace K V) : function.left_inverse W.dual_restrict W.dual_lift := fun x =>\n  show W.dual_restrict.comp W.dual_lift x = x\n    by\n    rw [dual_restrict_comp_dual_lift]\n    rfl\n#align dual_restrict_left_inverse dual_restrict_left_inverse\n\n",
 "dual_restrict_ker_eq_dual_annihilator":
 "theorem dual_restrict_ker_eq_dual_annihilator (W : submodule R M) : W.dual_restrict.ker = W.dual_annihilator :=\n  rfl\n#align dual_restrict_ker_eq_dual_annihilator dual_restrict_ker_eq_dual_annihilator\n\n",
 "dual_restrict_comp_dual_lift":
 "@[simp]\ntheorem dual_restrict_comp_dual_lift (W : subspace K V) : W.dual_restrict.comp W.dual_lift = 1 :=\n  by\n  ext (φ x)\n  simp\n#align dual_restrict_comp_dual_lift dual_restrict_comp_dual_lift\n\n",
 "dual_restrict_apply":
 "@[simp]\ntheorem dual_restrict_apply (W : submodule R M) (φ : module.dual R M) (x : W) : W.dual_restrict φ x = φ (x : M) :=\n  rfl\n#align dual_restrict_apply dual_restrict_apply\n\n",
 "dual_pairing_nondegenerate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem dual_pairing_nondegenerate : (dual_pairing K V).nondegenerate :=\n  by\n  refine' ⟨separating_left_iff_ker_eq_bot.mpr ker_id, _⟩\n  intro x\n  contrapose\n  rintro hx : x ≠ 0\n  rw [not_forall]\n  let f : «expr →ₗ[ ] » V K K := Classical.choose (linear_pmap.mk_span_singleton x 1 hx).to_fun.exists_extend\n  use f\n  refine' ne_zero_of_eq_one _\n  have h : f.comp («expr ∙ » K x).subtype = (linear_pmap.mk_span_singleton x 1 hx).to_fun :=\n    Classical.choose_spec (linear_pmap.mk_span_singleton x (1 : K) hx).to_fun.exists_extend\n  exact (fun_like.congr_fun h _).trans (linear_pmap.mk_span_singleton_apply _ hx _)\n#align dual_pairing_nondegenerate dual_pairing_nondegenerate\n\n",
 "dual_pairing_apply":
 "/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Fabian Glöckle\n-/\n@[simp]\ntheorem dual_pairing_apply (v x) : dual_pairing R M v x = v x :=\n  rfl\n#align dual_pairing_apply dual_pairing_apply\n\n",
 "dual_map_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem linear_equiv.dual_map_trans {M₃ : Type _} [add_comm_group M₃] [Module R M₃] (f : «expr ≃ₗ[ ] » M₁ R M₂)\n    (g : «expr ≃ₗ[ ] » M₂ R M₃) : g.dual_map.trans f.dual_map = (f.trans g).dual_map :=\n  rfl\n#align linear_equiv.dual_map_trans linear_equiv.dual_map_trans\n\n",
 "dual_map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv.dual_map_symm {f : «expr ≃ₗ[ ] » M₁ R M₂} :\n    (linear_equiv.dual_map f).symm = linear_equiv.dual_map f.symm :=\n  rfl\n#align linear_equiv.dual_map_symm linear_equiv.dual_map_symm\n\n",
 "dual_map_refl":
 "@[simp]\ntheorem linear_equiv.dual_map_refl : (linear_equiv.refl R M₁).dual_map = linear_equiv.refl R (dual R M₁) :=\n  by\n  ext\n  rfl\n#align linear_equiv.dual_map_refl linear_equiv.dual_map_refl\n\n",
 "dual_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.dual_map_id : (linear_map.id : «expr →ₗ[ ] » M₁ R M₁).dual_map = linear_map.id :=\n  by\n  ext\n  rfl\n#align linear_map.dual_map_id linear_map.dual_map_id\n\n",
 "dual_map_comp_dual_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.dual_map_comp_dual_map {M₃ : Type _} [add_comm_group M₃] [Module R M₃] (f : «expr →ₗ[ ] » M₁ R M₂)\n    (g : «expr →ₗ[ ] » M₂ R M₃) : f.dual_map.comp g.dual_map = (g.comp f).dual_map :=\n  rfl\n#align linear_map.dual_map_comp_dual_map linear_map.dual_map_comp_dual_map\n\n",
 "dual_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem linear_equiv.dual_map_apply (f : «expr ≃ₗ[ ] » M₁ R M₂) (g : dual R M₂) (x : M₁) : f.dual_map g x = g (f x) :=\n  rfl\n#align linear_equiv.dual_map_apply linear_equiv.dual_map_apply\n\n",
 "dual_lift_right_inverse":
 "theorem dual_lift_right_inverse (W : subspace K V) : function.right_inverse W.dual_lift W.dual_restrict :=\n  W.dual_restrict_left_inverse\n#align dual_lift_right_inverse dual_lift_right_inverse\n\n",
 "dual_lift_of_subtype":
 "@[simp]\ntheorem dual_lift_of_subtype {φ : module.dual K W} (w : W) : W.dual_lift φ (w : V) = φ w :=\n  by\n  erw [of_is_compl_left_apply _ w]\n  rfl\n#align dual_lift_of_subtype dual_lift_of_subtype\n\n",
 "dual_lift_of_mem":
 "theorem dual_lift_of_mem {φ : module.dual K W} {w : V} (hw : w ∈ W) : W.dual_lift φ w = φ ⟨w, hw⟩ := by\n  convert dual_lift_of_subtype ⟨w, hw⟩\n#align dual_lift_of_mem dual_lift_of_mem\n\n",
 "dual_lift_injective":
 "theorem dual_lift_injective : function.injective W.dual_lift :=\n  W.dual_restrict_left_inverse.injective\n#align dual_lift_injective dual_lift_injective\n\n",
 "dual_lc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem dual_lc (l : «expr →₀ » ι R) (i : ι) : ε i (dual_bases.lc e l) = l i :=\n  by\n  erw [linear_map.map_sum]\n  simp only [h.eval, map_smul, smul_eq_mul]\n  rw [finset.sum_eq_single i]\n  · simp\n  · intro q q_in q_ne\n    simp [q_ne.symm]\n  · intro p_not_in\n    simp [finsupp.not_mem_support_iff.1 p_not_in]\n#align dual_lc dual_lc\n\n",
 "dual_finrank_eq":
 "@[simp]\ntheorem dual_finrank_eq : finrank K (module.dual K V) = finrank K V :=\n  linear_equiv.finrank_eq (basis.of_vector_space K V).to_dual_equiv.symm\n#align dual_finrank_eq dual_finrank_eq\n\n",
 "dual_equiv_dual_def":
 "theorem dual_equiv_dual_def (W : subspace K V) : W.dual_equiv_dual.to_linear_map = W.dual_lift.range_restrict :=\n  rfl\n#align dual_equiv_dual_def dual_equiv_dual_def\n\n",
 "dual_equiv_dual_apply":
 "@[simp]\ntheorem dual_equiv_dual_apply (φ : module.dual K W) : W.dual_equiv_dual φ = ⟨W.dual_lift φ, mem_range.2 ⟨φ, rfl⟩⟩ :=\n  rfl\n#align dual_equiv_dual_apply dual_equiv_dual_apply\n\n",
 "dual_distrib_inv_of_basis_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n@[simp]\ntheorem dual_distrib_inv_of_basis_apply (b : basis ι R M) (c : basis κ R N) (f : dual R (tensor_product M R N)) :\n    dual_distrib_inv_of_basis b c f =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (f («expr ⊗ₜ » (b i) (c j))) («expr ⊗ₜ » (b.dual_basis i) (c.dual_basis j))) :=\n  by simp [dual_distrib_inv_of_basis]\n#align dual_distrib_inv_of_basis_apply dual_distrib_inv_of_basis_apply\n\n",
 "dual_distrib_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ » -/\n@[simp]\ntheorem dual_distrib_apply (f : dual R M) (g : dual R N) (m : M) (n : N) :\n    dual_distrib R M N («expr ⊗ₜ » f g) («expr ⊗ₜ » m n) = f m * g n :=\n  rfl\n#align dual_distrib_apply dual_distrib_apply\n\n",
 "dual_dim_eq":
 "-- TODO(jmc): generalize to rings, once `module.rank` is generalized\ntheorem dual_dim_eq [finite_dimensional K V] : cardinal.lift (module.rank K V) = module.rank K (dual K V) :=\n  (basis.of_vector_space K V).dual_dim_eq\n#align dual_dim_eq dual_dim_eq\n\n",
 "dual_basis_repr":
 "theorem dual_basis_repr (l : dual R M) (i : ι) : b.dual_basis.repr l i = l (b i) := by\n  rw [← total_dual_basis b, basis.total_repr b.dual_basis l]\n#align dual_basis_repr dual_basis_repr\n\n",
 "dual_basis_equiv_fun":
 "theorem dual_basis_equiv_fun [fintype ι] (l : dual R M) (i : ι) : b.dual_basis.equiv_fun l i = l (b i) := by\n  rw [basis.equiv_fun_apply, dual_basis_repr]\n#align dual_basis_equiv_fun dual_basis_equiv_fun\n\n",
 "dual_basis_apply_self":
 "-- We use `j = i` to match `basis.repr_self`\ntheorem dual_basis_apply_self (i j : ι) : b.dual_basis i (b j) = if j = i then 1 else 0 :=\n  by\n  convert b.to_dual_apply i j using 2\n  rw [@eq_comm _ j i]\n#align dual_basis_apply_self dual_basis_apply_self\n\n",
 "dual_basis_apply":
 "theorem dual_basis_apply (i : ι) (m : M) : b.dual_basis i m = b.repr m i :=\n  b.to_dual_apply_right i m\n#align dual_basis_apply dual_basis_apply\n\n",
 "dual_annihilator_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem dual_annihilator_top : («expr⊤» : submodule R M).dual_annihilator = «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  intro v\n  simp_rw [mem_dual_annihilator, mem_bot, mem_top, forall_true_left]\n  exact fun h => linear_map.ext h\n#align dual_annihilator_top dual_annihilator_top\n\n",
 "dual_annihilator_supr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem dual_annihilator_supr_eq {ι : Type _} (U : ι → submodule R M) :\n    («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (U i)).dual_annihilator =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (U i).dual_annihilator :=\n  by\n  classical\n    ext φ\n    simp_rw [mem_infi, mem_dual_annihilator]\n    constructor\n    · simp_rw [mem_supr]\n      intro h i w hw\n      exact h _ fun _ hi => hi i hw\n    · simp_rw [submodule.mem_supr_iff_exists_dfinsupp']\n      rintro h w ⟨f, rfl⟩\n      simp only [linear_map.map_dfinsupp_sum]\n      trans f.sum fun (i : ι) (d : U i) => (0 : R)\n      · congr\n        ext (i d)\n        exact h i d d.property\n      · exact @dfinsupp.sum_zero ι _ (fun i => U i) _ _ _ _ f\n#align dual_annihilator_supr_eq dual_annihilator_supr_eq\n\n",
 "dual_annihilator_sup_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem dual_annihilator_sup_eq (U V : submodule R M) :\n    («expr ⊔ » U V).dual_annihilator = «expr ⊓ » U.dual_annihilator V.dual_annihilator :=\n  by\n  ext φ\n  rw [mem_inf, mem_dual_annihilator, mem_dual_annihilator, mem_dual_annihilator]\n  constructor <;> intro h\n  · refine' ⟨_, _⟩ <;> intro x hx\n    exact h x (mem_sup.2 ⟨x, hx, 0, zero_mem _, add_zero _⟩)\n    exact h x (mem_sup.2 ⟨0, zero_mem _, x, hx, zero_add _⟩)\n  · simp_rw [mem_sup]\n    rintro _ ⟨x, hx, y, hy, rfl⟩\n    rw [linear_map.map_add, h.1 _ hx, h.2 _ hy, add_zero]\n#align dual_annihilator_sup_eq dual_annihilator_sup_eq\n\n",
 "dual_annihilator_dual_annihilator_comap_eq":
 "theorem dual_annihilator_dual_annihilator_comap_eq {W : subspace K V} : W.dual_annihilator.dual_annihilator_comap = W :=\n  by\n  refine' le_antisymm _ le_dual_annihilator_dual_annihilator_comap\n  intro v\n  simp only [mem_dual_annihilator, mem_dual_annihilator_comap]\n  contrapose!\n  intro hv\n  obtain ⟨W', hW⟩ := submodule.exists_is_compl W\n  obtain ⟨⟨w, w'⟩, rfl, -⟩ := exists_unique_add_of_is_compl_prod hW v\n  have hw'n : (w' : V) ∉ W := by\n    contrapose! hv\n    exact submodule.add_mem W w.2 hv\n  have hw'nz : w' ≠ 0 := by\n    rintro rfl\n    exact hw'n (submodule.zero_mem W)\n  rw [ne.def, ← module.forall_dual_apply_eq_zero_iff K w'] at hw'nz\n  push_neg  at hw'nz\n  obtain ⟨φ, hφ⟩ := hw'nz\n  exists ((linear_map.of_is_compl_prod hW).comp (linear_map.inr _ _ _)) φ\n  simp only [coe_comp, coe_inr, Function.comp_apply, of_is_compl_prod_apply, map_add, of_is_compl_left_apply,\n    zero_apply, of_is_compl_right_apply, zero_add, ne.def]\n  refine' ⟨_, hφ⟩\n  intro v hv\n  convert linear_map.of_is_compl_left_apply hW ⟨v, hv⟩\n#align dual_annihilator_dual_annihilator_comap_eq dual_annihilator_dual_annihilator_comap_eq\n\n",
 "dual_annihilator_comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- We work in vector spaces because `exists_is_compl` only hold for vector spaces\n@[simp]\ntheorem dual_annihilator_comap_top (W : subspace K V) :\n    («expr⊤» : submodule K (module.dual K W)).dual_annihilator_comap = «expr⊥» := by\n  rw [dual_annihilator_comap, dual_annihilator_top, comap_bot, module.eval_ker]\n#align dual_annihilator_comap_top dual_annihilator_comap_top\n\n",
 "dual_annihilator_comap_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem dual_annihilator_comap_bot : («expr⊥» : submodule R (module.dual R M)).dual_annihilator_comap = «expr⊤» := by\n  rw [dual_annihilator_comap, dual_annihilator_bot, comap_top]\n#align dual_annihilator_comap_bot dual_annihilator_comap_bot\n\n",
 "dual_annihilator_comap_anti":
 "@[mono]\ntheorem dual_annihilator_comap_anti {U V : submodule R (module.dual R M)} (hUV : U ≤ V) :\n    V.dual_annihilator_comap ≤ U.dual_annihilator_comap :=\n  by\n  intro φ\n  simp_rw [mem_dual_annihilator_comap]\n  intro h w hw\n  exact h w (hUV hw)\n#align dual_annihilator_comap_anti dual_annihilator_comap_anti\n\n",
 "dual_annihilator_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem dual_annihilator_bot : («expr⊥» : submodule R M).dual_annihilator = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro v\n  simp_rw [mem_dual_annihilator, mem_bot, mem_top, forall_true_left]\n  rintro _ rfl\n  exact _root_.map_zero v\n#align dual_annihilator_bot dual_annihilator_bot\n\n",
 "dual_annihilator_anti":
 "@[mono]\ntheorem dual_annihilator_anti {U V : submodule R M} (hUV : U ≤ V) : V.dual_annihilator ≤ U.dual_annihilator :=\n  by\n  intro φ\n  simp_rw [mem_dual_annihilator]\n  intro h w hw\n  exact h w (hUV hw)\n#align dual_annihilator_anti dual_annihilator_anti\n\n",
 "coeffs_lc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n@[simp]\ntheorem coeffs_lc (l : «expr →₀ » ι R) : h.coeffs (dual_bases.lc e l) = l :=\n  by\n  ext i\n  rw [h.coeffs_apply, h.dual_lc]\n#align coeffs_lc coeffs_lc\n\n",
 "coeffs_apply":
 "@[simp]\ntheorem coeffs_apply [decidable_eq ι] (h : dual_bases e ε) (m : M) (i : ι) : h.coeffs m i = ε i m :=\n  rfl\n#align coeffs_apply coeffs_apply\n\n",
 "coe_to_dual_self":
 "theorem coe_to_dual_self (i : ι) : b.to_dual (b i) = b.coord i :=\n  by\n  ext\n  apply to_dual_apply_right\n#align coe_to_dual_self coe_to_dual_self\n\n",
 "coe_dual_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_dual_basis [fintype ι] : «expr⇑ » h.basis.dual_basis = ε :=\n  funext fun i =>\n    h.basis.ext fun j => by rw [h.basis.dual_basis_apply_self, h.coe_basis, h.eval, if_congr eq_comm rfl rfl]\n#align coe_dual_basis coe_dual_basis\n\n",
 "coe_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_basis : «expr⇑ » h.basis = e := by\n  ext i\n  rw [basis.apply_eq_iff]\n  ext j\n  rw [h.basis_repr_apply, coeffs_apply, h.eval, finsupp.single_apply]\n  convert if_congr eq_comm rfl rfl\n#align coe_basis coe_basis\n\n"}