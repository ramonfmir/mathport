{"contract_left_assoc_coevaluation'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- This lemma corresponds to one of the coherence laws for duals in rigid categories, see\n  `category_theory.monoidal.rigid`. -/\ntheorem contract_left_assoc_coevaluation' :\n    «expr ∘ₗ » ((contract_left K V).ltensor _)\n        («expr ∘ₗ » (TensorProduct.assoc K _ _ _).to_linear_map ((coevaluation K V).rtensor V)) =\n      «expr ∘ₗ » (TensorProduct.rid K _).symm.to_linear_map (TensorProduct.lid K _).to_linear_map :=\n  by\n  letI := Classical.decEq (Basis.ofVectorSpaceIndex K V)\n  apply TensorProduct.ext\n  apply LinearMap.ext_ring; apply (Basis.ofVectorSpace K V).ext; intro j\n  rw [LinearMap.compr₂_apply, LinearMap.compr₂_apply, TensorProduct.mk_apply]\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearEquiv.coe_toLinearMap]\n  rw [lid_tmul, one_smul, rid_symm_apply]\n  simp only [LinearEquiv.coe_toLinearMap, LinearMap.rtensor_tmul, coevaluation_apply_one]\n  rw [TensorProduct.sum_tmul, LinearEquiv.map_sum]; simp only [assoc_tmul]\n  rw [LinearMap.map_sum]; simp only [LinearMap.ltensor_tmul, contract_left_apply]\n  simp only [basis.coord_apply, Basis.repr_self_apply, TensorProduct.tmul_ite]\n  rw [Finset.sum_ite_eq]; simp only [Finset.mem_univ, if_true]\n#align contract_left_assoc_coevaluation' contract_left_assoc_coevaluation'\n\n",
 "contract_left_assoc_coevaluation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- This lemma corresponds to one of the coherence laws for duals in rigid categories, see\n  `category_theory.monoidal.rigid`. -/\ntheorem contract_left_assoc_coevaluation :\n    «expr ∘ₗ » ((contract_left K V).rtensor _)\n        («expr ∘ₗ » (TensorProduct.assoc K _ _ _).symm.to_linear_map ((coevaluation K V).ltensor (module.dual K V))) =\n      «expr ∘ₗ » (TensorProduct.lid K _).symm.to_linear_map (TensorProduct.rid K _).to_linear_map :=\n  by\n  letI := Classical.decEq (Basis.ofVectorSpaceIndex K V)\n  apply TensorProduct.ext\n  apply (Basis.ofVectorSpace K V).dual_basis.ext; intro j; apply LinearMap.ext_ring\n  rw [LinearMap.compr₂_apply, LinearMap.compr₂_apply, TensorProduct.mk_apply]\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearEquiv.coe_toLinearMap]\n  rw [rid_tmul, one_smul, lid_symm_apply]\n  simp only [LinearEquiv.coe_toLinearMap, LinearMap.ltensor_tmul, coevaluation_apply_one]\n  rw [TensorProduct.tmul_sum, LinearEquiv.map_sum]; simp only [assoc_symm_tmul]\n  rw [LinearMap.map_sum]; simp only [LinearMap.rtensor_tmul, contract_left_apply]\n  simp only [basis.coe_dual_basis, basis.coord_apply, Basis.repr_self_apply, TensorProduct.ite_tmul]\n  rw [Finset.sum_ite_eq']; simp only [Finset.mem_univ, if_true]\n#align contract_left_assoc_coevaluation contract_left_assoc_coevaluation\n\n",
 "coevaluation_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/-\nCopyright (c) 2021 Jakob von Raumer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jakob von Raumer\n-/\ntheorem coevaluation_apply_one :\n    (coevaluation K V) (1 : K) =\n      let bV := Basis.ofVectorSpace K V\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr ⊗ₜ[ ] » (bV i) K (bV.coord i)) :=\n  by\n  simp only [coevaluation, id]\n  rw [(Basis.singleton Unit K).constr_apply_fintype K]\n  simp only [Fintype.univ_punit, Finset.sum_const, one_smul, Basis.singleton_repr, Basis.equivFun_apply,\n    Basis.coe_ofVectorSpace, one_nsmul, Finset.card_singleton]\n#align coevaluation_apply_one coevaluation_apply_one\n\n"}