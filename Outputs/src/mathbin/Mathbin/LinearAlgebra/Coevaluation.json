{"contract_left_assoc_coevaluation'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- This lemma corresponds to one of the coherence laws for duals in rigid categories, see\n  `category_theory.monoidal.rigid`. -/\ntheorem contract_left_assoc_coevaluation' :\n    «expr ∘ₗ » ((contract_left K V).ltensor _)\n        («expr ∘ₗ » (tensor_product.assoc K _ _ _).to_linear_map ((coevaluation K V).rtensor V)) =\n      «expr ∘ₗ » (tensor_product.rid K _).symm.to_linear_map (tensor_product.lid K _).to_linear_map :=\n  by\n  letI := classical.dec_eq (basis.of_vector_space_index K V)\n  apply tensor_product.ext\n  apply linear_map.ext_ring; apply (basis.of_vector_space K V).ext; intro j\n  rw [linear_map.compr₂_apply, linear_map.compr₂_apply, tensor_product.mk_apply]\n  simp only [linear_map.coe_comp, Function.comp_apply, linear_equiv.coe_to_linear_map]\n  rw [lid_tmul, one_smul, rid_symm_apply]\n  simp only [linear_equiv.coe_to_linear_map, linear_map.rtensor_tmul, coevaluation_apply_one]\n  rw [tensor_product.sum_tmul, linear_equiv.map_sum]; simp only [assoc_tmul]\n  rw [linear_map.map_sum]; simp only [linear_map.ltensor_tmul, contract_left_apply]\n  simp only [basis.coord_apply, basis.repr_self_apply, tensor_product.tmul_ite]\n  rw [finset.sum_ite_eq]; simp only [finset.mem_univ, if_true]\n#align contract_left_assoc_coevaluation' contract_left_assoc_coevaluation'\n\n",
 "contract_left_assoc_coevaluation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- This lemma corresponds to one of the coherence laws for duals in rigid categories, see\n  `category_theory.monoidal.rigid`. -/\ntheorem contract_left_assoc_coevaluation :\n    «expr ∘ₗ » ((contract_left K V).rtensor _)\n        («expr ∘ₗ » (tensor_product.assoc K _ _ _).symm.to_linear_map ((coevaluation K V).ltensor (module.dual K V))) =\n      «expr ∘ₗ » (tensor_product.lid K _).symm.to_linear_map (tensor_product.rid K _).to_linear_map :=\n  by\n  letI := classical.dec_eq (basis.of_vector_space_index K V)\n  apply tensor_product.ext\n  apply (basis.of_vector_space K V).dual_basis.ext; intro j; apply linear_map.ext_ring\n  rw [linear_map.compr₂_apply, linear_map.compr₂_apply, tensor_product.mk_apply]\n  simp only [linear_map.coe_comp, Function.comp_apply, linear_equiv.coe_to_linear_map]\n  rw [rid_tmul, one_smul, lid_symm_apply]\n  simp only [linear_equiv.coe_to_linear_map, linear_map.ltensor_tmul, coevaluation_apply_one]\n  rw [tensor_product.tmul_sum, linear_equiv.map_sum]; simp only [assoc_symm_tmul]\n  rw [linear_map.map_sum]; simp only [linear_map.rtensor_tmul, contract_left_apply]\n  simp only [basis.coe_dual_basis, basis.coord_apply, basis.repr_self_apply, tensor_product.ite_tmul]\n  rw [finset.sum_ite_eq']; simp only [finset.mem_univ, if_true]\n#align contract_left_assoc_coevaluation contract_left_assoc_coevaluation\n\n",
 "coevaluation_apply_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n/-\nCopyright (c) 2021 Jakob von Raumer. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jakob von Raumer\n-/\ntheorem coevaluation_apply_one :\n    (coevaluation K V) (1 : K) =\n      let bV := basis.of_vector_space K V\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr ⊗ₜ[ ] » (bV i) K (bV.coord i)) :=\n  by\n  simp only [coevaluation, id]\n  rw [(basis.singleton unit K).constr_apply_fintype K]\n  simp only [fintype.univ_punit, finset.sum_const, one_smul, basis.singleton_repr, basis.equiv_fun_apply,\n    basis.coe_of_vector_space, one_nsmul, finset.card_singleton]\n#align coevaluation_apply_one coevaluation_apply_one\n\n"}