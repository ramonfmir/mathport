{"supr_generalized_eigenspace_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). -/\ntheorem supr_generalized_eigenspace_eq_top [is_alg_closed K] [finite_dimensional K V] (f : End K V) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (f.generalized_eigenspace μ k) =\n      «expr⊤» :=\n  by\n  -- We prove the claim by strong induction on the dimension of the vector space.\n  induction' h_dim : finrank K V using nat.strong_induction_on with n ih generalizing V\n  cases n\n  -- If the vector space is 0-dimensional, the result is trivial.\n  · rw [← top_le_iff]\n    simp only [finrank_eq_zero.1 (eq.trans finrank_top h_dim), bot_le]\n  -- Otherwise the vector space is nontrivial.\n  · haveI : nontrivial V :=\n      finrank_pos_iff.1\n        (by\n          rw [h_dim]\n          apply nat.zero_lt_succ)\n    -- Hence, `f` has an eigenvalue `μ₀`.\n    obtain ⟨μ₀, hμ₀⟩ : ∃ μ₀, f.has_eigenvalue μ₀ := exists_eigenvalue f\n    -- We define `ES` to be the generalized eigenspace\n    let ES := f.generalized_eigenspace μ₀ (finrank K V)\n    -- and `ER` to be the generalized eigenrange.\n    let ER := f.generalized_eigenrange μ₀ (finrank K V)\n    -- `f` maps `ER` into itself.\n    have h_f_ER : ∀ x : V, x ∈ ER → f x ∈ ER := fun x hx => map_generalized_eigenrange_le (submodule.mem_map_of_mem hx)\n    -- Therefore, we can define the restriction `f'` of `f` to `ER`.\n    let f' : End K ER := f.restrict h_f_ER\n    -- The dimension of `ES` is positive\n    have h_dim_ES_pos : 0 < finrank K ES := by\n      dsimp only [ES]\n      rw [h_dim]\n      apply pos_finrank_generalized_eigenspace_of_has_eigenvalue hμ₀ (nat.zero_lt_succ n)\n    -- and the dimensions of `ES` and `ER` add up to `finrank K V`.\n    have h_dim_add : finrank K ER + finrank K ES = finrank K V := by apply linear_map.finrank_range_add_finrank_ker\n    -- Therefore the dimension `ER` mus be smaller than `finrank K V`.\n    have h_dim_ER : finrank K ER < n.succ := by linarith\n    -- This allows us to apply the induction hypothesis on `ER`:\n    have ih_ER :\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (f'.generalized_eigenspace μ k) =\n        «expr⊤» :=\n      ih (finrank K ER) h_dim_ER f' rfl\n    -- The induction hypothesis gives us a statement about subspaces of `ER`. We can transfer this\n    -- to a statement about subspaces of `V` via `submodule.subtype`:\n    have ih_ER' :\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          ((f'.generalized_eigenspace μ k).map ER.subtype) =\n        ER :=\n      by simp only [(submodule.map_supr _ _).symm, ih_ER, submodule.map_subtype_top ER]\n    -- Moreover, every generalized eigenspace of `f'` is contained in the corresponding generalized\n    -- eigenspace of `f`.\n    have hff' : ∀ μ k, (f'.generalized_eigenspace μ k).map ER.subtype ≤ f.generalized_eigenspace μ k :=\n      by\n      intros\n      rw [generalized_eigenspace_restrict]\n      apply submodule.map_comap_le\n    -- It follows that `ER` is contained in the span of all generalized eigenvectors.\n    have hER :\n      ER ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (f.generalized_eigenspace μ k) :=\n      by\n      rw [← ih_ER']\n      exact supᵢ₂_mono hff'\n    -- `ES` is contained in this span by definition.\n    have hES :\n      ES ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (f.generalized_eigenspace μ k) :=\n      le_trans (le_supᵢ (fun k => f.generalized_eigenspace μ₀ k) (finrank K V))\n        (le_supᵢ\n          (fun μ : K =>\n            «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n              (f.generalized_eigenspace μ k))\n          μ₀)\n    -- Moreover, we know that `ER` and `ES` are disjoint.\n    have h_disjoint : Disjoint ER ES := generalized_eigenvec_disjoint_range_ker f μ₀\n    -- Since the dimensions of `ER` and `ES` add up to the dimension of `V`, it follows that the\n    -- span of all generalized eigenvectors is all of `V`.\n    show\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (f.generalized_eigenspace μ k) =\n        «expr⊤»\n    · rw [← top_le_iff, ← submodule.eq_top_of_disjoint ER ES h_dim_add h_disjoint]\n      apply sup_le hER hES\n#align supr_generalized_eigenspace_eq_top supr_generalized_eigenspace_eq_top\n\n",
 "pos_finrank_generalized_eigenspace_of_has_eigenvalue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The generalized eigenspace of an eigenvalue has positive dimension for positive exponents. -/\ntheorem pos_finrank_generalized_eigenspace_of_has_eigenvalue [finite_dimensional K V] {f : End K V} {k : ℕ} {μ : K}\n    (hx : f.has_eigenvalue μ) (hk : 0 < k) : 0 < finrank K (f.generalized_eigenspace μ k) :=\n  calc\n    0 = finrank K («expr⊥» : submodule K V) := by rw [finrank_bot]\n    _ < finrank K (f.eigenspace μ) := submodule.finrank_lt_finrank_of_lt (bot_lt_iff_ne_bot.2 hx)\n    _ ≤ finrank K (f.generalized_eigenspace μ k) :=\n      submodule.finrank_mono ((f.generalized_eigenspace μ).monotone (nat.succ_le_of_lt hk))\n    \n#align pos_finrank_generalized_eigenspace_of_has_eigenvalue pos_finrank_generalized_eigenspace_of_has_eigenvalue\n\n",
 "mem_spectrum_of_has_eigenvalue":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_spectrum_of_has_eigenvalue {f : End R M} {μ : R} (hμ : has_eigenvalue f μ) : μ ∈ spectrum R f :=\n  by\n  refine' spectrum.mem_iff.mpr fun h_unit => _\n  set f' := linear_map.general_linear_group.to_linear_equiv h_unit.unit\n  rcases hμ.exists_has_eigenvector with ⟨v, hv⟩\n  refine' hv.2 ((linear_map.ker_eq_bot'.mp f'.ker) v (_ : «expr • » μ v - f v = 0))\n  rw [hv.apply_eq_smul, sub_self]\n#align mem_spectrum_of_has_eigenvalue mem_spectrum_of_has_eigenvalue\n\n",
 "mem_maximal_generalized_eigenspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_maximal_generalized_eigenspace (f : End R M) (μ : R) (m : M) :\n    m ∈ f.maximal_generalized_eigenspace μ ↔ ∃ k : ℕ, ((f - «expr • » μ 1) ^ k) m = 0 := by\n  simp only [maximal_generalized_eigenspace, ← mem_generalized_eigenspace, submodule.mem_supr_of_chain]\n#align mem_maximal_generalized_eigenspace mem_maximal_generalized_eigenspace\n\n",
 "mem_generalized_eigenspace":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem mem_generalized_eigenspace (f : End R M) (μ : R) (k : ℕ) (m : M) :\n    m ∈ f.generalized_eigenspace μ k ↔ ((f - «expr • » μ 1) ^ k) m = 0 :=\n  iff.rfl\n#align mem_generalized_eigenspace mem_generalized_eigenspace\n\n",
 "mem_eigenspace_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem mem_eigenspace_iff {f : End R M} {μ : R} {x : M} : x ∈ eigenspace f μ ↔ f x = «expr • » μ x := by\n  rw [eigenspace, linear_map.mem_ker, linear_map.sub_apply, algebra_map_End_apply, sub_eq_zero]\n#align mem_eigenspace_iff mem_eigenspace_iff\n\n",
 "maximal_generalized_eigenspace_eq":
 "/-- For an endomorphism of a Noetherian module, the maximal eigenspace is always of the form kernel\n`(f - μ • id) ^ k` for some `k`. -/\ntheorem maximal_generalized_eigenspace_eq [h : is_noetherian R M] (f : End R M) (μ : R) :\n    maximal_generalized_eigenspace f μ = f.generalized_eigenspace μ (maximal_generalized_eigenspace_index f μ) :=\n  by\n  rw [is_noetherian_iff_well_founded] at h\n  exact (well_founded.supr_eq_monotonic_sequence_limit h (f.generalized_eigenspace μ) : _)\n#align maximal_generalized_eigenspace_eq maximal_generalized_eigenspace_eq\n\n",
 "map_generalized_eigenrange_le":
 "/-- A linear map maps a generalized eigenrange into itself. -/\ntheorem map_generalized_eigenrange_le {f : End K V} {μ : K} {n : ℕ} :\n    submodule.map f (f.generalized_eigenrange μ n) ≤ f.generalized_eigenrange μ n :=\n  calc\n    submodule.map f (f.generalized_eigenrange μ n) = (f * (f - algebra_map _ _ μ) ^ n).range :=\n      (linear_map.range_comp _ _).symm\n    _ = ((f - algebra_map _ _ μ) ^ n * f).range := by rw [algebra.mul_sub_algebra_map_pow_commutes]\n    _ = submodule.map ((f - algebra_map _ _ μ) ^ n) f.range := linear_map.range_comp _ _\n    _ ≤ f.generalized_eigenrange μ n := linear_map.map_le_range\n    \n#align map_generalized_eigenrange_le map_generalized_eigenrange_le\n\n",
 "ker_aeval_ring_hom'_unit_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_aeval_ring_hom'_unit_polynomial (f : End K V) (c : «expr ˣ» (polynomial K)) :\n    (aeval f (c : polynomial K)).ker = «expr⊥» :=\n  by\n  rw [polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]\n  simp only [aeval_def, eval₂_C]\n  apply ker_algebra_map_End\n  apply coeff_coe_units_zero_ne_zero c\n#align ker_aeval_ring_hom'_unit_polynomial ker_aeval_ring_hom'_unit_polynomial\n\n",
 "is_root_of_has_eigenvalue":
 "theorem is_root_of_has_eigenvalue {f : End K V} {μ : K} (h : f.has_eigenvalue μ) : (minpoly K f).is_root μ :=\n  by\n  rcases(submodule.ne_bot_iff _).1 h with ⟨w, ⟨H, ne0⟩⟩\n  refine' or.resolve_right (smul_eq_zero.1 _) ne0\n  simp [← aeval_apply_of_has_eigenvector ⟨H, ne0⟩, minpoly.aeval K f]\n#align is_root_of_has_eigenvalue is_root_of_has_eigenvalue\n\n",
 "has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le":
 "/-- A generalized eigenvalue for some exponent `k` is also\n    a generalized eigenvalue for exponents larger than `k`. -/\ntheorem has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le {f : End R M} {μ : R} {k : ℕ} {m : ℕ}\n    (hm : k ≤ m) (hk : f.has_generalized_eigenvalue μ k) : f.has_generalized_eigenvalue μ m :=\n  by\n  unfold has_generalized_eigenvalue at *\n  contrapose! hk\n  rw [← le_bot_iff, ← hk]\n  exact (f.generalized_eigenspace μ).monotone hm\n#align\n  has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le\n\n",
 "has_generalized_eigenvalue_of_has_eigenvalue":
 "/-- All eigenvalues are generalized eigenvalues. -/\ntheorem has_generalized_eigenvalue_of_has_eigenvalue {f : End R M} {μ : R} {k : ℕ} (hk : 0 < k)\n    (hμ : f.has_eigenvalue μ) : f.has_generalized_eigenvalue μ k :=\n  by\n  apply has_generalized_eigenvalue_of_has_generalized_eigenvalue_of_le hk\n  rw [has_generalized_eigenvalue, generalized_eigenspace, OrderHom.coe_fun_mk, pow_one]\n  exact hμ\n#align has_generalized_eigenvalue_of_has_eigenvalue has_generalized_eigenvalue_of_has_eigenvalue\n\n",
 "has_generalized_eigenvalue_iff_has_eigenvalue":
 "/-- Generalized eigenvalues are actually just eigenvalues. -/\n@[simp]\ntheorem has_generalized_eigenvalue_iff_has_eigenvalue {f : End R M} {μ : R} {k : ℕ} (hk : 0 < k) :\n    f.has_generalized_eigenvalue μ k ↔ f.has_eigenvalue μ :=\n  ⟨has_eigenvalue_of_has_generalized_eigenvalue, has_generalized_eigenvalue_of_has_eigenvalue hk⟩\n#align has_generalized_eigenvalue_iff_has_eigenvalue has_generalized_eigenvalue_iff_has_eigenvalue\n\n",
 "has_eigenvalue_of_is_root":
 "theorem has_eigenvalue_of_is_root (h : (minpoly K f).is_root μ) : f.has_eigenvalue μ :=\n  by\n  cases' dvd_iff_is_root.2 h with p hp\n  rw [has_eigenvalue, eigenspace]\n  intro con\n  cases' (linear_map.is_unit_iff_ker_eq_bot _).2 con with u hu\n  have p_ne_0 : p ≠ 0 := by\n    intro con\n    apply minpoly.ne_zero f.is_integral\n    rw [hp, con, mul_zero]\n  have h_deg := minpoly.degree_le_of_ne_zero K f p_ne_0 _\n  · rw [hp, degree_mul, degree_X_sub_C, polynomial.degree_eq_nat_degree p_ne_0] at h_deg\n    norm_cast  at h_deg\n    linarith\n  · have h_aeval := minpoly.aeval K f\n    revert h_aeval\n    simp [hp, ← hu]\n#align has_eigenvalue_of_is_root has_eigenvalue_of_is_root\n\n",
 "has_eigenvalue_of_has_generalized_eigenvalue":
 "/-- All generalized eigenvalues are eigenvalues. -/\ntheorem has_eigenvalue_of_has_generalized_eigenvalue {f : End R M} {μ : R} {k : ℕ}\n    (hμ : f.has_generalized_eigenvalue μ k) : f.has_eigenvalue μ :=\n  by\n  intro contra; apply hμ\n  erw [linear_map.ker_eq_bot] at contra⊢; rw [linear_map.coe_pow]\n  exact function.injective.iterate contra k\n#align has_eigenvalue_of_has_generalized_eigenvalue has_eigenvalue_of_has_generalized_eigenvalue\n\n",
 "has_eigenvalue_of_has_eigenvector":
 "theorem has_eigenvalue_of_has_eigenvector {f : End R M} {μ : R} {x : M} (h : has_eigenvector f μ x) :\n    has_eigenvalue f μ := by\n  rw [has_eigenvalue, submodule.ne_bot_iff]\n  use x; exact h\n#align has_eigenvalue_of_has_eigenvector has_eigenvalue_of_has_eigenvector\n\n",
 "has_eigenvalue_iff_mem_spectrum":
 "theorem has_eigenvalue_iff_mem_spectrum [finite_dimensional K V] {f : End K V} {μ : K} :\n    f.has_eigenvalue μ ↔ μ ∈ spectrum K f :=\n  iff.intro mem_spectrum_of_has_eigenvalue fun h => by\n    rwa [spectrum.mem_iff, IsUnit.sub_iff, linear_map.is_unit_iff_ker_eq_bot] at h\n#align has_eigenvalue_iff_mem_spectrum has_eigenvalue_iff_mem_spectrum\n\n",
 "has_eigenvalue_iff_is_root":
 "theorem has_eigenvalue_iff_is_root : f.has_eigenvalue μ ↔ (minpoly K f).is_root μ :=\n  ⟨is_root_of_has_eigenvalue, has_eigenvalue_of_is_root⟩\n#align has_eigenvalue_iff_is_root has_eigenvalue_iff_is_root\n\n",
 "generalized_eigenvec_disjoint_range_ker":
 "/-- Generalized eigenrange and generalized eigenspace for exponent `finrank K V` are disjoint. -/\ntheorem generalized_eigenvec_disjoint_range_ker [finite_dimensional K V] (f : End K V) (μ : K) :\n    Disjoint (f.generalized_eigenrange μ (finrank K V)) (f.generalized_eigenspace μ (finrank K V)) :=\n  by\n  have h :=\n    calc\n      submodule.comap ((f - algebra_map _ _ μ) ^ finrank K V) (f.generalized_eigenspace μ (finrank K V)) =\n          ((f - algebra_map _ _ μ) ^ finrank K V * (f - algebra_map K (End K V) μ) ^ finrank K V).ker :=\n        by simpa only [generalized_eigenspace, OrderHom.coe_fun_mk, ← linear_map.ker_comp]\n      _ = f.generalized_eigenspace μ (finrank K V + finrank K V) :=\n        by\n        rw [← pow_add]\n        rfl\n      _ = f.generalized_eigenspace μ (finrank K V) :=\n        by\n        rw [generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le]\n        linarith\n      \n  rw [disjoint_iff_inf_le, generalized_eigenrange, linear_map.range_eq_map, submodule.map_inf_eq_map_inf_comap,\n    top_inf_eq, h]\n  apply submodule.map_comap_le\n#align generalized_eigenvec_disjoint_range_ker generalized_eigenvec_disjoint_range_ker\n\n",
 "generalized_eigenspace_zero":
 "@[simp]\ntheorem generalized_eigenspace_zero (f : End R M) (k : ℕ) : f.generalized_eigenspace 0 k = (f ^ k).ker := by\n  simp [module.End.generalized_eigenspace]\n#align generalized_eigenspace_zero generalized_eigenspace_zero\n\n",
 "generalized_eigenspace_restrict":
 "/-- If `f` maps a subspace `p` into itself, then the generalized eigenspace of the restriction\n    of `f` to `p` is the part of the generalized eigenspace of `f` that lies in `p`. -/\ntheorem generalized_eigenspace_restrict (f : End R M) (p : submodule R M) (k : ℕ) (μ : R)\n    (hfp : ∀ x : M, x ∈ p → f x ∈ p) :\n    generalized_eigenspace (linear_map.restrict f hfp) μ k = submodule.comap p.subtype (f.generalized_eigenspace μ k) :=\n  by\n  simp only [generalized_eigenspace, OrderHom.coe_fun_mk, ← linear_map.ker_comp]\n  induction' k with k ih\n  · rw [pow_zero, pow_zero, linear_map.one_eq_id]\n    apply (submodule.ker_subtype _).symm\n  ·\n    erw [pow_succ', pow_succ', linear_map.ker_comp, linear_map.ker_comp, ih, ← linear_map.ker_comp,\n      linear_map.comp_assoc]\n#align generalized_eigenspace_restrict generalized_eigenspace_restrict\n\n",
 "generalized_eigenspace_le_maximal":
 "theorem generalized_eigenspace_le_maximal (f : End R M) (μ : R) (k : ℕ) :\n    f.generalized_eigenspace μ k ≤ f.maximal_generalized_eigenspace μ :=\n  le_supᵢ _ _\n#align generalized_eigenspace_le_maximal generalized_eigenspace_le_maximal\n\n",
 "generalized_eigenspace_le_generalized_eigenspace_finrank":
 "/-- Every generalized eigenvector is a generalized eigenvector for exponent `finrank K V`.\n    (Lemma 8.11 of [axler2015]) -/\ntheorem generalized_eigenspace_le_generalized_eigenspace_finrank [finite_dimensional K V] (f : End K V) (μ : K)\n    (k : ℕ) : f.generalized_eigenspace μ k ≤ f.generalized_eigenspace μ (finrank K V) :=\n  ker_pow_le_ker_pow_finrank _ _\n#align generalized_eigenspace_le_generalized_eigenspace_finrank generalized_eigenspace_le_generalized_eigenspace_finrank\n\n",
 "generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le":
 "/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le [finite_dimensional K V] (f : End K V) (μ : K)\n    {k : ℕ} (hk : finrank K V ≤ k) : f.generalized_eigenspace μ k = f.generalized_eigenspace μ (finrank K V) :=\n  ker_pow_eq_ker_pow_finrank_of_le hk\n#align\n  generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le generalized_eigenspace_eq_generalized_eigenspace_finrank_of_le\n\n",
 "exp_ne_zero_of_has_generalized_eigenvalue":
 "/-- The exponent of a generalized eigenvalue is never 0. -/\ntheorem exp_ne_zero_of_has_generalized_eigenvalue {f : End R M} {μ : R} {k : ℕ} (h : f.has_generalized_eigenvalue μ k) :\n    k ≠ 0 := by\n  rintro rfl\n  exact h linear_map.ker_id\n#align exp_ne_zero_of_has_generalized_eigenvalue exp_ne_zero_of_has_generalized_eigenvalue\n\n",
 "exists_has_eigenvector":
 "theorem has_eigenvalue.exists_has_eigenvector {f : End R M} {μ : R} (hμ : f.has_eigenvalue μ) :\n    ∃ v, f.has_eigenvector μ v :=\n  submodule.exists_mem_ne_zero_of_ne_bot hμ\n#align has_eigenvalue.exists_has_eigenvector has_eigenvalue.exists_has_eigenvector\n\n",
 "exists_eigenvalue":
 "-- This is Lemma 5.21 of [axler2015], although we are no longer following that proof.\n/-- Every linear operator on a vector space over an algebraically closed field has\n    an eigenvalue. -/\ntheorem exists_eigenvalue [is_alg_closed K] [finite_dimensional K V] [nontrivial V] (f : End K V) :\n    ∃ c : K, f.has_eigenvalue c := by\n  simp_rw [has_eigenvalue_iff_mem_spectrum]\n  exact spectrum.nonempty_of_is_alg_closed_of_finite_dimensional K f\n#align exists_eigenvalue exists_eigenvalue\n\n",
 "eigenvectors_linear_independent":
 "/-- Eigenvectors corresponding to distinct eigenvalues of a linear operator are linearly\n    independent. (Lemma 5.10 of [axler2015])\n\n    We use the eigenvalues as indexing set to ensure that there is only one eigenvector for each\n    eigenvalue in the image of `xs`. -/\ntheorem eigenvectors_linear_independent (f : End K V) (μs : set K) (xs : μs → V)\n    (h_eigenvec : ∀ μ : μs, f.has_eigenvector μ (xs μ)) : linear_independent K xs :=\n  complete_lattice.independent.linear_independent _ (f.eigenspaces_independent.comp subtype.coe_injective)\n    (fun μ => (h_eigenvec μ).1) fun μ => (h_eigenvec μ).2\n#align eigenvectors_linear_independent eigenvectors_linear_independent\n\n",
 "eigenspaces_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem eigenspaces_independent (f : End K V) : complete_lattice.independent f.eigenspace := by\n  classical\n    -- Define an operation from `Π₀ μ : K, f.eigenspace μ`, the vector space of of finitely-supported\n    -- choices of an eigenvector from each eigenspace, to `V`, by sending a collection to its sum.\n    let S :\n      @linear_map K K _ _ (RingHom.id K)\n        («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\"\n          (f.eigenspace μ))\n        V (@dfinsupp.add_comm_monoid K (fun μ => f.eigenspace μ) _) _\n        (@dfinsupp.module K _ (fun μ => f.eigenspace μ) _ _ _) _ :=\n      @dfinsupp.lsum K K ℕ _ V _ _ _ _ _ _ _ _ _ fun μ => (f.eigenspace μ).subtype\n    -- We need to show that if a finitely-supported collection `l` of representatives of the\n    -- eigenspaces has sum `0`, then it itself is zero.\n    suffices\n      ∀ l :\n        «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\"\n          (f.eigenspace μ),\n        S l = 0 → l = 0\n      by\n      rw [complete_lattice.independent_iff_dfinsupp_lsum_injective]\n      change function.injective S\n      rw [←\n        @linear_map.ker_eq_bot K K\n          («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\"\n            (f.eigenspace μ))\n          V _ _ (@dfinsupp.add_comm_group K (fun μ => f.eigenspace μ) _)]\n      rw [eq_bot_iff]\n      exact this\n    intro l hl\n    -- We apply induction on the finite set of eigenvalues from which `l` selects a nonzero\n    -- eigenvector, i.e. on the support of `l`.\n    induction' h_l_support : l.support using Finset.induction with μ₀ l_support' hμ₀ ih generalizing l\n    -- If the support is empty, all coefficients are zero and we are done.\n    · exact dfinsupp.support_eq_empty.1 h_l_support\n    -- Now assume that the support of `l` contains at least one eigenvalue `μ₀`. We define a new\n    -- collection of representatives `l'` to apply the induction hypothesis on later. The collection\n    -- of representatives `l'` is derived from `l` by multiplying the coefficient of the eigenvector\n    -- with eigenvalue `μ` by `μ - μ₀`.\n    · let l' := dfinsupp.map_range.linear_map (fun μ => «expr • » (μ - μ₀) (@linear_map.id K (f.eigenspace μ) _ _ _)) l\n      -- The support of `l'` is the support of `l` without `μ₀`.\n      have h_l_support' : l'.support = l_support' :=\n        by\n        rw [← Finset.erase_insert hμ₀, ← h_l_support]\n        ext a\n        have : ¬(a = μ₀ ∨ l a = 0) ↔ ¬a = μ₀ ∧ ¬l a = 0 := not_or\n        simp only [l', dfinsupp.map_range.linear_map_apply, dfinsupp.map_range_apply, dfinsupp.mem_support_iff,\n          Finset.mem_erase, id.def, linear_map.id_coe, linear_map.smul_apply, ne.def, smul_eq_zero, sub_eq_zero, this]\n      -- The entries of `l'` add up to `0`.\n      have total_l' : S l' = 0 := by\n        let g := f - algebra_map K (End K V) μ₀\n        let a : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" V :=\n          dfinsupp.map_range.linear_map (fun μ => (f.eigenspace μ).subtype) l\n        calc\n          S l' = dfinsupp.lsum ℕ (fun μ => (f.eigenspace μ).subtype.comp («expr • » (μ - μ₀) linear_map.id)) l := _\n          _ = dfinsupp.lsum ℕ (fun μ => g.comp (f.eigenspace μ).subtype) l := _\n          _ = dfinsupp.lsum ℕ (fun μ => g) a := _\n          _ = g (dfinsupp.lsum ℕ (fun μ => (linear_map.id : «expr →ₗ[ ] » V K V)) a) := _\n          _ = g (S l) := _\n          _ = 0 := by rw [hl, g.map_zero]\n          \n        · exact dfinsupp.sum_map_range_index.linear_map\n        · congr\n          ext (μ v)\n          simp only [g, eq_self_iff_true, Function.comp_apply, id.def, linear_map.coe_comp, linear_map.id_coe,\n            linear_map.smul_apply, linear_map.sub_apply, module.algebra_map_End_apply, sub_left_inj, sub_smul,\n            submodule.coe_smul_of_tower, submodule.coe_sub, submodule.subtype_apply, mem_eigenspace_iff.1 v.prop]\n        · rw [dfinsupp.sum_map_range_index.linear_map]\n        ·\n          simp only [dfinsupp.sum_add_hom_apply, linear_map.id_coe, linear_map.map_dfinsupp_sum, id.def,\n            linear_map.to_add_monoid_hom_coe, dfinsupp.lsum_apply_apply]\n        · congr\n          simp only [S, a, dfinsupp.sum_map_range_index.linear_map, linear_map.id_comp]\n      -- Therefore, by the induction hypothesis, all entries of `l'` are zero.\n      have l'_eq_0 := ih l' total_l' h_l_support'\n      -- By the definition of `l'`, this means that `(μ - μ₀) • l μ = 0` for all `μ`.\n      have h_smul_eq_0 : ∀ μ, «expr • » (μ - μ₀) (l μ) = 0 :=\n        by\n        intro μ\n        calc\n          «expr • » (μ - μ₀) (l μ) = l' μ := by\n            simp only [l', linear_map.id_coe, id.def, linear_map.smul_apply, dfinsupp.map_range_apply,\n              dfinsupp.map_range.linear_map_apply]\n          _ = 0 := by\n            rw [l'_eq_0]\n            rfl\n          \n      -- Thus, the eigenspace-representatives in `l` for all `μ ≠ μ₀` are `0`.\n      have h_lμ_eq_0 : ∀ μ : K, μ ≠ μ₀ → l μ = 0 := by\n        intro μ hμ\n        apply or_iff_not_imp_left.1 (smul_eq_zero.1 (h_smul_eq_0 μ))\n        rwa [sub_eq_zero]\n      -- So if we sum over all these representatives, we obtain `0`.\n      have h_sum_l_support'_eq_0 : (finset.sum l_support' fun μ => (l μ : V)) = 0 :=\n        by\n        rw [← finset.sum_const_zero]\n        apply finset.sum_congr rfl\n        intro μ hμ\n        rw [submodule.coe_eq_zero, h_lμ_eq_0]\n        rintro rfl\n        exact hμ₀ hμ\n      -- The only potentially nonzero eigenspace-representative in `l` is the one corresponding to\n      -- `μ₀`. But since the overall sum is `0` by assumption, this representative must also be `0`.\n      have : l μ₀ = 0 :=\n        by\n        simp only [S, dfinsupp.lsum_apply_apply, dfinsupp.sum_add_hom_apply, linear_map.to_add_monoid_hom_coe,\n          dfinsupp.sum, h_l_support, submodule.subtype_apply, submodule.coe_eq_zero, finset.sum_insert hμ₀,\n          h_sum_l_support'_eq_0, add_zero] at hl\n        exact hl\n      -- Thus, all coefficients in `l` are `0`.\n      show l = 0\n      · ext μ\n        by_cases h_cases : μ = μ₀\n        · rwa [h_cases, SetLike.coe_eq_coe, dfinsupp.coe_zero, pi.zero_apply]\n        exact congr_arg (coe : _ → V) (h_lμ_eq_0 μ h_cases)\n#align eigenspaces_independent eigenspaces_independent\n\n",
 "eigenspace_zero":
 "/-\nCopyright (c) 2020 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp\n-/\n@[simp]\ntheorem eigenspace_zero (f : End R M) : f.eigenspace 0 = f.ker := by simp [eigenspace]\n#align eigenspace_zero eigenspace_zero\n\n",
 "eigenspace_restrict_le_eigenspace":
 "/-- If `p` is an invariant submodule of an endomorphism `f`, then the `μ`-eigenspace of the\nrestriction of `f` to `p` is a submodule of the `μ`-eigenspace of `f`. -/\ntheorem eigenspace_restrict_le_eigenspace (f : End R M) {p : submodule R M} (hfp : ∀ x ∈ p, f x ∈ p) (μ : R) :\n    (eigenspace (f.restrict hfp) μ).map p.subtype ≤ f.eigenspace μ :=\n  by\n  rintro a ⟨x, hx, rfl⟩\n  simp only [SetLike.mem_coe, mem_eigenspace_iff, linear_map.restrict_apply] at hx⊢\n  exact congr_arg coe hx\n#align eigenspace_restrict_le_eigenspace eigenspace_restrict_le_eigenspace\n\n",
 "eigenspace_restrict_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If an invariant subspace `p` of an endomorphism `f` is disjoint from the `μ`-eigenspace of `f`,\nthen the restriction of `f` to `p` has trivial `μ`-eigenspace. -/\ntheorem eigenspace_restrict_eq_bot {f : End R M} {p : submodule R M} (hfp : ∀ x ∈ p, f x ∈ p) {μ : R}\n    (hμp : Disjoint (f.eigenspace μ) p) : eigenspace (f.restrict hfp) μ = «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  intro x hx\n  simpa using hμp.le_bot ⟨eigenspace_restrict_le_eigenspace f hfp μ ⟨x, hx, rfl⟩, x.prop⟩\n#align eigenspace_restrict_eq_bot eigenspace_restrict_eq_bot\n\n",
 "eigenspace_le_generalized_eigenspace":
 "/-- The eigenspace is a subspace of the generalized eigenspace. -/\ntheorem eigenspace_le_generalized_eigenspace {f : End R M} {μ : R} {k : ℕ} (hk : 0 < k) :\n    f.eigenspace μ ≤ f.generalized_eigenspace μ k :=\n  (f.generalized_eigenspace μ).monotone (nat.succ_le_of_lt hk)\n#align eigenspace_le_generalized_eigenspace eigenspace_le_generalized_eigenspace\n\n",
 "eigenspace_div":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem eigenspace_div (f : End K V) (a b : K) (hb : b ≠ 0) :\n    eigenspace f (a / b) = («expr • » b f - algebra_map K (End K V) a).ker :=\n  calc\n    eigenspace f (a / b) = eigenspace f (b⁻¹ * a) := by rw [div_eq_mul_inv, mul_comm]\n    _ = (f - «expr • » (b⁻¹ * a) linear_map.id).ker := rfl\n    _ = (f - «expr • » b⁻¹ («expr • » a linear_map.id)).ker := by rw [smul_smul]\n    _ = (f - «expr • » b⁻¹ (algebra_map K (End K V) a)).ker := rfl\n    _ = («expr • » b (f - «expr • » b⁻¹ (algebra_map K (End K V) a))).ker := by rw [linear_map.ker_smul _ b hb]\n    _ = («expr • » b f - algebra_map K (End K V) a).ker := by rw [smul_sub, smul_inv_smul₀ hb]\n    \n#align eigenspace_div eigenspace_div\n\n",
 "eigenspace_aeval_polynomial_degree_1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eigenspace_aeval_polynomial_degree_1 (f : End K V) (q : polynomial K) (hq : degree q = 1) :\n    eigenspace f (-q.coeff 0 / q.leading_coeff) = (aeval f q).ker :=\n  calc\n    eigenspace f (-q.coeff 0 / q.leading_coeff) =\n        («expr • » q.leading_coeff f - algebra_map K (End K V) (-q.coeff 0)).ker :=\n      by\n      rw [eigenspace_div]\n      intro h\n      rw [leading_coeff_eq_zero_iff_deg_eq_bot.1 h] at hq\n      cases hq\n    _ = (aeval f (C q.leading_coeff * X + C (q.coeff 0))).ker :=\n      by\n      rw [C_mul', aeval_def]\n      simp [algebra_map, algebra.to_ring_hom]\n    _ = (aeval f q).ker := by rwa [← eq_X_add_C_of_degree_eq_one]\n    \n#align eigenspace_aeval_polynomial_degree_1 eigenspace_aeval_polynomial_degree_1\n\n",
 "apply_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem has_eigenvector.apply_eq_smul {f : End R M} {μ : R} {x : M} (hx : f.has_eigenvector μ x) :\n    f x = «expr • » μ x :=\n  mem_eigenspace_iff.mp hx.1\n#align has_eigenvector.apply_eq_smul has_eigenvector.apply_eq_smul\n\n",
 "aeval_apply_of_has_eigenvector":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem aeval_apply_of_has_eigenvector {f : End K V} {p : polynomial K} {μ : K} {x : V} (h : f.has_eigenvector μ x) :\n    aeval f p x = «expr • » (p.eval μ) x := by\n  apply p.induction_on\n  · intro a\n    simp [module.algebra_map_End_apply]\n  · intro p q hp hq\n    simp [hp, hq, add_smul]\n  · intro n a hna\n    rw [mul_comm, pow_succ, mul_assoc, alg_hom.map_mul, linear_map.mul_apply, mul_comm, hna]\n    simp only [mem_eigenspace_iff.1 h.1, smul_smul, aeval_X, eval_mul, eval_C, eval_pow, eval_X, linear_map.map_smulₛₗ,\n      RingHom.id_apply, mul_comm]\n#align aeval_apply_of_has_eigenvector aeval_apply_of_has_eigenvector\n\n"}