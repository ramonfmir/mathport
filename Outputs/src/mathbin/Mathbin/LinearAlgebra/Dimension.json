{"union_support_maximal_linear_independent_eq_range_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n-- One might hope that a finite spanning set implies that any linearly independent set is finite.\n-- While this is true over a division ring\n-- (simply because any linearly independent set can be extended to a basis),\n-- I'm not certain what more general statements are possible.\n-- We'll work by contradiction, assuming `ι` is infinite.\n-- Let `S` be the union of the supports of `x ∈ w` expressed as linear combinations of `b`.\n-- This is a finite set since `w` is finite.\n-- Thus this finite subset of the basis elements spans the entire module.\n-- Now there is some `x : ι` not in `S`, since `ι` is infinite.\n-- However it must be in the span of the finite subset,\n-- giving the desire contradiction.\n-- From [Les familles libres maximales d'un module ont-elles le meme cardinal?][lazarus1973]\n/-- Over any ring `R`, if `b` is a basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the union of the supports of `x ∈ s` (when written out in the basis `b`) is all of `b`.\n-/\ntheorem union_support_maximal_linear_independent_eq_range_basis {ι : Type w} (b : basis ι R M) {κ : Type w'} (v : κ → M)\n    (i : linear_independent R v) (m : i.maximal) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ((b.repr (v k)).support : set ι) =\n      univ :=\n  by\n  -- If that's not the case,\n  by_contra h\n  simp only [← ne.def, ne_univ_iff_exists_not_mem, mem_Union, not_exists_not, finsupp.mem_support_iff,\n    Finset.mem_coe] at h\n  -- We have some basis element `b b'` which is not in the support of any of the `v i`.\n  obtain ⟨b', w⟩ := h\n  -- Using this, we'll construct a linearly independent family strictly larger than `v`,\n  -- by also using this `b b'`.\n  let v' : option κ → M := fun o => o.elim (b b') v\n  have r : range v ⊆ range v' := by\n    rintro - ⟨k, rfl⟩\n    use some k\n    rfl\n  have r' : b b' ∉ range v := by\n    rintro ⟨k, p⟩\n    simpa [w] using congr_arg (fun m => (b.repr m) b') p\n  have r'' : range v ≠ range v' := by\n    intro e\n    have p : b b' ∈ range v' := by\n      use none\n      rfl\n    rw [← e] at p\n    exact r' p\n  have inj' : injective v' := by\n    rintro (_ | k) (_ | k) z\n    · rfl\n    · exfalso\n      exact r' ⟨k, z.symm⟩\n    · exfalso\n      exact r' ⟨k, z⟩\n    · congr\n      exact i.injective z\n  -- The key step in the proof is checking that this strictly larger family is linearly independent.\n  have i' : linear_independent R (coe : range v' → M) :=\n    by\n    rw [linear_independent_subtype_range inj', linear_independent_iff]\n    intro l z\n    rw [finsupp.total_option] at z\n    simp only [v', Option.elim'] at z\n    change _ + finsupp.total κ M R v l.some = 0 at z\n    -- We have some linear combination of `b b'` and the `v i`, which we want to show is trivial.\n    -- We'll first show the coefficient of `b b'` is zero,\n    -- by expressing the `v i` in the basis `b`, and using that the `v i` have no `b b'` term.\n    have l₀ : l none = 0 := by\n      rw [← eq_neg_iff_add_eq_zero] at z\n      replace z := eq_neg_of_eq_neg z\n      apply_fun fun x => b.repr x b'  at z\n      simp only [repr_self, linear_equiv.map_smul, mul_one, finsupp.single_eq_same, pi.neg_apply, finsupp.smul_single',\n        linear_equiv.map_neg, finsupp.coe_neg] at z\n      erw [finsupp.congr_fun (finsupp.apply_total R (b.repr : «expr →ₗ[ ] » M R («expr →₀ » ι R)) v l.some) b'] at z\n      simpa [finsupp.total_apply, w] using z\n    -- Then all the other coefficients are zero, because `v` is linear independent.\n    have l₁ : l.some = 0 := by\n      rw [l₀, zero_smul, zero_add] at z\n      exact linear_independent_iff.mp i _ z\n    -- Finally we put those facts together to show the linear combination is trivial.\n    ext (_ | a)\n    · simp only [l₀, finsupp.coe_zero, pi.zero_apply]\n    · erw [finsupp.congr_fun l₁ a]\n      simp only [finsupp.coe_zero, pi.zero_apply]\n  dsimp [linear_independent.maximal] at m\n  specialize m (range v') i' r\n  exact r'' m\n#align union_support_maximal_linear_independent_eq_range_basis union_support_maximal_linear_independent_eq_range_basis\n\n",
 "subtype_ne_bot_le_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem complete_lattice.independent.subtype_ne_bot_le_rank [NoZeroSMulDivisors R M] {V : ι → submodule R M}\n    (hV : complete_lattice.independent V) :\n    cardinal.lift.{v} (cardinal.mk { i : ι // V i ≠ «expr⊥» }) ≤ cardinal.lift.{w} (module.rank R M) :=\n  by\n  set I := { i : ι // V i ≠ «expr⊥» }\n  have hI : ∀ i : I, ∃ v ∈ V i, v ≠ (0 : M) := by\n    intro i\n    rw [← submodule.ne_bot_iff]\n    exact i.prop\n  choose v hvV hv using hI\n  have : linear_independent R v := (hV.comp subtype.coe_injective).linear_independent _ hvV hv\n  exact cardinal_lift_le_dim_of_linear_independent' this\n#align complete_lattice.independent.subtype_ne_bot_le_rank complete_lattice.independent.subtype_ne_bot_le_rank\n\n",
 "set_finite_of_is_noetherian":
 "theorem linear_independent.set_finite_of_is_noetherian [is_noetherian R M] {s : set M}\n    (hi : linear_independent R (coe : s → M)) : s.finite :=\n  @set.to_finite _ _ hi.finite_of_is_noetherian\n#align linear_independent.set_finite_of_is_noetherian linear_independent.set_finite_of_is_noetherian\n\n",
 "rank_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem rank_zero [nontrivial K] : rank (0 : «expr →ₗ[ ] » V K V') = 0 := by rw [rank, linear_map.range_zero, dim_bot]\n#align rank_zero rank_zero\n\n",
 "rank_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_le_range (f : «expr →ₗ[ ] » V K V₁) : rank f ≤ module.rank K V₁ :=\n  dim_submodule_le _\n#align rank_le_range rank_le_range\n\n",
 "rank_le_one_iff_top_is_principal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem module.rank_le_one_iff_top_is_principal : module.rank K V ≤ 1 ↔ («expr⊤» : submodule K V).is_principal := by\n  rw [← submodule.rank_le_one_iff_is_principal, dim_top]\n#align module.rank_le_one_iff_top_is_principal module.rank_le_one_iff_top_is_principal\n\n",
 "rank_le_one_iff_is_principal":
 "theorem submodule.rank_le_one_iff_is_principal (W : submodule K V) : module.rank K W ≤ 1 ↔ W.is_principal :=\n  by\n  simp only [dim_le_one_iff, submodule.is_principal_iff, le_antisymm_iff, le_span_singleton_iff,\n    span_singleton_le_iff_mem]\n  constructor\n  · rintro ⟨⟨m, hm⟩, hm'⟩\n    choose f hf using hm'\n    exact ⟨m, ⟨fun v hv => ⟨f ⟨v, hv⟩, congr_arg coe (hf ⟨v, hv⟩)⟩, hm⟩⟩\n  · rintro ⟨a, ⟨h, ha⟩⟩\n    choose f hf using h\n    exact ⟨⟨a, ha⟩, fun v => ⟨f v.1 v.2, subtype.ext (hf v.1 v.2)⟩⟩\n#align submodule.rank_le_one_iff_is_principal submodule.rank_le_one_iff_is_principal\n\n",
 "rank_le_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_le_domain (f : «expr →ₗ[ ] » V K V₁) : rank f ≤ module.rank K V :=\n  by\n  rw [← dim_range_add_dim_ker f]\n  exact self_le_add_right _ _\n#align rank_le_domain rank_le_domain\n\n",
 "rank_finset_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem rank_finset_sum_le {η} (s : Finset η) (f : η → «expr →ₗ[ ] » V K V') :\n    rank (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f d)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (rank (f d)) :=\n  @finset.sum_hom_rel _ _ _ _ _ (fun a b => rank a ≤ b) f (fun d => rank (f d)) s (le_of_eq rank_zero) fun i g c h =>\n    le_trans (rank_add_le _ _) (add_le_add_left h _)\n#align rank_finset_sum_le rank_finset_sum_le\n\n",
 "rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `S` a finite-dimensional ring extension of `R` which is free as an `R`-module,\nthen the rank of an ideal `I` of `S` over `R` is the same as the rank of `S`.\n-/\ntheorem ideal.rank_eq {R S : Type _} [CommRing R] [strong_rank_condition R] [Ring S] [IsDomain S] [algebra R S]\n    {n m : Type _} [fintype n] [fintype m] (b : basis n R S) {I : ideal S} (hI : I ≠ «expr⊥») (c : basis m R I) :\n    fintype.card m = fintype.card n :=\n  by\n  obtain ⟨a, ha⟩ := submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr hI)\n  have : linear_independent R fun i => «expr • » (b i) a :=\n    by\n    have hb := b.linear_independent\n    rw [fintype.linear_independent_iff] at hb⊢\n    intro g hg\n    apply hb g\n    simp only [← smul_assoc, ← finset.sum_smul, smul_eq_zero] at hg\n    exact hg.resolve_right ha\n  exact\n    le_antisymm\n      (b.card_le_card_of_linear_independent\n        (c.linear_independent.map' (submodule.subtype I) (linear_map.ker_eq_bot.mpr subtype.coe_injective)))\n      (c.card_le_card_of_linear_independent this)\n#align ideal.rank_eq ideal.rank_eq\n\n",
 "rank_comp_le2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_comp_le2 (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'₁) : rank (f.comp g) ≤ rank g := by\n  rw [rank, rank, linear_map.range_comp] <;> exact dim_map_le _ _\n#align rank_comp_le2 rank_comp_le2\n\n",
 "rank_comp_le1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_comp_le1 (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'') : rank (f.comp g) ≤ rank f :=\n  by\n  refine' dim_le_of_submodule _ _ _\n  rw [linear_map.range_comp]\n  exact linear_map.map_le_range\n#align rank_comp_le1 rank_comp_le1\n\n",
 "rank_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_add_le (f g : «expr →ₗ[ ] » V K V') : rank (f + g) ≤ rank f + rank g :=\n  calc\n    rank (f + g) ≤ module.rank K («expr ⊔ » f.range g.range : submodule K V') :=\n      by\n      refine' dim_le_of_submodule _ _ _\n      exact\n        linear_map.range_le_iff_comap.2 <|\n          eq_top_iff'.2 fun x =>\n            show f x + g x ∈ («expr ⊔ » f.range g.range : submodule K V') from mem_sup.2 ⟨_, ⟨x, rfl⟩, _, ⟨x, rfl⟩, rfl⟩\n    _ ≤ rank f + rank g := dim_add_le_dim_add_dim _ _\n    \n#align rank_add_le rank_add_le\n\n",
 "of_dim_eq_zero_apply":
 "@[simp]\ntheorem basis.of_dim_eq_zero_apply {ι : Type _} [is_empty ι] (hV : module.rank K V = 0) (i : ι) :\n    basis.of_dim_eq_zero hV i = 0 :=\n  rfl\n#align basis.of_dim_eq_zero_apply basis.of_dim_eq_zero_apply\n\n",
 "nonempty_linear_equiv_of_lift_dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two vector spaces are isomorphic if they have the same dimension. -/\ntheorem nonempty_linear_equiv_of_lift_dim_eq\n    (cond : cardinal.lift.{v'} (module.rank K V) = cardinal.lift.{v} (module.rank K V')) :\n    nonempty («expr ≃ₗ[ ] » V K V') := by\n  let B := basis.of_vector_space K V\n  let B' := basis.of_vector_space K V'\n  have : cardinal.lift.{v', v} (cardinal.mk _) = cardinal.lift.{v, v'} (cardinal.mk _) := by\n    rw [B.mk_eq_dim'', cond, B'.mk_eq_dim'']\n  exact (cardinal.lift_mk_eq.{v, v', 0}.1 this).map (B.equiv B')\n#align nonempty_linear_equiv_of_lift_dim_eq nonempty_linear_equiv_of_lift_dim_eq\n\n",
 "nonempty_linear_equiv_of_dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two vector spaces are isomorphic if they have the same dimension. -/\ntheorem nonempty_linear_equiv_of_dim_eq (cond : module.rank K V = module.rank K V₁) : nonempty («expr ≃ₗ[ ] » V K V₁) :=\n  nonempty_linear_equiv_of_lift_dim_eq <| congr_arg _ cond\n#align nonempty_linear_equiv_of_dim_eq nonempty_linear_equiv_of_dim_eq\n\n",
 "nonempty_fintype_index_of_dim_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If a module has a finite dimension, all bases are indexed by a finite type. -/\ntheorem basis.nonempty_fintype_index_of_dim_lt_aleph_0 {ι : Type _} (b : basis ι R M)\n    (h : module.rank R M < cardinal.aleph_0) : nonempty (fintype ι) := by\n  rwa [← cardinal.lift_lt, ←\n    b.mk_eq_dim,-- ensure `aleph_0` has the correct universe\n    cardinal.lift_aleph_0,\n    ← cardinal.lift_aleph_0.{u_1, v}, cardinal.lift_lt, cardinal.lt_aleph_0_iff_fintype] at h\n#align basis.nonempty_fintype_index_of_dim_lt_aleph_0 basis.nonempty_fintype_index_of_dim_lt_aleph_0\n\n",
 "nonempty_equiv_iff_lift_dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem linear_equiv.nonempty_equiv_iff_lift_dim_eq :\n    nonempty («expr ≃ₗ[ ] » V K V') ↔ cardinal.lift.{v'} (module.rank K V) = cardinal.lift.{v} (module.rank K V') :=\n  ⟨fun ⟨h⟩ => linear_equiv.lift_dim_eq h, fun h => nonempty_linear_equiv_of_lift_dim_eq h⟩\n#align linear_equiv.nonempty_equiv_iff_lift_dim_eq linear_equiv.nonempty_equiv_iff_lift_dim_eq\n\n",
 "nonempty_equiv_iff_dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem linear_equiv.nonempty_equiv_iff_dim_eq : nonempty («expr ≃ₗ[ ] » V K V₁) ↔ module.rank K V = module.rank K V₁ :=\n  ⟨fun ⟨h⟩ => linear_equiv.dim_eq h, fun h => nonempty_linear_equiv_of_dim_eq h⟩\n#align linear_equiv.nonempty_equiv_iff_dim_eq linear_equiv.nonempty_equiv_iff_dim_eq\n\n",
 "mk_range_eq_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem basis.mk_range_eq_dim (v : basis ι R M) : cardinal.mk (range v) = module.rank R M :=\n  v.reindex_range.mk_eq_dim''\n#align basis.mk_range_eq_dim basis.mk_range_eq_dim\n\n",
 "mk_eq_mk_of_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem mk_eq_mk_of_basis' {ι' : Type w} (v : basis ι R M) (v' : basis ι' R M) : cardinal.mk ι = cardinal.mk ι' :=\n  cardinal.lift_inj.1 <| mk_eq_mk_of_basis v v'\n#align mk_eq_mk_of_basis' mk_eq_mk_of_basis'\n\n",
 "mk_eq_mk_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The dimension theorem: if `v` and `v'` are two bases, their index types\nhave the same cardinalities. -/\ntheorem mk_eq_mk_of_basis (v : basis ι R M) (v' : basis ι' R M) :\n    cardinal.lift.{w'} (cardinal.mk ι) = cardinal.lift.{w} (cardinal.mk ι') :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  cases fintype_or_infinite ι\n  · -- `v` is a finite basis, so by `basis_fintype_of_finite_spans` so is `v'`.\n    haveI : fintype (range v) := set.fintype_range v\n    haveI := basis_fintype_of_finite_spans _ v.span_eq v'\n    -- We clean up a little:\n    rw [cardinal.mk_fintype, cardinal.mk_fintype]\n    simp only [cardinal.lift_nat_cast, cardinal.nat_cast_inj]\n    -- Now we can use invariant basis number to show they have the same cardinality.\n    apply card_eq_of_lequiv R\n    exact\n      «expr ≪≫ₗ » («expr ≪≫ₗ » ((finsupp.linear_equiv_fun_on_finite R R ι).symm.trans v.repr.symm) v'.repr)\n        (finsupp.linear_equiv_fun_on_finite R R ι')\n  · -- `v` is an infinite basis,\n    -- so by `infinite_basis_le_maximal_linear_independent`, `v'` is at least as big,\n    -- and then applying `infinite_basis_le_maximal_linear_independent` again\n    -- we see they have the same cardinality.\n    have w₁ := infinite_basis_le_maximal_linear_independent' v _ v'.linear_independent v'.maximal\n    rcases cardinal.lift_mk_le'.mp w₁ with ⟨f⟩\n    haveI : Infinite ι' := infinite.of_injective f f.2\n    have w₂ := infinite_basis_le_maximal_linear_independent' v' _ v.linear_independent v.maximal\n    exact le_antisymm w₁ w₂\n#align mk_eq_mk_of_basis mk_eq_mk_of_basis\n\n",
 "mk_eq_dim''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem basis.mk_eq_dim'' {ι : Type v} (v : basis ι R M) : cardinal.mk ι = module.rank R M :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  rw [module.rank]\n  apply le_antisymm\n  · trans\n    swap\n    apply le_csupᵢ (cardinal.bdd_above_range.{v, v} _)\n    exact\n      ⟨Set.range v, by\n        convert v.reindex_range.linear_independent\n        ext\n        simp⟩\n    exact (cardinal.mk_range_eq v v.injective).ge\n  · apply csupᵢ_le'\n    rintro ⟨s, li⟩\n    apply linear_independent_le_basis v _ li\n#align basis.mk_eq_dim'' basis.mk_eq_dim''\n\n",
 "mk_eq_dim'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem basis.mk_eq_dim'.{m} (v : basis ι R M) :\n    cardinal.lift.{max v m} (cardinal.mk ι) = cardinal.lift.{max w m} (module.rank R M) := by simpa using v.mk_eq_dim\n#align basis.mk_eq_dim' basis.mk_eq_dim'\n\n",
 "mk_eq_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem basis.mk_eq_dim (v : basis ι R M) : cardinal.lift.{v} (cardinal.mk ι) = cardinal.lift.{w} (module.rank R M) :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  rw [← v.mk_range_eq_dim, cardinal.mk_range_eq_of_injective v.injective]\n#align basis.mk_eq_dim basis.mk_eq_dim\n\n",
 "maximal_linear_independent_eq_infinite_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n-- When the basis is not infinite this need not be true!\n/-- Over any ring `R` satisfying the strong rank condition,\nif `b` is an infinite basis for a module `M`,\nthen every maximal linearly independent set has the same cardinality as `b`.\n\nThis proof (along with some of the lemmas above) comes from\n[Les familles libres maximales d'un module ont-elles le meme cardinal?][lazarus1973]\n-/\ntheorem maximal_linear_independent_eq_infinite_basis {ι : Type _} (b : basis ι R M) [Infinite ι] {κ : Type _}\n    (v : κ → M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk κ = cardinal.mk ι :=\n  by\n  apply le_antisymm\n  · exact linear_independent_le_basis b v i\n  · haveI : nontrivial R := nontrivial_of_invariant_basis_number R\n    exact infinite_basis_le_maximal_linear_independent b v i m\n#align maximal_linear_independent_eq_infinite_basis maximal_linear_independent_eq_infinite_basis\n\n",
 "linear_independent_le_span_aux'":
 "-- An auxiliary lemma for `linear_independent_le_span'`,\n-- with the additional assumption that the linearly independent family is finite.\ntheorem linear_independent_le_span_aux' {ι : Type _} [fintype ι] (v : ι → M) (i : linear_independent R v) (w : set M)\n    [fintype w] (s : range v ≤ span R w) : fintype.card ι ≤ fintype.card w :=\n  by\n  -- We construct an injective linear map `(ι → R) →ₗ[R] (w → R)`,\n  -- by thinking of `f : ι → R` as a linear combination of the finite family `v`,\n  -- and expressing that (using the axiom of choice) as a linear combination over `w`.\n  -- We can do this linearly by constructing the map on a basis.\n  fapply card_le_of_injective' R\n  · apply finsupp.total\n    exact fun i => span.repr R w ⟨v i, s (mem_range_self i)⟩\n  · intro f g h\n    apply_fun finsupp.total w M R coe  at h\n    simp only [finsupp.total_total, submodule.coe_mk, span.finsupp_total_repr] at h\n    rw [← sub_eq_zero, ← linear_map.map_sub] at h\n    exact sub_eq_zero.mp (linear_independent_iff.mp i _ h)\n#align linear_independent_le_span_aux' linear_independent_le_span_aux'\n\n",
 "linear_independent_le_span'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : ι → M`\ncontained in the span of some finite `w : set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem linear_independent_le_span' {ι : Type _} (v : ι → M) (i : linear_independent R v) (w : set M) [fintype w]\n    (s : range v ≤ span R w) : cardinal.mk ι ≤ fintype.card w :=\n  by\n  haveI : fintype ι := linear_independent_fintype_of_le_span_fintype v i w s\n  rw [cardinal.mk_fintype]\n  simp only [cardinal.nat_cast_le]\n  exact linear_independent_le_span_aux' v i w s\n#align linear_independent_le_span' linear_independent_le_span'\n\n",
 "linear_independent_le_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : ι → M`\nand any finite spanning set `w : set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem linear_independent_le_span {ι : Type _} (v : ι → M) (i : linear_independent R v) (w : set M) [fintype w]\n    (s : span R w = «expr⊤») : cardinal.mk ι ≤ fintype.card w :=\n  by\n  apply linear_independent_le_span' v i w\n  rw [s]\n  exact le_top\n#align linear_independent_le_span linear_independent_le_span\n\n",
 "linear_independent_le_infinite_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- An auxiliary lemma for `linear_independent_le_basis`:\nwe handle the case where the basis `b` is infinite.\n-/\ntheorem linear_independent_le_infinite_basis {ι : Type _} (b : basis ι R M) [Infinite ι] {κ : Type _} (v : κ → M)\n    (i : linear_independent R v) : cardinal.mk κ ≤ cardinal.mk ι :=\n  by\n  by_contra\n  rw [not_le, ← cardinal.mk_finset_of_infinite ι] at h\n  let Φ := fun k : κ => (b.repr (v k)).support\n  obtain ⟨s, w : Infinite («expr↥ » («expr ⁻¹' » Φ {s}))⟩ := cardinal.exists_infinite_fiber Φ h (by infer_instance)\n  let v' := fun k : «expr ⁻¹' » Φ {s} => v k\n  have i' : linear_independent R v' := i.comp _ subtype.val_injective\n  have w' : fintype («expr ⁻¹' » Φ {s}) :=\n    by\n    apply linear_independent_fintype_of_le_span_fintype v' i' (s.image b)\n    rintro m ⟨⟨p, ⟨rfl⟩⟩, rfl⟩\n    simp only [SetLike.mem_coe, subtype.coe_mk, Finset.coe_image]\n    apply basis.mem_span_repr_support\n  exact w.false\n#align linear_independent_le_infinite_basis linear_independent_le_infinite_basis\n\n",
 "linear_independent_le_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- Over any ring `R` satisfying the strong rank condition,\nif `b` is a basis for a module `M`,\nand `s` is a linearly independent set,\nthen the cardinality of `s` is bounded by the cardinality of `b`.\n-/\ntheorem linear_independent_le_basis {ι : Type _} (b : basis ι R M) {κ : Type _} (v : κ → M)\n    (i : linear_independent R v) : cardinal.mk κ ≤ cardinal.mk ι :=\n  by\n  -- We split into cases depending on whether `ι` is infinite.\n    cases fintype_or_infinite ι <;>\n    skip\n  · -- When `ι` is finite, we have `linear_independent_le_span`,\n    rw [cardinal.mk_fintype ι]\n    haveI : nontrivial R := nontrivial_of_invariant_basis_number R\n    rw [fintype.card_congr (Equiv.ofInjective b b.injective)]\n    exact linear_independent_le_span v i (range b) b.span_eq\n  ·-- and otherwise we have `linear_indepedent_le_infinite_basis`.\n    exact linear_independent_le_infinite_basis b v i\n#align linear_independent_le_basis linear_independent_le_basis\n\n",
 "lift_dim_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift_dim_range_le (f : «expr →ₗ[ ] » M R M') :\n    cardinal.lift.{v} (module.rank R f.range) ≤ cardinal.lift.{v'} (module.rank R M) :=\n  by\n  dsimp [module.rank]\n  rw [cardinal.lift_supr (cardinal.bdd_above_range.{v', v'} _)]\n  apply csupᵢ_le'\n  rintro ⟨s, li⟩\n  apply le_trans\n  swap\n  apply cardinal.lift_le.mpr\n  refine' le_csupᵢ (cardinal.bdd_above_range.{v, v} _) ⟨«expr '' » (range_splitting f) s, _⟩\n  · apply linear_independent.of_comp f.range_restrict\n    convert li.comp (Equiv.Set.rangeSplittingImageEquiv f s) (Equiv.injective _) using 1\n  · exact (cardinal.lift_mk_eq'.mpr ⟨Equiv.Set.rangeSplittingImageEquiv f s⟩).ge\n#align lift_dim_range_le lift_dim_range_le\n\n",
 "lift_dim_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift_dim_map_le (f : «expr →ₗ[ ] » M R M') (p : submodule R M) :\n    cardinal.lift.{v} (module.rank R (p.map f)) ≤ cardinal.lift.{v'} (module.rank R p) :=\n  by\n  have h := lift_dim_range_le (f.comp (submodule.subtype p))\n  rwa [linear_map.range_comp, range_subtype] at h\n#align lift_dim_map_le lift_dim_map_le\n\n",
 "lift_dim_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Johannes Hölzl, Sander Dahmen, Scott Morrison\n-/\ntheorem linear_map.lift_dim_le_of_injective (f : «expr →ₗ[ ] » M R M') (i : injective f) :\n    cardinal.lift.{v'} (module.rank R M) ≤ cardinal.lift.{v} (module.rank R M') :=\n  by\n  dsimp [module.rank]\n  rw [cardinal.lift_supr (cardinal.bdd_above_range.{v', v'} _), cardinal.lift_supr (cardinal.bdd_above_range.{v, v} _)]\n  apply csupᵢ_mono' (cardinal.bdd_above_range.{v', v} _)\n  rintro ⟨s, li⟩\n  refine' ⟨⟨«expr '' » f s, _⟩, cardinal.lift_mk_le'.mpr ⟨(Equiv.Set.image f s i).to_embedding⟩⟩\n  exact (li.map' _ <| linear_map.ker_eq_bot.mpr i).image\n#align linear_map.lift_dim_le_of_injective linear_map.lift_dim_le_of_injective\n\n",
 "lift_dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. -/\ntheorem linear_equiv.lift_dim_eq (f : «expr ≃ₗ[ ] » M R M') :\n    cardinal.lift.{v'} (module.rank R M) = cardinal.lift.{v} (module.rank R M') :=\n  by\n  apply le_antisymm\n  · exact f.to_linear_map.lift_dim_le_of_injective f.injective\n  · exact f.symm.to_linear_map.lift_dim_le_of_injective f.symm.injective\n#align linear_equiv.lift_dim_eq linear_equiv.lift_dim_eq\n\n",
 "le_span''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- An auxiliary lemma for `basis.le_span`.\n\nIf `R` satisfies the rank condition,\nthen for any finite basis `b : basis ι R M`,\nand any finite spanning set `w : set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem basis.le_span'' {ι : Type _} [fintype ι] (b : basis ι R M) {w : set M} [fintype w] (s : span R w = «expr⊤») :\n    fintype.card ι ≤ fintype.card w :=\n  by\n  -- We construct an surjective linear map `(w → R) →ₗ[R] (ι → R)`,\n  -- by expressing a linear combination in `w` as a linear combination in `ι`.\n  fapply card_le_of_surjective' R\n  · exact b.repr.to_linear_map.comp (finsupp.total w M R coe)\n  · apply surjective.comp\n    apply linear_equiv.surjective\n    rw [← linear_map.range_eq_top, finsupp.range_total]\n    simpa using s\n#align basis.le_span'' basis.le_span''\n\n",
 "le_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n-- Note that if `R` satisfies the strong rank condition,\n-- this also follows from `linear_independent_le_span` below.\n/-- If `R` satisfies the rank condition,\nthen the cardinality of any basis is bounded by the cardinality of any spanning set.\n-/\ntheorem basis.le_span {J : set M} (v : basis ι R M) (hJ : span R J = «expr⊤») : cardinal.mk (range v) ≤ cardinal.mk J :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  cases fintype_or_infinite J\n  · rw [← cardinal.lift_le, cardinal.mk_range_eq_of_injective v.injective, cardinal.mk_fintype J]\n    convert cardinal.lift_le.{w, v}.2 (basis_le_span' v hJ)\n    simp\n  · have := cardinal.mk_range_eq_of_injective v.injective\n    let S : J → set ι := fun j => ↑(v.repr j).support\n    let S' : J → set M := fun j => «expr '' » v (S j)\n    have hs :\n      range v ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S' j) :=\n      by\n      intro b hb\n      rcases mem_range.1 hb with ⟨i, hi⟩\n      have :\n        span R J ≤\n          comap v.repr.to_linear_map\n            (finsupp.supported R R\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (S j))) :=\n        span_le.2 fun j hj x hx => ⟨_, ⟨⟨j, hj⟩, rfl⟩, hx⟩\n      rw [hJ] at this\n      replace :\n        v.repr (v i) ∈\n          finsupp.supported R R\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S j)) :=\n        this trivial\n      rw [v.repr_self, finsupp.mem_supported, finsupp.support_single_ne_zero _ one_ne_zero] at this\n      · subst b\n        rcases mem_Union.1 (this (Finset.mem_singleton_self _)) with ⟨j, hj⟩\n        exact mem_Union.2 ⟨j, (mem_image _ _ _).2 ⟨i, hj, rfl⟩⟩\n      · infer_instance\n    refine' le_of_not_lt fun IJ => _\n    suffices\n      cardinal.mk\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S' j)) <\n        cardinal.mk (range v)\n      by exact not_le_of_lt this ⟨Set.embeddingOfSubset _ _ hs⟩\n    refine'\n      lt_of_le_of_lt (le_trans cardinal.mk_Union_le_sum_mk (cardinal.sum_le_sum _ (fun _ => cardinal.aleph_0) _)) _\n    · exact fun j => (cardinal.lt_aleph_0_of_finite _).le\n    · simpa\n#align basis.le_span basis.le_span\n\n",
 "le_rank_iff_exists_linear_independent_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem le_rank_iff_exists_linear_independent_finset {n : ℕ} {f : «expr →ₗ[ ] » V K V'} :\n    ↑n ≤ rank f ↔ ∃ s : Finset V, s.card = n ∧ linear_independent K fun x : (s : set V) => f x :=\n  by\n  simp only [le_rank_iff_exists_linear_independent, cardinal.lift_nat_cast, cardinal.lift_eq_nat_iff,\n    cardinal.mk_set_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩\n    exact ⟨t, rfl, si⟩\n  · rintro ⟨s, rfl, si⟩\n    exact ⟨s, ⟨s, rfl, rfl⟩, si⟩\n#align le_rank_iff_exists_linear_independent_finset le_rank_iff_exists_linear_independent_finset\n\n",
 "le_rank_iff_exists_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_rank_iff_exists_linear_independent {c : cardinal} {f : «expr →ₗ[ ] » V K V'} :\n    c ≤ rank f ↔\n      ∃ s : set V, cardinal.lift.{v'} (cardinal.mk s) = cardinal.lift.{v} c ∧ linear_independent K fun x : s => f x :=\n  by\n  rcases f.range_restrict.exists_right_inverse_of_surjective f.range_range_restrict with ⟨g, hg⟩\n  have fg : left_inverse f.range_restrict g := linear_map.congr_fun hg\n  refine' ⟨fun h => _, _⟩\n  · rcases le_dim_iff_exists_linear_independent.1 h with ⟨s, rfl, si⟩\n    refine' ⟨«expr '' » g s, cardinal.mk_image_eq_lift _ _ fg.injective, _⟩\n    replace fg : ∀ x, f (g x) = x\n    · intro x\n      convert congr_arg subtype.val (fg x)\n    replace si : linear_independent K fun x : s => f (g x)\n    · simpa only [fg] using si.map' _ (ker_subtype _)\n    exact si.image_of_comp s g f\n  · rintro ⟨s, hsc, si⟩\n    have : linear_independent K fun x : s => f.range_restrict x :=\n      linear_independent.of_comp f.range.subtype (by convert si)\n    convert cardinal_le_dim_of_linear_independent this.image\n    rw [← cardinal.lift_inj, ← hsc, cardinal.mk_image_eq_of_inj_on_lift]\n    exact inj_on_iff_injective.2 this.injective\n#align le_rank_iff_exists_linear_independent le_rank_iff_exists_linear_independent\n\n",
 "le_dim_iff_exists_linear_independent_finset":
 "theorem le_dim_iff_exists_linear_independent_finset {n : ℕ} :\n    ↑n ≤ module.rank K V ↔ ∃ s : Finset V, s.card = n ∧ linear_independent K (coe : (s : set V) → V) :=\n  by\n  simp only [le_dim_iff_exists_linear_independent, cardinal.mk_set_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩\n    exact ⟨t, rfl, si⟩\n  · rintro ⟨s, rfl, si⟩\n    exact ⟨s, ⟨s, rfl, rfl⟩, si⟩\n#align le_dim_iff_exists_linear_independent_finset le_dim_iff_exists_linear_independent_finset\n\n",
 "le_dim_iff_exists_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem le_dim_iff_exists_linear_independent {c : cardinal} :\n    c ≤ module.rank K V ↔ ∃ s : set V, cardinal.mk s = c ∧ linear_independent K (coe : s → V) :=\n  by\n  constructor\n  · intro h\n    let t := basis.of_vector_space K V\n    rw [← t.mk_eq_dim'', cardinal.le_mk_iff_exists_subset] at h\n    rcases h with ⟨s, hst, hsc⟩\n    exact ⟨s, hsc, (of_vector_space_index.linear_independent K V).mono hst⟩\n  · rintro ⟨s, rfl, si⟩\n    exact cardinal_le_dim_of_linear_independent si\n#align le_dim_iff_exists_linear_independent le_dim_iff_exists_linear_independent\n\n",
 "infinite_basis_le_maximal_linear_independent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- Over any ring `R`, if `b` is an infinite basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the cardinality of `b` is bounded by the cardinality of `s`.\n-/\ntheorem infinite_basis_le_maximal_linear_independent' {ι : Type w} (b : basis ι R M) [Infinite ι] {κ : Type w'}\n    (v : κ → M) (i : linear_independent R v) (m : i.maximal) :\n    cardinal.lift.{w'} (cardinal.mk ι) ≤ cardinal.lift.{w} (cardinal.mk κ) :=\n  by\n  let Φ := fun k : κ => (b.repr (v k)).support\n  have w₁ : cardinal.mk ι ≤ cardinal.mk (Set.range Φ) :=\n    by\n    apply cardinal.le_range_of_union_finset_eq_top\n    exact union_support_maximal_linear_independent_eq_range_basis b v i m\n  have w₂ : cardinal.lift.{w'} (cardinal.mk (Set.range Φ)) ≤ cardinal.lift.{w} (cardinal.mk κ) :=\n    cardinal.mk_range_le_lift\n  exact (cardinal.lift_le.mpr w₁).trans w₂\n#align infinite_basis_le_maximal_linear_independent' infinite_basis_le_maximal_linear_independent'\n\n",
 "infinite_basis_le_maximal_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n-- (See `infinite_basis_le_maximal_linear_independent'` for the more general version\n-- where the index types can live in different universes.)\n/-- Over any ring `R`, if `b` is an infinite basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the cardinality of `b` is bounded by the cardinality of `s`.\n-/\ntheorem infinite_basis_le_maximal_linear_independent {ι : Type w} (b : basis ι R M) [Infinite ι] {κ : Type w}\n    (v : κ → M) (i : linear_independent R v) (m : i.maximal) : cardinal.mk ι ≤ cardinal.mk κ :=\n  cardinal.lift_le.mp (infinite_basis_le_maximal_linear_independent' b v i m)\n#align infinite_basis_le_maximal_linear_independent infinite_basis_le_maximal_linear_independent\n\n",
 "finite_of_vector_space_index_of_dim_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If a vector space has a finite dimension, the index set of `basis.of_vector_space` is finite. -/\ntheorem basis.finite_of_vector_space_index_of_dim_lt_aleph_0 (h : module.rank K V < cardinal.aleph_0) :\n    (basis.of_vector_space_index K V).finite :=\n  finite_def.2 <| (basis.of_vector_space K V).nonempty_fintype_index_of_dim_lt_aleph_0 h\n#align basis.finite_of_vector_space_index_of_dim_lt_aleph_0 basis.finite_of_vector_space_index_of_dim_lt_aleph_0\n\n",
 "finite_of_is_noetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A linearly-independent family of vectors in a module over a non-trivial ring must be finite if\nthe module is Noetherian. -/\ntheorem linear_independent.finite_of_is_noetherian [is_noetherian R M] {v : ι → M} (hv : linear_independent R v) :\n    Finite ι := by\n  have hwf := is_noetherian_iff_well_founded.mp (by infer_instance : is_noetherian R M)\n  refine' complete_lattice.well_founded.finite_of_independent hwf hv.independent_span_singleton fun i contra => _\n  apply hv.ne_zero i\n  have : v i ∈ «expr ∙ » R (v i) := submodule.mem_span_singleton_self (v i)\n  rwa [contra, submodule.mem_bot] at this\n#align linear_independent.finite_of_is_noetherian linear_independent.finite_of_is_noetherian\n\n",
 "finite_index_of_dim_lt_aleph_0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem basis.finite_index_of_dim_lt_aleph_0 {ι : Type _} {s : set ι} (b : basis s R M)\n    (h : module.rank R M < cardinal.aleph_0) : s.finite :=\n  finite_def.2 (b.nonempty_fintype_index_of_dim_lt_aleph_0 h)\n#align basis.finite_index_of_dim_lt_aleph_0 basis.finite_index_of_dim_lt_aleph_0\n\n",
 "exists_mem_ne_zero_of_dim_pos":
 "theorem exists_mem_ne_zero_of_dim_pos {s : submodule K V} (h : 0 < module.rank K s) : ∃ b : V, b ∈ s ∧ b ≠ 0 :=\n  exists_mem_ne_zero_of_ne_bot fun eq => by rw [eq, dim_bot] at h <;> exact lt_irrefl _ h\n#align exists_mem_ne_zero_of_dim_pos exists_mem_ne_zero_of_dim_pos\n\n",
 "dim_zero_iff_forall_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem dim_zero_iff_forall_zero : module.rank R M = 0 ↔ ∀ x : M, x = 0 :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · contrapose! h\n    obtain ⟨x, hx⟩ := h\n    suffices 1 ≤ module.rank R M by\n      intro h\n      exact this.not_lt (h.symm ▸ zero_lt_one)\n    suffices linear_independent R fun y : ({x} : set M) => ↑y by simpa using cardinal_le_dim_of_linear_independent this\n    exact linear_independent_singleton hx\n  · have : («expr⊤» : submodule R M) = «expr⊥» := by\n      ext x\n      simp [h x]\n    rw [← dim_top, this, dim_bot]\n#align dim_zero_iff_forall_zero dim_zero_iff_forall_zero\n\n",
 "dim_zero_iff":
 "theorem dim_zero_iff : module.rank R M = 0 ↔ subsingleton M :=\n  dim_zero_iff_forall_zero.trans (subsingleton_iff_forall_eq 0).symm\n#align dim_zero_iff dim_zero_iff\n\n",
 "dim_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem dim_top : module.rank R («expr⊤» : submodule R M) = module.rank R M :=\n  by\n  have : «expr ≃ₗ[ ] » («expr⊤» : submodule R M) R M := linear_equiv.of_top («expr⊤») rfl\n  rw [this.dim_eq]\n#align dim_top dim_top\n\n",
 "dim_sup_add_dim_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem dim_sup_add_dim_inf_eq (s t : submodule K V) :\n    module.rank K («expr ⊔ » s t : submodule K V) + module.rank K («expr ⊓ » s t : submodule K V) =\n      module.rank K s + module.rank K t :=\n  dim_add_dim_split (of_le le_sup_left) (of_le le_sup_right) (of_le inf_le_left) (of_le inf_le_right)\n    (by\n      rw [← map_le_map_iff' (ker_subtype <| «expr ⊔ » s t), map_sup, map_top, ← linear_map.range_comp, ←\n        linear_map.range_comp, subtype_comp_of_le, subtype_comp_of_le, range_subtype, range_subtype, range_subtype]\n      exact le_rfl)\n    (ker_of_le _ _ _) (by ext ⟨x, hx⟩; rfl)\n    (by\n      rintro ⟨b₁, hb₁⟩ ⟨b₂, hb₂⟩ eq\n      obtain rfl : b₁ = b₂ := congr_arg subtype.val eq\n      exact ⟨⟨b₁, hb₁, hb₂⟩, rfl, rfl⟩)\n#align dim_sup_add_dim_inf_eq dim_sup_add_dim_inf_eq\n\n",
 "dim_submodule_le_one_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A submodule has dimension at most `1` if and only if there is a\nsingle vector, not necessarily in the submodule, such that the\nsubmodule is contained in its span. -/\ntheorem dim_submodule_le_one_iff' (s : submodule K V) : module.rank K s ≤ 1 ↔ ∃ v₀, s ≤ «expr ∙ » K v₀ :=\n  by\n  rw [dim_submodule_le_one_iff]\n  constructor\n  · rintro ⟨v₀, hv₀, h⟩\n    exact ⟨v₀, h⟩\n  · rintro ⟨v₀, h⟩\n    by_cases hw : ∃ w : V, w ∈ s ∧ w ≠ 0\n    · rcases hw with ⟨w, hw, hw0⟩\n      use w, hw\n      rcases mem_span_singleton.1 (h hw) with ⟨r', rfl⟩\n      have h0 : r' ≠ 0 := by\n        rintro rfl\n        simpa using hw0\n      rwa [span_singleton_smul_eq (IsUnit.mk0 _ h0) _]\n    · push_neg  at hw\n      rw [← submodule.eq_bot_iff] at hw\n      simp [hw]\n#align dim_submodule_le_one_iff' dim_submodule_le_one_iff'\n\n",
 "dim_submodule_le_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- A submodule has dimension at most `1` if and only if there is a\nsingle vector in the submodule such that the submodule is contained in\nits span. -/\ntheorem dim_submodule_le_one_iff (s : submodule K V) : module.rank K s ≤ 1 ↔ ∃ v₀ ∈ s, s ≤ «expr ∙ » K v₀ :=\n  by\n  simp_rw [dim_le_one_iff, le_span_singleton_iff]\n  constructor\n  · rintro ⟨⟨v₀, hv₀⟩, h⟩\n    use v₀, hv₀\n    intro v hv\n    obtain ⟨r, hr⟩ := h ⟨v, hv⟩\n    use r\n    simp_rw [subtype.ext_iff, coe_smul, submodule.coe_mk] at hr\n    exact hr\n  · rintro ⟨v₀, hv₀, h⟩\n    use ⟨v₀, hv₀⟩\n    rintro ⟨v, hv⟩\n    obtain ⟨r, hr⟩ := h v hv\n    use r\n    simp_rw [subtype.ext_iff, coe_smul, submodule.coe_mk]\n    exact hr\n#align dim_submodule_le_one_iff dim_submodule_le_one_iff\n\n",
 "dim_submodule_le":
 "theorem dim_submodule_le (s : submodule R M) : module.rank R s ≤ module.rank R M :=\n  by\n  rw [← dim_top R M]\n  exact dim_le_of_submodule _ _ le_top\n#align dim_submodule_le dim_submodule_le\n\n",
 "dim_span_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem dim_span_set {s : set M} (hs : linear_independent R (fun x => x : s → M)) :\n    module.rank R («expr↥ » (span R s)) = cardinal.mk s :=\n  by\n  rw [← @set_of_mem_eq _ s, ← Subtype.range_coe_subtype]\n  exact dim_span hs\n#align dim_span_set dim_span_set\n\n",
 "dim_span_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem dim_span_of_finset (s : Finset V) : module.rank K (span K (↑s : set V)) < cardinal.aleph_0 :=\n  calc\n    module.rank K (span K (↑s : set V)) ≤ cardinal.mk (↑s : set V) := dim_span_le ↑s\n    _ = s.card := by rw [Finset.coe_sort_coe, cardinal.mk_coe_finset]\n    _ < cardinal.aleph_0 := cardinal.nat_lt_aleph_0 _\n    \n#align dim_span_of_finset dim_span_of_finset\n\n",
 "dim_span_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n-- TODO how far can we generalise this?\n-- When `s` is finite, we could prove this for any ring satisfying the strong rank condition\n-- using `linear_independent_le_span'`\ntheorem dim_span_le (s : set V) : module.rank K (span K s) ≤ cardinal.mk s :=\n  by\n  obtain ⟨b, hb, hsab, hlib⟩ := exists_linear_independent K s\n  convert cardinal.mk_le_mk_of_subset hb\n  rw [← hsab, dim_span_set hlib]\n#align dim_span_le dim_span_le\n\n",
 "dim_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem dim_span {v : ι → M} (hv : linear_independent R v) :\n    module.rank R («expr↥ » (span R (range v))) = cardinal.mk (range v) :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  rw [← cardinal.lift_inj, ← (basis.span hv).mk_eq_dim,\n    cardinal.mk_range_eq_of_injective (@linear_independent.injective ι R M v _ _ _ _ hv)]\n#align dim_span dim_span\n\n",
 "dim_self":
 "@[simp]\ntheorem dim_self : module.rank R R = 1 := by\n  rw [← cardinal.lift_inj, ← (basis.singleton PUnit R).mk_eq_dim, cardinal.mk_punit]\n#align dim_self dim_self\n\n",
 "dim_range_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem dim_range_of_surjective (f : «expr →ₗ[ ] » M R M') (h : surjective f) :\n    module.rank R f.range = module.rank R M' := by rw [linear_map.range_eq_top.2 h, dim_top]\n#align dim_range_of_surjective dim_range_of_surjective\n\n",
 "dim_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem dim_range_le (f : «expr →ₗ[ ] » M R M₁) : module.rank R f.range ≤ module.rank R M := by\n  simpa using lift_dim_range_le f\n#align dim_range_le dim_range_le\n\n",
 "dim_range_add_dim_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- rank-nullity theorem -/\ntheorem dim_range_add_dim_ker (f : «expr →ₗ[ ] » V K V₁) :\n    module.rank K f.range + module.rank K f.ker = module.rank K V :=\n  by\n  haveI := fun p : submodule K V => classical.dec_eq («expr ⧸ » V p)\n  rw [← f.quot_ker_equiv_range.dim_eq, dim_quotient_add_dim]\n#align dim_range_add_dim_ker dim_range_add_dim_ker\n\n",
 "dim_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem dim_quotient_le (p : submodule R M) : module.rank R («expr ⧸ » M p) ≤ module.rank R M :=\n  (mkq p).dim_le_of_surjective (surjective_quot_mk _)\n#align dim_quotient_le dim_quotient_le\n\n",
 "dim_quotient_add_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\ntheorem dim_quotient_add_dim (p : submodule K V) : module.rank K («expr ⧸ » V p) + module.rank K p = module.rank K V :=\n  by\n  classical exact\n      let ⟨f⟩ := quotient_prod_linear_equiv p\n      dim_prod.symm.trans f.dim_eq\n#align dim_quotient_add_dim dim_quotient_add_dim\n\n",
 "dim_punit":
 "@[simp]\ntheorem dim_punit : module.rank R PUnit = 0 := by\n  apply le_bot_iff.mp\n  rw [module.rank]\n  apply csupᵢ_le'\n  rintro ⟨s, li⟩\n  apply le_bot_iff.mpr\n  apply cardinal.mk_emptyc_iff.mpr\n  simp only [subtype.coe_mk]\n  by_contra h\n  obtain ⟨a, ha⟩ := nonempty_iff_ne_empty.2 h\n  simpa using linear_independent.ne_zero (⟨a, ha⟩ : s) li\n#align dim_punit dim_punit\n\n",
 "dim_prod":
 "theorem dim_prod : module.rank K (V × V₁) = module.rank K V + module.rank K V₁ :=\n  by\n  let b := basis.of_vector_space K V\n  let c := basis.of_vector_space K V₁\n  rw [← cardinal.lift_inj, ← (basis.prod b c).mk_eq_dim, cardinal.lift_add, ← cardinal.mk_ulift, ← b.mk_eq_dim, ←\n    c.mk_eq_dim, ← cardinal.mk_ulift, ← cardinal.mk_ulift, cardinal.add_def (ULift _)]\n  exact cardinal.lift_inj.1 (cardinal.lift_mk_eq.2 ⟨equiv.ulift.trans (Equiv.sumCongr equiv.ulift equiv.ulift).symm⟩)\n#align dim_prod dim_prod\n\n",
 "dim_pos_iff_nontrivial":
 "theorem dim_pos_iff_nontrivial : 0 < module.rank R M ↔ nontrivial M :=\n  dim_pos_iff_exists_ne_zero.trans (nontrivial_iff_exists_ne 0).symm\n#align dim_pos_iff_nontrivial dim_pos_iff_nontrivial\n\n",
 "dim_pos_iff_exists_ne_zero":
 "theorem dim_pos_iff_exists_ne_zero : 0 < module.rank R M ↔ ∃ x : M, x ≠ 0 :=\n  by\n  rw [← not_iff_not]\n  simpa using dim_zero_iff_forall_zero\n#align dim_pos_iff_exists_ne_zero dim_pos_iff_exists_ne_zero\n\n",
 "dim_pos":
 "theorem dim_pos [h : nontrivial M] : 0 < module.rank R M :=\n  dim_pos_iff_nontrivial.2 h\n#align dim_pos dim_pos\n\n",
 "dim_pi":
 "theorem dim_pi [Finite η] : module.rank K (∀ i, φ i) = cardinal.sum fun i => module.rank K (φ i) :=\n  by\n  cases nonempty_fintype η\n  let b i := basis.of_vector_space K (φ i)\n  let this : basis (Σj, _) K (∀ j, φ j) := pi.basis b\n  rw [← cardinal.lift_inj, ← this.mk_eq_dim]\n  simp [← (b _).mk_range_eq_dim]\n#align dim_pi dim_pi\n\n",
 "dim_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem dim_map_le (f : «expr →ₗ[ ] » M R M₁) (p : submodule R M) : module.rank R (p.map f) ≤ module.rank R p := by\n  simpa using lift_dim_map_le f p\n#align dim_map_le dim_map_le\n\n",
 "dim_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Pushforwards of submodules along a `linear_equiv` have the same dimension. -/\ntheorem linear_equiv.dim_map_eq (f : «expr ≃ₗ[ ] » M R M₁) (p : submodule R M) :\n    module.rank R (p.map (f : «expr →ₗ[ ] » M R M₁)) = module.rank R p :=\n  (f.submodule_map p).dim_eq.symm\n#align linear_equiv.dim_map_eq linear_equiv.dim_map_eq\n\n",
 "dim_le_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem dim_le_one_iff : module.rank K V ≤ 1 ↔ ∃ v₀ : V, ∀ v, ∃ r : K, «expr • » r v₀ = v :=\n  by\n  let b := basis.of_vector_space K V\n  constructor\n  · intro hd\n    rw [← b.mk_eq_dim'', cardinal.le_one_iff_subsingleton, subsingleton_coe] at hd\n    rcases eq_empty_or_nonempty (of_vector_space_index K V) with (hb | ⟨⟨v₀, hv₀⟩⟩)\n    · use 0\n      have h' : ∀ v : V, v = 0 := by simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm\n      intro v\n      simp [h' v]\n    · use v₀\n      have h' : «expr ∙ » K v₀ = «expr⊤» := by simpa [hd.eq_singleton_of_mem hv₀] using b.span_eq\n      intro v\n      have hv : v ∈ («expr⊤» : submodule K V) := mem_top\n      rwa [← h', mem_span_singleton] at hv\n  · rintro ⟨v₀, hv₀⟩\n    have h : «expr ∙ » K v₀ = «expr⊤» := by\n      ext\n      simp [mem_span_singleton, hv₀]\n    rw [← dim_top, ← h]\n    convert dim_span_le _\n    simp\n#align dim_le_one_iff dim_le_one_iff\n\n",
 "dim_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.dim_le_of_surjective (f : «expr →ₗ[ ] » M R M₁) (h : surjective f) :\n    module.rank R M₁ ≤ module.rank R M := by\n  rw [← dim_range_of_surjective f h]\n  apply dim_range_le\n#align linear_map.dim_le_of_surjective linear_map.dim_le_of_surjective\n\n",
 "dim_le_of_submodule":
 "theorem dim_le_of_submodule (s t : submodule R M) (h : s ≤ t) : module.rank R s ≤ module.rank R t :=\n  (of_le h).dim_le_of_injective fun ⟨x, hx⟩ ⟨y, hy⟩ eq => subtype.eq <| show x = y from subtype.ext_iff_val.1 eq\n#align dim_le_of_submodule dim_le_of_submodule\n\n",
 "dim_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_map.dim_le_of_injective (f : «expr →ₗ[ ] » M R M₁) (i : injective f) :\n    module.rank R M ≤ module.rank R M₁ :=\n  cardinal.lift_le.1 (f.lift_dim_le_of_injective i)\n#align linear_map.dim_le_of_injective linear_map.dim_le_of_injective\n\n",
 "dim_le":
 "theorem dim_le {n : ℕ} (H : ∀ s : Finset M, (linear_independent R fun i : s => (i : M)) → s.card ≤ n) :\n    module.rank R M ≤ n := by\n  rw [module.rank]\n  apply csupᵢ_le'\n  rintro ⟨s, li⟩\n  exact linear_independent_bounded_of_finset_linear_independent_bounded H _ li\n#align dim_le dim_le\n\n",
 "dim_fun_eq_lift_mul":
 "theorem dim_fun_eq_lift_mul :\n    module.rank K (η → V) = (fintype.card η : cardinal.{max u₁' v}) * cardinal.lift.{u₁'} (module.rank K V) := by\n  rw [dim_pi, cardinal.sum_const, cardinal.mk_fintype, cardinal.lift_nat_cast]\n#align dim_fun_eq_lift_mul dim_fun_eq_lift_mul\n\n",
 "dim_fun'":
 "theorem dim_fun' : module.rank K (η → K) = fintype.card η := by\n  rw [dim_fun_eq_lift_mul, dim_self, cardinal.lift_one, mul_one, cardinal.nat_cast_inj]\n#align dim_fun' dim_fun'\n\n",
 "dim_fun":
 "theorem dim_fun {V η : Type u} [fintype η] [add_comm_group V] [Module K V] :\n    module.rank K (η → V) = fintype.card η * module.rank K V := by rw [dim_pi, cardinal.sum_const', cardinal.mk_fintype]\n#align dim_fun dim_fun\n\n",
 "dim_fin_fun":
 "theorem dim_fin_fun (n : ℕ) : module.rank K (fin n → K) = n := by simp [dim_fun']\n#align dim_fin_fun dim_fin_fun\n\n",
 "dim_eq_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem dim_eq_of_surjective (f : «expr →ₗ[ ] » V K V₁) (h : surjective f) :\n    module.rank K V = module.rank K V₁ + module.rank K f.ker := by\n  rw [← dim_range_add_dim_ker f, ← dim_range_of_surjective f h]\n#align dim_eq_of_surjective dim_eq_of_surjective\n\n",
 "dim_eq_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem dim_eq_of_injective (f : «expr →ₗ[ ] » M R M₁) (h : injective f) : module.rank R M = module.rank R f.range :=\n  (linear_equiv.of_injective f h).dim_eq\n#align dim_eq_of_injective dim_eq_of_injective\n\n",
 "dim_eq_card_basis":
 "/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem dim_eq_card_basis {ι : Type w} [fintype ι] (h : basis ι R M) : module.rank R M = fintype.card ι :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  rw [← h.mk_range_eq_dim, cardinal.mk_fintype, set.card_range_of_injective h.injective]\n#align dim_eq_card_basis dim_eq_card_basis\n\n",
 "dim_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem linear_equiv.dim_eq (f : «expr ≃ₗ[ ] » M R M₁) : module.rank R M = module.rank R M₁ :=\n  cardinal.lift_inj.1 f.lift_dim_eq\n#align linear_equiv.dim_eq linear_equiv.dim_eq\n\n",
 "dim_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem dim_bot : module.rank R («expr⊥» : submodule R M) = 0 :=\n  by\n  have : «expr ≃ₗ[ ] » («expr⊥» : submodule R M) R PUnit := bot_equiv_punit\n  rw [this.dim_eq, dim_punit]\n#align dim_bot dim_bot\n\n",
 "dim_add_le_dim_add_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem dim_add_le_dim_add_dim (s t : submodule K V) :\n    module.rank K («expr ⊔ » s t : submodule K V) ≤ module.rank K s + module.rank K t :=\n  by\n  rw [← dim_sup_add_dim_inf_eq]\n  exact self_le_add_right _ _\n#align dim_add_le_dim_add_dim dim_add_le_dim_add_dim\n\n",
 "dim_add_dim_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- This is mostly an auxiliary lemma for `dim_sup_add_dim_inf_eq`. -/\ntheorem dim_add_dim_split (db : «expr →ₗ[ ] » V₂ K V) (eb : «expr →ₗ[ ] » V₃ K V) (cd : «expr →ₗ[ ] » V₁ K V₂)\n    (ce : «expr →ₗ[ ] » V₁ K V₃) (hde : «expr⊤» ≤ «expr ⊔ » db.range eb.range) (hgd : ker cd = «expr⊥»)\n    (eq : db.comp cd = eb.comp ce) (eq₂ : ∀ d e, db d = eb e → ∃ c, cd c = d ∧ ce c = e) :\n    module.rank K V + module.rank K V₁ = module.rank K V₂ + module.rank K V₃ :=\n  by\n  have hf : surjective (coprod db eb) := by rwa [← range_eq_top, range_coprod, eq_top_iff]\n  conv =>\n    rhs\n    rw [← dim_prod, dim_eq_of_surjective _ hf]\n  congr 1\n  apply linear_equiv.dim_eq\n  refine' linear_equiv.of_bijective _ ⟨_, _⟩\n  · refine' cod_restrict _ (Prod cd (-ce)) _\n    · intro c\n      simp only [add_eq_zero_iff_eq_neg, linear_map.prod_apply, mem_ker, pi.prod, coprod_apply, neg_neg, map_neg,\n        neg_apply]\n      exact linear_map.ext_iff.1 eq c\n  · rw [← ker_eq_bot, ker_cod_restrict, ker_prod, hgd, bot_inf_eq]\n  · rw [← range_eq_top, eq_top_iff, range_cod_restrict, ← map_le_iff_le_comap, map_top, range_subtype]\n    rintro ⟨d, e⟩\n    have h := eq₂ d (-e)\n    simp only [add_eq_zero_iff_eq_neg, linear_map.prod_apply, mem_ker, SetLike.mem_coe, prod.mk.inj_iff, coprod_apply,\n      map_neg, neg_apply, linear_map.mem_range, pi.prod] at h⊢\n    intro hde\n    rcases h hde with ⟨c, h₁, h₂⟩\n    refine' ⟨c, h₁, _⟩\n    rw [h₂, _root_.neg_neg]\n#align dim_add_dim_split dim_add_dim_split\n\n",
 "cardinal_lift_le_dim_of_linear_independent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_lift_le_dim_of_linear_independent' {ι : Type w} {v : ι → M} (hv : linear_independent R v) :\n    cardinal.lift.{v} (cardinal.mk ι) ≤ cardinal.lift.{w} (module.rank R M) :=\n  cardinal_lift_le_dim_of_linear_independent.{u, v, w, 0} hv\n#align cardinal_lift_le_dim_of_linear_independent' cardinal_lift_le_dim_of_linear_independent'\n\n",
 "cardinal_lift_le_dim_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_lift_le_dim_of_linear_independent.{m} {ι : Type w} {v : ι → M} (hv : linear_independent R v) :\n    cardinal.lift.{max v m} (cardinal.mk ι) ≤ cardinal.lift.{max w m} (module.rank R M) :=\n  by\n  apply le_trans\n  · exact cardinal.lift_mk_le.mpr ⟨(Equiv.ofInjective _ hv.injective).to_embedding⟩\n  · simp only [cardinal.lift_le, module.rank]\n    apply le_trans\n    swap\n    exact le_csupᵢ (cardinal.bdd_above_range.{v, v} _) ⟨range v, hv.coe_range⟩\n    exact le_rfl\n#align cardinal_lift_le_dim_of_linear_independent cardinal_lift_le_dim_of_linear_independent\n\n",
 "cardinal_le_dim_of_linear_independent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_le_dim_of_linear_independent' {s : set M} (hs : linear_independent R (fun x => x : s → M)) :\n    cardinal.mk s ≤ module.rank R M :=\n  cardinal_le_dim_of_linear_independent hs\n#align cardinal_le_dim_of_linear_independent' cardinal_le_dim_of_linear_independent'\n\n",
 "cardinal_le_dim_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem cardinal_le_dim_of_linear_independent {ι : Type v} {v : ι → M} (hv : linear_independent R v) :\n    cardinal.mk ι ≤ module.rank R M := by simpa using cardinal_lift_le_dim_of_linear_independent hv\n#align cardinal_le_dim_of_linear_independent cardinal_le_dim_of_linear_independent\n\n",
 "card_le_card_of_submodule":
 "theorem basis.card_le_card_of_submodule (N : submodule R M) [fintype ι] (b : basis ι R M) [fintype ι']\n    (b' : basis ι' R N) : fintype.card ι' ≤ fintype.card ι :=\n  b.card_le_card_of_linear_independent (b'.linear_independent.map' N.subtype N.ker_subtype)\n#align basis.card_le_card_of_submodule basis.card_le_card_of_submodule\n\n",
 "card_le_card_of_linear_independent_aux":
 "/-- In an `n`-dimensional space, the rank is at most `m`. -/\ntheorem basis.card_le_card_of_linear_independent_aux {R : Type _} [Ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ}\n    (v : fin m → fin n → R) : linear_independent R v → m ≤ n := fun h => by\n  simpa using linear_independent_le_basis (pi.basis_fun R (fin n)) v h\n#align basis.card_le_card_of_linear_independent_aux basis.card_le_card_of_linear_independent_aux\n\n",
 "card_le_card_of_linear_independent":
 "theorem basis.card_le_card_of_linear_independent {ι : Type _} [fintype ι] (b : basis ι R M) {ι' : Type _} [fintype ι']\n    {v : ι' → M} (hv : linear_independent R v) : fintype.card ι' ≤ fintype.card ι :=\n  by\n  letI := nontrivial_of_invariant_basis_number R\n  simpa [dim_eq_card_basis b, cardinal.mk_fintype] using cardinal_lift_le_dim_of_linear_independent' hv\n#align basis.card_le_card_of_linear_independent basis.card_le_card_of_linear_independent\n\n",
 "card_le_card_of_le":
 "theorem basis.card_le_card_of_le {N O : submodule R M} (hNO : N ≤ O) [fintype ι] (b : basis ι R O) [fintype ι']\n    (b' : basis ι' R N) : fintype.card ι' ≤ fintype.card ι :=\n  b.card_le_card_of_linear_independent (b'.linear_independent.map' (submodule.of_le hNO) (N.ker_of_le O _))\n#align basis.card_le_card_of_le basis.card_le_card_of_le\n\n",
 "basis_le_span'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- Another auxiliary lemma for `basis.le_span`, which does not require assuming the basis is finite,\nbut still assumes we have a finite spanning set.\n-/\ntheorem basis_le_span' {ι : Type _} (b : basis ι R M) {w : set M} [fintype w] (s : span R w = «expr⊤») :\n    cardinal.mk ι ≤ fintype.card w :=\n  by\n  haveI := nontrivial_of_invariant_basis_number R\n  haveI := basis_fintype_of_finite_spans w s b\n  rw [cardinal.mk_fintype ι]\n  simp only [cardinal.nat_cast_le]\n  exact basis.le_span'' b s\n#align basis_le_span' basis_le_span'\n\n"}