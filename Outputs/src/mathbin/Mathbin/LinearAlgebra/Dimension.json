{"union_support_maximal_linearIndependent_eq_range_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print union_support_maximal_linearIndependent_eq_range_basis /-\n-- One might hope that a finite spanning set implies that any linearly independent set is finite.\n-- While this is true over a division ring\n-- (simply because any linearly independent set can be extended to a basis),\n-- I'm not certain what more general statements are possible.\n-- We'll work by contradiction, assuming `ι` is infinite.\n-- Let `S` be the union of the supports of `x ∈ w` expressed as linear combinations of `b`.\n-- This is a finite set since `w` is finite.\n-- Thus this finite subset of the basis elements spans the entire module.\n-- Now there is some `x : ι` not in `S`, since `ι` is infinite.\n-- However it must be in the span of the finite subset,\n-- giving the desire contradiction.\n-- From [Les familles libres maximales d'un module ont-elles le meme cardinal?][lazarus1973]\n/-- Over any ring `R`, if `b` is a basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the union of the supports of `x ∈ s` (when written out in the basis `b`) is all of `b`.\n-/\ntheorem union_support_maximal_linearIndependent_eq_range_basis {ι : Type w} (b : Basis ι R M) {κ : Type w'} (v : κ → M)\n    (i : LinearIndependent R v) (m : i.maximal) :\n    «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        ((b.repr (v k)).support : Set ι) =\n      univ :=\n  by\n  -- If that's not the case,\n  by_contra h\n  simp only [← ne.def, ne_univ_iff_exists_not_mem, mem_Union, not_exists_not, Finsupp.mem_support_iff,\n    Finset.mem_coe] at h\n  -- We have some basis element `b b'` which is not in the support of any of the `v i`.\n  obtain ⟨b', w⟩ := h\n  -- Using this, we'll construct a linearly independent family strictly larger than `v`,\n  -- by also using this `b b'`.\n  let v' : Option κ → M := fun o => o.elim (b b') v\n  have r : range v ⊆ range v' := by\n    rintro - ⟨k, rfl⟩\n    use some k\n    rfl\n  have r' : b b' ∉ range v := by\n    rintro ⟨k, p⟩\n    simpa [w] using congr_arg (fun m => (b.repr m) b') p\n  have r'' : range v ≠ range v' := by\n    intro e\n    have p : b b' ∈ range v' := by\n      use none\n      rfl\n    rw [← e] at p\n    exact r' p\n  have inj' : injective v' := by\n    rintro (_ | k) (_ | k) z\n    · rfl\n    · exfalso\n      exact r' ⟨k, z.symm⟩\n    · exfalso\n      exact r' ⟨k, z⟩\n    · congr\n      exact i.injective z\n  -- The key step in the proof is checking that this strictly larger family is linearly independent.\n  have i' : LinearIndependent R (coe : range v' → M) :=\n    by\n    rw [linearIndependent_subtype_range inj', linearIndependent_iff]\n    intro l z\n    rw [Finsupp.total_option] at z\n    simp only [v', Option.elim'] at z\n    change _ + Finsupp.total κ M R v l.some = 0 at z\n    -- We have some linear combination of `b b'` and the `v i`, which we want to show is trivial.\n    -- We'll first show the coefficient of `b b'` is zero,\n    -- by expressing the `v i` in the basis `b`, and using that the `v i` have no `b b'` term.\n    have l₀ : l none = 0 := by\n      rw [← eq_neg_iff_add_eq_zero] at z\n      replace z := neg_eq_iff_eq_neg.mpr z\n      apply_fun fun x => b.repr x b'  at z\n      simp only [repr_self, LinearEquiv.map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply, Finsupp.smul_single',\n        LinearEquiv.map_neg, Finsupp.coe_neg] at z\n      erw [Finsupp.congr_fun (Finsupp.apply_total R (b.repr : «expr →ₗ[ ] » M R («expr →₀ » ι R)) v l.some) b'] at z\n      simpa [Finsupp.total_apply, w] using z\n    -- Then all the other coefficients are zero, because `v` is linear independent.\n    have l₁ : l.some = 0 := by\n      rw [l₀, zero_smul, zero_add] at z\n      exact linear_independent_iff.mp i _ z\n    -- Finally we put those facts together to show the linear combination is trivial.\n    ext (_ | a)\n    · simp only [l₀, Finsupp.coe_zero, Pi.zero_apply]\n    · erw [Finsupp.congr_fun l₁ a]\n      simp only [Finsupp.coe_zero, Pi.zero_apply]\n  dsimp [LinearIndependent.Maximal] at m\n  specialize m (range v') i' r\n  exact r'' m\n#align union_support_maximal_linear_independent_eq_range_basis union_support_maximal_linearIndependent_eq_range_basis\n-/\n\n",
 "subtype_ne_bot_le_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print CompleteLattice.Independent.subtype_ne_bot_le_rank /-\ntheorem CompleteLattice.Independent.subtype_ne_bot_le_rank [NoZeroSMulDivisors R M] {V : ι → Submodule R M}\n    (hV : CompleteLattice.Independent V) :\n    Cardinal.lift.{v} (cardinal.mk { i : ι // V i ≠ «expr⊥» }) ≤ Cardinal.lift.{w} (Module.rank R M) :=\n  by\n  set I := { i : ι // V i ≠ «expr⊥» }\n  have hI : ∀ i : I, ∃ v ∈ V i, v ≠ (0 : M) := by\n    intro i\n    rw [← Submodule.ne_bot_iff]\n    exact i.prop\n  choose v hvV hv using hI\n  have : LinearIndependent R v := (hV.comp Subtype.coe_injective).linear_independent _ hvV hv\n  exact cardinal_lift_le_rank_of_linearIndependent' this\n#align complete_lattice.independent.subtype_ne_bot_le_rank CompleteLattice.Independent.subtype_ne_bot_le_rank\n-/\n\n",
 "set_finite_of_isNoetherian":
 "#print LinearIndependent.set_finite_of_isNoetherian /-\ntheorem LinearIndependent.set_finite_of_isNoetherian [IsNoetherian R M] {s : Set M}\n    (hi : LinearIndependent R (coe : s → M)) : s.finite :=\n  @Set.toFinite _ _ hi.finite_of_is_noetherian\n#align linear_independent.set_finite_of_is_noetherian LinearIndependent.set_finite_of_isNoetherian\n-/\n\n",
 "rank_zero_iff_forall_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print rank_zero_iff_forall_zero /-\ntheorem rank_zero_iff_forall_zero : Module.rank R M = 0 ↔ ∀ x : M, x = 0 :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · contrapose! h\n    obtain ⟨x, hx⟩ := h\n    letI : Nontrivial M := nontrivial_of_ne _ _ hx\n    exact rank_pos.ne'\n  · have : («expr⊤» : Submodule R M) = «expr⊥» := by\n      ext x\n      simp [h x]\n    rw [← rank_top, this, rank_bot]\n#align rank_zero_iff_forall_zero rank_zero_iff_forall_zero\n-/\n\n",
 "rank_zero_iff":
 "#print rank_zero_iff /-\n/-- See `rank_subsingleton` for the reason that `nontrivial R` is needed. -/\ntheorem rank_zero_iff : Module.rank R M = 0 ↔ subsingleton M :=\n  rank_zero_iff_forall_zero.trans (subsingleton_iff_forall_eq 0).symm\n#align rank_zero_iff rank_zero_iff\n-/\n\n",
 "rank_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem rank_zero [Nontrivial K] : rank (0 : «expr →ₗ[ ] » V K V') = 0 := by rw [rank, LinearMap.range_zero, rank_bot]\n#align rank_zero rank_zero\n\n",
 "rank_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print rank_top /-\n@[simp]\ntheorem rank_top : Module.rank R («expr⊤» : Submodule R M) = Module.rank R M :=\n  by\n  have : «expr ≃ₗ[ ] » («expr⊤» : Submodule R M) R M := LinearEquiv.ofTop («expr⊤») rfl\n  rw [this.rank_eq]\n#align rank_top rank_top\n-/\n\n",
 "rank_sup_add_rank_inf_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n#print Submodule.rank_sup_add_rank_inf_eq /-\ntheorem Submodule.rank_sup_add_rank_inf_eq (s t : Submodule K V) :\n    Module.rank K («expr ⊔ » s t : Submodule K V) + Module.rank K («expr ⊓ » s t : Submodule K V) =\n      Module.rank K s + Module.rank K t :=\n  rank_add_rank_split (ofLe le_sup_left) (ofLe le_sup_right) (ofLe inf_le_left) (ofLe inf_le_right)\n    (by\n      rw [← map_le_map_iff' (ker_subtype <| «expr ⊔ » s t), Submodule.map_sup, Submodule.map_top, ←\n        LinearMap.range_comp, ← LinearMap.range_comp, subtype_comp_of_le, subtype_comp_of_le, range_subtype,\n        range_subtype, range_subtype]\n      exact le_rfl)\n    (ker_ofLe _ _ _) (by ext ⟨x, hx⟩; rfl)\n    (by\n      rintro ⟨b₁, hb₁⟩ ⟨b₂, hb₂⟩ eq\n      obtain rfl : b₁ = b₂ := congr_arg Subtype.val Eq\n      exact ⟨⟨b₁, hb₁, hb₂⟩, rfl, rfl⟩)\n#align submodule.rank_sup_add_rank_inf_eq Submodule.rank_sup_add_rank_inf_eq\n-/\n\n",
 "rank_subsingleton":
 "#print rank_subsingleton /-\n@[simp]\ntheorem rank_subsingleton [subsingleton R] : Module.rank R M = 1 :=\n  by\n  haveI := Module.subsingleton R M\n  have : Nonempty { s : Set M // LinearIndependent R (coe : s → M) } := ⟨⟨∅, linearIndependent_empty _ _⟩⟩\n  rw [Module.rank, csupᵢ_eq_of_forall_le_of_forall_lt_exists_gt]\n  · rintro ⟨s, hs⟩\n    rw [Cardinal.mk_le_one_iff_set_subsingleton]\n    apply subsingleton_of_subsingleton\n  intro w hw\n  refine' ⟨⟨{0}, _⟩, _⟩\n  · rw [linearIndependent_iff']\n    intros\n    exact subsingleton.elim _ _\n  · exact hw.trans_eq (Cardinal.mk_singleton _).symm\n#align rank_subsingleton rank_subsingleton\n-/\n\n",
 "rank_submodule_le_one_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print rank_submodule_le_one_iff' /-\n/-- A submodule has dimension at most `1` if and only if there is a\nsingle vector, not necessarily in the submodule, such that the\nsubmodule is contained in its span. -/\ntheorem rank_submodule_le_one_iff' (s : Submodule K V) : Module.rank K s ≤ 1 ↔ ∃ v₀, s ≤ «expr ∙ » K v₀ :=\n  by\n  rw [rank_submodule_le_one_iff]\n  constructor\n  · rintro ⟨v₀, hv₀, h⟩\n    exact ⟨v₀, h⟩\n  · rintro ⟨v₀, h⟩\n    by_cases hw : ∃ w : V, w ∈ s ∧ w ≠ 0\n    · rcases hw with ⟨w, hw, hw0⟩\n      use w, hw\n      rcases mem_span_singleton.1 (h hw) with ⟨r', rfl⟩\n      have h0 : r' ≠ 0 := by\n        rintro rfl\n        simpa using hw0\n      rwa [span_singleton_smul_eq (IsUnit.mk0 _ h0) _]\n    · push_neg  at hw\n      rw [← Submodule.eq_bot_iff] at hw\n      simp [hw]\n#align rank_submodule_le_one_iff' rank_submodule_le_one_iff'\n-/\n\n",
 "rank_submodule_le_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print rank_submodule_le_one_iff /-\n/-- A submodule has dimension at most `1` if and only if there is a\nsingle vector in the submodule such that the submodule is contained in\nits span. -/\ntheorem rank_submodule_le_one_iff (s : Submodule K V) : Module.rank K s ≤ 1 ↔ ∃ v₀ ∈ s, s ≤ «expr ∙ » K v₀ :=\n  by\n  simp_rw [rank_le_one_iff, le_span_singleton_iff]\n  constructor\n  · rintro ⟨⟨v₀, hv₀⟩, h⟩\n    use v₀, hv₀\n    intro v hv\n    obtain ⟨r, hr⟩ := h ⟨v, hv⟩\n    use r\n    simp_rw [Subtype.ext_iff, coe_smul, Submodule.coe_mk] at hr\n    exact hr\n  · rintro ⟨v₀, hv₀, h⟩\n    use ⟨v₀, hv₀⟩\n    rintro ⟨v, hv⟩\n    obtain ⟨r, hr⟩ := h v hv\n    use r\n    simp_rw [Subtype.ext_iff, coe_smul, Submodule.coe_mk]\n    exact hr\n#align rank_submodule_le_one_iff rank_submodule_le_one_iff\n-/\n\n",
 "rank_submodule_le":
 "#print rank_submodule_le /-\ntheorem rank_submodule_le (s : Submodule R M) : Module.rank R s ≤ Module.rank R M :=\n  by\n  rw [← rank_top R M]\n  exact rank_le_of_submodule _ _ le_top\n#align rank_submodule_le rank_submodule_le\n-/\n\n",
 "rank_span_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print rank_span_set /-\ntheorem rank_span_set {s : Set M} (hs : LinearIndependent R (fun x => x : s → M)) :\n    Module.rank R («expr↥ » (span R s)) = cardinal.mk s :=\n  by\n  rw [← @set_of_mem_eq _ s, ← Subtype.range_coe_subtype]\n  exact rank_span hs\n#align rank_span_set rank_span_set\n-/\n\n",
 "rank_span_of_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print rank_span_of_finset /-\ntheorem rank_span_of_finset (s : Finset V) : Module.rank K (span K (↑s : Set V)) < cardinal.aleph_0 :=\n  calc\n    Module.rank K (span K (↑s : Set V)) ≤ cardinal.mk (↑s : Set V) := rank_span_le ↑s\n    _ = s.card := by rw [Finset.coe_sort_coe, Cardinal.mk_coe_finset]\n    _ < cardinal.aleph_0 := Cardinal.nat_lt_aleph0 _\n    \n#align rank_span_of_finset rank_span_of_finset\n-/\n\n",
 "rank_span_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print rank_span_le /-\n-- TODO how far can we generalise this?\n-- When `s` is finite, we could prove this for any ring satisfying the strong rank condition\n-- using `linear_independent_le_span'`\ntheorem rank_span_le (s : Set V) : Module.rank K (span K s) ≤ cardinal.mk s :=\n  by\n  obtain ⟨b, hb, hsab, hlib⟩ := exists_linearIndependent K s\n  convert Cardinal.mk_le_mk_of_subset hb\n  rw [← hsab, rank_span_set hlib]\n#align rank_span_le rank_span_le\n-/\n\n",
 "rank_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print rank_span /-\ntheorem rank_span {v : ι → M} (hv : LinearIndependent R v) :\n    Module.rank R («expr↥ » (span R (range v))) = cardinal.mk (range v) :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [← Cardinal.lift_inj, ← (Basis.span hv).mk_eq_rank,\n    Cardinal.mk_range_eq_of_injective (@LinearIndependent.injective ι R M v _ _ _ _ hv)]\n#align rank_span rank_span\n-/\n\n",
 "rank_self":
 "#print rank_self /-\n@[simp]\ntheorem rank_self : Module.rank R R = 1 := by\n  rw [← Cardinal.lift_inj, ← (Basis.singleton PUnit R).mk_eq_rank, Cardinal.mk_punit]\n#align rank_self rank_self\n-/\n\n",
 "rank_range_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print rank_range_of_surjective /-\ntheorem rank_range_of_surjective (f : «expr →ₗ[ ] » M R M') (h : surjective f) :\n    Module.rank R f.range = Module.rank R M' := by rw [LinearMap.range_eq_top.2 h, rank_top]\n#align rank_range_of_surjective rank_range_of_surjective\n-/\n\n",
 "rank_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print rank_range_le /-\ntheorem rank_range_le (f : «expr →ₗ[ ] » M R M₁) : Module.rank R f.range ≤ Module.rank R M := by\n  simpa using lift_rank_range_le f\n#align rank_range_le rank_range_le\n-/\n\n",
 "rank_range_add_rank_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print rank_range_add_rank_ker /-\n/-- rank-nullity theorem -/\ntheorem rank_range_add_rank_ker (f : «expr →ₗ[ ] » V K V₁) :\n    Module.rank K f.range + Module.rank K f.ker = Module.rank K V :=\n  by\n  haveI := fun p : Submodule K V => Classical.decEq («expr ⧸ » V p)\n  rw [← f.quot_ker_equiv_range.rank_eq, rank_quotient_add_rank]\n#align rank_range_add_rank_ker rank_range_add_rank_ker\n-/\n\n",
 "rank_quotient_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print rank_quotient_le /-\ntheorem rank_quotient_le (p : Submodule R M) : Module.rank R («expr ⧸ » M p) ≤ Module.rank R M :=\n  (mkQ p).rank_le_of_surjective (surjective_quot_mk _)\n#align rank_quotient_le rank_quotient_le\n-/\n\n",
 "rank_quotient_add_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⧸ » -/\n#print rank_quotient_add_rank /-\ntheorem rank_quotient_add_rank (p : Submodule K V) :\n    Module.rank K («expr ⧸ » V p) + Module.rank K p = Module.rank K V := by\n  classical exact\n      let ⟨f⟩ := quotient_prod_linearEquiv p\n      rank_prod'.symm.trans f.rank_eq\n#align rank_quotient_add_rank rank_quotient_add_rank\n-/\n\n",
 "rank_punit":
 "#print rank_punit /-\n@[simp]\ntheorem rank_punit : Module.rank R PUnit = 0 := by\n  apply le_bot_iff.mp\n  rw [Module.rank]\n  apply csupᵢ_le'\n  rintro ⟨s, li⟩\n  apply le_bot_iff.mpr\n  apply cardinal.mk_emptyc_iff.mpr\n  simp only [Subtype.coe_mk]\n  by_contra h\n  obtain ⟨a, ha⟩ := nonempty_iff_ne_empty.2 h\n  simpa using LinearIndependent.ne_zero (⟨a, ha⟩ : s) li\n#align rank_punit rank_punit\n-/\n\n",
 "rank_prod'":
 "#print rank_prod' /-\n/-- If `M` and `N` lie in the same universe, the rank of `M × N` is\n  `(module.rank R M) + (module.rank R N)`. -/\ntheorem rank_prod' : Module.rank K (V × V₁) = Module.rank K V + Module.rank K V₁ := by simp\n#align rank_prod' rank_prod'\n-/\n\n",
 "rank_prod":
 "#print rank_prod /-\n/-- The rank of `M × N` is `(module.rank R M).lift + (module.rank R N).lift`. -/\n@[simp]\ntheorem rank_prod :\n    Module.rank K (V × V') = Cardinal.lift.{v'} (Module.rank K V) + Cardinal.lift.{v, v'} (Module.rank K V') := by\n  simpa [rank_eq_card_choose_basis_index K V, rank_eq_card_choose_basis_index K V', lift_umax, lift_umax'] using\n    ((choose_basis K V).prod (choose_basis K V')).mk_eq_rank.symm\n#align rank_prod rank_prod\n-/\n\n",
 "rank_pos_iff_nontrivial":
 "#print rank_pos_iff_nontrivial /-\ntheorem rank_pos_iff_nontrivial : 0 < Module.rank R M ↔ Nontrivial M :=\n  rank_pos_iff_exists_ne_zero.trans (nontrivial_iff_exists_ne 0).symm\n#align rank_pos_iff_nontrivial rank_pos_iff_nontrivial\n-/\n\n",
 "rank_pos_iff_exists_ne_zero":
 "#print rank_pos_iff_exists_ne_zero /-\ntheorem rank_pos_iff_exists_ne_zero : 0 < Module.rank R M ↔ ∃ x : M, x ≠ 0 :=\n  by\n  rw [← not_iff_not]\n  simpa using rank_zero_iff_forall_zero\n#align rank_pos_iff_exists_ne_zero rank_pos_iff_exists_ne_zero\n-/\n\n",
 "rank_pos":
 "#print rank_pos /-\ntheorem rank_pos [Nontrivial M] : 0 < Module.rank R M :=\n  by\n  obtain ⟨x, hx⟩ := exists_ne (0 : M)\n  suffices 1 ≤ Module.rank R M by exact zero_lt_one.trans_le this\n  letI := Module.nontrivial R M\n  suffices LinearIndependent R fun y : ({x} : Set M) => ↑y by simpa using cardinal_le_rank_of_linearIndependent this\n  exact linearIndependent_singleton hx\n#align rank_pos rank_pos\n-/\n\n",
 "rank_pi":
 "#print rank_pi /-\n/-- The rank of a finite product is the sum of the ranks. -/\n@[simp]\ntheorem rank_pi [Finite η] : Module.rank K (∀ i, φ i) = Cardinal.sum fun i => Module.rank K (φ i) :=\n  by\n  cases nonempty_fintype η\n  let B i := choose_basis K (φ i)\n  let b : Basis _ K (∀ i, φ i) := Pi.basis fun i => B i\n  simp [← b.mk_eq_rank'', fun i => (B i).mk_eq_rank'']\n#align rank_pi rank_pi\n-/\n\n",
 "rank_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print rank_map_le /-\ntheorem rank_map_le (f : «expr →ₗ[ ] » M R M₁) (p : Submodule R M) : Module.rank R (p.map f) ≤ Module.rank R p := by\n  simpa using lift_rank_map_le f p\n#align rank_map_le rank_map_le\n-/\n\n",
 "rank_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearEquiv.rank_map_eq /-\n/-- Pushforwards of submodules along a `linear_equiv` have the same dimension. -/\ntheorem LinearEquiv.rank_map_eq (f : «expr ≃ₗ[ ] » M R M₁) (p : Submodule R M) :\n    Module.rank R (p.map (f : «expr →ₗ[ ] » M R M₁)) = Module.rank R p :=\n  (f.submodule_map p).rank_eq.symm\n#align linear_equiv.rank_map_eq LinearEquiv.rank_map_eq\n-/\n\n",
 "rank_le_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_le_range (f : «expr →ₗ[ ] » V K V') : rank f ≤ Module.rank K V' :=\n  rank_submodule_le _\n#align rank_le_range rank_le_range\n\n",
 "rank_le_one_iff_top_isPrincipal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Module.rank_le_one_iff_top_isPrincipal /-\ntheorem Module.rank_le_one_iff_top_isPrincipal : Module.rank K V ≤ 1 ↔ («expr⊤» : Submodule K V).is_principal := by\n  rw [← Submodule.rank_le_one_iff_isPrincipal, rank_top]\n#align module.rank_le_one_iff_top_is_principal Module.rank_le_one_iff_top_isPrincipal\n-/\n\n",
 "rank_le_one_iff_isPrincipal":
 "#print Submodule.rank_le_one_iff_isPrincipal /-\ntheorem Submodule.rank_le_one_iff_isPrincipal (W : Submodule K V) : Module.rank K W ≤ 1 ↔ W.is_principal :=\n  by\n  simp only [rank_le_one_iff, submodule.is_principal_iff, le_antisymm_iff, le_span_singleton_iff,\n    span_singleton_le_iff_mem]\n  constructor\n  · rintro ⟨⟨m, hm⟩, hm'⟩\n    choose f hf using hm'\n    exact ⟨m, ⟨fun v hv => ⟨f ⟨v, hv⟩, congr_arg coe (hf ⟨v, hv⟩)⟩, hm⟩⟩\n  · rintro ⟨a, ⟨h, ha⟩⟩\n    choose f hf using h\n    exact ⟨⟨a, ha⟩, fun v => ⟨f v.1 v.2, Subtype.ext (hf v.1 v.2)⟩⟩\n#align submodule.rank_le_one_iff_is_principal Submodule.rank_le_one_iff_isPrincipal\n-/\n\n",
 "rank_le_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print rank_le_one_iff /-\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem rank_le_one_iff : Module.rank K V ≤ 1 ↔ ∃ v₀ : V, ∀ v, ∃ r : K, «expr • » r v₀ = v :=\n  by\n  let b := Basis.ofVectorSpace K V\n  constructor\n  · intro hd\n    rw [← b.mk_eq_rank'', Cardinal.le_one_iff_subsingleton, subsingleton_coe] at hd\n    rcases eq_empty_or_nonempty (of_vector_space_index K V) with (hb | ⟨⟨v₀, hv₀⟩⟩)\n    · use 0\n      have h' : ∀ v : V, v = 0 := by simpa [hb, Submodule.eq_bot_iff] using b.span_eq.symm\n      intro v\n      simp [h' v]\n    · use v₀\n      have h' : «expr ∙ » K v₀ = «expr⊤» := by simpa [hd.eq_singleton_of_mem hv₀] using b.span_eq\n      intro v\n      have hv : v ∈ («expr⊤» : Submodule K V) := mem_top\n      rwa [← h', mem_span_singleton] at hv\n  · rintro ⟨v₀, hv₀⟩\n    have h : «expr ∙ » K v₀ = «expr⊤» := by\n      ext\n      simp [mem_span_singleton, hv₀]\n    rw [← rank_top, ← h]\n    refine' (rank_span_le _).trans_eq _\n    simp\n#align rank_le_one_iff rank_le_one_iff\n-/\n\n",
 "rank_le_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.rank_le_of_surjective /-\ntheorem LinearMap.rank_le_of_surjective (f : «expr →ₗ[ ] » M R M₁) (h : surjective f) :\n    Module.rank R M₁ ≤ Module.rank R M := by\n  rw [← rank_range_of_surjective f h]\n  apply rank_range_le\n#align linear_map.rank_le_of_surjective LinearMap.rank_le_of_surjective\n-/\n\n",
 "rank_le_of_submodule":
 "#print rank_le_of_submodule /-\ntheorem rank_le_of_submodule (s t : Submodule R M) (h : s ≤ t) : Module.rank R s ≤ Module.rank R t :=\n  (ofLe h).rank_le_of_injective fun ⟨x, hx⟩ ⟨y, hy⟩ eq => Subtype.eq <| show x = y from Subtype.ext_iff_val.1 Eq\n#align rank_le_of_submodule rank_le_of_submodule\n-/\n\n",
 "rank_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.rank_le_of_injective /-\ntheorem LinearMap.rank_le_of_injective (f : «expr →ₗ[ ] » M R M₁) (i : injective f) :\n    Module.rank R M ≤ Module.rank R M₁ :=\n  Cardinal.lift_le.1 (f.lift_rank_le_of_injective i)\n#align linear_map.rank_le_of_injective LinearMap.rank_le_of_injective\n-/\n\n",
 "rank_le_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_le_domain (f : «expr →ₗ[ ] » V K V₁) : rank f ≤ Module.rank K V :=\n  rank_range_le _\n#align rank_le_domain rank_le_domain\n\n",
 "rank_le":
 "#print rank_le /-\ntheorem rank_le {n : ℕ} (H : ∀ s : Finset M, (LinearIndependent R fun i : s => (i : M)) → s.card ≤ n) :\n    Module.rank R M ≤ n := by\n  rw [Module.rank]\n  apply csupᵢ_le'\n  rintro ⟨s, li⟩\n  exact linearIndependent_bounded_of_finset_linearIndependent_bounded H _ li\n#align rank_le rank_le\n-/\n\n",
 "rank_fun_eq_lift_mul":
 "#print rank_fun_eq_lift_mul /-\ntheorem rank_fun_eq_lift_mul :\n    Module.rank K (η → V) = (Fintype.card η : Cardinal.{max u₁' v}) * Cardinal.lift.{u₁'} (Module.rank K V) := by\n  rw [rank_pi, Cardinal.sum_const, Cardinal.mk_fintype, Cardinal.lift_natCast]\n#align rank_fun_eq_lift_mul rank_fun_eq_lift_mul\n-/\n\n",
 "rank_fun'":
 "#print rank_fun' /-\ntheorem rank_fun' : Module.rank K (η → K) = Fintype.card η := by\n  rw [rank_fun_eq_lift_mul, rank_self, Cardinal.lift_one, mul_one, Cardinal.natCast_inj]\n#align rank_fun' rank_fun'\n-/\n\n",
 "rank_fun":
 "#print rank_fun /-\ntheorem rank_fun {V η : Type u} [Fintype η] [AddCommGroup V] [Module K V] [Module.Free K V] :\n    Module.rank K (η → V) = Fintype.card η * Module.rank K V := by\n  rw [rank_pi, Cardinal.sum_const', Cardinal.mk_fintype]\n#align rank_fun rank_fun\n-/\n\n",
 "rank_finset_sum_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem rank_finset_sum_le {η} (s : Finset η) (f : η → «expr →ₗ[ ] » V K V') :\n    rank (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (f d)) ≤\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (rank (f d)) :=\n  @Finset.sum_hom_rel _ _ _ _ _ (fun a b => rank a ≤ b) f (fun d => rank (f d)) s (le_of_eq rank_zero) fun i g c h =>\n    le_trans (rank_add_le _ _) (add_le_add_left h _)\n#align rank_finset_sum_le rank_finset_sum_le\n\n",
 "rank_fin_fun":
 "#print rank_fin_fun /-\ntheorem rank_fin_fun (n : ℕ) : Module.rank K (Fin n → K) = n := by simp [rank_fun']\n#align rank_fin_fun rank_fin_fun\n-/\n\n",
 "rank_eq_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print rank_eq_of_surjective /-\ntheorem rank_eq_of_surjective (f : «expr →ₗ[ ] » V K V₁) (h : surjective f) :\n    Module.rank K V = Module.rank K V₁ + Module.rank K f.ker := by\n  rw [← rank_range_add_rank_ker f, ← rank_range_of_surjective f h]\n#align rank_eq_of_surjective rank_eq_of_surjective\n-/\n\n",
 "rank_eq_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print rank_eq_of_injective /-\ntheorem rank_eq_of_injective (f : «expr →ₗ[ ] » M R M₁) (h : injective f) : Module.rank R M = Module.rank R f.range :=\n  (LinearEquiv.ofInjective f h).rank_eq\n#align rank_eq_of_injective rank_eq_of_injective\n-/\n\n",
 "rank_eq_card_choose_basis_index":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`. -/\ntheorem rank_eq_card_choose_basis_index : Module.rank K V = cardinal.mk (ChooseBasisIndex K V) :=\n  (chooseBasis K V).mk_eq_rank''.symm\n#align rank_eq_card_choose_basis_index rank_eq_card_choose_basis_index\n\n",
 "rank_eq_card_basis":
 "#print rank_eq_card_basis /-\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem rank_eq_card_basis {ι : Type w} [Fintype ι] (h : Basis ι R M) : Module.rank R M = Fintype.card ι :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [← h.mk_range_eq_rank, Cardinal.mk_fintype, Set.card_range_of_injective h.injective]\n#align rank_eq_card_basis rank_eq_card_basis\n-/\n\n",
 "rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Ideal.rank_eq /-\n/-- If `S` a finite-dimensional ring extension of `R` which is free as an `R`-module,\nthen the rank of an ideal `I` of `S` over `R` is the same as the rank of `S`.\n-/\ntheorem Ideal.rank_eq {R S : Type _} [CommRing R] [StrongRankCondition R] [Ring S] [IsDomain S] [Algebra R S]\n    {n m : Type _} [Fintype n] [Fintype m] (b : Basis n R S) {I : Ideal S} (hI : I ≠ «expr⊥») (c : Basis m R I) :\n    Fintype.card m = Fintype.card n :=\n  by\n  obtain ⟨a, ha⟩ := Submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr hI)\n  have : LinearIndependent R fun i => «expr • » (b i) a :=\n    by\n    have hb := b.linear_independent\n    rw [Fintype.linearIndependent_iff] at hb⊢\n    intro g hg\n    apply hb g\n    simp only [← smul_assoc, ← Finset.sum_smul, smul_eq_zero] at hg\n    exact hg.resolve_right ha\n  exact\n    le_antisymm\n      (b.card_le_card_of_linear_independent\n        (c.linear_independent.map' (Submodule.subtype I) (linear_map.ker_eq_bot.mpr Subtype.coe_injective)))\n      (c.card_le_card_of_linear_independent this)\n#align ideal.rank_eq Ideal.rank_eq\n-/\n\n",
 "rank_comp_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_comp_le_right (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'₁) : rank (f.comp g) ≤ rank g := by\n  simpa only [Cardinal.lift_id] using lift_rank_comp_le_right g f\n#align rank_comp_le_right rank_comp_le_right\n\n",
 "rank_comp_le_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_comp_le_left (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'') : rank (f.comp g) ≤ rank f :=\n  by\n  refine' rank_le_of_submodule _ _ _\n  rw [LinearMap.range_comp]\n  exact LinearMap.map_le_range\n#align rank_comp_le_left rank_comp_le_left\n\n",
 "rank_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The rank of the composition of two maps is less than the minimum of their ranks.\n\nSee `lift_rank_comp_le` for the universe-polymorphic version. -/\ntheorem rank_comp_le (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'₁) :\n    rank (f.comp g) ≤ min (rank f) (rank g) := by simpa only [Cardinal.lift_id] using lift_rank_comp_le g f\n#align rank_comp_le rank_comp_le\n\n",
 "rank_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print rank_bot /-\n@[simp]\ntheorem rank_bot : Module.rank R («expr⊥» : Submodule R M) = 0 :=\n  by\n  have : «expr ≃ₗ[ ] » («expr⊥» : Submodule R M) R PUnit := bot_equiv_punit\n  rw [this.rank_eq, rank_punit]\n#align rank_bot rank_bot\n-/\n\n",
 "rank_add_rank_split":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print rank_add_rank_split /-\n/-- This is mostly an auxiliary lemma for `submodule.rank_sup_add_rank_inf_eq`. -/\ntheorem rank_add_rank_split (db : «expr →ₗ[ ] » V₂ K V) (eb : «expr →ₗ[ ] » V₃ K V) (cd : «expr →ₗ[ ] » V₁ K V₂)\n    (ce : «expr →ₗ[ ] » V₁ K V₃) (hde : «expr⊤» ≤ «expr ⊔ » db.range eb.range) (hgd : ker cd = «expr⊥»)\n    (eq : db.comp cd = eb.comp ce) (eq₂ : ∀ d e, db d = eb e → ∃ c, cd c = d ∧ ce c = e) :\n    Module.rank K V + Module.rank K V₁ = Module.rank K V₂ + Module.rank K V₃ :=\n  by\n  have hf : surjective (coprod db eb) := by rwa [← range_eq_top, range_coprod, eq_top_iff]\n  conv =>\n    rhs\n    rw [← rank_prod', rank_eq_of_surjective _ hf]\n  congr 1\n  apply LinearEquiv.rank_eq\n  refine' LinearEquiv.ofBijective _ ⟨_, _⟩\n  · refine' cod_restrict _ (Prod cd (-ce)) _\n    · intro c\n      simp only [add_eq_zero_iff_eq_neg, linear_map.prod_apply, mem_ker, Pi.prod, coprod_apply, neg_neg, map_neg,\n        neg_apply]\n      exact LinearMap.ext_iff.1 Eq c\n  · rw [← ker_eq_bot, ker_cod_restrict, ker_prod, hgd, bot_inf_eq]\n  · rw [← range_eq_top, eq_top_iff, range_cod_restrict, ← map_le_iff_le_comap, Submodule.map_top, range_subtype]\n    rintro ⟨d, e⟩\n    have h := eq₂ d (-e)\n    simp only [add_eq_zero_iff_eq_neg, linear_map.prod_apply, mem_ker, SetLike.mem_coe, Prod.mk.inj_iff, coprod_apply,\n      map_neg, neg_apply, LinearMap.mem_range, Pi.prod] at h⊢\n    intro hde\n    rcases h hde with ⟨c, h₁, h₂⟩\n    refine' ⟨c, h₁, _⟩\n    rw [h₂, _root_.neg_neg]\n#align rank_add_rank_split rank_add_rank_split\n-/\n\n",
 "rank_add_le_rank_add_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n#print Submodule.rank_add_le_rank_add_rank /-\ntheorem Submodule.rank_add_le_rank_add_rank (s t : Submodule K V) :\n    Module.rank K («expr ⊔ » s t : Submodule K V) ≤ Module.rank K s + Module.rank K t :=\n  by\n  rw [← Submodule.rank_sup_add_rank_inf_eq]\n  exact self_le_add_right _ _\n#align submodule.rank_add_le_rank_add_rank Submodule.rank_add_le_rank_add_rank\n-/\n\n",
 "rank_add_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem rank_add_le (f g : «expr →ₗ[ ] » V K V') : rank (f + g) ≤ rank f + rank g :=\n  calc\n    rank (f + g) ≤ Module.rank K («expr ⊔ » f.range g.range : Submodule K V') :=\n      by\n      refine' rank_le_of_submodule _ _ _\n      exact\n        LinearMap.range_le_iff_comap.2 <|\n          eq_top_iff'.2 fun x =>\n            show f x + g x ∈ («expr ⊔ » f.range g.range : Submodule K V') from mem_sup.2 ⟨_, ⟨x, rfl⟩, _, ⟨x, rfl⟩, rfl⟩\n    _ ≤ rank f + rank g := Submodule.rank_add_le_rank_add_rank _ _\n    \n#align rank_add_le rank_add_le\n\n",
 "ofRankEqZero_apply":
 "#print Basis.ofRankEqZero_apply /-\n@[simp]\ntheorem Basis.ofRankEqZero_apply {ι : Type _} [IsEmpty ι] (hV : Module.rank K V = 0) (i : ι) :\n    Basis.ofRankEqZero hV i = 0 :=\n  rfl\n#align basis.of_rank_eq_zero_apply Basis.ofRankEqZero_apply\n-/\n\n",
 "nonempty_linearEquiv_of_rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print nonempty_linearEquiv_of_rank_eq /-\n/-- Two vector spaces are isomorphic if they have the same dimension. -/\ntheorem nonempty_linearEquiv_of_rank_eq (cond : Module.rank K V = Module.rank K V₁) : Nonempty («expr ≃ₗ[ ] » V K V₁) :=\n  nonempty_linearEquiv_of_lift_rank_eq <| congr_arg _ cond\n#align nonempty_linear_equiv_of_rank_eq nonempty_linearEquiv_of_rank_eq\n-/\n\n",
 "nonempty_linearEquiv_of_lift_rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print nonempty_linearEquiv_of_lift_rank_eq /-\n/-- Two vector spaces are isomorphic if they have the same dimension. -/\ntheorem nonempty_linearEquiv_of_lift_rank_eq\n    (cond : Cardinal.lift.{v'} (Module.rank K V) = Cardinal.lift.{v} (Module.rank K V')) :\n    Nonempty («expr ≃ₗ[ ] » V K V') :=\n  by\n  obtain ⟨⟨_, B⟩⟩ := module.free.exists_basis K V\n  obtain ⟨⟨_, B'⟩⟩ := module.free.exists_basis K V'\n  have : Cardinal.lift.{v', v} (cardinal.mk _) = Cardinal.lift.{v, v'} (cardinal.mk _) := by\n    rw [B.mk_eq_rank'', cond, B'.mk_eq_rank'']\n  exact (Cardinal.lift_mk_eq.{v, v', 0}.1 this).map (B.equiv B')\n#align nonempty_linear_equiv_of_lift_rank_eq nonempty_linearEquiv_of_lift_rank_eq\n-/\n\n",
 "nonempty_fintype_index_of_rank_lt_aleph0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print Basis.nonempty_fintype_index_of_rank_lt_aleph0 /-\n/-- If a module has a finite dimension, all bases are indexed by a finite type. -/\ntheorem Basis.nonempty_fintype_index_of_rank_lt_aleph0 {ι : Type _} (b : Basis ι R M)\n    (h : Module.rank R M < cardinal.aleph_0) : Nonempty (Fintype ι) := by\n  rwa [← Cardinal.lift_lt, ← b.mk_eq_rank, Cardinal.lift_aleph0, Cardinal.lift_lt_aleph0,\n    Cardinal.lt_aleph0_iff_fintype] at h\n#align basis.nonempty_fintype_index_of_rank_lt_aleph_0 Basis.nonempty_fintype_index_of_rank_lt_aleph0\n-/\n\n",
 "nonempty_equiv_iff_rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print LinearEquiv.nonempty_equiv_iff_rank_eq /-\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem LinearEquiv.nonempty_equiv_iff_rank_eq : Nonempty («expr ≃ₗ[ ] » V K V₁) ↔ Module.rank K V = Module.rank K V₁ :=\n  ⟨fun ⟨h⟩ => LinearEquiv.rank_eq h, fun h => nonempty_linearEquiv_of_rank_eq h⟩\n#align linear_equiv.nonempty_equiv_iff_rank_eq LinearEquiv.nonempty_equiv_iff_rank_eq\n-/\n\n",
 "nonempty_equiv_iff_lift_rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print LinearEquiv.nonempty_equiv_iff_lift_rank_eq /-\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem LinearEquiv.nonempty_equiv_iff_lift_rank_eq :\n    Nonempty («expr ≃ₗ[ ] » V K V') ↔ Cardinal.lift.{v'} (Module.rank K V) = Cardinal.lift.{v} (Module.rank K V') :=\n  ⟨fun ⟨h⟩ => LinearEquiv.lift_rank_eq h, fun h => nonempty_linearEquiv_of_lift_rank_eq h⟩\n#align linear_equiv.nonempty_equiv_iff_lift_rank_eq LinearEquiv.nonempty_equiv_iff_lift_rank_eq\n-/\n\n",
 "mk_range_eq_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print Basis.mk_range_eq_rank /-\ntheorem Basis.mk_range_eq_rank (v : Basis ι R M) : cardinal.mk (range v) = Module.rank R M :=\n  v.reindex_range.mk_eq_rank''\n#align basis.mk_range_eq_rank Basis.mk_range_eq_rank\n-/\n\n",
 "mk_eq_rank''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print Basis.mk_eq_rank'' /-\ntheorem Basis.mk_eq_rank'' {ι : Type v} (v : Basis ι R M) : cardinal.mk ι = Module.rank R M :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [Module.rank]\n  apply le_antisymm\n  · trans\n    swap\n    apply le_csupᵢ (Cardinal.bddAbove_range.{v, v} _)\n    exact\n      ⟨Set.range v, by\n        convert v.reindex_range.linear_independent\n        ext\n        simp⟩\n    exact (Cardinal.mk_range_eq v v.injective).ge\n  · apply csupᵢ_le'\n    rintro ⟨s, li⟩\n    apply linearIndependent_le_basis v _ li\n#align basis.mk_eq_rank'' Basis.mk_eq_rank''\n-/\n\n",
 "mk_eq_rank'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print Basis.mk_eq_rank' /-\ntheorem Basis.mk_eq_rank'.{m} (v : Basis ι R M) :\n    Cardinal.lift.{max v m} (cardinal.mk ι) = Cardinal.lift.{max w m} (Module.rank R M) := by simpa using v.mk_eq_rank\n#align basis.mk_eq_rank' Basis.mk_eq_rank'\n-/\n\n",
 "mk_eq_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print Basis.mk_eq_rank /-\ntheorem Basis.mk_eq_rank (v : Basis ι R M) : Cardinal.lift.{v} (cardinal.mk ι) = Cardinal.lift.{w} (Module.rank R M) :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [← v.mk_range_eq_rank, Cardinal.mk_range_eq_of_injective v.injective]\n#align basis.mk_eq_rank Basis.mk_eq_rank\n-/\n\n",
 "mk_eq_mk_of_basis'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print mk_eq_mk_of_basis' /-\ntheorem mk_eq_mk_of_basis' {ι' : Type w} (v : Basis ι R M) (v' : Basis ι' R M) : cardinal.mk ι = cardinal.mk ι' :=\n  Cardinal.lift_inj.1 <| mk_eq_mk_of_basis v v'\n#align mk_eq_mk_of_basis' mk_eq_mk_of_basis'\n-/\n\n",
 "mk_eq_mk_of_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≪≫ₗ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print mk_eq_mk_of_basis /-\n/-- The dimension theorem: if `v` and `v'` are two bases, their index types\nhave the same cardinalities. -/\ntheorem mk_eq_mk_of_basis (v : Basis ι R M) (v' : Basis ι' R M) :\n    Cardinal.lift.{w'} (cardinal.mk ι) = Cardinal.lift.{w} (cardinal.mk ι') :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  cases fintypeOrInfinite ι\n  · -- `v` is a finite basis, so by `basis_fintype_of_finite_spans` so is `v'`.\n    haveI : Fintype (range v) := Set.fintypeRange v\n    haveI := basisFintypeOfFiniteSpans _ v.span_eq v'\n    -- We clean up a little:\n    rw [Cardinal.mk_fintype, Cardinal.mk_fintype]\n    simp only [Cardinal.lift_natCast, Cardinal.natCast_inj]\n    -- Now we can use invariant basis number to show they have the same cardinality.\n    apply card_eq_of_linearEquiv R\n    exact\n      «expr ≪≫ₗ » («expr ≪≫ₗ » ((Finsupp.linearEquivFunOnFinite R R ι).symm.trans v.repr.symm) v'.repr)\n        (Finsupp.linearEquivFunOnFinite R R ι')\n  · -- `v` is an infinite basis,\n    -- so by `infinite_basis_le_maximal_linear_independent`, `v'` is at least as big,\n    -- and then applying `infinite_basis_le_maximal_linear_independent` again\n    -- we see they have the same cardinality.\n    have w₁ := infinite_basis_le_maximal_linearIndependent' v _ v'.linear_independent v'.maximal\n    rcases cardinal.lift_mk_le'.mp w₁ with ⟨f⟩\n    haveI : Infinite ι' := Infinite.of_injective f f.2\n    have w₂ := infinite_basis_le_maximal_linearIndependent' v' _ v.linear_independent v.maximal\n    exact le_antisymm w₁ w₂\n#align mk_eq_mk_of_basis mk_eq_mk_of_basis\n-/\n\n",
 "maximal_linearIndependent_eq_infinite_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print maximal_linearIndependent_eq_infinite_basis /-\n-- When the basis is not infinite this need not be true!\n/-- Over any ring `R` satisfying the strong rank condition,\nif `b` is an infinite basis for a module `M`,\nthen every maximal linearly independent set has the same cardinality as `b`.\n\nThis proof (along with some of the lemmas above) comes from\n[Les familles libres maximales d'un module ont-elles le meme cardinal?][lazarus1973]\n-/\ntheorem maximal_linearIndependent_eq_infinite_basis {ι : Type _} (b : Basis ι R M) [Infinite ι] {κ : Type _} (v : κ → M)\n    (i : LinearIndependent R v) (m : i.maximal) : cardinal.mk κ = cardinal.mk ι :=\n  by\n  apply le_antisymm\n  · exact linearIndependent_le_basis b v i\n  · haveI : Nontrivial R := nontrivial_of_invariantBasisNumber R\n    exact infinite_basis_le_maximal_linearIndependent b v i m\n#align maximal_linear_independent_eq_infinite_basis maximal_linearIndependent_eq_infinite_basis\n-/\n\n",
 "linearIndependent_le_span_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print linearIndependent_le_span_finset /-\n/-- A version of `linear_independent_le_span` for `finset`. -/\ntheorem linearIndependent_le_span_finset {ι : Type _} (v : ι → M) (i : LinearIndependent R v) (w : Finset M)\n    (s : span R (w : Set M) = «expr⊤») : cardinal.mk ι ≤ w.card := by\n  simpa only [Finset.coe_sort_coe, Fintype.card_coe] using linearIndependent_le_span v i w s\n#align linear_independent_le_span_finset linearIndependent_le_span_finset\n-/\n\n",
 "linearIndependent_le_span_aux'":
 "#print linearIndependent_le_span_aux' /-\n-- An auxiliary lemma for `linear_independent_le_span'`,\n-- with the additional assumption that the linearly independent family is finite.\ntheorem linearIndependent_le_span_aux' {ι : Type _} [Fintype ι] (v : ι → M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : range v ≤ span R w) : Fintype.card ι ≤ Fintype.card w :=\n  by\n  -- We construct an injective linear map `(ι → R) →ₗ[R] (w → R)`,\n  -- by thinking of `f : ι → R` as a linear combination of the finite family `v`,\n  -- and expressing that (using the axiom of choice) as a linear combination over `w`.\n  -- We can do this linearly by constructing the map on a basis.\n  fapply card_le_of_injective' R\n  · apply Finsupp.total\n    exact fun i => Span.repr R w ⟨v i, s (mem_range_self i)⟩\n  · intro f g h\n    apply_fun Finsupp.total w M R coe  at h\n    simp only [Finsupp.total_total, Submodule.coe_mk, Span.finsupp_total_repr] at h\n    rw [← sub_eq_zero, ← LinearMap.map_sub] at h\n    exact sub_eq_zero.mp (linear_independent_iff.mp i _ h)\n#align linear_independent_le_span_aux' linearIndependent_le_span_aux'\n-/\n\n",
 "linearIndependent_le_span'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print linearIndependent_le_span' /-\n/-- If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : ι → M`\ncontained in the span of some finite `w : set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem linearIndependent_le_span' {ι : Type _} (v : ι → M) (i : LinearIndependent R v) (w : Set M) [Fintype w]\n    (s : range v ≤ span R w) : cardinal.mk ι ≤ Fintype.card w :=\n  by\n  haveI : Fintype ι := linearIndependentFintypeOfLeSpanFintype v i w s\n  rw [Cardinal.mk_fintype]\n  simp only [Cardinal.natCast_le]\n  exact linearIndependent_le_span_aux' v i w s\n#align linear_independent_le_span' linearIndependent_le_span'\n-/\n\n",
 "linearIndependent_le_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print linearIndependent_le_span /-\n/-- If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : ι → M`\nand any finite spanning set `w : set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem linearIndependent_le_span {ι : Type _} (v : ι → M) (i : LinearIndependent R v) (w : Set M) [Fintype w]\n    (s : span R w = «expr⊤») : cardinal.mk ι ≤ Fintype.card w :=\n  by\n  apply linearIndependent_le_span' v i w\n  rw [s]\n  exact le_top\n#align linear_independent_le_span linearIndependent_le_span\n-/\n\n",
 "linearIndependent_le_infinite_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print linearIndependent_le_infinite_basis /-\n/-- An auxiliary lemma for `linear_independent_le_basis`:\nwe handle the case where the basis `b` is infinite.\n-/\ntheorem linearIndependent_le_infinite_basis {ι : Type _} (b : Basis ι R M) [Infinite ι] {κ : Type _} (v : κ → M)\n    (i : LinearIndependent R v) : cardinal.mk κ ≤ cardinal.mk ι :=\n  by\n  by_contra\n  rw [not_le, ← Cardinal.mk_finset_of_infinite ι] at h\n  let Φ := fun k : κ => (b.repr (v k)).support\n  obtain ⟨s, w : Infinite («expr↥ » («expr ⁻¹' » Φ {s}))⟩ := Cardinal.exists_infinite_fiber Φ h (by infer_instance)\n  let v' := fun k : «expr ⁻¹' » Φ {s} => v k\n  have i' : LinearIndependent R v' := i.comp _ Subtype.val_injective\n  have w' : Fintype («expr ⁻¹' » Φ {s}) :=\n    by\n    apply linearIndependentFintypeOfLeSpanFintype v' i' (s.image b)\n    rintro m ⟨⟨p, ⟨rfl⟩⟩, rfl⟩\n    simp only [SetLike.mem_coe, Subtype.coe_mk, Finset.coe_image]\n    apply Basis.mem_span_repr_support\n  exact w.false\n#align linear_independent_le_infinite_basis linearIndependent_le_infinite_basis\n-/\n\n",
 "linearIndependent_le_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print linearIndependent_le_basis /-\n/-- Over any ring `R` satisfying the strong rank condition,\nif `b` is a basis for a module `M`,\nand `s` is a linearly independent set,\nthen the cardinality of `s` is bounded by the cardinality of `b`.\n-/\ntheorem linearIndependent_le_basis {ι : Type _} (b : Basis ι R M) {κ : Type _} (v : κ → M) (i : LinearIndependent R v) :\n    cardinal.mk κ ≤ cardinal.mk ι :=\n  by\n  -- We split into cases depending on whether `ι` is infinite.\n    cases fintypeOrInfinite ι <;>\n    skip\n  · -- When `ι` is finite, we have `linear_independent_le_span`,\n    rw [Cardinal.mk_fintype ι]\n    haveI : Nontrivial R := nontrivial_of_invariantBasisNumber R\n    rw [Fintype.card_congr (Equiv.ofInjective b b.injective)]\n    exact linearIndependent_le_span v i (range b) b.span_eq\n  ·-- and otherwise we have `linear_indepedent_le_infinite_basis`.\n    exact linearIndependent_le_infinite_basis b v i\n#align linear_independent_le_basis linearIndependent_le_basis\n-/\n\n",
 "lift_rank_range_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print lift_rank_range_le /-\ntheorem lift_rank_range_le (f : «expr →ₗ[ ] » M R M') :\n    Cardinal.lift.{v} (Module.rank R f.range) ≤ Cardinal.lift.{v'} (Module.rank R M) :=\n  by\n  dsimp [Module.rank]\n  rw [Cardinal.lift_supᵢ (Cardinal.bddAbove_range.{v', v'} _)]\n  apply csupᵢ_le'\n  rintro ⟨s, li⟩\n  apply le_trans\n  swap\n  apply cardinal.lift_le.mpr\n  refine' le_csupᵢ (Cardinal.bddAbove_range.{v, v} _) ⟨«expr '' » (range_splitting f) s, _⟩\n  · apply LinearIndependent.of_comp f.range_restrict\n    convert li.comp (Equiv.Set.rangeSplittingImageEquiv f s) (Equiv.injective _) using 1\n  · exact (cardinal.lift_mk_eq'.mpr ⟨Equiv.Set.rangeSplittingImageEquiv f s⟩).ge\n#align lift_rank_range_le lift_rank_range_le\n-/\n\n",
 "lift_rank_map_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print lift_rank_map_le /-\ntheorem lift_rank_map_le (f : «expr →ₗ[ ] » M R M') (p : Submodule R M) :\n    Cardinal.lift.{v} (Module.rank R (p.map f)) ≤ Cardinal.lift.{v'} (Module.rank R p) :=\n  by\n  have h := lift_rank_range_le (f.comp (Submodule.subtype p))\n  rwa [LinearMap.range_comp, range_subtype] at h\n#align lift_rank_map_le lift_rank_map_le\n-/\n\n",
 "lift_rank_le_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearMap.lift_rank_le_of_injective /-\n/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Johannes Hölzl, Sander Dahmen, Scott Morrison\n-/\ntheorem LinearMap.lift_rank_le_of_injective (f : «expr →ₗ[ ] » M R M') (i : injective f) :\n    Cardinal.lift.{v'} (Module.rank R M) ≤ Cardinal.lift.{v} (Module.rank R M') :=\n  by\n  dsimp [Module.rank]\n  rw [Cardinal.lift_supᵢ (Cardinal.bddAbove_range.{v', v'} _), Cardinal.lift_supᵢ (Cardinal.bddAbove_range.{v, v} _)]\n  apply csupᵢ_mono' (Cardinal.bddAbove_range.{v', v} _)\n  rintro ⟨s, li⟩\n  refine' ⟨⟨«expr '' » f s, _⟩, cardinal.lift_mk_le'.mpr ⟨(Equiv.Set.image f s i).to_embedding⟩⟩\n  exact (li.map' _ <| linear_map.ker_eq_bot.mpr i).image\n#align linear_map.lift_rank_le_of_injective LinearMap.lift_rank_le_of_injective\n-/\n\n",
 "lift_rank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print LinearEquiv.lift_rank_eq /-\n/-- Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. -/\ntheorem LinearEquiv.lift_rank_eq (f : «expr ≃ₗ[ ] » M R M') :\n    Cardinal.lift.{v'} (Module.rank R M) = Cardinal.lift.{v} (Module.rank R M') :=\n  by\n  apply le_antisymm\n  · exact f.to_linear_map.lift_rank_le_of_injective f.injective\n  · exact f.symm.to_linear_map.lift_rank_le_of_injective f.symm.injective\n#align linear_equiv.lift_rank_eq LinearEquiv.lift_rank_eq\n-/\n\n",
 "lift_rank_comp_le_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem lift_rank_comp_le_right (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'') :\n    Cardinal.lift.{v'} (rank (f.comp g)) ≤ Cardinal.lift.{v''} (rank g) := by\n  rw [rank, rank, LinearMap.range_comp] <;> exact lift_rank_map_le _ _\n#align lift_rank_comp_le_right lift_rank_comp_le_right\n\n",
 "lift_rank_comp_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The rank of the composition of two maps is less than the minimum of their ranks. -/\ntheorem lift_rank_comp_le (g : «expr →ₗ[ ] » V K V') (f : «expr →ₗ[ ] » V' K V'') :\n    Cardinal.lift.{v'} (rank (f.comp g)) ≤ min (Cardinal.lift.{v'} (rank f)) (Cardinal.lift.{v''} (rank g)) :=\n  le_min (Cardinal.lift_le.mpr <| rank_comp_le_left _ _) (lift_rank_comp_le_right _ _)\n#align lift_rank_comp_le lift_rank_comp_le\n\n",
 "le_span''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Basis.le_span'' /-\n/-- An auxiliary lemma for `basis.le_span`.\n\nIf `R` satisfies the rank condition,\nthen for any finite basis `b : basis ι R M`,\nand any finite spanning set `w : set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem Basis.le_span'' {ι : Type _} [Fintype ι] (b : Basis ι R M) {w : Set M} [Fintype w] (s : span R w = «expr⊤») :\n    Fintype.card ι ≤ Fintype.card w :=\n  by\n  -- We construct an surjective linear map `(w → R) →ₗ[R] (ι → R)`,\n  -- by expressing a linear combination in `w` as a linear combination in `ι`.\n  fapply card_le_of_surjective' R\n  · exact b.repr.to_linear_map.comp (Finsupp.total w M R coe)\n  · apply surjective.comp\n    apply LinearEquiv.surjective\n    rw [← LinearMap.range_eq_top, Finsupp.range_total]\n    simpa using s\n#align basis.le_span'' Basis.le_span''\n-/\n\n",
 "le_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print Basis.le_span /-\n-- Note that if `R` satisfies the strong rank condition,\n-- this also follows from `linear_independent_le_span` below.\n/-- If `R` satisfies the rank condition,\nthen the cardinality of any basis is bounded by the cardinality of any spanning set.\n-/\ntheorem Basis.le_span {J : Set M} (v : Basis ι R M) (hJ : span R J = «expr⊤») : cardinal.mk (range v) ≤ cardinal.mk J :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  cases fintypeOrInfinite J\n  · rw [← Cardinal.lift_le, Cardinal.mk_range_eq_of_injective v.injective, Cardinal.mk_fintype J]\n    convert Cardinal.lift_le.{w, v}.2 (basis_le_span' v hJ)\n    simp\n  · have := Cardinal.mk_range_eq_of_injective v.injective\n    let S : J → Set ι := fun j => ↑(v.repr j).support\n    let S' : J → Set M := fun j => «expr '' » v (S j)\n    have hs :\n      range v ⊆\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S' j) :=\n      by\n      intro b hb\n      rcases mem_range.1 hb with ⟨i, hi⟩\n      have :\n        span R J ≤\n          comap v.repr.to_linear_map\n            (Finsupp.supported R R\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                (S j))) :=\n        span_le.2 fun j hj x hx => ⟨_, ⟨⟨j, hj⟩, rfl⟩, hx⟩\n      rw [hJ] at this\n      replace :\n        v.repr (v i) ∈\n          Finsupp.supported R R\n            («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S j)) :=\n        this trivial\n      rw [v.repr_self, Finsupp.mem_supported, Finsupp.support_single_ne_zero _ one_ne_zero] at this\n      · subst b\n        rcases mem_Union.1 (this (Finset.mem_singleton_self _)) with ⟨j, hj⟩\n        exact mem_Union.2 ⟨j, (mem_image _ _ _).2 ⟨i, hj, rfl⟩⟩\n      · infer_instance\n    refine' le_of_not_lt fun IJ => _\n    suffices\n      cardinal.mk\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (S' j)) <\n        cardinal.mk (range v)\n      by exact not_le_of_lt this ⟨Set.embeddingOfSubset _ _ hs⟩\n    refine'\n      lt_of_le_of_lt (le_trans Cardinal.mk_unionᵢ_le_sum_mk (Cardinal.sum_le_sum _ (fun _ => cardinal.aleph_0) _)) _\n    · exact fun j => (Cardinal.lt_aleph0_of_finite _).le\n    · simpa\n#align basis.le_span Basis.le_span\n-/\n\n",
 "le_rank_iff_exists_linearIndependent_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print le_rank_iff_exists_linearIndependent_finset /-\ntheorem le_rank_iff_exists_linearIndependent_finset {n : ℕ} {f : «expr →ₗ[ ] » V K V'} :\n    ↑n ≤ rank f ↔ ∃ s : Finset V, s.card = n ∧ LinearIndependent K fun x : (s : Set V) => f x :=\n  by\n  simp only [le_rank_iff_exists_linearIndependent, Cardinal.lift_natCast, Cardinal.lift_eq_nat_iff,\n    Cardinal.mk_set_eq_nat_iff_finset]\n  constructor\n  · rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩\n    exact ⟨t, rfl, si⟩\n  · rintro ⟨s, rfl, si⟩\n    exact ⟨s, ⟨s, rfl, rfl⟩, si⟩\n#align le_rank_iff_exists_linear_independent_finset le_rank_iff_exists_linearIndependent_finset\n-/\n\n",
 "le_rank_iff_exists_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print le_rank_iff_exists_linearIndependent /-\ntheorem le_rank_iff_exists_linearIndependent {c : Cardinal} {f : «expr →ₗ[ ] » V K V'} :\n    c ≤ rank f ↔\n      ∃ s : Set V, Cardinal.lift.{v'} (cardinal.mk s) = Cardinal.lift.{v} c ∧ LinearIndependent K fun x : s => f x :=\n  by\n  rcases f.range_restrict.exists_right_inverse_of_surjective f.range_range_restrict with ⟨g, hg⟩\n  have fg : left_inverse f.range_restrict g := LinearMap.congr_fun hg\n  refine' ⟨fun h => _, _⟩\n  · rcases le_rank_iff_exists_linearIndependent.1 h with ⟨s, rfl, si⟩\n    refine' ⟨«expr '' » g s, Cardinal.mk_image_eq_lift _ _ fg.injective, _⟩\n    replace fg : ∀ x, f (g x) = x\n    · intro x\n      convert congr_arg Subtype.val (fg x)\n    replace si : LinearIndependent K fun x : s => f (g x)\n    · simpa only [fg] using si.map' _ (ker_subtype _)\n    exact si.image_of_comp s g f\n  · rintro ⟨s, hsc, si⟩\n    have : LinearIndependent K fun x : s => f.range_restrict x :=\n      LinearIndependent.of_comp f.range.subtype (by convert si)\n    convert cardinal_le_rank_of_linearIndependent this.image\n    rw [← Cardinal.lift_inj, ← hsc, Cardinal.mk_image_eq_of_injOn_lift]\n    exact inj_on_iff_injective.2 this.injective\n#align le_rank_iff_exists_linear_independent le_rank_iff_exists_linearIndependent\n-/\n\n",
 "infinite_basis_le_maximal_linearIndependent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print infinite_basis_le_maximal_linearIndependent' /-\n/-- Over any ring `R`, if `b` is an infinite basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the cardinality of `b` is bounded by the cardinality of `s`.\n-/\ntheorem infinite_basis_le_maximal_linearIndependent' {ι : Type w} (b : Basis ι R M) [Infinite ι] {κ : Type w'}\n    (v : κ → M) (i : LinearIndependent R v) (m : i.maximal) :\n    Cardinal.lift.{w'} (cardinal.mk ι) ≤ Cardinal.lift.{w} (cardinal.mk κ) :=\n  by\n  let Φ := fun k : κ => (b.repr (v k)).support\n  have w₁ : cardinal.mk ι ≤ cardinal.mk (Set.range Φ) :=\n    by\n    apply Cardinal.le_range_of_union_finset_eq_top\n    exact union_support_maximal_linearIndependent_eq_range_basis b v i m\n  have w₂ : Cardinal.lift.{w'} (cardinal.mk (Set.range Φ)) ≤ Cardinal.lift.{w} (cardinal.mk κ) :=\n    Cardinal.mk_range_le_lift\n  exact (cardinal.lift_le.mpr w₁).trans w₂\n#align infinite_basis_le_maximal_linear_independent' infinite_basis_le_maximal_linearIndependent'\n-/\n\n",
 "infinite_basis_le_maximal_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print infinite_basis_le_maximal_linearIndependent /-\n-- (See `infinite_basis_le_maximal_linear_independent'` for the more general version\n-- where the index types can live in different universes.)\n/-- Over any ring `R`, if `b` is an infinite basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the cardinality of `b` is bounded by the cardinality of `s`.\n-/\ntheorem infinite_basis_le_maximal_linearIndependent {ι : Type w} (b : Basis ι R M) [Infinite ι] {κ : Type w} (v : κ → M)\n    (i : LinearIndependent R v) (m : i.maximal) : cardinal.mk ι ≤ cardinal.mk κ :=\n  Cardinal.lift_le.mp (infinite_basis_le_maximal_linearIndependent' b v i m)\n#align infinite_basis_le_maximal_linear_independent infinite_basis_le_maximal_linearIndependent\n-/\n\n",
 "finite_of_isNoetherian":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print LinearIndependent.finite_of_isNoetherian /-\n/-- A linearly-independent family of vectors in a module over a non-trivial ring must be finite if\nthe module is Noetherian. -/\ntheorem LinearIndependent.finite_of_isNoetherian [IsNoetherian R M] {v : ι → M} (hv : LinearIndependent R v) :\n    Finite ι := by\n  have hwf := is_noetherian_iff_well_founded.mp (by infer_instance : IsNoetherian R M)\n  refine' CompleteLattice.WellFounded.finite_of_independent hwf hv.independent_span_singleton fun i contra => _\n  apply hv.ne_zero i\n  have : v i ∈ «expr ∙ » R (v i) := Submodule.mem_span_singleton_self (v i)\n  rwa [contra, Submodule.mem_bot] at this\n#align linear_independent.finite_of_is_noetherian LinearIndependent.finite_of_isNoetherian\n-/\n\n",
 "finite_ofVectorSpaceIndex_of_rank_lt_aleph0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0 /-\n-- TODO: merge with the `finrank` content\n/-- If a vector space has a finite dimension, the index set of `basis.of_vector_space` is finite. -/\ntheorem Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0 (h : Module.rank K V < cardinal.aleph_0) :\n    (Basis.ofVectorSpaceIndex K V).finite :=\n  finite_def.2 <| (Basis.ofVectorSpace K V).nonempty_fintype_index_of_rank_lt_aleph_0 h\n#align basis.finite_of_vector_space_index_of_rank_lt_aleph_0 Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0\n-/\n\n",
 "finite_index_of_rank_lt_aleph0":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\n#print Basis.finite_index_of_rank_lt_aleph0 /-\n/-- If a module has a finite dimension, all bases are indexed by a finite set. -/\ntheorem Basis.finite_index_of_rank_lt_aleph0 {ι : Type _} {s : Set ι} (b : Basis s R M)\n    (h : Module.rank R M < cardinal.aleph_0) : s.finite :=\n  finite_def.2 (b.nonempty_fintype_index_of_rank_lt_aleph_0 h)\n#align basis.finite_index_of_rank_lt_aleph_0 Basis.finite_index_of_rank_lt_aleph0\n-/\n\n",
 "exists_mem_ne_zero_of_rank_pos":
 "#print exists_mem_ne_zero_of_rank_pos /-\ntheorem exists_mem_ne_zero_of_rank_pos {s : Submodule R M} (h : 0 < Module.rank R s) : ∃ b : M, b ∈ s ∧ b ≠ 0 :=\n  exists_mem_ne_zero_of_ne_bot fun eq => by rw [Eq, rank_bot] at h <;> exact lt_irrefl _ h\n#align exists_mem_ne_zero_of_rank_pos exists_mem_ne_zero_of_rank_pos\n-/\n\n",
 "cardinal_lift_le_rank_of_linearIndependent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print cardinal_lift_le_rank_of_linearIndependent' /-\ntheorem cardinal_lift_le_rank_of_linearIndependent' {ι : Type w} {v : ι → M} (hv : LinearIndependent R v) :\n    Cardinal.lift.{v} (cardinal.mk ι) ≤ Cardinal.lift.{w} (Module.rank R M) :=\n  cardinal_lift_le_rank_of_linearIndependent.{u, v, w, 0} hv\n#align cardinal_lift_le_rank_of_linear_independent' cardinal_lift_le_rank_of_linearIndependent'\n-/\n\n",
 "cardinal_lift_le_rank_of_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print cardinal_lift_le_rank_of_linearIndependent /-\ntheorem cardinal_lift_le_rank_of_linearIndependent.{m} {ι : Type w} {v : ι → M} (hv : LinearIndependent R v) :\n    Cardinal.lift.{max v m} (cardinal.mk ι) ≤ Cardinal.lift.{max w m} (Module.rank R M) :=\n  by\n  apply le_trans\n  · exact cardinal.lift_mk_le.mpr ⟨(Equiv.ofInjective _ hv.injective).to_embedding⟩\n  · simp only [Cardinal.lift_le, Module.rank]\n    apply le_trans\n    swap\n    exact le_csupᵢ (Cardinal.bddAbove_range.{v, v} _) ⟨range v, hv.coe_range⟩\n    exact le_rfl\n#align cardinal_lift_le_rank_of_linear_independent cardinal_lift_le_rank_of_linearIndependent\n-/\n\n",
 "cardinal_le_rank_of_linearIndependent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print cardinal_le_rank_of_linearIndependent' /-\ntheorem cardinal_le_rank_of_linearIndependent' {s : Set M} (hs : LinearIndependent R (fun x => x : s → M)) :\n    cardinal.mk s ≤ Module.rank R M :=\n  cardinal_le_rank_of_linearIndependent hs\n#align cardinal_le_rank_of_linear_independent' cardinal_le_rank_of_linearIndependent'\n-/\n\n",
 "cardinal_le_rank_of_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print cardinal_le_rank_of_linearIndependent /-\ntheorem cardinal_le_rank_of_linearIndependent {ι : Type v} {v : ι → M} (hv : LinearIndependent R v) :\n    cardinal.mk ι ≤ Module.rank R M := by simpa using cardinal_lift_le_rank_of_linearIndependent hv\n#align cardinal_le_rank_of_linear_independent cardinal_le_rank_of_linearIndependent\n-/\n\n",
 "card_le_card_of_submodule":
 "#print Basis.card_le_card_of_submodule /-\ntheorem Basis.card_le_card_of_submodule (N : Submodule R M) [Fintype ι] (b : Basis ι R M) [Fintype ι']\n    (b' : Basis ι' R N) : Fintype.card ι' ≤ Fintype.card ι :=\n  b.card_le_card_of_linear_independent (b'.linear_independent.map' N.subtype N.ker_subtype)\n#align basis.card_le_card_of_submodule Basis.card_le_card_of_submodule\n-/\n\n",
 "card_le_card_of_linearIndependent_aux":
 "#print Basis.card_le_card_of_linearIndependent_aux /-\n/-- In an `n`-dimensional space, the rank is at most `m`. -/\ntheorem Basis.card_le_card_of_linearIndependent_aux {R : Type _} [Ring R] [StrongRankCondition R] (n : ℕ) {m : ℕ}\n    (v : Fin m → Fin n → R) : LinearIndependent R v → m ≤ n := fun h => by\n  simpa using linearIndependent_le_basis (Pi.basisFun R (Fin n)) v h\n#align basis.card_le_card_of_linear_independent_aux Basis.card_le_card_of_linearIndependent_aux\n-/\n\n",
 "card_le_card_of_linearIndependent":
 "#print Basis.card_le_card_of_linearIndependent /-\ntheorem Basis.card_le_card_of_linearIndependent {ι : Type _} [Fintype ι] (b : Basis ι R M) {ι' : Type _} [Fintype ι']\n    {v : ι' → M} (hv : LinearIndependent R v) : Fintype.card ι' ≤ Fintype.card ι :=\n  by\n  letI := nontrivial_of_invariantBasisNumber R\n  simpa [rank_eq_card_basis b, Cardinal.mk_fintype] using cardinal_lift_le_rank_of_linearIndependent' hv\n#align basis.card_le_card_of_linear_independent Basis.card_le_card_of_linearIndependent\n-/\n\n",
 "card_le_card_of_le":
 "#print Basis.card_le_card_of_le /-\ntheorem Basis.card_le_card_of_le {N O : Submodule R M} (hNO : N ≤ O) [Fintype ι] (b : Basis ι R O) [Fintype ι']\n    (b' : Basis ι' R N) : Fintype.card ι' ≤ Fintype.card ι :=\n  b.card_le_card_of_linear_independent (b'.linear_independent.map' (Submodule.ofLe hNO) (N.ker_of_le O _))\n#align basis.card_le_card_of_le Basis.card_le_card_of_le\n-/\n\n",
 "basis_le_span'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print basis_le_span' /-\n/-- Another auxiliary lemma for `basis.le_span`, which does not require assuming the basis is finite,\nbut still assumes we have a finite spanning set.\n-/\ntheorem basis_le_span' {ι : Type _} (b : Basis ι R M) {w : Set M} [Fintype w] (s : span R w = «expr⊤») :\n    cardinal.mk ι ≤ Fintype.card w :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber R\n  haveI := basisFintypeOfFiniteSpans w s b\n  rw [Cardinal.mk_fintype ι]\n  simp only [Cardinal.natCast_le]\n  exact Basis.le_span'' b s\n#align basis_le_span' basis_le_span'\n-/\n\n"}