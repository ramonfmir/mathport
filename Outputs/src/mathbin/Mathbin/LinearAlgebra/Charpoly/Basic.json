{"pow_eq_aeval_mod_charpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/-- Any endomorphism power can be computed as the sum of endomorphism powers less than the\ndimension of the module. -/\ntheorem pow_eq_aeval_mod_charpoly (k : ℕ) : f ^ k = aeval f («expr %ₘ » (X ^ k) f.charpoly) := by\n  rw [← aeval_eq_aeval_mod_charpoly, map_pow, aeval_X]\n#align pow_eq_aeval_mod_charpoly pow_eq_aeval_mod_charpoly\n\n",
 "minpoly_dvd_charpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem minpoly_dvd_charpoly {K : Type u} {M : Type v} [Field K] [AddCommGroup M] [Module K M] [FiniteDimensional K M]\n    (f : «expr →ₗ[ ] » M K M) : minpoly K f ∣ f.charpoly :=\n  minpoly.dvd _ _ (aeval_self_charpoly f)\n#align minpoly_dvd_charpoly minpoly_dvd_charpoly\n\n",
 "minpoly_coeff_zero_of_injective":
 "theorem minpoly_coeff_zero_of_injective (hf : function.injective f) : (minpoly R f).coeff 0 ≠ 0 :=\n  by\n  intro h\n  obtain ⟨P, hP⟩ := X_dvd_iff.2 h\n  have hdegP : P.degree < (minpoly R f).degree := by\n    rw [hP, mul_comm]\n    refine' degree_lt_degree_mul_X fun h => _\n    rw [h, MulZeroClass.mul_zero] at hP\n    exact minpoly.ne_zero (is_integral f) hP\n  have hPmonic : P.monic :=\n    by\n    suffices (minpoly R f).monic by rwa [monic.def, hP, mul_comm, leading_coeff_mul_X, ← monic.def] at this\n    exact minpoly.monic (is_integral f)\n  have hzero : aeval f (minpoly R f) = 0 := minpoly.aeval _ _\n  simp only [hP, mul_eq_comp, ext_iff, hf, aeval_X, map_eq_zero_iff, coe_comp, AlgHom.map_mul, zero_apply] at hzero\n  exact not_le.2 hdegP (minpoly.min _ _ hPmonic (ext hzero))\n#align minpoly_coeff_zero_of_injective minpoly_coeff_zero_of_injective\n\n",
 "is_integral":
 "theorem is_integral : is_integral R f :=\n  ⟨f.charpoly, ⟨charpoly_monic f, aeval_self_charpoly f⟩⟩\n#align is_integral is_integral\n\n",
 "charpoly_monic":
 "theorem charpoly_monic : f.charpoly.monic :=\n  charpoly_monic _\n#align charpoly_monic charpoly_monic\n\n",
 "charpoly_def":
 "/-\nCopyright (c) 2021 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem charpoly_def : f.charpoly = (toMatrix (chooseBasis R M) (chooseBasis R M) f).charpoly :=\n  rfl\n#align charpoly_def charpoly_def\n\n",
 "aeval_self_charpoly":
 "/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied\nto the linear map itself, is zero.\n\nSee `matrix.aeval_self_charpoly` for the equivalent statement about matrices. -/\ntheorem aeval_self_charpoly : aeval f f.charpoly = 0 :=\n  by\n  apply (LinearEquiv.map_eq_zero_iff (algEquivMatrix (choose_basis R M)).to_linear_equiv).1\n  rw [AlgEquiv.toLinearEquiv_apply, ← AlgEquiv.coe_algHom, ← Polynomial.aeval_algHom_apply _ _ _, charpoly_def]\n  exact aeval_self_charpoly _\n#align aeval_self_charpoly aeval_self_charpoly\n\n",
 "aeval_eq_aeval_mod_charpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/-- Any endomorphism polynomial `p` is equivalent under evaluation to `p %ₘ f.charpoly`; that is,\n`p` is equivalent to a polynomial with degree less than the dimension of the module. -/\ntheorem aeval_eq_aeval_mod_charpoly (p : polynomial R) : aeval f p = aeval f («expr %ₘ » p f.charpoly) :=\n  (aeval_modByMonic_eq_self_of_root f.charpoly_monic f.aeval_self_charpoly).symm\n#align aeval_eq_aeval_mod_charpoly aeval_eq_aeval_mod_charpoly\n\n"}