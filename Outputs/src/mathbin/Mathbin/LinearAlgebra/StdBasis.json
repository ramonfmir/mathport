{"supr_range_std_basis_le_infi_ker_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem supr_range_std_basis_le_infi_ker_proj (I J : Set ι) (h : Disjoint I J) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (range (stdBasis R φ i)) ≤\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (proj i : «expr →ₗ[ ] » (∀ i, φ i) R (φ i))) :=\n  by\n  refine' supᵢ_le fun i => supᵢ_le fun hi => range_le_iff_comap.2 _\n  simp only [(ker_comp _ _).symm, eq_top_iff, SetLike.le_def, mem_ker, comap_infi, mem_infi]\n  rintro b - j hj\n  rw [proj_std_basis_ne R φ j i, zero_apply]\n  rintro rfl\n  exact h.le_bot ⟨hi, hj⟩\n#align supr_range_std_basis_le_infi_ker_proj supr_range_std_basis_le_infi_ker_proj\n\n",
 "supr_range_std_basis_eq_infi_ker_proj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem supr_range_std_basis_eq_infi_ker_proj {I J : Set ι} (hd : Disjoint I J) (hu : Set.univ ⊆ I ∪ J)\n    (hI : Set.Finite I) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (range (stdBasis R φ i)) =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (proj i : «expr →ₗ[ ] » (∀ i, φ i) R (φ i))) :=\n  by\n  refine' le_antisymm (supr_range_std_basis_le_infi_ker_proj _ _ _ _ hd) _\n  have : Set.univ ⊆ ↑hI.to_finset ∪ J := by rwa [hI.coe_to_finset]\n  refine' le_trans (infi_ker_proj_le_supr_range_std_basis R φ this) (supᵢ_mono fun i => _)\n  rw [Set.Finite.mem_toFinset]\n  exact le_rfl\n#align supr_range_std_basis_eq_infi_ker_proj supr_range_std_basis_eq_infi_ker_proj\n\n",
 "supr_range_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem supr_range_std_basis [Finite ι] :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (range (stdBasis R φ i)) =\n      «expr⊤» :=\n  by\n  cases nonempty_fintype ι\n  convert top_unique (infi_emptyset.ge.trans <| infi_ker_proj_le_supr_range_std_basis R φ _)\n  · exact funext fun i => ((@supᵢ_pos _ _ _ fun h => range <| std_basis R φ i) <| Finset.mem_univ i).symm\n  · rw [Finset.coe_univ, Set.union_empty]\n#align supr_range_std_basis supr_range_std_basis\n\n",
 "std_basis_same":
 "@[simp]\ntheorem std_basis_same (i : ι) (b : φ i) : stdBasis R φ i b i = b :=\n  Pi.single_eq_same i b\n#align std_basis_same std_basis_same\n\n",
 "std_basis_ne":
 "theorem std_basis_ne (i j : ι) (h : j ≠ i) (b : φ i) : stdBasis R φ i b j = 0 :=\n  Pi.single_eq_of_ne h b\n#align std_basis_ne std_basis_ne\n\n",
 "std_basis_eq_std_basis_matrix":
 "theorem std_basis_eq_std_basis_matrix (i : n) (j : m) [DecidableEq n] [DecidableEq m] :\n    stdBasis R n m (i, j) = stdBasisMatrix i j (1 : R) :=\n  by\n  ext (a b)\n  by_cases hi : i = a <;> by_cases hj : j = b\n  · simp [std_basis, hi, hj]\n  · simp [std_basis, hi, hj, ne.symm hj, LinearMap.stdBasis_ne]\n  · simp [std_basis, hi, hj, ne.symm hi, LinearMap.stdBasis_ne]\n  · simp [std_basis, hi, hj, ne.symm hj, ne.symm hi, LinearMap.stdBasis_ne]\n#align std_basis_eq_std_basis_matrix std_basis_eq_std_basis_matrix\n\n",
 "std_basis_eq_single":
 "theorem std_basis_eq_single {a : R} :\n    (fun i : ι => (stdBasis R (fun _ : ι => R) i) a) = fun i : ι => Finsupp.single i a :=\n  funext fun i => (Finsupp.single_eq_pi_single i a).symm\n#align std_basis_eq_single std_basis_eq_single\n\n",
 "std_basis_eq_pi_diag":
 "theorem std_basis_eq_pi_diag (i : ι) : stdBasis R φ i = pi (diag i) :=\n  by\n  ext (x j)\n  convert(update_apply 0 x i j _).symm\n  rfl\n#align std_basis_eq_pi_diag std_basis_eq_pi_diag\n\n",
 "std_basis_apply'":
 "@[simp]\ntheorem std_basis_apply' (i i' : ι) : (stdBasis R (fun _x : ι => R) i) 1 i' = ite (i = i') 1 0 :=\n  by\n  rw [LinearMap.stdBasis_apply, Function.update_apply, Pi.zero_apply]\n  congr 1; rw [eq_iff_iff, eq_comm]\n#align std_basis_apply' std_basis_apply'\n\n",
 "std_basis_apply":
 "/-\nCopyright (c) 2017 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl\n-/\ntheorem std_basis_apply (i : ι) (b : φ i) : stdBasis R φ i b = update 0 i b :=\n  rfl\n#align std_basis_apply std_basis_apply\n\n",
 "proj_std_basis_same":
 "theorem proj_std_basis_same (i : ι) : (proj i).comp (stdBasis R φ i) = id :=\n  LinearMap.ext <| stdBasis_same R φ i\n#align proj_std_basis_same proj_std_basis_same\n\n",
 "proj_std_basis_ne":
 "theorem proj_std_basis_ne (i j : ι) (h : i ≠ j) : (proj i).comp (stdBasis R φ j) = 0 :=\n  LinearMap.ext <| stdBasis_ne R φ _ _ h\n#align proj_std_basis_ne proj_std_basis_ne\n\n",
 "proj_comp_std_basis":
 "theorem proj_comp_std_basis (i j : ι) : (proj i).comp (stdBasis R φ j) = diag j i := by\n  rw [std_basis_eq_pi_diag, proj_pi]\n#align proj_comp_std_basis proj_comp_std_basis\n\n",
 "linear_independent_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem linear_independent_std_basis [Ring R] [∀ i, AddCommGroup (Ms i)] [∀ i, Module R (Ms i)] [DecidableEq η]\n    (v : ∀ j, ιs j → Ms j) (hs : ∀ i, LinearIndependent R (v i)) :\n    LinearIndependent R fun ji : Σj, ιs j => stdBasis R Ms ji.1 (v ji.1 ji.2) :=\n  by\n  have hs' : ∀ j : η, LinearIndependent R fun i : ιs j => std_basis R Ms j (v j i) :=\n    by\n    intro j\n    exact (hs j).map' _ (ker_std_basis _ _ _)\n  apply linearIndependent_unionᵢ_finite hs'\n  · intro j J _ hiJ\n    simp [(set.Union.equations._eqn_1 _).symm, Submodule.span_image, Submodule.span_unionᵢ]\n    have h₀ : ∀ j, span R (range fun i : ιs j => std_basis R Ms j (v j i)) ≤ range (std_basis R Ms j) :=\n      by\n      intro j\n      rw [span_le, LinearMap.range_coe]\n      apply range_comp_subset_range\n    have h₁ :\n      span R (range fun i : ιs j => std_basis R Ms j (v j i)) ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (range (std_basis R Ms i)) :=\n      by\n      rw [@supᵢ_singleton _ _ _ fun i => LinearMap.range (std_basis R (fun j : η => Ms j) i)]\n      apply h₀\n    have h₂ :\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (span R (range fun i : ιs j => std_basis R Ms j (v j i))) ≤\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (range (std_basis R (fun j : η => Ms j) j)) :=\n      supᵢ₂_mono fun i _ => h₀ i\n    have h₃ : Disjoint (fun i : η => i ∈ {j}) J := by convert Set.disjoint_singleton_left.2 hiJ using 0\n    exact (disjoint_std_basis_std_basis _ _ _ _ h₃).mono h₁ h₂\n#align linear_independent_std_basis linear_independent_std_basis\n\n",
 "ker_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_std_basis (i : ι) : ker (stdBasis R φ i) = «expr⊥» :=\n  ker_eq_bot_of_injective <| Pi.single_injective _ _\n#align ker_std_basis ker_std_basis\n\n",
 "infi_ker_proj_le_supr_range_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem infi_ker_proj_le_supr_range_std_basis {I : Finset ι} {J : Set ι} (hu : Set.univ ⊆ ↑I ∪ J) :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (ker (proj i : «expr →ₗ[ ] » (∀ i, φ i) R (φ i))) ≤\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (range (stdBasis R φ i)) :=\n  SetLike.le_def.2\n    (by\n      intro b hb\n      simp only [mem_infi, mem_ker, proj_apply] at hb\n      rw [←\n        show\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" I\n              (std_basis R φ i (b i)) =\n            b\n          by\n          ext i\n          rw [Finset.sum_apply, ← std_basis_same R φ i (b i)]\n          refine' Finset.sum_eq_single i (fun j hjI ne => std_basis_ne _ _ _ _ ne.symm _) _\n          intro hiI\n          rw [std_basis_same]\n          exact hb _ ((hu trivial).resolve_left hiI)]\n      exact sum_mem_bsupr fun i hi => mem_range_self (std_basis R φ i) (b i))\n#align infi_ker_proj_le_supr_range_std_basis infi_ker_proj_le_supr_range_std_basis\n\n",
 "disjoint_std_basis_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem disjoint_std_basis_std_basis (I J : Set ι) (h : Disjoint I J) :\n    Disjoint\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (range (stdBasis R φ i)))\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (range (stdBasis R φ i))) :=\n  by\n  refine'\n    Disjoint.mono (supr_range_std_basis_le_infi_ker_proj _ _ _ _ <| disjoint_compl_right)\n      (supr_range_std_basis_le_infi_ker_proj _ _ _ _ <| disjoint_compl_right) _\n  simp only [disjoint_iff_inf_le, SetLike.le_def, mem_infi, mem_inf, mem_ker, mem_bot, proj_apply, funext_iff]\n  rintro b ⟨hI, hJ⟩ i\n  classical\n    by_cases hiI : i ∈ I\n    · by_cases hiJ : i ∈ J\n      · exact (h.le_bot ⟨hiI, hiJ⟩).elim\n      · exact hJ i hiJ\n    · exact hI i hiI\n#align disjoint_std_basis_std_basis disjoint_std_basis_std_basis\n\n",
 "coe_std_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_std_basis (i : ι) : «expr⇑ » (stdBasis R φ i) = Pi.single i :=\n  rfl\n#align coe_std_basis coe_std_basis\n\n",
 "basis_repr_std_basis":
 "-- The `add_comm_monoid (Π j, Ms j)` instance was hard to find.\n-- Defining this in tactic mode seems to shake up instance search enough that it works by itself.\n@[simp]\ntheorem basis_repr_std_basis [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (j i) :\n    (Pi.basis s).repr (stdBasis R _ j (s j i)) = Finsupp.single ⟨j, i⟩ 1 :=\n  by\n  ext ⟨j', i'⟩\n  by_cases hj : j = j'\n  · subst hj\n    simp only [Pi.basis, LinearEquiv.trans_apply, Basis.repr_self, std_basis_same, LinearEquiv.piCongrRight,\n      Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply]\n    symm\n    exact Finsupp.single_apply_left (fun i i' (h : (⟨j, i⟩ : Σj, ιs j) = ⟨j, i'⟩) => eq_of_heq (sigma.mk.inj h).2) _ _ _\n  simp only [Pi.basis, LinearEquiv.trans_apply, Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply,\n    LinearEquiv.piCongrRight]\n  dsimp\n  rw [std_basis_ne _ _ _ _ (ne.symm hj), LinearEquiv.map_zero, Finsupp.zero_apply, Finsupp.single_eq_of_ne]\n  rintro ⟨⟩\n  contradiction\n#align basis_repr_std_basis basis_repr_std_basis\n\n",
 "basis_repr":
 "@[simp]\ntheorem basis_repr (s : ∀ j, Basis (ιs j) R (Ms j)) (x) (ji) : (Pi.basis s).repr x ji = (s ji.1).repr (x ji.1) ji.2 :=\n  rfl\n#align basis_repr basis_repr\n\n",
 "basis_fun_repr":
 "@[simp]\ntheorem basis_fun_repr (x : η → R) (i : η) : (Pi.basisFun R η).repr x i = x i := by simp [basis_fun]\n#align basis_fun_repr basis_fun_repr\n\n",
 "basis_fun_apply":
 "@[simp]\ntheorem basis_fun_apply [DecidableEq η] (i) : basisFun R η i = stdBasis R (fun i : η => R) i 1 := by\n  simp only [basis_fun, Basis.coe_ofEquivFun, LinearEquiv.refl_symm, LinearEquiv.refl_apply, std_basis_apply]\n#align basis_fun_apply basis_fun_apply\n\n",
 "basis_apply":
 "@[simp]\ntheorem basis_apply [DecidableEq η] (s : ∀ j, Basis (ιs j) R (Ms j)) (ji) :\n    Pi.basis s ji = stdBasis R _ ji.1 (s ji.1 ji.2) :=\n  Basis.apply_eq_iff.mpr (by simp)\n#align basis_apply basis_apply\n\n"}