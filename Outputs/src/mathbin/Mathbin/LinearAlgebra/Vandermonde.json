{"vandermonde_transpose_mul_vandermonde":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem vandermonde_transpose_mul_vandermonde {n : ℕ} (v : Fin n → R) (i j) :\n    (matrix.mul (matrix.transpose (vandermonde v)) (vandermonde v)) i j =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (v k ^ (i + j : ℕ)) :=\n  by simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, pow_add]\n#align vandermonde_transpose_mul_vandermonde vandermonde_transpose_mul_vandermonde\n\n",
 "vandermonde_succ":
 "theorem vandermonde_succ {n : ℕ} (v : Fin n.succ → R) :\n    vandermonde v =\n      Fin.cons (fun j => v 0 ^ (j : ℕ)) fun i => Fin.cons 1 fun j => v i.succ * vandermonde (Fin.tail v) i j :=\n  by\n  conv_lhs => rw [← Fin.cons_self_tail v, vandermonde_cons]\n  simp only [Fin.tail]\n#align vandermonde_succ vandermonde_succ\n\n",
 "vandermonde_mul_vandermonde_transpose":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem vandermonde_mul_vandermonde_transpose {n : ℕ} (v w : Fin n → R) (i j) :\n    (matrix.mul (vandermonde v) (matrix.transpose (vandermonde w))) i j =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        ((v i * w j) ^ (k : ℕ)) :=\n  by simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, mul_pow]\n#align vandermonde_mul_vandermonde_transpose vandermonde_mul_vandermonde_transpose\n\n",
 "vandermonde_cons":
 "@[simp]\ntheorem vandermonde_cons {n : ℕ} (v0 : R) (v : Fin n → R) :\n    vandermonde (Fin.cons v0 v : Fin n.succ → R) =\n      Fin.cons (fun j => v0 ^ (j : ℕ)) fun i => Fin.cons 1 fun j => v i * vandermonde v i j :=\n  by\n  ext (i j)\n  refine' Fin.cases (by simp) (fun i => _) i\n  refine' Fin.cases (by simp) (fun j => _) j\n  simp [pow_succ]\n#align vandermonde_cons vandermonde_cons\n\n",
 "vandermonde_apply":
 "/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n@[simp]\ntheorem vandermonde_apply {n : ℕ} (v : Fin n → R) (i j) : vandermonde v i j = v i ^ (j : ℕ) :=\n  rfl\n#align vandermonde_apply vandermonde_apply\n\n",
 "eq_zero_of_forall_pow_sum_mul_pow_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem eq_zero_of_forall_pow_sum_mul_pow_eq_zero {R : Type _} [CommRing R] [IsDomain R] {n : ℕ} {f v : Fin n → R}\n    (hf : function.injective f)\n    (hfv :\n      ∀ i : Fin n,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (v j * f j ^ (i : ℕ)) =\n          0) :\n    v = 0 :=\n  eq_zero_of_vecMul_eq_zero (det_vandermonde_ne_zero_iff.mpr hf) (funext hfv)\n#align eq_zero_of_forall_pow_sum_mul_pow_eq_zero eq_zero_of_forall_pow_sum_mul_pow_eq_zero\n\n",
 "eq_zero_of_forall_index_sum_pow_mul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem eq_zero_of_forall_index_sum_pow_mul_eq_zero {R : Type _} [CommRing R] [IsDomain R] {n : ℕ} {f v : Fin n → R}\n    (hf : function.injective f)\n    (hfv :\n      ∀ j,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (f j ^ (i : ℕ) * v i) =\n          0) :\n    v = 0 :=\n  eq_zero_of_mulVec_eq_zero (det_vandermonde_ne_zero_iff.mpr hf) (funext hfv)\n#align eq_zero_of_forall_index_sum_pow_mul_eq_zero eq_zero_of_forall_index_sum_pow_mul_eq_zero\n\n",
 "eq_zero_of_forall_index_sum_mul_pow_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem eq_zero_of_forall_index_sum_mul_pow_eq_zero {R : Type _} [CommRing R] [IsDomain R] {n : ℕ} {f v : Fin n → R}\n    (hf : function.injective f)\n    (hfv :\n      ∀ j,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (v i * f j ^ (i : ℕ)) =\n          0) :\n    v = 0 := by\n  apply eq_zero_of_forall_index_sum_pow_mul_eq_zero hf\n  simp_rw [mul_comm]\n  exact hfv\n#align eq_zero_of_forall_index_sum_mul_pow_eq_zero eq_zero_of_forall_index_sum_mul_pow_eq_zero\n\n",
 "det_vandermonde_ne_zero_iff":
 "theorem det_vandermonde_ne_zero_iff [IsDomain R] {n : ℕ} {v : Fin n → R} :\n    det (vandermonde v) ≠ 0 ↔ function.injective v := by\n  simpa only [det_vandermonde_eq_zero_iff, ne.def, not_exists, not_and, Classical.not_not]\n#align det_vandermonde_ne_zero_iff det_vandermonde_ne_zero_iff\n\n",
 "det_vandermonde_eq_zero_iff":
 "theorem det_vandermonde_eq_zero_iff [IsDomain R] {n : ℕ} {v : Fin n → R} :\n    det (vandermonde v) = 0 ↔ ∃ i j : Fin n, v i = v j ∧ i ≠ j :=\n  by\n  constructor\n  · simp only [det_vandermonde v, Finset.prod_eq_zero_iff, sub_eq_zero, forall_exists_index]\n    exact fun i _ j h₁ h₂ => ⟨j, i, h₂, (mem_Ioi.mp h₁).ne'⟩\n  · simp only [ne.def, forall_exists_index, and_imp]\n    refine' fun i j h₁ h₂ => Matrix.det_zero_of_row_eq h₂ (funext fun k => _)\n    rw [vandermonde_apply, vandermonde_apply, h₁]\n#align det_vandermonde_eq_zero_iff det_vandermonde_eq_zero_iff\n\n",
 "det_vandermonde":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem det_vandermonde {n : ℕ} (v : Fin n → R) :\n    det (vandermonde v) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ioi i)\n          (v j - v i)) :=\n  by\n  unfold vandermonde\n  induction' n with n ih\n  · exact det_eq_one_of_card_eq_zero (Fintype.card_fin 0)\n  calc\n    det (of fun i j : Fin n.succ => v i ^ (j : ℕ)) =\n        det\n          (of fun i j : Fin n.succ =>\n            Matrix.vecCons (v 0 ^ (j : ℕ)) (fun i => v (fin.succ i) ^ (j : ℕ) - v 0 ^ (j : ℕ)) i) :=\n      det_eq_of_forall_row_eq_smul_add_const (Matrix.vecCons 0 1) 0 (Fin.cons_zero _ _) _\n    _ =\n        det\n          (of fun i j : Fin n =>\n            Matrix.vecCons (v 0 ^ (j.succ : ℕ)) (fun i : Fin n => v (fin.succ i) ^ (j.succ : ℕ) - v 0 ^ (j.succ : ℕ))\n              (Fin.succAbove 0 i)) :=\n      by\n      simp_rw [det_succ_column_zero, Fin.sum_univ_succ, of_apply, Matrix.cons_val_zero, submatrix, of_apply,\n        Matrix.cons_val_succ, Fin.val_zero, pow_zero, one_mul, sub_self, MulZeroClass.mul_zero, MulZeroClass.zero_mul,\n        Finset.sum_const_zero, add_zero]\n    _ =\n        det\n          (of fun i j : Fin n =>\n              (v (fin.succ i) - v 0) *\n                finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                  (Finset.range (j + 1 : ℕ)) (v i.succ ^ k * v 0 ^ (j - k : ℕ)) :\n            Matrix _ _ R) :=\n      by\n      congr\n      ext (i j)\n      rw [Fin.succAbove_zero, Matrix.cons_val_succ, Fin.val_succ, mul_comm]\n      exact (geom_sum₂_mul (v i.succ) (v 0) (j + 1 : ℕ)).symm\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (v (fin.succ i) - v 0) *\n          det fun i j : Fin n =>\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (Finset.range (j + 1 : ℕ)) (v i.succ ^ k * v 0 ^ (j - k : ℕ)) :=\n      (det_mul_column (fun i => v (fin.succ i) - v 0) _)\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n            (v (fin.succ i) - v 0) *\n          det fun i j : Fin n => v (fin.succ i) ^ (j : ℕ) :=\n      (congr_arg ((· * ·) _) _)\n    _ =\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ioi i)\n            (v j - v i)) :=\n      by simp_rw [ih (v ∘ fin.succ), Fin.prod_univ_succ, Fin.prod_Ioi_zero, Fin.prod_Ioi_succ]\n    \n  · intro i j\n    simp_rw [of_apply]\n    rw [Matrix.cons_val_zero]\n    refine' Fin.cases _ (fun i => _) i\n    · simp\n    rw [Matrix.cons_val_succ, Matrix.cons_val_succ, Pi.one_apply]\n    ring\n  · cases n\n    · simp only [det_eq_one_of_card_eq_zero (Fintype.card_fin 0)]\n    apply det_eq_of_forall_col_eq_smul_add_pred fun i => v 0\n    · intro j\n      simp\n    · intro i j\n      simp only [smul_eq_mul, Pi.add_apply, Fin.val_succ, Fin.coe_castSucc, Pi.smul_apply]\n      rw [Finset.sum_range_succ, add_comm, tsub_self, pow_zero, mul_one, Finset.mul_sum]\n      congr 1\n      refine' Finset.sum_congr rfl fun i' hi' => _\n      rw [mul_left_comm (v 0), nat.succ_sub, pow_succ]\n      exact nat.lt_succ_iff.mp (finset.mem_range.mp hi')\n#align det_vandermonde det_vandermonde\n\n"}