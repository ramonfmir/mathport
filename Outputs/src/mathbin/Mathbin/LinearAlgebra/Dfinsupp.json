{"supr_eq_range_dfinsupp_lsum":
 "/-- The supremum of a family of submodules is equal to the range of `dfinsupp.lsum`; that is\nevery element in the `supr` can be produced from taking a finite number of non-zero elements\nof `p i`, coercing them to `N`, and summing them. -/\ntheorem supr_eq_range_dfinsupp_lsum (p : ι → submodule R N) : supᵢ p = (dfinsupp.lsum ℕ fun i => (p i).subtype).range :=\n  by\n  apply le_antisymm\n  · apply supᵢ_le _\n    intro i y hy\n    exact ⟨dfinsupp.single i ⟨y, hy⟩, dfinsupp.sum_add_hom_single _ _ _⟩\n  · rintro x ⟨v, rfl⟩\n    exact dfinsupp_sum_add_hom_mem _ v _ fun i _ => (le_supᵢ p i : p i ≤ _) (v i).prop\n#align supr_eq_range_dfinsupp_lsum supr_eq_range_dfinsupp_lsum\n\n",
 "mem_supr_iff_exists_dfinsupp'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/-- A variant of `submodule.mem_supr_iff_exists_dfinsupp` with the RHS fully unfolded. -/\ntheorem mem_supr_iff_exists_dfinsupp' (p : ι → submodule R N) [∀ (i) (x : p i), decidable (x ≠ 0)] (x : N) :\n    x ∈ supᵢ p ↔\n      ∃ f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (p i),\n        (f.sum fun i xi => ↑xi) = x :=\n  by\n  rw [mem_supr_iff_exists_dfinsupp]\n  simp_rw [dfinsupp.lsum_apply_apply, dfinsupp.sum_add_hom_apply]\n  congr\n#align mem_supr_iff_exists_dfinsupp' mem_supr_iff_exists_dfinsupp'\n\n",
 "mem_supr_iff_exists_dfinsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem mem_supr_iff_exists_dfinsupp (p : ι → submodule R N) (x : N) :\n    x ∈ supᵢ p ↔\n      ∃ f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (p i),\n        dfinsupp.lsum ℕ (fun i => (p i).subtype) f = x :=\n  SetLike.ext_iff.mp (supr_eq_range_dfinsupp_lsum p) x\n#align mem_supr_iff_exists_dfinsupp mem_supr_iff_exists_dfinsupp\n\n",
 "mem_supr_finset_iff_exists_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mem_supr_finset_iff_exists_sum {s : Finset ι} (p : ι → submodule R N) (a : N) :\n    a ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (p i) ↔\n      ∃ μ : ∀ i, p i,\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s (μ i : N) =\n          a :=\n  by\n  classical\n    rw [submodule.mem_supr_iff_exists_dfinsupp']\n    constructor <;> rintro ⟨μ, hμ⟩\n    · use fun i => ⟨μ i, (supᵢ_const_le : _ ≤ p i) (coe_mem <| μ i)⟩\n      rw [← hμ]\n      symm\n      apply finset.sum_subset\n      · intro x\n        contrapose\n        intro hx\n        rw [mem_support_iff, not_ne_iff]\n        ext\n        rw [coe_zero, ← mem_bot R]\n        convert coe_mem (μ x)\n        symm\n        exact supᵢ_neg hx\n      · intro x _ hx\n        rw [mem_support_iff, not_ne_iff] at hx\n        rw [hx]\n        rfl\n    · refine' ⟨dfinsupp.mk s _, _⟩\n      · rintro ⟨i, hi⟩\n        refine' ⟨μ i, _⟩\n        rw [supᵢ_pos]\n        · exact coe_mem _\n        · exact hi\n      simp only [dfinsupp.sum]\n      rw [finset.sum_subset support_mk_subset, ← hμ]\n      exact finset.sum_congr rfl fun x hx => congr_arg coe <| mk_of_mem hx\n      · intro x _ hx\n        rw [mem_support_iff, not_ne_iff] at hx\n        rw [hx]\n        rfl\n#align mem_supr_finset_iff_exists_sum mem_supr_finset_iff_exists_sum\n\n",
 "mem_bsupr_iff_exists_dfinsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem mem_bsupr_iff_exists_dfinsupp (p : ι → Prop) [decidable_pred p] (S : ι → submodule R N) (x : N) :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (S i),\n        dfinsupp.lsum ℕ (fun i => (S i).subtype) (f.filter p) = x :=\n  SetLike.ext_iff.mp (bsupr_eq_range_dfinsupp_lsum p S) x\n#align mem_bsupr_iff_exists_dfinsupp mem_bsupr_iff_exists_dfinsupp\n\n",
 "map_range_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_range_smul (f : ∀ i, β₁ i → β₂ i) (hf : ∀ i, f i 0 = 0) (r : R)\n    (hf' : ∀ i x, f i («expr • » r x) = «expr • » r (f i x))\n    (g : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (β₁ i)) :\n    map_range f hf («expr • » r g) = «expr • » r (map_range f hf g) :=\n  by\n  ext\n  simp only [map_range_apply f, coe_smul, pi.smul_apply, hf']\n#align map_range_smul map_range_smul\n\n",
 "lsum_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- While `simp` can prove this, it is often convenient to avoid unfolding `lsum` into `sum_add_hom`\nwith `dfinsupp.lsum_apply_apply`. -/\ntheorem lsum_single [Semiring S] [Module S N] [SMulCommClass R S N] (F : ∀ i, «expr →ₗ[ ] » (M i) R N) (i) (x : M i) :\n    lsum S F (single i x) = F i x :=\n  sum_add_hom_single _ _ _\n#align lsum_single lsum_single\n\n",
 "lsum_comp_map_range_to_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-- Combining `dfinsupp.lsum` with `linear_map.to_span_singleton` is the same as `finsupp.total` -/\ntheorem lsum_comp_map_range_to_span_singleton [∀ m : R, decidable (m ≠ 0)] (p : ι → submodule R N) {v : ι → N}\n    (hv : ∀ i : ι, v i ∈ p i) :\n    ((lsum ℕ) fun i => (p i).subtype : «expr →ₗ[ ] » _ R _).comp\n        ((map_range.linear_map fun i => linear_map.to_span_singleton R («expr↥ » (p i)) ⟨v i, hv i⟩ :\n              «expr →ₗ[ ] » _ R _).comp\n          (finsupp_lequiv_dfinsupp R : «expr ≃ₗ[ ] » («expr →₀ » ι R) R _).to_linear_map) =\n      finsupp.total ι N R v :=\n  by\n  ext\n  simp\n#align lsum_comp_map_range_to_span_singleton lsum_comp_map_range_to_span_singleton\n\n",
 "lsingle_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lsingle_apply (i : ι) (x : M i) : (lsingle i : «expr →ₗ[ ] » _ R _) x = single i x :=\n  rfl\n#align lsingle_apply lsingle_apply\n\n",
 "lmk_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n@[simp]\ntheorem lmk_apply (s : Finset ι) (x) :\n    (lmk s :\n          «expr →ₗ[ ] » _ R\n            («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M i)))\n        x =\n      mk s x :=\n  rfl\n#align lmk_apply lmk_apply\n\n",
 "linear_map_id":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem map_range.linear_map_id :\n    (map_range.linear_map fun i => (linear_map.id : «expr →ₗ[ ] » (β₂ i) R _)) = linear_map.id :=\n  linear_map.ext map_range_id\n#align map_range.linear_map_id map_range.linear_map_id\n\n",
 "linear_map_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem map_range.linear_map_comp (f : ∀ i, «expr →ₗ[ ] » (β₁ i) R (β₂ i)) (f₂ : ∀ i, «expr →ₗ[ ] » (β i) R (β₁ i)) :\n    (map_range.linear_map fun i => (f i).comp (f₂ i)) = (map_range.linear_map f).comp (map_range.linear_map f₂) :=\n  linear_map.ext <| map_range_comp (fun i x => f i x) (fun i x => f₂ i x) _ _ _\n#align map_range.linear_map_comp map_range.linear_map_comp\n\n",
 "linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem sum_map_range_index.linear_map [∀ (i : ι) (x : β₁ i), decidable (x ≠ 0)]\n    [∀ (i : ι) (x : β₂ i), decidable (x ≠ 0)] {f : ∀ i, «expr →ₗ[ ] » (β₁ i) R (β₂ i)}\n    {h : ∀ i, «expr →ₗ[ ] » (β₂ i) R N}\n    {l : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (β₁ i)} :\n    dfinsupp.lsum ℕ h (map_range.linear_map f l) = dfinsupp.lsum ℕ (fun i => (h i).comp (f i)) l := by\n  simpa [dfinsupp.sum_add_hom_apply] using\n    @sum_map_range_index ι N _ _ _ _ _ _ _ _ (fun i => f i) (fun i => by simp) l (fun i => h i) fun i => by simp\n#align sum_map_range_index.linear_map sum_map_range_index.linear_map\n\n",
 "linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a family of submodules is `independent`, then a choice of nonzero vector from each submodule\nforms a linearly independent family.\n\nSee also `complete_lattice.independent.linear_independent'`. -/\ntheorem independent.linear_independent [NoZeroSMulDivisors R N] (p : ι → submodule R N) (hp : independent p) {v : ι → N}\n    (hv : ∀ i, v i ∈ p i) (hv' : ∀ i, v i ≠ 0) : linear_independent R v := by\n  classical\n    rw [linear_independent_iff]\n    intro l hl\n    let a := dfinsupp.map_range.linear_map (fun i => linear_map.to_span_singleton R (p i) ⟨v i, hv i⟩) l.to_dfinsupp\n    have ha : a = 0 := by\n      apply hp.dfinsupp_lsum_injective\n      rwa [← lsum_comp_map_range_to_span_singleton _ hv] at hl\n    ext i\n    apply smul_left_injective R (hv' i)\n    have : «expr • » (l i) (v i) = a i := rfl\n    simp [this, ha]\n#align independent.linear_independent independent.linear_independent\n\n",
 "linear_equiv_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem map_range.linear_equiv_trans (f : ∀ i, «expr ≃ₗ[ ] » (β i) R (β₁ i)) (f₂ : ∀ i, «expr ≃ₗ[ ] » (β₁ i) R (β₂ i)) :\n    (map_range.linear_equiv fun i => (f i).trans (f₂ i)) =\n      (map_range.linear_equiv f).trans (map_range.linear_equiv f₂) :=\n  linear_equiv.ext <| map_range_comp (fun i x => f₂ i x) (fun i x => f i x) _ _ _\n#align map_range.linear_equiv_trans map_range.linear_equiv_trans\n\n",
 "linear_equiv_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem map_range.linear_equiv_symm (e : ∀ i, «expr ≃ₗ[ ] » (β₁ i) R (β₂ i)) :\n    (map_range.linear_equiv e).symm = map_range.linear_equiv fun i => (e i).symm :=\n  rfl\n#align map_range.linear_equiv_symm map_range.linear_equiv_symm\n\n",
 "linear_equiv_refl":
 "@[simp]\ntheorem map_range.linear_equiv_refl :\n    (map_range.linear_equiv fun i => linear_equiv.refl R (β₁ i)) = linear_equiv.refl _ _ :=\n  linear_equiv.ext map_range_id\n#align map_range.linear_equiv_refl map_range.linear_equiv_refl\n\n",
 "lhom_ext'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/-- Two `R`-linear maps from `Π₀ i, M i` which agree on each `single i x` agree everywhere.\n\nSee note [partially-applied ext lemmas].\nAfter apply this lemma, if `M = R` then it suffices to verify `φ (single a 1) = ψ (single a 1)`. -/\n@[ext]\ntheorem lhom_ext'\n    ⦃φ ψ :\n      «expr →ₗ[ ] »\n        («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M i)) R N⦄\n    (h : ∀ i, φ.comp (lsingle i) = ψ.comp (lsingle i)) : φ = ψ :=\n  lhom_ext fun i => linear_map.congr_fun (h i)\n#align lhom_ext' lhom_ext'\n\n",
 "lhom_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/-\nCopyright (c) 2018 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Kenny Lau\n-/\n/-- Two `R`-linear maps from `Π₀ i, M i` which agree on each `single i x` agree everywhere. -/\ntheorem lhom_ext\n    ⦃φ ψ :\n      «expr →ₗ[ ] »\n        («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M i)) R N⦄\n    (h : ∀ i x, φ (single i x) = ψ (single i x)) : φ = ψ :=\n  linear_map.to_add_monoid_hom_injective <| add_hom_ext h\n#align lhom_ext lhom_ext\n\n",
 "lapply_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lapply_apply (i : ι)\n    (f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M i)) :\n    (lapply i : «expr →ₗ[ ] » _ R _) f = f i :=\n  rfl\n#align lapply_apply lapply_apply\n\n",
 "independent_of_dfinsupp_sum_add_hom_injective'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- If `dfinsupp.sum_add_hom` applied with `add_submonoid.subtype` is injective then the additive\nsubgroups are independent. -/\ntheorem independent_of_dfinsupp_sum_add_hom_injective' (p : ι → add_subgroup N)\n    (h : function.injective (sum_add_hom fun i => (p i).subtype)) : independent p :=\n  by\n  rw [← independent_map_order_iso_iff (add_subgroup.to_int_submodule : «expr ≃o » (add_subgroup N) _)]\n  exact independent_of_dfinsupp_lsum_injective _ h\n#align independent_of_dfinsupp_sum_add_hom_injective' independent_of_dfinsupp_sum_add_hom_injective'\n\n",
 "independent_of_dfinsupp_sum_add_hom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/- If `dfinsupp.sum_add_hom` applied with `add_submonoid.subtype` is injective then the additive\nsubmonoids are independent. -/\ntheorem independent_of_dfinsupp_sum_add_hom_injective (p : ι → AddSubmonoid N)\n    (h : function.injective (sum_add_hom fun i => (p i).subtype)) : independent p :=\n  by\n  rw [← independent_map_order_iso_iff (add_submonoid.to_nat_submodule : «expr ≃o » (AddSubmonoid N) _)]\n  exact independent_of_dfinsupp_lsum_injective _ h\n#align independent_of_dfinsupp_sum_add_hom_injective independent_of_dfinsupp_sum_add_hom_injective\n\n",
 "independent_of_dfinsupp_lsum_injective":
 "/- If `dfinsupp.lsum` applied with `submodule.subtype` is injective then the submodules are\nindependent. -/\ntheorem independent_of_dfinsupp_lsum_injective (p : ι → submodule R N)\n    (h : function.injective (lsum ℕ fun i => (p i).subtype)) : independent p :=\n  by\n  rw [independent_iff_forall_dfinsupp]\n  intro i x v hv\n  replace hv : lsum ℕ (fun i => (p i).subtype) (erase i v) = lsum ℕ (fun i => (p i).subtype) (single i x)\n  · simpa only [lsum_single] using hv\n  have := dfinsupp.ext_iff.mp (h hv) i\n  simpa [eq_comm] using this\n#align independent_of_dfinsupp_lsum_injective independent_of_dfinsupp_lsum_injective\n\n",
 "independent_iff_linear_independent_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\ntheorem independent_iff_linear_independent_of_ne_zero [NoZeroSMulDivisors R N] {v : ι → N} (h_ne_zero : ∀ i, v i ≠ 0) :\n    (independent fun i => «expr ∙ » R (v i)) ↔ linear_independent R v :=\n  ⟨fun hv => hv.linear_independent _ (fun i => submodule.mem_span_singleton_self <| v i) h_ne_zero, fun hv =>\n    hv.independent_span_singleton⟩\n#align independent_iff_linear_independent_of_ne_zero independent_iff_linear_independent_of_ne_zero\n\n",
 "independent_iff_forall_dfinsupp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/-- Independence of a family of submodules can be expressed as a quantifier over `dfinsupp`s.\n\nThis is an intermediate result used to prove\n`complete_lattice.independent_of_dfinsupp_lsum_injective` and\n`complete_lattice.independent.dfinsupp_lsum_injective`. -/\ntheorem independent_iff_forall_dfinsupp (p : ι → submodule R N) :\n    independent p ↔\n      ∀ (i) (x : p i)\n        (v :\n          «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\"\n            («expr↥ » (p i))),\n        lsum ℕ (fun i => (p i).subtype) (erase i v) = x → x = 0 :=\n  by\n  simp_rw [complete_lattice.independent_def, submodule.disjoint_def, submodule.mem_bsupr_iff_exists_dfinsupp,\n    exists_imp, filter_ne_eq_erase]\n  apply forall_congr' fun i => _\n  refine' subtype.forall'.trans _\n  simp_rw [submodule.coe_eq_zero]\n  rfl\n#align independent_iff_forall_dfinsupp independent_iff_forall_dfinsupp\n\n",
 "independent_iff_dfinsupp_sum_add_hom_injective":
 "/-- A family of additive subgroups over an additive group are independent if and only if\n`dfinsupp.sum_add_hom` applied with `add_subgroup.subtype` is injective. -/\ntheorem independent_iff_dfinsupp_sum_add_hom_injective (p : ι → add_subgroup N) :\n    independent p ↔ function.injective (sum_add_hom fun i => (p i).subtype) :=\n  ⟨independent.dfinsupp_sum_add_hom_injective, independent_of_dfinsupp_sum_add_hom_injective' p⟩\n#align independent_iff_dfinsupp_sum_add_hom_injective independent_iff_dfinsupp_sum_add_hom_injective\n\n",
 "independent_iff_dfinsupp_lsum_injective":
 "/-- A family of submodules over an additive group are independent if and only iff `dfinsupp.lsum`\napplied with `submodule.subtype` is injective.\n\nNote that this is not generally true for `[semiring R]`; see\n`complete_lattice.independent.dfinsupp_lsum_injective` for details. -/\ntheorem independent_iff_dfinsupp_lsum_injective (p : ι → submodule R N) :\n    independent p ↔ function.injective (lsum ℕ fun i => (p i).subtype) :=\n  ⟨independent.dfinsupp_lsum_injective, independent_of_dfinsupp_lsum_injective p⟩\n#align independent_iff_dfinsupp_lsum_injective independent_iff_dfinsupp_lsum_injective\n\n",
 "dfinsupp_sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem dfinsupp_sum_mem {β : ι → Type _} [∀ i, Zero (β i)] [∀ (i) (x : β i), decidable (x ≠ 0)] (S : submodule R N)\n    (f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (β i))\n    (g : ∀ i, β i → N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) : f.sum g ∈ S :=\n  dfinsupp_sum_mem S f g h\n#align dfinsupp_sum_mem dfinsupp_sum_mem\n\n",
 "dfinsupp_sum_add_hom_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+ » -/\ntheorem dfinsupp_sum_add_hom_mem {β : ι → Type _} [∀ i, add_zero_class (β i)] (S : submodule R N)\n    (f : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (β i))\n    (g : ∀ i, «expr →+ » (β i) N) (h : ∀ c, f c ≠ 0 → g c (f c) ∈ S) : dfinsupp.sum_add_hom g f ∈ S :=\n  dfinsupp_sum_add_hom_mem S f g h\n#align dfinsupp_sum_add_hom_mem dfinsupp_sum_add_hom_mem\n\n",
 "dfinsupp_sum_add_hom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃o » -/\n/-- The canonical map out of a direct sum of a family of additive subgroups is injective when the\nadditive subgroups are `complete_lattice.independent`. -/\ntheorem independent.dfinsupp_sum_add_hom_injective {p : ι → add_subgroup N} (h : independent p) :\n    function.injective (sum_add_hom fun i => (p i).subtype) :=\n  by\n  rw [← independent_map_order_iso_iff (add_subgroup.to_int_submodule : «expr ≃o » (add_subgroup N) _)] at h\n  exact h.dfinsupp_lsum_injective\n#align independent.dfinsupp_sum_add_hom_injective independent.dfinsupp_sum_add_hom_injective\n\n",
 "dfinsupp_lsum_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\n/-- The canonical map out of a direct sum of a family of submodules is injective when the submodules\nare `complete_lattice.independent`.\n\nNote that this is not generally true for `[semiring R]`, for instance when `A` is the\n`ℕ`-submodules of the positive and negative integers.\n\nSee `counterexamples/direct_sum_is_internal.lean` for a proof of this fact. -/\ntheorem independent.dfinsupp_lsum_injective {p : ι → submodule R N} (h : independent p) :\n    function.injective (lsum ℕ fun i => (p i).subtype) :=\n  by\n  -- simplify everything down to binders over equalities in `N`\n  rw [independent_iff_forall_dfinsupp] at h\n  suffices (lsum ℕ fun i => (p i).subtype).ker = «expr⊥»\n    by\n    -- Lean can't find this without our help\n    letI :\n      add_comm_group\n        («exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (p i)) :=\n      @dfinsupp.add_comm_group _ (fun i => p i) _\n    rw [linear_map.ker_eq_bot] at this\n    exact this\n  rw [linear_map.ker_eq_bot']\n  intro m hm\n  ext i : 1\n  -- split `m` into the piece at `i` and the pieces elsewhere, to match `h`\n  rw [dfinsupp.zero_apply, ← neg_eq_zero]\n  refine' h i (-m i) m _\n  rwa [← erase_add_single i m, linear_map.map_add, lsum_single, submodule.subtype_apply, add_eq_zero_iff_eq_neg, ←\n    submodule.coe_neg] at hm\n#align independent.dfinsupp_lsum_injective independent.dfinsupp_lsum_injective\n\n",
 "coprod_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprΠ₀ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , » -/\ntheorem coprod_map_apply (f : ∀ i : ι, «expr →ₗ[ ] » (M i) R N)\n    (x : «exprΠ₀ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«exprΠ₀ , »\" (M i)) :\n    coprod_map f x = finsupp.sum (map_range (fun i => f i) (fun i => linear_map.map_zero _) x).to_finsupp fun i => id :=\n  rfl\n#align coprod_map_apply coprod_map_apply\n\n",
 "bsupr_eq_range_dfinsupp_lsum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The bounded supremum of a family of commutative additive submonoids is equal to the range of\n`dfinsupp.sum_add_hom` composed with `dfinsupp.filter_add_monoid_hom`; that is, every element in the\nbounded `supr` can be produced from taking a finite number of non-zero elements from the `S i` that\nsatisfy `p i`, coercing them to `γ`, and summing them. -/\ntheorem bsupr_eq_range_dfinsupp_lsum (p : ι → Prop) [decidable_pred p] (S : ι → submodule R N) :\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) =\n      ((dfinsupp.lsum ℕ fun i => (S i).subtype).comp (dfinsupp.filter_linear_map R _ p)).range :=\n  by\n  apply le_antisymm\n  · refine' supᵢ₂_le fun i hi y hy => ⟨dfinsupp.single i ⟨y, hy⟩, _⟩\n    rw [linear_map.comp_apply, filter_linear_map_apply, filter_single_pos _ _ hi]\n    exact dfinsupp.sum_add_hom_single _ _ _\n  · rintro x ⟨v, rfl⟩\n    refine' dfinsupp_sum_add_hom_mem _ _ _ fun i hi => _\n    refine' mem_supr_of_mem i _\n    by_cases hp : p i\n    · simp [hp]\n    · simp [hp]\n#align bsupr_eq_range_dfinsupp_lsum bsupr_eq_range_dfinsupp_lsum\n\n"}