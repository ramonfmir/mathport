{"to_matrix_vec_mul_coords":
 "/-- A change of basis formula for barycentric coordinates.\n\nSee also `affine_basis.to_matrix_inv_mul_affine_basis_to_matrix`. -/\n@[simp]\ntheorem to_matrix_vec_mul_coords (x : P) : (b.to_matrix b₂.points).vec_mul (b₂.coords x) = b.coords x :=\n  by\n  ext j\n  change _ = b.coord j x\n  conv_rhs => rw [← b₂.affine_combination_coord_eq_self x]\n  rw [finset.map_affine_combination _ _ _ (b₂.sum_coord_apply_eq_one x)]\n  simp [matrix.vec_mul, matrix.dot_product, to_matrix_apply, coords]\n#align to_matrix_vec_mul_coords to_matrix_vec_mul_coords\n\n",
 "to_matrix_self":
 "@[simp]\ntheorem to_matrix_self [decidable_eq ι] : b.to_matrix b.points = (1 : matrix ι ι k) :=\n  by\n  ext (i j)\n  rw [to_matrix_apply, coord_apply, matrix.one_eq_pi_single, Pi.single_apply]\n#align to_matrix_self to_matrix_self\n\n",
 "to_matrix_row_sum_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem to_matrix_row_sum_one {ι' : Type _} (q : ι' → P) (i : ι') :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.to_matrix q i j) =\n      1 :=\n  by simp\n#align to_matrix_row_sum_one to_matrix_row_sum_one\n\n",
 "to_matrix_mul_to_matrix":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\ntheorem to_matrix_mul_to_matrix : matrix.mul (b.to_matrix b₂.points) (b₂.to_matrix b.points) = 1 :=\n  by\n  ext (l m)\n  change (b₂.to_matrix b.points).vec_mul (b.coords (b₂.points l)) m = _\n  rw [to_matrix_vec_mul_coords, coords_apply, ← to_matrix_apply, to_matrix_self]\n#align to_matrix_mul_to_matrix to_matrix_mul_to_matrix\n\n",
 "to_matrix_inv_vec_mul_to_matrix":
 "/-- A change of basis formula for barycentric coordinates.\n\nSee also `affine_basis.to_matrix_vec_mul_coords`. -/\n@[simp]\ntheorem to_matrix_inv_vec_mul_to_matrix (x : P) : (b.to_matrix b₂.points)⁻¹.vec_mul (b.coords x) = b₂.coords x :=\n  by\n  have hu := b.is_unit_to_matrix b₂\n  rw [matrix.is_unit_iff_is_unit_det] at hu\n  rw [← b.to_matrix_vec_mul_coords b₂, matrix.vec_mul_vec_mul, matrix.mul_nonsing_inv _ hu, matrix.vec_mul_one]\n#align to_matrix_inv_vec_mul_to_matrix to_matrix_inv_vec_mul_to_matrix\n\n",
 "to_matrix_apply":
 "/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\n@[simp]\ntheorem to_matrix_apply {ι' : Type _} (q : ι' → P) (i : ι') (j : ι) : b.to_matrix q i j = b.coord j (q i) :=\n  rfl\n#align to_matrix_apply to_matrix_apply\n\n",
 "is_unit_to_matrix_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_unit_to_matrix_iff [nontrivial k] (p : ι → P) :\n    is_unit (b.to_matrix p) ↔ affine_independent k p ∧ affine_span k (range p) = «expr⊤» :=\n  by\n  constructor\n  · rintro ⟨⟨B, A, hA, hA'⟩, rfl : B = b.to_matrix p⟩\n    rw [matrix.mul_eq_mul] at hA hA'\n    exact ⟨b.affine_independent_of_to_matrix_right_inv p hA, b.affine_span_eq_top_of_to_matrix_left_inv p hA'⟩\n  · rintro ⟨h_tot, h_ind⟩\n    let b' : affine_basis ι k P := ⟨p, h_tot, h_ind⟩\n    change is_unit (b.to_matrix b'.points)\n    exact b.is_unit_to_matrix b'\n#align is_unit_to_matrix_iff is_unit_to_matrix_iff\n\n",
 "is_unit_to_matrix":
 "theorem is_unit_to_matrix : is_unit (b.to_matrix b₂.points) :=\n  ⟨{  val := b.to_matrix b₂.points\n      inv := b₂.to_matrix b.points\n      val_inv := b.to_matrix_mul_to_matrix b₂\n      inv_val := b₂.to_matrix_mul_to_matrix b }, rfl⟩\n#align is_unit_to_matrix is_unit_to_matrix\n\n",
 "det_smul_coords_eq_cramer_coords":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.transpose -/\n/-- If we fix a background affine basis `b`, then for any other basis `b₂`, we can characterise\nthe barycentric coordinates provided by `b₂` in terms of determinants relative to `b`. -/\ntheorem det_smul_coords_eq_cramer_coords (x : P) :\n    «expr • » (b.to_matrix b₂.points).det (b₂.coords x) =\n      (matrix.transpose (b.to_matrix b₂.points)).cramer (b.coords x) :=\n  by\n  have hu := b.is_unit_to_matrix b₂\n  rw [matrix.is_unit_iff_is_unit_det] at hu\n  rw [← b.to_matrix_inv_vec_mul_to_matrix, matrix.det_smul_inv_vec_mul_eq_cramer_transpose _ _ hu]\n#align det_smul_coords_eq_cramer_coords det_smul_coords_eq_cramer_coords\n\n",
 "affine_span_eq_top_of_to_matrix_left_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Given a family of points `p : ι' → P` and an affine basis `b`, if the matrix whose rows are the\ncoordinates of `p` with respect `b` has a left inverse, then `p` spans the entire space. -/\ntheorem affine_span_eq_top_of_to_matrix_left_inv [decidable_eq ι] [nontrivial k] (p : ι' → P) {A : matrix ι ι' k}\n    (hA : matrix.mul A (b.to_matrix p) = 1) : affine_span k (range p) = «expr⊤» :=\n  by\n  suffices ∀ i, b.points i ∈ affine_span k (range p)\n    by\n    rw [eq_top_iff, ← b.tot, affine_span_le]\n    rintro q ⟨i, rfl⟩\n    exact this i\n  intro i\n  have hAi :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (A i j) =\n      1 :=\n    by\n    calc\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (A i j) =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (A i j *\n              finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n                (b.to_matrix p j l)) :=\n        by simp\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              (A i j * b.to_matrix p j l)) :=\n        by simp_rw [finset.mul_sum]\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              (A i j * b.to_matrix p j l)) :=\n        by rw [finset.sum_comm]\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            ((matrix.mul A (b.to_matrix p)) i l) :=\n        rfl\n      _ = 1 := by simp [hA, matrix.one_apply, Finset.filter_eq]\n      \n  have hbi : b.points i = finset.univ.affine_combination p (A i) :=\n    by\n    apply b.ext_elem\n    intro j\n    rw [b.coord_apply, finset.univ.map_affine_combination _ _ hAi,\n      finset.univ.affine_combination_eq_linear_combination _ _ hAi]\n    change _ = (matrix.mul A (b.to_matrix p)) i j\n    simp_rw [hA, matrix.one_apply, @eq_comm _ i j]\n  rw [hbi]\n  exact affine_combination_mem_affine_span hAi p\n#align affine_span_eq_top_of_to_matrix_left_inv affine_span_eq_top_of_to_matrix_left_inv\n\n",
 "affine_independent_of_to_matrix_right_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `matrix.mul -/\n/-- Given a family of points `p : ι' → P` and an affine basis `b`, if the matrix whose rows are the\ncoordinates of `p` with respect `b` has a right inverse, then `p` is affine independent. -/\ntheorem affine_independent_of_to_matrix_right_inv [decidable_eq ι'] (p : ι' → P) {A : matrix ι ι' k}\n    (hA : matrix.mul (b.to_matrix p) A = 1) : affine_independent k p :=\n  by\n  rw [affine_independent_iff_eq_of_fintype_affine_combination_eq]\n  intro w₁ w₂ hw₁ hw₂ hweq\n  have hweq' : (b.to_matrix p).vec_mul w₁ = (b.to_matrix p).vec_mul w₂ :=\n    by\n    ext j\n    change\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (w₁ i) (b.coord j (p i))) =\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » (w₂ i) (b.coord j (p i)))\n    rw [← finset.univ.affine_combination_eq_linear_combination _ _ hw₁, ←\n      finset.univ.affine_combination_eq_linear_combination _ _ hw₂, ← finset.univ.map_affine_combination p w₁ hw₁, ←\n      finset.univ.map_affine_combination p w₂ hw₂, hweq]\n  replace hweq' := congr_arg (fun w => A.vec_mul w) hweq'\n  simpa only [matrix.vec_mul_vec_mul, ← matrix.mul_eq_mul, hA, matrix.vec_mul_one] using hweq'\n#align affine_independent_of_to_matrix_right_inv affine_independent_of_to_matrix_right_inv\n\n"}