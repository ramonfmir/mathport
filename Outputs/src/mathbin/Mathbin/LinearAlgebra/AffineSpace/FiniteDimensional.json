{"vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one":
 "#print AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one /-\n/-- If the `vector_span` of a finite subset of an affinely independent\nfamily lies in a submodule with dimension one less than its\ncardinality, it equals that submodule. -/\ntheorem AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one {p : ι → P}\n    (hi : AffineIndependent k p) {s : Finset ι} {sm : Submodule k V} [FiniteDimensional k sm]\n    (hle : vectorSpan k (s.image p : Set P) ≤ sm) (hc : Finset.card s = finrank k sm + 1) :\n    vectorSpan k (s.image p : Set P) = sm :=\n  eq_of_le_of_finrank_eq hle <| hi.finrank_vector_span_image_finset hc\n#align affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one\n-/\n\n",
 "vectorSpan_eq_top_of_card_eq_finrank_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one /-\n/-- The `vector_span` of a finite affinely independent family whose\ncardinality is one more than that of the finite-dimensional space is\n`⊤`. -/\ntheorem AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one [FiniteDimensional k V] [Fintype ι] {p : ι → P}\n    (hi : AffineIndependent k p) (hc : Fintype.card ι = finrank k V + 1) : vectorSpan k (Set.range p) = «expr⊤» :=\n  eq_top_of_finrank_eq <| hi.finrank_vector_span hc\n#align affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one\n-/\n\n",
 "vectorSpan_eq_of_le_of_card_eq_finrank_add_one":
 "#print AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one /-\n/-- If the `vector_span` of a finite affinely independent\nfamily lies in a submodule with dimension one less than its\ncardinality, it equals that submodule. -/\ntheorem AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype ι] {p : ι → P}\n    (hi : AffineIndependent k p) {sm : Submodule k V} [FiniteDimensional k sm] (hle : vectorSpan k (Set.range p) ≤ sm)\n    (hc : Fintype.card ι = finrank k sm + 1) : vectorSpan k (Set.range p) = sm :=\n  eq_of_le_of_finrank_eq hle <| hi.finrank_vector_span hc\n#align affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one\n-/\n\n",
 "subset":
 "#print Coplanar.subset /-\n/-- A subset of a coplanar set is coplanar. -/\ntheorem Coplanar.subset {s₁ s₂ : Set P} (hs : s₁ ⊆ s₂) (h : Coplanar k s₂) : Coplanar k s₁ :=\n  (rank_le_of_submodule (vectorSpan k s₁) (vectorSpan k s₂) (vectorSpan_mono k hs)).trans h\n#align coplanar.subset Coplanar.subset\n-/\n\n",
 "span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Affine.Simplex.span_eq_top /-\ntheorem Affine.Simplex.span_eq_top [FiniteDimensional k V] {n : ℕ} (T : Affine.Simplex k V n)\n    (hrank : finrank k V = n) : affineSpan k (Set.range T.points) = «expr⊤» := by\n  rw [AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one T.independent, Fintype.card_fin, hrank]\n#align affine.simplex.span_eq_top Affine.Simplex.span_eq_top\n-/\n\n",
 "ne₂₃_of_not_collinear":
 "#print ne₂₃_of_not_collinear /-\n/-- If three points are not collinear, the second and third are different. -/\ntheorem ne₂₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) : p₂ ≠ p₃ :=\n  by\n  rintro rfl\n  simpa [collinear_pair] using h\n#align ne₂₃_of_not_collinear ne₂₃_of_not_collinear\n-/\n\n",
 "ne₁₃_of_not_collinear":
 "#print ne₁₃_of_not_collinear /-\n/-- If three points are not collinear, the first and third are different. -/\ntheorem ne₁₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) : p₁ ≠ p₃ :=\n  by\n  rintro rfl\n  simpa [collinear_pair] using h\n#align ne₁₃_of_not_collinear ne₁₃_of_not_collinear\n-/\n\n",
 "ne₁₂_of_not_collinear":
 "#print ne₁₂_of_not_collinear /-\n/-- If three points are not collinear, the first and second are different. -/\ntheorem ne₁₂_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) : p₁ ≠ p₂ :=\n  by\n  rintro rfl\n  simpa [collinear_pair] using h\n#align ne₁₂_of_not_collinear ne₁₂_of_not_collinear\n-/\n\n",
 "mem_affineSpan_of_mem_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print Collinear.mem_affineSpan_of_mem_of_ne /-\n/-- A point in a collinear set of points lies in the affine span of any two distinct points of\nthat set. -/\ntheorem Collinear.mem_affineSpan_of_mem_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ p₃ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) (hp₁p₂ : p₁ ≠ p₂) : p₃ ∈ «exprline[ , , ]» k p₁ p₂ :=\n  by\n  rw [collinear_iff_of_mem hp₁] at h\n  rcases h with ⟨v, h⟩\n  rcases h p₂ hp₂ with ⟨r₂, rfl⟩\n  rcases h p₃ hp₃ with ⟨r₃, rfl⟩\n  rw [vadd_left_mem_affineSpan_pair]\n  refine' ⟨r₃ / r₂, _⟩\n  have h₂ : r₂ ≠ 0 := by\n    rintro rfl\n    simpa using hp₁p₂\n  simp [smul_smul, h₂]\n#align collinear.mem_affine_span_of_mem_of_ne Collinear.mem_affineSpan_of_mem_of_ne\n-/\n\n",
 "finrank_vectorSpan_range_le":
 "#print finrank_vectorSpan_range_le /-\n/-- The `vector_span` of an indexed family of `n + 1` points has\ndimension at most `n`. -/\ntheorem finrank_vectorSpan_range_le [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) :\n    finrank k (vectorSpan k (Set.range p)) ≤ n :=\n  by\n  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]\n  rw [← Finset.card_univ] at hc\n  exact finrank_vectorSpan_image_finset_le _ _ _ hc\n#align finrank_vector_span_range_le finrank_vectorSpan_range_le\n-/\n\n",
 "finrank_vectorSpan_le_iff_not_affineIndependent":
 "#print finrank_vectorSpan_le_iff_not_affineIndependent /-\n/-- `n + 2` points have a `vector_span` with dimension at most `n` if\nand only if they are not affinely independent. -/\ntheorem finrank_vectorSpan_le_iff_not_affineIndependent [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 2) :\n    finrank k (vectorSpan k (Set.range p)) ≤ n ↔ ¬AffineIndependent k p :=\n  (not_iff_comm.1 (affineIndependent_iff_not_finrank_vectorSpan_le k p hc).symm).symm\n#align finrank_vector_span_le_iff_not_affine_independent finrank_vectorSpan_le_iff_not_affineIndependent\n-/\n\n",
 "finrank_vectorSpan_insert_le_set":
 "#print finrank_vectorSpan_insert_le_set /-\n/-- Adding a point to a set with a finite-dimensional span increases the dimension by at most\none. -/\ntheorem finrank_vectorSpan_insert_le_set (s : Set P) (p : P) :\n    finrank k (vectorSpan k (insert p s)) ≤ finrank k (vectorSpan k s) + 1 :=\n  by\n  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan, direction_affineSpan]\n  refine' (finrank_vectorSpan_insert_le _ _).trans (add_le_add_right _ _)\n  rw [direction_affineSpan]\n#align finrank_vector_span_insert_le_set finrank_vectorSpan_insert_le_set\n-/\n\n",
 "finrank_vectorSpan_insert_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print finrank_vectorSpan_insert_le /-\n/-- Adding a point to a finite-dimensional subspace increases the dimension by at most one. -/\ntheorem finrank_vectorSpan_insert_le (s : AffineSubspace k P) (p : P) :\n    finrank k (vectorSpan k (insert p (s : Set P))) ≤ finrank k s.direction + 1 :=\n  by\n  by_cases hf : FiniteDimensional k s.direction; swap\n  · have hf' : ¬FiniteDimensional k (vectorSpan k (insert p (s : Set P))) :=\n      by\n      intro h\n      have h' : s.direction ≤ vectorSpan k (insert p (s : Set P)) :=\n        by\n        conv_lhs => rw [← affine_span_coe s, direction_affineSpan]\n        exact vectorSpan_mono k (Set.subset_insert _ _)\n      exact hf (Submodule.finiteDimensional_of_le h')\n    rw [finrank_of_infinite_dimensional hf, finrank_of_infinite_dimensional hf', zero_add]\n    exact zero_le_one\n  haveI := hf\n  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]\n  rcases(s : Set P).eq_empty_or_nonempty with (hs | ⟨p₀, hp₀⟩)\n  · rw [coe_eq_bot_iff] at hs\n    rw [hs, bot_coe, span_empty, bot_coe, direction_affineSpan, direction_bot, finrank_bot, zero_add]\n    convert zero_le_one' ℕ\n    rw [← finrank_bot k V]\n    convert rfl <;> simp\n  · rw [affine_span_coe, direction_affine_span_insert hp₀, add_comm]\n    refine' (Submodule.finrank_add_le_finrank_add_finrank _ _).trans (add_le_add_right _ _)\n    refine' finrank_le_one ⟨«expr -ᵥ » p p₀, Submodule.mem_span_singleton_self _⟩ fun v => _\n    have h := v.property\n    rw [Submodule.mem_span_singleton] at h\n    rcases h with ⟨c, hc⟩\n    refine' ⟨c, _⟩\n    ext\n    exact hc\n#align finrank_vector_span_insert_le finrank_vectorSpan_insert_le\n-/\n\n",
 "finrank_vectorSpan_image_finset_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print finrank_vectorSpan_image_finset_le /-\n/-- The `vector_span` of `n + 1` points in an indexed family has\ndimension at most `n`. -/\ntheorem finrank_vectorSpan_image_finset_le (p : ι → P) (s : Finset ι) {n : ℕ} (hc : Finset.card s = n + 1) :\n    finrank k (vectorSpan k (s.image p : Set P)) ≤ n :=\n  by\n  have hn : (s.image p).nonempty :=\n    by\n    rw [Finset.Nonempty.image_iff, ← Finset.card_pos, hc]\n    apply nat.succ_pos\n  rcases hn with ⟨p₁, hp₁⟩\n  rw [vectorSpan_eq_span_vsub_finset_right_ne k hp₁]\n  refine' le_trans (finrank_span_finset_le_card (((s.image p).erase p₁).image fun p => «expr -ᵥ » p p₁)) _\n  rw [Finset.card_image_of_injective _ (vsub_left_injective p₁), Finset.card_erase_of_mem hp₁, tsub_le_iff_right, ← hc]\n  apply Finset.card_image_le\n#align finrank_vector_span_image_finset_le finrank_vectorSpan_image_finset_le\n-/\n\n",
 "finrank_vectorSpan_image_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print AffineIndependent.finrank_vectorSpan_image_finset /-\n/-- The `vector_span` of a finite subset of an affinely independent\nfamily has dimension one less than its cardinality. -/\ntheorem AffineIndependent.finrank_vectorSpan_image_finset {p : ι → P} (hi : AffineIndependent k p) {s : Finset ι}\n    {n : ℕ} (hc : Finset.card s = n + 1) : finrank k (vectorSpan k (s.image p : Set P)) = n :=\n  by\n  have hi' := hi.range.mono (Set.image_subset_range p ↑s)\n  have hc' : (s.image p).card = n + 1 := by rwa [s.card_image_of_injective hi.injective]\n  have hn : (s.image p).nonempty := by simp [hc', ← Finset.card_pos]\n  rcases hn with ⟨p₁, hp₁⟩\n  have hp₁' : p₁ ∈ «expr '' » p s := by simpa using hp₁\n  rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁', ← Finset.coe_singleton, ← Finset.coe_image, ←\n    Finset.coe_sdiff, Finset.sdiff_singleton_eq_erase, ← Finset.coe_image] at hi'\n  have hc : (Finset.image (fun p : P => «expr -ᵥ » p p₁) ((Finset.image p s).erase p₁)).card = n :=\n    by\n    rw [Finset.card_image_of_injective _ (vsub_left_injective _), Finset.card_erase_of_mem hp₁]\n    exact Nat.pred_eq_of_eq_succ hc'\n  rwa [vectorSpan_eq_span_vsub_finset_right_ne k hp₁, finrank_span_finset_eq_card, hc]\n#align affine_independent.finrank_vector_span_image_finset AffineIndependent.finrank_vectorSpan_image_finset\n-/\n\n",
 "finrank_vectorSpan":
 "#print AffineIndependent.finrank_vectorSpan /-\n/-- The `vector_span` of a finite affinely independent family has\ndimension one less than its cardinality. -/\ntheorem AffineIndependent.finrank_vectorSpan [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) {n : ℕ}\n    (hc : Fintype.card ι = n + 1) : finrank k (vectorSpan k (Set.range p)) = n :=\n  by\n  rw [← Finset.card_univ] at hc\n  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]\n  exact hi.finrank_vector_span_image_finset hc\n#align affine_independent.finrank_vector_span AffineIndependent.finrank_vectorSpan\n-/\n\n",
 "finite_set_of_fin_dim_affineIndependent":
 "#print finite_set_of_fin_dim_affineIndependent /-\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem finite_set_of_fin_dim_affineIndependent [FiniteDimensional k V] {s : Set ι} {f : s → P}\n    (hi : AffineIndependent k f) : s.finite :=\n  @Set.toFinite _ s (finite_of_fin_dim_affineIndependent k hi)\n#align finite_set_of_fin_dim_affine_independent finite_set_of_fin_dim_affineIndependent\n-/\n\n",
 "finite_set":
 "protected theorem finite_set [FiniteDimensional k V] {s : Set ι} (b : AffineBasis s k P) : s.finite :=\n  finite_set_of_fin_dim_affineIndependent k b.ind\n#align finite_set finite_set\n\n",
 "finite_of_fin_dim_affineIndependent":
 "#print finite_of_fin_dim_affineIndependent /-\n/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem finite_of_fin_dim_affineIndependent [FiniteDimensional k V] {p : ι → P} (hi : AffineIndependent k p) :\n    Finite ι := by\n  nontriviality ι; inhabit ι\n  rw [affineIndependent_iff_linearIndependent_vsub k p default] at hi\n  letI : IsNoetherian k V := IsNoetherian.iff_fg.2 inferInstance\n  exact (Set.finite_singleton default).finite_of_compl (Set.finite_coe_iff.1 hi.finite_of_is_noetherian)\n#align finite_of_fin_dim_affine_independent finite_of_fin_dim_affineIndependent\n-/\n\n",
 "finiteDimensional_vectorSpan_of_finite":
 "#print finiteDimensional_vectorSpan_of_finite /-\n/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n/-- The `vector_span` of a finite set is finite-dimensional. -/\ntheorem finiteDimensional_vectorSpan_of_finite {s : Set P} (h : Set.Finite s) : FiniteDimensional k (vectorSpan k s) :=\n  span_of_finite k <| h.vsub h\n#align finite_dimensional_vector_span_of_finite finiteDimensional_vectorSpan_of_finite\n-/\n\n",
 "finiteDimensional_vectorSpan":
 "#print Coplanar.finiteDimensional_vectorSpan /-\n/-- The `vector_span` of coplanar points is finite-dimensional. -/\ntheorem Coplanar.finiteDimensional_vectorSpan {s : Set P} (h : Coplanar k s) : FiniteDimensional k (vectorSpan k s) :=\n  by\n  refine' IsNoetherian.iff_fg.1 (IsNoetherian.iff_rank_lt_aleph0.2 (lt_of_le_of_lt h _))\n  simp\n#align coplanar.finite_dimensional_vector_span Coplanar.finiteDimensional_vectorSpan\n-/\n\n",
 "finiteDimensional_direction_affineSpan_of_finite":
 "#print finiteDimensional_direction_affineSpan_of_finite /-\n/-- The direction of the affine span of a finite set is\nfinite-dimensional. -/\ntheorem finiteDimensional_direction_affineSpan_of_finite {s : Set P} (h : Set.Finite s) :\n    FiniteDimensional k (affineSpan k s).direction :=\n  (direction_affineSpan k s).symm ▸ finiteDimensional_vectorSpan_of_finite k h\n#align finite_dimensional_direction_affine_span_of_finite finiteDimensional_direction_affineSpan_of_finite\n-/\n\n",
 "finiteDimensional_direction_affineSpan":
 "#print Coplanar.finiteDimensional_direction_affineSpan /-\n/-- The direction of the affine span of coplanar points is finite-dimensional. -/\ntheorem Coplanar.finiteDimensional_direction_affineSpan {s : Set P} (h : Coplanar k s) :\n    FiniteDimensional k (affineSpan k s).direction :=\n  (direction_affineSpan k s).symm ▸ h.finite_dimensional_vector_span\n#align coplanar.finite_dimensional_direction_affine_span Coplanar.finiteDimensional_direction_affineSpan\n-/\n\n",
 "exists_affine_basis_of_finite_dimensional":
 "theorem exists_affine_basis_of_finite_dimensional [Fintype ι] [FiniteDimensional k V]\n    (h : Fintype.card ι = FiniteDimensional.finrank k V + 1) : Nonempty (AffineBasis ι k P) :=\n  by\n  obtain ⟨s, b, hb⟩ := AffineBasis.exists_affineBasis k V P\n  lift s to Finset P using b.finite_set\n  refine' ⟨b.reindex <| Fintype.equivOfCardEq _⟩\n  rw [h, ← b.card_eq_finrank_add_one]\n#align exists_affine_basis_of_finite_dimensional exists_affine_basis_of_finite_dimensional\n\n",
 "coplanar_triple":
 "#print coplanar_triple /-\n/-- Three points are coplanar. -/\ntheorem coplanar_triple (p₁ p₂ p₃ : P) : Coplanar k ({p₁, p₂, p₃} : Set P) :=\n  (collinear_pair k p₂ p₃).coplanar_insert p₁\n#align coplanar_triple coplanar_triple\n-/\n\n",
 "coplanar_singleton":
 "#print coplanar_singleton /-\n/-- A single point is coplanar. -/\ntheorem coplanar_singleton (p : P) : Coplanar k ({p} : Set P) :=\n  (collinear_singleton k p).coplanar\n#align coplanar_singleton coplanar_singleton\n-/\n\n",
 "coplanar_pair":
 "#print coplanar_pair /-\n/-- Two points are coplanar. -/\ntheorem coplanar_pair (p₁ p₂ : P) : Coplanar k ({p₁, p₂} : Set P) :=\n  (collinear_pair k p₁ p₂).coplanar\n#align coplanar_pair coplanar_pair\n-/\n\n",
 "coplanar_of_finrank_eq_two":
 "#print coplanar_of_finrank_eq_two /-\n/-- A set of points in a two-dimensional space is coplanar. -/\ntheorem coplanar_of_finrank_eq_two (s : Set P) (h : finrank k V = 2) : Coplanar k s :=\n  by\n  haveI := finite_dimensional_of_finrank_eq_succ h\n  rw [coplanar_iff_finrank_le_two, ← h]\n  exact Submodule.finrank_le _\n#align coplanar_of_finrank_eq_two coplanar_of_finrank_eq_two\n-/\n\n",
 "coplanar_of_fact_finrank_eq_two":
 "#print coplanar_of_fact_finrank_eq_two /-\n/-- A set of points in a two-dimensional space is coplanar. -/\ntheorem coplanar_of_fact_finrank_eq_two (s : Set P) [h : Fact (finrank k V = 2)] : Coplanar k s :=\n  coplanar_of_finrank_eq_two s h.out\n#align coplanar_of_fact_finrank_eq_two coplanar_of_fact_finrank_eq_two\n-/\n\n",
 "coplanar_insert_iff_of_mem_affineSpan":
 "#print coplanar_insert_iff_of_mem_affineSpan /-\n/-- Adding a point in the affine span of a set does not change whether that set is coplanar. -/\ntheorem coplanar_insert_iff_of_mem_affineSpan {s : Set P} {p : P} (h : p ∈ affineSpan k s) :\n    Coplanar k (insert p s) ↔ Coplanar k s := by rw [Coplanar, Coplanar, vectorSpan_insert_eq_vectorSpan h]\n#align coplanar_insert_iff_of_mem_affine_span coplanar_insert_iff_of_mem_affineSpan\n-/\n\n",
 "coplanar_insert":
 "#print Collinear.coplanar_insert /-\n/-- Adding a point to a collinear set produces a coplanar set. -/\ntheorem Collinear.coplanar_insert {s : Set P} (h : Collinear k s) (p : P) : Coplanar k (insert p s) :=\n  by\n  haveI := h.finite_dimensional_vector_span\n  rw [coplanar_iff_finrank_le_two]\n  exact (finrank_vectorSpan_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)\n#align collinear.coplanar_insert Collinear.coplanar_insert\n-/\n\n",
 "coplanar_iff_finrank_le_two":
 "#print coplanar_iff_finrank_le_two /-\n/-- A set of points, whose `vector_span` is finite-dimensional, is coplanar if and only if their\n`vector_span` has dimension at most `2`. -/\ntheorem coplanar_iff_finrank_le_two {s : Set P} [FiniteDimensional k (vectorSpan k s)] :\n    Coplanar k s ↔ finrank k (vectorSpan k s) ≤ 2 :=\n  by\n  have h : Coplanar k s ↔ Module.rank k (vectorSpan k s) ≤ 2 := iff.rfl\n  rw [← finrank_eq_rank] at h\n  exact_mod_cast h\n#align coplanar_iff_finrank_le_two coplanar_iff_finrank_le_two\n-/\n\n",
 "coplanar_empty":
 "#print coplanar_empty /-\n/-- The empty set is coplanar. -/\ntheorem coplanar_empty : Coplanar k (∅ : Set P) :=\n  (collinear_empty k P).coplanar\n#align coplanar_empty coplanar_empty\n-/\n\n",
 "coplanar":
 "#print Collinear.coplanar /-\n/-- Collinear points are coplanar. -/\ntheorem Collinear.coplanar {s : Set P} (h : Collinear k s) : Coplanar k s :=\n  le_trans h one_le_two\n#align collinear.coplanar Collinear.coplanar\n-/\n\n",
 "collinear_triple_of_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print collinear_triple_of_mem_affineSpan_pair /-\n/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem collinear_triple_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P} (h₁ : p₁ ∈ «exprline[ , , ]» k p₄ p₅)\n    (h₂ : p₂ ∈ «exprline[ , , ]» k p₄ p₅) (h₃ : p₃ ∈ «exprline[ , , ]» k p₄ p₅) : Collinear k ({p₁, p₂, p₃} : Set P) :=\n  by\n  refine' (collinear_insert_insert_insert_left_of_mem_affineSpan_pair h₁ h₂ h₃).subset _\n  simp [Set.insert_subset_insert]\n#align collinear_triple_of_mem_affine_span_pair collinear_triple_of_mem_affineSpan_pair\n-/\n\n",
 "collinear_singleton":
 "#print collinear_singleton /-\n/-- A single point is collinear. -/\ntheorem collinear_singleton (p : P) : Collinear k ({p} : Set P) :=\n  by\n  rw [collinear_iff_rank_le_one, vectorSpan_singleton]\n  simp\n#align collinear_singleton collinear_singleton\n-/\n\n",
 "collinear_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print collinear_pair /-\n/-- Two points are collinear. -/\ntheorem collinear_pair (p₁ p₂ : P) : Collinear k ({p₁, p₂} : Set P) :=\n  by\n  rw [collinear_iff_exists_forall_eq_smul_vadd]\n  use p₁, «expr -ᵥ » p₂ p₁\n  intro p hp\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp\n  cases hp\n  · use 0\n    simp [hp]\n  · use 1\n    simp [hp]\n#align collinear_pair collinear_pair\n-/\n\n",
 "collinear_insert_of_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print collinear_insert_of_mem_affineSpan_pair /-\n/-- If a point lies in the affine span of two points, those three points are collinear. -/\ntheorem collinear_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ : P} (h : p₁ ∈ «exprline[ , , ]» k p₂ p₃) :\n    Collinear k ({p₁, p₂, p₃} : Set P) :=\n  by\n  rw [collinear_insert_iff_of_mem_affineSpan h]\n  exact collinear_pair _ _ _\n#align collinear_insert_of_mem_affine_span_pair collinear_insert_of_mem_affineSpan_pair\n-/\n\n",
 "collinear_insert_insert_of_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print collinear_insert_insert_of_mem_affineSpan_pair /-\n/-- If two points lie in the affine span of two points, those four points are collinear. -/\ntheorem collinear_insert_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ : P} (h₁ : p₁ ∈ «exprline[ , , ]» k p₃ p₄)\n    (h₂ : p₂ ∈ «exprline[ , , ]» k p₃ p₄) : Collinear k ({p₁, p₂, p₃, p₄} : Set P) :=\n  by\n  rw [collinear_insert_iff_of_mem_affineSpan\n      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k (Set.subset_insert _ _)) _ h₁),\n    collinear_insert_iff_of_mem_affineSpan h₂]\n  exact collinear_pair _ _ _\n#align collinear_insert_insert_of_mem_affine_span_pair collinear_insert_insert_of_mem_affineSpan_pair\n-/\n\n",
 "collinear_insert_insert_insert_of_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print collinear_insert_insert_insert_of_mem_affineSpan_pair /-\n/-- If three points lie in the affine span of two points, those five points are collinear. -/\ntheorem collinear_insert_insert_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P} (h₁ : p₁ ∈ «exprline[ , , ]» k p₄ p₅)\n    (h₂ : p₂ ∈ «exprline[ , , ]» k p₄ p₅) (h₃ : p₃ ∈ «exprline[ , , ]» k p₄ p₅) :\n    Collinear k ({p₁, p₂, p₃, p₄, p₅} : Set P) :=\n  by\n  rw [collinear_insert_iff_of_mem_affineSpan\n      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k ((Set.subset_insert _ _).trans (Set.subset_insert _ _))) _ h₁),\n    collinear_insert_iff_of_mem_affineSpan\n      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k (Set.subset_insert _ _)) _ h₂),\n    collinear_insert_iff_of_mem_affineSpan h₃]\n  exact collinear_pair _ _ _\n#align collinear_insert_insert_insert_of_mem_affine_span_pair collinear_insert_insert_insert_of_mem_affineSpan_pair\n-/\n\n",
 "collinear_insert_insert_insert_left_of_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print collinear_insert_insert_insert_left_of_mem_affineSpan_pair /-\n/-- If three points lie in the affine span of two points, the first four points are collinear. -/\ntheorem collinear_insert_insert_insert_left_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P}\n    (h₁ : p₁ ∈ «exprline[ , , ]» k p₄ p₅) (h₂ : p₂ ∈ «exprline[ , , ]» k p₄ p₅) (h₃ : p₃ ∈ «exprline[ , , ]» k p₄ p₅) :\n    Collinear k ({p₁, p₂, p₃, p₄} : Set P) :=\n  by\n  refine' (collinear_insert_insert_insert_of_mem_affineSpan_pair h₁ h₂ h₃).subset _\n  simp [Set.insert_subset_insert]\n#align collinear_insert_insert_insert_left_of_mem_affine_span_pair collinear_insert_insert_insert_left_of_mem_affineSpan_pair\n-/\n\n",
 "collinear_insert_iff_of_ne":
 "#print Collinear.collinear_insert_iff_of_ne /-\n/-- Given a collinear set of points, and two distinct points `p₂` and `p₃` in it, a point `p₁` is\ncollinear with the set if and only if it is collinear with `p₂` and `p₃`. -/\ntheorem Collinear.collinear_insert_iff_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ p₃ : P} (hp₂ : p₂ ∈ s)\n    (hp₃ : p₃ ∈ s) (hp₂p₃ : p₂ ≠ p₃) : Collinear k (insert p₁ s) ↔ Collinear k ({p₁, p₂, p₃} : Set P) :=\n  by\n  have hv : vectorSpan k (insert p₁ s) = vectorSpan k ({p₁, p₂, p₃} : Set P) :=\n    by\n    conv_lhs => rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]\n    conv_rhs => rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]\n    rw [h.affine_span_eq_of_ne hp₂ hp₃ hp₂p₃]\n  rw [Collinear, Collinear, hv]\n#align collinear.collinear_insert_iff_of_ne Collinear.collinear_insert_iff_of_ne\n-/\n\n",
 "collinear_insert_iff_of_mem_affineSpan":
 "#print collinear_insert_iff_of_mem_affineSpan /-\n/-- Adding a point in the affine span of a set does not change whether that set is collinear. -/\ntheorem collinear_insert_iff_of_mem_affineSpan {s : Set P} {p : P} (h : p ∈ affineSpan k s) :\n    Collinear k (insert p s) ↔ Collinear k s := by rw [Collinear, Collinear, vectorSpan_insert_eq_vectorSpan h]\n#align collinear_insert_iff_of_mem_affine_span collinear_insert_iff_of_mem_affineSpan\n-/\n\n",
 "collinear_iff_rank_le_one":
 "#print collinear_iff_rank_le_one /-\n/-- The definition of `collinear`. -/\ntheorem collinear_iff_rank_le_one (s : Set P) : Collinear k s ↔ Module.rank k (vectorSpan k s) ≤ 1 :=\n  iff.rfl\n#align collinear_iff_rank_le_one collinear_iff_rank_le_one\n-/\n\n",
 "collinear_iff_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print collinear_iff_of_mem /-\n/-- Given a point `p₀` in a set of points, that set is collinear if and\nonly if the points can all be expressed as multiples of the same\nvector, added to `p₀`. -/\ntheorem collinear_iff_of_mem {s : Set P} {p₀ : P} (h : p₀ ∈ s) :\n    Collinear k s ↔ ∃ v : V, ∀ p ∈ s, ∃ r : k, p = «expr +ᵥ » («expr • » r v) p₀ :=\n  by\n  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]\n  constructor\n  · rintro ⟨v₀, hv⟩\n    use v₀\n    intro p hp\n    obtain ⟨r, hr⟩ := hv («expr -ᵥ » p p₀) (vsub_mem_vectorSpan k hp h)\n    use r\n    rw [eq_vadd_iff_vsub_eq]\n    exact hr.symm\n  · rintro ⟨v, hp₀v⟩\n    use v\n    intro w hw\n    have hs : vectorSpan k s ≤ «expr ∙ » k v :=\n      by\n      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]\n      intro x hx\n      rw [SetLike.mem_coe, Submodule.mem_span_singleton]\n      rw [Set.mem_image] at hx\n      rcases hx with ⟨p, hp, rfl⟩\n      rcases hp₀v p hp with ⟨r, rfl⟩\n      use r\n      simp\n    have hw' := SetLike.le_def.1 hs hw\n    rwa [Submodule.mem_span_singleton] at hw'\n#align collinear_iff_of_mem collinear_iff_of_mem\n-/\n\n",
 "collinear_iff_not_affineIndependent_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n#print collinear_iff_not_affineIndependent_set /-\n/-- Three points are collinear if and only if they are not affinely independent. -/\ntheorem collinear_iff_not_affineIndependent_set {p₁ p₂ p₃ : P} :\n    Collinear k ({p₁, p₂, p₃} : Set P) ↔\n      ¬AffineIndependent k\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  affineIndependent_iff_not_collinear_set.not_left.symm\n#align collinear_iff_not_affine_independent_set collinear_iff_not_affineIndependent_set\n-/\n\n",
 "collinear_iff_not_affineIndependent_of_ne":
 "#print collinear_iff_not_affineIndependent_of_ne /-\n/-- Three points are collinear if and only if they are not affinely independent. -/\ntheorem collinear_iff_not_affineIndependent_of_ne {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃)\n    (h₂₃ : i₂ ≠ i₃) : Collinear k ({p i₁, p i₂, p i₃} : Set P) ↔ ¬AffineIndependent k p :=\n  (affineIndependent_iff_not_collinear_of_ne h₁₂ h₁₃ h₂₃).not_left.symm\n#align collinear_iff_not_affine_independent_of_ne collinear_iff_not_affineIndependent_of_ne\n-/\n\n",
 "collinear_iff_not_affineIndependent":
 "#print collinear_iff_not_affineIndependent /-\n/-- Three points are collinear if and only if they are not affinely\nindependent. -/\ntheorem collinear_iff_not_affineIndependent {p : Fin 3 → P} : Collinear k (Set.range p) ↔ ¬AffineIndependent k p := by\n  rw [collinear_iff_finrank_le_one, finrank_vectorSpan_le_iff_not_affineIndependent k p (Fintype.card_fin 3)]\n#align collinear_iff_not_affine_independent collinear_iff_not_affineIndependent\n-/\n\n",
 "collinear_iff_finrank_le_one":
 "#print collinear_iff_finrank_le_one /-\n/-- A set of points, whose `vector_span` is finite-dimensional, is\ncollinear if and only if their `vector_span` has dimension at most\n`1`. -/\ntheorem collinear_iff_finrank_le_one {s : Set P} [FiniteDimensional k (vectorSpan k s)] :\n    Collinear k s ↔ finrank k (vectorSpan k s) ≤ 1 :=\n  by\n  have h := collinear_iff_rank_le_one k s\n  rw [← finrank_eq_rank] at h\n  exact_mod_cast h\n#align collinear_iff_finrank_le_one collinear_iff_finrank_le_one\n-/\n\n",
 "collinear_iff_exists_forall_eq_smul_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print collinear_iff_exists_forall_eq_smul_vadd /-\n/-- A set of points is collinear if and only if they can all be\nexpressed as multiples of the same vector, added to the same base\npoint. -/\ntheorem collinear_iff_exists_forall_eq_smul_vadd (s : Set P) :\n    Collinear k s ↔ ∃ (p₀ : P)(v : V), ∀ p ∈ s, ∃ r : k, p = «expr +ᵥ » («expr • » r v) p₀ :=\n  by\n  rcases Set.eq_empty_or_nonempty s with (rfl | ⟨⟨p₁, hp₁⟩⟩)\n  · simp [collinear_empty]\n  · rw [collinear_iff_of_mem hp₁]\n    constructor\n    · exact fun h => ⟨p₁, h⟩\n    · rintro ⟨p, v, hv⟩\n      use v\n      intro p₂ hp₂\n      rcases hv p₂ hp₂ with ⟨r, rfl⟩\n      rcases hv p₁ hp₁ with ⟨r₁, rfl⟩\n      use r - r₁\n      simp [vadd_vadd, ← add_smul]\n#align collinear_iff_exists_forall_eq_smul_vadd collinear_iff_exists_forall_eq_smul_vadd\n-/\n\n",
 "collinear_empty":
 "#print collinear_empty /-\n/-- The empty set is collinear. -/\ntheorem collinear_empty : Collinear k (∅ : Set P) :=\n  by\n  rw [collinear_iff_rank_le_one, vectorSpan_empty]\n  simp\n#align collinear_empty collinear_empty\n-/\n\n",
 "card_eq_finrank_add_one":
 "theorem card_eq_finrank_add_one [Fintype ι] (b : AffineBasis ι k P) :\n    Fintype.card ι = FiniteDimensional.finrank k V + 1 :=\n  haveI := b.finite_dimensional\n  b.ind.affine_span_eq_top_iff_card_eq_finrank_add_one.mp b.tot\n#align card_eq_finrank_add_one card_eq_finrank_add_one\n\n",
 "affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one":
 "#print AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one /-\n/-- If the `affine_span` of a finite subset of an affinely independent\nfamily lies in an affine subspace whose direction has dimension one\nless than its cardinality, it equals that subspace. -/\ntheorem AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one {p : ι → P}\n    (hi : AffineIndependent k p) {s : Finset ι} {sp : AffineSubspace k P} [FiniteDimensional k sp.direction]\n    (hle : affineSpan k (s.image p : Set P) ≤ sp) (hc : Finset.card s = finrank k sp.direction + 1) :\n    affineSpan k (s.image p : Set P) = sp :=\n  by\n  have hn : s.nonempty := by\n    rw [← Finset.card_pos, hc]\n    apply nat.succ_pos\n  refine' eq_of_direction_eq_of_nonempty_of_le _ ((hn.image _).to_set.affine_span _) hle\n  have hd := direction_le hle\n  rw [direction_affineSpan] at hd⊢\n  exact hi.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hd hc\n#align affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one\n-/\n\n",
 "affineSpan_eq_top_iff_card_eq_finrank_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one /-\n/-- The `affine_span` of a finite affinely independent family is `⊤` iff the\nfamily's cardinality is one more than that of the finite-dimensional space. -/\ntheorem AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one [FiniteDimensional k V] [Fintype ι] {p : ι → P}\n    (hi : AffineIndependent k p) : affineSpan k (Set.range p) = «expr⊤» ↔ Fintype.card ι = finrank k V + 1 :=\n  by\n  constructor\n  · intro h_tot\n    let n := Fintype.card ι - 1\n    have hn : Fintype.card ι = n + 1 := (nat.succ_pred_eq_of_pos (card_pos_of_affine_span_eq_top k V P h_tot)).symm\n    rw [hn, ← finrank_top, ← (vector_span_eq_top_of_affine_span_eq_top k V P) h_tot, ← hi.finrank_vector_span hn]\n  · intro hc\n    rw [← finrank_top, ← direction_top k V P] at hc\n    exact hi.affine_span_eq_of_le_of_card_eq_finrank_add_one le_top hc\n#align affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one\n-/\n\n",
 "affineSpan_eq_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print Collinear.affineSpan_eq_of_ne /-\n/-- The affine span of any two distinct points of a collinear set of points equals the affine\nspan of the whole set. -/\ntheorem Collinear.affineSpan_eq_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ : P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    (hp₁p₂ : p₁ ≠ p₂) : «exprline[ , , ]» k p₁ p₂ = affineSpan k s :=\n  le_antisymm (affineSpan_mono _ (Set.insert_subset.2 ⟨hp₁, Set.singleton_subset_iff.2 hp₂⟩))\n    (affineSpan_le.2 fun p hp => h.mem_affine_span_of_mem_of_ne hp₁ hp₂ hp hp₁p₂)\n#align collinear.affine_span_eq_of_ne Collinear.affineSpan_eq_of_ne\n-/\n\n",
 "affineSpan_eq_of_le_of_card_eq_finrank_add_one":
 "#print AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one /-\n/-- If the `affine_span` of a finite affinely independent family lies\nin an affine subspace whose direction has dimension one less than its\ncardinality, it equals that subspace. -/\ntheorem AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype ι] {p : ι → P}\n    (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k sp.direction]\n    (hle : affineSpan k (Set.range p) ≤ sp) (hc : Fintype.card ι = finrank k sp.direction + 1) :\n    affineSpan k (Set.range p) = sp := by\n  rw [← Finset.card_univ] at hc\n  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image] at hle⊢\n  exact hi.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc\n#align affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one\n-/\n\n",
 "affineIndependent_iff_not_finrank_vectorSpan_le":
 "#print affineIndependent_iff_not_finrank_vectorSpan_le /-\n/-- `n + 2` points are affinely independent if and only if their\n`vector_span` does not have dimension at most `n`. -/\ntheorem affineIndependent_iff_not_finrank_vectorSpan_le [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 2) :\n    AffineIndependent k p ↔ ¬finrank k (vectorSpan k (Set.range p)) ≤ n := by\n  rw [affineIndependent_iff_le_finrank_vectorSpan k p hc, ← Nat.lt_iff_add_one_le, lt_iff_not_ge]\n#align affine_independent_iff_not_finrank_vector_span_le affineIndependent_iff_not_finrank_vectorSpan_le\n-/\n\n",
 "affineIndependent_iff_not_collinear_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n#print affineIndependent_iff_not_collinear_set /-\n/-- Three points are affinely independent if and only if they are not collinear. -/\ntheorem affineIndependent_iff_not_collinear_set {p₁ p₂ p₃ : P} :\n    AffineIndependent k\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") ↔\n      ¬Collinear k ({p₁, p₂, p₃} : Set P) :=\n  by simp [affineIndependent_iff_not_collinear, -Set.union_singleton]\n#align affine_independent_iff_not_collinear_set affineIndependent_iff_not_collinear_set\n-/\n\n",
 "affineIndependent_iff_not_collinear_of_ne":
 "#print affineIndependent_iff_not_collinear_of_ne /-\n/-- Three points are affinely independent if and only if they are not collinear. -/\ntheorem affineIndependent_iff_not_collinear_of_ne {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃)\n    (h₂₃ : i₂ ≠ i₃) : AffineIndependent k p ↔ ¬Collinear k ({p i₁, p i₂, p i₃} : Set P) :=\n  by\n  have hu : (Finset.univ : Finset (Fin 3)) = {i₁, i₂, i₃} := by decide!\n  rw [affineIndependent_iff_not_collinear, ← Set.image_univ, ← Finset.coe_univ, hu, Finset.coe_insert,\n    Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_pair]\n#align affine_independent_iff_not_collinear_of_ne affineIndependent_iff_not_collinear_of_ne\n-/\n\n",
 "affineIndependent_iff_not_collinear":
 "#print affineIndependent_iff_not_collinear /-\n/-- Three points are affinely independent if and only if they are not\ncollinear. -/\ntheorem affineIndependent_iff_not_collinear {p : Fin 3 → P} : AffineIndependent k p ↔ ¬Collinear k (Set.range p) := by\n  rw [collinear_iff_finrank_le_one, affineIndependent_iff_not_finrank_vectorSpan_le k p (Fintype.card_fin 3)]\n#align affine_independent_iff_not_collinear affineIndependent_iff_not_collinear\n-/\n\n",
 "affineIndependent_iff_le_finrank_vectorSpan":
 "#print affineIndependent_iff_le_finrank_vectorSpan /-\n/-- `n + 1` points are affinely independent if and only if their\n`vector_span` has dimension at least `n`. -/\ntheorem affineIndependent_iff_le_finrank_vectorSpan [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) :\n    AffineIndependent k p ↔ n ≤ finrank k (vectorSpan k (Set.range p)) :=\n  by\n  rw [affineIndependent_iff_finrank_vectorSpan_eq k p hc]\n  constructor\n  · rintro rfl\n    rfl\n  · exact fun hle => le_antisymm (finrank_vectorSpan_range_le k p hc) hle\n#align affine_independent_iff_le_finrank_vector_span affineIndependent_iff_le_finrank_vectorSpan\n-/\n\n",
 "affineIndependent_iff_finrank_vectorSpan_eq":
 "#print affineIndependent_iff_finrank_vectorSpan_eq /-\n/-- `n + 1` points are affinely independent if and only if their\n`vector_span` has dimension `n`. -/\ntheorem affineIndependent_iff_finrank_vectorSpan_eq [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) :\n    AffineIndependent k p ↔ finrank k (vectorSpan k (Set.range p)) = n :=\n  by\n  have hn : Nonempty ι := by simp [← Fintype.card_pos_iff, hc]\n  cases' hn with i₁\n  rw [affineIndependent_iff_linearIndependent_vsub _ _ i₁, linearIndependent_iff_card_eq_finrank_span, eq_comm,\n    vectorSpan_range_eq_span_range_vsub_right_ne k p i₁]\n  congr\n  rw [← Finset.card_univ] at hc\n  rw [Fintype.subtype_card]\n  simp [Finset.filter_ne', Finset.card_erase_of_mem, hc]\n#align affine_independent_iff_finrank_vector_span_eq affineIndependent_iff_finrank_vectorSpan_eq\n-/\n\n",
 "FiniteDimensional":
 "#print FiniteDimensional /-\nprotected theorem FiniteDimensional [Finite ι] (b : AffineBasis ι k P) : FiniteDimensional k V :=\n  let ⟨i⟩ := b.nonempty\n  FiniteDimensional.of_fintype_basis (b.basis_of i)\n#align finite_dimensional FiniteDimensional\n-/\n\n",
 "Finite":
 "#print Finite /-\nprotected theorem Finite [FiniteDimensional k V] (b : AffineBasis ι k P) : Finite ι :=\n  finite_of_fin_dim_affineIndependent k b.ind\n#align finite Finite\n-/\n\n"}