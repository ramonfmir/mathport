{"vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one":
 "/-- If the `vector_span` of a finite subset of an affinely independent\nfamily lies in a submodule with dimension one less than its\ncardinality, it equals that submodule. -/\ntheorem affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one {p : ι → P}\n    (hi : affine_independent k p) {s : Finset ι} {sm : submodule k V} [finite_dimensional k sm]\n    (hle : vector_span k (s.image p : set P) ≤ sm) (hc : finset.card s = finrank k sm + 1) :\n    vector_span k (s.image p : set P) = sm :=\n  eq_of_le_of_finrank_eq hle <| hi.finrank_vector_span_image_finset hc\n#align\n  affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one affine_independent.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one\n\n",
 "vector_span_eq_top_of_card_eq_finrank_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The `vector_span` of a finite affinely independent family whose\ncardinality is one more than that of the finite-dimensional space is\n`⊤`. -/\ntheorem affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one [finite_dimensional k V] [fintype ι]\n    {p : ι → P} (hi : affine_independent k p) (hc : fintype.card ι = finrank k V + 1) :\n    vector_span k (Set.range p) = «expr⊤» :=\n  eq_top_of_finrank_eq <| hi.finrank_vector_span hc\n#align\n  affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one affine_independent.vector_span_eq_top_of_card_eq_finrank_add_one\n\n",
 "vector_span_eq_of_le_of_card_eq_finrank_add_one":
 "/-- If the `vector_span` of a finite affinely independent\nfamily lies in a submodule with dimension one less than its\ncardinality, it equals that submodule. -/\ntheorem affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one [fintype ι] {p : ι → P}\n    (hi : affine_independent k p) {sm : submodule k V} [finite_dimensional k sm]\n    (hle : vector_span k (Set.range p) ≤ sm) (hc : fintype.card ι = finrank k sm + 1) :\n    vector_span k (Set.range p) = sm :=\n  eq_of_le_of_finrank_eq hle <| hi.finrank_vector_span hc\n#align\n  affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one affine_independent.vector_span_eq_of_le_of_card_eq_finrank_add_one\n\n",
 "subset":
 "/-- A subset of a coplanar set is coplanar. -/\ntheorem coplanar.subset {s₁ s₂ : set P} (hs : s₁ ⊆ s₂) (h : coplanar k s₂) : coplanar k s₁ :=\n  (dim_le_of_submodule (vector_span k s₁) (vector_span k s₂) (vector_span_mono k hs)).trans h\n#align coplanar.subset coplanar.subset\n\n",
 "ne₂₃_of_not_collinear":
 "/-- If three points are not collinear, the second and third are different. -/\ntheorem ne₂₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬collinear k ({p₁, p₂, p₃} : set P)) : p₂ ≠ p₃ :=\n  by\n  rintro rfl\n  simpa [collinear_pair] using h\n#align ne₂₃_of_not_collinear ne₂₃_of_not_collinear\n\n",
 "ne₁₃_of_not_collinear":
 "/-- If three points are not collinear, the first and third are different. -/\ntheorem ne₁₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬collinear k ({p₁, p₂, p₃} : set P)) : p₁ ≠ p₃ :=\n  by\n  rintro rfl\n  simpa [collinear_pair] using h\n#align ne₁₃_of_not_collinear ne₁₃_of_not_collinear\n\n",
 "ne₁₂_of_not_collinear":
 "/-- If three points are not collinear, the first and second are different. -/\ntheorem ne₁₂_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬collinear k ({p₁, p₂, p₃} : set P)) : p₁ ≠ p₂ :=\n  by\n  rintro rfl\n  simpa [collinear_pair] using h\n#align ne₁₂_of_not_collinear ne₁₂_of_not_collinear\n\n",
 "mem_affine_span_of_mem_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- A point in a collinear set of points lies in the affine span of any two distinct points of\nthat set. -/\ntheorem collinear.mem_affine_span_of_mem_of_ne {s : set P} (h : collinear k s) {p₁ p₂ p₃ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) (hp₁p₂ : p₁ ≠ p₂) : p₃ ∈ «exprline[ , , ]» k p₁ p₂ :=\n  by\n  rw [collinear_iff_of_mem hp₁] at h\n  rcases h with ⟨v, h⟩\n  rcases h p₂ hp₂ with ⟨r₂, rfl⟩\n  rcases h p₃ hp₃ with ⟨r₃, rfl⟩\n  rw [vadd_left_mem_affine_span_pair]\n  refine' ⟨r₃ / r₂, _⟩\n  have h₂ : r₂ ≠ 0 := by\n    rintro rfl\n    simpa using hp₁p₂\n  simp [smul_smul, h₂]\n#align collinear.mem_affine_span_of_mem_of_ne collinear.mem_affine_span_of_mem_of_ne\n\n",
 "finrank_vector_span_range_le":
 "/-- The `vector_span` of an indexed family of `n + 1` points has\ndimension at most `n`. -/\ntheorem finrank_vector_span_range_le [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 1) :\n    finrank k (vector_span k (Set.range p)) ≤ n :=\n  by\n  rw [← Set.image_univ, ← finset.coe_univ, ← Finset.coe_image]\n  rw [← finset.card_univ] at hc\n  exact finrank_vector_span_image_finset_le _ _ _ hc\n#align finrank_vector_span_range_le finrank_vector_span_range_le\n\n",
 "finrank_vector_span_le_iff_not_affine_independent":
 "/-- `n + 2` points have a `vector_span` with dimension at most `n` if\nand only if they are not affinely independent. -/\ntheorem finrank_vector_span_le_iff_not_affine_independent [fintype ι] (p : ι → P) {n : ℕ}\n    (hc : fintype.card ι = n + 2) : finrank k (vector_span k (Set.range p)) ≤ n ↔ ¬affine_independent k p :=\n  (not_iff_comm.1 (affine_independent_iff_not_finrank_vector_span_le k p hc).symm).symm\n#align finrank_vector_span_le_iff_not_affine_independent finrank_vector_span_le_iff_not_affine_independent\n\n",
 "finrank_vector_span_insert_le_set":
 "/-- Adding a point to a set with a finite-dimensional span increases the dimension by at most\none. -/\ntheorem finrank_vector_span_insert_le_set (s : set P) (p : P) :\n    finrank k (vector_span k (insert p s)) ≤ finrank k (vector_span k s) + 1 :=\n  by\n  rw [← direction_affine_span, ← affine_span_insert_affine_span, direction_affine_span]\n  refine' (finrank_vector_span_insert_le _ _).trans (add_le_add_right _ _)\n  rw [direction_affine_span]\n#align finrank_vector_span_insert_le_set finrank_vector_span_insert_le_set\n\n",
 "finrank_vector_span_insert_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Adding a point to a finite-dimensional subspace increases the dimension by at most one. -/\ntheorem finrank_vector_span_insert_le (s : affine_subspace k P) (p : P) :\n    finrank k (vector_span k (insert p (s : set P))) ≤ finrank k s.direction + 1 :=\n  by\n  by_cases hf : finite_dimensional k s.direction; swap\n  · have hf' : ¬finite_dimensional k (vector_span k (insert p (s : set P))) :=\n      by\n      intro h\n      have h' : s.direction ≤ vector_span k (insert p (s : set P)) :=\n        by\n        conv_lhs => rw [← affine_span_coe s, direction_affine_span]\n        exact vector_span_mono k (Set.subset_insert _ _)\n      exact hf (submodule.finite_dimensional_of_le h')\n    rw [finrank_of_infinite_dimensional hf, finrank_of_infinite_dimensional hf', zero_add]\n    exact zero_le_one\n  haveI := hf\n  rw [← direction_affine_span, ← affine_span_insert_affine_span]\n  rcases(s : set P).eq_empty_or_nonempty with (hs | ⟨p₀, hp₀⟩)\n  · rw [coe_eq_bot_iff] at hs\n    rw [hs, bot_coe, span_empty, bot_coe, direction_affine_span, direction_bot, finrank_bot, zero_add]\n    convert zero_le_one' ℕ\n    rw [← finrank_bot k V]\n    convert rfl <;> simp\n  · rw [affine_span_coe, direction_affine_span_insert hp₀, add_comm]\n    refine' (submodule.dim_add_le_dim_add_dim _ _).trans (add_le_add_right _ _)\n    refine' finrank_le_one ⟨«expr -ᵥ » p p₀, submodule.mem_span_singleton_self _⟩ fun v => _\n    have h := v.property\n    rw [submodule.mem_span_singleton] at h\n    rcases h with ⟨c, hc⟩\n    refine' ⟨c, _⟩\n    ext\n    exact hc\n#align finrank_vector_span_insert_le finrank_vector_span_insert_le\n\n",
 "finrank_vector_span_image_finset_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The `vector_span` of `n + 1` points in an indexed family has\ndimension at most `n`. -/\ntheorem finrank_vector_span_image_finset_le (p : ι → P) (s : Finset ι) {n : ℕ} (hc : finset.card s = n + 1) :\n    finrank k (vector_span k (s.image p : set P)) ≤ n :=\n  by\n  have hn : (s.image p).nonempty :=\n    by\n    rw [Finset.Nonempty.image_iff, ← finset.card_pos, hc]\n    apply nat.succ_pos\n  rcases hn with ⟨p₁, hp₁⟩\n  rw [vector_span_eq_span_vsub_finset_right_ne k hp₁]\n  refine' le_trans (finrank_span_finset_le_card (((s.image p).erase p₁).image fun p => «expr -ᵥ » p p₁)) _\n  rw [finset.card_image_of_injective _ (vsub_left_injective p₁), finset.card_erase_of_mem hp₁, tsub_le_iff_right, ← hc]\n  apply finset.card_image_le\n#align finrank_vector_span_image_finset_le finrank_vector_span_image_finset_le\n\n",
 "finrank_vector_span_image_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The `vector_span` of a finite subset of an affinely independent\nfamily has dimension one less than its cardinality. -/\ntheorem affine_independent.finrank_vector_span_image_finset {p : ι → P} (hi : affine_independent k p) {s : Finset ι}\n    {n : ℕ} (hc : finset.card s = n + 1) : finrank k (vector_span k (s.image p : set P)) = n :=\n  by\n  have hi' := hi.range.mono (Set.image_subset_range p ↑s)\n  have hc' : (s.image p).card = n + 1 := by rwa [s.card_image_of_injective hi.injective]\n  have hn : (s.image p).nonempty := by simp [hc', ← finset.card_pos]\n  rcases hn with ⟨p₁, hp₁⟩\n  have hp₁' : p₁ ∈ «expr '' » p s := by simpa using hp₁\n  rw [affine_independent_set_iff_linear_independent_vsub k hp₁', ← Finset.coe_singleton, ← Finset.coe_image, ←\n    Finset.coe_sdiff, Finset.sdiff_singleton_eq_erase, ← Finset.coe_image] at hi'\n  have hc : (Finset.image (fun p : P => «expr -ᵥ » p p₁) ((Finset.image p s).erase p₁)).card = n :=\n    by\n    rw [finset.card_image_of_injective _ (vsub_left_injective _), finset.card_erase_of_mem hp₁]\n    exact Nat.pred_eq_of_eq_succ hc'\n  rwa [vector_span_eq_span_vsub_finset_right_ne k hp₁, finrank_span_finset_eq_card, hc]\n#align affine_independent.finrank_vector_span_image_finset affine_independent.finrank_vector_span_image_finset\n\n",
 "finrank_vector_span":
 "/-- The `vector_span` of a finite affinely independent family has\ndimension one less than its cardinality. -/\ntheorem affine_independent.finrank_vector_span [fintype ι] {p : ι → P} (hi : affine_independent k p) {n : ℕ}\n    (hc : fintype.card ι = n + 1) : finrank k (vector_span k (Set.range p)) = n :=\n  by\n  rw [← finset.card_univ] at hc\n  rw [← Set.image_univ, ← finset.coe_univ, ← Finset.coe_image]\n  exact hi.finrank_vector_span_image_finset hc\n#align affine_independent.finrank_vector_span affine_independent.finrank_vector_span\n\n",
 "finite_set_of_fin_dim_affine_independent":
 "/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem finite_set_of_fin_dim_affine_independent [finite_dimensional k V] {s : set ι} {f : s → P}\n    (hi : affine_independent k f) : s.finite :=\n  @set.to_finite _ s (finite_of_fin_dim_affine_independent k hi)\n#align finite_set_of_fin_dim_affine_independent finite_set_of_fin_dim_affine_independent\n\n",
 "finite_set":
 "protected theorem finite_set [finite_dimensional k V] {s : set ι} (b : affine_basis s k P) : s.finite :=\n  finite_set_of_fin_dim_affine_independent k b.ind\n#align finite_set finite_set\n\n",
 "finite_of_fin_dim_affine_independent":
 "/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem finite_of_fin_dim_affine_independent [finite_dimensional k V] {p : ι → P} (hi : affine_independent k p) :\n    Finite ι := by\n  nontriviality ι; inhabit ι\n  rw [affine_independent_iff_linear_independent_vsub k p default] at hi\n  letI : is_noetherian k V := is_noetherian.iff_fg.2 infer_instance\n  exact (set.finite_singleton default).finite_of_compl (set.finite_coe_iff.1 hi.finite_of_is_noetherian)\n#align finite_of_fin_dim_affine_independent finite_of_fin_dim_affine_independent\n\n",
 "finite_dimensional_vector_span_of_finite":
 "/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n/-- The `vector_span` of a finite set is finite-dimensional. -/\ntheorem finite_dimensional_vector_span_of_finite {s : set P} (h : set.finite s) :\n    finite_dimensional k (vector_span k s) :=\n  span_of_finite k <| h.vsub h\n#align finite_dimensional_vector_span_of_finite finite_dimensional_vector_span_of_finite\n\n",
 "finite_dimensional_vector_span":
 "/-- The `vector_span` of coplanar points is finite-dimensional. -/\ntheorem coplanar.finite_dimensional_vector_span {s : set P} (h : coplanar k s) :\n    finite_dimensional k (vector_span k s) :=\n  by\n  refine' is_noetherian.iff_fg.1 (is_noetherian.iff_dim_lt_aleph_0.2 (lt_of_le_of_lt h _))\n  simp\n#align coplanar.finite_dimensional_vector_span coplanar.finite_dimensional_vector_span\n\n",
 "finite_dimensional_direction_affine_span_of_finite":
 "/-- The direction of the affine span of a finite set is\nfinite-dimensional. -/\ntheorem finite_dimensional_direction_affine_span_of_finite {s : set P} (h : set.finite s) :\n    finite_dimensional k (affine_span k s).direction :=\n  (direction_affine_span k s).symm ▸ finite_dimensional_vector_span_of_finite k h\n#align finite_dimensional_direction_affine_span_of_finite finite_dimensional_direction_affine_span_of_finite\n\n",
 "finite_dimensional_direction_affine_span":
 "/-- The direction of the affine span of coplanar points is finite-dimensional. -/\ntheorem coplanar.finite_dimensional_direction_affine_span {s : set P} (h : coplanar k s) :\n    finite_dimensional k (affine_span k s).direction :=\n  (direction_affine_span k s).symm ▸ h.finite_dimensional_vector_span\n#align coplanar.finite_dimensional_direction_affine_span coplanar.finite_dimensional_direction_affine_span\n\n",
 "finite_dimensional":
 "protected theorem finite_dimensional [Finite ι] (b : affine_basis ι k P) : finite_dimensional k V :=\n  let ⟨i⟩ := b.nonempty\n  finite_dimensional.of_fintype_basis (b.basis_of i)\n#align finite_dimensional finite_dimensional\n\n",
 "exists_affine_basis_of_finite_dimensional":
 "theorem exists_affine_basis_of_finite_dimensional [fintype ι] [finite_dimensional k V]\n    (h : fintype.card ι = finite_dimensional.finrank k V + 1) : nonempty (affine_basis ι k P) :=\n  by\n  obtain ⟨s, b, hb⟩ := affine_basis.exists_affine_basis k V P\n  lift s to Finset P using b.finite_set\n  refine' ⟨b.comp_equiv <| fintype.equiv_of_card_eq _⟩\n  rw [h, ← b.card_eq_finrank_add_one]\n#align exists_affine_basis_of_finite_dimensional exists_affine_basis_of_finite_dimensional\n\n",
 "coplanar_triple":
 "/-- Three points are coplanar. -/\ntheorem coplanar_triple (p₁ p₂ p₃ : P) : coplanar k ({p₁, p₂, p₃} : set P) :=\n  (collinear_pair k p₂ p₃).coplanar_insert p₁\n#align coplanar_triple coplanar_triple\n\n",
 "coplanar_singleton":
 "/-- A single point is coplanar. -/\ntheorem coplanar_singleton (p : P) : coplanar k ({p} : set P) :=\n  (collinear_singleton k p).coplanar\n#align coplanar_singleton coplanar_singleton\n\n",
 "coplanar_pair":
 "/-- Two points are coplanar. -/\ntheorem coplanar_pair (p₁ p₂ : P) : coplanar k ({p₁, p₂} : set P) :=\n  (collinear_pair k p₁ p₂).coplanar\n#align coplanar_pair coplanar_pair\n\n",
 "coplanar_of_finrank_eq_two":
 "/-- A set of points in a two-dimensional space is coplanar. -/\ntheorem coplanar_of_finrank_eq_two (s : set P) (h : finrank k V = 2) : coplanar k s :=\n  by\n  haveI := finite_dimensional_of_finrank_eq_succ h\n  rw [coplanar_iff_finrank_le_two, ← h]\n  exact submodule.finrank_le _\n#align coplanar_of_finrank_eq_two coplanar_of_finrank_eq_two\n\n",
 "coplanar_of_fact_finrank_eq_two":
 "/-- A set of points in a two-dimensional space is coplanar. -/\ntheorem coplanar_of_fact_finrank_eq_two (s : set P) [h : fact (finrank k V = 2)] : coplanar k s :=\n  coplanar_of_finrank_eq_two s h.out\n#align coplanar_of_fact_finrank_eq_two coplanar_of_fact_finrank_eq_two\n\n",
 "coplanar_insert_iff_of_mem_affine_span":
 "/-- Adding a point in the affine span of a set does not change whether that set is coplanar. -/\ntheorem coplanar_insert_iff_of_mem_affine_span {s : set P} {p : P} (h : p ∈ affine_span k s) :\n    coplanar k (insert p s) ↔ coplanar k s := by rw [coplanar, coplanar, vector_span_insert_eq_vector_span h]\n#align coplanar_insert_iff_of_mem_affine_span coplanar_insert_iff_of_mem_affine_span\n\n",
 "coplanar_insert":
 "/-- Adding a point to a collinear set produces a coplanar set. -/\ntheorem collinear.coplanar_insert {s : set P} (h : collinear k s) (p : P) : coplanar k (insert p s) :=\n  by\n  haveI := h.finite_dimensional_vector_span\n  rw [coplanar_iff_finrank_le_two]\n  exact (finrank_vector_span_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)\n#align collinear.coplanar_insert collinear.coplanar_insert\n\n",
 "coplanar_iff_finrank_le_two":
 "/-- A set of points, whose `vector_span` is finite-dimensional, is coplanar if and only if their\n`vector_span` has dimension at most `2`. -/\ntheorem coplanar_iff_finrank_le_two {s : set P} [finite_dimensional k (vector_span k s)] :\n    coplanar k s ↔ finrank k (vector_span k s) ≤ 2 :=\n  by\n  have h : coplanar k s ↔ module.rank k (vector_span k s) ≤ 2 := iff.rfl\n  rw [← finrank_eq_dim] at h\n  exact_mod_cast h\n#align coplanar_iff_finrank_le_two coplanar_iff_finrank_le_two\n\n",
 "coplanar_empty":
 "/-- The empty set is coplanar. -/\ntheorem coplanar_empty : coplanar k (∅ : set P) :=\n  (collinear_empty k P).coplanar\n#align coplanar_empty coplanar_empty\n\n",
 "coplanar":
 "/-- Collinear points are coplanar. -/\ntheorem collinear.coplanar {s : set P} (h : collinear k s) : coplanar k s :=\n  le_trans h one_le_two\n#align collinear.coplanar collinear.coplanar\n\n",
 "collinear_triple_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem collinear_triple_of_mem_affine_span_pair {p₁ p₂ p₃ p₄ p₅ : P} (h₁ : p₁ ∈ «exprline[ , , ]» k p₄ p₅)\n    (h₂ : p₂ ∈ «exprline[ , , ]» k p₄ p₅) (h₃ : p₃ ∈ «exprline[ , , ]» k p₄ p₅) : collinear k ({p₁, p₂, p₃} : set P) :=\n  by\n  refine' (collinear_insert_insert_insert_left_of_mem_affine_span_pair h₁ h₂ h₃).subset _\n  simp [Set.insert_subset_insert]\n#align collinear_triple_of_mem_affine_span_pair collinear_triple_of_mem_affine_span_pair\n\n",
 "collinear_singleton":
 "/-- A single point is collinear. -/\ntheorem collinear_singleton (p : P) : collinear k ({p} : set P) :=\n  by\n  rw [collinear_iff_dim_le_one, vector_span_singleton]\n  simp\n#align collinear_singleton collinear_singleton\n\n",
 "collinear_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Two points are collinear. -/\ntheorem collinear_pair (p₁ p₂ : P) : collinear k ({p₁, p₂} : set P) :=\n  by\n  rw [collinear_iff_exists_forall_eq_smul_vadd]\n  use p₁, «expr -ᵥ » p₂ p₁\n  intro p hp\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp\n  cases hp\n  · use 0\n    simp [hp]\n  · use 1\n    simp [hp]\n#align collinear_pair collinear_pair\n\n",
 "collinear_insert_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- If a point lies in the affine span of two points, those three points are collinear. -/\ntheorem collinear_insert_of_mem_affine_span_pair {p₁ p₂ p₃ : P} (h : p₁ ∈ «exprline[ , , ]» k p₂ p₃) :\n    collinear k ({p₁, p₂, p₃} : set P) :=\n  by\n  rw [collinear_insert_iff_of_mem_affine_span h]\n  exact collinear_pair _ _ _\n#align collinear_insert_of_mem_affine_span_pair collinear_insert_of_mem_affine_span_pair\n\n",
 "collinear_insert_insert_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- If two points lie in the affine span of two points, those four points are collinear. -/\ntheorem collinear_insert_insert_of_mem_affine_span_pair {p₁ p₂ p₃ p₄ : P} (h₁ : p₁ ∈ «exprline[ , , ]» k p₃ p₄)\n    (h₂ : p₂ ∈ «exprline[ , , ]» k p₃ p₄) : collinear k ({p₁, p₂, p₃, p₄} : set P) :=\n  by\n  rw [collinear_insert_iff_of_mem_affine_span\n      ((affine_subspace.le_def' _ _).1 (affine_span_mono k (Set.subset_insert _ _)) _ h₁),\n    collinear_insert_iff_of_mem_affine_span h₂]\n  exact collinear_pair _ _ _\n#align collinear_insert_insert_of_mem_affine_span_pair collinear_insert_insert_of_mem_affine_span_pair\n\n",
 "collinear_insert_insert_insert_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- If three points lie in the affine span of two points, those five points are collinear. -/\ntheorem collinear_insert_insert_insert_of_mem_affine_span_pair {p₁ p₂ p₃ p₄ p₅ : P}\n    (h₁ : p₁ ∈ «exprline[ , , ]» k p₄ p₅) (h₂ : p₂ ∈ «exprline[ , , ]» k p₄ p₅) (h₃ : p₃ ∈ «exprline[ , , ]» k p₄ p₅) :\n    collinear k ({p₁, p₂, p₃, p₄, p₅} : set P) :=\n  by\n  rw [collinear_insert_iff_of_mem_affine_span\n      ((affine_subspace.le_def' _ _).1 (affine_span_mono k ((Set.subset_insert _ _).trans (Set.subset_insert _ _))) _\n        h₁),\n    collinear_insert_iff_of_mem_affine_span\n      ((affine_subspace.le_def' _ _).1 (affine_span_mono k (Set.subset_insert _ _)) _ h₂),\n    collinear_insert_iff_of_mem_affine_span h₃]\n  exact collinear_pair _ _ _\n#align collinear_insert_insert_insert_of_mem_affine_span_pair collinear_insert_insert_insert_of_mem_affine_span_pair\n\n",
 "collinear_insert_insert_insert_left_of_mem_affine_span_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- If three points lie in the affine span of two points, the first four points are collinear. -/\ntheorem collinear_insert_insert_insert_left_of_mem_affine_span_pair {p₁ p₂ p₃ p₄ p₅ : P}\n    (h₁ : p₁ ∈ «exprline[ , , ]» k p₄ p₅) (h₂ : p₂ ∈ «exprline[ , , ]» k p₄ p₅) (h₃ : p₃ ∈ «exprline[ , , ]» k p₄ p₅) :\n    collinear k ({p₁, p₂, p₃, p₄} : set P) :=\n  by\n  refine' (collinear_insert_insert_insert_of_mem_affine_span_pair h₁ h₂ h₃).subset _\n  simp [Set.insert_subset_insert]\n#align\n  collinear_insert_insert_insert_left_of_mem_affine_span_pair collinear_insert_insert_insert_left_of_mem_affine_span_pair\n\n",
 "collinear_insert_iff_of_ne":
 "/-- Given a collinear set of points, and two distinct points `p₂` and `p₃` in it, a point `p₁` is\ncollinear with the set if and only if it is collinear with `p₂` and `p₃`. -/\ntheorem collinear.collinear_insert_iff_of_ne {s : set P} (h : collinear k s) {p₁ p₂ p₃ : P} (hp₂ : p₂ ∈ s)\n    (hp₃ : p₃ ∈ s) (hp₂p₃ : p₂ ≠ p₃) : collinear k (insert p₁ s) ↔ collinear k ({p₁, p₂, p₃} : set P) :=\n  by\n  have hv : vector_span k (insert p₁ s) = vector_span k ({p₁, p₂, p₃} : set P) :=\n    by\n    conv_lhs => rw [← direction_affine_span, ← affine_span_insert_affine_span]\n    conv_rhs => rw [← direction_affine_span, ← affine_span_insert_affine_span]\n    rw [h.affine_span_eq_of_ne hp₂ hp₃ hp₂p₃]\n  rw [collinear, collinear, hv]\n#align collinear.collinear_insert_iff_of_ne collinear.collinear_insert_iff_of_ne\n\n",
 "collinear_insert_iff_of_mem_affine_span":
 "/-- Adding a point in the affine span of a set does not change whether that set is collinear. -/\ntheorem collinear_insert_iff_of_mem_affine_span {s : set P} {p : P} (h : p ∈ affine_span k s) :\n    collinear k (insert p s) ↔ collinear k s := by rw [collinear, collinear, vector_span_insert_eq_vector_span h]\n#align collinear_insert_iff_of_mem_affine_span collinear_insert_iff_of_mem_affine_span\n\n",
 "collinear_iff_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Given a point `p₀` in a set of points, that set is collinear if and\nonly if the points can all be expressed as multiples of the same\nvector, added to `p₀`. -/\ntheorem collinear_iff_of_mem {s : set P} {p₀ : P} (h : p₀ ∈ s) :\n    collinear k s ↔ ∃ v : V, ∀ p ∈ s, ∃ r : k, p = «expr +ᵥ » («expr • » r v) p₀ :=\n  by\n  simp_rw [collinear_iff_dim_le_one, dim_submodule_le_one_iff', submodule.le_span_singleton_iff]\n  constructor\n  · rintro ⟨v₀, hv⟩\n    use v₀\n    intro p hp\n    obtain ⟨r, hr⟩ := hv («expr -ᵥ » p p₀) (vsub_mem_vector_span k hp h)\n    use r\n    rw [eq_vadd_iff_vsub_eq]\n    exact hr.symm\n  · rintro ⟨v, hp₀v⟩\n    use v\n    intro w hw\n    have hs : vector_span k s ≤ «expr ∙ » k v :=\n      by\n      rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, Set.subset_def]\n      intro x hx\n      rw [SetLike.mem_coe, submodule.mem_span_singleton]\n      rw [Set.mem_image] at hx\n      rcases hx with ⟨p, hp, rfl⟩\n      rcases hp₀v p hp with ⟨r, rfl⟩\n      use r\n      simp\n    have hw' := SetLike.le_def.1 hs hw\n    rwa [submodule.mem_span_singleton] at hw'\n#align collinear_iff_of_mem collinear_iff_of_mem\n\n",
 "collinear_iff_not_affine_independent_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Three points are collinear if and only if they are not affinely independent. -/\ntheorem collinear_iff_not_affine_independent_set {p₁ p₂ p₃ : P} :\n    collinear k ({p₁, p₂, p₃} : set P) ↔\n      ¬affine_independent k\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  affine_independent_iff_not_collinear_set.not_left.symm\n#align collinear_iff_not_affine_independent_set collinear_iff_not_affine_independent_set\n\n",
 "collinear_iff_not_affine_independent_of_ne":
 "/-- Three points are collinear if and only if they are not affinely independent. -/\ntheorem collinear_iff_not_affine_independent_of_ne {p : fin 3 → P} {i₁ i₂ i₃ : fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃)\n    (h₂₃ : i₂ ≠ i₃) : collinear k ({p i₁, p i₂, p i₃} : set P) ↔ ¬affine_independent k p :=\n  (affine_independent_iff_not_collinear_of_ne h₁₂ h₁₃ h₂₃).not_left.symm\n#align collinear_iff_not_affine_independent_of_ne collinear_iff_not_affine_independent_of_ne\n\n",
 "collinear_iff_not_affine_independent":
 "/-- Three points are collinear if and only if they are not affinely\nindependent. -/\ntheorem collinear_iff_not_affine_independent {p : fin 3 → P} : collinear k (Set.range p) ↔ ¬affine_independent k p := by\n  rw [collinear_iff_finrank_le_one, finrank_vector_span_le_iff_not_affine_independent k p (fintype.card_fin 3)]\n#align collinear_iff_not_affine_independent collinear_iff_not_affine_independent\n\n",
 "collinear_iff_finrank_le_one":
 "/-- A set of points, whose `vector_span` is finite-dimensional, is\ncollinear if and only if their `vector_span` has dimension at most\n`1`. -/\ntheorem collinear_iff_finrank_le_one {s : set P} [finite_dimensional k (vector_span k s)] :\n    collinear k s ↔ finrank k (vector_span k s) ≤ 1 :=\n  by\n  have h := collinear_iff_dim_le_one k s\n  rw [← finrank_eq_dim] at h\n  exact_mod_cast h\n#align collinear_iff_finrank_le_one collinear_iff_finrank_le_one\n\n",
 "collinear_iff_exists_forall_eq_smul_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A set of points is collinear if and only if they can all be\nexpressed as multiples of the same vector, added to the same base\npoint. -/\ntheorem collinear_iff_exists_forall_eq_smul_vadd (s : set P) :\n    collinear k s ↔ ∃ (p₀ : P)(v : V), ∀ p ∈ s, ∃ r : k, p = «expr +ᵥ » («expr • » r v) p₀ :=\n  by\n  rcases Set.eq_empty_or_nonempty s with (rfl | ⟨⟨p₁, hp₁⟩⟩)\n  · simp [collinear_empty]\n  · rw [collinear_iff_of_mem hp₁]\n    constructor\n    · exact fun h => ⟨p₁, h⟩\n    · rintro ⟨p, v, hv⟩\n      use v\n      intro p₂ hp₂\n      rcases hv p₂ hp₂ with ⟨r, rfl⟩\n      rcases hv p₁ hp₁ with ⟨r₁, rfl⟩\n      use r - r₁\n      simp [vadd_vadd, ← add_smul]\n#align collinear_iff_exists_forall_eq_smul_vadd collinear_iff_exists_forall_eq_smul_vadd\n\n",
 "collinear_iff_dim_le_one":
 "/-- The definition of `collinear`. -/\ntheorem collinear_iff_dim_le_one (s : set P) : collinear k s ↔ module.rank k (vector_span k s) ≤ 1 :=\n  iff.rfl\n#align collinear_iff_dim_le_one collinear_iff_dim_le_one\n\n",
 "collinear_empty":
 "/-- The empty set is collinear. -/\ntheorem collinear_empty : collinear k (∅ : set P) :=\n  by\n  rw [collinear_iff_dim_le_one, vector_span_empty]\n  simp\n#align collinear_empty collinear_empty\n\n",
 "card_eq_finrank_add_one":
 "theorem card_eq_finrank_add_one [fintype ι] (b : affine_basis ι k P) :\n    fintype.card ι = finite_dimensional.finrank k V + 1 :=\n  haveI := b.finite_dimensional\n  b.ind.affine_span_eq_top_iff_card_eq_finrank_add_one.mp b.tot\n#align card_eq_finrank_add_one card_eq_finrank_add_one\n\n",
 "affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one":
 "/-- If the `affine_span` of a finite subset of an affinely independent\nfamily lies in an affine subspace whose direction has dimension one\nless than its cardinality, it equals that subspace. -/\ntheorem affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one {p : ι → P}\n    (hi : affine_independent k p) {s : Finset ι} {sp : affine_subspace k P} [finite_dimensional k sp.direction]\n    (hle : affine_span k (s.image p : set P) ≤ sp) (hc : finset.card s = finrank k sp.direction + 1) :\n    affine_span k (s.image p : set P) = sp :=\n  by\n  have hn : (s.image p).nonempty :=\n    by\n    rw [Finset.Nonempty.image_iff, ← finset.card_pos, hc]\n    apply nat.succ_pos\n  refine' eq_of_direction_eq_of_nonempty_of_le _ ((affine_span_nonempty k _).2 hn) hle\n  have hd := direction_le hle\n  rw [direction_affine_span] at hd⊢\n  exact hi.vector_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hd hc\n#align\n  affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one affine_independent.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one\n\n",
 "affine_span_eq_top_iff_card_eq_finrank_add_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The `affine_span` of a finite affinely independent family is `⊤` iff the\nfamily's cardinality is one more than that of the finite-dimensional space. -/\ntheorem affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one [finite_dimensional k V] [fintype ι]\n    {p : ι → P} (hi : affine_independent k p) :\n    affine_span k (Set.range p) = «expr⊤» ↔ fintype.card ι = finrank k V + 1 :=\n  by\n  constructor\n  · intro h_tot\n    let n := fintype.card ι - 1\n    have hn : fintype.card ι = n + 1 := (nat.succ_pred_eq_of_pos (card_pos_of_affine_span_eq_top k V P h_tot)).symm\n    rw [hn, ← finrank_top, ← (vector_span_eq_top_of_affine_span_eq_top k V P) h_tot, ← hi.finrank_vector_span hn]\n  · intro hc\n    rw [← finrank_top, ← direction_top k V P] at hc\n    exact hi.affine_span_eq_of_le_of_card_eq_finrank_add_one le_top hc\n#align\n  affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one\n\n",
 "affine_span_eq_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/-- The affine span of any two distinct points of a collinear set of points equals the affine\nspan of the whole set. -/\ntheorem collinear.affine_span_eq_of_ne {s : set P} (h : collinear k s) {p₁ p₂ : P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s)\n    (hp₁p₂ : p₁ ≠ p₂) : «exprline[ , , ]» k p₁ p₂ = affine_span k s :=\n  le_antisymm (affine_span_mono _ (Set.insert_subset.2 ⟨hp₁, Set.singleton_subset_iff.2 hp₂⟩))\n    (affine_span_le.2 fun p hp => h.mem_affine_span_of_mem_of_ne hp₁ hp₂ hp hp₁p₂)\n#align collinear.affine_span_eq_of_ne collinear.affine_span_eq_of_ne\n\n",
 "affine_span_eq_of_le_of_card_eq_finrank_add_one":
 "/-- If the `affine_span` of a finite affinely independent family lies\nin an affine subspace whose direction has dimension one less than its\ncardinality, it equals that subspace. -/\ntheorem affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one [fintype ι] {p : ι → P}\n    (hi : affine_independent k p) {sp : affine_subspace k P} [finite_dimensional k sp.direction]\n    (hle : affine_span k (Set.range p) ≤ sp) (hc : fintype.card ι = finrank k sp.direction + 1) :\n    affine_span k (Set.range p) = sp := by\n  rw [← finset.card_univ] at hc\n  rw [← Set.image_univ, ← finset.coe_univ, ← Finset.coe_image] at hle⊢\n  exact hi.affine_span_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc\n#align\n  affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one affine_independent.affine_span_eq_of_le_of_card_eq_finrank_add_one\n\n",
 "affine_independent_iff_not_finrank_vector_span_le":
 "/-- `n + 2` points are affinely independent if and only if their\n`vector_span` does not have dimension at most `n`. -/\ntheorem affine_independent_iff_not_finrank_vector_span_le [fintype ι] (p : ι → P) {n : ℕ}\n    (hc : fintype.card ι = n + 2) : affine_independent k p ↔ ¬finrank k (vector_span k (Set.range p)) ≤ n := by\n  rw [affine_independent_iff_le_finrank_vector_span k p hc, ← Nat.lt_iff_add_one_le, lt_iff_not_ge]\n#align affine_independent_iff_not_finrank_vector_span_le affine_independent_iff_not_finrank_vector_span_le\n\n",
 "affine_independent_iff_not_collinear_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Three points are affinely independent if and only if they are not collinear. -/\ntheorem affine_independent_iff_not_collinear_set {p₁ p₂ p₃ : P} :\n    affine_independent k\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") ↔\n      ¬collinear k ({p₁, p₂, p₃} : set P) :=\n  by simp [affine_independent_iff_not_collinear, -Set.union_singleton]\n#align affine_independent_iff_not_collinear_set affine_independent_iff_not_collinear_set\n\n",
 "affine_independent_iff_not_collinear_of_ne":
 "/-- Three points are affinely independent if and only if they are not collinear. -/\ntheorem affine_independent_iff_not_collinear_of_ne {p : fin 3 → P} {i₁ i₂ i₃ : fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃)\n    (h₂₃ : i₂ ≠ i₃) : affine_independent k p ↔ ¬collinear k ({p i₁, p i₂, p i₃} : set P) :=\n  by\n  have hu : (finset.univ : Finset (fin 3)) = {i₁, i₂, i₃} := by decide!\n  rw [affine_independent_iff_not_collinear, ← Set.image_univ, ← finset.coe_univ, hu, Finset.coe_insert,\n    Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_pair]\n#align affine_independent_iff_not_collinear_of_ne affine_independent_iff_not_collinear_of_ne\n\n",
 "affine_independent_iff_not_collinear":
 "/-- Three points are affinely independent if and only if they are not\ncollinear. -/\ntheorem affine_independent_iff_not_collinear {p : fin 3 → P} : affine_independent k p ↔ ¬collinear k (Set.range p) := by\n  rw [collinear_iff_finrank_le_one, affine_independent_iff_not_finrank_vector_span_le k p (fintype.card_fin 3)]\n#align affine_independent_iff_not_collinear affine_independent_iff_not_collinear\n\n",
 "affine_independent_iff_le_finrank_vector_span":
 "/-- `n + 1` points are affinely independent if and only if their\n`vector_span` has dimension at least `n`. -/\ntheorem affine_independent_iff_le_finrank_vector_span [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 1) :\n    affine_independent k p ↔ n ≤ finrank k (vector_span k (Set.range p)) :=\n  by\n  rw [affine_independent_iff_finrank_vector_span_eq k p hc]\n  constructor\n  · rintro rfl\n    rfl\n  · exact fun hle => le_antisymm (finrank_vector_span_range_le k p hc) hle\n#align affine_independent_iff_le_finrank_vector_span affine_independent_iff_le_finrank_vector_span\n\n",
 "affine_independent_iff_finrank_vector_span_eq":
 "/-- `n + 1` points are affinely independent if and only if their\n`vector_span` has dimension `n`. -/\ntheorem affine_independent_iff_finrank_vector_span_eq [fintype ι] (p : ι → P) {n : ℕ} (hc : fintype.card ι = n + 1) :\n    affine_independent k p ↔ finrank k (vector_span k (Set.range p)) = n :=\n  by\n  have hn : nonempty ι := by simp [← fintype.card_pos_iff, hc]\n  cases' hn with i₁\n  rw [affine_independent_iff_linear_independent_vsub _ _ i₁, linear_independent_iff_card_eq_finrank_span, eq_comm,\n    vector_span_range_eq_span_range_vsub_right_ne k p i₁]\n  congr\n  rw [← finset.card_univ] at hc\n  rw [fintype.subtype_card]\n  simp [Finset.filter_ne', finset.card_erase_of_mem, hc]\n#align affine_independent_iff_finrank_vector_span_eq affine_independent_iff_finrank_vector_span_eq\n\n",
 "Finite":
 "#print Finite /-\nprotected theorem Finite [finite_dimensional k V] (b : affine_basis ι k P) : Finite ι :=\n  finite_of_fin_dim_affine_independent k b.ind\n#align finite Finite\n-/\n\n"}