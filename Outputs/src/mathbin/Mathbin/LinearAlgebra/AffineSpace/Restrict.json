{"surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem affine_map.restrict.surjective (φ : «expr →ᵃ[ ] » P₁ k P₂) {E : affine_subspace k P₁} {F : affine_subspace k P₂}\n    [nonempty E] [nonempty F] (h : E.map φ = F) : function.surjective (affine_map.restrict φ (le_of_eq h)) :=\n  by\n  rintro ⟨x, hx : x ∈ F⟩\n  rw [← h, affine_subspace.mem_map] at hx\n  obtain ⟨y, hy, rfl⟩ := hx\n  exact ⟨⟨y, hy⟩, rfl⟩\n#align affine_map.restrict.surjective affine_map.restrict.surjective\n\n",
 "nonempty_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/-\nCopyright (c) 2022 Paul Reichert. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Paul Reichert\n-/\n-- not an instance because it loops with `nonempty`\ntheorem affine_subspace.nonempty_map {E : affine_subspace k P₁} [Ene : nonempty E] {φ : «expr →ᵃ[ ] » P₁ k P₂} :\n    nonempty (E.map φ) := by\n  obtain ⟨x, hx⟩ := id Ene\n  refine' ⟨⟨φ x, affine_subspace.mem_map.mpr ⟨x, hx, rfl⟩⟩⟩\n#align affine_subspace.nonempty_map affine_subspace.nonempty_map\n\n",
 "linear_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem affine_map.restrict.linear_aux {φ : «expr →ᵃ[ ] » P₁ k P₂} {E : affine_subspace k P₁} {F : affine_subspace k P₂}\n    (hEF : E.map φ ≤ F) : E.direction ≤ F.direction.comap φ.linear :=\n  by\n  rw [← submodule.map_le_iff_le_comap, ← affine_subspace.map_direction]\n  exact affine_subspace.direction_le hEF\n#align affine_map.restrict.linear_aux affine_map.restrict.linear_aux\n\n",
 "linear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem affine_map.restrict.linear (φ : «expr →ᵃ[ ] » P₁ k P₂) {E : affine_subspace k P₁} {F : affine_subspace k P₂}\n    [nonempty E] [nonempty F] (hEF : E.map φ ≤ F) :\n    (φ.restrict hEF).linear = φ.linear.restrict (affine_map.restrict.linear_aux hEF) :=\n  rfl\n#align affine_map.restrict.linear affine_map.restrict.linear\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem affine_map.restrict.injective {φ : «expr →ᵃ[ ] » P₁ k P₂} (hφ : function.injective φ) {E : affine_subspace k P₁}\n    {F : affine_subspace k P₂} [nonempty E] [nonempty F] (hEF : E.map φ ≤ F) :\n    function.injective (affine_map.restrict φ hEF) := by\n  intro x y h\n  simp only [subtype.ext_iff, subtype.coe_mk, affine_map.restrict.coe_apply] at h⊢\n  exact hφ h\n#align affine_map.restrict.injective affine_map.restrict.injective\n\n",
 "coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem affine_map.restrict.coe_apply (φ : «expr →ᵃ[ ] » P₁ k P₂) {E : affine_subspace k P₁} {F : affine_subspace k P₂}\n    [nonempty E] [nonempty F] (hEF : E.map φ ≤ F) (x : E) : ↑(φ.restrict hEF x) = φ x :=\n  rfl\n#align affine_map.restrict.coe_apply affine_map.restrict.coe_apply\n\n",
 "bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem affine_map.restrict.bijective {E : affine_subspace k P₁} [nonempty E] {φ : «expr →ᵃ[ ] » P₁ k P₂}\n    (hφ : function.injective φ) : function.bijective (φ.restrict (le_refl (E.map φ))) :=\n  ⟨affine_map.restrict.injective hφ _, affine_map.restrict.surjective _ rfl⟩\n#align affine_map.restrict.bijective affine_map.restrict.bijective\n\n"}