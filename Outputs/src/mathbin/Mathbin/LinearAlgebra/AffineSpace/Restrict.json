{"surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineMap.restrict.surjective /-\ntheorem AffineMap.restrict.surjective (φ : «expr →ᵃ[ ] » P₁ k P₂) {E : AffineSubspace k P₁} {F : AffineSubspace k P₂}\n    [Nonempty E] [Nonempty F] (h : E.map φ = F) : function.surjective (AffineMap.restrict φ (le_of_eq h)) :=\n  by\n  rintro ⟨x, hx : x ∈ F⟩\n  rw [← h, AffineSubspace.mem_map] at hx\n  obtain ⟨y, hy, rfl⟩ := hx\n  exact ⟨⟨y, hy⟩, rfl⟩\n#align affine_map.restrict.surjective AffineMap.restrict.surjective\n-/\n\n",
 "nonempty_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineSubspace.nonempty_map /-\n/-\nCopyright (c) 2022 Paul Reichert. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Paul Reichert\n-/\n-- not an instance because it loops with `nonempty`\ntheorem AffineSubspace.nonempty_map {E : AffineSubspace k P₁} [Ene : Nonempty E] {φ : «expr →ᵃ[ ] » P₁ k P₂} :\n    Nonempty (E.map φ) := by\n  obtain ⟨x, hx⟩ := id Ene\n  refine' ⟨⟨φ x, affine_subspace.mem_map.mpr ⟨x, hx, rfl⟩⟩⟩\n#align affine_subspace.nonempty_map AffineSubspace.nonempty_map\n-/\n\n",
 "linear_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineMap.restrict.linear_aux /-\ntheorem AffineMap.restrict.linear_aux {φ : «expr →ᵃ[ ] » P₁ k P₂} {E : AffineSubspace k P₁} {F : AffineSubspace k P₂}\n    (hEF : E.map φ ≤ F) : E.direction ≤ F.direction.comap φ.linear :=\n  by\n  rw [← Submodule.map_le_iff_le_comap, ← AffineSubspace.map_direction]\n  exact AffineSubspace.direction_le hEF\n#align affine_map.restrict.linear_aux AffineMap.restrict.linear_aux\n-/\n\n",
 "linear":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineMap.restrict.linear /-\ntheorem AffineMap.restrict.linear (φ : «expr →ᵃ[ ] » P₁ k P₂) {E : AffineSubspace k P₁} {F : AffineSubspace k P₂}\n    [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) :\n    (φ.restrict hEF).linear = φ.linear.restrict (AffineMap.restrict.linear_aux hEF) :=\n  rfl\n#align affine_map.restrict.linear AffineMap.restrict.linear\n-/\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineMap.restrict.injective /-\ntheorem AffineMap.restrict.injective {φ : «expr →ᵃ[ ] » P₁ k P₂} (hφ : function.injective φ) {E : AffineSubspace k P₁}\n    {F : AffineSubspace k P₂} [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) :\n    function.injective (AffineMap.restrict φ hEF) := by\n  intro x y h\n  simp only [Subtype.ext_iff, Subtype.coe_mk, AffineMap.restrict.coe_apply] at h⊢\n  exact hφ h\n#align affine_map.restrict.injective AffineMap.restrict.injective\n-/\n\n",
 "coe_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineMap.restrict.coe_apply /-\ntheorem AffineMap.restrict.coe_apply (φ : «expr →ᵃ[ ] » P₁ k P₂) {E : AffineSubspace k P₁} {F : AffineSubspace k P₂}\n    [Nonempty E] [Nonempty F] (hEF : E.map φ ≤ F) (x : E) : ↑(φ.restrict hEF x) = φ x :=\n  rfl\n#align affine_map.restrict.coe_apply AffineMap.restrict.coe_apply\n-/\n\n",
 "bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n#print AffineMap.restrict.bijective /-\ntheorem AffineMap.restrict.bijective {E : AffineSubspace k P₁} [Nonempty E] {φ : «expr →ᵃ[ ] » P₁ k P₂}\n    (hφ : function.injective φ) : function.bijective (φ.restrict (le_refl (E.map φ))) :=\n  ⟨AffineMap.restrict.injective hφ _, AffineMap.restrict.surjective _ rfl⟩\n#align affine_map.restrict.bijective AffineMap.restrict.bijective\n-/\n\n"}