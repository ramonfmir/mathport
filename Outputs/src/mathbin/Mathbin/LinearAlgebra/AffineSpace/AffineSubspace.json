{"vsub_set_subset_vectorSpan":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vsub_set_subset_vectorSpan /-\n/-- The `s -ᵥ s` lies within the `vector_span k s`. -/\ntheorem vsub_set_subset_vectorSpan (s : Set P) : «expr -ᵥ » s s ⊆ ↑(vectorSpan k s) :=\n  Submodule.subset_span\n#align vsub_set_subset_vector_span vsub_set_subset_vectorSpan\n-/\n\n",
 "vsub_right_mem_direction_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point in an affine subspace, a result of subtracting that\npoint on the right is in the direction if and only if the other point\nis in the subspace. -/\ntheorem vsub_right_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) :\n    «expr -ᵥ » p2 p ∈ s.direction ↔ p2 ∈ s :=\n  by\n  rw [mem_direction_iff_eq_vsub_right hp]\n  simp\n#align vsub_right_mem_direction_iff_mem vsub_right_mem_direction_iff_mem\n\n",
 "vsub_rev_mem_vectorSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vsub_rev_mem_vectorSpan_pair /-\n/-- The difference between two points (reversed) lies in their `vector_span`. -/\ntheorem vsub_rev_mem_vectorSpan_pair (p₁ p₂ : P) : «expr -ᵥ » p₂ p₁ ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  vsub_mem_vectorSpan _ (Set.mem_insert_of_mem _ (Set.mem_singleton _)) (Set.mem_insert _ _)\n#align vsub_rev_mem_vector_span_pair vsub_rev_mem_vectorSpan_pair\n-/\n\n",
 "vsub_mem_vectorSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vsub_mem_vectorSpan_pair /-\n/-- The difference between two points lies in their `vector_span`. -/\ntheorem vsub_mem_vectorSpan_pair (p₁ p₂ : P) : «expr -ᵥ » p₁ p₂ ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  vsub_mem_vectorSpan _ (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n#align vsub_mem_vector_span_pair vsub_mem_vectorSpan_pair\n-/\n\n",
 "vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints /-\n/-- Subtracting two points in the affine span produces a vector in the\nspanning submodule. -/\ntheorem vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints {s : Set P} {p1 p2 : P} (hp1 : p1 ∈ spanPoints k s)\n    (hp2 : p2 ∈ spanPoints k s) : «expr -ᵥ » p1 p2 ∈ vectorSpan k s :=\n  by\n  rcases hp1 with ⟨p1a, ⟨hp1a, ⟨v1, ⟨hv1, hv1p⟩⟩⟩⟩\n  rcases hp2 with ⟨p2a, ⟨hp2a, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩\n  rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub («expr +ᵥ » v1 p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]\n  have hv1v2 : v1 - v2 ∈ vectorSpan k s := by\n    rw [sub_eq_add_neg]\n    apply (vectorSpan k s).add_mem hv1\n    rw [← neg_one_smul k v2]\n    exact (vectorSpan k s).smul_mem (-1 : k) hv2\n  refine' (vectorSpan k s).add_mem _ hv1v2\n  exact vsub_mem_vectorSpan k hp1a hp2a\n#align vsub_mem_vector_span_of_mem_span_points_of_mem_span_points vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints\n-/\n\n",
 "vsub_mem_vectorSpan":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vsub_mem_vectorSpan /-\n/-- Each pairwise difference is in the `vector_span`. -/\ntheorem vsub_mem_vectorSpan {s : Set P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) : «expr -ᵥ » p1 p2 ∈ vectorSpan k s :=\n  vsub_set_subset_vectorSpan k s (vsub_mem_vsub hp1 hp2)\n#align vsub_mem_vector_span vsub_mem_vectorSpan\n-/\n\n",
 "vsub_mem_direction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Subtracting two points in the subspace produces a vector in the\ndirection. -/\ntheorem vsub_mem_direction {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) :\n    «expr -ᵥ » p1 p2 ∈ s.direction :=\n  vsub_mem_vectorSpan k hp1 hp2\n#align vsub_mem_direction vsub_mem_direction\n\n",
 "vsub_left_mem_direction_iff_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point in an affine subspace, a result of subtracting that\npoint on the left is in the direction if and only if the other point\nis in the subspace. -/\ntheorem vsub_left_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) :\n    «expr -ᵥ » p p2 ∈ s.direction ↔ p2 ∈ s :=\n  by\n  rw [mem_direction_iff_eq_vsub_left hp]\n  simp\n#align vsub_left_mem_direction_iff_mem vsub_left_mem_direction_iff_mem\n\n",
 "vector_span_eq_top_of_affine_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the affine span of a set is `⊤`, then the vector span of the same set is the `⊤`. -/\ntheorem vector_span_eq_top_of_affine_span_eq_top {s : Set P} (h : affineSpan k s = «expr⊤») :\n    vectorSpan k s = «expr⊤» := by rw [← direction_affineSpan, h, direction_top]\n#align vector_span_eq_top_of_affine_span_eq_top vector_span_eq_top_of_affine_span_eq_top\n\n",
 "vector_span_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\ntheorem parallel.vector_span_eq {s₁ s₂ : Set P} (h : affine_subspace.parallel (affineSpan k s₁) (affineSpan k s₂)) :\n    vectorSpan k s₁ = vectorSpan k s₂ := by\n  simp_rw [← direction_affineSpan]\n  exact h.direction_eq\n#align parallel.vector_span_eq parallel.vector_span_eq\n\n",
 "vectorSpan_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print vectorSpan_singleton /-\n/-- The `vector_span` of a single point is `⊥`. -/\n@[simp]\ntheorem vectorSpan_singleton (p : P) : vectorSpan k ({p} : Set P) = «expr⊥» := by simp [vectorSpan_def]\n#align vector_span_singleton vectorSpan_singleton\n-/\n\n",
 "vectorSpan_range_eq_span_range_vsub_right_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_range_eq_span_range_vsub_right_ne /-\n/-- The `vector_span` of an indexed family is the span of the pairwise\nsubtractions with a given point on the right, excluding the subtraction\nof that point from itself. -/\ntheorem vectorSpan_range_eq_span_range_vsub_right_ne (p : ι → P) (i₀ : ι) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : { x // x ≠ i₀ } => «expr -ᵥ » (p i) (p i₀)) :=\n  by\n  rw [← Set.image_univ, vectorSpan_image_eq_span_vsub_set_right_ne k _ (Set.mem_univ i₀)]\n  congr with v\n  simp only [Set.mem_range, Set.mem_image, Set.mem_diff, Set.mem_singleton_iff, Subtype.exists, Subtype.coe_mk]\n  constructor\n  · rintro ⟨x, ⟨i₁, ⟨⟨hi₁u, hi₁⟩, rfl⟩⟩, hv⟩\n    exact ⟨i₁, hi₁, hv⟩\n  · exact fun ⟨i₁, hi₁, hv⟩ => ⟨p i₁, ⟨i₁, ⟨Set.mem_univ _, hi₁⟩, rfl⟩, hv⟩\n#align vector_span_range_eq_span_range_vsub_right_ne vectorSpan_range_eq_span_range_vsub_right_ne\n-/\n\n",
 "vectorSpan_range_eq_span_range_vsub_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_range_eq_span_range_vsub_right /-\n/-- The `vector_span` of an indexed family is the span of the pairwise\nsubtractions with a given point on the right. -/\ntheorem vectorSpan_range_eq_span_range_vsub_right (p : ι → P) (i0 : ι) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : ι => «expr -ᵥ » (p i) (p i0)) := by\n  rw [vectorSpan_eq_span_vsub_set_right k (Set.mem_range_self i0), ← Set.range_comp]\n#align vector_span_range_eq_span_range_vsub_right vectorSpan_range_eq_span_range_vsub_right\n-/\n\n",
 "vectorSpan_range_eq_span_range_vsub_left_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_range_eq_span_range_vsub_left_ne /-\n/-- The `vector_span` of an indexed family is the span of the pairwise\nsubtractions with a given point on the left, excluding the subtraction\nof that point from itself. -/\ntheorem vectorSpan_range_eq_span_range_vsub_left_ne (p : ι → P) (i₀ : ι) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : { x // x ≠ i₀ } => «expr -ᵥ » (p i₀) (p i)) :=\n  by\n  rw [← Set.image_univ, vectorSpan_image_eq_span_vsub_set_left_ne k _ (Set.mem_univ i₀)]\n  congr with v\n  simp only [Set.mem_range, Set.mem_image, Set.mem_diff, Set.mem_singleton_iff, Subtype.exists, Subtype.coe_mk]\n  constructor\n  · rintro ⟨x, ⟨i₁, ⟨⟨hi₁u, hi₁⟩, rfl⟩⟩, hv⟩\n    exact ⟨i₁, hi₁, hv⟩\n  · exact fun ⟨i₁, hi₁, hv⟩ => ⟨p i₁, ⟨i₁, ⟨Set.mem_univ _, hi₁⟩, rfl⟩, hv⟩\n#align vector_span_range_eq_span_range_vsub_left_ne vectorSpan_range_eq_span_range_vsub_left_ne\n-/\n\n",
 "vectorSpan_range_eq_span_range_vsub_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_range_eq_span_range_vsub_left /-\n/-- The `vector_span` of an indexed family is the span of the pairwise\nsubtractions with a given point on the left. -/\ntheorem vectorSpan_range_eq_span_range_vsub_left (p : ι → P) (i0 : ι) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : ι => «expr -ᵥ » (p i0) (p i)) := by\n  rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_range_self i0), ← Set.range_comp]\n#align vector_span_range_eq_span_range_vsub_left vectorSpan_range_eq_span_range_vsub_left\n-/\n\n",
 "vectorSpan_pair_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_pair_rev /-\n/-- The `vector_span` of two points is the span of their difference (reversed). -/\ntheorem vectorSpan_pair_rev (p₁ p₂ : P) : vectorSpan k ({p₁, p₂} : Set P) = «expr ∙ » k («expr -ᵥ » p₂ p₁) := by\n  rw [pair_comm, vectorSpan_pair]\n#align vector_span_pair_rev vectorSpan_pair_rev\n-/\n\n",
 "vectorSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_pair /-\n/-- The `vector_span` of two points is the span of their difference. -/\ntheorem vectorSpan_pair (p₁ p₂ : P) : vectorSpan k ({p₁, p₂} : Set P) = «expr ∙ » k («expr -ᵥ » p₁ p₂) := by\n  rw [vectorSpan_eq_span_vsub_set_left k (mem_insert p₁ _), image_pair, vsub_self, Submodule.span_insert_zero]\n#align vector_span_pair vectorSpan_pair\n-/\n\n",
 "vectorSpan_mono":
 "#print vectorSpan_mono /-\n/-- `vector_span` is monotone. -/\ntheorem vectorSpan_mono {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : vectorSpan k s₁ ≤ vectorSpan k s₂ :=\n  Submodule.span_mono (vsub_self_mono h)\n#align vector_span_mono vectorSpan_mono\n-/\n\n",
 "vectorSpan_insert_eq_vectorSpan":
 "#print vectorSpan_insert_eq_vectorSpan /-\n/-- If a point is in the affine span of a set, adding it to that set\ndoes not change the vector span. -/\ntheorem vectorSpan_insert_eq_vectorSpan {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) :\n    vectorSpan k (insert p ps) = vectorSpan k ps := by\n  simp_rw [← direction_affineSpan, affineSpan_insert_eq_affineSpan _ h]\n#align vector_span_insert_eq_vector_span vectorSpan_insert_eq_vectorSpan\n-/\n\n",
 "vectorSpan_image_eq_submodule_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print AffineMap.vectorSpan_image_eq_submodule_map /-\n@[simp]\ntheorem AffineMap.vectorSpan_image_eq_submodule_map {s : Set P₁} :\n    Submodule.map f.linear (vectorSpan k s) = vectorSpan k («expr '' » f s) := by\n  simp [f.image_vsub_image, vectorSpan_def]\n#align affine_map.vector_span_image_eq_submodule_map AffineMap.vectorSpan_image_eq_submodule_map\n-/\n\n",
 "vectorSpan_image_eq_span_vsub_set_right_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print vectorSpan_image_eq_span_vsub_set_right_ne /-\n/-- The `vector_span` of the image of a function is the span of the\npairwise subtractions with a given point on the right, excluding the\nsubtraction of that point from itself. -/\ntheorem vectorSpan_image_eq_span_vsub_set_right_ne (p : ι → P) {s : Set ι} {i : ι} (hi : i ∈ s) :\n    vectorSpan k («expr '' » p s) = Submodule.span k («expr '' » («expr -ᵥ » · (p i)) («expr '' » p (s \\ {i}))) :=\n  by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_right k (Set.mem_image_of_mem p hi), ← Set.insert_eq_of_mem hi, ←\n      Set.insert_diff_singleton, Set.image_insert_eq, Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n#align vector_span_image_eq_span_vsub_set_right_ne vectorSpan_image_eq_span_vsub_set_right_ne\n-/\n\n",
 "vectorSpan_image_eq_span_vsub_set_left_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print vectorSpan_image_eq_span_vsub_set_left_ne /-\n/-- The `vector_span` of the image of a function is the span of the\npairwise subtractions with a given point on the left, excluding the\nsubtraction of that point from itself. -/\ntheorem vectorSpan_image_eq_span_vsub_set_left_ne (p : ι → P) {s : Set ι} {i : ι} (hi : i ∈ s) :\n    vectorSpan k («expr '' » p s) = Submodule.span k («expr '' » ((«expr -ᵥ » · ·) (p i)) («expr '' » p (s \\ {i}))) :=\n  by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_image_of_mem p hi), ← Set.insert_eq_of_mem hi, ←\n      Set.insert_diff_singleton, Set.image_insert_eq, Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n#align vector_span_image_eq_span_vsub_set_left_ne vectorSpan_image_eq_span_vsub_set_left_ne\n-/\n\n",
 "vectorSpan_eq_span_vsub_set_right_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n#print vectorSpan_eq_span_vsub_set_right_ne /-\n/-- The `vector_span` is the span of the pairwise subtractions with a\ngiven point on the right, excluding the subtraction of that point from\nitself. -/\ntheorem vectorSpan_eq_span_vsub_set_right_ne {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k («expr '' » («expr -ᵥ » · p) (s \\ {p})) :=\n  by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_right k hp, ← Set.insert_eq_of_mem hp, ← Set.insert_diff_singleton,\n      Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n#align vector_span_eq_span_vsub_set_right_ne vectorSpan_eq_span_vsub_set_right_ne\n-/\n\n",
 "vectorSpan_eq_span_vsub_set_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n#print vectorSpan_eq_span_vsub_set_right /-\n/-- The `vector_span` is the span of the pairwise subtractions with a\ngiven point on the right. -/\ntheorem vectorSpan_eq_span_vsub_set_right {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k («expr '' » («expr -ᵥ » · p) s) :=\n  by\n  rw [vectorSpan_def]\n  refine' le_antisymm _ (Submodule.span_mono _)\n  · rw [Submodule.span_le]\n    rintro v ⟨p1, p2, hp1, hp2, hv⟩\n    rw [← vsub_sub_vsub_cancel_right p1 p2 p] at hv\n    rw [← hv, SetLike.mem_coe, Submodule.mem_span]\n    exact fun m hm => Submodule.sub_mem _ (hm ⟨p1, hp1, rfl⟩) (hm ⟨p2, hp2, rfl⟩)\n  · rintro v ⟨p2, hp2, hv⟩\n    exact ⟨p2, p, hp2, hp, hv⟩\n#align vector_span_eq_span_vsub_set_right vectorSpan_eq_span_vsub_set_right\n-/\n\n",
 "vectorSpan_eq_span_vsub_set_left_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n#print vectorSpan_eq_span_vsub_set_left_ne /-\n/-- The `vector_span` is the span of the pairwise subtractions with a\ngiven point on the left, excluding the subtraction of that point from\nitself. -/\ntheorem vectorSpan_eq_span_vsub_set_left_ne {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k («expr '' » ((«expr -ᵥ » · ·) p) (s \\ {p})) :=\n  by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_left k hp, ← Set.insert_eq_of_mem hp, ← Set.insert_diff_singleton,\n      Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n#align vector_span_eq_span_vsub_set_left_ne vectorSpan_eq_span_vsub_set_left_ne\n-/\n\n",
 "vectorSpan_eq_span_vsub_set_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n#print vectorSpan_eq_span_vsub_set_left /-\n/-- The `vector_span` is the span of the pairwise subtractions with a\ngiven point on the left. -/\ntheorem vectorSpan_eq_span_vsub_set_left {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k («expr '' » ((«expr -ᵥ » · ·) p) s) :=\n  by\n  rw [vectorSpan_def]\n  refine' le_antisymm _ (Submodule.span_mono _)\n  · rw [Submodule.span_le]\n    rintro v ⟨p1, p2, hp1, hp2, hv⟩\n    rw [← vsub_sub_vsub_cancel_left p1 p2 p] at hv\n    rw [← hv, SetLike.mem_coe, Submodule.mem_span]\n    exact fun m hm => Submodule.sub_mem _ (hm ⟨p2, hp2, rfl⟩) (hm ⟨p1, hp1, rfl⟩)\n  · rintro v ⟨p2, hp2, hv⟩\n    exact ⟨p, p2, hp, hp2, hv⟩\n#align vector_span_eq_span_vsub_set_left vectorSpan_eq_span_vsub_set_left\n-/\n\n",
 "vectorSpan_eq_span_vsub_finset_right_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n#print vectorSpan_eq_span_vsub_finset_right_ne /-\n/-- The `vector_span` is the span of the pairwise subtractions with a\ngiven point on the right, excluding the subtraction of that point from\nitself. -/\ntheorem vectorSpan_eq_span_vsub_finset_right_ne [DecidableEq P] [DecidableEq V] {s : Finset P} {p : P} (hp : p ∈ s) :\n    vectorSpan k (s : Set P) = Submodule.span k ((s.erase p).image («expr -ᵥ » · p)) := by\n  simp [vectorSpan_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]\n#align vector_span_eq_span_vsub_finset_right_ne vectorSpan_eq_span_vsub_finset_right_ne\n-/\n\n",
 "vectorSpan_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print vectorSpan_empty /-\n/-- The `vector_span` of the empty set is `⊥`. -/\n@[simp]\ntheorem vectorSpan_empty : vectorSpan k (∅ : Set P) = («expr⊥» : Submodule k V) := by\n  rw [vectorSpan_def, vsub_empty, Submodule.span_empty]\n#align vector_span_empty vectorSpan_empty\n-/\n\n",
 "vectorSpan_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vectorSpan_def /-\n/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n/-- The definition of `vector_span`, for rewriting. -/\ntheorem vectorSpan_def (s : Set P) : vectorSpan k s = Submodule.span k («expr -ᵥ » s s) :=\n  rfl\n#align vector_span_def vectorSpan_def\n-/\n\n",
 "vadd_right_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vadd_right_mem_affineSpan_pair /-\n/-- A vector added to the second point lies in the affine span of two points if and only if it is\na multiple of their difference. -/\ntheorem vadd_right_mem_affineSpan_pair {p₁ p₂ : P} {v : V} :\n    «expr +ᵥ » v p₂ ∈ «exprline[ , , ]» k p₁ p₂ ↔ ∃ r : k, «expr • » r («expr -ᵥ » p₁ p₂) = v := by\n  rw [vadd_mem_iff_mem_direction _ (right_mem_affineSpan_pair _ _ _), direction_affineSpan, mem_vectorSpan_pair]\n#align vadd_right_mem_affine_span_pair vadd_right_mem_affineSpan_pair\n-/\n\n",
 "vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n#print vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan /-\n/-- Adding a point in the affine span and a vector in the spanning\nsubmodule produces a point in the affine span. -/\ntheorem vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan {s : Set P} {p : P} {v : V} (hp : p ∈ spanPoints k s)\n    (hv : v ∈ vectorSpan k s) : «expr +ᵥ » v p ∈ spanPoints k s :=\n  by\n  rcases hp with ⟨p2, ⟨hp2, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩\n  rw [hv2p, vadd_vadd]\n  use p2, hp2, v + v2, (vectorSpan k s).add_mem hv hv2, rfl\n#align vadd_mem_span_points_of_mem_span_points_of_mem_vector_span vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan\n-/\n\n",
 "vadd_mem_of_mem_direction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- Adding a vector in the direction to a point in the subspace\nproduces a point in the subspace. -/\ntheorem vadd_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction) {p : P} (hp : p ∈ s) :\n    «expr +ᵥ » v p ∈ s := by\n  rw [mem_direction_iff_eq_vsub ⟨p, hp⟩] at hv\n  rcases hv with ⟨p1, hp1, p2, hp2, hv⟩\n  rw [hv]\n  convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp\n  rw [one_smul]\n#align vadd_mem_of_mem_direction vadd_mem_of_mem_direction\n\n",
 "vadd_mem_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- An affine subspace constructed from a point and a direction contains\nthe result of adding a vector in that direction to that point. -/\ntheorem vadd_mem_mk' {v : V} (p : P) {direction : Submodule k V} (hv : v ∈ direction) :\n    «expr +ᵥ » v p ∈ mk' p direction :=\n  ⟨v, hv, rfl⟩\n#align vadd_mem_mk' vadd_mem_mk'\n\n",
 "vadd_mem_iff_mem_of_mem_direction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- Adding a vector in the direction to a point produces a point in the subspace if and only if\nthe original point is in the subspace. -/\ntheorem vadd_mem_iff_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction) {p : P} :\n    «expr +ᵥ » v p ∈ s ↔ p ∈ s :=\n  by\n  refine' ⟨fun h => _, fun h => vadd_mem_of_mem_direction hv h⟩\n  convert vadd_mem_of_mem_direction (Submodule.neg_mem _ hv) h\n  simp\n#align vadd_mem_iff_mem_of_mem_direction vadd_mem_iff_mem_of_mem_direction\n\n",
 "vadd_mem_iff_mem_direction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- Adding a vector to a point in a subspace produces a point in the\nsubspace if and only if the vector is in the direction. -/\ntheorem vadd_mem_iff_mem_direction {s : AffineSubspace k P} (v : V) {p : P} (hp : p ∈ s) :\n    «expr +ᵥ » v p ∈ s ↔ v ∈ s.direction :=\n  ⟨fun h => by simpa using vsub_mem_direction h hp, fun h => vadd_mem_of_mem_direction h hp⟩\n#align vadd_mem_iff_mem_direction vadd_mem_iff_mem_direction\n\n",
 "vadd_left_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print vadd_left_mem_affineSpan_pair /-\n/-- A vector added to the first point lies in the affine span of two points if and only if it is\na multiple of their difference. -/\ntheorem vadd_left_mem_affineSpan_pair {p₁ p₂ : P} {v : V} :\n    «expr +ᵥ » v p₁ ∈ «exprline[ , , ]» k p₁ p₂ ↔ ∃ r : k, «expr • » r («expr -ᵥ » p₂ p₁) = v := by\n  rw [vadd_mem_iff_mem_direction _ (left_mem_affineSpan_pair _ _ _), direction_affineSpan, mem_vectorSpan_pair_rev]\n#align vadd_left_mem_affine_span_pair vadd_left_mem_affineSpan_pair\n-/\n\n",
 "trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n@[trans]\ntheorem parallel.trans {s₁ s₂ s₃ : AffineSubspace k P} (h₁₂ : affine_subspace.parallel s₁ s₂)\n    (h₂₃ : affine_subspace.parallel s₂ s₃) : affine_subspace.parallel s₁ s₃ :=\n  by\n  rcases h₁₂ with ⟨v₁₂, rfl⟩\n  rcases h₂₃ with ⟨v₂₃, rfl⟩\n  refine' ⟨v₂₃ + v₁₂, _⟩\n  rw [map_map, ← coe_trans_to_affine_map, ← const_vadd_add]\n#align parallel.trans parallel.trans\n\n",
 "top_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- `⊤`, coerced to a set, is the whole set of points. -/\n@[simp]\ntheorem top_coe : ((«expr⊤» : AffineSubspace k P) : Set P) = Set.univ :=\n  rfl\n#align top_coe top_coe\n\n",
 "symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n@[symm]\ntheorem parallel.symm {s₁ s₂ : AffineSubspace k P} (h : affine_subspace.parallel s₁ s₂) :\n    affine_subspace.parallel s₂ s₁ := by\n  rcases h with ⟨v, rfl⟩\n  refine' ⟨-v, _⟩\n  rw [map_map, ← coe_trans_to_affine_map, ← const_vadd_add, neg_add_self, const_vadd_zero, coe_refl_to_affine_map,\n    map_id]\n#align parallel.symm parallel.symm\n\n",
 "sup_direction_lt_of_nonempty_of_inter_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The sup of the directions of two nonempty affine subspaces with\nempty intersection is less than the direction of their sup. -/\ntheorem sup_direction_lt_of_nonempty_of_inter_empty {s1 s2 : AffineSubspace k P} (h1 : (s1 : Set P).nonempty)\n    (h2 : (s2 : Set P).nonempty) (he : (s1 ∩ s2 : Set P) = ∅) :\n    «expr ⊔ » s1.direction s2.direction < («expr ⊔ » s1 s2).direction :=\n  by\n  cases' h1 with p1 hp1\n  cases' h2 with p2 hp2\n  rw [SetLike.lt_iff_le_and_exists]\n  use sup_direction_le s1 s2, «expr -ᵥ » p2 p1,\n    vsub_mem_direction ((le_sup_right : s2 ≤ «expr ⊔ » s1 s2) hp2) ((le_sup_left : s1 ≤ «expr ⊔ » s1 s2) hp1)\n  intro h\n  rw [Submodule.mem_sup] at h\n  rcases h with ⟨v1, hv1, v2, hv2, hv1v2⟩\n  rw [← sub_eq_zero, sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm v1, add_assoc, ← vadd_vsub_assoc, ← neg_neg v2,\n    add_comm, ← sub_eq_add_neg, ← vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hv1v2\n  refine' Set.Nonempty.ne_empty _ he\n  use «expr +ᵥ » v1 p1, vadd_mem_of_mem_direction hv1 hp1\n  rw [hv1v2]\n  exact vadd_mem_of_mem_direction (Submodule.neg_mem _ hv2) hp2\n#align sup_direction_lt_of_nonempty_of_inter_empty sup_direction_lt_of_nonempty_of_inter_empty\n\n",
 "sup_direction_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The sup of the directions of two affine subspaces is less than or\nequal to the direction of their sup. -/\ntheorem sup_direction_le (s1 s2 : AffineSubspace k P) :\n    «expr ⊔ » s1.direction s2.direction ≤ («expr ⊔ » s1 s2).direction :=\n  by\n  repeat' rw [direction_eq_vector_span, vectorSpan_def]\n  exact\n    sup_le (infₛ_le_infₛ fun p hp => Set.Subset.trans (vsub_self_mono (le_sup_left : s1 ≤ «expr ⊔ » s1 s2)) hp)\n      (infₛ_le_infₛ fun p hp => Set.Subset.trans (vsub_self_mono (le_sup_right : s2 ≤ «expr ⊔ » s1 s2)) hp)\n#align sup_direction_le sup_direction_le\n\n",
 "subtype_linear":
 "@[simp]\ntheorem subtype_linear (s : AffineSubspace k P) [Nonempty s] : s.subtype.linear = s.direction.subtype :=\n  rfl\n#align subtype_linear subtype_linear\n\n",
 "subtype_apply":
 "theorem subtype_apply (s : AffineSubspace k P) [Nonempty s] (p : s) : s.subtype p = p :=\n  rfl\n#align subtype_apply subtype_apply\n\n",
 "subsingleton_of_subsingleton_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subsingleton_of_subsingleton_span_eq_top {s : Set P} (h₁ : s.subsingleton) (h₂ : affineSpan k s = «expr⊤») :\n    subsingleton P := by\n  obtain ⟨p, hp⟩ := AffineSubspace.nonempty_of_affineSpan_eq_top k V P h₂\n  have : s = {p} := subset.antisymm (fun q hq => h₁ hq hp) (by simp [hp])\n  rw [this, ← AffineSubspace.ext_iff, AffineSubspace.coe_affineSpan_singleton, AffineSubspace.top_coe, eq_comm, ←\n    subsingleton_iff_singleton (mem_univ _)] at h₂\n  exact subsingleton_of_univ_subsingleton h₂\n#align subsingleton_of_subsingleton_span_eq_top subsingleton_of_subsingleton_span_eq_top\n\n",
 "subset_spanPoints":
 "#print subset_spanPoints /-\n/-- A set is contained in its `span_points`. -/\ntheorem subset_spanPoints (s : Set P) : s ⊆ spanPoints k s := fun p => mem_spanPoints k p s\n#align subset_span_points subset_spanPoints\n-/\n\n",
 "subset_affineSpan":
 "#print subset_affineSpan /-\n/-- A set is contained in its affine span. -/\ntheorem subset_affineSpan (s : Set P) : s ⊆ affineSpan k s :=\n  subset_spanPoints k s\n#align subset_affine_span subset_affineSpan\n-/\n\n",
 "span_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The span of `univ` is `⊤`. -/\n@[simp]\ntheorem span_univ : affineSpan k (Set.univ : Set P) = «expr⊤» :=\n  eq_top_iff.2 <| subset_spanPoints k _\n#align span_univ span_univ\n\n",
 "span_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- The span of a union of sets is the sup of their spans. -/\ntheorem span_union (s t : Set P) : affineSpan k (s ∪ t) = «expr ⊔ » (affineSpan k s) (affineSpan k t) :=\n  (AffineSubspace.gi k V P).gc.l_sup\n#align span_union span_union\n\n",
 "span_points_subset_coe_of_subset_coe":
 "/-- If an affine subspace contains a set of points, it contains the\n`span_points` of that set. -/\ntheorem span_points_subset_coe_of_subset_coe {s : Set P} {s1 : AffineSubspace k P} (h : s ⊆ s1) : spanPoints k s ⊆ s1 :=\n  by\n  rintro p ⟨p1, hp1, v, hv, hp⟩\n  rw [hp]\n  have hp1s1 : p1 ∈ (s1 : Set P) := Set.mem_of_mem_of_subset hp1 h\n  refine' vadd_mem_of_mem_direction _ hp1s1\n  have hs : vectorSpan k s ≤ s1.direction := vectorSpan_mono k h\n  rw [SetLike.le_def] at hs\n  rw [← SetLike.mem_coe]\n  exact Set.mem_of_mem_of_subset hv hs\n#align span_points_subset_coe_of_subset_coe span_points_subset_coe_of_subset_coe\n\n",
 "span_eq_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem span_eq_top_of_surjective {s : Set P₁} (hf : function.surjective f) (h : affineSpan k s = «expr⊤») :\n    affineSpan k («expr '' » f s) = «expr⊤» := by rw [← AffineSubspace.map_span, h, map_top_of_surjective f hf]\n#align span_eq_top_of_surjective span_eq_top_of_surjective\n\n",
 "span_eq_top_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem span_eq_top_iff {s : Set P₁} (e : «expr ≃ᵃ[ ] » P₁ k P₂) :\n    affineSpan k s = «expr⊤» ↔ affineSpan k («expr '' » e s) = «expr⊤» :=\n  by\n  refine' ⟨(e : «expr →ᵃ[ ] » P₁ k P₂).span_eq_top_of_surjective e.surjective, _⟩\n  intro h\n  have : s = «expr '' » e.symm («expr '' » e s) := by simp [← image_comp]\n  rw [this]\n  exact (e.symm : «expr →ᵃ[ ] » P₂ k P₁).span_eq_top_of_surjective e.symm.surjective h\n#align span_eq_top_iff span_eq_top_iff\n\n",
 "span_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The span of the empty set is `⊥`. -/\n@[simp]\ntheorem span_empty : affineSpan k (∅ : Set P) = «expr⊥» :=\n  (AffineSubspace.gi k V P).gc.l_bot\n#align span_empty span_empty\n\n",
 "span_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The span of a union of an indexed family of sets is the sup of\ntheir spans. -/\ntheorem span_Union {ι : Type _} (s : ι → Set P) :\n    affineSpan k\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (affineSpan k (s i)) :=\n  (AffineSubspace.gi k V P).gc.l_supr\n#align span_Union span_Union\n\n",
 "spanPoints_nonempty":
 "#print spanPoints_nonempty /-\n/-- The `span_points` of a set is nonempty if and only if that set\nis. -/\n@[simp]\ntheorem spanPoints_nonempty (s : Set P) : (spanPoints k s).nonempty ↔ s.nonempty :=\n  by\n  constructor\n  · contrapose\n    rw [Set.not_nonempty_iff_eq_empty, Set.not_nonempty_iff_eq_empty]\n    intro h\n    simp [h, spanPoints]\n  · exact fun h => h.mono (subset_spanPoints _ _)\n#align span_points_nonempty spanPoints_nonempty\n-/\n\n",
 "smul_vsub_vadd_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print smul_vsub_vadd_mem_affineSpan_pair /-\n/-- A multiple of the difference of two points added to the first point lies in their affine\nspan. -/\ntheorem smul_vsub_vadd_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    «expr +ᵥ » («expr • » r («expr -ᵥ » p₂ p₁)) p₁ ∈ «exprline[ , , ]» k p₁ p₂ :=\n  AffineMap.lineMap_mem_affineSpan_pair _ _ _\n#align smul_vsub_vadd_mem_affine_span_pair smul_vsub_vadd_mem_affineSpan_pair\n-/\n\n",
 "smul_vsub_rev_vadd_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print smul_vsub_rev_vadd_mem_affineSpan_pair /-\n/-- A multiple of the difference of two points added to the second point lies in their affine\nspan. -/\ntheorem smul_vsub_rev_vadd_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    «expr +ᵥ » («expr • » r («expr -ᵥ » p₁ p₂)) p₂ ∈ «exprline[ , , ]» k p₁ p₂ :=\n  AffineMap.lineMap_rev_mem_affineSpan_pair _ _ _\n#align smul_vsub_rev_vadd_mem_affine_span_pair smul_vsub_rev_vadd_mem_affineSpan_pair\n-/\n\n",
 "smul_vsub_rev_mem_vectorSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print smul_vsub_rev_mem_vectorSpan_pair /-\n/-- A multiple of the difference between two points (reversed) lies in their `vector_span`. -/\ntheorem smul_vsub_rev_mem_vectorSpan_pair (r : k) (p₁ p₂ : P) :\n    «expr • » r («expr -ᵥ » p₂ p₁) ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  Submodule.smul_mem _ _ (vsub_rev_mem_vectorSpan_pair k p₁ p₂)\n#align smul_vsub_rev_mem_vector_span_pair smul_vsub_rev_mem_vectorSpan_pair\n-/\n\n",
 "smul_vsub_mem_vectorSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print smul_vsub_mem_vectorSpan_pair /-\n/-- A multiple of the difference between two points lies in their `vector_span`. -/\ntheorem smul_vsub_mem_vectorSpan_pair (r : k) (p₁ p₂ : P) :\n    «expr • » r («expr -ᵥ » p₁ p₂) ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  Submodule.smul_mem _ _ (vsub_mem_vectorSpan_pair k p₁ p₂)\n#align smul_vsub_mem_vector_span_pair smul_vsub_mem_vectorSpan_pair\n-/\n\n",
 "self_mem_mk'":
 "/-- An affine subspace constructed from a point and a direction contains\nthat point. -/\ntheorem self_mem_mk' (p : P) (direction : Submodule k V) : p ∈ mk' p direction :=\n  ⟨0, ⟨direction.zero_mem, (zero_vadd _ _).symm⟩⟩\n#align self_mem_mk' self_mem_mk'\n\n",
 "right_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print right_mem_affineSpan_pair /-\n/-- The second of two points lies in their affine span. -/\ntheorem right_mem_affineSpan_pair (p₁ p₂ : P) : p₂ ∈ «exprline[ , , ]» k p₁ p₂ :=\n  mem_affineSpan _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n#align right_mem_affine_span_pair right_mem_affineSpan_pair\n-/\n\n",
 "refl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n@[refl]\ntheorem parallel.refl (s : AffineSubspace k P) : affine_subspace.parallel s s :=\n  ⟨0, by simp⟩\n#align parallel.refl parallel.refl\n\n",
 "preimage_coe_affine_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem preimage_coe_affine_span_singleton (x : P) : «expr ⁻¹' » (coe : affineSpan k ({x} : Set P) → P) {x} = univ :=\n  eq_univ_of_forall fun y => (AffineSubspace.mem_affineSpan_singleton _ _).1 y.2\n#align preimage_coe_affine_span_singleton preimage_coe_affine_span_singleton\n\n",
 "parallel_iff_direction_eq_and_eq_bot_iff_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s₁ s₂ : AffineSubspace k P} :\n    affine_subspace.parallel s₁ s₂ ↔ s₁.direction = s₂.direction ∧ (s₁ = «expr⊥» ↔ s₂ = «expr⊥») :=\n  by\n  refine' ⟨fun h => ⟨h.direction_eq, _, _⟩, fun h => _⟩\n  · rintro rfl\n    exact bot_parallel_iff_eq_bot.1 h\n  · rintro rfl\n    exact parallel_bot_iff_eq_bot.1 h\n  · rcases h with ⟨hd, hb⟩\n    by_cases hs₁ : s₁ = «expr⊥»\n    · rw [hs₁, bot_parallel_iff_eq_bot]\n      exact hb.1 hs₁\n    · have hs₂ : s₂ ≠ «expr⊥» := hb.not.1 hs₁\n      rcases(nonempty_iff_ne_bot s₁).2 hs₁ with ⟨p₁, hp₁⟩\n      rcases(nonempty_iff_ne_bot s₂).2 hs₂ with ⟨p₂, hp₂⟩\n      refine' ⟨«expr -ᵥ » p₂ p₁, (eq_iff_direction_eq_of_mem hp₂ _).2 _⟩\n      · rw [mem_map]\n        refine' ⟨p₁, hp₁, _⟩\n        simp\n      · simpa using hd.symm\n#align parallel_iff_direction_eq_and_eq_bot_iff_eq_bot parallel_iff_direction_eq_and_eq_bot_iff_eq_bot\n\n",
 "parallel_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\ntheorem parallel_comm {s₁ s₂ : AffineSubspace k P} : affine_subspace.parallel s₁ s₂ ↔ affine_subspace.parallel s₂ s₁ :=\n  ⟨Parallel.symm, Parallel.symm⟩\n#align parallel_comm parallel_comm\n\n",
 "parallel_bot_iff_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem parallel_bot_iff_eq_bot {s : AffineSubspace k P} : affine_subspace.parallel s («expr⊥») ↔ s = «expr⊥» :=\n  by\n  refine' ⟨fun h => _, fun h => h ▸ parallel.refl _⟩\n  rcases h with ⟨v, h⟩\n  rwa [eq_comm, map_eq_bot_iff] at h\n#align parallel_bot_iff_eq_bot parallel_bot_iff_eq_bot\n\n",
 "not_mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- No points are in `⊥`. -/\ntheorem not_mem_bot (p : P) : p ∉ («expr⊥» : AffineSubspace k P) :=\n  Set.not_mem_empty p\n#align not_mem_bot not_mem_bot\n\n",
 "not_le_iff_exists":
 "/-- One subspace is not less than or equal to another if and only if\nit has a point not in the second subspace. -/\ntheorem not_le_iff_exists (s1 s2 : AffineSubspace k P) : ¬s1 ≤ s2 ↔ ∃ p ∈ s1, p ∉ s2 :=\n  Set.not_subset\n#align not_le_iff_exists not_le_iff_exists\n\n",
 "nonempty_of_affine_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem nonempty_of_affine_span_eq_top {s : Set P} (h : affineSpan k s = «expr⊤») : s.nonempty :=\n  by\n  rw [Set.nonempty_iff_ne_empty]\n  rintro rfl\n  rw [AffineSubspace.span_empty] at h\n  exact bot_ne_top k V P h\n#align nonempty_of_affine_span_eq_top nonempty_of_affine_span_eq_top\n\n",
 "nonempty_iff_ne_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nonempty_iff_ne_bot (Q : AffineSubspace k P) : (Q : Set P).nonempty ↔ Q ≠ «expr⊥» :=\n  by\n  rw [nonempty_iff_ne_empty]\n  exact not_congr Q.coe_eq_bot_iff\n#align nonempty_iff_ne_bot nonempty_iff_ne_bot\n\n",
 "mk'_nonempty":
 "/-- An affine subspace constructed from a point and a direction is\nnonempty. -/\ntheorem mk'_nonempty (p : P) (direction : Submodule k V) : (mk' p direction : Set P).nonempty :=\n  ⟨p, self_mem_mk' p direction⟩\n#align mk'_nonempty mk'_nonempty\n\n",
 "mk'_eq":
 "/-- Constructing an affine subspace from a point in a subspace and\nthat subspace's direction yields the original subspace. -/\n@[simp]\ntheorem mk'_eq {s : AffineSubspace k P} {p : P} (hp : p ∈ s) : mk' p s.direction = s :=\n  ext_of_direction_eq (direction_mk' p s.direction) ⟨p, Set.mem_inter (self_mem_mk' _ _) hp⟩\n#align mk'_eq mk'_eq\n\n",
 "mem_vectorSpan_pair_rev":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print mem_vectorSpan_pair_rev /-\n/-- A vector lies in the `vector_span` of two points if and only if it is a multiple of their\ndifference (reversed). -/\ntheorem mem_vectorSpan_pair_rev {p₁ p₂ : P} {v : V} :\n    v ∈ vectorSpan k ({p₁, p₂} : Set P) ↔ ∃ r : k, «expr • » r («expr -ᵥ » p₂ p₁) = v := by\n  rw [vectorSpan_pair_rev, Submodule.mem_span_singleton]\n#align mem_vector_span_pair_rev mem_vectorSpan_pair_rev\n-/\n\n",
 "mem_vectorSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print mem_vectorSpan_pair /-\n/-- A vector lies in the `vector_span` of two points if and only if it is a multiple of their\ndifference. -/\ntheorem mem_vectorSpan_pair {p₁ p₂ : P} {v : V} :\n    v ∈ vectorSpan k ({p₁, p₂} : Set P) ↔ ∃ r : k, «expr • » r («expr -ᵥ » p₁ p₂) = v := by\n  rw [vectorSpan_pair, Submodule.mem_span_singleton]\n#align mem_vector_span_pair mem_vectorSpan_pair\n-/\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- All points are in `⊤`. -/\ntheorem mem_top (p : P) : p ∈ («expr⊤» : AffineSubspace k P) :=\n  Set.mem_univ p\n#align mem_top mem_top\n\n",
 "mem_spanPoints":
 "#print mem_spanPoints /-\n/-- A point in a set is in its affine span. -/\ntheorem mem_spanPoints (p : P) (s : Set P) : p ∈ s → p ∈ spanPoints k s\n  | hp => ⟨p, hp, 0, Submodule.zero_mem _, (zero_vadd V p).symm⟩\n#align mem_span_points mem_spanPoints\n-/\n\n",
 "mem_mk'_iff_vsub_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- A point lies in an affine subspace constructed from another point and a direction if and only\nif their difference is in that direction. -/\ntheorem mem_mk'_iff_vsub_mem {p₁ p₂ : P} {direction : Submodule k V} :\n    p₂ ∈ mk' p₁ direction ↔ «expr -ᵥ » p₂ p₁ ∈ direction :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rw [← direction_mk' p₁ direction]\n    exact vsub_mem_direction h (self_mem_mk' _ _)\n  · rw [← vsub_vadd p₂ p₁]\n    exact vadd_mem_mk' p₁ h\n#align mem_mk'_iff_vsub_mem mem_mk'_iff_vsub_mem\n\n",
 "mem_map_of_mem":
 "theorem mem_map_of_mem {x : P₁} {s : AffineSubspace k P₁} (h : x ∈ s) : f x ∈ s.map f :=\n  Set.mem_image_of_mem _ h\n#align mem_map_of_mem mem_map_of_mem\n\n",
 "mem_map_iff_mem_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem mem_map_iff_mem_of_injective {f : «expr →ᵃ[ ] » P₁ k P₂} {x : P₁} {s : AffineSubspace k P₁}\n    (hf : function.injective f) : f x ∈ s.map f ↔ x ∈ s :=\n  hf.mem_set_image\n#align mem_map_iff_mem_of_injective mem_map_iff_mem_of_injective\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n@[simp]\ntheorem mem_map {f : «expr →ᵃ[ ] » P₁ k P₂} {x : P₂} {s : AffineSubspace k P₁} : x ∈ s.map f ↔ ∃ y ∈ s, f y = x :=\n  mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_inf_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- A point is in the inf of two affine subspaces if and only if it is\nin both of them. -/\ntheorem mem_inf_iff (p : P) (s1 s2 : AffineSubspace k P) : p ∈ «expr ⊓ » s1 s2 ↔ p ∈ s1 ∧ p ∈ s2 :=\n  iff.rfl\n#align mem_inf_iff mem_inf_iff\n\n",
 "mem_direction_iff_eq_vsub_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point in an affine subspace, a vector is in its direction\nif and only if it results from subtracting that point on the right. -/\ntheorem mem_direction_iff_eq_vsub_right {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) :\n    v ∈ s.direction ↔ ∃ p2 ∈ s, v = «expr -ᵥ » p2 p :=\n  by\n  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_right hp]\n  exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩\n#align mem_direction_iff_eq_vsub_right mem_direction_iff_eq_vsub_right\n\n",
 "mem_direction_iff_eq_vsub_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point in an affine subspace, a vector is in its direction\nif and only if it results from subtracting that point on the left. -/\ntheorem mem_direction_iff_eq_vsub_left {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) :\n    v ∈ s.direction ↔ ∃ p2 ∈ s, v = «expr -ᵥ » p p2 :=\n  by\n  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_left hp]\n  exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩\n#align mem_direction_iff_eq_vsub_left mem_direction_iff_eq_vsub_left\n\n",
 "mem_direction_iff_eq_vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- A vector is in the direction of a nonempty affine subspace if and\nonly if it is the subtraction of two vectors in the subspace. -/\ntheorem mem_direction_iff_eq_vsub {s : AffineSubspace k P} (h : (s : Set P).nonempty) (v : V) :\n    v ∈ s.direction ↔ ∃ p1 ∈ s, ∃ p2 ∈ s, v = «expr -ᵥ » p1 p2 :=\n  by\n  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set h]\n  exact\n    ⟨fun ⟨p1, p2, hp1, hp2, hv⟩ => ⟨p1, hp1, p2, hp2, hv.symm⟩, fun ⟨p1, hp1, p2, hp2, hv⟩ =>\n      ⟨p1, p2, hp1, hp2, hv.symm⟩⟩\n#align mem_direction_iff_eq_vsub mem_direction_iff_eq_vsub\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n@[simp]\ntheorem mem_comap {f : «expr →ᵃ[ ] » P₁ k P₂} {x : P₁} {s : AffineSubspace k P₂} : x ∈ s.comap f ↔ f x ∈ s :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_coe":
 "/-- A point is in an affine subspace coerced to a set if and only if\nit is in that affine subspace. -/\n@[simp]\ntheorem mem_coe (p : P) (s : AffineSubspace k P) : p ∈ (s : Set P) ↔ p ∈ s :=\n  iff.rfl\n#align mem_coe mem_coe\n\n",
 "mem_affine_span_singleton":
 "/-- A point is in the affine span of a single point if and only if\nthey are equal. -/\n@[simp]\ntheorem mem_affine_span_singleton : p₁ ∈ affineSpan k ({p₂} : Set P) ↔ p₁ = p₂ := by simp [← mem_coe]\n#align mem_affine_span_singleton mem_affine_span_singleton\n\n",
 "mem_affine_span_insert_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- Given a point `p1` in an affine subspace `s`, and a point `p2`, a\npoint `p` is in the span of `s` with `p2` added if and only if it is a\nmultiple of `p2 -ᵥ p1` added to a point in `s`. -/\ntheorem mem_affine_span_insert_iff {s : AffineSubspace k P} {p1 : P} (hp1 : p1 ∈ s) (p2 p : P) :\n    p ∈ affineSpan k (insert p2 (s : Set P)) ↔\n      ∃ (r : k)(p0 : P)(hp0 : p0 ∈ s), p = «expr +ᵥ » («expr • » r («expr -ᵥ » p2 p1 : V)) p0 :=\n  by\n  rw [← mem_coe] at hp1\n  rw [← vsub_right_mem_direction_iff_mem (mem_affineSpan k (Set.mem_insert_of_mem _ hp1)),\n    direction_affine_span_insert hp1, Submodule.mem_sup]\n  constructor\n  · rintro ⟨v1, hv1, v2, hv2, hp⟩\n    rw [Submodule.mem_span_singleton] at hv1\n    rcases hv1 with ⟨r, rfl⟩\n    use r, «expr +ᵥ » v2 p1, vadd_mem_of_mem_direction hv2 hp1\n    symm at hp\n    rw [← sub_eq_zero, ← vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp\n    rw [hp, vadd_vadd]\n  · rintro ⟨r, p3, hp3, rfl⟩\n    use «expr • » r («expr -ᵥ » p2 p1), Submodule.mem_span_singleton.2 ⟨r, rfl⟩, «expr -ᵥ » p3 p1,\n      vsub_mem_direction hp3 hp1\n    rw [vadd_vsub_assoc, add_comm]\n#align mem_affine_span_insert_iff mem_affine_span_insert_iff\n\n",
 "mem_affineSpan":
 "#print mem_affineSpan /-\n/-- A point in a set is in its affine span. -/\ntheorem mem_affineSpan {p : P} {s : Set P} (hp : p ∈ s) : p ∈ affineSpan k s :=\n  mem_spanPoints k p s hp\n#align mem_affine_span mem_affineSpan\n-/\n\n",
 "map_top_of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem map_top_of_surjective (hf : function.surjective f) : AffineSubspace.map f («expr⊤») = «expr⊤» :=\n  by\n  rw [← AffineSubspace.ext_iff]\n  exact image_univ_of_surjective hf\n#align map_top_of_surjective map_top_of_surjective\n\n",
 "map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n@[simp]\ntheorem map_symm (e : «expr ≃ᵃ[ ] » P₁ k P₂) (s : AffineSubspace k P₂) :\n    s.map (e.symm : «expr →ᵃ[ ] » P₂ k P₁) = s.comap e :=\n  coe_injective <| e.image_symm _\n#align map_symm map_symm\n\n",
 "map_supᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print map_supᵢ /-\ntheorem map_supᵢ {ι : Sort _} (f : «expr →ᵃ[ ] » P₁ k P₂) (s : ι → AffineSubspace k P₁) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f).l_supr\n#align map_supr map_supᵢ\n-/\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (s t : AffineSubspace k P₁) (f : «expr →ᵃ[ ] » P₁ k P₂) :\n    («expr ⊔ » s t).map f = «expr ⊔ » (s.map f) (t.map f) :=\n  (gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem map_span (s : Set P₁) : (affineSpan k s).map f = affineSpan k («expr '' » f s) :=\n  by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨p, hp⟩); · simp\n  apply ext_of_direction_eq\n  · simp [direction_affineSpan]\n  · exact ⟨f p, mem_image_of_mem f (subset_affineSpan k _ hp), subset_affineSpan k _ (mem_image_of_mem f hp)⟩\n#align map_span map_span\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem map_map (s : AffineSubspace k P₁) (f : «expr →ᵃ[ ] » P₁ k P₂) (g : «expr →ᵃ[ ] » P₂ k P₃) :\n    (s.map f).map g = s.map (g.comp f) :=\n  coe_injective <| image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n-- lemmas about map and comap derived from the galois connection\ntheorem map_le_iff_le_comap {f : «expr →ᵃ[ ] » P₁ k P₂} {s : AffineSubspace k P₁} {t : AffineSubspace k P₂} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_id":
 "@[simp]\ntheorem map_id (s : AffineSubspace k P₁) : s.map (AffineMap.id k P₁) = s :=\n  coe_injective <| image_id _\n#align map_id map_id\n\n",
 "map_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print map_eq_bot_iff /-\n@[simp]\ntheorem map_eq_bot_iff {s : AffineSubspace k P₁} : s.map f = «expr⊥» ↔ s = «expr⊥» :=\n  by\n  refine' ⟨fun h => _, fun h => _⟩\n  · rwa [← coe_eq_bot_iff, coe_map, image_eq_empty, coe_eq_bot_iff] at h\n  · rw [h, map_bot]\n#align map_eq_bot_iff map_eq_bot_iff\n-/\n\n",
 "map_direction":
 "@[simp]\ntheorem map_direction (s : AffineSubspace k P₁) : (s.map f).direction = s.direction.map f.linear := by\n  simp [direction_eq_vector_span]\n#align map_direction map_direction\n\n",
 "map_comap_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem map_comap_le (f : «expr →ᵃ[ ] » P₁ k P₂) (s : AffineSubspace k P₂) : (s.comap f).map f ≤ s :=\n  (gc_map_comap f).l_u_le _\n#align map_comap_le map_comap_le\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot : («expr⊥» : AffineSubspace k P₁).map f = «expr⊥» :=\n  coe_injective <| image_empty f\n#align map_bot map_bot\n\n",
 "lt_iff_le_and_exists":
 "/-- A subspace is less than another if and only if it is less than or\nequal to the second subspace and there is a point only in the\nsecond. -/\ntheorem lt_iff_le_and_exists (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ s1 ≤ s2 ∧ ∃ p ∈ s2, p ∉ s1 := by\n  rw [lt_iff_le_not_le, not_le_iff_exists]\n#align lt_iff_le_and_exists lt_iff_le_and_exists\n\n",
 "lt_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊂ » -/\n/-- The `<` order on subspaces is the same as that on the corresponding\nsets. -/\ntheorem lt_def (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ «expr ⊂ » (s1 : Set P) s2 :=\n  iff.rfl\n#align lt_def lt_def\n\n",
 "lineMap_rev_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print AffineMap.lineMap_rev_mem_affineSpan_pair /-\n/-- A combination of two points expressed with `line_map` (with the two points reversed) lies in\ntheir affine span. -/\ntheorem AffineMap.lineMap_rev_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    AffineMap.lineMap p₂ p₁ r ∈ «exprline[ , , ]» k p₁ p₂ :=\n  AffineMap.lineMap_mem _ (right_mem_affineSpan_pair _ _ _) (left_mem_affineSpan_pair _ _ _)\n#align affine_map.line_map_rev_mem_affine_span_pair AffineMap.lineMap_rev_mem_affineSpan_pair\n-/\n\n",
 "lineMap_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print AffineMap.lineMap_mem_affineSpan_pair /-\n/-- A combination of two points expressed with `line_map` lies in their affine span. -/\ntheorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    AffineMap.lineMap p₁ p₂ r ∈ «exprline[ , , ]» k p₁ p₂ :=\n  AffineMap.lineMap_mem _ (left_mem_affineSpan_pair _ _ _) (right_mem_affineSpan_pair _ _ _)\n#align affine_map.line_map_mem_affine_span_pair AffineMap.lineMap_mem_affineSpan_pair\n-/\n\n",
 "lineMap_mem":
 "#print AffineMap.lineMap_mem /-\ntheorem AffineMap.lineMap_mem {k V P : Type _} [Ring k] [AddCommGroup V] [Module k V] [AddTorsor V P]\n    {Q : AffineSubspace k P} {p₀ p₁ : P} (c : k) (h₀ : p₀ ∈ Q) (h₁ : p₁ ∈ Q) : AffineMap.lineMap p₀ p₁ c ∈ Q :=\n  by\n  rw [AffineMap.lineMap_apply]\n  exact Q.smul_vsub_vadd_mem c h₁ h₀ h₀\n#align affine_map.line_map_mem AffineMap.lineMap_mem\n-/\n\n",
 "left_mem_affineSpan_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print left_mem_affineSpan_pair /-\n/-- The first of two points lies in their affine span. -/\ntheorem left_mem_affineSpan_pair (p₁ p₂ : P) : p₁ ∈ «exprline[ , , ]» k p₁ p₂ :=\n  mem_affineSpan _ (Set.mem_insert _ _)\n#align left_mem_affine_span_pair left_mem_affineSpan_pair\n-/\n\n",
 "le_def'":
 "/-- One subspace is less than or equal to another if and only if all\nits points are in the second subspace. -/\ntheorem le_def' (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ ∀ p ∈ s1, p ∈ s2 :=\n  iff.rfl\n#align le_def' le_def'\n\n",
 "le_def":
 "/-- The `≤` order on subspaces is the same as that on the corresponding\nsets. -/\ntheorem le_def (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ (s1 : Set P) ⊆ s2 :=\n  iff.rfl\n#align le_def le_def\n\n",
 "le_comap_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem le_comap_map (f : «expr →ᵃ[ ] » P₁ k P₂) (s : AffineSubspace k P₁) : s ≤ (s.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n#align le_comap_map le_comap_map\n\n",
 "inter_nonempty_of_nonempty_of_sup_direction_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If the directions of two nonempty affine subspaces span the whole\nmodule, they have nonempty intersection. -/\ntheorem inter_nonempty_of_nonempty_of_sup_direction_eq_top {s1 s2 : AffineSubspace k P} (h1 : (s1 : Set P).nonempty)\n    (h2 : (s2 : Set P).nonempty) (hd : «expr ⊔ » s1.direction s2.direction = «expr⊤») : ((s1 : Set P) ∩ s2).nonempty :=\n  by\n  by_contra h\n  rw [Set.not_nonempty_iff_eq_empty] at h\n  have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h\n  rw [hd] at hlt\n  exact not_top_lt hlt\n#align inter_nonempty_of_nonempty_of_sup_direction_eq_top inter_nonempty_of_nonempty_of_sup_direction_eq_top\n\n",
 "inter_eq_singleton_of_nonempty_of_is_compl":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- If the directions of two nonempty affine subspaces are complements\nof each other, they intersect in exactly one point. -/\ntheorem inter_eq_singleton_of_nonempty_of_is_compl {s1 s2 : AffineSubspace k P} (h1 : (s1 : Set P).nonempty)\n    (h2 : (s2 : Set P).nonempty) (hd : IsCompl s1.direction s2.direction) : ∃ p, (s1 : Set P) ∩ s2 = {p} :=\n  by\n  cases' inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp\n  use p\n  ext q\n  rw [Set.mem_singleton_iff]\n  constructor\n  · rintro ⟨hq1, hq2⟩\n    have hqp : «expr -ᵥ » q p ∈ «expr ⊓ » s1.direction s2.direction :=\n      ⟨vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2⟩\n    rwa [hd.inf_eq_bot, Submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp\n  · exact fun h => h.symm ▸ hp\n#align inter_eq_singleton_of_nonempty_of_is_compl inter_eq_singleton_of_nonempty_of_is_compl\n\n",
 "injective_subtype":
 "theorem injective_subtype (s : AffineSubspace k P) [Nonempty s] : function.injective s.subtype :=\n  Subtype.coe_injective\n#align injective_subtype injective_subtype\n\n",
 "inf_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- The inf of two affine subspaces, coerced to a set, is the\nintersection of the two sets of points. -/\n@[simp]\ntheorem inf_coe (s1 s2 : AffineSubspace k P) : («expr ⊓ » s1 s2 : Set P) = s1 ∩ s2 :=\n  rfl\n#align inf_coe inf_coe\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem gc_map_comap (f : «expr →ᵃ[ ] » P₁ k P₂) : GaloisConnection (map f) (comap f) := fun _ _ => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "ext_of_direction_eq":
 "/-- Two affine subspaces with the same direction and nonempty\nintersection are equal. -/\ntheorem ext_of_direction_eq {s1 s2 : AffineSubspace k P} (hd : s1.direction = s2.direction)\n    (hn : ((s1 : Set P) ∩ s2).nonempty) : s1 = s2 := by\n  ext p\n  have hq1 := Set.mem_of_mem_inter_left hn.some_mem\n  have hq2 := Set.mem_of_mem_inter_right hn.some_mem\n  constructor\n  · intro hp\n    rw [← vsub_vadd p hn.some]\n    refine' vadd_mem_of_mem_direction _ hq2\n    rw [← hd]\n    exact vsub_mem_direction hp hq1\n  · intro hp\n    rw [← vsub_vadd p hn.some]\n    refine' vadd_mem_of_mem_direction _ hq1\n    rw [hd]\n    exact vsub_mem_direction hp hq2\n#align ext_of_direction_eq ext_of_direction_eq\n\n",
 "ext_iff":
 "@[simp]\ntheorem ext_iff (s₁ s₂ : AffineSubspace k P) : (s₁ : Set P) = s₂ ↔ s₁ = s₂ :=\n  SetLike.ext'_iff.symm\n#align ext_iff ext_iff\n\n",
 "ext":
 "@[ext]\ntheorem ext {p q : AffineSubspace k P} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n#align ext ext\n\n",
 "exists_of_lt":
 "/-- If a subspace is less than another, there is a point only in the\nsecond. -/\ntheorem exists_of_lt {s1 s2 : AffineSubspace k P} (h : s1 < s2) : ∃ p ∈ s2, p ∉ s1 :=\n  Set.exists_of_ssubset h\n#align exists_of_lt exists_of_lt\n\n",
 "eq_univ_of_subsingleton_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_univ_of_subsingleton_span_eq_top {s : Set P} (h₁ : s.subsingleton) (h₂ : affineSpan k s = «expr⊤») :\n    s = (univ : Set P) :=\n  by\n  obtain ⟨p, hp⟩ := AffineSubspace.nonempty_of_affineSpan_eq_top k V P h₂\n  have : s = {p} := subset.antisymm (fun q hq => h₁ hq hp) (by simp [hp])\n  rw [this, eq_comm, ← subsingleton_iff_singleton (mem_univ p), subsingleton_univ_iff]\n  exact subsingleton_of_subsingleton_span_eq_top h₁ h₂\n#align eq_univ_of_subsingleton_span_eq_top eq_univ_of_subsingleton_span_eq_top\n\n",
 "eq_of_direction_eq_of_nonempty_of_le":
 "/-- If an affine subspace is nonempty and contained in another with\nthe same direction, they are equal. -/\ntheorem eq_of_direction_eq_of_nonempty_of_le {s₁ s₂ : AffineSubspace k P} (hd : s₁.direction = s₂.direction)\n    (hn : (s₁ : Set P).nonempty) (hle : s₁ ≤ s₂) : s₁ = s₂ :=\n  let ⟨p, hp⟩ := hn\n  ext_of_direction_eq hd ⟨p, hp, hle hp⟩\n#align eq_of_direction_eq_of_nonempty_of_le eq_of_direction_eq_of_nonempty_of_le\n\n",
 "eq_iff_direction_eq_of_mem":
 "/-- Two affine subspaces with nonempty intersection are equal if and\nonly if their directions are equal. -/\ntheorem eq_iff_direction_eq_of_mem {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :\n    s₁ = s₂ ↔ s₁.direction = s₂.direction :=\n  ⟨fun h => h ▸ rfl, fun h => ext_of_direction_eq h ⟨p, h₁, h₂⟩⟩\n#align eq_iff_direction_eq_of_mem eq_iff_direction_eq_of_mem\n\n",
 "eq_bot_or_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem eq_bot_or_nonempty (Q : AffineSubspace k P) : Q = «expr⊥» ∨ (Q : Set P).nonempty :=\n  by\n  rw [nonempty_iff_ne_bot]\n  apply eq_or_ne\n#align eq_bot_or_nonempty eq_bot_or_nonempty\n\n",
 "direction_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- The direction of `⊤` is the whole module as a submodule. -/\n@[simp]\ntheorem direction_top : («expr⊤» : AffineSubspace k P).direction = «expr⊤» :=\n  by\n  cases' S.nonempty with p\n  ext v\n  refine' ⟨imp_intro Submodule.mem_top, fun hv => _⟩\n  have hpv : («expr -ᵥ » («expr +ᵥ » v p) p : V) ∈ («expr⊤» : AffineSubspace k P).direction :=\n    vsub_mem_direction (mem_top k V _) (mem_top k V _)\n  rwa [vadd_vsub] at hpv\n#align direction_top direction_top\n\n",
 "direction_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The direction of the sup of two nonempty affine subspaces is the\nsup of the two directions and of any one difference between points in\nthe two subspaces. -/\ntheorem direction_sup {s1 s2 : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s1) (hp2 : p2 ∈ s2) :\n    («expr ⊔ » s1 s2).direction = «expr ⊔ » («expr ⊔ » s1.direction s2.direction) («expr ∙ » k («expr -ᵥ » p2 p1)) :=\n  by\n  refine' le_antisymm _ _\n  · change (affineSpan k ((s1 : Set P) ∪ s2)).direction ≤ _\n    rw [← mem_coe] at hp1\n    rw [direction_affineSpan, vectorSpan_eq_span_vsub_set_right k (Set.mem_union_left _ hp1), Submodule.span_le]\n    rintro v ⟨p3, hp3, rfl⟩\n    cases hp3\n    · rw [sup_assoc, sup_comm, SetLike.mem_coe, Submodule.mem_sup]\n      use 0, Submodule.zero_mem _, «expr -ᵥ » p3 p1, vsub_mem_direction hp3 hp1\n      rw [zero_add]\n    · rw [sup_assoc, SetLike.mem_coe, Submodule.mem_sup]\n      use 0, Submodule.zero_mem _, «expr -ᵥ » p3 p1\n      rw [and_comm', zero_add]\n      use rfl\n      rw [← vsub_add_vsub_cancel p3 p2 p1, Submodule.mem_sup]\n      use «expr -ᵥ » p3 p2, vsub_mem_direction hp3 hp2, «expr -ᵥ » p2 p1, Submodule.mem_span_singleton_self _\n  · refine' sup_le (sup_direction_le _ _) _\n    rw [direction_eq_vector_span, vectorSpan_def]\n    exact\n      infₛ_le_infₛ fun p hp =>\n        Set.Subset.trans\n          (Set.singleton_subset_iff.2\n            (vsub_mem_vsub (mem_spanPoints k p2 _ (Set.mem_union_right _ hp2))\n              (mem_spanPoints k p1 _ (Set.mem_union_left _ hp1))))\n          hp\n#align direction_sup direction_sup\n\n",
 "direction_of_nonempty_eq_direction":
 "/-- `direction_of_nonempty` gives the same submodule as\n`direction`. -/\ntheorem direction_of_nonempty_eq_direction {s : AffineSubspace k P} (h : (s : Set P).nonempty) :\n    directionOfNonempty h = s.direction :=\n  le_antisymm (vsub_set_subset_vectorSpan k s) (Submodule.span_le.2 Set.Subset.rfl)\n#align direction_of_nonempty_eq_direction direction_of_nonempty_eq_direction\n\n",
 "direction_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/-- The direction of an affine subspace constructed from a point and a\ndirection. -/\n@[simp]\ntheorem direction_mk' (p : P) (direction : Submodule k V) : (mk' p direction).direction = direction :=\n  by\n  ext v\n  rw [mem_direction_iff_eq_vsub (mk'_nonempty _ _)]\n  constructor\n  · rintro ⟨p1, ⟨v1, hv1, hp1⟩, p2, ⟨v2, hv2, hp2⟩, hv⟩\n    rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right]\n    exact direction.sub_mem hv1 hv2\n  · exact fun hv => ⟨«expr +ᵥ » v p, vadd_mem_mk' _ hv, p, self_mem_mk' _ _, (vadd_vsub _ _).symm⟩\n#align direction_mk' direction_mk'\n\n",
 "direction_lt_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- If one nonempty affine subspace is less than another, the same\napplies to their directions -/\ntheorem direction_lt_of_nonempty {s1 s2 : AffineSubspace k P} (h : s1 < s2) (hn : (s1 : Set P).nonempty) :\n    s1.direction < s2.direction := by\n  cases' hn with p hp\n  rw [lt_iff_le_and_exists] at h\n  rcases h with ⟨hle, p2, hp2, hp2s1⟩\n  rw [SetLike.lt_iff_le_and_exists]\n  use direction_le hle, «expr -ᵥ » p2 p, vsub_mem_direction hp2 (hle hp)\n  intro hm\n  rw [vsub_right_mem_direction_iff_mem hp p2] at hm\n  exact hp2s1 hm\n#align direction_lt_of_nonempty direction_lt_of_nonempty\n\n",
 "direction_le":
 "/-- If one affine subspace is less than or equal to another, the same\napplies to their directions. -/\ntheorem direction_le {s1 s2 : AffineSubspace k P} (h : s1 ≤ s2) : s1.direction ≤ s2.direction :=\n  by\n  repeat' rw [direction_eq_vector_span, vectorSpan_def]\n  exact vectorSpan_mono k h\n#align direction_le direction_le\n\n",
 "direction_inf_of_mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- If two affine subspaces have a point in their inf, the direction\nof their inf equals the inf of their directions. -/\ntheorem direction_inf_of_mem_inf {s₁ s₂ : AffineSubspace k P} {p : P} (h : p ∈ «expr ⊓ » s₁ s₂) :\n    («expr ⊓ » s₁ s₂).direction = «expr ⊓ » s₁.direction s₂.direction :=\n  direction_inf_of_mem ((mem_inf_iff p s₁ s₂).1 h).1 ((mem_inf_iff p s₁ s₂).1 h).2\n#align direction_inf_of_mem_inf direction_inf_of_mem_inf\n\n",
 "direction_inf_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- If two affine subspaces have a point in common, the direction of\ntheir inf equals the inf of their directions. -/\ntheorem direction_inf_of_mem {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :\n    («expr ⊓ » s₁ s₂).direction = «expr ⊓ » s₁.direction s₂.direction :=\n  by\n  ext v\n  rw [Submodule.mem_inf, ← vadd_mem_iff_mem_direction v h₁, ← vadd_mem_iff_mem_direction v h₂, ←\n    vadd_mem_iff_mem_direction v ((mem_inf_iff p s₁ s₂).2 ⟨h₁, h₂⟩), mem_inf_iff]\n#align direction_inf_of_mem direction_inf_of_mem\n\n",
 "direction_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/-- The direction of the inf of two affine subspaces is less than or\nequal to the inf of their directions. -/\ntheorem direction_inf (s1 s2 : AffineSubspace k P) :\n    («expr ⊓ » s1 s2).direction ≤ «expr ⊓ » s1.direction s2.direction :=\n  by\n  repeat' rw [direction_eq_vector_span, vectorSpan_def]\n  exact\n    le_inf (infₛ_le_infₛ fun p hp => trans (vsub_self_mono (inter_subset_left _ _)) hp)\n      (infₛ_le_infₛ fun p hp => trans (vsub_self_mono (inter_subset_right _ _)) hp)\n#align direction_inf direction_inf\n\n",
 "direction_eq_vector_span":
 "/-- The direction equals the `vector_span`. -/\ntheorem direction_eq_vector_span (s : AffineSubspace k P) : s.direction = vectorSpan k (s : Set P) :=\n  rfl\n#align direction_eq_vector_span direction_eq_vector_span\n\n",
 "direction_eq_top_iff_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- A nonempty affine subspace is `⊤` if and only if its direction is\n`⊤`. -/\n@[simp]\ntheorem direction_eq_top_iff_of_nonempty {s : AffineSubspace k P} (h : (s : Set P).nonempty) :\n    s.direction = «expr⊤» ↔ s = «expr⊤» := by\n  constructor\n  · intro hd\n    rw [← direction_top k V P] at hd\n    refine' ext_of_direction_eq hd _\n    simp [h]\n  · rintro rfl\n    simp\n#align direction_eq_top_iff_of_nonempty direction_eq_top_iff_of_nonempty\n\n",
 "direction_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\ntheorem parallel.direction_eq {s₁ s₂ : AffineSubspace k P} (h : affine_subspace.parallel s₁ s₂) :\n    s₁.direction = s₂.direction := by\n  rcases h with ⟨v, rfl⟩\n  simp\n#align parallel.direction_eq parallel.direction_eq\n\n",
 "direction_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- The direction of `⊥` is the submodule `⊥`. -/\n@[simp]\ntheorem direction_bot : («expr⊥» : AffineSubspace k P).direction = «expr⊥» := by\n  rw [direction_eq_vector_span, bot_coe, vectorSpan_def, vsub_empty, Submodule.span_empty]\n#align direction_bot direction_bot\n\n",
 "direction_affine_span_insert":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The direction of the span of the result of adding a point to a\nnonempty affine subspace is the sup of the direction of that subspace\nand of any one difference between that point and a point in the\nsubspace. -/\ntheorem direction_affine_span_insert {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) :\n    (affineSpan k (insert p2 (s : Set P))).direction = «expr ⊔ » (Submodule.span k {«expr -ᵥ » p2 p1}) s.direction :=\n  by\n  rw [sup_comm, ← Set.union_singleton, ← coe_affine_span_singleton k V p2]\n  change («expr ⊔ » s (affineSpan k {p2})).direction = _\n  rw [direction_sup hp1 (mem_affineSpan k (Set.mem_singleton _)), direction_affineSpan]\n  simp\n#align direction_affine_span_insert direction_affine_span_insert\n\n",
 "direction_affineSpan":
 "#print direction_affineSpan /-\n/-- The direction of the affine span is the `vector_span`. -/\ntheorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s :=\n  by\n  apply le_antisymm\n  · refine' Submodule.span_le.2 _\n    rintro v ⟨p1, p3, ⟨p2, hp2, v1, hv1, hp1⟩, ⟨p4, hp4, v2, hv2, hp3⟩, rfl⟩\n    rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, SetLike.mem_coe]\n    exact (vectorSpan k s).sub_mem ((vectorSpan k s).add_mem hv1 (vsub_mem_vectorSpan k hp2 hp4)) hv2\n  · exact vectorSpan_mono k (subset_spanPoints k s)\n#align direction_affine_span direction_affineSpan\n-/\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top {f : «expr →ᵃ[ ] » P₁ k P₂} : («expr⊤» : AffineSubspace k P₂).comap f = «expr⊤» :=\n  by\n  rw [← ext_iff]\n  exact preimage_univ\n#align comap_top comap_top\n\n",
 "comap_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n@[simp]\ntheorem comap_symm (e : «expr ≃ᵃ[ ] » P₁ k P₂) (s : AffineSubspace k P₁) :\n    s.comap (e.symm : «expr →ᵃ[ ] » P₂ k P₁) = s.map e :=\n  coe_injective <| e.preimage_symm _\n#align comap_symm comap_symm\n\n",
 "comap_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_supr {ι : Sort _} (f : «expr →ᵃ[ ] » P₁ k P₂) (s : ι → AffineSubspace k P₂) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f).u_infi\n#align comap_supr comap_supr\n\n",
 "comap_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem comap_span (f : «expr ≃ᵃ[ ] » P₁ k P₂) (s : Set P₂) :\n    (affineSpan k s).comap (f : «expr →ᵃ[ ] » P₁ k P₂) = affineSpan k («expr ⁻¹' » f s) := by\n  rw [← map_symm, map_span, AffineEquiv.coe_coe, f.image_symm]\n#align comap_span comap_span\n\n",
 "comap_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem comap_mono {f : «expr →ᵃ[ ] » P₁ k P₂} {s t : AffineSubspace k P₂} : s ≤ t → s.comap f ≤ t.comap f :=\n  preimage_mono\n#align comap_mono comap_mono\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf (s t : AffineSubspace k P₂) (f : «expr →ᵃ[ ] » P₁ k P₂) :\n    («expr ⊓ » s t).comap f = «expr ⊓ » (s.comap f) (t.comap f) :=\n  (gc_map_comap f).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_id":
 "@[simp]\ntheorem comap_id (s : AffineSubspace k P₁) : s.comap (AffineMap.id k P₁) = s :=\n  coe_injective rfl\n#align comap_id comap_id\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\ntheorem comap_comap (s : AffineSubspace k P₃) (f : «expr →ᵃ[ ] » P₁ k P₂) (g : «expr →ᵃ[ ] » P₂ k P₃) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  coe_injective rfl\n#align comap_comap comap_comap\n\n",
 "coe_vsub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n-- See note [reducible non instances]\n@[simp, norm_cast]\ntheorem coe_vsub (s : AffineSubspace k P) [Nonempty s] (a b : s) : ↑(«expr -ᵥ » a b) = «expr -ᵥ » (a : P) (b : P) :=\n  rfl\n#align coe_vsub coe_vsub\n\n",
 "coe_vadd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n@[simp, norm_cast]\ntheorem coe_vadd (s : AffineSubspace k P) [Nonempty s] (a : s.direction) (b : s) :\n    ↑(«expr +ᵥ » a b) = «expr +ᵥ » (a : V) (b : P) :=\n  rfl\n#align coe_vadd coe_vadd\n\n",
 "coe_subtype":
 "@[simp]\ntheorem coe_subtype (s : AffineSubspace k P) [Nonempty s] : (s.subtype : s → P) = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map (s : AffineSubspace k P₁) : (s.map f : Set P₂) = «expr '' » f s :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_injective":
 "/-- Two affine subspaces are equal if they have the same points. -/\ntheorem coe_injective : function.injective (coe : AffineSubspace k P → Set P) :=\n  SetLike.coe_injective\n#align coe_injective coe_injective\n\n",
 "coe_eq_univ_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_eq_univ_iff (Q : AffineSubspace k P) : (Q : Set P) = univ ↔ Q = «expr⊤» :=\n  coe_injective.eq_iff' (top_coe _ _ _)\n#align coe_eq_univ_iff coe_eq_univ_iff\n\n",
 "coe_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem coe_eq_bot_iff (Q : AffineSubspace k P) : (Q : Set P) = ∅ ↔ Q = «expr⊥» :=\n  coe_injective.eq_iff' (bot_coe _ _ _)\n#align coe_eq_bot_iff coe_eq_bot_iff\n\n",
 "coe_direction_eq_vsub_set_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/-- Given a point in an affine subspace, the set of vectors in its\ndirection equals the set of vectors subtracting that point on the\nright. -/\ntheorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p ∈ s) :\n    (s.direction : Set V) = «expr '' » («expr -ᵥ » · p) s :=\n  by\n  rw [coe_direction_eq_vsub_set ⟨p, hp⟩]\n  refine' le_antisymm _ _\n  · rintro v ⟨p1, p2, hp1, hp2, rfl⟩\n    exact ⟨«expr +ᵥ » («expr -ᵥ » p1 p2) p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _⟩\n  · rintro v ⟨p2, hp2, rfl⟩\n    exact ⟨p2, p, hp2, hp, rfl⟩\n#align coe_direction_eq_vsub_set_right coe_direction_eq_vsub_set_right\n\n",
 "coe_direction_eq_vsub_set_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `«expr -ᵥ » -/\n/-- Given a point in an affine subspace, the set of vectors in its\ndirection equals the set of vectors subtracting that point on the\nleft. -/\ntheorem coe_direction_eq_vsub_set_left {s : AffineSubspace k P} {p : P} (hp : p ∈ s) :\n    (s.direction : Set V) = «expr '' » ((«expr -ᵥ » · ·) p) s :=\n  by\n  ext v\n  rw [SetLike.mem_coe, ← Submodule.neg_mem_iff, ← SetLike.mem_coe, coe_direction_eq_vsub_set_right hp,\n    Set.mem_image_iff_bex, Set.mem_image_iff_bex]\n  conv_lhs =>\n    congr\n    ext\n    rw [← neg_vsub_eq_vsub_rev, neg_inj]\n#align coe_direction_eq_vsub_set_left coe_direction_eq_vsub_set_left\n\n",
 "coe_direction_eq_vsub_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n/-- The set of vectors in the direction of a nonempty affine subspace\nis given by `vsub_set`. -/\ntheorem coe_direction_eq_vsub_set {s : AffineSubspace k P} (h : (s : Set P).nonempty) :\n    (s.direction : Set V) = «expr -ᵥ » (s : Set P) s :=\n  directionOfNonempty_eq_direction h ▸ rfl\n#align coe_direction_eq_vsub_set coe_direction_eq_vsub_set\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ᵃ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_comap (f : «expr →ᵃ[ ] » P₁ k P₂) (s : AffineSubspace k P₂) : (s.comap f : Set P₁) = «expr ⁻¹' » f ↑s :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_affine_span_singleton":
 "/-- The affine span of a single point, coerced to a set, contains just\nthat point. -/\n@[simp]\ntheorem coe_affine_span_singleton (p : P) : (affineSpan k ({p} : Set P) : Set P) = {p} :=\n  by\n  ext x\n  rw [mem_coe, ← vsub_right_mem_direction_iff_mem (mem_affineSpan k (Set.mem_singleton p)) _, direction_affineSpan]\n  simp\n#align coe_affine_span_singleton coe_affine_span_singleton\n\n",
 "coe_affineSpan":
 "#print coe_affineSpan /-\n/-- The affine span, converted to a set, is `span_points`. -/\n@[simp]\ntheorem coe_affineSpan (s : Set P) : (affineSpan k s : Set P) = spanPoints k s :=\n  rfl\n#align coe_affine_span coe_affineSpan\n-/\n\n",
 "card_pos_of_affine_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem card_pos_of_affine_span_eq_top {ι : Type _} [Fintype ι] {p : ι → P} (h : affineSpan k (range p) = «expr⊤») :\n    0 < Fintype.card ι := by\n  obtain ⟨-, ⟨i, -⟩⟩ := nonempty_of_affine_span_eq_top k V P h\n  exact fintype.card_pos_iff.mpr ⟨i⟩\n#align card_pos_of_affine_span_eq_top card_pos_of_affine_span_eq_top\n\n",
 "bot_parallel_iff_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_parallel_iff_eq_bot {s : AffineSubspace k P} : affine_subspace.parallel («expr⊥») s ↔ s = «expr⊥» := by\n  rw [parallel_comm, parallel_bot_iff_eq_bot]\n#align bot_parallel_iff_eq_bot bot_parallel_iff_eq_bot\n\n",
 "bot_ne_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print bot_ne_top /-\ntheorem bot_ne_top : («expr⊥» : AffineSubspace k P) ≠ «expr⊤» :=\n  by\n  intro contra\n  rw [← ext_iff, bot_coe, top_coe] at contra\n  exact Set.empty_ne_univ contra\n#align bot_ne_top bot_ne_top\n-/\n\n",
 "bot_lt_affineSpan":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print bot_lt_affineSpan /-\n@[simp]\ntheorem bot_lt_affineSpan : «expr⊥» < affineSpan k s ↔ s.nonempty :=\n  by\n  rw [bot_lt_iff_ne_bot, nonempty_iff_ne_empty]\n  exact (affineSpan_eq_bot _).not\n#align bot_lt_affine_span bot_lt_affineSpan\n-/\n\n",
 "bot_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- `⊥`, coerced to a set, is the empty set. -/\n@[simp]\ntheorem bot_coe : ((«expr⊥» : AffineSubspace k P) : Set P) = ∅ :=\n  rfl\n#align bot_coe bot_coe\n\n",
 "affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\ntheorem affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty {s₁ s₂ : Set P} :\n    affine_subspace.parallel (affineSpan k s₁) (affineSpan k s₂) ↔\n      vectorSpan k s₁ = vectorSpan k s₂ ∧ (s₁ = ∅ ↔ s₂ = ∅) :=\n  by\n  simp_rw [← direction_affineSpan, ← affineSpan_eq_bot k]\n  exact parallel_iff_direction_eq_and_eq_bot_iff_eq_bot\n#align affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty\n\n",
 "affine_span_pair_parallel_iff_vector_span_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `affine_subspace.parallel -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\ntheorem affine_span_pair_parallel_iff_vector_span_eq {p₁ p₂ p₃ p₄ : P} :\n    affine_subspace.parallel («exprline[ , , ]» k p₁ p₂) («exprline[ , , ]» k p₃ p₄) ↔\n      vectorSpan k ({p₁, p₂} : Set P) = vectorSpan k ({p₃, p₄} : Set P) :=\n  by simp [affine_span_parallel_iff_vector_span_eq_and_eq_empty_iff_eq_empty, ← not_nonempty_iff_eq_empty]\n#align affine_span_pair_parallel_iff_vector_span_eq affine_span_pair_parallel_iff_vector_span_eq\n\n",
 "affine_span_le":
 "#print affineSpan_le /-\ntheorem affineSpan_le {s : Set P} {Q : AffineSubspace k P} : affineSpan k s ≤ Q ↔ s ⊆ (Q : Set P) :=\n  (AffineSubspace.gi k V P).gc _ _\n#align affine_span_le affineSpan_le\n-/\n\n",
 "affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- For a non-trivial space, the affine span of a set is `⊤` iff its vector span is `⊤`. -/\ntheorem affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial {s : Set P} [Nontrivial P] :\n    affineSpan k s = «expr⊤» ↔ vectorSpan k s = «expr⊤» :=\n  by\n  cases' s.eq_empty_or_nonempty with hs hs\n  · simp [hs, subsingleton_iff_bot_eq_top, AddTorsor.subsingleton_iff V P, not_subsingleton]\n  · rw [affine_span_eq_top_iff_vector_span_eq_top_of_nonempty k V P hs]\n#align affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial affine_span_eq_top_iff_vector_span_eq_top_of_nontrivial\n\n",
 "affine_span_eq_top_iff_vector_span_eq_top_of_nonempty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- For a nonempty set, the affine span is `⊤` iff its vector span is `⊤`. -/\ntheorem affine_span_eq_top_iff_vector_span_eq_top_of_nonempty {s : Set P} (hs : s.nonempty) :\n    affineSpan k s = «expr⊤» ↔ vectorSpan k s = «expr⊤» :=\n  by\n  refine' ⟨vector_span_eq_top_of_affine_span_eq_top k V P, _⟩\n  intro h\n  suffices Nonempty (affineSpan k s) by\n    obtain ⟨p, hp : p ∈ affineSpan k s⟩ := this\n    rw [eq_iff_direction_eq_of_mem hp (mem_top k V p), direction_affineSpan, h, direction_top]\n  obtain ⟨x, hx⟩ := hs\n  exact ⟨⟨x, mem_affineSpan k hx⟩⟩\n#align affine_span_eq_top_iff_vector_span_eq_top_of_nonempty affine_span_eq_top_iff_vector_span_eq_top_of_nonempty\n\n",
 "affine_span_eq_Inf":
 "/-- The affine span is the `Inf` of subspaces containing the given\npoints. -/\ntheorem affine_span_eq_Inf (s : Set P) : affineSpan k s = infₛ { s' | s ⊆ s' } :=\n  le_antisymm (spanPoints_subset_coe_of_subset_coe <| Set.subset_interᵢ₂ fun _ => id) (infₛ_le (subset_spanPoints k _))\n#align affine_span_eq_Inf affine_span_eq_Inf\n\n",
 "affine_span_coe":
 "/-- Coercing a subspace to a set then taking the affine span produces\nthe original subspace. -/\n@[simp]\ntheorem affine_span_coe (s : AffineSubspace k P) : affineSpan k (s : Set P) = s :=\n  by\n  refine' le_antisymm _ (subset_spanPoints _ _)\n  rintro p ⟨p1, hp1, v, hv, rfl⟩\n  exact vadd_mem_of_mem_direction hv hp1\n#align affine_span_coe affine_span_coe\n\n",
 "affineSpan_singleton_union_vadd_eq_top_of_span_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print affineSpan_singleton_union_vadd_eq_top_of_span_eq_top /-\n/-- Suppose a set of vectors spans `V`.  Then a point `p`, together\nwith those vectors added to `p`, spans `P`. -/\ntheorem affineSpan_singleton_union_vadd_eq_top_of_span_eq_top {s : Set V} (p : P)\n    (h : Submodule.span k (Set.range (coe : s → V)) = «expr⊤») :\n    affineSpan k ({p} ∪ «expr '' » (fun v => «expr +ᵥ » v p) s) = «expr⊤» :=\n  by\n  convert ext_of_direction_eq _ ⟨p, mem_affineSpan k (Set.mem_union_left _ (Set.mem_singleton _)), mem_top k V p⟩\n  rw [direction_affineSpan, direction_top,\n    vectorSpan_eq_span_vsub_set_right k (Set.mem_union_left _ (Set.mem_singleton _) : p ∈ _), eq_top_iff, ← h]\n  apply Submodule.span_mono\n  rintro v ⟨v', rfl⟩\n  use «expr +ᵥ » (v' : V) p\n  simp\n#align affine_span_singleton_union_vadd_eq_top_of_span_eq_top affineSpan_singleton_union_vadd_eq_top_of_span_eq_top\n-/\n\n",
 "affineSpan_pair_le_of_right_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print affineSpan_pair_le_of_right_mem /-\n/-- One line is contained in another differing in the second point if the second point of the\nfirst line is contained in the second line. -/\ntheorem affineSpan_pair_le_of_right_mem {p₁ p₂ p₃ : P} (h : p₁ ∈ «exprline[ , , ]» k p₂ p₃) :\n    «exprline[ , , ]» k p₂ p₁ ≤ «exprline[ , , ]» k p₂ p₃ :=\n  affineSpan_pair_le_of_mem_of_mem (left_mem_affineSpan_pair _ _ _) h\n#align affine_span_pair_le_of_right_mem affineSpan_pair_le_of_right_mem\n-/\n\n",
 "affineSpan_pair_le_of_mem_of_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print affineSpan_pair_le_of_mem_of_mem /-\n/-- The span of two points that lie in an affine subspace is contained in that subspace. -/\ntheorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) :\n    «exprline[ , , ]» k p₁ p₂ ≤ s :=\n  by\n  rw [affineSpan_le, Set.insert_subset, Set.singleton_subset_iff]\n  exact ⟨hp₁, hp₂⟩\n#align affine_span_pair_le_of_mem_of_mem affineSpan_pair_le_of_mem_of_mem\n-/\n\n",
 "affineSpan_pair_le_of_left_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprline[ , , ]» -/\n#print affineSpan_pair_le_of_left_mem /-\n/-- One line is contained in another differing in the first point if the first point of the first\nline is contained in the second line. -/\ntheorem affineSpan_pair_le_of_left_mem {p₁ p₂ p₃ : P} (h : p₁ ∈ «exprline[ , , ]» k p₂ p₃) :\n    «exprline[ , , ]» k p₁ p₃ ≤ «exprline[ , , ]» k p₂ p₃ :=\n  affineSpan_pair_le_of_mem_of_mem h (right_mem_affineSpan_pair _ _ _)\n#align affine_span_pair_le_of_left_mem affineSpan_pair_le_of_left_mem\n-/\n\n",
 "affineSpan_nonempty":
 "#print affineSpan_nonempty /-\n/-- The affine span of a set is nonempty if and only if that set is. -/\ntheorem affineSpan_nonempty : (affineSpan k s : Set P).nonempty ↔ s.nonempty :=\n  spanPoints_nonempty k s\n#align affine_span_nonempty affineSpan_nonempty\n-/\n\n",
 "affineSpan_mono":
 "#print affineSpan_mono /-\n/-- `affine_span` is monotone. -/\n@[mono]\ntheorem affineSpan_mono {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : affineSpan k s₁ ≤ affineSpan k s₂ :=\n  spanPoints_subset_coe_of_subset_coe (Set.Subset.trans h (subset_affineSpan k _))\n#align affine_span_mono affineSpan_mono\n-/\n\n",
 "affineSpan_insert_eq_affineSpan":
 "#print affineSpan_insert_eq_affineSpan /-\n/-- If a point is in the affine span of a set, adding it to that set\ndoes not change the affine span. -/\ntheorem affineSpan_insert_eq_affineSpan {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) :\n    affineSpan k (insert p ps) = affineSpan k ps :=\n  by\n  rw [← mem_coe] at h\n  rw [← affineSpan_insert_affineSpan, Set.insert_eq_of_mem h, affine_span_coe]\n#align affine_span_insert_eq_affine_span affineSpan_insert_eq_affineSpan\n-/\n\n",
 "affineSpan_insert_affineSpan":
 "#print affineSpan_insert_affineSpan /-\n/-- Taking the affine span of a set, adding a point and taking the\nspan again produces the same results as adding the point to the set\nand taking the span. -/\ntheorem affineSpan_insert_affineSpan (p : P) (ps : Set P) :\n    affineSpan k (insert p (affineSpan k ps : Set P)) = affineSpan k (insert p ps) := by\n  rw [Set.insert_eq, Set.insert_eq, span_union, span_union, affine_span_coe]\n#align affine_span_insert_affine_span affineSpan_insert_affineSpan\n-/\n\n",
 "affineSpan_induction'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print affineSpan_induction' /-\n/-- A dependent version of `affine_span_induction`. -/\ntheorem affineSpan_induction' {s : Set P} {p : ∀ x, x ∈ affineSpan k s → Prop}\n    (Hs : ∀ (y) (hys : y ∈ s), p y (subset_affineSpan k _ hys))\n    (Hc :\n      ∀ (c : k) (u hu v hv w hw),\n        p u hu →\n          p v hv →\n            p w hw → p («expr +ᵥ » («expr • » c («expr -ᵥ » u v)) w) (affine_subspace.smul_vsub_vadd_mem _ _ hu hv hw))\n    {x : P} (h : x ∈ affineSpan k s) : p x h :=\n  by\n  refine' exists.elim _ fun (hx : x ∈ affineSpan k s) (hc : p x hx) => hc\n  refine' @affineSpan_induction k V P _ _ _ _ _ _ _ h _ _\n  · exact fun y hy => ⟨subset_affineSpan _ _ hy, Hs y hy⟩\n  ·\n    exact fun c u v w hu hv hw =>\n      exists.elim hu fun hu' hu =>\n        exists.elim hv fun hv' hv =>\n          exists.elim hw fun hw' hw => ⟨affine_subspace.smul_vsub_vadd_mem _ _ hu' hv' hw', Hc _ _ _ _ _ _ _ hu hv hw⟩\n#align affine_span_induction' affineSpan_induction'\n-/\n\n",
 "affineSpan_induction":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr +ᵥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n#print affineSpan_induction /-\n/-- An induction principle for span membership. If `p` holds for all elements of `s` and is\npreserved under certain affine combinations, then `p` holds for all elements of the span of `s`.\n-/\ntheorem affineSpan_induction {x : P} {s : Set P} {p : P → Prop} (h : x ∈ affineSpan k s) (Hs : ∀ x : P, x ∈ s → p x)\n    (Hc : ∀ (c : k) (u v w : P), p u → p v → p w → p («expr +ᵥ » («expr • » c («expr -ᵥ » u v)) w)) : p x :=\n  (@affineSpan_le _ _ _ _ _ _ _ _ ⟨p, Hc⟩).mpr Hs h\n#align affine_span_induction affineSpan_induction\n-/\n\n",
 "affineSpan_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print affineSpan_eq_bot /-\n/-- The affine span of a set is `⊥` if and only if that set is empty. -/\n@[simp]\ntheorem affineSpan_eq_bot : affineSpan k s = «expr⊥» ↔ s = ∅ := by\n  rw [← not_iff_not, ← ne.def, ← ne.def, ← nonempty_iff_ne_bot, affineSpan_nonempty, nonempty_iff_ne_empty]\n#align affine_span_eq_bot affineSpan_eq_bot\n-/\n\n",
 "affineSpan_coe_preimage_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print affineSpan_coe_preimage_eq_top /-\n/-- A set, considered as a subset of its spanned affine subspace, spans the whole subspace. -/\n@[simp]\ntheorem affineSpan_coe_preimage_eq_top (A : Set P) [Nonempty A] :\n    affineSpan k («expr ⁻¹' » (coe : affineSpan k A → P) A) = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  rintro ⟨x, hx⟩ -\n  refine' affineSpan_induction' (fun y hy => _) (fun c u hu v hv w hw => _) hx\n  · exact subset_affineSpan _ _ hy\n  · exact affine_subspace.smul_vsub_vadd_mem _ _\n#align affine_span_coe_preimage_eq_top affineSpan_coe_preimage_eq_top\n-/\n\n"}