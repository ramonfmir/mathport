{"surjective_coord":
 "theorem surjective_coord [nontrivial ι] (i : ι) : function.surjective <| b.coord i := by\n  classical\n    intro x\n    obtain ⟨j, hij⟩ := exists_ne i\n    let s : Finset ι := {i, j}\n    have hi : i ∈ s := by simp\n    have hj : j ∈ s := by simp\n    let w : ι → k := fun j' => if j' = i then x else 1 - x\n    have hw : s.sum w = 1 := by simp [hij, finset.sum_ite, Finset.filter_insert, Finset.filter_eq']\n    use s.affine_combination b.points w\n    simp [b.coord_apply_combination_of_mem hi hw]\n#align surjective_coord surjective_coord\n\n",
 "sum_coord_apply_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n@[simp]\ntheorem sum_coord_apply_eq_one [fintype ι] (q : P) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (b.coord i q) =\n      1 :=\n  by\n  have hq : q ∈ affine_span k (range b.points) := by\n    rw [b.tot]\n    exact affine_subspace.mem_top k V q\n  obtain ⟨w, hw, rfl⟩ := eq_affine_combination_of_mem_affine_span_of_fintype hq\n  convert hw\n  ext i\n  exact b.coord_apply_combination_of_mem (finset.mem_univ i) hw\n#align sum_coord_apply_eq_one sum_coord_apply_eq_one\n\n",
 "nonempty":
 "/-\nCopyright (c) 2021 Oliver Nash. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Oliver Nash\n-/\nprotected theorem nonempty : nonempty ι :=\n  not_isEmpty_iff.mp fun hι => by\n    simpa only [@range_eq_empty _ _ hι, affine_subspace.span_empty, bot_ne_top] using b.tot\n#align nonempty nonempty\n\n",
 "linear_eq_sum_coords":
 "@[simp]\ntheorem linear_eq_sum_coords (i : ι) : (b.coord i).linear = -(b.basis_of i).sum_coords :=\n  rfl\n#align linear_eq_sum_coords linear_eq_sum_coords\n\n",
 "linear_combination_coord_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A variant of `affine_basis.affine_combination_coord_eq_self` for the special case when the\naffine space is a module so we can talk about linear combinations. -/\n@[simp]\ntheorem linear_combination_coord_eq_self [fintype ι] (b : affine_basis ι k V) (v : V) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (b.coord i v) (b.points i)) =\n      v :=\n  by\n  have hb := b.affine_combination_coord_eq_self v\n  rwa [finset.univ.affine_combination_eq_linear_combination _ _ (b.sum_coord_apply_eq_one v)] at hb\n#align linear_combination_coord_eq_self linear_combination_coord_eq_self\n\n",
 "ext_elem":
 "theorem ext_elem [fintype ι] {q₁ q₂ : P} (h : ∀ i, b.coord i q₁ = b.coord i q₂) : q₁ = q₂ :=\n  by\n  rw [← b.affine_combination_coord_eq_self q₁, ← b.affine_combination_coord_eq_self q₂]\n  simp only [h]\n#align ext_elem ext_elem\n\n",
 "exists_affine_subbasis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (s «expr ⊆ » t) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem exists_affine_subbasis {t : set P} (ht : affine_span k t = «expr⊤») :\n    ∃ (s : _)(_ : s ⊆ t)(b : affine_basis («expr↥ » s) k P), b.points = coe :=\n  by\n  obtain ⟨s, hst, h_tot, h_ind⟩ := exists_affine_independent k V t\n  refine' ⟨s, hst, ⟨coe, h_ind, _⟩, rfl⟩\n  rw [Subtype.range_coe, h_tot, ht]\n#align exists_affine_subbasis exists_affine_subbasis\n\n",
 "exists_affine_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\ntheorem exists_affine_basis : ∃ (s : set P)(b : affine_basis («expr↥ » s) k P), b.points = coe :=\n  let ⟨s, _, hs⟩ := exists_affine_subbasis (affine_subspace.span_univ k V P)\n  ⟨s, hs⟩\n#align exists_affine_basis exists_affine_basis\n\n",
 "coords_apply":
 "@[simp]\ntheorem coords_apply (q : P) (i : ι) : b.coords q i = b.coord i q :=\n  rfl\n#align coords_apply coords_apply\n\n",
 "coord_apply_neq":
 "@[simp]\ntheorem coord_apply_neq (i j : ι) (h : j ≠ i) : b.coord i (b.points j) = 0 := by\n  rw [coord, affine_map.coe_mk, ← subtype.coe_mk j h, ← b.basis_of_apply i ⟨j, h⟩, basis.sum_coords_self_apply,\n    sub_self]\n#align coord_apply_neq coord_apply_neq\n\n",
 "coord_apply_eq":
 "@[simp]\ntheorem coord_apply_eq (i : ι) : b.coord i (b.points i) = 1 := by\n  simp only [coord, basis.coe_sum_coords, linear_equiv.map_zero, linear_equiv.coe_coe, sub_zero, affine_map.coe_mk,\n    finsupp.sum_zero_index, vsub_self]\n#align coord_apply_eq coord_apply_eq\n\n",
 "coord_apply_combination_of_not_mem":
 "@[simp]\ntheorem coord_apply_combination_of_not_mem {s : Finset ι} {i : ι} (hi : i ∉ s) {w : ι → k} (hw : s.sum w = 1) :\n    b.coord i (s.affine_combination b.points w) = 0 := by\n  classical simp only [coord_apply, hi, finset.affine_combination_eq_linear_combination, if_false, mul_boole, hw,\n      Function.comp_apply, smul_eq_mul, s.sum_ite_eq, s.map_affine_combination b.points w hw]\n#align coord_apply_combination_of_not_mem coord_apply_combination_of_not_mem\n\n",
 "coord_apply_combination_of_mem":
 "@[simp]\ntheorem coord_apply_combination_of_mem {s : Finset ι} {i : ι} (hi : i ∈ s) {w : ι → k} (hw : s.sum w = 1) :\n    b.coord i (s.affine_combination b.points w) = w i := by\n  classical simp only [coord_apply, hi, finset.affine_combination_eq_linear_combination, if_true, mul_boole, hw,\n      Function.comp_apply, smul_eq_mul, s.sum_ite_eq, s.map_affine_combination b.points w hw]\n#align coord_apply_combination_of_mem coord_apply_combination_of_mem\n\n",
 "coord_apply_centroid":
 "@[simp]\ntheorem coord_apply_centroid [CharZero k] (b : affine_basis ι k P) {s : Finset ι} {i : ι} (hi : i ∈ s) :\n    b.coord i (s.centroid k b.points) = (s.card : k)⁻¹ := by\n  rw [finset.centroid, b.coord_apply_combination_of_mem hi (s.sum_centroid_weights_eq_one_of_nonempty _ ⟨i, hi⟩),\n    finset.centroid_weights]\n#align coord_apply_centroid coord_apply_centroid\n\n",
 "coord_apply":
 "theorem coord_apply [decidable_eq ι] (i j : ι) : b.coord i (b.points j) = if i = j then 1 else 0 :=\n  by\n  cases eq_or_ne i j <;> simp [h.symm]\n  simp [h]\n#align coord_apply coord_apply\n\n",
 "coe_coord_of_subsingleton_eq_one":
 "@[simp]\ntheorem coe_coord_of_subsingleton_eq_one [subsingleton ι] (i : ι) : (b.coord i : P → k) = 1 :=\n  by\n  ext q\n  have hp : (range b.points).subsingleton := by\n    rw [← image_univ]\n    apply subsingleton.image\n    apply subsingleton_of_subsingleton\n  haveI := affine_subspace.subsingleton_of_subsingleton_span_eq_top hp b.tot\n  let s : Finset ι := {i}\n  have hi : i ∈ s := by simp\n  have hw : s.sum (function.const ι (1 : k)) = 1 := by simp\n  have hq : q = s.affine_combination b.points (function.const ι (1 : k)) := by simp\n  rw [pi.one_apply, hq, b.coord_apply_combination_of_mem hi hw]\n#align coe_coord_of_subsingleton_eq_one coe_coord_of_subsingleton_eq_one\n\n",
 "basis_of_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr -ᵥ » -/\n@[simp]\ntheorem basis_of_apply (i : ι) (j : { j : ι // j ≠ i }) : b.basis_of i j = «expr -ᵥ » (b.points ↑j) (b.points i) := by\n  simp [basis_of]\n#align basis_of_apply basis_of_apply\n\n",
 "affine_combination_coord_eq_self":
 "@[simp]\ntheorem affine_combination_coord_eq_self [fintype ι] (q : P) :\n    (finset.univ.affine_combination b.points fun i => b.coord i q) = q :=\n  by\n  have hq : q ∈ affine_span k (range b.points) := by\n    rw [b.tot]\n    exact affine_subspace.mem_top k V q\n  obtain ⟨w, hw, rfl⟩ := eq_affine_combination_of_mem_affine_span_of_fintype hq\n  congr\n  ext i\n  exact b.coord_apply_combination_of_mem (finset.mem_univ i) hw\n#align affine_combination_coord_eq_self affine_combination_coord_eq_self\n\n"}