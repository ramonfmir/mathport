{"units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print LinearIndependent.units_smul /-\n-- This lemma cannot be proved with `linear_independent.group_smul` since the action of\n-- `Rˣ` on `R` is not commutative.\ntheorem LinearIndependent.units_smul {v : ι → M} (hv : LinearIndependent R v) (w : ι → «expr ˣ» R) :\n    LinearIndependent R («expr • » w v) :=\n  by\n  rw [linearIndependent_iff''] at hv⊢\n  intro s g hgs hsum i\n  rw [← (w i).mul_left_eq_zero]\n  refine' hv s (fun i => «expr • » (g i) (w i)) (fun i hi => _) _ i\n  · dsimp only\n    exact (hgs i hi).symm ▸ zero_smul _ _\n  · rw [← hsum, Finset.sum_congr rfl _]\n    intros\n    erw [Pi.smul_apply, smul_assoc]\n    rfl\n#align linear_independent.units_smul LinearIndependent.units_smul\n-/\n\n",
 "union":
 "#print LinearIndependent.union /-\ntheorem LinearIndependent.union {s t : Set M} (hs : LinearIndependent R (fun x => x : s → M))\n    (ht : LinearIndependent R (fun x => x : t → M)) (hst : Disjoint (span R s) (span R t)) :\n    LinearIndependent R (fun x => x : s ∪ t → M) :=\n  (hs.sum_type ht <| by simpa).to_subtype_range' <| by simp\n#align linear_independent.union LinearIndependent.union\n-/\n\n",
 "total_repr":
 "#print LinearIndependent.total_repr /-\n@[simp]\ntheorem LinearIndependent.total_repr (x) : Finsupp.total ι M R v (hv.repr x) = x :=\n  Subtype.ext_iff.1 (LinearEquiv.apply_symm_apply hv.total_equiv x)\n#align linear_independent.total_repr LinearIndependent.total_repr\n-/\n\n",
 "total_ne_of_not_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print LinearIndependent.total_ne_of_not_mem_support /-\ntheorem LinearIndependent.total_ne_of_not_mem_support [Nontrivial R] (hv : LinearIndependent R v) {x : ι}\n    (f : «expr →₀ » ι R) (h : x ∉ f.support) : Finsupp.total ι M R v f ≠ v x :=\n  by\n  replace h : x ∉ (f.support : Set ι) := h\n  have p := hv.not_mem_span_image h\n  intro w\n  rw [← w] at p\n  rw [Finsupp.span_image_eq_map_total] at p\n  simp only [not_exists, not_and, mem_map] at p\n  exact p f (f.mem_supported_support R) rfl\n#align linear_independent.total_ne_of_not_mem_support LinearIndependent.total_ne_of_not_mem_support\n-/\n\n",
 "total_comp_repr":
 "#print LinearIndependent.total_comp_repr /-\ntheorem LinearIndependent.total_comp_repr : (Finsupp.total ι M R v).comp hv.repr = Submodule.subtype _ :=\n  LinearMap.ext <| hv.total_repr\n#align linear_independent.total_comp_repr LinearIndependent.total_comp_repr\n-/\n\n",
 "to_subtype_range'":
 "#print LinearIndependent.to_subtype_range' /-\ntheorem LinearIndependent.to_subtype_range' {ι} {f : ι → M} (hf : LinearIndependent R f) {t} (ht : range f = t) :\n    LinearIndependent R (coe : t → M) :=\n  ht ▸ hf.to_subtype_range\n#align linear_independent.to_subtype_range' LinearIndependent.to_subtype_range'\n-/\n\n",
 "to_subtype_range":
 "#print LinearIndependent.to_subtype_range /-\ntheorem LinearIndependent.to_subtype_range {ι} {f : ι → M} (hf : LinearIndependent R f) :\n    LinearIndependent R (coe : range f → M) := by\n  nontriviality R\n  exact (linearIndependent_subtype_range hf.injective).2 hf\n#align linear_independent.to_subtype_range LinearIndependent.to_subtype_range\n-/\n\n",
 "surjective_of_linearIndependent_of_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n#print surjective_of_linearIndependent_of_span /-\ntheorem surjective_of_linearIndependent_of_span [Nontrivial R] (hv : LinearIndependent R v) (f : «expr ↪ » ι' ι)\n    (hss : range v ⊆ span R (range (v ∘ f))) : surjective f :=\n  by\n  intro i\n  let repr : (span R (range (v ∘ f)) : Type _) → «expr →₀ » ι' R := (hv.comp f f.injective).repr\n  let l := (repr ⟨v i, hss (mem_range_self i)⟩).map_domain f\n  have h_total_l : Finsupp.total ι M R v l = v i := by\n    dsimp only [l]\n    rw [Finsupp.total_mapDomain]\n    rw [(hv.comp f f.injective).total_repr]\n    · rfl\n  have h_total_eq : (Finsupp.total ι M R v) l = (Finsupp.total ι M R v) (Finsupp.single i 1) := by\n    rw [h_total_l, Finsupp.total_single, one_smul]\n  have l_eq : l = _ := LinearMap.ker_eq_bot.1 hv h_total_eq\n  dsimp only [l] at l_eq\n  rw [← Finsupp.embDomain_eq_mapDomain] at l_eq\n  rcases Finsupp.single_of_embDomain_single (repr ⟨v i, _⟩) f i (1 : R) zero_ne_one.symm l_eq with ⟨i', hi'⟩\n  use i'\n  exact hi'.2\n#align surjective_of_linear_independent_of_span surjective_of_linearIndependent_of_span\n-/\n\n",
 "sum_type":
 "#print LinearIndependent.sum_type /-\ntheorem LinearIndependent.sum_type {v' : ι' → M} (hv : LinearIndependent R v) (hv' : LinearIndependent R v')\n    (h : Disjoint (Submodule.span R (range v)) (Submodule.span R (range v'))) : LinearIndependent R (Sum.elim v v') :=\n  linearIndependent_sum.2 ⟨hv, hv', h⟩\n#align linear_independent.sum_type LinearIndependent.sum_type\n-/\n\n",
 "subset_span_extend":
 "#print LinearIndependent.subset_span_extend /-\ntheorem LinearIndependent.subset_span_extend (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    t ⊆ span K (hs.extend hst) :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  htb\n#align linear_independent.subset_span_extend LinearIndependent.subset_span_extend\n-/\n\n",
 "subset_extend":
 "#print LinearIndependent.subset_extend /-\ntheorem LinearIndependent.subset_extend (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    s ⊆ hs.extend hst :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  hsb\n#align linear_independent.subset_extend LinearIndependent.subset_extend\n-/\n\n",
 "span_repr_eq":
 "#print LinearIndependent.span_repr_eq /-\ntheorem LinearIndependent.span_repr_eq [Nontrivial R] (x) :\n    Span.repr R (Set.range v) x = (hv.repr x).equiv_map_domain (Equiv.ofInjective _ hv.injective) :=\n  by\n  have p : (Span.repr R (Set.range v) x).equiv_map_domain (Equiv.ofInjective _ hv.injective).symm = hv.repr x :=\n    by\n    apply (LinearIndependent.totalEquiv hv).injective\n    ext\n    simp only [LinearIndependent.totalEquiv_apply_coe, Equiv.self_comp_ofInjective_symm, LinearIndependent.total_repr,\n      Finsupp.total_equivMapDomain, Span.finsupp_total_repr]\n  ext ⟨_, ⟨i, rfl⟩⟩\n  simp [← p]\n#align linear_independent.span_repr_eq LinearIndependent.span_repr_eq\n-/\n\n",
 "span_le_span_iff":
 "#print span_le_span_iff /-\ntheorem span_le_span_iff [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R (coe : u → M)) (hsu : s ⊆ u)\n    (htu : t ⊆ u) : span R s ≤ span R t ↔ s ⊆ t :=\n  ⟨le_of_span_le_span hl hsu htu, span_mono⟩\n#align span_le_span_iff span_le_span_iff\n-/\n\n",
 "restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print LinearIndependent.restrict_scalars /-\n/-- A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly\nindependent over a subring `R` of `K`.\nThe implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.\nThe version where `K` is an `R`-algebra is `linear_independent.restrict_scalars_algebras`.\n -/\ntheorem LinearIndependent.restrict_scalars [Semiring K] [SMulWithZero R K] [Module K M] [IsScalarTower R K M]\n    (hinj : function.injective fun r : R => «expr • » r (1 : K)) (li : LinearIndependent K v) : LinearIndependent R v :=\n  by\n  refine' linear_independent_iff'.mpr fun s g hg i hi => hinj (Eq.trans _ (zero_smul _ _).symm)\n  refine' (linear_independent_iff'.mp li : _) _ _ _ i hi\n  simp_rw [smul_assoc, one_smul]\n  exact hg\n#align linear_independent.restrict_scalars LinearIndependent.restrict_scalars\n-/\n\n",
 "restrict_of_comp_subtype":
 "#print LinearIndependent.restrict_of_comp_subtype /-\ntheorem LinearIndependent.restrict_of_comp_subtype {s : Set ι} (hs : LinearIndependent R (v ∘ coe : s → M)) :\n    LinearIndependent R (s.restrict v) :=\n  hs\n#align linear_independent.restrict_of_comp_subtype LinearIndependent.restrict_of_comp_subtype\n-/\n\n",
 "repr_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print LinearIndependent.repr_range /-\ntheorem LinearIndependent.repr_range : hv.repr.range = «expr⊤» := by rw [LinearIndependent.repr, LinearEquiv.range]\n#align linear_independent.repr_range LinearIndependent.repr_range\n-/\n\n",
 "repr_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print LinearIndependent.repr_ker /-\ntheorem LinearIndependent.repr_ker : hv.repr.ker = «expr⊥» := by rw [LinearIndependent.repr, LinearEquiv.ker]\n#align linear_independent.repr_ker LinearIndependent.repr_ker\n-/\n\n",
 "repr_eq_single":
 "#print LinearIndependent.repr_eq_single /-\ntheorem LinearIndependent.repr_eq_single (i) (x) (hx : ↑x = v i) : hv.repr x = Finsupp.single i 1 :=\n  by\n  apply hv.repr_eq\n  simp [Finsupp.total_single, hx]\n#align linear_independent.repr_eq_single LinearIndependent.repr_eq_single\n-/\n\n",
 "repr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print LinearIndependent.repr_eq /-\ntheorem LinearIndependent.repr_eq {l : «expr →₀ » ι R} {x} (eq : Finsupp.total ι M R v l = ↑x) : hv.repr x = l :=\n  by\n  have :\n    ↑((LinearIndependent.totalEquiv hv : «expr →ₗ[ ] » («expr →₀ » ι R) R (span R (range v))) l) =\n      Finsupp.total ι M R v l :=\n    rfl\n  have : (LinearIndependent.totalEquiv hv : «expr →ₗ[ ] » («expr →₀ » ι R) R (span R (range v))) l = x :=\n    by\n    rw [Eq] at this\n    exact Subtype.ext_iff.2 this\n  rw [← LinearEquiv.symm_apply_apply hv.total_equiv l]\n  rw [← this]\n  rfl\n#align linear_independent.repr_eq LinearIndependent.repr_eq\n-/\n\n",
 "option":
 "#print LinearIndependent.option /-\ntheorem LinearIndependent.option (hv : LinearIndependent K v) (hx : x ∉ Submodule.span K (range v)) :\n    LinearIndependent K (fun o => Option.casesOn' o x v : Option ι → V) :=\n  linearIndependent_option'.2 ⟨hv, hx⟩\n#align linear_independent.option LinearIndependent.option\n-/\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearIndependent.of_comp /-\n/-- If the image of a family of vectors under a linear map is linearly independent, then so is\nthe original family. -/\ntheorem LinearIndependent.of_comp (f : «expr →ₗ[ ] » M R M') (hfv : LinearIndependent R (f ∘ v)) :\n    LinearIndependent R v :=\n  linearIndependent_iff'.2 fun s g hg i his =>\n    have :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          («expr • » (g i) (f (v i))) =\n        0 :=\n      by simp_rw [← f.map_smul, ← f.map_sum, hg, f.map_zero]\n    linearIndependent_iff'.1 hfv s g this i his\n#align linear_independent.of_comp LinearIndependent.of_comp\n-/\n\n",
 "not_mem_span_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.not_mem_span_image /-\ntheorem LinearIndependent.not_mem_span_image [Nontrivial R] (hv : LinearIndependent R v) {s : Set ι} {x : ι}\n    (h : x ∉ s) : v x ∉ Submodule.span R («expr '' » v s) :=\n  by\n  have h' : v x ∈ Submodule.span R («expr '' » v {x}) :=\n    by\n    rw [Set.image_singleton]\n    exact mem_span_singleton_self (v x)\n  intro w\n  apply LinearIndependent.ne_zero x hv\n  refine' disjoint_def.1 (hv.disjoint_span_image _) (v x) h' w\n  simpa using h\n#align linear_independent.not_mem_span_image LinearIndependent.not_mem_span_image\n-/\n\n",
 "not_linearIndependent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Fintype.not_linearIndependent_iff /-\ntheorem Fintype.not_linearIndependent_iff [Fintype ι] :\n    ¬LinearIndependent R v ↔\n      ∃ g : ι → R,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (g i) (v i)) =\n            0 ∧\n          ∃ i, g i ≠ 0 :=\n  by simpa using not_iff_not.2 Fintype.linearIndependent_iff\n#align fintype.not_linear_independent_iff Fintype.not_linearIndependent_iff\n-/\n\n",
 "ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print LinearIndependent.ne_zero /-\ntheorem LinearIndependent.ne_zero [Nontrivial R] (i : ι) (hv : LinearIndependent R v) : v i ≠ 0 := fun h =>\n  zero_ne_one' R <|\n    Eq.symm\n      (by\n        suffices (Finsupp.single i 1 : «expr →₀ » ι R) i = 0 by simpa\n        rw [linearIndependent_iff.1 hv (Finsupp.single i 1)]\n        · simp\n        · simp [h])\n#align linear_independent.ne_zero LinearIndependent.ne_zero\n-/\n\n",
 "mono":
 "#print LinearIndependent.mono /-\ntheorem LinearIndependent.mono {t s : Set M} (h : t ⊆ s) :\n    LinearIndependent R (fun x => x : s → M) → LinearIndependent R (fun x => x : t → M) :=\n  by\n  simp only [linearIndependent_subtype_disjoint]\n  exact Disjoint.mono_left (Finsupp.supported_mono h)\n#align linear_independent.mono LinearIndependent.mono\n-/\n\n",
 "mem_span_insert_exchange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print mem_span_insert_exchange /-\n/- TODO: some of the following proofs can generalized with a zero_ne_one predicate type class\n   (instead of a data containing type class) -/\ntheorem mem_span_insert_exchange : x ∈ span K (insert y s) → x ∉ span K s → y ∈ span K (insert x s) :=\n  by\n  simp [mem_span_insert]\n  rintro a z hz rfl h\n  refine' ⟨a⁻¹, «expr • » (-a⁻¹) z, smul_mem _ _ hz, _⟩\n  have a0 : a ≠ 0 := by\n    rintro rfl\n    simp_all\n  simp [a0, smul_add, smul_smul]\n#align mem_span_insert_exchange mem_span_insert_exchange\n-/\n\n",
 "maximal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.maximal_iff /-\n/-- An alternative characterization of a maximal linearly independent family,\nquantifying over types (in the same universe as `M`) into which the indexing family injects.\n-/\ntheorem LinearIndependent.maximal_iff {ι : Type w} {R : Type u} [Ring R] [Nontrivial R] {M : Type v} [AddCommGroup M]\n    [Module R M] {v : ι → M} (i : LinearIndependent R v) :\n    i.maximal ↔ ∀ (κ : Type v) (w : κ → M) (i' : LinearIndependent R w) (j : ι → κ) (h : w ∘ j = v), surjective j :=\n  by\n  fconstructor\n  · rintro p κ w i' j rfl\n    specialize p (range w) i'.coe_range (range_comp_subset_range _ _)\n    rw [range_comp, ← @image_univ _ _ w] at p\n    exact range_iff_surjective.mp (image_injective.mpr i'.injective p)\n  · intro p w i' h\n    specialize\n      p w (coe : w → M) i' (fun i => ⟨v i, range_subset_iff.mp h i⟩)\n        (by\n          ext\n          simp)\n    have q := congr_arg (fun s => «expr '' » (coe : w → M) s) p.range_eq\n    dsimp at q\n    rw [← image_univ, image_image] at q\n    simpa using q\n#align linear_independent.maximal_iff LinearIndependent.maximal_iff\n-/\n\n",
 "map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print LinearIndependent.map' /-\n/-- An injective linear map sends linearly independent families of vectors to linearly independent\nfamilies of vectors. See also `linear_independent.map` for a more general statement. -/\ntheorem LinearIndependent.map' (hv : LinearIndependent R v) (f : «expr →ₗ[ ] » M R M') (hf_inj : f.ker = «expr⊥») :\n    LinearIndependent R (f ∘ v) :=\n  hv.map <| by simp [hf_inj]\n#align linear_independent.map' LinearIndependent.map'\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n#print LinearIndependent.map /-\n/-- If `v` is a linearly independent family of vectors and the kernel of a linear map `f` is\ndisjoint with the submodule spanned by the vectors of `v`, then `f ∘ v` is a linearly independent\nfamily of vectors. See also `linear_independent.map'` for a special case assuming `ker f = ⊥`. -/\ntheorem LinearIndependent.map (hv : LinearIndependent R v) {f : «expr →ₗ[ ] » M R M'}\n    (hf_inj : Disjoint (span R (range v)) f.ker) : LinearIndependent R (f ∘ v) :=\n  by\n  rw [disjoint_iff_inf_le, ← Set.image_univ, Finsupp.span_image_eq_map_total, map_inf_eq_map_inf_comap,\n    map_le_iff_le_comap, comap_bot, Finsupp.supported_univ, top_inf_eq] at hf_inj\n  unfold LinearIndependent at hv⊢\n  rw [hv, le_bot_iff] at hf_inj\n  haveI : Inhabited M := ⟨0⟩\n  rw [Finsupp.total_comp, @Finsupp.lmapDomain_total _ _ R _ _ _ _ _ _ _ _ _ _ f, LinearMap.ker_comp, hf_inj]\n  exact fun _ => rfl\n#align linear_independent.map LinearIndependent.map\n-/\n\n",
 "linearIndependent_unique_iff":
 "#print linearIndependent_unique_iff /-\ntheorem linearIndependent_unique_iff (v : ι → M) [Unique ι] : LinearIndependent R v ↔ v default ≠ 0 :=\n  by\n  simp only [linearIndependent_iff, Finsupp.total_unique, smul_eq_zero]\n  refine' ⟨fun h hv => _, fun hv l hl => Finsupp.unique_ext <| hl.resolve_right hv⟩\n  have := h (Finsupp.single default 1) (or.inr hv)\n  exact one_ne_zero (Finsupp.single_eq_zero.1 this)\n#align linear_independent_unique_iff linearIndependent_unique_iff\n-/\n\n",
 "linearIndependent_unionₛ_of_directed":
 "#print linearIndependent_unionₛ_of_directed /-\ntheorem linearIndependent_unionₛ_of_directed {s : Set (Set M)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, LinearIndependent R (fun x => x : (a : Set M) → M)) : LinearIndependent R (fun x => x : ⋃₀ s → M) :=\n  by rw [sUnion_eq_Union] <;> exact linearIndependent_unionᵢ_of_directed hs.directed_coe (by simpa using h)\n#align linear_independent_sUnion_of_directed linearIndependent_unionₛ_of_directed\n-/\n\n",
 "linearIndependent_unionᵢ_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print linearIndependent_unionᵢ_of_directed /-\ntheorem linearIndependent_unionᵢ_of_directed {η : Type _} {s : η → Set M} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, LinearIndependent R (fun x => x : s i → M)) :\n    LinearIndependent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) → M) :=\n  by\n  by_cases hη : Nonempty η\n  · skip\n    refine'\n      linearIndependent_of_finite\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        fun t ht ft => _\n    rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩\n    rcases hs.finset_le fi.to_finset with ⟨i, hi⟩\n    exact (h i).mono (subset.trans hI <| Union₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))\n  · refine' (linearIndependent_empty _ _).mono _\n    rintro _ ⟨_, ⟨i, _⟩, _⟩\n    exact hη ⟨i⟩\n#align linear_independent_Union_of_directed linearIndependent_unionᵢ_of_directed\n-/\n\n",
 "linearIndependent_unionᵢ_finite_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print linearIndependent_unionᵢ_finite_subtype /-\ntheorem linearIndependent_unionᵢ_finite_subtype {ι : Type _} {f : ι → Set M}\n    (hl : ∀ i, LinearIndependent R (fun x => x : f i → M))\n    (hd :\n      ∀ i,\n        ∀ t : Set ι,\n          t.finite →\n            i ∉ t →\n              Disjoint (span R (f i))\n                («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n                  (span R (f i)))) :\n    LinearIndependent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) → M) :=\n  by\n  rw [Union_eq_Union_finset f]\n  apply linearIndependent_unionᵢ_of_directed\n  · apply directed_of_sup\n    exact fun t₁ t₂ ht => Union_mono fun i => Union_subset_Union_const fun h => ht h\n  intro t\n  induction' t using Finset.induction_on with i s his ih\n  · refine' (linearIndependent_empty _ _).mono _\n    simp\n  · rw [Finset.set_bunionᵢ_insert]\n    refine' (hl _).union ih _\n    rw [span_Union₂]\n    exact hd i s s.finite_to_set his\n#align linear_independent_Union_finite_subtype linearIndependent_unionᵢ_finite_subtype\n-/\n\n",
 "linearIndependent_unionᵢ_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n#print linearIndependent_unionᵢ_finite /-\ntheorem linearIndependent_unionᵢ_finite {η : Type _} {ιs : η → Type _} {f : ∀ j : η, ιs j → M}\n    (hindep : ∀ j, LinearIndependent R (f j))\n    (hd :\n      ∀ i,\n        ∀ t : Set η,\n          t.finite →\n            i ∉ t →\n              Disjoint (span R (range (f i)))\n                («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n                  (span R (range (f i))))) :\n    LinearIndependent R fun ji : Σj, ιs j => f ji.1 ji.2 :=\n  by\n  nontriviality R\n  apply LinearIndependent.of_subtype_range\n  · rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ hxy\n    by_cases h_cases : x₁ = y₁\n    subst h_cases\n    · apply sigma.eq\n      rw [LinearIndependent.injective (hindep _) hxy]\n      rfl\n    · have h0 : f x₁ x₂ = 0 :=\n        by\n        apply\n          disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) fun h => h_cases (eq_of_mem_singleton h)) (f x₁ x₂)\n            (subset_span (mem_range_self _))\n        rw [supᵢ_singleton]\n        simp only at hxy\n        rw [hxy]\n        exact subset_span (mem_range_self y₂)\n      exact false.elim ((hindep x₁).ne_zero _ h0)\n  rw [range_sigma_eq_Union_range]\n  apply linearIndependent_unionᵢ_finite_subtype (fun j => (hindep j).to_subtype_range) hd\n#align linear_independent_Union_finite linearIndependent_unionᵢ_finite\n-/\n\n",
 "linearIndependent_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print linearIndependent_sum /-\ntheorem linearIndependent_sum {v : Sum ι ι' → M} :\n    LinearIndependent R v ↔\n      LinearIndependent R (v ∘ Sum.inl) ∧\n        LinearIndependent R (v ∘ Sum.inr) ∧\n          Disjoint (Submodule.span R (range (v ∘ Sum.inl))) (Submodule.span R (range (v ∘ Sum.inr))) :=\n  by\n  rw [range_comp v, range_comp v]\n  refine'\n    ⟨fun h =>\n      ⟨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, h.disjoint_span_image is_compl_range_inl_range_inr.1⟩, _⟩\n  rintro ⟨hl, hr, hlr⟩\n  rw [linearIndependent_iff'] at *\n  intro s g hg i hi\n  have :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (s.preimage Sum.inl (sum.inl_injective.inj_on _)) ((fun x => «expr • » (g x) (v x)) (Sum.inl i)) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (s.preimage Sum.inr (sum.inr_injective.inj_on _)) ((fun x => «expr • » (g x) (v x)) (Sum.inr i)) =\n      0 :=\n    by\n    rw [Finset.sum_preimage', Finset.sum_preimage', ← Finset.sum_union, ← Finset.filter_or]\n    · simpa only [← mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]\n    · exact Finset.disjoint_filter.2 fun x _ hx => disjoint_left.1 is_compl_range_inl_range_inr.1 hx\n  · rw [← eq_neg_iff_add_eq_zero] at this\n    rw [disjoint_def'] at hlr\n    have A := hlr _ (sum_mem fun i hi => _) _ (neg_mem <| sum_mem fun i hi => _) this\n    · cases' i with i i\n      · exact hl _ _ A i (Finset.mem_preimage.2 hi)\n      · rw [this, neg_eq_zero] at A\n        exact hr _ _ A i (Finset.mem_preimage.2 hi)\n    · exact smul_mem _ _ (subset_span ⟨Sum.inl i, mem_range_self _, rfl⟩)\n    · exact smul_mem _ _ (subset_span ⟨Sum.inr i, mem_range_self _, rfl⟩)\n#align linear_independent_sum linearIndependent_sum\n-/\n\n",
 "linearIndependent_subtype_range":
 "#print linearIndependent_subtype_range /-\ntheorem linearIndependent_subtype_range {ι} {f : ι → M} (hf : injective f) :\n    LinearIndependent R (coe : range f → M) ↔ LinearIndependent R f :=\n  iff.symm <| linearIndependent_equiv' (Equiv.ofInjective f hf) rfl\n#align linear_independent_subtype_range linearIndependent_subtype_range\n-/\n\n",
 "linearIndependent_subtype_disjoint":
 "#print linearIndependent_subtype_disjoint /-\ntheorem linearIndependent_subtype_disjoint {s : Set M} :\n    LinearIndependent R (fun x => x : s → M) ↔ Disjoint (Finsupp.supported R R s) (Finsupp.total M M R id).ker := by\n  apply @linearIndependent_comp_subtype_disjoint _ _ _ id\n#align linear_independent_subtype_disjoint linearIndependent_subtype_disjoint\n-/\n\n",
 "linearIndependent_subtype":
 "#print linearIndependent_subtype /-\ntheorem linearIndependent_subtype {s : Set M} :\n    LinearIndependent R (fun x => x : s → M) ↔ ∀ l ∈ Finsupp.supported R R s, (Finsupp.total M M R id) l = 0 → l = 0 :=\n  by apply @linearIndependent_comp_subtype _ _ _ id\n#align linear_independent_subtype linearIndependent_subtype\n-/\n\n",
 "linearIndependent_span":
 "#print linearIndependent_span /-\ntheorem linearIndependent_span (hs : LinearIndependent R v) :\n    @LinearIndependent ι R (span R (range v)) (fun i : ι => ⟨v i, subset_span (mem_range_self i)⟩) _ _ _ :=\n  LinearIndependent.of_comp (span R (range v)).subtype hs\n#align linear_independent_span linearIndependent_span\n-/\n\n",
 "linearIndependent_singleton":
 "#print linearIndependent_singleton /-\ntheorem linearIndependent_singleton {x : M} (hx : x ≠ 0) : LinearIndependent R (fun x => x : ({x} : Set M) → M) :=\n  linearIndependent_unique coe hx\n#align linear_independent_singleton linearIndependent_singleton\n-/\n\n",
 "linearIndependent_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print linearIndependent_pair /-\ntheorem linearIndependent_pair {x y : V} (hx : x ≠ 0) (hy : ∀ a : K, «expr • » a x ≠ y) :\n    LinearIndependent K (coe : ({x, y} : Set V) → V) :=\n  pair_comm y x ▸ (linearIndependent_singleton hx).insert <| mt mem_span_singleton.1 (not_exists.2 hy)\n#align linear_independent_pair linearIndependent_pair\n-/\n\n",
 "linearIndependent_option'":
 "#print linearIndependent_option' /-\ntheorem linearIndependent_option' :\n    LinearIndependent K (fun o => Option.casesOn' o x v : Option ι → V) ↔\n      LinearIndependent K v ∧ x ∉ Submodule.span K (range v) :=\n  by\n  rw [← linearIndependent_equiv (Equiv.optionEquivSumPUnit ι).symm, linearIndependent_sum, @range_unique _ PUnit,\n    @linearIndependent_unique_iff PUnit, disjoint_span_singleton]\n  dsimp [(· ∘ ·)]\n  refine' ⟨fun h => ⟨h.1, fun hx => h.2.1 <| h.2.2 hx⟩, fun h => ⟨h.1, _, fun hx => (h.2 hx).elim⟩⟩\n  rintro rfl\n  exact h.2 (zero_mem _)\n#align linear_independent_option' linearIndependent_option'\n-/\n\n",
 "linearIndependent_option":
 "#print linearIndependent_option /-\ntheorem linearIndependent_option {v : Option ι → V} :\n    LinearIndependent K v ↔\n      LinearIndependent K (v ∘ coe : ι → V) ∧ v none ∉ Submodule.span K (range (v ∘ coe : ι → V)) :=\n  by simp only [← linearIndependent_option', Option.casesOn'_none_coe]\n#align linear_independent_option linearIndependent_option\n-/\n\n",
 "linearIndependent_of_subsingleton":
 "#print linearIndependent_of_subsingleton /-\n@[nontriviality]\ntheorem linearIndependent_of_subsingleton [subsingleton R] : LinearIndependent R v :=\n  linearIndependent_iff.2 fun l hl => subsingleton.elim _ _\n#align linear_independent_of_subsingleton linearIndependent_of_subsingleton\n-/\n\n",
 "linearIndependent_of_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (t «expr ⊆ » s) -/\n#print linearIndependent_of_finite /-\ntheorem linearIndependent_of_finite (s : Set M)\n    (H : ∀ (t) (_ : t ⊆ s), Set.Finite t → LinearIndependent R (fun x => x : t → M)) :\n    LinearIndependent R (fun x => x : s → M) :=\n  linearIndependent_subtype.2 fun l hl => linearIndependent_subtype.1 (H _ hl (Finset.finite_toSet _)) l (Subset.refl _)\n#align linear_independent_of_finite linearIndependent_of_finite\n-/\n\n",
 "linearIndependent_monoidHom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n#print linearIndependent_monoidHom /-\n-- See, for example, Keith Conrad's note\n--  <https://kconrad.math.uconn.edu/blurbs/galoistheory/linearchar.pdf>\n/-- Dedekind's linear independence of characters -/\ntheorem linearIndependent_monoidHom (G : Type _) [Monoid G] (L : Type _) [CommRing L] [NoZeroDivisors L] :\n    @LinearIndependent _ L (G → L) (fun f => f : «expr →* » G L → G → L) _ _ _ := by\n  letI := Classical.decEq («expr →* » G L) <;>\n      letI : MulAction L L :=\n        distrib_mul_action.to_mul_action <;>-- We prove linear independence by showing that only the trivial linear combination vanishes.\n    exact\n      linearIndependent_iff'.2-- To do this, we use `finset` induction,\n      fun s =>\n        Finset.induction_on s (fun g hg i => false.elim) fun a s has ih g hg =>\n          -- Here\n          -- * `a` is a new character we will insert into the `finset` of characters `s`,\n          -- * `ih` is the fact that only the trivial linear combination of characters in `s` is zero\n          -- * `hg` is the fact that `g` are the coefficients of a linear combination summing to zero\n          -- and it remains to prove that `g` vanishes on `insert a s`.\n          -- We now make the key calculation:\n          -- For any character `i` in the original `finset`, we have `g i • i = g i • a` as functions on the\n          -- monoid `G`.\n          have h1 : ∀ i ∈ s, («expr • » (g i) i : G → L) = «expr • » (g i) a := fun i his =>\n            funext fun x : G =>\n              -- We prove these expressions are equal by showing\n                -- the differences of their values on each monoid element `x` is zero\n                eq_of_sub_eq_zero <|\n                ih (fun j => g j * j x - g j * a x)\n                  (funext fun y : G =>\n                    calc\n                      (-- After that, it's just a chase scene.\n                              finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                              («expr • » (g i * i x - g i * a x) i : G → L))\n                            y =\n                          finset.sum\n                            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                            ((g i * i x - g i * a x) * i y) :=\n                        Finset.sum_apply _ _ _\n                      _ =\n                          finset.sum\n                            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                            (g i * i x * i y - g i * a x * i y) :=\n                        (Finset.sum_congr rfl fun _ _ => sub_mul _ _ _)\n                      _ =\n                          finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                              (g i * i x * i y) -\n                            finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                              (g i * a x * i y) :=\n                        Finset.sum_sub_distrib\n                      _ =\n                          g a * a x * a y +\n                              finset.sum\n                                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                                (g i * i x * i y) -\n                            (g a * a x * a y +\n                              finset.sum\n                                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                                (g i * a x * i y)) :=\n                        by rw [add_sub_add_left_eq_sub]\n                      _ =\n                          finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (g i * i x * i y) -\n                            finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (g i * a x * i y) :=\n                        by rw [Finset.sum_insert has, Finset.sum_insert has]\n                      _ =\n                          finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (g i * i (x * y)) -\n                            finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (a x * (g i * i y)) :=\n                        (congr (congr_arg has_sub.sub (Finset.sum_congr rfl fun i _ => by rw [i.map_mul, mul_assoc]))\n                          (Finset.sum_congr rfl fun _ _ => by rw [mul_assoc, mul_left_comm]))\n                      _ =\n                          (finset.sum\n                                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                                (insert a s) («expr • » (g i) i : G → L))\n                              (x * y) -\n                            a x *\n                              (finset.sum\n                                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                                  (insert a s) («expr • » (g i) i : G → L))\n                                y :=\n                        by rw [Finset.sum_apply, Finset.sum_apply, Finset.mul_sum] <;> rfl\n                      _ = 0 - a x * 0 := by rw [hg] <;> rfl\n                      _ = 0 := by rw [MulZeroClass.mul_zero, sub_zero]\n                      )\n                  i his\n          -- On the other hand, since `a` is not already in `s`, for any character `i ∈ s`\n          -- there is some element of the monoid on which it differs from `a`.\n          have h2 : ∀ i : «expr →* » G L, i ∈ s → ∃ y, i y ≠ a y := fun i his =>\n            by_contradiction fun h =>\n              have hia : i = a := MonoidHom.ext fun y => by_contradiction fun hy => h ⟨y, hy⟩\n              has <| hia ▸ his\n          -- From these two facts we deduce that `g` actually vanishes on `s`,\n          have h3 : ∀ i ∈ s, g i = 0 := fun i his =>\n            let ⟨y, hy⟩ := h2 i his\n            have h : «expr • » (g i) (i y) = «expr • » (g i) (a y) := congr_fun (h1 i his) y\n            or.resolve_right (mul_eq_zero.1 <| by rw [mul_sub, sub_eq_zero] <;> exact h) (sub_ne_zero_of_ne hy)\n          -- And so, using the fact that the linear combination over `s` and over `insert a s` both vanish,\n          -- we deduce that `g a = 0`.\n          have h4 : g a = 0 :=\n            calc\n              g a = g a * 1 := (mul_one _).symm\n              _ = («expr • » (g a) a : G → L) 1 := by rw [← a.map_one] <;> rfl\n              _ =\n                  (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                      (insert a s) («expr • » (g i) i : G → L))\n                    1 :=\n                by\n                rw [Finset.sum_eq_single a]\n                · intro i his hia\n                  rw [Finset.mem_insert] at his\n                  rw [h3 i (his.resolve_left hia), zero_smul]\n                · intro haas\n                  exfalso\n                  apply haas\n                  exact Finset.mem_insert_self a s\n              _ = 0 := by rw [hg] <;> rfl\n              \n          (-- Now we're done; the last two facts together imply that `g` vanishes on every element\n                -- of `insert a s`.\n                Finset.forall_mem_insert\n                _ _ _).2\n            ⟨h4, h3⟩\n#align linear_independent_monoid_hom linearIndependent_monoidHom\n-/\n\n",
 "linearIndependent_insert'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print linearIndependent_insert' /-\ntheorem linearIndependent_insert' {ι} {s : Set ι} {a : ι} {f : ι → V} (has : a ∉ s) :\n    (LinearIndependent K fun x : insert a s => f x) ↔\n      (LinearIndependent K fun x : s => f x) ∧ f a ∉ Submodule.span K («expr '' » f s) :=\n  by\n  rw [← linearIndependent_equiv ((Equiv.optionEquivSumPUnit _).trans (Equiv.Set.insert has).symm),\n    linearIndependent_option]\n  simp [(· ∘ ·), range_comp f]\n#align linear_independent_insert' linearIndependent_insert'\n-/\n\n",
 "linearIndependent_insert":
 "#print linearIndependent_insert /-\ntheorem linearIndependent_insert (hxs : x ∉ s) :\n    (LinearIndependent K fun b : insert x s => (b : V)) ↔\n      (LinearIndependent K fun b : s => (b : V)) ∧ x ∉ Submodule.span K s :=\n  (@linearIndependent_insert' _ _ _ _ _ _ _ _ id hxs).trans <| by simp\n#align linear_independent_insert linearIndependent_insert\n-/\n\n",
 "linearIndependent_inl_union_inr'":
 "#print linearIndependent_inl_union_inr' /-\ntheorem linearIndependent_inl_union_inr' {v : ι → M} {v' : ι' → M'} (hv : LinearIndependent R v)\n    (hv' : LinearIndependent R v') : LinearIndependent R (Sum.elim (inl R M M' ∘ v) (inr R M M' ∘ v')) :=\n  (hv.map' (inl R M M') ker_inl).sum_type (hv'.map' (inr R M M') ker_inr) <| by\n    refine' is_compl_range_inl_inr.disjoint.mono _ _ <;> simp only [span_le, range_coe, range_comp_subset_range]\n#align linear_independent_inl_union_inr' linearIndependent_inl_union_inr'\n-/\n\n",
 "linearIndependent_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print linearIndependent_image /-\ntheorem linearIndependent_image {ι} {s : Set ι} {f : ι → M} (hf : Set.InjOn f s) :\n    (LinearIndependent R fun x : s => f x) ↔ LinearIndependent R fun x : «expr '' » f s => (x : M) :=\n  linearIndependent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl\n#align linear_independent_image linearIndependent_image\n-/\n\n",
 "linearIndependent_iff_totalOn":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print linearIndependent_iff_totalOn /-\ntheorem linearIndependent_iff_totalOn {s : Set M} :\n    LinearIndependent R (fun x => x : s → M) ↔ (Finsupp.totalOn M M R id s).ker = «expr⊥» := by\n  rw [Finsupp.totalOn, LinearMap.ker, LinearMap.comap_codRestrict, Submodule.map_bot, comap_bot, LinearMap.ker_comp,\n    linearIndependent_subtype_disjoint, disjoint_iff_inf_le, ← map_comap_subtype, map_le_iff_le_comap, comap_bot,\n    ker_subtype, le_bot_iff]\n#align linear_independent_iff_total_on linearIndependent_iff_totalOn\n-/\n\n",
 "linearIndependent_iff_not_smul_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print linearIndependent_iff_not_smul_mem_span /-\n-- TODO: why is this so slow?\ntheorem linearIndependent_iff_not_smul_mem_span :\n    LinearIndependent R v ↔ ∀ (i : ι) (a : R), «expr • » a (v i) ∈ span R («expr '' » v (univ \\ {i})) → a = 0 :=\n  ⟨fun hv i a ha => by\n    rw [Finsupp.span_image_eq_map_total, mem_map] at ha\n    rcases ha with ⟨l, hl, e⟩\n    rw [sub_eq_zero.1 (linearIndependent_iff.1 hv (l - Finsupp.single i a) (by simp [e]))] at hl\n    by_contra hn\n    exact (not_mem_of_mem_diff (hl <| by simp [hn])) (mem_singleton _), fun H =>\n    linearIndependent_iff.2 fun l hl => by\n      ext i; simp only [Finsupp.zero_apply]\n      by_contra hn\n      refine' hn (H i _ _)\n      refine' (Finsupp.mem_span_image_iff_total _).2 ⟨Finsupp.single i (l i) - l, _, _⟩\n      · rw [Finsupp.mem_supported']\n        intro j hj\n        have hij : j = i :=\n          Classical.not_not.1 fun hij : j ≠ i => hj ((mem_diff _).2 ⟨mem_univ _, fun h => hij (eq_of_mem_singleton h)⟩)\n        simp [hij]\n      · simp [hl]⟩\n#align linear_independent_iff_not_smul_mem_span linearIndependent_iff_not_smul_mem_span\n-/\n\n",
 "linearIndependent_iff_not_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print linearIndependent_iff_not_mem_span /-\ntheorem linearIndependent_iff_not_mem_span : LinearIndependent K v ↔ ∀ i, v i ∉ span K («expr '' » v (univ \\ {i})) :=\n  by\n  apply linear_independent_iff_not_smul_mem_span.trans\n  constructor\n  · intro h i h_in_span\n    apply one_ne_zero (h i 1 (by simp [h_in_span]))\n  · intro h i a ha\n    by_contra ha'\n    exact false.elim (h _ ((smul_mem_iff _ ha').1 ha))\n#align linear_independent_iff_not_mem_span linearIndependent_iff_not_mem_span\n-/\n\n",
 "linearIndependent_iff_injective_total":
 "#print linearIndependent_iff_injective_total /-\ntheorem linearIndependent_iff_injective_total : LinearIndependent R v ↔ function.injective (Finsupp.total ι M R v) :=\n  linearIndependent_iff.trans (injective_iff_map_eq_zero (Finsupp.total ι M R v).to_add_monoid_hom).symm\n#align linear_independent_iff_injective_total linearIndependent_iff_injective_total\n-/\n\n",
 "linearIndependent_iff''":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print linearIndependent_iff'' /-\ntheorem linearIndependent_iff'' :\n    LinearIndependent R v ↔\n      ∀ (s : Finset ι) (g : ι → R) (hg : ∀ (i) (_ : i ∉ s), g i = 0),\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n              («expr • » (g i) (v i)) =\n            0 →\n          ∀ i, g i = 0 :=\n  linearIndependent_iff'.trans\n    ⟨fun H s g hg hv i => if his : i ∈ s then H s g hv i his else hg i his, fun H s g hg i hi =>\n      by\n      convert H s (fun j => if j ∈ s then g j else 0) (fun j hj => if_neg hj)\n          (by simp_rw [ite_smul, zero_smul, Finset.sum_extend_by_zero, hg]) i\n      exact (if_pos hi).symm⟩\n#align linear_independent_iff'' linearIndependent_iff''\n-/\n\n",
 "linearIndependent_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Fintype.linearIndependent_iff' /-\n/-- A finite family of vectors `v i` is linear independent iff the linear map that sends\n`c : ι → R` to `∑ i, c i • v i` has the trivial kernel. -/\ntheorem Fintype.linearIndependent_iff' [Fintype ι] :\n    LinearIndependent R v ↔\n      (LinearMap.lsum R (fun i : ι => R) ℕ fun i => LinearMap.id.smul_right (v i)).ker = «expr⊥» :=\n  by simp [Fintype.linearIndependent_iff, LinearMap.ker_eq_bot', funext_iff] <;> skip\n#align fintype.linear_independent_iff' Fintype.linearIndependent_iff'\n-/\n\n",
 "linearIndependent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print LinearMap.linearIndependent_iff /-\n/-- If `f` is an injective linear map, then the family `f ∘ v` is linearly independent\nif and only if the family `v` is linearly independent. -/\nprotected theorem LinearMap.linearIndependent_iff (f : «expr →ₗ[ ] » M R M') (hf_inj : f.ker = «expr⊥») :\n    LinearIndependent R (f ∘ v) ↔ LinearIndependent R v :=\n  ⟨fun h => h.of_comp f, fun h => h.map <| by simp only [hf_inj, disjoint_bot_right]⟩\n#align linear_map.linear_independent_iff LinearMap.linearIndependent_iff\n-/\n\n",
 "linearIndependent_finset_map_embedding_subtype":
 "#print linearIndependent_finset_map_embedding_subtype /-\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem linearIndependent_finset_map_embedding_subtype (s : Set M) (li : LinearIndependent R (coe : s → M))\n    (t : Finset s) : LinearIndependent R (coe : Finset.map (Embedding.subtype s) t → M) :=\n  by\n  let f : t.map (embedding.subtype s) → s := fun x =>\n    ⟨x.1, by\n      obtain ⟨x, h⟩ := x\n      rw [Finset.mem_map] at h\n      obtain ⟨a, ha, rfl⟩ := h\n      simp only [Subtype.coe_prop, embedding.coe_subtype]⟩\n  convert LinearIndependent.comp li f _\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  rw [Finset.mem_map] at hx hy\n  obtain ⟨a, ha, rfl⟩ := hx\n  obtain ⟨b, hb, rfl⟩ := hy\n  simp only [imp_self, Subtype.mk_eq_mk]\n#align linear_independent_finset_map_embedding_subtype linearIndependent_finset_map_embedding_subtype\n-/\n\n",
 "linearIndependent_fin_succ'":
 "#print linearIndependent_fin_succ' /-\ntheorem linearIndependent_fin_succ' {n} {v : Fin (n + 1) → V} :\n    LinearIndependent K v ↔\n      LinearIndependent K (Fin.init v) ∧ v (Fin.last _) ∉ Submodule.span K (range <| Fin.init v) :=\n  by rw [← linearIndependent_fin_snoc, Fin.snoc_init_self]\n#align linear_independent_fin_succ' linearIndependent_fin_succ'\n-/\n\n",
 "linearIndependent_fin_succ":
 "#print linearIndependent_fin_succ /-\ntheorem linearIndependent_fin_succ {n} {v : Fin (n + 1) → V} :\n    LinearIndependent K v ↔ LinearIndependent K (Fin.tail v) ∧ v 0 ∉ Submodule.span K (range <| Fin.tail v) := by\n  rw [← linearIndependent_fin_cons, Fin.cons_self_tail]\n#align linear_independent_fin_succ linearIndependent_fin_succ\n-/\n\n",
 "linearIndependent_fin_snoc":
 "#print linearIndependent_fin_snoc /-\ntheorem linearIndependent_fin_snoc {n} {v : Fin n → V} :\n    LinearIndependent K (Fin.snoc v x : Fin (n + 1) → V) ↔ LinearIndependent K v ∧ x ∉ Submodule.span K (range v) := by\n  rw [Fin.snoc_eq_cons_rotate, linearIndependent_equiv, linearIndependent_fin_cons]\n#align linear_independent_fin_snoc linearIndependent_fin_snoc\n-/\n\n",
 "linearIndependent_fin_cons":
 "#print linearIndependent_fin_cons /-\ntheorem linearIndependent_fin_cons {n} {v : Fin n → V} :\n    LinearIndependent K (Fin.cons x v : Fin (n + 1) → V) ↔ LinearIndependent K v ∧ x ∉ Submodule.span K (range v) :=\n  by\n  rw [← linearIndependent_equiv (finSuccEquiv n).symm, linearIndependent_option]\n  convert iff.rfl\n  · ext\n    -- TODO: why doesn't simp use `fin_succ_equiv_symm_coe` here?\n    rw [comp_app, comp_app, finSuccEquiv_symm_some, Fin.cons_succ]\n  · ext\n    rw [comp_app, comp_app, finSuccEquiv_symm_some, Fin.cons_succ]\n#align linear_independent_fin_cons linearIndependent_fin_cons\n-/\n\n",
 "linearIndependent_fin2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print linearIndependent_fin2 /-\ntheorem linearIndependent_fin2 {f : Fin 2 → V} : LinearIndependent K f ↔ f 1 ≠ 0 ∧ ∀ a : K, «expr • » a (f 1) ≠ f 0 :=\n  by\n  rw [linearIndependent_fin_succ, linearIndependent_unique_iff, range_unique, mem_span_singleton, not_exists,\n    show Fin.tail f default = f 1 by rw [← Fin.succ_zero_eq_one] <;> rfl]\n#align linear_independent_fin2 linearIndependent_fin2\n-/\n\n",
 "linearIndependent_extend":
 "#print LinearIndependent.linearIndependent_extend /-\ntheorem LinearIndependent.linearIndependent_extend (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    LinearIndependent K (coe : hs.extend hst → V) :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  hli\n#align linear_independent.linear_independent_extend LinearIndependent.linearIndependent_extend\n-/\n\n",
 "linearIndependent_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print linearIndependent_equiv' /-\ntheorem linearIndependent_equiv' (e : «expr ≃ » ι ι') {f : ι' → M} {g : ι → M} (h : f ∘ e = g) :\n    LinearIndependent R g ↔ LinearIndependent R f :=\n  h ▸ linearIndependent_equiv e\n#align linear_independent_equiv' linearIndependent_equiv'\n-/\n\n",
 "linearIndependent_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n#print linearIndependent_equiv /-\ntheorem linearIndependent_equiv (e : «expr ≃ » ι ι') {f : ι' → M} :\n    LinearIndependent R (f ∘ e) ↔ LinearIndependent R f :=\n  ⟨fun h => function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.injective, fun h => h.comp _ e.injective⟩\n#align linear_independent_equiv linearIndependent_equiv\n-/\n\n",
 "linearIndependent_empty_type":
 "#print linearIndependent_empty_type /-\ntheorem linearIndependent_empty_type [IsEmpty ι] : LinearIndependent R v :=\n  linearIndependent_iff.mpr fun v hv => subsingleton.elim v 0\n#align linear_independent_empty_type linearIndependent_empty_type\n-/\n\n",
 "linearIndependent_empty":
 "#print linearIndependent_empty /-\ntheorem linearIndependent_empty : LinearIndependent R (fun x => x : (∅ : Set M) → M) := by\n  simp [linearIndependent_subtype_disjoint]\n#align linear_independent_empty linearIndependent_empty\n-/\n\n",
 "linearIndependent_comp_subtype_disjoint":
 "#print linearIndependent_comp_subtype_disjoint /-\ntheorem linearIndependent_comp_subtype_disjoint {s : Set ι} :\n    LinearIndependent R (v ∘ coe : s → M) ↔ Disjoint (Finsupp.supported R R s) (Finsupp.total ι M R v).ker := by\n  rw [linearIndependent_comp_subtype, LinearMap.disjoint_ker]\n#align linear_independent_comp_subtype_disjoint linearIndependent_comp_subtype_disjoint\n-/\n\n",
 "linearIndependent_comp_subtype":
 "#print linearIndependent_comp_subtype /-\ntheorem linearIndependent_comp_subtype {s : Set ι} :\n    LinearIndependent R (v ∘ coe : s → M) ↔ ∀ l ∈ Finsupp.supported R R s, (Finsupp.total ι M R v) l = 0 → l = 0 :=\n  by\n  simp only [linearIndependent_iff, (· ∘ ·), Finsupp.mem_supported, Finsupp.total_apply, Set.subset_def, Finset.mem_coe]\n  constructor\n  · intro h l hl₁ hl₂\n    have := h (l.subtype_domain s) ((Finsupp.sum_subtypeDomain_index hl₁).trans hl₂)\n    exact (Finsupp.subtypeDomain_eq_zero_iff hl₁).1 this\n  · intro h l hl\n    refine' Finsupp.embDomain_eq_zero.1 (h (l.emb_domain <| Function.Embedding.subtype s) _ _)\n    · suffices ∀ i hi, ¬l ⟨i, hi⟩ = 0 → i ∈ s by simpa\n      intros\n      assumption\n    · rwa [Finsupp.embDomain_eq_mapDomain, Finsupp.sum_mapDomain_index]\n      exacts[fun _ => zero_smul _ _, fun _ _ _ => add_smul _ _ _]\n#align linear_independent_comp_subtype linearIndependent_comp_subtype\n-/\n\n",
 "linearIndependent_bunionᵢ_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print linearIndependent_bunionᵢ_of_directed /-\ntheorem linearIndependent_bunionᵢ_of_directed {η} {s : Set η} {t : η → Set M}\n    (hs : DirectedOn («expr ⁻¹'o » t (· ⊆ ·)) s) (h : ∀ a ∈ s, LinearIndependent R (fun x => x : t a → M)) :\n    LinearIndependent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t a) → M) :=\n  by\n  rw [bUnion_eq_Union] <;>\n    exact linearIndependent_unionᵢ_of_directed (directed_comp.2 <| hs.directed_coe) (by simpa using h)\n#align linear_independent_bUnion_of_directed linearIndependent_bunionᵢ_of_directed\n-/\n\n",
 "linearIndependent_bounded_of_finset_linearIndependent_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print linearIndependent_bounded_of_finset_linearIndependent_bounded /-\n/-- If every finite set of linearly independent vectors has cardinality at most `n`,\nthen the same is true for arbitrary sets of linearly independent vectors.\n-/\ntheorem linearIndependent_bounded_of_finset_linearIndependent_bounded {n : ℕ}\n    (H : ∀ s : Finset M, (LinearIndependent R fun i : s => (i : M)) → s.card ≤ n) :\n    ∀ s : Set M, LinearIndependent R (coe : s → M) → cardinal.mk s ≤ n :=\n  by\n  intro s li\n  apply Cardinal.card_le_of\n  intro t\n  rw [← Finset.card_map (embedding.subtype s)]\n  apply H\n  apply linearIndependent_finset_map_embedding_subtype _ li\n#align linear_independent_bounded_of_finset_linear_independent_bounded linearIndependent_bounded_of_finset_linearIndependent_bounded\n-/\n\n",
 "linearDependent_comp_subtype'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print linearDependent_comp_subtype' /-\ntheorem linearDependent_comp_subtype' {s : Set ι} :\n    ¬LinearIndependent R (v ∘ coe : s → M) ↔\n      ∃ f : «expr →₀ » ι R, f ∈ Finsupp.supported R R s ∧ Finsupp.total ι M R v f = 0 ∧ f ≠ 0 :=\n  by simp [linearIndependent_comp_subtype]\n#align linear_dependent_comp_subtype' linearDependent_comp_subtype'\n-/\n\n",
 "linearDependent_comp_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print linearDependent_comp_subtype /-\n/-- A version of `linear_dependent_comp_subtype'` with `finsupp.total` unfolded. -/\ntheorem linearDependent_comp_subtype {s : Set ι} :\n    ¬LinearIndependent R (v ∘ coe : s → M) ↔\n      ∃ f : «expr →₀ » ι R,\n        f ∈ Finsupp.supported R R s ∧\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.support\n                («expr • » (f i) (v i)) =\n              0 ∧\n            f ≠ 0 :=\n  linearDependent_comp_subtype'\n#align linear_dependent_comp_subtype linearDependent_comp_subtype\n-/\n\n",
 "le_of_span_le_span":
 "#print le_of_span_le_span /-\ntheorem le_of_span_le_span [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R (coe : u → M)) (hsu : s ⊆ u)\n    (htu : t ⊆ u) (hst : span R s ≤ span R t) : s ⊆ t :=\n  by\n  have :=\n    eq_of_linearIndependent_of_span_subtype (hl.mono (Set.union_subset hsu htu)) (Set.subset_union_right _ _)\n      (Set.union_subset (Set.Subset.trans subset_span hst) subset_span)\n  rw [← this]; apply Set.subset_union_left\n#align le_of_span_le_span le_of_span_le_span\n-/\n\n",
 "insert":
 "#print LinearIndependent.insert /-\ntheorem LinearIndependent.insert (hs : LinearIndependent K (fun b => b : s → V)) (hx : x ∉ span K s) :\n    LinearIndependent K (fun b => b : insert x s → V) :=\n  by\n  rw [← union_singleton]\n  have x0 : x ≠ 0 := mt (by rintro rfl <;> apply zero_mem (span K s)) hx\n  apply hs.union (linearIndependent_singleton x0)\n  rwa [disjoint_span_singleton' x0]\n#align linear_independent.insert LinearIndependent.insert\n-/\n\n",
 "inl_union_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.inl_union_inr /-\ntheorem LinearIndependent.inl_union_inr {s : Set M} {t : Set M'} (hs : LinearIndependent R (fun x => x : s → M))\n    (ht : LinearIndependent R (fun x => x : t → M')) :\n    LinearIndependent R (fun x => x : «expr '' » (inl R M M') s ∪ «expr '' » (inr R M M') t → M × M') :=\n  by\n  refine' (hs.image_subtype _).union (ht.image_subtype _) _ <;> [simp, simp, skip]\n  simp only [span_image]\n  simp [disjoint_iff, prod_inf_prod]\n#align linear_independent.inl_union_inr LinearIndependent.inl_union_inr\n-/\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n#print LinearIndependent.injective /-\ntheorem LinearIndependent.injective [Nontrivial R] (hv : LinearIndependent R v) : injective v :=\n  by\n  intro i j hij\n  let l : «expr →₀ » ι R := Finsupp.single i (1 : R) - Finsupp.single j 1\n  have h_total : Finsupp.total ι M R v l = 0 :=\n    by\n    simp_rw [LinearMap.map_sub, Finsupp.total_apply]\n    simp [hij]\n  have h_single_eq : Finsupp.single i (1 : R) = Finsupp.single j 1 :=\n    by\n    rw [linearIndependent_iff] at hv\n    simp [eq_add_of_sub_eq' (hv l h_total)]\n  simpa [Finsupp.single_eq_single_iff] using h_single_eq\n#align linear_independent.injective LinearIndependent.injective\n-/\n\n",
 "independent_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n#print LinearIndependent.independent_span_singleton /-\n/-- See also `complete_lattice.independent_iff_linear_independent_of_ne_zero`. -/\ntheorem LinearIndependent.independent_span_singleton (hv : LinearIndependent R v) :\n    CompleteLattice.Independent fun i => «expr ∙ » R (v i) :=\n  by\n  refine' complete_lattice.independent_def.mp fun i => _\n  rw [disjoint_iff_inf_le]\n  intro m hm\n  simp only [mem_inf, mem_span_singleton, supᵢ_subtype', ← span_range_eq_supr] at hm\n  obtain ⟨⟨r, rfl⟩, hm⟩ := hm\n  suffices r = 0 by simp [this]\n  apply linear_independent_iff_not_smul_mem_span.mp hv i\n  convert hm\n  ext\n  simp\n#align linear_independent.independent_span_singleton LinearIndependent.independent_span_singleton\n-/\n\n",
 "image_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.image_subtype /-\ntheorem LinearIndependent.image_subtype {s : Set M} {f : «expr →ₗ[ ] » M R M'}\n    (hs : LinearIndependent R (fun x => x : s → M)) (hf_inj : Disjoint (span R s) f.ker) :\n    LinearIndependent R (fun x => x : «expr '' » f s → M') :=\n  by\n  rw [← @Subtype.range_coe _ s] at hf_inj\n  refine' (hs.map hf_inj).to_subtype_range' _\n  simp [Set.range_comp f]\n#align linear_independent.image_subtype LinearIndependent.image_subtype\n-/\n\n",
 "image_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.image_of_comp /-\ntheorem LinearIndependent.image_of_comp {ι ι'} (s : Set ι) (f : ι → ι') (g : ι' → M)\n    (hs : LinearIndependent R fun x : s => g (f x)) : LinearIndependent R fun x : «expr '' » f s => g x :=\n  by\n  nontriviality R\n  have : inj_on f s := inj_on_iff_injective.2 hs.injective.of_comp\n  exact (linearIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n#align linear_independent.image_of_comp LinearIndependent.image_of_comp\n-/\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.image /-\ntheorem LinearIndependent.image {ι} {s : Set ι} {f : ι → M} (hs : LinearIndependent R fun x : s => f x) :\n    LinearIndependent R fun x : «expr '' » f s => (x : M) := by convert LinearIndependent.image_of_comp s f id hs\n#align linear_independent.image LinearIndependent.image\n-/\n\n",
 "group_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print LinearIndependent.group_smul /-\ntheorem LinearIndependent.group_smul {G : Type _} [hG : Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] [SMulCommClass G R M] {v : ι → M} (hv : LinearIndependent R v) (w : ι → G) :\n    LinearIndependent R («expr • » w v) :=\n  by\n  rw [linearIndependent_iff''] at hv⊢\n  intro s g hgs hsum i\n  refine' (smul_eq_zero_iff_eq (w i)).1 _\n  refine' hv s (fun i => «expr • » (w i) (g i)) (fun i hi => _) _ i\n  · dsimp only\n    exact (hgs i hi).symm ▸ smul_zero _\n  · rw [← hsum, Finset.sum_congr rfl _]\n    intros\n    erw [Pi.smul_apply, smul_assoc, smul_comm]\n#align linear_independent.group_smul LinearIndependent.group_smul\n-/\n\n",
 "fin_cons'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print LinearIndependent.fin_cons' /-\n/-- See `linear_independent.fin_cons` for a family of elements in a vector space. -/\ntheorem LinearIndependent.fin_cons' {m : ℕ} (x : M) (v : Fin m → M) (hli : LinearIndependent R v)\n    (x_ortho : ∀ (c : R) (y : Submodule.span R (Set.range v)), «expr • » c x + y = (0 : M) → c = 0) :\n    LinearIndependent R (Fin.cons x v : Fin m.succ → M) :=\n  by\n  rw [Fintype.linearIndependent_iff] at hli⊢\n  rintro g total_eq j\n  simp_rw [Fin.sum_univ_succ, Fin.cons_zero, Fin.cons_succ] at total_eq\n  have : g 0 = 0 :=\n    by\n    refine'\n      x_ortho (g 0)\n        ⟨finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (g i.succ) (v i)),\n          _⟩\n        total_eq\n    exact sum_mem fun i _ => smul_mem _ _ (subset_span ⟨i, rfl⟩)\n  rw [this, zero_smul, zero_add] at total_eq\n  exact Fin.cases this (hli _ total_eq) j\n#align linear_independent.fin_cons' LinearIndependent.fin_cons'\n-/\n\n",
 "fin_cons":
 "#print LinearIndependent.fin_cons /-\n/-- See `linear_independent.fin_cons'` for an uglier version that works if you\nonly have a module over a semiring. -/\ntheorem LinearIndependent.fin_cons {n} {v : Fin n → V} (hv : LinearIndependent K v)\n    (hx : x ∉ Submodule.span K (range v)) : LinearIndependent K (Fin.cons x v : Fin (n + 1) → V) :=\n  linearIndependent_fin_cons.2 ⟨hv, hx⟩\n#align linear_independent.fin_cons LinearIndependent.fin_cons\n-/\n\n",
 "extend_subset":
 "#print LinearIndependent.extend_subset /-\ntheorem LinearIndependent.extend_subset (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    hs.extend hst ⊆ t :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linearIndependent_extension hs hst)\n  hbt\n#align linear_independent.extend_subset LinearIndependent.extend_subset\n-/\n\n",
 "exists_of_linearIndependent_of_finite_span":
 "#print exists_of_linearIndependent_of_finite_span /-\n-- TODO(Mario): rewrite?\ntheorem exists_of_linearIndependent_of_finite_span {t : Finset V} (hs : LinearIndependent K (fun x => x : s → V))\n    (hst : s ⊆ (span K ↑t : Submodule K V)) : ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = t.card :=\n  by\n  have :\n    ∀ t,\n      ∀ s' : Finset V,\n        ↑s' ⊆ s →\n          s ∩ ↑t = ∅ →\n            s ⊆ (span K ↑(s' ∪ t) : Submodule K V) →\n              ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = (s' ∪ t).card :=\n    fun t =>\n    Finset.induction_on t\n      (fun s' hs' _ hss' =>\n        have : s = ↑s' := eq_of_linearIndependent_of_span_subtype hs hs' <| by simpa using hss'\n        ⟨s', by simp [this]⟩)\n      fun b₁ t hb₁t ih s' hs' hst hss' =>\n      have hb₁s : b₁ ∉ s := fun h =>\n        by\n        have : b₁ ∈ s ∩ ↑(insert b₁ t) := ⟨h, Finset.mem_insert_self _ _⟩\n        rwa [hst] at this\n      have hb₁s' : b₁ ∉ s' := fun h => hb₁s <| hs' h\n      have hst : s ∩ ↑t = ∅ :=\n        eq_empty_of_subset_empty <| Subset.trans (by simp [inter_subset_inter, subset.refl]) (le_of_eq hst)\n      by_cases\n        (fun this : s ⊆ (span K ↑(s' ∪ t) : Submodule K V) =>\n          let ⟨u, hust, hsu, Eq⟩ := ih _ hs' hst this\n          have hb₁u : b₁ ∉ u := fun h => (hust h).elim hb₁s hb₁t\n          ⟨insert b₁ u, by simp [insert_subset_insert hust], Subset.trans hsu (by simp), by\n            simp [Eq, hb₁t, hb₁s', hb₁u]⟩)\n        fun this : ¬s ⊆ (span K ↑(s' ∪ t) : Submodule K V) =>\n        let ⟨b₂, hb₂s, hb₂t⟩ := not_subset.mp this\n        have hb₂t' : b₂ ∉ s' ∪ t := fun h => hb₂t <| subset_span h\n        have : s ⊆ (span K ↑(insert b₂ s' ∪ t) : Submodule K V) := fun b₃ hb₃ =>\n          by\n          have : ↑(s' ∪ insert b₁ t) ⊆ insert b₁ (insert b₂ ↑(s' ∪ t) : Set V) := by\n            simp [insert_eq, -singleton_union, -union_singleton, union_subset_union, subset.refl, subset_union_right]\n          have hb₃ : b₃ ∈ span K (insert b₁ (insert b₂ ↑(s' ∪ t) : Set V)) := span_mono this (hss' hb₃)\n          have : s ⊆ (span K (insert b₁ ↑(s' ∪ t)) : Submodule K V) := by\n            simpa [insert_eq, -singleton_union, -union_singleton] using hss'\n          have hb₁ : b₁ ∈ span K (insert b₂ ↑(s' ∪ t)) := mem_span_insert_exchange (this hb₂s) hb₂t\n          rw [span_insert_eq_span hb₁] at hb₃ <;> simpa using hb₃\n        let ⟨u, hust, hsu, Eq⟩ := ih _ (by simp [insert_subset, hb₂s, hs']) hst this\n        ⟨u, Subset.trans hust <| union_subset_union (Subset.refl _) (by simp [subset_insert]), hsu, by\n          simp [Eq, hb₂t', hb₁t, hb₁s']⟩\n  have eq : ((t.filter fun x => x ∈ s) ∪ t.filter fun x => x ∉ s) = t :=\n    by\n    ext1 x\n    by_cases x ∈ s <;> simp [*]\n  apply\n    exists.elim\n      (this (t.filter fun x => x ∉ s) (t.filter fun x => x ∈ s) (by simp [Set.subset_def])\n        (by simp (config := { contextual := true }) [Set.ext_iff]) (by rwa [Eq]))\n  intro u h\n  exact\n    ⟨u, subset.trans h.1 (by simp (config := { contextual := true }) [subset_def, and_imp, or_imp]), h.2.1, by\n      simp only [h.2.2, Eq]⟩\n#align exists_of_linear_independent_of_finite_span exists_of_linearIndependent_of_finite_span\n-/\n\n",
 "exists_maximal_independent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n#print exists_maximal_independent' /-\ntheorem exists_maximal_independent' (s : ι → M) :\n    ∃ I : Set ι,\n      (LinearIndependent R fun x : I => s x) ∧ ∀ J : Set ι, I ⊆ J → (LinearIndependent R fun x : J => s x) → I = J :=\n  by\n  let indep : Set ι → Prop := fun I => LinearIndependent R (s ∘ coe : I → M)\n  let X := { I : Set ι // indep I }\n  let r : X → X → Prop := fun I J => I.1 ⊆ J.1\n  have key :\n    ∀ c : Set X,\n      IsChain r c →\n        indep («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" I) :=\n    by\n    intro c hc\n    dsimp [indep]\n    rw [linearIndependent_comp_subtype]\n    intro f hsupport hsum\n    rcases eq_empty_or_nonempty c with (rfl | hn)\n    · simpa using hsupport\n    haveI : is_refl X r := ⟨fun _ => Set.Subset.refl _⟩\n    obtain ⟨I, I_mem, hI⟩ : ∃ I ∈ c, (f.support : Set ι) ⊆ I :=\n      hc.directed_on.exists_mem_subset_of_finset_subset_bUnion hn hsupport\n    exact linear_independent_comp_subtype.mp I.2 f hI hsum\n  have trans : transitive r := fun I J K => Set.Subset.trans\n  obtain ⟨⟨I, hli : indep I⟩, hmax : ∀ a, r ⟨I, hli⟩ a → r a ⟨I, hli⟩⟩ :=\n    @exists_maximal_of_chains_bounded _ r\n      (fun c hc =>\n        ⟨⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (I : Set ι),\n            key c hc⟩,\n          fun I => Set.subset_bunionᵢ_of_mem⟩)\n      trans\n  exact ⟨I, hli, fun J hsub hli => Set.Subset.antisymm hsub (hmax ⟨J, hli⟩ hsub)⟩\n#align exists_maximal_independent' exists_maximal_independent'\n-/\n\n",
 "exists_maximal_independent":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (i «expr ∉ » I) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print exists_maximal_independent /-\ntheorem exists_maximal_independent (s : ι → M) :\n    ∃ I : Set ι,\n      (LinearIndependent R fun x : I => s x) ∧\n        ∀ (i) (_ : i ∉ I), ∃ a : R, a ≠ 0 ∧ «expr • » a (s i) ∈ span R («expr '' » s I) :=\n  by\n  classical\n    rcases exists_maximal_independent' R s with ⟨I, hIlinind, hImaximal⟩\n    use I, hIlinind\n    intro i hi\n    specialize hImaximal (I ∪ {i}) (by simp)\n    set J := I ∪ {i} with hJ\n    have memJ : ∀ {x}, x ∈ J ↔ x = i ∨ x ∈ I := by simp [hJ]\n    have hiJ : i ∈ J := by simp\n    have h := mt hImaximal _\n    swap\n    · intro h2\n      rw [h2] at hi\n      exact absurd hiJ hi\n    obtain ⟨f, supp_f, sum_f, f_ne⟩ := linear_dependent_comp_subtype.mp h\n    have hfi : f i ≠ 0 := by\n      contrapose hIlinind\n      refine' linear_dependent_comp_subtype.mpr ⟨f, _, sum_f, f_ne⟩\n      simp only [Finsupp.mem_supported, hJ] at supp_f⊢\n      rintro x hx\n      refine' (memJ.mp (supp_f hx)).resolve_left _\n      rintro rfl\n      exact hIlinind (finsupp.mem_support_iff.mp hx)\n    use f i, hfi\n    have hfi' : i ∈ f.support := finsupp.mem_support_iff.mpr hfi\n    rw [← Finset.insert_erase hfi', Finset.sum_insert (Finset.not_mem_erase _ _), add_eq_zero_iff_eq_neg] at sum_f\n    rw [sum_f]\n    refine' neg_mem (sum_mem fun c hc => smul_mem _ _ (subset_span ⟨c, _, rfl⟩))\n    exact (memJ.mp (supp_f (Finset.erase_subset _ _ hc))).resolve_left (Finset.ne_of_mem_erase hc)\n#align exists_maximal_independent exists_maximal_independent\n-/\n\n",
 "exists_linearIndependent_extension":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b «expr ⊆ » t) -/\n#print exists_linearIndependent_extension /-\ntheorem exists_linearIndependent_extension (hs : LinearIndependent K (coe : s → V)) (hst : s ⊆ t) :\n    ∃ (b : _)(_ : b ⊆ t), s ⊆ b ∧ t ⊆ span K b ∧ LinearIndependent K (coe : b → V) :=\n  by\n  rcases zorn_subset_nonempty { b | b ⊆ t ∧ LinearIndependent K (coe : b → V) } _ _ ⟨hst, hs⟩ with ⟨b, ⟨bt, bi⟩, sb, h⟩\n  · refine' ⟨b, bt, sb, fun x xt => _, bi⟩\n    by_contra hn\n    apply hn\n    rw [← h _ ⟨insert_subset.2 ⟨xt, bt⟩, bi.insert hn⟩ (subset_insert _ _)]\n    exact subset_span (mem_insert _ _)\n  · refine' fun c hc cc c0 => ⟨⋃₀ c, ⟨_, _⟩, fun x => _⟩\n    · exact sUnion_subset fun x xc => (hc xc).1\n    · exact linearIndependent_unionₛ_of_directed cc.directed_on fun x xc => (hc xc).2\n    · exact subset_sUnion_of_mem\n#align exists_linear_independent_extension exists_linearIndependent_extension\n-/\n\n",
 "exists_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b «expr ⊆ » t) -/\n#print exists_linearIndependent /-\ntheorem exists_linearIndependent : ∃ (b : _)(_ : b ⊆ t), span K b = span K t ∧ LinearIndependent K (coe : b → V) :=\n  by\n  obtain ⟨b, hb₁, -, hb₂, hb₃⟩ := exists_linearIndependent_extension (linearIndependent_empty K V) (Set.empty_subset t)\n  exact ⟨b, hb₁, (span_eq_of_le _ hb₂ (Submodule.span_mono hb₁)).symm, hb₃⟩\n#align exists_linear_independent exists_linearIndependent\n-/\n\n",
 "exists_finite_card_le_of_finite_of_linearIndependent_of_span":
 "#print exists_finite_card_le_of_finite_of_linearIndependent_of_span /-\ntheorem exists_finite_card_le_of_finite_of_linearIndependent_of_span (ht : t.finite)\n    (hs : LinearIndependent K (fun x => x : s → V)) (hst : s ⊆ span K t) :\n    ∃ h : s.finite, h.to_finset.card ≤ ht.to_finset.card :=\n  have : s ⊆ (span K ↑ht.to_finset : Submodule K V) := by simp <;> assumption\n  let ⟨u, hust, hsu, Eq⟩ := exists_of_linearIndependent_of_finite_span hs this\n  have : s.finite := u.finite_to_set.subset hsu\n  ⟨this, by rw [← Eq] <;> exact Finset.card_le_of_subset <| finset.coe_subset.mp <| by simp [hsu]⟩\n#align exists_finite_card_le_of_finite_of_linear_independent_of_span exists_finite_card_le_of_finite_of_linearIndependent_of_span\n-/\n\n",
 "eq_of_smul_apply_eq_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print LinearIndependent.eq_of_smul_apply_eq_smul_apply /-\n/-- Linear independent families are injective, even if you multiply either side. -/\ntheorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type _} [AddCommGroup M] [Module R M] {v : ι → M}\n    (li : LinearIndependent R v) (c d : R) (i j : ι) (hc : c ≠ 0) (h : «expr • » c (v i) = «expr • » d (v j)) : i = j :=\n  by\n  let l : «expr →₀ » ι R := Finsupp.single i c - Finsupp.single j d\n  have h_total : Finsupp.total ι M R v l = 0 :=\n    by\n    simp_rw [LinearMap.map_sub, Finsupp.total_apply]\n    simp [h]\n  have h_single_eq : Finsupp.single i c = Finsupp.single j d :=\n    by\n    rw [linearIndependent_iff] at li\n    simp [eq_add_of_sub_eq' (li l h_total)]\n  rcases(Finsupp.single_eq_single_iff _ _ _ _).mp h_single_eq with (⟨this, _⟩ | ⟨hc, _⟩)\n  · exact this\n  · contradiction\n#align linear_independent.eq_of_smul_apply_eq_smul_apply LinearIndependent.eq_of_smul_apply_eq_smul_apply\n-/\n\n",
 "eq_of_linearIndependent_of_span_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n#print eq_of_linearIndependent_of_span_subtype /-\ntheorem eq_of_linearIndependent_of_span_subtype [Nontrivial R] {s t : Set M}\n    (hs : LinearIndependent R (fun x => x : s → M)) (h : t ⊆ s) (hst : s ⊆ span R t) : s = t :=\n  by\n  let f : «expr ↪ » t s := ⟨fun x => ⟨x.1, h x.2⟩, fun a b hab => Subtype.coe_injective (subtype.mk.inj hab)⟩\n  have h_surj : surjective f := by\n    apply surjective_of_linearIndependent_of_span hs f _\n    convert hst <;> simp [f, comp]\n  show s = t\n  · apply subset.antisymm _ h\n    intro x hx\n    rcases h_surj ⟨x, hx⟩ with ⟨y, hy⟩\n    convert y.mem\n    rw [← subtype.mk.inj hy]\n    rfl\n#align eq_of_linear_independent_of_span_subtype eq_of_linearIndependent_of_span_subtype\n-/\n\n",
 "disjoint_span_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n#print LinearIndependent.disjoint_span_image /-\ntheorem LinearIndependent.disjoint_span_image (hv : LinearIndependent R v) {s t : Set ι} (hs : Disjoint s t) :\n    Disjoint (Submodule.span R <| «expr '' » v s) (Submodule.span R <| «expr '' » v t) :=\n  by\n  simp only [disjoint_def, Finsupp.mem_span_image_iff_total]\n  rintro _ ⟨l₁, hl₁, rfl⟩ ⟨l₂, hl₂, H⟩\n  rw [hv.injective_total.eq_iff] at H; subst l₂\n  have : l₁ = 0 := submodule.disjoint_def.mp (Finsupp.disjoint_supported_supported hs) _ hl₁ hl₂\n  simp [this]\n#align linear_independent.disjoint_span_image LinearIndependent.disjoint_span_image\n-/\n\n",
 "comp":
 "#print LinearIndependent.comp /-\n/-- A subfamily of a linearly independent family (i.e., a composition with an injective map) is a\nlinearly independent family. -/\ntheorem LinearIndependent.comp (h : LinearIndependent R v) (f : ι' → ι) (hf : injective f) :\n    LinearIndependent R (v ∘ f) := by\n  rw [linearIndependent_iff, Finsupp.total_comp]\n  intro l hl\n  have h_map_domain : ∀ x, (Finsupp.mapDomain f l) (f x) = 0 := by\n    rw [linearIndependent_iff.1 h (Finsupp.mapDomain f l) hl] <;> simp\n  ext x\n  convert h_map_domain x\n  rw [Finsupp.mapDomain_apply hf]\n#align linear_independent.comp LinearIndependent.comp\n-/\n\n",
 "coe_range":
 "#print LinearIndependent.coe_range /-\ntheorem LinearIndependent.coe_range (i : LinearIndependent R v) : LinearIndependent R (coe : range v → M) := by\n  simpa using i.comp _ (range_splitting_injective v)\n#align linear_independent.coe_range LinearIndependent.coe_range\n-/\n\n"}