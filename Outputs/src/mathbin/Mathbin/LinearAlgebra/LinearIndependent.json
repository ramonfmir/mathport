{"units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- This lemma cannot be proved with `linear_independent.group_smul` since the action of\n-- `Rˣ` on `R` is not commutative.\ntheorem linear_independent.units_smul {v : ι → M} (hv : linear_independent R v) (w : ι → «expr ˣ» R) :\n    linear_independent R («expr • » w v) :=\n  by\n  rw [linear_independent_iff''] at hv⊢\n  intro s g hgs hsum i\n  rw [← (w i).mul_left_eq_zero]\n  refine' hv s (fun i => «expr • » (g i) (w i)) (fun i hi => _) _ i\n  · dsimp only\n    exact (hgs i hi).symm ▸ zero_smul _ _\n  · rw [← hsum, finset.sum_congr rfl _]\n    intros\n    erw [pi.smul_apply, smul_assoc]\n    rfl\n#align linear_independent.units_smul linear_independent.units_smul\n\n",
 "union":
 "theorem linear_independent.union {s t : set M} (hs : linear_independent R (fun x => x : s → M))\n    (ht : linear_independent R (fun x => x : t → M)) (hst : Disjoint (span R s) (span R t)) :\n    linear_independent R (fun x => x : s ∪ t → M) :=\n  (hs.sum_type ht <| by simpa).to_subtype_range' <| by simp\n#align linear_independent.union linear_independent.union\n\n",
 "total_repr":
 "@[simp]\ntheorem linear_independent.total_repr (x) : finsupp.total ι M R v (hv.repr x) = x :=\n  subtype.ext_iff.1 (linear_equiv.apply_symm_apply hv.total_equiv x)\n#align linear_independent.total_repr linear_independent.total_repr\n\n",
 "total_ne_of_not_mem_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem linear_independent.total_ne_of_not_mem_support [nontrivial R] (hv : linear_independent R v) {x : ι}\n    (f : «expr →₀ » ι R) (h : x ∉ f.support) : finsupp.total ι M R v f ≠ v x :=\n  by\n  replace h : x ∉ (f.support : set ι) := h\n  have p := hv.not_mem_span_image h\n  intro w\n  rw [← w] at p\n  rw [finsupp.span_image_eq_map_total] at p\n  simp only [not_exists, not_and, mem_map] at p\n  exact p f (f.mem_supported_support R) rfl\n#align linear_independent.total_ne_of_not_mem_support linear_independent.total_ne_of_not_mem_support\n\n",
 "total_comp_repr":
 "theorem linear_independent.total_comp_repr : (finsupp.total ι M R v).comp hv.repr = submodule.subtype _ :=\n  linear_map.ext <| hv.total_repr\n#align linear_independent.total_comp_repr linear_independent.total_comp_repr\n\n",
 "to_subtype_range'":
 "theorem linear_independent.to_subtype_range' {ι} {f : ι → M} (hf : linear_independent R f) {t} (ht : range f = t) :\n    linear_independent R (coe : t → M) :=\n  ht ▸ hf.to_subtype_range\n#align linear_independent.to_subtype_range' linear_independent.to_subtype_range'\n\n",
 "to_subtype_range":
 "theorem linear_independent.to_subtype_range {ι} {f : ι → M} (hf : linear_independent R f) :\n    linear_independent R (coe : range f → M) := by\n  nontriviality R\n  exact (linear_independent_subtype_range hf.injective).2 hf\n#align linear_independent.to_subtype_range linear_independent.to_subtype_range\n\n",
 "surjective_of_linear_independent_of_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem surjective_of_linear_independent_of_span [nontrivial R] (hv : linear_independent R v) (f : «expr ↪ » ι' ι)\n    (hss : range v ⊆ span R (range (v ∘ f))) : surjective f :=\n  by\n  intro i\n  let repr : (span R (range (v ∘ f)) : Type _) → «expr →₀ » ι' R := (hv.comp f f.injective).repr\n  let l := (repr ⟨v i, hss (mem_range_self i)⟩).map_domain f\n  have h_total_l : finsupp.total ι M R v l = v i := by\n    dsimp only [l]\n    rw [finsupp.total_map_domain]\n    rw [(hv.comp f f.injective).total_repr]\n    · rfl\n  have h_total_eq : (finsupp.total ι M R v) l = (finsupp.total ι M R v) (finsupp.single i 1) := by\n    rw [h_total_l, finsupp.total_single, one_smul]\n  have l_eq : l = _ := linear_map.ker_eq_bot.1 hv h_total_eq\n  dsimp only [l] at l_eq\n  rw [← finsupp.emb_domain_eq_map_domain] at l_eq\n  rcases finsupp.single_of_emb_domain_single (repr ⟨v i, _⟩) f i (1 : R) zero_ne_one.symm l_eq with ⟨i', hi'⟩\n  use i'\n  exact hi'.2\n#align surjective_of_linear_independent_of_span surjective_of_linear_independent_of_span\n\n",
 "sum_type":
 "theorem linear_independent.sum_type {v' : ι' → M} (hv : linear_independent R v) (hv' : linear_independent R v')\n    (h : Disjoint (submodule.span R (range v)) (submodule.span R (range v'))) : linear_independent R (sum.elim v v') :=\n  linear_independent_sum.2 ⟨hv, hv', h⟩\n#align linear_independent.sum_type linear_independent.sum_type\n\n",
 "subset_span_extend":
 "theorem linear_independent.subset_span_extend (hs : linear_independent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    t ⊆ span K (hs.extend hst) :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linear_independent_extension hs hst)\n  htb\n#align linear_independent.subset_span_extend linear_independent.subset_span_extend\n\n",
 "subset_extend":
 "theorem linear_independent.subset_extend (hs : linear_independent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    s ⊆ hs.extend hst :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linear_independent_extension hs hst)\n  hsb\n#align linear_independent.subset_extend linear_independent.subset_extend\n\n",
 "span_repr_eq":
 "theorem linear_independent.span_repr_eq [nontrivial R] (x) :\n    span.repr R (Set.range v) x = (hv.repr x).equiv_map_domain (Equiv.ofInjective _ hv.injective) :=\n  by\n  have p : (span.repr R (Set.range v) x).equiv_map_domain (Equiv.ofInjective _ hv.injective).symm = hv.repr x :=\n    by\n    apply (linear_independent.total_equiv hv).injective\n    ext\n    simp only [linear_independent.total_equiv_apply_coe, Equiv.self_comp_ofInjective_symm,\n      linear_independent.total_repr, finsupp.total_equiv_map_domain, span.finsupp_total_repr]\n  ext ⟨_, ⟨i, rfl⟩⟩\n  simp [← p]\n#align linear_independent.span_repr_eq linear_independent.span_repr_eq\n\n",
 "span_le_span_iff":
 "theorem span_le_span_iff [nontrivial R] {s t u : set M} (hl : linear_independent R (coe : u → M)) (hsu : s ⊆ u)\n    (htu : t ⊆ u) : span R s ≤ span R t ↔ s ⊆ t :=\n  ⟨le_of_span_le_span hl hsu htu, span_mono⟩\n#align span_le_span_iff span_le_span_iff\n\n",
 "restrict_scalars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly\nindependent over a subring `R` of `K`.\nThe implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.\nThe version where `K` is an `R`-algebra is `linear_independent.restrict_scalars_algebras`.\n -/\ntheorem linear_independent.restrict_scalars [Semiring K] [SMulWithZero R K] [Module K M] [IsScalarTower R K M]\n    (hinj : function.injective fun r : R => «expr • » r (1 : K)) (li : linear_independent K v) :\n    linear_independent R v :=\n  by\n  refine' linear_independent_iff'.mpr fun s g hg i hi => hinj (eq.trans _ (zero_smul _ _).symm)\n  refine' (linear_independent_iff'.mp li : _) _ _ _ i hi\n  simp_rw [smul_assoc, one_smul]\n  exact hg\n#align linear_independent.restrict_scalars linear_independent.restrict_scalars\n\n",
 "restrict_of_comp_subtype":
 "theorem linear_independent.restrict_of_comp_subtype {s : set ι} (hs : linear_independent R (v ∘ coe : s → M)) :\n    linear_independent R (s.restrict v) :=\n  hs\n#align linear_independent.restrict_of_comp_subtype linear_independent.restrict_of_comp_subtype\n\n",
 "repr_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem linear_independent.repr_range : hv.repr.range = «expr⊤» := by rw [linear_independent.repr, linear_equiv.range]\n#align linear_independent.repr_range linear_independent.repr_range\n\n",
 "repr_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem linear_independent.repr_ker : hv.repr.ker = «expr⊥» := by rw [linear_independent.repr, linear_equiv.ker]\n#align linear_independent.repr_ker linear_independent.repr_ker\n\n",
 "repr_eq_single":
 "theorem linear_independent.repr_eq_single (i) (x) (hx : ↑x = v i) : hv.repr x = finsupp.single i 1 :=\n  by\n  apply hv.repr_eq\n  simp [finsupp.total_single, hx]\n#align linear_independent.repr_eq_single linear_independent.repr_eq_single\n\n",
 "repr_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem linear_independent.repr_eq {l : «expr →₀ » ι R} {x} (eq : finsupp.total ι M R v l = ↑x) : hv.repr x = l :=\n  by\n  have :\n    ↑((linear_independent.total_equiv hv : «expr →ₗ[ ] » («expr →₀ » ι R) R (span R (range v))) l) =\n      finsupp.total ι M R v l :=\n    rfl\n  have : (linear_independent.total_equiv hv : «expr →ₗ[ ] » («expr →₀ » ι R) R (span R (range v))) l = x :=\n    by\n    rw [eq] at this\n    exact subtype.ext_iff.2 this\n  rw [← linear_equiv.symm_apply_apply hv.total_equiv l]\n  rw [← this]\n  rfl\n#align linear_independent.repr_eq linear_independent.repr_eq\n\n",
 "option":
 "theorem linear_independent.option (hv : linear_independent K v) (hx : x ∉ submodule.span K (range v)) :\n    linear_independent K (fun o => option.cases_on' o x v : option ι → V) :=\n  linear_independent_option'.2 ⟨hv, hx⟩\n#align linear_independent.option linear_independent.option\n\n",
 "of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If the image of a family of vectors under a linear map is linearly independent, then so is\nthe original family. -/\ntheorem linear_independent.of_comp (f : «expr →ₗ[ ] » M R M') (hfv : linear_independent R (f ∘ v)) :\n    linear_independent R v :=\n  linear_independent_iff'.2 fun s g hg i his =>\n    have :\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          («expr • » (g i) (f (v i))) =\n        0 :=\n      by simp_rw [← f.map_smul, ← f.map_sum, hg, f.map_zero]\n    linear_independent_iff'.1 hfv s g this i his\n#align linear_independent.of_comp linear_independent.of_comp\n\n",
 "not_mem_span_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent.not_mem_span_image [nontrivial R] (hv : linear_independent R v) {s : set ι} {x : ι}\n    (h : x ∉ s) : v x ∉ submodule.span R («expr '' » v s) :=\n  by\n  have h' : v x ∈ submodule.span R («expr '' » v {x}) :=\n    by\n    rw [Set.image_singleton]\n    exact mem_span_singleton_self (v x)\n  intro w\n  apply linear_independent.ne_zero x hv\n  refine' disjoint_def.1 (hv.disjoint_span_image _) (v x) h' w\n  simpa using h\n#align linear_independent.not_mem_span_image linear_independent.not_mem_span_image\n\n",
 "not_linear_independent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem fintype.not_linear_independent_iff [fintype ι] :\n    ¬linear_independent R v ↔\n      ∃ g : ι → R,\n        finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n              («expr • » (g i) (v i)) =\n            0 ∧\n          ∃ i, g i ≠ 0 :=\n  by simpa using not_iff_not.2 fintype.linear_independent_iff\n#align fintype.not_linear_independent_iff fintype.not_linear_independent_iff\n\n",
 "ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem linear_independent.ne_zero [nontrivial R] (i : ι) (hv : linear_independent R v) : v i ≠ 0 := fun h =>\n  zero_ne_one' R <|\n    eq.symm\n      (by\n        suffices (finsupp.single i 1 : «expr →₀ » ι R) i = 0 by simpa\n        rw [linear_independent_iff.1 hv (finsupp.single i 1)]\n        · simp\n        · simp [h])\n#align linear_independent.ne_zero linear_independent.ne_zero\n\n",
 "mono":
 "theorem linear_independent.mono {t s : set M} (h : t ⊆ s) :\n    linear_independent R (fun x => x : s → M) → linear_independent R (fun x => x : t → M) :=\n  by\n  simp only [linear_independent_subtype_disjoint]\n  exact Disjoint.mono_left (finsupp.supported_mono h)\n#align linear_independent.mono linear_independent.mono\n\n",
 "mem_span_insert_exchange":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- TODO: some of the following proofs can generalized with a zero_ne_one predicate type class\n   (instead of a data containing type class) -/\ntheorem mem_span_insert_exchange : x ∈ span K (insert y s) → x ∉ span K s → y ∈ span K (insert x s) :=\n  by\n  simp [mem_span_insert]\n  rintro a z hz rfl h\n  refine' ⟨a⁻¹, «expr • » (-a⁻¹) z, smul_mem _ _ hz, _⟩\n  have a0 : a ≠ 0 := by\n    rintro rfl\n    simp_all\n  simp [a0, smul_add, smul_smul]\n#align mem_span_insert_exchange mem_span_insert_exchange\n\n",
 "maximal_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An alternative characterization of a maximal linearly independent family,\nquantifying over types (in the same universe as `M`) into which the indexing family injects.\n-/\ntheorem linear_independent.maximal_iff {ι : Type w} {R : Type u} [Ring R] [nontrivial R] {M : Type v} [add_comm_group M]\n    [Module R M] {v : ι → M} (i : linear_independent R v) :\n    i.maximal ↔ ∀ (κ : Type v) (w : κ → M) (i' : linear_independent R w) (j : ι → κ) (h : w ∘ j = v), surjective j :=\n  by\n  fconstructor\n  · rintro p κ w i' j rfl\n    specialize p (range w) i'.coe_range (range_comp_subset_range _ _)\n    rw [range_comp, ← @image_univ _ _ w] at p\n    exact range_iff_surjective.mp (image_injective.mpr i'.injective p)\n  · intro p w i' h\n    specialize\n      p w (coe : w → M) i' (fun i => ⟨v i, range_subset_iff.mp h i⟩)\n        (by\n          ext\n          simp)\n    have q := congr_arg (fun s => «expr '' » (coe : w → M) s) p.range_eq\n    dsimp at q\n    rw [← image_univ, image_image] at q\n    simpa using q\n#align linear_independent.maximal_iff linear_independent.maximal_iff\n\n",
 "map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- An injective linear map sends linearly independent families of vectors to linearly independent\nfamilies of vectors. See also `linear_independent.map` for a more general statement. -/\ntheorem linear_independent.map' (hv : linear_independent R v) (f : «expr →ₗ[ ] » M R M') (hf_inj : f.ker = «expr⊥») :\n    linear_independent R (f ∘ v) :=\n  hv.map <| by simp [hf_inj]\n#align linear_independent.map' linear_independent.map'\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If `v` is a linearly independent family of vectors and the kernel of a linear map `f` is\ndisjoint with the submodule spanned by the vectors of `v`, then `f ∘ v` is a linearly independent\nfamily of vectors. See also `linear_independent.map'` for a special case assuming `ker f = ⊥`. -/\ntheorem linear_independent.map (hv : linear_independent R v) {f : «expr →ₗ[ ] » M R M'}\n    (hf_inj : Disjoint (span R (range v)) f.ker) : linear_independent R (f ∘ v) :=\n  by\n  rw [disjoint_iff_inf_le, ← Set.image_univ, finsupp.span_image_eq_map_total, map_inf_eq_map_inf_comap,\n    map_le_iff_le_comap, comap_bot, finsupp.supported_univ, top_inf_eq] at hf_inj\n  unfold linear_independent at hv⊢\n  rw [hv, le_bot_iff] at hf_inj\n  haveI : inhabited M := ⟨0⟩\n  rw [finsupp.total_comp, @finsupp.lmap_domain_total _ _ R _ _ _ _ _ _ _ _ _ _ f, linear_map.ker_comp, hf_inj]\n  exact fun _ => rfl\n#align linear_independent.map linear_independent.map\n\n",
 "linear_independent_unique_iff":
 "theorem linear_independent_unique_iff (v : ι → M) [unique ι] : linear_independent R v ↔ v default ≠ 0 :=\n  by\n  simp only [linear_independent_iff, finsupp.total_unique, smul_eq_zero]\n  refine' ⟨fun h hv => _, fun hv l hl => finsupp.unique_ext <| hl.resolve_right hv⟩\n  have := h (finsupp.single default 1) (or.inr hv)\n  exact one_ne_zero (finsupp.single_eq_zero.1 this)\n#align linear_independent_unique_iff linear_independent_unique_iff\n\n",
 "linear_independent_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_sum {v : Sum ι ι' → M} :\n    linear_independent R v ↔\n      linear_independent R (v ∘ sum.inl) ∧\n        linear_independent R (v ∘ sum.inr) ∧\n          Disjoint (submodule.span R (range (v ∘ sum.inl))) (submodule.span R (range (v ∘ sum.inr))) :=\n  by\n  rw [range_comp v, range_comp v]\n  refine'\n    ⟨fun h =>\n      ⟨h.comp _ sum.inl_injective, h.comp _ sum.inr_injective, h.disjoint_span_image is_compl_range_inl_range_inr.1⟩, _⟩\n  rintro ⟨hl, hr, hlr⟩\n  rw [linear_independent_iff'] at *\n  intro s g hg i hi\n  have :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (s.preimage sum.inl (sum.inl_injective.inj_on _)) ((fun x => «expr • » (g x) (v x)) (sum.inl i)) +\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (s.preimage sum.inr (sum.inr_injective.inj_on _)) ((fun x => «expr • » (g x) (v x)) (sum.inr i)) =\n      0 :=\n    by\n    rw [finset.sum_preimage', finset.sum_preimage', ← finset.sum_union, ← Finset.filter_or]\n    · simpa only [← mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_true]\n    · exact Finset.disjoint_filter.2 fun x _ hx => disjoint_left.1 is_compl_range_inl_range_inr.1 hx\n  · rw [← eq_neg_iff_add_eq_zero] at this\n    rw [disjoint_def'] at hlr\n    have A := hlr _ (sum_mem fun i hi => _) _ (neg_mem <| sum_mem fun i hi => _) this\n    · cases' i with i i\n      · exact hl _ _ A i (finset.mem_preimage.2 hi)\n      · rw [this, neg_eq_zero] at A\n        exact hr _ _ A i (finset.mem_preimage.2 hi)\n    · exact smul_mem _ _ (subset_span ⟨sum.inl i, mem_range_self _, rfl⟩)\n    · exact smul_mem _ _ (subset_span ⟨sum.inr i, mem_range_self _, rfl⟩)\n#align linear_independent_sum linear_independent_sum\n\n",
 "linear_independent_subtype_range":
 "theorem linear_independent_subtype_range {ι} {f : ι → M} (hf : injective f) :\n    linear_independent R (coe : range f → M) ↔ linear_independent R f :=\n  iff.symm <| linear_independent_equiv' (Equiv.ofInjective f hf) rfl\n#align linear_independent_subtype_range linear_independent_subtype_range\n\n",
 "linear_independent_subtype_disjoint":
 "theorem linear_independent_subtype_disjoint {s : set M} :\n    linear_independent R (fun x => x : s → M) ↔ Disjoint (finsupp.supported R R s) (finsupp.total M M R id).ker := by\n  apply @linear_independent_comp_subtype_disjoint _ _ _ id\n#align linear_independent_subtype_disjoint linear_independent_subtype_disjoint\n\n",
 "linear_independent_subtype":
 "theorem linear_independent_subtype {s : set M} :\n    linear_independent R (fun x => x : s → M) ↔ ∀ l ∈ finsupp.supported R R s, (finsupp.total M M R id) l = 0 → l = 0 :=\n  by apply @linear_independent_comp_subtype _ _ _ id\n#align linear_independent_subtype linear_independent_subtype\n\n",
 "linear_independent_span":
 "theorem linear_independent_span (hs : linear_independent R v) :\n    @linear_independent ι R (span R (range v)) (fun i : ι => ⟨v i, subset_span (mem_range_self i)⟩) _ _ _ :=\n  linear_independent.of_comp (span R (range v)).subtype hs\n#align linear_independent_span linear_independent_span\n\n",
 "linear_independent_singleton":
 "theorem linear_independent_singleton {x : M} (hx : x ≠ 0) : linear_independent R (fun x => x : ({x} : set M) → M) :=\n  linear_independent_unique coe hx\n#align linear_independent_singleton linear_independent_singleton\n\n",
 "linear_independent_sUnion_of_directed":
 "theorem linear_independent_sUnion_of_directed {s : set (set M)} (hs : DirectedOn (· ⊆ ·) s)\n    (h : ∀ a ∈ s, linear_independent R (fun x => x : (a : set M) → M)) : linear_independent R (fun x => x : ⋃₀ s → M) :=\n  by rw [sUnion_eq_Union] <;> exact linear_independent_Union_of_directed hs.directed_coe (by simpa using h)\n#align linear_independent_sUnion_of_directed linear_independent_sUnion_of_directed\n\n",
 "linear_independent_pair":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_pair {x y : V} (hx : x ≠ 0) (hy : ∀ a : K, «expr • » a x ≠ y) :\n    linear_independent K (coe : ({x, y} : set V) → V) :=\n  pair_comm y x ▸ (linear_independent_singleton hx).insert <| mt mem_span_singleton.1 (not_exists.2 hy)\n#align linear_independent_pair linear_independent_pair\n\n",
 "linear_independent_option'":
 "theorem linear_independent_option' :\n    linear_independent K (fun o => option.cases_on' o x v : option ι → V) ↔\n      linear_independent K v ∧ x ∉ submodule.span K (range v) :=\n  by\n  rw [← linear_independent_equiv (Equiv.optionEquivSumPUnit ι).symm, linear_independent_sum, @range_unique _ PUnit,\n    @linear_independent_unique_iff PUnit, disjoint_span_singleton]\n  dsimp [(· ∘ ·)]\n  refine' ⟨fun h => ⟨h.1, fun hx => h.2.1 <| h.2.2 hx⟩, fun h => ⟨h.1, _, fun hx => (h.2 hx).elim⟩⟩\n  rintro rfl\n  exact h.2 (zero_mem _)\n#align linear_independent_option' linear_independent_option'\n\n",
 "linear_independent_option":
 "theorem linear_independent_option {v : option ι → V} :\n    linear_independent K v ↔\n      linear_independent K (v ∘ coe : ι → V) ∧ v none ∉ submodule.span K (range (v ∘ coe : ι → V)) :=\n  by simp only [← linear_independent_option', option.cases_on'_none_coe]\n#align linear_independent_option linear_independent_option\n\n",
 "linear_independent_of_subsingleton":
 "@[nontriviality]\ntheorem linear_independent_of_subsingleton [subsingleton R] : linear_independent R v :=\n  linear_independent_iff.2 fun l hl => subsingleton.elim _ _\n#align linear_independent_of_subsingleton linear_independent_of_subsingleton\n\n",
 "linear_independent_of_finite":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (t «expr ⊆ » s) -/\ntheorem linear_independent_of_finite (s : set M)\n    (H : ∀ (t) (_ : t ⊆ s), set.finite t → linear_independent R (fun x => x : t → M)) :\n    linear_independent R (fun x => x : s → M) :=\n  linear_independent_subtype.2 fun l hl =>\n    linear_independent_subtype.1 (H _ hl (finset.finite_to_set _)) l (Subset.refl _)\n#align linear_independent_of_finite linear_independent_of_finite\n\n",
 "linear_independent_monoid_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n-- See, for example, Keith Conrad's note\n--  <https://kconrad.math.uconn.edu/blurbs/galoistheory/linearchar.pdf>\n/-- Dedekind's linear independence of characters -/\ntheorem linear_independent_monoid_hom (G : Type _) [monoid G] (L : Type _) [CommRing L] [no_zero_divisors L] :\n    @linear_independent _ L (G → L) (fun f => f : «expr →* » G L → G → L) _ _ _ := by\n  letI := classical.dec_eq («expr →* » G L) <;>\n      letI : MulAction L L :=\n        distrib_mul_action.to_mul_action <;>-- We prove linear independence by showing that only the trivial linear combination vanishes.\n    exact\n      linear_independent_iff'.2-- To do this, we use `finset` induction,\n      fun s =>\n        Finset.induction_on s (fun g hg i => false.elim) fun a s has ih g hg =>\n          -- Here\n          -- * `a` is a new character we will insert into the `finset` of characters `s`,\n          -- * `ih` is the fact that only the trivial linear combination of characters in `s` is zero\n          -- * `hg` is the fact that `g` are the coefficients of a linear combination summing to zero\n          -- and it remains to prove that `g` vanishes on `insert a s`.\n          -- We now make the key calculation:\n          -- For any character `i` in the original `finset`, we have `g i • i = g i • a` as functions on the\n          -- monoid `G`.\n          have h1 : ∀ i ∈ s, («expr • » (g i) i : G → L) = «expr • » (g i) a := fun i his =>\n            funext fun x : G =>\n              -- We prove these expressions are equal by showing\n                -- the differences of their values on each monoid element `x` is zero\n                eq_of_sub_eq_zero <|\n                ih (fun j => g j * j x - g j * a x)\n                  (funext fun y : G =>\n                    calc\n                      (-- After that, it's just a chase scene.\n                              finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                              («expr • » (g i * i x - g i * a x) i : G → L))\n                            y =\n                          finset.sum\n                            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                            ((g i * i x - g i * a x) * i y) :=\n                        finset.sum_apply _ _ _\n                      _ =\n                          finset.sum\n                            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                            (g i * i x * i y - g i * a x * i y) :=\n                        finset.sum_congr rfl fun _ _ => sub_mul _ _ _\n                      _ =\n                          finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                              (g i * i x * i y) -\n                            finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                              (g i * a x * i y) :=\n                        finset.sum_sub_distrib\n                      _ =\n                          g a * a x * a y +\n                              finset.sum\n                                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                                (g i * i x * i y) -\n                            (g a * a x * a y +\n                              finset.sum\n                                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n                                (g i * a x * i y)) :=\n                        by rw [add_sub_add_left_eq_sub]\n                      _ =\n                          finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (g i * i x * i y) -\n                            finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (g i * a x * i y) :=\n                        by rw [finset.sum_insert has, finset.sum_insert has]\n                      _ =\n                          finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (g i * i (x * y)) -\n                            finset.sum\n                              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                              (insert a s) (a x * (g i * i y)) :=\n                        congr (congr_arg has_sub.sub (finset.sum_congr rfl fun i _ => by rw [i.map_mul, mul_assoc]))\n                          (finset.sum_congr rfl fun _ _ => by rw [mul_assoc, mul_left_comm])\n                      _ =\n                          (finset.sum\n                                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                                (insert a s) («expr • » (g i) i : G → L))\n                              (x * y) -\n                            a x *\n                              (finset.sum\n                                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                                  (insert a s) («expr • » (g i) i : G → L))\n                                y :=\n                        by rw [finset.sum_apply, finset.sum_apply, finset.mul_sum] <;> rfl\n                      _ = 0 - a x * 0 := by rw [hg] <;> rfl\n                      _ = 0 := by rw [mul_zero, sub_zero]\n                      )\n                  i his\n          -- On the other hand, since `a` is not already in `s`, for any character `i ∈ s`\n          -- there is some element of the monoid on which it differs from `a`.\n          have h2 : ∀ i : «expr →* » G L, i ∈ s → ∃ y, i y ≠ a y := fun i his =>\n            by_contradiction fun h =>\n              have hia : i = a := MonoidHom.ext fun y => by_contradiction fun hy => h ⟨y, hy⟩\n              has <| hia ▸ his\n          -- From these two facts we deduce that `g` actually vanishes on `s`,\n          have h3 : ∀ i ∈ s, g i = 0 := fun i his =>\n            let ⟨y, hy⟩ := h2 i his\n            have h : «expr • » (g i) (i y) = «expr • » (g i) (a y) := congr_fun (h1 i his) y\n            or.resolve_right (mul_eq_zero.1 <| by rw [mul_sub, sub_eq_zero] <;> exact h) (sub_ne_zero_of_ne hy)\n          -- And so, using the fact that the linear combination over `s` and over `insert a s` both vanish,\n          -- we deduce that `g a = 0`.\n          have h4 : g a = 0 :=\n            calc\n              g a = g a * 1 := (mul_one _).symm\n              _ = («expr • » (g a) a : G → L) 1 := by rw [← a.map_one] <;> rfl\n              _ =\n                  (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n                      (insert a s) («expr • » (g i) i : G → L))\n                    1 :=\n                by\n                rw [finset.sum_eq_single a]\n                · intro i his hia\n                  rw [Finset.mem_insert] at his\n                  rw [h3 i (his.resolve_left hia), zero_smul]\n                · intro haas\n                  exfalso\n                  apply haas\n                  exact Finset.mem_insert_self a s\n              _ = 0 := by rw [hg] <;> rfl\n              \n          (-- Now we're done; the last two facts together imply that `g` vanishes on every element\n                -- of `insert a s`.\n                Finset.forall_mem_insert\n                _ _ _).2\n            ⟨h4, h3⟩\n#align linear_independent_monoid_hom linear_independent_monoid_hom\n\n",
 "linear_independent_insert'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent_insert' {ι} {s : set ι} {a : ι} {f : ι → V} (has : a ∉ s) :\n    (linear_independent K fun x : insert a s => f x) ↔\n      (linear_independent K fun x : s => f x) ∧ f a ∉ submodule.span K («expr '' » f s) :=\n  by\n  rw [← linear_independent_equiv ((Equiv.optionEquivSumPUnit _).trans (Equiv.Set.insert has).symm),\n    linear_independent_option]\n  simp [(· ∘ ·), range_comp f]\n#align linear_independent_insert' linear_independent_insert'\n\n",
 "linear_independent_insert":
 "theorem linear_independent_insert (hxs : x ∉ s) :\n    (linear_independent K fun b : insert x s => (b : V)) ↔\n      (linear_independent K fun b : s => (b : V)) ∧ x ∉ submodule.span K s :=\n  (@linear_independent_insert' _ _ _ _ _ _ _ _ id hxs).trans <| by simp\n#align linear_independent_insert linear_independent_insert\n\n",
 "linear_independent_inl_union_inr'":
 "theorem linear_independent_inl_union_inr' {v : ι → M} {v' : ι' → M'} (hv : linear_independent R v)\n    (hv' : linear_independent R v') : linear_independent R (sum.elim (inl R M M' ∘ v) (inr R M M' ∘ v')) :=\n  (hv.map' (inl R M M') ker_inl).sum_type (hv'.map' (inr R M M') ker_inr) <| by\n    refine' is_compl_range_inl_inr.disjoint.mono _ _ <;> simp only [span_le, range_coe, range_comp_subset_range]\n#align linear_independent_inl_union_inr' linear_independent_inl_union_inr'\n\n",
 "linear_independent_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent_image {ι} {s : set ι} {f : ι → M} (hf : Set.InjOn f s) :\n    (linear_independent R fun x : s => f x) ↔ linear_independent R fun x : «expr '' » f s => (x : M) :=\n  linear_independent_equiv' (Equiv.Set.imageOfInjOn _ _ hf) rfl\n#align linear_independent_image linear_independent_image\n\n",
 "linear_independent_iff_total_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem linear_independent_iff_total_on {s : set M} :\n    linear_independent R (fun x => x : s → M) ↔ (finsupp.total_on M M R id s).ker = «expr⊥» := by\n  rw [finsupp.total_on, linear_map.ker, linear_map.comap_cod_restrict, map_bot, comap_bot, linear_map.ker_comp,\n    linear_independent_subtype_disjoint, disjoint_iff_inf_le, ← map_comap_subtype, map_le_iff_le_comap, comap_bot,\n    ker_subtype, le_bot_iff]\n#align linear_independent_iff_total_on linear_independent_iff_total_on\n\n",
 "linear_independent_iff_not_smul_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n-- TODO: why is this so slow?\ntheorem linear_independent_iff_not_smul_mem_span :\n    linear_independent R v ↔ ∀ (i : ι) (a : R), «expr • » a (v i) ∈ span R («expr '' » v (univ \\ {i})) → a = 0 :=\n  ⟨fun hv i a ha => by\n    rw [finsupp.span_image_eq_map_total, mem_map] at ha\n    rcases ha with ⟨l, hl, e⟩\n    rw [sub_eq_zero.1 (linear_independent_iff.1 hv (l - finsupp.single i a) (by simp [e]))] at hl\n    by_contra hn\n    exact (not_mem_of_mem_diff (hl <| by simp [hn])) (mem_singleton _), fun H =>\n    linear_independent_iff.2 fun l hl => by\n      ext i; simp only [finsupp.zero_apply]\n      by_contra hn\n      refine' hn (H i _ _)\n      refine' (finsupp.mem_span_image_iff_total _).2 ⟨finsupp.single i (l i) - l, _, _⟩\n      · rw [finsupp.mem_supported']\n        intro j hj\n        have hij : j = i :=\n          not_not.1 fun hij : j ≠ i => hj ((mem_diff _).2 ⟨mem_univ _, fun h => hij (eq_of_mem_singleton h)⟩)\n        simp [hij]\n      · simp [hl]⟩\n#align linear_independent_iff_not_smul_mem_span linear_independent_iff_not_smul_mem_span\n\n",
 "linear_independent_iff_not_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent_iff_not_mem_span : linear_independent K v ↔ ∀ i, v i ∉ span K («expr '' » v (univ \\ {i})) :=\n  by\n  apply linear_independent_iff_not_smul_mem_span.trans\n  constructor\n  · intro h i h_in_span\n    apply one_ne_zero (h i 1 (by simp [h_in_span]))\n  · intro h i a ha\n    by_contra ha'\n    exact false.elim (h _ ((smul_mem_iff _ ha').1 ha))\n#align linear_independent_iff_not_mem_span linear_independent_iff_not_mem_span\n\n",
 "linear_independent_iff_injective_total":
 "theorem linear_independent_iff_injective_total : linear_independent R v ↔ function.injective (finsupp.total ι M R v) :=\n  linear_independent_iff.trans (injective_iff_map_eq_zero (finsupp.total ι M R v).to_add_monoid_hom).symm\n#align linear_independent_iff_injective_total linear_independent_iff_injective_total\n\n",
 "linear_independent_iff''":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i «expr ∉ » s) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_iff'' :\n    linear_independent R v ↔\n      ∀ (s : Finset ι) (g : ι → R) (hg : ∀ (i) (_ : i ∉ s), g i = 0),\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n              («expr • » (g i) (v i)) =\n            0 →\n          ∀ i, g i = 0 :=\n  linear_independent_iff'.trans\n    ⟨fun H s g hg hv i => if his : i ∈ s then H s g hv i his else hg i his, fun H s g hg i hi =>\n      by\n      convert\n        H s (fun j => if j ∈ s then g j else 0) (fun j hj => if_neg hj)\n          (by simp_rw [ite_smul, zero_smul, finset.sum_extend_by_zero, hg]) i\n      exact (if_pos hi).symm⟩\n#align linear_independent_iff'' linear_independent_iff''\n\n",
 "linear_independent_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A finite family of vectors `v i` is linear independent iff the linear map that sends\n`c : ι → R` to `∑ i, c i • v i` has the trivial kernel. -/\ntheorem fintype.linear_independent_iff' [fintype ι] :\n    linear_independent R v ↔\n      (linear_map.lsum R (fun i : ι => R) ℕ fun i => linear_map.id.smul_right (v i)).ker = «expr⊥» :=\n  by simp [fintype.linear_independent_iff, linear_map.ker_eq_bot', funext_iff] <;> skip\n#align fintype.linear_independent_iff' fintype.linear_independent_iff'\n\n",
 "linear_independent_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- If `f` is an injective linear map, then the family `f ∘ v` is linearly independent\nif and only if the family `v` is linearly independent. -/\nprotected theorem linear_map.linear_independent_iff (f : «expr →ₗ[ ] » M R M') (hf_inj : f.ker = «expr⊥») :\n    linear_independent R (f ∘ v) ↔ linear_independent R v :=\n  ⟨fun h => h.of_comp f, fun h => h.map <| by simp only [hf_inj, disjoint_bot_right]⟩\n#align linear_map.linear_independent_iff linear_map.linear_independent_iff\n\n",
 "linear_independent_finset_map_embedding_subtype":
 "/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem linear_independent_finset_map_embedding_subtype (s : set M) (li : linear_independent R (coe : s → M))\n    (t : Finset s) : linear_independent R (coe : Finset.map (Embedding.subtype s) t → M) :=\n  by\n  let f : t.map (embedding.subtype s) → s := fun x =>\n    ⟨x.1, by\n      obtain ⟨x, h⟩ := x\n      rw [Finset.mem_map] at h\n      obtain ⟨a, ha, rfl⟩ := h\n      simp only [subtype.coe_prop, embedding.coe_subtype]⟩\n  convert linear_independent.comp li f _\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  rw [Finset.mem_map] at hx hy\n  obtain ⟨a, ha, rfl⟩ := hx\n  obtain ⟨b, hb, rfl⟩ := hy\n  simp only [imp_self, subtype.mk_eq_mk]\n#align linear_independent_finset_map_embedding_subtype linear_independent_finset_map_embedding_subtype\n\n",
 "linear_independent_fin_succ'":
 "theorem linear_independent_fin_succ' {n} {v : fin (n + 1) → V} :\n    linear_independent K v ↔\n      linear_independent K (fin.init v) ∧ v (Fin.last _) ∉ submodule.span K (range <| fin.init v) :=\n  by rw [← linear_independent_fin_snoc, fin.snoc_init_self]\n#align linear_independent_fin_succ' linear_independent_fin_succ'\n\n",
 "linear_independent_fin_succ":
 "theorem linear_independent_fin_succ {n} {v : fin (n + 1) → V} :\n    linear_independent K v ↔ linear_independent K (fin.tail v) ∧ v 0 ∉ submodule.span K (range <| fin.tail v) := by\n  rw [← linear_independent_fin_cons, fin.cons_self_tail]\n#align linear_independent_fin_succ linear_independent_fin_succ\n\n",
 "linear_independent_fin_snoc":
 "theorem linear_independent_fin_snoc {n} {v : fin n → V} :\n    linear_independent K (fin.snoc v x : fin (n + 1) → V) ↔ linear_independent K v ∧ x ∉ submodule.span K (range v) :=\n  by rw [fin.snoc_eq_cons_rotate, linear_independent_equiv, linear_independent_fin_cons]\n#align linear_independent_fin_snoc linear_independent_fin_snoc\n\n",
 "linear_independent_fin_cons":
 "theorem linear_independent_fin_cons {n} {v : fin n → V} :\n    linear_independent K (fin.cons x v : fin (n + 1) → V) ↔ linear_independent K v ∧ x ∉ submodule.span K (range v) :=\n  by\n  rw [← linear_independent_equiv (fin_succ_equiv n).symm, linear_independent_option]\n  convert iff.rfl\n  · ext\n    -- TODO: why doesn't simp use `fin_succ_equiv_symm_coe` here?\n    rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]\n  · ext\n    rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]\n#align linear_independent_fin_cons linear_independent_fin_cons\n\n",
 "linear_independent_fin2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_fin2 {f : fin 2 → V} : linear_independent K f ↔ f 1 ≠ 0 ∧ ∀ a : K, «expr • » a (f 1) ≠ f 0 :=\n  by\n  rw [linear_independent_fin_succ, linear_independent_unique_iff, range_unique, mem_span_singleton, not_exists,\n    show fin.tail f default = f 1 by rw [← Fin.succ_zero_eq_one] <;> rfl]\n#align linear_independent_fin2 linear_independent_fin2\n\n",
 "linear_independent_extend":
 "theorem linear_independent.linear_independent_extend (hs : linear_independent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    linear_independent K (coe : hs.extend hst → V) :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linear_independent_extension hs hst)\n  hli\n#align linear_independent.linear_independent_extend linear_independent.linear_independent_extend\n\n",
 "linear_independent_equiv'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem linear_independent_equiv' (e : «expr ≃ » ι ι') {f : ι' → M} {g : ι → M} (h : f ∘ e = g) :\n    linear_independent R g ↔ linear_independent R f :=\n  h ▸ linear_independent_equiv e\n#align linear_independent_equiv' linear_independent_equiv'\n\n",
 "linear_independent_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem linear_independent_equiv (e : «expr ≃ » ι ι') {f : ι' → M} :\n    linear_independent R (f ∘ e) ↔ linear_independent R f :=\n  ⟨fun h => function.comp.right_id f ▸ e.self_comp_symm ▸ h.comp _ e.symm.injective, fun h => h.comp _ e.injective⟩\n#align linear_independent_equiv linear_independent_equiv\n\n",
 "linear_independent_empty_type":
 "theorem linear_independent_empty_type [is_empty ι] : linear_independent R v :=\n  linear_independent_iff.mpr fun v hv => subsingleton.elim v 0\n#align linear_independent_empty_type linear_independent_empty_type\n\n",
 "linear_independent_empty":
 "theorem linear_independent_empty : linear_independent R (fun x => x : (∅ : set M) → M) := by\n  simp [linear_independent_subtype_disjoint]\n#align linear_independent_empty linear_independent_empty\n\n",
 "linear_independent_comp_subtype_disjoint":
 "theorem linear_independent_comp_subtype_disjoint {s : set ι} :\n    linear_independent R (v ∘ coe : s → M) ↔ Disjoint (finsupp.supported R R s) (finsupp.total ι M R v).ker := by\n  rw [linear_independent_comp_subtype, linear_map.disjoint_ker]\n#align linear_independent_comp_subtype_disjoint linear_independent_comp_subtype_disjoint\n\n",
 "linear_independent_comp_subtype":
 "theorem linear_independent_comp_subtype {s : set ι} :\n    linear_independent R (v ∘ coe : s → M) ↔ ∀ l ∈ finsupp.supported R R s, (finsupp.total ι M R v) l = 0 → l = 0 :=\n  by\n  simp only [linear_independent_iff, (· ∘ ·), finsupp.mem_supported, finsupp.total_apply, Set.subset_def,\n    Finset.mem_coe]\n  constructor\n  · intro h l hl₁ hl₂\n    have := h (l.subtype_domain s) ((finsupp.sum_subtype_domain_index hl₁).trans hl₂)\n    exact (finsupp.subtype_domain_eq_zero_iff hl₁).1 this\n  · intro h l hl\n    refine' finsupp.emb_domain_eq_zero.1 (h (l.emb_domain <| Function.Embedding.subtype s) _ _)\n    · suffices ∀ i hi, ¬l ⟨i, hi⟩ = 0 → i ∈ s by simpa\n      intros\n      assumption\n    · rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index]\n      exacts[fun _ => zero_smul _ _, fun _ _ _ => add_smul _ _ _]\n#align linear_independent_comp_subtype linear_independent_comp_subtype\n\n",
 "linear_independent_bounded_of_finset_linear_independent_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/-- If every finite set of linearly independent vectors has cardinality at most `n`,\nthen the same is true for arbitrary sets of linearly independent vectors.\n-/\ntheorem linear_independent_bounded_of_finset_linear_independent_bounded {n : ℕ}\n    (H : ∀ s : Finset M, (linear_independent R fun i : s => (i : M)) → s.card ≤ n) :\n    ∀ s : set M, linear_independent R (coe : s → M) → cardinal.mk s ≤ n :=\n  by\n  intro s li\n  apply cardinal.card_le_of\n  intro t\n  rw [← finset.card_map (embedding.subtype s)]\n  apply H\n  apply linear_independent_finset_map_embedding_subtype _ li\n#align\n  linear_independent_bounded_of_finset_linear_independent_bounded linear_independent_bounded_of_finset_linear_independent_bounded\n\n",
 "linear_independent_bUnion_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹'o » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem linear_independent_bUnion_of_directed {η} {s : set η} {t : η → set M}\n    (hs : DirectedOn («expr ⁻¹'o » t (· ⊆ ·)) s) (h : ∀ a ∈ s, linear_independent R (fun x => x : t a → M)) :\n    linear_independent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (t a) → M) :=\n  by\n  rw [bUnion_eq_Union] <;>\n    exact linear_independent_Union_of_directed (directed_comp.2 <| hs.directed_coe) (by simpa using h)\n#align linear_independent_bUnion_of_directed linear_independent_bUnion_of_directed\n\n",
 "linear_independent_Union_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem linear_independent_Union_of_directed {η : Type _} {s : η → set M} (hs : Directed (· ⊆ ·) s)\n    (h : ∀ i, linear_independent R (fun x => x : s i → M)) :\n    linear_independent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i) → M) :=\n  by\n  by_cases hη : nonempty η\n  · skip\n    refine'\n      linear_independent_of_finite\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i))\n        fun t ht ft => _\n    rcases finite_subset_Union ft ht with ⟨I, fi, hI⟩\n    rcases hs.finset_le fi.to_finset with ⟨i, hi⟩\n    exact (h i).mono (subset.trans hI <| Union₂_subset fun j hj => hi j (fi.mem_to_finset.2 hj))\n  · refine' (linear_independent_empty _ _).mono _\n    rintro _ ⟨_, ⟨i, _⟩, _⟩\n    exact hη ⟨i⟩\n#align linear_independent_Union_of_directed linear_independent_Union_of_directed\n\n",
 "linear_independent_Union_finite_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem linear_independent_Union_finite_subtype {ι : Type _} {f : ι → set M}\n    (hl : ∀ i, linear_independent R (fun x => x : f i → M))\n    (hd :\n      ∀ i,\n        ∀ t : set ι,\n          t.finite →\n            i ∉ t →\n              Disjoint (span R (f i))\n                («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n                  (span R (f i)))) :\n    linear_independent R\n      (fun x => x :\n        «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (f i) → M) :=\n  by\n  rw [Union_eq_Union_finset f]\n  apply linear_independent_Union_of_directed\n  · apply directed_of_sup\n    exact fun t₁ t₂ ht => Union_mono fun i => Union_subset_Union_const fun h => ht h\n  intro t\n  induction' t using Finset.induction_on with i s his ih\n  · refine' (linear_independent_empty _ _).mono _\n    simp\n  · rw [finset.set_bUnion_insert]\n    refine' (hl _).union ih _\n    rw [span_Union₂]\n    exact hd i s s.finite_to_set his\n#align linear_independent_Union_finite_subtype linear_independent_Union_finite_subtype\n\n",
 "linear_independent_Union_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem linear_independent_Union_finite {η : Type _} {ιs : η → Type _} {f : ∀ j : η, ιs j → M}\n    (hindep : ∀ j, linear_independent R (f j))\n    (hd :\n      ∀ i,\n        ∀ t : set η,\n          t.finite →\n            i ∉ t →\n              Disjoint (span R (range (f i)))\n                («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n                  (span R (range (f i))))) :\n    linear_independent R fun ji : Σj, ιs j => f ji.1 ji.2 :=\n  by\n  nontriviality R\n  apply linear_independent.of_subtype_range\n  · rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ hxy\n    by_cases h_cases : x₁ = y₁\n    subst h_cases\n    · apply sigma.eq\n      rw [linear_independent.injective (hindep _) hxy]\n      rfl\n    · have h0 : f x₁ x₂ = 0 :=\n        by\n        apply\n          disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) fun h => h_cases (eq_of_mem_singleton h)) (f x₁ x₂)\n            (subset_span (mem_range_self _))\n        rw [supᵢ_singleton]\n        simp only at hxy\n        rw [hxy]\n        exact subset_span (mem_range_self y₂)\n      exact false.elim ((hindep x₁).ne_zero _ h0)\n  rw [range_sigma_eq_Union_range]\n  apply linear_independent_Union_finite_subtype (fun j => (hindep j).to_subtype_range) hd\n#align linear_independent_Union_finite linear_independent_Union_finite\n\n",
 "linear_dependent_comp_subtype'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem linear_dependent_comp_subtype' {s : set ι} :\n    ¬linear_independent R (v ∘ coe : s → M) ↔\n      ∃ f : «expr →₀ » ι R, f ∈ finsupp.supported R R s ∧ finsupp.total ι M R v f = 0 ∧ f ≠ 0 :=\n  by simp [linear_independent_comp_subtype]\n#align linear_dependent_comp_subtype' linear_dependent_comp_subtype'\n\n",
 "linear_dependent_comp_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A version of `linear_dependent_comp_subtype'` with `finsupp.total` unfolded. -/\ntheorem linear_dependent_comp_subtype {s : set ι} :\n    ¬linear_independent R (v ∘ coe : s → M) ↔\n      ∃ f : «expr →₀ » ι R,\n        f ∈ finsupp.supported R R s ∧\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" f.support\n                («expr • » (f i) (v i)) =\n              0 ∧\n            f ≠ 0 :=\n  linear_dependent_comp_subtype'\n#align linear_dependent_comp_subtype linear_dependent_comp_subtype\n\n",
 "le_of_span_le_span":
 "theorem le_of_span_le_span [nontrivial R] {s t u : set M} (hl : linear_independent R (coe : u → M)) (hsu : s ⊆ u)\n    (htu : t ⊆ u) (hst : span R s ≤ span R t) : s ⊆ t :=\n  by\n  have :=\n    eq_of_linear_independent_of_span_subtype (hl.mono (Set.union_subset hsu htu)) (Set.subset_union_right _ _)\n      (Set.union_subset (Set.Subset.trans subset_span hst) subset_span)\n  rw [← this]; apply Set.subset_union_left\n#align le_of_span_le_span le_of_span_le_span\n\n",
 "insert":
 "theorem linear_independent.insert (hs : linear_independent K (fun b => b : s → V)) (hx : x ∉ span K s) :\n    linear_independent K (fun b => b : insert x s → V) :=\n  by\n  rw [← union_singleton]\n  have x0 : x ≠ 0 := mt (by rintro rfl <;> apply zero_mem (span K s)) hx\n  apply hs.union (linear_independent_singleton x0)\n  rwa [disjoint_span_singleton' x0]\n#align linear_independent.insert linear_independent.insert\n\n",
 "inl_union_inr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent.inl_union_inr {s : set M} {t : set M'} (hs : linear_independent R (fun x => x : s → M))\n    (ht : linear_independent R (fun x => x : t → M')) :\n    linear_independent R (fun x => x : «expr '' » (inl R M M') s ∪ «expr '' » (inr R M M') t → M × M') :=\n  by\n  refine' (hs.image_subtype _).union (ht.image_subtype _) _ <;> [simp, simp, skip]\n  simp only [span_image]\n  simp [disjoint_iff, prod_inf_prod]\n#align linear_independent.inl_union_inr linear_independent.inl_union_inr\n\n",
 "injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem linear_independent.injective [nontrivial R] (hv : linear_independent R v) : injective v :=\n  by\n  intro i j hij\n  let l : «expr →₀ » ι R := finsupp.single i (1 : R) - finsupp.single j 1\n  have h_total : finsupp.total ι M R v l = 0 :=\n    by\n    simp_rw [linear_map.map_sub, finsupp.total_apply]\n    simp [hij]\n  have h_single_eq : finsupp.single i (1 : R) = finsupp.single j 1 :=\n    by\n    rw [linear_independent_iff] at hv\n    simp [eq_add_of_sub_eq' (hv l h_total)]\n  simpa [finsupp.single_eq_single_iff] using h_single_eq\n#align linear_independent.injective linear_independent.injective\n\n",
 "independent_span_singleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- See also `complete_lattice.independent_iff_linear_independent_of_ne_zero`. -/\ntheorem linear_independent.independent_span_singleton (hv : linear_independent R v) :\n    complete_lattice.independent fun i => «expr ∙ » R (v i) :=\n  by\n  refine' complete_lattice.independent_def.mp fun i => _\n  rw [disjoint_iff_inf_le]\n  intro m hm\n  simp only [mem_inf, mem_span_singleton, supᵢ_subtype', ← span_range_eq_supr] at hm\n  obtain ⟨⟨r, rfl⟩, hm⟩ := hm\n  suffices r = 0 by simp [this]\n  apply linear_independent_iff_not_smul_mem_span.mp hv i\n  convert hm\n  ext\n  simp\n#align linear_independent.independent_span_singleton linear_independent.independent_span_singleton\n\n",
 "image_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent.image_subtype {s : set M} {f : «expr →ₗ[ ] » M R M'}\n    (hs : linear_independent R (fun x => x : s → M)) (hf_inj : Disjoint (span R s) f.ker) :\n    linear_independent R (fun x => x : «expr '' » f s → M') :=\n  by\n  rw [← @Subtype.range_coe _ s] at hf_inj\n  refine' (hs.map hf_inj).to_subtype_range' _\n  simp [Set.range_comp f]\n#align linear_independent.image_subtype linear_independent.image_subtype\n\n",
 "image_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent.image_of_comp {ι ι'} (s : set ι) (f : ι → ι') (g : ι' → M)\n    (hs : linear_independent R fun x : s => g (f x)) : linear_independent R fun x : «expr '' » f s => g x :=\n  by\n  nontriviality R\n  have : inj_on f s := inj_on_iff_injective.2 hs.injective.of_comp\n  exact (linear_independent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n#align linear_independent.image_of_comp linear_independent.image_of_comp\n\n",
 "image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent.image {ι} {s : set ι} {f : ι → M} (hs : linear_independent R fun x : s => f x) :\n    linear_independent R fun x : «expr '' » f s => (x : M) := by convert linear_independent.image_of_comp s f id hs\n#align linear_independent.image linear_independent.image\n\n",
 "group_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent.group_smul {G : Type _} [hG : group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] [SMulCommClass G R M] {v : ι → M} (hv : linear_independent R v) (w : ι → G) :\n    linear_independent R («expr • » w v) :=\n  by\n  rw [linear_independent_iff''] at hv⊢\n  intro s g hgs hsum i\n  refine' (smul_eq_zero_iff_eq (w i)).1 _\n  refine' hv s (fun i => «expr • » (w i) (g i)) (fun i hi => _) _ i\n  · dsimp only\n    exact (hgs i hi).symm ▸ smul_zero _\n  · rw [← hsum, finset.sum_congr rfl _]\n    intros\n    erw [pi.smul_apply, smul_assoc, smul_comm]\n#align linear_independent.group_smul linear_independent.group_smul\n\n",
 "fin_cons'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- See `linear_independent.fin_cons` for a family of elements in a vector space. -/\ntheorem linear_independent.fin_cons' {m : ℕ} (x : M) (v : fin m → M) (hli : linear_independent R v)\n    (x_ortho : ∀ (c : R) (y : submodule.span R (Set.range v)), «expr • » c x + y = (0 : M) → c = 0) :\n    linear_independent R (fin.cons x v : fin m.succ → M) :=\n  by\n  rw [fintype.linear_independent_iff] at hli⊢\n  rintro g total_eq j\n  simp_rw [fin.sum_univ_succ, fin.cons_zero, fin.cons_succ] at total_eq\n  have : g 0 = 0 :=\n    by\n    refine'\n      x_ortho (g 0)\n        ⟨finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            («expr • » (g i.succ) (v i)),\n          _⟩\n        total_eq\n    exact sum_mem fun i _ => smul_mem _ _ (subset_span ⟨i, rfl⟩)\n  rw [this, zero_smul, zero_add] at total_eq\n  exact Fin.cases this (hli _ total_eq) j\n#align linear_independent.fin_cons' linear_independent.fin_cons'\n\n",
 "fin_cons":
 "/-- See `linear_independent.fin_cons'` for an uglier version that works if you\nonly have a module over a semiring. -/\ntheorem linear_independent.fin_cons {n} {v : fin n → V} (hv : linear_independent K v)\n    (hx : x ∉ submodule.span K (range v)) : linear_independent K (fin.cons x v : fin (n + 1) → V) :=\n  linear_independent_fin_cons.2 ⟨hv, hx⟩\n#align linear_independent.fin_cons linear_independent.fin_cons\n\n",
 "extend_subset":
 "theorem linear_independent.extend_subset (hs : linear_independent K (fun x => x : s → V)) (hst : s ⊆ t) :\n    hs.extend hst ⊆ t :=\n  let ⟨hbt, hsb, htb, hli⟩ := Classical.choose_spec (exists_linear_independent_extension hs hst)\n  hbt\n#align linear_independent.extend_subset linear_independent.extend_subset\n\n",
 "exists_of_linear_independent_of_finite_span":
 "-- TODO(Mario): rewrite?\ntheorem exists_of_linear_independent_of_finite_span {t : Finset V} (hs : linear_independent K (fun x => x : s → V))\n    (hst : s ⊆ (span K ↑t : submodule K V)) : ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = t.card :=\n  by\n  have :\n    ∀ t,\n      ∀ s' : Finset V,\n        ↑s' ⊆ s →\n          s ∩ ↑t = ∅ →\n            s ⊆ (span K ↑(s' ∪ t) : submodule K V) →\n              ∃ t' : Finset V, ↑t' ⊆ s ∪ ↑t ∧ s ⊆ ↑t' ∧ t'.card = (s' ∪ t).card :=\n    fun t =>\n    Finset.induction_on t\n      (fun s' hs' _ hss' =>\n        have : s = ↑s' := eq_of_linear_independent_of_span_subtype hs hs' <| by simpa using hss'\n        ⟨s', by simp [this]⟩)\n      fun b₁ t hb₁t ih s' hs' hst hss' =>\n      have hb₁s : b₁ ∉ s := fun h =>\n        by\n        have : b₁ ∈ s ∩ ↑(insert b₁ t) := ⟨h, Finset.mem_insert_self _ _⟩\n        rwa [hst] at this\n      have hb₁s' : b₁ ∉ s' := fun h => hb₁s <| hs' h\n      have hst : s ∩ ↑t = ∅ :=\n        eq_empty_of_subset_empty <| Subset.trans (by simp [inter_subset_inter, subset.refl]) (le_of_eq hst)\n      by_cases\n        (fun this : s ⊆ (span K ↑(s' ∪ t) : submodule K V) =>\n          let ⟨u, hust, hsu, eq⟩ := ih _ hs' hst this\n          have hb₁u : b₁ ∉ u := fun h => (hust h).elim hb₁s hb₁t\n          ⟨insert b₁ u, by simp [insert_subset_insert hust], Subset.trans hsu (by simp), by\n            simp [eq, hb₁t, hb₁s', hb₁u]⟩)\n        fun this : ¬s ⊆ (span K ↑(s' ∪ t) : submodule K V) =>\n        let ⟨b₂, hb₂s, hb₂t⟩ := not_subset.mp this\n        have hb₂t' : b₂ ∉ s' ∪ t := fun h => hb₂t <| subset_span h\n        have : s ⊆ (span K ↑(insert b₂ s' ∪ t) : submodule K V) := fun b₃ hb₃ =>\n          by\n          have : ↑(s' ∪ insert b₁ t) ⊆ insert b₁ (insert b₂ ↑(s' ∪ t) : set V) := by\n            simp [insert_eq, -singleton_union, -union_singleton, union_subset_union, subset.refl, subset_union_right]\n          have hb₃ : b₃ ∈ span K (insert b₁ (insert b₂ ↑(s' ∪ t) : set V)) := span_mono this (hss' hb₃)\n          have : s ⊆ (span K (insert b₁ ↑(s' ∪ t)) : submodule K V) := by\n            simpa [insert_eq, -singleton_union, -union_singleton] using hss'\n          have hb₁ : b₁ ∈ span K (insert b₂ ↑(s' ∪ t)) := mem_span_insert_exchange (this hb₂s) hb₂t\n          rw [span_insert_eq_span hb₁] at hb₃ <;> simpa using hb₃\n        let ⟨u, hust, hsu, eq⟩ := ih _ (by simp [insert_subset, hb₂s, hs']) hst this\n        ⟨u, Subset.trans hust <| union_subset_union (Subset.refl _) (by simp [subset_insert]), hsu, by\n          simp [eq, hb₂t', hb₁t, hb₁s']⟩\n  have eq : ((t.filter fun x => x ∈ s) ∪ t.filter fun x => x ∉ s) = t :=\n    by\n    ext1 x\n    by_cases x ∈ s <;> simp [*]\n  apply\n    exists.elim\n      (this (t.filter fun x => x ∉ s) (t.filter fun x => x ∈ s) (by simp [Set.subset_def])\n        (by simp (config := { contextual := true }) [Set.ext_iff]) (by rwa [eq]))\n  intro u h\n  exact\n    ⟨u, subset.trans h.1 (by simp (config := { contextual := true }) [subset_def, and_imp, or_imp]), h.2.1, by\n      simp only [h.2.2, eq]⟩\n#align exists_of_linear_independent_of_finite_span exists_of_linear_independent_of_finite_span\n\n",
 "exists_maximal_independent'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem exists_maximal_independent' (s : ι → M) :\n    ∃ I : set ι,\n      (linear_independent R fun x : I => s x) ∧ ∀ J : set ι, I ⊆ J → (linear_independent R fun x : J => s x) → I = J :=\n  by\n  let indep : set ι → Prop := fun I => linear_independent R (s ∘ coe : I → M)\n  let X := { I : set ι // indep I }\n  let r : X → X → Prop := fun I J => I.1 ⊆ J.1\n  have key :\n    ∀ c : set X,\n      IsChain r c →\n        indep («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" I) :=\n    by\n    intro c hc\n    dsimp [indep]\n    rw [linear_independent_comp_subtype]\n    intro f hsupport hsum\n    rcases eq_empty_or_nonempty c with (rfl | hn)\n    · simpa using hsupport\n    haveI : is_refl X r := ⟨fun _ => Set.Subset.refl _⟩\n    obtain ⟨I, I_mem, hI⟩ : ∃ I ∈ c, (f.support : set ι) ⊆ I :=\n      hc.directed_on.exists_mem_subset_of_finset_subset_bUnion hn hsupport\n    exact linear_independent_comp_subtype.mp I.2 f hI hsum\n  have trans : transitive r := fun I J K => Set.Subset.trans\n  obtain ⟨⟨I, hli : indep I⟩, hmax : ∀ a, r ⟨I, hli⟩ a → r a ⟨I, hli⟩⟩ :=\n    @exists_maximal_of_chains_bounded _ r\n      (fun c hc =>\n        ⟨⟨«expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (I : set ι),\n            key c hc⟩,\n          fun I => Set.subset_bunionᵢ_of_mem⟩)\n      trans\n  exact ⟨I, hli, fun J hsub hli => Set.Subset.antisymm hsub (hmax ⟨J, hli⟩ hsub)⟩\n#align exists_maximal_independent' exists_maximal_independent'\n\n",
 "exists_maximal_independent":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (i «expr ∉ » I) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem exists_maximal_independent (s : ι → M) :\n    ∃ I : set ι,\n      (linear_independent R fun x : I => s x) ∧\n        ∀ (i) (_ : i ∉ I), ∃ a : R, a ≠ 0 ∧ «expr • » a (s i) ∈ span R («expr '' » s I) :=\n  by\n  classical\n    rcases exists_maximal_independent' R s with ⟨I, hIlinind, hImaximal⟩\n    use I, hIlinind\n    intro i hi\n    specialize hImaximal (I ∪ {i}) (by simp)\n    set J := I ∪ {i} with hJ\n    have memJ : ∀ {x}, x ∈ J ↔ x = i ∨ x ∈ I := by simp [hJ]\n    have hiJ : i ∈ J := by simp\n    have h := mt hImaximal _\n    swap\n    · intro h2\n      rw [h2] at hi\n      exact absurd hiJ hi\n    obtain ⟨f, supp_f, sum_f, f_ne⟩ := linear_dependent_comp_subtype.mp h\n    have hfi : f i ≠ 0 := by\n      contrapose hIlinind\n      refine' linear_dependent_comp_subtype.mpr ⟨f, _, sum_f, f_ne⟩\n      simp only [finsupp.mem_supported, hJ] at supp_f⊢\n      rintro x hx\n      refine' (memJ.mp (supp_f hx)).resolve_left _\n      rintro rfl\n      exact hIlinind (finsupp.mem_support_iff.mp hx)\n    use f i, hfi\n    have hfi' : i ∈ f.support := finsupp.mem_support_iff.mpr hfi\n    rw [← Finset.insert_erase hfi', finset.sum_insert (Finset.not_mem_erase _ _), add_eq_zero_iff_eq_neg] at sum_f\n    rw [sum_f]\n    refine' neg_mem (sum_mem fun c hc => smul_mem _ _ (subset_span ⟨c, _, rfl⟩))\n    exact (memJ.mp (supp_f (Finset.erase_subset _ _ hc))).resolve_left (Finset.ne_of_mem_erase hc)\n#align exists_maximal_independent exists_maximal_independent\n\n",
 "exists_linear_independent_extension":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (b «expr ⊆ » t) -/\ntheorem exists_linear_independent_extension (hs : linear_independent K (coe : s → V)) (hst : s ⊆ t) :\n    ∃ (b : _)(_ : b ⊆ t), s ⊆ b ∧ t ⊆ span K b ∧ linear_independent K (coe : b → V) :=\n  by\n  rcases zorn_subset_nonempty { b | b ⊆ t ∧ linear_independent K (coe : b → V) } _ _ ⟨hst, hs⟩ with ⟨b, ⟨bt, bi⟩, sb, h⟩\n  · refine' ⟨b, bt, sb, fun x xt => _, bi⟩\n    by_contra hn\n    apply hn\n    rw [← h _ ⟨insert_subset.2 ⟨xt, bt⟩, bi.insert hn⟩ (subset_insert _ _)]\n    exact subset_span (mem_insert _ _)\n  · refine' fun c hc cc c0 => ⟨⋃₀ c, ⟨_, _⟩, fun x => _⟩\n    · exact sUnion_subset fun x xc => (hc xc).1\n    · exact linear_independent_sUnion_of_directed cc.directed_on fun x xc => (hc xc).2\n    · exact subset_sUnion_of_mem\n#align exists_linear_independent_extension exists_linear_independent_extension\n\n",
 "exists_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Basic.lean:632:2: warning: expanding binder collection (b «expr ⊆ » t) -/\ntheorem exists_linear_independent : ∃ (b : _)(_ : b ⊆ t), span K b = span K t ∧ linear_independent K (coe : b → V) :=\n  by\n  obtain ⟨b, hb₁, -, hb₂, hb₃⟩ :=\n    exists_linear_independent_extension (linear_independent_empty K V) (Set.empty_subset t)\n  exact ⟨b, hb₁, (span_eq_of_le _ hb₂ (submodule.span_mono hb₁)).symm, hb₃⟩\n#align exists_linear_independent exists_linear_independent\n\n",
 "exists_finite_card_le_of_finite_of_linear_independent_of_span":
 "theorem exists_finite_card_le_of_finite_of_linear_independent_of_span (ht : t.finite)\n    (hs : linear_independent K (fun x => x : s → V)) (hst : s ⊆ span K t) :\n    ∃ h : s.finite, h.to_finset.card ≤ ht.to_finset.card :=\n  have : s ⊆ (span K ↑ht.to_finset : submodule K V) := by simp <;> assumption\n  let ⟨u, hust, hsu, eq⟩ := exists_of_linear_independent_of_finite_span hs this\n  have : s.finite := u.finite_to_set.subset hsu\n  ⟨this, by rw [← eq] <;> exact finset.card_le_of_subset <| finset.coe_subset.mp <| by simp [hsu]⟩\n#align\n  exists_finite_card_le_of_finite_of_linear_independent_of_span exists_finite_card_le_of_finite_of_linear_independent_of_span\n\n",
 "eq_of_smul_apply_eq_smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Linear independent families are injective, even if you multiply either side. -/\ntheorem linear_independent.eq_of_smul_apply_eq_smul_apply {M : Type _} [add_comm_group M] [Module R M] {v : ι → M}\n    (li : linear_independent R v) (c d : R) (i j : ι) (hc : c ≠ 0) (h : «expr • » c (v i) = «expr • » d (v j)) :\n    i = j := by\n  let l : «expr →₀ » ι R := finsupp.single i c - finsupp.single j d\n  have h_total : finsupp.total ι M R v l = 0 :=\n    by\n    simp_rw [linear_map.map_sub, finsupp.total_apply]\n    simp [h]\n  have h_single_eq : finsupp.single i c = finsupp.single j d :=\n    by\n    rw [linear_independent_iff] at li\n    simp [eq_add_of_sub_eq' (li l h_total)]\n  rcases(finsupp.single_eq_single_iff _ _ _ _).mp h_single_eq with (⟨this, _⟩ | ⟨hc, _⟩)\n  · exact this\n  · contradiction\n#align linear_independent.eq_of_smul_apply_eq_smul_apply linear_independent.eq_of_smul_apply_eq_smul_apply\n\n",
 "eq_of_linear_independent_of_span_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\ntheorem eq_of_linear_independent_of_span_subtype [nontrivial R] {s t : set M}\n    (hs : linear_independent R (fun x => x : s → M)) (h : t ⊆ s) (hst : s ⊆ span R t) : s = t :=\n  by\n  let f : «expr ↪ » t s := ⟨fun x => ⟨x.1, h x.2⟩, fun a b hab => subtype.coe_injective (subtype.mk.inj hab)⟩\n  have h_surj : surjective f := by\n    apply surjective_of_linear_independent_of_span hs f _\n    convert hst <;> simp [f, comp]\n  show s = t\n  · apply subset.antisymm _ h\n    intro x hx\n    rcases h_surj ⟨x, hx⟩ with ⟨y, hy⟩\n    convert y.mem\n    rw [← subtype.mk.inj hy]\n    rfl\n#align eq_of_linear_independent_of_span_subtype eq_of_linear_independent_of_span_subtype\n\n",
 "disjoint_span_image":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem linear_independent.disjoint_span_image (hv : linear_independent R v) {s t : set ι} (hs : Disjoint s t) :\n    Disjoint (submodule.span R <| «expr '' » v s) (submodule.span R <| «expr '' » v t) :=\n  by\n  simp only [disjoint_def, finsupp.mem_span_image_iff_total]\n  rintro _ ⟨l₁, hl₁, rfl⟩ ⟨l₂, hl₂, H⟩\n  rw [hv.injective_total.eq_iff] at H; subst l₂\n  have : l₁ = 0 := submodule.disjoint_def.mp (finsupp.disjoint_supported_supported hs) _ hl₁ hl₂\n  simp [this]\n#align linear_independent.disjoint_span_image linear_independent.disjoint_span_image\n\n",
 "comp":
 "/-- A subfamily of a linearly independent family (i.e., a composition with an injective map) is a\nlinearly independent family. -/\ntheorem linear_independent.comp (h : linear_independent R v) (f : ι' → ι) (hf : injective f) :\n    linear_independent R (v ∘ f) := by\n  rw [linear_independent_iff, finsupp.total_comp]\n  intro l hl\n  have h_map_domain : ∀ x, (finsupp.map_domain f l) (f x) = 0 := by\n    rw [linear_independent_iff.1 h (finsupp.map_domain f l) hl] <;> simp\n  ext x\n  convert h_map_domain x\n  rw [finsupp.map_domain_apply hf]\n#align linear_independent.comp linear_independent.comp\n\n",
 "coe_range":
 "theorem linear_independent.coe_range (i : linear_independent R v) : linear_independent R (coe : range v → M) := by\n  simpa using i.comp _ (range_splitting_injective v)\n#align linear_independent.coe_range linear_independent.coe_range\n\n"}