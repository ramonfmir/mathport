{"zero_right":
 "@[simp]\ntheorem zero_right (x : M) : B x 0 = 0 := by rw [← @zero_smul _ _ _ _ _ (0 : M), smul_right, MulZeroClass.zero_mul]\n#align zero_right zero_right\n\n",
 "zero_left":
 "@[simp]\ntheorem zero_left (x : M) : B 0 x = 0 := by rw [← @zero_smul R _ _ _ _ (0 : M), smul_left, MulZeroClass.zero_mul]\n#align zero_left zero_left\n\n",
 "zero_apply":
 "@[simp]\ntheorem zero_apply (x y : M) : (0 : bilin_form R M) x y = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "to_lin_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem bilin_form.to_lin_symm :\n    (bilin_form.to_lin.symm : «expr ≃ₗ[ ] » _ R₂ (bilin_form R₂ M₂)) = linear_map.to_bilin :=\n  linear_map.to_bilin.symm_symm\n#align bilin_form.to_lin_symm bilin_form.to_lin_symm\n\n",
 "to_lin_restrict_range_dual_coannihilator_eq_orthogonal":
 "theorem to_lin_restrict_range_dual_coannihilator_eq_orthogonal (B : bilin_form K V) (W : Subspace K V) :\n    (B.to_lin.dom_restrict W).range.dual_coannihilator = B.orthogonal W :=\n  by\n  ext x; constructor <;> rw [mem_orthogonal_iff] <;> intro hx\n  · intro y hy\n    rw [submodule.mem_dual_coannihilator] at hx\n    refine' hx (B.to_lin.dom_restrict W ⟨y, hy⟩) ⟨⟨y, hy⟩, rfl⟩\n  · rw [submodule.mem_dual_coannihilator]\n    rintro _ ⟨⟨w, hw⟩, rfl⟩\n    exact hx w hw\n#align to_lin_restrict_range_dual_coannihilator_eq_orthogonal to_lin_restrict_range_dual_coannihilator_eq_orthogonal\n\n",
 "to_lin_restrict_ker_eq_inf_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem to_lin_restrict_ker_eq_inf_orthogonal (B : bilin_form K V) (W : Subspace K V) (b : B.is_refl) :\n    (B.to_lin.dom_restrict W).ker.map W.subtype = («expr ⊓ » W (B.orthogonal («expr⊤»)) : Subspace K V) :=\n  by\n  ext x; constructor <;> intro hx\n  · rcases hx with ⟨⟨x, hx⟩, hker, rfl⟩\n    erw [LinearMap.mem_ker] at hker\n    constructor\n    · simp [hx]\n    · intro y _\n      rw [is_ortho, b]\n      change (B.to_lin.dom_restrict W) ⟨x, hx⟩ y = 0\n      rw [hker]\n      rfl\n  · simp_rw [Submodule.mem_map, LinearMap.mem_ker]\n    refine' ⟨⟨x, hx.1⟩, _, rfl⟩\n    ext y\n    change B x y = 0\n    rw [b]\n    exact hx.2 _ Submodule.mem_top\n#align to_lin_restrict_ker_eq_inf_orthogonal to_lin_restrict_ker_eq_inf_orthogonal\n\n",
 "to_lin_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem bilin_form.to_lin_apply (x : M₂) : «expr⇑ » (bilin_form.to_lin B₂ x) = B₂ x :=\n  rfl\n#align bilin_form.to_lin_apply bilin_form.to_lin_apply\n\n",
 "to_lin'_flip_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem to_lin'_flip_apply (A : bilin_form R M) (x : M) : «expr⇑ » (to_lin_hom_flip R₂ A x) = fun y => A y x :=\n  rfl\n#align to_lin'_flip_apply to_lin'_flip_apply\n\n",
 "to_lin'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem to_lin'_apply (A : bilin_form R M) (x : M) : «expr⇑ » (to_lin_hom R₂ A x) = A x :=\n  rfl\n#align to_lin'_apply to_lin'_apply\n\n",
 "to_dual_def":
 "theorem to_dual_def {B : bilin_form K V} (b : B.nondegenerate) {m n : V} : B.to_dual b m n = B m n :=\n  rfl\n#align to_dual_def to_dual_def\n\n",
 "to_bilin_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_bilin_symm :\n    (linear_map.to_bilin.symm : «expr ≃ₗ[ ] » (bilin_form R₂ M₂) R₂ _) = bilin_form.to_lin :=\n  rfl\n#align linear_map.to_bilin_symm linear_map.to_bilin_symm\n\n",
 "to_bilin_aux_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem linear_map.to_bilin_aux_eq (f : «expr →ₗ[ ] » M₂ R₂ («expr →ₗ[ ] » M₂ R₂ R₂)) :\n    linear_map.to_bilin_aux f = linear_map.to_bilin f :=\n  rfl\n#align linear_map.to_bilin_aux_eq linear_map.to_bilin_aux_eq\n\n",
 "symm_comp_of_nondegenerate_left_apply":
 "@[simp]\ntheorem symm_comp_of_nondegenerate_left_apply (B₁ : bilin_form K V) {B₂ : bilin_form K V} (b₂ : B₂.nondegenerate)\n    (v w : V) : B₂ (symm_comp_of_nondegenerate B₁ B₂ b₂ w) v = B₁ w v :=\n  by\n  conv_lhs => rw [← bilin_form.to_lin_apply, comp_symm_comp_of_nondegenerate_apply]\n  rfl\n#align symm_comp_of_nondegenerate_left_apply symm_comp_of_nondegenerate_left_apply\n\n",
 "sum_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem sum_right {α} (t : Finset α) (w : M) (g : α → M) :\n    B w (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (g i)) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (B w (g i)) :=\n  (bilin_form.to_lin' B w).map_sum\n#align sum_right sum_right\n\n",
 "sum_repr_mul_repr_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Write out `B x y` as a sum over `B (b i) (b j)` if `b` is a basis. -/\ntheorem sum_repr_mul_repr_mul (x y : M₂) :\n    ((b.repr x).sum fun i xi => (b.repr y).sum fun j yj => «expr • » xi («expr • » yj (B₂ (b i) (b j)))) = B₂ x y :=\n  by\n  conv_rhs => rw [← b.total_repr x, ← b.total_repr y]\n  simp_rw [Finsupp.total_apply, Finsupp.sum, sum_left, sum_right, smul_left, smul_right, smul_eq_mul]\n#align sum_repr_mul_repr_mul sum_repr_mul_repr_mul\n\n",
 "sum_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n@[simp]\ntheorem sum_left {α} (t : Finset α) (g : α → M) (w : M) :\n    B (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (g i)) w =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (B (g i) w) :=\n  (bilin_form.to_lin' B).map_sum₂ t g w\n#align sum_left sum_left\n\n",
 "sub_right":
 "@[simp]\ntheorem sub_right (x y z : M₁) : B₁ x (y - z) = B₁ x y - B₁ x z := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, add_right, neg_right]\n#align sub_right sub_right\n\n",
 "sub_left":
 "@[simp]\ntheorem sub_left (x y z : M₁) : B₁ (x - y) z = B₁ x z - B₁ y z := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, add_left, neg_left]\n#align sub_left sub_left\n\n",
 "sub_apply":
 "@[simp]\ntheorem sub_apply (x y : M₁) : (B₁ - D₁) x y = B₁ x y - D₁ x y :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "sub":
 "theorem is_adjoint_pair.sub (h : is_adjoint_pair B₁ B₁' f₁ g₁) (h' : is_adjoint_pair B₁ B₁' f₁' g₁') :\n    is_adjoint_pair B₁ B₁' (f₁ - f₁') (g₁ - g₁') := fun x y => by\n  rw [LinearMap.sub_apply, LinearMap.sub_apply, sub_left, sub_right, h, h']\n#align is_adjoint_pair.sub is_adjoint_pair.sub\n\n",
 "span_singleton_sup_orthogonal_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem span_singleton_sup_orthogonal_eq_top {B : bilin_form K V} {x : V} (hx : ¬B.is_ortho x x) :\n    «expr ⊔ » («expr ∙ » K x) (B.orthogonal («expr ∙ » K x)) = «expr⊤» :=\n  by\n  rw [orthogonal_span_singleton_eq_to_lin_ker]\n  exact LinearMap.span_singleton_sup_ker_eq_top _ hx\n#align span_singleton_sup_orthogonal_eq_top span_singleton_sup_orthogonal_eq_top\n\n",
 "span_singleton_inf_orthogonal_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- ↓ This lemma only applies in fields as we require `a * b = 0 → a = 0 ∨ b = 0`\ntheorem span_singleton_inf_orthogonal_eq_bot {B : bilin_form K V} {x : V} (hx : ¬B.is_ortho x x) :\n    «expr ⊓ » («expr ∙ » K x) (B.orthogonal («expr ∙ » K x)) = «expr⊥» :=\n  by\n  rw [← Finset.coe_singleton]\n  refine' eq_bot_iff.2 fun y h => _\n  rcases mem_span_finset.1 h.1 with ⟨μ, rfl⟩\n  have := h.2 x _\n  · rw [Finset.sum_singleton] at this⊢\n    suffices hμzero : μ x = 0\n    · rw [hμzero, zero_smul, Submodule.mem_bot]\n    change B x («expr • » (μ x) x) = 0 at this\n    rw [smul_right] at this\n    exact or.elim (zero_eq_mul.mp this.symm) id fun hfalse => false.elim <| hx hfalse\n  · rw [Submodule.mem_span] <;> exact fun _ hp => hp <| Finset.mem_singleton_self _\n#align span_singleton_inf_orthogonal_eq_bot span_singleton_inf_orthogonal_eq_bot\n\n",
 "smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_right (a : R) (x y : M) : B x («expr • » a y) = a * B x y :=\n  bilin_smul_right B a x y\n#align smul_right smul_right\n\n",
 "smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_left (a : R) (x y : M) : B («expr • » a x) y = a * B x y :=\n  bilin_smul_left B a x y\n#align smul_left smul_left\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply {α} [Monoid α] [DistribMulAction α R] [SMulCommClass α R R] (a : α) (B : bilin_form R M) (x y : M) :\n    («expr • » a B) x y = «expr • » a (B x y) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem is_adjoint_pair.smul (c : R₂) (h : is_adjoint_pair B₂ B₂' f₂ g₂) :\n    is_adjoint_pair B₂ B₂' («expr • » c f₂) («expr • » c g₂) := fun x y => by\n  rw [LinearMap.smul_apply, LinearMap.smul_apply, smul_left, smul_right, h]\n#align is_adjoint_pair.smul is_adjoint_pair.smul\n\n",
 "self_eq_zero":
 "theorem self_eq_zero (H : B.is_alt) (x : M) : B x x = 0 :=\n  H x\n#align self_eq_zero self_eq_zero\n\n",
 "restrict_symm":
 "/-- The restriction of a symmetric bilinear form on a submodule is also symmetric. -/\ntheorem restrict_symm (B : bilin_form R M) (b : B.is_symm) (W : Submodule R M) : (B.restrict W).is_symm := fun x y =>\n  b x y\n#align restrict_symm restrict_symm\n\n",
 "restrict_orthogonal_span_singleton_nondegenerate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- The restriction of a reflexive, non-degenerate bilinear form on the orthogonal complement of\nthe span of a singleton is also non-degenerate. -/\ntheorem restrict_orthogonal_span_singleton_nondegenerate (B : bilin_form K V) (b₁ : B.nondegenerate) (b₂ : B.is_refl)\n    {x : V} (hx : ¬B.is_ortho x x) : nondegenerate <| B.restrict <| B.orthogonal («expr ∙ » K x) :=\n  by\n  refine' fun m hm => Submodule.coe_eq_zero.1 (b₁ m.1 fun n => _)\n  have : n ∈ «expr ⊔ » («expr ∙ » K x) (B.orthogonal («expr ∙ » K x)) :=\n    (span_singleton_sup_orthogonal_eq_top hx).symm ▸ Submodule.mem_top\n  rcases Submodule.mem_sup.1 this with ⟨y, hy, z, hz, rfl⟩\n  specialize hm ⟨z, hz⟩\n  rw [restrict] at hm\n  erw [add_right, show B m.1 y = 0 by rw [b₂] <;> exact m.2 y hy, hm, add_zero]\n#align restrict_orthogonal_span_singleton_nondegenerate restrict_orthogonal_span_singleton_nondegenerate\n\n",
 "restrict_nondegenerate_of_is_compl_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A subspace is complement to its orthogonal complement with respect to some\nreflexive bilinear form if that bilinear form restricted on to the subspace is nondegenerate. -/\ntheorem restrict_nondegenerate_of_is_compl_orthogonal {B : bilin_form K V} {W : Subspace K V} (b₁ : B.is_refl)\n    (b₂ : (B.restrict W).nondegenerate) : IsCompl W (B.orthogonal W) :=\n  by\n  have : «expr ⊓ » W (B.orthogonal W) = «expr⊥» := by\n    rw [eq_bot_iff]\n    intro x hx\n    obtain ⟨hx₁, hx₂⟩ := Submodule.mem_inf.1 hx\n    refine' Subtype.mk_eq_mk.1 (b₂ ⟨x, hx₁⟩ _)\n    rintro ⟨n, hn⟩\n    rw [restrict_apply, Submodule.coe_mk, Submodule.coe_mk, b₁]\n    exact hx₂ n hn\n  refine' IsCompl.of_eq this (eq_top_of_finrank_eq <| (Submodule.finrank_le _).antisymm _)\n  conv_rhs => rw [← add_zero (finrank K _)]\n  rw [← finrank_bot K V, ← this, Submodule.finrank_sup_add_finrank_inf_eq, finrank_add_finrank_orthogonal b₁]\n  exact le_self_add\n#align restrict_nondegenerate_of_is_compl_orthogonal restrict_nondegenerate_of_is_compl_orthogonal\n\n",
 "restrict_nondegenerate_iff_is_compl_orthogonal":
 "/-- A subspace is complement to its orthogonal complement with respect to some reflexive bilinear\nform if and only if that bilinear form restricted on to the subspace is nondegenerate. -/\ntheorem restrict_nondegenerate_iff_is_compl_orthogonal {B : bilin_form K V} {W : Subspace K V} (b₁ : B.is_refl) :\n    (B.restrict W).nondegenerate ↔ IsCompl W (B.orthogonal W) :=\n  ⟨fun b₂ => restrict_nondegenerate_of_is_compl_orthogonal b₁ b₂, fun h =>\n    B.nondegenerate_restrict_of_disjoint_orthogonal b₁ h.1⟩\n#align restrict_nondegenerate_iff_is_compl_orthogonal restrict_nondegenerate_iff_is_compl_orthogonal\n\n",
 "orthogonal_span_singleton_eq_to_lin_ker":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n-- ↓ This lemma only applies in fields since we use the `mul_eq_zero`\ntheorem orthogonal_span_singleton_eq_to_lin_ker {B : bilin_form K V} (x : V) :\n    B.orthogonal («expr ∙ » K x) = (bilin_form.to_lin B x).ker :=\n  by\n  ext y\n  simp_rw [mem_orthogonal_iff, LinearMap.mem_ker, Submodule.mem_span_singleton]\n  constructor\n  · exact fun h => h x ⟨1, one_smul _ _⟩\n  · rintro h _ ⟨z, rfl⟩\n    rw [is_ortho, smul_left, mul_eq_zero]\n    exact Or.intro_right _ h\n#align orthogonal_span_singleton_eq_to_lin_ker orthogonal_span_singleton_eq_to_lin_ker\n\n",
 "orthogonal_le":
 "theorem orthogonal_le (h : N ≤ L) : B.orthogonal L ≤ B.orthogonal N := fun _ hn l hl => hn l (h hl)\n#align orthogonal_le orthogonal_le\n\n",
 "ortho_comm":
 "theorem ortho_comm (H : B₁.is_alt) {x y : M₁} : is_ortho B₁ x y ↔ is_ortho B₁ y x :=\n  H.is_refl.ortho_comm\n#align ortho_comm ortho_comm\n\n",
 "not_nondegenerate_zero":
 "/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem not_nondegenerate_zero [Nontrivial M] : ¬(0 : bilin_form R M).nondegenerate :=\n  let ⟨m, hm⟩ := exists_ne (0 : M)\n  fun h => hm (h m fun n => rfl)\n#align not_nondegenerate_zero not_nondegenerate_zero\n\n",
 "not_is_ortho_basis_self_of_nondegenerate":
 "/-- An orthogonal basis with respect to a nondegenerate bilinear form has no self-orthogonal\nelements. -/\ntheorem is_Ortho.not_is_ortho_basis_self_of_nondegenerate {n : Type w} [Nontrivial R] {B : bilin_form R M}\n    {v : Basis n R M} (h : B.is_Ortho v) (hB : B.nondegenerate) (i : n) : ¬B.is_ortho (v i) (v i) :=\n  by\n  intro ho\n  refine' v.ne_zero i (hB (v i) fun m => _)\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum, sum_right]\n  apply Finset.sum_eq_zero\n  rintro j -\n  rw [smul_right]\n  convert MulZeroClass.mul_zero _ using 2\n  obtain rfl | hij := eq_or_ne i j\n  · exact ho\n  · exact h hij\n#align is_Ortho.not_is_ortho_basis_self_of_nondegenerate is_Ortho.not_is_ortho_basis_self_of_nondegenerate\n\n",
 "nondegenerate_restrict_of_disjoint_orthogonal":
 "/-- The restriction of a reflexive bilinear form `B` onto a submodule `W` is\nnondegenerate if `disjoint W (B.orthogonal W)`. -/\ntheorem nondegenerate_restrict_of_disjoint_orthogonal (B : bilin_form R₁ M₁) (b : B.is_refl) {W : Submodule R₁ M₁}\n    (hW : Disjoint W (B.orthogonal W)) : (B.restrict W).nondegenerate :=\n  by\n  rintro ⟨x, hx⟩ b₁\n  rw [Submodule.mk_eq_zero, ← Submodule.mem_bot R₁]\n  refine' hW.le_bot ⟨hx, fun y hy => _⟩\n  specialize b₁ ⟨y, hy⟩\n  rw [restrict_apply, Submodule.coe_mk, Submodule.coe_mk] at b₁\n  exact is_ortho_def.mpr (b x y b₁)\n#align nondegenerate_restrict_of_disjoint_orthogonal nondegenerate_restrict_of_disjoint_orthogonal\n\n",
 "nondegenerate_iff_not_is_ortho_basis_self":
 "/-- Given an orthogonal basis with respect to a bilinear form, the bilinear form is nondegenerate\niff the basis has no elements which are self-orthogonal. -/\ntheorem is_Ortho.nondegenerate_iff_not_is_ortho_basis_self {n : Type w} [Nontrivial R] [NoZeroDivisors R]\n    (B : bilin_form R M) (v : Basis n R M) (hO : B.is_Ortho v) : B.nondegenerate ↔ ∀ i, ¬B.is_ortho (v i) (v i) :=\n  by\n  refine' ⟨hO.not_is_ortho_basis_self_of_nondegenerate, fun ho m hB => _⟩\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [LinearEquiv.map_eq_zero_iff]\n  ext i\n  rw [Finsupp.zero_apply]\n  specialize hB (v i)\n  simp_rw [Basis.repr_symm_apply, Finsupp.total_apply, Finsupp.sum, sum_left, smul_left] at hB\n  rw [Finset.sum_eq_single i] at hB\n  · exact eq_zero_of_ne_zero_of_mul_right_eq_zero (ho i) hB\n  · intro j hj hij\n    convert MulZeroClass.mul_zero _ using 2\n    exact hO hij\n  · intro hi\n    convert MulZeroClass.zero_mul _ using 2\n    exact finsupp.not_mem_support_iff.mp hi\n#align is_Ortho.nondegenerate_iff_not_is_ortho_basis_self is_Ortho.nondegenerate_iff_not_is_ortho_basis_self\n\n",
 "nondegenerate_iff_ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A bilinear form is nondegenerate if and only if it has a trivial kernel. -/\ntheorem nondegenerate_iff_ker_eq_bot {B : bilin_form R₂ M₂} : B.nondegenerate ↔ B.to_lin.ker = «expr⊥» :=\n  by\n  rw [LinearMap.ker_eq_bot']\n  constructor <;> intro h\n  · refine' fun m hm => h _ fun x => _\n    rw [← to_lin_apply, hm]\n    rfl\n  · intro m hm\n    apply h\n    ext x\n    exact hm x\n#align nondegenerate_iff_ker_eq_bot nondegenerate_iff_ker_eq_bot\n\n",
 "nondegenerate_congr_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem nondegenerate_congr_iff {B : bilin_form R₂ M₂} (e : «expr ≃ₗ[ ] » M₂ R₂ M₂') :\n    (congr e B).nondegenerate ↔ B.nondegenerate :=\n  ⟨fun h => by\n    convert h.congr e.symm\n    rw [congr_congr, e.self_trans_symm, congr_refl, LinearEquiv.refl_apply], nondegenerate.congr e⟩\n#align nondegenerate_congr_iff nondegenerate_congr_iff\n\n",
 "neg_right":
 "@[simp]\ntheorem neg_right (x y : M₁) : B₁ x (-y) = -B₁ x y := by rw [← @neg_one_smul R₁ _ _, smul_right, neg_one_mul]\n#align neg_right neg_right\n\n",
 "neg_left":
 "@[simp]\ntheorem neg_left (x y : M₁) : B₁ (-x) y = -B₁ x y := by rw [← @neg_one_smul R₁ _ _, smul_left, neg_one_mul]\n#align neg_left neg_left\n\n",
 "neg_eq":
 "#print neg_eq /-\ntheorem neg_eq (H : B₁.is_alt) (x y : M₁) : -B₁ x y = B₁ y x :=\n  by\n  have H1 : B₁ (x + y) (x + y) = 0 := self_eq_zero H (x + y)\n  rw [add_left, add_right, add_right, self_eq_zero H, self_eq_zero H, ring.zero_add, ring.add_zero,\n    add_eq_zero_iff_neg_eq] at H1\n  exact H1\n#align neg_eq neg_eq\n-/\n\n",
 "neg_apply":
 "@[simp]\ntheorem neg_apply (x y : M₁) : (-B₁) x y = -B₁ x y :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "neg":
 "protected theorem neg {B : bilin_form R₁ M₁} (hB : B.is_alt) : (-B).is_alt := fun x => neg_eq_zero.mpr <| hB x\n#align neg neg\n\n",
 "ne_zero_of_not_is_ortho_self":
 "theorem ne_zero_of_not_is_ortho_self {B : bilin_form K V} (x : V) (hx₁ : ¬B.is_ortho x x) : x ≠ 0 := fun hx₂ =>\n  hx₁ (hx₂.symm ▸ is_ortho_zero_left _)\n#align ne_zero_of_not_is_ortho_self ne_zero_of_not_is_ortho_self\n\n",
 "ne_zero":
 "theorem nondegenerate.ne_zero [Nontrivial M] {B : bilin_form R M} (h : B.nondegenerate) : B ≠ 0 := fun h0 =>\n  not_nondegenerate_zero R M <| h0 ▸ h\n#align nondegenerate.ne_zero nondegenerate.ne_zero\n\n",
 "mul":
 "theorem is_adjoint_pair.mul {f g f' g' : Module.End R M} (h : is_adjoint_pair B B f g)\n    (h' : is_adjoint_pair B B f' g') : is_adjoint_pair B B (f * f') (g' * g) := fun x y => by\n  rw [LinearMap.mul_apply, LinearMap.mul_apply, h, h']\n#align is_adjoint_pair.mul is_adjoint_pair.mul\n\n",
 "mem_skew_adjoint_submodule":
 "@[simp]\ntheorem mem_skew_adjoint_submodule (f : Module.End R₃ M₃) : f ∈ B₃.skew_adjoint_submodule ↔ B₃.is_skew_adjoint f :=\n  by\n  rw [is_skew_adjoint_iff_neg_self_adjoint]\n  exact iff.rfl\n#align mem_skew_adjoint_submodule mem_skew_adjoint_submodule\n\n",
 "mem_self_adjoint_submodule":
 "@[simp]\ntheorem mem_self_adjoint_submodule (f : Module.End R₂ M₂) : f ∈ B₂.self_adjoint_submodule ↔ B₂.is_self_adjoint f :=\n  iff.rfl\n#align mem_self_adjoint_submodule mem_self_adjoint_submodule\n\n",
 "mem_orthogonal_iff":
 "@[simp]\ntheorem mem_orthogonal_iff {N : Submodule R M} {m : M} : m ∈ B.orthogonal N ↔ ∀ n ∈ N, is_ortho B n m :=\n  iff.rfl\n#align mem_orthogonal_iff mem_orthogonal_iff\n\n",
 "mem_is_pair_self_adjoint_submodule":
 "@[simp]\ntheorem mem_is_pair_self_adjoint_submodule (f : Module.End R₂ M₂) :\n    f ∈ is_pair_self_adjoint_submodule B₂ F₂ ↔ is_pair_self_adjoint B₂ F₂ f := by rfl\n#align mem_is_pair_self_adjoint_submodule mem_is_pair_self_adjoint_submodule\n\n",
 "linear_independent_of_is_Ortho":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A set of orthogonal vectors `v` with respect to some bilinear form `B` is linearly independent\n  if for all `i`, `B (v i) (v i) ≠ 0`. -/\ntheorem linear_independent_of_is_Ortho {n : Type w} {B : bilin_form K V} {v : n → V} (hv₁ : B.is_Ortho v)\n    (hv₂ : ∀ i, ¬B.is_ortho (v i) (v i)) : LinearIndependent K v := by\n  classical\n    rw [linearIndependent_iff']\n    intro s w hs i hi\n    have : B (s.sum fun i : n => «expr • » (w i) (v i)) (v i) = 0 := by rw [hs, zero_left]\n    have hsum : (s.sum fun j : n => w j * B (v j) (v i)) = w i * B (v i) (v i) :=\n      by\n      apply Finset.sum_eq_single_of_mem i hi\n      intro j hj hij\n      rw [is_Ortho_def.1 hv₁ _ _ hij, MulZeroClass.mul_zero]\n    simp_rw [sum_left, smul_left, hsum] at this\n    exact eq_zero_of_ne_zero_of_mul_right_eq_zero (hv₂ i) this\n#align linear_independent_of_is_Ortho linear_independent_of_is_Ortho\n\n",
 "lin_mul_lin_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lin_mul_lin_comp_right (r : «expr →ₗ[ ] » M₂ R₂ M₂) :\n    (lin_mul_lin f g).comp_right r = lin_mul_lin f (g.comp r) :=\n  rfl\n#align lin_mul_lin_comp_right lin_mul_lin_comp_right\n\n",
 "lin_mul_lin_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lin_mul_lin_comp_left (l : «expr →ₗ[ ] » M₂ R₂ M₂) : (lin_mul_lin f g).comp_left l = lin_mul_lin (f.comp l) g :=\n  rfl\n#align lin_mul_lin_comp_left lin_mul_lin_comp_left\n\n",
 "lin_mul_lin_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem lin_mul_lin_comp (l r : «expr →ₗ[ ] » M₂' R₂ M₂) :\n    (lin_mul_lin f g).comp l r = lin_mul_lin (f.comp l) (g.comp r) :=\n  rfl\n#align lin_mul_lin_comp lin_mul_lin_comp\n\n",
 "lin_mul_lin_apply":
 "@[simp]\ntheorem lin_mul_lin_apply (x y) : lin_mul_lin f g x y = f x * g y :=\n  rfl\n#align lin_mul_lin_apply lin_mul_lin_apply\n\n",
 "le_orthogonal_orthogonal":
 "theorem le_orthogonal_orthogonal (b : B.is_refl) : N ≤ B.orthogonal (B.orthogonal N) := fun n hn m hm => b _ _ (hm n hn)\n#align le_orthogonal_orthogonal le_orthogonal_orthogonal\n\n",
 "ker_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem nondegenerate.ker_eq_bot {B : bilin_form R₂ M₂} (h : B.nondegenerate) : B.to_lin.ker = «expr⊥» :=\n  nondegenerate_iff_ker_eq_bot.mp h\n#align nondegenerate.ker_eq_bot nondegenerate.ker_eq_bot\n\n",
 "is_symm_zero":
 "@[simp]\ntheorem is_symm_zero : (0 : bilin_form R M).is_symm := fun _ _ => rfl\n#align is_symm_zero is_symm_zero\n\n",
 "is_symm_neg":
 "@[simp]\ntheorem is_symm_neg {B : bilin_form R₁ M₁} : (-B).is_symm ↔ B.is_symm :=\n  ⟨fun h => neg_neg B ▸ h.neg, is_symm.neg⟩\n#align is_symm_neg is_symm_neg\n\n",
 "is_symm_iff_flip'":
 "theorem is_symm_iff_flip' [Algebra R₂ R] : B.is_symm ↔ flip_hom R₂ B = B :=\n  by\n  constructor\n  · intro h\n    ext (x y)\n    exact h y x\n  · intro h x y\n    conv_lhs => rw [← h]\n    simp\n#align is_symm_iff_flip' is_symm_iff_flip'\n\n",
 "is_skew_adjoint_iff_neg_self_adjoint":
 "theorem is_skew_adjoint_iff_neg_self_adjoint (f : Module.End R₁ M₁) :\n    B₁.is_skew_adjoint f ↔ is_adjoint_pair (-B₁) B₁ f f :=\n  show (∀ x y, B₁ (f x) y = B₁ x ((-f) y)) ↔ ∀ x y, B₁ (f x) y = (-B₁) x (f y) by\n    simp only [LinearMap.neg_apply, bilin_form.neg_apply, bilin_form.neg_right]\n#align is_skew_adjoint_iff_neg_self_adjoint is_skew_adjoint_iff_neg_self_adjoint\n\n",
 "is_refl_zero":
 "@[simp]\ntheorem is_refl_zero : (0 : bilin_form R M).is_refl := fun _ _ _ => rfl\n#align is_refl_zero is_refl_zero\n\n",
 "is_refl_neg":
 "@[simp]\ntheorem is_refl_neg {B : bilin_form R₁ M₁} : (-B).is_refl ↔ B.is_refl :=\n  ⟨fun h => neg_neg B ▸ h.neg, is_refl.neg⟩\n#align is_refl_neg is_refl_neg\n\n",
 "is_refl":
 "theorem is_refl (H : B₁.is_alt) : B₁.is_refl := by\n  intro x y h\n  rw [← neg_eq H, h, neg_zero]\n#align is_refl is_refl\n\n",
 "is_pair_self_adjoint_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem is_pair_self_adjoint_equiv (e : «expr ≃ₗ[ ] » M₂' R₂ M₂) (f : Module.End R₂ M₂) :\n    is_pair_self_adjoint B₂ F₂ f ↔ is_pair_self_adjoint (B₂.comp ↑e ↑e) (F₂.comp ↑e ↑e) (e.symm.conj f) :=\n  by\n  have hₗ : (F₂.comp ↑e ↑e).comp_left (e.symm.conj f) = (F₂.comp_left f).comp ↑e ↑e :=\n    by\n    ext\n    simp [LinearEquiv.symm_conj_apply]\n  have hᵣ : (B₂.comp ↑e ↑e).comp_right (e.symm.conj f) = (B₂.comp_right f).comp ↑e ↑e :=\n    by\n    ext\n    simp [LinearEquiv.conj_apply]\n  have he : function.surjective («expr⇑ » (↑e : «expr →ₗ[ ] » M₂' R₂ M₂) : M₂' → M₂) := e.surjective\n  show bilin_form.is_adjoint_pair _ _ _ _ ↔ bilin_form.is_adjoint_pair _ _ _ _\n  rw [is_adjoint_pair_iff_comp_left_eq_comp_right, is_adjoint_pair_iff_comp_left_eq_comp_right, hᵣ, hₗ,\n    comp_inj _ _ he he]\n#align is_pair_self_adjoint_equiv is_pair_self_adjoint_equiv\n\n",
 "is_ortho_zero_right":
 "theorem is_ortho_zero_right (x : M) : is_ortho B x (0 : M) :=\n  zero_right x\n#align is_ortho_zero_right is_ortho_zero_right\n\n",
 "is_ortho_zero_left":
 "theorem is_ortho_zero_left (x : M) : is_ortho B (0 : M) x :=\n  zero_left x\n#align is_ortho_zero_left is_ortho_zero_left\n\n",
 "is_ortho_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem is_ortho_smul_right {x y : M₄} {a : R₄} (ha : a ≠ 0) : is_ortho G x («expr • » a y) ↔ is_ortho G x y :=\n  by\n  dsimp only [is_ortho]\n  constructor <;> intro H\n  · rw [smul_right, mul_eq_zero] at H\n    cases H\n    · trivial\n    · exact H\n  · rw [smul_right, H, MulZeroClass.mul_zero]\n#align is_ortho_smul_right is_ortho_smul_right\n\n",
 "is_ortho_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem is_ortho_smul_left {x y : M₄} {a : R₄} (ha : a ≠ 0) : is_ortho G («expr • » a x) y ↔ is_ortho G x y :=\n  by\n  dsimp only [is_ortho]\n  constructor <;> intro H\n  · rw [smul_left, mul_eq_zero] at H\n    cases H\n    · trivial\n    · exact H\n  · rw [smul_left, H, MulZeroClass.mul_zero]\n#align is_ortho_smul_left is_ortho_smul_left\n\n",
 "is_ortho_def":
 "theorem is_ortho_def {B : bilin_form R M} {x y : M} : B.is_ortho x y ↔ B x y = 0 :=\n  iff.rfl\n#align is_ortho_def is_ortho_def\n\n",
 "is_compl_span_singleton_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∙ » -/\n/-- Given a bilinear form `B` and some `x` such that `B x x ≠ 0`, the span of the singleton of `x`\n  is complement to its orthogonal complement. -/\ntheorem is_compl_span_singleton_orthogonal {B : bilin_form K V} {x : V} (hx : ¬B.is_ortho x x) :\n    IsCompl («expr ∙ » K x) (B.orthogonal <| «expr ∙ » K x) :=\n  { disjoint := disjoint_iff.2 <| span_singleton_inf_orthogonal_eq_bot hx\n    codisjoint := codisjoint_iff.2 <| span_singleton_sup_orthogonal_eq_top hx }\n#align is_compl_span_singleton_orthogonal is_compl_span_singleton_orthogonal\n\n",
 "is_alt_zero":
 "@[simp]\ntheorem is_alt_zero : (0 : bilin_form R M).is_alt := fun _ => rfl\n#align is_alt_zero is_alt_zero\n\n",
 "is_alt_neg":
 "@[simp]\ntheorem is_alt_neg {B : bilin_form R₁ M₁} : (-B).is_alt ↔ B.is_alt :=\n  ⟨fun h => neg_neg B ▸ h.neg, is_alt.neg⟩\n#align is_alt_neg is_alt_neg\n\n",
 "is_adjoint_pair_zero":
 "theorem is_adjoint_pair_zero : is_adjoint_pair B B' 0 0 := fun x y => by\n  simp only [bilin_form.zero_left, bilin_form.zero_right, LinearMap.zero_apply]\n#align is_adjoint_pair_zero is_adjoint_pair_zero\n\n",
 "is_adjoint_pair_unique_of_nondegenerate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_adjoint_pair_unique_of_nondegenerate (B : bilin_form R₁ M₁) (b : B.nondegenerate)\n    (φ ψ₁ ψ₂ : «expr →ₗ[ ] » M₁ R₁ M₁) (hψ₁ : is_adjoint_pair B B ψ₁ φ) (hψ₂ : is_adjoint_pair B B ψ₂ φ) : ψ₁ = ψ₂ :=\n  B.comp_left_injective b <| ext fun v w => by rw [comp_left_apply, comp_left_apply, hψ₁, hψ₂]\n#align is_adjoint_pair_unique_of_nondegenerate is_adjoint_pair_unique_of_nondegenerate\n\n",
 "is_adjoint_pair_left_adjoint_of_nondegenerate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_adjoint_pair_left_adjoint_of_nondegenerate (B : bilin_form K V) (b : B.nondegenerate)\n    (φ : «expr →ₗ[ ] » V K V) : is_adjoint_pair B B (B.left_adjoint_of_nondegenerate b φ) φ := fun x y =>\n  (B.comp_right φ).symm_comp_of_nondegenerate_left_apply b y x\n#align is_adjoint_pair_left_adjoint_of_nondegenerate is_adjoint_pair_left_adjoint_of_nondegenerate\n\n",
 "is_adjoint_pair_iff_eq_of_nondegenerate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Given the nondegenerate bilinear form `B`, the linear map `φ` has a unique left adjoint given by\n`bilin_form.left_adjoint_of_nondegenerate`. -/\ntheorem is_adjoint_pair_iff_eq_of_nondegenerate (B : bilin_form K V) (b : B.nondegenerate) (ψ φ : «expr →ₗ[ ] » V K V) :\n    is_adjoint_pair B B ψ φ ↔ ψ = B.left_adjoint_of_nondegenerate b φ :=\n  ⟨fun h => B.is_adjoint_pair_unique_of_nondegenerate b φ ψ _ h (is_adjoint_pair_left_adjoint_of_nondegenerate _ _ _),\n    fun h => h.symm ▸ is_adjoint_pair_left_adjoint_of_nondegenerate _ _ _⟩\n#align is_adjoint_pair_iff_eq_of_nondegenerate is_adjoint_pair_iff_eq_of_nondegenerate\n\n",
 "is_adjoint_pair_iff_comp_left_eq_comp_right":
 "theorem is_adjoint_pair_iff_comp_left_eq_comp_right (f g : Module.End R M) :\n    is_adjoint_pair B F f g ↔ F.comp_left f = B.comp_right g :=\n  by\n  constructor <;> intro h\n  · ext (x y)\n    rw [comp_left_apply, comp_right_apply]\n    apply h\n  · intro x y\n    rw [← comp_left_apply, ← comp_right_apply]\n    rw [h]\n#align is_adjoint_pair_iff_comp_left_eq_comp_right is_adjoint_pair_iff_comp_left_eq_comp_right\n\n",
 "is_adjoint_pair_id":
 "theorem is_adjoint_pair_id : is_adjoint_pair B B 1 1 := fun x y => rfl\n#align is_adjoint_pair_id is_adjoint_pair_id\n\n",
 "is_Ortho_def":
 "theorem is_Ortho_def {n : Type w} {B : bilin_form R M} {v : n → M} :\n    B.is_Ortho v ↔ ∀ i j : n, i ≠ j → B (v i) (v j) = 0 :=\n  iff.rfl\n#align is_Ortho_def is_Ortho_def\n\n",
 "group_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem group_smul {α} [Group α] [DistribMulAction α R] [SMulCommClass α R R] (a : α) {B : bilin_form R M}\n    (hB : B.is_refl) : («expr • » a B).is_refl := fun x y =>\n  (smul_eq_zero_iff_eq _).mpr ∘ hB x y ∘ (smul_eq_zero_iff_eq _).mp\n#align group_smul group_smul\n\n",
 "flip_flip_aux":
 "theorem flip_flip_aux [Algebra R₂ R] (A : bilin_form R M) : (flip_hom_aux R₂) (flip_hom_aux R₂ A) = A :=\n  by\n  ext (A x y)\n  simp [flip_hom_aux]\n#align flip_flip_aux flip_flip_aux\n\n",
 "flip_flip":
 "theorem flip_flip [Algebra R₂ R] : (flip_hom R₂).trans (flip_hom R₂) = LinearEquiv.refl R₂ (bilin_form R M) :=\n  by\n  ext (A x y)\n  simp\n#align flip_flip flip_flip\n\n",
 "flip_apply":
 "@[simp]\ntheorem flip_apply [Algebra R₂ R] (A : bilin_form R M) (x y : M) : flip_hom R₂ A x y = A y x :=\n  rfl\n#align flip_apply flip_apply\n\n",
 "finrank_add_finrank_orthogonal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem finrank_add_finrank_orthogonal {B : bilin_form K V} {W : Subspace K V} (b₁ : B.is_refl) :\n    finrank K W + finrank K (B.orthogonal W) =\n      finrank K V + finrank K («expr ⊓ » W (B.orthogonal («expr⊤»)) : Subspace K V) :=\n  by\n  rw [← to_lin_restrict_ker_eq_inf_orthogonal _ _ b₁, ← to_lin_restrict_range_dual_coannihilator_eq_orthogonal _ _,\n    submodule.finrank_map_subtype_eq]\n  conv_rhs =>\n    rw [← @subspace.finrank_add_finrank_dual_coannihilator_eq K V _ _ _ _ (B.to_lin.dom_restrict W).range, add_comm, ←\n      add_assoc, add_comm (finrank K («expr↥ » (B.to_lin.dom_restrict W).ker)), LinearMap.finrank_range_add_finrank_ker]\n#align finrank_add_finrank_orthogonal finrank_add_finrank_orthogonal\n\n",
 "ext_iff":
 "theorem ext_iff : B = D ↔ ∀ x y, B x y = D x y :=\n  ⟨congr_fun, ext⟩\n#align ext_iff ext_iff\n\n",
 "ext_basis":
 "/-- Two bilinear forms are equal when they are equal on all basis vectors. -/\ntheorem ext_basis (h : ∀ i j, B₂ (b i) (b j) = F₂ (b i) (b j)) : B₂ = F₂ :=\n  to_lin.injective <| b.ext fun i => b.ext fun j => h i j\n#align ext_basis ext_basis\n\n",
 "ext":
 "@[ext]\ntheorem ext (H : ∀ x y : M, B x y = D x y) : B = D :=\n  coe_injective <| by\n    funext\n    exact H _ _\n#align ext ext\n\n",
 "eq_zero":
 "theorem eq_zero : ∀ {x y : M}, B x y = 0 → B y x = 0 := fun x y => H x y\n#align eq_zero eq_zero\n\n",
 "eq":
 "theorem is_adjoint_pair.eq (h : is_adjoint_pair B B' f g) : ∀ {x y}, B' (f x) y = B x (g y) :=\n  h\n#align is_adjoint_pair.eq is_adjoint_pair.eq\n\n",
 "dual_basis_repr_apply":
 "@[simp]\ntheorem dual_basis_repr_apply (B : bilin_form K V) (hB : B.nondegenerate) (b : Basis ι K V) (x i) :\n    (B.dual_basis hB b).repr x i = B x (b i) := by\n  rw [dual_basis, basis.map_repr, LinearEquiv.symm_symm, LinearEquiv.trans_apply, basis.dual_basis_repr, to_dual_def]\n#align dual_basis_repr_apply dual_basis_repr_apply\n\n",
 "congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem congr_trans (e : «expr ≃ₗ[ ] » M₂ R₂ M₂') (f : «expr ≃ₗ[ ] » M₂' R₂ M₂'') :\n    (congr e).trans (congr f) = congr (e.trans f) :=\n  rfl\n#align congr_trans congr_trans\n\n",
 "congr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem congr_symm (e : «expr ≃ₗ[ ] » M₂ R₂ M₂') : (congr e).symm = congr e.symm :=\n  by\n  ext (B x y)\n  simp only [congr_apply, LinearEquiv.symm_symm]\n  rfl\n#align congr_symm congr_symm\n\n",
 "congr_refl":
 "@[simp]\ntheorem congr_refl : congr (LinearEquiv.refl R₂ M₂) = LinearEquiv.refl R₂ _ :=\n  LinearEquiv.ext fun B => ext fun x y => rfl\n#align congr_refl congr_refl\n\n",
 "congr_fun":
 "#print congr_fun /-\ntheorem congr_fun (h : B = D) (x y : M) : B x y = D x y :=\n  h ▸ rfl\n#align congr_fun congr_fun\n-/\n\n",
 "congr_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem congr_congr (e : «expr ≃ₗ[ ] » M₂' R₂ M₂'') (f : «expr ≃ₗ[ ] » M₂ R₂ M₂') (B : bilin_form R₂ M₂) :\n    congr e (congr f B) = congr (f.trans e) B :=\n  rfl\n#align congr_congr congr_congr\n\n",
 "congr_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem congr_comp (e : «expr ≃ₗ[ ] » M₂ R₂ M₂') (B : bilin_form R₂ M₂) (l r : «expr →ₗ[ ] » M₂'' R₂ M₂') :\n    (congr e B).comp l r =\n      B.comp (LinearMap.comp (e.symm : «expr →ₗ[ ] » M₂' R₂ M₂) l)\n        (LinearMap.comp (e.symm : «expr →ₗ[ ] » M₂' R₂ M₂) r) :=\n  rfl\n#align congr_comp congr_comp\n\n",
 "congr_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem congr_apply (e : «expr ≃ₗ[ ] » M₂ R₂ M₂') (B : bilin_form R₂ M₂) (x y : M₂') :\n    congr e B x y = B (e.symm x) (e.symm y) :=\n  rfl\n#align congr_apply congr_apply\n\n",
 "congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem nondegenerate.congr {B : bilin_form R₂ M₂} (e : «expr ≃ₗ[ ] » M₂ R₂ M₂') (h : B.nondegenerate) :\n    (congr e B).nondegenerate := fun m hm =>\n  e.symm.map_eq_zero_iff.1 <| h (e.symm m) fun n => (congr_arg _ (e.symm_apply_apply n).symm).trans (hm (e n))\n#align nondegenerate.congr nondegenerate.congr\n\n",
 "comp_symm_comp_of_nondegenerate_apply":
 "theorem comp_symm_comp_of_nondegenerate_apply (B₁ : bilin_form K V) {B₂ : bilin_form K V} (b₂ : B₂.nondegenerate)\n    (v : V) : to_lin B₂ (B₁.symm_comp_of_nondegenerate B₂ b₂ v) = to_lin B₁ v := by\n  erw [symm_comp_of_nondegenerate, LinearEquiv.apply_symm_apply (B₂.to_dual b₂) _]\n#align comp_symm_comp_of_nondegenerate_apply comp_symm_comp_of_nondegenerate_apply\n\n",
 "comp_right_id":
 "@[simp]\ntheorem comp_right_id (B : bilin_form R M) : B.comp_right LinearMap.id = B :=\n  by\n  ext\n  rfl\n#align comp_right_id comp_right_id\n\n",
 "comp_right_comp_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_right_comp_left (B : bilin_form R M) (l r : «expr →ₗ[ ] » M R M) :\n    (B.comp_right r).comp_left l = B.comp l r :=\n  rfl\n#align comp_right_comp_left comp_right_comp_left\n\n",
 "comp_right_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_right_apply (B : bilin_form R M) (f : «expr →ₗ[ ] » M R M) (v w) : B.comp_right f v w = B v (f w) :=\n  rfl\n#align comp_right_apply comp_right_apply\n\n",
 "comp_left_injective":
 "theorem comp_left_injective (B : bilin_form R₁ M₁) (b : B.nondegenerate) : function.injective B.comp_left :=\n  fun φ ψ h => by\n  ext w\n  refine' eq_of_sub_eq_zero (b _ _)\n  intro v\n  rw [sub_left, ← comp_left_apply, ← comp_left_apply, ← h, sub_self]\n#align comp_left_injective comp_left_injective\n\n",
 "comp_left_id":
 "@[simp]\ntheorem comp_left_id (B : bilin_form R M) : B.comp_left LinearMap.id = B :=\n  by\n  ext\n  rfl\n#align comp_left_id comp_left_id\n\n",
 "comp_left_comp_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_left_comp_right (B : bilin_form R M) (l r : «expr →ₗ[ ] » M R M) :\n    (B.comp_left l).comp_right r = B.comp l r :=\n  rfl\n#align comp_left_comp_right comp_left_comp_right\n\n",
 "comp_left_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_left_apply (B : bilin_form R M) (f : «expr →ₗ[ ] » M R M) (v w) : B.comp_left f v w = B (f v) w :=\n  rfl\n#align comp_left_apply comp_left_apply\n\n",
 "comp_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem comp_inj (B₁ B₂ : bilin_form R M') {l r : «expr →ₗ[ ] » M R M'} (hₗ : function.surjective l)\n    (hᵣ : function.surjective r) : B₁.comp l r = B₂.comp l r ↔ B₁ = B₂ :=\n  by\n  constructor <;> intro h\n  · -- B₁.comp l r = B₂.comp l r → B₁ = B₂\n    ext\n    cases' hₗ x with x' hx\n    subst hx\n    cases' hᵣ y with y' hy\n    subst hy\n    rw [← comp_apply, ← comp_apply, h]\n  ·-- B₁ = B₂ → B₁.comp l r = B₂.comp l r\n    subst h\n#align comp_inj comp_inj\n\n",
 "comp_id_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_id_right (B : bilin_form R M) (l : «expr →ₗ[ ] » M R M) : B.comp l LinearMap.id = B.comp_left l :=\n  by\n  ext\n  rfl\n#align comp_id_right comp_id_right\n\n",
 "comp_id_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_id_left (B : bilin_form R M) (r : «expr →ₗ[ ] » M R M) : B.comp LinearMap.id r = B.comp_right r :=\n  by\n  ext\n  rfl\n#align comp_id_left comp_id_left\n\n",
 "comp_id_id":
 "-- Shortcut for `comp_id_{left,right}` followed by `comp_{right,left}_id`,\n-- has to be declared after the former two to get the right priority\n@[simp]\ntheorem comp_id_id (B : bilin_form R M) : B.comp LinearMap.id LinearMap.id = B :=\n  by\n  ext\n  rfl\n#align comp_id_id comp_id_id\n\n",
 "comp_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem comp_congr (e : «expr ≃ₗ[ ] » M₂' R₂ M₂'') (B : bilin_form R₂ M₂) (l r : «expr →ₗ[ ] » M₂' R₂ M₂) :\n    congr e (B.comp l r) =\n      B.comp (l.comp (e.symm : «expr →ₗ[ ] » M₂'' R₂ M₂')) (r.comp (e.symm : «expr →ₗ[ ] » M₂'' R₂ M₂')) :=\n  rfl\n#align comp_congr comp_congr\n\n",
 "comp_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem comp_comp {M'' : Type _} [AddCommMonoid M''] [Module R M''] (B : bilin_form R M'') (l r : «expr →ₗ[ ] » M R M')\n    (l' r' : «expr →ₗ[ ] » M' R M'') : (B.comp l' r').comp l r = B.comp (l'.comp l) (r'.comp r) :=\n  rfl\n#align comp_comp comp_comp\n\n",
 "comp_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_apply (B : bilin_form R M') (l r : «expr →ₗ[ ] » M R M') (v w) : B.comp l r v w = B (l v) (r w) :=\n  rfl\n#align comp_apply comp_apply\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem is_adjoint_pair.comp {f' : «expr →ₗ[ ] » M' R M''} {g' : «expr →ₗ[ ] » M'' R M'} (h : is_adjoint_pair B B' f g)\n    (h' : is_adjoint_pair B' B'' f' g') : is_adjoint_pair B B'' (f'.comp f) (g.comp g') := fun x y => by\n  rw [LinearMap.comp_apply, LinearMap.comp_apply, h', h]\n#align is_adjoint_pair.comp is_adjoint_pair.comp\n\n",
 "coe_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_zero : «expr⇑ » (0 : bilin_form R M) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_sub : «expr⇑ » (B₁ - D₁) = B₁ - D₁ :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_smul {α} [Monoid α] [DistribMulAction α R] [SMulCommClass α R R] (a : α) (B : bilin_form R M) :\n    «expr⇑ » («expr • » a B) = «expr • » a B :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_neg : «expr⇑ » (-B₁) = -B₁ :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_injective":
 "-- TODO: instantiate `fun_like`\ntheorem coe_injective : function.injective (coe_fn : bilin_form R M → M → M → R) := fun B D h =>\n  by\n  cases B\n  cases D\n  congr\n#align coe_injective coe_injective\n\n",
 "coe_fn_mk":
 "/-\nCopyright (c) 2018 Andreas Swerdlow. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andreas Swerdlow, Kexing Ying\n-/\n@[simp]\ntheorem coe_fn_mk (f : M → M → R) (h₁ h₂ h₃ h₄) : (bilin_form.mk f h₁ h₂ h₃ h₄ : M → M → R) = f :=\n  rfl\n#align coe_fn_mk coe_fn_mk\n\n",
 "coe_fn_congr":
 "theorem coe_fn_congr : ∀ {x x' y y' : M}, x = x' → y = y' → B x y = B x' y'\n  | _, _, _, _, rfl, rfl => rfl\n#align coe_fn_congr coe_fn_congr\n\n",
 "coe_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_add : «expr⇑ » (B + D) = B + D :=\n  rfl\n#align coe_add coe_add\n\n",
 "apply_dual_basis_right":
 "theorem apply_dual_basis_right (B : bilin_form K V) (hB : B.nondegenerate) (sym : B.is_symm) (b : Basis ι K V) (i j) :\n    B (b i) (B.dual_basis hB b j) = if i = j then 1 else 0 := by rw [Sym, apply_dual_basis_left]\n#align apply_dual_basis_right apply_dual_basis_right\n\n",
 "apply_dual_basis_left":
 "theorem apply_dual_basis_left (B : bilin_form K V) (hB : B.nondegenerate) (b : Basis ι K V) (i j) :\n    B (B.dual_basis hB b i) (b j) = if j = i then 1 else 0 := by\n  rw [dual_basis, Basis.map_apply, basis.coe_dual_basis, ← to_dual_def hB, LinearEquiv.apply_symm_apply,\n    basis.coord_apply, Basis.repr_self, Finsupp.single_apply]\n#align apply_dual_basis_left apply_dual_basis_left\n\n",
 "add_right":
 "@[simp]\ntheorem add_right (x y z : M) : B x (y + z) = B x y + B x z :=\n  bilin_add_right B x y z\n#align add_right add_right\n\n",
 "add_left":
 "@[simp]\ntheorem add_left (x y z : M) : B (x + y) z = B x z + B y z :=\n  bilin_add_left B x y z\n#align add_left add_left\n\n",
 "add_apply":
 "@[simp]\ntheorem add_apply (x y : M) : (B + D) x y = B x y + D x y :=\n  rfl\n#align add_apply add_apply\n\n",
 "add":
 "theorem is_adjoint_pair.add (h : is_adjoint_pair B B' f g) (h' : is_adjoint_pair B B' f' g') :\n    is_adjoint_pair B B' (f + f') (g + g') := fun x y => by\n  rw [LinearMap.add_apply, LinearMap.add_apply, add_left, add_right, h, h']\n#align is_adjoint_pair.add is_adjoint_pair.add\n\n",
 "Eq":
 "#print Eq /-\nprotected theorem Eq (x y : M) : B x y = B y x :=\n  H x y\n#align eq Eq\n-/\n\n"}