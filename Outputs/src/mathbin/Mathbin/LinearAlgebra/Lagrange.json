{"values_eq_on_of_interpolate_eq":
 "theorem values_eq_on_of_interpolate_eq (hvs : Set.InjOn v s) (hrr' : interpolate s v r = interpolate s v r') :\n    ∀ i ∈ s, r i = r' i := fun _ hi => by\n  rw [← eval_interpolate_at_node r hvs hi, hrr', eval_interpolate_at_node r' hvs hi]\n#align values_eq_on_of_interpolate_eq values_eq_on_of_interpolate_eq\n\n",
 "sum_nodal_weight_mul_inv_sub_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_nodal_weight_mul_inv_sub_ne_zero (hvs : Set.InjOn v s) (hx : ∀ i ∈ s, x ≠ v i) (hs : s.nonempty) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (nodal_weight s v i * (x - v i)⁻¹) ≠\n      0 :=\n  @right_ne_zero_of_mul_eq_one _ _ _ (eval x (nodal s v)) _ <| by\n    simpa only [pi.one_apply, interpolate_one hvs hs, eval_one, mul_one] using (eval_interpolate_not_at_node 1 hx).symm\n#align sum_nodal_weight_mul_inv_sub_ne_zero sum_nodal_weight_mul_inv_sub_ne_zero\n\n",
 "sum_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem sum_basis (hvs : Set.InjOn v s) (hs : s.nonempty) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (lagrange.basis s v j) =\n      1 :=\n  by\n  refine' eq_of_degrees_lt_of_eval_index_eq s hvs (lt_of_le_of_lt (degree_sum_le _ _) _) _ _\n  · rw [finset.sup_lt_iff (WithBot.bot_lt_coe s.card)]\n    intro i hi\n    rw [degree_basis hvs hi, WithBot.coe_lt_coe]\n    exact nat.pred_lt (card_ne_zero_of_mem hi)\n  · rw [degree_one, ← with_bot.coe_zero, WithBot.coe_lt_coe]\n    exact nonempty.card_pos hs\n  · intro i hi\n    rw [eval_finset_sum, eval_one, ← add_sum_erase _ _ hi, eval_basis_self hvs hi, add_right_eq_self]\n    refine' sum_eq_zero fun j hj => _\n    rcases mem_erase.mp hj with ⟨hij, hj⟩\n    rw [eval_basis_of_ne hij hi]\n#align sum_basis sum_basis\n\n",
 "nodal_weight_ne_zero":
 "theorem nodal_weight_ne_zero (hvs : Set.InjOn v s) (hi : i ∈ s) : nodal_weight s v i ≠ 0 :=\n  by\n  rw [nodal_weight, prod_ne_zero_iff]\n  intro j hj\n  rcases mem_erase.mp hj with ⟨hij, hj⟩\n  refine' inv_ne_zero (sub_ne_zero_of_ne (mt (hvs.eq_iff hi hj).mp hij.symm))\n#align nodal_weight_ne_zero nodal_weight_ne_zero\n\n",
 "nodal_weight_eq_eval_nodal_erase_inv":
 "theorem nodal_weight_eq_eval_nodal_erase_inv : nodal_weight s v i = (eval (v i) (nodal (s.erase i) v))⁻¹ := by\n  rw [eval_nodal, nodal_weight, prod_inv_distrib]\n#align nodal_weight_eq_eval_nodal_erase_inv nodal_weight_eq_eval_nodal_erase_inv\n\n",
 "nodal_weight_eq_eval_nodal_derative":
 "theorem nodal_weight_eq_eval_nodal_derative (hi : i ∈ s) : nodal_weight s v i = (eval (v i) (nodal s v).derivative)⁻¹ :=\n  by rw [eval_nodal_derivative_eval_node_eq hi, nodal_weight_eq_eval_nodal_erase_inv]\n#align nodal_weight_eq_eval_nodal_derative nodal_weight_eq_eval_nodal_derative\n\n",
 "nodal_insert_eq_nodal":
 "theorem nodal_insert_eq_nodal (hi : i ∉ s) : nodal (insert i s) v = (X - C (v i)) * nodal s v := by\n  simp_rw [nodal, prod_insert hi]\n#align nodal_insert_eq_nodal nodal_insert_eq_nodal\n\n",
 "nodal_erase_eq_nodal_div":
 "theorem nodal_erase_eq_nodal_div (hi : i ∈ s) : nodal (s.erase i) v = nodal s v / (X - C (v i)) :=\n  by\n  rw [nodal_eq_mul_nodal_erase hi, EuclideanDomain.mul_div_cancel_left]\n  exact X_sub_C_ne_zero _\n#align nodal_erase_eq_nodal_div nodal_erase_eq_nodal_div\n\n",
 "nodal_eq_mul_nodal_erase":
 "theorem nodal_eq_mul_nodal_erase [decidable_eq ι] (hi : i ∈ s) : nodal s v = (X - C (v i)) * nodal (s.erase i) v := by\n  simp_rw [nodal, mul_prod_erase _ _ hi]\n#align nodal_eq_mul_nodal_erase nodal_eq_mul_nodal_erase\n\n",
 "nodal_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem nodal_eq (s : Finset ι) (v : ι → F) :\n    nodal s v =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n        (X - C (v i)) :=\n  rfl\n#align nodal_eq nodal_eq\n\n",
 "nodal_empty":
 "@[simp]\ntheorem nodal_empty : nodal ∅ v = 1 :=\n  rfl\n#align nodal_empty nodal_empty\n\n",
 "nat_degree_basis_divisor_self":
 "theorem nat_degree_basis_divisor_self : (basis_divisor x x).nat_degree = 0 := by\n  rw [basis_divisor_self, nat_degree_zero]\n#align nat_degree_basis_divisor_self nat_degree_basis_divisor_self\n\n",
 "nat_degree_basis_divisor_of_ne":
 "theorem nat_degree_basis_divisor_of_ne (hxy : x ≠ y) : (basis_divisor x y).nat_degree = 1 :=\n  nat_degree_eq_of_degree_eq_some (degree_basis_divisor_of_ne hxy)\n#align nat_degree_basis_divisor_of_ne nat_degree_basis_divisor_of_ne\n\n",
 "nat_degree_basis":
 "@[simp]\ntheorem nat_degree_basis (hvs : Set.InjOn v s) (hi : i ∈ s) : (lagrange.basis s v i).nat_degree = s.card - 1 :=\n  by\n  have H : ∀ j, j ∈ s.erase i → basis_divisor (v i) (v j) ≠ 0 :=\n    by\n    simp_rw [ne.def, mem_erase, basis_divisor_eq_zero_iff]\n    exact fun j ⟨hij₁, hj⟩ hij₂ => hij₁ (hvs hj hi hij₂.symm)\n  rw [← card_erase_of_mem hi, card_eq_sum_ones]\n  convert nat_degree_prod _ _ H using 1\n  refine' sum_congr rfl fun j hj => (nat_degree_basis_divisor_of_ne _).symm\n  rw [ne.def, ← basis_divisor_eq_zero_iff]\n  exact H _ hj\n#align nat_degree_basis nat_degree_basis\n\n",
 "interpolate_singleton":
 "@[simp]\ntheorem interpolate_singleton : interpolate {i} v r = C (r i) := by\n  rw [interpolate_apply, sum_singleton, basis_singleton, mul_one]\n#align interpolate_singleton interpolate_singleton\n\n",
 "interpolate_one":
 "theorem interpolate_one (hvs : Set.InjOn v s) (hs : s.nonempty) : interpolate s v 1 = 1 :=\n  by\n  simp_rw [interpolate_apply, pi.one_apply, map_one, one_mul]\n  exact sum_basis hvs hs\n#align interpolate_one interpolate_one\n\n",
 "interpolate_eq_sum_interpolate_insert_sdiff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem interpolate_eq_sum_interpolate_insert_sdiff (hvt : Set.InjOn v t) (hs : s.nonempty) (hst : s ⊆ t) :\n    interpolate t v r =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (interpolate (insert i (t \\ s)) v r * lagrange.basis s v i) :=\n  by\n  symm\n  refine' eq_interpolate_of_eval_eq _ hvt (lt_of_le_of_lt (degree_sum_le _ _) _) fun i hi => _\n  · simp_rw [finset.sup_lt_iff (WithBot.bot_lt_coe t.card), degree_mul]\n    intro i hi\n    have hs : 1 ≤ s.card := nonempty.card_pos ⟨_, hi⟩\n    have hst' : s.card ≤ t.card := card_le_of_subset hst\n    have H : t.card = 1 + (t.card - s.card) + (s.card - 1) := by\n      rw [add_assoc, tsub_add_tsub_cancel hst' hs, ← add_tsub_assoc_of_le (hs.trans hst'), Nat.succ_add_sub_one,\n        zero_add]\n    rw [degree_basis (Set.InjOn.mono hst hvt) hi, H, WithBot.coe_add,\n      WithBot.add_lt_add_iff_right (@WithBot.coe_ne_bot _ (s.card - 1))]\n    convert degree_interpolate_lt _ (hvt.mono (coe_subset.mpr (insert_subset.mpr ⟨hst hi, sdiff_subset _ _⟩)))\n    rw [card_insert_of_not_mem (not_mem_sdiff_of_mem_right hi), card_sdiff hst, add_comm]\n  · simp_rw [eval_finset_sum, eval_mul]\n    by_cases hi' : i ∈ s\n    · rw [← add_sum_erase _ _ hi', eval_basis_self (hvt.mono hst) hi',\n        eval_interpolate_at_node _ (hvt.mono (coe_subset.mpr (insert_subset.mpr ⟨hi, sdiff_subset _ _⟩)))\n          (mem_insert_self _ _),\n        mul_one, add_right_eq_self]\n      refine' sum_eq_zero fun j hj => _\n      rcases mem_erase.mp hj with ⟨hij, hj⟩\n      rw [eval_basis_of_ne hij hi', mul_zero]\n    · have H :\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n            (eval (v i) (lagrange.basis s v j)) =\n          1 :=\n        by rw [← eval_finset_sum, sum_basis (hvt.mono hst) hs, eval_one]\n      rw [← mul_one (r i), ← H, mul_sum]\n      refine' sum_congr rfl fun j hj => _\n      congr\n      exact\n        eval_interpolate_at_node _ (hvt.mono (insert_subset.mpr ⟨hst hj, sdiff_subset _ _⟩))\n          (mem_insert.mpr (or.inr (mem_sdiff.mpr ⟨hi, hi'⟩)))\n#align interpolate_eq_sum_interpolate_insert_sdiff interpolate_eq_sum_interpolate_insert_sdiff\n\n",
 "interpolate_eq_of_values_eq_on":
 "theorem interpolate_eq_of_values_eq_on (hrr' : ∀ i ∈ s, r i = r' i) : interpolate s v r = interpolate s v r' :=\n  sum_congr rfl fun i hi => by rw [hrr' _ hi]\n#align interpolate_eq_of_values_eq_on interpolate_eq_of_values_eq_on\n\n",
 "interpolate_eq_nodal_weight_mul_nodal_div_X_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem interpolate_eq_nodal_weight_mul_nodal_div_X_sub_C :\n    interpolate s v r =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (C (nodal_weight s v i) * (nodal s v / (X - C (v i))) * C (r i)) :=\n  sum_congr rfl fun j hj => by rw [mul_comm, basis_eq_prod_sub_inv_mul_nodal_div hj]\n#align interpolate_eq_nodal_weight_mul_nodal_div_X_sub_C interpolate_eq_nodal_weight_mul_nodal_div_X_sub_C\n\n",
 "interpolate_eq_iff_values_eq_on":
 "theorem interpolate_eq_iff_values_eq_on (hvs : Set.InjOn v s) :\n    interpolate s v r = interpolate s v r' ↔ ∀ i ∈ s, r i = r' i :=\n  ⟨values_eq_on_of_interpolate_eq _ _ hvs, interpolate_eq_of_values_eq_on _ _⟩\n#align interpolate_eq_iff_values_eq_on interpolate_eq_iff_values_eq_on\n\n",
 "interpolate_eq_add_interpolate_erase":
 "theorem interpolate_eq_add_interpolate_erase (hvs : Set.InjOn v s) (hi : i ∈ s) (hj : j ∈ s) (hij : i ≠ j) :\n    interpolate s v r =\n      interpolate (s.erase j) v r * basis_divisor (v i) (v j) +\n        interpolate (s.erase i) v r * basis_divisor (v j) (v i) :=\n  by\n  rw [interpolate_eq_sum_interpolate_insert_sdiff _ hvs ⟨i, mem_insert_self i {j}⟩ _,\n    sum_insert (not_mem_singleton.mpr hij), sum_singleton, basis_pair_left hij, basis_pair_right hij,\n    sdiff_insert_insert_of_mem_of_not_mem hi (not_mem_singleton.mpr hij), sdiff_singleton_eq_erase, pair_comm,\n    sdiff_insert_insert_of_mem_of_not_mem hj (not_mem_singleton.mpr hij.symm), sdiff_singleton_eq_erase]\n  · exact insert_subset.mpr ⟨hi, singleton_subset_iff.mpr hj⟩\n#align interpolate_eq_add_interpolate_erase interpolate_eq_add_interpolate_erase\n\n",
 "interpolate_empty":
 "@[simp]\ntheorem interpolate_empty : interpolate ∅ v r = 0 := by rw [interpolate_apply, sum_empty]\n#align interpolate_empty interpolate_empty\n\n",
 "eval_nodal_not_at_node":
 "theorem eval_nodal_not_at_node (hx : ∀ i ∈ s, x ≠ v i) : eval x (nodal s v) ≠ 0 :=\n  by\n  simp_rw [nodal, eval_prod, prod_ne_zero_iff, eval_sub, eval_X, eval_C, sub_ne_zero]\n  exact hx\n#align eval_nodal_not_at_node eval_nodal_not_at_node\n\n",
 "eval_nodal_derivative_eval_node_eq":
 "theorem eval_nodal_derivative_eval_node_eq (hi : i ∈ s) :\n    eval (v i) (nodal s v).derivative = eval (v i) (nodal (s.erase i) v) :=\n  by\n  rw [derivative_nodal, eval_finset_sum, ← add_sum_erase _ _ hi, add_right_eq_self]\n  refine' sum_eq_zero fun j hj => _\n  simp_rw [nodal, eval_prod, eval_sub, eval_X, eval_C, prod_eq_zero_iff, mem_erase]\n  exact ⟨i, ⟨(mem_erase.mp hj).1.symm, hi⟩, sub_eq_zero_of_eq rfl⟩\n#align eval_nodal_derivative_eval_node_eq eval_nodal_derivative_eval_node_eq\n\n",
 "eval_nodal_at_node":
 "theorem eval_nodal_at_node (hi : i ∈ s) : eval (v i) (nodal s v) = 0 :=\n  by\n  rw [eval_nodal, prod_eq_zero_iff]\n  exact ⟨i, hi, sub_eq_zero_of_eq rfl⟩\n#align eval_nodal_at_node eval_nodal_at_node\n\n",
 "eval_nodal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem eval_nodal {x : F} :\n    (nodal s v).eval x =\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (x - v i) :=\n  by simp_rw [nodal, eval_prod, eval_sub, eval_X, eval_C]\n#align eval_nodal eval_nodal\n\n",
 "eval_interpolate_not_at_node'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- This is the second barycentric form of the Lagrange interpolant. -/\ntheorem eval_interpolate_not_at_node' (hvs : Set.InjOn v s) (hs : s.nonempty) (hx : ∀ i ∈ s, x ≠ v i) :\n    eval x (interpolate s v r) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (nodal_weight s v i * (x - v i)⁻¹ * r i) /\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (nodal_weight s v i * (x - v i)⁻¹) :=\n  by\n  rw [← div_one (eval x (interpolate s v r)), ← @eval_one _ _ x, ← interpolate_one hvs hs,\n    eval_interpolate_not_at_node r hx, eval_interpolate_not_at_node 1 hx]\n  simp only [mul_div_mul_left _ _ (eval_nodal_not_at_node hx), pi.one_apply, mul_one]\n#align eval_interpolate_not_at_node' eval_interpolate_not_at_node'\n\n",
 "eval_interpolate_not_at_node":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- This is the first barycentric form of the Lagrange interpolant. -/\ntheorem eval_interpolate_not_at_node (hx : ∀ i ∈ s, x ≠ v i) :\n    eval x (interpolate s v r) =\n      eval x (nodal s v) *\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n          (nodal_weight s v i * (x - v i)⁻¹ * r i) :=\n  by\n  simp_rw [interpolate_apply, mul_sum, eval_finset_sum, eval_mul, eval_C]\n  refine' sum_congr rfl fun i hi => _\n  rw [← mul_assoc, mul_comm, eval_basis_not_at_node hi (hx _ hi)]\n#align eval_interpolate_not_at_node eval_interpolate_not_at_node\n\n",
 "eval_interpolate_at_node":
 "theorem eval_interpolate_at_node (hvs : Set.InjOn v s) (hi : i ∈ s) : eval (v i) (interpolate s v r) = r i :=\n  by\n  rw [interpolate_apply, eval_finset_sum, ← add_sum_erase _ _ hi]\n  simp_rw [eval_mul, eval_C, eval_basis_self hvs hi, mul_one, add_right_eq_self]\n  refine' sum_eq_zero fun j H => _\n  rw [eval_basis_of_ne (mem_erase.mp H).1 hi, mul_zero]\n#align eval_interpolate_at_node eval_interpolate_at_node\n\n",
 "eval_basis_self":
 "@[simp]\ntheorem eval_basis_self (hvs : Set.InjOn v s) (hi : i ∈ s) : (lagrange.basis s v i).eval (v i) = 1 :=\n  by\n  rw [lagrange.basis, eval_prod]\n  refine' prod_eq_one fun j H => _\n  rw [eval_basis_divisor_left_of_ne]\n  rcases mem_erase.mp H with ⟨hij, hj⟩\n  exact mt (hvs hi hj) hij.symm\n#align eval_basis_self eval_basis_self\n\n",
 "eval_basis_of_ne":
 "@[simp]\ntheorem eval_basis_of_ne (hij : i ≠ j) (hj : j ∈ s) : (lagrange.basis s v i).eval (v j) = 0 :=\n  by\n  simp_rw [lagrange.basis, eval_prod, prod_eq_zero_iff]\n  exact ⟨j, ⟨mem_erase.mpr ⟨hij.symm, hj⟩, eval_basis_divisor_right⟩⟩\n#align eval_basis_of_ne eval_basis_of_ne\n\n",
 "eval_basis_not_at_node":
 "theorem eval_basis_not_at_node (hi : i ∈ s) (hxi : x ≠ v i) :\n    eval x (lagrange.basis s v i) = eval x (nodal s v) * (nodal_weight s v i * (x - v i)⁻¹) := by\n  rw [mul_comm, basis_eq_prod_sub_inv_mul_nodal_div hi, eval_mul, eval_C, ← nodal_erase_eq_nodal_div hi, eval_nodal,\n    eval_nodal, mul_assoc, ← mul_prod_erase _ _ hi, ← mul_assoc (x - v i)⁻¹, inv_mul_cancel (sub_ne_zero_of_ne hxi),\n    one_mul]\n#align eval_basis_not_at_node eval_basis_not_at_node\n\n",
 "eval_basis_divisor_right":
 "@[simp]\ntheorem eval_basis_divisor_right : eval y (basis_divisor x y) = 0 := by\n  simp only [basis_divisor, eval_mul, eval_C, eval_sub, eval_X, sub_self, mul_zero]\n#align eval_basis_divisor_right eval_basis_divisor_right\n\n",
 "eval_basis_divisor_left_of_ne":
 "theorem eval_basis_divisor_left_of_ne (hxy : x ≠ y) : eval x (basis_divisor x y) = 1 :=\n  by\n  simp only [basis_divisor, eval_mul, eval_C, eval_sub, eval_X]\n  exact inv_mul_cancel (sub_ne_zero_of_ne hxy)\n#align eval_basis_divisor_left_of_ne eval_basis_divisor_left_of_ne\n\n",
 "eq_zero_of_degree_lt_of_eval_index_eq_zero":
 "theorem eq_zero_of_degree_lt_of_eval_index_eq_zero (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card)\n    (eval_f : ∀ i ∈ s, f.eval (v i) = 0) : f = 0 := by\n  classical\n    rw [← card_image_of_inj_on hvs] at degree_f_lt\n    refine' eq_zero_of_degree_lt_of_eval_finset_eq_zero _ degree_f_lt _\n    intro x hx\n    rcases mem_image.mp hx with ⟨_, hj, rfl⟩\n    exact eval_f _ hj\n#align eq_zero_of_degree_lt_of_eval_index_eq_zero eq_zero_of_degree_lt_of_eval_index_eq_zero\n\n",
 "eq_zero_of_degree_lt_of_eval_finset_eq_zero":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Wrenna Robson\n-/\ntheorem eq_zero_of_degree_lt_of_eval_finset_eq_zero (degree_f_lt : f.degree < s.card) (eval_f : ∀ x ∈ s, f.eval x = 0) :\n    f = 0 := by\n  rw [← mem_degree_lt] at degree_f_lt\n  simp_rw [eval_eq_sum_degree_lt_equiv degree_f_lt] at eval_f\n  rw [← degree_lt_equiv_eq_zero_iff_eq_zero degree_f_lt]\n  exact\n    matrix.eq_zero_of_forall_index_sum_mul_pow_eq_zero\n      (injective.comp (embedding.subtype _).inj' (equiv_fin_of_card_eq (card_coe _)).symm.injective) fun _ =>\n      eval_f _ (Finset.coe_mem _)\n#align eq_zero_of_degree_lt_of_eval_finset_eq_zero eq_zero_of_degree_lt_of_eval_finset_eq_zero\n\n",
 "eq_of_degrees_lt_of_eval_index_eq":
 "theorem eq_of_degrees_lt_of_eval_index_eq (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card)\n    (degree_g_lt : g.degree < s.card) (eval_fg : ∀ i ∈ s, f.eval (v i) = g.eval (v i)) : f = g :=\n  by\n  refine' eq_of_degree_sub_lt_of_eval_index_eq _ hvs _ eval_fg\n  rw [← mem_degree_lt] at degree_f_lt degree_g_lt⊢\n  exact submodule.sub_mem _ degree_f_lt degree_g_lt\n#align eq_of_degrees_lt_of_eval_index_eq eq_of_degrees_lt_of_eval_index_eq\n\n",
 "eq_of_degrees_lt_of_eval_finset_eq":
 "theorem eq_of_degrees_lt_of_eval_finset_eq (degree_f_lt : f.degree < s.card) (degree_g_lt : g.degree < s.card)\n    (eval_fg : ∀ x ∈ s, f.eval x = g.eval x) : f = g :=\n  by\n  rw [← mem_degree_lt] at degree_f_lt degree_g_lt\n  refine' eq_of_degree_sub_lt_of_eval_finset_eq _ _ eval_fg\n  rw [← mem_degree_lt]; exact submodule.sub_mem _ degree_f_lt degree_g_lt\n#align eq_of_degrees_lt_of_eval_finset_eq eq_of_degrees_lt_of_eval_finset_eq\n\n",
 "eq_of_degree_sub_lt_of_eval_index_eq":
 "theorem eq_of_degree_sub_lt_of_eval_index_eq (hvs : Set.InjOn v s) (degree_fg_lt : (f - g).degree < s.card)\n    (eval_fg : ∀ i ∈ s, f.eval (v i) = g.eval (v i)) : f = g :=\n  by\n  rw [← sub_eq_zero]\n  refine' eq_zero_of_degree_lt_of_eval_index_eq_zero _ hvs degree_fg_lt _\n  simp_rw [eval_sub, sub_eq_zero]\n  exact eval_fg\n#align eq_of_degree_sub_lt_of_eval_index_eq eq_of_degree_sub_lt_of_eval_index_eq\n\n",
 "eq_of_degree_sub_lt_of_eval_finset_eq":
 "theorem eq_of_degree_sub_lt_of_eval_finset_eq (degree_fg_lt : (f - g).degree < s.card)\n    (eval_fg : ∀ x ∈ s, f.eval x = g.eval x) : f = g :=\n  by\n  rw [← sub_eq_zero]\n  refine' eq_zero_of_degree_lt_of_eval_finset_eq_zero _ degree_fg_lt _\n  simp_rw [eval_sub, sub_eq_zero]\n  exact eval_fg\n#align eq_of_degree_sub_lt_of_eval_finset_eq eq_of_degree_sub_lt_of_eval_finset_eq\n\n",
 "eq_interpolate_of_eval_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_interpolate_of_eval_eq {f : polynomial F} (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card)\n    (eval_f : ∀ i ∈ s, f.eval (v i) = r i) : f = interpolate s v r :=\n  by\n  rw [eq_interpolate hvs degree_f_lt]\n  exact interpolate_eq_of_values_eq_on _ _ eval_f\n#align eq_interpolate_of_eval_eq eq_interpolate_of_eval_eq\n\n",
 "eq_interpolate_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- This is the characteristic property of the interpolation: the interpolation is the\nunique polynomial of `degree < fintype.card ι` which takes the value of the `r i` on the `v i`.\n-/\ntheorem eq_interpolate_iff {f : polynomial F} (hvs : Set.InjOn v s) :\n    (f.degree < s.card ∧ ∀ i ∈ s, eval (v i) f = r i) ↔ f = interpolate s v r :=\n  by\n  constructor <;> intro h\n  · exact eq_interpolate_of_eval_eq _ hvs h.1 h.2\n  · rw [h]\n    exact ⟨degree_interpolate_lt _ hvs, fun _ hi => eval_interpolate_at_node _ hvs hi⟩\n#align eq_interpolate_iff eq_interpolate_iff\n\n",
 "eq_interpolate":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_interpolate {f : polynomial F} (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card) :\n    f = interpolate s v fun i => f.eval (v i) :=\n  eq_of_degrees_lt_of_eval_index_eq _ hvs degree_f_lt (degree_interpolate_lt _ hvs) fun i hi =>\n    (eval_interpolate_at_node _ hvs hi).symm\n#align eq_interpolate eq_interpolate\n\n",
 "derivative_nodal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem derivative_nodal :\n    (nodal s v).derivative =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        (nodal (s.erase i) v) :=\n  by\n  refine' Finset.induction_on s _ fun _ _ hit IH => _\n  · rw [nodal_empty, derivative_one, sum_empty]\n  · rw [nodal_insert_eq_nodal hit, derivative_mul, IH, derivative_sub, derivative_X, derivative_C, sub_zero, one_mul,\n      sum_insert hit, mul_sum, erase_insert hit, add_right_inj]\n    refine' sum_congr rfl fun j hjt => _\n    rw [nodal_erase_eq_nodal_div (mem_insert_of_mem hjt), nodal_insert_eq_nodal hit,\n      EuclideanDomain.mul_div_assoc _ (X_sub_C_dvd_nodal v hjt), nodal_erase_eq_nodal_div hjt]\n#align derivative_nodal derivative_nodal\n\n",
 "degree_nodal":
 "theorem degree_nodal : (nodal s v).degree = s.card := by\n  simp_rw [nodal, degree_prod, degree_X_sub_C, sum_const, Nat.smul_one_eq_coe]\n#align degree_nodal degree_nodal\n\n",
 "degree_interpolate_lt":
 "theorem degree_interpolate_lt (hvs : Set.InjOn v s) : (interpolate s v r).degree < s.card :=\n  by\n  rcases eq_empty_or_nonempty s with (rfl | h)\n  · rw [interpolate_empty, degree_zero, card_empty]\n    exact WithBot.bot_lt_coe _\n  · refine' lt_of_le_of_lt (degree_interpolate_le _ hvs) _\n    rw [WithBot.coe_lt_coe]\n    exact nat.sub_lt (nonempty.card_pos h) zero_lt_one\n#align degree_interpolate_lt degree_interpolate_lt\n\n",
 "degree_interpolate_le":
 "theorem degree_interpolate_le (hvs : Set.InjOn v s) : (interpolate s v r).degree ≤ ↑(s.card - 1) :=\n  by\n  refine' (degree_sum_le _ _).trans _\n  rw [finset.sup_le_iff]\n  intro i hi\n  rw [degree_mul, degree_basis hvs hi]\n  by_cases hr : r i = 0\n  · simpa only [hr, map_zero, degree_zero, WithBot.bot_add] using bot_le\n  · rw [degree_C hr, zero_add, WithBot.coe_le_coe]\n#align degree_interpolate_le degree_interpolate_le\n\n",
 "degree_interpolate_erase_lt":
 "theorem degree_interpolate_erase_lt (hvs : Set.InjOn v s) (hi : i ∈ s) :\n    (interpolate (s.erase i) v r).degree < ↑(s.card - 1) :=\n  by\n  rw [← finset.card_erase_of_mem hi]\n  exact degree_interpolate_lt _ (Set.InjOn.mono (coe_subset.mpr (erase_subset _ _)) hvs)\n#align degree_interpolate_erase_lt degree_interpolate_erase_lt\n\n",
 "degree_basis_divisor_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem degree_basis_divisor_self : (basis_divisor x x).degree = «expr⊥» := by rw [basis_divisor_self, degree_zero]\n#align degree_basis_divisor_self degree_basis_divisor_self\n\n",
 "degree_basis_divisor_of_ne":
 "theorem degree_basis_divisor_of_ne (hxy : x ≠ y) : (basis_divisor x y).degree = 1 :=\n  by\n  rw [basis_divisor, degree_mul, degree_X_sub_C, degree_C, zero_add]\n  exact inv_ne_zero (sub_ne_zero_of_ne hxy)\n#align degree_basis_divisor_of_ne degree_basis_divisor_of_ne\n\n",
 "degree_basis":
 "theorem degree_basis (hvs : Set.InjOn v s) (hi : i ∈ s) : (lagrange.basis s v i).degree = ↑(s.card - 1) := by\n  rw [degree_eq_nat_degree (basis_ne_zero hvs hi), nat_degree_basis hvs hi]\n#align degree_basis degree_basis\n\n",
 "basis_singleton":
 "@[simp]\ntheorem basis_singleton (i : ι) : lagrange.basis {i} v i = 1 := by rw [lagrange.basis, erase_singleton, prod_empty]\n#align basis_singleton basis_singleton\n\n",
 "basis_pair_right":
 "@[simp]\ntheorem basis_pair_right (hij : i ≠ j) : lagrange.basis {i, j} v j = basis_divisor (v j) (v i) :=\n  by\n  rw [pair_comm]\n  exact basis_pair_left hij.symm\n#align basis_pair_right basis_pair_right\n\n",
 "basis_pair_left":
 "@[simp]\ntheorem basis_pair_left (hij : i ≠ j) : lagrange.basis {i, j} v i = basis_divisor (v i) (v j) := by\n  simp only [lagrange.basis, hij, erase_insert_eq_erase, erase_eq_of_not_mem, mem_singleton, not_false_iff,\n    prod_singleton]\n#align basis_pair_left basis_pair_left\n\n",
 "basis_ne_zero":
 "theorem basis_ne_zero (hvs : Set.InjOn v s) (hi : i ∈ s) : lagrange.basis s v i ≠ 0 :=\n  by\n  simp_rw [lagrange.basis, prod_ne_zero_iff, ne.def, mem_erase]\n  rintro j ⟨hij, hj⟩\n  rw [basis_divisor_eq_zero_iff, hvs.eq_iff hi hj]\n  exact hij.symm\n#align basis_ne_zero basis_ne_zero\n\n",
 "basis_eq_prod_sub_inv_mul_nodal_div":
 "theorem basis_eq_prod_sub_inv_mul_nodal_div (hi : i ∈ s) :\n    lagrange.basis s v i = C (nodal_weight s v i) * (nodal s v / (X - C (v i))) := by\n  simp_rw [lagrange.basis, basis_divisor, nodal_weight, prod_mul_distrib, map_prod, ← nodal_erase_eq_nodal_div hi,\n    nodal]\n#align basis_eq_prod_sub_inv_mul_nodal_div basis_eq_prod_sub_inv_mul_nodal_div\n\n",
 "basis_empty":
 "@[simp]\ntheorem basis_empty : lagrange.basis ∅ v i = 1 :=\n  rfl\n#align basis_empty basis_empty\n\n",
 "basis_divisor_self":
 "theorem basis_divisor_self : basis_divisor x x = 0 := by\n  simp only [basis_divisor, sub_self, inv_zero, map_zero, zero_mul]\n#align basis_divisor_self basis_divisor_self\n\n",
 "basis_divisor_ne_zero_iff":
 "theorem basis_divisor_ne_zero_iff : basis_divisor x y ≠ 0 ↔ x ≠ y := by rw [ne.def, basis_divisor_eq_zero_iff]\n#align basis_divisor_ne_zero_iff basis_divisor_ne_zero_iff\n\n",
 "basis_divisor_inj":
 "theorem basis_divisor_inj (hxy : basis_divisor x y = 0) : x = y :=\n  by\n  simp_rw [basis_divisor, mul_eq_zero, X_sub_C_ne_zero, or_false_iff, C_eq_zero, inv_eq_zero, sub_eq_zero] at hxy\n  exact hxy\n#align basis_divisor_inj basis_divisor_inj\n\n",
 "basis_divisor_eq_zero_iff":
 "@[simp]\ntheorem basis_divisor_eq_zero_iff : basis_divisor x y = 0 ↔ x = y :=\n  ⟨basis_divisor_inj, fun H => H ▸ basis_divisor_self⟩\n#align basis_divisor_eq_zero_iff basis_divisor_eq_zero_iff\n\n",
 "basis_divisor_add_symm":
 "theorem basis_divisor_add_symm {x y : F} (hxy : x ≠ y) : basis_divisor x y + basis_divisor y x = 1 := by\n  classical rw [← sum_basis (Set.injOn_of_injective function.injective_id _) ⟨x, mem_insert_self _ {y}⟩,\n      sum_insert (not_mem_singleton.mpr hxy), sum_singleton, basis_pair_left hxy, basis_pair_right hxy, id, id]\n#align basis_divisor_add_symm basis_divisor_add_symm\n\n",
 "X_sub_C_dvd_nodal":
 "theorem X_sub_C_dvd_nodal (v : ι → F) (hi : i ∈ s) : X - C (v i) ∣ nodal s v :=\n  ⟨_, by classical exact nodal_eq_mul_nodal_erase hi⟩\n#align X_sub_C_dvd_nodal X_sub_C_dvd_nodal\n\n"}