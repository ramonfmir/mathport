{"subset_extend":
 "#print Basis.subset_extend /-\ntheorem Basis.subset_extend {s : Set V} (hs : LinearIndependent K (coe : s → V)) : s ⊆ hs.extend (Set.subset_univ _) :=\n  hs.subset_extend _\n#align basis.subset_extend Basis.subset_extend\n-/\n\n",
 "subalgebra_top_rank_eq_submodule_top_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print subalgebra_top_rank_eq_submodule_top_rank /-\ntheorem subalgebra_top_rank_eq_submodule_top_rank :\n    Module.rank F («expr⊤» : Subalgebra F E) = Module.rank F («expr⊤» : Submodule F E) :=\n  by\n  rw [← Algebra.top_toSubmodule]\n  rfl\n#align subalgebra_top_rank_eq_submodule_top_rank subalgebra_top_rank_eq_submodule_top_rank\n-/\n\n",
 "subalgebra_top_finrank_eq_submodule_top_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print subalgebra_top_finrank_eq_submodule_top_finrank /-\ntheorem subalgebra_top_finrank_eq_submodule_top_finrank :\n    finrank F («expr⊤» : Subalgebra F E) = finrank F («expr⊤» : Submodule F E) :=\n  by\n  rw [← Algebra.top_toSubmodule]\n  rfl\n#align subalgebra_top_finrank_eq_submodule_top_finrank subalgebra_top_finrank_eq_submodule_top_finrank\n-/\n\n",
 "span_lt_top_of_card_lt_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print span_lt_top_of_card_lt_finrank /-\ntheorem span_lt_top_of_card_lt_finrank {s : Set V} [Fintype s] (card_lt : s.to_finset.card < finrank K V) :\n    span K s < «expr⊤» :=\n  lt_top_of_finrank_lt_finrank (lt_of_le_of_lt (finrank_span_le_card _) card_lt)\n#align span_lt_top_of_card_lt_finrank span_lt_top_of_card_lt_finrank\n-/\n\n",
 "span_lt_of_subset_of_card_lt_finrank":
 "#print span_lt_of_subset_of_card_lt_finrank /-\ntheorem span_lt_of_subset_of_card_lt_finrank {s : Set V} [Fintype s] {t : Submodule K V} (subset : s ⊆ t)\n    (card_lt : s.to_finset.card < finrank K t) : span K s < t :=\n  lt_of_le_of_finrank_lt_finrank (span_le.mpr subset) (lt_of_le_of_lt (finrank_span_le_card _) card_lt)\n#align span_lt_of_subset_of_card_lt_finrank span_lt_of_subset_of_card_lt_finrank\n-/\n\n",
 "rank_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print Subalgebra.rank_top /-\ntheorem Subalgebra.rank_top : Module.rank F («expr⊤» : Subalgebra F E) = Module.rank F E :=\n  by\n  rw [subalgebra_top_rank_eq_submodule_top_rank]\n  exact rank_top F E\n#align subalgebra.rank_top Subalgebra.rank_top\n-/\n\n",
 "rank_toSubmodule":
 "#print Subalgebra.rank_toSubmodule /-\n@[simp]\ntheorem Subalgebra.rank_toSubmodule (S : Subalgebra F E) : Module.rank F S.to_submodule = Module.rank F S :=\n  rfl\n#align subalgebra.rank_to_submodule Subalgebra.rank_toSubmodule\n-/\n\n",
 "rank_lt_of_finrank_lt":
 "theorem rank_lt_of_finrank_lt {n : ℕ} (h : n < finrank K V) : ↑n < Module.rank K V :=\n  by\n  rwa [← Cardinal.toNat_lt_iff_lt_of_lt_aleph0, to_nat_cast]\n  · exact nat_lt_aleph_0 n\n  · contrapose! h\n    rw [finrank, Cardinal.toNat_apply_of_aleph0_le h]\n    exact n.zero_le\n#align rank_lt_of_finrank_lt rank_lt_of_finrank_lt\n\n",
 "rank_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.rank_bot /-\n@[simp]\ntheorem Subalgebra.rank_bot : Module.rank F («expr⊥» : Subalgebra F E) = 1 :=\n  ((Subalgebra.toSubmoduleEquiv («expr⊥» : Subalgebra F E)).symm.trans <|\n          LinearEquiv.ofEq _ _ Algebra.toSubmodule_bot).rank_eq.trans <|\n    by\n    letI := Module.nontrivial F E\n    rw [rank_span_set]\n    exacts[mk_singleton _, linearIndependent_singleton one_ne_zero]\n#align subalgebra.rank_bot Subalgebra.rank_bot\n-/\n\n",
 "nontrivial_of_finrank_pos":
 "/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem nontrivial_of_finrank_pos (h : 0 < finrank K V) : Nontrivial V :=\n  rank_pos_iff_nontrivial.mp (rank_lt_of_finrank_lt h)\n#align nontrivial_of_finrank_pos nontrivial_of_finrank_pos\n\n",
 "nontrivial_of_finrank_eq_succ":
 "/-- A finite dimensional space is nontrivial if it has `finrank` equal to the successor of a\nnatural number. -/\ntheorem nontrivial_of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) : Nontrivial V :=\n  nontrivial_of_finrank_pos (by rw [hn] <;> exact n.succ_pos)\n#align nontrivial_of_finrank_eq_succ nontrivial_of_finrank_eq_succ\n\n",
 "lt_top_of_finrank_lt_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lt_top_of_finrank_lt_finrank {s : Submodule K V} (lt : finrank K s < finrank K V) : s < «expr⊤» :=\n  by\n  rw [← finrank_top K V] at lt\n  exact lt_of_le_of_finrank_lt_finrank le_top lt\n#align lt_top_of_finrank_lt_finrank lt_top_of_finrank_lt_finrank\n\n",
 "lt_of_le_of_finrank_lt_finrank":
 "theorem lt_of_le_of_finrank_lt_finrank {s t : Submodule K V} (le : s ≤ t) (lt : finrank K s < finrank K t) : s < t :=\n  lt_of_le_of_ne le fun h => ne_of_lt lt (by rw [h])\n#align lt_of_le_of_finrank_lt_finrank lt_of_le_of_finrank_lt_finrank\n\n",
 "linearIndependent_of_top_le_span_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print linearIndependent_of_top_le_span_of_card_eq_finrank /-\ntheorem linearIndependent_of_top_le_span_of_card_eq_finrank {ι : Type _} [Fintype ι] {b : ι → V}\n    (spans : «expr⊤» ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) : LinearIndependent K b :=\n  linearIndependent_iff'.mpr fun s g dependent i i_mem_s =>\n    by\n    by_contra gx_ne_zero\n    -- We'll derive a contradiction by showing `b '' (univ \\ {i})` of cardinality `n - 1`\n    -- spans a vector space of dimension `n`.\n    refine'\n      not_le_of_gt\n        (span_lt_top_of_card_lt_finrank (show («expr '' » b (Set.univ \\ {i})).to_finset.card < finrank K V from _)) _\n    ·\n      calc\n        («expr '' » b (Set.univ \\ {i})).to_finset.card = ((Set.univ \\ {i}).to_finset.image b).card := by\n          rw [Set.toFinset_card, Fintype.card_ofFinset]\n        _ ≤ (Set.univ \\ {i}).to_finset.card := Finset.card_image_le\n        _ = (finset.univ.erase i).card := (congr_arg Finset.card (Finset.ext (by simp [and_comm'])))\n        _ < finset.univ.card := (Finset.card_erase_lt_of_mem (Finset.mem_univ i))\n        _ = finrank K V := card_eq\n        \n    -- We already have that `b '' univ` spans the whole space,\n    -- so we only need to show that the span of `b '' (univ \\ {i})` contains each `b j`.\n    refine' spans.trans (span_le.mpr _)\n    rintro _ ⟨j, rfl, rfl⟩\n    -- The case that `j ≠ i` is easy because `b j ∈ b '' (univ \\ {i})`.\n    by_cases j_eq : j = i\n    swap\n    · refine' subset_span ⟨j, (Set.mem_diff _).mpr ⟨Set.mem_univ _, _⟩, rfl⟩\n      exact mt set.mem_singleton_iff.mp j_eq\n    -- To show `b i ∈ span (b '' (univ \\ {i}))`, we use that it's a weighted sum\n    -- of the other `b j`s.\n    rw [j_eq, SetLike.mem_coe, show b i = -«expr • » (g i)⁻¹ ((s.erase i).sum fun j => «expr • » (g j) (b j)) from _]\n    · refine' neg_mem (smul_mem _ _ (sum_mem fun k hk => _))\n      obtain ⟨k_ne_i, k_mem⟩ := finset.mem_erase.mp hk\n      refine' smul_mem _ _ (subset_span ⟨k, _, rfl⟩)\n      simpa using k_mem\n    -- To show `b i` is a weighted sum of the other `b j`s, we'll rewrite this sum\n    -- to have the form of the assumption `dependent`.\n    apply eq_neg_of_add_eq_zero_left\n    calc\n      b i + «expr • » (g i)⁻¹ ((s.erase i).sum fun j => «expr • » (g j) (b j)) =\n          «expr • » (g i)⁻¹ («expr • » (g i) (b i) + (s.erase i).sum fun j => «expr • » (g j) (b j)) :=\n        by rw [smul_add, ← mul_smul, inv_mul_cancel gx_ne_zero, one_smul]\n      _ = «expr • » (g i)⁻¹ 0 := (congr_arg _ _)\n      _ = 0 := smul_zero _\n      \n    -- And then it's just a bit of manipulation with finite sums.\n    rwa [← Finset.insert_erase i_mem_s, Finset.sum_insert (Finset.not_mem_erase _ _)] at dependent\n#align linear_independent_of_top_le_span_of_card_eq_finrank linearIndependent_of_top_le_span_of_card_eq_finrank\n-/\n\n",
 "linearIndependent_iff_card_le_finrank_span":
 "#print linearIndependent_iff_card_le_finrank_span /-\ntheorem linearIndependent_iff_card_le_finrank_span {ι : Type _} [Fintype ι] {b : ι → V} :\n    LinearIndependent K b ↔ Fintype.card ι ≤ (Set.range b).finrank K := by\n  rw [linearIndependent_iff_card_eq_finrank_span, finrank_range_le_card.le_iff_eq]\n#align linear_independent_iff_card_le_finrank_span linearIndependent_iff_card_le_finrank_span\n-/\n\n",
 "linearIndependent_iff_card_eq_finrank_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print linearIndependent_iff_card_eq_finrank_span /-\n/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem linearIndependent_iff_card_eq_finrank_span {ι : Type _} [Fintype ι] {b : ι → V} :\n    LinearIndependent K b ↔ Fintype.card ι = (Set.range b).finrank K :=\n  by\n  constructor\n  · intro h\n    exact (finrank_span_eq_card h).symm\n  · intro hc\n    let f := Submodule.subtype (span K (Set.range b))\n    let b' : ι → span K (Set.range b) := fun i => ⟨b i, mem_span.2 fun p hp => hp (Set.mem_range_self _)⟩\n    have hs : «expr⊤» ≤ span K (Set.range b') := by\n      intro x\n      have h : span K («expr '' » f (Set.range b')) = map f (span K (Set.range b')) := span_image f\n      have hf : «expr '' » f (Set.range b') = Set.range b :=\n        by\n        ext x\n        simp [Set.mem_image, Set.mem_range]\n      rw [hf] at h\n      have hx : (x : V) ∈ span K (Set.range b) := x.property\n      conv at hx =>\n        congr\n        skip\n        rw [h]\n      simpa [mem_map] using hx\n    have hi : f.ker = «expr⊥» := ker_subtype _\n    convert(linearIndependent_of_top_le_span_of_card_eq_finrank hs hc).map' _ hi\n#align linear_independent_iff_card_eq_finrank_span linearIndependent_iff_card_eq_finrank_span\n-/\n\n",
 "finrank_zero_of_subsingleton":
 "/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/\ntheorem finrank_zero_of_subsingleton [h : subsingleton V] : finrank K V = 0 :=\n  by\n  by_contra h0\n  obtain ⟨x, y, hxy⟩ := nontrivial_of_finrank_pos (nat.pos_of_ne_zero h0)\n  exact hxy (subsingleton.elim _ _)\n#align finrank_zero_of_subsingleton finrank_zero_of_subsingleton\n\n",
 "finrank_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n#print finrank_top /-\n@[simp]\ntheorem finrank_top : finrank K («expr⊤» : Submodule K V) = finrank K V :=\n  by\n  unfold finrank\n  simp [rank_top]\n#align finrank_top finrank_top\n-/\n\n",
 "finrank_toSubmodule":
 "#print Subalgebra.finrank_toSubmodule /-\n@[simp]\ntheorem Subalgebra.finrank_toSubmodule (S : Subalgebra F E) : finrank F S.to_submodule = finrank F S :=\n  rfl\n#align subalgebra.finrank_to_submodule Subalgebra.finrank_toSubmodule\n-/\n\n",
 "finrank_span_set_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print finrank_span_set_eq_card /-\ntheorem finrank_span_set_eq_card (s : Set V) [Fintype s] (hs : LinearIndependent K (coe : s → V)) :\n    finrank K (span K s) = s.to_finset.card :=\n  finrank_eq_of_rank_eq\n    (by\n      have : Module.rank K (span K s) = cardinal.mk s := rank_span_set hs\n      rwa [Cardinal.mk_fintype, ← Set.toFinset_card] at this)\n#align finrank_span_set_eq_card finrank_span_set_eq_card\n-/\n\n",
 "finrank_span_le_card":
 "#print finrank_span_le_card /-\ntheorem finrank_span_le_card (s : Set V) [Fintype s] : finrank K (span K s) ≤ s.to_finset.card :=\n  finrank_le_of_rank_le (by simpa using rank_span_le s)\n#align finrank_span_le_card finrank_span_le_card\n-/\n\n",
 "finrank_span_finset_le_card":
 "#print finrank_span_finset_le_card /-\ntheorem finrank_span_finset_le_card (s : Finset V) : (s : Set V).finrank K ≤ s.card :=\n  calc\n    (s : Set V).finrank K ≤ (s : Set V).to_finset.card := finrank_span_le_card s\n    _ = s.card := by simp\n    \n#align finrank_span_finset_le_card finrank_span_finset_le_card\n-/\n\n",
 "finrank_span_finset_eq_card":
 "#print finrank_span_finset_eq_card /-\ntheorem finrank_span_finset_eq_card (s : Finset V) (hs : LinearIndependent K (coe : s → V)) :\n    finrank K (span K (s : Set V)) = s.card :=\n  by\n  convert finrank_span_set_eq_card (↑s) hs\n  ext\n  simp\n#align finrank_span_finset_eq_card finrank_span_finset_eq_card\n-/\n\n",
 "finrank_span_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n#print finrank_span_eq_card /-\ntheorem finrank_span_eq_card {ι : Type _} [Fintype ι] {b : ι → V} (hb : LinearIndependent K b) :\n    finrank K (span K (Set.range b)) = Fintype.card ι :=\n  finrank_eq_of_rank_eq\n    (by\n      have : Module.rank K (span K (Set.range b)) = cardinal.mk (Set.range b) := rank_span hb\n      rwa [← lift_inj, mk_range_eq_of_injective hb.injective, Cardinal.mk_fintype, lift_nat_cast, lift_eq_nat_iff] at\n        this)\n#align finrank_span_eq_card finrank_span_eq_card\n-/\n\n",
 "finrank_self":
 "/-- A ring satisfying `strong_rank_condition` (such as a `division_ring`) is one-dimensional as a\nmodule over itself. -/\n@[simp]\ntheorem finrank_self : finrank K K = 1 :=\n  finrank_eq_of_rank_eq (by simp)\n#align finrank_self finrank_self\n\n",
 "finrank_range_of_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The dimensions of the domain and range of an injective linear map are equal. -/\ntheorem finrank_range_of_inj {f : «expr →ₗ[ ] » V K V₂} (hf : function.injective f) : finrank K f.range = finrank K V :=\n  by rw [(LinearEquiv.ofInjective f hf).finrank_eq]\n#align finrank_range_of_inj finrank_range_of_inj\n\n",
 "finrank_range_le_card":
 "#print finrank_range_le_card /-\ntheorem finrank_range_le_card {ι : Type _} [Fintype ι] {b : ι → V} : (Set.range b).finrank K ≤ Fintype.card ι :=\n  (finrank_span_le_card _).trans <| by\n    rw [Set.toFinset_range]\n    exact Finset.card_image_le\n#align finrank_range_le_card finrank_range_le_card\n-/\n\n",
 "finrank_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Pushforwards of finite-dimensional submodules along a `linear_equiv` have the same finrank. -/\ntheorem finrank_map_eq (f : «expr ≃ₗ[ ] » M R M₂) (p : Submodule R M) :\n    finrank R (p.map (f : «expr →ₗ[ ] » M R M₂)) = finrank R p :=\n  (f.submodule_map p).finrank_eq.symm\n#align finrank_map_eq finrank_map_eq\n\n",
 "finrank_lt_of_rank_lt":
 "theorem finrank_lt_of_rank_lt {n : ℕ} (h : Module.rank K V < ↑n) : finrank K V < n :=\n  by\n  rwa [← Cardinal.toNat_lt_iff_lt_of_lt_aleph0, to_nat_cast] at h\n  · exact h.trans (nat_lt_aleph_0 n)\n  · exact nat_lt_aleph_0 n\n#align finrank_lt_of_rank_lt finrank_lt_of_rank_lt\n\n",
 "finrank_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print finrank_le_one /-\n/-- If every vector is a multiple of some `v : V`, then `V` has dimension at most one.\n-/\ntheorem finrank_le_one (v : V) (h : ∀ w : V, ∃ c : K, «expr • » c v = w) : finrank K V ≤ 1 :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber K\n  rcases eq_or_ne v 0 with (rfl | hn)\n  · haveI :=\n      subsingleton_of_forall_eq (0 : V) fun w => by\n        obtain ⟨c, rfl⟩ := h w\n        simp\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  · exact (finrank_eq_one v hn h).le\n#align finrank_le_one finrank_le_one\n-/\n\n",
 "finrank_le_of_rank_le":
 "theorem finrank_le_of_rank_le {n : ℕ} (h : Module.rank K V ≤ ↑n) : finrank K V ≤ n :=\n  by\n  rwa [← Cardinal.toNat_le_iff_le_of_lt_aleph0, to_nat_cast] at h\n  · exact h.trans_lt (nat_lt_aleph_0 n)\n  · exact nat_lt_aleph_0 n\n#align finrank_le_of_rank_le finrank_le_of_rank_le\n\n",
 "finrank_le_finrank_of_rank_le_rank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.aleph_0 -/\ntheorem finrank_le_finrank_of_rank_le_rank (h : lift.{v'} (Module.rank K V) ≤ Cardinal.lift.{v} (Module.rank K V₂))\n    (h' : Module.rank K V₂ < cardinal.aleph_0) : finrank K V ≤ finrank K V₂ := by\n  simpa only [to_nat_lift] using to_nat_le_of_le_of_lt_aleph_0 (lift_lt_aleph_0.mpr h') h\n#align finrank_le_finrank_of_rank_le_rank finrank_le_finrank_of_rank_le_rank\n\n",
 "finrank_fintype_fun_eq_card":
 "/-- The vector space of functions on a fintype ι has finrank equal to the cardinality of ι. -/\n@[simp]\ntheorem finrank_fintype_fun_eq_card {ι : Type v} [Fintype ι] : finrank K (ι → K) = Fintype.card ι :=\n  finrank_eq_of_rank_eq rank_fun'\n#align finrank_fintype_fun_eq_card finrank_fintype_fun_eq_card\n\n",
 "finrank_fin_fun":
 "/-- The vector space of functions on `fin n` has finrank equal to `n`. -/\n@[simp]\ntheorem finrank_fin_fun {n : ℕ} : finrank K (Fin n → K) = n := by simp\n#align finrank_fin_fun finrank_fin_fun\n\n",
 "finrank_eq_zero_of_not_exists_basis_finset":
 "#print finrank_eq_zero_of_not_exists_basis_finset /-\ntheorem finrank_eq_zero_of_not_exists_basis_finset (h : ¬∃ s : Finset V, Nonempty (Basis s K V)) : finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩\n#align finrank_eq_zero_of_not_exists_basis_finset finrank_eq_zero_of_not_exists_basis_finset\n-/\n\n",
 "finrank_eq_zero_of_not_exists_basis_finite":
 "#print finrank_eq_zero_of_not_exists_basis_finite /-\ntheorem finrank_eq_zero_of_not_exists_basis_finite (h : ¬∃ (s : Set V)(b : Basis.{v} (s : Set V) K V), s.finite) :\n    finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_not_finite fun s b hs => h ⟨s, b, hs⟩\n#align finrank_eq_zero_of_not_exists_basis_finite finrank_eq_zero_of_not_exists_basis_finite\n-/\n\n",
 "finrank_eq_zero_of_not_exists_basis":
 "#print finrank_eq_zero_of_not_exists_basis /-\ntheorem finrank_eq_zero_of_not_exists_basis (h : ¬∃ s : Finset V, Nonempty (Basis (s : Set V) K V)) : finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩\n#align finrank_eq_zero_of_not_exists_basis finrank_eq_zero_of_not_exists_basis\n-/\n\n",
 "finrank_eq_zero_of_basis_imp_not_finite":
 "#print finrank_eq_zero_of_basis_imp_not_finite /-\ntheorem finrank_eq_zero_of_basis_imp_not_finite (h : ∀ s : Set V, Basis.{v} (s : Set V) K V → ¬s.finite) :\n    finrank K V = 0 := by\n  obtain ⟨_, ⟨b⟩⟩ := (Module.free_iff_set K V).mp ‹_›\n  exact dif_neg fun rank_lt => h _ b (b.finite_index_of_rank_lt_aleph_0 rank_lt)\n#align finrank_eq_zero_of_basis_imp_not_finite finrank_eq_zero_of_basis_imp_not_finite\n-/\n\n",
 "finrank_eq_zero_of_basis_imp_false":
 "#print finrank_eq_zero_of_basis_imp_false /-\ntheorem finrank_eq_zero_of_basis_imp_false (h : ∀ s : Finset V, Basis.{v} (s : Set V) K V → False) : finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_not_finite fun s b hs =>\n    h hs.to_finset\n      (by\n        convert b\n        simp)\n#align finrank_eq_zero_of_basis_imp_false finrank_eq_zero_of_basis_imp_false\n-/\n\n",
 "finrank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print finrank_eq_one /-\n/-- If there is a nonzero vector and every other vector is a multiple of it,\nthen the module has dimension one. -/\ntheorem finrank_eq_one (v : V) (n : v ≠ 0) (h : ∀ w : V, ∃ c : K, «expr • » c v = w) : finrank K V = 1 :=\n  by\n  haveI := nontrivial_of_invariantBasisNumber K\n  obtain ⟨b⟩ := (Basis.basis_singleton_iff PUnit).mpr ⟨v, n, h⟩\n  rw [finrank_eq_card_basis b, Fintype.card_punit]\n#align finrank_eq_one finrank_eq_one\n-/\n\n",
 "finrank_eq_of_rank_eq":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Anne Baanen\n-/\ntheorem finrank_eq_of_rank_eq {n : ℕ} (h : Module.rank K V = ↑n) : finrank K V = n :=\n  by\n  apply_fun toNat  at h\n  rw [to_nat_cast] at h\n  exact_mod_cast h\n#align finrank_eq_of_rank_eq finrank_eq_of_rank_eq\n\n",
 "finrank_eq_card_finset_basis":
 "/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. This lemma uses a `finset` instead of indexed types. -/\ntheorem finrank_eq_card_finset_basis {ι : Type w} {b : Finset ι} (h : Basis.{w} b K V) : finrank K V = Finset.card b :=\n  by rw [finrank_eq_card_basis h, Fintype.card_coe]\n#align finrank_eq_card_finset_basis finrank_eq_card_finset_basis\n\n",
 "finrank_eq_card_basis":
 "/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem finrank_eq_card_basis {ι : Type w} [Fintype ι] (h : Basis ι K V) : finrank K V = Fintype.card ι :=\n  finrank_eq_of_rank_eq (rank_eq_card_basis h)\n#align finrank_eq_card_basis finrank_eq_card_basis\n\n",
 "finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem finrank_eq (f : «expr ≃ₗ[ ] » M R M₂) : finrank R M = finrank R M₂ :=\n  by\n  unfold finrank\n  rw [← Cardinal.toNat_lift, f.lift_rank_eq, Cardinal.toNat_lift]\n#align finrank_eq finrank_eq\n\n",
 "finrank_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n#print Subalgebra.finrank_bot /-\n@[simp]\ntheorem Subalgebra.finrank_bot : finrank F («expr⊥» : Subalgebra F E) = 1 :=\n  finrank_eq_of_rank_eq (by simp)\n#align subalgebra.finrank_bot Subalgebra.finrank_bot\n-/\n\n",
 "coe_basisOfTopLeSpanOfCardEqFinrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n#print coe_basisOfTopLeSpanOfCardEqFinrank /-\n@[simp]\ntheorem coe_basisOfTopLeSpanOfCardEqFinrank {ι : Type _} [Fintype ι] (b : ι → V)\n    (le_span : «expr⊤» ≤ span K (Set.range b)) (card_eq : Fintype.card ι = finrank K V) :\n    «expr⇑ » (basisOfTopLeSpanOfCardEqFinrank b le_span card_eq) = b :=\n  Basis.coe_mk _ _\n#align coe_basis_of_top_le_span_of_card_eq_finrank coe_basisOfTopLeSpanOfCardEqFinrank\n-/\n\n"}