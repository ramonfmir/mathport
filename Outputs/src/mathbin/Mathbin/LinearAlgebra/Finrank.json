{"subset_extend":
 "theorem basis.subset_extend {s : set V} (hs : linear_independent K (coe : s → V)) : s ⊆ hs.extend (Set.subset_univ _) :=\n  hs.subset_extend _\n#align basis.subset_extend basis.subset_extend\n\n",
 "subalgebra_top_finrank_eq_submodule_top_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra_top_finrank_eq_submodule_top_finrank :\n    finrank F («expr⊤» : subalgebra F E) = finrank F («expr⊤» : submodule F E) :=\n  by\n  rw [← algebra.top_to_submodule]\n  rfl\n#align subalgebra_top_finrank_eq_submodule_top_finrank subalgebra_top_finrank_eq_submodule_top_finrank\n\n",
 "subalgebra_top_dim_eq_submodule_top_dim":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra_top_dim_eq_submodule_top_dim :\n    module.rank F («expr⊤» : subalgebra F E) = module.rank F («expr⊤» : submodule F E) :=\n  by\n  rw [← algebra.top_to_submodule]\n  rfl\n#align subalgebra_top_dim_eq_submodule_top_dim subalgebra_top_dim_eq_submodule_top_dim\n\n",
 "span_lt_top_of_card_lt_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem span_lt_top_of_card_lt_finrank {s : set V} [fintype s] (card_lt : s.to_finset.card < finrank K V) :\n    span K s < «expr⊤» :=\n  lt_top_of_finrank_lt_finrank (lt_of_le_of_lt (finrank_span_le_card _) card_lt)\n#align span_lt_top_of_card_lt_finrank span_lt_top_of_card_lt_finrank\n\n",
 "span_lt_of_subset_of_card_lt_finrank":
 "theorem span_lt_of_subset_of_card_lt_finrank {s : set V} [fintype s] {t : submodule K V} (subset : s ⊆ t)\n    (card_lt : s.to_finset.card < finrank K t) : span K s < t :=\n  lt_of_le_of_finrank_lt_finrank (span_le.mpr subset) (lt_of_le_of_lt (finrank_span_le_card _) card_lt)\n#align span_lt_of_subset_of_card_lt_finrank span_lt_of_subset_of_card_lt_finrank\n\n",
 "nontrivial_of_finrank_pos":
 "/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem nontrivial_of_finrank_pos (h : 0 < finrank K V) : nontrivial V :=\n  dim_pos_iff_nontrivial.mp (dim_lt_of_finrank_lt h)\n#align nontrivial_of_finrank_pos nontrivial_of_finrank_pos\n\n",
 "nontrivial_of_finrank_eq_succ":
 "/-- A finite dimensional space is nontrivial if it has `finrank` equal to the successor of a\nnatural number. -/\ntheorem nontrivial_of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) : nontrivial V :=\n  nontrivial_of_finrank_pos (by rw [hn] <;> exact n.succ_pos)\n#align nontrivial_of_finrank_eq_succ nontrivial_of_finrank_eq_succ\n\n",
 "lt_top_of_finrank_lt_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem lt_top_of_finrank_lt_finrank {s : submodule K V} (lt : finrank K s < finrank K V) : s < «expr⊤» :=\n  by\n  rw [← @finrank_top K V] at lt\n  exact lt_of_le_of_finrank_lt_finrank le_top lt\n#align lt_top_of_finrank_lt_finrank lt_top_of_finrank_lt_finrank\n\n",
 "lt_of_le_of_finrank_lt_finrank":
 "theorem lt_of_le_of_finrank_lt_finrank {s t : submodule K V} (le : s ≤ t) (lt : finrank K s < finrank K t) : s < t :=\n  lt_of_le_of_ne le fun h => ne_of_lt lt (by rw [h])\n#align lt_of_le_of_finrank_lt_finrank lt_of_le_of_finrank_lt_finrank\n\n",
 "linear_independent_of_top_le_span_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem linear_independent_of_top_le_span_of_card_eq_finrank {ι : Type _} [fintype ι] {b : ι → V}\n    (spans : «expr⊤» ≤ span K (Set.range b)) (card_eq : fintype.card ι = finrank K V) : linear_independent K b :=\n  linear_independent_iff'.mpr fun s g dependent i i_mem_s =>\n    by\n    by_contra gx_ne_zero\n    -- We'll derive a contradiction by showing `b '' (univ \\ {i})` of cardinality `n - 1`\n    -- spans a vector space of dimension `n`.\n    refine'\n      not_le_of_gt\n        (span_lt_top_of_card_lt_finrank (show («expr '' » b (Set.univ \\ {i})).to_finset.card < finrank K V from _)) _\n    ·\n      calc\n        («expr '' » b (Set.univ \\ {i})).to_finset.card = ((Set.univ \\ {i}).to_finset.image b).card := by\n          rw [set.to_finset_card, fintype.card_of_finset]\n        _ ≤ (Set.univ \\ {i}).to_finset.card := finset.card_image_le\n        _ = (finset.univ.erase i).card := congr_arg finset.card (Finset.ext (by simp [and_comm']))\n        _ < finset.univ.card := finset.card_erase_lt_of_mem (finset.mem_univ i)\n        _ = finrank K V := card_eq\n        \n    -- We already have that `b '' univ` spans the whole space,\n    -- so we only need to show that the span of `b '' (univ \\ {i})` contains each `b j`.\n    refine' spans.trans (span_le.mpr _)\n    rintro _ ⟨j, rfl, rfl⟩\n    -- The case that `j ≠ i` is easy because `b j ∈ b '' (univ \\ {i})`.\n    by_cases j_eq : j = i\n    swap\n    · refine' subset_span ⟨j, (Set.mem_diff _).mpr ⟨Set.mem_univ _, _⟩, rfl⟩\n      exact mt set.mem_singleton_iff.mp j_eq\n    -- To show `b i ∈ span (b '' (univ \\ {i}))`, we use that it's a weighted sum\n    -- of the other `b j`s.\n    rw [j_eq, SetLike.mem_coe, show b i = -«expr • » (g i)⁻¹ ((s.erase i).sum fun j => «expr • » (g j) (b j)) from _]\n    · refine' neg_mem (smul_mem _ _ (sum_mem fun k hk => _))\n      obtain ⟨k_ne_i, k_mem⟩ := finset.mem_erase.mp hk\n      refine' smul_mem _ _ (subset_span ⟨k, _, rfl⟩)\n      simpa using k_mem\n    -- To show `b i` is a weighted sum of the other `b j`s, we'll rewrite this sum\n    -- to have the form of the assumption `dependent`.\n    apply eq_neg_of_add_eq_zero_left\n    calc\n      b i + «expr • » (g i)⁻¹ ((s.erase i).sum fun j => «expr • » (g j) (b j)) =\n          «expr • » (g i)⁻¹ («expr • » (g i) (b i) + (s.erase i).sum fun j => «expr • » (g j) (b j)) :=\n        by rw [smul_add, ← mul_smul, inv_mul_cancel gx_ne_zero, one_smul]\n      _ = «expr • » (g i)⁻¹ 0 := congr_arg _ _\n      _ = 0 := smul_zero _\n      \n    -- And then it's just a bit of manipulation with finite sums.\n    rwa [← Finset.insert_erase i_mem_s, finset.sum_insert (Finset.not_mem_erase _ _)] at dependent\n#align linear_independent_of_top_le_span_of_card_eq_finrank linear_independent_of_top_le_span_of_card_eq_finrank\n\n",
 "linear_independent_iff_card_le_finrank_span":
 "theorem linear_independent_iff_card_le_finrank_span {ι : Type _} [fintype ι] {b : ι → V} :\n    linear_independent K b ↔ fintype.card ι ≤ (Set.range b).finrank K := by\n  rw [linear_independent_iff_card_eq_finrank_span, finrank_range_le_card.le_iff_eq]\n#align linear_independent_iff_card_le_finrank_span linear_independent_iff_card_le_finrank_span\n\n",
 "linear_independent_iff_card_eq_finrank_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem linear_independent_iff_card_eq_finrank_span {ι : Type _} [fintype ι] {b : ι → V} :\n    linear_independent K b ↔ fintype.card ι = (Set.range b).finrank K :=\n  by\n  constructor\n  · intro h\n    exact (finrank_span_eq_card h).symm\n  · intro hc\n    let f := submodule.subtype (span K (Set.range b))\n    let b' : ι → span K (Set.range b) := fun i => ⟨b i, mem_span.2 fun p hp => hp (Set.mem_range_self _)⟩\n    have hs : «expr⊤» ≤ span K (Set.range b') := by\n      intro x\n      have h : span K («expr '' » f (Set.range b')) = map f (span K (Set.range b')) := span_image f\n      have hf : «expr '' » f (Set.range b') = Set.range b :=\n        by\n        ext x\n        simp [Set.mem_image, Set.mem_range]\n      rw [hf] at h\n      have hx : (x : V) ∈ span K (Set.range b) := x.property\n      conv at hx =>\n        congr\n        skip\n        rw [h]\n      simpa [mem_map] using hx\n    have hi : f.ker = «expr⊥» := ker_subtype _\n    convert (linear_independent_of_top_le_span_of_card_eq_finrank hs hc).map' _ hi\n#align linear_independent_iff_card_eq_finrank_span linear_independent_iff_card_eq_finrank_span\n\n",
 "finrank_zero_of_subsingleton":
 "/-- A (finite dimensional) space that is a subsingleton has zero `finrank`. -/\ntheorem finrank_zero_of_subsingleton [h : subsingleton V] : finrank K V = 0 :=\n  by\n  by_contra h0\n  obtain ⟨x, y, hxy⟩ := nontrivial_of_finrank_pos (nat.pos_of_ne_zero h0)\n  exact hxy (subsingleton.elim _ _)\n#align finrank_zero_of_subsingleton finrank_zero_of_subsingleton\n\n",
 "finrank_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem finrank_top : finrank K («expr⊤» : submodule K V) = finrank K V :=\n  by\n  unfold finrank\n  simp [dim_top]\n#align finrank_top finrank_top\n\n",
 "finrank_to_submodule":
 "@[simp]\ntheorem subalgebra.finrank_to_submodule (S : subalgebra F E) : finrank F S.to_submodule = finrank F S :=\n  rfl\n#align subalgebra.finrank_to_submodule subalgebra.finrank_to_submodule\n\n",
 "finrank_span_set_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem finrank_span_set_eq_card (s : set V) [fintype s] (hs : linear_independent K (coe : s → V)) :\n    finrank K (span K s) = s.to_finset.card :=\n  finrank_eq_of_dim_eq\n    (by\n      have : module.rank K (span K s) = cardinal.mk s := dim_span_set hs\n      rwa [cardinal.mk_fintype, ← set.to_finset_card] at this)\n#align finrank_span_set_eq_card finrank_span_set_eq_card\n\n",
 "finrank_span_le_card":
 "theorem finrank_span_le_card (s : set V) [fintype s] : finrank K (span K s) ≤ s.to_finset.card :=\n  finrank_le_of_dim_le (by simpa using dim_span_le s)\n#align finrank_span_le_card finrank_span_le_card\n\n",
 "finrank_span_finset_le_card":
 "theorem finrank_span_finset_le_card (s : Finset V) : (s : set V).finrank K ≤ s.card :=\n  calc\n    (s : set V).finrank K ≤ (s : set V).to_finset.card := finrank_span_le_card s\n    _ = s.card := by simp\n    \n#align finrank_span_finset_le_card finrank_span_finset_le_card\n\n",
 "finrank_span_finset_eq_card":
 "theorem finrank_span_finset_eq_card (s : Finset V) (hs : linear_independent K (coe : s → V)) :\n    finrank K (span K (s : set V)) = s.card :=\n  by\n  convert finrank_span_set_eq_card (↑s) hs\n  ext\n  simp\n#align finrank_span_finset_eq_card finrank_span_finset_eq_card\n\n",
 "finrank_span_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\ntheorem finrank_span_eq_card {ι : Type _} [fintype ι] {b : ι → V} (hb : linear_independent K b) :\n    finrank K (span K (Set.range b)) = fintype.card ι :=\n  finrank_eq_of_dim_eq\n    (by\n      have : module.rank K (span K (Set.range b)) = cardinal.mk (Set.range b) := dim_span hb\n      rwa [← lift_inj, mk_range_eq_of_injective hb.injective, cardinal.mk_fintype, lift_nat_cast, lift_eq_nat_iff] at\n        this)\n#align finrank_span_eq_card finrank_span_eq_card\n\n",
 "finrank_self":
 "/-- A division_ring is one-dimensional as a vector space over itself. -/\n@[simp]\ntheorem finrank_self : finrank K K = 1 :=\n  finrank_eq_of_dim_eq (by simp)\n#align finrank_self finrank_self\n\n",
 "finrank_range_of_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- The dimensions of the domain and range of an injective linear map are equal. -/\ntheorem finrank_range_of_inj {f : «expr →ₗ[ ] » V K V₂} (hf : function.injective f) : finrank K f.range = finrank K V :=\n  by rw [(linear_equiv.of_injective f hf).finrank_eq]\n#align finrank_range_of_inj finrank_range_of_inj\n\n",
 "finrank_range_le_card":
 "theorem finrank_range_le_card {ι : Type _} [fintype ι] {b : ι → V} : (Set.range b).finrank K ≤ fintype.card ι :=\n  (finrank_span_le_card _).trans <| by\n    rw [set.to_finset_range]\n    exact finset.card_image_le\n#align finrank_range_le_card finrank_range_le_card\n\n",
 "finrank_map_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Pushforwards of finite-dimensional submodules along a `linear_equiv` have the same finrank. -/\ntheorem finrank_map_eq (f : «expr ≃ₗ[ ] » M R M₂) (p : submodule R M) :\n    finrank R (p.map (f : «expr →ₗ[ ] » M R M₂)) = finrank R p :=\n  (f.submodule_map p).finrank_eq.symm\n#align finrank_map_eq finrank_map_eq\n\n",
 "finrank_lt_of_dim_lt":
 "theorem finrank_lt_of_dim_lt {n : ℕ} (h : module.rank K V < ↑n) : finrank K V < n :=\n  by\n  rwa [← cardinal.to_nat_lt_iff_lt_of_lt_aleph_0, to_nat_cast] at h\n  · exact h.trans (nat_lt_aleph_0 n)\n  · exact nat_lt_aleph_0 n\n#align finrank_lt_of_dim_lt finrank_lt_of_dim_lt\n\n",
 "finrank_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If every vector is a multiple of some `v : V`, then `V` has dimension at most one.\n-/\ntheorem finrank_le_one (v : V) (h : ∀ w : V, ∃ c : K, «expr • » c v = w) : finrank K V ≤ 1 :=\n  by\n  rcases eq_or_ne v 0 with (rfl | hn)\n  · haveI :=\n      subsingleton_of_forall_eq (0 : V) fun w => by\n        obtain ⟨c, rfl⟩ := h w\n        simp\n    rw [finrank_zero_of_subsingleton]\n    exact zero_le_one\n  · exact (finrank_eq_one v hn h).le\n#align finrank_le_one finrank_le_one\n\n",
 "finrank_le_of_dim_le":
 "theorem finrank_le_of_dim_le {n : ℕ} (h : module.rank K V ≤ ↑n) : finrank K V ≤ n :=\n  by\n  rwa [← cardinal.to_nat_le_iff_le_of_lt_aleph_0, to_nat_cast] at h\n  · exact h.trans_lt (nat_lt_aleph_0 n)\n  · exact nat_lt_aleph_0 n\n#align finrank_le_of_dim_le finrank_le_of_dim_le\n\n",
 "finrank_fintype_fun_eq_card":
 "/-- The vector space of functions on a fintype ι has finrank equal to the cardinality of ι. -/\n@[simp]\ntheorem finrank_fintype_fun_eq_card {ι : Type v} [fintype ι] : finrank K (ι → K) = fintype.card ι :=\n  finrank_eq_of_dim_eq dim_fun'\n#align finrank_fintype_fun_eq_card finrank_fintype_fun_eq_card\n\n",
 "finrank_fin_fun":
 "/-- The vector space of functions on `fin n` has finrank equal to `n`. -/\n@[simp]\ntheorem finrank_fin_fun {n : ℕ} : finrank K (fin n → K) = n := by simp\n#align finrank_fin_fun finrank_fin_fun\n\n",
 "finrank_eq_zero_of_not_exists_basis_finset":
 "theorem finrank_eq_zero_of_not_exists_basis_finset (h : ¬∃ s : Finset V, nonempty (basis s K V)) : finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩\n#align finrank_eq_zero_of_not_exists_basis_finset finrank_eq_zero_of_not_exists_basis_finset\n\n",
 "finrank_eq_zero_of_not_exists_basis_finite":
 "theorem finrank_eq_zero_of_not_exists_basis_finite (h : ¬∃ (s : set V)(b : basis.{v} (s : set V) K V), s.finite) :\n    finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_not_finite fun s b hs => h ⟨s, b, hs⟩\n#align finrank_eq_zero_of_not_exists_basis_finite finrank_eq_zero_of_not_exists_basis_finite\n\n",
 "finrank_eq_zero_of_not_exists_basis":
 "theorem finrank_eq_zero_of_not_exists_basis (h : ¬∃ s : Finset V, nonempty (basis (s : set V) K V)) : finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_false fun s b => h ⟨s, ⟨b⟩⟩\n#align finrank_eq_zero_of_not_exists_basis finrank_eq_zero_of_not_exists_basis\n\n",
 "finrank_eq_zero_of_basis_imp_not_finite":
 "theorem finrank_eq_zero_of_basis_imp_not_finite (h : ∀ s : set V, basis.{v} (s : set V) K V → ¬s.finite) :\n    finrank K V = 0 :=\n  dif_neg fun dim_lt =>\n    h _ (basis.of_vector_space K V) ((basis.of_vector_space K V).finite_index_of_dim_lt_aleph_0 dim_lt)\n#align finrank_eq_zero_of_basis_imp_not_finite finrank_eq_zero_of_basis_imp_not_finite\n\n",
 "finrank_eq_zero_of_basis_imp_false":
 "theorem finrank_eq_zero_of_basis_imp_false (h : ∀ s : Finset V, basis.{v} (s : set V) K V → false) : finrank K V = 0 :=\n  finrank_eq_zero_of_basis_imp_not_finite fun s b hs =>\n    h hs.to_finset\n      (by\n        convert b\n        simp)\n#align finrank_eq_zero_of_basis_imp_false finrank_eq_zero_of_basis_imp_false\n\n",
 "finrank_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If there is a nonzero vector and every other vector is a multiple of it,\nthen the module has dimension one. -/\ntheorem finrank_eq_one (v : V) (n : v ≠ 0) (h : ∀ w : V, ∃ c : K, «expr • » c v = w) : finrank K V = 1 :=\n  by\n  obtain ⟨b⟩ := (basis.basis_singleton_iff PUnit).mpr ⟨v, n, h⟩\n  rw [finrank_eq_card_basis b, fintype.card_punit]\n#align finrank_eq_one finrank_eq_one\n\n",
 "finrank_eq_of_dim_eq":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Anne Baanen\n-/\ntheorem finrank_eq_of_dim_eq {n : ℕ} (h : module.rank K V = ↑n) : finrank K V = n :=\n  by\n  apply_fun to_nat  at h\n  rw [to_nat_cast] at h\n  exact_mod_cast h\n#align finrank_eq_of_dim_eq finrank_eq_of_dim_eq\n\n",
 "finrank_eq_card_finset_basis":
 "/-- If a vector space has a finite basis, then its dimension is equal to the cardinality of the\nbasis. This lemma uses a `finset` instead of indexed types. -/\ntheorem finrank_eq_card_finset_basis {ι : Type w} {b : Finset ι} (h : basis.{w} b K V) : finrank K V = finset.card b :=\n  by rw [finrank_eq_card_basis h, fintype.card_coe]\n#align finrank_eq_card_finset_basis finrank_eq_card_finset_basis\n\n",
 "finrank_eq_card_basis":
 "/-- If a vector space has a finite basis, then its dimension is equal to the cardinality of the\nbasis. -/\ntheorem finrank_eq_card_basis {ι : Type w} [fintype ι] (h : basis ι K V) : finrank K V = fintype.card ι :=\n  finrank_eq_of_dim_eq (dim_eq_card_basis h)\n#align finrank_eq_card_basis finrank_eq_card_basis\n\n",
 "finrank_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem finrank_eq (f : «expr ≃ₗ[ ] » M R M₂) : finrank R M = finrank R M₂ :=\n  by\n  unfold finrank\n  rw [← cardinal.to_nat_lift, f.lift_dim_eq, cardinal.to_nat_lift]\n#align finrank_eq finrank_eq\n\n",
 "finrank_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem subalgebra.finrank_bot [nontrivial E] : finrank F («expr⊥» : subalgebra F E) = 1 :=\n  finrank_eq_of_dim_eq (by simp)\n#align subalgebra.finrank_bot subalgebra.finrank_bot\n\n",
 "dim_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra.dim_top : module.rank F («expr⊤» : subalgebra F E) = module.rank F E :=\n  by\n  rw [subalgebra_top_dim_eq_submodule_top_dim]\n  exact dim_top F E\n#align subalgebra.dim_top subalgebra.dim_top\n\n",
 "dim_to_submodule":
 "@[simp]\ntheorem subalgebra.dim_to_submodule (S : subalgebra F E) : module.rank F S.to_submodule = module.rank F S :=\n  rfl\n#align subalgebra.dim_to_submodule subalgebra.dim_to_submodule\n\n",
 "dim_lt_of_finrank_lt":
 "theorem dim_lt_of_finrank_lt {n : ℕ} (h : n < finrank K V) : ↑n < module.rank K V :=\n  by\n  rwa [← cardinal.to_nat_lt_iff_lt_of_lt_aleph_0, to_nat_cast]\n  · exact nat_lt_aleph_0 n\n  · contrapose! h\n    rw [finrank, cardinal.to_nat_apply_of_aleph_0_le h]\n    exact n.zero_le\n#align dim_lt_of_finrank_lt dim_lt_of_finrank_lt\n\n",
 "dim_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem subalgebra.dim_bot [nontrivial E] : module.rank F («expr⊥» : subalgebra F E) = 1 :=\n  ((subalgebra.to_submodule_equiv («expr⊥» : subalgebra F E)).symm.trans <|\n          linear_equiv.of_eq _ _ algebra.to_submodule_bot).dim_eq.trans <|\n    by\n    rw [dim_span_set]\n    exacts[mk_singleton _, linear_independent_singleton one_ne_zero]\n#align subalgebra.dim_bot subalgebra.dim_bot\n\n",
 "coe_basis_of_top_le_span_of_card_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_basis_of_top_le_span_of_card_eq_finrank {ι : Type _} [fintype ι] (b : ι → V)\n    (le_span : «expr⊤» ≤ span K (Set.range b)) (card_eq : fintype.card ι = finrank K V) :\n    «expr⇑ » (basis_of_top_le_span_of_card_eq_finrank b le_span card_eq) = b :=\n  basis.coe_mk _ _\n#align coe_basis_of_top_le_span_of_card_eq_finrank coe_basis_of_top_le_span_of_card_eq_finrank\n\n"}