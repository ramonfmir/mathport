{"zero_right":
 "@[simp]\ntheorem zero_right (x : M) : SameRay R x 0 :=\n  or.inr <| or.inl rfl\n#align zero_right zero_right\n\n",
 "zero_left":
 "/-\nCopyright (c) 2021 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n@[simp]\ntheorem zero_left (y : M) : SameRay R 0 y :=\n  or.inl rfl\n#align zero_left zero_left\n\n",
 "units_smul_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scaling by a positive unit is a no-op. -/\ntheorem units_smul_of_pos (u : «expr ˣ» R) (hu : 0 < (u : R)) (v : Module.Ray R M) : «expr • » u v = v :=\n  by\n  induction v using Module.Ray.ind\n  rw [smul_rayOfNeZero, ray_eq_iff]\n  exact SameRay.sameRay_pos_smul_left _ hu\n#align units_smul_of_pos units_smul_of_pos\n\n",
 "units_smul_of_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scaling by a negative unit is negation. -/\ntheorem units_smul_of_neg (u : «expr ˣ» R) (hu : (u : R) < 0) (v : Module.Ray R M) : «expr • » u v = -v :=\n  by\n  rw [← neg_inj, neg_neg, ← neg_units_smul, units_smul_of_pos]\n  rwa [Units.val_neg, Right.neg_pos_iff]\n#align units_smul_of_neg units_smul_of_neg\n\n",
 "units_smul_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print units_smul_eq_self_iff /-\n@[simp]\ntheorem units_smul_eq_self_iff {u : «expr ˣ» R} {v : Module.Ray R M} : «expr • » u v = v ↔ (0 : R) < u :=\n  by\n  induction' v using Module.Ray.ind with v hv\n  simp only [smul_rayOfNeZero, ray_eq_iff, Units.smul_def, sameRay_smul_left_iff_of_ne hv u.ne_zero]\n#align units_smul_eq_self_iff units_smul_eq_self_iff\n-/\n\n",
 "units_smul_eq_neg_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print units_smul_eq_neg_iff /-\n@[simp]\ntheorem units_smul_eq_neg_iff {u : «expr ˣ» R} {v : Module.Ray R M} : «expr • » u v = -v ↔ ↑u < (0 : R) := by\n  rw [← neg_inj, neg_neg, ← Module.Ray.neg_units_smul, units_smul_eq_self_iff, Units.val_neg, neg_pos]\n#align units_smul_eq_neg_iff units_smul_eq_neg_iff\n-/\n\n",
 "units_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print units_inv_smul /-\n/-- Scaling by an inverse unit is the same as scaling by itself. -/\n@[simp]\ntheorem units_inv_smul (u : «expr ˣ» R) (v : Module.Ray R M) : «expr • » u⁻¹ v = «expr • » u v :=\n  calc\n    «expr • » u⁻¹ v = «expr • » (u * u) («expr • » u⁻¹ v) :=\n      Eq.symm <| («expr • » u⁻¹ v).units_smul_of_pos _ <| mul_self_pos.2 u.ne_zero\n    _ = «expr • » u v := by rw [mul_smul, smul_inv_smul]\n    \n#align units_inv_smul units_inv_smul\n-/\n\n",
 "trans":
 "#print trans /-\n/-- `same_ray` is transitive unless the vector in the middle is zero and both other vectors are\nnonzero. -/\ntheorem trans (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 → x = 0 ∨ z = 0) : SameRay R x z :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx); · exact zero_left z\n  rcases eq_or_ne z 0 with (rfl | hz); · exact zero_right x\n  rcases eq_or_ne y 0 with (rfl | hy); · exact (hy rfl).elim (fun h => (hx h).elim) fun h => (hz h).elim\n  rcases hxy.exists_pos hx hy with ⟨r₁, r₂, hr₁, hr₂, h₁⟩\n  rcases hyz.exists_pos hy hz with ⟨r₃, r₄, hr₃, hr₄, h₂⟩\n  refine' or.inr (or.inr <| ⟨r₃ * r₁, r₂ * r₄, mul_pos hr₃ hr₁, mul_pos hr₂ hr₄, _⟩)\n  rw [mul_smul, mul_smul, h₁, ← h₂, smul_comm]\n#align trans trans\n-/\n\n",
 "symm":
 "#print symm /-\n/-- `same_ray` is symmetric. -/\n@[symm]\ntheorem symm (h : SameRay R x y) : SameRay R y x :=\n  (or_left_comm.1 h).imp_right <| or.imp_right fun ⟨r₁, r₂, h₁, h₂, h⟩ => ⟨r₂, r₁, h₂, h₁, h.symm⟩\n#align symm symm\n-/\n\n",
 "some_vector_ray":
 "/-- The ray of `some_vector`. -/\n@[simp]\ntheorem some_vector_ray (x : Module.Ray R M) : rayOfNeZero R _ x.some_vector_ne_zero = x :=\n  (congr_arg _ (Subtype.coe_eta _ _) : _).trans x.out_eq\n#align some_vector_ray some_vector_ray\n\n",
 "some_vector_ne_zero":
 "/-- `some_vector` is nonzero. -/\n@[simp]\ntheorem some_vector_ne_zero (x : Module.Ray R M) : x.some_vector ≠ 0 :=\n  x.some_ray_vector.property\n#align some_vector_ne_zero some_vector_ne_zero\n\n",
 "some_ray_vector_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-- The ray of `some_ray_vector`. -/\n@[simp]\ntheorem some_ray_vector_ray (x : Module.Ray R M) : («expr⟦ ⟧» x.some_ray_vector : Module.Ray R M) = x :=\n  Quotient.out_eq _\n#align some_ray_vector_ray some_ray_vector_ray\n\n",
 "smul_rayOfNeZero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print smul_rayOfNeZero /-\n@[simp]\ntheorem smul_rayOfNeZero (g : G) (v : M) (hv) :\n    «expr • » g (rayOfNeZero R v hv) = rayOfNeZero R («expr • » g v) ((smul_ne_zero_iff_ne _).2 hv) :=\n  rfl\n#align smul_ray_of_ne_zero smul_rayOfNeZero\n-/\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If two vectors are on the same ray then both scaled by the same action are also on the same\nray. -/\ntheorem smul {S : Type _} [Monoid S] [DistribMulAction S M] [SMulCommClass R S M] (h : SameRay R x y) (s : S) :\n    SameRay R («expr • » s x) («expr • » s y) :=\n  h.map («expr • » s (LinearMap.id : «expr →ₗ[ ] » M R M))\n#align smul smul\n\n",
 "same_ray_pos_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print SameRay.sameRay_pos_smul_right /-\n/-- A vector is in the same ray as a positive multiple of itself. -/\ntheorem SameRay.sameRay_pos_smul_right (v : M) {r : R} (h : 0 < r) : SameRay R v («expr • » r v) :=\n  SameRay.sameRay_nonneg_smul_right v h.le\n#align same_ray_pos_smul_right SameRay.sameRay_pos_smul_right\n-/\n\n",
 "same_ray_pos_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print SameRay.sameRay_pos_smul_left /-\n/-- A positive multiple of a vector is in the same ray as that vector. -/\ntheorem SameRay.sameRay_pos_smul_left (v : M) {r : R} (h : 0 < r) : SameRay R («expr • » r v) v :=\n  SameRay.sameRay_nonneg_smul_left v h.le\n#align same_ray_pos_smul_left SameRay.sameRay_pos_smul_left\n-/\n\n",
 "same_ray_nonneg_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print SameRay.sameRay_nonneg_smul_right /-\n/-- A vector is in the same ray as a nonnegative multiple of itself. -/\ntheorem SameRay.sameRay_nonneg_smul_right (v : M) {r : R} (h : 0 ≤ r) : SameRay R v («expr • » r v) :=\n  or.inr <|\n    h.eq_or_lt.imp (fun h => h ▸ zero_smul R v) fun h =>\n      ⟨r, 1, h, by\n        nontriviality R\n        exact zero_lt_one, (one_smul _ _).symm⟩\n#align same_ray_nonneg_smul_right SameRay.sameRay_nonneg_smul_right\n-/\n\n",
 "same_ray_nonneg_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print SameRay.sameRay_nonneg_smul_left /-\n/-- A nonnegative multiple of a vector is in the same ray as that vector. -/\ntheorem SameRay.sameRay_nonneg_smul_left (v : M) {r : R} (h : 0 ≤ r) : SameRay R («expr • » r v) v :=\n  (SameRay.sameRay_nonneg_smul_right v h).symm\n#align same_ray_nonneg_smul_left SameRay.sameRay_nonneg_smul_left\n-/\n\n",
 "same_ray_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print SameRay.sameRay_map_iff /-\n/-- The images of two vectors under a linear equivalence are on the same ray if and only if the\noriginal vectors are on the same ray. -/\n@[simp]\ntheorem SameRay.sameRay_map_iff (e : «expr ≃ₗ[ ] » M R N) : SameRay R (e x) (e y) ↔ SameRay R x y :=\n  Function.Injective.sameRay_map_iff (EquivLike.injective e)\n#align same_ray_map_iff SameRay.sameRay_map_iff\n-/\n\n",
 "same_ray_comm":
 "#print SameRay.sameRay_comm /-\ntheorem SameRay.sameRay_comm : SameRay R x y ↔ SameRay R y x :=\n  ⟨SameRay.symm, SameRay.symm⟩\n#align same_ray_comm SameRay.sameRay_comm\n-/\n\n",
 "sameRay_smul_right_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_smul_right_iff_of_ne /-\n/-- A nonzero vector is in the same ray as a multiple of itself if and only if that multiple\nis positive. -/\ntheorem sameRay_smul_right_iff_of_ne {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : SameRay R v («expr • » r v) ↔ 0 < r :=\n  by simp only [sameRay_smul_right_iff, hv, or_false_iff, hr.symm.le_iff_lt]\n#align same_ray_smul_right_iff_of_ne sameRay_smul_right_iff_of_ne\n-/\n\n",
 "sameRay_smul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_smul_right_iff /-\n@[simp]\ntheorem sameRay_smul_right_iff {v : M} {r : R} : SameRay R v («expr • » r v) ↔ 0 ≤ r ∨ v = 0 :=\n  ⟨fun hrv => or_iff_not_imp_left.2 fun hr => eq_zero_of_sameRay_neg_smul_right (not_le.1 hr) hrv,\n    or_imp.2 ⟨SameRay.sameRay_nonneg_smul_right v, fun h => h.symm ▸ SameRay.zero_left _⟩⟩\n#align same_ray_smul_right_iff sameRay_smul_right_iff\n-/\n\n",
 "sameRay_smul_left_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_smul_left_iff_of_ne /-\n/-- A multiple of a nonzero vector is in the same ray as that vector if and only if that multiple\nis positive. -/\ntheorem sameRay_smul_left_iff_of_ne {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : SameRay R («expr • » r v) v ↔ 0 < r :=\n  SameRay.sameRay_comm.trans (sameRay_smul_right_iff_of_ne hv hr)\n#align same_ray_smul_left_iff_of_ne sameRay_smul_left_iff_of_ne\n-/\n\n",
 "sameRay_smul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_smul_left_iff /-\n@[simp]\ntheorem sameRay_smul_left_iff {v : M} {r : R} : SameRay R («expr • » r v) v ↔ 0 ≤ r ∨ v = 0 :=\n  SameRay.sameRay_comm.trans sameRay_smul_right_iff\n#align same_ray_smul_left_iff sameRay_smul_left_iff\n-/\n\n",
 "sameRay_or_sameRay_neg_iff_not_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n#print sameRay_or_sameRay_neg_iff_not_linearIndependent /-\n/-- Two vectors are in the same ray, or the first is in the same ray as the negation of the\nsecond, if and only if they are not linearly independent. -/\ntheorem sameRay_or_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y ∨ SameRay R x (-y) ↔\n      ¬LinearIndependent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  by_cases hx : x = 0;\n  ·\n    simp [hx,\n      fun h :\n        LinearIndependent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") =>\n      h.ne_zero 0 rfl]\n  by_cases hy : y = 0;\n  ·\n    simp [hy,\n      fun h :\n        LinearIndependent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") =>\n      h.ne_zero 1 rfl]\n  simp_rw [Fintype.not_linearIndependent_iff, Fin.sum_univ_two, Fin.exists_fin_two]\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with ((hx0 | hy0 | ⟨r₁, r₂, hr₁, hr₂, h⟩) | (hx0 | hy0 | ⟨r₁, r₂, hr₁, hr₂, h⟩))\n    · exact false.elim (hx hx0)\n    · exact false.elim (hy hy0)\n    · refine' ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", _⟩\n      simp [h, hr₁.ne.symm]\n    · exact false.elim (hx hx0)\n    · exact false.elim (hy (neg_eq_zero.1 hy0))\n    · refine' ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", _⟩\n      simp [h, hr₁.ne.symm]\n  · rcases h with ⟨m, hm, hmne⟩\n    change «expr • » (m 0) x + «expr • » (m 1) y = 0 at hm\n    rw [add_eq_zero_iff_eq_neg] at hm\n    rcases lt_trichotomy (m 0) 0 with (hm0 | hm0 | hm0) <;> rcases lt_trichotomy (m 1) 0 with (hm1 | hm1 | hm1)\n    · refine' or.inr (or.inr (or.inr ⟨-m 0, -m 1, Left.neg_pos_iff.2 hm0, Left.neg_pos_iff.2 hm1, _⟩))\n      simp [hm]\n    · exfalso\n      simpa [hm1, hx, hm0.ne] using hm\n    · refine' or.inl (or.inr (or.inr ⟨-m 0, m 1, Left.neg_pos_iff.2 hm0, hm1, _⟩))\n      simp [hm]\n    · exfalso\n      simpa [hm0, hy, hm1.ne] using hm\n    · refine' false.elim (not_and_or.2 hmne ⟨hm0, hm1⟩)\n    · exfalso\n      simpa [hm0, hy, hm1.ne.symm] using hm\n    · refine' or.inl (or.inr (or.inr ⟨m 0, -m 1, hm0, Left.neg_pos_iff.2 hm1, _⟩))\n      simp [hm]\n    · exfalso\n      simpa [hm1, hx, hm0.ne.symm] using hm\n    · refine' or.inr (or.inr (or.inr ⟨m 0, m 1, hm0, hm1, _⟩))\n      simp [hm]\n#align same_ray_or_same_ray_neg_iff_not_linear_independent sameRay_or_sameRay_neg_iff_not_linearIndependent\n-/\n\n",
 "sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n#print sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent /-\n/-- Two vectors are in the same ray, or they are nonzero and the first is in the same ray as the\nnegation of the second, if and only if they are not linearly independent. -/\ntheorem sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y ∨ x ≠ 0 ∧ y ≠ 0 ∧ SameRay R x (-y) ↔\n      ¬LinearIndependent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  rw [← sameRay_or_sameRay_neg_iff_not_linearIndependent]\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0 <;> simp [hx, hy]\n#align same_ray_or_ne_zero_and_same_ray_neg_iff_not_linear_independent sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent\n-/\n\n",
 "sameRay_of_mem_orbit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_of_mem_orbit /-\n/-- `same_ray` follows from membership of `mul_action.orbit` for the `units.pos_subgroup`. -/\ntheorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit (Units.posSubgroup R) v₂) : SameRay R v₁ v₂ :=\n  by\n  rcases h with ⟨⟨r, hr : 0 < (r : R)⟩, rfl : «expr • » r v₂ = v₁⟩\n  exact SameRay.sameRay_pos_smul_left _ hr\n#align same_ray_of_mem_orbit sameRay_of_mem_orbit\n-/\n\n",
 "sameRay_neg_swap":
 "#print sameRay_neg_swap /-\ntheorem sameRay_neg_swap : SameRay R (-x) y ↔ SameRay R x (-y) := by rw [← sameRay_neg_iff, neg_neg]\n#align same_ray_neg_swap sameRay_neg_swap\n-/\n\n",
 "sameRay_neg_smul_right_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_neg_smul_right_iff_of_ne /-\ntheorem sameRay_neg_smul_right_iff_of_ne {v : M} {r : R} (hv : v ≠ 0) (hr : r ≠ 0) :\n    SameRay R (-v) («expr • » r v) ↔ r < 0 := by simp only [sameRay_neg_smul_right_iff, hv, or_false_iff, hr.le_iff_lt]\n#align same_ray_neg_smul_right_iff_of_ne sameRay_neg_smul_right_iff_of_ne\n-/\n\n",
 "sameRay_neg_smul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_neg_smul_right_iff /-\n@[simp]\ntheorem sameRay_neg_smul_right_iff {v : M} {r : R} : SameRay R (-v) («expr • » r v) ↔ r ≤ 0 ∨ v = 0 := by\n  rw [← sameRay_neg_iff, neg_neg, ← neg_smul, sameRay_smul_right_iff, neg_nonneg]\n#align same_ray_neg_smul_right_iff sameRay_neg_smul_right_iff\n-/\n\n",
 "sameRay_neg_smul_left_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_neg_smul_left_iff_of_ne /-\ntheorem sameRay_neg_smul_left_iff_of_ne {v : M} {r : R} (hv : v ≠ 0) (hr : r ≠ 0) :\n    SameRay R («expr • » r v) (-v) ↔ r < 0 :=\n  SameRay.sameRay_comm.trans <| sameRay_neg_smul_right_iff_of_ne hv hr\n#align same_ray_neg_smul_left_iff_of_ne sameRay_neg_smul_left_iff_of_ne\n-/\n\n",
 "sameRay_neg_smul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print sameRay_neg_smul_left_iff /-\n@[simp]\ntheorem sameRay_neg_smul_left_iff {v : M} {r : R} : SameRay R («expr • » r v) (-v) ↔ r ≤ 0 ∨ v = 0 :=\n  SameRay.sameRay_comm.trans sameRay_neg_smul_right_iff\n#align same_ray_neg_smul_left_iff sameRay_neg_smul_left_iff\n-/\n\n",
 "sameRay_neg_iff":
 "#print sameRay_neg_iff /-\n/-- `same_ray.neg` as an `iff`. -/\n@[simp]\ntheorem sameRay_neg_iff : SameRay R (-x) (-y) ↔ SameRay R x y := by simp only [SameRay, neg_eq_zero, smul_neg, neg_inj]\n#align same_ray_neg_iff sameRay_neg_iff\n-/\n\n",
 "rfl":
 "#print rfl /-\nprotected theorem rfl : SameRay R x x :=\n  refl _\n#align rfl rfl\n-/\n\n",
 "refl":
 "#print refl /-\n/-- `same_ray` is reflexive. -/\n@[refl]\ntheorem refl (x : M) : SameRay R x x := by\n  nontriviality R\n  exact or.inr (or.inr <| ⟨1, 1, zero_lt_one, zero_lt_one, rfl⟩)\n#align refl refl\n-/\n\n",
 "ray_pos_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print ray_pos_smul /-\n/-- The ray given by a positive multiple of a nonzero vector. -/\n@[simp]\ntheorem ray_pos_smul {v : M} (h : v ≠ 0) {r : R} (hr : 0 < r) (hrv : «expr • » r v ≠ 0) :\n    rayOfNeZero R («expr • » r v) hrv = rayOfNeZero R v h :=\n  (ray_eq_iff _ _).2 <| SameRay.sameRay_pos_smul_left v hr\n#align ray_pos_smul ray_pos_smul\n-/\n\n",
 "ray_eq_iff":
 "#print ray_eq_iff /-\n/-- The rays given by two nonzero vectors are equal if and only if those vectors\nsatisfy `same_ray`. -/\ntheorem ray_eq_iff {v₁ v₂ : M} (hv₁ : v₁ ≠ 0) (hv₂ : v₂ ≠ 0) :\n    rayOfNeZero R _ hv₁ = rayOfNeZero R _ hv₂ ↔ SameRay R v₁ v₂ :=\n  Quotient.eq'\n#align ray_eq_iff ray_eq_iff\n-/\n\n",
 "pos_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector is in the same ray as a positive multiple of one it is in the same ray as. -/\ntheorem pos_smul_right {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R x («expr • » r y) :=\n  h.nonneg_smul_right hr.le\n#align pos_smul_right pos_smul_right\n\n",
 "pos_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A positive multiple of a vector is in the same ray as one it is in the same ray as. -/\ntheorem pos_smul_left {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R («expr • » r x) y :=\n  h.nonneg_smul_left hr.le\n#align pos_smul_left pos_smul_left\n\n",
 "of_subsingleton'":
 "@[nontriviality]\ntheorem of_subsingleton' [subsingleton R] (x y : M) : SameRay R x y :=\n  haveI := Module.subsingleton R M\n  of_subsingleton x y\n#align of_subsingleton' of_subsingleton'\n\n",
 "of_subsingleton":
 "@[nontriviality]\ntheorem of_subsingleton [subsingleton M] (x y : M) : SameRay R x y :=\n  by\n  rw [subsingleton.elim x 0]\n  exact zero_left _\n#align of_subsingleton of_subsingleton\n\n",
 "nonneg_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector is in the same ray as a nonnegative multiple of one it is in the same ray as. -/\ntheorem nonneg_smul_right {r : R} (h : SameRay R x y) (hr : 0 ≤ r) : SameRay R x («expr • » r y) :=\n  h.trans (SameRay.sameRay_nonneg_smul_right y hr) fun hy => or.inr <| by rw [hy, smul_zero]\n#align nonneg_smul_right nonneg_smul_right\n\n",
 "nonneg_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A nonnegative multiple of a vector is in the same ray as one it is in the same ray as. -/\ntheorem nonneg_smul_left {r : R} (h : SameRay R x y) (hr : 0 ≤ r) : SameRay R («expr • » r x) y :=\n  (h.symm.nonneg_smul_right hr).symm\n#align nonneg_smul_left nonneg_smul_left\n\n",
 "neg_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem neg_units_smul (u : «expr ˣ» R) (v : Module.Ray R M) : «expr • » (-u) v = -«expr • » u v :=\n  by\n  induction v using Module.Ray.ind\n  simp only [smul_rayOfNeZero, Units.smul_def, Units.val_neg, neg_smul, neg_rayOfNeZero]\n#align neg_units_smul neg_units_smul\n\n",
 "neg_rayOfNeZero":
 "#print neg_rayOfNeZero /-\n/-- The ray given by the negation of a nonzero vector. -/\n@[simp]\ntheorem neg_rayOfNeZero (v : M) (h : v ≠ 0) : -rayOfNeZero R _ h = rayOfNeZero R (-v) (neg_ne_zero.2 h) :=\n  rfl\n#align neg_ray_of_ne_zero neg_rayOfNeZero\n-/\n\n",
 "ne_neg_self":
 "/-- A ray does not equal its own negation. -/\ntheorem ne_neg_self [NoZeroSMulDivisors R M] (x : Module.Ray R M) : x ≠ -x :=\n  by\n  induction' x using Module.Ray.ind with x hx\n  rw [neg_rayOfNeZero, ne.def, ray_eq_iff]\n  exact mt eq_zero_of_sameRay_self_neg hx\n#align ne_neg_self ne_neg_self\n\n",
 "map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Module.Ray.map_symm /-\n@[simp]\ntheorem Module.Ray.map_symm (e : «expr ≃ₗ[ ] » M R N) : (Module.Ray.map e).symm = Module.Ray.map e.symm :=\n  rfl\n#align module.ray.map_symm Module.Ray.map_symm\n-/\n\n",
 "map_refl":
 "#print Module.Ray.map_refl /-\n@[simp]\ntheorem Module.Ray.map_refl : (Module.Ray.map <| LinearEquiv.refl R M) = Equiv.refl _ :=\n  Equiv.ext <| Module.Ray.ind R fun _ _ => rfl\n#align module.ray.map_refl Module.Ray.map_refl\n-/\n\n",
 "map_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print map_neg /-\n@[simp]\nprotected theorem map_neg (f : «expr ≃ₗ[ ] » M R N) (v : Module.Ray R M) : map f (-v) = -map f v :=\n  by\n  induction' v using Module.Ray.ind with g hg\n  simp\n#align map_neg map_neg\n-/\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print Module.Ray.map_apply /-\n@[simp]\ntheorem Module.Ray.map_apply (e : «expr ≃ₗ[ ] » M R N) (v : M) (hv : v ≠ 0) :\n    Module.Ray.map e (rayOfNeZero _ v hv) = rayOfNeZero _ (e v) (e.map_ne_zero_iff.2 hv) :=\n  rfl\n#align module.ray.map_apply Module.Ray.map_apply\n-/\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If two vectors are on the same ray then they remain so after applying a linear map. -/\ntheorem map (f : «expr →ₗ[ ] » M R N) (h : SameRay R x y) : SameRay R (f x) (f y) :=\n  (h.imp fun hx => by rw [hx, map_zero]) <|\n    Or.imp (fun hy => by rw [hy, map_zero]) fun ⟨r₁, r₂, hr₁, hr₂, h⟩ =>\n      ⟨r₁, r₂, hr₁, hr₂, by rw [← f.map_smul, ← f.map_smul, h]⟩\n#align map map\n\n",
 "linearEquiv_smul_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Module.Ray.linearEquiv_smul_eq_map /-\n/-- The action via `linear_equiv.apply_distrib_mul_action` corresponds to `module.ray.map`. -/\n@[simp]\ntheorem Module.Ray.linearEquiv_smul_eq_map (e : «expr ≃ₗ[ ] » M R M) (v : Module.Ray R M) :\n    «expr • » e v = Module.Ray.map e v :=\n  rfl\n#align module.ray.linear_equiv_smul_eq_map Module.Ray.linearEquiv_smul_eq_map\n-/\n\n",
 "ind":
 "#print Module.Ray.ind /-\n/-- An induction principle for `module.ray`, used as `induction x using module.ray.ind`. -/\ntheorem Module.Ray.ind {C : Module.Ray R M → Prop} (h : ∀ (v) (hv : v ≠ 0), C (rayOfNeZero R v hv))\n    (x : Module.Ray R M) : C x :=\n  quotient.ind (subtype.rec <| h) x\n#align module.ray.ind Module.Ray.ind\n-/\n\n",
 "exists_pos_right_iff_sameRay_and_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_pos_right_iff_sameRay_and_ne_zero /-\ntheorem exists_pos_right_iff_sameRay_and_ne_zero (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ x = «expr • » r y) ↔ SameRay R x y ∧ x ≠ 0 := by\n  simpa only [SameRay.sameRay_comm, eq_comm] using exists_pos_left_iff_sameRay_and_ne_zero hy\n#align exists_pos_right_iff_same_ray_and_ne_zero exists_pos_right_iff_sameRay_and_ne_zero\n-/\n\n",
 "exists_pos_right_iff_sameRay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_pos_right_iff_sameRay /-\ntheorem exists_pos_right_iff_sameRay (hx : x ≠ 0) (hy : y ≠ 0) : (∃ r : R, 0 < r ∧ x = «expr • » r y) ↔ SameRay R x y :=\n  by simpa only [SameRay.sameRay_comm, eq_comm] using exists_pos_left_iff_sameRay hy hx\n#align exists_pos_right_iff_same_ray exists_pos_right_iff_sameRay\n-/\n\n",
 "exists_pos_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_right (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ r : R, 0 < r ∧ x = «expr • » r y :=\n  (h.symm.exists_pos_left hy hx).imp fun _ => And.imp_right Eq.symm\n#align exists_pos_right exists_pos_right\n\n",
 "exists_pos_left_iff_sameRay_and_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_pos_left_iff_sameRay_and_ne_zero /-\ntheorem exists_pos_left_iff_sameRay_and_ne_zero (hx : x ≠ 0) :\n    (∃ r : R, 0 < r ∧ «expr • » r x = y) ↔ SameRay R x y ∧ y ≠ 0 :=\n  by\n  constructor\n  · rintro ⟨r, hr, rfl⟩\n    simp [hx, hr.le, hr.ne']\n  · rintro ⟨hxy, hy⟩\n    exact (exists_pos_left_iff_sameRay hx hy).2 hxy\n#align exists_pos_left_iff_same_ray_and_ne_zero exists_pos_left_iff_sameRay_and_ne_zero\n-/\n\n",
 "exists_pos_left_iff_sameRay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_pos_left_iff_sameRay /-\ntheorem exists_pos_left_iff_sameRay (hx : x ≠ 0) (hy : y ≠ 0) : (∃ r : R, 0 < r ∧ «expr • » r x = y) ↔ SameRay R x y :=\n  by\n  refine' ⟨fun h => _, fun h => h.exists_pos_left hx hy⟩\n  rcases h with ⟨r, hr, rfl⟩\n  exact SameRay.sameRay_pos_smul_right x hr\n#align exists_pos_left_iff_same_ray exists_pos_left_iff_sameRay\n-/\n\n",
 "exists_pos_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_left (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ r : R, 0 < r ∧ «expr • » r x = y :=\n  let ⟨r₁, r₂, hr₁, hr₂, h⟩ := h.exists_pos hx hy\n  ⟨r₂⁻¹ * r₁, mul_pos (inv_pos.2 hr₂) hr₁, by rw [mul_smul, h, inv_smul_smul₀ hr₂.ne']⟩\n#align exists_pos_left exists_pos_left\n\n",
 "exists_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem exists_pos (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ r₁ r₂ : R, 0 < r₁ ∧ 0 < r₂ ∧ «expr • » r₁ x = «expr • » r₂ y :=\n  (h.resolve_left hx).resolve_left hy\n#align exists_pos exists_pos\n\n",
 "exists_nonneg_right_iff_sameRay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_nonneg_right_iff_sameRay /-\ntheorem exists_nonneg_right_iff_sameRay (hy : y ≠ 0) : (∃ r : R, 0 ≤ r ∧ x = «expr • » r y) ↔ SameRay R x y := by\n  simpa only [SameRay.sameRay_comm, eq_comm] using exists_nonneg_left_iff_sameRay hy\n#align exists_nonneg_right_iff_same_ray exists_nonneg_right_iff_sameRay\n-/\n\n",
 "exists_nonneg_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a vector `v₁` is on the same ray as a nonzero vector `v₂`, then it is equal to `c • v₂` for\nsome nonnegative `c`. -/\ntheorem exists_nonneg_right (h : SameRay R x y) (hy : y ≠ 0) : ∃ r : R, 0 ≤ r ∧ x = «expr • » r y :=\n  (h.symm.exists_nonneg_left hy).imp fun _ => And.imp_right Eq.symm\n#align exists_nonneg_right exists_nonneg_right\n\n",
 "exists_nonneg_left_iff_sameRay":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print exists_nonneg_left_iff_sameRay /-\ntheorem exists_nonneg_left_iff_sameRay (hx : x ≠ 0) : (∃ r : R, 0 ≤ r ∧ «expr • » r x = y) ↔ SameRay R x y :=\n  by\n  refine' ⟨fun h => _, fun h => h.exists_nonneg_left hx⟩\n  rcases h with ⟨r, hr, rfl⟩\n  exact SameRay.sameRay_nonneg_smul_right x hr\n#align exists_nonneg_left_iff_same_ray exists_nonneg_left_iff_sameRay\n-/\n\n",
 "exists_nonneg_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a vector `v₂` is on the same ray as a nonzero vector `v₁`, then it is equal to `c • v₁` for\nsome nonnegative `c`. -/\ntheorem exists_nonneg_left (h : SameRay R x y) (hx : x ≠ 0) : ∃ r : R, 0 ≤ r ∧ «expr • » r x = y :=\n  by\n  obtain rfl | hy := eq_or_ne y 0\n  · exact ⟨0, le_rfl, zero_smul _ _⟩\n  · exact (h.exists_pos_left hx hy).imp fun _ => And.imp_left le_of_lt\n#align exists_nonneg_left exists_nonneg_left\n\n",
 "exists_eq_smul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If vectors `v₁` and `v₂` are on the same ray, then for some nonnegative `a b`, `a + b = 1`, we\nhave `v₁ = a • (v₁ + v₂)` and `v₂ = b • (v₁ + v₂)`. -/\ntheorem exists_eq_smul_add (h : SameRay R v₁ v₂) :\n    ∃ a b : R, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = «expr • » a (v₁ + v₂) ∧ v₂ = «expr • » b (v₁ + v₂) :=\n  by\n  rcases h with (rfl | rfl | ⟨r₁, r₂, h₁, h₂, H⟩)\n  · use 0, 1\n    simp\n  · use 1, 0\n    simp\n  · have h₁₂ : 0 < r₁ + r₂ := add_pos h₁ h₂\n    refine' ⟨r₂ / (r₁ + r₂), r₁ / (r₁ + r₂), div_nonneg h₂.le h₁₂.le, div_nonneg h₁.le h₁₂.le, _, _, _⟩\n    · rw [← add_div, add_comm, div_self h₁₂.ne']\n    · rw [div_eq_inv_mul, mul_smul, smul_add, ← H, ← add_smul, add_comm r₂, inv_smul_smul₀ h₁₂.ne']\n    · rw [div_eq_inv_mul, mul_smul, smul_add, H, ← add_smul, add_comm r₂, inv_smul_smul₀ h₁₂.ne']\n#align exists_eq_smul_add exists_eq_smul_add\n\n",
 "exists_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If vectors `v₁` and `v₂` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `v₁ + v₂`, see `same_ray.exists_eq_smul_add`. -/\ntheorem exists_eq_smul (h : SameRay R v₁ v₂) :\n    ∃ (u : M)(a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = «expr • » a u ∧ v₂ = «expr • » b u :=\n  ⟨v₁ + v₂, h.exists_eq_smul_add⟩\n#align exists_eq_smul exists_eq_smul\n\n",
 "equiv_neg_iff":
 "/-- If two nonzero vectors are equivalent, so are their negations. -/\n@[simp]\ntheorem equiv_neg_iff {v₁ v₂ : RayVector R M} : -v₁ ≈ -v₂ ↔ v₁ ≈ v₂ :=\n  sameRay_neg_iff\n#align equiv_neg_iff equiv_neg_iff\n\n",
 "equiv_iff_sameRay":
 "#print equiv_iff_sameRay /-\n/-- Equivalence of nonzero vectors, in terms of same_ray. -/\ntheorem equiv_iff_sameRay {v₁ v₂ : RayVector R M} : v₁ ≈ v₂ ↔ SameRay R (v₁ : M) v₂ :=\n  iff.rfl\n#align equiv_iff_same_ray equiv_iff_sameRay\n-/\n\n",
 "eq_zero_of_sameRay_self_neg":
 "#print eq_zero_of_sameRay_self_neg /-\n/-- If a vector is in the same ray as its negation, that vector is zero. -/\ntheorem eq_zero_of_sameRay_self_neg [NoZeroSMulDivisors R M] (h : SameRay R x (-x)) : x = 0 :=\n  by\n  nontriviality M; haveI : Nontrivial R := Module.nontrivial R M\n  refine' eq_zero_of_sameRay_neg_smul_right (neg_lt_zero.2 (zero_lt_one' R)) _\n  rwa [neg_one_smul]\n#align eq_zero_of_same_ray_self_neg eq_zero_of_sameRay_self_neg\n-/\n\n",
 "eq_zero_of_sameRay_neg_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print eq_zero_of_sameRay_neg_smul_right /-\ntheorem eq_zero_of_sameRay_neg_smul_right [NoZeroSMulDivisors R M] {r : R} (hr : r < 0)\n    (h : SameRay R x («expr • » r x)) : x = 0 :=\n  by\n  rcases h with (rfl | h₀ | ⟨r₁, r₂, hr₁, hr₂, h⟩)\n  · rfl\n  · simpa [hr.ne] using h₀\n  · rw [← sub_eq_zero, smul_smul, ← sub_smul, smul_eq_zero] at h\n    refine' h.resolve_left (ne_of_gt <| sub_pos.2 _)\n    exact (mul_neg_of_pos_of_neg hr₂ hr).trans hr₁\n#align eq_zero_of_same_ray_neg_smul_right eq_zero_of_sameRay_neg_smul_right\n-/\n\n",
 "coe_neg":
 "/-- Negating a nonzero vector commutes with coercion to the underlying module. -/\n@[simp, norm_cast]\ntheorem coe_neg {R : Type _} (v : RayVector R M) : ↑(-v) = -(v : M) :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "add_right":
 "/-- If `y` and `z` are on the same ray as `x`, then so is `y + z`. -/\ntheorem add_right (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z) :=\n  (hy.symm.add_left hz.symm).symm\n#align add_right add_right\n\n",
 "add_left":
 "/-- If `x` and `y` are on the same ray as `z`, then so is `x + y`. -/\ntheorem add_left (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx₀); · rwa [zero_add]\n  rcases eq_or_ne y 0 with (rfl | hy₀); · rwa [add_zero]\n  rcases eq_or_ne z 0 with (rfl | hz₀); · apply zero_right\n  rcases hx.exists_pos hx₀ hz₀ with ⟨rx, rz₁, hrx, hrz₁, Hx⟩\n  rcases hy.exists_pos hy₀ hz₀ with ⟨ry, rz₂, hry, hrz₂, Hy⟩\n  refine' or.inr (or.inr ⟨rx * ry, ry * rz₁ + rx * rz₂, mul_pos hrx hry, _, _⟩)\n  · apply_rules [add_pos, mul_pos]\n  · simp only [mul_smul, smul_add, add_smul, ← Hx, ← Hy]\n    rw [smul_comm]\n#align add_left add_left\n\n"}