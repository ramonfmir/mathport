{"zero_right":
 "@[simp]\ntheorem zero_right (x : M) : same_ray R x 0 :=\n  or.inr <| or.inl rfl\n#align zero_right zero_right\n\n",
 "zero_left":
 "/-\nCopyright (c) 2021 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\n@[simp]\ntheorem zero_left (y : M) : same_ray R 0 y :=\n  or.inl rfl\n#align zero_left zero_left\n\n",
 "units_smul_of_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scaling by a positive unit is a no-op. -/\ntheorem units_smul_of_pos (u : «expr ˣ» R) (hu : 0 < (u : R)) (v : module.ray R M) : «expr • » u v = v :=\n  by\n  induction v using module.ray.ind\n  rw [smul_ray_of_ne_zero, ray_eq_iff]\n  exact same_ray_pos_smul_left _ hu\n#align units_smul_of_pos units_smul_of_pos\n\n",
 "units_smul_of_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scaling by a negative unit is negation. -/\ntheorem units_smul_of_neg (u : «expr ˣ» R) (hu : (u : R) < 0) (v : module.ray R M) : «expr • » u v = -v :=\n  by\n  rw [← neg_inj, neg_neg, ← neg_units_smul, units_smul_of_pos]\n  rwa [Units.val_neg, right.neg_pos_iff]\n#align units_smul_of_neg units_smul_of_neg\n\n",
 "units_smul_eq_self_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem units_smul_eq_self_iff {u : «expr ˣ» R} {v : module.ray R M} : «expr • » u v = v ↔ (0 : R) < u :=\n  by\n  induction' v using module.ray.ind with v hv\n  simp only [smul_ray_of_ne_zero, ray_eq_iff, Units.smul_def, same_ray_smul_left_iff_of_ne hv u.ne_zero]\n#align units_smul_eq_self_iff units_smul_eq_self_iff\n\n",
 "units_smul_eq_neg_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem units_smul_eq_neg_iff {u : «expr ˣ» R} {v : module.ray R M} : «expr • » u v = -v ↔ ↑u < (0 : R) := by\n  rw [← neg_inj, neg_neg, ← module.ray.neg_units_smul, units_smul_eq_self_iff, Units.val_neg, neg_pos]\n#align units_smul_eq_neg_iff units_smul_eq_neg_iff\n\n",
 "units_inv_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Scaling by an inverse unit is the same as scaling by itself. -/\n@[simp]\ntheorem units_inv_smul (u : «expr ˣ» R) (v : module.ray R M) : «expr • » u⁻¹ v = «expr • » u v :=\n  calc\n    «expr • » u⁻¹ v = «expr • » (u * u) («expr • » u⁻¹ v) :=\n      eq.symm <| («expr • » u⁻¹ v).units_smul_of_pos _ <| mul_self_pos.2 u.ne_zero\n    _ = «expr • » u v := by rw [mul_smul, smul_inv_smul]\n    \n#align units_inv_smul units_inv_smul\n\n",
 "trans":
 "#print trans /-\n/-- `same_ray` is transitive unless the vector in the middle is zero and both other vectors are\nnonzero. -/\ntheorem trans (hxy : same_ray R x y) (hyz : same_ray R y z) (hy : y = 0 → x = 0 ∨ z = 0) : same_ray R x z :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx); · exact zero_left z\n  rcases eq_or_ne z 0 with (rfl | hz); · exact zero_right x\n  rcases eq_or_ne y 0 with (rfl | hy); · exact (hy rfl).elim (fun h => (hx h).elim) fun h => (hz h).elim\n  rcases hxy.exists_pos hx hy with ⟨r₁, r₂, hr₁, hr₂, h₁⟩\n  rcases hyz.exists_pos hy hz with ⟨r₃, r₄, hr₃, hr₄, h₂⟩\n  refine' or.inr (or.inr <| ⟨r₃ * r₁, r₂ * r₄, mul_pos hr₃ hr₁, mul_pos hr₂ hr₄, _⟩)\n  rw [mul_smul, mul_smul, h₁, ← h₂, smul_comm]\n#align trans trans\n-/\n\n",
 "symm":
 "#print symm /-\n/-- `same_ray` is symmetric. -/\n@[symm]\ntheorem symm (h : same_ray R x y) : same_ray R y x :=\n  (or_left_comm.1 h).imp_right <| or.imp_right fun ⟨r₁, r₂, h₁, h₂, h⟩ => ⟨r₂, r₁, h₂, h₁, h.symm⟩\n#align symm symm\n-/\n\n",
 "some_vector_ray":
 "/-- The ray of `some_vector`. -/\n@[simp]\ntheorem some_vector_ray (x : module.ray R M) : ray_of_ne_zero R _ x.some_vector_ne_zero = x :=\n  (congr_arg _ (subtype.coe_eta _ _) : _).trans x.out_eq\n#align some_vector_ray some_vector_ray\n\n",
 "some_vector_ne_zero":
 "/-- `some_vector` is nonzero. -/\n@[simp]\ntheorem some_vector_ne_zero (x : module.ray R M) : x.some_vector ≠ 0 :=\n  x.some_ray_vector.property\n#align some_vector_ne_zero some_vector_ne_zero\n\n",
 "some_ray_vector_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⟦ ⟧» -/\n/-- The ray of `some_ray_vector`. -/\n@[simp]\ntheorem some_ray_vector_ray (x : module.ray R M) : («expr⟦ ⟧» x.some_ray_vector : module.ray R M) = x :=\n  quotient.out_eq _\n#align some_ray_vector_ray some_ray_vector_ray\n\n",
 "smul_ray_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_ray_of_ne_zero (g : G) (v : M) (hv) :\n    «expr • » g (ray_of_ne_zero R v hv) = ray_of_ne_zero R («expr • » g v) ((smul_ne_zero_iff_ne _).2 hv) :=\n  rfl\n#align smul_ray_of_ne_zero smul_ray_of_ne_zero\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If two vectors are on the same ray then both scaled by the same action are also on the same\nray. -/\ntheorem smul {S : Type _} [monoid S] [DistribMulAction S M] [SMulCommClass R S M] (h : same_ray R x y) (s : S) :\n    same_ray R («expr • » s x) («expr • » s y) :=\n  h.map («expr • » s (linear_map.id : «expr →ₗ[ ] » M R M))\n#align smul smul\n\n",
 "same_ray_smul_right_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A nonzero vector is in the same ray as a multiple of itself if and only if that multiple\nis positive. -/\ntheorem same_ray_smul_right_iff_of_ne {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) :\n    same_ray R v («expr • » r v) ↔ 0 < r := by simp only [same_ray_smul_right_iff, hv, or_false_iff, hr.symm.le_iff_lt]\n#align same_ray_smul_right_iff_of_ne same_ray_smul_right_iff_of_ne\n\n",
 "same_ray_smul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem same_ray_smul_right_iff {v : M} {r : R} : same_ray R v («expr • » r v) ↔ 0 ≤ r ∨ v = 0 :=\n  ⟨fun hrv => or_iff_not_imp_left.2 fun hr => eq_zero_of_same_ray_neg_smul_right (not_le.1 hr) hrv,\n    or_imp.2 ⟨same_ray_nonneg_smul_right v, fun h => h.symm ▸ same_ray.zero_left _⟩⟩\n#align same_ray_smul_right_iff same_ray_smul_right_iff\n\n",
 "same_ray_smul_left_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A multiple of a nonzero vector is in the same ray as that vector if and only if that multiple\nis positive. -/\ntheorem same_ray_smul_left_iff_of_ne {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) : same_ray R («expr • » r v) v ↔ 0 < r :=\n  same_ray_comm.trans (same_ray_smul_right_iff_of_ne hv hr)\n#align same_ray_smul_left_iff_of_ne same_ray_smul_left_iff_of_ne\n\n",
 "same_ray_smul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem same_ray_smul_left_iff {v : M} {r : R} : same_ray R («expr • » r v) v ↔ 0 ≤ r ∨ v = 0 :=\n  same_ray_comm.trans same_ray_smul_right_iff\n#align same_ray_smul_left_iff same_ray_smul_left_iff\n\n",
 "same_ray_pos_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector is in the same ray as a positive multiple of itself. -/\ntheorem _root_.same_ray_pos_smul_right (v : M) {r : R} (h : 0 < r) : same_ray R v («expr • » r v) :=\n  same_ray_nonneg_smul_right v h.le\n#align same_ray_pos_smul_right same_ray_pos_smul_right\n\n",
 "same_ray_pos_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A positive multiple of a vector is in the same ray as that vector. -/\ntheorem _root_.same_ray_pos_smul_left (v : M) {r : R} (h : 0 < r) : same_ray R («expr • » r v) v :=\n  same_ray_nonneg_smul_left v h.le\n#align same_ray_pos_smul_left same_ray_pos_smul_left\n\n",
 "same_ray_or_same_ray_neg_iff_not_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Two vectors are in the same ray, or the first is in the same ray as the negation of the\nsecond, if and only if they are not linearly independent. -/\ntheorem same_ray_or_same_ray_neg_iff_not_linear_independent {x y : M} :\n    same_ray R x y ∨ same_ray R x (-y) ↔\n      ¬linear_independent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  by_cases hx : x = 0;\n  ·\n    simp [hx,\n      fun h :\n        linear_independent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") =>\n      h.ne_zero 0 rfl]\n  by_cases hy : y = 0;\n  ·\n    simp [hy,\n      fun h :\n        linear_independent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") =>\n      h.ne_zero 1 rfl]\n  simp_rw [fintype.not_linear_independent_iff, fin.sum_univ_two, Fin.exists_fin_two]\n  refine' ⟨fun h => _, fun h => _⟩\n  · rcases h with ((hx0 | hy0 | ⟨r₁, r₂, hr₁, hr₂, h⟩) | (hx0 | hy0 | ⟨r₁, r₂, hr₁, hr₂, h⟩))\n    · exact false.elim (hx hx0)\n    · exact false.elim (hy hy0)\n    · refine' ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", _⟩\n      simp [h, hr₁.ne.symm]\n    · exact false.elim (hx hx0)\n    · exact false.elim (hy (neg_eq_zero.1 hy0))\n    · refine' ⟨«expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\", _⟩\n      simp [h, hr₁.ne.symm]\n  · rcases h with ⟨m, hm, hmne⟩\n    change «expr • » (m 0) x + «expr • » (m 1) y = 0 at hm\n    rw [add_eq_zero_iff_eq_neg] at hm\n    rcases lt_trichotomy (m 0) 0 with (hm0 | hm0 | hm0) <;> rcases lt_trichotomy (m 1) 0 with (hm1 | hm1 | hm1)\n    · refine' or.inr (or.inr (or.inr ⟨-m 0, -m 1, left.neg_pos_iff.2 hm0, left.neg_pos_iff.2 hm1, _⟩))\n      simp [hm]\n    · exfalso\n      simpa [hm1, hx, hm0.ne] using hm\n    · refine' or.inl (or.inr (or.inr ⟨-m 0, m 1, left.neg_pos_iff.2 hm0, hm1, _⟩))\n      simp [hm]\n    · exfalso\n      simpa [hm0, hy, hm1.ne] using hm\n    · refine' false.elim (not_and_or.2 hmne ⟨hm0, hm1⟩)\n    · exfalso\n      simpa [hm0, hy, hm1.ne.symm] using hm\n    · refine' or.inl (or.inr (or.inr ⟨m 0, -m 1, hm0, left.neg_pos_iff.2 hm1, _⟩))\n      simp [hm]\n    · exfalso\n      simpa [hm1, hx, hm0.ne.symm] using hm\n    · refine' or.inr (or.inr (or.inr ⟨m 0, m 1, hm0, hm1, _⟩))\n      simp [hm]\n#align same_ray_or_same_ray_neg_iff_not_linear_independent same_ray_or_same_ray_neg_iff_not_linear_independent\n\n",
 "same_ray_or_ne_zero_and_same_ray_neg_iff_not_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- Two vectors are in the same ray, or they are nonzero and the first is in the same ray as the\nnegation of the second, if and only if they are not linearly independent. -/\ntheorem same_ray_or_ne_zero_and_same_ray_neg_iff_not_linear_independent {x y : M} :\n    same_ray R x y ∨ x ≠ 0 ∧ y ≠ 0 ∧ same_ray R x (-y) ↔\n      ¬linear_independent R\n          («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") :=\n  by\n  rw [← same_ray_or_same_ray_neg_iff_not_linear_independent]\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0 <;> simp [hx, hy]\n#align\n  same_ray_or_ne_zero_and_same_ray_neg_iff_not_linear_independent same_ray_or_ne_zero_and_same_ray_neg_iff_not_linear_independent\n\n",
 "same_ray_of_mem_orbit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `same_ray` follows from membership of `mul_action.orbit` for the `units.pos_subgroup`. -/\ntheorem same_ray_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ mul_action.orbit (units.pos_subgroup R) v₂) : same_ray R v₁ v₂ :=\n  by\n  rcases h with ⟨⟨r, hr : 0 < (r : R)⟩, rfl : «expr • » r v₂ = v₁⟩\n  exact same_ray_pos_smul_left _ hr\n#align same_ray_of_mem_orbit same_ray_of_mem_orbit\n\n",
 "same_ray_nonneg_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector is in the same ray as a nonnegative multiple of itself. -/\ntheorem _root_.same_ray_nonneg_smul_right (v : M) {r : R} (h : 0 ≤ r) : same_ray R v («expr • » r v) :=\n  or.inr <|\n    h.eq_or_lt.imp (fun h => h ▸ zero_smul R v) fun h =>\n      ⟨r, 1, h, by\n        nontriviality R\n        exact zero_lt_one, (one_smul _ _).symm⟩\n#align same_ray_nonneg_smul_right same_ray_nonneg_smul_right\n\n",
 "same_ray_nonneg_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A nonnegative multiple of a vector is in the same ray as that vector. -/\ntheorem _root_.same_ray_nonneg_smul_left (v : M) {r : R} (h : 0 ≤ r) : same_ray R («expr • » r v) v :=\n  (same_ray_nonneg_smul_right v h).symm\n#align same_ray_nonneg_smul_left same_ray_nonneg_smul_left\n\n",
 "same_ray_neg_swap":
 "theorem same_ray_neg_swap : same_ray R (-x) y ↔ same_ray R x (-y) := by rw [← same_ray_neg_iff, neg_neg]\n#align same_ray_neg_swap same_ray_neg_swap\n\n",
 "same_ray_neg_smul_right_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem same_ray_neg_smul_right_iff_of_ne {v : M} {r : R} (hv : v ≠ 0) (hr : r ≠ 0) :\n    same_ray R (-v) («expr • » r v) ↔ r < 0 := by\n  simp only [same_ray_neg_smul_right_iff, hv, or_false_iff, hr.le_iff_lt]\n#align same_ray_neg_smul_right_iff_of_ne same_ray_neg_smul_right_iff_of_ne\n\n",
 "same_ray_neg_smul_right_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem same_ray_neg_smul_right_iff {v : M} {r : R} : same_ray R (-v) («expr • » r v) ↔ r ≤ 0 ∨ v = 0 := by\n  rw [← same_ray_neg_iff, neg_neg, ← neg_smul, same_ray_smul_right_iff, neg_nonneg]\n#align same_ray_neg_smul_right_iff same_ray_neg_smul_right_iff\n\n",
 "same_ray_neg_smul_left_iff_of_ne":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem same_ray_neg_smul_left_iff_of_ne {v : M} {r : R} (hv : v ≠ 0) (hr : r ≠ 0) :\n    same_ray R («expr • » r v) (-v) ↔ r < 0 :=\n  same_ray_comm.trans <| same_ray_neg_smul_right_iff_of_ne hv hr\n#align same_ray_neg_smul_left_iff_of_ne same_ray_neg_smul_left_iff_of_ne\n\n",
 "same_ray_neg_smul_left_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem same_ray_neg_smul_left_iff {v : M} {r : R} : same_ray R («expr • » r v) (-v) ↔ r ≤ 0 ∨ v = 0 :=\n  same_ray_comm.trans same_ray_neg_smul_right_iff\n#align same_ray_neg_smul_left_iff same_ray_neg_smul_left_iff\n\n",
 "same_ray_neg_iff":
 "/-- `same_ray.neg` as an `iff`. -/\n@[simp]\ntheorem same_ray_neg_iff : same_ray R (-x) (-y) ↔ same_ray R x y := by\n  simp only [same_ray, neg_eq_zero, smul_neg, neg_inj]\n#align same_ray_neg_iff same_ray_neg_iff\n\n",
 "same_ray_map_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/-- The images of two vectors under a linear equivalence are on the same ray if and only if the\noriginal vectors are on the same ray. -/\n@[simp]\ntheorem _root_.same_ray_map_iff (e : «expr ≃ₗ[ ] » M R N) : same_ray R (e x) (e y) ↔ same_ray R x y :=\n  function.injective.same_ray_map_iff (equiv_like.injective e)\n#align same_ray_map_iff same_ray_map_iff\n\n",
 "same_ray_comm":
 "theorem _root_.same_ray_comm : same_ray R x y ↔ same_ray R y x :=\n  ⟨same_ray.symm, same_ray.symm⟩\n#align same_ray_comm same_ray_comm\n\n",
 "rfl":
 "#print rfl /-\nprotected theorem rfl : same_ray R x x :=\n  refl _\n#align rfl rfl\n-/\n\n",
 "refl":
 "#print refl /-\n/-- `same_ray` is reflexive. -/\n@[refl]\ntheorem refl (x : M) : same_ray R x x := by\n  nontriviality R\n  exact or.inr (or.inr <| ⟨1, 1, zero_lt_one, zero_lt_one, rfl⟩)\n#align refl refl\n-/\n\n",
 "ray_pos_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The ray given by a positive multiple of a nonzero vector. -/\n@[simp]\ntheorem ray_pos_smul {v : M} (h : v ≠ 0) {r : R} (hr : 0 < r) (hrv : «expr • » r v ≠ 0) :\n    ray_of_ne_zero R («expr • » r v) hrv = ray_of_ne_zero R v h :=\n  (ray_eq_iff _ _).2 <| same_ray_pos_smul_left v hr\n#align ray_pos_smul ray_pos_smul\n\n",
 "ray_eq_iff":
 "/-- The rays given by two nonzero vectors are equal if and only if those vectors\nsatisfy `same_ray`. -/\ntheorem ray_eq_iff {v₁ v₂ : M} (hv₁ : v₁ ≠ 0) (hv₂ : v₂ ≠ 0) :\n    ray_of_ne_zero R _ hv₁ = ray_of_ne_zero R _ hv₂ ↔ same_ray R v₁ v₂ :=\n  quotient.eq\n#align ray_eq_iff ray_eq_iff\n\n",
 "pos_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector is in the same ray as a positive multiple of one it is in the same ray as. -/\ntheorem pos_smul_right {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R x («expr • » r y) :=\n  h.nonneg_smul_right hr.le\n#align pos_smul_right pos_smul_right\n\n",
 "pos_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A positive multiple of a vector is in the same ray as one it is in the same ray as. -/\ntheorem pos_smul_left {r : R} (h : same_ray R x y) (hr : 0 < r) : same_ray R («expr • » r x) y :=\n  h.nonneg_smul_left hr.le\n#align pos_smul_left pos_smul_left\n\n",
 "of_subsingleton'":
 "@[nontriviality]\ntheorem of_subsingleton' [subsingleton R] (x y : M) : same_ray R x y :=\n  haveI := Module.subsingleton R M\n  of_subsingleton x y\n#align of_subsingleton' of_subsingleton'\n\n",
 "of_subsingleton":
 "@[nontriviality]\ntheorem of_subsingleton [subsingleton M] (x y : M) : same_ray R x y :=\n  by\n  rw [subsingleton.elim x 0]\n  exact zero_left _\n#align of_subsingleton of_subsingleton\n\n",
 "nonneg_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A vector is in the same ray as a nonnegative multiple of one it is in the same ray as. -/\ntheorem nonneg_smul_right {r : R} (h : same_ray R x y) (hr : 0 ≤ r) : same_ray R x («expr • » r y) :=\n  h.trans (same_ray_nonneg_smul_right y hr) fun hy => or.inr <| by rw [hy, smul_zero]\n#align nonneg_smul_right nonneg_smul_right\n\n",
 "nonneg_smul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A nonnegative multiple of a vector is in the same ray as one it is in the same ray as. -/\ntheorem nonneg_smul_left {r : R} (h : same_ray R x y) (hr : 0 ≤ r) : same_ray R («expr • » r x) y :=\n  (h.symm.nonneg_smul_right hr).symm\n#align nonneg_smul_left nonneg_smul_left\n\n",
 "neg_units_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem neg_units_smul (u : «expr ˣ» R) (v : module.ray R M) : «expr • » (-u) v = -«expr • » u v :=\n  by\n  induction v using module.ray.ind\n  simp only [smul_ray_of_ne_zero, Units.smul_def, Units.val_neg, neg_smul, neg_ray_of_ne_zero]\n#align neg_units_smul neg_units_smul\n\n",
 "neg_ray_of_ne_zero":
 "/-- The ray given by the negation of a nonzero vector. -/\n@[simp]\ntheorem neg_ray_of_ne_zero (v : M) (h : v ≠ 0) : -ray_of_ne_zero R _ h = ray_of_ne_zero R (-v) (neg_ne_zero.2 h) :=\n  rfl\n#align neg_ray_of_ne_zero neg_ray_of_ne_zero\n\n",
 "ne_neg_self":
 "/-- A ray does not equal its own negation. -/\ntheorem ne_neg_self [NoZeroSMulDivisors R M] (x : module.ray R M) : x ≠ -x :=\n  by\n  induction' x using module.ray.ind with x hx\n  rw [neg_ray_of_ne_zero, ne.def, ray_eq_iff]\n  exact mt eq_zero_of_same_ray_self_neg hx\n#align ne_neg_self ne_neg_self\n\n",
 "map_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem module.ray.map_symm (e : «expr ≃ₗ[ ] » M R N) : (module.ray.map e).symm = module.ray.map e.symm :=\n  rfl\n#align module.ray.map_symm module.ray.map_symm\n\n",
 "map_refl":
 "@[simp]\ntheorem module.ray.map_refl : (module.ray.map <| linear_equiv.refl R M) = equiv.refl _ :=\n  equiv.ext <| module.ray.ind R fun _ _ => rfl\n#align module.ray.map_refl module.ray.map_refl\n\n",
 "map_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n#print map_neg /-\n@[simp]\nprotected theorem map_neg (f : «expr ≃ₗ[ ] » M R N) (v : module.ray R M) : map f (-v) = -map f v :=\n  by\n  induction' v using module.ray.ind with g hg\n  simp\n#align map_neg map_neg\n-/\n\n",
 "map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem module.ray.map_apply (e : «expr ≃ₗ[ ] » M R N) (v : M) (hv : v ≠ 0) :\n    module.ray.map e (ray_of_ne_zero _ v hv) = ray_of_ne_zero _ (e v) (e.map_ne_zero_iff.2 hv) :=\n  rfl\n#align module.ray.map_apply module.ray.map_apply\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- If two vectors are on the same ray then they remain so after applying a linear map. -/\ntheorem map (f : «expr →ₗ[ ] » M R N) (h : same_ray R x y) : same_ray R (f x) (f y) :=\n  (h.imp fun hx => by rw [hx, map_zero]) <|\n    Or.imp (fun hy => by rw [hy, map_zero]) fun ⟨r₁, r₂, hr₁, hr₂, h⟩ =>\n      ⟨r₁, r₂, hr₁, hr₂, by rw [← f.map_smul, ← f.map_smul, h]⟩\n#align map map\n\n",
 "linear_equiv_smul_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- The action via `linear_equiv.apply_distrib_mul_action` corresponds to `module.ray.map`. -/\n@[simp]\ntheorem module.ray.linear_equiv_smul_eq_map (e : «expr ≃ₗ[ ] » M R M) (v : module.ray R M) :\n    «expr • » e v = module.ray.map e v :=\n  rfl\n#align module.ray.linear_equiv_smul_eq_map module.ray.linear_equiv_smul_eq_map\n\n",
 "ind":
 "/-- An induction principle for `module.ray`, used as `induction x using module.ray.ind`. -/\ntheorem module.ray.ind {C : module.ray R M → Prop} (h : ∀ (v) (hv : v ≠ 0), C (ray_of_ne_zero R v hv))\n    (x : module.ray R M) : C x :=\n  quotient.ind (subtype.rec <| h) x\n#align module.ray.ind module.ray.ind\n\n",
 "exists_pos_right_iff_same_ray_and_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_right_iff_same_ray_and_ne_zero (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ x = «expr • » r y) ↔ same_ray R x y ∧ x ≠ 0 := by\n  simpa only [same_ray_comm, eq_comm] using exists_pos_left_iff_same_ray_and_ne_zero hy\n#align exists_pos_right_iff_same_ray_and_ne_zero exists_pos_right_iff_same_ray_and_ne_zero\n\n",
 "exists_pos_right_iff_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_right_iff_same_ray (hx : x ≠ 0) (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ x = «expr • » r y) ↔ same_ray R x y := by\n  simpa only [same_ray_comm, eq_comm] using exists_pos_left_iff_same_ray hy hx\n#align exists_pos_right_iff_same_ray exists_pos_right_iff_same_ray\n\n",
 "exists_pos_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_right (h : same_ray R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ r : R, 0 < r ∧ x = «expr • » r y :=\n  (h.symm.exists_pos_left hy hx).imp fun _ => and.imp_right eq.symm\n#align exists_pos_right exists_pos_right\n\n",
 "exists_pos_left_iff_same_ray_and_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_left_iff_same_ray_and_ne_zero (hx : x ≠ 0) :\n    (∃ r : R, 0 < r ∧ «expr • » r x = y) ↔ same_ray R x y ∧ y ≠ 0 :=\n  by\n  constructor\n  · rintro ⟨r, hr, rfl⟩\n    simp [hx, hr.le, hr.ne']\n  · rintro ⟨hxy, hy⟩\n    exact (exists_pos_left_iff_same_ray hx hy).2 hxy\n#align exists_pos_left_iff_same_ray_and_ne_zero exists_pos_left_iff_same_ray_and_ne_zero\n\n",
 "exists_pos_left_iff_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_left_iff_same_ray (hx : x ≠ 0) (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ «expr • » r x = y) ↔ same_ray R x y :=\n  by\n  refine' ⟨fun h => _, fun h => h.exists_pos_left hx hy⟩\n  rcases h with ⟨r, hr, rfl⟩\n  exact same_ray_pos_smul_right x hr\n#align exists_pos_left_iff_same_ray exists_pos_left_iff_same_ray\n\n",
 "exists_pos_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_pos_left (h : same_ray R x y) (hx : x ≠ 0) (hy : y ≠ 0) : ∃ r : R, 0 < r ∧ «expr • » r x = y :=\n  let ⟨r₁, r₂, hr₁, hr₂, h⟩ := h.exists_pos hx hy\n  ⟨r₂⁻¹ * r₁, mul_pos (inv_pos.2 hr₂) hr₁, by rw [mul_smul, h, inv_smul_smul₀ hr₂.ne']⟩\n#align exists_pos_left exists_pos_left\n\n",
 "exists_pos":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem exists_pos (h : same_ray R x y) (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ r₁ r₂ : R, 0 < r₁ ∧ 0 < r₂ ∧ «expr • » r₁ x = «expr • » r₂ y :=\n  (h.resolve_left hx).resolve_left hy\n#align exists_pos exists_pos\n\n",
 "exists_nonneg_right_iff_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_nonneg_right_iff_same_ray (hy : y ≠ 0) : (∃ r : R, 0 ≤ r ∧ x = «expr • » r y) ↔ same_ray R x y := by\n  simpa only [same_ray_comm, eq_comm] using exists_nonneg_left_iff_same_ray hy\n#align exists_nonneg_right_iff_same_ray exists_nonneg_right_iff_same_ray\n\n",
 "exists_nonneg_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a vector `v₁` is on the same ray as a nonzero vector `v₂`, then it is equal to `c • v₂` for\nsome nonnegative `c`. -/\ntheorem exists_nonneg_right (h : same_ray R x y) (hy : y ≠ 0) : ∃ r : R, 0 ≤ r ∧ x = «expr • » r y :=\n  (h.symm.exists_nonneg_left hy).imp fun _ => and.imp_right eq.symm\n#align exists_nonneg_right exists_nonneg_right\n\n",
 "exists_nonneg_left_iff_same_ray":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem exists_nonneg_left_iff_same_ray (hx : x ≠ 0) : (∃ r : R, 0 ≤ r ∧ «expr • » r x = y) ↔ same_ray R x y :=\n  by\n  refine' ⟨fun h => _, fun h => h.exists_nonneg_left hx⟩\n  rcases h with ⟨r, hr, rfl⟩\n  exact same_ray_nonneg_smul_right x hr\n#align exists_nonneg_left_iff_same_ray exists_nonneg_left_iff_same_ray\n\n",
 "exists_nonneg_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If a vector `v₂` is on the same ray as a nonzero vector `v₁`, then it is equal to `c • v₁` for\nsome nonnegative `c`. -/\ntheorem exists_nonneg_left (h : same_ray R x y) (hx : x ≠ 0) : ∃ r : R, 0 ≤ r ∧ «expr • » r x = y :=\n  by\n  obtain rfl | hy := eq_or_ne y 0\n  · exact ⟨0, le_rfl, zero_smul _ _⟩\n  · exact (h.exists_pos_left hx hy).imp fun _ => and.imp_left le_of_lt\n#align exists_nonneg_left exists_nonneg_left\n\n",
 "exists_eq_smul_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If vectors `v₁` and `v₂` are on the same ray, then for some nonnegative `a b`, `a + b = 1`, we\nhave `v₁ = a • (v₁ + v₂)` and `v₂ = b • (v₁ + v₂)`. -/\ntheorem exists_eq_smul_add (h : same_ray R v₁ v₂) :\n    ∃ a b : R, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = «expr • » a (v₁ + v₂) ∧ v₂ = «expr • » b (v₁ + v₂) :=\n  by\n  rcases h with (rfl | rfl | ⟨r₁, r₂, h₁, h₂, H⟩)\n  · use 0, 1\n    simp\n  · use 1, 0\n    simp\n  · have h₁₂ : 0 < r₁ + r₂ := add_pos h₁ h₂\n    refine' ⟨r₂ / (r₁ + r₂), r₁ / (r₁ + r₂), div_nonneg h₂.le h₁₂.le, div_nonneg h₁.le h₁₂.le, _, _, _⟩\n    · rw [← add_div, add_comm, div_self h₁₂.ne']\n    · rw [div_eq_inv_mul, mul_smul, smul_add, ← H, ← add_smul, add_comm r₂, inv_smul_smul₀ h₁₂.ne']\n    · rw [div_eq_inv_mul, mul_smul, smul_add, H, ← add_smul, add_comm r₂, inv_smul_smul₀ h₁₂.ne']\n#align exists_eq_smul_add exists_eq_smul_add\n\n",
 "exists_eq_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If vectors `v₁` and `v₂` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `v₁ + v₂`, see `same_ray.exists_eq_smul_add`. -/\ntheorem exists_eq_smul (h : same_ray R v₁ v₂) :\n    ∃ (u : M)(a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = «expr • » a u ∧ v₂ = «expr • » b u :=\n  ⟨v₁ + v₂, h.exists_eq_smul_add⟩\n#align exists_eq_smul exists_eq_smul\n\n",
 "equiv_neg_iff":
 "/-- If two nonzero vectors are equivalent, so are their negations. -/\n@[simp]\ntheorem equiv_neg_iff {v₁ v₂ : ray_vector R M} : -v₁ ≈ -v₂ ↔ v₁ ≈ v₂ :=\n  same_ray_neg_iff\n#align equiv_neg_iff equiv_neg_iff\n\n",
 "equiv_iff_same_ray":
 "/-- Equivalence of nonzero vectors, in terms of same_ray. -/\ntheorem equiv_iff_same_ray {v₁ v₂ : ray_vector R M} : v₁ ≈ v₂ ↔ same_ray R (v₁ : M) v₂ :=\n  iff.rfl\n#align equiv_iff_same_ray equiv_iff_same_ray\n\n",
 "eq_zero_of_same_ray_self_neg":
 "/-- If a vector is in the same ray as its negation, that vector is zero. -/\ntheorem eq_zero_of_same_ray_self_neg [NoZeroSMulDivisors R M] (h : same_ray R x (-x)) : x = 0 :=\n  by\n  nontriviality M; haveI : nontrivial R := Module.nontrivial R M\n  refine' eq_zero_of_same_ray_neg_smul_right (neg_lt_zero.2 (zero_lt_one' R)) _\n  rwa [neg_one_smul]\n#align eq_zero_of_same_ray_self_neg eq_zero_of_same_ray_self_neg\n\n",
 "eq_zero_of_same_ray_neg_smul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem eq_zero_of_same_ray_neg_smul_right [NoZeroSMulDivisors R M] {r : R} (hr : r < 0)\n    (h : same_ray R x («expr • » r x)) : x = 0 :=\n  by\n  rcases h with (rfl | h₀ | ⟨r₁, r₂, hr₁, hr₂, h⟩)\n  · rfl\n  · simpa [hr.ne] using h₀\n  · rw [← sub_eq_zero, smul_smul, ← sub_smul, smul_eq_zero] at h\n    refine' h.resolve_left (ne_of_gt <| sub_pos.2 _)\n    exact (mul_neg_of_pos_of_neg hr₂ hr).trans hr₁\n#align eq_zero_of_same_ray_neg_smul_right eq_zero_of_same_ray_neg_smul_right\n\n",
 "coe_neg":
 "/-- Negating a nonzero vector commutes with coercion to the underlying module. -/\n@[simp, norm_cast]\ntheorem coe_neg {R : Type _} (v : ray_vector R M) : ↑(-v) = -(v : M) :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "add_right":
 "/-- If `y` and `z` are on the same ray as `x`, then so is `y + z`. -/\ntheorem add_right (hy : same_ray R x y) (hz : same_ray R x z) : same_ray R x (y + z) :=\n  (hy.symm.add_left hz.symm).symm\n#align add_right add_right\n\n",
 "add_left":
 "/- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\"[\", expr add_pos, \",\", expr mul_pos, \"]\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error -/\n/-- If `x` and `y` are on the same ray as `z`, then so is `x + y`. -/\ntheorem add_left (hx : same_ray R x z) (hy : same_ray R y z) : same_ray R (x + y) z :=\n  by\n  rcases eq_or_ne x 0 with (rfl | hx₀); · rwa [zero_add]\n  rcases eq_or_ne y 0 with (rfl | hy₀); · rwa [add_zero]\n  rcases eq_or_ne z 0 with (rfl | hz₀); · apply zero_right\n  rcases hx.exists_pos hx₀ hz₀ with ⟨rx, rz₁, hrx, hrz₁, Hx⟩\n  rcases hy.exists_pos hy₀ hz₀ with ⟨ry, rz₂, hry, hrz₂, Hy⟩\n  refine' or.inr (or.inr ⟨rx * ry, ry * rz₁ + rx * rz₂, mul_pos hrx hry, _, _⟩)\n  ·\n    trace\n      \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:75:38: in apply_rules #[[\\\"[\\\", expr add_pos, \\\",\\\", expr mul_pos, \\\"]\\\"], []]: ./././Mathport/Syntax/Translate/Basic.lean:349:22: unsupported: parse error\"\n  · simp only [mul_smul, smul_add, add_smul, ← Hx, ← Hy]\n    rw [smul_comm]\n#align add_left add_left\n\n"}