{"zero_comp_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem zero_comp_linear_map (g : «expr →ₗ[ ] » M₂ R M) : (0 : AlternatingMap R M N ι).comp_linear_map g = 0 :=\n  by\n  ext\n  simp only [comp_linear_map_apply, zero_apply]\n#align zero_comp_linear_map zero_comp_linear_map\n\n",
 "zero_apply":
 "@[simp]\ntheorem zero_apply : (0 : AlternatingMap R M N ι) v = 0 :=\n  rfl\n#align zero_apply zero_apply\n\n",
 "to_multilinear_map_eq_coe":
 "@[simp]\ntheorem to_multilinear_map_eq_coe : f.to_multilinear_map = f :=\n  rfl\n#align to_multilinear_map_eq_coe to_multilinear_map_eq_coe\n\n",
 "to_fun_eq_coe":
 "/-\nCopyright (c) 2020 Zhangir Azerbayev. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser, Zhangir Azerbayev\n-/\n-- semiring / add_comm_monoid\n-- semiring / add_comm_group\n-- shortcut instance\n@[simp]\ntheorem to_fun_eq_coe : f.to_fun = f :=\n  rfl\n#align to_fun_eq_coe to_fun_eq_coe\n\n",
 "swap_smul_involutive":
 "theorem mod_sum_congr.swap_smul_involutive {α β : Type _} [DecidableEq (Sum α β)] (i j : Sum α β) :\n    Function.Involutive (has_smul.smul (Equiv.swap i j) : ModSumCongr α β → ModSumCongr α β) := fun σ =>\n  by\n  apply σ.induction_on' fun σ => _\n  exact _root_.congr_arg Quotient.mk'' (Equiv.swap_mul_involutive i j σ)\n#align mod_sum_congr.swap_smul_involutive mod_sum_congr.swap_smul_involutive\n\n",
 "summand_mk'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\ntheorem dom_coprod.summand_mk' (a : AlternatingMap R' Mᵢ N₁ ιa) (b : AlternatingMap R' Mᵢ N₂ ιb)\n    (σ : Equiv.Perm (Sum ιa ιb)) :\n    domCoprod.summand a b (Quotient.mk'' σ) =\n      «expr • » σ.sign\n        ((MultilinearMap.domCoprod ↑a ↑b : MultilinearMap R' (fun _ => Mᵢ) (tensor_product.infer N₁ N₂)).dom_dom_congr\n          σ) :=\n  rfl\n#align dom_coprod.summand_mk' dom_coprod.summand_mk'\n\n",
 "summand_eq_zero_of_smul_invariant":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Swapping elements in `σ` with equal values in `v` result in zero if the swap has no effect\non the quotient. -/\ntheorem dom_coprod.summand_eq_zero_of_smul_invariant (a : AlternatingMap R' Mᵢ N₁ ιa) (b : AlternatingMap R' Mᵢ N₂ ιb)\n    (σ : Perm.ModSumCongr ιa ιb) {v : Sum ιa ιb → Mᵢ} {i j : Sum ιa ιb} (hv : v i = v j) (hij : i ≠ j) :\n    «expr • » (swap i j) σ = σ → domCoprod.summand a b σ v = 0 :=\n  by\n  apply σ.induction_on' fun σ => _\n  dsimp only [quotient.lift_on'_mk', quotient.map'_mk', MultilinearMap.smul_apply, MultilinearMap.domDomCongr_apply,\n    multilinear_map.dom_coprod_apply, dom_coprod.summand]\n  intro hσ\n  cases hi : σ⁻¹ i <;> cases hj : σ⁻¹ j <;> rw [perm.inv_eq_iff_eq] at hi hj <;> substs hi hj <;> revert val val_1\n  case inl.inr |\n    inr.inl =>\n    -- the term pairs with and cancels another term\n    all_goals\n      intro i' j' hv hij hσ\n      obtain ⟨⟨sl, sr⟩, hσ⟩ := quotient_group.left_rel_apply.mp (Quotient.exact' hσ)\n    on_goal 1 => replace hσ := Equiv.congr_fun hσ (Sum.inl i')\n    on_goal 2 => replace hσ := Equiv.congr_fun hσ (Sum.inr i')\n    all_goals\n      rw [smul_eq_mul, ← mul_swap_eq_swap_mul, mul_inv_rev, swap_inv, inv_mul_cancel_right] at hσ\n      simpa using hσ\n  case inr.inr |\n    inl.inl =>\n    -- the term does not pair but is zero\n    all_goals\n      intro i' j' hv hij hσ\n      convert smul_zero _\n    on_goal 1 => convert TensorProduct.tmul_zero _ _\n    on_goal 2 => convert TensorProduct.zero_tmul _ _\n    all_goals exact AlternatingMap.map_eq_zero_of_eq _ _ hv fun hij' => hij (hij' ▸ rfl)\n#align dom_coprod.summand_eq_zero_of_smul_invariant dom_coprod.summand_eq_zero_of_smul_invariant\n\n",
 "summand_add_swap_smul_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Swapping elements in `σ` with equal values in `v` results in an addition that cancels -/\ntheorem dom_coprod.summand_add_swap_smul_eq_zero (a : AlternatingMap R' Mᵢ N₁ ιa) (b : AlternatingMap R' Mᵢ N₂ ιb)\n    (σ : Perm.ModSumCongr ιa ιb) {v : Sum ιa ιb → Mᵢ} {i j : Sum ιa ιb} (hv : v i = v j) (hij : i ≠ j) :\n    domCoprod.summand a b σ v + domCoprod.summand a b («expr • » (swap i j) σ) v = 0 :=\n  by\n  apply σ.induction_on' fun σ => _\n  dsimp only [quotient.lift_on'_mk', quotient.map'_mk', MulAction.Quotient.smul_mk, dom_coprod.summand]\n  rw [smul_eq_mul, perm.sign_mul, perm.sign_swap hij]\n  simp only [one_mul, neg_mul, Function.comp_apply, Units.neg_smul, perm.coe_mul, Units.val_neg,\n    MultilinearMap.smul_apply, MultilinearMap.neg_apply, MultilinearMap.domDomCongr_apply,\n    multilinear_map.dom_coprod_apply]\n  convert add_right_neg _ <;>\n    · ext k\n      rw [Equiv.apply_swap_eq_self hv]\n#align dom_coprod.summand_add_swap_smul_eq_zero dom_coprod.summand_add_swap_smul_eq_zero\n\n",
 "subtype_comp_alternating_map_cod_restrict":
 "@[simp]\ntheorem subtype_comp_alternating_map_cod_restrict (f : AlternatingMap R M N ι) (p : Submodule R N) (h) :\n    p.subtype.comp_alternating_map (f.cod_restrict p h) = f :=\n  AlternatingMap.ext fun v => rfl\n#align subtype_comp_alternating_map_cod_restrict subtype_comp_alternating_map_cod_restrict\n\n",
 "sub_apply":
 "@[simp]\ntheorem sub_apply (m : ι → M) : (g - g₂) m = g m - g₂ m :=\n  rfl\n#align sub_apply sub_apply\n\n",
 "smul_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem smul_apply (c : S) (m : ι → M) : («expr • » c f) m = «expr • » c (f m) :=\n  rfl\n#align smul_apply smul_apply\n\n",
 "neg_apply":
 "@[simp]\ntheorem neg_apply (m : ι → M) : (-g) m = -g m :=\n  rfl\n#align neg_apply neg_apply\n\n",
 "map_zero":
 "#print map_zero /-\n@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 :=\n  f.to_multilinear_map.map_zero\n#align map_zero map_zero\n-/\n\n",
 "map_vec_cons_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A version of `multilinear_map.cons_smul` for `alternating_map`. -/\ntheorem map_vec_cons_smul {n : ℕ} (f : AlternatingMap R M N (Fin n.succ)) (m : Fin n → M) (c : R) (x : M) :\n    f (Matrix.vecCons («expr • » c x) m) = «expr • » c (f (Matrix.vecCons x m)) :=\n  f.to_multilinear_map.cons_smul _ _ _\n#align map_vec_cons_smul map_vec_cons_smul\n\n",
 "map_vec_cons_add":
 "/-- A version of `multilinear_map.cons_add` for `alternating_map`. -/\ntheorem map_vec_cons_add {n : ℕ} (f : AlternatingMap R M N (Fin n.succ)) (m : Fin n → M) (x y : M) :\n    f (Matrix.vecCons (x + y) m) = f (Matrix.vecCons x m) + f (Matrix.vecCons y m) :=\n  f.to_multilinear_map.cons_add _ _ _\n#align map_vec_cons_add map_vec_cons_add\n\n",
 "map_update_zero":
 "@[simp]\ntheorem map_update_zero [DecidableEq ι] (m : ι → M) (i : ι) : f (update m i 0) = 0 :=\n  f.to_multilinear_map.map_update_zero m i\n#align map_update_zero map_update_zero\n\n",
 "map_update_update":
 "theorem map_update_update [DecidableEq ι] {i j : ι} (hij : i ≠ j) (m : M) :\n    f (Function.update (Function.update v i m) j m) = 0 :=\n  f.map_eq_zero_of_eq _ (by rw [Function.update_same, Function.update_noteq hij, Function.update_same]) hij\n#align map_update_update map_update_update\n\n",
 "map_update_sum":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem map_update_sum {α : Type _} [DecidableEq ι] (t : Finset α) (i : ι) (g : α → M) (m : ι → M) :\n    f\n        (update m i\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (g a))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t\n        (f (update m i (g a))) :=\n  f.to_multilinear_map.map_update_sum t i g m\n#align map_update_sum map_update_sum\n\n",
 "map_update_self":
 "theorem map_update_self [DecidableEq ι] {i j : ι} (hij : i ≠ j) : f (Function.update v i (v j)) = 0 :=\n  f.map_eq_zero_of_eq _ (by rw [Function.update_same, Function.update_noteq hij.symm]) hij\n#align map_update_self map_update_self\n\n",
 "map_swap_add":
 "theorem map_swap_add [DecidableEq ι] {i j : ι} (hij : i ≠ j) : f (v ∘ Equiv.swap i j) + f v = 0 :=\n  by\n  rw [Equiv.comp_swap_eq_update]\n  convert f.map_update_update v hij (v i + v j)\n  simp [f.map_update_self _ hij, f.map_update_self _ hij.symm, Function.update_comm hij (v i + v j) (v _) v,\n    Function.update_comm hij.symm (v i) (v i) v]\n#align map_swap_add map_swap_add\n\n",
 "map_swap":
 "theorem map_swap [DecidableEq ι] {i j : ι} (hij : i ≠ j) : g (v ∘ Equiv.swap i j) = -g v :=\n  eq_neg_of_add_eq_zero_left <| g.map_swap_add v hij\n#align map_swap map_swap\n\n",
 "map_sub":
 "#print map_sub /-\n@[simp]\ntheorem map_sub [DecidableEq ι] (i : ι) (x y : M') :\n    g' (update v' i (x - y)) = g' (update v' i x) - g' (update v' i y) :=\n  g'.to_multilinear_map.map_sub v' i x y\n#align map_sub map_sub\n-/\n\n",
 "map_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem map_smul [DecidableEq ι] (i : ι) (r : R) (x : M) :\n    f (update v i («expr • » r x)) = «expr • » r (f (update v i x)) :=\n  f.to_multilinear_map.map_smul' v i r x\n#align map_smul map_smul\n\n",
 "map_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_perm [DecidableEq ι] [Fintype ι] (v : ι → M) (σ : Equiv.Perm ι) : g (v ∘ σ) = «expr • » σ.sign (g v) :=\n  by\n  apply Equiv.Perm.swap_induction_on' σ\n  · simp\n  · intro s x y hxy hI\n    simpa [g.map_swap (v ∘ s) hxy, Equiv.Perm.sign_swap hxy] using hI\n#align map_perm map_perm\n\n",
 "map_neg":
 "#print map_neg /-\n@[simp]\ntheorem map_neg [DecidableEq ι] (i : ι) (x : M') : g' (update v' i (-x)) = -g' (update v' i x) :=\n  g'.to_multilinear_map.map_neg v' i x\n#align map_neg map_neg\n-/\n\n",
 "map_linear_dependent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If the arguments are linearly dependent then the result is `0`. -/\ntheorem map_linear_dependent {K : Type _} [Ring K] {M : Type _} [AddCommGroup M] [Module K M] {N : Type _}\n    [AddCommGroup N] [Module K N] [NoZeroSMulDivisors K N] (f : AlternatingMap K M N ι) (v : ι → M)\n    (h : ¬LinearIndependent K v) : f v = 0 :=\n  by\n  obtain ⟨s, g, h, i, hi, hz⟩ := not_linear_independent_iff.mp h\n  letI := Classical.decEq ι\n  suffices f (update v i («expr • » (g i) (v i))) = 0\n    by\n    rw [f.map_smul, Function.update_eq_self, smul_eq_zero] at this\n    exact or.resolve_left this hz\n  conv at h in «expr • » (g _) (v _) => rw [← if_t_t (i = x) («expr • » (g _) (v _))]\n  rw [Finset.sum_ite, Finset.filter_eq, Finset.filter_ne, if_pos hi, Finset.sum_singleton, add_eq_zero_iff_eq_neg] at h\n  rw [h, f.map_neg, f.map_update_sum, neg_eq_zero, Finset.sum_eq_zero]\n  intro j hj\n  obtain ⟨hij, _⟩ := finset.mem_erase.mp hj\n  rw [f.map_smul, f.map_update_self _ hij.symm, smul_zero]\n#align map_linear_dependent map_linear_dependent\n\n",
 "map_eq_zero_of_not_injective":
 "theorem map_eq_zero_of_not_injective (v : ι → M) (hv : ¬function.injective v) : f v = 0 :=\n  by\n  rw [function.injective] at hv\n  push_neg  at hv\n  rcases hv with ⟨i₁, i₂, heq, hne⟩\n  exact f.map_eq_zero_of_eq v HEq hne\n#align map_eq_zero_of_not_injective map_eq_zero_of_not_injective\n\n",
 "map_eq_zero_of_eq":
 "@[simp]\ntheorem map_eq_zero_of_eq (v : ι → M) {i j : ι} (h : v i = v j) (hij : i ≠ j) : f v = 0 :=\n  f.map_eq_zero_of_eq' v i j h hij\n#align map_eq_zero_of_eq map_eq_zero_of_eq\n\n",
 "map_coord_zero":
 "theorem map_coord_zero {m : ι → M} (i : ι) (h : m i = 0) : f m = 0 :=\n  f.to_multilinear_map.map_coord_zero i h\n#align map_coord_zero map_coord_zero\n\n",
 "map_congr_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem map_congr_perm [DecidableEq ι] [Fintype ι] (σ : Equiv.Perm ι) : g v = «expr • » σ.sign (g (v ∘ σ)) :=\n  by\n  rw [g.map_perm, smul_smul]\n  simp\n#align map_congr_perm map_congr_perm\n\n",
 "map_add_swap":
 "theorem map_add_swap [DecidableEq ι] {i j : ι} (hij : i ≠ j) : f v + f (v ∘ Equiv.swap i j) = 0 :=\n  by\n  rw [add_comm]\n  exact f.map_swap_add v hij\n#align map_add_swap map_add_swap\n\n",
 "map_add":
 "#print map_add /-\n@[simp]\ntheorem map_add [DecidableEq ι] (i : ι) (x y : M) : f (update v i (x + y)) = f (update v i x) + f (update v i y) :=\n  f.to_multilinear_map.map_add' v i x y\n#align map_add map_add\n-/\n\n",
 "ext_iff":
 "theorem ext_iff {f g : AlternatingMap R M N ι} : f = g ↔ ∀ x, f x = g x :=\n  ⟨fun h x => h ▸ rfl, fun h => ext h⟩\n#align ext_iff ext_iff\n\n",
 "ext_alternating":
 "#print Basis.ext_alternating /-\n/-- Two alternating maps indexed by a `fintype` are equal if they are equal when all arguments\nare distinct basis vectors. -/\ntheorem Basis.ext_alternating {f g : AlternatingMap R' N₁ N₂ ι} (e : Basis ι₁ R' N₁)\n    (h : ∀ v : ι → ι₁, function.injective v → (f fun i => e (v i)) = g fun i => e (v i)) : f = g := by\n  classical\n    refine' AlternatingMap.coe_multilinearMap_injective (Basis.ext_multilinear e fun v => _)\n    by_cases hi : function.injective v\n    · exact h v hi\n    · have : ¬function.injective fun i => e (v i) := hi.imp Function.Injective.of_comp\n      rw [coe_multilinear_map, coe_multilinear_map, f.map_eq_zero_of_not_injective _ this,\n        g.map_eq_zero_of_not_injective _ this]\n#align basis.ext_alternating Basis.ext_alternating\n-/\n\n",
 "ext":
 "@[ext]\ntheorem ext {f f' : AlternatingMap R M N ι} (H : ∀ x, f x = f' x) : f = f' :=\n  FunLike.ext _ _ H\n#align ext ext\n\n",
 "dom_lcongr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\ntheorem dom_lcongr_trans (e : «expr ≃ₗ[ ] » M R M₂) (f : «expr ≃ₗ[ ] » M₂ R M₃) :\n    (domLCongr R N ι S e).trans (domLCongr R N ι S f) = domLCongr R N ι S (e.trans f) :=\n  rfl\n#align dom_lcongr_trans dom_lcongr_trans\n\n",
 "dom_lcongr_symm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n@[simp]\ntheorem dom_lcongr_symm (e : «expr ≃ₗ[ ] » M R M₂) : (domLCongr R N ι S e).symm = domLCongr R N ι S e.symm :=\n  rfl\n#align dom_lcongr_symm dom_lcongr_symm\n\n",
 "dom_lcongr_refl":
 "@[simp]\ntheorem dom_lcongr_refl : domLCongr R N ι S (LinearEquiv.refl R M) = LinearEquiv.refl S _ :=\n  LinearEquiv.ext fun _ => AlternatingMap.ext fun v => rfl\n#align dom_lcongr_refl dom_lcongr_refl\n\n",
 "dom_dom_congr_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem dom_dom_congr_zero (σ : «expr ≃ » ι ι') : (0 : AlternatingMap R M N ι).dom_dom_congr σ = 0 :=\n  rfl\n#align dom_dom_congr_zero dom_dom_congr_zero\n\n",
 "dom_dom_congr_trans":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\ntheorem dom_dom_congr_trans (σ₁ : «expr ≃ » ι ι') (σ₂ : «expr ≃ » ι' ι'') (f : AlternatingMap R M N ι) :\n    f.dom_dom_congr (σ₁.trans σ₂) = (f.dom_dom_congr σ₁).dom_dom_congr σ₂ :=\n  rfl\n#align dom_dom_congr_trans dom_dom_congr_trans\n\n",
 "dom_dom_congr_refl":
 "@[simp]\ntheorem dom_dom_congr_refl (f : AlternatingMap R M N ι) : f.dom_dom_congr (Equiv.refl ι) = f :=\n  ext fun v => rfl\n#align dom_dom_congr_refl dom_dom_congr_refl\n\n",
 "dom_dom_congr_perm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem dom_dom_congr_perm [Fintype ι] [DecidableEq ι] (σ : Equiv.Perm ι) : g.dom_dom_congr σ = «expr • » σ.sign g :=\n  AlternatingMap.ext fun v => g.map_perm v σ\n#align dom_dom_congr_perm dom_dom_congr_perm\n\n",
 "dom_dom_congr_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem dom_dom_congr_eq_zero_iff (σ : «expr ≃ » ι ι') (f : AlternatingMap R M N ι) : f.dom_dom_congr σ = 0 ↔ f = 0 :=\n  (domDomCongrEquiv σ : «expr ≃+ » (AlternatingMap R M N ι) (AlternatingMap R M N ι')).map_eq_zero_iff\n#align dom_dom_congr_eq_zero_iff dom_dom_congr_eq_zero_iff\n\n",
 "dom_dom_congr_eq_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/-- The results of applying `dom_dom_congr` to two maps are equal if and only if those maps are. -/\n@[simp]\ntheorem dom_dom_congr_eq_iff (σ : «expr ≃ » ι ι') (f g : AlternatingMap R M N ι) :\n    f.dom_dom_congr σ = g.dom_dom_congr σ ↔ f = g :=\n  (domDomCongrEquiv σ : «expr ≃+ » _ (AlternatingMap R M N ι')).apply_eq_iff_eq\n#align dom_dom_congr_eq_iff dom_dom_congr_eq_iff\n\n",
 "dom_dom_congr_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[simp]\ntheorem dom_dom_congr_add (σ : «expr ≃ » ι ι') (f g : AlternatingMap R M N ι) :\n    (f + g).dom_dom_congr σ = f.dom_dom_congr σ + g.dom_dom_congr σ :=\n  rfl\n#align dom_dom_congr_add dom_dom_congr_add\n\n",
 "dom_coprod_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\ntheorem dom_coprod_coe (a : AlternatingMap R' Mᵢ N₁ ιa) (b : AlternatingMap R' Mᵢ N₂ ιb) :\n    (↑(a.dom_coprod b) : MultilinearMap R' (fun _ => Mᵢ) _) =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (domCoprod.summand a b σ) :=\n  MultilinearMap.ext fun _ => rfl\n#align dom_coprod_coe dom_coprod_coe\n\n",
 "dom_coprod'_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊗ₜ[ ] » -/\n@[simp]\ntheorem dom_coprod'_apply (a : AlternatingMap R' Mᵢ N₁ ιa) (b : AlternatingMap R' Mᵢ N₂ ιb) :\n    domCoprod' («expr ⊗ₜ[ ] » a R' b) = domCoprod a b :=\n  rfl\n#align dom_coprod'_apply dom_coprod'_apply\n\n",
 "domCoprod_alternization_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `tensor_product.infer -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print MultilinearMap.domCoprod_alternization_eq /-\n/-- Taking the `multilinear_map.alternatization` of the `multilinear_map.dom_coprod` of two\n`alternating_map`s gives a scaled version of the `alternating_map.coprod` of those maps.\n-/\ntheorem MultilinearMap.domCoprod_alternization_eq [DecidableEq ιa] [DecidableEq ιb] (a : AlternatingMap R' Mᵢ N₁ ιa)\n    (b : AlternatingMap R' Mᵢ N₂ ιb) :\n    (MultilinearMap.domCoprod a b :\n          MultilinearMap R' (fun _ : Sum ιa ιb => Mᵢ) (tensor_product.infer N₁ N₂)).alternatization =\n      «expr • » ((Fintype.card ιa).factorial * (Fintype.card ιb).factorial) (a.dom_coprod b) :=\n  by\n  rw [MultilinearMap.domCoprod_alternization, coe_alternatization, coe_alternatization, mul_smul, ← dom_coprod'_apply, ←\n    dom_coprod'_apply, ← TensorProduct.smul_tmul', TensorProduct.tmul_smul, LinearMap.map_smul_of_tower dom_coprod',\n    LinearMap.map_smul_of_tower dom_coprod']\n  -- typeclass resolution is a little confused here\n  infer_instance;\n  infer_instance\n#align multilinear_map.dom_coprod_alternization_eq MultilinearMap.domCoprod_alternization_eq\n-/\n\n",
 "domCoprod_alternization_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print MultilinearMap.domCoprod_alternization_coe /-\n/-- A helper lemma for `multilinear_map.dom_coprod_alternization`. -/\ntheorem MultilinearMap.domCoprod_alternization_coe [DecidableEq ιa] [DecidableEq ιb]\n    (a : MultilinearMap R' (fun _ : ιa => Mᵢ) N₁) (b : MultilinearMap R' (fun _ : ιb => Mᵢ) N₂) :\n    MultilinearMap.domCoprod ↑a.alternatization ↑b.alternatization =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » σa.sign («expr • » σb.sign (MultilinearMap.domCoprod (a.dom_dom_congr σa) (b.dom_dom_congr σb)))) :=\n  by\n  simp_rw [← MultilinearMap.domCoprod'_apply, MultilinearMap.alternatization_coe]\n  simp_rw [TensorProduct.sum_tmul, TensorProduct.tmul_sum, LinearMap.map_sum, ← TensorProduct.smul_tmul',\n    TensorProduct.tmul_smul, LinearMap.map_smul_of_tower]\n#align multilinear_map.dom_coprod_alternization_coe MultilinearMap.domCoprod_alternization_coe\n-/\n\n",
 "domCoprod_alternization":
 "#print MultilinearMap.domCoprod_alternization /-\n/-- Computing the `multilinear_map.alternatization` of the `multilinear_map.dom_coprod` is the same\nas computing the `alternating_map.dom_coprod` of the `multilinear_map.alternatization`s.\n-/\ntheorem MultilinearMap.domCoprod_alternization [DecidableEq ιa] [DecidableEq ιb]\n    (a : MultilinearMap R' (fun _ : ιa => Mᵢ) N₁) (b : MultilinearMap R' (fun _ : ιb => Mᵢ) N₂) :\n    (MultilinearMap.domCoprod a b).alternatization = a.alternatization.dom_coprod b.alternatization :=\n  by\n  apply coe_multilinear_map_injective\n  rw [dom_coprod_coe, MultilinearMap.alternatization_coe,\n    Finset.sum_partition (QuotientGroup.leftRel (perm.sum_congr_hom ιa ιb).range)]\n  congr 1\n  ext1 σ\n  apply σ.induction_on' fun σ => _\n  -- unfold the quotient mess left by `finset.sum_partition`\n  conv in _ = Quotient.mk'' _ =>\n    change Quotient.mk'' _ = Quotient.mk'' _\n    rw [QuotientGroup.eq']\n  -- eliminate a multiplication\n  rw [← Finset.map_univ_equiv (Equiv.mulLeft σ), Finset.filter_map, Finset.sum_map]\n  simp_rw [Equiv.coe_toEmbedding, Equiv.coe_mulLeft, (· ∘ ·), mul_inv_rev, inv_mul_cancel_right, Subgroup.inv_mem_iff,\n    MonoidHom.mem_range, Finset.univ_filter_exists, Finset.sum_image (perm.sum_congr_hom_injective.inj_on _)]\n  -- now we're ready to clean up the RHS, pulling out the summation\n  rw [dom_coprod.summand_mk', MultilinearMap.domCoprod_alternization_coe, ← Finset.sum_product',\n    Finset.univ_product_univ, ← MultilinearMap.domDomCongrEquiv_apply, AddEquiv.map_sum, Finset.smul_sum]\n  congr 1\n  ext1 ⟨al, ar⟩\n  dsimp only\n  -- pull out the pair of smuls on the RHS, by rewriting to `_ →ₗ[ℤ] _` and back\n  rw [← AddEquiv.coe_toAddMonoidHom, ← AddMonoidHom.coe_toIntLinearMap, LinearMap.map_smul_of_tower,\n    LinearMap.map_smul_of_tower, AddMonoidHom.coe_toIntLinearMap, AddEquiv.coe_toAddMonoidHom,\n    MultilinearMap.domDomCongrEquiv_apply]\n  -- pick up the pieces\n  rw [MultilinearMap.domDomCongr_mul, perm.sign_mul, perm.sum_congr_hom_apply,\n    MultilinearMap.domCoprod_domDomCongr_sumCongr, perm.sign_sum_congr, mul_smul, mul_smul]\n#align multilinear_map.dom_coprod_alternization MultilinearMap.domCoprod_alternization\n-/\n\n",
 "curry_left_zero":
 "@[simp]\ntheorem curry_left_zero {n : ℕ} : curryLeft (0 : AlternatingMap R' M'' N'' (Fin n.succ)) = 0 :=\n  rfl\n#align curry_left_zero curry_left_zero\n\n",
 "curry_left_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem curry_left_smul {n : ℕ} (r : R') (f : AlternatingMap R' M'' N'' (Fin n.succ)) :\n    curryLeft («expr • » r f) = «expr • » r (curryLeft f) :=\n  rfl\n#align curry_left_smul curry_left_smul\n\n",
 "curry_left_same":
 "/-- Currying with the same element twice gives the zero map. -/\n@[simp]\ntheorem curry_left_same {n : ℕ} (f : AlternatingMap R' M'' N'' (Fin n.succ.succ)) (m : M'') :\n    (f.curry_left m).curry_left m = 0 :=\n  ext fun x => f.map_eq_zero_of_eq _ (by simp) Fin.zero_ne_one\n#align curry_left_same curry_left_same\n\n",
 "curry_left_comp_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem curry_left_comp_linear_map {n : ℕ} (g : «expr →ₗ[ ] » M₂'' R' M'') (f : AlternatingMap R' M'' N'' (Fin n.succ))\n    (m : M₂'') : (f.comp_linear_map g).curry_left m = (f.curry_left (g m)).comp_linear_map g :=\n  ext fun v =>\n    congr_arg f <|\n      funext <| by\n        refine' Fin.cases _ _\n        · rfl\n        · simp\n#align curry_left_comp_linear_map curry_left_comp_linear_map\n\n",
 "curry_left_comp_alternating_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem curry_left_comp_alternating_map {n : ℕ} (g : «expr →ₗ[ ] » N'' R' N₂'')\n    (f : AlternatingMap R' M'' N'' (Fin n.succ)) (m : M'') :\n    (g.comp_alternating_map f).curry_left m = g.comp_alternating_map (f.curry_left m) :=\n  rfl\n#align curry_left_comp_alternating_map curry_left_comp_alternating_map\n\n",
 "curry_left_add":
 "@[simp]\ntheorem curry_left_add {n : ℕ} (f g : AlternatingMap R' M'' N'' (Fin n.succ)) :\n    curryLeft (f + g) = curryLeft f + curryLeft g :=\n  rfl\n#align curry_left_add curry_left_add\n\n",
 "congr_fun":
 "#print congr_fun /-\ntheorem congr_fun {f g : AlternatingMap R M N ι} (h : f = g) (x : ι → M) : f x = g x :=\n  congr_arg (fun h : AlternatingMap R M N ι => h x) h\n#align congr_fun congr_fun\n-/\n\n",
 "congr_arg":
 "#print congr_arg /-\ntheorem congr_arg (f : AlternatingMap R M N ι) {x y : ι → M} (h : x = y) : f x = f y :=\n  congr_arg (fun x : ι → M => f x) h\n#align congr_arg congr_arg\n-/\n\n",
 "comp_multilinear_map_alternatization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composition with a linear map before and after alternatization are equivalent. -/\ntheorem comp_multilinear_map_alternatization (g : «expr →ₗ[ ] » N' R N'₂) (f : MultilinearMap R (fun _ : ι => M) N') :\n    (g.comp_multilinear_map f).alternatization = g.comp_alternating_map f.alternatization :=\n  by\n  ext\n  simp [MultilinearMap.alternatization_def]\n#align comp_multilinear_map_alternatization comp_multilinear_map_alternatization\n\n",
 "comp_linear_map_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_linear_map_zero [Nonempty ι] (f : AlternatingMap R M N ι) :\n    f.comp_linear_map (0 : «expr →ₗ[ ] » M₂ R M) = 0 := by\n  ext\n  simp_rw [comp_linear_map_apply, LinearMap.zero_apply, ← Pi.zero_def, map_zero, zero_apply]\n#align comp_linear_map_zero comp_linear_map_zero\n\n",
 "comp_linear_map_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing with a surjective linear map is injective. -/\ntheorem comp_linear_map_injective (f : «expr →ₗ[ ] » M₂ R M) (hf : function.surjective f) :\n    function.injective fun g : AlternatingMap R M N ι => g.comp_linear_map f := fun g₁ g₂ h =>\n  ext fun x => by simpa [Function.surjInv_eq hf] using ext_iff.mp h (Function.surjInv hf ∘ x)\n#align comp_linear_map_injective comp_linear_map_injective\n\n",
 "comp_linear_map_inj":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem comp_linear_map_inj (f : «expr →ₗ[ ] » M₂ R M) (hf : function.surjective f) (g₁ g₂ : AlternatingMap R M N ι) :\n    g₁.comp_linear_map f = g₂.comp_linear_map f ↔ g₁ = g₂ :=\n  (compLinearMap_injective _ hf).eq_iff\n#align comp_linear_map_inj comp_linear_map_inj\n\n",
 "comp_linear_map_id":
 "/-- Composing an alternating map with the identity linear map in each argument. -/\n@[simp]\ntheorem comp_linear_map_id (f : AlternatingMap R M N ι) : f.comp_linear_map LinearMap.id = f :=\n  ext fun _ => rfl\n#align comp_linear_map_id comp_linear_map_id\n\n",
 "comp_linear_map_assoc":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ∘ₗ » -/\n/-- Composing an alternating map twice with the same linear map in each argument is\nthe same as composing with their composition. -/\ntheorem comp_linear_map_assoc (f : AlternatingMap R M N ι) (g₁ : «expr →ₗ[ ] » M₂ R M) (g₂ : «expr →ₗ[ ] » M₃ R M₂) :\n    (f.comp_linear_map g₁).comp_linear_map g₂ = f.comp_linear_map («expr ∘ₗ » g₁ g₂) :=\n  rfl\n#align comp_linear_map_assoc comp_linear_map_assoc\n\n",
 "comp_linear_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_linear_map_apply (f : AlternatingMap R M N ι) (g : «expr →ₗ[ ] » M₂ R M) (v : ι → M₂) :\n    f.comp_linear_map g v = f fun i => g (v i) :=\n  rfl\n#align comp_linear_map_apply comp_linear_map_apply\n\n",
 "comp_linear_equiv_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/-- Composing an alternating map with the same linear equiv on each argument gives the zero map\nif and only if the alternating map is the zero map. -/\n@[simp]\ntheorem comp_linear_equiv_eq_zero_iff (f : AlternatingMap R M N ι) (g : «expr ≃ₗ[ ] » M₂ R M) :\n    f.comp_linear_map (g : «expr →ₗ[ ] » M₂ R M) = 0 ↔ f = 0 :=\n  (domLCongr R N ι ℕ g.symm).map_eq_zero_iff\n#align comp_linear_equiv_eq_zero_iff comp_linear_equiv_eq_zero_iff\n\n",
 "comp_alternating_map_cod_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_alternating_map_cod_restrict (g : «expr →ₗ[ ] » N R N₂) (f : AlternatingMap R M N ι) (p : Submodule R N₂)\n    (h) : (g.cod_restrict p h).comp_alternating_map f = (g.comp_alternating_map f).cod_restrict p fun v => h (f v) :=\n  AlternatingMap.ext fun v => rfl\n#align comp_alternating_map_cod_restrict comp_alternating_map_cod_restrict\n\n",
 "comp_alternating_map_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem comp_alternating_map_apply (g : «expr →ₗ[ ] » N R N₂) (f : AlternatingMap R M N ι) (m : ι → M) :\n    g.comp_alternating_map f m = g (f m) :=\n  rfl\n#align comp_alternating_map_apply comp_alternating_map_apply\n\n",
 "coe_zero":
 "@[norm_cast]\ntheorem coe_zero : ((0 : AlternatingMap R M N ι) : MultilinearMap R (fun i : ι => M) N) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_sub":
 "@[norm_cast]\ntheorem coe_sub : (↑(g - g₂) : MultilinearMap R (fun i : ι => M) N') = g - g₂ :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[norm_cast]\ntheorem coe_smul (c : S) :\n    ((«expr • » c f : AlternatingMap R M N ι) : MultilinearMap R (fun i : ι => M) N) = «expr • » c f :=\n  rfl\n#align coe_smul coe_smul\n\n",
 "coe_neg":
 "@[norm_cast]\ntheorem coe_neg : ((-g : AlternatingMap R M N' ι) : MultilinearMap R (fun i : ι => M) N') = -g :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_multilinear_map_mk":
 "@[simp]\ntheorem coe_multilinear_map_mk (f : (ι → M) → N) (h₁ h₂ h₃) :\n    ((⟨f, h₁, h₂, h₃⟩ : AlternatingMap R M N ι) : MultilinearMap R (fun i : ι => M) N) = ⟨f, @h₁, @h₂⟩ :=\n  rfl\n#align coe_multilinear_map_mk coe_multilinear_map_mk\n\n",
 "coe_multilinear_map_injective":
 "theorem coe_multilinear_map_injective :\n    function.injective (coe : AlternatingMap R M N ι → MultilinearMap R (fun i : ι => M) N) := fun x y h =>\n  ext <| MultilinearMap.congr_fun h\n#align coe_multilinear_map_injective coe_multilinear_map_injective\n\n",
 "coe_multilinear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp, norm_cast]\ntheorem coe_multilinear_map : «expr⇑ » (f : MultilinearMap R (fun i : ι => M) N) = f :=\n  rfl\n#align coe_multilinear_map coe_multilinear_map\n\n",
 "coe_mk":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_mk (f : (ι → M) → N) (h₁ h₂ h₃) : «expr⇑ » (⟨f, h₁, h₂, h₃⟩ : AlternatingMap R M N ι) = f :=\n  rfl\n#align coe_mk coe_mk\n\n",
 "coe_injective":
 "theorem coe_injective : injective (coe_fn : AlternatingMap R M N ι → (ι → M) → N) :=\n  FunLike.coe_injective\n#align coe_injective coe_injective\n\n",
 "coe_inj":
 "@[simp, norm_cast]\ntheorem coe_inj {f g : AlternatingMap R M N ι} : (f : (ι → M) → N) = g ↔ f = g :=\n  coe_injective.eq_iff\n#align coe_inj coe_inj\n\n",
 "coe_fn_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem coe_fn_smul (c : S) (f : AlternatingMap R M N ι) : «expr⇑ » («expr • » c f) = «expr • » c f :=\n  rfl\n#align coe_fn_smul coe_fn_smul\n\n",
 "coe_dom_dom_congr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n@[norm_cast]\ntheorem coe_dom_dom_congr (σ : «expr ≃ » ι ι') :\n    ↑(f.dom_dom_congr σ) = (f : MultilinearMap R (fun _ : ι => M) N).dom_dom_congr σ :=\n  MultilinearMap.ext fun v => rfl\n#align coe_dom_dom_congr coe_dom_dom_congr\n\n",
 "coe_comp_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\ntheorem coe_comp_linear_map (f : AlternatingMap R M N ι) (g : «expr →ₗ[ ] » M₂ R M) :\n    «expr⇑ » (f.comp_linear_map g) = f ∘ (· ∘ ·) g :=\n  rfl\n#align coe_comp_linear_map coe_comp_linear_map\n\n",
 "coe_comp_alternating_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_comp_alternating_map (g : «expr →ₗ[ ] » N R N₂) (f : AlternatingMap R M N ι) :\n    «expr⇑ » (g.comp_alternating_map f) = g ∘ f :=\n  rfl\n#align coe_comp_alternating_map coe_comp_alternating_map\n\n",
 "coe_alternatization":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Alternatizing a multilinear map that is already alternating results in a scale factor of `n!`,\nwhere `n` is the number of inputs. -/\ntheorem coe_alternatization [DecidableEq ι] [Fintype ι] (a : AlternatingMap R M N' ι) :\n    (↑a : MultilinearMap R (fun ι => M) N').alternatization = «expr • » (Nat.factorial (Fintype.card ι)) a :=\n  by\n  apply AlternatingMap.coe_injective\n  simp_rw [MultilinearMap.alternatization_def, ← coe_dom_dom_congr, dom_dom_congr_perm, coe_smul, smul_smul,\n    Int.units_mul_self, one_smul, Finset.sum_const, Finset.card_univ, Fintype.card_perm, ← coe_multilinear_map,\n    coe_smul]\n#align coe_alternatization coe_alternatization\n\n",
 "coe_add":
 "@[norm_cast]\ntheorem coe_add : (↑(f + f') : MultilinearMap R (fun i : ι => M) N) = f + f' :=\n  rfl\n#align coe_add coe_add\n\n",
 "alternization_map_eq_zero_of_eq_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprivate theorem alternization_map_eq_zero_of_eq_aux (m : MultilinearMap R (fun i : ι => M) N') (v : ι → M) (i j : ι)\n    (i_ne_j : i ≠ j) (hv : v i = v j) :\n    (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » σ.sign (m.dom_dom_congr σ)))\n        v =\n      0 :=\n  by\n  rw [sum_apply]\n  exact\n    Finset.sum_involution (fun σ _ => swap i j * σ) (fun σ _ => by simp [perm.sign_swap i_ne_j, apply_swap_eq_self hv])\n      (fun σ _ _ => (not_congr swap_mul_eq_iff).mpr i_ne_j) (fun σ _ => Finset.mem_univ _) fun σ _ =>\n      swap_mul_involutive i j σ\n#align alternization_map_eq_zero_of_eq_aux alternization_map_eq_zero_of_eq_aux\n\n",
 "alternatization_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem alternatization_def (m : MultilinearMap R (fun i : ι => M) N') :\n    «expr⇑ » (alternatization m) =\n      (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » σ.sign (m.dom_dom_congr σ)) :\n        _) :=\n  rfl\n#align alternatization_def alternatization_def\n\n",
 "alternatization_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem alternatization_coe (m : MultilinearMap R (fun i : ι => M) N') :\n    ↑m.alternatization =\n      (finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n          («expr • » σ.sign (m.dom_dom_congr σ)) :\n        _) :=\n  coe_injective rfl\n#align alternatization_coe alternatization_coe\n\n",
 "alternatization_apply":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem alternatization_apply (m : MultilinearMap R (fun i : ι => M) N') (v : ι → M) :\n    alternatization m v =\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » σ.sign (m.dom_dom_congr σ v)) :=\n  by simp only [alternatization_def, smul_apply, sum_apply]\n#align alternatization_apply alternatization_apply\n\n",
 "add_comp_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n@[simp]\ntheorem add_comp_linear_map (f₁ f₂ : AlternatingMap R M N ι) (g : «expr →ₗ[ ] » M₂ R M) :\n    (f₁ + f₂).comp_linear_map g = f₁.comp_linear_map g + f₂.comp_linear_map g :=\n  by\n  ext\n  simp only [comp_linear_map_apply, add_apply]\n#align add_comp_linear_map add_comp_linear_map\n\n",
 "add_apply":
 "@[simp]\ntheorem add_apply : (f + f') v = f v + f' v :=\n  rfl\n#align add_apply add_apply\n\n"}