{"unique_separable_of_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem unique_separable_of_irreducible {f : polynomial F} (hf : Irreducible f) (hp : 0 < p) (n₁ : ℕ)\n    (g₁ : polynomial F) (hg₁ : g₁.separable) (hgf₁ : expand F (p ^ n₁) g₁ = f) (n₂ : ℕ) (g₂ : polynomial F)\n    (hg₂ : g₂.separable) (hgf₂ : expand F (p ^ n₂) g₂ = f) : n₁ = n₂ ∧ g₁ = g₂ :=\n  by\n  revert g₁ g₂\n  wlog hn : n₁ ≤ n₂\n  · intro g₁ g₂ hg₁ Hg₁ hg₂ Hg₂\n    simpa only [eq_comm] using this hf hp n₂ n₁ (le_of_not_le hn) g₂ g₁ hg₂ Hg₂ hg₁ Hg₁\n  have hf0 : f ≠ 0 := hf.ne_zero\n  intros\n  rw [le_iff_exists_add] at hn\n  rcases hn with ⟨k, rfl⟩\n  rw [← hgf₁, pow_add, expand_mul, expand_inj (pow_pos hp n₁)] at hgf₂\n  subst hgf₂\n  subst hgf₁\n  rcases is_unit_or_eq_zero_of_separable_expand p k hp hg₁ with (h | rfl)\n  · rw [is_unit_iff] at h\n    rcases h with ⟨r, hr, rfl⟩\n    simp_rw [expand_C] at hf\n    exact absurd (is_unit_C.2 hr) hf.1\n  · rw [add_zero, pow_zero, expand_one]\n    constructor <;> rfl\n#align unique_separable_of_irreducible unique_separable_of_irreducible\n\n",
 "squarefree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.squarefree {p : polynomial R} (hsep : separable p) : Squarefree p :=\n  by\n  rw [multiplicity.squarefree_iff_multiplicity_le_one p]\n  intro f\n  by_cases hunit : IsUnit f\n  · exact or.inr hunit\n  exact or.inl (multiplicity_le_one_of_separable hunit hsep)\n#align separable.squarefree separable.squarefree\n\n",
 "separable_prod_X_sub_C_iff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem separable_prod_X_sub_C_iff' {ι : Sort _} {f : ι → F} {s : Finset ι} :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (X - C (f i))).separable ↔\n      ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y :=\n  ⟨fun hfs x hx y hy hfxy => hfs.inj_of_prod_X_sub_C hx hy hfxy, fun H =>\n    by\n    rw [← prod_attach]\n    exact\n      separable_prod'\n        (fun x hx y hy hxy =>\n          @pairwise_coprime_X_sub_C _ _ { x // x ∈ s } (fun x => f x)\n            (fun x y hxy => Subtype.eq <| H x.1 x.2 y.1 y.2 hxy) _ _ hxy)\n        fun _ _ => separable_X_sub_C⟩\n#align separable_prod_X_sub_C_iff' separable_prod_X_sub_C_iff'\n\n",
 "separable_prod_X_sub_C_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem separable_prod_X_sub_C_iff {ι : Sort _} [Fintype ι] {f : ι → F} :\n    (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (X - C (f i))).separable ↔\n      function.injective f :=\n  separable_prod_X_sub_C_iff'.trans <| by simp_rw [mem_univ, true_imp_iff, function.injective]\n#align separable_prod_X_sub_C_iff separable_prod_X_sub_C_iff\n\n",
 "separable_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem separable_prod' {ι : Sort _} {f : ι → polynomial R} {s : Finset ι} :\n    (∀ x ∈ s, ∀ y ∈ s, x ≠ y → IsCoprime (f x) (f y)) →\n      (∀ x ∈ s, (f x).separable) →\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n            (f x)).separable :=\n  Finset.induction_on s (fun _ _ => separable_one) fun a s has ih h1 h2 =>\n    by\n    simp_rw [Finset.forall_mem_insert, forall_and] at h1 h2; rw [prod_insert has]\n    exact\n      h2.1.mul (ih h1.2.2 h2.2)\n        (IsCoprime.prod_right fun i his => h1.1.2 i his <| ne.symm <| ne_of_mem_of_not_mem his has)\n#align separable_prod' separable_prod'\n\n",
 "separable_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr on » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem separable_prod {ι : Sort _} [Fintype ι] {f : ι → polynomial R} (h1 : Pairwise («expr on » IsCoprime f))\n    (h2 : ∀ x, (f x).separable) :\n    (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (f x)).separable :=\n  separable_prod' (fun x hx y hy hxy => h1 hxy) fun x hx => h2 x\n#align separable_prod separable_prod\n\n",
 "separable_or":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_or {f : polynomial F} (hf : Irreducible f) :\n    f.separable ∨ ¬f.separable ∧ ∃ g : polynomial F, Irreducible g ∧ expand F p g = f :=\n  if H : f.derivative = 0 then by\n    rcases p.eq_zero_or_pos with (rfl | hp)\n    · haveI := CharP.charP_to_charZero F\n      have := nat_degree_eq_zero_of_derivative_eq_zero H\n      have := (nat_degree_pos_iff_degree_pos.mpr <| degree_pos_of_irreducible hf).ne'\n      contradiction\n    haveI := is_local_ring_hom_expand F hp\n    exact\n      or.inr\n        ⟨by rw [separable_iff_derivative_ne_zero hf, Classical.not_not, H], contract p f,\n          of_irreducible_map (↑(expand F p)) (by rwa [← expand_contract p H hp.ne'] at hf), expand_contract p H hp.ne'⟩\n  else or.inl <| (separable_iff_derivative_ne_zero hf).2 H\n#align separable_or separable_or\n\n",
 "separable_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_one : (1 : polynomial R).separable :=\n  isCoprime_one_left\n#align separable_one separable_one\n\n",
 "separable_of_subsingleton":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[nontriviality]\ntheorem separable_of_subsingleton [subsingleton R] (f : polynomial R) : f.separable := by simp [separable]\n#align separable_of_subsingleton separable_of_subsingleton\n\n",
 "separable_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_map (f : «expr →+* » F K) {p : polynomial F} : (p.map f).separable ↔ p.separable := by\n  simp_rw [separable_def, derivative_map, is_coprime_map]\n#align separable_map separable_map\n\n",
 "separable_iff_derivative_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_iff_derivative_ne_zero {f : polynomial F} (hf : Irreducible f) : f.separable ↔ f.derivative ≠ 0 :=\n  ⟨fun h1 h2 => hf.not_unit <| isCoprime_zero_right.1 <| h2 ▸ h1, fun h =>\n    EuclideanDomain.isCoprime_of_dvd (mt And.right h) fun g hg1 hg2 ⟨p, hg3⟩ hg4 =>\n      let ⟨u, hu⟩ := (hf.is_unit_or_is_unit hg3).resolve_left hg1\n      have : f ∣ f.derivative := by\n        conv_lhs => rw [hg3, ← hu]\n        rwa [Units.mul_right_dvd]\n      not_lt_of_le (natDegree_le_of_dvd this h) <| natDegree_derivative_lt <| mt derivative_of_natDegree_zero h⟩\n#align separable_iff_derivative_ne_zero separable_iff_derivative_ne_zero\n\n",
 "separable_gcd_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_gcd_right {F : Type _} [Field F] {g : polynomial F} (f : polynomial F) (hg : g.separable) :\n    (EuclideanDomain.gcd f g).separable :=\n  separable.of_dvd hg (EuclideanDomain.gcd_dvd_right f g)\n#align separable_gcd_right separable_gcd_right\n\n",
 "separable_gcd_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_gcd_left {F : Type _} [Field F] {f : polynomial F} (hf : f.separable) (g : polynomial F) :\n    (EuclideanDomain.gcd f g).separable :=\n  separable.of_dvd hf (EuclideanDomain.gcd_dvd_left f g)\n#align separable_gcd_left separable_gcd_left\n\n",
 "separable_def'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_def' (f : polynomial R) : f.separable ↔ ∃ a b : polynomial R, a * f + b * f.derivative = 1 :=\n  iff.rfl\n#align separable_def' separable_def'\n\n",
 "separable_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\ntheorem separable_def (f : polynomial R) : f.separable ↔ IsCoprime f f.derivative :=\n  iff.rfl\n#align separable_def separable_def\n\n",
 "separable_X_sub_C":
 "theorem separable_X_sub_C {x : R} : separable (X - C x) := by\n  simpa only [sub_eq_add_neg, C_neg] using separable_X_add_C (-x)\n#align separable_X_sub_C separable_X_sub_C\n\n",
 "separable_X_pow_sub_C_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- If `is_unit n` in a `comm_ring R`, then `X ^ n - u` is separable for any unit `u`. -/\ntheorem separable_X_pow_sub_C_unit {n : ℕ} (u : «expr ˣ» R) (hn : IsUnit (n : R)) : separable (X ^ n - C (u : R)) :=\n  by\n  nontriviality R\n  rcases n.eq_zero_or_pos with (rfl | hpos)\n  · simpa using hn\n  apply (separable_def' (X ^ n - C (u : R))).2\n  obtain ⟨n', hn'⟩ := hn.exists_left_inv\n  refine' ⟨-C ↑u⁻¹, C ↑u⁻¹ * C n' * X, _⟩\n  rw [derivative_sub, derivative_C, sub_zero, derivative_pow X n, derivative_X, mul_one]\n  calc\n    -C ↑u⁻¹ * (X ^ n - C ↑u) + C ↑u⁻¹ * C n' * X * (↑n * X ^ (n - 1)) =\n        C (↑u⁻¹ * ↑u) - C ↑u⁻¹ * X ^ n + C ↑u⁻¹ * C (n' * ↑n) * (X * X ^ (n - 1)) :=\n      by\n      simp only [C.map_mul, C_eq_nat_cast]\n      ring\n    _ = 1 := by\n      simp only [Units.inv_mul, hn', C.map_one, mul_one, ← pow_succ, nat.sub_add_cancel (show 1 ≤ n from hpos),\n        sub_add_cancel]\n    \n#align separable_X_pow_sub_C_unit separable_X_pow_sub_C_unit\n\n",
 "separable_X_pow_sub_C":
 "/-- If `n ≠ 0` in `F`, then ` X ^ n - a` is separable for any `a ≠ 0`. -/\ntheorem separable_X_pow_sub_C {n : ℕ} (a : F) (hn : (n : F) ≠ 0) (ha : a ≠ 0) : separable (X ^ n - C a) :=\n  separable_X_pow_sub_C_unit (Units.mk0 a ha) (IsUnit.mk0 n hn)\n#align separable_X_pow_sub_C separable_X_pow_sub_C\n\n",
 "separable_X_add_C":
 "theorem separable_X_add_C (a : R) : (X + C a).separable :=\n  by\n  rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero]\n  exact isCoprime_one_right\n#align separable_X_add_C separable_X_add_C\n\n",
 "separable_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable_X : (X : polynomial R).separable :=\n  by\n  rw [separable_def, derivative_X]\n  exact isCoprime_one_right\n#align separable_X separable_X\n\n",
 "separable_C":
 "theorem separable_C (r : R) : (C r).separable ↔ IsUnit r := by\n  rw [separable_def, derivative_C, isCoprime_zero_right, is_unit_C]\n#align separable_C separable_C\n\n",
 "separable":
 "theorem is_separable.separable [is_separable F K] : ∀ x : K, (minpoly F x).separable :=\n  is_separable.separable'\n#align is_separable.separable is_separable.separable\n\n",
 "root_multiplicity_le_one_of_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem root_multiplicity_le_one_of_separable [Nontrivial R] {p : polynomial R} (hsep : separable p) (x : R) :\n    rootMultiplicity x p ≤ 1 := by\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [root_multiplicity_eq_multiplicity, dif_neg hp, ← PartENat.coe_le_coe, PartENat.natCast_get, Nat.cast_one]\n  exact multiplicity_le_one_of_separable (not_is_unit_X_sub_C _) hsep\n#align root_multiplicity_le_one_of_separable root_multiplicity_le_one_of_separable\n\n",
 "of_pow'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.of_pow' {f : polynomial R} : ∀ {n : ℕ} (h : (f ^ n).separable), IsUnit f ∨ f.separable ∧ n = 1 ∨ n = 0\n  | 0 => fun h => or.inr <| or.inr rfl\n  | 1 => fun h => or.inr <| or.inl ⟨pow_one f ▸ h, rfl⟩\n  | n + 2 => fun h => by\n    rw [pow_succ, pow_succ] at h\n    exact or.inl (isCoprime_self.1 h.is_coprime.of_mul_right_left)\n#align separable.of_pow' separable.of_pow'\n\n",
 "of_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.of_pow {f : polynomial R} (hf : ¬IsUnit f) {n : ℕ} (hn : n ≠ 0) (hfs : (f ^ n).separable) :\n    f.separable ∧ n = 1 :=\n  (hfs.of_pow'.resolve_left hf).resolve_right hn\n#align separable.of_pow separable.of_pow\n\n",
 "of_mul_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.of_mul_right {f g : polynomial R} (h : (f * g).separable) : g.separable :=\n  by\n  rw [mul_comm] at h\n  exact h.of_mul_left\n#align separable.of_mul_right separable.of_mul_right\n\n",
 "of_mul_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.of_mul_left {f g : polynomial R} (h : (f * g).separable) : f.separable :=\n  by\n  have := h.of_mul_left_left; rw [derivative_mul] at this\n  exact IsCoprime.of_mul_right_left (IsCoprime.of_add_mul_left_right this)\n#align separable.of_mul_left separable.of_mul_left\n\n",
 "of_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.of_dvd {f g : polynomial R} (hf : f.separable) (hfg : g ∣ f) : g.separable :=\n  by\n  rcases hfg with ⟨f', rfl⟩\n  exact separable.of_mul_left hf\n#align separable.of_dvd separable.of_dvd\n\n",
 "of_alg_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem is_separable.of_alg_hom (E' : Type _) [Field E'] [Algebra F E'] (f : «expr →ₐ[ ] » E F E') [is_separable F E'] :\n    is_separable F E := by\n  letI : Algebra E E' := RingHom.toAlgebra f.to_ring_hom\n  haveI : IsScalarTower F E E' := IsScalarTower.of_algebraMap_eq fun x => (f.commutes x).symm\n  exact is_separable_tower_bot_of_is_separable F E E'\n#align is_separable.of_alg_hom is_separable.of_alg_hom\n\n",
 "not_separable_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem not_separable_zero [Nontrivial R] : ¬separable (0 : polynomial R) :=\n  by\n  rintro ⟨x, y, h⟩\n  simpa only [derivative_zero, MulZeroClass.mul_zero, add_zero, zero_ne_one] using h\n#align not_separable_zero not_separable_zero\n\n",
 "nodup_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nodup_roots {p : polynomial R} (hsep : separable p) : p.roots.nodup :=\n  Multiset.nodup_iff_count_le_one.mpr (count_roots_le_one hsep)\n#align nodup_roots nodup_roots\n\n",
 "nodup_of_separable_prod":
 "theorem nodup_of_separable_prod [Nontrivial R] {s : Multiset R}\n    (hs : separable (Multiset.map (fun a => X - C a) s).prod) : s.nodup :=\n  by\n  rw [Multiset.nodup_iff_ne_cons_cons]\n  rintro a t rfl\n  refine' not_is_unit_X_sub_C a (is_unit_of_self_mul_dvd_separable hs _)\n  simpa only [Multiset.map_cons, Multiset.prod_cons] using mul_dvd_mul_left _ (dvd_mul_right _ _)\n#align nodup_of_separable_prod nodup_of_separable_prod\n\n",
 "multiplicity_le_one_of_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem multiplicity_le_one_of_separable {p q : polynomial R} (hq : ¬IsUnit q) (hsep : separable p) :\n    multiplicity q p ≤ 1 := by\n  contrapose! hq\n  apply is_unit_of_self_mul_dvd_separable hsep\n  rw [← sq]\n  apply multiplicity.pow_dvd_of_le_multiplicity\n  simpa only [Nat.cast_one, Nat.cast_bit0] using PartENat.add_one_le_of_lt hq\n#align multiplicity_le_one_of_separable multiplicity_le_one_of_separable\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.mul {f g : polynomial R} (hf : f.separable) (hg : g.separable) (h : IsCoprime f g) :\n    (f * g).separable := by\n  rw [separable_def, derivative_mul]\n  exact ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)\n#align separable.mul separable.mul\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem separable.map {p : polynomial R} (h : p.separable) {f : «expr →+* » R S} : (p.map f).separable :=\n  let ⟨a, b, H⟩ := h\n  ⟨a.map f, b.map f, by\n    rw [derivative_map, ← Polynomial.map_mul, ← Polynomial.map_mul, ← Polynomial.map_add, H, Polynomial.map_one]⟩\n#align separable.map separable.map\n\n",
 "is_unit_or_eq_zero_of_separable_expand":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_unit_or_eq_zero_of_separable_expand {f : polynomial F} (n : ℕ) (hp : 0 < p)\n    (hf : (expand F (p ^ n) f).separable) : IsUnit f ∨ n = 0 :=\n  by\n  rw [or_iff_not_imp_right]\n  rintro hn : n ≠ 0\n  have hf2 : (expand F (p ^ n) f).derivative = 0 := by\n    rw [derivative_expand, Nat.cast_pow, CharP.cast_eq_zero, zero_pow hn.bot_lt, MulZeroClass.zero_mul,\n      MulZeroClass.mul_zero]\n  rw [separable_def, hf2, isCoprime_zero_right, is_unit_iff] at hf\n  rcases hf with ⟨r, hr, hrf⟩\n  rw [eq_comm, expand_eq_C (pow_pos hp _)] at hrf\n  rwa [hrf, is_unit_C]\n#align is_unit_or_eq_zero_of_separable_expand is_unit_or_eq_zero_of_separable_expand\n\n",
 "is_unit_of_self_mul_dvd_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_unit_of_self_mul_dvd_separable {p q : polynomial R} (hp : p.separable) (hq : q * q ∣ p) : IsUnit q :=\n  by\n  obtain ⟨p, rfl⟩ := hq\n  apply is_coprime_self.mp\n  have : IsCoprime (q * (q * p)) (q * (q.derivative * p + q.derivative * p + q * p.derivative)) :=\n    by\n    simp only [← mul_assoc, mul_add]\n    convert hp\n    rw [derivative_mul, derivative_mul]\n    ring\n  exact IsCoprime.of_mul_right_left (IsCoprime.of_mul_left_left this)\n#align is_unit_of_self_mul_dvd_separable is_unit_of_self_mul_dvd_separable\n\n",
 "is_separable_tower_top_of_is_separable":
 "-- See note [lower instance priority]\ntheorem is_separable_tower_top_of_is_separable [is_separable F E] : is_separable K E :=\n  ⟨fun x => is_integral_of_is_scalar_tower (is_separable.is_integral F x), fun x =>\n    (is_separable.separable F x).map.of_dvd (minpoly.dvd_map_of_is_scalar_tower _ _ _)⟩\n#align is_separable_tower_top_of_is_separable is_separable_tower_top_of_is_separable\n\n",
 "is_separable_tower_bot_of_is_separable":
 "theorem is_separable_tower_bot_of_is_separable [h : is_separable F E] : is_separable F K :=\n  is_separable_iff.2 fun x =>\n    by\n    refine' (is_separable_iff.1 h (algebraMap K E x)).imp is_integral_tower_bot_of_is_integral_field fun hs => _\n    obtain ⟨q, hq⟩ := minpoly.dvd F x ((aeval_algebra_map_eq_zero_iff _ _ _).mp (minpoly.aeval F ((algebraMap K E) x)))\n    rw [hq] at hs\n    exact hs.of_mul_left\n#align is_separable_tower_bot_of_is_separable is_separable_tower_bot_of_is_separable\n\n",
 "is_separable_iff":
 "theorem is_separable_iff : is_separable F K ↔ ∀ x : K, is_integral F x ∧ (minpoly F x).separable :=\n  ⟨fun h x => ⟨@is_separable.is_integral F _ _ _ h x, @is_separable.separable F _ _ _ h x⟩, fun h =>\n    ⟨fun x => (h x).1, fun x => (h x).2⟩⟩\n#align is_separable_iff is_separable_iff\n\n",
 "is_integral":
 "-- TODO: refactor to allow transcendental extensions?\n-- See: https://en.wikipedia.org/wiki/Separable_extension#Separability_of_transcendental_extensions\n-- Note that right now a Galois extension (class `is_galois`) is defined to be an extension which\n-- is separable and normal, so if the definition of separable changes here at some point\n-- to allow non-algebraic extensions, then the definition of `is_galois` must also be changed.\ntheorem is_separable.is_integral [is_separable F K] : ∀ x : K, is_integral F x :=\n  is_separable.is_integral'\n#align is_separable.is_integral is_separable.is_integral\n\n",
 "is_coprime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem separable.is_coprime {f g : polynomial R} (h : (f * g).separable) : IsCoprime f g :=\n  by\n  have := h.of_mul_left_left; rw [derivative_mul] at this\n  exact IsCoprime.of_mul_right_right (IsCoprime.of_add_mul_left_right this)\n#align separable.is_coprime separable.is_coprime\n\n",
 "injective_of_prod_X_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\ntheorem separable.injective_of_prod_X_sub_C [Nontrivial R] {ι : Sort _} [Fintype ι] {f : ι → R}\n    (hfs :\n      (finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (X - C (f i))).separable) :\n    function.injective f := fun x y hfxy => hfs.inj_of_prod_X_sub_C (mem_univ _) (mem_univ _) hfxy\n#align separable.injective_of_prod_X_sub_C separable.injective_of_prod_X_sub_C\n\n",
 "inj_of_prod_X_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\ntheorem separable.inj_of_prod_X_sub_C [Nontrivial R] {ι : Sort _} {f : ι → R} {s : Finset ι}\n    (hfs :\n      (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (X - C (f i))).separable)\n    {x y : ι} (hx : x ∈ s) (hy : y ∈ s) (hfxy : f x = f y) : x = y :=\n  by\n  by_contra hxy\n  rw [← insert_erase hx, prod_insert (not_mem_erase _ _), ← insert_erase (mem_erase_of_ne_of_mem (ne.symm hxy) hy),\n    prod_insert (not_mem_erase _ _), ← mul_assoc, hfxy, ← sq] at hfs\n  cases (hfs.of_mul_left.of_pow (not_is_unit_X_sub_C _) two_ne_zero).2\n#align separable.inj_of_prod_X_sub_C separable.inj_of_prod_X_sub_C\n\n",
 "exists_separable_of_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_separable_of_irreducible {f : polynomial F} (hf : Irreducible f) (hp : p ≠ 0) :\n    ∃ (n : ℕ)(g : polynomial F), g.separable ∧ expand F (p ^ n) g = f :=\n  by\n  replace hp : p.prime := (CharP.char_is_prime_or_zero F p).resolve_right hp\n  induction' hn : f.nat_degree using nat.strong_induction_on with N ih generalizing f\n  rcases separable_or p hf with (h | ⟨h1, g, hg, hgf⟩)\n  · refine' ⟨0, f, h, _⟩\n    rw [pow_zero, expand_one]\n  · cases' N with N\n    · rw [nat_degree_eq_zero_iff_degree_le_zero, degree_le_zero_iff] at hn\n      rw [hn, separable_C, isUnit_iff_ne_zero, Classical.not_not] at h1\n      have hf0 : f ≠ 0 := hf.ne_zero\n      rw [h1, C_0] at hn\n      exact absurd hn hf0\n    have hg1 : g.nat_degree * p = N.succ := by rwa [← nat_degree_expand, hgf]\n    have hg2 : g.nat_degree ≠ 0 := by\n      intro this\n      rw [this, MulZeroClass.zero_mul] at hg1\n      cases hg1\n    have hg3 : g.nat_degree < N.succ := by\n      rw [← mul_one g.nat_degree, ← hg1]\n      exact nat.mul_lt_mul_of_pos_left hp.one_lt hg2.bot_lt\n    rcases ih _ hg3 hg rfl with ⟨n, g, hg4, rfl⟩\n    refine' ⟨n + 1, g, hg4, _⟩\n    rw [← hgf, expand_expand, pow_succ]\n#align exists_separable_of_irreducible exists_separable_of_irreducible\n\n",
 "exists_finset_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_finset_of_splits (i : «expr →+* » F K) {f : polynomial F} (sep : separable f) (sp : Splits i f) :\n    ∃ s : Finset K, f.map i = C (i f.leading_coeff) * s.prod fun a : K => X - C a :=\n  by\n  obtain ⟨s, h⟩ := (splits_iff_exists_multiset _).1 sp\n  use s.to_finset\n  rw [h, Finset.prod_eq_multiset_prod, ← Multiset.toFinset_eq]\n  apply nodup_of_separable_prod\n  apply separable.of_mul_right\n  rw [← h]\n  exact sep.map\n#align exists_finset_of_splits exists_finset_of_splits\n\n",
 "eq_X_sub_C_of_separable_of_root_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_X_sub_C_of_separable_of_root_eq {x : F} {h : polynomial F} (h_sep : h.separable) (h_root : h.eval x = 0)\n    (h_splits : Splits i h) (h_roots : ∀ y ∈ (h.map i).roots, y = i x) : h = C (leadingCoeff h) * (X - C x) :=\n  by\n  have h_ne_zero : h ≠ 0 := by\n    rintro rfl\n    exact not_separable_zero h_sep\n  apply Polynomial.eq_X_sub_C_of_splits_of_single_root i h_splits\n  apply finset.mk.inj\n  · change _ = {i x}\n    rw [Finset.eq_singleton_iff_unique_mem]\n    constructor\n    · apply finset.mem_mk.mpr\n      rw [mem_roots (show h.map i ≠ 0 from map_ne_zero h_ne_zero)]\n      rw [is_root.def, ← eval₂_eq_eval_map, eval₂_hom, h_root]\n      exact RingHom.map_zero i\n    · exact h_roots\n  · exact nodup_roots (separable.map h_sep)\n#align eq_X_sub_C_of_separable_of_root_eq eq_X_sub_C_of_separable_of_root_eq\n\n",
 "count_roots_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem count_roots_le_one {p : polynomial R} (hsep : separable p) (x : R) : p.roots.count x ≤ 1 :=\n  by\n  rw [count_roots p]\n  exact root_multiplicity_le_one_of_separable hsep x\n#align count_roots_le_one count_roots_le_one\n\n",
 "card_root_set_eq_nat_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem card_root_set_eq_nat_degree [Algebra F K] {p : polynomial F} (hsep : p.separable)\n    (hsplit : Splits (algebraMap F K) p) : Fintype.card (p.root_set K) = p.nat_degree :=\n  by\n  simp_rw [root_set_def, Finset.coe_sort_coe, Fintype.card_coe]\n  rw [Multiset.toFinset_card_of_nodup, ← nat_degree_eq_card_roots hsplit]\n  exact nodup_roots hsep.map\n#align card_root_set_eq_nat_degree card_root_set_eq_nat_degree\n\n",
 "card_of_power_basis":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom.card_of_power_basis (pb : power_basis K S) (h_sep : (minpoly K pb.gen).separable)\n    (h_splits : (minpoly K pb.gen).splits (algebraMap K L)) :\n    @Fintype.card («expr →ₐ[ ] » S K L) (power_basis.alg_hom.fintype pb) = pb.dim :=\n  by\n  let s := ((minpoly K pb.gen).map (algebraMap K L)).roots.to_finset\n  have H := fun x => Multiset.mem_toFinset\n  rw [Fintype.card_congr pb.lift_equiv', Fintype.card_of_subtype s H, ← pb.nat_degree_minpoly,\n    nat_degree_eq_card_roots h_splits, Multiset.toFinset_card_of_nodup]\n  exact nodup_roots ((separable_map (algebraMap K L)).mpr h_sep)\n#align alg_hom.card_of_power_basis alg_hom.card_of_power_basis\n\n",
 "X_pow_sub_one_separable_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n-- this can possibly be strengthened to making `separable_X_pow_sub_C_unit` a\n-- bi-implication, but it is nontrivial!\n/-- In a field `F`, `X ^ n - 1` is separable iff `↑n ≠ 0`. -/\ntheorem X_pow_sub_one_separable_iff {n : ℕ} : (X ^ n - 1 : polynomial F).separable ↔ (n : F) ≠ 0 :=\n  by\n  refine' ⟨_, fun h => separable_X_pow_sub_C_unit 1 (IsUnit.mk0 (↑n) h)⟩\n  rw [separable_def', derivative_sub, derivative_X_pow, derivative_one, sub_zero]\n  -- Suppose `(n : F) = 0`, then the derivative is `0`, so `X ^ n - 1` is a unit, contradiction.\n  rintro (h : IsCoprime _ _) hn'\n  rw [hn', C_0, MulZeroClass.zero_mul, isCoprime_zero_right] at h\n  exact not_is_unit_X_pow_sub_one F n h\n#align X_pow_sub_one_separable_iff X_pow_sub_one_separable_iff\n\n"}