{"transfer_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem alg_equiv.transfer_normal (f : «expr ≃ₐ[ ] » E F E') : normal F E ↔ normal F E' :=\n  ⟨fun h => normal.of_alg_equiv f, fun h => normal.of_alg_equiv f.symm⟩\n#align alg_equiv.transfer_normal alg_equiv.transfer_normal\n\n",
 "tower_top_of_normal":
 "theorem normal.tower_top_of_normal [h : normal F E] : normal K E :=\n  normal_iff.2 fun x => by\n    cases' h.out x with hx hhx\n    rw [algebra_map_eq F K E] at hhx\n    exact\n      ⟨is_integral_of_is_scalar_tower hx,\n        polynomial.splits_of_splits_of_dvd (algebra_map K E) (polynomial.map_ne_zero (minpoly.ne_zero hx))\n          ((polynomial.splits_map_iff (algebra_map F K) (algebra_map K E)).mpr hhx)\n          (minpoly.dvd_map_of_is_scalar_tower F K x)⟩\n#align normal.tower_top_of_normal normal.tower_top_of_normal\n\n",
 "splits":
 "theorem normal.splits (h : normal F K) (x : K) : splits (algebra_map F K) (minpoly F x) :=\n  normal.splits' x\n#align normal.splits normal.splits\n\n",
 "restrict_scalars_normal":
 "@[simp]\ntheorem restrict_scalars_normal {E : intermediate_field K L} : normal F (E.restrict_scalars F) ↔ normal F E :=\n  iff.rfl\n#align restrict_scalars_normal restrict_scalars_normal\n\n",
 "restrict_scalars_eq_supr_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem restrict_scalars_eq_supr_adjoin [h : normal F L] :\n    (normal_closure F K L).restrict_scalars F =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        (adjoin F ((minpoly F x).root_set L)) :=\n  by\n  refine' le_antisymm (supᵢ_le _) (supᵢ_le fun x => adjoin_le_iff.mpr fun y hy => _)\n  · rintro f _ ⟨x, rfl⟩\n    refine' le_supᵢ (fun x => adjoin F ((minpoly F x).root_set L)) x (subset_adjoin F ((minpoly F x).root_set L) _)\n    rw [mem_root_set_of_ne, alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom, polynomial.aeval_alg_hom_apply,\n      minpoly.aeval, map_zero]\n    exact\n      minpoly.ne_zero ((is_integral_algebra_map_iff (algebra_map K L).injective).mp (h.is_integral (algebra_map K L x)))\n  · rw [polynomial.root_set, Finset.mem_coe, Multiset.mem_toFinset] at hy\n    let g :=\n      (alg_hom_adjoin_integral_equiv F\n            ((is_integral_algebra_map_iff (algebra_map K L).injective).mp (h.is_integral (algebra_map K L x)))).symm\n        ⟨y, hy⟩\n    refine'\n      le_supᵢ (fun f : «expr →ₐ[ ] » K F L => f.field_range) ((g.lift_normal L).comp (is_scalar_tower.to_alg_hom F K L))\n        ⟨x, (g.lift_normal_commutes L (adjoin_simple.gen F x)).trans _⟩\n    rw [algebra.id.map_eq_id, RingHom.id_apply]\n    apply power_basis.lift_gen\n#align restrict_scalars_eq_supr_adjoin restrict_scalars_eq_supr_adjoin\n\n",
 "restrict_normal_trans":
 "theorem alg_equiv.restrict_normal_trans [normal F E] :\n    (χ.trans ω).restrict_normal E = (χ.restrict_normal E).trans (ω.restrict_normal E) :=\n  alg_equiv.ext fun _ =>\n    (algebra_map E K₃).injective (by simp only [alg_equiv.trans_apply, alg_equiv.restrict_normal_commutes])\n#align alg_equiv.restrict_normal_trans alg_equiv.restrict_normal_trans\n\n",
 "restrict_normal_hom_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem alg_equiv.restrict_normal_hom_surjective [normal F K₁] [normal F E] :\n    function.surjective (alg_equiv.restrict_normal_hom K₁ : «expr ≃ₐ[ ] » E F E → «expr ≃ₐ[ ] » K₁ F K₁) := fun χ =>\n  ⟨χ.lift_normal E, χ.restrict_lift_normal E⟩\n#align alg_equiv.restrict_normal_hom_surjective alg_equiv.restrict_normal_hom_surjective\n\n",
 "restrict_normal_comp":
 "theorem alg_hom.restrict_normal_comp [normal F E] :\n    (ψ.restrict_normal E).comp (ϕ.restrict_normal E) = (ψ.comp ϕ).restrict_normal E :=\n  alg_hom.ext fun _ =>\n    (algebra_map E K₃).injective (by simp only [alg_hom.comp_apply, alg_hom.restrict_normal_commutes])\n#align alg_hom.restrict_normal_comp alg_hom.restrict_normal_comp\n\n",
 "restrict_normal_commutes":
 "@[simp]\ntheorem alg_equiv.restrict_normal_commutes [normal F E] (x : E) :\n    algebra_map E K₂ (χ.restrict_normal E x) = χ (algebra_map E K₁ x) :=\n  χ.to_alg_hom.restrict_normal_commutes E x\n#align alg_equiv.restrict_normal_commutes alg_equiv.restrict_normal_commutes\n\n",
 "restrict_lift_normal":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n@[simp]\ntheorem alg_equiv.restrict_lift_normal (χ : «expr ≃ₐ[ ] » K₁ F K₁) [normal F K₁] [normal F E] :\n    (χ.lift_normal E).restrict_normal K₁ = χ :=\n  alg_equiv.ext fun x =>\n    (algebra_map K₁ E).injective (eq.trans (alg_equiv.restrict_normal_commutes _ K₁ x) (χ.lift_normal_commutes E x))\n#align alg_equiv.restrict_lift_normal alg_equiv.restrict_lift_normal\n\n",
 "out":
 "theorem normal.out : normal F K → ∀ x : K, is_integral F x ∧ splits (algebra_map F K) (minpoly F x) :=\n  normal_iff.1\n#align normal.out normal.out\n\n",
 "of_is_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem normal.of_is_splitting_field (p : polynomial F) [hFEp : is_splitting_field F E p] : normal F E :=\n  by\n  by_cases hp : p = 0\n  · have : is_splitting_field F F p := by\n      rw [hp]\n      exact ⟨splits_zero _, subsingleton.elim _ _⟩\n    exact\n      (alg_equiv.transfer_normal ((is_splitting_field.alg_equiv F p).trans (is_splitting_field.alg_equiv E p).symm)).mp\n        (normal_self F)\n  refine' normal_iff.2 fun x => _\n  haveI hFE : finite_dimensional F E := is_splitting_field.finite_dimensional E p\n  have Hx : is_integral F x := is_integral_of_noetherian (is_noetherian.iff_fg.2 hFE) x\n  refine' ⟨Hx, or.inr _⟩\n  rintro q q_irred ⟨r, hr⟩\n  let D := adjoin_root q\n  haveI := fact.mk q_irred\n  let pbED := adjoin_root.power_basis q_irred.ne_zero\n  haveI : finite_dimensional E D := power_basis.finite_dimensional pbED\n  have finrankED : finite_dimensional.finrank E D = q.nat_degree := power_basis.finrank pbED\n  letI : algebra F D := ring_hom.to_algebra ((algebra_map E D).comp (algebra_map F E))\n  haveI : IsScalarTower F E D := of_algebra_map_eq fun _ => rfl\n  haveI : finite_dimensional F D := finite_dimensional.trans F E D\n  suffices nonempty («expr →ₐ[ ] » D F E) by\n    cases' this with ϕ\n    rw [← WithBot.coe_one, degree_eq_iff_nat_degree_eq q_irred.ne_zero, ← finrankED]\n    have nat_lemma : ∀ a b c : ℕ, a * b = c → c ≤ a → 0 < c → b = 1 :=\n      by\n      intro a b c h1 h2 h3\n      nlinarith\n    exact\n      nat_lemma _ _ _ (finite_dimensional.finrank_mul_finrank F E D)\n        (linear_map.finrank_le_finrank_of_injective\n          (show function.injective ϕ.to_linear_map from ϕ.to_ring_hom.injective))\n        finite_dimensional.finrank_pos\n  let C := adjoin_root (minpoly F x)\n  haveI Hx_irred := fact.mk (minpoly.irreducible Hx)\n  letI : algebra C D :=\n    ring_hom.to_algebra\n      (adjoin_root.lift (algebra_map F D) (adjoin_root.root q)\n        (by\n          rw [algebra_map_eq F E D, ← eval₂_map, hr, adjoin_root.algebra_map_eq, eval₂_mul, adjoin_root.eval₂_root,\n            zero_mul]))\n  letI : algebra C E := ring_hom.to_algebra (adjoin_root.lift (algebra_map F E) x (minpoly.aeval F x))\n  haveI : IsScalarTower F C D := of_algebra_map_eq fun x => (adjoin_root.lift_of _).symm\n  haveI : IsScalarTower F C E := of_algebra_map_eq fun x => (adjoin_root.lift_of _).symm\n  suffices nonempty («expr →ₐ[ ] » D C E) by exact nonempty.map (alg_hom.restrict_scalars F) this\n  let S : set D := ((p.map (algebra_map F E)).roots.map (algebra_map E D)).to_finset\n  suffices «expr⊤» ≤ intermediate_field.adjoin C S\n    by\n    refine' intermediate_field.alg_hom_mk_adjoin_splits' (top_le_iff.mp this) fun y hy => _\n    rcases multiset.mem_map.mp (multiset.mem_to_finset.mp hy) with ⟨z, hz1, hz2⟩\n    have Hz : is_integral F z := is_integral_of_noetherian (is_noetherian.iff_fg.2 hFE) z\n    use show is_integral C y from is_integral_of_noetherian (is_noetherian.iff_fg.2 (finite_dimensional.right F C D)) y\n    apply splits_of_splits_of_dvd (algebra_map C E) (map_ne_zero (minpoly.ne_zero Hz))\n    · rw [splits_map_iff, ← algebra_map_eq F C E]\n      exact\n        splits_of_splits_of_dvd _ hp hFEp.splits\n          (minpoly.dvd F z (eq.trans (eval₂_eq_eval_map _) ((mem_roots (map_ne_zero hp)).mp hz1)))\n    · apply minpoly.dvd\n      rw [← hz2, aeval_def, eval₂_map, ← algebra_map_eq F C D, algebra_map_eq F E D, ← hom_eval₂, ← aeval_def,\n        minpoly.aeval F z, RingHom.map_zero]\n  rw [← intermediate_field.to_subalgebra_le_to_subalgebra, intermediate_field.top_to_subalgebra]\n  apply ge_trans (intermediate_field.algebra_adjoin_le_adjoin C S)\n  suffices (algebra.adjoin C S).restrict_scalars F = (algebra.adjoin E {adjoin_root.root q}).restrict_scalars F\n    by\n    rw [adjoin_root.adjoin_root_eq_top, subalgebra.restrict_scalars_top, ← @subalgebra.restrict_scalars_top F C] at this\n    exact top_le_iff.mpr (subalgebra.restrict_scalars_injective F this)\n  dsimp only [S]\n  rw [← Finset.image_toFinset, Finset.coe_image]\n  apply eq.trans (algebra.adjoin_res_eq_adjoin_res F E C D hFEp.adjoin_roots adjoin_root.adjoin_root_eq_top)\n  rw [Set.image_singleton, ring_hom.algebra_map_to_algebra, adjoin_root.lift_root]\n#align normal.of_is_splitting_field normal.of_is_splitting_field\n\n",
 "of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem normal.of_alg_equiv [h : normal F E] (f : «expr ≃ₐ[ ] » E F E') : normal F E' :=\n  normal_iff.2 fun x => by\n    cases' h.out (f.symm x) with hx hhx\n    have H := map_is_integral f.to_alg_hom hx\n    rw [alg_equiv.to_alg_hom_eq_coe, alg_equiv.coe_alg_hom, alg_equiv.apply_symm_apply] at H\n    use H\n    apply polynomial.splits_of_splits_of_dvd (algebra_map F E') (minpoly.ne_zero hx)\n    · rw [← alg_hom.comp_algebra_map f.to_alg_hom]\n      exact polynomial.splits_comp_of_splits (algebra_map F E) f.to_alg_hom.to_ring_hom hhx\n    · apply minpoly.dvd _ _\n      rw [← AddEquiv.map_eq_zero_iff f.symm.to_add_equiv]\n      exact\n        eq.trans (polynomial.aeval_alg_hom_apply f.symm.to_alg_hom x (minpoly F (f.symm x))).symm (minpoly.aeval _ _)\n#align normal.of_alg_equiv normal.of_alg_equiv\n\n",
 "normal_iff":
 "theorem normal_iff : normal F K ↔ ∀ x : K, is_integral F x ∧ splits (algebra_map F K) (minpoly F x) :=\n  ⟨fun h x => ⟨h.is_integral x, h.splits x⟩, fun h => ⟨fun x => (h x).1.is_algebraic F, fun x => (h x).2⟩⟩\n#align normal_iff normal_iff\n\n",
 "normal_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom.normal_bijective [h : normal F E] (ϕ : «expr →ₐ[ ] » E F K) : function.bijective ϕ :=\n  ⟨ϕ.to_ring_hom.injective, fun x => by\n    letI : algebra E K := ϕ.to_ring_hom.to_algebra\n    obtain ⟨h1, h2⟩ := h.out (algebra_map K E x)\n    cases'\n      minpoly.mem_range_of_degree_eq_one E x\n        (h2.def.resolve_left (minpoly.ne_zero h1)\n          (minpoly.irreducible\n            (is_integral_of_is_scalar_tower ((is_integral_algebra_map_iff (algebra_map K E).injective).mp h1)))\n          (minpoly.dvd E x\n            ((algebra_map K E).injective\n              (by\n                rw [RingHom.map_zero, aeval_map_algebra_map, ← aeval_algebra_map_apply]\n                exact minpoly.aeval F (algebra_map K E x))))) with\n      y hy\n    exact ⟨y, hy⟩⟩\n#align alg_hom.normal_bijective alg_hom.normal_bijective\n\n",
 "lift_normal_commutes":
 "@[simp]\ntheorem alg_equiv.lift_normal_commutes [normal F E] (x : K₁) :\n    χ.lift_normal E (algebra_map K₁ E x) = algebra_map K₂ E (χ x) :=\n  χ.to_alg_hom.lift_normal_commutes E x\n#align alg_equiv.lift_normal_commutes alg_equiv.lift_normal_commutes\n\n",
 "is_solvable_of_is_scalar_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_solvable_of_is_scalar_tower [normal F K₁] [h1 : is_solvable («expr ≃ₐ[ ] » K₁ F K₁)]\n    [h2 : is_solvable («expr ≃ₐ[ ] » E K₁ E)] : is_solvable («expr ≃ₐ[ ] » E F E) :=\n  by\n  let f : «expr →* » («expr ≃ₐ[ ] » E K₁ E) («expr ≃ₐ[ ] » E F E) :=\n    { to_fun := fun ϕ =>\n        alg_equiv.of_alg_hom (ϕ.to_alg_hom.restrict_scalars F) (ϕ.symm.to_alg_hom.restrict_scalars F)\n          (alg_hom.ext fun x => ϕ.apply_symm_apply x) (alg_hom.ext fun x => ϕ.symm_apply_apply x)\n      map_one' := alg_equiv.ext fun _ => rfl\n      map_mul' := fun _ _ => alg_equiv.ext fun _ => rfl }\n  refine'\n    solvable_of_ker_le_range f (alg_equiv.restrict_normal_hom K₁) fun ϕ hϕ =>\n      ⟨{ ϕ with commutes' := fun x => _ }, alg_equiv.ext fun _ => rfl⟩\n  exact eq.trans (ϕ.restrict_normal_commutes K₁ x).symm (congr_arg _ (alg_equiv.ext_iff.mp hϕ x))\n#align is_solvable_of_is_scalar_tower is_solvable_of_is_scalar_tower\n\n",
 "is_integral":
 "theorem normal.is_integral (h : normal F K) (x : K) : is_integral F x :=\n  is_algebraic_iff_is_integral.mp (h.is_algebraic x)\n#align normal.is_integral normal.is_integral\n\n",
 "is_algebraic":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Thomas Browning, Patrick Lutz\n-/\ntheorem normal.is_algebraic (h : normal F K) (x : K) : is_algebraic F x :=\n  normal.is_algebraic' x\n#align normal.is_algebraic normal.is_algebraic\n\n",
 "exists_is_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem normal.exists_is_splitting_field [h : normal F K] [finite_dimensional F K] :\n    ∃ p : polynomial F, is_splitting_field F K p :=\n  by\n  let s := basis.of_vector_space F K\n  refine'\n    ⟨finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (minpoly F (s x)),\n      splits_prod _ fun x hx => h.splits (s x), subalgebra.to_submodule.injective _⟩\n  rw [algebra.top_to_submodule, eq_top_iff, ← s.span_eq, submodule.span_le, Set.range_subset_iff]\n  refine' fun x =>\n    algebra.subset_adjoin\n      (multiset.mem_to_finset.mpr <|\n        (mem_roots <| mt (polynomial.map_eq_zero <| algebra_map F K).1 <| finset.prod_ne_zero_iff.2 fun x hx => _).2 _)\n  · exact minpoly.ne_zero (h.is_integral (s x))\n  rw [is_root.def, eval_map, ← aeval_def, alg_hom.map_prod]\n  exact finset.prod_eq_zero (finset.mem_univ _) (minpoly.aeval _ _)\n#align normal.exists_is_splitting_field normal.exists_is_splitting_field\n\n"}