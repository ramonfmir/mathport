{"to_alg_hom_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- `mul_semiring_action.to_alg_hom` is bijective. -/\ntheorem to_alg_hom_bijective (G : Type u) (F : Type v) [group G] [Field F] [Finite G] [MulSemiringAction G F]\n    [FaithfulSMul G F] :\n    function.bijective (mul_semiring_action.to_alg_hom _ _ : G → «expr →ₐ[ ] » F (subfield G F) F) :=\n  by\n  cases nonempty_fintype G\n  rw [fintype.bijective_iff_injective_and_card]\n  constructor\n  · exact mul_semiring_action.to_alg_hom_injective _ F\n  · apply le_antisymm\n    · exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F)\n    · rw [← finrank_eq_card G F]\n      exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _)\n#align to_alg_hom_bijective to_alg_hom_bijective\n\n",
 "smul_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- Why is this so slow?\n@[simp]\ntheorem smul_polynomial (m : M) (p : polynomial (fixed_points.subfield M F)) : «expr • » m p = p :=\n  polynomial.induction_on p (fun x => by rw [polynomial.smul_C, smul]) (fun p q ihp ihq => by rw [smul_add, ihp, ihq])\n    fun n x ih => by rw [smul_mul', polynomial.smul_C, smul, smul_pow', polynomial.smul_X]\n#align smul_polynomial smul_polynomial\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n-- we use `subfield.copy` so that the underlying set is `fixed_points M F`\n@[simp]\ntheorem smul (m : M) (x : fixed_points.subfield M F) : «expr • » m x = x :=\n  subtype.eq <| x.2 m\n#align smul smul\n\n",
 "of_eval₂":
 "theorem of_eval₂ (f : polynomial (fixed_points.subfield G F))\n    (hf : polynomial.eval₂ (subfield.subtype <| fixed_points.subfield G F) x f = 0) : minpoly G F x ∣ f :=\n  by\n  erw [← polynomial.map_dvd_map' (subfield.subtype <| fixed_points.subfield G F), minpoly,\n    polynomial.map_to_subring _ (subfield G F).to_subring, prod_X_sub_smul]\n  refine'\n    fintype.prod_dvd_of_coprime (polynomial.pairwise_coprime_X_sub_C <| mul_action.injective_of_quotient_stabilizer G x)\n      fun y => quotient_group.induction_on y fun g => _\n  rw [polynomial.dvd_iff_is_root, polynomial.is_root.def, mul_action.of_quotient_stabilizer_mk, polynomial.eval_smul', ←\n    subfield.to_subring.subtype_eq_subtype, ←\n    is_invariant_subring.coe_subtype_hom' G (fixed_points.subfield G F).to_subring, ←\n    mul_semiring_action_hom.coe_polynomial, ← MulSemiringActionHom.map_smul, smul_polynomial,\n    mul_semiring_action_hom.coe_polynomial, is_invariant_subring.coe_subtype_hom', polynomial.eval_map,\n    subfield.to_subring.subtype_eq_subtype, hf, smul_zero]\n#align of_eval₂ of_eval₂\n\n",
 "ne_one":
 "theorem ne_one : minpoly G F x ≠ (1 : polynomial (fixed_points.subfield G F)) := fun H =>\n  have := eval₂ G F x\n  (one_ne_zero : (1 : F) ≠ 0) <| by rwa [H, polynomial.eval₂_one] at this\n#align ne_one ne_one\n\n",
 "monic":
 "theorem monic : (minpoly G F x).monic :=\n  by\n  simp only [minpoly, polynomial.monic_to_subring]\n  exact prod_X_sub_smul.monic G F x\n#align monic monic\n\n",
 "minpoly_eq_minpoly":
 "theorem minpoly_eq_minpoly : minpoly G F x = _root_.minpoly (fixed_points.subfield G F) x :=\n  minpoly.eq_of_irreducible_of_monic (minpoly.irreducible G F x) (minpoly.eval₂ G F x) (minpoly.monic G F x)\n#align minpoly_eq_minpoly minpoly_eq_minpoly\n\n",
 "linear_independent_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_independent_to_linear_map (R : Type u) (A : Type v) (B : Type w) [CommSemiring R] [Ring A] [algebra R A]\n    [CommRing B] [IsDomain B] [algebra R B] :\n    linear_independent B (alg_hom.to_linear_map : «expr →ₐ[ ] » A R B → «expr →ₗ[ ] » A R B) :=\n  have : linear_independent B (linear_map.lto_fun R A B ∘ alg_hom.to_linear_map) :=\n    ((linear_independent_monoid_hom A B).comp (coe : «expr →ₐ[ ] » A R B → «expr →* » A B) fun f g hfg =>\n        alg_hom.ext <| MonoidHom.ext_iff.1 hfg :\n      _)\n  this.of_comp _\n#align linear_independent_to_linear_map linear_independent_to_linear_map\n\n",
 "linear_independent_smul_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_smul_of_linear_independent {s : Finset F} :\n    (linear_independent (fixed_points.subfield G F) fun i : (s : set F) => (i : F)) →\n      linear_independent F fun i : (s : set F) => MulAction.toFun G F i :=\n  by\n  haveI : is_empty ((∅ : Finset F) : set F) := ⟨subtype.prop⟩\n  refine' Finset.induction_on s (fun _ => linear_independent_empty_type) fun a s has ih hs => _\n  rw [coe_insert] at hs⊢\n  rw [linear_independent_insert (mt mem_coe.1 has)] at hs\n  rw [linear_independent_insert' (mt mem_coe.1 has)]\n  refine' ⟨ih hs.1, fun ha => _⟩\n  rw [finsupp.mem_span_image_iff_total] at ha\n  rcases ha with ⟨l, hl, hla⟩\n  rw [finsupp.total_apply_of_mem_supported F hl] at hla\n  suffices ∀ i ∈ s, l i ∈ fixed_points.subfield G F\n    by\n    replace hla := (sum_apply _ _ fun i => «expr • » (l i) (to_fun G F i)).symm.trans (congr_fun hla 1)\n    simp_rw [pi.smul_apply, to_fun_apply, one_smul] at hla\n    refine' hs.2 (hla ▸ submodule.sum_mem _ fun c hcs => _)\n    change «expr • » (⟨l c, this c hcs⟩ : fixed_points.subfield G F) c ∈ _\n    exact submodule.smul_mem _ _ (submodule.subset_span <| mem_coe.2 hcs)\n  intro i his g\n  refine'\n    eq_of_sub_eq_zero\n      (linear_independent_iff'.1 (ih hs.1) s.attach (fun i => «expr • » g (l i) - l i) _ ⟨i, his⟩ (mem_attach _ _) : _)\n  refine' (@sum_attach _ _ s _ fun i => «expr • » («expr • » g (l i) - l i) (MulAction.toFun G F i)).trans _\n  ext g'\n  dsimp only\n  conv_lhs =>\n    rw [sum_apply]\n    congr\n    skip\n    ext\n    rw [pi.smul_apply, sub_smul, smul_eq_mul]\n  rw [sum_sub_distrib, pi.zero_apply, sub_eq_zero]\n  conv_lhs =>\n    congr\n    skip\n    ext\n    rw [to_fun_apply, ← mul_inv_cancel_left g g', mul_smul, ← smul_mul', ← to_fun_apply _ x]\n  show\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        («expr • » g ((fun y => «expr • » (l y) (MulAction.toFun G F y)) x (g⁻¹ * g'))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((fun y => «expr • » (l y) (MulAction.toFun G F y)) x g')\n  rw [← smul_sum, ← sum_apply _ _ fun y => «expr • » (l y) (to_fun G F y), ←\n    sum_apply _ _ fun y => «expr • » (l y) (to_fun G F y)]\n  dsimp only\n  rw [hla, to_fun_apply, to_fun_apply, smul_smul, mul_inv_cancel_left]\n#align linear_independent_smul_of_linear_independent linear_independent_smul_of_linear_independent\n\n",
 "is_integral":
 "theorem is_integral [Finite G] (x : F) : is_integral (fixed_points.subfield G F) x :=\n  by\n  cases nonempty_fintype G\n  exact ⟨minpoly G F x, minpoly.monic G F x, minpoly.eval₂ G F x⟩\n#align is_integral is_integral\n\n",
 "irreducible_aux":
 "-- Why is this so slow?\ntheorem irreducible_aux (f g : polynomial (fixed_points.subfield G F)) (hf : f.monic) (hg : g.monic)\n    (hfg : f * g = minpoly G F x) : f = 1 ∨ g = 1 :=\n  by\n  have hf2 : f ∣ minpoly G F x := by\n    rw [← hfg]\n    exact dvd_mul_right _ _\n  have hg2 : g ∣ minpoly G F x := by\n    rw [← hfg]\n    exact dvd_mul_left _ _\n  have := eval₂ G F x\n  rw [← hfg, polynomial.eval₂_mul, mul_eq_zero] at this\n  cases this\n  · right\n    have hf3 : f = minpoly G F x :=\n      polynomial.eq_of_monic_of_associated hf (monic G F x)\n        (associated_of_dvd_dvd hf2 <| @of_eval₂ G _ F _ _ _ x f this)\n    rwa [← mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg\n  · left\n    have hg3 : g = minpoly G F x :=\n      polynomial.eq_of_monic_of_associated hg (monic G F x)\n        (associated_of_dvd_dvd hg2 <| @of_eval₂ G _ F _ _ _ x g this)\n    rwa [← one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg\n#align irreducible_aux irreducible_aux\n\n",
 "finrank_le_card":
 "-- this was a plain rw when we were using unbundled subrings\ntheorem finrank_le_card [fintype G] : finrank (subfield G F) F ≤ fintype.card G :=\n  by\n  rw [← cardinal.nat_cast_le, finrank_eq_dim]\n  apply dim_le_card\n#align finrank_le_card finrank_le_card\n\n",
 "finrank_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem finrank_eq_card (G : Type u) (F : Type v) [group G] [Field F] [fintype G] [MulSemiringAction G F]\n    [FaithfulSMul G F] : finrank (fixed_points.subfield G F) F = fintype.card G :=\n  le_antisymm (fixed_points.finrank_le_card G F) <|\n    calc\n      fintype.card G ≤ fintype.card («expr →ₐ[ ] » F (fixed_points.subfield G F) F) :=\n        fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F)\n      _ ≤ finrank F («expr →ₗ[ ] » F (fixed_points.subfield G F) F) := finrank_alg_hom (fixed_points G F) F\n      _ = finrank (fixed_points.subfield G F) F := finrank_linear_map' _ _ _\n      \n#align finrank_eq_card finrank_eq_card\n\n",
 "finrank_alg_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem finrank_alg_hom (K : Type u) (V : Type v) [Field K] [Field V] [algebra K V] [finite_dimensional K V] :\n    fintype.card («expr →ₐ[ ] » V K V) ≤ finrank V («expr →ₗ[ ] » V K V) :=\n  fintype_card_le_finrank_of_linear_independent <| linear_independent_to_linear_map K V V\n#align finrank_alg_hom finrank_alg_hom\n\n",
 "eval₂'":
 "theorem eval₂' : polynomial.eval₂ (subfield.subtype <| fixed_points.subfield G F) x (minpoly G F x) = 0 :=\n  eval₂ G F x\n#align eval₂' eval₂'\n\n",
 "eval₂":
 "theorem eval₂ : polynomial.eval₂ (subring.subtype <| (fixed_points.subfield G F).to_subring) x (minpoly G F x) = 0 :=\n  by\n  rw [← prod_X_sub_smul.eval G F x, polynomial.eval₂_eq_eval_map]\n  simp only [minpoly, polynomial.map_to_subring]\n#align eval₂ eval₂\n\n",
 "dim_le_card":
 "theorem dim_le_card : module.rank (fixed_points.subfield G F) F ≤ fintype.card G :=\n  dim_le fun s hs => by\n    simpa only [dim_fun', cardinal.mk_coe_finset, Finset.coe_sort_coe, cardinal.lift_nat_cast,\n      cardinal.nat_cast_le] using\n      cardinal_lift_le_dim_of_linear_independent' (linear_independent_smul_of_linear_independent G F hs)\n#align dim_le_card dim_le_card\n\n",
 "coe_algebra_map":
 "theorem coe_algebra_map : algebra_map (fixed_points.subfield M F) F = subfield.subtype (fixed_points.subfield M F) :=\n  rfl\n#align coe_algebra_map coe_algebra_map\n\n",
 "cardinal_mk_alg_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem cardinal_mk_alg_hom (K : Type u) (V : Type v) (W : Type w) [Field K] [Field V] [algebra K V]\n    [finite_dimensional K V] [Field W] [algebra K W] [finite_dimensional K W] :\n    cardinal.mk («expr →ₐ[ ] » V K W) ≤ finrank W («expr →ₗ[ ] » V K W) :=\n  cardinal_mk_le_finrank_of_linear_independent <| linear_independent_to_linear_map K V W\n#align cardinal_mk_alg_hom cardinal_mk_alg_hom\n\n",
 "Irreducible":
 "#print Irreducible /-\ntheorem Irreducible : Irreducible (minpoly G F x) :=\n  (polynomial.irreducible_of_monic (monic G F x) (ne_one G F x)).2 (irreducible_aux G F x)\n#align irreducible Irreducible\n-/\n\n"}