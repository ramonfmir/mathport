{"to_alg_hom_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- `mul_semiring_action.to_alg_hom` is bijective. -/\ntheorem to_alg_hom_bijective (G : Type u) (F : Type v) [Group G] [Field F] [Finite G] [MulSemiringAction G F]\n    [FaithfulSMul G F] : function.bijective (MulSemiringAction.toAlgHom _ _ : G → «expr →ₐ[ ] » F (subfield G F) F) :=\n  by\n  cases nonempty_fintype G\n  rw [Fintype.bijective_iff_injective_and_card]\n  constructor\n  · exact MulSemiringAction.toAlgHom_injective _ F\n  · apply le_antisymm\n    · exact Fintype.card_le_of_injective _ (MulSemiringAction.toAlgHom_injective _ F)\n    · rw [← finrank_eq_card G F]\n      exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _)\n#align to_alg_hom_bijective to_alg_hom_bijective\n\n",
 "smul_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n-- Why is this so slow?\n@[simp]\ntheorem smul_polynomial (m : M) (p : Polynomial (fixed_points.subfield M F)) : «expr • » m p = p :=\n  Polynomial.induction_on p (fun x => by rw [Polynomial.smul_C, smul]) (fun p q ihp ihq => by rw [smul_add, ihp, ihq])\n    fun n x ih => by rw [smul_mul', Polynomial.smul_C, smul, smul_pow', Polynomial.smul_X]\n#align smul_polynomial smul_polynomial\n\n",
 "smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n-- we use `subfield.copy` so that the underlying set is `fixed_points M F`\n@[simp]\ntheorem smul (m : M) (x : fixed_points.subfield M F) : «expr • » m x = x :=\n  Subtype.eq <| x.2 m\n#align smul smul\n\n",
 "rank_le_card":
 "theorem rank_le_card : Module.rank (fixed_points.subfield G F) F ≤ Fintype.card G :=\n  rank_le fun s hs => by\n    simpa only [rank_fun', Cardinal.mk_coe_finset, Finset.coe_sort_coe, Cardinal.lift_natCast,\n      Cardinal.natCast_le] using\n      cardinal_lift_le_rank_of_linearIndependent' (linear_independent_smul_of_linear_independent G F hs)\n#align rank_le_card rank_le_card\n\n",
 "of_eval₂":
 "theorem of_eval₂ (f : Polynomial (fixed_points.subfield G F))\n    (hf : Polynomial.eval₂ (Subfield.subtype <| fixed_points.subfield G F) x f = 0) : minpoly G F x ∣ f :=\n  by\n  erw [← Polynomial.map_dvd_map' (Subfield.subtype <| fixed_points.subfield G F), minpoly,\n    Polynomial.map_toSubring _ (Subfield G F).to_subring, prodXSubSmul]\n  refine'\n    Fintype.prod_dvd_of_coprime (Polynomial.pairwise_coprime_X_sub_C <| MulAction.injective_ofQuotientStabilizer G x)\n      fun y => QuotientGroup.induction_on y fun g => _\n  rw [Polynomial.dvd_iff_isRoot, Polynomial.IsRoot.def, MulAction.ofQuotientStabilizer_mk, Polynomial.eval_smul', ←\n    Subfield.toSubring_subtype_eq_subtype, ←\n    IsInvariantSubring.coe_subtypeHom' G (fixed_points.subfield G F).to_subring, ← MulSemiringActionHom.coe_polynomial,\n    ← MulSemiringActionHom.map_smul, smul_polynomial, MulSemiringActionHom.coe_polynomial,\n    IsInvariantSubring.coe_subtypeHom', Polynomial.eval_map, Subfield.toSubring_subtype_eq_subtype, hf, smul_zero]\n#align of_eval₂ of_eval₂\n\n",
 "ne_one":
 "theorem ne_one : minpoly G F x ≠ (1 : Polynomial (fixed_points.subfield G F)) := fun H =>\n  have := eval₂ G F x\n  (one_ne_zero : (1 : F) ≠ 0) <| by rwa [H, Polynomial.eval₂_one] at this\n#align ne_one ne_one\n\n",
 "monic":
 "theorem monic : (minpoly G F x).monic :=\n  by\n  simp only [minpoly, Polynomial.monic_toSubring]\n  exact prodXSubSmul.monic G F x\n#align monic monic\n\n",
 "minpoly_eq_minpoly":
 "theorem minpoly_eq_minpoly : minpoly G F x = _root_.minpoly (fixed_points.subfield G F) x :=\n  minpoly.eq_of_irreducible_of_monic (minpoly.irreducible G F x) (minpoly.eval₂ G F x) (minpoly.monic G F x)\n#align minpoly_eq_minpoly minpoly_eq_minpoly\n\n",
 "linear_independent_to_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem linear_independent_to_linear_map (R : Type u) (A : Type v) (B : Type w) [CommSemiring R] [Ring A] [Algebra R A]\n    [CommRing B] [IsDomain B] [Algebra R B] :\n    LinearIndependent B (AlgHom.toLinearMap : «expr →ₐ[ ] » A R B → «expr →ₗ[ ] » A R B) :=\n  have : LinearIndependent B (LinearMap.ltoFun R A B ∘ AlgHom.toLinearMap) :=\n    ((linearIndependent_monoidHom A B).comp (coe : «expr →ₐ[ ] » A R B → «expr →* » A B) fun f g hfg =>\n        AlgHom.ext <| MonoidHom.ext_iff.1 hfg :\n      _)\n  this.of_comp _\n#align linear_independent_to_linear_map linear_independent_to_linear_map\n\n",
 "linear_independent_smul_of_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem linear_independent_smul_of_linear_independent {s : Finset F} :\n    (LinearIndependent (fixed_points.subfield G F) fun i : (s : Set F) => (i : F)) →\n      LinearIndependent F fun i : (s : Set F) => MulAction.toFun G F i :=\n  by\n  haveI : IsEmpty ((∅ : Finset F) : Set F) := ⟨Subtype.prop⟩\n  refine' Finset.induction_on s (fun _ => linearIndependent_empty_type) fun a s has ih hs => _\n  rw [coe_insert] at hs⊢\n  rw [linearIndependent_insert (mt mem_coe.1 has)] at hs\n  rw [linearIndependent_insert' (mt mem_coe.1 has)]\n  refine' ⟨ih hs.1, fun ha => _⟩\n  rw [Finsupp.mem_span_image_iff_total] at ha\n  rcases ha with ⟨l, hl, hla⟩\n  rw [Finsupp.total_apply_of_mem_supported F hl] at hla\n  suffices ∀ i ∈ s, l i ∈ fixed_points.subfield G F\n    by\n    replace hla := (sum_apply _ _ fun i => «expr • » (l i) (to_fun G F i)).symm.trans (congr_fun hla 1)\n    simp_rw [Pi.smul_apply, to_fun_apply, one_smul] at hla\n    refine' hs.2 (hla ▸ Submodule.sum_mem _ fun c hcs => _)\n    change «expr • » (⟨l c, this c hcs⟩ : fixed_points.subfield G F) c ∈ _\n    exact Submodule.smul_mem _ _ (Submodule.subset_span <| mem_coe.2 hcs)\n  intro i his g\n  refine'\n    eq_of_sub_eq_zero\n      (linearIndependent_iff'.1 (ih hs.1) s.attach (fun i => «expr • » g (l i) - l i) _ ⟨i, his⟩ (mem_attach _ _) : _)\n  refine' (@sum_attach _ _ s _ fun i => «expr • » («expr • » g (l i) - l i) (MulAction.toFun G F i)).trans _\n  ext g'\n  dsimp only\n  conv_lhs =>\n    rw [sum_apply]\n    congr\n    skip\n    ext\n    rw [Pi.smul_apply, sub_smul, smul_eq_mul]\n  rw [sum_sub_distrib, Pi.zero_apply, sub_eq_zero]\n  conv_lhs =>\n    congr\n    skip\n    ext\n    rw [to_fun_apply, ← mul_inv_cancel_left g g', mul_smul, ← smul_mul', ← to_fun_apply _ x]\n  show\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        («expr • » g ((fun y => «expr • » (l y) (MulAction.toFun G F y)) x (g⁻¹ * g'))) =\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" s\n        ((fun y => «expr • » (l y) (MulAction.toFun G F y)) x g')\n  rw [← smul_sum, ← sum_apply _ _ fun y => «expr • » (l y) (to_fun G F y), ←\n    sum_apply _ _ fun y => «expr • » (l y) (to_fun G F y)]\n  dsimp only\n  rw [hla, to_fun_apply, to_fun_apply, smul_smul, mul_inv_cancel_left]\n#align linear_independent_smul_of_linear_independent linear_independent_smul_of_linear_independent\n\n",
 "is_integral":
 "theorem is_integral [Finite G] (x : F) : is_integral (fixed_points.subfield G F) x :=\n  by\n  cases nonempty_fintype G\n  exact ⟨minpoly G F x, minpoly.monic G F x, minpoly.eval₂ G F x⟩\n#align is_integral is_integral\n\n",
 "irreducible_aux":
 "-- Why is this so slow?\ntheorem irreducible_aux (f g : Polynomial (fixed_points.subfield G F)) (hf : f.monic) (hg : g.monic)\n    (hfg : f * g = minpoly G F x) : f = 1 ∨ g = 1 :=\n  by\n  have hf2 : f ∣ minpoly G F x := by\n    rw [← hfg]\n    exact dvd_mul_right _ _\n  have hg2 : g ∣ minpoly G F x := by\n    rw [← hfg]\n    exact dvd_mul_left _ _\n  have := eval₂ G F x\n  rw [← hfg, Polynomial.eval₂_mul, mul_eq_zero] at this\n  cases this\n  · right\n    have hf3 : f = minpoly G F x :=\n      Polynomial.eq_of_monic_of_associated hf (monic G F x)\n        (associated_of_dvd_dvd hf2 <| @of_eval₂ G _ F _ _ _ x f this)\n    rwa [← mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg\n  · left\n    have hg3 : g = minpoly G F x :=\n      Polynomial.eq_of_monic_of_associated hg (monic G F x)\n        (associated_of_dvd_dvd hg2 <| @of_eval₂ G _ F _ _ _ x g this)\n    rwa [← one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg\n#align irreducible_aux irreducible_aux\n\n",
 "finrank_le_card":
 "-- this was a plain rw when we were using unbundled subrings\ntheorem finrank_le_card [Fintype G] : finrank (subfield G F) F ≤ Fintype.card G :=\n  by\n  rw [← Cardinal.natCast_le, finrank_eq_rank]\n  apply rank_le_card\n#align finrank_le_card finrank_le_card\n\n",
 "finrank_eq_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem finrank_eq_card (G : Type u) (F : Type v) [Group G] [Field F] [Fintype G] [MulSemiringAction G F]\n    [FaithfulSMul G F] : finrank (fixed_points.subfield G F) F = Fintype.card G :=\n  le_antisymm (fixed_points.finrank_le_card G F) <|\n    calc\n      Fintype.card G ≤ Fintype.card («expr →ₐ[ ] » F (fixed_points.subfield G F) F) :=\n        Fintype.card_le_of_injective _ (MulSemiringAction.toAlgHom_injective _ F)\n      _ ≤ finrank F («expr →ₗ[ ] » F (fixed_points.subfield G F) F) := (finrank_alg_hom (fixedPoints G F) F)\n      _ = finrank (fixed_points.subfield G F) F := finrank_linear_map' _ _ _\n      \n#align finrank_eq_card finrank_eq_card\n\n",
 "finrank_alg_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem finrank_alg_hom (K : Type u) (V : Type v) [Field K] [Field V] [Algebra K V] [FiniteDimensional K V] :\n    Fintype.card («expr →ₐ[ ] » V K V) ≤ finrank V («expr →ₗ[ ] » V K V) :=\n  fintype_card_le_finrank_of_linearIndependent <| linear_independent_to_linear_map K V V\n#align finrank_alg_hom finrank_alg_hom\n\n",
 "eval₂'":
 "theorem eval₂' : Polynomial.eval₂ (Subfield.subtype <| fixed_points.subfield G F) x (minpoly G F x) = 0 :=\n  eval₂ G F x\n#align eval₂' eval₂'\n\n",
 "eval₂":
 "theorem eval₂ : Polynomial.eval₂ (Subring.subtype <| (fixed_points.subfield G F).to_subring) x (minpoly G F x) = 0 :=\n  by\n  rw [← prodXSubSmul.eval G F x, Polynomial.eval₂_eq_eval_map]\n  simp only [minpoly, Polynomial.map_toSubring]\n#align eval₂ eval₂\n\n",
 "coe_algebra_map":
 "theorem coe_algebra_map : algebraMap (fixed_points.subfield M F) F = Subfield.subtype (fixed_points.subfield M F) :=\n  rfl\n#align coe_algebra_map coe_algebra_map\n\n",
 "cardinal_mk_alg_hom":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\ntheorem cardinal_mk_alg_hom (K : Type u) (V : Type v) (W : Type w) [Field K] [Field V] [Algebra K V]\n    [FiniteDimensional K V] [Field W] [Algebra K W] [FiniteDimensional K W] :\n    Cardinal.mk («expr →ₐ[ ] » V K W) ≤ finrank W («expr →ₗ[ ] » V K W) :=\n  cardinal_mk_le_finrank_of_linearIndependent <| linear_independent_to_linear_map K V W\n#align cardinal_mk_alg_hom cardinal_mk_alg_hom\n\n",
 "Irreducible":
 "#print Irreducible /-\ntheorem Irreducible : Irreducible (minpoly G F x) :=\n  (Polynomial.irreducible_of_monic (monic G F x) (ne_one G F x)).2 (irreducible_aux G F x)\n#align irreducible Irreducible\n-/\n\n"}