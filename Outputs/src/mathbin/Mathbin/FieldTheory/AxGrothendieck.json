{"ax_grothendieck_of_locally_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/-\nCopyright (c) 2023 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ax_grothendieck_of_locally_finite {ι K R : Type _} [Field K] [Finite K] [CommRing R] [Finite ι] [Algebra K R]\n    (alg : algebra.is_algebraic K R) (ps : ι → MvPolynomial ι R) (hinj : injective fun v i => eval v (ps i)) :\n    surjective fun v i => eval v (ps i) :=\n  by\n  have is_int : ∀ x : R, is_integral K x := fun x => is_algebraic_iff_is_integral.1 (alg x)\n  classical\n    intro v\n    cases nonempty_fintype ι\n    /- `s` is the set of all coefficients of the polynomial, as well as all of\n      the coordinates of `v`, the point I am trying to find the preimage of. -/\n    let s : Finset R :=\n      (Finset.bunionᵢ (univ : Finset ι) fun i => (ps i).support.image fun x => coeff x (ps i)) ∪\n        (univ : Finset ι).image v\n    have hv : ∀ i, v i ∈ Algebra.adjoin K (s : Set R) := fun j =>\n      Algebra.subset_adjoin (mem_union_right _ (mem_image.2 ⟨j, mem_univ _, rfl⟩))\n    have hs₁ : ∀ (i : ι) (k : «expr →₀ » ι ℕ), k ∈ (ps i).support → coeff k (ps i) ∈ Algebra.adjoin K (s : Set R) :=\n      fun i k hk => Algebra.subset_adjoin (mem_union_left _ (mem_bUnion.2 ⟨i, mem_univ _, mem_image_of_mem _ hk⟩))\n    have hs : ∀ i, MvPolynomial.eval v (ps i) ∈ Algebra.adjoin K (s : Set R) := fun i => eval_mem (hs₁ _) hv\n    letI := is_noetherian_adjoin_finset s fun x _ => is_int x\n    letI := Module.IsNoetherian.finite K (Algebra.adjoin K (s : Set R))\n    letI : Finite (Algebra.adjoin K (s : Set R)) := FiniteDimensional.finite_of_finite K (Algebra.adjoin K (s : Set R))\n    -- The restriction of the polynomial map, `ps`, to the subalgebra generated by `s`\n    let res : (ι → Algebra.adjoin K (s : Set R)) → ι → Algebra.adjoin K (s : Set R) := fun x i =>\n      ⟨eval (fun j : ι => (x j : R)) (ps i), eval_mem (hs₁ _) fun i => (x i).2⟩\n    have hres_inj : injective res := by\n      intro x y hxy\n      ext i\n      simp only [res, Subtype.ext_iff, funext_iff] at hxy\n      exact congr_fun (hinj (funext hxy)) i\n    have hres_surj : surjective res := Finite.injective_iff_surjective.1 hres_inj\n    cases' hres_surj fun i => ⟨v i, hv i⟩ with w hw\n    use fun i => w i\n    simpa only [res, Subtype.ext_iff, funext_iff] using hw\n#align ax_grothendieck_of_locally_finite ax_grothendieck_of_locally_finite\n\n"}