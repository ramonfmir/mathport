{"succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem succ (n : ℕ) (f : polynomial K) : splitting_field_aux (n + 1) f = splitting_field_aux n f.remove_factor :=\n  rfl\n#align succ succ\n\n",
 "splits_of_splits":
 "theorem splits_of_splits {F : intermediate_field K L} (h : p.splits (algebra_map K L))\n    (hF : ∀ x ∈ p.root_set L, x ∈ F) : p.splits (algebra_map K F) :=\n  by\n  simp_rw [root_set, Finset.mem_coe, Multiset.mem_toFinset] at hF\n  rw [splits_iff_exists_multiset]\n  refine' ⟨Multiset.pmap subtype.mk _ hF, map_injective _ (algebra_map F L).injective _⟩\n  conv_lhs =>\n    rw [polynomial.map_map, ← is_scalar_tower.algebra_map_eq, eq_prod_roots_of_splits h, ←\n      Multiset.pmap_eq_map _ _ _ hF]\n  simp_rw [polynomial.map_mul, polynomial.map_multiset_prod, Multiset.map_pmap, polynomial.map_sub, map_C, map_X]\n  rfl\n#align splits_of_splits splits_of_splits\n\n",
 "splits_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem splits_iff (f : polynomial K) [is_splitting_field K L f] :\n    polynomial.splits (RingHom.id K) f ↔ («expr⊤» : subalgebra K L) = «expr⊥» :=\n  ⟨fun h =>\n    eq_bot_iff.2 <|\n      adjoin_roots L f ▸\n        (roots_map (algebra_map K L) h).symm ▸\n          algebra.adjoin_le_iff.2 fun y hy =>\n            let ⟨x, hxs, hxy⟩ := Finset.mem_image.1 (by rwa [Multiset.toFinset_map] at hy)\n            hxy ▸ SetLike.mem_coe.2 <| subalgebra.algebra_map_mem _ _,\n    fun h =>\n    @RingEquiv.toRingHom_refl K _ ▸\n      RingEquiv.self_trans_symm (RingEquiv.ofBijective _ <| algebra.bijective_algebra_map_iff.2 h) ▸\n        by\n        rw [RingEquiv.toRingHom_trans]\n        exact splits_comp_of_splits _ _ (splits L f)⟩\n#align splits_iff splits_iff\n\n",
 "splits":
 "protected theorem splits : splits (algebra_map K (splitting_field f)) f :=\n  splitting_field_aux.splits _ _ rfl\n#align splits splits\n\n",
 "of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem of_alg_equiv [algebra K F] (p : polynomial K) (f : «expr ≃ₐ[ ] » F K L) [is_splitting_field K F p] :\n    is_splitting_field K L p := by\n  constructor\n  · rw [← f.to_alg_hom.comp_algebra_map]\n    exact splits_comp_of_splits _ _ (splits F p)\n  ·\n    rw [← (algebra.range_top_iff_surjective f.to_alg_hom).mpr f.surjective, ← root_set,\n      adjoin_root_set_eq_range (splits F p), root_set, adjoin_roots F p]\n#align of_alg_equiv of_alg_equiv\n\n",
 "nat_degree_remove_factor'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_remove_factor' {f : polynomial K} {n : ℕ} (hfn : f.nat_degree = n + 1) :\n    f.remove_factor.nat_degree = n := by rw [nat_degree_remove_factor, hfn, n.add_sub_cancel]\n#align nat_degree_remove_factor' nat_degree_remove_factor'\n\n",
 "nat_degree_remove_factor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem nat_degree_remove_factor (f : polynomial K) : f.remove_factor.nat_degree = f.nat_degree - 1 := by\n  rw [remove_factor, nat_degree_div_by_monic _ (monic_X_sub_C _), nat_degree_map, nat_degree_X_sub_C]\n#align nat_degree_remove_factor nat_degree_remove_factor\n\n",
 "mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mul (f g : polynomial F) (hf : f ≠ 0) (hg : g ≠ 0) [is_splitting_field F K f]\n    [is_splitting_field K L (g.map <| algebra_map F K)] : is_splitting_field F L (f * g) :=\n  ⟨(is_scalar_tower.algebra_map_eq F K L).symm ▸\n      splits_mul _ (splits_comp_of_splits _ _ (splits K f))\n        ((splits_map_iff _ _).1 (splits L <| g.map <| algebra_map F K)),\n    by\n    rw [polynomial.map_mul, roots_mul (mul_ne_zero (map_ne_zero hf : f.map (algebra_map F L) ≠ 0) (map_ne_zero hg)),\n      Multiset.toFinset_add, Finset.coe_union, algebra.adjoin_union_eq_adjoin_adjoin,\n      is_scalar_tower.algebra_map_eq F K L, ← map_map,\n      roots_map (algebra_map K L) ((splits_id_iff_splits <| algebra_map F K).2 <| splits K f), Multiset.toFinset_map,\n      Finset.coe_image, algebra.adjoin_algebra_map, adjoin_roots, algebra.map_top,\n      is_scalar_tower.adjoin_range_to_alg_hom, ← map_map, adjoin_roots, subalgebra.restrict_scalars_top]⟩\n#align mul mul\n\n",
 "irreducible_factor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes\n-/\ntheorem irreducible_factor (f : polynomial K) : Irreducible (factor f) := by rw [factor]; split_ifs with H;\n  · exact (Classical.choose_spec H).1; · exact irreducible_X\n#align irreducible_factor irreducible_factor\n\n",
 "finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem finite_dimensional (f : polynomial K) [is_splitting_field K L f] : finite_dimensional K L :=\n  ⟨@algebra.top_to_submodule K L _ _ _ ▸\n      adjoin_roots L f ▸\n        fg_adjoin_of_finite (finset.finite_to_set _) fun y hy =>\n          if hf : f = 0 then by\n            rw [hf, polynomial.map_zero, roots_zero] at hy\n            cases hy\n          else\n            is_algebraic_iff_is_integral.1\n              ⟨f, hf, (eval₂_eq_eval_map _).trans <| (mem_roots <| map_ne_zero hf).1 (Multiset.mem_toFinset.mp hy)⟩⟩\n#align finite_dimensional finite_dimensional\n\n",
 "factor_dvd_of_not_is_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem factor_dvd_of_not_is_unit {f : polynomial K} (hf1 : ¬is_unit f) : factor f ∣ f :=\n  by\n  by_cases hf2 : f = 0;\n  · rw [hf2]\n    exact dvd_zero _\n  rw [factor, dif_pos (wf_dvd_monoid.exists_irreducible_factor hf1 hf2)]\n  exact (Classical.choose_spec <| wf_dvd_monoid.exists_irreducible_factor hf1 hf2).2\n#align factor_dvd_of_not_is_unit factor_dvd_of_not_is_unit\n\n",
 "factor_dvd_of_nat_degree_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem factor_dvd_of_nat_degree_ne_zero {f : polynomial K} (hf : f.nat_degree ≠ 0) : factor f ∣ f :=\n  factor_dvd_of_degree_ne_zero (mt nat_degree_eq_of_degree_eq_some hf)\n#align factor_dvd_of_nat_degree_ne_zero factor_dvd_of_nat_degree_ne_zero\n\n",
 "factor_dvd_of_degree_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem factor_dvd_of_degree_ne_zero {f : polynomial K} (hf : f.degree ≠ 0) : factor f ∣ f :=\n  factor_dvd_of_not_is_unit (mt degree_eq_zero_of_is_unit hf)\n#align factor_dvd_of_degree_ne_zero factor_dvd_of_degree_ne_zero\n\n",
 "fact_irreducible_factor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- See note [fact non-instances]. -/\ntheorem fact_irreducible_factor (f : polynomial K) : fact (Irreducible (factor f)) :=\n  ⟨irreducible_factor f⟩\n#align fact_irreducible_factor fact_irreducible_factor\n\n",
 "exists_lift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem exists_lift (n : ℕ) :\n    ∀ {K : Type u} [Field K],\n      ∀ (f : polynomial K) (hfn : f.nat_degree = n) {L : Type _} [Field L],\n        ∀ (j : «expr →+* » K L) (hf : splits j f),\n          ∃ k : «expr →+* » (splitting_field_aux n f) L, k.comp (algebra_map _ _) = j :=\n  nat.rec_on n (fun K _ _ _ L _ j _ => ⟨j, j.comp_id⟩) fun n ih K _ f hf L _ j hj =>\n    have hndf : f.nat_degree ≠ 0 := by\n      intro h\n      rw [h] at hf\n      cases hf\n    have hfn0 : f ≠ 0 := by\n      intro h\n      rw [h] at hndf\n      exact hndf rfl\n    let ⟨r, hr⟩ :=\n      exists_root_of_splits _ (splits_of_splits_of_dvd j hfn0 hj (factor_dvd_of_nat_degree_ne_zero hndf))\n        (mt is_unit_iff_degree_eq_zero.2 f.irreducible_factor.1)\n    have hmf0 : map (adjoin_root.of f.factor) f ≠ 0 := map_ne_zero hfn0\n    have hsf : splits (adjoin_root.lift j r hr) f.remove_factor :=\n      by\n      rw [← X_sub_C_mul_remove_factor _ hndf] at hmf0\n      refine' (splits_of_splits_mul _ hmf0 _).2\n      rwa [X_sub_C_mul_remove_factor _ hndf, ← splits_id_iff_splits, map_map, adjoin_root.lift_comp_of,\n        splits_id_iff_splits]\n    let ⟨k, hk⟩ := ih f.remove_factor (nat_degree_remove_factor' hf) (adjoin_root.lift j r hr) hsf\n    ⟨k, by rw [algebra_map_succ, ← RingHom.comp_assoc, hk, adjoin_root.lift_comp_of]⟩\n#align exists_lift exists_lift\n\n",
 "algebra_map_succ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nNote that the recursive nature of this definition and `splitting_field_aux.field` creates\nnon-definitionally-equal diamonds in the `ℕ`- and `ℤ`- actions.\n```lean\nexample (n : ℕ) {K : Type u} [field K] {f : K[X]} (hfn : f.nat_degree = n) :\n    (add_comm_monoid.nat_module : module ℕ (splitting_field_aux n f hfn)) =\n  @algebra.to_module _ _ _ _ (splitting_field_aux.algebra n _ hfn) :=\nrfl  -- fails\n```\nIt's not immediately clear whether this _can_ be fixed; the failure is much the same as the reason\nthat the following fails:\n```lean\ndef cases_twice {α} (a₀ aₙ : α) : ℕ → α × α\n| 0 := (a₀, a₀)\n| (n + 1) := (aₙ, aₙ)\n\nexample (x : ℕ) {α} (a₀ aₙ : α) : (cases_twice a₀ aₙ x).1 = (cases_twice a₀ aₙ x).2 := rfl  -- fails\n```\nWe don't really care at this point because this is an implementation detail (which is why this is\nnot a docstring), but we do in `splitting_field.algebra'` below. -/\n-- finding this instance ourselves makes things faster\ntheorem algebra_map_succ (n : ℕ) (f : polynomial K) :\n    algebra_map K (splitting_field_aux (n + 1) f) =\n      (algebra_map (adjoin_root f.factor) (splitting_field_aux n f.remove_factor)).comp (adjoin_root.of f.factor) :=\n  is_scalar_tower.algebra_map_eq _ _ _\n#align algebra_map_succ algebra_map_succ\n\n",
 "adjoin_roots":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_roots :\n    algebra.adjoin K (↑(f.map (algebra_map K <| splitting_field f)).roots.to_finset : set (splitting_field f)) =\n      «expr⊤» :=\n  splitting_field_aux.adjoin_roots _ _ rfl\n#align adjoin_roots adjoin_roots\n\n",
 "adjoin_root_set":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem adjoin_root_set : algebra.adjoin K (f.root_set f.splitting_field) = «expr⊤» :=\n  adjoin_roots f\n#align adjoin_root_set adjoin_root_set\n\n",
 "X_sub_C_mul_remove_factor":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem X_sub_C_mul_remove_factor (f : polynomial K) (hf : f.nat_degree ≠ 0) :\n    (X - C (adjoin_root.root f.factor)) * f.remove_factor = map (adjoin_root.of f.factor) f :=\n  let ⟨g, hg⟩ := factor_dvd_of_nat_degree_ne_zero hf\n  mul_div_by_monic_eq_iff_is_root.2 <| by\n    rw [is_root.def, eval_map, hg, eval₂_mul, ← hg, adjoin_root.eval₂_root, zero_mul]\n#align X_sub_C_mul_remove_factor X_sub_C_mul_remove_factor\n\n"}