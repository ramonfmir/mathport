{"zsmul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\nprotected theorem zsmul_mem {x : K} (hx : x ∈ s) (n : ℤ) : «expr • » n x ∈ s :=\n  zsmul_mem hx n\n#align zsmul_mem zsmul_mem\n\n",
 "zpow_mem":
 "theorem zpow_mem {x : K} (hx : x ∈ s) (n : ℤ) : x ^ n ∈ s :=\n  by\n  cases n\n  · simpa using s.pow_mem hx n\n  · simpa [pow_succ] using s.inv_mem (s.mul_mem hx (s.pow_mem hx n))\n#align zpow_mem zpow_mem\n\n",
 "zero_mem":
 "/-- A subfield contains the field's 0. -/\nprotected theorem zero_mem : (0 : K) ∈ s :=\n  zero_mem s\n#align zero_mem zero_mem\n\n",
 "sum_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/-- Sum of elements in a `subfield` indexed by a `finset` is in the `subfield`. -/\nprotected theorem sum_mem {ι : Type _} {t : Finset ι} {f : ι → K} (h : ∀ c ∈ t, f c ∈ s) :\n    finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" t (f i) ∈ s :=\n  sum_mem h\n#align sum_mem sum_mem\n\n",
 "subtype_eq_subtype":
 "theorem to_subring.subtype_eq_subtype (F : Type _) [Field F] (S : subfield F) : S.to_subring.subtype = S.subtype :=\n  rfl\n#align to_subring.subtype_eq_subtype to_subring.subtype_eq_subtype\n\n",
 "subset_closure":
 "/-- The subfield generated by a set includes the set. -/\n@[simp]\ntheorem subset_closure {s : set K} : s ⊆ closure s :=\n  Set.Subset.trans subring.subset_closure (subring_closure_le s)\n#align subset_closure subset_closure\n\n",
 "subring_closure_le":
 "theorem subring_closure_le (s : set K) : subring.closure s ≤ (closure s).to_subring := fun x hx =>\n  ⟨x, hx, 1, subring.one_mem _, div_one x⟩\n#align subring_closure_le subring_closure_le\n\n",
 "sub_mem":
 "/-- A subfield is closed under subtraction. -/\nprotected theorem sub_mem {x y : K} : x ∈ s → y ∈ s → x - y ∈ s :=\n  sub_mem\n#align sub_mem sub_mem\n\n",
 "rat_smul_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem rat_smul_mem (s : S) (a : exprℚ) (x : s) : («expr • » a x : K) ∈ s := by\n  simpa only [Rat.smul_def] using mul_mem (coe_rat_mem s a) x.prop\n#align rat_smul_mem rat_smul_mem\n\n",
 "prod_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- Product of elements of a subfield indexed by a `finset` is in the subfield. -/\nprotected theorem prod_mem {ι : Type _} {t : Finset ι} {f : ι → K} (h : ∀ c ∈ t, f c ∈ s) :\n    finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" t (f i) ∈ s :=\n  prod_mem h\n#align prod_mem prod_mem\n\n",
 "pow_mem":
 "#print pow_mem /-\nprotected theorem pow_mem {x : K} (hx : x ∈ s) (n : ℕ) : x ^ n ∈ s :=\n  pow_mem hx n\n#align pow_mem pow_mem\n-/\n\n",
 "one_mem":
 "/-- A subfield contains the field's 1. -/\nprotected theorem one_mem : (1 : K) ∈ s :=\n  one_mem s\n#align one_mem one_mem\n\n",
 "not_mem_of_not_mem_closure":
 "theorem not_mem_of_not_mem_closure {s : set K} {P : K} (hP : P ∉ closure s) : P ∉ s := fun h => hP (subset_closure h)\n#align not_mem_of_not_mem_closure not_mem_of_not_mem_closure\n\n",
 "neg_mem":
 "/-- A subfield is closed under negation. -/\nprotected theorem neg_mem {x : K} : x ∈ s → -x ∈ s :=\n  neg_mem\n#align neg_mem neg_mem\n\n",
 "multiset_sum_mem":
 "/-- Sum of a multiset of elements in a `subfield` is in the `subfield`. -/\nprotected theorem multiset_sum_mem (m : Multiset K) : (∀ a ∈ m, a ∈ s) → m.sum ∈ s :=\n  multiset_sum_mem m\n#align multiset_sum_mem multiset_sum_mem\n\n",
 "multiset_prod_mem":
 "/-- Product of a multiset of elements in a subfield is in the subfield. -/\nprotected theorem multiset_prod_mem (m : Multiset K) : (∀ a ∈ m, a ∈ s) → m.prod ∈ s :=\n  multiset_prod_mem m\n#align multiset_prod_mem multiset_prod_mem\n\n",
 "mul_mem":
 "/-- A subfield is closed under multiplication. -/\nprotected theorem mul_mem {x y : K} : x ∈ s → y ∈ s → x * y ∈ s :=\n  mul_mem\n#align mul_mem mul_mem\n\n",
 "mk_le_mk":
 "@[simp]\ntheorem mk_le_mk {S S' : set K} (h₁ h₂ h₃ h₄ h₅ h₆ h₁' h₂' h₃' h₄' h₅' h₆') :\n    (⟨S, h₁, h₂, h₃, h₄, h₅, h₆⟩ : subfield K) ≤ (⟨S', h₁', h₂', h₃', h₄', h₅', h₆'⟩ : subfield K) ↔ S ⊆ S' :=\n  iff.rfl\n#align mk_le_mk mk_le_mk\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top (x : K) : x ∈ («expr⊤» : subfield K) :=\n  Set.mem_univ x\n#align mem_top mem_top\n\n",
 "mem_to_subring":
 "@[simp]\ntheorem mem_to_subring (s : subfield K) (x : K) : x ∈ s.to_subring ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_subring mem_to_subring\n\n",
 "mem_to_submonoid":
 "@[simp]\ntheorem mem_to_submonoid {s : subfield K} {x : K} : x ∈ s.to_submonoid ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_submonoid mem_to_submonoid\n\n",
 "mem_to_add_subgroup":
 "@[simp]\ntheorem mem_to_add_subgroup {s : subfield K} {x : K} : x ∈ s.to_add_subgroup ↔ x ∈ s :=\n  iff.rfl\n#align mem_to_add_subgroup mem_to_add_subgroup\n\n",
 "mem_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- The underlying set of a non-empty directed Sup of subfields is just a union of the subfields.\n  Note that this fails without the directedness assumption (the union of two subfields is\n  typically not a subfield) -/\ntheorem mem_supr_of_directed {ι} [hι : nonempty ι] {S : ι → subfield K} (hS : Directed (· ≤ ·) S) {x : K} :\n    x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) ↔\n      ∃ i, x ∈ S i :=\n  by\n  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supᵢ S i) hi⟩\n  suffices\n    x ∈\n        closure\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (S i : set K)) →\n      ∃ i, x ∈ S i\n    by simpa only [closure_Union, closure_eq]\n  refine' fun hx => closure_induction hx (fun x => set.mem_Union.mp) _ _ _ _ _\n  · exact hι.elim fun i => ⟨i, (S i).one_mem⟩\n  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩\n    obtain ⟨k, hki, hkj⟩ := hS i j\n    exact ⟨k, (S k).add_mem (hki hi) (hkj hj)⟩\n  · rintro x ⟨i, hi⟩\n    exact ⟨i, (S i).neg_mem hi⟩\n  · rintro x ⟨i, hi⟩\n    exact ⟨i, (S i).inv_mem hi⟩\n  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩\n    obtain ⟨k, hki, hkj⟩ := hS i j\n    exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n#align mem_supr_of_directed mem_supr_of_directed\n\n",
 "mem_mk":
 "@[simp]\ntheorem mem_mk {S : set K} {x : K} (h₁ h₂ h₃ h₄ h₅ h₆) : x ∈ (⟨S, h₁, h₂, h₃, h₄, h₅, h₆⟩ : subfield K) ↔ x ∈ S :=\n  iff.rfl\n#align mem_mk mem_mk\n\n",
 "mem_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_map {f : «expr →+* » K L} {s : subfield K} {y : L} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y :=\n  Set.mem_image_iff_bex\n#align mem_map mem_map\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {p p' : subfield K} {x : K} : x ∈ «expr ⊓ » p p' ↔ x ∈ p ∧ x ∈ p' :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_field_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_field_range {f : «expr →+* » K L} {y : L} : y ∈ f.field_range ↔ ∃ x, f x = y :=\n  iff.rfl\n#align mem_field_range mem_field_range\n\n",
 "mem_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem mem_comap {s : subfield L} {f : «expr →+* » K L} {x : K} : x ∈ s.comap f ↔ f x ∈ s :=\n  iff.rfl\n#align mem_comap mem_comap\n\n",
 "mem_closure_iff":
 "theorem mem_closure_iff {s : set K} {x} : x ∈ closure s ↔ ∃ y ∈ subring.closure s, ∃ z ∈ subring.closure s, y / z = x :=\n  iff.rfl\n#align mem_closure_iff mem_closure_iff\n\n",
 "mem_closure":
 "theorem mem_closure {x : K} {s : set K} : x ∈ closure s ↔ ∀ S : subfield K, s ⊆ S → x ∈ S :=\n  ⟨fun ⟨y, hy, z, hz, x_eq⟩ t le =>\n    x_eq ▸ t.div_mem (subring.mem_closure.mp hy t.to_subring le) (subring.mem_closure.mp hz t.to_subring le), fun h =>\n    h (closure s) subset_closure⟩\n#align mem_closure mem_closure\n\n",
 "mem_carrier":
 "-- Prefer subclasses of `field` over subclasses of `subfield_class`.\n-- Prefer subclasses of `field` over subclasses of `subfield_class`.\n@[simp]\ntheorem mem_carrier {s : subfield K} {x : K} : x ∈ s.carrier ↔ x ∈ s :=\n  iff.rfl\n#align mem_carrier mem_carrier\n\n",
 "mem_Sup_of_directed_on":
 "theorem mem_Sup_of_directed_on {S : set (subfield K)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) {x : K} :\n    x ∈ supₛ S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : nonempty S := Sne.to_subtype\n  simp only [supₛ_eq_supᵢ', mem_supr_of_directed hS.directed_coe, SetCoe.exists, subtype.coe_mk]\n#align mem_Sup_of_directed_on mem_Sup_of_directed_on\n\n",
 "mem_Inf":
 "theorem mem_Inf {S : set (subfield K)} {x : K} : x ∈ infₛ S ↔ ∀ p ∈ S, x ∈ p :=\n  subring.mem_Inf.trans ⟨fun h p hp => h p.to_subring ⟨p, hp, rfl⟩, fun h p ⟨p', hp', p_eq⟩ => p_eq ▸ h p' hp'⟩\n#align mem_Inf mem_Inf\n\n",
 "map_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem map_supr {ι : Sort _} (f : «expr →+* » K L) (s : ι → subfield K) :\n    (supᵢ s).map f =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" ((s i).map f) :=\n  (gc_map_comap f).l_supr\n#align map_supr map_supr\n\n",
 "map_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem map_sup (s t : subfield K) (f : «expr →+* » K L) : («expr ⊔ » s t).map f = «expr ⊔ » (s.map f) (t.map f) :=\n  (gc_map_comap f).l_sup\n#align map_sup map_sup\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_map (g : «expr →+* » L M) (f : «expr →+* » K L) : (s.map f).map g = s.map (g.comp f) :=\n  SetLike.ext' <| Set.image_image _ _ _\n#align map_map map_map\n\n",
 "map_le_iff_le_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_le_iff_le_comap {f : «expr →+* » K L} {s : subfield K} {t : subfield L} : s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n#align map_le_iff_le_comap map_le_iff_le_comap\n\n",
 "map_field_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_field_range : f.field_range.map g = (g.comp f).field_range := by\n  simpa only [field_range_eq_map] using («expr⊤» : subfield K).map_map g f\n#align map_field_range map_field_range\n\n",
 "map_field_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image under a ring homomorphism of the subfield generated by a set equals\nthe subfield generated by the image of the set. -/\ntheorem map_field_closure (f : «expr →+* » K L) (s : set K) : (closure s).map f = closure («expr '' » f s) :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <| le_trans (closure_mono <| Set.subset_preimage_image _ _) (field_closure_preimage_le _ _))\n    (closure_le.2 <| Set.image_subset _ subset_closure)\n#align map_field_closure map_field_closure\n\n",
 "map_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem map_bot (f : «expr →+* » K L) : («expr⊥» : subfield K).map f = «expr⊥» :=\n  (gc_map_comap f).l_bot\n#align map_bot map_bot\n\n",
 "list_sum_mem":
 "/-- Sum of a list of elements in a subfield is in the subfield. -/\nprotected theorem list_sum_mem {l : list K} : (∀ x ∈ l, x ∈ s) → l.sum ∈ s :=\n  list_sum_mem\n#align list_sum_mem list_sum_mem\n\n",
 "list_prod_mem":
 "/-- Product of a list of elements in a subfield is in the subfield. -/\nprotected theorem list_prod_mem {l : list K} : (∀ x ∈ l, x ∈ s) → l.prod ∈ s :=\n  list_prod_mem\n#align list_prod_mem list_prod_mem\n\n",
 "isGLB_infₛ":
 "#print isGLB_infₛ /-\ntheorem isGLB_infₛ (S : set (subfield K)) : IsGLB S (infₛ S) :=\n  by\n  refine' IsGLB.of_image (fun s t => show (s : set K) ≤ t ↔ s ≤ t from SetLike.coe_subset_coe) _\n  convert isGLB_binfᵢ\n  exact coe_Inf _\n#align is_glb_Inf isGLB_infₛ\n-/\n\n",
 "inv_mem":
 "/-- A subfield is closed under inverses. -/\nprotected theorem inv_mem {x : K} : x ∈ s → x⁻¹ ∈ s :=\n  inv_mem\n#align inv_mem inv_mem\n\n",
 "gc_map_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem gc_map_comap (f : «expr →+* » K L) : GaloisConnection (map f) (comap f) := fun S T => map_le_iff_le_comap\n#align gc_map_comap gc_map_comap\n\n",
 "field_range_subtype":
 "@[simp]\ntheorem field_range_subtype (s : subfield K) : s.subtype.field_range = s :=\n  SetLike.ext' <| (coe_srange _).trans Subtype.range_coe\n#align field_range_subtype field_range_subtype\n\n",
 "field_range_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem field_range_eq_map : f.field_range = subfield.map f («expr⊤») :=\n  by\n  ext\n  simp\n#align field_range_eq_map field_range_eq_map\n\n",
 "field_closure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem field_closure_preimage_le (f : «expr →+* » K L) (s : set L) : closure («expr ⁻¹' » f s) ≤ (closure s).comap f :=\n  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n#align field_closure_preimage_le field_closure_preimage_le\n\n",
 "ext":
 "/-- Two subfields are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : subfield K} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n#align ext ext\n\n",
 "eq_on_field_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem eq_on_field_closure {f g : «expr →+* » K L} {s : set K} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eq_locus_field g from closure_le.2 h\n#align eq_on_field_closure eq_on_field_closure\n\n",
 "eq_of_eq_on_subfield_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem eq_of_eq_on_subfield_top {f g : «expr →+* » K L} (h : Set.EqOn f g («expr⊤» : subfield K)) : f = g :=\n  ext fun x => h trivial\n#align eq_of_eq_on_subfield_top eq_of_eq_on_subfield_top\n\n",
 "eq_of_eq_on_of_field_closure_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem eq_of_eq_on_of_field_closure_eq_top {s : set K} (hs : closure s = «expr⊤») {f g : «expr →+* » K L}\n    (h : s.eq_on f g) : f = g :=\n  eq_of_eq_on_subfield_top <| hs ▸ eq_on_field_closure h\n#align eq_of_eq_on_of_field_closure_eq_top eq_of_eq_on_of_field_closure_eq_top\n\n",
 "div_mem":
 "/-- A subfield is closed under division. -/\nprotected theorem div_mem {x y : K} : x ∈ s → y ∈ s → x / y ∈ s :=\n  div_mem\n#align div_mem div_mem\n\n",
 "copy_eq":
 "theorem copy_eq (S : subfield K) (s : set K) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n#align copy_eq copy_eq\n\n",
 "comap_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem comap_top (f : «expr →+* » K L) : («expr⊤» : subfield L).comap f = «expr⊤» :=\n  (gc_map_comap f).u_top\n#align comap_top comap_top\n\n",
 "comap_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\ntheorem comap_infi {ι : Sort _} (f : «expr →+* » K L) (s : ι → subfield L) :\n    (infᵢ s).comap f =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" ((s i).comap f) :=\n  (gc_map_comap f).u_infi\n#align comap_infi comap_infi\n\n",
 "comap_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem comap_inf (s t : subfield L) (f : «expr →+* » K L) :\n    («expr ⊓ » s t).comap f = «expr ⊓ » (s.comap f) (t.comap f) :=\n  (gc_map_comap f).u_inf\n#align comap_inf comap_inf\n\n",
 "comap_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem comap_comap (s : subfield M) (g : «expr →+* » L M) (f : «expr →+* » K L) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n#align comap_comap comap_comap\n\n",
 "coe_zero":
 "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : K) = 0 :=\n  rfl\n#align coe_zero coe_zero\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ((«expr⊤» : subfield K) : set K) = Set.univ :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_to_subring":
 "@[simp]\ntheorem coe_to_subring (s : subfield K) : (s.to_subring : set K) = s :=\n  rfl\n#align coe_to_subring coe_to_subring\n\n",
 "coe_to_submonoid":
 "@[simp]\ntheorem coe_to_submonoid : (s.to_submonoid : set K) = s :=\n  rfl\n#align coe_to_submonoid coe_to_submonoid\n\n",
 "coe_to_add_subgroup":
 "@[simp]\ntheorem coe_to_add_subgroup : (s.to_add_subgroup : set K) = s :=\n  rfl\n#align coe_to_add_subgroup coe_to_add_subgroup\n\n",
 "coe_supr_of_directed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_supr_of_directed {ι} [hι : nonempty ι] {S : ι → subfield K} (hS : Directed (· ≤ ·) S) :\n    ((«expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (S i) :\n          subfield K) :\n        set K) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑(S i) :=\n  Set.ext fun x => by simp [mem_supr_of_directed hS]\n#align coe_supr_of_directed coe_supr_of_directed\n\n",
 "coe_subtype":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem coe_subtype : «expr⇑ » s.subtype = coe :=\n  rfl\n#align coe_subtype coe_subtype\n\n",
 "coe_sub":
 "@[simp, norm_cast]\ntheorem coe_sub (x y : s) : (↑(x - y) : K) = ↑x - ↑y :=\n  rfl\n#align coe_sub coe_sub\n\n",
 "coe_set_mk":
 "@[simp]\ntheorem coe_set_mk (S : set K) (h₁ h₂ h₃ h₄ h₅ h₆) : ((⟨S, h₁, h₂, h₃, h₄, h₅, h₆⟩ : subfield K) : set K) = S :=\n  rfl\n#align coe_set_mk coe_set_mk\n\n",
 "coe_rat_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n@[simp]\ntheorem coe_rat_smul (s : S) (a : exprℚ) (x : s) : (↑(«expr • » a x) : K) = «expr • » a x :=\n  rfl\n#align coe_rat_smul coe_rat_smul\n\n",
 "coe_rat_mem":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2020 Anne Baanen. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Anne Baanen\n-/\n-- See note [lower instance priority]\ntheorem coe_rat_mem (s : S) (x : exprℚ) : (x : K) ∈ s := by\n  simpa only [Rat.cast_def] using div_mem (coe_int_mem s x.num) (coe_nat_mem s x.denom)\n#align coe_rat_mem coe_rat_mem\n\n",
 "coe_rat_cast":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n@[simp]\ntheorem coe_rat_cast (s : S) (x : exprℚ) : ((x : s) : K) = x :=\n  rfl\n#align coe_rat_cast coe_rat_cast\n\n",
 "coe_range_restrict_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem coe_range_restrict_field (f : «expr →+* » K L) (x : K) : (f.range_restrict_field x : L) = f x :=\n  rfl\n#align coe_range_restrict_field coe_range_restrict_field\n\n",
 "coe_one":
 "@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : K) = 1 :=\n  rfl\n#align coe_one coe_one\n\n",
 "coe_neg":
 "@[simp, norm_cast]\ntheorem coe_neg (x : s) : (↑(-x) : K) = -↑x :=\n  rfl\n#align coe_neg coe_neg\n\n",
 "coe_mul":
 "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : (↑(x * y) : K) = ↑x * ↑y :=\n  rfl\n#align coe_mul coe_mul\n\n",
 "coe_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem coe_map : (s.map f : set L) = «expr '' » f s :=\n  rfl\n#align coe_map coe_map\n\n",
 "coe_inv":
 "@[simp, norm_cast]\ntheorem coe_inv (x : s) : (↑x⁻¹ : K) = (↑x)⁻¹ :=\n  rfl\n#align coe_inv coe_inv\n\n",
 "coe_int_mem":
 "protected theorem coe_int_mem (n : ℤ) : (n : K) ∈ s :=\n  coe_int_mem s n\n#align coe_int_mem coe_int_mem\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem coe_inf (p p' : subfield K) : ((«expr ⊓ » p p' : subfield K) : set K) = p ∩ p' :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_field_range":
 "@[simp]\ntheorem coe_field_range : (f.field_range : set L) = Set.range f :=\n  rfl\n#align coe_field_range coe_field_range\n\n",
 "coe_div":
 "@[simp, norm_cast]\ntheorem coe_div (x y : s) : (↑(x / y) : K) = ↑x / ↑y :=\n  rfl\n#align coe_div coe_div\n\n",
 "coe_copy":
 "@[simp]\ntheorem coe_copy (S : subfield K) (s : set K) (hs : s = ↑S) : (S.copy s hs : set K) = s :=\n  rfl\n#align coe_copy coe_copy\n\n",
 "coe_comap":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\n@[simp]\ntheorem coe_comap (s : subfield L) : (s.comap f : set K) = «expr ⁻¹' » f s :=\n  rfl\n#align coe_comap coe_comap\n\n",
 "coe_add":
 "@[simp, norm_cast]\ntheorem coe_add (x y : s) : (↑(x + y) : K) = ↑x + ↑y :=\n  rfl\n#align coe_add coe_add\n\n",
 "coe_Sup_of_directed_on":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\ntheorem coe_Sup_of_directed_on {S : set (subfield K)} (Sne : S.nonempty) (hS : DirectedOn (· ≤ ·) S) :\n    (↑(supₛ S) : set K) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑s :=\n  Set.ext fun x => by simp [mem_Sup_of_directed_on Sne hS]\n#align coe_Sup_of_directed_on coe_Sup_of_directed_on\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : set (subfield K)) :\n    ((infₛ S : subfield K) : set K) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s :=\n  show\n    ((infₛ («expr '' » subfield.to_subring S) : subring K) : set K) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" ↑s\n    by\n    ext x\n    rw [subring.coe_Inf, Set.mem_interᵢ, Set.mem_interᵢ]\n    exact\n      ⟨fun h s s' ⟨s_mem, s'_eq⟩ => h s.to_subring _ ⟨⟨s, s_mem, rfl⟩, s'_eq⟩,\n        fun h s s' ⟨⟨s'', s''_mem, s_eq⟩, (s'_eq : ↑s = s')⟩ => h s'' _ ⟨s''_mem, by simp [← s_eq, ← s'_eq]⟩⟩\n#align coe_Inf coe_Inf\n\n",
 "closure_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem closure_univ : closure (Set.univ : set K) = «expr⊤» :=\n  @coe_top K _ ▸ closure_eq («expr⊤»)\n#align closure_univ closure_univ\n\n",
 "closure_union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem closure_union (s t : set K) : closure (s ∪ t) = «expr ⊔ » (closure s) (closure t) :=\n  (subfield.gi K).gc.l_sup\n#align closure_union closure_union\n\n",
 "closure_sUnion":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem closure_sUnion (s : set (set K)) :\n    closure (⋃₀ s) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure t) :=\n  (subfield.gi K).gc.l_Sup\n#align closure_sUnion closure_sUnion\n\n",
 "closure_preimage_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⁻¹' » -/\ntheorem closure_preimage_le (f : «expr →+* » K L) (s : set L) : closure («expr ⁻¹' » f s) ≤ (closure s).comap f :=\n  closure_le.2 fun x hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n#align closure_preimage_le closure_preimage_le\n\n",
 "closure_mono":
 "/-- Subfield closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\ntheorem closure_mono ⦃s t : set K⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n#align closure_mono closure_mono\n\n",
 "closure_le":
 "/-- A subfield `t` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : set K} {t : subfield K} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h x hx => mem_closure.mp hx t h⟩\n#align closure_le closure_le\n\n",
 "closure_induction":
 "/-- An induction principle for closure membership. If `p` holds for `1`, and all elements\nof `s`, and is preserved under addition, negation, and multiplication, then `p` holds for all\nelements of the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : set K} {p : K → Prop} {x} (h : x ∈ closure s) (Hs : ∀ x ∈ s, p x) (H1 : p 1)\n    (Hadd : ∀ x y, p x → p y → p (x + y)) (Hneg : ∀ x, p x → p (-x)) (Hinv : ∀ x, p x → p x⁻¹)\n    (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  (@closure_le _ _ _ ⟨p, Hmul, H1, Hadd, @add_neg_self K _ 1 ▸ Hadd _ _ H1 (Hneg _ H1), Hneg, Hinv⟩).2 Hs h\n#align closure_induction closure_induction\n\n",
 "closure_eq_of_le":
 "theorem closure_eq_of_le {s : set K} {t : subfield K} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) : closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n#align closure_eq_of_le closure_eq_of_le\n\n",
 "closure_eq":
 "/-- Closure of a subfield `S` equals `S`. -/\ntheorem closure_eq (s : subfield K) : closure (s : set K) = s :=\n  (subfield.gi K).l_u_eq s\n#align closure_eq closure_eq\n\n",
 "closure_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem closure_empty : closure (∅ : set K) = «expr⊥» :=\n  (subfield.gi K).gc.l_bot\n#align closure_empty closure_empty\n\n",
 "closure_Union":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem closure_Union {ι} (s : ι → set K) :\n    closure («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" (s i)) =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (closure (s i)) :=\n  (subfield.gi K).gc.l_supr\n#align closure_Union closure_Union\n\n",
 "add_mem":
 "/-- A subfield is closed under addition. -/\nprotected theorem add_mem {x y : K} : x ∈ s → y ∈ s → x + y ∈ s :=\n  add_mem\n#align add_mem add_mem\n\n",
 "Inf_to_subring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem Inf_to_subring (s : set (subfield K)) :\n    (infₛ s).to_subring =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (subfield.to_subring t) :=\n  by\n  ext x\n  rw [mem_to_subring, mem_Inf]\n  erw [subring.mem_Inf]\n  exact\n    ⟨fun h p ⟨p', hp⟩ => hp ▸ subring.mem_Inf.mpr fun p ⟨hp', hp⟩ => hp ▸ h _ hp', fun h p hp =>\n      h p.to_subring\n        ⟨p,\n          subring.ext fun x =>\n            ⟨fun hx => subring.mem_Inf.mp hx _ ⟨hp, rfl⟩, fun hx =>\n              subring.mem_Inf.mpr fun p' ⟨hp, p'_eq⟩ => p'_eq ▸ hx⟩⟩⟩\n#align Inf_to_subring Inf_to_subring\n\n"}