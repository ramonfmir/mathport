{"primitive_element_inf_aux_exists_c":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem primitive_element_inf_aux_exists_c (f g : polynomial F) :\n    ∃ c : F, ∀ α' ∈ (f.map ϕ).roots, ∀ β' ∈ (g.map ϕ).roots, -(α' - α) / (β' - β) ≠ ϕ c :=\n  by\n  let sf := (f.map ϕ).roots\n  let sg := (g.map ϕ).roots\n  let s := (sf.bind fun α' => sg.map fun β' => -(α' - α) / (β' - β)).to_finset\n  let s' := s.preimage ϕ fun x hx y hy h => ϕ.injective h\n  obtain ⟨c, hc⟩ := infinite.exists_not_mem_finset s'\n  simp_rw [finset.mem_preimage, Multiset.mem_toFinset, Multiset.mem_bind, Multiset.mem_map] at hc\n  push_neg  at hc\n  exact ⟨c, hc⟩\n#align primitive_element_inf_aux_exists_c primitive_element_inf_aux_exists_c\n\n",
 "primitive_element_inf_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n-- This is the heart of the proof of the primitive element theorem. It shows that if `F` is\n-- infinite and `α` and `β` are separable over `F` then `F⟮α, β⟯` is generated by a single element.\ntheorem primitive_element_inf_aux [is_separable F E] :\n    ∃ γ : E,\n      «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" =\n        «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" :=\n  by\n  have hα := is_separable.is_integral F α\n  have hβ := is_separable.is_integral F β\n  let f := minpoly F α\n  let g := minpoly F β\n  let ιFE := algebra_map F E\n  let ιEE' := algebra_map E (splitting_field (g.map ιFE))\n  obtain ⟨c, hc⟩ := primitive_element_inf_aux_exists_c (ιEE'.comp ιFE) (ιEE' α) (ιEE' β) f g\n  let γ := α + «expr • » c β\n  suffices β_in_Fγ :\n    β ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\"\n  · use γ\n    apply le_antisymm\n    · rw [adjoin_le_iff]\n      have α_in_Fγ :\n        α ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" :=\n        by\n        rw [← add_sub_cancel α («expr • » c β)]\n        exact\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").sub_mem\n            (mem_adjoin_simple_self F γ)\n            ((«expr ⟮ ,⟯» F\n                    \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").to_subalgebra.smul_mem\n              β_in_Fγ c)\n      exact fun x hx => by cases hx <;> cases hx <;> cases hx <;> assumption\n    · rw [adjoin_simple_le_iff]\n      have α_in_Fαβ :\n        α ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" :=\n        subset_adjoin F {α, β} (Set.mem_insert α {β})\n      have β_in_Fαβ :\n        β ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" :=\n        subset_adjoin F {α, β} (Set.mem_insert_of_mem α rfl)\n      exact\n        («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").add_mem\n          α_in_Fαβ\n          ((«expr ⟮ ,⟯» F\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").smul_mem\n            β_in_Fαβ)\n  let p :=\n    EuclideanDomain.gcd\n      ((f.map\n            (algebra_map F\n              («expr ⟮ ,⟯» F\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\"))).comp\n        (C (adjoin_simple.gen F γ) - C ↑c * X))\n      (g.map\n        (algebra_map F\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")))\n  let h := EuclideanDomain.gcd ((f.map ιFE).comp (C γ - C (ιFE c) * X)) (g.map ιFE)\n  have map_g_ne_zero : g.map ιFE ≠ 0 := map_ne_zero (minpoly.ne_zero hβ)\n  have h_ne_zero : h ≠ 0 := mt euclidean_domain.gcd_eq_zero_iff.mp (not_and.mpr fun _ => map_g_ne_zero)\n  suffices p_linear :\n    p.map\n        (algebra_map\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") E) =\n      C h.leading_coeff * (X - C β)\n  · have finale :\n      β =\n        algebra_map\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") E\n          (-p.coeff 0 / p.coeff 1) :=\n      by\n      rw [map_div₀, RingHom.map_neg, ← coeff_map, ← coeff_map, p_linear]\n      simp [mul_sub, coeff_C, mul_div_cancel_left β (mt leading_coeff_eq_zero.mp h_ne_zero)]\n    rw [finale]\n    exact Subtype.mem (-p.coeff 0 / p.coeff 1)\n  have h_sep : h.separable := separable_gcd_right _ (is_separable.separable F β).map\n  have h_root : h.eval β = 0 := by\n    apply eval_gcd_eq_zero\n    ·\n      rw [eval_comp, eval_sub, eval_mul, eval_C, eval_C, eval_X, eval_map, ← aeval_def, ← algebra.smul_def,\n        add_sub_cancel, minpoly.aeval]\n    · rw [eval_map, ← aeval_def, minpoly.aeval]\n  have h_splits : splits ιEE' h := splits_of_splits_gcd_right ιEE' map_g_ne_zero (splitting_field.splits _)\n  have h_roots : ∀ x ∈ (h.map ιEE').roots, x = ιEE' β :=\n    by\n    intro x hx\n    rw [mem_roots_map h_ne_zero] at hx\n    specialize\n      hc (ιEE' γ - ιEE' (ιFE c) * x)\n        (by\n          have f_root := root_left_of_root_gcd hx\n          rw [eval₂_comp, eval₂_sub, eval₂_mul, eval₂_C, eval₂_C, eval₂_X, eval₂_map] at f_root\n          exact (mem_roots_map (minpoly.ne_zero hα)).mpr f_root)\n    specialize\n      hc x\n        (by\n          rw [mem_roots_map (minpoly.ne_zero hβ), ← eval₂_map]\n          exact root_right_of_root_gcd hx)\n    by_contra a\n    apply hc\n    apply (div_eq_iff (sub_ne_zero.mpr a)).mpr\n    simp only [algebra.smul_def, RingHom.map_add, RingHom.map_mul, RingHom.comp_apply]\n    ring\n  rw [← eq_X_sub_C_of_separable_of_root_eq h_sep h_root h_splits h_roots]\n  trans EuclideanDomain.gcd (_ : polynomial E) (_ : polynomial E)\n  · dsimp only [p]\n    convert\n      (gcd_map\n          (algebra_map\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n            E)).symm\n  · simpa [map_comp, polynomial.map_map, ← is_scalar_tower.algebra_map_eq, h]\n#align primitive_element_inf_aux primitive_element_inf_aux\n\n",
 "exists_primitive_element_of_finite_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-\nCopyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning, Patrick Lutz\n-/\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem exists_primitive_element_of_finite_top [Finite E] :\n    ∃ α : E,\n      «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊤» :=\n  by\n  obtain ⟨α, hα⟩ := is_cyclic.exists_generator (Units E)\n  use α\n  apply eq_top_iff.mpr\n  rintro x -\n  by_cases hx : x = 0\n  · rw [hx]\n    exact («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").zero_mem\n  · obtain ⟨n, hn⟩ := set.mem_range.mp (hα (Units.mk0 x hx))\n    rw [show x = α ^ n by\n        norm_cast\n        rw [hn, Units.val_mk0]]\n    exact zpow_mem (mem_adjoin_simple_self F ↑α) n\n#align exists_primitive_element_of_finite_top exists_primitive_element_of_finite_top\n\n",
 "exists_primitive_element_of_finite_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem exists_primitive_element_of_finite_bot [Finite F] [finite_dimensional F E] :\n    ∃ α : E,\n      «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊤» :=\n  haveI : Finite E := finite_of_finite F E\n  exists_primitive_element_of_finite_top F E\n#align exists_primitive_element_of_finite_bot exists_primitive_element_of_finite_bot\n\n",
 "exists_primitive_element":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- Primitive element theorem: a finite separable field extension `E` of `F` has a\n  primitive element, i.e. there is an `α ∈ E` such that `F⟮α⟯ = (⊤ : subalgebra F E)`.-/\ntheorem exists_primitive_element :\n    ∃ α : E,\n      «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊤» :=\n  by\n  rcases isEmpty_or_nonempty (fintype F) with (F_inf | ⟨⟨F_finite⟩⟩)\n  · let P : intermediate_field F E → Prop := fun K =>\n      ∃ α : E, «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = K\n    have base : P («expr⊥») := ⟨0, adjoin_zero⟩\n    have ih :\n      ∀ (K : intermediate_field F E) (x : E),\n        P K →\n          P\n            ((«expr ⟮ ,⟯» K\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n              F) :=\n      by\n      intro K β hK\n      cases' hK with α hK\n      rw [← hK, adjoin_simple_adjoin_simple]\n      haveI : Infinite F := is_empty_fintype.mp F_inf\n      cases' primitive_element_inf_aux F α β with γ hγ\n      exact ⟨γ, hγ.symm⟩\n    exact induction_on_adjoin P base ih («expr⊤»)\n  · exact exists_primitive_element_of_finite_bot F E\n#align exists_primitive_element exists_primitive_element\n\n",
 "card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n@[simp]\ntheorem alg_hom.card (F E K : Type _) [Field F] [Field E] [Field K] [is_alg_closed K] [algebra F E]\n    [finite_dimensional F E] [is_separable F E] [algebra F K] : fintype.card («expr →ₐ[ ] » E F K) = finrank F E :=\n  by\n  convert\n    (alg_hom.card_of_power_basis (field.power_basis_of_finite_of_separable F E) (is_separable.separable _ _)\n          (is_alg_closed.splits_codomain _)).trans\n      (power_basis.finrank _).symm\n  infer_instance\n#align alg_hom.card alg_hom.card\n\n"}