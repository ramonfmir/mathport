{"unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The minimal polynomial of an element `x` is uniquely characterized by its defining property:\nif there is another monic polynomial of minimal degree that has `x` as a root, then this polynomial\nis equal to the minimal polynomial of `x`. See also `minpoly.unique` which relaxes the\nassumptions on `S` in exchange for stronger assumptions on `R`. -/\ntheorem is_integrally_closed.minpoly.unique {s : S} {P : polynomial R} (hmo : P.monic) (hP : polynomial.aeval s P = 0)\n    (Pmin : ∀ Q : polynomial R, Q.monic → polynomial.aeval s Q = 0 → degree P ≤ degree Q) : P = minpoly R s :=\n  by\n  have hs : is_integral R s := ⟨P, hmo, hP⟩\n  symm; apply eq_of_sub_eq_zero\n  by_contra hnz\n  have := is_integrally_closed.degree_le_of_ne_zero hs hnz (by simp [hP])\n  contrapose! this\n  refine' degree_sub_lt _ (ne_zero hs) _\n  · exact le_antisymm (min R s hmo hP) (Pmin (minpoly R s) (monic hs) (aeval R s))\n  · rw [(monic hs).leading_coeff, hmo.leading_coeff]\n#align is_integrally_closed.minpoly.unique is_integrally_closed.minpoly.unique\n\n",
 "ker_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem ker_eval {s : S} (hs : is_integral R s) :\n    ((polynomial.aeval s).to_ring_hom : «expr →+* » (polynomial R) S).ker =\n      ideal.span ({minpoly R s} : set (polynomial R)) :=\n  by\n  apply le_antisymm <;> intro p hp\n  ·\n    rwa [ring_hom.mem_ker, alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom, is_integrally_closed_dvd p hs, ←\n      ideal.mem_span_singleton] at hp\n  ·\n    rwa [ring_hom.mem_ker, alg_hom.to_ring_hom_eq_coe, alg_hom.coe_to_ring_hom, is_integrally_closed_dvd p hs, ←\n      ideal.mem_span_singleton]\n#align ker_eval ker_eval\n\n",
 "is_integrally_closed_eq_field_fractions''":
 "/-- For GCD domains, the minimal polynomial over the ring is the same as the minimal polynomial\nover the fraction field. Compared to `minpoly.is_integrally_closed_eq_field_fractions`, this\nversion is useful if the element is in a ring that is not a domain -/\ntheorem is_integrally_closed_eq_field_fractions'' [NoZeroSMulDivisors S L] {s : S} (hs : is_integral R s) :\n    minpoly K (algebra_map S L s) = map (algebra_map R K) (minpoly R s) :=\n  by\n  --the idea of the proof is the following: since the minpoly of `a` over `Frac(R)` divides the\n  --minpoly of `a` over `R`, it is itself in `R`. Hence its degree is greater or equal to that of\n  --the minpoly of `a` over `R`. But the minpoly of `a` over `Frac(R)` divides the minpoly of a\n  --over `R` in `R[X]` so we are done.\n  --a few \"trivial\" preliminary results to set up the proof\n  have lem0 : minpoly K (algebra_map S L s) ∣ map (algebra_map R K) (minpoly R s) := dvd_map_of_is_scalar_tower' R K L s\n  have lem1 : is_integral K (algebra_map S L s) :=\n    by\n    refine' is_integral_map_of_comp_eq_of_is_integral (algebra_map R K) _ _ hs\n    rw [← is_scalar_tower.algebra_map_eq, ← is_scalar_tower.algebra_map_eq]\n  obtain ⟨g, hg⟩ := is_integrally_closed.eq_map_mul_C_of_dvd K (minpoly.monic hs) lem0\n  rw [(minpoly.monic lem1).leading_coeff, C_1, mul_one] at hg\n  have lem2 : polynomial.aeval s g = 0 :=\n    by\n    have := minpoly.aeval K (algebra_map S L s)\n    rw [← hg, ← map_aeval_eq_aeval_map, ← map_zero (algebra_map S L)] at this\n    · exact no_zero_smul_divisors.algebra_map_injective S L this\n    · rw [← is_scalar_tower.algebra_map_eq, ← is_scalar_tower.algebra_map_eq]\n  have lem3 : g.monic := by\n    simpa only [function.injective.monic_map_iff (is_fraction_ring.injective R K), hg] using minpoly.monic lem1\n  rw [← hg]\n  refine' congr_arg _ (eq.symm (polynomial.eq_of_monic_of_dvd_of_nat_degree_le lem3 (minpoly.monic hs) _ _))\n  · rwa [← map_dvd_map _ (is_fraction_ring.injective R K) lem3, hg]\n  · exact nat_degree_le_nat_degree (minpoly.min R s lem3 lem2)\n#align is_integrally_closed_eq_field_fractions'' is_integrally_closed_eq_field_fractions''\n\n",
 "is_integrally_closed_eq_field_fractions'":
 "/-- For integrally closed domains, the minimal polynomial over the ring is the same as the minimal\npolynomial over the fraction field. Compared to `minpoly.is_integrally_closed_eq_field_fractions`,\nthis version is useful if the element is in a ring that is already a `K`-algebra. -/\ntheorem is_integrally_closed_eq_field_fractions' [IsDomain S] [algebra K S] [IsScalarTower R K S] {s : S}\n    (hs : is_integral R s) : minpoly K s = (minpoly R s).map (algebra_map R K) :=\n  by\n  let L := fraction_ring S\n  rw [← is_integrally_closed_eq_field_fractions K L hs]\n  refine' minpoly.eq_of_algebra_map_eq (is_fraction_ring.injective S L) (is_integral_of_is_scalar_tower hs) rfl\n#align is_integrally_closed_eq_field_fractions' is_integrally_closed_eq_field_fractions'\n\n",
 "is_integrally_closed_eq_field_fractions":
 "/-- For integrally closed domains, the minimal polynomial over the ring is the same as the minimal\npolynomial over the fraction field. See `minpoly.is_integrally_closed_eq_field_fractions'` if\n`S` is already a `K`-algebra. -/\ntheorem is_integrally_closed_eq_field_fractions [IsDomain S] {s : S} (hs : is_integral R s) :\n    minpoly K (algebra_map S L s) = (minpoly R s).map (algebra_map R K) :=\n  by\n  refine' (eq_of_irreducible_of_monic _ _ _).symm\n  · exact (polynomial.monic.irreducible_iff_irreducible_map_fraction_map (monic hs)).1 (Irreducible hs)\n  · rw [aeval_map_algebra_map, aeval_algebra_map_apply, aeval, map_zero]\n  · exact (monic hs).map _\n#align is_integrally_closed_eq_field_fractions is_integrally_closed_eq_field_fractions\n\n",
 "is_integrally_closed_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr %ₘ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- For integrally closed rings, the minimal polynomial divides any polynomial that has the\n  integral element as root. See also `minpoly.dvd` which relaxes the assumptions on `S`\n  in exchange for stronger assumptions on `R`. -/\ntheorem is_integrally_closed_dvd [nontrivial R] (p : polynomial R) {s : S} (hs : is_integral R s) :\n    polynomial.aeval s p = 0 ↔ minpoly R s ∣ p :=\n  by\n  refine' ⟨fun hp => _, fun hp => _⟩\n  · let K := fraction_ring R\n    let L := fraction_ring S\n    have : minpoly K (algebra_map S L s) ∣ map (algebra_map R K) («expr %ₘ » p (minpoly R s)) :=\n      by\n      rw [map_mod_by_monic _ (minpoly.monic hs), mod_by_monic_eq_sub_mul_div]\n      refine' dvd_sub (minpoly.dvd K (algebra_map S L s) _) _\n      rw [← map_aeval_eq_aeval_map, hp, map_zero]\n      rw [← is_scalar_tower.algebra_map_eq, ← is_scalar_tower.algebra_map_eq]\n      apply dvd_mul_of_dvd_left\n      rw [is_integrally_closed_eq_field_fractions'' K L hs]\n      exact monic.map _ (minpoly.monic hs)\n    rw [is_integrally_closed_eq_field_fractions'' _ _ hs,\n      map_dvd_map (algebra_map R K) (is_fraction_ring.injective R K) (minpoly.monic hs)] at this\n    rw [← dvd_iff_mod_by_monic_eq_zero (minpoly.monic hs)]\n    refine' polynomial.eq_zero_of_dvd_of_degree_lt this (degree_mod_by_monic_lt p <| minpoly.monic hs)\n    all_goals infer_instance\n  ·\n    simpa only [ring_hom.mem_ker, RingHom.coe_comp, coe_eval_ring_hom, coe_map_ring_hom, Function.comp_apply, eval_map,\n      ← aeval_def] using aeval_eq_zero_of_dvd_aeval_eq_zero hp (minpoly.aeval R s)\n#align is_integrally_closed_dvd is_integrally_closed_dvd\n\n",
 "injective":
 "theorem to_adjoin.injective (hx : is_integral R x) : function.injective (minpoly.to_adjoin R x) :=\n  by\n  refine' (injective_iff_map_eq_zero _).2 fun P₁ hP₁ => _\n  obtain ⟨P, hP⟩ := mk_surjective (minpoly.monic hx) P₁\n  by_cases hPzero : P = 0\n  · simpa [hPzero] using hP.symm\n  rw [← hP, minpoly.to_adjoin_apply', lift_hom_mk, ← subalgebra.coe_eq_zero, aeval_subalgebra_coe, [anonymous],\n    is_integrally_closed_dvd _ hx] at hP₁\n  obtain ⟨Q, hQ⟩ := hP₁\n  rw [← hP, hQ, RingHom.map_mul, mk_self, zero_mul]\n#align to_adjoin.injective to_adjoin.injective\n\n",
 "gcd_domain_eq_field_fractions'":
 "/-- For GCD domains, the minimal polynomial over the ring is the same as the minimal polynomial\nover the fraction field. Compared to `minpoly.gcd_domain_eq_field_fractions`, this version is useful\nif the element is in a ring that is already a `K`-algebra. -/\ntheorem gcd_domain_eq_field_fractions' [IsDomain S] [algebra K S] [IsScalarTower R K S] {s : S} (hs : is_integral R s) :\n    minpoly K s = (minpoly R s).map (algebra_map R K) :=\n  by\n  let L := fraction_ring S\n  rw [← gcd_domain_eq_field_fractions K L hs]\n  refine' minpoly.eq_of_algebra_map_eq (is_fraction_ring.injective S L) (is_integral_of_is_scalar_tower hs) rfl\n#align gcd_domain_eq_field_fractions' gcd_domain_eq_field_fractions'\n\n",
 "gcd_domain_eq_field_fractions":
 "/-\nCopyright (c) 2019 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\n/-- For GCD domains, the minimal polynomial over the ring is the same as the minimal polynomial\nover the fraction field. See `minpoly.gcd_domain_eq_field_fractions'` if `S` is already a\n`K`-algebra. -/\ntheorem gcd_domain_eq_field_fractions [IsDomain S] {s : S} (hs : is_integral R s) :\n    minpoly K (algebra_map S L s) = (minpoly R s).map (algebra_map R K) :=\n  by\n  refine' (eq_of_irreducible_of_monic _ _ _).symm\n  ·\n    exact\n      (polynomial.is_primitive.irreducible_iff_irreducible_map_fraction_map\n            (polynomial.monic.is_primitive (monic hs))).1\n        (Irreducible hs)\n  · rw [aeval_map_algebra_map, aeval_algebra_map_apply, aeval, map_zero]\n  · exact (monic hs).map _\n#align gcd_domain_eq_field_fractions gcd_domain_eq_field_fractions\n\n",
 "gcd_domain_dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gcd_domain_dvd [NormalizedGCDMonoid R] {s : S} (hs : is_integral R s) {P : polynomial R} (hP : P ≠ 0)\n    (hroot : polynomial.aeval s P = 0) : minpoly R s ∣ P :=\n  by\n  let K := fraction_ring R\n  let L := fraction_ring S\n  let P₁ := P.prim_part\n  suffices minpoly R s ∣ P₁ by exact dvd_trans this (prim_part_dvd _)\n  apply (is_primitive.dvd_iff_fraction_map_dvd_fraction_map K (monic hs).is_primitive P.is_primitive_prim_part).2\n  let y := algebra_map S L s\n  have hy : is_integral R y := hs.algebra_map\n  rw [← gcd_domain_eq_field_fractions K L hs]\n  refine' dvd _ _ _\n  rw [aeval_map_algebra_map, aeval_algebra_map_apply, aeval_prim_part_eq_zero hP hroot, map_zero]\n#align gcd_domain_dvd gcd_domain_dvd\n\n",
 "degree_le_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If an element `x` is a root of a nonzero polynomial `p`, then the degree of `p` is at least the\ndegree of the minimal polynomial of `x`. See also `minpoly.degree_le_of_ne_zero` which relaxes the\nassumptions on `S` in exchange for stronger assumptions on `R`. -/\ntheorem is_integrally_closed.degree_le_of_ne_zero {s : S} (hs : is_integral R s) {p : polynomial R} (hp0 : p ≠ 0)\n    (hp : polynomial.aeval s p = 0) : degree (minpoly R s) ≤ degree p :=\n  by\n  rw [degree_eq_nat_degree (minpoly.ne_zero hs), degree_eq_nat_degree hp0]\n  norm_cast\n  exact nat_degree_le_of_dvd ((is_integrally_closed_dvd _ hs).mp hp) hp0\n#align is_integrally_closed.degree_le_of_ne_zero is_integrally_closed.degree_le_of_ne_zero\n\n"}