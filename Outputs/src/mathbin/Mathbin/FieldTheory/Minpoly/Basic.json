{"unique'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem unique' {p : polynomial A} (hm : p.monic) (hp : Polynomial.aeval x p = 0)\n    (hl : ∀ q : polynomial A, degree q < degree p → q = 0 ∨ Polynomial.aeval x q ≠ 0) : p = minpoly A x :=\n  by\n  nontriviality A\n  have hx : is_integral A x := ⟨p, hm, hp⟩\n  obtain h | h := hl _ ((minpoly A x).degree_mod_by_monic_lt hm)\n  swap\n  · exact (h <| (aeval_mod_by_monic_eq_self_of_root hm hp).trans <| aeval A x).elim\n  obtain ⟨r, hr⟩ := (dvd_iff_mod_by_monic_eq_zero hm).1 h\n  rw [hr]\n  have hlead := congr_arg leading_coeff hr\n  rw [mul_comm, leading_coeff_mul_monic hm, (monic hx).leading_coeff] at hlead\n  have : nat_degree r ≤ 0 :=\n    by\n    have hr0 : r ≠ 0 := by\n      rintro rfl\n      exact NeZero hx (MulZeroClass.mul_zero p ▸ hr)\n    apply_fun nat_degree  at hr\n    rw [hm.nat_degree_mul' hr0] at hr\n    apply nat.le_of_add_le_add_left\n    rw [add_zero]\n    exact hr.symm.trans_le (nat_degree_le_nat_degree <| min A x hm hp)\n  rw [eq_C_of_nat_degree_le_zero this, ← nat.eq_zero_of_le_zero this, ← leading_coeff, ← hlead, C_1, mul_one]\n#align unique' unique'\n\n",
 "subsingleton":
 "@[nontriviality]\ntheorem subsingleton [subsingleton B] : minpoly A x = 1 :=\n  by\n  nontriviality A\n  have := minpoly.min A x monic_one (subsingleton.elim _ _)\n  rw [degree_one] at this\n  cases' le_or_lt (minpoly A x).degree 0 with h h\n  · rwa [(monic ⟨1, monic_one, by simp⟩ : (minpoly A x).monic).degree_le_zero_iff_eq_one] at h\n  · exact (this.not_lt h).elim\n#align subsingleton subsingleton\n\n",
 "not_is_unit":
 "/-- A minimal polynomial is not a unit. -/\ntheorem not_is_unit [Nontrivial B] : ¬IsUnit (minpoly A x) :=\n  by\n  haveI : Nontrivial A := (algebraMap A B).domain_nontrivial\n  by_cases hx : is_integral A x\n  · exact mt (monic hx).eq_one_of_is_unit (ne_one A x)\n  · rw [eq_zero hx]\n    exact not_isUnit_zero\n#align not_is_unit not_is_unit\n\n",
 "ne_one":
 "/-- A minimal polynomial is not `1`. -/\ntheorem ne_one [Nontrivial B] : minpoly A x ≠ 1 := by\n  intro h\n  refine' (one_ne_zero : (1 : B) ≠ 0) _\n  simpa using congr_arg (Polynomial.aeval x) h\n#align ne_one ne_one\n\n",
 "nat_degree_pos":
 "/-- The degree of a minimal polynomial, as a natural number, is positive. -/\ntheorem nat_degree_pos [Nontrivial B] (hx : is_integral A x) : 0 < natDegree (minpoly A x) :=\n  by\n  rw [pos_iff_ne_zero]\n  intro ndeg_eq_zero\n  have eq_one : minpoly A x = 1 := by\n    rw [eq_C_of_nat_degree_eq_zero ndeg_eq_zero]\n    convert C_1\n    simpa only [ndeg_eq_zero.symm] using (monic hx).leading_coeff\n  simpa only [eq_one, AlgHom.map_one, one_ne_zero] using aeval A x\n#align nat_degree_pos nat_degree_pos\n\n",
 "monic":
 "/-\nCopyright (c) 2019 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Johan Commelin\n-/\n/-- A minimal polynomial is monic. -/\ntheorem monic (hx : is_integral A x) : Monic (minpoly A x) :=\n  by\n  delta minpoly\n  rw [dif_pos hx]\n  exact (degree_lt_wf.min_mem _ hx).1\n#align monic monic\n\n",
 "min":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- The defining property of the minimal polynomial of an element `x`:\nit is the monic polynomial with smallest degree that has `x` as its root. -/\ntheorem min {p : polynomial A} (pmonic : p.monic) (hp : Polynomial.aeval x p = 0) : degree (minpoly A x) ≤ degree p :=\n  by\n  delta minpoly; split_ifs with hx\n  · exact le_of_not_lt (degree_lt_wf.not_lt_min _ hx ⟨pmonic, hp⟩)\n  · simp only [degree_zero, bot_le]\n#align min min\n\n",
 "mem_range_of_degree_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_range_of_degree_eq_one (hx : (minpoly A x).degree = 1) : x ∈ (algebraMap A B).range :=\n  by\n  have h : is_integral A x := by\n    by_contra h\n    rw [eq_zero h, degree_zero, ← WithBot.coe_one] at hx\n    exact ne_of_lt (show «expr⊥» < ↑1 from WithBot.bot_lt_coe 1) hx\n  have key := minpoly.aeval A x\n  rw [eq_X_add_C_of_degree_eq_one hx, (minpoly.monic h).leading_coeff, C_1, one_mul, aeval_add, aeval_C, aeval_X, ←\n    eq_neg_iff_add_eq_zero, ← RingHom.map_neg] at key\n  exact ⟨-(minpoly A x).coeff 0, key.symm⟩\n#align mem_range_of_degree_eq_one mem_range_of_degree_eq_one\n\n",
 "map_ne_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_ne_one [Nontrivial B] {R : Type _} [Semiring R] [Nontrivial R] (f : «expr →+* » A R) :\n    (minpoly A x).map f ≠ 1 := by\n  by_cases hx : is_integral A x\n  · exact mt ((monic hx).eq_one_of_map_eq_one f) (ne_one A x)\n  · rw [eq_zero hx, Polynomial.map_zero]\n    exact zero_ne_one\n#align map_ne_one map_ne_one\n\n",
 "eq_zero":
 "theorem eq_zero (hx : ¬is_integral A x) : minpoly A x = 0 :=\n  dif_neg hx\n#align eq_zero eq_zero\n\n",
 "eq_X_sub_C_of_algebra_map_inj":
 "/-- If `B/A` is an injective ring extension, and `a` is an element of `A`,\nthen the minimal polynomial of `algebra_map A B a` is `X - C a`. -/\ntheorem eq_X_sub_C_of_algebra_map_inj (a : A) (hf : function.injective (algebraMap A B)) :\n    minpoly A (algebraMap A B a) = X - C a := by\n  nontriviality A\n  refine' (unique' A _ (monic_X_sub_C a) _ _).symm\n  · rw [map_sub, aeval_C, aeval_X, sub_self]\n  simp_rw [or_iff_not_imp_left]\n  intro q hl h0\n  rw [← nat_degree_lt_nat_degree_iff h0, nat_degree_X_sub_C, Nat.lt_one_iff] at hl\n  rw [eq_C_of_nat_degree_eq_zero hl] at h0⊢\n  rwa [aeval_C, map_ne_zero_iff _ hf, ← C_ne_zero]\n#align eq_X_sub_C_of_algebra_map_inj eq_X_sub_C_of_algebra_map_inj\n\n",
 "degree_pos":
 "/-- The degree of a minimal polynomial is positive. -/\ntheorem degree_pos [Nontrivial B] (hx : is_integral A x) : 0 < degree (minpoly A x) :=\n  natDegree_pos_iff_degree_pos.mp (nat_degree_pos hx)\n#align degree_pos degree_pos\n\n",
 "aeval_ne_zero_of_dvd_not_unit_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem aeval_ne_zero_of_dvd_not_unit_minpoly {a : polynomial A} (hx : is_integral A x) (hamonic : a.monic)\n    (hdvd : DvdNotUnit a (minpoly A x)) : Polynomial.aeval x a ≠ 0 :=\n  by\n  refine' fun ha => (min A x hamonic ha).not_lt (degree_lt_degree _)\n  obtain ⟨b, c, hu, he⟩ := hdvd\n  have hcm := hamonic.of_mul_monic_left (he.subst <| monic hx)\n  rw [he, hamonic.nat_degree_mul hcm]\n  apply Nat.lt_add_of_zero_lt_left _ _ (lt_of_not_le fun h => hu _)\n  rw [eq_C_of_nat_degree_le_zero h, ← nat.eq_zero_of_le_zero h, ← leading_coeff, hcm.leading_coeff, C_1]\n  exact isUnit_one\n#align aeval_ne_zero_of_dvd_not_unit_minpoly aeval_ne_zero_of_dvd_not_unit_minpoly\n\n",
 "aeval":
 "/-- An element is a root of its minimal polynomial. -/\n@[simp]\ntheorem aeval : aeval x (minpoly A x) = 0 := by\n  delta minpoly; split_ifs with hx\n  · exact (degree_lt_wf.min_mem _ hx).2\n  · exact aeval_zero _\n#align aeval aeval\n\n",
 "NeZero":
 "#print NeZero /-\n/-- A minimal polynomial is nonzero. -/\ntheorem NeZero [Nontrivial A] (hx : is_integral A x) : minpoly A x ≠ 0 :=\n  (monic hx).ne_zero\n#align ne_zero NeZero\n-/\n\n",
 "Irreducible":
 "#print Irreducible /-\n/-- A minimal polynomial is irreducible. -/\ntheorem Irreducible (hx : is_integral A x) : Irreducible (minpoly A x) :=\n  by\n  refine' (irreducible_of_monic (monic hx) <| ne_one A x).2 fun f g hf hg he => _\n  rw [← hf.is_unit_iff, ← hg.is_unit_iff]\n  by_contra' h\n  have heval := congr_arg (Polynomial.aeval x) he\n  rw [aeval A x, aeval_mul, mul_eq_zero] at heval\n  cases heval\n  · exact aeval_ne_zero_of_dvd_not_unit_minpoly hx hf ⟨hf.ne_zero, g, h.2, he.symm⟩ heval\n  · refine' aeval_ne_zero_of_dvd_not_unit_minpoly hx hg ⟨hg.ne_zero, f, h.1, _⟩ heval\n    rw [mul_comm, he]\n#align irreducible Irreducible\n-/\n\n"}