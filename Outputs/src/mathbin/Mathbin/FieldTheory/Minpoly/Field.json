{"zero":
 "/-- The minimal polynomial of `0` is `X`. -/\n@[simp]\ntheorem zero : minpoly A (0 : B) = X := by\n  simpa only [add_zero, C_0, sub_eq_add_neg, neg_zero, RingHom.map_zero] using eq_X_sub_C B (0 : A)\n#align zero zero\n\n",
 "sub_algebra_map":
 "theorem sub_algebra_map {B : Type _} [CommRing B] [Algebra A B] {x : B} (hx : is_integral A x) (a : A) :\n    minpoly A (x - algebraMap A B a) = (minpoly A x).comp (X + C a) := by\n  simpa [sub_eq_add_neg] using add_algebra_map hx (-a)\n#align sub_algebra_map sub_algebra_map\n\n",
 "root":
 "/-- If `L/K` is a field extension and an element `y` of `K` is a root of the minimal polynomial\nof an element `x ∈ L`, then `y` maps to `x` under the field embedding. -/\ntheorem root {x : B} (hx : is_integral A x) {y : A} (h : IsRoot (minpoly A x) y) : algebraMap A B y = x :=\n  by\n  have key : minpoly A x = X - C y :=\n    eq_of_monic_of_associated (monic hx) (monic_X_sub_C y)\n      (associated_of_dvd_dvd ((irreducible_X_sub_C y).dvd_symm (irreducible hx) (dvd_iff_isRoot.2 h))\n        (dvd_iff_isRoot.2 h))\n  have := aeval A x\n  rwa [key, AlgHom.map_sub, aeval_X, aeval_C, sub_eq_zero, eq_comm] at this\n#align root root\n\n",
 "one":
 "/-- The minimal polynomial of `1` is `X - 1`. -/\n@[simp]\ntheorem one : minpoly A (1 : B) = X - 1 := by\n  simpa only [RingHom.map_one, C_1, sub_eq_add_neg] using eq_X_sub_C B (1 : A)\n#align one one\n\n",
 "ne_zero_of_finite_field_extension":
 "theorem ne_zero_of_finite_field_extension (e : B) [FiniteDimensional A B] : minpoly A e ≠ 0 :=\n  minpoly.ne_zero <| is_integral_of_noetherian (IsNoetherian.iff_fg.2 inferInstance) _\n#align ne_zero_of_finite_field_extension ne_zero_of_finite_field_extension\n\n",
 "eq_of_irreducible_of_monic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_of_irreducible_of_monic [Nontrivial B] {p : polynomial A} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) (hp3 : p.monic) : p = minpoly A x :=\n  let ⟨q, hq⟩ := dvd A x hp2\n  eq_of_monic_of_associated hp3 (monic ⟨p, ⟨hp3, hp2⟩⟩) <|\n    mul_one (minpoly A x) ▸ hq.symm ▸ Associated.mul_left _ <|\n      associated_one_iff_isUnit.2 <| (hp1.is_unit_or_is_unit hq).resolve_left <| not_is_unit A x\n#align eq_of_irreducible_of_monic eq_of_irreducible_of_monic\n\n",
 "eq_of_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem eq_of_irreducible [Nontrivial B] {p : polynomial A} (hp1 : Irreducible p) (hp2 : Polynomial.aeval x p = 0) :\n    p * C p.leading_coeff⁻¹ = minpoly A x :=\n  by\n  have : p.leading_coeff ≠ 0 := leading_coeff_ne_zero.mpr hp1.ne_zero\n  apply eq_of_irreducible_of_monic\n  ·\n    exact\n      Associated.irreducible\n        ⟨⟨C p.leading_coeff⁻¹, C p.leading_coeff, by rwa [← C_mul, inv_mul_cancel, C_1], by\n            rwa [← C_mul, mul_inv_cancel, C_1]⟩,\n          rfl⟩\n        hp1\n  · rw [aeval_mul, hp2, MulZeroClass.zero_mul]\n  · rwa [Polynomial.Monic, leading_coeff_mul, leading_coeff_C, mul_inv_cancel]\n#align eq_of_irreducible eq_of_irreducible\n\n",
 "eq_of_algebra_map_eq":
 "/-- If `y` is the image of `x` in an extension, their minimal polynomials coincide.\n\nWe take `h : y = algebra_map L T x` as an argument because `rw h` typically fails\nsince `is_integral R y` depends on y.\n-/\ntheorem eq_of_algebra_map_eq {K S T : Type _} [Field K] [CommRing S] [CommRing T] [Algebra K S] [Algebra K T]\n    [Algebra S T] [IsScalarTower K S T] (hST : function.injective (algebraMap S T)) {x : S} {y : T}\n    (hx : is_integral K x) (h : y = algebraMap S T x) : minpoly K x = minpoly K y :=\n  minpoly.unique _ _ (minpoly.monic hx) (by rw [h, aeval_algebra_map_apply, minpoly.aeval, RingHom.map_zero])\n    fun q q_monic root_q =>\n    minpoly.min _ _ q_monic\n      ((aeval_algebraMap_eq_zero_iff_of_injective hST).mp (h ▸ root_q : Polynomial.aeval (algebraMap S T x) q = 0))\n#align eq_of_algebra_map_eq eq_of_algebra_map_eq\n\n",
 "eq_X_sub_C'":
 "theorem eq_X_sub_C' (a : A) : minpoly A a = X - C a :=\n  eq_X_sub_C A a\n#align eq_X_sub_C' eq_X_sub_C'\n\n",
 "eq_X_sub_C":
 "/-- If `B/K` is a nontrivial algebra over a field, and `x` is an element of `K`,\nthen the minimal polynomial of `algebra_map K B x` is `X - C x`. -/\ntheorem eq_X_sub_C (a : A) : minpoly A (algebraMap A B a) = X - C a :=\n  eq_X_sub_C_of_algebra_map_inj a (algebraMap A B).injective\n#align eq_X_sub_C eq_X_sub_C\n\n",
 "dvd_map_of_is_scalar_tower'":
 "theorem dvd_map_of_is_scalar_tower' (R : Type _) {S : Type _} (K L : Type _) [CommRing R] [CommRing S] [Field K]\n    [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L] [Algebra R L] [IsScalarTower R K L]\n    [IsScalarTower R S L] (s : S) : minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) :=\n  by\n  apply minpoly.dvd K (algebraMap S L s)\n  rw [← map_aeval_eq_aeval_map, minpoly.aeval, map_zero]\n  rw [← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n#align dvd_map_of_is_scalar_tower' dvd_map_of_is_scalar_tower'\n\n",
 "dvd_map_of_is_scalar_tower":
 "theorem dvd_map_of_is_scalar_tower (A K : Type _) {R : Type _} [CommRing A] [Field K] [CommRing R] [Algebra A K]\n    [Algebra A R] [Algebra K R] [IsScalarTower A K R] (x : R) : minpoly K x ∣ (minpoly A x).map (algebraMap A K) :=\n  by\n  refine' minpoly.dvd K x _\n  rw [aeval_map_algebra_map, minpoly.aeval]\n#align dvd_map_of_is_scalar_tower dvd_map_of_is_scalar_tower\n\n",
 "dvd":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If an element `x` is a root of a polynomial `p`, then the minimal polynomial of `x` divides `p`.\nSee also `minpoly.gcd_domain_dvd` which relaxes the assumptions on `A` in exchange for stronger\nassumptions on `B`. -/\ntheorem dvd {p : polynomial A} (hp : Polynomial.aeval x p = 0) : minpoly A x ∣ p :=\n  by\n  by_cases hp0 : p = 0\n  · simp only [hp0, dvd_zero]\n  have hx : is_integral A x := by\n    rw [← is_algebraic_iff_is_integral]\n    exact ⟨p, hp0, hp⟩\n  rw [← dvd_iff_mod_by_monic_eq_zero (monic hx)]\n  by_contra hnz\n  have := degree_le_of_ne_zero A x hnz _\n  · contrapose! this\n    exact degree_mod_by_monic_lt _ (monic hx)\n  · rw [← mod_by_monic_add_div p (monic hx)] at hp\n    simpa using hp\n#align dvd dvd\n\n",
 "degree_le_of_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2019 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca, Johan Commelin\n-/\n/-- If an element `x` is a root of a nonzero polynomial `p`, then the degree of `p` is at least the\ndegree of the minimal polynomial of `x`. See also `gcd_domain_degree_le_of_ne_zero` which relaxes\nthe assumptions on `A` in exchange for stronger assumptions on `B`. -/\ntheorem degree_le_of_ne_zero {p : polynomial A} (pnz : p ≠ 0) (hp : Polynomial.aeval x p = 0) :\n    degree (minpoly A x) ≤ degree p :=\n  calc\n    degree (minpoly A x) ≤ degree (p * C (leadingCoeff p)⁻¹) := min A x (monic_mul_leadingCoeff_inv pnz) (by simp [hp])\n    _ = degree p := degree_mul_leadingCoeff_inv p pnz\n    \n#align degree_le_of_ne_zero degree_le_of_ne_zero\n\n",
 "coeff_zero_ne_zero":
 "/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem coeff_zero_ne_zero (hx : is_integral A x) (h : x ≠ 0) : coeff (minpoly A x) 0 ≠ 0 :=\n  by\n  contrapose! h\n  simpa only [hx, coeff_zero_eq_zero] using h\n#align coeff_zero_ne_zero coeff_zero_ne_zero\n\n",
 "coeff_zero_eq_zero":
 "/-- The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. -/\n@[simp]\ntheorem coeff_zero_eq_zero (hx : is_integral A x) : coeff (minpoly A x) 0 = 0 ↔ x = 0 :=\n  by\n  constructor\n  · intro h\n    have zero_root := zero_is_root_of_coeff_zero_eq_zero h\n    rw [← root hx zero_root]\n    exact RingHom.map_zero _\n  · rintro rfl\n    simp\n#align coeff_zero_eq_zero coeff_zero_eq_zero\n\n",
 "aux_inj_roots_of_min_poly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- Marked as `noncomputable!` since this definition takes multiple seconds to compile,\n-- and isn't very computable in practice (since neither `finrank` nor `fin_basis` are).\ntheorem aux_inj_roots_of_min_poly : injective (roots_of_min_poly_pi_type F E K) :=\n  by\n  intro f g h\n  suffices (f : «expr →ₗ[ ] » E F K) = g by rwa [FunLike.ext'_iff] at this⊢\n  rw [funext_iff] at h\n  exact LinearMap.ext_on (FiniteDimensional.finBasis F E).span_eq fun e he => subtype.ext_iff.mp (h ⟨e, he⟩)\n#align aux_inj_roots_of_min_poly aux_inj_roots_of_min_poly\n\n",
 "aeval_of_is_scalar_tower":
 "/-- If `y` is a conjugate of `x` over a field `K`, then it is a conjugate over a subring `R`. -/\ntheorem aeval_of_is_scalar_tower (R : Type _) {K T U : Type _} [CommRing R] [Field K] [CommRing T] [Algebra R K]\n    [Algebra K T] [Algebra R T] [IsScalarTower R K T] [CommSemiring U] [Algebra K U] [Algebra R U] [IsScalarTower R K U]\n    (x : T) (y : U) (hy : Polynomial.aeval y (minpoly K x) = 0) : Polynomial.aeval y (minpoly R x) = 0 :=\n  aeval_map_algebraMap K y (minpoly R x) ▸\n    eval₂_eq_zero_of_dvd_of_eval₂_eq_zero (algebraMap K U) y (minpoly.dvd_map_of_is_scalar_tower R K x) hy\n#align aeval_of_is_scalar_tower aeval_of_is_scalar_tower\n\n",
 "add_algebra_map":
 "theorem add_algebra_map {B : Type _} [CommRing B] [Algebra A B] {x : B} (hx : is_integral A x) (a : A) :\n    minpoly A (x + algebraMap A B a) = (minpoly A x).comp (X - C a) :=\n  by\n  refine' (minpoly.unique _ _ ((minpoly.monic hx).comp_X_sub_C _) _ fun q qmo hq => _).symm\n  · simp [aeval_comp]\n  · have : (Polynomial.aeval x) (q.comp (X + C a)) = 0 := by simpa [aeval_comp] using hq\n    have H := minpoly.min A x (qmo.comp_X_add_C _) this\n    rw [degree_eq_nat_degree qmo.ne_zero, degree_eq_nat_degree ((minpoly.monic hx).comp_X_sub_C _).ne_zero,\n      WithBot.coe_le_coe, nat_degree_comp, nat_degree_X_sub_C, mul_one]\n    rwa [degree_eq_nat_degree (minpoly.ne_zero hx), degree_eq_nat_degree (qmo.comp_X_add_C _).ne_zero,\n      WithBot.coe_le_coe, nat_degree_comp, nat_degree_X_add_C, mul_one] at H\n#align add_algebra_map add_algebra_map\n\n",
 "Unique":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Unique /-\n/-- The minimal polynomial of an element `x` is uniquely characterized by its defining property:\nif there is another monic polynomial of minimal degree that has `x` as a root, then this polynomial\nis equal to the minimal polynomial of `x`. See also `minpoly.gcd_unique` which relaxes the\nassumptions on `A` in exchange for stronger assumptions on `B`. -/\ntheorem Unique {p : polynomial A} (pmonic : p.monic) (hp : Polynomial.aeval x p = 0)\n    (pmin : ∀ q : polynomial A, q.monic → Polynomial.aeval x q = 0 → degree p ≤ degree q) : p = minpoly A x :=\n  by\n  have hx : is_integral A x := ⟨p, pmonic, hp⟩\n  symm; apply eq_of_sub_eq_zero\n  by_contra hnz\n  have := degree_le_of_ne_zero A x hnz (by simp [hp])\n  contrapose! this\n  apply degree_sub_lt _ (NeZero hx)\n  · rw [(monic hx).leading_coeff, pmonic.leading_coeff]\n  · exact le_antisymm (min A x pmonic hp) (pmin (minpoly A x) (monic hx) (aeval A x))\n#align unique Unique\n-/\n\n",
 "Prime":
 "#print Prime /-\n/-- A minimal polynomial is prime. -/\ntheorem Prime (hx : is_integral A x) : Prime (minpoly A x) :=\n  by\n  refine' ⟨NeZero hx, not_is_unit A x, _⟩\n  rintro p q ⟨d, h⟩\n  have : Polynomial.aeval x (p * q) = 0 := by simp [h, aeval A x]\n  replace : Polynomial.aeval x p = 0 ∨ Polynomial.aeval x q = 0 := by simpa\n  exact Or.imp (dvd A x) (dvd A x) this\n#align prime Prime\n-/\n\n"}