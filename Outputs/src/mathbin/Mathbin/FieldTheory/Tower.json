{"trans":
 "#print trans /-\ntheorem trans [finite_dimensional F K] [finite_dimensional K A] : finite_dimensional F A :=\n  let b := basis.of_vector_space F K\n  let c := basis.of_vector_space K A\n  of_fintype_basis <| b.smul c\n#align trans trans\n-/\n\n",
 "right":
 "theorem right [hf : finite_dimensional F A] : finite_dimensional K A :=\n  let ⟨⟨b, hb⟩⟩ := hf\n  ⟨⟨b,\n      submodule.restrict_scalars_injective F _ _ <|\n        by\n        rw [submodule.restrict_scalars_top, eq_top_iff, ← hb, submodule.span_le]\n        exact submodule.subset_span⟩⟩\n#align right right\n\n",
 "left":
 "/-- In a tower of field extensions `L / K / F`, if `L / F` is finite, so is `K / F`.\n\n(In fact, it suffices that `L` is a nontrivial ring.)\n\nNote this cannot be an instance as Lean cannot infer `L`.\n-/\ntheorem left (K L : Type _) [Field K] [algebra F K] [Ring L] [nontrivial L] [algebra F L] [algebra K L]\n    [IsScalarTower F K L] [finite_dimensional F L] : finite_dimensional F K :=\n  finite_dimensional.of_injective (is_scalar_tower.to_alg_hom F K L).to_linear_map (RingHom.injective _)\n#align left left\n\n",
 "is_simple_order_of_finrank_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra.is_simple_order_of_finrank_prime (A) [Ring A] [IsDomain A] [algebra F A] (hp : (finrank F A).prime) :\n    IsSimpleOrder (subalgebra F A) :=\n  { to_nontrivial :=\n      ⟨⟨«expr⊥», «expr⊤», fun he => Nat.not_prime_one ((subalgebra.bot_eq_top_iff_finrank_eq_one.1 he).subst hp)⟩⟩\n    eq_bot_or_eq_top := fun K => by\n      haveI := finite_dimensional_of_finrank hp.pos\n      letI := division_ring_of_finite_dimensional F K\n      refine' (hp.eq_one_or_self_of_dvd _ ⟨_, (finrank_mul_finrank F K A).symm⟩).imp _ fun h => _\n      · exact subalgebra.eq_bot_of_finrank_one\n      · exact algebra.to_submodule_eq_top.1 (eq_top_of_finrank_eq <| K.finrank_to_submodule.trans h) }\n#align subalgebra.is_simple_order_of_finrank_prime subalgebra.is_simple_order_of_finrank_prime\n\n",
 "finrank_mul_finrank":
 "/-- Tower law: if `A` is a `K`-algebra and `K` is a field extension of `F` then\n`dim_F(A) = dim_F(K) * dim_K(A)`. -/\ntheorem finrank_mul_finrank [finite_dimensional F K] : finrank F K * finrank K A = finrank F A :=\n  by\n  by_cases hA : finite_dimensional K A\n  · skip\n    let b := basis.of_vector_space F K\n    let c := basis.of_vector_space K A\n    rw [finrank_eq_card_basis b, finrank_eq_card_basis c, finrank_eq_card_basis (b.smul c), fintype.card_prod]\n  · rw [finrank_of_infinite_dimensional hA, mul_zero, finrank_of_infinite_dimensional]\n    exact mt (@right F K A _ _ _ _ _ _ _) hA\n#align finrank_mul_finrank finrank_mul_finrank\n\n",
 "finrank_linear_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- TODO: generalize by removing [finite_dimensional F K]\n-- V = ⊕F,\n-- (V →ₗ[F] K) = ((⊕F) →ₗ[F] K) = (⊕ (F →ₗ[F] K)) = ⊕K\ntheorem finrank_linear_map' (F : Type u) (K : Type v) (V : Type w) [Field F] [Field K] [algebra F K]\n    [finite_dimensional F K] [add_comm_group V] [Module F V] [finite_dimensional F V] :\n    finrank K («expr →ₗ[ ] » V F K) = finrank F V :=\n  mul_right_injective₀ finrank_pos.ne' <|\n    calc\n      finrank F K * finrank K («expr →ₗ[ ] » V F K) = finrank F («expr →ₗ[ ] » V F K) := finrank_mul_finrank _ _ _\n      _ = finrank F V * finrank F K := finrank_linear_map F V K\n      _ = finrank F K * finrank F V := mul_comm _ _\n      \n#align finrank_linear_map' finrank_linear_map'\n\n",
 "finrank_linear_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- TODO: `intermediate_field` version\ntheorem finrank_linear_map (F : Type u) (V : Type v) (W : Type w) [Field F] [add_comm_group V] [Module F V]\n    [add_comm_group W] [Module F W] [finite_dimensional F V] [finite_dimensional F W] :\n    finrank F («expr →ₗ[ ] » V F W) = finrank F V * finrank F W :=\n  by\n  let b := basis.of_vector_space F V\n  let c := basis.of_vector_space F W\n  rw [linear_equiv.finrank_eq (linear_map.to_matrix b c), matrix.finrank_matrix, finrank_eq_card_basis b,\n    finrank_eq_card_basis c, mul_comm]\n#align finrank_linear_map finrank_linear_map\n\n",
 "dim_mul_dim'":
 "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n/-- Tower law: if `A` is a `K`-vector space and `K` is a field extension of `F` then\n`dim_F(A) = dim_F(K) * dim_K(A)`. -/\ntheorem dim_mul_dim' :\n    cardinal.lift.{w} (module.rank F K) * cardinal.lift.{v} (module.rank K A) = cardinal.lift.{v} (module.rank F A) :=\n  by\n  let b := basis.of_vector_space F K\n  let c := basis.of_vector_space K A\n  rw [← (module.rank F K).lift_id, ← b.mk_eq_dim, ← (module.rank K A).lift_id, ← c.mk_eq_dim, ← lift_umax.{w, v}, ←\n    (b.smul c).mk_eq_dim, mk_prod, lift_mul, lift_lift, lift_lift, lift_lift, lift_lift, lift_umax]\n#align dim_mul_dim' dim_mul_dim'\n\n",
 "dim_mul_dim":
 "/-- Tower law: if `A` is a `K`-vector space and `K` is a field extension of `F` then\n`dim_F(A) = dim_F(K) * dim_K(A)`. -/\ntheorem dim_mul_dim (F : Type u) (K A : Type v) [Field F] [Field K] [add_comm_group A] [algebra F K] [Module K A]\n    [Module F A] [IsScalarTower F K A] : module.rank F K * module.rank K A = module.rank F A := by\n  convert dim_mul_dim' F K A <;> rw [lift_id]\n#align dim_mul_dim dim_mul_dim\n\n"}