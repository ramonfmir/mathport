{"trans":
 "#print trans /-\ntheorem trans [FiniteDimensional F K] [FiniteDimensional K A] : FiniteDimensional F A :=\n  Module.Finite.trans K A\n#align trans trans\n-/\n\n",
 "right":
 "theorem right [hf : FiniteDimensional F A] : FiniteDimensional K A :=\n  let ⟨⟨b, hb⟩⟩ := hf\n  ⟨⟨b,\n      Submodule.restrictScalars_injective F _ _ <|\n        by\n        rw [Submodule.restrictScalars_top, eq_top_iff, ← hb, Submodule.span_le]\n        exact Submodule.subset_span⟩⟩\n#align right right\n\n",
 "rank_mul_rank":
 "#print rank_mul_rank /-\n/-- Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$.\n\nThis is a simpler version of `lift_rank_mul_lift_rank` with `K` and `A` in the same universe. -/\ntheorem rank_mul_rank (F : Type u) (K A : Type v) [CommRing F] [Ring K] [AddCommGroup A] [Algebra F K] [Module K A]\n    [Module F A] [IsScalarTower F K A] [StrongRankCondition F] [StrongRankCondition K] [Module.Free F K]\n    [Module.Free K A] : Module.rank F K * Module.rank K A = Module.rank F A := by\n  convert lift_rank_mul_lift_rank F K A <;> rw [lift_id]\n#align rank_mul_rank rank_mul_rank\n-/\n\n",
 "lift_rank_mul_lift_rank":
 "#print lift_rank_mul_lift_rank /-\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n/-- Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$. -/\ntheorem lift_rank_mul_lift_rank :\n    Cardinal.lift.{w} (Module.rank F K) * Cardinal.lift.{v} (Module.rank K A) = Cardinal.lift.{v} (Module.rank F A) :=\n  by\n  obtain ⟨_, b⟩ := module.free.exists_basis F K\n  obtain ⟨_, c⟩ := module.free.exists_basis K A\n  rw [← (Module.rank F K).lift_id, ← b.mk_eq_rank, ← (Module.rank K A).lift_id, ← c.mk_eq_rank, ← lift_umax.{w, v}, ←\n    (b.smul c).mk_eq_rank, mk_prod, lift_mul, lift_lift, lift_lift, lift_lift, lift_lift, lift_umax]\n#align lift_rank_mul_lift_rank lift_rank_mul_lift_rank\n-/\n\n",
 "left":
 "/-- In a tower of field extensions `L / K / F`, if `L / F` is finite, so is `K / F`.\n\n(In fact, it suffices that `L` is a nontrivial ring.)\n\nNote this cannot be an instance as Lean cannot infer `L`.\n-/\ntheorem left (K L : Type _) [Field K] [Algebra F K] [Ring L] [Nontrivial L] [Algebra F L] [Algebra K L]\n    [IsScalarTower F K L] [FiniteDimensional F L] : FiniteDimensional F K :=\n  FiniteDimensional.of_injective (IsScalarTower.toAlgHom F K L).to_linear_map (RingHom.injective _)\n#align left left\n\n",
 "is_simple_order_of_finrank_prime":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem subalgebra.is_simple_order_of_finrank_prime (A) [Ring A] [IsDomain A] [Algebra F A] (hp : (finrank F A).prime) :\n    IsSimpleOrder (Subalgebra F A) :=\n  { to_nontrivial :=\n      ⟨⟨«expr⊥», «expr⊤», fun he => Nat.not_prime_one ((Subalgebra.bot_eq_top_iff_finrank_eq_one.1 he).subst hp)⟩⟩\n    eq_bot_or_eq_top := fun K => by\n      haveI := finite_dimensional_of_finrank hp.pos\n      letI := divisionRingOfFiniteDimensional F K\n      refine' (hp.eq_one_or_self_of_dvd _ ⟨_, (finrank_mul_finrank F K A).symm⟩).imp _ fun h => _\n      · exact Subalgebra.eq_bot_of_finrank_one\n      · exact Algebra.toSubmodule_eq_top.1 (eq_top_of_finrank_eq <| K.finrank_to_submodule.trans h) }\n#align subalgebra.is_simple_order_of_finrank_prime subalgebra.is_simple_order_of_finrank_prime\n\n",
 "finrank_mul_finrank'":
 "#print FiniteDimensional.finrank_mul_finrank' /-\n/-- Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$. -/\ntheorem FiniteDimensional.finrank_mul_finrank' [Nontrivial K] [Module.Finite F K] [Module.Finite K A] :\n    finrank F K * finrank K A = finrank F A :=\n  by\n  letI := nontrivial_of_invariantBasisNumber F\n  let b := Module.Free.chooseBasis F K\n  let c := Module.Free.chooseBasis K A\n  rw [finrank_eq_card_basis b, finrank_eq_card_basis c, finrank_eq_card_basis (b.smul c), Fintype.card_prod]\n#align finite_dimensional.finrank_mul_finrank' FiniteDimensional.finrank_mul_finrank'\n-/\n\n",
 "finrank_mul_finrank":
 "/-- Tower law: if `A` is a `K`-vector space and `K` is a field extension of `F` then\n`dim_F(A) = dim_F(K) * dim_K(A)`.\n\nThis is `finite_dimensional.finrank_mul_finrank'` with one fewer finiteness assumption. -/\ntheorem finrank_mul_finrank [FiniteDimensional F K] : finrank F K * finrank K A = finrank F A :=\n  by\n  by_cases hA : FiniteDimensional K A\n  · skip\n    rw [finrank_mul_finrank']\n  · rw [finrank_of_infinite_dimensional hA, MulZeroClass.mul_zero, finrank_of_infinite_dimensional]\n    exact mt (@right F K A _ _ _ _ _ _ _) hA\n#align finrank_mul_finrank finrank_mul_finrank\n\n",
 "finrank_linear_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₗ[ ] » -/\n-- TODO: `intermediate_field` version \n-- TODO: generalize by removing [finite_dimensional F K]\n-- V = ⊕F,\n-- (V →ₗ[F] K) = ((⊕F) →ₗ[F] K) = (⊕ (F →ₗ[F] K)) = ⊕K\ntheorem finrank_linear_map' (F : Type u) (K : Type v) (V : Type w) [Field F] [Field K] [Algebra F K]\n    [FiniteDimensional F K] [AddCommGroup V] [Module F V] [FiniteDimensional F V] :\n    finrank K («expr →ₗ[ ] » V F K) = finrank F V :=\n  mul_right_injective₀ finrank_pos.ne' <|\n    calc\n      finrank F K * finrank K («expr →ₗ[ ] » V F K) = finrank F («expr →ₗ[ ] » V F K) := finrank_mul_finrank _ _ _\n      _ = finrank F V * finrank F K := (finrank_linearMap F V K)\n      _ = finrank F K * finrank F V := mul_comm _ _\n      \n#align finrank_linear_map' finrank_linear_map'\n\n"}