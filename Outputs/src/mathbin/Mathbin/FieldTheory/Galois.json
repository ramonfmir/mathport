{"transfer_galois":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem alg_equiv.transfer_galois (f : «expr ≃ₐ[ ] » E F E') : is_galois F E ↔ is_galois F E' :=\n  ⟨fun h => is_galois.of_alg_equiv f, fun h => is_galois.of_alg_equiv f.symm⟩\n#align alg_equiv.transfer_galois alg_equiv.transfer_galois\n\n",
 "tower_top_of_is_galois":
 "theorem is_galois.tower_top_of_is_galois [is_galois F E] : is_galois K E :=\n  { to_is_separable := is_separable_tower_top_of_is_separable F K E\n    to_normal := normal.tower_top_of_normal F K E }\n#align is_galois.tower_top_of_is_galois is_galois.tower_top_of_is_galois\n\n",
 "tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Equivalent characterizations of a Galois extension of finite degree-/\ntheorem tfae [FiniteDimensional F E] :\n    TFAE\n      [is_galois F E, intermediate_field.fixed_field («expr⊤» : Subgroup («expr ≃ₐ[ ] » E F E)) = «expr⊥»,\n        Fintype.card («expr ≃ₐ[ ] » E F E) = finrank F E, ∃ p : polynomial F, p.separable ∧ p.is_splitting_field F E] :=\n  by\n  tfae_have 1 → 2\n  · exact fun h => OrderIso.map_bot (@intermediate_field_equiv_subgroup F _ E _ _ _ h).symm\n  tfae_have 1 → 3\n  · intro\n    exact card_aut_eq_finrank F E\n  tfae_have 1 → 4\n  · intro\n    exact is_separable_splitting_field F E\n  tfae_have 2 → 1\n  · exact of_fixed_field_eq_bot F E\n  tfae_have 3 → 1\n  · exact of_card_aut_eq_finrank F E\n  tfae_have 4 → 1\n  · rintro ⟨h, hp1, _⟩\n    exact of_separable_splitting_field hp1\n  tfae_finish\n#align tfae tfae\n\n",
 "splits":
 "theorem splits [is_galois F E] (x : E) : (minpoly F x).splits (algebraMap F E) :=\n  normal.splits' x\n#align splits splits\n\n",
 "separable":
 "theorem separable [is_galois F E] (x : E) : (minpoly F x).separable :=\n  is_separable.separable F x\n#align separable separable\n\n",
 "of_separable_splitting_field_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem of_separable_splitting_field_aux [hFE : FiniteDimensional F E] [sp : p.is_splitting_field F E]\n    (hp : p.separable) (K : Type _) [Field K] [Algebra F K] [Algebra K E] [IsScalarTower F K E] {x : E}\n    (hx : x ∈ (p.map (algebraMap F E)).roots)\n    -- these are both implied by `hFE`, but as they carry data this makes the lemma more general\n    [Fintype («expr →ₐ[ ] » K F E)]\n    [Fintype\n        («expr →ₐ[ ] »\n          ((«expr ⟮ ,⟯» K\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n            F)\n          F E)] :\n    Fintype.card\n        («expr →ₐ[ ] »\n          ((«expr ⟮ ,⟯» K\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n            F)\n          F E) =\n      Fintype.card («expr →ₐ[ ] » K F E) *\n        finrank K\n          («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n  by\n  have h : is_integral K x := is_integral_of_is_scalar_tower (is_integral_of_noetherian (IsNoetherian.iff_fg.2 hFE) x)\n  have h1 : p ≠ 0 := fun hp => by rwa [hp, Polynomial.map_zero, Polynomial.roots_zero] at hx\n  have h2 : minpoly K x ∣ p.map (algebraMap F K) := by\n    apply minpoly.dvd\n    rw [Polynomial.aeval_def, Polynomial.eval₂_map, ← Polynomial.eval_map, ← IsScalarTower.algebraMap_eq]\n    exact (Polynomial.mem_roots (Polynomial.map_ne_zero h1)).mp hx\n  let key_equiv :\n    «expr ≃ »\n      («expr →ₐ[ ] »\n        ((«expr ⟮ ,⟯» K\n              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n          F)\n        F E)\n      (Σf : «expr →ₐ[ ] » K F E,\n        @AlgHom K («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          E _ _ _ _ (RingHom.toAlgebra f)) :=\n    by\n    change\n      «expr ≃ »\n        («expr →ₐ[ ] »\n          («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") F E)\n        (Σf : «expr →ₐ[ ] » K F E, _)\n    exact algHomEquivSigma\n  haveI :\n    ∀ f : «expr →ₐ[ ] » K F E,\n      Fintype\n        (@AlgHom K («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          E _ _ _ _ (RingHom.toAlgebra f)) :=\n    fun f => by\n    apply Fintype.ofInjective (sigma.mk f) fun _ _ H => eq_of_heq (sigma.mk.inj H).2\n    exact Fintype.ofEquiv _ key_equiv\n  rw [Fintype.card_congr key_equiv, Fintype.card_sigma, intermediate_field.adjoin.finrank h]\n  apply Finset.sum_const_nat\n  intro f hf\n  rw [← @intermediate_field.card_alg_hom_adjoin_integral K _ E _ _ x E _ (RingHom.toAlgebra f) h]\n  · apply Fintype.card_congr\n    rfl\n  · exact polynomial.separable.of_dvd ((polynomial.separable_map (algebraMap F K)).mpr hp) h2\n  · refine' Polynomial.splits_of_splits_of_dvd _ (Polynomial.map_ne_zero h1) _ h2\n    rw [Polynomial.splits_map_iff, ← IsScalarTower.algebraMap_eq]\n    exact sp.splits\n#align of_separable_splitting_field_aux of_separable_splitting_field_aux\n\n",
 "of_separable_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_separable_splitting_field [sp : p.is_splitting_field F E] (hp : p.separable) : is_galois F E :=\n  by\n  haveI hFE : FiniteDimensional F E := polynomial.is_splitting_field.finite_dimensional E p\n  letI := Classical.decEq E\n  let s := (p.map (algebraMap F E)).roots.to_finset\n  have adjoin_root : intermediate_field.adjoin F ↑s = «expr⊤» :=\n    by\n    apply intermediate_field.to_subalgebra_injective\n    rw [intermediate_field.top_to_subalgebra, ← top_le_iff, ← sp.adjoin_roots]\n    apply intermediate_field.algebra_adjoin_le_adjoin\n  let P : intermediate_field F E → Prop := fun K => Fintype.card («expr →ₐ[ ] » K F E) = finrank F K\n  suffices P (intermediate_field.adjoin F ↑s) by\n    rw [adjoin_root] at this\n    apply of_card_aut_eq_finrank\n    rw [← Eq.trans this (LinearEquiv.finrank_eq intermediate_field.top_equiv.to_linear_equiv)]\n    exact\n      Fintype.card_congr\n        ((alg_equiv_equiv_alg_hom F E).to_equiv.trans (intermediate_field.top_equiv.symm.arrow_congr AlgEquiv.refl))\n  apply intermediate_field.induction_on_adjoin_finset s P\n  · have key := intermediate_field.card_alg_hom_adjoin_integral F (show is_integral F (0 : E) from is_integral_zero)\n    rw [minpoly.zero, Polynomial.natDegree_X] at key\n    specialize key polynomial.separable_X (Polynomial.splits_X (algebraMap F E))\n    rw [← @Subalgebra.finrank_bot F E _ _ _, ← intermediate_field.bot_to_subalgebra] at key\n    refine' Eq.trans _ key\n    apply Fintype.card_congr\n    rw [intermediate_field.adjoin_zero]\n  intro K x hx hK\n  simp only [P] at *\n  rw [of_separable_splitting_field_aux hp K (multiset.mem_to_finset.mp hx), hK, finrank_mul_finrank]\n  symm\n  refine' LinearEquiv.finrank_eq _\n  rfl\n#align of_separable_splitting_field of_separable_splitting_field\n\n",
 "of_fixed_field_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem of_fixed_field_eq_bot [FiniteDimensional F E]\n    (h : intermediate_field.fixed_field («expr⊤» : Subgroup («expr ≃ₐ[ ] » E F E)) = «expr⊥») : is_galois F E :=\n  by\n  rw [← is_galois_iff_is_galois_bot, ← h]\n  classical exact is_galois.of_fixed_field E («expr⊤» : Subgroup («expr ≃ₐ[ ] » E F E))\n#align of_fixed_field_eq_bot of_fixed_field_eq_bot\n\n",
 "of_card_aut_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem of_card_aut_eq_finrank [FiniteDimensional F E] (h : Fintype.card («expr ≃ₐ[ ] » E F E) = finrank F E) :\n    is_galois F E := by\n  apply of_fixed_field_eq_bot\n  have p : 0 < finrank (intermediate_field.fixed_field («expr⊤» : Subgroup («expr ≃ₐ[ ] » E F E))) E := finrank_pos\n  classical\n    rw [← intermediate_field.finrank_eq_one_iff, ← mul_left_inj' (ne_of_lt p).symm, finrank_mul_finrank, ← h, one_mul,\n      intermediate_field.finrank_fixed_field_eq_card]\n    apply Fintype.card_congr\n    exact\n      { to_fun := fun g => ⟨g, Subgroup.mem_top g⟩\n        inv_fun := coe\n        left_inv := fun g => rfl\n        right_inv := fun _ => by\n          ext\n          rfl }\n#align of_card_aut_eq_finrank of_card_aut_eq_finrank\n\n",
 "of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_galois.of_alg_equiv [h : is_galois F E] (f : «expr ≃ₐ[ ] » E F E') : is_galois F E' :=\n  { to_is_separable := is_separable.of_alg_hom F E f.symm\n    to_normal := normal.of_alg_equiv f }\n#align is_galois.of_alg_equiv is_galois.of_alg_equiv\n\n",
 "le_iff_le":
 "theorem le_iff_le : K ≤ fixed_field H ↔ H ≤ fixing_subgroup K :=\n  ⟨fun h g hg x => h (Subtype.mem x) ⟨g, hg⟩, fun h x hx g => h (Subtype.mem g) ⟨x, hx⟩⟩\n#align le_iff_le le_iff_le\n\n",
 "is_separable_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_separable_splitting_field [FiniteDimensional F E] [is_galois F E] :\n    ∃ p : polynomial F, p.separable ∧ p.is_splitting_field F E :=\n  by\n  cases' field.exists_primitive_element F E with α h1\n  use minpoly F α, separable F α, is_galois.splits F α\n  rw [eq_top_iff, ← intermediate_field.top_to_subalgebra, ← h1]\n  rw [intermediate_field.adjoin_simple_to_subalgebra_of_integral (integral F α)]\n  apply Algebra.adjoin_mono\n  rw [Set.singleton_subset_iff, Finset.mem_coe, Multiset.mem_toFinset, Polynomial.mem_roots]\n  · dsimp only [Polynomial.IsRoot]\n    rw [Polynomial.eval_map, ← Polynomial.aeval_def]\n    exact minpoly.aeval _ _\n  · exact Polynomial.map_ne_zero (minpoly.ne_zero (integral F α))\n#align is_separable_splitting_field is_separable_splitting_field\n\n",
 "is_galois_iff_is_galois_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_galois_iff_is_galois_top : is_galois F («expr⊤» : intermediate_field F E) ↔ is_galois F E :=\n  (intermediate_field.top_equiv : «expr ≃ₐ[ ] » («expr⊤» : intermediate_field F E) F E).transfer_galois\n#align is_galois_iff_is_galois_top is_galois_iff_is_galois_top\n\n",
 "is_galois_iff_is_galois_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- see Note [lower instance priority]\ntheorem is_galois_iff_is_galois_bot : is_galois («expr⊥» : intermediate_field F E) E ↔ is_galois F E :=\n  by\n  constructor\n  · intro h\n    exact is_galois.tower_top_of_is_galois («expr⊥» : intermediate_field F E) F E\n  · intro h\n    infer_instance\n#align is_galois_iff_is_galois_bot is_galois_iff_is_galois_bot\n\n",
 "is_galois_iff":
 "/-\nCopyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning, Patrick Lutz\n-/\ntheorem is_galois_iff : is_galois F E ↔ is_separable F E ∧ normal F E :=\n  ⟨fun h => ⟨h.1, h.2⟩, fun h =>\n    { to_is_separable := h.1\n      to_normal := h.2 }⟩\n#align is_galois_iff is_galois_iff\n\n",
 "integral":
 "-- see Note [lower instance priority]\ntheorem integral [is_galois F E] (x : E) : is_integral F x :=\n  to_normal.is_integral x\n#align integral integral\n\n",
 "fixing_subgroup_fixed_field":
 "theorem fixing_subgroup_fixed_field [FiniteDimensional F E] : fixing_subgroup (fixed_field H) = H :=\n  by\n  have H_le : H ≤ fixingSubgroup (fixed_field H) := (le_iff_le _ _).mp le_rfl\n  classical\n    suffices Fintype.card H = Fintype.card (fixingSubgroup (fixed_field H)) by\n      exact\n        SetLike.coe_injective\n          (Set.eq_of_inclusion_surjective\n              ((Fintype.bijective_iff_injective_and_card (Set.inclusion H_le)).mpr\n                  ⟨Set.inclusion_injective H_le, this⟩).2).symm\n    apply Fintype.card_congr\n    refine' (fixed_points.to_alg_hom_equiv H E).trans _\n    refine' (alg_equiv_equiv_alg_hom (fixed_field H) E).to_equiv.symm.trans _\n    exact (fixing_subgroup_equiv (fixed_field H)).to_equiv.symm\n#align fixing_subgroup_fixed_field fixing_subgroup_fixed_field\n\n",
 "fixed_field_fixing_subgroup":
 "theorem fixed_field_fixing_subgroup [FiniteDimensional F E] [h : is_galois F E] :\n    intermediate_field.fixed_field (intermediate_field.fixing_subgroup K) = K :=\n  by\n  have K_le : K ≤ intermediate_field.fixed_field (intermediate_field.fixing_subgroup K) :=\n    (intermediate_field.le_iff_le _ _).mpr le_rfl\n  suffices finrank K E = finrank (intermediate_field.fixed_field (intermediate_field.fixing_subgroup K)) E by\n    exact (intermediate_field.eq_of_le_of_finrank_eq' K_le this).symm\n  classical\n    rw [intermediate_field.finrank_fixed_field_eq_card,\n      Fintype.card_congr (intermediate_field.fixing_subgroup_equiv K).to_equiv]\n    exact (card_aut_eq_finrank K E).symm\n#align fixed_field_fixing_subgroup fixed_field_fixing_subgroup\n\n",
 "finrank_fixed_field_eq_card":
 "theorem finrank_fixed_field_eq_card [FiniteDimensional F E] [DecidablePred (· ∈ H)] :\n    finrank (fixed_field H) E = Fintype.card H :=\n  fixed_points.finrank_eq_card H E\n#align finrank_fixed_field_eq_card finrank_fixed_field_eq_card\n\n",
 "card_fixing_subgroup_eq_finrank":
 "theorem card_fixing_subgroup_eq_finrank [DecidablePred (· ∈ intermediate_field.fixing_subgroup K)]\n    [FiniteDimensional F E] [is_galois F E] : Fintype.card (intermediate_field.fixing_subgroup K) = finrank K E := by\n  conv =>\n    rhs\n    rw [← fixed_field_fixing_subgroup K, intermediate_field.finrank_fixed_field_eq_card]\n#align card_fixing_subgroup_eq_finrank card_fixing_subgroup_eq_finrank\n\n",
 "card_aut_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem card_aut_eq_finrank [FiniteDimensional F E] [is_galois F E] :\n    Fintype.card («expr ≃ₐ[ ] » E F E) = finrank F E :=\n  by\n  cases' field.exists_primitive_element F E with α hα\n  let iso :\n    «expr ≃ₐ[ ] » («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n      F E :=\n    { to_fun := fun e => e.val\n      inv_fun := fun e =>\n        ⟨e, by\n          rw [hα]\n          exact intermediate_field.mem_top⟩\n      left_inv := fun _ => by\n        ext\n        rfl\n      right_inv := fun _ => rfl\n      map_mul' := fun _ _ => rfl\n      map_add' := fun _ _ => rfl\n      commutes' := fun _ => rfl }\n  have H : is_integral F α := is_galois.integral F α\n  have h_sep : (minpoly F α).separable := is_galois.separable F α\n  have h_splits : (minpoly F α).splits (algebraMap F E) := is_galois.splits F α\n  replace h_splits :\n    Polynomial.Splits\n      (algebraMap F\n        («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\"))\n      (minpoly F α)\n  · have p :\n      iso.symm.to_alg_hom.to_ring_hom.comp (algebraMap F E) =\n        algebraMap F\n          («expr↥ »\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")) :=\n      by\n      ext\n      simp\n    simpa [p] using Polynomial.splits_comp_of_splits (algebraMap F E) iso.symm.to_alg_hom.to_ring_hom h_splits\n  rw [← LinearEquiv.finrank_eq iso.to_linear_equiv]\n  rw [← intermediate_field.adjoin_simple.card_aut_eq_finrank F E H h_sep h_splits]\n  apply Fintype.card_congr\n  apply equiv.mk (fun ϕ => iso.trans (trans ϕ iso.symm)) fun ϕ => iso.symm.trans (trans ϕ iso)\n  · intro ϕ\n    ext1\n    simp only [trans_apply, apply_symm_apply]\n  · intro ϕ\n    ext1\n    simp only [trans_apply, symm_apply_apply]\n#align card_aut_eq_finrank card_aut_eq_finrank\n\n"}