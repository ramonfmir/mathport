{"transfer_galois":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem alg_equiv.transfer_galois (f : «expr ≃ₐ[ ] » E F E') : is_galois F E ↔ is_galois F E' :=\n  ⟨fun h => is_galois.of_alg_equiv f, fun h => is_galois.of_alg_equiv f.symm⟩\n#align alg_equiv.transfer_galois alg_equiv.transfer_galois\n\n",
 "tower_top_of_is_galois":
 "theorem is_galois.tower_top_of_is_galois [is_galois F E] : is_galois K E :=\n  { to_is_separable := is_separable_tower_top_of_is_separable F K E\n    to_normal := normal.tower_top_of_normal F K E }\n#align is_galois.tower_top_of_is_galois is_galois.tower_top_of_is_galois\n\n",
 "tfae":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- failed to parenthesize: parenthesize: uncaught backtrack exception\n[PrettyPrinter.parenthesize.input] (Command.declaration\n     (Command.declModifiers\n      [(Command.docComment \"/--\" \"Equivalent characterizations of a Galois extension of finite degree-/\")]\n      []\n      []\n      []\n      []\n      [])\n     (Command.theorem\n      \"theorem\"\n      (Command.declId `tfae [])\n      (Command.declSig\n       [(Term.instBinder \"[\" [] (Term.app `finite_dimensional [`F `E]) \"]\")]\n       (Term.typeSpec\n        \":\"\n        (Term.app\n         `TFAE\n         [(«term[_]»\n           \"[\"\n           [(Term.app `is_galois [`F `E])\n            \",\"\n            («term_=_»\n             (Term.app\n              `intermediate_field.fixed_field\n              [(Term.typeAscription\n                \"(\"\n                (Term.app `«expr⊤» [])\n                \":\"\n                [(Term.app `subgroup [(Term.app `«expr ≃ₐ[ ] » [`E `F `E])])]\n                \")\")])\n             \"=\"\n             (Term.app `«expr⊥» []))\n            \",\"\n            («term_=_» (Term.app `fintype.card [(Term.app `«expr ≃ₐ[ ] » [`E `F `E])]) \"=\" (Term.app `finrank [`F `E]))\n            \",\"\n            («term∃_,_»\n             \"∃\"\n             (Lean.explicitBinders\n              (Lean.unbracketedExplicitBinders [(Lean.binderIdent `p)] [\":\" (Term.app `polynomial [`F])]))\n             \",\"\n             («term_∧_» (Term.proj `p \".\" `separable) \"∧\" (Term.app (Term.proj `p \".\" `is_splitting_field) [`F `E])))]\n           \"]\")])))\n      (Command.declValSimple\n       \":=\"\n       (Term.byTactic\n        \"by\"\n        (Tactic.tacticSeq\n         (Tactic.tacticSeq1Indented\n          [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact\n              \"exact\"\n              (Term.fun\n               \"fun\"\n               (Term.basicFun\n                [`h]\n                []\n                \"=>\"\n                (Term.app\n                 `OrderIso.map_bot\n                 [(Term.proj\n                   (Term.app\n                    (Term.explicit \"@\" `intermediate_field_equiv_subgroup)\n                    [`F (Term.hole \"_\") `E (Term.hole \"_\") (Term.hole \"_\") (Term.hole \"_\") `h])\n                   \".\"\n                   `symm)]))))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" []) [] (Tactic.exact \"exact\" (Term.app `card_aut_eq_finrank [`F `E]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.intro \"intro\" []) [] (Tactic.exact \"exact\" (Term.app `is_separable_splitting_field [`F `E]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `of_fixed_field_eq_bot [`F `E]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Tactic.exact \"exact\" (Term.app `of_card_aut_eq_finrank [`F `E]))])\n           []\n           (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n           []\n           (tactic__\n            (cdotTk (patternIgnore (token.«· » \"·\")))\n            [(Std.Tactic.rintro\n              \"rintro\"\n              [(Std.Tactic.RCases.rintroPat.one\n                (Std.Tactic.RCases.rcasesPat.tuple\n                 \"⟨\"\n                 [(Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp1)])\n                   [])\n                  \",\"\n                  (Std.Tactic.RCases.rcasesPatLo\n                   (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                   [])]\n                 \"⟩\"))]\n              [])\n             []\n             (Tactic.exact \"exact\" (Term.app `of_separable_splitting_field [`hp1]))])\n           []\n           (Tactic.tfaeFinish \"tfae_finish\")])))\n       [])\n      []\n      []))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.abbrev'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.def'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.byTactic\n       \"by\"\n       (Tactic.tacticSeq\n        (Tactic.tacticSeq1Indented\n         [(Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"2\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact\n             \"exact\"\n             (Term.fun\n              \"fun\"\n              (Term.basicFun\n               [`h]\n               []\n               \"=>\"\n               (Term.app\n                `OrderIso.map_bot\n                [(Term.proj\n                  (Term.app\n                   (Term.explicit \"@\" `intermediate_field_equiv_subgroup)\n                   [`F (Term.hole \"_\") `E (Term.hole \"_\") (Term.hole \"_\") (Term.hole \"_\") `h])\n                  \".\"\n                  `symm)]))))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"3\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" []) [] (Tactic.exact \"exact\" (Term.app `card_aut_eq_finrank [`F `E]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"1\") \"→\" (num \"4\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.intro \"intro\" []) [] (Tactic.exact \"exact\" (Term.app `is_separable_splitting_field [`F `E]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"2\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `of_fixed_field_eq_bot [`F `E]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"3\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Tactic.exact \"exact\" (Term.app `of_card_aut_eq_finrank [`F `E]))])\n          []\n          (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n          []\n          (tactic__\n           (cdotTk (patternIgnore (token.«· » \"·\")))\n           [(Std.Tactic.rintro\n             \"rintro\"\n             [(Std.Tactic.RCases.rintroPat.one\n               (Std.Tactic.RCases.rcasesPat.tuple\n                \"⟨\"\n                [(Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp1)])\n                  [])\n                 \",\"\n                 (Std.Tactic.RCases.rcasesPatLo\n                  (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n                  [])]\n                \"⟩\"))]\n             [])\n            []\n            (Tactic.exact \"exact\" (Term.app `of_separable_splitting_field [`hp1]))])\n          []\n          (Tactic.tfaeFinish \"tfae_finish\")])))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Tactic.tacticSeq1Indented', expected 'Lean.Parser.Tactic.tacticSeqBracketed'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeFinish \"tfae_finish\")\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1024\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (tactic__\n       (cdotTk (patternIgnore (token.«· » \"·\")))\n       [(Std.Tactic.rintro\n         \"rintro\"\n         [(Std.Tactic.RCases.rintroPat.one\n           (Std.Tactic.RCases.rcasesPat.tuple\n            \"⟨\"\n            [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)]) [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp1)])\n              [])\n             \",\"\n             (Std.Tactic.RCases.rcasesPatLo\n              (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n              [])]\n            \"⟩\"))]\n         [])\n        []\n        (Tactic.exact \"exact\" (Term.app `of_separable_splitting_field [`hp1]))])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.exact \"exact\" (Term.app `of_separable_splitting_field [`hp1]))\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Term.app `of_separable_splitting_field [`hp1])\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.namedArgument'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'ident', expected 'Lean.Parser.Term.ellipsis'\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      `hp1\n[PrettyPrinter.parenthesize] ...precedences are 1023 >? 1024, (none, [anonymous]) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] parenthesizing (cont := (some 1022, term))\n      `of_separable_splitting_field\n[PrettyPrinter.parenthesize] ...precedences are 1024 >? 1024, (none, [anonymous]) <=? (some 1022, term)\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022, (some 1023, term) <=? (none, [anonymous])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Std.Tactic.rintro\n       \"rintro\"\n       [(Std.Tactic.RCases.rintroPat.one\n         (Std.Tactic.RCases.rcasesPat.tuple\n          \"⟨\"\n          [(Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `h)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.one `hp1)]) [])\n           \",\"\n           (Std.Tactic.RCases.rcasesPatLo\n            (Std.Tactic.RCases.rcasesPatMed [(Std.Tactic.RCases.rcasesPat.ignore \"_\")])\n            [])]\n          \"⟩\"))]\n       [])\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] ...precedences are 0 >? 1022\n[PrettyPrinter.parenthesize] parenthesizing (cont := (none, [anonymous]))\n      (Tactic.tfaeHave \"tfae_have\" [] (num \"4\") \"→\" (num \"1\"))\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« → »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ↔ »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind '«→»', expected 'token.« ← »'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.declValEqns'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.declValSimple', expected 'Lean.Parser.Command.whereStructInst'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.opaque'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.instance'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.axiom'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.example'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.inductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.classInductive'\n[PrettyPrinter.parenthesize.backtrack] unexpected node kind 'Lean.Parser.Command.theorem', expected 'Lean.Parser.Command.structure'-/-- failed to format: format: uncaught backtrack exception\n/-- Equivalent characterizations of a Galois extension of finite degree-/\n  theorem\n    tfae\n    [ finite_dimensional F E ]\n      :\n        TFAE\n          [\n            is_galois F E\n              ,\n              intermediate_field.fixed_field ( «expr⊤» : subgroup «expr ≃ₐ[ ] » E F E ) = «expr⊥»\n              ,\n              fintype.card «expr ≃ₐ[ ] » E F E = finrank F E\n              ,\n              ∃ p : polynomial F , p . separable ∧ p . is_splitting_field F E\n            ]\n    :=\n      by\n        tfae_have 1 → 2\n          · exact fun h => OrderIso.map_bot @ intermediate_field_equiv_subgroup F _ E _ _ _ h . symm\n          tfae_have 1 → 3\n          · intro exact card_aut_eq_finrank F E\n          tfae_have 1 → 4\n          · intro exact is_separable_splitting_field F E\n          tfae_have 2 → 1\n          · exact of_fixed_field_eq_bot F E\n          tfae_have 3 → 1\n          · exact of_card_aut_eq_finrank F E\n          tfae_have 4 → 1\n          · rintro ⟨ h , hp1 , _ ⟩ exact of_separable_splitting_field hp1\n          tfae_finish\n#align tfae tfae\n\n",
 "splits":
 "theorem splits [is_galois F E] (x : E) : (minpoly F x).splits (algebra_map F E) :=\n  normal.splits' x\n#align splits splits\n\n",
 "separable":
 "theorem separable [is_galois F E] (x : E) : (minpoly F x).separable :=\n  is_separable.separable F x\n#align separable separable\n\n",
 "of_separable_splitting_field_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem of_separable_splitting_field_aux [hFE : finite_dimensional F E] [sp : p.is_splitting_field F E]\n    (hp : p.separable) (K : Type _) [Field K] [algebra F K] [algebra K E] [IsScalarTower F K E] {x : E}\n    (hx : x ∈ (p.map (algebra_map F E)).roots)\n    -- these are both implied by `hFE`, but as they carry data this makes the lemma more general\n    [fintype («expr →ₐ[ ] » K F E)]\n    [fintype\n        («expr →ₐ[ ] »\n          ((«expr ⟮ ,⟯» K\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n            F)\n          F E)] :\n    fintype.card\n        («expr →ₐ[ ] »\n          ((«expr ⟮ ,⟯» K\n                \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n            F)\n          F E) =\n      fintype.card («expr →ₐ[ ] » K F E) *\n        finrank K\n          («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n  by\n  have h : is_integral K x := is_integral_of_is_scalar_tower (is_integral_of_noetherian (is_noetherian.iff_fg.2 hFE) x)\n  have h1 : p ≠ 0 := fun hp => by rwa [hp, polynomial.map_zero, polynomial.roots_zero] at hx\n  have h2 : minpoly K x ∣ p.map (algebra_map F K) :=\n    by\n    apply minpoly.dvd\n    rw [polynomial.aeval_def, polynomial.eval₂_map, ← polynomial.eval_map, ← is_scalar_tower.algebra_map_eq]\n    exact (polynomial.mem_roots (polynomial.map_ne_zero h1)).mp hx\n  let key_equiv :\n    «expr ≃ »\n      («expr →ₐ[ ] »\n        ((«expr ⟮ ,⟯» K\n              \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n          F)\n        F E)\n      (Σf : «expr →ₐ[ ] » K F E,\n        @alg_hom K («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          E _ _ _ _ (ring_hom.to_algebra f)) :=\n    by\n    change\n      «expr ≃ »\n        («expr →ₐ[ ] »\n          («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") F E)\n        (Σf : «expr →ₐ[ ] » K F E, _)\n    exact alg_hom_equiv_sigma\n  haveI :\n    ∀ f : «expr →ₐ[ ] » K F E,\n      fintype\n        (@alg_hom K\n          («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") E _ _ _\n          _ (ring_hom.to_algebra f)) :=\n    fun f => by\n    apply fintype.of_injective (sigma.mk f) fun _ _ H => eq_of_heq (sigma.mk.inj H).2\n    exact fintype.of_equiv _ key_equiv\n  rw [fintype.card_congr key_equiv, fintype.card_sigma, intermediate_field.adjoin.finrank h]\n  apply finset.sum_const_nat\n  intro f hf\n  rw [← @intermediate_field.card_alg_hom_adjoin_integral K _ E _ _ x E _ (ring_hom.to_algebra f) h]\n  · apply fintype.card_congr\n    rfl\n  · exact polynomial.separable.of_dvd ((polynomial.separable_map (algebra_map F K)).mpr hp) h2\n  · refine' polynomial.splits_of_splits_of_dvd _ (polynomial.map_ne_zero h1) _ h2\n    rw [polynomial.splits_map_iff, ← is_scalar_tower.algebra_map_eq]\n    exact sp.splits\n#align of_separable_splitting_field_aux of_separable_splitting_field_aux\n\n",
 "of_separable_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_separable_splitting_field [sp : p.is_splitting_field F E] (hp : p.separable) : is_galois F E :=\n  by\n  haveI hFE : finite_dimensional F E := polynomial.is_splitting_field.finite_dimensional E p\n  letI := classical.dec_eq E\n  let s := (p.map (algebra_map F E)).roots.to_finset\n  have adjoin_root : intermediate_field.adjoin F ↑s = «expr⊤» :=\n    by\n    apply intermediate_field.to_subalgebra_injective\n    rw [intermediate_field.top_to_subalgebra, ← top_le_iff, ← sp.adjoin_roots]\n    apply intermediate_field.algebra_adjoin_le_adjoin\n  let P : intermediate_field F E → Prop := fun K => fintype.card («expr →ₐ[ ] » K F E) = finrank F K\n  suffices P (intermediate_field.adjoin F ↑s) by\n    rw [adjoin_root] at this\n    apply of_card_aut_eq_finrank\n    rw [← eq.trans this (linear_equiv.finrank_eq intermediate_field.top_equiv.to_linear_equiv)]\n    exact\n      fintype.card_congr\n        ((alg_equiv_equiv_alg_hom F E).to_equiv.trans (intermediate_field.top_equiv.symm.arrow_congr alg_equiv.refl))\n  apply intermediate_field.induction_on_adjoin_finset s P\n  · have key := intermediate_field.card_alg_hom_adjoin_integral F (show is_integral F (0 : E) from is_integral_zero)\n    rw [minpoly.zero, polynomial.nat_degree_X] at key\n    specialize key polynomial.separable_X (polynomial.splits_X (algebra_map F E))\n    rw [← @subalgebra.finrank_bot F E _ _ _, ← intermediate_field.bot_to_subalgebra] at key\n    refine' eq.trans _ key\n    apply fintype.card_congr\n    rw [intermediate_field.adjoin_zero]\n  intro K x hx hK\n  simp only [P] at *\n  rw [of_separable_splitting_field_aux hp K (multiset.mem_to_finset.mp hx), hK, finrank_mul_finrank]\n  symm\n  refine' linear_equiv.finrank_eq _\n  rfl\n#align of_separable_splitting_field of_separable_splitting_field\n\n",
 "of_fixed_field_eq_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem of_fixed_field_eq_bot [finite_dimensional F E]\n    (h : intermediate_field.fixed_field («expr⊤» : subgroup («expr ≃ₐ[ ] » E F E)) = «expr⊥») : is_galois F E :=\n  by\n  rw [← is_galois_iff_is_galois_bot, ← h]\n  classical exact is_galois.of_fixed_field E («expr⊤» : subgroup («expr ≃ₐ[ ] » E F E))\n#align of_fixed_field_eq_bot of_fixed_field_eq_bot\n\n",
 "of_card_aut_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem of_card_aut_eq_finrank [finite_dimensional F E] (h : fintype.card («expr ≃ₐ[ ] » E F E) = finrank F E) :\n    is_galois F E := by\n  apply of_fixed_field_eq_bot\n  have p : 0 < finrank (intermediate_field.fixed_field («expr⊤» : subgroup («expr ≃ₐ[ ] » E F E))) E := finrank_pos\n  classical\n    rw [← intermediate_field.finrank_eq_one_iff, ← mul_left_inj' (ne_of_lt p).symm, finrank_mul_finrank, ← h, one_mul,\n      intermediate_field.finrank_fixed_field_eq_card]\n    apply fintype.card_congr\n    exact\n      { to_fun := fun g => ⟨g, subgroup.mem_top g⟩\n        inv_fun := coe\n        left_inv := fun g => rfl\n        right_inv := fun _ => by\n          ext\n          rfl }\n#align of_card_aut_eq_finrank of_card_aut_eq_finrank\n\n",
 "of_alg_equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem is_galois.of_alg_equiv [h : is_galois F E] (f : «expr ≃ₐ[ ] » E F E') : is_galois F E' :=\n  { to_is_separable := is_separable.of_alg_hom F E f.symm\n    to_normal := normal.of_alg_equiv f }\n#align is_galois.of_alg_equiv is_galois.of_alg_equiv\n\n",
 "le_iff_le":
 "theorem le_iff_le : K ≤ fixed_field H ↔ H ≤ fixing_subgroup K :=\n  ⟨fun h g hg x => h (Subtype.mem x) ⟨g, hg⟩, fun h x hx g => h (Subtype.mem g) ⟨x, hx⟩⟩\n#align le_iff_le le_iff_le\n\n",
 "is_separable_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_separable_splitting_field [finite_dimensional F E] [is_galois F E] :\n    ∃ p : polynomial F, p.separable ∧ p.is_splitting_field F E :=\n  by\n  cases' field.exists_primitive_element F E with α h1\n  use minpoly F α, separable F α, is_galois.splits F α\n  rw [eq_top_iff, ← intermediate_field.top_to_subalgebra, ← h1]\n  rw [intermediate_field.adjoin_simple_to_subalgebra_of_integral (integral F α)]\n  apply algebra.adjoin_mono\n  rw [Set.singleton_subset_iff, Finset.mem_coe, Multiset.mem_toFinset, polynomial.mem_roots]\n  · dsimp only [polynomial.is_root]\n    rw [polynomial.eval_map, ← polynomial.aeval_def]\n    exact minpoly.aeval _ _\n  · exact polynomial.map_ne_zero (minpoly.ne_zero (integral F α))\n#align is_separable_splitting_field is_separable_splitting_field\n\n",
 "is_galois_iff_is_galois_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem is_galois_iff_is_galois_top : is_galois F («expr⊤» : intermediate_field F E) ↔ is_galois F E :=\n  (intermediate_field.top_equiv : «expr ≃ₐ[ ] » («expr⊤» : intermediate_field F E) F E).transfer_galois\n#align is_galois_iff_is_galois_top is_galois_iff_is_galois_top\n\n",
 "is_galois_iff_is_galois_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n-- see Note [lower instance priority]\ntheorem is_galois_iff_is_galois_bot : is_galois («expr⊥» : intermediate_field F E) E ↔ is_galois F E :=\n  by\n  constructor\n  · intro h\n    exact is_galois.tower_top_of_is_galois («expr⊥» : intermediate_field F E) F E\n  · intro h\n    infer_instance\n#align is_galois_iff_is_galois_bot is_galois_iff_is_galois_bot\n\n",
 "is_galois_iff":
 "/-\nCopyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning, Patrick Lutz\n-/\ntheorem is_galois_iff : is_galois F E ↔ is_separable F E ∧ normal F E :=\n  ⟨fun h => ⟨h.1, h.2⟩, fun h =>\n    { to_is_separable := h.1\n      to_normal := h.2 }⟩\n#align is_galois_iff is_galois_iff\n\n",
 "integral":
 "-- see Note [lower instance priority]\ntheorem integral [is_galois F E] (x : E) : is_integral F x :=\n  to_normal.is_integral x\n#align integral integral\n\n",
 "fixing_subgroup_fixed_field":
 "theorem fixing_subgroup_fixed_field [finite_dimensional F E] : fixing_subgroup (fixed_field H) = H :=\n  by\n  have H_le : H ≤ fixing_subgroup (fixed_field H) := (le_iff_le _ _).mp le_rfl\n  classical\n    suffices fintype.card H = fintype.card (fixing_subgroup (fixed_field H)) by\n      exact\n        SetLike.coe_injective\n          (Set.eq_of_inclusion_surjective\n              ((fintype.bijective_iff_injective_and_card (Set.inclusion H_le)).mpr\n                  ⟨Set.inclusion_injective H_le, this⟩).2).symm\n    apply fintype.card_congr\n    refine' (fixed_points.to_alg_hom_equiv H E).trans _\n    refine' (alg_equiv_equiv_alg_hom (fixed_field H) E).to_equiv.symm.trans _\n    exact (fixing_subgroup_equiv (fixed_field H)).to_equiv.symm\n#align fixing_subgroup_fixed_field fixing_subgroup_fixed_field\n\n",
 "fixed_field_fixing_subgroup":
 "theorem fixed_field_fixing_subgroup [finite_dimensional F E] [h : is_galois F E] :\n    intermediate_field.fixed_field (intermediate_field.fixing_subgroup K) = K :=\n  by\n  have K_le : K ≤ intermediate_field.fixed_field (intermediate_field.fixing_subgroup K) :=\n    (intermediate_field.le_iff_le _ _).mpr le_rfl\n  suffices finrank K E = finrank (intermediate_field.fixed_field (intermediate_field.fixing_subgroup K)) E by\n    exact (intermediate_field.eq_of_le_of_finrank_eq' K_le this).symm\n  classical\n    rw [intermediate_field.finrank_fixed_field_eq_card,\n      fintype.card_congr (intermediate_field.fixing_subgroup_equiv K).to_equiv]\n    exact (card_aut_eq_finrank K E).symm\n#align fixed_field_fixing_subgroup fixed_field_fixing_subgroup\n\n",
 "finrank_fixed_field_eq_card":
 "theorem finrank_fixed_field_eq_card [finite_dimensional F E] [decidable_pred (· ∈ H)] :\n    finrank (fixed_field H) E = fintype.card H :=\n  fixed_points.finrank_eq_card H E\n#align finrank_fixed_field_eq_card finrank_fixed_field_eq_card\n\n",
 "card_fixing_subgroup_eq_finrank":
 "theorem card_fixing_subgroup_eq_finrank [decidable_pred (· ∈ intermediate_field.fixing_subgroup K)]\n    [finite_dimensional F E] [is_galois F E] : fintype.card (intermediate_field.fixing_subgroup K) = finrank K E := by\n  conv =>\n    rhs\n    rw [← fixed_field_fixing_subgroup K, intermediate_field.finrank_fixed_field_eq_card]\n#align card_fixing_subgroup_eq_finrank card_fixing_subgroup_eq_finrank\n\n",
 "card_aut_eq_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem card_aut_eq_finrank [finite_dimensional F E] [is_galois F E] :\n    fintype.card («expr ≃ₐ[ ] » E F E) = finrank F E :=\n  by\n  cases' field.exists_primitive_element F E with α hα\n  let iso :\n    «expr ≃ₐ[ ] » («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n      F E :=\n    { to_fun := fun e => e.val\n      inv_fun := fun e =>\n        ⟨e, by\n          rw [hα]\n          exact intermediate_field.mem_top⟩\n      left_inv := fun _ => by\n        ext\n        rfl\n      right_inv := fun _ => rfl\n      map_mul' := fun _ _ => rfl\n      map_add' := fun _ _ => rfl\n      commutes' := fun _ => rfl }\n  have H : is_integral F α := is_galois.integral F α\n  have h_sep : (minpoly F α).separable := is_galois.separable F α\n  have h_splits : (minpoly F α).splits (algebra_map F E) := is_galois.splits F α\n  replace h_splits :\n    polynomial.splits\n      (algebra_map F\n        («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\"))\n      (minpoly F α)\n  · have p :\n      iso.symm.to_alg_hom.to_ring_hom.comp (algebra_map F E) =\n        algebra_map F\n          («expr↥ »\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")) :=\n      by\n      ext\n      simp\n    simpa [p] using polynomial.splits_comp_of_splits (algebra_map F E) iso.symm.to_alg_hom.to_ring_hom h_splits\n  rw [← linear_equiv.finrank_eq iso.to_linear_equiv]\n  rw [← intermediate_field.adjoin_simple.card_aut_eq_finrank F E H h_sep h_splits]\n  apply fintype.card_congr\n  apply equiv.mk (fun ϕ => iso.trans (trans ϕ iso.symm)) fun ϕ => iso.symm.trans (trans ϕ iso)\n  · intro ϕ\n    ext1\n    simp only [trans_apply, apply_symm_apply]\n  · intro ϕ\n    ext1\n    simp only [trans_apply, symm_apply_apply]\n#align card_aut_eq_finrank card_aut_eq_finrank\n\n"}