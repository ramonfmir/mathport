{"splits_X_pow_sub_one_of_X_pow_sub_C":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem splits_X_pow_sub_one_of_X_pow_sub_C {F : Type _} [Field F] {E : Type _} [Field E] (i : «expr →+* » F E) (n : ℕ)\n    {a : F} (ha : a ≠ 0) (h : (X ^ n - C a).splits i) : (X ^ n - 1).splits i :=\n  by\n  have ha' : i a ≠ 0 := mt ((injective_iff_map_eq_zero i).mp i.injective a) ha\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, sub_self]\n    exact splits_zero i\n  have hn' : 0 < n := pos_iff_ne_zero.mpr hn\n  have hn'' : (X ^ n - C a).degree ≠ 0 := ne_of_eq_of_ne (degree_X_pow_sub_C hn' a) (mt with_bot.coe_eq_coe.mp hn)\n  obtain ⟨b, hb⟩ := exists_root_of_splits i h hn''\n  rw [eval₂_sub, eval₂_X_pow, eval₂_C, sub_eq_zero] at hb\n  have hb' : b ≠ 0 := by\n    intro hb'\n    rw [hb', zero_pow hn'] at hb\n    exact ha' hb.symm\n  let s := ((X ^ n - C a).map i).roots\n  have hs : _ = _ * (s.map _).prod := eq_prod_roots_of_splits h\n  rw [leading_coeff_X_pow_sub_C hn', RingHom.map_one, C_1, one_mul] at hs\n  have hs' : s.card = n := (nat_degree_eq_card_roots h).symm.trans nat_degree_X_pow_sub_C\n  apply @splits_of_exists_multiset F E _ _ i (X ^ n - 1) (s.map fun c : E => c / b)\n  rw [leading_coeff_X_pow_sub_one hn', RingHom.map_one, C_1, one_mul, Multiset.map_map]\n  have C_mul_C : C (i a⁻¹) * C (i a) = 1 := by rw [← C_mul, ← i.map_mul, inv_mul_cancel ha, i.map_one, C_1]\n  have key1 : (X ^ n - 1).map i = C (i a⁻¹) * ((X ^ n - C a).map i).comp (C b * X) := by\n    rw [Polynomial.map_sub, Polynomial.map_sub, Polynomial.map_pow, map_X, map_C, Polynomial.map_one, sub_comp,\n      pow_comp, X_comp, C_comp, mul_pow, ← C_pow, hb, mul_sub, ← mul_assoc, C_mul_C, one_mul]\n  have key2 :\n    ((fun q : polynomial E => q.comp (C b * X)) ∘ fun c : E => X - C c) = fun c : E => C b * (X - C (c / b)) :=\n    by\n    ext1 c\n    change (X - C c).comp (C b * X) = C b * (X - C (c / b))\n    rw [sub_comp, X_comp, C_comp, mul_sub, ← C_mul, mul_div_cancel' c hb']\n  rw [key1, hs, multiset_prod_comp, Multiset.map_map, key2, Multiset.prod_map_mul, Multiset.map_const,\n    Multiset.prod_replicate, hs', ← C_pow, hb, ← mul_assoc, C_mul_C, one_mul]\n  all_goals exact field.to_nontrivial F\n#align splits_X_pow_sub_one_of_X_pow_sub_C splits_X_pow_sub_one_of_X_pow_sub_C\n\n",
 "is_solvable'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- **Abel-Ruffini Theorem** (one direction): An irreducible polynomial with an\n`is_solvable_by_rad` root has solvable Galois group -/\ntheorem is_solvable' {α : E} {q : polynomial F} (q_irred : Irreducible q) (q_aeval : aeval α q = 0)\n    (hα : is_solvable_by_rad F α) : IsSolvable q.gal :=\n  by\n  have : _root_.is_solvable (q * C q.leading_coeff⁻¹).gal :=\n    by\n    rw [minpoly.eq_of_irreducible q_irred q_aeval, ←\n      show minpoly F (⟨α, hα⟩ : solvable_by_rad F E) = minpoly F α from\n        minpoly.eq_of_algebra_map_eq (RingHom.injective _) (is_integral ⟨α, hα⟩) rfl]\n    exact IsSolvable ⟨α, hα⟩\n  refine' solvable_of_surjective (gal.restrict_dvd_surjective ⟨C q.leading_coeff⁻¹, rfl⟩ _)\n  rw [mul_ne_zero_iff, ne, ne, C_eq_zero, inv_eq_zero]\n  exact ⟨q_irred.ne_zero, leading_coeff_ne_zero.mpr q_irred.ne_zero⟩\n#align is_solvable' is_solvable'\n\n",
 "is_integral":
 "theorem is_integral (α : solvable_by_rad F E) : is_integral F α :=\n  by\n  revert α\n  apply solvable_by_rad.induction\n  · exact fun _ => is_integral_algebra_map\n  · exact fun _ _ => is_integral_add\n  · exact fun _ => is_integral_neg\n  · exact fun _ _ => is_integral_mul\n  ·\n    exact fun α hα =>\n      subalgebra.inv_mem_of_algebraic (integral_closure F (solvable_by_rad F E))\n        (show is_algebraic F ↑(⟨α, hα⟩ : integral_closure F (solvable_by_rad F E)) from\n          is_algebraic_iff_is_integral.mpr hα)\n  · intro α n hn hα\n    obtain ⟨p, h1, h2⟩ := is_algebraic_iff_is_integral.mpr hα\n    refine'\n      is_algebraic_iff_is_integral.mp\n        ⟨p.comp (X ^ n), ⟨fun h => h1 (leading_coeff_eq_zero.mp _), by rw [aeval_comp, aeval_X_pow, h2]⟩⟩\n    rwa [← leading_coeff_eq_zero, leading_coeff_comp, leading_coeff_X_pow, one_pow, mul_one] at h\n    rwa [nat_degree_X_pow]\n#align is_integral is_integral\n\n",
 "induction3":
 "/-- An auxiliary induction lemma, which is generalized by `solvable_by_rad.is_solvable`. -/\ntheorem induction3 {α : solvable_by_rad F E} {n : ℕ} (hn : n ≠ 0) (hα : P (α ^ n)) : P α :=\n  by\n  let p := minpoly F (α ^ n)\n  have hp : p.comp (X ^ n) ≠ 0 := by\n    intro h\n    cases' comp_eq_zero_iff.mp h with h' h'\n    · exact minpoly.ne_zero (is_integral (α ^ n)) h'\n    · exact hn (by rw [← nat_degree_C _, ← h'.2, nat_degree_X_pow])\n  apply gal_is_solvable_of_splits\n  ·\n    exact\n      ⟨splits_of_splits_of_dvd _ hp (splitting_field.splits (p.comp (X ^ n)))\n          (minpoly.dvd F α (by rw [aeval_comp, aeval_X_pow, minpoly.aeval]))⟩\n  · refine' gal_is_solvable_tower p (p.comp (X ^ n)) _ hα _\n    · exact gal.splits_in_splitting_field_of_comp _ _ (by rwa [nat_degree_X_pow])\n    · obtain ⟨s, hs⟩ := (splits_iff_exists_multiset _).1 (splitting_field.splits p)\n      rw [map_comp, Polynomial.map_pow, map_X, hs, mul_comp, C_comp]\n      apply gal_mul_is_solvable (gal_C_is_solvable _)\n      rw [multiset_prod_comp]\n      apply gal_prod_is_solvable\n      intro q hq\n      rw [Multiset.mem_map] at hq\n      obtain ⟨q, hq, rfl⟩ := hq\n      rw [Multiset.mem_map] at hq\n      obtain ⟨q, hq, rfl⟩ := hq\n      rw [sub_comp, X_comp, C_comp]\n      exact gal_X_pow_sub_C_is_solvable n q\n#align induction3 induction3\n\n",
 "induction2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/-- An auxiliary induction lemma, which is generalized by `solvable_by_rad.is_solvable`. -/\ntheorem induction2 {α β γ : solvable_by_rad F E}\n    (hγ : γ ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n    (hα : P α) (hβ : P β) : P γ := by\n  let p := minpoly F α\n  let q := minpoly F β\n  have hpq :=\n    Polynomial.splits_of_splits_mul _ (mul_ne_zero (minpoly.ne_zero (is_integral α)) (minpoly.ne_zero (is_integral β)))\n      (splitting_field.splits (p * q))\n  let f :\n    «expr →ₐ[ ] » («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n      F (p * q).splitting_field :=\n    Classical.choice\n      (alg_hom_mk_adjoin_splits\n        (by\n          intro x hx\n          cases hx\n          rw [hx]\n          exact ⟨is_integral α, hpq.1⟩\n          cases hx\n          exact ⟨is_integral β, hpq.2⟩))\n  have key : minpoly F γ = minpoly F (f ⟨γ, hγ⟩) :=\n    minpoly.eq_of_irreducible_of_monic (minpoly.irreducible (is_integral γ))\n      (by\n        suffices\n          aeval\n              (⟨γ, hγ⟩ :\n                «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n              (minpoly F γ) =\n            0\n          by rw [aeval_alg_hom_apply, this, AlgHom.map_zero]\n        apply\n          (algebraMap\n              («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n              (solvable_by_rad F E)).injective\n        rw [RingHom.map_zero, ← aeval_algebra_map_apply]\n        exact minpoly.aeval F γ)\n      (minpoly.monic (is_integral γ))\n  rw [P, key]\n  exact gal_is_solvable_of_splits ⟨normal.splits (splitting_field.normal _) _⟩ (gal_mul_is_solvable hα hβ)\n#align induction2 induction2\n\n",
 "induction1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/-- An auxiliary induction lemma, which is generalized by `solvable_by_rad.is_solvable`. -/\ntheorem induction1 {α β : solvable_by_rad F E}\n    (hβ : β ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n    (hα : P α) : P β :=\n  induction2 (adjoin.mono F _ _ (ge_of_eq (Set.pair_eq_singleton α)) hβ) hα hα\n#align induction1 induction1\n\n",
 "induction":
 "theorem induction (P : solvable_by_rad F E → Prop) (base : ∀ α : F, P (algebraMap F (solvable_by_rad F E) α))\n    (add : ∀ α β : solvable_by_rad F E, P α → P β → P (α + β)) (neg : ∀ α : solvable_by_rad F E, P α → P (-α))\n    (mul : ∀ α β : solvable_by_rad F E, P α → P β → P (α * β)) (inv : ∀ α : solvable_by_rad F E, P α → P α⁻¹)\n    (rad : ∀ α : solvable_by_rad F E, ∀ n : ℕ, n ≠ 0 → P (α ^ n) → P α) (α : solvable_by_rad F E) : P α :=\n  by\n  revert α\n  suffices ∀ α : E, is_solvable_by_rad F α → ∃ β : solvable_by_rad F E, ↑β = α ∧ P β\n    by\n    intro α\n    obtain ⟨α₀, hα₀, Pα⟩ := this α (Subtype.mem α)\n    convert Pα\n    exact Subtype.ext hα₀.symm\n  apply is_solvable_by_rad.rec\n  · exact fun α => ⟨algebraMap F (solvable_by_rad F E) α, rfl, base α⟩\n  · intro α β hα hβ Pα Pβ\n    obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := Pα, Pβ\n    exact\n      ⟨α₀ + β₀, by\n        rw [← hα₀, ← hβ₀]\n        rfl, add α₀ β₀ Pα Pβ⟩\n  · intro α hα Pα\n    obtain ⟨α₀, hα₀, Pα⟩ := Pα\n    exact\n      ⟨-α₀, by\n        rw [← hα₀]\n        rfl, neg α₀ Pα⟩\n  · intro α β hα hβ Pα Pβ\n    obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := Pα, Pβ\n    exact\n      ⟨α₀ * β₀, by\n        rw [← hα₀, ← hβ₀]\n        rfl, mul α₀ β₀ Pα Pβ⟩\n  · intro α hα Pα\n    obtain ⟨α₀, hα₀, Pα⟩ := Pα\n    exact\n      ⟨α₀⁻¹, by\n        rw [← hα₀]\n        rfl, inv α₀ Pα⟩\n  · intro α n hn hα Pα\n    obtain ⟨α₀, hα₀, Pα⟩ := Pα\n    refine' ⟨⟨α, is_solvable_by_rad.rad α n hn hα⟩, rfl, rad _ n hn _⟩\n    convert Pα\n    exact Subtype.ext (Eq.trans ((solvable_by_rad F E).coe_pow _ n) hα₀.symm)\n#align induction induction\n\n",
 "gal_zero_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Thomas Browning and Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning, Patrick Lutz\n-/\ntheorem gal_zero_is_solvable : IsSolvable (0 : polynomial F).gal := by infer_instance\n#align gal_zero_is_solvable gal_zero_is_solvable\n\n",
 "gal_prod_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_prod_is_solvable {s : Multiset (polynomial F)} (hs : ∀ p ∈ s, IsSolvable (gal p)) : IsSolvable s.prod.gal :=\n  by\n  apply Multiset.induction_on' s\n  · exact gal_one_is_solvable\n  · intro p t hps hts ht\n    rw [Multiset.insert_eq_cons, Multiset.prod_cons]\n    exact gal_mul_is_solvable (hs p hps) ht\n#align gal_prod_is_solvable gal_prod_is_solvable\n\n",
 "gal_one_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_one_is_solvable : IsSolvable (1 : polynomial F).gal := by infer_instance\n#align gal_one_is_solvable gal_one_is_solvable\n\n",
 "gal_mul_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_mul_is_solvable {p q : polynomial F} (hp : IsSolvable p.gal) (hq : IsSolvable q.gal) :\n    IsSolvable (p * q).gal :=\n  solvable_of_solvable_injective (gal.restrict_prod_injective p q)\n#align gal_mul_is_solvable gal_mul_is_solvable\n\n",
 "gal_is_solvable_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_is_solvable_tower (p q : polynomial F) (hpq : p.splits (algebraMap F q.splitting_field))\n    (hp : IsSolvable p.gal) (hq : IsSolvable (q.map (algebraMap F p.splitting_field)).gal) : IsSolvable q.gal :=\n  by\n  let K := p.splitting_field\n  let L := q.splitting_field\n  haveI : Fact (p.splits (algebraMap F L)) := ⟨hpq⟩\n  let ϕ : «expr ≃* » («expr ≃ₐ[ ] » L K L) (q.map (algebraMap F K)).gal :=\n    (is_splitting_field.alg_equiv L (q.map (algebraMap F K))).aut_congr\n  have ϕ_inj : function.injective ϕ.to_monoid_hom := ϕ.injective\n  haveI : IsSolvable («expr ≃ₐ[ ] » K F K) := hp\n  haveI : IsSolvable («expr ≃ₐ[ ] » L K L) := solvable_of_solvable_injective ϕ_inj\n  exact is_solvable_of_is_scalar_tower F p.splitting_field q.splitting_field\n#align gal_is_solvable_tower gal_is_solvable_tower\n\n",
 "gal_is_solvable_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_is_solvable_of_splits {p q : polynomial F} (hpq : Fact (p.splits (algebraMap F q.splitting_field)))\n    (hq : IsSolvable q.gal) : IsSolvable p.gal :=\n  haveI : IsSolvable («expr ≃ₐ[ ] » q.splitting_field F q.splitting_field) := hq\n  solvable_of_surjective (alg_equiv.restrict_normal_hom_surjective q.splitting_field)\n#align gal_is_solvable_of_splits gal_is_solvable_of_splits\n\n",
 "gal_X_sub_C_is_solvable":
 "theorem gal_X_sub_C_is_solvable (x : F) : IsSolvable (X - C x).gal := by infer_instance\n#align gal_X_sub_C_is_solvable gal_X_sub_C_is_solvable\n\n",
 "gal_X_pow_sub_one_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_X_pow_sub_one_is_solvable (n : ℕ) : IsSolvable (X ^ n - 1 : polynomial F).gal :=\n  by\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, sub_self]\n    exact gal_zero_is_solvable\n  have hn' : 0 < n := pos_iff_ne_zero.mpr hn\n  have hn'' : (X ^ n - 1 : polynomial F) ≠ 0 := X_pow_sub_C_ne_zero hn' 1\n  apply isSolvable_of_comm\n  intro σ τ\n  ext (a ha)\n  simp only [mem_root_set_of_ne hn'', map_sub, aeval_X_pow, aeval_one, sub_eq_zero] at ha\n  have key : ∀ σ : (X ^ n - 1 : polynomial F).gal, ∃ m : ℕ, σ a = a ^ m :=\n    by\n    intro σ\n    lift n to «exprℕ+» using hn'\n    exact map_root_of_unity_eq_pow_self σ.to_alg_hom (roots_of_unity.mk_of_pow_eq a ha)\n  obtain ⟨c, hc⟩ := key σ\n  obtain ⟨d, hd⟩ := key τ\n  rw [σ.mul_apply, τ.mul_apply, hc, τ.map_pow, hd, σ.map_pow, hc, ← pow_mul, pow_mul']\n#align gal_X_pow_sub_one_is_solvable gal_X_pow_sub_one_is_solvable\n\n",
 "gal_X_pow_sub_C_is_solvable_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_X_pow_sub_C_is_solvable_aux (n : ℕ) (a : F) (h : (X ^ n - 1 : polynomial F).splits (RingHom.id F)) :\n    IsSolvable (X ^ n - C a).gal := by\n  by_cases ha : a = 0\n  · rw [ha, C_0, sub_zero]\n    exact gal_X_pow_is_solvable n\n  have ha' : algebraMap F (X ^ n - C a).splitting_field a ≠ 0 :=\n    mt ((injective_iff_map_eq_zero _).mp (RingHom.injective _) a) ha\n  by_cases hn : n = 0\n  · rw [hn, pow_zero, ← C_1, ← C_sub]\n    exact gal_C_is_solvable (1 - a)\n  have hn' : 0 < n := pos_iff_ne_zero.mpr hn\n  have hn'' : X ^ n - C a ≠ 0 := X_pow_sub_C_ne_zero hn' a\n  have hn''' : (X ^ n - 1 : polynomial F) ≠ 0 := X_pow_sub_C_ne_zero hn' 1\n  have mem_range : ∀ {c}, c ^ n = 1 → ∃ d, algebraMap F (X ^ n - C a).splitting_field d = c := fun c hc =>\n    ring_hom.mem_range.mp\n      (minpoly.mem_range_of_degree_eq_one F c\n        (h.def.resolve_left hn''' (minpoly.irreducible ((splitting_field.normal (X ^ n - C a)).is_integral c))\n          (minpoly.dvd F c (by rwa [map_id, AlgHom.map_sub, sub_eq_zero, aeval_X_pow, aeval_one]))))\n  apply isSolvable_of_comm\n  intro σ τ\n  ext (b hb)\n  simp only [mem_root_set_of_ne hn'', map_sub, aeval_X_pow, aeval_C, sub_eq_zero] at hb\n  have hb' : b ≠ 0 := by\n    intro hb'\n    rw [hb', zero_pow hn'] at hb\n    exact ha' hb.symm\n  have key : ∀ σ : (X ^ n - C a).gal, ∃ c, σ b = b * algebraMap F _ c :=\n    by\n    intro σ\n    have key : (σ b / b) ^ n = 1 := by rw [div_pow, ← σ.map_pow, hb, σ.commutes, div_self ha']\n    obtain ⟨c, hc⟩ := mem_range key\n    use c\n    rw [hc, mul_div_cancel' (σ b) hb']\n  obtain ⟨c, hc⟩ := key σ\n  obtain ⟨d, hd⟩ := key τ\n  rw [σ.mul_apply, τ.mul_apply, hc, τ.map_mul, τ.commutes, hd, σ.map_mul, σ.commutes, hc]\n  rw [mul_assoc, mul_assoc, mul_right_inj' hb', mul_comm]\n#align gal_X_pow_sub_C_is_solvable_aux gal_X_pow_sub_C_is_solvable_aux\n\n",
 "gal_X_pow_sub_C_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_X_pow_sub_C_is_solvable (n : ℕ) (x : F) : IsSolvable (X ^ n - C x).gal :=\n  by\n  by_cases hx : x = 0\n  · rw [hx, C_0, sub_zero]\n    exact gal_X_pow_is_solvable n\n  apply gal_is_solvable_tower (X ^ n - 1) (X ^ n - C x)\n  · exact splits_X_pow_sub_one_of_X_pow_sub_C _ n hx (splitting_field.splits _)\n  · exact gal_X_pow_sub_one_is_solvable n\n  · rw [Polynomial.map_sub, Polynomial.map_pow, map_X, map_C]\n    apply gal_X_pow_sub_C_is_solvable_aux\n    have key := splitting_field.splits (X ^ n - 1 : polynomial F)\n    rwa [← splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_pow, map_X, Polynomial.map_one] at key\n#align gal_X_pow_sub_C_is_solvable gal_X_pow_sub_C_is_solvable\n\n",
 "gal_X_pow_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_X_pow_is_solvable (n : ℕ) : IsSolvable (X ^ n : polynomial F).gal := by infer_instance\n#align gal_X_pow_is_solvable gal_X_pow_is_solvable\n\n",
 "gal_X_is_solvable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem gal_X_is_solvable : IsSolvable (X : polynomial F).gal := by infer_instance\n#align gal_X_is_solvable gal_X_is_solvable\n\n",
 "gal_C_is_solvable":
 "theorem gal_C_is_solvable (x : F) : IsSolvable (C x).gal := by infer_instance\n#align gal_C_is_solvable gal_C_is_solvable\n\n",
 "IsSolvable":
 "#print IsSolvable /-\ntheorem IsSolvable (α : solvable_by_rad F E) : IsSolvable (minpoly F α).gal :=\n  by\n  revert α\n  apply solvable_by_rad.induction\n  ·\n    exact fun α => by\n      rw [minpoly.eq_X_sub_C]\n      exact gal_X_sub_C_is_solvable α\n  ·\n    exact fun α β =>\n      induction2\n        (add_mem (subset_adjoin F _ (Set.mem_insert α _))\n          (subset_adjoin F _ (Set.mem_insert_of_mem α (Set.mem_singleton β))))\n  · exact fun α => induction1 (neg_mem (mem_adjoin_simple_self F α))\n  ·\n    exact fun α β =>\n      induction2\n        (mul_mem (subset_adjoin F _ (Set.mem_insert α _))\n          (subset_adjoin F _ (Set.mem_insert_of_mem α (Set.mem_singleton β))))\n  · exact fun α => induction1 (inv_mem (mem_adjoin_simple_self F α))\n  · exact fun α n => induction3\n#align is_solvable IsSolvable\n-/\n\n"}