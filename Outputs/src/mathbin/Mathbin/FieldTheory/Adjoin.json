{"top_to_subfield":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_subfield : («expr⊤» : intermediate_field F E).to_subfield = «expr⊤» :=\n  rfl\n#align top_to_subfield top_to_subfield\n\n",
 "top_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_to_subalgebra : («expr⊤» : intermediate_field F E).to_subalgebra = «expr⊤» :=\n  rfl\n#align top_to_subalgebra top_to_subalgebra\n\n",
 "top_equiv_symm_apply_coe":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_equiv_symm_apply_coe (a : E) : ↑(top_equiv.symm a : («expr⊤» : intermediate_field F E)) = a :=\n  rfl\n#align top_equiv_symm_apply_coe top_equiv_symm_apply_coe\n\n",
 "sup_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem sup_to_subalgebra [h1 : finite_dimensional K E1] [h2 : finite_dimensional K E2] :\n    («expr ⊔ » E1 E2).to_subalgebra = «expr ⊔ » E1.to_subalgebra E2.to_subalgebra :=\n  by\n  let S1 := E1.to_subalgebra\n  let S2 := E2.to_subalgebra\n  refine'\n    le_antisymm\n      (show _ ≤ («expr ⊔ » S1 S2).to_intermediate_field _ from\n        sup_le (show S1 ≤ _ from le_sup_left) (show S2 ≤ _ from le_sup_right))\n      (le_sup_to_subalgebra E1 E2)\n  suffices IsField («expr↥ » («expr ⊔ » S1 S2)) by\n    intro x hx\n    by_cases hx' : (⟨x, hx⟩ : «expr ⊔ » S1 S2) = 0\n    · rw [← subtype.coe_mk x hx, hx', subalgebra.coe_zero, inv_zero]\n      exact («expr ⊔ » S1 S2).zero_mem\n    · obtain ⟨y, h⟩ := this.mul_inv_cancel hx'\n      exact (congr_arg (· ∈ «expr ⊔ » S1 S2) <| eq_inv_of_mul_eq_one_right <| subtype.ext_iff.mp h).mp y.2\n  exact\n    is_field_of_is_integral_of_is_field'\n      (is_integral_sup.mpr ⟨algebra.is_integral_of_finite K E1, algebra.is_integral_of_finite K E2⟩) (Field.toIsField K)\n#align sup_to_subalgebra sup_to_subalgebra\n\n",
 "subsingleton_of_finrank_adjoin_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem subsingleton_of_finrank_adjoin_le_one [finite_dimensional F E]\n    (h :\n      ∀ x : E,\n        finrank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") ≤\n          1) :\n    subsingleton (intermediate_field F E) :=\n  subsingleton_of_bot_eq_top (bot_eq_top_of_finrank_adjoin_le_one h)\n#align subsingleton_of_finrank_adjoin_le_one subsingleton_of_finrank_adjoin_le_one\n\n",
 "subsingleton_of_finrank_adjoin_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem subsingleton_of_finrank_adjoin_eq_one\n    (h :\n      ∀ x : E,\n        finrank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n          1) :\n    subsingleton (intermediate_field F E) :=\n  subsingleton_of_bot_eq_top (bot_eq_top_of_finrank_adjoin_eq_one h)\n#align subsingleton_of_finrank_adjoin_eq_one subsingleton_of_finrank_adjoin_eq_one\n\n",
 "subsingleton_of_dim_adjoin_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem subsingleton_of_dim_adjoin_eq_one\n    (h :\n      ∀ x : E,\n        module.rank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n          1) :\n    subsingleton (intermediate_field F E) :=\n  subsingleton_of_bot_eq_top (bot_eq_top_of_dim_adjoin_eq_one h)\n#align subsingleton_of_dim_adjoin_eq_one subsingleton_of_dim_adjoin_eq_one\n\n",
 "subset_adjoin_of_subset_right":
 "theorem subset_adjoin_of_subset_right {T : set E} (H : T ⊆ S) : T ⊆ adjoin F S := fun x hx => subset_adjoin F S (H hx)\n#align subset_adjoin_of_subset_right subset_adjoin_of_subset_right\n\n",
 "subset_adjoin_of_subset_left":
 "theorem subset_adjoin_of_subset_left {F : subfield E} {T : set E} (HT : T ⊆ F) : T ⊆ adjoin F S := fun x hx =>\n  (adjoin F S).algebra_map_mem ⟨x, HT hx⟩\n#align subset_adjoin_of_subset_left subset_adjoin_of_subset_left\n\n",
 "subset_adjoin":
 "theorem subset_adjoin : S ⊆ adjoin F S := fun x hx => subfield.subset_closure (or.inr hx)\n#align subset_adjoin subset_adjoin\n\n",
 "restrict_scalars_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem restrict_scalars_top {K : Type _} [Field K] [algebra K E] [algebra K F] [IsScalarTower K F E] :\n    («expr⊤» : intermediate_field F E).restrict_scalars K = «expr⊤» :=\n  rfl\n#align restrict_scalars_top restrict_scalars_top\n\n",
 "restrict_scalars_bot_eq_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem restrict_scalars_bot_eq_self (K : intermediate_field F E) :\n    («expr⊥» : intermediate_field K E).restrict_scalars _ = K :=\n  by\n  ext\n  rw [mem_restrict_scalars, mem_bot]\n  exact set.ext_iff.mp Subtype.range_coe x\n#align restrict_scalars_bot_eq_self restrict_scalars_bot_eq_self\n\n",
 "range_algebra_map_subset":
 "theorem adjoin.range_algebra_map_subset : Set.range (algebra_map F E) ⊆ adjoin F S :=\n  by\n  intro x hx\n  cases' hx with f hf\n  rw [← hf]\n  exact adjoin.algebra_map_mem F S f\n#align adjoin.range_algebra_map_subset adjoin.range_algebra_map_subset\n\n",
 "nat_degree_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem _root_.minpoly.nat_degree_le {x : L} [finite_dimensional K L] (hx : is_integral K x) :\n    (minpoly K x).nat_degree ≤ finrank K L :=\n  le_of_eq_of_le (intermediate_field.adjoin.finrank hx).symm\n    («expr ⟮ ,⟯» K\n          \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").to_submodule.finrank_le\n#align minpoly.nat_degree_le minpoly.nat_degree_le\n\n",
 "mono":
 "@[mono]\ntheorem adjoin.mono (T : set E) (h : S ⊆ T) : adjoin F S ≤ adjoin F T :=\n  GaloisConnection.monotone_l gc h\n#align adjoin.mono adjoin.mono\n\n",
 "minpoly_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem minpoly_gen {α : E} (h : is_integral F α) : minpoly F (adjoin_simple.gen F α) = minpoly F α :=\n  by\n  rw [← adjoin_simple.algebra_map_gen F α] at h\n  have inj :=\n    (algebra_map («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        E).injective\n  exact\n    minpoly.eq_of_algebra_map_eq inj ((is_integral_algebra_map_iff inj).mp h) (adjoin_simple.algebra_map_gen _ _).symm\n#align minpoly_gen minpoly_gen\n\n",
 "mem_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem mem_top {x : E} : x ∈ («expr⊤» : intermediate_field F E) :=\n  trivial\n#align mem_top mem_top\n\n",
 "mem_lifts_of_splits":
 "theorem lifts.mem_lifts_of_splits (x : lifts F E K) {s : E} (h1 : is_integral F s)\n    (h2 : (minpoly F s).splits (algebra_map F K)) : s ∈ (x.lift_of_splits h1 h2).1 :=\n  mem_adjoin_simple_self x.1 s\n#align lifts.mem_lifts_of_splits lifts.mem_lifts_of_splits\n\n",
 "mem_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem mem_inf {S T : intermediate_field F E} {x : E} : x ∈ «expr ⊓ » S T ↔ x ∈ S ∧ x ∈ T :=\n  iff.rfl\n#align mem_inf mem_inf\n\n",
 "mem_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem mem_bot {x : E} : x ∈ («expr⊥» : intermediate_field F E) ↔ x ∈ Set.range (algebra_map F E) :=\n  Set.ext_iff.mp coe_bot x\n#align mem_bot mem_bot\n\n",
 "mem_adjoin_simple_self":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n--this definition of notation is courtesy of Kyle Miller on zulip\ntheorem mem_adjoin_simple_self :\n    α ∈ «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" :=\n  subset_adjoin F {α} (Set.mem_singleton α)\n#align mem_adjoin_simple_self mem_adjoin_simple_self\n\n",
 "map_field_range":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem _root_.alg_hom.map_field_range {K L : Type _} [Field K] [Field L] [algebra F K] [algebra F L]\n    (f : «expr →ₐ[ ] » E F K) (g : «expr →ₐ[ ] » K F L) : f.field_range.map g = (g.comp f).field_range :=\n  SetLike.ext' (Set.range_comp g f).symm\n#align alg_hom.map_field_range alg_hom.map_field_range\n\n",
 "le_sup_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\ntheorem le_sup_to_subalgebra : «expr ⊔ » E1.to_subalgebra E2.to_subalgebra ≤ («expr ⊔ » E1 E2).to_subalgebra :=\n  sup_le (show E1 ≤ «expr ⊔ » E1 E2 from le_sup_left) (show E2 ≤ «expr ⊔ » E1 E2 from le_sup_right)\n#align le_sup_to_subalgebra le_sup_to_subalgebra\n\n",
 "le_lifts_of_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem lifts.le_lifts_of_splits (x : lifts F E K) {s : E} (h1 : is_integral F s)\n    (h2 : (minpoly F s).splits (algebra_map F K)) : x ≤ x.lift_of_splits h1 h2 :=\n  ⟨fun z hz =>\n    algebra_map_mem\n      («expr ⟮ ,⟯» x.1 \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") ⟨z, hz⟩,\n    fun t u htu =>\n    eq.symm\n      (by\n        rw [←\n          show\n            algebra_map x.1\n                («expr ⟮ ,⟯» x.1 \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n                t =\n              u\n            from subtype.ext htu]\n        letI : algebra x.1 K := x.2.to_ring_hom.to_algebra\n        exact alg_hom.commutes _ t)⟩\n#align lifts.le_lifts_of_splits lifts.le_lifts_of_splits\n\n",
 "is_splitting_field_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A compositum of splitting fields is a splitting field -/\ntheorem is_splitting_field_supr {ι : Type _} {t : ι → intermediate_field F E} {p : ι → polynomial F} {s : Finset ι}\n    (h0 : finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s (p i) ≠ 0)\n    (h : ∀ i ∈ s, (p i).is_splitting_field F (t i)) :\n    (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" s\n          (p i)).is_splitting_field\n      F\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t i) :\n        intermediate_field F E) :=\n  by\n  let K : intermediate_field F E :=\n    «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (t i)\n  have hK : ∀ i ∈ s, t i ≤ K := fun i hi => le_supᵢ_of_le i (le_supᵢ (fun _ => t i) hi)\n  simp only [is_splitting_field_iff] at h⊢\n  refine'\n    ⟨splits_prod (algebra_map F K) fun i hi =>\n        polynomial.splits_comp_of_splits (algebra_map F (t i)) (inclusion (hK i hi)).to_ring_hom (h i hi).1,\n      _⟩\n  simp only [root_set_prod p s h0, ← Set.supᵢ_eq_unionᵢ, (@gc F _ E _ _).l_supr₂]\n  exact supᵢ_congr fun i => supᵢ_congr fun hi => (h i hi).2\n#align is_splitting_field_supr is_splitting_field_supr\n\n",
 "is_splitting_field_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem is_splitting_field_iff {p : polynomial F} {K : intermediate_field F E} :\n    p.is_splitting_field F K ↔ p.splits (algebra_map F K) ∧ K = adjoin F (p.root_set E) :=\n  by\n  suffices _ → (algebra.adjoin F (p.root_set K) = «expr⊤» ↔ K = adjoin F (p.root_set E)) by\n    exact ⟨fun h => ⟨h.1, (this h.1).mp h.2⟩, fun h => ⟨h.1, (this h.1).mpr h.2⟩⟩\n  simp_rw [SetLike.ext_iff, ← mem_to_subalgebra, ← SetLike.ext_iff]\n  rw [← K.range_val, adjoin_algebraic_to_subalgebra fun x => is_algebraic_of_mem_root_set]\n  exact fun hp => (adjoin_root_set_eq_range hp K.val).symm.trans eq_comm\n#align is_splitting_field_iff is_splitting_field_iff\n\n",
 "is_integral_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n@[simp]\ntheorem adjoin_simple.is_integral_gen : is_integral F (adjoin_simple.gen F α) ↔ is_integral F α :=\n  by\n  conv_rhs => rw [← adjoin_simple.algebra_map_gen F α]\n  rw [is_integral_algebra_map_iff\n      (algebra_map («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n          E).injective]\n  infer_instance\n#align adjoin_simple.is_integral_gen adjoin_simple.is_integral_gen\n\n",
 "is_algebraic_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/-- A compositum of algebraic extensions is algebraic -/\ntheorem is_algebraic_supr {ι : Type _} {f : ι → intermediate_field K L} (h : ∀ i, algebra.is_algebraic K (f i)) :\n    algebra.is_algebraic K\n      («expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :\n        intermediate_field K L) :=\n  by\n  rintro ⟨x, hx⟩\n  obtain ⟨s, hx⟩ := exists_finset_of_mem_supr' hx\n  rw [is_algebraic_iff, subtype.coe_mk, ← subtype.coe_mk x hx, ← is_algebraic_iff]\n  haveI :\n    ∀ i : Σi, f i,\n      finite_dimensional K\n        («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n    fun ⟨i, x⟩ => adjoin.finite_dimensional (is_integral_iff.1 (is_algebraic_iff_is_integral.1 (h i x)))\n  apply algebra.is_algebraic_of_finite\n#align is_algebraic_supr is_algebraic_supr\n\n",
 "infi_to_subfield":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem infi_to_subfield {ι : Sort _} (S : ι → intermediate_field F E) :\n    (infᵢ S).to_subfield =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (S i).to_subfield :=\n  SetLike.coe_injective <| by simp [infᵢ]\n#align infi_to_subfield infi_to_subfield\n\n",
 "infi_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem infi_to_subalgebra {ι : Sort _} (S : ι → intermediate_field F E) :\n    (infᵢ S).to_subalgebra =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        (S i).to_subalgebra :=\n  SetLike.coe_injective <| by simp [infᵢ]\n#align infi_to_subalgebra infi_to_subalgebra\n\n",
 "inf_to_subfield":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_to_subfield (S T : intermediate_field F E) :\n    («expr ⊓ » S T).to_subfield = «expr ⊓ » S.to_subfield T.to_subfield :=\n  rfl\n#align inf_to_subfield inf_to_subfield\n\n",
 "inf_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_to_subalgebra (S T : intermediate_field F E) :\n    («expr ⊓ » S T).to_subalgebra = «expr ⊓ » S.to_subalgebra T.to_subalgebra :=\n  rfl\n#align inf_to_subalgebra inf_to_subalgebra\n\n",
 "induction_on_adjoin_finset":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem induction_on_adjoin_finset (S : Finset E) (P : intermediate_field F E → Prop) (base : P («expr⊥»))\n    (ih :\n      ∀ (K : intermediate_field F E),\n        ∀ x ∈ S,\n          P K →\n            P\n              ((«expr ⟮ ,⟯» K\n                    \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n                F)) :\n    P (adjoin F ↑S) := by\n  apply Finset.induction_on' S\n  · exact base\n  · intro a s h1 _ _ h4\n    rw [Finset.coe_insert, Set.insert_eq, Set.union_comm, ← adjoin_adjoin_left]\n    exact ih (adjoin F s) a h1 h4\n#align induction_on_adjoin_finset induction_on_adjoin_finset\n\n",
 "induction_on_adjoin_fg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem induction_on_adjoin_fg (P : intermediate_field F E → Prop) (base : P («expr⊥»))\n    (ih :\n      ∀ (K : intermediate_field F E) (x : E),\n        P K →\n          P\n            ((«expr ⟮ ,⟯» K\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n              F))\n    (K : intermediate_field F E) (hK : K.fg) : P K :=\n  by\n  obtain ⟨S, rfl⟩ := hK\n  exact induction_on_adjoin_finset S P base fun K x _ hK => ih K x hK\n#align induction_on_adjoin_fg induction_on_adjoin_fg\n\n",
 "induction_on_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem induction_on_adjoin [fd : finite_dimensional F E] (P : intermediate_field F E → Prop) (base : P («expr⊥»))\n    (ih :\n      ∀ (K : intermediate_field F E) (x : E),\n        P K →\n          P\n            ((«expr ⟮ ,⟯» K\n                  \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n              F))\n    (K : intermediate_field F E) : P K :=\n  letI : is_noetherian F E := is_noetherian.iff_fg.2 infer_instance\n  induction_on_adjoin_fg P base ih K K.fg_of_noetherian\n#align induction_on_adjoin induction_on_adjoin\n\n",
 "gc":
 "theorem gc : GaloisConnection (adjoin F : set E → intermediate_field F E) coe := fun _ _ => adjoin_le_iff\n#align gc gc\n\n",
 "finrank_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem finrank_eq_one_iff : finrank F K = 1 ↔ K = «expr⊥» := by\n  rw [← to_subalgebra_eq_iff, ← finrank_eq_finrank_subalgebra, subalgebra.finrank_eq_one_iff, bot_to_subalgebra]\n#align finrank_eq_one_iff finrank_eq_one_iff\n\n",
 "finrank_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem finrank_bot : finrank F («expr⊥» : intermediate_field F E) = 1 := by rw [finrank_eq_one_iff]\n#align finrank_bot finrank_bot\n\n",
 "finrank_adjoin_simple_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem finrank_adjoin_simple_eq_one_iff :\n    finrank F («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n        1 ↔\n      α ∈ («expr⊥» : intermediate_field F E) :=\n  by\n  rw [finrank_adjoin_eq_one_iff]\n  exact Set.singleton_subset_iff\n#align finrank_adjoin_simple_eq_one_iff finrank_adjoin_simple_eq_one_iff\n\n",
 "finrank_adjoin_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem finrank_adjoin_eq_one_iff : finrank F (adjoin F S) = 1 ↔ S ⊆ («expr⊥» : intermediate_field F E) :=\n  iff.trans finrank_eq_one_iff adjoin_eq_bot_iff\n#align finrank_adjoin_eq_one_iff finrank_adjoin_eq_one_iff\n\n",
 "finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem adjoin.finrank {x : L} (hx : is_integral K x) :\n    finite_dimensional.finrank K\n        («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n      (minpoly K x).nat_degree :=\n  by\n  rw [power_basis.finrank (adjoin.power_basis hx : _)]\n  rfl\n#align adjoin.finrank adjoin.finrank\n\n",
 "finite_dimensional":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem adjoin.finite_dimensional {x : L} (hx : is_integral K x) :\n    finite_dimensional K\n      («expr ⟮ ,⟯» K \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n  power_basis.finite_dimensional (adjoin.power_basis hx)\n#align adjoin.finite_dimensional adjoin.finite_dimensional\n\n",
 "field_range_eq_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem _root_.alg_hom.field_range_eq_map {K : Type _} [Field K] [algebra F K] (f : «expr →ₐ[ ] » E F K) :\n    f.field_range = intermediate_field.map f («expr⊤») :=\n  SetLike.ext' Set.image_univ.symm\n#align alg_hom.field_range_eq_map alg_hom.field_range_eq_map\n\n",
 "fg_of_noetherian":
 "theorem fg_of_noetherian (S : intermediate_field F E) [is_noetherian F E] : S.fg :=\n  S.fg_of_fg_to_subalgebra S.to_subalgebra.fg_of_noetherian\n#align fg_of_noetherian fg_of_noetherian\n\n",
 "fg_of_fg_to_subalgebra":
 "theorem fg_of_fg_to_subalgebra (S : intermediate_field F E) (h : S.to_subalgebra.fg) : S.fg :=\n  by\n  cases' h with t ht\n  exact ⟨t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm⟩\n#align fg_of_fg_to_subalgebra fg_of_fg_to_subalgebra\n\n",
 "fg_def":
 "theorem fg_def {S : intermediate_field F E} : S.fg ↔ ∃ t : set E, set.finite t ∧ adjoin F t = S :=\n  iff.symm set.exists_finite_iff_finset\n#align fg_def fg_def\n\n",
 "fg_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem fg_bot : («expr⊥» : intermediate_field F E).fg :=\n  ⟨∅, adjoin_empty F E⟩\n#align fg_bot fg_bot\n\n",
 "fg_adjoin_finset":
 "theorem fg_adjoin_finset (t : Finset E) : (adjoin F (↑t : set E)).fg :=\n  ⟨t, rfl⟩\n#align fg_adjoin_finset fg_adjoin_finset\n\n",
 "exists_upper_bound":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lifts.exists_upper_bound (c : set (lifts F E K)) (hc : IsChain (· ≤ ·) c) : ∃ ub, ∀ a ∈ c, a ≤ ub :=\n  ⟨lifts.upper_bound hc, by\n    intro x hx\n    constructor\n    · exact fun s hs => ⟨x, Set.mem_insert_of_mem («expr⊥») hx, hs⟩\n    · intro s t hst\n      change x.2 s = (Classical.choose t.mem).2 ⟨t, (Classical.choose_spec t.mem).2⟩\n      obtain ⟨z, hz, hxz, hyz⟩ :=\n        lifts.exists_max_two hc (Set.mem_insert_of_mem («expr⊥») hx) (Classical.choose_spec t.mem).1\n      rw [lifts.eq_of_le hxz, lifts.eq_of_le hyz]\n      exact congr_arg z.2 (subtype.ext hst)⟩\n#align lifts.exists_upper_bound lifts.exists_upper_bound\n\n",
 "exists_max_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lifts.exists_max_two {c : set (lifts F E K)} {x y : lifts F E K} (hc : IsChain (· ≤ ·) c)\n    (hx : x ∈ has_insert.insert («expr⊥») c) (hy : y ∈ has_insert.insert («expr⊥») c) :\n    ∃ z : lifts F E K, z ∈ has_insert.insert («expr⊥») c ∧ x ≤ z ∧ y ≤ z :=\n  by\n  cases' (hc.insert fun _ _ _ => or.inl bot_le).total hx hy with hxy hyx\n  · exact ⟨y, hy, hxy, le_refl y⟩\n  · exact ⟨x, hx, le_refl x, hyx⟩\n#align lifts.exists_max_two lifts.exists_max_two\n\n",
 "exists_max_three":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem lifts.exists_max_three {c : set (lifts F E K)} {x y z : lifts F E K} (hc : IsChain (· ≤ ·) c)\n    (hx : x ∈ has_insert.insert («expr⊥») c) (hy : y ∈ has_insert.insert («expr⊥») c)\n    (hz : z ∈ has_insert.insert («expr⊥») c) :\n    ∃ w : lifts F E K, w ∈ has_insert.insert («expr⊥») c ∧ x ≤ w ∧ y ≤ w ∧ z ≤ w :=\n  by\n  obtain ⟨v, hv, hxv, hyv⟩ := lifts.exists_max_two hc hx hy\n  obtain ⟨w, hw, hzw, hvw⟩ := lifts.exists_max_two hc hz hv\n  exact ⟨w, hw, le_trans hxv hvw, le_trans hyv hvw, hzw⟩\n#align lifts.exists_max_three lifts.exists_max_three\n\n",
 "exists_lift_of_splits":
 "theorem lifts.exists_lift_of_splits (x : lifts F E K) {s : E} (h1 : is_integral F s)\n    (h2 : (minpoly F s).splits (algebra_map F K)) : ∃ y, x ≤ y ∧ s ∈ y.1 :=\n  ⟨x.lift_of_splits h1 h2, x.le_lifts_of_splits h1 h2, x.mem_lifts_of_splits h1 h2⟩\n#align lifts.exists_lift_of_splits lifts.exists_lift_of_splits\n\n",
 "exists_finset_of_mem_supr''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem exists_finset_of_mem_supr'' {ι : Type _} {f : ι → intermediate_field F E}\n    (h : ∀ i, algebra.is_algebraic F (f i)) {x : E}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :\n    ∃ s : Finset (Σi, f i),\n      x ∈\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          (adjoin F ((minpoly F (i.2 : _)).root_set E)) :=\n  by\n  refine'\n    exists_finset_of_mem_supr\n      (set_like.le_def.mp\n        (supᵢ_le fun i x hx => set_like.le_def.mp (le_supᵢ_of_le ⟨i, x, hx⟩ le_rfl) (subset_adjoin F _ _)) hx)\n  rw [intermediate_field.minpoly_eq, subtype.coe_mk, mem_root_set_of_ne, minpoly.aeval]\n  exact minpoly.ne_zero (is_integral_iff.mp (is_algebraic_iff_is_integral.mp (h i ⟨x, hx⟩)))\n#align exists_finset_of_mem_supr'' exists_finset_of_mem_supr''\n\n",
 "exists_finset_of_mem_supr'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem exists_finset_of_mem_supr' {ι : Type _} {f : ι → intermediate_field F E} {x : E}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :\n    ∃ s : Finset (Σi, f i),\n      x ∈\n        «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n  exists_finset_of_mem_supr\n    (SetLike.le_def.mp\n      (supᵢ_le fun i x h => SetLike.le_def.mp (le_supᵢ_of_le ⟨i, x, h⟩ le_rfl) (mem_adjoin_simple_self F x)) hx)\n#align exists_finset_of_mem_supr' exists_finset_of_mem_supr'\n\n",
 "exists_finset_of_mem_supr":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem exists_finset_of_mem_supr {ι : Type _} {f : ι → intermediate_field F E} {x : E}\n    (hx : x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i)) :\n    ∃ s : Finset ι,\n      x ∈ «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i) :=\n  by\n  have := (adjoin_simple_is_compact_element x).exists_finset_of_le_supr (intermediate_field F E) f\n  simp only [adjoin_simple_le_iff] at this\n  exact this hx\n#align exists_finset_of_mem_supr exists_finset_of_mem_supr\n\n",
 "equiv_of_eq_trans":
 "@[simp]\ntheorem equiv_of_eq_trans {S T U : intermediate_field F E} (hST : S = T) (hTU : T = U) :\n    (equiv_of_eq hST).trans (equiv_of_eq hTU) = equiv_of_eq (trans hST hTU) :=\n  rfl\n#align equiv_of_eq_trans equiv_of_eq_trans\n\n",
 "equiv_of_eq_symm":
 "@[simp]\ntheorem equiv_of_eq_symm {S T : intermediate_field F E} (h : S = T) : (equiv_of_eq h).symm = equiv_of_eq h.symm :=\n  rfl\n#align equiv_of_eq_symm equiv_of_eq_symm\n\n",
 "equiv_of_eq_rfl":
 "@[simp]\ntheorem equiv_of_eq_rfl (S : intermediate_field F E) : equiv_of_eq (rfl : S = S) = alg_equiv.refl :=\n  by\n  ext\n  rfl\n#align equiv_of_eq_rfl equiv_of_eq_rfl\n\n",
 "equiv_adjoin_simple_symm_gen":
 "@[simp]\ntheorem equiv_adjoin_simple_symm_gen (pb : power_basis K L) :\n    pb.equiv_adjoin_simple.symm pb.gen = adjoin_simple.gen K pb.gen := by\n  rw [equiv_adjoin_simple, equiv_of_minpoly_symm, equiv_of_minpoly_gen, adjoin.power_basis_gen]\n#align equiv_adjoin_simple_symm_gen equiv_adjoin_simple_symm_gen\n\n",
 "equiv_adjoin_simple_symm_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem equiv_adjoin_simple_symm_aeval (pb : power_basis K L) (f : polynomial K) :\n    pb.equiv_adjoin_simple.symm (aeval pb.gen f) = aeval (adjoin_simple.gen K pb.gen) f := by\n  rw [equiv_adjoin_simple, equiv_of_minpoly_symm, equiv_of_minpoly_aeval, adjoin.power_basis_gen]\n#align equiv_adjoin_simple_symm_aeval equiv_adjoin_simple_symm_aeval\n\n",
 "equiv_adjoin_simple_gen":
 "@[simp]\ntheorem equiv_adjoin_simple_gen (pb : power_basis K L) : pb.equiv_adjoin_simple (adjoin_simple.gen K pb.gen) = pb.gen :=\n  equiv_of_minpoly_gen _ pb _\n#align equiv_adjoin_simple_gen equiv_adjoin_simple_gen\n\n",
 "equiv_adjoin_simple_aeval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n@[simp]\ntheorem equiv_adjoin_simple_aeval (pb : power_basis K L) (f : polynomial K) :\n    pb.equiv_adjoin_simple (aeval (adjoin_simple.gen K pb.gen) f) = aeval pb.gen f :=\n  equiv_of_minpoly_aeval _ pb _ f\n#align equiv_adjoin_simple_aeval equiv_adjoin_simple_aeval\n\n",
 "eq_of_le":
 "theorem lifts.eq_of_le {x y : lifts F E K} (hxy : x ≤ y) (s : x.1) : x.2 s = y.2 ⟨s, hxy.1 s.mem⟩ :=\n  hxy.2 s ⟨s, hxy.1 s.mem⟩ rfl\n#align lifts.eq_of_le lifts.eq_of_le\n\n",
 "eq_adjoin_of_eq_algebra_adjoin":
 "theorem eq_adjoin_of_eq_algebra_adjoin (K : intermediate_field F E) (h : K.to_subalgebra = algebra.adjoin F S) :\n    K = adjoin F S := by\n  apply to_subalgebra_injective\n  rw [h]\n  refine' (adjoin_eq_algebra_adjoin _ _ _).symm\n  intro x\n  convert K.inv_mem\n  rw [← h]\n  rfl\n#align eq_adjoin_of_eq_algebra_adjoin eq_adjoin_of_eq_algebra_adjoin\n\n",
 "dim_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem dim_eq_one_iff : module.rank F K = 1 ↔ K = «expr⊥» := by\n  rw [← to_subalgebra_eq_iff, ← dim_eq_dim_subalgebra, subalgebra.dim_eq_one_iff, bot_to_subalgebra]\n#align dim_eq_one_iff dim_eq_one_iff\n\n",
 "dim_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem dim_bot : module.rank F («expr⊥» : intermediate_field F E) = 1 := by rw [dim_eq_one_iff]\n#align dim_bot dim_bot\n\n",
 "dim_adjoin_simple_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem dim_adjoin_simple_eq_one_iff :\n    module.rank F\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n        1 ↔\n      α ∈ («expr⊥» : intermediate_field F E) :=\n  by\n  rw [dim_adjoin_eq_one_iff]\n  exact Set.singleton_subset_iff\n#align dim_adjoin_simple_eq_one_iff dim_adjoin_simple_eq_one_iff\n\n",
 "dim_adjoin_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem dim_adjoin_eq_one_iff : module.rank F (adjoin F S) = 1 ↔ S ⊆ («expr⊥» : intermediate_field F E) :=\n  iff.trans dim_eq_one_iff adjoin_eq_bot_iff\n#align dim_adjoin_eq_one_iff dim_adjoin_eq_one_iff\n\n",
 "degree_le":
 "theorem _root_.minpoly.degree_le {x : L} [finite_dimensional K L] (hx : is_integral K x) :\n    (minpoly K x).degree ≤ finrank K L :=\n  degree_le_of_nat_degree_le (minpoly.nat_degree_le hx)\n#align minpoly.degree_le minpoly.degree_le\n\n",
 "coe_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem coe_top : ↑(«expr⊤» : intermediate_field F E) = (Set.univ : set E) :=\n  rfl\n#align coe_top coe_top\n\n",
 "coe_infi":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋂ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , » -/\n@[simp, norm_cast]\ntheorem coe_infi {ι : Sort _} (S : ι → intermediate_field F E) :\n    (↑(infᵢ S) : set E) =\n      «expr⋂ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋂ , »\" (S i) :=\n  by simp [infᵢ]\n#align coe_infi coe_infi\n\n",
 "coe_inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp, norm_cast]\ntheorem coe_inf (S T : intermediate_field F E) : (↑(«expr ⊓ » S T) : set E) = S ∩ T :=\n  rfl\n#align coe_inf coe_inf\n\n",
 "coe_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_bot : ↑(«expr⊥» : intermediate_field F E) = Set.range (algebra_map F E) :=\n  by\n  change ↑(subfield.closure (Set.range (algebra_map F E) ∪ ∅)) = Set.range (algebra_map F E)\n  simp [← Set.image_univ, ← ring_hom.map_field_closure]\n#align coe_bot coe_bot\n\n",
 "coe_algebra_map_over_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem coe_algebra_map_over_bot :\n    (algebra_map («expr⊥» : intermediate_field F E) F : («expr⊥» : intermediate_field F E) → F) =\n      intermediate_field.bot_equiv F E :=\n  rfl\n#align coe_algebra_map_over_bot coe_algebra_map_over_bot\n\n",
 "coe_Inf":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp, norm_cast]\ntheorem coe_Inf (S : set (intermediate_field F E)) : (↑(infₛ S) : set E) = infₛ («expr '' » coe S) :=\n  rfl\n#align coe_Inf coe_Inf\n\n",
 "card_alg_hom_adjoin_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem card_alg_hom_adjoin_integral (h : is_integral F α) (h_sep : (minpoly F α).separable)\n    (h_splits : (minpoly F α).splits (algebra_map F K)) :\n    @fintype.card\n        («expr →ₐ[ ] »\n          («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") F K)\n        (fintype_of_alg_hom_adjoin_integral F h) =\n      (minpoly F α).nat_degree :=\n  by\n  rw [alg_hom.card_of_power_basis] <;>\n    simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]\n#align card_alg_hom_adjoin_integral card_alg_hom_adjoin_integral\n\n",
 "bot_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_to_subalgebra : («expr⊥» : intermediate_field F E).to_subalgebra = «expr⊥» :=\n  by\n  ext\n  rw [mem_to_subalgebra, algebra.mem_bot, mem_bot]\n#align bot_to_subalgebra bot_to_subalgebra\n\n",
 "bot_equiv_symm":
 "@[simp]\ntheorem bot_equiv_symm (x : F) : (bot_equiv F E).symm x = algebra_map F _ x :=\n  rfl\n#align bot_equiv_symm bot_equiv_symm\n\n",
 "bot_equiv_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_equiv_def (x : F) : bot_equiv F E (algebra_map F («expr⊥» : intermediate_field F E) x) = x :=\n  alg_equiv.commutes (bot_equiv F E) x\n#align bot_equiv_def bot_equiv_def\n\n",
 "bot_eq_top_of_finrank_adjoin_le_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `F⟮x⟯` has dimension `≤1` over `F` for every `x ∈ E` then `F = E`. -/\ntheorem bot_eq_top_of_finrank_adjoin_le_one [finite_dimensional F E]\n    (h :\n      ∀ x : E,\n        finrank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") ≤\n          1) :\n    («expr⊥» : intermediate_field F E) = «expr⊤» :=\n  by\n  apply bot_eq_top_of_finrank_adjoin_eq_one\n  exact fun x => by\n    linarith [h x,\n      show\n        0 <\n          finrank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        from finrank_pos]\n#align bot_eq_top_of_finrank_adjoin_le_one bot_eq_top_of_finrank_adjoin_le_one\n\n",
 "bot_eq_top_of_finrank_adjoin_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem bot_eq_top_of_finrank_adjoin_eq_one\n    (h :\n      ∀ x : E,\n        finrank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n          1) :\n    («expr⊥» : intermediate_field F E) = «expr⊤» := by\n  ext\n  rw [iff_true_right intermediate_field.mem_top]\n  exact finrank_adjoin_simple_eq_one_iff.mp (h x)\n#align bot_eq_top_of_finrank_adjoin_eq_one bot_eq_top_of_finrank_adjoin_eq_one\n\n",
 "bot_eq_top_of_dim_adjoin_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `F⟮x⟯` has dimension `1` over `F` for every `x ∈ E` then `F = E`. -/\ntheorem bot_eq_top_of_dim_adjoin_eq_one\n    (h :\n      ∀ x : E,\n        module.rank F\n            («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") =\n          1) :\n    («expr⊥» : intermediate_field F E) = «expr⊤» := by\n  ext\n  rw [iff_true_right intermediate_field.mem_top]\n  exact dim_adjoin_simple_eq_one_iff.mp (h x)\n#align bot_eq_top_of_dim_adjoin_eq_one bot_eq_top_of_dim_adjoin_eq_one\n\n",
 "algebra_map_mem":
 "theorem adjoin.algebra_map_mem (x : F) : algebra_map F E x ∈ adjoin F S :=\n  intermediate_field.algebra_map_mem (adjoin F S) x\n#align adjoin.algebra_map_mem adjoin.algebra_map_mem\n\n",
 "algebra_map_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n@[simp]\ntheorem adjoin_simple.algebra_map_gen :\n    algebra_map («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") E\n        (adjoin_simple.gen F α) =\n      α :=\n  rfl\n#align adjoin_simple.algebra_map_gen adjoin_simple.algebra_map_gen\n\n",
 "algebra_adjoin_le_adjoin":
 "theorem algebra_adjoin_le_adjoin : algebra.adjoin F S ≤ (adjoin F S).to_subalgebra :=\n  algebra.adjoin_le (subset_adjoin _ _)\n#align algebra_adjoin_le_adjoin algebra_adjoin_le_adjoin\n\n",
 "alg_hom_mk_adjoin_splits'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom_mk_adjoin_splits' (hS : adjoin F S = «expr⊤»)\n    (hK : ∀ x ∈ S, is_integral F (x : E) ∧ (minpoly F x).splits (algebra_map F K)) : nonempty («expr →ₐ[ ] » E F K) :=\n  by\n  cases' alg_hom_mk_adjoin_splits hK with ϕ\n  rw [hS] at ϕ\n  exact ⟨ϕ.comp top_equiv.symm.to_alg_hom⟩\n#align alg_hom_mk_adjoin_splits' alg_hom_mk_adjoin_splits'\n\n",
 "alg_hom_mk_adjoin_splits":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem alg_hom_mk_adjoin_splits (hK : ∀ s ∈ S, is_integral F (s : E) ∧ (minpoly F s).splits (algebra_map F K)) :\n    nonempty («expr →ₐ[ ] » (adjoin F S) F K) :=\n  by\n  obtain ⟨x : lifts F E K, hx⟩ := zorn_partialOrder lifts.exists_upper_bound\n  refine'\n    ⟨alg_hom.mk (fun s => x.2 ⟨s, adjoin_le_iff.mpr (fun s hs => _) s.mem⟩) x.2.map_one\n        (fun s t => x.2.map_mul ⟨s, _⟩ ⟨t, _⟩) x.2.map_zero (fun s t => x.2.map_add ⟨s, _⟩ ⟨t, _⟩) x.2.commutes⟩\n  rcases x.exists_lift_of_splits (hK s hs).1 (hK s hs).2 with ⟨y, h1, h2⟩\n  rwa [hx y h1] at h2\n#align alg_hom_mk_adjoin_splits alg_hom_mk_adjoin_splits\n\n",
 "aeval_gen_minpoly":
 "theorem aeval_gen_minpoly (α : E) : aeval (adjoin_simple.gen F α) (minpoly F α) = 0 :=\n  by\n  ext\n  convert minpoly.aeval F α\n  conv in aeval α => rw [← adjoin_simple.algebra_map_gen F α]\n  exact (aeval_algebra_map_apply E (adjoin_simple.gen F α) _).symm\n#align aeval_gen_minpoly aeval_gen_minpoly\n\n",
 "adjoin_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_zero :\n    «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊥» :=\n  adjoin_simple_eq_bot_iff.mpr (zero_mem («expr⊥»))\n#align adjoin_zero adjoin_zero\n\n",
 "adjoin_univ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem adjoin_univ (F E : Type _) [Field F] [Field E] [algebra F E] : adjoin F (Set.univ : set E) = «expr⊤» :=\n  eq_top_iff.mpr <| subset_adjoin _ _\n#align adjoin_univ adjoin_univ\n\n",
 "adjoin_subset_adjoin_iff":
 "theorem adjoin_subset_adjoin_iff {F' : Type _} [Field F'] [algebra F' E] {S S' : set E} :\n    (adjoin F S : set E) ⊆ adjoin F' S' ↔ Set.range (algebra_map F E) ⊆ adjoin F' S' ∧ S ⊆ adjoin F' S' :=\n  ⟨fun h => ⟨trans (adjoin.range_algebra_map_subset _ _) h, trans (subset_adjoin _ _) h⟩, fun ⟨hF, hS⟩ =>\n    subfield.closure_le.mpr (Set.union_subset hF hS)⟩\n#align adjoin_subset_adjoin_iff adjoin_subset_adjoin_iff\n\n",
 "adjoin_simple_to_subalgebra_of_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem adjoin_simple_to_subalgebra_of_integral (hα : is_integral F α) :\n    («expr ⟮ ,⟯» F\n          \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").to_subalgebra =\n      algebra.adjoin F {α} :=\n  by\n  apply adjoin_algebraic_to_subalgebra\n  rintro x (rfl : x = α)\n  rwa [is_algebraic_iff_is_integral]\n#align adjoin_simple_to_subalgebra_of_integral adjoin_simple_to_subalgebra_of_integral\n\n",
 "adjoin_simple_le_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n@[simp]\ntheorem adjoin_simple_le_iff {K : intermediate_field F E} :\n    «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" ≤ K ↔ α ∈ K :=\n  adjoin_le_iff.trans singleton_subset_iff\n#align adjoin_simple_le_iff adjoin_simple_le_iff\n\n",
 "adjoin_simple_is_compact_element":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/-- Adjoining a single element is compact in the lattice of intermediate fields. -/\ntheorem adjoin_simple_is_compact_element (x : E) :\n    is_compact_element\n      («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n  by\n  rw [is_compact_element_iff_le_of_directed_Sup_le]\n  rintro s ⟨F₀, hF₀⟩ hs hx\n  simp only [adjoin_simple_le_iff] at hx⊢\n  let F : intermediate_field F E :=\n    { carrier := «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\" ↑E\n      add_mem' := by\n        rintro x₁ x₂ ⟨-, ⟨F₁, rfl⟩, ⟨-, ⟨hF₁, rfl⟩, hx₁⟩⟩ ⟨-, ⟨F₂, rfl⟩, ⟨-, ⟨hF₂, rfl⟩, hx₂⟩⟩\n        obtain ⟨F₃, hF₃, h₁₃, h₂₃⟩ := hs F₁ hF₁ F₂ hF₂\n        exact mem_Union_of_mem F₃ (mem_Union_of_mem hF₃ (F₃.add_mem (h₁₃ hx₁) (h₂₃ hx₂)))\n      neg_mem' := by\n        rintro x ⟨-, ⟨E, rfl⟩, ⟨-, ⟨hE, rfl⟩, hx⟩⟩\n        exact mem_Union_of_mem E (mem_Union_of_mem hE (E.neg_mem hx))\n      mul_mem' := by\n        rintro x₁ x₂ ⟨-, ⟨F₁, rfl⟩, ⟨-, ⟨hF₁, rfl⟩, hx₁⟩⟩ ⟨-, ⟨F₂, rfl⟩, ⟨-, ⟨hF₂, rfl⟩, hx₂⟩⟩\n        obtain ⟨F₃, hF₃, h₁₃, h₂₃⟩ := hs F₁ hF₁ F₂ hF₂\n        exact mem_Union_of_mem F₃ (mem_Union_of_mem hF₃ (F₃.mul_mem (h₁₃ hx₁) (h₂₃ hx₂)))\n      inv_mem' := by\n        rintro x ⟨-, ⟨E, rfl⟩, ⟨-, ⟨hE, rfl⟩, hx⟩⟩\n        exact mem_Union_of_mem E (mem_Union_of_mem hE (E.inv_mem hx))\n      algebra_map_mem' := fun x => mem_Union_of_mem F₀ (mem_Union_of_mem hF₀ (F₀.algebra_map_mem x)) }\n  have key : Sup s ≤ F := supₛ_le fun E hE => subset_Union_of_subset E (subset_Union _ hE)\n  obtain ⟨-, ⟨E, rfl⟩, -, ⟨hE, rfl⟩, hx⟩ := key hx\n  exact ⟨E, hE, hx⟩\n#align adjoin_simple_is_compact_element adjoin_simple_is_compact_element\n\n",
 "adjoin_simple_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_simple_eq_bot_iff :\n    «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊥» ↔\n      α ∈ («expr⊥» : intermediate_field F E) :=\n  by\n  rw [adjoin_eq_bot_iff]\n  exact Set.singleton_subset_iff\n#align adjoin_simple_eq_bot_iff adjoin_simple_eq_bot_iff\n\n",
 "adjoin_simple_comm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem adjoin_simple_comm (β : E) :\n    («expr ⟮ ,⟯» («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n        F =\n      («expr ⟮ ,⟯» («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n        F :=\n  adjoin_adjoin_comm _ _ _\n#align adjoin_simple_comm adjoin_simple_comm\n\n",
 "adjoin_simple_adjoin_simple":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem adjoin_simple_adjoin_simple (β : E) :\n    («expr ⟮ ,⟯» («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n            \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\").restrict_scalars\n        F =\n      «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" :=\n  adjoin_adjoin_left _ _ _\n#align adjoin_simple_adjoin_simple adjoin_simple_adjoin_simple\n\n",
 "adjoin_root_set_is_splitting_field":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem adjoin_root_set_is_splitting_field {p : polynomial F} (hp : p.splits (algebra_map F E)) :\n    p.is_splitting_field F (adjoin F (p.root_set E)) :=\n  is_splitting_field_iff.mpr ⟨splits_of_splits hp fun x hx => subset_adjoin F (p.root_set E) hx, rfl⟩\n#align adjoin_root_set_is_splitting_field adjoin_root_set_is_splitting_field\n\n",
 "adjoin_root_equiv_adjoin_apply_root":
 "theorem adjoin_root_equiv_adjoin_apply_root (h : is_integral F α) :\n    adjoin_root_equiv_adjoin F h (adjoin_root.root (minpoly F α)) = adjoin_simple.gen F α :=\n  adjoin_root.lift_root (aeval_gen_minpoly F α)\n#align adjoin_root_equiv_adjoin_apply_root adjoin_root_equiv_adjoin_apply_root\n\n",
 "adjoin_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_one :\n    «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊥» :=\n  adjoin_simple_eq_bot_iff.mpr (one_mem («expr⊥»))\n#align adjoin_one adjoin_one\n\n",
 "adjoin_nat":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_nat (n : ℕ) :\n    «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊥» :=\n  adjoin_simple_eq_bot_iff.mpr (coe_nat_mem («expr⊥») n)\n#align adjoin_nat adjoin_nat\n\n",
 "adjoin_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem adjoin_map {E' : Type _} [Field E'] [algebra F E'] (f : «expr →ₐ[ ] » E F E') :\n    (adjoin F S).map f = adjoin F («expr '' » f S) := by\n  ext x\n  show\n    x ∈ (subfield.closure (Set.range (algebra_map F E) ∪ S)).map (f : «expr →+* » E E') ↔\n      x ∈ subfield.closure (Set.range (algebra_map F E') ∪ «expr '' » f S)\n  rw [ring_hom.map_field_closure, Set.image_union, ← Set.range_comp, ← RingHom.coe_comp, f.comp_algebra_map]\n  rfl\n#align adjoin_map adjoin_map\n\n",
 "adjoin_le_subfield":
 "/-- If `K` is a field with `F ⊆ K` and `S ⊆ K` then `adjoin F S ≤ K`. -/\ntheorem adjoin_le_subfield {K : subfield E} (HF : Set.range (algebra_map F E) ⊆ K) (HS : S ⊆ K) :\n    (adjoin F S).to_subfield ≤ K := by\n  apply subfield.closure_le.mpr\n  rw [Set.union_subset_iff]\n  exact ⟨HF, HS⟩\n#align adjoin_le_subfield adjoin_le_subfield\n\n",
 "adjoin_le_iff":
 "/-\nCopyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning, Patrick Lutz\n-/\n@[simp]\ntheorem adjoin_le_iff {S : set E} {T : intermediate_field F E} : adjoin F S ≤ T ↔ S ≤ T :=\n  ⟨fun H => le_trans (le_trans (Set.subset_union_right _ _) subfield.subset_closure) H, fun H =>\n    (@subfield.closure_le E _ (Set.range (algebra_map F E) ∪ S) T.to_subfield).mpr\n      (Set.union_subset (intermediate_field.set_range_subset T) H)⟩\n#align adjoin_le_iff adjoin_le_iff\n\n",
 "adjoin_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_int (n : ℤ) :\n    «expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\" = «expr⊥» :=\n  adjoin_simple_eq_bot_iff.mpr (coe_int_mem («expr⊥») n)\n#align adjoin_int adjoin_int\n\n",
 "adjoin_insert_adjoin":
 "@[simp]\ntheorem adjoin_insert_adjoin (x : E) : adjoin F (insert x (adjoin F S : set E)) = adjoin F (insert x S) :=\n  le_antisymm\n    (adjoin_le_iff.mpr\n      (Set.insert_subset.mpr\n        ⟨subset_adjoin _ _ (Set.mem_insert _ _),\n          adjoin_le_iff.mpr (subset_adjoin_of_subset_right _ _ (Set.subset_insert _ _))⟩))\n    (adjoin.mono _ _ _ (Set.insert_subset_insert (subset_adjoin _ _)))\n#align adjoin_insert_adjoin adjoin_insert_adjoin\n\n",
 "adjoin_induction":
 "@[elab_as_elim]\ntheorem adjoin_induction {s : set E} {p : E → Prop} {x} (h : x ∈ adjoin F s) (Hs : ∀ x ∈ s, p x)\n    (Hmap : ∀ x, p (algebra_map F E x)) (Hadd : ∀ x y, p x → p y → p (x + y)) (Hneg : ∀ x, p x → p (-x))\n    (Hinv : ∀ x, p x → p x⁻¹) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=\n  subfield.closure_induction h (fun x hx => or.cases_on hx (fun ⟨x, hx⟩ => hx ▸ Hmap x) (Hs x))\n    ((algebra_map F E).map_one ▸ Hmap 1) Hadd Hneg Hinv Hmul\n#align adjoin_induction adjoin_induction\n\n",
 "adjoin_finset_is_compact_element":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/-- Adjoining a finite subset is compact in the lattice of intermediate fields. -/\ntheorem adjoin_finset_is_compact_element (S : Finset E) : is_compact_element (adjoin F S : intermediate_field F E) :=\n  by\n  have key :\n    adjoin F ↑S =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n        («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\") :=\n    le_antisymm\n      (adjoin_le_iff.mpr fun x hx =>\n        set_like.mem_coe.mpr (adjoin_simple_le_iff.mp (le_supᵢ_of_le x (le_supᵢ_of_le hx le_rfl))))\n      (supᵢ_le fun x => supᵢ_le fun hx => adjoin_simple_le_iff.mpr (subset_adjoin F S hx))\n  rw [key, ← finset.sup_eq_supr]\n  exact finset_sup_compact_of_compact S fun x hx => adjoin_simple_is_compact_element x\n#align adjoin_finset_is_compact_element adjoin_finset_is_compact_element\n\n",
 "adjoin_finite_is_compact_element":
 "/-- Adjoining a finite subset is compact in the lattice of intermediate fields. -/\ntheorem adjoin_finite_is_compact_element {S : set E} (h : S.finite) : is_compact_element (adjoin F S) :=\n  finite.coe_to_finset h ▸ adjoin_finset_is_compact_element h.to_finset\n#align adjoin_finite_is_compact_element adjoin_finite_is_compact_element\n\n",
 "adjoin_eq_range_algebra_map_adjoin":
 "theorem adjoin_eq_range_algebra_map_adjoin : (adjoin F S : set E) = Set.range (algebra_map (adjoin F S) E) :=\n  Subtype.range_coe.symm\n#align adjoin_eq_range_algebra_map_adjoin adjoin_eq_range_algebra_map_adjoin\n\n",
 "adjoin_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_eq_bot_iff : adjoin F S = «expr⊥» ↔ S ⊆ («expr⊥» : intermediate_field F E) :=\n  by\n  rw [eq_bot_iff, adjoin_le_iff]\n  rfl\n#align adjoin_eq_bot_iff adjoin_eq_bot_iff\n\n",
 "adjoin_eq_algebra_adjoin":
 "theorem adjoin_eq_algebra_adjoin (inv_mem : ∀ x ∈ algebra.adjoin F S, x⁻¹ ∈ algebra.adjoin F S) :\n    (adjoin F S).to_subalgebra = algebra.adjoin F S :=\n  le_antisymm\n    (show\n      adjoin F S ≤\n        { algebra.adjoin F S with\n          neg_mem' := fun x => (algebra.adjoin F S).neg_mem\n          inv_mem' := inv_mem }\n      from adjoin_le_iff.mpr algebra.subset_adjoin)\n    (algebra_adjoin_le_adjoin _ _)\n#align adjoin_eq_algebra_adjoin adjoin_eq_algebra_adjoin\n\n",
 "adjoin_empty":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem adjoin_empty (F E : Type _) [Field F] [Field E] [algebra F E] : adjoin F (∅ : set E) = «expr⊥» :=\n  eq_bot_iff.mpr (adjoin_le_iff.mpr (Set.empty_subset _))\n#align adjoin_empty adjoin_empty\n\n",
 "adjoin_contains_field_as_subfield":
 "theorem adjoin_contains_field_as_subfield (F : subfield E) : (F : set E) ⊆ adjoin F S := fun x hx =>\n  adjoin.algebra_map_mem F S ⟨x, hx⟩\n#align adjoin_contains_field_as_subfield adjoin_contains_field_as_subfield\n\n",
 "adjoin_algebraic_to_subalgebra":
 "theorem adjoin_algebraic_to_subalgebra {S : set E} (hS : ∀ x ∈ S, is_algebraic F x) :\n    (intermediate_field.adjoin F S).to_subalgebra = algebra.adjoin F S :=\n  by\n  simp only [is_algebraic_iff_is_integral] at hS\n  have : algebra.is_integral F (algebra.adjoin F S) := by\n    rwa [← le_integral_closure_iff_is_integral, algebra.adjoin_le_iff]\n  have := is_field_of_is_integral_of_is_field' this (Field.toIsField F)\n  rw [← ((algebra.adjoin F S).to_intermediate_field' this).eq_adjoin_of_eq_algebra_adjoin F S] <;> rfl\n#align adjoin_algebraic_to_subalgebra adjoin_algebraic_to_subalgebra\n\n",
 "adjoin_adjoin_left":
 "/-- `F[S][T] = F[S ∪ T]` -/\ntheorem adjoin_adjoin_left (T : set E) : (adjoin (adjoin F S) T).restrict_scalars _ = adjoin F (S ∪ T) :=\n  by\n  rw [SetLike.ext'_iff]\n  change ↑(adjoin (adjoin F S) T) = _\n  apply Set.eq_of_subset_of_subset <;> rw [adjoin_subset_adjoin_iff] <;> constructor\n  · rintro _ ⟨⟨x, hx⟩, rfl⟩\n    exact adjoin.mono _ _ _ (Set.subset_union_left _ _) hx\n  · exact subset_adjoin_of_subset_right _ _ (Set.subset_union_right _ _)\n  · exact subset_adjoin_of_subset_left _ (adjoin.range_algebra_map_subset _ _)\n  · exact Set.union_subset (subset_adjoin_of_subset_left _ (subset_adjoin _ _)) (subset_adjoin _ _)\n#align adjoin_adjoin_left adjoin_adjoin_left\n\n",
 "adjoin_adjoin_comm":
 "/-- `F[S][T] = F[T][S]` -/\ntheorem adjoin_adjoin_comm (T : set E) :\n    (adjoin (adjoin F S) T).restrict_scalars F = (adjoin (adjoin F T) S).restrict_scalars F := by\n  rw [adjoin_adjoin_left, adjoin_adjoin_left, Set.union_comm]\n#align adjoin_adjoin_comm adjoin_adjoin_comm\n\n",
 "Inf_to_subfield":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_to_subfield (S : set (intermediate_field F E)) : (infₛ S).to_subfield = infₛ («expr '' » to_subfield S) :=\n  SetLike.coe_injective <| by simp [Set.unionₛ_image]\n#align Inf_to_subfield Inf_to_subfield\n\n",
 "Inf_to_subalgebra":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_to_subalgebra (S : set (intermediate_field F E)) :\n    (infₛ S).to_subalgebra = infₛ («expr '' » to_subalgebra S) :=\n  SetLike.coe_injective <| by simp [Set.unionₛ_image]\n#align Inf_to_subalgebra Inf_to_subalgebra\n\n"}