{"splits_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- Every polynomial splits in the field extension `f : K →+* k` if `K` is algebraically closed.\n\nSee also `is_alg_closed.splits_codomain` for the case where `k` is algebraically closed.\n-/\ntheorem is_alg_closed.splits_domain {k K : Type _} [Field k] [is_alg_closed k] [Field K] {f : «expr →+* » k K}\n    (p : polynomial k) : p.splits f :=\n  polynomial.splits_of_splits_id _ <| is_alg_closed.splits _\n#align is_alg_closed.splits_domain is_alg_closed.splits_domain\n\n",
 "splits_codomain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n/-- Every polynomial splits in the field extension `f : K →+* k` if `k` is algebraically closed.\n\nSee also `is_alg_closed.splits_domain` for the case where `K` is algebraically closed.\n-/\ntheorem is_alg_closed.splits_codomain {k K : Type _} [Field k] [is_alg_closed k] [Field K] {f : «expr →+* » K k}\n    (p : polynomial K) : p.splits f := by\n  convert is_alg_closed.splits (p.map f)\n  simp [splits_map_iff]\n#align is_alg_closed.splits_codomain is_alg_closed.splits_codomain\n\n",
 "roots_eq_zero_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_eq_zero_iff [is_alg_closed k] {p : polynomial k} : p.roots = 0 ↔ p = polynomial.C (p.coeff 0) :=\n  by\n  refine' ⟨fun h => _, fun hp => by rw [hp, roots_C]⟩\n  cases' le_or_lt (degree p) 0 with hd hd\n  · exact eq_C_of_degree_le_zero hd\n  · obtain ⟨z, hz⟩ := is_alg_closed.exists_root p hd.ne'\n    rw [← mem_roots (ne_zero_of_degree_gt hd), h] at hz\n    simpa using hz\n#align roots_eq_zero_iff roots_eq_zero_iff\n\n",
 "range_eval_eq_root_set_minpoly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- Let `A` be an algebraically closed field and let `x ∈ K`, with `K/F` an algebraic extension\n  of fields. Then the images of `x` by the `F`-algebra morphisms from `K` to `A` are exactly\n  the roots in `A` of the minimal polynomial of `x` over `F`. -/\ntheorem algebra.is_algebraic.range_eval_eq_root_set_minpoly {F K} (A) [Field F] [Field K] [Field A] [is_alg_closed A]\n    [algebra F K] (hK : algebra.is_algebraic F K) [algebra F A] (x : K) :\n    (Set.range fun ψ : «expr →ₐ[ ] » K F A => ψ x) = (minpoly F x).root_set A :=\n  by\n  have := algebra.is_algebraic_iff_is_integral.1 hK\n  ext a; rw [mem_root_set_of_ne (minpoly.ne_zero (this x))] <;> [skip, infer_instance]\n  refine' ⟨_, fun ha => _⟩\n  · rintro ⟨ψ, rfl⟩\n    rw [aeval_alg_hom_apply ψ x, minpoly.aeval, map_zero]\n  let Fx := adjoin_root (minpoly F x)\n  have hx : aeval x (minpoly F x) = 0 := minpoly.aeval F x\n  letI : algebra Fx A := (adjoin_root.lift (algebra_map F A) a ha).to_algebra\n  letI : algebra Fx K := (adjoin_root.lift (algebra_map F K) x hx).to_algebra\n  haveI : IsScalarTower F Fx A := is_scalar_tower.of_ring_hom (adjoin_root.lift_hom _ a ha)\n  haveI : IsScalarTower F Fx K := is_scalar_tower.of_ring_hom (adjoin_root.lift_hom _ x hx)\n  haveI : fact (Irreducible <| minpoly F x) := ⟨minpoly.irreducible <| this x⟩\n  let ψ₀ : «expr →ₐ[ ] » K Fx A := is_alg_closed.lift (algebra.is_algebraic_of_larger_base F Fx hK)\n  exact\n    ⟨ψ₀.restrict_scalars F,\n      (congr_arg ψ₀ (adjoin_root.lift_root hx).symm).trans <| (ψ₀.commutes _).trans <| adjoin_root.lift_root ha⟩\n#align algebra.is_algebraic.range_eval_eq_root_set_minpoly algebra.is_algebraic.range_eval_eq_root_set_minpoly\n\n",
 "of_exists_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem of_exists_root (H : ∀ p : polynomial k, p.monic → Irreducible p → ∃ x, p.eval x = 0) : is_alg_closed k :=\n  ⟨fun p =>\n    or.inr fun q hq hqp =>\n      have : Irreducible (q * C (leading_coeff q)⁻¹) :=\n        by\n        rw [← coe_norm_unit_of_ne_zero hq.ne_zero]\n        exact (associated_normalize _).irreducible hq\n      let ⟨x, hx⟩ := H (q * C (leading_coeff q)⁻¹) (monic_mul_leading_coeff_inv hq.ne_zero) this\n      degree_mul_leading_coeff_inv q hq.ne_zero ▸ degree_eq_one_of_irreducible_of_root this hx⟩\n#align of_exists_root of_exists_root\n\n",
 "maximal_subfield_with_hom_is_maximal":
 "theorem maximal_subfield_with_hom_is_maximal :\n    ∀ N : subfield_with_hom K L M hL, maximal_subfield_with_hom M hL ≤ N → N ≤ maximal_subfield_with_hom M hL :=\n  Classical.choose_spec (exists_maximal_subfield_with_hom M hL)\n#align maximal_subfield_with_hom_is_maximal maximal_subfield_with_hom_is_maximal\n\n",
 "maximal_subfield_with_hom_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem maximal_subfield_with_hom_eq_top : (maximal_subfield_with_hom M hL).carrier = «expr⊤» :=\n  by\n  rw [eq_top_iff]\n  intro x _\n  let p := minpoly K x\n  let N : subalgebra K L := (maximal_subfield_with_hom M hL).carrier\n  letI : Field N := (subalgebra.is_field_of_algebraic N hL).to_field\n  letI : algebra N M := (maximal_subfield_with_hom M hL).emb.to_ring_hom.to_algebra\n  cases'\n    is_alg_closed.exists_aeval_eq_zero M (minpoly N x)\n      (ne_of_gt\n        (minpoly.degree_pos (is_algebraic_iff_is_integral.1 (algebra.is_algebraic_of_larger_base _ _ hL x)))) with\n    y hy\n  let O : subalgebra N L := algebra.adjoin N {(x : L)}\n  let larger_emb :=\n    (adjoin_root.lift_hom (minpoly N x) y hy).comp (alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly N x).to_alg_hom\n  have hNO : N ≤ O.restrict_scalars K := by\n    intro z hz\n    show algebra_map N L ⟨z, hz⟩ ∈ O\n    exact O.algebra_map_mem _\n  let O' : subfield_with_hom K L M hL :=\n    { carrier := O.restrict_scalars K\n      emb := larger_emb.restrict_scalars K }\n  have hO' : maximal_subfield_with_hom M hL ≤ O' := by\n    refine' ⟨hNO, _⟩\n    intro z\n    show O'.emb (algebra_map N O z) = algebra_map N M z\n    simp only [O', restrict_scalars_apply, alg_hom.commutes]\n  refine' (maximal_subfield_with_hom_is_maximal M hL O' hO').fst _\n  exact algebra.subset_adjoin (Set.mem_singleton x)\n#align maximal_subfield_with_hom_eq_top maximal_subfield_with_hom_eq_top\n\n",
 "maximal_subfield_with_hom_chain_bounded":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\ntheorem maximal_subfield_with_hom_chain_bounded (c : set (subfield_with_hom K L M hL)) (hc : IsChain (· ≤ ·) c) :\n    ∃ ub : subfield_with_hom K L M hL, ∀ N, N ∈ c → N ≤ ub :=\n  if hcn : c.nonempty then\n    let ub : subfield_with_hom K L M hL :=\n      haveI : nonempty c := Set.Nonempty.to_subtype hcn\n      { carrier :=\n          «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\"\n            (i : subfield_with_hom K L M hL).carrier\n        emb :=\n          subalgebra.supr_lift (fun i : c => (i : subfield_with_hom K L M hL).carrier)\n            (fun i j =>\n              let ⟨k, hik, hjk⟩ := directedOn_iff_directed.1 hc.directed_on i j\n              ⟨k, hik.fst, hjk.fst⟩)\n            (fun i => (i : subfield_with_hom K L M hL).emb)\n            (by\n              intro i j h\n              ext x\n              cases' hc.total i.prop j.prop with hij hji\n              · simp [← hij.snd x]\n              ·\n                erw [alg_hom.comp_apply, ← hji.snd (inclusion h x), inclusion_inclusion, inclusion_self,\n                  alg_hom.id_apply x])\n            _ rfl }\n    ⟨ub, fun N hN =>\n      ⟨(le_supᵢ (fun i : c => (i : subfield_with_hom K L M hL).carrier) ⟨N, hN⟩ : _),\n        by\n        intro x\n        simp [ub]\n        rfl⟩⟩\n  else by\n    rw [Set.not_nonempty_iff_eq_empty] at hcn\n    simp [hcn]\n#align maximal_subfield_with_hom_chain_bounded maximal_subfield_with_hom_chain_bounded\n\n",
 "le_def":
 "/- In this section, the homomorphism from any algebraic extension into an algebraically\n  closed extension is proven to exist. The assumption that M is algebraically closed could probably\n  easily be switched to an assumption that M contains all the roots of polynomials in K -/\ntheorem le_def : E₁ ≤ E₂ ↔ ∃ h : E₁.carrier ≤ E₂.carrier, ∀ x, E₂.emb (inclusion h x) = E₁.emb x :=\n  iff.rfl\n#align le_def le_def\n\n",
 "is_algebraic":
 "private theorem fraction_ring.is_algebraic :\n    letI : IsDomain R := (no_zero_smul_divisors.algebra_map_injective R S).is_domain _\n    algebra.is_algebraic (fraction_ring R) (fraction_ring S) :=\n  by\n  intro inst x\n  exact\n    (is_fraction_ring.is_algebraic_iff R (fraction_ring R) (fraction_ring S)).1\n      ((is_fraction_ring.is_algebraic_iff' R S (fraction_ring S)).1 hS x)\n#align fraction_ring.is_algebraic fraction_ring.is_algebraic\n\n",
 "is_alg_closure_iff":
 "theorem is_alg_closure_iff (K : Type v) [Field K] [algebra k K] :\n    is_alg_closure k K ↔ is_alg_closed K ∧ algebra.is_algebraic k K :=\n  ⟨fun h => ⟨h.1, h.2⟩, fun h => ⟨h.1, h.2⟩⟩\n#align is_alg_closure_iff is_alg_closure_iff\n\n",
 "exists_root":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_root [is_alg_closed k] (p : polynomial k) (hp : p.degree ≠ 0) : ∃ x, is_root p x :=\n  exists_root_of_splits _ (is_alg_closed.splits p) hp\n#align exists_root exists_root\n\n",
 "exists_pow_nat_eq":
 "theorem exists_pow_nat_eq [is_alg_closed k] (x : k) {n : ℕ} (hn : 0 < n) : ∃ z, z ^ n = x :=\n  by\n  rcases exists_root (X ^ n - C x) _ with ⟨z, hz⟩; swap\n  · rw [degree_X_pow_sub_C hn x]\n    exact ne_of_gt (WithBot.coe_lt_coe.2 hn)\n  use z\n  simp only [eval_C, eval_X, eval_pow, eval_sub, is_root.def] at hz\n  exact sub_eq_zero.1 hz\n#align exists_pow_nat_eq exists_pow_nat_eq\n\n",
 "exists_maximal_subfield_with_hom":
 "theorem exists_maximal_subfield_with_hom : ∃ E : subfield_with_hom K L M hL, ∀ N, E ≤ N → N ≤ E :=\n  exists_maximal_of_chains_bounded maximal_subfield_with_hom_chain_bounded fun _ _ _ => le_trans\n#align exists_maximal_subfield_with_hom exists_maximal_subfield_with_hom\n\n",
 "exists_eval₂_eq_zero_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_eval₂_eq_zero_of_injective {R : Type _} [Ring R] [is_alg_closed k] (f : «expr →+* » R k)\n    (hf : function.injective f) (p : polynomial R) (hp : p.degree ≠ 0) : ∃ x, p.eval₂ f x = 0 :=\n  let ⟨x, hx⟩ := exists_root (p.map f) (by rwa [degree_map_eq_of_injective hf])\n  ⟨x, by rwa [eval₂_eq_eval_map, ← is_root]⟩\n#align exists_eval₂_eq_zero_of_injective exists_eval₂_eq_zero_of_injective\n\n",
 "exists_eval₂_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_eval₂_eq_zero {R : Type _} [Field R] [is_alg_closed k] (f : «expr →+* » R k) (p : polynomial R)\n    (hp : p.degree ≠ 0) : ∃ x, p.eval₂ f x = 0 :=\n  exists_eval₂_eq_zero_of_injective f f.injective p hp\n#align exists_eval₂_eq_zero exists_eval₂_eq_zero\n\n",
 "exists_eq_mul_self":
 "theorem exists_eq_mul_self [is_alg_closed k] (x : k) : ∃ z, x = z * z :=\n  by\n  rcases exists_pow_nat_eq x zero_lt_two with ⟨z, rfl⟩\n  exact ⟨z, sq z⟩\n#align exists_eq_mul_self exists_eq_mul_self\n\n",
 "exists_aeval_eq_zero_of_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_aeval_eq_zero_of_injective {R : Type _} [CommRing R] [is_alg_closed k] [algebra R k]\n    (hinj : function.injective (algebra_map R k)) (p : polynomial R) (hp : p.degree ≠ 0) : ∃ x : k, aeval x p = 0 :=\n  exists_eval₂_eq_zero_of_injective (algebra_map R k) hinj p hp\n#align exists_aeval_eq_zero_of_injective exists_aeval_eq_zero_of_injective\n\n",
 "exists_aeval_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem exists_aeval_eq_zero {R : Type _} [Field R] [is_alg_closed k] [algebra R k] (p : polynomial R)\n    (hp : p.degree ≠ 0) : ∃ x : k, aeval x p = 0 :=\n  exists_eval₂_eq_zero (algebra_map R k) p hp\n#align exists_aeval_eq_zero exists_aeval_eq_zero\n\n",
 "equiv_of_equiv_symm_comp_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem equiv_of_equiv_symm_comp_algebra_map (hSR : «expr ≃+* » S R) :\n    ((equiv_of_equiv L M hSR).symm : «expr →+* » M L).comp (algebra_map R M) = (algebra_map S L).comp hSR.symm :=\n  RingHom.ext_iff.2 (equiv_of_equiv_symm_algebra_map L M hSR)\n#align equiv_of_equiv_symm_comp_algebra_map equiv_of_equiv_symm_comp_algebra_map\n\n",
 "equiv_of_equiv_symm_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem equiv_of_equiv_symm_algebra_map (hSR : «expr ≃+* » S R) (r : R) :\n    (equiv_of_equiv L M hSR).symm (algebra_map R M r) = algebra_map S L (hSR.symm r) :=\n  (equiv_of_equiv L M hSR).injective (by simp)\n#align equiv_of_equiv_symm_algebra_map equiv_of_equiv_symm_algebra_map\n\n",
 "equiv_of_equiv_comp_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n@[simp]\ntheorem equiv_of_equiv_comp_algebra_map (hSR : «expr ≃+* » S R) :\n    (↑(equiv_of_equiv L M hSR) : «expr →+* » L M).comp (algebra_map S L) = (algebra_map R M).comp hSR :=\n  (equiv_of_equiv_aux L M hSR).2\n#align equiv_of_equiv_comp_algebra_map equiv_of_equiv_comp_algebra_map\n\n",
 "equiv_of_equiv_algebra_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n@[simp]\ntheorem equiv_of_equiv_algebra_map (hSR : «expr ≃+* » S R) (s : S) :\n    equiv_of_equiv L M hSR (algebra_map S L s) = algebra_map R M (hSR s) :=\n  RingHom.ext_iff.1 (equiv_of_equiv_comp_algebra_map L M hSR) s\n#align equiv_of_equiv_algebra_map equiv_of_equiv_algebra_map\n\n",
 "degree_eq_one_of_irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem degree_eq_one_of_irreducible [is_alg_closed k] {p : polynomial k} (hp : Irreducible p) : p.degree = 1 :=\n  degree_eq_one_of_irreducible_of_splits hp (is_alg_closed.splits_codomain _)\n#align degree_eq_one_of_irreducible degree_eq_one_of_irreducible\n\n",
 "compat":
 "theorem compat (h : E₁ ≤ E₂) : ∀ x, E₂.emb (inclusion h.fst x) = E₁.emb x :=\n  by\n  rw [le_def] at h\n  cases h\n  assumption\n#align compat compat\n\n",
 "algebra_map_surjective_of_is_integral'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem algebra_map_surjective_of_is_integral' {k K : Type _} [Field k] [CommRing K] [IsDomain K] [hk : is_alg_closed k]\n    (f : «expr →+* » k K) (hf : f.is_integral) : function.surjective f :=\n  @algebra_map_surjective_of_is_integral k K _ _ _ _ f.to_algebra hf\n#align algebra_map_surjective_of_is_integral' algebra_map_surjective_of_is_integral'\n\n",
 "algebra_map_surjective_of_is_integral":
 "theorem algebra_map_surjective_of_is_integral {k K : Type _} [Field k] [Ring K] [IsDomain K] [hk : is_alg_closed k]\n    [algebra k K] (hf : algebra.is_integral k K) : function.surjective (algebra_map k K) :=\n  by\n  refine' fun x => ⟨-(minpoly k x).coeff 0, _⟩\n  have hq : (minpoly k x).leading_coeff = 1 := minpoly.monic (hf x)\n  have h : (minpoly k x).degree = 1 := degree_eq_one_of_irreducible k (minpoly.irreducible (hf x))\n  have : aeval x (minpoly k x) = 0 := minpoly.aeval k x\n  rw [eq_X_add_C_of_degree_eq_one h, hq, C_1, one_mul, aeval_add, aeval_X, aeval_C, add_eq_zero_iff_eq_neg] at this\n  exact (RingHom.map_neg (algebra_map k K) ((minpoly k x).coeff 0)).symm ▸ this.symm\n#align algebra_map_surjective_of_is_integral algebra_map_surjective_of_is_integral\n\n",
 "algebra_map_surjective_of_is_algebraic":
 "theorem algebra_map_surjective_of_is_algebraic {k K : Type _} [Field k] [Ring K] [IsDomain K] [hk : is_alg_closed k]\n    [algebra k K] (hf : algebra.is_algebraic k K) : function.surjective (algebra_map k K) :=\n  algebra_map_surjective_of_is_integral (algebra.is_algebraic_iff_is_integral.mp hf)\n#align algebra_map_surjective_of_is_algebraic algebra_map_surjective_of_is_algebraic\n\n"}