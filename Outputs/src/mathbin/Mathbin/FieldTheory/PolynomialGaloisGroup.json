{"splits_ℚ_ℂ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\ntheorem splits_ℚ_ℂ {p : polynomial (exprℚ)} : Fact (p.splits (algebraMap (exprℚ) (exprℂ))) :=\n  ⟨is_alg_closed.splits_codomain p⟩\n#align splits_ℚ_ℂ splits_ℚ_ℂ\n\n",
 "splits_in_splitting_field_of_comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- `p` splits in the splitting field of `p ∘ q`, for `q` non-constant. -/\ntheorem splits_in_splitting_field_of_comp (hq : q.nat_degree ≠ 0) :\n    p.splits (algebraMap F (p.comp q).splitting_field) :=\n  by\n  let P : polynomial F → Prop := fun r => r.splits (algebraMap F (r.comp q).splitting_field)\n  have key1 : ∀ {r : polynomial F}, Irreducible r → P r :=\n    by\n    intro r hr\n    by_cases hr' : nat_degree r = 0\n    · exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one)\n    obtain ⟨x, hx⟩ :=\n      exists_root_of_splits _ (splitting_field.splits (r.comp q)) fun h =>\n        hr' ((mul_eq_zero.mp (nat_degree_comp.symm.trans (nat_degree_eq_of_degree_eq_some h))).resolve_right hq)\n    rw [← aeval_def, aeval_comp] at hx\n    have h_normal : normal F (r.comp q).splitting_field := splitting_field.normal (r.comp q)\n    have qx_int := normal.is_integral h_normal (aeval x q)\n    exact\n      splits_of_splits_of_dvd _ (minpoly.ne_zero qx_int) (normal.splits h_normal _)\n        ((minpoly.irreducible qx_int).dvd_symm hr (minpoly.dvd F _ hx))\n  have key2 : ∀ {p₁ p₂ : polynomial F}, P p₁ → P p₂ → P (p₁ * p₂) :=\n    by\n    intro p₁ p₂ hp₁ hp₂\n    by_cases h₁ : p₁.comp q = 0\n    · cases' comp_eq_zero_iff.mp h₁ with h h\n      · rw [h, MulZeroClass.zero_mul]\n        exact splits_zero _\n      · exact false.rec _ (hq (by rw [h.2, nat_degree_C]))\n    by_cases h₂ : p₂.comp q = 0\n    · cases' comp_eq_zero_iff.mp h₂ with h h\n      · rw [h, MulZeroClass.mul_zero]\n        exact splits_zero _\n      · exact false.rec _ (hq (by rw [h.2, nat_degree_C]))\n    have key := mul_splits_in_splitting_field_of_mul h₁ h₂ hp₁ hp₂\n    rwa [← mul_comp] at key\n  exact\n    WfDvdMonoid.induction_on_irreducible p (splits_zero _) (fun _ => splits_of_is_unit _) fun _ _ _ h => key2 (key1 h)\n#align splits_in_splitting_field_of_comp splits_in_splitting_field_of_comp\n\n",
 "restrict_surjective":
 "-- The `algebra p.splitting_field E` instance above behaves badly when\n-- `E := p.splitting_field`, since it may result in a unification problem\n-- `is_splitting_field.lift.to_ring_hom.to_algebra =?= algebra.id`,\n-- which takes an extremely long time to resolve, causing timeouts.\n-- Since we don't really care about this definition, marking it as irreducible\n-- causes that unification to error out early.\ntheorem restrict_surjective [Fact (p.splits (algebraMap F E))] [normal F E] : function.surjective (restrict p E) :=\n  alg_equiv.restrict_normal_hom_surjective E\n#align restrict_surjective restrict_surjective\n\n",
 "restrict_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `polynomial.gal.restrict p E` is compatible with `polynomial.gal.gal_action p E`. -/\n@[simp]\ntheorem restrict_smul [Fact (p.splits (algebraMap F E))] (ϕ : «expr ≃ₐ[ ] » E F E) (x : rootSet p E) :\n    ↑(«expr • » (restrict p E ϕ) x) = ϕ x :=\n  by\n  let ψ := AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F p.splitting_field E)\n  change ↑(ψ (ψ.symm _)) = ϕ x\n  rw [AlgEquiv.apply_symm_apply ψ]\n  change ϕ (roots_equiv_roots p E ((roots_equiv_roots p E).symm x)) = ϕ x\n  rw [Equiv.apply_symm_apply (roots_equiv_roots p E)]\n#align restrict_smul restrict_smul\n\n",
 "restrict_prod_injective":
 "/-- `polynomial.gal.restrict_prod` is actually a subgroup embedding. -/\ntheorem restrict_prod_injective : function.injective (restrict_prod p q) :=\n  by\n  by_cases hpq : p * q = 0\n  · have : Unique (p * q).gal := by\n      rw [hpq]\n      infer_instance\n    exact fun f g h => Eq.trans (Unique.eq_default f) (Unique.eq_default g).symm\n  intro f g hfg\n  dsimp only [restrict_prod, restrict_dvd] at hfg\n  simp only [dif_neg hpq, MonoidHom.prod_apply, Prod.mk.inj_iff] at hfg\n  ext (x hx)\n  rw [root_set, Polynomial.map_mul, Polynomial.roots_mul] at hx\n  cases' multiset.mem_add.mp (multiset.mem_to_finset.mp hx) with h h\n  · haveI : Fact (p.splits (algebraMap F (p * q).splitting_field)) :=\n      ⟨splits_of_splits_of_dvd _ hpq (splitting_field.splits (p * q)) (dvd_mul_right p q)⟩\n    have key :\n      x =\n        algebraMap p.splitting_field (p * q).splitting_field\n          ((roots_equiv_roots p _).inv_fun ⟨x, multiset.mem_to_finset.mpr h⟩) :=\n      subtype.ext_iff.mp (Equiv.apply_symm_apply (roots_equiv_roots p _) ⟨x, _⟩).symm\n    rw [key, ← alg_equiv.restrict_normal_commutes, ← alg_equiv.restrict_normal_commutes]\n    exact congr_arg _ (alg_equiv.ext_iff.mp hfg.1 _)\n  · haveI : Fact (q.splits (algebraMap F (p * q).splitting_field)) :=\n      ⟨splits_of_splits_of_dvd _ hpq (splitting_field.splits (p * q)) (dvd_mul_left q p)⟩\n    have key :\n      x =\n        algebraMap q.splitting_field (p * q).splitting_field\n          ((roots_equiv_roots q _).inv_fun ⟨x, multiset.mem_to_finset.mpr h⟩) :=\n      subtype.ext_iff.mp (Equiv.apply_symm_apply (roots_equiv_roots q _) ⟨x, _⟩).symm\n    rw [key, ← alg_equiv.restrict_normal_commutes, ← alg_equiv.restrict_normal_commutes]\n    exact congr_arg _ (alg_equiv.ext_iff.mp hfg.2 _)\n  · rwa [ne.def, mul_eq_zero, map_eq_zero, map_eq_zero, ← mul_eq_zero]\n#align restrict_prod_injective restrict_prod_injective\n\n",
 "restrict_dvd_surjective":
 "theorem restrict_dvd_surjective (hpq : p ∣ q) (hq : q ≠ 0) : function.surjective (restrict_dvd hpq) := by\n  simp only [restrict_dvd, dif_neg hq, restrict_surjective]\n#align restrict_dvd_surjective restrict_dvd_surjective\n\n",
 "restrict_comp_surjective":
 "theorem restrict_comp_surjective (hq : q.nat_degree ≠ 0) : function.surjective (restrict_comp p q hq) := by\n  simp only [restrict_comp, restrict_surjective]\n#align restrict_comp_surjective restrict_comp_surjective\n\n",
 "prime_degree_dvd_card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⟮ ,⟯» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯» -/\ntheorem prime_degree_dvd_card [CharZero F] (p_irr : Irreducible p) (p_deg : p.nat_degree.prime) :\n    p.nat_degree ∣ Fintype.card p.gal :=\n  by\n  rw [gal.card_of_separable p_irr.separable]\n  have hp : p.degree ≠ 0 := fun h => Nat.Prime.ne_zero p_deg (nat_degree_eq_zero_iff_degree_le_zero.mpr (le_of_eq h))\n  let α : p.splitting_field := root_of_splits (algebraMap F p.splitting_field) (splitting_field.splits p) hp\n  have hα : is_integral F α := algebra.is_integral_of_finite _ _ α\n  use\n    FiniteDimensional.finrank\n      («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n      p.splitting_field\n  suffices (minpoly F α).nat_degree = p.nat_degree by\n    rw [←\n      FiniteDimensional.finrank_mul_finrank F\n        («expr ⟮ ,⟯» F \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr ⟮ ,⟯»\")\n        p.splitting_field,\n      intermediate_field.adjoin.finrank hα, this]\n  suffices minpoly F α ∣ p by\n    have key := (minpoly.irreducible hα).dvd_symm p_irr this\n    apply le_antisymm\n    · exact nat_degree_le_of_dvd this p_irr.ne_zero\n    · exact nat_degree_le_of_dvd key (minpoly.ne_zero hα)\n  apply minpoly.dvd F α\n  rw [aeval_def, map_root_of_splits _ (splitting_field.splits p) hp]\n#align prime_degree_dvd_card prime_degree_dvd_card\n\n",
 "mul_splits_in_splitting_field_of_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem mul_splits_in_splitting_field_of_mul {p₁ q₁ p₂ q₂ : polynomial F} (hq₁ : q₁ ≠ 0) (hq₂ : q₂ ≠ 0)\n    (h₁ : p₁.splits (algebraMap F q₁.splitting_field)) (h₂ : p₂.splits (algebraMap F q₂.splitting_field)) :\n    (p₁ * p₂).splits (algebraMap F (q₁ * q₂).splitting_field) :=\n  by\n  apply splits_mul\n  · rw [←\n      (splitting_field.lift q₁\n          (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _)\n            (dvd_mul_right q₁ q₂))).comp_algebra_map]\n    exact splits_comp_of_splits _ _ h₁\n  · rw [←\n      (splitting_field.lift q₂\n          (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _)\n            (dvd_mul_left q₂ q₁))).comp_algebra_map]\n    exact splits_comp_of_splits _ _ h₂\n#align mul_splits_in_splitting_field_of_mul mul_splits_in_splitting_field_of_mul\n\n",
 "map_roots_bijective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem map_roots_bijective [h : Fact (p.splits (algebraMap F E))] : function.bijective (map_roots p E) :=\n  by\n  constructor\n  · exact fun _ _ h => Subtype.ext (RingHom.injective _ (subtype.ext_iff.mp h))\n  · intro y\n    -- this is just an equality of two different ways to write the roots of `p` as an `E`-polynomial\n    have key :=\n      roots_map (IsScalarTower.toAlgHom F p.splitting_field E : «expr →+* » p.splitting_field E)\n        ((splits_id_iff_splits _).mpr (is_splitting_field.splits p.splitting_field p))\n    rw [map_map, AlgHom.comp_algebraMap] at key\n    have hy := Subtype.mem y\n    simp only [root_set, Finset.mem_coe, Multiset.mem_toFinset, key, Multiset.mem_map] at hy\n    rcases hy with ⟨x, hx1, hx2⟩\n    exact ⟨⟨x, multiset.mem_to_finset.mpr hx1⟩, Subtype.ext hx2⟩\n#align map_roots_bijective map_roots_bijective\n\n",
 "gal_action_hom_restrict":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem gal_action_hom_restrict [Fact (p.splits (algebraMap F E))] (ϕ : «expr ≃ₐ[ ] » E F E) (x : rootSet p E) :\n    ↑(gal_action_hom p E (restrict p E ϕ) x) = ϕ x :=\n  restrict_smul ϕ x\n#align gal_action_hom_restrict gal_action_hom_restrict\n\n",
 "gal_action_hom_injective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- `gal p` embeds as a subgroup of permutations of the roots of `p` in `E`. -/\ntheorem gal_action_hom_injective [Fact (p.splits (algebraMap F E))] : function.injective (gal_action_hom p E) :=\n  by\n  rw [injective_iff_map_eq_one]\n  intro ϕ hϕ\n  ext (x hx)\n  have key := equiv.perm.ext_iff.mp hϕ (roots_equiv_roots p E ⟨x, hx⟩)\n  change\n    roots_equiv_roots p E («expr • » ϕ ((roots_equiv_roots p E).symm (roots_equiv_roots p E ⟨x, hx⟩))) =\n      roots_equiv_roots p E ⟨x, hx⟩ at\n    key\n  rw [Equiv.symm_apply_apply] at key\n  exact subtype.ext_iff.mp (Equiv.injective (roots_equiv_roots p E) key)\n#align gal_action_hom_injective gal_action_hom_injective\n\n",
 "gal_action_hom_bijective_of_prime_degree'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem gal_action_hom_bijective_of_prime_degree' {p : polynomial (exprℚ)} (p_irr : Irreducible p)\n    (p_deg : p.nat_degree.prime) (p_roots1 : Fintype.card (p.root_set (exprℝ)) + 1 ≤ Fintype.card (p.root_set (exprℂ)))\n    (p_roots2 : Fintype.card (p.root_set (exprℂ)) ≤ Fintype.card (p.root_set (exprℝ)) + 3) :\n    function.bijective (gal_action_hom p (exprℂ)) :=\n  by\n  apply gal_action_hom_bijective_of_prime_degree p_irr p_deg\n  let n := (gal_action_hom p (exprℂ) (restrict p (exprℂ) (complex.conj_ae.restrict_scalars (exprℚ)))).support.card\n  have hn : 2 ∣ n :=\n    Equiv.Perm.two_dvd_card_support\n      (by\n        rw [← MonoidHom.map_pow, ← MonoidHom.map_pow,\n          show AlgEquiv.restrictScalars (exprℚ) Complex.conjAe ^ 2 = 1 from AlgEquiv.ext Complex.conj_conj,\n          MonoidHom.map_one, MonoidHom.map_one])\n  have key := card_complex_roots_eq_card_real_add_card_not_gal_inv p\n  simp_rw [Set.toFinset_card] at key\n  rw [key, add_le_add_iff_left] at p_roots1 p_roots2\n  rw [key, add_right_inj]\n  suffices ∀ m : ℕ, 2 ∣ m → 1 ≤ m → m ≤ 3 → m = 2 by exact this n hn p_roots1 p_roots2\n  rintro m ⟨k, rfl⟩ h2 h3\n  exact\n    le_antisymm (nat.lt_succ_iff.mp (lt_of_le_of_ne h3 (show 2 * k ≠ 2 * 1 + 1 from Nat.two_mul_ne_two_mul_add_one)))\n      (nat.succ_le_iff.mpr (lt_of_le_of_ne h2 (show 2 * 0 + 1 ≠ 2 * k from nat.two_mul_ne_two_mul_add_one.symm)))\n#align gal_action_hom_bijective_of_prime_degree' gal_action_hom_bijective_of_prime_degree'\n\n",
 "gal_action_hom_bijective_of_prime_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem gal_action_hom_bijective_of_prime_degree {p : polynomial (exprℚ)} (p_irr : Irreducible p)\n    (p_deg : p.nat_degree.prime) (p_roots : Fintype.card (p.root_set (exprℂ)) = Fintype.card (p.root_set (exprℝ)) + 2) :\n    function.bijective (gal_action_hom p (exprℂ)) :=\n  by\n  have h1 : Fintype.card (p.root_set (exprℂ)) = p.nat_degree :=\n    by\n    simp_rw [root_set_def, Finset.coe_sort_coe, Fintype.card_coe]\n    rw [Multiset.toFinset_card_of_nodup, ← nat_degree_eq_card_roots]\n    · exact is_alg_closed.splits_codomain p\n    · exact nodup_roots ((separable_map (algebraMap (exprℚ) (exprℂ))).mpr p_irr.separable)\n  have h2 : Fintype.card p.gal = Fintype.card (gal_action_hom p (exprℂ)).range :=\n    Fintype.card_congr (MonoidHom.ofInjective (gal_action_hom_injective p (exprℂ))).to_equiv\n  let conj := restrict p (exprℂ) (complex.conj_ae.restrict_scalars (exprℚ))\n  refine'\n    ⟨gal_action_hom_injective p (exprℂ), fun x =>\n      (congr_arg (has_mem.mem x) (show (gal_action_hom p (exprℂ)).range = «expr⊤» from _)).mpr (Subgroup.mem_top x)⟩\n  apply Equiv.Perm.subgroup_eq_top_of_swap_mem\n  · rwa [h1]\n  · rw [h1]\n    convert prime_degree_dvd_card p_irr p_deg using 1\n    convert h2.symm\n  · exact ⟨conj, rfl⟩\n  · rw [← Equiv.Perm.card_support_eq_two]\n    apply nat.add_left_cancel\n    rw [← p_roots, ← Set.toFinset_card (root_set p (exprℝ)), ← Set.toFinset_card (root_set p (exprℂ))]\n    exact (card_complex_roots_eq_card_real_add_card_not_gal_inv p).symm\n#align gal_action_hom_bijective_of_prime_degree gal_action_hom_bijective_of_prime_degree\n\n",
 "ext":
 "/-\nCopyright (c) 2020 Thomas Browning, Patrick Lutz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Thomas Browning, Patrick Lutz\n-/\n@[ext]\ntheorem ext {σ τ : p.gal} (h : ∀ x ∈ p.root_set p.splitting_field, σ x = τ x) : σ = τ :=\n  by\n  refine'\n    AlgEquiv.ext fun x =>\n      (AlgHom.mem_equalizer σ.to_alg_hom τ.to_alg_hom x).mp ((set_like.ext_iff.mp _ x).mpr Algebra.mem_top)\n  rwa [eq_top_iff, ← splitting_field.adjoin_roots, Algebra.adjoin_le_iff]\n#align ext ext\n\n",
 "card_of_separable":
 "/-- For a separable polynomial, its Galois group has cardinality\nequal to the dimension of its splitting field over `F`. -/\ntheorem card_of_separable (hp : p.separable) : Fintype.card p.gal = finrank F p.splitting_field :=\n  haveI : is_galois F p.splitting_field := is_galois.of_separable_splitting_field hp\n  is_galois.card_aut_eq_finrank F p.splitting_field\n#align card_of_separable card_of_separable\n\n",
 "card_complex_roots_eq_card_real_add_card_not_gal_inv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℝ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℂ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- The number of complex roots equals the number of real roots plus\n    the number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem card_complex_roots_eq_card_real_add_card_not_gal_inv (p : polynomial (exprℚ)) :\n    (p.root_set (exprℂ)).to_finset.card =\n      (p.root_set (exprℝ)).to_finset.card +\n        (gal_action_hom p (exprℂ) (restrict p (exprℂ) (Complex.conjAe.restrict_scalars (exprℚ)))).support.card :=\n  by\n  by_cases hp : p = 0\n  · haveI : IsEmpty (p.root_set (exprℂ)) := by\n      rw [hp, root_set_zero]\n      infer_instance\n    simp_rw [(gal_action_hom p (exprℂ) _).support.eq_empty_of_is_empty, hp, root_set_zero, Set.toFinset_empty,\n      Finset.card_empty]\n  have inj : function.injective (IsScalarTower.toAlgHom (exprℚ) (exprℝ) (exprℂ)) :=\n    (algebraMap (exprℝ) (exprℂ)).injective\n  rw [← Finset.card_image_of_injective _ Subtype.coe_injective, ← Finset.card_image_of_injective _ inj]\n  let a : Finset (exprℂ) := _\n  let b : Finset (exprℂ) := _\n  let c : Finset (exprℂ) := _\n  change a.card = b.card + c.card\n  have ha : ∀ z : exprℂ, z ∈ a ↔ aeval z p = 0 := by\n    intro z\n    rw [Set.mem_toFinset, mem_root_set_of_ne hp]\n    infer_instance\n  have hb : ∀ z : exprℂ, z ∈ b ↔ aeval z p = 0 ∧ z.im = 0 :=\n    by\n    intro z\n    simp_rw [Finset.mem_image, exists_prop, Set.mem_toFinset, mem_root_set_of_ne hp]\n    constructor\n    · rintro ⟨w, hw, rfl⟩\n      exact ⟨by rw [aeval_alg_hom_apply, hw, AlgHom.map_zero], rfl⟩\n    · rintro ⟨hz1, hz2⟩\n      have key : IsScalarTower.toAlgHom (exprℚ) (exprℝ) (exprℂ) z.re = z :=\n        by\n        ext\n        rfl\n        rw [hz2]\n        rfl\n      exact ⟨z.re, inj (by rwa [← aeval_alg_hom_apply, key, AlgHom.map_zero]), key⟩\n  have hc0 :\n    ∀ w : p.root_set (exprℂ),\n      gal_action_hom p (exprℂ) (restrict p (exprℂ) (complex.conj_ae.restrict_scalars (exprℚ))) w = w ↔ w.val.im = 0 :=\n    by\n    intro w\n    rw [Subtype.ext_iff, gal_action_hom_restrict]\n    exact Complex.conj_eq_iff_im\n  have hc : ∀ z : exprℂ, z ∈ c ↔ aeval z p = 0 ∧ z.im ≠ 0 :=\n    by\n    intro z\n    simp_rw [Finset.mem_image, exists_prop]\n    constructor\n    · rintro ⟨w, hw, rfl⟩\n      exact ⟨(mem_root_set.mp w.2).2, mt (hc0 w).mpr (equiv.perm.mem_support.mp hw)⟩\n    · rintro ⟨hz1, hz2⟩\n      exact ⟨⟨z, mem_root_set.mpr ⟨hp, hz1⟩⟩, equiv.perm.mem_support.mpr (mt (hc0 _).mp hz2), rfl⟩\n  rw [← Finset.card_disjoint_union]\n  · apply congr_arg Finset.card\n    simp_rw [Finset.ext_iff, Finset.mem_union, ha, hb, hc]\n    tauto\n  · rw [Finset.disjoint_left]\n    intro z\n    rw [hb, hc]\n    tauto\n  · infer_instance\n#align card_complex_roots_eq_card_real_add_card_not_gal_inv card_complex_roots_eq_card_real_add_card_not_gal_inv\n\n"}