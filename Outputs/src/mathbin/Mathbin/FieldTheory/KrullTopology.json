{"top_fixed_by_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `L/K` is a field extension, then we have `Gal(L/K) ∈ fixed_by_finite K L` -/\ntheorem top_fixed_by_finite {K L : Type _} [Field K] [Field L] [Algebra K L] : «expr⊤» ∈ fixed_by_finite K L :=\n  ⟨«expr⊥», intermediate_field.finite_dimensional_bot K L, intermediate_field.fixing_subgroup.bot⟩\n#align top_fixed_by_finite top_fixed_by_finite\n\n",
 "mem_gal_basis_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- A subset of `L ≃ₐ[K] L` is a member of `gal_basis K L` if and only if it is the underlying set\nof `Gal(L/E)` for some finite subextension `E/K`-/\ntheorem mem_gal_basis_iff (K L : Type _) [Field K] [Field L] [Algebra K L] (U : Set («expr ≃ₐ[ ] » L K L)) :\n    U ∈ gal_basis K L ↔ U ∈ «expr '' » subgroup.carrier (fixed_by_finite K L) :=\n  iff.rfl\n#align mem_gal_basis_iff mem_gal_basis_iff\n\n",
 "mem_fixing_subgroup_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- An element of `L ≃ₐ[K] L` is in `Gal(L/E)` if and only if it fixes every element of `E`-/\ntheorem intermediate_field.mem_fixing_subgroup_iff {K L : Type _} [Field K] [Field L] [Algebra K L]\n    (E : intermediate_field K L) (σ : «expr ≃ₐ[ ] » L K L) : σ ∈ E.fixing_subgroup ↔ ∀ x : L, x ∈ E → σ x = x :=\n  ⟨fun hσ x hx => hσ ⟨x, hx⟩, fun h ⟨x, hx⟩ => h x hx⟩\n#align intermediate_field.mem_fixing_subgroup_iff intermediate_field.mem_fixing_subgroup_iff\n\n",
 "map_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-\nCopyright (c) 2022 Sebastian Monnet. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sebastian Monnet\n-/\n/-- Mapping intermediate fields along algebra equivalences preserves the partial order -/\ntheorem intermediate_field.map_mono {K L M : Type _} [Field K] [Field L] [Field M] [Algebra K L] [Algebra K M]\n    {E1 E2 : intermediate_field K L} (e : «expr ≃ₐ[ ] » L K M) (h12 : E1 ≤ E2) :\n    E1.map e.to_alg_hom ≤ E2.map e.to_alg_hom :=\n  Set.image_subset e h12\n#align intermediate_field.map_mono intermediate_field.map_mono\n\n",
 "map_id":
 "/-- Mapping intermediate fields along the identity does not change them -/\ntheorem intermediate_field.map_id {K L : Type _} [Field K] [Field L] [Algebra K L] (E : intermediate_field K L) :\n    E.map (AlgHom.id K L) = E :=\n  SetLike.coe_injective <| Set.image_id _\n#align intermediate_field.map_id intermediate_field.map_id\n\n",
 "krull_topology_totally_disconnected":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- If `L/K` is an algebraic field extension, then the Krull topology on `L ≃ₐ[K] L` is\n  totally disconnected. -/\ntheorem krull_topology_totally_disconnected {K L : Type _} [Field K] [Field L] [Algebra K L]\n    (h_int : algebra.is_integral K L) : IsTotallyDisconnected (Set.univ : Set («expr ≃ₐ[ ] » L K L)) :=\n  by\n  apply isTotallyDisconnected_of_clopen_set\n  intro σ τ h_diff\n  have hστ : σ⁻¹ * τ ≠ 1 := by rwa [ne.def, inv_mul_eq_one]\n  rcases FunLike.exists_ne hστ with ⟨x, hx : (σ⁻¹ * τ) x ≠ x⟩\n  let E := intermediate_field.adjoin K ({x} : Set L)\n  haveI := intermediate_field.adjoin.finite_dimensional (h_int x)\n  refine'\n    ⟨leftCoset σ E.fixing_subgroup, ⟨E.fixing_subgroup_is_open.left_coset σ, E.fixing_subgroup_is_closed.left_coset σ⟩,\n      ⟨1, E.fixing_subgroup.one_mem', mul_one σ⟩, _⟩\n  simp only [mem_leftCoset_iff, SetLike.mem_coe, intermediate_field.mem_fixing_subgroup_iff, not_forall]\n  exact ⟨x, intermediate_field.mem_adjoin_simple_self K x, hx⟩\n#align krull_topology_totally_disconnected krull_topology_totally_disconnected\n\n",
 "krull_topology_t2":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- If `L/K` is an algebraic extension, then the Krull topology on `L ≃ₐ[K] L` is Hausdorff. -/\ntheorem krull_topology_t2 {K L : Type _} [Field K] [Field L] [Algebra K L] (h_int : algebra.is_integral K L) :\n    T2Space («expr ≃ₐ[ ] » L K L) :=\n  {\n    t2 := fun f g hfg => by\n      let φ := f⁻¹ * g\n      cases' FunLike.exists_ne hfg with x hx\n      have hφx : φ x ≠ x := by\n        apply ne_of_apply_ne f\n        change f (f.symm (g x)) ≠ f x\n        rw [AlgEquiv.apply_symm_apply f (g x), ne_comm]\n        exact hx\n      let E : intermediate_field K L := intermediate_field.adjoin K {x}\n      let h_findim : FiniteDimensional K E := intermediate_field.adjoin.finite_dimensional (h_int x)\n      let H := E.fixing_subgroup\n      have h_basis : (H : Set («expr ≃ₐ[ ] » L K L)) ∈ gal_group_basis K L := ⟨H, ⟨E, ⟨h_findim, rfl⟩⟩, rfl⟩\n      have h_nhd := GroupFilterBasis.mem_nhds_one (gal_group_basis K L) h_basis\n      rw [mem_nhds_iff] at h_nhd\n      rcases h_nhd with ⟨W, hWH, hW_open, hW_1⟩\n      refine'\n        ⟨leftCoset f W, leftCoset g W,\n          ⟨hW_open.left_coset f, hW_open.left_coset g, ⟨1, hW_1, mul_one _⟩, ⟨1, hW_1, mul_one _⟩, _⟩⟩\n      rw [Set.disjoint_left]\n      rintro σ ⟨w1, hw1, h⟩ ⟨w2, hw2, rfl⟩\n      rw [eq_inv_mul_iff_mul_eq.symm, ← mul_assoc, mul_inv_eq_iff_eq_mul.symm] at h\n      have h_in_H : w1 * w2⁻¹ ∈ H := H.mul_mem (hWH hw1) (H.inv_mem (hWH hw2))\n      rw [h] at h_in_H\n      change φ ∈ E.fixing_subgroup at h_in_H\n      rw [intermediate_field.mem_fixing_subgroup_iff] at h_in_H\n      specialize h_in_H x\n      have hxE : x ∈ E := by\n        apply intermediate_field.subset_adjoin\n        apply Set.mem_singleton\n      exact hφx (h_in_H hxE) }\n#align krull_topology_t2 krull_topology_t2\n\n",
 "fixing_subgroup_is_open":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- Let `L/E/K` be a tower of fields with `E/K` finite. Then `Gal(L/E)` is an open subgroup of\n  `L ≃ₐ[K] L`. -/\ntheorem intermediate_field.fixing_subgroup_is_open {K L : Type _} [Field K] [Field L] [Algebra K L]\n    (E : intermediate_field K L) [FiniteDimensional K E] : IsOpen (E.fixing_subgroup : Set («expr ≃ₐ[ ] » L K L)) :=\n  by\n  have h_basis : E.fixing_subgroup.carrier ∈ gal_group_basis K L := ⟨E.fixing_subgroup, ⟨E, ‹_›, rfl⟩, rfl⟩\n  have h_nhd := GroupFilterBasis.mem_nhds_one (gal_group_basis K L) h_basis\n  exact Subgroup.isOpen_of_mem_nhds _ h_nhd\n#align intermediate_field.fixing_subgroup_is_open intermediate_field.fixing_subgroup_is_open\n\n",
 "fixing_subgroup_is_closed":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n/-- Given a tower of fields `L/E/K`, with `E/K` finite, the subgroup `Gal(L/E) ≤ L ≃ₐ[K] L` is\n  closed. -/\ntheorem intermediate_field.fixing_subgroup_is_closed {K L : Type _} [Field K] [Field L] [Algebra K L]\n    (E : intermediate_field K L) [FiniteDimensional K E] : IsClosed (E.fixing_subgroup : Set («expr ≃ₐ[ ] » L K L)) :=\n  OpenSubgroup.isClosed ⟨E.fixing_subgroup, E.fixing_subgroup_is_open⟩\n#align intermediate_field.fixing_subgroup_is_closed intermediate_field.fixing_subgroup_is_closed\n\n",
 "finite_dimensional_sup":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/-- If `E1` and `E2` are finite-dimensional intermediate fields, then so is their compositum.\nThis rephrases a result already in mathlib so that it is compatible with our type classes -/\ntheorem finite_dimensional_sup {K L : Type _} [Field K] [Field L] [Algebra K L] (E1 E2 : intermediate_field K L)\n    (h1 : FiniteDimensional K E1) (h2 : FiniteDimensional K E2) : FiniteDimensional K («expr↥ » («expr ⊔ » E1 E2)) :=\n  intermediate_field.finite_dimensional_sup E1 E2\n#align finite_dimensional_sup finite_dimensional_sup\n\n",
 "finite_dimensional_bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- For an field extension `L/K`, the intermediate field `K` is finite-dimensional over `K` -/\ntheorem intermediate_field.finite_dimensional_bot (K L : Type _) [Field K] [Field L] [Algebra K L] :\n    FiniteDimensional K («expr⊥» : intermediate_field K L) :=\n  finiteDimensional_of_rank_eq_one intermediate_field.rank_bot\n#align intermediate_field.finite_dimensional_bot intermediate_field.finite_dimensional_bot\n\n",
 "bot":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- This lemma says that `Gal(L/K) = L ≃ₐ[K] L` -/\ntheorem intermediate_field.fixing_subgroup.bot {K L : Type _} [Field K] [Field L] [Algebra K L] :\n    intermediate_field.fixing_subgroup («expr⊥» : intermediate_field K L) = «expr⊤» :=\n  by\n  ext f\n  refine' ⟨fun _ => Subgroup.mem_top _, fun _ => _⟩\n  rintro ⟨x, hx : x ∈ («expr⊥» : intermediate_field K L)⟩\n  rw [intermediate_field.mem_bot] at hx\n  rcases hx with ⟨y, rfl⟩\n  exact f.commutes y\n#align intermediate_field.fixing_subgroup.bot intermediate_field.fixing_subgroup.bot\n\n",
 "antimono":
 "/-- The map `E ↦ Gal(L/E)` is inclusion-reversing -/\ntheorem intermediate_field.fixing_subgroup.antimono {K L : Type _} [Field K] [Field L] [Algebra K L]\n    {E1 E2 : intermediate_field K L} (h12 : E1 ≤ E2) : E2.fixing_subgroup ≤ E1.fixing_subgroup :=\n  by\n  rintro σ hσ ⟨x, hx⟩\n  exact hσ ⟨x, h12 hx⟩\n#align intermediate_field.fixing_subgroup.antimono intermediate_field.fixing_subgroup.antimono\n\n"}