{"rank_R":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `cardinal.mk -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr↥ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\ntheorem rank_R [Fintype σ] : Module.rank K (R σ K) = Fintype.card (σ → K) :=\n  calc\n    Module.rank K (R σ K) =\n        Module.rank K («expr →₀ » («expr↥ » { s : «expr →₀ » σ ℕ | ∀ n : σ, s n ≤ Fintype.card K - 1 }) K) :=\n      LinearEquiv.rank_eq (Finsupp.supportedEquivFinsupp { s : «expr →₀ » σ ℕ | ∀ n : σ, s n ≤ Fintype.card K - 1 })\n    _ = cardinal.mk { s : «expr →₀ » σ ℕ | ∀ n : σ, s n ≤ Fintype.card K - 1 } := by rw [rank_finsupp_self']\n    _ = cardinal.mk { s : σ → ℕ | ∀ n : σ, s n < Fintype.card K } :=\n      by\n      refine' quotient.sound ⟨Equiv.subtypeEquiv Finsupp.equivFunOnFinite fun f => _⟩\n      refine' forall_congr' fun n => le_tsub_iff_right _\n      exact Fintype.card_pos_iff.2 ⟨0⟩\n    _ = cardinal.mk (σ → { n // n < Fintype.card K }) :=\n      (@Equiv.subtypePiEquivPi σ (fun _ => ℕ) fun s n => n < Fintype.card K).cardinal_eq\n    _ = cardinal.mk (σ → Fin (Fintype.card K)) := (Equiv.arrowCongr (Equiv.refl σ) Fin.equivSubtype.symm).cardinal_eq\n    _ = cardinal.mk (σ → K) := (Equiv.arrowCongr (Equiv.refl σ) (Fintype.equivFin K).symm).cardinal_eq\n    _ = Fintype.card (σ → K) := Cardinal.mk_fintype _\n    \n#align rank_R rank_R\n\n",
 "range_evalᵢ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem range_evalᵢ [Finite σ] : (evalᵢ σ K).range = «expr⊤» :=\n  by\n  rw [evalᵢ, LinearMap.range_comp, range_subtype]\n  exact map_restrict_dom_evalₗ\n#align range_evalᵢ range_evalᵢ\n\n",
 "map_restrict_dom_evalₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\ntheorem map_restrict_dom_evalₗ : (restrictDegree σ K (Fintype.card K - 1)).map (evalₗ K σ) = «expr⊤» :=\n  by\n  cases nonempty_fintype σ\n  refine' top_unique (SetLike.le_def.2 fun e _ => mem_map.2 _)\n  refine'\n    ⟨finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (e n) (indicator n)),\n      _, _⟩\n  · exact sum_mem fun c _ => smul_mem _ _ (indicator_mem_restrict_degree _)\n  · ext n\n    simp only [LinearMap.map_sum, @Finset.sum_apply (σ → K) (fun _ => K) _ _ _ _ _, Pi.smul_apply, LinearMap.map_smul]\n    simp only [evalₗ_apply]\n    trans\n    refine' Finset.sum_eq_single n (fun b _ h => _) _\n    · rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero]\n    · exact fun h => (h <| Finset.mem_univ n).elim\n    · rw [eval_indicator_apply_eq_one, smul_eq_mul, mul_one]\n#align map_restrict_dom_evalₗ map_restrict_dom_evalₗ\n\n",
 "ker_evalₗ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ker_evalₗ [Finite σ] : (evalᵢ σ K).ker = «expr⊥» :=\n  by\n  cases nonempty_fintype σ\n  refine' (ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank _).mpr (range_evalᵢ _ _)\n  rw [FiniteDimensional.finrank_fintype_fun_eq_card, finrank_R]\n#align ker_evalₗ ker_evalₗ\n\n",
 "indicator_mem_restrict_degree":
 "theorem indicator_mem_restrict_degree (c : σ → K) : indicator c ∈ restrictDegree σ K (Fintype.card K - 1) :=\n  by\n  rw [mem_restrict_degree_iff_sup, indicator]\n  intro n\n  refine' le_trans (Multiset.count_le_of_le _ <| degrees_indicator _) (le_of_eq _)\n  simp_rw [← Multiset.coe_countAddMonoidHom, (Multiset.countAddMonoidHom n).map_sum, AddMonoidHom.map_nsmul,\n    Multiset.coe_countAddMonoidHom, nsmul_eq_mul, Nat.cast_id]\n  trans\n  refine' Finset.sum_eq_single n _ _\n  · intro b hb ne\n    rw [Multiset.count_singleton, if_neg ne.symm, MulZeroClass.mul_zero]\n  · intro h\n    exact (h <| Finset.mem_univ _).elim\n  · rw [Multiset.count_singleton_self, mul_one]\n#align indicator_mem_restrict_degree indicator_mem_restrict_degree\n\n",
 "frobenius_zmod":
 "theorem frobenius_zmod (f : MvPolynomial σ (ZMod p)) : frobenius _ p f = expand p f :=\n  by\n  apply induction_on f\n  · intro a\n    rw [expand_C, frobenius_def, ← C_pow, zmod.pow_card]\n  · simp only [AlgHom.map_add, RingHom.map_add]\n    intro _ _ hf hg\n    rw [hf, hg]\n  · simp only [expand_X, RingHom.map_mul, AlgHom.map_mul]\n    intro _ _ hf\n    rw [hf, frobenius_def]\n#align frobenius_zmod frobenius_zmod\n\n",
 "finrank_R":
 "theorem finrank_R [Fintype σ] : FiniteDimensional.finrank K (R σ K) = Fintype.card (σ → K) :=\n  FiniteDimensional.finrank_eq_of_rank_eq (rank_R σ K)\n#align finrank_R finrank_R\n\n",
 "expand_zmod":
 "theorem expand_zmod (f : MvPolynomial σ (ZMod p)) : expand p f = f ^ p :=\n  (frobenius_zmod _).symm\n#align expand_zmod expand_zmod\n\n",
 "eval_indicator_apply_eq_zero":
 "theorem eval_indicator_apply_eq_zero (a b : σ → K) (h : a ≠ b) : eval a (indicator b) = 0 :=\n  by\n  obtain ⟨i, hi⟩ : ∃ i, a i ≠ b i := by rwa [(· ≠ ·), Function.funext_iff, not_forall] at h\n  simp only [indicator, map_prod, map_sub, map_one, map_pow, eval_X, eval_C, sub_self, Finset.prod_eq_zero_iff]\n  refine' ⟨i, Finset.mem_univ _, _⟩\n  rw [finite_field.pow_card_sub_one_eq_one, sub_self]\n  rwa [(· ≠ ·), sub_eq_zero]\n#align eval_indicator_apply_eq_zero eval_indicator_apply_eq_zero\n\n",
 "eval_indicator_apply_eq_one":
 "theorem eval_indicator_apply_eq_one (a : σ → K) : eval a (indicator a) = 1 :=\n  by\n  nontriviality\n  have : 0 < Fintype.card K - 1 := tsub_pos_of_lt Fintype.one_lt_card\n  simp only [indicator, map_prod, map_sub, map_one, map_pow, eval_X, eval_C, sub_self, zero_pow this, sub_zero,\n    Finset.prod_const_one]\n#align eval_indicator_apply_eq_one eval_indicator_apply_eq_one\n\n",
 "eq_zero_of_eval_eq_zero":
 "theorem eq_zero_of_eval_eq_zero [Finite σ] (p : MvPolynomial σ K) (h : ∀ v : σ → K, eval v p = 0)\n    (hp : p ∈ restrictDegree σ K (Fintype.card K - 1)) : p = 0 :=\n  let p' : R σ K := ⟨p, hp⟩\n  have : p' ∈ (evalᵢ σ K).ker := funext h\n  show p'.1 = (0 : R σ K).1 from congr_arg _ <| by rwa [ker_evalₗ, mem_bot] at this\n#align eq_zero_of_eval_eq_zero eq_zero_of_eval_eq_zero\n\n",
 "degrees_indicator":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem degrees_indicator (c : σ → K) :\n    degrees (indicator c) ≤\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        («expr • » (Fintype.card K - 1) {s}) :=\n  by\n  rw [indicator]\n  refine' le_trans (degrees_prod _ _) (Finset.sum_le_sum fun s hs => _)\n  refine' le_trans (degrees_sub _ _) _\n  rw [degrees_one, ← bot_eq_zero, bot_sup_eq]\n  refine' le_trans (degrees_pow _ _) (nsmul_le_nsmul_of_le_right _ _)\n  refine' le_trans (degrees_sub _ _) _\n  rw [degrees_C, ← bot_eq_zero, sup_bot_eq]\n  exact degrees_X' _\n#align degrees_indicator degrees_indicator\n\n",
 "C_dvd_iff_zmod":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n/-- A polynomial over the integers is divisible by `n : ℕ`\nif and only if it is zero over `zmod n`. -/\ntheorem C_dvd_iff_zmod (n : ℕ) (φ : MvPolynomial σ ℤ) : C (n : ℤ) ∣ φ ↔ map (Int.castRingHom (ZMod n)) φ = 0 :=\n  C_dvd_iff_map_hom_eq_zero _ _ (CharP.int_cast_eq_zero_iff (ZMod n) n) _\n#align C_dvd_iff_zmod C_dvd_iff_zmod\n\n"}