{"splits_zmod_X_pow_sub_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem splits_zmod_X_pow_sub_X : splits (RingHom.id (zmod p)) (X ^ p - X) :=\n  by\n  have hp : 1 < p := (fact.out (Nat.Prime p)).one_lt\n  have h1 : roots (X ^ p - X : polynomial (zmod p)) = finset.univ.val :=\n    by\n    convert finite_field.roots_X_pow_card_sub_X _\n    exact (zmod.card p).symm\n  have h2 := finite_field.X_pow_card_sub_X_nat_degree_eq (zmod p) hp\n  -- We discharge the `p = 0` separately, to avoid typeclass issues on `zmod p`.\n  cases p\n  cases hp\n  rw [splits_iff_card_roots, h1, ← finset.card_def, finset.card_univ, h2, zmod.card]\n#align splits_zmod_X_pow_sub_X splits_zmod_X_pow_sub_X\n\n",
 "splits_X_pow_card_sub_X":
 "theorem splits_X_pow_card_sub_X : splits (algebra_map (zmod p) K) (X ^ fintype.card K - X) :=\n  (finite_field.has_sub.sub.polynomial.is_splitting_field K (zmod p)).splits\n#align splits_X_pow_card_sub_X splits_X_pow_card_sub_X\n\n",
 "is_splitting_field_of_card_eq":
 "theorem is_splitting_field_of_card_eq (h : fintype.card K = p ^ n) : is_splitting_field (zmod p) K (X ^ p ^ n - X) :=\n  h ▸ finite_field.has_sub.sub.polynomial.is_splitting_field K (zmod p)\n#align is_splitting_field_of_card_eq is_splitting_field_of_card_eq\n\n",
 "galois_poly_separable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson, Alex J. Best, Johan Commelin, Eric Rodriguez, Ruben Van de Velde\n-/\ntheorem galois_poly_separable {K : Type _} [Field K] (p q : ℕ) [char_p K p] (h : p ∣ q) :\n    separable (X ^ q - X : polynomial K) := by\n  use 1, X ^ q - X - 1\n  rw [← char_p.cast_eq_zero_iff (polynomial K) p] at h\n  rw [derivative_sub, derivative_X_pow, derivative_X, C_eq_nat_cast, h]\n  ring\n#align galois_poly_separable galois_poly_separable\n\n",
 "finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem finrank {n} (h : n ≠ 0) : finite_dimensional.finrank (zmod p) (galois_field p n) = n :=\n  by\n  set g_poly := (X ^ p ^ n - X : polynomial (zmod p))\n  have hp : 1 < p := (fact.out (Nat.Prime p)).one_lt\n  have aux : g_poly ≠ 0 := finite_field.X_pow_card_pow_sub_X_ne_zero _ h hp\n  have key : fintype.card (g_poly.root_set (galois_field p n)) = g_poly.nat_degree :=\n    card_root_set_eq_nat_degree (galois_poly_separable p _ (dvd_pow (dvd_refl p) h)) (splitting_field.splits g_poly)\n  have nat_degree_eq : g_poly.nat_degree = p ^ n := finite_field.X_pow_card_pow_sub_X_nat_degree_eq _ h hp\n  rw [nat_degree_eq] at key\n  suffices g_poly.root_set (galois_field p n) = Set.univ\n    by\n    simp_rw [this, ← fintype.of_equiv_card (Equiv.Set.univ _)] at key\n    rw [@card_eq_pow_finrank (zmod p), zmod.card] at key\n    exact Nat.pow_right_injective (Nat.Prime.one_lt' p).out key\n  rw [Set.eq_univ_iff_forall]\n  suffices\n    ∀ (x) (hx : x ∈ («expr⊤» : subalgebra (zmod p) (galois_field p n))),\n      x ∈ (X ^ p ^ n - X : polynomial (zmod p)).root_set (galois_field p n)\n    by simpa\n  rw [← splitting_field.adjoin_root_set]\n  simp_rw [algebra.mem_adjoin_iff]\n  intro x hx\n  -- We discharge the `p = 0` separately, to avoid typeclass issues on `zmod p`.\n  cases p\n  cases hp\n  apply subring.closure_induction hx <;> clear! x <;> simp_rw [mem_root_set_of_ne aux]\n  · rintro x (⟨r, rfl⟩ | hx)\n    · simp only [aeval_X_pow, aeval_X, alg_hom.map_sub]\n      rw [← map_pow, zmod.pow_card_pow, sub_self]\n    · dsimp only [galois_field] at hx\n      rwa [mem_root_set_of_ne aux] at hx\n      infer_instance\n  · dsimp only [g_poly]\n    rw [← coeff_zero_eq_aeval_zero']\n    simp only [coeff_X_pow, coeff_X_zero, sub_zero, _root_.map_eq_zero, ite_eq_right_iff, one_ne_zero, coeff_sub]\n    intro hn\n    exact nat.not_lt_zero 1 (pow_eq_zero hn.symm ▸ hp)\n  · simp\n  · simp only [aeval_X_pow, aeval_X, alg_hom.map_sub, add_pow_char_pow, sub_eq_zero]\n    intro x y hx hy\n    rw [hx, hy]\n  · intro x hx\n    simp only [sub_eq_zero, aeval_X_pow, aeval_X, alg_hom.map_sub, sub_neg_eq_add] at *\n    rw [neg_pow, hx, char_p.neg_one_pow_char_pow]\n    simp\n  · simp only [aeval_X_pow, aeval_X, alg_hom.map_sub, mul_pow, sub_eq_zero]\n    intro x y hx hy\n    rw [hx, hy]\n#align finrank finrank\n\n",
 "card":
 "theorem card (h : n ≠ 0) : fintype.card (galois_field p n) = p ^ n :=\n  by\n  let b := is_noetherian.finset_basis (zmod p) (galois_field p n)\n  rw [module.card_fintype b, ← finite_dimensional.finrank_eq_card_basis b, zmod.card, finrank p h]\n#align card card\n\n"}