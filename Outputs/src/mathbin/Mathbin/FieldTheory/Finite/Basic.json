{"units_pow_card_sub_one_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- **Fermat's Little Theorem**: for every unit `a` of `zmod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem units_pow_card_sub_one_eq_one (p : ℕ) [Fact p.prime] (a : «expr ˣ» (ZMod p)) : a ^ (p - 1) = 1 := by\n  rw [← card_units p, pow_card_eq_one]\n#align units_pow_card_sub_one_eq_one units_pow_card_sub_one_eq_one\n\n",
 "unit_is_square_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem unit_is_square_iff (hF : ringChar F ≠ 2) (a : «expr ˣ» F) : IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 := by\n  classical\n    obtain ⟨g, hg⟩ := is_cyclic.exists_generator («expr ˣ» F)\n    obtain ⟨n, hn⟩ : a ∈ Submonoid.powers g :=\n      by\n      rw [mem_powers_iff_mem_zpowers]\n      apply hg\n    have hodd := Nat.two_mul_odd_div_two (finite_field.odd_card_of_char_ne_two hF)\n    constructor\n    · rintro ⟨y, rfl⟩\n      rw [← pow_two, ← pow_mul, hodd]\n      apply_fun @coe («expr ˣ» F) F _ using Units.ext\n      · push_cast\n        exact finite_field.pow_card_sub_one_eq_one (y : F) (Units.ne_zero y)\n    · subst a\n      intro h\n      have key : 2 * (Fintype.card F / 2) ∣ n * (Fintype.card F / 2) :=\n        by\n        rw [← pow_mul] at h\n        rw [hodd, ← Fintype.card_units, ← order_of_eq_card_of_forall_mem_zpowers hg]\n        apply orderOf_dvd_of_pow_eq_one h\n      have : 0 < Fintype.card F / 2 := Nat.div_pos Fintype.one_lt_card (by norm_num)\n      obtain ⟨m, rfl⟩ := Nat.dvd_of_mul_dvd_mul_right this key\n      refine' ⟨g ^ m, _⟩\n      rw [mul_comm, pow_mul, pow_two]\n#align unit_is_square_iff unit_is_square_iff\n\n",
 "sum_pow_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/-- The sum of `x ^ i` as `x` ranges over the units of a finite field of cardinality `q`\nis equal to `0` unless `(q - 1) ∣ i`, in which case the sum is `q - 1`. -/\ntheorem sum_pow_units [Fintype («expr ˣ» K)] (i : ℕ) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n        (x ^ i : K) =\n      if exprq - 1 ∣ i then -1 else 0 :=\n  by\n  let φ : «expr →* » («expr ˣ» K) K :=\n    { to_fun := fun x => x ^ i\n      map_one' := by rw [Units.val_one, one_pow]\n      map_mul' := by\n        intros\n        rw [Units.val_mul, mul_pow] }\n  have : Decidable (φ = 1) := by classical infer_instance\n  calc\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (φ x) =\n        if φ = 1 then Fintype.card («expr ˣ» K) else 0 :=\n      sum_hom_units φ\n    _ = if exprq - 1 ∣ i then -1 else 0 := _\n    \n  suffices exprq - 1 ∣ i ↔ φ = 1 by\n    simp only [this]\n    split_ifs with h h\n    swap\n    rfl\n    rw [Fintype.card_units, Nat.cast_sub, cast_card_eq_zero, Nat.cast_one, zero_sub]\n    show 1 ≤ exprq\n    exact fintype.card_pos_iff.mpr ⟨0⟩\n  rw [← forall_pow_eq_one_iff, MonoidHom.ext_iff]\n  apply forall_congr'\n  intro x\n  rw [Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one, MonoidHom.one_apply]\n  rfl\n#align sum_pow_units sum_pow_units\n\n",
 "sum_pow_lt_card_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ↪ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ -/\n/-- The sum of `x ^ i` as `x` ranges over a finite field of cardinality `q`\nis equal to `0` if `i < q - 1`. -/\ntheorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < exprq - 1) :\n    finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\" (x ^ i) =\n      0 :=\n  by\n  by_cases hi : i = 0\n  · simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero]\n  classical\n    have hiq : ¬exprq - 1 ∣ i := by\n      contrapose! h\n      exact nat.le_of_dvd (nat.pos_of_ne_zero hi) h\n    let φ : «expr ↪ » («expr ˣ» K) K := ⟨coe, Units.ext⟩\n    have : univ.map φ = univ \\ {0} := by\n      ext x\n      simp only [true_and_iff, embedding.coe_fn_mk, mem_sdiff, Units.exists_iff_ne_zero, mem_univ, mem_map,\n        exists_prop_of_true, mem_singleton]\n    calc\n      finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (x ^ i) =\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (univ \\ {(0 : K)}) (x ^ i) :=\n        by rw [← sum_sdiff ({0} : Finset K).subset_univ, sum_singleton, zero_pow (nat.pos_of_ne_zero hi), add_zero]\n      _ =\n          finset.sum_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum_univ\"\n            (x ^ i) :=\n        by\n        rw [← this, univ.sum_map φ]\n        rfl\n      _ = 0 := by\n        rw [sum_pow_units K i, if_neg]\n        exact hiq\n      \n#align sum_pow_lt_card_sub_one sum_pow_lt_card_sub_one\n\n",
 "sq_add_sq":
 "theorem sq_add_sq (R : Type _) [CommRing R] [IsDomain R] (p : ℕ) [NeZero p] [CharP R p] (x : ℤ) :\n    ∃ a b : ℕ, (a ^ 2 + b ^ 2 : R) = x := by\n  haveI := char_is_prime_of_pos R p\n  obtain ⟨a, b, hab⟩ := zmod.sq_add_sq p x\n  refine' ⟨a.val, b.val, _⟩\n  simpa using congr_arg (ZMod.castHom dvd_rfl R) hab\n#align sq_add_sq sq_add_sq\n\n",
 "roots_X_pow_card_sub_X":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem roots_X_pow_card_sub_X : roots (X ^ exprq - X : polynomial K) = Finset.univ.val := by\n  classical\n    have aux : (X ^ exprq - X : polynomial K) ≠ 0 := X_pow_card_sub_X_ne_zero K Fintype.one_lt_card\n    have : (roots (X ^ exprq - X : polynomial K)).to_finset = Finset.univ :=\n      by\n      rw [eq_univ_iff_forall]\n      intro x\n      rw [Multiset.mem_toFinset, mem_roots aux, is_root.def, eval_sub, eval_pow, eval_X, sub_eq_zero, pow_card]\n    rw [← this, Multiset.toFinset_val, eq_comm, Multiset.dedup_eq_self]\n    apply nodup_roots\n    rw [separable_def]\n    convert is_coprime_one_right.neg_right using 1\n    ·\n      rw [derivative_sub, derivative_X, derivative_X_pow, CharP.cast_card_eq_zero K, C_0, MulZeroClass.zero_mul,\n        zero_sub]\n#align roots_X_pow_card_sub_X roots_X_pow_card_sub_X\n\n",
 "prod_univ_units_id_eq_neg_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem prod_univ_units_id_eq_neg_one [CommRing K] [IsDomain K] [Fintype («expr ˣ» K)] :\n    finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\" x =\n      (-1 : «expr ˣ» K) :=\n  by\n  classical\n    have :\n      finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\"\n          ((@univ («expr ˣ» K) _).erase (-1)) x =\n        1 :=\n      prod_involution (fun x _ => x⁻¹) (by simp)\n        (fun a => by simp (config := { contextual := true }) [Units.inv_eq_self_iff])\n        (fun a => by simp [@inv_eq_iff_eq_inv _ _ a]) (by simp)\n    rw [← insert_erase (mem_univ (-1 : «expr ˣ» K)), prod_insert (not_mem_erase _ _), this, mul_one]\n#align prod_univ_units_id_eq_neg_one prod_univ_units_id_eq_neg_one\n\n",
 "pow_totient":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [MOD ]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `nat.totient -/\n/-- The **Fermat-Euler totient theorem**. `zmod.pow_totient` is an alternative statement\n  of the same theorem. -/\ntheorem nat.modeq.pow_totient {x n : ℕ} (h : Nat.coprime x n) : «expr ≡ [MOD ]» (x ^ (nat.totient) n) 1 n :=\n  by\n  rw [← ZMod.eq_iff_modEq_nat]\n  let x' : Units (ZMod n) := ZMod.unitOfCoprime _ h\n  have := zmod.pow_totient x'\n  apply_fun (coe : Units (ZMod n) → ZMod n)  at this\n  simpa only [-zmod.pow_totient, nat.succ_eq_add_one, Nat.cast_pow, Units.val_one, Nat.cast_one, coe_unit_of_coprime,\n    Units.val_pow_eq_pow_val]\n#align nat.modeq.pow_totient nat.modeq.pow_totient\n\n",
 "pow_dichotomy":
 "/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. -/\ntheorem pow_dichotomy (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1 :=\n  by\n  have h₁ := finite_field.pow_card_sub_one_eq_one a ha\n  rw [← Nat.two_mul_odd_div_two (finite_field.odd_card_of_char_ne_two hF), mul_comm, pow_mul, pow_two] at h₁\n  exact mul_self_eq_one_iff.mp h₁\n#align pow_dichotomy pow_dichotomy\n\n",
 "pow_card_sub_one_eq_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≡ [ZMOD ]» -/\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem int.modeq.pow_card_sub_one_eq_one {p : ℕ} (hp : Nat.Prime p) {n : ℤ} (hpn : IsCoprime n p) :\n    «expr ≡ [ZMOD ]» (n ^ (p - 1)) 1 p := by\n  haveI : Fact p.prime := ⟨hp⟩\n  have : ¬(n : ZMod p) = 0 :=\n    by\n    rw [CharP.int_cast_eq_zero_iff _ p, ← (nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]\n    · exact hpn.symm\n    exact zmod.char_p p\n  simpa [← ZMod.int_cast_eq_int_cast_iff] using zmod.pow_card_sub_one_eq_one this\n#align int.modeq.pow_card_sub_one_eq_one int.modeq.pow_card_sub_one_eq_one\n\n",
 "pow_card_pow":
 "@[simp]\ntheorem pow_card_pow {n p : ℕ} [Fact p.prime] (x : ZMod p) : x ^ p ^ n = x :=\n  by\n  induction' n with n ih\n  · simp\n  · simp [pow_succ, pow_mul, ih, pow_card]\n#align pow_card_pow pow_card_pow\n\n",
 "pow_card":
 "/-- A variation on Fermat's little theorem. See `zmod.pow_card_sub_one_eq_one` -/\n@[simp]\ntheorem pow_card {p : ℕ} [Fact p.prime] (x : ZMod p) : x ^ p = x :=\n  by\n  have h := finite_field.pow_card x\n  rwa [ZMod.card p] at h\n#align pow_card pow_card\n\n",
 "order_of_units_dvd_card_sub_one":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\ntheorem order_of_units_dvd_card_sub_one {p : ℕ} [Fact p.prime] (u : «expr ˣ» (ZMod p)) : orderOf u ∣ p - 1 :=\n  orderOf_dvd_of_pow_eq_one <| units_pow_card_sub_one_eq_one _ _\n#align order_of_units_dvd_card_sub_one order_of_units_dvd_card_sub_one\n\n",
 "order_of_dvd_card_sub_one":
 "theorem order_of_dvd_card_sub_one {p : ℕ} [Fact p.prime] {a : ZMod p} (ha : a ≠ 0) : orderOf a ∣ p - 1 :=\n  orderOf_dvd_of_pow_eq_one <| pow_card_sub_one_eq_one ha\n#align order_of_dvd_card_sub_one order_of_dvd_card_sub_one\n\n",
 "odd_card_of_char_ne_two":
 "theorem odd_card_of_char_ne_two (hF : ringChar F ≠ 2) : Fintype.card F % 2 = 1 :=\n  Nat.mod_two_ne_zero.mp (mt even_card_iff_char_two.mpr hF)\n#align odd_card_of_char_ne_two odd_card_of_char_ne_two\n\n",
 "is_square_of_char_two":
 "/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem is_square_of_char_two (hF : ringChar F = 2) (a : F) : IsSquare a :=\n  haveI hF' : CharP F 2 := ringChar.of_eq hF\n  isSquare_of_charTwo' a\n#align is_square_of_char_two is_square_of_char_two\n\n",
 "is_square_iff":
 "/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem is_square_iff (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) : IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n  by\n  apply (iff_congr _ (by simp [Units.ext_iff])).mp (finite_field.unit_is_square_iff hF (Units.mk0 a ha))\n  simp only [IsSquare, Units.ext_iff, Units.val_mk0, Units.val_mul]\n  constructor\n  · rintro ⟨y, hy⟩\n    exact ⟨y, hy⟩\n  · rintro ⟨y, rfl⟩\n    have hy : y ≠ 0 := by\n      rintro rfl\n      simpa [zero_pow] using ha\n    refine' ⟨Units.mk0 y hy, _⟩\n    simp\n#align is_square_iff is_square_iff\n\n",
 "frobenius_zmod":
 "@[simp]\ntheorem frobenius_zmod (p : ℕ) [Fact p.prime] : frobenius (ZMod p) p = RingHom.id _ :=\n  by\n  ext a\n  rw [frobenius_def, zmod.pow_card, RingHom.id_apply]\n#align frobenius_zmod frobenius_zmod\n\n",
 "frobenius_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\ntheorem frobenius_pow {p : ℕ} [Fact p.prime] [CharP K p] {n : ℕ} (hcard : exprq = p ^ n) : frobenius K p ^ n = 1 :=\n  by\n  ext; conv_rhs => rw [RingHom.one_def, RingHom.id_apply, ← pow_card x, hcard]; clear hcard\n  induction n; · simp\n  rw [pow_succ, pow_succ', pow_mul, RingHom.mul_def, RingHom.comp_apply, frobenius_def, n_ih]\n#align frobenius_pow frobenius_pow\n\n",
 "forall_pow_eq_one_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\ntheorem forall_pow_eq_one_iff (i : ℕ) : (∀ x : «expr ˣ» K, x ^ i = 1) ↔ exprq - 1 ∣ i := by\n  classical\n    obtain ⟨x, hx⟩ := is_cyclic.exists_generator («expr ˣ» K)\n    rw [← Fintype.card_units, ← order_of_eq_card_of_forall_mem_zpowers hx, orderOf_dvd_iff_pow_eq_one]\n    constructor\n    · intro h\n      apply h\n    · intro h y\n      simp_rw [← mem_powers_iff_mem_zpowers] at hx\n      rcases hx y with ⟨j, rfl⟩\n      rw [← pow_mul, mul_comm, pow_mul, h, one_pow]\n#align forall_pow_eq_one_iff forall_pow_eq_one_iff\n\n",
 "expand_card":
 "theorem expand_card {p : ℕ} [Fact p.prime] (f : Polynomial (ZMod p)) : expand (ZMod p) p f = f ^ p :=\n  by\n  have h := finite_field.expand_card f\n  rwa [ZMod.card p] at h\n#align expand_card expand_card\n\n",
 "exists_root_sum_quadratic":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-- If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. -/\ntheorem exists_root_sum_quadratic [Fintype R] {f g : polynomial R} (hf2 : degree f = 2) (hg2 : degree g = 2)\n    (hR : Fintype.card R % 2 = 1) : ∃ a b, f.eval a + g.eval b = 0 :=\n  letI := Classical.decEq R\n  suffices ¬Disjoint (univ.image fun x : R => eval x f) (univ.image fun x : R => eval x (-g))\n    by\n    simp only [disjoint_left, mem_image] at this\n    push_neg  at this\n    rcases this with ⟨x, ⟨a, _, ha⟩, ⟨b, _, hb⟩⟩\n    exact ⟨a, b, by rw [ha, ← hb, eval_neg, neg_add_self]⟩\n  fun hd : Disjoint _ _ =>\n  lt_irrefl (2 * ((univ.image fun x : R => eval x f) ∪ univ.image fun x : R => eval x (-g)).card) <|\n    calc\n      2 * ((univ.image fun x : R => eval x f) ∪ univ.image fun x : R => eval x (-g)).card ≤ 2 * Fintype.card R :=\n        nat.mul_le_mul_left _ (Finset.card_le_univ _)\n      _ = Fintype.card R + Fintype.card R := (two_mul _)\n      _ <\n          nat_degree f * (univ.image fun x : R => eval x f).card +\n            nat_degree (-g) * (univ.image fun x : R => eval x (-g)).card :=\n        (add_lt_add_of_lt_of_le\n          (lt_of_le_of_ne (card_image_polynomial_eval (by rw [hf2] <;> exact by decide))\n            (mt (congr_arg (· % 2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR])))\n          (card_image_polynomial_eval (by rw [degree_neg, hg2] <;> exact by decide)))\n      _ = 2 * ((univ.image fun x : R => eval x f) ∪ univ.image fun x : R => eval x (-g)).card := by\n        rw [card_disjoint_union hd] <;>\n          simp [nat_degree_eq_of_degree_eq_some hf2, nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]\n      \n#align exists_root_sum_quadratic exists_root_sum_quadratic\n\n",
 "exists_nonsquare":
 "/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem exists_nonsquare (hF : ringChar F ≠ 2) : ∃ a : F, ¬IsSquare a :=\n  by\n  -- Idea: the squaring map on `F` is not injective, hence not surjective\n  let sq : F → F := fun x => x ^ 2\n  have h : ¬injective sq := by\n    simp only [injective, not_forall, exists_prop]\n    refine' ⟨-1, 1, _, Ring.neg_one_ne_one_of_char_ne_two hF⟩\n    simp only [sq, one_pow, neg_one_sq]\n  rw [Finite.injective_iff_surjective] at h\n  -- sq not surjective\n  simp_rw [IsSquare, ← pow_two, @eq_comm _ _ (_ ^ 2)]\n  push_neg  at h⊢\n  exact h\n#align exists_nonsquare exists_nonsquare\n\n",
 "even_card_of_char_two":
 "theorem even_card_of_char_two (hF : ringChar F = 2) : Fintype.card F % 2 = 0 :=\n  even_card_iff_char_two.mp hF\n#align even_card_of_char_two even_card_of_char_two\n\n",
 "even_card_iff_char_two":
 "/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem even_card_iff_char_two : ringChar F = 2 ↔ Fintype.card F % 2 = 0 :=\n  by\n  rcases finite_field.card F (ringChar F) with ⟨n, hp, h⟩\n  rw [h, Nat.pow_mod]\n  constructor\n  · intro hF\n    rw [hF]\n    simp only [Nat.bit0_mod_two, zero_pow', ne.def, PNat.ne_zero, not_false_iff, nat.zero_mod]\n  · rw [← Nat.even_iff, Nat.even_pow]\n    rintro ⟨hev, hnz⟩\n    rw [Nat.even_iff, Nat.mod_mod] at hev\n    exact (Nat.Prime.eq_two_or_odd hp).resolve_right (ne_of_eq_of_ne hev zero_ne_one)\n#align even_card_iff_char_two even_card_iff_char_two\n\n",
 "cast_card_eq_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n@[simp]\ntheorem cast_card_eq_zero : (exprq : K) = 0 :=\n  by\n  rcases CharP.exists K with ⟨p, _char_p⟩; skip\n  rcases card K p with ⟨n, hp, hn⟩\n  simp only [char_p.cast_eq_zero_iff K p, hn]\n  conv =>\n    congr\n    rw [← pow_one p]\n  exact pow_dvd_pow _ n.2\n#align cast_card_eq_zero cast_card_eq_zero\n\n",
 "card_units":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n@[simp]\ntheorem card_units (p : ℕ) [Fact p.prime] : Fintype.card («expr ˣ» (ZMod p)) = p - 1 := by rw [Fintype.card_units, card]\n#align card_units card_units\n\n",
 "card_image_polynomial_eval":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Joey van Langen, Casper Putz\n-/\n/-- The cardinality of a field is at most `n` times the cardinality of the image of a degree `n`\n  polynomial -/\ntheorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : polynomial R} (hp : 0 < p.degree) :\n    Fintype.card R ≤ natDegree p * (univ.image fun x => eval x p).card :=\n  Finset.card_le_mul_card_image _ _ fun a _ =>\n    calc\n      _ = (p - C a).roots.to_finset.card := congr_arg card (by simp [Finset.ext_iff, mem_roots_sub_C hp])\n      _ ≤ (p - C a).roots.card := (Multiset.toFinset_card_le _)\n      _ ≤ _ := card_roots_sub_C' hp\n      \n#align card_image_polynomial_eval card_image_polynomial_eval\n\n",
 "card_eq_pow_finrank":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\n-- should this go in a namespace?\n-- finite_dimensional would be natural,\n-- but we don't assume it...\ntheorem card_eq_pow_finrank [Fintype V] : Fintype.card V = exprq ^ FiniteDimensional.finrank K V :=\n  by\n  let b := IsNoetherian.finsetBasis K V\n  rw [Module.card_fintype b, ← FiniteDimensional.finrank_eq_card_basis b]\n#align card_eq_pow_finrank card_eq_pow_finrank\n\n",
 "card'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n-- this statement doesn't use `q` because we want `K` to be an explicit parameter\ntheorem card' : ∃ (p : ℕ)(n : «exprℕ+»), Nat.Prime p ∧ Fintype.card K = p ^ (n : ℕ) :=\n  let ⟨p, hc⟩ := CharP.exists K\n  ⟨p, @finite_field.card K _ _ p hc⟩\n#align card' card'\n\n",
 "card":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℕ+» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprq -/\ntheorem card (p : ℕ) [CharP K p] : ∃ n : «exprℕ+», Nat.Prime p ∧ exprq = p ^ (n : ℕ) :=\n  by\n  haveI hp : Fact p.prime := ⟨CharP.char_is_prime K p⟩\n  letI : Module (ZMod p) K := { (ZMod.castHom dvd_rfl K : «expr →+* » (ZMod p) _).to_module with }\n  obtain ⟨n, h⟩ := VectorSpace.card_fintype (ZMod p) K\n  rw [ZMod.card] at h\n  refine' ⟨⟨n, _⟩, hp.1, h⟩\n  apply or.resolve_left (nat.eq_zero_or_pos n)\n  rintro rfl\n  rw [pow_zero] at h\n  have : (0 : K) = 1 := by apply fintype.card_le_one_iff.mp (le_of_eq h)\n  exact absurd this zero_ne_one\n#align card card\n\n",
 "X_pow_card_sub_X_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem X_pow_card_sub_X_ne_zero (hp : 1 < p) : (X ^ p - X : polynomial K') ≠ 0 :=\n  ne_zero_of_natDegree_gt <|\n    calc\n      1 < _ := hp\n      _ = _ := (X_pow_card_sub_X_nat_degree_eq K' hp).symm\n      \n#align X_pow_card_sub_X_ne_zero X_pow_card_sub_X_ne_zero\n\n",
 "X_pow_card_sub_X_nat_degree_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem X_pow_card_sub_X_nat_degree_eq (hp : 1 < p) : (X ^ p - X : polynomial K').nat_degree = p :=\n  by\n  have h1 : (X : polynomial K').degree < (X ^ p : polynomial K').degree :=\n    by\n    rw [degree_X_pow, degree_X]\n    exact_mod_cast hp\n  rw [nat_degree_eq_of_degree_eq (degree_sub_eq_left_of_degree_lt h1), nat_degree_X_pow]\n#align X_pow_card_sub_X_nat_degree_eq X_pow_card_sub_X_nat_degree_eq\n\n",
 "X_pow_card_pow_sub_X_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem X_pow_card_pow_sub_X_ne_zero (hn : n ≠ 0) (hp : 1 < p) : (X ^ p ^ n - X : polynomial K') ≠ 0 :=\n  X_pow_card_sub_X_ne_zero K' <| Nat.one_lt_pow _ _ (nat.pos_of_ne_zero hn) hp\n#align X_pow_card_pow_sub_X_ne_zero X_pow_card_pow_sub_X_ne_zero\n\n",
 "X_pow_card_pow_sub_X_nat_degree_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem X_pow_card_pow_sub_X_nat_degree_eq (hn : n ≠ 0) (hp : 1 < p) :\n    (X ^ p ^ n - X : polynomial K').nat_degree = p ^ n :=\n  X_pow_card_sub_X_nat_degree_eq K' <| Nat.one_lt_pow _ _ (nat.pos_of_ne_zero hn) hp\n#align X_pow_card_pow_sub_X_nat_degree_eq X_pow_card_pow_sub_X_nat_degree_eq\n\n"}