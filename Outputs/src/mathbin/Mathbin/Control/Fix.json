{"fix_def'":
 "theorem fix_def' {x : α} (h' : ¬∃ i, (Fix.approx f i x).dom) : Part.fix f x = none := by\n  dsimp [Part.fix] <;> rw [assert_neg h']\n#align fix_def' fix_def'\n\n",
 "fix_def":
 "/-\nCopyright (c) 2020 Simon Hudon. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Simon Hudon\n-/\nprotected theorem fix_def {x : α} (h' : ∃ i, (Fix.approx f i x).dom) :\n    Part.fix f x = Fix.approx f (nat.succ <| nat.find h') x :=\n  by\n  let p := fun i : ℕ => (fix.approx f i x).dom\n  have : p (nat.find h') := nat.find_spec h'\n  generalize hk : nat.find h' = k\n  replace hk : nat.find h' = k + (@upto.zero p).val := hk\n  rw [hk] at this\n  revert hk\n  dsimp [Part.fix]; rw [assert_pos h']; revert this\n  generalize upto.zero = z; intros\n  suffices : ∀ x', well_founded.fix (fix._proof_1 f x h') (fix_aux f) z x' = fix.approx f (succ k) x'\n  exact this _\n  induction k generalizing z <;> intro\n  · rw [fix.approx, well_founded.fix_eq, fix_aux]\n    congr\n    ext : 1\n    rw [assert_neg]\n    rfl\n    rw [nat.zero_add] at this\n    simpa only [not_not, subtype.val_eq_coe]\n  · rw [fix.approx, well_founded.fix_eq, fix_aux]\n    congr\n    ext : 1\n    have hh : ¬(fix.approx f z.val x).dom := by\n      apply nat.find_min h'\n      rw [hk, nat.succ_add, ← nat.add_succ]\n      apply nat.lt_of_succ_le\n      apply nat.le_add_left\n    rw [succ_add_eq_succ_add] at this hk\n    rw [assert_pos hh, k_ih (upto.succ z hh) this hk]\n#align fix_def fix_def\n\n"}