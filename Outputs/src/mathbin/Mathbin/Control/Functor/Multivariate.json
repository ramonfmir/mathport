{"of_mem_supp":
 "/-\nCopyright (c) 2018 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Mario Carneiro, Simon Hudon\n-/\ntheorem of_mem_supp {α : typevec n} {x : F α} {p : ∀ ⦃i⦄, α i → Prop} (h : liftp p x) (i : fin2 n) :\n    ∀ y ∈ supp x i, p y := fun y hy => hy h\n#align of_mem_supp of_mem_supp\n\n",
 "map_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\ntheorem map_map (g : typevec.arrow α β) (h : typevec.arrow β γ) (x : F α) :\n    mvfunctor.map h (mvfunctor.map g x) = mvfunctor.map (typevec.comp h g) x :=\n  eq.symm <| comp_map _ _ _\n#align map_map map_map\n\n",
 "liftr_last_rel_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem liftr_last_rel_iff (x y : F (typevec.append_fun α β)) :\n    liftr' (rel_last' _ rr) x y ↔ liftr (rel_last _ rr) x y :=\n  by\n  dsimp only [liftr, liftr']\n  apply exists_iff_exists_of_mono F (f rr _ _) (g rr _ _)\n  · ext (i⟨x, _⟩) : 2\n    cases i <;> rfl\n  · intros\n    rw [mvfunctor.map_map, mvfunctor.map_map, (typevec.comp · ·), (typevec.comp · ·)]\n    congr <;> ext (i⟨x, _⟩) <;> cases i <;> rfl\n#align liftr_last_rel_iff liftr_last_rel_iff\n\n",
 "liftr_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\ntheorem liftr_def (x y : F α) :\n    liftr' r x y ↔\n      ∃ u : F (subtype_ r),\n        mvfunctor.map (typevec.comp typevec.prod.fst (subtype_val r)) u = x ∧\n          mvfunctor.map (typevec.comp typevec.prod.snd (subtype_val r)) u = y :=\n  exists_iff_exists_of_mono _ _ _ (to_subtype'_of_subtype' r)\n    (by simp only [map_map, comp_assoc, subtype_val_to_subtype'] <;> simp [comp])\n#align liftr_def liftr_def\n\n",
 "liftp_last_pred_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:219:4: warning: unsupported binary notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.append_fun -/\ntheorem liftp_last_pred_iff {β} (p : β → Prop) (x : F (typevec.append_fun α β)) :\n    liftp' (pred_last' _ p) x ↔ liftp (pred_last _ p) x :=\n  by\n  dsimp only [liftp, liftp']\n  apply exists_iff_exists_of_mono F (f _ n α) (g _ n α)\n  · ext (i⟨x, _⟩)\n    cases i <;> rfl\n  · intros\n    rw [mvfunctor.map_map, (typevec.comp · ·)]\n    congr <;> ext (i⟨x, _⟩) <;> cases i <;> rfl\n#align liftp_last_pred_iff liftp_last_pred_iff\n\n",
 "liftp_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem liftp_def (x : F α) : liftp' p x ↔ ∃ u : F (subtype_ p), mvfunctor.map (subtype_val p) u = x :=\n  exists_iff_exists_of_mono F _ _ (to_subtype_of_subtype p) (by simp [mvfunctor.map_map])\n#align liftp_def liftp_def\n\n",
 "id_map'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n@[simp]\ntheorem id_map' (x : F α) : mvfunctor.map (fun i a => a) x = x :=\n  id_map x\n#align id_map' id_map'ₓ\n\n",
 "id_map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n@[simp]\ntheorem id_map (x : F α) : mvfunctor.map typevec.id x = x :=\n  id_map x\n#align id_map id_map\n\n",
 "exists_iff_exists_of_mono":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.arrow -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `typevec.comp -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `mvfunctor.map -/\ntheorem exists_iff_exists_of_mono {p : F α → Prop} {q : F β → Prop} (f : typevec.arrow α β) (g : typevec.arrow β α)\n    (h₀ : typevec.comp f g = id) (h₁ : ∀ u : F α, p u ↔ q (mvfunctor.map f u)) : (∃ u : F α, p u) ↔ ∃ u : F β, q u :=\n  by\n  constructor <;> rintro ⟨u, h₂⟩ <;> [use mvfunctor.map f u, use mvfunctor.map g u]\n  · apply (h₁ u).mp h₂\n  · apply (h₁ _).mpr _\n    simp only [mvfunctor.map_map, h₀, is_lawful_mvfunctor.id_map, h₂]\n#align exists_iff_exists_of_mono exists_iff_exists_of_mono\n\n"}