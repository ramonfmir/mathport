{"discr_zero_of_not_linear_independent":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- If `b` is not linear independent, then `algebra.discr A b = 0`. -/\ntheorem discr_zero_of_not_linear_independent [IsDomain A] {b : ι → B} (hli : ¬linear_independent A b) : discr A b = 0 :=\n  by\n  classical\n    obtain ⟨g, hg, i, hi⟩ := fintype.not_linear_independent_iff.1 hli\n    have : (trace_matrix A b).mul_vec g = 0 := by\n      ext i\n      have : ∀ j, (trace A B) (b i * b j) * g j = (trace A B) («expr • » (g j) (b j) * b i) :=\n        by\n        intro j\n        simp [mul_comm]\n      simp only [mul_vec, dot_product, trace_matrix, pi.zero_apply, trace_form_apply, fun j => this j, ←\n        linear_map.map_sum, ← sum_mul, hg, zero_mul, linear_map.map_zero]\n    by_contra h\n    rw [discr_def] at h\n    simpa [matrix.eq_zero_of_mul_vec_eq_zero h this] using hi\n#align discr_zero_of_not_linear_independent discr_zero_of_not_linear_independent\n\n",
 "discr_reindex":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⇑ » -/\n@[simp]\ntheorem discr_reindex (b : basis ι A B) (f : «expr ≃ » ι ι') : discr A (b ∘ «expr⇑ » f.symm) = discr A b := by\n  classical rw [← basis.coe_reindex, discr_def, trace_matrix_reindex, det_reindex_self, ← discr_def]\n#align discr_reindex discr_reindex\n\n",
 "discr_power_basis_eq_prod''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A variation of `of_power_basis_eq_prod`. -/\ntheorem discr_power_basis_eq_prod'' [is_separable K L] (e : «expr ≃ » (fin pb.dim) («expr →ₐ[ ] » L K E)) :\n    algebra_map K E (discr K pb.basis) =\n      (-1) ^ (exprn * (exprn - 1) / 2) *\n        finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n          (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ioi i)\n            ((e j pb.gen - e i pb.gen) * (e i pb.gen - e j pb.gen))) :=\n  by\n  rw [discr_power_basis_eq_prod' _ _ _ e]\n  simp_rw [fun i j => neg_eq_neg_one_mul ((e j pb.gen - e i pb.gen) * (e i pb.gen - e j pb.gen)), prod_mul_distrib]\n  congr\n  simp only [prod_pow_eq_pow_sum, prod_const]\n  congr\n  rw [← @Nat.cast_inj (exprℚ), nat.cast_sum]\n  have : ∀ x : fin pb.dim, ↑x + 1 ≤ pb.dim := by simp [Nat.succ_le_iff, Fin.is_lt]\n  simp_rw [fin.card_Ioi, nat.sub_sub, add_comm 1]\n  simp only [Nat.cast_sub, this, finset.card_fin, nsmul_eq_mul, sum_const, sum_sub_distrib, Nat.cast_add, Nat.cast_one,\n    sum_add_distrib, mul_one]\n  rw [← nat.cast_sum, ← @finset.sum_range ℕ _ pb.dim fun i => i, sum_range_id]\n  have hn : exprn = pb.dim := by\n    rw [← alg_hom.card K L E, ← fintype.card_fin pb.dim]\n    exact card_congr (equiv.symm e)\n  have h₂ : 2 ∣ pb.dim * (pb.dim - 1) := even_iff_two_dvd.1 (nat.even_mul_self_pred _)\n  have hne : ((2 : ℕ) : exprℚ) ≠ 0 := by simp\n  have hle : 1 ≤ pb.dim :=\n    by\n    rw [← hn, Nat.one_le_iff_ne_zero, ← zero_lt_iff, finite_dimensional.finrank_pos_iff]\n    infer_instance\n  rw [hn, Nat.cast_div h₂ hne, nat.cast_mul, Nat.cast_sub hle]\n  field_simp\n  ring\n#align discr_power_basis_eq_prod'' discr_power_basis_eq_prod''\n\n",
 "discr_power_basis_eq_prod'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- A variation of `of_power_basis_eq_prod`. -/\ntheorem discr_power_basis_eq_prod' [is_separable K L] (e : «expr ≃ » (fin pb.dim) («expr →ₐ[ ] » L K E)) :\n    algebra_map K E (discr K pb.basis) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ioi i)\n          (-((e j pb.gen - e i pb.gen) * (e i pb.gen - e j pb.gen)))) :=\n  by\n  rw [discr_power_basis_eq_prod _ _ _ e]\n  congr ; ext i; congr ; ext j\n  ring\n#align discr_power_basis_eq_prod' discr_power_basis_eq_prod'\n\n",
 "discr_power_basis_eq_prod":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.prod -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod -/\n/-- The discriminant of a power basis. -/\ntheorem discr_power_basis_eq_prod (e : «expr ≃ » (fin pb.dim) («expr →ₐ[ ] » L K E)) [is_separable K L] :\n    algebra_map K E (discr K pb.basis) =\n      finset.prod_univ \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod_univ\"\n        (finset.prod \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.prod\" (Ioi i)\n          ((e j pb.gen - e i pb.gen) ^ 2)) :=\n  by\n  rw [discr_eq_det_embeddings_matrix_reindex_pow_two K E pb.basis e, embeddings_matrix_reindex_eq_vandermonde,\n    det_transpose, det_vandermonde, ← prod_pow]\n  congr ; ext i\n  rw [← prod_pow]\n#align discr_power_basis_eq_prod discr_power_basis_eq_prod\n\n",
 "discr_power_basis_eq_norm":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprn -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprn -/\n/-- Formula for the discriminant of a power basis using the norm of the field extension. -/\ntheorem discr_power_basis_eq_norm [is_separable K L] :\n    discr K pb.basis = (-1) ^ (exprn * (exprn - 1) / 2) * norm K (aeval pb.gen (minpoly K pb.gen).derivative) :=\n  by\n  let E := algebraic_closure L\n  letI := fun a b : E => classical.prop_decidable (eq a b)\n  have e : «expr ≃ » (fin pb.dim) («expr →ₐ[ ] » L K E) :=\n    by\n    refine' equiv_of_card_eq _\n    rw [fintype.card_fin, alg_hom.card]\n    exact (power_basis.finrank pb).symm\n  have hnodup : (map (algebra_map K E) (minpoly K pb.gen)).roots.nodup :=\n    nodup_roots (separable.map (is_separable.separable K pb.gen))\n  have hroots : ∀ σ : «expr →ₐ[ ] » L K E, σ pb.gen ∈ (map (algebra_map K E) (minpoly K pb.gen)).roots :=\n    by\n    intro σ\n    rw [mem_roots, is_root.def, eval_map, ← aeval_def, aeval_alg_hom_apply]\n    repeat' simp [minpoly.ne_zero (is_separable.is_integral K pb.gen)]\n  apply (algebra_map K E).injective\n  rw [RingHom.map_mul, RingHom.map_pow, RingHom.map_neg, RingHom.map_one, discr_power_basis_eq_prod'' _ _ _ e]\n  congr\n  rw [norm_eq_prod_embeddings, prod_prod_Ioi_mul_eq_prod_prod_off_diag]\n  conv_rhs =>\n    congr\n    skip\n    ext\n    rw [← aeval_alg_hom_apply,\n      aeval_root_derivative_of_splits (minpoly.monic (is_separable.is_integral K pb.gen))\n        (is_alg_closed.splits_codomain _) (hroots σ),\n      ← finset.prod_mk _ (hnodup.erase _)]\n  rw [prod_sigma', prod_sigma']\n  refine'\n    prod_bij (fun i hi => ⟨e i.2, e i.1 pb.gen⟩) (fun i hi => _) (fun i hi => by simp at hi) (fun i j hi hj hij => _)\n      fun σ hσ => _\n  · simp only [true_and_iff, Finset.mem_mk, mem_univ, mem_sigma]\n    rw [Multiset.mem_erase_of_ne fun h => _]\n    · exact hroots _\n    · simp only [true_and_iff, mem_univ, ne.def, mem_sigma, mem_compl, mem_singleton] at hi\n      rw [← power_basis.lift_equiv_apply_coe, ← power_basis.lift_equiv_apply_coe] at h\n      exact hi (e.injective <| pb.lift_equiv.injective <| subtype.eq h.symm)\n  · simp only [equiv.apply_eq_iff_eq, heq_iff_eq] at hij\n    have h := hij.2\n    rw [← power_basis.lift_equiv_apply_coe, ← power_basis.lift_equiv_apply_coe] at h\n    refine' sigma.eq (Equiv.injective e (Equiv.injective _ (subtype.eq h))) (by simp [hij.1])\n  · simp only [true_and_iff, Finset.mem_mk, mem_univ, mem_sigma] at hσ⊢\n    simp only [sigma.exists, exists_prop, mem_compl, mem_singleton, ne.def]\n    refine' ⟨e.symm (power_basis.lift pb σ.2 _), e.symm σ.1, ⟨fun h => _, sigma.eq _ _⟩⟩\n    · rw [aeval_def, eval₂_eq_eval_map, ← is_root.def, ← mem_roots]\n      · exact Multiset.erase_subset _ _ hσ\n      · simp [minpoly.ne_zero (is_separable.is_integral K pb.gen)]\n    · replace h := alg_hom.congr_fun (Equiv.injective _ h) pb.gen\n      rw [power_basis.lift_gen] at h\n      rw [← h] at hσ\n      exact hnodup.not_mem_erase hσ\n    all_goals simp\n#align discr_power_basis_eq_norm discr_power_basis_eq_norm\n\n",
 "discr_of_matrix_vec_mul":
 "/-- Relation between `algebra.discr A ι b` and\n`algebra.discr A ((P.map (algebra_map A B)).vec_mul b)`. -/\ntheorem discr_of_matrix_vec_mul [decidable_eq ι] (b : ι → B) (P : matrix ι ι A) :\n    discr A ((P.map (algebra_map A B)).vec_mul b) = P.det ^ 2 * discr A b := by\n  rw [discr_def, trace_matrix_of_matrix_vec_mul, det_mul, det_mul, det_transpose, mul_comm, ← mul_assoc, discr_def,\n    pow_two]\n#align discr_of_matrix_vec_mul discr_of_matrix_vec_mul\n\n",
 "discr_of_matrix_mul_vec":
 "/-- Relation between `algebra.discr A ι b` and\n`algebra.discr A ((P.map (algebra_map A B)).mul_vec b)`. -/\ntheorem discr_of_matrix_mul_vec [decidable_eq ι] (b : ι → B) (P : matrix ι ι A) :\n    discr A ((P.map (algebra_map A B)).mul_vec b) = P.det ^ 2 * discr A b := by\n  rw [discr_def, trace_matrix_of_matrix_mul_vec, det_mul, det_mul, det_transpose, mul_comm, ← mul_assoc, discr_def,\n    pow_two]\n#align discr_of_matrix_mul_vec discr_of_matrix_mul_vec\n\n",
 "discr_not_zero_of_basis":
 "/-- Over a field, if `b` is a basis, then `algebra.discr K b ≠ 0`. -/\ntheorem discr_not_zero_of_basis [is_separable K L] (b : basis ι K L) : discr K b ≠ 0 :=\n  by\n  cases isEmpty_or_nonempty ι\n  · simp [discr]\n  · have := span_eq_top_of_linear_independent_of_card_eq_finrank b.linear_independent (finrank_eq_card_basis b).symm\n    rw [discr_def, trace_matrix_def]\n    simp_rw [← basis.mk_apply b.linear_independent this.ge]\n    rw [← trace_matrix_def, trace_matrix_of_basis, ← bilin_form.nondegenerate_iff_det_ne_zero]\n    exact trace_form_nondegenerate _ _\n#align discr_not_zero_of_basis discr_not_zero_of_basis\n\n",
 "discr_mul_is_integral_mem_adjoin":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- Let `K` be the fraction field of an integrally closed domain `R` and let `L` be a finite\nseparable extension of `K`. Let `B : power_basis K L` be such that `is_integral R B.gen`.\nThen for all, `z : L` that are integral over `R`, we have\n`(discr K B.basis) • z ∈ adjoin R ({B.gen} : set L)`. -/\ntheorem discr_mul_is_integral_mem_adjoin [IsDomain R] [is_separable K L] [is_integrally_closed R] [is_fraction_ring R K]\n    {B : power_basis K L} (hint : (expris_integral) R B.gen) {z : L} (hz : (expris_integral) R z) :\n    «expr • » (discr K B.basis) z ∈ adjoin R ({B.gen} : set L) :=\n  by\n  have hinv : is_unit (trace_matrix K B.basis).det := by simpa [← discr_def] using discr_is_unit_of_basis _ B.basis\n  have H :\n    «expr • » (trace_matrix K B.basis).det ((trace_matrix K B.basis).mul_vec (B.basis.equiv_fun z)) =\n      «expr • » (trace_matrix K B.basis).det fun i => trace K L (z * B.basis i) :=\n    by\n    congr\n    exact trace_matrix_of_basis_mul_vec _ _\n  have cramer := mul_vec_cramer (trace_matrix K B.basis) fun i => trace K L (z * B.basis i)\n  suffices ∀ i, («expr • » (trace_matrix K B.basis).det (B.basis.equiv_fun z)) i ∈ («expr⊥» : subalgebra R K)\n    by\n    rw [← B.basis.sum_repr z, finset.smul_sum]\n    refine' subalgebra.sum_mem _ fun i hi => _\n    replace this := this i\n    rw [← discr_def, pi.smul_apply, mem_bot] at this\n    obtain ⟨r, hr⟩ := this\n    rw [basis.equiv_fun_apply] at hr\n    rw [← smul_assoc, ← hr, algebra_map_smul]\n    refine' subalgebra.smul_mem _ _ _\n    rw [B.basis_eq_pow i]\n    refine' subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _\n  intro i\n  rw [← H, ← mul_vec_smul] at cramer\n  replace cramer := congr_arg (mul_vec (trace_matrix K B.basis)⁻¹) cramer\n  rw [mul_vec_mul_vec, nonsing_inv_mul _ hinv, mul_vec_mul_vec, nonsing_inv_mul _ hinv, one_mul_vec, one_mul_vec] at\n    cramer\n  rw [← congr_fun cramer i, cramer_apply, det_apply]\n  refine' subalgebra.sum_mem _ fun σ _ => subalgebra.zsmul_mem _ (subalgebra.prod_mem _ fun j _ => _) _\n  by_cases hji : j = i\n  · simp only [update_column_apply, hji, eq_self_iff_true, power_basis.coe_basis]\n    exact\n      mem_bot.2\n        (is_integrally_closed.is_integral_iff.1 <| is_integral_trace <| is_integral_mul hz <| is_integral.pow hint _)\n  · simp only [update_column_apply, hji, power_basis.coe_basis]\n    exact\n      mem_bot.2\n        (is_integrally_closed.is_integral_iff.1 <|\n          is_integral_trace <| is_integral_mul (is_integral.pow hint _) (is_integral.pow hint _))\n#align discr_mul_is_integral_mem_adjoin discr_mul_is_integral_mem_adjoin\n\n",
 "discr_is_unit_of_basis":
 "/-- Over a field, if `b` is a basis, then `algebra.discr K b` is a unit. -/\ntheorem discr_is_unit_of_basis [is_separable K L] (b : basis ι K L) : is_unit (discr K b) :=\n  IsUnit.mk0 _ (discr_not_zero_of_basis _ _)\n#align discr_is_unit_of_basis discr_is_unit_of_basis\n\n",
 "discr_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/-- If `K` and `L` are fields and `is_scalar_tower R K L`, and `b : ι → L` satisfies\n` ∀ i, is_integral R (b i)`, then `is_integral R (discr K b)`. -/\ntheorem discr_is_integral {b : ι → L} (h : ∀ i, (expris_integral) R (b i)) : (expris_integral) R (discr K b) := by\n  classical\n    rw [discr_def]\n    exact is_integral.det fun i j => is_integral_trace (is_integral_mul (h i) (h j))\n#align discr_is_integral discr_is_integral\n\n",
 "discr_eq_discr_of_to_matrix_coeff_is_integral":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expris_integral -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-- If `b` and `b'` are `ℚ`-bases of a number field `K` such that\n`∀ i j, is_integral ℤ (b.to_matrix b' i j)` and `∀ i j, is_integral ℤ (b'.to_matrix b i j)` then\n`discr ℚ b = discr ℚ b'`. -/\ntheorem discr_eq_discr_of_to_matrix_coeff_is_integral [number_field K] {b : basis ι (exprℚ) K} {b' : basis ι' (exprℚ) K}\n    (h : ∀ i j, (expris_integral) ℤ (b.to_matrix b' i j)) (h' : ∀ i j, (expris_integral) ℤ (b'.to_matrix b i j)) :\n    discr (exprℚ) b = discr (exprℚ) b' :=\n  by\n  replace h' : ∀ i j, (expris_integral) ℤ (b'.to_matrix (b.reindex (b.index_equiv b')) i j)\n  · intro i j\n    convert h' i ((b.index_equiv b').symm j)\n    simpa\n  classical\n    rw [← (b.reindex (b.index_equiv b')).to_matrix_map_vec_mul b', discr_of_matrix_vec_mul, ← one_mul (discr (exprℚ) b),\n      basis.coe_reindex, discr_reindex]\n    congr\n    have hint : (expris_integral) ℤ ((b.reindex (b.index_equiv b')).to_matrix b').det :=\n      is_integral.det fun i j => h _ _\n    obtain ⟨r, hr⟩ := is_integrally_closed.is_integral_iff.1 hint\n    have hunit : is_unit r :=\n      by\n      have : (expris_integral) ℤ (b'.to_matrix (b.reindex (b.index_equiv b'))).det := is_integral.det fun i j => h' _ _\n      obtain ⟨r', hr'⟩ := is_integrally_closed.is_integral_iff.1 this\n      refine' isUnit_iff_exists_inv.2 ⟨r', _⟩\n      suffices algebra_map ℤ (exprℚ) (r * r') = 1\n        by\n        rw [← RingHom.map_one (algebra_map ℤ (exprℚ))] at this\n        exact (is_fraction_ring.injective ℤ (exprℚ)) this\n      rw [RingHom.map_mul, hr, hr', ← det_mul, basis.to_matrix_mul_to_matrix_flip, det_one]\n    rw [← RingHom.map_one (algebra_map ℤ (exprℚ)), ← hr]\n    cases' Int.isUnit_iff.1 hunit with hp hm\n    · simp [hp]\n    · simp [hm]\n#align discr_eq_discr_of_to_matrix_coeff_is_integral discr_eq_discr_of_to_matrix_coeff_is_integral\n\n",
 "discr_eq_det_embeddings_matrix_reindex_pow_two":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- If `L/K` is a field extension and `b : ι → L`, then `discr K b` is the square of the\ndeterminant of the matrix whose `(i, j)` coefficient is `σⱼ (b i)`, where `σⱼ : L →ₐ[K] E` is the\nembedding in an algebraically closed field `E` corresponding to `j : ι` via a bijection\n`e : ι ≃ (L →ₐ[K] E)`. -/\ntheorem discr_eq_det_embeddings_matrix_reindex_pow_two [decidable_eq ι] [is_separable K L]\n    (e : «expr ≃ » ι («expr →ₐ[ ] » L K E)) :\n    algebra_map K E (discr K b) = (embeddings_matrix_reindex K E b e).det ^ 2 := by\n  rw [discr_def, ring_hom.map_det, ring_hom.map_matrix_apply, trace_matrix_eq_embeddings_matrix_reindex_mul_trans,\n    det_mul, det_transpose, pow_two]\n#align discr_eq_det_embeddings_matrix_reindex_pow_two discr_eq_det_embeddings_matrix_reindex_pow_two\n\n",
 "discr_def":
 "/-\nCopyright (c) 2021 Riccardo Brasca. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Riccardo Brasca\n-/\ntheorem discr_def [decidable_eq ι] [fintype ι] (b : ι → B) : discr A b = (trace_matrix A b).det := by convert rfl\n#align discr_def discr_def\n\n"}