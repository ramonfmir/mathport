{"top_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n@[simp]\ntheorem top_N : («expr⊤» : I.filtration M).N = «expr⊤» :=\n  rfl\n#align top_N top_N\n\n",
 "supr_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨆ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , » -/\n@[simp]\ntheorem supr_N {ι : Sort _} (f : ι → I.filtration M) :\n    (supᵢ f).N =\n      «expr⨆ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨆ , »\" (f i).N :=\n  congr_arg supₛ (Set.range_comp _ _).symm\n#align supr_N supr_N\n\n",
 "sup_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊔ » -/\n@[simp]\ntheorem sup_N : («expr ⊔ » F F').N = «expr ⊔ » F.N F'.N :=\n  rfl\n#align sup_N sup_N\n\n",
 "submodule_span_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem submodule_span_single :\n    submodule.span (rees_algebra I)\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (single R i) (F.N i : set M))) =\n      F.submodule :=\n  by\n  rw [← submodule.span_closure, submodule_closure_single]\n  simp\n#align submodule_span_single submodule_span_single\n\n",
 "submodule_fg_iff_stable":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the components of a filtration are finitely generated, then the filtration is stable iff\nits associated submodule of is finitely generated.  -/\ntheorem submodule_fg_iff_stable (hF' : ∀ i, (F.N i).fg) : F.submodule.fg ↔ F.stable := by\n  classical\n    delta ideal.filtration.stable\n    simp_rw [← F.submodule_eq_span_le_iff_stable_ge]\n    constructor\n    · rintro H\n      apply\n        H.stablizes_of_supr_eq\n          ⟨fun n₀ =>\n            submodule.span _\n              («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n                («expr '' » (single R i) ↑(F.N i))),\n            _⟩\n      · dsimp\n        rw [← submodule.span_Union, ← submodule_span_single]\n        congr 1\n        ext\n        simp only [Set.mem_unionᵢ, Set.mem_image, SetLike.mem_coe, exists_prop]\n        constructor\n        · rintro ⟨-, i, -, e⟩\n          exact ⟨i, e⟩\n        · rintro ⟨i, e⟩\n          exact ⟨i, i, le_refl i, e⟩\n      · intro n m e\n        rw [submodule.span_le, Set.unionᵢ₂_subset_iff]\n        intro i hi\n        refine' (Set.Subset.trans _ (Set.subset_unionᵢ₂ i (hi.trans e : _))).trans submodule.subset_span\n        rfl\n    · rintro ⟨n, hn⟩\n      rw [hn]\n      simp_rw [submodule.span_Union₂, ← Finset.mem_range_succ_iff, supᵢ_subtype']\n      apply submodule.fg_supr\n      rintro ⟨i, hi⟩\n      obtain ⟨s, hs⟩ := hF' i\n      have :\n        submodule.span (rees_algebra I) (s.image (lsingle R i) : set (polynomial_module R M)) =\n          submodule.span _ («expr '' » (single R i) (F.N i : set M)) :=\n        by\n        rw [Finset.coe_image, ← submodule.span_span_of_tower R, ← submodule.map_span, hs]\n        rfl\n      rw [subtype.coe_mk, ← this]\n      exact ⟨_, rfl⟩\n#align submodule_fg_iff_stable submodule_fg_iff_stable\n\n",
 "submodule_eq_span_le_iff_stable_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →₀ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem submodule_eq_span_le_iff_stable_ge (n₀ : ℕ) :\n    F.submodule =\n        submodule.span _\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            («expr '' » (single R i) (F.N i : set M))) ↔\n      ∀ n ≥ n₀, «expr • » I (F.N n) = F.N (n + 1) :=\n  by\n  rw [← submodule_span_single, ← LE.le.le_iff_eq, submodule.span_le, Set.unionᵢ_subset_iff]\n  swap; · exact submodule.span_mono (Set.unionᵢ₂_subset_unionᵢ _ _)\n  constructor\n  · intro H n hn\n    refine' (F.smul_le n).antisymm _\n    intro x hx\n    obtain ⟨l, hl⟩ := (finsupp.mem_span_iff_total _ _ _).mp (H _ ⟨x, hx, rfl⟩)\n    replace hl := congr_arg (fun f : «expr →₀ » ℕ M => f (n + 1)) hl\n    dsimp only at hl\n    erw [finsupp.single_eq_same] at hl\n    rw [← hl, finsupp.total_apply, finsupp.sum_apply]\n    apply submodule.sum_mem _ _\n    rintro ⟨_, _, ⟨n', rfl⟩, _, ⟨hn', rfl⟩, m, hm, rfl⟩ -\n    dsimp only [subtype.coe_mk]\n    rw [subalgebra.smul_def, smul_single_apply, if_pos (show n' ≤ n + 1 by linarith)]\n    have e : n' ≤ n := by linarith\n    have := F.pow_smul_le_pow_smul (n - n') n' 1\n    rw [tsub_add_cancel_of_le e, pow_one, add_comm _ 1, ← add_tsub_assoc_of_le e, add_comm] at this\n    exact this (submodule.smul_mem_smul ((l _).2 <| n + 1 - n') hm)\n  · let F' :=\n      submodule.span (rees_algebra I)\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (single R i) (F.N i : set M)))\n    intro hF i\n    have : ∀ i ≤ n₀, «expr '' » (single R i) (F.N i : set M) ⊆ F' := fun i hi =>\n      Set.Subset.trans (Set.subset_unionᵢ₂ i hi) submodule.subset_span\n    induction' i with j hj\n    · exact this _ (zero_le _)\n    by_cases hj' : j.succ ≤ n₀\n    · exact this _ hj'\n    simp only [not_le, Nat.lt_succ_iff] at hj'\n    rw [nat.succ_eq_add_one, ← hF _ hj']\n    rintro _ ⟨m, hm, rfl⟩\n    apply submodule.smul_induction_on hm\n    · intro r hr m' hm'\n      rw [add_comm, ← monomial_smul_single]\n      exact F'.smul_mem ⟨_, rees_algebra.monomial_mem.mpr (by rwa [pow_one])⟩ (hj <| Set.mem_image_of_mem _ hm')\n    · intro x y hx hy\n      rw [map_add]\n      exact F'.add_mem hx hy\n#align submodule_eq_span_le_iff_stable_ge submodule_eq_span_le_iff_stable_ge\n\n",
 "submodule_closure_single":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\ntheorem submodule_closure_single :\n    add_submonoid.closure\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (single R i) (F.N i : set M))) =\n      F.submodule.to_add_submonoid :=\n  by\n  apply le_antisymm\n  · rw [add_submonoid.closure_le, Set.unionᵢ_subset_iff]\n    rintro i _ ⟨m, hm, rfl⟩ j\n    rw [single_apply]\n    split_ifs\n    · rwa [← h]\n    · exact (F.N j).zero_mem\n  · intro f hf\n    rw [← f.sum_single]\n    apply add_submonoid.sum_mem _ _\n    rintro c -\n    exact add_submonoid.subset_closure (Set.subset_unionᵢ _ c <| Set.mem_image_of_mem _ (hf c))\n#align submodule_closure_single submodule_closure_single\n\n",
 "stable_iff_exists_pow_smul_eq_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem stable_iff_exists_pow_smul_eq_of_ge : F.stable ↔ ∃ n₀, ∀ n ≥ n₀, F.N n = «expr • » (I ^ (n - n₀)) (F.N n₀) :=\n  by\n  refine' ⟨stable.exists_pow_smul_eq_of_ge, fun h => ⟨h.some, fun n hn => _⟩⟩\n  rw [h.some_spec n hn, h.some_spec (n + 1) (by linarith), smul_smul, ← pow_succ, tsub_add_eq_add_tsub hn]\n#align stable_iff_exists_pow_smul_eq_of_ge stable_iff_exists_pow_smul_eq_of_ge\n\n",
 "stable_filtration_stable":
 "theorem _root_.ideal.stable_filtration_stable (I : ideal R) (N : submodule R M) : (I.stable_filtration N).stable :=\n  by\n  use 0\n  intro n _\n  dsimp\n  rw [add_comm, pow_add, mul_smul, pow_one]\n#align ideal.stable_filtration_stable ideal.stable_filtration_stable\n\n",
 "pow_smul_le_pow_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem pow_smul_le_pow_smul (i j k : ℕ) : «expr • » (I ^ (i + k)) (F.N j) ≤ «expr • » (I ^ k) (F.N (i + j)) :=\n  by\n  rw [add_comm, pow_add, mul_smul]\n  exact submodule.smul_mono_right (F.pow_smul_le i j)\n#align pow_smul_le_pow_smul pow_smul_le_pow_smul\n\n",
 "pow_smul_le":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\ntheorem pow_smul_le (i j : ℕ) : «expr • » (I ^ i) (F.N j) ≤ F.N (i + j) :=\n  by\n  induction i\n  · simp\n  · rw [pow_succ, mul_smul, nat.succ_eq_add_one, add_assoc, add_comm 1, ← add_assoc]\n    exact (submodule.smul_mono_right i_ih).trans (F.smul_le _)\n#align pow_smul_le pow_smul_le\n\n",
 "of_le":
 "theorem stable.of_le [is_noetherian_ring R] [h : module.finite R M] (hF : F.stable) {F' : I.filtration M}\n    (hf : F' ≤ F) : F'.stable := by\n  haveI := is_noetherian_of_fg_of_noetherian' h.1\n  rw [← submodule_fg_iff_stable] at hF⊢\n  any_goals intro i; exact is_noetherian.noetherian _\n  have := is_noetherian_of_fg_of_noetherian _ hF\n  rw [is_noetherian_submodule] at this\n  exact this _ (OrderHomClass.mono (submodule_inf_hom M I) hf)\n#align stable.of_le stable.of_le\n\n",
 "mem_submodule":
 "@[simp]\ntheorem mem_submodule (f : polynomial_module R M) : f ∈ F.submodule ↔ ∀ i, f i ∈ F.N i :=\n  iff.rfl\n#align mem_submodule mem_submodule\n\n",
 "mem_infi_smul_pow_eq_bot_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem ideal.mem_infi_smul_pow_eq_bot_iff [is_noetherian_ring R] [hM : module.finite R M] (x : M) :\n    x ∈\n        («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n            («expr • » (I ^ i) («expr⊤»)) :\n          submodule R M) ↔\n      ∃ r : I, «expr • » (r : R) x = x :=\n  by\n  let N :=\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n        («expr • » (I ^ i) («expr⊤»)) :\n      submodule R M)\n  have hN : ∀ k, («expr ⊓ » (I.stable_filtration («expr⊤»)) (I.trivial_filtration N)).N k = N :=\n    by\n    intro k\n    exact inf_eq_right.mpr ((infᵢ_le _ k).trans <| le_of_eq <| by simp)\n  constructor\n  · haveI := is_noetherian_of_fg_of_noetherian' hM.out\n    obtain ⟨r, hr₁, hr₂⟩ := submodule.exists_mem_and_smul_eq_self_of_fg_of_le_smul I N (is_noetherian.noetherian N) _\n    · intro H\n      exact ⟨⟨r, hr₁⟩, hr₂ _ H⟩\n    obtain ⟨k, hk⟩ := (I.stable_filtration_stable («expr⊤»)).inter_right (I.trivial_filtration N)\n    have := hk k (le_refl _)\n    rw [hN, hN] at this\n    exact le_of_eq this.symm\n  · rintro ⟨r, eq⟩\n    rw [submodule.mem_infi]\n    intro i\n    induction' i with i hi\n    · simp\n    · rw [Nat.succ_eq_one_add, pow_add, ← smul_smul, pow_one, ← eq]\n      exact submodule.smul_mem_smul r.prop hi\n#align ideal.mem_infi_smul_pow_eq_bot_iff ideal.mem_infi_smul_pow_eq_bot_iff\n\n",
 "inter_right":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem stable.inter_right [is_noetherian_ring R] [h : module.finite R M] (hF : F.stable) : («expr ⊓ » F F').stable :=\n  hF.of_le inf_le_left\n#align stable.inter_right stable.inter_right\n\n",
 "inter_left":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem stable.inter_left [is_noetherian_ring R] [h : module.finite R M] (hF : F.stable) : («expr ⊓ » F' F).stable :=\n  hF.of_le inf_le_right\n#align stable.inter_left stable.inter_left\n\n",
 "infi_pow_smul_eq_bot_of_local_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\ntheorem ideal.infi_pow_smul_eq_bot_of_local_ring [is_noetherian_ring R] [local_ring R] [module.finite R M]\n    (h : I ≠ «expr⊤») :\n    («expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\"\n          («expr • » (I ^ i) («expr⊤»)) :\n        submodule R M) =\n      «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  intro x hx\n  obtain ⟨r, hr⟩ := (I.mem_infi_smul_pow_eq_bot_iff x).mp hx\n  have := local_ring.is_unit_one_sub_self_of_mem_nonunits _ (local_ring.le_maximal_ideal h r.prop)\n  apply this.smul_left_cancel.mp\n  swap; · infer_instance\n  simp [sub_smul, hr]\n#align ideal.infi_pow_smul_eq_bot_of_local_ring ideal.infi_pow_smul_eq_bot_of_local_ring\n\n",
 "infi_pow_eq_bot_of_local_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- **Krull's intersection theorem** for noetherian local rings. -/\ntheorem ideal.infi_pow_eq_bot_of_local_ring [is_noetherian_ring R] [local_ring R] (h : I ≠ «expr⊤») :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (I ^ i) = «expr⊥» :=\n  by\n  convert I.infi_pow_smul_eq_bot_of_local_ring h\n  ext i\n  rw [smul_eq_mul, ← ideal.one_eq_top, mul_one]\n  infer_instance\n#align ideal.infi_pow_eq_bot_of_local_ring ideal.infi_pow_eq_bot_of_local_ring\n\n",
 "infi_pow_eq_bot_of_is_domain":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/-- **Krull's intersection theorem** for noetherian domains. -/\ntheorem ideal.infi_pow_eq_bot_of_is_domain [is_noetherian_ring R] [IsDomain R] (h : I ≠ «expr⊤») :\n    «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (I ^ i) = «expr⊥» :=\n  by\n  rw [eq_bot_iff]\n  intro x hx\n  by_contra hx'\n  have := ideal.mem_infi_smul_pow_eq_bot_iff I x\n  simp_rw [smul_eq_mul, ← ideal.one_eq_top, mul_one] at this\n  obtain ⟨r, hr⟩ := this.mp hx\n  have := mul_right_cancel₀ hx' (hr.trans (one_mul x).symm)\n  exact I.eq_top_iff_one.not.mp h (this ▸ r.prop)\n#align ideal.infi_pow_eq_bot_of_is_domain ideal.infi_pow_eq_bot_of_is_domain\n\n",
 "infi_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⨅ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , » -/\n@[simp]\ntheorem infi_N {ι : Sort _} (f : ι → I.filtration M) :\n    (infᵢ f).N =\n      «expr⨅ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⨅ , »\" (f i).N :=\n  congr_arg infₛ (Set.range_comp _ _).symm\n#align infi_N infi_N\n\n",
 "inf_submodule":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\ntheorem inf_submodule : («expr ⊓ » F F').submodule = «expr ⊓ » F.submodule F'.submodule :=\n  by\n  ext\n  exact forall_and\n#align inf_submodule inf_submodule\n\n",
 "inf_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n@[simp]\ntheorem inf_N : («expr ⊓ » F F').N = «expr ⊓ » F.N F'.N :=\n  rfl\n#align inf_N inf_N\n\n",
 "exists_pow_smul_eq_of_ge":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem stable.exists_pow_smul_eq_of_ge : ∃ n₀, ∀ n ≥ n₀, F.N n = «expr • » (I ^ (n - n₀)) (F.N n₀) :=\n  by\n  obtain ⟨n₀, hn₀⟩ := h.exists_pow_smul_eq\n  use n₀\n  intro n hn\n  convert hn₀ (n - n₀)\n  rw [add_comm, tsub_add_cancel_of_le hn]\n#align stable.exists_pow_smul_eq_of_ge stable.exists_pow_smul_eq_of_ge\n\n",
 "exists_pow_smul_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem stable.exists_pow_smul_eq : ∃ n₀, ∀ k, F.N (n₀ + k) = «expr • » (I ^ k) (F.N n₀) :=\n  by\n  obtain ⟨n₀, hn⟩ := h\n  use n₀\n  intro k\n  induction k\n  · simp\n  · rw [nat.succ_eq_add_one, ← add_assoc, ← hn, k_ih, add_comm, pow_add, mul_smul, pow_one]\n    linarith\n#align stable.exists_pow_smul_eq stable.exists_pow_smul_eq\n\n",
 "exists_pow_inf_eq_pow_smul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ⊓ » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- **Artin-Rees lemma** -/\ntheorem ideal.exists_pow_inf_eq_pow_smul [is_noetherian_ring R] [h : module.finite R M] (N : submodule R M) :\n    ∃ k : ℕ,\n      ∀ n ≥ k,\n        «expr ⊓ » («expr • » (I ^ n) («expr⊤»)) N =\n          «expr • » (I ^ (n - k)) («expr ⊓ » («expr • » (I ^ k) («expr⊤»)) N) :=\n  ((I.stable_filtration_stable («expr⊤»)).inter_right (I.trivial_filtration N)).exists_pow_smul_eq_of_ge\n#align ideal.exists_pow_inf_eq_pow_smul ideal.exists_pow_inf_eq_pow_smul\n\n",
 "exists_forall_le":
 "theorem stable.exists_forall_le (h : F.stable) (e : F.N 0 ≤ F'.N 0) : ∃ n₀, ∀ n, F.N (n + n₀) ≤ F'.N n :=\n  by\n  obtain ⟨n₀, hF⟩ := h\n  use n₀\n  intro n\n  induction' n with n hn\n  · refine' (F.antitone _).trans e\n    simp\n  · rw [Nat.succ_eq_one_add, add_assoc, add_comm, add_comm 1 n, ← hF]\n    exact (submodule.smul_mono_right hn).trans (F'.smul_le _)\n    simp\n#align stable.exists_forall_le stable.exists_forall_le\n\n",
 "bounded_difference":
 "theorem stable.bounded_difference (h : F.stable) (h' : F'.stable) (e : F.N 0 = F'.N 0) :\n    ∃ n₀, ∀ n, F.N (n + n₀) ≤ F'.N n ∧ F'.N (n + n₀) ≤ F.N n :=\n  by\n  obtain ⟨n₁, h₁⟩ := h.exists_forall_le (le_of_eq e)\n  obtain ⟨n₂, h₂⟩ := h'.exists_forall_le (le_of_eq e.symm)\n  use max n₁ n₂\n  intro n\n  refine' ⟨(F.antitone _).trans (h₁ n), (F'.antitone _).trans (h₂ n)⟩ <;> simp\n#align stable.bounded_difference stable.bounded_difference\n\n",
 "bot_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊥» -/\n@[simp]\ntheorem bot_N : («expr⊥» : I.filtration M).N = «expr⊥» :=\n  rfl\n#align bot_N bot_N\n\n",
 "antitone":
 "protected theorem antitone : antitone F.N :=\n  antitone_nat_of_succ_le F.mono\n#align antitone antitone\n\n",
 "Sup_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Sup_N (S : set (I.filtration M)) : (supₛ S).N = supₛ («expr '' » ideal.filtration.N S) :=\n  rfl\n#align Sup_N Sup_N\n\n",
 "Inf_N":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n@[simp]\ntheorem Inf_N (S : set (I.filtration M)) : (infₛ S).N = infₛ («expr '' » ideal.filtration.N S) :=\n  rfl\n#align Inf_N Inf_N\n\n"}