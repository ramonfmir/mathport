{"trans":
 "#print trans /-\ntheorem trans [algebra A B] [IsScalarTower R A B] (hRA : finite_type R A) (hAB : finite_type A B) : finite_type R B :=\n  ⟨fg_trans' hRA.1 hAB.1⟩\n#align trans trans\n-/\n\n",
 "support_gen_of_gen'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set `S` generates, as algebra, `monoid_algebra R M`, then the image of the union of the\nsupports of elements of `S` generates `monoid_algebra R M`. -/\ntheorem support_gen_of_gen' {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = «expr⊤») :\n    algebra.adjoin R\n        («expr '' » (of R M)\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (f.support : set M))) =\n      «expr⊤» :=\n  by\n  suffices\n    «expr '' » (of R M)\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (f.support : set M)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (of R M) (f.support : set M))\n    by\n    rw [this]\n    exact support_gen_of_gen hS\n  simp only [Set.image_unionᵢ]\n#align support_gen_of_gen' support_gen_of_gen'\n\n",
 "support_gen_of_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set `S` generates, as algebra, `monoid_algebra R M`, then the set of supports of elements\nof `S` generates `monoid_algebra R M`. -/\ntheorem support_gen_of_gen {S : set (monoid_algebra R M)} (hS : algebra.adjoin R S = «expr⊤») :\n    algebra.adjoin R\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (of R M) (f.support : set M))) =\n      «expr⊤» :=\n  by\n  refine' le_antisymm le_top _\n  rw [← hS, adjoin_le_iff]\n  intro f hf\n  have hincl :\n    «expr '' » (of R M) f.support ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (of R M) g.support) :=\n    by\n    intro s hs\n    exact Set.mem_unionᵢ₂.2 ⟨f, ⟨hf, hs⟩⟩\n  exact adjoin_mono hincl (mem_adjoin_support f)\n#align support_gen_of_gen support_gen_of_gen\n\n",
 "self":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n-- see Note [lower instance priority]\ntheorem self : finite_type R R :=\n  ⟨⟨{1}, subsingleton.elim _ _⟩⟩\n#align self self\n\n",
 "polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\nprotected theorem polynomial : finite_type R (polynomial R) :=\n  ⟨⟨{polynomial.X}, by\n      rw [Finset.coe_singleton]\n      exact polynomial.adjoin_X⟩⟩\n#align polynomial polynomial\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_surjective (f : «expr →ₐ[ ] » A R B) (hf : surjective f) : f.finite_type :=\n  ring_hom.finite_type.of_surjective f hf\n#align of_surjective of_surjective\n\n",
 "of_restrict_scalars_finite_type":
 "theorem of_restrict_scalars_finite_type [algebra A B] [IsScalarTower R A B] [hB : finite_type R B] : finite_type A B :=\n  by\n  obtain ⟨S, hS⟩ := hB.out\n  refine' ⟨⟨S, eq_top_iff.2 fun b => _⟩⟩\n  have le : adjoin R (S : set B) ≤ subalgebra.restrict_scalars R (adjoin A S) :=\n    by\n    apply (algebra.adjoin_le _ : _ ≤ subalgebra.restrict_scalars R (adjoin A ↑S))\n    simp only [subalgebra.coe_restrict_scalars]\n    exact algebra.subset_adjoin\n  exact le (eq_top_iff.1 hS b)\n#align of_restrict_scalars_finite_type of_restrict_scalars_finite_type\n\n",
 "of_mem_span_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of an element `m : M` in `monoid_algebra R M` belongs the submodule generated by\n`S : set M` if and only if `m ∈ S`. -/\ntheorem of_mem_span_of_iff [nontrivial R] {m : M} {S : set M} : of R M m ∈ span R («expr '' » (of R M) S) ↔ m ∈ S :=\n  by\n  refine' ⟨fun h => _, fun h => submodule.subset_span <| Set.mem_image_of_mem (of R M) h⟩\n  rw [of, MonoidHom.coe_mk, ← finsupp.supported_eq_span_single, finsupp.mem_supported,\n    finsupp.support_single_ne_zero _ (one_ne_zero' R)] at h\n  simpa using h\n#align of_mem_span_of_iff of_mem_span_of_iff\n\n",
 "of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_finite {f : «expr →+* » A B} (hf : f.finite) : f.finite_type :=\n  @module.finite.finite_type _ _ _ _ f.to_algebra hf\n#align of_finite of_finite\n\n",
 "of_comp_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp_finite_type {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (h : (g.comp f).finite_type) :\n    g.finite_type :=\n  ring_hom.finite_type.of_comp_finite_type h\n#align of_comp_finite_type of_comp_finite_type\n\n",
 "of'_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of an element `m : M` in `add_monoid_algebra R M` belongs the submodule generated by\n`S : set M` if and only if `m ∈ S`. -/\ntheorem of'_mem_span [nontrivial R] {m : M} {S : set M} : of' R M m ∈ span R («expr '' » (of' R M) S) ↔ m ∈ S :=\n  by\n  refine' ⟨fun h => _, fun h => submodule.subset_span <| Set.mem_image_of_mem (of R M) h⟩\n  rw [of', ← finsupp.supported_eq_span_single, finsupp.mem_supported,\n    finsupp.support_single_ne_zero _ (one_ne_zero' R)] at h\n  simpa using h\n#align of'_mem_span of'_mem_span\n\n",
 "mv_polynomial_aeval_of_surjective_of_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set `S` generates a monoid `M`, then the image of `M` generates, as algebra,\n`monoid_algebra R M`. -/\ntheorem mv_polynomial_aeval_of_surjective_of_closure [CommSemiring R] {S : set M} (hS : closure S = «expr⊤») :\n    function.surjective (mv_polynomial.aeval fun s : S => of R M ↑s : mv_polynomial S R → monoid_algebra R M) :=\n  by\n  refine' fun f => induction_on f (fun m => _) _ _\n  · have : m ∈ closure S := hS.symm ▸ mem_top _\n    refine' closure_induction this (fun m hm => _) _ _\n    · exact ⟨mv_polynomial.X ⟨m, hm⟩, mv_polynomial.aeval_X _ _⟩\n    · exact ⟨1, alg_hom.map_one _⟩\n    · rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩\n      exact ⟨P₁ * P₂, by rw [alg_hom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]⟩\n  · rintro f g ⟨P, rfl⟩ ⟨Q, rfl⟩\n    exact ⟨P + Q, alg_hom.map_add _ _ _⟩\n  · rintro r f ⟨P, rfl⟩\n    exact ⟨«expr • » r P, alg_hom.map_smul _ _ _⟩\n#align mv_polynomial_aeval_of_surjective_of_closure mv_polynomial_aeval_of_surjective_of_closure\n\n",
 "mv_polynomial":
 "protected theorem mv_polynomial (ι : Type _) [Finite ι] : finite_type R (mv_polynomial ι R) := by\n  cases nonempty_fintype ι <;>\n    exact\n      ⟨⟨finset.univ.image mv_polynomial.X,\n          by\n          rw [Finset.coe_image, finset.coe_univ, Set.image_univ]\n          exact mv_polynomial.adjoin_range_X⟩⟩\n#align mv_polynomial mv_polynomial\n\n",
 "module_polynomial_of_endo_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem module_polynomial_of_endo_smul_def (n : polynomial R) (a : M) :\n    @has_smul.smul (module_polynomial_of_endo f).to_has_smul n a = polynomial.aeval f n a :=\n  rfl\n#align module_polynomial_of_endo_smul_def module_polynomial_of_endo_smul_def\n\n",
 "mem_closure_of_mem_span_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the image of an element `m : M` in `monoid_algebra R M` belongs the submodule generated by the\nclosure of some `S : set M` then `m ∈ closure S`. -/\ntheorem mem_closure_of_mem_span_closure [nontrivial R] {m : M} {S : set M}\n    (h : of R M m ∈ span R (Submonoid.closure («expr '' » (of R M) S) : set (monoid_algebra R M))) : m ∈ closure S :=\n  by\n  rw [← MonoidHom.map_mclosure] at h\n  simpa using of_mem_span_of_iff.1 h\n#align mem_closure_of_mem_span_closure mem_closure_of_mem_span_closure\n\n",
 "mem_adjoin_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An element of `monoid_algebra R M` is in the subalgebra generated by its support. -/\ntheorem mem_adjoin_support (f : monoid_algebra R M) : f ∈ adjoin R («expr '' » (of R M) f.support) :=\n  by\n  suffices span R («expr '' » (of R M) f.support) ≤ (adjoin R («expr '' » (of R M) f.support)).to_submodule by\n    exact this (mem_span_support f)\n  rw [submodule.span_le]\n  exact subset_adjoin\n#align mem_adjoin_support mem_adjoin_support\n\n",
 "is_scalar_tower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\ntheorem module_polynomial_of_endo.is_scalar_tower :\n    @IsScalarTower R (polynomial R) M _\n      (by\n        letI := module_polynomial_of_endo f\n        infer_instance)\n      _ :=\n  by\n  letI := module_polynomial_of_endo f\n  constructor\n  intro x y z\n  simp\n#align module_polynomial_of_endo.is_scalar_tower module_polynomial_of_endo.is_scalar_tower\n\n",
 "is_noetherian_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem is_noetherian_ring (R S : Type _) [CommRing R] [CommRing S] [algebra R S] [h : algebra.finite_type R S]\n    [is_noetherian_ring R] : is_noetherian_ring S :=\n  by\n  obtain ⟨s, hs⟩ := h.1\n  apply\n    is_noetherian_ring_of_surjective (mv_polynomial s R) S\n      (mv_polynomial.aeval coe : «expr →ₐ[ ] » (mv_polynomial s R) R S)\n  rw [← Set.range_iff_surjective, alg_hom.coe_to_ring_hom, ← alg_hom.coe_range, ← algebra.adjoin_range_eq_range_aeval,\n    Subtype.range_coe_subtype, Finset.setOf_mem, hs]\n  rfl\n#align is_noetherian_ring is_noetherian_ring\n\n",
 "injective_of_surjective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/-- A theorem/proof by Vasconcelos, given a finite module `M` over a commutative ring, any\nsurjective endomorphism of `M` is also injective. Based on,\nhttps://math.stackexchange.com/a/239419/31917,\nhttps://www.ams.org/journals/tran/1969-138-00/S0002-9947-1969-0238839-5/.\nThis is similar to `is_noetherian.injective_of_surjective_endomorphism` but only applies in the\ncommutative case, but does not use a Noetherian hypothesis. -/\ntheorem module.finite.injective_of_surjective_endomorphism [hfg : Finite R M] (f_surj : function.surjective f) :\n    function.injective f := by\n  letI := module_polynomial_of_endo f\n  haveI : IsScalarTower R (polynomial R) M := module_polynomial_of_endo.is_scalar_tower f\n  have hfgpoly : Finite (polynomial R) M := finite.of_restrict_scalars_finite R _ _\n  have X_mul : ∀ o, «expr • » (X : polynomial R) o = f o :=\n    by\n    intro\n    simp\n  have : («expr⊤» : submodule (polynomial R) M) ≤ «expr • » (ideal.span {X}) («expr⊤») :=\n    by\n    intro a ha\n    obtain ⟨y, rfl⟩ := f_surj a\n    rw [← X_mul y]\n    exact submodule.smul_mem_smul (ideal.mem_span_singleton.mpr (dvd_refl _)) trivial\n  obtain ⟨F, hFa, hFb⟩ :=\n    submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul _ («expr⊤» : submodule (polynomial R) M)\n      (finite_def.mp hfgpoly) this\n  rw [← linear_map.ker_eq_bot, linear_map.ker_eq_bot']\n  intro m hm\n  rw [ideal.mem_span_singleton'] at hFa\n  obtain ⟨G, hG⟩ := hFa\n  suffices «expr • » (F - 1) m = 0 by\n    have Fmzero := hFb m (by simp)\n    rwa [← sub_add_cancel F 1, add_smul, one_smul, this, zero_add] at Fmzero\n  rw [← hG, mul_smul, X_mul m, hm, smul_zero]\n#align module.finite.injective_of_surjective_endomorphism module.finite.injective_of_surjective_endomorphism\n\n",
 "iff_quotient_mv_polynomial''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely generated if and only if it is a quotient of a polynomial ring in `n`\nvariables. -/\ntheorem iff_quotient_mv_polynomial'' :\n    finite_type R A ↔ ∃ (n : ℕ)(f : «expr →ₐ[ ] » (mv_polynomial (fin n) R) R A), surjective f :=\n  by\n  constructor\n  · rw [iff_quotient_mv_polynomial']\n    rintro ⟨ι, hfintype, ⟨f, hsur⟩⟩\n    skip\n    have equiv := mv_polynomial.rename_equiv R (fintype.equiv_fin ι)\n    exact ⟨fintype.card ι, alg_hom.comp f equiv.symm, function.surjective.comp hsur (alg_equiv.symm equiv).surjective⟩\n  · rintro ⟨n, ⟨f, hsur⟩⟩\n    exact finite_type.of_surjective (finite_type.mv_polynomial R (fin n)) f hsur\n#align iff_quotient_mv_polynomial'' iff_quotient_mv_polynomial''\n\n",
 "iff_quotient_mv_polynomial'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a fintype. -/\ntheorem iff_quotient_mv_polynomial' :\n    finite_type R A ↔ ∃ (ι : Type u_2)(_ : fintype ι)(f : «expr →ₐ[ ] » (mv_polynomial ι R) R A), surjective f :=\n  by\n  constructor\n  · rw [iff_quotient_mv_polynomial]\n    rintro ⟨s, ⟨f, hsur⟩⟩\n    use { x // x ∈ s }, by infer_instance, f, hsur\n  · rintro ⟨ι, ⟨hfintype, ⟨f, hsur⟩⟩⟩\n    letI : fintype ι := hfintype\n    exact finite_type.of_surjective (finite_type.mv_polynomial R ι) f hsur\n#align iff_quotient_mv_polynomial' iff_quotient_mv_polynomial'\n\n",
 "iff_quotient_mv_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a finset. -/\ntheorem iff_quotient_mv_polynomial :\n    finite_type R A ↔ ∃ (s : Finset A)(f : «expr →ₐ[ ] » (mv_polynomial { x // x ∈ s } R) R A), surjective f :=\n  by\n  constructor\n  · rintro ⟨s, hs⟩\n    use s, mv_polynomial.aeval coe\n    intro x\n    have hrw : (↑s : set A) = fun x : A => x ∈ s.val := rfl\n    rw [← Set.mem_range, ← alg_hom.coe_range, ← adjoin_eq_range, ← hrw, hs]\n    exact Set.mem_univ x\n  · rintro ⟨s, ⟨f, hsur⟩⟩\n    exact finite_type.of_surjective (finite_type.mv_polynomial R { x // x ∈ s }) f hsur\n#align iff_quotient_mv_polynomial iff_quotient_mv_polynomial\n\n",
 "id":
 "#print id /-\ntheorem id : finite_type (alg_hom.id R A) :=\n  ring_hom.finite_type.id A\n#align id id\n-/\n\n",
 "finite_type_iff_group_fg":
 "/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem finite_type_iff_group_fg {G : Type _} [comm_group G] [CommRing R] [nontrivial R] :\n    finite_type R (monoid_algebra R G) ↔ group.fg G := by simpa [group.fg_iff_monoid.fg] using finite_type_iff_fg\n#align finite_type_iff_group_fg finite_type_iff_group_fg\n\n",
 "finite_type_iff_fg":
 "/-- A monoid `M` is finitely generated if and only if `monoid_algebra R M` is of finite type. -/\ntheorem finite_type_iff_fg [CommRing R] [nontrivial R] : finite_type R (monoid_algebra R M) ↔ monoid.fg M :=\n  ⟨fun h => monoid.fg_iff_add_fg.2 <| add_monoid_algebra.finite_type_iff_fg.1 <| h.equiv <| to_additive_alg_equiv R M,\n    fun h => @monoid_algebra.finite_type_of_fg _ _ _ _ h⟩\n#align finite_type_iff_fg finite_type_iff_fg\n\n",
 "finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem finite_type {f : «expr →ₐ[ ] » A R B} (hf : f.finite) : finite_type f :=\n  ring_hom.finite.finite_type hf\n#align finite_type finite_type\n\n",
 "fg_of_finite_type":
 "/-- If `monoid_algebra R M` is of finite type then `M` is finitely generated. -/\ntheorem fg_of_finite_type [CommRing R] [nontrivial R] [h : finite_type R (monoid_algebra R M)] : monoid.fg M :=\n  finite_type_iff_fg.1 h\n#align fg_of_finite_type fg_of_finite_type\n\n",
 "fg_iff_finite_type":
 "theorem _root_.subalgebra.fg_iff_finite_type {R A : Type _} [CommSemiring R] [Semiring A] [algebra R A]\n    (S : subalgebra R A) : S.fg ↔ algebra.finite_type R S :=\n  S.fg_top.symm.trans ⟨fun h => ⟨h⟩, fun h => h.out⟩\n#align subalgebra.fg_iff_finite_type subalgebra.fg_iff_finite_type\n\n",
 "exists_finset_adjoin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `monoid_algebra R M` is of finite type, there there is a `G : finset M` such that its image\ngenerates, as algera, `monoid_algebra R M`. -/\ntheorem exists_finset_adjoin_eq_top [h : finite_type R (monoid_algebra R M)] :\n    ∃ G : Finset M, algebra.adjoin R («expr '' » (of R M) G) = «expr⊤» :=\n  by\n  obtain ⟨S, hS⟩ := h\n  letI : decidable_eq M := classical.dec_eq M\n  use Finset.bunionᵢ S fun f => f.support\n  have :\n    (Finset.bunionᵢ S fun f => f.support : set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (f.support : set M) :=\n    by simp only [finset.set_bUnion_coe, Finset.coe_bunionᵢ]\n  rw [this]\n  exact support_gen_of_gen' hS\n#align exists_finset_adjoin_eq_top exists_finset_adjoin_eq_top\n\n",
 "equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\ntheorem equiv (hRA : finite_type R A) (e : «expr ≃ₐ[ ] » A R B) : finite_type R B :=\n  hRA.of_surjective e e.surjective\n#align equiv equiv\n\n",
 "comp_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp_surjective {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (hf : f.finite_type) (hg : surjective g) :\n    (g.comp f).finite_type :=\n  ring_hom.finite_type.comp_surjective hf hg\n#align comp_surjective comp_surjective\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp {g : «expr →ₐ[ ] » B R C} {f : «expr →ₐ[ ] » A R B} (hg : g.finite_type) (hf : f.finite_type) :\n    (g.comp f).finite_type :=\n  ring_hom.finite_type.comp hg hf\n#align comp comp\n\n"}