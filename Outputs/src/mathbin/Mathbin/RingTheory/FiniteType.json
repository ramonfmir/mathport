{"trans":
 "#print trans /-\ntheorem trans [Algebra A B] [IsScalarTower R A B] (hRA : FiniteType R A) (hAB : FiniteType A B) : FiniteType R B :=\n  ⟨fg_trans' hRA.1 hAB.1⟩\n#align trans trans\n-/\n\n",
 "support_gen_of_gen'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set `S` generates, as algebra, `monoid_algebra R M`, then the image of the union of the\nsupports of elements of `S` generates `monoid_algebra R M`. -/\ntheorem support_gen_of_gen' {S : Set (MonoidAlgebra R M)} (hS : Algebra.adjoin R S = «expr⊤») :\n    Algebra.adjoin R\n        («expr '' » (of R M)\n          («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n            (f.support : Set M))) =\n      «expr⊤» :=\n  by\n  suffices\n    «expr '' » (of R M)\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          (f.support : Set M)) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (of R M) (f.support : Set M))\n    by\n    rw [this]\n    exact support_gen_of_gen hS\n  simp only [Set.image_unionᵢ]\n#align support_gen_of_gen' support_gen_of_gen'\n\n",
 "support_gen_of_gen":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set `S` generates, as algebra, `monoid_algebra R M`, then the set of supports of elements\nof `S` generates `monoid_algebra R M`. -/\ntheorem support_gen_of_gen {S : Set (MonoidAlgebra R M)} (hS : Algebra.adjoin R S = «expr⊤») :\n    Algebra.adjoin R\n        («expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n          («expr '' » (of R M) (f.support : Set M))) =\n      «expr⊤» :=\n  by\n  refine' le_antisymm le_top _\n  rw [← hS, adjoin_le_iff]\n  intro f hf\n  have hincl :\n    «expr '' » (of R M) f.support ⊆\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        («expr '' » (of R M) g.support) :=\n    by\n    intro s hs\n    exact Set.mem_unionᵢ₂.2 ⟨f, ⟨hf, hs⟩⟩\n  exact adjoin_mono hincl (mem_adjoin_support f)\n#align support_gen_of_gen support_gen_of_gen\n\n",
 "self":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n-- see Note [lower instance priority]\ntheorem self : FiniteType R R :=\n  ⟨⟨{1}, subsingleton.elim _ _⟩⟩\n#align self self\n\n",
 "of_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_surjective (f : «expr →ₐ[ ] » A R B) (hf : surjective f) : f.finite_type :=\n  RingHom.FiniteType.of_surjective f hf\n#align of_surjective of_surjective\n\n",
 "of_restrict_scalars_finite_type":
 "theorem of_restrict_scalars_finite_type [Algebra A B] [IsScalarTower R A B] [hB : FiniteType R B] : FiniteType A B :=\n  by\n  obtain ⟨S, hS⟩ := hB.out\n  refine' ⟨⟨S, eq_top_iff.2 fun b => _⟩⟩\n  have le : adjoin R (S : Set B) ≤ Subalgebra.restrictScalars R (adjoin A S) :=\n    by\n    apply (Algebra.adjoin_le _ : _ ≤ Subalgebra.restrictScalars R (adjoin A ↑S))\n    simp only [Subalgebra.coe_restrictScalars]\n    exact Algebra.subset_adjoin\n  exact le (eq_top_iff.1 hS b)\n#align of_restrict_scalars_finite_type of_restrict_scalars_finite_type\n\n",
 "of_mem_span_of_iff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of an element `m : M` in `monoid_algebra R M` belongs the submodule generated by\n`S : set M` if and only if `m ∈ S`. -/\ntheorem of_mem_span_of_iff [Nontrivial R] {m : M} {S : Set M} : of R M m ∈ span R («expr '' » (of R M) S) ↔ m ∈ S :=\n  by\n  refine' ⟨fun h => _, fun h => Submodule.subset_span <| Set.mem_image_of_mem (of R M) h⟩\n  rw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported,\n    Finsupp.support_single_ne_zero _ (one_ne_zero' R)] at h\n  simpa using h\n#align of_mem_span_of_iff of_mem_span_of_iff\n\n",
 "of_finite":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\ntheorem of_finite {f : «expr →+* » A B} (hf : f.finite) : f.finite_type :=\n  @Module.Finite.finiteType _ _ _ _ f.to_algebra hf\n#align of_finite of_finite\n\n",
 "of_comp_finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem of_comp_finite_type {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (h : (g.comp f).finite_type) :\n    g.finite_type :=\n  RingHom.FiniteType.of_comp_finiteType h\n#align of_comp_finite_type of_comp_finite_type\n\n",
 "of'_mem_span":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- The image of an element `m : M` in `add_monoid_algebra R M` belongs the submodule generated by\n`S : set M` if and only if `m ∈ S`. -/\ntheorem of'_mem_span [Nontrivial R] {m : M} {S : Set M} : of' R M m ∈ span R («expr '' » (of' R M) S) ↔ m ∈ S :=\n  by\n  refine' ⟨fun h => _, fun h => Submodule.subset_span <| Set.mem_image_of_mem (of R M) h⟩\n  rw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported,\n    Finsupp.support_single_ne_zero _ (one_ne_zero' R)] at h\n  simpa using h\n#align of'_mem_span of'_mem_span\n\n",
 "mv_polynomial_aeval_of_surjective_of_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If a set `S` generates a monoid `M`, then the image of `M` generates, as algebra,\n`monoid_algebra R M`. -/\ntheorem mv_polynomial_aeval_of_surjective_of_closure [CommSemiring R] {S : Set M} (hS : closure S = «expr⊤») :\n    function.surjective (MvPolynomial.aeval fun s : S => of R M ↑s : MvPolynomial S R → MonoidAlgebra R M) :=\n  by\n  refine' fun f => induction_on f (fun m => _) _ _\n  · have : m ∈ closure S := hS.symm ▸ mem_top _\n    refine' closure_induction this (fun m hm => _) _ _\n    · exact ⟨MvPolynomial.X ⟨m, hm⟩, MvPolynomial.aeval_X _ _⟩\n    · exact ⟨1, AlgHom.map_one _⟩\n    · rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩\n      exact ⟨P₁ * P₂, by rw [AlgHom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]⟩\n  · rintro f g ⟨P, rfl⟩ ⟨Q, rfl⟩\n    exact ⟨P + Q, AlgHom.map_add _ _ _⟩\n  · rintro r f ⟨P, rfl⟩\n    exact ⟨«expr • » r P, AlgHom.map_smul _ _ _⟩\n#align mv_polynomial_aeval_of_surjective_of_closure mv_polynomial_aeval_of_surjective_of_closure\n\n",
 "modulePolynomialOfEndo_smul_def":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print modulePolynomialOfEndo_smul_def /-\ntheorem modulePolynomialOfEndo_smul_def (n : polynomial R) (a : M) :\n    @has_smul.smul (modulePolynomialOfEndo f).to_has_smul n a = Polynomial.aeval f n a :=\n  rfl\n#align module_polynomial_of_endo_smul_def modulePolynomialOfEndo_smul_def\n-/\n\n",
 "mem_closure_of_mem_span_closure":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- If the image of an element `m : M` in `monoid_algebra R M` belongs the submodule generated by the\nclosure of some `S : set M` then `m ∈ closure S`. -/\ntheorem mem_closure_of_mem_span_closure [Nontrivial R] {m : M} {S : Set M}\n    (h : of R M m ∈ span R (Submonoid.closure («expr '' » (of R M) S) : Set (MonoidAlgebra R M))) : m ∈ closure S :=\n  by\n  rw [← MonoidHom.map_mclosure] at h\n  simpa using of_mem_span_of_iff.1 h\n#align mem_closure_of_mem_span_closure mem_closure_of_mem_span_closure\n\n",
 "mem_adjoin_support":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/-- An element of `monoid_algebra R M` is in the subalgebra generated by its support. -/\ntheorem mem_adjoin_support (f : MonoidAlgebra R M) : f ∈ adjoin R («expr '' » (of R M) f.support) :=\n  by\n  suffices span R («expr '' » (of R M) f.support) ≤ (adjoin R («expr '' » (of R M) f.support)).to_submodule by\n    exact this (mem_span_support f)\n  rw [Submodule.span_le]\n  exact subset_adjoin\n#align mem_adjoin_support mem_adjoin_support\n\n",
 "isScalarTower":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print modulePolynomialOfEndo.isScalarTower /-\ntheorem modulePolynomialOfEndo.isScalarTower :\n    @IsScalarTower R (polynomial R) M _\n      (by\n        letI := modulePolynomialOfEndo f\n        infer_instance)\n      _ :=\n  by\n  letI := modulePolynomialOfEndo f\n  constructor\n  intro x y z\n  simp\n#align module_polynomial_of_endo.is_scalar_tower modulePolynomialOfEndo.isScalarTower\n-/\n\n",
 "injective_of_surjective_endomorphism":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n#print Module.Finite.injective_of_surjective_endomorphism /-\n/-- A theorem/proof by Vasconcelos, given a finite module `M` over a commutative ring, any\nsurjective endomorphism of `M` is also injective. Based on,\nhttps://math.stackexchange.com/a/239419/31917,\nhttps://www.ams.org/journals/tran/1969-138-00/S0002-9947-1969-0238839-5/.\nThis is similar to `is_noetherian.injective_of_surjective_endomorphism` but only applies in the\ncommutative case, but does not use a Noetherian hypothesis. -/\ntheorem Module.Finite.injective_of_surjective_endomorphism [hfg : Finite R M] (f_surj : function.surjective f) :\n    function.injective f := by\n  letI := modulePolynomialOfEndo f\n  haveI : IsScalarTower R (polynomial R) M := modulePolynomialOfEndo.isScalarTower f\n  have hfgpoly : Finite (polynomial R) M := finite.of_restrict_scalars_finite R _ _\n  have X_mul : ∀ o, «expr • » (X : polynomial R) o = f o :=\n    by\n    intro\n    simp\n  have : («expr⊤» : Submodule (polynomial R) M) ≤ «expr • » (Ideal.span {X}) («expr⊤») :=\n    by\n    intro a ha\n    obtain ⟨y, rfl⟩ := f_surj a\n    rw [← X_mul y]\n    exact Submodule.smul_mem_smul (ideal.mem_span_singleton.mpr (dvd_refl _)) trivial\n  obtain ⟨F, hFa, hFb⟩ :=\n    Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul _ («expr⊤» : Submodule (polynomial R) M)\n      (finite_def.mp hfgpoly) this\n  rw [← LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']\n  intro m hm\n  rw [Ideal.mem_span_singleton'] at hFa\n  obtain ⟨G, hG⟩ := hFa\n  suffices «expr • » (F - 1) m = 0 by\n    have Fmzero := hFb m (by simp)\n    rwa [← sub_add_cancel F 1, add_smul, one_smul, this, zero_add] at Fmzero\n  rw [← hG, mul_smul, X_mul m, hm, smul_zero]\n#align module.finite.injective_of_surjective_endomorphism Module.Finite.injective_of_surjective_endomorphism\n-/\n\n",
 "iff_quotient_mv_polynomial''":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely generated if and only if it is a quotient of a polynomial ring in `n`\nvariables. -/\ntheorem iff_quotient_mv_polynomial'' :\n    FiniteType R A ↔ ∃ (n : ℕ)(f : «expr →ₐ[ ] » (MvPolynomial (Fin n) R) R A), surjective f :=\n  by\n  constructor\n  · rw [iff_quotient_mv_polynomial']\n    rintro ⟨ι, hfintype, ⟨f, hsur⟩⟩\n    skip\n    have equiv := MvPolynomial.renameEquiv R (Fintype.equivFin ι)\n    exact ⟨Fintype.card ι, AlgHom.comp f Equiv.symm, function.surjective.comp hsur (AlgEquiv.symm Equiv).surjective⟩\n  · rintro ⟨n, ⟨f, hsur⟩⟩\n    exact finite_type.of_surjective (finite_type.mv_polynomial R (Fin n)) f hsur\n#align iff_quotient_mv_polynomial'' iff_quotient_mv_polynomial''\n\n",
 "iff_quotient_mv_polynomial'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a fintype. -/\ntheorem iff_quotient_mv_polynomial' :\n    FiniteType R A ↔ ∃ (ι : Type u_2)(_ : Fintype ι)(f : «expr →ₐ[ ] » (MvPolynomial ι R) R A), surjective f :=\n  by\n  constructor\n  · rw [iff_quotient_mv_polynomial]\n    rintro ⟨s, ⟨f, hsur⟩⟩\n    use { x // x ∈ s }, by infer_instance, f, hsur\n  · rintro ⟨ι, ⟨hfintype, ⟨f, hsur⟩⟩⟩\n    letI : Fintype ι := hfintype\n    exact finite_type.of_surjective (finite_type.mv_polynomial R ι) f hsur\n#align iff_quotient_mv_polynomial' iff_quotient_mv_polynomial'\n\n",
 "iff_quotient_mv_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/-- An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a finset. -/\ntheorem iff_quotient_mv_polynomial :\n    FiniteType R A ↔ ∃ (s : Finset A)(f : «expr →ₐ[ ] » (MvPolynomial { x // x ∈ s } R) R A), surjective f :=\n  by\n  constructor\n  · rintro ⟨s, hs⟩\n    use s, MvPolynomial.aeval coe\n    intro x\n    have hrw : (↑s : Set A) = fun x : A => x ∈ s.val := rfl\n    rw [← Set.mem_range, ← AlgHom.coe_range, ← adjoin_eq_range, ← hrw, hs]\n    exact Set.mem_univ x\n  · rintro ⟨s, ⟨f, hsur⟩⟩\n    exact finite_type.of_surjective (finite_type.mv_polynomial R { x // x ∈ s }) f hsur\n#align iff_quotient_mv_polynomial iff_quotient_mv_polynomial\n\n",
 "id":
 "#print id /-\ntheorem id : FiniteType (AlgHom.id R A) :=\n  RingHom.FiniteType.id A\n#align id id\n-/\n\n",
 "finite_type_iff_group_fg":
 "/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem finite_type_iff_group_fg {G : Type _} [CommGroup G] [CommRing R] [Nontrivial R] :\n    FiniteType R (MonoidAlgebra R G) ↔ Group.Fg G := by simpa [Group.fg_iff_monoid_fg] using finite_type_iff_fg\n#align finite_type_iff_group_fg finite_type_iff_group_fg\n\n",
 "finite_type_iff_fg":
 "/-- A monoid `M` is finitely generated if and only if `monoid_algebra R M` is of finite type. -/\ntheorem finite_type_iff_fg [CommRing R] [Nontrivial R] : FiniteType R (MonoidAlgebra R M) ↔ Monoid.Fg M :=\n  ⟨fun h => Monoid.fg_iff_add_fg.2 <| AddMonoidAlgebra.finiteType_iff_fg.1 <| h.equiv <| toAdditiveAlgEquiv R M,\n    fun h => @MonoidAlgebra.finiteType_of_fg _ _ _ _ h⟩\n#align finite_type_iff_fg finite_type_iff_fg\n\n",
 "finite_type":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem finite_type {f : «expr →ₐ[ ] » A R B} (hf : f.finite) : FiniteType f :=\n  RingHom.Finite.finiteType hf\n#align finite_type finite_type\n\n",
 "fg_of_finite_type":
 "/-- If `monoid_algebra R M` is of finite type then `M` is finitely generated. -/\ntheorem fg_of_finite_type [CommRing R] [Nontrivial R] [h : FiniteType R (MonoidAlgebra R M)] : Monoid.Fg M :=\n  finiteType_iff_fg.1 h\n#align fg_of_finite_type fg_of_finite_type\n\n",
 "fg_iff_finite_type":
 "#print Subalgebra.fg_iff_finiteType /-\ntheorem Subalgebra.fg_iff_finiteType {R A : Type _} [CommSemiring R] [Semiring A] [Algebra R A] (S : Subalgebra R A) :\n    S.fg ↔ Algebra.FiniteType R S :=\n  S.fg_top.symm.trans ⟨fun h => ⟨h⟩, fun h => h.out⟩\n#align subalgebra.fg_iff_finite_type Subalgebra.fg_iff_finiteType\n-/\n\n",
 "exists_finset_adjoin_eq_top":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr '' » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr⊤» -/\n/-- If `monoid_algebra R M` is of finite type, there there is a `G : finset M` such that its image\ngenerates, as algera, `monoid_algebra R M`. -/\ntheorem exists_finset_adjoin_eq_top [h : FiniteType R (MonoidAlgebra R M)] :\n    ∃ G : Finset M, Algebra.adjoin R («expr '' » (of R M) G) = «expr⊤» :=\n  by\n  obtain ⟨S, hS⟩ := h\n  letI : DecidableEq M := Classical.decEq M\n  use Finset.bunionᵢ S fun f => f.support\n  have :\n    (Finset.bunionᵢ S fun f => f.support : Set M) =\n      «expr⋃ , » \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr⋃ , »\"\n        (f.support : Set M) :=\n    by simp only [Finset.set_bunionᵢ_coe, Finset.coe_bunionᵢ]\n  rw [this]\n  exact support_gen_of_gen' hS\n#align exists_finset_adjoin_eq_top exists_finset_adjoin_eq_top\n\n",
 "comp_surjective":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp_surjective {f : «expr →ₐ[ ] » A R B} {g : «expr →ₐ[ ] » B R C} (hf : f.finite_type) (hg : surjective g) :\n    (g.comp f).finite_type :=\n  RingHom.FiniteType.comp_surjective hf hg\n#align comp_surjective comp_surjective\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\ntheorem comp {g : «expr →ₐ[ ] » B R C} {f : «expr →ₐ[ ] » A R B} (hg : g.finite_type) (hf : f.finite_type) :\n    (g.comp f).finite_type :=\n  RingHom.FiniteType.comp hg hf\n#align comp comp\n\n",
 "Polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `polynomial -/\n#print Polynomial /-\nprotected theorem Polynomial : FiniteType R (polynomial R) :=\n  ⟨⟨{Polynomial.X}, by\n      rw [Finset.coe_singleton]\n      exact Polynomial.adjoin_X⟩⟩\n#align polynomial Polynomial\n-/\n\n",
 "MvPolynomial":
 "#print MvPolynomial /-\nprotected theorem MvPolynomial (ι : Type _) [Finite ι] : FiniteType R (MvPolynomial ι R) := by\n  cases nonempty_fintype ι <;>\n    exact\n      ⟨⟨finset.univ.image MvPolynomial.X,\n          by\n          rw [Finset.coe_image, Finset.coe_univ, Set.image_univ]\n          exact MvPolynomial.adjoin_range_X⟩⟩\n#align mv_polynomial MvPolynomial\n-/\n\n",
 "IsNoetherianRing":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →ₐ[ ] » -/\n#print IsNoetherianRing /-\ntheorem IsNoetherianRing (R S : Type _) [CommRing R] [CommRing S] [Algebra R S] [h : Algebra.FiniteType R S]\n    [IsNoetherianRing R] : IsNoetherianRing S := by\n  obtain ⟨s, hs⟩ := h.1\n  apply\n    isNoetherianRing_of_surjective (MvPolynomial s R) S (MvPolynomial.aeval coe : «expr →ₐ[ ] » (MvPolynomial s R) R S)\n  rw [← Set.range_iff_surjective, AlgHom.coe_toRingHom, ← AlgHom.coe_range, ← Algebra.adjoin_range_eq_range_aeval,\n    Subtype.range_coe_subtype, Finset.setOf_mem, hs]\n  rfl\n#align is_noetherian_ring IsNoetherianRing\n-/\n\n",
 "Equiv":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃ₐ[ ] » -/\n#print Equiv /-\ntheorem Equiv (hRA : FiniteType R A) (e : «expr ≃ₐ[ ] » A R B) : FiniteType R B :=\n  hRA.of_surjective e e.surjective\n#align equiv Equiv\n-/\n\n"}