{"map_frobenius_poly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `¬´expr‚Öü¬ª -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\ntheorem map_frobenius_poly (n : ‚Ñï) :\n    mv_polynomial.map (Int.castRingHom (expr‚Ñö)) (frobenius_poly p n) = frobenius_poly_rat p n :=\n  by\n  rw [frobenius_poly, RingHom.map_add, RingHom.map_mul, RingHom.map_pow, map_C, map_X, eq_intCast, Int.cast_ofNat,\n    frobenius_poly_rat]\n  apply nat.strong_induction_on n\n  clear n\n  intro n IH\n  rw [X_in_terms_of_W_eq]\n  simp only [alg_hom.map_sum, alg_hom.map_sub, alg_hom.map_mul, alg_hom.map_pow, bind‚ÇÅ_C_right]\n  have h1 : ‚Üëp ^ n * (¬´expr‚Öü¬ª) (‚Üëp : expr‚Ñö) ^ n = 1 := by rw [‚Üê mul_pow, mul_invOf_self, one_pow]\n  rw [bind‚ÇÅ_X_right, Function.comp_apply, witt_polynomial_eq_sum_C_mul_X_pow, sum_range_succ, sum_range_succ, tsub_self,\n    add_tsub_cancel_left, pow_zero, pow_one, pow_one, sub_mul, add_mul, add_mul, mul_right_comm,\n    mul_right_comm (C (‚Üëp ^ (n + 1))), ‚Üê C_mul, ‚Üê C_mul, pow_succ, mul_assoc (‚Üëp) (‚Üëp ^ n), h1, mul_one, C_1, one_mul,\n    add_comm _ (X n ^ p), add_assoc, ‚Üê add_sub, add_right_inj, frobenius_poly_aux_eq, RingHom.map_sub, map_X, mul_sub,\n    sub_eq_add_neg, add_comm _ (C ‚Üëp * X (n + 1)), ‚Üê add_sub, add_right_inj, neg_eq_iff_neg_eq, neg_sub]\n  simp only [ring_hom.map_sum, mul_sum, sum_mul, ‚Üê sum_sub_distrib]\n  apply sum_congr rfl\n  intro i hi\n  rw [mem_range] at hi\n  rw [‚Üê IH i hi]\n  clear IH\n  rw [add_comm (X i ^ p), add_pow, sum_range_succ', pow_zero, tsub_zero, Nat.choose_zero_right, one_mul, Nat.cast_one,\n    mul_one, mul_add, add_mul, nat.succ_sub (le_of_lt hi), nat.succ_eq_add_one (n - i), pow_succ, pow_mul,\n    add_sub_cancel, mul_sum, sum_mul]\n  apply sum_congr rfl\n  intro j hj\n  rw [mem_range] at hj\n  rw [RingHom.map_mul, RingHom.map_mul, RingHom.map_pow, RingHom.map_pow, RingHom.map_pow, RingHom.map_pow,\n    RingHom.map_pow, map_C, map_X, mul_pow]\n  rw [mul_comm (C ‚Üëp ^ i), mul_comm _ ((X i ^ p) ^ _), mul_comm (C ‚Üëp ^ (j + 1)), mul_comm (C ‚Üëp)]\n  simp only [mul_assoc]\n  apply congr_arg\n  apply congr_arg\n  rw [‚Üê C_eq_coe_nat]\n  simp only [‚Üê RingHom.map_pow, ‚Üê C_mul]\n  rw [C_inj]\n  simp only [invOf_eq_inv, eq_intCast, inv_pow, Int.cast_ofNat, nat.cast_mul, Int.cast_mul]\n  rw [Rat.coe_nat_div _ _ (map_frobenius_poly.key‚ÇÅ p (n - i) j hj)]\n  simp only [Nat.cast_pow, pow_add, pow_one]\n  suffices\n    ((p ^ (n - i)).choose (j + 1) * p ^ (j - (exprv) p ‚ü®j + 1, j.succ_pos‚ü©) * p * p ^ n : expr‚Ñö) =\n      p ^ j * p * ((p ^ (n - i)).choose (j + 1) * p ^ i) * p ^ (n - i - (exprv) p ‚ü®j + 1, j.succ_pos‚ü©)\n    by\n    have aux : ‚àÄ k : ‚Ñï, (p ^ k : expr‚Ñö) ‚â† 0 := by\n      intro\n      apply pow_ne_zero\n      exact_mod_cast hp.1.ne_zero\n    simpa [aux, -one_div, field_simps] using this.symm\n  rw [mul_comm _ (p : expr‚Ñö), mul_assoc, mul_assoc, ‚Üê pow_add, map_frobenius_poly.key‚ÇÇ p hi hj]\n  ring\n#align map_frobenius_poly map_frobenius_poly\n\n",
 "key‚ÇÇ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/-- A key numerical identity needed for the proof of `witt_vector.map_frobenius_poly`. -/\ntheorem map_frobenius_poly.key‚ÇÇ {n i j : ‚Ñï} (hi : i < n) (hj : j < p ^ (n - i)) :\n    j - (exprv) p ‚ü®j + 1, j.succ_pos‚ü© + n = i + j + (n - i - (exprv) p ‚ü®j + 1, j.succ_pos‚ü©) :=\n  by\n  generalize h : (exprv) p ‚ü®j + 1, j.succ_pos‚ü© = m\n  suffices m ‚â§ n - i ‚àß m ‚â§ j by\n    rw [tsub_add_eq_add_tsub this.2, add_comm i j, add_tsub_assoc_of_le (this.1.trans (nat.sub_le n i)), add_assoc,\n      tsub_right_comm, add_comm i, tsub_add_cancel_of_le (le_tsub_of_add_le_right ((le_tsub_iff_left hi.le).mp this.1))]\n  constructor\n  ¬∑ rw [‚Üê h, ‚Üê part_enat.coe_le_coe, pnat_multiplicity, part_enat.coe_get, ‚Üê\n      hp.1.multiplicity_choose_prime_pow hj j.succ_pos]\n    apply le_add_left\n    rfl\n  ¬∑ obtain ‚ü®c, hc‚ü© : p ^ m ‚à£ j + 1 := by\n      rw [‚Üê h]\n      exact multiplicity.pow_multiplicity_dvd _\n    obtain ‚ü®c, rfl‚ü© : ‚àÉ k : ‚Ñï, c = k + 1 := by\n      apply nat.exists_eq_succ_of_ne_zero\n      rintro rfl\n      simpa only using hc\n    rw [mul_add, mul_one] at hc\n    apply nat.le_of_lt_succ\n    calc\n      m < p ^ m := Nat.lt_pow_self hp.1.one_lt m\n      _ ‚â§ j + 1 := by\n        rw [‚Üê tsub_eq_of_eq_add_rev hc]\n        apply nat.sub_le\n      \n#align map_frobenius_poly.key‚ÇÇ map_frobenius_poly.key‚ÇÇ\n\n",
 "key‚ÇÅ":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/-\nOur next goal is to prove\n```\nlemma map_frobenius_poly (n : ‚Ñï) :\n  mv_polynomial.map (int.cast_ring_hom ‚Ñö) (frobenius_poly p n) = frobenius_poly_rat p n\n```\nThis lemma has a rather long proof, but it mostly boils down to applying induction,\nand then using the following two key facts at the right point.\n-/\n/-- A key divisibility fact for the proof of `witt_vector.map_frobenius_poly`. -/\ntheorem map_frobenius_poly.key‚ÇÅ (n j : ‚Ñï) (hj : j < p ^ n) :\n    p ^ (n - (exprv) p ‚ü®j + 1, j.succ_pos‚ü©) ‚à£ (p ^ n).choose (j + 1) :=\n  by\n  apply multiplicity.pow_dvd_of_le_multiplicity\n  have aux : (multiplicity p ((p ^ n).choose (j + 1))).dom :=\n    by\n    rw [‚Üê multiplicity.finite_iff_dom, multiplicity.finite_nat_iff]\n    exact ‚ü®hp.1.ne_one, Nat.choose_pos hj‚ü©\n  rw [‚Üê part_enat.coe_get aux, part_enat.coe_le_coe, tsub_le_iff_left, ‚Üê part_enat.coe_le_coe, Nat.cast_add,\n    pnat_multiplicity, part_enat.coe_get, part_enat.coe_get, add_comm]\n  exact (hp.1.multiplicity_choose_prime_pow hj j.succ_pos).ge\n#align map_frobenius_poly.key‚ÇÅ map_frobenius_poly.key‚ÇÅ\n\n",
 "ghost_component_frobenius_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n@[ghost_simps]\ntheorem ghost_component_frobenius_fun (n : ‚Ñï) (x : (exprùïé) R) :\n    ghost_component n (frobenius_fun x) = ghost_component (n + 1) x := by\n  simp only [ghost_component_apply, frobenius_fun, coeff_mk, ‚Üê bind‚ÇÅ_frobenius_poly_witt_polynomial, aeval_bind‚ÇÅ]\n#align ghost_component_frobenius_fun ghost_component_frobenius_fun\n\n",
 "ghost_component_frobenius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n@[ghost_simps]\ntheorem ghost_component_frobenius (n : ‚Ñï) (x : (exprùïé) R) :\n    ghost_component n (frobenius x) = ghost_component (n + 1) x :=\n  ghost_component_frobenius_fun _ _\n#align ghost_component_frobenius ghost_component_frobenius\n\n",
 "frobenius_zmodp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n@[simp]\ntheorem frobenius_zmodp (x : (exprùïé) (zmod p)) : frobenius x = x := by\n  simp only [ext_iff, coeff_frobenius_char_p, zmod.pow_card, eq_self_iff_true, forall_const]\n#align frobenius_zmodp frobenius_zmodp\n\n",
 "frobenius_poly_zmod":
 "theorem frobenius_poly_zmod (n : ‚Ñï) : mv_polynomial.map (Int.castRingHom (zmod p)) (frobenius_poly p n) = X n ^ p :=\n  by\n  rw [frobenius_poly, RingHom.map_add, RingHom.map_pow, RingHom.map_mul, map_X, map_C]\n  simp only [Int.cast_ofNat, add_zero, eq_intCast, zmod.nat_cast_self, zero_mul, C_0]\n#align frobenius_poly_zmod frobenius_poly_zmod\n\n",
 "frobenius_poly_aux_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprv -/\ntheorem frobenius_poly_aux_eq (n : ‚Ñï) :\n    frobenius_poly_aux p n =\n      X (n + 1) -\n        finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range n)\n          (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (range (p ^ (n - i)))\n            ((X i ^ p) ^ (p ^ (n - i) - (j + 1)) * frobenius_poly_aux p i ^ (j + 1) *\n              C\n                ‚Üë((p ^ (n - i)).choose (j + 1) / p ^ (n - i - (exprv) p ‚ü®j + 1, nat.succ_pos j‚ü©) *\n                      ‚Üëp ^ (j - (exprv) p ‚ü®j + 1, nat.succ_pos j‚ü©) :\n                    ‚Ñï))) :=\n  by rw [frobenius_poly_aux, ‚Üê fin.sum_univ_eq_sum_range]\n#align frobenius_poly_aux_eq frobenius_poly_aux_eq\n\n",
 "frobenius_is_poly":
 "/-- `frobenius` is tautologically a polynomial function. -/\n@[is_poly]\ntheorem frobenius_is_poly : is_poly p fun R _Rcr => @frobenius p R _ _Rcr :=\n  frobenius_fun_is_poly _\n#align frobenius_is_poly frobenius_is_poly\n\n",
 "frobenius_fun_is_poly":
 "/-- `frobenius_fun` is tautologically a polynomial function.\n\nSee also `frobenius_is_poly`. -/\n@[is_poly]\ntheorem frobenius_fun_is_poly : is_poly p fun R _Rcr => @frobenius_fun p R _ _Rcr :=\n  ‚ü®‚ü®frobenius_poly p, by\n      intros\n      funext n\n      apply coeff_frobenius_fun‚ü©‚ü©\n#align frobenius_fun_is_poly frobenius_fun_is_poly\n\n",
 "frobenius_eq_map_frobenius":
 "theorem frobenius_eq_map_frobenius : @frobenius p R _ _ = map (_root_.frobenius R p) :=\n  by\n  ext (x n)\n  simp only [coeff_frobenius_char_p, map_coeff, frobenius_def]\n#align frobenius_eq_map_frobenius frobenius_eq_map_frobenius\n\n",
 "frobenius_bijective":
 "theorem frobenius_bijective [perfect_ring R p] : function.bijective (@witt_vector.frobenius p R _ _) :=\n  (frobenius_equiv p R).bijective\n#align frobenius_bijective frobenius_bijective\n\n",
 "coeff_frobenius_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem coeff_frobenius_fun (x : (exprùïé) R) (n : ‚Ñï) :\n    coeff (frobenius_fun x) n = mv_polynomial.aeval x.coeff (frobenius_poly p n) := by rw [frobenius_fun, coeff_mk]\n#align coeff_frobenius_fun coeff_frobenius_fun\n\n",
 "coeff_frobenius_char_p":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n@[simp]\ntheorem coeff_frobenius_char_p (x : (exprùïé) R) (n : ‚Ñï) : coeff (frobenius x) n = x.coeff n ^ p :=\n  by\n  rw [coeff_frobenius]\n  -- outline of the calculation, proofs follow below\n  calc\n    aeval (fun k => x.coeff k) (frobenius_poly p n) =\n        aeval (fun k => x.coeff k) (mv_polynomial.map (Int.castRingHom (zmod p)) (frobenius_poly p n)) :=\n      _\n    _ = aeval (fun k => x.coeff k) (X n ^ p : mv_polynomial ‚Ñï (zmod p)) := _\n    _ = x.coeff n ^ p := _\n    \n  ¬∑ conv_rhs => rw [aeval_eq_eval‚ÇÇ_hom, eval‚ÇÇ_hom_map_hom]\n    apply eval‚ÇÇ_hom_congr (RingHom.ext_int _ _) rfl rfl\n  ¬∑ rw [frobenius_poly_zmod]\n  ¬∑ rw [alg_hom.map_pow, aeval_X]\n#align coeff_frobenius_char_p coeff_frobenius_char_p\n\n",
 "coeff_frobenius":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem coeff_frobenius (x : (exprùïé) R) (n : ‚Ñï) :\n    coeff (frobenius x) n = mv_polynomial.aeval x.coeff (frobenius_poly p n) :=\n  coeff_frobenius_fun _ _\n#align coeff_frobenius coeff_frobenius\n\n",
 "bind‚ÇÅ_frobenius_poly_witt_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n@[simp]\ntheorem bind‚ÇÅ_frobenius_poly_witt_polynomial (n : ‚Ñï) :\n    bind‚ÇÅ (frobenius_poly p) (witt_polynomial p ‚Ñ§ n) = witt_polynomial p ‚Ñ§ (n + 1) :=\n  by\n  apply mv_polynomial.map_injective (Int.castRingHom (expr‚Ñö)) Int.cast_injective\n  simp only [map_bind‚ÇÅ, map_frobenius_poly, bind‚ÇÅ_frobenius_poly_rat_witt_polynomial, map_witt_polynomial]\n#align bind‚ÇÅ_frobenius_poly_witt_polynomial bind‚ÇÅ_frobenius_poly_witt_polynomial\n\n",
 "bind‚ÇÅ_frobenius_poly_rat_witt_polynomial":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr‚Ñö -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n-- type as `\\bbW`\ntheorem bind‚ÇÅ_frobenius_poly_rat_witt_polynomial (n : ‚Ñï) :\n    bind‚ÇÅ (frobenius_poly_rat p) (witt_polynomial p (expr‚Ñö) n) = witt_polynomial p (expr‚Ñö) (n + 1) :=\n  by\n  delta frobenius_poly_rat\n  rw [‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_X_in_terms_of_W_witt_polynomial, bind‚ÇÅ_X_right]\n#align bind‚ÇÅ_frobenius_poly_rat_witt_polynomial bind‚ÇÅ_frobenius_poly_rat_witt_polynomial\n\n"}