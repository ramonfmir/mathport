{"select_is_poly":
 "@[is_poly]\ntheorem select_is_poly (P : ℕ → Prop) : is_poly p fun R _Rcr x => select P x :=\n  by\n  use select_poly P\n  rintro R _Rcr x\n  funext i\n  apply coeff_select\n#align select_is_poly select_is_poly\n\n",
 "select_add_select_not":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem select_add_select_not : ∀ x : (expr𝕎) R, select P x + select (fun i => ¬P i) x = x :=\n  by\n  ghost_calc _\n  intro n\n  simp only [RingHom.map_add]\n  suffices\n    (bind₁ (select_poly P)) (witt_polynomial p ℤ n) + (bind₁ (select_poly fun i => ¬P i)) (witt_polynomial p ℤ n) =\n      witt_polynomial p ℤ n\n    by\n    apply_fun aeval x.coeff  at this\n    simpa only [alg_hom.map_add, aeval_bind₁, ← coeff_select]\n  simp only [witt_polynomial_eq_sum_C_mul_X_pow, select_poly, alg_hom.map_sum, alg_hom.map_pow, alg_hom.map_mul,\n    bind₁_X_right, bind₁_C_right, ← finset.sum_add_distrib, ← mul_add]\n  apply finset.sum_congr rfl\n  refine' fun m hm => mul_eq_mul_left_iff.mpr (or.inl _)\n  rw [ite_pow, ite_pow, zero_pow (pow_pos hp.out.pos _)]\n  by_cases Pm : P m\n  · rw [if_pos Pm, if_neg _, add_zero]\n    exact not_not.mpr Pm\n  · rwa [if_neg Pm, if_pos, zero_add]\n#align select_add_select_not select_add_select_not\n\n",
 "init_zsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem init_zsmul (m : ℤ) (x : (expr𝕎) R) (n : ℕ) : init n («expr • » m x) = init n («expr • » m (init n x)) := by\n  init_ring using fun p [fact (Nat.Prime p)] n => witt_zsmul_vars p m n\n#align init_zsmul init_zsmul\n\n",
 "init_sub":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem init_sub (x y : (expr𝕎) R) (n : ℕ) : init n (x - y) = init n (init n x - init n y) := by\n  init_ring using witt_sub_vars\n#align init_sub init_sub\n\n",
 "init_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem init_pow (m : ℕ) (x : (expr𝕎) R) (n : ℕ) : init n (x ^ m) = init n (init n x ^ m) := by\n  init_ring using fun p [fact (Nat.Prime p)] n => witt_pow_vars p m n\n#align init_pow init_pow\n\n",
 "init_nsmul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr • » -/\ntheorem init_nsmul (m : ℕ) (x : (expr𝕎) R) (n : ℕ) : init n («expr • » m x) = init n («expr • » m (init n x)) := by\n  init_ring using fun p [fact (Nat.Prime p)] n => witt_nsmul_vars p m n\n#align init_nsmul init_nsmul\n\n",
 "init_neg":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem init_neg (x : (expr𝕎) R) (n : ℕ) : init n (-x) = init n (-init n x) := by init_ring using witt_neg_vars\n#align init_neg init_neg\n\n",
 "init_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem init_mul (x y : (expr𝕎) R) (n : ℕ) : init n (x * y) = init n (init n x * init n y) := by\n  init_ring using witt_mul_vars\n#align init_mul init_mul\n\n",
 "init_is_poly":
 "/-- `witt_vector.init n x` is polynomial in the coefficients of `x`. -/\ntheorem init_is_poly (n : ℕ) : is_poly p fun R _Rcr => init n :=\n  select_is_poly fun i => i < n\n#align init_is_poly init_is_poly\n\n",
 "init_init":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n@[simp]\ntheorem init_init (x : (expr𝕎) R) (n : ℕ) : init n (init n x) = init n x := by init_ring\n#align init_init init_init\n\n",
 "init_add_tail":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n@[simp]\ntheorem init_add_tail (x : (expr𝕎) R) (n : ℕ) : init n x + tail n x = x := by\n  simp only [init, tail, ← not_lt, select_add_select_not]\n#align init_add_tail init_add_tail\n\n",
 "init_add":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem init_add (x y : (expr𝕎) R) (n : ℕ) : init n (x + y) = init n (init n x + init n y) := by\n  init_ring using witt_add_vars\n#align init_add init_add\n\n",
 "coeff_select":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/-\nCopyright (c) 2020 Johan Commelin, Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Robert Y. Lewis\n-/\n-- type as `\\bbW`\ntheorem coeff_select (x : (expr𝕎) R) (n : ℕ) : (select P x).coeff n = aeval x.coeff (select_poly P n) :=\n  by\n  dsimp [select, select_poly]\n  split_ifs with hi\n  · rw [aeval_X]\n  · rw [alg_hom.map_zero]\n#align coeff_select coeff_select\n\n",
 "coeff_add_of_disjoint":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem coeff_add_of_disjoint (x y : (expr𝕎) R) (h : ∀ n, x.coeff n = 0 ∨ y.coeff n = 0) :\n    (x + y).coeff n = x.coeff n + y.coeff n :=\n  by\n  let P : ℕ → Prop := fun n => y.coeff n = 0\n  haveI : decidable_pred P := classical.dec_pred P\n  set z := mk p fun n => if P n then x.coeff n else y.coeff n with hz\n  have hx : select P z = x := by\n    ext1 n\n    rw [select, coeff_mk, coeff_mk]\n    split_ifs with hn\n    · rfl\n    · rw [(h n).resolve_right hn]\n  have hy : select (fun i => ¬P i) z = y := by\n    ext1 n\n    rw [select, coeff_mk, coeff_mk]\n    split_ifs with hn\n    · exact hn.symm\n    · rfl\n  calc\n    (x + y).coeff n = z.coeff n := by rw [← hx, ← hy, select_add_select_not P z]\n    _ = x.coeff n + y.coeff n := _\n    \n  dsimp [z]\n  split_ifs with hn\n  · dsimp [P] at hn\n    rw [hn, add_zero]\n  · rw [(h n).resolve_right hn, zero_add]\n#align coeff_add_of_disjoint coeff_add_of_disjoint\n\n"}