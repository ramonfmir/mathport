{"poly_eq_of_witt_polynomial_bind_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Robert Y. Lewis\n-/\n/-\n### Simplification tactics\n\n`ghost_simp` is used later in the development for certain simplifications.\nWe define it here so it is a shared import.\n-/\n-- type as `\\bbW`\ntheorem poly_eq_of_witt_polynomial_bind_eq' (f g : ℕ → mv_polynomial (idx × ℕ) ℤ)\n    (h : ∀ n, bind₁ f (witt_polynomial p _ n) = bind₁ g (witt_polynomial p _ n)) : f = g :=\n  by\n  ext1 n\n  apply mv_polynomial.map_injective (Int.castRingHom (exprℚ)) Int.cast_injective\n  rw [← function.funext_iff] at h\n  replace h :=\n    congr_arg (fun fam => bind₁ (mv_polynomial.map (Int.castRingHom (exprℚ)) ∘ fam) (X_in_terms_of_W p (exprℚ) n)) h\n  simpa only [function.comp, map_bind₁, map_witt_polynomial, ← bind₁_bind₁, bind₁_witt_polynomial_X_in_terms_of_W,\n    bind₁_X_right] using h\n#align poly_eq_of_witt_polynomial_bind_eq' poly_eq_of_witt_polynomial_bind_eq'\n\n",
 "poly_eq_of_witt_polynomial_bind_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\ntheorem poly_eq_of_witt_polynomial_bind_eq (f g : ℕ → mv_polynomial ℕ ℤ)\n    (h : ∀ n, bind₁ f (witt_polynomial p _ n) = bind₁ g (witt_polynomial p _ n)) : f = g :=\n  by\n  ext1 n\n  apply mv_polynomial.map_injective (Int.castRingHom (exprℚ)) Int.cast_injective\n  rw [← function.funext_iff] at h\n  replace h :=\n    congr_arg (fun fam => bind₁ (mv_polynomial.map (Int.castRingHom (exprℚ)) ∘ fam) (X_in_terms_of_W p (exprℚ) n)) h\n  simpa only [function.comp, map_bind₁, map_witt_polynomial, ← bind₁_bind₁, bind₁_witt_polynomial_X_in_terms_of_W,\n    bind₁_X_right] using h\n#align poly_eq_of_witt_polynomial_bind_eq poly_eq_of_witt_polynomial_bind_eq\n\n",
 "neg_is_poly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/-- The additive negation is a polynomial function on Witt vectors. -/\n@[is_poly]\ntheorem neg_is_poly : is_poly p fun R _ => @has_neg.neg ((expr𝕎) R) _ :=\n  ⟨⟨fun n => rename prod.snd (witt_neg p n), by\n      intros ; funext n\n      rw [neg_coeff, aeval_eq_eval₂_hom, eval₂_hom_rename]\n      apply eval₂_hom_congr rfl _ rfl\n      ext ⟨i, k⟩; fin_cases i; rfl⟩⟩\n#align neg_is_poly neg_is_poly\n\n",
 "mul_is_poly₂":
 "/-- Multiplication of Witt vectors is a polynomial function. -/\n@[is_poly]\ntheorem mul_is_poly₂ [fact p.prime] : is_poly₂ p fun _ _ => (· * ·) :=\n  ⟨⟨witt_mul p, by\n      intros\n      dsimp only [witt_vector.has_mul]\n      simp [eval]⟩⟩\n#align mul_is_poly₂ mul_is_poly₂\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n-- unfortunately this is not universe polymorphic, merely because `f` isn't\ntheorem map {f} (hf : is_poly₂ p f) (g : «expr →+* » R S) (x y : (expr𝕎) R) : map g (f x y) = f (map g x) (map g y) :=\n  by\n  -- this could be turned into a tactic “macro” (taking `hf` as parameter)\n  -- so that applications do not have to worry about the universe issue\n  obtain ⟨φ, hf⟩ := hf\n  ext n\n  simp only [map_coeff, hf, map_aeval, peval, uncurry]\n  apply eval₂_hom_congr (RingHom.ext_int _ _) _ rfl\n  try ext ⟨i, k⟩; fin_cases i\n  all_goals simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]\n#align map map\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ≃+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem ext {f g} (hf : is_poly₂ p f) (hg : is_poly₂ p g)\n    (h :\n      ∀ (R : Type u) [_Rcr : CommRing R] (x y : (expr𝕎) R) (n : ℕ),\n        ghost_component n (f x y) = ghost_component n (g x y)) :\n    ∀ (R) [_Rcr : CommRing R] (x y : (expr𝕎) R), f x y = g x y :=\n  by\n  obtain ⟨φ, hf⟩ := hf\n  obtain ⟨ψ, hg⟩ := hg\n  intros\n  ext n\n  rw [hf, hg, poly_eq_of_witt_polynomial_bind_eq' p φ ψ]\n  clear x y\n  intro k\n  apply mv_polynomial.funext\n  intro x\n  simp only [hom_bind₁]\n  specialize h (ULift ℤ) (mk p fun i => ⟨x (0, i)⟩) (mk p fun i => ⟨x (1, i)⟩) k\n  simp only [ghost_component_apply, aeval_eq_eval₂_hom] at h\n  apply (ulift.ring_equiv.symm : «expr ≃+* » ℤ _).injective\n  simp only [← RingEquiv.coe_toRingHom, map_eval₂_hom]\n  convert h using 1\n  all_goals\n    funext i\n    simp only [hf, hg, mv_polynomial.eval, map_eval₂_hom]\n    apply eval₂_hom_congr (RingHom.ext_int _ _) _ rfl\n    ext1\n    apply eval₂_hom_congr (RingHom.ext_int _ _) _ rfl\n    ext ⟨b, _⟩\n    fin_cases b <;> simp only [coeff_mk, uncurry] <;> rfl\n#align ext ext\n\n",
 "diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- The diagonal `λ x, f x x` of a polynomial function `f` is polynomial. -/\ntheorem is_poly₂.diag {f} (hf : is_poly₂ p f) : is_poly p fun R _Rcr x => f x x :=\n  by\n  obtain ⟨φ, hf⟩ := hf\n  refine'\n    ⟨⟨fun n =>\n        bind₁\n          (uncurry («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\"))\n          (φ n),\n        _⟩⟩\n  intros ; funext n\n  simp only [hf, peval, uncurry, aeval_bind₁]\n  apply eval₂_hom_congr rfl _ rfl\n  ext ⟨i, k⟩; fin_cases i <;> simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]\n#align is_poly₂.diag is_poly₂.diag\n\n",
 "comp₂":
 "/-- The composition of a polynomial function with a binary polynomial function is polynomial. -/\ntheorem is_poly.comp₂ {g f} (hg : is_poly p g) (hf : is_poly₂ p f) : is_poly₂ p fun R _Rcr x y => g (f x y) :=\n  by\n  obtain ⟨φ, hf⟩ := hf\n  obtain ⟨ψ, hg⟩ := hg\n  use fun n => bind₁ φ (ψ n)\n  intros\n  simp only [peval, aeval_bind₁, function.comp, hg, hf]\n#align is_poly.comp₂ is_poly.comp₂\n\n",
 "comp_right":
 "/-- The composition of a binary polynomial function\n with a unary polynomial function in the second argument is polynomial. -/\ntheorem comp_right {g f} (hg : is_poly₂ p g) (hf : is_poly p f) : is_poly₂ p fun R _Rcr x y => g x (f y) :=\n  hg.comp (witt_vector.id_is_poly p) hf\n#align comp_right comp_right\n\n",
 "comp_left":
 "/-- The composition of a binary polynomial function\n with a unary polynomial function in the first argument is polynomial. -/\ntheorem comp_left {g f} (hg : is_poly₂ p g) (hf : is_poly p f) : is_poly₂ p fun R _Rcr x y => g (f x) y :=\n  hg.comp hf (witt_vector.id_is_poly _)\n#align comp_left comp_left\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- The composition of polynomial functions is polynomial. -/\ntheorem is_poly₂.comp {h f g} (hh : is_poly₂ p h) (hf : is_poly p f) (hg : is_poly p g) :\n    is_poly₂ p fun R _Rcr x y => h (f x) (g y) :=\n  by\n  obtain ⟨φ, hf⟩ := hf\n  obtain ⟨ψ, hg⟩ := hg\n  obtain ⟨χ, hh⟩ := hh\n  refine'\n    ⟨⟨fun n =>\n        bind₁\n          (uncurry <| «expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\")\n          (χ n),\n        _⟩⟩\n  intros\n  funext n\n  simp only [peval, aeval_bind₁, function.comp, hh, hf, hg, uncurry]\n  apply eval₂_hom_congr rfl _ rfl\n  ext ⟨i, n⟩\n  fin_cases i <;>\n    simp only [aeval_eq_eval₂_hom, eval₂_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons,\n      matrix.cons_val_one]\n#align is_poly₂.comp is_poly₂.comp\n\n",
 "bind₁_zero_witt_polynomial":
 "/- To avoid a theory of 0-ary functions (a.k.a. constants)\nwe model them as constant unary functions. -/\n@[simp]\ntheorem bind₁_zero_witt_polynomial (n : ℕ) : bind₁ (0 : ℕ → mv_polynomial ℕ R) (witt_polynomial p R n) = 0 := by\n  rw [← aeval_eq_bind₁, aeval_zero, constant_coeff_witt_polynomial, RingHom.map_zero]\n#align bind₁_zero_witt_polynomial bind₁_zero_witt_polynomial\n\n",
 "bind₁_one_poly_witt_polynomial":
 "@[simp]\ntheorem bind₁_one_poly_witt_polynomial (n : ℕ) : bind₁ one_poly (witt_polynomial p ℤ n) = 1 :=\n  by\n  rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum, finset.sum_eq_single 0]\n  · simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bind₁_X_right, if_true, eq_self_iff_true]\n  · intro i hi hi0\n    simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero, alg_hom.map_pow, bind₁_X_right,\n      alg_hom.map_mul]\n  · rw [Finset.mem_range]\n    decide\n#align bind₁_one_poly_witt_polynomial bind₁_one_poly_witt_polynomial\n\n",
 "add_is_poly₂":
 "/-- Addition of Witt vectors is a polynomial function. -/\n@[is_poly]\ntheorem add_is_poly₂ [fact p.prime] : is_poly₂ p fun _ _ => (· + ·) :=\n  ⟨⟨witt_add p, by\n      intros\n      dsimp only [witt_vector.has_add]\n      simp [eval]⟩⟩\n#align add_is_poly₂ add_is_poly₂\n\n"}