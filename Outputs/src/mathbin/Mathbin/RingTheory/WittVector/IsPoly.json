{"poly_eq_of_witt_polynomial_bind_eq'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Robert Y. Lewis\n-/\n/-\n### Simplification tactics\n\n`ghost_simp` is used later in the development for certain simplifications.\nWe define it here so it is a shared import.\n-/\n-- type as `\\bbW`\ntheorem poly_eq_of_witt_polynomial_bind_eq' (f g : â„• â†’ mv_polynomial (idx Ã— â„•) â„¤)\n    (h : âˆ€ n, bindâ‚ f (witt_polynomial p _ n) = bindâ‚ g (witt_polynomial p _ n)) : f = g :=\n  by\n  ext1 n\n  apply mv_polynomial.map_injective (Int.castRingHom (exprâ„š)) Int.cast_injective\n  rw [â† function.funext_iff] at h\n  replace h :=\n    congr_arg (fun fam => bindâ‚ (mv_polynomial.map (Int.castRingHom (exprâ„š)) âˆ˜ fam) (X_in_terms_of_W p (exprâ„š) n)) h\n  simpa only [function.comp, map_bindâ‚, map_witt_polynomial, â† bindâ‚_bindâ‚, bindâ‚_witt_polynomial_X_in_terms_of_W,\n    bindâ‚_X_right] using h\n#align poly_eq_of_witt_polynomial_bind_eq' poly_eq_of_witt_polynomial_bind_eq'\n\n",
 "poly_eq_of_witt_polynomial_bind_eq":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprâ„š -/\ntheorem poly_eq_of_witt_polynomial_bind_eq (f g : â„• â†’ mv_polynomial â„• â„¤)\n    (h : âˆ€ n, bindâ‚ f (witt_polynomial p _ n) = bindâ‚ g (witt_polynomial p _ n)) : f = g :=\n  by\n  ext1 n\n  apply mv_polynomial.map_injective (Int.castRingHom (exprâ„š)) Int.cast_injective\n  rw [â† function.funext_iff] at h\n  replace h :=\n    congr_arg (fun fam => bindâ‚ (mv_polynomial.map (Int.castRingHom (exprâ„š)) âˆ˜ fam) (X_in_terms_of_W p (exprâ„š) n)) h\n  simpa only [function.comp, map_bindâ‚, map_witt_polynomial, â† bindâ‚_bindâ‚, bindâ‚_witt_polynomial_X_in_terms_of_W,\n    bindâ‚_X_right] using h\n#align poly_eq_of_witt_polynomial_bind_eq poly_eq_of_witt_polynomial_bind_eq\n\n",
 "neg_is_poly":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/-- The additive negation is a polynomial function on Witt vectors. -/\n@[is_poly]\ntheorem neg_is_poly : is_poly p fun R _ => @has_neg.neg ((exprğ•) R) _ :=\n  âŸ¨âŸ¨fun n => rename prod.snd (witt_neg p n), by\n      intros ; funext n\n      rw [neg_coeff, aeval_eq_evalâ‚‚_hom, evalâ‚‚_hom_rename]\n      apply evalâ‚‚_hom_congr rfl _ rfl\n      ext âŸ¨i, kâŸ©; fin_cases i; rflâŸ©âŸ©\n#align neg_is_poly neg_is_poly\n\n",
 "mul_is_polyâ‚‚":
 "/-- Multiplication of Witt vectors is a polynomial function. -/\n@[is_poly]\ntheorem mul_is_polyâ‚‚ [fact p.prime] : is_polyâ‚‚ p fun _ _ => (Â· * Â·) :=\n  âŸ¨âŸ¨witt_mul p, by\n      intros\n      dsimp only [witt_vector.has_mul]\n      simp [eval]âŸ©âŸ©\n#align mul_is_polyâ‚‚ mul_is_polyâ‚‚\n\n",
 "map":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n-- unfortunately this is not universe polymorphic, merely because `f` isn't\ntheorem map {f} (hf : is_polyâ‚‚ p f) (g : Â«expr â†’+* Â» R S) (x y : (exprğ•) R) : map g (f x y) = f (map g x) (map g y) :=\n  by\n  -- this could be turned into a tactic â€œmacroâ€ (taking `hf` as parameter)\n  -- so that applications do not have to worry about the universe issue\n  obtain âŸ¨Ï†, hfâŸ© := hf\n  ext n\n  simp only [map_coeff, hf, map_aeval, peval, uncurry]\n  apply evalâ‚‚_hom_congr (RingHom.ext_int _ _) _ rfl\n  try ext âŸ¨i, kâŸ©; fin_cases i\n  all_goals simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]\n#align map map\n\n",
 "ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â‰ƒ+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\ntheorem ext {f g} (hf : is_polyâ‚‚ p f) (hg : is_polyâ‚‚ p g)\n    (h :\n      âˆ€ (R : Type u) [_Rcr : CommRing R] (x y : (exprğ•) R) (n : â„•),\n        ghost_component n (f x y) = ghost_component n (g x y)) :\n    âˆ€ (R) [_Rcr : CommRing R] (x y : (exprğ•) R), f x y = g x y :=\n  by\n  obtain âŸ¨Ï†, hfâŸ© := hf\n  obtain âŸ¨Ïˆ, hgâŸ© := hg\n  intros\n  ext n\n  rw [hf, hg, poly_eq_of_witt_polynomial_bind_eq' p Ï† Ïˆ]\n  clear x y\n  intro k\n  apply mv_polynomial.funext\n  intro x\n  simp only [hom_bindâ‚]\n  specialize h (ULift â„¤) (mk p fun i => âŸ¨x (0, i)âŸ©) (mk p fun i => âŸ¨x (1, i)âŸ©) k\n  simp only [ghost_component_apply, aeval_eq_evalâ‚‚_hom] at h\n  apply (ulift.ring_equiv.symm : Â«expr â‰ƒ+* Â» â„¤ _).injective\n  simp only [â† RingEquiv.coe_toRingHom, map_evalâ‚‚_hom]\n  convert h using 1\n  all_goals\n    funext i\n    simp only [hf, hg, mv_polynomial.eval, map_evalâ‚‚_hom]\n    apply evalâ‚‚_hom_congr (RingHom.ext_int _ _) _ rfl\n    ext1\n    apply evalâ‚‚_hom_congr (RingHom.ext_int _ _) _ rfl\n    ext âŸ¨b, _âŸ©\n    fin_cases b <;> simp only [coeff_mk, uncurry] <;> rfl\n#align ext ext\n\n",
 "diag":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/-- The diagonal `Î» x, f x x` of a polynomial function `f` is polynomial. -/\ntheorem is_polyâ‚‚.diag {f} (hf : is_polyâ‚‚ p f) : is_poly p fun R _Rcr x => f x x :=\n  by\n  obtain âŸ¨Ï†, hfâŸ© := hf\n  refine'\n    âŸ¨âŸ¨fun n =>\n        bindâ‚\n          (uncurry (Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\"))\n          (Ï† n),\n        _âŸ©âŸ©\n  intros ; funext n\n  simp only [hf, peval, uncurry, aeval_bindâ‚]\n  apply evalâ‚‚_hom_congr rfl _ rfl\n  ext âŸ¨i, kâŸ©; fin_cases i <;> simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]\n#align is_polyâ‚‚.diag is_polyâ‚‚.diag\n\n",
 "compâ‚‚":
 "/-- The composition of a polynomial function with a binary polynomial function is polynomial. -/\ntheorem is_poly.compâ‚‚ {g f} (hg : is_poly p g) (hf : is_polyâ‚‚ p f) : is_polyâ‚‚ p fun R _Rcr x y => g (f x y) :=\n  by\n  obtain âŸ¨Ï†, hfâŸ© := hf\n  obtain âŸ¨Ïˆ, hgâŸ© := hg\n  use fun n => bindâ‚ Ï† (Ïˆ n)\n  intros\n  simp only [peval, aeval_bindâ‚, function.comp, hg, hf]\n#align is_poly.compâ‚‚ is_poly.compâ‚‚\n\n",
 "comp_right":
 "/-- The composition of a binary polynomial function\n with a unary polynomial function in the second argument is polynomial. -/\ntheorem comp_right {g f} (hg : is_polyâ‚‚ p g) (hf : is_poly p f) : is_polyâ‚‚ p fun R _Rcr x y => g x (f y) :=\n  hg.comp (witt_vector.id_is_poly p) hf\n#align comp_right comp_right\n\n",
 "comp_left":
 "/-- The composition of a binary polynomial function\n with a unary polynomial function in the first argument is polynomial. -/\ntheorem comp_left {g f} (hg : is_polyâ‚‚ p g) (hf : is_poly p f) : is_polyâ‚‚ p fun R _Rcr x y => g (f x) y :=\n  hg.comp hf (witt_vector.id_is_poly _)\n#align comp_left comp_left\n\n",
 "comp":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr![ ,]Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â» -/\n/-- The composition of polynomial functions is polynomial. -/\ntheorem is_polyâ‚‚.comp {h f g} (hh : is_polyâ‚‚ p h) (hf : is_poly p f) (hg : is_poly p g) :\n    is_polyâ‚‚ p fun R _Rcr x y => h (f x) (g y) :=\n  by\n  obtain âŸ¨Ï†, hfâŸ© := hf\n  obtain âŸ¨Ïˆ, hgâŸ© := hg\n  obtain âŸ¨Ï‡, hhâŸ© := hh\n  refine'\n    âŸ¨âŸ¨fun n =>\n        bindâ‚\n          (uncurry <| Â«expr![ ,]Â» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `Â«expr![ ,]Â»\")\n          (Ï‡ n),\n        _âŸ©âŸ©\n  intros\n  funext n\n  simp only [peval, aeval_bindâ‚, function.comp, hh, hf, hg, uncurry]\n  apply evalâ‚‚_hom_congr rfl _ rfl\n  ext âŸ¨i, nâŸ©\n  fin_cases i <;>\n    simp only [aeval_eq_evalâ‚‚_hom, evalâ‚‚_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons,\n      matrix.cons_val_one]\n#align is_polyâ‚‚.comp is_polyâ‚‚.comp\n\n",
 "bindâ‚_zero_witt_polynomial":
 "/- To avoid a theory of 0-ary functions (a.k.a. constants)\nwe model them as constant unary functions. -/\n@[simp]\ntheorem bindâ‚_zero_witt_polynomial (n : â„•) : bindâ‚ (0 : â„• â†’ mv_polynomial â„• R) (witt_polynomial p R n) = 0 := by\n  rw [â† aeval_eq_bindâ‚, aeval_zero, constant_coeff_witt_polynomial, RingHom.map_zero]\n#align bindâ‚_zero_witt_polynomial bindâ‚_zero_witt_polynomial\n\n",
 "bindâ‚_one_poly_witt_polynomial":
 "@[simp]\ntheorem bindâ‚_one_poly_witt_polynomial (n : â„•) : bindâ‚ one_poly (witt_polynomial p â„¤ n) = 1 :=\n  by\n  rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum, finset.sum_eq_single 0]\n  Â· simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bindâ‚_X_right, if_true, eq_self_iff_true]\n  Â· intro i hi hi0\n    simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero, alg_hom.map_pow, bindâ‚_X_right,\n      alg_hom.map_mul]\n  Â· rw [Finset.mem_range]\n    decide\n#align bindâ‚_one_poly_witt_polynomial bindâ‚_one_poly_witt_polynomial\n\n",
 "add_is_polyâ‚‚":
 "/-- Addition of Witt vectors is a polynomial function. -/\n@[is_poly]\ntheorem add_is_polyâ‚‚ [fact p.prime] : is_polyâ‚‚ p fun _ _ => (Â· + Â·) :=\n  âŸ¨âŸ¨witt_add p, by\n      intros\n      dsimp only [witt_vector.has_add]\n      simp [eval]âŸ©âŸ©\n#align add_is_polyâ‚‚ add_is_polyâ‚‚\n\n"}