{"teichmuller_zero":
 "@[simp]\ntheorem teichmuller_zero : teichmuller p (0 : R) = 0 := by\n  ext ⟨⟩ <;>\n    · rw [zero_coeff]\n      rfl\n#align teichmuller_zero teichmuller_zero\n\n",
 "teichmuller_mul_aux₂":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprivate theorem teichmuller_mul_aux₂ (x y : MvPolynomial R ℤ) :\n    teichmuller_fun p (x * y) = teichmuller_fun p x * teichmuller_fun p y :=\n  by\n  refine' map_injective (MvPolynomial.map (Int.castRingHom (exprℚ))) (MvPolynomial.map_injective _ Int.cast_injective) _\n  simp only [teichmuller_mul_aux₁, map_teichmuller_fun, RingHom.map_mul]\n#align teichmuller_mul_aux₂ teichmuller_mul_aux₂\n\n",
 "teichmuller_mul_aux₁":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprℚ -/\nprivate theorem teichmuller_mul_aux₁ (x y : MvPolynomial R (exprℚ)) :\n    teichmuller_fun p (x * y) = teichmuller_fun p x * teichmuller_fun p y :=\n  by\n  apply (ghost_map.bijective_of_invertible p (MvPolynomial R (exprℚ))).1\n  rw [RingHom.map_mul]\n  ext1 n\n  simp only [Pi.mul_apply, ghost_map_apply, ghost_component_teichmuller_fun, mul_pow]\n#align teichmuller_mul_aux₁ teichmuller_mul_aux₁\n\n",
 "teichmuller_coeff_zero":
 "@[simp]\ntheorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r :=\n  rfl\n#align teichmuller_coeff_zero teichmuller_coeff_zero\n\n",
 "teichmuller_coeff_pos":
 "@[simp]\ntheorem teichmuller_coeff_pos (r : R) : ∀ (n : ℕ) (hn : 0 < n), (teichmuller p r).coeff n = 0\n  | n + 1, _ => rfl\n#align teichmuller_coeff_pos teichmuller_coeff_pos\n\n",
 "map_teichmuller_fun":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\nprivate theorem map_teichmuller_fun (f : «expr →+* » R S) (r : R) :\n    map f (teichmuller_fun p r) = teichmuller_fun p (f r) :=\n  by\n  ext n\n  cases n\n  · rfl\n  · exact f.map_zero\n#align map_teichmuller_fun map_teichmuller_fun\n\n",
 "map_teichmuller":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/-- `teichmuller` is a natural transformation. -/\n@[simp]\ntheorem map_teichmuller (f : «expr →+* » R S) (r : R) : map f (teichmuller p r) = teichmuller p (f r) :=\n  map_teichmuller_fun _ _ _\n#align map_teichmuller map_teichmuller\n\n",
 "ghost_component_teichmuller_fun":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n-- type as `\\bbW`\nprivate theorem ghost_component_teichmuller_fun (r : R) (n : ℕ) : ghost_component n (teichmuller_fun p r) = r ^ p ^ n :=\n  by\n  rw [ghost_component_apply, aeval_witt_polynomial, Finset.sum_eq_single 0, pow_zero, one_mul, tsub_zero]\n  · rfl\n  · intro i hi h0\n    convert MulZeroClass.mul_zero _\n    convert zero_pow _\n    · cases i\n      · contradiction\n      · rfl\n    · exact pow_pos hp.1.pos _\n  · rw [Finset.mem_range]\n    intro h\n    exact (h (nat.succ_pos n)).elim\n#align ghost_component_teichmuller_fun ghost_component_teichmuller_fun\n\n",
 "ghost_component_teichmuller":
 "/-- The `n`-th ghost component of `teichmuller p r` is `r ^ p ^ n`. -/\n@[simp]\ntheorem ghost_component_teichmuller (r : R) (n : ℕ) : ghost_component n (teichmuller p r) = r ^ p ^ n :=\n  ghost_component_teichmuller_fun _ _ _\n#align ghost_component_teichmuller ghost_component_teichmuller\n\n"}