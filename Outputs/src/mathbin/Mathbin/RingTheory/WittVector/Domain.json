{"verschiebung_shift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\ntheorem verschiebung_shift (x : (exprğ•) R) (k : â„•) (h : âˆ€ i < k + 1, x.coeff i = 0) :\n    verschiebung (x.shift k.succ) = x.shift k := by\n  ext âŸ¨jâŸ©\n  Â· rw [verschiebung_coeff_zero, shift_coeff, h]\n    apply nat.lt_succ_self\n  Â· simp only [verschiebung_coeff_succ, shift]\n    congr 1\n    rw [nat.add_succ, add_comm, nat.add_succ, add_comm]\n#align verschiebung_shift verschiebung_shift\n\n",
 "verschiebung_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\ntheorem verschiebung_nonzero {x : (exprğ•) R} (hx : x â‰  0) :\n    âˆƒ n : â„•, âˆƒ x' : (exprğ•) R, x'.coeff 0 â‰  0 âˆ§ x = (Â«expr ^[ ]Â» verschiebung n) x' :=\n  by\n  have hex : âˆƒ k : â„•, x.coeff k â‰  0 := by\n    by_contra' hall\n    apply hx\n    ext i\n    simp only [hall, zero_coeff]\n  let n := nat.find hex\n  use n, x.shift n\n  refine' âŸ¨nat.find_spec hex, eq_iterate_verschiebung fun i hi => not_not.mp _âŸ©\n  exact nat.find_min hex hi\n#align verschiebung_nonzero verschiebung_nonzero\n\n",
 "shift_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis\n-/\n-- type as `\\bbW`\ntheorem shift_coeff (x : (exprğ•) R) (n k : â„•) : (x.shift n).coeff k = x.coeff (n + k) :=\n  rfl\n#align shift_coeff shift_coeff\n\n",
 "eq_iterate_verschiebung":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr ^[ ]Â» -/\ntheorem eq_iterate_verschiebung {x : (exprğ•) R} {n : â„•} (h : âˆ€ i < n, x.coeff i = 0) :\n    x = (Â«expr ^[ ]Â» verschiebung n) (x.shift n) :=\n  by\n  induction' n with k ih\n  Â· cases x <;> simp [shift]\n  Â· dsimp\n    rw [verschiebung_shift]\n    Â· exact ih fun i hi => h _ (hi.trans (nat.lt_succ_self _))\n    Â· exact h\n#align eq_iterate_verschiebung eq_iterate_verschiebung\n\n"}