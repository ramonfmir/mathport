{"verschiebung_shift":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem verschiebung_shift (x : (expr𝕎) R) (k : ℕ) (h : ∀ i < k + 1, x.coeff i = 0) :\n    verschiebung (x.shift k.succ) = x.shift k := by\n  ext ⟨j⟩\n  · rw [verschiebung_coeff_zero, shift_coeff, h]\n    apply nat.lt_succ_self\n  · simp only [verschiebung_coeff_succ, shift]\n    congr 1\n    rw [nat.add_succ, add_comm, nat.add_succ, add_comm]\n#align verschiebung_shift verschiebung_shift\n\n",
 "verschiebung_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem verschiebung_nonzero {x : (expr𝕎) R} (hx : x ≠ 0) :\n    ∃ n : ℕ, ∃ x' : (expr𝕎) R, x'.coeff 0 ≠ 0 ∧ x = («expr ^[ ]» verschiebung n) x' :=\n  by\n  have hex : ∃ k : ℕ, x.coeff k ≠ 0 := by\n    by_contra' hall\n    apply hx\n    ext i\n    simp only [hall, zero_coeff]\n  let n := nat.find hex\n  use n, x.shift n\n  refine' ⟨nat.find_spec hex, eq_iterate_verschiebung fun i hi => not_not.mp _⟩\n  exact nat.find_min hex hi\n#align verschiebung_nonzero verschiebung_nonzero\n\n",
 "shift_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis\n-/\n-- type as `\\bbW`\ntheorem shift_coeff (x : (expr𝕎) R) (n k : ℕ) : (x.shift n).coeff k = x.coeff (n + k) :=\n  rfl\n#align shift_coeff shift_coeff\n\n",
 "eq_iterate_verschiebung":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ^[ ]» -/\ntheorem eq_iterate_verschiebung {x : (expr𝕎) R} {n : ℕ} (h : ∀ i < n, x.coeff i = 0) :\n    x = («expr ^[ ]» verschiebung n) (x.shift n) :=\n  by\n  induction' n with k ih\n  · cases x <;> simp [shift]\n  · dsimp\n    rw [verschiebung_shift]\n    · exact ih fun i hi => h _ (hi.trans (nat.lt_succ_self _))\n    · exact h\n#align eq_iterate_verschiebung eq_iterate_verschiebung\n\n"}