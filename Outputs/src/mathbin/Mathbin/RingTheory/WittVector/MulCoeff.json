{"witt_poly_prod_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Heather Macbeth\n-/\ntheorem witt_poly_prod_vars (n : ℕ) : (witt_poly_prod p n).vars ⊆ finset.product univ (range (n + 1)) :=\n  by\n  rw [witt_poly_prod]\n  apply subset.trans (vars_mul _ _)\n  apply union_subset <;>\n    · apply subset.trans (vars_rename _ _)\n      simp [witt_polynomial_vars, image_subset_iff]\n#align witt_poly_prod_vars witt_poly_prod_vars\n\n",
 "witt_poly_prod_remainder_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem witt_poly_prod_remainder_vars (n : ℕ) : (witt_poly_prod_remainder p n).vars ⊆ finset.product univ (range n) :=\n  by\n  rw [witt_poly_prod_remainder]\n  apply subset.trans (vars_sum_subset _ _)\n  rw [bUnion_subset]\n  intro x hx\n  apply subset.trans (vars_mul _ _)\n  apply union_subset\n  · apply subset.trans (vars_pow _ _)\n    have : (p : mv_polynomial (fin 2 × ℕ) ℤ) = C (p : ℤ) := by simp only [Int.cast_ofNat, eq_intCast]\n    rw [this, vars_C]\n    apply empty_subset\n  · apply subset.trans (vars_pow _ _)\n    apply subset.trans (witt_mul_vars _ _)\n    apply product_subset_product (subset.refl _)\n    simp only [mem_range, range_subset] at hx⊢\n    exact hx\n#align witt_poly_prod_remainder_vars witt_poly_prod_remainder_vars\n\n",
 "remainder_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem remainder_vars (n : ℕ) : (remainder p n).vars ⊆ finset.product univ (range (n + 1)) :=\n  by\n  rw [remainder]\n  apply subset.trans (vars_mul _ _)\n  apply union_subset <;>\n    · apply subset.trans (vars_sum_subset _ _)\n      rw [bUnion_subset]\n      intro x hx\n      rw [rename_monomial, vars_monomial, finsupp.map_domain_single]\n      · apply subset.trans finsupp.support_single_subset\n        simp [hx]\n      · apply pow_ne_zero\n        exact_mod_cast hp.out.ne_zero\n#align remainder_vars remainder_vars\n\n",
 "poly_of_interest_vars_eq":
 "theorem poly_of_interest_vars_eq (n : ℕ) :\n    (poly_of_interest p n).vars =\n      ((p ^ (n + 1) : mv_polynomial (fin 2 × ℕ) ℤ) *\n          (witt_mul p (n + 1) + p ^ (n + 1) * X (0, n + 1) * X (1, n + 1) -\n              X (0, n + 1) * rename (prod.mk (1 : fin 2)) (witt_polynomial p ℤ (n + 1)) -\n            X (1, n + 1) * rename (prod.mk (0 : fin 2)) (witt_polynomial p ℤ (n + 1)))).vars :=\n  by\n  have : (p ^ (n + 1) : mv_polynomial (fin 2 × ℕ) ℤ) = C (p ^ (n + 1) : ℤ) := by\n    simp only [Int.cast_ofNat, eq_intCast, C_pow, eq_self_iff_true]\n  rw [poly_of_interest, this, vars_C_mul]\n  apply pow_ne_zero\n  exact_mod_cast hp.out.ne_zero\n#align poly_of_interest_vars_eq poly_of_interest_vars_eq\n\n",
 "poly_of_interest_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem poly_of_interest_vars (n : ℕ) : (poly_of_interest p n).vars ⊆ finset.product univ (range (n + 1)) := by\n  rw [poly_of_interest_vars_eq] <;> apply mul_poly_of_interest_vars\n#align poly_of_interest_vars poly_of_interest_vars\n\n",
 "peval_poly_of_interest'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/-- The characteristic `p` version of `peval_poly_of_interest` -/\ntheorem peval_poly_of_interest' (n : ℕ) (x y : (expr𝕎) k) :\n    peval (poly_of_interest p n)\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") =\n      (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) - x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) :=\n  by\n  rw [peval_poly_of_interest]\n  have : (p : k) = 0 := char_p.cast_eq_zero k p\n  simp only [this, add_zero, zero_mul, nat.succ_ne_zero, ne.def, not_false_iff, zero_pow']\n  have sum_zero_pow_mul_pow_p :\n    ∀ y : (expr𝕎) k,\n      finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n          (range (n + 1 + 1)) (0 ^ x * y.coeff x ^ p ^ (n + 1 - x)) =\n        y.coeff 0 ^ p ^ (n + 1) :=\n    by\n    intro y\n    rw [finset.sum_eq_single_of_mem 0]\n    · simp\n    · simp\n    · intro j _ hj\n      simp [zero_pow (zero_lt_iff.mpr hj)]\n  congr <;> apply sum_zero_pow_mul_pow_p\n#align peval_poly_of_interest' peval_poly_of_interest'\n\n",
 "peval_poly_of_interest":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem peval_poly_of_interest (n : ℕ) (x y : (expr𝕎) k) :\n    peval (poly_of_interest p n)\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\") =\n      (x * y).coeff (n + 1) + p ^ (n + 1) * x.coeff (n + 1) * y.coeff (n + 1) -\n          y.coeff (n + 1) *\n            finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n              (range (n + 1 + 1)) (p ^ i * x.coeff i ^ p ^ (n + 1 - i)) -\n        x.coeff (n + 1) *\n          finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\"\n            (range (n + 1 + 1)) (p ^ i * y.coeff i ^ p ^ (n + 1 - i)) :=\n  by\n  simp only [poly_of_interest, peval, map_nat_cast, matrix.head_cons, map_pow, function.uncurry_apply_pair, aeval_X,\n    matrix.cons_val_one, map_mul, matrix.cons_val_zero, map_sub]\n  rw [sub_sub, add_comm (_ * _), ← sub_sub]\n  have mvpz : (p : mv_polynomial ℕ ℤ) = mv_polynomial.C ↑p := by rw [eq_intCast, Int.cast_ofNat]\n  have : ∀ (f : «expr →+* » ℤ k) (g : ℕ → k), eval₂ f g p = f p :=\n    by\n    intros\n    rw [mvpz, mv_polynomial.eval₂_C]\n  simp [witt_polynomial_eq_sum_C_mul_X_pow, aeval, eval₂_rename, this, mul_coeff, peval, map_nat_cast, map_add, map_pow,\n    map_mul]\n#align peval_poly_of_interest peval_poly_of_interest\n\n",
 "nth_remainder_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem nth_remainder_spec (n : ℕ) (x y : (expr𝕎) k) :\n    (x * y).coeff (n + 1) =\n      x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) + y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) +\n        nth_remainder p n (truncate_fun (n + 1) x) (truncate_fun (n + 1) y) :=\n  Classical.choose_spec (nth_mul_coeff p k n) _ _\n#align nth_remainder_spec nth_remainder_spec\n\n",
 "nth_mul_coeff'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem nth_mul_coeff' (n : ℕ) :\n    ∃ f : truncated_witt_vector p (n + 1) k → truncated_witt_vector p (n + 1) k → k,\n      ∀ x y : (expr𝕎) k,\n        f (truncate_fun (n + 1) x) (truncate_fun (n + 1) y) =\n          (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) -\n            x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) :=\n  by\n  simp only [← peval_poly_of_interest']\n  obtain ⟨f₀, hf₀⟩ := exists_restrict_to_vars k (poly_of_interest_vars p n)\n  let f : truncated_witt_vector p (n + 1) k → truncated_witt_vector p (n + 1) k → k :=\n    by\n    intro x y\n    apply f₀\n    rintro ⟨a, ha⟩\n    apply\n      function.uncurry\n        («expr![ ,]» \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `«expr![ ,]»\")\n    simp only [true_and_iff, Multiset.mem_cons, range_val, product_val, Multiset.mem_range, Multiset.mem_product,\n      Multiset.range_succ, mem_univ_val] at ha\n    refine' ⟨a.fst, ⟨a.snd, _⟩⟩\n    cases' ha with ha ha <;> linarith only [ha]\n  use f\n  intro x y\n  dsimp [peval]\n  rw [← hf₀]\n  simp only [f, function.uncurry_apply_pair]\n  congr\n  ext a\n  cases' a with a ha\n  cases' a with i m\n  simp only [true_and_iff, Multiset.mem_cons, range_val, product_val, Multiset.mem_range, Multiset.mem_product,\n    Multiset.range_succ, mem_univ_val] at ha\n  have ha' : m < n + 1 := by cases' ha with ha ha <;> linarith only [ha]\n  fin_cases i <;>-- surely this case split is not necessary\n    · simpa only using x.coeff_truncate_fun ⟨m, ha'⟩\n#align nth_mul_coeff' nth_mul_coeff'\n\n",
 "nth_mul_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem nth_mul_coeff (n : ℕ) :\n    ∃ f : truncated_witt_vector p (n + 1) k → truncated_witt_vector p (n + 1) k → k,\n      ∀ x y : (expr𝕎) k,\n        (x * y).coeff (n + 1) =\n          x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) + y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) +\n            f (truncate_fun (n + 1) x) (truncate_fun (n + 1) y) :=\n  by\n  obtain ⟨f, hf⟩ := nth_mul_coeff' p k n\n  use f\n  intro x y\n  rw [hf x y]\n  ring\n#align nth_mul_coeff nth_mul_coeff\n\n",
 "mul_poly_of_interest_vars":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.product -/\ntheorem mul_poly_of_interest_vars (n : ℕ) :\n    ((p ^ (n + 1) : mv_polynomial (fin 2 × ℕ) ℤ) * poly_of_interest p n).vars ⊆ finset.product univ (range (n + 1)) :=\n  by\n  rw [mul_poly_of_interest_aux5]\n  apply subset.trans (vars_sub_subset _ _)\n  apply union_subset\n  · apply remainder_vars\n  · apply witt_poly_prod_remainder_vars\n#align mul_poly_of_interest_vars mul_poly_of_interest_vars\n\n",
 "mul_poly_of_interest_aux5":
 "theorem mul_poly_of_interest_aux5 (n : ℕ) :\n    (p ^ (n + 1) : mv_polynomial (fin 2 × ℕ) ℤ) * poly_of_interest p n =\n      remainder p n - witt_poly_prod_remainder p (n + 1) :=\n  by\n  simp only [poly_of_interest, mul_sub, mul_add, sub_eq_iff_eq_add']\n  rw [mul_poly_of_interest_aux4 p n]\n  ring\n#align mul_poly_of_interest_aux5 mul_poly_of_interest_aux5\n\n",
 "mul_poly_of_interest_aux4":
 "theorem mul_poly_of_interest_aux4 (n : ℕ) :\n    (p ^ (n + 1) * witt_mul p (n + 1) : mv_polynomial (fin 2 × ℕ) ℤ) =\n      -(p ^ (n + 1) * X (0, n + 1)) * (p ^ (n + 1) * X (1, n + 1)) +\n            p ^ (n + 1) * X (0, n + 1) * rename (prod.mk (1 : fin 2)) (witt_polynomial p ℤ (n + 1)) +\n          p ^ (n + 1) * X (1, n + 1) * rename (prod.mk (0 : fin 2)) (witt_polynomial p ℤ (n + 1)) +\n        (remainder p n - witt_poly_prod_remainder p (n + 1)) :=\n  by\n  rw [← add_sub_assoc, eq_sub_iff_add_eq, mul_poly_of_interest_aux2]\n  exact mul_poly_of_interest_aux3 _ _\n#align mul_poly_of_interest_aux4 mul_poly_of_interest_aux4\n\n",
 "mul_poly_of_interest_aux3":
 "theorem mul_poly_of_interest_aux3 (n : ℕ) :\n    witt_poly_prod p (n + 1) =\n      -(p ^ (n + 1) * X (0, n + 1)) * (p ^ (n + 1) * X (1, n + 1)) +\n            p ^ (n + 1) * X (0, n + 1) * rename (prod.mk (1 : fin 2)) (witt_polynomial p ℤ (n + 1)) +\n          p ^ (n + 1) * X (1, n + 1) * rename (prod.mk (0 : fin 2)) (witt_polynomial p ℤ (n + 1)) +\n        remainder p n :=\n  by\n  -- a useful auxiliary fact\n  have mvpz : (p ^ (n + 1) : mv_polynomial (fin 2 × ℕ) ℤ) = mv_polynomial.C (↑p ^ (n + 1)) := by\n    simp only [Int.cast_ofNat, eq_intCast, C_pow, eq_self_iff_true]\n  -- unfold definitions and peel off the last entries of the sums.\n  rw [witt_poly_prod, witt_polynomial, alg_hom.map_sum, alg_hom.map_sum, sum_range_succ]\n  -- these are sums up to `n+2`, so be careful to only unfold to `n+1`.\n  conv_lhs =>\n    congr\n    skip\n    rw [sum_range_succ]\n  simp only [add_mul, mul_add, tsub_self, pow_zero, alg_hom.map_sum]\n  -- rearrange so that the first summand on rhs and lhs is `remainder`, and peel off\n  conv_rhs => rw [add_comm]\n  simp only [add_assoc]\n  apply congr_arg (has_add.add _)\n  conv_rhs => rw [sum_range_succ]\n  -- the rest is equal with proper unfolding and `ring`\n  simp only [rename_monomial, ← C_mul_X_pow_eq_monomial, map_mul, rename_C, pow_one, rename_X]\n  simp only [mvpz, Int.cast_ofNat, map_pow, eq_intCast, rename_X, pow_one, tsub_self, pow_zero]\n  ring1\n#align mul_poly_of_interest_aux3 mul_poly_of_interest_aux3\n\n",
 "mul_poly_of_interest_aux2":
 "theorem mul_poly_of_interest_aux2 (n : ℕ) :\n    (p ^ n * witt_mul p n : mv_polynomial (fin 2 × ℕ) ℤ) + witt_poly_prod_remainder p n = witt_poly_prod p n :=\n  by\n  convert mul_poly_of_interest_aux1 p n\n  rw [sum_range_succ, add_comm, nat.sub_self, pow_zero, pow_one]\n  rfl\n#align mul_poly_of_interest_aux2 mul_poly_of_interest_aux2\n\n",
 "mul_poly_of_interest_aux1":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `finset.sum -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum -/\ntheorem mul_poly_of_interest_aux1 (n : ℕ) :\n    (finset.sum \"./././Mathport/Syntax/Translate/Expr.lean:210:13: unsupported notation `finset.sum\" (range (n + 1))\n          (p ^ i * witt_mul p i ^ p ^ (n - i)) :\n        mv_polynomial (fin 2 × ℕ) ℤ) =\n      witt_poly_prod p n :=\n  by\n  simp only [witt_poly_prod]\n  convert witt_structure_int_prop p (X (0 : fin 2) * X 1) n using 1\n  · simp only [witt_polynomial, witt_mul]\n    rw [alg_hom.map_sum]\n    congr 1 with i\n    congr 1\n    have hsupp : (finsupp.single i (p ^ (n - i))).support = {i} :=\n      by\n      rw [finsupp.support_eq_singleton]\n      simp only [and_true_iff, finsupp.single_eq_same, eq_self_iff_true, ne.def]\n      exact pow_ne_zero _ hp.out.ne_zero\n    simp only [bind₁_monomial, hsupp, Int.cast_ofNat, prod_singleton, eq_intCast, finsupp.single_eq_same, C_pow,\n      mul_eq_mul_left_iff, true_or_iff, eq_self_iff_true]\n  · simp only [map_mul, bind₁_X_right]\n#align mul_poly_of_interest_aux1 mul_poly_of_interest_aux1\n\n"}