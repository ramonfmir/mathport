{"succ_nth_val_spec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem succ_nth_val_spec' (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : (exprùïé) k) (bs : Fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0)\n    (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    succ_nth_val p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ ^ p * a‚ÇÅ.coeff 0 ^ p ^ (n + 1) + a‚ÇÅ.coeff (n + 1) * (bs 0 ^ p) ^ p ^ (n + 1) +\n        nth_remainder p n (fun v => bs v ^ p) (truncate_fun (n + 1) a‚ÇÅ) =\n      succ_nth_val p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ * a‚ÇÇ.coeff 0 ^ p ^ (n + 1) + a‚ÇÇ.coeff (n + 1) * bs 0 ^ p ^ (n + 1) +\n        nth_remainder p n bs (truncate_fun (n + 1) a‚ÇÇ) :=\n  by\n  rw [‚Üê sub_eq_zero]\n  have := succ_nth_val_spec p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ\n  simp only [Polynomial.map_add, Polynomial.eval_X, Polynomial.map_pow, Polynomial.eval_C, Polynomial.eval_pow,\n    succ_nth_defining_poly, Polynomial.eval_mul, Polynomial.eval_add, Polynomial.eval_sub, Polynomial.map_mul,\n    Polynomial.map_sub, Polynomial.IsRoot.def] at this\n  convert this using 1\n  ring\n#align succ_nth_val_spec' succ_nth_val_spec'\n\n",
 "succ_nth_val_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem succ_nth_val_spec (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : (exprùïé) k) (bs : Fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0)\n    (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : (succ_nth_defining_poly p n a‚ÇÅ a‚ÇÇ bs).is_root (succ_nth_val p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ) :=\n  Classical.choose_spec (root_exists p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ)\n#align succ_nth_val_spec succ_nth_val_spec\n\n",
 "succ_nth_defining_poly_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Heather Macbeth\n-/\ntheorem succ_nth_defining_poly_degree [IsDomain k] (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : (exprùïé) k) (bs : Fin (n + 1) ‚Üí k)\n    (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : (succ_nth_defining_poly p n a‚ÇÅ a‚ÇÇ bs).degree = p :=\n  by\n  have : (X ^ p * C (a‚ÇÅ.coeff 0 ^ p ^ (n + 1))).degree = p :=\n    by\n    rw [degree_mul, degree_C]\n    ¬∑ simp only [Nat.cast_withBot, add_zero, degree_X, degree_pow, Nat.smul_one_eq_coe]\n    ¬∑ exact pow_ne_zero _ ha‚ÇÅ\n  have : (X ^ p * C (a‚ÇÅ.coeff 0 ^ p ^ (n + 1)) - X * C (a‚ÇÇ.coeff 0 ^ p ^ (n + 1))).degree = p :=\n    by\n    rw [degree_sub_eq_left_of_degree_lt, this]\n    rw [this, degree_mul, degree_C, degree_X, add_zero]\n    ¬∑ exact_mod_cast hp.out.one_lt\n    ¬∑ exact pow_ne_zero _ ha‚ÇÇ\n  rw [succ_nth_defining_poly, degree_add_eq_left_of_degree_lt, this]\n  apply lt_of_le_of_lt degree_C_le\n  rw [this]\n  exact_mod_cast hp.out.pos\n#align succ_nth_defining_poly_degree succ_nth_defining_poly_degree\n\n",
 "solution_spec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem solution_spec' {a‚ÇÅ : (exprùïé) k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (a‚ÇÇ : (exprùïé) k) :\n    solution p a‚ÇÅ a‚ÇÇ ^ p * a‚ÇÅ.coeff 0 = solution p a‚ÇÅ a‚ÇÇ * a‚ÇÇ.coeff 0 :=\n  by\n  have := solution_spec p a‚ÇÅ a‚ÇÇ\n  cases' nat.exists_eq_succ_of_ne_zero hp.out.ne_zero with q hq\n  have hq' : q = p - 1 := by simp only [hq, tsub_zero, nat.succ_sub_succ_eq_sub]\n  conv_lhs =>\n    congr\n    congr\n    skip\n    rw [hq]\n  rw [pow_succ', hq', this]\n  field_simp [ha‚ÇÅ, mul_comm]\n#align solution_spec' solution_spec'\n\n",
 "solution_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem solution_spec (a‚ÇÅ a‚ÇÇ : (exprùïé) k) : solution p a‚ÇÅ a‚ÇÇ ^ (p - 1) = a‚ÇÇ.coeff 0 / a‚ÇÅ.coeff 0 :=\n  Classical.choose_spec <| solution_pow p a‚ÇÅ a‚ÇÇ\n#align solution_spec solution_spec\n\n",
 "solution_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem solution_pow (a‚ÇÅ a‚ÇÇ : (exprùïé) k) : ‚àÉ x : k, x ^ (p - 1) = a‚ÇÇ.coeff 0 / a‚ÇÅ.coeff 0 :=\n  is_alg_closed.exists_pow_nat_eq _ <| by linarith [hp.out.one_lt, le_of_lt hp.out.one_lt]\n#align solution_pow solution_pow\n\n",
 "solution_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem solution_nonzero {a‚ÇÅ a‚ÇÇ : (exprùïé) k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) : solution p a‚ÇÅ a‚ÇÇ ‚â† 0 :=\n  by\n  intro h\n  have := solution_spec p a‚ÇÅ a‚ÇÇ\n  rw [h, zero_pow] at this\n  ¬∑ simpa [ha‚ÇÅ, ha‚ÇÇ] using _root_.div_eq_zero_iff.mp this.symm\n  ¬∑ linarith [hp.out.one_lt, le_of_lt hp.out.one_lt]\n#align solution_nonzero solution_nonzero\n\n",
 "root_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem root_exists (n : ‚Ñï) (a‚ÇÅ a‚ÇÇ : (exprùïé) k) (bs : Fin (n + 1) ‚Üí k) (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    ‚àÉ b : k, (succ_nth_defining_poly p n a‚ÇÅ a‚ÇÇ bs).is_root b :=\n  is_alg_closed.exists_root _ <| by\n    simp only [succ_nth_defining_poly_degree p n a‚ÇÅ a‚ÇÇ bs ha‚ÇÅ ha‚ÇÇ, hp.out.ne_zero, WithTop.coe_eq_zero, ne.def,\n      not_false_iff]\n#align root_exists root_exists\n\n",
 "frobenius_rotation_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem frobenius_rotation_nonzero {a‚ÇÅ a‚ÇÇ : (exprùïé) k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    frobenius_rotation p ha‚ÇÅ ha‚ÇÇ ‚â† 0 := by\n  intro h\n  apply solution_nonzero p ha‚ÇÅ ha‚ÇÇ\n  simpa [‚Üê h, frobenius_rotation, frobenius_rotation_coeff] using witt_vector.zero_coeff p k 0\n#align frobenius_rotation_nonzero frobenius_rotation_nonzero\n\n",
 "frobenius_frobenius_rotation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem frobenius_frobenius_rotation {a‚ÇÅ a‚ÇÇ : (exprùïé) k} (ha‚ÇÅ : a‚ÇÅ.coeff 0 ‚â† 0) (ha‚ÇÇ : a‚ÇÇ.coeff 0 ‚â† 0) :\n    frobenius (frobenius_rotation p ha‚ÇÅ ha‚ÇÇ) * a‚ÇÅ = frobenius_rotation p ha‚ÇÅ ha‚ÇÇ * a‚ÇÇ :=\n  by\n  ext n\n  induction' n with n ih\n  ¬∑ simp only [witt_vector.mul_coeff_zero, witt_vector.coeff_frobenius_char_p, frobenius_rotation,\n      frobenius_rotation_coeff]\n    apply solution_spec' _ ha‚ÇÅ\n  ¬∑ simp only [nth_remainder_spec, witt_vector.coeff_frobenius_char_p, frobenius_rotation_coeff, frobenius_rotation,\n      [anonymous]]\n    have := succ_nth_val_spec' p n a‚ÇÅ a‚ÇÇ (fun i : Fin (n + 1) => frobenius_rotation_coeff p ha‚ÇÅ ha‚ÇÇ i.val) ha‚ÇÅ ha‚ÇÇ\n    simp only [frobenius_rotation_coeff, [anonymous], fin.val_zero] at this\n    convert this using 4\n    apply truncated_witt_vector.ext\n    intro i\n    simp only [[anonymous], witt_vector.coeff_truncate_fun, witt_vector.coeff_frobenius_char_p]\n    rfl\n#align frobenius_frobenius_rotation frobenius_frobenius_rotation\n\n",
 "exists_frobenius_solution_fraction_ring_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\ntheorem exists_frobenius_solution_fraction_ring_aux (m n : ‚Ñï) (r' q' : (exprùïé) k) (hr' : r'.coeff 0 ‚â† 0)\n    (hq' : q'.coeff 0 ‚â† 0) (hq : ‚Üëp ^ n * q' ‚àà nonZeroDivisors ((exprùïé) k)) :\n    let b : (exprùïé) k := frobenius_rotation p hr' hq'\n    IsFractionRing.fieldEquivOfRingEquiv (frobenius_equiv p k) (algebraMap ((exprùïé) k) (FractionRing ((exprùïé) k)) b) *\n        Localization.mk (‚Üëp ^ m * r') ‚ü®‚Üëp ^ n * q', hq‚ü© =\n      ‚Üëp ^ (m - n : ‚Ñ§) * algebraMap ((exprùïé) k) (FractionRing ((exprùïé) k)) b :=\n  by\n  intro b\n  have key : witt_vector.frobenius b * p ^ m * r' * p ^ n = p ^ m * b * (p ^ n * q') :=\n    by\n    have H := congr_arg (fun x : (exprùïé) k => x * p ^ m * p ^ n) (frobenius_frobenius_rotation p hr' hq')\n    dsimp at H\n    refine' (Eq.trans _ H).trans _ <;> ring\n  have hq'' : algebraMap ((exprùïé) k) (FractionRing ((exprùïé) k)) q' ‚â† 0 :=\n    by\n    have hq''' : q' ‚â† 0 := fun h => hq' (by simp [h])\n    simpa only [ne.def, map_zero] using (IsFractionRing.injective ((exprùïé) k) (FractionRing ((exprùïé) k))).ne hq'''\n  rw [zpow_sub‚ÇÄ (fraction_ring.p_nonzero p k)]\n  field_simp [fraction_ring.p_nonzero p k]\n  simp only [IsFractionRing.fieldEquivOfRingEquiv, IsLocalization.ringEquivOfRingEquiv_eq, RingEquiv.coe_ofBijective]\n  convert congr_arg (fun x => algebraMap ((exprùïé) k) (FractionRing ((exprùïé) k)) x) key using 1\n  ¬∑ simp only [RingHom.map_mul, RingHom.map_pow, map_natCast, frobenius_equiv_apply]\n    ring\n  ¬∑ simp only [RingHom.map_mul, RingHom.map_pow, map_natCast]\n#align exists_frobenius_solution_fraction_ring_aux exists_frobenius_solution_fraction_ring_aux\n\n",
 "exists_frobenius_solution_fraction_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprœÜ -/\ntheorem exists_frobenius_solution_fraction_ring {a : FractionRing ((exprùïé) k)} (ha : a ‚â† 0) :\n    ‚àÉ (b : FractionRing ((exprùïé) k))(hb : b ‚â† 0)(m : ‚Ñ§), (exprœÜ) b * a = p ^ m * b :=\n  by\n  revert ha\n  refine' Localization.induction_on a _\n  rintro ‚ü®r, q, hq‚ü© hrq\n  have hq0 : q ‚â† 0 := mem_nonZeroDivisors_iff_ne_zero.1 hq\n  have hr0 : r ‚â† 0 := fun h => hrq (by simp [h])\n  obtain ‚ü®m, r', hr', rfl‚ü© := exists_eq_pow_p_mul r hr0\n  obtain ‚ü®n, q', hq', rfl‚ü© := exists_eq_pow_p_mul q hq0\n  let b := frobenius_rotation p hr' hq'\n  refine' ‚ü®algebraMap ((exprùïé) k) _ b, _, m - n, _‚ü©\n  ¬∑\n    simpa only [map_zero] using\n      (IsFractionRing.injective (witt_vector p k) (FractionRing (witt_vector p k))).ne\n        (frobenius_rotation_nonzero p hr' hq')\n  exact exists_frobenius_solution_fraction_ring_aux p m n r' q' hr' hq' hq\n#align exists_frobenius_solution_fraction_ring exists_frobenius_solution_fraction_ring\n\n"}