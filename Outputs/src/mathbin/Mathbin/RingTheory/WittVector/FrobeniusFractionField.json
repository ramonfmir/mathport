{"succ_nth_val_spec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem succ_nth_val_spec' (n : ℕ) (a₁ a₂ : (expr𝕎) k) (bs : Fin (n + 1) → k) (ha₁ : a₁.coeff 0 ≠ 0)\n    (ha₂ : a₂.coeff 0 ≠ 0) :\n    succ_nth_val p n a₁ a₂ bs ha₁ ha₂ ^ p * a₁.coeff 0 ^ p ^ (n + 1) + a₁.coeff (n + 1) * (bs 0 ^ p) ^ p ^ (n + 1) +\n        nth_remainder p n (fun v => bs v ^ p) (truncate_fun (n + 1) a₁) =\n      succ_nth_val p n a₁ a₂ bs ha₁ ha₂ * a₂.coeff 0 ^ p ^ (n + 1) + a₂.coeff (n + 1) * bs 0 ^ p ^ (n + 1) +\n        nth_remainder p n bs (truncate_fun (n + 1) a₂) :=\n  by\n  rw [← sub_eq_zero]\n  have := succ_nth_val_spec p n a₁ a₂ bs ha₁ ha₂\n  simp only [Polynomial.map_add, Polynomial.eval_X, Polynomial.map_pow, Polynomial.eval_C, Polynomial.eval_pow,\n    succ_nth_defining_poly, Polynomial.eval_mul, Polynomial.eval_add, Polynomial.eval_sub, Polynomial.map_mul,\n    Polynomial.map_sub, Polynomial.IsRoot.def] at this\n  convert this using 1\n  ring\n#align succ_nth_val_spec' succ_nth_val_spec'\n\n",
 "succ_nth_val_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem succ_nth_val_spec (n : ℕ) (a₁ a₂ : (expr𝕎) k) (bs : Fin (n + 1) → k) (ha₁ : a₁.coeff 0 ≠ 0)\n    (ha₂ : a₂.coeff 0 ≠ 0) : (succ_nth_defining_poly p n a₁ a₂ bs).is_root (succ_nth_val p n a₁ a₂ bs ha₁ ha₂) :=\n  Classical.choose_spec (root_exists p n a₁ a₂ bs ha₁ ha₂)\n#align succ_nth_val_spec succ_nth_val_spec\n\n",
 "succ_nth_defining_poly_degree":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Heather Macbeth\n-/\ntheorem succ_nth_defining_poly_degree [IsDomain k] (n : ℕ) (a₁ a₂ : (expr𝕎) k) (bs : Fin (n + 1) → k)\n    (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) : (succ_nth_defining_poly p n a₁ a₂ bs).degree = p :=\n  by\n  have : (X ^ p * C (a₁.coeff 0 ^ p ^ (n + 1))).degree = p :=\n    by\n    rw [degree_mul, degree_C]\n    · simp only [Nat.cast_withBot, add_zero, degree_X, degree_pow, Nat.smul_one_eq_coe]\n    · exact pow_ne_zero _ ha₁\n  have : (X ^ p * C (a₁.coeff 0 ^ p ^ (n + 1)) - X * C (a₂.coeff 0 ^ p ^ (n + 1))).degree = p :=\n    by\n    rw [degree_sub_eq_left_of_degree_lt, this]\n    rw [this, degree_mul, degree_C, degree_X, add_zero]\n    · exact_mod_cast hp.out.one_lt\n    · exact pow_ne_zero _ ha₂\n  rw [succ_nth_defining_poly, degree_add_eq_left_of_degree_lt, this]\n  apply lt_of_le_of_lt degree_C_le\n  rw [this]\n  exact_mod_cast hp.out.pos\n#align succ_nth_defining_poly_degree succ_nth_defining_poly_degree\n\n",
 "solution_spec'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem solution_spec' {a₁ : (expr𝕎) k} (ha₁ : a₁.coeff 0 ≠ 0) (a₂ : (expr𝕎) k) :\n    solution p a₁ a₂ ^ p * a₁.coeff 0 = solution p a₁ a₂ * a₂.coeff 0 :=\n  by\n  have := solution_spec p a₁ a₂\n  cases' nat.exists_eq_succ_of_ne_zero hp.out.ne_zero with q hq\n  have hq' : q = p - 1 := by simp only [hq, tsub_zero, nat.succ_sub_succ_eq_sub]\n  conv_lhs =>\n    congr\n    congr\n    skip\n    rw [hq]\n  rw [pow_succ', hq', this]\n  field_simp [ha₁, mul_comm]\n#align solution_spec' solution_spec'\n\n",
 "solution_spec":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem solution_spec (a₁ a₂ : (expr𝕎) k) : solution p a₁ a₂ ^ (p - 1) = a₂.coeff 0 / a₁.coeff 0 :=\n  Classical.choose_spec <| solution_pow p a₁ a₂\n#align solution_spec solution_spec\n\n",
 "solution_pow":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem solution_pow (a₁ a₂ : (expr𝕎) k) : ∃ x : k, x ^ (p - 1) = a₂.coeff 0 / a₁.coeff 0 :=\n  is_alg_closed.exists_pow_nat_eq _ <| by linarith [hp.out.one_lt, le_of_lt hp.out.one_lt]\n#align solution_pow solution_pow\n\n",
 "solution_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem solution_nonzero {a₁ a₂ : (expr𝕎) k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) : solution p a₁ a₂ ≠ 0 :=\n  by\n  intro h\n  have := solution_spec p a₁ a₂\n  rw [h, zero_pow] at this\n  · simpa [ha₁, ha₂] using _root_.div_eq_zero_iff.mp this.symm\n  · linarith [hp.out.one_lt, le_of_lt hp.out.one_lt]\n#align solution_nonzero solution_nonzero\n\n",
 "root_exists":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem root_exists (n : ℕ) (a₁ a₂ : (expr𝕎) k) (bs : Fin (n + 1) → k) (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) :\n    ∃ b : k, (succ_nth_defining_poly p n a₁ a₂ bs).is_root b :=\n  is_alg_closed.exists_root _ <| by\n    simp only [succ_nth_defining_poly_degree p n a₁ a₂ bs ha₁ ha₂, hp.out.ne_zero, WithTop.coe_eq_zero, ne.def,\n      not_false_iff]\n#align root_exists root_exists\n\n",
 "frobenius_rotation_nonzero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem frobenius_rotation_nonzero {a₁ a₂ : (expr𝕎) k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) :\n    frobenius_rotation p ha₁ ha₂ ≠ 0 := by\n  intro h\n  apply solution_nonzero p ha₁ ha₂\n  simpa [← h, frobenius_rotation, frobenius_rotation_coeff] using witt_vector.zero_coeff p k 0\n#align frobenius_rotation_nonzero frobenius_rotation_nonzero\n\n",
 "frobenius_frobenius_rotation":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem frobenius_frobenius_rotation {a₁ a₂ : (expr𝕎) k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) :\n    frobenius (frobenius_rotation p ha₁ ha₂) * a₁ = frobenius_rotation p ha₁ ha₂ * a₂ :=\n  by\n  ext n\n  induction' n with n ih\n  · simp only [witt_vector.mul_coeff_zero, witt_vector.coeff_frobenius_char_p, frobenius_rotation,\n      frobenius_rotation_coeff]\n    apply solution_spec' _ ha₁\n  · simp only [nth_remainder_spec, witt_vector.coeff_frobenius_char_p, frobenius_rotation_coeff, frobenius_rotation,\n      [anonymous]]\n    have := succ_nth_val_spec' p n a₁ a₂ (fun i : Fin (n + 1) => frobenius_rotation_coeff p ha₁ ha₂ i.val) ha₁ ha₂\n    simp only [frobenius_rotation_coeff, [anonymous], fin.val_zero] at this\n    convert this using 4\n    apply truncated_witt_vector.ext\n    intro i\n    simp only [[anonymous], witt_vector.coeff_truncate_fun, witt_vector.coeff_frobenius_char_p]\n    rfl\n#align frobenius_frobenius_rotation frobenius_frobenius_rotation\n\n",
 "exists_frobenius_solution_fraction_ring_aux":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem exists_frobenius_solution_fraction_ring_aux (m n : ℕ) (r' q' : (expr𝕎) k) (hr' : r'.coeff 0 ≠ 0)\n    (hq' : q'.coeff 0 ≠ 0) (hq : ↑p ^ n * q' ∈ nonZeroDivisors ((expr𝕎) k)) :\n    let b : (expr𝕎) k := frobenius_rotation p hr' hq'\n    IsFractionRing.fieldEquivOfRingEquiv (frobenius_equiv p k) (algebraMap ((expr𝕎) k) (FractionRing ((expr𝕎) k)) b) *\n        Localization.mk (↑p ^ m * r') ⟨↑p ^ n * q', hq⟩ =\n      ↑p ^ (m - n : ℤ) * algebraMap ((expr𝕎) k) (FractionRing ((expr𝕎) k)) b :=\n  by\n  intro b\n  have key : witt_vector.frobenius b * p ^ m * r' * p ^ n = p ^ m * b * (p ^ n * q') :=\n    by\n    have H := congr_arg (fun x : (expr𝕎) k => x * p ^ m * p ^ n) (frobenius_frobenius_rotation p hr' hq')\n    dsimp at H\n    refine' (Eq.trans _ H).trans _ <;> ring\n  have hq'' : algebraMap ((expr𝕎) k) (FractionRing ((expr𝕎) k)) q' ≠ 0 :=\n    by\n    have hq''' : q' ≠ 0 := fun h => hq' (by simp [h])\n    simpa only [ne.def, map_zero] using (IsFractionRing.injective ((expr𝕎) k) (FractionRing ((expr𝕎) k))).ne hq'''\n  rw [zpow_sub₀ (fraction_ring.p_nonzero p k)]\n  field_simp [fraction_ring.p_nonzero p k]\n  simp only [IsFractionRing.fieldEquivOfRingEquiv, IsLocalization.ringEquivOfRingEquiv_eq, RingEquiv.coe_ofBijective]\n  convert congr_arg (fun x => algebraMap ((expr𝕎) k) (FractionRing ((expr𝕎) k)) x) key using 1\n  · simp only [RingHom.map_mul, RingHom.map_pow, map_natCast, frobenius_equiv_apply]\n    ring\n  · simp only [RingHom.map_mul, RingHom.map_pow, map_natCast]\n#align exists_frobenius_solution_fraction_ring_aux exists_frobenius_solution_fraction_ring_aux\n\n",
 "exists_frobenius_solution_fraction_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprφ -/\ntheorem exists_frobenius_solution_fraction_ring {a : FractionRing ((expr𝕎) k)} (ha : a ≠ 0) :\n    ∃ (b : FractionRing ((expr𝕎) k))(hb : b ≠ 0)(m : ℤ), (exprφ) b * a = p ^ m * b :=\n  by\n  revert ha\n  refine' Localization.induction_on a _\n  rintro ⟨r, q, hq⟩ hrq\n  have hq0 : q ≠ 0 := mem_nonZeroDivisors_iff_ne_zero.1 hq\n  have hr0 : r ≠ 0 := fun h => hrq (by simp [h])\n  obtain ⟨m, r', hr', rfl⟩ := exists_eq_pow_p_mul r hr0\n  obtain ⟨n, q', hq', rfl⟩ := exists_eq_pow_p_mul q hq0\n  let b := frobenius_rotation p hr' hq'\n  refine' ⟨algebraMap ((expr𝕎) k) _ b, _, m - n, _⟩\n  ·\n    simpa only [map_zero] using\n      (IsFractionRing.injective (witt_vector p k) (FractionRing (witt_vector p k))).ne\n        (frobenius_rotation_nonzero p hr' hq')\n  exact exists_frobenius_solution_fraction_ring_aux p m n r' q' hr' hq' hq\n#align exists_frobenius_solution_fraction_ring exists_frobenius_solution_fraction_ring\n\n"}