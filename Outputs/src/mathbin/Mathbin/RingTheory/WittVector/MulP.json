{"mul_n_is_poly":
 "/-- Multiplication by `n` is a polynomial function. -/\n@[is_poly]\ntheorem mul_n_is_poly (n : ‚Ñï) : is_poly p fun R _Rcr x => x * n :=\n  ‚ü®‚ü®witt_mul_n p n, fun R _Rcr x => by\n      funext k\n      exact mul_n_coeff n x k‚ü©‚ü©\n#align mul_n_is_poly mul_n_is_poly\n\n",
 "mul_n_coeff":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprùïé -/\n/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\n-- type as `\\bbW`\ntheorem mul_n_coeff (n : ‚Ñï) (x : (exprùïé) R) (k : ‚Ñï) : (x * n).coeff k = aeval x.coeff (witt_mul_n p n k) :=\n  by\n  induction' n with n ih generalizing k\n  ¬∑ simp only [Nat.zero_eq, Nat.cast_zero, mul_zero, zero_coeff, witt_mul_n, alg_hom.map_zero, pi.zero_apply]\n  ¬∑ rw [witt_mul_n, nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one, mul_add, mul_one, aeval_bind‚ÇÅ, add_coeff]\n    apply eval‚ÇÇ_hom_congr (RingHom.ext_int _ _) _ rfl\n    ext1 ‚ü®b, i‚ü©\n    fin_cases b\n    ¬∑ simp only [function.uncurry, matrix.cons_val_zero, ih]\n    ¬∑ simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X]\n#align mul_n_coeff mul_n_coeff\n\n",
 "bind‚ÇÅ_witt_mul_n_witt_polynomial":
 "@[simp]\ntheorem bind‚ÇÅ_witt_mul_n_witt_polynomial (n k : ‚Ñï) :\n    bind‚ÇÅ (witt_mul_n p n) (witt_polynomial p ‚Ñ§ k) = n * witt_polynomial p ‚Ñ§ k :=\n  by\n  induction' n with n ih\n  ¬∑ simp only [witt_mul_n, Nat.cast_zero, zero_mul, bind‚ÇÅ_zero_witt_polynomial]\n  ¬∑ rw [witt_mul_n, ‚Üê bind‚ÇÅ_bind‚ÇÅ, witt_add, witt_structure_int_prop]\n    simp only [alg_hom.map_add, Nat.cast_succ, bind‚ÇÅ_X_right]\n    rw [add_mul, one_mul, bind‚ÇÅ_rename, bind‚ÇÅ_rename]\n    simp only [ih, function.uncurry, function.comp, bind‚ÇÅ_X_left, alg_hom.id_apply, matrix.cons_val_zero,\n      matrix.head_cons, matrix.cons_val_one]\n#align bind‚ÇÅ_witt_mul_n_witt_polynomial bind‚ÇÅ_witt_mul_n_witt_polynomial\n\n"}