{"zmod_equiv_trunc_compat":
 "theorem zmod_equiv_trunc_compat (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂) :\n    (truncated_witt_vector.truncate hk).comp ((zmod_equiv_trunc p k₂).to_ring_hom.comp (padic_int.to_zmod_pow k₂)) =\n      (zmod_equiv_trunc p k₁).to_ring_hom.comp (padic_int.to_zmod_pow k₁) :=\n  by rw [← RingHom.comp_assoc, commutes, RingHom.comp_assoc, padic_int.zmod_cast_comp_to_zmod_pow]\n#align zmod_equiv_trunc_compat zmod_equiv_trunc_compat\n\n",
 "zmod_equiv_trunc_apply":
 "theorem zmod_equiv_trunc_apply {x : ZMod (p ^ n)} :\n    zmod_equiv_trunc p n x = ZMod.castHom (by rfl) (truncated_witt_vector p n (ZMod p)) x :=\n  rfl\n#align zmod_equiv_trunc_apply zmod_equiv_trunc_apply\n\n",
 "to_zmod_pow_compat":
 "theorem to_zmod_pow_compat (m n : ℕ) (h : m ≤ n) :\n    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (to_zmod_pow p n) = to_zmod_pow p m :=\n  calc\n    (ZMod.castHom _ (ZMod (p ^ m))).comp ((zmod_equiv_trunc p n).symm.to_ring_hom.comp (truncate n)) =\n        ((zmod_equiv_trunc p m).symm.to_ring_hom.comp (truncated_witt_vector.truncate h)).comp (truncate n) :=\n      by rw [commutes_symm, RingHom.comp_assoc]\n    _ = (zmod_equiv_trunc p m).symm.to_ring_hom.comp (truncate m) := by\n      rw [RingHom.comp_assoc, truncate_comp_witt_vector_truncate]\n    \n#align to_zmod_pow_compat to_zmod_pow_compat\n\n",
 "to_padic_int_comp_from_padic_int_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem to_padic_int_comp_from_padic_int_ext (x) :\n    (to_padic_int p).comp (from_padic_int p) x = RingHom.id («exprℤ_[ ]» p) x := by\n  rw [to_padic_int_comp_from_padic_int]\n#align to_padic_int_comp_from_padic_int_ext to_padic_int_comp_from_padic_int_ext\n\n",
 "to_padic_int_comp_from_padic_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«exprℤ_[ ]» -/\ntheorem to_padic_int_comp_from_padic_int : (to_padic_int p).comp (from_padic_int p) = RingHom.id («exprℤ_[ ]» p) :=\n  by\n  rw [← padic_int.to_zmod_pow_eq_iff_ext]\n  intro n\n  rw [← RingHom.comp_assoc, to_padic_int, padic_int.lift_spec]\n  simp only [from_padic_int, to_zmod_pow, RingHom.comp_id]\n  rw [RingHom.comp_assoc, truncate_comp_lift, ← RingHom.comp_assoc]\n  simp only [RingEquiv.symm_toRingHom_comp_toRingHom, RingHom.id_comp]\n#align to_padic_int_comp_from_padic_int to_padic_int_comp_from_padic_int\n\n",
 "from_padic_int_comp_to_padic_int_ext":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem from_padic_int_comp_to_padic_int_ext (x) :\n    (from_padic_int p).comp (to_padic_int p) x = RingHom.id ((expr𝕎) (ZMod p)) x := by\n  rw [from_padic_int_comp_to_padic_int]\n#align from_padic_int_comp_to_padic_int_ext from_padic_int_comp_to_padic_int_ext\n\n",
 "from_padic_int_comp_to_padic_int":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem from_padic_int_comp_to_padic_int : (from_padic_int p).comp (to_padic_int p) = RingHom.id ((expr𝕎) (ZMod p)) :=\n  by\n  apply witt_vector.hom_ext\n  intro n\n  rw [from_padic_int, ← RingHom.comp_assoc, truncate_comp_lift, RingHom.comp_assoc]\n  simp only [to_padic_int, to_zmod_pow, RingHom.comp_id, padic_int.lift_spec, RingHom.id_comp, ← RingHom.comp_assoc,\n    RingEquiv.toRingHom_comp_symm_toRingHom]\n#align from_padic_int_comp_to_padic_int from_padic_int_comp_to_padic_int\n\n",
 "eq_of_le_of_cast_pow_eq_zero":
 "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Robert Y. Lewis\n-/\ntheorem eq_of_le_of_cast_pow_eq_zero [CharP R p] (i : ℕ) (hin : i ≤ n)\n    (hpi : (p ^ i : truncated_witt_vector p n R) = 0) : i = n :=\n  by\n  contrapose! hpi\n  replace hin := lt_of_le_of_ne hin hpi\n  clear hpi\n  have : (↑p ^ i : truncated_witt_vector p n R) = witt_vector.truncate n (↑p ^ i) := by\n    rw [RingHom.map_pow, map_natCast]\n  rw [this, ext_iff, not_forall]\n  clear this\n  use ⟨i, hin⟩\n  rw [witt_vector.coeff_truncate, coeff_zero, Fin.val_mk, witt_vector.coeff_p_pow]\n  haveI : Nontrivial R := CharP.nontrivial_of_char_ne_one hp.1.ne_one\n  exact one_ne_zero\n#align eq_of_le_of_cast_pow_eq_zero eq_of_le_of_cast_pow_eq_zero\n\n",
 "commutes_symm'":
 "theorem commutes_symm' {m : ℕ} (hm : n ≤ m) (x : truncated_witt_vector p m (ZMod p)) :\n    (zmod_equiv_trunc p n).symm (truncate hm x) = ZMod.castHom (pow_dvd_pow p hm) _ ((zmod_equiv_trunc p m).symm x) :=\n  by\n  apply (zmod_equiv_trunc p n).injective\n  rw [← commutes']\n  simp\n#align commutes_symm' commutes_symm'\n\n",
 "commutes_symm":
 "/-- The following diagram commutes:\n```text\ntruncated_witt_vector p n (zmod p) ----> truncated_witt_vector p m (zmod p)\n            |                                        |\n            |                                        |\n            v                                        v\n          zmod (p^n) ----------------------------> zmod (p^m)\n```\nHere the vertical arrows are `(truncated_witt_vector.zmod_equiv_trunc p _).symm`,\nthe horizontal arrow at the top is `zmod.cast_hom`,\nand the horizontal arrow at the bottom is `truncated_witt_vector.truncate`.\n-/\ntheorem commutes_symm {m : ℕ} (hm : n ≤ m) :\n    (zmod_equiv_trunc p n).symm.to_ring_hom.comp (truncate hm) =\n      (ZMod.castHom (pow_dvd_pow p hm) _).comp (zmod_equiv_trunc p m).symm.to_ring_hom :=\n  by ext <;> apply commutes_symm'\n#align commutes_symm commutes_symm\n\n",
 "commutes'":
 "theorem commutes' {m : ℕ} (hm : n ≤ m) (x : ZMod (p ^ m)) :\n    truncate hm (zmod_equiv_trunc p m x) = zmod_equiv_trunc p n (ZMod.castHom (pow_dvd_pow p hm) _ x) :=\n  show (truncate hm).comp (zmod_equiv_trunc p m).to_ring_hom x = _ by rw [commutes _ _ hm] <;> rfl\n#align commutes' commutes'\n\n",
 "commutes":
 "/-- The following diagram commutes:\n```text\n          zmod (p^n) ----------------------------> zmod (p^m)\n            |                                        |\n            |                                        |\n            v                                        v\ntruncated_witt_vector p n (zmod p) ----> truncated_witt_vector p m (zmod p)\n```\nHere the vertical arrows are `truncated_witt_vector.zmod_equiv_trunc`,\nthe horizontal arrow at the top is `zmod.cast_hom`,\nand the horizontal arrow at the bottom is `truncated_witt_vector.truncate`.\n-/\ntheorem commutes {m : ℕ} (hm : n ≤ m) :\n    (truncate hm).comp (zmod_equiv_trunc p m).to_ring_hom =\n      (zmod_equiv_trunc p n).to_ring_hom.comp (ZMod.castHom (pow_dvd_pow p hm) _) :=\n  RingHom.ext_zmod _ _\n#align commutes commutes\n\n",
 "char_p_zmod":
 "theorem char_p_zmod : CharP (truncated_witt_vector p n (ZMod p)) (p ^ n) :=\n  charP_of_prime_pow_injective _ _ _ (card_zmod _ _) (eq_of_le_of_cast_pow_eq_zero p n (ZMod p))\n#align char_p_zmod char_p_zmod\n\n",
 "card_zmod":
 "theorem card_zmod : Fintype.card (truncated_witt_vector p n (ZMod p)) = p ^ n := by rw [card, ZMod.card]\n#align card_zmod card_zmod\n\n"}