{"is_unit_of_coeff_zero_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr ˣ» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem is_unit_of_coeff_zero_ne_zero (x : (expr𝕎) k) (hx : x.coeff 0 ≠ 0) : IsUnit x :=\n  by\n  let y : «expr ˣ» k := Units.mk0 (x.coeff 0) hx\n  have hy : x.coeff 0 = y := rfl\n  exact (mk_unit hy).is_unit\n#align is_unit_of_coeff_zero_ne_zero is_unit_of_coeff_zero_ne_zero\n\n",
 "exists_eq_pow_p_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem exists_eq_pow_p_mul' (a : (expr𝕎) k) (ha : a ≠ 0) : ∃ (m : ℕ)(b : Units ((expr𝕎) k)), a = p ^ m * b :=\n  by\n  obtain ⟨m, b, h₁, h₂⟩ := exists_eq_pow_p_mul a ha\n  let b₀ := Units.mk0 (b.coeff 0) h₁\n  have hb₀ : b.coeff 0 = b₀ := rfl\n  exact ⟨m, mk_unit hb₀, h₂⟩\n#align exists_eq_pow_p_mul' exists_eq_pow_p_mul'\n\n",
 "exists_eq_pow_p_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\ntheorem exists_eq_pow_p_mul (a : (expr𝕎) k) (ha : a ≠ 0) : ∃ (m : ℕ)(b : (expr𝕎) k), b.coeff 0 ≠ 0 ∧ a = p ^ m * b :=\n  by\n  obtain ⟨m, c, hc, hcm⟩ := witt_vector.verschiebung_nonzero ha\n  obtain ⟨b, rfl⟩ := (frobenius_bijective p k).surjective.iterate m c\n  rw [witt_vector.iterate_frobenius_coeff] at hc\n  have := congr_fun (witt_vector.verschiebung_frobenius_comm.comp_iterate m) b\n  simp only [Function.comp_apply] at this\n  rw [← this] at hcm\n  refine' ⟨m, b, _, _⟩\n  · contrapose! hc\n    have : 0 < p ^ m := pow_pos (Nat.Prime.pos (fact.out _)) _\n    simp [hc, zero_pow this]\n  · rw [← mul_left_iterate (p : (expr𝕎) k) m]\n    convert hcm\n    ext1 x\n    rw [mul_comm, ← witt_vector.verschiebung_frobenius x]\n#align exists_eq_pow_p_mul exists_eq_pow_p_mul\n\n",
 "discrete_valuation_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/-\nNote: The following lemma should be an instance, but it seems to cause some\nexponential blowups in certain typeclass resolution problems.\nSee the following Lean4 issue as well as the zulip discussion linked there:\nhttps://github.com/leanprover/lean4/issues/1102\n-/\n/-- The ring of Witt Vectors of a perfect field of positive characteristic is a DVR.\n-/\ntheorem discrete_valuation_ring : discrete_valuation_ring ((expr𝕎) k) :=\n  discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization\n    (by\n      refine' ⟨p, Irreducible p, fun x hx => _⟩\n      obtain ⟨n, b, hb⟩ := exists_eq_pow_p_mul' x hx\n      exact ⟨n, b, hb.symm⟩)\n#align discrete_valuation_ring discrete_valuation_ring\n\n",
 "coe_mk_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Heather Macbeth, Johan Commelin\n-/\n@[simp]\ntheorem coe_mk_unit {a : Units k} {A : (expr𝕎) k} (hA : A.coeff 0 = a) : (mk_unit hA : (expr𝕎) k) = A :=\n  rfl\n#align coe_mk_unit coe_mk_unit\n\n",
 "Irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `«expr →+* » -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `expr𝕎 -/\n#print Irreducible /-\ntheorem Irreducible : Irreducible (p : (expr𝕎) k) :=\n  by\n  have hp : ¬IsUnit (p : (expr𝕎) k) := by\n    intro hp\n    simpa only [constant_coeff_apply, coeff_p_zero, not_isUnit_zero] using\n      (constant_coeff : «expr →+* » (witt_vector p k) _).is_unit_map hp\n  refine' ⟨hp, fun a b hab => _⟩\n  obtain ⟨ha0, hb0⟩ : a ≠ 0 ∧ b ≠ 0 := by\n    rw [← mul_ne_zero_iff]\n    intro h\n    rw [h] at hab\n    exact p_nonzero p k hab\n  obtain ⟨m, a, ha, rfl⟩ := verschiebung_nonzero ha0\n  obtain ⟨n, b, hb, rfl⟩ := verschiebung_nonzero hb0\n  cases m\n  · exact or.inl (is_unit_of_coeff_zero_ne_zero a ha)\n  cases n\n  · exact or.inr (is_unit_of_coeff_zero_ne_zero b hb)\n  rw [iterate_verschiebung_mul] at hab\n  apply_fun fun x => coeff x 1  at hab\n  simp only [coeff_p_one, nat.add_succ, add_comm _ n, Function.iterate_succ', Function.comp_apply,\n    verschiebung_coeff_add_one, verschiebung_coeff_zero] at hab\n  exact (one_ne_zero hab).elim\n#align irreducible Irreducible\n-/\n\n"}