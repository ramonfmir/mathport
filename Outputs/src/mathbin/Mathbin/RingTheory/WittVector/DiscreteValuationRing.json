{"is_unit_of_coeff_zero_ne_zero":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr Ë£Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\ntheorem is_unit_of_coeff_zero_ne_zero (x : (exprğ•) k) (hx : x.coeff 0 â‰  0) : IsUnit x :=\n  by\n  let y : Â«expr Ë£Â» k := Units.mk0 (x.coeff 0) hx\n  have hy : x.coeff 0 = y := rfl\n  exact (mk_unit hy).is_unit\n#align is_unit_of_coeff_zero_ne_zero is_unit_of_coeff_zero_ne_zero\n\n",
 "exists_eq_pow_p_mul'":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\ntheorem exists_eq_pow_p_mul' (a : (exprğ•) k) (ha : a â‰  0) : âˆƒ (m : â„•)(b : Units ((exprğ•) k)), a = p ^ m * b :=\n  by\n  obtain âŸ¨m, b, hâ‚, hâ‚‚âŸ© := exists_eq_pow_p_mul a ha\n  let bâ‚€ := Units.mk0 (b.coeff 0) hâ‚\n  have hbâ‚€ : b.coeff 0 = bâ‚€ := rfl\n  exact âŸ¨m, mk_unit hbâ‚€, hâ‚‚âŸ©\n#align exists_eq_pow_p_mul' exists_eq_pow_p_mul'\n\n",
 "exists_eq_pow_p_mul":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\ntheorem exists_eq_pow_p_mul (a : (exprğ•) k) (ha : a â‰  0) : âˆƒ (m : â„•)(b : (exprğ•) k), b.coeff 0 â‰  0 âˆ§ a = p ^ m * b :=\n  by\n  obtain âŸ¨m, c, hc, hcmâŸ© := witt_vector.verschiebung_nonzero ha\n  obtain âŸ¨b, rflâŸ© := (frobenius_bijective p k).surjective.iterate m c\n  rw [witt_vector.iterate_frobenius_coeff] at hc\n  have := congr_fun (witt_vector.verschiebung_frobenius_comm.comp_iterate m) b\n  simp only [Function.comp_apply] at this\n  rw [â† this] at hcm\n  refine' âŸ¨m, b, _, _âŸ©\n  Â· contrapose! hc\n    have : 0 < p ^ m := pow_pos (Nat.Prime.pos (fact.out _)) _\n    simp [hc, zero_pow this]\n  Â· rw [â† mul_left_iterate (p : (exprğ•) k) m]\n    convert hcm\n    ext1 x\n    rw [mul_comm, â† witt_vector.verschiebung_frobenius x]\n#align exists_eq_pow_p_mul exists_eq_pow_p_mul\n\n",
 "discrete_valuation_ring":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/-\nNote: The following lemma should be an instance, but it seems to cause some\nexponential blowups in certain typeclass resolution problems.\nSee the following Lean4 issue as well as the zulip discussion linked there:\nhttps://github.com/leanprover/lean4/issues/1102\n-/\n/-- The ring of Witt Vectors of a perfect field of positive characteristic is a DVR.\n-/\ntheorem discrete_valuation_ring : discrete_valuation_ring ((exprğ•) k) :=\n  discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization\n    (by\n      refine' âŸ¨p, Irreducible p, fun x hx => _âŸ©\n      obtain âŸ¨n, b, hbâŸ© := exists_eq_pow_p_mul' x hx\n      exact âŸ¨n, b, hb.symmâŸ©)\n#align discrete_valuation_ring discrete_valuation_ring\n\n",
 "coe_mk_unit":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/-\nCopyright (c) 2022 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Heather Macbeth, Johan Commelin\n-/\n@[simp]\ntheorem coe_mk_unit {a : Units k} {A : (exprğ•) k} (hA : A.coeff 0 = a) : (mk_unit hA : (exprğ•) k) = A :=\n  rfl\n#align coe_mk_unit coe_mk_unit\n\n",
 "Irreducible":
 "/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `Â«expr â†’+* Â» -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `exprğ• -/\n#print Irreducible /-\ntheorem Irreducible : Irreducible (p : (exprğ•) k) :=\n  by\n  have hp : Â¬IsUnit (p : (exprğ•) k) := by\n    intro hp\n    simpa only [constant_coeff_apply, coeff_p_zero, not_isUnit_zero] using\n      (constant_coeff : Â«expr â†’+* Â» (witt_vector p k) _).is_unit_map hp\n  refine' âŸ¨hp, fun a b hab => _âŸ©\n  obtain âŸ¨ha0, hb0âŸ© : a â‰  0 âˆ§ b â‰  0 := by\n    rw [â† mul_ne_zero_iff]\n    intro h\n    rw [h] at hab\n    exact p_nonzero p k hab\n  obtain âŸ¨m, a, ha, rflâŸ© := verschiebung_nonzero ha0\n  obtain âŸ¨n, b, hb, rflâŸ© := verschiebung_nonzero hb0\n  cases m\n  Â· exact or.inl (is_unit_of_coeff_zero_ne_zero a ha)\n  cases n\n  Â· exact or.inr (is_unit_of_coeff_zero_ne_zero b hb)\n  rw [iterate_verschiebung_mul] at hab\n  apply_fun fun x => coeff x 1  at hab\n  simp only [coeff_p_one, nat.add_succ, add_comm _ n, Function.iterate_succ', Function.comp_apply,\n    verschiebung_coeff_add_one, verschiebung_coeff_zero] at hab\n  exact (one_ne_zero hab).elim\n#align irreducible Irreducible\n-/\n\n"}